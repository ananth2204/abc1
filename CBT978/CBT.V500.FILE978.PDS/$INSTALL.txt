/* We first need rexx in comment if compiled or read from SYSPROC. */
rexx_$install:
  rexxpgm_version = "01.01"          /* Set with 'ver 1' and 'lev 2'. */

  Parse Arg all_my_arguments
  Address ISPEXEC "CONTROL ERRORS RETURN"

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 This code drives Initialization, Process, and Termination routines.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
rexx_Main_Code:
  return_code = Initialzation_routine()
  If (return_code = 0) Then Do
    return_code = Process_routine()
  End
  return_code = Termination_routine()
  Return return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Put the onus on the user if anything should go wrong.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
standard_global_disclaimer:
  Say ""
  Say "STANDARD GLOBAL DISCLAIMER"
  Say "=========================="
  Say "The author explicitly disavows any claim whatsoever about"
  Say "the correctness or functionality of this program, and"
  Say "disclaims liability for anything and everything bad that"
  Say "might happen in connection with, before, during, or after"
  Say "using it. I have tried to make it work right, and I am"
  Say "personally pretty confident that it does, but everybody"
  Say "makes mistakes, so if you use it, you do so at your own"
  Say "risk."
  Say ""
  Say "The extensible nature of this program allows a software"
  Say "developer to add their own externally called upon routines."
  Say "Contact them if their code causes you concerns and/or issues."
  Say ""
  Say "IBM Corporation reserves the right to modify the IDTF"
  Say "format and has done so over the years."
  Say ""
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

  Contact:  "Kenneth E. Tomiak"<CBT_Ken@KTomiak.BIZ>
  Overview: This is an ISPF dialog custom built to install the GENIE
            REXX programs and WISH files on your mainframe computer.

=======================================================================

  History of Modifications
  ------------------------
vv.mm When     Who  /  What you did
----- -------- --------------------------------------------------------
01.01 20180207 "Kenneth E Tomiak"<CBT_Ken@KTomiak.biz>
               1) Adding #2VARS hostdsn is only 44 characters.
               2) Corrected old #INSTALL to $INSTALL.
               3) Switch order of parms passed knowing someone
                  wants to blank them out.
----- -------- --------------------------------------------------------
01.00 20180122 "Kenneth E Tomiak"<CBT_Ken@KTomiak.biz>
               1) Original code started.
----- -------- --------------------------------------------------------

=======================================================================

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 This routine initializes constants and variables.
 Finds from whence this was executed, use the hostdd/hostdsn as
 ISPPLIB and ALTLIB.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Initialzation_routine:
  return_code = 0
  PARSE SOURCE,
    source_host_env,
    source_call_type,
    source_uc_exec_name,
    source_hostdd,
    source_hostdsn,
    source_nf_exec_name,
    source_initial_cmd_env,
    source_asid_name,
    source_char8_user_token,
    source_hostother

  Address TSO "MakeBuf"

  sysvar_sysuid = SYSVAR("SYSUID")
  sysvar_syspref = SYSVAR("SYSPREF")

  If (source_hostdsn = "?") Then Do
    function_rc = find_hostdsn()
  End
  listdsi_rc = Listdsi("'"source_hostdsn"'")
  vdef_volser = SYSVOLUME
  vdef_unit = STRIP(SYSUNIT,"B"," ")

  msg_rc = 0
  ZERRALRM = "On"
  ZERRHM = "MSICPHLP"
  verb_help = "HELP"
  ZERRSM = ask_to_get_help()
  ZERRLM = ""

  libdef_plib = 0
  altlib_exec = 0
  TASKTABL = "TASKTABL"
  vdef_table = "VDEFTABL"
  tbcreate_idtftbl = 0
  tbcreate_tasktbl = 0
  tbcreate_vdef_table = 0

  valid_names = "@#$ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890"

  Address ISPEXEC "LIBDEF ISPPLIB DATASET",
    "ID('"source_hostdsn"') STACK"
  libdef_rc = RC
  If (libdef_rc <> 0) Then Do
    ZERRLM = "LIBDEF of ISPPLIB failed, rc="libdef_rc
    msg_rc = 1
    return_code = libdef_rc
  End
  libdef_plib = 1

  Address TSO ,
    "Altlib Activate Application(EXEC) Dataset('"source_hostdsn"')"
  altlib_rc = RC
  If (altlib_rc <> 0) Then Do
    ZERRLM = "altlib of EXEC failed, rc="altlib_rc
    msg_rc = 1
    return_code = altlib_rc
  End
  altlib_exec = 1

  editdsn = source_hostdsn
  Address ISPEXEC "VPUT (EDITDSN)"

  Return return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 This routine does the processing.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Process_routine:
  Address ISPEXEC "VGET (ZSCREENW)"
  hw = (ZSCREENW - 16) % 2
  ZTDMARK = Copies("-",hw)"> End of Tasks <"Copies("-",hw)
  task_dsn = "'"source_hostdsn"(#1TASKS)'"
  function_rc = Tasks_initialization()
  vars_dsn = "'"source_hostdsn"(#2VARS)'"
  function_rc = Vars_initialization()
  edit_dsn = "'"source_hostdsn"(#3EDIT)'"
  process_rc = Tasks_processing()
  If (ZERRLM <> "") Then Do
    ZERRSM = ask_to_get_help()
    Address ISPEXEC "SETMSG MSG(ISRZ002)"
  End
  return return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 This routine does any pre-termination cleanup.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Termination_routine:
  If (libdef_plib = 1) Then Do
    Address ISPEXEC "LIBDEF ISPPLIB DATASET"
  End
  If (altlib_exec = 1) Then Do
    Address TSO "AltLib Deactivate Application(EXEC)"
  End
  If (tbcreate_tasktbl = 1) Then Do
    Address ISPEXEC,
      "TBEnd TASKTABL"
  End
  If (tbcreate_vdef_table = 1) Then Do
    Address ISPEXEC,
      "TBEnd" vdef_table
  End
  If (return_code > 0) Then Do
    If (msg_rc = 1) Then Do
      If (ZERRSM = "") Then Do
        ZERRSM = "An unhappy ending"
        ZERRLM = "Some unhappy turn of events is sending back",
          "a RETURN code higher than 0 with no message."
      End
      ZERRSM = ask_to_get_help()
      Address ISPEXEC "SETMSG MSG(ISRZ002)"
    End
  End
  Address TSO "DROPBUF"
  Return return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 Search a DD to find where this code runs from.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
find_hostdsn:
  Address ISPEXEC ,
    "QBASELIB" source_hostdd "ID(DSNLIST)"
  ISPEXEC_rc = RC
  If (ISPEXEC_rc <> 0) Then Do
    msg_rc = 1
    ZERRLM = "QBASELIB Failed, RC("ISPEXEC_rc")"
    Return 4
  End
  dsnlist_temp = dsnlist
  @trap_state = TRAPMSG("On")
  msg_state = Msg("OFF")
  Do While dsnlist_temp <> ""
    Parse Var dsnlist_temp one_dsn "," dsnlist_temp
    one_dsn = Strip(one_dsn,"B","'")
    sysdsn_rc = SysDsn("'"one_dsn"("source_uc_exec_name")'")
    If (sysdsn_rc = "OK") Then Do
      source_hostdsn = STRIP(one_dsn,"B"," ")
      Leave
    End
  End
  msg_rc = Msg(msg_state)
  @trap_rc = TRAPMSG(@trap_state)
  Return 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 Convert string to lowercase.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
To_Lowercase: Parse arg myarg
  If (uppercase_letters = "UPPERCASE_LETTERS") Then Do
    uppercase_letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    lowercase_letters = "abcdefghijklmnopqrstuvwxyz"
  End
  Return Translate(myarg,lowercase_letters,uppercase_letters)

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 Convert string to uppercase.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
To_Uppercase: Parse arg myarg
  If (uppercase_letters = "UPPERCASE_LETTERS") Then Do
    uppercase_letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    lowercase_letters = "abcdefghijklmnopqrstuvwxyz"
  End
  Return Translate(myarg,uppercase_letters,lowercase_letters)

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 VGET the PFKEY settings amd map to names.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
pfkeys_by_name:
  pfkeys_verb. = ""
  Address ISPEXEC "VGET (ZPF01, ZPF02, ZPF03, ZPF04, ZPF05, ZPF06," ,
                        "ZPF07, ZPF08, ZPF09, ZPF10, ZPF11, ZPF12," ,
                        "ZPF13, ZPF14, ZPF15, ZPF16, ZPF17, ZPF18," ,
                        "ZPF19, ZPF20, ZPF21, ZPF22, ZPF23, ZPF24)"
  vget_rc = RC
  If (vget_rc <> 0) Then Do
    pfkeys_verb.verb_HELP = "Type HELP and press Enter."
    return vget_rc
  End
  ZPF01 = To_Uppercase(ZPF01)
  ZPF02 = To_Uppercase(ZPF02)
  ZPF03 = To_Uppercase(ZPF03)
  ZPF04 = To_Uppercase(ZPF04)
  ZPF05 = To_Uppercase(ZPF05)
  ZPF06 = To_Uppercase(ZPF06)
  ZPF07 = To_Uppercase(ZPF07)
  ZPF08 = To_Uppercase(ZPF08)
  ZPF09 = To_Uppercase(ZPF09)
  ZPF10 = To_Uppercase(ZPF10)
  ZPF11 = To_Uppercase(ZPF11)
  ZPF12 = To_Uppercase(ZPF12)
  ZPF13 = To_Uppercase(ZPF13)
  ZPF14 = To_Uppercase(ZPF14)
  ZPF15 = To_Uppercase(ZPF15)
  ZPF16 = To_Uppercase(ZPF16)
  ZPF17 = To_Uppercase(ZPF17)
  ZPF18 = To_Uppercase(ZPF18)
  ZPF19 = To_Uppercase(ZPF19)
  ZPF20 = To_Uppercase(ZPF20)
  ZPF21 = To_Uppercase(ZPF21)
  ZPF22 = To_Uppercase(ZPF22)
  ZPF23 = To_Uppercase(ZPF23)
  ZPF24 = To_Uppercase(ZPF24)
  pfkeys_verb.ZPF01 = pfkeys_verb.ZPF01"PF01/"
  pfkeys_verb.ZPF02 = pfkeys_verb.ZPF02"PF02/"
  pfkeys_verb.ZPF03 = pfkeys_verb.ZPF03"PF03/"
  pfkeys_verb.ZPF04 = pfkeys_verb.ZPF04"PF04/"
  pfkeys_verb.ZPF05 = pfkeys_verb.ZPF05"PF05/"
  pfkeys_verb.ZPF06 = pfkeys_verb.ZPF06"PF06/"
  pfkeys_verb.ZPF07 = pfkeys_verb.ZPF07"PF07/"
  pfkeys_verb.ZPF08 = pfkeys_verb.ZPF08"PF08/"
  pfkeys_verb.ZPF09 = pfkeys_verb.ZPF09"PF09/"
  pfkeys_verb.ZPF10 = pfkeys_verb.ZPF10"PF10/"
  pfkeys_verb.ZPF11 = pfkeys_verb.ZPF11"PF11/"
  pfkeys_verb.ZPF12 = pfkeys_verb.ZPF12"PF12/"
  pfkeys_verb.ZPF13 = pfkeys_verb.ZPF13"PF13/"
  pfkeys_verb.ZPF14 = pfkeys_verb.ZPF14"PF14/"
  pfkeys_verb.ZPF15 = pfkeys_verb.ZPF15"PF15/"
  pfkeys_verb.ZPF16 = pfkeys_verb.ZPF16"PF16/"
  pfkeys_verb.ZPF17 = pfkeys_verb.ZPF17"PF17/"
  pfkeys_verb.ZPF18 = pfkeys_verb.ZPF18"PF18/"
  pfkeys_verb.ZPF19 = pfkeys_verb.ZPF19"PF19/"
  pfkeys_verb.ZPF20 = pfkeys_verb.ZPF20"PF20/"
  pfkeys_verb.ZPF21 = pfkeys_verb.ZPF21"PF21/"
  pfkeys_verb.ZPF22 = pfkeys_verb.ZPF22"PF22/"
  pfkeys_verb.ZPF23 = pfkeys_verb.ZPF23"PF23/"
  pfkeys_verb.ZPF24 = pfkeys_verb.ZPF24"PF24/"
  pfkeys_verb.ZPF01 = Strip(pfkeys_verb.ZPF01,"T","/")
  pfkeys_verb.ZPF02 = Strip(pfkeys_verb.ZPF02,"T","/")
  pfkeys_verb.ZPF03 = Strip(pfkeys_verb.ZPF03,"T","/")
  pfkeys_verb.ZPF04 = Strip(pfkeys_verb.ZPF04,"T","/")
  pfkeys_verb.ZPF05 = Strip(pfkeys_verb.ZPF05,"T","/")
  pfkeys_verb.ZPF06 = Strip(pfkeys_verb.ZPF06,"T","/")
  pfkeys_verb.ZPF07 = Strip(pfkeys_verb.ZPF07,"T","/")
  pfkeys_verb.ZPF08 = Strip(pfkeys_verb.ZPF08,"T","/")
  pfkeys_verb.ZPF09 = Strip(pfkeys_verb.ZPF09,"T","/")
  pfkeys_verb.ZPF10 = Strip(pfkeys_verb.ZPF10,"T","/")
  pfkeys_verb.ZPF11 = Strip(pfkeys_verb.ZPF11,"T","/")
  pfkeys_verb.ZPF12 = Strip(pfkeys_verb.ZPF12,"T","/")
  pfkeys_verb.ZPF13 = Strip(pfkeys_verb.ZPF13,"T","/")
  pfkeys_verb.ZPF14 = Strip(pfkeys_verb.ZPF14,"T","/")
  pfkeys_verb.ZPF15 = Strip(pfkeys_verb.ZPF15,"T","/")
  pfkeys_verb.ZPF16 = Strip(pfkeys_verb.ZPF16,"T","/")
  pfkeys_verb.ZPF17 = Strip(pfkeys_verb.ZPF17,"T","/")
  pfkeys_verb.ZPF18 = Strip(pfkeys_verb.ZPF18,"T","/")
  pfkeys_verb.ZPF19 = Strip(pfkeys_verb.ZPF19,"T","/")
  pfkeys_verb.ZPF20 = Strip(pfkeys_verb.ZPF20,"T","/")
  pfkeys_verb.ZPF21 = Strip(pfkeys_verb.ZPF21,"T","/")
  pfkeys_verb.ZPF22 = Strip(pfkeys_verb.ZPF22,"T","/")
  pfkeys_verb.ZPF23 = Strip(pfkeys_verb.ZPF23,"T","/")
  pfkeys_verb.ZPF24 = Strip(pfkeys_verb.ZPF24,"T","/")
  Return vget_rc

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Set a string to press a help PFKey.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
ask_to_get_help:
  pfkey_rc = pfkeys_by_name()
  If (Left(pfkeys_verb.verb_help,2) = "PF") Then Do
    press_this = "Press" pfkeys_verb.verb_help
  End
  Else Do
    press_this = pfkeys_verb.verb_help
  End
  Return press_this

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Read #1TASKS and load into an ISPF table.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Tasks_initialization:
  @trap_state = TRAPMSG("On")
  msg_state = Msg("OFF")
  sysdsn_rc = SysDsn(task_dsn)
  If (sysdsn_rc <> "OK") Then Do
    msg_rc = 1
    return_code = 16
    Return return_code
  End
  msg_rc = Msg(msg_state)
  @trap_state = TRAPMSG(@trap_state)
  capture_state = OutTrap(captured.)
  Address TSO ,
    "ALLOC File(TASKS) DataSet("task_dsn") SHR REUSE"
  alloc_rc = RC
  Address MVS ,
    "EXECIO * DiskR TASKS (Stem tasklist. Finis)"
  execio_rc = RC
  Address TSO ,
    "FREE File(TASKS)"
  free_rc = RC
  restore_state = OutTrap(capture_state)

  Address ISPEXEC,
    "TBEnd TASKTABL"
  Address ISPEXEC,
    "TBCREATE TASKTABL" ,
    "NAMES(TASKZSEL, TASKSEQ, TASKTYPE, TASKITEM," ,
      "TASKDONE, TASKRC, TASKDESC)" ,
    "REPLACE" ,
    "NOWRITE"
  tbcreate_rc = RC
  If (tbcreate_rc <> 0) Then Do
    Select
      When (tbcreate_rc = 4) Then Do
        ZERRLM = "4 - Duplicate table exists but 'replace' specified"
      End
      When (tbcreate_rc = 8) Then Do
        ZERRLM = "8 - Table already exists; 'replace' not specified"
      End
      When (tbcreate_rc = 12) Then Do
        ZERRLM = "Table in use; enq failed"
      End
      When (tbcreate_rc = 16) Then Do
        ZERRLM = "Table input library not allocated with 'write'"
      End
      When (tbcreate_rc = 20) Then Do
        ZERRLM = "Severe error"
      End
      Otherwise Do
        ZERRLM = tbcreate_rc "is a new value to this code."
      End
    End
    Return tbcreate_rc
  End
  tbcreate_tasktbl = 1
  Do tx = 1 to tasklist.0
    If (Left(tasklist.tx,1) = "*") Then Iterate
    Parse Var tasklist.tx ,
          tasklist_seq.tx +3 ,
       =5 tasklist_type.tx +7 ,
      =13 tasklist_item.tx +8 ,
      =70 tasklist_done.tx +8 ,
      =79 tasklist_status.tx +2 .
    tasklist_item.tx = Strip(tasklist_item.tx,"T"," ")
    Address ISPEXEC "TBVCLEAR TASKTABL"
    TASKSEQ = tasklist_seq.tx
    TASKTYPE = tasklist_type.tx
    TASKITEM = tasklist_item.tx
    TASKDONE = tasklist_done.tx
    TASKRC = tasklist_status.tx
    tx = tx + 1
    tasklist_descr.tx = Strip(tasklist.tx,"T"," ")
    TASKDESC = tasklist_descr.tx
    Address ISPEXEC "TBAdd TASKTABL"
    tbadd_rc = RC
    If (tbadd_rc <> 0) Then Do
      Select
        When (tbadd_rc = 4) Then Do
          ZERRLM = "TASKTABL TBADD, Number of rows parameter" ,
                   "was specified but storage" ,
                   "was only obtained for a" ,
                   "single row"
          msg_rc = 1
        End
        When (tbadd_rc = 8) Then Do
          ZERRLM = "TASKTABL TBADD, Key tables: a row with the" ,
                   "same key already exists;" ,
                   "crp set to top"
        End
        When (tbadd_rc = 12) Then Do
          ZERRLM = "TASKTABL TBADD, Table is not open"
          msg_rc = 1
        End
        When (tbadd_rc = 16) Then Do
          ZERRLM = "TASKTABL TBADD, Severe error"
          msg_rc = 1
        End
        Otherwise Do
          ZERRLM = "TASKTABL TBADD," ,
            tbadd_rc "is a new value to this code."
          msg_rc = 1
        End
      End
    End
  End
  Address ISPEXEC "TBSort TASKTABL Fields(taskseq,C,A)"
  Address ISPEXEC "TBTop TASKTABL"
  Return return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Read #2VARS and load into an ISPF table.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Vars_initialization:
  @trap_state = TRAPMSG("On")
  msg_state = Msg("OFF")
  sysdsn_rc = SysDsn(vars_dsn)
  If (sysdsn_rc <> "OK") Then Do
    msg_rc = 1
    return_code = 16
    Return return_code
  End
  msg_rc = Msg(msg_state)
  @trap_state = TRAPMSG(@trap_state)
  Address TSO ,
    "ALLOC File(VARS) DataSet("vars_dsn") SHR REUSE"
  alloc_rc = RC
  Address MVS ,
    "EXECIO * DiskR VARS (Stem varslist. Finis)"
  execio_rc = RC
  Address TSO ,
    "FREE File(VARS)"
  free_rc = RC
  Address ISPEXEC,
    "TBCLOSE" vdef_table
  Address ISPEXEC,
    "TBEnd" vdef_table
  Address ISPEXEC,
    "TBCREATE" vdef_table ,
    "NAMES(VDEFVAR, VDEFATTR, VDEFLEN," ,
      "VDEFVAL, VDEFDESC)" ,
    "SHARE" ,
    "NOWRITE"
  tbcreate_rc = RC
  If (tbcreate_rc <> 0) Then Do
    ZERRLM = tbcreate_rc "unexpected"
    Return tbcreate_rc
  End
  tbcreate_vdef_table = 1
  vdefine_list = ""
  vdefine_attrib. = ""
  vdefine_length. = 0
  vdefine_val. = ""
  Do tx = 1 to varslist.0
    If (Left(varslist.tx,1) = "*") Then Iterate
    Parse Var varslist.tx ,
          varslist_item.tx +8 ,
      =10 varslist_attr.tx +2 ,
      =13 varslist_len.tx " " . ,
      =20 varslist_desc.tx
    varslist_item.tx = Strip(varslist_item.tx,"T"," ")
    varslist_desc.tx = Strip(varslist_desc.tx,"T"," ")
    varslist_key = varslist_item.tx
    vdefine_list = vdefine_list||varslist_key" "
    vdefine_var.varslist_key = tx
    ox = tx
    tx = tx + 1
    varslist_val = Left(varslist.tx,varslist_len.ox)
    Address ISPEXEC "TBVCLEAR" vdef_table
    VDEFVAR = varslist_key
    VDEFATTR = varslist_attr.ox
    VDEFLEN  = varslist_len.ox
    VDEFDESC = varslist_desc.ox
    VDEFVAL  = varslist_val
    Address ISPEXEC "TBAdd" vdef_table
    Select
      When (vdefvar = "WISHLIST") THEN vdef_wishlist = vdefval
      When (vdefvar = "VOLSER") THEN vdef_volser = vdefval
      When (vdefvar = "UNIT") THEN vdef_unit = vdefval
      Otherwise DO
        NOP
      END
    END
  End
  function_rc = get_variable_value("HOSTDSN")
  IF (function_rc = "") THEN DO
    Address ISPEXEC "TBVCLEAR" vdef_table
    VDEFVAR = "HOSTDSN"
    VDEFATTR = "DS"
    VDEFLEN  = 44
    VDEFDESC = "The data set used to launch $INSTALL."
    VDEFVAL  = source_hostdsn
    Address ISPEXEC "TBAdd" vdef_table
  END
  function_rc = get_variable_value("UNIT")
  IF (function_rc = "") THEN DO
    Address ISPEXEC "TBVCLEAR" vdef_table
    VDEFVAR = "UNIT"
    VDEFATTR = "UC"
    VDEFLEN  = 8
    VDEFDESC = "Name of DISK volume for new data sets."
    VDEFVAL  = vdef_unit
    Address ISPEXEC "TBAdd" vdef_table
  END
  function_rc = get_variable_value("VOLSER")
  IF (function_rc = "") THEN DO
    Address ISPEXEC "TBVCLEAR" vdef_table
    VDEFVAR = "VOLSER"
    VDEFATTR = "UC"
    VDEFLEN  = 8
    VDEFDESC = "Name of DISK volume for new data sets."
    VDEFVAL  = vdef_volser
    Address ISPEXEC "TBAdd" vdef_table
  END
  function_rc = get_variable_value("ZUSER")
  IF (function_rc = "") THEN DO
    Address ISPEXEC "TBVCLEAR" vdef_table
    VDEFVAR = "ZUSER"
    VDEFATTR = "UC"
    VDEFLEN  = 8
    VDEFDESC = "Your current USERID."
    VDEFVAL  = sysvar_sysuid
    Address ISPEXEC "TBAdd" vdef_table
  END

  Return return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Display the task table until the user exits.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Tasks_processing:
  Address ISPEXEC "VGET (ZSCREENW)"
  hw = (ZSCREENW - 16) % 2
  ZTDMARK = Copies("-",hw)"> End of tasks <"Copies("-",hw)
  msicptsk_tbdispl_rc = 0
  Do While (msicptsk_tbdispl_rc < 8)
    Address ISPEXEC "TBDISPL TASKTABL PANEL(MSICPTSK)"
    msicptsk_tbdispl_rc = RC
    Select
      When (msicptsk_tbdispl_rc = 8) Then Do
        Leave
      End
      When (msicptsk_tbdispl_rc > 4) Then Do
        ZERRLM = "RC is too high," msicptsk_tbdispl_rc"."
        msg_rc = 1
        return msicptsk_tbdispl_rc
      End
      Otherwise Do
        tasks_zcmd_rc = tasks_zcmd_procesing()
        If (tasks_zcmd_rc <> 0) Then Do
          return tasks_zcmd_rc
        End
        tasks_zsel_rc = tasks_zsel_procesing()
      End
    End
  End
  return return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Process ==>Command options.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
tasks_zcmd_procesing:
  msg_rc = 0
  task_zcmd = ZCMD
  ZCMD = ""
  Select
    When (task_zcmd = "") Then Do
      return return_code
    End
    When (To_Uppercase(task_zcmd) = "X") Then Do
      ZERRSM = "Okay"
      ZERRLM = "You used X to leave."
      Address ISPEXEC "SETMSG MSG(ISRZ002)"
      return_code = 8
    End
    Otherwise Do
      ZERRSM = "What?"
      ZERRLM = "Choose a valid option or feature."
      Address ISPEXEC "SETMSG MSG(ISRZ002)"
    End  /* End of OTHERWISE */
  End  /* End of SELECT  */
  Return return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Loop thru the selected task rows.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
tasks_zsel_procesing:
  msicptsk_tbdispl_rc = 0
  Do While (ZTDSELS > 0)
    TASKZSEL = To_Uppercase(TASKZSEL)
    function_rc = tasks_row_selection()
    TASKZSEL = ""
    Address ISPEXEC "TBPUT TASKTABL"
    save_rc = tasks_save_state()
    If (ZTDSELS > 1) Then Do
      Address ISPEXEC "TBDISPL TASKTABL"
      msicptsk_tbdispl_rc = RC
    End
    Else Do
      ZTDSELS = 0
    End
  End
  Return msicptsk_tbdispl_rc

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
-----------------------------------------------------------------------
 Process the ROW selection.
-----------------------------------------------------------------------
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
tasks_row_selection:
  Select
    When (TASKZSEL = "S") Then Do
      Select
        When (To_uppercase(TASKTYPE) = "BROWSE") Then Do
          out_dsn = "'"source_hostdsn"("taskitem")'"
          Address ISPEXEC "Control Display Save"
          orig_zscr = ZSCR
          Address ISPEXEC "Browse DATASET("OUT_DSN")"
          browse_rc = RC
          Address ISPEXEC "Control Display Restore"
          ZSCR = orig_zscr
          taskdone = Date("S")
          taskrc = "00"
          If (browse_rc <> 0) Then Do
            ZERRSM = ask_to_get_help()
            ZERRLM = "Configuration error," taskitem "not present."
            Address ISPEXEC "SETMSG MSG(ISRZ002)"
            taskrc = "NG"
          End
        End
        When (To_uppercase(TASKTYPE) = "EDIT") Then Do
          out_dsn = "'"source_hostdsn"("taskitem")'"
          Address ISPEXEC "Control Display Save"
          orig_zscr = ZSCR
          Address ISPEXEC "EDIT DATASET("OUT_DSN")"
          EDIT_rc = RC
          Address ISPEXEC "Control Display Restore"
          ZSCR = orig_zscr
          taskdone = Date("S")
          taskrc = "00"
          If (EDIT_rc <> 0) Then Do
            ZERRSM = ask_to_get_help()
            ZERRLM = "Configuration error," taskitem "not present."
            Address ISPEXEC "SETMSG MSG(ISRZ002)"
            taskrc = "NG"
          End
        End
        When (To_uppercase(TASKTYPE) = "VIEW") Then Do
          out_dsn = "'"source_hostdsn"("taskitem")'"
          Address ISPEXEC "Control Display Save"
          orig_zscr = ZSCR
          Address ISPEXEC "VIEW DATASET("OUT_DSN")"
          VIEW_rc = RC
          Address ISPEXEC "Control Display Restore"
          ZSCR = orig_zscr
          taskdone = Date("S")
          taskrc = "00"
          If (VIEW_rc <> 0) Then Do
            ZERRSM = ask_to_get_help()
            ZERRLM = "Configuration error," taskitem "not present."
            Address ISPEXEC "SETMSG MSG(ISRZ002)"
            taskrc = "NG"
          End
        End
        When (To_uppercase(TASKTYPE) = "EXECUTE") Then Do
          Address ISPEXEC "Control Display Save"
          SELECT
            WHEN (taskitem = "MSICCOPY") THEN DO
              function_rc = get_variable_value("SYSEXEC")
              Address ISPEXEC "SELECT CMD("taskitem ,
                source_hostdsn vdefval")"
            END
            WHEN (taskitem = "MSICDEFN") THEN DO
              Address ISPEXEC "SELECT CMD("taskitem ,
                vdef_wishlist source_hostdsn vdef_volser vdef_unit")"
            END
            WHEN (taskitem = "MSICREDT") THEN DO
              Address ISPEXEC "SELECT CMD("taskitem ,
                source_hostdsn")"
            END
            WHEN (taskitem = "GENIEBLD") THEN DO
              Address ISPEXEC "SELECT CMD("taskitem ,
                vdef_wishlist")"
            END
            OTHERWISE DO
              Address ISPEXEC "SELECT CMD("taskitem ,
                vdef_wishlist source_hostdsn ,
                taskitem vdef_volser vdef_unit")"
            END
          END
          execute_rc = RC
          Address ISPEXEC "Control Display Restore"
          taskdone = Date("S")
          taskrc = Right(execute_rc,2,"0")
        End
        When (To_uppercase(TASKTYPE) = "ROUTINE") Then Do
          Interpret "routine_rc = "taskitem"_routine()"
          taskdone = Date("S")
          taskrc = Right(routine_rc,2,"0")
        End
        When (To_uppercase(TASKTYPE) = "SUBMIT") Then Do
          out_dsn = "'"source_hostdsn"("taskitem")'"
          Address ISPEXEC "Control Display Save"
          orig_zscr = ZSCR
          @outtrap_state = OutTrap(@caughtit.)
          Address ISPEXEC "Edit DATASET("OUT_DSN") MACRO(MSICMMBR)"
          submit_rc = RC
          @outtrap_state = OutTrap(@outtrap_state)
          Do oxx = 1 to @caughtit.0
            say @caughtit.oxx
          End
          Address ISPEXEC "Control Display Restore"
          ZSCR = orig_zscr
          taskdone = Date("S")
          taskrc = Right(submit_rc,2,"0")
        End
        Otherwise Do
          ZERRSM = ask_to_get_help()
          ZERRLM = "Not ready to" tasktype "on" taskitem"."
          Address ISPEXEC "SETMSG MSG(ISRZ002)"
        End
      End
    End
    Otherwise Do
      ZERRSM = "What?"
      ZERRLM = "Use a valid line command (S)."
      Address ISPEXEC "SETMSG MSG(ISRZ002)"
    End
  End
  Return 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Internal routine to prompt for variable values.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
$SETVARS_routine:
  Address ISPEXEC "TBSort" vdef_table "Fields(VDEFVAR,C,A)"
  Address ISPEXEC "TBTop" vdef_table
  Address ISPEXEC "VGET (ZSCREENW)"
  hw = (ZSCREENW - 16) % 2
  ZTDMARK = Copies("-",hw)"> End of variables <"Copies("-",hw)
  msicpvar_tbdispl_rc = 0
  Address ISPEXEC "CONTROL DISPLAY SAVE"
  Do While (msicpvar_tbdispl_rc < 8)
    msicpvar_tbdispl_rc = vdef_tbdispl_panel()
  End
  Address ISPEXEC "CONTROL DISPLAY RESTORE"
  return return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 In this routine we display the variable intake panel.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
vdef_tbdispl_panel:
  Address ISPEXEC "TBDISPL" vdef_table "PANEL(MSICPVAR)"
  msicpvar_tbdispl_rc = RC
  Select
    When (msicpvar_tbdispl_rc = 8) Then Do
      return msicpvar_tbdispl_rc
    End
    When (msicpvar_tbdispl_rc > 4) Then Do
      ZERRLM = "RC is too high," msicpvar_tbdispl_rc"."
      return msicpvar_tbdispl_rc
    End
    Otherwise Do
      vdef_zcmd_rc = vdef_zcmd_procesing()
      If (vdef_zcmd_rc <> 0) Then Do
        return vdef_zcmd_rc
      End
      vdef_zsel_rc = vdef_zsel_procesing()
    End
  End
  If (msicpvar_tbdispl_rc = 8) Then Do
    return return_code
  End
  return return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 In this routine we process the zcmd from the variable intake panel.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
vdef_zcmd_procesing:
  msg_rc = 0
  vdef_zcmd = ZCMD
  ZCMD = ""
  Select
    When (vdef_zcmd = "") Then Do
      return return_code
    End
    When (To_Uppercase(vdef_zcmd) = "X") Then Do
      ZERRSM = "Okay"
      ZERRLM = "You used X to leave."
      Address ISPEXEC "SETMSG MSG(ISRZ002)"
      return_code = 8
    End
    Otherwise Do
      ZERRSM = "What?"
      ZERRLM = "Choose a valid option or feature."
      Address ISPEXEC "SETMSG MSG(ISRZ002)"
    End  /* End of OTHERWISE */
  End  /* End of SELECT  */
  Return return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Process all VDEF row changes.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
vdef_zsel_procesing:
  msicpvar_tbdispl_rc = 0
  valid_msg = 0
  ZERRLM = ""
  Do While (ZTDSELS > 0)
    function_rc = vdef_row_selection()
    Address ISPEXEC "TBPUT" vdef_table
    save_rc = vdef_save_updates()
    If (ZTDSELS > 1) Then Do
      Address ISPEXEC "TBDISPL" vdef_table
      msicpvar_tbdispl_rc = RC
    End
    Else Do
      ztdsels = 0
    End
  End
  If (valid_msg = 1) Then Do
    ZERRSM = "Validaion results"
    Address ISPEXEC "SETMSG MSG(ISRZ002)"
  End
  Return msicpvar_tbdispl_rc

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
-----------------------------------------------------------------------
 Process the VDEF ROW selection.
 Validate the value matches the attribute and length.
 DS, LC, MB, MC, N, UC
-----------------------------------------------------------------------
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
vdef_row_selection:
  good_name = 1
  vdefvar = Strip(vdefvar,"T"," ")
  Select
    When (vdefattr = "DS") Then Do
      vdefval = To_Uppercase(Strip(vdefval,"T"," "))
      dsn@len = Length(vdefval)
      If (dsn@len <= vdeflen) Then Do
        tmp_dsn = vdefval
        If (Pos("'",tmp_dsn) > 0) Then Do
          tmp_dsn = Strip(tmp_dsn,"B","'")
        End
        Else Do
          Parse Var vdefval one_qual "." .
          If (one_qual <> sysvar_syspref) Then Do
            tmp_dsn = sysvar_syspref"."tmp_dsn
          End
        End
        Do While (tmp_dsn <> "")
          Parse Var tmp_dsn one_qual "." tmp_dsn
          If (Pos(Left(one_qual,1),Left(valid_names,29)) = 0 ) Then Do
            good_name = 0
            ZERRLM = ZERRLM || ,
              Left(vdefvar "1st character bad:" Left(one_qual,1),79)
          End
          mbr@len = Length(one_qual)
          Do ltr = 2 to mbr@len
            If (Pos(SubStr(one_qual,ltr,1),valid_names) = 0 ) Then Do
              good_name = 0
              ZERRLM = ZERRLM || ,
                Left(vdefvar ltr ,
                  "character bad:" SubStr(one_qual,ltr,1),79)
            End
          End
        End
      End
      Else Do
        good_name = 0
        ZERRLM = ZERRLM || ,
          Left(vdefvar dsn@len "length exceeds" vdeflen,79)
      End
    End
    When (vdefattr = "LC") Then Do
      vdefval = To_Lowercase(vdefval)
    End
    When (vdefattr = "MB") Then Do
      vdefval = To_Uppercase(vdefval)
      mbr@len = Length(vdefval)
      good_name = 1
      If (mbr@len > vdeflen) Then Do
        If (Pos(Left(vdefval,1),Left(valid_names,29)) = 0 ) Then Do
          good_name = 0
          ZERRLM = ZERRLM || ,
            Left(vdefvar "1st character bad:" Left(vdefval,1),79)
        End
        Do ltr = 2 to mbr@len
          If (Pos(SubStr(vdefval,ltr,1),valid_names) = 0 ) Then Do
            good_name = 0
            ZERRLM = ZERRLM || ,
              Left(vdefvar ltr ,
                "character bad:" SubStr(vdefval,ltr,1),79)
          End
        End
      End
      Else Do
        good_name = 0
        ZERRLM = ZERRLM || ,
          Left(vdefvar mbr@len "length exceeds" vdeflen,79)
      End
    End
    When (vdefattr = "MC") Then Do
      NOp
    End
    When (vdefattr = "N") Then Do
      good_name = 1
      val@len = Length(vdefval)
      If (val@len > vdeflen) Then Do
        good_name = 0
        ZERRLM = ZERRLM || ,
          Left(vdefvar val@len "length exceeds" vdeflen,79)
      End
      If (DataType(vdefval) <> "NUM") Then Do
        good_name = 0
        ZERRLM = ZERRLM || ,
          Left(vdefvar "is not numeric",79)
      End
    End
    When (vdefattr = "UC") Then Do
      vdefval = To_Uppercase(vdefval)
    End
    When (vdefattr = "XM") Then Do
      val@len = Length(vdefval)
      If (val@len > vdeflen) Then Do
        good_name = 0
        ZERRLM = ZERRLM || ,
          Left(vdefvar val@len "length exceeds" vdeflen,79)
      End
      xmit_dsn = "'"source_hostdsn"("vdefvar")'"
      Address TSO "Alloc File(INMRCK)" ,
        "Dataset("xmit_dsn") SHR REUSE"
      Address MVS "Execio 1 DISKR INMRCK (Stem inmr. FINIS)"
      Address TSO "Free File(INMRCK)"
      If (Pos("\INMR01",inmr.1) <> 2) Then Do
        good_name = 0
        ZERRLM = ZERRLM || ,
          Left(vdefvar "is not an IDTF file XM INMR01<>2",79)
      End
    End
    Otherwise Do
      msg_rc = 1
      ZERRLM = ZERRLM || ,
        Left(vdefvar vdefattr "is a bad attribute to me.",79)
    End
    Select
      When (vdefvar = "WISHLIST") THEN vdef_wishlist = vdefval
      When (vdefvar = "VOLSER") THEN vdef_volser = vdefval
      When (vdefvar = "UNIT") THEN vdef_unit = vdefval
      Otherwise DO
        NOP
      END
    END
  End
  If (good_name = 0) Then Do
    vdefzsel = "ERR"
  End
  Else Do
    ZERRLM = ZERRLM || ,
      Left(vdefvar "OK",79)
  End
  valid_msg = 1
  Return 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Search for the named variable and retrieve its value.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
get_variable_value:
  parse arg my_var
  Address IspExec "TBTOP VDEFTABL"
  Address IspExec "TBVCLEAR VDEFTABL"
  VDEFVAR = my_var
  Address IspExec "TBSARG VDEFTABL" ,
    "Next NameCond(VDEFVAR,EQ)"
  tbsarg_rc = RC
  Address IspExec "TBScan VDEFTABL"
  tbscan_rc = RC
  If (tbscan_rc <> 0) then vdefval = ""
  Return vdefval

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Save the updated #1TASKS list.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
tasks_save_state:
  line_of_code = get_my_sigl() + 2
/* Tasklist
*
* Mainframe Software Installation Customizer (MSIC)
*
* Tasks require 2 records.
* Record 1:
* =====================================================================
* Seq    N3 Three digit sequence identifier
* Type   C7 What it is you want to do.
*             Browse : Let the user BROWSE a PDS member.
*             Edit   : Let the user EDIT a PDS member.
*             Execute: Run some external REXX code.
*             Receive: Receive all XM variables.
*             Routine: Run an internal REXX routine.
*             Submit : Submit a member to run in the background.
*             View : Let the user VIEW a PDS member.
* Item   C8 What is acted upon.
* Done   D8 The last attempt date filled in by MSIC.
* Status C2 How that last attempt fared filled in by MSIC.
*
* Record 2:
* =====================================================================
* Desc  : A descriptive bit of text.
*
*---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
*SQ Type    Item     Description goes on a second line               Done     St
*== ======= ======== =============================================== ======== ==
End */
  tasklist. = ""
  task_ctr = 0
  Do While (SourceLine(line_of_code) <> "End */")
    task_ctr = task_ctr + 1
    tasklist.task_ctr = SourceLine(line_of_code)
    line_of_code = line_of_code + 1
  End
  Address ISPEXEC "TBTop TASKTABL"
  tbskip_rc = 0
  Do While (tbskip_rc = 0)
    Address ISPEXEC "TBSkip TASKTABL"
    tbskip_rc = RC
    If (tbskip_rc = 0) Then Do
      task_ctr = task_ctr + 1
      tasklist.task_ctr = Right(taskseq,3,"0") ,
        Left(tasktype,7) Left(taskitem,8) ,
        Copies(" ",47) Left(taskdone,8) Left(Taskrc,2)
      task_ctr = task_ctr + 1
      tasklist.task_ctr = taskdesc
    End
  End
  task_ctr = task_ctr + 1
  tasklist.task_ctr = "*"
  task_ctr = task_ctr + 1
  tasklist.task_ctr = "* End of #1TASKS."
  @trap_state = TRAPMSG("On")
  msg_state = Msg("OFF")
  Address TSO ,
    "ALLOC File(TASKS) DataSet("task_dsn") SHR REUSE"
  alloc_rc = RC
  Address MVS ,
    "EXECIO * Diskw TASKS (Stem tasklist. Finis)"
  execio_rc = RC
  Address TSO ,
    "FREE File(TASKS)"
  free_rc = RC
  msg_rc = Msg(msg_state)
  @trap_state = TRAPMSG(@trap_state)
  Return 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Save the updated #2VARS list.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
vdef_save_updates:
  line_of_code = get_my_sigl() + 2
/* Varlist
*
* Mainframe Software Installation Customizer (MSIC)
*
* Variables require 2 records.
* Record 1:
* =====================================================================
* ITEM         C8 The variable name.
*                 You will wrap it with exclamation marks when used.
* Attribute    C2 Provides for limited validation and identification.
*                   DS = Data set name
*                   LC = Lowercase
*                   MB = Member name
*                   MC = Mixed case (ASIS)
*                   N  = Number (digits)
*                   UC = Uppercase
*                   XM = IDTF member to DSName.
* Length      N2  The maximum size of the value.
* Description C61 Describes what the variable is used for.
*
* Record 2:
* =====================================================================
* The initial default value or the user specified value.
*
*---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
*Item    A  Length Description (value is on the next row).
*======= == ====== =============================================================
End */
  vdeflist. = ""
  vdef_ctr = 0
  Do While (SourceLine(line_of_code) <> "End */")
    vdef_ctr = vdef_ctr + 1
    vdeflist.vdef_ctr = SourceLine(line_of_code)
    line_of_code = line_of_code + 1
  End
  Address ISPEXEC "TBTop" vdef_table
  tbskip_rc = 0
  Do While (tbskip_rc = 0)
    Address ISPEXEC "TBSkip" vdef_table
    tbskip_rc = RC
    If (tbskip_rc = 0) Then Do
      vdef_ctr = vdef_ctr + 1
      vdeflist.vdef_ctr = Left(vdefvar,8) ,
        left(vdefattr,2) Left(vdeflen,6) Left(vdefdesc,61)
      vdef_ctr = vdef_ctr + 1
      vdeflist.vdef_ctr = Left(vdefval,80)
      Select
        When (vdefvar = "WISHLIST") THEN vdef_wishlist = vdefval
        When (vdefvar = "VOLSER") THEN vdef_volser = vdefval
        When (vdefvar = "UNIT") THEN vdef_unit = vdefval
        Otherwise DO
          NOP
        END
      END
    End
  End
  vdef_ctr = vdef_ctr + 1
  vdeflist.vdef_ctr = "*"
  vdef_ctr = vdef_ctr + 1
  vdeflist.vdef_ctr = "* End of #2VARS. Saved:" Date("S") Time()
  @trap_state = TRAPMSG("On")
  msg_state = Msg("OFF")
  Address TSO ,
    "ALLOC File(VARS) DataSet("vars_dsn") SHR REUSE"
  alloc_rc = RC
  Address MVS ,
    "EXECIO * Diskw VARS (Stem vdeflist. Finis)"
  execio_rc = RC
  Address TSO ,
    "FREE File(VARS)"
  free_rc = RC
  msg_rc = Msg(msg_state)
  @trap_state = TRAPMSG(@trap_state)
  Return 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Return from which line this was called from.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
get_my_sigl: Return sigl

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 More than just rounding.
   Floor always goes down to a multiple of height.
   Ceiling always goes up to a multiple of height.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Floor_rtn: Procedure
  Parse Arg @number, @height
  @occurs = (@number % @height)
  Select
    When (@remainder = 0) Then @adjustment = 0
    When (@number < 0) Then @adjustment = -1
    Otherwise Do
      @adjustment = 0
    End
  End
  @result = (@occurs + @adjustment) * @height
  return @result

Ceiling_rtn: Procedure
  Parse Arg @number, @height
  @occurs = @number % @height
  @remainder = @number - (@occurs * @height)
  Select
    When (@remainder = 0) Then @adjustment = 0
    When (@number > 0) Then @adjustment = 1
    Otherwise Do
      @adjustment = 0
    End
  End
  @result = (@occurs + @adjustment) * @height
  return @result

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Set the short message to press a help PFKey.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
trapped_an_error:
  Signal Off Error
  Signal Off Failure
  Signal Off Syntax
  error_line = Sigl
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "!ERR!"
  INFOVAL = "On or near" error_line":"Sourceline(error_line)
  Address ISPEXEC "TBAdd infotabl"
  ZERRSM = ask_to_get_help()
  ZERRLM = ZERRLM || ,
    Left("Bad IDTF data set - truncated?",79)
  Address ISPEXEC "SETMSG MSG(ISRZ002)"
  interpret "call" back_here
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 End of code.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
__DATA__
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */

