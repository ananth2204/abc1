{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013641000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 11933558, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 15, "INMDSNAM": "CBT.V500.FILE978.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 11933558, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 11933558, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE978.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\xb6\\x07'", "DS1TRBAL": "b'P\\xe2'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\n4\\x00\\x02\\n@\\x00\\x04\\x00\\xb7'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04`\\x00#\\x01\\x180\\x8f\\x01\\x180\\x8f\\x16$\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf6@@@'", "ispf": {"version": "04.96", "flags": 0, "createdate": "2018-11-04T00:00:00", "modifydate": "2018-11-04T16:24:23", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-496"}, "text": "REGULAR CBT TAPE - VERSION 496    FILE:  978\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT496.FILE978\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 54 MEMBERS COUNTED; CUMULATIVE SIZE IS 112,741 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   11/04/18    16:24:22    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$#README": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x14\\x01\\x17 \\x7f\\x01\\x18\\x14O\\x11U\\x00Q\\x00\\x01\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2017-07-26T00:00:00", "modifydate": "2018-05-24T11:55:14", "lines": 81, "newlines": 1, "modlines": 0, "user": "KTOMIAK"}, "text": "\n       Genuine Every Noteworthy Itemized Examplizer (GENIE)\n\nThis FreeWare Tool is an ISPF Edit macro that mimics the MODEL\ncommand, while being robustly extensible in the number of WISH items\nGENIE can grant.\n\nThe author has a large list of manuals to be turned into WISH items. Feel\nfree to contact Kenneth Tomiak if you want to help build WISH members or\nhave your own TOPIC you would like to have included.\n\n\n$$README:\n========================================================================\nThis collection is best used by placing the two REXX programs\nin your //SYSEXEC concatenation.\n\nGENIE can be made available to all types of developers. However, the breadth of\ncontent may overwhelm all but the System Programmer this was written for. For\nthat reason you might want to create tailored WISHLIST data sets for different\nroles (SYSPROG, PGMR, SCHEDOPS). You would create more than one WISHLIST data\nset if you are keen on limiting what the user has access to. There are sample\nstatements in the GENIE code on how to use more than one WISH data set assigned\nby your logic.\n\nGENIEBLD is meant solely for the administrator (System Programmer)\nthat manages the WISHLIST data set. It must be run against a WISHLIST data set\nthat has been updated.\n\n\nINSTALLATION\n========================================================================\nThis FreeWare Tool is installed by executing the $INSTALL REXX program. You will\nbe shown a list of tasks, some optional, that are to be executed in sequence.\nThe result will be one WISHLIST data set holding all of the topics you selected\nfor inclusion. You can redrive the installation process and choose alternate\nWISHLIST data sets if you are providing tailored topics for different roles.\n\n\nCONFIGURATION\n========================================================================\nAnytime you modify the WISHLIST data set you will need to rebuild\nthe $$$$0501 member by running GENIEBLD. I prefer using ISPF\n3.4 to pull up a list of WISHLIST data sets and then using line command\n%GENIEBLD /\nto run the REXX code on the data set. It validates the syntax,\nnot the content, of WISH members and either displays an error\nreport or overlays the existing $$$$0501 member.\n\n\nUSAGE\n========================================================================\nWhile in EDIT or VIEW you can invoke the GENIE EDIT macro using the command\nfield.\n\nSyntax:\n\n  %genie {wish} | {?}\n\n  The percent sign is used to speed up searching //SYSPROC\n  and //SYSEXEC, ignoring load modules from system libraries.\n\n  Optional {wish} asks for a known item. If it is not found then\n  the normal panel display of topics will be presented.\n\n  Optional {?} asks to see the GENIE primary commands help\n  prompt at startup.\n\n  Expand any TOPIC to see CHAPTERS and expand CHAPTERS to see ITEMS.\n\n\nEXTENSIBILITY\n========================================================================\nCarefully choose a TOPIC prefix and add your own WISH members.\nSee GENIE TOPIC $$$$ Chapter 4 for more details.\n\nUse an existing WISH member as a template.\nPay attention to how column one is used.\nCreate your TOPIC, CHAPTER(s), and WISH(es).\nExecute GENIEBLD to update the $$$$0501 member.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$DISCLAM": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x002\\x01\\x18\\x03/\\x01\\x18\\x03?\\x07\\x18\\x00\\x0c\\x00\\x10\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-02-01T00:00:00", "modifydate": "2018-02-02T07:18:32", "lines": 12, "newlines": 16, "modlines": 0, "user": "KTOMIAK"}, "text": "\nSTANDARD GLOBAL DISCLAIMER\n--------------------------\nThe author explicitly disavows any claim whatsoever about the\ncorrectness or functionality of this program, and disclaims liability\nfor anything and everything bad that might happen in connection with,\nbefore, during, or after using it. I have tried to make it work right,\nand I am personally pretty confident that it does, but everybody makes\nmistakes, so if you use it, you do so at your own risk.\n\nSincerely yours,\n\"Kenneth E Tomiak\"<CBT_Ken@KTomiak.biz>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$INSTALL": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x008\\x01\\x18\\x02O\\x01\\x18\\x03\\x9f\\x07'\\x05\\x08\\x04\\xd1\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-01-24T00:00:00", "modifydate": "2018-02-08T07:27:38", "lines": 1288, "newlines": 1233, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\nrexx_$install:\n  rexxpgm_version = \"01.01\"          /* Set with 'ver 1' and 'lev 2'. */\n\n  Parse Arg all_my_arguments\n  Address ISPEXEC \"CONTROL ERRORS RETURN\"\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nrexx_Main_Code:\n  return_code = Initialzation_routine()\n  If (return_code = 0) Then Do\n    return_code = Process_routine()\n  End\n  return_code = Termination_routine()\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Put the onus on the user if anything should go wrong.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nstandard_global_disclaimer:\n  Say \"\"\n  Say \"STANDARD GLOBAL DISCLAIMER\"\n  Say \"==========================\"\n  Say \"The author explicitly disavows any claim whatsoever about\"\n  Say \"the correctness or functionality of this program, and\"\n  Say \"disclaims liability for anything and everything bad that\"\n  Say \"might happen in connection with, before, during, or after\"\n  Say \"using it. I have tried to make it work right, and I am\"\n  Say \"personally pretty confident that it does, but everybody\"\n  Say \"makes mistakes, so if you use it, you do so at your own\"\n  Say \"risk.\"\n  Say \"\"\n  Say \"The extensible nature of this program allows a software\"\n  Say \"developer to add their own externally called upon routines.\"\n  Say \"Contact them if their code causes you concerns and/or issues.\"\n  Say \"\"\n  Say \"IBM Corporation reserves the right to modify the IDTF\"\n  Say \"format and has done so over the years.\"\n  Say \"\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog custom built to install the GENIE\n            REXX programs and WISH files on your mainframe computer.\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.01 20180207 \"Kenneth E Tomiak\"<CBT_Ken@KTomiak.biz>\n               1) Adding #2VARS hostdsn is only 44 characters.\n               2) Corrected old #INSTALL to $INSTALL.\n               3) Switch order of parms passed knowing someone\n                  wants to blank them out.\n----- -------- --------------------------------------------------------\n01.00 20180122 \"Kenneth E Tomiak\"<CBT_Ken@KTomiak.biz>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n Finds from whence this was executed, use the hostdd/hostdsn as\n ISPPLIB and ALTLIB.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialzation_routine:\n  return_code = 0\n  PARSE SOURCE,\n    source_host_env,\n    source_call_type,\n    source_uc_exec_name,\n    source_hostdd,\n    source_hostdsn,\n    source_nf_exec_name,\n    source_initial_cmd_env,\n    source_asid_name,\n    source_char8_user_token,\n    source_hostother\n\n  Address TSO \"MakeBuf\"\n\n  sysvar_sysuid = SYSVAR(\"SYSUID\")\n  sysvar_syspref = SYSVAR(\"SYSPREF\")\n\n  If (source_hostdsn = \"?\") Then Do\n    function_rc = find_hostdsn()\n  End\n  listdsi_rc = Listdsi(\"'\"source_hostdsn\"'\")\n  vdef_volser = SYSVOLUME\n  vdef_unit = STRIP(SYSUNIT,\"B\",\" \")\n\n  msg_rc = 0\n  ZERRALRM = \"On\"\n  ZERRHM = \"MSICPHLP\"\n  verb_help = \"HELP\"\n  ZERRSM = ask_to_get_help()\n  ZERRLM = \"\"\n\n  libdef_plib = 0\n  altlib_exec = 0\n  TASKTABL = \"TASKTABL\"\n  vdef_table = \"VDEFTABL\"\n  tbcreate_idtftbl = 0\n  tbcreate_tasktbl = 0\n  tbcreate_vdef_table = 0\n\n  valid_names = \"@#$ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890\"\n\n  Address ISPEXEC \"LIBDEF ISPPLIB DATASET\",\n    \"ID('\"source_hostdsn\"') STACK\"\n  libdef_rc = RC\n  If (libdef_rc <> 0) Then Do\n    ZERRLM = \"LIBDEF of ISPPLIB failed, rc=\"libdef_rc\n    msg_rc = 1\n    return_code = libdef_rc\n  End\n  libdef_plib = 1\n\n  Address TSO ,\n    \"Altlib Activate Application(EXEC) Dataset('\"source_hostdsn\"')\"\n  altlib_rc = RC\n  If (altlib_rc <> 0) Then Do\n    ZERRLM = \"altlib of EXEC failed, rc=\"altlib_rc\n    msg_rc = 1\n    return_code = altlib_rc\n  End\n  altlib_exec = 1\n\n  editdsn = source_hostdsn\n  Address ISPEXEC \"VPUT (EDITDSN)\"\n\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_routine:\n  Address ISPEXEC \"VGET (ZSCREENW)\"\n  hw = (ZSCREENW - 16) % 2\n  ZTDMARK = Copies(\"-\",hw)\"> End of Tasks <\"Copies(\"-\",hw)\n  task_dsn = \"'\"source_hostdsn\"(#1TASKS)'\"\n  function_rc = Tasks_initialization()\n  vars_dsn = \"'\"source_hostdsn\"(#2VARS)'\"\n  function_rc = Vars_initialization()\n  edit_dsn = \"'\"source_hostdsn\"(#3EDIT)'\"\n  process_rc = Tasks_processing()\n  If (ZERRLM <> \"\") Then Do\n    ZERRSM = ask_to_get_help()\n    Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n  End\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_routine:\n  If (libdef_plib = 1) Then Do\n    Address ISPEXEC \"LIBDEF ISPPLIB DATASET\"\n  End\n  If (altlib_exec = 1) Then Do\n    Address TSO \"AltLib Deactivate Application(EXEC)\"\n  End\n  If (tbcreate_tasktbl = 1) Then Do\n    Address ISPEXEC,\n      \"TBEnd TASKTABL\"\n  End\n  If (tbcreate_vdef_table = 1) Then Do\n    Address ISPEXEC,\n      \"TBEnd\" vdef_table\n  End\n  If (return_code > 0) Then Do\n    If (msg_rc = 1) Then Do\n      If (ZERRSM = \"\") Then Do\n        ZERRSM = \"An unhappy ending\"\n        ZERRLM = \"Some unhappy turn of events is sending back\",\n          \"a RETURN code higher than 0 with no message.\"\n      End\n      ZERRSM = ask_to_get_help()\n      Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    End\n  End\n  Address TSO \"DROPBUF\"\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Search a DD to find where this code runs from.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nfind_hostdsn:\n  Address ISPEXEC ,\n    \"QBASELIB\" source_hostdd \"ID(DSNLIST)\"\n  ISPEXEC_rc = RC\n  If (ISPEXEC_rc <> 0) Then Do\n    msg_rc = 1\n    ZERRLM = \"QBASELIB Failed, RC(\"ISPEXEC_rc\")\"\n    Return 4\n  End\n  dsnlist_temp = dsnlist\n  @trap_state = TRAPMSG(\"On\")\n  msg_state = Msg(\"OFF\")\n  Do While dsnlist_temp <> \"\"\n    Parse Var dsnlist_temp one_dsn \",\" dsnlist_temp\n    one_dsn = Strip(one_dsn,\"B\",\"'\")\n    sysdsn_rc = SysDsn(\"'\"one_dsn\"(\"source_uc_exec_name\")'\")\n    If (sysdsn_rc = \"OK\") Then Do\n      source_hostdsn = STRIP(one_dsn,\"B\",\" \")\n      Leave\n    End\n  End\n  msg_rc = Msg(msg_state)\n  @trap_rc = TRAPMSG(@trap_state)\n  Return 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: Parse arg myarg\n  If (uppercase_letters = \"UPPERCASE_LETTERS\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: Parse arg myarg\n  If (uppercase_letters = \"UPPERCASE_LETTERS\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n VGET the PFKEY settings amd map to names.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\npfkeys_by_name:\n  pfkeys_verb. = \"\"\n  Address ISPEXEC \"VGET (ZPF01, ZPF02, ZPF03, ZPF04, ZPF05, ZPF06,\" ,\n                        \"ZPF07, ZPF08, ZPF09, ZPF10, ZPF11, ZPF12,\" ,\n                        \"ZPF13, ZPF14, ZPF15, ZPF16, ZPF17, ZPF18,\" ,\n                        \"ZPF19, ZPF20, ZPF21, ZPF22, ZPF23, ZPF24)\"\n  vget_rc = RC\n  If (vget_rc <> 0) Then Do\n    pfkeys_verb.verb_HELP = \"Type HELP and press Enter.\"\n    return vget_rc\n  End\n  ZPF01 = To_Uppercase(ZPF01)\n  ZPF02 = To_Uppercase(ZPF02)\n  ZPF03 = To_Uppercase(ZPF03)\n  ZPF04 = To_Uppercase(ZPF04)\n  ZPF05 = To_Uppercase(ZPF05)\n  ZPF06 = To_Uppercase(ZPF06)\n  ZPF07 = To_Uppercase(ZPF07)\n  ZPF08 = To_Uppercase(ZPF08)\n  ZPF09 = To_Uppercase(ZPF09)\n  ZPF10 = To_Uppercase(ZPF10)\n  ZPF11 = To_Uppercase(ZPF11)\n  ZPF12 = To_Uppercase(ZPF12)\n  ZPF13 = To_Uppercase(ZPF13)\n  ZPF14 = To_Uppercase(ZPF14)\n  ZPF15 = To_Uppercase(ZPF15)\n  ZPF16 = To_Uppercase(ZPF16)\n  ZPF17 = To_Uppercase(ZPF17)\n  ZPF18 = To_Uppercase(ZPF18)\n  ZPF19 = To_Uppercase(ZPF19)\n  ZPF20 = To_Uppercase(ZPF20)\n  ZPF21 = To_Uppercase(ZPF21)\n  ZPF22 = To_Uppercase(ZPF22)\n  ZPF23 = To_Uppercase(ZPF23)\n  ZPF24 = To_Uppercase(ZPF24)\n  pfkeys_verb.ZPF01 = pfkeys_verb.ZPF01\"PF01/\"\n  pfkeys_verb.ZPF02 = pfkeys_verb.ZPF02\"PF02/\"\n  pfkeys_verb.ZPF03 = pfkeys_verb.ZPF03\"PF03/\"\n  pfkeys_verb.ZPF04 = pfkeys_verb.ZPF04\"PF04/\"\n  pfkeys_verb.ZPF05 = pfkeys_verb.ZPF05\"PF05/\"\n  pfkeys_verb.ZPF06 = pfkeys_verb.ZPF06\"PF06/\"\n  pfkeys_verb.ZPF07 = pfkeys_verb.ZPF07\"PF07/\"\n  pfkeys_verb.ZPF08 = pfkeys_verb.ZPF08\"PF08/\"\n  pfkeys_verb.ZPF09 = pfkeys_verb.ZPF09\"PF09/\"\n  pfkeys_verb.ZPF10 = pfkeys_verb.ZPF10\"PF10/\"\n  pfkeys_verb.ZPF11 = pfkeys_verb.ZPF11\"PF11/\"\n  pfkeys_verb.ZPF12 = pfkeys_verb.ZPF12\"PF12/\"\n  pfkeys_verb.ZPF13 = pfkeys_verb.ZPF13\"PF13/\"\n  pfkeys_verb.ZPF14 = pfkeys_verb.ZPF14\"PF14/\"\n  pfkeys_verb.ZPF15 = pfkeys_verb.ZPF15\"PF15/\"\n  pfkeys_verb.ZPF16 = pfkeys_verb.ZPF16\"PF16/\"\n  pfkeys_verb.ZPF17 = pfkeys_verb.ZPF17\"PF17/\"\n  pfkeys_verb.ZPF18 = pfkeys_verb.ZPF18\"PF18/\"\n  pfkeys_verb.ZPF19 = pfkeys_verb.ZPF19\"PF19/\"\n  pfkeys_verb.ZPF20 = pfkeys_verb.ZPF20\"PF20/\"\n  pfkeys_verb.ZPF21 = pfkeys_verb.ZPF21\"PF21/\"\n  pfkeys_verb.ZPF22 = pfkeys_verb.ZPF22\"PF22/\"\n  pfkeys_verb.ZPF23 = pfkeys_verb.ZPF23\"PF23/\"\n  pfkeys_verb.ZPF24 = pfkeys_verb.ZPF24\"PF24/\"\n  pfkeys_verb.ZPF01 = Strip(pfkeys_verb.ZPF01,\"T\",\"/\")\n  pfkeys_verb.ZPF02 = Strip(pfkeys_verb.ZPF02,\"T\",\"/\")\n  pfkeys_verb.ZPF03 = Strip(pfkeys_verb.ZPF03,\"T\",\"/\")\n  pfkeys_verb.ZPF04 = Strip(pfkeys_verb.ZPF04,\"T\",\"/\")\n  pfkeys_verb.ZPF05 = Strip(pfkeys_verb.ZPF05,\"T\",\"/\")\n  pfkeys_verb.ZPF06 = Strip(pfkeys_verb.ZPF06,\"T\",\"/\")\n  pfkeys_verb.ZPF07 = Strip(pfkeys_verb.ZPF07,\"T\",\"/\")\n  pfkeys_verb.ZPF08 = Strip(pfkeys_verb.ZPF08,\"T\",\"/\")\n  pfkeys_verb.ZPF09 = Strip(pfkeys_verb.ZPF09,\"T\",\"/\")\n  pfkeys_verb.ZPF10 = Strip(pfkeys_verb.ZPF10,\"T\",\"/\")\n  pfkeys_verb.ZPF11 = Strip(pfkeys_verb.ZPF11,\"T\",\"/\")\n  pfkeys_verb.ZPF12 = Strip(pfkeys_verb.ZPF12,\"T\",\"/\")\n  pfkeys_verb.ZPF13 = Strip(pfkeys_verb.ZPF13,\"T\",\"/\")\n  pfkeys_verb.ZPF14 = Strip(pfkeys_verb.ZPF14,\"T\",\"/\")\n  pfkeys_verb.ZPF15 = Strip(pfkeys_verb.ZPF15,\"T\",\"/\")\n  pfkeys_verb.ZPF16 = Strip(pfkeys_verb.ZPF16,\"T\",\"/\")\n  pfkeys_verb.ZPF17 = Strip(pfkeys_verb.ZPF17,\"T\",\"/\")\n  pfkeys_verb.ZPF18 = Strip(pfkeys_verb.ZPF18,\"T\",\"/\")\n  pfkeys_verb.ZPF19 = Strip(pfkeys_verb.ZPF19,\"T\",\"/\")\n  pfkeys_verb.ZPF20 = Strip(pfkeys_verb.ZPF20,\"T\",\"/\")\n  pfkeys_verb.ZPF21 = Strip(pfkeys_verb.ZPF21,\"T\",\"/\")\n  pfkeys_verb.ZPF22 = Strip(pfkeys_verb.ZPF22,\"T\",\"/\")\n  pfkeys_verb.ZPF23 = Strip(pfkeys_verb.ZPF23,\"T\",\"/\")\n  pfkeys_verb.ZPF24 = Strip(pfkeys_verb.ZPF24,\"T\",\"/\")\n  Return vget_rc\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Set a string to press a help PFKey.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nask_to_get_help:\n  pfkey_rc = pfkeys_by_name()\n  If (Left(pfkeys_verb.verb_help,2) = \"PF\") Then Do\n    press_this = \"Press\" pfkeys_verb.verb_help\n  End\n  Else Do\n    press_this = pfkeys_verb.verb_help\n  End\n  Return press_this\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Read #1TASKS and load into an ISPF table.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTasks_initialization:\n  @trap_state = TRAPMSG(\"On\")\n  msg_state = Msg(\"OFF\")\n  sysdsn_rc = SysDsn(task_dsn)\n  If (sysdsn_rc <> \"OK\") Then Do\n    msg_rc = 1\n    return_code = 16\n    Return return_code\n  End\n  msg_rc = Msg(msg_state)\n  @trap_state = TRAPMSG(@trap_state)\n  capture_state = OutTrap(captured.)\n  Address TSO ,\n    \"ALLOC File(TASKS) DataSet(\"task_dsn\") SHR REUSE\"\n  alloc_rc = RC\n  Address MVS ,\n    \"EXECIO * DiskR TASKS (Stem tasklist. Finis)\"\n  execio_rc = RC\n  Address TSO ,\n    \"FREE File(TASKS)\"\n  free_rc = RC\n  restore_state = OutTrap(capture_state)\n\n  Address ISPEXEC,\n    \"TBEnd TASKTABL\"\n  Address ISPEXEC,\n    \"TBCREATE TASKTABL\" ,\n    \"NAMES(TASKZSEL, TASKSEQ, TASKTYPE, TASKITEM,\" ,\n      \"TASKDONE, TASKRC, TASKDESC)\" ,\n    \"REPLACE\" ,\n    \"NOWRITE\"\n  tbcreate_rc = RC\n  If (tbcreate_rc <> 0) Then Do\n    Select\n      When (tbcreate_rc = 4) Then Do\n        ZERRLM = \"4 - Duplicate table exists but 'replace' specified\"\n      End\n      When (tbcreate_rc = 8) Then Do\n        ZERRLM = \"8 - Table already exists; 'replace' not specified\"\n      End\n      When (tbcreate_rc = 12) Then Do\n        ZERRLM = \"Table in use; enq failed\"\n      End\n      When (tbcreate_rc = 16) Then Do\n        ZERRLM = \"Table input library not allocated with 'write'\"\n      End\n      When (tbcreate_rc = 20) Then Do\n        ZERRLM = \"Severe error\"\n      End\n      Otherwise Do\n        ZERRLM = tbcreate_rc \"is a new value to this code.\"\n      End\n    End\n    Return tbcreate_rc\n  End\n  tbcreate_tasktbl = 1\n  Do tx = 1 to tasklist.0\n    If (Left(tasklist.tx,1) = \"*\") Then Iterate\n    Parse Var tasklist.tx ,\n          tasklist_seq.tx +3 ,\n       =5 tasklist_type.tx +7 ,\n      =13 tasklist_item.tx +8 ,\n      =70 tasklist_done.tx +8 ,\n      =79 tasklist_status.tx +2 .\n    tasklist_item.tx = Strip(tasklist_item.tx,\"T\",\" \")\n    Address ISPEXEC \"TBVCLEAR TASKTABL\"\n    TASKSEQ = tasklist_seq.tx\n    TASKTYPE = tasklist_type.tx\n    TASKITEM = tasklist_item.tx\n    TASKDONE = tasklist_done.tx\n    TASKRC = tasklist_status.tx\n    tx = tx + 1\n    tasklist_descr.tx = Strip(tasklist.tx,\"T\",\" \")\n    TASKDESC = tasklist_descr.tx\n    Address ISPEXEC \"TBAdd TASKTABL\"\n    tbadd_rc = RC\n    If (tbadd_rc <> 0) Then Do\n      Select\n        When (tbadd_rc = 4) Then Do\n          ZERRLM = \"TASKTABL TBADD, Number of rows parameter\" ,\n                   \"was specified but storage\" ,\n                   \"was only obtained for a\" ,\n                   \"single row\"\n          msg_rc = 1\n        End\n        When (tbadd_rc = 8) Then Do\n          ZERRLM = \"TASKTABL TBADD, Key tables: a row with the\" ,\n                   \"same key already exists;\" ,\n                   \"crp set to top\"\n        End\n        When (tbadd_rc = 12) Then Do\n          ZERRLM = \"TASKTABL TBADD, Table is not open\"\n          msg_rc = 1\n        End\n        When (tbadd_rc = 16) Then Do\n          ZERRLM = \"TASKTABL TBADD, Severe error\"\n          msg_rc = 1\n        End\n        Otherwise Do\n          ZERRLM = \"TASKTABL TBADD,\" ,\n            tbadd_rc \"is a new value to this code.\"\n          msg_rc = 1\n        End\n      End\n    End\n  End\n  Address ISPEXEC \"TBSort TASKTABL Fields(taskseq,C,A)\"\n  Address ISPEXEC \"TBTop TASKTABL\"\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Read #2VARS and load into an ISPF table.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nVars_initialization:\n  @trap_state = TRAPMSG(\"On\")\n  msg_state = Msg(\"OFF\")\n  sysdsn_rc = SysDsn(vars_dsn)\n  If (sysdsn_rc <> \"OK\") Then Do\n    msg_rc = 1\n    return_code = 16\n    Return return_code\n  End\n  msg_rc = Msg(msg_state)\n  @trap_state = TRAPMSG(@trap_state)\n  Address TSO ,\n    \"ALLOC File(VARS) DataSet(\"vars_dsn\") SHR REUSE\"\n  alloc_rc = RC\n  Address MVS ,\n    \"EXECIO * DiskR VARS (Stem varslist. Finis)\"\n  execio_rc = RC\n  Address TSO ,\n    \"FREE File(VARS)\"\n  free_rc = RC\n  Address ISPEXEC,\n    \"TBCLOSE\" vdef_table\n  Address ISPEXEC,\n    \"TBEnd\" vdef_table\n  Address ISPEXEC,\n    \"TBCREATE\" vdef_table ,\n    \"NAMES(VDEFVAR, VDEFATTR, VDEFLEN,\" ,\n      \"VDEFVAL, VDEFDESC)\" ,\n    \"SHARE\" ,\n    \"NOWRITE\"\n  tbcreate_rc = RC\n  If (tbcreate_rc <> 0) Then Do\n    ZERRLM = tbcreate_rc \"unexpected\"\n    Return tbcreate_rc\n  End\n  tbcreate_vdef_table = 1\n  vdefine_list = \"\"\n  vdefine_attrib. = \"\"\n  vdefine_length. = 0\n  vdefine_val. = \"\"\n  Do tx = 1 to varslist.0\n    If (Left(varslist.tx,1) = \"*\") Then Iterate\n    Parse Var varslist.tx ,\n          varslist_item.tx +8 ,\n      =10 varslist_attr.tx +2 ,\n      =13 varslist_len.tx \" \" . ,\n      =20 varslist_desc.tx\n    varslist_item.tx = Strip(varslist_item.tx,\"T\",\" \")\n    varslist_desc.tx = Strip(varslist_desc.tx,\"T\",\" \")\n    varslist_key = varslist_item.tx\n    vdefine_list = vdefine_list||varslist_key\" \"\n    vdefine_var.varslist_key = tx\n    ox = tx\n    tx = tx + 1\n    varslist_val = Left(varslist.tx,varslist_len.ox)\n    Address ISPEXEC \"TBVCLEAR\" vdef_table\n    VDEFVAR = varslist_key\n    VDEFATTR = varslist_attr.ox\n    VDEFLEN  = varslist_len.ox\n    VDEFDESC = varslist_desc.ox\n    VDEFVAL  = varslist_val\n    Address ISPEXEC \"TBAdd\" vdef_table\n    Select\n      When (vdefvar = \"WISHLIST\") THEN vdef_wishlist = vdefval\n      When (vdefvar = \"VOLSER\") THEN vdef_volser = vdefval\n      When (vdefvar = \"UNIT\") THEN vdef_unit = vdefval\n      Otherwise DO\n        NOP\n      END\n    END\n  End\n  function_rc = get_variable_value(\"HOSTDSN\")\n  IF (function_rc = \"\") THEN DO\n    Address ISPEXEC \"TBVCLEAR\" vdef_table\n    VDEFVAR = \"HOSTDSN\"\n    VDEFATTR = \"DS\"\n    VDEFLEN  = 44\n    VDEFDESC = \"The data set used to launch $INSTALL.\"\n    VDEFVAL  = source_hostdsn\n    Address ISPEXEC \"TBAdd\" vdef_table\n  END\n  function_rc = get_variable_value(\"UNIT\")\n  IF (function_rc = \"\") THEN DO\n    Address ISPEXEC \"TBVCLEAR\" vdef_table\n    VDEFVAR = \"UNIT\"\n    VDEFATTR = \"UC\"\n    VDEFLEN  = 8\n    VDEFDESC = \"Name of DISK volume for new data sets.\"\n    VDEFVAL  = vdef_unit\n    Address ISPEXEC \"TBAdd\" vdef_table\n  END\n  function_rc = get_variable_value(\"VOLSER\")\n  IF (function_rc = \"\") THEN DO\n    Address ISPEXEC \"TBVCLEAR\" vdef_table\n    VDEFVAR = \"VOLSER\"\n    VDEFATTR = \"UC\"\n    VDEFLEN  = 8\n    VDEFDESC = \"Name of DISK volume for new data sets.\"\n    VDEFVAL  = vdef_volser\n    Address ISPEXEC \"TBAdd\" vdef_table\n  END\n  function_rc = get_variable_value(\"ZUSER\")\n  IF (function_rc = \"\") THEN DO\n    Address ISPEXEC \"TBVCLEAR\" vdef_table\n    VDEFVAR = \"ZUSER\"\n    VDEFATTR = \"UC\"\n    VDEFLEN  = 8\n    VDEFDESC = \"Your current USERID.\"\n    VDEFVAL  = sysvar_sysuid\n    Address ISPEXEC \"TBAdd\" vdef_table\n  END\n\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Display the task table until the user exits.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTasks_processing:\n  Address ISPEXEC \"VGET (ZSCREENW)\"\n  hw = (ZSCREENW - 16) % 2\n  ZTDMARK = Copies(\"-\",hw)\"> End of tasks <\"Copies(\"-\",hw)\n  msicptsk_tbdispl_rc = 0\n  Do While (msicptsk_tbdispl_rc < 8)\n    Address ISPEXEC \"TBDISPL TASKTABL PANEL(MSICPTSK)\"\n    msicptsk_tbdispl_rc = RC\n    Select\n      When (msicptsk_tbdispl_rc = 8) Then Do\n        Leave\n      End\n      When (msicptsk_tbdispl_rc > 4) Then Do\n        ZERRLM = \"RC is too high,\" msicptsk_tbdispl_rc\".\"\n        msg_rc = 1\n        return msicptsk_tbdispl_rc\n      End\n      Otherwise Do\n        tasks_zcmd_rc = tasks_zcmd_procesing()\n        If (tasks_zcmd_rc <> 0) Then Do\n          return tasks_zcmd_rc\n        End\n        tasks_zsel_rc = tasks_zsel_procesing()\n      End\n    End\n  End\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Process ==>Command options.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\ntasks_zcmd_procesing:\n  msg_rc = 0\n  task_zcmd = ZCMD\n  ZCMD = \"\"\n  Select\n    When (task_zcmd = \"\") Then Do\n      return return_code\n    End\n    When (To_Uppercase(task_zcmd) = \"X\") Then Do\n      ZERRSM = \"Okay\"\n      ZERRLM = \"You used X to leave.\"\n      Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      return_code = 8\n    End\n    Otherwise Do\n      ZERRSM = \"What?\"\n      ZERRLM = \"Choose a valid option or feature.\"\n      Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    End  /* End of OTHERWISE */\n  End  /* End of SELECT  */\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Loop thru the selected task rows.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\ntasks_zsel_procesing:\n  msicptsk_tbdispl_rc = 0\n  Do While (ZTDSELS > 0)\n    TASKZSEL = To_Uppercase(TASKZSEL)\n    function_rc = tasks_row_selection()\n    TASKZSEL = \"\"\n    Address ISPEXEC \"TBPUT TASKTABL\"\n    save_rc = tasks_save_state()\n    If (ZTDSELS > 1) Then Do\n      Address ISPEXEC \"TBDISPL TASKTABL\"\n      msicptsk_tbdispl_rc = RC\n    End\n    Else Do\n      ZTDSELS = 0\n    End\n  End\n  Return msicptsk_tbdispl_rc\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n Process the ROW selection.\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\ntasks_row_selection:\n  Select\n    When (TASKZSEL = \"S\") Then Do\n      Select\n        When (To_uppercase(TASKTYPE) = \"BROWSE\") Then Do\n          out_dsn = \"'\"source_hostdsn\"(\"taskitem\")'\"\n          Address ISPEXEC \"Control Display Save\"\n          orig_zscr = ZSCR\n          Address ISPEXEC \"Browse DATASET(\"OUT_DSN\")\"\n          browse_rc = RC\n          Address ISPEXEC \"Control Display Restore\"\n          ZSCR = orig_zscr\n          taskdone = Date(\"S\")\n          taskrc = \"00\"\n          If (browse_rc <> 0) Then Do\n            ZERRSM = ask_to_get_help()\n            ZERRLM = \"Configuration error,\" taskitem \"not present.\"\n            Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n            taskrc = \"NG\"\n          End\n        End\n        When (To_uppercase(TASKTYPE) = \"EDIT\") Then Do\n          out_dsn = \"'\"source_hostdsn\"(\"taskitem\")'\"\n          Address ISPEXEC \"Control Display Save\"\n          orig_zscr = ZSCR\n          Address ISPEXEC \"EDIT DATASET(\"OUT_DSN\")\"\n          EDIT_rc = RC\n          Address ISPEXEC \"Control Display Restore\"\n          ZSCR = orig_zscr\n          taskdone = Date(\"S\")\n          taskrc = \"00\"\n          If (EDIT_rc <> 0) Then Do\n            ZERRSM = ask_to_get_help()\n            ZERRLM = \"Configuration error,\" taskitem \"not present.\"\n            Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n            taskrc = \"NG\"\n          End\n        End\n        When (To_uppercase(TASKTYPE) = \"VIEW\") Then Do\n          out_dsn = \"'\"source_hostdsn\"(\"taskitem\")'\"\n          Address ISPEXEC \"Control Display Save\"\n          orig_zscr = ZSCR\n          Address ISPEXEC \"VIEW DATASET(\"OUT_DSN\")\"\n          VIEW_rc = RC\n          Address ISPEXEC \"Control Display Restore\"\n          ZSCR = orig_zscr\n          taskdone = Date(\"S\")\n          taskrc = \"00\"\n          If (VIEW_rc <> 0) Then Do\n            ZERRSM = ask_to_get_help()\n            ZERRLM = \"Configuration error,\" taskitem \"not present.\"\n            Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n            taskrc = \"NG\"\n          End\n        End\n        When (To_uppercase(TASKTYPE) = \"EXECUTE\") Then Do\n          Address ISPEXEC \"Control Display Save\"\n          SELECT\n            WHEN (taskitem = \"MSICCOPY\") THEN DO\n              function_rc = get_variable_value(\"SYSEXEC\")\n              Address ISPEXEC \"SELECT CMD(\"taskitem ,\n                source_hostdsn vdefval\")\"\n            END\n            WHEN (taskitem = \"MSICDEFN\") THEN DO\n              Address ISPEXEC \"SELECT CMD(\"taskitem ,\n                vdef_wishlist source_hostdsn vdef_volser vdef_unit\")\"\n            END\n            WHEN (taskitem = \"MSICREDT\") THEN DO\n              Address ISPEXEC \"SELECT CMD(\"taskitem ,\n                source_hostdsn\")\"\n            END\n            WHEN (taskitem = \"GENIEBLD\") THEN DO\n              Address ISPEXEC \"SELECT CMD(\"taskitem ,\n                vdef_wishlist\")\"\n            END\n            OTHERWISE DO\n              Address ISPEXEC \"SELECT CMD(\"taskitem ,\n                vdef_wishlist source_hostdsn ,\n                taskitem vdef_volser vdef_unit\")\"\n            END\n          END\n          execute_rc = RC\n          Address ISPEXEC \"Control Display Restore\"\n          taskdone = Date(\"S\")\n          taskrc = Right(execute_rc,2,\"0\")\n        End\n        When (To_uppercase(TASKTYPE) = \"ROUTINE\") Then Do\n          Interpret \"routine_rc = \"taskitem\"_routine()\"\n          taskdone = Date(\"S\")\n          taskrc = Right(routine_rc,2,\"0\")\n        End\n        When (To_uppercase(TASKTYPE) = \"SUBMIT\") Then Do\n          out_dsn = \"'\"source_hostdsn\"(\"taskitem\")'\"\n          Address ISPEXEC \"Control Display Save\"\n          orig_zscr = ZSCR\n          @outtrap_state = OutTrap(@caughtit.)\n          Address ISPEXEC \"Edit DATASET(\"OUT_DSN\") MACRO(MSICMMBR)\"\n          submit_rc = RC\n          @outtrap_state = OutTrap(@outtrap_state)\n          Do oxx = 1 to @caughtit.0\n            say @caughtit.oxx\n          End\n          Address ISPEXEC \"Control Display Restore\"\n          ZSCR = orig_zscr\n          taskdone = Date(\"S\")\n          taskrc = Right(submit_rc,2,\"0\")\n        End\n        Otherwise Do\n          ZERRSM = ask_to_get_help()\n          ZERRLM = \"Not ready to\" tasktype \"on\" taskitem\".\"\n          Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n        End\n      End\n    End\n    Otherwise Do\n      ZERRSM = \"What?\"\n      ZERRLM = \"Use a valid line command (S).\"\n      Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    End\n  End\n  Return 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Internal routine to prompt for variable values.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n$SETVARS_routine:\n  Address ISPEXEC \"TBSort\" vdef_table \"Fields(VDEFVAR,C,A)\"\n  Address ISPEXEC \"TBTop\" vdef_table\n  Address ISPEXEC \"VGET (ZSCREENW)\"\n  hw = (ZSCREENW - 16) % 2\n  ZTDMARK = Copies(\"-\",hw)\"> End of variables <\"Copies(\"-\",hw)\n  msicpvar_tbdispl_rc = 0\n  Address ISPEXEC \"CONTROL DISPLAY SAVE\"\n  Do While (msicpvar_tbdispl_rc < 8)\n    msicpvar_tbdispl_rc = vdef_tbdispl_panel()\n  End\n  Address ISPEXEC \"CONTROL DISPLAY RESTORE\"\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n In this routine we display the variable intake panel.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nvdef_tbdispl_panel:\n  Address ISPEXEC \"TBDISPL\" vdef_table \"PANEL(MSICPVAR)\"\n  msicpvar_tbdispl_rc = RC\n  Select\n    When (msicpvar_tbdispl_rc = 8) Then Do\n      return msicpvar_tbdispl_rc\n    End\n    When (msicpvar_tbdispl_rc > 4) Then Do\n      ZERRLM = \"RC is too high,\" msicpvar_tbdispl_rc\".\"\n      return msicpvar_tbdispl_rc\n    End\n    Otherwise Do\n      vdef_zcmd_rc = vdef_zcmd_procesing()\n      If (vdef_zcmd_rc <> 0) Then Do\n        return vdef_zcmd_rc\n      End\n      vdef_zsel_rc = vdef_zsel_procesing()\n    End\n  End\n  If (msicpvar_tbdispl_rc = 8) Then Do\n    return return_code\n  End\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n In this routine we process the zcmd from the variable intake panel.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nvdef_zcmd_procesing:\n  msg_rc = 0\n  vdef_zcmd = ZCMD\n  ZCMD = \"\"\n  Select\n    When (vdef_zcmd = \"\") Then Do\n      return return_code\n    End\n    When (To_Uppercase(vdef_zcmd) = \"X\") Then Do\n      ZERRSM = \"Okay\"\n      ZERRLM = \"You used X to leave.\"\n      Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      return_code = 8\n    End\n    Otherwise Do\n      ZERRSM = \"What?\"\n      ZERRLM = \"Choose a valid option or feature.\"\n      Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    End  /* End of OTHERWISE */\n  End  /* End of SELECT  */\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Process all VDEF row changes.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nvdef_zsel_procesing:\n  msicpvar_tbdispl_rc = 0\n  valid_msg = 0\n  ZERRLM = \"\"\n  Do While (ZTDSELS > 0)\n    function_rc = vdef_row_selection()\n    Address ISPEXEC \"TBPUT\" vdef_table\n    save_rc = vdef_save_updates()\n    If (ZTDSELS > 1) Then Do\n      Address ISPEXEC \"TBDISPL\" vdef_table\n      msicpvar_tbdispl_rc = RC\n    End\n    Else Do\n      ztdsels = 0\n    End\n  End\n  If (valid_msg = 1) Then Do\n    ZERRSM = \"Validaion results\"\n    Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n  End\n  Return msicpvar_tbdispl_rc\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n Process the VDEF ROW selection.\n Validate the value matches the attribute and length.\n DS, LC, MB, MC, N, UC\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nvdef_row_selection:\n  good_name = 1\n  vdefvar = Strip(vdefvar,\"T\",\" \")\n  Select\n    When (vdefattr = \"DS\") Then Do\n      vdefval = To_Uppercase(Strip(vdefval,\"T\",\" \"))\n      dsn@len = Length(vdefval)\n      If (dsn@len <= vdeflen) Then Do\n        tmp_dsn = vdefval\n        If (Pos(\"'\",tmp_dsn) > 0) Then Do\n          tmp_dsn = Strip(tmp_dsn,\"B\",\"'\")\n        End\n        Else Do\n          Parse Var vdefval one_qual \".\" .\n          If (one_qual <> sysvar_syspref) Then Do\n            tmp_dsn = sysvar_syspref\".\"tmp_dsn\n          End\n        End\n        Do While (tmp_dsn <> \"\")\n          Parse Var tmp_dsn one_qual \".\" tmp_dsn\n          If (Pos(Left(one_qual,1),Left(valid_names,29)) = 0 ) Then Do\n            good_name = 0\n            ZERRLM = ZERRLM || ,\n              Left(vdefvar \"1st character bad:\" Left(one_qual,1),79)\n          End\n          mbr@len = Length(one_qual)\n          Do ltr = 2 to mbr@len\n            If (Pos(SubStr(one_qual,ltr,1),valid_names) = 0 ) Then Do\n              good_name = 0\n              ZERRLM = ZERRLM || ,\n                Left(vdefvar ltr ,\n                  \"character bad:\" SubStr(one_qual,ltr,1),79)\n            End\n          End\n        End\n      End\n      Else Do\n        good_name = 0\n        ZERRLM = ZERRLM || ,\n          Left(vdefvar dsn@len \"length exceeds\" vdeflen,79)\n      End\n    End\n    When (vdefattr = \"LC\") Then Do\n      vdefval = To_Lowercase(vdefval)\n    End\n    When (vdefattr = \"MB\") Then Do\n      vdefval = To_Uppercase(vdefval)\n      mbr@len = Length(vdefval)\n      good_name = 1\n      If (mbr@len > vdeflen) Then Do\n        If (Pos(Left(vdefval,1),Left(valid_names,29)) = 0 ) Then Do\n          good_name = 0\n          ZERRLM = ZERRLM || ,\n            Left(vdefvar \"1st character bad:\" Left(vdefval,1),79)\n        End\n        Do ltr = 2 to mbr@len\n          If (Pos(SubStr(vdefval,ltr,1),valid_names) = 0 ) Then Do\n            good_name = 0\n            ZERRLM = ZERRLM || ,\n              Left(vdefvar ltr ,\n                \"character bad:\" SubStr(vdefval,ltr,1),79)\n          End\n        End\n      End\n      Else Do\n        good_name = 0\n        ZERRLM = ZERRLM || ,\n          Left(vdefvar mbr@len \"length exceeds\" vdeflen,79)\n      End\n    End\n    When (vdefattr = \"MC\") Then Do\n      NOp\n    End\n    When (vdefattr = \"N\") Then Do\n      good_name = 1\n      val@len = Length(vdefval)\n      If (val@len > vdeflen) Then Do\n        good_name = 0\n        ZERRLM = ZERRLM || ,\n          Left(vdefvar val@len \"length exceeds\" vdeflen,79)\n      End\n      If (DataType(vdefval) <> \"NUM\") Then Do\n        good_name = 0\n        ZERRLM = ZERRLM || ,\n          Left(vdefvar \"is not numeric\",79)\n      End\n    End\n    When (vdefattr = \"UC\") Then Do\n      vdefval = To_Uppercase(vdefval)\n    End\n    When (vdefattr = \"XM\") Then Do\n      val@len = Length(vdefval)\n      If (val@len > vdeflen) Then Do\n        good_name = 0\n        ZERRLM = ZERRLM || ,\n          Left(vdefvar val@len \"length exceeds\" vdeflen,79)\n      End\n      xmit_dsn = \"'\"source_hostdsn\"(\"vdefvar\")'\"\n      Address TSO \"Alloc File(INMRCK)\" ,\n        \"Dataset(\"xmit_dsn\") SHR REUSE\"\n      Address MVS \"Execio 1 DISKR INMRCK (Stem inmr. FINIS)\"\n      Address TSO \"Free File(INMRCK)\"\n      If (Pos(\"\\INMR01\",inmr.1) <> 2) Then Do\n        good_name = 0\n        ZERRLM = ZERRLM || ,\n          Left(vdefvar \"is not an IDTF file XM INMR01<>2\",79)\n      End\n    End\n    Otherwise Do\n      msg_rc = 1\n      ZERRLM = ZERRLM || ,\n        Left(vdefvar vdefattr \"is a bad attribute to me.\",79)\n    End\n    Select\n      When (vdefvar = \"WISHLIST\") THEN vdef_wishlist = vdefval\n      When (vdefvar = \"VOLSER\") THEN vdef_volser = vdefval\n      When (vdefvar = \"UNIT\") THEN vdef_unit = vdefval\n      Otherwise DO\n        NOP\n      END\n    END\n  End\n  If (good_name = 0) Then Do\n    vdefzsel = \"ERR\"\n  End\n  Else Do\n    ZERRLM = ZERRLM || ,\n      Left(vdefvar \"OK\",79)\n  End\n  valid_msg = 1\n  Return 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Search for the named variable and retrieve its value.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nget_variable_value:\n  parse arg my_var\n  Address IspExec \"TBTOP VDEFTABL\"\n  Address IspExec \"TBVCLEAR VDEFTABL\"\n  VDEFVAR = my_var\n  Address IspExec \"TBSARG VDEFTABL\" ,\n    \"Next NameCond(VDEFVAR,EQ)\"\n  tbsarg_rc = RC\n  Address IspExec \"TBScan VDEFTABL\"\n  tbscan_rc = RC\n  If (tbscan_rc <> 0) then vdefval = \"\"\n  Return vdefval\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Save the updated #1TASKS list.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\ntasks_save_state:\n  line_of_code = get_my_sigl() + 2\n/* Tasklist\n*\n* Mainframe Software Installation Customizer (MSIC)\n*\n* Tasks require 2 records.\n* Record 1:\n* =====================================================================\n* Seq    N3 Three digit sequence identifier\n* Type   C7 What it is you want to do.\n*             Browse : Let the user BROWSE a PDS member.\n*             Edit   : Let the user EDIT a PDS member.\n*             Execute: Run some external REXX code.\n*             Receive: Receive all XM variables.\n*             Routine: Run an internal REXX routine.\n*             Submit : Submit a member to run in the background.\n*             View : Let the user VIEW a PDS member.\n* Item   C8 What is acted upon.\n* Done   D8 The last attempt date filled in by MSIC.\n* Status C2 How that last attempt fared filled in by MSIC.\n*\n* Record 2:\n* =====================================================================\n* Desc  : A descriptive bit of text.\n*\n*---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8\n*SQ Type    Item     Description goes on a second line               Done     St\n*== ======= ======== =============================================== ======== ==\nEnd */\n  tasklist. = \"\"\n  task_ctr = 0\n  Do While (SourceLine(line_of_code) <> \"End */\")\n    task_ctr = task_ctr + 1\n    tasklist.task_ctr = SourceLine(line_of_code)\n    line_of_code = line_of_code + 1\n  End\n  Address ISPEXEC \"TBTop TASKTABL\"\n  tbskip_rc = 0\n  Do While (tbskip_rc = 0)\n    Address ISPEXEC \"TBSkip TASKTABL\"\n    tbskip_rc = RC\n    If (tbskip_rc = 0) Then Do\n      task_ctr = task_ctr + 1\n      tasklist.task_ctr = Right(taskseq,3,\"0\") ,\n        Left(tasktype,7) Left(taskitem,8) ,\n        Copies(\" \",47) Left(taskdone,8) Left(Taskrc,2)\n      task_ctr = task_ctr + 1\n      tasklist.task_ctr = taskdesc\n    End\n  End\n  task_ctr = task_ctr + 1\n  tasklist.task_ctr = \"*\"\n  task_ctr = task_ctr + 1\n  tasklist.task_ctr = \"* End of #1TASKS.\"\n  @trap_state = TRAPMSG(\"On\")\n  msg_state = Msg(\"OFF\")\n  Address TSO ,\n    \"ALLOC File(TASKS) DataSet(\"task_dsn\") SHR REUSE\"\n  alloc_rc = RC\n  Address MVS ,\n    \"EXECIO * Diskw TASKS (Stem tasklist. Finis)\"\n  execio_rc = RC\n  Address TSO ,\n    \"FREE File(TASKS)\"\n  free_rc = RC\n  msg_rc = Msg(msg_state)\n  @trap_state = TRAPMSG(@trap_state)\n  Return 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Save the updated #2VARS list.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nvdef_save_updates:\n  line_of_code = get_my_sigl() + 2\n/* Varlist\n*\n* Mainframe Software Installation Customizer (MSIC)\n*\n* Variables require 2 records.\n* Record 1:\n* =====================================================================\n* ITEM         C8 The variable name.\n*                 You will wrap it with exclamation marks when used.\n* Attribute    C2 Provides for limited validation and identification.\n*                   DS = Data set name\n*                   LC = Lowercase\n*                   MB = Member name\n*                   MC = Mixed case (ASIS)\n*                   N  = Number (digits)\n*                   UC = Uppercase\n*                   XM = IDTF member to DSName.\n* Length      N2  The maximum size of the value.\n* Description C61 Describes what the variable is used for.\n*\n* Record 2:\n* =====================================================================\n* The initial default value or the user specified value.\n*\n*---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8\n*Item    A  Length Description (value is on the next row).\n*======= == ====== =============================================================\nEnd */\n  vdeflist. = \"\"\n  vdef_ctr = 0\n  Do While (SourceLine(line_of_code) <> \"End */\")\n    vdef_ctr = vdef_ctr + 1\n    vdeflist.vdef_ctr = SourceLine(line_of_code)\n    line_of_code = line_of_code + 1\n  End\n  Address ISPEXEC \"TBTop\" vdef_table\n  tbskip_rc = 0\n  Do While (tbskip_rc = 0)\n    Address ISPEXEC \"TBSkip\" vdef_table\n    tbskip_rc = RC\n    If (tbskip_rc = 0) Then Do\n      vdef_ctr = vdef_ctr + 1\n      vdeflist.vdef_ctr = Left(vdefvar,8) ,\n        left(vdefattr,2) Left(vdeflen,6) Left(vdefdesc,61)\n      vdef_ctr = vdef_ctr + 1\n      vdeflist.vdef_ctr = Left(vdefval,80)\n      Select\n        When (vdefvar = \"WISHLIST\") THEN vdef_wishlist = vdefval\n        When (vdefvar = \"VOLSER\") THEN vdef_volser = vdefval\n        When (vdefvar = \"UNIT\") THEN vdef_unit = vdefval\n        Otherwise DO\n          NOP\n        END\n      END\n    End\n  End\n  vdef_ctr = vdef_ctr + 1\n  vdeflist.vdef_ctr = \"*\"\n  vdef_ctr = vdef_ctr + 1\n  vdeflist.vdef_ctr = \"* End of #2VARS. Saved:\" Date(\"S\") Time()\n  @trap_state = TRAPMSG(\"On\")\n  msg_state = Msg(\"OFF\")\n  Address TSO ,\n    \"ALLOC File(VARS) DataSet(\"vars_dsn\") SHR REUSE\"\n  alloc_rc = RC\n  Address MVS ,\n    \"EXECIO * Diskw VARS (Stem vdeflist. Finis)\"\n  execio_rc = RC\n  Address TSO ,\n    \"FREE File(VARS)\"\n  free_rc = RC\n  msg_rc = Msg(msg_state)\n  @trap_state = TRAPMSG(@trap_state)\n  Return 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Return from which line this was called from.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nget_my_sigl: Return sigl\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n More than just rounding.\n   Floor always goes down to a multiple of height.\n   Ceiling always goes up to a multiple of height.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nFloor_rtn: Procedure\n  Parse Arg @number, @height\n  @occurs = (@number % @height)\n  Select\n    When (@remainder = 0) Then @adjustment = 0\n    When (@number < 0) Then @adjustment = -1\n    Otherwise Do\n      @adjustment = 0\n    End\n  End\n  @result = (@occurs + @adjustment) * @height\n  return @result\n\nCeiling_rtn: Procedure\n  Parse Arg @number, @height\n  @occurs = @number % @height\n  @remainder = @number - (@occurs * @height)\n  Select\n    When (@remainder = 0) Then @adjustment = 0\n    When (@number > 0) Then @adjustment = 1\n    Otherwise Do\n      @adjustment = 0\n    End\n  End\n  @result = (@occurs + @adjustment) * @height\n  return @result\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Set the short message to press a help PFKey.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\ntrapped_an_error:\n  Signal Off Error\n  Signal Off Failure\n  Signal Off Syntax\n  error_line = Sigl\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"!ERR!\"\n  INFOVAL = \"On or near\" error_line\":\"Sourceline(error_line)\n  Address ISPEXEC \"TBAdd infotabl\"\n  ZERRSM = ask_to_get_help()\n  ZERRLM = ZERRLM || ,\n    Left(\"Bad IDTF data set - truncated?\",79)\n  Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n  interpret \"call\" back_here\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n__DATA__\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "###SETUP": {"ttr": 1030, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x08\\x01\\x18\\x02?\\x01\\x18\\x14?\\t\\x13\\x00\\x13\\x00\\x13\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-01-23T00:00:00", "modifydate": "2018-05-23T09:13:08", "lines": 19, "newlines": 19, "modlines": 0, "user": "KTOMIAK"}, "text": "\nGENIE.PDS(###SETUP)\n\nGENIE grants WISHes defined in a WISHLIST data set. The administrator\nwill define one or more WISHLIST data sets and populate each with TOPIC(s)\nsuitable for your role.\n\nIt is recommended to use the same high level qulifier (HLQ) on all of the\nWISHLIST data sets for easy identification. Use the second level qualifer\nfor role based WISHLIST data sets.\n\nUse WISHLIST for the low level qualifier.\n\nDuring the next two tasks the $INSTALL program will copy the two REXX\nprograms to your named SYSEXEC (or SYSPROC) data set and define one\nWISHLIST data set. If you choose to have multiple role based WISHLIST data\nsets then after creating your first one, come back and update the HLQ and\nselect the MSICDEFN task and optionally receive the desired TOPIC(S) into it.\nRemember to run GENIEBLD to update the $$$$0501 configuration member.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#1TASKS": {"ttr": 1032, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x001\\x01\\x18\\x02\\x9f\\x01\\x18\\x14O\\x11I\\x00L\\x00D\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2018-01-29T00:00:00", "modifydate": "2018-05-24T11:49:31", "lines": 76, "newlines": 68, "modlines": 0, "user": "KTOMIAK"}, "text": "*\n* Genuine Every Noteworthy Itemized Examplizer (GENIE).\n*\n* Tasks require 2 records.\n* Record 1:\n* =====================================================================\n* Seq    N3 Three digit sequence identifier\n* Type   C7 What it is you want to do.\n*             Browse : Let the user BROWSE a PDS member.\n*             Edit   : Let the user EDIT a PDS member.\n*             Execute: Run some external REXX code.\n*             Receive: Receive all XM variables.\n*             Routine: Run an internal REXX routine.\n*             Submit : Submit a member to run in the background.\n*             View : Let the user VIEW a PDS member.\n* Item   C8 What is acted upon.\n* Done   D8 The last attempt date filled in by MSIC.\n* Status C2 How that last attempt fared filled in by MSIC.\n*\n* Record 2:\n* =====================================================================\n* Desc  : A descriptive bit of text.\n*\n*---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8\n*SQ Type    Item     Description goes on a second line               Done     St\n*== ======= ======== =============================================== ======== ==\n001 Browse  $#README\nRead about the installation tasks to install the GENIE edit macro.\n002 Routine $SETVARS\nSet values for variables used.\n003 Execute MSICREDT\nGlobally changes variables in named members listed in #3EDIT.\n020 Browse  ###SETUP\nRead about the installation tasks to install the GENIE edit macro.\n021 Execute MSICCOPY\nCopy GENIE and GENIEBLD to SYSEXEC (or SYSPROC) named data set.\n022 Execute MSICDEFN\nDefine a WISHLIST data set to hold WISH members.\n030 Browse  @FILE972\nRead about the installation tasks to install the GENIE edit macro.\n031 Execute RECVAMSC\n(Optional) Receive members for Access Method Services for Catalogs.\n032 Execute RECVDASM\n(Optional) Receive members for Data And Storage Management.\n033 Execute RECVDFPU\n(Optional) Receive members for Data Facility Product User Guide.\n034 Execute RECVJCLR\n(Optional) Receive members for JCL Reference Manual.\n035 Execute RECVJOBC\n(Optional) Receive members for JOB card samples.\n036 Execute RECVMITR\n(Optional) Receive members for z/OS MVS Initialiation and Tuning.\n037 Execute RECVPMAU\n(Optional) Receive members for SMP/E Planning and Migration Assistant.\n038 Execute RECVPSFC\n(Optional) Receive members for Print Services Facility Customization.\n039 Execute RECVREXR\n(Optional) Receive members for REXX Reference.\n040 Execute RECVRXCP\n(Optional) Receive members for REXX Compiler Presentation -George Fulk.\n041 Execute RECVRXCU\n(Optional) Receive members for REXX Compiler User's Guide and Reference.\n042 Execute RECVTSAD\n(Optional) Receive members for Tools And Service Aids.\n043 Execute RECVCRDG\n(Optional) Receive members for CICS Resource Definition Guide.\n044 Execute RECVKTPM\n(Optional) Receive members for Kenneth Tomiak Programming Method (ongoing).\n045 Execute RECVISRE\n(Optional) Receive members for ISPF Edit and Edit Macros (just ISREMSPY)\n046 Execute RECVISPG\n(Optional) Receive members for ISPF Services Guide (in-progress).\n999 Execute GENIEBLD\n(Required) Build configuration member $$$$0501.\n*\n* End of #1TASKS.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#2VARS": {"ttr": 1035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x005\\x01\\x18\\x02\\x7f\\x01\\x18\\x03\\x8f\\x10!\\x00\"\\x00(\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2018-01-27T00:00:00", "modifydate": "2018-02-07T10:21:35", "lines": 34, "newlines": 40, "modlines": 0, "user": "KTOMIAK"}, "text": "*\n* Genuine Every Noteworthy Itemized Examplizer (GENIE).\n*\n* Variables require 2 records.\n* Record 1:\n* =====================================================================\n* ITEM         C8 The variable name.\n*                 You will wrap it with exclamation marks when used.\n* Attribute    C2 Provides for limited validation and identification.\n*                   DS = Data set name\n*                   LC = Lowercase\n*                   MB = Member name\n*                   MC = Mixed case (ASIS)\n*                   N  = Number (digits)\n*                   UC = Uppercase\n*                   XM = IDTF member to DSName.\n* Length      N2  The maximum size of the value.\n* Description C61 Describes what the variable is used for.\n*\n* Record 2:\n* =====================================================================\n* The initial default value or the user specified value.\n*\n*---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8\n*Item    A  Length Description (value is on the next row).\n*======= == ====== =============================================================\nHLQ      UC 8      High level qualifier for sample WISHLIST names in GENIE.\nVENDOR\nSYSEXEC  DS 44     Which //SYSEXEC data set should get GENIE and GENIEBLD.\nenter a fully qualified DSN (no apostrophes)\nWISHLIST DS 44     Name of the WISHLIST pds data set.      (No apostrophes!)\nVENDOR.SYSPG.WISHLIST\n*\n* End of #2VARS.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#3EDIT": {"ttr": 1037, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00U\\x01\\x17!\\x7f\\x01\\x18\\x02/\\x116\\x00\\t\\x00\\x14\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2017-08-05T00:00:00", "modifydate": "2018-01-22T11:36:55", "lines": 9, "newlines": 20, "modlines": 0, "user": "KTOMIAK"}, "text": "*\n* Genuine Every Noteworthy Itemized Examplizer (GENIE).\n*\n* This is a list of members that will undergo variable replacement.\n*\nGENIE\nGENIEBLD\n*\n* End of #3EDIT.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE978": {"ttr": 1039, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04`\\x00\\x17\\x01\\x180\\x8f\\x01\\x180\\x8f\\x16$\\x00Z\\x00Z\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf6@@@'", "ispf": {"version": "04.96", "flags": 0, "createdate": "2018-11-04T00:00:00", "modifydate": "2018-11-04T16:24:17", "lines": 90, "newlines": 90, "modlines": 0, "user": "CBT-496"}, "text": "//***FILE 978 is from Kenneth Tomiak and contains an EDIT macro     *   FILE 978\n//*           that mimics the ISPF 'MODEL' command, but GENIE       *   FILE 978\n//*           is extensible and serves up WISHes from user          *   FILE 978\n//*           created templates.  This is a beta version, after     *   FILE 978\n//*           File 972, which was the first published version.      *   FILE 978\n//*                                                                 *   FILE 978\n//*           ---------------------------------------------------   *   FILE 978\n//*                                                                 *   FILE 978\n//*           Released 2018-11-05                                   *   FILE 978\n//*                                                                 *   FILE 978\n//*           This release is an update of File 972 which Ken       *   FILE 978\n//*           had been working on, after File 972 was published     *   FILE 978\n//*           here.  Since unfortunately, Ken has passed away,      *   FILE 978\n//*           but he kept working almost to the last minute, this   *   FILE 978\n//*           file is probably good, but I don't really know, and   *   FILE 978\n//*           I'm putting it out as a beta version, until someone   *   FILE 978\n//*           will test it and prove it to be reliable.  (SBG)      *   FILE 978\n//*           (Then we'll probably replace File 972 with it.)       *   FILE 978\n//*                                                                 *   FILE 978\n//*           ---------------------------------------------------   *   FILE 978\n//*                                                                 *   FILE 978\n//*           The administrator will create one or more WISHLIST    *   FILE 978\n//*           data sets referenced by the GENIE edit macro that is  *   FILE 978\n//*           placed in your SYSEXEC or SYSPROC concatenation.      *   FILE 978\n//*                                                                 *   FILE 978\n//*           The end user (developers) invokes GENIE on the        *   FILE 978\n//*           command line and expands a relevant TOPIC and CHAPTER *   FILE 978\n//*           to choose a WISH whose SYNTAX is shown and sample     *   FILE 978\n//*           code inserted in the current EDIT session.            *   FILE 978\n//*                                                                 *   FILE 978\n//*           ===================================================== *   FILE 978\n//*           Released 2018-02-07                                   *   FILE 978\n//*           WISHLIST members:                                     *   FILE 978\n//*             DASM - DFSMS Data And Storage Management            *   FILE 978\n//*             DFPU - Data Facility Product User Guide             *   FILE 978\n//*             IBMK - IBM Manuals to be used for WISHes            *   FILE 978\n//*             JCLR - JCL Reference Manual                         *   FILE 978\n//*             MITR - z/OS MVS Initialization and Tuning           *   FILE 978\n//*             PMAU - SMP/E Planning and Migration Assistant       *   FILE 978\n//*             PSFC - Print Services Facility Customization        *   FILE 978\n//*             REXR - REXX Reference                               *   FILE 978\n//*             RXCP - REXX Compiler Presentation -George Fulk      *   FILE 978\n//*             RXCU - REXX Compiler User's Guide and Reference     *   FILE 978\n//*             TSAD - Diagnosis Tools and Service Aids             *   FILE 978\n//*           ===================================================== *   FILE 978\n//*           Released 2018-02-12                                   *   FILE 978\n//*           WISHLIST members:                                     *   FILE 978\n//*             CRDG - CICS Resource Definition Guide               *   FILE 978\n//*             KETU - Kenneth Tomiak Utility Examples (ongoing)    *   FILE 978\n//*           ===================================================== *   FILE 978\n//*           Released 2018-02-25                                   *   FILE 978\n//*           Code changes:                                         *   FILE 978\n//*             GENIE level 02.23 now contains a full smarter       *   FILE 978\n//*             SEARCH that handles line wrapping.                  *   FILE 978\n//*           ===================================================== *   FILE 978\n//*           Released 2018-03-22                                   *   FILE 978\n//*           WISHLIST members:                                     *   FILE 978\n//*             AMSC - Access Method Services for Catalogs          *   FILE 978\n//*           ===================================================== *   FILE 978\n//*           Released 2018-05-13                                   *   FILE 978\n//*           Code changes:                                         *   FILE 978\n//*             GENIE level 02.25 Revamped configuration member     *   FILE 978\n//*             format, some bug fixes, and improved help.          *   FILE 978\n//*                                                                 *   FILE 978\n//*             GENIEBLD level 01.08 Revamped configuration member. *   FILE 978\n//*                                                                 *   FILE 978\n//*           WISHLIST members:                                     *   FILE 978\n//*             ISRE - ISPF Edit and Edit Macros (just ISREMSPY)    *   FILE 978\n//*             ISPG - ISPF Services Guide (in-progress)            *   FILE 978\n//*           ===================================================== *   FILE 978\n//*           Released 2018-05-##                                   *   FILE 978\n//*           Code changes:                                         *   FILE 978\n//*             GENIE level 02.26 Show Book under INFO              *   FILE 978\n//*                         02.27 Warn when var subst fails.        *   FILE 978\n//*                               Grouped some doc under History.   *   FILE 978\n//*                               Inserting uses (newtext).         *   FILE 978\n//*                               MSGLINE & NOTELINE <= 72.         *   FILE 978\n//*             GENIERTA level 01.00 Sample user_routine.           *   FILE 978\n//*                                                                 *   FILE 978\n//*           WISHLIST members:                                     *   FILE 978\n//*             IBMK - Deleted with IBM move to KnowledgeCenter.    *   FILE 978\n//*             JCLR - Shortened titles to fit 24x80 display.       *   FILE 978\n//*             JOBC - JOB Card Standards                <== NEW    *   FILE 978\n//*             KETU - Moved under KTPM.                            *   FILE 978\n//*             KTPM - Kenneth Tomiak Programming Method <== NEW    *   FILE 978\n//*             RXCP - Updated examples.                            *   FILE 978\n//*           ===================================================== *   FILE 978\n//*                                                                 *   FILE 978\n//*           email:  sbgolob@cbttape.org                           *   FILE 978\n//*                                                                 *   FILE 978\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GENIE": {"ttr": 1042, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x1b\\x00(\\x01\\x18\\x03\\x9f\\x01\\x18\\x14?\\t\\x01\\t\\xe3\\x08r\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "02.27", "flags": 0, "createdate": "2018-02-08T00:00:00", "modifydate": "2018-05-23T09:01:28", "lines": 2531, "newlines": 2162, "modlines": 0, "user": "KTOMIAK"}, "text": "/* rexx */\nRexx_GENIE:\n  rexxpgm_version = \"02.27\"           /* ver lev */\n\n  ADDRESS ISREDIT \"MACRO (GENIEMBR) NOPROCESS\"\n  ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n\n  sys_sysuid = SYSVAR(\"SYSUID\")\n  function_rc = Rcvt_Acee()\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Here is where you can tailor GENIE to use different data sets.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n  SELECT\n    WHEN (user_special = \"YES\") THEN DO\n      wish@dsn = \"VENDOR.GENIE.WISHLIST\" /* SET without Apostrophes */\n    END\n    WHEN (WORDPOS(\"GENIEAPP\", saf_connect) > 0) THEN DO\n      wish@dsn = \"!HLQ!.APPLIC.WISHLIST\"  /* SET without Apostrophes */\n    END\n    OTHERWISE DO\n      wish@dsn = \"!WISHLIST!\"             /* SET without Apostrophes */\n    END\n  END\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Here is where you can tailor GENIE to use a different\n configuration file.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n  wish@cfg = \"$$$$0501\"\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nMain_Routine:\n  return_code = Initialization_Routine()\n  IF (return_code = 0) THEN DO\n    return_code = Process_Routine()\n  END\n  return_code = Termination_Routine()\n  ADDRESS ISREDIT \"MEND\"\n  EXIT 1        /* EXIT 1 will place the cursor on the command line. */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n\n Dataset:  REXX(GENIE)\n           Genuine Every Noteworthy Itemized Examplizer (GENIE).\n Contact:  \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n Overview: Similar to MODEL, but expanded to use any TOPIC (manual)\n           as defined in wish@cfg. The TOPIC is assigned a four\n           character type. TOPICs are broken up into CHAPTERs and\n           WISH members provide details that can include DATA lines.\n Syntax:   GENIE |wish|*|?|=keyword|\n           wish    : The combination of a TOPIC, CHAPTER, and sequence.\n           *       : Expand all TOPICs and CHAPTERs at startup.\n           ?       : Pop-up the Primary Command help panel at startup.\n           =keyword: Find keyword in WISH files.\n\n-----------------------------------------------------------------------\n\n History of Modifications\n ------------------------\nvv.mm WHEN     Who / What you did ... (Newest change at the top.)\n----- -------- --------------------------------------------------------\n02.27 20180523 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n         -     1) Added \"B\"ook when requesting INFO on a member.\n      20180518 2) ZERRLM when variable substitution RC > 0.\n----- -------- --------------------------------------------------------\n02.26 20180517 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n         -     1) Added exclamation mark around substitution\n      20180516    variable names.\n               2) Docucmented ID@TYPE values:\n                    ID@TYPE=@ Copyright\n                    ID@TYPE=* Comment\n                    ID@TYPE=B Book\n                    ID@TYPE=D DATALINE\n                    ID@TYPE=E Edited last by\n                    ID@TYPE=G GENIE configuration (see 3 below)\n                    ID@TYPE=I INFOLINE  ======\n                    ID@TYPE=K Keywords\n                    ID@TYPE=M MSGLINE   ==MSG>\n                    ID@TYPE=N NOTELINE  =NOTE=\n                    ID@TYPE=R Run a routine (see 5 below)\n                    ID@TYPE=S Source member name\n                    ID@TYPE=T Title (TOPIC, CHAPTER, Subject)\n                    ID@TYPE=U URL of a Web Page\n                    ID@TYPE=W URL of a Web Site\n                    ID@TYPE=X eXchange variable with value (see 4 below)\n                    ID@TYPE=Z Date and time last updated\n               3) Docucmented configuration member\n                  Column 1 = file_typ\n                  ---------------------\n                    file_typ=T TOPIC\n                    file_typ=C CHAPTER\n                    file_typ=W WISH\n                    file_typ=K Keywords\n               4) Docucmented variable = substitution-value:\n                  GENIE reserved values\n                  --------------------------------------------------\n                    current_dataset = the current dataset name\n                    current_member = the current member name\n                    logon_acct    = from the logon PROCEDURE (ZACCTNUM)\n                    mvsvar_sysname = MVSVAR(\"SYSNAME\")\n                    saf_dfltgrp   = User's default RACF group\n                    saf_name      = RACF name field (20 characters)\n                    sysvar_sysuid = SYSVAR(\"SYSUID\")\n                    zdate         = DATE(\"S\") yyyymmdd\n                    ztime         = TIME()     hh:mm:ss\n                  User defined samples\n                  --------------------\n                    X!your_variable! = \"your static value\"\n                    X!company-url! = \"http://www.ktomiak.com/ORG\"\n                  Tested reserved samples\n                  -----------------------\n                    x!acct! = logon_acct\n                    x!datasetid! = editdsn\n                    x!group! = saf_dfltgrp\n                    x!memberid! = editmbr\n                    x!mvsname! = mvsvar_sysname\n                    x!now-time! = ztime\n                    x!programmer-name! = saf_name\n                    x!sysuser! = sysvar_sysuid\n                    x!todays-date! = zdate\n               5) Documented Routines (ID@TYPE=R)\n                  Known system routines inside GENIE\n                  ----------------------------------\n                    system_symbols\n                  Sample user routines outside GENIE\n                  ----------------------------------\n                    genierta\n               6) Added support for invoking a user routine.\n               7) NOTELINE length limited to 72 characters.\n                  Verification added to GENIE and GENIEBLD.\n                  MSGLINE, too.\n               8) IF NOTELINE inserts INFOLINE then add a space.\n               9) Fixed a bad occurence of GENIESRT being set to \"T\".\n----- -------- --------------------------------------------------------\n02.25 20180513 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Vast renaming of 'item' to member so that I could\n                  use WISH and wish where appropriate.\n               2) Cleanup of TOPIC, CHAPTER, and WISH capitalization.\n               3) Consistent help text for Expand and Unexpand.\n               4) Fixed inserting to use variable newtext.\n----- -------- --------------------------------------------------------\n02.24 20180512 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Stylize using\n                  Programming Using The Kenneth Tomiak Method.\n                 a) Use PUTKTM comments on primary routines.\n                 b) Use PUTKTM on user-defined routines.\n                 c) Conform variable names to lowercase.\n                 d) Remove WIDTH on panels.\n                 e) Correct panel attribute characters (~ for |).\n               2) Stylize using Edit Macro @putktm:\n                  Programming Using The Kenneth Tomiak Method.\n               3) Reenable \"?\" presenting Primary command help.\n               4) Delete unnecessary VPUT of ZERR* variables.\n               5) Transform \"A\"pplication to \"T\"OPIC and \"T\"OPIC to\n                  \"W\"ISH.\n----- -------- --------------------------------------------------------\n02.23 20180224 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Alias FIND with KEYWORD.\n               2) Add full text SEARCH, albeit a CPU consumer.\n----- -------- --------------------------------------------------------\n02.22 20180207 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Hmmm.... IF string <> prior_string and ENTER used\n                  THEN DO a FIND.\n               2) IF FIND turns up nothing then SETMSG.\n----- -------- --------------------------------------------------------\n02.21 20180207 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Moved default wish@dsn to the OTHERWISE block.\n----- -------- --------------------------------------------------------\n02.20 20180207 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Capture RC on LMINIT and LMPUT.\n               2) Added TOPIC level full expansion based on CRDG.\n               3) Made the table field GENIEDES scrollable.\n----- -------- --------------------------------------------------------\n02.19 20170919 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Added line selection Preview.\n----- -------- --------------------------------------------------------\n02.18 20170825 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Changed WHEN to use ABBREV in many lines.\n               2) Change Expand(\\\\) to Expand(||) which led to\n                  changing attribute (%|_) to (%~_).\n               3) Removed DEBUG logic.\n               4) Alter expansion to be expand TOPIC to CHAPTER and\n                  CHAPTER to WISH. Expanding a WISH is invalid.\n----- -------- --------------------------------------------------------\n02.17 20170821 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Moved driver code above comment block.\n----- -------- --------------------------------------------------------\n02.16 20170715 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Added a sample Select-When block for using more\n                  than one WISHLIST data set.\n----- -------- --------------------------------------------------------\n02.15 20170713 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Modified panel labels TOPIC, CHAPTER, and WISH.\n               2) Using VENDOR.GENIE.WISHLIST.\n----- -------- --------------------------------------------------------\n02.14 20170613 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Support \"X\" currdsn = curdsname.\n               2) Exhaustive search to free //BULK####.\n                  I had an EXIT IF a member was asked for and granted.\n               3) Corrected initialization of debuglvl to \"\".\n               4) Corrected comparison of debuglvl to sort_rc.\n               5) Moved init of sort variables sooner.\n----- -------- --------------------------------------------------------\n02.13 20170523 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Replaced Plib_Allocated.\n                  a) Add PANELEND statements.\n                  b) Renamed panel_def to Get_Sigl_Near_Plib.\n----- -------- --------------------------------------------------------\n02.12 20170522 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Adjusted the saf programmer name length.\n----- -------- --------------------------------------------------------\n02.11 20170518 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) To_Uppercase(geniembr) before validation.\n               2) Chased down the RACF name field in the ACEE.\n----- -------- --------------------------------------------------------\n02.10 20170517 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Blank out GENIEANS before prompting.\n               2) Text-Flow the global disclaimer.\n               3) Added sample text to PARSE VERSION.\n               4) PUTKTM-REXX the comment blocks.\n               5) Added ACF list to get programmer-name.\n               6) Validate member name before attempting to fetch it.\n               7) %genie * will show all of the WISH members.\n----- -------- --------------------------------------------------------\n02.09 20170516 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Added MSG(ISPZZ102) to TBDISPL: Row x to y of z.\n----- -------- --------------------------------------------------------\n02.08 20170515 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Process_Routine: allow tbdispl rc(4) on multiple\n                  row selects.\n                  a) IF keep_going > 0 changed to 4.\n                  b) After THEN DO.. END set keep_going = 0.\n               2) Added positioning to the first selected member.\n                  Position_To_Key:\n                    using frowsarg (first row search argument)\n               3) Added primary command Locate to position to an member.\n                  Also uses frowsarg and Position_To_Key.\n----- -------- --------------------------------------------------------\n02.07 20170510 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Handling the Parse of LISTUSER results differently.\n----- -------- --------------------------------------------------------\n02.06 20170508 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Added Top-Secret support to get username and dfltgrp.\n               2) Rename RACF_ variables to SAF_.\n               3) Added support for sysvaruid.\n               4) IF RCVT or RTSS has trouble, or SECNAM not matched by\n                  ACF2, RCVT, or RTSS then use GENIEASK to get name\n                  and group.\n----- -------- --------------------------------------------------------\n02.05 20170507 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Added GENIEASK to get username and dfltgrp WHEN\n                  not using RACF (CA-ACF2 and CA-Top Secret).\n               2) Added id@type = \"R\" to process a routine.\n               3) Renamed ins@line to id@type as in %GENIEBLD.\n               4) Support exchange mvs_smfid.\n               4) Support exchange zdate.\n----- -------- --------------------------------------------------------\n02.04 20170505 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Added code to get RCVTID and parse LISTUSER WHEN\n                  the security product is RACF.\n               2) Added id@type = \"?\" to pop-up intake panel GENIEASK.\n               3) Fixed translating id@type to uppercase.\n                  That means the WISH files are now mixed case\n                  tolerant. For example, you can now use \"X\" or \"x\".\n----- -------- --------------------------------------------------------\n02.03 20170504 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Modified the 'History of Modifications\" to\n                  conform with PUTKTM-REXX.\n               2) Support case-insensitive id@type values.\n               3) Added support for user specified string substitution\n                  based on id@type = X using GENIE reserved values.\n----- -------- --------------------------------------------------------\n02.02 20170417 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Handling a new $$$$$$$$ format of 1 to many\n                  \"T\", \"C\", or \"W\" records per member.\n               2) Add support for Keywords (1 to many).\n----- -------- --------------------------------------------------------\n02.01 20170411 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Rebranded INSERTS to GENIE using WISHLIST.\n               2) No real zvm support as it lacks the concept\n                  to support a PC folder or MVS DSORG=PO DSN.\n               3) No real PC support now that SPF/PC will not\n                  work on Windodws 8.0 and above.\n               4) Using one generic TBDISPL panel.\n----- -------- --------------------------------------------------------\n02.00 20170330 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Changed zos_dsn to be userid centric.\n----- -------- --------------------------------------------------------\n01.08 20080119 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Added pop-up IF '?' used to see the complete\n                  list of category/class names and description.\n----- -------- --------------------------------------------------------\n01.07 20080117 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) IF PC, assume SPF/PC 4.0, get ZPANPATH and\n                  check the panels for a line with &INSLVL = '##' and\n                  check IF the level matches what this version of the\n                  code requires. IF not found or not matched, check IF\n                  we should update them or else exit.\n----- -------- --------------------------------------------------------\n01.06 20080112 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Renamed to INSERTS, adding PC and VM support.\n----- -------- --------------------------------------------------------\n01.05 20080103 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Corrected choosing a construct from the panel.\n----- -------- --------------------------------------------------------\n01.04 20080101 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Reworked how sub-levels are used.\n----- -------- --------------------------------------------------------\n01.03 20071230 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Force wish@dsn to be coded.\n               2) Force wish@cfg to contain names and descriptions.\n               3) Only allocate tables and panels IF needed.\n----- -------- --------------------------------------------------------\n01.02 20071225 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n      Merry Christmas.\n               1) Expanded to read the class member in order to\n                  map statements to files.\n----- -------- --------------------------------------------------------\n01.01 20071223 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original base code.\n----- -------- --------------------------------------------------------\n\n-----------------------------------------------------------------------\n\nSTANDARD GLOBAL DISCLAIMER\nThe author explicitly disavows any claim whatsoever about the\ncorrectness or functionality of this program, and disclaims liability\nfor anything and everything bad that might happen in connection with,\nbefore, during, or after using it. I have tried to make it work right,\nand I am personally pretty confident that it does, but everybody makes\nmistakes, so IF you use it, you do so at your own risk.\n\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_Routine:\n  return_code = 0\n\n  UPPER GENIEMBR\n\n  ADDRESS ISREDIT \"(editdsn,origdsn,origlibn) = DATASET\"\n  ADDRESS ISREDIT \"(editmbr) = MEMBER\"\n  ADDRESS ISREDIT \"(bndsl,bndsr) = BOUNDS\"\n  bnds_left = bndsl + 0\n  bnds_right = bndsr + 0\n\n  ZERRALRM = \"NO\"\n  ZERRHM = \"*\"\n  ZERRSM = \"\"\n  ZERRLM = \"\"\n\n  starter_line = COPIES(\"1a2b3c4d\",9)\n  plib_rc = -1\n\n  sysvar_SYSLTERM = SYSVAR(\"SYSLTERM\")\n  sysvar_SYSWTERM = SYSVAR(\"SYSWTERM\")\n\n  ADDRESS ISREDIT \"(toprow, botrow) = DISPLAY_LINES\"\n  isredit_rc = RC\n  IF (isredit_rc <> 0) THEN DO\n    toprow = 0\n  END\n  resume_row = toprow + 0\n\n  ADDRESS ISREDIT \"(zlstline) = LINENUM .ZLast\"\n\n  ADDRESS ISREDIT \"PROCESS DEST\"            /* ISPF adjusts for a/b */\n  isredit_rc = RC\n  SELECT\n    WHEN (isredit_rc = 20) THEN DO /* empty file  */\n      destline = 0\n    END\n    WHEN (isredit_rc = 16) THEN DO\n      ZERRALRM = \"YES\"\n      ZERRSM = \"PRESS HELP\"\n      ZERRLM = \"Incomplete or conflicting line commands.\"\n      ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      return_code = 16\n      RETURN return_code\n    END\n    WHEN (isredit_rc = 8) THEN DO\n      destline = zlstline\n      ZERRALRM = \"YES\"\n      ZERRSM = \"Insert command pending\"\n      ZERRLM = ,\n        \"An A/B line command has not been specified.\" ,\n        \".ZLAST (\"destline\") will be used instead.\"\n      ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    END\n    WHEN (isredit_rc = 0) THEN DO\n      line_pos = \"AFTER\"\n      ADDRESS ISREDIT \"(destline) = LINENUM .ZDEST\"\n      isredit_rc = RC\n      IF (isredit_rc > 0) THEN DO\n        destline = 0\n      END\n    END\n    OTHERWISE DO\n      destline = 0\n    END\n  END\n  aftrline = destline + 0\n\n  show_help = 0\n\n  listuser_done = \"No\"\n  valid_names = \"@#$ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n  sortfld = \"GENIEITM\"\n  dsplfld = \"WISH ID\"\n  GENIESRT = \"A\"\n  genielvl = \"T\"\n\n  prior_string = \"\"\n  exp_len = 0\n  genieexp = \"\"\n  geniekey = \"\"\n  buildkey = \"T\"\n  key_pos = POS(\"=\",geniembr)\n  IF (key_pos > 0) THEN DO\n    geniekey = SUBSTR(geniembr,(key_pos + 1))\n    GENIEFND = geniekey\n    buildkey = \"\"\n    geniembr = \"\"\n  END\n  key_len = LENGTH(geniekey)\n  SELECT\n    WHEN (geniembr = \"?\") THEN DO\n      show_help = 1\n      geniembr = \"\"\n    END\n    WHEN (geniembr = \"*\") THEN DO\n      geniekey = \"*\"\n    END\n    WHEN (geniembr <> \"\") THEN DO\n      mbr@len = LENGTH(geniembr)\n      good_name = 0\n      IF (mbr@len < 9) THEN DO\n        geniember = To_Uppercase(geniembr)\n        IF (POS(LEFT(geniembr,1),LEFT(valid_names,29)) = 0 ) THEN DO\n          good_name = 1\n          SAY \"1st character bad:\" LEFT(geniembr,1)\n        END\n        DO ltr = 2 TO mbr@len\n          IF (POS(SUBSTR(geniembr,ltr,1),valid_names) = 0 ) THEN DO\n            good_name = 1\n          SAY ltr \"character bad:\" SUBSTR(geniembr,ltr,1)\n          END\n        END\n        IF (good_name = 0) THEN DO\n          fetch_item = geniembr\n          fetchsel = \"F\"\n          return_code = Fetch_The_Member()\n          return_code = 2\n          RETURN return_code\n        END\n        ELSE DO\n          SAY geniembr \"contains invalid characters for a WISH.\"\n        END\n      END\n    END\n    OTHERWISE DO\n      NOP\n    END\n  END\n\n  strglen = 80\n  purgekey = \"\"\n\n  return_code = Tbcreate_Genie()\n  IF (return_code = 0) THEN DO\n    return_code = Read_Zos_Index()\n  END\n  buildkey = \"\"\n  plib_rc = Plib_Allocated()\n  IF (plib_rc <> 0) THEN DO\n    SAY \"Problem building a PLIB:\" plib_rc\n    return_code = plib_rc\n    RETURN return_code\n  END\n\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_Routine:\n  ZSCR = \"PAGE\"\n  ADDRESS ISPEXEC \"VGET (ZSCREENW)\"\n  hw = (ZSCREENW - 17) % 2\n  ZTDMARK = COPIES(\"-\",hw)\"> End of WISHes <\"COPIES(\"-\",hw)\n  GENIEHD1 = '$$$$'\n  GENIEHD2 = 'Genuine Every Noteworthy Itemized Examplizer'\n  prevfld = sortfld\n  prevsrt = GENIESRT\n  frowsarg = \"\"\n  keep_going = 0\n  DO WHILE (keep_going = 0)\n    ZTDSELS = 0\n    ZCMD = \"\"\n    initzcmd = \"\"\n    IF (show_help = 1) THEN DO\n      show_help = 0\n      initzcmd = \"?\"\n      ADDRESS ISPEXEC \"CONTROL NONDISPL ENTER\"\n    END\n    IF (frowsarg <> \"\") THEN DO\n      function_rc = Position_To_Key()\n    END\n    ADDRESS ISPEXEC ,\n      \"TBDISPL GENIETBL PANEL(GENIEPRI)\" ,\n      \"MSG(ISPZZ102)\"\n    keep_going = RC\n    frowsarg = \"\"\n    /* RETURN codes                      */\n    /* 4  - The enter key or scroll      */\n    /*      command used; additional data*/\n    /*      remains to be stored         */\n    /* 8  - The END or RETURN command was*/\n    /*      entered.  IF crp at top, no  */\n    /*      lines modified               */\n    /*    - Panel was generated from tags*/\n    /*      and the EXIT command was     */\n    /*      entered                      */\n    IF (keep_going = 8) THEN DO\n      ZERRALRM = \"NO\"\n      ZERRSM = \"OK\"\n      ZERRLM = \"You asked to end this dialog.\"\n      ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      LEAVE\n    END\n    IF (keep_going > 4) THEN DO\n      ZERRALRM = \"YES\"\n      ZERRSM = \"NO\"\n      ZERRLM = \"Uh Oh, panel(GENIEPRI)\",\n        \"failed to tbdispl, rc(\"keep_going\").\"\n      ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      RETURN keep_going\n    END\n    keep_going = 0\n    ZERRALRM = \"NO\"\n    ZERRSM = \"\"\n    ZERRLM = \"\"\n    now_what = Zcmd_Main_Loop()\n    IF (now_what <> 0) THEN DO\n      keep_going = 1\n    END\n    IF (keep_going = 0) THEN DO\n      now_what = Process_Zdtsel()\n    END\n  END\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_Routine:\n  IF (table_create = 0) THEN DO\n    ADDRESS ISPEXEC \"TBEND SDUMPTBL\"\n  END\n  IF (plib_rc = 0) THEN DO\n    ADDRESS ISPEXEC ,\n      \"LMFREE DATAID(&TMPPNL)\"\n    ADDRESS ISPEXEC ,\n      \"LIBDEF ISPPLIB\"\n    ADDRESS TSO ,\n      \"FREE FILE(\"panel_dd\")\"\n  END\n  resume_row = resume_row + 1\n  ADDRESS ISREDIT \"CURSOR =\" resume_row \"1\"\n  isredit_rc = RC\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Remove selected entries from the displayed table.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nPurge_Genietbl:\n  IF (purgekey = \"\") THEN DO\n    RETURN 0\n  END\n  ADDRESS ISPEXEC \"TBTOP GENIETBL\"\n  ADDRESS ISPEXEC \"TBSKIP GENIETBL\"\n  purge_rc = RC\n  DO WHILE (purge_rc = 0)\n    SELECT\n      WHEN (purgekey = \"*\") THEN DO\n        ADDRESS ISPEXEC \"TBDELETE GENIETBL\"\n        purge_rc = RC\n      END\n      WHEN (purgekey = \"C\") & ,\n           (LENGTH(genieitm) > 4) THEN DO\n        ADDRESS ISPEXEC \"TBDELETE GENIETBL\"\n        purge_rc = RC\n      END\n      OTHERWISE DO\n        NOP\n      END\n    END\n    ADDRESS ISPEXEC \"TBSKIP GENIETBL\"\n    purge_rc = RC\n  END\n  purgekey = \"\"\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Create a table to hold the members.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTbcreate_Genie:\n  ADDRESS ISPEXEC ,\n    \"TBEND GENIETBL\"\n  ADDRESS ISPEXEC ,\n    \"TBCREATE GENIETBL\",\n    \"KEYS(GENIEITM)\" ,\n    \"NAMES(GENIESEL, GENIETPC, GENIECHA,\",\n      \"GENIESEQ, GENIEDES, GENIEAKA)\",\n    \"REPLACE\",\n    \"NOWRITE\"\n  tbcreate_rc = RC\n  /* RETURN codes                      */\n  /*  4 - Duplicate table exists but   */\n  /*      \"replace\" specified          */\n  /*  8 - Table already exists;        */\n  /*      \"replace\" not specified      */\n  /* 12 - Table in use; enq failed     */\n  /* 16 - Table input library not      */\n  /*      allocated with \"write\"       */\n  /* 20 - Severe error                 */\n  IF (tbcreate_rc <> 0) THEN DO\n    SAY \"Uh Oh, table(GENIETBL) failed to create, rc(\"tbcreate_rc\").\"\n    RETURN tbl_rc\n  END\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Read configuration member to store members, keywords, and titles.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nRead_Zos_Index:\n  \"ALLOC FILE(GENIECFG) DATASET('\"wish@dsn\"(\"wish@cfg\")') SHR REUSE\"\n  alloc_rc = RC\n  IF (alloc_rc <> 0) THEN DO\n    SAY \"Allocation of the configuration file failed, RC=\"alloc_rc\n    return_code = alloc_rc\n    RETURN return_code\n  END\n  \"EXECIO * DISKR GENIECFG (STEM cfg_record. FINIS)\"\n  diskr_rc = RC\n  \"FREE FILE(GENIECFG)\"\n  IF (diskr_rc <> 0) THEN DO\n    SAY \"Read of the configuration file failed, RC=\"diskr_rc\n    ZERRSM = \"DISKR!\"\n    ZERRLM = \"GENIECFG DISKR error:\" diskr_rc\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    return_code = 16\n    RETURN return_code\n  END\n  return_code = Build_My_Table()\n  key_len = 0\n  exp_len = 0\n  ADDRESS ISPEXEC \"TBTOP GENIETBL\"\n  tbtop_rc = RC\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Position to a key.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nPosition_To_Key:\n  ADDRESS ISPEXEC \"TBTOP GENIETBL\"\n  ADDRESS ISPEXEC \"TBVCLEAR GENIETBL\"\n  genieitm = frowsarg\n  ADDRESS ISPEXEC \"TBSARG GENIETBL\" ,\n    \"NEXT NAMECOND(GENIEITM,GE)\"\n  tbsarg_rc = RC\n  ADDRESS ISPEXEC \"TBScan GENIETBL\"\n  tbscan_rc = RC\n  IF (tbscan_rc <> 0) THEN DO\n    RETURN 0\n  END\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Sort the table.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nSort_The_Table:\n  ADDRESS ISPEXEC \"TBSORT GENIETBL FIELDS(\"sortfld\",C,\"GENIESRT\")\"\n  sort_rc = RC\n      /* RETURN codes                 */\n      /* 12 - Table is not OPEN       */\n      /* 16 - Numeric convert error   */\n      /* 20 - Severe error            */\n  IF (sort_rc <> 0) THEN DO\n    IF (sort_rc > 1) THEN DO\n      SAY \"Sort_The_Table sort RC:\" sort_rc\n      SAY \"  Field:\" sortfld \"Sequence:\" geniesrt\".\"\n    END\n  END\n  prevfld = sortfld\n  prevsrt = GENIESRT\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Compare the WISH to see if we should show it (add to table).\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nWould_It_Match:\n  matching = \"\"\n  SELECT\n    WHEN (geniekey = \"*\") * (exp_len > 0) THEN DO\n      IF ((To_Lowercase(LEFT(prior_item,LENGTH(genieexp))) = ,\n          To_Lowercase(genieexp))) ,\n    THEN DO\n      matching = matching\"*(itm) \"\n    END\n    END\n    WHEN (geniekey = \"*\") THEN DO\n      matching = matching\"key(*) \"\n    END\n    WHEN (genieexp = \"*\") THEN DO\n      matching = matching\"exp(*) \"\n    END\n    WHEN (key_len > 0) THEN DO\n      IF (POS(To_Lowercase(geniekey),To_Lowercase(genieaka)) > 0) ,\n        THEN DO\n        matching = matching\"aka \"\n        find_status = 1\n      END\n      IF (POS(To_Lowercase(geniekey),To_Lowercase(GENIEDES)) > 0) ,\n        THEN DO\n        matching = matching\"des \"\n        find_status = 1\n      END\n      IF (To_Lowercase(geniekey) = ,\n          To_Lowercase(LEFT(prior_item,key_len))) ,\n        THEN DO\n        matching = matching\"key(itm) \"\n        matching = matching\"des \"\n        find_status = 1\n      END\n    END\n    WHEN (exp_len > 0) THEN DO\n      IF ((To_Lowercase(LEFT(prior_item,LENGTH(genieexp))) = ,\n          To_Lowercase(genieexp)) & ,\n          (LENGTH(STRIP(prior_item,\"T\",\" \")) = exp_len)) ,\n        THEN DO\n        matching = matching\"exp(itm) \"\n        matching = matching\"key(itm) \"\n        matching = matching\"des \"\n        find_status = 1\n      END\n    END\n    WHEN (buildkey = \"T\") & ,\n         (prior_type = \"T\") THEN DO\n      matching = matching\"T \"\n    END\n    OTHERWISE DO\n      NOP\n    END\n  END\n  RETURN LENGTH(matching)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Loop thru the configuration WISHLIST data and add to the table.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nBuild_My_Table:\n  ADDRESS ISPEXEC \"TBVCLEAR GENIETBL\"\n  first_sw = 0\n  DO cfgx = 1 TO cfg_record.0\n    PARSE VAR cfg_record.cfgx,\n      =1  file_gen +1,\n      =2  file_item +8,\n      =10 blank_one +1,\n      =11 file_typ +1,\n      =12 blank_two +1,\n      =13 file_txt\n    IF (file_gen <> \"G\") THEN DO\n      ITERATE\n    END\n    IF (first_sw = 0) THEN DO\n      first_sw = 1\n      prior_item = file_item\n      prior_type = file_typ\n      first_wish = \"\"\n    END\n    IF (file_item <> prior_item) THEN DO\n      function_rc = Would_It_Match()\n      IF (matching <> \"\") THEN DO\n        IF (first_wish = \"\") THEN DO\n          first_wish = prior_item\n        END\n        GENIEDES = STRIP(GENIEDES,\"T\",\" \")\n        ADDRESS ISPEXEC ,\n          \"TBADD GENIETBL ORDER\"\n        tbadd_rc = RC\n        IF (tbadd_rc > 8) THEN DO\n          SAY \"Uh Oh,\" genieitm \"add failed, rc(\"tbadd_rc\").\"\n        END\n      END\n      /* RETURN codes                    */\n      /*  4 - Number of rows parameter   */\n      /*      was specified but storage  */\n      /*      was only obtained for a    */\n      /*      single row                 */\n      /*  8 - Key tables: a row with the */\n      /*      same key already exists;   */\n      /*      crp set to top             */\n      /* 12 - Table is not OPEN          */\n      /* 20 - Severe error               */\n      ADDRESS ISPEXEC \"TBVCLEAR GENIETBL\"\n      prior_item = file_item\n      prior_type = file_typ\n    END\n    genieitm = STRIP(file_item,\"T\",\" \")\n    GENIETPC = LEFT(file_item,4)\n    IF (LENGTH(genieitm) > 5) THEN DO\n      GENIECHA = SUBSTR(file_item,5,2)\n    END\n    IF (LENGTH(genieitm) = 8) THEN DO\n      GENIESEQ = SUBSTR(file_item,7,2)\n    END\n    genietyp = file_typ\n    genietxt  = STRIP(file_txt ,\"T\",\" \")\n    SELECT\n      WHEN (file_typ = \"T\") THEN DO\n        IF (GENIEDES = \"\") THEN DO\n          GENIEDES = genietxt\n        END\n        ELSE DO\n          GENIEDES = GENIEDES\" \"genietxt\n        END\n        GENIECHA = \"==\"\n        GENIESEQ = \"--\"\n        genieaka = \"\"\n      END\n      WHEN (file_typ = \"C\") THEN DO\n        IF (GENIEDES = \"\") THEN DO\n          GENIEDES = genietxt\n        END\n        ELSE DO\n          GENIEDES = GENIEDES\" \"genietxt\n        END\n        GENIESEQ = \"--\"\n        genieaka = \"\"\n      END\n      WHEN (file_typ = \"W\") THEN DO\n        IF (GENIEDES = \"\") THEN DO\n          GENIEDES = genietxt\n        END\n        ELSE DO\n          GENIEDES = GENIEDES\" \"genietxt\n        END\n        genieaka = \"\"\n      END\n      WHEN (file_typ = \"K\") THEN DO\n        IF (genieaka = \"\") THEN DO\n          genieaka = genietxt\n        END\n        ELSE DO\n          genieaka = genieaka\" \"genietxt\n        END\n      END\n      OTHERWISE DO\n        SAY \"Huh?\" ,\n          LEFT(cfg_record.cfgx,70)\n      END\n    END\n  END\n  function_rc = Would_It_Match()\n  IF (matching <> \"\") THEN DO\n    GENIEDES = STRIP(GENIEDES,\"T\",\" \")\n    ADDRESS ISPEXEC ,\n      \"TBADD GENIETBL ORDER\"\n    tbadd_rc = RC\n    IF (tbadd_rc > 8) THEN DO\n      SAY \"Uh Oh,\" genieitm \"add failed, rc(\"tbadd_rc\").\"\n    END\n  END\n  maxrows = 0\n  ADDRESS ISPEXEC ,\n    \"TBSTATS GENIETBL ROWCURR(MAXROWS)\"\n  tbstats_rc = RC\n    /*  RETURN codes                     */\n    /*   0 - Normal RETURN even IF table */\n    /*       does not exist              */\n    /*  16 - Variable value truncated    */\n    /*  20 - Severe error                */\n  IF (maxrows > 0) THEN DO\n    function_rc = Sort_The_Table()\n  END\n  ELSE DO\n    ZERRALRM = \"YES\"\n    ZERRSM = \"PRESS HELP\"\n    ZERRLM = \"What you chose led to an empty table.\" ,\n      \"Use the REFRESH primary command to view all TOPICs or\",\n      \"use the FIND option to search for a different string.\"\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n  END\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Remove TOPIC or CHAPTER members.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nUnexpand_Table:\n  origfld = sortfld\n  origsrt = GENIESRT\n  sortfld = \"GENIEITM\"\n  GENIESRT = \"A\"\n  function_rc = Sort_The_Table()\n  ADDRESS ISPEXEC \"TBTOP GENIETBL\"\n  ADDRESS ISPEXEC \"TBVCLEAR GENIETBL\"\n  genieitm = genieexp\n  ADDRESS ISPEXEC \"TBSARG GENIETBL\" ,\n    \"Next NameCond(GENIEITM,GT)\"\n  tbsarg_rc = RC\n  IF (tbsarg_rc <> 0) THEN DO\n    RETURN 0\n  END\n  tbscan_rc = 0\n  DO WHILE (tbscan_rc = 0)\n    ADDRESS ISPEXEC \"TBSCAN GENIETBL\"\n    tbscan_rc = RC\n    IF (LEFT(genieitm,exp_len) <> genieexp) THEN DO\n      LEAVE\n    END\n  ADDRESS ISPEXEC \"TBDELETE GENIETBL\"\n  END\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Process the FIXED section of the panel - COMMAND field.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nZcmd_Main_Loop:\n  uppercase_zcmd = TRANSLATE(zcmd)\n  ZCMD = \"\"\n  SELECT\n    WHEN (uppercase_zcmd = \"?\") THEN DO\n      zcmdverb = uppercase_zcmd\n    END\n    WHEN (ABBREV(\"SORT\",uppercase_zcmd,2) = 1) THEN DO\n      zcmdverb = uppercase_zcmd\n    END\n    WHEN (ABBREV(\"ORDER\",uppercase_zcmd,1) = 1) THEN DO\n      zcmdverb = uppercase_zcmd\n    END\n    WHEN (ABBREV(\"FINDKYWD\",uppercase_zcmd,1) = 1) THEN DO\n      zcmdverb = uppercase_zcmd\n      zcmditm = GENIEFND\n    END\n    WHEN (ABBREV(\"SEARCH\",uppercase_zcmd,2) = 1) THEN DO\n      zcmdverb = uppercase_zcmd\n      zcmditm = GENIEFND\n    END\n    WHEN (ABBREV(\"SRCHTEXT\",uppercase_zcmd,2) = 1) THEN DO\n      zcmdverb = uppercase_zcmd\n      zcmditm = GENIEFND\n    END\n    WHEN (uppercase_zcmd = \"\") & ,\n      (prior_string <> GENIEFND) THEN DO\n      IF (GENIEFND = \"\") THEN DO\n        prior_string = \"\"\n        RETURN 0\n      END\n      zcmdverb = \"FINDKYWD\"\n      zcmditm = GENIEFND\n    END\n    WHEN (POS(\" \",uppercase_zcmd) > 0) THEN DO\n      PARSE VAR uppercase_zcmd zcmdverb zcmditm\n    END\n    WHEN (uppercase_zcmd = \"\") THEN DO\n      RETURN 0\n    END\n    OTHERWISE DO\n      PARSE VAR uppercase_zcmd zcmdverb +1 zcmditm\n    END\n  END\n  function_rc = Zcmd_Selection()\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Process the COMMAND.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nZcmd_Selection:\n  SELECT\n    WHEN (LEFT(zcmdverb,1) = \"+\") | ,\n         (ABBREV(\"EXPAND\",zcmdverb,1) = 1) THEN DO\n      IF (LENGTH(zcmditm) = 8) THEN DO\n        ZERRALRM = \"YES\"\n        ZERRSM = \"PRESS HELP\"\n        ZERRLM = \"You cannot expand a WISH. Request denied!\"\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      END\n      ELSE DO\n        genieexp = zcmditm\n        exp_len = LENGTH(genieexp) + 2\n        call_rc = Build_My_Table()\n        exp_len = 0\n      END\n    END\n    WHEN (LEFT(zcmdverb,1) = \"*\") THEN DO\n      IF (LENGTH(zcmditm) = 8) THEN DO\n        ZERRALRM = \"YES\"\n        ZERRSM = \"PRESS HELP\"\n        ZERRLM = \"You cannot expand a WISH. Request denied!\"\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      END\n      ELSE DO\n        geniekey = \"*\"\n        genieexp = zcmditm\n        exp_len = LENGTH(genieexp) + 4\n        call_rc = Build_My_Table()\n        exp_len = 0\n      END\n    END\n    WHEN (LEFT(zcmdverb,1) = \"-\") | ,\n         (ABBREV(\"UNEXPAND\",zcmdverb,1) = 1) THEN DO\n      IF (LENGTH(zcmditm) = 8) THEN DO\n        ZERRALRM = \"YES\"\n        ZERRSM = \"PRESS HELP\"\n        ZERRLM = \"You cannot unexpand (shrink) a WISH. Request denied!\"\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      END\n      ELSE DO\n        genieexp = zcmditm\n        exp_len = LENGTH(genieexp)\n        call_rc = Unexpand_Table()\n      END\n    END\n    WHEN (LEFT(zcmdverb,1) = \"?\") THEN DO\n      GENIEZSL = \"\"\n      go_again = 0\n      DO WHILE (go_again = 0)\n        ADDRESS ISPEXEC \"ADDPOP\"\n        ADDRESS ISPEXEC \"DISPLAY PANEL(GENIEZSL)\"\n        display_rc = RC\n        ADDRESS ISPEXEC \"REMPOP\"\n        IF (display_rc > 0) THEN DO\n          go_again = 1\n          LEAVE\n        END\n        SELECT\n          WHEN (GENIEZSL = \"?\") THEN DO\n            ZERRALRM = \"YES\"\n            ZERRSM = \"No way!\"\n            ZERRLM = \"Asking for recursive help is inexscuable.\"\n            ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n          END\n          WHEN (GENIEZSL = \"\") THEN DO\n          END\n          OTHERWISE DO\n            zcmd = GENIEZSL\n            function_rc = Zcmd_Main_Loop()\n            go_again = 1\n          END\n        END\n      END\n    END\n    WHEN (ABBREV(\"FIND\" ,zcmdverb,1) = 1) | ,\n         (ABBREV(\"FINDKYWD\" ,zcmdverb,1) = 1) | ,\n         (ABBREV(\"KEYWORD\" ,zcmdverb,1) = 1) THEN DO\n      IF (zcmditm = \"\") THEN DO\n        ZERRALRM = \"YES\"\n        ZERRSM = \"Problem!\"\n        ZERRLM = \"You asked to find nothing.\"\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n        keep_going = 2\n        RETURN 4\n      END\n      purgekey = \"C\"\n      call_rc = Purge_Genietbl()\n      GENIEFND = zcmditm\n      geniekey = zcmditm\n      key_len = LENGTH(geniekey)\n      find_status = 0\n      call_rc = Build_My_Table()\n      IF (find_status = 0) THEN DO\n        ZERRALRM = \"YES\"\n        ZERRSM = \"Not found\"\n        ZERRLM = GENIEFND \"does not appear in titles nor keywords.\"\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      END\n      ELSE DO\n        frowsarg = first_wish\n        function_rc = Position_To_Key()\n      END\n      prior_string = GENIEFND\n      key_len = 0\n    END\n    WHEN (ABBREV(\"SEARCH\",zcmdverb,2) = 1) | ,\n         (ABBREV(\"SRCHTEXT\",zcmdverb,2) = 1) THEN DO\n      IF (zcmditm <> \"\") THEN DO\n        GENIEFND = zcmditm\n        zcmditm = \"\"\n      END\n      prior_string = GENIEFND\n      genieask = \"Search can take a long time, are you sure?\" ,\n        \"Y for YES otherwise No.\"\n      GENIELEN = 3\n      GENIELIM = \"            \" COPIES(\"+\",GENIELEN)\n      GENIEANS = \"\"\n      ADDRESS ISPEXEC \"DISPLAY PANEL(GENIEASK)\"\n      IF (ABBREV(\"YES\",To_Uppercase(GENIEANS),1) <> 1) THEN DO\n        ZERRALRM = \"NO\"\n        ZERRSM = \"Search cancelled\"\n        ZERRLM = \"You asked to cancel the long running search.\"\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n        keep_going = 2\n        RETURN 4\n      END\n      IF (GENIEFND = \"\") THEN DO\n        ZERRALRM = \"YES\"\n        ZERRSM = \"Problem!\"\n        ZERRLM = \"You asked to search for nothing.\"\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n        keep_going = 2\n        RETURN 4\n      END\n      purgekey = \"C\"\n      call_rc = Purge_Genietbl()\n      first_sw = 0\n      blobfound = 0\n      DO cfgx = 1 TO cfg_record.0\n        PARSE VAR cfg_record.cfgx,\n          =1  file_gen +1,\n          =2  file_item +8,\n          =10 blank_one +1,\n          =11 file_typ +1,\n          =12 blank_two +1,\n          =13 file_txt\n        IF (file_gen <> \"G\") THEN DO\n          ITERATE\n        END\n        IF (first_sw = 0) THEN DO\n          first_sw = 1\n          prior_item = file_item\n          prior_type = file_typ\n          ADDRESS ISPEXEC \"TBVCLEAR GENIETBL\"\n          first_wish = \"\"\n        END\n        IF (file_item <> prior_item) THEN DO\n          function_rc = Search_Pds_Member()\n          prior_item = file_item\n          prior_type = file_typ\n          ADDRESS ISPEXEC \"TBVCLEAR GENIETBL\"\n        END\n        genieitm = STRIP(file_item,\"T\",\" \")\n        GENIETPC = LEFT(file_item,4)\n        IF (LENGTH(genieitm) > 5) THEN DO\n          GENIECHA = SUBSTR(file_item,5,2)\n        END\n        IF (LENGTH(genieitm) = 8) THEN DO\n          GENIESEQ = SUBSTR(file_item,7,2)\n        END\n        genietyp = file_typ\n        genietxt  = STRIP(file_txt ,\"T\",\" \")\n        SELECT\n          WHEN (file_typ = \"T\") THEN DO\n            IF (GENIEDES = \"\") THEN DO\n              GENIEDES = genietxt\n            END\n            ELSE DO\n              GENIEDES = GENIEDES\" \"genietxt\n            END\n            GENIECHA = \"==\"\n            GENIESEQ = \"--\"\n          END\n          WHEN (file_typ = \"C\") THEN DO\n            IF (GENIEDES = \"\") THEN DO\n              GENIEDES = genietxt\n            END\n            ELSE DO\n              GENIEDES = GENIEDES\" \"genietxt\n            END\n            GENIESEQ = \"--\"\n          END\n          WHEN (file_typ = \"W\") THEN DO\n            IF (GENIEDES = \"\") THEN DO\n              GENIEDES = genietxt\n            END\n            ELSE DO\n              GENIEDES = GENIEDES\" \"genietxt\n            END\n          END\n          WHEN (file_typ = \"K\") THEN DO\n            IF (genieaka = \"\") THEN DO\n              genieaka = genietxt\n            END\n            ELSE DO\n              genieaka = genieaka\" \"genietxt\n            END\n          END\n          OTHERWISE DO\n            SAY \"Huh?\" ,\n              LEFT(cfg_record.cfgx,70)\n          END\n        END\n        GENIEDES = STRIP(GENIEDES,\"T\",\" \")\n      END\n      function_rc = Search_Pds_Member()\n      IF (blobfound = 0) THEN DO\n        ZERRALRM = \"YES\"\n        ZERRSM = \"Not found\"\n        ZERRLM = GENIEFND \"does not appear in the WISHLIST members.\"\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      END\n      ELSE DO\n        frowsarg = first_wish\n        function_rc = Position_To_Key()\n      END\n      prior_item = \"\"\n      exp_len = 0\n      genieexp = \"\"\n      geniekey = \"\"\n    END\n    WHEN (ABBREV(\"INFO\",zcmdverb,1) = 1) THEN DO\n      fetch_item = zcmditm\n      fetchsel = \"I\"\n      call_rc = Itemize_Detail()\n    END\n    WHEN (ABBREV(\"LOCATE\",zcmdverb,1) = 1) THEN DO\n      frowsarg = zcmditm\n      function_rc = Position_To_Key()\n    END\n    WHEN (ABBREV(\"ORDER\",zcmdverb,1) = 1) THEN DO\n      SELECT\n        WHEN (GENIESRT = \"A\") THEN DO\n          GENIESRT = \"D\"\n        END\n        OTHERWISE DO\n          GENIESRT = \"A\"\n        END\n      END\n      function_rc = Sort_The_Table()\n    END\n    WHEN (ABBREV(\"SORT\",zcmdverb,4) = 1) THEN DO\n      SELECT\n        WHEN (prevfld = \"GENIEDES\") THEN DO\n          sortfld = \"GENIEITM\"\n          dsplfld = \"WISH ID\"\n          GENIESRT = \"A\"\n        END\n        OTHERWISE DO\n          sortfld = \"GENIEDES\"\n          dsplfld = \"Title\"\n          GENIESRT = \"A\"\n        END\n      END\n      function_rc = Sort_The_Table()\n    END\n    WHEN (ABBREV(\"SELECT\",zcmdverb,1) = 1) THEN DO\n      fetch_item = zcmditm\n      fetchsel = \"S\"\n      call_rc = Fetch_The_Member()\n      keep_going = 1\n    END\n    WHEN (ABBREV(\"WISH\",zcmdverb,1) = 1) THEN DO\n      purgekey = \"C\"\n      call_rc = Purge_Genietbl()\n      IF (GENIEFND = \"\") THEN DO\n        ZERRALRM = \"YES\"\n        ZERRSM = \"Problem!\"\n        ZERRLM = \"You asked to find nothing.\"\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n        keep_going = 2\n        RETURN 4\n      END\n      geniekey = GENIEFND\n      key_len = LENGTH(geniekey)\n      call_rc = Build_My_Table()\n      key_len = 0\n    END\n    WHEN (ABBREV(\"REFRESH\",zcmdverb,1) = 1) THEN DO\n      genielvl = \"T\"\n      purgekey = \"*\"\n      call_rc = Purge_Genietbl()\n      GENIEFND = \"\"\n      key_len = 0\n      geniekey = \"\"\n      genieexp = \"\"\n      exp_len = 0\n      buildkey = \"T\"\n      call_rc = Read_Zos_Index()\n      IF (call_rc <> 0) THEN DO\n        RETURN call_rc\n      END\n    END\n    WHEN (ABBREV(\"CANCEL\",zcmdverb,1) = 1) THEN DO\n      ZERRALRM = \"No\"\n      ZERRSM = \"Cancel accepted.\"\n      ZERRLM = \"You asked to cancel the request.\"\n      ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      keep_going = 2\n      RETURN 4\n    END\n    OTHERWISE DO\n      ZERRALRM = \"YES\"\n      ZERRSM = \"Press help\"\n      ZERRLM = \"You asked GENIE to do something. However,\" ,\n        zcmdverb \"makes absolutely no sense.\"\n      ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    END\n  END\n  zcmdverb = \"\"\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Process the )MODEL section of the panel - ROW selection.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_Zdtsel:\n  IF (ZTDSELS > 0) THEN DO\n    frowsarg = genieitm\n  END\n  DO WHILE (ZTDSELS > 0)\n    GENIESEL = To_Uppercase(GENIESEL)\n    function_rc = Line_Selection()\n    GENIESEL = \"\"\n    ADDRESS ISPEXEC \"TBPUT GENIETBL\"\n    IF (ZTDSELS > 1) THEN DO\n      ADDRESS ISPEXEC \"TBDISPL GENIETBL\"\n    END\n    ELSE DO\n      ZTDSELS = 0\n    END\n  END\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Process the ROW selection.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nLine_Selection:\n  SELECT\n    WHEN (GENIESEL = \"S\") THEN DO\n      fetch_item = genieitm\n      fetchsel = \"S\"\n      call_rc = Fetch_The_Member()\n      keep_going = 1\n    END\n    WHEN ((GENIESEL = \"/\") | (GENIESEL = \"?\")) THEN DO\n      GENIELSL = \"\"\n      ADDRESS ISPEXEC \"ADDPOP\"\n      ADDRESS ISPEXEC \"DISPLAY PANEL(GENIELSL)\"\n      ADDRESS ISPEXEC \"REMPOP\"\n      SELECT\n        WHEN (GENIELSL = \"/\") THEN DO\n          ZERRALRM = \"YES\"\n          ZERRSM = \"No way!\"\n          ZERRLM = \"Asking for recursive help is inexscuable.\"\n          ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n        END\n        OTHERWISE DO\n          GENIESEL = To_Uppercase(GENIELSL)\n          function_rc = Line_Selection()\n        END\n      END\n    END\n    WHEN (GENIESEL = \"I\") THEN DO\n      fetch_item = genieitm\n      fetchsel = \"I\"\n      call_rc = Itemize_Detail()\n    END\n    WHEN (GENIESEL = \"P\") THEN DO\n      fetch_item = genieitm\n      call_rc = Preview_Detail()\n    END\n    WHEN (GENIESEL = \"+\") | (GENIESEL = \"E\") THEN DO\n      IF (LENGTH(genieitm) = 8) THEN DO\n        ZERRALRM = \"YES\"\n        ZERRSM = \"PRESS HELP\"\n        ZERRLM = \"You cannot expand a WISH. Request denied!\"\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      END\n      ELSE DO\n        priorsel = GENIESEL\n        genieexp = STRIP(genieitm,\"B\",\" \")\n        exp_len = LENGTH(genieexp) + 2\n        call_rc = Build_My_Table()\n        exp_len = 0\n      END\n    END\n    WHEN (GENIESEL = \"*\") THEN DO\n      IF (LENGTH(genieitm) = 8) THEN DO\n        ZERRALRM = \"YES\"\n        ZERRSM = \"PRESS HELP\"\n        ZERRLM = \"You cannot expand a WISH. Request denied!\"\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      END\n      ELSE DO\n        geniekey = \"*\"\n        genieexp = STRIP(genieitm,\"B\",\" \")\n        exp_len = LENGTH(genieexp)\n        call_rc = Build_My_Table()\n        exp_len = 0\n      END\n    END\n    WHEN (GENIESEL = \"-\") | (GENIESEL = \"U\") THEN DO\n      IF (LENGTH(genieitm) = 8) THEN DO\n        ZERRALRM = \"YES\"\n        ZERRSM = \"PRESS HELP\"\n        ZERRLM = \"You cannot unexpand (shrink) a WISH.\" ,\n          \"Request denied!\"\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      END\n      ELSE DO\n        genieexp = genieitm\n        exp_len = LENGTH(genieexp)\n        call_rc = Unexpand_Table()\n      END\n    END\n    OTHERWISE DO\n      NOP\n    END\n  END\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Process the full member list.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nSearch_Pds_Member:\n  wish_mbr = STRIP(genieitm,\"T\",\" \")\n  reason1 = \"Searching\" wish_mbr\n  ADDRESS ISPEXEC \"CONTROL DISPLAY LOCK\"\n  ADDRESS ISPEXEC \"DISPLAY PANEL(GENIEBAR)\"\n  msg_rc = MSG(\"OFF\")\n  \"ALLOC FILE(GENIEMBR) DATASET('\"wish@dsn\"(\"wish_mbr\")') SHR REUSE\"\n  alloc_rc = RC\n  msg_rc = MSG(\"ON\")\n  IF (alloc_rc <> 0) THEN DO\n    RETURN 0\n  END\n  \"EXECIO * DISKR GENIEMBR (STEM mbr_record. FINIS)\"\n  diskr_rc = RC\n  \"FREE FILE(GENIEMBR)\"\n  IF (diskr_rc <> 0) THEN DO\n    RETURN 0\n  END\n  wishblob = \"\"\n  DO mbrx = 1 TO mbr_record.0\n    wishtext = STRIP(SUBSTR(mbr_record.mbrx,2),\"B\",\" \")\n    wishblob = wishblob wishtext\n  END\n  IF (POS(To_Uppercase(GENIEFND),To_Uppercase(wishblob)) > 0) THEN DO\n    ADDRESS ISPEXEC ,\n      \"TBADD GENIETBL ORDER\"\n    blobfound = 1\n    IF (first_wish = \"\") THEN DO\n      first_wish = wish_mbr\n    END\n  END\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Break up a string into a smaller length.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nChop_String_To_Length:\n  ts_len = LENGTH(this_string)\n  IF (ts_len <= strglen) THEN DO\n    return_string = this_string\n    this_string = \"\"\n    RETURN return_string\n  END\n  too_long = \"\"\n  good_long = \"\"\n  num_words = WORDS(this_string)\n  a_space = \"\"\n  DO word_ctr = 1 TO num_words\n    next_word = WORD(this_string,1)\n    IF (LENGTH(next_word) > strglen) THEN DO\n      IF (good_long <> \"\") THEN DO\n        RETURN good_long\n      END\n      ELSE DO\n        return_string = LEFT(this_string,strglen)\n        this_string = SUBSTR(this_string,(strglen + 1))\n        RETURN return_string\n      END\n    END\n    too_long = too_long\"\"a_space\"\"next_word\n    line_len = LENGTH(too_long)\n    IF (line_len > strglen) THEN DO\n      RETURN good_long\n    END\n    good_long = good_long\"\"a_space\"\"next_word\n    a_space = \" \"\n    this_string = STRIP(DELSTR(this_string,1,LENGTH(next_word)),\"L\",\" \")\n  END\n  RETURN good_long\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Pad a string to a desired length.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nFill_String:\n  PARSE ARG padlen , padstring\n  IF (LENGTH(padstring) > padlen) THEN DO\n    SAY \"ABORT\"\n    RETURN LEFT(padstring,padlen)\n  END\n  IF (LENGTH(padstring) = padlen) THEN DO\n    RETURN padstring\n  END\n  filllen = padlen - LENGTH(padstring)\n  RETURN LEFT(padstring COPIES(\" \",filllen),padlen)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Add a line to the current member.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nAdd_Line:\n  IF ((type_line = \"MSGLINE\") | (type_line = \"NOTELINE\")) THEN DO\n    IF (LENGTH(newtext) > 72) THEN DO\n      oldtext = newtext\n      newleft = LASTPOS(LEFT(oldtext,72),\" \")\n      IF (newleft = 0) THEN DO\n        newleft = 72\n      end\n      newtext = LEFT(oldtext,newleft)\n      call_rc = Add_Line()\n      newtext = SUBSTR(oldtext,(newleft + 1))\n    END\n  END\n  IF (newtext = \"\") THEN DO\n    newtext = \" \"\n  END\n  oldtext = newtext\n  IF (newtext = \"INFOLINE\") THEN DO\n    newtext = \"INFOLINE \"\n  END\n  IF (type_line = \"ERROR\") THEN DO\n    SAY \"Add_Line: ERROR\" newtext\n    RETURN 0\n  END\n  ADDRESS ISREDIT ,\n    \"LINE_BEFORE\" aftrline \"=\" type_line \"(newtext)\"\n  insert_rc = RC\n  IF (insert_rc <> 0) THEN DO\n    ZERRSM = \"Insert error, RC(\"insert_rc\")\"\n    ZERRLM = LEFT(\"Really, insert has a problem fetchsel=\"fetchsel,76)\n    ZERRLM = ZERRLM || ,\n      LEFT(type_line \"after\" aftrline \"record\" cfgx \"sigl\" sigl,76)\n    ZERRLM = ZERRLM || ,\n      LEFT(\">\"newtext\"<\",76)\n    ZERRLM = ZERRLM || ,\n      LEFT(\">\"oldtext\"<\",76)\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    say \"ZERR:\" zerrsm\n    say zerrlm\n    return_code = 1\n  END\n  IF (type_line = \"DATALINE\") THEN DO\n    aftrline = aftrline + 1\n  END\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Process the selected member.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nFetch_The_Member:\n  filename_in = \"'\"STRIP(wish@dsn,\"B\",\"'\")\"(\"fetch_item\")'\"\n  insmbr_rc = SYSDSN(filename_in)\n  IF (POS(\"I\",debuglvl) > 0) THEN DO\n    SAY \"Fetch_The_Member:    SysDsn:\" insmbr_rc\n  END\n  IF (insmbr_rc <> \"OK\") THEN DO\n    ZERRSM = \"Not found\"\n    ZERRLM = \"The\" fetch_item \"wish member was not found.\"\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    return_code = 4\n    RETURN return_code\n  END\n  \"ALLOC FILE(GENIEMBR) SHR REUSE\",\n    \"DATASET('\"wish@dsn\"(\"fetch_item\")')\"\n  alloc_rc = RC\n  IF (alloc_rc <> 0) THEN DO\n    SAY \"Allocation of the wish file failed, RC=\"alloc_rc\n    RETURN 16\n  END\n  \"EXECIO * DISKR GENIEMBR (STEM mbr_record. FINIS)\"\n  diskr_rc = RC\n  \"FREE FILE(GENIEMBR)\"\n  IF (diskr_rc <> 0) THEN DO\n    ZERRSM = \"DISKR!\"\n    ZERRLM = \"WISH DISKR error:\" diskr_rc\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    return_code = 16\n    RETURN return_code\n  END\n  IF (fetchsel <> \"I\") THEN DO\n    newtext = starter_line\n    ADDRESS ISREDIT ,\n      \"LINE_AFTER\" aftrline \"= DATALINE (newtext)\"\n    starter_rc = RC\n    aftrline = aftrline + 1\n    ADDRESS ISREDIT ,\n      \"LABEL\" aftrline \"= .DELME 0\"\n    newtext = \"Your\" fetch_item \"wish begins below:\"\n    type_line = \"INFOLINE\"\n    cfgx = \"wish-begins\"\n    call_rc = Add_Line()\n  END\n  genieboo = \"\"\n  geniecpy = \"\"\n  geniedte = \"\"\n  geniekwd = \"\"\n  genientr = \"\"\n  geniesrc = \"\"\n  genietle = \"\"\n  genieurl = \"\"\n  genieweb = \"\"\n  DO mbrx = 1 TO mbr_record.0\n    mbr_record.mbrx = STRIP(mbr_record.mbrx,\"T\",\" \")\n    PARSE VAR mbr_record.mbrx id@type +1 file_txt\n    id@type = To_Uppercase(id@type)\n    newtext = STRIP(file_txt,\"T\",\" \")\n    SELECT\n      WHEN (id@type = \"@\") THEN DO\n        IF (geniecpy = \"\") THEN DO\n          geniecpy = newtext\n        END\n        ELSE DO\n          geniecpy = geniecpy newtext\n        END\n        ITERATE\n      END\n      WHEN (id@type = \"*\") THEN DO\n        ITERATE\n      END\n      WHEN (id@type = \"B\") THEN DO\n        IF (geniecpy = \"\") THEN DO\n          genieboo = newtext\n        END\n        ELSE DO\n          genieboo = genieboo newtext\n        END\n        ITERATE\n      END\n      WHEN (id@type = \"D\") THEN DO\n        type_line = \"DATALINE\"\n      END\n      WHEN (id@type = \"E\") THEN DO\n        IF (genientr = \"\") THEN DO\n          genientr = newtext\n        END\n        ELSE DO\n          genientr = genientr\" \"newtext\n        END\n        ITERATE\n      END\n      WHEN (id@type = \"G\") THEN DO\n        ITERATE\n      END\n      WHEN (id@type = \"I\") THEN DO\n        type_line = \"INFOLINE\"\n      END\n      WHEN (id@type = \"K\") THEN DO\n        IF (geniekwd = \"\") THEN DO\n          geniekwd = newtext\n        END\n        ELSE DO\n          geniekwd = geniekwd\" \"newtext\n        END\n        ITERATE\n      END\n      WHEN (id@type = \"M\") THEN DO\n        type_line = \"MSGLINE\"\n      END\n      WHEN (id@type = \"N\") THEN DO\n        type_line = \"NOTELINE\"\n      END\n      WHEN (id@type = \"R\") THEN DO\n        SELECT\n          WHEN (To_Lowercase(newtext) = \"system_symbols\") THEN DO\n            routine_rc = Ecvtsymt_Symbols()\n          END\n          OTHERWISE DO\n            newtext = STRIP(newtext,\"T\",\" \")\n            ADDRESS ISPEXEC \"VPUT (aftrline) SHARED\"\n            ADDRESS ISPEXEC \"SELECT cmd(\"newtext\")\"\n            macro_rc = RC\n            ADDRESS ISPEXEC \"VGET (aftrline) SHARED\"\n          END\n        END\n        ITERATE\n      END\n      WHEN (id@type = \"S\") THEN DO\n        IF (geniesrc = \"\") THEN DO\n          geniesrc = newtext\n        END\n        ELSE DO\n          geniesrc = geniesrc\" \"newtext\n        END\n        ITERATE\n      END\n      WHEN (id@type = \"T\") THEN DO\n        IF (genietle = \"\") THEN DO\n          genietle = newtext\n        END\n        ELSE DO\n          genietle = genietle\" \"newtext\n        END\n        ITERATE\n      END\n      WHEN (id@type = \"U\") THEN DO\n        IF (genieurl = \"\") THEN DO\n          genieurl = newtext\n        END\n        ELSE DO\n          genieurl = genieurl\"\"newtext\n        END\n        ITERATE\n      END\n      WHEN (id@type = \"W\") THEN DO\n        IF (genieweb = \"\") THEN DO\n          genieweb = newtext\n        END\n        ELSE DO\n          genieweb = genieweb\" \"newtext\n        END\n        ITERATE\n      END\n      WHEN (id@type = \"X\") THEN DO\n        PARSE VAR newtext cvarfrom \" = \" cvarto\n        SELECT\n          WHEN (To_Lowercase(cvarto) = \"editdsn\") THEN DO\n            ADDRESS ISREDIT \"(cvarto) = DATASET\"\n          END\n          WHEN (To_Lowercase(cvarto) = \"editmbr\") THEN DO\n            ADDRESS ISREDIT \"(cvarto) = MEMBER\"\n          END\n          WHEN (To_Lowercase(cvarto) = \"logon_acct\") THEN DO\n            ADDRESS ISPEXEC \"VGET (ZACCTNUM)\"\n            cvarto = ZACCTNUM\n          END\n          WHEN (To_Lowercase(cvarto) = \"mvsvar_sysname\") THEN DO\n            cvarto = MVSVAR(\"SYSNAME\")\n          END\n          WHEN (To_Lowercase(cvarto) = \"saf_dfltgrp\") THEN DO\n            IF (listuser_done = \"No\") THEN DO\n              listuser_done = Rcvt_Listuser()\n            END\n            cvarto = SPACE(saf_dfltgrp)\n          END\n          WHEN (To_Lowercase(cvarto) = \"saf_name\") THEN DO\n            IF (listuser_done = \"No\") THEN DO\n              listuser_done = Rcvt_Listuser()\n            END\n            cvarto = saf_username\n          END\n          WHEN (To_Lowercase(cvarto) = \"sysvar_sysuid\") THEN DO\n            cvarto = sys_sysuid\n          END\n          WHEN (To_Lowercase(cvarto) = \"zdate\") THEN DO\n            cvarto = DATE(\"S\")\n          END\n          WHEN (To_Lowercase(cvarto) = \"ztime\") THEN DO\n            cvarto = TIME()\n          END\n          OTHERWISE DO\n            newtext = \"You must change:\" newtext\n            type_line = \"MSGLINE\"\n            IF (fetchsel <> \"I\") THEN DO\n              cfgx = \"id=r\" mbrx\n              call_rc = Add_Line()\n            END\n            ITERATE\n          END\n        END\n        ADDRESS ISREDIT \"C '&cvarfrom' '&cvarto' ALL\"\n        change_rc = RC\n        IF (change_rc > 0) THEN DO\n          ZERRLM = ZERRLM ,\n            LEFT(\"var:\" cvarfrom \"is defined, but not used or\" ,\n              \"errored out.\",76)\n        END\n        ITERATE\n      END\n      WHEN (id@type = \"Z\") THEN DO\n        IF (geniedte = \"\") THEN DO\n          geniedte = newtext\n        END\n        ELSE DO\n          geniedte = geniedte newtext\n        END\n        ITERATE\n      END\n      WHEN (id@type = \"?\") THEN DO\n        PARSE VAR newtext cvarfrom \" = \" GENIELEN \" = \" genieask\n        IF (plib_rc <> 0) THEN DO\n          plib_rc = Plib_Allocated()\n        END\n        GENIELIM = LEFT(\"Char(\"GENIELEN\")\",11)\": \"COPIES(\"+\",GENIELEN)\n        GENIEANS = \"\"\n        ADDRESS ISPEXEC \"DISPLAY PANEL(GENIEASK)\"\n        IF (GENIEANS <> \"\") THEN DO\n          cvarto = LEFT(GENIEANS,GENIELEN)\n          ADDRESS ISREDIT \"C '&cvarfrom' '&cvarto' ALL\"\n        END\n        ITERATE\n      END\n      OTHERWISE DO\n        SAY \"Line id?\" id@type\"!\"\n        ITERATE\n      END\n    END\n    IF (fetchsel <> \"I\") THEN DO\n      cfgx = \"member\" mbrx\n      call_rc = Add_Line()\n    END\n  END\n  newtext = \"Your\" fetch_item \"wish was granted above.\"\n  type_line = \"INFOLINE\"\n  IF (fetchsel <> \"I\") THEN DO\n    cfgx = \"wish-granted\"\n    call_rc = Add_Line()\n  END\n  ADDRESS ISREDIT \"DELETE .DELME\"\n  cfgx = \".delme is gone\"\n  fetchsel = \"\"\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Prompt for the user name WHEN unable to get it from the SAF product.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nAsk_For_Username:\n  genieask = \"What is your name?\"\n  GENIELIM = LEFT(\"Char(\"GENIELEN\")\",20)\": \"COPIES(\"+\",GENIELEN)\n  ADDRESS ISPEXEC \"DISPLAY PANEL(GENIEASK)\"\n  IF (GENIEANS <> \"\") THEN DO\n    saf_username = LEFT(GENIEANS,GENIELEN)\n  END\n  genieask = \"What is your group?\"\n  GENIELIM = LEFT(\"Char(\"GENIELEN\")\",8)\": \"COPIES(\"+\",GENIELEN)\n  ADDRESS ISPEXEC \"DISPLAY PANEL(GENIEASK)\"\n  IF (GENIEANS <> \"\") THEN DO\n    saf_dfltgrp = LEFT(GENIEANS,GENIELEN)\n  END\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Follow CVT to get SAF Product and then list user to get name.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nRcvt_Listuser:\n  good_or_bad = \"Bad\"\n  PTR2PSA = 0                                      /* Pointer to PSA */\n  CVTPTR = STORAGE(D2X(PTR2PSA + 16),4)            /* Pointer to CVT */\n  CVT = C2D(BITAND(CVTPTR,\"7FFFFFFF\"X))       /* Flip high order bit */\n  JESCT = C2D(STORAGE(D2X(CVT + 296),4))          /* point to JESCT  */\n  CVTRAC = C2D(STORAGE(D2X(CVT + 992),4))       /* point to RACF CVT */\n  RCVTID = STORAGE(D2X(CVTRAC),4)                 /* point to RCVTID */\n                                              /* ACF2, RCVT, or RTSS */\n  saf_userid = \"Unknown\"\n  saf_dfltgrp = \"Unknown\"\n  saf_username = \"Unknown\"\n  SELECT\n    WHEN (RCVTID = \"ACF2\") THEN DO\n      SECNAM = \"CA-ACF2\"  /* ACF2 is CA-ACF2     */\n      saf_accessor_id = \"Unknown\"\n      saf_accessor_name = \"Uknown\"\n      saf_dfltgrp = \"Unknown\"\n/* untested */\n      MAKEBUF\n      QUEUE \"LIST\" sys_sysuid \"SECTION(ALL) PROFILE(ALL)\"\n      QUEUE \"End\"\n      xx = OUTTRAP(\"acf2_back.\")\n      ADDRESS TSO \"ACF\"\n      xx = OUTTRAP(\"OFF\")\n      DROPBUF\n      IF (acf2_back.0 < 2) THEN DO\n        ask_rc = Ask_For_Username()\n      END\n      ELSE DO\n        DO saf_ix = 2 TO acf2_back.0\n          SELECT\n            WHEN (POS(sys_sysuid,acf2_back.saf_ix) = 3) THEN DO\n              PARSE VAR acf2_back.saf_ix ,\n              saf_id saf_logon_uid saf_accessor_name\n              saf_accessor_name = STRIP(saf_accessor_name,\"T\",\" \")\n            END\n            WHEN (POS(\"TSOACCT(\",acf2_back.saf_ix) > 0) THEN DO\n              saf_start = POS(\"TSOACCT(\",acf2_back.saf_ix) + 8\n              saf_end = ,\n                INDEX(acf2_back.saf_ix,\")\",saf_start)\n              saf_lenx = saf_end - saf_start\n              saf_dfltgrp = ,\n                SUBSTR(acf2_back.saf_ix,saf_start,saf_lenx)\n            END\n            OTHERWISE DO\n              NOP\n            END\n          END\n        END\n      END\n/* untested */\n      good_or_bad = \"Good\"\n    END\n    WHEN (RCVTID = \"RCVT\") THEN DO\n      SECNAM = \"RACF\"     /* RCVT is RACF        */\n      psatold = STORAGE(D2X(548),4)\n      ascbasxb = STORAGE(D2X(C2D(psatold)+108),4)\n      asxbsenv = STORAGE(D2X(C2D(ascbasxb)+200),4)\n      aceeptr = asxbsenv\n      saf_dfltgrp = STORAGE(D2X(C2D(aceeptr)+30),8)\n      aceeunaa = STORAGE(D2X(C2D(aceeptr)+100),4)\n      IF (C2D(aceeunaa) > 0) THEN DO\n        aceeunal = STORAGE(D2X(C2D(aceeunaa)),1)\n        aceeunam = STORAGE(D2X(C2D(aceeunaa) + 1),C2D(aceeunal) - 1)\n        saf_username = STRIP(aceeunam,\"B\",\" \")\n      END\n      IF (saf_username = \"Unknown\") THEN DO\n        xx = OUTTRAP(\"racf_back.\")\n        ADDRESS TSO \"LISTUSER\" sys_sysuid\n        xx = OUTTRAP(\"Off\")\n        IF (racf_back.0 < 2) THEN DO\n          ask_rc = Ask_For_Username()\n        END\n        ELSE DO\n          dix = 1\n          bpos = POS(\"USER=\",racf_back.dix) + 5\n          IF (bpos > 5) THEN DO\n            saf_userid = SUBSTR(racf_back.dix,bpos,8)\n          END\n          ELSE DO\n            saf_userid = \"NotFound\"\n          END\n          bpos = POS(\"NAME=\",racf_back.dix) + 5\n          IF (bpos > 5) THEN DO\n            saf_username = SUBSTR(racf_back.dix,bpos,20)\n          END\n          ELSE DO\n            ask_rc = Ask_For_Username()\n          END\n          bpos = POS(\"OWNER=\",racf_back.dix) + 6\n          IF (bpos > 6) THEN DO\n            saf_owner = SUBSTR(racf_back.dix,bpos,8)\n          END\n          ELSE DO\n            saf_owner = \"NotFound\"\n          END\n          bpos = POS(\"CREATED=\",racf_back.dix) + 8\n          IF (bpos > 8) THEN DO\n            saf_created = SUBSTR(racf_back.dix,bpos,6)\n          END\n          ELSE DO\n            saf_created = \"NotFound\"\n          END\n\n          dix = 2\n          bpos = POS(\"DEFAULT-GROUP=\",racf_back.dix) + 14\n          IF (bpos > 14) THEN DO\n            saf_dfltgrp = SUBSTR(racf_back.dix,bpos,8)\n          END\n          ELSE DO\n            saf_dfltgrp = \"NotFound\"\n          END\n          good_or_bad = \"Good\"\n        END\n      END\n    END\n    WHEN (RCVTID = \"RTSS\") THEN DO\n      SECNAM = \"TopSecret\" /* RTSS is Top Secret */\n/* untested */\n      xx = OUTTRAP(\"tss_back.\")\n      ADDRESS TSO \"TSS LIST(\"sys_sysuid\")\"\n      xx = OUTTRAP(\"Off\")\n      IF (tss_back.0 < 4) THEN DO\n        ask_rc = Ask_For_Username()\n      END\n      ELSE DO\n        PARSE VAR tss_back.2 . \" = \" saf_userid \" \" ,\n          . \" = \" saf_username\n        saf_username = STRIP(saf_username,\"T\",\" \")\n        DO tssx = 2 TO tss_back.0\n          SELECT\n            WHEN (POS(\"DFLTGRP    =\",tss_back.tssx) > 0) THEN DO\n              PARSE VAR tss_back.tssx . \" = \" saf_dfltgrp \" \" .\n              tssx = tss_back.0\n            END\n            OTHERWISE DO\n              NOP\n            END\n          END\n        END\n      END\n/* untested */\n      good_or_bad = \"Good\"\n    END\n    OTHERWISE DO\n      SECNAM = RCVTID\n      ask_rc = Ask_For_Username()\n    END\n  END\n  RETURN good_or_bad\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n System Symbols information sub-routine.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n/**********************************************************************\n Find System Symbols  - ASASYMBP MACRO\n   ECVT+X'128' = ECVTSYMT\n   2nd half word = # of symbols , after that each entry is 4 words\n   1st word = offset to symbol name\n   2nd word = length of symbol name\n   3rd word = offset to symbol value\n   4th word = length of symbol value\n**********************************************************************/\nEcvtsymt_Symbols:\n  PTR2PSA = 0                                      /* Pointer to PSA */\n  CVTPTR = STORAGE(D2X(PTR2PSA + 16),4)            /* Pointer to CVT */\n  CVT = C2D(BITAND(CVTPTR,\"7FFFFFFF\"X) )      /* Flip high order bit */\n  ECVT = C2D(STORAGE(D2X(CVT + 140),4))          /* point to CVTECVT */\n  ECVTSYMT = C2D(STORAGE(D2X(ECVT + 296),4))    /* point to ECVTSYMT */\n  NUMSYMBS = C2D(STORAGE(D2X(ECVTSYMT + 2),2))  /* number of symbols */\n  type_line = \"DATALINE\"\n  DO numx = 1 TO NUMSYMBS\n    SOFF = (numx * 16) - 16\n    NAMOFF = C2D(STORAGE(D2X(ECVTSYMT+4+SOFF),4))     /* name offset */\n    NAMLEN = C2D(STORAGE(D2X(ECVTSYMT+8+SOFF),4))     /* name length */\n    VALOFF = C2D(STORAGE(D2X(ECVTSYMT+12+SOFF),4))   /* value offset */\n    VALLEN = C2D(STORAGE(D2X(ECVTSYMT+16+SOFF),4))   /* value length */\n    SYMNAME = STORAGE(D2X(ECVTSYMT+4+NAMOFF),NAMLEN)  /* symbol name */\n    IF (VALLEN > 0) THEN DO\n      symval = STORAGE(D2X(ECVTSYMT+4+VALOFF),VALLEN)       /* value */\n      symname = STRIP(symname,\"B\",\" \")\n      symname = STRIP(symname,\"B\",\".\")\n      symname = STRIP(symname,\"B\",\"&\")\n      newtext = \"//\"LEFT(SYMNAME,8,\" \") \"SET\" symname\"='\"symval\"'\"\n      cfgx = \"ECVTSYMT\" numx\n      call_rc = Add_Line()\n    END /* IF VALLEN > 0 */\n  END  /* do NUMSYMBS */\n  RETURN s_symbol.0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Read a member to get information details.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nItemize_Detail:\n  call_rc = Fetch_The_Member()\n  IF (call_rc > 0) THEN DO\n    RETURN call_rc\n  END\n  strglen = 80\n  GENIESTF = \"\"\n  this_string = \"Source member selected is:\" fetch_item\n    partial_string = Chop_String_To_LENGTH()\n    partial_string = Fill_String(strglen, partial_string)\n    GENIESTF = GENIESTF\"\"partial_string\n  IF (geniesrc <> \"\") THEN DO\n    this_string = \"Source ID:\" geniesrc\n    DO WHILE (this_string <> \"\")\n      partial_string = Chop_String_To_LENGTH()\n      partial_string = Fill_String(strglen, partial_string)\n      GENIESTF = GENIESTF\"\"partial_string\n    END\n  END\n  IF (geniekwd <> \"\") THEN DO\n    this_string = \"Also Known As (AKA) keywords:\" geniekwd\n    DO WHILE (this_string <> \"\")\n      partial_string = Chop_String_To_LENGTH()\n      partial_string = Fill_String(strglen, partial_string)\n      GENIESTF = GENIESTF\"\"partial_string\n    END\n  END\n  IF (genientr <> \"\") THEN DO\n    this_string = \"Entered by:\" genientr\n    DO WHILE (this_string <> \"\")\n      partial_string = Chop_String_To_LENGTH()\n      partial_string = Fill_String(strglen, partial_string)\n      GENIESTF = GENIESTF\"\"partial_string\n    END\n  END\n  IF (geniedte <> \"\") THEN DO\n    this_string = \"Dated:\" geniedte\n    DO WHILE (this_string <> \"\")\n      partial_string = Chop_String_To_LENGTH()\n      partial_string = Fill_String(strglen, partial_string)\n      GENIESTF = GENIESTF\"\"partial_string\n    END\n  END\n  IF (genieboo <> \"\") THEN DO\n    this_string = \"Book/Manual:\" genieboo\n    DO WHILE (this_string <> \"\")\n      partial_string = Chop_String_To_LENGTH()\n      partial_string = Fill_String(strglen, partial_string)\n      GENIESTF = GENIESTF\"\"partial_string\n    END\n  END\n  IF (genieweb <> \"\") THEN DO\n    this_string = genieweb\n    DO WHILE (this_string <> \"\")\n      partial_string = Chop_String_To_LENGTH()\n      partial_string = Fill_String(strglen, partial_string)\n      GENIESTF = GENIESTF\"\"partial_string\n    END\n  END\n  IF (genieurl <> \"\") THEN DO\n    this_string = genieurl\n    DO WHILE (this_string <> \"\")\n      partial_string = Chop_String_To_LENGTH()\n      partial_string = Fill_String(strglen, partial_string)\n      GENIESTF = GENIESTF\"\"partial_string\n    END\n  END\n  IF (geniecpy <> \"\") THEN DO\n    this_string = \"Copyright @\" geniecpy\n    DO WHILE (this_string <> \"\")\n      partial_string = Chop_String_To_LENGTH()\n      partial_string = Fill_String(strglen, partial_string)\n      GENIESTF = GENIESTF\"\"partial_string\n    END\n  END\n  partial_string = COPIES(\" \",strglen)\n  GENIESTF = GENIESTF\"\"partial_string\n  partial_string = Fill_String(strglen, \"Description\")\n  GENIESTF = GENIESTF\"\"partial_string\n  IF (genietle <> \"\") THEN DO\n    this_string = genietle\n    DO WHILE (this_string <> \"\")\n      partial_string = Chop_String_To_LENGTH()\n      partial_string = Fill_String(strglen, partial_string)\n      GENIESTF = GENIESTF\"\"partial_string\n    END\n  END\n  GENIESTF = GENIESTF\"\"COPIES(\" \",strglen)\n  center_text = \"End of member's information.\"\n  halves = (strglen - LENGTH(center_text)) / 2\n  PARSE VAR halves half\".\" . halfknots\n  partial_string = ,\n    LEFT(COPIES(\"-\",half)\"\"center_text\"\"COPIES(\"-\",half),strglen)\n  GENIESTF = GENIESTF\"\"partial_string\n\n  GENIESTF = GENIESTF\"\"COPIES(\" \",strglen)\n\n  geniepfk = Pfkey_Retrieve(\"End\")\n  center_text = ,\n    \"Press the END PFKey <\"geniepfk\"> to exit.\"\n  halves = (strglen - LENGTH(center_text)) / 2\n  PARSE VAR halves half\".\" . halfknots\n  partial_string = ,\n    LEFT(COPIES(\"-\",half)\"\"center_text\"\"COPIES(\"-\",half),strglen)\n  GENIESTF = GENIESTF\"\"partial_string\n  info_rc = 0\n  DO WHILE (info_rc = 0)\n    ADDRESS ISPEXEC \"DISPLAY PANEL(GENIEINF)\"\n    info_rc = RC\n  END\n  DROP mbr_record.\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Read a member to get information details.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nPreview_Detail:\n  filename_in = \"'\"STRIP(wish@dsn,\"B\",\"'\")\"(\"fetch_item\")'\"\n  ADDRESS ISPEXEC \"View\" ,\n    \"DATASET(\"filename_in\")\"\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Retrieve the 24 PFKeys and see which might match the argument.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nPfkey_Retrieve:\n  PARSE UPPER ARG pfk\n  ADDRESS ISPEXEC \"VGET (ZPF01, ZPF02, ZPF03, ZPF04, ZPF05, ZPF06)\"\n  ADDRESS ISPEXEC \"VGET (ZPF07, ZPF08, ZPF09, ZPF10, ZPF11, ZPF12)\"\n  ADDRESS ISPEXEC \"VGET (ZPF13, ZPF14, ZPF15, ZPF16, ZPF17, ZPF18)\"\n  ADDRESS ISPEXEC \"VGET (ZPF19, ZPF20, ZPF21, ZPF22, ZPF23, ZPF24)\"\n  pf_key = WORDPOS(pfk,  To_Uppercase( ,\n                         ZPF01 ZPF02 ZPF03 ZPF04 ZPF05 ZPF06 ,\n                         ZPF07 ZPF08 ZPF09 ZPF10 ZPF11 ZPF12 ,\n                         ZPF13 ZPF14 ZPF15 ZPF16 ZPF17 ZPF18 ,\n                         ZPF19 ZPF20 ZPF21 ZPF22 ZPF23 ZPF24) )\n  pf_key = \"PF\"RIGHT(\"00\"pf_key,2)\n  IF (pf_key = \"00\") THEN DO\n    pf_key = \"N/A\"\n  END\n  RETURN pf_key\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: PARSE ARG myarg\n  IF (lowercase_letters = \"LOWERCASE_LETTERS\") THEN DO\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  IF (uppercase_letters = \"UPPERCASE_LETTERS\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  END\n  RETURN TRANSLATE(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: PARSE ARG myarg\n  IF (lowercase_letters = \"LOWERCASE_LETTERS\") THEN DO\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  IF (uppercase_letters = \"UPPERCASE_LETTERS\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  END\n  RETURN TRANSLATE(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n FUNCTION TO TURN A CHARACTER STRING INTO BINARY BITS.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nC2b: PROCEDURE EXPOSE BITS\n  DATA = ARG(1)\n  IF (BITS.F <> \"1111\") THEN DO\n    BITS.0=\"0000\"; BITS.1=\"0001\"; BITS.2=\"0010\"; BITS.3=\"0011\"\n    BITS.4=\"0100\"; BITS.5=\"0101\"; BITS.6=\"0110\"; BITS.7=\"0111\"\n    BITS.8=\"1000\"; BITS.9=\"1001\"; BITS.A=\"1010\"; BITS.B=\"1011\"\n    BITS.C=\"1100\"; BITS.D=\"1101\"; BITS.E=\"1110\"; BITS.F=\"1111\"\n  END\n  dx = C2X(DATA)\n  BS=\"\"\n  DO I=1 TO LENGTH(dx)\n    Q=SUBSTR(dx,I,1)\n    BS=BS\"\"BITS.Q\n  END\n  BS = STRIP(BS,\"B\",\" \")\n  RETURN BS\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Access the ACEE and get user and group connections.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nRcvt_Acee:\n  psatold = STORAGE(D2X(548),4)              /* Pointer to curr ASCB */\n  ascbasxb = STORAGE(D2X(C2D(psatold)+108),4)    /* Get ASXB ADDRESS */\n  asxbsenv = STORAGE(D2X(C2D(ascbasxb)+200),4)   /* Get ACEE ADDRESS */\n  aceeptr = asxbsenv\n  aceeacee = STORAGE(D2X(C2D(aceeptr)+0),4)        /* get eyecatcher */\n  user_special = \"?\"\n  saf_connect = \"\"\n  IF (aceeacee <> \"ACEE\") THEN DO\n    SAY \"No ACEE\"\n    RETURN 0\n  END\n\n  aceeflg1 = STORAGE(D2X(C2D(aceeptr)+38),1)                 /* flag */\n  IF (BITAND(aceeflg1,\"80\"X) = \"80\"x) THEN DO\n    user_special = \"YES\"\n  END\n  ELSE DO\n    user_special = \"No\"\n  END\n\n  aceeflg3 = STORAGE(D2X(C2D(aceeptr)+40),1)                 /* flag */\n  aceeuser_flag3 = C2b(aceeflg3)\n  IF (SUBSTR(aceeuser_flag3,1,1) = 1) THEN DO\n    aceecgrp = STORAGE(D2X(C2D(aceeptr)+108),4)   /* addr group list */\n    aceeeyec = STORAGE(D2X(C2D(aceecgrp)+00),4)   /* addr group list */\n    IF (aceeeyec <> \"CGRP\") THEN DO\n      SAY \"Major error on CGRP\"\n      RETURN 0\n    END\n    aceecqty = STORAGE(D2X(C2D(aceecgrp)+8),2)            /* quantity */\n    cgrp_pos = 32\n    cgrp_eyecatcher = STORAGE(D2X(C2D(aceecgrp)+cgrp_pos),4)\n    DO gix = 1 TO C2D(aceecqty)\n      cgrp_item = STORAGE(D2X(C2D(aceecgrp)+cgrp_pos),8)\n      saf_connect = saf_connect\"\"cgrp_item\" \"\n      cgrp_pos = cgrp_pos + 24\n    END\n  END\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Allocate a temporary PDS and load dynamically generated panels.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nPlib_Allocated:\n  IF (plib_rc = 0) THEN DO\n    RETURN 0\n  END\n\n  panel_dd = \"BULK\"RIGHT(\"0000\"RANDOM(99999),4)\n  \"ALLOC NEW DEL F(\"panel_dd\") DSO(PO) DIR(1) SP(3,3) TRACK\",\n         \"REUSE RECFM(F B) BLKSIZE(0) LRECL(80) UNIT(SYSALLDA)\"\n  alloc_rc = RC\n  IF (alloc_rc <> 0) THEN DO\n    SAY \"Allocation of BULK dd failed, rc(\"alloc_rc\").\"\n    RETURN alloc_rc\n  END\n  ADDRESS ISPEXEC ,\n    \"LMINIT DATAID(TMPPNL) ENQ(EXCLU) DDNAME(\"panel_dd\")\"\n  lminit_rc = RC\n  IF (lminit_rc <> 0) THEN DO\n    SAY \"Trouble with LMINIT on TMPPNL, RC(\"lminit_rc\").\"\n    return_code = lminit_rc\n    RETURN return_code\n  END\n  SIGNAL ON SYNTAX NAME End_Of_Code\n  @search = \"/*PLIB\"\n  a_ix = Get_Sigl_Near_Plib()            /* Get near PLIB using SIGL */\n  DO UNTIL (srcline = \"/*PLIB\")/* Find PLIB */\n    srcline = SOURCELINE(a_ix)\n    a_ix = a_ix + 1\n  END\n  srcline = SOURCELINE(a_ix)\n  SIGNAL ON SYNTAX NAME End_Of_Code\n  @search = \"PLIB*/\"\n  DO UNTIL (srcline = \"PLIB*/\")\n    SELECT\n      WHEN (LEFT(srcline,6) = \"PANEL \") THEN DO\n        PARSE VAR srcline . panelname .\n        ADDRESS ISPEXEC ,\n          \"LMOPEN DATAID(&tmppnl) OPTION(OUTPUT)\"\n      END\n      WHEN (srcline = \"PANELEND\") THEN DO\n        ADDRESS ISPEXEC ,\n          \"LMMADD DATAID(&TMPPNL) MEMBER(\"panelname\")\"\n        ADDRESS ISPEXEC ,\n          \"LMClose DATAID(&tmppnl)\"\n        lmclose_rc = RC\n      END\n      OTHERWISE DO\n        ADDRESS ISPEXEC ,\n          \"LMPUT DATAID(&TMPPNL) MODE(INVAR)\" ,\n          \"DATALOC(SRCLINE) DATALEN(80)\"\n        lmput_rc = RC\n      END\n    END\n    a_ix = a_ix + 1\n    srcline = SOURCELINE(a_ix)\n  END\n  SIGNAL OFF SYNTAX\n  ADDRESS ISPEXEC ,\n    \"LIBDEF ISPPLIB LIBRARY ID(\"panel_dd\") STACK\"\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nPanel_def thru /*PLIB absolutley MUST remain in the same sequence. */\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nGet_Sigl_Near_Plib:\n  SIGNAL ON SYNTAX\n  RETURN aftrline()\naftrline:\n  RETURN sigl+4\n\n/*PLIB\nPANEL GENIEASK\n)ATTR DEFAULT(%+_)\n %   TYPE(TEXT) INTENS(HIGH) Caps(Off)\n +   TYPE(TEXT) INTENS(LOW) Caps(Off)\n _   TYPE(INPUT) INTENS(Low) CAPS(Off) JUST(LEFT) Hilite(UScore)\n)BODY Expand(||)\n%|-| GENIE has a question for you.|-|\n%Command ===>_ZCMD                                                             #\n+\n%&GENIEASK\n+Your answer:_GENIEANS\n%&GENIELIM\n+\n+Search string: &GENIEFND\n+\n)INIT\n)REINIT\n)PROC\nVER(&GENIEANS,LEN,LE,&GENIELEN)\n)END\nContact:  \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nPANELEND\nPANEL GENIEBAR\n)ATTR DEFAULT(%+_)\n  % TYPE(TEXT) INTENS(HIGH)\n  + TYPE(TEXT) INTENS(LOW)\n  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)\n)BODY Expand(||) WINDOW(80,12)\n%| | GENIE Search in progress | |\n+\n+&Reason1\n+\n+Search string: &GENIEFND\n+\n)INIT\n)PROC\n)END\nContact:  \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nPANELEND\nPANEL GENIEINF\n)ATTR DEFAULT(%+_)\n %   TYPE(TEXT) INTENS(HIGH) Caps(Off)\n +   TYPE(TEXT) INTENS(LOW) Caps(Off)\n _   TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) Hilite(UScore)\n $ Type(Output) Caps(Off) Intens(Low) Color(Green)\n ? TYPE(PIN)                         /* panel instruction line       */\n # TYPE(NT)                          /* normal text attribute        */\n ! TYPE(DT)                          /* description text             */\n @ AREA(Dynamic) Scroll(On) Extend(On) /* extendable scrollable area */\n)BODY Expand(||)\n%|-| GENIE WISHLIST Member Description |-|\n#\n%Information for &fetch_item follows:\n#\n|-|\n@GENIESTF                                                                      @\n)INIT\n.HELP = GENIEHLP\n)REINIT\n)PROC\n)HELP\n)END\nContact:  \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nPANELEND\nPANEL GENIELSL\n)ATTR DEFAULT(%~_)\n %   TYPE(TEXT) INTENS(HIGH) Caps(Off)\n ~   TYPE(TEXT) INTENS(LOW) Caps(Off)\n _   TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) Hilite(UScore)\n)BODY EXPAND(||)\n%|-| GENIE Line Commands |-|\n~\n%Line Command ==>_Z~\n%Line Function\n~---- |-|\n%  S ~Selects a member.\n%  P ~Preview a member.\n%/   ~Brings up this pop-up panel.\n%+ E ~Expands any TOPIC to CHAPTERs or CHAPTER to WISHes.\n%- U ~Unexpands the TOPIC or CHAPTER.\n%  I ~Shows additional information about the member.\n~---- |-|\n~\n)INIT\n.ZVARS = 'GENIELSL'\n)REINIT\n)PROC\n)HELP\n)END\nContact:  \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nPANELEND\nPANEL GENIEPRI\n)ATTR DEFAULT(%~_) FORMAT(MIX)\n /* % TYPE(TEXT) INTENS(HIGH)                                         */\n ~ TYPE(TEXT) INTENS(LOW)\n /* _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)                    */\n _ TYPE(Input)  Intens(High) Caps(Off) Just(LEFT) Hilite(uscore)\n # Type(Output) Intens(High) Caps(Off) Just(Left) Pas(On) Hilite(UScore)\n @ Type(Output) Intens(High) Caps(Off) Just(Left)\n $ Type(Output) Intens(Low)  Caps(Off) Just(Left) PAS(On) Hilite(Uscore)\n)BODY EXPAND(||) WIDTH(&ZSCREENW)\n%|-| GENIE Member Selector |-|\n%COMMAND ==>_Z | |%SCROLL ==>_ZSCR~\n%\n#sort~:&dsplfld #Order~:_z~ String:_GENIEFND | |#Keyword~#Search~\n@Z   %:~&GENIEHD2\n%S~=Select %+~=Expand %-~=Unexpand %I~=Information %*~=Full expand %P~=Preview\n~Sel  TOPIC CH  SQ  TITLE\n~---  ----  --  --  |-|\n)Model\n~_Z~ @Z   ~@Z ~@Z ~$GENIEDES\n)INIT\n.ZVARS = 'ZCMD, GENIESRT, GENIEHD1, +\n   GENIESEL, GENIETPC, GENIECHA, GENIESEQ'\n.CURSOR = 'ZCMD'\n&Sort = 'Sort'\n&Order = 'Order'\n&Keyword = 'Keyword'\n&Search = 'Search'\nIF (&initzcmd = '?')\n  &ZCMD = &initzcmd\n)REINIT\n)PROC\n)FIELD\nField(GENIEDES) Len(255) SCROLL(On)\n)PNTS\nFIELD(Sort)     VAR(ZCMD) VAL('SORT')\nFIELD(Order)    VAR(ZCMD) VAL('ORDER')\nFIELD(Keyword)  VAR(ZCMD) VAL('FINDKYWD')\nFIELD(Search)   VAR(ZCMD) VAL('SRCHTEXT')\n)END\nContact:  \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nPANELEND\nPANEL GENIEZSL\n)ATTR DEFAULT(%~_)\n %   TYPE(TEXT) INTENS(HIGH) Caps(Off)\n ~   TYPE(TEXT) INTENS(LOW) Caps(Off)\n _   TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) Hilite(UScore)\n)BODY Expand(||)\n%|-| GENIE Primary Commands |-|\n~\n%Primary Command ==>_GENIEZSL\n%Primary            Function\n~------------------ |-|\n%Select wish       ~Selects a wish.\n%?                 ~Brings up this pop-up panel.\n%+ Expand level    ~Expands any TOPIC to CHAPTERs or CHAPTER to WISHes.\n%*                 ~Expands all TOPICs and CHAPTERs.\n%- Unexpand level  ~Unexpands the TOPIC or CHAPTER.\n%Info member       ~Shows additional information about the member.\n%Cancel            ~Just another way to end without selecting a wish.\n%Find string       ~Finds your string in Descriptions and As Known\n%                  ~As (AKA) keyword fields.\n%Keyword string    ~Finds your string in Descriptions and As Known\n%                  ~As (AKA) keyword fields.\n%Search string     ~Slower search of all text.\n%Locate            ~Scroll to the location of a member.\n%Sort              ~Toggles between item and description fields.\n%Order             ~Toggles between Ascending and Descending sequence.\n%Refresh           ~Reread the configuration file and rebuild table.\n~---------- |-|\n~\n)INIT\n)REINIT\n)PROC\n)HELP\n)END\nContact:  \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nPANELEND\nPLIB*/\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Should never get here.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nEnd_Of_Code :\n  SIGNAL OFF SYNTAX\n  SAY \"End of source found before\" @search \"was found.\"\nSyntax:\n  SIGNAL OFF SYNTAX\n  RETURN 4\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\nEnd of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GENIEBLD": {"ttr": 2305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x000\\x01\\x18\\x19\\x1f\\x01\\x18\\x19\\x1f\\x08\\x07\\x02\\x13\\x02\\x13\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2018-07-10T00:00:00", "modifydate": "2018-07-10T08:07:30", "lines": 531, "newlines": 531, "modlines": 0, "user": "KTOMIAK"}, "text": "/* rexx */\nRexx_GENIEBLD:\n  rexxpgm_version = \"01.10\"           /* ver lev */\n\n  PARSE ARG Dataset nothing\n  ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Here is where you can tailor GENIE to use a different\n configuration member.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n  cfgmember = \"$$$$0501\"\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nMain_Routine:\n  return_code = Initialization_Routine()\n  IF (return_code = 0) THEN DO\n    return_code = Process_Routine()\n  END\n  return_code = Termination_Routine()\n  RETURN return_code\n\n/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n=======================================================================\n\nDataset: REXX(GENIEBLD)\nContact: \"Kenneth Tomiak\"<CBT_KEN@KTomiak.biz>\nPurpose: This code uses ISPF library services to gather all\n         members and create the cfgmember member for the %GENIE\n         Edit macro.\nSyntax:  geniebld |filename|\n         filename: a PDS or PDSE where WISHLIST members are stored.\n\n-----------------------------------------------------------------------\n\nHistory of Modifications\n========================\nvv.mm When     Who / What you did\n----- -------- --------------------------------------------------------\n01.10 20180710 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Set return_code on lminit and lmopen.\n               2) Initialize dataout_count earlier and use to bypass\n                  errant DISKW attempt when PDSDSN is not available.\n----- -------- --------------------------------------------------------\n01.09 20180517 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Added length check for MSGLINE and NOTELINE > 72.\n----- -------- --------------------------------------------------------\n01.08 20180513 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Removed 'id@type = \"F\"' as \"F\" is no longer used.\n               2) Changed configuration file to configuration member.\n----- -------- --------------------------------------------------------\n01.07 20180512 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Stylize using Edit Macro @putktm:\n                  Programming Using The Kenneth Tomiak Method.\n               2) Stylize using\n                  Programming Using The Kenneth Tomiak Method.\n               3) Updated initial comment.\n               4) Fixed time on \"Z\" record to not have \":\".\n----- -------- --------------------------------------------------------\n01.06 20180322 KTomiak \"Kenneth Tomiak\"<CBT_KEN@KTomiak.biz>\n               1) Show record ctr when bad internal type.\n----- -------- --------------------------------------------------------\n01.05 20180207 KTomiak \"Kenneth Tomiak\"<CBT_KEN@KTomiak.biz>\n               1) SETMSG when cfgmember is successfully built.\n----- -------- --------------------------------------------------------\n01.04 20180122 KTomiak \"Kenneth Tomiak\"<CBT_KEN@KTomiak.biz>\n               1) Removed prompt to overlay cfgmember.\n----- -------- --------------------------------------------------------\n01.03 20170611 KTomiak \"Kenneth Tomiak\"<CBT_KEN@KTomiak.biz>\n               1) Renamed to GENIEBLD.\n----- -------- --------------------------------------------------------\n01.02 20170531 KTomiak \"Kenneth Tomiak\"<CBT_KEN@KTomiak.biz>\n               1) Replaced subsequent use of Dataset to pdsdsn.\n               2) Support \"F\" to map file to a topic.\n----- -------- --------------------------------------------------------\n01.01 20170507 KTomiak \"Kenneth Tomiak\"<CBT_KEN@KTomiak.biz>\n               1) Stylized History of Modifications per PUTKTM-REXX.\n               2) Added support for id@type = \"R\", \"X\", and \"?\".\n               3) Support case-insensitive id@type values.\n                  That means the WISHLIST files are now mixed case\n                  tolerant. For example, you can now use \"X\" or \"x\".\n               4) Add To_Lowercase and To_Uppercase routines.\n----- -------- --------------------------------------------------------\n01.00 20170411 KTomiak \"Kenneth Tomiak\"<CBT_KEN@KTomiak.biz>\n               1) Original code cloned from PDS2UPDT and modified.\n----- -------- --------------------------------------------------------\n\n-----------------------------------------------------------------------\n\nSTANDARD GLOBAL DISCLAIMER\nThe author explicitly disavows any claim whatsoever about the\ncorrectness or functionality of this program, and disclaims liability\nfor anything and everything bad that might happen in connection with,\nbefore, during, or after using it. I have tried to make it work right,\nand I am personally pretty confident that it does, but everybody makes\nmistakes, so if you use it, you do so at your own risk.\n\n=======================================================================\n<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_Routine:\n  return_code = 0\n  dataout_count = 0\n  sysvar_sysuid = SYSVAR(\"SYSUID\")\n  IF (Dataset = \"\") THEN DO\n    Dataset = \"VENDOR.SYSPG.WISHLIST\"\n  END\n  PDSDSN = STRIP(Dataset,\"B\",\"'\")\n  ADDRESS ISPEXEC \"LMINIT DATAID(DATAID)\",\n    \"DATASET('\"PDSDSN\"') ENQ(SHR)\"\n  lminit_rc = RC\n  IF (lminit_rc <> 0) THEN DO\n    ZERRSM = \"WISHLIST problem\"\n    ZERRLM = \"THE FILE\" PDSDSN \"IS IN USE OR DOES NOT EXIST.\"\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    return_code = lminit_rc\n    RETURN return_code\n  END\n  ADDRESS ISPEXEC \"LMOPEN DATAID(\"DATAID\")\",\n    \"OPTION(INPUT) LRECL(MYRECLN)\"\n  lmopen_rc = RC\n  IF (lmopen_rc > 0) THEN DO\n    ZERRSM = \"FILE FAILED TO OPEN\"\n    ZERRLM = \"THE FILE\" PDSDSN \"FAILED TO OPEN RC=\"lmopen_rc\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    return_code = lmopen_rc\n    RETURN return_code\n  END\n  myrecln = myrecln + 0\n  num_lvls = 0\n  real_dsn = pdsdsn\n  DO WHILE (real_dsn <> \"\")\n    num_lvls = num_lvls + 1\n    PARSE VAR real_dsn LQ '.' real_dsn\n    lq.num_lvls = LQ\n  END\n  lq.0 = num_lvls\n  out_dsn = sysvar_SYSUID\".SEQOUT\"\n  DO ix = 1 TO num_lvls\n    one_level = lq.ix\n    IF (one_level = sysvar_SYSUID) THEN DO\n      ITERATE\n    END\n    out_dsn = out_dsn\".\"one_level\n  END\n  sysdsn_status = SYSDSN(\"'\"out_dsn\"'\")\n  IF (sysdsn_status = \"OK\") THEN DO\n    \"ALLOC FILE(SEQOUT) DA('\"out_dsn\"') OLD\",\n      \"TRACKS SPACE(250 150) REUSE\"\n    MYRC=RC\n  END\n  ELSE DO\n    \"ALLOC FILE(SEQOUT) DA('\"out_dsn\"')\",\n      \"NEW CATALOG RECFM(F B) REUSE\",\n      \"BLKSIZE(0) LRECL(\"MYRECLN\")\",\n      \"TRACKS SPACE(250 150)\",\n      \"UNIT(SYSALLDA)\"\n /*   \"UNIT(SYSALLDA) VOLUME(\"SYSVOLUME\")\"  */\n    MYRC=RC\n  END\n  IF (MYRC > 0) THEN DO\n    SAY \"COULD NOT CREATE\" out_dsn \"RC=\"MYRC\n    RETURN myrc\n  END\n  dataout. = \"\"\n  func_rc = Add_Initial_Comment()\n  error_count = 0\n  warning_count = 0\n  pdsmbr = \"\"\n  function_rc = 0\n  my_ctr = 0\n  uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_Routine:\n  DO WHILE (function_rc = 0)\n    function_rc = Lmmlist_Pds_Members()\n  END\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does cleanup before exiting.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_Routine:\n  ADDRESS ISPEXEC \"LMMLIST DATAID(\"DATAID\") OPTION(FREE)\"\n  ADDRESS ISPEXEC \"LMCLOSE DATAID(\"DATAID\")\"\n  ADDRESS ISPEXEC \"LMFREE DATAID(\"DATAID\")\"\n\n  IF (dataout_count > 0) THEN DO\n    data_rc = Add_Data(\"*\")\n    dataout.0 = dataout_count\n    \"EXECIO * DISKW SEQOUT (STEM dataout. FINIS)\"\n    \"FREE FILE(SEQOUT)\"\n    IF ((error_count > 0) | (warning_count > 0)) THEN DO\n      ZERRSM = error_count \"Errors\"\n      ZERRLM = \"Find '!' and fix. Find '?' and verify its use.\"\n      ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      ADDRESS ISPEXEC \"VIEW DATASET('\"out_dsn\"')\"\n         /* Return codes                     */\n         /* 16 - No members in library       */\n         /* 18 - VSAM processing unavailable */\n         /* 20 - Severe error                */\n         /*                                  */\n    END\n    IF (error_count = 0) THEN DO\n      ZERRSM = cfgmember \"replaced\"\n      ZERRLM = \"The config member was successfully built.\"\n      ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      out_mbr = pdsdsn\"(\"cfgmember\")\"\n      \"ALLOC FILE(SEQOUT) DATASET('\"out_mbr\"') SHR REUSE\"\n      \"EXECIO * DISKW SEQOUT (STEM dataout. FINIS)\"\n      \"FREE FILE(SEQOUT)\"\n    END\n  END\n  msg_rc = MSG(\"OFF\")\n  \"DELETE '\"out_dsn\"'\"\n  msg_rc = MSG(\"ON\")\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Loop thru all of the WISHLIST members.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nLmmlist_Pds_Members:\n  ADDRESS ISPEXEC \"LMMLIST DATAID(\"DATAID\")\",\n    \"OPTION(LIST) MEMBER(pdsmbr) STATS(YES)\"\n  lmmlist_rc = RC\n  IF (lmmlist_rc > 0) THEN DO\n    RETURN lmmlist_rc\n  END\n  my_ctr = my_ctr + 1\n  IF (pdsmbr = cfgmember) THEN DO\n    RETURN 0\n  END\n  just_mbr = STRIP(pdsmbr,\"T\",\" \")\n  just_len = LENGTH(just_mbr)\n  SELECT\n    WHEN (just_len = 4) THEN DO\n      mbrtype = \"T\"\n      SAY just_mbr\n    END\n    WHEN (just_len = 6) THEN DO\n      mbrtype = \"C\"\n    END\n    WHEN (just_len = 8) THEN DO\n      mbrtype = \"W\"\n    END\n    OTHERWISE DO\n      error_count = error_count + 1\n      data_rc = Add_Data(\"*\"pdsmbr \"! Invalid name length:\" just_len)\n      SAY \"*\"pdsmbr \"! Invalid name length:\" just_len\n      RETURN 0\n    END\n  END\n  msg_rc = MSG(\"OFF\")\n  \"ALLOC FILE(GENIEMBR) DATASET('\"pdsdsn\"(\"just_mbr\")') SHR REUSE\"\n  alloc_rc = RC\n  msg_rc = MSG(\"ON\")\n  IF (alloc_rc <> 0) THEN DO\n    error_count = error_count + 1\n    data_rc = Add_Data(\"*\"pdsmbr \"! ALLOC failed:\" alloc_rc)\n    SAY \"*\"pdsmbr \"! ALLOC failed:\" alloc_rc\n    RETURN alloc_rc\n  END\n  \"EXECIO * DISKR GENIEMBR (STEM mbr_record. FINIS)\"\n  diskr_rc = RC\n  \"FREE FILE(GENIEMBR)\"\n  IF (diskr_rc <> 0) THEN DO\n    error_count = error_count + 1\n    data_rc = Add_Data(\"*\"pdsmbr \"! DISKR failed:\" diskr_rc)\n    SAY \"*\"pdsmbr \"! DISKR failed:\" diskr_rc\n    RETURN diskr_rc\n  END\n  IF (mbr_record.0 < 2) THEN DO\n    error_count = error_count + 1\n    data_rc = Add_Data(\"*\"pdsmbr \"! Too few records:\" ,\n      just_mbr\", #=\"mbr_record.0)\n    SAY \"*\"pdsmbr \"! Too few records:\" ,\n      just_mbr\", #=\"mbr_record.0\n    RETURN diskr_rc\n  END\n  t_record = \"\"\n  c_record = \"\"\n  w_record = \"\"\n  anykey = \"\"\n  anydes = \"\"\n  dspace = \"\"\n  kspace = \"\"\n  DO mbrx = 1 TO mbr_record.0\n    mbr_record.mbrx = STRIP(mbr_record.mbrx,\"T\",\" \")\n    id@type = LEFT(mbr_record.mbrx,1)\n    id@type = To_Uppercase(id@type)\n    SELECT\n      WHEN (id@type = \"*\") THEN DO\n        NOP\n      END\n      WHEN (id@type = \"#\") THEN DO\n        NOP\n      END\n      WHEN (id@type = \"@\") THEN DO\n        NOP\n      END\n      WHEN (id@type = \"B\") THEN DO\n        NOP\n      END\n      WHEN (id@type = \"D\") THEN DO\n        NOP\n      END\n      WHEN (id@type = \"E\") THEN DO\n        NOP\n      END\n      WHEN (id@type = \"G\") THEN DO\n        NOP\n      END\n      WHEN (id@type = \"I\") THEN DO\n        NOP\n      END\n      WHEN (id@type = \"K\") THEN DO\n        anykey = anykey || ,\n          kspace || SUBSTR(mbr_record.mbrx,2)\n        kspace = \" \"\n      END\n      WHEN (id@type = \"M\") THEN DO\n        IF (LENGTH(mbr_record.mbrx) > 73) THEN DO\n          data_rc = Add_Data(\"*\"pdsmbr \"! Length > 72:\" int@name mbrx)\n          data_rc = Add_Data(\"*\"pdsmbr \"!\" Left(mbr_record.mbrx,68))\n          SAY \"*\"pdsmbr \"!  Length > 72:\" int@name mbrx\n          error_count = error_count + 1\n        END\n      END\n      WHEN (id@type = \"N\") THEN DO\n        IF (LENGTH(mbr_record.mbrx) > 73) THEN DO\n          data_rc = Add_Data(\"*\"pdsmbr \"! Length > 72:\" int@name mbrx)\n          data_rc = Add_Data(\"*\"pdsmbr \"!\" Left(mbr_record.mbrx,68))\n          SAY \"*\"pdsmbr \"!  Length > 72:\" int@name mbrx\n          error_count = error_count + 1\n        END\n      END\n      WHEN (id@type = \"R\") THEN DO\n        NOP\n      END\n      WHEN (id@type = \"S\") THEN DO\n        int@name = SUBSTR(mbr_record.mbrx,2,8)\n        IF (just_mbr <> int@name) THEN DO\n          data_rc = Add_Data(\"*\"pdsmbr \"! Bad internal name:\" int@name mbrx)\n          SAY \"*\"pdsmbr \"! Bad internal name:\" int@name mbrx\n          error_count = error_count + 1\n        END\n        t_record = LEFT(pdsmbr,4)\"     \"mbrtype\n        c_record = LEFT(pdsmbr,6)\"   \"mbrtype\n        w_record = LEFT(pdsmbr,8)\" \"mbrtype\n      END\n      WHEN (id@type = \"T\") THEN DO\n        anydes = anydes || ,\n          dspace || SUBSTR(mbr_record.mbrx,2)\n        dspace = \" \"\n      END\n      WHEN (id@type = \"U\") THEN DO\n        NOP\n      END\n      WHEN (id@type = \"W\") THEN DO\n        NOP\n      END\n      WHEN (id@type = \"X\") THEN DO\n        NOP\n      END\n      WHEN (id@type = \"Z\") THEN DO\n        NOP\n      END\n      WHEN (id@type = \"?\") THEN DO\n        NOP\n      END\n      OTHERWISE DO\n        data_rc = Add_Data(\"*\"pdsmbr \"! Bad type:\" id@type  ,\n          \"record:\" mbrx)\n        SAY \"*\"pdsmbr \"! Bad type:\" id@type ,\n          \"record:\" mbrx\n        error_count = error_count + 1\n      END\n    END\n  END\n  SELECT\n    WHEN (mbrtype = \"T\") THEN DO\n      this_string = anydes\n      strglen = 60\n      DO WHILE (this_string <> \"\")\n        partial_string = Chop_String_To_LENGTH()\n        data_rc = Add_Data(\"G\"t_record partial_string)\n      END\n    END\n    WHEN (mbrtype = \"C\") THEN DO\n      this_string = anydes\n      strglen = 60\n      DO WHILE (this_string <> \"\")\n        partial_string = Chop_String_To_LENGTH()\n        data_rc = Add_Data(\"G\"c_record partial_string)\n      END\n    END\n    WHEN (mbrtype = \"W\") THEN DO\n      this_string = anydes\n      strglen = 60\n      DO WHILE (this_string <> \"\")\n        partial_string = Chop_String_To_LENGTH()\n        data_rc = Add_Data(\"G\"w_record partial_string)\n      END\n    END\n    OTHERWISE DO\n      NOP\n    END\n  END\n  IF (anykey <> \"\") THEN DO\n    this_string = anykey\n    strglen = 60\n    DO WHILE (this_string <> \"\")\n      partial_string = Chop_String_To_LENGTH()\n      data_rc = Add_Data(\"G\"LEFT(pdsmbr,8) \"K\" partial_string)\n    END\n  END\n  RETURN 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Add to the stem dataout.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nAdd_Data:\n  PARSE ARG somedata\n  dataout_count = dataout_count + 1\n  dataout.dataout_count = somedata\n  RETURN dataout_count\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Add the initial comment.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nAdd_Initial_Comment:\n  data_rc = Add_Data(\"S\"cfgmember)\n  data_rc = Add_Data(\"TGENIE\")\n  data_rc = Add_Data(\"T-Chapter 05.\")\n  data_rc = Add_Data(\"T-Default configuration member.\")\n  data_rc = Add_Data(\"E%GENIEBLD Generator REXX code\")\n  time_blk = TIME(\"H\") || TIME(\"M\") || LEFT(TIME(\"S\"),2)\n  data_rc = Add_Data(\"Z\"DATE(\"S\")\"-\"time_blk)\n  data_rc = Add_Data(\"*\")\n  data_rc = Add_Data(\"*\"COPIES(\"_\",79))\n  data_rc = Add_Data(\"*\")\n  RETURN dataout_count\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Break up a string into a smaller length.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nChop_String_To_Length:\n  ts_len = LENGTH(this_string)\n  IF (ts_len <= strglen) THEN DO\n    return_string = this_string\n    this_string = \"\"\n    RETURN return_string\n  END\n  too_long = \"\"\n  good_long = \"\"\n  num_words = WORDS(this_string)\n  a_space = \"\"\n  DO word_ctr = 1 TO num_words\n    next_word = WORD(this_string,1)\n    IF (LENGTH(next_word) > strglen) THEN DO\n      IF (good_long <> \"\") THEN DO\n        RETURN good_long\n      END\n      ELSE DO\n        return_string = LEFT(this_string,strglen)\n        this_string = SUBSTR(this_string,(strglen + 1))\n        RETURN return_string\n      END\n    END\n    too_long = too_long || a_space || next_word\n    line_len = LENGTH(too_long)\n    IF (line_len > strglen) THEN DO\n      RETURN good_long\n    END\n    good_long = good_long || a_space || next_word\n    a_space = \" \"\n    this_string = STRIP(DELSTR(this_string,1,LENGTH(next_word)),\"L\",\" \")\n  END\n  RETURN good_long\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Pad a string to a desired length.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nFill_String:\n  PARSE ARG padlen , padstring\n  IF (LENGTH(padstring) > padlen) THEN DO\n    SAY \"ABORT\"\n    RETURN LEFT(padstring,padlen)\n  END\n  IF (LENGTH(padstring) = padlen) THEN DO\n    RETURN padstring\n  END\n  filllen = padlen - LENGTH(padstring)\n  RETURN LEFT(padstring COPIES(\" \",filllen),padlen)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: PARSE ARG myarg\n  RETURN TRANSLATE(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: PARSE ARG myarg\n  RETURN TRANSLATE(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\nEnd of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GENIEMC1": {"ttr": 2314, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00G\\x01\\x18\\x13\\x1f\\x01\\x18\\x13\\x7f\\x00\\x01\\x01\\x12\\x00s\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2018-05-11T00:00:00", "modifydate": "2018-05-17T00:01:47", "lines": 274, "newlines": 115, "modlines": 0, "user": "KTOMIAK"}, "text": "/* rexx */\nRexx_GENIEMC1:\n  rexxpgm_version = \"01.03\"           /* ver lev */\n\n  ADDRESS ISREDIT \"MACRO (bulk) NOPROCESS\"\n  UPPER bulk\n  ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nMain_Routine:\n  return_code = Initialization_Routine()\n  IF (return_code = 0) THEN DO\n    return_code = Process_Routine()\n  END\n  return_code = Termination_Routine()\n  ADDRESS ISREDIT \"MEND\"\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n\n Dataset:  TSO.REXX(GENIEMC1)\n Contact:  \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n Overview: Strip \"T\" records down in size.\n Syntax:   %GENIEMC1 |bulk|\n             bulk: YES when more than one member is being processed.\n\n-----------------------------------------------------------------------\n\n History of Modifications\n ------------------------\nvv.mm WHEN     Who / What you did ... (Newest change at the top.)\n----- -------- --------------------------------------------------------\n01.03 20180516 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Handle saving a new member RC(04) ledt to adding\n                  logic for all of the possible return codes.\n               2) If BULK = YES and SAVE failed then SETMSG and\n                  do not END. VPUT(GONOGO) = NOGO to halt processing.\n----- -------- --------------------------------------------------------\n01.02 20180515 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Move NOSMART logic here. Changes PC smart\n                  characters to the typewriter based equivalents.\n               2) Added macro parameter BULK to signal when more\n                  than one member is being processed.\n----- -------- --------------------------------------------------------\n01.01 20180512 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Tweaking to look at all members.\n----- -------- --------------------------------------------------------\n01.00 20180511 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code.\n----- -------- --------------------------------------------------------\n\n-----------------------------------------------------------------------\n\nSTANDARD GLOBAL DISCLAIMER\n--------------------------\nThe author explicitly disavows any claim whatsoever about the\ncorrectness or functionality of this program, and disclaims liability\nfor anything and everything bad that might happen in connection with,\nbefore, during, or after using it. I have tried to make it work right,\nand I am personally pretty confident that it does, but everybody makes\nmistakes, so if you use it, you do so at your own risk.\n\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_Routine:\n  return_code = 0\n  ADDRESS ISREDIT \"(editmbr) = MEMBER\"\n  ADDRESS ISREDIT \"(editdsn,origdsn,origlibn) = DATASET\"\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_Routine:\n  ADDRESS ISREDIT \"(finddata) = LINE 1\"\n  finddata = STRIP(finddata,\"B\",\" \")\n  newdata = \"S\"editmbr\n  IF (finddata <> newdata) THEN DO\n    ADDRESS ISREDIT \"LINE 1 = (newdata)\"\n  END\n  ADDRESS ISREDIT \"C ALL 'kenneth e. tomiak' 'Kenneth Tomiak'\"\n  IF (LEFT(editmbr,4) = \"$$$$\") THEN DO\n    ADDRESS ISREDIT \"C ALL 'topic' 'TOPIC'\"\n    ADDRESS ISREDIT \"C ALL 'chapter' 'CHAPTER'\"\n    ADDRESS ISREDIT \"C ALL 'wish' 'WISH'\"\n    ADDRESS ISREDIT \"C ALL 'T-CHAPTER' 'T-Chapter'\"\n    ADDRESS ISREDIT \"C ALL 'NCHAPTER' 'NChapter'\"\n  END\n  SELECT\n    WHEN (LENGTH(editmbr) = 4) THEN DO\n      NOP\n    END\n    WHEN (LENGTH(editmbr) = 6) THEN DO\n      NOP\n    END\n    WHEN (LENGTH(editmbr) = 8) THEN DO\n      ADDRESS ISREDIT \"FIND 'T-Chapter' FIRST\"\n      find_rc = RC\n      IF (find_rc = 0) THEN DO\n        ADDRESS ISREDIT \"(findline, findpos) = CURSOR\"\n        findline = findline + 0\n        ADDRESS ISREDIT \"(finddata) = LINE\" findline\n        IF (POS(\":\",finddata) > 0) THEN DO\n          PARSE VAR finddata newdata \":\" . \"-\" keeper\n        END\n        ELSE DO\n          PARSE VAR finddata newdata \".\" . \"-\" keeper\n        END\n        newdata = newdata || \".\"\n        ADDRESS ISREDIT \"LINE\" findline \"= (newdata)\"\n        keeper = STRIP(keeper,\"B\",\" \")\n        IF (keeper <> \"\") THEN DO\n          newdata = \"T-\" || keeper\n          ADDRESS ISREDIT \"LINE_AFTER\" findline \"= (newdata)\"\n        END\n      END\n    END\n    OTHERWISE DO\n      NOP\n    END\n  END\n\n/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n Change PC smart characters to valid EBCDIC characters.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n  ADDRESS ISREDIT \"x ' ' all\"\n  ADDRESS ISREDIT \"C x'01' ' ' all\"   /*  */\n  ADDRESS ISREDIT \"C x'05' ' ' all\"   /* tab */\n  ADDRESS ISREDIT \"C x'11' \"\"'\"\" all\" /*  */\n  ADDRESS ISREDIT \"C x'12' \"\"'\"\" all\" /* apostrophe */\n  ADDRESS ISREDIT \"C x'13' '\"\"' all\"  /* start quote */\n  ADDRESS ISREDIT \"C x'19' '' all\"    /* TM */\n  ADDRESS ISREDIT \"C x'26' ' ' all\"   /*  */\n  ADDRESS ISREDIT \"C x'32' '-' all\"   /* dash */\n  ADDRESS ISREDIT \"C x'39' '' all\"    /* TM */\n  ADDRESS ISREDIT \"C x'3C' '\"\"' all\"  /* end quote */\n/*ADDRESS ISREDIT \"C x'??' ' ' all\"   /* not x'50' blank house */ */\n  ADDRESS ISREDIT \"C x'AF' '' all\"    /* Registered */\n\n  ADDRESS ISREDIT \"f p'.' first\"\n  find_rc = RC\n  IF ((bulk <> \"YES\") & (find_rc = 0)) THEN DO\n    ADDRESS ISREDIT \"(strg,lin) = FIND_COUNTS\"\n    SAY \"(\"strg\",\"lin\") = FIND_COUNTS strings and lines\"\n    ZERRALRM = \"YES\"\n    ZERRHM = \"*\"\n    ZERRSM = \"p'.' found\"\n    ZERRLM = ,\n      LEFT(\"Reissue the find p'.' first command.\",76)\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n  END\n\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does cleanup before exiting.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_Routine:\n  ADDRESS ISREDIT ,\n    \"F c'* End of WISH.' 1 ALL\"\n  find_rc = RC\n  IF (find_rc > 0) THEN DO\n    ADDRESS ISREDIT ,\n      \"C '* End of WISH' '* End of WISH.' 1 ALL\"\n    ADDRESS ISREDIT ,\n      \"C '* End of WISH..' '* End of WISH.' 1 ALL\"\n  END\n  ADDRESS ISREDIT \"(lastline) = LINENUM .ZLAST\"\n  lastline = lastline + 0\n  ADDRESS ISREDIT \"(lastdata) = LINE\" lastline\n  DO WHILE (lastdata = \" \")\n    IF (STRIP(lastdata,\"B\",\" \") = \"\") THEN DO\n      ADDRESS ISREDIT \"DELETE\" lastline\n      lastline = lastline - 1\n    END\n    ADDRESS ISREDIT \"(lastdata) = LINE\" lastline\n  END\n  IF (lastdata <> \"* End of WISH.\") THEN DO\n    newdata = \"* End of WISH.\"\n    ADDRESS ISREDIT \"LINE_AFTER\" lastline \"= (newdata)\"\n  END\n  ADDRESS ISREDIT \"(datachgd) = DATA_CHANGED\"\n  IF (datachgd = \"YES\") THEN DO\n    ADDRESS ISREDIT \"FIND 'Z' 1 FIRST\"\n    find_rc = RC\n    IF (find_rc = 0) THEN DO\n      ADDRESS ISREDIT \"(findline, findpos) = CURSOR\"\n      findline = findline + 0\n      ADDRESS ISREDIT \"(finddata) = LINE\" findline\n      PARSE VALUE TIME(\"N\") WITH hr \":\" mn \":\" sc\n      time_blk = hr || mn || sc\n      newdata = \"Z\" || DATE(\"S\") || \"-\" || time_blk\n      ADDRESS ISREDIT \"LINE\" findline \"= (newdata)\"\n    END\n    gonogo = \"NOGO\"\n    ADDRESS ISREDIT \"SAVE\"\n    save_rc = RC\n    SELECT\n      WHEN (save_rc = 0) THEN DO\n        /* Normal completion */\n        gonogo = \"GO\"\n      END\n      WHEN (save_rc = 4) THEN DO\n        /* New member saved - wish is also a good save */\n        gonogo = \"GO\"\n      END\n      WHEN (save_rc = 8) THEN DO\n        /* Data is not saved; the SAVE command was entered              .\n           while in View */\n        NOP\n      END\n      WHEN (save_rc > 12) THEN DO\n        /* Data is not saved; possible reasons are:\n           -> There is not enough PDS space or directory space available\n              to satisfy the command.\n           -> The NEWGEN or NOGEN parameter was specified while editing\n              a file that is not a member in a PDSE version 2 data set\n              that is configured for member generations. */\n        ADDRESS ISPEXEC \"DSINFO DATASET('\"editdsn\"')\"\n        IF (ZDSDIRA = ZDSDIRU) THEN DO\n          ZERRLM = \"You need to add directory blocks to:\" editdsn\n          ZERRLM = ZERRLM ,\n            LEFT(\"More than\" SPACE(ZDSDIRU) \"directory blocks.\",76)\n        END\n        ELSE DO\n          ZERRLM = \"You need to compress:\" editdsn\n          ZERRLM = ZERRLM ,\n            LEFT(\"Or allocate it larger than\" ,\n            SPACE(ZDSTOTUX) ZDSSPC,76)\n        END\n        return_code = save_rc\n      END\n      WHEN (save_rc = 20) THEN DO\n        /* Severe error */\n        return_code = save_rc\n      END\n      OTHERWISE DO\n        SAY \"You should never reach here, RC(\"save_rc\").\"\n        return_code = save_rc\n      END\n    END\n  END\n  IF ((bulk <> \"YES\") & (save_rc > 0)) THEN DO\n    ZERRALRM = \"YES\"\n    ZERRHM = \"*\"\n    ZERRSM = \"Press HELP!\"\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n  END\n  ADDRESS ISPEXEC \"VPUT (GONOGO) SHARED\"\n  IF (save_rc < 5) THEN DO\n    ADDRESS ISREDIT \"END\"\n  END\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\nEnd of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GENIERTA": {"ttr": 2565, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01\\x18\\x13o\\x01\\x18\\x13\\x7f\\t(\\x00`\\x00[\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-16T00:00:00", "modifydate": "2018-05-17T09:28:32", "lines": 96, "newlines": 91, "modlines": 0, "user": "KTOMIAK"}, "text": "/* rexx */\nRexx_GENIERTA:\n  rexxpgm_version = \"01.00\"           /* ver lev */\n\n  ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nMain_Routine:\n  return_code = Initialization_Routine()\n  IF (return_code = 0) THEN DO\n    return_code = Process_Routine()\n  END\n  return_code = Termination_Routine()\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n\n Dataset:  TSO.REXX(GENIERTA)\n Contact:  \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n Overview: Sample user defined routine.\n Syntax:   %GENIERTA\n\n-----------------------------------------------------------------------\n\n History of Modifications\n ------------------------\nvv.mm WHEN     Who / What you did ... (Newest change at the top.)\n----- -------- --------------------------------------------------------\n01.00 20180517 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code.\n----- -------- --------------------------------------------------------\n\n-----------------------------------------------------------------------\n\nSTANDARD GLOBAL DISCLAIMER\n--------------------------\nThe author explicitly disavows any claim whatsoever about the\ncorrectness or functionality of this program, and disclaims liability\nfor anything and everything bad that might happen in connection with,\nbefore, during, or after using it. I have tried to make it work right,\nand I am personally pretty confident that it does, but everybody makes\nmistakes, so if you use it, you do so at your own risk.\n\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_Routine:\n  return_code = 0\n  ADDRESS ISPEXEC \"VGET (aftrline) SHARED\"\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_Routine:\n  type_line = \"INFOLINE\"\n  newtext = \"This INFOLINE (======) was added by GENIERTA.\"\n  ADDRESS ISREDIT \"LINE_BEFORE\" aftrline \"=\" type_line \"(newtext)\"\n  insert_rc = RC\n  IF (insert_rc = 0) THEN DO\n    IF (type_line = \"DATALINE\") THEN DO\n      aftrline = aftrline + 1\n    END\n  END\n  ELSE DO\n    SAY \"Insert LINE_BEFORE\" aftrline type_line ,\n      \"failed, RC(\"inert_rc\").\"\n  END\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does cleanup before exiting.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_Routine:\n  ADDRESS ISPEXEC \"VPUT (aftrline) SHARED\"\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\nEnd of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICCOPY": {"ttr": 2568, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x04\\x01\\x18\\x02\\x7f\\x01\\x18\\x03\\x8f\\x08'\\x00\\x9b\\x00`\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-01-27T00:00:00", "modifydate": "2018-02-07T08:27:04", "lines": 155, "newlines": 96, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\nrexx_msiccopy:\n  rexxpgm_version = \"01.01\"          /* Set with 'ver 1' and 'lev 2'. */\n\n  PARSE ARG vdef_hostdsn vdef_sysexec\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nrexx_Main_Code:\n  return_code = Initialization_routine()\n  If (return_code = 0) Then Do\n    return_code = Process_routine()\n  End\n  return_code = Termination_routine()\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to define a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.01 20180207 \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Ensure vdef_sysexec exists.\n----- -------- --------------------------------------------------------\n01.00 20180122 \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_routine:\n  return_code = 0\n  ADDRESS ISPEXEC \"LMINIT DATAID(DSNIN) DATASET('\"vdef_hostdsn\"')\"\n  function_rc = RC\n  IF (function_rc <> 0) THEN DO\n    ZERRALRM = \"YES\"\n    ZERRHLP = \"\"\n    ZERRSM = DSNIN \"LMINIT RC(\"function_rc\")\"\n    ZERRLM = \"LMINIT FAILED ON\" vdef_hostdsn\".\"\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    return_code = function_rc\n    Return return_code\n  END\n  listdsi_rc = LISTDSI(\"'\"vdef_sysexec\"'\")\n  IF (listdsi_rc <> 0) THEN DO\n    ZERRALRM = \"YES\"\n    ZERRHLP = \"\"\n    ZERRSM = \"SYSEXEC not found\"\n    ZERRLM = \"DSN('\"vdef_sysexec\"') was not found.\"\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    return_code = listdsi_rc\n    RETURN return_code\n  END\n  ADDRESS ISPEXEC \"LMINIT DATAID(DSNOT) DATASET('\"vdef_sysexec\"')\"\n  function_rc = RC\n  IF (function_rc <> 0) THEN DO\n    ZERRALRM = \"YES\"\n    ZERRHLP = \"\"\n    ZERRSM = DSNIN \"LMINIT RC(\"function_rc\")\"\n    ZERRLM = \"LMINIT FAILED ON\" vdef_sysexec\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    return_code = function_rc\n    Return return_code\n  END\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_routine:\n  ADDRESS ISPEXEC \"LMCOPY FROMID(\"DSNIN\") TODATAID(\"DSNOT\")\" ,\n    \"FROMMEM(GENIE) REPLACE\"\n  function_rc = RC\n  IF (function_rc <> 0) THEN DO\n    ZERRALRM = \"YES\"\n    ZERRHLP = \"\"\n    ZERRSM = DSNIN \"LMCOPY RC(\"function_rc\")\"\n    ZERRLM = \"LMCOPY FAILED ON GENIE\"\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    return_code = function_rc\n    Return return_code\n  END\n  ADDRESS ISPEXEC \"LMCOPY FROMID(\"DSNIN\") TODATAID(\"DSNOT\")\" ,\n    \"FROMMEM(GENIEBLD) REPLACE\"\n  function_rc = RC\n  IF (function_rc <> 0) THEN DO\n    ZERRALRM = \"YES\"\n    ZERRHLP = \"\"\n    ZERRSM = DSNIN \"LMCOPY RC(\"function_rc\")\"\n    ZERRLM = \"LMCOPY FAILED ON GENIE\"\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    return_code = function_rc\n    Return return_code\n  END\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_routine:\n  ADDRESS ISPEXEC \"LMCLOSE DATAID(\"DSNIN\")\"\n  ADDRESS ISPEXEC \"LMCLOSE DATAID(\"DSNOT\")\"\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICDEFN": {"ttr": 2572, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00 \\x01\\x18\\x02/\\x01\\x18\\x03\\x8f\\x121\\x00\\xa2\\x00u\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2018-01-22T00:00:00", "modifydate": "2018-02-07T12:31:20", "lines": 162, "newlines": 117, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\nrexx_msicdefn:\n  rexxpgm_version = \"01.03\"          /* Set with 'ver 1' and 'lev 2'. */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn  vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nrexx_Main_Code:\n  return_code = Initialization_routine()\n  If (return_code = 0) Then Do\n    return_code = Process_routine()\n  End\n  return_code = Termination_routine()\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to define a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.03 20180207 \"Kenneth E Tomiak\"<CBT_Ken@KTomiak.biz>\n               1) Switch order of parms now that someone is blanking\n                  out the unit and volser/\n----- -------- --------------------------------------------------------\n01.02 20180207 \"Kenneth E Tomiak\"<CBT_Ken@KTomiak.biz>\n               1) Should not need it, but remove apostrophes on\n                  vdef_hostdsn.\n----- -------- --------------------------------------------------------\n01.01 20180206 \"Kenneth E Tomiak\"<CBT_Ken@KTomiak.biz>\n               1) Add a check for SMS = ACTIVE and ignore the\n                  UNIT and VOLSER when allocating the WISHLIST.\n----- -------- --------------------------------------------------------\n01.00 20180122 \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_routine:\n  return_code = 0\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists = 0) THEN DO\n    reason1 = \"Delete existing WISHLIST data set?\"\n    reason2 = \"  '\"vdef_wishlist\"'\"\n    reason4 = \"Warning: You will have to reload the right TOPIC(S).\"\n    Address ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n    IF (function_rc = 0) THEN DO\n      IF (TRANSLATE(CONFIRMD) = \"Y\") THEN DO\n        ADDRESS TSO \"DELETE '\"vdef_wishlist\"'\"\n        function_rc = RC\n        IF (function_rc <> 0) THEN DO\n          SAY \"Delete of '\"vdef_wishlist\"' failed, RC(\"function_rc\")\"\n          return function_rc\n        END\n      END\n      ELSE DO\n        SAY \"Keeping the existing WISHLIST data set.\"\n      END\n    END\n    ELSE DO\n      say \"panel(MSICPCFM) display error\" function_rc\n    END\n  END\n  IF (MVSVAR(\"SYSSMS\") = 'ACTIVE') THEN DO\n    ADDRESS TSO \"ALLOCATE FILE(WISHLIST) DATASET('\"vdef_wishlist\"')\" ,\n      \"TRACKS SPACE(100 50) DIR(490) NEW CATALOG\" ,\n      \"UNIT(SYSALLDA)\" ,\n      \"RECFM(F B) BLKSIZE(0) LRECL(81)\"\n  END\n  ELSE DO\n    ADDRESS TSO \"ALLOCATE FILE(WISHLIST) DATASET('\"vdef_wishlist\"')\" ,\n      \"TRACKS SPACE(100 50) DIR(490) NEW CATALOG\" ,\n      \"UNIT(\"vdef_unit\") VOL(\"vdef_volser\")\" ,\n      \"RECFM(F B) BLKSIZE(0) LRECL(81)\"\n  END\n  function_rc = RC\n  IF (function_rc <> 0) THEN DO\n    SAY \"Allocate of '\"vdef_wishlist\"' failed, RC(\"function_rc\")\"\n    return function_rc\n  END\n  MAKEBUF\n  Queue \"DSNAME('\"vdef_wishlist\"')\"\n  Queue \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\"'\")\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XM$$$$)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XM$$$$)' RC(\"receive_rc\")\"\n    return receive_rc\n  END\n  DROPBUF\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_routine:\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICPCFM": {"ttr": 2819, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00I\\x01\\x17\"\\x1f\\x01\\x17$_\\x14)\\x00\\x16\\x00\\x10\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2017-08-09T00:00:00", "modifydate": "2017-09-02T14:29:49", "lines": 22, "newlines": 16, "modlines": 0, "user": "KTOMIAK"}, "text": ")ATTR DEFAULT(%+_)\n  % TYPE(TEXT) INTENS(HIGH)\n  + TYPE(TEXT) INTENS(LOW)\n  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)\n)BODY WIDTH(80) Expand(||) WINDOW(80,12)\n%| | MSIC Confirmation Required | |\n+\n+&Reason1\n%Confirm:_Z+  Y for YES or N for NO.\n+\n+&Reason2\n+&Reason3\n+&Reason4\n+&Reason5\n+\n)INIT\n.ZVARS = 'CONFIRMD'\n&CONFIRMD = '?'\n)PROC\nVer(&CONFIRMD,LIST,Y,N)\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICPHLP": {"ttr": 2821, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00P\\x01\\x17\"_\\x01\\x18\\x02/\\x11!\\x00\\x14\\x00\\x16\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2017-08-13T00:00:00", "modifydate": "2018-01-22T11:21:50", "lines": 20, "newlines": 22, "modlines": 0, "user": "KTOMIAK"}, "text": ")ATTR DEFAULT(%+_)\n      /*  % TYPE(TEXT) INTENS(HIGH)      defaults displayed for      */\n      /*  + TYPE(TEXT) INTENS(LOW)       information only            */\n      /*  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)             */\n)BODY Expand(||)\n%|-| INSTALL: Help |-|\n%SELECTION ===>_ZCMD                                                           +\n%\n%           ------------------------------------------\n            | GENIE custom installation REXX program |\n            ------------------------------------------\n+\nThis FreeWare tool assists in installing the GENIE REXX programs and WISH\nfiles on your mainframe computer.\n\nWork your way down the tasks in the numbered sequence. Feel free to press your\nHELP PFKey whenever the upper right hand corner indicates there is a longer\nresponse to share with you.\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICPTSK": {"ttr": 2823, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00)\\x01\\x17 /\\x01\\x18\\x02/\\x10R\\x00\\x1a\\x00\\x17\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2017-07-21T00:00:00", "modifydate": "2018-01-22T10:52:29", "lines": 26, "newlines": 23, "modlines": 0, "user": "KTOMIAK"}, "text": ")ATTR DEFAULT(%+_) FORMAT(MIX)\n /* % TYPE(TEXT) INTENS(HIGH)                                         */\n + TYPE(TEXT) INTENS(LOW) Skip(On)\n _ TYPE(Input)  Intens(High) Caps(Off) Just(Left) Pas(On)\n   Hilite(UScore)\n # Type(Output) Intens(High) Caps(Off) Just(Left)\n $ Type(Output) Intens(Low)  Caps(Off) Just(Left) Pas(On)\n)BODY EXPAND(\\\\) Width(&ZSCREENW)\n%-\\-\\- INSTALL Task List -\\-\\-\n%Command ==>_ZCMD \\ \\%Scroll ==>_ZSCR\n%\n%Sel Seq Type      Done     RC Description\n+--- --- --------- -------- -- \\-\\\n)Model\n_Z  $Z  #TASKTYPE #TASKDONE#Z $TASKDESC\n)INIT\n.ZVARS = 'TASKZSEL, TASKSEQ, TASKRC'\n)PROC\n)HELP\nFIELD(ZCMD) PANEL(MSICHTF1)\nFIELD(TASKZSEL) PANEL(MSICHTF2)\nFIELD(TASKDESC) PANEL(MSICHTF3)\n)Field\nField(TASKDESC) Len(80) SCROLL(On)\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICPVAR": {"ttr": 2825, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00U\\x01\\x17#/\\x01\\x18\\x02/\\x113\\x00\\x17\\x00\\x1a\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "2017-08-20T00:00:00", "modifydate": "2018-01-22T11:33:55", "lines": 23, "newlines": 26, "modlines": 0, "user": "KTOMIAK"}, "text": ")ATTR DEFAULT(%+_) FORMAT(MIX)\n /* % TYPE(TEXT) INTENS(HIGH)                                         */\n + TYPE(TEXT) INTENS(LOW) Skip(On)\n _ TYPE(Input)  Intens(High) Caps(Off) Just(Left) Pas(On)\n   Hilite(UScore)\n # Type(Output) Intens(High) Caps(Off) Just(Left)\n $ Type(Output) Intens(Low)  Caps(Off) Just(Left) Pas(On)\n)BODY EXPAND(||) Width(&ZSCREENW)\n%-|-|- INSTALL Variable list -|-|-\n%Command ==>_ZCMD | |%Scroll ==>_ZSCR\n%\n%Name     Type     Length  Description / Value is on the next row.\n+-------- -------- ------- |-|\n)Model\n#VDEFVAR $VDEFATTR$VDEFLEN$VDEFDESC\n_VDEFVAL\n+\n)INIT\n)PROC\n)Field\nField(VDEFDESC) Len(80) SCROLL(On)\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICREDT": {"ttr": 2827, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00Q\\x01\\x18\\x02/\\x01\\x18\\x02\\x7f\\x103\\x00\\x8c\\x00\\x86\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2018-01-22T00:00:00", "modifydate": "2018-01-27T10:33:51", "lines": 140, "newlines": 134, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\nrexx_msicredt:\n  rexxpgm_version = \"01.00\"          /* Set with 'ver 1' and 'lev 2'. */\n\n  PARSE UPPER ARG editdsn\n\n  ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nrexx_Main_Code:\n  return_code = Initialization_routine()\n  If (return_code = 0) Then Do\n    return_code = Process_routine()\n  End\n  return_code = Termination_routine()\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to do variable\n            replacement in identified members.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.00 20170728 \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_routine:\n  return_code = 0\n  msg_rc = 0\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_routine:\n  @trap_state = TRAPMSG(\"On\")\n  msg_state = Msg(\"OFF\")\n  sysdsn_rc = SysDsn(\"'\"editdsn\"'\")\n  If (sysdsn_rc <> \"OK\") Then Do\n    ZERRALRM = \"On\"\n    ZERRHM = \"\"\n    ZERRSM = \"DSN error\"\n    ZERRLM = editdsn \"not found - but $INSTALL ran from it.\"\n    Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    msg_rc = 1\n    return_code = 16\n    Return return_code\n  End\n  msg_st = Msg(msg_state)\n  @trap_state = TRAPMSG(@trap_state)\n  Address TSO ,\n    \"ALLOC File(@EDIT) DataSet('\"editdsn\"(#3EDIT)') SHR REUSE\"\n  alloc_rc = RC\n  Address MVS ,\n    \"EXECIO * DiskR @EDIT (Stem editlist. Finis)\"\n  execio_rc = RC\n  Address TSO ,\n    \"FREE File(@EDIT)\"\n  free_rc = RC\n\n  zerrlm = \"\"\n  Do tx = 1 to editlist.0\n    If (Left(editlist.tx,1) = \"*\") Then Iterate\n    editlist_item = Strip(Left(editlist.tx,8),\"T\",\" \")\n    Address ISPEXEC \"EDIT\" ,\n      \"Dataset('\"editdsn\"(\"editlist_item\")') MACRO(MSICRMBR)\"\n    edit_rc = RC\n    If (edit_rc = 0) Then Do\n      zerrlm = zerrlm || Left(editlist_item \"OK\",79)\n    End\n    Else Do\n      zerrlm = zerrlm || Left(editlist_item \"Nothing changed\",79)\n    End\n  End\n  ZERRALRM = \"Yes\"\n  ZERRSM = \"Edit results\"\n  ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_routine:\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICRMBR": {"ttr": 2830, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00D\\x01\\x17 \\x9f\\x01\\x18\\x02\\x7f\\x11A\\x00\\xdb\\x00\\xe1\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2017-07-28T00:00:00", "modifydate": "2018-01-27T11:41:44", "lines": 219, "newlines": 225, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\nrexx_MSICRMBR:\n  rexxpgm_version = \"01.00\"          /* Set with 'ver 1' and 'lev 2'. */\n\n  Address ISREDIT 'MACRO () NOPROCESS'\n  Address ISPEXEC \"CONTROL ERRORS Return\"\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nrexx_Main_Code:\n  return_code = Initialization_routine()\n  If (return_code = 0) Then Do\n    return_code = Process_routine()\n  End\n  return_code = Termination_routine()\n  Address ISREDIT \"MEND\"\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF edit macro called to do variable\n            replacement in identified members.\n\n  Syntax: Address ISPEXEC \"EDIT DATASET('abc.xyz(mbr)') Macro(MSICREDT)\"\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.01 20170822 \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Added compress if save RC = 12.\n----- -------- --------------------------------------------------------\n01.00 20170729 \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_routine:\n  return_code = 0\n  compress_free = 0\n  Address ISREDIT \"(MYMEM) = MEMBER\"\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_routine:\n  Address ISPEXEC \"TBOpen VDEFTABL NOWRITE SHARE\"\n  tbopen_rc = RC\n  If (tbopen_rc <> 0) Then Do\n    Say \"TBOpen failed, RC(\"tbopen_rc\").\"\n    return tbopen_rc\n  End\n  Address ISPEXEC \"TBSort VDEFTABL Fields(VDEFVAR)\"\n  Do loop = 1 to 2\n    Address ISPEXEC \"TBTop VDEFTABL\"\n    tbskip_rc = 0\n    Do While (tbskip_rc = 0)\n      Address ISPEXEC \"TBSkip VDEFTABL\"\n      tbskip_rc = RC\n      If (tbskip_rc = 0) Then Do\n        vdefval = Strip(vdefval,\"T\",\" \")\n        If (Pos(\"'\",vdefval) > 0) Then Do\n          Address ISREDIT 'c \"!'vdefvar'!\" \"&vdefval\" all'\n          isredit_rc = RC\n        End\n        Else Do\n          Address ISREDIT \"c '!\"vdefvar\"!' '&vdefval' all\"\n          isredit_rc = RC\n        End\n      End\n    End\n  End\n  Address ISPEXEC \"TBEnd VDEFTABL\"\n\n  Address ISREDIT \"(ischange) = DATA_CHANGED\"\n  If (ischange = \"YES\") Then Do\n    Address ISREDIT \"SAVE\"\n    save_rc = RC\n    If (save_rc = 0) Then Do\n      Address ISREDIT \"End\"\n    End\n    Else Do\n      ADDRESS ISREDIT \"(CURRDSN) = DATASET\"\n      currdsn = \"'\"currdsn\"'\"\n      compress_rc = Compress_CURRDSN()\n      If (compress_rc = 0) Then Do\n        Address ISREDIT \"SAVE\"\n        save_rc = RC\n        If (save_rc = 0) Then Do\n          Address ISREDIT \"End\"\n        End\n        Else Do\n          Address ISREDIT \"Cancel\"\n        End\n      End\n    End\n  End\n  Else Do\n    Address ISREDIT \"CANCEL\"\n  End\n\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_routine:\n  If (compress_free = 1) Then Do\n    Address TSO \"Free File(SYSUT1)\"\n    Address TSO \"Free File(SYSUT2)\"\n    Address TSO \"Free File(SYSPRINT)\"\n    Address TSO \"Free File(SYSIN)\"\n  End\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine runs IEBCOPY to compress the PDS.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nCompress_CURRDSN:\n  compress_free = 1\n  Address TSO \"Alloc File(SYSUT1) DataSet(\"CURRDSN\") OLD REUSE\"\n  sysut1_rc = RC\n  If (sysut1_rc <> 0) Then Do\n    Say \"Sorry, Alloc //SYSUT1    DD DISP=OLD,DSN=\"CURRDSN ,\n      \"failed, RC(\"sysut1_rc\").\"\n    return sysut1_rc\n  End\n  Address TSO \"Alloc File(SYSUT2) DataSet(\"CURRDSN\") OLD REUSE\"\n  sysut2_rc = RC\n  If (sysut2_rc <> 0) Then Do\n    Say \"Sorry, Alloc //SYSUT2    DD DISP=OLD,DSN=\"CURRDSN ,\n      \"failed, RC(\"sysut2_rc\").\"\n    return sysut2_rc\n  End\n  Address TSO \"Alloc File(SYSPRINT) NEW DELETE REUSE\" ,\n    \"TRACKS SPACE(1,1)\" ,\n    \"DSORG(PS) RECFM(F B A) BLKSIZE(0) LRECL(121)\"\n  SYSPRINT_rc = RC\n  If (SYSPRINT_rc <> 0) Then Do\n    Say \"Sorry, Alloc //SYSPRINT  DD DSN=&&temp\" ,\n      \"failed, RC(\"SYSPRINT_rc\").\"\n    return SYSPRINT_rc\n  End\n  Address TSO \"Alloc File(SYSIN) NEW DELETE REUSE\" ,\n    \"TRACKS SPACE(1,1)\" ,\n    \"DSORG(PS) RECFM(F) BLKSIZE(80) LRECL(80)\"\n  SYSIN_rc = RC\n  If (SYSIN_rc <> 0) Then Do\n    Say \"Sorry, Alloc //SYSIN     DD DSN=&&temp\" ,\n      \"failed, RC(\"SYSIN_rc\").\"\n    return SYSIN_rc\n  End\n  Address TSO \"MAKEBUF\"\n  Queue \" COPY OUTDD=SYSUT2,INDD=SYSUT1\"\n  Address MVS \"EXECIO\" queued() \"DISKW SYSIN (Finis)\"\n  Address TSO \"DROPBUF\"\n  Call   On ERROR    Name ERROR_HANDLER_ROUTINE\n  Call   On FAILURE  Name ERROR_HANDLER_ROUTINE\n  address LINKMVS \"IEBCOPY\"\n  iebcopy_rc = RC\ngood_004:\n  Call   Off ERROR\n  Call   Off FAILURE\n  /*\n  Address MVS \"ExecIO * DISKR SYSPRINT (Stem iebc. Finis)\"\n  Say \"SYSPRINT has\" iebc.0 \"record(s).\"\n  ix = iebc.0\n  Say Left(iebc.ix,79)\n  */\n/*  IEB147I END OF JOB - 0 WAS HIGHEST SEVERITY CODE */\n  return iebcopy_rc\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine handles several conditions and returns after the fault.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nERROR_HANDLER_ROUTINE:\n  err_rc   = RC\n  signal_type = Condition(\"C\")\n  error_code = -1\n  Select\n    When (signal_type = \"ERROR\") Then error_code = 8\n    When (signal_type = \"FAILURE\") Then error_code = 12\n    When (signal_type = \"HALT\") Then error_code = 16\n    When (signal_type = \"NOVALUE\") Then error_code = 2\n    When (signal_type = \"SYNTAX\") Then error_code = 4\n    Otherwise error_code = 20\n  End\n  result = err_rc\n  Signal Value signal_type\"_\"come_back\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECVASMC": {"ttr": 2835, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00#\\x01\\x18\\x08\\x1f\\x01\\x18\\x14?\\x10Y\\x00y\\x00u\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-03-22T00:00:00", "modifydate": "2018-05-23T10:59:23", "lines": 121, "newlines": 117, "modlines": 0, "user": "KTOMIAK"}, "text": "/* rexx */\nRexx_RECVASMC:\n  rexxpgm_version = \"01.01\"           /* ver lev */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn vdef_taskitem ,\n    vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nRexx_Main_Code:\n  return_code = Initialization_Routine()\n  IF (return_code = 0) THEN DO\n    return_code = Process_Routine()\n  END\n  return_code = Termination_Routine()\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to load a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.01 20180523 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Stylize using Edit Macro @KTPM:\n                  Kenneth Tomiak Programming Method (KTPM).\n----- -------- --------------------------------------------------------\n01.00 20180322 \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_Routine:\n  return_code = 0\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_Routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists <> 0) THEN DO\n    reason1 = \"WISHLIST data set '\"vdef_wishlist\"' does not exist.\"\n    reason2 = \"Acknowledge and then select task 022 before proceeding.\"\n    reason4 = \"\"\n    ADDRESS ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n  END\n  MAKEBUF\n  QUEUE \"DSNAME('\"vdef_wishlist\"')\"\n  QUEUE \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XMAMSC)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XMAMSC)'\" ,\n      \"RC(\"receive_rc\")\"\n    return_code = receive_rc\n  END\n  DROPBUF\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_Routine:\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: PARSE ARG myarg\n  defined_state = SYMBOL(uppercase_letters)\n  IF (defined_state = \"LIT\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  RETURN TRANSLATE(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: PARSE ARG myarg\n  defined_state = SYMBOL(uppercase_letters)\n  IF (defined_state = \"LIT\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  RETURN TRANSLATE(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECVCRDG": {"ttr": 3075, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x008\\x01\\x18\\x03\\x9f\\x01\\x18\\x14?\\x10X\\x00y\\x00u\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-02-08T00:00:00", "modifydate": "2018-05-23T10:58:38", "lines": 121, "newlines": 117, "modlines": 0, "user": "KTOMIAK"}, "text": "/* rexx */\nRexx_RECVCRDG:\n  rexxpgm_version = \"01.01\"           /* ver lev */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn vdef_taskitem ,\n    vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nRexx_Main_Code:\n  return_code = Initialization_Routine()\n  IF (return_code = 0) THEN DO\n    return_code = Process_Routine()\n  END\n  return_code = Termination_Routine()\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to load a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.01 20180523 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Stylize using Edit Macro @KTPM:\n                  Kenneth Tomiak Programming Method (KTPM).\n----- -------- --------------------------------------------------------\n01.00 20180208 \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_Routine:\n  return_code = 0\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_Routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists <> 0) THEN DO\n    reason1 = \"WISHLIST data set '\"vdef_wishlist\"' does not exist.\"\n    reason2 = \"Acknowledge and then select task 022 before proceeding.\"\n    reason4 = \"\"\n    ADDRESS ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n  END\n  MAKEBUF\n  QUEUE \"DSNAME('\"vdef_wishlist\"')\"\n  QUEUE \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XMCRDG)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XMCRDG)'\" ,\n      \"RC(\"receive_rc\")\"\n    return_code = receive_rc\n  END\n  DROPBUF\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_Routine:\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: PARSE ARG myarg\n  defined_state = SYMBOL(uppercase_letters)\n  IF (defined_state = \"LIT\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  RETURN TRANSLATE(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: PARSE ARG myarg\n  defined_state = SYMBOL(uppercase_letters)\n  IF (defined_state = \"LIT\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  RETURN TRANSLATE(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECVDASM": {"ttr": 3078, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00H\\x01\\x18\\x02\\x8f\\x01\\x18\\x14?\\x10Y\\x00y\\x00v\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-01-28T00:00:00", "modifydate": "2018-05-23T10:59:48", "lines": 121, "newlines": 118, "modlines": 0, "user": "KTOMIAK"}, "text": "/* rexx */\nRexx_RECVDASM:\n  rexxpgm_version = \"01.01\"           /* ver lev */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn vdef_taskitem ,\n    vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nRexx_Main_Code:\n  return_code = Initialization_Routine()\n  IF (return_code = 0) THEN DO\n    return_code = Process_Routine()\n  END\n  return_code = Termination_Routine()\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to load a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.01 20180523 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Stylize using Edit Macro @KTPM:\n                  Kenneth Tomiak Programming Method (KTPM).\n----- -------- --------------------------------------------------------\n01.00 20180122 \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_Routine:\n  return_code = 0\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_Routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists <> 0) THEN DO\n    reason1 = \"WISHLIST data set '\"vdef_wishlist\"' does not exist.\"\n    reason2 = \"Acknowledge and then select task 022 before proceeding.\"\n    reason4 = \"\"\n    ADDRESS ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n  END\n  MAKEBUF\n  QUEUE \"DSNAME('\"vdef_wishlist\"')\"\n  QUEUE \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XMDASM)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XMDASM)'\" ,\n      \"RC(\"receive_rc\")\"\n    return_code = receive_rc\n  END\n  DROPBUF\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_Routine:\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: PARSE ARG myarg\n  defined_state = SYMBOL(uppercase_letters)\n  IF (defined_state = \"LIT\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  RETURN TRANSLATE(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: PARSE ARG myarg\n  defined_state = SYMBOL(uppercase_letters)\n  IF (defined_state = \"LIT\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  RETURN TRANSLATE(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECVDFPU": {"ttr": 3081, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00V\\x01\\x18\\x02\\x8f\\x01\\x18\\x14?\\x10Y\\x00y\\x00v\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-01-28T00:00:00", "modifydate": "2018-05-23T10:59:56", "lines": 121, "newlines": 118, "modlines": 0, "user": "KTOMIAK"}, "text": "/* rexx */\nRexx_RECVDFPU:\n  rexxpgm_version = \"01.01\"           /* ver lev */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn vdef_taskitem ,\n    vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nRexx_Main_Code:\n  return_code = Initialization_Routine()\n  IF (return_code = 0) THEN DO\n    return_code = Process_Routine()\n  END\n  return_code = Termination_Routine()\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to load a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.01 20180523 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Stylize using Edit Macro @KTPM:\n                  Kenneth Tomiak Programming Method (KTPM).\n----- -------- --------------------------------------------------------\n01.00 20180122 \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_Routine:\n  return_code = 0\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_Routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists <> 0) THEN DO\n    reason1 = \"WISHLIST data set '\"vdef_wishlist\"' does not exist.\"\n    reason2 = \"Acknowledge and then select task 022 before proceeding.\"\n    reason4 = \"\"\n    ADDRESS ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n  END\n  MAKEBUF\n  QUEUE \"DSNAME('\"vdef_wishlist\"')\"\n  QUEUE \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XMDFPU)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XMDFPU)'\" ,\n      \"RC(\"receive_rc\")\"\n    return_code = receive_rc\n  END\n  DROPBUF\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_Routine:\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: PARSE ARG myarg\n  defined_state = SYMBOL(uppercase_letters)\n  IF (defined_state = \"LIT\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  RETURN TRANSLATE(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: PARSE ARG myarg\n  defined_state = SYMBOL(uppercase_letters)\n  IF (defined_state = \"LIT\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  RETURN TRANSLATE(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECVISPG": {"ttr": 3084, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x18\\x14?\\x01\\x18\\x14?\\x10W\\x00y\\x00y\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-23T00:00:00", "modifydate": "2018-05-23T10:57:57", "lines": 121, "newlines": 121, "modlines": 0, "user": "KTOMIAK"}, "text": "/* rexx */\nRexx_RECVISPG:\n  rexxpgm_version = \"01.01\"           /* ver lev */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn vdef_taskitem ,\n    vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nRexx_Main_Code:\n  return_code = Initialization_Routine()\n  IF (return_code = 0) THEN DO\n    return_code = Process_Routine()\n  END\n  return_code = Termination_Routine()\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to load a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.01 20180523 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Stylize using Edit Macro @KTPM:\n                  Kenneth Tomiak Programming Method (KTPM).\n----- -------- --------------------------------------------------------\n01.00 20180513 \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_Routine:\n  return_code = 0\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_Routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists <> 0) THEN DO\n    reason1 = \"WISHLIST data set '\"vdef_wishlist\"' does not exist.\"\n    reason2 = \"Acknowledge and then select task 022 before proceeding.\"\n    reason4 = \"\"\n    ADDRESS ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n  END\n  MAKEBUF\n  QUEUE \"DSNAME('\"vdef_wishlist\"')\"\n  QUEUE \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XMISPG)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XMISPG)'\" ,\n      \"RC(\"receive_rc\")\"\n    return_code = receive_rc\n  END\n  DROPBUF\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_Routine:\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: PARSE ARG myarg\n  defined_state = SYMBOL(uppercase_letters)\n  IF (defined_state = \"LIT\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  RETURN TRANSLATE(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: PARSE ARG myarg\n  defined_state = SYMBOL(uppercase_letters)\n  IF (defined_state = \"LIT\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  RETURN TRANSLATE(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECVISRE": {"ttr": 3329, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x14\\x01\\x18\\x13?\\x01\\x18\\x14?\\x11\\x00\\x00y\\x00u\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-13T00:00:00", "modifydate": "2018-05-23T11:00:14", "lines": 121, "newlines": 117, "modlines": 0, "user": "KTOMIAK"}, "text": "/* rexx */\nRexx_RECVISRE:\n  rexxpgm_version = \"01.01\"           /* ver lev */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn vdef_taskitem ,\n    vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nRexx_Main_Code:\n  return_code = Initialization_Routine()\n  IF (return_code = 0) THEN DO\n    return_code = Process_Routine()\n  END\n  return_code = Termination_Routine()\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to load a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.01 20180523 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Stylize using Edit Macro @KTPM:\n                  Kenneth Tomiak Programming Method (KTPM).\n----- -------- --------------------------------------------------------\n01.00 20180513 \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_Routine:\n  return_code = 0\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_Routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists <> 0) THEN DO\n    reason1 = \"WISHLIST data set '\"vdef_wishlist\"' does not exist.\"\n    reason2 = \"Acknowledge and then select task 022 before proceeding.\"\n    reason4 = \"\"\n    ADDRESS ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n  END\n  MAKEBUF\n  QUEUE \"DSNAME('\"vdef_wishlist\"')\"\n  QUEUE \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XMISRE)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XMISRE)'\" ,\n      \"RC(\"receive_rc\")\"\n    return_code = receive_rc\n  END\n  DROPBUF\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_Routine:\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: PARSE ARG myarg\n  defined_state = SYMBOL(uppercase_letters)\n  IF (defined_state = \"LIT\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  RETURN TRANSLATE(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: PARSE ARG myarg\n  defined_state = SYMBOL(uppercase_letters)\n  IF (defined_state = \"LIT\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  RETURN TRANSLATE(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECVJCLR": {"ttr": 3332, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x14\\x01\\x18\\x02\\x8f\\x01\\x18\\x14?\\x11\\x03\\x00y\\x00v\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-01-28T00:00:00", "modifydate": "2018-05-23T11:03:14", "lines": 121, "newlines": 118, "modlines": 0, "user": "KTOMIAK"}, "text": "/* rexx */\nRexx_RECVJCLR:\n  rexxpgm_version = \"01.01\"           /* ver lev */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn vdef_taskitem ,\n    vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nRexx_Main_Code:\n  return_code = Initialization_Routine()\n  IF (return_code = 0) THEN DO\n    return_code = Process_Routine()\n  END\n  return_code = Termination_Routine()\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to load a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.01 20180523 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Stylize using Edit Macro @KTPM:\n                  Kenneth Tomiak Programming Method (KTPM).\n----- -------- --------------------------------------------------------\n01.00 20180122 \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_Routine:\n  return_code = 0\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_Routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists <> 0) THEN DO\n    reason1 = \"WISHLIST data set '\"vdef_wishlist\"' does not exist.\"\n    reason2 = \"Acknowledge and then select task 022 before proceeding.\"\n    reason4 = \"\"\n    ADDRESS ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n  END\n  MAKEBUF\n  QUEUE \"DSNAME('\"vdef_wishlist\"')\"\n  QUEUE \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XMJCLR)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XMJCLR)'\" ,\n      \"RC(\"receive_rc\")\"\n    return_code = receive_rc\n  END\n  DROPBUF\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_Routine:\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: PARSE ARG myarg\n  defined_state = SYMBOL(uppercase_letters)\n  IF (defined_state = \"LIT\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  RETURN TRANSLATE(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: PARSE ARG myarg\n  defined_state = SYMBOL(uppercase_letters)\n  IF (defined_state = \"LIT\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  RETURN TRANSLATE(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECVJOBC": {"ttr": 3335, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00F\\x01\\x18\\x14?\\x01\\x18\\x14?\\x11\\x03\\x00y\\x00u\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-23T00:00:00", "modifydate": "2018-05-23T11:03:46", "lines": 121, "newlines": 117, "modlines": 0, "user": "KTOMIAK"}, "text": "/* rexx */\nRexx_RECVJOBC:\n  rexxpgm_version = \"01.01\"           /* ver lev */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn vdef_taskitem ,\n    vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nRexx_Main_Code:\n  return_code = Initialization_Routine()\n  IF (return_code = 0) THEN DO\n    return_code = Process_Routine()\n  END\n  return_code = Termination_Routine()\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to load a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.01 20180523 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Stylize using Edit Macro @KTPM:\n                  Kenneth Tomiak Programming Method (KTPM).\n----- -------- --------------------------------------------------------\n01.00 20180122 \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_Routine:\n  return_code = 0\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_Routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists <> 0) THEN DO\n    reason1 = \"WISHLIST data set '\"vdef_wishlist\"' does not exist.\"\n    reason2 = \"Acknowledge and then select task 022 before proceeding.\"\n    reason4 = \"\"\n    ADDRESS ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n  END\n  MAKEBUF\n  QUEUE \"DSNAME('\"vdef_wishlist\"')\"\n  QUEUE \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XMJOBC)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XMJOBC)'\" ,\n      \"RC(\"receive_rc\")\"\n    return_code = receive_rc\n  END\n  DROPBUF\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_Routine:\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: PARSE ARG myarg\n  defined_state = SYMBOL(uppercase_letters)\n  IF (defined_state = \"LIT\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  RETURN TRANSLATE(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: PARSE ARG myarg\n  defined_state = SYMBOL(uppercase_letters)\n  IF (defined_state = \"LIT\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  RETURN TRANSLATE(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECVKTPM": {"ttr": 3338, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x007\\x01\\x18\\x14?\\x01\\x18\\x14?\\x11\\x04\\x00z\\x00v\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-23T00:00:00", "modifydate": "2018-05-23T11:04:37", "lines": 122, "newlines": 118, "modlines": 0, "user": "KTOMIAK"}, "text": "/* rexx */\nRexx_RECVKTPM:\n  rexxpgm_version = \"01.01\"           /* ver lev */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn vdef_taskitem ,\n    vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nRexx_Main_Code:\n  return_code = Initialization_Routine()\n  IF (return_code = 0) THEN DO\n    return_code = Process_Routine()\n  END\n  return_code = Termination_Routine()\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to load a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.01 20180523 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Stylize using Edit Macro @KTPM:\n                  Kenneth Tomiak Programming Method (KTPM).\n----- -------- --------------------------------------------------------\n01.00 20180122 \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_Routine:\n  return_code = 0\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_Routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists <> 0) THEN DO\n    reason1 = \"WISHLIST data set '\"vdef_wishlist\"' does not exist.\"\n    reason2 = \"Acknowledge and then select task 022 before proceeding.\"\n    reason4 = \"\"\n    ADDRESS ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n  END\n  MAKEBUF\n  QUEUE \"DSNAME('\"vdef_wishlist\"')\"\n  QUEUE \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XMKTPM)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XMKTPM)'\" ,\n      \"RC(\"receive_rc\")\"\n    return_code = receive_rc\n  END\n  DROPBUF\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_Routine:\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: PARSE ARG myarg\n  defined_state = SYMBOL(uppercase_letters)\n  IF (defined_state = \"LIT\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  RETURN TRANSLATE(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: PARSE ARG myarg\n  defined_state = SYMBOL(uppercase_letters)\n  IF (defined_state = \"LIT\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  RETURN TRANSLATE(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECVMITR": {"ttr": 3341, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x01\\x01\\x18\\x02\\x8f\\x01\\x18\\x14?\\x11\\x05\\x00y\\x00v\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-01-28T00:00:00", "modifydate": "2018-05-23T11:05:01", "lines": 121, "newlines": 118, "modlines": 0, "user": "KTOMIAK"}, "text": "/* rexx */\nRexx_RECVMITR:\n  rexxpgm_version = \"01.01\"           /* ver lev */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn vdef_taskitem ,\n    vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nRexx_Main_Code:\n  return_code = Initialization_Routine()\n  IF (return_code = 0) THEN DO\n    return_code = Process_Routine()\n  END\n  return_code = Termination_Routine()\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to load a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.01 20180523 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Stylize using Edit Macro @KTPM:\n                  Kenneth Tomiak Programming Method (KTPM).\n----- -------- --------------------------------------------------------\n01.00 20180122 \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_Routine:\n  return_code = 0\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_Routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists <> 0) THEN DO\n    reason1 = \"WISHLIST data set '\"vdef_wishlist\"' does not exist.\"\n    reason2 = \"Acknowledge and then select task 022 before proceeding.\"\n    reason4 = \"\"\n    ADDRESS ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n  END\n  MAKEBUF\n  QUEUE \"DSNAME('\"vdef_wishlist\"')\"\n  QUEUE \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XMMITR)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XMMITR)'\" ,\n      \"RC(\"receive_rc\")\"\n    return_code = receive_rc\n  END\n  DROPBUF\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_Routine:\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: PARSE ARG myarg\n  defined_state = SYMBOL(uppercase_letters)\n  IF (defined_state = \"LIT\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  RETURN TRANSLATE(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: PARSE ARG myarg\n  defined_state = SYMBOL(uppercase_letters)\n  IF (defined_state = \"LIT\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  RETURN TRANSLATE(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECVPMAU": {"ttr": 3587, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00!\\x01\\x18\\x02\\x8f\\x01\\x18\\x14?\\x11\\x05\\x00y\\x00v\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-01-28T00:00:00", "modifydate": "2018-05-23T11:05:21", "lines": 121, "newlines": 118, "modlines": 0, "user": "KTOMIAK"}, "text": "/* rexx */\nRexx_RECVPMAU:\n  rexxpgm_version = \"01.01\"           /* ver lev */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn vdef_taskitem ,\n    vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nRexx_Main_Code:\n  return_code = Initialization_Routine()\n  IF (return_code = 0) THEN DO\n    return_code = Process_Routine()\n  END\n  return_code = Termination_Routine()\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to load a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.01 20180523 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Stylize using Edit Macro @KTPM:\n                  Kenneth Tomiak Programming Method (KTPM).\n----- -------- --------------------------------------------------------\n01.00 20180122 \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_Routine:\n  return_code = 0\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_Routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists <> 0) THEN DO\n    reason1 = \"WISHLIST data set '\"vdef_wishlist\"' does not exist.\"\n    reason2 = \"Acknowledge and then select task 022 before proceeding.\"\n    reason4 = \"\"\n    ADDRESS ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n  END\n  MAKEBUF\n  QUEUE \"DSNAME('\"vdef_wishlist\"')\"\n  QUEUE \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XMPMAU)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XMPMAU)'\" ,\n      \"RC(\"receive_rc\")\"\n    return_code = receive_rc\n  END\n  DROPBUF\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_Routine:\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: PARSE ARG myarg\n  defined_state = SYMBOL(uppercase_letters)\n  IF (defined_state = \"LIT\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  RETURN TRANSLATE(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: PARSE ARG myarg\n  defined_state = SYMBOL(uppercase_letters)\n  IF (defined_state = \"LIT\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  RETURN TRANSLATE(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECVPSFC": {"ttr": 3590, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x18\\x02\\x8f\\x01\\x18\\x14?\\x11\\x05\\x00y\\x00v\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-01-28T00:00:00", "modifydate": "2018-05-23T11:05:31", "lines": 121, "newlines": 118, "modlines": 0, "user": "KTOMIAK"}, "text": "/* rexx */\nRexx_RECVPSFC:\n  rexxpgm_version = \"01.01\"           /* ver lev */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn vdef_taskitem ,\n    vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nRexx_Main_Code:\n  return_code = Initialization_Routine()\n  IF (return_code = 0) THEN DO\n    return_code = Process_Routine()\n  END\n  return_code = Termination_Routine()\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to load a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.01 20180523 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Stylize using Edit Macro @KTPM:\n                  Kenneth Tomiak Programming Method (KTPM).\n----- -------- --------------------------------------------------------\n01.00 20180122 \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_Routine:\n  return_code = 0\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_Routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists <> 0) THEN DO\n    reason1 = \"WISHLIST data set '\"vdef_wishlist\"' does not exist.\"\n    reason2 = \"Acknowledge and then select task 022 before proceeding.\"\n    reason4 = \"\"\n    ADDRESS ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n  END\n  MAKEBUF\n  QUEUE \"DSNAME('\"vdef_wishlist\"')\"\n  QUEUE \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XMPSFC)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XMPSFC)'\" ,\n      \"RC(\"receive_rc\")\"\n    return_code = receive_rc\n  END\n  DROPBUF\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_Routine:\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: PARSE ARG myarg\n  defined_state = SYMBOL(uppercase_letters)\n  IF (defined_state = \"LIT\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  RETURN TRANSLATE(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: PARSE ARG myarg\n  defined_state = SYMBOL(uppercase_letters)\n  IF (defined_state = \"LIT\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  RETURN TRANSLATE(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECVREXR": {"ttr": 3593, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00C\\x01\\x18\\x02\\x8f\\x01\\x18\\x14?\\x11\\x05\\x00y\\x00v\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-01-28T00:00:00", "modifydate": "2018-05-23T11:05:43", "lines": 121, "newlines": 118, "modlines": 0, "user": "KTOMIAK"}, "text": "/* rexx */\nRexx_RECVREXR:\n  rexxpgm_version = \"01.01\"           /* ver lev */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn vdef_taskitem ,\n    vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nRexx_Main_Code:\n  return_code = Initialization_Routine()\n  IF (return_code = 0) THEN DO\n    return_code = Process_Routine()\n  END\n  return_code = Termination_Routine()\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to load a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.01 20180523 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Stylize using Edit Macro @KTPM:\n                  Kenneth Tomiak Programming Method (KTPM).\n----- -------- --------------------------------------------------------\n01.00 20180122 \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_Routine:\n  return_code = 0\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_Routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists <> 0) THEN DO\n    reason1 = \"WISHLIST data set '\"vdef_wishlist\"' does not exist.\"\n    reason2 = \"Acknowledge and then select task 022 before proceeding.\"\n    reason4 = \"\"\n    ADDRESS ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n  END\n  MAKEBUF\n  QUEUE \"DSNAME('\"vdef_wishlist\"')\"\n  QUEUE \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XMREXR)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XMREXR)'\" ,\n      \"RC(\"receive_rc\")\"\n    return_code = receive_rc\n  END\n  DROPBUF\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_Routine:\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: PARSE ARG myarg\n  defined_state = SYMBOL(uppercase_letters)\n  IF (defined_state = \"LIT\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  RETURN TRANSLATE(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: PARSE ARG myarg\n  defined_state = SYMBOL(uppercase_letters)\n  IF (defined_state = \"LIT\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  RETURN TRANSLATE(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECVRXCP": {"ttr": 3596, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00U\\x01\\x18\\x02\\x8f\\x01\\x18\\x14?\\x11\\x05\\x00y\\x00v\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-01-28T00:00:00", "modifydate": "2018-05-23T11:05:55", "lines": 121, "newlines": 118, "modlines": 0, "user": "KTOMIAK"}, "text": "/* rexx */\nRexx_RECVRXCP:\n  rexxpgm_version = \"01.01\"           /* ver lev */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn vdef_taskitem ,\n    vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nRexx_Main_Code:\n  return_code = Initialization_Routine()\n  IF (return_code = 0) THEN DO\n    return_code = Process_Routine()\n  END\n  return_code = Termination_Routine()\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to load a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.01 20180523 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Stylize using Edit Macro @KTPM:\n                  Kenneth Tomiak Programming Method (KTPM).\n----- -------- --------------------------------------------------------\n01.00 20180122 \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_Routine:\n  return_code = 0\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_Routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists <> 0) THEN DO\n    reason1 = \"WISHLIST data set '\"vdef_wishlist\"' does not exist.\"\n    reason2 = \"Acknowledge and then select task 022 before proceeding.\"\n    reason4 = \"\"\n    ADDRESS ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n  END\n  MAKEBUF\n  QUEUE \"DSNAME('\"vdef_wishlist\"')\"\n  QUEUE \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XMRXCP)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XMRXCP)'\" ,\n      \"RC(\"receive_rc\")\"\n    return_code = receive_rc\n  END\n  DROPBUF\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_Routine:\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: PARSE ARG myarg\n  defined_state = SYMBOL(uppercase_letters)\n  IF (defined_state = \"LIT\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  RETURN TRANSLATE(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: PARSE ARG myarg\n  defined_state = SYMBOL(uppercase_letters)\n  IF (defined_state = \"LIT\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  RETURN TRANSLATE(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECVRXCU": {"ttr": 3841, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x07\\x01\\x18\\x13?\\x01\\x18\\x14?\\x11\\x06\\x00y\\x00u\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-13T00:00:00", "modifydate": "2018-05-23T11:06:07", "lines": 121, "newlines": 117, "modlines": 0, "user": "KTOMIAK"}, "text": "/* rexx */\nRexx_RECVRXCU:\n  rexxpgm_version = \"01.01\"           /* ver lev */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn vdef_taskitem ,\n    vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nRexx_Main_Code:\n  return_code = Initialization_Routine()\n  IF (return_code = 0) THEN DO\n    return_code = Process_Routine()\n  END\n  return_code = Termination_Routine()\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to load a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.01 20180523 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Stylize using Edit Macro @KTPM:\n                  Kenneth Tomiak Programming Method (KTPM).\n----- -------- --------------------------------------------------------\n01.00 20180122 \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_Routine:\n  return_code = 0\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_Routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists <> 0) THEN DO\n    reason1 = \"WISHLIST data set '\"vdef_wishlist\"' does not exist.\"\n    reason2 = \"Acknowledge and then select task 022 before proceeding.\"\n    reason4 = \"\"\n    ADDRESS ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n  END\n  MAKEBUF\n  QUEUE \"DSNAME('\"vdef_wishlist\"')\"\n  QUEUE \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XMRXCU)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XMRXCU)'\" ,\n      \"RC(\"receive_rc\")\"\n    return_code = receive_rc\n  END\n  DROPBUF\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_Routine:\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: PARSE ARG myarg\n  defined_state = SYMBOL(uppercase_letters)\n  IF (defined_state = \"LIT\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  RETURN TRANSLATE(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: PARSE ARG myarg\n  defined_state = SYMBOL(uppercase_letters)\n  IF (defined_state = \"LIT\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  RETURN TRANSLATE(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECVTSAD": {"ttr": 3844, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x19\\x01\\x18\\x02\\x8f\\x01\\x18\\x14?\\x11\\x06\\x00y\\x00v\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-01-28T00:00:00", "modifydate": "2018-05-23T11:06:19", "lines": 121, "newlines": 118, "modlines": 0, "user": "KTOMIAK"}, "text": "/* rexx */\nRexx_RECVTSAD:\n  rexxpgm_version = \"01.01\"           /* ver lev */\n\n  PARSE ARG vdef_wishlist vdef_hostdsn vdef_taskitem ,\n    vdef_volser vdef_unit\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nRexx_Main_Code:\n  return_code = Initialization_Routine()\n  IF (return_code = 0) THEN DO\n    return_code = Process_Routine()\n  END\n  return_code = Termination_Routine()\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to load a\n            WISHLIST data set.\n\n  Syntax:   Called from #INSTALL.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.01 20180523 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Stylize using Edit Macro @KTPM:\n                  Kenneth Tomiak Programming Method (KTPM).\n----- -------- --------------------------------------------------------\n01.00 20180122 \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_Routine:\n  return_code = 0\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_Routine:\n  wishlist_exists = LISTDSI(\"'\"vdef_wishlist\"'\")\n  IF (wishlist_exists <> 0) THEN DO\n    reason1 = \"WISHLIST data set '\"vdef_wishlist\"' does not exist.\"\n    reason2 = \"Acknowledge and then select task 022 before proceeding.\"\n    reason4 = \"\"\n    ADDRESS ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n    function_rc = RC\n  END\n  MAKEBUF\n  QUEUE \"DSNAME('\"vdef_wishlist\"')\"\n  QUEUE \"END\"\n  vdef_hostdsn = STRIP(vdef_hostdsn,\"B\",\" \")\n  prompt_state = PROMPT(\"ON\")\n  \"RECEIVE INDA('\"vdef_hostdsn\"(XMTSAD)')\"\n  receive_rc = RC\n  prompt_state = PROMPT(prompt_state)\n  IF (receive_rc <> 0) THEN DO\n    SAY \"Trouble with RECEIVE '\"vdef_hostdsn\"(XMTSAD)'\" ,\n      \"RC(\"receive_rc\")\"\n    return_code = receive_rc\n  END\n  DROPBUF\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_Routine:\n  RETURN return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: PARSE ARG myarg\n  defined_state = SYMBOL(uppercase_letters)\n  IF (defined_state = \"LIT\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  RETURN TRANSLATE(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: PARSE ARG myarg\n  defined_state = SYMBOL(uppercase_letters)\n  IF (defined_state = \"LIT\") THEN DO\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  END\n  RETURN TRANSLATE(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XM$$$$": {"ttr": 3847, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00@\\x01\\x180\\x8f\\x01\\x180\\x8f\\x16\\x11\\r\\xbb\\r\\xbb\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-11-04T00:00:00", "modifydate": "2018-11-04T16:11:40", "lines": 3515, "newlines": 3515, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMAMSC": {"ttr": 5379, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00@\\x01\\x180\\x8f\\x01\\x180\\x8f\\x16\\x11elel\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-11-04T00:00:00", "modifydate": "2018-11-04T16:11:40", "lines": 25964, "newlines": 25964, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMCRDG": {"ttr": 15877, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00@\\x01\\x180\\x8f\\x01\\x180\\x8f\\x16\\x11D\\xb6D\\xb6\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-11-04T00:00:00", "modifydate": "2018-11-04T16:11:40", "lines": 17590, "newlines": 17590, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMDASM": {"ttr": 23045, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00@\\x01\\x180\\x8f\\x01\\x180\\x8f\\x16\\x11\\x02'\\x02'\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-11-04T00:00:00", "modifydate": "2018-11-04T16:11:40", "lines": 551, "newlines": 551, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMDFPU": {"ttr": 23300, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00@\\x01\\x180\\x8f\\x01\\x180\\x8f\\x16\\x11 \\xbf \\xbf\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-11-04T00:00:00", "modifydate": "2018-11-04T16:11:40", "lines": 8383, "newlines": 8383, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMISPG": {"ttr": 26631, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00@\\x01\\x180\\x8f\\x01\\x180\\x8f\\x16\\x11\\x14\\xab\\x14\\xab\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-11-04T00:00:00", "modifydate": "2018-11-04T16:11:40", "lines": 5291, "newlines": 5291, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMISRE": {"ttr": 28929, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00@\\x01\\x180\\x8f\\x01\\x180\\x8f\\x16\\x11\\x00\\x83\\x00\\x83\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-11-04T00:00:00", "modifydate": "2018-11-04T16:11:40", "lines": 131, "newlines": 131, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMJCLR": {"ttr": 28932, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00@\\x01\\x180\\x8f\\x01\\x180\\x8f\\x16\\x11@\\xa4@\\xa4\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-11-04T00:00:00", "modifydate": "2018-11-04T16:11:40", "lines": 16548, "newlines": 16548, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMJOBC": {"ttr": 35591, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00@\\x01\\x180\\x8f\\x01\\x180\\x8f\\x16\\x11\\x00\\xd1\\x00\\xd1\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-11-04T00:00:00", "modifydate": "2018-11-04T16:11:40", "lines": 209, "newlines": 209, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMKTPM": {"ttr": 35595, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00@\\x01\\x180\\x8f\\x01\\x180\\x8f\\x16\\x11\\x04\\xde\\x04\\xde\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-11-04T00:00:00", "modifydate": "2018-11-04T16:11:40", "lines": 1246, "newlines": 1246, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMMITR": {"ttr": 36106, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00@\\x01\\x180\\x8f\\x01\\x180\\x8f\\x16\\x11\\x00\\xc0\\x00\\xc0\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-11-04T00:00:00", "modifydate": "2018-11-04T16:11:40", "lines": 192, "newlines": 192, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMPMAU": {"ttr": 36356, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00@\\x01\\x180\\x8f\\x01\\x180\\x8f\\x16\\x11\\x04\\r\\x04\\r\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-11-04T00:00:00", "modifydate": "2018-11-04T16:11:40", "lines": 1037, "newlines": 1037, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMPSFC": {"ttr": 36618, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00@\\x01\\x180\\x8f\\x01\\x180\\x8f\\x16\\x11\\x04\\xe0\\x04\\xe0\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-11-04T00:00:00", "modifydate": "2018-11-04T16:11:40", "lines": 1248, "newlines": 1248, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMREXR": {"ttr": 37130, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00@\\x01\\x180\\x8f\\x01\\x180\\x8f\\x16\\x114343\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-11-04T00:00:00", "modifydate": "2018-11-04T16:11:40", "lines": 13363, "newlines": 13363, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMRXCP": {"ttr": 42755, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00@\\x01\\x180\\x8f\\x01\\x180\\x8f\\x16\\x11\\x04Y\\x04Y\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-11-04T00:00:00", "modifydate": "2018-11-04T16:11:40", "lines": 1113, "newlines": 1113, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMRXCU": {"ttr": 43018, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00@\\x01\\x180\\x8f\\x01\\x180\\x8f\\x16\\x11\\x00\\xd9\\x00\\xd9\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-11-04T00:00:00", "modifydate": "2018-11-04T16:11:40", "lines": 217, "newlines": 217, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMTSAD": {"ttr": 43269, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00@\\x01\\x180\\x8f\\x01\\x180\\x8f\\x16\\x11 \\xc2 \\xc2\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-11-04T00:00:00", "modifydate": "2018-11-04T16:11:40", "lines": 8386, "newlines": 8386, "modlines": 0, "user": "KTOMIAK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT978/FILE978.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT978", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}