{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012211000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 352716, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE493.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 352716, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 352716, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE493.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x07\\x03'", "DS1TRBAL": "b'\\xb3\\xf6'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03\\xc8\\x00\\x04\\x03\\xc8\\x00\\x0b\\x00\\x08'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x02O\\x01\\x01\\x02O\\x17@\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xc8\\xc9\\xd7\\xc4\\xc1\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-24T00:00:00", "modifydate": "2001-01-24T17:40:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SHIPDAT"}, "text": "REGULAR CBT TAPE - VERSION 432    FILE:  493\n\n    ORIGINAL DSNAME:  WSBG.CBT432.FILE493\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    27920   PO\n\n\n   10 MEMBERS COUNTED; CUMULATIVE SIZE IS 3,072 RECORDS\n\nTIME THIS PDS WAS SHIPPED:   01/24/01    17:40:28    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$INDEX": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x01\\x00?\\x01\\x01\\x00?\\x15!\\x00\\x04\\x00\\x04\\x00\\x00\\xd1\\xc3\\xd6\\xd5\\xd5@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2001-01-03T00:00:00", "modifydate": "2001-01-03T15:21:00", "lines": 4, "newlines": 4, "modlines": 0, "user": "JCONN"}, "text": "CRCPAPER    A PAINLESS GUIDE TO CRC ERROR DETECTION ALGORITHMS\nCRC32       A SAMPLE PROGRAM IN IBM ASSEMBLER\nC2F         A REXX FUNCTION TO CONVERT TO FLOATING POINT FORMAT\nVC          VSAM CLONE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#ERICD": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x01\\x00O\\x01\\x01\\x00O\\x11@\\x00\\x19\\x00\\x18\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2001-01-04T00:00:00", "modifydate": "2001-01-04T11:40:00", "lines": 25, "newlines": 24, "modlines": 0, "user": "WSBG"}, "text": "Golob, Sam\nFrom:\tEric Durbin <ericd@kcr.uky.edu>\nSent:\tThursday, January 04, 2001 10:38 AM\nTo:\tsbgolob@attglobal.net\nSubject:\tRe: CRC Knowledge\nSam,\n\nWhen doing research for a CRC algorithm to implement for the\nNAACCR standard record layout I could only find one well\ndocumented example and this is the one I chose.  I'm sure there\nmay be different CRC checksum implementations used with ethernet\nand other applications.  For more information on the Rocksoft(tm)\nModel CRC Algorithm (the one I chose) see the document titled \"A\nPainless Guide to CRC Error Detection Algorithms\" by Ross\nWilliams (ross@guest.adelaide.edu.au.).  This document is likely\nto be in the FTP archive:\n\nftp://ftp.adelaide.edu.au/pub/rocksoft .\n\n  (Note:  We have it here - member CRCPAPER.)\n\nHope this helps.\n\nEric\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE493": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x99\\x08?\\x01\\x01\\x00O\\tC\\x00\\x17\\x00\\x02\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1999-03-24T00:00:00", "modifydate": "2001-01-04T09:43:00", "lines": 23, "newlines": 2, "modlines": 0, "user": "WSBG"}, "text": "//***FILE 493 is from Jim Connelley and contains some handy         *   FILE 493\n//*           routines.  There is also a paper all about CRC        *   FILE 493\n//*           checksum creation, from Ross N. Williams, that        *   FILE 493\n//*           Jim has included here.                                *   FILE 493\n//*                                                                 *   FILE 493\n//*           Jim's \"reverse IDCAMS\" program called VC is worthy    *   FILE 493\n//*           of note.                                              *   FILE 493\n//*                                                                 *   FILE 493\n//*           email:   jim@connelley.org                            *   FILE 493\n//*                                                                 *   FILE 493\n//*    Programs included are:                                       *   FILE 493\n//*                                                                 *   FILE 493\n//*    CRC32      -  An Assembler routine to provide a CRC          *   FILE 493\n//*                  checksum                                       *   FILE 493\n//*                                                                 *   FILE 493\n//*    VC         -  A REXX routine to look at a VSAM cluster       *   FILE 493\n//*                  and generate IDCAMS statements which           *   FILE 493\n//*                  DEFINE it                                      *   FILE 493\n//*                                                                 *   FILE 493\n//*    C2F        -  A REXX routine to convert a number to          *   FILE 493\n//*                  internal float format, display the result,     *   FILE 493\n//*                  and convert the result back to decimal         *   FILE 493\n//*                                                                 *   FILE 493\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CRCPAPER": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00?\\x01\\x01\\x00?\\x14\\x19\\x08\\x16\\x08\\x16\\x00\\x00\\xd1\\xc3\\xd6\\xd5\\xd5@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-03T00:00:00", "modifydate": "2001-01-03T14:19:00", "lines": 2070, "newlines": 2070, "modlines": 0, "user": "JCONN"}, "text": "\nA PAINLESS GUIDE TO CRC ERROR DETECTION ALGORITHMS\n==================================================\n\"Everything you wanted to know about CRC algorithms, but were afraid\nto ask for fear that errors in your understanding might be detected.\"\n\nVersion : 3.\nDate    : 19 August 1993.\nAuthor  : Ross N. Williams.\nNet     : ross@guest.adelaide.edu.au.\nFTP     : ftp.adelaide.edu.au/pub/rocksoft/crc_v3.txt\nCompany : Rocksoft\u00actm Pty Ltd.\nSnail   : 16 Lerwick Avenue, Hazelwood Park 5066, Australia.\nFax     : +61 8 373-4911 (c/- Internode Systems Pty Ltd).\nPhone   : +61 8 379-9217 (10am to 10pm Adelaide Australia time).\nNote    : \"Rocksoft\" is a trademark of Rocksoft Pty Ltd, Australia.\nStatus  : Copyright (C) Ross Williams, 1993. However, permission is\n          granted to make and distribute verbatim copies of this\n          document provided that this information block and copyright\n          notice is included. Also, the C code modules included\n          in this document are fully public domain.\nThanks  : Thanks to Jean-loup Gailly (jloup@chorus.fr) and Mark Adler\n          (me@quest.jpl.nasa.gov) who both proof read this document\n          and picked out lots of nits as well as some big fat bugs.\n\nTable of Contents\n-----------------\n    Abstract\n 1. Introduction: Error Detection\n 2. The Need For Complexity\n 3. The Basic Idea Behind CRC Algorithms\n 4. Polynomical Arithmetic\n 5. Binary Arithmetic with No Carries\n 6. A Fully Worked Example\n 7. Choosing A Poly\n 8. A Straightforward CRC Implementation\n 9. A Table-Driven Implementation\n10. A Slightly Mangled Table-Driven Implementation\n11. \"Reflected\" Table-Driven Implementations\n12. \"Reversed\" Polys\n13. Initial and Final Values\n14. Defining Algorithms Absolutely\n15. A Parameterized Model For CRC Algorithms\n16. A Catalog of Parameter Sets for Standards\n17. An Implementation of the Model Algorithm\n18. Roll Your Own Table-Driven Implementation\n19. Generating A Lookup Table\n20. Summary\n21. Corrections\n A. Glossary\n B. References\n C. References I Have Detected But Haven't Yet Sighted\n\n\nAbstract\n--------\nThis document explains CRCs (Cyclic Redundancy Codes) and their\ntable-driven implementations in full, precise detail. Much of the\nliterature on CRCs, and in particular on their table-driven\nimplementations, is a little obscure (or at least seems so to me).\nThis document is an attempt to provide a clear and simple no-nonsense\nexplanation of CRCs and to absolutely nail down every detail of the\noperation of their high-speed implementations. In addition to this,\nthis document presents a parameterized model CRC algorithm called the\n\"Rocksoft\u00actm Model CRC Algorithm\". The model algorithm can be\nparameterized to behave like most of the CRC implementations around,\nand so acts as a good reference for describing particular algorithms.\nA low-speed implementation of the model CRC algorithm is provided in\nthe C programming language. Lastly there is a section giving two forms\nof high-speed table driven implementations, and providing a program\nthat generates CRC lookup tables.\n\n\n1. Introduction: Error Detection\n--------------------------------\nThe aim of an error detection technique is to enable the receiver of a\nmessage transmitted through a noisy (error-introducing) channel to\ndetermine whether the message has been corrupted. To do this, the\ntransmitter constructs a value (called a checksum) that is a function\nof the message, and appends it to the message. The receiver can then\nuse the same function to calculate the checksum of the received\nmessage and compare it with the appended checksum to see if the\nmessage was correctly received. For example, if we chose a checksum\nfunction which was simply the sum of the bytes in the message mod 256\n(i.e. modulo 256), then it might go something as follows. All numbers\nare in decimal.\n\n   Message                    :  6 23  4\n   Message with checksum      :  6 23  4 33\n   Message after transmission :  6 27  4 33\n\nIn the above, the second byte of the message was corrupted from 23 to\n27 by the communications channel. However, the receiver can detect\nthis by comparing the transmitted checksum (33) with the computer\nchecksum of 37 (6 + 27 + 4). If the checksum itself is corrupted, a\ncorrectly transmitted message might be incorrectly identified as a\ncorrupted one. However, this is a safe-side failure. A dangerous-side\nfailure occurs where the message and/or checksum is corrupted in a\nmanner that results in a transmission that is internally consistent.\nUnfortunately, this possibility is completely unavoidable and the best\nthat can be done is to minimize its probability by increasing the\namount of information in the checksum (e.g. widening the checksum from\none byte to two bytes).\n\nOther error detection techniques exist that involve performing complex\ntransformations on the message to inject it with redundant\ninformation. However, this document addresses only CRC algorithms,\nwhich fall into the class of error detection algorithms that leave the\ndata intact and append a checksum on the end. i.e.:\n\n      <original intact message> <checksum>\n\n\n2. The Need For Complexity\n--------------------------\nIn the checksum example in the previous section, we saw how a\ncorrupted message was detected using a checksum algorithm that simply\nsums the bytes in the message mod 256:\n\n   Message                    :  6 23  4\n   Message with checksum      :  6 23  4 33\n   Message after transmission :  6 27  4 33\n\nA problem with this algorithm is that it is too simple. If a number of\nrandom corruptions occur, there is a 1 in 256 chance that they will\nnot be detected. For example:\n\n   Message                    :  6 23  4\n   Message with checksum      :  6 23  4 33\n   Message after transmission :  8 20  5 33\n\nTo strengthen the checksum, we could change from an 8-bit register to\na 16-bit register (i.e. sum the bytes mod 65536 instead of mod 256) so\nas to apparently reduce the probability of failure from 1/256 to\n1/65536. While basically a good idea, it fails in this case because\nthe formula used is not sufficiently \"random\"; with a simple summing\nformula, each incoming byte affects roughly only one byte of the\nsumming register no matter how wide it is. For example, in the second\nexample above, the summing register could be a Megabyte wide, and the\nerror would still go undetected. This problem can only be solved by\nreplacing the simple summing formula with a more sophisticated formula\nthat causes each incoming byte to have an effect on the entire\nchecksum register.\n\nThus, we see that at least two aspects are required to form a strong\nchecksum function:\n\n   WIDTH: A register width wide enough to provide a low a-priori\n          probability of failure (e.g. 32-bits gives a 1/2\u00ac32 chance\n          of failure).\n\n   CHAOS: A formula that gives each input byte the potential to change\n          any number of bits in the register.\n\nNote: The term \"checksum\" was presumably used to describe early\nsumming formulas, but has now taken on a more general meaning\nencompassing more sophisticated algorithms such as the CRC ones. The\nCRC algorithms to be described satisfy the second condition very well,\nand can be configured to operate with a variety of checksum widths.\n\n\n3. The Basic Idea Behind CRC Algorithms\n---------------------------------------\nWhere might we go in our search for a more complex function than\nsumming? All sorts of schemes spring to mind. We could construct\ntables using the digits of pi, or hash each incoming byte with all the\nbytes in the register. We could even keep a large telephone book\non-line, and use each incoming byte combined with the register bytes\nto index a new phone number which would be the next register value.\nThe possibilities are limitless.\n\nHowever, we do not need to go so far; the next arithmetic step\nsuffices. While addition is clearly not strong enough to form an\neffective checksum, it turns out that division is, so long as the\ndivisor is about as wide as the checksum register.\n\nThe basic idea of CRC algorithms is simply to treat the message as an\nenormous binary number, to divide it by another fixed binary number,\nand to make the remainder from this division the checksum. Upon\nreceipt of the message, the receiver can perform the same division and\ncompare the remainder with the \"checksum\" (transmitted remainder).\n\nExample: Suppose the the message consisted of the two bytes (6,23) as\nin the previous example. These can be considered to be the hexadecimal\nnumber 0617 which can be considered to be the binary number\n0000-0110-0001-0111. Suppose that we use a checksum register one-byte\nwide and use a constant divisor of 1001, then the checksum is the\nremainder after 0000-0110-0001-0111 is divided by 1001. While in this\ncase, this calculation could obviously be performed using common\ngarden variety 32-bit registers, in the general case this is messy. So\ninstead, we'll do the division using good-'ol long division which you\nlearnt in school (remember?). Except this time, it's in binary:\n\n          ...0000010101101 = 00AD =  173 = QUOTIENT\n         ____-___-___-___-\n9= 1001 ) 0000011000010111 = 0617 = 1559 = DIVIDEND\nDIVISOR   0000.,,....,.,,,\n          ----.,,....,.,,,\n           0000,,....,.,,,\n           0000,,....,.,,,\n           ----,,....,.,,,\n            0001,....,.,,,\n            0000,....,.,,,\n            ----,....,.,,,\n             0011....,.,,,\n             0000....,.,,,\n             ----....,.,,,\n              0110...,.,,,\n              0000...,.,,,\n              ----...,.,,,\n               1100..,.,,,\n               1001..,.,,,\n               ====..,.,,,\n                0110.,.,,,\n                0000.,.,,,\n                ----.,.,,,\n                 1100,.,,,\n                 1001,.,,,\n                 ====,.,,,\n                  0111.,,,\n                  0000.,,,\n                  ----.,,,\n                   1110,,,\n                   1001,,,\n                   ====,,,\n                    1011,,\n                    1001,,\n                    ====,,\n                     0101,\n                     0000,\n                     ----\n                      1011\n                      1001\n                      ====\n                      0010 = 02 = 2 = REMAINDER\n\n\nIn decimal this is \"1559 divided by 9 is 173 with a remainder of 2\".\n\nAlthough the effect of each bit of the input message on the quotient\nis not all that significant, the 4-bit remainder gets kicked about\nquite a lot during the calculation, and if more bytes were added to\nthe message (dividend) it's value could change radically again very\nquickly. This is why division works where addition doesn't.\n\nIn case you're wondering, using this 4-bit checksum the transmitted\nmessage would look like this (in hexadecimal): 06172 (where the 0617\nis the message and the 2 is the checksum). The receiver would divide\n0617 by 9 and see whether the remainder was 2.\n\n\n4. Polynomical Arithmetic\n-------------------------\nWhile the division scheme described in the previous section is very\nvery similar to the checksumming schemes called CRC schemes, the CRC\nschemes are in fact a bit weirder, and we need to delve into some\nstrange number systems to understand them.\n\nThe word you will hear all the time when dealing with CRC algorithms\nis the word \"polynomial\". A given CRC algorithm will be said to be\nusing a particular polynomial, and CRC algorithms in general are said\nto be operating using polynomial arithmetic. What does this mean?\n\nInstead of the divisor, dividend (message), quotient, and remainder\n(as described in the previous section) being viewed as positive\nintegers, they are viewed as polynomials with binary coefficients.\nThis is done by treating each number as a bit-string whose bits are\nthe coefficients of a polynomial. For example, the ordinary number 23\n(decimal) is 17 (hex) and 10111 binary and so it corresponds to the\npolynomial:\n\n   1*x\u00ac4 + 0*x\u00ac3 + 1*x\u00ac2 + 1*x\u00ac1 + 1*x\u00ac0\n\nor, more simply:\n\n   x\u00ac4 + x\u00ac2 + x\u00ac1 + x\u00ac0\n\nUsing this technique, the message, and the divisor can be represented\nas polynomials and we can do all our arithmetic just as before, except\nthat now it's all cluttered up with Xs. For example, suppose we wanted\nto multiply 1101 by 1011. We can do this simply by multiplying the\npolynomials:\n\n(x\u00ac3 + x\u00ac2 + x\u00ac0)(x\u00ac3 + x\u00ac1 + x\u00ac0)\n= (x\u00ac6 + x\u00ac4 + x\u00ac3\n + x\u00ac5 + x\u00ac3 + x\u00ac2\n + x\u00ac3 + x\u00ac1 + x\u00ac0) = x\u00ac6 + x\u00ac5 + x\u00ac4 + 3*x\u00ac3 + x\u00ac2 + x\u00ac1 + x\u00ac0\n\nAt this point, to get the right answer, we have to pretend that x is 2\nand propagate binary carries from the 3*x\u00ac3 yielding\n\n   x\u00ac7 + x\u00ac3 + x\u00ac2 + x\u00ac1 + x\u00ac0\n\nIt's just like ordinary arithmetic except that the base is abstracted\nand brought into all the calculations explicitly instead of being\nthere implicitly. So what's the point?\n\nThe point is that IF we pretend that we DON'T know what x is, we CAN'T\nperform the carries. We don't know that 3*x\u00ac3 is the same as x\u00ac4 + x\u00ac3\nbecause we don't know that x is 2. In this true polynomial arithmetic\nthe relationship between all the coefficients is unknown and so the\ncoefficients of each power effectively become strongly typed;\ncoefficients of x\u00ac2 are effectively of a different type to\ncoefficients of x\u00ac3.\n\nWith the coefficients of each power nicely isolated, mathematicians\ncame up with all sorts of different kinds of polynomial arithmetics\nsimply by changing the rules about how coefficients work. Of these\nschemes, one in particular is relevant here, and that is a polynomial\narithmetic where the coefficients are calculated MOD 2 and there is no\ncarry; all coefficients must be either 0 or 1 and no carries are\ncalculated. This is called \"polynomial arithmetic mod 2\". Thus,\nreturning to the earlier example:\n\n(x\u00ac3 + x\u00ac2 + x\u00ac0)(x\u00ac3 + x\u00ac1 + x\u00ac0)\n= (x\u00ac6 + x\u00ac4 + x\u00ac3\n + x\u00ac5 + x\u00ac3 + x\u00ac2\n + x\u00ac3 + x\u00ac1 + x\u00ac0)\n= x\u00ac6 + x\u00ac5 + x\u00ac4 + 3*x\u00ac3 + x\u00ac2 + x\u00ac1 + x\u00ac0\n\nUnder the other arithmetic, the 3*x\u00ac3 term was propagated using the\ncarry mechanism using the knowledge that x=2. Under \"polynomial\narithmetic mod 2\", we don't know what x is, there are no carries, and\nall coefficients have to be calculated mod 2. Thus, the result\nbecomes:\n\n= x\u00ac6 + x\u00ac5 + x\u00ac4 + x\u00ac3 + x\u00ac2 + x\u00ac1 + x\u00ac0\n\nAs Knuth \u00ddKnuth81\u00a8 says (p.400):\n\n   \"The reader should note the similarity between polynomial\n   arithmetic and multiple-precision arithmetic (Section 4.3.1), where\n   the radix b is substituted for x. The chief difference is that the\n   coefficient u_k of x\u00ack in polynomial arithmetic bears little or no\n   relation to its neighboring coefficients x\u00ac{k-1} \u00ddand x\u00ac{k+1}\u00a8, so\n   the idea of \"carrying\" from one place to another is absent. In fact\n   polynomial arithmetic modulo b is essentially identical to multiple\n   precision arithmetic with radix b, except that all carries are\n   suppressed.\"\n\nThus polynomical arithmetic mod 2 is just binary arithmetic mod 2 with\nno carries. While polynomials provide useful mathematical machinery in\nmore analytical approaches to CRC and error-correction algorithms, for\nthe purposes of exposition they provide no extra insight and some\nencumbrance and have been discarded in the remainder of this document\nin favour of direct manipulation of the arithmetical system with which\nthey are isomorphic: binary arithmetic with no carry.\n\n\n5. Binary Arithmetic with No Carries\n------------------------------------\nHaving dispensed with polynomials, we can focus on the real arithmetic\nissue, which is that all the arithmetic performed during CRC\ncalculations is performed in binary with no carries. Often this is\ncalled polynomial arithmetic, but as I have declared the rest of this\ndocument a polynomial free zone, we'll have to call it CRC arithmetic\ninstead. As this arithmetic is a key part of CRC calculations, we'd\nbetter get used to it. Here we go:\n\nAdding two numbers in CRC arithmetic is the same as adding numbers in\nordinary binary arithmetic except there is no carry. This means that\neach pair of corresponding bits determine the corresponding output bit\nwithout reference to any other bit positions. For example:\n\n        10011011\n       +11001010\n        --------\n        01010001\n        --------\n\nThere are only four cases for each bit position:\n\n   0+0=0\n   0+1=1\n   1+0=1\n   1+1=0  (no carry)\n\nSubtraction is identical:\n\n        10011011\n       -11001010\n        --------\n        01010001\n        --------\n\nwith\n\n   0-0=0\n   0-1=1  (wraparound)\n   1-0=1\n   1-1=0\n\nIn fact, both addition and subtraction in CRC arithmetic is equivalent\nto the XOR operation, and the XOR operation is its own inverse. This\neffectively reduces the operations of the first level of power\n(addition, subtraction) to a single operation that is its own inverse.\nThis is a very convenient property of the arithmetic.\n\nBy collapsing of addition and subtraction, the arithmetic discards any\nnotion of magnitude beyond the power of its highest one bit. While it\nseems clear that 1010 is greater than 10, it is no longer the case\nthat 1010 can be considered to be greater than 1001. To see this, note\nthat you can get from 1010 to 1001 by both adding and subtracting the\nsame quantity:\n\n   1010 = 1010 + 0011\n   1010 = 1010 - 0011\n\nThis makes nonsense of any notion of order.\n\nHaving defined addition, we can move to multiplication and division.\nMultiplication is absolutely straightforward, being the sum of the\nfirst number, shifted in accordance with the second number.\n\n        1101\n      x 1011\n        ----\n        1101\n       1101.\n      0000..\n     1101...\n     -------\n     1111111  Note: The sum uses CRC addition\n     -------\n\nDivision is a little messier as we need to know when \"a number goes\ninto another number\". To do this, we invoke the weak definition of\nmagnitude defined earlier: that X is greater than or equal to Y iff\nthe position of the highest 1 bit of X is the same or greater than the\nposition of the highest 1 bit of Y. Here's a fully worked division\n(nicked from \u00ddTanenbaum81\u00a8).\n\n            1100001010\n       _______________\n10011 ) 11010110110000\n        10011,,.,,....\n        -----,,.,,....\n         10011,.,,....\n         10011,.,,....\n         -----,.,,....\n          00001.,,....\n          00000.,,....\n          -----.,,....\n           00010,,....\n           00000,,....\n           -----,,....\n            00101,....\n            00000,....\n            -----,....\n             01011....\n             00000....\n             -----....\n              10110...\n              10011...\n              -----...\n               01010..\n               00000..\n               -----..\n                10100.\n                10011.\n                -----.\n                 01110\n                 00000\n                 -----\n                  1110 = Remainder\n\nThat's really it. Before proceeding further, however, it's worth our\nwhile playing with this arithmetic a bit to get used to it.\n\nWe've already played with addition and subtraction, noticing that they\nare the same thing. Here, though, we should note that in this\narithmetic A+0=A and A-0=A. This obvious property is very useful\nlater.\n\nIn dealing with CRC multiplication and division, it's worth getting a\nfeel for the concepts of MULTIPLE and DIVISIBLE.\n\nIf a number A is a multiple of B then what this means in CRC\narithmetic is that it is possible to construct A from zero by XORing\nin various shifts of B. For example, if A was 0111010110 and B was 11,\nwe could construct A from B as follows:\n\n                  0111010110\n                = .......11.\n                + ....11....\n                + ...11.....\n                  .11.......\n\nHowever, if A is 0111010111, it is not possible to construct it out of\nvarious shifts of B (can you see why? - see later) so it is said to be\nnot divisible by B in CRC arithmetic.\n\nThus we see that CRC arithmetic is primarily about XORing particular\nvalues at various shifting offsets.\n\n\n6. A Fully Worked Example\n-------------------------\nHaving defined CRC arithmetic, we can now frame a CRC calculation as\nsimply a division, because that's all it is! This section fills in the\ndetails and gives an example.\n\nTo perform a CRC calculation, we need to choose a divisor. In maths\nmarketing speak the divisor is called the \"generator polynomial\" or\nsimply the \"polynomial\", and is a key parameter of any CRC algorithm.\nIt would probably be more friendly to call the divisor something else,\nbut the poly talk is so deeply ingrained in the field that it would\nnow be confusing to avoid it. As a compromise, we will refer to the\nCRC polynomial as the \"poly\". Just think of this number as a sort of\nparrot. \"Hello poly!\"\n\nYou can choose any poly and come up with a CRC algorithm. However,\nsome polys are better than others, and so it is wise to stick with the\ntried an tested ones. A later section addresses this issue.\n\nThe width (position of the highest 1 bit) of the poly is very\nimportant as it dominates the whole calculation. Typically, widths of\n16 or 32 are chosen so as to simplify implementation on modern\ncomputers. The width of a poly is the actual bit position of the\nhighest bit. For example, the width of 10011 is 4, not 5. For the\npurposes of example, we will chose a poly of 10011 (of width W of 4).\n\nHaving chosen a poly, we can proceed with the calculation. This is\nsimply a division (in CRC arithmetic) of the message by the poly. The\nonly trick is that W zero bits are appended to the message before the\nCRC is calculated. Thus we have:\n\n   Original message                : 1101011011\n   Poly                            :      10011\n   Message after appending W zeros : 11010110110000\n\nNow we simply divide the augmented message by the poly using CRC\narithmetic. This is the same division as before:\n\n            1100001010 = Quotient (nobody cares about the quotient)\n       _______________\n10011 ) 11010110110000 = Augmented message (1101011011 + 0000)\n=Poly  10011,,.,,....\n        -----,,.,,....\n         10011,.,,....\n         10011,.,,....\n         -----,.,,....\n          00001.,,....\n          00000.,,....\n          -----.,,....\n           00010,,....\n           00000,,....\n           -----,,....\n            00101,....\n            00000,....\n            -----,....\n             01011....\n             00000....\n             -----....\n              10110...\n              10011...\n              -----...\n               01010..\n               00000..\n               -----..\n                10100.\n                10011.\n                -----.\n                 01110\n                 00000\n                 -----\n                  1110 = Remainder = THE CHECKSUM!!!!\n\nThe division yields a quotient, which we throw away, and a remainder,\nwhich is the calculated checksum. This ends the calculation.\n\nUsually, the checksum is then appended to the message and the result\ntransmitted. In this case the transmission would be: 11010110111110.\n\nAt the other end, the receiver can do one of two things:\n\n   a. Separate the message and checksum. Calculate the checksum for\n      the message (after appending W zeros) and compare the two\n      checksums.\n\n   b. Checksum the whole lot (without appending zeros) and see if it\n      comes out as zero!\n\nThese two options are equivalent. However, in the next section, we\nwill be assuming option b because it is marginally mathematically\ncleaner.\n\nA summary of the operation of the class of CRC algorithms:\n\n   1. Choose a width W, and a poly G (of width W).\n   2. Append W zero bits to the message. Call this M'.\n   3. Divide M' by G using CRC arithmetic. The remainder is the checksum.\n\nThat's all there is to it.\n\n7. Choosing A Poly\n------------------\nChoosing a poly is somewhat of a black art and the reader is referred\nto \u00ddTanenbaum81\u00a8 (p.130-132) which has a very clear discussion of this\nissue. This section merely aims to put the fear of death into anyone\nwho so much as toys with the idea of making up their own poly. If you\ndon't care about why one poly might be better than another and just\nwant to find out about high-speed implementations, choose one of the\narithmetically sound polys listed at the end of this section and skip\nto the next section.\n\nFirst note that the transmitted message T is a multiple of the poly.\nTo see this, note that 1) the last W bits of T is the remainder after\ndividing the augmented (by zeros remember) message by the poly, and 2)\naddition is the same as subtraction so adding the remainder pushes the\nvalue up to the next multiple. Now note that if the transmitted\nmessage is corrupted in transmission that we will receive T+E where E\nis an error vector (and + is CRC addition (i.e. XOR)). Upon receipt of\nthis message, the receiver divides T+E by G. As T mod G is 0, (T+E)\nmod G = E mod G. Thus, the capacity of the poly we choose to catch\nparticular kinds of errors will be determined by the set of multiples\nof G, for any corruption E that is a multiple of G will be undetected.\nOur task then is to find classes of G whose multiples look as little\nlike the kind of line noise (that will be creating the corruptions) as\npossible. So let's examine the kinds of line noise we can expect.\n\nSINGLE BIT ERRORS: A single bit error means E=1000...0000. We can\nensure that this class of error is always detected by making sure that\nG has at least two bits set to 1. Any multiple of G will be\nconstructed using shifting and adding and it is impossible to\nconstruct a value with a single bit by shifting an adding a single\nvalue with more than one bit set, as the two end bits will always\npersist.\n\nTWO-BIT ERRORS: To detect all errors of the form 100...000100...000\n(i.e. E contains two 1 bits) choose a G that does not have multiples\nthat are 11, 101, 1001, 10001, 100001, etc. It is not clear to me how\none goes about doing this (I don't have the pure maths background),\nbut Tanenbaum assures us that such G do exist, and cites G with 1 bits\n(15,14,1) turned on as an example of one G that won't divide anything\nless than 1...1 where ... is 32767 zeros.\n\nERRORS WITH AN ODD NUMBER OF BITS: We can catch all corruptions where\nE has an odd number of bits by choosing a G that has an even number of\nbits. To see this, note that 1) CRC multiplication is simply XORing a\nconstant value into a register at various offsets, 2) XORing is simply\na bit-flip operation, and 3) if you XOR a value with an even number of\nbits into a register, the oddness of the number of 1 bits in the\nregister remains invariant. Example: Starting with E=111, attempt to\nflip all three bits to zero by the repeated application of XORing in\n11 at one of the two offsets (i.e. \"E=E XOR 011\" and \"E=E XOR 110\")\nThis is nearly isomorphic to the \"glass tumblers\" party puzzle where\nyou challenge someone to flip three tumblers by the repeated\napplication of the operation of flipping any two. Most of the popular\nCRC polys contain an even number of 1 bits. (Note: Tanenbaum states\nmore specifically that all errors with an odd number of bits can be\ncaught by making G a multiple of 11).\n\nBURST ERRORS: A burst error looks like E=000...000111...11110000...00.\nThat is, E consists of all zeros except for a run of 1s somewhere\ninside. This can be recast as E=(10000...00)(1111111...111) where\nthere are z zeros in the LEFT part and n ones in the RIGHT part. To\ncatch errors of this kind, we simply set the lowest bit of G to 1.\nDoing this ensures that LEFT cannot be a factor of G. Then, so long as\nG is wider than RIGHT, the error will be detected. See Tanenbaum for a\nclearer explanation of this; I'm a little fuzzy on this one. Note:\nTanenbaum asserts that the probability of a burst of length greater\nthan W getting through is (0.5)\u00acW.\n\nThat concludes the section on the fine art of selecting polys.\n\nSome popular polys are:\n16 bits: (16,12,5,0)                                \u00ddX25 standard\u00a8\n         (16,15,2,0)                                \u00dd\"CRC-16\"\u00a8\n32 bits: (32,26,23,22,16,12,11,10,8,7,5,4,2,1,0)    \u00ddEthernet\u00a8\n\n\n8. A Straightforward CRC Implementation\n---------------------------------------\nThat's the end of the theory; now we turn to implementations. To start\nwith, we examine an absolutely straight-down-the-middle boring\nstraightforward low-speed implementation that doesn't use any speed\ntricks at all. We'll then transform that program progessively until we\nend up with the compact table-driven code we all know and love and\nwhich some of us would like to understand.\n\nTo implement a CRC algorithm all we have to do is implement CRC\ndivision. There are two reasons why we cannot simply use the divide\ninstruction of whatever machine we are on. The first is that we have\nto do the divide in CRC arithmetic. The second is that the dividend\nmight be ten megabytes long, and todays processors do not have\nregisters that big.\n\nSo to implement CRC division, we have to feed the message through a\ndivision register. At this point, we have to be absolutely precise\nabout the message data. In all the following examples the message will\nbe considered to be a stream of bytes (each of 8 bits) with bit 7 of\neach byte being considered to be the most significant bit (MSB). The\nbit stream formed from these bytes will be the bit stream with the MSB\n(bit 7) of the first byte first, going down to bit 0 of the first\nbyte, and then the MSB of the second byte and so on.\n\nWith this in mind, we can sketch an implementation of the CRC\ndivision. For the purposes of example, consider a poly with W=4 and\nthe poly=10111. Then, the perform the division, we need to use a 4-bit\nregister:\n\n                  3   2   1   0   Bits\n                +---+---+---+---+\n       Pop! <-- |   |   |   |   | <----- Augmented message\n                +---+---+---+---+\n\n             1    0   1   1   1   = The Poly\n\n(Reminder: The augmented message is the message followed by W zero bits.)\n\nTo perform the division perform the following:\n\n   Load the register with zero bits.\n   Augment the message by appending W zero bits to the end of it.\n   While (more message bits)\n      Begin\n      Shift the register left by one bit, reading the next bit of the\n         augmented message into register bit position 0.\n      If (a 1 bit popped out of the register during step 3)\n         Register = Register XOR Poly.\n      End\n   The register now contains the remainder.\n\n(Note: In practice, the IF condition can be tested by testing the top\n bit of R before performing the shift.)\n\nWe will call this algorithm \"SIMPLE\".\n\nThis might look a bit messy, but all we are really doing is\n\"subtracting\" various powers (i.e. shiftings) of the poly from the\nmessage until there is nothing left but the remainder. Study the\nmanual examples of long division if you don't understand this.\n\nIt should be clear that the above algorithm will work for any width W.\n\n\n9. A Table-Driven Implementation\n--------------------------------\nThe SIMPLE algorithm above is a good starting point because it\ncorresponds directly to the theory presented so far, and because it is\nso SIMPLE. However, because it operates at the bit level, it is rather\nawkward to code (even in C), and inefficient to execute (it has to\nloop once for each bit). To speed it up, we need to find a way to\nenable the algorithm to process the message in units larger than one\nbit. Candidate quantities are nibbles (4 bits), bytes (8 bits), words\n(16 bits) and longwords (32 bits) and higher if we can achieve it. Of\nthese, 4 bits is best avoided because it does not correspond to a byte\nboundary. At the very least, any speedup should allow us to operate at\nbyte boundaries, and in fact most of the table driven algorithms\noperate a byte at a time.\n\nFor the purposes of discussion, let us switch from a 4-bit poly to a\n32-bit one. Our register looks much the same, except the boxes\nrepresent bytes instead of bits, and the Poly is 33 bits (one implicit\n1 bit at the top and 32 \"active\" bits) (W=32).\n\n                   3    2    1    0   Bytes\n                +----+----+----+----+\n       Pop! <-- |    |    |    |    | <----- Augmented message\n                +----+----+----+----+\n\n               1<------32 bits------>\n\nThe SIMPLE algorithm is still applicable. Let us examine what it does.\nImagine that the SIMPLE algorithm is in full swing and consider the\ntop 8 bits of the 32-bit register (byte 3) to have the values:\n\n   t7 t6 t5 t4 t3 t2 t1 t0\n\nIn the next iteration of SIMPLE, t7 will determine whether the Poly\nwill be XORed into the entire register. If t7=1, this will happen,\notherwise it will not. Suppose that the top 8 bits of the poly are g7\ng6.. g0, then after the next iteration, the top byte will be:\n\n        t6 t5 t4 t3 t2 t1 t0 ??\n+ t7 * (g7 g6 g5 g4 g3 g2 g1 g0)    \u00ddReminder: + is XOR\u00a8\n\nThe NEW top bit (that will control what happens in the next iteration)\nnow has the value t6 + t7*g7. The important thing to notice here is\nthat from an informational point of view, all the information required\nto calculate the NEW top bit was present in the top TWO bits of the\noriginal top byte. Similarly, the NEXT top bit can be calculated in\nadvance SOLELY from the top THREE bits t7, t6, and t5. In fact, in\ngeneral, the value of the top bit in the register in k iterations can\nbe calculated from the top k bits of the register. Let us take this\nfor granted for a moment.\n\nConsider for a moment that we use the top 8 bits of the register to\ncalculate the value of the top bit of the register during the next 8\niterations. Suppose that we drive the next 8 iterations using the\ncalculated values (which we could perhaps store in a single byte\nregister and shift out to pick off each bit). Then we note three\nthings:\n\n   * The top byte of the register now doesn't matter. No matter how\n     many times and at what offset the poly is XORed to the top 8\n     bits, they will all be shifted out the right hand side during the\n     next 8 iterations anyway.\n\n\n   * The remaining bits will be shifted left one position and the\n     rightmost byte of the register will be shifted in the next byte\n\n   AND\n\n   * While all this is going on, the register will be subjected to a\n     series of XOR's in accordance with the bits of the pre-calculated\n     control byte.\n\nNow consider the effect of XORing in a constant value at various\noffsets to a register. For example:\n\n       0100010  Register\n       ...0110  XOR this\n       ..0110.  XOR this\n       0110...  XOR this\n       -------\n       0011000\n       -------\n\nThe point of this is that you can XOR constant values into a register\nto your heart's delight, and in the end, there will exist a value\nwhich when XORed in with the original register will have the same\neffect as all the other XORs.\n\nPerhaps you can see the solution now. Putting all the pieces together\nwe have an algorithm that goes like this:\n\n   While (augmented message is not exhausted)\n      Begin\n      Examine the top byte of the register\n      Calculate the control byte from the top byte of the register\n      Sum all the Polys at various offsets that are to be XORed into\n         the register in accordance with the control byte\n      Shift the register left by one byte, reading a new message byte\n         into the rightmost byte of the register\n      XOR the summed polys to the register\n      End\n\nAs it stands this is not much better than the SIMPLE algorithm.\nHowever, it turns out that most of the calculation can be precomputed\nand assembled into a table. As a result, the above algorithm can be\nreduced to:\n\n   While (augmented message is not exhaused)\n      Begin\n      Top = top_byte(Register);\n      Register = (Register << 24) | next_augmessage_byte;\n      Register = Register XOR precomputed_table\u00ddTop\u00a8;\n      End\n\nThere! If you understand this, you've grasped the main idea of\ntable-driven CRC algorithms. The above is a very efficient algorithm\nrequiring just a shift, and OR, an XOR, and a table lookup per byte.\nGraphically, it looks like this:\n\n                   3    2    1    0   Bytes\n                +----+----+----+----+\n         +-----<|    |    |    |    | <----- Augmented message\n         |      +----+----+----+----+\n         |                \u00ac\n         |                |\n         |               XOR\n         |                |\n         |     0+----+----+----+----+       Algorithm\n         v      +----+----+----+----+       ---------\n         |      +----+----+----+----+       1. Shift the register left by\n         |      +----+----+----+----+          one byte, reading in a new\n         |      +----+----+----+----+          message byte.\n         |      +----+----+----+----+       2. Use the top byte just rotated\n         |      +----+----+----+----+          out of the register to index\n         +----->+----+----+----+----+          the table of 256 32-bit values.\n                +----+----+----+----+       3. XOR the table value into the\n                +----+----+----+----+          register.\n                +----+----+----+----+       4. Goto 1 iff more augmented\n                +----+----+----+----+          message bytes.\n             255+----+----+----+----+\n\n\nIn C, the algorithm main loop looks like this:\n\n   r=0;\n   while (len--)\n     {\n      byte t = (r >> 24) & 0xFF;\n      r = (r << 8) | *p++;\n      r\u00ac=table\u00ddt\u00a8;\n     }\n\nwhere len is the length of the augmented message in bytes, p points to\nthe augmented message, r is the register, t is a temporary, and table\nis the computed table. This code can be made even more unreadable as\nfollows:\n\n   r=0; while (len--) r = ((r << 8) | *p++) \u00ac t\u00dd(r >> 24) & 0xFF\u00a8;\n\nThis is a very clean, efficient loop, although not a very obvious one\nto the casual observer not versed in CRC theory. We will call this the\nTABLE algorithm.\n\n\n10. A Slightly Mangled Table-Driven Implementation\n--------------------------------------------------\nDespite the terse beauty of the line\n\n   r=0; while (len--) r = ((r << 8) | *p++) \u00ac t\u00dd(r >> 24) & 0xFF\u00a8;\n\nthose optimizing hackers couldn't leave it alone. The trouble, you\nsee, is that this loop operates upon the AUGMENTED message and in\norder to use this code, you have to append W/8 zero bytes to the end\nof the message before pointing p at it. Depending on the run-time\nenvironment, this may or may not be a problem; if the block of data\nwas handed to us by some other code, it could be a BIG problem. One\nalternative is simply to append the following line after the above\nloop, once for each zero byte:\n\n      for (i=0; i<W/4; i++) r = (r << 8) \u00ac t\u00dd(r >> 24) & 0xFF\u00a8;\n\nThis looks like a sane enough solution to me. However, at the further\nexpense of clarity (which, you must admit, is already a pretty scare\ncommodity in this code) we can reorganize this small loop further so\nas to avoid the need to either augment the message with zero bytes, or\nto explicitly process zero bytes at the end as above. To explain the\noptimization, we return to the processing diagram given earlier.\n\n                   3    2    1    0   Bytes\n                +----+----+----+----+\n         +-----<|    |    |    |    | <----- Augmented message\n         |      +----+----+----+----+\n         |                \u00ac\n         |                |\n         |               XOR\n         |                |\n         |     0+----+----+----+----+       Algorithm\n         v      +----+----+----+----+       ---------\n         |      +----+----+----+----+       1. Shift the register left by\n         |      +----+----+----+----+          one byte, reading in a new\n         |      +----+----+----+----+          message byte.\n         |      +----+----+----+----+       2. Use the top byte just rotated\n         |      +----+----+----+----+          out of the register to index\n         +----->+----+----+----+----+          the table of 256 32-bit values.\n                +----+----+----+----+       3. XOR the table value into the\n                +----+----+----+----+          register.\n                +----+----+----+----+       4. Goto 1 iff more augmented\n                +----+----+----+----+          message bytes.\n             255+----+----+----+----+\n\nNow, note the following facts:\n\nTAIL: The W/4 augmented zero bytes that appear at the end of the\n      message will be pushed into the register from the right as all\n      the other bytes are, but their values (0) will have no effect\n      whatsoever on the register because 1) XORing with zero does not\n      change the target byte, and 2) the four bytes are never\n      propagated out the left side of the register where their\n      zeroness might have some sort of influence. Thus, the sole\n      function of the W/4 augmented zero bytes is to drive the\n      calculation for another W/4 byte cycles so that the end of the\n      REAL data passes all the way through the register.\n\nHEAD: If the initial value of the register is zero, the first four\n      iterations of the loop will have the sole effect of shifting in\n      the first four bytes of the message from the right. This is\n      because the first 32 control bits are all zero and so nothing is\n      XORed into the register. Even if the initial value is not zero,\n      the first 4 byte iterations of the algorithm will have the sole\n      effect of shifting the first 4 bytes of the message into the\n      register and then XORing them with some constant value (that is\n      a function of the initial value of the register).\n\nThese facts, combined with the XOR property\n\n   (A xor B) xor C = A xor (B xor C)\n\nmean that message bytes need not actually travel through the W/4 bytes\nof the register. Instead, they can be XORed into the top byte just\nbefore it is used to index the lookup table. This leads to the\nfollowing modified version of the algorithm.\n\n\n         +-----<Message (non augmented)\n         |\n         v         3    2    1    0   Bytes\n         |      +----+----+----+----+\n        XOR----<|    |    |    |    |\n         |      +----+----+----+----+\n         |                \u00ac\n         |                |\n         |               XOR\n         |                |\n         |     0+----+----+----+----+       Algorithm\n         v      +----+----+----+----+       ---------\n         |      +----+----+----+----+       1. Shift the register left by\n         |      +----+----+----+----+          one byte, reading in a new\n         |      +----+----+----+----+          message byte.\n         |      +----+----+----+----+       2. XOR the top byte just rotated\n         |      +----+----+----+----+          out of the register with the\n         +----->+----+----+----+----+          next message byte to yield an\n                +----+----+----+----+          index into the table (\u00dd0,255\u00a8).\n                +----+----+----+----+       3. XOR the table value into the\n                +----+----+----+----+          register.\n                +----+----+----+----+       4. Goto 1 iff more augmented\n             255+----+----+----+----+          message bytes.\n\n\nNote: The initial register value for this algorithm must be the\ninitial value of the register for the previous algorithm fed through\nthe table four times. Note: The table is such that if the previous\nalgorithm used 0, the new algorithm will too.\n\nThis is an IDENTICAL algorithm and will yield IDENTICAL results. The C\ncode looks something like this:\n\n   r=0; while (len--) r = (r<<8) \u00ac t\u00dd(r >> 24) \u00ac *p++\u00a8;\n\nand THIS is the code that you are likely to find inside current\ntable-driven CRC implementations. Some FF masks might have to be ANDed\nin here and there for portability's sake, but basically, the above\nloop is IT. We will call this the DIRECT TABLE ALGORITHM.\n\nDuring the process of trying to understand all this stuff, I managed\nto derive the SIMPLE algorithm and the table-driven version derived\nfrom that. However, when I compared my code with the code found in\nreal-implementations, I was totally bamboozled as to why the bytes\nwere being XORed in at the wrong end of the register! It took quite a\nwhile before I figured out that theirs and my algorithms were actually\nthe same. Part of why I am writing this document is that, while the\nlink between division and my earlier table-driven code is vaguely\napparent, any such link is fairly well erased when you start pumping\nbytes in at the \"wrong end\" of the register. It looks all wrong!\n\nIf you've got this far, you not only understand the theory, the\npractice, the optimized practice, but you also understand the real\ncode you are likely to run into. Could get any more complicated? Yes\nit can.\n\n\n11. \"Reflected\" Table-Driven Implementations\n--------------------------------------------\nDespite the fact that the above code is probably optimized about as\nmuch as it could be, this did not stop some enterprising individuals\nfrom making things even more complicated. To understand how this\nhappened, we have to enter the world of hardware.\n\nDEFINITION: A value/register is reflected if it's bits are swapped\naround its centre. For example: 0101 is the 4-bit reflection of 1010.\n0011 is the reflection of 1100.\n0111-0101-1010-1111-0010-0101-1011-1100 is the reflection of\n0011-1101-1010-0100-1111-0101-1010-1110.\n\nTurns out that UARTs (those handy little chips that perform serial IO)\nare in the habit of transmitting each byte with the least significant\nbit (bit 0) first and the most significant bit (bit 7) last (i.e.\nreflected). An effect of this convention is that hardware engineers\nconstructing hardware CRC calculators that operate at the bit level\ntook to calculating CRCs of bytes streams with each of the bytes\nreflected within itself. The bytes are processed in the same order,\nbut the bits in each byte are swapped; bit 0 is now bit 7, bit 1 is\nnow bit 6, and so on. Now this wouldn't matter much if this convention\nwas restricted to hardware land. However it seems that at some stage\nsome of these CRC values were presented at the software level and\nsomeone had to write some code that would interoperate with the\nhardware CRC calculation.\n\nIn this situation, a normal sane software engineer would simply\nreflect each byte before processing it. However, it would seem that\nnormal sane software engineers were thin on the ground when this early\nground was being broken, because instead of reflecting the bytes,\nwhoever was responsible held down the byte and reflected the world,\nleading to the following \"reflected\" algorithm which is identical to\nthe previous one except that everything is reflected except the input\nbytes.\n\n\n             Message (non augmented) >-----+\n                                           |\n           Bytes   0    1    2    3        v\n                +----+----+----+----+      |\n                |    |    |    |    |>----XOR\n                +----+----+----+----+      |\n                          \u00ac                |\n                          |                |\n                         XOR               |\n                          |                |\n                +----+----+----+----+0     |\n                +----+----+----+----+      v\n                +----+----+----+----+      |\n                +----+----+----+----+      |\n                +----+----+----+----+      |\n                +----+----+----+----+      |\n                +----+----+----+----+      |\n                +----+----+----+----+<-----+\n                +----+----+----+----+\n                +----+----+----+----+\n                +----+----+----+----+\n                +----+----+----+----+\n                +----+----+----+----+255\n\nNotes:\n\n   * The table is identical to the one in the previous algorithm\n   except that each entry has been reflected.\n\n   * The initial value of the register is the same as in the previous\n   algorithm except that it has been reflected.\n\n   * The bytes of the message are processed in the same order as\n   before (i.e. the message itself is not reflected).\n\n   * The message bytes themselves don't need to be explicitly\n   reflected, because everything else has been!\n\nAt the end of execution, the register contains the reflection of the\nfinal CRC value (remainder). Actually, I'm being rather hard on\nwhoever cooked this up because it seems that hardware implementations\nof the CRC algorithm used the reflected checksum value and so\nproducing a reflected CRC was just right. In fact reflecting the world\nwas probably a good engineering solution - if a confusing one.\n\nWe will call this the REFLECTED algorithm.\n\nWhether or not it made sense at the time, the effect of having\nreflected algorithms kicking around the world's FTP sites is that\nabout half the CRC implementations one runs into are reflected and the\nother half not. It's really terribly confusing. In particular, it\nwould seem to me that the casual reader who runs into a reflected,\ntable-driven implementation with the bytes \"fed in the wrong end\"\nwould have Buckley's chance of ever connecting the code to the concept\nof binary mod 2 division.\n\nIt couldn't get any more confusing could it? Yes it could.\n\n\n12. \"Reversed\" Polys\n--------------------\nAs if reflected implementations weren't enough, there is another\nconcept kicking around which makes the situation bizaarly confusing.\nThe concept is reversed Polys.\n\nIt turns out that the reflection of good polys tend to be good polys\ntoo! That is, if G=11101 is a good poly value, then 10111 will be as\nwell. As a consequence, it seems that every time an organization (such\nas CCITT) standardizes on a particularly good poly (\"polynomial\"),\nthose in the real world can't leave the poly's reflection alone\neither. They just HAVE to use it. As a result, the set of \"standard\"\npoly's has a corresponding set of reflections, which are also in use.\nTo avoid confusion, we will call these the \"reversed\" polys.\n\n   X25   standard: 1-0001-0000-0010-0001\n   X25   reversed: 1-0000-1000-0001-0001\n\n   CRC16 standard: 1-1000-0000-0000-0101\n   CRC16 reversed: 1-0100-0000-0000-0011\n\nNote that here it is the entire poly that is being reflected/reversed,\nnot just the bottom W bits. This is an important distinction. In the\nreflected algorithm described in the previous section, the poly used\nin the reflected algorithm was actually identical to that used in the\nnon-reflected algorithm; all that had happened is that the bytes had\neffectively been reflected. As such, all the 16-bit/32-bit numbers in\nthe algorithm had to be reflected. In contrast, the ENTIRE poly\nincludes the implicit one bit at the top, and so reversing a poly is\nnot the same as reflecting its bottom 16 or 32 bits.\n\nThe upshot of all this is that a reflected algorithm is not equivalent\nto the original algorithm with the poly reflected. Actually, this is\nprobably less confusing than if they were duals.\n\nIf all this seems a bit unclear, don't worry, because we're going to\nsort it all out \"real soon now\". Just one more section to go before\nthat.\n\n\n13. Initial and Final Values\n----------------------------\nIn addition to the complexity already seen, CRC algorithms differ from\neach other in two other regards:\n\n   * The initial value of the register.\n\n   * The value to be XORed with the final register value.\n\nFor example, the \"CRC32\" algorithm initializes its register to\nFFFFFFFF and XORs the final register value with FFFFFFFF.\n\nMost CRC algorithms initialize their register to zero. However, some\ninitialize it to a non-zero value. In theory (i.e. with no assumptions\nabout the message), the initial value has no affect on the strength of\nthe CRC algorithm, the initial value merely providing a fixed starting\npoint from which the register value can progress. However, in\npractice, some messages are more likely than others, and it is wise to\ninitialize the CRC algorithm register to a value that does not have\n\"blind spots\" that are likely to occur in practice. By \"blind spot\" is\nmeant a sequence of message bytes that do not result in the register\nchanging its value. In particular, any CRC algorithm that initializes\nits register to zero will have a blind spot of zero when it starts up\nand will be unable to \"count\" a leading run of zero bytes. As a\nleading run of zero bytes is quite common in real messages, it is wise\nto initialize the algorithm register to a non-zero value.\n\n\n14. Defining Algorithms Absolutely\n----------------------------------\nAt this point we have covered all the different aspects of\ntable-driven CRC algorithms. As there are so many variations on these\nalgorithms, it is worth trying to establish a nomenclature for them.\nThis section attempts to do that.\n\nWe have seen that CRC algorithms vary in:\n\n   * Width of the poly (polynomial).\n   * Value of the poly.\n   * Initial value for the register.\n   * Whether the bits of each byte are reflected before being processed.\n   * Whether the algorithm feeds input bytes through the register or\n     xors them with a byte from one end and then straight into the table.\n   * Whether the final register value should be reversed (as in reflected\n     versions).\n   * Value to XOR with the final register value.\n\nIn order to be able to talk about particular CRC algorithms, we need\nto able to define them more precisely than this. For this reason, the\nnext section attempts to provide a well-defined parameterized model\nfor CRC algorithms. To refer to a particular algorithm, we need then\nsimply specify the algorithm in terms of parameters to the model.\n\n\n15. A Parameterized Model For CRC Algorithms\n--------------------------------------------\nIn this section we define a precise parameterized model CRC algorithm\nwhich, for want of a better name, we will call the \"Rocksoft\u00actm Model\nCRC Algorithm\" (and why not? Rocksoft\u00actm could do with some free\nadvertising :-).\n\nThe most important aspect of the model algorithm is that it focusses\nexclusively on functionality, ignoring all implementation details. The\naim of the exercise is to construct a way of referring precisely to\nparticular CRC algorithms, regardless of how confusingly they are\nimplemented. To this end, the model must be as simple and precise as\npossible, with as little confusion as possible.\n\nThe Rocksoft\u00actm Model CRC Algorithm is based essentially on the DIRECT\nTABLE ALGORITHM specified earlier. However, the algorithm has to be\nfurther parameterized to enable it to behave in the same way as some\nof the messier algorithms out in the real world.\n\nTo enable the algorithm to behave like reflected algorithms, we\nprovide a boolean option to reflect the input bytes, and a boolean\noption to specify whether to reflect the output checksum value. By\nframing reflection as an input/output transformation, we avoid the\nconfusion of having to mentally map the parameters of reflected and\nnon-reflected algorithms.\n\nAn extra parameter allows the algorithm's register to be initialized\nto a particular value. A further parameter is XORed with the final\nvalue before it is returned.\n\nBy putting all these pieces together we end up with the parameters of\nthe algorithm:\n\n   NAME: This is a name given to the algorithm. A string value.\n\n   WIDTH: This is the width of the algorithm expressed in bits. This\n   is one less than the width of the Poly.\n\n   POLY: This parameter is the poly. This is a binary value that\n   should be specified as a hexadecimal number. The top bit of the\n   poly should be omitted. For example, if the poly is 10110, you\n   should specify 06. An important aspect of this parameter is that it\n   represents the unreflected poly; the bottom bit of this parameter\n   is always the LSB of the divisor during the division regardless of\n   whether the algorithm being modelled is reflected.\n\n   INIT: This parameter specifies the initial value of the register\n   when the algorithm starts. This is the value that is to be assigned\n   to the register in the direct table algorithm. In the table\n   algorithm, we may think of the register always commencing with the\n   value zero, and this value being XORed into the register after the\n   N'th bit iteration. This parameter should be specified as a\n   hexadecimal number.\n\n   REFIN: This is a boolean parameter. If it is FALSE, input bytes are\n   processed with bit 7 being treated as the most significant bit\n   (MSB) and bit 0 being treated as the least significant bit. If this\n   parameter is FALSE, each byte is reflected before being processed.\n\n   REFOUT: This is a boolean parameter. If it is set to FALSE, the\n   final value in the register is fed into the XOROUT stage directly,\n   otherwise, if this parameter is TRUE, the final register value is\n   reflected first.\n\n   XOROUT: This is an W-bit value that should be specified as a\n   hexadecimal number. It is XORed to the final register value (after\n   the REFOUT) stage before the value is returned as the official\n   checksum.\n\n   CHECK: This field is not strictly part of the definition, and, in\n   the event of an inconsistency between this field and the other\n   field, the other fields take precedence. This field is a check\n   value that can be used as a weak validator of implementations of\n   the algorithm. The field contains the checksum obtained when the\n   ASCII string \"123456789\" is fed through the specified algorithm\n   (i.e. 313233... (hexadecimal)).\n\nWith these parameters defined, the model can now be used to specify a\nparticular CRC algorithm exactly. Here is an example specification for\na popular form of the CRC-16 algorithm.\n\n   Name   : \"CRC-16\"\n   Width  : 16\n   Poly   : 8005\n   Init   : 0000\n   RefIn  : True\n   RefOut : True\n   XorOut : 0000\n   Check  : BB3D\n\n\n16. A Catalog of Parameter Sets for Standards\n---------------------------------------------\nAt this point, I would like to give a list of the specifications for\ncommonly used CRC algorithms. However, most of the algorithms that I\nhave come into contact with so far are specified in such a vague way\nthat this has not been possible. What I can provide is a list of polys\nfor various CRC standards I have heard of:\n\n   X25   standard : 1021       \u00ddCRC-CCITT, ADCCP, SDLC/HDLC\u00a8\n   X25   reversed : 0811\n\n   CRC16 standard : 8005\n   CRC16 reversed : 4003       \u00ddLHA\u00a8\n\n   CRC32          : 04C11DB7   \u00ddPKZIP, AUTODIN II, Ethernet, FDDI\u00a8\n\nI would be interested in hearing from anyone out there who can tie\ndown the complete set of model parameters for any of these standards.\n\nHowever, a program that was kicking around seemed to imply the\nfollowing specifications. Can anyone confirm or deny them (or provide\nthe check values (which I couldn't be bothered coding up and\ncalculating)).\n\n   Name   : \"CRC-16/CITT\"\n   Width  : 16\n   Poly   : 1021\n   Init   : FFFF\n   RefIn  : False\n   RefOut : False\n   XorOut : 0000\n   Check  : ?\n\n\n   Name   : \"XMODEM\"\n   Width  : 16\n   Poly   : 8408\n   Init   : 0000\n   RefIn  : True\n   RefOut : True\n   XorOut : 0000\n   Check  : ?\n\n\n   Name   : \"ARC\"\n   Width  : 16\n   Poly   : 8005\n   Init   : 0000\n   RefIn  : True\n   RefOut : True\n   XorOut : 0000\n   Check  : ?\n\nHere is the specification for the CRC-32 algorithm which is reportedly\nused in PKZip, AUTODIN II, Ethernet, and FDDI.\n\n   Name   : \"CRC-32\"\n   Width  : 32\n   Poly   : 04C11DB7\n   Init   : FFFFFFFF\n   RefIn  : True\n   RefOut : True\n   XorOut : FFFFFFFF\n   Check  : CBF43926\n\n\n17. An Implementation of the Model Algorithm\n--------------------------------------------\nHere is an implementation of the model algorithm in the C programming\nlanguage. The implementation consists of a header file (.h) and an\nimplementation file (.c). If you're reading this document in a\nsequential scroller, you can skip this code by searching for the\nstring \"Roll Your Own\".\n\nTo ensure that the following code is working, configure it for the\nCRC-16 and CRC-32 algorithms given above and ensure that they produce\nthe specified \"check\" checksum when fed the test string \"123456789\"\n(see earlier).\n\n/******************************************************************************/\n/*                             Start of crcmodel.h                            */\n/******************************************************************************/\n/*                                                                            */\n/* Author : Ross Williams (ross@guest.adelaide.edu.au.).                      */\n/* Date   : 3 June 1993.                                                      */\n/* Status : Public domain.                                                    */\n/*                                                                            */\n/* Description : This is the header (.h) file for the reference               */\n/* implementation of the Rocksoft\u00actm Model CRC Algorithm. For more            */\n/* information on the Rocksoft\u00actm Model CRC Algorithm, see the document       */\n/* titled \"A Painless Guide to CRC Error Detection Algorithms\" by Ross        */\n/* Williams (ross@guest.adelaide.edu.au.). This document is likely to be in   */\n/* \"ftp.adelaide.edu.au/pub/rocksoft\".                                        */\n/*                                                                            */\n/* Note: Rocksoft is a trademark of Rocksoft Pty Ltd, Adelaide, Australia.    */\n/*                                                                            */\n/******************************************************************************/\n/*                                                                            */\n/* How to Use This Package                                                    */\n/* -----------------------                                                    */\n/* Step 1: Declare a variable of type cm_t. Declare another variable          */\n/*         (p_cm say) of type p_cm_t and initialize it to point to the first  */\n/*         variable (e.g. p_cm_t p_cm = &cm_t).                               */\n/*                                                                            */\n/* Step 2: Assign values to the parameter fields of the structure.            */\n/*         If you don't know what to assign, see the document cited earlier.  */\n/*         For example:                                                       */\n/*            p_cm->cm_width = 16;                                            */\n/*            p_cm->cm_poly  = 0x8005L;                                       */\n/*            p_cm->cm_init  = 0L;                                            */\n/*            p_cm->cm_refin = TRUE;                                          */\n/*            p_cm->cm_refot = TRUE;                                          */\n/*            p_cm->cm_xorot = 0L;                                            */\n/*         Note: Poly is specified without its top bit (18005 becomes 8005).  */\n/*         Note: Width is one bit less than the raw poly width.               */\n/*                                                                            */\n/* Step 3: Initialize the instance with a call cm_ini(p_cm);                  */\n/*                                                                            */\n/* Step 4: Process zero or more message bytes by placing zero or more         */\n/*         successive calls to cm_nxt. Example: cm_nxt(p_cm,ch);              */\n/*                                                                            */\n/* Step 5: Extract the CRC value at any time by calling crc = cm_crc(p_cm);   */\n/*         If the CRC is a 16-bit value, it will be in the bottom 16 bits.    */\n/*                                                                            */\n/******************************************************************************/\n/*                                                                            */\n/* Design Notes                                                               */\n/* ------------                                                               */\n/* PORTABILITY: This package has been coded very conservatively so that       */\n/* it will run on as many machines as possible. For example, all external     */\n/* identifiers have been restricted to 6 characters and all internal ones to  */\n/* 8 characters. The prefix cm (for Crc Model) is used as an attempt to avoid */\n/* namespace collisions. This package is endian independent.                  */\n/*                                                                            */\n/* EFFICIENCY: This package (and its interface) is not designed for           */\n/* speed. The purpose of this package is to act as a well-defined reference   */\n/* model for the specification of CRC algorithms. If you want speed, cook up  */\n/* a specific table-driven implementation as described in the document cited  */\n/* above. This package is designed for validation only; if you have found or  */\n/* implemented a CRC algorithm and wish to describe it as a set of parameters */\n/* to the Rocksoft\u00actm Model CRC Algorithm, your CRC algorithm implementation  */\n/* should behave identically to this package under those parameters.          */\n/*                                                                            */\n/******************************************************************************/\n\n/* The following #ifndef encloses this entire */\n/* header file, rendering it indempotent.     */\n#ifndef CM_DONE\n#define CM_DONE\n\n/******************************************************************************/\n\n/* The following definitions are extracted from my style header file which    */\n/* would be cumbersome to distribute with this package. The DONE_STYLE is the */\n/* idempotence symbol used in my style header file.                           */\n\n#ifndef DONE_STYLE\n\ntypedef unsigned long   ulong;\ntypedef unsigned        bool;\ntypedef unsigned char * p_ubyte_;\n\n#ifndef TRUE\n#define FALSE 0\n#define TRUE  1\n#endif\n\n/* Change to the second definition if you don't have prototypes. */\n#define P_(A) A\n/* #define P_(A) () */\n\n/* Uncomment this definition if you don't have void. */\n/* typedef int void; */\n\n#endif\n\n/******************************************************************************/\n\n/* CRC Model Abstract Type */\n/* ----------------------- */\n/* The following type stores the context of an executing instance of the  */\n/* model algorithm. Most of the fields are model parameters which must be */\n/* set before the first initializing call to cm_ini.                      */\ntypedef struct\n  {\n   int   cm_width;   /* Parameter: Width in bits \u00dd8,32\u00a8.       */\n   ulong cm_poly;    /* Parameter: The algorithm's polynomial. */\n   ulong cm_init;    /* Parameter: Initial register value.     */\n   bool  cm_refin;   /* Parameter: Reflect input bytes?        */\n   bool  cm_refot;   /* Parameter: Reflect output CRC?         */\n   ulong cm_xorot;   /* Parameter: XOR this to output CRC.     */\n\n   ulong cm_reg;     /* Context: Context during execution.     */\n  } cm_t;\ntypedef cm_t *p_cm_t;\n\n/******************************************************************************/\n\n/* Functions That Implement The Model */\n/* ---------------------------------- */\n/* The following functions animate the cm_t abstraction. */\n\nvoid cm_ini P_((p_cm_t p_cm));\n/* Initializes the argument CRC model instance.          */\n/* All parameter fields must be set before calling this. */\n\nvoid cm_nxt P_((p_cm_t p_cm,int ch));\n/* Processes a single message byte \u00dd0,255\u00a8. */\n\nvoid cm_blk P_((p_cm_t p_cm,p_ubyte_ blk_adr,ulong blk_len));\n/* Processes a block of message bytes. */\n\nulong cm_crc P_((p_cm_t p_cm));\n/* Returns the CRC value for the message bytes processed so far. */\n\n/******************************************************************************/\n\n/* Functions For Table Calculation */\n/* ------------------------------- */\n/* The following function can be used to calculate a CRC lookup table.        */\n/* It can also be used at run-time to create or check static tables.          */\n\nulong cm_tab P_((p_cm_t p_cm,int index));\n/* Returns the i'th entry for the lookup table for the specified algorithm.   */\n/* The function examines the fields cm_width, cm_poly, cm_refin, and the      */\n/* argument table index in the range \u00dd0,255\u00a8 and returns the table entry in   */\n/* the bottom cm_width bytes of the return value.                             */\n\n/******************************************************************************/\n\n/* End of the header file idempotence #ifndef */\n#endif\n\n/******************************************************************************/\n/*                             End of crcmodel.h                              */\n/******************************************************************************/\n\n\n/******************************************************************************/\n/*                             Start of crcmodel.c                            */\n/******************************************************************************/\n/*                                                                            */\n/* Author : Ross Williams (ross@guest.adelaide.edu.au.).                      */\n/* Date   : 3 June 1993.                                                      */\n/* Status : Public domain.                                                    */\n/*                                                                            */\n/* Description : This is the implementation (.c) file for the reference       */\n/* implementation of the Rocksoft\u00actm Model CRC Algorithm. For more            */\n/* information on the Rocksoft\u00actm Model CRC Algorithm, see the document       */\n/* titled \"A Painless Guide to CRC Error Detection Algorithms\" by Ross        */\n/* Williams (ross@guest.adelaide.edu.au.). This document is likely to be in   */\n/* \"ftp.adelaide.edu.au/pub/rocksoft\".                                        */\n/*                                                                            */\n/* Note: Rocksoft is a trademark of Rocksoft Pty Ltd, Adelaide, Australia.    */\n/*                                                                            */\n/******************************************************************************/\n/*                                                                            */\n/* Implementation Notes                                                       */\n/* --------------------                                                       */\n/* To avoid inconsistencies, the specification of each function is not echoed */\n/* here. See the header file for a description of these functions.            */\n/* This package is light on checking because I want to keep it short and      */\n/* simple and portable (i.e. it would be too messy to distribute my entire    */\n/* C culture (e.g. assertions package) with this package.                     */\n/*                                                                            */\n/******************************************************************************/\n\n#include \"crcmodel.h\"\n\n/******************************************************************************/\n\n/* The following definitions make the code more readable. */\n\n#define BITMASK(X) (1L << (X))\n#define MASK32 0xFFFFFFFFL\n#define LOCAL static\n\n/******************************************************************************/\n\nLOCAL ulong reflect P_((ulong v,int b));\nLOCAL ulong reflect (v,b)\n/* Returns the value v with the bottom b \u00dd0,32\u00a8 bits reflected. */\n/* Example: reflect(0x3e23L,3) == 0x3e26                        */\nulong v;\nint   b;\n{\n int   i;\n ulong t = v;\n for (i=0; i<b; i++)\n   {\n    if (t & 1L)\n       v|=  BITMASK((b-1)-i);\n    else\n       v&= ~BITMASK((b-1)-i);\n    t>>=1;\n   }\n return v;\n}\n\n/******************************************************************************/\n\nLOCAL ulong widmask P_((p_cm_t));\nLOCAL ulong widmask (p_cm)\n/* Returns a longword whose value is (2\u00acp_cm->cm_width)-1.     */\n/* The trick is to do this portably (e.g. without doing <<32). */\np_cm_t p_cm;\n{\n return (((1L<<(p_cm->cm_width-1))-1L)<<1)|1L;\n}\n\n/******************************************************************************/\n\nvoid cm_ini (p_cm)\np_cm_t p_cm;\n{\n p_cm->cm_reg = p_cm->cm_init;\n}\n\n/******************************************************************************/\n\nvoid cm_nxt (p_cm,ch)\np_cm_t p_cm;\nint    ch;\n{\n int   i;\n ulong uch  = (ulong) ch;\n ulong topbit = BITMASK(p_cm->cm_width-1);\n\n if (p_cm->cm_refin) uch = reflect(uch,8);\n p_cm->cm_reg \u00ac= (uch << (p_cm->cm_width-8));\n for (i=0; i<8; i++)\n   {\n    if (p_cm->cm_reg & topbit)\n       p_cm->cm_reg = (p_cm->cm_reg << 1) \u00ac p_cm->cm_poly;\n    else\n       p_cm->cm_reg <<= 1;\n    p_cm->cm_reg &= widmask(p_cm);\n   }\n}\n\n/******************************************************************************/\n\nvoid cm_blk (p_cm,blk_adr,blk_len)\np_cm_t   p_cm;\np_ubyte_ blk_adr;\nulong    blk_len;\n{\n while (blk_len--) cm_nxt(p_cm,*blk_adr++);\n}\n\n/******************************************************************************/\n\nulong cm_crc (p_cm)\np_cm_t p_cm;\n{\n if (p_cm->cm_refot)\n    return p_cm->cm_xorot \u00ac reflect(p_cm->cm_reg,p_cm->cm_width);\n else\n    return p_cm->cm_xorot \u00ac p_cm->cm_reg;\n}\n\n/******************************************************************************/\n\nulong cm_tab (p_cm,index)\np_cm_t p_cm;\nint    index;\n{\n int   i;\n ulong r;\n ulong topbit = BITMASK(p_cm->cm_width-1);\n ulong inbyte = (ulong) index;\n\n if (p_cm->cm_refin) inbyte = reflect(inbyte,8);\n r = inbyte << (p_cm->cm_width-8);\n for (i=0; i<8; i++)\n    if (r & topbit)\n       r = (r << 1) \u00ac p_cm->cm_poly;\n    else\n       r<<=1;\n if (p_cm->cm_refin) r = reflect(r,p_cm->cm_width);\n return r & widmask(p_cm);\n}\n\n/******************************************************************************/\n/*                             End of crcmodel.c                              */\n/******************************************************************************/\n\n\n18. Roll Your Own Table-Driven Implementation\n---------------------------------------------\nDespite all the fuss I've made about understanding and defining CRC\nalgorithms, the mechanics of their high-speed implementation remains\ntrivial. There are really only two forms: normal and reflected. Normal\nshifts to the left and covers the case of algorithms with Refin=FALSE\nand Refot=FALSE. Reflected shifts to the right and covers algorithms\nwith both those parameters true. (If you want one parameter true and\nthe other false, you'll have to figure it out for yourself!) The\npolynomial is embedded in the lookup table (to be discussed). The\nother parameters, Init and XorOt can be coded as macros. Here is the\n32-bit normal form (the 16-bit form is similar).\n\n   unsigned long crc_normal ();\n   unsigned long crc_normal (blk_adr,blk_len)\n   unsigned char *blk_adr;\n   unsigned long  blk_len;\n   {\n    unsigned long crc = INIT;\n    while (blk_len--)\n       crc = crctable\u00dd((crc>>24) \u00ac *blk_adr++) & 0xFFL\u00a8 \u00ac (crc << 8);\n    return crc \u00ac XOROT;\n   }\n\nHere is the reflected form:\n\n   unsigned long crc_reflected ();\n   unsigned long crc_reflected (blk_adr,blk_len)\n   unsigned char *blk_adr;\n   unsigned long  blk_len;\n   {\n    unsigned long crc = INIT_REFLECTED;\n    while (blk_len--)\n       crc = crctable\u00dd(crc \u00ac *blk_adr++) & 0xFFL\u00a8 \u00ac (crc >> 8));\n    return crc \u00ac XOROT;\n   }\n\nNote: I have carefully checked the above two code fragments, but I\nhaven't actually compiled or tested them. This shouldn't matter to\nyou, as, no matter WHAT you code, you will always be able to tell if\nyou have got it right by running whatever you have created against the\nreference model given earlier. The code fragments above are really\njust a rough guide. The reference model is the definitive guide.\n\nNote: If you don't care much about speed, just use the reference model\ncode!\n\n\n19. Generating A Lookup Table\n-----------------------------\nThe only component missing from the normal and reversed code fragments\nin the previous section is the lookup table. The lookup table can be\ncomputed at run time using the cm_tab function of the model package\ngiven earlier, or can be pre-computed and inserted into the C program.\nIn either case, it should be noted that the lookup table depends only\non the POLY and RefIn (and RefOt) parameters. Basically, the\npolynomial determines the table, but you can generate a reflected\ntable too if you want to use the reflected form above.\n\nThe following program generates any desired 16-bit or 32-bit lookup\ntable. Skip to the word \"Summary\" if you want to skip over this code.\n\n\n\n/******************************************************************************/\n/*                             Start of crctable.c                            */\n/******************************************************************************/\n/*                                                                            */\n/* Author  : Ross Williams (ross@guest.adelaide.edu.au.).                     */\n/* Date    : 3 June 1993.                                                     */\n/* Version : 1.0.                                                             */\n/* Status  : Public domain.                                                   */\n/*                                                                            */\n/* Description : This program writes a CRC lookup table (suitable for         */\n/* inclusion in a C program) to a designated output file. The program can be  */\n/* statically configured to produce any table covered by the Rocksoft\u00actm      */\n/* Model CRC Algorithm. For more information on the Rocksoft\u00actm Model CRC     */\n/* Algorithm, see the document titled \"A Painless Guide to CRC Error          */\n/* Detection Algorithms\" by Ross Williams (ross@guest.adelaide.edu.au.). This */\n/* document is likely to be in \"ftp.adelaide.edu.au/pub/rocksoft\".            */\n/*                                                                            */\n/* Note: Rocksoft is a trademark of Rocksoft Pty Ltd, Adelaide, Australia.    */\n/*                                                                            */\n/******************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include \"crcmodel.h\"\n\n/******************************************************************************/\n\n/* TABLE PARAMETERS                                                           */\n/* ================                                                           */\n/* The following parameters entirely determine the table to be generated. You */\n/* should need to modify only the definitions in this section before running  */\n/* this program.                                                              */\n/*                                                                            */\n/*    TB_FILE  is the name of the output file.                                */\n/*    TB_WIDTH is the table width in bytes (either 2 or 4).                   */\n/*    TB_POLY  is the \"polynomial\", which must be TB_WIDTH bytes wide.        */\n/*    TB_REVER indicates whether the table is to be reversed (reflected).     */\n/*                                                                            */\n/* Example:                                                                   */\n/*                                                                            */\n/*    #define TB_FILE   \"crctable.out\"                                        */\n/*    #define TB_WIDTH  2                                                     */\n/*    #define TB_POLY   0x8005L                                               */\n/*    #define TB_REVER  TRUE                                                  */\n\n#define TB_FILE   \"crctable.out\"\n#define TB_WIDTH  4\n#define TB_POLY   0x04C11DB7L\n#define TB_REVER  TRUE\n\n/******************************************************************************/\n\n/* Miscellaneous definitions. */\n\n#define LOCAL static\nFILE *outfile;\n#define WR(X) fprintf(outfile,(X))\n#define WP(X,Y) fprintf(outfile,(X),(Y))\n\n/******************************************************************************/\n\nLOCAL void chk_err P_((char *));\nLOCAL void chk_err (mess)\n/* If mess is non-empty, write it out and abort. Otherwise, check the error   */\n/* status of outfile and abort if an error has occurred.                      */\nchar *mess;\n{\n if (mess\u00dd0\u00a8 != 0   ) {printf(\"%s\\n\",mess); exit(EXIT_FAILURE);}\n if (ferror(outfile)) {perror(\"chk_err\");   exit(EXIT_FAILURE);}\n}\n\n/******************************************************************************/\n\nLOCAL void chkparam P_((void));\nLOCAL void chkparam ()\n{\n if ((TB_WIDTH != 2) && (TB_WIDTH != 4))\n    chk_err(\"chkparam: Width parameter is illegal.\");\n if ((TB_WIDTH == 2) && (TB_POLY & 0xFFFF0000L))\n    chk_err(\"chkparam: Poly parameter is too wide.\");\n if ((TB_REVER != FALSE) && (TB_REVER != TRUE))\n    chk_err(\"chkparam: Reverse parameter is not boolean.\");\n}\n\n/******************************************************************************/\n\nLOCAL void gentable P_((void));\nLOCAL void gentable ()\n{\n WR(\"/*****************************************************************/\\n\");\n WR(\"/*                                                               */\\n\");\n WR(\"/* CRC LOOKUP TABLE                                              */\\n\");\n WR(\"/* ================                                              */\\n\");\n WR(\"/* The following CRC lookup table was generated automagically    */\\n\");\n WR(\"/* by the Rocksoft\u00actm Model CRC Algorithm Table Generation       */\\n\");\n WR(\"/* Program V1.0 using the following model parameters:            */\\n\");\n WR(\"/*                                                               */\\n\");\n WP(\"/*    Width   : %1lu bytes.                                         */\\n\",\n    (ulong) TB_WIDTH);\n if (TB_WIDTH == 2)\n WP(\"/*    Poly    : 0x%04lX                                           */\\n\",\n    (ulong) TB_POLY);\n else\n WP(\"/*    Poly    : 0x%08lXL                                      */\\n\",\n    (ulong) TB_POLY);\n if (TB_REVER)\n WR(\"/*    Reverse : TRUE.                                            */\\n\");\n else\n WR(\"/*    Reverse : FALSE.                                           */\\n\");\n WR(\"/*                                                               */\\n\");\n WR(\"/* For more information on the Rocksoft\u00actm Model CRC Algorithm,  */\\n\");\n WR(\"/* see the document titled \\\"A Painless Guide to CRC Error        */\\n\");\n WR(\"/* Detection Algorithms\\\" by Ross Williams                        */\\n\");\n WR(\"/* (ross@guest.adelaide.edu.au.). This document is likely to be  */\\n\");\n WR(\"/* in the FTP archive \\\"ftp.adelaide.edu.au/pub/rocksoft\\\".        */\\n\");\n WR(\"/*                                                               */\\n\");\n WR(\"/*****************************************************************/\\n\");\n WR(\"\\n\");\n switch (TB_WIDTH)\n   {\n    case 2: WR(\"unsigned short crctable\u00dd256\u00a8 =\\n{\\n\"); break;\n    case 4: WR(\"unsigned long  crctable\u00dd256\u00a8 =\\n{\\n\"); break;\n    default: chk_err(\"gentable: TB_WIDTH is invalid.\");\n   }\n chk_err(\"\");\n\n {\n  int i;\n  cm_t cm;\n  char *form    = (TB_WIDTH==2) ? \"0x%04lX\" : \"0x%08lXL\";\n  int   perline = (TB_WIDTH==2) ? 8 : 4;\n\n  cm.cm_width = TB_WIDTH*8;\n  cm.cm_poly  = TB_POLY;\n  cm.cm_refin = TB_REVER;\n\n  for (i=0; i<256; i++)\n    {\n     WR(\" \");\n     WP(form,(ulong) cm_tab(&cm,i));\n     if (i != 255) WR(\",\");\n     if (((i+1) % perline) == 0) WR(\"\\n\");\n     chk_err(\"\");\n    }\n\n WR(\"};\\n\");\n WR(\"\\n\");\n WR(\"/*****************************************************************/\\n\");\n WR(\"/*                   End of CRC Lookup Table                     */\\n\");\n WR(\"/*****************************************************************/\\n\");\n WR(\"\");\n chk_err(\"\");\n}\n}\n\n/******************************************************************************/\n\nmain ()\n{\n printf(\"\\n\");\n printf(\"Rocksoft\u00actm Model CRC Algorithm Table Generation Program V1.0\\n\");\n printf(\"-------------------------------------------------------------\\n\");\n printf(\"Output file is \\\"%s\\\".\\n\",TB_FILE);\n chkparam();\n outfile = fopen(TB_FILE,\"w\"); chk_err(\"\");\n gentable();\n if (fclose(outfile) != 0)\n    chk_err(\"main: Couldn't close output file.\");\n printf(\"\\nSUCCESS: The table has been successfully written.\\n\");\n}\n\n/******************************************************************************/\n/*                             End of crctable.c                              */\n/******************************************************************************/\n\n20. Summary\n-----------\nThis document has provided a detailed explanation of CRC algorithms\nexplaining their theory and stepping through increasingly\nsophisticated implementations ranging from simple bit shifting through\nto byte-at-a-time table-driven implementations. The various\nimplementations of different CRC algorithms that make them confusing\nto deal with have been explained. A parameterized model algorithm has\nbeen described that can be used to precisely define a particular CRC\nalgorithm, and a reference implementation provided. Finally, a program\nto generate CRC tables has been provided.\n\n21. Corrections\n---------------\nIf you think that any part of this document is unclear or incorrect,\nor have any other information, or suggestions on how this document\ncould be improved, please context the author. In particular, I would\nlike to hear from anyone who can provide Rocksoft\u00actm Model CRC\nAlgorithm parameters for standard algorithms out there.\n\nA. Glossary\n-----------\nCHECKSUM - A number that has been calculated as a function of some\nmessage. The literal interpretation of this word \"Check-Sum\" indicates\nthat the function should involve simply adding up the bytes in the\nmessage. Perhaps this was what early checksums were. Today, however,\nalthough more sophisticated formulae are used, the term \"checksum\" is\nstill used.\n\nCRC - This stands for \"Cyclic Redundancy Code\". Whereas the term\n\"checksum\" seems to be used to refer to any non-cryptographic checking\ninformation unit, the term \"CRC\" seems to be reserved only for\nalgorithms that are based on the \"polynomial\" division idea.\n\nG - This symbol is used in this document to represent the Poly.\n\nMESSAGE - The input data being checksummed. This is usually structured\nas a sequence of bytes. Whether the top bit or the bottom bit of each\nbyte is treated as the most significant or least significant is a\nparameter of CRC algorithms.\n\nPOLY - This is my friendly term for the polynomial of a CRC.\n\nPOLYNOMIAL - The \"polynomial\" of a CRC algorithm is simply the divisor\nin the division implementing the CRC algorithm.\n\nREFLECT - A binary number is reflected by swapping all of its bits\naround the central point. For example, 1101 is the reflection of 1011.\n\nROCKSOFT\u00acTM MODEL CRC ALGORITHM - A parameterized algorithm whose\npurpose is to act as a solid reference for describing CRC algorithms.\nTypically CRC algorithms are specified by quoting a polynomial.\nHowever, in order to construct a precise implementation, one also\nneeds to know initialization values and so on.\n\nWIDTH - The width of a CRC algorithm is the width of its polynomical\nminus one. For example, if the polynomial is 11010, the width would be\n4 bits. The width is usually set to be a multiple of 8 bits.\n\nB. References\n-------------\n\u00ddGriffiths87\u00a8 Griffiths, G., Carlyle Stones, G., \"The Tea-Leaf Reader\nAlgorithm: An Efficient Implementation of CRC-16 and CRC-32\",\nCommunications of the ACM, 30(7), pp.617-620. Comment: This paper\ndescribes a high-speed table-driven implementation of CRC algorithms.\nThe technique seems to be a touch messy, and is superceded by the\nSarwete algorithm.\n\n\u00ddKnuth81\u00a8 Knuth, D.E., \"The Art of Computer Programming\", Volume 2:\nSeminumerical Algorithms, Section 4.6.\n\n\u00ddNelson 91\u00a8 Nelson, M., \"The Data Compression Book\", M&T Books, (501\nGalveston Drive, Redwood City, CA 94063), 1991, ISBN: 1-55851-214-4.\nComment: If you want to see a real implementation of a real 32-bit\nchecksum algorithm, look on pages 440, and 446-448.\n\n\u00ddSarwate88\u00a8 Sarwate, D.V., \"Computation of Cyclic Redundancy Checks\nvia Table Look-Up\", Communications of the ACM, 31(8), pp.1008-1013.\nComment: This paper describes a high-speed table-driven implementation\nfor CRC algorithms that is superior to the tea-leaf algorithm.\nAlthough this paper describes the technique used by most modern CRC\nimplementations, I found the appendix of this paper (where all the\ngood stuff is) difficult to understand.\n\n\u00ddTanenbaum81\u00a8 Tanenbaum, A.S., \"Computer Networks\", Prentice Hall,\n1981, ISBN: 0-13-164699-0. Comment: Section 3.5.3 on pages 128 to 132\nprovides a very clear description of CRC codes. However, it does not\ndescribe table-driven implementation techniques.\n\n\nC. References I Have Detected But Haven't Yet Sighted\n-----------------------------------------------------\nBoudreau, Steen, \"Cyclic Redundancy Checking by Program,\" AFIPS\nProceedings, Vol. 39, 1971.\n\nDavies, Barber, \"Computer Networks and Their Protocols,\" J. Wiley &\nSons, 1979.\n\nHigginson, Kirstein, \"On the Computation of Cyclic Redundancy Checks\nby Program,\" The Computer Journal (British), Vol. 16, No. 1, Feb 1973.\n\nMcNamara, J. E., \"Technical Aspects of Data Communication,\" 2nd\nEdition, Digital Press, Bedford, Massachusetts, 1982.\n\nMarton and Frambs, \"A Cyclic Redundancy Checking (CRC) Algorithm,\"\nHoneywell Computer Journal, Vol. 5, No. 3, 1971.\n\nNelson M., \"File verification using CRC\", Dr Dobbs Journal, May 1992,\npp.64-67.\n\nRamabadran T.V., Gaitonde S.S., \"A tutorial on CRC computations\", IEEE\nMicro, Aug 1988.\n\nSchwaderer W.D., \"CRC Calculation\", April 85 PC Tech Journal,\npp.118-133.\n\nWard R.K, Tabandeh M., \"Error Correction and Detection, A Geometric\nApproach\" The Computer Journal, Vol. 27, No. 3, 1984, pp.246-253.\n\nWecker, S., \"A Table-Lookup Algorithm for Software Computation of\nCyclic Redundancy Check (CRC),\" Digital Equipment Corporation\nmemorandum, 1974.\n\n--<End of Document>--\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CRC32": {"ttr": 1288, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00\\x00\\x01\\x00\\x00o\\x01\\x01\\x00?\\x15\\x19\\x00\\xcb\\x00c\\x00\\x00\\xd1\\xc3\\xd6\\xd5\\xd5@@@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2001-01-03T15:19:00", "lines": 203, "newlines": 99, "modlines": 0, "user": "JCONN"}, "text": "CRCTEST  CSECT\n*+-------------------------------------------------------------------+*\n*|  CRCTEST                                                          |*\n*|                                                                   |*\n*|  THIS TEST PROGRAM DRIVES A CRC32 ROUTINE AND DISPLAYS THE        |*\n*|  RESULTS.                                                         |*\n*|                                                                   |*\n*|  WE CAN USE THE ACTUAL PROGRAM AREA AS \"TEST DATA\".  SINCE WE     |*\n*|  MODIFY WORKING STORAGE DURING EXECUTION, MULTIPLE CALLS WILL     |*\n*|  YIELD DIFFERENT RESULTS.                                         |*\n*|                                                                   |*\n*|  WRITTEN BY JIM CONNELLEY  FOR CBTTAPE FILE 493                   |*\n*|                                                                   |*\n*+-------------------------------------------------------------------+*\nCRCTEST  AMODE 31\nCRCTEST  RMODE ANY\n         SAVE  (14,12)\n         LR    R12,R15             BASE REG\n         USING CRCTEST,R12         TELL THE ASSEMBLER\n         ST    R13,SAVEAREA+4\n         LA    R13,SAVEAREA\n*\n         BAL   R11,CALLIT          FIRST CALL\n         BAL   R11,CALLIT          SECOND CALL\n         BAL   R11,CALLIT          THIRD CALL\n*\n         LA    R15,0\n         L     R13,SAVEAREA+4\n         RETURN (14,12),RC=0\n*+-------------------------------------------------------------------+*\n*|  CALLIT                                                           |*\n*|  CALL CRC32 ROUTINE AND DISPLAY RESULTS.                          |*\n*+-------------------------------------------------------------------+*\nCALLIT   DS    0H\n         MVC   CALLPARM,=A(ADDRESS,LENGTH,INITIAL)\n         LA    R1,CALLPARM         ADDRESS OF PARM LIST\n         LA    R15,CRC32           ADDRESS OF THE ROUTINE\n         BALR  R14,R15             COMPUTE CRC\n         ST    R15,FULLWORD        SAVE CRC VALUE\n         UNPK  HEX,FULLWORD(5)     UNPACK RETURNED VALUE\n         TR    HEX,TOHEX           TRANSLATE TO HEX\n         MVC   HEXDISPL,HEX        MOVE TO MESSAGE\n         WTO   MF=(E,WTOMSG)       DISPLAY THE VALUE\n         BR    R11                 RETURN TO CALLER\n*\nADDRESS  EQU   CRCTEST             BEGINNING ADDRESS\nLENGTH   EQU   LASTBYTE-CRCTEST    # BYTES TO PROCESS\nINITIAL  EQU   X'FFFFFFFF'         INITIAL VALUE OF CRC\n*+-------------------------------------------------------------------+*\n*|  WORKING STORAGE                                                  |*\n*+-------------------------------------------------------------------+*\nSAVEAREA DS   18F                  STANDARD SAVEAREA\n*        WTO ROUTCDE=11 IS FOR PROGRAMMER INFORMATION\nWTOMSG   WTO   'CRC32 VALUE: ........',ROUTCDE=11,MF=L\n         ORG   *-12                ORG BACK INTO WTO TEXT\nHEXDISPL DS    CL8                 AREA FOR CRC VALUE\n         ORG   ,                   RESET LOCATION COUNTER\nHEX      DS    CL9                 UNPACK AREA\nFULLWORD DS    F                   FULLWORD TO BE UNPACKED\n*\nCALLPARM DS    CL12                AREA\n*\n*----------------------------------------------------------------*\n* FOLLOWING IS TRANSLATE TABLE FOR HEX DATA\n*----------------------------------------------------------------*\nTOHEX    DC  256C' '\n         ORG   TOHEX+C'0'\n         DC    C'0123456789ABCDEF'\n*+-------------------------------------------------------------------+*\n*|  EVERYTHING ABOVE THIS LINE IS THE TEST DRIVER PROGRAM            |*\n*+-------------------------------------------------------------------+*\n*|                                                                   |*\n*|  C R C 3 2                                                        |*\n*|                                                                   |*\n*|  THIS ROUTINE CALCULATES A 32-BIT CYCLIC REDUNDANCY CHECK         |*\n*|  VALUE FOR THE SUPPLIED INPUT DATA.                               |*\n*|                                                                   |*\n*|  THIS CODE BASED UPON DOCUMENTATION AND ALGORITHMS PROVIDED BY    |*\n*|  BY DR. ROSS N. WILLIAMS IN THE DOCUMENT \"A PAINLESS GUIDE TO     |*\n*|  CRC ERROR DETECTION ALGORITHMS.\" REFERENCE TO THIS FTP DOCUMENT  |*\n*|  FOUND AT:                                                        |*\n*|      HTTP://WWW.NAACCR.ORG/STANDARD/CRC32/DOCUMENT.HTML.          |*\n*|  THE ORIGINAL DOCUMENT WAS ACTUALLY FOUND AT:                     |*\n*|      FTP://FTP.ROCKSOFT.COM/PAPERS/CRC_V3.TXT                     |*\n*|                                                                   |*\n*|   CALLING PARMS                                                   |*\n*|     0(,R1) ADDRESS OF DATA TO BE CRC'D                            |*\n*|     4(,R1) LENGTH  OF DATA TO BE CRC'D                            |*\n*|     8(,R1) INITIAL VALUE FOR CRC                                  |*\n*|                                                                   |*\n*|   RETURN VALUE:                                                   |*\n*|     R15: COMPUTED CRC VALUE                                       |*\n*|                                                                   |*\n*+-------------------------------------------------------------------+*\nCRC32    SAVE  (14,12)\n*\n         LR    R12,R15             BASE REG\n         USING CRC32,R12           TELL THE ASSEMBLER\n*\n         LM    R4,R6,0(R1)         ADDRESS, LENGTH AND INITIAL VALUE\n         L     R7,=X'000000FF'     FAST \"AND\" VALUE\n*\nCRC32LP  DS    0H\n         SLR   R8,R8               CLEAR WORKING REGISTER\n         IC    R8,0(,R4)           INSERT NEXT CHARACTER\n         XR    R8,R6               APPLY ACCUMULATED CRC\n         NR    R8,R7               CLEAR ALL BUT LOW ORDER BYTE\n         SLL   R8,2                VALUE TIMES 4 = TABLE OFFSET\n         SRL   R6,8                SHIFT ACCUMULATION FOR NEW BYTE\n         X     R6,CRC32TAB(R8)     APPLY THE POLYNOMIAL\n         LA    R4,1(,R4)           POINT TO NEXT INPUT BYTE\n         BCT   R5,CRC32LP          PROCESS ALL INPUT BYTES\n*\n         X     R6,=X'FFFFFFFF'     FINAL XOR\n         LR    R15,R6              RETURN REGISTER\n         RETURN (14,12),RC=(15)\n*+-------------------------------------------------------------------+*\n*|  TABLE OF POLYNOMIAL VALUES USED TO CREATE A 32 BIT CRC           |*\n*+-------------------------------------------------------------------+*\n         DS    0F                  FORCE FULLWORD ALIGNMENT\nCRC32TAB DC    X'00000000',X'77073096',X'EE0E612C',X'990951BA'  00-03\n         DC    X'076DC419',X'706AF48F',X'E963A535',X'9E6495A3'  04-07\n         DC    X'0EDB8832',X'79DCB8A4',X'E0D5E91E',X'97D2D988'  08-0B\n         DC    X'09B64C2B',X'7EB17CBD',X'E7B82D07',X'90BF1D91'  0C-0F\n         DC    X'1DB71064',X'6AB020F2',X'F3B97148',X'84BE41DE'  10-13\n         DC    X'1ADAD47D',X'6DDDE4EB',X'F4D4B551',X'83D385C7'  14-17\n         DC    X'136C9856',X'646BA8C0',X'FD62F97A',X'8A65C9EC'  18-1B\n         DC    X'14015C4F',X'63066CD9',X'FA0F3D63',X'8D080DF5'  1C-1F\n         DC    X'3B6E20C8',X'4C69105E',X'D56041E4',X'A2677172'  20-23\n         DC    X'3C03E4D1',X'4B04D447',X'D20D85FD',X'A50AB56B'  24-27\n         DC    X'35B5A8FA',X'42B2986C',X'DBBBC9D6',X'ACBCF940'  28-2B\n         DC    X'32D86CE3',X'45DF5C75',X'DCD60DCF',X'ABD13D59'  2C-2F\n         DC    X'26D930AC',X'51DE003A',X'C8D75180',X'BFD06116'  30-33\n         DC    X'21B4F4B5',X'56B3C423',X'CFBA9599',X'B8BDA50F'  34-37\n         DC    X'2802B89E',X'5F058808',X'C60CD9B2',X'B10BE924'  38-3B\n         DC    X'2F6F7C87',X'58684C11',X'C1611DAB',X'B6662D3D'  3C-3F\n         DC    X'76DC4190',X'01DB7106',X'98D220BC',X'EFD5102A'  40-43\n         DC    X'71B18589',X'06B6B51F',X'9FBFE4A5',X'E8B8D433'  44-47\n         DC    X'7807C9A2',X'0F00F934',X'9609A88E',X'E10E9818'  48-4B\n         DC    X'7F6A0DBB',X'086D3D2D',X'91646C97',X'E6635C01'  4C-4F\n         DC    X'6B6B51F4',X'1C6C6162',X'856530D8',X'F262004E'  50-53\n         DC    X'6C0695ED',X'1B01A57B',X'8208F4C1',X'F50FC457'  54-57\n         DC    X'65B0D9C6',X'12B7E950',X'8BBEB8EA',X'FCB9887C'  58-5B\n         DC    X'62DD1DDF',X'15DA2D49',X'8CD37CF3',X'FBD44C65'  5C-5F\n         DC    X'4DB26158',X'3AB551CE',X'A3BC0074',X'D4BB30E2'  60-63\n         DC    X'4ADFA541',X'3DD895D7',X'A4D1C46D',X'D3D6F4FB'  64-67\n         DC    X'4369E96A',X'346ED9FC',X'AD678846',X'DA60B8D0'  68-6B\n         DC    X'44042D73',X'33031DE5',X'AA0A4C5F',X'DD0D7CC9'  6C-6F\n         DC    X'5005713C',X'270241AA',X'BE0B1010',X'C90C2086'  70-73\n         DC    X'5768B525',X'206F85B3',X'B966D409',X'CE61E49F'  74-77\n         DC    X'5EDEF90E',X'29D9C998',X'B0D09822',X'C7D7A8B4'  78-7B\n         DC    X'59B33D17',X'2EB40D81',X'B7BD5C3B',X'C0BA6CAD'  7C-7F\n         DC    X'EDB88320',X'9ABFB3B6',X'03B6E20C',X'74B1D29A'  80-83\n         DC    X'EAD54739',X'9DD277AF',X'04DB2615',X'73DC1683'  84-87\n         DC    X'E3630B12',X'94643B84',X'0D6D6A3E',X'7A6A5AA8'  88-8B\n         DC    X'E40ECF0B',X'9309FF9D',X'0A00AE27',X'7D079EB1'  8C-8F\n         DC    X'F00F9344',X'8708A3D2',X'1E01F268',X'6906C2FE'  90-93\n         DC    X'F762575D',X'806567CB',X'196C3671',X'6E6B06E7'  94-97\n         DC    X'FED41B76',X'89D32BE0',X'10DA7A5A',X'67DD4ACC'  98-9B\n         DC    X'F9B9DF6F',X'8EBEEFF9',X'17B7BE43',X'60B08ED5'  9C-9F\n         DC    X'D6D6A3E8',X'A1D1937E',X'38D8C2C4',X'4FDFF252'  A0-A3\n         DC    X'D1BB67F1',X'A6BC5767',X'3FB506DD',X'48B2364B'  A4-A7\n         DC    X'D80D2BDA',X'AF0A1B4C',X'36034AF6',X'41047A60'  A8-AB\n         DC    X'DF60EFC3',X'A867DF55',X'316E8EEF',X'4669BE79'  AC-AF\n         DC    X'CB61B38C',X'BC66831A',X'256FD2A0',X'5268E236'  B0-B3\n         DC    X'CC0C7795',X'BB0B4703',X'220216B9',X'5505262F'  B4-B7\n         DC    X'C5BA3BBE',X'B2BD0B28',X'2BB45A92',X'5CB36A04'  B8-BB\n         DC    X'C2D7FFA7',X'B5D0CF31',X'2CD99E8B',X'5BDEAE1D'  BC-BF\n         DC    X'9B64C2B0',X'EC63F226',X'756AA39C',X'026D930A'  C0-C3\n         DC    X'9C0906A9',X'EB0E363F',X'72076785',X'05005713'  C4-C7\n         DC    X'95BF4A82',X'E2B87A14',X'7BB12BAE',X'0CB61B38'  C8-CB\n         DC    X'92D28E9B',X'E5D5BE0D',X'7CDCEFB7',X'0BDBDF21'  CC-CF\n         DC    X'86D3D2D4',X'F1D4E242',X'68DDB3F8',X'1FDA836E'  D0-D3\n         DC    X'81BE16CD',X'F6B9265B',X'6FB077E1',X'18B74777'  D4-D7\n         DC    X'88085AE6',X'FF0F6A70',X'66063BCA',X'11010B5C'  D8-DB\n         DC    X'8F659EFF',X'F862AE69',X'616BFFD3',X'166CCF45'  DC-DF\n         DC    X'A00AE278',X'D70DD2EE',X'4E048354',X'3903B3C2'  E0-E3\n         DC    X'A7672661',X'D06016F7',X'4969474D',X'3E6E77DB'  E4-E7\n         DC    X'AED16A4A',X'D9D65ADC',X'40DF0B66',X'37D83BF0'  E8-EB\n         DC    X'A9BCAE53',X'DEBB9EC5',X'47B2CF7F',X'30B5FFE9'  EC-EF\n         DC    X'BDBDF21C',X'CABAC28A',X'53B39330',X'24B4A3A6'  F0-F3\n         DC    X'BAD03605',X'CDD70693',X'54DE5729',X'23D967BF'  F4-F7\n         DC    X'B3667A2E',X'C4614AB8',X'5D681B02',X'2A6F2B94'  F8-FB\n         DC    X'B40BBE37',X'C30C8EA1',X'5A05DF1B',X'2D02EF8D'  FC-FF\nLASTBYTE EQU   *\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CRC32REF": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x10\\x10\\x00{\\x00{\\x00\\x00\\xd1\\xc3\\xd6\\xd5\\xd5@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T10:10:00", "lines": 123, "newlines": 123, "modlines": 0, "user": "JCONN"}, "text": "                   NAACCR CRC CHECKSUM\n\nThe standard for calculating the 32 bit CRC checksum for NAACCR\nrecords is based upon documentation and algorithms provided by\nDr.  Ross N. Williams in the document \"A Painless Guide to CRC\nError Detection Algorithms.\" This document may be downloaded from\n\nftp://ftp.rocksoft.com/cliens/rocksoft/papers/crc_v3.txt as of\n12/15/1998.  Dr. Williams has placed this document and algorithms\nin the public domain.  Any use of these algorithms should give\ncredit to this source.\n\nThe NAACCR implementation follows the \"reflected\" table-driven\nimplementation defined by Dr. Williams. The CRC-32 parameter set\nreportedly used in PKZip, Ethernet, and FDDI has been used. The\ncomplete parameter set is specified below:\n\nName    : \"CRC-32\"\nWidth   : 32\nPoly    : 04C11DB7\nInit    : FFFFFFFF\nRefIn   : True\nRefOut  : True\nXorOut  : FFFFFFFF\nCheck   : CBF43926\n\nTo assist in the implementation of this algorithm, 'C' programs\nand header files for calculating, assigning, and comparing\nchecksums have been developed by Eric Durbin (Kentucky Cancer\nRegistry) and placed in the public domain. A test suite for\nstandard data and NAACCR records has also been developed. Please\nsee the NAACCR website\n\n\"http://www.naaccr.org/standard/standards.html\" for details.\nThe pseudocode algorithm follows.\n\nPseudocode Algorithm\n\n\n     Initialize crc_value to 0xFFFFFFFFL\n\n For each byte in NAACCR record (Excluding CRC CHECKSUM field) {\n   crc_value = (CRCTABLE value at (crc_value XOR byte_value) AND 0xFFL)\n      XOR (crc_value RIGHTSHIFTED 8 bits);\n        }\n\n     Return crc_value XOR 0xFFFFFFFFL\n\nCRCTABLE is the pre-calculated lookup table provided for this\nimplementation:\n\nunsigned long  CRCTABLE[256] =\n{\n 0x00000000L, 0x77073096L, 0xEE0E612CL, 0x990951BAL,\n 0x076DC419L, 0x706AF48FL, 0xE963A535L, 0x9E6495A3L,\n 0x0EDB8832L, 0x79DCB8A4L, 0xE0D5E91EL, 0x97D2D988L,\n 0x09B64C2BL, 0x7EB17CBDL, 0xE7B82D07L, 0x90BF1D91L,\n 0x1DB71064L, 0x6AB020F2L, 0xF3B97148L, 0x84BE41DEL,\n 0x1ADAD47DL, 0x6DDDE4EBL, 0xF4D4B551L, 0x83D385C7L,\n 0x136C9856L, 0x646BA8C0L, 0xFD62F97AL, 0x8A65C9ECL,\n 0x14015C4FL, 0x63066CD9L, 0xFA0F3D63L, 0x8D080DF5L,\n 0x3B6E20C8L, 0x4C69105EL, 0xD56041E4L, 0xA2677172L,\n 0x3C03E4D1L, 0x4B04D447L, 0xD20D85FDL, 0xA50AB56BL,\n 0x35B5A8FAL, 0x42B2986CL, 0xDBBBC9D6L, 0xACBCF940L,\n 0x32D86CE3L, 0x45DF5C75L, 0xDCD60DCFL, 0xABD13D59L,\n 0x26D930ACL, 0x51DE003AL, 0xC8D75180L, 0xBFD06116L,\n 0x21B4F4B5L, 0x56B3C423L, 0xCFBA9599L, 0xB8BDA50FL,\n 0x2802B89EL, 0x5F058808L, 0xC60CD9B2L, 0xB10BE924L,\n 0x2F6F7C87L, 0x58684C11L, 0xC1611DABL, 0xB6662D3DL,\n 0x76DC4190L, 0x01DB7106L, 0x98D220BCL, 0xEFD5102AL,\n 0x71B18589L, 0x06B6B51FL, 0x9FBFE4A5L, 0xE8B8D433L,\n 0x7807C9A2L, 0x0F00F934L, 0x9609A88EL, 0xE10E9818L,\n 0x7F6A0DBBL, 0x086D3D2DL, 0x91646C97L, 0xE6635C01L,\n 0x6B6B51F4L, 0x1C6C6162L, 0x856530D8L, 0xF262004EL,\n 0x6C0695EDL, 0x1B01A57BL, 0x8208F4C1L, 0xF50FC457L,\n 0x65B0D9C6L, 0x12B7E950L, 0x8BBEB8EAL, 0xFCB9887CL,\n 0x62DD1DDFL, 0x15DA2D49L, 0x8CD37CF3L, 0xFBD44C65L,\n 0x4DB26158L, 0x3AB551CEL, 0xA3BC0074L, 0xD4BB30E2L,\n 0x4ADFA541L, 0x3DD895D7L, 0xA4D1C46DL, 0xD3D6F4FBL,\n 0x4369E96AL, 0x346ED9FCL, 0xAD678846L, 0xDA60B8D0L,\n 0x44042D73L, 0x33031DE5L, 0xAA0A4C5FL, 0xDD0D7CC9L,\n 0x5005713CL, 0x270241AAL, 0xBE0B1010L, 0xC90C2086L,\n 0x5768B525L, 0x206F85B3L, 0xB966D409L, 0xCE61E49FL,\n 0x5EDEF90EL, 0x29D9C998L, 0xB0D09822L, 0xC7D7A8B4L,\n 0x59B33D17L, 0x2EB40D81L, 0xB7BD5C3BL, 0xC0BA6CADL,\n 0xEDB88320L, 0x9ABFB3B6L, 0x03B6E20CL, 0x74B1D29AL,\n 0xEAD54739L, 0x9DD277AFL, 0x04DB2615L, 0x73DC1683L,\n 0xE3630B12L, 0x94643B84L, 0x0D6D6A3EL, 0x7A6A5AA8L,\n 0xE40ECF0BL, 0x9309FF9DL, 0x0A00AE27L, 0x7D079EB1L,\n 0xF00F9344L, 0x8708A3D2L, 0x1E01F268L, 0x6906C2FEL,\n 0xF762575DL, 0x806567CBL, 0x196C3671L, 0x6E6B06E7L,\n 0xFED41B76L, 0x89D32BE0L, 0x10DA7A5AL, 0x67DD4ACCL,\n 0xF9B9DF6FL, 0x8EBEEFF9L, 0x17B7BE43L, 0x60B08ED5L,\n 0xD6D6A3E8L, 0xA1D1937EL, 0x38D8C2C4L, 0x4FDFF252L,\n 0xD1BB67F1L, 0xA6BC5767L, 0x3FB506DDL, 0x48B2364BL,\n 0xD80D2BDAL, 0xAF0A1B4CL, 0x36034AF6L, 0x41047A60L,\n 0xDF60EFC3L, 0xA867DF55L, 0x316E8EEFL, 0x4669BE79L,\n 0xCB61B38CL, 0xBC66831AL, 0x256FD2A0L, 0x5268E236L,\n 0xCC0C7795L, 0xBB0B4703L, 0x220216B9L, 0x5505262FL,\n 0xC5BA3BBEL, 0xB2BD0B28L, 0x2BB45A92L, 0x5CB36A04L,\n 0xC2D7FFA7L, 0xB5D0CF31L, 0x2CD99E8BL, 0x5BDEAE1DL,\n 0x9B64C2B0L, 0xEC63F226L, 0x756AA39CL, 0x026D930AL,\n 0x9C0906A9L, 0xEB0E363FL, 0x72076785L, 0x05005713L,\n 0x95BF4A82L, 0xE2B87A14L, 0x7BB12BAEL, 0x0CB61B38L,\n 0x92D28E9BL, 0xE5D5BE0DL, 0x7CDCEFB7L, 0x0BDBDF21L,\n 0x86D3D2D4L, 0xF1D4E242L, 0x68DDB3F8L, 0x1FDA836EL,\n 0x81BE16CDL, 0xF6B9265BL, 0x6FB077E1L, 0x18B74777L,\n 0x88085AE6L, 0xFF0F6A70L, 0x66063BCAL, 0x11010B5CL,\n 0x8F659EFFL, 0xF862AE69L, 0x616BFFD3L, 0x166CCF45L,\n 0xA00AE278L, 0xD70DD2EEL, 0x4E048354L, 0x3903B3C2L,\n 0xA7672661L, 0xD06016F7L, 0x4969474DL, 0x3E6E77DBL,\n 0xAED16A4AL, 0xD9D65ADCL, 0x40DF0B66L, 0x37D83BF0L,\n 0xA9BCAE53L, 0xDEBB9EC5L, 0x47B2CF7FL, 0x30B5FFE9L,\n 0xBDBDF21CL, 0xCABAC28AL, 0x53B39330L, 0x24B4A3A6L,\n 0xBAD03605L, 0xCDD70693L, 0x54DE5729L, 0x23D967BFL,\n 0xB3667A2EL, 0xC4614AB8L, 0x5D681B02L, 0x2A6F2B94L,\n 0xB40BBE37L, 0xC30C8EA1L, 0x5A05DF1BL, 0x2D02EF8DL\n};\n\nAllowable values in NAACCR record:\n\nNumeric, uppercase hexadecimal, right-justified, zero-filled,\nor blank.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CRC32STD": {"ttr": 1540, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x10\\t\\x00 \\x00 \\x00\\x00\\xd1\\xc3\\xd6\\xd5\\xd5@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T10:09:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "JCONN"}, "text": "                 CRC CHECKSUM Implementation Guide\n\nThis document may be used as an implementation guide for the NAACCR\nstandard CRC CHECKSUM. This field will help ensure integrity of\nNAACCR records when they are transmitted electronically. The CRC\nCHECKSUM field should be implemented beginning with NAACCR Record\nLayout Version 7.\n\nInformation included on this page should be adequate to allow\nsoftware vendors to quickly implement the CRC Checksum field. A\n\"C\" API has been developed and contributed for public use by Eric\nDurbin. The API includes the following routines:\n\n*CalcCRC32() - Calculates and returns the CRC32 for a record.\n*AssignCRC32() - Assigns (fills in) the CRC CHECKSUM field for a record.\n*CompareCRC32() - Compares the CRC CHECKSUM field against the calculated\nCRC CHECKSUM for a record.\n\nPlease refer to the C Implementation file for further details.\n\nTest routines are also included to test the API functions.\n\n*NAACCR Field Definition\n*C API Implementation\n*C API Implementation Header File\n*C Test Program\n*Makefile\n\nFor further information contact Eric Durbin, Kentucky Cancer Registry,\n(606)257-4581, E-Mail ericd@delos.kcr.uky.edu\n\nLast Updated: December 15, 1998\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "C2F": {"ttr": 1542, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00?\\x01\\x01\\x00?\\x15\\x17\\x00\\xaa\\x00\\xaa\\x00\\x00\\xd1\\xc3\\xd6\\xd5\\xd5@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-03T00:00:00", "modifydate": "2001-01-03T15:17:00", "lines": 170, "newlines": 170, "modlines": 0, "user": "JCONN"}, "text": "        /*------------ REXX -----------------------------+\n         *                                               |\n         * Converts a number to internal float format.   |\n         * Displays the result                           |\n         * Then converts the result back out to decimal. |\n         *                                               |\n         * Written by Jim Connelley                      |\n         *                                               |\n         * Tracing thru this code is a good way to get   |\n         * familiar with IBM system 390 internal         |\n         * floating point format.                        |\n         *                                               |\n         * Created for CBTTAPE file 493.                 |\n         *                                               |\n         *-----------------------------------------------+\n         */\n        Numeric Digits 100     /* handle BIG numbers */\n        Parse Upper Arg input_val .\n        Say \"Input Value:                  \" input_val\n        If datatype(input_val) /= \"NUM\" Then Do\n          Say \"invalid value\"\n          Exit 0\n          End\n        If input_val = 0 Then Do      /* special case zero */\n          Say \"Resulting Value:               0000000000000000\"\n          Say \"Floating value converted back: 0\"\n          Exit 0\n          End\n        input_val = Format(input_val)\n\n        /*-------------------------------------------------------+\n         * Handle leading minus sign                             |\n         *-------------------------------------------------------+\n         */\n        If left(input_val,1) = \"-\" Then Do\n          Sign = \"80\"x\n          input_val = Substr(input_val,2)   /* remove sign */\n          End\n        Else Do\n          Sign = \"00\"x\n          End\n\n        /*-------------------------------------------------------+\n         * Separate input into integer and fraction              |\n         *-------------------------------------------------------+\n         */\n        Parse Var input_val input_integer \".\" input_fract\n\n        /*-------------------------------------------------------+\n         * If no fraction given, then default to zero            |\n         *-------------------------------------------------------+\n         */\n        If input_fract = \"\" Then input_fract = 0\n        input_fract = \".\"input_fract\n\n        /*-------------------------------------------------------+\n         * Convert integer portion directly                      |\n         *-------------------------------------------------------+\n         */\n        fraction = D2x(input_integer)\n        If fraction = \"0\" Then fraction = \"\"\n\n        /*-------------------------------------------------------+\n         * If there is no integer portion, then we can normalize |\n         * just the fraction portion of the input value.         |\n         *-------------------------------------------------------+\n         */\n        exponent = Length(fraction)\n        If exponent = 0 Then Do Forever\n          normalizing_fraction = input_fract * 16\n          If normalizing_fraction >= 1 Then Leave\n          input_fract = normalizing_fraction\n          exponent = exponent - 1\n          End\n\n        /*-------------------------------------------------------+\n         * compute amount to normalize                           |\n         *-------------------------------------------------------+\n         */\n        If exponent < 0 Then Do\n          amount_to_normalize = 0\n          End\n        Else Do\n          amount_to_normalize = exponent\n          End\n\n        /*-------------------------------------------------------+\n         * Normalize the fraction.                               |\n         *-------------------------------------------------------+\n         */\n        remainder = input_fract\n        Do i = 1 To (14 - amount_to_normalize)\n          normalizing_value = remainder * 16\n          quotient = normalizing_value % 1\n          remainder = normalizing_value // 1\n          fraction = fraction || D2x(quotient)\n          End\n\n        /*-------------------------------------------------------+\n         * We now have a Sign, exponent and a fraction...        |\n         * Here, just put it all together into one result value. |\n         * The bin_float variable will contain the result value  |\n         * which can be used internally for floating point       |\n         * computations.                                         |\n         *-------------------------------------------------------+\n         */\n        excess64  = exponent+64          /* excess 64 exponent */\n        hex_exp   = D2x(excess64)        /* convert to hex     */\n        bin_exp   = X2c(hex_exp)         /* convert to binary  */\n        bin_sax   = Bitor(bin_exp,Sign)  /* \"or\" sign bit      */\n        sax       = C2x(bin_sax)         /* convert to hex     */\n        hex_float = sax||fraction        /* hex float value    */\n        bin_float = X2c(hex_float)       /* binary float value */\n        result_value = Substr(hex_float,1,16)\n        Say \"Resulting floating value:     \" result_value\n\n        /*-------------------------------------------------------+\n         * Extract the sign and exponent byte                    |\n         *-------------------------------------------------------+\n         */\n        sign_and_exponent = Substr(bin_float,1,1)\n\n        /*-------------------------------------------------------+\n         * Compute the true exponent                             |\n         *-------------------------------------------------------+\n         */\n        x_exponent    = Bitand(sign_and_exponent,\"7f\"x)\n        excess_64_exp = C2d(x_exponent)\n        true_exponent = excess_64_exp - 65\n\n        /*-------------------------------------------------------+\n         * Create a factor of +1 or -1 from the sign bit         |\n         *-------------------------------------------------------+\n         */\n        sign_factor = ((Bitand(sign_and_exponent,\"80\"x)=\"00\"x)-.5)*2\n\n        /*-------------------------------------------------------+\n         * Extract the \"fraction\" part of the number             |\n         *-------------------------------------------------------+\n         */\n        fraction     = Substr(bin_float,2)\n        hex_fraction = C2x(fraction)\n        result_value = 0\n\n        /*-------------------------------------------------------+\n         * Sum the result value by processing each hex digit     |\n         *-------------------------------------------------------+\n         */\n        Do i = 1 To Length(hex_fraction)\n          hex_digit     = X2d(Substr(hex_fraction,i,1))\n          result_value  = result_value + (hex_digit * (16**true_exponent))\n          true_exponent = true_exponent - 1\n          End\n\n        /*-------------------------------------------------------+\n         * Factor in the sign                                    |\n         *-------------------------------------------------------+\n         */\n        result_value   = result_value * sign_factor\n\n        /*-------------------------------------------------------+\n         * Format the result                                     |\n         *-------------------------------------------------------+\n         */\n        print_value = Strip(Strip(Format(result_value,,14),T,0),T,.)\n        If print_value = 0 Then  /* Maybe we stripped too much */\n          print_value = Format(result_value,2,14,2,0)\n\n        Say \"Floating value converted back:\" print_value\n        Exit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VC": {"ttr": 1546, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x01\\x00\\x19/\\x01\\x01\\x00?\\x14$\\x01\\x9a\\x01\\x97\\x00\\x00\\xd1\\xc3\\xd6\\xd5\\xd5@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2000-07-10T00:00:00", "modifydate": "2001-01-03T14:24:00", "lines": 410, "newlines": 407, "modlines": 0, "user": "JCONN"}, "text": "        /*------------------- REXX -----------------------------------*\n         *                                                            *\n         * This code does not do anything other than display the      *\n         * IDCAMS control statement needed to define a VSAM file.     *\n         *                                                            *\n         * From ISPF 3.4, type VC next to a VSAM data set             *\n         *                                                            *\n         * Written by Jim Connelley.  No copyright.  Ifyawanna, (If   *\n         * you want to) send your enhancements to jim@connelley.org   *\n         *                                                            *\n         * There are bugs, such as handling multi-volume files, but   *\n         * that's where YOU come in.                                  *\n         *                                                            *\n         * This code makes use of a handy command called STEMVIEW     *\n         * written by Gilbert Saint-flour available as source code    *\n         * as part of file # 183 at http://www.cbttape.org            *\n         *                                                            *\n         * CBTTAPE FILE 493                                           *\n         *                                                            *\n         *------------------------------------------------------------*\n         */\n        Parse Arg data_set_name\n          Address tso\n          Call init_variables\n          Call execute_listcat\n          Call process_listcat\n          indent = copies(' ',5)\n          Call addkey \")\"        /* add closing paren */\n          out_line.0 = x         /* set total linecount */\n          Call output_results\n        Exit 0\n\n        /*------------------------------------------------------------*\n         *                                                            *\n         * process_listcat drives the processing of the LISTCAT       *\n         * output.                                                    *\n         *                                                            *\n         *------------------------------------------------------------*\n         */\n        process_listcat:\n        Do i = 1 To trap_line.0\n          Parse Var trap_line.i field1 the_rest\n          Select\n            When field1 = 'NONVSAM' Then Do\n              out_line.0 = 1         /* set one line */\n              out_line.1 = \"Not a VSAM data set:\" data_set_name\n              Call output_results\n              Exit 0\n              End\n            When field1 = 'CLUSTER' Then Do\n              big_state = 'CLUSTER'\n              Parse Var the_rest . object_name\n              x = 1\n              out_line.x = indent \"DEFINE\"\n              Call addkey \"CLUSTER (\"\n              indent = copies(' ',5)\n              Call addkey \"NAME(\" || object_name || \")\"\n              indent = copies(' ',10)\n              Call addkey \"INDEXED\"          /* KLUDGE default LINE 4 */\n              Call addkey \"SHAREOPTION(2 1)\" /* KLUDGE default LINE 5 */\n              End\n            When field1 = 'DATA' Then Do\n              big_state = 'DATA'\n              Parse Var the_rest . data_name\n              indent = copies(' ',5)\n              Call addkey \")\"\n              indent = copies(' ',1)\n              Call addkey \"DATA(\"\n              indent = copies(' ',5)\n              Call addkey \"NAME(\" || data_name || \")\"\n              indent = copies(' ',10)\n              End\n            When field1 = 'INDEX' Then Do\n              big_state = 'INDEX'\n              Parse Var the_rest . index_name\n              indent = copies(' ',5)\n              Call addkey \")\"\n              indent = copies(' ',1)\n              Call addkey \"INDEX(\"\n              indent = copies(' ',5)\n              Call addkey \"NAME(\" || index_name || \")\"\n              indent = copies(' ',10)\n              End\n            When field1 = 'HISTORY' Then Do\n              state = 'HISTORY'\n              End\n            When field1 = 'SMSDATA' Then Do\n              state = 'SMSDATA'\n              End\n            When field1 = 'RLSDATA' Then Do\n              state = 'RLSDATA'\n              End\n            When field1 = 'ASSOCIATIONS' Then Do\n              state = 'ASSOCIATIONS'\n              End\n            When field1 = 'ATTRIBUTES' Then Do\n              state = 'ATTRIBUTES'\n              End\n            When field1 = 'STATISTICS' Then Do\n              state = 'STATISTICS'\n              End\n            When field1 = 'ALLOCATION' Then Do\n              state = 'ALLOCATION'\n              End\n            When field1 = 'VOLUME' Then Do\n              state = 'VOLUME'\n              End\n            Otherwise\n              Select\n                When state = 'SMSDATA' Then Do\n                  Call do_smsdata\n                  End\n                When state = 'ATTRIBUTES' Then Do\n                  Call do_attributes\n                  End\n                When state = 'ALLOCATION' Then Do\n                  Call do_allocation\n                  End\n                When state = 'VOLUME' Then Do\n                  Call do_volume\n                  End\n                Otherwise\n                  Nop\n              End /* Select state */\n          End /* Select field1 */\n        End\n\n        Return\n\n        /*------------------------------------------------------------*\n         *                                                            *\n         * do_smsdata processes the keywords found under the SMSDATA  *\n         * section of output from listcat command.                    *\n         *                                                            *\n         *------------------------------------------------------------*\n         */\n        do_smsdata:\n\n          keyval = getkey('STORAGECLASS' trap_line.i)\n          If keyval /= '' Then\n            Call addkey \"STORAGECLASS(\" || keyval || \")\"\n\n          keyval = getkey('MANAGEMENTCLASS' trap_line.i)\n          If keyval /= '' Then\n            Call addkey \"MANAGEMENTCLASS(\" || keyval || \")\"\n\n          keyval = getkey('DATACLASS' trap_line.i)\n          If keyval /= '' Then\n            Call addkey \"DATACLASS(\" || keyval || \")\"\n\n          keyval = getkey('BWO----' trap_line.i)\n          If keyval /= '' Then\n            Call addkey \"BWO(\" || keyval || \")\"\n\n          Return\n\n        /*------------------------------------------------------------*\n         *                                                            *\n         * do_volume processes the keywords and values found under    *\n         * under the volume section of the LISTCAT command.           *\n         * Currently, we are only interested in the VOLUME keyword.   *\n         *                                                            *\n         *------------------------------------------------------------*\n         */\n        do_volume:\n\n          keyval = getkey('VOLSER' trap_line.i)\n          If keyval /= '' Then\n            Call addkey \"VOLUMES(\" || keyval || \")\"\n\n          Return\n\n        /*------------------------------------------------------------*\n         *                                                            *\n         * do_allocation processes the keywords and values found      *\n         * under the allocation section of the LISTCAT command.       *\n         *                                                            *\n         *------------------------------------------------------------*\n         */\n        do_allocation:\n\n          keyval = getkey('SPACE-TYPE' trap_line.i)\n          If keyval /= '' Then\n            space_type = keyval\n\n          keyval = getkey('SPACE-PRI' trap_line.i)\n          If keyval /= '' Then\n            space_pri = keyval\n\n          keyval = getkey('SPACE-SEC' trap_line.i)\n          If keyval /= '' Then\n            Call addkey space_type || \"(\" || space_pri keyval || \")\"\n\n          Return\n\n        /*------------------------------------------------------------*\n         *                                                            *\n         * do_attributes process the non-default data under the       *\n         * ATTRIBUTES section of output from the LISTCAT command.     *\n         *                                                            *\n         *------------------------------------------------------------*\n         */\n        do_attributes:\n\n          If big_state = 'DATA' Then\n            Call do_attributes_data\n\n          If big_state = 'INDEX' Then\n            Call do_attributes_index\n\n          keyval = getkey('BUFSPACE' trap_line.i)\n          If keyval /= '' Then\n            Call addkey \"BUFFERSPACE(\" || keyval || \")\"\n\n          keyval = getkey('EXCPEXIT' trap_line.i)\n          If keyval /= '' Then\n            Call addkey \"EXCEPTIONEXIT(\" || keyval || \")\"\n\n          keyval = getkey('CISIZE' trap_line.i)\n          If keyval /= '' Then\n            Call addkey \"CONTROLINTERVALSIZE(\" || keyval || \")\"\n\n          position = pos('SHROPTNS',trap_line.i)\n          If position /= 0 Then Do\n            position = position + length('SHROPTNS(')\n            keyval = substr(trap_line.i,position,3)\n            out_line.5 = indent \"SHAREOPTIONS(\" || keyval || \") -\"\n            End\n\n          Call findkey \"WRITECHECK\"\n          Call findkey \"REUSE\"\n\n          If wordpos(\"NONINDEXED\",trap_line.i) /= 0 Then\n            out_line.4 = indent \"NONINDEXED -\"\n          If wordpos(\"NUMBERED\",trap_line.i) /= 0 Then\n            out_line.4 = indent \"NUMBERED -\"\n          If wordpos(\"LINEAR\",trap_line.i) /= 0 Then\n            out_line.4 = indent \"LINEAR -\"\n\n          Return\n\n        /*------------------------------------------------------------*\n         *                                                            *\n         * do_attributes_data processes those keywords that are       *\n         * only valid for the data portion of a cluster.        .     *\n         * Currently these are KEYS(), RECORDSIZE(), erase and speed. *\n         *                                                            *\n         *------------------------------------------------------------*\n         */\n        do_attributes_data:\n\n          keyval = getkey('KEYLEN' trap_line.i)\n          If keyval /= '' Then\n            keylen = keyval\n\n          keyval = getkey('RKP' trap_line.i)\n          If keyval /= '' Then\n            Call addkey \"KEYS(\" || keylen keyval || \")\"\n\n          keyval = getkey('AVGLRECL' trap_line.i)\n          If keyval /= '' Then\n            avglrecl = keyval\n\n          keyval = getkey('MAXLRECL' trap_line.i)\n          If keyval /= '' Then\n            Call addkey \"RECORDSIZE(\" || avglrecl keyval || \")\"\n\n          Call findkey \"ERASE\"\n          Call findkey \"SPEED\"\n\n          Return\n\n        /*------------------------------------------------------------*\n         *                                                            *\n         * do_attributes_index processes those keywords that are      *\n         * only valid for the index portion of a cluster.             *\n         * Currently these are REPLICATE and INBED.                   *\n         *                                                            *\n         *------------------------------------------------------------*\n         */\n        do_attributes_index:\n          Call findkey \"REPLICATE\"\n          Call findkey \"IMBED\"\n          Return\n\n        /*------------------------------------------------------------*\n         *                                                            *\n         * getkey function scans a passed string for a                *\n         * specific keyword.  If the keyword is found, getkey         *\n         * returns a value associated with the keyword.               *\n         *                                                            *\n         * getkey is oriented to that ugly listcat output such as:    *\n         *     STORAGECLASS -----SCPRIM                               *\n         * example:                                                   *\n         *  getkey('STORAGECLASS','STORAGECLASS -----SCPRIM')         *\n         *                                                            *\n         * getkey will return SCPRIM                                  *\n         *                                                            *\n         *------------------------------------------------------------*\n         */\n        getkey: procedure\n          Parse Arg keyword  str\n          ret_str = ''\n          position = pos(keyword,str)\n          If position /= 0 Then Do\n            len = length(keyword)\n            position = position + len\n            len = 24  - len\n            ret_str = strip(strip(substr(str,position,len)),,'-')\n            If ret_str = '(NULL)' Then ret_str = ''\n            End\n          Return ret_str\n\n        /*------------------------------------------------------------*\n         *                                                            *\n         * findkey scans for a passed string and if it is found,      *\n         * adds the same string to the DEFINE statement.              *\n         *                                                            *\n         *------------------------------------------------------------*\n         */\n        findkey:\n          Parse Arg keyword\n          If wordpos(keyword,trap_line.i) /= 0 Then\n            Call addkey keyword\n          Return\n\n        /*------------------------------------------------------------*\n         *                                                            *\n         * addkey procedure simply adds a passed value to the         *\n         * DEFINE statement that we are building.                     *\n         *                                                            *\n         * Put a check here for keywords such as recordsize(0 0)      *\n         *   Return if found, because IDCAMS rejects such values      *\n         *     as being 'out of range'.                               *\n         *                                                            *\n         *------------------------------------------------------------*\n         */\n        addkey: procedure expose out_line. x indent\n          Parse Arg keyword\n          length_keyword = length(keyword)\n          If length_keyword > 3 Then\n            If substr(keyword,length_keyword-2,3) = '(0)' Then\n              Return\n          If length_keyword > 5 Then\n            If substr(keyword,length_keyword-4,5) = '(0 0)' Then\n              Return\n          out_line.x = out_line.x \"-\"\n          x = x + 1\n          out_line.x = indent keyword\n          Return\n\n        /*------------------------------------------------------------*\n         *                                                            *\n         * execute_listcat calls listcat command and handles return.  *\n         *                                                            *\n         *------------------------------------------------------------*\n         */\n        execute_listcat:\n        data_set_name = strip(data_set_name,,\"'\")\n        x = outtrap('trap_line.')\n        \"listcat entry('\" || data_set_name || \"') all\"\n        If RC /= 0 Then Do\n          out_line.0 = 1         /* set one line */\n          out_line.1 = \"listcat RC:\" RC\n          Call output_results\n          Exit 0\n          End\n        x = outtrap('off')\n        If DATATYPE(trap_line.0)  /= 'NUM' Then Do\n          out_line.0 = 1         /* set one line */\n          out_line.1 = \"listcat No output trapped\"\n          Call output_results\n          Exit 0\n          End\n        Return\n\n        /*------------------------------------------------------------*\n         *                                                            *\n         * init_variables is coded promarily so we can add comments   *\n         * about the variables used in this REXX.                     *\n         *                                                            *\n         *------------------------------------------------------------*\n         */\n        init_variables:\n        Drop trap_line.                        /* trapped from listcat */\n        Drop out_line.                         /* output array */\n        Drop state                             /* currently parsing this */\n        Drop object_name                       /* cluster name */\n        Drop data_name                         /* data name */\n        Drop index_name                        /* index name */\n        x = 0                                  /* current output line */\n        indent = copies(' ',1)\n        Return\n\n        /*------------------------------------------------------------*\n         *                                                            *\n         * Output any results and then exit this exec.                *\n         *                                                            *\n         *------------------------------------------------------------*\n         */\n        output_results:\n        Signal on syntax\n        Call STEMVIEW  'BROWSE','out_line.',,,'VC \"VSAM Clone\"','ISRBROBF'\n        Return\n        Syntax:                /* stemview function not available */\n          Do i=1 To out_line.0\n            Say out_line.i\n          End\n        Return\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT493/FILE493.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT493", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}