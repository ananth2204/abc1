{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012345000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 411502, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 10, "INMDSNAM": "CBT.V500.FILE562.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE562.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x08\\x0c'", "DS1TRBAL": "b'q\\x06'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04,\\x00\\x02\\x04,\\x00\\n\\x00\\t'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x13o\\x01\\x02\\x13o\\x124\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xc8\\xc9\\xd7\\xc4\\xc1\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-05-16T00:00:00", "modifydate": "2002-05-16T12:34:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SHIPDAT"}, "text": "REGULAR CBT TAPE - VERSION 447    FILE:  562\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT447.FILE562\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    8000    PO\n\n   PDS117I 29 MEMBERS COUNTED; CUMULATIVE SIZE IS 3,587 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   05/16/02    12:34:07    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE1": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x14\\x01\\x02\\x10\\x0f\\x01\\x02\\x10\\x0f '\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-10T00:00:00", "modifydate": "2002-04-10T20:27:14", "lines": 14, "newlines": 14, "modlines": 0, "user": "SBGOLOB"}, "text": "This note talks about the purpose of the EXECs in this file,\ntogether with the supporting Panel and Message Libraries:\n\nI am going to try to send three small XMIT files with this email\nto see if they go ok, and if you can read them successfully.  They\nare EXEC, MSGS, and PLIB which together contain an ISPF dialog I\nwrote in an attempt to give our programmers an online guide to\nreading Abend-Aid dumps.  It is intended to provide instructions a\nprogrammer can use to analyze a SYSUDUMP produced by Abend-Aid in\norder to locate the abending instruction and the corresponding\ninstruction in their COBOL source program.  In addition, it aids\nin location of selected data fields in the dump.  It isn't used\nextensively here, as I didn't follow up and issue training and\nadvertising about it.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE2": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x02\\x13o\\x01\\x02\\x13o\\x123\\x00 \\x00 \\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-05-16T00:00:00", "modifydate": "2002-05-16T12:33:37", "lines": 32, "newlines": 32, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject: File 562 $$README\nDate: Thu, 16 May 2002 10:26:57 -0400\nFrom: \"Thornton, Dick\" <rthornton@trigon.com>\nTo: xgob1 <sbgolob@attglobal.net>, xgob2 <sbgolob@aol.com>\n\nHi Sam,\n\nThis morning I have a $$README file to be added to FILE562. It\ncontains documentation for the members in the has file (REXX\nEXEC's) as well as for the members in the included MSGS and PLIB\nfiles. This file is a direct download from the mainframe to the\nPC using binary and no CR/LF. It was not XMITed. My intent (if it\nis a usable file) is for it to be added to FILE562 as member\n$$README.\n\nAs usual, I have a list of deleted elements, though short this\ntime. I have deleted as trash these members from the PLIB file:\n#CUT, #CUTD, #PASD, #PASTE, C1SD1000, DMMMAIN, DMM2, and SMPE0.\n\nAs usual, I appreciate your hard work and wish you happiness and\nprosperity,\n\nDick\n\nNote from Sam Golob:  As with Dick's other files, I have not deleted\n                      the members which he said he deleted from his\n                      own libraries.  I have merely pointed out which\n                      members he did not think \"worthy\" of keeping.\n                      Remember that Beethoven did not like all the\n                      music he wrote, either.  Other people can judge\n                      for themselves.....\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$PDSLOD": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x01\\x00\\x97\\x11\\x0f\\x01\\x02\\t\\x9f\\x181\\x00\\x17\\x00\\x08\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1997-04-20T00:00:00", "modifydate": "2002-04-09T18:31:01", "lines": 23, "newlines": 8, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBL JOB (ACCT#),PDSLOAD,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(1,LT)\n//*\n//*   CREATE MESSAGES AND PANELS DATASETS FOR USE WITH THESE EXECS\n//*\n//*\n//LOA1 EXEC PGM=PDSLOAD            /* FROM FILE 093 - LOAD ON FILE 035\n//STEPLIB  DD DISP=SHR,DSN=SBGOLOB.LOAD\n//SYSUT1   DD DISP=SHR,DSN=SBGOLOB.CBT444.FILE562($MSGS)\n//SYSPRINT DD SYSOUT=*\n//SYSUT2   DD DISP=(NEW,CATLG,DELETE),DSN=SBGOLOB.FILE562.MSGS,\n//   DCB=(RECFM=FB,LRECL=80,BLKSIZE=8000),\n//   SPACE=(TRK,(15,15,44),RLSE),UNIT=SYSALLDA,VOL=SER=DATA04\n//*\n//LOA2 EXEC PGM=PDSLOAD            /* FROM FILE 093 - LOAD ON FILE 035\n//STEPLIB  DD DISP=SHR,DSN=SBGOLOB.LOAD\n//SYSUT1   DD DISP=SHR,DSN=SBGOLOB.CBT444.FILE562($PNLS)\n//SYSPRINT DD SYSOUT=*\n//SYSUT2   DD DISP=(NEW,CATLG,DELETE),DSN=SBGOLOB.FILE562.PNLS,\n//   DCB=(RECFM=FB,LRECL=80,BLKSIZE=8000),\n//   SPACE=(TRK,(15,30,44),RLSE),UNIT=SYSALLDA,VOL=SER=DATA04\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$README": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x13\\x01\\x02\\x13o\\x01\\x02\\x13o\\x12)\\x00w\\x00w\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-05-16T00:00:00", "modifydate": "2002-05-16T12:29:13", "lines": 119, "newlines": 119, "modlines": 0, "user": "SBGOLOB"}, "text": "************************************************************************\n* File 562 contains three libraries (REXX execs, messages, and panels) *\n* that together make up an ISPF dialog that can be used by a programmer*\n* to aid in reading an Abend-Aid dump.                                 *\n*                                                                      *\n* In addition there are a few other things in these libraries as noted *\n* in the member documentation below. Documentation is provided here for*\n* all 3 libraries; there is no separate $$README file within the MSGS  *\n* and PLIB libraries.                                                  *\n*                                                                      *\n* Before use, the three libraries must be allocated to the ISPF SYSPROC*\n* (or SYSEXEC), ISPMLIB, and ISPPLIB files, respectively. Also, the    *\n* programmer should have the listing from the COBOL compile and        *\n* linkedit listings as well as the Abend-Aid dump.                     *\n*                                                                      *\n* In use, data gathering panels ask for information the programmer must*\n* supply from the compile, linkedit, and dump listings. The dialog then*\n* guides the programmer to the statement in the COBOL program where the*\n* abend occurred.                                                      *\n*                                                                      *\n* The dialog can also be used by a programmer to locate data fields in *\n* the Abend-Aid dump. Fields may be located in WORKING-STORAGE, in data*\n* files, or in the LINKAGE SECTION. by entering the BL-CELL, offset,   *\n* data type, field length, number of occurrences, subscript or index   *\n* information, and so forth, the programmer is led to the data field   *\n* in the dump.                                                         *\n*                                                                      *\n* The dialog aids the programmer by doing the hex-decimal conversions, *\n* validating data entered, and specifying where the data is to be      *\n* found. It also determines correct offsets based on zero-relative or  *\n* on one-relative offsets. This can be tricky, as IBM and Abend-Aid    *\n* differ in some instances, and neither of them is consistent.         *\n*                                                                      *\n* Dialog is started by use of the AATX000 command, then reading the    *\n* panels presented and following instructions.                         *\n*                                                                      *\n************************************************************************\n\n***********************************************************************\n* EXECS:   REXX EXECS (ALLOCATE TO SYSPROC OR TO SYSEXEC)             *\n***********************************************************************\nAATX000  .Part of the AATX000 dialog.\nAATX010  .Part of the AATX000 dialog.\nAATX020  .Part of the AATX000 dialog.\nAATX030  .Part of the AATX000 dialog.\nAATX034  .Part of the AATX000 dialog.\nAATX060  .Part of the AATX000 dialog.\nAATX064  .Part of the AATX000 dialog.\nAATX070  .Part of the AATX000 dialog.\nAATX074  .Part of the AATX000 dialog.\nAATX080  .Part of the AATX000 dialog.\nAATX090  .Part of the AATX000 dialog.\nARGPASS  .Example of passing arguments to a REXX EXEC.\nDATE     .This is a REXX EXEC that requests a Julian or Gregorian date\n          and displays the other format on the TSO screen. It uses\n          the DATES COBOL program in FILE563.\nMODEL    .This is a sample for developing a REXX routine from scratch.\nMULTPULL .Simple REXX EXEC asks for three numbers, displays their sum.\nPARSPULL .Simple REXX EXEC to show how parsing can retain data case\n          or change to all upper-case.\nREXXADDR .Shows some REXX ADDRESS commands. Has an error in the comments\n          at the beginning of the exec (needs /*...*/).\nSAY      .Simple REXX EXEC to show uses of the \"SAY\" command.\nTEST     .Sample REXX exec to show several REXX constructs.\nTEST1    .REXX EXEC called by the \"TEST\" REXX EXEC above.\nTIMEGAME .REXX EXEC to display time of day using the TIME command.\n\n***********************************************************************\n* MSGS:    DIALOG MESSAGES (ALLOCATE TO ISPMLIB)                      *\n***********************************************************************\nAATM00    .Part of the AATX000 dialog..\nAATM01    .Part of the AATX000 dialog..\nAATM03    .Part of the AATX000 dialog..\nAATM06    .Part of the AATX000 dialog..\nAATM07    .Part of the AATX000 dialog..\nAATM08    .Part of the AATX000 dialog..\nAATM91    .Part of the AATX000 dialog..\n\n***********************************************************************\n* PLIB:    dialog.. PANELS (ALLOCATE TO ISPPLIB)                      *\n***********************************************************************\nAATH000   .Part of the AATX000 dialog..\nAATH010   .Part of the AATX000 dialog..\nAATH011   .Part of the AATX000 dialog..\nAATH030   .Part of the AATX000 dialog..\nAATH031   .Part of the AATX000 dialog..\nAATH060   .Part of the AATX000 dialog..\nAATH061   .Part of the AATX000 dialog..\nAATH070   .Part of the AATX000 dialog..\nAATH071   .Part of the AATX000 dialog..\nAATH080   .Part of the AATX000 dialog..\nAATH090   .Part of the AATX000 dialog..\nAATH911   .Part of the AATX000 dialog..\nAATH911A  .Part of the AATX000 dialog..\nAATH912   .Part of the AATX000 dialog..\nAATH912A  .Part of the AATX000 dialog..\nAATH913   .Part of the AATX000 dialog..\nAATP000   .Part of the AATX000 dialog..\nAATP010   .Part of the AATX000 dialog..\nAATP014   .Part of the AATX000 dialog..\nAATP020   .Part of the AATX000 dialog..\nAATP030   .Part of the AATX000 dialog..\nAATP034   .Part of the AATX000 dialog..\nAATP060   .Part of the AATX000 dialog..\nAATP064   .Part of the AATX000 dialog..\nAATP070   .Part of the AATX000 dialog..\nAATP071   .Part of the AATX000 dialog..\nAATP074   .Part of the AATX000 dialog..\nAATP080   .Part of the AATX000 dialog..\nAATP081   .Part of the AATX000 dialog..\nAATP090   .Part of the AATX000 dialog..\nAATP911   .Part of the AATX000 dialog..\nAATP912   .Part of the AATX000 dialog..\nAATP913   .Part of the AATX000 dialog..\nCBC3GIS2  .Used by the C sample program CBC3GIS3 in FILE559\nCBC3GIS4  .Used by the C sample programs CBC3GIS4 and CBC3GIS8 in\n           FILE559.\nCBC3GIS5  .Used by the C sample program CBC3GIS3 in FILE559\nCBC3GIS7  .Used by the C sample program CBC3GIS8 in FILE559\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$MSGS": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x181\\x00\\xca\\x00\\xca\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T18:31:00", "lines": 202, "newlines": 202, "modlines": 0, "user": "BC0THOR"}, "text": "./ ADD NAME=AATM00   0103-00024-00024-0758-00003-00003-00000-BC0THOR\nAATM001\n'To report problems or to make suggestions, notify Dick Thornton ' +\n'by phone at 354-4829 or via email at RTHORNTON@TRIGON.COM'\n./ ADD NAME=AATM01   0107-00006-00021-1648-00026-00008-00000-BC0THOR\nAATM011   'INVALID PROGRAM NAME    '     .ALARM=YES\n'PROGRAM NAMES MUST BEGIN WITH A-Z AND CONTAIN ONLY A-Z, 0-9, $, #, @.'\n\nAATM012   'INVALID HEX VALUE       '     .ALARM=YES\n'HEX FIELDS MUST CONTAIN ONLY DIGITS 0-9 AND LETTERS A-F'\n\nAATM013   'INVALID LINE NUMBER     '     .ALARM=YES\n'LINE NUMBER MUST CONTAIN ONLY DIGITS 0-9'\n\nAATM014   'HEXLOC NOT < DISPLACEMNT'     .ALARM=YES\n'HEXLOC MUST BE LESS THAN ABEND DISPLACEMENT.'\n\nAATM015   'INFO SEEMS VALID        '     .ALARM=YES\n'BASED ON INFORMATION ENTERED, STATEMENT NUMBER GIVEN APPEARS CORRECT.'\n\nAATM016   'COMPLETION CODE INVALID '     .ALARM=YES\n'COMPLETION CODE MUST BE U OR S FOLLOWED BY THREE HEX DIGITS.'\n\nAATM017   'ABEND DISPLACEMENT ERROR'     .ALARM=YES\n'ABEND DISPLACEMENT MUST BE AN EVEN NUMBER UNLESS S0C6 ABEND.'\n\nAATM018   'CHECK HEXLOC AND DISPLAC'     .ALARM=YES\n'OVER 32 BYTES BETWEEN HEXLOC AND DISPLACEMENT. MAY BE OK, BUT CHECK.'\n\nAATM019   'DISPLACEMENT > LENGTH   '     .ALARM=YES\n'ABEND DISPLACEMENT IS GREATER THAN PROGRAM LENGTH.'\n./ ADD NAME=AATM03   0117-00007-00024-1541-00045-00044-00000-BC0THOR\nAATM030   'INVALID FIELD LENGTH    '     .ALARM=YES\n'FIELD LENGTH MUST BE GREATER THAN 0 AND LESS THAN 33'\n\nAATM031   'INVALID FIELD NAME      '     .ALARM=YES\n'FIELD NAMES MUST BEGIN WITH A-Z AND CONTAIN ONLY A-Z, 0-9, $, #, @.'\n\nAATM032   'INVALID DATA TYPE       '     .ALARM=YES\n'DATA TYPE MUST BE P, B, Z, OR C'\n\nAATM033   'INVALID HEX NUMBER      '     .ALARM=YES\n'HEX NUMBERS CONTAIN ONLY DIGITS 0-9 AND A-F'\n\nAATM034   'INVALID DECIMAL NUMBER  '     .ALARM=YES\n'DECIMAL INTEGERS CONTAIN ONLY DIGITS 0-9'\n\nAATM035   'BINARY FIELD LENGTH ERR '     .ALARM=YES\n'BINARY (COMP) FIELDS IN COBOL ARE ALWAYS 2, 4, OR 8 BYTES LONG.'\n\nAATM036   'INVALID DATA LENGTH     '     .ALARM=YES\n'DATA FIELD CONTENT IN HEX REQUIRES 2 HEX DIGITS PER BYTE.'\n\nAATM037   'FIELD TOO LONG          '     .ALARM=YES\n'THIS DIALOG CANNOT HANDLE FIELDS OVER 16 BYTES LONG.'\n\nAATM038   'INVALID BL CELL TYPE    '     .ALARM=YES\n'BL CELL TYPE MUST BE F (FILE), W (WORKING-STORAGE), OR L (LINKAGE).'\n\nAATM039   'DDNAME REQUIRED FOR BLF '     .ALARM=YES\n'WHEN BL CELL TYPE IS F (BLF CELLS), DDNAME IS REQUIRED.'\n\nAATM039A                               .ALARM=YES\n'DATA FIELD CONTENT IN HEX REQUIRES 2 HEX DIGITS PER BYTE.'\n\nAATM039B                               .ALARM=YES\n'RIGHTMOST DIGIT OF A PACKED DECIMAL FIELD MUST BE SIGN: C, D, OR F'\n\nAATM039C                               .ALARM=YES\n'PACKED DECIMAL DATA MUST BE ALL 0-9 EXCEPT SIGN AT RIGHT END'\n\nAATM039D                               .ALARM=YES\n'ZONED DECIMAL BYTES MUST ALL BE F0-F9 EXCEPT THE RIGHTMOST, WHICH IS ' +\n'THE SIGN BYTE. IT MAY CONTAIN C0-C9 (+), D0-D9 (-), OR F0-F9 (NO SIGN)'\n\nAATM039E                               .ALARM=YES\n'ZONED SIGN (RIGHTMOST BYTE) MUST BE C0-C9, D0-D9, OR F0-F9'\n./ ADD NAME=AATM06   0107-00019-00024-1602-00055-00026-00000-BC0THOR\nAATM060   'INVALID FIELD LENGTH    '     .ALARM=YES\n'FIELD LENGTH MUST BE GREATER THAN 0 AND LESS THAN 33'\n\nAATM060A  'OCCURS MUST BE > 0      '     .ALARM=YES\n'NUMBER OF OCCURS FOR THE TABLE MUST BE GREATER THAN 0'\n\nAATM061   'INVALID FIELD NAME      '     .ALARM=YES\n'FIELD NAMES MUST BEGIN WITH A-Z AND CONTAIN ONLY A-Z, 0-9, $, #, @.'\n\nAATM062   'INVALID DATA TYPE       '     .ALARM=YES\n'DATA TYPE MUST BE P, B, OR Z'\n\nAATM063   'INVALID HEX NUMBER      '     .ALARM=YES\n'HEX NUMBERS CONTAIN ONLY DIGITS 0-9 AND A-F'\n\nAATM064   'INVALID DECIMAL NUMBER  '     .ALARM=YES\n'DECIMAL INTEGERS CONTAIN ONLY DIGITS 0-9'\n\nAATM065   'BINARY FIELD LENGTH ERR '     .ALARM=YES\n'BINARY (COMP) FIELDS IN COBOL ARE ALWAYS 2, 4, OR 8 BYTES LONG.'\n\nAATM066   'INVALID DATA LENGTH     '     .ALARM=YES\n'DATA FIELD CONTENT IN HEX REQUIRES 2 HEX DIGITS PER BYTE.'\n\nAATM067   'FIELD TOO LONG          '     .ALARM=YES\n'THIS DIALOG CANNOT HANDLE FIELDS OVER 16 BYTES LONG.'\n\nAATM068   'INVALID BL CELL TYPE    '     .ALARM=YES\n'BL CELL TYPE MUST BE F (FILE), W (WORKING-STORAGE), OR L (LINKAGE).'\n\nAATM069   'DDNAME REQUIRED FOR BLF '     .ALARM=YES\n'WHEN BL CELL TYPE IS F (BLF CELLS), DDNAME IS REQUIRED.'\n\nAATM069A                               .ALARM=YES\n'DATA FIELD CONTENT IN HEX REQUIRES 2 HEX DIGITS PER BYTE.'\n\nAATM069B                               .ALARM=YES\n'RIGHTMOST DIGIT OF A PACKED DECIMAL FIELD MUST BE SIGN: C, D, OR F'\n\nAATM069C                               .ALARM=YES\n'PACKED DECIMAL DATA MUST BE ALL 0-9 EXCEPT SIGN AT RIGHT END'\n\nAATM069D                               .ALARM=YES\n'ZONED DECIMAL BYTES MUST ALL BE F0-F9 EXCEPT THE RIGHTMOST, WHICH IS ' +\n'THE SIGN BYTE. IT MAY CONTAIN C0-C9 (+), D0-D9 (-), OR F0-F9 (NO SIGN)'\n\nAATM069E                               .ALARM=YES\n'ZONED SIGN (RIGHTMOST BYTE) MUST BE C0-C9, D0-D9, OR F0-F9'\n\nAATM069F                               .ALARM=YES\n'A SUBSCRIPT MUST CONTAIN A POSITIVE VALUE OF 1 OR GREATER'\n\nAATM069G                               .ALARM=YES\n'THE SUBSCRIPT IS PAST THE END OF THE TABLE. THAT IS, IT IS GREATER ' +\n'THAN THE NUMBER OF OCCURS FOR THE TABLE.'\n./ ADD NAME=AATM07   0105-00024-00024-1452-00031-00005-00000-BC0THOR\nAATM070   'NBR OCCURS MUST BE > 0  '     .ALARM=YES\n'NUMBER OF OCCURRENCES FOR THE TABLE MUST BE 1 OR MORE.'                ILE.'\n\nAATM071   'INVALID INDEX NUMBER    '     .ALARM=YES\n'INDEX NUMBER MUST BE 4 HEX DIGITS FROM THE IDX= FIELD IN THE COBOL COMPILE.'\n\nAATM072   'INVALID DECIMAL NUMBER  '     .ALARM=YES\n'DECIMAL VALUES CAN CONTAIN ONLY THE DECIMAL DIGITS 0-9.'\n\nAATM073   'INVALID INDEX LENGTH    '     .ALARM=YES\n'INDEX CELLS ARE 4 BYTES LONG AND CONTAIN 8 HEX DIGITS (0-9, A-F).'\n\nAATM074   'INVALID HEX VALUE       '     .ALARM=YES\n'HEX VALUES MUST INCLUDE ONLY HEX DIGITS (0-9, A-F).'\n\nAATM075   'INVALID COBOL IDX NUMBER'     .ALARM=YES\n'COBOL INDEX NUMBERS (IDX=____) ARE ALWAYS GREATER THAN ZERO.'\n\nAATM079A                               .ALARM=YES\n'THE INDEX POINTS PAST THE END OF THE TABLE. THAT IS, IT IS GREATER ' +\n'THAN THE NUMBER OF OCCURS FOR THE TABLE.'\n\nAATM079B                               .ALARM=YES\n'THE INDEX CONTENT MUST BE AN EXACT MULTIPLE OF THE OCCURRING FIELD ' +\n'LENGTH TO BE VALID. RECHECK INDEX CONTENT AND OCCURRING FIELD LENGTH.'\n\nAATM079C                               .ALARM=YES\n'DATA FIELD CONTENT IN HEX REQUIRES 2 HEX DIGITS PER BYTE.'\n\nAATM079D                               .ALARM=YES\n'THE INDEX VALUE IS NEGATIVE, WHICH IS INVALID.'\n./ ADD NAME=AATM08   0118-99357-00021-1657-00033-00006-00000-BC0THOR\nAATM081   'INVALID DECIMAL NUMBER  '     .ALARM=YES\n'DECIMAL INTEGERS CONTAIN ONLY DIGITS 0-9 AND OPTIONAL LEADING SIGN'\n\nAATM081A  'REMAINDER DROPPED       '     .ALARM=YES\n'REMAINDER IS DROPPED WHEN DIVIDEND IS NOT A MULTIPLE OF THE DIVISOR.'\n\nAATM081B  'DECIMAL NUMBER TOO LONG '     .ALARM=YES\n'THE VALID DECIMAL NUMBER RANGE IS -2,147,483,648 TO +2,147,483,647.'\n\nAATM082   'INVALID HEX NUMBER      '     .ALARM=YES\n'HEX NUMBERS CONTAIN ONLY DIGITS 0-9 AND A-F'\n\nAATM083   'INVALID OPERATOR        '     .ALARM=YES\n'ARITHMETIC OPERATOR MUST BE BLANK, +, -, *, OR /'\n\nAATM084 '1ST NUMBER MISSING        '     .ALARM=YES\n'1ST NUMBER MUST BE SPECIFIED, EITHER DECIMAL, OR HEX'\n\nAATM085   'ENTER *ONE* 1ST NUMBER  '     .ALARM=YES\n'EITHER A HEX OR A DECIMAL NUMBER IS REQUIRED FOR 1ST NUMBER, NOT BOTH'\n\nAATM086 '2ND NUMBER MISSING        '     .ALARM=YES\n'2ND NUMBER MUST BE SPECIFIED WHEN AN OPERATION IS GIVEN'\n\nAATM087   'ENTER *ONE* 2ND NUMBER  '     .ALARM=YES\n'EITHER A HEX OR A DECIMAL NUMBER IS REQUIRED FOR 2ND NUMBER, NOT BOTH'\n\nAATM088   'INTEGER VALUE REQUIRED  '     .ALARM=YES\n'DECIMAL NUMBERS MUST BE WHOLE NUMBERS WITHOUT DECIMAL PLACES.'\n\nAATM089   'RESULT TOO LONG         '     .ALARM=YES\n'UNABLE TO DISPLAY THE RESULT AS IT IS TOO LONG FOR THE SCREEN FIELDS.'\n\n./ ADD NAME=AATM91   0113-00014-00024-1522-00002-00002-00000-BC0THOR\nAATM911A  'INVALID HEX NUMBER      '     .ALARM=YES\n'HEX NUMBERS CONTAIN ONLY DIGITS 0-9 AND A-F'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$PLIB": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\t\\x9f\\x01\\x02\\t\\x9f\\x181\\x06`\\x06`\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-09T00:00:00", "modifydate": "2002-04-09T18:31:00", "lines": 1632, "newlines": 1632, "modlines": 0, "user": "BC0THOR"}, "text": "./ ADD NAME=#CUT     0100-98274-98274-1158-00025-00025-00000-BC0THOR\n)ATTR DEFAULT(%+_)\n)BODY Expand(\\\\)\n%Tutorial \\-\\  CUT  \\-\\ Tutorial\n%SELECTION ===>_ZCMD                                                           +\n%                     --------------------------------\n                      |     Edit Macro  \"CUT\"        |\n                      --------------------------------\n+\n    This Edit Macro will save the data indicated by the copy/move line\n    commands.\n\n    The CUT data is remembered between edit sessions.\n\n    To view all past cut data, specify LIST as the level. The list that\n    is given supports the \"B\" Browse and \"D\" Delete line commands.\n\n    The data is retrieved by the PASTE Edit Macro.\n\n%SYNTAX:+   CUT  level\n+\n+           level is a 5 byte alpha-nueric identifier.\n            The default level is \"A\".\n+\n)PROC\n)END\n./ ADD NAME=#CUTD    0100-98274-98274-1159-00021-00021-00000-BC0THOR\n)ATTR\n ! TYPE(INPUT) INTENS(HIGH) CAPS(ON)\n \\ TYPE(OUTPUT) INTENS(LOW) CAPS(OFF) JUST(LEFT)\n)BODY\n%-----------------------  ISPF/PDF CUT MEMBERS  --------------------------------\n%COMMAND ===>_ZCMD                                            %SCROLL ===>_Z   +\n+  LEVEL  RECORDS   CREATED    FIRST RECORD\n)MODEL\n!Z\\Z    +  \\RECCNT+\\CREATED + \\RECORD                                          +\n)INIT\n  .HELP = #CUT\n  .ZVARS = '(ZSCML LSEL LEVEL)'\n  &LSEL = &Z\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n VPUT (ZSCML) PROFILE\n IF (&ZTDSELS \u00ac= 0)\n     VER (&LSEL,LIST,S,D,B MSG= DTSM001)\n &UMSG1 = 'INVALID VALUE'\n &LMSG1 = 'ENTER ''S'' OR ''B'' TO SELECT OR ''D'' TO DELETE THE MEMBER'\n)END\n./ ADD NAME=#PASD    0100-98274-98274-1159-00021-00021-00000-BC0THOR\n)ATTR\n ! TYPE(INPUT) INTENS(HIGH) CAPS(ON)\n \\ TYPE(OUTPUT) INTENS(LOW) CAPS(OFF) JUST(LEFT)\n)BODY\n%-----------------------  ISPF/PDF CUT MEMBERS  --------------------------------\n%COMMAND ===>_ZCMD                                            %SCROLL ===>_Z   +\n+  LEVEL  RECORDS   CREATED    FIRST RECORD\n)MODEL\n!Z\\Z    +  \\RECCNT+\\CREATED + \\RECORD                                          +\n)INIT\n  .HELP =  #PASTE\n  .ZVARS = '(ZSCML LSEL LEVEL)'\n  &LSEL = &Z\n)PROC\n IF (&ZCMD \u00ac= &Z) .MSG = ISPZ001\n VPUT (ZSCML) PROFILE\n IF (&ZTDSELS \u00ac= 0)\n     VER (&LSEL,LIST,S,B MSG= DTSM001)\n &UMSG1 = 'INVALID VALUE'\n &LMSG1 = 'ENTER ''S'' TO SELECT OR ''B'' TO BROWSE THE MEMBER'\n)END\n./ ADD NAME=#PASTE   0100-98274-98274-1200-00022-00022-00000-BC0THOR\n)ATTR DEFAULT(%+_)\n)BODY Expand(//)\n%Tutorial /-/  PASTE  /-/ Tutorial\n%SELECTION ===>_ZCMD                                                           +\n%                     --------------------------------\n                      |     Edit Macro  \"PASTE\"      |\n                      --------------------------------\n+\n    This Edit Macro will retrieve data saved by the CUT Edit Macro command.\n    The original data is undisturbed. The placement of the data is determined\n    by the placement of the \"A\" After or \"B\" Before line commands.\n\n    The special level LIST will list all available CUT files to allow\n    \"S\", select or \"B\" Browse line commands.\n\n%SYNTAX:+   PASTE level\n+\n+           level is a 5 byte alpha-numeric identifier.\n+           The default is list all current File Folders.\n+\n)PROC\n)END\n./ ADD NAME=AATH000  0106-00026-01037-1124-00039-00031-00000-BC0THOR\n)ATTR DEFAULT(%+_)\n        % TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)  SKIP(ON)\n        _ TYPE(INPUT)   INTENS(HIGH)  PAD('_')\n)BODY\n%AATH000               ABEND-AID DUMP TOOLS TUTORIAL HELP\n%NEXT SELECTION ===>_ZCMD  +\n+\n+ This is a set of panels intended to aid COBOL programmers in use of\n+ the Abend-Aid dump. The principal areas addressed include location\n+ of the COBOL program statement where the abend occurred, location of\n+ data field contents in the Abend-Aid dump, and interpretation of the\n+ data found. Subscripts and indexes are handled as separate types of\n+ data fields whose contents are validated and related to the occurring\n+ table element to which they refer by occurrence number and offset.\n+\n+ The following topics can be viewed in sequence, or may be selected by\n+ number:\n+\n+   1  FIND INST -  Finding the Failing Instruction in a COBOL program.\n+   3  LOCATE FLD-  Locating Fields in the Abend-Aid Dump\n+   6  SUBSCRIPT -  Working with Subscripts.\n+   7  INDEX     -  Working with Indexes.\n+   8  CALC/CONV -  Hexadecimal/Decimal Converter/Calculator.\n+   9  INTERPRET -  Interpreting Memory Contents.\n+\n+\n+ Make a selection and press Enter or press PF3 to return.\n)INIT\n)PROC\n  &ZSEL = TRANS(&ZCMD\n                 1,AATH010\n                 3,AATH030\n                 6,AATH060\n                 7,AATH070\n                 8,AATH080\n                 9,AATH090\n                 *,'?' )\n)END\n./ ADD NAME=AATH010  0105-00024-00027-0757-00036-00031-00000-BC0THOR\n)ATTR DEFAULT(%+_)\n        % TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)  SKIP(ON)\n        _ TYPE(INPUT)   INTENS(HIGH)  PAD('_')\n)BODY\n%AATH010           FINDING THE LINE NUMBER IN THE COBOL PROGRAM\n%NEXT SELECTION ===>_ZCMD  +\n+\n+Finding the abending instruction in the COBOL program requires you to\n+have access to the Abend-Aid dump and the COBOL compile listing for the\n+abending program. In this panel you are asked to enter several items of\n+information. The information entered is validated by a number of tests\n+which include: (1) Program Name must be a syntactically valid name; (2)\n+Completion Code must be Uxxx or Sxxx, where xxx is valid hex; (3) Abend\n+Displacement must be less than Program Length; (4) Abend Displacement\n+must be an even number unless Completion Code is S0C6; (5) HEXLOC must  be\n+less than Abend Displacement; (6) If HEXLOC is more than 32 bytes less\n+than Abend Displacement, a cautionary message is displayed, though this\n+may be valid; (7) All decimal and hex fields are checked for valid data .\n+\n+The following topic will be presented only if explicitly selected by\n+number:\n+   %1+ Finding the HEXLOC and Instruction Number in a COBOL compile\n+       Listing\n+\n+\n+\n+ Select 1 and press Enter or press PF3 to return\n)INIT\n.HELP = AATH000\n)PROC\n&ZSEL = TRANS(&ZCMD\n     1,*AATH011\n     *,'?')\n&ZUP = AATH000\n)END\n./ ADD NAME=AATH011  0103-00026-00027-0757-00033-00031-00000-BC0THOR\n)ATTR DEFAULT(%@\u00ac)\n        % TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        @ TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN)  SKIP(ON)\n        \u00ac TYPE(INPUT)   INTENS(HIGH)  PAD('_')\n)BODY\n@AATH011  FINDING THE HEXLOC AND INSTRUCTION NUMBER IN A COBOL COMPILE\n@\n@ The CLIST in the COBOL compile immediately follows the Constant Global\n@ Table (CGT) toward the back of the listing. It is in 3 columns, each\n@ headed with LINE #  HEXLOC  VERB. If you view the listing on a TSO\n@ terminal, you will have to shift left and right to see all 3 columns.\n@ Example (includes last line of the CGT):\n@\n@ 0011A4  (LIT+4128)   0040C000 01400006 08000020 06B50240 00080800 002006\n@ LINE #  HEXLOC  VERB                        LINE #  HEXLOC  VERB\n@ 001747 00163A CALL                          001748 001666 MOVE\n@ 001751 001688 PERFORM                       001756 001690 CALL\n@ 001760 0016CE IF                            001761 0016D4 GO\n@ 001764 0016F4 DISPLAY                       001765 001706 DISPLAY\n@ ______ ______\n@   |      |\n@   |      |---> Compare the abend displacement to the HEXLOC column to\n@   |            find the HIGHEST HEXLOC that is LESS THAN the abend\n@   |            displacement. Be sure to shift right to see the third\n@   |            column as well.\n@   |---> This is the COBOL program line number for the statement.\n@\n@ Press Enter or PF3 to return.\n)INIT\n.HELP = AATH010\n)PROC\n  &ZUP = AATH010\n)END\n./ ADD NAME=AATH030  0101-00026-00026-1455-00036-00036-00000-BC0THOR\n)ATTR DEFAULT(%+_)\n        % TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)  SKIP(ON)\n        _ TYPE(INPUT)   INTENS(HIGH)  PAD('_')\n)BODY\n%AATH030             FINDING DATA FIELD CONTENTS IN THE ABEND-AID DUMP\n%NEXT SELECTION ===>_ZCMD  +\n+\n+When a subscripted or indexed field is to be found, you should first\n+use the Subscript or Index panels (Main Menu options 6 or 7) to obtain\n+the offset due to the subscript(s) or index(es), since this offset data .\n+is needed before the field can be found in the dump.\n+\n+Three panels are involved in this process. The first obtains information\n+from you that you must locate in the COBOL compile listing. The second\n+explains how to locate the data in the Abend-Aid dump, and asks you to\n+key in the data found. The third panel interprets the data using the\n+data type and the hex value you entered: the value is always given in\n+hexadecimal and character form; when the data type is numeric (packed,\n+binary, or zoned), it is tested for validity, and a message is displayed\n+if the content is not valid for the type. For valid numeric data, the\n+value is given in both binary (hex) and decimal forms.\n+\n+The following topic will be presented only if explicitly selected by\n+number:\n+   %1+ Locating Field Data in the COBOL Compile Listing\n+\n+ Select 1 and press Enter or press PF3 to return\n)INIT\n.HELP = AATH000\n)PROC\n&ZSEL = TRANS(&ZCMD\n     1,*AATH031\n     *,'?')\n&ZUP = AATH000\n)END\n./ ADD NAME=AATH031  0105-00024-00027-0759-00033-00031-00000-BC0THOR\n)ATTR DEFAULT(%@\u00ac)\n        % TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        @ TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        \u00ac TYPE(INPUT)   INTENS(HIGH)  PAD('_')\n)BODY\n@AATH031          LOCATING FIELD DATA IN THE COBOL COMPILE\n@\n@ Much of the data requested on the data entry panels comes from\n@ the COBOL compile listing to the right of the field definition:\n@\n@    like: BLF=0000+029,0000001 6P      --> The field length is given here\n@    or:   BLW=0000+029,0000001 0CL6    |   as the non-zero number. A zero\n@    or:   BLL=0000+029,0000001 6C      |   shows a group item. The letter\n@            _      ___         ____    |   \"P\" is for a packed decimal\n@            |       |           |      |   field, but the PIC clause must\n@            |       |           |______|   be used for other types.\n@            |       |\n@            |       |--> This is the offset from the BL cell.\n@            |\n@            |--> This is the BL cell type (F, W, or L)\n@\n@  Use the PIC clause for data types.\n@     P (Packed decimal) has a COMP-3:    PIC S9(5)V99 COMP-3.\n@     B (Binary) has a COMP:              PIC 9(7) COMP.\n@     Z (Zoned decimal) has neither COMP nor COMP-3: PIC 9(7)V9.\n@     C (Character) data is non-numeric:  PIC X(23) or PIC ZZ9,999.99\n@\n@ Press Enter to return\n)INIT\n.HELP = AATH030\n)PROC\n  &ZUP = AATH030\n)END\n./ ADD NAME=AATH060  0100-00026-00026-1512-00038-00038-00000-BC0THOR\n)ATTR DEFAULT(%+_)\n        % TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)  SKIP(ON)\n        _ TYPE(INPUT)   INTENS(HIGH)  PAD('_')\n)BODY\n%AATH060             FINDING SUBSCRIPT CONTENTS IN THE ABEND-AID DUMP\n%NEXT SELECTION ===>_ZCMD  +\n+\n+Three panels are involved in this process. The first obtains information\n+from you that you must locate in the COBOL compile listing. The second\n+explains how to locate the subscript in the Abend-Aid dump, and asks\n+you to key in the data found. The third panel interprets the data\n+using the data type and the hex value you entered: the value is always\n+given in hexadecimal and character form; when the data type is numeric\n+(packed, binary, or zoned), it is tested for validity, and a message is\n+displayed if the content is not valid for the type. For valid numeric\n+data, the value is given in both binary (hex) and decimal forms. In\n+addition, the offset due to the subscript is computed and displayed in\n+hex, which should be entered on the Sub/Indx Off field on the AATP030\n+panel (Main Menu option 3).\n+\n+\n+The following topics will be presented only if explicitly selected by\n+number:\n+   %1+ Subscript Data Collection Instructions (OCCURS Data)\n+   %2+ Locating Field Data in the COBOL Compile Listing\n+\n+\n+ Select 1 and press Enter or press PF3 to return\n)INIT\n.HELP = AATH000\n)PROC\n&ZSEL = TRANS(&ZCMD\n     1,*AATH061\n     2,*AATH031\n     *,'?')\n&ZUP = AATH000\n)END\n./ ADD NAME=AATH061  0103-00024-00027-0800-00033-00031-00000-BC0THOR\n)ATTR DEFAULT(%@\u00ac)\n        % TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        @ TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        \u00ac TYPE(INPUT)   INTENS(HIGH)  PAD('_')\n)BODY\n@AATH061     SUBSCRIPT DATA COLLECTION INSTRUCTIONS (OCCURS DATA)\n@\n@ In COBOL, a table may have one or two levels of subscript. When two\n@ subscript levels are used, first find the offset due to the first\n@ subscript, then find the offset due to the second subscript and add\n@ the two offsets before trying to locate the subscripted data field via\n@ Main Menu option 3. For example:\n@    01  STATE-COUNTY-TABLE    OCCURS 50 TIMES.\n@        05 STATE-NAME         PIC X(15).\n@        05 COUNTY-TABLE       OCCURS 200 TIMES.\n@           10  COUNTY-NAME    PIC X(15).\n@\n@ If you wish to find the field COUNTY-NAME (STATE-NO, COUNTY-NO) where the\n@ subscripts used are STATE-NO and COUNTY-NO, you would first use Main Menu\n@ option 6 to find the offset due to STATE-NO, then use it again to find\n@ the offset due to COUNTY-NO, and add the resulting offsets (using Main\n@ Menu option 8 if desired). The sum is the value to be used as Sub/Indx Off\n@ on the Main Menu option 3 panel.\n@\n@ When finding the offset due to a subscript, be sure to use the number of\n@ occurrences and occurring field length appropriate to the subscript.\n@\n@ Press Enter to return\n)INIT\n.HELP = AATH060\n)PROC\n&ZUP = AATH060\n)END\n./ ADD NAME=AATH070  0100-00026-00026-1547-00036-00036-00000-BC0THOR\n)ATTR DEFAULT(%+_)\n        % TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)  SKIP(ON)\n        _ TYPE(INPUT)   INTENS(HIGH)  PAD('_')\n)BODY\n%AATH070             FINDING INDEX CONTENTS IN THE ABEND-AID DUMP\n%NEXT SELECTION ===>_ZCMD  +\n+\n+Three panels are involved in this process. The first obtains information\n+from you that you must locate in the COBOL compile listing. The second\n+explains how to locate the index value in the Abend-Aid dump, and asks\n+you to key in that data value. The third panel computes and displays\n+the equivalent occurrence number (the number that would have been used\n+in a subscript to arrive at the same element in the table). In order\n+to be valid, the index content must be an exact multiple of the length\n+of the occurring field. If not, you have probably used an incorrect\n+index, or typed the value incorrectly. an error message is also given if\n+the computed occurrence number is greater than the number of OCCURS for\n+the table. The index content should be entered on the Sub/Indx Off field\n+on the AATP030 panel (Main Menu option 3).\n+\n+The following topic will be presented only if explicitly selected by\n+number:\n+   %1+ Obtaining the Value of an Index from the Dump\n+\n+\n+\n+ Select 1 and press Enter or press PF3 to return\n)INIT\n.HELP = AATH000\n)PROC\n&ZSEL = TRANS(&ZCMD\n     1,*AATH071\n     *,'?')\n&ZUP = AATH000\n)END\n./ ADD NAME=AATH071  0103-00026-00027-0801-00033-00032-00000-BC0THOR\n)ATTR DEFAULT(%@\u00ac)\n        % TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        @ TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        \u00ac TYPE(INPUT)   INTENS(HIGH)  PAD('_')\n)BODY\n@AATH071     OBTAINING THE VALUE OF AN INDEX FROM THE DUMP\n@\n@ In COBOL, a table may have one or two levels of indexing. When two\n@ index levels are used, first find the value in the first index, then\n@ find the value in the second index and add the two before trying to\n@ locate the indexed field via Main Menu option 3.\n@ For example:\n@    01  STATE-COUNTY-TABLE    OCCURS 50 TIMES INDEXED BY STATE-NO.\n@        05 STATE-NAME         PIC X(15).\n@        05 COUNTY-TABLE       OCCURS 200 TIMES INDEXED BY COUNTY-NO.\n@           10  COUNTY-NAME    PIC X(15).\n@\n@ If you wish to find the field COUNTY-NAME (STATE-NO, COUNTY-NO) where the\n@ indexes used are STATE-NO and COUNTY-NO, you would first use Main Menu\n@ option 7 to find the value in STATE-NO, then use it again to find the\n@ value in COUNTY-NO, and add the resulting index values (using Main\n@ Menu option 8 if desired). The sum is the value to be used as Sub/Indx Off\n@ on the Main Menu option 3 panel.\n@\n@ When finding the offset due to an index, be sure to use the number of\n@ occurrences and occurring field length appropriate to the index.\n@\n@ Press Enter to return\n)INIT\n.HELP = AATH070\n)PROC\n&ZUP = AATH070\n)END\n./ ADD NAME=AATH080  0100-00026-00026-1604-00033-00033-00000-BC0THOR\n)ATTR DEFAULT(%\u00ac_)\n        % TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        \u00ac TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)  SKIP(ON)\n        _ TYPE(INPUT)   INTENS(HIGH)  PAD('_')\n)BODY\n%AATH080             CALCULATIONS AND CONVERSIONS IN HEX AND DECIMAL\n%NEXT SELECTION ===>_ZCMD  \u00ac\n\u00ac\n\u00acTwo panels are used here, the first to obtain user data, and the second\n\u00acto display the results. In the first panel, the user enters either a\n\u00achex or a decimal number in the 1st Number column. If nothing is\n\u00acentered in the Operation column, a conversion is called for, and the\n\u00acsecond panel shows the number entered in both hex and decimal forms.\n\u00ac\n\u00acWhen a calculation is to be done, the Operation must be set to +, -,\n\u00ac*, or / to perform addition, subtraction, multiplication, or division.\n\u00acAlso, either a hex or a decimal number must be entered in the 1st\n\u00acNumber column and in the 2nd Number column. The result is displayed\n\u00acon the second panel. Both numbers are converted and are displayed in\n\u00acboth hex and decimal forms.\n\u00ac\n\u00ac\n\u00ac\n\u00ac\n\u00ac\n\u00ac\n\u00ac\n\u00ac Press Enter to continue with HELP or PF3 to return\n)INIT\n.HELP = AATH000\n)PROC\n&ZUP = AATH000\n)END\n./ ADD NAME=AATH090  0100-00026-00026-1607-00033-00033-00000-BC0THOR\n)ATTR DEFAULT(%\u00ac_)\n        % TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        \u00ac TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)  SKIP(ON)\n        _ TYPE(INPUT)   INTENS(HIGH)  PAD('_')\n)BODY\n%AATH090             INTERPRETATION OF MEMORY CONTENT\n%NEXT SELECTION ===>_ZCMD  \u00ac\n\u00ac\n\u00acThis is simply a scrollable window that shows all the possible values\n\u00acfor a single byte in memory. There are columns for the Decimal value,\n\u00acthe Hex value, the EBCDIC value, the ASCII value, and the instruction\n\u00acmnemonic.\n\u00ac\n\u00ac\n\u00ac\n\u00ac\n\u00ac\n\u00ac\n\u00ac\n\u00ac\n\u00ac\n\u00ac\n\u00ac\n\u00ac\n\u00ac\n\u00ac\n\u00ac\n\u00ac Press Enter to continue with HELP or PF3 to return\n)INIT\n.HELP = AATH000\n)PROC\n&ZUP = AATH000\n)END\n./ ADD NAME=AATH911  0100-00027-00027-0840-00034-00034-00000-BC0THOR\n)ATTR DEFAULT(%+_)\n        % TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)  SKIP(ON)\n        _ TYPE(INPUT)   INTENS(HIGH)  PAD('_')\n)BODY\n+AATH911    LOCATING WORKING STORAGE FIELDS IN THE ABEND-AID DUMP\n+NEXT SELECTION ===>_ZCMD  +\n+\n+To find WORKING-STORAGE data fields in the Abend-Aid dump when you are\n+given the BLW Cell number, offset, data column number, and starting byte\n+number, first locate the heading: \"Working storage referenced by BLW\n+cell   n (X'x')\" where n is the decimal and x is the hexadecimal BLW\n+cell number. The data below is shown in 11 columns, where column 1 is\n+a 6-digit displacement from the beginning of the BLW cell, column 2 is\n+an 8-digit memory address, columns 3-10 are 8-digit (4-byte) data\n+columns, and the 11th column is a 32-byte character equivalent.\n+\n+DSPL Addres --------------------------Data--------------------------\n+xxxx xxxxxx xxxxxx xxxxxx xxxxxx xxxxxx  xxxxxx xxxxxx xxxxxx xxxxxx ccc\n+ |     |      |      |      |      |       |      |      |      |     |\n+ D     A      D      D      D      D       D      D      D      D     C\n+ i     d      a      a      a      a       a      a      a      a     h\n+ s     d      t      t      t      t       t      t      t      t     a\n+ p     r      a      a      a      a       a      a      a      a     r\n+ l            1      2      3      4       5      6      7      8     s\n+\n+\n+                        (Continued next page)\n)INIT\n.HELP = AATH030\n)PROC\n  &ZUP = AATH030\n  &ZCONT = AATH911A\n)END\n./ ADD NAME=AATH911A 0101-00027-00027-0853-00033-00033-00000-BC0THOR\n)ATTR DEFAULT(%+_)\n        % TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)  SKIP(ON)\n        _ TYPE(INPUT)   INTENS(HIGH)  PAD('_')\n)BODY\n+AATH911A   LOCATING WORKING STORAGE FIELDS IN THE ABEND-AID DUMP\n+NEXT SELECTION ===>_ZCMD  +\n+\n+Use the DSPL column to find the correct line, then go to the data column\n+specified on the AATH911 panel as shown above. Each data column contains\n+4 bytes (8 hex digits). Byte numbers within each data column are:\n+\n+                 xxxxxxxx\n+                 | | | |\n+                 | | | |---> byte 4\n+                 | | |-----> byte 3\n+                 | |-------> byte 2\n+                 |---------> byte 1\n+\n+When reading out data, recall that each byte is 2 consecutive hex digits.\n+The spaces between data columns are for readability, however the 4th\n+byte of one data column is actually immediately before the first byte of\n+the next column. Once you locate the first byte of your field, read left\n+to right for the number of bytes in the field. If the field continues\n+past byte 4 of the 8th data column, continue to byte 1 of data column 1\n+on the next line below.\n+\n+                    (Continued from previous page)\n)INIT\n.HELP = AATH030\n)PROC\n  &ZUP = AATH911\n)END\n./ ADD NAME=AATH912  0100-00027-00027-0904-00034-00034-00000-BC0THOR\n)ATTR DEFAULT(%+_)\n        % TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)  SKIP(ON)\n        _ TYPE(INPUT)   INTENS(HIGH)  PAD('_')\n)BODY\n+AATH912    LOCATING LINKAGE SECTION FIELDS IN THE ABEND-AID DUMP\n+NEXT SELECTION ===>_ZCMD  +\n+\n+To find LINKAGE SECTION data fields in the Abend-Aid dump when you are\n+given the BLL Cell number, offset, data column number, and starting byte\n+number, first locate the block titled \"Data Division of Program xxxxxxxx\"\n+where xxxxxxxx is the name of the program in which the abend occurred.\n+Next locate the line \"Linkage storage referenced by BLL Cell   n (X'x')\"\n+where n is the decimal and x is the hexadecimal BLL cell number. The\n+data below is shown in 11 columns, where column 1 is a 6-digit displace-\n+ment from the beginning of the BLL cell, column 2 is an 8-digit memory\n+address, columns 3-10 are 8-digit (4-byte) data columns, and the 11th\n+column is a 32-byte character equivalent.\n+DSPL Addres --------------------------Data--------------------------\n+xxxx xxxxxx xxxxxx xxxxxx xxxxxx xxxxxx  xxxxxx xxxxxx xxxxxx xxxxxx ccc\n+ |     |      |      |      |      |       |      |      |      |     |\n+ D     A      D      D      D      D       D      D      D      D     C\n+ i     d      a      a      a      a       a      a      a      a     h\n+ s     d      t      t      t      t       t      t      t      t     a\n+ p     r      a      a      a      a       a      a      a      a     r\n+ l            1      2      3      4       5      6      7      8     s\n+\n+                        (Continued next page)\n)INIT\n.HELP = AATH030\n)PROC\n  &ZUP = AATH030\n  &ZCONT = AATH912A\n)END\n./ ADD NAME=AATH912A 0100-00027-00027-0905-00033-00033-00000-BC0THOR\n)ATTR DEFAULT(%+_)\n        % TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)  SKIP(ON)\n        _ TYPE(INPUT)   INTENS(HIGH)  PAD('_')\n)BODY\n+AATH912A   LOCATING LINKAGE SECTION FIELDS IN THE ABEND-AID DUMP\n+NEXT SELECTION ===>_ZCMD  +\n+\n+Use the DSPL column to find the correct line, then go to the data column\n+specified on the AATH912 panel as shown above. Each data column contains\n+4 bytes (8 hex digits). Byte numbers within each data column are:\n+\n+                 xxxxxxxx\n+                 | | | |\n+                 | | | |---> byte 4\n+                 | | |-----> byte 3\n+                 | |-------> byte 2\n+                 |---------> byte 1\n+\n+When reading out data, recall that each byte is 2 consecutive hex digits.\n+The spaces between data columns are for readability, however the 4th\n+byte of one data column is actually immediately before the first byte of\n+the next column. Once you locate the first byte of your field, read left\n+to right for the number of bytes in the field. If the field continues\n+past byte 4 of the 8th data column, continue to byte 1 of data column 1\n+on the next line below.\n+\n+                    (Continued from previous page)\n)INIT\n.HELP = AATH030\n)PROC\n  &ZUP = AATH912\n)END\n./ ADD NAME=AATH913  0100-00027-00027-0921-00033-00033-00000-BC0THOR\n)ATTR DEFAULT(%+_)\n        % TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        + TYPE(TEXT)    INTENS(LOW)   COLOR(GREEN)  SKIP(ON)\n        _ TYPE(INPUT)   INTENS(HIGH)  PAD('_')\n)BODY\n+AATH913    LOCATING FILE SECTION FIELDS IN THE ABEND-AID DUMP\n+NEXT SELECTION ===>_ZCMD  +\n+\n+To find FILE SECTION data fields in the Abend-Aid dump when you are\n+given the DDNAME, BLF cell number, offset, DDNAME, and beginning byte\n+number, go to the back of the dump and page upward until you find the\n+page headed \"Data Management Control Blocks for DDNAME cccccccc\",\n+where cccccccc is your DDNAME. Now look forward to find the line that\n+says \"Current record\", and the following data is for the BLF cell given.\n+This data is formatted much differently than other dump data: a vertical\n+CHAR/ZONE/DIGIT format is used, but most inportantly, bytes are numbered\n+in decimal beginning with 1. The offset given on the AATP913 panel is\n+also given in decimal relative to 1. Locate the byte number and read\n+out the data:\n+Current Record\n+\n+xxxxxxxx CHAR cccccccccccccccccccccccccccccccccccccccccccccccccccccc\n+         ZONE xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n+DIGIT xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n+1...5...10....*...20....*...30....*...40....*...50....\n+\n+When reading data in hex, the ZONE digit is read first, followed by the\n+DIGIT digit in the same column.\n)INIT\n.HELP = AATH030\n)PROC\n  &ZUP = AATH030\n)END\n./ ADD NAME=AATP000  0103-00024-01037-1108-00044-00035-00000-BC0THOR\n)ATTR\n        % TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN)\n        ! TYPE(TEXT)    INTENS(HIGH)  COLOR(WHITE)\n        @ TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN)\n        + TYPE(TEXT)    INTENS(LOW)\n\n)BODY\n%AATP000            ABEND AID TOOLS MAIN MENU\n%SELECTION ==>_ZCMD\n+\n!1 @FIND INST -  Finding the Failing Instruction in a COBOL program.\n!2 @SUB-PROG  -  When the Abend occurs in a Sub-Program.\n!3 @LOCATE FLD-  Locating Fields in the Abend-Aid Dump\n!6 @SUBSCRIPT -  Working with Subscripts.\n!7 @INDEX     -  Working with Indexes.\n!8 @CALC/CONV -  Hexadecimal/Decimal Converter/Calculator.\n!9 @INTERPRET -  Interpreting Memory Contents.\n+\n+\n@ An extensive HELP facility is included with this dialog. Please\n@ press PF1 when any question arises. This will display a longer\n@ message when a short one is displayed, or a screen that contains\n@ an explanation of the current panel and its fields.\n+\n+\n!X @EXIT      -  Return to Workbench Master Menu\n)INIT\n.MSG = AATM001\n.HELP = AATH000\n&ZPRIM = YES\n&ZHTOP = AATH000\n)PROC\n  &ZSEL = TRANS( TRUNC (&ZCMD,'.')\n                 1,'CMD(AATX010)'\n                 2,'CMD(AATX020)'\n                 3,'CMD(AATX030)'\n                 6,'CMD(AATX060)'\n                 7,'CMD(AATX070)'\n                 8,'CMD(AATX080)'\n                 9,'CMD(AATX090)'\n               ' ',' '\n                 X,'EXIT'\n                 *,'?' )\n)END\n./ ADD NAME=AATP010  0106-00024-01036-1519-00046-00046-00000-BC0THOR\n)ATTR DEFAULT(%@\u00ac)\n        % TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        @ TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN)  SKIP(ON)\n        \u00ac TYPE(INPUT)   INTENS(HIGH)  PAD('_')\n)BODY\n%AATP010   FINDING THE FAILING INSTRUCTION IN A COBOL PROGRAM\n%\n@ In the Abend-Aid dump, locate the Next Sequential Instruction Section\n@ which should have a statement that says: THE NEXT SEQUENTIAL INSTRUCTION\n@ TO BE EXECUTED IN PROGRAM\u00acprogram @WAS AT DISPLACEMENT\u00acabdisp@   Enter\n@ the program name and displacement. Also enter completion code:\u00accomp@\n@\n@ Next, look down a few lines in the dump and find the statement that says\n@ THE PROGRAM WAS COMPILED ON dd mmm yy AND IS nnnnnn BYTES LONG. Enter\n@ the length here: \u00acpgmlen@\n@\n@ Now locate the COBOL compile and LINKEDIT listing (footprint) for the\n@ abending program. Be sure the length matches the length above.\n@\n@ In the COBOL Compile listing locate the Condensed Procedure Listing,\n@ which immediately follows the Constant Global Table (CGT). It has 3\n@ columns across the page, each column having LINE #, HEXLOC, and VERB.\n@ Locate the highest HEXLOC that is LOWER than the displacement you\n@ wrote down above. The LINE # associated with this HEXLOC is for the\n@ instruction that caused the abend. Enter the HEXLOC:\u00achexloc@and LINE #\n@ \u00aclineno@\n@\n@ Press Enter to retype data. PF3 returns to the main menu. PF1 is HELP\n)INIT\n.CURSOR = &CURSLOC\n.MSG=&ERRMESG\n.HELP=AATH010\n)PROC\n   VER (&PROGRAM,NB)\n   VER (&PROGRAM,NAME,MSG=AATM011)\n   VER (&ABDISP,NB)\n   VER (&ABDISP,HEX,MSG=AATM012)\n   VER (&COMP,NB)\n   VER (&PGMLEN,NB)\n   VER (&PGMLEN,HEX,MSG=AATM012)\n   VER (&HEXLOC,NB)\n   VER (&HEXLOC,HEX,MSG=AATM012)\n   VER (&LINENO,NB)\n   VER (&LINENO,NUM,MSG=AATM013)\n   VPUT (PROGRAM ABDISP COMP PGMLEN HEXLOC) SHARED\n)END\n./ ADD NAME=AATP014  0104-01036-01036-1533-00035-00035-00000-BC0THOR\n)ATTR DEFAULT(%@\u00ac)\n        % TYPE(OUTPUT)  INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        @ TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        \u00ac TYPE(OUTPUT)  INTENS(HIGH)  COLOR(red) SKIP(ON)\n        $ TYPE(OUTPUT)  INTENS(HIGH)  COLOR(GREEN) CAPS(OFF)\n)BODY\n@AATP014   ABENDING COBOL PROGRAM STATEMENT FOUND!!\n@\n@ Locate the COBOL compile listing that matches the dump. To insure\n@ you have the correct listing, go to the LinkEdit listing and check\n@ to see that the length of program\u00acprogram@ is exactly\u00acpgmlen@ bytes\n@ long.\n@\n@ Now go to statement number\u00aclineno@ in the COBOL compile listing. This\n@ is the statement that caused the abend. Quite often the problem will\n@ be obvious when this statement is found and read.\n@\n@ If additional information is required, please refer to other pages\n@ in this dialog.\n@\n@\n@\n@\n@\n@\n@\n@\n@\n@ Press Enter or PF3 to continue\n)INIT\n.HELP = AATH010\n.CURSOR = &CURSLOC\n.MSG = &ERRMESG\n)PROC\n)END\n./ ADD NAME=AATP020  0102-00024-00027-0806-00032-00031-00000-BC0THOR\n)ATTR DEFAULT(%@\u00ac)\n        % TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        @ TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        \u00ac TYPE(INPUT)   INTENS(HIGH)  PAD('_')\n)BODY\n%AATP020              ABENDS IN CALLED SUBROUTINES\n@\n@ When the abend occurs in a called program, it is often caused by the\n@ calling program passing incorrect parameters. To find the CALL statement\n@ that invoked the subroutine, go to the Abend-Aid dump and look for the\n@ CALL TRACE SUMMARY. Find the subroutine in the *****CALLED***** column.\n@ On that line in the *****CALLING***** column you see the name of the\n@ program that called the subroutine. In the ***RETURN*** column is the\n@ DISPlacement from the beginning of the program to the CALL statement that\n@ invoked the subroutine. Write down the Calling program name and displa-\n@ cement and use them on the \"Finding the Failing Instruction in a COBOL\n@ Program\" in this dialog. You will need the COBOL compile and linkedit\n@ listing for the calling program, of course.\n@\n@ Things to look for in the calling program:\n@   1. Were the right number of parameters passed?\n@   2. Are the parameters passed in the same order as expected by the\n@      called subroutine?\n@   3. Are the parameters defined the same (data type, length)?\n@   4. Do the fields passed to the called subroutine contain valid data?\n@\n@\n@\n)INIT\n.HELP = AATH000\n)PROC\n)END\n./ ADD NAME=AATP030  0102-00024-00026-1640-00054-00054-00000-BC0THOR\n)ATTR DEFAULT(%@\u00ac)\n        % TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        @ TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        \u00ac TYPE(INPUT)   INTENS(HIGH)  PAD('_')\n)BODY\n@AATP030             LOCATING FIELDS IN THE ABEND-AID DUMP\n@\n@\n@ If the field you wish to find is subscripted or indexed, you will have\n@ to use Main Menu choice 6 or 7 and get their displacement(s) first.\n@\n@ In the COBOL compile listing, locate the data field you want to find in\n@ the dump and enter the following data for the field:\n@    Field Name:   \u00acfldname                       @\n@    Data Type:    \u00acz@       P=COMP-3, B=COMP, Z=PIC 9 no COMP, C=all else\n@    BL Cell Type: \u00acz@       F=BLF, W=BLW, L=BLL\n@    BL Cell Nbr:  \u00acz   @    Hex value\n@    BL Offset:    \u00acz  @     Hex value\n@    Field length: \u00acfldlen@  Decimal value\n@    DDNAME:       \u00acddname  @Required when BL Cell Type is F\n@    Sub/Indx Off: \u00acsubidx@  Blank when field is neither subscripted nor\n@                            indexed. When the field is subscripted, get\n@                            the value from Main Menu option 6. When the\n@                            field is indexed, get the value from Main\n@                            Menu option 7. If two subscripts/indexes are\n@                            used, enter the sum of offsets. Value is hex.\n@\n@ Press Enter to continue or PF3 to return to the main menu. PF1 for HELP\n)INIT\n.ZVARS = '(FLDTYPE,BLCELLTY,BLCELLNO,BLOFF)'\n.CURSOR = &CURSLOC\n.MSG = &ERRMESG\n.HELP = AATH030\nVGET (PROGRAM) SHARED\n)PROC\n   VER (&FLDNAME,NB)\n   VER (&FLDTYPE,NB)\n   VER (&FLDTYPE,LIST,P,B,Z,C,MSG=AATM032)\n   VER (&BLCELLTY,NB)\n   VER (&BLCELLTY,LIST,F,W,L,MSG=AATM038)\n   VER (&BLCELLNO,NB)\n   VER (&BLCELLNO,HEX,MSG=AATM033)\n   VER (&BLOFF,NB)\n   VER (&BLOFF,HEX,MSG=AATM033)\n   VER (&FLDLEN,NB)\n   VER (&FLDLEN,NUM,MSG=AATM034)\n   VER (&FLDLEN,RANGE,1,32,MSG=AATM030)\n   IF (&BLCELLTY = 'F')\n      VER(&DDNAME,NB)\n   VER (&DDNAME,NAME,MSG=AATM031)\n   VER (&SUBIDX,HEX,MSG=AATM033)\n   VPUT (FLDNAME FLDTYPE BLCELLTY BLCELLNO) SHARED\n   VPUT (BLOFF FLDLEN DDNAME SUBIDX) SHARED\n)END\n./ ADD NAME=AATP034  0105-00024-00027-1422-00037-00035-00000-BC0THOR\n)ATTR DEFAULT(%@\u00ac)\n        % TYPE(OUTPUT)  INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        @ TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        \u00ac TYPE(OUTPUT)  INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        $ TYPE(OUTPUT)  INTENS(HIGH)  COLOR(GREEN) CAPS(OFF)\n)BODY\n@AATP034   VALIDATION OF DUMP DATA FIELD CONTENT\n@\n@     Field Name:   %fldname                       @\n@     Data Type:    %datatype@\n@    \u00acbl @Cell:     %z   @   Hex value\n@     BL Offset     %z  @    Hex value\n@     Length:       %fldlen@ Decimal value\n@\n@     Hex Content:  %hexdata                         @\n@\n@     Decimal Value:%decval                          @\n@\n@     CHAR$char            @\n@     ZONE%zone            @\n@     NUM %num             @\n@\n@\n@\n@\n@\n@\n@\n@ Press Enter or PF3 to continue\n)INIT\n.HELP = AATH030\n.ZVARS = '(BLCELLNO,BLOFF)'\n.CURSOR = &CURSLOC\n.MSG = &ERRMESG\n&DATATYPE = TRANS (&FLDTYPE B,BINARY C,CHARACTER P,PACKED Z,ZONED)\n)PROC\n)END\n./ ADD NAME=AATP060  0102-00024-01033-1113-00059-00059-00000-BC0THOR\n)ATTR DEFAULT(%@\u00ac)\n        % TYPE(TEXT)    INTENS(HIGH)  COLOR(WHITE) SKIP(ON)\n        @ TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        \u00ac TYPE(INPUT)   INTENS(HIGH)  PAD('_')\n)BODY\n@AATP060                   WORKING WITH SUBSCRIPTS\n@\n@ A subscript is an ordinary numeric data field that contains an occurrence\n@ number beween 1 and the maximum number of occurrences in a table. This\n@ panel derives the decimal occurrence number and total hex displacement\n@ for the value currently contained in a subscript.\n@\n@ In the the COBOL compile listing, locate the subscript field you want to\n@ find in the dump and enter the following data for it:\n@      Field Name:            \u00acfldname                       @\n@      Data Type:             \u00acz@       P=COMP-3, B=COMP, Z=PIC 9 no COMP\n@      BL Cell Type:          \u00acz@       F=BLF, W=BLW, L=BLL\n@      BL Cell Nbr:           \u00acz   @    Hex value\n@      BL Offset:             \u00acz  @     Hex value\n@      Subscript field length:\u00acfldlen@  Decimal value\n@      DDNAME:                \u00acddname  @DDNAME if BL Cell Type = F\n@      Occurring Field Length:\u00acocclen @ Decimal value\n@      Number of Occurs:      \u00acoccnbr@  Decimal value\n@ The total length value due to the subscript must be entered on the\n@ Subscript/Index Offset field of the location panel (choice 3, 4, or 5\n@ from the Main Menu). If there are two subscripts, sum their values.\n@\n@ Press Enter to continue or PF3 to return to the main menu.\n)INIT\n.ZVARS = '(FLDTYPE,BLCELLTY,BLCELLNO,BLOFF)'\n.CURSOR = &CURSLOC\n.MSG = &ERRMESG\n.HELP = AATH060\nVGET (PROGRAM) SHARED\n)PROC\n   VER (&FLDNAME,NB)\n   VER (&FLDTYPE,NB)\n   VER (&FLDTYPE,LIST,P,B,Z,MSG=AATM062)\n   VER (&BLCELLTY,NB)\n   VER (&BLCELLTY,LIST,F,W,L,MSG=AATM068)\n   VER (&BLCELLNO,NB)\n   VER (&BLCELLNO,HEX,MSG=AATM063)\n   VER (&BLOFF,NB)\n   VER (&BLOFF,HEX,MSG=AATM063)\n   VER (&FLDLEN,NB)\n   VER (&FLDLEN,NUM,MSG=AATM064)\n   VER (&FLDLEN,RANGE,1,32,MSG=AATM060)\n   VER (&DDNAME,NAME,MSG=AATM061)\n   IF (&BLCELLTY = 'F')\n      VER (&DDNAME,NB)\n   VER (&DDNAME,NAME,MSG=AATM061)\n   VER (&OCCLEN,NB)\n   VER (&OCCLEN,NUM,MSG=AATM064)\n   VER (&OCCNBR,NB)\n   VER (&OCCNBR,NUM,MSG=AATM064)\n   VER (&SUBIDX,HEX,MSG=AATM063)\n   VPUT (FLDNAME FLDTYPE BLCELLTY BLCELLNO) SHARED\n   VPUT (BLOFF FLDLEN DDNAME OCCLEN OCCNBR) SHARED\n)END\n./ ADD NAME=AATP064  0104-00024-00027-1423-00037-00035-00000-BC0THOR\n)ATTR DEFAULT(%@\u00ac)\n        % TYPE(OUTPUT)  INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        @ TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        \u00ac TYPE(OUTPUT)  INTENS(HIGH)  COLOR(WHITE) SKIP(ON)\n        $ TYPE(OUTPUT)  INTENS(HIGH)  COLOR(GREEN) CAPS(OFF)\n)BODY\n@AATP064      VALIDATION/EXPANSION OF SUBSCRIPT FIELD CONTENT\n@\n@     Subscript Name:%fldname                       @\n@     Data Type:     %datatype@\n@    \u00acbl @Cell:      %z   @   Hex value\n@     BL Offset      %z  @    Hex value\n@     Length:        %fldlen@ Decimal value\n@\n@     Hex Content:   %hexdata                         @ Hex value in dump\n@\n@     CHAR$char            @\n@     ZONE%zone            @\n@     NUM %num             @\n@\n@     Decimal Value:           \u00acdecval          @ Occurrence Nbr\n@     Number Occurs:           %occnbr@           Decimal value\n@     Length of Occurring Item:%occlen@           Decimal value\n@     Offset due to Subscript: \u00acsuboff@ Hex offset from the beginning of the\n@                                       table to the specified table entry.\n@                                       Copy to the Sub/Indx Off field of\n@                                       Main Menu choice 3 panel AATP030.\n@\n@ Press Enter or PF3 to continue\n)INIT\n.HELP = AATH060\n.ZVARS = '(BLCELLNO,BLOFF)'\n.CURSOR = &CURSLOC\n.MSG = &ERRMESG\n&DATATYPE = TRANS (&FLDTYPE B,BINARY C,CHARACTER P,PACKED Z,ZONED)\n)PROC\n)END\n./ ADD NAME=AATP070  0100-00024-00024-1409-00043-00043-00000-BC0THOR\n)ATTR DEFAULT(%@\u00ac)\n        % TYPE(TEXT)    INTENS(HIGH)  COLOR(WHITE) SKIP(ON)\n        @ TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        \u00ac TYPE(INPUT)   INTENS(HIGH)  PAD('_')\n)BODY\n@AATP070                   WORKING WITH INDEXES\n@\n@ An index is a 4-byte binary data field that is created by COBOL when the\n@ INDEXED BY clause is specified on a data item. The index contains the\n@ total number of bytes from the beginning of the table to the table element\n@ it refers to. This differs from a subscript, which contains an occurrence\n@ number.\n@\n@ In the the COBOL compile listing, locate the index field you want to\n@ find in the dump and enter the following data for it:\n@      Index Name:            \u00acfldname                       @\n@      COBOL IDX Number:      \u00acidx @    Hex value from IDX=\n@      Occurring Field Length:\u00acocclen @ Decimal value from occurring field\n@      Number of Occurs:      \u00acoccnbr@  Decimal value from OCCURS nnn TIMES\n@\n@ The total length value due to the index must be entered on the\n@ Subscript/Index Offset field of the Main Menu choice 3, panel AATP030\n@ If there are two indexes, sum their values.\n@\n@\n@\n@\n@ Press Enter to continue, PF3 to return to the main menu or PF1 for Help\n)INIT\n.CURSOR = &CURSLOC\n.MSG = &ERRMESG\n.HELP = AATH070\nVGET (PROGRAM) SHARED\n)PROC\n   VER (&FLDNAME,NB)\n   VER (&IDX,NB)\n   VER (&IDX,HEX,MSG=AATM071)\n   VER (&OCCLEN,NB)\n   VER (&OCCLEN,NUM,MSG=AATM072)\n   VER (&OCCNBR,NB)\n   VER (&OCCNBR,NUM,MSG=AATM072)\n   VPUT (FLDNAME IDX OCCLEN OCCNBR) SHARED\n)END\n./ ADD NAME=AATP071  0103-00024-00027-0809-00036-00035-00000-BC0THOR\n)ATTR DEFAULT(%@\u00ac)\n        % TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        @ TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        \u00ac TYPE(OUTPUT)  INTENS(HIGH)\n        $ TYPE(INPUT)   INTENS(HIGH)  PAD('_')\n)BODY\n@AATP071              LOCATING INDEX VALUES IN THE ABEND-AID DUMP\n@\n@\n@ Go to the Abend-Aid dump and locate the beginning of your program's\n@ data, which will be in a box headed: DATA DIVISION OF PROGRAM\u00acprogram @\n@\n@ Go forward past the WORKING STORAGE REFERENCED by pages until you find\n@ the SUPPORTING DATA page, which contains contents of BLW cells, BLL\n@ cells, BLF cells, and index cells. Locate the content of the index\n@ cell identified as IDX  \u00acz  .@Note that this is one less than the\n@ COBOL IDX number due to differences in the ways COBOL and Abend-aid\n@ count.\n@\n@ Enter the four-byte content of the index cell, which is 8 hex digits:\n@ $hexdata @\n@\n@\n@\n@\n@\n@\n@ Press Enter to continue or PF3 to return to the main menu.\n)INIT\n.HELP = AATH070\n.ZVARS = '(ABIDX)'\n.MSG = &ERRMESG\n)PROC\n   VER (&HEXDATA,HEX,MSG=AATM074)\n   VPUT (HEXDATA) SHARED\n)END\n./ ADD NAME=AATP074  0103-00024-00027-0809-00035-00034-00000-BC0THOR\n)ATTR DEFAULT(%@\u00ac)\n        % TYPE(OUTPUT)  INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        @ TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        \u00ac TYPE(OUTPUT)  INTENS(HIGH)  COLOR(WHITE) SKIP(ON)\n)BODY\n@AATP074               INDEX CONTENT VALIDATION\n@\n@     Index Name:         %fldname                       @\n@     COBOL Index Number  %idx @   Hex value\n@     Abend-Aid Index nbr %z  @    Hex value\n@\n@     Hex Content:   %hexdata                         @ Hex value in dump\n@\n@     Equivalent Occurrence No:\u00acdecval          @ Decimal value\n@     Number Occurs:           %occnbr@           Decimal value\n@     Length of Occurring Item:%occlen@           Decimal value\n@     Offset due to Index:     \u00acsuboff  @ Hex offset from the start of the\n@                                       table to the specified table entry.\n@                                       Copy to the Sub/Indx Off field of\n@                                       Main Menu choice 3 panel AATP030.\n@\n@\n@\n@\n@\n@\n@\n@ Press Enter or PF3 to continue\n)INIT\n.HELP = AATH070\n.ZVARS = '(ABIDX)'\n.CURSOR = &CURSLOC\n.MSG = &ERRMESG\n)PROC\n)END\n./ ADD NAME=AATP080  0103-00024-00027-0941-00056-00055-00000-BC0THOR\n)ATTR DEFAULT(%@_)\n        % TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        @ TYPE(TEXT)    INTENS(HIGH)  COLOR(green) SKIP(ON)\n        _ TYPE(INPUT)   INTENS(HIGH)\n        # TYPE(OUTPUT)  INTENS(HIGH)  SKIP(ON)\n\n)BODY\n%AATP080         ABEND AID TOOLS HEX/DECIMAL CALCULATIONS\n%\n%\n@ To convert from decimal to hex, or hex to decimal, leave the operation\n@ field (Op) blank, and enter the known number in the 1st Number column.\n@\n@ For calculations, the Operation field (Op) must contain a + for\n@ addition, a - for subtraction, a * for multiplication, or a / for\n@ division. Enter one number in the 1st Number column, and one in the\n@ second column.\n@\n@ Only whole numbers can be entered (no decimal points or commas). The\n@ allowed decimal number range is -2,147,483,648 to +2,147,483,647. For\n@ hex numbers, the range is 00000000 to FFFFFFFF.\n%\n%\n% 1st Number           Operation   2nd Number\n% Hex _h1      %           _z%     Hex _h2      %                       %\n% Dec _d1                 %        Dec _d2            %                       %\n%\n%\n%\n% Press Enter for calculation. PF3 returns to the previous screen.\n)INIT\n.ZVARS = '(OP)'\n.CURSOR = &CURSLOC\n.MSG=&ERRMESG\n.HELP = AATH080\n)PROC\n   VER (&D1,ENUM,MSG=AATM081)\n   VER (&D2,ENUM,MSG=AATM081)\n   VER (&H1,HEX,MSG=AATM082)\n   VER (&H2,HEX,MSG=AATM082)\n   VER (&OP,LIST,' ','+','-','*','/',MSG=AATM083)\nIF (&H1 = '')\n    IF (&D1 = '')\n        .MSG=AATM084\nELSE\n    IF (&D1 \u00ac= '')\n        .MSG=AATM085\nIF (&OP \u00ac= '')\n   IF (&H2 = '')\n       IF (&D2 = '')\n           .MSG=AATM086\n   ELSE\n       IF (&D2 \u00ac= '')\n           .MSG=AATM087\n   VPUT (D1 H1 OP D2 H2) SHARED\n)END\n./ ADD NAME=AATP081  0103-00024-00027-0945-00034-00033-00000-BC0THOR\n)ATTR DEFAULT(%@_)\n        % TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        # TYPE(OUTPUT)  INTENS(HIGH)  SKIP(ON)\n\n)BODY\n%AATP081         ABEND AID TOOLS HEX/DECIMAL CALCULATION RESULTS\n%SELECTION ==>_ZCMD\n%\n%\n%\n% 1st Number           Operation   2nd Number              Result\n% Hex #h1      %           #z%     Hex #h2      %     % =  Hex #hr      %\n% Dec #d1                 %        Dec #d2            % =  Dec #dr            %\n%\n%\n%\n%\n%\n%\n%\n%\n%\n%\n%\n%\n%\n%\n% Press Enter for clear calculation screen, PF3 to return to main menu.\n)INIT\n.ZVARS = '(OP)'\n.MSG=&errmesg\n.HELP = AATH080\n)PROC\n)END\n./ ADD NAME=AATP090  0104-00024-00027-0810-00018-00017-00000-BC0THOR\n)ATTR DEFAULT(%+_)\n      % TYPE(TEXT)   INTENS(HIGH) SKIP(ON)\n      + TYPE(TEXT)   INTENS(LOW)  SKIP(ON)\n      _ TYPE(INPUT)  INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD(_)\n      \u00ac TYPE(INPUT)  INTENS(HIGH) CAPS(ON) JUST(LEFT)\n      $ TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)\n)BODY\n%AATP090------------- Code Conversion Chart ------------------------------------\n+Command%===>\u00acZCMD                                            +Scroll%===>_SAMT+\n%Sel DEC HEX  -BINARY--  EBCDIC    ASCII    INSTR +\n+--- ---  --  ---- ----  --------  -------  ----- +\n)MODEL\n_S  $DEC $HX $BINARY    $EBCDIC   $ASCII   $INSTR\n)INIT\n&s = ''\n.HELP = AATH090\n)PROC\n)END\n./ ADD NAME=AATP911  0104-00024-00027-0813-00038-00037-00000-BC0THOR\n)ATTR DEFAULT(%@\u00ac)\n        % TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        @ TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        \u00ac TYPE(OUTPUT)  INTENS(HIGH)\n        $ TYPE(INPUT)   INTENS(HIGH)  PAD('_')\n)BODY\n%AATP911   LOCATING FIELDS IN WORKING STORAGE AREAS (BLW CELLS)\n%\n%\n@ The field named \u00acfldname                         @\n@ can be found in the Abend-Aid Dump at BLW Cell \u00acz   @+ offset \u00acz     @\n@\n@ Go to the Abend-Aid dump and locate the beginning of your program's\n@ data, which will be in a box headed: DATA DIVISION OF PROGRAM\u00acprogram @\n@\n@ Go forward to find the line: WORKING STORAGE REFERENCED BY BLW CELL\u00acz   @\n@\n@ Now locate the data line whose offset (DSPL column) value is:\u00acz     @\n@\n@ The field will begin in DATA column number \u00acz@ on that line. When\n@ counting data columns, remember that the first two columns are\n@ displacement and address, NOT data. The THIRD column is DATA column 1.\n@\n@ Your\u00acdatatype@field begins in byte number \u00acz@in the data column, and is\n@ \u00acfldlen@bytes long. Remember that one byte is two hex digits. For a\n@ validity check of the data, enter the value from the dump, 2 hex digits\n@ per byte:$hexdata                         @\n@\n@ Press Enter to continue, PF3 to return, or PF1 for HELP.\n)INIT\n.HELP = AATH911\n.ZVARS = '(BLCELLNO TOTLOFST TOTBLCEL LINEOFST NBRCOLS BYTEOFST)'\n.MSG = &ERRMESG\n&DATATYPE = TRANS (&FLDTYPE B,BINARY C,CHARACTER P,PACKED Z,ZONED)\n)PROC\n   VER (&HEXDATA,HEX,MSG=AATM911A)\n   VPUT (HEXDATA) SHARED\n)END\n./ ADD NAME=AATP912  0104-00024-00027-0813-00038-00037-00000-BC0THOR\n)ATTR DEFAULT(%@\u00ac)\n        % TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        @ TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        \u00ac TYPE(OUTPUT)  INTENS(HIGH)\n        $ TYPE(INPUT)   INTENS(HIGH)  PAD('_')\n)BODY\n%AATP912   LOCATING FIELDS IN LINKAGE SECTION AREAS (BLL CELLS)\n%\n%\n@ The field named \u00acfldname                         @\n@ can be found in the Abend-Aid Dump at BLL Cell \u00acz   @+ offset \u00acz     @\n@\n@ Go to the Abend-Aid dump and locate the beginning of your program's data,\n@ which will be in a box headed: DATA DIVISION OF PROGRAM\u00acprogram @\n@\n@ Go forward to find the line: LINKAGE STORAGE REFERENCED BY BLL CELL\u00acz   @\n@\n@ Now locate the data line whose offset (DSPL column) value is:\u00acz     @\n@\n@ The field will begin in DATA column number \u00acz@ on that line. When\n@ counting data columns, remember that the first two columns are\n@ displacement and address, NOT data. The THIRD column is DATA column 1.\n@\n@ Your\u00acdatatype@field begins in byte number \u00acz@in the data column, and is\n@ \u00acfldlen@bytes long. Remember that one byte is two hex digits. For a\n@ validity check of the data, enter the value from the dump, 2 hex digits\n@ per byte:$hexdata                         @\n@\n@ Press Enter to continue, PF3 to return, or PF1 for HELP\n)INIT\n.ZVARS = '(BLCELLNO TOTLOFST TOTBLCEL LINEOFST NBRCOLS BYTEOFST)'\n.MSG = &ERRMESG\n&DATATYPE = TRANS (&FLDTYPE B,BINARY C,CHARACTER P,PACKED Z,ZONED)\n.HELP = AATH912\n)PROC\n   VER (&HEXDATA,HEX,MSG=AATM911A)\n   VPUT (HEXDATA) SHARED\n)END\n./ ADD NAME=AATP913  0104-00024-00027-0814-00038-00037-00000-BC0THOR\n)ATTR DEFAULT(%@\u00ac)\n        % TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        @ TYPE(TEXT)    INTENS(HIGH)  COLOR(GREEN) SKIP(ON)\n        \u00ac TYPE(OUTPUT)  INTENS(HIGH)\n        $ TYPE(INPUT)   INTENS(HIGH)  PAD('_')\n)BODY\n%AATP913   LOCATING FIELDS IN A RECORD IN AN FD (BLF CELLS)\n%\n%\n@ The field named \u00acfldname                         @\n@ can be found in the Abend-Aid Dump at BLF Cell \u00acz   @+ offset \u00acz     @\n@\n@ Go to the back of the Abend-Aid dump and page backward to find the page\n@ headed: DATA MANAGEMENT CONTROL BLOCKS FOR DDNAME\u00acddname  @\n@\n@ From there, search forward to find the line that says: CURRENT RECORD\n@\n@ The content of the record is shown  in three lines with character values\n@ on the top line, hexadecimal zone values on the next line, and hexadeci-\n@ mal numeric values on the third line. Below the third line is a locator\n@ bar showing byte numbers across the line in decimal relative to 1.\n@\n@ Your\u00acdatatype@field begins in byte number \u00acz     @ (decimal) and is \u00acfldlen@\n@ bytes long. Each column is one byte and the first column is column 1.\n@\n@ For a validity check of the data, enter the value from the dump, 2 hex\n@ digits per byte (types P, B, and Z only):$hexdata                         @\n@\n@ Press Enter to continue, PF3 to return, or PF1 for HELP.\n)INIT\n.HELP = AATH913\n.ZVARS = '(BLCELLNO TOTLOFST BYTEOFST)'\n.MSG = &ERRMESG\n&DATATYPE = TRANS (&FLDTYPE B,BINARY C,CHARACTER P,PACKED Z,ZONED)\n)PROC\n   VER (&HEXDATA,HEX,MSG=AATM911A)\n   VPUT (HEXDATA) SHARED\n)END\n./ ADD NAME=CBC3GIS2 0100-00250-00250-1151-00019-00019-00000-BC0THOR\n)ATTR DEFAULT(%+_)\n/* this menu is used by the ISPF example */\n      /*  % TYPE(TEXT) INTENS(HIGH)      defaults displayed for      */\n      /*  + TYPE(TEXT) INTENS(LOW)       information only            */\n\n)BODY\n%---------------------  SAMPLE ISPF DIALOG  PANEL  -----------------------------\n%OPTION ===>_ZCMD                                                              +\n+\n+  %1+ SELECTION 1      CALL C PROGRAM.\n   %2+ FUTURE           NOT IMPLEMENTED.\n   %3+ FUTURE           NOT IMPLEMENTED.\n+\n+ENTER %END+COMMAND TO TERMINATE.\n)PROC\n   &ZSEL=TRANS(TRUNC(&ZCMD,'.')\n             1,'PGM(CBC3GIS3)'\n             *,'?')\n)END\n./ ADD NAME=CBC3GIS4 0100-00250-00250-1140-00021-00021-00000-BC0THOR\n)ATTR DEFAULT(%+_)\n/* this menu is used by the ISPF example */\n      /*  % TYPE(TEXT) INTENS(HIGH)      defaults displayed for    */\n      /*  + TYPE(TEXT) INTENS(LOW)       information only*/\n      /*  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)           */\n)BODY\n%------------------------  A SAMPLE ISPF MENU ------------------------\n%OPTION ===>_ZCMD\n+\n+  %1+ SELECTION 1      NOT IMPLEMENTED.\n   %2+ SELECTION 2      EXIT\n\n+   %END+ TO EXIT.\n+\n)INIT\n  .HELP = cbc3gis5\n)PROC\n   &ZSEL=TRANS(TRUNC(&ZCMD,'.')\n         2,'EXIT'\n         *,'?')\n)END\n./ ADD NAME=CBC3GIS5 0100-00250-00250-1141-00009-00009-00000-BC0THOR\n)ATTR DEFAULT(%+_)\n/* this panel is used by the ISPF example */\n)BODY\n%---------------------  Sample Ispf Help Panel  --------------------------------\n+\n   This is a HELP panel.  Enter %END +to exit.\n\n)PROC\n)END\n./ ADD NAME=CBC3GIS7 0100-00250-00250-1142-00019-00019-00000-BC0THOR\n)ATTR DEFAULT(%+_)\n/* this menu is used by the ISPF example */\n      /*  % TYPE(TEXT) INTENS(HIGH)      defaults displayed for      */\n      /*  + TYPE(TEXT) INTENS(LOW)       information only            */\n\n)BODY\n%---------------------  SAMPLE ISPF DIALOG  PANEL  -----------------------------\n%OPTION ===>_ZCMD                                                              +\n+\n+  %1+ SELECTION 1      CALL C PROGRAM.\n   %2+ FUTURE           NOT IMPLEMENTED.\n   %3+ FUTURE           NOT IMPLEMENTED.\n+\n+ENTER %END+COMMAND TO TERMINATE.\n)PROC\n   &ZSEL=TRANS(TRUNC(&ZCMD,'.')\n             1,'PGM(CBC3GIS8)'\n             *,'?')\n)END\n./ ADD NAME=C1SD1000 0101-01065-01065-1804-00042-00042-00000-BC0THOR\n)ATTR DEFAULT(%+_)\n       /* % TYPE(TEXT) INTENS(HIGH)      DEFAULTS DISPLAYED FOR      */\n       /* + TYPE(TEXT) INTENS(LOW)       INFORMATION ONLY            */\n       /* _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)             */\n   $ TYPE(INPUT) INTENS(LOW) PAD(_)      /* UNIQUE ATTRIBUTES FOR   */\n   ! TYPE(INPUT) INTENS(LOW) PAD(NULLS)  /* DASHES AND NULL PADDING */\n   \u00a2 TYPE(OUTPUT) INTENS(HIGH) JUST(RIGHT)\n   | TYPE(OUTPUT) INTENS(LOW)\n   \u00ac TYPE(INPUT) CAPS(&VARCACCI) FORMAT(&VARFMCCI)\n   ` TYPE(INPUT) CAPS(&VARCACOM) FORMAT(&VARFMCOM)\n   ~ TYPE(INPUT) CAPS(&VARCADES) FORMAT(&VARFMDES)\n)BODY\n%-------------------  Display Elements/Component Lists  ------------------------\n%OPTION  ===>_ZCMD                                                             +\n+\n%   blank+- Display selection list     %B+- Browse element current level\n%   S+- Display summary of levels      %C+- Display changes current level\n%   M+- Display element master info    %H+- Display history current level\n+\n+   Enter%SX, BX, CX+or%HX+to display component list information\n+\n+                                    LIST OPTIONS:\n+FROM ENDEVOR:                          DISPLAY PROC GRP NAME%===>_Z+ (Y/N)\n+  ENVIRONMENT%===>_VAREVNME+           DISPLAY LIST         %===>_Z+ (Y/N)\n+  SYSTEM     %===>_SYS     +           WHERE CCID EQ        %===>\u00acVARWHCCI    +\n+  SUBSYSTEM  %===>_SBS     +   +       WHERE PROC GRP EQ    %===>_VARWPGRP+\n+  ELEMENT    %===>_CIELM     +         DISPLAY SYS/SBS LIST %===>_H+ (Y/N)\n+  TYPE       %===>_TYPEN   +           BUILD USING MAP      %===>_Z+ (Y/N)\n+  STAGE      %===>_D+     \u00a2CLU1I+-|CLU1ID  \u00a2CLU2I+-|CLU2ID\n+\n+\n+\n+\n+\n+\n+\n)INIT\n  .HELP = CITD1000\n  .ZVARS = '(VARDPGRP VARWKLST VARSHMAP)'\n  &VARDPGRP = 'Y'\n)PROC\n)END\n./ ADD NAME=DMMMAIN  0101-99361-99361-1238-00045-00045-00000-BC0THOR\n)ATTR\n        % TYPE(TEXT)    INTENS(HIGH)\n        ! TYPE(TEXT)    INTENS(HIGH)  color(white)\n        @ TYPE(TEXT)    INTENS(HIGH)  color(turq)\n        + TYPE(TEXT)    INTENS(LOW)   color(blue)\n        # TYPE(OUTPUT)  INTENS(HIGH)\n        _ TYPE(INPUT)   PAD(_)\n\n)BODY expand(\\\\)\n%-\\-\\-  Automated Systems Interface -\\-\\-\n%SELECTION ==>_ZCMD  +  %&ERPO\n+\n@1 OPSLOG+\n@2 Operators Information+\n  !2.1+Alpha Pager         !2.4+OPS/MVS Messages    !2.7+IMS Location Inquiry\n  !2.2+Endevor Archives Rpt!2.5+OPS/MVS Commands    !2.8+Broad Cast Editor\n  !2.3+Defined Applications!2.6+ISD Oncall          !2.9+Phone List\n@3 Operators Assistance+\n  !3.1+Technical Lib       !3.4+Date Verify         !3.7+Paging Interface+\n  !3.2+Oper Commands       !3.5+IMS/AOI End Times   !3.8+AOI Information+\n  !3.3+PDS Search          !3.6+Not Available       !3.9+IPL/Shutdown graph\n@4 Automation Control Services+\n  !4.1+TOD Overrides       !4.3+Service Level       !4.5+Initiator Schedule+\n  !4.2+Holidays            !4.4+Not Available       !4.6+Partial Shutdown+\n@5 Network Control Functions+\n  !5.1+Distributed Alerts  !5.4+Printers            !5.7+JES Lines+\n  !5.2+IMS Regions         !5.5+NJE Lines           !5.8+Cross Domains+\n  !5.3+CICS Regions        !5.6+IMS Trans Globals   !5.9+IMS Trans Abends+\n@6 OPS/MVS Team Options+\n  !6.1+Global Search       !6.4+DMM Activity        !6.7+Oncall Maintenance+\n  !6.2+ID Generator        !6.5+Not Available       !6.8+Restore SQL Tables+\n  !6.3+DMM Security        !6.6+Application Globals !6.9+SQL Search+\n)INIT\n)PROC\n  &ZSEL = TRANS( TRUNC (&ZCMD,'.')\n                 1,'CMD(OB)'\n                 2,'PANEL(DMM2)'\n                 3,'PANEL(DMM3)'\n                 4,'Panel(DMM4)'\n                 5,'panel(DMM5)'\n                 6,'panel(DMM6)'\n               ' ',' '\n                 X,'EXIT'\n                 *,'?' )\n)END\n./ ADD NAME=DMM2     0100-99361-99361-1240-00035-00035-00000-BC0THOR\n)ATTR\n        % TYPE(TEXT)    INTENS(HIGH)\n        + TYPE(TEXT)    INTENS(LOW)   SKIP(OFF)\n        # TYPE(OUTPUT)  INTENS(HIGH)\n        _ TYPE(INPUT)   PAD(_)\n\n)BODY expand(\\\\)\n%-\\-\\-  Operators Information -\\-\\-\n+%Selection ==>_Zcmd + %&ER2\n+\n+\n+              %1+-->%Alpha Numeric Pager system\n+              %2+-->%Endevor Archives Report\n+              %3+-->%Browse Automation components\n+              %4+-->%Browse Messages and Codes\n+              %5+-->%Browse Automation Commands\n+              %6+-->%Browse OPS/MVS On-Call\n+              %7+-->%IMS Location Inquiry\n+              %8+-->%Broad Cast Editor Utility\n+              %9+-->%Phone List\n)INIT\n)PROC\n  &ZSEL = TRANS( TRUNC (&ZCMD,'.')\n                 1,'CMD(OI DMM2100P)'\n                 2,'CMD(OI DMM2200P)'\n                 3,'CMD(OI DMM2300P)'\n                 4,'CMD(OI DMM2400P MESSAGES)'\n                 5,'CMD(OI DMM2400P COMMANDS)'\n                 6,'CMD(OI DMM2600P)'\n                 7,'CMD(OI DMM2700P)'\n                 8,'CMD(OI DMM2800P)'\n                 9,'CMD(OI DMM2900P)'\n               ' ',' '\n                 *,'?' )\n)END\n./ ADD NAME=SMPE0    0102-99041-00192-1645-00078-00001-00000-BC0THOR\n)ATTR\n   \u00ac TYPE(TEXT)    INTENS(HIGH)    COLOR(WHITE)\n   % TYPE(TEXT)    INTENS(HIGH)    COLOR(YELLOW)\n   + TYPE(TEXT)    INTENS(LOW)     COLOR(TURQ)\n   # TYPE(TEXT)    INTENS(LOW)     COLOR(BLUE)\n   _ TYPE(INPUT)   INTENS(HIGH)    COLOR(PINK)\n   @ TYPE(INPUT)   INTENS(NON)\n)BODY\n\u00ac----------------------* SMP/E Global Zone Selection *--------------------------\n+\u00acCOMMAND ===>_ZCMD                                                            +\n+                                                                              +\n+        %1 #MVS/ESA    -+MVS/ESA\u00ac5.1.0+and all other IBM products except:     +\n+        %2 #COBOL II   -  +VS COBOL II\u00ac1.4.0+                                 +\n+        %3 #LE/MVS     -  +Language Environment/MVS\u00ac1.5.0+                    +\n+        %4 #PL/I       -  +PL/I\u00ac2.3.0+                                        +\n+        %5 #HL/ASM     -  +HL/ASM\u00ac1.2.0                                       +\n+                                                                              +\n+        %7 #E-Helpdesk -+E-PRF\u00ac1.1                                            +\n+        %8 #SPS        -+SPS\u00ac3.2.0+                                           +\n+        %9 #CAI        -+Computer Associates, all products, except:           +\n+        %10#NETMAN     -  +CA-NETMAN\u00ac4.9.0+                                   +\n+        %11#VIEW       -  +CA-VIEW V\u00ac2.0+                                     +\n+                                                                              +\n+        %13#TMON/MVS   -+Landmark Systems                                     +\n+                                                                              +\n+                                                                              +\n+    Use the%number+to select the SMP/E Global Zone desired.                   +\n+                                                                              +\n+   Press the%END+key to exit.                                                 +\n)INIT\n  .CURSOR = ZCMD\n &ZCMD = &Z\n VGET (GPMSTCSI) PROFILE\n)PROC\n  IF (&ZCMD = 1)\n    &GPMSTCSI = '''SMPE.GLOBAL.CSI'''\n  IF (&ZCMD = 2)\n    &GPMSTCSI = '''SPP.COB4.SMPCSI.CSI'''\n  IF (&ZCMD = 3)\n    &GPMSTCSI = '''SPP.LEMVS.R150.SMPCSI.CSI'''\n  IF (&ZCMD = 4)\n    &GPMSTCSI = '''SPP.PLI230.CSI'''\n  IF (&ZCMD = 5)\n    &GPMSTCSI = '''SPP.HLASM.SMPE.CSI'''\n  IF (&ZCMD = 7)\n    &GPMSTCSI = '''SPP.EHELP.CSI'''\n  IF (&ZCMD = 8)\n    &GPMSTCSI = '''SPP.SPS320.CSI'''\n  IF (&ZCMD = 9)\n    &GPMSTCSI = '''CAI.SMPECSI.CSI'''\n  IF (&ZCMD = 10)\n    &GPMSTCSI = '''SPP.NETMAN.SMPCSI.CSI'''\n  IF (&ZCMD = 11)\n    &GPMSTCSI = '''SPP.VIEW.V20.SMPCSI.CSI'''\n  IF (&ZCMD = 13)\n    &GPMSTCSI = '''SPP.TMONMVS.CSI'''\n VPUT (GPMSTCSI) PROFILE\n &ZSEL = TRANS( TRUNC (&ZCMD,'.')\n                1,'PGM(GIMSTART) PARM(&ZCMD) NOCHECK'\n                2,'PGM(GIMSTART) PARM(&ZCMD) NOCHECK'\n                3,'PGM(GIMSTART) PARM(&ZCMD) NOCHECK'\n                4,'PGM(GIMSTART) PARM(&ZCMD) NOCHECK'\n                5,'PGM(GIMSTART) PARM(&ZCMD) NOCHECK'\n                6,'PGM(GIMSTART) PARM(&ZCMD) NOCHECK'\n                7,'PGM(GIMSTART) PARM(&ZCMD) NOCHECK'\n                8,'PGM(GIMSTART) PARM(&ZCMD) NOCHECK'\n                9,'PGM(GIMSTART) PARM(&ZCMD) NOCHECK'\n               10,'PGM(GIMSTART) PARM(&ZCMD) NOCHECK'\n               11,'PGM(GIMSTART) PARM(&ZCMD) NOCHECK'\n               12,'PGM(GIMSTART) PARM(&ZCMD) NOCHECK'\n               13,'PGM(GIMSTART) PARM(&ZCMD) NOCHECK'\n               14,'PGM(GIMSTART) PARM(&ZCMD) NOCHECK'\n               15,'PGM(GIMSTART) PARM(&ZCMD) NOCHECK'\n                X,'EXIT'\n              ' ',' '\n               *,'?' )\n &ZTRAIL = .TRAIL\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE562": {"ttr": 1287, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x19\\x01\\x01\\x02_\\x01\\x02\\x10O\\x08\\t\\x00\\x1a\\x00\\x02\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2001-01-25T00:00:00", "modifydate": "2002-04-14T08:09:19", "lines": 26, "newlines": 2, "modlines": 0, "user": "SBGOLOB"}, "text": "//***FILE 562 is from Dick Thornton, who is the author of the       *   FILE 562\n//*           DISASSEMBLER program on File 217, and his new         *   FILE 562\n//*           DISASSEMBLER program on File 234.  This is his EXEC   *   FILE 562\n//*           library which also contains an ISPF panel library     *   FILE 562\n//*           (as member $PNLS) and an ISPF message library (as     *   FILE 562\n//*           member $MSGS).  Member $$PDSLOD is a job to create    *   FILE 562\n//*           pds'es from the $MSGS and $PNLS members of this file. *   FILE 562\n//*                                                                 *   FILE 562\n//*           emails:  (check to see which are relevant):           *   FILE 562\n//*               dickthor@hotmail.com                              *   FILE 562\n//*               cthornton@swva.net                                *   FILE 562\n//*               rthornton@trigon.com                              *   FILE 562\n//*                                                                 *   FILE 562\n//*      I am including three XMIT files in this package.           *   FILE 562\n//*                                                                 *   FILE 562\n//*      They are EXEC, MSGS, and PLIB which together contain an    *   FILE 562\n//*      ISPF dialog I wrote in an attempt to give our              *   FILE 562\n//*      programmers an online guide to reading Abend-Aid dumps.    *   FILE 562\n//*      It is intended to provide instructions a programmer can    *   FILE 562\n//*      use to analyze a SYSUDUMP produced by Abend-Aid in order   *   FILE 562\n//*      to locate the abending instruction and the corresponding   *   FILE 562\n//*      instruction in their COBOL source program.  In addition,   *   FILE 562\n//*      it aids in location of selected data fields in the dump.   *   FILE 562\n//*      It isn't used extensively here, as I didn't follow up      *   FILE 562\n//*      and issue training and advertising about it.               *   FILE 562\n//*                                                                 *   FILE 562\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "AATX000": {"ttr": 1289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00)\\x01\\x00\\x02O\\x01\\x00\\x02O\\x130\\x00\\x0e\\x00\\x0e\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-24T00:00:00", "modifydate": "2000-01-24T13:30:29", "lines": 14, "newlines": 14, "modlines": 0, "user": "BC0THOR"}, "text": "/**REXX****************************************************************/\n/*  NAME      - AATX000                                               */\n/*  PROJECT   - ABENDAID TOOL DIALOG                                  */\n/*  TYPE      - TSO REXX                                              */\n/*  FUNCTION  - DISPLAY PRIMARY ABENDAID MENU WHICH SERVES AS AN      */\n/*              EXECUTIVE DIRECTOR FOR THE DIALOG.                    */\n/*  CALLED BY - USER TO INITIATE THE DIALOG                           */\n/*  RELATED   - PANEL AATP000, OTHER AAT MEMBERS IN EXEC, PLIB, MSGS  */\n/*  AUTHOR    - DICK THORNTON DEC 1999                                */\n/**********************************************************************/\nNUMERIC DIGITS 32             /* SET NUMBER DIGITS FOR CALCULATIONS */\nERRMESG = 'AATM001'  /* COBOL BINARY FIELDS ARE */\nADDRESS 'ISPEXEC' \"SELECT PANEL(AATP000)\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AATX010": {"ttr": 1291, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x04\\x01\\x00\\x02O\\x01\\x01\\x03o\\x15\\x10\\x00G\\x00G\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2000-01-24T00:00:00", "modifydate": "2001-02-05T15:10:04", "lines": 71, "newlines": 71, "modlines": 0, "user": "BC0THOR"}, "text": "/*REXX*****************************************************************/\n/*  NAME      -  AATX010                                              */\n/*  PROJECT   -  ABEND-AID TOOLS (AAT)                                */\n/*  TYPE      -  REXX PROGRAM                                         */\n/*  FUNCTION  -  DISPLAYS PANEL AATP010 TO COLLECT THE ABEND-TIME     */\n/*               INFORMATION INCLUDING PROGRAM NAME, ABEND COMPLETION */\n/*               CODE, ABEND DISPLACEMENT, AND PROGRAM LENGTH. USER   */\n/*               LOCATES AND ENTERS THE HEXLOC AND INSTRUCTION NUMBER */\n/*               USING THE COBOL CONDENSED LISTING AND THE DUMP.      */\n/*               INFORMATION ENTERED IS VALIDATED AS POSSIBLE.        */\n/*  CALLED BY -  PANEL AATP000                                        */\n/*  RELATED   -  PANEL AATP010, MSG AATM01                            */\n/*  CALLS     -  PANEL AATP014                                        */\n/*  AUTHOR    -  DICK THORNTON JAN 2000                               */\n/**********************************************************************/\n/**********************************************************************/\n/*  THE PROGRAM VALIDATES DATA ENTERED BY THE USER ON PANEL AATP010   */\n/**********************************************************************/\n/* TRACE ?ALL */\nNUMERIC DIGITS 32             /* SET NUMBER DIGITS FOR CALCULATIONS */\nCURSLOC = 'PROGRAM'\nERRMESG = ''\nDO FOREVER\n   ADDRESS ISPEXEC 'DISPLAY PANEL(AATP010)' /*DISPLAY PANEL AATP010*/\n   IF RC \u00ac= 0 THEN EXIT    /* ASSUME PF3 HIT IF RC IS NOT 0 */\n   IF ((SUBSTR(COMP,1,1) = 'S') | (SUBSTR(COMP,1,1) = 'U')) THEN NOP\n   ELSE DO\n      CURSLOC = 'COMP'      /* SET CURSOR TO COMP FIELD */\n      ERRMESG = 'AATM016'   /* SET ERROR MESSAGE */\n      ITERATE               /* GO RE-DISPLAY */\n   END\n   IF DATATYPE(SUBSTR(COMP,2,3),X) THEN NOP\n   ELSE DO\n      CURSLOC = 'COMP'      /* SET CURSOR TO COMP FIELD */\n      ERRMESG = 'AATM016'   /* SET ERROR MESSAGE */\n      ITERATE               /* GO RE-DISPLAY */\n   END\n   DISP = X2D(ABDISP)      /* MAKE ABEND DISPLACEMENT NUMERIC  */\n   PRGLN = X2D(PGMLEN)     /* MAKE PROGRAM LENGTH NUMERIC */\n   ODD = DISP // 2         /* ODD = 1 IF DISP IS AN ODD NUMBER */\n   IF (DISP > PRGLN) THEN DO\n      CURSLOC = 'PGMLEN'    /* SET CURSOR TO PGMLEN FIELD */\n      ERRMESG = 'AATM019'   /* SET ERROR MESSAGE */\n      ITERATE               /* GO RE-DISPLAY */\n   END\n   IF ODD = 1 THEN /* ODD DISPLACEMENT IS AN ERROR */\n      IF COMP = 'S0C6' THEN NOP /* (EXCEPT FOR S0C6) */\n      ELSE DO\n         CURSLOC = 'ABDISP'    /* SET CURSOR TO DISPLACEMENT FIELD */\n         ERRMESG = 'AATM017'   /* SET ERROR MESSAGE */\n         ITERATE               /* GO RE-DISPLAY */\n      END\n   LOCN = X2D(HEXLOC)      /* MAKE HEX LOCATION NUMERIC */\n   IF DISP > LOCN THEN DO  /* HEXLOC MUST BE > DISPLACEMENT */\n      IF ((DISP - LOCN) > 32) THEN DO  /* IF >32 BYTES BETWEEN */\n         CURSLOC = 'HEXLOC'    /* SET CURSOR TO HEXLOC FIELD */\n         ERRMESG = 'AATM018'   /* TELL USER TO CHECK */\n         ITERATE               /* GO RE-DISPLAY */\n      END\n      ELSE DO\n         CURSLOC = 'LINENO'    /* SET CURSOR TO HEXLOC FIELD */\n         ADDRESS ISPEXEC 'DISPLAY PANEL(AATP014)' /*DISPLAY AATP014*/\n      END\n   END\n   ELSE DO\n      CURSLOC = 'HEXLOC'    /* SET CURSOR TO HEXLOC FIELD */\n      ERRMESG = 'AATM014'   /* SET ERROR MESSAGE */\n      ITERATE               /* GO RE-DISPLAY */\n   END\n   ADDRESS ISPEXEC \"VPUT (CURSLOC ERRMESG) SHARED\"\nEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AATX020": {"ttr": 1294, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x004\\x01\\x00\\x02O\\x01\\x00\\x02O\\x133\\x00\\x11\\x00\\x11\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-24T00:00:00", "modifydate": "2000-01-24T13:33:34", "lines": 17, "newlines": 17, "modlines": 0, "user": "BC0THOR"}, "text": "/*REXX*****************************************************************/\n/*  NAME      -  AATX020                                              */\n/*  PROJECT   -  ABEND-AID TOOLS (AAT)                                */\n/*  TYPE      -  REXX PROGRAM                                         */\n/*  FUNCTION  -  DISPLAYS GENERIC INFORMATION CONCERNING ABENDS THAT  */\n/*               OCCUR IN CALLED SUBROUTINES. SUGGESTIONS ARE GIVEN,  */\n/*               BUT NO INFORMATION IS ENTERED ON THIS PANEL.         */\n/*  CALLED BY -  PANEL AATP000                                        */\n/*  RELATED   -  PANEL AATP020                                        */\n/*  AUTHOR    -  DICK THORNTON JAN 2000                               */\n/**********************************************************************/\n/**********************************************************************/\n/*  THE PROGRAM VALIDATES DATA ENTERED BY THE USER ON PANEL AATP020   */\n/**********************************************************************/\n/* TRACE ?ALL */\nNUMERIC DIGITS 32             /* SET NUMBER DIGITS FOR CALCULATIONS */\nADDRESS ISPEXEC 'DISPLAY PANEL(AATP020)' /* DISPLAY PANEL AATP020*/\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "AATX030": {"ttr": 1296, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x005\\x01\\x00\\x02O\\x01\\x00\\x02O\\x16\\x19\\x00u\\x00t\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2000-01-24T00:00:00", "modifydate": "2000-01-24T16:19:35", "lines": 117, "newlines": 116, "modlines": 0, "user": "BC0THOR"}, "text": "/*REXX*****************************************************************/\n/*  NAME      -  AATX030                                              */\n/*  PROJECT   -  ABEND-AID TOOLS (AAT)                                */\n/*  TYPE      -  REXX PROGRAM                                         */\n/*  FUNCTION  -  DISPLAYS PANEL AATP030 TO COLLECT INFORMATION ON THE */\n/*               WORKING STORAGE FIELD TO BE LOCATED AND VALIDATED IN */\n/*               THE DUMP. USER ENTERS DATA SUCH AS FIELD NAME, BL    */\n/*               CELL TYPE, BL CELL NUMBER, BL CELL OFFSET, DATA TYPE,*/\n/*               FIELD LENGTH, DDNAME (FOR BLF CELLS), AND OFFSET DUE */\n/*               TO ANY SUBSCRIPT OR INDEX. WHEN DATA ENTERED ON THE  */\n/*               AATP030 SCREEN IS CORRECT, PANEL AATP911 IS SHOWN    */\n/*               FOR BLW CELLS, PANEL AATP912 IS SHOWN FOR BLL CELLS, */\n/*               OR PANEL AATP913 IS SHOWN FOR BLF CELLS. THESE PANELS*/\n/*               TELL THE USER HOW TO FIND THE FIELD IN MEMORY, AND   */\n/*               OBTAINS THAT VALUE FROM THE USER. FINALLY, THE       */\n/*               AATP034 PANEL IS DISPLAYED TO ANALYZE FIELD CONTENT  */\n/*  CALLED BY -  PANEL AATP000                                        */\n/*  RELATED   -  PANELS AATP911-AATP913, AATH030, AND MSG AATM03      */\n/*  CALLS     -  AATX034                                              */\n/*  AUTHOR    -  DICK THORNTON JAN 2000                               */\n/**********************************************************************/\n/**********************************************************************/\n/*  THE PROGRAM RUNS IN A NEVER ENDING LOOP UNTIL THE USER HITS PF3   */\n/*  1. INITIALIZE VARIABLES.                                          */\n/*  2. DISPLAY THE AATP030 PANEL TO OBTAIN THE FIELD VARIABLE INFO.   */\n/*  3. ON RETURN FROM PANEL AATP030, EXIT IF THE USER HAS HIT PF3.    */\n/*  4. VALIDATE THE USER SUPPLIED VARIABLES. IF ANY ERROR OCCURS,     */\n/*     REDISPLAY AATP030 WITH AN ERROR MESSAGE AND THE CURSOR SET ON  */\n/*     THE FIELD IN ERROR.                                            */\n/*  5. SET UP VARIABLES FOR THE AATP911, AATP912, OR AATP913 PANEL    */\n/*  6. DISPLAY THE AATP911-AATP913 TO SHOW THE RESULTS TO THE USER.   */\n/*  7. ON RETURN DISPLAY PANEL AATP034 TO SHOW DATA ANALYSIS.         */\n/*  8. REPEAT STEPS 1-9.                                              */\n/**********************************************************************/\n/* TRACE ?ALL */\nNUMERIC DIGITS 32             /* SET NUMBER DIGITS FOR CALCULATIONS */\nDO FOREVER\n   FLDNAME = ''; FLDTYPE = ' '; BLCELLTY = ' '; BLCELLNO = '';\n   BLOFF = ''; FLDLEN = ''; DDNAME = ''; SUBIDX = ''; HEXDATA = '';\n   ERROR = 1; ERRMESG = ''; CURSLOC = 'FLDNAME'\n   DO FOREVER\n      ADDRESS ISPEXEC 'DISPLAY PANEL(AATP030)'\n      IF RC \u00ac= 0 THEN EXIT    /* ASSUME PF3 HIT OF RC IS NOT 0 */\n      ERROR = 0; ERRMESG = ''; CURSLOC = 'FLDNAME'\n      CALL VALIDATE           /* VALIDATE PANEL VARIABLES */\n      IF ERROR \u00ac= 0 THEN ITERATE /* IF ERROR, RE-DISPLAY AATP030 */\n      HEXDATA = ''\n      DO FOREVER\n         IF BLCELLTY = 'W' THEN\n            ADDRESS ISPEXEC 'DISPLAY PANEL(AATP911)'  /* BLW */\n         ELSE\n            IF BLCELLTY = 'L' THEN\n               ADDRESS ISPEXEC 'DISPLAY PANEL(AATP912)'  /* BLL */\n            ELSE\n               ADDRESS ISPEXEC 'DISPLAY PANEL(AATP913)'  /* BLF */\n         IF RC \u00ac= 0 THEN EXIT    /* ASSUME PF3 HIT IF RC IS NOT 0 */\n         IF (LENGTH(HEXDATA) = (2 * FLDLEN)) THEN LEAVE\n         ELSE DO\n            ERRMESG = 'AATM036'  /* HEX REQUIRES 2 DIGITS PER BYTE */\n            CURSLOC = 'HEXDATA'\n            ITERATE\n         END\n      END\n      ERROR = 0; ERRMESG = ''; CURSLOC = 'FLDNAME'\n      ADDRESS ISPEXEC \"VPUT (FLDNAME FLDTYPE BLCELLTY \" ||,\n         \"BLCELLNO BLOFF FLDLEN DDNAME SUBIDX HEXDATA \" ||,\n         \"ERRMESG CURSLOC) SHARED\"\n      CALL AATX034            /* VALIDATE FIELD DATA */\n   END\nEND\n/********************************************************************/\n/*  VALIDATE THE VARIABLE DATA ENTERED BY THE USER AND BUILD THE    */\n/*  ADDITIONAL VARIABLES FOR THE AATP911-AATP913 PANELS             */\n/********************************************************************/\nVALIDATE:\n   IF FLDTYPE = B THEN DO\n      IF ((FLDLEN = 2) | (FLDLEN = 4) | (FLDLEN = 8)) THEN NOP\n      ELSE DO\n         ERROR = 1\n         ERRMESG = 'AATM035'  /* COBOL BINARY FIELDS ARE */\n         CURSLOC = 'FLDLEN'   /* ALWAYS 2, 4, OR 8 BYTES LONG */\n         RETURN\n      END\n   END\n   IF (FLDLEN > 32) THEN DO\n      ERROR = 1\n      ERRMESG = 'AATM037'   /* CANNOT HANDLE FIELDS > 16 BYTES */\n      CURSLOC = 'FLDLEN'\n      RETURN\n   END\n   TOTLOFST = X2D(BLOFF) + X2D(SUBIDX)   /* COMPUTE TOTAL OFFSET */\n   TOTBLCEL = X2D(BLCELLNO)             /* CONVERT BLWCELL FOR COMP */\n   DO WHILE TOTLOFST > 4095\n      TOTLOFST = TOTLOFST - 4096         /* DEDUCT 4,096 BYTES */\n      TOTBLCEL = TOTBLCEL + 1            /* ADD 1 TO BL CELL */\n   END\n   LINEOFST = TOTLOFST                   /* COPY TOTAL OFFSET */\n   LINEOFST = (LINEOFST % 16) * 16       /* MAKE LOW BYTE 0 */\n   X = (LINEOFST % 16) // 2              /* CHECK IF 4TH DIGIT IS ODD */\n   IF X = 1 THEN                         /* GET CORRECT LINE OFFSET */\n         LINEOFST = LINEOFST - 16        /* GET CORRECT LINE OFFSET */\n   NBRCOLS = ((TOTLOFST - LINEOFST) % 4) + 1 /* COLUMN NUMBER */\n   BYTEOFST = ((TOTLOFST - LINEOFST) //4) + 1 /* BYTE NUMBER IN COL */\n   IF BLCELLTY = 'F' THEN DO\n      TOTLOFST = TOTLOFST + 1            /* FOR BLF, MAKE 1-RELATIVE */\n      BYTEOFST = TOTLOFST                /* SAME FOR BYTE OFFSET */\n      TOTBLCEL = BLCELLNO              /* COPY TOTAL BL CELL VALUE */\n   END\n   ELSE DO\n      TOTLOFST = D2X(TOTLOFST,6)            /* CONVERT BACK TO HEX */\n      LINEOFST = D2X(LINEOFST,6)            /* CONVERT BACK TO HEX */\n      TOTBLCEL = D2X(TOTBLCEL,4)            /* CONVERT BACK TO HEX */\n      NBRCOLS = D2X(NBRCOLS,1)              /* CONVERT BACK TO HEX */\n      BYTEOFST = D2X(BYTEOFST,1)            /* CONVERT BACK TO HEX */\n      BLCELLNO = TOTBLCEL              /* COPY TOTAL BL CELL VALUE */\n   END\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AATX034": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00C\\x01\\x00\\x02O\\x01\\x00\\x02O\\x14&\\x00\\x83\\x00\\x83\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-01-24T00:00:00", "modifydate": "2000-01-24T14:26:43", "lines": 131, "newlines": 131, "modlines": 0, "user": "BC0THOR"}, "text": "/*REXX*****************************************************************/\n/*  NAME      -  AATX034                                              */\n/*  PROJECT   -  ABEND-AID TOOLS (AAT)                                */\n/*  TYPE      -  REXX PROGRAM                                         */\n/*  FUNCTION  -  VALIDATES THE CONTENT OF A DATAFIELD FOUND IN THE    */\n/*               DUMP WHOSE HEX CONTENT IS GIVEN IN THE HEXDATA       */\n/*               VARIABLE. VALIDITY CHECK IS MADE BASED ON THE FLDTYPE*/\n/*               AND FLDLEN VARIABLES. THE DECIMAL VALUE IS PLACED IN */\n/*               THE DECVAL VARIABLE FOR NUMERIC FIELDS.              */\n/*  CALLED BY -  REXX PROGRAM AATX030                                 */\n/*  RELATED   -  PANELS AATP034 AND MSG AATM03                        */\n/*  CALLS     -                                                       */\n/*  AUTHOR    -  DICK THORNTON JAN 2000                               */\n/**********************************************************************/\n/* TRACE ?ALL */\nNUMERIC DIGITS 32             /* SET NUMBER DIGITS FOR CALCULATIONS */\nADDRESS ISPEXEC \"VGET (FLDNAME FLDTYPE BLCELL \" ||,\n\"BLCELLTY FLDOFF FLDLEN HEXDATA DECVAL ERROR  \" ||,\n\"ERRMESG CURSLOC CHAR ZONE NUM) SHARED\"\nIF HEXDATA = '' THEN RETURN\nHEXLEN = LENGTH(HEXDATA)\nDECVAL = ''\nBL = 'BL'||BLCELLTY\nIF HEXLEN \u00ac= (2 * FLDLEN) THEN DO\n   ERROR = 1\n   ERRMESG = 'AATM039A'  /* INCORRECT HEX LENGTH */\n   CURSLOC = 'HEXDATA'  /* SET CURSOR LOCATION */\n   RETURN\nEND\nIF FLDTYPE = 'B' THEN\n   DECVAL = X2D(HEXDATA,HEXLEN)   /* SET UP DECIMAL EQUIVALENT */\nELSE\n   IF FLDTYPE = 'P' THEN\n      CALL PACKED_DECIMAL  /* VALIDATE, BUILD DECIMAL VALUE */\n   ELSE\n      IF FLDTYPE = 'Z' THEN\n         CALL ZONED_DECIMAL /* VALIDATE, BUILD DECIMAL VALUE */\nCALL CHAR_HEX_TRANSLATE    /* BUILD CHAR/ZONE/NUM EQUIVALENT */\nADDRESS ISPEXEC 'DISPLAY PANEL(AATP034)'\nRETURN\n/********************************************************************/\n/* VALIDATE PACKED_DECIMAL FIELDS                                   */\n/********************************************************************/\nPACKED_DECIMAL:\nDO I = 1 TO HEXLEN\n   CH = SUBSTR(HEXDATA,I,1)\n   IF I = HEXLEN THEN DO\n      IF CH = 'D' THEN DECVAL = '-' || DECVAL\n      ELSE DO\n         IF CH = 'C' THEN DECVAL = '+' || DECVAL\n         ELSE DO\n            IF CH \u00ac= 'F' THEN DO\n               ERROR = 1\n               ERRMESG = 'AATM039B' /*INVALID PACKED SIGN */\n               CURSLOC = 'HEXDATA'  /*SET CURSOR LOCATION */\n               DECVAL = ''          /* CLEAR ANY DECIMAL VALUE */\n               RETURN\n            END\n         END\n      END\n   END\n   ELSE DO\n      IF ((CH >= '0') & (CH <= '9')) THEN\n         DECVAL = DECVAL || CH\n      ELSE DO\n         ERROR = 1\n         ERRMESG = 'AATM039C' /* INVALID PACKED DIGIT */\n         CURSLOC = 'HEXDATA'  /* SET CURSOR LOCATION */\n         DECVAL = ''          /* CLEAR ANY DECIMAL VALUE */\n         RETURN\n      END\n   END\nEND\nRETURN\n/********************************************************************/\n/* VALIDATE ZONED DECIMAL FIELDS                                    */\n/********************************************************************/\nZONED_DECIMAL:\nDO I = 1 TO HEXLEN BY 2 while I < (HEXLEN - 1)\n   ZONE = SUBSTR(HEXDATA,I,1)\n   NUM  = SUBSTR(HEXDATA,I+1,1)\n   IF ((NUM >= '0') & (NUM <= '9') & (ZONE = 'F')) THEN\n         DECVAL = DECVAL || NUM\n   ELSE DO\n      ERROR = 1\n      ERRMESG = 'AATM039D' /* INVALID ZONED NUMERIC */\n      CURSLOC = 'HEXDATA'  /* SET CURSOR LOCATION */\n      DECVAL = ''          /* CLEAR ANY DECIMAL VALUE */\n      RETURN\n   END\nEND\nZONE = SUBSTR(HEXDATA,HEXLEN - 1,1)\nNUM  = SUBSTR(HEXDATA,HEXLEN,1)\nIF ((NUM >= '0') & (NUM <= '9')) THEN\n   DECVAL = DECVAL || NUM\nELSE DO\n      ERROR = 1\n      ERRMESG = 'AATM039D' /* INVALID ZONED NUMERIC */\n      CURSLOC = 'HEXDATA'  /* SET CURSOR LOCATION */\n      DECVAL = ''          /* CLEAR ANY DECIMAL VALUE */\n      RETURN\nEND\nIF ZONE = 'D' THEN DECVAL = '-' || DECVAL\n   ELSE DO\n      IF ZONE = 'C' THEN DECVAL = '+' || DECVAL\n      ELSE DO\n         IF ZONE \u00ac= 'F' THEN DO\n             ERROR = 1\n             ERRMESG = 'AATM039E' /* INVALID ZONED SIGN */\n             CURSLOC = 'HEXDATA'  /* SET CURSOR LOCATION */\n             DECVAL = ''          /* CLEAR ANY DECIMAL VALUE */\n             RETURN\n         END\n      END\n   END\nRETURN\n/********************************************************************/\n/* BUILD THE CHARACTER/ZONE/NUMERIC DISPLAY                         */\n/********************************************************************/\nCHAR_HEX_TRANSLATE:\nCHAR = ''; ZONE = ''; NUM = ''\nDO I = 1 TO HEXLEN BY 2\n   ZONE = ZONE || SUBSTR(HEXDATA,I,1)\n   NUM  = NUM || SUBSTR(HEXDATA,I+1,1)\nEND\nCHAR = X2C(HEXDATA)          /* CONVERT CHARACTER HEX TO REAL HEX */\nCHAR = TRANSLATE(CHAR,\"abcdefghi\",\"818283848586878889\"X)\nCHAR = TRANSLATE(CHAR,\"jklmnopqr\",\"919293949596979899\"X)\nCHAR = TRANSLATE(CHAR,\"stuvwxyz\",\"A2A3A4A5A6A7A8A9\"X)\nADDRESS ISPEXEC \"VPUT (CHAR ZONE NUM) SHARED\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AATX060": {"ttr": 1540, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x16\\x01\\x00\\x02O\\x01\\x00\\x02O\\x16\\x19\\x00|\\x00{\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2000-01-24T00:00:00", "modifydate": "2000-01-24T16:19:16", "lines": 124, "newlines": 123, "modlines": 0, "user": "BC0THOR"}, "text": "/*REXX*****************************************************************/\n/*  NAME      -  AATX060                                              */\n/*  PROJECT   -  ABEND-AID TOOLS (AAT)                                */\n/*  TYPE      -  REXX PROGRAM                                         */\n/*  FUNCTION  -  DISPLAYS PANEL AATP060 TO COLLECT INFORMATION ON THE */\n/*               WORKING STORAGE FIELD TO BE LOCATED AND VALIDATED IN */\n/*               THE DUMP. USER ENTERS DATA SUCH AS FIELD NAME, BL    */\n/*               CELL TYPE, BL CELL NUMBER, BL CELL OFFSET, DATA TYPE,*/\n/*               FIELD LENGTH, DDNAME (FOR BLF CELLS), OCCURS NUMBER, */\n/*               AND LENGTH OF OCCURRING ITEM. WHEN DATA ENTERED ON   */\n/*               PANEL AATP060 IS CORRECT, PANEL AATP911 IS SHOWN     */\n/*               FOR BLW CELLS, PANEL AATP912 IS SHOWN FOR BLL CELLS, */\n/*               OR PANEL AATP913 IS SHOWN FOR BLF CELLS. THESE PANELS*/\n/*               TELL THE USER HOW TO FIND THE FIELD IN MEMORY, AND   */\n/*               OBTAINS THAT VALUE FROM THE USER. FINALLY, THE       */\n/*               AATP064 PANEL IS DISPLAYED TO ANALYZE FIELD CONTENT  */\n/*               INCLUDING OCCURRENCE NUMBER AND DISPLACEMENT VALUES. */\n/*  CALLED BY -  PANEL AATP000                                        */\n/*  RELATED   -  PANELS AATP911-AATP913, AATH060, AND MSG AATM06      */\n/*  CALLS     -  AATX064                                              */\n/*  AUTHOR    -  DICK THORNTON JAN 2000                               */\n/**********************************************************************/\n/**********************************************************************/\n/*  THE PROGRAM RUNS IN A NEVER ENDING LOOP UNTIL THE USER HITS PF3   */\n/*  1. INITIALIZE VARIABLES.                                          */\n/*  2. DISPLAY THE AATP060 PANEL TO OBTAIN THE FIELD VARIABLE INFO.   */\n/*  3. ON RETURN FROM PANEL AATP060, EXIT IF THE USER HAS HIT PF3.    */\n/*  4. VALIDATE THE USER SUPPLIED VARIABLES. IF ANY ERROR OCCURS,     */\n/*     REDISPLAY AATP060 WITH AN ERROR MESSAGE AND THE CURSOR SET ON  */\n/*     THE FIELD IN ERROR.                                            */\n/*  5. SET UP VARIABLES FOR THE AATP911, AATP912, OR AATP913 PANEL    */\n/*  6. DISPLAY THE AATP911-AATP913 TO SHOW THE RESULTS TO THE USER.   */\n/*  7. ON RETURN DISPLAY PANEL AATP064 TO SHOW DATA ANALYSIS.         */\n/*  8. REPEAT STEPS 1-9.                                              */\n/**********************************************************************/\n/* TRACE ?ALL */\nNUMERIC DIGITS 32             /* SET NUMBER DIGITS FOR CALCULATIONS */\nDO FOREVER\n   FLDNAME = ''; FLDTYPE = ' '; BLCELLTY = ' '; BLCELLNO = '';\n   BLOFF = ''; FLDLEN = ''; DDNAME = ''; HEXDATA = ''; OCCLEN = '';\n   ERROR = 1; ERRMESG = ''; CURSLOC = 'FLDNAME'; OCCNBR = '';\n   DO FOREVER\n      ADDRESS ISPEXEC 'DISPLAY PANEL(AATP060)'\n      IF RC \u00ac= 0 THEN EXIT    /* ASSUME PF3 HIT OF RC IS NOT 0 */\n      ERROR = 0; ERRMESG = ''; CURSLOC = 'FLDNAME'\n      CALL VALIDATE           /* VALIDATE PANEL VARIABLES */\n      IF ERROR \u00ac= 0 THEN ITERATE /* IF ERROR, RE-DISPLAY AATP060 */\n      HEXDATA = ''\n      DO FOREVER\n         IF BLCELLTY = 'W' THEN\n            ADDRESS ISPEXEC 'DISPLAY PANEL(AATP911)'  /* BLW */\n         ELSE\n            IF BLCELLTY = 'L' THEN\n               ADDRESS ISPEXEC 'DISPLAY PANEL(AATP912)'  /* BLL */\n            ELSE\n               ADDRESS ISPEXEC 'DISPLAY PANEL(AATP913)'  /* BLF */\n         IF RC \u00ac= 0 THEN EXIT    /* ASSUME PF3 HIT IF RC IS NOT 0 */\n         IF (LENGTH(HEXDATA) = (2 * FLDLEN)) THEN LEAVE\n         ELSE DO\n            ERRMESG = 'AATM066'  /* HEX REQUIRES 2 DIGITS PER BYTE */\n            CURSLOC = 'HEXDATA'\n            ITERATE\n         END\n      END\n      ERROR = 0; ERRMESG = ''; CURSLOC = 'FLDNAME'\n      ADDRESS ISPEXEC \"VPUT (FLDNAME FLDTYPE BLCELLTY \" ||,\n         \"BLCELLNO BLOFF FLDLEN DDNAME OCCNBR OCCLEN HEXDATA \" ||,\n         \"ERRMESG CURSLOC) SHARED\"\n      CALL AATX064            /* VALIDATE FIELD DATA */\n   END\nEND\n/********************************************************************/\n/*  VALIDATE THE VARIABLE DATA ENTERED BY THE USER AND BUILD THE    */\n/*  ADDITIONAL VARIABLES FOR THE AATP911-AATP913 PANELS             */\n/********************************************************************/\nVALIDATE:\n   IF FLDTYPE = B THEN DO\n      IF ((FLDLEN = 2) | (FLDLEN = 4) | (FLDLEN = 8)) THEN NOP\n      ELSE DO\n         ERROR = 1\n         ERRMESG = 'AATM065'  /* COBOL BINARY FIELDS ARE */\n         CURSLOC = 'FLDLEN'   /* ALWAYS 2, 4, OR 8 BYTES LONG */\n         RETURN\n      END\n   END\n   IF (FLDLEN > 32) THEN DO\n      ERROR = 1\n      ERRMESG = 'AATM067'   /* CANNOT HANDLE FIELDS > 16 BYTES */\n      CURSLOC = 'FLDLEN'\n      RETURN\n   END\n   IF (OCCNBR <= 1) THEN DO\n      ERROR = 1\n      ERRMESG = 'AATM060A'  /* OCCNBR MUST BE > 0 */\n      CURSLOC = 'OCCNBR'\n      RETURN\n   END\n   TOTLOFST = X2D(BLOFF)                 /* COMPUTE TOTAL OFFSET */\n   TOTBLCEL = X2D(BLCELLNO)             /* CONVERT BLWCELL FOR COMP */\n   DO WHILE TOTLOFST > 4095\n      TOTLOFST = TOTLOFST - 4096         /* DEDUCT 4,096 BYTES */\n      TOTBLCEL = TOTBLCEL + 1            /* ADD 1 TO BL CELL */\n   END\n   LINEOFST = TOTLOFST                   /* COPY TOTAL OFFSET */\n   LINEOFST = (LINEOFST % 16) * 16       /* MAKE LOW BYTE 0 */\n   X = (LINEOFST % 16) // 2              /* CHECK IF 4TH DIGIT IS ODD */\n   IF X = 1 THEN                         /* GET CORRECT LINE OFFSET */\n         LINEOFST = LINEOFST - 16        /* GET CORRECT LINE OFFSET */\n   NBRCOLS = ((TOTLOFST - LINEOFST) % 4) + 1 /* COLUMN NUMBER */\n   BYTEOFST = ((TOTLOFST - LINEOFST) //4) + 1 /* BYTE NUMBER IN COL */\n   IF BLCELLTY = 'F' THEN DO\n      TOTLOFST = TOTLOFST + 1            /* FOR BLF, MAKE 1-RELATIVE */\n      BYTEOFST = TOTLOFST                /* SAME FOR BYTE OFFSET */\n      TOTBLCEL = BLCELLNO              /* COPY TOTAL BL CELL VALUE */\n   END\n   ELSE DO\n      TOTLOFST = D2X(TOTLOFST,6)            /* CONVERT BACK TO HEX */\n      LINEOFST = D2X(LINEOFST,6)            /* CONVERT BACK TO HEX */\n      TOTBLCEL = D2X(TOTBLCEL,4)            /* CONVERT BACK TO HEX */\n      NBRCOLS = D2X(NBRCOLS,1)              /* CONVERT BACK TO HEX */\n      BYTEOFST = D2X(BYTEOFST,1)            /* CONVERT BACK TO HEX */\n      BLCELLNO = TOTBLCEL              /* COPY TOTAL BL CELL VALUE */\n   END\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AATX064": {"ttr": 1543, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00E\\x01\\x00\\x02O\\x01\\x00\\x02O\\x14W\\x00\\x8f\\x00\\x92\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2000-01-24T00:00:00", "modifydate": "2000-01-24T14:57:45", "lines": 143, "newlines": 146, "modlines": 0, "user": "BC0THOR"}, "text": "/*REXX*****************************************************************/\n/*  NAME      -  AATX064                                              */\n/*  PROJECT   -  ABEND-AID TOOLS (AAT)                                */\n/*  TYPE      -  REXX PROGRAM                                         */\n/*  FUNCTION  -  VALIDATES THE CONTENT OF A SUBSCRIPT FIELD FOUND IN  */\n/*               THE DUMP WHOSE HEX CONTENT IS GIVEN IN THE HEXDATA   */\n/*               VARIABLE. VALIDITY CHECK IS MADE BASED ON THE FLDTYPE*/\n/*               AND FLDLEN VARIABLES. THE DECIMAL VALUE IS PLACED IN */\n/*               THE DECVAL VARIABLE. ZERO IS INVALID FOR SUBSCRIPTS. */\n/*  CALLED BY -  REXX PROGRAM AATX060                                 */\n/*  RELATED   -  PANELS AATP064 AND MSG AATM06                        */\n/*  CALLS     -                                                       */\n/*  AUTHOR    -  DICK THORNTON JAN 2000                               */\n/**********************************************************************/\n/* TRACE ?ALL */\nNUMERIC DIGITS 32             /* SET NUMBER DIGITS FOR CALCULATIONS */\nADDRESS ISPEXEC \"VGET (FLDNAME FLDTYPE BLCELL \" ||,\n\"BLCELLTY FLDOFF FLDLEN HEXDATA DECVAL ERROR  \" ||,\n\"ERRMESG CURSLOC OCCLEN OCCNBR) SHARED\"\nERROR = 0\nHEXLEN = LENGTH(HEXDATA)\nDECVAL = ''\nBL = 'BL'||BLCELLTY\nIF HEXLEN \u00ac= (2 * FLDLEN) THEN DO\n   ERROR = 1\n   ERRMESG = 'AATM069A'  /* INCORRECT HEX LENGTH */\n   CURSLOC = 'HEXDATA'  /* SET CURSOR LOCATION */\nEND\nIF ((FLDTYPE = 'B') & (ERROR = 0)) THEN\n   DECVAL = X2D(HEXDATA,HEXLEN)   /* SET UP DECIMAL EQUIVALENT */\nELSE\n   IF ((FLDTYPE = 'P') & (ERROR = 0)) THEN\n      CALL PACKED_DECIMAL  /* VALIDATE, BUILD DECIMAL VALUE */\n   ELSE\n      IF ((FLDTYPE = 'Z') & (ERROR = 0)) THEN\n         CALL ZONED_DECIMAL /* VALIDATE, BUILD DECIMAL VALUE */\nIF ERROR = 0 THEN DO\n   CALL CHAR_HEX_TRANSLATE    /* BUILD CHAR/ZONE/NUM EQUIVALENT */\n   IF DECVAL \u00ac> 0 THEN DO\n      ERROR = 1\n      ERRMESG = 'AATM069F' /*SUBSCRIPT VALUE MUST BE > 0 */\n      CURSLOC = 'DECVAL'\n   END\n   IF DECVAL > OCCNBR THEN DO\n      ERROR = 1\n      ERRMESG = 'AATM069G' /*SUBSCRIPT VALUE > OCCNBR */\n      CURSLOC = 'DECVAL'\n   END\nEND\nIF ERROR = 0 THEN\n   SUBOFF = D2X((DECVAL - 1) * OCCLEN)  /* SUBSCRIPT OFFSET */\nADDRESS ISPEXEC 'DISPLAY PANEL(AATP064)'\nRETURN\n/********************************************************************/\n/* VALIDATE PACKED_DECIMAL FIELDS                                   */\n/********************************************************************/\nPACKED_DECIMAL:\nDO I = 1 TO HEXLEN\n   CH = SUBSTR(HEXDATA,I,1)\n   IF I = HEXLEN THEN DO\n      REALDEC = DECVAL           /* SAVE DECIMAL VALUE WITHOUT SIGN */\n      IF CH = 'D' THEN DECVAL = '-' || DECVAL\n      ELSE DO\n         IF CH = 'C' THEN DECVAL = '+' || DECVAL\n         ELSE DO\n            IF CH \u00ac= 'F' THEN DO\n               ERROR = 1\n               ERRMESG = 'AATM069B' /*INVALID PACKED SIGN */\n               CURSLOC = 'HEXDATA'  /*SET CURSOR LOCATION */\n               DECVAL = ''          /* CLEAR ANY DECIMAL VALUE */\n               RETURN\n            END\n         END\n      END\n   END\n   ELSE DO\n      IF ((CH >= '0') & (CH <= '9')) THEN\n         DECVAL = DECVAL || CH\n      ELSE DO\n         ERROR = 1\n         ERRMESG = 'AATM069C' /* INVALID PACKED DIGIT */\n         CURSLOC = 'HEXDATA'  /* SET CURSOR LOCATION */\n         DECVAL = ''          /* CLEAR ANY DECIMAL VALUE */\n         RETURN\n      END\n   END\nEND\nRETURN\n/********************************************************************/\n/* VALIDATE ZONED DECIMAL FIELDS                                    */\n/********************************************************************/\nZONED_DECIMAL:\nDO I = 1 TO HEXLEN BY 2 while I < (HEXLEN - 1)\n   ZONE = SUBSTR(HEXDATA,I,1)\n   NUM  = SUBSTR(HEXDATA,I+1,1)\n   IF ((NUM >= '0') & (NUM <= '9') & (ZONE = 'F')) THEN\n         DECVAL = DECVAL || NUM\n   ELSE DO\n      ERROR = 1\n      ERRMESG = 'AATM069D' /* INVALID ZONED NUMERIC */\n      CURSLOC = 'HEXDATA'  /* SET CURSOR LOCATION */\n      DECVAL = ''          /* CLEAR ANY DECIMAL VALUE */\n      RETURN\n   END\nEND\nZONE = SUBSTR(HEXDATA,HEXLEN - 1,1)\nNUM  = SUBSTR(HEXDATA,HEXLEN,1)\nIF ((NUM >= '0') & (NUM <= '9')) THEN\n   DECVAL = DECVAL || NUM\nELSE DO\n      ERROR = 1\n      ERRMESG = 'AATM069D' /* INVALID ZONED NUMERIC */\n      CURSLOC = 'HEXDATA'  /* SET CURSOR LOCATION */\n      DECVAL = ''          /* CLEAR ANY DECIMAL VALUE */\n      RETURN\nEND\nREALDEC = DECVAL           /* SAVE DECIMAL VALUE WITHOUT SIGN */\nIF ZONE = 'D' THEN DECVAL = '-' || DECVAL\n   ELSE DO\n      IF ZONE = 'C' THEN DECVAL = '+' || DECVAL\n      ELSE DO\n         IF ZONE \u00ac= 'F' THEN DO\n             ERROR = 1\n             ERRMESG = 'AATM069E' /* INVALID ZONED SIGN */\n             CURSLOC = 'HEXDATA'  /* SET CURSOR LOCATION */\n             DECVAL = ''          /* CLEAR ANY DECIMAL VALUE */\n             RETURN\n         END\n      END\n   END\nRETURN\n/********************************************************************/\n/* BUILD THE CHARACTER/ZONE/NUMERIC DISPLAY                         */\n/********************************************************************/\nCHAR_HEX_TRANSLATE:\nCHAR = ''; ZONE = ''; NUM = ''\nDO I = 1 TO HEXLEN BY 2\n   ZONE = ZONE || SUBSTR(HEXDATA,I,1)\n   NUM  = NUM || SUBSTR(HEXDATA,I+1,1)\nEND\nCHAR = X2C(HEXDATA)          /* CONVERT CHARACTER HEX TO REAL HEX */\nADDRESS ISPEXEC \"VPUT (CHAR ZONE NUM SUBOFF) SHARED\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AATX070": {"ttr": 1547, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00)\\x01\\x00\\x02O\\x01\\x00\\x02O\\x16#\\x00P\\x00O\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2000-01-24T00:00:00", "modifydate": "2000-01-24T16:23:29", "lines": 80, "newlines": 79, "modlines": 0, "user": "BC0THOR"}, "text": "/*REXX*****************************************************************/\n/*  NAME      -  AATX070                                              */\n/*  PROJECT   -  ABEND-AID TOOLS (AAT)                                */\n/*  TYPE      -  REXX PROGRAM                                         */\n/*  FUNCTION  -  DISPLAYS PANEL AATP070 TO COLLECT INFORMATION ON AN  */\n/*               INDEX CELL TO BE LOCATED AND VALIDATED IN THE DUMP.  */\n/*               THE USER ENTERS DATA SUCH AS FIELD NAME, INDEX CELL  */\n/*               NUMBER, OCCURS NUMBER, AND LENGTH OF OCCURRING ITEM. */\n/*               WHEN DATA ENTERED ON PANEL AATP070 IS CORRECT, PANEL */\n/*               PANEL AATP071 TO TELL THE USER HOW TO FIND THE INDEX */\n/*               CELL IN THE ABEND-AID DUMP, AND OBTAINS ITS VALUE    */\n/*               FROM THE USER. FINALLY, THE AATP074 PANEL IS SHOWN   */\n/*               TO ANALYZE THE INDEX CONTENT AND PROVIDE THE EQUIV-  */\n/*               ALENT OCCURRENCE NUMBER.                             */\n/*  CALLED BY -  PANEL AATP000                                        */\n/*  RELATED   -  PANELS AATP071, AATH070, AND MSG AATM07              */\n/*  CALLS     -  AATX074                                              */\n/*  AUTHOR    -  DICK THORNTON JAN 2000                               */\n/**********************************************************************/\n/**********************************************************************/\n/*  THE PROGRAM RUNS IN A NEVER ENDING LOOP UNTIL THE USER HITS PF3   */\n/*  1. INITIALIZE VARIABLES.                                          */\n/*  2. DISPLAY THE AATP070 PANEL TO OBTAIN THE FIELD VARIABLE INFO.   */\n/*  3. ON RETURN FROM PANEL AATP070, EXIT IF THE USER HAS HIT PF3.    */\n/*  4. VALIDATE THE USER SUPPLIED VARIABLES. IF ANY ERROR OCCURS,     */\n/*     REDISPLAY AATP070 WITH AN ERROR MESSAGE AND THE CURSOR SET ON  */\n/*     THE FIELD IN ERROR.                                            */\n/*  5. SET UP VARIABLES FOR THE AATP071 PANEL.                        */\n/*  6. DISPLAY THE AATP071 TO OBTAIN THE VALUE IN THE INDEX.          */\n/*  7. ON RETURN DISPLAY PANEL AATP074 TO SHOW DATA ANALYSIS.         */\n/*  8. REPEAT STEPS 1-9.                                              */\n/**********************************************************************/\n/* TRACE ?ALL */\nNUMERIC DIGITS 32             /* SET NUMBER DIGITS FOR CALCULATIONS */\nDO FOREVER\n   FLDNAME = ''; IDX = ''; OCCLEN = ''; OCCNBR = ''; ABIDX = ''\n   ERROR = 1; ERRMESG = ''; CURSLOC = 'FLDNAME';\n   DO FOREVER\n      ADDRESS ISPEXEC 'DISPLAY PANEL(AATP070)'\n      IF RC \u00ac= 0 THEN EXIT    /* ASSUME PF3 HIT OF RC IS NOT 0 */\n      ERROR = 0; ERRMESG = ''; CURSLOC = 'FLDNAME'\n      CALL VALIDATE           /* VALIDATE PANEL VARIABLES */\n      IF ERROR \u00ac= 0 THEN ITERATE /* IF ERROR, RE-DISPLAY AATP070 */\n      HEXDATA = ''\n      DO FOREVER\n         ADDRESS ISPEXEC 'DISPLAY PANEL(AATP071)'  /* GET INDEX VALUE */\n         IF RC \u00ac= 0 THEN EXIT    /* ASSUME PF3 HIT IF RC IS NOT 0 */\n         IF (LENGTH(HEXDATA) = 8) THEN LEAVE\n         ELSE DO\n            ERRMESG = 'AATM073'  /* HEX REQUIRES 2 DIGITS PER BYTE */\n            CURSLOC = 'HEXDATA'\n            ITERATE\n         END\n      END\n      ERROR = 0; ERRMESG = ''; CURSLOC = 'FLDNAME'\n      ADDRESS ISPEXEC \"VPUT (FLDNAME IDX OCCLEN OCCNBR \" ||,\n         \"HEXDATA ABIDX ERRMESG CURSLOC) SHARED\"\n      CALL AATX074            /* VALIDATE FIELD DATA */\n   END\nEND\n/********************************************************************/\n/*  VALIDATE THE VARIABLE DATA ENTERED BY THE USER AND BUILD THE    */\n/*  ADDITIONAL VARIABLES FOR THE AATP071 PANEL.                     */\n/********************************************************************/\nVALIDATE:\n   IF (OCCNBR <= 1) THEN DO\n      ERROR = 1\n      ERRMESG = 'AATM070'        /* OCCNBR MUST BE > 0 */\n      CURSLOC = 'OCCNBR'\n      RETURN\n   END\n   ABIDX = X2D(IDX) - 1          /* COMPUTE ABEND-AID INDEX NUMBER */\n   IF ABIDX < 0 THEN DO\n      ERROR = 1\n      ERRMESG = 'AATM075'       /* COBOL IDX= NUMBERS ARE > 0 */\n      CURSLOC = 'IDX'\n   END\n   ELSE\n      ABIDX = D2X(ABIDX)\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AATX074": {"ttr": 1550, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00Q\\x01\\x00\\x02O\\x01\\x00\\x02O\\x14R\\x001\\x001\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-01-24T00:00:00", "modifydate": "2000-01-24T14:52:51", "lines": 49, "newlines": 49, "modlines": 0, "user": "BC0THOR"}, "text": "/*REXX*****************************************************************/\n/*  NAME      -  AATX074                                              */\n/*  PROJECT   -  ABEND-AID TOOLS (AAT)                                */\n/*  TYPE      -  REXX PROGRAM                                         */\n/*  FUNCTION  -  VALIDATES THE CONTENT OF AN INDEX FIELD FOUND IN THE */\n/*               DUMP WHOSE HEX CONTENT IS GIVEN IN THE HEXDATA       */\n/*               VARIABLE. VALIDITY CHECK IS MADE BASED ON THE OCCLEN */\n/*               AND OCCNBR VARIABLES. THE DECIMAL VALUE IS PLACED IN */\n/*               THE DECVAL VARIABLE. ZERO IS INVALID FOR SUBSCRIPTS. */\n/*  CALLED BY -  REXX PROGRAM AATX070                                 */\n/*  RELATED   -  PANELS AATP074 AND MSG AATM07                        */\n/*  CALLS     -                                                       */\n/*  AUTHOR    -  DICK THORNTON JAN 2000                               */\n/**********************************************************************/\n/* TRACE ?ALL */\nNUMERIC DIGITS 32             /* SET NUMBER DIGITS FOR CALCULATIONS */\nADDRESS ISPEXEC \"VGET (FLDNAME IDX OCCLEN \" ||,\n\"OCCNBR ABIDX HEXDATA ERRMESG CURSLOC) SHARED\"\nERROR = 0\nHEXLEN = LENGTH(HEXDATA)\nDECVAL = ''\nIF HEXLEN \u00ac= 8 THEN DO\n   ERROR = 1\n   ERRMESG = 'AATM079C'  /* INCORRECT HEX LENGTH */\n   CURSLOC = 'HEXDATA'  /* SET CURSOR LOCATION */\nEND\nDECVAL = X2D(HEXDATA,8)   /* SET UP DECIMAL EQUIVALENT */\nREMVAL = (DECVAL // OCCLEN) /* SEE IF ANY REMAINDER */\nDECVAL = (DECVAL % OCCLEN) + 1  /* COMPUTE OCCURRENCE NUMBER */\nIF REMVAL \u00ac= 0 THEN DO\n      ERROR = 1\n      ERRMESG = 'AATM079B'  /*INDEX VALUE MUST BE LENGTH MULTIPLE */\n      CURSLOC = 'OCCLEN'\nEND\nELSE\n   IF DECVAL < 0 THEN DO\n      ERROR = 1\n      ERRMESG = 'AATM079D' /*INDEX VALUE MUST BE POSITIVE */\n      CURSLOC = 'HEXDATA'\n   END\n   ELSE\n      IF DECVAL > OCCNBR THEN DO\n         ERROR = 1\n         ERRMESG = 'AATM079A' /*COMPUTED OCCURRENCE > OCCNBR */\n         CURSLOC = 'DECVAL'\n      END\nSUBOFF = HEXDATA           /* OFFSET DUE TO THE INDEX */\nADDRESS ISPEXEC 'DISPLAY PANEL(AATP074)'\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AATX080": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00F\\x01\\x00\\x02O\\x01\\x00\\x02\\x7f\\tC\\x00\\x9b\\x00\\x9b\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-01-24T00:00:00", "modifydate": "2000-01-27T09:43:46", "lines": 155, "newlines": 155, "modlines": 0, "user": "BC0THOR"}, "text": "/*REXX*****************************************************************/\n/*  NAME      -  AATX080                                              */\n/*  PROJECT   -  ABEND-AID TOOLS (AAT)                                */\n/*  TYPE      -  REXX PROGRAM                                         */\n/*  FUNCTION  -  DISPLAYS PANEL AATP080 TO COLLECT THE NUMBERS TO BE  */\n/*               CONVERTED OR USED IN THE CALCULATION SPECIFIED. THE  */\n/*               USER ENTERS ONLY A HEX OR A DECIMAL NUMBER WHEN      */\n/*               CONVERSION IS DESIRED. FOR CALCULATIONS, AN ARITH-   */\n/*               METIC OPERATOR AND SECOND NUMBER ARE ENTERED. DATA   */\n/*               ENTERED IS VALIDATED, THEN THE AATP081 SCREEN IS     */\n/*               DISPLAYED TO SHOW THE CONVERSION AND RESULTS OF ANY  */\n/*               CALCULATION SPECIFIED.                               */\n/*  CALLED BY -  PANEL AATP000                                        */\n/*  RELATED   -  PANELS AATP080, AATP081 AND MSG AATM08               */\n/*  CALLS     -                                                       */\n/*  AUTHOR    -  DICK THORNTON DEC 1999                               */\n/**********************************************************************/\n/**********************************************************************/\n/*  THE PROGRAM RUNS IN A NEVER ENDING LOOP UNTIL THE USER HITS PF3   */\n/*  1. INITIALIZE VARIABLES.                                          */\n/*  2. DISPLAY THE AATP080 PANEL TO OBTAIN THE CONVERSION/CALCULATION */\n/*     VARIABLES FROM THE USERS.                                      */\n/*  3. ON RETURN FROM PANEL AATP080, EXIT IF THE USER HAS HIT PF3.    */\n/*  4. VALIDATE THE USER SUPPLIED VARIABLES. IF ANY ERROR OCCURS,     */\n/*     REDISPLAY AATP080 WITH AN ERROR MESAGE AND THE CURSOR SET ON   */\n/*     THE FIELD IN ERROR.                                            */\n/*  5. PERFORM ANY INDICATED CALCULATIONS.                            */\n/*  6. DISPLAY THE AATP081 PANEL TO SHOW THE RESULTS TO THE USER.     */\n/*  7. ON RETURN FROM PANEL AATP080, EXIT IF THE USER HAS HIT PF3.    */\n/*  8. REPEAT STEPS 1-9.                                              */\n/**********************************************************************/\n/* TRACE ?ALL  */\nNUMERIC DIGITS 32             /* SET NUMBER DIGITS FOR CALCULATIONS */\nDO FOREVER\n   D1 = ''; H1 = ''; OP = ''; D2 = '';H2 = '';DR = ''; HR = ''\n   ERROR = 1; ERRMESG = ''; CURSLOC = 'H1'\n   DO WHILE ERROR\n      ADDRESS ISPEXEC 'DISPLAY PANEL(AATP080)'\n      IF RC \u00ac= 0 THEN EXIT    /* ASSUME PF3 HIT OF RC IS NOT 0 */\n      ERROR = 0; ERRMESG = ''; CURSLOC = 'H1'\n      CALL VALIDATE           /* VALIDATE D1 AND D2 PANEL VARIABLES */\n      IF ERROR \u00ac= 0 THEN ITERATE /* IF ERROR, RE-DISPLAY AATP080 */\n      IF OP \u00ac= '' THEN CALL CALCULATE /* IF OPERATION GIVEN, DO CALC */\n      ADDRESS ISPEXEC 'DISPLAY PANEL(AATP081)'  /* DISPLAY RESULTS */\n      IF RC \u00ac= 0 THEN EXIT    /* ASSUME PF3 HIT IF RC IS NOT 0 */\n      ERROR = 0; ERRMESG = ''; CURSLOC = 'H1'\n   END\nEND\n/********************************************************************/\n/*  VALIDATE THE VARIABLE DATA ENTERED BY THE USER AND PERFORM THE  */\n/*  CONVERSIONS NECESSARY SO THAT BOTH DECIMAL AND HEX VALUES ARE   */\n/*  AVAILABLE FOR CALCULATION AND DISPLAY.                          */\n/********************************************************************/\nVALIDATE:\n   IF D1 = '' THEN DO\n      H1LEN = LENGTH(H1)\n      IF ((H1LEN = 4) | (H1LEN = 8)) THEN D1 = X2D(H1,H1LEN)\n      ELSE D1 = X2D(H1)\n      REALD1 = D1; REALH1 = H1\n   END\n   ELSE DO\n      TESTDEC = D1\n      CALL VALIDATE_DECIMAL\n      IF ERROR \u00ac= 0 THEN CURSLOC = 'H1'\n      ELSE DO\n         D1 = REALDEC; REALD1 = D1\n         H1 = REALHEX; REALH1 = H1\n      END\n   END\n   IF OP = '' THEN NOP     /* IF OPERATION BLANK, NO D2 */\n   ELSE DO\n      IF D2 = '' THEN DO\n         H2LEN = LENGTH(H2)\n         IF ((H2LEN = 4) | (H2LEN = 8)) THEN D2 = X2D(H2,H2LEN)\n         ELSE D2 = X2D(H2)\n         REALD2 = D2; REALH2 = H2\n      END\n      ELSE DO\n         TESTDEC = D2\n         CALL VALIDATE_DECIMAL\n         IF ERROR \u00ac= 0 THEN CURSLOC = 'H2'\n         ELSE DO\n            D2 = REALDEC; REALD2 = D2\n            H2 = REALHEX; REALH2 = H2\n         END\n      END\n   END\nRETURN\n/********************************************************************/\n/*  PERFORM THE USER SPECIFIED CALCULATION USING THE REAL DECIMAL   */\n/*  FIELDS. THE HEX RESULT IS OBTAINED FROM THE DECIMAL VALUE.      */\n/********************************************************************/\nCALCULATE:\n   IF OP = '+' THEN DR = REALD1 + REALD2\n   ELSE\n      IF OP = '-' THEN DR = REALD1 - REALD2\n      ELSE\n         IF OP = '*' THEN DR = REALD1 * REALD2\n         ELSE\n            IF OP = '/' THEN\n               DO\n                  DR = REALD1 % REALD2\n                  DREM = REALD1 // REALD2\n                  IF DREM \u00ac= 0 THEN ERRMESG = 'AATM081A'\n               END\n   IF ((DR > 2147483647) | (DR < -2147483648)) THEN\n      DO\n         ERRMESG = 'AATM089'\n         CURSLOC = ''\n      END\n   ELSE\n      DO\n         I = 4\n         IF ((DR > 32767) | (DR < -32768)) THEN I = 8\n         HR = D2X(DR,I)\n      END\nRETURN\n/********************************************************************/\n/*  EDITS A DECIMAL NUMBER IN THE TESTDEC FIELD FOR VALIDITY. IF IT */\n/*  CONTAINS A DECIMAL POINT, AN ERROR IS RECOGNIZED. OTHER TESTS   */\n/*  HAVE ALREADY BEEN MADE BY PANEL VER STATEMENTS. THE NUMBER IS   */\n/*  SCANNED AND THE SIGN, IF ANY, AND ALL DIGITS ARE MOVED TO THE   */\n/*  REALDEC FIELD.                                                  */\n/********************************************************************/\nVALIDATE_DECIMAL:\n   REALDEC = ''; REALHEX = ''\n   NEXTBYTE = SUBSTR(TESTDEC,1,1)\n   IF ((NEXTBYTE = '+') | (NEXTBYTE = '-')) THEN DO\n      REALDEC = SUBSTR(TESTDEC,1,1)\n      I = 2\n   END\n   ELSE I = 1\n   DO I = I TO LENGTH(TESTDEC) BY 1\n      NEXTBYTE = SUBSTR(TESTDEC,I,1)\n      IF NEXTBYTE = ',' THEN ITERATE\n      ELSE DO\n         IF NEXTBYTE = '.' THEN DO\n            ERROR = 1\n            ERRMESG = 'AATM088'\n            LEAVE\n         END\n         ELSE REALDEC = REALDEC || NEXTBYTE\n      END\n   END\n   IF ERROR = 0 THEN\n      IF ((REALDEC < -2147483648) | (REALDEC > 2147483647)) THEN DO\n         ERROR = 1\n         ERRMESG = 'AATM081B'\n      END\n      ELSE DO\n         I = 4\n         IF ((REALDEC > 32767) | (REALDEC < -32768)) THEN I = 8\n         REALHEX = D2X(REALDEC,I)\n      END\nRETURN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "AATX090": {"ttr": 1797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00@\\x01\\x00\\x02O\\x01\\x00\\x02O\\x13E\\x01#\\x01#\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-24T00:00:00", "modifydate": "2000-01-24T13:45:40", "lines": 291, "newlines": 291, "modlines": 0, "user": "BC0THOR"}, "text": "/*********************************************************************/\n/* NAME      - AATX090                                               */\n/* LANGUAGE  - TSO/REXX                                              */\n/* FUNCTION  - DISPLAYS THE TABLE OF DECIMAL-HEX-ASCII-EBCDIC VALUES */\n/*             USING PANEL AATP090                                   */\n/* CALLED BY - PANEL AATP000                                         */\n/* RELATED   - PANEL AATP090                                         */\n/* CALLS     -                                                       */\n/* AUTHOR R THORNTON JAN 2000                                        */\n/*********************************************************************/\nCODELINE.0 = '000  00  0000 0000    NUL     NUL        '\nCODELINE.1 = '001  01  0000 0001    SOH     SOH        '\nCODELINE.2 = '002  02  0000 0010    STX     STX        '\nCODELINE.3 = '003  03  0000 0011    ETX     ETX        '\nCODELINE.4 = '004  04  0000 0100    SEL     EOT   SPM  '\nCODELINE.5 = '005  05  0000 0101     HT     ENQ   BALR '\nCODELINE.6 = '006  06  0000 0110    RNL     ACK   BCTR '\nCODELINE.7 = '007  07  0000 0111    DEL     BEL   BCR  '\nCODELINE.8 = '008  08  0000 1000     GE      BS        '\nCODELINE.9 = '009  09  0000 1001    SPS      HT        '\nCODELINE.10 = '010  0A  0000 1010    RPT      LF   SVC  '\nCODELINE.11 = '011  0B  0000 1011     VT      VT   BSM  '\nCODELINE.12 = '012  0C  0000 1100     FF      FF   BASSM'\nCODELINE.13 = '013  0D  0000 1101     CR      CR   BASR '\nCODELINE.14 = '014  0E  0000 1110     SO      SO   MVCL '\nCODELINE.15 = '015  0F  0000 1111     SI      SI   CLCL '\nCODELINE.16 = '016  10  0001 0000    DLE     DLE   LPR  '\nCODELINE.17 = '017  11  0001 0001    DC1     DC1   LNR  '\nCODELINE.18 = '018  12  0001 0010    DC2     DC2   LTR  '\nCODELINE.19 = '019  13  0001 0011    DC3     DC3   LCR  '\nCODELINE.20 = '020  14  0001 0100    RES     DC4   NR   '\nCODELINE.21 = '021  15  0001 0101     NL     NAK   CLR  '\nCODELINE.22 = '022  16  0001 0110     BS     SYN   OR   '\nCODELINE.23 = '023  17  0001 0111    POC     ETB   XR   '\nCODELINE.24 = '024  18  0001 1000    CAN     CAN   LR   '\nCODELINE.25 = '025  19  0001 1001     EM      EM   CR   '\nCODELINE.26 = '026  1A  0001 1010    UBS     SUB   AR   '\nCODELINE.27 = '027  1B  0001 1011    CU1     ESC   SR   '\nCODELINE.28 = '028  1C  0001 1100    IFS      FS   MR   '\nCODELINE.29 = '029  1D  0001 1101    IGS      GS   DR   '\nCODELINE.30 = '030  1E  0001 1110    IRS      RS   ALR  '\nCODELINE.31 = '031  1F  0001 1111    ITB      US   SLR  '\nCODELINE.32 = '032  20  0010 0000     DS    space  LPDR '\nCODELINE.33 = '033  21  0010 0001    SOS      !    LNDR '\nCODELINE.34 = '034  22  0010 0010     FS      \"    LTDR '\nCODELINE.35 = '035  23  0010 0011    WUS      #    LCDR '\nCODELINE.36 = '036  24  0010 0100    BYP      $    HDR  '\nCODELINE.37 = '037  25  0010 0101     LF      %    LRDR '\nCODELINE.38 = '038  26  0010 0110    ETB      &    MXR  '\nCODELINE.39 = '039  27  0010 0111    ESC     tic   MXDR '\nCODELINE.40 = '040  28  0010 1000     SA      (    LDR  '\nCODELINE.41 = '041  29  0010 1001    SFE      )    CDR  '\nCODELINE.42 = '042  2A  0010 1010     SM      *    ADR  '\nCODELINE.43 = '043  2B  0010 1011    CSP      +    SDR  '\nCODELINE.44 = '044  2C  0010 1100    MFA    comma  MDR  '\nCODELINE.45 = '045  2D  0010 1101    ENQ      -    DDR  '\nCODELINE.46 = '046  2E  0010 1110    ACK      .    AWR  '\nCODELINE.47 = '047  2F  0010 1111    BEL      /    SWR  '\nCODELINE.48 = '048  30  0011 0000             0    LPER '\nCODELINE.49 = '049  31  0011 0001             1    LNER '\nCODELINE.50 = '050  32  0011 0010    SYN      2    LTER '\nCODELINE.51 = '051  33  0011 0011     IR      3    LCER '\nCODELINE.52 = '052  34  0011 0100     PP      4    HER  '\nCODELINE.53 = '053  35  0011 0101    TRN      5    LRER '\nCODELINE.54 = '054  36  0011 0110    NBS      6    AXR  '\nCODELINE.55 = '055  37  0011 0111    EOT      7    SXR  '\nCODELINE.56 = '056  38  0011 1000    SBS      8    LER  '\nCODELINE.57 = '057  39  0011 1001     IT      9    CER  '\nCODELINE.58 = '058  3A  0011 1010    RFF      :    AER  '\nCODELINE.59 = '059  3B  0011 1011    CU3      ;    SER  '\nCODELINE.60 = '060  3C  0011 1100    DC4      <    MER  '\nCODELINE.61 = '061  3D  0011 1101    NAK      =    DER  '\nCODELINE.62 = '062  3E  0011 1110             >    AUR  '\nCODELINE.63 = '063  3F  0011 1111    SUB      ?    SUR  '\nCODELINE.64 = '064  40  0100 0000   space     @    STH  '\nCODELINE.65 = '065  41  0100 0001    RSP      A    LA   '\nCODELINE.66 = '066  42  0100 0010             B    STC  '\nCODELINE.67 = '067  43  0100 0011             C    IC   '\nCODELINE.68 = '068  44  0100 0100             D    EX   '\nCODELINE.69 = '069  45  0100 0101             E    BAL  '\nCODELINE.70 = '070  46  0100 0110             F    BCT  '\nCODELINE.71 = '071  47  0100 0111             G    BC   '\nCODELINE.72 = '072  48  0100 1000             H    LH   '\nCODELINE.73 = '073  49  0100 1001             I    CH   '\nCODELINE.74 = '074  4A  0100 1010   cent      J    AH   '\nCODELINE.75 = '075  4B  0100 1011     .       K    SH   '\nCODELINE.76 = '076  4C  0100 1100     <       L    MH   '\nCODELINE.77 = '077  4D  0100 1101     (       M    BAS  '\nCODELINE.78 = '078  4E  0100 1110     +       N    CVD  '\nCODELINE.79 = '079  4F  0100 1111     |       O    CVB  '\nCODELINE.80 = '080  50  0101 0000     &       P    ST   '\nCODELINE.81 = '081  51  0101 0001             Q         '\nCODELINE.82 = '082  52  0101 0010             R         '\nCODELINE.83 = '083  53  0101 0011             S         '\nCODELINE.84 = '084  54  0101 0100             T    N    '\nCODELINE.85 = '085  55  0101 0101             U    CL   '\nCODELINE.86 = '086  56  0101 0110             V    O    '\nCODELINE.87 = '087  57  0101 0111             W    X    '\nCODELINE.88 = '088  58  0101 1000             X    L    '\nCODELINE.89 = '089  59  0101 1001             Y    C    '\nCODELINE.90 = '090  5A  0101 1010     !       Z    A    '\nCODELINE.91 = '091  5B  0101 1011     $     l-brkt S    '\nCODELINE.92 = '092  5C  0101 1100     *       \\    M    '\nCODELINE.93 = '093  5D  0101 1101     )     r-brkt D    '\nCODELINE.94 = '094  5E  0101 1110     ;      hat   AL   '\nCODELINE.95 = '095  5F  0101 1111    not   undscor SL   '\nCODELINE.96 = '096  60  0110 0000     -    accent  STD  '\nCODELINE.97 = '097  61  0110 0001     /       a         '\nCODELINE.98 = '098  62  0110 0010             b         '\nCODELINE.99 = '099  63  0110 0011             c         '\nCODELINE.100 = '100  64  0110 0100             d         '\nCODELINE.101 = '101  65  0110 0101             e         '\nCODELINE.102 = '102  66  0110 0110             f         '\nCODELINE.103 = '103  67  0110 0111             g    MXD  '\nCODELINE.104 = '104  68  0110 1000             h    LD   '\nCODELINE.105 = '105  69  0110 1001             i    CD   '\nCODELINE.106 = '106  6A  0110 1010     \u00a6       j    AD   '\nCODELINE.107 = '107  6B  0110 1011   comma     k    SD   '\nCODELINE.108 = '108  6C  0110 1100     %       l    MD   '\nCODELINE.109 = '109  6D  0110 1101  undrscor   m    DD   '\nCODELINE.110 = '110  6E  0110 1110     >       n    AW   '\nCODELINE.111 = '111  6F  0110 1111     ?       o    SW   '\nCODELINE.112 = '112  70  0111 0000             p    STE  '\nCODELINE.113 = '113  71  0111 0001             q         '\nCODELINE.114 = '114  72  0111 0010             r         '\nCODELINE.115 = '115  73  0111 0011             s         '\nCODELINE.116 = '116  74  0111 0100             t         '\nCODELINE.117 = '117  75  0111 0101             u         '\nCODELINE.118 = '118  76  0111 0110             v         '\nCODELINE.119 = '119  77  0111 0111             w         '\nCODELINE.120 = '120  78  0111 1000             x    LE   '\nCODELINE.121 = '121  79  0111 1001  accent     y    CE   '\nCODELINE.122 = '122  7A  0111 1010     :       z    AE   '\nCODELINE.123 = '123  7B  0111 1011     #       {    SE   '\nCODELINE.124 = '124  7C  0111 1100     @       \u00a6    ME   '\nCODELINE.125 = '125  7D  0111 1101    tic      }    DE   '\nCODELINE.126 = '126  7E  0111 1110     =       ~    AU   '\nCODELINE.127 = '127  7F  0111 1111     \"      DEL   SU   '\nCODELINE.128 = '128  80  1000 0000                  SSM  '\nCODELINE.129 = '129  81  1000 0001     a                 '\nCODELINE.130 = '130  82  1000 0010     b            LPSW '\nCODELINE.131 = '131  83  1000 0011     c         diagnose'\nCODELINE.132 = '132  84  1000 0100     d                 '\nCODELINE.133 = '133  85  1000 0101     e                 '\nCODELINE.134 = '134  86  1000 0110     f            BXH  '\nCODELINE.135 = '135  87  1000 0111     g            BXLE '\nCODELINE.136 = '136  88  1000 1000     h            SRL  '\nCODELINE.137 = '137  89  1000 1001     i            SLL  '\nCODELINE.138 = '138  8A  1000 1010                  SRA  '\nCODELINE.139 = '139  8B  1000 1011     {            SLA  '\nCODELINE.140 = '140  8C  1000 1100                  SRDL '\nCODELINE.141 = '141  8D  1000 1101                  SLDL '\nCODELINE.142 = '142  8E  1000 1110                  SRDA '\nCODELINE.143 = '143  8F  1000 1111     +            SLDA '\nCODELINE.144 = '144  90  1001 0000                  STM  '\nCODELINE.145 = '145  91  100B 0001     j            TM   '\nCODELINE.146 = '146  92  1001 0010     k            MVI  '\nCODELINE.147 = '147  93  1001 0011     l            TS   '\nCODELINE.148 = '148  94  1001 0100     m            NI   '\nCODELINE.149 = '149  95  1001 0101     n            CLI  '\nCODELINE.150 = '150  96  1001 0110     o            OI   '\nCODELINE.151 = '151  97  1001 0111     p            XI   '\nCODELINE.152 = '152  98  1001 1000     q            LM   '\nCODELINE.153 = '153  99  1001 1001     r            TRACE'\nCODELINE.154 = '154  9A  1001 1010                       '\nCODELINE.155 = '155  9B  1001 1011     }                 '\nCODELINE.156 = '156  9C  1001 1100  lozenge              '\nCODELINE.157 = '157  9D  1001 1101                       '\nCODELINE.158 = '158  9E  1001 1110                       '\nCODELINE.159 = '159  9F  1001 1111   block               '\nCODELINE.160 = '160  A0  1010 0000                       '\nCODELINE.161 = '161  A1  1010 0001                       '\nCODELINE.162 = '162  A2  1010 0010     s                 '\nCODELINE.163 = '163  A3  1010 0011     t                 '\nCODELINE.164 = '164  A4  1010 0100     u                 '\nCODELINE.165 = '165  A5  1010 0101     v                 '\nCODELINE.166 = '166  A6  1010 0110     w                 '\nCODELINE.167 = '167  A7  1010 0111     x                 '\nCODELINE.168 = '168  A8  1010 1000     y                 '\nCODELINE.169 = '169  A9  1010 1001     z                 '\nCODELINE.170 = '170  AA  1010 1010                       '\nCODELINE.171 = '171  AB  1010 1011                       '\nCODELINE.172 = '172  AC  1010 1100                  STNSM'\nCODELINE.173 = '173  AD  1010 1101  l-brkt          STOSM'\nCODELINE.174 = '174  AE  1010 1110                  SIGP '\nCODELINE.175 = '175  AF  1010 1111                  MC   '\nCODELINE.176 = '176  B0  1011 0000                       '\nCODELINE.177 = '177  B1  1011 0001                  LRA  '\nCODELINE.178 = '178  B2  1011 0010                  *    '\nCODELINE.179 = '179  B3  1011 0011                       '\nCODELINE.180 = '180  B4  1011 0100                       '\nCODELINE.181 = '181  B5  1011 0101                       '\nCODELINE.182 = '182  B6  1011 0110                  STCTL'\nCODELINE.183 = '183  B7  1011 0111                  LCTL '\nCODELINE.184 = '184  B8  1011 1000                       '\nCODELINE.185 = '185  B9  1011 1001                       '\nCODELINE.186 = '186  BA  1011 1010                  CS   '\nCODELINE.187 = '187  BB  1011 1011                  CDS  '\nCODELINE.188 = '188  BC  1011 1100                       '\nCODELINE.189 = '189  BD  1011 1101  r-brkt          CLM  '\nCODELINE.190 = '190  BE  1011 1110  not eql         STCM '\nCODELINE.191 = '191  BF  1011 1111     -            ICM  '\nCODELINE.192 = '192  C0  1100 0000     {                 '\nCODELINE.193 = '193  C1  1100 0001     A                 '\nCODELINE.194 = '194  C2  1100 0010     B                 '\nCODELINE.195 = '195  C3  1100 0011     C                 '\nCODELINE.196 = '196  C4  1100 0100     D                 '\nCODELINE.197 = '197  C5  1100 0101     E                 '\nCODELINE.198 = '198  C6  1100 0110     F                 '\nCODELINE.199 = '199  C7  1100 0111     G                 '\nCODELINE.200 = '200  C8  1100 1000     H                 '\nCODELINE.201 = '201  C9  1100 1001     I                 '\nCODELINE.202 = '202  CA  1100 1010    shy                '\nCODELINE.203 = '203  CB  1100 1011                       '\nCODELINE.204 = '204  CC  1100 1100                       '\nCODELINE.205 = '205  CD  1100 1101                       '\nCODELINE.206 = '206  CE  1100 1110                       '\nCODELINE.207 = '207  CF  1100 1111                       '\nCODELINE.208 = '208  D0  1101 0000     }                 '\nCODELINE.209 = '209  D1  1101 0001     J            MVN  '\nCODELINE.210 = '210  D2  1101 0010     K            MVC  '\nCODELINE.211 = '211  D3  1101 0011     L            MVZ  '\nCODELINE.212 = '212  D4  1101 0100     M            NC   '\nCODELINE.213 = '213  D5  1101 0101     N            CLC  '\nCODELINE.214 = '214  D6  1101 0110     O            OC   '\nCODELINE.215 = '215  D7  1101 0111     P            XC   '\nCODELINE.216 = '216  D8  1101 1000     Q                 '\nCODELINE.217 = '217  D9  1101 1001     R            MVCK '\nCODELINE.218 = '218  DA  1101 1010                  MVCP '\nCODELINE.219 = '219  DB  1101 1011                  MVCS '\nCODELINE.220 = '220  DC  1101 1100                  TR   '\nCODELINE.221 = '221  DD  1101 1101                  TRT  '\nCODELINE.222 = '222  DE  1101 1110                  ED   '\nCODELINE.223 = '223  DF  1101 1111                  EDMK '\nCODELINE.224 = '224  E0  1110 0000     \\                 '\nCODELINE.225 = '225  E1  1110 0001    nsp                '\nCODELINE.226 = '226  E2  1110 0010     S                 '\nCODELINE.227 = '227  E3  1110 0011     T                 '\nCODELINE.228 = '228  E4  1110 0100     U            *    '\nCODELINE.229 = '229  E5  1110 0101     V            *    '\nCODELINE.230 = '230  E6  1110 0110     W                 '\nCODELINE.231 = '231  E7  1110 0111     X                 '\nCODELINE.232 = '232  E8  1110 1000     Y            MVCIN'\nCODELINE.233 = '233  E9  1110 1001     Z                 '\nCODELINE.234 = '234  EA  1110 1010                       '\nCODELINE.235 = '235  EB  1110 1011                       '\nCODELINE.236 = '236  EC  1110 1100                       '\nCODELINE.237 = '237  ED  1110 1101                       '\nCODELINE.238 = '238  EE  1110 1110                       '\nCODELINE.239 = '239  EF  1110 1111                       '\nCODELINE.240 = '240  F0  1111 0000     0            SRP  '\nCODELINE.241 = '241  F1  1111 0001     1            MVO  '\nCODELINE.242 = '242  F2  1111 0010     2            PACK '\nCODELINE.243 = '243  F3  1111 0011     3            UNPK '\nCODELINE.244 = '244  F4  1111 0100     4                 '\nCODELINE.245 = '245  F5  1111 0101     5                 '\nCODELINE.246 = '246  F6  1111 0110     6                 '\nCODELINE.247 = '247  F7  1111 0111     7                 '\nCODELINE.248 = '248  F8  1111 1000     8            ZAP  '\nCODELINE.249 = '249  F9  1111 1001     9            CP   '\nCODELINE.250 = '250  FA  1111 1010                  AP   '\nCODELINE.251 = '251  FB  1111 1011                  SP   '\nCODELINE.252 = '252  FC  1111 1100                  MP   '\nCODELINE.253 = '253  FD  1111 1101                  DP   '\nCODELINE.254 = '254  FE  1111 1110                       '\nCODELINE.255 = '255  FF  1111 1111                       '\n\nADDRESS 'ISPEXEC'\n\"TBCREATE ALLBYTES KEYS(DEC)\",\n\"NAMES(HX, BINARY, EBCDIC, ASCII, INSTR)\",\n\"NOWRITE REPLACE\"\nDO X = 0 TO 255\n  DEC     = SUBSTR(CODELINE.X,1,3)\n  HX      = SUBSTR(CODELINE.X,6,2)\n  BINARY  = SUBSTR(CODELINE.X,10,9)\n  EBCDIC  = SUBSTR(CODELINE.X,20,8)\n  ASCII   = SUBSTR(CODELINE.X,29,7)\n  INSTR   = SUBSTR(CODELINE.X,37,5)\n  \"TBMOD ALLBYTES\"\nEND\n\"TBTOP ALLBYTES\"\n\n/* TRACE ?ALL  */\nDO FOREVER\n\"TBDISPL ALLBYTES PANEL(AATP090)\"\n IF RC = 8 THEN EXIT\n IF WORD(ZCMD,1) = 'L' THEN\n    ADDRESS 'ISPEXEC'\n    DEC = WORD(ZCMD,2)||'*'\n    \"TBSCAN ALLBYTES ARGLIST(DEC) NEXT ROWID(TBLROW)\"\nEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ARGPASS": {"ttr": 1803, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x00\\x99\\x02/\\x00\\x99\\x02/\\x16F\\x00\\x18\\x00\\x18\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-01-22T00:00:00", "modifydate": "1999-01-22T16:46:20", "lines": 24, "newlines": 24, "modlines": 0, "user": "BC0THOR"}, "text": "/*REXX****************************************************************/\n/* Description: Example of passing arguments to a REXX exec.         */\n/* 1. If PARSE precedes the ARG keyword, data is transferred as-is,  */\n/*    otherwise alphabetic characters are all made upper-case.       */\n/* 2. If the user enters fewer fields than are given on the ARG (or  */\n/*    PULL) keyword, the extra fields are set to null.               */\n/* 3. If the user enters more fields than are given on the ARG (or   */\n/*    PULL) keyword, the extra fields are last variable gets all the */\n/*    remaining values.                                              */\n/* 4. A period in the ARG or PULL field names identifies a parameter */\n/*    that will be ignored. For example, ARG fld1 . fld3 . will set  */\n/*    set fld1 and fld3 to the 1st and third fields entered by the   */\n/*    but the 2nd and 4th fields entered will be ignored.            */\n/* 5. To execute from the EDIT command line:                         */\n/*       tso exec pds.exec(argpass) '5 3' exec                       */\n/*    or tso exec 'bc0thor.pds.exec(argpass)' '5 3'                  */\n/*    or tso %argpass 5 3                                            */\n/*    but not argpass '5 3'                                          */\n/*    and not argpass 5 3                                            */\n/* 6. From a non-EDIT command line\n/*********************************************************************/\nARG num1 num2\nsay 'The first parameter is' num1\nsay 'The second parameter is' num2\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DATE": {"ttr": 1805, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x003\\x01\\x00\\x03/\\x01\\x00\\x03/\\x111\\x00\\x13\\x00\\x14\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2000-02-01T00:00:00", "modifydate": "2000-02-01T11:31:33", "lines": 19, "newlines": 20, "modlines": 0, "user": "BC0THOR"}, "text": "/**REXX****************************************************************/\n/*  NAME      - DATE                                                  */\n/*  TYPE      - TSO REXX                                              */\n/*  FUNCTION  - INVOKES THE DATEINFO PROGRAM TO DISPLAY AN INPUT DATE */\n/*              IN BOTH JULIAN AND GREGORIAN, AND GIVE ADDITIONAL     */\n/*              INFORMATION, SUCH AS DAY OF WEEK, HOLIDAY, ETC.       */\n/*  CALLED BY - USER                                                  */\n/*  RELATED   - PROGRAM: DATES (NOT A DIALOG)                         */\n/*  AUTHOR    - DICK THORNTON JAN 2000                                */\n/**********************************************************************/\nINPUT = TRANSLATE(ARG(1))     /* GET FIRST (ONLY) PARAMETER */\nIF INPUT = '' THEN DO\n    SAY 'JULIAN SYNTAX IS:    DATE ''JYYYYDDD'''\n    SAY 'GREGORIAN SYNTAX IS: DATE ''GMMDDYYYY'''\n    EXIT\n    END\nADDRESS 'TSO' \"ALLOCATE F(SYSPRINT) DA(*)\"\nADDRESS 'TSO' \"CALL 'SYS1.SYSB.HNET.LINKLIB(DATEINFO)' \"INPUT\"\"\nADDRESS 'TSO' \"FREE F(SYSPRINT)\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MODEL": {"ttr": 1807, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x13\\x00\\x99\\x02\\x1f\\x01\\x00\\x03/\\tI\\x00\\n\\x00\\x01\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1999-01-21T00:00:00", "modifydate": "2000-02-01T09:49:13", "lines": 10, "newlines": 1, "modlines": 0, "user": "BC0THOR"}, "text": "/**REXX****************************************************************/\n/*  NAME      -                                                       */\n/*  TYPE      - TSO REXX                                              */\n/*  FUNCTION  -                                                       */\n/*                                                                    */\n/*  CALLED BY - USER                                                  */\n/*  RELATED   - (panel) (program) (message) etc                       */\n/*  AUTHOR    - DICK THORNTON mmm yyyy                                */\n/**********************************************************************/\nNUMERIC DIGITS 32             /* SET NUMBER DIGITS FOR CALCULATIONS */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MULTPULL": {"ttr": 1809, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x00\\x99\\x02\\x1f\\x00\\x99\\x02\\x1f\\x17\\x00\\x00\\x07\\x00\\x07\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-01-21T00:00:00", "modifydate": "1999-01-21T17:00:54", "lines": 7, "newlines": 7, "modlines": 0, "user": "BC0THOR"}, "text": "/*REXX***********************************************************rexx*/\n/* a pull instruction can get several values in a single instruction */\n/*********************************************************************/\nsay Enter three numbers\npull n1 n2 n3\nn4 = n1 + n2 + n3\nsay The sum of the numbers is n4\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PARSPULL": {"ttr": 1811, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x003\\x00\\x99\\x02\\x1f\\x00\\x99\\x02\\x1f\\x16R\\x00\\n\\x00\\n\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-01-21T00:00:00", "modifydate": "1999-01-21T16:52:33", "lines": 10, "newlines": 10, "modlines": 0, "user": "BC0THOR"}, "text": "/*REXX***********************************************************rexx*/\n/* shows how to obtain upper and lower case input from the user with */\n/* a PULL keyword instruction preceded by the PARSE keyword.         */\n/*********************************************************************/\nsay \"Enter an animal name in mixed upper and lower case\"\npull name\nsay name 'notice it appears in all upper case'\nsay 'Now enter the same name again in upper and lower case'\nparse pull name\nsay name 'when PULL is preceded by PARSE input case is retained'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXXADDR": {"ttr": 2049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00 \\x8f\\x01\\x00 \\x8f\\x14X\\x00o\\x00o\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-07-26T00:00:00", "modifydate": "2000-07-26T14:58:00", "lines": 111, "newlines": 111, "modlines": 0, "user": "BC0THOR"}, "text": "***********************************************************************\n* SOME REXX ADDRESS COMMANDS FOUND BY A SCAN OF SYS1.CLIST. ALL DATA  *\n* WAS CONVERTED TO UPPER CASE, WHICH MAY, IN SOME CASES, AFFECT THE   *\n* STATEMENT.                                                          *\n***********************************************************************\nADDRESS 'ISPEXEC'\nADDRESS 'LINKMVS'\nADDRESS 'TSO'\nADDRESS 'TSO' \"CLR\"\nADDRESS \"ISREDIT\" \"(BEGL) = LINENUM .ZFRANGE\"  /* FIR         ST LINE*/\nADDRESS \"ISREDIT\" \"(ENDL) = LINENUM .ZLRANGE\"  /* LAS         T LINE */\nADDRESS \"ISREDIT\" \"MACRO (BEGL,ENDL) NOPROCESS\"\nADDRESS \"ISREDIT\" \"PROCESS RANGE C\"\nADDRESS \"TSO\" \"DELETE '\"PKAB\"'\"\nADDRESS ISPEXEC\nADDRESS ISPEXEC 'BROWSE DATAID(&DSN1)'\nADDRESS ISPEXEC 'CONTROL DISPLAY REFRESH'\nADDRESS ISPEXEC 'CONTROL ERRORS RETURN'\nADDRESS ISPEXEC 'DISPLAY PANEL(VIAWARPD)'\nADDRESS ISPEXEC 'FTCLOSE'\nADDRESS ISPEXEC 'FTINCL PDS$WFOR                              '\nADDRESS ISPEXEC 'FTOPEN TEMP'\nADDRESS ISPEXEC 'LMCOPY FROMID('TMPN') TODATAID('SYSN')'\nADDRESS ISPEXEC 'LMFREE DATAID(&DSN1)'\nADDRESS ISPEXEC 'LMINIT DATAID(DSN1) DDNAME(LSTCAT) EN        Q(EXCLU)'\nADDRESS ISPEXEC 'SELECT 'CMDSTR\nADDRESS ISPEXEC 'SELECT CMD(%PDSHOLCV IN OUT F)'\nADDRESS ISPEXEC 'SELECT CMD('CMD')'\nADDRESS ISPEXEC 'SELECT CMD(STARBAT)'\nADDRESS ISPEXEC 'SETMSG MSG('MSGID')'\nADDRESS ISPEXEC 'TBADD VIAWARP'\nADDRESS ISPEXEC 'TBCREATE  VIAWARP' ADDED\nADDRESS ISPEXEC 'TBCREATE OUT NAMES(OUTLINE) NOWRITE'\nADDRESS ISPEXEC 'TBDELETE 'TABLID\nADDRESS ISPEXEC 'TBDISPL 'CBTBL' PANEL(VIAWARP)'\nADDRESS ISPEXEC 'TBEND OUT'\nADDRESS ISPEXEC 'TBPUT  'TABLID\nADDRESS ISPEXEC 'TBSKIP 'CBTBL 'ROWID(ROWI)'\nADDRESS ISPEXEC 'TBTOP  'TABLID\nADDRESS ISPEXEC 'VGET ('KEYS,       /* GET KEYS                       */\nADDRESS ISPEXEC 'VPUT ('KEYS')'     /* TELL ISPF                      */\nADDRESS ISPEXEC \"BROWSE DATASET('\"DSN\"') VOLUME(\"VOL\")\"\nADDRESS ISPEXEC \"CONTROL DISPLAY RESTORE\"\nADDRESS ISPEXEC \"DISPLAY PANEL(PROGXXH0)\"\nADDRESS ISPEXEC \"EDIT DATAID(\"TEMPID\")\"\nADDRESS ISPEXEC \"FTCLOSE\"\nADDRESS ISPEXEC \"FTINCL PDS$LBAT\"\nADDRESS ISPEXEC \"FTOPEN TEMP\"\nADDRESS ISPEXEC \"LIBDEF ISPLLIB DATASET ID('MQS.MQSP.SCSQAUTH',\nADDRESS ISPEXEC \"LIBDEF ISPMLIB DATASET ID('MQS.MQSP.SCSQMSGE',\nADDRESS ISPEXEC \"LIBDEF ISPPLIB DATASET ID('MQS.MQSP.SCSQPNLE',\nADDRESS ISPEXEC \"LIBDEF ISPSLIB DATASET ID('MQS.MQSP.SCSQSKL')\"\nADDRESS ISPEXEC \"LIST BUFNAME(O) LINELEN(\"LENGTH(O)\") CC\"\nADDRESS ISPEXEC \"LMFREE DATAID(\"DID\")\"\nADDRESS ISPEXEC \"LMINIT DATAID(DID) DDNAME(SYSPRINT)\"\nADDRESS ISPEXEC \"LMQUERY DATAID(\"DID\") VOLUME(SRCVOL)\"\nADDRESS ISPEXEC \"SELECT CMD(%PDSWRPV1)\"\nADDRESS ISPEXEC \"SELECT PGM(STARBAT)\"\nADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\nADDRESS ISPEXEC \"SETMSG MSGID(\"ZERRMSG\")\"\nADDRESS ISPEXEC \"TBADD\" OUT\nADDRESS ISPEXEC \"TBADD\" TABLID\nADDRESS ISPEXEC \"TBADD\" WNAME\nADDRESS ISPEXEC \"TBBOTTOM\" TABLID\nADDRESS ISPEXEC \"TBCREATE TEMP1 NAMES(PDSLN1) NOWRITE REPLACE\"\nADDRESS ISPEXEC \"TBDELETE\" TABLID\nADDRESS ISPEXEC \"TBDISPL \"TABLENM\" PANEL(PROGXXAT)\"\nADDRESS ISPEXEC \"TBEND TEMP1\"\nADDRESS ISPEXEC \"TBGET\" MLTBL\nADDRESS ISPEXEC \"TBMOD COLTBL\"\nADDRESS ISPEXEC \"TBPUT\" MLTBL\nADDRESS ISPEXEC \"TBQUERY COLTBL POSITION(CSRROW)\"\nADDRESS ISPEXEC \"TBSKIP COLTBL\"\nADDRESS ISPEXEC \"TBTOP \"TABLENM\nADDRESS ISPEXEC \"VGET (BJC1 BJC2 BJC3 BJC4) PROFILE\"\nADDRESS ISPEXEC \"VGET ZSCREEN SHARED\" /* GET LOGICAL SCREEN NUMBER   */\nADDRESS ISPEXEC \"VPUT (PDSTCNT PDSTRC) SHARED\"\nADDRESS ISPEXEC CMDX\nADDRESS ISREDIT\nADDRESS ISREDIT \"CAPS = \"ICAPS /* RESTORE CAPS STATE UPON ENTRY */\nADDRESS SYSCALL 'ACCESS (PARM)' F_OK\nADDRESS SYSCALL 'GETCWD PARM'\nADDRESS SYSCALL 'GETCWD PARM'\nADDRESS SYSCALL 'READFILE (PARM) F.'\nADDRESS SYSCALL 'REALPATH (PARM) FN'\nADDRESS SYSCALL 'REALPATH (PARM) P'\nADDRESS SYSCALL 'WRITEFILE (PARM)' VPERM 'TXT.'\nADDRESS TSO\nADDRESS TSO 'ALLOC FI(TOPSPRN) SYSOUT('PSO') REUSE'\nADDRESS TSO 'CONSOLE SYSCMD' ||, /* ISSUE COMMAND                     */\nADDRESS TSO 'EXECIO * DISKW TOPSPRN (FINI' /* WRITE STACK             */\nADDRESS TSO 'FREE DD(DD01 DD01O SYSIN SYSPRINT)'\nADDRESS TSO 'FREE FI(TOPSPRN)' /* SPIN FILE                           */\nADDRESS TSO 'ISPSTART CMD(MQ19TEST1) NEWAPPL(MA19)'\nADDRESS TSO \"%DB2SYSID\"\nADDRESS TSO \"CLR\"\nADDRESS TSO \"DEL TSO.COLS\"\nADDRESS TSO \"EXECIO * DISKW \"PROGXXS_DDN\" (FINIS\"\nADDRESS TSO \"EXECIO 0 DISKR\" IN \"(FINIS\"\nADDRESS TSO \"EXECIO 0 DISKR\" IN \"(OPEN\"\nADDRESS TSO \"EXECIO 0 DISKW\" OUT \"(FINIS\"\nADDRESS TSO \"EXECIO 0 DISKW\" OUT \"(OPEN\"\nADDRESS TSO \"EXECIO 1 DISKR\" IN\nADDRESS TSO \"EXECIO 1 DISKW\" OUT\nADDRESS TSO \"FREE FI(LSTCAT)\"\nADDRESS TSO \"LISTCAT ENTRY('SYS1.LINKLIB') ALL\"\nADDRESS TSO \"PDSE '\"DSN\"' VOLUME(\"VOL\")\"\nADDRESS TSO \"SHOWTSO SYSRES\"                                   */\nADDRESS TSO CMD\nINTERPRET \"ADDRESS TSO\" STARTOOL 'DSN1' USAGE\nINTERPRET \"ADDRESS TSO\" VAR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SAY": {"ttr": 2052, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00X\\x00\\x99\\x02\\x1f\\x00\\x99\\x02\\x1f\\x16\\x19\\x00\\x07\\x00\\x02\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1999-01-21T00:00:00", "modifydate": "1999-01-21T16:19:58", "lines": 7, "newlines": 2, "modlines": 0, "user": "BC0THOR"}, "text": "/*REXX****************************************************************/\nSay 'This is a Mixed-Mode Message'\nsAy 'This is an example of a literal that is continued on',\n    'another line using a comma at the end of the first line.'\nsaY \"This is two\"          'quoted literals'\nSAY \"These two\"  ||      'literals contain the || to eliminate blank'\nsay 'This is an example'; say 'of two statements on one line'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TEST": {"ttr": 2054, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x0c\\x00'\\x01\\x00\\x18_\\x01\\x00\\x19?\\x17\\x08\\x00s\\x00\\x0f\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@\"", "ispf": {"version": "01.12", "flags": 0, "createdate": "2000-07-03T00:00:00", "modifydate": "2000-07-11T17:08:27", "lines": 115, "newlines": 15, "modlines": 0, "user": "BC0THOR"}, "text": "/* REXX ***************************************************************/\n/*  TEST VARIOUS REXX CONSTRUCTS                                      */\n/**********************************************************************/\n\nSIGNAL THIS_IS_A_BRANCH_LABEL  /* SIGNAL FUNCTIONS AS A GOTO IN REXX */\n\n/**********************************************************************/\n/* CALL AN EXTERNAL PROGRAM USING STANDARD MAINFRAME LINKAGE. THE     */\n/* LOAD LIBRARY CONTAINING THE PROGRAM IS SUPPLIED BY ALLOCATING IT   */\n/* TO ISPLLIB. THE LENGTH OF THE RETURNED VARIABLE IS SET BEFORE THE  */\n/* CALL. PROGRAM NAME MUST BE IN CAPS. RETURN CODE IS IN PREDEFINED   */\n/* REXX VARIABLE RC.                                                  */\n/**********************************************************************/\nADDRESS ISPEXEC \"LIBDEF ISPLLIB DATASET ID('BC0THOR.LOAD.LOAD')\"\nJOBNAME = '12345678'           /* SET JOBNAME AS AN 8-BYTE VARIABLE */\nADDRESS LINKPGM 'GETJOBN JOBNAME' /* CALL GETJOBN SUBPROGRAM */\nIF RC = 0 THEN                    /* RC IS VALUE IN R15 ON RETURN */\n  SAY 'JOB NAME IS ' JOBNAME\nELSE DO                           /* DO USED TO GROUP INSTRUCTIONS */\n       SAY 'CALL TO GETJOBN FAILED WITH RC =' RC\n       SAY 'GETJOBN SHOULD HAVE RETURNED JOBNAME'\n     END\n\n/**********************************************************************/\n/* CALL AN INTERNAL ROUTINE WHICH RETURNS A VALUE IN RESULT. INTERNAL */\n/* ROUTINES CAN MANIPULATE VARIABLES IDENTIFIED IN THIS PROGRAM.      */\n/**********************************************************************/\nCALL ADDRTN 12.6 31.9\nSAY '12.6 + 31.9 = ' RESULT\n\n\n/**********************************************************************/\n/* CALL AN EXTERNAL REXX ROUTINE WHICH RETURNS A VALUE IN RESULT. THE */\n/* EXTERNAL PROGRAM NAME MUST BE IN CAPS, AND MUST BE IN THE SAME     */\n/* LIBRARY AS THIS EXEC. CALLED PROGRAM CANNOT MODIFY VARIABLES PASSED*/\n/**********************************************************************/\nCALL \"TEST1\" 12.6 31.9\nSAY '12.6 - 31.9 = ' RESULT\n\n/**********************************************************************/\n/* DO GROUPS. SIMPLE INSTRUCTION-GROUPING DO SHOWN ABOVE WITH ADDRESS.*/\n/**********************************************************************/\nFIVE = 5\nDO FIVE                    /* SIMPLE INSTRUCTION SEQUENCE REPEAT */\n   FIVE = FIVE + 1         /* NOTE THAT CHANGING THE REPEAT VARIABLE\n                              DOES NOT AFFECT THE LOOP COUNT */\n   SAY 'THE VARIABLE FIVE NOW HAS THE VALUE' FIVE\nEND\n\nI = 0.3\nDO Y=I TO I+4 BY 0.7 FOR 10  /* THE FOR VALUE MERELY SETS A MAXIMUM\n                                NUMBER OF ITERATIONS. NOTE THE LOOP\n                                VARIABLES CAN BE FRACTIONAL. */\n   SAY 'Y IS NOW' Y\nEND\n\nA = 0\nDO OUTER = 1 TO 10         /* NESTED DO LOOPS */\n   DO INNER = 1 TO 5\n      A = A + 2\n   END INNER               /* STATING LOOP VARIABLE ON END IMPROVES */\nEND OUTER                  /* EFFICIEMCY AND HELPS IDENTIFY THE LOOP */\nSAY 'VALUE IN A AFTER OUTER-INNER LOOP IS' A\n\nDO I = 1 TO 30 BY 3 UNTIL I > 25 /* UNTIL IS TESTED AT BOTTOM OF LOOP,\n                                    WHILE IS TESTED AT TOP OF LOOP */\n   IF I = 10 THEN ITERATE     /* JUMP TO TOP WHEN I = 10 */\n   IF I = 22 THEN LEAVE       /* EXIT LOOP WHEN I = 22 */\n   SAY 'I =' I\nEND\n\nA = 0\nDO FOREVER                 /* REQUIRES LOOP TO BE BROKEN FROM WITHIN */\n  A = A + 1\n  IF A = 5 THEN LEAVE\n  SAY 'FOREVER LEAVES WHEN A = 5. A IS NOW' A\nEND\n\nDROP A I                      /* DROP RELEASES A VARIABLE */\nSAY 'VALUES FOR A AND I ARE NOW:' A 'AND' I\n\nIF ANSWER = YES THEN SAY 'ANSWER IS YES' /* IF ELSE ON SAME LINE AS */\n   ELSE SAY 'ANSWER IS NOT YES'  /* THEN, PRECEDE IT WITH SEMICOLON */\n\nIF ANSWER = 'YES' THEN     /* ELSE BINDS TO NEAREST IF WITHOUT AN */\n   IF A = 3                /* ASSOCIATED ELSE. TO ELIMINATE ERRORS */\n      THEN SAY 'A IS 3'    /* USE THE ELSE NOP CONSTRUCT. */\n   ELSE\n      NOP\nELSE\n   SAY 'ANSWER IS NOT YES'\n\nSTART = 'DO I = 1 TO 3;' /* INTERPRET BUILDS */\nMIDDLE = \"SAY 'I IS NOW' I; SAY 'CONTINUING...'\" /* A STRING FROM AN */\nFINISH = ';END'                                  /* EXPRESSION, THEN */\nINTERPRET START MIDDLE FINISH                    /* EXECUTES IT */\n\nTHIS_IS_A_BRANCH_LABEL:\nSAY 'GOT TO THE BRANCH LABEL'\n\n\n\n\n\nJ = 3\nEXIT 4 * J   /* EXITS WITH (OPTIONAL) STRING '12' RETURNED TO CALLER */\n\n/**********************************************************************/\n/* INTERNAL SUBROUTINE RETURNING A VALUE IN THE PREDEFINED REXX       */\n/* VARIABLE NAMED RESULT.                                             */\n/**********************************************************************/\nADDRTN:\nARG NUM1 NUM2                    /* DIG OUT PARMS PASSED */\nSUM = NUM1 + NUM2                /* ADD THE NUMBERS      */\nRETURN SUM                       /* RETURN THE SUM IN RESULT */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TEST1": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x007\\x01\\x00\\x18\\x8f\\x01\\x00\\x18\\x8f\\x08E\\x00\\x0b\\x00\"\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-07-06T00:00:00", "modifydate": "2000-07-06T08:45:37", "lines": 11, "newlines": 34, "modlines": 0, "user": "BC0THOR"}, "text": "/* REXX ***************************************************************/\n/*  TEST VARIOUS REXX CONSTRUCTS - EXTERNAL SUB PROGRAM               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* EXTERNAL SUBROUTINE RETURNING A VALUE IN THE PREDEFINED REXX       */\n/* VARIABLE NAMED RESULT.                                             */\n/**********************************************************************/\nARG NUM1 NUM2                    /* DIG OUT PARMS PASSED */\nDIFF = NUM1 - NUM2               /* SUBTRACT THE NUMBERS      */\nRETURN DIFF                      /* RETURN THE DIFFERENCE IN RESULT */\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TIMEGAME": {"ttr": 2059, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x17\\x00\\x99\\x02\\x1f\\x00\\x99\\x02\\x1f\\x16H\\x00\\x15\\x00\\x12\\x00\\x00\\xc2\\xc3\\xf0\\xe3\\xc8\\xd6\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-01-21T00:00:00", "modifydate": "1999-01-21T16:48:17", "lines": 21, "newlines": 18, "modlines": 0, "user": "BC0THOR"}, "text": "/*REXX***********************************************************rexx*/\n/* This is an interactive REXX exec that asks the user for the       */\n/* time and then displays the time from the TIME command.            */\n/* Taken from the REXX User's Guide V2R5 SC28-1882-05                */\n/*********************************************************************/\nGame1: /* this is a label instruction */\n\ntimevar = 0               /* this is an assignment instruction */\n                             /* this is a null statement */\nsay 'What time is it?' /* this is a keyword (say) instruction */\npull usertime         /* get user's response to variable usertime */\nif usertime = '' then /* if user didn't enter a time */\n    say \"O.K., Game's over.\"\nelse\n    DO\n       SAY \"The computer says:\"\n          TIME /* this is a command instruction as it is not\n                  one of the above */\n    End\n\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT562/FILE562.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT562", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}