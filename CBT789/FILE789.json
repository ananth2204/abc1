{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012810000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 470288, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 9, "INMDSNAM": "CBT.V500.FILE789.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE789.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x08\\n'", "DS1TRBAL": "b'.Z'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x05X\\x00\\x01\\x05X\\x00\\t\\x00\\t'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04_\\x00)\\x01\\x17%O\\x01\\x17%O\\x14\\x05\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf5@@@'", "ispf": {"version": "04.95", "flags": 0, "createdate": "2017-09-11T00:00:00", "modifydate": "2017-09-11T14:05:29", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-495"}, "text": "REGULAR CBT TAPE - VERSION 495    FILE:  789\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT495.FILE789\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 23 MEMBERS COUNTED; CUMULATIVE SIZE IS 3,890 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   09/11/17    14:05:29    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE01": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x15\\x01\\x08 _\\x01\\x08 _\\x13)\\x00W\\x00W\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-07-23T00:00:00", "modifydate": "2008-07-23T13:29:15", "lines": 87, "newlines": 87, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:    CBT Tape submission\nFrom:       <alferguson@northwesternmutual.com>\nDate:       Mon, 21 Jul 2008 08:30:56 -0500\nTo:         <sknutson@cbttape.org>, <sbgolob@cbttape.org>\n\nSam & Sam,\n\nI have been working on a batch JOB to automate the sending of\nour Monthly SCRT Report (Sub-Capacity Reporting Tool) to IBM\nfor Sub-Capacity Licensing via eMail. It uses:\n\n          o CBT GDG Copy Utility (File 482)\n          o A REXX I wrote to Build the IFASMFDP PARMs to get\n            just last months MULC Records (runs under IRXJCL).\n          o IBM's SCRTTOOL (see\n            http://www-03.ibm.com/servers/eserver/zseries/swprice/scrt/\n          o A RXSOCKET API based REXX I wrote to submit the\n            report as a MIME attachment to IBM's LMS eMail process\n            (runs under IRXJCL).\n          o A REXX to do date manipulation, based of a REXX &\n            Algorithms by David A. Cromley (A System Programmer\n            Journal article from early 1990's).\n\nI also have the following JCL for this process:\n\n          o The entire JOB (6 STEPs + 1 per Image with MULC\n            Records you need to process)\n          o Sample PARMs for my REXX EXECs.\n          o Sample PARMs for SCRT Tool (though each shop update\n            these to reflect their environment)\n          o Sample JOB to LINKEDIT the SCRTTOOL (IBM gives you an\n            inline LinkEdit-Go JOB)\n\nWe schedule this JOB to run on the 2nd day of the month, early in\nthe morning (This is the earliest IBM is ready to accept these\nreports). It automatically sends the SCRT Tool Report to IBM each\nmonth. IBM's suggest way to accomplish this requires a number of\nmanual steps (create the report, download to your PC, create an\nemail, attach the report, and send). Using our process I do not\nforget and can go on vacation during the beginning of the month\n(with IBM's manual process, this could cause fines if we miss\ngetting the report to them on time).\n\nSince IBM \"improved\" its eMail process, it has gotten very picky.\nIt took 3 months to get this working again (IBM has a number of\nnot so well documented requirements for this process. They also\ngave little information to help us figure out why it was not being\naccepted by the new process). This version works with the new\nsystem which assumes your IBM Account Name is also your email\naddress and is 32 or less characters in total. For those using\nSub-Capacity Licensing, this may be quite useful (and allow them\nto keep some more of their hair, vs. trying to figure this out on\ntheir own).\n\nIn the process of creating this I wrote a generic RXSOCKET API\nbase REXX to do eMail with MIME attachments. I also used this to\ntest the SMTP Server and adjust its configuration (getting it to\nwork, securing it, and tuning logging). This REXX runs under\nIRXJCL and handles the following MIME Types:\n\nThe last Content-Type requires access to the Leland Lucius's\nENCODE64 REXX Function from http://www.homerow.net/asm/index.htm\n(I believe it is also part of his XMITIP). I also have a sample\nJOB to run this REXX adding a couple of attachments. This was an\ninteresting programming exercise in socket Programming, SMTP\nsocket programming, and SMTP header coding. I have not seen a\nRXSOCKET API REXX that covered all of this, so it may be of\ninterest to others for this reason. This REXX works under:\n\n          o IRXJCL with pre-allocated files (TSO is not required)\n          o TSO with pre-allocated files\n          o A REXX or CList running under TSO, used to build and\n            pre-allocate the files.\n\nAttached is a TSO XMIT file of the PDS with the above files. If\nyou see anything missing I should include, let me know (I probably\nneed better documentation on the attachment types and the EMCNTL\nDD's Control cards. When I get some more time I will try to put\nthis together). Thanks.\n\n---------------\n\nAl Ferguson        | mailto:AlFerguson@northwesternmutual.com\nTechnical Support  |  phone: 414-661-5403\nNorthwestern Mutual|    fax: 414-661-6957\n1E220\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE02": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x17$\\x9f\\x01\\x17$\\x9f 5\\x00\\x18\\x00\\x18\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-09-06T00:00:00", "modifydate": "2017-09-06T20:35:44", "lines": 24, "newlines": 24, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  File 789 Updates\nFrom:     \"Ferguson, Al\" <Al.Ferguson@sccompanies.com>\nDate:     8/29/2017 10:54 AM\nTo:       \"sbgolob@cbttape.org\" <sbgolob@cbttape.org>\n\nSam,\n\nI have updated File 789. It includes:\n\nReplacing the GDGCOPY program from FILE482 with a\nGDGCOPY REXX I wrote using BPXWDYN & the Catalog Search\nInterface (CSI).\n\nVarious fixes to DATEX (including some new functionality)\n\nA few fixes to the SCRTML & SENDMAIL REXXes (fixed some\nshop specific coding).\n\nThanks for keeping CBTTape.org up to date.\n\nAl Ferguson\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 | phone: 608-324-9170\nSenior Systems Programmer |\u00a0 mail: Albert.Ferguson@sccompanies.com\nColony Brands, Inc\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 |\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$LIST": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x005\\x01\\x08\\x19\\x8f\\x01\\x17%O\\t\\x00\\x00\\x18\\x00\\x12\\x00\\x00\\xe3\\xe2\\xc1\\xe9\\xc6\\xc1@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2008-07-16T00:00:00", "modifydate": "2017-09-11T09:00:35", "lines": 24, "newlines": 18, "modlines": 0, "user": "TSAZFA"}, "text": "FROM CBT.FILE789.PDS\n  DATEX    - REXX to do Date Manipulations\n\n  GDGCOPY  - MVS REXX to copy a GDG in creation order.\n  GDGCPROC - IRXJCL PROC to call GDGCOPY REXX\n\n  JCLSCRTL - JCL to LINKEDIT the IBM SCRT Tool utility\n  JCLSCRTM - JCL to gather SMF, run SCRT Tool, and eMail Report to LMS\n  JCLSENDM - JCL to call SENDMAIL REXX in batch\n\n  REXXEPNL - My common REXX Error handling Panel\n  RHELP02  - My common REXX Help Display Panel\n\n  SCRTML   - REXX to build MIME eMail for LMS\n  SCRTMP01 - JCLSCRTM PARM #1 -- DFSORT control member to merge SMF\n  SCRTMP02 - JCLSCRTM PARM #2 -- SMF Dump control PARMs not created\n                                 by SMFPARM REXX\n  SCRTMP03 - JCLSCRTM PARM #3 -- SCRT Tool NO89 control member\n  SCRTMP04 - JCLSCRTM PARM #4 -- SCRT Tool PARMS control member\n  SCRTMP05 - JCLSCRTM PARM #5 -- EMCNTL control member\n\n  SENDMAIL - REXX to do SMTP eMail using RXSOCKET API\n  SMFPARM  - REXX to build SMF Dump Utility PARMs for last month's data\n  TESTMAIL - REXX to build control members and call SENDMAIL REXX\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE789": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04_\\x00#\\x01\\x17%O\\x01\\x17%O\\x14\\x05\\x00Y\\x00Y\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf5@@@'", "ispf": {"version": "04.95", "flags": 0, "createdate": "2017-09-11T00:00:00", "modifydate": "2017-09-11T14:05:23", "lines": 89, "newlines": 89, "modlines": 0, "user": "CBT-495"}, "text": "//***FILE 789 is from Al Ferguson and contains a batch job to       *   FILE 789\n//*           automate and run IBM's SCRT (Sub-Capacity             *   FILE 789\n//*           Reporting Tool) report every month automatically,     *   FILE 789\n//*           and to email the result to IBM.  This will help       *   FILE 789\n//*           all of you who have to do this, and use a person      *   FILE 789\n//*           to perform all the operations manually.               *   FILE 789\n//*                                                                 *   FILE 789\n//*           email: Al.Ferguson@sccompanies.com                    *   FILE 789\n//*                                                                 *   FILE 789\n//*   See member $$NOTE02 for update information.                   *   FILE 789\n//*                                                                 *   FILE 789\n//*   Description ---                                               *   FILE 789\n//*                                                                 *   FILE 789\n//*   I have been working on a batch JOB to automate the            *   FILE 789\n//*   sending of our Monthly SCRT Report (Sub-Capacity              *   FILE 789\n//*   Reporting Tool) to IBM for Sub-Capacity Licensing via         *   FILE 789\n//*   eMail. It uses:                                               *   FILE 789\n//*                                                                 *   FILE 789\n//*   o CBT GDG Copy Utility (File 482)                             *   FILE 789\n//*   o A REXX I wrote to Build the IFASMFDP PARMs to               *   FILE 789\n//*     get just last months MULC Records (runs under               *   FILE 789\n//*     IRXJCL).                                                    *   FILE 789\n//*   o IBM's SCRTTOOL (see                                         *   FILE 789\n//*     http://www-03.ibm.com/servers/eserver/zseries/swprice/scrt/ *   FILE 789\n//*   o A RXSOCKET API based REXX I wrote to submit the             *   FILE 789\n//*     report as a MIME attachment to IBM's LMS eMail              *   FILE 789\n//*     process (runs under IRXJCL).                                *   FILE 789\n//*   o A REXX to do date manipulation, based of a REXX &           *   FILE 789\n//*     Algorithms by David A. Cromley (A System Programmer         *   FILE 789\n//*     Journal article from early 1990's).                         *   FILE 789\n//*                                                                 *   FILE 789\n//*   I also have the following JCL for this process:               *   FILE 789\n//*                                                                 *   FILE 789\n//*   o The entire JOB (6 STEPs + 1 per Image with MULC             *   FILE 789\n//*     Records you need to process)                                *   FILE 789\n//*   o Sample PARMs for my REXX EXECs.                             *   FILE 789\n//*   o Sample PARMs for SCRT Tool (though each shop                *   FILE 789\n//*     update these to reflect their environment)                  *   FILE 789\n//*   o Sample JOB to LINKEDIT the SCRTTOOL (IBM gives              *   FILE 789\n//*     you an inline LinkEdit-Go JOB)                              *   FILE 789\n//*                                                                 *   FILE 789\n//*   We schedule this JOB to run on the 2nd day of the month,      *   FILE 789\n//*   early in the morning.  (This is the earliest IBM is ready     *   FILE 789\n//*   to accept these reports).  It automatically sends the         *   FILE 789\n//*   SCRT Tool Report to IBM each month.  IBM's suggested way      *   FILE 789\n//*   to accomplish this requires a number of manual steps          *   FILE 789\n//*   (create the report, download to your PC, create an email,     *   FILE 789\n//*   attach the report, and send).  Using our process I do not     *   FILE 789\n//*   forget and can go on vacation during the beginning of the     *   FILE 789\n//*   month (with IBM's manual process, this could cause fines      *   FILE 789\n//*   if we miss getting the report to them on time).               *   FILE 789\n//*                                                                 *   FILE 789\n//*   Since IBM \"improved\" its eMail process, it has gotten         *   FILE 789\n//*   very picky.  It took 3 months to get this working again       *   FILE 789\n//*   (IBM has a number of not so well documented                   *   FILE 789\n//*   requirements for this process. They also gave little          *   FILE 789\n//*   information to help us figure out why it was not being        *   FILE 789\n//*   accepted by the new process). This version works with         *   FILE 789\n//*   the new system which assumes your IBM Account Name is         *   FILE 789\n//*   also your email address and is 32 or less characters in       *   FILE 789\n//*   total. For those using Sub-Capacity Licensing, this may       *   FILE 789\n//*   be quite useful (and allow them to keep some more of          *   FILE 789\n//*   their hair, vs. trying to figure this out on their            *   FILE 789\n//*   own).                                                         *   FILE 789\n//*                                                                 *   FILE 789\n//*   In the process of creating this I wrote a generic             *   FILE 789\n//*   RXSOCKET API base REXX to do eMail with MIME                  *   FILE 789\n//*   attachments. I also used this to test the SMTP Server         *   FILE 789\n//*   and adjust its configuration (getting it to work,             *   FILE 789\n//*   securing it, and tuning logging). This REXX runs under        *   FILE 789\n//*   IRXJCL and handles the following MIME Types:                  *   FILE 789\n//*                                                                 *   FILE 789\n//*   The last Content-Type requires access to the Leland           *   FILE 789\n//*   Lucius's ENCODE64 REXX Function from                          *   FILE 789\n//*   http://www.homerow.net/asm/index.htm (I believe it is         *   FILE 789\n//*   also part of his XMITIP).  I also have a sample JOB to        *   FILE 789\n//*   run this REXX adding a couple of attachments. This was        *   FILE 789\n//*   an interesting programming exercise in socket                 *   FILE 789\n//*   Programming, SMTP socket programming, and SMTP header         *   FILE 789\n//*   coding.  I have not seen a RXSOCKET API REXX that             *   FILE 789\n//*   covered all of this, so it may be of interest to others       *   FILE 789\n//*   for this reason.  This REXX works under:                      *   FILE 789\n//*                                                                 *   FILE 789\n//*   o IRXJCL with pre-allocated files (TSO is not                 *   FILE 789\n//*     required)                                                   *   FILE 789\n//*   o TSO with pre-allocated files                                *   FILE 789\n//*   o A REXX or CList running under TSO, used to build            *   FILE 789\n//*     and pre-allocate the files.                                 *   FILE 789\n//*                                                                 *   FILE 789\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DATEX": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x03*\\x008\\x01\\x00 \\x7f\\x01\\x17$\\x1f\\t3\\x01\\xce\\x01\\xd7\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "03.42", "flags": 0, "createdate": "2000-07-25T00:00:00", "modifydate": "2017-08-29T09:33:38", "lines": 462, "newlines": 471, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX converts date formates and can be used to do date arithmetic.\n\n                        Date conversion routines\n                  See help at bottom for instructions\n            original Algorithms (c) 1991 by David A. Cromley\n                 as published in Tech Support Magazine\n               modified Algorithms - 2000 by Al Ferguson\n    Use of any of these algorithms requires this notice be included.\n\n                           --- EXAMPLE ---\nTSO <%>DATEX p1 <p2 <p3>> <TEST(valid REXX trace option)>\nTSO <%>DATEX -H -- To display help for this REXX\n\n  Arguments: p1          - First parm  -- see below\n             p2          - Second parm -- see below\n             p3          - Third parm  -- see below\n             InParms     - Non-Positional  parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n\n                     --- Input Format Examples ---\n              datex today       converts from todays date\n              datex tommorow    converts from tomorrows date\n              datex yesterday   converts from yesterdays date\n              datex bbbbbb      converts from base date\n              datex yyyy jjj    converts from julian date\n              datex dd mm yyyy  converts from day, month, year\n\n\n  In all cases, output is:  YYYY-MM-DD.JJJ BBBBBB Day-of-week\n     where mm is month 1-12\n           dd is day 1-31\n          jjj is julian date 1-366\n         yyyy is year >= 0001\n       bbbbbb is the number of days since 01 January 0001\n  day-of-week is the full English Day of the Week in mixed case\n\n      Files: NONE\nOther EXECS: NONE\n\nEXEC History\n\n  EXEC Name: DATEX\n     Author: AL FERGUSON - TS ADM (TSAZFA) from version 3.29\n             Al Ferguson (HUL2353) from version 3.03\n             Al Ferguson (TTECAH1) from version 1.01\n             David A. Cromley, Brought in and enhanced by\n                   Al Ferguson (TTECAH1)\n     Writen: 1991\n    History: 06FEB17 - v3.31 - Update Error Handling Routines\n             22FEB11 - v3.27 - Ensure we are in a Leap Year if trying to\n                       use February 29th as a date or Julian 366.\n             22FEB11 - v3.24 - Add support for TOMORROW and use REXX DATE\n                       Function conversions were possible.\n             26AUG08 - v3.20 - Add support for \"YESTERDAY\"\n             26JUL00 - v3.03 - Reworking of algorithms to avoid\n                       Y2K problems and support wider date range.\n             07JUL98 - v2.17 - Use the SET_MSG vs SAY FUNCTION to\n                       better support being CALLed.\n             18MAY95 - v2.07 - Update all REXXes w/latest versions of\n                       commom routines via %CCMASS\n             23FEB95 - v2.06 - Remove dependance on TSO to allow\n                       use as a CALLed REXX Function under MVS & IRXJCL.\n             15DEC93 - v2.03 - Support for ISPF and TSO base Help\n                       screens added.\n             23JUN93 - v2.00 - Maintenance done to include the\n                       latest changes to many COPY members.  This\n                       maintenance done via CCMASS.\n             26MAY93 - v1.10 - ERROR handling, Help display, and\n                       NP-PARM Support added.\n             1991    - v1.00\n***************************** Rexx ***********************************/\nARG p1 p2 p3 InParms\n\nIF WORDPOS(p1,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nSELECT\n  WHEN ABBREV(\"TODAY\", p1)     THEN CALL BBB2ALL DATE('B')\n  WHEN ABBREV(\"TOMORROW\", p1)  THEN CALL BBB2ALL DATE('B')+1\n  WHEN ABBREV(\"YESTERDAY\", p1) THEN CALL BBB2ALL DATE('B')-1\n  WHEN p2=''                   THEN DO   /* SAY 'Converting bbb'      */\n      IF p1 < 1 THEN DO\n          CALL SET_MSG , \"ccccc must be greater then 1!\", \"YES\"\n          EXIT ExitError\n      END\n      CALL BBB2ALL p1\n    END\n  WHEN \u00ac(DATATYPE(p2,'W'))     THEN CALL DISPLAY_HELP\n  WHEN p3=''                   THEN DO   /* 'Converting yyyy jjj'     */\n      year = EDPY(p1)\n      IF p2<1 | p2>366 THEN DO\n          CALL SET_MSG , \"Julian must be 1-366.\", \"YES\"\n          EXIT ExitError\n      END\n      IF p2=366 & \u00ac(IS_LEAP(year)) THEN DO\n          CALL SET_MSG , \"Julian must be 1-365 for\" year\".\", \"YES\"\n          EXIT ExitError\n      END\n      CALL BBB2ALL DATE(\"B\",RIGHT(year,2)||RIGHT(p2,3,\"0\"),\"J\")\n    END\n  WHEN DATATYPE(p3,'w')=0      THEN CALL DISPLAY_HELP\nOTHERWISE                                /* 'Converting mm dd yyyy'   */\n   year = EDPY(p3)\n   SELECT\n     WHEN p1<1 | p1>12                         THEN DO\n         CALL SET_MSG , \"Month must be 1-12\", \"YES\"\n         EXIT ExitError\n       END\n     WHEN  p2<1 | p2>31                        THEN DO\n         CALL SET_MSG , \"Day must be 1-31\", \"YES\"\n         EXIT ExitError\n       END\n     WHEN p2 = 29 & p1 = 02 & \u00ac(IS_LEAP(year)) THEN DO\n         CALL SET_MSG , \"February 29th not valid for '\"year\"'!\", \"YES\"\n         EXIT ExitError\n       END\n   OTHERWISE; NOP; END\n   CALL BBB2ALL DATE(\"B\",RIGHT(year,4)||RIGHT(p1,2,\"0\")||RIGHT(p2,2,\"0\"),\"S\")\nEND\n\nok = '*';\"SUBCOM TSO\"             /* How do we end this REXX?         */\nIF RC = 0 THEN DO                 /* If TSO, RETURN if CALLed         */\n   IF SYSVAR(\"SYSNEST\") = 'YES' THEN RETURN zzz\n   ELSE DO                       /* or if EXECed from CMD Line        */\n      CALL SET_MSG , zzz, \"YES\"\n      EXIT ExitError\n   END\n  END\nELSE RETURN zzz                   /* If MVS, RETURN                    */\n/***************************** REXX ************************************\n                            END of REXX\n****************************** REXX ************************************\n                       Beginning of PROCEDURES\n****************************** REXX ************************************/\n/***********************************************************************\n            INITIALIZE varables and get startup parameters\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0     /* REXX functional values for TRUE and FALSE    */\n                      /* INITIALIZE and process non-positional parms  */\n  ValidParms=\"TEST(O)\"\n  MatchLength=4\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  ExitError=0\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n        Validate and format Year\n**********************************************************************/\nEDPY:\nARG py\n  SELECT\n    WHEN LENGTH(py) = 4 THEN IF py < 1 THEN DO /* Valid Year?        */\n       CALL SET_MSG ,\"'\"py\"' is an invalid Year! The Year must be > 1!\",,\n                     \"YES\"\n       EXIT 8\n      END\n    WHEN py < 50        THEN py = py + 2000    /* Y2K Windowing      */\n    WHEN py < 100       THEN py = py + 1900    /* Y2K Windowing      */\n  OTHERWISE; NOP; END\nRETURN py\n/**********************************************************************\n        Convert days since 1 ,1 ,1 AD to MMDDYY.JJJ\n          final results -- \"YYYY-MM-DD.JJJ BBBBBB Day-of-week\"\n**********************************************************************/\nBBB2ALL:                         /* CONVERT BBBBBB TO MM DD YYYY.JJJ */\nARG bbb .\n  dow = DATE(\"W\", bbb, \"B\")\n  PARSE VALUE DATE(\"S\", bbb, \"B\") WITH yyyy 5 mm 7 dd .\n\n  y1    = 365\n  y4    =  4*y1   + 1\n  y100  = 24*y4   + (4*y1)\n  y400  =  4*y100 + 1\n\n  y400s = bbb  %y400; l400s = bbb  //y400\n  y100s = l400s%y100; l100s = l400s//y100\n  y4s   = l100s%y4  ; l4s   = l100s//y4\n  y1s   = l4s  %y1  ; jjj   = l4s  //y1 + 1\n\n  IF jjj = 1 & dd = 31 & mm = 12 THEN jjj = 366\n\n  zzz=RIGHT(yyyy,4,'0')'-'RIGHT(mm,2,'0')'-'RIGHT(dd,2,'0')'.'RIGHT(jjj,3,'0'),\n      bbb dow\nRETURN\n/**********************************************************************\n      Is the Year a Leap Year?\n***********************************************************************/\nIS_LEAP:\nARG check_me .\n  SELECT\n    WHEN (check_me//400) = 0 THEN RETURN TRUE\n    WHEN (check_me//100) = 0 THEN RETURN FALSE\n    WHEN (check_me//  4) = 0 THEN RETURN TRUE\n  OTHERWISE;                      RETURN FALSE; END\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GDGCOPY": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x02\\x007\\x01\\x10\\x14\\x0f\\x01\\x17$\\x1f\\t@\\x01\\x9a\\x01x\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "02.02", "flags": 0, "createdate": "2010-05-20T00:00:00", "modifydate": "2017-08-29T09:40:37", "lines": 410, "newlines": 376, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX uses IGGCSI00 (the Catalog Search Interface), then BPXWDYN\n      to dynmically ALLOCATE all the GDSs in a GDG Base and then to\n      CONCATinate them into a single SYSUT1 DD, and then finally\n      ICEGENER to COPY then into a single file specified by SYSUT2.\n\nNOTE: This is done without using TSO!\n\n                           --- EXAMPLE ---\nIRXJCL GDGCOPY GdgBase <CATALOG(catalog_to_check)> <TEST(TraceOption)>\nIRXJCL GDGCOPY -H -- To display help for this REXX\n\n  Arguments: GdgBase     - The GdgBase name to return GDSes for\n                           i.e. the individual \"G0000V00\"s for the GDG\n             InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                 CATALOG - Catalog to search against.    default: blank\n                    TEST - Used to control traces\n\n      Files: The GDS List for a GDG Base retrieved via CSI\n             SYSUT2 must be pre-allocated before calling GDGCOPY\nOther EXECS: NONE\n Sample JCL: //STEP0001 EXEC PGM=IRXJCL,TIME=5,DYNAMNBR=30,\n             //         PARM='GDGCOPY GDG.BASE.NAME.HERE TEST(O)'\n             //SYSEXEC  DD DISP=SHR,DSN=YOUR.SYSEXEC.LIBRARY\n             //SYSIN    DD DUMMY\n             //SYSPRINT DD SYSOUT=Z\n             //SYSTSPRT DD SYSOUT=*\n             //SYSUT2   DD DISP=(MOD,PASS),SPACE=(???,(###,##))\n\nEXEC History\n\n REXX EXEC Name: GDGCOPY\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 1.91\n                 FERGUSON AL (HUL2353)\n         Writen: 08NOV06\n        History: 06FEB17 - v2.01 - Update ERROR Handling routines\n                 14FEB11 - v1.85 - Fixes to BPXWDYN_ERR Reporting.\n                 21DEC10 - v1.84 - Miscelanious code cleanup.\n                 21MAY10 - v1.71 - First Working version!\n                 20MAY10 - v1.0\n***************************** Rexx ***********************************/\nARG GdgBase InParms                       /* Place arguments here    */\n\nSELECT\n  WHEN WORDPOS(GdgBase,'-h -H') > 0 THEN CALL DISPLAY_HELP\n  WHEN GdgBase = \"\"                 THEN DO\n     SAY  \" You must supply a GdgBase for %GDGCOPY!\"\n     EXIT 12\n    END\nOTHERWISE; CALL INITIALIZE_THIS_REXX; END\n/**********************************************************************\n              Initialize ERROR handling\n***********************************************************************/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     */\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT */\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  */\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO */\nTRACE (TEST)\n\nDO UNTIL RESUME \u00ac= 'Y'              /* SET UP FOR RESUME, IF NECESSARY */\n   ok='*';ADDRESS \"LINKPGM\" \"IGGCSI00 MODRSNRC CSIFIELD DWORK\"\n   IF RC \u00ac= 0 THEN CALL DISPLAY_IGGCSI_ERROR\n\n   RESUME = SUBSTR(CSIFIELD,150,1)  /* GET RESUME FLAG FOR NEXT LOOP   */\n   PARSE VALUE DWORK WITH . +4 . +4 CSIUSDLN +4 . +2 rest\n   rest=LEFT(rest, C2D(CSIUSDLN)-14)\n   /********************************************************************/\n   /*  PROCESS DATA RETURNED IN WORK AREA                              */\n   /********************************************************************/\n   DO WHILE LENGTH(rest) > 49         /* DO UNTIL ALL DATA IS PROCESSED*/\n      PARSE VALUE rest WITH . +1 CSICTYPE +1 CSICNAME +44 . +2 . +1 . +1 rest\n      SELECT\n        WHEN CSICTYPE = '0'     THEN ITERATE\n        WHEN LENGTH(rest) <= 49 THEN ITERATE\n        WHEN tmp = 0            THEN DO\n            tmp=1; DDLIST=\"SYSUT1\"\n            x=BPXWDYN(\"ALLOC DD(SYSUT1) DSN(\"STRIP(CSICNAME)\") OLD REUSE\")\n            IF x \u00ac= 0 THEN ExitError = BPXWDYN_ERR(x \"ALLOC\" CSICNAME)\n          END\n      OTHERWISE\n          tmp=tmp+1; DDLIST=DDLIST\",TMP\"tmp\n          x=BPXWDYN(\"ALLOC DD(TMP\"tmp\") DSN(\"STRIP(CSICNAME)\") OLD REUSE\")\n          IF x \u00ac= 0 THEN ExitError = BPXWDYN_ERR(x \"ALLOC\" CSICNAME)\n      END\n   END\nEND\n\nIF tmp > 0 THEN DO\n   ok='0'\n   x=BPXWDYN(\"CONCAT DDLIST(\"DDLIST\")\")\n   IF x = 0 THEN ADDRESS \"LINKMVS\" \"ICEGENER\"\n      ELSE ExitError=BPXWDYN_ERR(x \"CONCAT\" DDLIST)\n  END\nELSE ExitError=1\n\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  ValidParms = \"CATALOG() TEST(O)\"\n  MatchLength = 3      /* NP-Parms match on first # chars             */\n  AcceptAll = FALSE    /* Allow un-recognized NP-PARMS to be passed   */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  ExitError = 0\n  SYSMSGLVL1 = \"\"; SYSMSGLVL2 = \"\"\n  Lower = \"abcdefghijklmnopqrstuvwxyz\"\n  Upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        /* Initial variables used by IGGCSI interface                 */\n  MODRSNRC = LEFT(' ',4)              /* CLEAR MODULE/RETURN/REASON   */\n  CSIFILTK = LEFT(STRIP(GdgBase)'.*',44)\n  CSICATNM = LEFT(CATALOG,44)         /* CLEAR CATALOG NAME           */\n  CSIRESNM = LEFT(' ',44)             /* CLEAR RESUME NAME            */\n  CSIDTYPS = LEFT('H',16)             /* Get these entry types        */\n  CSICLDI  = ' '                      /* Indicate DATA and INDEX      */\n  CSIRESUM = LEFT(' ',1)              /* CLEAR RESUME FLAG            */\n  CSIS1CAT = LEFT(' ',1)              /* INDICATE SEARCH > 1 CATALOGS */\n  CSIOPTNS = LEFT(' ',1)              /* CLEAR RESERVE CHARACTER      */\n  CSINUMEN = X2C(RIGHT(D2X(0),4,'0'))\n  /********************************************************************/\n  /*  BUILD THE SELECTION CRITERIA FIELDS PART OF PARAMETER LIST      */\n  /********************************************************************/\n  CSIOPTS  = CSICLDI ||CSIRESUM||CSIS1CAT||CSIOPTNS\n  CSIFIELD = CSIFILTK||CSICATNM||CSIRESNM||CSIDTYPS||CSIOPTS||CSINUMEN\n  /********************************************************************/\n  /*  INITIALIZE AND BUILD WORK ARE OUTPUT PART OF PARAMETER LIST     */\n  /********************************************************************/\n  WORKLEN = 64000; CSIUSRLN = X2C(RIGHT(D2X(WORKLEN),8,'0'))\n  DWORK   = CSIUSRLN || COPIES('00'X,WORKLEN-4)\n\n  tmp = 0   /* Number of TMP DDs allocated (GDGs - 1)                 */\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/**********************************************************************\n      An error occured when calling IGGCSI00, dislay MODRSNRC, the\n         parms used to call it, and the WORK area returned.\n***********************************************************************/\nDISPLAY_IGGCSI_ERROR:\n  SAY  \"IGGCSI Error!  LINK RC=\"RC \"MOD=\"LEFT(MODRSNRC,2),\n       \"RSN=\"C2D(SUBSTR(MODRSNRC,3,1)) \"RC=\"C2D(SUBSTR(MODRSNRC,4,1))\n  SAY  \"_______________________ CSIFIELD ______________________\"\n  SAY  CSIFIELD\n  SAY  \"________________________ DWORK ________________________\"\n  SAY  DWORK\n  SAY  \"_______________________________________________________\"\nEXIT RC\n/**********************************************************************\n     Display BPXWDYN error information for non-zero Return Codes\n***********************************************************************/\nBPXWDYN_ERR:\nPARSE ARG BPXWDYN_rc arg2 arg3\n  SAY RIGHT(arg2,7) \"of:\" arg3\n  IF BPXWDYN_rc > 0 THEN DO\n     PARSE VALUE RIGHT(D2X(BPXWDYN_rc),8,\"0\") WITH dyn_EC 5 dyn_RC .\n     SAY RIGHT(arg2,7) \"RC:\" BPXWDYN_rc \"(\"dyn_EC dyn_RC\")\"\n    END\n  ELSE DO\n     dyn_EC = ABS(BPXWDYN_rc)\n     SAY RIGHT(arg2,7) \"RC:\" BPXWDYN_rc\n  END\n  IF SYMBOL(\"S99MSG.0\")=\"VAR\" THEN DO m=1 TO S99MSG.0;SAY \"  \"S99MSG.m;END\nRETURN dyn_EC\n/* COPY ERRMVS */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n                                                                        /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n  CALL MVS_ERROR_DISPLAY            /* Display collected error info   *//*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GDGCOPY#": {"ttr": 780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x05\\x01\\x08\\x19/\\x01\\x08\\x19\\x7f\\x10@\\x00\\x0c\\x00\\x0e\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2008-07-10T00:00:00", "modifydate": "2008-07-15T10:40:05", "lines": 12, "newlines": 14, "modlines": 0, "user": "AL-FERG"}, "text": "//GDGCOPY  PROC\n//*-------------------------------------------------------------------*\n//*   COPY GDG in correct order using CBT GDGCOPY Utility             *\n//*-------------------------------------------------------------------*\n//PROC0100 EXEC PGM=GDGCOPY,TIME=120,PARM='GDGBASE.TOBE.COPIED'\n//*\n//STEPLIB  DD DISP=SHR,DSN=SYS2.CBT.LOADLIB\n//SYSUT1   DD DCB=(DSORG=PS,RECFM=VBS,LRECL=32760,BLKSIZE=0)\n//SYSUT2   DD DISP=(MOD,PASS),UNIT=SORT,SPACE=(CYL,(100,50),RLSE),\n//            DCB=(DSORG=PS,RECFM=VBS,LRECL=32760,BLKSIZE=0)\n//*\n//GDGCOPY  PEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GDGCPROC": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00X\\x01\\x17$\\x1f\\x01\\x17%O\\x08X\\x00\\x0e\\x00\\x15\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2017-08-29T00:00:00", "modifydate": "2017-09-11T08:58:58", "lines": 14, "newlines": 21, "modlines": 0, "user": "AL-FERG"}, "text": "//*-------------------------------------------------------------------*\n//GDGCOPY  PROC GDGBASE='GDG_BASE_TO_COPY'\n//*-------------------------------------------------------------------*\n//PROC0100 EXEC PGM=IRXJCL,TIME=5,DYNAMNBR=30,\n//         PARM='GDGCOPY &GDGBASE TEST(O)'\n//*\n//SYSEXEC  DD DISP=SHR,DSN=&SYSUID..CBT.FILE789.PDS <=== %GDGCOPY LIVES\n//SYSIN    DD DUMMY\n//SYSPRINT DD SYSOUT=Z\n//SYSTSPRT DD SYSOUT=*\n//SYSUT2   DD DISP=(MOD,PASS),UNIT=SORT,SPACE=(CYL,(100,50),RLSE)\n//*-------------------------------------------------------------------*\n//GDGCOPY  PEND\n//*-------------------------------------------------------------------*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JCLSCRTL": {"ttr": 1027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00&\\x01\\x08\\x19/\\x01\\x08\\x19o!\\x14\\x00\\x10\\x00\\x10\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2008-07-10T00:00:00", "modifydate": "2008-07-14T21:14:26", "lines": 16, "newlines": 16, "modlines": 0, "user": "AL-FERG"}, "text": "//job_name JOB (DGP,MAIN),'SCRT Tool LinkEdit',\n//         CLASS=2,MSGCLASS=K,MSGLEVEL=(1,1),\n//         NOTIFY=user_id,PRTY=2\n//*\n//LKED     EXEC PGM=IEWBLINK,\n//         PARM=(MAP,LET,LIST,NCAL,XREF,RENT,REUS)\n//*\n//SYSLMOD  DD DISP=SHR,DSN=dataset.to.place.SCRTTOOL.module\n//SYSLIN   DD DATA,DLM=@@\n  Object Code from IBM Goes here\n  NAME SCRTTOOL(R)\n@@\n//SYSOUT   DD SYSOUT=*,OUTLIM=999999\n//SYSPRINT DD SYSOUT=*,OUTLIM=999999\n//SYSUT1   DD UNIT=3390,SPACE=(CYL,(1,1))\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JCLSCRTM": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01 \\x00X\\x01\\x06(?\\x01\\x17%O\\x08X\\x00T\\x01\\r\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.32", "flags": 0, "createdate": "2006-10-10T00:00:00", "modifydate": "2017-09-11T08:58:58", "lines": 84, "newlines": 269, "modlines": 0, "user": "AL-FERG"}, "text": "//job_name JOB (DGP,MAIN),'eMail SCRT Tool Rpt',\n//         MSGLEVEL=(1,1),PRTY=5,\n//         CLASS=1,MSGCLASS=K,NOTIFY=user_id\n//*===================================================================*\n//*     RESTART FROM THE BEGINNING OF THE JOB                         *\n//*===================================================================*\n//         JCLLIB ORDER=(&SYSUID..CBT.FILE789.PDS)\n//*===================================================================*\n//*  Create SMF DUMP Utility Parms for Last Month's MULC Data         *\n//*===================================================================*\n//STEP0100 EXEC PGM=IRXJCL,PARM='SMFPARM LASTMONTH TEST(O)'\n//*\n//SYSEXEC  DD DISP=SHR,DSN=&SYSUID..CBT.FILE789.PDS\n//SYSTSPRT DD SYSOUT=*,OUTLIM=999999\n//SMFDPARM DD DISP=(NEW,PASS),UNIT=VIO,SPACE=(TRK,(15,15)),\n//            DCB=(DSORG=PS,RECFM=FB,LRECL=80,BLKSIZE=0)\n//*===================================================================*\n//*  Gather up the Type 70 & 89 SMF Records for each zOS Image        *\n//*===================================================================*\n//STEP0200 EXEC GDGCOPY,PARM.PROC0100='SYSD.SMF.SYSA.DAILY.MULC'\n//STEP0210 EXEC GDGCOPY,PARM.PROC0100='SYSD.SMF.SYSB.DAILY.MULC'\n//STEP0220 EXEC GDGCOPY,PARM.PROC0100='SYSD.SMF.SYSC.DAILY.MULC'\n//*===================================================================*\n//*  Merge the Image MULC DSNs into a single date-time sorted file    *\n//*===================================================================*\n//STEP0300 EXEC PGM=SORT,TIME=15,REGION=96M\n//*\n//DFMSGOUT DD SYSOUT=*,OUTLIM=999999\n//SORTIN   DD DISP=(OLD,DELETE),DSN=*.STEP0200.PROC0100.SYSUT2\n//         DD DISP=(OLD,DELETE),DSN=*.STEP0210.PROC0100.SYSUT2\n//         DD DISP=(OLD,DELETE),DSN=*.STEP0220.PROC0100.SYSUT2\n//SORTOUT  DD DISP=(NEW,PASS),UNIT=SORT,SPACE=(CYL,(75,10),RLSE),\n//            DCB=(DSORG=PS,RECFM=VBS,LRECL=32760,BLKSIZE=0)\n//SYSIN    DD DISP=SHR,DSN=&SYSUID..CBT.FILE789.PDS(SCRTMP01)\n//SYSOUT   DD SYSOUT=*,OUTLIM=999999\n//*===================================================================*\n//*  Extract out only Last Month's Type 70 & 89 SMF Records           *\n//*===================================================================*\n//STEP0400 EXEC PGM=IFASMFDP,REGION=96M,TIME=10\n//*\n//SYSIN    DD DISP=SHR,DSN=&SYSUID..CBT.FILE789.PDS(SCRTMP02)\n//         DD DISP=(OLD,DELETE),DSN=*.STEP0100.SMFDPARM\n//SYSPRINT DD SYSOUT=M,OUTLIM=9999999\n//INPUT    DD DISP=(OLD,DELETE),DSN=*.STEP0300.SORTOUT\n//OUTPUT   DD DISP=(NEW,PASS),UNIT=SORT,SPACE=(CYL,(75,10),RLSE),\n//            DCB=(DSORG=PS,RECFM=VBS,LRECL=32760,BLKSIZE=0)\n//*===================================================================*\n//*  Run IBM's Sub-Capacity Reporting Tool                            *\n//*===================================================================*\n//STEP0500 EXEC PGM=SCRTTOOL,TIME=15\n//*\n//STEPLIB  DD DISP=SHR,DSN=dataset.to.place.SCRTTOOL.module\n//SMF      DD DISP=(OLD,DELETE),DSN=*.STEP0400.OUTPUT\n//NO89     DD DISP=SHR,DSN=&SYSUID..CBT.FILE789.PDS(SCRTMP03)\n//OUTPUT   DD DISP=(NEW,PASS),UNIT=VIO,SPACE=(TRK,(15,15)),\n//            DCB=(DSORG=PS,RECFM=VB,LRECL=1028,BLKSIZE=0)\n//PARMS    DD DISP=SHR,DSN=&SYSUID..CBT.FILE789.PDS(SCRTMP04)\n//SYSPRINT DD DISP=(NEW,PASS),UNIT=VIO,SPACE=(TRK,(15,15))\n//*===================================================================*\n//*  Create a MIME based eMail and send the SCRT Report Attachment    *\n//*===================================================================*\n//STEP0600 EXEC PGM=IRXJCL,TIME=5,COND=(8,LE,STEP0500),\n//         PARM='SCRTML NAR(Y) TEST(O)'\n//*        PARM='SCRTML NAR(Y) SERVER(localhost) TEST(O)'\n//*        PARM='SCRTML NAR(Y) SERVER(127.0.0.1) TEST(O)'\n//*\n//SYSEXEC  DD DISP=SHR,DSN=&SYSUID..CBT.FILE789.PDS\n//SYSTSPRT DD SYSOUT=*,OUTLIM=999999\n//*\n//*        DDS USED BY REXX\n//*\n//EMBODY   DD DISP=(OLD,PASS),DSN=*.STEP0500.SYSPRINT\n//EMCNTL   DD DISP=SHR,DSN=&SYSUID..CBT.FILE789.PDS(SCRTMP05)\n//SCRTRPT  DD DISP=(OLD,DELETE),DSN=*.STEP0500.OUTPUT\n//*===================================================================*\n//*  Copy the SCRTTOOL Utility SYSPRINT to SYSOUT for Archiving       *\n//*===================================================================*\n//STEP0700 EXEC PGM=IEBGENER,COND=EVEN\n//*\n//SYSIN    DD DUMMY\n//SYSPRINT DD SYSOUT=*,OUTLIM=999999\n//SYSUT1   DD DISP=(OLD,DELETE),DSN=*.STEP0500.SYSPRINT\n//SYSUT2   DD SYSOUT=M,OUTLIM=999999\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JCLSENDM": {"ttr": 1032, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1f\\x00X\\x01\\x06(?\\x01\\x17%O\\x08X\\x000\\x01\\r\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.31", "flags": 0, "createdate": "2006-10-10T00:00:00", "modifydate": "2017-09-11T08:58:58", "lines": 48, "newlines": 269, "modlines": 0, "user": "AL-FERG"}, "text": "//job_name JOB (DGP,MAIN),'SENDMAIL RXSOCKET',\n//         MSGLEVEL=(1,1),PRTY=5,\n//         CLASS=1,MSGCLASS=K,NOTIFY=user_id\n//*===================================================================*\n//*  Create a MIME based eMail w/attachment and send via SMTP         *\n//*===================================================================*\n//STEP0100 EXEC PGM=IRXJCL,TIME=5,\n//         PARM='SENDMAIL NAR(Y) TEST(O)'\n//*        PARM='SENDMAIL NAR(Y) SERVER(localhost) TEST(O)'\n//*        PARM='SENDMAIL NAR(Y) SERVER(127.0.0.1) TEST(O)'\n//*\n//STEPLIB  DD DISP=SHR,DSN=SYS2.CBT.LOADLIB     <=== ENCODE64\n//SYSEXEC  DD DISP=SHR,DSN=&SYSUID..CBT.FILE789.PDS\n//SYSTSPRT DD SYSOUT=*,OUTLIM=999999\n//*\n//*        DDS USED BY REXX\n//*\n//IKJTSO00 DD DISP=SHR,DSN=SYS1.PARMLIB(IKJTSO00)\n//LPALST00 DD DISP=SHR,DSN=SYS1.PARMLIB(LPALST00)\n//EMBODY   DD DATA,DLM=@@\nThis is a test message using the REXX RXSOCKET API vs the USS\n/usr/bin/sendmail command.\n\nThis is the text of the message. It should also have two attachments:\n     ikjtso.txt - SYS1.PARMLIB(IKJTSO00)\n     lpalst.txt - SYS1.PARMLIB(LPALST00)\n\nThis should also have a signature at the end.\n@@\n//EMCNTL   DD DATA,DLM=@@\nFrom: YourEmailAddress@your_domain.com\nTo: YourEmailAddress@your_domain.com\nSubject: Testing RXSOCKET API SMTP Email.\nComment: RXSOCKET API for SMTP Email comment enbedded in header.\nAttachment: SIGNATUR inline\nAttachment: IKJTSO00 plain ikjtso.txt\nAttachment: LPALST00 plain lpalst.txt\n@@\n//SIGNATUR DD DATA,DLM=@@\n\n_______________\n\nYour Full Name     | mailto:YourEmailAddress@your_domain.com\nTechnical Support  |  phone: ###-###-####\nYour Comany Name   |    fax: ###-###-####\nSuite 1234\n@@\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REXXEPNL": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00P\\x00\\x95#o\\x01\\x08\\x19\\x7f\\x10A\\x00!\\x00%\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1995-08-24T00:00:00", "modifydate": "2008-07-15T10:41:50", "lines": 33, "newlines": 37, "modlines": 0, "user": "AL-FERG"}, "text": ")ATTR\n  @ TYPE(INPUT)  INTENS(LOW)  CAPS(ON)   JUST(LEFT)\n  ! TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF)  COLOR(TURQ)\n  \u00a2 TYPE(OUTPUT) INTENS(LOW)  CAPS(OFF)\n  \u00ac TYPE(TEXT)   INTENS(HIGH) COLOR(YELLOW)\n  # TYPE(TEXT)   INTENS(HIGH) COLOR(RED) HILITE(USCORE)\n  $ TYPE(TEXT)   INTENS(LOW)  CAPS(OFF)  COLOR(TURQ)\n  % TYPE(TEXT)   INTENS(HIGH)\n  + TYPE(TEXT)   INTENS(LOW)\n)BODY EXPAND(||) WIDTH(&ZSCREENW)\n%|-| REXX ERROR Reporting Panel |-|\n%COMMAND ===>@ZCMD\n\u00ac| | An#ERROR\u00achas occurred in REXX!erexx   +| |\n\u00ac| |Please do a SCREEN PRINT, write down what you were doing, and | |\n\u00ac| |then contact Product Support http://your.intranet.com/site.htm| |\n+\n$        Error Type:\u00a2etype\n$       Error Cause:\u00a2ecause\n$                RC:\u00a2erc\n$ Error Description:\u00a2emsg\n\n$       Source Line:\u00a2elineno\n$   Source reads as:\u00a2sourcel\n\n$Source EXECutes as:\u00a2expandl\n\n$    Stack Contents:\u00a2eresults\n\n\n+Press%END+to exit\n)INIT\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RHELP02": {"ttr": 1036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\"\\x00\\x93\\x17_\\x01\\x02\\x05\\x0f\\x15\\x03\\x00\\x11\\x00\\x11\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-06-24T00:00:00", "modifydate": "2002-02-19T15:03:22", "lines": 17, "newlines": 17, "modlines": 0, "user": "AL-FERG"}, "text": ")ATTR\n\u00a2 TYPE(OUTPUT) INTENS(LOW) CAPS(OFF)\n_ TYPE(INPUT)  INTENS(HIGH) CAPS(OFF)\n\u00ac TYPE(TEXT)   INTENS(HIGH) COLOR(YELLOW)\n$ TYPE(TEXT)   INTENS(HIGH) COLOR(TURQ)\n)BODY EXPAND(||)\n%|-|\u00acREXX Help Display%|-|\n%COMMAND ===>_ZCMD | | %SCROLL ===>_Z   +\n\u00ac\n+Enter$END+to exit$| | &rname | |+Scroll$UP+or$DOWN\n+\n)MODEL\n\u00a2source\n)INIT\n  .HELP   = RHELP04\n  .ZVARS = '(ZSCBR)'\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SCRTML": {"ttr": 1038, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x1b\\x00Y\\x01\\x08\\x12o\\x01\\x17$\\x1f\\tP\\x03\\x14\\x01J\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "02.27", "flags": 0, "createdate": "2008-05-05T00:00:00", "modifydate": "2017-08-29T09:50:59", "lines": 788, "newlines": 330, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX is used to send the monthly SCRT.csv file (Sub-Capacity\n      Reporting Tool) to those that will deliver it to IBM. This uses\n      RXSOCKET vs the USS /usr/bin/sendmail command. This allows the\n      manipulations of additional SMTP Headers not available when\n      using sendmail.\n\n This REXX does NOT Require TSO, it will run in batch under IRXJCL.\n\n To BASE64 encoding requires access to ENCODE64 REXX Function:\n       http://www.homerow.net/asm/index.htm\n\n                           --- EXAMPLE ---\nIRXJCL SCRTML <EM_DOM(@default_email_domain)>                        ,\n              <IMPORT(Normal|High|Low)> <NAR(Y|N)> <PORT(smtp_port)> ,\n              <SERVER(server_dns_name)> <TEST(TraceOption)>\nTSO <%>SCRTML <EM_DOM(@default_email_domain)>                        ,\n              <IMPORT(Normal|High|Low)> <NAR(Y|N)> <PORT(smtp_port)> ,\n              <SERVER(server_dns_name)> <TEST(TraceOption)>\nTSO <%>SCRTML -H -- To display help for this REXX\n\n  Arguments: InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                  EM_DOM - Default Email Domain to add to email address\n                           default: @YourDomain.com\n                  IMPORT - Message Importance       default: Normal\n                     NAR - Use 'nar' addition.      default: Y\n                    PORT - SMTP Server Port Number. default: DEFAULT\n                  SERVER - SMTP Server DNS Name.    default: DEFAULT\n                    TEST - Used to control traces.\n\n      Files: EMCNTL - Pre-Allocated EMail Control DD (see PARMs below)\n             EMBODY - Pre-Allocated EMail Body DD\n             ?????? - Pre-Allocated EMail Attachments DDs as defined in\n                      EMail Control DD\n PARM NOTEs: You must set the FROM and RECEIVED PARMs to the same eMail\n                 address to work with IBM's Automated LMS eMail system.\n             This eMail address also must: Be 32 charactors or less.  Be\n                 the same as the IBM Account name of a register LMS User.\n             These are limitations imposed by IBM's process.\n      PARMs: *        - In column 1 indicates a comment.\n             From     - eMail address in message From field.\n             Received - Used in SMTP header to trace path of a message\n                        from its source to its destination.\n             Reply-to - eMail address used when user does a REPLY, if\n                        different then the From address.\n             To       - Primary eMail receipients.\n             Cc       - Carbon Copy eMail receipients.\n             Bcc      - Blind Carbon Copy eMail receipients.\n             Subject  - eMail one line subject.\n             Comment  - Comment embedded in eMail header information.\n             Import   - Set eMail Importance:  Normal, High, or Low.\n             Attach   - Attachment file information:  DD_name, MIME\n                        Content-type, and file name.\nOther EXECS: None\n\nEXEC History\n\n REXX EXEC Name: SCRTML\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 2.08\n                 Al Ferguson (HUL2353)\n         Writen: 03JUL08\n        History: 06FEB17 - v2.10 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v2.09 - Mass update to Error Handling Fixes.\n                 24FEB11 - v2.01 - Changes to use base REXX DATE\n                           Function capabilities vs external REXX EXEC.\n                 09JUL08 - v1.74 - Convert to use common SOCKMAIL\n                           COPYCODE procedures.\n                 09JUL08 - v1.68 - Fix Socket Error handling and\n                           handle PORT(DEFAULT) or PORT() when the SERVER\n                           is passed.\n                 08JUL08 - v1.62 - Cleanup Mime headers and reduce\n                           CALLs to RXSOCKET. Ensure RANDOM returns valid\n                           values to pick random letters properly.\n                 07JUL08 - v1.57 - Ensure SOCKET ERROR RC is used\n                           for exit_error so RC is correct. Also, pass\n                           line number and line source for command in\n                           error.\n                 07JUL08 - v1.51 - Updates to SMTP HELO to use\n                           the Server DNS vs the \"SMTP\" string. Cleanup\n                           to remove any TSO Dependencies, this will now\n                           work under IRXJCL. Add a End-of-MIME\n                           indicater to the CLOSE_EMAIL Procedure.\n                 03JUL08 - v1.43 - Fixes to Time Offset and\n                           \"Received:\" output.\n                 03JUL08 - v1.41 - Tweaked version of PORT Based\n                           SNMP REXX to send SCRT Tool Reports to IBM.\n                           This has been updated to handle a number of\n                           SNMP mail headers un-available when using the\n                           /usr/bin/sendmail USS program.\n                 03JUL08 - v1.00\n***************************** Rexx ***********************************/\nPARSE ARG InParms                            /* Place arguments here */\n\nIF WORDPOS(InParms,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nCALL GET_EMAIL_CNTL\n      /* Insert SCRT Report Month into eMail Subject Line            */\nPARSE VALUE STRIP(_subject_) WITH before \"&month\" after\n_subject_ = before last_month last_year after\n\nCALL INIT_SMTP_SOCKET\n  CALL EMAIL_HEADER\n  CALL EMAIL_BODY\n  CALL EMAIL_ATTACHMENTS\n  CALL CLOSE_EMAIL\nCALL CLOSE_SMTP_SOCKET\n\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  ValidParms = \"EM_DOM(@YourDomain.com) SERVER(DEFAULT)\",\n                \"IMPORT() NAR(Y) PORT(DEFAULT) TEST(O)\"\n  MatchLength=3        /* NP-Parms match on first # chars             */\n  AcceptAll=FALSE      /* Allow un-recognized NP-PARMS to be passed   */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  SYSUID = USERID()\n  ExitError = 0\n  Lower=\"abcdefghijklmnopqrstuvwxyz\"; Upper=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  letters = Lower || Upper\n  PARSE SOURCE . . rname .          /* Get REXX EXEC name             */\n  jname = MVSVAR(\"SYMDEF\",\"JOBNAME\")\n\n  months = \"January February March April May June July August\",\n           \"September October November December\"\n  this_month = DATE(\"M\"); last_year  = LEFT(DATE(\"S\"),4)\n  IF ABBREV(this_month, \"January\") THEN DO\n       last_month=\"December\"\n       last_year =last_year-1\n     END\n  ELSE last_month=WORD(months, WORDPOS(this_month,months)-1)\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SOCKMAIL */\n/* COPY MAILCNTL */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n     Read eMail Header and Control information,then parse it, and       /*COPY*/\n           build stings for SMTP Header commands.                       /*COPY*/\n                                                                        /*COPY*/\n  The structure of the em. STEM Varaible used here and passed via the   /*COPY*/\n      STEMPUSH & STEMPULL REXX Functions.                               /*COPY*/\n    em. = \"\"                                                            /*COPY*/\n    em.hdr.to.0 = 0; em.hdr.cc.0 = 0; em.hdr.bc.0 = 0; em.hdr.rep.0 = 0 /*COPY*/\n    em.hdr.to.# = \u00dd<email@domain> | name <email@domain>\u00a8                /*COPY*/\n    em.hdr.cc.# = \u00dd<email@domain> | name <email@domain>\u00a8                /*COPY*/\n    em.hdr.bc.# = \u00dd<email@domain> | name <email@domain>\u00a8                /*COPY*/\n    em.hdr.fm   = \u00dd<email@domain> | name <email@domain>\u00a8                /*COPY*/\n    em.hdr.sub  = \"\"               /* Email Subject line              *//*COPY*/\n    em.hdr.com  = \"\"               /* Hidden Header comment           *//*COPY*/\n    em.hdr.imp  = \u00ddN | H | L\u00a8      /* Email Importance                *//*COPY*/\n    em.hdr.rec  = email@domain     /* SMTP Received from address      *//*COPY*/\n    em.hdr.rep.# = \u00dd<email@domain> | name <email@domain>\u00a8 /* Reply-To *//*COPY*/\n    em.atch.0     = #              /* Number of attachments           *//*COPY*/\n    em.atch.#.dat = \"\"             /* Attachment file date (optional) *//*COPY*/\n    em.atch.#.fnm = \"\"             /* Attachment filename             *//*COPY*/\n    em.atch.#.typ = \u00ddPLAIN | OCTET-STREAM | INLINE | BASE64\u00a8            /*COPY*/\n    em.body.0   = #                /* Number of records in email body *//*COPY*/\n***********************************************************************//*COPY*/\nGET_EMAIL_CNTL:                                                         /*COPY*/\n  ok_to = \"postmaster POSTMASTER MAILER-DAEMON\"                         /*COPY*/\n  crlf = X2C(\"0D25\"); tab = X2C(\"05\")                                   /*COPY*/\n  dte = LEFT(DATE(\"W\"),3)\",\" DATE(\"N\") TIME(\"N\")                        /*COPY*/\n  _os_ = MVSVAR(\"SYMDEF\",\"LHHMMSS\") - MVSVAR(\"SYMDEF\",\"HHMMSS\")         /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN LENGTH(_os_) = 5 THEN dte = dte \"+0\"LEFT(_os_,3)               /*COPY*/\n    WHEN LENGTH(_os_) = 7 THEN dte = dte LEFT(_os_,5)                   /*COPY*/\n    WHEN ABBREV(_os_,\"-\") THEN dte = dte \"-0\"SUBSTR(_os_,2,3)           /*COPY*/\n  OTHERWISE;                   dte = dte \"+\"LEFT(_os_,4); END           /*COPY*/\n  mid = SUBSTR(letters,RANDOM(51)+1,1)||DATE(\"B\") ,                     /*COPY*/\n     || SUBSTR(letters,RANDOM(51)+1,1)            ,                     /*COPY*/\n     || SUBSTR(letters,RANDOM(51)+1,1)            ,                     /*COPY*/\n     || SUBSTR(letters,RANDOM(51)+1,1)            ,                     /*COPY*/\n     || SUBSTR(letters,RANDOM(51)+1,1)||TIME(\"S\")                       /*COPY*/\n  PARSE SOURCE . . rname .               /* Get REXX EXEC name        *//*COPY*/\n  jname = MVSVAR(\"SYMDEF\",\"JOBNAME\")     /* Get Job Name              *//*COPY*/\n  mbound = \"USER=\"SYSUID\";JOB=\"jname\";REXX=\"rname\";\"mid                 /*COPY*/\n  em. = \"\"; em.atch.0 = 0; em.body.0 = 0                                /*COPY*/\n  em.hdr.to.0 = 0; em.hdr.cc.0 = 0; em.hdr.bc.0 = 0; em.hdr.rep.0 = 0   /*COPY*/\n                                                                        /*COPY*/\n  IF TOKEN = \"\" THEN DO                                                 /*COPY*/\n    ADDRESS \"MVS\" \"EXECIO * DISKR EMCNTL (STEM _emcntl_. FINIS\"         /*COPY*/\n    DO i = 1 TO _emcntl_.0                                              /*COPY*/\n       PARSE VALUE _emcntl_.i WITH keyword \": \" _rest_                  /*COPY*/\n       UPPER keyword; _rest_ = STRIP(_rest_)                            /*COPY*/\n       SELECT                                                           /*COPY*/\n         WHEN ABBREV(keyword,\"*\")        THEN ITERATE i                 /*COPY*/\n         WHEN ABBREV(keyword,\"TO\")       THEN DO                        /*COPY*/\n            k = 1 + em.hdr.to.0; em.hdr.to.0 = k                        /*COPY*/\n            SELECT                                                      /*COPY*/\n              WHEN WORDPOS(_rest_,ok_to) THEN em.hdr.to.k = _rest_      /*COPY*/\n              WHEN ABBREV(_rest_,\"<\")    THEN em.hdr.to.k = _rest_      /*COPY*/\n              WHEN INDEX(_rest_,\"@\") > 0 THEN em.hdr.to.k = \"<\"_rest_\">\"/*COPY*/\n            OTHERWISE; em.hdr.to.k = \"<\"_rest_||EM_DOM\">\"; END          /*COPY*/\n           END                                                          /*COPY*/\n         WHEN ABBREV(keyword,\"CC\")       THEN DO                        /*COPY*/\n            k = 1 + em.hdr.cc.0; em.hdr.cc.0 = k                        /*COPY*/\n            SELECT                                                      /*COPY*/\n              WHEN ABBREV(_rest_,\"<\")    THEN em.hdr.cc.k = _rest_      /*COPY*/\n              WHEN INDEX(_rest_,\"@\") > 0 THEN em.hdr.cc.k = \"<\"_rest_\">\"/*COPY*/\n            OTHERWISE; em.hdr.cc.k = \"<\"_rest_||EM_DOM\">\"; END          /*COPY*/\n           END                                                          /*COPY*/\n         WHEN ABBREV(keyword,\"BCC\")      THEN DO                        /*COPY*/\n            k = 1 + em.hdr.bc.0; em.hdr.bc.0 = k                        /*COPY*/\n            SELECT                                                      /*COPY*/\n              WHEN ABBREV(_rest_,\"<\")    THEN em.hdr.bc.k = _rest_      /*COPY*/\n              WHEN INDEX(_rest_,\"@\") > 0 THEN em.hdr.bc.k = \"<\"_rest_\">\"/*COPY*/\n            OTHERWISE; em.hdr.bc.k = \"<\"_rest_||EM_DOM\">\"; END          /*COPY*/\n           END                                                          /*COPY*/\n         WHEN ABBREV(keyword,\"FROM\")     THEN SELECT                    /*COPY*/\n             WHEN ABBREV(_rest_, \"<\")    THEN em.hdr.fm = _rest_        /*COPY*/\n             WHEN ABBREV(_rest_, \"'\")    THEN em.hdr.fm = _rest_        /*COPY*/\n             WHEN INDEX(_rest_, \"@\") > 0 THEN em.hdr.fm = \"<\"_rest_\">\"  /*COPY*/\n           OTHERWISE; em.hdr.fm = \"<\"_rest_||EM_DOM\">\"; END             /*COPY*/\n         WHEN ABBREV(keyword,\"RECEIVED\") THEN DO                        /*COPY*/\n             PARSE VALUE _rest_ WITH sid \"@\" domain .                   /*COPY*/\n             IF domain = \"\" THEN domain = EM_DOM                        /*COPY*/\n             em.hdr.ret = STRIP(sid\"@\"domain)                           /*COPY*/\n             em.hdr.rec = \"From\" sid \"at\" domain \"with SMTP id\",        /*COPY*/\n                          mid\";\"crlf||tab dte                           /*COPY*/\n           END                                                          /*COPY*/\n         WHEN ABBREV(keyword,\"REPLY\")    THEN DO                        /*COPY*/\n            k = 1 + em.hdr.rep.0; em.hdr.rep.0 = k                      /*COPY*/\n            SELECT                                                      /*COPY*/\n              WHEN ABBREV(_rest_,\"<\")    THEN em.hdr.rep.k=_rest_       /*COPY*/\n              WHEN INDEX(_rest_,\"@\") > 0 THEN em.hdr.rep.k=\"<\"_rest_\">\" /*COPY*/\n            OTHERWISE; em.hdr.rep.k = \"<\"_rest_||EM_DOM\">\"; END         /*COPY*/\n           END                                                          /*COPY*/\n         WHEN ABBREV(keyword,\"SUBJECT\")  THEN em.hdr.sub = STRIP(_rest_)/*COPY*/\n         WHEN ABBREV(keyword,\"COMMENT\")  THEN em.hdr.com = _rest_       /*COPY*/\n         WHEN ABBREV(keyword,\"IMPORT\")   &,                             /*COPY*/\n              em.hdr.imp = \"\"            THEN em.hdr.imp = _rest_       /*COPY*/\n         WHEN ABBREV(keyword,\"ATTACH\")   THEN DO                        /*COPY*/\n             k = 1 + em.atch.0; em.atch.0 = k                           /*COPY*/\n             PARSE UPPER VALUE _rest_ WITH em.atch.k.dd em.atch.k.typ . /*COPY*/\n             em.atch.k.fnm = WORD(_rest_,3)                             /*COPY*/\n           END                                                          /*COPY*/\n       OTHERWISE; NOP; END                                              /*COPY*/\n    END                                                                 /*COPY*/\n  END                                                                   /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     rc = STEMPULL(TOKEN,\"DELETE\")                                      /*COPY*/\n     IF em.hdr.rec \u00ac= \"\" THEN DO                                        /*COPY*/\n        IF INDEX(em.hdr.rec, \"@\") > 0 THEN                              /*COPY*/\n                 PARSE VALUE em.hdr.rec WITH sid \"@\" domain .           /*COPY*/\n        ELSE DO; sid = em.hdr.rec; domain = EM_DOM; END                 /*COPY*/\n        em.hdr.ret = em.hdr.rec                                         /*COPY*/\n        em.hdr.rec = \"From\" sid \"at\" domain \"with SMTP id\",             /*COPY*/\n                     mid\";\"crlf||tab dte                                /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                           /* Set email importance level      *//*COPY*/\n    WHEN ABBREV(em.hdr.imp, \"N\") THEN em.hdr.imp = \"Normal\"             /*COPY*/\n    WHEN ABBREV(em.hdr.imp, \"H\") THEN em.hdr.imp = \"High\"               /*COPY*/\n    WHEN ABBREV(em.hdr.imp, \"L\") THEN em.hdr.imp = \"Low\"                /*COPY*/\n  OTHERWISE; em.hdr.imp = \"Normal\"; END                                 /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MAILBODY */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Read in and then Send eMail Body using inline MIME format.        /*COPY*/\n***********************************************************************//*COPY*/\nEMAIL_BODY:                                  /* Get eMail Body        *//*COPY*/\n  IF TOKEN = \"\" THEN                                                    /*COPY*/\n     ADDRESS \"MVS\" \"EXECIO * DISKR EMBODY (STEM em.body. FINIS\"         /*COPY*/\n  IF em.body.0 = 0 THEN RETURN               /* No body to add        *//*COPY*/\n                                             /* Add body MIME Header  *//*COPY*/\n  sm = SOCKET(\"WRITE\",_sid,crlf||'--'mbound||crlf)                      /*COPY*/\n  IF ABBREV(SYMBOL(\"EM_TYPE\"),\"VAR\") & ABBREV(EM_TYPE,\"HTML\") THEN      /*COPY*/\n       sm = SOCKET(\"WRITE\",_sid,'Content-Type: text/html;',             /*COPY*/\n                                'charset=\"ISO-8859-1\"'crlf)             /*COPY*/\n  ELSE sm = SOCKET(\"WRITE\",_sid,'Content-Type: text/plain;',            /*COPY*/\n                                'charset=\"ISO-8859-1\"'crlf)             /*COPY*/\n  sm = SOCKET(\"WRITE\",_sid,'Content-Transfer-Encoding: 7bit'crlf||crlf) /*COPY*/\n  /* Add eMail Body Text                                              *//*COPY*/\n  DO i = 1 TO em.body.0; sm = SOCKET(\"WRITE\",_sid,em.body.i||crlf); END /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MAILATCH */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n Read any MIME Attachments identified in the EMCNTL, set MIME Header,   /*COPY*/\n      ENCODE when necessary, and then write as MIME Attachment.         /*COPY*/\n***********************************************************************//*COPY*/\nEMAIL_ATTACHMENTS:                                                      /*COPY*/\n  DO k = 1 TO em.atch.0                                                 /*COPY*/\n      IF TOKEN = \"\" THEN ADDRESS \"MVS\",                                 /*COPY*/\n         \"EXECIO * DISKR\" em.atch.k.dd \"(STEM em.atch.\"k\". FINIS\"       /*COPY*/\n      IF em.atch.k.0 = 0    THEN ITERATE k  /* Empty Attachement      *//*COPY*/\n      IF em.atch.k.dat = \"\" THEN em.atch.k.dat = dte                    /*COPY*/\n      SELECT                                /* Add MIME Type info     *//*COPY*/\n        WHEN ABBREV(\"PLAIN\", em.atch.k.typ) THEN DO                     /*COPY*/\n           MimeHeader = crlf'--'mbound || crlf,                         /*COPY*/\n              ||'Content-Type: text/plain; name=\"'em.atch.k.fnm'\"'crlf, /*COPY*/\n              ||'Content-Disposition: attachment; ',                    /*COPY*/\n              ||        'filename=\"'em.atch.k.fnm'\"; ',                 /*COPY*/\n              ||        'modification-date=\"'em.atch.k.dat'\"'crlf,      /*COPY*/\n              ||'Content-Transfer-Encoding: 7bit'crlf                   /*COPY*/\n           sm = SOCKET(\"WRITE\",_sid,MimeHeader||crlf)                   /*COPY*/\n           DO j = 1 TO em.atch.k.0          /* Add Attachment file    *//*COPY*/\n              sm = SOCKET(\"WRITE\",_sid,em.atch.k.j||crlf)               /*COPY*/\n           END                                                          /*COPY*/\n          END                                                           /*COPY*/\n        WHEN ABBREV(\"HTML\", em.atch.k.typ)  THEN DO                     /*COPY*/\n           MimeHeader = crlf'--'mbound || crlf,                         /*COPY*/\n              ||'Content-Type: text/html; name=\"'em.atch.k.fnm'\"'crlf,  /*COPY*/\n              ||'Content-Disposition: attachment; ',                    /*COPY*/\n              ||        'filename=\"'em.atch.k.fnm'\"; ',                 /*COPY*/\n              ||        'modification-date=\"'em.atch.k.dat'\"'crlf,      /*COPY*/\n              ||        'charset=iso-8859-1'crlf                        /*COPY*/\n           sm = SOCKET(\"WRITE\",_sid,MimeHeader||crlf)                   /*COPY*/\n           DO j = 1 TO em.atch.k.0          /* Add Attachment file    *//*COPY*/\n              sm = SOCKET(\"WRITE\",_sid,em.atch.k.j||crlf)               /*COPY*/\n           END                                                          /*COPY*/\n          END                                                           /*COPY*/\n        WHEN ABBREV(\"OCTET-STREAM\", em.atch.k.typ) THEN DO              /*COPY*/\n           MimeHeader = crlf'--'mbound || crlf,                         /*COPY*/\n              ||'Content-Type: application/octet-stream; ',             /*COPY*/\n              ||              'name=\"'em.atch.k.fnm'\"'crlf,             /*COPY*/\n              ||'Content-Disposition: attachment; ',                    /*COPY*/\n              ||        'filename=\"'em.atch.k.fnm'\"; ',                 /*COPY*/\n              ||        'modification-date=\"'em.atch.k.dat'\"'crlf,      /*COPY*/\n              ||'Content-Transfer-Encoding: 7bit'crlf                   /*COPY*/\n           sm = SOCKET(\"WRITE\",_sid,MimeHeader||crlf)                   /*COPY*/\n           DO j = 1 TO em.atch.k.0          /* Add Attachment         *//*COPY*/\n              sm = SOCKET(\"WRITE\",_sid,em.atch.k.j||crlf)               /*COPY*/\n           END                                                          /*COPY*/\n          END                                                           /*COPY*/\n        WHEN k=1 & ABBREV(\"INLINE\", em.atch.k.typ) THEN,                /*COPY*/\n          DO j = 1 TO em.atch.k.0                                       /*COPY*/\n            sm = SOCKET(\"WRITE\",_sid,em.atch.k.j||crlf)                 /*COPY*/\n          END                                                           /*COPY*/\n        WHEN ABBREV(\"INLINE\", em.atch.k.typ)       THEN DO              /*COPY*/\n           MimeHeader = crlf'--'mbound || crlf,                         /*COPY*/\n              ||'Content-Type: text/plain; charset=\"ISO-8859-1\"'crlf,   /*COPY*/\n              ||'Content-Disposition: inline'crlf,                      /*COPY*/\n              ||'Content-Transfer-Encoding: 7bit'crlf                   /*COPY*/\n           sm = SOCKET(\"WRITE\",_sid,MimeHeader||crlf)                   /*COPY*/\n           DO j = 1 TO em.atch.k.0          /* Add Inline file        *//*COPY*/\n              sm = SOCKET(\"WRITE\",_sid,em.atch.k.j||crlf)               /*COPY*/\n           END                                                          /*COPY*/\n          END                                                           /*COPY*/\n      OTHERWISE   /* ENCODE64 CBT Rexx Function must be available     *//*COPY*/\n         MimeHeader = crlf'--'mbound || crlf,                           /*COPY*/\n            ||'Content-Type: application/octet-stream; ',               /*COPY*/\n            ||              'name=\"'em.atch.k.fnm'\"'crlf,               /*COPY*/\n            ||'Content-Disposition: attachment; ',                      /*COPY*/\n            ||        'filename=\"'em.atch.k.fnm'\"; ',                   /*COPY*/\n            ||        'modification-date=\"'em.atch.k.dat'\"'crlf,        /*COPY*/\n            ||'Content-Transfer-Encoding: base64'crlf                   /*COPY*/\n         sm = SOCKET(\"WRITE\",_sid,MimeHeader||crlf)                     /*COPY*/\n         x = ENCODE64(\"em.atch.k.\",\"_atch_64.\")  /* Convert to Base64 *//*COPY*/\n         DO j = 1 TO _atch_64.0                  /* Add ENCODEd file  *//*COPY*/\n            sm = SOCKET(\"WRITE\",_sid,_atch_64.j||crlf)                  /*COPY*/\n         END                                                            /*COPY*/\n      END                                                               /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MAILSOCK */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Initialize Socket and get necessary info from TCP/IP Stack.       /*COPY*/\n***********************************************************************//*COPY*/\nINIT_SMTP_SOCKET:                                                       /*COPY*/\n  sm = SOCKET(\"INITIALIZE\",\"SMTP01\")       /* Init RXSOCKET API       *//*COPY*/\n    IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"INITIALIZE\", sm          /*COPY*/\n  sm = SOCKET(\"SOCKET\",\"AF_INET\",\"STREAM\") /* Init IP4 TCP Socket     *//*COPY*/\n    IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"SOCKET\", sm              /*COPY*/\n       ELSE _sid = WORD(sm,2)                                           /*COPY*/\n  sm = SOCKET(\"GETHOSTNAME\")               /* Get HOSTNAME            *//*COPY*/\n    IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"GETHOSTNAME\", sm         /*COPY*/\n       ELSE HOSTNAME = WORD(sm,2)                                       /*COPY*/\n  sm = SOCKET(\"GETDOMAINNAME\")             /* Get Domain              *//*COPY*/\n    IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"GETDOMAINNAME\", sm       /*COPY*/\n       ELSE DOMAINNAME = WORD(sm,2)                                     /*COPY*/\n  IF ABBREV(\"DEFAULT\", SERVER) & \u00ac(DATATYPE(PORT, \"NUM\")) THEN DO       /*COPY*/\n      sm = SOCKET(\"GETSERVBYNAME\", \"SMTP\") /* Get local SMTP Port     *//*COPY*/\n         IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"GETSERVBYNAME\", sm  /*COPY*/\n            ELSE PORT = WORD(sm,3)                                      /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE IF ABBREV(\"DEFAULT\",PORT) THEN PORT = 25                         /*COPY*/\n                                           /* Translate to ASCII      *//*COPY*/\n  sm = SOCKET(\"SETSOCKOPT\",_sid,\"SOL_SOCKET\",\"SO_ASCII\",\"ON\")           /*COPY*/\n     IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"SETSOCKOPT\", sm         /*COPY*/\n                                           /* Connect to SMTP Server  *//*COPY*/\n  IF ABBREV(\"DEFAULT\", SERVER) THEN SERVER = HOSTNAME\".\"DOMAINNAME      /*COPY*/\n  sm = SOCKET(\"CONNECT\",_sid,\"AF_INET\" PORT SERVER)                     /*COPY*/\n     IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"CONNECT\", sm            /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n      Connect to SMTP Server and Send SMTP Header control commands.     /*COPY*/\n***********************************************************************//*COPY*/\nEMAIL_HEADER:                                                           /*COPY*/\n  sm = SOCKET(\"WRITE\",_sid,\"HELO\" SERVER||crlf) /* Start SMTP Session *//*COPY*/\n     IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"WRITE\", sm              /*COPY*/\n     ELSE DO                                                            /*COPY*/\n        sm = SOCKET(\"READ\",_sid)                                        /*COPY*/\n        IF WORD(sm,3) \u00ac= \"220\" THEN                                     /*COPY*/\n           CALL SOCKET_ERR \"HELO\" SERVER, WORD(sm,3) sm                 /*COPY*/\n     END                                     /* Set SMTP From:        *//*COPY*/\n  PARSE VALUE em.hdr.fm WITH . \"<\" _from_ \">\" .                         /*COPY*/\n  sm = SOCKET(\"WRITE\",_sid, \"MAIL FROM: <\"_from_\">\"crlf)                /*COPY*/\n     IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"WRITE\", sm              /*COPY*/\n     ELSE DO                                                            /*COPY*/\n        sm = SOCKET(\"READ\",_sid)                                        /*COPY*/\n        IF WORD(sm,3) \u00ac= \"250\" THEN                                     /*COPY*/\n           CALL SOCKET_ERR \"MAIL FROM:\", WORD(sm,3) sm                  /*COPY*/\n     END                                                                /*COPY*/\n  DO i = 1 TO em.hdr.to.0                    /* eMail TO: Addresses   *//*COPY*/\n      PARSE VALUE em.hdr.to.i WITH . \"<\" _to_ \">\" .                     /*COPY*/\n      sm = SOCKET(\"WRITE\",_sid, \"RCPT TO: <\"_to_\">\"crlf)                /*COPY*/\n      IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"WRITE\", sm             /*COPY*/\n      ELSE DO                                                           /*COPY*/\n         sm = SOCKET(\"READ\",_sid)                                       /*COPY*/\n         IF WORDPOS(WORD(sm,3), \"250 251\") = 0 THEN                     /*COPY*/\n            CALL SOCKET_ERR \"RCPT TO:\" em.hdr.to.i, WORD(sm,3) sm       /*COPY*/\n      END                                                               /*COPY*/\n  END                                                                   /*COPY*/\n  DO i = 1 TO em.hdr.cc.0                    /* eMail CC: Addresses   *//*COPY*/\n      PARSE VALUE em.hdr.cc.i WITH . \"<\" _cc_ \">\" .                     /*COPY*/\n      sm = SOCKET(\"WRITE\",_sid, \"RCPT TO: <\"_cc_\">\"crlf)                /*COPY*/\n      IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"WRITE\", sm             /*COPY*/\n      ELSE DO                                                           /*COPY*/\n         sm = SOCKET(\"READ\",_sid)                                       /*COPY*/\n         IF WORDPOS(WORD(sm,3), \"250 251\") = 0 THEN                     /*COPY*/\n            CALL SOCKET_ERR \"RCPT TO:\" em.hdr.cc.i, WORD(sm,3) sm       /*COPY*/\n      END                                                               /*COPY*/\n  END                                                                   /*COPY*/\n  DO i = 1 TO em.hdr.bc.0                    /* eMail BCC: Addresses  *//*COPY*/\n      PARSE VALUE em.hdr.bc.i WITH . \"<\" _bc_ \">\" .                     /*COPY*/\n      sm = SOCKET(\"WRITE\",_sid, \"RCPT TO: <\"_bc_\">\"crlf)                /*COPY*/\n      IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"WRITE\", sm             /*COPY*/\n      ELSE DO                                                           /*COPY*/\n         sm = SOCKET(\"READ\",_sid)                                       /*COPY*/\n         IF WORDPOS(WORD(sm,3), \"250 251\") = 0 THEN                     /*COPY*/\n            CALL SOCKET_ERR \"RCPT TO:\" em.hdr.bc.i, WORD(sm,3) sm       /*COPY*/\n      END                                                               /*COPY*/\n  END                                        /* End SMTP Header       *//*COPY*/\n  sm = SOCKET(\"WRITE\",_sid, \"DATA\"||crlf)                               /*COPY*/\n  IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"WRITE\", sm                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     sm = SOCKET(\"READ\",_sid)                                           /*COPY*/\n     IF WORDPOS(WORD(sm,3), \"250 354\") = 0 THEN                         /*COPY*/\n        CALL SOCKET_ERR \"DATA\", WORD(sm,3) sm                           /*COPY*/\n  END                                                                   /*COPY*/\n  IF em.hdr.rec \u00ac= \"\"   THEN DO              /* Start eMail Headers   *//*COPY*/\n       sm = SOCKET(\"WRITE\",_sid, \"Received:\" em.hdr.rec||crlf)          /*COPY*/\n       sm = SOCKET(\"WRITE\",_sid, \"Date:\" dte||crlf)                     /*COPY*/\n       PARSE VALUE TIME(\"S\") WITH hh \":\" mm \":\" ss .                    /*COPY*/\n       sm = SOCKET(\"WRITE\",_sid, \"Message-ID:\",                         /*COPY*/\n                    DATE(\"S\")||hh||mm||ss\".\"mid||EM_DOM||crlf)          /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE sm = SOCKET(\"WRITE\",_sid, \"Date:\" dte||crlf)                     /*COPY*/\n  sm = SOCKET(\"WRITE\",_sid, \"From:\" em.hdr.fm||crlf)                    /*COPY*/\n  IF em.hdr.rep \u00ac= \"\" THEN                                              /*COPY*/\n     sm = SOCKET(\"WRITE\",_sid, \"Reply-to:\" em.hdr.rep  ||crlf)          /*COPY*/\n  ELSE DO i = 1 TO em.hdr.rep.0                                         /*COPY*/\n     sm = SOCKET(\"WRITE\",_sid, \"Reply-to:\" em.hdr.rep.i||crlf)          /*COPY*/\n  END                                                                   /*COPY*/\n  DO i = 1 TO em.hdr.to.0                                               /*COPY*/\n     sm = SOCKET(\"WRITE\",_sid,\"To:\" em.hdr.to.i||crlf)                  /*COPY*/\n  END                                                                   /*COPY*/\n  DO i = 1 TO em.hdr.cc.0                                               /*COPY*/\n     sm = SOCKET(\"WRITE\",_sid,\"Cc:\" em.hdr.cc.i||crlf)                  /*COPY*/\n  END                                                                   /*COPY*/\n  IF em.hdr.sub \u00ac= \"\" THEN                                              /*COPY*/\n       sm = SOCKET(\"WRITE\",_sid, \"Subject:\" em.hdr.sub||crlf)           /*COPY*/\n  IF em.hdr.com \u00ac= \"\" THEN                   /* eMail Header Comment  *//*COPY*/\n       sm = SOCKET(\"WRITE\",_sid, \"Comment:\" em.hdr.com||crlf)           /*COPY*/\n  sm = SOCKET(\"WRITE\",_sid, \"Importance:\" em.hdr.imp||crlf)             /*COPY*/\n                                             /* This will use MIME    *//*COPY*/\n  sm = SOCKET(\"WRITE\",_sid, \"MIME-Version: 1.0\"crlf)                    /*COPY*/\n  sm = SOCKET(\"WRITE\",_sid, \"Content-Type: multipart/mixed;\",           /*COPY*/\n                            'boundary=\"'mbound'\"'crlf)                  /*COPY*/\n  IF em.hdr.ret \u00ac= \"\" THEN                   /* Return-Path           *//*COPY*/\n       sm = SOCKET(\"WRITE\",_sid, \"Return-Path:\" em.hdr.ret||crlf)       /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n      Send End-of-MIME indicater, SMTP End-of-Message indicator,        /*COPY*/\n      and then close SMTP session.                                      /*COPY*/\n***********************************************************************//*COPY*/\nCLOSE_eMail:                                                            /*COPY*/\n  IF (em.body.0 + em.atch.0) > 0 THEN sm =,                             /*COPY*/\n       SOCKET(\"WRITE\",_sid, crlf||\"--\"mbound\"--\"||crlf)                 /*COPY*/\n  sm = SOCKET(\"WRITE\",_sid, crlf\".\"crlf)     /* SMTP End of Message   *//*COPY*/\n     IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"WRITE\", sm              /*COPY*/\n     ELSE DO                                                            /*COPY*/\n        sm = SOCKET(\"READ\",_sid)                                        /*COPY*/\n        IF \u00ac(ABBREV(sm,\"0\")) & WORD(sm,3) = \"250\" THEN                  /*COPY*/\n             CALL SOCKET_ERR \"SENDMAIL\", sm                             /*COPY*/\n        ELSE CALL SET_MSG \"eMail Sent.\", sm,\"NO\"                        /*COPY*/\n     END                                                                /*COPY*/\n  sm = SOCKET(\"WRITE\",_sid, \"RSET\"crlf)                                 /*COPY*/\n  sm = SOCKET(\"READ\",_sid)                                              /*COPY*/\n  sm = SOCKET(\"WRITE\",_sid, \"QUIT\"crlf)      /* Complete SMTP Session *//*COPY*/\n  sm = SOCKET(\"READ\",_sid)                                              /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n      Close and Terminate Socket connection.                            /*COPY*/\n***********************************************************************//*COPY*/\nCLOSE_SMTP_SOCKET:                                                      /*COPY*/\n  sm = SOCKET(\"CLOSE\", _sid)                 /* Disconnect Socket     *//*COPY*/\n     IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"CLOSE\", sm              /*COPY*/\n  sm = SOCKET(\"TERMINATE\", \"SMTP01\")         /* End RXSOCKET API      *//*COPY*/\n     IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"TERMINATE\", sm          /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n    Report RXSOCKET Error and then fall through to CLEANUP              /*COPY*/\n***********************************************************************//*COPY*/\nSOCKET_ERR:                                                             /*COPY*/\nARG _type_, ExitError _msg_                                             /*COPY*/\n  DO eline = sigl-1 TO 1 BY -1                                          /*COPY*/\n     IF INDEX(STRIP(SOURCELINE(eline)),\"SOCKET(\") > 0 THEN LEAVE eline  /*COPY*/\n  END                                                                   /*COPY*/\n  IF eline > 1 THEN line = STRIP(SOURCELINE(eline))                     /*COPY*/\n     ELSE           line = STRIP(SOURCELINE(sigl-1))                    /*COPY*/\n  CALL SET_MSG \" Socket RC:\" ExitError, _type_ \"Error:\" _msg_, \"YES\"    /*COPY*/\n  CALL SET_MSG \"Error Line:\" eline, line, \"YES\"                         /*COPY*/\n  sm = SOCKET(\"CLOSE\", _sid)           /* Disconnect Socket           *//*COPY*/\n  sm = SOCKET(\"TERMINATE\", \"SMTP01\")   /* End RXSOCKET API            *//*COPY*/\nEXIT ExitError                         /* Set TSO/MVS RC to error RC  *//*COPY*/\n/**********************************************************************\n            Cleanup and Exit Gracefully\n***********************************************************************/\nCLEANUP:\n  ok='*'                               /* Ignore all non-0 RCs        */\n    sm = SOCKET(\"CLOSE\", _sid)         /* Disconnect Socket           */\n    sm = SOCKET(\"TERMINATE\", \"SMTP01\") /* End RXSOCKET API            */\nEXIT ExitError                         /* Set TSO/MVS RC to error RC  */\n/* COPY ERRMVS */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n                                                                        /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n  CALL MVS_ERROR_DISPLAY            /* Display collected error info   *//*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCRTMP01": {"ttr": 1289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00X\\x01\\x06\\x08\\x7f\\x01\\x06!o\\x13\\x12\\x00\\x02\\x00\\x02\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2006-03-28T00:00:00", "modifydate": "2006-08-04T13:12:58", "lines": 2, "newlines": 2, "modlines": 0, "user": "AL-FERG"}, "text": " OPTION   VLSHRT,SIZE=E500000,NOEQUALS\n SORT     FIELDS=(11,4,PD0,A,7,4,BI,A)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SCRTMP02": {"ttr": 1291, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00E\\x01\\x06\\x08\\x7f\\x01\\x06\\x08\\x7f\\x10A\\x00\\x02\\x00\\x02\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-03-28T00:00:00", "modifydate": "2006-03-28T10:41:45", "lines": 2, "newlines": 2, "modlines": 0, "user": "AL-FERG"}, "text": "  INDD(INPUT,OPTIONS(DUMP))\n  OUTDD(OUTPUT,TYPE(70,89))\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SCRTMP03": {"ttr": 1293, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x16\\x01\\x07\\x19\\x1f\\x01\\x08\\x19\\x7f\\x152\\x00\\xb1\\x00\\xb0\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2007-07-10T00:00:00", "modifydate": "2008-07-15T15:32:16", "lines": 177, "newlines": 176, "modlines": 0, "user": "AL-FERG"}, "text": "*\n* THIS MEMBER MUST BE TUNED FOR YOU SHOP!!!!\n*\n* FOR EACH PRODUCT LISTED, YOU MUST ENTER ONE OF THESE 3 OPTIONS:\n*\n* 1. ENTER *ALL IF THE PRODUCT RUNS IN ALL LPARS IN THE INPUT SMF\n*    DATA FILE. E.G.  5655-043=*ALL\n* 2. ENTER *NONE IF THE PRODUCT RUNS IN NONE OF THE LPARS IN THE\n*    INPUT SMF DATA FILE.\n* 3. ENTER A LIST OF LPAR NAMES SEPARATED BY COMMAS OF THE LPARS IN\n*    WHICH THE PRODUCT RUNS. (YOU MAY CONTINUE ONTO THE NEXT LINE BY\n*    ENDING THE PRIOR LINE WITH A COMMA.)\n*\n* --------------------------- Z/OS NO89S -----------------------------\n*\n* NETVIEW PERF MONITOR V2\n5655-043=*ALL\n* TIVOLI NETVIEW FOR Z/OS\n5697-ENV=*ALL\n* TIVOLI NETVIEW FOR OS/390\n5697-B82=*ALL\n* TIVOLI WORKLOAD SCHEDULER FOR Z/OS\n5697-WSZ=*ALL\n* OPC V2\n5697-OPC=*ALL\n* SYSTEM AUTOMATION FOR OS/390\n5645-005=*ALL\n* SYSTEM AUTOMATION OS/390 V2\n5645-006=*ALL\n* LOTUS DOMINO FOR S/390\n5655-B86=*ALL\n* (NEW 15.1.0) LOTUS ACTIVE INSIGHT FOR Z/OS V6\n5655-U15=*ALL\n* COBOL FOR OS/390 & VM V2\n5648-A25=*ALL\n* VA PL/I FOR OS/390 V2\n5655-B22=*ALL\n* IBM ENTERPRISE PL/I FOR Z/OS AND OS/390 V3\n5655-H31=*ALL\n* IBM ENTERPRISE COBOL FOR Z/OS AND OS/390 V3\n5655-G53=*ALL\n* (NEW 15.1.0) IBM ENTERPRISE COBOL FOR Z/OS V4\n5655-S71=*ALL\n* QMF MVS VERSION 3\n5706-254=*ALL\n* FAULT ANALYZER FOR OS/390 V1\n5697-F19=*ALL\n* FAULT ANALYZER FOR Z/OS AND OS/390 V2\n5655-G74=*ALL\n* FAULT ANALYZER FOR Z/OS AND OS/390 V3\n5655-J47=*ALL\n* FAULT ANALYZER FOR Z/OS V4\n5655-L25=*ALL\n* FAULT ANALYZER FOR Z/OS V5\n5655-M20=*ALL\n* FAULT ANALYZER FOR Z/OS V6\n5655-P16=*ALL\n* FAULT ANALYZER FOR Z/OS V7\n5655-R46=*ALL\n* FILE ANALYZER FOR Z/OS AND OS/390 V2\n5655-G75=*ALL\n* FILE MANAGER  FOR OS/390 V1\n5697-F20=*ALL\n* FILE MANAGER  FOR Z/OS AND OS/390 V3\n5655-J48=*ALL\n* FILE MANAGER FOR Z/OS V4\n5655-L26=*ALL\n* FILE MANAGER FOR Z/OS V5\n5655-M21=*ALL\n* FILE MANAGER FOR Z/OS V6\n5655-P17=*ALL\n* FILE MANAGER FOR Z/OS V7\n5655-R47=*ALL\n* FILE EXPORT FOR Z/OS V1\n5697-I12=*ALL\n* APPLICATION MONITOR FOR Z/OS AND OS/390 V1\n5697-H63=*ALL\n* APPLICATION MONITOR FOR Z/OS V2\n5655-L22=*ALL\n* DEBUG TOOL UTILITIES AND ADV FUNCTIONS FOR Z/OS & OS/390 V3\n5655-J18=*ALL\n* DEBUG TOOL UTILITIES AND ADV FUNCTIONS FOR Z/OS V4\n5655-L23=*ALL\n* DEBUG TOOL UTILITIES AND ADV FUNCTIONS FOR Z/OS V5\n5655-M19=*ALL\n* DEBUG TOOL UTILITIES AND ADV FUNCTIONS FOR Z/OS V6\n5655-P15=*ALL\n* DEBUG TOOL UTILITIES AND ADV FUNCTIONS FOR Z/OS V7\n5655-R45=*ALL\n* (NEW 15.1.0) DEBUG TOOL UTILITIES AND ADV FUNCTIONS FOR Z/OS V8\n5655-S16=*ALL\n* CLOUD 9 FOR SCLM FOR OS/390 V1\n5697-G57=*ALL\n* CLOUD 9 FOR SCLM FOR Z/OS V2\n5655-G93=*ALL\n* BREEZE FOR SCLM OS/390 V1\n5697-G58=*ALL\n* IBM TIVOLI MONITORING FOR NETWORK PERFORMANCE V1\n5698-A10=*ALL\n* IBM TIVOLI SYSTEM AUTOMATION FOR OS/390 V2\n5698-A14=*ALL\n* IBM TIVOLI SYSTEM AUTOMATION FOR OS/390 V3\n5698-SA3=*ALL\n* IBM TIVOLI WORKLOAD SCHEDULER FOR HOST EDITION V8\n5698-A17=*ALL\n* IBM TIVOLI MONITORING FOR NETWORK PERFORMANCE V2\n5698-FNP=*ALL\n* WEBSPHERE TRANSFORMATION EXTENDER FOR Z/OS V8\n5655-R95=*ALL\n* IBM WEBSPHERE PORTAL FOR Z/OS AND OS/390 V4\n5655-K12=*ALL\n* IBM WEBSPHERE HOST PUBLISHER FOR V4 FOR ZSERIES\n5655-I03=*ALL\n* IBM WEBSPHERE MQ INTEGRATOR BROKER FOR Z/OS V2\n5655-I58=*ALL\n* IBM WEBSPHERE MQ INTEGRATOR FOR Z/OS V2\n5655-G97=*ALL\n* WEBSPHERE STUDIO APPLICATION MONITOR V1\n5655-J67=*ALL\n* WEBSPHERE STUDIO ASSET ANALYZER V4\n5655-M22=*ALL\n* WEBSPHERE STUDIO ASSET ANALYZER V3\n5655-L21=*ALL\n* WEBSPHERE STUDIO ASSET ANALYZER V2\n5655-I49=*ALL\n* WEBSPHERE STUDIO WORKLOAD SIMULATOR V1\n5655-I14=*ALL\n* WEBSPHERE STUDIO APPLICATION MONITOR FOR Z/OS V2\n5655-L42=*ALL\n* WEBSPHERE STUDIO APPLICATION MONITOR FOR Z/OS V3\n5697-J18=*ALL\n* IMS DATA COLLECTOR FOR WEBSPHERE STUDIO APPL MONITOR V3\n5697-J01=*ALL\n* CICS DATA COLLECTOR FOR WEBSPHERE STUDIO APPL MONITOR V2\n5655-L50=*ALL\n* CICS DATA COLLECTOR FOR WEBSPHERE STUDIO APPL MONITOR V3\n5697-J17=*ALL\n* (NEW 15.1.0) WEBSPHERE DASHBOARD FRAMEWORK FOR Z/OS V6\n5655-U13=*ALL\n* APPLICATION WORKLOAD MODELER FOR Z/OS V1\n5655-J62=*ALL\n* ENHANCED ACCESS CONTROL FOR SCLM V1\n5697-H59=*ALL\n* WORKLOAD SIMULATOR FOR Z/OS AND OS/390 V1\n5655-I39=*ALL\n* MERGE TOOL FOR Z/OS AND OS/390 V1\n5697-H70=*ALL\n* MIGRATION UTILITY FOR Z/OS V1\n5655-I18=*ALL\n* MIGRATION UTILITY FOR Z/OS V2\n5697-I89=*ALL\n* SCLM SUITE ADMIN WORKBENCH FOR Z/OS V1\n5655-L03=*ALL\n* SCLM DEVELOPER TOOLKIT V2\n5655-R37=*ALL\n* SCLM DEVELOPER TOOLKIT V1\n5655-M99=*ALL\n* APPLICATION PERF ANALYZER FOR Z/OS V1\n5697-N37=*ALL\n* APPLICATION PERF ANALYZER FOR Z/OS V7\n5697-N53=*ALL\n* (NEW 14.2.0) APPLICATION PERF ANALYZER FOR Z/OS V8\n5697-N63=*ALL\n* TIVOLI COMPOSITE APPLICATION MANAGER FOR CICS V6\n5698-A69=*ALL\n* TIVOLI COMPOSITE APPLICATION MANAGER FOR IMS V6\n5698-A70=*ALL\n* TIVOLI COMPOSITE APPLICATION MANAGER FOR WEBSPHERE V6\n5698-A71=*ALL\n* SCLM ADMIN TOOLKIT V2\n5697-J19=*ALL\n* IBM MIGRATION UTILITY FOR Z/OS V3\n5697-N44=*ALL\n* TIVOLI OMEGAMON XE FOR MESSAGING V6\n5698-A87=*ALL\n* AUTOMATED TAPE ALLOC MANAGER V1\n5697-H62=*ALL\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SCRTMP04": {"ttr": 1539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00G\\x01\\x06\\x07/\\x01\\x08\\x19/\\x15X\\x00\\x1c\\x00\\xa8\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2006-03-13T00:00:00", "modifydate": "2008-07-10T15:58:47", "lines": 28, "newlines": 168, "modlines": 0, "user": "AL-FERG"}, "text": "*\n* THERE ARE 5 REQUIRED PARM KEYWORDS:\n*     THEY MUST BE FILLED IN OR THE PROGRAM WILL NOT PROCEED.\n*\n* ENTER YOUR CUSTOMER_NAME\nCustomer_Name=IBM_Customer_Name\n*\n* ENTER YOUR IBM COUNTRY CODE FOLLOWED BY YOUR IBM CUSTOMER NUMBER\n*   IF YOU DON'T KNOW YOUR IBM COUNTRY CODE, FIND IT HERE:\n* http://ibm.com/zseries/swprice/scrt/index.html#codes\nCustomer_Number=1234567890\n*\n* ENTER THE NAME OF THE PERSON SUBMITTING THE REPORT\nContact_Name=Full_Name_of_IBM_Account_holder\n*\n* ENTER THE EMAIL ADDRESS OF PERSON SUBMITTING THE REPORT\nContact_EMail=IBM_Account_name/eMail_Address\n*\n* ENTER THE PHONE NUMBER OF THE PERSON SUBMITTING THE REPORT\nContact_Phone=(###) ###-####\n*\n* OPTIONALLY UNCOMMENT THIS LINE AND ENTER A PO NUMBER\n* PO_Number=\n*\n* OPTIONALLY UNCOMMENT ONE OF THESE LINES TO SELECT A REPORT PERIOD\n* Report_Period=YYYY/MM\n* Report_Period=Last_Month\n*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SCRTMP05": {"ttr": 1541, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x005\\x01\\x08\\x19/\\x01\\x08\\x19\\x7f\\x101\\x00\\t\\x00\\x0e\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2008-07-10T00:00:00", "modifydate": "2008-07-15T10:31:35", "lines": 9, "newlines": 14, "modlines": 0, "user": "AL-FERG"}, "text": "Received: primary_contact@your_domain.com\nFrom: primary_contact@your_domain.com\nTo: scrtlms@dk.ibm.com\nCc: IBM_account_rep@us.ibm.com\nCc: primary_contact@your_domain.com\nCc: backup_contact@your_domain.com\nSubject: <AUTO> Sub-Capacity Report for &month.\nComment: Monthly Automated SCRT report from Customer_Name.\nAttachment: SCRTRPT octet-stream scrt.csv\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SENDMAIL": {"ttr": 1543, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02?\\x00 \\x01\\x08\\x12o\\x01\\x17$\\x1f\\tQ\\x03\\x0f\\x01J\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "02.63", "flags": 0, "createdate": "2008-05-05T00:00:00", "modifydate": "2017-08-29T09:51:20", "lines": 783, "newlines": 330, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n This REXX is used to send SMTP Mail via the REXX RXSOCKET API vs the\n      USS /bin/sendmail command. This allows the manipulations of\n      additional SMTP Headers not available when using sendmail.\n\n This REXX does NOT Require TSO, it will run in batch under IRXJCL.\n\n To BASE64 encoding requires access to ENCODE64 REXX Function:\n       http://www.homerow.net/asm/index.htm\n\n                           --- EXAMPLE ---\nIRXJCL SENDMAIL <EM_DOM(@default_email_domain)> <EM_TYPE(PLAIN|HTML)>   ,\n      <IMPORT(Normal|High|Low)> <PORT(smtp_port)>                       ,\n      <SERVER(server_dns_name)> <TOKEN(STEMPUSH_token)> <TEST(trace_opt)>\nTSO <%>SENDMAIL <EM_DOM(@default_email_domain)> <EM_TYPE(PLIAN|HTML)>   ,\n      <IMPORT(Normal|High|Low)> <PORT(smtp_port)>                       ,\n      <SERVER(server_dns_name)> <TOKEN(STEMPUSH_token)> <TEST(trace_opt)>\nTSO <%>SENDMAIL -H -- To display help for this REXX\n\n  Arguments: InParms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                  EM_DOM - Default Email Domain to add to email address\n                           default: @YourDomain.com\n                 EM_TYPE - Email Body Type, plain text or html\n                           default: PLAIN\n                  IMPORT - Message Importance       default: Normal\n                    PORT - SMTP Server Port Number. default: DEFAULT\n                  SERVER - SMTP Server DNS Name.    default: DEFAULT\n                   TOKEN - Token created by STEMPUSH in calling REXX\n                           and used by STEMPULL to ID stem variable\n                           used to pass email.      default: blank\n                    TEST - Used to control traces.\n\n      Files: EMCNTL - Pre-Allocated EMail Control DD (see PARMs below)\n             EMBODY - Pre-Allocated EMail Body DD\n             ?????? - Pre-Allocated EMail Attachments DDs as defined\n                      in EMail Control DD\n                NOTE: The above files are not used if TOKEN is provided.\n      PARMs: *        - In column 1 indicates a comment.\n             From     - eMail address in message From field.\n             Received - Used in SMTP header to trace path of a message\n                        from its source to its destination.\n             Reply-to - eMail address used when user does a REPLY, if\n                        different then the From address.\n             To       - Primary eMail receipients.\n             Cc       - Carbon Copy eMail receipients.\n             Bcc      - Blind Carbon Copy eMail receipients.\n             Subject  - eMail one line subject.\n             Comment  - Comment embedded in eMail header information.\n             Import   - Set eMail Importance: Normal, High, or Low.\n             Attach   - Attachment file information: DD_name, MIME\n                        Content-type, and attachment file name.\n   STEM Var: em. = \"\"\n             em.hdr.to.0   = 0; em.hdr.cc.0 = 0; em.hdr.bc.0 = 0\n             em.hdr.to.#   = \u00dd<email@domain> | name <email@domain>\u00a8\n             em.hdr.cc.#   = \u00dd<email@domain> | name <email@domain>\u00a8\n             em.hdr.bc.#   = \u00dd<email@domain> | name <email@domain>\u00a8\n             em.hdr.fm     = \u00dd<email@domain> | name <email@domain>\u00a8\n             em.hdr.sub    = \"\"             /* Email Subject line         */\n             em.hdr.com    = \"\"             /* Hidden Header comment      */\n             em.hdr.imp    = \u00ddN | H | L\u00a8    /* Email Importance           */\n             em.hdr.rec    = email@domain   /* SMTP Received from address */\n             em.hdr.rep.#  = \u00dd<email@domain> | name <email@domain>\u00a8\n             em.atch.0     = #              /* Number of attachments      */\n             em.atch.#.dat = \"\"             /* Attachment file date       */\n             em.atch.#.fnm = \"\"             /* Attachment filename        */\n             em.atch.#.typ = \u00ddPLAIN | HTML | OCTET-STREAM | INLINE | BASE64\u00a8\n             em.body.0     = #              /* Number records in body     */\n             em.body.#     = \"\"             /* Record # of email body     */\nOther EXECS: None\n\nEXEC History\n\n REXX EXEC Name: SENDMAIL\n         Author: AL FERGUSON - TS ADM (TSAZFA) from version 2.43\n                 Al Ferguson (HUL2353)\n         Writen: 07JUL08\n        History: 06FEB17 - v2.49 - Pick up updated version or ERRINFO\n                           Common Code routines.\n                 01FEB17 - v2.48 - Mass update to Error Handling Fixes.\n                 10MAY16 - v2.43 - Remove NAR support (obsolete)\n                 25APR13 - v2.38 - Fix multiple Reply-to email\n                           address support, while supporting old calls.\n                 09JAN12 - v2.31 - Add support for HTML Based\n                           Email Bodies & Attachments.\n                 16DEC11 - v2.17 - Add support for using SENDMAIL\n                           as a CALLED REXX that passes the email via\n                           stem variables using Rob Scott's STEMPUSH and\n                           STEMPULL REXX Functions (CBT File 411).\n                 14JUL08 - v1.84 - Fixed SET_MSG when being CALLed\n                           from within another REXX EXEC.\n                 09JUL08 - v1.71 - Miscellanious cleanup.\n                 09JUL08 - v1.69 - Fix Socket Error handling and\n                           handle PORT(DEFAULT) or PORT() when the SERVER\n                           is passed.\n                 08JUL08 - v1.66 - Cleanup Mime headers and reduce\n                           CALLs to RXSOCKET. Ensure RANDOM returns valid\n                           values to pick random letters properly.\n                 07JUL08 - v1.0 -- Based off of SCRTML v1.57\n***************************** Rexx ***********************************/\nPARSE ARG InParms                            /* Place arguments here */\n\nIF WORDPOS(InParms,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nCALL GET_EMAIL_CNTL\nCALL INIT_SMTP_SOCKET\n\nCALL EMAIL_HEADER\nCALL EMAIL_BODY\nCALL EMAIL_ATTACHMENTS\nCALL CLOSE_EMAIL\n\nCALL CLOSE_SMTP_SOCKET\n\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  ValidParms = \"EM_DOM(@YourDomain.com) EM_TYPE(PLAIN) IMPORT()\",\n                \"PORT(DEFAULT) SERVER(DEFAULT) TOKEN() TEST(O)\"\n  MatchLength = 4      /* NP-Parms match on first # chars             */\n  AcceptAll = FALSE    /* Allow un-recognized NP-PARMS to be passed   */\n  IF ValidParms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  SYSUID = USERID()\n  ExitError = 0\n  Lower   = \"abcdefghijklmnopqrstuvwxyz\"\n  Upper   = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  letters = Lower || Upper\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n     source.i = SOURCELINE(i + 1)   /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i = 1 TO i; SAY source.i; END /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i = 1 TO i     /* Build HELP table to display                 *//*COPY*/\n        source = source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"            /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK = CENTER(\"----> END of Help <----\",80)                     /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList = ValidParms ' '; InList = InParms ' '                         /*COPY*/\n  ParmList = ''; ParmErrorList = ''                                     /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(ValidParms) UNTIL VpList = ''                    /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList = ParmList STRIP(LEFT(parm.linx,MatchLength))             /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm = STRIP(parm)                                                 /*COPY*/\n     ParmNumber = WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)      /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber = value                  /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList = ParmErrorList parm\"(\"value                    /*COPY*/\n     ELSE ParmErrorList = ParmErrorList parm\"(\"value\")\"                 /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse = STRIP(InList) ParmErrorList                       /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      AnythingElse = STRIP(InList)                                      /*COPY*/\n  END                                                                   /*COPY*/\n  DO ParmInx = 1 TO linx                                                /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE         /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SOCKMAIL */\n/* COPY MAILCNTL */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n     Read eMail Header and Control information,then parse it, and       /*COPY*/\n           build stings for SMTP Header commands.                       /*COPY*/\n                                                                        /*COPY*/\n  The structure of the em. STEM Varaible used here and passed via the   /*COPY*/\n      STEMPUSH & STEMPULL REXX Functions.                               /*COPY*/\n    em. = \"\"                                                            /*COPY*/\n    em.hdr.to.0 = 0; em.hdr.cc.0 = 0; em.hdr.bc.0 = 0; em.hdr.rep.0 = 0 /*COPY*/\n    em.hdr.to.# = \u00dd<email@domain> | name <email@domain>\u00a8                /*COPY*/\n    em.hdr.cc.# = \u00dd<email@domain> | name <email@domain>\u00a8                /*COPY*/\n    em.hdr.bc.# = \u00dd<email@domain> | name <email@domain>\u00a8                /*COPY*/\n    em.hdr.fm   = \u00dd<email@domain> | name <email@domain>\u00a8                /*COPY*/\n    em.hdr.sub  = \"\"               /* Email Subject line              *//*COPY*/\n    em.hdr.com  = \"\"               /* Hidden Header comment           *//*COPY*/\n    em.hdr.imp  = \u00ddN | H | L\u00a8      /* Email Importance                *//*COPY*/\n    em.hdr.rec  = email@domain     /* SMTP Received from address      *//*COPY*/\n    em.hdr.rep.# = \u00dd<email@domain> | name <email@domain>\u00a8 /* Reply-To *//*COPY*/\n    em.atch.0     = #              /* Number of attachments           *//*COPY*/\n    em.atch.#.dat = \"\"             /* Attachment file date (optional) *//*COPY*/\n    em.atch.#.fnm = \"\"             /* Attachment filename             *//*COPY*/\n    em.atch.#.typ = \u00ddPLAIN | OCTET-STREAM | INLINE | BASE64\u00a8            /*COPY*/\n    em.body.0   = #                /* Number of records in email body *//*COPY*/\n***********************************************************************//*COPY*/\nGET_EMAIL_CNTL:                                                         /*COPY*/\n  ok_to = \"postmaster POSTMASTER MAILER-DAEMON\"                         /*COPY*/\n  crlf = X2C(\"0D25\"); tab = X2C(\"05\")                                   /*COPY*/\n  dte = LEFT(DATE(\"W\"),3)\",\" DATE(\"N\") TIME(\"N\")                        /*COPY*/\n  _os_ = MVSVAR(\"SYMDEF\",\"LHHMMSS\") - MVSVAR(\"SYMDEF\",\"HHMMSS\")         /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN LENGTH(_os_) = 5 THEN dte = dte \"+0\"LEFT(_os_,3)               /*COPY*/\n    WHEN LENGTH(_os_) = 7 THEN dte = dte LEFT(_os_,5)                   /*COPY*/\n    WHEN ABBREV(_os_,\"-\") THEN dte = dte \"-0\"SUBSTR(_os_,2,3)           /*COPY*/\n  OTHERWISE;                   dte = dte \"+\"LEFT(_os_,4); END           /*COPY*/\n  mid = SUBSTR(letters,RANDOM(51)+1,1)||DATE(\"B\") ,                     /*COPY*/\n     || SUBSTR(letters,RANDOM(51)+1,1)            ,                     /*COPY*/\n     || SUBSTR(letters,RANDOM(51)+1,1)            ,                     /*COPY*/\n     || SUBSTR(letters,RANDOM(51)+1,1)            ,                     /*COPY*/\n     || SUBSTR(letters,RANDOM(51)+1,1)||TIME(\"S\")                       /*COPY*/\n  PARSE SOURCE . . rname .               /* Get REXX EXEC name        *//*COPY*/\n  jname = MVSVAR(\"SYMDEF\",\"JOBNAME\")     /* Get Job Name              *//*COPY*/\n  mbound = \"USER=\"SYSUID\";JOB=\"jname\";REXX=\"rname\";\"mid                 /*COPY*/\n  em. = \"\"; em.atch.0 = 0; em.body.0 = 0                                /*COPY*/\n  em.hdr.to.0 = 0; em.hdr.cc.0 = 0; em.hdr.bc.0 = 0; em.hdr.rep.0 = 0   /*COPY*/\n                                                                        /*COPY*/\n  IF TOKEN = \"\" THEN DO                                                 /*COPY*/\n    ADDRESS \"MVS\" \"EXECIO * DISKR EMCNTL (STEM _emcntl_. FINIS\"         /*COPY*/\n    DO i = 1 TO _emcntl_.0                                              /*COPY*/\n       PARSE VALUE _emcntl_.i WITH keyword \": \" _rest_                  /*COPY*/\n       UPPER keyword; _rest_ = STRIP(_rest_)                            /*COPY*/\n       SELECT                                                           /*COPY*/\n         WHEN ABBREV(keyword,\"*\")        THEN ITERATE i                 /*COPY*/\n         WHEN ABBREV(keyword,\"TO\")       THEN DO                        /*COPY*/\n            k = 1 + em.hdr.to.0; em.hdr.to.0 = k                        /*COPY*/\n            SELECT                                                      /*COPY*/\n              WHEN WORDPOS(_rest_,ok_to) THEN em.hdr.to.k = _rest_      /*COPY*/\n              WHEN ABBREV(_rest_,\"<\")    THEN em.hdr.to.k = _rest_      /*COPY*/\n              WHEN INDEX(_rest_,\"@\") > 0 THEN em.hdr.to.k = \"<\"_rest_\">\"/*COPY*/\n            OTHERWISE; em.hdr.to.k = \"<\"_rest_||EM_DOM\">\"; END          /*COPY*/\n           END                                                          /*COPY*/\n         WHEN ABBREV(keyword,\"CC\")       THEN DO                        /*COPY*/\n            k = 1 + em.hdr.cc.0; em.hdr.cc.0 = k                        /*COPY*/\n            SELECT                                                      /*COPY*/\n              WHEN ABBREV(_rest_,\"<\")    THEN em.hdr.cc.k = _rest_      /*COPY*/\n              WHEN INDEX(_rest_,\"@\") > 0 THEN em.hdr.cc.k = \"<\"_rest_\">\"/*COPY*/\n            OTHERWISE; em.hdr.cc.k = \"<\"_rest_||EM_DOM\">\"; END          /*COPY*/\n           END                                                          /*COPY*/\n         WHEN ABBREV(keyword,\"BCC\")      THEN DO                        /*COPY*/\n            k = 1 + em.hdr.bc.0; em.hdr.bc.0 = k                        /*COPY*/\n            SELECT                                                      /*COPY*/\n              WHEN ABBREV(_rest_,\"<\")    THEN em.hdr.bc.k = _rest_      /*COPY*/\n              WHEN INDEX(_rest_,\"@\") > 0 THEN em.hdr.bc.k = \"<\"_rest_\">\"/*COPY*/\n            OTHERWISE; em.hdr.bc.k = \"<\"_rest_||EM_DOM\">\"; END          /*COPY*/\n           END                                                          /*COPY*/\n         WHEN ABBREV(keyword,\"FROM\")     THEN SELECT                    /*COPY*/\n             WHEN ABBREV(_rest_, \"<\")    THEN em.hdr.fm = _rest_        /*COPY*/\n             WHEN ABBREV(_rest_, \"'\")    THEN em.hdr.fm = _rest_        /*COPY*/\n             WHEN INDEX(_rest_, \"@\") > 0 THEN em.hdr.fm = \"<\"_rest_\">\"  /*COPY*/\n           OTHERWISE; em.hdr.fm = \"<\"_rest_||EM_DOM\">\"; END             /*COPY*/\n         WHEN ABBREV(keyword,\"RECEIVED\") THEN DO                        /*COPY*/\n             PARSE VALUE _rest_ WITH sid \"@\" domain .                   /*COPY*/\n             IF domain = \"\" THEN domain = EM_DOM                        /*COPY*/\n             em.hdr.ret = STRIP(sid\"@\"domain)                           /*COPY*/\n             em.hdr.rec = \"From\" sid \"at\" domain \"with SMTP id\",        /*COPY*/\n                          mid\";\"crlf||tab dte                           /*COPY*/\n           END                                                          /*COPY*/\n         WHEN ABBREV(keyword,\"REPLY\")    THEN DO                        /*COPY*/\n            k = 1 + em.hdr.rep.0; em.hdr.rep.0 = k                      /*COPY*/\n            SELECT                                                      /*COPY*/\n              WHEN ABBREV(_rest_,\"<\")    THEN em.hdr.rep.k=_rest_       /*COPY*/\n              WHEN INDEX(_rest_,\"@\") > 0 THEN em.hdr.rep.k=\"<\"_rest_\">\" /*COPY*/\n            OTHERWISE; em.hdr.rep.k = \"<\"_rest_||EM_DOM\">\"; END         /*COPY*/\n           END                                                          /*COPY*/\n         WHEN ABBREV(keyword,\"SUBJECT\")  THEN em.hdr.sub = STRIP(_rest_)/*COPY*/\n         WHEN ABBREV(keyword,\"COMMENT\")  THEN em.hdr.com = _rest_       /*COPY*/\n         WHEN ABBREV(keyword,\"IMPORT\")   &,                             /*COPY*/\n              em.hdr.imp = \"\"            THEN em.hdr.imp = _rest_       /*COPY*/\n         WHEN ABBREV(keyword,\"ATTACH\")   THEN DO                        /*COPY*/\n             k = 1 + em.atch.0; em.atch.0 = k                           /*COPY*/\n             PARSE UPPER VALUE _rest_ WITH em.atch.k.dd em.atch.k.typ . /*COPY*/\n             em.atch.k.fnm = WORD(_rest_,3)                             /*COPY*/\n           END                                                          /*COPY*/\n       OTHERWISE; NOP; END                                              /*COPY*/\n    END                                                                 /*COPY*/\n  END                                                                   /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     rc = STEMPULL(TOKEN,\"DELETE\")                                      /*COPY*/\n     IF em.hdr.rec \u00ac= \"\" THEN DO                                        /*COPY*/\n        IF INDEX(em.hdr.rec, \"@\") > 0 THEN                              /*COPY*/\n                 PARSE VALUE em.hdr.rec WITH sid \"@\" domain .           /*COPY*/\n        ELSE DO; sid = em.hdr.rec; domain = EM_DOM; END                 /*COPY*/\n        em.hdr.ret = em.hdr.rec                                         /*COPY*/\n        em.hdr.rec = \"From\" sid \"at\" domain \"with SMTP id\",             /*COPY*/\n                     mid\";\"crlf||tab dte                                /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                           /* Set email importance level      *//*COPY*/\n    WHEN ABBREV(em.hdr.imp, \"N\") THEN em.hdr.imp = \"Normal\"             /*COPY*/\n    WHEN ABBREV(em.hdr.imp, \"H\") THEN em.hdr.imp = \"High\"               /*COPY*/\n    WHEN ABBREV(em.hdr.imp, \"L\") THEN em.hdr.imp = \"Low\"                /*COPY*/\n  OTHERWISE; em.hdr.imp = \"Normal\"; END                                 /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MAILBODY */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Read in and then Send eMail Body using inline MIME format.        /*COPY*/\n***********************************************************************//*COPY*/\nEMAIL_BODY:                                  /* Get eMail Body        *//*COPY*/\n  IF TOKEN = \"\" THEN                                                    /*COPY*/\n     ADDRESS \"MVS\" \"EXECIO * DISKR EMBODY (STEM em.body. FINIS\"         /*COPY*/\n  IF em.body.0 = 0 THEN RETURN               /* No body to add        *//*COPY*/\n                                             /* Add body MIME Header  *//*COPY*/\n  sm = SOCKET(\"WRITE\",_sid,crlf||'--'mbound||crlf)                      /*COPY*/\n  IF ABBREV(SYMBOL(\"EM_TYPE\"),\"VAR\") & ABBREV(EM_TYPE,\"HTML\") THEN      /*COPY*/\n       sm = SOCKET(\"WRITE\",_sid,'Content-Type: text/html;',             /*COPY*/\n                                'charset=\"ISO-8859-1\"'crlf)             /*COPY*/\n  ELSE sm = SOCKET(\"WRITE\",_sid,'Content-Type: text/plain;',            /*COPY*/\n                                'charset=\"ISO-8859-1\"'crlf)             /*COPY*/\n  sm = SOCKET(\"WRITE\",_sid,'Content-Transfer-Encoding: 7bit'crlf||crlf) /*COPY*/\n  /* Add eMail Body Text                                              *//*COPY*/\n  DO i = 1 TO em.body.0; sm = SOCKET(\"WRITE\",_sid,em.body.i||crlf); END /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MAILATCH */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n Read any MIME Attachments identified in the EMCNTL, set MIME Header,   /*COPY*/\n      ENCODE when necessary, and then write as MIME Attachment.         /*COPY*/\n***********************************************************************//*COPY*/\nEMAIL_ATTACHMENTS:                                                      /*COPY*/\n  DO k = 1 TO em.atch.0                                                 /*COPY*/\n      IF TOKEN = \"\" THEN ADDRESS \"MVS\",                                 /*COPY*/\n         \"EXECIO * DISKR\" em.atch.k.dd \"(STEM em.atch.\"k\". FINIS\"       /*COPY*/\n      IF em.atch.k.0 = 0    THEN ITERATE k  /* Empty Attachement      *//*COPY*/\n      IF em.atch.k.dat = \"\" THEN em.atch.k.dat = dte                    /*COPY*/\n      SELECT                                /* Add MIME Type info     *//*COPY*/\n        WHEN ABBREV(\"PLAIN\", em.atch.k.typ) THEN DO                     /*COPY*/\n           MimeHeader = crlf'--'mbound || crlf,                         /*COPY*/\n              ||'Content-Type: text/plain; name=\"'em.atch.k.fnm'\"'crlf, /*COPY*/\n              ||'Content-Disposition: attachment; ',                    /*COPY*/\n              ||        'filename=\"'em.atch.k.fnm'\"; ',                 /*COPY*/\n              ||        'modification-date=\"'em.atch.k.dat'\"'crlf,      /*COPY*/\n              ||'Content-Transfer-Encoding: 7bit'crlf                   /*COPY*/\n           sm = SOCKET(\"WRITE\",_sid,MimeHeader||crlf)                   /*COPY*/\n           DO j = 1 TO em.atch.k.0          /* Add Attachment file    *//*COPY*/\n              sm = SOCKET(\"WRITE\",_sid,em.atch.k.j||crlf)               /*COPY*/\n           END                                                          /*COPY*/\n          END                                                           /*COPY*/\n        WHEN ABBREV(\"HTML\", em.atch.k.typ)  THEN DO                     /*COPY*/\n           MimeHeader = crlf'--'mbound || crlf,                         /*COPY*/\n              ||'Content-Type: text/html; name=\"'em.atch.k.fnm'\"'crlf,  /*COPY*/\n              ||'Content-Disposition: attachment; ',                    /*COPY*/\n              ||        'filename=\"'em.atch.k.fnm'\"; ',                 /*COPY*/\n              ||        'modification-date=\"'em.atch.k.dat'\"'crlf,      /*COPY*/\n              ||        'charset=iso-8859-1'crlf                        /*COPY*/\n           sm = SOCKET(\"WRITE\",_sid,MimeHeader||crlf)                   /*COPY*/\n           DO j = 1 TO em.atch.k.0          /* Add Attachment file    *//*COPY*/\n              sm = SOCKET(\"WRITE\",_sid,em.atch.k.j||crlf)               /*COPY*/\n           END                                                          /*COPY*/\n          END                                                           /*COPY*/\n        WHEN ABBREV(\"OCTET-STREAM\", em.atch.k.typ) THEN DO              /*COPY*/\n           MimeHeader = crlf'--'mbound || crlf,                         /*COPY*/\n              ||'Content-Type: application/octet-stream; ',             /*COPY*/\n              ||              'name=\"'em.atch.k.fnm'\"'crlf,             /*COPY*/\n              ||'Content-Disposition: attachment; ',                    /*COPY*/\n              ||        'filename=\"'em.atch.k.fnm'\"; ',                 /*COPY*/\n              ||        'modification-date=\"'em.atch.k.dat'\"'crlf,      /*COPY*/\n              ||'Content-Transfer-Encoding: 7bit'crlf                   /*COPY*/\n           sm = SOCKET(\"WRITE\",_sid,MimeHeader||crlf)                   /*COPY*/\n           DO j = 1 TO em.atch.k.0          /* Add Attachment         *//*COPY*/\n              sm = SOCKET(\"WRITE\",_sid,em.atch.k.j||crlf)               /*COPY*/\n           END                                                          /*COPY*/\n          END                                                           /*COPY*/\n        WHEN k=1 & ABBREV(\"INLINE\", em.atch.k.typ) THEN,                /*COPY*/\n          DO j = 1 TO em.atch.k.0                                       /*COPY*/\n            sm = SOCKET(\"WRITE\",_sid,em.atch.k.j||crlf)                 /*COPY*/\n          END                                                           /*COPY*/\n        WHEN ABBREV(\"INLINE\", em.atch.k.typ)       THEN DO              /*COPY*/\n           MimeHeader = crlf'--'mbound || crlf,                         /*COPY*/\n              ||'Content-Type: text/plain; charset=\"ISO-8859-1\"'crlf,   /*COPY*/\n              ||'Content-Disposition: inline'crlf,                      /*COPY*/\n              ||'Content-Transfer-Encoding: 7bit'crlf                   /*COPY*/\n           sm = SOCKET(\"WRITE\",_sid,MimeHeader||crlf)                   /*COPY*/\n           DO j = 1 TO em.atch.k.0          /* Add Inline file        *//*COPY*/\n              sm = SOCKET(\"WRITE\",_sid,em.atch.k.j||crlf)               /*COPY*/\n           END                                                          /*COPY*/\n          END                                                           /*COPY*/\n      OTHERWISE   /* ENCODE64 CBT Rexx Function must be available     *//*COPY*/\n         MimeHeader = crlf'--'mbound || crlf,                           /*COPY*/\n            ||'Content-Type: application/octet-stream; ',               /*COPY*/\n            ||              'name=\"'em.atch.k.fnm'\"'crlf,               /*COPY*/\n            ||'Content-Disposition: attachment; ',                      /*COPY*/\n            ||        'filename=\"'em.atch.k.fnm'\"; ',                   /*COPY*/\n            ||        'modification-date=\"'em.atch.k.dat'\"'crlf,        /*COPY*/\n            ||'Content-Transfer-Encoding: base64'crlf                   /*COPY*/\n         sm = SOCKET(\"WRITE\",_sid,MimeHeader||crlf)                     /*COPY*/\n         x = ENCODE64(\"em.atch.k.\",\"_atch_64.\")  /* Convert to Base64 *//*COPY*/\n         DO j = 1 TO _atch_64.0                  /* Add ENCODEd file  *//*COPY*/\n            sm = SOCKET(\"WRITE\",_sid,_atch_64.j||crlf)                  /*COPY*/\n         END                                                            /*COPY*/\n      END                                                               /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MAILSOCK */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Initialize Socket and get necessary info from TCP/IP Stack.       /*COPY*/\n***********************************************************************//*COPY*/\nINIT_SMTP_SOCKET:                                                       /*COPY*/\n  sm = SOCKET(\"INITIALIZE\",\"SMTP01\")       /* Init RXSOCKET API       *//*COPY*/\n    IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"INITIALIZE\", sm          /*COPY*/\n  sm = SOCKET(\"SOCKET\",\"AF_INET\",\"STREAM\") /* Init IP4 TCP Socket     *//*COPY*/\n    IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"SOCKET\", sm              /*COPY*/\n       ELSE _sid = WORD(sm,2)                                           /*COPY*/\n  sm = SOCKET(\"GETHOSTNAME\")               /* Get HOSTNAME            *//*COPY*/\n    IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"GETHOSTNAME\", sm         /*COPY*/\n       ELSE HOSTNAME = WORD(sm,2)                                       /*COPY*/\n  sm = SOCKET(\"GETDOMAINNAME\")             /* Get Domain              *//*COPY*/\n    IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"GETDOMAINNAME\", sm       /*COPY*/\n       ELSE DOMAINNAME = WORD(sm,2)                                     /*COPY*/\n  IF ABBREV(\"DEFAULT\", SERVER) & \u00ac(DATATYPE(PORT, \"NUM\")) THEN DO       /*COPY*/\n      sm = SOCKET(\"GETSERVBYNAME\", \"SMTP\") /* Get local SMTP Port     *//*COPY*/\n         IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"GETSERVBYNAME\", sm  /*COPY*/\n            ELSE PORT = WORD(sm,3)                                      /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE IF ABBREV(\"DEFAULT\",PORT) THEN PORT = 25                         /*COPY*/\n                                           /* Translate to ASCII      *//*COPY*/\n  sm = SOCKET(\"SETSOCKOPT\",_sid,\"SOL_SOCKET\",\"SO_ASCII\",\"ON\")           /*COPY*/\n     IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"SETSOCKOPT\", sm         /*COPY*/\n                                           /* Connect to SMTP Server  *//*COPY*/\n  IF ABBREV(\"DEFAULT\", SERVER) THEN SERVER = HOSTNAME\".\"DOMAINNAME      /*COPY*/\n  sm = SOCKET(\"CONNECT\",_sid,\"AF_INET\" PORT SERVER)                     /*COPY*/\n     IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"CONNECT\", sm            /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n      Connect to SMTP Server and Send SMTP Header control commands.     /*COPY*/\n***********************************************************************//*COPY*/\nEMAIL_HEADER:                                                           /*COPY*/\n  sm = SOCKET(\"WRITE\",_sid,\"HELO\" SERVER||crlf) /* Start SMTP Session *//*COPY*/\n     IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"WRITE\", sm              /*COPY*/\n     ELSE DO                                                            /*COPY*/\n        sm = SOCKET(\"READ\",_sid)                                        /*COPY*/\n        IF WORD(sm,3) \u00ac= \"220\" THEN                                     /*COPY*/\n           CALL SOCKET_ERR \"HELO\" SERVER, WORD(sm,3) sm                 /*COPY*/\n     END                                     /* Set SMTP From:        *//*COPY*/\n  PARSE VALUE em.hdr.fm WITH . \"<\" _from_ \">\" .                         /*COPY*/\n  sm = SOCKET(\"WRITE\",_sid, \"MAIL FROM: <\"_from_\">\"crlf)                /*COPY*/\n     IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"WRITE\", sm              /*COPY*/\n     ELSE DO                                                            /*COPY*/\n        sm = SOCKET(\"READ\",_sid)                                        /*COPY*/\n        IF WORD(sm,3) \u00ac= \"250\" THEN                                     /*COPY*/\n           CALL SOCKET_ERR \"MAIL FROM:\", WORD(sm,3) sm                  /*COPY*/\n     END                                                                /*COPY*/\n  DO i = 1 TO em.hdr.to.0                    /* eMail TO: Addresses   *//*COPY*/\n      PARSE VALUE em.hdr.to.i WITH . \"<\" _to_ \">\" .                     /*COPY*/\n      sm = SOCKET(\"WRITE\",_sid, \"RCPT TO: <\"_to_\">\"crlf)                /*COPY*/\n      IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"WRITE\", sm             /*COPY*/\n      ELSE DO                                                           /*COPY*/\n         sm = SOCKET(\"READ\",_sid)                                       /*COPY*/\n         IF WORDPOS(WORD(sm,3), \"250 251\") = 0 THEN                     /*COPY*/\n            CALL SOCKET_ERR \"RCPT TO:\" em.hdr.to.i, WORD(sm,3) sm       /*COPY*/\n      END                                                               /*COPY*/\n  END                                                                   /*COPY*/\n  DO i = 1 TO em.hdr.cc.0                    /* eMail CC: Addresses   *//*COPY*/\n      PARSE VALUE em.hdr.cc.i WITH . \"<\" _cc_ \">\" .                     /*COPY*/\n      sm = SOCKET(\"WRITE\",_sid, \"RCPT TO: <\"_cc_\">\"crlf)                /*COPY*/\n      IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"WRITE\", sm             /*COPY*/\n      ELSE DO                                                           /*COPY*/\n         sm = SOCKET(\"READ\",_sid)                                       /*COPY*/\n         IF WORDPOS(WORD(sm,3), \"250 251\") = 0 THEN                     /*COPY*/\n            CALL SOCKET_ERR \"RCPT TO:\" em.hdr.cc.i, WORD(sm,3) sm       /*COPY*/\n      END                                                               /*COPY*/\n  END                                                                   /*COPY*/\n  DO i = 1 TO em.hdr.bc.0                    /* eMail BCC: Addresses  *//*COPY*/\n      PARSE VALUE em.hdr.bc.i WITH . \"<\" _bc_ \">\" .                     /*COPY*/\n      sm = SOCKET(\"WRITE\",_sid, \"RCPT TO: <\"_bc_\">\"crlf)                /*COPY*/\n      IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"WRITE\", sm             /*COPY*/\n      ELSE DO                                                           /*COPY*/\n         sm = SOCKET(\"READ\",_sid)                                       /*COPY*/\n         IF WORDPOS(WORD(sm,3), \"250 251\") = 0 THEN                     /*COPY*/\n            CALL SOCKET_ERR \"RCPT TO:\" em.hdr.bc.i, WORD(sm,3) sm       /*COPY*/\n      END                                                               /*COPY*/\n  END                                        /* End SMTP Header       *//*COPY*/\n  sm = SOCKET(\"WRITE\",_sid, \"DATA\"||crlf)                               /*COPY*/\n  IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"WRITE\", sm                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     sm = SOCKET(\"READ\",_sid)                                           /*COPY*/\n     IF WORDPOS(WORD(sm,3), \"250 354\") = 0 THEN                         /*COPY*/\n        CALL SOCKET_ERR \"DATA\", WORD(sm,3) sm                           /*COPY*/\n  END                                                                   /*COPY*/\n  IF em.hdr.rec \u00ac= \"\"   THEN DO              /* Start eMail Headers   *//*COPY*/\n       sm = SOCKET(\"WRITE\",_sid, \"Received:\" em.hdr.rec||crlf)          /*COPY*/\n       sm = SOCKET(\"WRITE\",_sid, \"Date:\" dte||crlf)                     /*COPY*/\n       PARSE VALUE TIME(\"S\") WITH hh \":\" mm \":\" ss .                    /*COPY*/\n       sm = SOCKET(\"WRITE\",_sid, \"Message-ID:\",                         /*COPY*/\n                    DATE(\"S\")||hh||mm||ss\".\"mid||EM_DOM||crlf)          /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE sm = SOCKET(\"WRITE\",_sid, \"Date:\" dte||crlf)                     /*COPY*/\n  sm = SOCKET(\"WRITE\",_sid, \"From:\" em.hdr.fm||crlf)                    /*COPY*/\n  IF em.hdr.rep \u00ac= \"\" THEN                                              /*COPY*/\n     sm = SOCKET(\"WRITE\",_sid, \"Reply-to:\" em.hdr.rep  ||crlf)          /*COPY*/\n  ELSE DO i = 1 TO em.hdr.rep.0                                         /*COPY*/\n     sm = SOCKET(\"WRITE\",_sid, \"Reply-to:\" em.hdr.rep.i||crlf)          /*COPY*/\n  END                                                                   /*COPY*/\n  DO i = 1 TO em.hdr.to.0                                               /*COPY*/\n     sm = SOCKET(\"WRITE\",_sid,\"To:\" em.hdr.to.i||crlf)                  /*COPY*/\n  END                                                                   /*COPY*/\n  DO i = 1 TO em.hdr.cc.0                                               /*COPY*/\n     sm = SOCKET(\"WRITE\",_sid,\"Cc:\" em.hdr.cc.i||crlf)                  /*COPY*/\n  END                                                                   /*COPY*/\n  IF em.hdr.sub \u00ac= \"\" THEN                                              /*COPY*/\n       sm = SOCKET(\"WRITE\",_sid, \"Subject:\" em.hdr.sub||crlf)           /*COPY*/\n  IF em.hdr.com \u00ac= \"\" THEN                   /* eMail Header Comment  *//*COPY*/\n       sm = SOCKET(\"WRITE\",_sid, \"Comment:\" em.hdr.com||crlf)           /*COPY*/\n  sm = SOCKET(\"WRITE\",_sid, \"Importance:\" em.hdr.imp||crlf)             /*COPY*/\n                                             /* This will use MIME    *//*COPY*/\n  sm = SOCKET(\"WRITE\",_sid, \"MIME-Version: 1.0\"crlf)                    /*COPY*/\n  sm = SOCKET(\"WRITE\",_sid, \"Content-Type: multipart/mixed;\",           /*COPY*/\n                            'boundary=\"'mbound'\"'crlf)                  /*COPY*/\n  IF em.hdr.ret \u00ac= \"\" THEN                   /* Return-Path           *//*COPY*/\n       sm = SOCKET(\"WRITE\",_sid, \"Return-Path:\" em.hdr.ret||crlf)       /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n      Send End-of-MIME indicater, SMTP End-of-Message indicator,        /*COPY*/\n      and then close SMTP session.                                      /*COPY*/\n***********************************************************************//*COPY*/\nCLOSE_eMail:                                                            /*COPY*/\n  IF (em.body.0 + em.atch.0) > 0 THEN sm =,                             /*COPY*/\n       SOCKET(\"WRITE\",_sid, crlf||\"--\"mbound\"--\"||crlf)                 /*COPY*/\n  sm = SOCKET(\"WRITE\",_sid, crlf\".\"crlf)     /* SMTP End of Message   *//*COPY*/\n     IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"WRITE\", sm              /*COPY*/\n     ELSE DO                                                            /*COPY*/\n        sm = SOCKET(\"READ\",_sid)                                        /*COPY*/\n        IF \u00ac(ABBREV(sm,\"0\")) & WORD(sm,3) = \"250\" THEN                  /*COPY*/\n             CALL SOCKET_ERR \"SENDMAIL\", sm                             /*COPY*/\n        ELSE CALL SET_MSG \"eMail Sent.\", sm,\"NO\"                        /*COPY*/\n     END                                                                /*COPY*/\n  sm = SOCKET(\"WRITE\",_sid, \"RSET\"crlf)                                 /*COPY*/\n  sm = SOCKET(\"READ\",_sid)                                              /*COPY*/\n  sm = SOCKET(\"WRITE\",_sid, \"QUIT\"crlf)      /* Complete SMTP Session *//*COPY*/\n  sm = SOCKET(\"READ\",_sid)                                              /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n      Close and Terminate Socket connection.                            /*COPY*/\n***********************************************************************//*COPY*/\nCLOSE_SMTP_SOCKET:                                                      /*COPY*/\n  sm = SOCKET(\"CLOSE\", _sid)                 /* Disconnect Socket     *//*COPY*/\n     IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"CLOSE\", sm              /*COPY*/\n  sm = SOCKET(\"TERMINATE\", \"SMTP01\")         /* End RXSOCKET API      *//*COPY*/\n     IF \u00ac(ABBREV(sm,\"0\")) THEN CALL SOCKET_ERR \"TERMINATE\", sm          /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n    Report RXSOCKET Error and then fall through to CLEANUP              /*COPY*/\n***********************************************************************//*COPY*/\nSOCKET_ERR:                                                             /*COPY*/\nARG _type_, ExitError _msg_                                             /*COPY*/\n  DO eline = sigl-1 TO 1 BY -1                                          /*COPY*/\n     IF INDEX(STRIP(SOURCELINE(eline)),\"SOCKET(\") > 0 THEN LEAVE eline  /*COPY*/\n  END                                                                   /*COPY*/\n  IF eline > 1 THEN line = STRIP(SOURCELINE(eline))                     /*COPY*/\n     ELSE           line = STRIP(SOURCELINE(sigl-1))                    /*COPY*/\n  CALL SET_MSG \" Socket RC:\" ExitError, _type_ \"Error:\" _msg_, \"YES\"    /*COPY*/\n  CALL SET_MSG \"Error Line:\" eline, line, \"YES\"                         /*COPY*/\n  sm = SOCKET(\"CLOSE\", _sid)           /* Disconnect Socket           *//*COPY*/\n  sm = SOCKET(\"TERMINATE\", \"SMTP01\")   /* End RXSOCKET API            *//*COPY*/\nEXIT ExitError                         /* Set TSO/MVS RC to error RC  *//*COPY*/\n/**********************************************************************\n            Cleanup and Exit Gracefully\n***********************************************************************/\nCLEANUP:\n  ok='*'                               /* Ignore all non-0 RCs        */\n    sm = SOCKET(\"CLOSE\", _sid)         /* Disconnect Socket           */\n    sm = SOCKET(\"TERMINATE\", \"SMTP01\") /* End RXSOCKET API            */\nEXIT ExitError                         /* Set TSO/MVS RC to error RC  */\n/* COPY ERRMVS */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n                                                                        /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n  CALL MVS_ERROR_DISPLAY            /* Display collected error info   *//*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n     nextl = SOURCELINE(elineno + e_i)                                  /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)        /*COPY*/\n     sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                      /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause  = ERRORTEXT(RC)       /* Brief description of error     */ /*COPY*/\n     expandl = \"Can't INTERPRET source with SYNTAX errors!\"             /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst = \"ADDRESS CALL INTERPRET SAY\"                                 /*COPY*/\n     ecause  = CONDITION('D')       /* Brief description of error     *//*COPY*/\n     FullLine = sourcel             /* Begin getting EXECuted source  *//*COPY*/\n     expandl = \"\"                                                       /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals = VALUE(srcl); END                             /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl = expandl';' evals                                      /*COPY*/\n     END                                                                /*COPY*/\n     expandl = STRIP(STRIP(expandl,\"L\",\";\"))                            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg = ZERRLM                                                 /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg = 'No available ERROR description.'                      /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                             /*COPY*/\n     ELSE emsg = SYSMSGLVL1                                             /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg = \"SYSREASON: '\"SYSREASON\"'\"                             /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError = 4    /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError = RC                                                /*COPY*/\n  erc = ExitError       /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SMFPARM": {"ttr": 1799, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x015\\x00&\\x01\\x01 o\\x01\\x08\\x19\\x7f\\x157\\x01\\x99\\x01~\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.53", "flags": 0, "createdate": "2001-07-25T00:00:00", "modifydate": "2008-07-15T15:37:26", "lines": 409, "newlines": 382, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n\n This REXX builds the IFASMFDP (SMF DUMP Utility) control records for\n      for TAPE Batch processing. It's primary purpose is the dynamic\n      creation of the \"DATE(start_date,end_date)\" card based off of\n      passed parameters.\n\n This REXX does NOT Require TSO, it will run in batch under IRXJCL.\n\n                           --- EXAMPLE ---\nIRXJCL SMFPARM start finish <ADJUST(TRUE|FALSE)> <BEGIN(start_time)> ,\n           <END(end_time)> <TEST(trace_option)>\nTSO <%>SMFPARM start finish <ADJUST(TRUE|FALSE)> <BEGIN(start_time)> ,\n           <END(end_time)> <TEST(trace_option)>\nTSO <%>SMFPARM -H -- To display help for this REXX\n\n  Arguments: start       - The first day SMF records that are desired.\n                           FORMAT: yyyy-mm-dd, -days_ago, \"YESTERDAY\",\n                                   \"TODAY\", \"LASTMONTH\", & \"LASTWEEK\"\n             finish      - The last day SMF records that are desired.\n                           FORMAT: yyyy-mm-dd, -days_ago, or blank\n             inparms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                  ADJUST - ADJUST the \"start\" to handle weekends.\n                           default: FALSE\n                   BEGIN - Begin time for the start Date in HHMM format\n                           default: blank          <=== i.e. 0000\n                     END - End time for the finish Date in HHMM format\n                           default: blank          <=== i.e. 2400\n                    TEST - Used to control traces\n\n      Files: OUTPUT DD is SMFDPARM\nOther EXECS: DATEX    - For date calculations in building Subject line.\n\nEXEC History\n\n REXX EXEC Name: SMFPARM\n         Author: Al Ferguson (HUL2353)\n         Writen: 25JUL01\n        History: 14JUL08 - Version 1.45 - Remove TSO Dependencies so\n                           SMFPARM can run under IRXJCL.\n                 17MAR06 - Version 1.42 - Fix LASTMONTH Code\n                 15MAR06 - Version 1.40 - Remove support for NMDATE, as\n                           it does not work with IFASMFDP.\n                 14MAR06 - Version 1.38 - Add support for \"LASTWEEK\"\n                 13MAR06 - Version 1.36 - Add support for \"LASTMONTH\"\n                 20MAY04 - Version 1.34 - First Functional Version.\n                 26FEB04 - Version 1.00 - Based off of RACFSMF\n\n***************************** Rexx ***********************************/\nPARSE ARG start finish inparms               /* Place arguments here */\n\nIF WORDPOS(start,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n    ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"  /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nSELECT\n  WHEN ABBREV(start, \"LASTMONTH\") THEN DO\n      PARSE VALUE DATEX(\"TODAY\")     WITH yyyy\"-\"mm\"-\"dd\".\" jjj base_date .\n      PARSE VALUE DATEX(mm 1 yyyy)   WITH yyyy\"-\"mm\"-\"dd\".\" jjj base_date .\n      PARSE VALUE DATEX(base_date-1) WITH yyyy\"-\"mm\"-\"dd\".\" jjj .\n      end_date = yyyy || jjj\n      PARSE VALUE DATEX(mm 1 yyyy)   WITH yyyy\"-\"mm\"-\"dd\".\" jjj .\n      start_date = yyyy || jjj\n    END\n  WHEN ABBREV(start, \"LASTWEEK\")  THEN DO\n      x = WORDPOS(dow, days_of_week)\n      PARSE VALUE DATEX(base_date-(x+6)) WITH yyyy \"-\" . \".\" jjj .\n      start_date = yyyy || jjj\n      PARSE VALUE DATEX(base_date-x)     WITH yyyy \"-\" . \".\" jjj .\n      end_date = yyyy || jjj\n    END\n  WHEN ABBREV(start, \"YESTERDAY\") THEN DO\n      start_date = yesterday_jjj\n      end_date = yesterday_jjj\n    END\n  WHEN ABBREV(start, \"TODAY\")     THEN DO\n      start_date = today_jjj\n      end_date   = today_jjj\n    END\n  WHEN start < 0                  THEN DO\n      PARSE VALUE DATEX(base_date+start) WITH yyyy \"-\" . \".\" jjj .\n      start_date = yyyy || jjj\n      IF finish \u00ac= \"\" & finish \u00ac= \".\" THEN DO\n          PARSE VALUE DATEX(base_date+finish) WITH yyyy \"-\" . \".\" jjj .\n          end_date = yyyy || jjj\n        END\n      ELSE end_date = today_jjj\n    END\n  WHEN start = \"\"                 THEN DO\n      SAY \"=====>\"\n      SAY \"=====> I need at least a START Date to create IFASMFDP Parameters!\"\n      SAY \"=====>\"\n      EXIT 8\n    END\nOTHERWISE\n    PARSE VALUE start             WITH yyyy \"-\" mm  \"-\" dd .\n    PARSE VALUE DATEX(mm dd yyyy) WITH yyyy \"-\" . \".\" jjj .\n    start_date = yyyy || jjj\n    IF finish \u00ac= \"\" & finish \u00ac= \".\" THEN DO\n        PARSE VALUE finish            WITH yyyy \"-\" mm  \"-\" dd .\n        PARSE VALUE DATEX(mm dd yyyy) WITH yyyy \"-\" . \".\" jjj .\n        end_date = yyyy || jjj\n      END\n    ELSE end_date = today_jjj\nEND\n\nQUEUE \"  DATE(\"start_date\",\"end_date\")\"\nIF BEGIN \u00ac= \"\" THEN QUEUE \"  START(\"BEGIN\")\"\nIF END   \u00ac= \"\" THEN QUEUE \"  END(\"END\")\"\nok='0';ADDRESS \"MVS\" \"EXECIO\" QUEUED() \"DISKW SMFDPARM (FINIS\"\n\nEXIT exit_error\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE = 1; FALSE = 0  /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  valid_parms = \"ADJUST(FALSE) BEGIN() END() LEVEL1() LEVEL2() TEST(O)\"\n  match_length = 6                /* NP-Parms match on first # chars  */\n  IF valid_parms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  no_submited = 0\n  SYSUID = USERID()\n  user_prefix = LEFT(SYSUID,4)\n  exit_error = 0; sql_error = 0\n  SYSMSGLVL1 = \"\"; SYSMSGLVL2 = \"\"\n  Lower = \"abcdefghijklmnopqrstuvwxyz\"\n  Upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  days_of_week = \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\"\n\n  IF ADJUST \u00ac= TRUE THEN ADJUST = FALSE\n\n  PARSE VALUE DATEX(\"TODAY\")       WITH yyyy\"-\"mm\"-\"dd\".\" jjj base_date dow\n  today_jjj     = yyyy || jjj\n  PARSE VALUE DATEX(base_date - 1) WITH yyyy \"-\" . \".\" jjj .\n  yesterday_jjj = yyyy || jjj\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG exit_or_return .                                                    /*COPY*/\n  DO i = 1 TO SOURCELINE() UNTIL SOURCELINE(i + 2) = 'EXEC History'     /*COPY*/\n      source.i = SOURCELINE(i + 1)  /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO   /* No ISPF, use SAY to display help            *//*COPY*/\n      DO i = 1 TO i                                                     /*COPY*/\n          SAY source.i                                                  /*COPY*/\n      END                                                               /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n      PARSE SOURCE . . rname .      /* Get REXX EXEC name             *//*COPY*/\n                                                                        /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\" /*COPY*/\n      DO i = 1 TO i    /* Build HELP table to display                 *//*COPY*/\n          source = source.i                                             /*COPY*/\n          ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"                             /*COPY*/\n      END                                                               /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                          /*COPY*/\n      ZTDMARK = CENTER(\"----> END of Help <----\",80)                    /*COPY*/\n      ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"     /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                        /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',exit_or_return,3) THEN RETURN                        /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Possitional Parms in a           /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  vp_list = valid_parms ' '; in_list = inparms ' '                      /*COPY*/\n  parm_list = ''; parm_error_list = ''                                  /*COPY*/\n                                                                        /*COPY*/\n  DO linx = 1 TO WORDS(valid_parms) UNTIL vp_list = ''                  /*COPY*/\n      PARSE VALUE vp_list WITH parm.linx '(' parm_val.linx ') ' vp_list /*COPY*/\n      parm_list = parm_list STRIP(LEFT(parm.linx,match_length))         /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(in_list, '(') > 0                                      /*COPY*/\n      PARSE VALUE in_list WITH parm '(' value ') ' in_list              /*COPY*/\n      UPPER parm           /* Don't want to translate value to UPPER */ /*COPY*/\n      parm = STRIP(parm)                                                /*COPY*/\n      parm_number = WORDPOS(STRIP(LEFT(parm,match_length)), parm_list)  /*COPY*/\n      IF parm_number > 0 THEN parm_val.parm_number = value              /*COPY*/\n      ELSE IF INDEX(value,\")\") > 0 THEN                                 /*COPY*/\n           parm_error_list = parm_error_list parm\"(\"value               /*COPY*/\n      ELSE parm_error_list = parm_error_list parm\"(\"value\")\"            /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN parm_error_list \u00ac= '' & accept_all = TRUE THEN                 /*COPY*/\n        anything_else = STRIP(in_list) parm_error_list                  /*COPY*/\n    WHEN parm_error_list \u00ac= ''                     THEN DO              /*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"parm_error_list\"' is an/are invalid Parm(s)\", \"YES\"      /*COPY*/\n        EXIT 8                                                          /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      anything_else = STRIP(in_list)                                    /*COPY*/\n  END                                                                   /*COPY*/\n  DO parm_inx = 1 TO linx                                               /*COPY*/\n      SELECT                                                            /*COPY*/\n        WHEN ABBREV(parm_val.parm_inx, \"&\")               |,            /*COPY*/\n             ABBREV(parm_val.parm_inx, \"*\")               THEN          /*COPY*/\n            INTERPRET parm.parm_inx \"= '\"parm_val.parm_inx\"'\"           /*COPY*/\n        WHEN DATATYPE(parm_val.parm_inx, \"NUM\")           THEN          /*COPY*/\n            INTERPRET parm.parm_inx \"=\" parm_val.parm_inx               /*COPY*/\n        WHEN WORDPOS(parm_val.parm_inx, \"FALSE TRUE\") > 0 THEN          /*COPY*/\n            INTERPRET parm.parm_inx \"=\" parm_val.parm_inx               /*COPY*/\n        WHEN (LEFT(parm_val.parm_inx,1) = \"'\"             & ,           /*COPY*/\n              RIGHT(parm_val.parm_inx,1) = \"'\")           | ,           /*COPY*/\n             INDEX(parm_val.parm_inx,':') > 0             | ,           /*COPY*/\n             INDEX(parm_val.parm_inx,'*') > 0             | ,           /*COPY*/\n             INDEX(parm_val.parm_inx,'%') > 0             | ,           /*COPY*/\n             INDEX(parm_val.parm_inx,'=') > 0             THEN          /*COPY*/\n            INTERPRET parm.parm_inx \"= parm_val.\"parm_inx               /*COPY*/\n        WHEN INDEX(STRIP(parm_val.parm_inx), \" \") > 0     THEN          /*COPY*/\n            INTERPRET parm.parm_inx \"=\" parm_val.parm_inx               /*COPY*/\n      OTHERWISE                                                         /*COPY*/\n          ADDRESS \"MVS\" \"SUBCOM TSO\"                                    /*COPY*/\n          IF RC = 0 THEN TSO_avail = TRUE; ELSE TSO_avail = FALSE       /*COPY*/\n          PARSE VALUE parm_val.parm_inx WITH PDS_name '(' rest          /*COPY*/\n          SELECT                                                        /*COPY*/\n            WHEN \u00ac(TSO_avail)                            THEN           /*COPY*/\n                INTERPRET parm.parm_inx \"=\" parm_val.parm_inx           /*COPY*/\n            WHEN SYSVAR(\"SYSNEST\") = 'YES'               THEN           /*COPY*/\n                INTERPRET parm.parm_inx \"=\" parm_val.parm_inx           /*COPY*/\n            WHEN (INDEX(rest, \")\") > 0                   &,             /*COPY*/\n                 (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")   |,             /*COPY*/\n                  ABBREV(rest, \"0)\")))                   THEN           /*COPY*/\n                INTERPRET parm.parm_inx \"= '\"parm_val.parm_inx\"'\"       /*COPY*/\n            WHEN (LISTDSI(parm_val.parm_inx)       <= 4  | ,            /*COPY*/\n                  LISTDSI(\"'\"parm_val.parm_inx\"'\") <= 4  | ,            /*COPY*/\n                  LISTDSI(\"'\"PDS_name\"'\")          <= 4  | ,            /*COPY*/\n                  LISTDSI(PDS_name)                <= 4) THEN           /*COPY*/\n                INTERPRET parm.parm_inx \"= parm_val.\"parm_inx           /*COPY*/\n          OTHERWISE                                                     /*COPY*/\n                INTERPRET parm.parm_inx \"=\" parm_val.parm_inx           /*COPY*/\n          END                                                           /*COPY*/\n          INTERPRET parm.parm_inx \"=\" parm_val.parm_inx                 /*COPY*/\n      END                                                               /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM                              /*COPY*/\n  IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'                   /*COPY*/\n     ELSE ZERRALRM = 'NO'                                               /*COPY*/\n  IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                       /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ002)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRMVS   */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok = '*' THEN RETURN  /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  CALL MVS_ERROR_DISPLAY            /* Display collected error info   *//*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  SIGNAL OFF SYNTAX                 /* Turn off all ERROR Trapping    *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n                                                                        /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype   = CONDITION('C')          /* Condition causing error        *//*COPY*/\n  sourcel = SOURCELINE(elineno)     /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel = LEFT(sourcel,72)     /*COPY*/\n  sourcel = STRIP(sourcel)                                              /*COPY*/\n  DO e_i = 1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)               /*COPY*/\n      nextl = SOURCELINE(elineno + e_i)                                 /*COPY*/\n      IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl = LEFT(nextl,72)       /*COPY*/\n      sourcel = STRIP(sourcel,'T',',') STRIP(nextl)                     /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n      ecause  = ERRORTEXT(RC)       /* Brief description of error     *//*COPY*/\n      expandl = \"Can't INTERPRET source with SYNTAX errors!\"            /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n      ecause  = CONDITION('D')      /* Brief description of error     *//*COPY*/\n      full_line = sourcel           /* Begin getting EXECuted source  *//*COPY*/\n      PARSE VALUE full_line WITH srcl ';' full_line                     /*COPY*/\n      IF \u00ac(ABBREV(STRIP(srcl),\"CALL\")) &,                               /*COPY*/\n         \u00ac(ABBREV(STRIP(srcl),\"SAY\"))  THEN INTERPRET \"evals =\" srcl    /*COPY*/\n          ELSE evals = \"\"                                               /*COPY*/\n      IF DATATYPE(evals, \"NUM\") | evals = \"\" THEN evals = srcl          /*COPY*/\n      expandl = evals                                                   /*COPY*/\n      DO WHILE full_line \u00ac= ''      /* loop to handle ';' in source   *//*COPY*/\n          PARSE VALUE full_line WITH srcl ';' full_line                 /*COPY*/\n          IF \u00ac(ABBREV(STRIP(srcl),\"CALL\")) THEN INTERPRET \"evals =\" srcl/*COPY*/\n              ELSE evals = \"\"                                           /*COPY*/\n          IF DATATYPE(evals, \"NUM\") | evals = \"\" THEN evals = srcl      /*COPY*/\n          expandl = expandl ';' evals                                   /*COPY*/\n      END                                                               /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR'      THEN           /*COPY*/\n         emsg = ZERRLM                                                  /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') = 'VAR' & SYSMSGLVL1 \u00ac= \"\" THEN           /*COPY*/\n         IF SYMBOL('SYSMSGLVL2') = 'VAR'                 THEN           /*COPY*/\n              emsg = SYSMSGLVL1 \"--\" SYSMSGLVL2                         /*COPY*/\n         ELSE emsg = SYSMSGLVL1                                         /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      emsg = 'No available ERROR description.'                          /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0 THEN                      /*COPY*/\n     QUEUE \"SYSREASON: '\"SYSREASON\"'\"                                   /*COPY*/\n  IF etype = 'NOVALUE' THEN exit_error = 4   /* Set EXIT error level  *//*COPY*/\n     ELSE exit_error = RC                                               /*COPY*/\n  erc = exit_error      /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  TRACE(\"O\")                                                            /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresults = 1 TO eresult.0                                          /*COPY*/\n      PARSE PULL eresult.eresults                                       /*COPY*/\n  END                                                                   /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls) /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY CENTER(LEFT('          Error Type:' etype,80),ls)                 /*COPY*/\n  SAY CENTER(LEFT('         Error Cause:' ecause,80),ls)                /*COPY*/\n  SAY CENTER(LEFT('                  RC:' erc,80),ls)                   /*COPY*/\n  SAY CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)             /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n      SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)  /*COPY*/\n  END                                                                   /*COPY*/\n  SAY CENTER(LEFT('         Source Line:' elineno,80),ls)               /*COPY*/\n  SAY LEFT('   Error Description:' emsg,ls)                             /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY LEFT('Source line reads as:' sourcel,ls)                          /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY LEFT('  Source EXECutes as:' expandl,ls)                          /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\n  SAY ''                                                                /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\nEXIT exit_error                     /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TESTMAIL": {"ttr": 2052, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00I\\x01\\x08\\x19o\\x01\\x17%O\\t\\x01\\x01h\\x01r\\x00\\x00\\xc1\\xd3`\\xc6\\xc5\\xd9\\xc7@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2008-07-14T00:00:00", "modifydate": "2017-09-11T09:01:49", "lines": 360, "newlines": 370, "modlines": 0, "user": "AL-FERG"}, "text": "/***************************** REXX ***********************************\n\n This REXX is a sample SENDMAIL Calling REXX. It builds the EMBODY,\n      EMCNTL, and an INLINE Signature File. Then it calls the\n      SENDMAIL RXSOCKET API REXX to actually send the eMail message.\n\n                           --- EXAMPLE ---\nTSO <%>TESTMAIL SMTP_server <TEST(trace_option)>\nTSO <%>TESTMAIL -H -- To display help for this REXX\n\n  Arguments: SMTP_server - The SMTP Server you will be connecting to.\n             inparms     - Non-Positional parameters\n ----------------------------- NP-PARMS -------------------------------\n                    TEST - Used to control traces\n\n      Files: EMBODY   -\n             EMCNTL   -\n             SIGNATUR -\nOther EXECS: SENDMAIL\n\nEXEC History\n\n REXX EXEC Name: TESTMAIL\n         Author: FERGUSON AL (HUL2353)\n         Writen: 14JUL08\n        History: 14JUL08 - Version 1.0\n\n***************************** Rexx ***********************************/\nmsgstat = MSG(\"OFF\")\nPARSE ARG SMTP_server inparms                /* Place arguments here */\n\nIF WORDPOS(SMTP_server,'-h -H') > 0 THEN CALL DISPLAY_HELP\nCALL INITIALIZE_THIS_REXX\n/* COPY ERRINIT */\n/********************************************************************** /*COPY*/\n              Initialize ERROR handling                                 /*COPY*/\n***********************************************************************//*COPY*/\nCALL ON ERROR     NAME ERROR_PROC   /* On RCs > 0 CALL ERROR_PROC     *//*COPY*/\nSIGNAL ON HALT    NAME CLEANUP      /* Cleanup before exiting on HALT *//*COPY*/\nSIGNAL ON SYNTAX  NAME ERROR_PROC   /* On REXX Syntax Error GOTO ...  *//*COPY*/\nSIGNAL ON NOVALUE NAME ERROR_PROC   /* On uninitialized variable GOTO *//*COPY*/\nok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"  /* Is ISPEXEC available?       *//*COPY*/\nIF RC = 0 THEN DO                   /* Yes, then allow REXX to handle *//*COPY*/\n   ok='0';ADDRESS \"ISPEXEC\" \"CONTROL ERRORS RETURN\"   /* ISPF errors  *//*COPY*/\nEND                                                                     /*COPY*/\n                                                                        /*COPY*/\nTRACE (TEST)\nok='0';ADDRESS \"TSO\" \"NEWSTACK\"\n  ADDRESS \"TSO\" \"ALLOC DD(EMBODY) NEW REUSE\"                  ,\n                \"UNIT(VIO) AVGREC(U) AVBLOCK(80) SPACE(10,50)\",\n                \"DSORG(PS) RECFM(F B) LRECL(131) BLKSIZE(0)\"\n  QUEUE \"This is a test message using a CALLing REXX to test the\",\n        \"SENDMAIL RXSOCKET REXX.\"\n  ADDRESS \"MVS\" \"EXECIO\" QUEUED() \"DISKW EMBODY (FINIS\"\n\n  ADDRESS \"TSO\" \"ALLOC DD(EMCNTL) NEW REUSE\"                  ,\n                \"UNIT(VIO) AVGREC(U) AVBLOCK(80) SPACE(10,50)\",\n                \"DSORG(PS) RECFM(F B) LRECL(131) BLKSIZE(0)\"\n  QUEUE \"Received: YourEmailAddress@your_domain.com\"\n  QUEUE \"From: YourEmailAddress@your_domain.com\"\n  QUEUE \"To: YourEmailAddress@your_domain.com\"\n  QUEUE \"Subject: Testing CALL to SENDMAIL RXSOCKET REXX.\"\n  QUEUE \"Comment: RXSOCKET API for SMTP Email comment enbedded in header.\"\n  QUEUE \"Attachment: SIGNATUR inline\"\n  ADDRESS \"MVS\" \"EXECIO\" QUEUED() \"DISKW EMCNTL (FINIS\"\n\n  ADDRESS \"TSO\" \"ALLOC DD(SIGNATUR) NEW REUSE\"                ,\n                \"UNIT(VIO) AVGREC(U) AVBLOCK(80) SPACE(10,50)\",\n                \"DSORG(PS) RECFM(F B) LRECL(131) BLKSIZE(0)\"\n  QUEUE \"\"\n  QUEUE \"_______________\"\n  QUEUE \"\"\n  QUEUE \"Your Full Name     | mailto:YourEmailAddress@your_domain.com\"\n  QUEUE \"Technical Support  |  phone: ###-###-####\"\n  QUEUE \"Your Company Name  |    fax: ###-###-####\"\n  QUEUE \"Suite 12345\n  ADDRESS \"MVS\" \"EXECIO\" QUEUED() \"DISKW SIGNATUR (FINIS\"\nok='0';ADDRESS \"TSO\" \"DELSTACK\"\n\nx = SENDMAIL(\"IMPORT(Low) SERVER(\"SMTP_server\") TEST(\"TEST\")\")\n\nok='0'\n  ADDRESS \"TSO\" \"FREE DD(EMBODY)\"\n  ADDRESS \"TSO\" \"FREE DD(EMCNTL)\"\n  ADDRESS \"TSO\" \"FREE DD(SIGNATUR)\"\n\nmsgstat = MSG(msgstat)\nEXIT ExitError\n/***************************** REXX ***********************************\n                            END of REXX\n****************************** REXX ***********************************\n                       Beginning of PROCEDURES\n****************************** REXX ***********************************/\n/**********************************************************************\n     This Initializes any variables needed for this REXX\n***********************************************************************/\nINITIALIZE_THIS_REXX:\n  TRUE=1; FALSE=0      /* REXX functional values for TRUE and FALSE   */\n                       /* Initialize and process non-positional parms */\n  valid_parms=\"TEST(O)\"\n  match_length=4       /* NP-Parms match on first # chars             */\n  accept_all=FALSE     /* Allow un-recognized NP-PARMS to be passed   */\n  IF valid_parms \u00ac= '' THEN CALL DO_NP_PARMS\n\n  no_submited=0\n  exit_error=0\n  SYSMSGLVL1=\"\"; SYSMSGLVL2=\"\"\n  Lower=\"abcdefghijklmnopqrstuvwxyz\"; Upper=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  PARSE SOURCE . . rname .          /* Get REXX EXEC name             */\n  jname=MVSVAR(\"SYMDEF\",\"JOBNAME\")\n\nRETURN\n/* COPY DISHELP */\n/********************************************************************** /*COPY*/\n            This PROCEDURE displays the Help information in             /*COPY*/\n                 this REXX's HEADER when invoked.                       /*COPY*/\n***********************************************************************//*COPY*/\nDISPLAY_HELP: PROCEDURE                                                 /*COPY*/\nARG ExitOrReturn .                                                      /*COPY*/\n  DO i=1 TO SOURCELINE() UNTIL SOURCELINE(i+2) = 'EXEC History'         /*COPY*/\n     source.i=SOURCELINE(i + 1)     /* Read in HELP from EXEC         *//*COPY*/\n  END                                                                   /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  IF RC \u00ac= 0 THEN DO i=1 TO i; SAY source.i; END   /* No ISPF, so SAY *//*COPY*/\n  ELSE DO              /* ISPF available, use TBDISPL to display help *//*COPY*/\n     PARSE SOURCE . . rname .       /* Get REXX EXEC name             *//*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCREATE RHELP02 NAMES(source) NOWRITE\"  /*COPY*/\n     DO i=1 TO i       /* Build HELP table to display                 *//*COPY*/\n        source=source.i; ADDRESS \"ISPEXEC\" \"TBADD RHELP02\"              /*COPY*/\n     END                                                                /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBTOP RHELP02\"                           /*COPY*/\n     ZTDMARK=CENTER(\"----> END of Help <----\",80)                       /*COPY*/\n     ok='0 4 8';ADDRESS \"ISPEXEC\" \"TBDISPL RHELP02 PANEL(RHELP02)\"      /*COPY*/\n     ok='0';ADDRESS \"ISPEXEC\" \"TBCLOSE RHELP02\"                         /*COPY*/\n  END                                                                   /*COPY*/\n                      /* Stay inside current EXEC or EXIT             *//*COPY*/\nIF ABBREV('RETURN',ExitOrReturn,3) THEN RETURN                          /*COPY*/\n   ELSE EXIT 0                                                          /*COPY*/\n/* COPY NPPARMS */\n/********************************************************************** /*COPY*/\n            Initialize and process Non-Positional Parms in a            /*COPY*/\n                method similar to that of CLISTs                        /*COPY*/\n    NOTE: If you use parentheses in the initizing of a NP-Parms, do     /*COPY*/\n          not follow any internal ')' with spaces!!                     /*COPY*/\n**********************************************************************/ /*COPY*/\nDO_NP_PARMS:                                                            /*COPY*/\n  VpList=ValidParms ' ';InList=InParms ' ';ParmList='';ParmErrorList='' /*COPY*/\n                                                                        /*COPY*/\n  DO linx=1 TO WORDS(ValidParms) UNTIL VpList = ''                      /*COPY*/\n     PARSE VALUE VpList WITH parm.linx '(' ParmVal.linx ') ' VpList     /*COPY*/\n     ParmList=ParmList STRIP(LEFT(parm.linx,MatchLength))               /*COPY*/\n  END                                                                   /*COPY*/\n  DO WHILE INDEX(InList, '(') > 0                                       /*COPY*/\n     PARSE VALUE InList WITH parm '(' value ') ' InList                 /*COPY*/\n     UPPER parm            /* Don't want to translate value to UPPER */ /*COPY*/\n     parm=STRIP(parm)                                                   /*COPY*/\n     ParmNumber=WORDPOS(STRIP(LEFT(parm,MatchLength)), ParmList)        /*COPY*/\n     IF ParmNumber > 0 THEN ParmVal.ParmNumber=value                    /*COPY*/\n     ELSE IF INDEX(value,\")\") > 0 THEN                                  /*COPY*/\n          ParmErrorList=ParmErrorList parm\"(\"value                      /*COPY*/\n     ELSE ParmErrorList=ParmErrorList parm\"(\"value\")\"                   /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN ParmErrorList \u00ac= '' & AcceptAll = TRUE          THEN           /*COPY*/\n       AnythingElse=STRIP(InList) ParmErrorList                         /*COPY*/\n    WHEN ParmErrorList \u00ac= ''                             THEN DO        /*COPY*/\n       PARSE SOURCE . . rname .        /* Get REXX EXEC name          *//*COPY*/\n       CALL SET_MSG 'Invalid Parameter(s)',,                            /*COPY*/\n            \"'\"ParmErrorList\"' not valid Parm(s) for\" rname\"!\", \"YES\"   /*COPY*/\n       EXIT 8                                                           /*COPY*/\n      END                                                               /*COPY*/\n  OTHERWISE; AnythingElse=STRIP(InList); END                            /*COPY*/\n  DO ParmInx=1 TO linx                                                  /*COPY*/\n     SELECT                                                             /*COPY*/\n       WHEN ABBREV(ParmVal.ParmInx, \"&\")                 |,             /*COPY*/\n            ABBREV(ParmVal.ParmInx, \"*\")                 THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"               /*COPY*/\n       WHEN DATATYPE(ParmVal.ParmInx, \"NUM\")             THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN WORDPOS(ParmVal.ParmInx, \"FALSE TRUE\") > 0   THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n       WHEN (LEFT(ParmVal.ParmInx,1) = \"'\"               & ,            /*COPY*/\n             RIGHT(ParmVal.ParmInx,1) = \"'\")             | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,':') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'*') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'%') > 0               | ,            /*COPY*/\n            INDEX(ParmVal.ParmInx,'=') > 0               THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                   /*COPY*/\n       WHEN INDEX(STRIP(ParmVal.ParmInx), \" \") > 0       THEN           /*COPY*/\n           INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                   /*COPY*/\n     OTHERWISE                                                          /*COPY*/\n        ADDRESS \"MVS\" \"SUBCOM TSO\"                                      /*COPY*/\n        IF RC = 0 THEN TSO_avail=TRUE; ELSE TSO_avail=FALSE             /*COPY*/\n        PARSE VALUE ParmVal.ParmInx WITH PDS_name '(' rest              /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN \u00ac(TSO_avail) | PDS_name = \"\"              THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN SYSVAR(\"SYSNEST\") = 'YES'                 THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n          WHEN (INDEX(rest, \")\") > 0                     &,             /*COPY*/\n               (ABBREV(rest, \"+\") | ABBREV(rest,\"-\")     |,             /*COPY*/\n                ABBREV(rest, \"0)\")))                     THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= '\"ParmVal.ParmInx\"'\"            /*COPY*/\n          WHEN (LISTDSI(ParmVal.ParmInx)           <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"ParmVal.ParmInx\"'\")     <= 4  | ,            /*COPY*/\n                LISTDSI(\"'\"PDS_name\"'\")            <= 4  | ,            /*COPY*/\n                LISTDSI(PDS_name)                  <= 4) THEN           /*COPY*/\n              INTERPRET parm.ParmInx \"= ParmVal.\"ParmInx                /*COPY*/\n        OTHERWISE                                                       /*COPY*/\n              INTERPRET parm.ParmInx \"=\" ParmVal.ParmInx                /*COPY*/\n        END                                                             /*COPY*/\n     END                                                                /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY SETMSG */                                                       /*COPY*/\n/********************************************************************** /*COPY*/\n              Error with DSN, Use ISPF to display Error Message         /*COPY*/\n***********************************************************************//*COPY*/\nSET_MSG: PROCEDURE                                                      /*COPY*/\nPARSE ARG ZERRSM, ZERRLM, ZERRALRM, ZERRHM, ZERRTP, ZERRWN .            /*COPY*/\n  ok='*';ADDRESS \"MVS\" \"SUBCOM ISPEXEC\"                                 /*COPY*/\n  SELECT                                                                /*COPY*/\n   WHEN RC \u00ac= 0                   THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n   WHEN SYSVAR(\"SYSNEST\") = 'YES' &,                                    /*COPY*/\n        SYSVAR('SYSENV') = 'BACK' THEN DO                               /*COPY*/\n      SAY ''; SAY ZERRSM ; SAY ZERRLM; SAY ''                           /*COPY*/\n    END                                                                 /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n      IF ABBREV('YES', ZERRALRM, 1) THEN ZERRALRM = 'YES'               /*COPY*/\n         ELSE ZERRALRM = 'NO'                                           /*COPY*/\n      IF ZERRHM    = ''    THEN ZERRHM   = 'ISR2MACR'                   /*COPY*/\n      ok='0';ADDRESS \"ISPEXEC\" \"SETMSG MSG(ISRZ003)\"                    /*COPY*/\n  END                                                                   /*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRPROC */\n/********************************************************************** /*COPY*/\n      Error Handling procedure -- SHOULD BE LAST PROCEDURES IN REXX     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_PROC:                                                             /*COPY*/\n  IF (CONDITION('C') = 'ERROR') & (SYMBOL('OK') = 'VAR') THEN ,         /*COPY*/\n     IF (WORDPOS(RC, ok) > 0) | ok='*' THEN RETURN    /* Not an ERROR *//*COPY*/\n                                                                        /*COPY*/\n  TRACE(\"O\")                        /* Turn off ERROR traps et.al.    *//*COPY*/\n  elineno = sigl                    /* Source line error occured in   *//*COPY*/\n  SIGNAL OFF SYNTAX                 /* ... all Error trapping OFF     *//*COPY*/\n  SIGNAL OFF NOVALUE                                                    /*COPY*/\n  CALL   OFF ERROR                                                      /*COPY*/\n  CALL GET_ERROR_INFO               /* Get information about error    *//*COPY*/\n                                                                        /*COPY*/\n  \"SUBCOM ISPEXEC\"                  /* Is ISPF available?             *//*COPY*/\n  IF RC = 0 THEN IF SYSVAR('SYSENV') \u00ac= 'BACK' THEN DO UNTIL RC \u00ac= 0    /*COPY*/\n        eresults = \"\"                                                   /*COPY*/\n        DO QUEUED()                                                     /*COPY*/\n           PARSE PULL eresult                                           /*COPY*/\n           eresults = STRIP(eresults \"NL ===>\" eresult)                 /*COPY*/\n        END                                                             /*COPY*/\n        ADDRESS \"ISPEXEC\" \"DISPLAY PANEL(REXXEPNL)\"                     /*COPY*/\n      END                                                               /*COPY*/\n    ELSE CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n  ELSE   CALL MVS_ERROR_DISPLAY                                         /*COPY*/\n                                                                        /*COPY*/\n  CALL ERROR_RESPONSE               /* EXEC dependent ERROR handling  *//*COPY*/\n  CALL CLEANUP                      /* Cleanup and EXIT gracefully    *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY ERRINFO  */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n      Get the information about the ERROR and format it                 /*COPY*/\n***********************************************************************//*COPY*/\nGET_ERROR_INFO:                                                         /*COPY*/\n  PARSE SOURCE . . erexx .          /* Get REXX EXEC name             *//*COPY*/\n  etype  =CONDITION('C')            /* Condition causing error        *//*COPY*/\n  sourcel=SOURCELINE(elineno)       /* Start getting error source line*//*COPY*/\n  IF INDEX(sourcel,'/*COPY*/') = 73 THEN sourcel=LEFT(sourcel,72)       /*COPY*/\n  sourcel=STRIP(sourcel)                                                /*COPY*/\n  DO e_i=1 WHILE LASTPOS(',',sourcel) = LENGTH(sourcel)                 /*COPY*/\n     nextl=SOURCELINE(elineno + e_i)                                    /*COPY*/\n     IF INDEX(nextl,'/*COPY*/') = 73 THEN nextl=LEFT(nextl,72)          /*COPY*/\n     sourcel=STRIP(sourcel,'T',',') STRIP(nextl)                        /*COPY*/\n  END                           /* END loop to handle continued lines *//*COPY*/\n  IF etype = 'SYNTAX' THEN DO                                           /*COPY*/\n     ecause =ERRORTEXT(RC)         /* Brief description of error     */ /*COPY*/\n     expandl=\"Can't INTERPRET source with SYNTAX errors!\"               /*COPY*/\n    END                                                                 /*COPY*/\n  ELSE DO                                                               /*COPY*/\n     Lst=\"ADDRESS CALL INTERPRET SAY\"                                   /*COPY*/\n     ecause  =CONDITION('D')        /* Brief description of error     *//*COPY*/\n     FullLine=sourcel               /* Begin getting EXECuted source  *//*COPY*/\n     expandl =\"\"                                                        /*COPY*/\n     DO UNTIL FullLine = ''         /* loop to handle ';' in source   *//*COPY*/\n        PARSE VALUE FullLine WITH srcl ';' FullLine                     /*COPY*/\n        SELECT                                                          /*COPY*/\n          WHEN WORDPOS(WORD(srcl,1),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN WORDPOS(WORD(srcl,2),Lst) > 0        THEN evals=srcl     /*COPY*/\n          WHEN INDEX(srcl,\"=\")           > 1        THEN evals=srcl     /*COPY*/\n        OTHERWISE; evals=VALUE(srcl); END                               /*COPY*/\n        IF DATATYPE(evals, \"NUM\")                   THEN evals=srcl     /*COPY*/\n        expandl=expandl';' evals                                        /*COPY*/\n     END                                                                /*COPY*/\n     expandl=STRIP(STRIP(expandl,\"L\",\";\"))                              /*COPY*/\n  END                                                                   /*COPY*/\n  SELECT                                                                /*COPY*/\n    WHEN etype = 'ERROR' & SYMBOL('ZERRLM') = 'VAR' THEN                /*COPY*/\n          emsg=ZERRLM                                                   /*COPY*/\n    WHEN SYMBOL('SYSMSGLVL1') \u00ac= 'VAR'              THEN                /*COPY*/\n          emsg='No available ERROR description.'                        /*COPY*/\n    WHEN SYSMSGLVL1 = \"\"                            THEN                /*COPY*/\n          emsg='No available ERROR description.'                        /*COPY*/\n  OTHERWISE                                                             /*COPY*/\n     IF SYMBOL('SYSMSGLVL2') = 'VAR'                THEN                /*COPY*/\n          emsg=SYSMSGLVL1 \"--\" SYSMSGLVL2                               /*COPY*/\n     ELSE emsg=SYSMSGLVL1                                               /*COPY*/\n  END                                                                   /*COPY*/\n  IF INDEX(emsg, \"IN VARIABLE SYSREASON\") > 0       THEN                /*COPY*/\n          emsg=\"SYSREASON: '\"SYSREASON\"'\"                               /*COPY*/\n  IF etype = 'NOVALUE' THEN ExitError=4      /* Set EXIT error level  *//*COPY*/\n     ELSE ExitError=RC                                                  /*COPY*/\n  erc=ExitError         /* Get all information about error            *//*COPY*/\nRETURN                                                                  /*COPY*/\n/* COPY MVSERROR */                                                     /*COPY*/\n/********************************************************************** /*COPY*/\n                 Output ERROR information to SYSPRINT                   /*COPY*/\n***********************************************************************//*COPY*/\nMVS_ERROR_DISPLAY:                                                      /*COPY*/\n  eresult. = \"\";eresult.0 = QUEUED() /* Get info currently on STACK   *//*COPY*/\n  DO eresult = 1 TO eresult.0; PARSE PULL eresult.eresult; END          /*COPY*/\n  ls = LINESIZE()                   /* How wide is the display?       *//*COPY*/\n  IF ls <= 80 THEN ls2 = ls; ELSE ls2 = ls - 30                         /*COPY*/\n  SAY ''                            /* Start SAYing error information *//*COPY*/\n  SAY  CENTER(CENTER(\" An ERROR occurred in REXX '\"erexx\"' \",50,'*'),ls)/*COPY*/\n  SAY    CENTER(LEFT('          Error Type:' etype,80),ls)              /*COPY*/\n  SAY    CENTER(LEFT('         Error Cause:' ecause,80),ls)             /*COPY*/\n  SAY    CENTER(LEFT('                  RC:' erc,80),ls)                /*COPY*/\n  SAY    CENTER(LEFT('      Stack Contents:' eresult.1,80),ls)          /*COPY*/\n  DO eresults = 2 TO eresult.0                                          /*COPY*/\n     SAY CENTER(LEFT('                     ' eresult.eresults,80),ls)   /*COPY*/\n  END                                                                   /*COPY*/\n  SAY    CENTER(LEFT('         Source Line:' elineno,80),ls)            /*COPY*/\n  SAY           LEFT('   Error Description:' emsg,ls)                   /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY           LEFT('Source line reads as:' sourcel,ls)                /*COPY*/\n  SAY ''                                                                /*COPY*/\n  SAY          LEFT('  Source EXECutes as:' expandl,ls)                 /*COPY*/\n  SAY CENTER(CENTER(\"      End of ERROR Reporting     \",50,'*'),ls)     /*COPY*/\n  SAY CENTER(CENTER(\"   Beginning of Error Handling   \",50,'*'),ls)     /*COPY*/\nRETURN                                                                  /*COPY*/\n/********************************************************************** /*COPY*/\n        In case ERROR_RESPONSE and CLEANUP are not supplied             /*COPY*/\n   REXX allows Multiple PROCEDUREs with same name, but always uses      /*COPY*/\n   the first one found.  So, a REXX specific version of these can       /*COPY*/\n   be use writen if it is placed before ERROR_PROC.                     /*COPY*/\n***********************************************************************//*COPY*/\nERROR_RESPONSE:                     /* Dummy ERROR_RESPONSE PROC      *//*COPY*/\nRETURN                                                                  /*COPY*/\nCLEANUP:                            /* Simple CLEANUP PROC            *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"FTCLOSE\"       /* CLOSE File Tailoring FILE      *//*COPY*/\n  ZISPFRC = ExitError               /* SET ISPF RC to ExitError       *//*COPY*/\n  ADDRESS \"ISPEXEC\" \"VPUT (ZISPFRC)\"                                    /*COPY*/\nEXIT ExitError                      /* EXIT with error return code    *//*COPY*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT789/FILE789.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT789", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}