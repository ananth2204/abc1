{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011521000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1528436, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 13, "INMDSNAM": "CBT.V500.FILE220.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1528436, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1528436, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE220.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x19\\x08'", "DS1TRBAL": "b'\\x9d\\xa6'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x01\\x94\\x00\\x04\\x01\\x95\\x00\\x0e\\x00\\x1a'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04]\\x00\\x00\\x01\\x165?\\x01\\x165?\\x15)\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf3@@@'", "ispf": {"version": "04.93", "flags": 0, "createdate": "2016-12-18T00:00:00", "modifydate": "2016-12-18T15:29:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-493"}, "text": "REGULAR CBT TAPE - VERSION 493    FILE:  220\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT493.FILE220\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 45 MEMBERS COUNTED; CUMULATIVE SIZE IS 13,988 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   12/18/16    15:28:59    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$FB80": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x13\\x01\\x14\\x06O\\x01\\x15\\x03?\\x10Y\\x00$\\x00$\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2014-03-05T00:00:00", "modifydate": "2015-02-02T10:59:13", "lines": 36, "newlines": 36, "modlines": 0, "user": "SBGOLOB"}, "text": "Note from Sam Golob     (March 5, 2014)\n\nAddition to CBT File 220, from CBT File 221.\n\nI converted many of the LIST*** REXXes to FB-80, so I could\ninclude them in my SYSPROC concatenation which is FB-80, as\nopposed to VB-255.  These are really valuable and\neasily installable tools, to help you (or the auditors) to get\na better insight into the specific workings of your MVS\nsystem.\n\nThe REXXes that I have not yet converted, are the ones which\ndon't seem to work right under z/OS 1.13 (although I may have\nmissed one or two which do work).  These are on my \"to do\" list,\nto improve, both in the FB-80 and VB-255 versions.\n\nNotes on this:\n  LISTDCQ has been fixed for z/OS by Tony Cieri.\n  LISTDASD and LISTTAPE have been fixed by Tony Cieri.\n\nThe IO*** members have not been converted.\n\nLee Conyers (who has passed on) was really an expert auditor\nand he knew a lot about what makes the system tick, especially\nin those areas that an auditor has to watch.  It is a pleasure\nto be able to use his excellent tools.  That is why I have\ntried to make them even more useful, for today's environment.\n\nFor the record, SHOWzOS on CBT File 492 (load module collection\non CBT File 614) is also extremely useful to supplement this\ninformation obtainable with the REXXes here.\n\nAll the best of everything to all of you.\n\nSam\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE01": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Q\\x01\\x14\\x07\\x8f\\x01\\x14\\x07\\x8f\"#\\x006\\x006\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-03-19T00:00:00", "modifydate": "2014-03-19T22:23:51", "lines": 54, "newlines": 54, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  RE: Converted some REXXes to FB-80\nFrom:     \"Cieri, Anthony\" <ACieri@seic.com>\nDate:     3/19/2014 2:14 PM\nTo:       Sam Golob <sbgolob@cbttape.org>\n\nHi Sam,\n\nThanks for the updates!!!\n\nI like the REXXES member in File 220.  It make it easier to copy\nthem right into your SYSPROC dataset(s).  Also, I had a look at\nyour UCBTYPE command from File 731 and I like that too.  Just like\nUCBDASD and UCBTAPE, they make a suitable alternative for the\nLISTDCQ, LISTDASD and LISTTAPE Rexxs from File 221.\n\nAlso, I took the liberty of modifying the LISTDCQ command (Rexx)\nfrom File 221.  This new version uses the same logic for scanning\nthe DCQ as before, but now, uses the ULUT for scanning the UCBs\nin the system.  (Thanks to the education you UCBTYPE command\nprovided me!!!)  It really provides the same information as\nUCBTYPE, but it is written in Rexx.\n\nI offer it for your review in case you would like to include it\nin File 221.  It is attached to this email!!\n\nIt is interesting to note that UCBs that have been moved \"above\nthe line\" are NOT chained in the DCQ.\n\nThanks\nTony\n\n   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nFrom: Sam Golob \u00ddmailto:sbgolob@cbttape.org\u00a8\nSent: Wednesday, March 05, 2014 10:18 AM\nTo: Cieri, Anthony\nSubject: Converted some REXXes to FB-80\n\nHi Tony,\n\nI converted some of the REXXes in File 221 to FB-80 and put them\non File 220 as member REXXES.  I also added a member to File 220\ncalled $$$FB80 which describes what I did.  Please take a look\nand see what you think.  I also hope to try and fix some of the\nREXXes that don't work on z/OS, but that's for later.\n\nPlease let me know what you think.\n\nAll the best of everything to you and your family.\n\nSincerely,   Sam\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE02": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00B\\x01\\x14\\x08O\\x01\\x14\\x08O!I\\x00/\\x00/\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-03-25T00:00:00", "modifydate": "2014-03-25T21:49:42", "lines": 47, "newlines": 47, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  RE: Converted some REXXes to FB-80\nFrom:     \"Cieri, Anthony\" <ACieri@seic.com>\nDate:     3/24/2014 6:45 PM\nTo:       Sam Golob <sbgolob@cbttape.org>\n\nHi Sam,\n\nI apologize for the repeat email, but I found a few things in my\nprevious attempt that did not make me happy!!\n\nI have attached an updated LISTDCQ rexx command.  The previous\nversion did NOT check for the Ulut type. I am not sure how many\nfolks are running older version of z/OS than 1.7, but the last\niteration of my LISTDCQ would NOT have worked for them.\n\nAlso, the original version from file 221 compared the total\nscanned UCBs to the counts provided in the DCQ header. This\nupdated version now compares the scanned UCBs to the counts\nproved in the ULUT header.\n\nI am happier with this version, I hope you are too.\n\nThanks\nTony\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFrom: Sam Golob \u00ddmailto:sbgolob@cbttape.org\u00a8\nSent: Wednesday, March 19, 2014 9:13 PM\nTo: Cieri, Anthony\nSubject: Re: Converted some REXXes to FB-80\n\nHi Tony,\n\n    What a pleasure it is to hear from you!  I was going to fix\n    LISTDCQ the exact same way, but you beat me to it.  I am\n    glad, because you learned a bunch of stuff along the way.\n    Thanks for pointing out that the DCQ was partially obsolete\n    because of UCBs being moved above the line.\n\n    I haven't tried your stuff out yet, but I will, in about 5\n    minutes.\n\n    All the best of everything to you and your family.\n\nSincerely,    Sam\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$README": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00\\x00\\x00\\x94'\\x8f\\x00\\x94(\\x0f\\x112\\x00\\x89\\x00\\x82\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "1994-10-05T00:00:00", "modifydate": "1994-10-07T11:32:00", "lines": 137, "newlines": 130, "modlines": 0, "user": "SBGCSC"}, "text": "            INTRODUCTION TO THE AUDITMVS STARTER KIT\n            ----------------------------------------\n\n\nThis file contains the AUDITMVS starter kit software.  The kit\nconsists of utility software to collect and analyze data from an\noperational MVS system.  It will greatly assist in documenting the\nAuthorized Program Facility (APF) environment, including all APF\nlibraries, Supervisor Call (SVC) routines, Extended SVC Router (ESR)\nroutines, Program Call (PC) routines, and Link Pack Area (LPA)\nprograms (i.e., Pageable, Modified, Fixed LPA; and other items along\nthe LPA Queue).\n\nThe software consists mostly of REXX and SAS programs.  In addition,\nthere are several assembly language programs to disassemble MVS\nsoftware from object code back to assembly language.  There is also\nan assembly language program that uses the SNAP macro to retrieve the\nProgram Call table from the PCAUTH address space.\n\nThe contents of this diskette should be uploaded to the MVS system\nthat is to be audited.  All of the files, except the REXX programs,\nmay be placed into individual members of a standard FB 80 partitioned\ndata set (PDS).  The REXX programs sometimes exceed line lengths\nbeyond 72 characters--therefore, a VB 255 PDS is recommended.  Both\nFB 80 and VB 255 formats are supported by the ISPF/PDF editor.  To\nsummarize, the following diskette-directory-to-MVS-PDS upload\nstructure is suggested:\n\n     File Member                      MVS PDS and DCB Info\n     ------------------        ----------------------------------\n\n     ADVCAATS                  userid.DISASM.CNTL         FB   80\n     MISC                      userid.CNTL                FB   80\n     REXX                      userid.EXEC                VB  255\n     SAS                       userid.SAS.CNTL            FB   80\n\nSome of the starter kit programs also require a number of MVS support\nfiles.  For example, the IO* REXX programs are data collectors which\nwrite to various VB 255 physical sequential data sets.  These data\nsets are then read by the SAS programs for analysis and reporting.\nYou will have to allocate and name these to your own preference, and\nedit the REXX and SAS programs accordingly.  There is one support\ndata set that must be formatted specifically to support the output of\nthe SNAP macro.  See the assembly language program (SNAPPC.ASM in the\nMISC directory) for these specific DCB parameters.\n\n\nADVCAATS\n--------\n\nThis library contains source code for a old, old (but very useful)\npublic domain disassembler.  The disassembler has been extended to\nperform in-storage disassembly if the code resides below the 16 MB\nline.  See the file $$README for more information.\n\n\nMISC\n----\n\nThis library contains several *.JCL files.  ALLOCGDG.JCL shows how\nto define a generation data group (GDG) should you want to build a\nsystem of audit jobs that maintain snapshot cycles of data sets for\nyour MVS system.  IKJEFT01.JCL shows how to run your REXX programs in\n\"batch mode\" TSO.  Other JCL files provide examples of lengthy job\nstreams for multiple audit steps.  This library also contains the\nSNAPPC.ASM file for obtaining your MVS systems PC table.\n\n\nREXX\n----\n\nThis library contains a wide variety of REXX programs that collect\ndata from an operational MVS system.  All are stand alone programs\nexcept for #NUCLKUP, which is an external REXX CALLable procedure\nthat seaches the nucleus map for an entry name and returns its entry\npoint address.  #NUCLKUP is currently CALLed by IOSVCT, IOESRT,\nLISTSVCT, and LISTESRT.  SDUMP is a general purpose formatted display\nstorage dump program.  The VSDATA1 program is a modified version of\nSDUMP which displays several in-storage control blocks.\n\nThe IO* series of programs collect data and write to \"WORK.DATA\" data\nsets.  The LIST* series of programs can all be executed interactively\nto display MVS internals data to your terminal screen.  Acronyms used\nwithin the naming scheme for these programs are:\n\n   ADSP     ADdress SPace\n   APFP     APF libraries Programs\n   APFT     APF Table\n   CATS     CATalogS\n   CONS     CONsoleS\n   DASD     Direct Access Storage Devices list\n   DCQ      Device Class Queue\n   ENV      ENVironmental information\n   ESRT     ESR Table\n   LLT      Linklist Libraries Table\n   LLTP     LLT libraries Programs\n   LPAQ     LPA Queue\n   LPAT     LPA libraries Table\n   NUCM     NUCleus Map\n   PART     Paging Activity Reference Table\n   PDSD     PDS Directory\n   PDSM     PDS Members\n   PCAUTH   Program Call AUTHorization table\n   PLPA     Pageable LPA programs\n   SART     Swapping Activity Reference Table\n   SFT      System Function Table\n   SMAP     Storage MAP information\n   SMF      System Management Facility information\n   SSN      SubSystem Name table\n   SVCJ     SVC Journal table\n   SVCT     SVC Table\n   TAPE     TAPE devices list\n   VMAP     Virtual storage MAP\n\nThe NOT@OR file is a ready reference of the EBCDIC hex codes for the\n\"and\" and \"or\" characters.  These two characters are hard to remember\nwhen one uses several different microcomputer keyboard maps\nassociated with various 3270 emulation software packages.\n\n\nSAS\n---\n\nThis library contains SAS programs which report from the various\nfiles created by the IO* series of REXX programs.  The APFPDUP,\nLLTPDUP, LPAPDUP, ESRMATCH, PCMATCH, and SVCMATCH programs\ndemonstrate the power of the SAS MERGE function.\n\n\n      Lee Conyers\n      U.S. Department of Transportation\n      700 4th Street SW\n      Room 7404, M-35\n      Washington, DC  20590\n      (202) 366-1126\n\n                                          -- vlc (3/27/94)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$PDSLOAD": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00Y\\x01\\x026_\\x01\\x14\\x07\\x8f!Q\\x00\\x15\\x00\\x08\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2002-12-31T00:00:00", "modifydate": "2014-03-19T21:51:59", "lines": 21, "newlines": 8, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBL JOB (ACCT#),PDSLOAD,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X\n//*\n//*    PDSLOAD JOB TO CREATE FB-80 REXX LIBRARY\n//*\n//TSOBATCH EXEC PGM=IKJEFT01\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN DD *\n   RECEIVE INDS('SBGOLOB.CBT488.FILE220(PDSLOAD)')\n   DSN ('SBGOLOB.FILE220.LOADLIB') VOL(WORKE2)\n/*\n//*\n//LOAD   EXEC PGM=PDSLOAD\n//STEPLIB  DD DISP=SHR,DSN=SBGOLOB.FILE220.LOADLIB\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD DISP=SHR,DSN=SBGOLOB.CBT488.FILE220(REXXES)\n//SYSUT2   DD UNIT=SYSALLDA,VOL=SER=WORKE2,\n//             DSN=SBGOLOB.FB80PDS.FILE220,\n//             DISP=(NEW,CATLG,DELETE),\n//             SPACE=(TRK,(30,45,44),RLSE)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#NUCLKUP": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x08\\x8f\\x00\\x94\\x08\\x8f\\x10\\x00\\x00%\\x00%\\x00\\x00\\xc3\\xd6\\xd5\\xe8\\xc5\\xd9\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "1994-03-29T10:00:00", "lines": 37, "newlines": 37, "modlines": 0, "user": "CONYERS"}, "text": "/*REXX*/\n/*****************************************************************/\n/*#NUCLKUP: REXX external procedure to scan nucleus map.         */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*              NUCMP - Nucleus Map Table (16 bytes by n rows)   */\n/*****************************************************************/\nArg target\nNumeric Digits 10\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtnucmp = STORAGE(D2X(X2D(@cvt)+1200),4)   /* get CVTNUCMP address  */\n@cvtnucmp = D2X(C2D(@cvtnucmp))                /* binary to hex       */\nnucmapid  = STORAGE(@cvtnucmp,8)           /* nucmap eyecatcher entry */\nnucmeot   = C2D(STORAGE(D2X(X2D(@cvtnucmp)+8),4))  /* table end addrs */\nnucmlen   = C2D(STORAGE(D2X(X2D(@cvtnucmp)+13),3)) /* nucm tbl length */\n@nucmentry= X2D(@cvtnucmp)+16          /* address of 1st nucmap entry */\nepaddr = 'FFFFFFFF'                  /* initialize with invalid value */\nIf nucmapid \\= 'NUCMAP  ' Then Do\n   Say 'Error: Nucleus map table eyecatcher not found'\n   Exit\n   End\ni = 0   /* target = 'IGCERROR' */\nDo While @nucmentry <= nucmeot                  /* loop thru storage  */\n   i = i + 1\n   epname   = STORAGE(D2X(@nucmentry),8)      /* get entry point name */\n   If epname = target Then Do\n      epaddr = C2X(STORAGE(D2X(@nucmentry+8),4))    /* get ep address */\n      epflag = STORAGE(D2X(@nucmentry+12),1)     /* get raw flag byte */\n      eplen  = C2X(STORAGE(D2X(@nucmentry+13),3))    /* get ep length */\n      Leave\n      End\n   @nucmentry = @nucmentry + 16                 /* bump to next entry */\nEnd\nReturn epaddr\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE220": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04]\\x00S\\x01\\x165?\\x01\\x165?\\x15(\\x00\\xf4\\x00\\xf4\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf3@@@'", "ispf": {"version": "04.93", "flags": 0, "createdate": "2016-12-18T00:00:00", "modifydate": "2016-12-18T15:28:53", "lines": 244, "newlines": 244, "modlines": 0, "user": "CBT-493"}, "text": "//***FILE 220 is from Lee Conyers of the U.S. Department of         *   FILE 220\n//*           Transportation in Washington, D.C.  This is a         *   FILE 220\n//*           collection of E.D.P. Auditing tools, to be used       *   FILE 220\n//*           in finding out information about an MVS system        *   FILE 220\n//*           without much outside help (that's one of the          *   FILE 220\n//*           things that E.D.P. Auditors do).  This is (of         *   FILE 220\n//*           course) also useful for MVS Systems Programmers.      *   FILE 220\n//*                                                                 *   FILE 220\n//*           Most of the REXX EXECs in this collection have been   *   FILE 220\n//*           converted into fixed blocked LRECL=80 format.  They   *   FILE 220\n//*           are no longer contained (in IEBUPDTE - PDSLOAD        *   FILE 220\n//*           format) in a single member, but they have now been    *   FILE 220\n//*           separated into individual members, so that it will    *   FILE 220\n//*           be easier to find them and use them.                  *   FILE 220\n//*                                                                 *   FILE 220\n//*           See File 221 for the REXX EXECs in this collection,   *   FILE 220\n//*           in VB format with LRECL=255.                          *   FILE 220\n//*                                                                 *   FILE 220\n//*           This collection was developed, a long time ago,       *   FILE 220\n//*           at the MVS/XA 2.2.3 level.  Most of the EXECs have    *   FILE 220\n//*           now been converted, by Anthony Cieri, to run on       *   FILE 220\n//*           z/OS 1.13, 2.1, and 2.2.                              *   FILE 220\n//*                                                                 *   FILE 220\n//*                < ------ >  z/OS 1.13  < ------ >                *   FILE 220\n//*                < ------ >  z/OS 2.1   < ------ >                *   FILE 220\n//*                                                                 *   FILE 220\n//*    Note:  Lee Conyers has unfortunately passed on.              *   FILE 220\n//*    ----                                                         *   FILE 220\n//*           Most of the REXX execs in this collection have        *   FILE 220\n//*           been upgraded to the z/OS 1.13 level by Tony Cieri.   *   FILE 220\n//*           Tony's TSO userid and the ISPF date, will indicate    *   FILE 220\n//*           which members have been updated (most of them).       *   FILE 220\n//*                                                                 *   FILE 220\n//*             Anthony J.Cieri                                     *   FILE 220\n//*             SEI Investments                                     *   FILE 220\n//*             1 Freedom Valley Drive                              *   FILE 220\n//*             Oaks, PA 19456                                      *   FILE 220\n//*                                                                 *   FILE 220\n//*             (P) 610.676.4088                                    *   FILE 220\n//*             (F) 484.676.4088                                    *   FILE 220\n//*             Email: acieri@seic.com                              *   FILE 220\n//*                                                                 *   FILE 220\n//*                < ------ >  z/OS 1.13  < ------ >                *   FILE 220\n//*                < ------ >  z/OS 2.1   < ------ >                *   FILE 220\n//*                                                                 *   FILE 220\n//*           I'd also suggest looking at the \"SHOWzOS\" TSO         *   FILE 220\n//*           command on File 492 of this tape, to supply some      *   FILE 220\n//*           more of this kind of information.  (S.G.)             *   FILE 220\n//*                                                                 *   FILE 220\n//*           INTRODUCTION TO THE AUDITMVS STARTER KIT              *   FILE 220\n//*           ----------------------------------------              *   FILE 220\n//*                                                                 *   FILE 220\n//*     THIS FILE CONTAINS THE AUDITMVS STARTER KIT SOFTWARE.       *   FILE 220\n//*     THE KIT CONSISTS OF UTILITY SOFTWARE TO COLLECT AND         *   FILE 220\n//*     ANALYZE DATA FROM AN OPERATIONAL MVS SYSTEM.  IT WILL       *   FILE 220\n//*     GREATLY ASSIST IN DOCUMENTING THE AUTHORIZED PROGRAM        *   FILE 220\n//*     FACILITY (APF) ENVIRONMENT, INCLUDING ALL APF LIBRARIES,    *   FILE 220\n//*     SUPERVISOR CALL (SVC) ROUTINES, EXTENDED SVC ROUTER (ESR)   *   FILE 220\n//*     ROUTINES, PROGRAM CALL (PC) ROUTINES, AND LINK PACK AREA    *   FILE 220\n//*     (LPA) PROGRAMS (I.E., PAGEABLE, MODIFIED, FIXED LPA; AND    *   FILE 220\n//*     OTHER ITEMS ALONG THE LPA QUEUE).                           *   FILE 220\n//*                                                                 *   FILE 220\n//*     THE SOFTWARE CONSISTS MOSTLY OF REXX AND SAS PROGRAMS.      *   FILE 220\n//*     IN ADDITION, THERE ARE SEVERAL ASSEMBLY LANGUAGE PROGRAMS   *   FILE 220\n//*     TO DISASSEMBLE MVS SOFTWARE FROM OBJECT CODE BACK TO        *   FILE 220\n//*     ASSEMBLY LANGUAGE.  THERE IS ALSO AN ASSEMBLY LANGUAGE      *   FILE 220\n//*     PROGRAM THAT USES THE SNAP MACRO TO RETRIEVE THE PROGRAM    *   FILE 220\n//*     CALL TABLE FROM THE PCAUTH ADDRESS SPACE.                   *   FILE 220\n//*                                                                 *   FILE 220\n//*     THE CONTENTS OF THIS DISKETTE SHOULD BE UPLOADED TO THE     *   FILE 220\n//*     MVS SYSTEM THAT IS TO BE AUDITED.  ALL OF THE FILES,        *   FILE 220\n//*     EXCEPT THE REXX PROGRAMS, MAY BE PLACED INTO INDIVIDUAL     *   FILE 220\n//*     MEMBERS OF A STANDARD FB 80 PARTITIONED DATA SET (PDS).     *   FILE 220\n//*     THE REXX PROGRAMS SOMETIMES EXCEED LINE LENGTHS BEYOND 72   *   FILE 220\n//*     CHARACTERS--THEREFORE, A VB 255 PDS IS RECOMMENDED.  BOTH   *   FILE 220\n//*     FB 80 AND VB 255 FORMATS ARE SUPPORTED BY THE ISPF/PDF      *   FILE 220\n//*     EDITOR.  TO SUMMARIZE, THE FOLLOWING                        *   FILE 220\n//*     DISKETTE-DIRECTORY-TO-MVS-PDS UPLOAD STRUCTURE IS           *   FILE 220\n//*     SUGGESTED:                                                  *   FILE 220\n//*                                                                 *   FILE 220\n//*     FILE MEMBER                 MVS PDS AND DCB INFO            *   FILE 220\n//*     ------------------    --------------------------------      *   FILE 220\n//*                                                                 *   FILE 220\n//*     ADVCAATS              USERID.DISASM.CNTL      FB   80       *   FILE 220\n//*     MISC                  USERID.CNTL             FB   80       *   FILE 220\n//*     REXX  (FILE 221)      USERID.EXEC             VB  255       *   FILE 220\n//*     SAS                   USERID.SAS.CNTL         FB   80       *   FILE 220\n//*                                                                 *   FILE 220\n//*     SOME OF THE STARTER KIT PROGRAMS ALSO REQUIRE A NUMBER OF   *   FILE 220\n//*     MVS SUPPORT FILES.  FOR EXAMPLE, THE IO* REXX PROGRAMS      *   FILE 220\n//*     ARE DATA COLLECTORS WHICH WRITE TO VARIOUS VB 255           *   FILE 220\n//*     PHYSICAL SEQUENTIAL DATA SETS.  THESE DATA SETS ARE THEN    *   FILE 220\n//*     READ BY THE SAS PROGRAMS FOR ANALYSIS AND REPORTING.  YOU   *   FILE 220\n//*     WILL HAVE TO ALLOCATE AND NAME THESE TO YOUR OWN            *   FILE 220\n//*     PREFERENCE, AND EDIT THE REXX AND SAS PROGRAMS              *   FILE 220\n//*     ACCORDINGLY.  THERE IS ONE SUPPORT DATA SET THAT MUST BE    *   FILE 220\n//*     FORMATTED SPECIFICALLY TO SUPPORT THE OUTPUT OF THE SNAP    *   FILE 220\n//*     MACRO.  SEE THE ASSEMBLY LANGUAGE PROGRAM (SNAPPC.ASM IN    *   FILE 220\n//*     THE MISC DIRECTORY) FOR THESE SPECIFIC DCB PARAMETERS.      *   FILE 220\n//*                                                                 *   FILE 220\n//*     ADVCAATS                                                    *   FILE 220\n//*     --------                                                    *   FILE 220\n//*                                                                 *   FILE 220\n//*     THIS LIBRARY CONTAINS SOURCE CODE FOR A OLD, OLD (BUT       *   FILE 220\n//*     VERY USEFUL) PUBLIC DOMAIN DISASSEMBLER.  THE               *   FILE 220\n//*     DISASSEMBLER HAS BEEN EXTENDED TO PERFORM IN-STORAGE        *   FILE 220\n//*     DISASSEMBLY IF THE CODE RESIDES BELOW THE 16 MB LINE.       *   FILE 220\n//*     SEE THE FILE $$README FOR MORE INFORMATION.                 *   FILE 220\n//*                                                                 *   FILE 220\n//*     MISC                                                        *   FILE 220\n//*     ----                                                        *   FILE 220\n//*                                                                 *   FILE 220\n//*     THIS LIBRARY CONTAINS SEVERAL *.JCL FILES.  ALLOCGDG.JCL    *   FILE 220\n//*     SHOWS HOW TO DEFINE A GENERATION DATA GROUP (GDG) SHOULD    *   FILE 220\n//*     YOU WANT TO BUILD A SYSTEM OF AUDIT JOBS THAT MAINTAIN      *   FILE 220\n//*     SNAPSHOT CYCLES OF DATA SETS FOR YOUR MVS SYSTEM.           *   FILE 220\n//*     IKJEFT01.JCL SHOWS HOW TO RUN YOUR REXX PROGRAMS IN         *   FILE 220\n//*     \"BATCH MODE\" TSO.  OTHER JCL FILES PROVIDE EXAMPLES OF      *   FILE 220\n//*     LENGTHY JOB STREAMS FOR MULTIPLE AUDIT STEPS.  THIS         *   FILE 220\n//*     LIBRARY ALSO CONTAINS THE SNAPPC.ASM FILE FOR OBTAINING     *   FILE 220\n//*     YOUR MVS SYSTEMS PC TABLE.                                  *   FILE 220\n//*                                                                 *   FILE 220\n//*     REXX     (FOUND IN FILE 221)                                *   FILE 220\n//*     ----                                                        *   FILE 220\n//*                                                                 *   FILE 220\n//*     THIS LIBRARY CONTAINS A WIDE VARIETY OF REXX PROGRAMS       *   FILE 220\n//*     THAT COLLECT DATA FROM AN OPERATIONAL MVS SYSTEM.  ALL      *   FILE 220\n//*     ARE STAND ALONE PROGRAMS EXCEPT FOR #NUCLKUP, WHICH IS AN   *   FILE 220\n//*     EXTERNAL REXX CALLABLE PROCEDURE THAT SEACHES THE NUCLEUS   *   FILE 220\n//*     MAP FOR AN ENTRY NAME AND RETURNS ITS ENTRY POINT           *   FILE 220\n//*     ADDRESS.  #NUCLKUP IS CURRENTLY CALLED BY IOSVCT, IOESRT,   *   FILE 220\n//*     LISTSVCT, AND LISTESRT.  SDUMP IS A GENERAL PURPOSE         *   FILE 220\n//*     FORMATTED DISPLAY STORAGE DUMP PROGRAM.  THE VSDATA1        *   FILE 220\n//*     PROGRAM IS A MODIFIED VERSION OF SDUMP WHICH DISPLAYS       *   FILE 220\n//*     SEVERAL IN-STORAGE CONTROL BLOCKS.                          *   FILE 220\n//*                                                                 *   FILE 220\n//*     THE IO* SERIES OF PROGRAMS COLLECT DATA AND WRITE TO        *   FILE 220\n//*     \"WORK.DATA\" DATA SETS.  THE LIST* SERIES OF PROGRAMS CAN    *   FILE 220\n//*     ALL BE EXECUTED INTERACTIVELY TO DISPLAY MVS INTERNALS      *   FILE 220\n//*     DATA TO YOUR TERMINAL SCREEN.  ACRONYMS USED WITHIN THE     *   FILE 220\n//*     NAMING SCHEME FOR THESE PROGRAMS ARE:                       *   FILE 220\n//*                                                                 *   FILE 220\n//*        ADSP     ADDRESS SPACE                                   *   FILE 220\n//*        APFP     APF LIBRARIES PROGRAMS                          *   FILE 220\n//*        APFT     APF TABLE                                       *   FILE 220\n//*        CATS     CATALOGS                                        *   FILE 220\n//*        CONS     CONSOLES                                        *   FILE 220\n//*        DASD     DIRECT ACCESS STORAGE DEVICES LIST              *   FILE 220\n//*        DCQ      DEVICE CLASS QUEUE                              *   FILE 220\n//*        ENV      ENVIRONMENTAL INFORMATION                       *   FILE 220\n//*        ESRT     ESR TABLE                                       *   FILE 220\n//*        LLT      LINKLIST LIBRARIES TABLE                        *   FILE 220\n//*        LLTP     LLT LIBRARIES PROGRAMS                          *   FILE 220\n//*        LPAQ     LPA QUEUE                                       *   FILE 220\n//*        LPAT     LPA LIBRARIES TABLE                             *   FILE 220\n//*        NUCM     NUCLEUS MAP                                     *   FILE 220\n//*        PART     PAGING ACTIVITY REFERENCE TABLE                 *   FILE 220\n//*        PDSD     PDS DIRECTORY                                   *   FILE 220\n//*        PDSM     PDS MEMBERS                                     *   FILE 220\n//*        PCAUTH   PROGRAM CALL AUTHORIZATION TABLE                *   FILE 220\n//*        PLPA     PAGEABLE LPA PROGRAMS                           *   FILE 220\n//*        SART     SWAPPING ACTIVITY REFERENCE TABLE               *   FILE 220\n//*        SDUMP    DISPLAY 31-BIT STORAGE                          *   FILE 220\n//*        SDUMPE   DISPLAY 64-BIT STORAGE BUT TRUNCATE HI 4 CHARS  *   FILE 220\n//*        SDUMPG   DISPLAY 64-BIT STORAGE - DISPLAY 83 BYTES WIDE  *   FILE 220\n//*        SFT      SYSTEM FUNCTION TABLE                           *   FILE 220\n//*        SMAP     STORAGE MAP INFORMATION                         *   FILE 220\n//*        SMF      SYSTEM MANAGEMENT FACILITY INFORMATION          *   FILE 220\n//*        SSN      SUBSYSTEM NAME TABLE                            *   FILE 220\n//*        SVCJ     SVC JOURNAL TABLE                               *   FILE 220\n//*        SVCT     SVC TABLE                                       *   FILE 220\n//*        TAPE     TAPE DEVICES LIST                               *   FILE 220\n//*        VMAP     VIRTUAL STORAGE MAP                             *   FILE 220\n//*                                                                 *   FILE 220\n//*     THE NOT@OR FILE IS A READY REFERENCE OF THE EBCDIC HEX      *   FILE 220\n//*     CODES FOR THE \"AND\" AND \"OR\" CHARACTERS.  THESE TWO         *   FILE 220\n//*     CHARACTERS ARE HARD TO REMEMBER WHEN ONE USES SEVERAL       *   FILE 220\n//*     DIFFERENT MICROCOMPUTER KEYBOARD MAPS ASSOCIATED WITH       *   FILE 220\n//*     VARIOUS 3270 EMULATION SOFTWARE PACKAGES.                   *   FILE 220\n//*                                                                 *   FILE 220\n//*     SAS                                                         *   FILE 220\n//*     ---                                                         *   FILE 220\n//*                                                                 *   FILE 220\n//*     THIS LIBRARY CONTAINS SAS PROGRAMS WHICH REPORT FROM THE    *   FILE 220\n//*     VARIOUS FILES CREATED BY THE IO* SERIES OF REXX PROGRAMS.   *   FILE 220\n//*     THE APFPDUP, LLTPDUP, LPAPDUP, ESRMATCH, PCMATCH, AND       *   FILE 220\n//*     SVCMATCH PROGRAMS DEMONSTRATE THE POWER OF THE SAS MERGE    *   FILE 220\n//*     FUNCTION.                                                   *   FILE 220\n//*                                                                 *   FILE 220\n//*                                                                 *   FILE 220\n//*           LEE CONYERS                                           *   FILE 220\n//*           U.S. DEPARTMENT OF TRANSPORTATION                     *   FILE 220\n//*           700 4TH STREET SW                                     *   FILE 220\n//*           ROOM 7404, M-35                                       *   FILE 220\n//*           WASHINGTON, DC  20590                                 *   FILE 220\n//*           (202) 366-1126                                        *   FILE 220\n//*                                               -- VLC (3/27/94)  *   FILE 220\n//*                                                                 *   FILE 220\n//*    Note from Sam Golob     (March 5, 2014)                      *   FILE 220\n//*                                                                 *   FILE 220\n//*    Addition to CBT File 220, from CBT File 221.                 *   FILE 220\n//*                                                                 *   FILE 220\n//*    I converted many of the LIST*** REXXes to FB-80, so I        *   FILE 220\n//*    could include them in my SYSPROC concatenation which is      *   FILE 220\n//*    FB-80, as opposed to VB-255.  They are here in this          *   FILE 220\n//*    member called REXXES, which is really a PDS in IEBUPDTE      *   FILE 220\n//*    (PDSLOAD) format, for your use and pleasure.  These are      *   FILE 220\n//*    really valuable and easily installable tools, to help        *   FILE 220\n//*    you (or the auditors) to get a better insight into the       *   FILE 220\n//*    specific workings of your MVS system.                        *   FILE 220\n//*                                                                 *   FILE 220\n//*    The REXXes that I have not yet converted, are the ones       *   FILE 220\n//*    which don't seem to work right under z/OS 1.13               *   FILE 220\n//*    (although I may have missed one or two which do work).       *   FILE 220\n//*    These are on my \"to do\" list, to improve, both in the        *   FILE 220\n//*    FB-80 and VB-255 versions.                                   *   FILE 220\n//*                                                                 *   FILE 220\n//*    The LISTDASD and LISTTAPE REXXes have been fixed.            *   FILE 220\n//*                                                                 *   FILE 220\n//*    The LISTDCQ REXX has been fixed.                             *   FILE 220\n//*                                                                 *   FILE 220\n//*    The IO*** members have not been converted.                   *   FILE 220\n//*                                                                 *   FILE 220\n//*    Lee Conyers (who has passed on) was really an expert         *   FILE 220\n//*    auditor and he knew a lot about what makes the system        *   FILE 220\n//*    tick, especially in those areas that an auditor has to       *   FILE 220\n//*    watch.  It is a pleasure to be able to use his               *   FILE 220\n//*    excellent tools.  That is why I have tried to make them      *   FILE 220\n//*    even more useful, for today's environment.                   *   FILE 220\n//*                                                                 *   FILE 220\n//*    For the record, SHOWzOS on CBT File 492 (load module         *   FILE 220\n//*    collection on CBT File 614) is also extremely useful to      *   FILE 220\n//*    supplement this information obtainable with the REXXes       *   FILE 220\n//*    here.                                                        *   FILE 220\n//*                                                                 *   FILE 220\n//*    We have included a TSO command to clear the screen, which    *   FILE 220\n//*    is needed by the REXXes in File 221 and member REXXES in     *   FILE 220\n//*    this file.  This is member CLEAR and its assembly JCL,       *   FILE 220\n//*    member CLEAR$.                                               *   FILE 220\n//*                                                                 *   FILE 220\n//*    All the best of everything to all of you.                    *   FILE 220\n//*                                                                 *   FILE 220\n//*    Sam                                                          *   FILE 220\n//*                                                                 *   FILE 220\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE221": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04[\\x00\\x00\\x01\\x153\\x7f\\x01\\x153\\x7f\\x13X\\x00&\\x00&\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf1@@@'", "ispf": {"version": "04.91", "flags": 0, "createdate": "2015-12-03T00:00:00", "modifydate": "2015-12-03T13:58:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "CBT-491"}, "text": "//***FILE 221 is from Lee Conyers of the U.S. Department of         *   FILE 221\n//*           Transportation in Washington, D.C.  See File 220      *   FILE 221\n//*           for a description of this entire collection of        *   FILE 221\n//*           E.D.P. auditing tools.  This file contains the        *   FILE 221\n//*           REXX execs from the collection, that have been        *   FILE 221\n//*           separated out because of their DCB format, which      *   FILE 221\n//*           is VB with LRECL(255).  This file is in IEBCOPY       *   FILE 221\n//*           format.                                               *   FILE 221\n//*                                                                 *   FILE 221\n//*                < ------ >  z/OS 2.1   < ------ >                *   FILE 221\n//*                                                                 *   FILE 221\n//*    Note:  Lee Conyers has unfortunately passed on.              *   FILE 221\n//*    ----                                                         *   FILE 221\n//*           Most of the REXX execs in this collection have        *   FILE 221\n//*           been upgraded to the z/OS 1.13 level by Tony Cieri.   *   FILE 221\n//*           Tony's TSO userid and the ISPF date, will indicate    *   FILE 221\n//*           which members have been updated (most of them).       *   FILE 221\n//*                                                                 *   FILE 221\n//*             Anthony J.Cieri                                     *   FILE 221\n//*             SEI Investments                                     *   FILE 221\n//*             1 Freedom Valley Drive                              *   FILE 221\n//*             Oaks, PA 19456                                      *   FILE 221\n//*                                                                 *   FILE 221\n//*             (P) 610.676.4088                                    *   FILE 221\n//*             (F) 484.676.4088                                    *   FILE 221\n//*             Email: acieri@seic.com                              *   FILE 221\n//*                                                                 *   FILE 221\n//*           Many of these execs have been converted to FB-80      *   FILE 221\n//*           format from VB-255.  The converted execs can be       *   FILE 221\n//*           found on CBT File 220 as member REXXES.  This         *   FILE 221\n//*           member is in IEBUPDTE (PDSLOAD) format, with the      *   FILE 221\n//*           ISPF statistics preserved.  Use the PDSLOAD program   *   FILE 221\n//*           from File 093 to restore the FB-80 pds of REXX        *   FILE 221\n//*           execs, corresponding to most of the execs on this     *   FILE 221\n//*           file.                                                 *   FILE 221\n//*                                                                 *   FILE 221\n//*                < ------ >  z/OS 2.1   < ------ >                *   FILE 221\n//*                                                                 *   FILE 221\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ADVCAATS": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x94'\\x8f\\x00\\x94'\\x8f\\x19\\x08 \\xf0 \\xf0\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-10-05T00:00:00", "modifydate": "1994-10-05T19:08:00", "lines": 8432, "newlines": 8432, "modlines": 0, "user": "SBGCSC"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "CLEAR": {"ttr": 4105, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'P\\x06\\x00\\x00\\x01\\x05\\x03O\\x01\\x14\\x05/\\x13X\\x00Y\\x00*\\x00;\\xc7\\xc5\\xd9\\xc8\\xc1\\xd9\\xc4@@@'", "ispf": {"version": "80.06", "flags": 0, "createdate": "2005-02-03T00:00:00", "modifydate": "2014-02-21T13:58:00", "lines": 89, "newlines": 42, "modlines": 59, "user": "GERHARD"}, "text": "CLR70    TITLE 'C L E A R  ***  CLEAR SCREEN ON TSO/VTAM CRT'\n         PUNCH ' ENTRY CLEAR   '                                GP05033\n         PUNCH '  ORDER CLEAR(P) '     NEAT DUMPS\n         PRINT GEN\n***********************************************************************\n*                                                                     *\n*        CLEAR - TSO CLEAR SCREEN COMMAND                             *\n*              RENT,REFR,REUS                                         *\n*                                                                     *\n*        RECOMMENDED ALIAS OF CLR3270 FOR COMPATIBILITY               *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*        WRITTEN FROM A SUGGESTION IN TECHNICAL SUPPORT MAGAZINE,     *\n*        VOL. 4, NUMBER 15 (DEC. 1990), PAGE 10                       *\n*                                                                     *\n***********************************************************************\nCLEAR    CSECT\n         USING SAVE,R13\nA@0002   B     B@0002-*(,R15)\n         DC    AL1(L'N@0002)\nN@0002   DC    C'CLEAR - &SYSDATE - &SYSTIME'\n\nB@0002   STM   R14,R12,SAVE14\n         LR    R12,R15\n         LR    R11,R1\n         USING A@0002,R12\n         LA    R14,SAVEND-SAVE\n         LR    0,R14                   LOAD LENGTH\n         BAL   1,*+4                   INDICATE GETMAIN\n         SVC   10                      ISSUE GETMAIN SVC\n         ST    R14,SAVESPLN-SAVE(R1)\n         ST    R1,SAVEFWD\n         ST    R13,SAVE13-SAVE(R1)\n         LR    R13,R1\nSAVE     DSECT\nSAVESPLN DS    F\nSAVE13   DS    F\nSAVEFWD  DS    A\nSAVE14   DS    A\nSAVE15   DS    A\nSAVE0    DS    A\nSAVE1    DS    A\nSAVE2    DS    A\nSAVE3    DS    A\nSAVE4    DS    A\nSAVE5    DS    A\nSAVE6    DS    A\nSAVE7    DS    A\nSAVE8    DS    A\nSAVE9    DS    A\nSAVE10   DS    A\nSAVE11   DS    A\nSAVE12   DS    A\nSAVEFWK  EQU   *\nCLEAR    CSECT\n         YREGS\n*        GTSIZE ,            CHECK FOR A CRT\n         GTSIZE\n         CH    R0,=H'1'      MORE THAN ONE LINE ?\n         BNH   GETOUT        NO\n         STFSMODE ON,INITIAL=YES\n         BXH   R15,R15,NOTVTAM\n         STLINENO LINE=1,MODE=ON\n         STFSMODE OFF\n         B     GETOUT\nNOTVTAM  TPUT  SCRNCLR,SCRNCLRL,NOEDIT\nGETOUT   L     R0,SAVESPLN-SAVESPLN(,R13)\n         LR    R1,R13\n         L     R13,SAVE13-SAVESPLN(,R13)\n         SVC   10\n         LM    R14,R12,SAVE14-SAVESPLN(R13)\n         MVI   SAVE14-SAVESPLN(R13),X'FF'\n         XR    R15,R15\n         BR    R14\n         SPACE 1\nSCRNCLR  DC    C'C'\n         DC    X'11'                    SET BUFFER ADDRESS\n         DC    C'  '\n         DC    C' '\n         DC    X'3C'                    REPEAT TO ADDRESS\n         DC    C'  '\n         DC    C' '\n         DC    X'13'                    INSERT CURSOR\nSCRNCLRL EQU   *-SCRNCLR\n         SPACE 1\nSAVE     DSECT ,             SAVE/WORK AREA\nSAVEND   EQU   *\n         END   ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CLEAR$": {"ttr": 4108, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x001\\x00\\x994/\\x01\\x16\\x11\\x7f\\x13W\\x00\\x1b\\x00\\x1d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1999-12-08T00:00:00", "modifydate": "2016-04-26T13:57:31", "lines": 27, "newlines": 29, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(CLEAR)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET,RENT,REUS,REFR'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB     <-- YOUR LIBRARY\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB     <-- YOUR LIBRARY\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETCODE AC(0)\n SETSSI  CB488221\n NAME    CLEAR(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LISTADSP": {"ttr": 4353, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x00\\x00\\x00\\x94\\x08\\x8f\\x01\\x14\\x06/#\\x15\\x00Y\\x00W\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-03-03T23:15:00", "lines": 89, "newlines": 87, "modlines": 0, "user": "SBGOLOB"}, "text": "/* REXX */\n/*****************************************************************/\n/*LISTADSP: REXX program to display all address space names.     */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*               ASVT - Address Space Vector Table               */\n/*               ASCB - Address Space Control Block              */\n/*               OUCB - SRM User Control Block                   */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to dec to hex      */\n@cvtasvt  = STORAGE(D2X(X2D(@cvt)+556),4)    /* get CVTASVT address   */\n@cvtasvt  = D2X(C2D(@cvtasvt))                 /* binary to dec to hex*/\nAddress TSO ; \"CLEAR\"\nSay 'CVT: '@cvt 'CVTASVT: '@cvtasvt' ===> Scan on 'DATE()'.  Started: 'TIME()\n@asvt = @cvtasvt\nasvtmaxu = STORAGE(D2X(X2D(@asvt)+516),4) /* get maxuser (table size) */\nDo i = 1 to C2D(asvtmaxu)                  /* initialize name buckets */\n   bat.i = ''\n   tso.i = ''\n   stc.i = ''\nEnd\nj = 0 ; k = 0 ; tablend = 524 + (4 * (C2D(asvtmaxu)-1))\nb = 0 ; t = 0 ; s = 0 ; inits = 0      /* address space type counters */\nDo i = 524 to tablend By 4                      /* loop thru the ASVT */\n   j = j + 1                            /* count asvt slots processed */\n   @ascb = STORAGE(D2X(X2D(@asvt)+i),4)        /* get address of ASCB */\n   If BITAND(LEFT(@ascb,1),'80'x)\\='80'x Then Do   /* bit off, in use */\n      k = k + 1                                /* count active adrspc */\n      ascbasid = STORAGE(D2X(C2D(@ascb)+36),2)            /* get ASID */\n      @ascboucb = STORAGE(D2X(C2D(@ascb)+144),4)  /* get OUCB address */\n      @ascbjbni = STORAGE(D2X(C2D(@ascb)+172),4)  /* get JOBN address */\n      jbni = '        ' ; @ascbjbni = D2X(C2D(@ascbjbni))\n      If @ascbjbni \\= 0 Then jbni = STORAGE(@ascbjbni,8)\n      @ascbjbns = STORAGE(D2X(C2D(@ascb)+176),4)  /* get STCN address */\n      jbns = '        ' ; @ascbjbns = D2X(C2D(@ascbjbns))\n      If @ascbjbns \\= 0 Then jbns = STORAGE(@ascbjbns,8)\n      oucbsubn = STORAGE(D2X(C2D(@ascboucb)+176),4)    /* subsys name */\n      oucbtrxn = STORAGE(D2X(C2D(@ascboucb)+200),8)    /* transn name */\n      oucbusrd = STORAGE(D2X(C2D(@ascboucb)+208),8)         /* userid */\n      /* BATCH JOBS */\n      If oucbsubn = 'STC ' & jbns = 'INIT    ' Then inits = inits + 1\n      If oucbsubn = 'JES2' & jbns = 'INIT    ' & jbni = oucbtrxn Then Do\n         inits = inits + 1\n         b = b + 1\n         bat.b = oucbtrxn\n         End\n      /* TSO USERS  */\n      If oucbsubn = 'TSO ' Then Do\n         t = t + 1\n         If oucbusrd = '        ' Then tso.t = '????????' /* missing lid */\n                                  Else tso.t = oucbusrd\n         End\n      /* STARTED TASKS */\n     If oucbsubn = 'STC ' & oucbtrxn \\= 'INIT    ' & jbns \\= 'INIT    ',\n     Then Do\n         s = s + 1\n         stc.s = oucbtrxn\n         End\n      End\nEnd\nSay ' '\nSay RIGHT(inits,4,' ')' Initiators defined. 'RIGHT(b,3,' ') 'Batch jobs active:'\n\nIf b > 0 Then Do i = 1 To b By 8\n   c1=i ; c2=i+1 ; c3=i+2 ; c4=i+3 ; c5=i+4 ; c6=i+5 ; c7=i+6 ; c8=i+7\n   Say '     'bat.c1' 'bat.c2' 'bat.c3' 'bat.c4,\n              bat.c5' 'bat.c6' 'bat.c7' 'bat.c8\n   End\nSay ' '\nSay RIGHT(t,4,' ')' TSO sessions:'\nIf t > 0 Then Do i = 1 To t By 8\n   c1=i ; c2=i+1 ; c3=i+2 ; c4=i+3 ; c5=i+4 ; c6=i+5 ; c7=i+6 ; c8=i+7\n   Say '     'tso.c1' 'tso.c2' 'tso.c3' 'tso.c4,\n              tso.c5' 'tso.c6' 'tso.c7' 'tso.c8\n   End\nSay ' '\nSay RIGHT(s,4,' ')' Started tasks:'\nIf s > 0 Then Do i = 1 To s By 8\n   c1=i ; c2=i+1 ; c3=i+2 ; c4=i+3 ; c5=i+4 ; c6=i+5 ; c7=i+6 ; c8=i+7\n   Say '     'stc.c1' 'stc.c2' 'stc.c3' 'stc.c4,\n              stc.c5' 'stc.c6' 'stc.c7' 'stc.c8\n   End\nSay ' '\nSay RIGHT(k,4,' ')' slots in use out of a total 'j' scanned.  Completed: 'TIME()\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTAPFT": {"ttr": 4356, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x00\\x00\\x01\\x130\\x9f\\x01\\x130\\x9f\\x13\\t\\x00A\\x00M\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3\\xe3@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "2013-11-05T00:00:00", "modifydate": "2013-11-05T13:09:00", "lines": 65, "newlines": 77, "modlines": 0, "user": "SCNS03T"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTAPFT: REXX program to display APF table from CSTOR.        */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*             APFTAB - Undocumented in MVS DATA AREAS book.     */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\nnumeric digits 30\ncvt = c2d(storage(10,4))                       /* point to cvt        */\n@cvt = D2X(cvt)                                /* binary to hex       */\necvt = c2d(storage(d2x(cvt+140),4))            /* point to cvtecvt    */\n@ecvt = STORAGE(D2X(X2D(@cvt)+140),4)          /* get CVTAUTHL addres */\n@ecvt = D2X(C2D(@ecvt))                        /* binary to hex       */\n@cvtauthl = STORAGE(D2X(X2D(@cvt)+484),4)      /* get CVTAUTHL addres */\n@cvtauthl = D2X(C2D(@cvtauthl))                /* binary to hex       */\nif X2D(@cvtauthl) <> c2d('7ffff001'x) then      /*dynamic list ?   @@ */\ndo          /* Static format  */\nSay 'The CVT  is located at '@cvt '('X2D(@cvt)')'\napfcount  = C2D(STORAGE(D2X(X2D(@cvtauthl)+1),1)) /* APF libraries    */\napfllen   = C2D(STORAGE(D2X(X2D(@cvtauthl)+2),1)) /* length 1st entry */\n@apfentry = X2D(@cvtauthl)+3          /* address of 1st APF entry     */\nDo i = 1 to apfcount                            /* loop thru storage  */\n   apflib.i = STORAGE(D2X(@apfentry),apfllen)   /* get the APF entry  */\n   @apfentry = @apfentry + apfllen + 1          /* bump to next entry */\n   apfllen = C2D(STORAGE(D2X(@apfentry-1),1))   /* length of next     */\n   apfvol.i  = substr(apflib.i,1,6)                /* apf vol         */\n   apfdsn.i  = substr(apflib.i,7,44)               /* apf dsn         */\nEnd\nEnd         /* Static format  */\nElse        /* Dynamic format */\n  do\n    Say 'The eCVT is located at '@ecvt '('X2D(@ecvt)')'\n    ecvtcsvt = c2d(storage(d2x(ecvt+228),4))   /* point to ecvtcsvt   */\n    apfa = c2d(storage(d2x(ecvtcsvt+12),4))    /* addr start of list  */\n    apht = c2d(storage(d2x(apfa+8),4))         /* addr 1st entry      */\n    last = c2d(storage(d2x(apfa+12),4))        /* addr last entry     */\n    apf. = ''\n    i = 0\n    do forever\n      apfdsn.i = storage(d2x(apht+24),44)      /* apf dataset name    */\n      if substr(apfdsn.i,1,1) \u00ac= '00'x then    /* 00 = deleted        */\n        do\n          apfesms = storage(d2x(apht+4),1)     /* sms flag            */\n          if  bitand(apfesms,'80'x)  = '80'x then apfvol.i = '*SMS* '\n          else apfvol.i = storage(d2x(apht+68),6)   /* apf volser     */\n          i = i + 1\n        end\n      if apht = last then leave\n      else apht = c2d(storage(d2x(apht+8),4))  /* addr next entry     */\n    end\n    apfcount = i - 1\n  end       /* Dynamic format */               /* set maximum lines   */\nSay 'The CVTAUTHL field points to '@cvtauthl '('X2D(@cvtauthl)')'\nSay 'The APF table contains 'apfcount 'entries, as follows:'\nSay 'VOLSER --------------DATA SET NAME-----------------'\nSay ' '\ndo i = 1 to apfcount                       /* for each line       */\n  say apfvol.i' 'left(apfdsn.i,45) i       /* build output line   */\nend\nExit\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTAPF2": {"ttr": 4358, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00\\x00\\x01\\x130_\\x01\\x130\\x9f\\x122\\x00M\\x00(\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3\\xe3@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "2013-11-01T00:00:00", "modifydate": "2013-11-05T12:32:00", "lines": 77, "newlines": 40, "modlines": 0, "user": "SCNS03T"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTAPFT: REXX program to display APF table from CSTOR.        */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*             APFTAB - Undocumented in MVS DATA AREAS book.     */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\nnumeric digits 30\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                          /* binary to hex       */\n\ncvt = c2d(storage(10,4))                       /* point to cvt        */\necvt = c2d(storage(d2x(cvt+140),4))            /* point to cvtecvt    */\n@ecvt = STORAGE(D2X(X2D(@cvt)+140),4)          /* get CVTAUTHL addres */\n@ecvt = D2X(C2D(@ecvt))                        /* binary to hex       */\n\n@cvtauthl = STORAGE(D2X(X2D(@cvt)+484),4)      /* get CVTAUTHL addres */\n@cvtauthl = D2X(C2D(@cvtauthl))                /* binary to hex       */\nsay '@cvtauthl= '@cvtauthl\nsay 'compare1= 'c2d('7ffff001'x)\nSay 'The CVT  is located at '@cvt '('X2D(@cvt)')'\nSay 'The eCVT is located at '@ecvt '('X2D(@ecvt)')'\nSay 'The CVTAUTHL field points to '@cvtauthl '('X2D(@cvtauthl)')'\nif X2D(@cvtauthl) <> c2d('7ffff001'x) then      /*dynamic list ?   @@ */\ndo          /* Static format  */\nsay 'Static Format'\napfcount  = C2D(STORAGE(D2X(X2D(@cvtauthl)+1),1)) /* APF libraries    */\napfllen   = C2D(STORAGE(D2X(X2D(@cvtauthl)+2),1)) /* length 1st entry */\n@apfentry = X2D(@cvtauthl)+3          /* address of 1st APF entry     */\nSay 'The APF table contains 'apfcount 'entries, as follows:'\nSay ' '\nDo i = 1 to apfcount                            /* loop thru storage  */\n   apflib.i = STORAGE(D2X(@apfentry),apfllen)   /* get the APF entry  */\n   @apfentry = @apfentry + apfllen + 1          /* bump to next entry */\n   apfllen = C2D(STORAGE(D2X(@apfentry-1),1))   /* length of next  */\nEnd\nSay 'VOLSER --------------DATA SET NAME-----------------'\nSay ' '\nDo i = 1 to apfcount                            /* print the list     */\n   Say SUBSTR(apflib.i,1,6) SUBSTR(apflib.i,7,44,' ') i\nEnd\nEnd         /* Static format  */\nElse        /* Dynamic format */\n  do\n    say 'Dynamic Format'\n    ecvtcsvt = c2d(storage(d2x(ecvt+228),4))   /* point to ecvtcsvt   */\n    apfa = c2d(storage(d2x(ecvtcsvt+12),4))    /* addr start of list  */\n    apht = c2d(storage(d2x(apfa+8),4))         /* addr 1st entry      */\n    last = c2d(storage(d2x(apfa+12),4))        /* addr last entry     */\n    apf. = ''\n    inc = 0\n    do forever\n      apfdsn = storage(d2x(apht+24),44)        /* apf dataset name    */\n      if substr(apfdsn,1,1) \u00ac= '00'x then      /* 00 = deleted        */\n        do\n          apfesms = storage(d2x(apht+4),1)     /* sms flag            */\n          if  bitand(apfesms,'80'x)  = '80'x then apfvol = '*SMS* '\n          else apfvol = storage(d2x(apht+68),6)   /* apf volser       */\n          line.inc =left(apfdsn,45)||apfvol\n          inc = inc + 1\n        end\n      if apht = last then leave\n      else apht = c2d(storage(d2x(apht+8),4))  /* addr next entry     */\n    end\n    apfcount = inc - 1\n    Say 'The APF table contains 'apfcount 'entries, as follows:'\n\n  do inc = 1 to apfcount                       /* for each line       */\n    say ' 'line.inc                            /* build output line   */\n  end\n  end       /* Dynamic format */               /* set maximum lines   */\nExit\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTCATS": {"ttr": 4361, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00\\x00\\x01\\x14\\x02O\\x01\\x14\\x05\\x0f\"V\\x006\\x00-\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2014-01-24T00:00:00", "modifydate": "2014-02-19T22:56:00", "lines": 54, "newlines": 45, "modlines": 0, "user": "SCNS03"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTCATS: REXX program to display all open catalogs.           */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*              AMCBS - Access Method Control Block Structure    */\n/*              CAXWA - Calaog Auxiliary Work Area               */\n/*                UCB - Device Unit Control Block                */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                         /* binary to dec to hex */\n@cvtcbsp  = STORAGE(D2X(X2D(@cvt)+256),4)      /* get CVTCBSP address */\n@cvtcbsp  = D2X(C2D(@cvtcbsp))                /* binary to dec to hex */\n@cbscaxcn = STORAGE(D2X(X2D(@cvtcbsp)+20),4)  /* get CBSCAXCN address */\n@cbscaxcn = D2X(C2D(@cbscaxcn))               /* binary to dec to hex */\n@cbsacb   = STORAGE(D2X(X2D(@cvtcbsp)+8),4)     /* get CBSACB address */\n@cbsacb   = D2X(C2D(@cbsacb))                 /* binary to dec to hex */\nAddress TSO ; \"CLEAR\"\nSay 'CVT: '@cvt' CVTCBSP: '@cvtcbsp' ===> CAXWA chain trace started: 'TIME()\n   Say 'CBSCAXCN: '@cbscaxcn' CBSACB:'@cbsacb\nSay ' '\ni = 0 ; endofcax = 0 ; @caxchn = @cbscaxcn\nDo While endofcax = 0 & i < 500\n   i = i + 1\n   @caxacb = STORAGE(D2X(X2D(@caxchn)+24),4)   /* catalog acb address */\n   @caxacb = D2X(C2D(@caxacb))                /* binary to dec to hex */\n   If @caxacb = @cbsacb Then\n    Do\n     cattype = 'Master'\n     @caxucb = STORAGE(D2X(X2D(@caxchn)+28),4) /* catalog ucb address */\n    End\n   Else\n    Do\n    cattype = 'User  '\n    @caxucb = STORAGE(D2X(X2D(@caxchn)+188),4) /* catalog ucb address */\n    End\n   @caxucb = D2X(C2D(@caxucb))                /* binary to dec to hex */\n/* Say 'CAXUCB: '@caxucb' CAXACB:'@caxacb */\n   caxvol  = STORAGE(D2X(X2D(@caxucb)+28),6)        /* catalog volser */\n   caxcnam = STORAGE(D2X(X2D(@caxchn)+52),44)          /* catalog dsn */\n   caxflg3 = STORAGE(D2X(X2D(@caxchn)+10),1)             /* cax flags */\n   catorg = 'CVOL' ; If BITAND(caxflg3,'20'x)='20'x Then catorg = 'ICF '\n   @caxnext = STORAGE(D2X(X2D(@caxchn)+4),4)    /* next caxwa address */\n   @caxnext = C2X(@caxnext)                   /* binary to dec to hex */\n   If @caxnext = 0 Then endofcax = 1            /* end of chain value */\n   Say RIGHT(i,2,' ') cattype catorg caxvol caxcnam\n   @caxchn = @caxnext\nEnd\nSay ' '\nSay 'Last CAXWA after 'i' blocks scanned.  Completed: 'TIME()\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTCONS": {"ttr": 4363, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x94\\x08\\x8f\\x01\\x14\\x05\\x0f\"V\\x00h\\x00_\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-02-19T22:56:00", "lines": 104, "newlines": 95, "modlines": 0, "user": "SCNS03"}, "text": "/*REXX*/\n/*****************************************************************/\n/* LISTCONS: REXX program to display system consoles and status. */\n/*     Note: Developed and tested on an MVS/SP 2.2.3 system.     */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                UCM - Unit Control Module                      */\n/*                UCB - IOS Unit Control Block                   */\n/*****************************************************************/\nAddress TSO ; \"CLEAR\" ; Numeric Digits 10\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                                /* binary to hex */\n@cvtcucb  = STORAGE(D2X(X2D(@cvt)+100),4)      /* get CVTCUCB address */\n@cvtcucb  = D2X(C2D(@cvtcucb))                       /* binary to hex */\n@ucmvea   = STORAGE(D2X(X2D(@cvtcucb)+72),4)    /* get UCMVEA address */\n@ucme     = D2X(C2D(@ucmvea))                        /* binary to hex */\nucmvez    = STORAGE(D2X(X2D(@cvtcucb)+76),4)            /* get UCMVEZ */\nucmelen   = C2D(ucmvez)                              /* binary to dec */\n@ucmvel   = STORAGE(D2X(X2D(@cvtcucb)+80),4)    /* get UCMVEL address */\n@ucmelast = D2X(C2D(@ucmvel))                        /* binary to hex */\nSay 'CVT:'@cvt'  CVTCUCB:'@cvtcucb'  UCMVEA:'@ucme'  'DATE() TIME()\nSay ' '\nSay '    Console  '\nSay 'ID  UCB    Name     Status    Message Routing'\nSay '--  ----   -------- ------    ----------------------------------------'\nSay ' '\nbit0='80'x ; bit1='40'x ; bit2='20'x ; bit3='10'x\nbit4='08'x ; bit5='04'x ; bit6='02'x ; bit7='01'x\nDo While @ucme \\= @ucmelast             /* loop through the ucme list */\n   @ucmucb   = STORAGE(D2X(X2D(@ucme)+12),4)    /* get UCMUCB address */\n   @ucmucb   = D2X(C2D(@ucmucb))                     /* binary to hex */\n   ucbname   = STORAGE(D2X(X2D(@ucmucb)+13),3)         /* get UCBNAME */\n     ucbchan   = STORAGE(D2X(X2D(@ucmucb)+4),2)        /* get UCBCHAN */\n     ucbchan   =  D2X(C2D(ucbchan))\n   if substr(ucbname,1,3) ='UCB' then ucbname = ucbchan\n   ucmatr    = STORAGE(D2X(X2D(@ucme)+25),1)            /* get UCMATR */\n   ucmid     = STORAGE(D2X(X2D(@ucme)+26),1)             /* get UCMID */\n   ucmid     = C2D(ucmid)                            /* binary to dec */\n\n      @ucmfextp = STORAGE(D2X(X2D(@ucme)+72),4)  /* get UCMFEXTP addr */\n      @ucmfextp = D2X(C2D(@ucmfextp))                /* binary to hex */\n      ucmefcnm  = STORAGE(D2X(X2D(@ucmfextp)+52),8)    /* get UCMEFCNM*/\n\n   active    = '' ; routing = '' ; line2 = ''\n   If BITAND(ucmatr,'10'x) = '10'x Then Do /* process active consoles */\n      active = '*Active* '\n      ucmefrc   = STORAGE(D2X(X2D(@ucmfextp)+24),16)   /* get UCMEFRC */\n      /*-------------------process route code data--------------------*/\n      Do i = 1 to 16\n         byte = SUBSTR(ucmefrc,i,1)\n         k = (i-1) * 8\n         If BITAND(byte,bit0)=bit0 Then routing = routing k+1\n         If BITAND(byte,bit1)=bit1 Then routing = routing k+2\n         If BITAND(byte,bit2)=bit2 Then routing = routing k+3\n         If BITAND(byte,bit3)=bit3 Then routing = routing k+4\n         If BITAND(byte,bit4)=bit4 Then routing = routing k+5\n         If BITAND(byte,bit5)=bit5 Then routing = routing k+6\n         If BITAND(byte,bit6)=bit6 Then routing = routing k+7\n         If BITAND(byte,bit7)=bit7 Then routing = routing k+8\n      End\n      i = 0 ; k = 0 ; f = '' ; j = 0 ; jj = 0\n      Do While routing \\= ''\n         i = i + 1\n         PARSE VAR routing type.i routing\n      End\n      If i > 2 Then\n         Do k = 1 to i-2\n            j = k + 1 ; jj = k + 2\n            If type.k = type.j - 1 & type.j = type.jj -1 Then f.k = '*'\n                                                         Else f.k = ' '\n         End\n      routing = 'Codes('\n      Do k = 1 to i\n         If f.k \\= '*' Then Do\n                               routing = routing''type.k\n                               If k \\= i Then routing = routing','\n                                         Else routing = routing')'\n                            End\n                       Else Do\n                              routing = routing''type.k':'\n                              Do While f.k = '*' ; k=k+1 ; End\n                            End\n      End\n      line2 = ''\n      If LENGTH(routing) >50 Then\n         Do\n            Do i = 70 to 1 By -1\n               If SUBSTR(routing,i,1) = ',' Then Leave\n            End\n            line2 = SUBSTR(routing,i+1,60)\n            routing = LEFT(routing,i)\n         End\n      /*--------------------end of route code data--------------------*/\n      End\n/* Say RIGHT(ucmid,2)' ('ucbname')  'active routing */\n/* Say RIGHT(ucmid,2)' ('ucbname') ' ucmefcnm active routing */\n Say RIGHT(ucmid,2)' ('RIGHT(ucbname,4)') ' ucmefcnm active routing\n   If line2 \\= '' Then Say   '                         'line2\n   @ucme = D2X(X2D(@ucme)+ucmelen)               /* bump to next ucme */\nEnd\nSay ' '\nSay 'Unit Control Module device table scan completed 'TIME()\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTDASD": {"ttr": 4366, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x01\\x15\\x02_\\x01\\x15\\x02o\\x18@\\x00~\\x00\\x82\\x00\\x00\\xc1\\xc3\\xc9\\xc5\\xd9\\xc9@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2015-01-25T00:00:00", "modifydate": "2015-01-26T18:40:00", "lines": 126, "newlines": 130, "modlines": 0, "user": "ACIERI"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTDASD: REXX program to display all online DASD devices.     */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                UCB - Device Unit Control Block                */\n/*                DCE - Device Class Extension                   */\n/*                VIP - VTOC Information Block                   */\n/* @ z/OS V2.2 the ULUT has been moved into 64 bit storage.      */\n/*****************************************************************/\nAddress TSO ; \"CLEAR\" ; Numeric Digits 20    /* 20 can handle 64 bits */\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to dec to hex      */\n@cvtucba  = STORAGE(D2X(X2D(@cvt)+1252),4)   /* get CVTUCBA address   */\n@cvtucba  = D2X(C2D(@cvtucba))                 /* binary to dec to hex*/\n@cvtixav  = STORAGE(D2X(X2D(@cvt)+124),4)      /* get CVTIXAVL addres */\n@cvtixav  = D2X(C2D(@cvtixav))                       /* binary to hex */\n@iovtadr  = STORAGE(D2X(X2D(@cvtixav)+208),4)  /* get IOVT address    */\n@iovtadr  = D2X(C2D(@iovtadr))                       /* binary to hex */\n@ulutadr  = STORAGE(D2X(X2D(@iovtadr)+8),4)    /* get IOVT address    */\n@ulutadr  = D2X(C2D(@ulutadr))                       /* binary to hex */\nif @ulutadr = 0 then                            /* zOS V2.2 or higher */\n  do\n   Say 'zOS:'MVSVAR(SYSOPSYS)' Ulut is in 64 bit storage'\n   @ulutadr  = STORAGE(D2X(X2D(@iovtadr)+440),8)  /* get IOVT address */\n   @ulutadr  = D2X(C2D(@ulutadr))                    /* binary to hex */\n  end\nulu      = STORAGE(@ulutadr,64)             /* get 64 byte ulu header */\nuluname  = SUBSTR(ulu,1,4)                         /* ulut eyecatcher */\nulutype  = SUBSTR(ulu,5,1)                         /* ulut Type 1 or 2*/\nIf ulutype = '01'x Then off = 0                    /* ULUT Type 1     */\nIf ulutype = '02'x Then off = 8                    /* ULUT Type 2     */\nIf ulutype = '03'x Then                            /* ULUT Type 3     */\n Do\n   ulufirst = SUBSTR(ulu,17,8)          /* addr of 1st ULU element(64)*/\n   uluucbno = SUBSTR(ulu,29,4)          /* # of ucb's this I/O config */\n   off = 12\n End\nElse\n Do                                     /* Ulut type 1 or 2           */\n   ulufirst = SUBSTR(ulu,13+off,4)      /* address of 1st ULU element */\n   uluucbno = SUBSTR(ulu,17+off,4)      /* # of ucb's this I/O config */\n End\n uluttape = SUBSTR(ulu,21+off,4)        /* # of TAPE UCBs in I/O cfg  */\n ulutcomm = SUBSTR(ulu,25+off,4)        /* # of COMM UCBs in I/O cfg  */\n ulutdasd = SUBSTR(ulu,29+off,4)        /* # of DASD UCBs in I/O cfg  */\n @uluchn  = C2X(ulufirst)\nSay 'CVT: '@cvt' CVTUCBA: '@cvtucba' ===> DASD chain trace started: 'TIME()\nSay '            CVTIXAV:'@cvtixav' IOVT:'@iovtadr' ULUT: '@ulutadr\nSay ' '\nSay '     This I/O configuration has 'C2D(ulutdasd)' DASD UCBs defined!'\nSay ' '\ni = 0 ; J = 0 ; pri = 0 ; pub = 0 ; sto = 0 ; smsv = 0\nDo i = 1 to C2D(uluucbno)               /* scan the ULUT for ALL DASD */\n    uluelmnt = STORAGE(@uluchn,12)       /* get 12 byte ULUT element */\n    uluucbad = SUBSTR(uluelmnt,9,4)     /* 1st ucb this device class */\n    uluucbad = C2X(uluucbad) ; @ucbchn = uluucbad\n   ucb     = STORAGE(@ucbchn,24)    /* get 24 byte ucb common segment */\n   ucbfl5  = SUBSTR(ucb,2,1)                  /* get flags5 bitstring */\n   ucbid   = SUBSTR(ucb,3,1)                 /* get the 'FF'x id byte */\n   ucbstat = SUBSTR(ucb,4,1)              /* status byte '80'x online */\n   ucbchan = SUBSTR(ucb,5,2)                /* channel address in hex */\n   ucbnxucb= SUBSTR(ucb,9,4)                   /* pointer to next ucb */\n   ucbtbyt3= SUBSTR(ucb,19,1)                 /* device '20'x is DASD */\n   ucbtbyt4= SUBSTR(ucb,20,1)           /* contains device type codes */\n   If (BITAND(ucbstat,'80'x)='80'x & BITAND(ucbtbyt3,'20'x)='20'x) Then Do\n      j = j + 1; device = ' Unknown'\n      ioaddr = C2X(ucbchan)\n      If BITAND(ucbfl5,'20'x)\\='20'x Then sms = 'Not SMS'\n                                     Else Do\n                                          sms = 'SMS    '\n                                          smsv = smsv + 1\n                                          End\n      If BITAND(ucbtbyt4,'04'x)='04'x Then device = '9340   '\n      If BITAND(ucbtbyt4,'06'x)='06'x Then device = '2305-1 '\n      If BITAND(ucbtbyt4,'07'x)='07'x Then device = '2305-2 '\n      If BITAND(ucbtbyt4,'08'x)='08'x Then device = '2314   '\n      If BITAND(ucbtbyt4,'09'x)='09'x Then device = '3330   '\n      If BITAND(ucbtbyt4,'0D'x)='0D'x Then device = '3330-11'\n      If BITAND(ucbtbyt4,'0A'x)='0A'x Then device = '3340   '\n      If BITAND(ucbtbyt4,'0B'x)='0B'x Then device = '3350   '\n      If BITAND(ucbtbyt4,'0C'x)='0C'x Then device = '3375   '\n      If BITAND(ucbtbyt4,'85'x)='85'x Then device = '6421   ' /*facom*/\n      If BITAND(ucbtbyt4,'0E'x)='0E'x Then device = '3380   '\n      If BITAND(ucbtbyt4,'0F'x)='0F'x Then device = '3390   '\n      @ucbx   = SUBSTR(ucb,21,4)          /* address of ucb extension */\n      @ucbx   = D2X(C2D(@ucbx))               /* binary to dec to hex */\n      @dce    = STORAGE(D2X(X2D(@ucbx)+24),4)       /* address of DCE */\n      @dce    = D2X(C2D(@dce))                /* binary to dec to hex */\n      @vib    = STORAGE(D2X(X2D(@dce)+4),4)         /* address of VIB */\n      @vib    = D2X(C2D(@vib))                /* binary to dec to hex */\n      vibflags= STORAGE(D2X(X2D(@vib)+6),1)    /* VTOC info flag byte */\n      If BITAND(vibflags,'80'x)='80'x Then vtocix = 'VTOCIX'\n                                      Else vtocix = '      '\n      @vvds   = STORAGE(D2X(X2D(@dce)+8),4)  /* address of VVDS block */\n      If C2D(@vvds) = 0 Then vvds = '    '\n                        Else vvds = 'VVDS'\n      @ucbchn=D2X(X2D(@ucbchn)+24)            /* bump to DASD segment */\n      ucbdasd = STORAGE(@ucbchn,24)       /* get 24 byte DASD segment */\n      ucbvoli = SUBSTR(ucbdasd,5,6)              /* volser if mounted */\n      ucbstab = SUBSTR(ucbdasd,11,1)         /* mount attribute codes */\n      mount = 'Unknown '\n      If BITAND(ucbstab,'10'x)='10'x Then Do\n         mount = 'Private'\n         pri = pri + 1\n         End\n      If BITAND(ucbstab,'08'x)='08'x Then Do\n         mount = 'Public '\n         pub = pub + 1\n         End\n      If BITAND(ucbstab,'04'x)='04'x Then Do\n         mount = 'Storage'\n         sto = sto + 1\n         End\n      Say RIGHT(j,4,' ') ucbvoli RIGHT(ioaddr,4) STRIP(device),\n          mount vtocix vvds sms\n   End\n   @uluchn  = D2X(x2d(@uluchn)+12)\nEnd\nSay ' '\nSay 'Summary ===>  Private: 'pri'  Storage: 'sto'  Public: 'pub'  SMS: 'smsv\nSay ' '\nSay 'Last UCB after 'i' blocks scanned.  Completed: 'TIME()\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTDCQ": {"ttr": 4609, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x01\\x15\\x02_\\x01\\x15\\x02o\\x18@\\x00\\x89\\x00\\x8a\\x00\\x00\\xc1\\xc3\\xc9\\xc5\\xd9\\xc9@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2015-01-25T00:00:00", "modifydate": "2015-01-26T18:40:00", "lines": 137, "newlines": 138, "modlines": 0, "user": "ACIERI"}, "text": "/*REXX*/\n/*****************************************************************/\n/* LISTDCQ: REXX program to display the device class queue.      */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                DCQ - Device Class Queue                       */\n/*                UCB - Device Unit Control Block                */\n/*                                                               */\n/*               ULUT - UCB Look Up table                        */\n/* UCB count, 1st UCB addr, # Act and Inact now derived from ULUT*/\n/* @ z/OS V2.2 the ULUT has been moved into 64 bit storage.      */\n/*****************************************************************/\nAddress TSO ; \"CLEAR\" ; Numeric Digits 20    /* 20 can handle 64 bits */\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                                /* binary to hex */\n@cvtdcqa  = STORAGE(D2X(X2D(@cvt)+1248),4)     /* get CVTDCQA address */\n@cvtdcqa  = D2X(C2D(@cvtdcqa))                       /* binary to hex */\n@cvtixav  = STORAGE(D2X(X2D(@cvt)+124),4)      /* get CVTIXAVL addres */\n@cvtixav  = D2X(C2D(@cvtixav))                       /* binary to hex */\n@iovtadr  = STORAGE(D2X(X2D(@cvtixav)+208),4)  /* get IOVT address    */\n@iovtadr  = D2X(C2D(@iovtadr))                       /* binary to hex */\n@ulutadr  = STORAGE(D2X(X2D(@iovtadr)+8),4)       /* get ULUT address */\n@ulutadr  = D2X(C2D(@ulutadr))                       /* binary to hex */\nif @ulutadr = 0 then                            /* zOS V2.2 or higher */\n  do\n   Say 'zOS:'MVSVAR(SYSOPSYS)' Ulut is in 64 bit storage'\n   @ulutadr  = STORAGE(D2X(X2D(@iovtadr)+440),8)  /* get IOVT address */\n   @ulutadr  = D2X(C2D(@ulutadr))                    /* binary to hex */\n  end\nSay 'CVT:'@cvt' CVTDCQA:'@cvtdcqa' ==> Device Class Queue 'DATE() TIME()\nSay '           CVTIXAV:'@cvtixav' IOVT:'@iovtadr' ULUT: '@ulutadr\nSay ' '\ndcq      = STORAGE(@cvtdcqa,20)             /* get 20 byte DCQ header */\ndcqname  = SUBSTR(dcq,1,4)                          /* dcq eyecatcher */\ndcqlngth = SUBSTR(dcq,5,2)                /* length of each dcq entry */\ndcqcount = SUBSTR(dcq,7,2)                      /* number of elements */\ndcqfirst = SUBSTR(dcq,9,4)              /* address of 1st dcq element */\ndcqdstct = SUBSTR(dcq,13,4)    /* entries in device class stats table */\ndcqucbno = SUBSTR(dcq,17,4) /* number of ucb's this I/O configuration */\n@dcqchn  = C2X(dcqfirst) ; i = 0\nulu      = STORAGE(@ulutadr,64)             /* get 56 byte ulu header */\nuluname  = SUBSTR(ulu,1,4)                         /* ulut eyecatcher */\nulutype  = SUBSTR(ulu,5,1)\nIf ulutype = '01'x Then off = 0                    /* ULUT Type 1     */\nIf ulutype = '02'x Then off = 8                    /* ULUT Type 2     */\nIf ulutype = '03'x Then                            /* ULUT Type 3     */\n Do\n   ulufirst = SUBSTR(ulu,17,8)          /* addr of 1st ULU element(64)*/\n   uluucbno = SUBSTR(ulu,29,4)          /* # of ucb's this I/O config */\n   off = 12\n End\nElse\n Do                                     /* Ulut type 1 or 2           */\n   ulufirst = SUBSTR(ulu,13+off,4)      /* address of 1st ULU element */\n   uluucbno = SUBSTR(ulu,17+off,4)      /* # of ucb's this I/O config */\n End\n uluttape = SUBSTR(ulu,21+off,4)        /* # of TAPE UCBs in I/O cfg  */\n ulutcomm = SUBSTR(ulu,25+off,4)        /* # of COMM UCBs in I/O cfg  */\n ulutdasd = SUBSTR(ulu,29+off,4)        /* # of DASD UCBs in I/O cfg  */\n ulutdisp = SUBSTR(ulu,33+off,4)        /* # of DISP UCBs in I/O cfg  */\n uluturec = SUBSTR(ulu,37+off,4)        /* # of UREC UCBs in I/O cfg  */\n ulutchar = SUBSTR(ulu,41+off,4)        /* # of CHAR UCBs in I/O cfg  */\n ulutctca = SUBSTR(ulu,45+off,4)        /* # of CTCA UCBs in I/O cfg  */\n@uluchn  = C2X(ulufirst)\nSay ' This I/O configuration has defined - DCQ UCBs: 'C2D(dcqucbno)\nSay '                                     ULUT Type: 'C2D(ulutype)\nSay '                                     ULUT UCBs: 'C2D(uluucbno)\nSay '                                         DCQEs: 'C2D(dcqcount)\nSay '                                       1stDCQE: '@dcqchn\nSay '                                       1stULUT: 'D2X(C2D(ulufirst))\nSay ' '\nSay '      Name____  ID_   UCBs   1stUCB__   Active   Inactive  ID=UCB'\nSay ' '\nDo i = 1 to C2D(dcqcount)          /* scan the DCQ for all dev classes*/\n   dcqelmnt = STORAGE(@dcqchn,28)          /* get 28 byte DCQ element */\n   dcqchain = SUBSTR(dcqelmnt,1,4)      /* get next element's address */\n   @dcqchn  = D2X(C2D(dcqchain))\n   dcqdevc.i = SUBSTR(dcqelmnt,5,1)    /* device class, i.e. UCBTBYT3 */\n   dcqucbct = SUBSTR(dcqelmnt,7,2)     /* ucb's for this device class */\n   dcqucbct = C2D(dcqucbct)\n   dcqucbad = SUBSTR(dcqelmnt,9,4)       /* 1st ucb this device class */\n   dcqucba.i = C2X(dcqucbad)             /* first UCB address in DCQ  */\n   dcqdevn.i = SUBSTR(dcqelmnt,13,8)             /* device class name */\n   act.i = 0 ; inact.i = 0 ; chk.i = 0        /* Initialize counters  */\n   uluucbc.i = 0 ; ok.i ='ERROR'              /* Initialize counters  */\nEnd                                                /* END oF DCQ scan */\n Do j = 1 to C2D(uluucbno)              /* scan the ULUT for ALL UCBs */\n     uluelmnt = STORAGE(@uluchn,12)       /* get 12 byte ULUT element */\n     uluucbad = SUBSTR(uluelmnt,9,4)     /* 1st ucb this device class */\n     uluucbad = C2X(uluucbad) ; @ucbchn = uluucbad\n      ucb     = STORAGE(@ucbchn,24) /* get 24 byte ucb common segment */\n      ucbstat = SUBSTR(ucb,4,1)           /* status byte '80'x online */\n      ucbnxucb= SUBSTR(ucb,9,4)                /* pointer to next ucb */\n      ucbtbyt3= SUBSTR(ucb,19,1)           /* device ID like dcqdevcl */\n   Do k = 1 to C2D(dcqcount)           /* loop through all dev classes*/\n      If ucbtbyt3 = dcqdevc.k Then\n        Do\n          chk.k = chk.k + 1\n          If BITAND(ucbstat,'80'x)='80'x Then act.k = act.k + 1\n                                     Else inact.k = inact.k + 1\n          If chk.k = 1 Then uluucba.k = uluucbad  /* 1st UCB from ULUT*/\n          uluucbc.k = uluucbc.k + 1\n        End\n   end                                 /* End  through all dev classes*/\n   @uluchn  = D2X(x2d(@uluchn)+12)\n End                                               /* End of ULUT scan*/\nSay ' '\n   Do l = 1 to C2D(dcqcount)                     /*  Print output     */\n   Select\n     When dcqdevn.l = 'TAPE' Then\n       If uluucbc.l = X2D(C2X(uluttape)) then ok.l = '*okay*'\n     When dcqdevn.l = 'COMM' Then\n       If uluucbc.l = X2D(C2X(ulutcomm)) then ok.l = '*okay*'\n     When dcqdevn.l = 'DASD' Then\n       If uluucbc.l = X2D(C2X(ulutdasd)) then ok.l = '*okay*'\n     When dcqdevn.l = 'DISP' Then\n       If uluucbc.l = X2D(C2X(ulutdisp)) then ok.l = '*okay*'\n     When dcqdevn.l = 'UREC' Then\n       If uluucbc.l = X2D(C2X(uluturec)) then ok.l = '*okay*'\n     When dcqdevn.l = 'CHAR' Then\n       If uluucbc.l = X2D(C2X(ulutchar)) then ok.l = '*okay*'\n     Otherwise\n       If uluucbc.l = X2D(C2X(ulutctca)) then ok.l = '*okay*'\n   End\n   If uluucbc.l = 0 Then Do\n      uluucba.l = '        '\n      act.l    = '    ' ; inact.l  = '    ' ; ok.l     = '      '\n   End\n   Say RIGHT(l,3)'   'dcqdevn.l'  'C2X(dcqdevc.l)'x',\n       '  'RIGHT(uluucbc.l,4)'   'uluucba.l,\n       '   'RIGHT(act.l,4)'      'RIGHT(inact.l,4)'    'ok.l\n   end                                           /* End  Print output */\nSay ' '\nSay 'Device Class Queue scan completed 'TIME()\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTENV": {"ttr": 4612, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00C\\x01\\x153o\\x01\\x153o\\x17\\x07\\x00\\xcc\\x00\\xcc\\x00\\x00\\xc1\\xc3\\xc9\\xc5\\xd9\\xc9@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2015-12-02T00:00:00", "modifydate": "2015-12-02T17:07:43", "lines": 204, "newlines": 204, "modlines": 0, "user": "ACIERI"}, "text": "/*REXX*/\n/*****************************************************************/\n/* LISTENV: REXX program to display system environment data.     */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*              JESCT - JES Control Table                        */\n/*             PCCAVT - Phys. Config. Comm. Area Vector Table    */\n/*               PCCA - Physical Config. Communications Area     */\n/*               TSVT - TSO Vector Table                         */\n/*               MQCT - HSM CVT                                  */\n/*                RCE - RSM Control and Enumeration Area         */\n/*                PSA - Prefixed Saved Area (CVT & PSAATCVT)     */\n/*              ASMVT - ASM Vector Table                         */\n/*                DCQ - Device Class Queue                       */\n/*                UCB - Device Unit Control Block                */\n/*****************************************************************/\nAddress TSO ; \"CLEAR\" ; Numeric Digits 20\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                                /* binary to hex */\n@cvtprodn = D2X(X2D(@cvt)-40)                 /* get CVTPRODN address */\nmvssplvl  = STORAGE(@cvtprodn,8)                      /* get SP level */\n@cvtprodi = D2X(X2D(@cvt)-32)                 /* get CVTPRODI address */\nmvsfmid   = STORAGE(@cvtprodi,8)                          /* get FMID */\n@cvtmdl   = D2X(X2D(@cvt)-6)                    /* get CVTMDL address */\ncpumodel  = STORAGE(@cvtmdl,2)                           /* get MODEL */\ncpumodel  = C2X(cpumodel)\n@cvtsysad = STORAGE(D2X(X2D(@cvt)+48),4)      /* get CVTSYSAD address */\n@cvtsysad = D2X(C2D(@cvtsysad))                      /* binary to hex */\nsysresucb = STORAGE(@cvtsysad,48)                          /* get UCB */\nucbchan   = SUBSTR(sysresucb,4,3)            /* correct for 4 char ucb*/\nucbchan   = SUBSTR(C2X(ucbchan),3)           /* Correct for 4 char UCB*/\nucbvoli   = SUBSTR(sysresucb,29,6)\n@cvttvt   = STORAGE(D2X(X2D(@cvt)+156),4)       /* get CVTTVT address */\n@cvttvt   = D2X(C2D(@cvttvt))                        /* binary to hex */\ntsvtlver  = STORAGE(D2X(X2D(@cvttvt)+100),1)          /* get TSVTLVER */\ntsvtlrel  = STORAGE(D2X(X2D(@cvttvt)+101),2)          /* get TSVTLREL */\ntsvtlmod  = STORAGE(D2X(X2D(@cvttvt)+103),1)          /* get TSVTLMOD */\n  tsoe = tsvtlver'.'tsvtlrel'.'tsvtlmod\n@cvtmz00  = STORAGE(D2X(X2D(@cvt)+164),4)              /* get CVTMZ00 */\n@cvtmz00  = D2X(C2D(@cvtmz00))                       /* binary to hex */\n  eovm  = ((X2D(@cvtmz00)+1)/1048576)'M'\n@cvtjesct = STORAGE(D2X(X2D(@cvt)+296),4)     /* get CVTJESCT address */\n@cvtjesct = D2X(C2D(@cvtjesct))                      /* binary to hex */\n  jes     = STORAGE(D2X(X2D(@cvtjesct)+28),4)         /* get JES name */\n@cvteorm  = STORAGE(D2X(X2D(@cvt)+312),4)      /* get CVTEORM address */\n@cvteorm  = D2X(C2D(@cvteorm))                       /* binary to hex */\n  cstor = ((X2D(@cvteorm)+1)/1048576)'M'             /* convert to MB */\n@cvtext2  = STORAGE(D2X(X2D(@cvt)+328),4)      /* get CVTEXT2 address */\n@cvtext2  = D2X(C2D(@cvtext2))                       /* binary to hex */\ncvtnucls  = STORAGE(D2X(X2D(@cvtext2)+4),1)   /* get selected nucleus */\n@cvtasmvt = STORAGE(D2X(X2D(@cvt)+704),4)     /* get CVTASMVT address */\n@cvtasmvt = D2X(C2D(@cvtasmvt))                      /* binary to hex */\nasmflag2  = STORAGE(D2X(X2D(@cvtasmvt)+1),1)\n  clpa = '(NO CLPA)'\n  If BITAND(asmflag2,'08'x) \\= '08'x Then clpa = '(CLPA)'\n@cvtpccat = STORAGE(D2X(X2D(@cvt)+764),4)     /* get CVTPCCAT address */\n@cvtpccat = D2X(C2D(@cvtpccat))                      /* binary to hex */\n@cvtrlstg = STORAGE(D2X(X2D(@cvt)+856),4)       /* get CVTRLSTG bytes */\n@cvtrlstg = C2D(@cvtrlstg)                           /* binary to dec */\n  cstorol = ((@cvtrlstg)/1024)'M'                    /* convert to MB */\n@cvthsm   = STORAGE(D2X(X2D(@cvt)+988),4)       /* get CVTHSM address */\n@cvthsm   = D2X(C2D(@cvthsm))                        /* binary to hex */\nmqctver   = STORAGE(D2X(X2D(@cvthsm)+48),2)            /* get MQCTVER */\nmqctrel   = STORAGE(D2X(X2D(@cvthsm)+50),1)            /* get MQCTREL */\nmqctmod   = STORAGE(D2X(X2D(@cvthsm)+51),1)            /* get MQCTMOD */\n  hsm  = mqctver'.'mqctrel'.'mqctmod\n@cvtdfa   = STORAGE(D2X(X2D(@cvt)+1216),4)      /* get CVTDFA address */\n@cvtdfa   = D2X(C2D(@cvtdfa))                        /* binary to hex */\ndfadata   = STORAGE(@cvtdfa,4)                  /* get DFP level data */\ndfadata   = C2X(dfadata)\ndfaver    = SUBSTR(dfadata,5,1)                    /* get DFP version */\ndfarel    = SUBSTR(dfadata,6,1)                    /* get DFP release */\ndfamod    = SUBSTR(dfadata,7,1)                    /* get DFP mod lvl */\n  dfp  = dfaver'.'dfarel'.'dfamod\n@cvtrcep  = STORAGE(D2X(X2D(@cvt)+1168),4)     /* get CVTRCEP address */\n@cvtrcep  = D2X(C2D(@cvtrcep))                       /* binary to hex */\nrceespl   = STORAGE(D2X(X2D(@cvtrcep)+160),4)  /* get RCEESPL frames  */\n  estor = ((C2D(rceespl)*4096)/1048576)'M'           /* convert to MB */\n@psaatcvt = STORAGE(408,4)             /* get VTAM ATCVT from PSAAOLD */\n@psaatcvt = D2X(C2D(@psaatcvt))                      /* binary to hex */\natcvtdata = STORAGE(@psaatcvt,4)               /* get VTAM level data */\natcvtdata = C2X(atcvtdata)\natcvtver  = SUBSTR(atcvtdata,6,1)                 /* get VTAM version */\natcvtrel  = SUBSTR(atcvtdata,8,1)                 /* get VTAM release */\n  vtam = atcvtver'.'atcvtrel\nSay 'CVT:'@cvt'   SYSTEM ENVIRONMENT DATA on 'DATE() TIME()\nSay ' '\nSay '   Software -   MVS: 'mvssplvl' ('STRIP(mvsfmid)')    JES: 'jes\nSay '                DFP: 'dfp'               TSO/E: 'tsoe\nSay '               VTAM: 'vtam'                   HSM:'hsm\nSay '                IPL: 'ucbvoli' @ 'ucbchan'     Nucleus: 'cvtnucls,\n    '  'clpa\nSay ' '\nSay '  Processor - Model: 'cpumodel\nSay '              CSTOR: 'cstor'   ('cstorol' on-line)    ESTOR: 'estor\nSay '              VSTOR: 'eovm'  (Highest virtual address '@cvtmz00'/',\n    X2D(@cvtmz00)')'\nDo i = 0 to 15                                 /* loop thru CPU table */\n   @pcca = STORAGE(D2X(X2D(@cvtpccat)+(i*4)),4)\n   @pcca = C2X(@pcca)\n   If @pcca \\= 0 Then Do\n      Say '                CPU: 'RIGHT(i,2,0),\n          '    ('STORAGE(D2X(X2D(@pcca)+4),8)')'\n      End\n   End\n@cvtdcqa  = STORAGE(D2X(X2D(@cvt)+1248),4)     /* get CVTDCQA address */\n@cvtdcqa  = D2X(C2D(@cvtdcqa))                       /* binary to hex */\n@cvtixav  = STORAGE(D2X(X2D(@cvt)+124),4)      /* get CVTIXAVL addres */\n@cvtixav  = D2X(C2D(@cvtixav))                       /* binary to hex */\n@iovtadr  = STORAGE(D2X(X2D(@cvtixav)+208),4)  /* get IOVT address    */\n@iovtadr  = D2X(C2D(@iovtadr))                       /* binary to hex */\n@ulutadr  = STORAGE(D2X(X2D(@iovtadr)+8),4)    /* get IOVT address    */\n@ulutadr  = D2X(C2D(@ulutadr))                       /* binary to hex */\nif @ulutadr = 0 then                            /* zOS V2.2 or higher */\n  do\n   Say ''\n   @ulutadr  = STORAGE(D2X(X2D(@iovtadr)+440),8)  /* get IOVT address */\n   @ulutadr  = D2X(C2D(@ulutadr))                    /* binary to hex */\n   Say 'zOS:'MVSVAR(SYSOPSYS)' Ulut is in 64 bit storage @ '@ulutadr\n  end\nulu      = STORAGE(@ulutadr,64)             /* get 56 byte ulu header */\nuluname  = SUBSTR(ulu,1,4)                         /* ulut eyecatcher */\nulutype  = SUBSTR(ulu,5,1)                         /* ulut Type 1 or 2*/\nIf ulutype = '01'x Then off = 0                    /* ULUT Type 1     */\n                   Else off = 8                    /* ULUT Type 2     */\nIf ulutype = '03'x Then                            /* ULUT Type 3     */\n Do\n   ulufirst = SUBSTR(ulu,17,8)          /* addr of 1st ULU element(64)*/\n   uluucbno = SUBSTR(ulu,29,4)          /* # of ucb's this I/O config */\n   off = 12\n End\nElse\n Do                                     /* Ulut type 1 or 2           */\n   ulufirst = SUBSTR(ulu,13+off,4)      /* address of 1st ULU element */\n   uluucbno = SUBSTR(ulu,17+off,4)      /* # of ucb's this I/O config */\n End\n uluttape = SUBSTR(ulu,21+off,4)        /* # of TAPE UCBs in I/O cfg  */\n ulutcomm = SUBSTR(ulu,25+off,4)        /* # of COMM UCBs in I/O cfg  */\n ulutdasd = SUBSTR(ulu,29+off,4)        /* # of DASD UCBs in I/O cfg  */\n ulutdisp = SUBSTR(ulu,33+off,4)        /* # of DISP UCBs in I/O cfg  */\n uluturec = SUBSTR(ulu,37+off,4)        /* # of UREC UCBs in I/O cfg  */\n ulutchar = SUBSTR(ulu,41+off,4)        /* # of CHAR UCBs in I/O cfg  */\n ulutctca = SUBSTR(ulu,45+off,4)        /* # of CTCA UCBs in I/O cfg  */\n@uluchn  = C2X(ulufirst)\ndcq      = STORAGE(@cvtdcqa,20)             /* get 20 byte DCQ header */\ndcqcount = SUBSTR(dcq,7,2)                      /* number of elements */\ndcqfirst = SUBSTR(dcq,9,4)              /* address of 1st dcq element */\n@dcqchn  = C2X(dcqfirst) ; i = 0\nSay ' '\nSay '        I/O - Device    Class   UCBs  Active  ID=UCB'\nSay '              --------  ------  ----  ------  ------'\nDo i = 1 to C2D(dcqcount)          /* scan the DCQ for all dev classes*/\n   dcqelmnt = STORAGE(@dcqchn,28)          /* get 28 byte DCQ element */\n   dcqchain = SUBSTR(dcqelmnt,1,4)      /* get next element's address */\n   @dcqchn  = D2X(C2D(dcqchain))\n   dcqdevc.i = SUBSTR(dcqelmnt,5,1)    /* device class, i.e. UCBTBYT3 */\n   dcqdevn.i = SUBSTR(dcqelmnt,13,8)             /* device class name */\n   act.i = 0 ; uluucbc.i = 0 ; ok.i ='ERROR'  /* Initialize counters  */\nEnd\n Do j = 1 to C2D(uluucbno)              /* scan the ULUT for ALL UCBs */\n     uluelmnt = STORAGE(@uluchn,12)       /* get 12 byte ULUT element */\n     uluucbad = SUBSTR(uluelmnt,9,4)     /* 1st ucb this device class */\n     uluucbad = C2X(uluucbad) ; @ucbchn = uluucbad\n      ucb     = STORAGE(@ucbchn,24) /* get 24 byte ucb common segment */\n      ucbstat = SUBSTR(ucb,4,1)           /* status byte '80'x online */\n      ucbnxucb= SUBSTR(ucb,9,4)                /* pointer to next ucb */\n      ucbtbyt3= SUBSTR(ucb,19,1)           /* device ID like dcqdevcl */\n   Do k = 1 to C2D(dcqcount)           /* loop through all dev classes*/\n      If ucbtbyt3 = dcqdevc.k Then\n        Do\n          If BITAND(ucbstat,'80'x)='80'x Then act.k = act.k + 1\n          uluucbc.k = uluucbc.k + 1\n        End\n   end                                 /* End  through all dev classes*/\n   @uluchn  = D2X(x2d(@uluchn)+12)\n End                                               /* End of ULUT scan*/\n    Do l = 1 to C2D(dcqcount)                     /*  Print output    */\n    Select\n      When dcqdevn.l = 'TAPE' Then\n        If uluucbc.l = X2D(C2X(uluttape)) then ok.l = '*okay*'\n      When dcqdevn.l = 'COMM' Then\n        If uluucbc.l = X2D(C2X(ulutcomm)) then ok.l = '*okay*'\n      When dcqdevn.l = 'DASD' Then\n        If uluucbc.l = X2D(C2X(ulutdasd)) then ok.l = '*okay*'\n      When dcqdevn.l = 'DISP' Then\n        If uluucbc.l = X2D(C2X(ulutdisp)) then ok.l = '*okay*'\n      When dcqdevn.l = 'UREC' Then\n        If uluucbc.l = X2D(C2X(uluturec)) then ok.l = '*okay*'\n      When dcqdevn.l = 'CHAR' Then\n        If uluucbc.l = X2D(C2X(ulutchar)) then ok.l = '*okay*'\n      Otherwise\n        If uluucbc.l = X2D(C2X(ulutctca)) then ok.l = '*okay*'\n    End\n    If uluucbc.l = 0 Then Do\n       uluucba.l = '        '\n       act.l    = '    ' ; ok.l     = '      '\n    End\n   Say '              'dcqdevn.l'   'C2X(dcqdevc.l)'x',\n       '   'RIGHT(uluucbc.l,4),\n       '   'RIGHT(act.l,4)'  'ok.l\n    end                                          /* End  Print output */\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTESRT": {"ttr": 4616, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x94\\x08\\x8f\\x01\\x14\\x06?\\x01\\t\\x00\\xc2\\x00\\xc2\\x00\\x00\\xc1\\xc3\\xc9\\xc5\\xd9\\xc9@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-03-04T01:09:00", "lines": 194, "newlines": 194, "modlines": 0, "user": "ACIERI"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTESRT: REXX program to display all router SVCs.             */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*               SCVT - Supervisor Call Vector Table             */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\n/*--------------virtual storage map definition section----------------*/\nNumeric Digits 10           /* required to handle decimal conversions */\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */\n@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */\n@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */\n@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */\n@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */\n@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */\n@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */\n@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */\n@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */\n@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */\n@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */\n@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */\n@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */\n@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */\n@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */\n@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */\n@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */\n@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */\n@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */\n@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */\n@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */\n@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */\n@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */\n@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */\n@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */\n@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */\n@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */\n@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */\n@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */\n@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */\n@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */\n@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */\n@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */\n@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */\n@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */\n@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */\n@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */\n@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */\n@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */\n@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */\n@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */\n@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */\n@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */\n@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */\n@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */\n@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */\n@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */\n@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */\n        /*------simplify variable names & make addresses decimal------*/\n@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/\n   csa1 = X2D(@csa1g) ; csa2 = X2D(@csa2g)                    /* csa  */\n@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */\n   mlpa1 = X2D(@mlpa1) ; mlpa2 = X2D(@mlpa2)\n@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */\n   flpa1 = X2D(@flpa1) ; flpa2 = X2D(@flpa2)\n@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */\n   plpa1 = X2D(@plpa1) ; plpa2 = X2D(@plpa2)\n@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */\n   sqa1 = X2D(@sqa1) ; sqa2 = X2D(@sqa2)\n@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */\n   nuc1 = X2D(@nuc1) ; nuc2 = X2D(@nuc2)\n@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */\n  esqa1 = X2D(@esqa1) ; esqa2 = X2D(@esqa2)\n@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/\n eplpa1 = X2D(@eplpa1) ; eplpa2 = X2D(@eplpa2)\n@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/\n eflpa1 = X2D(@eflpa1) ; eflpa2 = X2D(@eflpa2)\n@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/\n emlpa1 = X2D(@emlpa1) ; emlpa2 = X2D(@emlpa2)\n@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/\n  ecsa1 = X2D(@ecsa1g) ; ecsa2 = X2D(@ecsa2g)\n@eprivs = X2D(@ecsa2g)+1                               /* ext private */\n@eprive = 2147483647                         /* fixed by architecture */\n epriv1 = @eprivs ; epriv2 = @eprive\n@psas   = 0 ; @psae = 4095                       /* psa fixed by arch */\n   psa1 = @psas ; psa2 = @psae\n@prive  = X2D(@csa1g)-1 ; @privs = X2D(@psae)+1            /* private */\n  priv1 = @privs ; priv2 = @prive\n              /*------------------------------------------------------*/\n             /* Usage Notes: Hex character compares are incompatible */\n            /*    for storage residency determination.  Thus, entry */\n           /*     point addresses must be converted to decimal and */\n          /*      VS boundary addresses must be converted to de-  */\n         /*       cimal for correct compare operations.          */\n        /*------------------------------------------------------*/\n/*----------end of virtual storage map definition section-------------*/\n@cvtabend = STORAGE(D2X(X2D(@cvt)+200),4)    /* get CVTABEND address  */\n@cvtabend = D2X(C2D(@cvtabend))                /* binary to hex       */\n@scvtsvct = D2X(X2D(@cvtabend)+132)          /* SCVT addressibility   */\n@scvtsvct = STORAGE(@scvtsvct,4)                  /* SVCT table       */\n@scvtsvct = D2X(C2D(@scvtsvct))                /* binary to hex       */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' CVTABEND:'@cvtabend' SCVTSVCT:'@scvtsvct' 'DATE() TIME()\nSay ' '\nSay 'Active ESR SVCs follow:'\nSay ' '\nactive = 0 ; inactive = 0 ; esrsvc = 0\nmodule = 'IGXERROR' ; Call \"#NUCLKUP\" module ; igxerror = Result\nDo i = 0 to 255                                 /* loop thru storage  */\n   bytes = STORAGE(D2X(X2D(@scvtsvct)+(i*8)),8)\n   bytes = C2X(bytes)\n   svcep  = SUBSTR(bytes,1,8)\n   svctp2 = SUBSTR(bytes,10,1)\n   If svctp2 = '4'            /* EP address is an ESR table */\n      Then Do\n         esrid = STORAGE(svcep,4)                 /* table eyecatcher */\n         esrct = C2X(STORAGE(D2X(X2D(svcep)+4),4))       /* esr count */\n     Say 'SVC 'i' is 'esrid'.  Table at 'svcep', Slots 'X2D(esrct)' ('esrct')'\n         Say ' '\n         esrsvc = 0\n         Do j = 0 to X2D(esrct)                   /* process this ESR */\n            bytes = STORAGE(D2X(X2D(svcep)+(j*8)+8),8)\n   addr = SUBSTR(bytes,1,4)       /* sloppy code to grap EP in binary */\n   bytes = C2X(bytes)          /* legacy code before learning bit ops */\n            esrep  = SUBSTR(bytes,1,8)\n                                        /* determine storage location */\n   addr = BITAND(addr,'7FFFFFFF'x)        /* shave off amode bit (32) */\n   addr = C2D(addr)                      /* make numeric for compares */\n   sloc = 'ERROR'                       /* determine module residency */\n   If (addr >= csa1   & addr <= csa2  ) Then sloc = 'CSA  '\n      Else If (addr >= mlpa1  & addr <= mlpa2 ) Then sloc = 'MLPA '\n      Else If (addr >= flpa1  & addr <= flpa2 ) Then sloc = 'FLPA '\n      Else If (addr >= plpa1  & addr <= plpa2 ) Then sloc = 'PLPA '\n      Else If (addr >= sqa1   & addr <= sqa2  ) Then sloc = 'SQA  '\n      Else If (addr >= nuc1   & addr <= nuc2  ) Then sloc = 'NUC  '\n      Else If (addr >= esqa1  & addr <= esqa2 ) Then sloc = 'ESQA '\n      Else If (addr >= eplpa1 & addr <= eplpa2) Then sloc = 'EPLPA'\n      Else If (addr >= eflpa1 & addr <= eflpa2) Then sloc = 'EFLPA'\n      Else If (addr >= emlpa1 & addr <= emlpa2) Then sloc = 'EMLPA'\n      Else If (addr >= ecsa1  & addr <= ecsa2 ) Then sloc = 'ECSA '\n      Else If (addr >= epriv1 & addr <= epriv2) Then sloc = 'EPRIV'\n      Else If (addr >= priv1  & addr <= priv2 ) Then sloc = 'PRIV '\n      Else If (addr >= psa1   & addr <= psa2  ) Then sloc = 'PSA  '\n            esrtp2 = SUBSTR(bytes,10,1)\n            esrmisc = '   '\n            If esrtp2 = '8'\n               Then esrmisc = 'APF'\n            inactflag = 0\n            If igxerror = Right(D2X(addr),8,0) /* normalize address */\n               Then inactflag = 1\n               Else Do\n                       active = active + 1\n                       esrsvc = esrsvc + 1\n                    End\n            esrtp1 = SUBSTR(bytes,9,1)\n               Select\n                  When esrtp1 = '0'\n                     Then esrtype = 'TYPE 1  '\n                  When esrtp1 = '8'\n                     Then esrtype = 'TYPE 2  '\n                  When esrtp1 = 'C'\n                     Then esrtype = 'TYPE 3/4'\n                  When esrtp1 = '2'\n                     Then esrtype = 'TYPE 6  '\n               Otherwise\n                          esrtype = 'TYPE ?  '\n               End\n            If inactflag = 0\n               Then Say  '   ESR 'RIGHT(j,3,0) '('RIGHT(D2X(j),2,0)')',\n                          esrtype esrep sloc esrmisc\n         End\n         Say ' '\n         Say '     Total ESR SVCs this table 'esrsvc\n         Say ' '\n         Say ' '\n      End\nEnd\nSay ' '\nSay 'This system contains 'active' ESR SVCs'\nSay ' '\nSay '  (IGXERROR nucleus address = 'igxerror')'\nSay ' '\nSay 'ESRTABLE processing complete ' TIME()\nSay ' '\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTLLT": {"ttr": 4620, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x94\\x08\\x8f\\x01\\x14\\x05\\x0f\"W\\x00-\\x00-\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-02-19T22:57:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "SCNS03"}, "text": "/*REXX*/\n/*****************************************************************/\n/* LISTLLT: REXX program to display Linklist Lookaside Table.    */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                LLT - Linklist Lookaside Table                 */\n/*               DCB3 - Data Control Block (BDAM)                */\n/*                DEB - IOS Data Extent Block                    */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtlink  = STORAGE(D2X(X2D(@cvt)+8),4)      /* get CVTLINK address   */\n@cvtlink  = D2X(C2D(@cvtlink))                 /* binary to hex       */\n@dcbdebad = STORAGE(D2X(X2D(@cvtlink)+44),4)    /* LINKLIB DCB to DEB */\n@dcbdebad = D2X(C2D(@dcbdebad))                 /* convert to hex     */\ndebflgs1  = STORAGE(D2X(X2D(@dcbdebad)+14),1)     /* LINKLIB DEBflags */\n   debapfin = 'LNKLST'\n   If BITAND(debflgs1,'02'x)\\='02'x Then debapfin = 'APFTAB'\n@cvtllta  = STORAGE(D2X(X2D(@cvt)+1244),4)   /* get CVTLLTA address   */\n@cvtllta  = D2X(C2D(@cvtllta))                 /* binary to hex       */\nlltcount  = C2D(STORAGE(D2X(X2D(@cvtllta)+7),1))  /* LLT libraries    */\nlltllen   = C2D(STORAGE(D2X(X2D(@cvtllta)+8),1))  /* length 1st entry */\n@lltentry = X2D(@cvtllta)+9           /* address of 1st LLT entry     */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' CVTLLTA:'@cvtllta' DCB:'@cvtlink,\n    'DEB:'@dcbdebad' FLGS1:'C2X(debflgs1)' LNKAUTH='debapfin\nSay ' '\nSay 'LLT scan on 'DATE()' started: 'TIME()\nSay ' '\nDo i = 1 to lltcount                            /* loop thru storage  */\n   lltlib.i = STORAGE(D2X(@lltentry),lltllen)   /* get the LLT entry  */\n   @lltentry = @lltentry + 45                   /* bump to next entry */\n   lltllen = C2D(STORAGE(D2X(@lltentry-1),1))   /* length of next  */\nEnd\nSay '--------------DATA SET NAME-----------------'\nSay ' '\nDo i = 1 to lltcount                            /* print the list     */\n   Say SUBSTR(lltlib.i,1,44,' ') i\nEnd\nSay ' '\nSay 'LLT scan completed: 'TIME()\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTLPAQ": {"ttr": 4865, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x94\\x08\\x8f\\x01\\x14\\x05\\x0f\"@\\x00\\xa2\\x00\\xa2\\x00\\x00\\xc1\\xc3\\xc9\\xc5\\xd9\\xc9@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-02-19T22:40:00", "lines": 162, "newlines": 162, "modlines": 0, "user": "ACIERI"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTLPAQ: REXX program to display LPA Queue (MVS job pack).    */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                GDA - Global Data Area                         */\n/*               LPAQ - Link Pack Area Queue                     */\n/*                CDE - Contents Directory Entry                 */\n/*                                                               */\n/*****************************************************************/\n/*--------------virtual storage map definition section----------------*/\nNumeric Digits 10           /* required to handle decimal conversions */\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */\n@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */\n@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */\n@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */\n@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */\n@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */\n@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */\n@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */\n@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */\n@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */\n@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */\n@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */\n@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */\n@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */\n@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */\n@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */\n@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */\n@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */\n@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */\n@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */\n@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */\n@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */\n@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */\n@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */\n@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */\n@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */\n@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */\n@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */\n@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */\n@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */\n@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */\n@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */\n@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */\n@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */\n@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */\n@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */\n@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */\n@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */\n@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */\n@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */\n@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */\n@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */\n@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */\n@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */\n@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */\n@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */\n@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */\n@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */\n        /*------simplify variable names & make addresses decimal------*/\n@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/\n   csa1 = X2D(@csa1g) ; csa2 = X2D(@csa2g)                    /* csa  */\n@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */\n   mlpa1 = X2D(@mlpa1) ; mlpa2 = X2D(@mlpa2)\n@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */\n   flpa1 = X2D(@flpa1) ; flpa2 = X2D(@flpa2)\n@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */\n   plpa1 = X2D(@plpa1) ; plpa2 = X2D(@plpa2)\n@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */\n   sqa1 = X2D(@sqa1) ; sqa2 = X2D(@sqa2)\n@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */\n   nuc1 = X2D(@nuc1) ; nuc2 = X2D(@nuc2)\n@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */\n  esqa1 = X2D(@esqa1) ; esqa2 = X2D(@esqa2)\n@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/\n eplpa1 = X2D(@eplpa1) ; eplpa2 = X2D(@eplpa2)\n@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/\n eflpa1 = X2D(@eflpa1) ; eflpa2 = X2D(@eflpa2)\n@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/\n emlpa1 = X2D(@emlpa1) ; emlpa2 = X2D(@emlpa2)\n@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/\n  ecsa1 = X2D(@ecsa1g) ; ecsa2 = X2D(@ecsa2g)\n@eprivs = X2D(@ecsa2g)+1                               /* ext private */\n@eprive = 2147483647                         /* fixed by architecture */\n epriv1 = @eprivs ; epriv2 = @eprive\n@psas   = 0 ; @psae = 4095                       /* psa fixed by arch */\n   psa1 = @psas ; psa2 = @psae\n@prive  = X2D(@csa1g)-1 ; @privs = X2D(@psae)+1            /* private */\n  priv1 = @privs ; priv2 = @prive\n              /*------------------------------------------------------*/\n             /* Usage Notes: Hex character compares are incompatible */\n            /*    for storage residency determination.  Thus, entry */\n           /*     point addresses must be converted to decimal and */\n          /*      VS boundary addresses must be converted to de-  */\n         /*       cimal for correct compare operations.          */\n        /*------------------------------------------------------*/\n/*----------end of virtual storage map definition section-------------*/\n@cvtqlpaq = STORAGE(D2X(X2D(@cvt)+188),4)    /* get CVTqlpaq address  */\n@cvtqlpaq = D2X(C2D(@cvtqlpaq))                /* binary to hex       */\n@lpaqptr  = STORAGE(@cvtqlpaq,4)             /* get pointer to LPAQ   */\n@lpaqptr  = D2X(C2D(@lpaqptr))                 /* binary to hex       */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' CVTQLPAQ:'@cvtqlpaq' LPAQPTR:'@lpaqptr' 'DATE() TIME()\n@cdechn = @lpaqptr\nSay ' '\ni = 0\nDo While @cdechn \\= '00000000'\n   i = i + 1\n   cde = STORAGE(@cdechn,32)                          /* get the cde */\n   cdname = SUBSTR(cde,9,8)\n   cdentpt= SUBSTR(cde,17,4)\n                                        /* determine storage location */\n   addr = BITAND(cdentpt,'7FFFFFFF'x)     /* shave off amode bit (32) */\n   addr = C2D(addr)                      /* make numeric for compares */\n   sloc = 'ERROR'                       /* determine module residency */\n   If (addr >= csa1   & addr <= csa2  ) Then sloc = 'CSA  '\n      Else If (addr >= mlpa1  & addr <= mlpa2 ) Then sloc = 'MLPA '\n      Else If (addr >= flpa1  & addr <= flpa2 ) Then sloc = 'FLPA '\n      Else If (addr >= plpa1  & addr <= plpa2 ) Then sloc = 'PLPA '\n      Else If (addr >= sqa1   & addr <= sqa2  ) Then sloc = 'SQA  '\n      Else If (addr >= nuc1   & addr <= nuc2  ) Then sloc = 'NUC  '\n      Else If (addr >= esqa1  & addr <= esqa2 ) Then sloc = 'ESQA '\n      Else If (addr >= eplpa1 & addr <= eplpa2) Then sloc = 'EPLPA'\n      Else If (addr >= eflpa1 & addr <= eflpa2) Then sloc = 'EFLPA'\n      Else If (addr >= emlpa1 & addr <= emlpa2) Then sloc = 'EMLPA'\n      Else If (addr >= ecsa1  & addr <= ecsa2 ) Then sloc = 'ECSA '\n      Else If (addr >= epriv1 & addr <= epriv2) Then sloc = 'EPRIV'\n      Else If (addr >= priv1  & addr <= priv2 ) Then sloc = 'PRIV '\n      Else If (addr >= psa1   & addr <= psa2  ) Then sloc = 'PSA  '\n   cdxlmjp= C2X(SUBSTR(cde,21,4))\n   cduse  = C2D(SUBSTR(cde,25,2))\n   cdattr =     SUBSTR(cde,29,1)  /* do NOT convert raw byte */\n   alias = 0 ; If (BITAND(cdattr,'04'x)='04'x) Then alias = 1\n   cdattr2=     SUBSTR(cde,30,1)  /* do NOT convert raw byte */\n   auth = 0 ; If (BITAND(cdattr2,'01'x)='01'x) Then auth = 1\n   cdemjp  = '         '\n   cdemjnm = '        '\n   If alias = 1 Then Do\n                        cdemjp  = ' Alias of'\n                        cdemjnm = STORAGE(D2X(X2D(cdxlmjp)+8),8)\n                     End\n   Say 'LPAQ'RIGHT(i,4,0),\n       cdname ,\n       C2X(cdentpt) ,\n       sloc ,\n       'USE:'RIGHT(cduse,5,0) ,\n        'AC:'auth ,\n        cdemjp cdemjnm\n   @cdechn = C2X(LEFT(cde,4))                 /* get next cde address */\nEnd\nSay ' '\nSay 'End of LPA Queue scan ' TIME()\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTLPAT": {"ttr": 4869, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x08\\x8f\\x00\\x94\\x08\\x8f\\x10\\x00\\x00&\\x00&\\x00\\x00\\xc3\\xd6\\xd5\\xe8\\xc5\\xd9\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "1994-03-29T10:00:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "CONYERS"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTLPAT: REXX program to display LPA libraries.               */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*               LPAT - Link Pack Area (libraries) Table         */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* get CVTEPLPS address  */\n@cvteplps = STORAGE(@cvteplps,4)             /* get LPAT address      */\n@cvteplps = D2X(C2D(@cvteplps))                /* binary to hex       */\nlpatcount = C2D(STORAGE(D2X(X2D(@cvteplps)+4),4)) /* LPAT entries     */\nlpatlen   = C2D(STORAGE(D2X(X2D(@cvteplps)+8),1)) /* length 1st entry */\n@lpatentry= X2D(@cvteplps)+9          /* address of 1st LPAT entry    */\nSay 'CVT:'@cvt  'CVTSMEXT:'@cvtsmext'  CVTEPLPS:'@cvteplps,\n    '  'DATE() TIME()\nSay ' '\nSay 'The LPAT table contains 'lpatcount 'entries, as follows:'\nSay ' '\nDo i = 1 to lpatcount                           /* loop thru storage  */\n   lpatlib.i = STORAGE(D2X(@lpatentry),lpatlen) /* get the LLT entry  */\n   @lpatentry = @lpatentry + 45                 /* bump to next entry */\n   lpatlen = C2D(STORAGE(D2X(@lpatentry-1),1))  /* length of next     */\nEnd\nSay '--------------DATA SET NAME-----------------'\nSay ' '\nDo i = 1 to lpatcount                           /* print the list     */\n   Say SUBSTR(lpatlib.i,1,44,' ') i\nEnd\nExit\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTNUCM": {"ttr": 4871, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x94\\x08\\x8f\\x01\\x14\\x05\\x0f\"Y\\x00>\\x00>\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-02-19T22:59:00", "lines": 62, "newlines": 62, "modlines": 0, "user": "SCNS03"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTNUCM: REXX program to display the nucleus map.             */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*              NUCMP - Nucleus Map Table (16 bytes by n rows)   */\n/*                                                               */\n/*****************************************************************/\nNumeric Digits 10\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtnucmp = STORAGE(D2X(X2D(@cvt)+1200),4)   /* get CVTNUCMP address  */\n@cvtnucmp = D2X(C2D(@cvtnucmp))                /* binary to hex       */\nnucmapid  = STORAGE(@cvtnucmp,8)           /* nucmap eyecatcher entry */\nnucmeot   = C2D(STORAGE(D2X(X2D(@cvtnucmp)+8),4))  /* table end addrs */\nnucmlen   = C2D(STORAGE(D2X(X2D(@cvtnucmp)+13),3)) /* nucm tbl length */\n@nucmentry= X2D(@cvtnucmp)+16          /* address of 1st nucmap entry */\nAddress TSO ; 'CLEAR'\nSay 'CVT:'@cvt  'CVTNUCMP:'@cvtnucmp'  NUCMLEN:'nucmlen' bytes',\n    '  'DATE() TIME()\nSay ' '\nIf nucmapid \\= 'NUCMAP  ' Then Do\n   Say 'Error: Nucleus map table eyecatcher not found'\n   Exit\n   End\ni = 0\nSay 'The Nucleus Map table follows:'\nSay ' '\nDo While @nucmentry <= nucmeot                  /* loop thru storage  */\n   i = i + 1\n   epname.i = STORAGE(D2X(@nucmentry),8)      /* get entry point name */\n   epaddr.i = C2X(STORAGE(D2X(@nucmentry+8),4))     /* get ep address */\n   epflag.i = STORAGE(D2X(@nucmentry+12),1)      /* get raw flag byte */\n   eplen.i  = C2X(STORAGE(D2X(@nucmentry+13),3))     /* get ep length */\n   @nucmentry = @nucmentry + 16                 /* bump to next entry */\nEnd\nentries = i\n/*--------------------------------------------------------------*/\n/* epflag byte structure:                                       */\n/*                                                              */\n/*           XXXX XXXX --> epflag byte                          */\n/*           |||| ||||                                          */\n/*           |||| ||++---- AMODE 00/01=24, 10=31, 11=ANY        */\n/*           |||| |+------ RMODE 0=24, 1=ANY                    */\n/*           |||| +------- RSECT 1=yes                          */\n/*           |||+--------- CSECT 1=yes                          */\n/*           +++---------- unused                               */\n/*--------------------------------------------------------------*/\nSay 'Entry --Name-- -EPaddr- CSECT RSECT RMODE AMODE Length'\nSay ' '\nDo i = 1 to entries                             /* print the list     */\n   csect = '     ' ; rsect = '     ' ; rmode = '  24 ' ; amode = '  24 '\n   If BITAND(epflag.i,'10'x)='10'x Then csect = '  Y  '\n   If BITAND(epflag.i,'08'x)='08'x Then rsect = '  Y  ' /* read only  */\n   If BITAND(epflag.i,'04'x)='04'x Then rmode = ' Any ' /* residency  */\n   If BITAND(epflag.i,'02'x)='02'x Then amode = '  31 ' /* addressing */\n   If BITAND(epflag.i,'03'x)='03'x Then amode = ' Any ' /* addressing */\n   Say ' 'Right(i,4,0) epname.i epaddr.i csect rsect rmode amode eplen.i\nEnd\nExit\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTPART": {"ttr": 4873, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x00\\x01\\x14\\x02\\x9f\\x01\\x14\\x05\\x0f\"W\\x00B\\x00C\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2014-01-29T00:00:00", "modifydate": "2014-02-19T22:57:00", "lines": 66, "newlines": 67, "modlines": 0, "user": "SCNS03"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTPART: REXX program to show ASM paging data set status.     */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*              ASMVT - ASM Vector Table                         */\n/*               PART - ASM Paging Activity Reference Table      */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                         /* binary to dec to hex */\n@cvtasmvt = STORAGE(D2X(X2D(@cvt)+704),4)     /* get CVTASMVT address */\n@asmvt    = RIGHT(C2X(@cvtasmvt),7)                   /* trim address */\n@asmpart  = STORAGE(D2X(X2D(@asmvt)+8),4)         /* get PART address */\n@part     = RIGHT(C2X(@asmpart),7)                    /* trim address */\npartsize  = STORAGE(D2X(X2D(@part)+4),4)      /* get number of PART's */\npartsize  = C2D(partsize)                            /* binary to dec */\n@partdsnl = STORAGE(D2X(X2D(@part)+24),4)     /* get dsn list address */\n@partdsnl = C2X(@partdsnl)                            /* need 32 bits */\npartlcnt  = STORAGE(D2X(X2D(@part)+32),2)     /* get number of locals */\npartlcnt  = C2D(partlcnt)                            /* binary to dec */\n@partplpa = STORAGE(D2X(X2D(@part)+48),4)      /* get plpa part entry */\n@partplpa = RIGHT(C2X(@partplpa),7)                   /* trim address */\n@partloca = STORAGE(D2X(X2D(@part)+52),4)      /* get 1st local entry */\n@partloca = RIGHT(C2X(@partloca),7)                   /* trim address */\n@partlsta = STORAGE(D2X(X2D(@part)+56),4)      /* get last locl entry */\n@partlsta = RIGHT(C2X(@partlsta),7)                   /* trim address */\n@partents  = STORAGE(D2X(X2D(@part)+80),4)      /* get 1st part entry */\n@partents = RIGHT(C2X(@partents),7)                   /* trim address */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' CVTASMVT:'@asmvt ' ASMPART:'@part'   'TIME() DATE()\nSay ' '\nSay 'The PART table starts at '@partplpa' and contains 'partsize' entries.'\nSay ' '\np = 0 ; i = 0 ; @partix = @partplpa ; @dsnl = @partdsnl\nDo p = 1 To partsize                           /* scan the PART table */\n   pareflg1 = STORAGE(D2X(X2D(@partix)+9),1)         /* get flag byte */\n   If BITAND(pareflg1,'80'x) \\= '80'x Then Do  /* process in use only */\n      i = i + 1                              /* count active pageds's */\n      pagedsn  = STORAGE(@dsnl,44)         /* pickup the dsn from csa */\n      paretype = STORAGE(D2X(X2D(@partix)+8),1)      /* get type byte */\n      ptype = '??????'\n      If BITAND(paretype,'80'x) = '80'x Then ptype = 'PLPA  '\n      If BITAND(paretype,'40'x) = '40'x Then ptype = 'Common'\n      If BITAND(paretype,'20'x) = '20'x Then ptype = 'Duplex'\n      If BITAND(paretype,'10'x) = '10'x Then ptype = 'Local '\n      pareszsl = STORAGE(D2X(X2D(@partix)+16),4) /* get size in slots */\n      pareszsl = C2D(pareszsl)\n      pareslta = STORAGE(D2X(X2D(@partix)+20),4)   /* slots available */\n      pareslta = C2D(pareslta) ; used = pareszsl - pareslta\n      pctused  = TRUNC((used*100)/pareszsl,0)\n      pctused  ='('RIGHT(pctused,3)'%)'\n      @pareucbp = STORAGE(D2X(X2D(@partix)+44),4)  /* get UCB address */\n      pioaddr  = STORAGE(D2X(C2D(@pareucbp)+4),2)  /* channel address */\n      pioaddr  = RIGHT(C2X(pioaddr),4)             /* 4-character UCB */\n      pvolser  = STORAGE(D2X(C2D(@pareucbp)+28),6)     /* dasd volser */\n      Say RIGHT(i,2) pagedsn ptype RIGHT(pareszsl,5) pctused pvolser pioaddr\n   End\n   @partix = D2X(X2D(@partix)+96)          /* bump to next PART entry */\n   @dsnl   = D2X(X2D(@dsnl)+44)             /* bump to next DSN entry */\nEnd\nSay ' '\nSay 'Paging activity table analysis completed: 'TIME()\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTPAR2": {"ttr": 4875, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x00\\x00\\x94\\x08\\x8f\\x01\\x14\\x05\\x0f\"W\\x00F\\x00B\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-02-19T22:57:00", "lines": 70, "newlines": 66, "modlines": 0, "user": "SCNS03"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTPART: REXX program to show ASM paging data set status.     */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*              ASMVT - ASM Vector Table                         */\n/*               PART - ASM Paging Activity Reference Table      */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                         /* binary to dec to hex */\n@cvtasmvt = STORAGE(D2X(X2D(@cvt)+704),4)     /* get CVTASMVT address */\n@asmvt    = RIGHT(C2X(@cvtasmvt),7)                   /* trim address */\n@asmpart  = STORAGE(D2X(X2D(@asmvt)+8),4)         /* get PART address */\n@part     = RIGHT(C2X(@asmpart),7)                    /* trim address */\npartsize  = STORAGE(D2X(X2D(@part)+4),4)      /* get number of PART's */\npartsize  = C2D(partsize)                            /* binary to dec */\nparteuse  = STORAGE(D2X(X2D(@part)+8),2)      /* get # of PARTs in use*/\nparteuse  = C2D(parteuse)                            /* binary to dec */\n@partdsnl = STORAGE(D2X(X2D(@part)+24),4)     /* get dsn list address */\n@partdsnl = C2X(@partdsnl)                            /* need 32 bits */\npartlcnt  = STORAGE(D2X(X2D(@part)+32),2)     /* get number of locals */\npartlcnt  = C2D(partlcnt)                            /* binary to dec */\n@partplpa = STORAGE(D2X(X2D(@part)+48),4)      /* get plpa part entry */\n@partplpa = RIGHT(C2X(@partplpa),7)                   /* trim address */\n@partloca = STORAGE(D2X(X2D(@part)+52),4)      /* get 1st local entry */\n@partloca = RIGHT(C2X(@partloca),7)                   /* trim address */\n@partlsta = STORAGE(D2X(X2D(@part)+56),4)      /* get last locl entry */\n@partlsta = RIGHT(C2X(@partlsta),7)                   /* trim address */\n@partents  = STORAGE(D2X(X2D(@part)+80),4)      /* get 1st part entry */\n@partents = RIGHT(C2X(@partents),7)                   /* trim address */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' CVTASMVT:'@asmvt ' ASMPART:'@part'   'TIME() DATE()\nSay ' '\nSay 'The PART table starts at '@partplpa' and contains 'partsize' entries,'parte\nSay ' '\nSay ' # Type   Full   Stat  VolSer Addr DataSet Name'\nSay ' '\np = 0 ; i = 0 ; @partix = @partplpa ; @dsnl = @partdsnl\nDo p = 1 To partsize                           /* scan the PART table */\n   pareflg1 = STORAGE(D2X(X2D(@partix)+9),1)         /* get flag byte */\n   If BITAND(pareflg1,'80'x) \\= '80'x Then Do  /* process in use only */\n      i = i + 1                              /* count active pageds's */\n      pagedsn  = STORAGE(@dsnl,44)         /* pickup the dsn from csa */\n      paretype = STORAGE(D2X(X2D(@partix)+8),1)      /* get type byte */\n      ptype = '??????'\n      If BITAND(paretype,'80'x) = '80'x Then ptype = 'PLPA  '\n      If BITAND(paretype,'40'x) = '40'x Then ptype = 'Common'\n      If BITAND(paretype,'20'x) = '20'x Then ptype = 'Duplex'\n      If BITAND(paretype,'10'x) = '10'x Then ptype = 'Local '\n      pareszsl = STORAGE(D2X(X2D(@partix)+16),4) /* get size in slots */\n      pareszsl = C2D(pareszsl)\n      pareslta = STORAGE(D2X(X2D(@partix)+20),4)   /* slots available */\n      pareslta = C2D(pareslta) ; used = pareszsl - pareslta\n      pctused  = TRUNC((used*100)/pareszsl,0)\n      pctused  ='('RIGHT(pctused,3)'%)'\n      @pareucbp = STORAGE(D2X(X2D(@partix)+44),4)  /* get UCB address */\n      pioaddr  = STORAGE(D2X(C2D(@pareucbp)+4),2)  /* channel address */\n      pioaddr  = RIGHT(C2X(pioaddr),4)             /* 4 character UCB */\n      pvolser  = STORAGE(D2X(C2D(@pareucbp)+28),6)     /* dasd volser */\n      Say RIGHT(i,2) ptype RIGHT(pareszsl,5) pctused pvolser pioaddr pagedsn\n   End\n   @partix = D2X(X2D(@partix)+96)          /* bump to next PART entry */\n   @dsnl   = D2X(X2D(@dsnl)+44)             /* bump to next DSN entry */\nEnd\nSay ' '\nSay 'Paging activity table analysis completed: 'TIME()\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTPDSD": {"ttr": 4877, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x94\\x08\\x8f\\x01\\x14\\x06?\\x011\\x009\\x008\\x00\\x00\\xc1\\xc3\\xc9\\xc5\\xd9\\xc9@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-03-04T01:31:00", "lines": 57, "newlines": 56, "modlines": 0, "user": "ACIERI"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTPDSD: REXX program to display PDS directory records.       */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                 -none-                                        */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\nparse arg dsn\nAddress TSO\n/*dsn = 'SYS1.SORTLIB'   */            /* Fake out DCB of PO */\n\"ALLOC F(PDS) DA('\"dsn\"') SHR DSORG(PS) LRECL(256) BLKSIZE(256) RECFM(F)\"\nNewstack\n'EXECIO * DISKR PDS ( FINIS'\nQueue '*EOF*'\ni = 0\nDo While i < 10\n   i = i + 1\n   Pull line\n   If LEFT(line,5) = '*EOF*' Then Leave\n   dirblock = C2X(line)\n   blocklen = X2D(C2X(SUBSTR(line,1,2)))\n   If blocklen = 0 Then Leave\n   Say 'DIRBLOCK No. 'i'  RC = 'RC,\n       ' DIRBLOCK Length = 'LENGTH(line)'  DIRDATA length = 'blocklen\n   Say ' '\n   Say 'Data: 'SUBSTR(dirblock,001,60)' *'SUBSTR(line,001,30)'*'\n   Say '      'SUBSTR(dirblock,061,60)' *'SUBSTR(line,031,30)'*'\n   Say '      'SUBSTR(dirblock,121,60)' *'SUBSTR(line,061,30)'*'\n   Say '      'SUBSTR(dirblock,181,60)' *'SUBSTR(line,091,30)'*'\n   Say '      'SUBSTR(dirblock,241,60)' *'SUBSTR(line,121,30)'*'\n   Say '      'SUBSTR(dirblock,301,60)' *'SUBSTR(line,151,30)'*'\n   Say '      'SUBSTR(dirblock,361,60)' *'SUBSTR(line,181,30)'*'\n   Say '      'SUBSTR(dirblock,421,60)' *'SUBSTR(line,211,30)'*'\n   Say '      'SUBSTR(dirblock,481,32),\n       '                          ',\n       ' *'SUBSTR(line,241,16),\n       '             *'\n   Say ' '\n   Say 'Linear block dump follows:'\n   Say ' '\n   y = 0\n   Do y = 1 to 256\n      Say '   DIRBLOCK byte 'RIGHT(y,3,0),\n          ' Char:'SUBSTR(line,y,1),\n          ' Hex:'C2X(SUBSTR(line,y,1)),\n          ' Dec:'C2D(SUBSTR(line,y,1))\n   End\n   Say ' '\nEnd\nDelstack\n\"FREE F(PDS)\"\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTPDSM": {"ttr": 4879, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x94\\x08\\x8f\\x01\\x14\\x06?\\x019\\x00~\\x00}\\x00\\x00\\xc1\\xc3\\xc9\\xc5\\xd9\\xc9@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-03-04T01:39:00", "lines": 126, "newlines": 125, "modlines": 0, "user": "ACIERI"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTPDSM: REXX program to display all PDS member information.  */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                PDS - Partitioned Data Set (entry)             */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\nparse arg dsn\nAddress TSO\n/*dsn = 'SYS2.LINKLIB'     */             /* Fake out DCB of PO */\n\"ALLOC F(PDS) DA('\"dsn\"') SHR DSORG(PS) LRECL(256) BLKSIZE(256) RECFM(F)\"\nNewstack\n'EXECIO * DISKR PDS ( FINIS'\nQueue '*EOF*'\ni = 0\nlast = 0     /* flags when the no more members indicator is detected */\nmemcount = 0\nSay 'Date: 'DATE()' PDS: 'dsn\nDo While i < 1000 & last \\= 1  /* had to pick some limit */\n   i = i + 1\n   Pull line\n   If LEFT(line,5) = '*EOF*' Then Leave\n   blocklen = X2D(C2X(SUBSTR(line,1,2)))  /* Not proud of this logic, */\n   If blocklen = 0 or last = 1 Then Leave /* but seems to work --vlc  */\n   ix = 3                          /* Initialize DIRBLOCK parse index */\n   Do While ix < blocklen & last \\= 1          /* parse this DIRBLOCK */\n      pds2ftb1 = '00'x                         /* initialize apf not  */\n      pds2mnm  = '        '                    /* initialize alias of */\n      pds2name = SUBSTR(line,ix,8)  ; ix = ix + 8     /* main section */\n      pds2ttrp = SUBSTR(line,ix,3)  ; ix = ix + 3\n      pds2indc = SUBSTR(line,ix,1)  ; ix = ix + 1\n      udl = 0                           /* calculate user data length */\n      If BITAND(pds2indc,'01'x) = '01'x Then udl = 1\n      If BITAND(pds2indc,'02'x) = '02'x Then udl = udl + 2\n      If BITAND(pds2indc,'04'x) = '04'x Then udl = udl + 4\n      If BITAND(pds2indc,'08'x) = '08'x Then udl = udl + 8\n      If BITAND(pds2indc,'10'x) = '10'x Then udl = udl + 16\n      udl = udl * 2                 /* finish calc halfwords to bytes */\n      If udl >= 22 Then Do               /* only process likely stuff */\n         ix = ix + 8             /* adjust index to skip misc 8 bytes */\n         pds2atr1 = SUBSTR(line,ix,1) ; ix = ix + 1\n         pds2atr2 = SUBSTR(line,ix,1) ; ix = ix + 1\n         pds2stor = SUBSTR(line,ix,3) ; ix = ix + 3\n         ix = ix + 2             /* adjust index to skip misc 2 bytes */\n         pds2epa  = SUBSTR(line,ix,3) ; ix = ix + 3\n         pds2ftb1 = SUBSTR(line,ix,1) ; ix = ix + 1\n         ix = ix + 2             /* adjust index to skip misc 2 bytes */\n                                                      /* scatter sect */\n         If BITAND(pds2atr1,'04'x) = '04'x Then Do\n            pds2scat = SUBSTR(line,ix+33,8)\n            ix = ix + 8\n            End\n                                                        /* alias sect */\n         If BITAND(pds2indc,'80'x) = '80'x Then Do\n            If udl >= 32 Then Do\n               pds2epm  = SUBSTR(line,ix,3) ; ix = ix + 3\n               pds2mnm  = SUBSTR(line,ix,8) ; ix = ix + 8\n               End\n            Else Do\n               Say '*** WARNING - Missing major for alias 'pds2name' DBLK:'i\n               pds2epm = '000000'x\n               pds2mnm = '????????'\n               End\n            End\n                                                       /* ssi section */\n         If BITAND(pds2ftb1,'10'x) = '10'x Then Do\n            If (ix-1)//2 \\= 0 Then ix = ix + 1    /* halfword alignmt */\n            pdsssiwd = SUBSTR(line,ix,4) ; ix = ix + 4\n            End\n                                                       /* apf section */\n         If BITAND(pds2ftb1,'08'x) \\= '08'x Then pdsapfac = ' '/* none*/\n         Else Do                                         /* maybe apf */\n            pdsapfct = SUBSTR(line,ix,1)\n            If pdsapfct = '01'x Then Do                /* NORMAL path */\n               ix = ix + 1\n               pdsapfac = SUBSTR(line,ix,1)\n               ix = ix + 1\n               If pdsapfac \\= '00'x & pdsapfac \\= '01'x Then Do\n                  Say '*** WARNING - Invalid AC for 'pds2name' DBLK:'i\n                  nop\n                  End\n               End\n            If pdsapfct \\= '01'x & (BITAND(pds2indc,'80'x)='80'x) Then Do\n               pdsapfac=' '\n               ix = ix - 8\n               Say '*** WARNING - Compacted alias logic for 'pds2name' DBLK:'i\n               End\n            End\n         End\n      Else Do                              /* too short udl, leave it */\n         ix = ix + udl\n         If pds2name = 'FFFFFFFFFFFFFFFF'x Then Do\n            last = 1\n            Leave\n            End\n         Say '*** WARNING - too short udl for 'pds2name' DBLK:'i\n         pds2atr1 = '00'x\n         pds2atr2 = '00'x\n         pds2stor = '000000'x\n         pds2mnm  = '        '\n         pdsapfac = ' '\n         End\n      If (ix-1)//2 \\= 0 Then ix = ix + 1          /* halfword alignmt */\n      If pds2name = 'FFFFFFFFFFFFFFFF'x Then Do\n         last = 1\n         Leave\n         End\n      If pds2name \\= '0000000000000000'x Then Do\n         memcount = memcount + 1\n         Say RIGHT(memcount,4,0) pds2name' TTR:'C2X(pds2ttrp),\n             ' INDC:'C2X(pds2indc)' ATRBs:'C2X(pds2atr1),\n             C2X(pds2atr2)' SIZE:'C2X(pds2stor),\n             ' MAJ:'pds2mnm' AC:'C2X(pdsapfac),\n             ' DBLK:'RIGHT(i,4,0)' UDL:'RIGHT(udl,2,0),\n             ' IX:'RIGHT(ix,3,0)\n         End\n   End                                         /* DIRBLOCK parse done */\nEnd\nDelstack\n\"FREE F(PDS)\"\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTPLPA": {"ttr": 5122, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x94\\x08\\x8f\\x01\\x14\\x05\\x0f\"W\\x00\\x9f\\x00\\x9f\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-02-19T22:57:00", "lines": 159, "newlines": 159, "modlines": 0, "user": "SCNS03"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTPLPA: REXX program to display PLPA directory table.        */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                GDA - Global Data Area                         */\n/*               LPDE - Link Pack Directory Entry                */\n/*                                                               */\n/*****************************************************************/\n/*--------------virtual storage map definition section----------------*/\nNumeric Digits 10           /* required to handle decimal conversions */\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */\n@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */\n@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */\n@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */\n@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */\n@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */\n@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */\n@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */\n@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */\n@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */\n@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */\n@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */\n@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */\n@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */\n@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */\n@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */\n@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */\n@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */\n@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */\n@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */\n@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */\n@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */\n@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */\n@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */\n@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */\n@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */\n@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */\n@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */\n@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */\n@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */\n@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */\n@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */\n@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */\n@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */\n@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */\n@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */\n@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */\n@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */\n@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */\n@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */\n@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */\n@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */\n@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */\n@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */\n@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */\n@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */\n@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */\n@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */\n        /*------simplify variable names & make addresses decimal------*/\n@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/\n   csa1 = X2D(@csa1g) ; csa2 = X2D(@csa2g)                    /* csa  */\n@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */\n   mlpa1 = X2D(@mlpa1) ; mlpa2 = X2D(@mlpa2)\n@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */\n   flpa1 = X2D(@flpa1) ; flpa2 = X2D(@flpa2)\n@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */\n   plpa1 = X2D(@plpa1) ; plpa2 = X2D(@plpa2)\n@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */\n   sqa1 = X2D(@sqa1) ; sqa2 = X2D(@sqa2)\n@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */\n   nuc1 = X2D(@nuc1) ; nuc2 = X2D(@nuc2)\n@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */\n  esqa1 = X2D(@esqa1) ; esqa2 = X2D(@esqa2)\n@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/\n eplpa1 = X2D(@eplpa1) ; eplpa2 = X2D(@eplpa2)\n@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/\n eflpa1 = X2D(@eflpa1) ; eflpa2 = X2D(@eflpa2)\n@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/\n emlpa1 = X2D(@emlpa1) ; emlpa2 = X2D(@emlpa2)\n@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/\n  ecsa1 = X2D(@ecsa1g) ; ecsa2 = X2D(@ecsa2g)\n@eprivs = X2D(@ecsa2g)+1                               /* ext private */\n@eprive = 2147483647                         /* fixed by architecture */\n epriv1 = @eprivs ; epriv2 = @eprive\n@psas   = 0 ; @psae = 4095                       /* psa fixed by arch */\n   psa1 = @psas ; psa2 = @psae\n@prive  = X2D(@csa1g)-1 ; @privs = X2D(@psae)+1            /* private */\n  priv1 = @privs ; priv2 = @prive\n              /*------------------------------------------------------*/\n             /* Usage Notes: Hex character compares are incompatible */\n            /*    for storage residency determination.  Thus, entry */\n           /*     point addresses must be converted to decimal and */\n          /*      VS boundary addresses must be converted to de-  */\n         /*       cimal for correct compare operations.          */\n        /*------------------------------------------------------*/\n/*----------end of virtual storage map definition section-------------*/\n@cvtlpdir = STORAGE(D2X(X2D(@cvt)+361),3)    /* get CVTLPDIR address  */\n@cvtlpdir = D2X(C2D(@cvtlpdir))                /* binary to hex       */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' CVTLPDIR:'@cvtlpdir'  'DATE() TIME()\n@lpdechn = @cvtlpdir\nSay ' '\ni = 0 ; eot = '00000000000000000000000000000000'\nDo While i < 10000                                 /* arbitrary limit */\n   lpde = STORAGE(@lpdechn,40)                        /* get the lpde */\n   If C2X(SUBSTR(lpde,1,16))=eot Then Leave           /* end of table */\n   i = i + 1\n   module = SUBSTR(lpde,9,8)\n   entry  = SUBSTR(lpde,17,4)\n                                        /* determine storage location */\n   addr = BITAND(entry,'7FFFFFFF'x)       /* shave off amode bit (32) */\n   addr = C2D(addr)                      /* make numeric for compares */\n   sloc = 'ERROR'                       /* determine module residency */\n   If (addr >= csa1   & addr <= csa2  ) Then sloc = 'CSA  '\n      Else If (addr >= mlpa1  & addr <= mlpa2 ) Then sloc = 'MLPA '\n      Else If (addr >= flpa1  & addr <= flpa2 ) Then sloc = 'FLPA '\n      Else If (addr >= plpa1  & addr <= plpa2 ) Then sloc = 'PLPA '\n      Else If (addr >= sqa1   & addr <= sqa2  ) Then sloc = 'SQA  '\n      Else If (addr >= nuc1   & addr <= nuc2  ) Then sloc = 'NUC  '\n      Else If (addr >= esqa1  & addr <= esqa2 ) Then sloc = 'ESQA '\n      Else If (addr >= eplpa1 & addr <= eplpa2) Then sloc = 'EPLPA'\n      Else If (addr >= eflpa1 & addr <= eflpa2) Then sloc = 'EFLPA'\n      Else If (addr >= emlpa1 & addr <= emlpa2) Then sloc = 'EMLPA'\n      Else If (addr >= ecsa1  & addr <= ecsa2 ) Then sloc = 'ECSA '\n      Else If (addr >= epriv1 & addr <= epriv2) Then sloc = 'EPRIV'\n      Else If (addr >= priv1  & addr <= priv2 ) Then sloc = 'PRIV '\n      Else If (addr >= psa1   & addr <= psa2  ) Then sloc = 'PSA  '\n   size   = C2X(SUBSTR(lpde,33,4))\n   att2   =     SUBSTR(lpde,30,1)\n   auth = 0 ; If (BITAND(att2,'01'x)='01'x) Then auth = 1\n   lpdemjp  = '         '\n   lpdemjnm = '        '\n   If C2D(SUBSTR(lpde,21,4)) \\= 0 Then\n      Do\n         lpdemjp  = ' Alias of'\n         lpdemjnm = SUBSTR(lpde,33,8)\n             size = '        '\n      End\n   Say 'PLPA'RIGHT(i,4,0) ,\n       module ,\n       C2X(entry) ,\n       sloc ,\n       'SIZE:'RIGHT(size,8,0) ,\n       'AC:'auth ,\n       lpdemjp lpdemjnm\n   @lpdechn = D2X(X2D(@lpdechn)+40)         /* address of next LPDE */\nEnd\nSay ' '\nSay 'LPDE table scan completed 'TIME()\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTSFT": {"ttr": 5126, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x00\\x00\\x00\\x94\\x08\\x8f\\x01\\x14\\x05_\\x02E\\x01u\\x00{\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-02-24T02:45:00", "lines": 373, "newlines": 123, "modlines": 0, "user": "SBGOLOB"}, "text": "/*REXX*/\n/*****************************************************************/\n/* LISTSFT: REXX program to display the PC system function table.*/\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                SFT - System Function Table                    */\n/*****************************************************************/\n/* Added entries to accommodate IEAVXSFM from z/OS 1.13  (SBG)   */\n/* See MVS Diagnosis Reference for a list of PC LX/EX Services.  */\n/* (I think many of them are not anchored in the SFT, but are    */\n/*  anchored somewhere else in the system.)                      */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtxsft  = STORAGE(D2X(X2D(@cvt)+772),4)    /* get CVTXSFT address   */\n@cvtxsft  = D2X(C2D(@cvtxsft))                 /* binary to hex       */\n/* Address TSO ; \"CLEAR\"  */\nSay 'CVT:'@cvt'  CVTXSFT:'@cvtxsft'   'DATE() TIME()\nSay ' '\nSay '    PC Number          Service Description'\nSay '    ----------------   ----------------------------------------'\n@start = @cvtxsft ; i = 0\nsftentry = STORAGE(@start,4)\nDo While sftentry \\= 'FFFFFFFF'x                       /* process SFT */\n   i = i + 1\n   linkageix = SUBSTR(sftentry,2,2) ; linkageix = C2X(linkageix)\n     entryix = SUBSTR(sftentry,4,1) ;   entryix = C2X(entryix)\n   Select\n      When sftentry = '00000000'x Then\n         service = 'Linkage Index Reserve                    (IEAVXLRE)'\n      When sftentry = '00000001'x Then\n         service = 'Linkage Index Free                       (IEAVXLFR)'\n      When sftentry = '00000002'x Then\n         service = 'Entry Table Create                       (IEAVXECR)'\n      When sftentry = '00000003'x Then\n         service = 'Entry Table Destroy                      (IEAVXEDE)'\n      When sftentry = '00000004'x Then\n         service = 'Entry Table Connect                      (IEAVXECO)'\n      When sftentry = '00000005'x Then\n         service = 'Entry Table Disconnect                   (IEAVXEDI)'\n      When sftentry = '00000006'x Then\n         service = 'Authorization Index Reserve              (IEAVXRFE)'\n      When sftentry = '00000007'x Then\n         service = 'Authorization Index Free                 (IEAVXRFE)'\n      When sftentry = '00000008'x Then\n         service = 'Authorization Index Extract              (IEAVXRFE)'\n      When sftentry = '00000009'x Then\n         service = 'Authorization Index Set                  (IEAVXSET)'\n      When sftentry = '0000000A'x Then\n         service = 'Authorization Table Set                  (IEAVXSET)'\n      When sftentry = '0000000B'x Then\n         service = 'PC/Auth Resource Manager                 (IEAVXPAM)'\n      When sftentry = '0000000C'x Then\n         service = 'For use by IBM code only                 (IEAVXREX)'\n      When sftentry = '0000000D'x Then\n         service = 'ALESERV ADD/ADDPASN services             (IEAVXALA)'\n      When sftentry = '0000000E'x Then\n         service = 'ALESERV DELETE service                   (IEAVXALD)'\n      When sftentry = '0000000F'x Then\n         service = 'ALESERV EXTRACT/EXTRACTH services        (IEAVXALE)'\n      When sftentry = '00000010'x Then\n         service = 'ALESERV SEARCH service                   (IEAVXALS)'\n      When sftentry = '00000011'x Then\n         service = 'DualPool router                          (        )'\n      When sftentry = '00000100'x Then\n         service = 'ENQ/DEQ/RESERVE                          (ISGGQWBI)'\n      When sftentry = '00000101'x Then\n         service = 'ENQ/DEQ/RESERVE Redrive                  (ISGGQWBI)'\n      When sftentry = '00000102'x Then\n         service = 'ENQ/DEQ/RESERVE Resource Term Mgr        (ISGGTRM1)'\n      When sftentry = '00000103'x Then\n         service = 'Global Resource Serialization Dump       (ISGDGCB0)'\n      When sftentry = '00000104'x Then\n         service = 'Global Resource Serialization Qscan      (ISGQSCAN)'\n      When sftentry = '00000105'x Then\n         service = 'Global Resource Serialization Stor Mgmt  (ISGSMI  )'\n      When sftentry = '00000106'x Then\n         service = 'Global Resource Serialization Qscan      (ISGQSCAN)'\n      When sftentry = '00000107'x Then\n         service = 'DEQUEUE Fast Path                        (ISGLNQDQ)'\n      When sftentry = '00000108'x Then\n         service = 'ENQUEUE Fast Path                        (ISGLNQDQ)'\n      When sftentry = '00000109'x Then\n         service = 'Global Resource Serialization ESTAE      (ISGGEST0)'\n      When sftentry = '0000010C'x Then\n         service = 'GRS Latch internal processing            (ISGLRLQE)'\n      When sftentry = '0000010D'x Then\n         service = 'GRS Latch CREATE service                 (ISGLCRTS)'\n      When sftentry = '0000010E'x Then\n         service = 'GRS Latch internal processing            (ISGLRTR )'\n      When sftentry = '0000010F'x Then\n         service = 'GRS Latch PURGE service                  (ISGLPRGS)'\n      When sftentry = '0000011A'x Then\n         service = 'ISGENQ Service                           (ISGGRT  )'\n      When sftentry = '0000011B'x Then\n         service = 'ISGQUERY Service                         (ISGQPC  )'\n      When sftentry = '0000011C'x Then\n         service = 'ISGADMIN Service                         (ISGGADMN)'\n      When sftentry = '0000011D'x Then\n         service = 'Non-cross memory ENQ svce redrives to GRS(ISGGRT  )'\n      When sftentry = '0000011E'x Then\n         service = 'Non-cross memory DEQ svce redrives to GRS(ISGGRT  )'\n      When sftentry = '00000200'x Then\n         service = 'Display Allocation Tables Manager        (IEFHB410)'\n      When sftentry = '00000201'x Then\n         service = 'DALT Dynamic Activate Config change      (IEFHB420)'\n      When sftentry = '00000202'x Then\n         service = 'Allocation Component Trace Record        (IEFCTRCD)'\n      When sftentry = '00000203'x Then\n         service = 'ATS Tape sharing Operations              (IEFHB4IG)'\n      When sftentry = '00000204'x Then\n         service = 'Allocation Dev Mgmt (offl,online,unload) (IEFHBPDF)'\n      When sftentry = '00000300'x Then\n         service = 'VSM CPOOL Build Service                  (IGVCPBDP)'\n      When sftentry = '00000301'x Then\n         service = 'VSM CPOOL Expansion Interface            (IGVCPEXP)'\n      When sftentry = '00000302'x Then\n         service = 'VSM CPOOL Delete Service                 (IGVCPDLP)'\n      When sftentry = '00000303'x Then\n         service = 'VSMLIST Service                          (IGVLISTP)'\n      When sftentry = '00000304'x Then\n         service = 'VSMLOC Service                           (IGVLOCP )'\n      When sftentry = '00000305'x Then\n         service = 'CPUTIMER Service                         (IEAVRT04)'\n      When sftentry = '00000306'x Then\n         service = 'Virtual Fetch CSVVFORK Service           (CSVVFORK)'\n      When sftentry = '00000307'x Then\n         service = 'Data in Virtural                         (ITVCCTL )'\n      When sftentry = '00000308'x Then\n         service = 'Symptom Records                          (ASRSERVP)'\n      When sftentry = '00000309'x Then\n         service = 'LSEXPAND Service                         (IEAVLSEX)'\n      When sftentry = '0000030A'x Then\n         service = 'LOCASCB STOKEN= Service                  (IEAVESTA)'\n      When sftentry = '0000030B'x Then\n         service = 'Storage obtain                           (IGVVSTOR)'\n      When sftentry = '0000030C'x Then\n         service = 'RTM dynamic storage manager              (IEAVTR2C)'\n      When sftentry = '0000030D'x Then\n         service = 'WAIT LINKAGE=SYSTEM service              (IEAVEWTP)'\n      When sftentry = '0000030E'x Then\n         service = 'POST LINKAGE=SYSTEM service              (IEAVEPTP)'\n      When sftentry = '0000030F'x Then\n         service = 'PC-ESTAE service                         (IEAVESTI)'\n      When sftentry = '00000310'x Then\n         service = 'ASCRE/ASDES/ASEXT services               (ASEMAIN )'\n      When sftentry = '00000311'x Then\n         service = 'Storage release                          (IGVVSTOR)'\n      When sftentry = '00000312'x Then\n         service = 'TCBTOKEN service                         (IEAVTTKN)'\n      When sftentry = '00000313'x Then\n         service = 'TESTART service                          (IEAVXTAR)'\n      When sftentry = '00000314'x Then\n         service = 'CSVQUERY service                         (CSVQYSRV)'\n      When sftentry = '00000315'x Then\n         service = 'For use by IBM code only                 (ITVCF   )'\n      When sftentry = '00000316'x Then\n         service = 'TIMEUSED service                         (IEATTUSD)'\n      When sftentry = '00000317'x Then\n         service = 'SRB SUSPEND with token                   (IEAVSRBS)'\n      When sftentry = '00000318'x Then\n         service = 'SRB RESUME with token                    (IEAVSRBR)'\n      When sftentry = '00000319'x Then\n         service = 'SRB PURGE with token                     (IEAVSRBP)'\n      When sftentry = '0000031A'x Then\n         service = 'LLACOPY service                          (CSVLLCPY)'\n      When sftentry = '0000031B'x Then\n         service = 'RCFSTAT service                          (IEEUSTAT)'\n      When sftentry = '0000031C'x Then\n         service = 'RCFCONF service                          (IEEULCFG)'\n      When sftentry = '0000031D'x Then\n         service = 'AFFINITY service                         (IEAVEAFN)'\n      When sftentry = '0000031E'x Then\n         service = 'SDOM connect service                     (COFMCONN)'\n      When sftentry = '0000031F'x Then\n         service = 'SDOM disconnect service                  (COFMDISC)'\n      When sftentry = '00000320'x Then\n         service = 'CTRACEWR - Write service                 (ITTTWRIT)'\n      When sftentry = '00000321'x Then\n         service = 'PC TIME service                          (IEATTIME)'\n      When sftentry = '00000322'x Then\n         service = 'UCB Service Authorized                   (IOSVUPCR)'\n      When sftentry = '00000323'x Then\n         service = 'UCB Service Unauthorized                 (IOSVUPCR)'\n      When sftentry = '00000324'x Then\n         service = 'Configuration Change Manager             (IOSVCCMI)'\n      When sftentry = '00000325'x Then\n         service = 'Unit Verification Services               (IEFEISO1)'\n      When sftentry = '00000326'x Then\n         service = 'Name token services                      (IEANTCRS)'\n      When sftentry = '00000327'x Then\n         service = 'Name token services                      (IEANTDLS)'\n      When sftentry = '00000328'x Then\n         service = 'CONVTOD service                          (IEATCNVT)'\n      When sftentry = '00000329'x Then\n         service = 'Dynamic APF service                      (CSVQUERY)'\n      When sftentry = '0000032A'x Then\n         service = 'APPC service routine                     (ATBMIPTE)'\n      When sftentry = '0000032B'x Then\n         service = 'Dynamic Exit Support                     (CSVEXPR )'\n      When sftentry = '0000032C'x Then\n         service = 'CSRL16T service                          (CSRL16JP)'\n      When sftentry = '0000032D'x Then\n         service = 'SCHEDIRB service                         (IEAVEIRB)'\n      When sftentry = '0000032E'x Then\n         service = 'IOS Support                              (IOSVCOPR)'\n      When sftentry = '0000032F'x Then\n         service = 'HCD System/390 microprocessr cluster sup (CBDMSHSD)'\n      When sftentry = '00000330'x Then\n         service = 'TESTART CADS ALET Service                (IEAVXTRI)'\n      When sftentry = '00000331'x Then\n         service = 'SCHEDSRB                                 (IEAVSCHD)'\n      When sftentry = '00000333'x Then\n         service = 'HCD Sysplex Services (HSS) interface rtn (CBDMSHSS)'\n      When sftentry = '00000334'x Then\n         service = 'Captured UCB Services                    (IOSVCAPU)'\n      When sftentry = '00000335'x Then\n         service = 'Allocation DD Service                    (IEFDIS01)'\n      When sftentry = '00000336'x Then\n         service = 'ETR Information                          (IEATETRI)'\n      When sftentry = '00000337'x Then\n         service = 'LOGGER Router                            (IXGL2RTE)'\n      When sftentry = '00000338'x Then\n         service = 'RTM Linkage Stack Query                  (IEAVTLSQ)'\n      When sftentry = '00000339'x Then\n         service = 'LOGGER Router                            (IXGL2RTI)'\n      When sftentry = '0000033A'x Then\n         service = 'IOS Support                              (IOSVCDRP)'\n      When sftentry = '0000033B'x Then\n         service = 'Dynamic Linklist                         (CSVDLPR )'\n      When sftentry = '0000033C'x Then\n         service = 'Authorized Command Exit Manager          (IEAVEAEM)'\n      When sftentry = '0000033D'x Then\n         service = 'Logical Parmlib Service                  (IEFPIS01)'\n      When sftentry = '0000033E'x Then\n         service = 'Context Services Router                  (CTXROUTE)'\n      When sftentry = '0000033F'x Then\n         service = 'Product Enable/Disable                   (IFAEDPCT)'\n      When sftentry = '00000340'x Then\n         service = 'Dynamic LPA                              (CSVLPPR )'\n      When sftentry = '00000342'x Then\n         service = 'Enhanced PURGEDQ                         (IEAVPDQX)'\n      When sftentry = '00000343'x Then\n         service = 'IEAMQRY                                  (IEAVQRY )'\n      When sftentry = '00000344'x Then\n         service = 'Context Services Router                  (CTXROUTE)'\n      When sftentry = '00000345'x Then\n         service = 'IEAFP                                    (IEAVEFPR)'\n      When sftentry = '00000346'x Then\n         service = 'IEARR Service                            (IEAVSTA1)'\n      When sftentry = '00000347'x Then\n         service = 'IEARR Service                            (IEAVSTA1)'\n      When sftentry = '00000348'x Then\n         service = 'CSRSI Service                            (CSRSIPR )'\n      When sftentry = '00000349'x Then\n         service = 'RRS Set Environment                      (ATRUMSEN)'\n      When sftentry = '0000034A'x Then\n         service = 'RRS Retrieve Environment                 (ATRUMREN)'\n      When sftentry = '0000034B'x Then\n         service = 'Client License Services                  (ILMPRPCT)'\n      When sftentry = '0000034C'x Then\n         service = 'LE Services                              (CELSPCTK)'\n      When sftentry = '0000034D'x Then\n         service = 'LE Services                              (CELSPCTK)'\n      When sftentry = '0000034E'x Then\n         service = 'Create Name/Token Pair                   (IEAN4CRS)'\n      When sftentry = '0000034F'x Then\n         service = 'Delete Name/Token Pair                   (IEAN4DLS)'\n      When sftentry = '00000350'x Then\n         service = 'IPCS Storage Access                      (BLS1ACTV)'\n      When sftentry = '00000351'x Then\n         service = 'ILMQUERY                                 (ILMPQRY )'\n      When sftentry = '00000352'x Then\n         service = 'RRS Router                               (ATRBMIPC)'\n      When sftentry = '00000353'x Then\n         service = 'Unicode Services                         (CUNMZPC )'\n      When sftentry = '00000354'x Then\n         service = 'Supervisor Internal Processing           (IEAVIFAP)'\n      When sftentry = '00000355'x Then\n         service = 'VSAM Record Management                   (IDA0DBUG)'\n      When sftentry = '00000356'x Then\n         service = 'CTRACE                                   (ITTTWRTX)'\n      When sftentry = '00000357'x Then\n         service = 'IEAARR Service                           (IEAVTR4A)'\n      When sftentry = '00000358'x Then\n         service = 'EAV DEVMAN Service Routine               (DMODA002)'\n      When sftentry = '00000359'x Then\n         service = 'IEAARR Service                           (IEAVTR4A)'\n      When sftentry = '0000035A'x Then\n         service = 'CSV internal processing                  (CSVGETRP)'\n      When sftentry = '0000035B'x Then\n         service = 'Autoconfiguration Service Routine        (IOSVDACI)'\n      When sftentry = '0000035C'x Then\n         service = 'HISUSER Service Routine                  (HISNUSER)'\n      When sftentry = '0000035D'x Then\n         service = 'IEATXDC Service Routine                  (IEAVETX0)'\n      When sftentry = '0000035E'x Then\n         service = 'JCL Symbol Retrieve service routine      (IEFSJSR1)'\n      When sftentry = '00000400'x Then\n         service = 'WTO Service                              (IEAVH600)'\n      When sftentry = '00000500'x Then\n         service = 'System Trace Control Block Verification  (IEAVETCV)'\n      When sftentry = '00000501'x Then\n         service = 'System Trace Environment Alteration      (IEAVETEA)'\n      When sftentry = '00000502'x Then\n         service = 'System Trace Processor Alteration        (IEAVETPA)'\n      When sftentry = '00000503'x Then\n         service = 'System Trace Processor Snapshot          (IEAVETPS)'\n      When sftentry = '00000504'x Then\n         service = 'System Trace Processor Verification      (IEAVETPV)'\n      When sftentry = '00000505'x Then\n         service = 'System Trace Table Snapshot Data Extract (IEAVETSD)'\n      When sftentry = '00000506'x Then\n         service = 'System Trace Table Snapshot              (IEAVETSN)'\n      When sftentry = '00000507'x Then\n         service = 'System Trace Suspend, Resume, PSTART     (IEAVETSP)'\n      When sftentry = '00000508'x Then\n         service = 'System Trace Table Snapshot Filter       (IEAVETTF)'\n      When sftentry = '00000600'x Then\n         service = 'Virtual Fetch CSVVFSCH Service           (CSVVFSCH)'\n      When sftentry = '00000700'x Then\n         service = 'SMF Buffering Routine                    (IFAPCWTR)'\n      When sftentry = '00000800'x Then\n         service = 'Lnklst Lookaside (LLA)                   (CSVLLS01)'\n      When sftentry = '00000900'x Then\n         service = 'Data Space PC Service                    (RSM     )'\n      When sftentry = '00000A00'x Then\n         service = 'Virtual Lookaside Facility               (VLF     )'\n      When sftentry = '00000B00'x Then\n         service = 'XCF                                      (XCF     )'\n      When sftentry = '00000C00'x Then\n         service = 'Reserved for DFP use                     (DFP     )'\n      When sftentry = '00000D00'x Then\n         service = 'MVS/APPC Scheduler                       (APPC    )'\n      When sftentry = '00000E00'x Then\n         service = 'LLACOPY Service                          (ContSupr)'\n      When sftentry = '00000F00'x Then\n         service = 'SDOM services                            (SDOM    )'\n      When sftentry = '00001000'x Then\n         service = 'MVS Message Service                      (MVSMsgSr)'\n      When sftentry = '00001100'x Then\n         service = 'MVS/APPC scheduler                       (APPC    )'\n      When sftentry = '00001300'x Then\n         service = 'z/OS UNIX System Services space sw serv  (BXPJCSS )'\n      When sftentry = '00001301'x Then\n         service = 'z/OS UNIX System Services nonsp-sw serv  (BXPJCPC )'\n      When sftentry = '00001302'x Then\n         service = 'z/OS UNIX System Services authsp-sw serv (BXPJCPC )'\n      When sftentry = '00001303'x Then\n         service = 'z/OS UNIX System Services space sw callbl(BXPJCSS )'\n      When sftentry = '00001400'x Then\n         service = 'Reserved                                 (        )'\n      When sftentry = '00001504'x Then\n         service = 'System Logger                            (Logger  )'\n      When sftentry = '00001600'x Then\n         service = 'BOSS                                     (BOSS    )'\n      When sftentry = '00001700'x Then\n         service = 'IOS Space Switching Service              (IOSVIOSW)'\n      When sftentry = '00001800'x Then\n         service = 'BCPii services                           (        )'\n      When sftentry = '00001900'x Then\n         service = 'HIS Services                             (HISSSERV)'\n      Otherwise\n         service = '*** Unknown Program Call Function ***'\n      End\n   Say RIGHT(i,3,' ')'  LX: 'linkageix'  EX: 'entryix'   'service\n   sftentry = STORAGE(D2X(X2D(@start)+(i*4)),4) /* bump to next entry */\nEnd\nSay ' '\nSay 'System Function Table scan completed 'TIME()\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTSMAP": {"ttr": 5133, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x01\\x130\\x9f\\x01\\x14\\x06?\\x13H\\x00\\xa8\\x00\\x8f\\x00\\x00\\xc1\\xc3\\xc9\\xc5\\xd9\\xc9@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2013-11-05T00:00:00", "modifydate": "2014-03-04T13:48:00", "lines": 168, "newlines": 143, "modlines": 0, "user": "ACIERI"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTSMAP: REXX program to display key virtual storage points.  */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                GDA - Global Data Area                         */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\nnumeric digits 30\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtmz00  = STORAGE(D2X(X2D(@cvt)+164),4)    /* get CVTMZ00 bitstring */\n@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */\n@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */\n@cvteorm  = STORAGE(D2X(X2D(@cvt)+312),4)    /* get CVTEORM address   */\n@cvteorm  = D2X(C2D(@cvteorm))                 /* binary to hex       */\n@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */\n@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */\n@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */\n@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */\n@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */\n@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */\n@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */\n@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */\n@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */\n@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */\n@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */\n@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */\n@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */\n@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */\n@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */\n@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */\n@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */\n@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */\n@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */\n@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */\n@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */\n@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */\n@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */\n@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */\n@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */\n@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */\n@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */\n@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */\n@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */\n@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */\n@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */\n@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */\n@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */\n@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */\n@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */\n@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */\n@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */\n@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */\n@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */\n@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */\n@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */\n@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */\n@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */\n@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */\n@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */\n@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */\nSay 'The CVT  is located at '@cvt '('X2D(@cvt)')'\nSay 'The CVTMZ00  field contains 'C2X(@cvtmz00) /*'('X2D(@cvtmz00)')'*/\nSay 'The CVTSEORM field contains '@cvteorm '('X2D(@cvteorm)')'\nSay 'The CVTREAL  field contains   '@cvtreal     '('X2D(@cvtreal)')'\nSay 'The CVTSHRVM field contains  '@cvtshrvm  '('X2D(@cvtshrvm)')'\nSay 'The CVTGDA   field contains  '@cvtgda    '('X2D(@cvtgda)')'\nSay 'The GDACSA   field contains  '@gdacsa    '('X2D(@gdacsa)')'\nSay 'The GDACSASZ field contains  '@gdacsasz  '('X2D(@gdacsasz)')'\nSay 'The GDAECSA  field contains  '@gdaecsa   '('X2D(@gdaecsa)')'\nSay 'The GDAECSAS field contains  '@gdaecsas  '('X2D(@gdaecsas)')'\nSay 'The CVTMLPAS field contains  '@cvtmlpas  '('X2D(@cvtmlpas)')'\nSay 'The CVTMLPAE field contains  '@cvtmlpae  '('X2D(@cvtmlpae)')'\nSay 'The CVTFLPAS field contains  '@cvtflpas  '('X2D(@cvtflpas)')'\nSay 'The CVTFLPAE field contains  '@cvtflpae  '('X2D(@cvtflpae)')'\nSay 'The CVTPLPAS field contains  '@cvtplpas  '('X2D(@cvtplpas)')'\nSay 'The CVTPLPAE field contains  '@cvtplpae  '('X2D(@cvtplpae)')'\nSay 'The CVTRWNS  field contains  '@cvtrwns   '('X2D(@cvtrwns)')'\nSay 'The CVTRWNE  field contains  '@cvtrwne   '('X2D(@cvtrwne)')'\nSay 'The CVTRONS  field contains  '@cvtrons   '('X2D(@cvtrons)')'\nSay 'The CVTRONE  field contains '@cvtrone   '('X2D(@cvtrone)')'\nSay 'The CVTERWNS field contains '@cvterwns  '('X2D(@cvterwns)')'\nSay 'The CVTERWNE field contains '@cvterwne  '('X2D(@cvterwne)')'\nSay 'The CVTEPLPS field contains '@cvteplps  '('X2D(@cvteplps)')'\nSay 'The CVTEPLPE field contains '@cvteplpe  '('X2D(@cvteplpe)')'\nSay 'The CVTEFLPS field contains '@cvteflps  '('X2D(@cvteflps)')'\nSay 'The CVTEFLPE field contains '@cvteflpe  '('X2D(@cvteflpe)')'\nSay 'The CVTEMLPS field contains '@cvtemlps  '('X2D(@cvtemlps)')'\nSay 'The CVTEMLPE field contains '@cvtemlpe  '('X2D(@cvtemlpe)')'\nSay ' '\nSay ' '\nSay ' '\n/*  simplify variable names & calculate some boundaries   */\n@csa1   = @cvtshrvm  ;\n/*sa1   = @cvtshrvm  ; @csa2  = D2X(X2D(@cvtmlpas)-1)         @@ csa  */\n@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/\n@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */\n@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */\n@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */\n@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */\n@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */\n@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */\n@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/\n@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/\n@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/\n@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/\n/*csas    = (X2D(@csa2)-X2D(@csa1)+1)/1024     @@ size of csa   KB    */\ncsasg   =  X2D(@gdacsasz)/1024               /* size of csag  KB    */\nmlpas   = (X2D(@mlpa2)-X2D(@mlpa1)+1)/1024   /* size of mlpa  KB    */\nflpas   = (X2D(@flpa2)-X2D(@flpa1)+1)/1024   /* size of flpa  KB    */\nplpas   = (X2D(@plpa2)-X2D(@plpa1)+1)/1024   /* size of plpa  KB    */\nsqas    = (X2D(@sqa2)-X2D(@sqa1)+1)/1024     /* size of sqa   KB    */\nnucs    = (X2D(@nuc2)-X2D(@nuc1)+1)/1024     /* size of nuc   KB    */\nesqas   = (X2D(@esqa2)-X2D(@esqa1)+1)/1024   /* size of esqa  KB    */\neplpas  = (X2D(@eplpa2)-X2D(@eplpa1)+1)/1024 /* size of eplpa KB    */\neflpas  = (X2D(@eflpa2)-X2D(@eflpa1)+1)/1024 /* size of eflpa KB    */\nemlpas  = (X2D(@emlpa2)-X2D(@emlpa1)+1)/1024 /* size of emlpa KB    */\necsasg  =  X2D(@gdaecsas)/1024               /* size of ecsag KB    */\nSay 'Key storage addresses for system routine residency analysis:'\nSay ' '\nSay 'STORAGE AREA NAME               SIZE(K)      ADDRESS RANGE'\nSay ' '\nm01='Common Service Area (CSA)       '\nm01=m01||RIGHT(csas,5)  '     'RIGHT(@csa1,8,0)'-'RIGHT(@csa2,8,0)\nsay m01\nm02='Common Service Area (CSA/GDA)   '\nm02=m02||RIGHT(csasg,5)  '     'RIGHT(@csa1g,8,0)'-'RIGHT(@csa2g,8,0)\nsay m02\nm03='Modified Link Pack Area (MLPA)  '\nm03=m03||RIGHT(mlpas,5) '     'RIGHT(@mlpa1,8,0)'-'RIGHT(@mlpa2,8,0)\nsay m03\nm04='Fixed Link Pack Area (FLPA)     '\nm04=m04||RIGHT(flpas,5) '     'RIGHT(@flpa1,8,0)'-'RIGHT(@flpa2,8,0)\nsay m04\nm05='Pageable Link Pack Area (PLPA)  '\nm05=m05||RIGHT(plpas,5) '     'RIGHT(@plpa1,8,0)'-'RIGHT(@flpa2,8,0)\nsay m05\nm06='System Queue Area (SQA)         '\nm06=m06||RIGHT(sqas,5)  '     'RIGHT(@sqa1,8,0)'-'RIGHT(@sqa2,8,0)\nsay m06\nm07='MVS Nucleus (NUC)               '\nm07=m07||RIGHT(nucs,5)  '     'RIGHT(@nuc1,8,0)'-'RIGHT(@nuc2,8,0)\nsay m07\nm08='Extended SQA                    '\nm08=m08||RIGHT(esqas,5) '     'RIGHT(@esqa1,8,0)'-'RIGHT(@esqa2,8,0)\nsay m08\nm09='Extended PLPA                   '\nm09=m09||RIGHT(eplpas,5) '     'RIGHT(@eplpa1,8,0)'-'RIGHT(@eplpa2,8,0)\nsay m09\nm10='Extended FLPA                   '\nm10=m10||RIGHT(eflpas,5) '     'RIGHT(@eflpa1,8,0)'-'RIGHT(@eflpa2,8,0)\nsay m10\nm11='Extended MLPA                   '\nm11=m11||Right(emlpas,5) '     'RIGHT(@emlpa1,8,0)'-'RIGHT(@emlpa2,8,0)\nsay m11\nm12='Extended CSA/GDA                '\nm12=m12||RIGHT(ecsasg,5) '     'RIGHT(@ecsa1g,8,0)'-'RIGHT(@ecsa2g,8,0)\nsay m12\nExit\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTSMF": {"ttr": 5380, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x130_\\x01\\x14\\x06?\\x02\"\\x00\\x8f\\x00\\x8f\\x00\\x00\\xc1\\xc3\\xc9\\xc5\\xd9\\xc9@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2013-11-01T00:00:00", "modifydate": "2014-03-04T02:22:00", "lines": 143, "newlines": 143, "modlines": 0, "user": "ACIERI"}, "text": "/*REXX*/\n/*****************************************************************/\n/* LISTSMF: REXX program to show SMF information.                */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*               SMCA - SMF Control Area                         */\n/*                RDS - SMF Recording Data Set                   */\n/*               SSTP - SMF Selectivity Table                    */\n/*                                                               */\n/* AJC 12/01/05  Fix problem with length of Selectivity Table.   */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                         /* binary to dec to hex */\n@cvtsmca  = STORAGE(D2X(X2D(@cvt)+196),4)      /* get CVTSMCA address */\n@smca     = C2X(@cvtsmca) ; @cvtsmca = RIGHT(@smca,7)    /* trim addr */\nsmcasid   = STORAGE(D2X(X2D(@cvtsmca)+016),4)  /* get system id field */\nsmcadsct  = STORAGE(D2X(X2D(@cvtsmca)+116),4)       /* get # rec lost */\nsmcadsct = C2D(smcadsct)                             /* binary to dec */\nsmcasjwt  = STORAGE(D2X(X2D(@cvtsmca)+144),4)       /* get system jwt */\nsmcaprmt  = STORAGE(D2X(X2D(@cvtsmca)+208),1) /* get smf prompt flags */\n@smcafrds = STORAGE(D2X(X2D(@cvtsmca)+244),4)  /* get 1st RDA address */\n@smcafrds = C2X(@smcafrds)                           /* binary to hex */\n@smcalrds = STORAGE(D2X(X2D(@cvtsmca)+248),4) /* get last RDA address */\n@smcalrds = C2X(@smcalrds)                           /* binary to hex */\n@smcasstp = STORAGE(D2X(X2D(@cvtsmca)+328),4)     /* get SSTP address */\n@smcasstp = C2X(@smcasstp)                           /* binary to hex */\nsmcaitme  = STORAGE(D2X(X2D(@cvtsmca)+336),4)         /* get IPL time */\nipltime = C2D(smcaitme) ; iplhh = ipltime%360000         /* get hours */\niplmm = ipltime//360000 ; iplmm = iplmm%6000           /* get minutes */\niplt = RIGHT(iplhh,2,0)':'RIGHT(iplmm,2,0)            /* format HH:MM */\nsmcaidte  = STORAGE(D2X(X2D(@cvtsmca)+340),4)         /* get IPL date */\nsmcansst = STORAGE(D2X(X2D(@cvtsmca)+348),2)              /* get NSST */\nsmcansst = C2D(smcansst)                             /* binary to dec */\nsmcalsst = STORAGE(D2X(X2D(@cvtsmca)+350),2)              /* get LSST */\nsmcalsst = C2D(smcalsst)                             /* binary to dec */\ni = 0 ; endofrds = 0 ; j = 0 ; k = 0\nprompt = 'NOPROMPT' ; @rds = @smcafrds ; @sstp = @smcasstp\nIf BITAND(smcaprmt,'80'x) = '80'x Then prompt = 'PROMPT(IPLR)'\nIf BITAND(smcaprmt,'40'x) = '40'x Then prompt = 'PROMPT(LIST)'\nipld = C2X(smcaidte) ; ipld = SUBSTR(ipld,3,5)\nipldays = SUBSTR(ipld,3,3) ; days = DATE(D) - ipldays\nIf days < 0 Then days = days + 365     /* crossed into new year */\nIf days = 0 Then iplday = '(Today)'\nIf days = 1 Then iplday = '(Yesterday)'\nIf days > 1 Then iplday = '('days' days ago)'\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' SMCA:'@smca 'RDS:'@rds'   'TIME() DATE()\nSay ' '\nSay 'SMFID:'smcasid'  JWT:'smcasjwt'  'prompt'  IPL:'ipld' 'iplday' at 'iplt\nSay ' '\nDo While endofrds = 0 & i < 37         /* Trace the RDS chain */\n   i = i + 1                                  /* count all RDSs found */\n   @rdsnext= STORAGE(D2X(X2D(@rds)+4),4)          /* next RDS address */\n   @rdsnext=C2X(@rdsnext)                               /* bin to hex */\n   rdsflg1 = STORAGE(D2X(X2D(@rds)+12),1)              /* get RDSFLG1 */\n   dump = '' ; active = '      '\n   If BITAND(rdsflg1,'08'x) = '08'x Then dump = 'Dump Requested'\n   If BITAND(rdsflg1,'04'x) \\= '04'x Then active = 'Active'\n   rdsname = STORAGE(D2X(X2D(@rds)+16),27)       /* AJCget RDS DSName */\n   rdsvol  = STORAGE(D2X(X2D(@rds)+60),6)        /* ajcget RDS volser */\n   rdscapty= STORAGE(D2X(X2D(@rds)+76),4)   /* get RDS size in blocks */\n   rdsnxtbk= STORAGE(D2X(X2D(@rds)+80),4)       /* get RDS next block */\n   capty = C2D(rdscapty) ; nxtbk = C2D(rdsnxtbk) ; used = nxtbk - 1\n   pctused=TRUNC((used*100)/capty,1) ; pctused=RIGHT(pctused,5)'%'\n   Say RIGHT(i,2,' ') rdsname rdsvol RIGHT(capty,6),\n       RIGHT(used,6)' ('pctused') 'dump active\n   @rds = @rdsnext ; If @rds = @smcalrds Then endofrds = 1\nEnd\nIf smcadsct \u00ac= '0' Then\n   do\n     Say ' '\n     Say 'Number of SMF records lost = 'smcadsct\n   end\nSay ' '\nSay 'SMF selectivity tables defined: 'smcansst'    SST length: 'smcalsst\nSay ' '\nbit0='80'x ; bit1='40'x ; bit2='20'x ; bit3='10'x\nbit4='08'x ; bit5='04'x ; bit6='02'x ; bit7='01'x\nDo kk = 1 To smcansst\n   sst    = STORAGE(@sstp,smcalsst)                  /* get sst block */\n   sstn   = SUBSTR(sst,1,4)                      /* get subsysname id */\n   If sstn = '00000000'x Then sstn = 'Null'\n   rectbl = SUBSTR(sst,17,32)           /* get record type bit string */\n   rectypes = ''\n   Do i = 0 to 31\n      byte = SUBSTR(rectbl,i+1,1)\n      k = i * 8\n      If BITAND(byte,bit0)=bit0 Then rectypes = rectypes k\n      If BITAND(byte,bit1)=bit1 Then rectypes = rectypes k+1\n      If BITAND(byte,bit2)=bit2 Then rectypes = rectypes k+2\n      If BITAND(byte,bit3)=bit3 Then rectypes = rectypes k+3\n      If BITAND(byte,bit4)=bit4 Then rectypes = rectypes k+4\n      If BITAND(byte,bit5)=bit5 Then rectypes = rectypes k+5\n      If BITAND(byte,bit6)=bit6 Then rectypes = rectypes k+6\n      If BITAND(byte,bit7)=bit7 Then rectypes = rectypes k+7\n   End\n   i = 0 ; k = 0 ; f = '' ; j = 0 ; jj = 0\n   Do While rectypes \\= ''\n      i = i + 1\n      PARSE VAR rectypes type.i rectypes\n   End\n   If i > 2 Then\n         Do k = 1 to i-2\n            j = k + 1 ; jj = k + 2\n            If type.k = type.j - 1 & type.j = type.jj -1 Then f.k = '*'\n                                                         Else f.k = ' '\n         End\n   rectypes = 'TYPE('\n   Do k = 1 to i\n      If f.k \\= '*' Then Do\n                            rectypes = rectypes''type.k\n                            If k \\= i Then rectypes = rectypes','\n                                      Else rectypes = rectypes')'\n                         End\n                    Else Do\n                           rectypes = rectypes''type.k':'\n                           Do While f.k = '*' ; k=k+1 ; End\n                         End\n   End\n   If RIGHT(rectypes,1) = ':' Then  /* compensate for single type */\n      Do\n         rectypes = LEFT(rectypes,LENGTH(rectypes)-1)')'\n         nop\n      End\n   line2 = ''\n   If LENGTH(rectypes) >70 Then\n      Do\n         Do i = 70 to 1 By -1\n            If SUBSTR(rectypes,i,1) = ',' Then Leave\n         End\n         line2 = SUBSTR(rectypes,i+1,smcalsst)\n         rectypes = LEFT(rectypes,i)\n      End\n   If sstn = 'Null' Then rectypes = ''\n   Say RIGHT(kk,2,' ') sstn rectypes\n   If line2 \\= '' Then Say '             'line2\n   @sstp  = D2X(X2D(@sstp)+smcalsst)              /* bump to next sst */\nEnd\nSay ' '\nSay 'SMF analysis completed: 'TIME()\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTSSN": {"ttr": 5384, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x94\\x08\\x8f\\x01\\x14\\x06?\\x02%\\x00B\\x00B\\x00\\x00\\xc1\\xc3\\xc9\\xc5\\xd9\\xc9@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-03-04T02:25:00", "lines": 66, "newlines": 66, "modlines": 0, "user": "ACIERI"}, "text": "/*REXX*/\n/*****************************************************************/\n/* LISTSSN: REXX program to show all MVS subsystems.             */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*              JESCT - JES Communications Table                 */\n/*              SSCVT - Subsystem Communications Vector Table    */\n/*               SSVT - Subsystem vector Table                   */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                         /* binary to dec to hex */\n@cvtjesct = STORAGE(D2X(X2D(@cvt)+296),4)     /* get CVTJESCT address */\n@cvtjesct = D2X(C2D(@cvtjesct))               /* binary to dec to hex */\n@jesct    = STORAGE(D2X(X2D(@cvtjesct)+24),4)    /* get JESCT address */\n@jesct    = D2X(C2D(@jesct))                  /* binary to dec to hex */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' JESCT:'@jesct' SSCVT chain trace started: 'TIME() DATE()\nSay ' '\ni = 0 ; endofchn = 0 ; j = 0 ; @ssct = @jesct ; e = 0\nina = 0 ; inacsnam = '' ; inaline1 = ''\nSay '    Snam Fnum  Sysevents Monitored'\nSay '    ---- ----  -----------------------------------------------------------'\nDo While endofchn = 0 & i < 50\n   i = i + 1                                 /* count all SSCTs found */\n   @scta   = STORAGE(D2X(X2D(@ssct)+4),4)    /* get next SSCT address */\n   @scta   = D2X(C2D(@scta))                     /* bin to dec to hex */\n   snam    = STORAGE(D2X(X2D(@ssct)+8),4)     /* get subsystem's name */\n   @ssvt   = STORAGE(D2X(X2D(@ssct)+16),4)        /* get SSVT address */\n   @ssvt   = D2X(C2D(@ssvt))                     /* bin to dec to hex */\n   If @ssvt = 0 Then Do           /* make note of inactive subsystems */\n      ina = ina + 1\n      inacsnam = inacsnam snam           /* build primary output line */\n      If LENGTH(inacsnam) >= 70 Then Do   /* logic for 2 output lines */\n         inaline1 = inacsnam\n         inacsnam = ''\n         End\n      End\n   If @ssvt \\= 0 Then Do             /* detail only active subsystems */\n      j = j + 1                                  /* count active ones */\n      sysevents = ''                    /* SYSEVENTS output code line */\n      fnum = STORAGE(D2X(X2D(@ssvt)+2),2)      /* number of functions */\n      fnum = C2D(fnum)\n      fmat = STORAGE(D2X(X2D(@ssvt)+4),256)   /* function code matrix */\n      Do e = 1 to 256          /* scan fmat, load sysevents code line */\n         If C2D(SUBSTR(fmat,e,1)) \\= 0 Then sysevents = sysevents e\n      End\n      Say RIGHT(j,3,' ') snam'  'RIGHT(fnum,2,0)'  'sysevents\n      End\n   @ssct = @scta\n   If @ssct = 0 Then endofchn = 1    /* zero address ends chain */\nEnd\nIf ina > 0 Then Do\n   Say ' '\n   Say RIGHT(ina,3,' ') 'Subsystems defined, no SSVT built:'\n   If LENGTH(inaline1) \\= 0 Then Do\n      Say '     'inaline1\n      If LENGTH(inacsnam) \\= 0 Then Say '     'inacsnam\n      End\n      Else Say '     'inacsnam\n   End\nSay '---'\nSay RIGHT(i,3,' ')' SSCVT blocks scanned.  Completed: 'TIME()\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTSVCJ": {"ttr": 5386, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x94\\x08\\x8f\\x01\\x14\\x06?\\x02(\\x00/\\x00/\\x00\\x00\\xc1\\xc3\\xc9\\xc5\\xd9\\xc9@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-03-04T02:28:00", "lines": 47, "newlines": 47, "modlines": 0, "user": "ACIERI"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTSVCJ: REXX program to display SVC update journal.          */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*               SCVT - Supervisor Call Vector Table             */\n/*               SVCR - SVC Recording Table                      */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtabend = STORAGE(D2X(X2D(@cvt)+200),4)    /* get CVTABEND address  */\n@cvtabend = D2X(C2D(@cvtabend))                /* binary to hex       */\n@scvtsvcr = D2X(X2D(@cvtabend)+136)          /* SCVT addressibility   */\n@scvtsvcr = STORAGE(@scvtsvcr,4)                  /* SVCR table       */\n@scvtsvcr = D2X(C2D(@scvtsvcr))                /* binary to hex       */\nSay ' '\nSay ' '\nSay 'The CVT  is located at '@cvt '('X2D(@cvt)')'\nSay 'The CVTABEND field points to '@cvtabend '('X2D(@cvtabend)')'\nSay 'The SCVTSVCR field points to '@scvtsvcr '('X2D(@scvtsvcr)')'\nSay ' '\nSay 'The SVC Update Journal table is at '@scvtsvcr '('X2D(@scvtsvcr)')'\nSay ' '\nhits = 0\nDo i = 0 to 255                                 /* loop thru storage  */\n   bytes = STORAGE(D2X(X2D(@scvtsvcr)+(i*24)),24)\n   bytes = C2X(bytes)\n   If SUBSTR(bytes,1,16) \\= '0000000000000000'\n      Then Do\n         hits = hits + 1\n         Say ' '\n  Say '  SVC 'RIGHT(i,3,0) 'updated.  Old SVCTABLE entry: 'SUBSTR(bytes,1,16)\n  Say '           Updating pgm return address: 'SUBSTR(bytes,17,8)\n  Say '                    New SVC EP address: 'SUBSTR(bytes,26,8)\n  Say '                         Times updated: 'X2D(SUBSTR(bytes,41,4))\n         If SUBSTR(bytes,35,5) = '00000'\n            Then Say '                   Date of last update: unknown'\n       Else Say '                   Date of last update: 'SUBSTR(bytes,35,5)\n      End\nEnd\nSay ' '\nSay 'SVCTABLE entries showing updates in the journal = 'hits\nExit\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTSVCT": {"ttr": 5388, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x94\\x08\\x8f\\x01\\x14\\x05\\x0f\"W\\x00\\xbb\\x00\\xbb\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2014-02-19T22:57:00", "lines": 187, "newlines": 187, "modlines": 0, "user": "SCNS03"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTSVCT: REXX program to display SVC table from CSTOR.        */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*               SCVT - Supervisor Call Vector Table             */\n/*               SVCT - SVC Table                                */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\n/*--------------virtual storage map definition section----------------*/\nNumeric Digits 10           /* required to handle decimal conversions */\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to hex             */\n@cvtreal  = STORAGE(D2X(X2D(@cvt)+284),4)    /* get CVTREAL address   */\n@cvtreal  = D2X(C2D(@cvtreal))                 /* binary to hex       */\n@cvtshrvm = STORAGE(D2X(X2D(@cvt)+416),4)    /* get CVTSHRVM address  */\n@cvtshrvm = D2X(C2D(@cvtshrvm))                /* binary to hex       */\n@cvtgda   = STORAGE(D2X(X2D(@cvt)+560),4)    /* get CVTGDA address    */\n@cvtgda   = D2X(C2D(@cvtgda))                  /* binary to hex       */\n@gdacsa   = D2X(X2D(@cvtgda)+108)            /* locate GDACSAstarts   */\n@gdacsa   = D2X(C2D(STORAGE(@gdacsa,4)))       /*  get GDACSA         */\n@gdacsasz = D2X(X2D(@cvtgda)+112)            /* locate GDACSASiZe     */\n@gdacsasz = D2X(C2D(STORAGE(@gdacsasz,4)))     /*  get GDACSASiZe     */\n@gdaecsa  = D2X(X2D(@cvtgda)+124)            /* locate GDAECSAstarts  */\n@gdaecsa  = D2X(C2D(STORAGE(@gdaecsa,4)))      /*  get GDAECSA        */\n@gdaecsas = D2X(X2D(@cvtgda)+128)            /* locate GDAECSASize    */\n@gdaecsas = D2X(C2D(STORAGE(@gdaecsas,4)))     /*  get GDAECSAS       */\n@cvtsmext = STORAGE(D2X(X2D(@cvt)+1196),4)   /* get CVTSMEXT address  */\n@cvtsmext = D2X(C2D(@cvtsmext))                /* binary to hex       */\n@cvtmlpas = D2X(X2D(@cvtsmext)+8)            /* locate CVTMLPAStarts  */\n@cvtmlpas = D2X(C2D(STORAGE(@cvtmlpas,4)))     /*  get CVTMLPAS       */\n@cvtmlpae = D2X(X2D(@cvtsmext)+12)           /* locate CVTMLPAEnds    */\n@cvtmlpae = D2X(C2D(STORAGE(@cvtmlpae,4)))     /*  get CVTMLPAE       */\n@cvtflpas = D2X(X2D(@cvtsmext)+16)           /* locate CVTFLPAStarts  */\n@cvtflpas = D2X(C2D(STORAGE(@cvtflpas,4)))     /*  get CVTFLPAS       */\n@cvtflpae = D2X(X2D(@cvtsmext)+20)           /* locate CVTFLPAEnds    */\n@cvtflpae = D2X(C2D(STORAGE(@cvtflpae,4)))     /*  get CVTFLPAE       */\n@cvtplpas = D2X(X2D(@cvtsmext)+24)           /* locate CVTPLPAStarts  */\n@cvtplpas = D2X(C2D(STORAGE(@cvtplpas,4)))     /*  get CVTPLPAS       */\n@cvtplpae = D2X(X2D(@cvtsmext)+28)           /* locate CVTPLPAEnds    */\n@cvtplpae = D2X(C2D(STORAGE(@cvtplpae,4)))     /*  get CVTPLPAE       */\n@cvtrwns  = D2X(X2D(@cvtsmext)+32)           /* locate CVTRWNStarts   */\n@cvtrwns  = D2X(C2D(STORAGE(@cvtrwns,4)))      /*  get CVTRWNS        */\n@cvtrwne  = D2X(X2D(@cvtsmext)+36)           /* locate CVTRWNEnds     */\n@cvtrwne  = D2X(C2D(STORAGE(@cvtrwne,4)))      /*  get CVTRWNE        */\n@cvtrons  = D2X(X2D(@cvtsmext)+40)           /* locate CVTRONStarts   */\n@cvtrons  = D2X(C2D(STORAGE(@cvtrons,4)))      /*  get CVTRONS        */\n@cvtrone  = D2X(X2D(@cvtsmext)+44)           /* locate CVTRONEnds     */\n@cvtrone  = D2X(C2D(STORAGE(@cvtrone,4)))      /*  get CVTRONE        */\n@cvterwns = D2X(X2D(@cvtsmext)+48)           /* locate CVTERWNStarts  */\n@cvterwns = D2X(C2D(STORAGE(@cvterwns,4)))     /*  get CVTERWNS       */\n@cvterwne = D2X(X2D(@cvtsmext)+52)           /* locate CVTERWNEnds    */\n@cvterwne = D2X(C2D(STORAGE(@cvterwne,4)))     /*  get CVTRRWNE       */\n@cvteplps = D2X(X2D(@cvtsmext)+56)           /* locate CVTEPLPStarts  */\n@cvteplps = D2X(C2D(STORAGE(@cvteplps,4)))     /*  get CVTEPLPS       */\n@cvteplpe = D2X(X2D(@cvtsmext)+60)           /* locate CVTEPLPEnds    */\n@cvteplpe = D2X(C2D(STORAGE(@cvteplpe,4)))     /*  get CVTRPLPE       */\n@cvteflps = D2X(X2D(@cvtsmext)+64)           /* locate CVTEFLPStarts  */\n@cvteflps = D2X(C2D(STORAGE(@cvteflps,4)))     /*  get CVTEFLPS       */\n@cvteflpe = D2X(X2D(@cvtsmext)+68)           /* locate CVTEFLPEnds    */\n@cvteflpe = D2X(C2D(STORAGE(@cvteflpe,4)))     /*  get CVTRFLPE       */\n@cvtemlps = D2X(X2D(@cvtsmext)+72)           /* locate CVTEMLPStarts  */\n@cvtemlps = D2X(C2D(STORAGE(@cvtemlps,4)))     /*  get CVTEMLPS       */\n@cvtemlpe = D2X(X2D(@cvtsmext)+76)           /* locate CVTEMLPEnds    */\n@cvtemlpe = D2X(C2D(STORAGE(@cvtemlpe,4)))     /*  get CVTRMLPE       */\n        /*------simplify variable names & make addresses decimal------*/\n@csa1g  = @gdacsa    ; @csa2g = D2X(X2D(@gdacsasz)+X2D(@gdacsa)-1)/* g*/\n   csa1 = X2D(@csa1g) ; csa2 = X2D(@csa2g)                    /* csa  */\n@mlpa1  = @cvtmlpas  ; @mlpa2 = @cvtmlpae                     /* mlpa */\n   mlpa1 = X2D(@mlpa1) ; mlpa2 = X2D(@mlpa2)\n@flpa1  = @cvtflpas  ; @flpa2 = @cvtflpae                     /* flpa */\n   flpa1 = X2D(@flpa1) ; flpa2 = X2D(@flpa2)\n@plpa1  = @cvtplpas  ; @plpa2 = @cvtplpae                     /* plpa */\n   plpa1 = X2D(@plpa1) ; plpa2 = X2D(@plpa2)\n@sqa1   = D2X(X2D(@cvtplpae)+1) ; @sqa2 = D2X(X2D(@cvtrwns)-1)/* sqa  */\n   sqa1 = X2D(@sqa1) ; sqa2 = X2D(@sqa2)\n@nuc1   = @cvtrwns   ; @nuc2  = @cvterwne                     /* nuc  */\n   nuc1 = X2D(@nuc1) ; nuc2 = X2D(@nuc2)\n@esqa1  = D2X(X2D(@nuc2)+1) ; @esqa2 = D2X(X2D(@cvteplps)-1)  /* esqa */\n  esqa1 = X2D(@esqa1) ; esqa2 = X2D(@esqa2)\n@eplpa1 = @cvteplps  ; @eplpa2 = @cvteplpe                    /* eplpa*/\n eplpa1 = X2D(@eplpa1) ; eplpa2 = X2D(@eplpa2)\n@eflpa1 = @cvteflps  ; @eflpa2 = @cvteflpe                    /* eflpa*/\n eflpa1 = X2D(@eflpa1) ; eflpa2 = X2D(@eflpa2)\n@emlpa1 = @cvtemlps  ; @emlpa2 = @cvtemlpe                    /* emlpa*/\n emlpa1 = X2D(@emlpa1) ; emlpa2 = X2D(@emlpa2)\n@ecsa1g = @gdaecsa   ; @ecsa2g= D2X(X2D(@gdaecsas)+X2D(@gdaecsa)-1)/*g*/\n  ecsa1 = X2D(@ecsa1g) ; ecsa2 = X2D(@ecsa2g)\n@eprivs = X2D(@ecsa2g)+1                               /* ext private */\n@eprive = 2147483647                         /* fixed by architecture */\n epriv1 = @eprivs ; epriv2 = @eprive\n@psas   = 0 ; @psae = 4095                       /* psa fixed by arch */\n   psa1 = @psas ; psa2 = @psae\n@prive  = X2D(@csa1g)-1 ; @privs = X2D(@psae)+1            /* private */\n  priv1 = @privs ; priv2 = @prive\n              /*------------------------------------------------------*/\n             /* Usage Notes: Hex character compares are incompatible */\n            /*    for storage residency determination.  Thus, entry */\n           /*     point addresses must be converted to decimal and */\n          /*      VS boundary addresses must be converted to de-  */\n         /*       cimal for correct compare operations.          */\n        /*------------------------------------------------------*/\n/*----------end of virtual storage map definition section-------------*/\n@cvtabend = STORAGE(D2X(X2D(@cvt)+200),4)    /* get CVTABEND address  */\n@cvtabend = D2X(C2D(@cvtabend))                /* binary to hex       */\n@scvtsvct = D2X(X2D(@cvtabend)+132)          /* SCVT addressibility   */\n@scvtsvct = STORAGE(@scvtsvct,4)                  /* SVCT table       */\n@scvtsvct = D2X(C2D(@scvtsvct))                /* binary to hex       */\nAddress TSO ; \"CLEAR\"\nSay 'CVT:'@cvt' CVTABEND:'@cvtabend' SCVTSVCT:'@scvtsvct DATE() TIME()\nSay ' '\nSay 'Active SVCs follow:'\nSay ' '\nactive = 0 ; inactive = 0 ; svcapf = 0 ; svcesr = 0\nnucepn = 'IGCERROR' ; Call \"#NUCLKUP\" nucepn ; igcerror = Result\nDo i = 0 to 255                                 /* loop thru storage  */\n   bytes = STORAGE(D2X(X2D(@scvtsvct)+(i*8)),8)\n   addr = SUBSTR(bytes,1,4)       /* sloppy code to grab EP in binary */\n   bytes = C2X(bytes)          /* legacy code before learning bit ops */\n   svcep  = SUBSTR(bytes,1,8)\n                                        /* determine storage location */\n   addr = BITAND(addr,'7FFFFFFF'x)        /* shave off amode bit (32) */\n   addr = C2D(addr)                      /* make numeric for compares */\n   sloc = 'ERROR'                       /* determine module residency */\n   If (addr >= csa1   & addr <= csa2  ) Then sloc = 'CSA  '\n      Else If (addr >= mlpa1  & addr <= mlpa2 ) Then sloc = 'MLPA '\n      Else If (addr >= flpa1  & addr <= flpa2 ) Then sloc = 'FLPA '\n      Else If (addr >= plpa1  & addr <= plpa2 ) Then sloc = 'PLPA '\n      Else If (addr >= sqa1   & addr <= sqa2  ) Then sloc = 'SQA  '\n      Else If (addr >= nuc1   & addr <= nuc2  ) Then sloc = 'NUC  '\n      Else If (addr >= esqa1  & addr <= esqa2 ) Then sloc = 'ESQA '\n      Else If (addr >= eplpa1 & addr <= eplpa2) Then sloc = 'EPLPA'\n      Else If (addr >= eflpa1 & addr <= eflpa2) Then sloc = 'EFLPA'\n      Else If (addr >= emlpa1 & addr <= emlpa2) Then sloc = 'EMLPA'\n      Else If (addr >= ecsa1  & addr <= ecsa2 ) Then sloc = 'ECSA '\n      Else If (addr >= epriv1 & addr <= epriv2) Then sloc = 'EPRIV'\n      Else If (addr >= priv1  & addr <= priv2 ) Then sloc = 'PRIV '\n      Else If (addr >= psa1   & addr <= psa2  ) Then sloc = 'PSA  '\n      inactflag = 0\n      If igcerror = Right(D2X(addr),8,0)  /* normalize for match */\n         Then Do\n            inactive = inactive + 1\n            inactflag = 1\n         End\n         Else active = active + 1\n   svctp1 = SUBSTR(bytes,9,1)\n      Select\n         When svctp1 = '0'\n            Then svctype = 'TYPE 1  '\n         When svctp1 = '8'\n            Then svctype = 'TYPE 2  '\n         When svctp1 = 'C'\n            Then svctype = 'TYPE 3/4'\n         When svctp1 = '2'\n            Then svctype = 'TYPE 6  '\n      Otherwise\n                 svctype = 'TYPE ?  '\n      End\n   svctp2 = SUBSTR(bytes,10,1)\n      svcmisc = '   '\n      If svctp2 = '8'\n         Then Do\n            svcmisc = 'APF'\n            svcapf = svcapf + 1\n         End\n      If svctp2 = '4'\n         Then Do\n            svcmisc = 'ESR'\n            svcesr = svcesr + 1\n         End\n   If inactflag = 0\n      Then Say 'SVC 'RIGHT(i,3,0) '('RIGHT(D2X(i),2,0)')',\n               svctype svcep sloc svcmisc\nEnd\nSay ' '\nSay 'SVCTABLE processing complete ' TIME()\nSay ' '\nSay 'There are 'active 'active standard SVCs on this system.'\nSay 'Among the active SVCs, 'svcapf 'are APF restricted.'\nSay 'There are 'svcesr 'active ESR router SVCs present.'\nSay 'The SVCTABLE contains 'inactive 'inactive slots (IGCERROR).'\nSay '    (IGCERROR nucleus address = 'igcerror')'\nSay ' '\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTTAPE": {"ttr": 5633, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x00\\x01\\x15\\x02_\\x01\\x15\\x02o\\x18A\\x00V\\x00V\\x00\\x00\\xc1\\xc3\\xc9\\xc5\\xd9\\xc9@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2015-01-25T00:00:00", "modifydate": "2015-01-26T18:41:00", "lines": 86, "newlines": 86, "modlines": 0, "user": "ACIERI"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTTAPE: REXX program to display all online TAPE devices.     */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                UCB - Device Unit Control Block                */\n/*                                                               */\n/* @ z/OS V2.2 the ULUT has been moved into 64 bit storage.      */\n/*                                                               */\n/*****************************************************************/\nAddress TSO ; \"CLEAR\" ; Numeric Digits 20    /* 20 can handle 64 bits */\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to dec to hex      */\n@cvtucba  = STORAGE(D2X(X2D(@cvt)+1252),4)   /* get CVTUCBA address   */\n@cvtucba  = D2X(C2D(@cvtucba))                 /* binary to dec to hex*/\n@cvtixav  = STORAGE(D2X(X2D(@cvt)+124),4)      /* get CVTIXAVL addres */\n@cvtixav  = D2X(C2D(@cvtixav))                       /* binary to hex */\n@iovtadr  = STORAGE(D2X(X2D(@cvtixav)+208),4)  /* get IOVT address    */\n@iovtadr  = D2X(C2D(@iovtadr))                       /* binary to hex */\n@ulutadr  = STORAGE(D2X(X2D(@iovtadr)+8),4)    /* get IOVT address    */\n@ulutadr  = D2X(C2D(@ulutadr))                       /* binary to hex */\nif @ulutadr = 0 then                            /* zOS V2.2 or higher */\n  do                                            /* or V2.1/V1.13 w/PTF*/\n   Say 'zOS:'MVSVAR(SYSOPSYS)' Ulut is in 64 bit storage'\n   @ulutadr  = STORAGE(D2X(X2D(@iovtadr)+440),8)  /* get IOVT address */\n   @ulutadr  = D2X(C2D(@ulutadr))                    /* binary to hex */\n  end\nulu      = STORAGE(@ulutadr,64)             /* get 64 byte ulu header */\nuluname  = SUBSTR(ulu,1,4)                         /* ulut eyecatcher */\nulutype  = SUBSTR(ulu,5,1)\nIf ulutype = '01'x Then off = 0                    /* ULUT Type 1     */\nIf ulutype = '02'x Then off = 8                    /* ULUT Type 2     */\nIf ulutype = '03'x Then                            /* ULUT Type 3     */\n Do\n   ulufirst = SUBSTR(ulu,17,8)          /* addr of 1st ULU element(64)*/\n   uluucbno = SUBSTR(ulu,29,4)          /* # of ucb's this I/O config */\n   off = 12\n End\nElse\n Do                                     /* Ulut type 1 or 2           */\n   ulufirst = SUBSTR(ulu,13+off,4)      /* address of 1st ULU element */\n   uluucbno = SUBSTR(ulu,17+off,4)      /* # of ucb's this I/O config */\n End\n uluttape = SUBSTR(ulu,21+off,4)        /* # of TAPE UCBs in I/O cfg  */\n ulutcomm = SUBSTR(ulu,25+off,4)        /* # of COMM UCBs in I/O cfg  */\n ulutdasd = SUBSTR(ulu,29+off,4)        /* # of DASD UCBs in I/O cfg  */\n @uluchn  = C2X(ulufirst)\nSay 'CVT: '@cvt' CVTUCBA: '@cvtucba' ===> TAPE UCB scan started: 'TIME()\nSay '            CVTIXAV:'@cvtixav' IOVT:'@iovtadr' ULUT: '@ulutadr\nSay '                                        ULUT Type: 'C2D(ulutype)\nSay ' '\nSay '     This I/O configuration has 'C2D(uluttape)' TAPE UCBs defined!'\nSay ' '\n@ucbchn = @cvtucba\ni = 0 ; j = 0\nDo i = 1 to C2D(uluucbno)               /* scan the ULUT for ALL DASD */\n    uluelmnt = STORAGE(@uluchn,12)       /* get 12 byte ULUT element */\n    uluucbad = SUBSTR(uluelmnt,9,4)     /* 1st ucb this device class */\n    uluucbad = C2X(uluucbad) ; @ucbchn = uluucbad\n   ucb     = STORAGE(@ucbchn,24)    /* get 24 byte ucb common segment */\n   ucbid   = SUBSTR(ucb,3,1)                 /* get the 'FF'x id byte */\n   ucbstat = SUBSTR(ucb,4,1)              /* status byte '80'x online */\n   ucbchan = SUBSTR(ucb,5,2)                /* channel address in hex */\n   ucbnxucb= SUBSTR(ucb,9,4)                   /* pointer to next ucb */\n   ucbtbyt3= SUBSTR(ucb,19,1)                 /* device '80'x is TAPE */\n   ucbtbyt4= SUBSTR(ucb,20,1)           /* contains device type codes */\n   If (BITAND(ucbstat,'80'x)='80'x & BITAND(ucbtbyt3,'80'x)='80'x) Then Do\n      j = j + 1; device = 'Unknown'\n      ioaddr = C2X(ucbchan)\n      If BITAND(ucbtbyt4,'80'x)='80'x Then device = '3480   '\n      If BITAND(ucbtbyt4,'01'x)='01'x Then device = '2400   '\n      If BITAND(ucbtbyt4,'03'x)='03'x Then device = '3420   '\n      If BITAND(ucbtbyt4,'81'x)='81'x Then device = '3490E  '\n      @ucbchn=D2X(X2D(@ucbchn)+24)            /* bump to TAPE segment */\n      ucbtape = STORAGE(@ucbchn,24)       /* get 24 byte TAPE segment */\n      ucbfser = SUBSTR(ucbtape,5,6)              /* volser if mounted */\n      If C2X(ucbfser) = '000000000000' Then ucbfser = '-idle-'\n      Say RIGHT(j,3,' ') RIGHT(ioaddr,3) STRIP(device) ucbfser\n   End\n   @uluchn  = D2X(x2d(@uluchn)+12)\nEnd\nSay ' '\nSay 'Last UCB after 'i' blocks scanned.  Completed: 'TIME()\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MISC": {"ttr": 5636, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x94'\\x8f\\x00\\x94'\\x8f\\x19D\\x00\\xf9\\x00\\xf9\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-10-05T00:00:00", "modifydate": "1994-10-05T19:44:00", "lines": 249, "newlines": 249, "modlines": 0, "user": "SBGCSC"}, "text": "./ ADD NAME=ALLOCGDG 0100-94267-94267-1200-00012-00012-00000-CONYERS\n//MS01@IDC JOB (MS01,228),'CONYERS - ALLOCGDG',MSGCLASS=T,CLASS=A,\n//         NOTIFY=MS01VC1,MSGLEVEL=(1,1),TIME=(,05)\n//STEP0001 EXEC PGM=IDCAMS\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  *\n  DEFINE GENERATIONDATAGROUP                     -\n     (                                           -\n      NAME(MS01.CONYERS.PLPAMODS.DATA)           -\n      LIMIT(255)                                 -\n      NOEMPTY                                    -\n      SCRATCH                                    -\n     )\n./ ADD NAME=IKJEFT01 0100-94267-94267-1200-00011-00011-00000-CONYERS\n//MS01@TSO JOB (MS01,228),'CONYERS - IKJEFT01',MSGCLASS=T,CLASS=A,\n//         NOTIFY=MS01VC1,MSGLEVEL=(1,1),TIME=(,06),REGION=8M\n//********************************************************************\n//*  BATCH TSO SESSION.  USED TO TEST REXX PROGRAMS.\n//********************************************************************\n//TMPGO    EXEC PGM=IKJEFT01,REGION=8M ,DYNAMNBR=200 ,TIME=(2)\n//SYSPROC  DD DISP=SHR,DSN=MS01.CONYERS.EXEC\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%VSDATA4\n./ ADD NAME=JOBMVS1  0100-94267-94267-1200-00125-00125-00000-CONYERS\n//MS01@MVS JOB (MS01,228),'CONYERS - JOBMVS1 ',MSGCLASS=T,CLASS=A,\n//         NOTIFY=MS01VC1,MSGLEVEL=(1,1),TIME=(3),REGION=8M\n//********************************************************************\n//*  BATCH TSO SESSION.  USED TO RUN MVS AUDIT REXX PROGRAMS.\n//********************************************************************\n//ENV      EXEC PGM=IKJEFT01,REGION=8M,DYNAMNBR=200,TIME=(,5)\n//SYSPROC  DD DISP=SHR,DSN=MS01.CONYERS.EXEC\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%LISTENV\n//SMF      EXEC PGM=IKJEFT01,REGION=8M,DYNAMNBR=200,TIME=(,5)\n//SYSPROC  DD DISP=SHR,DSN=MS01.CONYERS.EXEC\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%LISTSMF\n//SSN      EXEC PGM=IKJEFT01,REGION=8M,DYNAMNBR=200,TIME=(,5)\n//SYSPROC  DD DISP=SHR,DSN=MS01.CONYERS.EXEC\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%LISTSSN\n//ADSP     EXEC PGM=IKJEFT01,REGION=8M,DYNAMNBR=200,TIME=(,5)\n//SYSPROC  DD DISP=SHR,DSN=MS01.CONYERS.EXEC\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%LISTADSP\n//VMAP     EXEC PGM=IKJEFT01,REGION=8M,DYNAMNBR=200,TIME=(,5)\n//SYSPROC  DD DISP=SHR,DSN=MS01.CONYERS.EXEC\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%LISTVMAP\n//SVCT     EXEC PGM=IKJEFT01,REGION=8M,DYNAMNBR=200,TIME=(,5)\n//SYSPROC  DD DISP=SHR,DSN=MS01.CONYERS.EXEC\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%LISTSVCT\n//ESRT     EXEC PGM=IKJEFT01,REGION=8M,DYNAMNBR=200,TIME=(,5)\n//SYSPROC  DD DISP=SHR,DSN=MS01.CONYERS.EXEC\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%LISTESRT\n//CATS     EXEC PGM=IKJEFT01,REGION=8M,DYNAMNBR=200,TIME=(,5)\n//SYSPROC  DD DISP=SHR,DSN=MS01.CONYERS.EXEC\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%LISTCATS\n//LPAQ     EXEC PGM=IKJEFT01,REGION=8M,DYNAMNBR=200,TIME=(,5)\n//SYSPROC  DD DISP=SHR,DSN=MS01.CONYERS.EXEC\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%LISTLPAQ\n//PLPA     EXEC PGM=IKJEFT01,REGION=8M,DYNAMNBR=200,TIME=(,5)\n//SYSPROC  DD DISP=SHR,DSN=MS01.CONYERS.EXEC\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%LISTPLPA\n//CONS     EXEC PGM=IKJEFT01,REGION=8M,DYNAMNBR=200,TIME=(,5)\n//SYSPROC  DD DISP=SHR,DSN=MS01.CONYERS.EXEC\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%LISTCONS\n//IOAPFP   EXEC PGM=IKJEFT01,REGION=8M,DYNAMNBR=200,TIME=(2)\n//SYSPROC  DD DISP=SHR,DSN=MS01.CONYERS.EXEC\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%IOAPFP\n//IOLLTP   EXEC PGM=IKJEFT01,REGION=8M,DYNAMNBR=200,TIME=(2)\n//SYSPROC  DD DISP=SHR,DSN=MS01.CONYERS.EXEC\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%IOLLTP\n//IOLPAP   EXEC PGM=IKJEFT01,REGION=8M,DYNAMNBR=200,TIME=(2)\n//SYSPROC  DD DISP=SHR,DSN=MS01.CONYERS.EXEC\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%IOLPAP\n//IOLPAQ   EXEC PGM=IKJEFT01,REGION=8M,DYNAMNBR=200,TIME=(,5)\n//SYSPROC  DD DISP=SHR,DSN=MS01.CONYERS.EXEC\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%IOLPAQ\n//IOPLPA   EXEC PGM=IKJEFT01,REGION=8M,DYNAMNBR=200,TIME=(,5)\n//SYSPROC  DD DISP=SHR,DSN=MS01.CONYERS.EXEC\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%IOPLPA\n//IOSVCT   EXEC PGM=IKJEFT01,REGION=8M,DYNAMNBR=200,TIME=(,5)\n//SYSPROC  DD DISP=SHR,DSN=MS01.CONYERS.EXEC\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%IOSVCT\n//IOESRT   EXEC PGM=IKJEFT01,REGION=8M,DYNAMNBR=200,TIME=(,5)\n//SYSPROC  DD DISP=SHR,DSN=MS01.CONYERS.EXEC\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%IOESRT\n//IOPCAUTH EXEC PGM=IKJEFT01,REGION=8M,DYNAMNBR=200,TIME=(,5)\n//SYSPROC  DD DISP=SHR,DSN=MS01.CONYERS.EXEC\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%IOPCAUTH\n//IONUCM   EXEC PGM=IKJEFT01,REGION=8M,DYNAMNBR=200,TIME=(,5)\n//SYSPROC  DD DISP=SHR,DSN=MS01.CONYERS.EXEC\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%IONUCM\n./ ADD NAME=JOBMVS2  0100-94267-94267-1200-00060-00060-00000-CONYERS\n//MS01@MVS JOB (MS01,228),'CONYERS - JOBMVS2 ',MSGCLASS=T,CLASS=A,\n//         NOTIFY=MS01VC1,MSGLEVEL=(1,1),TIME=(3),REGION=8M\n//********************************************************************\n//*  BATCH TSO SESSION.  USED TO RUN MVS AUDIT REXX PROGRAMS.\n//*  DATA COLLECTOR FOR INSTORAGE MODULE, SVC, PC, ETC. DATA.\n//********************************************************************\n//ENV      EXEC PGM=IKJEFT01,REGION=8M,DYNAMNBR=200,TIME=(,5)\n//SYSPROC  DD DISP=SHR,DSN=MS01.CONYERS.EXEC\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%LISTENV\n//SMF      EXEC PGM=IKJEFT01,REGION=8M,DYNAMNBR=200,TIME=(,5)\n//SYSPROC  DD DISP=SHR,DSN=MS01.CONYERS.EXEC\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%LISTSMF\n//VMAP     EXEC PGM=IKJEFT01,REGION=8M,DYNAMNBR=200,TIME=(,5)\n//SYSPROC  DD DISP=SHR,DSN=MS01.CONYERS.EXEC\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%LISTVMAP\n//IOLPAQ   EXEC PGM=IKJEFT01,REGION=8M,DYNAMNBR=200,TIME=(,5)\n//SYSPROC  DD DISP=SHR,DSN=MS01.CONYERS.EXEC\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%IOLPAQ\n//IOPLPA   EXEC PGM=IKJEFT01,REGION=8M,DYNAMNBR=200,TIME=(,5)\n//SYSPROC  DD DISP=SHR,DSN=MS01.CONYERS.EXEC\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%IOPLPA\n//IOSVCT   EXEC PGM=IKJEFT01,REGION=8M,DYNAMNBR=200,TIME=(,5)\n//SYSPROC  DD DISP=SHR,DSN=MS01.CONYERS.EXEC\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%IOSVCT\n//IOESRT   EXEC PGM=IKJEFT01,REGION=8M,DYNAMNBR=200,TIME=(,5)\n//SYSPROC  DD DISP=SHR,DSN=MS01.CONYERS.EXEC\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%IOESRT\n//IOPCAUTH EXEC PGM=IKJEFT01,REGION=8M,DYNAMNBR=200,TIME=(,5)\n//SYSPROC  DD DISP=SHR,DSN=MS01.CONYERS.EXEC\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%IOPCAUTH\n//IONUCM   EXEC PGM=IKJEFT01,REGION=8M,DYNAMNBR=200,TIME=(,9)\n//SYSPROC  DD DISP=SHR,DSN=MS01.CONYERS.EXEC\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%IONUCM\n./ ADD NAME=SNAPPC   0100-94267-94267-1200-00024-00024-00000-CONYERS\n//MS01@SNP JOB (MS01,228),'CONYERS - SNAPPC ',MSGLEVEL=(1,1),\n//         NOTIFY=MS01VC1,MSGCLASS=T,TIME=(,10),CLASS=A\n//ASSEM    EXEC ASMHCLG,REGION=1000K\n//C.SYSIN    DD *\nSNAP     CSECT\n         STM   14,12,12(13)\n         LR    12,15\n         USING SNAP,12\nBEGIN    ST    13,SAVE+4\n         LR    2,13\n         LA    13,SAVE\n         ST    13,8(2)\n         OPEN  (PRTOUT,OUTPUT)\n         SNAP  DCB=PRTOUT,SDATA=(PCDATA)\n         CLOSE PRTOUT\n         L     13,SAVE+4\n         RETURN (14,12),RC=0\nPRTOUT   DCB   DSORG=PS,RECFM=VBA,LRECL=125,BLKSIZE=1632,MACRF=(W),    X\n               DDNAME=SNAPRINT\n*\nSAVE     DS    18F'0'\n         END\n//G.SYSUDUMP DD SYSOUT=*\n//G.SNAPRINT DD DISP=OLD,DSN=MS01.CONYERS.PCAUTH.DATA.WORK\n./ ADD NAME=UDUMP280 0100-94267-94267-1200-00011-00011-00000-CONYERS\n//MS01DUMP JOB (MS01,228),'CONYERS - UDUMP280',MSGCLASS=T,CLASS=A,\n//         NOTIFY=MS01VC1,MSGLEVEL=(1,1),TIME=(,06)\n//BARF     EXEC PGM=DYL280,REGION=2048K\n//STEPLIB  DD DSN=T2.T201XXXX.DYLLIB,DISP=SHR\n//SYS004   DD UNIT=SYSDA,SPACE=(TRK,5)\n//SYSPRINT DD SYSOUT=*\n//INFILE   DD DISP=SHR,DSN=SYS1.LINKLIB(MSTJCL00)\n//SYSIN    DD *\nFILE INFILE COUNT INCOUNT\n IF INCOUNT LE   50 HEXPRINT INFILE            ENDIF\nFIN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "NOT@OR": {"ttr": 5641, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x08\\x8f\\x00\\x94\\x08\\x8f\\x10\\x00\\x00\\x02\\x00\\x02\\x00\\x00\\xc3\\xd6\\xd5\\xe8\\xc5\\xd9\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "1994-03-29T10:00:00", "lines": 2, "newlines": 2, "modlines": 0, "user": "CONYERS"}, "text": "  \u00ac  IBM EBCDIC 'not' character is '5F'x                                al\n  |  IBM EBCDIC 'or'  character is '4F'x                                al\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PDSLOAD": {"ttr": 5643, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x15\\x7f\\x01\\x01\\x15\\x7f\\x156\\x00e\\x00e\\x00\\x00\\xd3\\xd6\\xc1\\xc4\\xd3\\xc9\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-06-06T00:00:00", "modifydate": "2001-06-06T15:36:00", "lines": 101, "newlines": 101, "modlines": 0, "user": "LOADLIB"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "REXXMEM": {"ttr": 5646, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\t\\x01\\x15\\x02\\x8f\\x01\\x15\\x02\\x9f\\x145\\x01\\\\\\x01\\\\\\x00\\x00\\xc1\\xc3\\xc9\\xc5\\xd9\\xc9@@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2015-01-28T00:00:00", "modifydate": "2015-01-29T14:35:09", "lines": 348, "newlines": 348, "modlines": 0, "user": "ACIERI"}, "text": "/* REXX -                                */\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/*                                       */\n/*   Indirect storage addressing code    */\n/*   contribution from: Mau Tran         */\n/*                                       */\n/*                                       */\nhelp_start = HELP_INCL()\n/*********************************************************************/\n/* DISPLAY MEMORY IN \"DUMP\" FORMAT                                   */\n/*********************************************************************/\n/* EXECUTION SYNTAX:                                                 */\n/*                                                                   */\n/* TSO %REXXMEM <strt_addr> <length>                                 */\n/*                                                                   */\n/* The strt_addr and length values are expected to be hexidecimal.   */\n/* The hexadecimal values supplied may be represented with or        */\n/* without an \"X\". In other words, x'100' and 100 can both be        */\n/* processed and are treated the same.                               */\n/*                                                                   */\n/* strt_addr can also make use of indirect storage addressing        */\n/* similar to IPCS.  \"?\", \"%\", \"+\", \"-\" and \".\" are supported.       */\n/* See the examples below.                                           */\n/*                                                                   */\n/* NOTE #1: If no length is specified, then the default is 100 (hex).*/\n/*                                                                   */\n/* NOTE #2: While \".\" is supported like IPCS, it is not required     */\n/*          when the initial digit is the letter A through F like    */\n/*          it is in IPCS and is essentially ignored.                */\n/*                                                                   */\n/* NOTE #3: If any storage in the range is protected, then none of   */\n/*          it can be displayed. This is how the REXX STORAGE        */\n/*          function works.                                          */\n/*                                                                   */\n/* NOTE #4: If you execute REXXMEM without a parm or a parm of \"?\"   */\n/*          the comment section of this code with syntax and usage   */\n/*          notes plus examples will be displayed as \"help\".         */\n/*                                                                   */\n/*********************************************************************/\n/*                                                                   */\n/* Examples:                                                         */\n/*  TSO %REXXMEM               (display syntax, notes & examples)    */\n/*  TSO %REXXMEM 0             (start at x'00000000' for x'100')     */\n/*  TSO %REXXMEM 10 100        (start at x'00000010' for x'100')     */\n/*  TSO %REXXMEM x'10' x'100'  (start at x'00000010' for x'100')     */\n/*  TSO %REXXMEM FD0740        (start at x'00FD0740' for x'100')     */\n/*  TSO %REXXMEM FD0746 64     (start at x'00FD0746' for x'64')      */\n/*  TSO %REXXMEM 4C%           (24-bit ptr to stor at x'4C')         */\n/*  TSO %REXXMEM 10.%%         (24-bit ptr x'10' + 2nd 24-bit ptr)   */\n/*  TSO %REXXMEM 10?           (31-bit ptr to stor at x'10' - CVT)   */\n/*  TSO %REXXMEM 10?+8C? 200   (point to ECVT stor for x'200')       */\n/*  TSO %REXXMEM 10?+22C? 1E00 (point to ASVT stor for x'1E00')      */\n/*  TSO %REXXMEM 10?+8C?+188? 1000    (point to IPA for x'1000')     */\n/*                                                                   */\n/*********************************************************************/\nhelp_end = HELP_INCL()\n/*********************************************************************/\nLASTUPD = '02/07/2014'                    /* date of last update     */\n/*********************************************************************/\nArg R_ADDR R_LEN\nHELPDSP = 0                               /* default panel display   */\nNumeric digits 20                         /* dflt of 9 not enough    */\nIf R_ADDR = '' | R_ADDR = '?' then do     /* call help routine       */\n  R_ADDR  = 0\n  R_LEN   = 0\n  HELPDSP = 1                             /* help panel display      */\n  Call HELP_DISPLAY\n  Call FINISHED\nEnd                                       /* tokenize strt_addr parm */\n/*********************************************************************/\nSignal On Syntax                          /* error condition         */\nIf R_ADDR = '' then R_ADDR = 0            /* dflt strt_addr 00000000 */\nIf R_LEN  = '' then R_LEN = 100           /* dflt length x'100'      */\nR_ADDR = Translate(R_ADDR,\"\",\"xX'\")       /* remove hex notation     */\nR_ADDR = Space(R_ADDR,0)                  /* rmv blnks in addr string*/\nR_LEN  = Translate(R_LEN ,\"\",\"xX'\")       /* remove hex notation     */\nR_LEN  = Strip(R_LEN)                     /* remove blanks           */\n/*********************************************************************/\n/* Tokenize the input address string for indirect addressing         */\n/*********************************************************************/\nCall TOKENIZE R_ADDR\nR_ADDR = TOKEN.1\n/*********************************************************************/\nR_ADDR = X2d(R_ADDR)                      /* change to dec for rexx  */\nR_LEN  = X2d(R_LEN)                       /* change to dec for rexx  */\nR_ADDR = RESOLVE_ADDR(R_ADDR)\n/*********************************************************************/\n/* Try and get the storage requested                                 */\n/*********************************************************************/\nD_STOR = Storage(D2x(R_ADDR),R_LEN)             /* get the storage   */\nIf D_STOR = '' then do                          /* none returned?    */\n  Say  'Some storage in specified range is protected - none' ,\n       'can be displayed.'\n  \"Delstack\"                                    /* delete data stack */\n  Exit 12\nEnd\nD_STORX = C2x(D_STOR)\nD_STORL = Length(D_STORX)\n/*********************************************************************/\n/* Routine to make sure we start the storage display at an address   */\n/* that is on a quadruple word boundry.                              */\n/*********************************************************************/\nIf (R_ADDR/16) <> 0 then do\n  T1    = Trunc(R_ADDR/16)\n  T2    = T1 * 16\n  DIFF_S = R_ADDR - T2\n  D_ADDR = R_ADDR - DIFF_S\n  D_STORX = Copies('40',DIFF_S) || D_STORX       /* add blanks       */\n  D_STORL = Length(D_STORX)\nEnd\nElse D_ADDR = R_ADDR\n/*********************************************************************/\n/* Routine to format storage address and length from above           */\n/*********************************************************************/\nD_OFF    = 0                                     /* relative offset  */\n  Queue '    Address       Offset  0-1-2-3-  4-5-6-7-  8-9-A-B-  C-D-E-F-',\n'   0123456789ABCDEF'\nDo I = 1 to D_STORL by 32\n  D_ADDR   = Right(D2x(D_ADDR),16,0)             /*@format stg addr  */\n  D_OFF2   = Right('+'|| D2x(D_OFF),6,' ')       /* format offset    */\n  D_STOR_A = Strip(Substr(D_STORX,I,32))         /* remove blanks    */\n  If I > D_STORL - 32 then do                    /* last time only   */\n    DIFF_L   = (31-(D_STORL-I)) / 2  /* figure out how many blanks   */\n    ENDBLNKS = Copies(' ',DIFF_L)    /* to add at end of ebcdic      */\n    D_STOR_E = X2c(D_STOR_A) || ENDBLNKS         /* make EBCDIC      */\n  End\n  Else D_STOR_E = X2c(D_STOR_A)                  /* make EBCDIC      */\n  If I = 1 & R_ADDR <> 0 then                    /* fix hex display  */\n    D_STORX = Overlay(' ',D_STORX,1,DIFF_S*2, ' ') /* for start addr */\n  D_STORX1 = Substr(D_STORX,I,8)                 /* first  word      */\n  D_STORX2 = Substr(D_STORX,I+8,8)               /* second word      */\n  D_STORX3 = Substr(D_STORX,I+16,8)              /* third  word      */\n  D_STORX4 = Substr(D_STORX,I+24,8)              /* forth  word      */\n  Queue  D_ADDR '' D_OFF2 '' D_STORX1 '' D_STORX2 '' D_STORX3 ,\n         ''  D_STORX4  ' |' D_STOR_E '|'\n  D_ADDR = X2d(D_ADDR) + 16                      /* bump up addr     */\n  If I = 1 & R_ADDR <> 0 then D_OFF = 16-DIFF_S  /* bump up offset   */\n    Else D_OFF = D_OFF + 16                      /* bump up offset   */\nEnd\nQueue ''  /* NULL Queue TO END STACK   */\n/***************************************************************/\nFINISHED:\nIf Sysvar(SYSISPF) = 'ACTIVE' then call BROWSE_ISPF\nElse do Queued()\n Parse pull line\n Say line\nEnd\nExit 0\n/***************************************************************/\nBROWSE_ISPF:\nQueue ''  /* null queue to end stack   */\nAddress ISPEXEC \"CONTROL ERRORS RETURN\"\nAddress ISPEXEC \"VGET ZENVIR\"\nAddress TSO\nprefix = sysvar('SYSPREF')        /* tso profile prefix            */\nuid    = sysvar('SYSUID')         /* tso userid                    */\nIf prefix = '' then prefix = uid  /* use uid if null prefix        */\nIf prefix <> '' & prefix <> uid then /* different prefix than uid  */\n   prefix = prefix || '.' || uid /* use  prefix.uid                */\nddnm1 = 'DD'||random(1,99999)   /* choose random ddname            */\nddnm2 = 'DD'||random(1,99999)   /* choose random ddname            */\njunk = msg(off)\n\"ALLOC FILE(\"||ddnm1||\") UNIT(SYSALLDA) NEW TRACKS SPACE(9,9) DELETE\",\n      \" REUSE LRECL(100) RECFM(F B) BLKSIZE(3200)\"\n\"ALLOC FILE(\"||ddnm2||\") UNIT(SYSALLDA) NEW TRACKS SPACE(1,1) DELETE\",\n      \" REUSE LRECL(100) RECFM(F B) BLKSIZE(3200) DIR(1)\",\n      \" DA('\"||prefix||\".REXXMEM.\" ||ddnm2|| \".ISPPLIB')\"\njunk = msg(on)\nNewstack\n/*************************/\n/* REXXMEMP Panel source */\n/*************************/\nIf Substr(ZENVIR,6,1) >= 4 then\n  Queue \")PANEL KEYLIST(ISRSPBC,ISR)\"\nQueue \")ATTR\"\nQueue \"  _ TYPE(INPUT)   INTENS(HIGH) COLOR(TURQ) CAPS(OFF)\" ,\n      \"FORMAT(&MIXED)\"\nQueue \"  | AREA(DYNAMIC) EXTEND(ON)   SCROLL(ON)\"\nQueue \"  + TYPE(TEXT)    INTENS(LOW)  COLOR(BLUE)\"\nQueue \"  @ TYPE(TEXT)    INTENS(LOW)  COLOR(TURQ)\"\nQueue \"  % TYPE(TEXT)    INTENS(HIGH) COLOR(GREEN)\"\nQueue \"  ! TYPE(OUTPUT)  INTENS(HIGH) COLOR(TURQ) PAD(-)\"\nQueue \" 01 TYPE(DATAOUT) INTENS(LOW)\"\nQueue \" 02 TYPE(DATAOUT) INTENS(HIGH)\"\nQueue \" 0B TYPE(DATAOUT) INTENS(HIGH) FORMAT(DBCS)\"\nQueue \" 0C TYPE(DATAOUT) INTENS(HIGH) FORMAT(EBCDIC)\"\nQueue \" 0D TYPE(DATAOUT) INTENS(HIGH) FORMAT(&MIXED)\"\nQueue \" 10 TYPE(DATAOUT) INTENS(LOW)  FORMAT(DBCS)\"\nQueue \" 11 TYPE(DATAOUT) INTENS(LOW)  FORMAT(EBCDIC)\"\nQueue \" 12 TYPE(DATAOUT) INTENS(LOW)  FORMAT(&MIXED)\"\nQueue \")BODY EXPAND(//)\"\nQueue \"%BROWSE  @&ZTITLE  / /  %Line!ZLINES  %Col!ZCOLUMS+\"\nQueue \"%Command ===>_ZCMD / /           %Scroll ===>_Z   +\"\nQueue \"|ZDATA ---------------/ /-------------------------|\"\nQueue \"|                     / /                         |\"\nQueue \"| --------------------/-/-------------------------|\"\nQueue \")INIT\"\nQueue \"  .HELP = ISR10000\"\nQueue \"  .ZVARS = 'ZSCBR'\"\nIf HELPDSP = 1 then ,\n  Queue \"  &ZTITLE = 'Mark''s MVS Utilities - REXXMEM  -- HELP --'\"\nElse ,\n  Queue \"  &ZTITLE = 'Mark''s MVS Utilities -\" ,\n        \"STOR(\" || D2x(R_ADDR) || \",\" || D2x(R_LEN) || \")'\"\nQueue \"  &MIXED = MIX\"\nQueue \"  IF (&ZPDMIX = N)\"\nQueue \"   &MIXED = EBCDIC\"\nQueue \"  VGET (ZSCBR) PROFILE\"\nQueue \"  IF (&ZSCBR = ' ')\"\nQueue \"   &ZSCBR = 'CSR'\"\nQueue \")REINIT\"\nQueue \"  REFRESH(ZCMD,ZSCBR,ZDATA,ZLINES,ZCOLUMS)\"\nQueue \")PROC\"\nQueue \"  &ZCURSOR = .CURSOR\"\nQueue \"  &ZCSROFF = .CSRPOS\"\nQueue \"  &ZLVLINE = LVLINE(ZDATA)\"\nQueue \"  VPUT (ZSCBR) PROFILE\"\nQueue \")END\"\nQueue \"\"\n/*                                    */\n\"ALLOC FILE(REXXMEMP) SHR REUSE\",\n      \" DA('\"||prefix||\".REXXMEM.\" ||ddnm2|| \".ISPPLIB(REXXMEMP)')\"\n\"EXECIO * DISKW REXXMEMP (FINIS\"\n\"FREE FI(REXXMEMP)\"\nDelstack\n\"EXECIO * DISKW\" ddnm1 \"(FINIS\"\nIf HELPDSP = 1 then zedsmsg = 'Help displayed'\n  Else zedsmsg = 'Storage displayed'\nzedlmsg = 'REXXMEM - Last updated on' ,\n           LASTUPD ||'. Written by' ,\n          'Mark Zelden. Mark''s MVS Utilities -' ,\n          'http://www.mzelden.com/mvsutil.html'\nAddress ISPEXEC \"LIBDEF ISPPLIB LIBRARY ID(\"ddnm2\") STACK\"\nAddress ISPEXEC \"SETMSG MSG(ISRZ000)\"  /* msg - no alarm    */\nAddress ISPEXEC \"LMINIT DATAID(TEMP) DDNAME(\"ddnm1\")\"\nAddress ISPEXEC \"BROWSE DATAID(\"temp\") PANEL(REXXMEMP)\"\nAddress ISPEXEC \"LMFREE DATAID(\"temp\")\"\nAddress ISPEXEC \"LIBDEF ISPPLIB\"\njunk = msg(off)\n\"FREE FI(\"ddnm1\")\"\n\"FREE FI(\"ddnm2\")\"\nExit\n\n\nTOKENIZE: Procedure expose DELIM. TOKEN. R_ADDR\n/*********************************************************************/\n/*   Routine to tokenize the input address                           */\n/*********************************************************************/\nParse upper arg ADDR_STR\nDELIM.1 = '?'\nDELIM.2 = '+'\nDELIM.3 = '-'\nDELIM.4 = '%'\nDELIM.5 = '.'\nDELIM.0 = 5\nREFCNT = 1\nDo while length(ADDR_STR) > 0\n  REF_FND = verify(ADDR_STR,'?+-%.','M')\n  If REF_FND > 0 then do\n    If REF_FND > 1 then do\n      TOKEN.REFCNT = Substr(ADDR_STR,1,REF_FND-1)\n      REFCNT = REFCNT + 1\n    End  /* if REF_FND > 1 ... */\n    TOKEN.REFCNT = Substr(ADDR_STR,REF_FND,1)\n    ADDR_STR = Substr(ADDR_STR,REF_FND+1)\n    REFCNT = REFCNT + 1\n  End          /* if REF_FND > 0 ... */\n  Else do\n    TOKEN.REFCNT = ADDR_STR\n    ADDR_STR = ''\n    REFCNT = REFCNT + 1\n  End\nEnd     /* do while ...*/\nTOKEN.0 = REFCNT - 1\nReturn\n\n\nRESOLVE_ADDR: Procedure expose DELIM TOKEN.\n/*********************************************************************/\n/*   Routine to resolve indirect addressing                          */\n/*********************************************************************/\nADDR = Arg(1)\n/* LINE = ADDR */\nLINE = \"x'\" || D2x(ADDR) || \"'\"\nDo RSLV=2 to TOKEN.0\n  If TOKEN.RSLV = '?' then do\n    RESULT = C2x(Storage(D2x(ADDR),4))\n    ADDR   = X2d(RESULT)\n    LINE = LINE||TOKEN.RSLV\n    Queue LINE \"=\" Right(D2x(ADDR),8,0)\n  End\n  If TOKEN.RSLV = '%' then do\n    RESULT = C2x(Storage(D2x(ADDR),4))\n    RESULT = Substr(RESULT,3,6)  /* 24-bit pointer */\n    ADDR   = X2d(RESULT)\n    LINE = LINE||TOKEN.RSLV\n    Queue LINE \"=\" Right(D2x(ADDR),8,0)\n  End\n  If TOKEN.RSLV = '+' then do\n    RSLV = RSLV + 1\n    ADDR = ADDR + X2d(TOKEN.RSLV)\n    LINE = LINE||\"+x'\"TOKEN.RSLV\"'\"\n     Queue LINE \"=\" Right(D2x(ADDR),8,0)\n  End\n  If TOKEN.RSLV = '-' then do\n    RSLV = RSLV + 1\n    ADDR = ADDR - X2d(TOKEN.RSLV)\n    LINE = LINE||\"-x'\"TOKEN.RSLV\"'\"\n    Queue LINE \"=\" Right(D2x(ADDR),8,0)\n  End\n  If TOKEN.RSLV = '.' then do\n /* LINE = LINE||\"\"TOKEN.RSLV\n    Queue LINE \"=\" Right(D2x(ADDR),8,0)  */\n  End\nEnd\nIf TOKEN.0 > 1 then do\n  /* Improve readability - add lines before storage display if       */\n  /* indirect storage references are used.                           */\n  Queue '---------------------------------------------------' || ,\n        '---------------------------'\n  Queue ' '\nEnd\nReturn ADDR\n\n\n/*********************************/\n/*  HELP SUB-ROUTINES            */\n/*********************************/\nHELP_INCL:\nReturn SIGL\nHELP_DISPLAY:\nQueue '==================='\nQueue '===   H E L P   ==='\nQueue '==================='\nDo hlp = help_start+1 to help_end-1 by 1\n  hline = Sourceline(hlp)\n  Queue hline\nEnd\nReturn\n\n\nSYNTAX:\nSay ERRORTEXT(rc)                              /* return code        */\nSay 'Please verify input parameters for valid hex characters' ,\n    'and proper indirect storage addressing.'\n\"Delstack\"                                     /* delete data stack  */\nExit 12\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SAS": {"ttr": 5893, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x94'\\x8f\\x00\\x94'\\x8f\\x19D\\x04;\\x04;\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-10-05T00:00:00", "modifydate": "1994-10-05T19:44:00", "lines": 1083, "newlines": 1083, "modlines": 0, "user": "SBGCSC"}, "text": "./ ADD NAME=APFPDUP  0100-94267-94267-1200-00058-00058-00000-CONYERS\n//MS01@APF JOB (MS01,228),'CONYERS - APFPDUP ',MSGCLASS=T,CLASS=A,\n//         NOTIFY=MS01VC1,MSGLEVEL=(1,1),TIME=(,14)\n//*********************************************************************\n//*   THIS PROCEDURE SCANS AN APF LIBRARY CONTENTS DATA BASE AND\n//*     PRODUCES VARIOUS ANALYSES USING THE SAS SOFTWARE PRODUCT\n//*********************************************************************\n//STEP01   EXEC SAS\n//APFPGMS  DD DISP=SHR,DSN=MS01.CONYERS.APFPGMS.DATA.WORK\nDATA APF  ;\n  INFILE APFPGMS OBS=99999 ;      /* Limit control for testing */\n  INPUT\n        @2    APFLIB $CHAR44.\n        @47   APFVOL $CHAR6.\n        @55   APFPGM $CHAR8.\n        @68   APFTTR $CHAR6.\n        @81   APFIND $CHAR2.\n        @90   APFAT1 $CHAR2.\n        @93   APFAT2 $CHAR2.\n        @101  APFSIZ $CHAR6.\n        @113  APFMAJ $CHAR8.\n        @125  APFACD $CHAR2.\n        @134  APFDBK $CHAR4.\n        @143  APFUDL $CHAR2.\n        @150  APFBIX $CHAR3.   ;\n  LABEL APFLIB = 'Library Name'\n        APFVOL = 'VOLSER'\n        APFPGM = 'Program Load Module Name'\n        APFTTR = 'Program DASD TTR Address'\n        APFIND = 'Program PDS2INDC Byte'\n        APFAT1 = 'Program PDS2ATR1 Byte'\n        APFAT2 = 'Program PDS2ATR2 Byte'\n        APFSIZ = 'Program PDS2STOR Field (module size)'\n        APFMAJ = 'Program Major Name if APFPGM is alias'\n        APFACD = 'Program PDSAPFAC Byte (AC=00,01,40)'\n        APFDBK = 'APFLIB Directory Block'\n        APFUDL = 'Directory Entry User Data Length'\n        APFBIX = 'Block Index to Next Directory Entry'      ;\n  TITLE1 \"APF Library Contents Analysis\" ;\n  PROC SORT NODUPS ;\n    BY APFPGM APFLIB ;\n  PROC FREQ ORDER=FREQ;\n    TABLES APFPGM / OUT=SUMOUT NOPERCENT NOPRINT ;\n    TITLE2 \"Duplicate Program Names\" ;\nDATA FREQOUT ;\n  SET SUMOUT ;\n  IF COUNT > 1 ;\n  PROC PRINT ;\n    VAR APFPGM COUNT ;\n    SUM COUNT ;\n  PROC SORT ;\n    BY APFPGM ;\nDATA MATCHUP ;\n  MERGE APF FREQOUT(IN=F) ;\n  BY APFPGM ;\n  IF F ;\n  PROC PRINT ;\n    VAR APFPGM APFSIZ APFACD APFMAJ APFLIB APFVOL ;\n   BY APFPGM ;\n./ ADD NAME=APFPGMS  0100-94267-94267-1200-00061-00061-00000-CONYERS\n//MS01@APF JOB (MS01,228),'CONYERS - APFPGMS ',MSGCLASS=T,CLASS=A,\n//         NOTIFY=MS01VC1,MSGLEVEL=(1,1),TIME=(,14)\n//*********************************************************************\n//*   THIS PROCEDURE SCANS AN APF LIBRARY CONTENTS DATA BASE AND\n//*     PRODUCES VARIOUS ANALYSES USING THE SAS SOFTWARE PRODUCT\n//*********************************************************************\n//STEP01   EXEC SAS\n//APFPGMS  DD DISP=SHR,DSN=MS01.CONYERS.APFPGMS.DATA.WORK\nDATA APF  ;\n  INFILE APFPGMS OBS=99999 ;      /* Limit control for testing */\n  INPUT\n        @2    APFLIB $CHAR44.\n        @47   APFVOL $CHAR6.\n        @55   APFPGM $CHAR8.\n        @68   APFTTR $CHAR6.\n        @81   APFIND $CHAR2.\n        @90   APFAT1 $CHAR2.\n        @93   APFAT2 $CHAR2.\n        @101  APFSIZ $CHAR6.\n        @113  APFMAJ $CHAR8.\n        @125  APFACD $CHAR2.\n        @134  APFDBK $CHAR4.\n        @143  APFUDL $CHAR2.\n        @150  APFBIX $CHAR3.   ;\n  LABEL APFLIB = 'Library Name'\n        APFVOL = 'VOLSER'\n        APFPGM = 'Program Load Module Name'\n        APFTTR = 'Program DASD TTR Address'\n        APFIND = 'Program PDS2INDC Byte'\n        APFAT1 = 'Program PDS2ATR1 Byte'\n        APFAT2 = 'Program PDS2ATR2 Byte'\n        APFSIZ = 'Program PDS2STOR Field (module size)'\n        APFMAJ = 'Program Major Name if APFPGM is alias'\n        APFACD = 'Program PDSAPFAC Byte (AC=00,01,40)'\n        APFDBK = 'APFLIB Directory Block'\n        APFUDL = 'Directory Entry User Data Length'\n        APFBIX = 'Block Index to Next Directory Entry'      ;\n  TITLE1 \"APF Library Contents Analysis\" ;\n  PROC FREQ ;\n    TABLES APFACD ;\n    TITLE2 \"Authorization (AC) Profile\" ;\nDATA ALIASES ;\n  SET APF ;\n  IF APFMAJ NE '        ' ;\n  PROC SORT NODUPS ;\n    BY APFPGM APFLIB ;\n  PROC PRINT ;\n    VAR APFPGM APFMAJ APFSIZ APFACD APFLIB APFVOL ;\n    TITLE2 \"Alias Report by Program Name (Alias)\" ;\n  PROC SORT NODUPS ;\n    BY APFMAJ APFPGM APFLIB;\n  PROC PRINT ;\n    VAR APFMAJ APFPGM APFSIZ APFACD APFLIB APFVOL ;\n    TITLE2 \"Alias Report by Program Name (Major)\" ;\nDATA ALLPGMS ;\n  SET APF ;\n  PROC SORT NODUPS ;\n    BY APFPGM APFLIB ;\n  PROC PRINT ;\n    VAR APFPGM APFMAJ APFSIZ APFACD APFLIB APFVOL ;\n    TITLE2 \"Detail Report by Program\" ;\n./ ADD NAME=ESRLIST  0100-94267-94267-1200-00046-00046-00000-CONYERS\n//MS01@ESR JOB (MS01,228),'CONYERS - ESRLIST ',MSGCLASS=T,CLASS=A,\n//         NOTIFY=MS01VC1,MSGLEVEL=(1,1),TIME=(,14)\n//*********************************************************************\n//*   THIS PROCEDURE SCANS AN ESR TABLE CONTENTS DATA BASE AND\n//*     PRODUCES VARIOUS ANALYSES USING THE SAS SOFTWARE PRODUCT\n//*********************************************************************\n//STEP01   EXEC SAS\n//ESRS     DD DISP=SHR,DSN=MS01.CONYERS.ESRS.DATA.WORK\nDATA ESRLIST ;\n  INFILE ESRS OBS=99999 ;     /* Limit control for testing */\n  INPUT\n        @2    ESRLIB  $CHAR44.\n        @47   ESRNUM  $CHAR6.\n        @59   SVCNUM  $CHAR6.\n        @76   ESRTYPE $CHAR3.\n        @80   ESREPA  $CHAR8.\n        @89   ESRLOC  $CHAR5.\n        @95   ESRSPEC $CHAR3.   ;\n  LABEL ESRLIB  = 'Library Name'\n        ESRNUM  = 'ESR Number'\n        SVCNUM  = 'SVC Number'\n        ESRTYPE = 'Type (1-4,6)'\n        ESREPA  = 'Entry Address'\n        ESRLOC  = 'Entry Location'\n        ESRSPEC = 'Special (APF)'    ;\n  TITLE1 \"ESR Tables Contents Analysis\" ;\n ********************************************************************;\n /* Generate a comment if location exception detected              */\n  COMMENT = '                    ' ;\n  IF ESRTYPE = '1  ' AND ESRLOC \u00ac= 'NUC'\n     THEN COMMENT = 'TYPE 1   NOT NUC' ;\n  IF ESRTYPE = '2  ' AND ESRLOC \u00ac= 'NUC'\n     THEN COMMENT = 'TYPE 2   NOT NUC' ;\n  IF ESRTYPE = '6  ' AND ESRLOC \u00ac= 'NUC'\n     THEN COMMENT = 'TYPE 6   NOT NUC' ;\n  IF ESRTYPE = '3/4' AND (ESRLOC \u00ac= 'PLPA' AND ESRLOC \u00ac= 'EPLPA')\n     THEN COMMENT = 'TYPE 3/4 NOT PLPA' ;\n ********************************************************************;\n  PROC FREQ ;\n    TABLES ESRTYPE ESRLOC ESRSPEC COMMENT ;\n    TITLE2 \"ESR Tables Entry Counts\" ;\n  PROC SORT NODUPS ;\n    BY SVCNUM ESRNUM ;\n  PROC PRINT ;\n    VAR SVCNUM ESRNUM ESRSPEC ESRTYPE ESREPA ESRLOC COMMENT ;\n    TITLE2 \"Detail Report by ESR Table Entry\" ;\n./ ADD NAME=ESRMATCH 0100-94267-94267-1200-00129-00129-00000-CONYERS\n//MS01@ESR JOB (MS01,228),'CONYERS - ESRMATCH',MSGCLASS=T,CLASS=A,\n//         NOTIFY=MS01VC1,MSGLEVEL=(1,1),TIME=(,14)\n//*********************************************************************\n//*   THIS PROCEDURE SCANS AN ESR TABLE OUTPUT DATA BASE AND\n//*     MATCHES ENTRY POINTS WITH LPAQ, PLPA, AND NUCMAP ENTRIES.\n//*********************************************************************\n//STEP01   EXEC SAS\n//ESRS     DD DISP=SHR,DSN=MS01.CONYERS.ESRS.DATA.WORK\n//LPAQMODS DD DISP=SHR,DSN=MS01.CONYERS.LPAQMODS.DATA.WORK\n//PLPAMODS DD DISP=SHR,DSN=MS01.CONYERS.PLPAMODS.DATA.WORK\n//NUCMAP   DD DISP=SHR,DSN=MS01.CONYERS.NUCMAP.DATA.WORK\n  TITLE1 \"ESR Table Contents Analysis\" ;\nDATA ESRLIST ;\n  INFILE ESRS OBS=99999 ;     /* Limit control for testing */\n  INPUT\n        @2    ESRLIB  $CHAR44.\n        @47   ESRNUM  $CHAR6.\n        @59   SVCNUM  $CHAR6.\n        @76   ESRTYPE $CHAR3.\n        @80   ESREPA  $CHAR8.\n        @89   ESRLOC  $CHAR5.\n        @95   ESRSPEC $CHAR3.   ;\n  LABEL ESRLIB  = 'Library Name'\n        ESRNUM  = 'ESR Number'\n        SVCNUM  = 'SVC Number'\n        ESRTYPE = 'Type (1-4,6)'\n        ESREPA  = 'Entry Address'\n        ESRLOC  = 'Entry Location'\n        ESRSPEC = 'Special (APF)'    ;\n  EPADDR = SUBSTR(ESREPA,2,7) ;\n  PROC SORT DATA=ESRLIST ; BY EPADDR ;\nDATA LPAQ ;\n  INFILE LPAQMODS OBS=99999 ;     /* Limit control for testing */\n  INPUT\n        @2    LPAQLIB $CHAR44.\n        @47   LPAQSEQ $CHAR4.\n        @52   LPAQPGM $CHAR8.\n        @61   LPAQEPA $CHAR8.\n        @70   LPAQLOC $CHAR5.\n        @80   LPAQUSE $CHAR5.\n        @89   LPAQACD $CHAR1.\n        @101  LPAQMAJ $CHAR8.   ;\n  LABEL LPAQLIB = 'Library Name'\n        LPAQSEQ = 'LPAQ Sequence Number'\n        LPAQPGM = 'Program Load Module Name'\n        LPAQEPA = 'Program Entry Point Address'\n        LPAQLOC = 'Program Location'\n        LPAQUSE = 'Program Use Count'\n        LPAQACD = 'Program AC Flag (AC=0,1)'\n        LPAQMAJ = 'Program Major Name if LPAQPGM is alias' ;\n  EPADDR = SUBSTR(LPAQEPA,2,7) ;\n  PROC SORT DATA=LPAQ ; BY EPADDR ;\n*********************************************************************;\nDATA PLPA ;\n  INFILE PLPAMODS OBS=99999 ;     /* Limit control for testing */\n  INPUT\n        @2   PLPALIB $CHAR44.\n        @47  PLPASEQ $CHAR8.\n        @56  PLPAPGM $CHAR8.\n        @65  PLPAEPA $CHAR8.\n        @74  PLPALOC $CHAR5.\n        @85  PLPASIZ $CHAR8.\n        @97  PLPAACD $CHAR1.\n        @109 PLPAMAJ $CHAR8.   ;\n  LABEL PLPALIB = 'Library Name'\n        PLPASEQ = 'PLPA Sequence Number'\n        PLPAPGM = 'Load Module Name'\n        PLPAEPA = 'Entry Point Address'\n        PLPALOC = 'Module Location'\n        PLPASIZ = 'Module Size'\n        PLPAACD = 'Authorization Code'\n        PLPAMAJ = 'Major Name if PLPAPGM is Alias'   ;\n  EPADDR = SUBSTR(PLPAEPA,2,7) ;\n  PROC SORT DATA=PLPA ; BY EPADDR ;\n*********************************************************************;\nDATA NUCM ;\n  INFILE NUCMAP OBS=99999 ;     /* Limit control for testing */\n  INPUT\n        @2    NUCMSEQ  $CHAR8.\n        @11   NUCMEPN  $CHAR8.\n        @20   NUCMEPA  $CHAR8.\n        @31   NUCCSECT $CHAR1.\n        @37   NUCRSECT $CHAR1.\n        @42   NUCRMODE $CHAR3.\n        @48   NUCAMODE $CHAR3.\n        @53   NUCMLEN  $CHAR6.    ;\n  LABEL NUCMSEQ  = 'NUCMAP Sequence'\n        NUCMEPN  = 'Entry Name'\n        NUCMEPA  = 'Entry Point Address'\n        NUCCSECT = 'CSECT Flag'\n        NUCRSECT = 'RSECT Flag'\n        NUCRMODE = 'RMODE'\n        NUCAMODE = 'AMODE'\n        NUCMLEN  = 'Entry Length'        ;\n  EPADDR = SUBSTR(NUCMEPA,2,7) ;\n  PROC SORT DATA=NUCM ; BY EPADDR ;\n*********************************************************************;\nDATA ESR_ALL ;\n  MERGE ESRLIST(IN=ESRLIST) LPAQ(IN=LPAQ) PLPA(IN=PLPA) NUCM(IN=NUCM);\n    BY EPADDR ;\n  IN_E=ESRLIST ; IN_L=LPAQ ; IN_P=PLPA ; IN_N=NUCM ; /* debug */\n  IF ESRLIST ;\n  PROC SORT DATA=ESR_ALL ; BY SVCNUM ESRNUM ;\n  PROC PRINT ;\n    VAR SVCNUM ESRNUM ESRTYPE ESREPA ESRLOC ESRSPEC\n        LPAQPGM PLPAPGM NUCMEPN ;\n    BY SVCNUM ;\n    TITLE2 \"ESRs Matched with LPAQ, PLPA, and NUCMAP\" ;\n*********************************************************************;\nDATA ESR_ERR ;\n  SET ESR_ALL ;\n  IF IN_E AND NUCMEPN = 'IGXERROR' ;\n  PROC SORT DATA=ESR_ERR ; BY SVCNUM ESRNUM ;\n  PROC PRINT ;\n    VAR SVCNUM ESRNUM ESRTYPE ESREPA ESRLOC ESRSPEC\n        LPAQPGM PLPAPGM NUCMEPN ;\n    TITLE2 \"ESRs Matched with LPAQ, PLPA, and NUCMAP\" ;\n    TITLE3 \"ESRs Pointing to Nucleus Error Routine\" ;\n*********************************************************************;\nDATA ESR_MISS ;\n  SET ESR_ALL ;\n  IF IN_E\n       AND NOT IN_L AND NOT IN_P AND NOT IN_N ;\n  PROC SORT DATA=ESR_MISS ; BY SVCNUM ESRNUM ;\n  PROC PRINT ;\n    VAR SVCNUM ESRNUM ESRTYPE ESREPA ESRLOC ESRSPEC\n        LPAQPGM PLPAPGM NUCMEPN ;\n    TITLE2 \"ESRs NOT Matched with LPAQ, PLPA, and NUCMAP\" ;\n    TITLE3 \"Storage Residency Exceptions\" ;\n./ ADD NAME=LLTPDUP  0100-94267-94267-1200-00058-00058-00000-CONYERS\n//MS01@LLT JOB (MS01,228),'CONYERS - LLTPDUP ',MSGCLASS=T,CLASS=A,\n//         NOTIFY=MS01VC1,MSGLEVEL=(1,1),TIME=(,14)\n//*********************************************************************\n//*   THIS PROCEDURE SCANS A LINKLIST LIBRARY CONTENTS DATA BASE AND\n//*     PRODUCES VARIOUS ANALYSES USING THE SAS SOFTWARE PRODUCT\n//*********************************************************************\n//STEP01   EXEC SAS\n//LLTPGMS  DD DISP=SHR,DSN=MS01.CONYERS.LLTPGMS.DATA.WORK\nDATA LLT  ;\n  INFILE LLTPGMS OBS=99999 ;      /* Limit control for testing */\n  INPUT\n        @2    LLTLIB $CHAR44.\n        @47   LLTSEQ $CHAR3.\n        @52   LLTPGM $CHAR8.\n        @65   LLTTTR $CHAR6.\n        @78   LLTIND $CHAR2.\n        @87   LLTAT1 $CHAR2.\n        @90   LLTAT2 $CHAR2.\n        @98   LLTSIZ $CHAR6.\n        @110  LLTMAJ $CHAR8.\n        @122  LLTACD $CHAR2.\n        @131  LLTDBK $CHAR4.\n        @140  LLTUDL $CHAR2.\n        @147  LLTBIX $CHAR3.   ;\n  LABEL LLTLIB = 'Library Name'\n        LLTSEQ = 'LLT Sequence Number'\n        LLTPGM = 'Program Load Module Name'\n        LLTTTR = 'Program DASD TTR Address'\n        LLTIND = 'Program PDS2INDC Byte'\n        LLTAT1 = 'Program PDS2ATR1 Byte'\n        LLTAT2 = 'Program PDS2ATR2 Byte'\n        LLTSIZ = 'Program PDS2STOR Field (module size)'\n        LLTMAJ = 'Program Major Name if LLTPGM is alias'\n        LLTACD = 'Program PDSLLTAC Byte (AC=00,01,40)'\n        LLTDBK = 'LLTLIB Directory Block'\n        LLTUDL = 'Directory Entry User Data Length'\n        LLTBIX = 'Block Index to Next Directory Entry'      ;\n  TITLE1 \"LLT Library Contents Analysis\" ;\n  PROC SORT NODUPS ;\n    BY LLTPGM LLTSEQ LLTLIB ;\n  PROC FREQ ORDER=FREQ;\n    TABLES LLTPGM / OUT=SUMOUT NOPERCENT NOPRINT ;\n    TITLE2 \"Duplicate Program Names\" ;\nDATA FREQOUT ;\n  SET SUMOUT ;\n  IF COUNT > 1 ;\n  PROC PRINT ;\n    VAR LLTPGM COUNT ;\n    SUM COUNT ;\n  PROC SORT ;\n    BY LLTPGM ;\nDATA MATCHUP ;\n  MERGE LLT FREQOUT(IN=F) ;\n  BY LLTPGM ;\n  IF F ;\n  PROC PRINT ;\n    VAR LLTPGM LLTSIZ LLTACD LLTMAJ LLTLIB LLTSEQ ;\n   BY LLTPGM ;\n./ ADD NAME=LLTPGMS  0100-94267-94267-1200-00061-00061-00000-CONYERS\n//MS01@LLT JOB (MS01,228),'CONYERS - LLTPGMS ',MSGCLASS=T,CLASS=A,\n//         NOTIFY=MS01VC1,MSGLEVEL=(1,1),TIME=(,14)\n//*********************************************************************\n//*   THIS PROCEDURE SCANS A LINKLIST LIBRARY CONTENTS DATA BASE AND\n//*     PRODUCES VARIOUS ANALYSES USING THE SAS SOFTWARE PRODUCT\n//*********************************************************************\n//STEP01   EXEC SAS\n//LLTPGMS  DD DISP=SHR,DSN=MS01.CONYERS.LLTPGMS.DATA.WORK\nDATA LLT  ;\n  INFILE LLTPGMS OBS=99999 ;      /* Limit control for testing */\n  INPUT\n        @2    LLTLIB $CHAR44.\n        @47   LLTSEQ $CHAR3.\n        @52   LLTPGM $CHAR8.\n        @65   LLTTTR $CHAR6.\n        @78   LLTIND $CHAR2.\n        @87   LLTAT1 $CHAR2.\n        @90   LLTAT2 $CHAR2.\n        @98   LLTSIZ $CHAR6.\n        @110  LLTMAJ $CHAR8.\n        @122  LLTACD $CHAR2.\n        @131  LLTDBK $CHAR4.\n        @140  LLTUDL $CHAR2.\n        @147  LLTBIX $CHAR3.   ;\n  LABEL LLTLIB = 'Library Name'\n        LLTSEQ = 'LLT Sequence Number'\n        LLTPGM = 'Program Load Module Name'\n        LLTTTR = 'Program DASD TTR Address'\n        LLTIND = 'Program PDS2INDC Byte'\n        LLTAT1 = 'Program PDS2ATR1 Byte'\n        LLTAT2 = 'Program PDS2ATR2 Byte'\n        LLTSIZ = 'Program PDS2STOR Field (module size)'\n        LLTMAJ = 'Program Major Name if LLTPGM is alias'\n        LLTACD = 'Program PDSLLTAC Byte (AC=00,01,40)'\n        LLTDBK = 'LLTLIB Directory Block'\n        LLTUDL = 'Directory Entry User Data Length'\n        LLTBIX = 'Block Index to Next Directory Entry'      ;\n  TITLE1 \"LLT Library Contents Analysis\" ;\n  PROC FREQ ;\n    TABLES LLTACD ;\n    TITLE2 \"Authorization (AC) Profile\" ;\nDATA ALIASES ;\n  SET LLT ;\n  IF LLTMAJ NE '        ' ;\n  PROC SORT NODUPS ;\n    BY LLTPGM LLTSEQ ;\n  PROC PRINT ;\n    VAR LLTPGM LLTMAJ LLTSIZ LLTACD LLTLIB LLTSEQ ;\n    TITLE2 \"Alias Report by Program Name (Alias)\" ;\n  PROC SORT NODUPS ;\n    BY LLTMAJ LLTPGM LLTLIB;\n  PROC PRINT ;\n    VAR LLTMAJ LLTPGM LLTSIZ LLTACD LLTLIB LLTSEQ ;\n    TITLE2 \"Alias Report by Program Name (Major)\" ;\nDATA ALLPGMS ;\n  SET LLT ;\n  PROC SORT NODUPS ;\n    BY LLTPGM LLTSEQ ;\n  PROC PRINT ;\n    VAR LLTPGM LLTMAJ LLTSIZ LLTACD LLTLIB LLTSEQ ;\n    TITLE2 \"Detail Report by Program\" ;\n./ ADD NAME=LPAPDUP  0100-94267-94267-1200-00058-00058-00000-CONYERS\n//MS01@LPA JOB (MS01,228),'CONYERS - LPAPDUP ',MSGCLASS=T,CLASS=A,\n//         NOTIFY=MS01VC1,MSGLEVEL=(1,1),TIME=(,14)\n//*********************************************************************\n//*   THIS PROCEDURE SCANS A LPAT LIBRARY CONTENTS DATA BASE AND\n//*     PRODUCES VARIOUS ANALYSES USING THE SAS SOFTWARE PRODUCT\n//*********************************************************************\n//STEP01   EXEC SAS\n//LPAPGMS  DD DISP=SHR,DSN=MS01.CONYERS.LPAPGMS.DATA.WORK\nDATA LPA  ;\n  INFILE LPAPGMS OBS=99999 ;      /* Limit control for testing */\n  INPUT\n        @2    LPALIB $CHAR44.\n        @47   LPASEQ $CHAR3.\n        @52   LPAPGM $CHAR8.\n        @65   LPATTR $CHAR6.\n        @78   LPAIND $CHAR2.\n        @87   LPAAT1 $CHAR2.\n        @90   LPAAT2 $CHAR2.\n        @98   LPASIZ $CHAR6.\n        @110  LPAMAJ $CHAR8.\n        @122  LPAACD $CHAR2.\n        @131  LPADBK $CHAR4.\n        @140  LPAUDL $CHAR2.\n        @147  LPABIX $CHAR3.   ;\n  LABEL LPALIB = 'Library Name'\n        LPASEQ = 'LPA Sequence Number'\n        LPAPGM = 'Program Load Module Name'\n        LPATTR = 'Program DASD TTR Address'\n        LPAIND = 'Program PDS2INDC Byte'\n        LPAAT1 = 'Program PDS2ATR1 Byte'\n        LPAAT2 = 'Program PDS2ATR2 Byte'\n        LPASIZ = 'Program PDS2STOR Field (module size)'\n        LPAMAJ = 'Program Major Name if LPAPGM is alias'\n        LPAACD = 'Program PDSLPAAC Byte (AC=00,01,40)'\n        LPADBK = 'LPALIB Directory Block'\n        LPAUDL = 'Directory Entry User Data Length'\n        LPABIX = 'Block Index to Next Directory Entry'      ;\n  TITLE1 \"LPA Library Contents Analysis\" ;\n  PROC SORT NODUPS ;\n    BY LPAPGM LPASEQ LPALIB ;\n  PROC FREQ ORDER=FREQ;\n    TABLES LPAPGM / OUT=SUMOUT NOPERCENT NOPRINT ;\n    TITLE2 \"Duplicate Program Names\" ;\nDATA FREQOUT ;\n  SET SUMOUT ;\n  IF COUNT > 1 ;\n  PROC PRINT ;\n    VAR LPAPGM COUNT ;\n    SUM COUNT ;\n  PROC SORT ;\n    BY LPAPGM ;\nDATA MATCHUP ;\n  MERGE LPA FREQOUT(IN=F) ;\n  BY LPAPGM ;\n  IF F ;\n  PROC PRINT ;\n    VAR LPAPGM LPASIZ LPAACD LPAMAJ LPALIB LPASEQ ;\n   BY LPAPGM ;\n./ ADD NAME=LPAPGMS  0100-94267-94267-1200-00061-00061-00000-CONYERS\n//MS01@LPA JOB (MS01,228),'CONYERS - LPAPGMS ',MSGCLASS=T,CLASS=A,\n//         NOTIFY=MS01VC1,MSGLEVEL=(1,1),TIME=(,14)\n//*********************************************************************\n//*   THIS PROCEDURE SCANS A LPAT LIBRARY CONTENTS DATA BASE AND\n//*     PRODUCES VARIOUS ANALYSES USING THE SAS SOFTWARE PRODUCT\n//*********************************************************************\n//STEP01   EXEC SAS\n//LPAPGMS  DD DISP=SHR,DSN=MS01.CONYERS.LPAPGMS.DATA.WORK\nDATA LPA  ;\n  INFILE LPAPGMS OBS=99999 ;      /* Limit control for testing */\n  INPUT\n        @2    LPALIB $CHAR44.\n        @47   LPASEQ $CHAR3.\n        @52   LPAPGM $CHAR8.\n        @65   LPATTR $CHAR6.\n        @78   LPAIND $CHAR2.\n        @87   LPAAT1 $CHAR2.\n        @90   LPAAT2 $CHAR2.\n        @98   LPASIZ $CHAR6.\n        @110  LPAMAJ $CHAR8.\n        @122  LPAACD $CHAR2.\n        @131  LPADBK $CHAR4.\n        @140  LPAUDL $CHAR2.\n        @147  LPABIX $CHAR3.   ;\n  LABEL LPALIB = 'Library Name'\n        LPASEQ = 'LPA Sequence Number'\n        LPAPGM = 'Program Load Module Name'\n        LPATTR = 'Program DASD TTR Address'\n        LPAIND = 'Program PDS2INDC Byte'\n        LPAAT1 = 'Program PDS2ATR1 Byte'\n        LPAAT2 = 'Program PDS2ATR2 Byte'\n        LPASIZ = 'Program PDS2STOR Field (module size)'\n        LPAMAJ = 'Program Major Name if LPAPGM is alias'\n        LPAACD = 'Program PDSLPAAC Byte (AC=00,01,40)'\n        LPADBK = 'LPALIB Directory Block'\n        LPAUDL = 'Directory Entry User Data Length'\n        LPABIX = 'Block Index to Next Directory Entry'      ;\n  TITLE1 \"LPA Library Contents Analysis\" ;\n  PROC FREQ ;\n    TABLES LPAACD ;\n    TITLE2 \"Authorization (AC) Profile\" ;\nDATA ALIASES ;\n  SET LPA ;\n  IF LPAMAJ NE '        ' ;\n  PROC SORT NODUPS ;\n    BY LPAPGM LPASEQ ;\n  PROC PRINT ;\n    VAR LPAPGM LPAMAJ LPASIZ LPAACD LPALIB LPASEQ ;\n    TITLE2 \"Alias Report by Program Name (Alias)\" ;\n  PROC SORT NODUPS ;\n    BY LPAMAJ LPAPGM LPALIB;\n  PROC PRINT ;\n    VAR LPAMAJ LPAPGM LPASIZ LPAACD LPALIB LPASEQ ;\n    TITLE2 \"Alias Report by Program Name (Major)\" ;\nDATA ALLPGMS ;\n  SET LPA ;\n  PROC SORT NODUPS ;\n    BY LPAPGM LPASEQ ;\n  PROC PRINT ;\n    VAR LPAPGM LPAMAJ LPASIZ LPAACD LPALIB LPASEQ ;\n    TITLE2 \"Detail Report by Program\" ;\n./ ADD NAME=LPAQMODS 0100-94267-94267-1200-00089-00089-00000-CONYERS\n//MS01@LPQ JOB (MS01,228),'CONYERS - LPAQMODS',MSGCLASS=T,CLASS=A,\n//         NOTIFY=MS01VC1,MSGLEVEL=(1,1),TIME=(,14)\n//*********************************************************************\n//*   THIS PROCEDURE SCANS A LPAQ CDE CHAIN CONTENTS DATA BASE AND\n//*     PRODUCES VARIOUS ANALYSES USING THE SAS SOFTWARE PRODUCT\n//*********************************************************************\n//STEP01   EXEC SAS\n//LPAQMODS DD DISP=SHR,DSN=MS01.CONYERS.LPAQMODS.DATA.WORK\nDATA LPAQ ;\n  INFILE LPAQMODS OBS=99999 ;     /* Limit control for testing */\n  INPUT\n        @2    LPAQLIB $CHAR44.\n        @47   LPAQSEQ $CHAR4.\n        @52   LPAQPGM $CHAR8.\n        @61   LPAQEPA $CHAR8.\n        @70   LPAQLOC $CHAR5.\n        @80   LPAQUSE $CHAR5.\n        @89   LPAQACD $CHAR1.\n        @101  LPAQMAJ $CHAR8.   ;\n  LABEL LPAQLIB = 'Library Name'\n        LPAQSEQ = 'LPAQ Sequence Number'\n        LPAQPGM = 'Program Load Module Name'\n        LPAQEPA = 'Program Entry Point Address'\n        LPAQLOC = 'Program Location'\n        LPAQUSE = 'Program Use Count'\n        LPAQACD = 'Program AC Flag (AC=0,1)'\n        LPAQMAJ = 'Program Major Name if LPAQPGM is alias' ;\n  TITLE1 \"LPAQ CDE Chain Contents Analysis\" ;\n ********************************************************************;\n  PROC SORT NODUPS ;\n    BY LPAQLIB LPAQPGM ;\n  PROC PRINT ;\n    VAR LPAQPGM LPAQSEQ LPAQEPA LPAQLOC LPAQACD LPAQMAJ ;\n    BY LPAQLIB ; PAGEBY LPAQLIB ;\n    TITLE2 \"Detail Report by Library\" ;\n  PROC SORT NODUPS ;\n    BY LPAQLOC LPAQPGM ;\n  PROC PRINT ;\n    VAR LPAQLOC LPAQPGM LPAQEPA LPAQACD LPAQMAJ ;\n    BY LPAQLOC ; PAGEBY LPAQLOC ;\n    TITLE2 \"Detail Report by Storage Location\" ;\n  PROC SORT NODUPS ;\n    BY LPAQLOC LPAQEPA LPAQPGM ;\n  PROC PRINT ;\n    VAR LPAQLOC LPAQEPA LPAQPGM LPAQACD LPAQMAJ ;\n    BY LPAQLOC ; PAGEBY LPAQLOC ;\n    TITLE2 \"Detail Report by Entry Point Address\" ;\n  PROC SORT NODUPS ;\n    BY LPAQSEQ ;\n  PROC PRINT ;\n    VAR LPAQSEQ LPAQPGM LPAQLOC LPAQEPA LPAQACD LPAQMAJ LPAQLIB ;\n    TITLE2 \"Detail Report by CDE Chain Order\" ;\n  PROC FREQ ;\n    TABLES LPAQACD ;\n    TITLE2 \"Authorization (AC) Profile\" ;\nDATA ALIASES ;\n  SET LPAQ ;\n  IF LPAQMAJ NE '        ' ;\n  PROC SORT NODUPS ;\n    BY LPAQPGM LPAQSEQ ;\n  PROC PRINT ;\n    VAR LPAQPGM LPAQMAJ LPAQEPA LPAQACD LPAQLIB LPAQSEQ ;\n    TITLE2 \"Alias Report by Program Name (Alias)\" ;\n  PROC SORT NODUPS ;\n    BY LPAQMAJ LPAQPGM LPAQLIB;\n  PROC PRINT ;\n    VAR LPAQMAJ LPAQPGM LPAQEPA LPAQACD LPAQLIB LPAQSEQ ;\n    TITLE2 \"Alias Report by Program Name (Major)\" ;\n ********************************************************************;\n PROC SORT NODUPS DATA=LPAQ ;   /* BRING BACK LPAQ WORKING SET HERE */\n   BY LPAQPGM LPAQSEQ LPAQLIB ;\n PROC FREQ ORDER=FREQ;\n   TABLES LPAQPGM / OUT=SUMOUT NOPERCENT NOPRINT ;\n   TITLE2 \"Duplicate Program Names\" ;\n DATA FREQOUT ;\n   SET SUMOUT ;\n   IF COUNT > 1 ;\n   PROC PRINT ;\n     VAR LPAQPGM COUNT ;\n     SUM COUNT ;\n   PROC SORT ;\n     BY LPAQPGM ;\n DATA MATCHUP ;\n   MERGE LPAQ FREQOUT(IN=F) ;\n   BY LPAQPGM ;\n   IF F ;\n   PROC PRINT ;\n     VAR LPAQPGM LPAQACD LPAQMAJ LPAQSEQ LPAQEPA LPAQLOC ;\n     BY LPAQPGM ;\n./ ADD NAME=NUCMLIST 0100-94267-94267-1200-00044-00044-00000-CONYERS\n//MS01@NUC JOB (MS01,228),'CONYERS - NUCMLIST',MSGCLASS=T,CLASS=A,\n//         NOTIFY=MS01VC1,MSGLEVEL=(1,1),TIME=(,14)\n//*********************************************************************\n//*   THIS PROCEDURE SCANS A NUCLEUS MAP TABLE DATA BASE AND\n//*     PRODUCES VARIOUS ANALYSES USING THE SAS SOFTWARE PRODUCT\n//*********************************************************************\n//STEP01   EXEC SAS\n//NUCMAP   DD DISP=SHR,DSN=MS01.CONYERS.NUCMAP.DATA.WORK\nDATA NUCMLIST ;\n  INFILE NUCMAP OBS=99999 ;     /* Limit control for testing */\n  INPUT\n        @2    NUCMSEQ  $CHAR8.\n        @11   NUCMEPN  $CHAR8.\n        @20   NUCMEPA  $CHAR8.\n        @31   NUCCSECT $CHAR1.\n        @37   NUCRSECT $CHAR1.\n        @42   NUCRMODE $CHAR3.\n        @48   NUCAMODE $CHAR3.\n        @53   NUCMLEN  $CHAR6.    ;\n  LABEL NUCMSEQ  = 'NUCMAP Sequence'\n        NUCMEPN  = 'Entry Name'\n        NUCMEPA  = 'Entry Point Address'\n        NUCCSECT = 'CSECT Flag'\n        NUCRSECT = 'RSECT Flag'\n        NUCRMODE = 'RMODE'\n        NUCAMODE = 'AMODE'\n        NUCMLEN  = 'Entry Length'        ;\n  TITLE1 \"Nucleus Map Table Contents Analysis\" ;\n ********************************************************************;\n  PROC FREQ ;\n    TABLES NUCCSECT NUCRSECT NUCRMODE NUCAMODE ;\n    TITLE2 \"Table Entry Counts\" ;\n  PROC SORT NODUPS ;\n    BY NUCMEPN ;\n  PROC PRINT ;\n    VAR NUCMEPN NUCMEPA NUCMLEN NUCCSECT NUCRSECT\n        NUCRMODE NUCAMODE NUCMSEQ ;\n    TITLE2 \"Detail Report by Table Entry Name\" ;\n  PROC SORT NODUPS ;\n    BY NUCMSEQ ;\n  PROC PRINT ;\n    VAR NUCMEPN NUCMEPA NUCMLEN NUCCSECT NUCRSECT\n        NUCRMODE NUCAMODE NUCMSEQ ;\n    TITLE2 \"Detail Report by Table Entry Address\" ;\n./ ADD NAME=PCLIST   0100-94267-94267-1200-00043-00043-00000-CONYERS\n//MS01@PC  JOB (MS01,228),'CONYERS - PCLIST  ',MSGCLASS=T,CLASS=A,\n//         NOTIFY=MS01VC1,MSGLEVEL=(1,1),TIME=(,14)\n//*********************************************************************\n//*   THIS PROCEDURE SCANS A PCDATA SNAP OUTPUT DATA BASE AND\n//*     PRODUCES VARIOUS ANALYSES USING THE SAS SOFTWARE PRODUCT\n//*********************************************************************\n//STEP01   EXEC SAS\n//PCAUTH   DD DISP=SHR,DSN=MS01.CONYERS.PCAUTH.DATA.WORK\nDATA PCLIST ;\n  INFILE PCAUTH OBS=99999 ;     /* Limit control for testing */\n  INPUT\n        @2    PCAULIB $CHAR44.\n        @47   PCNUM   $CHAR6.\n         @47  PCNUMLX $CHAR4.\n         @51  PCNUMEX $CHAR2.\n        @54   PCAKM   $CHAR4.\n        @59   PCEXAS  $CHAR4.\n        @64   PCEXASN $CHAR8.\n        @73   PCENAD  $CHAR8.\n        @82   PCENLOC $CHAR5.\n        @88   PCEXST  $CHAR1.\n        @90   PCEKM   $CHAR4.   ;\n  LABEL PCAULIB = 'Library Name'\n        PCNUM   = 'PC Number'\n        PCNUMLX = 'Linkage Index'\n        PCNUMEX = 'Entry Index'\n        PCAKM   = 'Auth Key Mask'\n        PCEXAS  = 'Exec ASID'\n        PCEXASN = 'Exec ASID Name'\n        PCENAD  = 'Entry Address'\n        PCENLOC = 'Entry Location'\n        PCEXST  = 'Exec State'\n        PCEKM   = 'Exec Key Mask'        ;\n  TITLE1 \"PCAUTH Table Contents Analysis\" ;\n ********************************************************************;\n  PROC FREQ ;\n    TABLES PCNUMLX PCAKM PCEXASN PCENLOC PCEXST PCEKM ;\n    TITLE2 \"PC Table Entry Counts\" ;\n  PROC SORT NODUPS ;\n    BY PCNUM ;\n  PROC PRINT ;\n    VAR PCNUM PCAKM PCEXAS PCEXASN PCENAD PCENLOC PCEXST PCEKM ;\n    TITLE2 \"Detail Report by PC Table Entry\" ;\n./ ADD NAME=PCMATCH  0100-94267-94267-1200-00145-00145-00000-CONYERS\n//MS01@PC  JOB (MS01,228),'CONYERS - PCMATCH ',MSGCLASS=T,CLASS=A,\n//         NOTIFY=MS01VC1,MSGLEVEL=(1,1),TIME=(,14)\n//*********************************************************************\n//*   THIS PROCEDURE SCANS A PCDATA SNAP OUTPUT DATA BASE AND\n//*     MATCHES ENTRY POINTS WITH LPAQ, PLPA, AND NUCMAP ENTRIES.\n//*********************************************************************\n//STEP01   EXEC SAS\n//PCAUTH   DD DISP=SHR,DSN=MS01.CONYERS.PCAUTH.DATA.WORK\n//LPAQMODS DD DISP=SHR,DSN=MS01.CONYERS.LPAQMODS.DATA.WORK\n//PLPAMODS DD DISP=SHR,DSN=MS01.CONYERS.PLPAMODS.DATA.WORK\n//NUCMAP   DD DISP=SHR,DSN=MS01.CONYERS.NUCMAP.DATA.WORK\n  TITLE1 \"PCAUTH Table Contents Analysis\" ;\nDATA PCLIST ;\n  INFILE PCAUTH OBS=99999 ;     /* Limit control for testing */\n  INPUT\n        @2    PCAULIB $CHAR44.\n        @47   PCNUM   $CHAR6.\n        @47   PCNUM_X $HEX6.       /* GET HEX VALUE FOR SORT */\n         @47  PCNUMLX $CHAR4.\n         @51  PCNUMEX $CHAR2.\n        @54   PCAKM   $CHAR4.\n        @59   PCEXAS  $CHAR4.\n        @64   PCEXASN $CHAR8.\n        @73   PCENAD  $CHAR8.\n        @82   PCENLOC $CHAR5.\n        @88   PCEXST  $CHAR1.\n        @90   PCEKM   $CHAR4.   ;\n  LABEL PCAULIB = 'Library Name'\n        PCNUM   = 'PC Number'\n        PCNUMLX = 'Linkage Index'\n        PCNUMEX = 'Entry Index'\n        PCAKM   = 'Auth Key Mask'\n        PCEXAS  = 'Exec ASID'\n        PCEXASN = 'Exec ASID Name'\n        PCENAD  = 'Entry Address'\n        PCENLOC = 'Entry Location'\n        PCEXST  = 'Exec State'\n        PCEKM   = 'Exec Key Mask'        ;\n  EPADDR = SUBSTR(PCENAD,2,7) ;\n  PROC SORT DATA=PCLIST ; BY EPADDR ;\nDATA LPAQ ;\n  INFILE LPAQMODS OBS=99999 ;     /* Limit control for testing */\n  INPUT\n        @2    LPAQLIB $CHAR44.\n        @47   LPAQSEQ $CHAR4.\n        @52   LPAQPGM $CHAR8.\n        @61   LPAQEPA $CHAR8.\n        @70   LPAQLOC $CHAR5.\n        @80   LPAQUSE $CHAR5.\n        @89   LPAQACD $CHAR1.\n        @101  LPAQMAJ $CHAR8.   ;\n  LABEL LPAQLIB = 'Library Name'\n        LPAQSEQ = 'LPAQ Sequence Number'\n        LPAQPGM = 'Program Load Module Name'\n        LPAQEPA = 'Program Entry Point Address'\n        LPAQLOC = 'Program Location'\n        LPAQUSE = 'Program Use Count'\n        LPAQACD = 'Program AC Flag (AC=0,1)'\n        LPAQMAJ = 'Program Major Name if LPAQPGM is alias' ;\n  EPADDR = SUBSTR(LPAQEPA,2,7) ;\n  PROC SORT DATA=LPAQ ; BY EPADDR ;\n*********************************************************************;\nDATA PLPA ;\n  INFILE PLPAMODS OBS=99999 ;     /* Limit control for testing */\n  INPUT\n        @2   PLPALIB $CHAR44.\n        @47  PLPASEQ $CHAR8.\n        @56  PLPAPGM $CHAR8.\n        @65  PLPAEPA $CHAR8.\n        @74  PLPALOC $CHAR5.\n        @85  PLPASIZ $CHAR8.\n        @97  PLPAACD $CHAR1.\n        @109 PLPAMAJ $CHAR8.   ;\n  LABEL PLPALIB = 'Library Name'\n        PLPASEQ = 'PLPA Sequence Number'\n        PLPAPGM = 'Load Module Name'\n        PLPAEPA = 'Entry Point Address'\n        PLPALOC = 'Module Location'\n        PLPASIZ = 'Module Size'\n        PLPAACD = 'Authorization Code'\n        PLPAMAJ = 'Major Name if PLPAPGM is Alias'   ;\n  EPADDR = SUBSTR(PLPAEPA,2,7) ;\n  PROC SORT DATA=PLPA ; BY EPADDR ;\n*********************************************************************;\nDATA NUCM ;\n  INFILE NUCMAP OBS=99999 ;     /* Limit control for testing */\n  INPUT\n        @2    NUCMSEQ  $CHAR8.\n        @11   NUCMEPN  $CHAR8.\n        @20   NUCMEPA  $CHAR8.\n        @31   NUCCSECT $CHAR1.\n        @37   NUCRSECT $CHAR1.\n        @42   NUCRMODE $CHAR3.\n        @48   NUCAMODE $CHAR3.\n        @53   NUCMLEN  $CHAR6.    ;\n  LABEL NUCMSEQ  = 'NUCMAP Sequence'\n        NUCMEPN  = 'Entry Name'\n        NUCMEPA  = 'Entry Point Address'\n        NUCCSECT = 'CSECT Flag'\n        NUCRSECT = 'RSECT Flag'\n        NUCRMODE = 'RMODE'\n        NUCAMODE = 'AMODE'\n        NUCMLEN  = 'Entry Length'        ;\n  EPADDR = SUBSTR(NUCMEPA,2,7) ;\n  PROC SORT DATA=NUCM ; BY EPADDR ;\n*********************************************************************;\nDATA PC_ALL ;\n  MERGE PCLIST(IN=PCLIST) LPAQ(IN=LPAQ) PLPA(IN=PLPA) NUCM(IN=NUCM) ;\n    BY EPADDR ;\n  IN_PC=PCLIST ; IN_L=LPAQ ; IN_P=PLPA ; IN_N=NUCM ; /* debug */\n  IF PCLIST ;\n  PROC SORT DATA=PC_ALL ; BY PCNUM_X ;\n  PROC PRINT ;\n    VAR PCNUM PCAKM PCEXASN PCENAD PCENLOC\n        LPAQPGM PLPAPGM NUCMEPN ;\n    TITLE2 \"PCs Matched with LPAQ, PLPA, and NUCMAP\" ;\n*********************************************************************;\nDATA PC_XABE ;\n  SET PC_ALL ;\n  IF IN_PC AND NUCMEPN = 'IEAVXABE' ;\n  PROC SORT DATA=PC_XABE ; BY PCNUM_X ;\n  PROC PRINT ;\n    VAR PCNUM PCAKM PCEXASN PCENAD PCENLOC\n        LPAQPGM PLPAPGM NUCMEPN ;\n    TITLE2 \"PCs Matched with LPAQ, PLPA, and NUCMAP\" ;\n    TITLE3 \"PCs Pointing to Nucleus Error Routine\" ;\n*********************************************************************;\nDATA PC_MISS ;\n  SET PC_ALL ;\n  LOCTEST = '    ' ;     /* Filter out PRIV, CSA, and SQA items */\n  IF PCENLOC =: 'NUC'   OR\n     PCENLOC =: 'MLPA'  OR\n     PCENLOC =: 'FLPA'  OR\n     PCENLOC =: 'PLPA'  OR\n     PCENLOC =: 'EMLPA' OR\n     PCENLOC =: 'EFLPA' OR\n     PCENLOC =: 'EPLPA' THEN LOCTEST = 'KEEP' ;\n  IF IN_PC\n       AND NOT IN_L AND NOT IN_P AND NOT IN_N AND LOCTEST = 'KEEP' ;\n  PROC SORT DATA=PC_MISS ; BY PCNUM_X ;\n  PROC PRINT ;\n    VAR PCNUM PCAKM PCEXASN PCENAD PCENLOC\n        LPAQPGM PLPAPGM NUCMEPN ;\n    TITLE2 \"PCs NOT Matched with LPAQ, PLPA, and NUCMAP\" ;\n    TITLE3 \"Storage Residency Exceptions\" ;\n./ ADD NAME=PLPAMODS 0100-94267-94267-1200-00036-00036-00000-CONYERS\n//MS01@PLP JOB (MS01,228),'CONYERS - PLPAMODS',MSGCLASS=T,CLASS=A,\n//         NOTIFY=MS01VC1,MSGLEVEL=(1,1),TIME=(,14)\n//*********************************************************************\n//*   THIS PROCEDURE SCANS A PLPA MODULE CONTENTS DATA BASE AND\n//*     PRODUCES VARIOUS ANALYSES USING THE SAS SOFTWARE PRODUCT\n//*********************************************************************\n//STEP01   EXEC SAS\n//PLPAMODS DD DISP=SHR,DSN=MS01.CONYERS.PLPAMODS.DATA.WORK\nDATA PLPA ;\n  INFILE PLPAMODS OBS=99999 ;      /* Limit control for testing */\n  INPUT\n        @2   PLPALIB $CHAR44.\n        @47  PLPASEQ $CHAR8.\n        @56  PLPAPGM $CHAR8.\n        @65  PLPAEPA $CHAR8.\n        @74  PLPALOC $CHAR5.\n        @85  PLPASIZ $CHAR8.\n        @97  PLPAACD $CHAR1.\n        @109 PLPAMAJ $CHAR8.   ;\n  LABEL PLPALIB = 'Library Name'\n        PLPASEQ = 'PLPA Sequence Number'\n        PLPAPGM = 'Load Module Name'\n        PLPAEPA = 'Entry Point Address'\n        PLPALOC = 'Module Location'\n        PLPASIZ = 'Module Size'\n        PLPAACD = 'Authorization Code'\n        PLPAMAJ = 'Major Name if PLPAPGM is Alias'   ;\n  TITLE1 \"PLPA Contents Analysis\" ;\n  PROC FREQ ;\n    TABLES PLPALOC PLPAACD ;\n    TITLE2 \"Location/Authorization Profile\" ;\n  PROC SORT NODUPS ;\n    BY PLPAPGM ;\n  PROC PRINT ;\n    VAR PLPAPGM PLPAEPA PLPALOC PLPASIZ PLPAACD PLPAMAJ ;\n    TITLE2 \"Detail Report by Program\" ;\n./ ADD NAME=SVCLIST  0100-94267-94267-1200-00053-00053-00000-CONYERS\n//MS01@SVC JOB (MS01,228),'CONYERS - SVCLIST ',MSGCLASS=T,CLASS=A,\n//         NOTIFY=MS01VC1,MSGLEVEL=(1,1),TIME=(,14)\n//*********************************************************************\n//*   THIS PROCEDURE SCANS AN SVC TABLE CONTENTS DATA BASE AND\n//*     PRODUCES VARIOUS ANALYSES USING THE SAS SOFTWARE PRODUCT\n//*********************************************************************\n//STEP01   EXEC SAS\n//SVCS     DD DISP=SHR,DSN=MS01.CONYERS.SVCS.DATA.WORK\nDATA SVCLIST ;\n  INFILE SVCS OBS=99999 ;     /* Limit control for testing */\n  INPUT\n        @2    SVCLIB  $CHAR44.\n        @47   SVCNUM  $CHAR6.\n        @64   SVCTYPE $CHAR3.\n        @68   SVCEPA  $CHAR8.\n        @77   SVCLOC  $CHAR5.\n        @83   SVCSPEC $CHAR3.   ;\n  LABEL SVCLIB  = 'Library Name'\n        SVCNUM  = 'SVC Number'\n        SVCTYPE = 'Type (1-4,6)'\n        SVCEPA  = 'Entry Address'\n        SVCLOC  = 'Entry Location'\n        SVCSPEC = 'Special (APF,ESR)'    ;\n  TITLE1 \"SVC Table Contents Analysis\" ;\n ********************************************************************;\n /* Generate a comment if location exception detected              */\n  COMMENT = '                    ' ;\n  IF SVCNUM > 'SVC199' AND SVCSPEC = '   '\n     THEN COMMENT = 'User SVC not APF';\n  IF SVCTYPE = '1  ' AND SVCLOC \u00ac= 'NUC'\n     THEN COMMENT = 'T1 not in NUC   ' ;\n  IF SVCTYPE = '2  ' AND SVCLOC \u00ac= 'NUC'\n     THEN COMMENT = 'T2 not in NUC   ' ;\n  IF SVCTYPE = '6  ' AND SVCLOC \u00ac= 'NUC'\n     THEN COMMENT = 'T6 not in NUC   ' ;\n  IF SVCTYPE = '3/4' AND (SVCLOC \u00ac= 'PLPA' AND SVCLOC \u00ac= 'EPLPA')\n     THEN COMMENT = 'T3/4 not in PLPA' ;\n ********************************************************************;\n  PROC FREQ ;\n    TABLES SVCTYPE SVCLOC SVCSPEC COMMENT ;\n    TITLE2 \"SVC Table Entry Counts\" ;\n  PROC SORT NODUPS ; BY SVCNUM ;\n  PROC PRINT ;\n    VAR SVCNUM SVCSPEC SVCTYPE SVCEPA SVCLOC COMMENT ;\n    TITLE2 \"Detail Report by SVC Table Entry\" ;\nDATA SVCEXCP ;\n  SET SVCLIST ;\n  IF COMMENT \u00ac=  '                    ' ;\n  PROC SORT NODUPS ; BY COMMENT SVCNUM ;\n  PROC PRINT ;\n    VAR SVCNUM SVCSPEC SVCTYPE SVCEPA SVCLOC COMMENT ;\n    BY COMMENT ;\n    TITLE2 \"SVC Entry Point Address Exceptions\" ;\n./ ADD NAME=SVCMATCH 0100-94267-94267-1200-00126-00126-00000-CONYERS\n//MS01@SVC JOB (MS01,228),'CONYERS - SVCMATCH',MSGCLASS=T,CLASS=A,\n//         NOTIFY=MS01VC1,MSGLEVEL=(1,1),TIME=(,14)\n//*********************************************************************\n//*   THIS PROCEDURE SCANS AN SVC TABLE OUTPUT DATA BASE AND\n//*     MATCHES ENTRY POINTS WITH LPAQ, PLPA, AND NUCMAP ENTRIES.\n//*********************************************************************\n//STEP01   EXEC SAS\n//SVCS     DD DISP=SHR,DSN=MS01.CONYERS.SVCS.DATA.WORK\n//LPAQMODS DD DISP=SHR,DSN=MS01.CONYERS.LPAQMODS.DATA.WORK\n//PLPAMODS DD DISP=SHR,DSN=MS01.CONYERS.PLPAMODS.DATA.WORK\n//NUCMAP   DD DISP=SHR,DSN=MS01.CONYERS.NUCMAP.DATA.WORK\n  TITLE1 \"SVC Table Contents Analysis\" ;\nDATA SVCLIST ;\n  INFILE SVCS OBS=99999 ;     /* Limit control for testing */\n  INPUT\n        @2    SVCLIB  $CHAR44.\n        @47   SVCNUM  $CHAR6.\n        @64   SVCTYPE $CHAR3.\n        @68   SVCEPA  $CHAR8.\n        @77   SVCLOC  $CHAR5.\n        @83   SVCSPEC $CHAR3.   ;\n  LABEL SVCLIB  = 'Library Name'\n        SVCNUM  = 'SVC Number'\n        SVCTYPE = 'Type (1-4,6)'\n        SVCEPA  = 'Entry Address'\n        SVCLOC  = 'Entry Location'\n        SVCSPEC = 'Special (APF,ESR)'    ;\n  EPADDR = SUBSTR(SVCEPA,2,7) ;\n  PROC SORT DATA=SVCLIST ; BY EPADDR ;\nDATA LPAQ ;\n  INFILE LPAQMODS OBS=99999 ;     /* Limit control for testing */\n  INPUT\n        @2    LPAQLIB $CHAR44.\n        @47   LPAQSEQ $CHAR4.\n        @52   LPAQPGM $CHAR8.\n        @61   LPAQEPA $CHAR8.\n        @70   LPAQLOC $CHAR5.\n        @80   LPAQUSE $CHAR5.\n        @89   LPAQACD $CHAR1.\n        @101  LPAQMAJ $CHAR8.   ;\n  LABEL LPAQLIB = 'Library Name'\n        LPAQSEQ = 'LPAQ Sequence Number'\n        LPAQPGM = 'Program Load Module Name'\n        LPAQEPA = 'Program Entry Point Address'\n        LPAQLOC = 'Program Location'\n        LPAQUSE = 'Program Use Count'\n        LPAQACD = 'Program AC Flag (AC=0,1)'\n        LPAQMAJ = 'Program Major Name if LPAQPGM is alias' ;\n  EPADDR = SUBSTR(LPAQEPA,2,7) ;\n  PROC SORT DATA=LPAQ ; BY EPADDR ;\n*********************************************************************;\nDATA PLPA ;\n  INFILE PLPAMODS OBS=99999 ;     /* Limit control for testing */\n  INPUT\n        @2   PLPALIB $CHAR44.\n        @47  PLPASEQ $CHAR8.\n        @56  PLPAPGM $CHAR8.\n        @65  PLPAEPA $CHAR8.\n        @74  PLPALOC $CHAR5.\n        @85  PLPASIZ $CHAR8.\n        @97  PLPAACD $CHAR1.\n        @109 PLPAMAJ $CHAR8.   ;\n  LABEL PLPALIB = 'Library Name'\n        PLPASEQ = 'PLPA Sequence Number'\n        PLPAPGM = 'Load Module Name'\n        PLPAEPA = 'Entry Point Address'\n        PLPALOC = 'Module Location'\n        PLPASIZ = 'Module Size'\n        PLPAACD = 'Authorization Code'\n        PLPAMAJ = 'Major Name if PLPAPGM is Alias'   ;\n  EPADDR = SUBSTR(PLPAEPA,2,7) ;\n  PROC SORT DATA=PLPA ; BY EPADDR ;\n*********************************************************************;\nDATA NUCM ;\n  INFILE NUCMAP OBS=99999 ;     /* Limit control for testing */\n  INPUT\n        @2    NUCMSEQ  $CHAR8.\n        @11   NUCMEPN  $CHAR8.\n        @20   NUCMEPA  $CHAR8.\n        @31   NUCCSECT $CHAR1.\n        @37   NUCRSECT $CHAR1.\n        @42   NUCRMODE $CHAR3.\n        @48   NUCAMODE $CHAR3.\n        @53   NUCMLEN  $CHAR6.    ;\n  LABEL NUCMSEQ  = 'NUCMAP Sequence'\n        NUCMEPN  = 'Entry Name'\n        NUCMEPA  = 'Entry Point Address'\n        NUCCSECT = 'CSECT Flag'\n        NUCRSECT = 'RSECT Flag'\n        NUCRMODE = 'RMODE'\n        NUCAMODE = 'AMODE'\n        NUCMLEN  = 'Entry Length'        ;\n  EPADDR = SUBSTR(NUCMEPA,2,7) ;\n  PROC SORT DATA=NUCM ; BY EPADDR ;\n*********************************************************************;\nDATA SVC_ALL ;\n  MERGE SVCLIST(IN=SVCLIST) LPAQ(IN=LPAQ) PLPA(IN=PLPA) NUCM(IN=NUCM);\n    BY EPADDR ;\n  IN_S=SVCLIST ; IN_L=LPAQ ; IN_P=PLPA ; IN_N=NUCM ; /* debug */\n  IF SVCLIST ;\n  PROC SORT DATA=SVC_ALL ; BY SVCNUM ;\n  PROC PRINT ;\n    VAR SVCNUM SVCTYPE SVCEPA SVCLOC SVCSPEC\n        LPAQPGM PLPAPGM NUCMEPN ;\n    TITLE2 \"SVCs Matched with LPAQ, PLPA, and NUCMAP\" ;\n*********************************************************************;\nDATA SVC_ERR ;\n  SET SVC_ALL ;\n  IF IN_S AND NUCMEPN = 'IGCERROR' ;\n  PROC SORT DATA=SVC_ERR ; BY SVCNUM ;\n  PROC PRINT ;\n    VAR SVCNUM SVCTYPE SVCEPA SVCLOC SVCSPEC\n        LPAQPGM PLPAPGM NUCMEPN ;\n    TITLE2 \"SVCs Matched with LPAQ, PLPA, and NUCMAP\" ;\n    TITLE3 \"SVCs Pointing to Nucleus Error Routine\" ;\n*********************************************************************;\nDATA SVC_MISS ;\n  SET SVC_ALL ;\n  IF IN_S\n       AND NOT IN_L AND NOT IN_P AND NOT IN_N ;\n  PROC SORT DATA=SVC_MISS ; BY SVCNUM ;\n  PROC PRINT ;\n    VAR SVCNUM SVCTYPE SVCEPA SVCLOC SVCSPEC\n        LPAQPGM PLPAPGM NUCMEPN ;\n    TITLE2 \"SVCs NOT Matched with LPAQ, PLPA, and NUCMAP\" ;\n    TITLE3 \"Storage Residency Exceptions\" ;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SDUMP": {"ttr": 6403, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x02\\x00A\\x00\\x94\\x08\\x8f\\x01\\x15\\x03?\\x13\\x00\\x00)\\x00'\\x00\\x00\\xc1\\xc3\\xc9\\xc5\\xd9\\xc9@@@@\"", "ispf": {"version": "02.02", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2015-02-02T13:00:41", "lines": 41, "newlines": 39, "modlines": 0, "user": "ACIERI"}, "text": "/*REXX*/\n/**********************************************************************/\n/*    PROCEDURE NAME:  SDUMP - formatted storage dump.                */\n/*                                                                    */\n/*            ARG(1):  HEXADECIMAL ADDRESS - DUMP starting location   */\n/*            ARG(2):  DECIMAL LENGTH      - Bytes to dump            */\n/*                                                                    */\n/*    NOTES:  Produces a formatted storage dump for 80 column screens.*/\n/*            The length is rounded to a 16 byte boundary.            */\n/*            The TSO/E STORAGE function is used to access memory.    */\n/**********************************************************************/\nArg @start bytes\nNumeric Digits 20               /* for high end addresses in ESA */\nIf DATATYPE(@start,'X') \\= 1 Then Do\n   Say 'Starting address '@start' is not in hexadecimal form.'\n   Return\n   End\nIf bytes = '' Then bytes  =  256\nIf DATATYPE(bytes,'N') \\= 1 Then Do\n   Say 'Specified bytes 'bytes' is not in decimal form.'\n   Return\n   End\nblocks16=bytes%16 ; If blocks16\\=(bytes/16) Then blocks16=blocks16+1\nAddress TSO ; \"CLEAR\"\nSay 'Storage dump beginning at '@start' for 'blocks16*16' bytes.'\nSay ' '\nSay '  ADDRESS  OFFSET            HEXADECIMAL DATA               ',\n'CHARACTER'\nSay ' --------  ------  ------------------------------------ ',\n':----------------:'\nDo i = 0 to blocks16-1\n   offset = i*16\n   @address = D2X(X2D(@start)+offset)\n   nbytes = STORAGE(@address,16)\n   nbytes = C2X(nbytes)\n   Say ' 'RIGHT(@address,8,0)'  'RIGHT(D2X(offset),6,0)' ',\n           SUBSTR(nbytes,1,8)' 'SUBSTR(nbytes,9,8)' ',\n           SUBSTR(nbytes,17,8)' 'SUBSTR(nbytes,25,8)' ',\n           ':'X2C(nbytes)':'\nEnd\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SDUMPE": {"ttr": 6405, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x08\\x002\\x01\\x15\\x02\\x9f\\x01\\x165?\\x15!\\x00*\\x00'\\x00\\x00\\xf6\\xf4`\\xc2\\xc9\\xe3@@@@\"", "ispf": {"version": "01.08", "flags": 0, "createdate": "2015-01-29T00:00:00", "modifydate": "2016-12-18T15:21:32", "lines": 42, "newlines": 39, "modlines": 0, "user": "64-BIT"}, "text": "/*REXX*/\n/**********************************************************************/\n/*    PROCEDURE NAME:  SDUMP - formatted storage dump.                */\n/*                                                                    */\n/*            ARG(1):  HEXADECIMAL ADDRESS - DUMP starting location   */\n/*            ARG(2):  DECIMAL LENGTH      - Bytes to dump            */\n/*                                                                    */\n/*    NOTES:  Produces a formatted storage dump for 80 column screens.*/\n/*            The length is rounded to a 16 byte boundary.            */\n/*            The TSO/E STORAGE function is used to access memory.    */\n/*              Only shows lower 12 characters of the 16 bits         */\n/*              needed for 64-bit storage display.                    */\n/**********************************************************************/\nArg @start bytes\nNumeric Digits 20               /* for high end addresses in ESA */\nIf DATATYPE(@start,'X') \\= 1 Then Do\n   Say 'Starting address '@start' is not in hexadecimal form.'\n   Return\n   End\nIf bytes = '' Then bytes  =  256\nIf DATATYPE(bytes,'N') \\= 1 Then Do\n   Say 'Specified bytes 'bytes' is not in decimal form.'\n   Return\n   End\nblocks16=bytes%16 ; If blocks16\\=(bytes/16) Then blocks16=blocks16+1\nAddress TSO ; \"CLEAR\"\nSay 'Storage dump beginning at '@start' for 'blocks16*16' bytes.'\nSay ' '\nSay '  ADDRESS      OFFSET            HEXADECIMAL DATA                CHARACTER'\nSay ' ------------  ------  ------------------------------------  :-------------\n---:'\nDo i = 0 to blocks16-1\n   offset = i*16\n   @address = D2X(X2D(@start)+offset)\n   nbytes = STORAGE(@address,16)\n   nbytes = C2X(nbytes)\n   Say ' 'RIGHT(@address,12,0)'  'RIGHT(D2X(offset),6,0)' ',\n           SUBSTR(nbytes,1,8)' 'SUBSTR(nbytes,9,8)' ',\n           SUBSTR(nbytes,17,8)' 'SUBSTR(nbytes,25,8)' ',\n           ':'X2C(nbytes)':'\nEnd\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SDUMPG": {"ttr": 6407, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x07\\x00\\x00\\x00\\x94\\x08\\x8f\\x01\\x165?\\x15 \\x00+\\x00'\\x00\\x00\\xf6\\xf4`\\xc2\\xc9\\xe3@@@@\"", "ispf": {"version": "02.07", "flags": 0, "createdate": "1994-03-29T00:00:00", "modifydate": "2016-12-18T15:20:00", "lines": 43, "newlines": 39, "modlines": 0, "user": "64-BIT"}, "text": "/*REXX*/\n/**********************************************************************/\n/*    PROCEDURE NAME:  SDUMP - formatted storage dump.                */\n/*                                                                    */\n/*            ARG(1):  HEXADECIMAL ADDRESS - DUMP starting location   */\n/*            ARG(2):  DECIMAL LENGTH      - Bytes to dump            */\n/*                                                                    */\n/*    NOTES:  Produces a formatted storage dump for 83 column screens.*/\n/*            The length is rounded to a 16 byte boundary.            */\n/*            The TSO/E STORAGE function is used to access memory.    */\n/*              displays all 64 bits of the storage.                  */\n/*                                                                    */\n/**********************************************************************/\nArg @start bytes\nNumeric Digits 20               /* for high end addresses in ESA */\nIf DATATYPE(@start,'X') \\= 1 Then Do\n   Say 'Starting address '@start' is not in hexadecimal form.'\n   Return\n   End\nIf bytes = '' Then bytes  =  256\nIf DATATYPE(bytes,'N') \\= 1 Then Do\n   Say 'Specified bytes 'bytes' is not in decimal form.'\n   Return\n   End\nblocks16=bytes%16 ; If blocks16\\=(bytes/16) Then blocks16=blocks16+1\nAddress TSO ; \"CLEAR\"\nSay 'Storage dump beginning at '@start' for 'blocks16*16' bytes.'\nSay ' '\nSay '      ADDRESS      OFFSET            HEXADECIMAL DATA       ',\n'        CHARACTER'\nSay ' ----------------  ------  ------------------------------------ ',\n':----------------:'\nDo i = 0 to blocks16-1\n   offset = i*16\n   @address = D2X(X2D(@start)+offset)\n   nbytes = STORAGE(@address,16)\n   nbytes = C2X(nbytes)\n   Say ' 'RIGHT(@address,16,0)'  'RIGHT(D2X(offset),6,0)' ',\n           SUBSTR(nbytes,1,8)' 'SUBSTR(nbytes,9,8)' ',\n           SUBSTR(nbytes,17,8)' 'SUBSTR(nbytes,25,8)' ',\n           ':'X2C(nbytes)':'\nEnd\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT220/FILE220.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT220", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}