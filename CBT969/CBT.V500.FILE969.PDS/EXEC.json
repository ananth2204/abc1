{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SLBD", "INMTNODE": "X", "INMTUID": "Y", "INMFTIME": "20201214121935000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1395097, "INMDSORG": "PO", "INMTYPE": "Data Library", "INMLRECL": 80, "INMBLKSZ": 32720, "INMRECFM": "FB", "INMDIR": 1, "INMDSNAM": "SLBD.PDSEGEN.EXEC", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1395097, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1395097, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"SLBD.PDSEGEN.EXEC": {"COPYR1": {"type": "PDSE", "DS1DSORG": 512, "DS1BLKL": 32720, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 8, "DVACLASS": 32, "DVAUNIT": 0, "DVAMAXRC": 32760, "DVACYL": 256, "DVATRK": 256, "DVATRKLN": 65535, "DVAOVHD": 0, "num_header_records": 0}, "COPYR2": {"deb": "b'\\x03\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x00\\x00\\x00\\x04\\x00\\x00\\x00'", "extents": ["b'\\x03\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x00\\x00\\x00\\x04\\x00\\x00\\x00'", "b'\\x00\\x0fxH\\x00\\x00\\x00\\x00\\x00\\x00\\x00~\\x00\\xff\\x7f\\x00'", "b'\\x00\\x0fxH\\x00\\x00\\x00\\x7f\\x00\\x00\\x00\\xfd\\x00\\xff\\x7f\\x00'", "b'\\x00\\x0fxH\\x00\\x00\\x00\\xfe\\x00\\x00\\x00\\xff\\x00\\xff\\x02\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"GNAME": {"ttr": 201, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00 \\x01\\x16!/\\x01\\x17'\\x8f\\x07Q\\x00?\\x00-\\x00\\x00\\xd7\\xc4\\xe2\\xc5@@@@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "2016-07-30T00:00:00", "modifydate": "2017-10-05T07:51:20", "lines": 63, "newlines": 45, "modlines": 0, "user": "PDSE"}, "text": "/* --------------------  rexx procedure  -------------------- *\n * Name:      GNAME                                           *\n *                                                            *\n * Function:  Identify the Backup Member to the Real Member   *\n *            and Generation                                  *\n *                                                            *\n * ISPF Edit Command:  GNAME                                  *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * History:                                                   *\n *            07/31/16 - Creation (inspired by John Kalinich) *\n *                                                            *\n * ---------------------------------------------------------- *\n * Copyright (c) 2017 by Lionel B. Dyck                       *\n * ---------------------------------------------------------- */\n\n/* ------------------------------- *\n * Get the Dataset and Member info *\n * ------------------------------- */\nAddress isredit\n'macro'\n'(member)  = member'\n'(dataset) = dataset'\n\n/* ----------------------------- *\n * Now read in the $INDEX member *\n * ----------------------------- */\naddress tso\ngdd = 'gdd'random(99)\nif sysdsn(\"'\"dataset\"($index)'\") /= 'OK' then do\n   zerrsm = 'Error'\n   zerrlm = 'The current dataset is not a PDSEGEN Backup' ,\n            'dataset so this macro can do nothing.'\n   zerrhm   = 'PDSEGH0'\n   zerralrm = 'NO'\n   Address ISPExec 'Setmsg msg(isrz002)'\n   exit\n   end\n\"alloc f(\"gdd\") shr reuse ds('\"dataset\"($index)')\"\n'execio * diskr 'gdd' (finis stem in.'\n'Free f('gdd')'\n\n/* ----------------------------------------------------- *\n * Find the current member name (backup format) and then *\n * insert a message with the real member name and        *\n * absolute (relative) generation.                       *\n * ----------------------------------------------------- */\nAddress isredit\ndo i = 1 to in.0\n   if word(in.i,1) > member then do\n      zerrsm = 'Error'\n      zerrlm = 'The current member is not a PDSEGEN Backup member.'\n      zerrhm   = 'PDSEGH0'\n      zerralrm = 'NO'\n      Address ISPExec 'Setmsg msg(isrz002)'\n      end\n   if word(in.i,1) /= member then iterate\n   parse value in.i with member real agen rgen .\n   text = 'Member name:' left(real,10) 'Generation:' agen'('rgen')'\n   \"line_before .zfirst = msgline '\"text\"'\"\n   exit\n   end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDSEGBAK": {"ttr": 179, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00R\\x01\\x16\\x19o\\x01\\x19%O\\x07&\\x03M\\x001\\x00\\x00\\xd7\\xc4\\xe2\\xc5@@@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2016-07-14T00:00:00", "modifydate": "2019-09-11T07:26:52", "lines": 845, "newlines": 49, "modlines": 0, "user": "PDSE"}, "text": "/* --------------------  rexx procedure  -------------------- */\n pdsegver = pdsegver()\n/* Name:      pdsegbak                                        *\n *                                                            *\n * Function:  backup and restore a pdse with member           *\n *            generations.                                    *\n *                                                            *\n *            the backup file is a pds with an index member   *\n *            and then members using created names            *\n *                                                            *\n *            this backup pds can then be copied using        *\n *            iebcopy, tso transmit, or other normal tool     *\n *                                                            *\n *            the backup process will allocate a backup       *\n *            dataset as a pdse v2 without maxgen.            *\n *                                                            *\n *            the output/backup dataset will have information *\n *            needed to recreate the backup source.           *\n *                                                            *\n *            Can be run in batch                             *\n *                                                            *\n * Syntax:    %pdsegbak input output options                  *\n *                                                            *\n *            input  is either the pdse with member/gens      *\n *                   or the backup pds                        *\n *            output is the target dataset for backup or      *\n *                   restore.  this dataset will be           *\n *                   allocated based on the input dataset     *\n *            options are: backup, restore and/or batch       *\n *                                                            *\n *            if no parameters or only the fromdsn is         *\n *            provided then a prompting panel will be         *\n *            displayed.                                      *\n *                                                            *\n *            batch may be used with both backup and restore  *\n *                                                            *\n *            if the batch option is used the report will     *\n *            be written to the terminal instead of browsed   *\n *                                                            *\n * Dependencies:   PDSEGENI rexx function                     *\n *                 ISPF                                       *\n *                                                            *\n * Special members in the target PDSE                         *\n *            $ALLOC    contains the maxgen information used  *\n *                      to allocate the restore PDSE          *\n *            $BACKUP   contains the backup report            *\n *            $INDEX    a map of original name/generation to  *\n *                      backup name (@nnnnnnn)                *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * History:                                                   *\n *            09/10/19 - Update pdsegeni parse for mmod       *\n *            06/25/19 - Set return code                      *\n *            03/04/19 - Add Numeric Digits for Maxgen check  *\n *            11/24/17 - Update to support changed PDSEGENS   *\n *            08/14/17 - Change to use pdsegver for pdsegen   *\n *                       version                              *\n *            06/20/17 - Version change                       *\n *            06/08/17 - Version change                       *\n *            05/30/17 - Version change                       *\n *            05/19/17 - Change to use edit macro parm        *\n *            04/04/17 - Make panel a popup                   *\n *                     - Recurse into ISPF APPL(PDSE)         *\n *            01/19/17 - Version change                       *\n *            01/05/17 - Version change                       *\n *            10/07/16 - Allow null default unit              *\n *                     - correction for ttr test              *\n *                     - correct backup messages              *\n *                     - change from edit to view             *\n *                     - removed stats from backup summary    *\n *                       members ($*) as that fails in batch  *\n *                     - changed to use relative gen instead  *\n *                       of absolute gen for replace          *\n *            09/12/16 - Use PDSEGENS for default unit        *\n *                     - additional test for null member name *\n *            09/07/16 - Fix batch test                       *\n *            09/01/16 - If TTR is x'000000' then ignore as   *\n *                       it's a dummy member                  *\n *            08/24/16 - Add preparing message                *\n *                     - update code for performance          *\n *            08/23/16 - Correct progress display             *\n *            08/16/16 - Add batch option                     *\n *            08/12/16 - Correct backup to ignore dummys      *\n *                       and process members with no stats    *\n *            07/27/16 - Add check for maxgen limit on restore*\n *            07/27/16 - Add timestamp for start of processing*\n *            07/25/16 - Change from msg isrz001 to isrz002   *\n *            07/21/16 - Get pdsebopt from ispf variable      *\n *                     - add elapsed time to report           *\n *            07/20/16 - Add progress meter                   *\n *                     - correction for batch processing      *\n *                       to NOT call ISPF Browse              *\n *                     - make sure report dataset is not there*\n *            07/19/16 - Minor updates                        *\n *                     - add more doc and $backup member      *\n *            07/18/16 - Enhance the reporting with rel gen   *\n *            07/16/16 - Change to display panel if passed    *\n *                       only the fromdsn                     *\n *                     - change to use replace instead of     *\n *                       cut/paste for backup process         *\n *            07/15/16 - Creation                             *\n *                                                            *\n * ---------------------------------------------------------- */\n arg options\n\n/* ---------------------------------------------------- *\n | Check for Applid of PDSE and recurse into it if not. |\n * ---------------------------------------------------- */\n Address ISPExec\n 'Control Errors Return'\n \"Vget (Zapplid)\"\n if zapplid <> \"PDSE\" then do\n     \"Select CMD(%\"sysvar('sysicmd') options \") Newappl(PDSE)\" ,\n         \"Passlib\"\n    exit rc\n    end\n\n parse value options with fromdsn targetds options\n\n if wordpos('BACKUP',options)  > 0 then pdsebopt = 'BACKUP'\n if wordpos('RESTORE',options) > 0 then pdsebopt = 'RESTORE'\n if wordpos('BATCH',options)   > 0 then batch    = 'BATCH'\n                                   else batch    = null\n\n/* ------------------------------------------ *\n * Default the addressing environment to ISPF *\n * and setup our other defaults               *\n * ------------------------------------------ */\n Address ISPExec\n 'Control Errors Return'\n null   = ''\n ddn    = 'PDSE'random(999)\n mc     = 0\n zerrhm   = 'PDSEGH0'\n zerralrm = 'NO'\n\n/* ------------------------------------------------- *\n * Now get current environment - must be ISPF Active *\n * ------------------------------------------------- */\n ispf = sysvar('sysispf')\n\n if ispf /= 'ACTIVE' then do\n    say 'Error: This tool must be run under ISPF' ,\n        'either online or it ISPF/TSO batch.'\n    exit 8\n    end\n else ispf = 1\n\n/* ------------------------------------------- *\n * Now turn off ISPF flag for batch processing *\n * ------------------------------------------- */\n if sysvar('sysenv') /= 'FORE' then ispf = 0\n if ispf = 0 then batch = null\n\n if batch = 'BATCH' then ispf = 0\n\n/* -------------------------- *\n * Get defaults from PDSEGENS *\n * -------------------------- */\n x = pdsegens()\n parse value x with  mail '/' etime '/' higen ,\n              '/' base_color '/' sort_color '/' clean ,\n              '/' prune_prompt '/' tempmem '/' def_unit ,\n              '/' x\n base_color   = strip(base_color)\n sort_color   = strip(sort_color)\n clean        = strip(clean)\n prune_prompt = strip(prune_prompt)\n tempmem      = strip(tempmem)\n def_unit     = strip(def_unit)\n if def_unit /= null then\n    def_unit = 'unit('def_unit')'\n\n/* ----------------------------------------------- *\n * If no parms then check for foreground and if so *\n * display the prompting panel.                    *\n * ----------------------------------------------- */\n if length(targetds) = 0 then do\n    if pdsebopt = null then\n       'vget (pdsebopt)'\n    if sysvar('sysenv') = 'FORE'\n       then do forever\n            \"addpop\"\n            \"Display panel(PDSEGBAK)\"\n            xrc = rc\n            \"rempop\"\n            if xrc > 4 then exit 4\n            call start\n            end\n    end\n\nStart:\n/* --------------------------------- *\n * Now validate the provided options *\n * --------------------------------- */\n if length(fromdsn) = 0 then do\n    zerrsm  = 'Error'\n    zerrlm  = 'Invalid syntax.' ,\n              '%pdsegbak input output option'\n    call do_msg\n    exit 8\n    end\n\n if length(targetds) = 0 then do\n    zerrsm  = 'Error'\n    zerrlm  = 'Invalid syntax.' ,\n              '%pdsegbak input output option'\n    call do_msg\n    exit 8\n    end\n\n if length(pdsebopt) = 0 then do\n    zerrsm  = 'Error'\n    zerrlm  = 'Invalid syntax.' ,\n              '%pdsegbak input output option'\n    call do_msg\n    exit 8\n    end\n\n if sysdsn(fromdsn) /= 'OK' then do\n    zerrsm  = 'Error'\n    zerrlm  = fromdsn sysdsn(fromdsn)\n    call do_msg\n    return\n    end\n\n if sysdsn(targetds) = 'OK' then do\n    zerrsm  = 'Error'\n    zerrlm  = targetds 'exists and it must not exist.'\n    call do_msg\n    return\n    end\n\n Select\n   When abbrev('BACKUP',pdsebopt,1) = 1 then pdsebopt = 'BACKUP'\n   When abbrev('RESTORE',pdsebopt,1) = 1 then pdsebopt = 'RESTORE'\n   Otherwise do\n    zerrsm  = 'Error'\n    zerrlm  = 'Invalid option - must be BACKUP or RESTORE'\n    call do_msg\n    exit 8\n    end\n  end\n\n/* ------------------------------------------------- *\n * Completed the parameter validation - now to begin *\n * the processing we were called to do.              *\n * ------------------------------------------------- */\n\n/* --------------------------------------------- *\n * First validate the dataset for backup/restore *\n * --------------------------------------------- */\n \"dsinfo dataset(\"fromdsn\")\"\n zdsngen = zdsngen + 0\n if pdsebopt = 'BACKUP' then\n    if zdsngen = 0 then do\n        zerrsm  = 'Error'\n        zerrlm  = 'Backup will only process PDSE Version 2' ,\n                  'datasets with generations. Use a real' ,\n                  'product for this dataset (it will be faster).'\n        call do_msg\n        return\n        end\n if pdsebopt = 'RESTORE' then\n    if zdsngen >  0 then do\n        zerrsm  = 'Error'\n        zerrlm  = 'Restore was requested from a dataset' ,\n                  'which is NOT a backup dataset.'\n        call do_msg\n        return\n        end\n\n/* --------------------------------------------------- *\n * Now create variables with the fully qualified input *\n * and output dsnames without quotes.                  *\n * --------------------------------------------------- */\n if left(fromdsn,1) = \"'\" then do\n    wfromdsn = substr(fromdsn,2,length(fromdsn)-2)\n    end\n else do\n      if sysvar('syspref') = null\n         then wfromdsn = fromdsn\n         else wfromdsn = sysvar('sysuid')'.'fromdsn\n      end\n if left(targetds,1) = \"'\" then do\n    wtargetds = substr(targetds,2,length(targetds)-2)\n    end\n else do\n      if sysvar('syspref') = null\n         then wtargetds = targetds\n         else wtargetds = sysvar('sysuid')'.'targetds\n      end\n\n/* --------------- *\n * Start our timer *\n * --------------- */\n x = time('r')\n\n/* ------------------------------------------------------------ *\n * Backup processing:                                           *\n * 1. allocate the backup (output) dataset using the ALLOC LIKE *\n *    with MAXGEN(0)                                            *\n * 2. create member $ALLOC with MAXGEN information of the       *\n *    backup (input) dataset                                    *\n * 3. get all members/generations using the pdsegeni rexx       *\n *    function (member. stem)                                   *\n * 4. copy base members using lmcopy and generations using      *\n *    ispf edit using the pdsegenm macro (copy/paste)           *\n *    - members in output pds will be created member names      *\n *      e.g. $1 to $9999999                                     *\n * 5. lmmstats will be used to update $nnnnnnn with the source  *\n *    members ispf stats so they are retained.                  *\n * 6. $index member will contain a record for each $nnnnnnn     *\n *    member with original name, generation                     *\n * 7. after all members/generations copied write out $INDEX     *\n * 8. after all members/generations copied write out $BACKUP    *\n * 9. insert ISPF stats for $alloc, $backup, and $index         *\n * ------------------------------------------------------------ */\n\n if pdsebopt = 'BACKUP' then do\n\n if ispf = 1 then do\n    prog = 'Preparing...'\n    \"Control Display Lock\"\n    'addpop'\n    'display panel(pdsegpr)'\n    'rempop'\n    end\n\n call do_say 'Processing backup from' fromdsn\n call do_say '                    to' targetds\n call do_say ' '\n call do_say 'Time:' time()' Date:' date()\n call do_say ' '\n\n/* ------------------------------------------------------- *\n * Allocate the output dataset and prime the $ALLOC member *\n * ------------------------------------------------------- */\n  Address TSO\n  'Alloc f('ddn') ds('targetds') like('fromdsn') maxgen(0)' ,\n        def_unit\n  $alloc.0 = 1\n  $alloc.1 = 'MAXGEN('zdsngen')'\n  \"Alloc f(\"ddn\"o) ds('\"wtargetds\"($alloc)') shr reuse\"\n  \"Execio * diskw \"ddn\"o (finis stem $alloc.\"\n  \"Free  f(\"ddn\"o)\"\n  Address ISPExec\n\n/* ----------------------------------------- *\n * Establish the ISPF setup for the datasets *\n * ----------------------------------------- */\n \"lminit dataid(fromid) dataset(\"fromdsn\")\"\n \"lminit dataid(toid)   dataset(\"targetds\")\"\n 'dsinfo dataset('fromdsn')'\n\n/* ------------------------------------- *\n * Get the list of members from PDSEIGEN *\n * ------------------------------------- */\n Address TSO\n 'Alloc f('ddn'I) ds('fromdsn') shr reuse'\n rc = pdsegeni(ddn'I')\n 'Free f('ddn'I)'\n  Address ISPExec\n\n/* ----------------------------------- *\n * setup for the copy/backup operation *\n *                                     *\n * bc      counter for target member   *\n * ic      counter for $index          *\n * members work variable               *\n * tot_members counter for total mbrs  *\n * omem    old member                  *\n * ----------------------------------- */\n bc = 0\n ic = 0\n tot_members = 0\n members = null\n omem  = null\n\n/* -------------------------------------------- *\n * Process the members from pdsegeni (member.i) *\n * -------------------------------------------- */\n do ifm = 1 to member.0\n    parse value member.ifm with 5 cmem 13 agen 21 . 22 vrm 27 . ,\n          35 cdate 42 . 46 ttr ,\n          49 mdate 56 mtime 63 muser 70 . mmod 73 . 75 mcur 79 minit 83 .\n    cmem = strip(cmem)\n    agen = strip(agen)\n\n    /* check for null member name */\n    if left(cmem,1) = '00'x then iterate\n\n    if strip(cdate) = null then do\n        parse value '' with cdate mdate mtime vrm ,\n                            muser scdate smdate ,\n                            mcur minit mmod state\n        sgen = mgen\n        mgen = agen\n        end\n\n   /* --------------------------------- *\n    * Test for dummy members and ignore *\n    * --------------------------------- */\n    if c2x(ttr) == '000000' then iterate\n    if omem /= cmem then do\n       omem = cmem\n       if agen > 0 then do\n          omem = null\n          iterate\n          end\n       end\n\n   /* --------------------- *\n    * Test for dummy Member *\n    * --------------------- */\n    if agen /= 0 then\n    if cdate = null then do\n       call test_mem\n       if rc > 4 then iterate\n       end\n\n   /* ------------------------------- *\n    | Save member info for processing |\n    * ------------------------------- */\n    if wordpos(cmem,members) = 0 then do\n       members = members cmem\n       mem.cmem.A = ''\n       end\n    mem.cmem.A = mem.cmem.A agen\n    if length(strip(mcur)) = 0 then mcur = 0\n                               else mcur = x2d(c2x(mcur))\n    if length(strip(minit)) = 0 then minit = 0\n                                else minit = x2d(c2x(minit))\n    mtime = Substr(mtime,2,2)||':'||Substr(mtime,4,2)\n    mmod = c2x(mmod)\n    mmod = x2d(mmod)\n    if mdate /= '' then do\n       smdate = substr(mdate,1,7)\n       mdate = substr(mdate,3,5)\n       mdate = date('o',mdate,'j')\n       end\n    if cdate /= '' then do\n       scdate = substr(cdate,1,7)\n       cdate = substr(cdate,3,5)\n       cdate = date('o',cdate,'j')\n       end\n  /* ------------------------------- *\n   * Add the member info to our stem *\n   * ------------------------------- */\n   parse value vrm with iver'.'imod\n   if strip(iver)  = null then iver  = 0\n   if strip(imod)  = null then imod  = 0\n   if strip(cdate) = null then cdate = 0\n   if strip(mdate) = null then mdate = 0\n   if strip(mtime) = null then mtime = '0:0'\n   if strip(muser) = null then muser = '??'\n   mem.cmem.agen = cmem agen'\\'iver'\\'imod'\\'cdate,\n                   '\\'mdate'\\' mtime'\\'mcur'\\'minit'\\'mmod'\\'muser\n   tot_members = tot_members + 1\n\n   /* ------------------------------------- *\n    | Check to see if we should display the |\n    | progress meter.                       |\n    * ------------------------------------- */\n   if tot_members//10 = 0 then\n   if ispf = 1 then do\n      prog = 'Analyzed' tot_members 'members/generations'\n      \"Control Display Lock\"\n      'addpop'\n      'display panel(pdsegpr)'\n      'rempop'\n      end\n   end\n\n   if ispf = 1 then do\n      prog = 'Preparing to backup:' tot_members 'members/generations'\n      \"Control Display Lock\"\n      'addpop'\n      'display panel(pdsegpr)'\n      'rempop'\n      end\n   else do\n        call do_say 'Preparing to backup:' tot_members 'members/generations'\n        call do_say ' '\n        end\n\n/* ------------------------------- *\n * Now process the members to copy *\n * ------------------------------- */\n dcount = 0\n if ispf = 1 then\n    call set_prog\n do im = 1 to words(members)\n   cmem = word(members,im)\n   rgen = words(mem.cmem.a) - 1\n   do ix = words(mem.cmem.A) to 1 by -1\n      dcount = dcount + 1\n      if ispf = 1 then call disp_progress\n      igen = word(mem.cmem.A,ix)\n      parse value mem.cmem.igen with x y'\\'iver'\\'imod'\\'cdate,\n                                    '\\'mdate'\\' mtime'\\'mcur'\\'minit,\n                                    '\\'mmod'\\'muser\n      if igen = 0 then do\n          rgen = 0\n          call update_target\n          call do_say 'Backing up base member' left(cmem,8) ,\n              'to' bmem\n         \"lmcopy fromid(\"fromid\") todataid(\"toid\")\" ,\n                \"frommem(\"cmem\") tomem(\"bmem\") replace\"\n         end\n      else do\n           call update_target\n           bgen = rgen *-1\n           call do_say 'Backing up gen member ' left(cmem,8) 'rel gen:' ,\n                       left(bgen,5) 'generation' igen 'to' bmem\n           /* --------------------------------------- *\n            * Replace all records from current to new *\n            * Output dataset is pre-allocated and     *\n            * then freed.                             *\n            * --------------------------------------- */\n            pdsemopt = 'R'\n            pdsecpds = \"'\"wtargetds\"(\"bmem\")'\"\n            'vput (pdsecpds)'\n            'view dataid('fromid') member('cmem') gen('bgen')' ,\n                 'macro(pdsegenm) parm(pdsemopt)'\n            rgen = rgen - 1\n           /* ------------------------------------------------ *\n            * Update the target member with the old ISPF stats *\n            * ------------------------------------------------ */\n            if iver > 0 then\n            'LMMStats Dataid('toid')' ,\n                     'Member('bmem') version('iver') modlevel('imod')' ,\n                     'Created('cdate') Moddate('mdate')' ,\n                     'Modtime('mtime') Cursize('mcur')' ,\n                     'Initsize('minit') Modrecs('mmod')' ,\n                     'User('muser')'\n            else 'LMMStats Dataid('toid') Member('bmem') Delete'\n            end\n      end\n   end\n\n call do_say ' '\n call do_say 'Backed up' bc 'members from' fromdsn\n call do_say '                         to' targetds\n call do_say ' '\n call proc_etime\n call do_say 'Elapsed time:' etime\n\n/* ------------------------------------------------------ *\n * Allocate the output dataset and write the $index member*\n * ------------------------------------------------------ */\n Address TSO\n $index.0 = ic\n \"Alloc f(\"ddn\"o) ds('\"wtargetds\"($index)') shr reuse\"\n \"Execio * diskw \"ddn\"o (finis stem $index.\"\n \"Free  f(\"ddn\"o)\"\n Address ISPExec\n\n/* -------------------------------------------------------- *\n * Allocate the output dataset and write the $backup member *\n * -------------------------------------------------------- */\n Address TSO\n msg.0 = mc\n \"Alloc f(\"ddn\"o) ds('\"wtargetds\"($backup)') shr reuse\"\n \"Execio * diskw \"ddn\"o (finis stem msg.\"\n \"Free  f(\"ddn\"o)\"\n Address ISPExec\n\n/* ------------------------------------------------ *\n | Add the ISPF Stats to $ALLOC, $BACKUP and $INDEX |\n * ------------------------------------------------ */\n/* --------------------- *\n | first prime the stats |\n * --------------------- */\n iver = 1\n imod = 0\n cdate = date('o')\n mdate = cdate\n mtime = time()\n mmod  = 0\n muser = sysvar('sysuid')\n/* --------------- *\n | First to $INDEX |\n * --------------- */\n mcur  = $index.0\n minit = mcur\n 'LMMStats Dataid('toid')' ,\n          'Member($INDEX) version('iver') modlevel('imod')' ,\n          'Created('cdate') Moddate('mdate')' ,\n          'Modtime('mtime') Cursize('mcur')' ,\n          'Initsize('minit') Modrecs('mmod')' ,\n          'User('muser')'\n/* --------------- *\n | Now for $BACKUP |\n * --------------- */\n mcur  = msg.0\n minit = mcur\n 'LMMStats Dataid('toid')' ,\n          'Member($BACKUP) version('iver') modlevel('imod')' ,\n          'Created('cdate') Moddate('mdate')' ,\n          'Modtime('mtime') Cursize('mcur')' ,\n          'Initsize('minit') Modrecs('mmod')' ,\n          'User('muser')'\n/* ---------------------- *\n | And finally for $ALLOC |\n * ---------------------- */\n 'LMMStats Dataid('toid')' ,\n          'Member($ALLOC) version('iver') modlevel('imod')' ,\n          'Created('cdate') Moddate('mdate')' ,\n          'Modtime('mtime') Cursize(1)' ,\n          'Initsize(1) Modrecs(0)' ,\n          'User('muser')'\n\n/* ------------------------------------- *\n * Free up the ISPF allocations and exit *\n * ------------------------------------- */\n \"lmfree dataid(\"fromid\")\"\n \"lmfree dataid(\"toid\")\"\n Address TSO 'Free f('ddn')'\n end\n\n/* ------------------------------------------------------------- *\n * Restore processing                                            *\n * 1. read in $ALLOC member to get MAXGEN value                  *\n *    check the maxgen value against the system limit and        *\n *    if the maxgen value is greater then set to system limit    *\n *    and tell the user                                          *\n * 2. Allocate the output PDSE with the ALLOC LIKE of the backup *\n *    dataset using the MAXGEN value                             *\n * 3. Read in the $INDEX member and process each member in       *\n *    sequence using lmcopy                                      *\n *                                                               *\n * The original generation number will be lost but the relative  *\n * generation will be retained.                                  *\n * ------------------------------------------------------------- */\n if pdsebopt = 'RESTORE' then do\n\n if ispf = 1 then do\n    prog = 'Preparing...'\n    \"Control Display Lock\"\n    'addpop'\n    'display panel(pdsegpr)'\n    'rempop'\n    end\n\n call do_say 'Processing restore from' fromdsn\n call do_say '                     to' targetds\n call do_say ' '\n call do_say 'Time:' time()' Date:' date()\n call do_say ' '\n\n/* ------------------------------------ *\n * Get the current system maxgens_limit *\n * ------------------------------------ */\n\n  Numeric Digits 10\n  CVT      = C2D(Storage(10,4))\n  CVTDFA   = C2D(Storage(D2X(CVT + 1216),4))   /* cvt + 4c0 */\n  DFAMGEN  = C2D(Storage(D2X(cvtdfa + 76),4))  /* dfa + 4c */\n\n/* --------------------------------------------------------- *\n * Read in the $ALLOC member so we know what the generations *\n * should be and then allocate the target PDSE.              *\n * Read in the $INDEX member so we know what members to      *\n * restore.                                                  *\n * --------------------------------------------------------- */\n  Address TSO\n  \"Alloc f(\"ddn\"i) ds('\"wfromdsn\"($alloc)') shr reuse\"\n  \"Execio * diskr \"ddn\"i (finis stem $alloc.\"\n  parse value $alloc.1 with .'('amgen')' .\n  if amgen > dfamgen then do\n     $alloc.1 = 'MAXGEN('dfamgen')'\n     call do_say 'The requested MAXGEN('amgen') is greater than' ,\n                 'the current system'\n     call do_say 'MAXGENS_LIMIT of' dfamgen'.' ,\n                 'The restore will use the system MAXGENS_LIMIT.'\n     call do_say 'Warning: It is possible that generations beyond the' ,\n                 dfamgen' limit will be'\n     call do_say 'lost during the restore process.'\n     call do_say ' '\n     end\n  'Alloc f('ddn') ds('targetds') like('fromdsn')' $alloc.1 ,\n    'dsntype(library,2)' def_unit\n  \"Alloc f(\"ddn\"i) ds('\"wfromdsn\"($index)') shr reuse\"\n  \"Execio * diskr \"ddn\"i (finis stem $index.\"\n  \"Free  f(\"ddn\"i)\"\n  Address ISPExec\n\n/* ----------------------------------------- *\n * Establish the ISPF setup for the datasets *\n * ----------------------------------------- */\n \"lminit dataid(fromid) dataset(\"fromdsn\") enq(shrw)\"\n \"lminit dataid(toid)   dataset(\"targetds\") enq(shrw)\"\n 'dsinfo dataset('fromdsn')'\n\n/* --------------------------------------------- *\n * Now process the $index member which lists the *\n * backup member name and then the real member   *\n * name.                                         *\n *                                               *\n * The list is in order with the oldest/highest  *\n * generation first with the base member last.   *\n *                                               *\n * Thus we can just do lmcopy for each.          *\n * --------------------------------------------- */\n dcount = 0\n if ispf = 1 then do\n    tot_members = $index.0\n    call set_prog\n    end\n do im = 1 to $index.0\n    parse value $index.im with from to gen rgen .\n    dcount = dcount + 1\n    if ispf = 1 then call disp_progress\n    \"lmcopy fromid(\"fromid\") todataid(\"toid\")\" ,\n           \"frommem(\"from\") tomem(\"to\") replace\"\n     call do_say 'Restoring member' left(to,8) 'from backup member' from ,\n                 'rel gen' rgen\n     end\n\n/* ------------------------------------- *\n * Free up the ISPF allocations and exit *\n * ------------------------------------- */\n   call do_say ' '\n   call do_say 'Restored' $index.0 'members from' fromdsn\n   call do_say '                             to' targetds\n   call do_say ' '\n   call proc_etime\n   call do_say 'Elapsed time:' etime\n   \"lmfree dataid(\"fromid\")\"\n   \"lmfree dataid(\"toid\")\"\n    Address TSO \"Free f(\"ddn\")\"\n   end\n\n if ispf = 1 then\n if mc > 0 then do\n    if sysvar('syspref') = null\n       then temp = sysvar('sysuid')'.pdsegbak.report'\n       else temp = sysvar('syspref')'.pdsegbak.report'\n    Address TSO\n    if sysdsn(\"'\"temp\"'\") = 'OK' then do\n       call outtrap 'x.'\n       Address TSO \"Delete '\"temp\"'\"\n       call outtrap 'off'\n       end\n    \"Alloc f(\"ddn\") ds('\"temp\"') new spa(1,1) tr\" ,\n      \"recfm(f b) lrecl(80) blksize(6160)\"\n    msg.0 = mc\n    \"Execio * diskw\" ddn \"(finis stem msg.\"\n    Address TSO \"Free f(\"ddn\")\"\n    Address ISPExec\n    \"Browse dataset('\"temp\"')\"\n    call outtrap 'x.'\n    Address TSO \"Delete '\"temp\"'\"\n    call outtrap 'off'\n    mc = 0\n    drop msg.\n    end\n return\n\n/* ------------------------------------ *\n * Setup for Progress Indicator Display *\n * ------------------------------------ */\n set_prog:\n division = 10\n incr = (tot_members % division) + 1\n progc = null\n perc# = 0\n return\n\n/* ---------------- *\n * Display progress *\n * ---------------- */\n Disp_Progress:\n if dcount//incr = 0 then do\n    progc = progc'**'\n    perc# = perc# + division\n    perc = perc#\"%\"\n    prog = progc '('perc')'\n    \"Control Display Lock\"\n    'addpop'\n    'display panel(pdsegpr)'\n    'rempop'\n    end\n return\n\n/* -------------------------------------- *\n * Update_Target                          *\n *                                        *\n * 1. add 1 to backup ocunter             *\n * 2. add 1 to index counter              *\n * 3. update bmem with backup member name *\n *    absolute gen and relative gen       *\n * -------------------------------------- */\n Update_Target:\n bc = bc + 1\n ic = ic + 1\n bmem = '@'right(bc,7,'0')\n $index.ic = bmem cmem igen rgen*-1\n return\n\n/* -------------------------------------------------- *\n * do_say routine                                     *\n *                                                    *\n * put the message in a stem and if ispf is not       *\n * active then say it                                 *\n * -------------------------------------------------- */\n do_say:\n parse arg message\n mc = mc + 1\n msg.mc = message\n if ispf /= 1 then\n    say message\n return\n\n/* -------------------------------- *\n * Test member and get record count *\n * -------------------------------- */\n Test_Mem:\n   pdsemopt = 'T'\n   'view dataid('fromid') member('cmem') gen('agen')' ,\n        'macro(pdsegenm) parm(pdsemopt)'\n return\n\n/* ----------------- *\n * Generate messages *\n * ----------------- */\n do_msg:\n if ispf = 1 then 'Setmsg msg(isrz002)'\n    else do\n         say zerrsm\n         say zerrlm\n         end\n return\n\n Proc_eTime:\n    e_time = time(\"E\")\n    parse value e_time with ss \".\" uu\n    numeric digits 6\n    mm = ss % 60 /* get minutes integer */\n    ss = ss // 60 /* get seconds integer */\n    uu = uu // 100 /* get micro seconds integer */\n    etime =  right(mm+100,2)':'right(ss+100,2)'.'right(uu+100,2) '(mm:ss:th)'\n    return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDSEGCMD": {"ttr": 193, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x005\\x01 )O\\x01 )_\\x08\\x03\\x00\\x85\\x00\\x88\\x00\\x00\\xd7\\xc4\\xe2\\xc5@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2020-10-20T00:00:00", "modifydate": "2020-10-21T08:03:35", "lines": 133, "newlines": 136, "modlines": 0, "user": "PDSE"}, "text": "  /* --------------------  rexx procedure  -------------------- *\n  | Name:      pdsegcmd                                        |\n  |                                                            |\n  | Function:  User Command History and Execution              |\n  |                                                            |\n  | Syntax:    %pdsegcmd option dataset                        |\n  |                                                            |\n  | Usage Notes: display a prompt panel with table of recent   |\n  |              user commands                                 |\n  |                                                            |\n  | Author:    Lionel B. Dyck                                  |\n  |                                                            |\n  | History:  (most recent on top)                             |\n  |            10/20/20 LBD - Creation                         |\n  |                                                            |\n  | ---------------------------------------------------------- |\n  | Copyright (c) 2017-2020 by Lionel B. Dyck                  |\n  | ---------------------------------------------------------- |\n  | Support is on a best effort and time available basis which |\n  | is why the complete source is provided for this application|\n  | so you can find and fix any issues you find. Please let    |\n  | me know if you do make changes/enhancements/fixes.         |\n  | ---------------------------------------------------------- |\n  | License:   This EXEC and related components are released   |\n  |            under terms of the GPLV3 License. Please        |\n  |            refer to the LICENSE file for more information. |\n  |            Or for the latest license text go to:           |\n  |                                                            |\n  |              http://www.gnu.org/licenses/                  |\n  | ---------------------------------------------------------- |\n  |                                                            |\n  * ---------------------------------------------------------- */\n  parse arg pdsedsn\n\n  /* ---------------------------------------------------- *\n  | Set ISPExec                                          |\n  * ---------------------------------------------------- */\n  Address ISPExec\n  'Control Errors Return'\n\n  /* -------------------------------------------------- *\n  | Check to see if the user has ISPTABL allocated and |\n  | if not then use ISPPROF as our table DD            |\n  * -------------------------------------------------- */\n  isptabl = 'ISPTABL'\n  x = listdsi(isptabl 'FILE')\n  if x > 0 then isptabl = 'ISPPROF'\n\n  /* ----------------------------------------------------- *\n  | Open the table but if it doesn't exist then create it |\n  * ----------------------------------------------------- */\n  'TBOpen pdsegcmd Library('isptabl') Write Share'\n  if rc > 0 then do\n  'tbcreate pdsegcmd keys(pdsecmd) library('isptabl') write share'\n  end\n\n  /* -------------------- *\n  | Setup table defaults |\n  * -------------------- */\n  ztdtop = 0\n  ztdsels = 0\n\n  /* ---------------------------------------------------------------- *\n  | Process the table.                                               |\n  |                                                                  |\n  | All row selections will be processed and if none then the git    |\n  | command will be executed.                                        |\n  |                                                                  |\n  | Row selections:  S to copy the command to the git command  entry |\n  |                  D to delete the command (supports multipe row   |\n  |                    selections)                                   |\n  |                  X to execute the command now and update the     |\n  |                    git command entry field                       |\n  * ---------------------------------------------------------------- */\n  do forever\n     if ztdsels = 0 then do\n        'tbtop pdsegcmd'\n        'tbskip pdsegcmd number('ztdtop')'\n        'tbdispl pdsegcmd panel(pdsegcmd) cursor(pdsecmd)'\n     end\n     else\n     'tbdispl pdsegcmd'\n     if rc > 4 then leave\n     'vput (gopt) profile'\n     if row = 0 then usel = null\n     if row <> null then\n     if row > 0 then do\n       'TBTop pdsegcmd'\n       'TBSkip pdsegcmd Number('row')'\n     end\n     Select\n        When zcmd = 'CLEAR' then do\n             'tbclose pdsegcmd replcopy library('isptabl')'\n             'tberase pdsegcmd library('isptabl')'\n             'tbcreate pdsegcmd keys(pdsecmde) library('isptabl') write share'\n             pdsecmd = null\n             end\n        When usel = 'D' then 'tbdelete pdsegcmd'\n        When usel = 'S' then do\n           pdsecmd = pdsecmde\n           ztdsels = 0\n        end\n        When usel = 'X' then do\n           pdsecmd = pdsecmde\n           ztdsels = 0\n           call do_pdsecmd\n        end\n        When pdsecmd /= null then call do_pdsecmd\n        Otherwise nop\n     end\n     usel = null\n  end\n\n  /* -------------- *\n  | Close and exit |\n  * -------------- */\n  'tbclose pdsegcmd replcopy library('isptabl')'\n  exit\n\n  /* ------------------------------------------------------------- *\n  | Execute the user command                                       |\n  * -------------------------------------------------------------- */\ndo_pdsecmd:\n  pdsecmde = pdsecmd\n  'tbadd pdsegcmd'\n  'Select cmd('pdsecmde')'\n  src = rc\n  zerrsm = 'Completed.'\n  zerrlm = 'The command completed processing with return code:' src\n  'Setmsg msg(isrz003)'\n  'vput (pdsecmde) shared'\n  'verase (pdsecmde)'\n  return\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PDSEGCPR": {"ttr": 185, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01UV\\x00\\x01\\x16'\\x1f\\x01 \\x10\\x8f\\x06Y\\x01\\x13\\x00\\x19\\x00\\x00\\xd7\\xc4\\xe2\\xc5@@@@@@\"", "ispf": {"version": "01.85", "flags": 86, "createdate": "2016-09-27T00:00:00", "modifydate": "2020-04-17T06:59:00", "lines": 16448, "newlines": 0, "modlines": 0, "user": "PDSE"}, "text": "/* --------------------  rexx procedure  -------------------- *\n | Name:      pdsegcpr                                        |\n |                                                            |\n | Function:  ISPF Edit Macro to compare the current member   |\n |            to another mbr and/or generation                |\n |                                                            |\n | Usage Notes:  compare member generation                    |\n |               or                                           |\n |               compare generation                           |\n |                                                            |\n |               To use the native ISPF Compare first         |\n |               issue the COMPARE RESET command.             |\n |                                                            |\n |               No need if non-generation or other dataset   |\n |               as normal compare handles that               |\n |                                                            |\n | Dependencies:  The PDSEGENM edit macro                     |\n |                PDSEGENS settings exec                      |\n |                                                            |\n | Process:   If the compare is for a generation then the     |\n |            generation is copied into a temporary dataset   |\n |            that is allocated using the same DCB as the     |\n |            source dataset. Then the ISPF Edit Compare      |\n |            command is invoked using the BUILTIN command    |\n |            to compare the current member/generation to     |\n |            the temp dataset. After the compare the temp    |\n |            dataset is deleted as it is no longer needed.   |\n |                                                            |\n |            If the compare is to a base member or another   |\n |            dataset then the ISPF Compare command is        |\n |            invoked using the BUILTIN command.              |\n |                                                            |\n | Author:    Lionel B. Dyck                                  |\n |                                                            |\n | History:  (most recent on top)                             |\n |            04/17/20 - Add Compare RESET option             |\n |            04/04/20 - Fix typo in parm for option R        |\n |            11/24/17 - Update to support changed PDSEGENS   |\n |            05/19/17 - Change to use Edit Macro Parm        |\n |            10/07/16 - Additional code to support compares  |\n |                       for non-0 gens                       |\n |            09/30/16 - Correction and add Exclude           |\n |            09/29/16 - Allow only a generation              |\n |            09/28/16 - Creation                             |\n |                                                            |\n * ---------------------------------------------------------- */\n Address ISREdit\n 'Macro (options)'\n parse value '' with null odsn deltemp\n\n/* ----------------------- *\n | If no options just exit |\n * ----------------------- */\n if options = null then exit\n\n if translate(options) = 'RESET' then do\n  'define compare reset'\n  'define compare reset'\n   zedsmsg = ''\n   zedlmsg = 'Compare override removed. Compare will now work' ,\n             'as natively implemented in ISPF but will no longer' ,\n             'support generations.'\n    Address ISPExec 'setmsg msg(isrz001)'\n    exit\n    end\n\n/* ---------------------------------------------------- *\n | Check passed options                                 |\n | if only 1 then use native compare                    |\n |    unless it is a generation number                  |\n | if only 2 options and option 2 not numeric then use  |\n |    native compare                                    |\n | if option 2 is numeric and 0 then use native compare |\n |    as generation 0 is a base member                  |\n | otherwise use compare extension                      |\n * ---------------------------------------------------- */\n do_compare = 0\n if words(options) = 1\n    then if datatype(options) /= 'NUM' then\n         do_compare = 1\n    else do\n         '(mbr)  = member'\n         options = mbr options\n         end\n if words(options) = 2 then do\n    if datatype(word(options,2)) /= 'NUM' then do_compare = 1\n    if word(options,2) = 0 then do\n       options = word(options,1)\n       do_compare = 0\n       end\n    end\n\n/* -------------------------------------- *\n | If do_compare is set to 1 then use the |\n | builtin function to run the native     |\n | ISPF Compare on the member or dataset. |\n * -------------------------------------- */\n if do_compare = 1 then do\n    'Builtin Compare' options\n    if rc > 0 then\n       Address ISPExec ,\n       'setmsg msg(isrz002)'\n    exit 0\n    end\n\n/* --------------------------------------- *\n | Get the current dataset characteristics |\n * --------------------------------------- */\n '(dataset) = dataset'\n '(member)  = member'\n Address ISPExec \"dsinfo dataset('\"dataset\"')\"\n  recfm = left(zdsrf,1)\n  lrecl = zdslrec + 0\n  blksize = zdsblk + 0\n\n Address ISPExec\n 'Control Errors Return'\n\n/* ------------------------------------------------- *\n | Parse the passed options and check to verify that |\n | the requested member and generation exist.        |\n * ------------------------------------------------- */\n parse value options with mbr gen\n mbr = translate(mbr)\n pdsemopt = 'T'\n \"LMINIT DATAID(zpdsendd) DATASET('\"dataset\"')\"\n \"LMOPEN DATAID(\"zpdsendd\") OPTION(INPUT)\"\n 'view dataid('zpdsendd') member('mbr') gen('gen')' ,\n        'macro(pdsegenm) parm(pdsemopt)'\n erc = rc\n\n if erc > 4 then do\n   zedsmsg = 'Invalid Member/Gen'\n   zedlmsg = 'The specified member:' mbr 'or Generation:' gen ,\n             'is not valid.'\n   'Setmsg msg(isrz001)'\n   \"LMClose Dataid(\"zpdsendd\")\"\n   \"LMFree  Dataid(\"zpdsendd\")\"\n   exit\n   end\n\n/* ----------------------------------------------- *\n | Call PDSEGENS for tempmem and default unit into |\n * ----------------------------------------------- */\n x = pdsegens()\n parse value x with  mail '/' etime '/' higen ,\n              '/' base_color '/' sort_color '/' clean ,\n              '/' prune_prompt '/' tempmem '/' def_unit ,\n              '/' x\n tempmem  = strip(tempmem)\n def_unit = strip(def_unit)\n if def_unit /= null then\n    def_unit = 'unit('def_unit')'\n\n/* ------------------------------------------------------- *\n | Check for current member being generation 0 and copy to |\n | a temp member for the compare                           |\n * ------------------------------------------------------- */\n Address ISPExec 'vget (agen mgen)'\n if agen /= 0 then do\n    hgen = gen\n    gen = agen\n    call create_temp 'xx'\n    gen  = hgen\n    odsn = tdsn\n    deltemp = 1\n    end\n\n/* -------------------------------------------------- *\n | Call the routine to create a temporary dataset for |\n | the requested member generation so the compare     |\n | can access it.                                     |\n * -------------------------------------------------- */\n call create_temp\n\n if odsn = null then do\n   /* ------------------------------------------------------- *\n    | Invoke the native ISPF Compare command to compare       |\n    | the current member with the requested member generation |\n    * ------------------------------------------------------- */\n    Address ISREdit\n\n    'Builtin Compare' tdsn 'exclude'\n\n    parse value '0 0 0' with line sline lline\n\n    'Locate first label'\n    if rc = 0 then do\n       '(lline) = cursor'\n       end\n\n    'Locate first special'\n    if rc = 0 then do\n       '(sline) = cursor'\n       end\n\n    if sline = 0 then sline = lline\n    if lline = 0 then lline = sline\n\n    if sline > lline then line = lline\n                     else line = sline\n\n    if line > 0 then\n       'Locate' line -1\n\n    if line = 0 then line = 1\n\n    msg = '===> Comparing current member' member 'to' mbr'('gen')'\n\n    if line > 1\n     then \"line_before\" line \"= MSGLine '\"msg\"'\"\n     else \"line_after 0 = MSGLine '\"msg\"'\"\n    end\n else do\n     /* ------------------------------------------- *\n      | Compare the temp member to the temp dataset |\n      * ------------------------------------------- */\n      Address ISPExec\n      cmem     = mbr\n      cto      = gen\n      cfrom    = mgen\n      todsn    = tdsn\n      pdsemopt = 'COM'\n      'vput (todsn deltemp cmem cfrom cto)'\n      'view dataset('odsn') confirm(no) chgwarn(no) macro(pdsegenm)' ,\n            'parm(pdsemopt)'\n      if deltemp = 1 then do\n         pdsedd = 'PCPR'random(999)\n         pdsedsn = \"'\"dataset\"'\"\n         Address TSO\n         'Alloc f('pdsedd') shr reuse ds('pdsedsn')'\n         x = pdsegdel(tempmem,0,pdsedd)\n         'Free f('pdsedd')'\n         end\n      end\n\n/* ---------------------------------------------- *\n | Now free the allocations and exit back to Edit |\n * ---------------------------------------------- */\n if odsn = null then\n    Address TSO ,\n        'Free f('tpdsendd') Delete'\n Address ISPExec\n\"LMClose Dataid(\"zpdsendd\")\"\n\"LMFree  Dataid(\"zpdsendd\")\"\n Exit\n\n/* --------------------------------------------------- *\n | Create_temp routine will copy the requested         |\n | member generation to a temporary dataset so         |\n | that the native ISPF Compare command can access it. |\n * --------------------------------------------------- */\n Create_Temp:\n    arg t_opt\n    if t_opt = null then do\n    tpdsendd = 'PDSET'random(999)\n    if sysvar('syspref') = null then hlq = sysvar('sysuid')\n                                else hlq = sysvar('syspref')\n    tdsn = \"'\"hlq'.PDSEGEN.TEMP.'tpdsendd'.'mbr\"'\"\n    Address TSO ,\n     'Alloc f('tpdsendd') ds('tdsn') new spa(15,50) tr' ,\n        'Recfm('recfm' B) lrecl('lrecl') blksize('blksize')' ,\n        def_unit\n    end\n    else tdsn = \"'\"dataset\"(\"tempmem\")'\"\n /* ---------------------------------- *\n  | Copy all records from 'old' mbr    |\n  | using the Replace Edit command     |\n  * ---------------------------------- */\n   pdsemopt = 'R'\n   pdsecpds = tdsn\n   'vput (pdsecpds)'\n   'view dataid('zpdsendd') member('mbr') gen('gen')' ,\n        'macro(pdsegenm) parm(pdsemopt)'\n return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDSEGDSL": {"ttr": 191, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01;\\x00C\\x01  \\x7f\\x01 %\\x0f\\x17I\\x01\\xe5\\x00$\\x00\\x00\\xd7\\xc4\\xe2\\xc5@@@@@@'", "ispf": {"version": "01.59", "flags": 0, "createdate": "2020-07-25T00:00:00", "modifydate": "2020-09-06T17:49:43", "lines": 485, "newlines": 36, "modlines": 0, "user": "PDSE"}, "text": "  /* --------------------  rexx procedure  -------------------- *\n  * Name:      PDSEGDSL                                        *\n  *                                                            *\n  * Function:  Process the PDSEGEN Data Set List Table         *\n  *                                                            *\n  * Usage Notes: Called by PDSEGEN when a request is made      *\n  *              for this table.                               *\n  *                                                            *\n  * Author:    Lionel B. Dyck                                  *\n  *                                                            *\n  * History:  (most recent on top)                             *\n  *            08/06/20 LBD - Allow alias on command line like *\n  *                           a number                         *\n  *                         - Allow member in dsname field     *\n  *            08/03/20 LBD - Add Max History to panel         *\n  *            08/02/20 LBD - Correct cursor if insert dsn bad *\n  *            07/31/20 LBD - Restructure and clean up         *\n  *            07/27/20 LBD - Refinement                       *\n  *            07/26/20 LBD - Refinement                       *\n  *            07/25/20 LBD - Creation                         *\n  *                                                            *\n  * ---------------------------------------------------------- *\n  * Copyright (c) 2017-2020 by Lionel B. Dyck                  *\n  * ---------------------------------------------------------- *\n  * Support is on a best effort and time available basis which *\n  * is why the complete source is provided for this application*\n  * so you can find and fix any issues you find. Please let    *\n  * me know if you do make changes/enhancements/fixes.         *\n  * ---------------------------------------------------------- *\n  * License:   This EXEC and related components are released   *\n  *            under terms of the GPLV3 License. Please        *\n  *            refer to the LICENSE file for more information. *\n  *            Or for the latest license text go to:           *\n  *                                                            *\n  *              http://www.gnu.org/licenses/                  *\n  * ---------------------------------------------------------- *\n  * ------------------- Soli Deo Gloria ---------------------- */\n  arg option\n  Address ISPExec\n  null = ''\n  zerrhm   = 'PDSEGH0'\n  zerralrm = 'NO'\n  zerrtp   = 'Notify'\n\n  /* ---------------------------- *\n  | if user max is 0 then return |\n  * ---------------------------- */\n  'vget (umaxhist maxhist) profile'\n  if umaxhist = 0 then return 0\n  if datatype(umaxhist) /= 'NUM'\n  then umaxhist = maxhist\n\n  /* ------------------------------------------------------------ *\n  | Open the ISPF Table of PDSEGEN Data Sets (PDSEGDSL) which is |\n  | stored in the ISPPROF referenced dataset since everyone has  |\n  | this allocated.                                              |\n  |                                                              |\n  | If the table does NOT exist then create it.                  |\n  |                                                              |\n  | Test for the PDSEDS01 variable and if found then convert the |\n  | old format variables to the new ISPF Table.                  |\n  |                                                              |\n  | Then erase the obsolete variables from the Profile.          |\n  * ------------------------------------------------------------ */\n  'tbopen pdsegdsl library(ispprof) write share'\n  if rc > 0 then do\n    call table_create\n    call check_oldstuff\n  end\n  call test_table\n\n  /* ------------------------------------------------------------ *\n  | Test for any passed option value.                            |\n  |                                                              |\n  | 1. If it contains a . then it is a dataset and will be added |\n  |    to the table at position 1.                               |\n  | 2. If it does not contain a . and it is numeric then return  |\n  |    the dataset at that position                              |\n  | 3. If it does not contain a . and is not numeric then check  |\n  |    if it is a dataset alias and return that dataset name     |\n  | 4. if all the above fails then display the table             |\n  * ------------------------------------------------------------ */\n  if option /= null then\n  if option /= '?' then do\n    if pos('.',option) > 0 then do\n      zs = 0\n      dsloc = 5\n      if pos('(',option) > 0\n      then do\n        parse value option with option'('omem')'ro\n        option = option''ro\n      end\n      else omem = null\n      x = listdsi(option)\n      if x > 0 then do\n        zerrsm = null\n        zerrlm = option sysmsglvl2\n        'setmsg msg(isrz003)'\n        return 0\n      end\n      if omem /= null then sysdsname = sysdsname\"(\"omem\")\"\n      tdsn = \"'\"sysdsname\"'\"\n      x = does_dsn_exist()\n      if x = 0 then call do_return 0\n      pdsn = tdsn\n      zs = 0\n      dsloc = 5\n      palias = null\n      lastref = date('j')\n      lastref = left(lastref,2)'.'right(lastref,3)\n      'tbadd pdsegdsl'\n      x = update_zs(0)\n      call test_table_count\n      call do_return 0\n    end\n    if left(option,1) = '>' then\n    parse value option with one_time 2 option\n    else one_time = null\n    'tbtop pdsegdsl'\n    do forever\n      'tbskip pdsegdsl'\n      if rc > 0 then do\n        if one_time /= null then call do_return 0\n        zerrsm = null\n        zerrlm = 'Requested file not found:' option\n        'setmsg msg(isrz003)'\n        leave\n      end\n      select\n        when datatype(option) = 'NUM' then do\n          if zs = option then\n          call do_return pdsn\n        end\n        otherwise do\n          if option = palias then\n          call do_return pdsn\n        end\n      end\n    end\n  end\n\n  /* --------------------------------------------------------- *\n  | Time to display the table to allow the user to manage the |\n  | table and/or select a dataset to work with.               |\n  * --------------------------------------------------------- */\n  option = null\n  'tbtop pdsegdsl'\n  dtop = 1\n  arow = null\n  do forever\n    dsel = null\n    if ztdsels > 1 then do\n      'tbdispl pdsegdsl'\n    end\n    else do\n      update = 0\n      sort = 0\n      dloc = 0\n      umhist = umaxhist\n      'tbtop pdsegdsl'\n      'tbskip pdsegdsl number('dtop')'\n      if arow = null\n      then 'tbdispl pdsegdsl panel(pdsegdsl)'\n      else 'tbdispl pdsegdsl panel(pdsegdsl)' ,\n        'csrrow('arow') cursor(pdsn)'\n      arow = null\n    end\n    if rc > 4 then leave\n    if umhist /= umaxhist then do\n      umaxhist = umhist\n      'vput (umaxhist) profile'\n      call test_table_count\n    end\n    dtop = ztdtop\n    if ztdsels > 0 then\n    if dsel = null then do\n      if row > 0 then\n      if pos = 'DSEL'\n      then dsel = 'S'\n      else dsel = 'U'\n      if row = 0 then do\n        s_palias = palias\n        'tbtop pdsegdsl'\n        'tbscan pdsegdsl arglist(pdsn) rowid(row)'\n        dsel = 'U'\n        palias = s_palias\n      end\n    end\n    Select\n      When zcmd = 'EXIT' then leave\n      When zcmd /= null then call do_zcmd\n      Otherwise if dsel /= null then do\n        call do_dsel\n      end\n    end\n  end\n  call do_return 0\n\n  /* ------------------------------------ *\n  | Return after save/close of the table |\n  * ------------------------------------ */\nDo_Return:\n  arg return_value\n  'tbclose pdsegdsl replcopy library(ispprof)'\n  if pos('(',return_value) > 0 then do\n     parse value return_value with return_value'('rm')'rd\n     return_value = return_value''rd rm\n     end\n  Exit  return_value\n\n  /* --------------------- *\n  | Create the ISPF Table |\n  * --------------------- */\nTable_Create:\n  'tbcreate pdsegdsl names(pdsn zs palias dsloc lastref) write' ,\n    'library(ispprof) share'\n  return\n\n  /* -------------------- *\n  | Process any commands |\n  * -------------------- */\ndo_zcmd:\n  Select\n    When datatype(zcmd) = 'NUM' then do\n      'tbtop pdsegdsl'\n      'tbskip pdsegdsl number('zcmd')'\n      if rc = 0 then\n      call do_return pdsn\n      else do\n           zerrsm = 'Invalid.'\n           zerrlm = zcmd 'is not a valid row selection. Select a row' ,\n             'number from 1 to' rownum + 0 'and try again.'\n           'setmsg msg(isrz003)'\n           end\n    end\n    When zcmd = 'CLEAR' then do\n      'tbclose pdsegdsl library(ispprof)'\n      'tberase pdsegdsl library(ispprof)'\n      call table_create\n      dtop = 1\n    end\n    /* ---------------- *\n    | Insert a dataset |\n    |  - blank         |\n    |  - dataset       |\n    |  - dataset alias |\n    * ---------------- */\n    When abbrev('INSERT',word(zcmd,1),1) = 1 then do\n      zs = 1\n      pdsn = word(zcmd,2)\n      if pdsn /= null then do\n        if pos('(',pdsn) > 0\n        then do\n          parse value pdsn with pdsn'('pmem')'rdsn\n          pdsn = pdsn\"\"rdsn\n        end\n        else pmem = null\n        x = listdsi(pdsn)\n        if x > 0 then do\n          zerrsm = 'Error.'\n          zerrlm = pdsn sysmsglvl2\n          'setmsg msg(isrz003)'\n        end\n        else do\n          if pmem = null\n          then pdsn = \"'\"sysdsname\"'\"\n          else pdsn = \"'\"sysdsname\"(\"pmem\")'\"\n        end\n      end\n      palias = word(zcmd,3)\n      dsloc = 1\n      'tbtop pdsegdsl'\n      'tbadd pdsegdsl'\n      x = update_zs(0)\n      arow = 1\n      update = 1\n      ztdsels = 0\n      zcmd = null\n      dtop = 1\n    end\n    When abbrev('SORT',zcmd,1) = 1 then do\n      'tbsort pdsegdsl fields(pdsn,c,a)'\n      x = update_zs(0)\n    end\n    When abbrev('SORTD',zcmd,1) = 1 then do\n      'tbsort pdsegdsl fields(pdsn,c,d)'\n      x = update_zs(0)\n    end\n    Otherwise do\n      'tbtop pdsegdsl'\n      do forever\n        'tbskip pdsegdsl'\n        if rc > 0 then leave\n        if zcmd = palias then call do_return pdsn\n      end\n    end\n  end\n  return\n\n  /* ------------------------------------------ *\n  | Update the table row counters and location |\n  * ------------------------------------------ */\nUpdate_zs:\n  arg dc\n  'tbtop pdsegdsl'\n  dloc = 0\n  do forever\n    'tbskip pdsegdsl'\n    if rc > 0 then leave\n    dc = dc + 1\n    zs = dc\n    dloc = dloc +100\n    dsloc = dloc\n    'tbput pdsegdsl'\n  end\n  return 0\n\n  /* --------------------------------------------------------------- *\n  | Process Row Selections                                          |\n  | - no selection but a change in the row then just update the row |\n  | - R will remove the row (delete)                                |\n  | - M will move the row to the top                                |\n  | - I will inser a row below the current row                      |\n  * --------------------------------------------------------------- */\ndo_dsel:\n  Select\n    When dsel = 'U' then do\n      spdsn = pdsn\n      spalias = palias\n      szs = zs\n      zdsloc = dsloc\n      if pos('(',spdsn) = 0\n      then pmem = null\n      else do\n        parse value spdsn with spdsn'('pmem')'rdsn\n        spdsn = spdsn\"\"rdsn\n      end\n      x = listdsi(spdsn)\n      if x > 0 then do\n        zerrsm = 'Error.'\n        zerrlm = spdsn 'is not a valid dataset name or does not exist:' ,\n          sysmsglvl2\n        'setmsg msg(isrz003)'\n        arow = row\n      end\n      else do\n        if pmem = null\n        then spdsn = \"'\"sysdsname\"'\"\n        else spdsn = \"'\"sysdsname\"(\"pmem\")'\"\n      end\n      pdsn = spdsn\n      palias = spalias\n      zs = 1\n      dsloc = 10\n      'tbput pdsegdsl'\n      update = 1\n    end\n    When dsel = 'S' then call do_return pdsn\n    When dsel = 'I' then do\n      dsloc = dsloc + 5\n      pdsn = null\n      palias = null\n      'tbadd pdsegdsl'\n      arow = row + 1\n      update = 0\n    end\n    When dsel = 'R' | dsel = 'D' then do\n      'tbdelete pdsegdsl'\n      update = 1\n    end\n    when dsel = 'M' then do\n      dloc = dloc + 1\n      dsloc = dloc\n      zs = 1\n      'tbput pdsegdsl'\n      sort = 1\n      update = 1\n      dtop = 0\n    end\n    otherwise nop\n  end\n  if ztdsels = 1 then\n  if update = 1 then do\n    if sort = 1 then\n    'tbsort pdsegdsl fields(dsloc,n,a)'\n    x = update_zs(0)\n    sort = 0\n    update = 0\n  end\n  return 0\n\nDoes_DSN_Exist:\n  'tbtop pdsegdsl'\n  do forever\n    'tbskip pdsegdsl'\n    if rc > 0 then return 4\n    if pdsn = tdsn then do\n      lastref = date('j')\n      lastref = left(lastref,2)'.'right(lastref,3)\n      'tbput pdsegdsl'\n      return 0\n    end\n  end\n  return\n\n  /* ---------------------------------------------------------- *\n  | Test the table to see if the last reference field is there |\n  | and if not recreate the table with it.                     |\n  * ---------------------------------------------------------- */\nTest_Table:\n  'tbquery pdsegdsl names(rows) rownum(rownum)'\n  if pos('LASTREF',rows) > 0 then return\n  tc = 0\n  'tbtop pdsegdsl'\n  do forever\n    'tbskip pdsegdsl'\n    if rc > 0 then leave\n    tc = tc + 1\n    r.tc =  pdsn palias\n  end\n  'tbclose pdsegdsl library(ispprof)'\n  'tberase pdsegdsl library(ispprof)'\n  call table_create\n  dsloc = 0\n  do i = 1 to tc\n    zs = 1\n    dsloc = dsloc + 10\n    lastref = date('j')\n    lastref = left(lastref,2)'.'right(lastref,3)\n    parse value r.i with pdsn palias\n    'tbadd pdsegdsl'\n  end\n  x = update_zs(0)\n  return\n\n  /* ------------------------------------------------------------- *\n  | Test if the table has reached the defined limit plus 1 and if |\n  | so then delete all entries over the limit (typically that     |\n  | should only be one row).                                      |\n  * ------------------------------------------------------------- */\nTest_Table_Count:\n  'tbquery pdsegdsl rownum(rows)'\n  'tbsort pdsegdsl fields(lastref,n,d)'\n  remove = rows - umaxhist + 1\n  'tbtop pdsegdsl'\n  do ttr = 1 to remove\n    'tbskip pdsegdsl'\n    if rc > 0 then leave\n    if palias /= null then do\n      iterate\n    end\n    'tbdelete pdsegdsl'\n  end\n  'tbsort pdsegdsl fields(dsloc,n,a)'\n  x = update_zs(0)\n  return\n\nCheck_OldStuff:\n  'vget (pdseds01 pdseds02 pdseds03 pdseds04' ,\n    'pdseds05 pdseds06 pdseds07 pdseds08' ,\n    'pdseds09 pdseds10 pdseds11 pdseds12' ,\n    'pdseds13 pdseds14 pdseds15 pdseds16 ' ,\n    'pdseds17 pdseds18 pdseds19 pdseds20 ' ,\n    'pdseds21 pdseds22 pdseds23 pdseds24 ' ,\n    'pdseds25)' ,\n    'profile'\n  if rc = 0 then do\n    do i = 1 to 25\n      interpret 'pdsn = pdseds'right(i+100,2)\n      if pdsn = null then iterate\n      zs = i\n      dsloc = i * 100\n      'tbadd pdsegdsl'\n    end\n  end\n  'tbsave pdsegdsl library(ispprof)'\n  'verase (pdseds01 pdseds02 pdseds03 pdseds04' ,\n    'pdseds05 pdseds06 pdseds07 pdseds08' ,\n    'pdseds09 pdseds10 pdseds11 pdseds12' ,\n    'pdseds13 pdseds14 pdseds15 pdseds16 ' ,\n    'pdseds17 pdseds18 pdseds19 pdseds20 ' ,\n    'pdseds21 pdseds22 pdseds23 pdseds24 ' ,\n    'pdseds25)' ,\n    'profile'\n  Return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDSEGEN": {"ttr": 197, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05c\\x008\\x01\\x18\\t\\x7f\\x01 4\\x9f\\x06\\x17\\x1a\\x0c\\x17\\x9d\\x00\\x00\\xd7\\xc4\\xe2\\xc5@@@@@@'", "ispf": {"version": "05.99", "flags": 0, "createdate": "2018-04-07T00:00:00", "modifydate": "2020-12-14T06:17:38", "lines": 6668, "newlines": 6045, "modlines": 0, "user": "PDSE"}, "text": "  /* --------------------  rexx procedure  -------------------- */\n  pdsegver = pdsegver()\n  /* Name:      pdsegen                                         *\n  *                                                            *\n  * Function:  Display a PDSE member list with generations     *\n  *            and allow Browse, Edit, View on all members     *\n  *                                                            *\n  * Syntax:    %pdsegen  dsn filter SET=x \\ flags              *\n  *                                                            *\n  * If a dataset name is not provided then a prompting panel   *\n  * will be displayed.                                         *\n  *                                                            *\n  * If a dataset name of * is provided then the PDSEGEN        *\n  * change dataset selection list will be displayed.           *\n  *                                                            *\n  * If a dataset name of ? is provided then the ISPF Tutorial  *\n  * will be presented and when the tutorial ends the dialog    *\n  * will start.                                                *\n  *                                                            *\n  * filter is any valid member name filter or a date filter.   *\n  *                                                            *\n  * SET defines the default Select option (B,E,V,/)            *\n  * If not specified then will use the default or the          *\n  * value set using the dialog or the SET command.             *\n  *                                                            *\n  * SET= may be anywhere in the parameters                     *\n  *                                                            *\n  * flags may be Time to enable time reporting or HIGEN        *\n  * to display HIGEN members, or both.                         *\n  *                                                            *\n  * If flags is E or Edit then if the member name has no mask  *\n  * then the member will be edited.                            *\n  *                                                            *\n  * Note: Must be started in any ISPF APPLID other than PDSE   *\n  *       so that the ISPF command table can be built and      *\n  *       then the exec is reinvoked under the PDSE APPLID.    *\n  *                                                            *\n  * Commands:  Backup the PDSE with generations                *\n  *            Browse member                                   *\n  *            C or C dsname to change to another PDSE         *\n  *            HIGEN to add HIGEN members to the display       *\n  *              or HIGEN ? to display short tutorial          *\n  *            Compare member from-mem to-mem                  *\n  *            Copy to copy current PDSE to another/new PDSE   *\n  *            Edit member                                     *\n  *            Filter member-mask (*x, x*, x:, x/ or /x or OFF *\n  *            Find 'string'                                   *\n  *            GENOnly - hide all base members (toggle)        *\n  *            Hide - hide all generations (toggle)            *\n  *            ID char(s) - display only members with the      *\n  *                         characters.                        *\n  *            Info to display info on the dataset (PDSE only) *\n  *            Locate member or member*                        *\n  *            MIne - display only active users members        *\n  *            Model - Allocate a new dataset based on the     *\n  *                  allocation info of the active dataset     *\n  *            OPtions to prompt for a PDSEGEN command         *\n  *            Output to create a file with all members and    *\n  *                   information                              *\n  *            Prune to remove old generations                 *\n  *                  or to delete ALL members/generations      *\n  *            Reflist - List last 30 data sets referenced to  *\n  *                  select a data set from                    *\n  *            Refresh - rebuild the member list               *\n  *            Reset is an alias of Refresh that isn't doc'd   *\n  *            Restore - restore a backup pdse                 *\n  *            S member (alias of Edit member)                 *\n  *            Set to change the action for the S line option  *\n  *            Sort Create, Change, Size, or Userid A/D        *\n  *              - only one at a time                          *\n  *              - A for ascending and D for descending        *\n  *            Submit - to submit a member or members          *\n  *            Validate using IEBPDSE                          *\n  *              - if clean is enabled in PDSEGENS then the    *\n  *                validate will also force a clean for all    *\n  *                pending deletes.                            *\n  *            View member                                     *\n  *            Today, Week, Month, Year, Since yy/mm/dd,       *\n  *                Since -nn (toggles)                         *\n  *                                                            *\n  * Selection options:                                         *\n  * Short - Long - Description                                 *\n  * A Attrib   - Attributes (Ver/Mod/Userid) (gen 0 only)      *\n  * B Browse   - Browse                                        *\n  * C COPy     - Copy a member to another PDSE/PDS (gen 0 only)*\n  *            - Will also copy all generations                *\n  * D Delete   - Delete                                        *\n  * E Edit     - Edit     (for gen 0 only)                     *\n  *              converted to V for non-0 gen                  *\n  * G RECover  - Recover  (for non-0 generations)              *\n  * H Hide     - Hide the current row                          *\n  * I Info     - display Info on the individual member/gen     *\n  * J Submit   - Submit the member (JCL) to the internal       *\n  *              reader                                        *\n  * K Klone    - Clone the member (gen 0 only)                 *\n  *   CLone      generations are not cloned                    *\n  * M MAil     - Mail the member (if enabled)                  *\n  * P Promote  - Promote  (for non-0 generations)              *\n  * R REName   - reName the member and all generations         *\n  *            - prompt for option                             *\n  * S Select   - Select   (based on the prompt panel           *\n  * U User     - User command                                  *\n  * V View     - View                                          *\n  * X EXecute  - eXecute the member (rexx only)                *\n  * Z COMpare  - Compare  (for gen 0 to non-0 generation)      *\n  * /          - prompt for option                             *\n  * =          - repeat last used line command                 *\n  *                                                            *\n  * Notes:                                                     *\n  *   0. Generation browse/edit/view only works with z/OS 2.1  *\n  *      and later.                                            *\n  *   1. Multiple members may be selected for Browse or View   *\n  *      but Edit will only work if the member IS NOT          *\n  *      saved or updated.  If a member is saved or updated    *\n  *      then all rows for that member are deleted and         *\n  *      re-added to include the updated generation info.      *\n  *   2. It shouldn't have to be stated but generations are    *\n  *      only supported for PDSE Version 2 datasets where      *\n  *      generations have been enabled.                        *\n  *   3. Promote will take the specified generation and have   *\n  *      it replace the base generation.                       *\n  *   4. Recover will take the specified generation and prompt *\n  *      for a new member to copy it into.                     *\n  *   5. Refresh will completely rebuild the member list.      *\n  *   6. The Compare command will ONLY accept relative         *\n  *      generations number (e.g. -n)                          *\n  *   7. The Locate command uses tbskip and compare to get     *\n  *      close to the requested member if an exact isn't found *\n  *   8. The mail option must be enabled - see PDSEGENS exec.  *\n  *   9. The elapsed time display may be enabled or disabled   *\n  *      see PDSEGENS exec.                                    *\n  *  10. The COPY function uses the PDSEGENC exec for the      *\n  *      processing.                                           *\n  *  11. Aliases are NOT support by this application.          *\n  *  12. If you prefer to show HIGEN members to your users     *\n  *      then update PDSEGENS to change the HIGEN variable     *\n  *      to 1.                                                 *\n  *  13. Filter will limit the members, with their generations *\n  *      that are displayed.                                   *\n  *         x: will filter for members starting with x         *\n  *         x/ will filter for members with x anywhere         *\n  *         /x will filter for members with x anywhere         *\n  *         % will match any single character                  *\n  *         * will match any number of characters              *\n  *         /x will filter for members with x anywhere         *\n  *         OFF will turn off filtering                        *\n  *  14. Find searches all members in the member display. To   *\n  *      speed up the find use a filter before find            *\n  *  15. When Hide is active, Delete, Prune, and Rename are    *\n  *      not available.                                        *\n  *                                                            *\n  * Author:    Lionel B. Dyck                                  *\n  *            lbdyck@gmail.com                                *\n  *                                                            *\n  * Acknowledgement: Thanks to Thomas Reed of IBM for his      *\n  *                  presentation at SHARE Session 16957 at    *\n  *                  Seattle 2015                              *\n  *                                                            *\n  *                  MAJOR thanks to John Kalinich, Bill Smith,*\n  *                  and Bruce Koss for their testing and      *\n  *                  constructive feedback on this tool        *\n  *                                                            *\n  *                  Thanks to John Kalinich for many useful   *\n  *                  contributions to the code.                *\n  *                                                            *\n  *                  Special THANKs to Greg Price for updating *\n  *                  a REXX Function from Rem Perretta via     *\n  *                  Xephon to provide the PDSE generation     *\n  *                  info and to John Kalinich who helped me.  *\n  *                                                            *\n  *                  Special THANKs to Salvador Carrasco whose *\n  *                  code, IRXF@MAT, I found on CBT File 386   *\n  *                  and have incorporated as PDSEGMAT.        *\n  *                                                            *\n  * History:                                                   *\n  *          12/14/20 - v5.8.5 - Correct return if recfm=u     *\n  *          09/17/20 - v5.8.3 - Enhance cursor location       *\n  *          08/11/20 - v5.8.2 - Free MODEL allocation         *\n  *          08/07/20 - v5.8.1 - Support dsname(mem)           *\n  *          08/03/20 - v5.8.0 - Fix bug if invalid dsn        *\n  *          08/02/20 - v5.7.9 - Add SETMSG if C dsn invalid   *\n  *          07/26/20 - v5.7.7 - Add TPC command to invoke PDS *\n  *                            - Change ? to use new PDSEGDSL  *\n  *                            - Support PDSEGENS MaxHist var  *\n  *          07/09/20 - v5.7.6 - Correct bug Edit new member   *\n  *          06/03/20 - v5.7.4 - Remove member cursor and fix  *\n  *                              bugs introduced by that       *\n  *          06/02/20 - v5.7.3 - Correct Scrolling bug         *\n  *          06/01/20 - v5.7.2 - Correction for member cursor  *\n  *          05/27/20 - v5.7.1 - Fix cursor positioning        *\n  *          04/22/20 - v5.7.0 - Support flag of E/Edit        *\n  *                            - Add flag of *Kloned for the   *\n  *                              cloned member (eye catcher)   *\n  *                            - Update to support use of      *\n  *                              Compare with SAVELAB          *\n  *          03/09/20 - v5.6.7 - Fix code bug in Model         *\n  *                            - If invalid line command report*\n  *          03/02/20 - v5.6.6 - New option to use Action Bar  *\n  *          02/28/20 - v5.6.5 - New option to use Action Bar  *\n  *                              panels on SET menu.           *\n  *                            - Action Bars are now default   *\n  *          01/31/20 - v5.6.4 - Implement an Initial Edit     *\n  *                              Macro by dataset suffix       *\n  *                              Commands: SETMACRO or SM      *\n  *          01/18/20 - v5.6.3 - Prevent Copy from/to the same *\n  *                              dataset.                      *\n  *          01/08/20 - v5.6.2 - Enable G (Recover) on Orphan  *\n  *                              member base 0 (agen >0)       *\n  *          12/11/19 - v5.6.1 - Add AGE command (thx JK)      *\n  *          11/18/19 - v5.6.0 - Change ISRZ002 to ISRZ003     *\n  *                            - Fix E XX (new member) issue   *\n  *          10/10/19 - v5.5.9 - Correction to mod size parse  *\n  *                            - Improve PFSHOW routine        *\n  *                            - Clean up Z compare process    *\n  *                            - Allow C 'dsname and add close *\n  *                              quote.                        *\n  *          08/21/19 - v5.5.7 - Add setmsg after b/e/v        *\n  *                            - Enable Find for non-MG DS     *\n  *                            - Support filter from:to        *\n  *                            - Correct Sort ID               *\n  *                            - Support filter (x y z) with   *\n  *                              masking                       *\n  *                            - Correct INIT sorting          *\n  *          07/22/19 - v5.5.6 - Allow Options abbrev of O     *\n  *          06/25/19 - v5.5.5 - Check Backup return code      *\n  *                            - Fix C * after using REFList   *\n  *                            - Fix E XX if filter X/ and XX  *\n  *                              does not exist (yet)          *\n  *          06/05/19 - v5.5.4 - Add REFLIST command (thx JK)  *\n  *                            - Change disp_change (PDSEGENS) *\n  *          04/29/19 - v5.5.3 - Correct entry/exit processing *\n  *          04/27/19 - v5.5.2 - Restore * calling parm        *\n  *          04/24/19 - v5.5.1 - Improve Prefix/Noprefix use   *\n  *                            - Add option T (for Tryit)      *\n  *          03/07/19 - v5.5.0 - Add Row/Column to Addpops     *\n  *                            - Add Addpop for panel PDSEGENI *\n  *                            - Improved msgs for Block cmds  *\n  *          02/22/19 - v5.4.9 - Update msg options if zOSOK   *\n  *          12/31/18 - v5.4.8 - Small change from JK if the   *\n  *                              requested data set is not     *\n  *                              RECFM F or V.                 *\n  *          12/20/18 - v5.4.7 - Change call to XMITIPFE (mail)*\n  *                              to ISPF Select so that if     *\n  *                              mail not installed can get    *\n  *                              error message.                *\n  *          12/19/18 - v5.4.6 - Correction to message when    *\n  *                              browsing a PDSE with MAXGEN   *\n  *                              of zero                       *\n  *          10/22/18 - v5.4.4 - Add ID and MINE commands      *\n  *                            - Correct support for 8 char    *\n  *                              userids (thx JK)              *\n  *          08/22/18 - v5.4.3 - Small update to eliminate     *\n  *                              setmsg after edit if rc <= 4  *\n  *          04/30/18 - v5.4.0 - Add Numeric Digits 10 for     *\n  *                              system limit check (thx Marv) *\n  *                            - Clean up the member Info disp *\n  *                            - Renamed table panels and added*\n  *                              a set with and without the    *\n  *                              absolute generation number    *\n  *          04/12/18 - v5.3.1 - Fix edit cancel that was      *\n  *                              broken with 5.3.0             *\n  *          04/10/18 - v5.3.0 - Require REST instead of RES   *\n  *                              for Restore                   *\n  *                            - Change RESET to an alias of   *\n  *                              Refresh instead of Prune      *\n  *                            - Change USER column to ID      *\n  *                              and change SORT USER to ID    *\n  *                            - Allow F instead of FIN        *\n  *                              for Find                      *\n  *                            - Find will now also find string*\n  *                              in the member name            *\n  *                            - Improve filter time if the    *\n  *                              filter ends in *              *\n  *                            - Improve filter time if the    *\n  *                              filter starting with *        *\n  *                            - Correct intial panel prompt   *\n  *                              failure if a filter is used   *\n  *                            - Update for z/OS 2.1 for scroll*\n  *                              returning command table       *\n  *          04/03/18 - v5.2.3 - Check member name from status *\n  *                              field for validity (G, K, R)  *\n  *                            - For G, K, and R make sure the *\n  *                              target member does not exist  *\n  *                            - Clean up logging messages     *\n  *          03/31/18 - v5.2.2 - Add RenSwap or Q to support   *\n  *                              Rename Swap for a member      *\n  *                            - correct bug in  dsn parse     *\n  *          03/27/18 - v5.2.1 - Correct TBSort typos          *\n  *                            - Add IBM FileManager variable  *\n  *          03/26/18 - v5.2.0 - Improve performance           *\n  *                              - initial table build         *\n  *                              - replace tbmod with tbput    *\n  *                              - remove ORDER from TBADD     *\n  *                              - eliminate extra call to     *\n  *                                table rebuild on mbr changes*\n  *                            - Check for Dummy flag from geni*\n  *                            - E mask will only work on gen 0*\n  *                            - Support B/V/E * -n            *\n  *                            - Clean up to retain last opt   *\n  *                              after an Edit                 *\n  *                            - For HIGen check for dummy gen *\n  *                              flag from pdsegeni            *\n  *                            - Fix OUTPUT alignment          *\n  *                            - Fix Sort size, init, mod      *\n  *          03/09/18 - v5.1.8 - Add logging of startup        *\n  *                            - minor code cleanup            *\n  *                            - Add more comments             *\n  *                            - Remove PDSECMDS table and use *\n  *                              CONTROL LRSCROLL command      *\n  *                            - Remove HELP primary command   *\n  *                              as PF1 works just fine        *\n  *          02/27/18 - v5.1.7 - Change tbend to tbclose       *\n  *                            - Update to new randstr routine *\n  *          02/22/18 - v5.1.6 - Change to new random routine  *\n  *          02/16/18 - v5.1.5 - Fix to not update the member  *\n  *                              list for b/e/v if member not  *\n  *                              in the filter                 *\n  *                            - Change from random to time(s) *\n  *                              to get random variables       *\n  *          02/13/18 - v5.1.4 - Fix hlq for OUTPUT command if *\n  *                              NOPREFIX in use               *\n  *          02/02/18 - v5.1.3 - Support empty pds/pdse        *\n  *                            - Enable C > after Model        *\n  *                            - Enable Z (compare) on gen 0   *\n  *                              to display the Compare prompt *\n  *                            - Add short message on unknown  *\n  *                              primary and line options.     *\n  *                            - Validate Rename target        *\n  *                            - Improve Rename prompting      *\n  *          01/25/18 - v5.1.2 - Change last used option var   *\n  *                              for short and long panels     *\n  *          01/24/18 - v5.1.1 - Fix tbvclear error            *\n  *                            - Change TBCreate and TBAdds    *\n  *          01/04/18 - v5.1.0 - Support C > to change to      *\n  *                              the COPY target Dataset       *\n  *                            - Check B/E/S/V commands for    *\n  *                              a member name/mask            *\n  *                            - New OPtions command to prompt *\n  *                              for a PDSEGEN command         *\n  *                            - Update no generation warning  *\n  *                              message                       *\n  *                            - Correctly add dsnames to the  *\n  *                              dataset list if noprefix      *\n  *                            - Display line selection popup  *\n  *                              on invalid selections         *\n  *                            - Add aliases to FIND for SRCh  *\n  *                              and SEArch                    *\n  *                            - Correct issue with sort colors*\n  *                              for sorted/unsorted columns   *\n  *          12/18/17 - v5.0.2 - Allow member name/mask on     *\n  *                              a dsname in the comamnd       *\n  *                              e.g. sys1.parmlib(ieasys*)    *\n  *                            - Correct bug for dslist > 16   *\n  *          12/03/17 - v5.0.1 - Change to MODEL (JK) alloc    *\n  *                            - Allow opening empty PDS/PDSE  *\n  *                            - Log all PDSEGEN commands      *\n  *          12/01/17 - v5.0.0 - Change 1 char comamnds:       *\n  *                              C (Compare) becomes Z         *\n  *                              R (Recover) becomes G         *\n  *                              N (reName) becomes R          *\n  *                              C will now be COPy to new DS  *\n  *                              R will now be REName          *\n  *                            - Alloc filter of ? to be       *\n  *                              converted to %                *\n  *                            - Add MODEL command to allocate *\n  *                              a new dataset based on the    *\n  *                              active dataset.               *\n  *                            - Correct initial sort order    *\n  *                            - Change HIGEN relative gen to -*\n  *                              a - instead of x'ff'          *\n  *                            - Speed up HIGen off process    *\n  *                            - Allow non-PDS/PDSE by calling *\n  *                              ISPF 3.4 (DSLIST)             *\n  *                            - Support 9 character selection *\n  *                              and enhance left/right panels *\n  *                              rotation                      *\n  *                            - Increase DSList from 16 to 25 *\n  *                            - Allow any line selection to   *\n  *                              be a block command XX/XX or   *\n  *                              X99999                        *\n  *                            - Support expanded commands     *\n  *                            - Support expanded Block cmds   *\n  *                              by doubling the 1st character *\n  *                            - Expanded commands block by    *\n  *                              doubling the 1st character    *\n  *                              but no counts allowed         *\n  *                            - For Expanded display show full*\n  *                              line command selection in     *\n  *                              the status field              *\n  *                            - Enable the expanded status    *\n  *                              field as input and use for    *\n  *                              N (rename), K (klone), and    *\n  *                              R (recover) to use the status *\n  *                              as the target name.           *\n  *                            - If user commands have / in the*\n  *                              status field then prompt, if  *\n  *                              not then just execute passing *\n  *                              the dataset(member) or temp   *\n  *                              dataset (if generation)       *\n  *                            - Add Transfer line selection   *\n  *                              to copy to another PDSE/PDS   *\n  *                            - Add option (see PDSEGENS) to  *\n  *                              display the Changes tutorial  *\n  *                              panel when the version changes*\n  *          11/08/17 - v4.5.0 - Allow E * with filter         *\n  *                              and if filter member doesn't  *\n  *                              exist.                        *\n  *                            - Support using empty PDS/PDSE  *\n  *                            - Fix Time display if cpu=time  *\n  *                            - Increase DSList from 15 to 16 *\n  *                            - Enable DSList remove for last *\n  *                              active dataset                *\n  *                            - Remove unexpected SORT with   *\n  *                              HIGEN command                 *\n  *                            - Fix sort after table change   *\n  *          10/20/17 - v4.4.9 - Improve warning message text  *\n  *                              when attempts are made to     *\n  *                              process a dummy member (jk)   *\n  *                            - At close null the zcmd var    *\n  *                            - For eXec selection prompt for *\n  *                              execution parms               *\n  *          10/11/17 - v4.4.8 - Tweaks to clean up code       *\n  *                            - Add more info to \\ time info  *\n  *          09/29/17 - v4.4.7 - Allow copy to dsn on COPY     *\n  *                            - Changed RESTORE command to    *\n  *                              call PDSEGRST                 *\n  *                            - Update member info (I) display*\n  *                              with accurate current/init    *\n  *                              counts if > 99k               *\n  *          09/19/17 - v4.4.6 - Improve the INFo metrics      *\n  *                              display with generation info  *\n  *                            - Update allocation on COPY to  *\n  *                              allow changing space units    *\n  *          09/14/17 - v4.4.5 - Additional performance updates*\n  *                            - improved pending delete       *\n  *                              awareness                     *\n  *                            - Performance tweak using tbscan*\n  *                              instead of tbskip/compare in  *\n  *                              many places                   *\n  *          09/05/17 - v4.4.4 - Bug fix to resolve issue with *\n  *                              edit command for member that  *\n  *                              was deleted outside pdsegen   *\n  *          09/01/17 - v4.4.3 - Improve Submit long message   *\n  *                              in the case where submit fails*\n  *                              And test DCB before Submit    *\n  *          09/01/17 - v4.4.2 - Enable B/E/Sub/V on members   *\n  *                              not in the active member list *\n  *                            - And make them work the way one*\n  *                              expects                       *\n  *                            - Use pdsegdel for all deletes  *\n  *          08/29/17 - v4.4.1 - Enable commands:              *\n  *                              B member, B *                 *\n  *                              E member, E *                 *\n  *                              V member, V *                 *\n  *                              by making browse, edit, view  *\n  *                              sub-routines                  *\n  *                            - New H (hide) line option      *\n  *                            - Add SUBmit command            *\n  *                              SUB member or SUB *           *\n  *                            - Update OUTPUT to use 4 digit  *\n  *                              year for dates in the report  *\n  *                            - Clean up old change history   *\n  *                              entries - see panel PDSEGHCG  *\n  *                              for entire history.           *\n  *                            - Bug fix if filter find nada   *\n  *          08/16/17 - v4.4.0 - Clean up message isrz002 if   *\n  *                              pds doesn't have members gens *\n  *                            - Clean up message isrz002 after*\n  *                              browse in a pds without gens  *\n  *          08/14/17 - v4.3.9 - Change to use pdsegver to get *\n  *                              the version of the pdsegen    *\n  *                              package                       *\n  *          07/05/17 - v4.3.9 - Back to using LMMDEL but with *\n  *                              LMINIT ENQ(SHRW)              *\n  *          07/03/17 - v4.3.8 - Change LMMDEL to TSO Delete   *\n  *          06/20/17 - v4.3.7 - Add PFSHOW routine and use    *\n  *                              around addpop/rempop          *\n  *                            - If line selection unknown then*\n  *                              issue msg and change to /     *\n  *                            - If PDS/PDSE not generation    *\n  *                              enabled use LMMDEL for deletes*\n  *          06/12/17 - v4.3.6 - Allow ? for pdsedsn to display*\n  *                              the tutorial to start with    *\n  *          06/08/17 - v4.3.5 - Fix problem with dsn=* on exit*\n  *          05/30/17 - v4.3.4 - Update to set last option for *\n  *                              mail                          *\n  *          05/19/17 - v4.3.3 - Use Edit Macro Parm instead   *\n  *                              if variable pool              *\n  *          04/26/17 - v4.3.2 - Fix bug in Dummy detection    *\n  *          04/20/17 - v4.3.1 - Add error message if edit     *\n  *                              member fails                  *\n  *          04/12/17 - v4.3.0 - Support new table member      *\n  *                              setting for member position   *\n  *                            - Support user color settings   *\n  *                            - Enable EDIT * command for the *\n  *                              last selected member          *\n  *                            - Add GENOnly option            *\n  *                            - Correct EDIT MBR Gen use      *\n  *                            - Allow VIEW on command like    *\n  *                              EDIT                          *\n  *          03/21/17 - v4.2.2 - Add flag TIME and HIGEN       *\n  *                              and expand time reporting     *\n  *                            - Improved test for Dummy       *\n  *                              members - only ttr 000000     *\n  *                            - Add MULT to TBADD for max     *\n  *                              anticipated members           *\n  *                            - Add progress flag for copy    *\n  *                            - Msg if unknown line cmd       *\n  *                            - Support MEMLIST/ML for        *\n  *                              Filter alias (from PDS)       *\n  *          01/23/17 - v4.2.1 - Add Selection A (base only)   *\n  *                            - Allow Exit and Quit on        *\n  *                              dataset selection panel       *\n  *                            - Clean up delete promote code  *\n  *          01/05/17 - v4.2.0 - Update Delete processing to   *\n  *                              delete base and promote       *\n  *          12/13/16 - v4.1.9 - Version change only           *\n  *          12/12/16 - v4.1.8 - If mail=0 then prevent mail   *\n  *                              option                        *\n  *          12/05/16 - v4.1.7 - Correction for sorting with   *\n  *                              extended stats (thanks JK)    *\n  *          11/07/16 - v4.1.6 - Allow SET= anywhere in the    *\n  *                              parameters                    *\n  *          10/25/16 - v4.1.5 - Add 4 digit year fields       *\n  *                            - Add Left/Right table command  *\n  *                              to switch table for year size *\n  *                            - Add PASSLIB to HELP command   *\n  *          10/07/16 - v4.1.4 - Allow null default unit       *\n  *                            - correct test for ghosts       *\n  *                            - After using the dataset list  *\n  *                              then return to it to exit     *\n  *                            - If enter using dsn prompt     *\n  *                              then return to it to exit     *\n  *          09/08/16 - v4.1.3 - Check for zdsngen > 0 before  *\n  *                              doing generation msgs in b/e/v*\n  *                            - Check for zdsngen > 0 before  *\n  *                              doing Compare                 *\n  *                            - Get def_unit for allocs from  *\n  *                              pdsegens                      *\n  *                            - Additional test for null      *\n  *                              member name as a Dummy mbr    *\n  *          09/08/16 - v4.1.2 - Add sort prompt popup         *\n  *          09/08/16 - v4.1.1 - version change only           *\n  *                            - change short browse/edit msg  *\n  *          09/07/16 - v4.1.0 - Clean up from 4.0 and change  *\n  *                              from V.R to V.R.M             *\n  *                            - Add message for Browse of a   *\n  *                              non-0 gen to inform the gen   *\n  *                            - Add message for Edit of gen 0 *\n  *                            - If C * is used and there is   *\n  *                              no previous dsn then display  *\n  *                              change DSN list               *\n  *                            - If called with a DSN of *     *\n  *                              then display change DSN list  *\n  *                            - Promote display issue fixed   *\n  *                            - Display panel PDSEGFIL popup  *\n  *                              for FILTER blank or ?         *\n  *                            - Add unknown command message   *\n  *                            - Add HIDE command to hide      *\n  *                              all generations.              *\n  *                            - Change user command to use    *\n  *                              select cmd(xx)                *\n  *                            - error msg if unknown line     *\n  *                              selection option              *\n  *                            - Correct Find to handle strings*\n  *                            - Add datasets in the change    *\n  *                              list will now be fully qual'd *\n  *                            - Added date filters Today,     *\n  *                              Week, Month, Since yy/mm/dd,  *\n  *                              Since -nn, and Year           *\n  *                            - Allow both member and date    *\n  *                              filters where ever a filter   *\n  *                              can be specified.             *\n  *                            - Call PDSEGMAT for enhanced    *\n  *                              pattern matching (* and %)    *\n  *                            - if ttr is x'000000' then it   *\n  *                              is a Dummy member so flag it  *\n  *                            - Add CLEAR and SORT commands   *\n  *                              to change dataset list        *\n  *                            - Allow Locate on last sorted   *\n  *                              column (default name column)  *\n  *                            - Allow SET x on the startup    *\n  *                            - Allow S or E member gen       *\n  *                            - Add popup if Find blank       *\n  *                            - Add filter option on REFRESH  *\n  *                            - New PDSEGENS option for prune *\n  *                              prompting                     *\n  *            08/19/16 - v4.0 - Change Version to 4.0 due to  *\n  *                              the number of enhancements    *\n  *                            - If Filter in place use for    *\n  *                              Copy                          *\n  *                            - Add C ? option for a list of  *\n  *                              15 previous datasets or C #   *\n  *                              to get directly to entry #    *\n  *                            - Allow a filter on the C       *\n  *                              (change) command              *\n  *                            - Improve test of invalid dsn   *\n  *                            - Reset Delete Prompt after each*\n  *                              group of deletes              *\n  *                            - Change default Selection opt  *\n  *                              to /                          *\n  *                            - Add QUIT and EXIT as commands *\n  *                            - Allow option on PRUNE command *\n  *                            - Add line selection U          *\n  *                            - Message if Filter with blank  *\n  *                            - Correction if Edit is canceled*\n  *                              on new member to not update   *\n  *                              the row with last option.     *\n  *                            - If selection is O or / then   *\n  *                              display panel PDSEGSLN or     *\n  *                              PDSEGSL0                      *\n  *                            - Correction for Dummy member   *\n  *                              appearing in table after del  *\n  *                            - Correction for members/gens   *\n  *                              with no stats                 *\n  *                            - Reset table title row after   *\n  *                              Prune Reset if Filter was on  *\n  *                            - Fix rename issue with just    *\n  *                              recovered member              *\n  *                            - Fix so multiple line commands *\n  *                              can be selected at once       *\n  *                            - Clean up of last used opt     *\n  *            07/18/16 - v3.0 - Add BACKUP and RESTORE cmds   *\n  *                            - Change to use Replace for     *\n  *                              cut/paste                     *\n  *            06/21/16 - v2.0 - Convert to use PDSEGENI REXX  *\n  *                              function.                     *\n  *                            - Access HIGEN members using P  *\n  *                            - Allow D for HIGEN members     *\n  *            06/13/16 - v1.0 - First general release         *\n  *            05/26/16 - v0.1 - creation                      *\n  *                                                            *\n  * ---------------------------------------------------------- *\n  * Copyright (c) 2017-2020 by Lionel B. Dyck                  *\n  * ---------------------------------------------------------- *\n  * Support is on a best effort and time available basis which *\n  * is why the complete source is provided for this application*\n  * so you can find and fix any issues you find. Please let    *\n  * me know if you do make changes/enhancements/fixes.         *\n  * ---------------------------------------------------------- *\n  * License:   This EXEC and related components are released   *\n  *            under terms of the GPLV3 License. Please        *\n  *            refer to the LICENSE file for more information. *\n  *            Or for the latest license text go to:           *\n  *                                                            *\n  *              http://www.gnu.org/licenses/                  *\n  * ---------------------------------------------------------- *\n  * ------------------- Soli Deo Gloria ---------------------- */\n  arg options\n\n  /* -------------------------------- *\n  * Check for supported z/OS Release *\n  * -------------------------------- */\n  parse value mvsvar('sysmvs') with 'SP'level\n  if level >= '7.2.1'\n  then zOSOK  = 1\n  else do\n    zerrhm   = 'PDSEGH0'\n    zerralrm = 'NO'\n    zerrtp   = 'Notify'\n    zerrsm  = ''\n    zerrlm  = 'This application assists in managing PDSE' ,\n      'generations. The release of z/OS that you are' ,\n      'running does not support these capabilities.'\n    Address ISPExec ,\n      'Setmsg msg(isrz003)'\n    exit 4\n  end\n  parse value level with  vv'.'rr'.'mm\n  if rr > 1 then if mm < 2 then cmdtbl = 1\n  else cmdtbl = 0\n\n  /* -------------------------------------------------- *\n  * Test for our ISPF Applid and if not then:          *\n  * - re-invoke ourselves with our APPLID              *\n  * - upon return exit                                 *\n  * -------------------------------------------------- */\n  Address ISPExec\n  \"Vget (Zapplid)\"\n  \"Control Errors Return\"\n  if zapplid <> \"PDSE\" then do\n    /* --------------------------------------- *\n    | Create the ISPF Commands table for PDSE |\n    | to enable Left/Right commands           |\n    * --------------------------------------- */\n    if cmdtbl = 1 then do\n      'tbquery pdsecmds rownum('rows')'\n      if rc > 0 then do\n        \"TBCreate pdsecmds names(zctverb zcttrunc zctact zctdesc)\",\n          \"replace share nowrite\"\n        zctverb  = \"RIGHT\"\n        zcttrunc = 0\n        zctact   = \"&PDSECMD\"\n        zctdesc  = \"RIGHT for PDSE Dialog\"\n        \"TBAdd pdsecmds\"\n        zctverb  = \"LEFT\"\n        zcttrunc = 0\n        zctact   = \"&PDSECMD\"\n        zctdesc  = \"LEFT for PDSE Dialog\"\n        \"TBAdd pdsecmds\"\n        zctverb  = \"HELP\"\n        zcttrunc = 0\n        zctact   = \"SELECT PGM(ISPTUTOR) PARM(&ZPARM) NOFUNC NEWAPPL(PDSE)\" ,\n          \"PASSLIB\"\n        zctact   = translate(zctact)\n        zctdesc  = \"Help for PDSE Dialog\"\n        \"TBAdd pdsecmds\"\n        cmdtbl = 1\n      end\n    end\n    callit = sysvar('sysicmd')\n    \"Select CMD(%\"callit options \") Newappl(PDSE)\" ,\n      \"Passlib\"\n    if cmdtbl = 1 then\n    \"TBClose pdsecmds\"\n    exit 0\n  end\n\n  /* ------------------------------------------------- *\n  * Check for SET= in the options on the start command *\n  * ------------------------------------------------- */\n  if pos('SET=',options) > 0 then do\n    p = pos('SET=',options)\n    lf = left(options,p-1)\n    rf = substr(options,p+5)\n    pdsedo = substr(options,p,5)\n    parse value pdsedo with 'SET='pdsedo\n    call logit 'Setting:' pdsedo\n    'vput (pdsedo) profile'\n    options = lf''rf\n  end\n\n  /* --------------- *\n  | Process options |\n  * --------------- */\n  parse value options with pdsedsn filter '\\' flag\n\n  /* --------------- *\n  * Define defaults *\n  * --------------- */\n  parse value '' with null tfilter tfilterl tfiltert filter_title ,\n    save_pdsedsn HIGEN_title metric_table ,\n    proc_mems hide_title do_pdsedsl date_filter ,\n    date_filter_title gen_hide hide_title ft ,\n    date_filterv last_date_filter dfilter ,\n    dsn_prompt table_panelo last_mem last_mgen ,\n    last_agen first_pass docmd blockcmd ,\n    save_bcmd topdse hfilter bypass_tb ,\n    update_table open_pdse filter_id ,\n    tfilter_from tfilter_to tfilter_list srowcrp\n  pdsedd   = randstr()\n  pdsegdd  = randstr()\n  tblmet   = randstr()\n  pdsedelp = 'N'\n  zerrhm   = 'PDSEGH0'\n  zerralrm = 'NO'\n  zerrtp   = 'NOTIFY'\n  closed   = 1   /* 1 = closed 0 = open */\n  sortcol  = 'NAME'\n  sortf = 'mbr,c,'A',mgen,n,d'\n  sort.sortcol = 'A'\n\n  /* ----------------------------- *\n  * Get the current MAXGENS_LIMIT *\n  * ----------------------------- */\n  Numeric Digits 10\n  CVT      = C2D(Storage(10,4))\n  CVTDFA   = C2D(Storage(D2X(CVT + 1216),4))   /* cvt + 4c0 */\n  DFAMGEN  = C2D(Storage(D2X(cvtdfa + 76),4))  /* dfa + 4c */\n\n  /* ----------------------------------------- *\n  * Define the default addressing environment *\n  * and save the version in the profile pool  *\n  * so that the tutorial panels can use it    *\n  * ----------------------------------------- */\n  Address ISPExec\n  'vput (pdsegver)'\n\n  /* -------------------------- *\n  | Log the Dataset being used |\n  * -------------------------- */\n  call logit 'Starting PDSEGEN Version:' pdsegver\n\n  /* --------------------------------------------------- *\n  * Call PDSEGENS to setup the local site customization *\n  * values for this application.                        *\n  * --------------------------------------------------- */\n  x = pdsegens()\n  parse value x with  mail '/' etime '/' higenf ,\n    '/' base_color '/' sort_color '/' clean ,\n    '/' prune_prompt '/' tempmem '/' def_unit ,\n    '/' def_panel '/' disp_change '/' maxhist\n  clean        = strip(clean)\n  prune_prompt = strip(prune_prompt)\n  tempmem      = strip(tempmem)\n  def_unit     = strip(def_unit)\n  def_panel    = strip(def_panel)\n  base_color   = translate(strip(base_color))\n  sort_color   = translate(strip(sort_color))\n  if def_unit  /= null then\n  def_unit  = 'unit('def_unit')'\n  if clean = 1 then valparm = 'clean'\n  else valparm = null\n\n  if datatype(maxhist) = 'NUM'\n  then 'vput (maxhist) profile'\n  else do\n    maxhist = 100\n    'vput (maxhist) profile'\n  end\n\n  'vget (useab tpanel) profile'\n  if tpanel = null then tpanel = def_panel\n  if useab = null then do\n    useab = 'Y'\n    'vput (useab) profile'\n    call change_panels\n  end\n  call set_panels\n  if left(translate(tpanel),7) /= 'PDSEGED'\n     then tpanel = def_panel\n\n  /* --------------------------------------------- *\n  | Save mail value so the tutorial panel sees it |\n  * --------------------------------------------- */\n  'vput (mail)'\n\n  /* --------------------------------------- *\n  | Call Proc_Settings for initial defaults |\n  * --------------------------------------- */\n  call proc_settings 'initial'\n  'Vget (clrb clrg clrp clrr clrt clrw clry clrh clrhr' ,\n    'sortb sortc pdsetb csrloc changed useab) profile'\n  base_color = sortb\n  sort_color = sortc\n  if changed = 'N'  then\n  disp_change = 0\n\n  /* ----------------------------------------------------------- *\n  | Check for version change and change display tutorial option |\n  | - only check the v.r and ignore the .m                      |\n  * ----------------------------------------------------------- */\n  'vget (pdselver) profile'\n  change_hit = 0\n  if disp_change = 1 then\n  if left(pdselver,3) /= left(pdsegver,3) then change_hit = 1\n  if disp_change = 2 then\n  if left(pdselver,5) /= left(pdsegver,5) then change_hit = 1\n  if change_hit = 1 then do\n    pdselver = pdsegver\n    'vput (pdselver) profile'\n    'Select pgm(isptutor) parm(pdseghcg)'\n  end\n\n  /* --------------------------- *\n  | Check for saved Table Panel |\n  * --------------------------- */\n\n  /* ------------------------- *\n  | Test for any Flag options |\n  * ------------------------- */\n  if flag /= null then do i = 1 to words(flag)\n    if abbrev(\"CASPER\",word(flag,i),1) = 1 then higenf = 1\n    if abbrev(\"ACHMED\",word(flag,i),1) = 1 then higenf = 1\n    if abbrev(\"ZOMBIE\",word(flag,i),1) = 1 then higenf = 1\n    if abbrev(\"HIGEN\",word(flag,i),1)  = 1 then higenf = 1\n    if higenf = 1 then HIGEN_title = 'HIGen members'\n    if abbrev(\"TIME\",word(flag,i),1)   = 1 then etime  = 1\n    if abbrev(\"EDIT\",word(flag,i),1)   = 1 then do\n      fm = translate(filter,'&&& ','*%/')\n      if pos('&',fm) = 0 then\n      editit = 1\n    end\n  end\n\nRestart:\n  if pdsedsn /= null then\n  call fixup_pdsedsn\n  else if first_pass /= null then exit\n  first_pass = 1\n  /* ------------------------------------- *\n  | Restart processing                    |\n  | - test for a member in the dsname     |\n  |   - extract and use for a member-mask |\n  | - test for a filter (member-mask)     |\n  |   - setup the filter processing       |\n  * ------------------------------------- */\n  if pos('(',pdsedsn) > 0 then do\n    if filter /= null then hfilter = filter\n    else hfilter = null\n    parse value pdsedsn with pdsedsn '('filter')' .\n    if left(pdsedsn,1) = \"'\" then pdsedsn = pdsedsn\"'\"\n    if hfilter /= null then filter = filter\n  end\n  if pdsedsn /= null then\n  if filter /= null then do\n    last_date_filter = null\n    date_filter = null\n    call setup_filter\n  end\n\n  /* ----------------------------------------------------- *\n  | Set the IBM FileManager variable to allow those sites |\n  | with it to use EFIND and ECHG                         |\n  * ----------------------------------------------------- */\n  crzdsnx = wdsn\n  'vput (crzdsnx) shared'\n\n  /* ----------------------------------------------- *\n  | Set the flag used to indicate if the dataset is |\n  | pdse member generation enabled                  |\n  * ----------------------------------------------- */\n  zdsngen_first = null\n\n  /* ---------------------------------------------------- *\n  * Test for supplied dsname and if none then            *\n  * prompt the user for the dsname.                      *\n  * ---------------------------------------------------- */\n  if pdsedsn = '?' then do\n    pdsedsn = null\n    'Select pgm(isptutor) parm(pdsegh0)'\n  end\n  if pdsedsn = '*' then do\n    pdsedsn = null\n    zcmd = null\n    x = pdsegdsl()\n    if x /= 0 then do\n      pdsedsn = word(x,1)\n      if words(x) > 1 then filter = subword(x,2)\n      zcmd = 'C' x\n      signal restart\n      exit 0\n    end\n    else pdsedsn = null\n    zcmd = null\n    signal restart\n    exit 0\n  end\n  if pdsedsn /= null then do\n    call test_dsn_alias\n    if sysdsn(pdsedsn) = 'OK' then do\n      call start\n      exit 0\n    end\n    else do\n      zerrsm = 'Error'\n      zerrlm = pdsedsn sysdsn(pdsedsn)\n      'setmsg msg(isrz003)'\n      'vput (pdsedsn)'\n    end\n  end\n\n  'vget (pdsedsn)'\n  do forever\n    dsn_prompt = 1\n    \"Display panel(pdsegenp)\"\n    if rc > 0 then exit\n    'vput (pdsedsn pdsedo) profile'\n    if pdsedsn = '*' then do\n      pdsedsn = null\n      'vput (pdsedsn)'\n      pdsedsn = pdsegdsl()\n      if words(pdsedsn) > 1 then\n      parse value pdsedsn with pdsedsn filter\n      call close\n      signal restart\n    end\n    if sysdsn(pdsedsn) /= 'OK' then do\n      zerrsm = 'Invalid DSN'\n      zerrlm = sysdsn(pdsedsn)\n      'Setmsg msg(isrz003)'\n    end\n    else if pdsedsn /= null then do\n      if filter = null then  signal start\n      else do\n        call setup_filter\n        signal start\n      end\n    end\n  end\n  Exit 0\n\nStart:\n  if etime = 1 then\n  x = time('r')\n  s_service = sysvar('SYSSRV')\n  s_stime   = sysvar('SYSCPU')\n\n  sortcol = 'NAME'\n  sort.NAME = 'A'\n  parse value '' with lopt lopts msel\n\n  /* ------------------------------------------------------ *\n  * Test that the supplied dsname is a valid dataset name. *\n  *                                                        *\n  * Save the dsname in the ispf profile pool               *\n  *                                                        *\n  * Create a working variable with a fully qualifed dsname *\n  * if the dsname was not by prefixing with either the     *\n  * syspref or sysuid.                                     *\n  * ------------------------------------------------------ */\n  call fixup_pdsedsn\n  if sysdsn(pdsedsn) /= 'OK' then do\n    zerrsm  = null\n    zerrlm  = 'Error.' pdsedsn sysdsn(pdsedsn)\n    'setmsg msg(isrz003)'\n    return\n  end\n\n  /* ------------------------------------- *\n  | Get the dataset info using dsinfo and |\n  | test for RECFM=U (load library) which |\n  | is not supported.                     |\n  * ------------------------------------- */\n  'dsinfo dataset('pdsedsn')'\n  if wordpos(left(strip(zdsrf),1),'F V') = 0 then do\n    zerrsm  = 'Error: RECFM='zdsrf\n    zerrlm = 'PDSEGEN does not support RECFM='zdsrf\n    'setmsg msg(isrz003)'\n    \"Select PGM(isrdslst) parm(DSL \"pdsedsn\") suspend scrname(udlist)\"\n    exit 8\n  end\n\n  /* ---------------------------------------------- *\n  | If the ZDSNGEN varaible is not set then we are |\n  | running on a non supported version of z/OS so  |\n  | set the value to 0.                            |\n  * ---------------------------------------------- */\n  if zdsngen /= 'ZDSNGEN' then  zdsngen = zdsngen + 0\n  else zdsngen = 0 /* unsupported level of z/OS */\n  'vput (zdsngen)'\n\n  /* --------------------------------------------- *\n  | Save the pdse dsn in the profile for next use |\n  * --------------------------------------------- */\n  'Vput (pdsedsn) Profile'\n\n  /* ------------------------------------ *\n  | Update the dataset list with new dsn |\n  * ------------------------------------ */\n  x = pdsegdsl(pdsedsn)\n\n  /* ------------------------------------ *\n  * Define our defaults for this session *\n  * ------------------------------------ */\n  parse value \"\" with member ,\n    ZLCDATE ZLMDATE ZLVERS ZLMOD ZLMTIME ZLCNORC,\n    ZLINORC ZLMNORC ZLUSER\n\n  /* --------------------------------- *\n  * Get the default Selection options *\n  * --------------------------------- */\n  'vget (pdsedo pdsetb)'\n  if pdsedo = null then pdsedo = '/'\n  if pdsetb = null then pdsetb = 0\n\n  /* ----------------------------------------- *\n  * Define the default colors for the columns *\n  * ----------------------------------------- */\n  call reset_color\n\n  /* ------------------------------------ *\n  | Test for DSORG of PO and for Members |\n  * ------------------------------------ */\n  if zdsorg /= 'PO' then do\n    zerrsm  = 'Error'\n    zerrlm  = pdsedsn 'is not a PDS or PDSE. Try with' ,\n      'another dataset that is a PDS/PDSE.'\n    'Setmsg msg(isrz003)'\n    return\n  end\n  if zds#mem = 0 then do\n    zerrsm  = 'Warning'\n    zerrlm  = pdsedsn 'has no members. Use EDIT to create' ,\n      'your first member in this PDS/PDSE.'\n    'Setmsg msg(isrz003)'\n  end\n\n  /* ------------------ *\n  * Define ISPF Dataid *\n  * and Allocate       *\n  * ------------------ */\n  \"LMINIT DATAID(pdsegend) DATASET(\"pdsedsn\")\"\n  \"LMOPEN DATAID(\"pdsegend\") OPTION(INPUT)\"\n  Address TSO ,\n    \"Alloc f(\"pdsedd\") ds('\"wdsn\"') shr reuse\"\n\n  /* ----------------------- *\n  * Now process all members *\n  * ----------------------- */\n  s_spdsi_service = sysvar('SYSSRV')\n  s_spdsi_stime   = sysvar('SYSCPU')\n  drop member.\n  if zds#mem > 0\n  then x=pdsegeni(pdsedd)\n  else do\n    rc = 0\n    member.0 = 0\n  end\n  xrc = rc\n  e_spdsi_stime   = sysvar('SYSCPU')\n  e_spdsi_service = sysvar('SYSSRV')\n  Address TSO 'Free f('pdsedd')'\n  if rc > 7 then do\n    zerrsm  = 'Error'\n    zerrlm  = 'Error encountered getting PDSE member' ,\n      'generation info. RC=' rc\n    \"Setmsg msg(isrz003)\"\n    call close\n    Exit 0\n  end\n  mbr = null\n  s_ppdsi_service = sysvar('SYSSRV')\n  s_ppdsi_stime   = sysvar('SYSCPU')\n  call proc_pdsegeni\n  e_ppdsi_stime   = sysvar('SYSCPU')\n  e_ppdsi_service = sysvar('SYSSRV')\n  'tbstats' pdset 'rowcurr(tabr)'\n  if tabr = 0 then\n  if filter /= null then do\n    zerrsm  = 'Error'\n    zerrlm  = 'The FILTER' filter 'resulted in zero' ,\n      'members being displayed. Issue Filter Off' ,\n      'to display all members or try a different' ,\n      'dataset.'\n    'Setmsg msg(isrz003)'\n  end\n  call do_sort\n\n  /* ------------------------------------------- *\n  * Display the table of members to select from *\n  * ------------------------------------------- */\n  'tbtop' pdset\n  parse  value '0 0 0' with crp rowcrp ztdsels\n  if zdsngen_first /= 1 then\n  if zdsngen = 0 then do\n    zdsngen_first = 1\n    zerrsm  = 'No Generations'\n    zerrlm  = 'This dataset does not support generations' ,\n      'so this dialog will not be as useful as' ,\n      'normal ISPF member processing.'\n    \"setmsg msg(isrz003)\"\n    zerrlm = null\n  end\n  if zds#mem = 0 then do\n    if left(zdsdsnt,1) = 'L' then dsnt = 'PDSE'\n    else dsnt = 'PDS'\n    zerrsm  = 'Empty' dsnt\n    zerrlm  = 'This dataset is empty. Use Edit to create' ,\n      'to create a member in this' dsnt\n    \"setmsg msg(isrz003)\"\n    zerrlm = null\n  end\n\n  /* ------------------------------------------------ *\n  | If the TIME option was enable then collect the   |\n  | service units and cpu time used so that it can   |\n  | be reported on if the user pressed F1 when the   |\n  | short message with processing time is displayed. |\n  * ------------------------------------------------ */\n  if etime = 1 then do\n    e_time = time(\"E\")\n    e_stime   = sysvar('SYSCPU')\n    e_service = sysvar('SYSSRV')\n    parse value e_time with ss \".\" uu\n    numeric digits 6\n    mm = ss % 60   /* get minutes integer */\n    ss = ss // 60  /* get seconds integer */\n    uu = uu // 100 /* get micro seconds integer */\n    'tbstats' pdset 'rowcurr(tabr)'\n    pwtime  =  right(mm+100,2)':'right(ss+100,2)'.'right(uu+100,2)\n    zerrsm  = pwtime\n    zerrlm  = ''\n    zerrhm  = 'pdsegtim'\n    ptgrows = grows\n    pttm    =  member.0\n    pttabr  = tabr * 1\n    ptserv  = e_service - s_service\n    ptctime = e_stime - s_stime\n    ptsserv = e_spdsi_service - s_spdsi_service\n    ptcpu   = e_spdsi_stime - s_spdsi_stime\n    ptpserv = e_ppdsi_service - s_ppdsi_service\n    ptpcpu  = e_ppdsi_stime - s_ppdsi_stime\n    poserv  = ptserv - (ptsserv + ptpserv)\n    pocpu   = ptctime - (ptcpu + ptpcpu)\n    numeric digits 2\n    ptsservp = (ptsserv / ptserv  ) * 100 ||'%'\n    ptcpup   = (ptcpu  /  ptctime ) * 100 ||'%'\n    ptpservp = (ptpserv / ptserv  ) * 100 ||'%'\n    ptpcpup  = (ptpcpu /  ptctime ) * 100 ||'%'\n    poservp  = (poserv / ptserv   ) * 100 ||'%'\n    if pocpu = ptctime then pocpup = 0'%'\n    else pocpup   = (pocpu  / ptctime  ) * 100 ||'%'\n    numeric digits 6\n    'vput (ptgrows pttm pttabr ptserv ptctime ptsserv ptcpu' ,\n      'poserv pocpu poservp pocpup pwtime' ,\n      'ptsservp ptcpup ptpservp ptpcpup' ,\n      'ptpserv ptpcpu pdsegver) profile'\n    zerrhm = 'pdsegh0'\n    Address ISPExec\n    'setmsg msg(isrz003)'\n  end\n\n  /* ------------------------------------- *\n  * Now display the ISPF Table of Members *\n  * ------------------------------------- */\n  call logit 'Opening Dataset:' wdsn 'Maxgens:' strip(zdsngen)\n  open_pdse = 1\n\n  do forever\n    /* ------------------------ *\n    * Define the dynamic title *\n    * ------------------------ */\n    if strip(filter_title HIGEN_title hide_title date_filter_title) ,\n      /= null then ft = 'Filter:' ,\n      filter_title date_filter_title HIGEN_title hide_title\n    else ft = null\n\n    pdsetitl = 'DSN='wdsn' - MaxGens='strip(zdsngen)  ft\n\n    if editit = 1 then do\n      zcmd = 'E' filter\n      editit = null\n      call do_command 'E'\n    end\n\n    /* ----------------- *\n    * Display the table *\n    * ----------------- */\n    if bypass_tb = null then do\n      zcmd    = null\n      if cmdtbl = 0\n      then 'CONTROL PASSTHRU LRSCROLL PASON'\n      else  pdsecmd = 'PASSTHRU'\n      parse value '' with zerrsm zerrlm proc_mems clinecmd\n      if ztdsels > 1 then src = 4\n      else src = 0\n      if src = 4 then \"TBDispl\" pdset\n      else do\n      if srowcrp /= null then do\n         rowcrp = srowcrp\n         srowcrp = null\n         end\n        \"TBTOP\" pdset\n        \"TBSKIP\" pdset \"NUMBER(\"crp\")\"\n        if csrloc = 0 then rowcrp = 0\n        if rowcrp = 0 then\n        \"TBDISPL\" pdset \"PANEL(\"tpanel\")\"\n        else\n        \"TBDISPL\" pdset \"PANEL(\"tpanel\")\",\n          \"AUTOSEL(NO) CSRROW(\"rowcrp\")\"\n        crp = ztdtop\n      end\n    end\n    src = rc\n    docmd = null\n    if cmdtbl = 0\n    then 'CONTROL PASSTHRU LRSCROLL PASOFF'\n    else pdsecmd = null\n    if src = 20 then\n    if zerrlm /= 'Attempt to process a table row that no longer exists.'\n    then leave\n    else do\n      src = 0\n      ztdsels = 0\n    end\n    if src > 4\n    then if do_pdsedsl /= 1 then leave\n    else do\n      pdsedsn = '*'\n      zcmd = 'C ?'\n      signal do_zcmd\n    end\n\n    if ztdsels > 1 then\n       if srowcrp = null\n          then srowcrp = rowcrp\n\n    /* ------------------------------ *\n    | Process any immediate commands |\n    * ------------------------------ */\n    if zcmd = 'QUIT' then leave\n    if zcmd = 'EXIT' then leave\n    if zcmd = 'RIGHT' then do\n      zcmd = null\n      Select\n        When tpanel = table_panel1 then tpanel = table_panel2\n        When tpanel = table_panel2 then tpanel = table_panel3\n        When tpanel = table_panel3 then tpanel = table_panel4\n        When tpanel = table_panel4 then tpanel = table_panel5\n        When tpanel = table_panel5 then tpanel = table_panel6\n        When tpanel = table_panel6 then tpanel = table_panel7\n        When tpanel = table_panel7 then tpanel = table_panel8\n        When tpanel = table_panel8 then tpanel = table_panel1\n        otherwise tpanel = def_panel\n      End\n      'vput (tpanel) profile'\n    end\n    if zcmd = 'LEFT' then do\n      zcmd = null\n      Select\n        When tpanel = table_panel8 then tpanel = table_panel7\n        When tpanel = table_panel7 then tpanel = table_panel6\n        When tpanel = table_panel6 then tpanel = table_panel5\n        When tpanel = table_panel5 then tpanel = table_panel4\n        When tpanel = table_panel4 then tpanel = table_panel3\n        When tpanel = table_panel3 then tpanel = table_panel2\n        When tpanel = table_panel2 then tpanel = table_panel1\n        When tpanel = table_panel1 then tpanel = table_panel8\n        otherwise tpanel = def_panel\n      End\n      'vput (tpanel) profile'\n    end\n\n    /* ----------------------------- *\n    | Check for the Options command |\n    * ----------------------------- */\n    if abbrev(\"OPTIONS\",word(zcmd,1),1) = 1 then\n    do forever\n      zcmd = null\n      bypass_tb = null\n      'Display Panel(pdsegopt)'\n      if rc > 0 then leave\n      if zcmd /= null\n      then zcmd = zcmd gopt\n      if zcmd /= null then leave\n    end\n\n    /* ------------------------------- *\n    | Handle point and shoot on a row |\n    * ------------------------------- */\n    if datatype(row) /= 'NUM' then row = 0\n    if row /= 0 then do\n      ssel = msel\n      \"TBTOP\" pdset\n      \"TBSKIP\" pdset \"NUMBER(\"row\")\"\n      msel = ssel\n    end\n\n    /* --------------------------------------------- *\n    * Process any command options                   *\n    * --------------------------------------------- */\n  do_zcmd:\n    if zcmd /= null then do\n      edits = null\n      call logit 'Processing Command:' zcmd\n      if abbrev(\"CASPER\",word(zcmd,1),3) = 1 then zcmd = \"HIGEN\" subword(zcmd,2)\n      if abbrev(\"ACHMED\",word(zcmd,1),3) = 1 then zcmd = \"HIGEN\" subword(zcmd,2)\n      if abbrev(\"ZOMBIE\",word(zcmd,1),3) = 1 then zcmd = \"HIGEN\" subword(zcmd,2)\n      if abbrev(\"SELECT\",word(zcmd,1),1) = 1 then do\n        zcmd = 'EDIT' subword(zcmd,2)\n        edits = 'S'\n      end\n      if abbrev(\"RESET\",word(zcmd,1),3) = 1 then zcmd = \"REFRESH\"\n      if abbrev(\"SRCH\",word(zcmd,1),3) = 1 then zcmd = \"FIND\" subword(zcmd,2)\n      if abbrev(\"SEARCH\",word(zcmd,1),3) = 1 then zcmd = \"FIND\" subword(zcmd,2)\n\n      /* ----------------------------------------- *\n      | Support PDSE memlist/ml syntax for filter |\n      * ----------------------------------------- */\n      if abbrev('MEMLIST',word(zcmd,1),3) = 1 then do\n        zcmd = 'FILTER' subword(zcmd,2)\n      end\n      if word(zcmd,1) = 'ML' then\n      zcmd = 'FILTER' subword(zcmd,2)\n\n      /* -------------------------------- *\n      | Now check for supported commands |\n      * -------------------------------- */\n      Select\n        /* ----------------------- *\n        | Check for userid filter |\n        * ----------------------- */\n        When wordpos('MINE',zcmd) > 0 then do\n          if wordpos('MINE',filter_title) > 0 then do\n            filter_id = null\n            if wordpos('MINE',filter_title) > 0 then do\n              wp = wordpos('MINE',filter_title)\n              filter_title = delword(filter_title,wp,1)\n            end\n            if wordpos('ID',filter_title) > 0 then do\n              wp = wordpos('ID',filter_title)\n              filter_title = delword(filter_title,wp,2)\n            end\n            call proc_refresh\n          end\n          if wordpos('MINE',filter_title) > 0 then do\n            wp = wordpos('MINE',filter_title)\n            filter_title = delword(filter_title,wp,1)\n          end\n          if wordpos('ID',filter_title) > 0 then do\n            wp = wordpos('ID',filter_title)\n            filter_title = delword(filter_title,wp,2)\n          end\n          filter_id = sysvar('sysuid')\n          filter_title = strip(filter_title 'MINE')\n          call proc_refresh\n        end\n        When abbrev(\"ID\",word(zcmd,1),2) = 1 then do\n          if words(zcmd) = 1 then call cmd_prompt 'ID'\n          if words(zcmd) = 1 then\n          if wordpos('ID',filter_title) > 0 then do\n            filter_id = null\n            if wordpos('ID',filter_title) > 0 then do\n              wp = wordpos('ID',filter_title)\n              filter_title = delword(filter_title,wp,2)\n            end\n            call proc_refresh\n          end\n          filter_id = word(zcmd,2)\n          if filter_id = '*' then filter_id = null\n          if wordpos('MINE',filter_title) > 0 then do\n            wp = wordpos('MINE',filter_title)\n            filter_title = delword(filter_title,wp,1)\n          end\n          if wordpos('ID',filter_title) > 0 then do\n            wp = wordpos('ID',filter_title)\n            filter_title = delword(filter_title,wp,2)\n          end\n          if filter_id /= null then\n          filter_title = strip(filter_title 'ID' filter_id)\n          call proc_refresh\n        end\n        /* ----------------- *\n        * Date filter check *\n        * ----------------- */\n        when wordpos(word(zcmd,1),'SINCE TODAY WEEK MONTH YEAR') > 0\n        then do\n          call setup_date_filter\n          zcmd = null\n          call proc_refresh\n        end\n        /* ------------------ *\n        | C - Change Dataset |\n        * ------------------ */\n        When abbrev(\"CHANGE\",word(zcmd,1),1) = 1 then do\n          zerrsm = null\n          zcmd = 'C' subword(zcmd,2)\n          if word(zcmd,2) = '>' then do\n            if topdse /= null\n            then zcmd = 'C' topdse\n            else do\n              zerrsm = 'Error'\n              zerrlm = 'Unable to change to the COPY' ,\n                'PDS/PDSE because COPY has not' ,\n                'been used in this PDSEGEN session.'\n              'Setmsg msg(isrz003)'\n            end\n          end\n          if zerrsm = null then do\n            if word(zcmd,3) /= null then\n            filter = subword(zcmd,3)\n            else filter = filter date_filterv\n            if datatype(word(zcmd,2)) = 'NUM' then do\n              dnum = word(zcmd,2)\n              x = pdsegdsl(dnum)\n              if x /= 0 then  do\n                if words(x) = 1\n                then zcmd = 'C' x filter\n                else do\n                  zcmd = 'C' word(x,1)\n                  filter = subword(x,2)\n                end\n              end\n            end\n            if strip(zcmd) = 'C' then zcmd = 'C ?'\n            if word(zcmd,2) = '?' then do\n              x = pdsegdsl()\n              if x /= 0\n              then do\n                if words(x) = 1\n                then zcmd = 'C' x filter\n                else do\n                  zcmd = 'C' word(x,1)\n                  filter = subword(x,2)\n                end\n              end\n              else zcmd = null\n            end\n            if zcmd /= null then do\n              tds = word(zcmd,2)\n              if tds = '*' then do\n                zcmd = 'C' save_pdsedsn filter\n                tds = save_pdsedsn\n              end\n              if pos('.',tds) = 0 then\n              if length(tds) < 8 then do\n                x = pdsegdsl(tds)\n                if x /= 0 then do\n                  if words(x) = 1\n                  then zcmd = 'C' x filter\n                  else zcmd = 'C' x\n                end\n              end\n              x = listdsi(word(zcmd,2))\n              if x > 0 then do\n                zerrsm = 'Error.'\n                zerrlm = tds 'is not a valid dataset' sysmsglvl2\n                'setmsg msg(isrz003)'\n              end\n              else do\n                save_pdsedsn = pdsedsn\n                hcmd = zcmd\n                call close\n                zcmd = hcmd\n                pdsedsn = word(zcmd,2)\n                signal restart\n              end\n            end\n          end\n        end\n        /* -------------------- *\n        | REFLIST from John K. |\n        * -------------------- */\n        When abbrev(\"REFLIST\",word(zcmd,1),4) = 1 then do\n          'Control Display Save'\n          \"Select pgm(isrdslst) parm(PL1 REFLIST)\"\n          'Control Display Restore'\n          'vget zrdsn shared'\n          if zrdsn <> '' then do\n            save_pdsedsn = pdsedsn\n            if pos('(',zrdsn) > 0 then\n            pdsedsn = substr(zrdsn,1,pos('(',zrdsn)-1)||\"'\"\n            else\n            pdsedsn = zrdsn\n            zcmd = 'C' pdsedsn\n            zrdsn = ''\n            'vput zrdsn shared'\n          end\n          signal restart\n        end\n        /* ------ *\n        * Backup *\n        * ------ */\n        when abbrev(\"BACKUP\",word(zcmd,1),3) = 1 then do\n          fromdsn = pdsedsn\n          zcmd = null\n          pdsebopt = 'B'\n          'vput (pdsebopt)'\n          'Select cmd(%pdsegbak' fromdsn\n          if rc = 0 then do\n            zerrsm  = 'Completed'\n            zerrlm  = 'Backup operation completed.'\n          end\n          else do\n            zerrsm  = 'Cancelled'\n            zerrlm  = 'Backup operation cancelled.'\n          end\n          'Setmsg msg(isrz003)'\n        end\n        /* ------ *\n        * Restore *\n        * ------ */\n        when abbrev(\"RESTORE\",word(zcmd,1),4) = 1 then do\n          fromdsn = pdsedsn\n          zcmd = null\n          'Control Display Save'\n          'Addpop Row(3) Column(3)'\n          'Display Panel(pdsegrst)'\n          xrc = rc\n          'Rempop'\n          'Control Display Restore'\n          if xrc = 0 then do\n            if newtarg /= 'Y' then newtarg = null\n            else newtarg = 'NEW'\n            'Select cmd(%pdsegrst' fromdsn targetds ,\n              restmem restgen '/' newtarg ')'\n            zerrsm  = 'Completed'\n            zerrlm  = 'Restore operation completed.'\n            'Setmsg msg(isrz003)'\n            newtarg = null\n          end\n          else do\n            zerrsm = 'Cancelled'\n            zerrlm = 'Restore operation cancelled.'\n            'Setmsg msg(isrz003)'\n          end\n        end\n        /* ------- *\n        * Compare *\n        * ------- */\n        when abbrev(\"COMPARE\",word(zcmd,1),3) = 1 then\n        call compare_prompt\n        /* ------------------------ *\n        * Copy to Another/New PDSE *\n        * ------------------------ */\n        when abbrev(\"COPY\",word(zcmd,1),3) = 1 then do\n          frompdse = pdsedsn\n          if word(zcmd,2) /= null then\n          topdse = word(zcmd,2)\n          zcmd = null\n          select\n            when left(zdsspc,1) = 'C' then spaceu = 'Cyl'\n            when left(zdsspc,1) = 'T' then spaceu = 'Trk'\n            when left(zdsspc,1) = 'B' then spaceu = 'Trk'\n            otherwise spaceu = 'Trk'\n          end\n\n          newgen = zdsngen\n\n          if newgen = 0 then newgen = dfamgen\n          mempat = null\n          if filter /= null then mempat = filter\n          if date_filter /= null\n          then mempat = strip(mempat) date_filterv\n\n          do forever\n            call pfshow 'off'\n            'Addpop Row(3) Column(3)'\n            \"Display Panel(pdsegcpy)\"\n            xrc = rc\n            'Rempop'\n            call pfshow 'reset'\n            zerrsm = null\n            if xrc > 7 then leave\n            if left(topdse,1) = \"'\"\n            then wtpds = strip(topdse,'B',\"'\")\n            else wtpds = sysvar('syspref')'.'topdse\n            if left(frompdse,1) = \"'\"\n            then wfpds = strip(frompdse,'B',\"'\")\n            else wfpds = sysvar('syspref')'.'frompdse\n            if wtpds = wfpds then do\n              zerrsm = 'Error.'\n              zerrlm = 'The from and to datasets may not be the same.'\n              'setmsg msg(isrz003)'\n            end\n            if zerrsm = null then do\n              if create = 'Y' then do\n                replace = null\n                if 'OK' /= sysdsn(topdse) then do\n                  if spaceu = 'BLK' then spaceu = 'TRACKS'\n                  if spaceu = 'TRK' then spaceu = 'TRACKS'\n                  if spaceu = 'CYL' then spaceu = 'CYLINDERS'\n                  Address TSO\n                  \"Alloc ds(\"topdse\") like(\"frompdse\")\" ,\n                    \"dsntype(library,2) maxgens(\"newgen\")\" ,\n                    \"space(\"zdstota','zds2ex') new' ,\n                    def_unit spaceu\n                  \"Free ds(\"topdse\")\"\n                  Address ISPExec\n                  create = 'N'\n                end\n                else do\n                  zerrsm  = 'Error'\n                  zerrlm  = topdse 'already exists - try a new' ,\n                    'name or change create to N.'\n                  'Setmsg msg(isrz003)'\n                end\n              end\n            end\n            if zerrsm = null then do\n              if create = 'N' then do\n                if 'OK' = sysdsn(topdse) then do\n                  if replace = 'Y'\n                  then repopt = '( replace'\n                  else repopt = null\n                  if progress = 'N' then do\n                    if repopt = null then repopt = '( batch'\n                    else repopt = repopt 'batch'\n                  end\n                  'Select cmd(%pdsegenc' frompdse topdse ,\n                    mempat repopt\n                  leave\n                end\n                else do\n                  zerrsm  = 'Error'\n                  zerrlm  = topdse sysdsn(topdse)\n                  'Setmsg msg(isrz003)'\n                end\n              end\n            end\n          end\n        end\n        /* ------ *\n        | Browse |\n        * ------ */\n        when abbrev(\"BROWSE\",word(zcmd,1),1) = 1 then do\n          if words(zcmd) = 1 then call cmd_prompt 'B'\n          call do_command 'B'\n        end\n        /* ------- *\n        | HIGEN   |\n        * ------- */\n        when abbrev(\"HIGEN\",word(zcmd,1),3) = 1 then do\n          if word(zcmd,2) = '?' then do\n            'Select pgm(isptutor) parm(pdseghhw)'\n          end\n          else do\n            if zdsngen = 0 then do\n              zerrsm = 'Error'\n              zerrlm = 'HIGen is not supported for datasets without' ,\n                'PDSE member generations.'\n              'Setmsg msg(isrz003)'\n              higenf = 0\n            end\n            else do\n              if higenf = 0 then higenf = 1\n              else higenf = 0\n              if higenf = 1\n              then do\n                HIGEN_title = 'HIGen members'\n                call proc_refresh\n              end\n              else do\n                HIGEN_title = null\n                'tbtop' pdset\n                do forever\n                  'tbskip' pdset\n                  if rc > 0 then leave\n                  if muser = 'HIGen' then 'tbdelete' pdset\n                end\n              end\n            end\n          end\n        end\n        /* ---- *\n        | Edit |\n        * ---- */\n        when abbrev(\"EDIT\",word(zcmd,1),1) = 1 then do\n          if words(zcmd) = 1 then call cmd_prompt 'E'\n          call do_command 'E'\n        end\n        /* ------ *\n        | Filter |\n        * ------ */\n        when abbrev(\"FILTER\",word(zcmd,1),3) = 1\n        then do\n          if word(zcmd,2) = '?' then zcmd = null\n          if word(zcmd,2) = null then do\n            zcmd = null\n            call pfshow 'off'\n            'Addpop Row(3) Column(3)'\n            'Display Panel(pdsegfil)'\n            'Rempop'\n            call pfshow 'reset'\n            if filter = null then filter = 'OFF'\n          end\n          else filter = subword(zcmd,2)\n          if filter /= null then call setup_filter\n        end\n        /* ------- *\n        * Find    *\n        * ------- */\n        when abbrev(\"FIND\",word(zcmd,1),1) = 1 then do\n          if word(zcmd,2) = null then do\n            zcmd = null\n            call pfshow 'off'\n            'Addpop Row(3) Column(3)'\n            'Display Panel(pdsegfnd)'\n            'Rempop'\n            call pfshow 'reset'\n          end\n          else pdsegfnd = subword(zcmd,2)\n          select\n            when words(pdsegfnd) = 1 then nop\n            when left(pdsegfnd,1) = \"'\"\n            then if right(pdsegfnd,1) /= \"'\"\n            then pdsegfnd = '\"'pdsegfnd'\"'\n            when left(pdsegfnd,1) = '\"'\n            then if right(pdsegfnd,1) /= '\"'\n            then pdsegfnd = '\"'pdsegfnd'\"'\n            when words(pdsegfnd) > 1\n            then pdsegfnd = \"'\"pdsegfnd\"'\"\n            otherwise nop\n          end\n          if pdsegfnd = null then do\n            zerrsm  = 'Error'\n            zerrlm  = 'Find requires a find string'\n            'Setmsg msg(isrz003)'\n          end\n          else do\n            call do_find\n          end\n        end\n        /* ------- *\n        | GENOnly |\n        * ------- */\n        when abbrev(\"GENONLY\",word(zcmd,1),1) = 1\n        then do\n          zcmd = null\n          if gen_hide = 1 then do\n            gen_hide = 0\n            hide_title = null\n            zerrsm = 'UnHide'\n            zerrlm = 'Base members are now displayed.'\n            'setmsg msg(isrz003)'\n            call proc_refresh\n          end\n          gen_hide = 1\n          gcount = 0\n          'tbtop' pdset\n          do forever\n            'tbskip' pdset\n            if rc > 0 then leave\n            if agen = null then iterate\n            if agen = 0 then do\n              'tbdelete' pdset\n              gcount = gcount + 1\n            end\n          end\n          'tbtop' pdset\n          zerrsm = 'Hidden'\n          zerrlm = gcount 'base members have been hidden. ' ,\n            'Use GENOnly toggle to unhide them.' ,\n            'Delete, Prune, and Rename are not supported' ,\n            'when GENOnly/Hide mode is active.'\n          'setmsg msg(isrz003)'\n          hide_title = 'GENOnly'\n        end\n        /* ------ *\n        * Hide   *\n        * ------ */\n        when abbrev(\"HIDE\",word(zcmd,1),1) = 1\n        then do\n          zcmd = null\n          if gen_hide = 1 then do\n            gen_hide = 0\n            hide_title = null\n            zerrsm = 'UnHide'\n            zerrlm = 'Generations are now displayed.'\n            'setmsg msg(isrz003)'\n            call proc_refresh\n          end\n          gen_hide = 1\n          gcount = 0\n          'tbtop' pdset\n          do forever\n            'tbskip' pdset\n            if rc > 0 then leave\n            if agen = null then iterate\n            if agen > 0 then do\n              'tbdelete' pdset\n              gcount = gcount + 1\n            end\n          end\n          'tbtop' pdset\n          zerrsm = 'Hidden'\n          zerrlm = gcount 'generations have been hidden. ' ,\n            'Use Hide toggle to unhide them.' ,\n            'Delete, Prune, and Rename are not supported' ,\n            'when Hide mode is active.'\n          'setmsg msg(isrz003)'\n          hide_title = 'Hide'\n        end\n        /* ------ *\n        * Info   *\n        * ------ */\n        when abbrev(\"INFO\",word(zcmd,1),1) = 1\n        then do\n          'dsinfo dataset('pdsedsn')'\n          zcmd = null\n          call do_metric\n          do forever\n            'tbdispl' tblmet 'panel(pdseginf)'\n            if rc > 0 then leave\n          end\n        end\n        /* ------ *\n        * Locate *\n        * ------ */\n        when abbrev(\"LOCATE\",word(zcmd,1),1) = 1\n        then do\n          if words(zcmd) = 1 then call cmd_prompt 'L'\n          lstring = word(zcmd,2)\n          if lstring = null then do\n            zerrsm = null\n            zerrlm = 'Locate requires locate string.'\n            'setmsg msg(isrz003)'\n          end\n          else call do_locate 'x'\n        end\n       /* -------------- *\n       * The PDS Command *\n       * --------------- */\n        when abbrev(\"TPC\",word(zcmd,1),3) = 1 then do /* pds.command */\n          parse var zcmd cmd pds_sub_cmd\n          zcmd = null\n          'control display line start(1)'\n          \"select cmd(pds \"pdsedsn pds_sub_cmd\")\"\n        end\n        /* ------ *\n        * Output *\n        * ------ */\n        When abbrev(\"OUTPUT\",word(zcmd,1),3) = 1\n        then do\n          zcmd = null\n          if sysvar('syspref') = null\n          then do\n            hlq = sysvar('sysuid')\n            odsn = hlq'.PDSEGEN.REPORT'\n          end\n          else do\n            hlq = sysvar('syspref')\n            odsn = \"'\"hlq\".PDSEGEN.REPORT'\"\n          end\n          if sysdsn(odsn) = 'OK' then do\n            call outtrap 'x.'\n            Address TSO ,\n              'Delete' odsn\n            call outtrap 'off'\n          end\n          oc = 0\n          drop ocl.\n          oc = oc + 1\n          ocl.oc = '1'pdsetitl\n          oc = oc + 1\n          ocl.oc = ' Date:' date() 'Time:' time()\n          oc = oc + 1\n          ocl.oc = ' '\n          oc = oc + 1\n          ocl.oc = '0Name      Gen  Abs Created      Changed        ',\n            'V.M   Size  Init   Mod ID'\n          'tbtop' pdset\n          do forever\n            'tbskip' pdset\n            if rc > 0 then leave\n            oc = oc + 1\n            ocl.oc =' 'left(mbr,8),\n              right(mgen,4),\n              right(agen,4),\n              left(cdate4,10),\n              left(mdate4,10),\n              left(mtime,5),\n              left(vrm,5),\n              right(mcur,5),\n              right(minit,5),\n              right(mmod,5),\n              left(muser,8)\n          end\n          oc = oc + 1\n          ocl.oc = '0'ztdmark\n          ocl.0 = oc\n          Address TSO\n          odd = randstr()\n          'Alloc f('odd') ds('odsn') new spa(15,15) tr' ,\n            'Recfm(f b a) lrecl(121) blksize(0)'\n          'Execio * diskw' odd '(finis stem ocl.'\n          'Free f('odd')'\n          Address ISPExec\n          'Browse dataset('odsn')'\n          zerrsm  = ' '\n          zerrlm  = 'Member table has been successfully listed.' ,\n            'The dataset' odsn 'has been retained to allow' ,\n            'additional processing.'\n          'Setmsg msg(isrz003)'\n        end\n        /* ------- *\n        * Prune   *\n        * ------- */\n        when abbrev(\"PRUNE\",word(zcmd,1),1) = 1 then do\n          if gen_hide = 1 then do\n            zerrsm = 'Warning'\n            zerrlm = 'Prune is not supported when generations are' ,\n              'hidden. Use the REFRESH command to restore the' ,\n              'generations to the member list and then you can' ,\n              'use prune.'\n            'Setmsg msg(isrz003)'\n          end\n          else do\n            if zdsngen = 0 then do\n              zerrsm = 'Error'\n              zerrlm = 'Prune does not support datasets' ,\n                'that are not generation enabled.'\n              'setmsg msg(isrz003)'\n            end\n            else do\n              prune = word(zcmd,2)\n              zcmd = null\n              do forever\n                if datatype(prune) /= 'NUM' ,\n                  | prune_prompt = 0 then do\n                  call pfshow 'off'\n                  'Addpop Row(3) Column(3)'\n                  'display panel(pdsegpru)'\n                  xrc = rc\n                  'Rempop'\n                  call pfshow 'reset'\n                  if xrc > 0 then leave\n                end\n                val = 'NO'\n                if prune = 'RESET' then\n                do forever\n                  call pfshow 'off'\n                  'Addpop Row(3) Column(3)'\n                  'display panel(pdsegprv)'\n                  xrc = rc\n                  'Rempop'\n                  call pfshow 'reset'\n                  if xrc > 0 then leave\n                  if val = 'YES' then leave\n                end\n                if datatype(prune) = 'NUM' then do\n                  if prune > -1 then\n                  if prune < zdsngen+1\n                  then call do_prune\n                  else do\n                    zerrsm = 'Error'\n                    zerrlm = prune 'value is not within the valid range' ,\n                      'of 0 to ' zdsngen\n                    'setmsg msg(isrz003)'\n                    iterate\n                  end\n                  leave\n                end\n                if prune = 'RESET' then if val /= 'YES' then leave\n                if prune = 'RESET' then call prune_all\n                else call do_prune\n                if prune = null then leave\n              end\n            end\n          end\n        end\n        /* ------- *\n        * Refresh *\n        * ------- */\n        when abbrev(\"REFRESH\",word(zcmd,1),3) = 1 then do\n          parse value '' with tfilter tfilterl tfiltert ,\n            date_filter date_filter_title ,\n            filter filter_title hide_title ,\n            HIGEN_title last_date_filter filter_id\n          higenf = 0\n          gen_hide = 0\n          if word(zcmd,2) /= null then do\n            filter = subword(zcmd,2)\n            call setup_filter\n          end\n          else call proc_refresh\n        end\n        /* ------ *\n        * Set    *\n        * ------ */\n        when abbrev(\"SET\",word(zcmd,1),2) = 1\n        then do\n          if word(zcmd,2) /= null\n          then do\n            pset = word(zcmd,2)\n            if pos(pset,'EBV/') = 0 then zcmd = 'SET'\n            pdsedo = pset\n            'vput (pdsedo)'\n            zerrsm = 'Set' pdsedo\n            zerrlm = pdsedo 'has been set as the default' ,\n              'action for the Select line option.'\n            'setmsg msg(isrz003)'\n          end\n          if word(zcmd,2) = null then do\n            zcmd = null\n            call Proc_Settings\n            'Vget (clrb clrg clrp clrr clrt clrw clry clrh clrhr' ,\n              'sortb sortc pdsetb useab) profile'\n            base_color = sortb\n            sort_color = sortc\n            call reset_color\n            Select\n              When sortcol = 'NAME'     then clrmbr   = sort_color\n              When sortcol = 'CREATED'  then clrcdate = sort_color\n              When sortcol = 'CHANGED'  then clrchang = sort_color\n              When sortcol = 'ID'       then clrmuser = sort_color\n              When sortcol = 'SIZE'     then clrmcur  = sort_color\n              When sortcol = 'MOD'      then clrmmod  = sort_color\n              When sortcol = 'INIT'     then clrminit = sort_color\n              Otherwise clrmbr = sort_color\n            End\n          end\n        end\n       /* ----------------------------------------------- *\n        | Support the SetMacro commands (SETMACRO and SM) |\n        * ----------------------------------------------- */\n        when abbrev(\"SETMACRO\",word(zcmd,1),2) = 1 then call do_imacro\n        when zcmd = 'SM' then call do_imacro\n        /* ------- *\n        * Sort    *\n        * ------- */\n        when abbrev(\"SORT\",word(zcmd,1),2) = 1 then do\n          sortcol = word(zcmd,2)\n          sort_order = left(word(zcmd,3),1)\n          zcmd = null\n          if pos(sort_order,'A D') = 0 then sort_order = null\n          if sortcol = '?' then sortcol = null\n          if sortcol = null then do\n            call ask_sort\n          end\n          if sortcol  /= null then do\n            sortseq  = word(zcmd,3)\n            lsort    = sort.sortcol\n            if lsort = 'D' then lsort = 'A'\n            else lsort = 'D'\n            if sort_order /= null then lsort = sort_order\n            sortseq       = lsort\n            sort.sortcol  = lsort\n            select\n              when abbrev(\"CREATED\",sortcol,2) = 1 then do\n                sortcol = 'CREATED'\n                sortf = 'scdate,c,'sortseq',mbr,c,a,mgen,n,d'\n                call reset_color\n                clrcdate = sort_color\n              end\n              when abbrev(\"CHANGED\",sortcol,2) = 1 then do\n                sortcol = 'CHANGED'\n                sortf = 'smdate,c,'sortseq,\n                  ',mtime,c,'sortseq',mbr,c,a,mgen,n,d'\n                call reset_color\n                clrchang = sort_color\n              end\n              when abbrev(\"ID\",sortcol,2) = 1 then do\n                sortcol = 'ID'\n                sortf = 'muser,c,'sortseq',mbr,c,',\n                  sortseq',mgen,n,d'\n                call reset_color\n                clrmuser = sort_color\n              end\n              when abbrev(\"SIZE\",sortcol,1) = 1 then do\n                sortcol = 'SIZE'\n                sortf = 'mcur,n,'sortseq\n                call reset_color\n                clrmcur  = sort_color\n              end\n              when abbrev(\"MOD\",sortcol,1) = 1 then do\n                sortcol = 'MOD'\n                sortf = 'mmod,n,'sortseq\n                call reset_color\n                clrmmod  = sort_color\n              end\n              when abbrev(\"INIT\",sortcol,2) = 1 then do\n                sortcol = 'INIT'\n                sortf = 'minit,n,'sortseq\n                call reset_color\n                clrminit = sort_color\n              end\n              when abbrev(\"NAME\",sortcol,1) = 1 then do\n                sortcol = 'NAME'\n                sortf = 'mbr,c,'sortseq',mgen,n,d'\n                call reset_color\n                clrmbr   = sort_color\n              end\n              when sortcol = '?' then do\n                call ask_sort\n              end\n              otherwise do\n                call ask_sort\n              end\n            end\n            'tbsort' pdset 'fields('sortf')'\n            'tbtop'  pdset\n          end\n        end\n        /* ------------------------------------------ *\n        | Model - Allocate a new dataset using       |\n        |         the characteristics of the current |\n        |         dataset.                           |\n        * ------------------------------------------ */\n        When abbrev(\"MODEL\",word(zcmd,1),3) = 1 then do\n          call do_model\n        end\n        /* ------ *\n        | Submit |\n        * ------ */\n        when abbrev(\"SUBMIT\",word(zcmd,1),3) = 1 then do\n          if words(zcmd) = 1 then call cmd_prompt 'SUB'\n          call do_command 'S'\n        end\n        /* -------- *\n        * Validate *\n        * -------- */\n        when abbrev(\"VALIDATE\",word(zcmd,1),2) = 1 then do\n          'Control Display Save'\n          zcmd = null\n          \"Select cmd(%pdsegval '\"wdsn\"' \"valparm\")\"\n          'Control Display Restore'\n        end\n        /* ---- *\n        | View |\n        * ---- */\n        when abbrev(\"VIEW\",word(zcmd,1),1) = 1 then do\n          if words(zcmd) = 1 then call cmd_prompt 'V'\n          call do_command 'V'\n        end\n        /* ------------------- *\n        | Age - From John K.  |\n        * ------------------- */\n        when abbrev(\"AGE\",word(zcmd,1),2) = 1 then call do_age\n        /* ------------------------------- *\n        | Command not found or recognized |\n        * ------------------------------- */\n        Otherwise do\n          zerrsm = 'Unknown Command'\n          zerrlm = 'Command entered is not recognized:' word(zcmd,1)\n          bypass_tb = 1\n          gopt = subword(zcmd,2)\n          zcmd = 'OP'\n          'Setmsg msg(isrz003)'\n        end\n      end\n    end            /* end of zcmd processing */\n\n    /* --------------- line commands ---------------------------- *\n    * Process the member selections commands:                    *\n    *             A - Attributes (Ver/Mod/Userid) (gen 0 only)   *\n    *             B - browse                                     *\n    *             C - transfer (gen 0 only)                      *\n    *             D - delete                                     *\n    *             E - edit     (for gen 0 only)                  *\n    *                 converted to V for non-0 gen)              *\n    *             G - recover  (for non-0 generations)           *\n    *             H - Hide the row                               *\n    *             J - Submit the member                          *\n    *             K - Clone the member (gen 0 only)              *\n    *                 generations are not cloned                 *\n    *             R - Rename a member and generations            *\n    *             P - promote  (for non-0 generations)           *\n    *             O - prompt for option                          *\n    *             S - select   (based on the prompt panel        *\n    *             V - view                                       *\n    *             X - eXecute the member (rexx only)             *\n    *             Z - compare  (compare the gen 0 to this non-0) *\n    *             / - prompt for option                          *\n    * ---------------------------------------------------------- */\n    if datatype(row) /= 'NUM' then row = 0\n    last_mem  = mbr\n    last_mgen = mgen\n    last_agen = agen\n    if row > 0 then\n    if msel /= null then ztdsels = 1\n    if ztdsels > 0 then do\n      if msel = 'S' then msel = pdsedo\n      if Dummy = 'G' then do\n        zerrsm  = 'Warning'\n        zerrlm  = \"This is a Dummy member that holds information about a\" ,\n          \"previously deleted member. That information includes the\" ,\n          \"highest absolute generation that was used for the member\" ,\n          \"before it, or it's generations, were deleted.\"\n        'Setmsg msg(isrz003)'\n        msel = null\n        iterate\n      end\n\n      /* ------------------------------------- *\n      | Validate the member selection options |\n      * ------------------------------------- */\n      if length(msel) = 1 then\n      if pos(msel,'/ABCDEGHIJKMOPQRTUVWXZ') = 0 then do\n        zerrsm = 'Unknown Selection'\n        zerrlm = msel 'is an unknow option - select a valid option.'\n        'Setmsg msg(isrz003)'\n        msel = '/'\n      end\n\n      /* ------------------------------------------------ *\n      | Block Command Processing                         |\n      |                                                  |\n      | Block = doubling the line command character or   |\n      |         doubling the 1st character               |\n      |                                                  |\n      | Any line selection can be blocked or a count     |\n      | e.g. X99    (expanded commands can't be counts)  |\n      * ------------------------------------------------ */\n      if abbrev('CCLONE',msel,4)  = 1 then msel = 'KK'\n      if abbrev('CCOPY',msel,4)   = 1 then msel = 'CC'\n      if abbrev('SSUBMIT',msel,4) = 1 then msel = 'JJ'\n      if abbrev('TTRANSFER',msel,2) = 1 then msel = 'CC'\n      linecmds = '// OO AA BB CC DD EE GG HH II JJ KK MM NN' ,\n        'PP RR UU VV WW XX'\n      if wordpos(left(msel,2),linecmds) > 0  then do\n        if blockcmd = 1 then do\n          if save_msel /= msel then do\n            zerrsm = 'Error'\n            zerrlm = left('Invalid/Mismatched block command.',70) ,\n              left('Starting block command:' save_msel,70) ,\n              'Ending block command:' msel\n            'Setmsg msg(isrz003)'\n            blockcmd = 0\n            block_rows = null\n          end\n        end\n        else if blockcmd /= 1 then do\n          block_rows = null\n          blockcmd = 1\n          save_msel = msel\n        end\n        'tbquery' pdset 'position(rownum)'\n        block_rows = block_rows rownum+0\n        msel = null\n        if words(block_rows) = 2\n        then call proc_block\n        else if ztdsels = 1 then do\n          zerrsm = 'Block Started'\n          zerrlm = save_msel 'block started at row:' block_rows\n          'Setmsg msg(isrz003)'\n          lopt = '*Block'\n          'tbput' pdset 'Order'\n        end\n      end\n\n      /* ------------------------------- *\n      | Check for block count commands: |\n      |                                 |\n      |    Snnnnn                       |\n      * ------------------------------- */\n      if datatype(substr(msel,2)) = 'NUM' then do\n        'tbquery' pdset 'position(rownum) rownum(maxrow)'\n        tblend = rownum+substr(msel,2)-1\n        if tblend > maxrow then tblend = maxrow\n        block_rows = rownum+0 tblend\n        save_msel = msel\n        msel = null\n        if words(block_rows) = 2 then call proc_block\n      end\n\n      /* ---------------------------- *\n      | Process the member selection |\n      * ---------------------------- */\n    Proc_Selection:\n      zerrsm = null\n\n      call logit 'Processing Selection Option:' msel 'on Member:' mbr ,\n        'Gen:' agen\n\n      if pos(msel,'O/') > 0 then do forever\n        msel = null\n        if agen > 0 then panel = 'pdsegsln'\n        else panel = 'pdsegsl0'\n        call pfshow 'off'\n        'Addpop Row(3) Column(3)'\n        'Display Panel('panel')'\n        xrc = rc\n        'Rempop'\n        call pfshow 'reset'\n        if xrc > 0 then leave\n        if rc = 0\n        then if msel /= null\n        then leave\n      end\n\n      /* ------------------------------------ *\n      | Process long line selection commands |\n      * ------------------------------------ */\n      Select\n        When abbrev(\"ATTRIB\",msel,1)    = 1 then msel = 'A'\n        When abbrev(\"BROWSE\",msel,1)    = 1 then msel = 'B'\n        When abbrev(\"CLONE\",msel,2)     = 1 then msel = 'K'\n        When abbrev(\"COMPARE\",msel,3)   = 1 then msel = 'Z'\n        When abbrev(\"COPY\",msel,3)      = 1 then msel = 'C'\n        When abbrev(\"DELETE\",msel,1)    = 1 then msel = 'D'\n        When abbrev(\"EDIT\",msel,1)      = 1 then msel = 'E'\n        When abbrev(\"EXECUTE\",msel,2)   = 1 then msel = 'X'\n        When abbrev(\"HIDE\",msel,1)      = 1 then msel = 'H'\n        When abbrev(\"INFO\",msel,1)      = 1 then msel = 'I'\n        When abbrev(\"KLONE\",msel,1)     = 1 then msel = 'K'\n        When abbrev(\"MAIL\",msel,2)      = 1 then msel = 'M'\n        When abbrev(\"PROMOTE\",msel,1)   = 1 then msel = 'P'\n        When abbrev(\"RECOVER\",msel,3)   = 1 then msel = 'G'\n        When abbrev(\"RENAME\",msel,3)    = 1 then msel = 'R'\n        When msel = \"RENS\"                  then msel = 'Q'\n        When msel = \"RENSWAP\"               then msel = 'Q'\n        When abbrev(\"SELECT\",msel,2)    = 1 then msel = 'S'\n        When abbrev(\"SUBMIT\",msel,2)    = 1 then msel = 'J'\n        When abbrev(\"TRANSFER\",msel,2)  = 1 then msel = 'C'\n        When abbrev(\"TRYIT\",msel,1)      = 1 then msel = 'T'\n        When abbrev(\"USER\",msel,1)      = 1 then msel = 'U'\n        When abbrev(\"VIEW\",msel,1)      = 1 then msel = 'V'\n        Otherwise nop\n      end\n\n      Select\n        /* ---------------------------------------------------- *\n        | When the selection is > 1 character                  |\n        | - checks for EE/EE, Enn, Dnn, DD/DD must be prior to |\n        |   this test                                          |\n        * ---------------------------------------------------- */\n        when length(msel) > 1 then do\n          zucmd = msel '/'\n          call do_user\n          lopt  = '*'msel\n          lopts = lopt\n          msel  = null\n          'tbput' pdset 'Order'\n        end\n        /* ---------- *\n        | Attributes |\n        * ---------- */\n        When msel = 'A' then do\n          if mgen < 0 then do\n            zerrsm  = 'Invalid option'\n            zerrlm  = 'Attributes is only allowed for generation 0' ,\n              'members.'\n            'Setmsg msg(isrz003)'\n          end\n          else do\n            parse value vrm with avr'.'amd\n            aid = muser\n            'control display save'\n            call pfshow 'off'\n            'Addpop Row(3) Column(3)'\n            'Display Panel(pdsegat)'\n            xrc = rc\n            'Rempop'\n            call pfshow 'reset'\n            'control display restore'\n            if xrc = 0 then do\n              avr = avr * 1\n              amd = amd * 1\n              if avr < 10 then avr = '0'avr\n              if amd < 10 then amd = '0'amd\n              'LMMStats Dataid('pdsegend')' ,\n                'Member('mbr') version('avr') modlevel('amd')' ,\n                'User('aid')'\n              lrc = rc\n              if lrc = 0 then do\n                vrm = avr'.'amd\n                muser = aid\n                zerrsm = 'Updated'\n                zerrlm = 'Attributes updated for member' mbr 'to' ,\n                  'Version:' avr 'Modification Level:' amd ,\n                  'Userid:' muser\n                'setmsg msg(isrz003)'\n                lopt  = '*Attrib'\n                lopts = lopt\n                msel  = null\n                'tbput' pdset 'Order'\n              end\n              else do\n                'setmsg msg(isrz003)'\n              end\n            end\n            else do\n              zerrsm = 'Canceled'\n              zerrlm = 'Attributes update canceled'\n              'setmsg msg(isrz003)'\n            end\n          end\n        end\n        /* ------ *\n        * Browse *\n        * ------ */\n        when msel = 'B' then call do_browse\n        /* ---------------------------------------------------- *\n        | C - Copy a member to another PDSE (or PDS)           |\n        |   - only works for Base members                      |\n        |   - will transfer generations                        |\n        |   - prompts for target PDSE/PDS (must already exist) |\n        |   - invokes PDSEGENC                                 |\n        * ---------------------------------------------------- */\n        When msel = 'C' then do\n          zerrsm = null\n          if mgen < 0 then\n          if blockcmd /= 1 then do\n            zerrsm  = 'Invalid option'\n            zerrlm  = 'Copy is only allowed for generation 0' ,\n              'members.'\n            'Setmsg msg(isrz003)'\n          end\n          'Control Display Save'\n          if zerrsm = null then\n          do forever\n            xrc = 0\n            if blockcmd /= 1 then topdse = null\n            if topdse /= null then leave\n            'Addpop Row(3) Column(3)'\n            'Display Panel(pdsegxfr)'\n            xrc = rc\n            'Rempop'\n            if xrc > 0 then leave\n            zerrsm = null\n            x = listdsi(ztdsn)\n            if x > 0 then do\n              zerrsm = 'Invalid DSN'\n              zerrlm = ztdsn sysdsn(ztdsn)\n              'Setmsg msg(isrz003)'\n            end\n            if left(ztdsn,1) = \"'\"\n            then wtdsn = strip(ztdsn,'B',\"'\")\n            else wtdsn = sysvar('syspref')'.'ztdsn\n            if wdsn = wtdsn then do\n              zerrsm = 'Error.'\n              zerrlm = 'The from and the to datasets may not be the same.'\n              'Setmsg msg(isrz003)'\n            end\n            if zerrsm = null then leave\n          end\n          'Control Display Restore'\n          topdse = ztdsn\n          if zerrsm = null then\n          if xrc = 0 then do\n            if repxfr = 'Y' then replopt = '( Replace'\n            else replopt = null\n            address tso ,\n              \"%pdsegenc '\"wdsn\"'\" ztdsn mbr replopt\n            if rc = 0 then do\n              lopt  = '*Copy'\n              lopts = lopt\n              msel  = null\n              'tbput' pdset 'Order'\n            end\n          end\n        end\n        /* ---------------------------------------------------- *\n        * D - Delete process                                   *\n        *                                                      *\n        * If pending delete then create a dummy member to hold *\n        * the base and allow access to the generations         *\n        * ---------------------------------------------------- */\n        when msel = 'D' then do\n          pdsedelu = 'N'\n          if gen_hide = 1 then do\n            zerrsm = 'Warning'\n            zerrlm = 'Delete is not supported when generations are' ,\n              'hidden. Use the REFRESH command to restore the' ,\n              'generations to the member list and then you can' ,\n              'use delete.'\n            'Setmsg msg(isrz003)'\n          end\n          else do\n            if Dummy = 'G' then do\n              Address TSO\n              \"Alloc f(\"pdsegdd\") shr reuse\" ,\n                \"dsn('\"wdsn\"(\"mbr\")')\"\n              s.0 = 1;s.1 = 'Primary member for Dummy member'\n              \"Execio * diskw\" pdsegdd \"(finis stem s.\"\n              \"Free f(\"pdsegdd\")\"\n              Address ISPExec\n              mgen = 0\n            end\n            if pdsedelp = 'N' then do\n              pdsedel  = 'N'\n              call pfshow 'off'\n              'Addpop Row(3) Column(3)'\n              if mgen = 0\n              then 'display panel(pdsegdlb)'\n              else 'display panel(pdsegdlg)'\n              'Rempop'\n              call pfshow 'reset'\n            end\n            else pdsedel = 'Y'\n            if pdsedel = 'Y' then\n            if pdsedelu = 'Y' then call del_promote\n            else\n            if pdsedel = 'Y' then do\n              if agen > 0 then do\n                Address TSO\n                'Alloc f('pdsedd') shr reuse ds('pdsedsn')'\n                x = proc_del(mbr agen pdsedd)\n                'Free f('pdsedd')'\n                zerrsm  = 'Deleted'\n                zerrlm  = mbr 'gen' mgen 'deleted.'\n                Address ISPExec\n                'tbdelete' pdset\n                'Setmsg msg(isrz003)'\n                proc_mems = proc_mems mbr 'D'\n              end\n              else do\n                save_top = ztdtop\n                'tbtop' pdset\n                dmbr  = mbr\n                dgens = null\n                do forever\n                  'tbvclear' pdset\n                  mbr = dmbr\n                  'tbscan' pdset 'arglist(mbr)'\n                  if rc > 0 then leave\n                  if mbr > dmbr then leave\n                  if mbr = dmbr then do\n                    if strip(agen) = null then agen = 0\n                    dgens = dgens strip(agen)\n                  end\n                end\n                idw = words(dgens)\n                Address TSO ,\n                  'Alloc f('pdsedd') shr reuse ds('pdsedsn')'\n                do id = idw to 1 by -1\n                  x = proc_del(dmbr word(dgens,id) pdsedd)\n                end\n                Address TSO ,\n                  'Free f('pdsedd')'\n                mbr = dmbr\n                call delete_mem\n                ztdtop = save_top\n                zerrsm  = 'Deleted'\n                zerrlm  = dmbr 'and all generations have been deleted.'\n                'Setmsg msg(isrz003)'\n              end\n            end\n          end\n        end\n        /* ---------------------------------------- *\n        * Edit                                     *\n        * If non-0 generation then convert to View *\n        * ---------------------------------------- */\n        when msel = 'E' then call do_edit\n        /* ------ *\n        * eMail  *\n        * ------ */\n        when msel = 'M' then\n        if mail /= 0 then do\n          'control display save'\n          call do_email\n          'control display restore'\n          lopt = '*eMail'\n          lopts = lopt\n          msel  = null\n          'tbput' pdset 'Order'\n        end\n        else do\n          zerrsm  = 'Error'\n          zerrlm  = 'The M (mail) option is not supported by' ,\n            'this installation.'\n          'Setmsg Msg(isrz003)'\n        end\n        /* ------------ *\n        | H - Hide row |\n        * ------------ */\n        when msel = 'H' then 'TBDelete' pdset\n        /* ----------------------------------------- *\n        * K - Klone member                          *\n        *   - prompt the user for a new member name *\n        *     into which this base member will      *\n        *     be copied into.                       *\n        * ----------------------------------------- */\n        when msel = 'K' then do\n          zerrsm  = null\n          znewmem = null\n          if agen > 0 then do\n            zerrsm  = 'Error'\n            zerrlm  = 'The K (Clone) operation can only be done' ,\n              'on a base (generation 0) member.'\n            'Setmsg Msg(isrz003)'\n            znewmem = null\n          end\n          if lopt /= null then\n          if left(lopt,1) /= '*' then do\n            znewmem = translate(lopt)\n            bypass = 1\n          end\n          if znewmem /= null\n          then x = valname(znewmem)\n          if x /= 0 then do\n            bypass = 0\n            zerrsm = 'Error'\n            zerrlm = x\n            'Setmsg msg(isrz003)'\n            zerrsm = null\n          end\n          if znewmem /= null then\n          if sysdsn(\"'\"wdsn\"(\"znewmem\")'\") = 'OK' then do\n            bypass = 0\n            zerrsm = 'Error'\n            zerrlm = znewmem 'currently exists - pick a new name.'\n            'Setmsg msg(isrz003)'\n            zerrsm = null\n          end\n          if zerrsm = null then do forever\n            zerrsm  = null\n            if bypass /= 1 then do\n              call pfshow 'off'\n              'Addpop Row(3) Column(3)'\n              'Display Panel(pdsegcl)'\n              xrc = rc\n              'Rempop'\n              call pfshow 'reset'\n            end\n            else do\n              xrc = 0\n              bypass = 0\n            end\n            if xrc > 0 then do\n              znewmem = null\n              leave\n            end\n            if xrc = 0 then do\n              if znewmem = null then leave\n              if sysdsn(\"'\"wdsn\"(\"znewmem\")'\") /= 'OK' then leave\n              zerrsm  = 'Error'\n              zerrlm  = znewmem \"exists - pick a new name\"\n              'Setmsg Msg(isrz003)'\n            end\n          end\n          if znewmem = null then\n          if zerrsm  = null then do\n            zerrsm  = 'Cancelled'\n            zerrlm  = 'Cloning (K) cancelled'\n            'Setmsg Msg(isrz003)'\n          end\n          if zerrsm  = null then do\n            lopt = '*Klone'\n            lopts = lopt\n            msel  = null\n            call do_klone\n            'tbput' pdset 'Order'\n            mbr = znewmem\n            proc_mems = proc_mems znewmem 'Klone'\n            lopt = null\n            lopts = null\n          end\n        end\n        /* --------------------------------------------------- *\n        * Promote process                                     *\n        *   Copies the non-0 generation into the generation 0 *\n        *   member leaving the user in Edit.                  *\n        *   Also promotes HIGEN members to gen 0              *\n        * --------------------------------------------------- */\n        when msel = 'P' then do\n          zerrsm  = null\n          if mgen = 0 then do\n            zerrsm  = 'Error'\n            zerrlm  = 'Promote can only be done on a generation' ,\n              'other than generation 0.'\n            'Setmsg Msg(isrz003)'\n          end\n          if mgen = null then do\n            zerrsm  = 'Error'\n            zerrlm  = 'Promote can not be done on a non-generation' ,\n              'dataset member.'\n            'Setmsg Msg(isrz003)'\n          end\n          if zerrsm  = null then do\n            call create_temp\n            pdsemopt = 'R'\n            pdsecpds = \"'\"wdsn\"(\"mbr\")'\"\n            'vput (pdsecpds)'\n            'control display save'\n            'edit dataset('tdsn') macro(pdsegenm) parm(pdsemopt)'\n            'control display restore'\n            Address TSO 'Free f('zpdsendd') Delete'\n            pmbr = mbr\n            if cdate /= null then do\n              parse var vrm iver'.'imod\n              'LMMStats Dataid('pdsegend')' ,\n                'Member('mbr') version('iver') modlevel('imod')' ,\n                'Created('cdate') Moddate('mdate')' ,\n                'Modtime('mtime') Cursize('mcur')' ,\n                'Initsize('minit') Modrecs('mmod')' ,\n                'User('muser')'\n            end\n            lopt = '*Promote'\n            lopts = lopt\n            msel  = null\n            proc_mems = proc_mems mbr 'Promote'\n            'tbput' pdset 'Order'\n            lopt = null\n            lopts = null\n          end\n        end\n        /* ----------------------------------------- *\n        * G - Recover generation to base member     *\n        *   - prompt the user for a new member name *\n        *     into which this non-0 generation will *\n        *     be created into.                      *\n        * ----------------------------------------- */\n        when msel = 'G' then do\n          zerrsm  = null\n          znewmem = null\n          if Dummy = 'G' then mgen = -1\n          if agen = 0 then\n          if mgen = 0 then do\n            zerrsm  = 'Error'\n            zerrlm  = 'Recovery can only be done on a generation' ,\n              'other than generation 0.'\n            'Setmsg Msg(isrz003)'\n            znewmem = null\n          end\n          if agen = null then do\n            zerrsm  = 'Error'\n            zerrlm  = 'Recovery cannot be performed on a non-generation' ,\n              'dataset mamber. '\n            'Setmsg Msg(isrz003)'\n            znewmem = null\n          end\n          if zerrsm = null then do forever\n            zerrsm  = null\n            if lopt /= null then\n            if left(lopt,1) /= '*'\n            then do\n              bypass = 1\n              znewmem = translate(lopt)\n            end\n            if znewmem /= null\n            then x = valname(znewmem)\n            if x /= 0 then do\n              bypass = 0\n              zerrsm = 'Error'\n              zerrlm = x\n              'Setmsg msg(isrz003)'\n              zerrsm = null\n            end\n            if znewmem /= null then\n            if sysdsn(\"'\"wdsn\"(\"znewmem\")'\") = 'OK' then do\n              bypass = 0\n              zerrsm = 'Error'\n              zerrlm = znewmem 'currently exists - pick a new name.'\n              'Setmsg msg(isrz003)'\n              zerrsm = null\n            end\n            if bypass /= 1 then do\n              call pfshow 'off'\n              'Addpop Row(3) Column(3)'\n              if Dummy = 'G'\n              then 'Display Panel(pdsegrmp)'\n              else 'Display Panel(pdsegrm)'\n              xrc = rc\n              'Rempop'\n              call pfshow 'reset'\n            end\n            else do\n              bypass = 0\n              xrc = 0\n            end\n            if xrc > 0 then do\n              znewmem = null\n              leave\n            end\n            if xrc = 0 then do\n              if znewmem = null then leave\n              if mbr /= znewmem then\n              if sysdsn(\"'\"wdsn\"(\"znewmem\")'\") /= 'OK' then leave\n              zerrsm  = 'Error'\n              if Dummy = 'G' then\n              zerrlm  = \"Recovery not allowed to the same member name.\"\n              else\n              zerrlm  = znewmem \"exists - pick a new name\"\n              'Setmsg Msg(isrz003)'\n            end\n          end\n          if znewmem = null then\n          if zerrsm  = null then do\n            zerrsm  = 'Cancelled'\n            zerrlm  = 'Recovery cancelled'\n            'Setmsg Msg(isrz003)'\n          end\n          if zerrsm  = null then do\n            lopt = '*Recover'\n            lopts = '*G'\n            msel  = null\n            if Dummy /= 'G' then do\n              'tbput' pdset 'Order'\n              lopt = null\n              lopts = null\n              msel = null\n              pdsemopt = 'R'\n              pdsecpds = \"'\"wdsn\"(\"znewmem\")'\"\n              'vput (pdsecpds)'\n              'edit dataid('pdsegend') member('mbr') gen('agen')' ,\n                'macro(pdsegenm) parm(pdsemopt)'\n              mbr = znewmem\n            end\n            if Dummy = 'G' then do\n              'tbdelete' pdset\n              mgen = agen\n              Address TSO\n              \"Alloc f(\"pdsegdd\") shr reuse\" ,\n                \"dsn('\"wdsn\"(\"znewmem\")')\"\n              s.0 = 1;s.1 = 'Primary member for HIGen members'\n              \"Execio * diskw\" pdsegdd \"(finis stem s.\"\n              \"Free f(\"pdsegdd\")\"\n              Address ISPExec\n              pdsecpds = \"'\"wdsn\"(\"znewmem\")'\"\n              pdsemopt = 'R'\n              'vput (pdsecpds)'\n              'edit dataid('pdsegend') member('mbr') gen('agen')' ,\n                'macro(pdsegenm) parm(pdsemopt)'\n              'tbtop' pdset\n              do forever\n                'tbvclear' pdset\n                mbr = znewmem\n                'tbscan' pdset 'arglist(mbr)'\n                if rc > 0 then leave\n                'tbdelete' pdset\n              end\n              mbr = znewmem\n              call update_mem\n              'tbtop' pdset\n              do forever\n                'tbvclear' pdset\n                mbr = znewmem\n                'tbscan' pdset 'arglist(mbr)'\n                if rc > 0 then leave\n                address tso\n                'Alloc f('pdsedd') shr reuse ds('pdsedsn')'\n                x = proc_del(mbr agen pdsedd)\n                agen = agen - 1\n                x = proc_del(mbr agen pdsedd)\n                'Free f('pdsedd')'\n                address ispexec\n                call update_mem\n                gclean = 1\n              end\n            end\n            if gclean /= 1 then do\n              mbr = znewmem\n              call new_mem\n              lstring = mbr\n              call do_locate\n              msel  = null\n              Dummy = null\n              proc_mems = proc_mems mbr 'Recover'\n              lopt = null\n              lopts = null\n            end\n          end\n        end\n        /* ----------------------------------------- *\n        * R - Rename member                         *\n        *   - prompt the user for a new member name *\n        *     that this member and its generations  *\n        *     will be renamed to.                   *\n        * ----------------------------------------- */\n        when msel = 'R' then do\n          if gen_hide = 1 then do\n            zerrsm = 'Warning'\n            zerrlm = 'Rename is not supported when generations are' ,\n              'hidden. Use the REFRESH command to restore the' ,\n              'generations to the member list and then you can' ,\n              'use rename.'\n            'Setmsg msg(isrz003)'\n          end\n          zerrsm  = null\n          znewmem = null\n          if agen > 0 then do\n            zerrsm  = 'Error'\n            zerrlm  = 'Rename can only be done on a generation 0' ,\n              'member.'\n            'Setmsg Msg(isrz003)'\n            znewmem = null\n          end\n          if lopt /= null then\n          if left(lopt,1) /= '*' then do\n            znewmem = translate(lopt)\n            bypass = 1\n          end\n          if znewmem /= null\n          then x = valname(znewmem)\n          if x /= 0 then do\n            bypass = 0\n            zerrsm = 'Error'\n            zerrlm = x\n            'Setmsg msg(isrz003)'\n            zerrsm = null\n          end\n          if znewmem /= null then\n          if sysdsn(\"'\"wdsn\"(\"znewmem\")'\") = 'OK' then do\n            bypass = 0\n            zerrsm = 'Error'\n            zerrlm = znewmem 'currently exists - pick a new name.'\n            'Setmsg msg(isrz003)'\n            zerrsm = null\n          end\n          if zerrsm = null then do forever\n            zerrsm  = null\n            if bypass /= 1 then do\n              call pfshow 'off'\n              'Addpop Row(3) Column(3)'\n              'Display Panel(pdsegrnm)'\n              xrc = rc\n              'Rempop'\n              call pfshow 'reset'\n            end\n            else do\n              xrc = 0\n              bypass = 0\n            end\n            if xrc > 0 then do\n              znewmem = null\n              leave\n            end\n            if xrc = 0 then do\n              if znewmem = null then leave\n              if sysdsn(\"'\"wdsn\"(\"znewmem\")'\") /= 'OK' then leave\n              zerrsm  = 'Error'\n              zerrlm  = znewmem \"exists - pick a new name\"\n              'Setmsg Msg(isrz003)'\n            end\n          end\n          if znewmem = null then\n          if zerrsm  = null then do\n            zerrsm  = 'Cancelled'\n            zerrlm  = 'Rename (R) cancelled'\n            'Setmsg Msg(isrz003)'\n          end\n          if zerrsm  = null then do\n            save_top = ztdtop\n            'tbtop' pdset\n            rmbr  = mbr\n            rgens = null\n            drop rmem.\n            do forever\n              'tbskip' pdset\n              if rc > 0 then leave\n              if mbr = rmbr then do\n                parse var vrm iver'.'imod\n                if strip(agen) = null then agen = 0\n                rgens = rgens strip(agen)\n                rmem.agen = mbr agen'\\'iver'\\'imod'\\'cdate,\n                  '\\'mdate'\\' mtime'\\'mcur'\\'minit'\\'mmod'\\'muser\n              end\n            end\n            call do_rename\n            /* remove the from member from the table */\n            mbr = rmbr\n            call delete_mem\n            /* remove the new member from the table just in case */\n            mbr = znewmem\n            call delete_mem\n            /* now add the new member to the table */\n            mbr = znewmem\n            call update_mem\n            /* now update the table info */\n            save_top = ztdtop\n            'tbtop' pdset\n            mbr = znewmem\n            agen = 0\n            'tbscan' pdset 'arglist(mbr agen) position(srowcrp)'\n            'tbget' pdset\n            lopt = '*RENAME'\n            lopts = '*R'\n            'tbput' pdset\n          end\n        end\n        /* -------------------------------------------- *\n        | Rename Swap (Q)                              |\n        | - Rename swaps 2 members and all generations |\n        * -------------------------------------------- */\n        when msel = 'Q' then call do_rename_swap\n        /* -------------------------------------------- *\n        | TRYIT - Edit the member with the TRYIT macro |\n        * -------------------------------------------- */\n        when msel = 'T' then call do_tryit\n        /* ---- *\n        * View *\n        * ---- */\n        when msel = 'V' then call do_view\n        /* ------------ *\n        * User Command *\n        * ------------ */\n        when msel = 'U' then do\n          call do_user\n          lopt  = '*User'\n          lopts = lopt\n          msel  = null\n          'tbput' pdset 'Order'\n        end\n        /* ------- *\n        * eXecute *\n        * ------- */\n        when msel = 'X' then do\n          'control display save'\n          call do_eXecute\n          'control display restore'\n          lopt = '*eXecute'\n          lopts = lopt\n          msel = null\n          'tbput' pdset 'Order'\n        end\n        /* ------- *\n        * Info    *\n        * ------- */\n        when msel    = 'I' then do\n          /* slick translate from Doug Nadel */\n          xagen = strip(translate('0,123,456,789,abc,def', ,\n            right(agen,16,','), ,\n            '0123456789abcdef'),'L',',')\n          'control display save'\n          'Addpop row(3) column(3)'\n          'Display Panel(pdsegeni)'\n          'Rempop'\n          'control display restore'\n          lopt  = '*Info'\n          lopts = lopt\n          msel  = null\n          'tbput' pdset 'Order'\n        end\n        /* ------- *\n        * Submit  *\n        * ------- */\n        when msel = 'J' then do\n          call do_submit\n          lopt  = '*Submit'\n          lopts = lopt\n          msel  = null\n          'tbput' pdset 'Order'\n        end\n        /* ---------------------------------------------------- *\n        * Watch Out - allows editing any member or generation. *\n        * When editing a non-0 generation any updates can be   *\n        * saved but they cannot be accessed via JCL or         *\n        * Dynamic Allocation.                                  *\n        *                                                      *\n        * Note the ISPF statistics will be updated for the     *\n        * member when the member list display is refreshed.    *\n        * ---------------------------------------------------- */\n        when msel = 'W' then do\n          if agen > 0 then do\n            zerrsm = 'Warning'\n            zerrlm = 'You are editing a non-0 generation and if you' ,\n              'save your changes there will NOT be a new' ,\n              'generation created and you can not access this' ,\n              'update using JCL or Dynamic Allocation.'\n            'Setmsg msg(isrz003)'\n          end\n          higen = (words(all_members.mbr) -2) *-1\n          pdsemopt = 'EM'\n          'vput (mgen agen higen) shared'\n          'Control Display Save'\n          'Edit dataid('pdsegend') member('mbr') gen('agen')' ,\n            'macro(pdsegenm) parm(pdsemopt)'\n          'Control Display Restore'\n          lopt  = '*WarnEdit'\n          lopts = lopt\n          msel  = null\n          'tbput' pdset 'Order'\n          lopt = null\n          lopts = null\n        end\n        /* ----------- *\n        | Z - COMpare |\n        * ----------- */\n        when msel = 'Z' then do\n          if mgen = 0 then do\n            zcmd = '$' mbr 0\n            lopt = '*Compare'\n            lopts = '*Z'\n            msel = null\n            'tbput' pdset 'Order'\n            lopt = null\n            lopts = null\n            call compare_prompt\n          end\n          else do\n            cfrom = 0\n            cto   = mgen\n            cmem  = mbr\n            lopt = '*Compare'\n            lopts = '*Z'\n            msel = null\n            'tbput' pdset 'Order'\n            lopt = null\n            lopts = null\n            call do_compare\n          end\n        end\n        When msel = null then nop\n        /* This routine should never be entered as the line\n        selection options are validated much earlier */\n        Otherwise do\n          if zerrsm = null then do\n            zerrsm = 'Invalid Option'\n            zerrlm = msel 'is not a recognized line selection option.'\n            'setmsg msg(isrz003)'\n          end\n        end\n      end\n      if words(block_rows) = 2 then return\n\n      /* ---------------------------------------- *\n      * Clean up and update the last used option *\n      * ---------------------------------------- */\n    Clean_Up:\n      arg return_opt\n      parse value '' with lopt lopts msel update_table edit_stat\n      if ztdsels = 1 then\n      if proc_mems /= null then do\n        lopt  = null\n        lopts = null\n        lopts = null\n        pdsedelp = 'N'\n        pdsedelu = 'N'\n        call refresh_pdsi\n        do um = 1 to words(proc_mems) by 2\n          mbr = word(proc_mems,um)\n          mopt = word(proc_mems,um+1)\n          call update_mem 'x'\n          update_table = update_table mbr\n          if left(mopt,1) = 'E' then edit_stat = edit_stat mbr\n          if mopt = 'Recover' then edit_stat = edit_stat mbr\n          if mopt = 'Klone'  then do\n            mopt = 'Kloned'\n            edit_stat = edit_stat mbr\n          end\n        end\n        call proc_pdsegeni\n        do um = 1 to words(edit_stat)\n          mbr = word(edit_stat,um)\n          'tbtop' pdset\n          'tbscan' pdset 'arglist(mbr) position(scanrow) condlist(eq)'\n          lopt = '*'mopt\n          if mopt = 'Recover'\n          then lopts = '*G'\n          else lopts = lopt\n          'tbput' pdset 'Order'\n          lopt = null\n          lopts = null\n        end\n        mbr = word(proc_mems,1)\n        lstring = mbr\n        scrp = crp\n        call do_locate\n        crp = scrp\n        proc_mems = null\n      end\n      if return_opt /= null then do\n        return_opt = null\n        return\n      end\n      update_table = null\n      edit_stat    = null\n    end\n  end\n\n  if do_pdsedsl = 1 then do\n    pdsedsn = '*'\n    call close\n    signal restart\n  end\n\n  if dsn_prompt = 1 then do\n    pdsedsn = null\n    call close\n    signal restart\n  end\n\nExit:\n  call close\n  call logit 'PDSEGEN processing ending - rc 0'\n  exit 0\n\n  /* -------------------------------- *\n  | Enter/Manage Initial Edit Macros |\n  * -------------------------------- */\nDo_IMacro:\n  'vget (imacvar) profile'\n  imtab = 'im'random(9999)\n  'tbcreate' imtab 'keys(imsuff) names(imacro imacprm) nowrite'\n  workvar = imacvar\n  do forever\n    parse value workvar with imsuff imacro imacprm '%' workvar\n    if strip(imsuff) = null then leave\n    'tbadd' imtab\n    'tbsort' imtab 'fields(imsuff,ch,a)'\n  end\n  ztdsels = 0\n  do forever\n    zcmd = null\n    if ztdsels < 2 then do\n      'tbtop' imtab\n      'tbdispl' imtab 'panel(pdsegimc)'\n    end\n    else 'tbdispl' imtab\n    if rc > 4 then leave\n    if abbrev('INSERT',zcmd,1) = 1 then do forever\n      zsel = null\n      zcmd = null\n      imsuff = null\n      'control display save'\n      'addpop row(3) column(3)'\n      'display panel(pdsegima)'\n      drc = rc\n      'rempop'\n      'control display restore'\n      if drc > 0 then leave\n      newmac = imsuff imacro imacprm\n      if wordpos(imsuff,imacvar) > 0 then do\n        zerrsm = 'Error'\n        zerrlm = 'The suffix' imsuff 'already exists, use Change to' ,\n          'update it if necessary.'\n        'setmsg msg(isrz003)'\n      end\n      else imacvar = imacvar newmac '%'\n      'vput (imacvar) profile'\n      'tbadd' imtab\n      'tbsort' imtab 'fields(imsuff,ch,a)'\n      leave\n    end\n    if zsel = 'C' then do\n      zsel = null\n      zcmd = null\n      osuff = imsuff\n      'control display save'\n      'addpop row(3) column(3)'\n      'display panel(pdsegimu)'\n      drc = rc\n      'rempop'\n      'control display restore'\n      if drc = 0 then do\n        cmac = imsuff imacro imacprm\n        call del_imac\n        imacvar = imacvar cmac '%'\n        'vput (imacvar) profile'\n        'tbmod' imtab\n        'tbsort' imtab 'fields(imsuff,ch,a)'\n      end\n    end\n    if zsel = 'D' then call del_imac\n  end\n  'tbend' imtab\n  return\n\nDel_Imac:\n  zsel = null\n  wp = wordpos(imsuff,imacvar)\n  newmac = ''\n  do until length(imacvar) = 0\n    parse value imacvar with sfx smx smp '%' imacvar\n    if sfx = imsuff then iterate\n    newmac = newmac sfx smx smp '%'\n  end\n  imacvar = newmac\n  'vput (imacvar) profile'\n  'tbdelete' imtab\n  return\n\n  /* ------------------------- *\n  | Process the Model command |\n  * ------------------------- */\nDo_Model: Procedure Expose pdsedsn zdsngen null zcmd dfamgen\n  'dsinfo dataset('pdsedsn')'\n  if words(zcmd) = 2 then mdsn = word(zcmd,2)\n  else mdsn   = pdsedsn\n  newgen = zdsngen\n  munit  = left(zdsspc,1)\n  dsnt   = left(zdsdsnt,1)\n  'Control Display Save'\n  'Addpop Row(3) Column(3)'\n  do forever\n    zcmd   = null\n    'Display Panel(pdsegmdl)'\n    xrc = rc\n    if xrc > 0 then leave\n    if sysdsn(mdsn) /= 'OK' then leave\n    zerrsm = 'Error...'\n    zerrlm = mdsn 'already exists - try a different dsn.'\n    'setmsg msg(isrz003)'\n  end\n  'RemPop'\n  'Control Display Restore'\n  if xrc > 0 then do\n    zerrsm = 'Cancelled'\n    zerrlm = 'Model request has been cancelled.'\n    'setmsg msg(isrz003)'\n    return\n  end\n  zdsrf = strip(left(zdsrf,1)' 'substr(zdsrf,2,1)' 'substr(zdsrf,3,1))\n  library = null\n  if dsnt = 'P' then\n  library = 'Dsntype(PDS) dsorg(po) dir('zdsdira')'\n  if (dsnt = 'L' & newgen = 0) then\n  library = 'Dsntype(Library,2) dsorg(po) dir(1)'\n  if (dsnt = 'L' & newgen > 0) then\n  library = 'Dsntype(Library,2) dsorg(po) dir(1) maxgens('newgen')'\n  if zdsvol = null then vol = null\n  else vol = 'Vol('zdsvol')'\n  space = null\n  if munit = 'B' then space = 'Block('zdsblk')'\n  if munit = 'T' then space = 'Tracks'\n  if munit = 'C' then space = 'Cylinders'\n  Address TSO ,\n    'Alloc ds('mdsn') new spa('zds1ex','zds2ex')' vol ,\n    'Recfm('zdsrf') Lrecl('zdslrec') Blksize('zdsblk')' ,\n    library space\n  if rc = 0 then do\n    zerrsm = 'Allocated'\n    zerrlm = mdsn 'allocated with Space('zds1ex','zds2ex')' ,\n      'Recfm('zdsrf') Lrecl('zdslrec') Blksize('zdsblk')' ,\n      vol library space\n    topdse = mdsn\n    Address TSO ,\n    \"Free ds(\"mdsn\")\"\n  end\n  else do\n    zerrsm = 'Error'\n    zerrlm = 'Allocation failure for' mdsn\n  end\n  'setmsg msg(isrz003)'\n  return\n\n  /* -------------------------- *\n  | Process the block commands |\n  * -------------------------- */\nProc_Block:\n  rstart = word(block_rows,1)\n  rend   = word(block_rows,2)\n  if rend < rstart then do\n    rhold = rstart\n    rstart = rend\n    rend = rhold\n  end\n  if pos(left(save_msel,1),'HD') = 0\n  then do pblk = rstart to rend\n    'tbtop' pdset\n    'tbskip' pdset 'number('pblk')'\n    if rc > 0 then leave\n    msel = left(save_msel,1)\n    call proc_selection\n  end\n  else do pblk = rend to rstart by -1\n    'tbtop' pdset\n    'tbskip' pdset 'number('pblk')'\n    if rc > 0 then leave\n    msel = left(save_msel,1)\n    call proc_selection\n  end\n  blockcmd = 0\n  block_rows = null\n  save_msel = null\n  msel = null\n  return\n\n  /* --------------------------------------------- *\n  | Do_Browse Routine.                            |\n  |                                               |\n  | Called by Browse command and B line selection |\n  * --------------------------------------------- */\nDo_Browse:\n  if zdsngen > 0 then do\n    higenr = (words(members.mbr) -1) *-1\n    higena = word(members.mbr,2)\n    if mgen /= 0 then do\n      msggen = mgen'('agen')'\n    end\n    else msggen = 0\n  end\n  else do\n    msggen = 0\n    higenr = 0\n    higena = 0\n  end\n  zerrsm = 'Gen' mgen\n  if higenr = 0 then hm = 0\n  else hm = higenr'('higena')'\n  if zdsngen > 0 then\n  zerrlm = 'Browsing generation' msggen 'with a high' ,\n    'gen of' hm\n  else\n  zerrlm = 'Browsing a PDS member in a PDS with no' ,\n    'generations defined.'\n  'setmsg msg(isrz003)'\n  'control display save'\n  'Browse dataid('pdsegend') member('mbr') gen('agen')'\n  if rc > 4 then 'setmsg msg(isrz003)'\n  'control display restore'\n  'tbtop' pdset\n  'tbscan' pdset 'arglist(mbr agen)'\n  msel = null\n  lopt = '*Browse'\n  lopts = lopt\n  'tbput' pdset 'Order'\n  lopt = null\n  lopts = null\n  return\n\n  /* --------------- *\n  | Do_Edit Routine |\n  * --------------- */\nDo_Edit:\n  /* -------------------------------------------------------- *\n  | If editing a Dummy member then set absolute and relative |\n  | generations to 0 to allow editing.                       |\n  |                                                          |\n  | The Dummy is just a place holder retaining the high      |\n  | water mark of absolute generations.                      |\n  * -------------------------------------------------------- */\n  if Dummy = 'G' then do\n    msel = 'E'\n    agen = 0\n    mgen = 0\n  end\n  /* ------------------------------------------------- *\n  | Check to determine if we allow Edit or if a non-0 |\n  | generations for View                              |\n  * ------------------------------------------------- */\n  if agen = null then agen = 0\n  if agen = 0 then mgen = 0\n  if agen /= 0 then do\n    zerrsm  = 'Changed to View'\n    zerrlm  = 'Edit is ONLY allowed for generation 0' ,\n      'members. Your request has been changed' ,\n      'to View.'\n    'Setmsg msg(isrz003)'\n    if docmd /= null then\n    higen = (words(all_members.mbr) -2) *-1\n    pdsemopt = 'EMV'\n    'vput (mgen agen higen) shared'\n    'Control Display Save'\n    'view   dataid('pdsegend') member('mbr') gen('agen')' ,\n      'macro(pdsegenm) parm(pdsemopt)'\n    if rc > 4 then 'setmsg msg(isrz003)'\n    'Control Display Restore'\n    'tbtop' pdset\n    'tbscan' pdset 'arglist(mbr agen)'\n    lopt = '*View'\n    lopts = lopt\n    msel = null\n    'tbput' pdset 'Order'\n    lopt = null\n    lopts = null\n  end\n  else do\n    if zdsngen > 0 then do\n      higenr = (words(all_members.mbr) -2) *-1\n      if higenr > 0 then higenr = 0\n      higena = word(members.mbr,2)\n      higen = higenr\n      zerrsm = 'Gen' mgen\n      zerrlm = 'Editing generation 0 with a high' ,\n        'gen of' higenr'('higena')'\n      'setmsg msg(isrz003)'\n    end\n    if zdsngen = 0 then\n    parse value '0 0 0' with agen mgen higen\n    pdsemopt = 'EM'\n    'vput (mgen agen higen) shared'\n    'Control Display Save'\n    'edit   dataid('pdsegend') member('mbr') gen('agen')' ,\n      'macro(pdsegenm) parm(pdsemopt)'\n    xrc = rc\n    'Control Display Restore'\n    /* rc <= 4 is acceptable */\n    if xrc > 4 then 'Setmsg Msg(isrz003)'\n    /* rc = 0 then member updated */\n    xmbr = mbr\n    if xrc = 0 then do\n      mbr = xmbr\n      call update_mem\n      mbr = xmbr\n      call clean_up 'x'\n      mbr = xmbr\n      agen = 0\n      'tbtop' pdset\n      'tbscan' pdset 'arglist(mbr agen)'\n      'tbget' pdset\n      lopt  = '*Edit'\n      lopts = lopt\n      msel  = null\n      'tbput' pdset 'Order'\n      lopt = null\n      lopts = null\n      msel = null\n    end\n    /* rc > 0 then member not updated */\n    else do\n      'tbtop' pdset\n      'tbscan' pdset 'arglist(mbr agen)'\n      'tbget' pdset\n      lopt  = '*Edit'\n      lopts = lopt\n      msel  = null\n      'tbput' pdset 'order'\n      lopt  = null\n      lopts = null\n    end\n  end\n  proc_mems = null\n  return\n\n  /* --------------- *\n  | Do_Tryit Routine|\n  * --------------- */\nDo_Tryit:\n  higen = (words(all_members.mbr) -2) *-1\n  pdsemopt = 'EMV'\n  'vput (mgen agen higen) shared'\n  'control display save'\n  if agen = 0\n  then 'Edit   dataid('pdsegend') member('mbr') gen('agen')' ,\n    'macro(tryit)'\n  else 'View   dataid('pdsegend') member('mbr') gen('agen')' ,\n    'macro(tryit)'\n  'control display restore'\n  'tbtop' pdset\n  'tbscan' pdset 'arglist(mbr agen)'\n  lopt = '*Tryit'\n  lopts = lopt\n  msel = null\n  'tbput' pdset 'Order'\n  lopt = null\n  lopts = null\n  return\n\n  /* --------------- *\n  | Do_View Routine |\n  * --------------- */\nDo_View:\n  higen = (words(all_members.mbr) -2) *-1\n  pdsemopt = 'EMV'\n  'vput (mgen agen higen) shared'\n  'control display save'\n  'view   dataid('pdsegend') member('mbr') gen('agen')' ,\n    'macro(pdsegenm) parm(pdsemopt)'\n  if rc > 4 then 'setmsg msg(isrz003)'\n  'control display restore'\n  'tbtop' pdset\n  'tbscan' pdset 'arglist(mbr agen)'\n  lopt = '*View'\n  lopts = lopt\n  msel = null\n  'tbput' pdset 'Order'\n  lopt = null\n  lopts = null\n  return\n\n  /* -------------------------------------------------- *\n  | PFSHOW routine:                                    |\n  |                                                    |\n  | Option Off - check if it was On and then set to On |\n  | Option Reset - save current value and set off      |\n  * -------------------------------------------------- */\npfshow:\n  arg pfkopt\n  if pfkopt = 'RESET' then do\n    if pfkeys = 'ON' then\n    'select pgm(ispopf) parm(FKA,ON)'\n  end\n  if pfkopt = 'OFF' then do\n    'vget (zpfshow)'\n    pfkeys = zpfshow\n    if zpfshow = 'OFF' then return\n    'select pgm(ispopf) parm(FKA,OFF)'\n  end\n  return\n\n  /* --------------------------------------------------- *\n  | Delete member processing routine                    |\n  * --------------------------------------------------- */\nProc_Del: procedure expose zdsngen wdsn\n  arg member gen dd\n  if zdsngen = 0 then mgflag = 'D'\n  else mgflag = 'DG'\n  xrc = pdsegdel(member,gen,dd,mgflag)\n  return xrc\n\n  /* ----------------------------------------------------- *\n  | Del_Promote Routine:                                  |\n  |                                                       |\n  | This routine will:                                    |\n  |                                                       |\n  | 1. Promote the -1 generation to the base              |\n  | 2. Delete the -1 (formerly base) and -2 (formerly -1) |\n  |    generations                                        |\n  * ----------------------------------------------------- */\nDel_Promote:\n  mgen = '-1'\n  call create_temp\n  mgen = 0\n  pdsemopt = 'R'\n  pdsecpds = \"'\"wdsn\"(\"mbr\")'\"\n  'vput (pdsecpds)'\n  'edit dataset('tdsn') macro(pdsegenm) parm(pdsemopt)'\n  Address TSO 'Free f('zpdsendd') Delete'\n  'tbskip' pdset\n  if cdate /= null then do\n    parse var vrm iver'.'imod\n    'LMMStats Dataid('pdsegend')' ,\n      'Member('mbr') version('iver') modlevel('imod')' ,\n      'Created('cdate') Moddate('mdate')' ,\n      'Modtime('mtime') Cursize('mcur')' ,\n      'Initsize('minit') Modrecs('mmod')' ,\n      'User('muser')'\n  end\n  lopt = '*D'\n  lopts = lopt\n  msel = null\n  proc_mems = proc_mems mbr 'D'\n  lopt = null\n  lopts = null\n  Address TSO ,\n    'Alloc f('pdsedd') shr reuse ds('pdsedsn')'\n  delgen = find_highgen(pdsedsn,mbr)\n  x = proc_del(mbr delgen pdsedd)\n  delgen = word(members.mbr,2)\n  x = proc_del(mbr delgen pdsedd)\n  Address TSO ,\n    'Free f('pdsedd')'\n  return\n\n  /* ------------------------------------------------- *\n  * Update_stat routine                               *\n  *                                                   *\n  * Updates the ispf member statistics for our table. *\n  *                                                   *\n  * Note the changed number of records is NOT used    *\n  * since we don't get it from pdsegeni               *\n  * ------------------------------------------------- */\nUpdate_stat:\n  cdate   = zlcdate\n  mdate   = zlmdate\n  mtime   = zlmtime\n  if zlvers /= null then\n  vrm     = zlvers'.'zlmod\n  mcur    = zlcnorc\n  minit   = zlinorc\n  mmod    = zlmnorc\n  muser   = zluser\n  scdate  = cdate\n  smdate  = mdate\n  smtime  = mtime\n  smuser  = muser\n  return\n\n  /* ------------------------------------------ *\n  * Do_Locate routine                          *\n  * find the location of the requested member  *\n  * near find (condlist) is supported and will *\n  * reduce the row count by 1                  *\n  *                                            *\n  * Option of non-blank will generate a        *\n  * message on locate end (good/bad)           *\n  * ------------------------------------------ */\nDo_Locate:\n  arg loc_opt\n  scrp = crp\n  srowcrp = rowcrp\n  crp = 0\n  rowcrp = 0\n  'tbtop' pdset\n  if sortcol = null then sortcol = 'NAME'\n  if sort.sortcol = null then cond = 'LE'\n  if sort.sortcol = 'D' then cond = 'LE'\n  else cond = 'GE'\n  call do_sort\n  'tbvclear' pdset\n  mbr  = lstring\n  scanrows = 0\n  Select\n    When sortcol = 'NAME' then do\n      sortcoln = 'Name'\n      'tbscan' pdset 'arglist(mbr) position(scanrow) condlist('cond')'\n      if mbr /= lstring then scanrows = scanrow - 1\n    end\n    When sortcol = 'ID' then do\n      sortcoln = 'ID'\n      muser = lstring\n      'tbscan' pdset 'arglist(muser) position(scanrow) condlist('cond')'\n      if muser /= lstring then scanrows = scanrow - 1\n    end\n    When sortcol = 'CREATED' then do\n      sortcoln = 'Created'\n      cdate  = lstring\n      'tbscan' pdset 'arglist(cdate) position(scanrow) condlist('cond')'\n      if cdate /= lstring then scanrows = scanrow - 1\n    end\n    When sortcol = 'CHANGED' then do\n      sortcoln = 'Changed'\n      mdate  = lstring\n      'tbscan' pdset 'arglist(mdate) position(scanrow) condlist('cond')'\n      if mdate /= lstring then scanrows = scanrow - 1\n    end\n    When sortcol = 'MOD' then do\n      sortcoln = 'Mod'\n      mmod  = lstring\n      'tbscan' pdset 'arglist(mmod) position(scanrow) condlist('cond')'\n      if mmod /= lstring then scanrows = scanrow - 1\n    end\n    When sortcol = 'SIZE' then do\n      sortcoln = 'Size'\n      mcur  = lstring\n      'tbscan' pdset 'arglist(mcur) position(scanrow) condlist('cond')'\n      if mcur /= lstring then scanrows = scanrow - 1\n    end\n    When sortcol = 'INIT' then do\n      sortcoln = 'Init'\n      minit =  lstring\n      'tbscan' pdset 'arglist(minit) position(scanrow) condlist('cond')'\n      if minit /= lstring then scanrows = scanrow - 1\n    end\n    Otherwise do\n      zerrsm = 'Invalid'\n      zerrlm = 'Invalid sort column:' sortcol\n      'Setmsg msg(isrz003)'\n    end\n  end\n  lrc = rc\n  if scanrows > 0 then found = 'Near Find'\n  else found = 'Found'\n  if lrc = 0\n  then do\n    crp = scanrow\n    srowcrp = scanrow\n    if loc_opt /= null then do\n      zerrsm = found\n      zerrlm = 'Locate on column' sortcoln' for value:' lstring\n      'Setmsg msg(isrz003)'\n    end\n  end\n  else do\n    crp = scrp\n    rowcrp = srowcrp\n    if loc_opt /= null then do\n      zerrsm = 'Not Found'\n      zerrlm = 'Locate on column' sortcol' not found for:' lstring\n      'Setmsg msg(isrz003)'\n    end\n  end\n  return\n\n  /* ----------------------------- *\n  * Add a new member to the table *\n  * ----------------------------- */\nnew_mem:\n  \"LMClose dataid(\"pdsegend\")\"\n  \"LMOPEN DATAID(\"pdsegend\") OPTION(INPUT)\"\n  \"LmmList Dataid(\"pdsegend\") Option(List) Member(member)\",\n    'stats(yes)'\n  if zdsngen > 0 then do\n    agen    = 0\n    mgen    = 0\n  end\n  call update_stat\n  'tbadd' pdset 'Order'\n  call do_sort\n  return\n\n  /* ---------------------------------------------- *\n  * Process the results from the pdsegeni function *\n  * ---------------------------------------------- */\nProc_pdsegeni:\n  /* -------------------------------------- *\n  * Now process each member and generation *\n  * -------------------------------------- */\n  /*\n  Field    start length\n  Member   5     8\n  absgen   13    8\n  vrm      22    5\n  cdate    35    7   yyyyddd\n  ttr      46    3\n  mdate    49    7   yyyyddd\n  mtime    56    7   0hhmmss\n  userid   63    8\n  mmod     71    2   hex mod records\n  cur size 75    4  hex\n  init size 79   4  hex\n  dummy flag 87  1   D for dummy generation\n  */\n  mgen     = 0\n  pdsegmem = 0   /* count of generations */\n  smbr     = null  /* was mbr */\n  ombr     = null\n  grows    = 0\n  metrics  = null\n  drop members. all_members.\n  members.     = null\n  all_members. = null\n  numeric digits 10\n\n  /* ----------------------------------------------------- *\n  | Create the ISPF Table for the Members and Generations |\n  | If update_table not null then don't tbcreate          |\n  * ----------------------------------------------------- */\n  if update_table = null then do\n    if closed = 0 then\n    'tbclose' pdset\n    pdset = randstr()           /* random table name for recursion */\n    'tbcreate' pdset,\n      'names(msel mbr mgen agen lopt lopts cdate mdate mtime' ,\n      'vrm mcur minit muser mmod scdate smdate Dummy' ,\n      'mcscale miscale mcurx minitx mttr cdate4 mdate4) nowrite'\n    closed = 0\n  end\n\n  mult = 0\n  if filter /= null\n  then if date_filter /= null\n  then if member.0 < 15000\n  then mult = member.0\n  if mult = 0 then\n  Select\n    When member.0 = 0 then return\n    When member.0 > 5000 then mult = 5000\n    when member.0 > 1000 then mult = 1000\n    otherwise mult = 250\n  end\n\n  /* -------------------------------------------------- *\n  | Now process the member info returned from pdsegeni |\n  * -------------------------------------------------- */\n  do i = 1 to member.0\n    parse value member.i with 5 mbr 13 agen 21 . 22 vrm 27 . ,\n      35 cdate 42 . 46 mttr ,\n      49 mdate 56 mtime 63 muser 71 mmod 73 . 75 mcur 79 minit ,\n      83 . 87 dmy .\n\n    /* ---------------------------------------------- *\n    | Test for Dummy/invalid members and ignore      |\n    | unless the Dummy option (HIGEN) flag is set.   |\n    * ---------------------------------------------- */\n    mbr   = strip(mbr)\n    if left(mbr,1) = '00'x then iterate\n    mttr  = c2x(mttr)\n    Dummy = null\n    parse value '' with lopt lopts\n\n    muser = strip(muser)\n    agen  = strip(agen)\n\n    if zdsngen = 0\n    then parse value '0 0' with mgen agen\n    else do\n      /* ------------------------ *\n      | Test for a Dummy member: |\n      |                          |\n      | dmy = D then set counter |\n      | Iterate if not HIGen     |\n      | else set mgen to -       |\n      * ------------------------ */\n      if dmy = 'D' then do\n        Dummy = 'G'\n        grows = grows + 1\n        if higenf = 0 then iterate\n      end\n      if agen = 0 then mgen = 1\n      if higenf = 1 then\n      if mgen = '-' then mgen = 0\n      if Dummy /= 'G'\n      then mgen = mgen -1\n      else  mgen = 0\n    end\n\n    /* -------------------------------- *\n    | Increment the generation counter |\n    * -------------------------------- */\n    if agen > 0 then pdsegmem = pdsegmem + 1\n\n    /* ---------------------------------- *\n    | Keep track of members and gen info |\n    * ---------------------------------- */\n    if all_members.mbr = null\n    then do\n      all_members.mbr = mbr agen\n      all_members.0 = all_members.0 mbr\n    end\n    else all_members.mbr = all_members.mbr agen\n\n    if wordpos(mbr,all_members.0) = 0\n    then all_members.0 = all_members.0 mbr\n    if smbr /= null then if smbr /= mbr then iterate\n\n    /* ----------------------------- *\n    | Check and process any filters |\n    * ----------------------------- */\n    if filter /= null then do\n      ftest = proc_filter(mbr)\n      if ftest = 0 then iterate\n    end\n\n    /* --------------------------------- *\n    | Make counts and dates displayable |\n    * --------------------------------- */\n    if mcur = '    '\n    then mcur = 0\n    else mcur = x2d(c2x(mcur))\n    if minit = '    '\n    then minit = 0\n    else minit = x2d(c2x(minit))\n\n    parse value '' with mcscale miscale mcurx minitx\n\n    /* ---------------------------------------- *\n    | Fixup the counts for display             |\n    | if > 99,999 then use M (million) suffix  |\n    | if > 9,999 then use K (thousands) suffix |\n    | Note: STATS EXT is required for > 65k    |\n    * ---------------------------------------- */\n    Select\n      when mcur > 999999 then do\n        mcurx   = mcur\n        mcur    = mcur%1000000||'M'\n        mcscale = 'M'\n      end\n      when mcur > 99999 then do\n        mcurx   = mcur\n        mcur    = mcur%1000||'K'\n        mcscale = 'K'\n      end\n      Otherwise nop\n    end\n\n    Select\n      when minit > 999999 then do\n        minitx  = minit\n        minit   = minit%1000000||'M'\n        miscale = 'M'\n      end\n      when minit > 99999 then do\n        minitx  = minit\n        minit   = minit%1000||'K'\n        miscale = 'K'\n      end\n      Otherwise nop\n    end\n\n    mtime = Substr(mtime,2,2)||':'||Substr(mtime,4,2)\n    mmod  = x2d(c2x(mmod))\n    if mdate /= null then do\n      smdate = substr(mdate,1,7)\n      mdate  = substr(mdate,3,5)\n      mdate4 = date('s',mdate,'j')\n      mdate  = date('o',mdate,'j')\n      mdate4 = left(mdate4,4)'/'substr(mdate,4,2)'/'right(mdate,2)\n    end\n    if cdate /= null then do\n      scdate = substr(cdate,1,7)\n      cdate  = substr(cdate,3,5)\n      cdate4 = date('s',cdate,'j')\n      cdate  = date('o',cdate,'j')\n      cdate4 = left(cdate4,4)'/'substr(cdate,4,2)'/'right(cdate,2)\n    end\n\n    if zdsngen > 0 then do\n      /* -------------------------------------------------- *\n      * If the member name changes and the absolute gen is *\n      * not zero (it should be zero) then set Dummy flag   *\n      * -------------------------------------------------- */\n      if ombr /= mbr then do\n        ombr = mbr\n        mgen = 0\n      end\n      if Dummy = 'G' then cdate  = null\n    end\n\n    /* ------------------------------------------------- *\n    | If the creation date is null then nullify all the |\n    | row variables                                     |\n    * ------------------------------------------------- */\n    if strip(cdate) = null then do\n      parse value '' with cdate mdate mtime vrm ,\n        muser scdate smdate ,\n        mcur minit mmod state cdate4 mdate4\n      sgen = mgen\n    end\n    if dummy = 'G' then do\n      muser = 'HIGen'\n      mgen  = '-'\n    end\n\n    /* ------------------------------------------------- *\n    | Set the HIGEN into the Last Option (status) Field |\n    * ------------------------------------------------- */\n    if higenf = 1 then do\n      if agen > 0 then\n      if mgen = '-' then do\n        lopt = agen\n        lopts = lopt\n        agen = mgen\n      end\n    end\n\n    /* ----------------------- *\n    * Test for Date Filtering *\n    * ----------------------- */\n    if date_filter /= null then do\n      if mdate = null then iterate\n      test_date = date('b',mdate,'o')\n      if date_filter > test_date then iterate\n    end\n\n    /* ------------------------------------ *\n    | Test if generations should be hidden |\n    * ------------------------------------ */\n    if gen_hide = 1 then do\n      if agen = null then leave\n      if agen > 0 then iterate\n    end\n\n    /* -------------------------- *\n    | Check for userid filtering |\n    * -------------------------- */\n    if filter_id /= null then do\n      if pos(filter_id,muser) = 0 then iterate\n    end\n\n    /* ----------------------------------------------------- *\n    | Add the member/generation to the ISPF Table           |\n    | and update the members. stem with member and gen info |\n    * ----------------------------------------------------- */\n    members.mbr = members.mbr agen\n    /* --------------------------------------------------------- *\n    | Only add those members found in the update_table variable |\n    | if it isn't null                                          |\n    * --------------------------------------------------------- */\n    if update_table /= null\n    then if wordpos(mbr,update_table) = 0 then iterate\n\n    /* ------------------------------- *\n    | Now add the member to the table |\n    * ------------------------------- */\n    'tbadd' pdset 'mult('mult')'\n  end\n  'tbsort' pdset 'fields('sortf')'\n  return\n\n  /* ---------------------------------------- *\n  | Build metrics of the members/generations |\n  * ---------------------------------------- */\ndo_metric:\n  metric. = null\n  metrics = null\n  do dm = 1 to words(all_members.0)\n    dm_mbr = word(all_members.0,dm)\n    mg = words(all_members.dm_mbr) -2\n    if wordpos(mg,metrics) > 0 then do\n      metric.mg = metric.mg + 1\n    end\n    else do\n      metrics = metrics mg\n      metric.mg = 1\n    end\n  end\n\n  /* ------------------------- *\n  | Create Metrics ISPF Table |\n  * ------------------------- */\n  if metric_table /= null\n  then 'TBClose' tblmet\n  metric_table = 1\n  'tbcreate' tblmet 'names(row) nowrite'\n  call add_tblmet left('Volser:',20) left(strip(zdsvol),11) ,\n    left('Management Class:',20) strip(zdsmc)\n  call add_tblmet left('DSN Type:',20) left(strip(zdsdsnt),11) ,\n    left('Storage Class:',20) strip(zdssc)\n  call add_tblmet left('DSN Version:',20) left(strip(zdsdsnv),11),\n    left('Data Class:',20) strip(zdsdc)\n  if zdsdsnt = 'PDS' then\n  call add_tblmet left('Directory Alloc:',20) left(strip(zdsdira),11),\n    left('Directory Used:',20) strip(zdsdiru)\n  call add_tblmet left('RECFM:',20) left(strip(zdsrf),11) ,\n    left('Extents Allocated:',20) left(strip(zdsexta),11)\n  call add_tblmet left('LRECL:',20) left(strip(zdslrec),11) ,\n    left('Extents Used:',20) left(strip(zdsextu),11)\n  call add_tblmet left('BLKSIZE:',20) left(strip(zdsblk),11) ,\n    left('Base Members:',20) left(strip(zds#mem),11)\n  call add_tblmet left('Units:',20) left(strip(zdsspc),11) ,\n    left('Generation Members:',20) left(strip(pdsegmem),11)\n  call add_tblmet left('Primary:',20) left(strip(zds1ex),11) ,\n    left('MaxGen:',20) left(strip(zdsngen),11)\n  call add_tblmet left('Secondary:',20) left(strip(zds2ex),11) ,\n    left('System MaxGens:',20) left(strip(dfamgen),11)\n  call add_tblmet left('Allocated:',20) left(strip(zdstota),11) ,\n    left('Pages Used:',20) left(strip(zdspagu),11)\n  call add_tblmet left('Used:',20) left(strip(zdstotu),11) ,\n    left('Pages Utilized:',20) left(strip(zdsperu),11)\n  call add_tblmet ' '\n  call add_tblmet 'Member Distribution:'\n  call add_tblmet 'GenNo  Members' ,\n    ' GenNo  Members' ,\n    ' GenNo  Members' ,\n    ' GenNo  Members'\n  /* ---------------------------- *\n  | Sort the metrics for display |\n  * ---------------------------- */\n  do imx = 1 to words(metrics)-1\n    do im = 1 to words(metrics)\n      w1 = word(metrics,im)\n      w2 = word(metrics,im+1)\n      if w1 > w2 then do\n        if im > 1\n        then  lm = subword(metrics,1,im-1)\n        else lm = ''\n        rm = subword(metrics,im+2)\n        metrics = lm w2 w1 rm\n      end\n    end\n  end\n  /* -------------------------------- *\n  | Now add the metrics to the table |\n  * -------------------------------- */\n  do im = 1 to words(metrics)\n    row = null\n    metgen = word(metrics,im)\n    metmem = metric.metgen\n    if metgen > 0 then metgen = metgen * -1\n    row = right(metgen,5) right(metmem,8)\n    im = im + 1\n    metgen = word(metrics,im)\n    metmem = metric.metgen\n    if metgen > 0 then metgen = metgen * -1\n    row = row' ' right(metgen,5) right(metmem,8)\n    im = im + 1\n    metgen = word(metrics,im)\n    metmem = metric.metgen\n    if metgen > 0 then metgen = metgen * -1\n    row = row' ' right(metgen,5) right(metmem,8)\n    im = im + 1\n    metgen = word(metrics,im)\n    metmem = metric.metgen\n    if metgen > 0 then metgen = metgen * -1\n    row = row' ' right(metgen,5) right(metmem,8)\n    'tbadd' tblmet\n  end\n  'tbtop' tblmet\n  return\n\n  /* ---------------------------- *\n  | Add row to the metrics table |\n  * ---------------------------- */\nAdd_tblmet:\n  parse arg row\n  'tbadd' tblmet\n  return\n\n  /* -------------------------------------- *\n  * Update the member rows after edit save *\n  * -------------------------------------- */\nupdate_mem:\n  arg umopt\n  omem = mbr\n  'tbtop' pdset\n  do forever\n    'tbvclear' pdset\n    mbr = omem\n    'tbscan' pdset 'arglist(mbr)'\n    if rc > 0 then leave\n    'tbdelete' pdset\n  end\n  mbr = omem\n  if umopt = null then do\n    call refresh_pdsi\n    update_table = omem\n    call proc_pdsegeni 'x'\n  end\n  src = 0\n  return\n\n  /* ---------------- *\n  * Common Sort Call *\n  * ---------------- */\ndo_sort:\n  sorder = sort.sortcol\n  'tbtop' pdset\n  Select\n    When sortcol = 'NAME'     then\n    'tbsort' pdset 'fields(mbr,c,'sorder',mgen,n,d)'\n    When sortcol = 'CREATED'  then\n    'tbsort' pdset 'fields(scdate,c,'sorder',mbr,c,a,mgen,n,d)'\n    When sortcol = 'CHANGED'  then\n    'tbsort' pdset 'fields(smdate,c,'sorder',mtime,c,'sorder',',\n      'mbr,c,a,mgen,n,d)'\n    When sortcol = 'ID'       then\n    'tbsort' pdset 'fields(muser,c,'sorder',mbr,c,a,mgen,n,d)'\n    When sortcol = 'SIZE'     then\n    'tbsort' pdset 'fields(mcur,n,'sorder',' ,\n      'mbr,c,a,mgen,n,d)'\n    When sortcol = 'MOD'      then\n    'tbsort' pdset 'fields(mmod,n,'sorder',mbr,c,a,mgen,n,d)'\n    When sortcol = 'INIT'     then\n    'tbsort' pdset 'fields(minit,n,'sorder',' ,\n      'mbr,c,a,mgen,n,d)'\n    Otherwise nop\n  end\n  Select\n    When sortcol = 'NAME'     then clrmbr   = sort_color\n    When sortcol = 'CREATED'  then clrcdate = sort_color\n    When sortcol = 'CHANGED'  then clrchang = sort_color\n    When sortcol = 'ID'       then clrmuser = sort_color\n    When sortcol = 'SIZE'     then clrmcur  = sort_color\n    When sortcol = 'MOD'      then clrmmod  = sort_color\n    When sortcol = 'INIT'     then clrminit = sort_color\n    otherwise clrmbr = sort_color\n  end\n  return\n\n  /* --------------------------- *\n  | Refresh the member/gen list |\n  * --------------------------- */\nRefresh_pdsi:\n  Address TSO\n  \"Alloc f(\"pdsedd\") ds('\"wdsn\"') shr reuse\"\n  drop member.\n  Address ISPExec ,\n    \"dsinfo dataset('\"wdsn\"')\"\n  if zds#mem > 0\n  then x=pdsegeni(pdsedd)\n  else do\n    rc = 0\n    member.0 = 0\n  end\n  'Free f('pdsedd')'\n  Address ISPExec\n  return\n\n  /* -------------------------------------------------------- *\n  | Compare Prompt                                           |\n  |                                                          |\n  | Entered from the Command Compare or from the Compare (Z) |\n  | Line command if entered on generation 0 (base)           |\n  * -------------------------------------------------------- */\nCompare_Prompt:\n  parse value zcmd with c cmem cfrom cto\n  cpos = 'cmem'\n  if words(zcmd) < 4 then do\n    do forever\n      zcmd = null\n      call pfshow 'off'\n      'Addpop Row(3) Column(3)'\n      'Display Panel(pdsegcom) cursor('cpos')'\n      xrc = rc\n      'Rempop'\n      call pfshow 'reset'\n      if xrc > 4 then cmem = null\n      if cmem = null then leave\n      zerrsm = null\n      cprgens = words(members.cmem)\n      cprgens = '0 to -'words(members.cmem)-1\n      rc = test_gen(cmem cfrom)\n      if rc = 1 then do\n        cpos = 'cfrom'\n        zerrsm = 'Error'\n        zerrlm = 'From generation does not exist. Try using:' ,\n          cprgens\n        'setmsg msg(isrz003)'\n      end\n      rc = test_gen(cmem cto)\n      if rc = 1 then do\n        cpos = 'cto'\n        zerrsm = 'Error'\n        zerrlm = 'To generation does not exist. Try using:' ,\n          cprgens\n        'setmsg msg(isrz003)'\n      end\n      if zerrsm = null then do\n        if sysdsn(\"'\"wdsn\"(\"cmem\")'\") = \"OK\" then leave\n        else do\n          cpos = 'cmem'\n          zerrsm  = 'Error'\n          zerrlm  = \"'\"wdsn\"(\"cmem\")'\" ,\n            sysdsn(\"'\"wdsn\"(\"cmem\")'\")\n          'Setmsg msg(isrz003)'\n        end\n      end\n    end\n  end\n  if members.cmem = null then do\n    zerrsm = 'Invalid Member'\n    zerrlm = cmem 'is not a valid member name.'\n    'setmsg msg(isrz003)'\n    cmem = null\n  end\n  if datatype(cfrom) /= 'NUM' | datatype(cto) /= 'NUM'  then do\n    zerrsm = 'Invalid Gen'\n    zerrlm = 'Either the from or to generation is invalid.' ,\n      'They must be relative generation number which' ,\n      'are negative numbers.' ,\n      'From:' cfrom 'To:' cto\n    'setmsg msg(isrz003)'\n    cmem = null\n  end\n  if cfrom > 0 | cto > 0 then do\n    zerrsm = 'Invalid Gen'\n    zerrlm = 'Either the from or to generation is invalid.' ,\n      'They must be relative generation number which' ,\n      'are negative numbers.' ,\n      'From:' cfrom 'To:' cto\n    'setmsg msg(isrz003)'\n    cmem = null\n  end\n  if cmem /= null then do\n    cbad = 0\n    parse value '' with cbadfrom cbadto\n    rc = test_gen(cmem cfrom)\n    if rc = 1 then do\n      cbad = 1\n      cbadfrom = 'From:' cfrom\n    end\n    rc = test_gen(cmem cto)\n    if rc = 1 then do\n      cbad = cbad + 1\n      cbadto = 'To:' cto\n    end\n    if cbad > 1 then genmsg = 'Both generations'\n    else genmsg = 'A generation'\n    if cbad > 0 then do\n      zerrsm = 'Invalid Gen'\n      zerrlm = genmsg 'specified for' cmem ,\n        'is invalid:' cbadfrom cbadto\n      'setmsg msg(isrz003)'\n      cmem = null\n    end\n  end\n  if cmem /= null then do\n    scrp = crp\n    call do_sort\n    'tbtop' pdset\n    do forever\n      'tbskip' pdset\n      if cmem < mbr then leave\n      if cmem = mbr then if mgen = cfrom then cabso = mgen\n      if cabso /= null then leave\n    end\n    'tbtop' pdset\n    do forever\n      'tbskip' pdset\n      if cmem < mbr then leave\n      if cmem = mbr then if mgen = cto then cabsn = mgen\n      if cabsn /= null then leave\n    end\n    zerrsm  = null\n    if cabsn = null then do\n      crp = scrp\n      zerrsm  = 'Error'\n      zerrlm  = 'Generation' cto 'does not exist.'\n      'Setmsg msg(isrz003)'\n    end\n    if cabso = null then do\n      zerrsm  = 'Error'\n      zerrlm  = 'Generation' cfrom 'does not exist.'\n      'Setmsg msg(isrz003)'\n    end\n    if zerrsm  = null then call do_compare\n  end\n  return\n\n  /* ------------------------------------------------------------- *\n  * Do_Compare routine:                                           *\n  *                                                               *\n  * 1. Called by COMPARE command and                              *\n  * 2. Called by Z line command                                   *\n  * 3. calls PDSEGENM edit macro with option COM                  *\n  *                                                               *\n  * Compare will compare 2 members. If the from member is         *\n  * generation 0 then it will be opened in Edit and compared      *\n  * to to the to member.                                          *\n  *                                                               *\n  * If the to member is a generation then it will be copied       *\n  * into a temp dataset for compare purposes.                     *\n  *                                                               *\n  * If the from member is a non-0 generation then it will         *\n  * be copied into a temp member (defined in PDSEGENS using       *\n  * the tempmem variable) and opened in View.                     *\n  *                                                               *\n  * The user may use the ISPF Edit or Replace commands to         *\n  * save any changes made while in View. That member will not     *\n  * be reflected in the member list until a refresh is performed. *\n  * ------------------------------------------------------------- */\nDo_Compare:\n  if zdsngen < 1 then do\n    zerrsm = 'Error'\n    zerrlm = 'Compare is not supported in a dataset without' ,\n      'generations.'\n    'setmsg msg(isrz003)'\n    return\n  end\n  parse value '' with todsn deltemp worktemp\n  mbr = cmem\n  if cto /= 0 then do\n    mgen = cto\n    call create_temp\n    todsn = tdsn\n  end\n  else do\n    todsn = \"'\"wdsn\"(\"cmem\")'\"\n  end\n  mgen = cfrom\n  if cfrom /= 0 then do\n    call create_temp 'mem'\n    deltemp = 1\n  end\n  /* ---------------------- *\n  * Now Compare from to to *\n  * ---------------------- */\n  pdsemopt = 'COM'\n  'vput (todsn todd cmem cto cfrom deltemp)'\n  if cfrom = 0 then\n  'edit dataid('pdsegend') member('cmem') gen('cfrom')' ,\n    'macro(pdsegenm) parm(pdsemopt)'\n  else 'view dataset('tdsn') confirm(no) chgwarn(no) macro(pdsegenm)' ,\n    'parm(pdsemopt)'\n  if deltemp = 1 then do\n    Address TSO ,\n      'Alloc f('pdsedd') shr reuse ds('pdsedsn')'\n    x = proc_del(tempmem 0 pdsedd)\n  end\n  return\n\n  /* ------------------------------------- *\n  * Do_User routine:                      *\n  * 1. Called by U line command           *\n  *                                       *\n  * - display prompting panel             *\n  * - call create_temp to create temp d/s *\n  *   if not generation 0                 *\n  * - execute the user command            *\n  * ------------------------------------- */\nDo_user:\n  if mgen < 0 then call create_temp\n  else  zpdsendd = null\n  if zpdsendd = null\n  then zudsn = \"'\"wdsn\"(\"mbr\")'\"\n  else zudsn = tdsn\n\n  do forever\n    if msel /= 'U' then\n    if lopt /= '/' then do\n      bypass = 1\n      zucmd = msel '/'\n      xrc = 0\n    end\n    if bypass /= 1 then do\n      call pfshow 'off'\n      'Addpop Row(3) Column(3)'\n      'Display Panel(pdseguc)'\n      xrc = rc\n      'Rempop'\n      call pfshow 'reset'\n    end\n    if bypass = 1 then do\n      bypass = 0\n      xrc = 0\n    end\n    if xrc > 0 then do\n      zerrsm = 'Cancelled'\n      zerrlm = 'User command cancelled.'\n      'Setmsg msg(isrz003)'\n      if zpdsendd /= null then\n      Address TSO ,\n        'Free f('zpdsendd') Delete'\n      return\n    end\n    if pos('/',zucmd) > 0 then leave\n    zerrsm = 'Error'\n    zerrlm = 'You must specify the location for the' ,\n      'current dataset(member) using a /.'\n    'Setmsg msg(isrz003)'\n  end\n\n  /* -------------------------- *\n  * Now build the user command *\n  * -------------------------- */\n  p = pos('/',zucmd)\n  zusercmd = left(zucmd,p-1) zudsn substr(zucmd,p+1)\n  /* ------------------------ *\n  * Now execute the user     *\n  * command                  *\n  * ------------------------ */\n  call logit 'Executing User command:' zusercmd\n  'Control display save'\n  'select cmd('zusercmd')'\n  if rc = 20 then do\n    'setmsg msg(isrz003)'\n  end\n  if zpdsendd /= null\n  then Address TSO ,\n    'Free f('zpdsendd') Delete'\n  'Control display restore'\n  return\n\n  /* ------------------------------------- *\n  * Do_eXecute routine:                   *\n  * 1. Called by X line command           *\n  *                                       *\n  * - call create_temp to create temp d/s *\n  *   if not generation 0                 *\n  * - eXecute the temp dataset            *\n  * ------------------------------------- */\nDo_eXecute:\n  if mgen < 0 then call create_temp\n  else  zpdsendd = null\n  /* ------------------------ *\n  * Now eXecute the temp d/s *\n  * or the real d/s          *\n  * ------------------------ */\n  do forever\n    if zpdsendd = null\n    then sxdsn = \"'\"wdsn\"(\"mbr\")'\"\n    else sxdsn = tdsn\n    call pfshow 'off'\n    'Addpop Row(3) Column(3)'\n    'Display Panel(pdsegxc)'\n    xrc = rc\n    'Rempop'\n    call pfshow 'reset'\n    if xrc > 0 then do\n      zerrsm = 'Cancelled'\n      zerrlm = 'Exec command cancelled.'\n      'Setmsg msg(isrz003)'\n      if zpdsendd /= null then\n      Address TSO ,\n        'Free f('zpdsendd') Delete'\n      return\n    end\n    Address TSO\n    if zpdsendd /= null\n    then do\n      'Exec' tdsn \"'\"zxcmd\"'\"\n      'Free f('zpdsendd') Delete'\n    end\n    else \"Exec  '\"wdsn\"(\"mbr\")' '\"zxcmd\"'\"\n    Address ISPExec\n    return\n  end\n\n  /* ------------------------------------- *\n  * Do_Submit routine:                    *\n  *    Called by J line command           *\n  *    and by SUBmit command              *\n  *                                       *\n  * - call create_temp to create temp d/s *\n  *   if not generation 0                 *\n  * - submit the temp dataset             *\n  * ------------------------------------- */\nDo_Submit:\n  if mgen < 0 then call create_temp\n  else  zpdsendd = null\n\n  /* ---------------- *\n  | Check Submit DCB |\n  * ---------------- */\n  rc = test_submit()\n  if rc > 0 then return\n\n  /* ------------------------ *\n  * Now Submit the temp d/s  *\n  * or the real d/s          *\n  * ------------------------ */\n  Address TSO\n\n  /* ---------------------------------------------- *\n  * Get the current state of the TSO PROFILE MSGID *\n  * and if on turn off for the submit.             *\n  * ---------------------------------------------- */\n  call outtrap 'x.'\n  'profile'\n  call outtrap 'off'\n  if wordpos('NOMSGID',x.1) > 0 then msg = 'off'\n  if wordpos('MSGID',x.1) > 0 then msg = 'on'\n  if msg = 'on' then 'profile nomsgid'\n\n  /* ------------------ *\n  * Now submit the JCL *\n  * ------------------ */\n  call outtrap 'x.'\n  if zpdsendd /= null\n  then do\n    'Submit' tdsn\n    'Free f('zpdsendd') Delete'\n  end\n  else \"submit '\"wdsn\"(\"mbr\")'\"\n  call outtrap 'off'\n  if msg = 'on' then 'profile msgid'\n\n  Address ISPExec\n  zerrsm  = 'Submitted'\n  zerrlm  = x.1\n  'setmsg msg(isrz003)'\n  return\n\n  /* ------------------------------------- *\n  * Do_eMail routine:                     *\n  * 1. Called by M line command           *\n  *                                       *\n  * - call create_temp to create temp d/s *\n  *   if not generation 0                 *\n  * - call %xmitipfe to e-mail            *\n  * ------------------------------------- */\nDo_eMail:\n  if mgen < 0 then call create_temp\n  else  zpdsendd = null\n  /* ---------------------- *\n  * Now eMail the temp d/s *\n  * ---------------------- */\n  if zpdsendd /= null\n  then do\n    cmd = \"%xmitipfe\" ,\n      \"File(\"tdsn\")\" ,\n      \"Filename(\"mbr\".txt)\" ,\n      \"Format(Txt)\" ,\n      \"Subject(\"wdsn\"  Member \"mbr\" Generation\" mgen\")\"\n    \"Select cmd(\"cmd\")\"\n    mrc = rc\n    Address TSO 'Free f('zpdsendd') Delete'\n  end\n  else do\n    cmd = \"%xmitipfe\" ,\n      \"File('\"wdsn\"(\"mbr\")')\" ,\n      \"Filename(\"mbr\".txt)\" ,\n      \"Format(Txt)\" ,\n      \"Subject(\"wdsn\" Member \"mbr\" Generation\" mgen\")\"\n    \"Select cmd(\"cmd\")\"\n    mrc = rc\n  end\n  if mrc > 0 then do\n    zerrsm = 'Error'\n    zerrlm = 'E-Mail (M) is not supported on this system. Contact' ,\n      'your systems programmer.'\n    'Setmsg msg(isrz003)'\n  end\n  return\n\n  /* ---------------------------------------------- *\n  | Create a temporary dataset, or member, for use |\n  | with member generations.                       |\n  * ---------------------------------------------- */\nCreate_Temp:\n  arg temp_opt\n  if temp_opt = null then do\n    zpdsendd = randstr()\n    if sysvar('syspref') = null then hlq = sysvar('sysuid')\n    else hlq = sysvar('syspref')\n    tdsn = \"'\"hlq'.PDSEGEN.TEMP.'zpdsendd'.'mbr\"'\"\n    call logit 'Creating temp dataset:' tdsn\n    if left(zdsrf,1) = 'F' then zdsrf = 'F B'\n    else zdsrf = 'V B'\n    Address TSO ,\n      'Alloc f('zpdsendd') ds('tdsn') new spa(5,5) tr' ,\n      'Recfm('zdsrf') lrecl('zdslrec') blksize('zdsblk')' ,\n      def_unit\n  end\n  else do\n    tdsn = \"'\"wdsn\"(\"tempmem\")'\"\n  end\n  /* ---------------------------------- *\n  * Copy all records from 'old' member *\n  * using the Replace Edit command     *\n  * ---------------------------------- */\n  pdsemopt = 'R'\n  pdsecpds = tdsn\n  'vput (pdsecpds)'\n  'edit dataid('pdsegend') member('mbr') gen('mgen')' ,\n    'macro(pdsegenm) parm(pdsemopt)'\n  return\n\n  /* ------------------------------------------------------- *\n  * Setup Filter procedure                                  *\n  *                                                         *\n  *    if filter is x then test for member x                *\n  *       type is 3                                         *\n  *    if filter is x: then test for member starting with x *\n  *       type is 1                                         *\n  *    if filter is x* then test for member starting with x *\n  *       type is 1                                         *\n  *    if filter is *x then test for member ending with x   *\n  *       type is 5                                         *\n  *    if filter is x/ then test for member with x anywhere *\n  *       type is 2                                         *\n  *    if filter is /x then test for member with x anywhere *\n  *       type is 2                                         *\n  *    if filter has * or %                                 *\n  *       type is 4  (uses pdsegmat rexx function)          *\n  *    if filter has : within                               *\n  *       type is 6  from:to                                *\n  *    if filter is (xxx yyy)                               *\n  *       type is 7                                         *\n  *                                                         *\n  *    * and OFF turn off Filtering                         *\n  *                                                         *\n  * variables:                                              *\n  *    tfilter = the test filter member                     *\n  *    tfilterl = length of tfilter                         *\n  *    tfiltert = filter type                               *\n  *    tfilter_from = from member                           *\n  *    tfilter_from = from member                           *\n  *    tfilter_list = list of members                       *\n  * ------------------------------------------------------- */\nSetup_Filter:\n  filter = strip(filter)\n  if filter = '/' then filter = '*'\n  if words(filter) > 1 then\n  if left(filter,1) /= '(' then\n  if wordpos(word(filter,1),'SINCE TODAY WEEK MONTH YEAR') = 0 then do\n    dfilter = subword(filter,2)\n    filter = word(filter,1)\n  end\n  else dfilter = null\n  Select\n    When wordpos(word(filter,1),'SINCE TODAY WEEK MONTH YEAR') > 0 then do\n      zcmd = filter\n      call setup_date_filter\n      filter = null\n      zcmd   = null\n      call proc_refresh\n    end\n    When translate(filter) = 'OFF' then do\n      parse value '' with tfilter tfilterl tfiltert ,\n        date_filter date_filter_title ,\n        filter filter_title\n      call proc_refresh\n    end\n    When strip(filter) = '*' then do\n      filter = null\n      filter_title = null\n      parse value '' with tfilter tfilterl tfiltert\n      call proc_refresh\n    end\n    When left(filter,1) = '(' then do\n      parse value filter with '('tfilter_list')'\n      tfiltert = 7\n    end\n    When right(filter,1) = ':' then do\n      tfilterl = length(filter) -1\n      tfilter  = left(filter,tfilterl)\n      tfiltert = 1\n    end\n    When pos(\":\",filter) > 1 then do\n      tfilter  = filter\n      parse value filter with tfilter_from\":\"tfilter_to .\n      tfiltert = 6\n    end\n    When pos('%',filter) > 0 then do\n      if length(filter) > 1 then\n      tfiltert = 4\n    end\n    When pos('?',filter) > 0 then do\n      filter = translate(filter,'%','?')\n      if length(filter) > 1 then\n      tfiltert = 4\n    end\n    When pos('*',filter) > 0 then do\n      px = pos('*',filter)\n      py = pos('*',filter,px+1)\n      tfiltert = null\n      if px = length(filter) then do\n        tfiltert = 1\n        tfilterl = length(filter)-1\n        tfilter = left(filter,px-1)\n      end\n      if px = 1 then do\n        tfiltert = 5\n        tfilterl = length(filter)-1\n        tfilter = substr(filter,px+1)\n      end\n      if py > 0 then tfiltert = 4\n      if tfiltert = null then tfiltert = 4\n    end\n    When pos('/',filter) > 0 then do\n      if pos('/',filter) > 1 then do\n        tfilterl = length(filter) -1\n        tfilter  = left(filter,tfilterl)\n        tfiltert = 2\n      end\n      else do\n        tfilterl = length(filter) -1\n        tfilter  = substr(filter,2)\n        tfiltert = 2\n      end\n    end\n    Otherwise do\n      tfilterl = length(filter)\n      tfilter  = filter\n      tfiltert = 3\n    end\n  end\n  if filter /= null then do\n    filter_title = filter\n    if dfilter /= null then do\n      zcmd = dfilter\n      call setup_date_filter\n      zcmd = null\n    end\n    signal proc_refresh\n  end\n  return\n\n  /* --------------------------------- *\n  * Proc_Refresh routine              *\n  *                                   *\n  * Call the close routine and then   *\n  * start over from the beginning     *\n  * with a clean updated member list. *\n  * --------------------------------- */\nProc_Refresh:\n  if open_pdse = null then return\n  s_zerrsm = zerrsm\n  s_zerrlm = zerrlm\n  call logit 'Performing Refresh' wdsn\n  call close\n  parse value '' with zcmd lopt lopts\n  zerrsm = s_zerrsm\n  zerrlm = s_zerrlm\n  signal start\n\n  /* ------------------------- *\n  * Close and Free the Dataid *\n  * ------------------------- */\nClose:\n  if open_pdse = null then return\n  call logit 'Closing Dataset:' wdsn\n  \"LMClose Dataid(\"pdsegend\")\"\n  \"LMFree  Dataid(\"pdsegend\")\"\n  if closed = 0 then\n  'TBClose' pdset\n  closed = 1\n  if metric_table /= null then\n  'TBClose' tblmet\n  metric_table = null\n  zcmd = null\n  return\n\nLogit:\n  parse arg zerrlm\n  zerrsm = 'PDSEGEN'\n  Address ISPExec\n  'log msg(isrz003)'\n  parse value '' with zerrsm zerrlm\n  return\n\n  /* ------------------------------------------------------- *\n  * Filter testing using filter type                        *\n  *                                                         *\n  * return code 0 to bypass                                 *\n  *             1 to accept                                 *\n  * ------------------------------------------------------- */\nProc_Filter:\n  arg filter_member\n  rtn = 1\n  Select\n    /* filter = x */\n    When tfiltert = 3 then do\n      if tfilter /= filter_member then rtn = 0\n    end\n    /* filter = x: or x* */\n    When tfiltert = 1 then do\n      if left(filter_member,tfilterl) /= tfilter then rtn = 0\n    end\n    /* filter = x/ or /x */\n    When tfiltert = 2 then do\n      if pos(tfilter,filter_member) = 0 then rtn = 0\n    end\n    /* filter has * or % */\n    When tfiltert = 4 then do\n      rtn = pdsegmat(filter_member,filter)\n    end\n    /* filter = *x */\n    When tfiltert = 5 then do\n      if right(filter_member,tfilterl) /= tfilter then rtn = 0\n    end\n    /* filter = x:y */\n    When tfiltert = 6 then do\n      rtn = 0\n      if left(filter_member,length(tfilter_from)) >= ,\n        tfilter_from then\n      if left(filter_member,length(tfilter_to)) <= ,\n        tfilter_to then rtn = 1\n    end\n    When tfiltert = 7 then do\n      rtn = 0\n      do mc = 1 to words(tfilter_list)\n        mw = word(tfilter_list,mc)\n        select\n          when pos('/',mw) > 0 then do\n            mw = strip(translate(mw,' ','/'))\n            if pos(mw,filter_member) > 0 then rtn = 1\n          end\n          when filter_member = mw then rtn = 1\n          when pos('*',mw) > 0 then do\n            rc = pdsegmat(filter_member,mw)\n            if rc = 1 then rtn = 1\n          end\n          when pos('%',mw) > 0 then do\n            rc = pdsegmat(filter_member,mw)\n            if rc = 1 then rtn = 1\n          end\n          otherwise nop\n        end\n      end\n    end\n    Otherwise nop\n  end\n  return rtn\n\n  /* --------------------------------------------------- *\n  * do_klone routine:                                   *\n  *                                                     *\n  * Copy the requested base member to a new name        *\n  * --------------------------------------------------- */\nDo_klone:\n  \"LMInit Dataid(rename) dataset(\"pdsedsn\")\"\n  \"LMInit Dataid(toname) dataset(\"pdsedsn\")\"\n  Address TSO ,\n    'Alloc f('pdsedd') shr reuse ds('pdsedsn')'\n  \"lmcopy fromid(\"rename\") todataid(\"toname\")\" ,\n    \"frommem(\"mbr\") tomem(\"znewmem\")\"\n  Address TSO ,\n    'Free f('pdsedd')'\n  \"LMFree Dataid(\"rename\")\"\n  \"LMFree Dataid(\"toname\")\"\n  return\n\n  /* --------------------------------------------------- *\n  * Do_Rename routine:                                  *\n  *                                                     *\n  * Copy each member using oldest generation to newest  *\n  * to the new name to preserve the relative generation *\n  * order and then delete the 'from' member.            *\n  * --------------------------------------------------- */\nDo_Rename:\n  \"LMInit Dataid(rename) dataset(\"pdsedsn\")\"\n  \"LMInit Dataid(toname) dataset(\"pdsedsn\")\"\n  Address TSO ,\n    'Alloc f('pdsedd') shr reuse ds('pdsedsn')'\n  if strip(rgens) = null then rgens = 0\n  do ix = words(rgens) to 1 by -1\n    igen = word(rgens,ix)\n    parse value rmem.igen with x y'\\'iver'\\'imod'\\'cdate,\n      '\\'mdate'\\' mtime'\\'mcur'\\'minit,\n      '\\'mmod'\\'muser\n    if igen = 0 then do\n      \"lmcopy fromid(\"rename\") todataid(\"toname\")\" ,\n        \"frommem(\"rmbr\") tomem(\"znewmem\") replace\"\n      x = proc_del(rmbr igen pdsedd)\n    end\n    else do\n      /* ---------------------------------- *\n      * Copy all records from 'old' member *\n      * using the Replace Edit command     *\n      * ---------------------------------- */\n      pdsemopt = 'R'\n      pdsecpds = \"'\"wdsn\"(\"znewmem\")'\"\n      'vput (pdsecpds)'\n      'edit dataid('rename') member('rmbr') gen('igen')' ,\n        'macro(pdsegenm) parm(pdsemopt)'\n      /* -------------------------------- *\n      * Now delete the member/generation *\n      * -------------------------------- */\n      x = proc_del(rmbr igen pdsedd)\n      /* ------------------------------------------------ *\n      * Update the target member with the old ISPF stats *\n      * ------------------------------------------------ */\n      'LMMStats Dataid('rename')' ,\n        'Member('znewmem') version('iver') modlevel('imod')' ,\n        'Created('cdate') Moddate('mdate')' ,\n        'Modtime('mtime') Cursize('mcur')' ,\n        'Initsize('minit') Modrecs('mmod')' ,\n        'User('muser')'\n    end\n  end\n  Address TSO ,\n    'Free f('pdsedd')'\n  \"LMFree Dataid(\"rename\")\"\n  \"LMFree Dataid(\"toname\")\"\n  return\n\nDo_Rename_Swap:\n  /* ------------------------------- *\n  | Rename Swap                     |\n  |                                 |\n  | 1. Prompt for both member names |\n  | 2. Rename 1st to temp           |\n  | 3. Rename 2nd to 1st            |\n  | 4. Rename temp to 2nd           |\n  * ------------------------------- */\n  if gen_hide = 1 then do\n    zerrsm = 'Warning'\n    zerrlm = 'Rename Swap is not supported when generations are' ,\n      'hidden. Use the REFRESH command to restore the' ,\n      'generations to the member list and then you can' ,\n      'use rename.'\n    'Setmsg msg(isrz003)'\n  end\n  zerrsm  = null\n  znewmem = null\n  if agen > 0 then do\n    zerrsm  = 'Error'\n    zerrlm  = 'Rename-Swap can only be done on a generation 0' ,\n      'member.'\n    'Setmsg Msg(isrz003)'\n    znewmem = null\n  end\n  if lopt /= null then\n  if left(lopt,1) /= '*' then do\n    znewmem = translate(lopt)\n    bypass = 1\n  end\n  if zerrsm = null then do forever\n    zerrsm  = null\n    if bypass /= 1 then do\n      call pfshow 'off'\n      'Addpop Row(3) Column(3)'\n      'Display Panel(pdsegrns)'\n      xrc = rc\n      'Rempop'\n      call pfshow 'reset'\n    end\n    else do\n      xrc = 0\n      bypass = 0\n    end\n    if xrc > 0 then do\n      znewmem = null\n      leave\n    end\n    if xrc = 0 then do\n      if znewmem = null then leave\n      if sysdsn(\"'\"wdsn\"(\"znewmem\")'\") = 'OK' then leave\n      zerrsm  = 'Error'\n      zerrlm  = \"'\"wdsn\"(\"znewmem\")' does NOT exist\" ,\n        \"and the swap cannot be done.\"\n      'Setmsg Msg(isrz003)'\n    end\n  end\n  if znewmem = null then\n  if zerrsm  = null then do\n    zerrsm  = 'Cancelled'\n    zerrlm  = 'Rename-Swap (Q) cancelled'\n    'Setmsg Msg(isrz003)'\n  end\n  if znewmem = mbr then\n  if zerrsm  = null then do\n    zerrsm  = 'Cancelled'\n    zerrlm  = 'Rename-Swap (Q) cancelled' ,\n      'as the from and to member names are the same.'\n    'Setmsg Msg(isrz003)'\n  end\n  if zerrsm  = null then do\n    save_top = ztdtop\n    from_mbr = mbr\n    to_mbr   = znewmem\n    temp_mbr = tempmem\n    call logit 'Rename Swap' from_mbr 'and' to_mbr\n    /* make sure the tempmem doesn't exist */\n    Address TSO\n    'Alloc f('pdsedd') shr reuse ds('pdsedsn')'\n    x = proc_del(tempmem 0 pdsedd)\n    'Free f('pdsedd')'\n    Address ISPExec\n    /* rename from_mbr to temp_mbr */\n    rmbr = from_mbr\n    znewmem = temp_mbr\n    rgens = members.rmbr\n    call logit 'Rename Swap' from_mbr 'to' znewmem\n    call do_rename\n    /* rename to_mbr to from_mbr */\n    rmbr = to_mbr\n    znewmem = from_mbr\n    rgens = members.rmbr\n    call logit 'Rename Swap' to_mbr 'to' znewmem\n    call do_rename\n    /* rename temp_mbr to to_mbr */\n    mbr = temp_mbr\n    call update_mem\n    mbr = temp_mbr\n    call clean_up 'x'\n    rmbr = temp_mbr\n    znewmem = to_mbr\n    rgens = members.rmbr\n    call logit 'Rename Swap' mbr 'to' znewmem\n    call do_rename\n    /* clean up the member info */\n    mbr = from_mbr\n    call update_mem\n    mbr = from_mbr\n    call clean_up 'x'\n    mbr = to_mbr\n    call update_mem\n    mbr = temp_mbr\n    call clean_up 'x'\n    mbr = temp_mbr\n    call update_mem\n    /* now update the table info */\n    'tbtop' pdset\n    mbr = from_mbr\n    agen = 0\n    'tbscan' pdset 'arglist(mbr agen)'\n    'tbget' pdset\n    lopt = '*RENSWAP'\n    lopts = '*Q'\n    'tbput' pdset\n    'tbtop' pdset\n    mbr = to_mbr\n    agen = 0\n    'tbscan' pdset 'arglist(mbr agen)'\n    'tbget' pdset\n    lopt = '*RENSWAP'\n    lopts = '*Q'\n    'tbput' pdset\n    'tbtop' pdset\n    'tbskip' pdset 'skip('save_top')'\n  end\n  return\n\n  /* ------------------------------------ *\n  * Setup for Progress Indicator Display *\n  * ------------------------------------ */\nset_prog:\n  'tbstats' pdset 'rowcurr(tabr)'\n  division = 10\n  incr = (tabr % division) + 1\n  progc = '**'\n  perc# = 0\n  return\n\n  /* -------------------------------------------------- *\n  * Reset Color routine                                *\n  *                                                    *\n  * Sets the color for the columns back to the default *\n  * -------------------------------------------------- */\nReset_Color:\n  clrn      = base_color\n  clrmbr    = base_color\n  clrcdate  = base_color\n  clrchang  = base_color\n  clrmcur   = base_color\n  clrminit  = base_color\n  clrmmod   = base_color\n  clrmuser  = base_color\n  return\n\n  /* ---------------- *\n  * Display progress *\n  * ---------------- */\nDisp_Progress:\n  if qfind//incr = 0 then do\n    progc = progc'**'\n    perc# = perc# + division\n    perc = perc#\"%\"\n    prog = progc '('perc')'\n    \"Control Display Lock\"\n    call pfshow 'off'\n    'Addpop Row(3) Column(3)'\n    'display panel(pdsegfp)'\n    'Rempop'\n    call pfshow 'reset'\n  end\n  return\n\n  /* ------------------------------------------ *\n  * Delete the base member and all generations *\n  * from the table display                     *\n  * ------------------------------------------ */\ndelete_mem:\n  omem = mbr\n  'tbtop' pdset\n  do forever\n    'tbvclear' pdset\n    mbr = omem\n    'tbscan' pdset 'arglist(mbr)'\n    if rc > 0 then leave\n    'tbdelete' pdset\n  end\n  mbr = omem\n  return\n\n  /* ------------------------------------------ *\n  * Delete All members and generations in the  *\n  * member display list                        *\n  * ------------------------------------------ */\nPrune_all:\n  prune = null\n  'tbtop' pdset\n  Address TSO ,\n    'Alloc f('pdsedd') shr reuse ds('pdsedsn')'\n  do forever\n    'tbskip' pdset\n    if rc > 0 then leave\n    if agen = 0 then do\n      x = proc_del(mbr agen pdsedd)\n      'tbdelete' pdset\n    end\n  end\n  Address TSO ,\n    'Free f('pdsedd')'\n  if filter /= null then do\n    pfilterm = ' and filter has been turned off.',\n      'The filter was:' filter\n    filter = null\n    filter_title = null\n  end\n  else pfilterm = '.'\n  zerrsm = 'Pruned'\n  if pfilterm = null then\n  zerrlm = 'All members and generations in the display' ,\n    'list have been deleted'pfilterm\n  else\n  zerrlm = 'The filtered members and generations have' ,\n    'been deleted'pfilterm\n  'setmsg msg(isrz003)'\n  call proc_refresh\n  return\n\n  /* ---------------------------------------------------- *\n  * Do_Prune Routine                                     *\n  *                                                      *\n  * Prune older generations to clean up the PDSE Library *\n  * If the prune varaiable is RESET then remove all      *\n  * members and generations.                             *\n  * ---------------------------------------------------- */\nDo_Prune:\n  tpruned   = 0\n  pmbr      = null\n  Address TSO ,\n    'Alloc f('pdsedd') shr reuse ds('pdsedsn')'\n  do forever\n    'tbskip' pdset\n    if rc > 0 then do\n      zerrsm = 'Pruned'\n      zerrlm = tpruned 'generations pruned.'\n      'Setmsg msg(isrz003)'\n      'tbtop' pdset\n      leave\n    end\n    else do\n      if mgen < (prune * -1) then do\n        x = proc_del(mbr agen pdsedd)\n        'TBDelete' pdset\n        tpruned = tpruned + 1\n      end\n    end\n  end\n  prune = null\n  Address TSO ,\n    'Free f('pdsedd')'\n  return\n\n  /* ---------------------------------------------------------- *\n  * Do_Find routine                                            *\n  *                                                            *\n  * - test for members $alloc, $backup and $index to determine *\n  *   if this is a backup dataset                              *\n  * - if not do normal find                                    *\n  * - if backup use superc find pdsegfnd                       *\n  * ---------------------------------------------------------- */\nDo_Find:\n  zcmd = null\n  fhit = 0\n  do forever\n    if zdsngen = 0 then fhit = 1\n    if sysdsn(\"'\"wdsn\"($alloc)'\")  = 'OK' then fhit = 1\n    if sysdsn(\"'\"wdsn\"($backup)'\") = 'OK' then fhit = 1\n    if sysdsn(\"'\"wdsn\"($index)'\")  = 'OK' then fhit = 1\n    if fhit = 0 then leave\n    /* build selection list */\n    ftmems = null\n    'tbtop' pdset\n    if ft /= null then do\n      'tbskip' pdset\n      if rc > 0 then leave\n      ftmems = ftmems mbr\n    end\n    'vput (ftmems)'\n    address tso \"%pdsegfnd '\"wdsn\"'\" pdsegfnd '/\\/\\'\n    'vget (mhits)'\n    if strip(mhits) /= null then do\n      'tbtop' pdset\n      do forever\n        'tbskip' pdset\n        if rc > 0 then leave\n        if wordpos(mbr,mhits) = 0 then 'tbdelete' pdset\n      end\n    end\n    'tbtop' pdset\n    zerrsm  = words(mhits) 'hits'\n    zerrlm  = 'String:' pdsegfnd 'found in' words(mhits) 'members.'\n    'Setmsg msg(isrz003)'\n    return\n  end\n  'tbtop' pdset\n  mfind = 0\n  qfind = 0\n  pdsemopt = 'F'\n  'vput (pdsegfnd)'\n  call set_prog\n  do forever\n    'tbskip' pdset\n    if rc > 0 then leave\n    qfind = qfind + 1\n    call  Disp_Progress\n    /* find string in member name ? */\n    if pos(pdsegfnd,mbr) > 0 then do\n      pdsegrc = 0\n    end\n    else do\n      /* find string within member/generation */\n      'edit dataid('pdsegend') member('mbr') gen('agen')' ,\n        'macro(pdsegenm) parm(pdsemopt)'\n      'vget pdsegrc'\n    end\n    if pdsegrc > 0 then 'tbdelete' pdset\n    else mfind = mfind + 1\n  end\n  'tbtop' pdset\n  zerrsm  = mfind 'hits'\n  zerrlm  = 'String:' pdsegfnd 'found in' mfind 'members.'\n  'Setmsg msg(isrz003)'\n  if mfind = 0 then\n  call proc_refresh\n  return\n\n  /* --------------------------------------------------------- *\n  * Update_DSList routine                                     *\n  *                                                           *\n  * Updates the recently used dsname variables in a push-down *\n  * stack process.                                            *\n  *                                                           *\n  * variables pdseds01 thru pdseds25                          *\n  * --------------------------------------------------------- */\nUpdate_DSList:\n  'vget (pdseds01 pdseds02 pdseds03 pdseds04' ,\n    'pdseds05 pdseds06 pdseds07 pdseds08' ,\n    'pdseds09 pdseds10 pdseds11 pdseds12' ,\n    'pdseds13 pdseds14 pdseds15 pdseds16 ' ,\n    'pdseds17 pdseds18 pdseds19 pdseds20 ' ,\n    'pdseds21 pdseds22 pdseds23 pdseds24 ' ,\n    'pdseds25)' ,\n    'profile'\n\n  /* ------------------------------------- *\n  * Add dsnames to a variable for testing *\n  * ------------------------------------- */\n  dsnslist = null\n  dsnslist = pdseds01 pdseds02 pdseds03 pdseds04 ,\n    pdseds05 pdseds06 pdseds07 pdseds08 ,\n    pdseds09 pdseds10 pdseds11 pdseds12 ,\n    pdseds13 pdseds14 pdseds15 pdseds16 ,\n    pdseds17 pdseds18 pdseds19 pdseds20 ,\n    pdseds21 pdseds22 pdseds23 pdseds24 ,\n    pdseds25\n\n  /* ---------------------------- *\n  * Remove the requested dataset *\n  * ---------------------------- */\n  if left(zcmd,1) = 'R' then do\n    rnum = substr(zcmd,2)\n    if datatype(rnum) /= 'NUM' then return\n    dsl_dsn = subword(dsnslist,rnum,1)\n    dsnslist = delword(dsnslist,rnum,1)\n    pdseds25 = word(dsnslist,25)\n    pdseds24 = word(dsnslist,24)\n    pdseds23 = word(dsnslist,23)\n    pdseds22 = word(dsnslist,22)\n    pdseds21 = word(dsnslist,21)\n    pdseds20 = word(dsnslist,20)\n    pdseds19 = word(dsnslist,19)\n    pdseds18 = word(dsnslist,18)\n    pdseds17 = word(dsnslist,17)\n    pdseds16 = word(dsnslist,16)\n    pdseds15 = word(dsnslist,15)\n    pdseds14 = word(dsnslist,14)\n    pdseds13 = word(dsnslist,13)\n    pdseds12 = word(dsnslist,12)\n    pdseds11 = word(dsnslist,11)\n    pdseds10 = word(dsnslist,10)\n    pdseds09 = word(dsnslist,09)\n    pdseds08 = word(dsnslist,08)\n    pdseds07 = word(dsnslist,07)\n    pdseds06 = word(dsnslist,06)\n    pdseds05 = word(dsnslist,05)\n    pdseds04 = word(dsnslist,04)\n    pdseds03 = word(dsnslist,03)\n    pdseds02 = word(dsnslist,02)\n    pdseds01 = word(dsnslist,01)\n    zcmd     = null\n    zerrsm = 'Removed'\n    zerrlm = 'Dataset' dsl_dsn 'removed from the table.'\n    'Setmsg msg(isrz003)'\n    call save_dslist\n  end\n\n  /* ------------------------------------- *\n  * Move the requested dataset to the top *\n  * ------------------------------------- */\n  if left(zcmd,1) = 'M' then do\n    rnum = substr(zcmd,2)\n    if datatype(rnum) /= 'NUM' then return\n    movedsn  = word(dsnslist,rnum)\n    dsnslist = delword(dsnslist,rnum,1)\n    dsnslist = movedsn dsnslist\n    pdseds25 = word(dsnslist,25)\n    pdseds24 = word(dsnslist,24)\n    pdseds23 = word(dsnslist,23)\n    pdseds22 = word(dsnslist,22)\n    pdseds21 = word(dsnslist,21)\n    pdseds20 = word(dsnslist,20)\n    pdseds19 = word(dsnslist,19)\n    pdseds18 = word(dsnslist,18)\n    pdseds17 = word(dsnslist,17)\n    pdseds16 = word(dsnslist,16)\n    pdseds15 = word(dsnslist,15)\n    pdseds14 = word(dsnslist,14)\n    pdseds13 = word(dsnslist,13)\n    pdseds12 = word(dsnslist,12)\n    pdseds11 = word(dsnslist,11)\n    pdseds10 = word(dsnslist,10)\n    pdseds09 = word(dsnslist,09)\n    pdseds08 = word(dsnslist,08)\n    pdseds07 = word(dsnslist,07)\n    pdseds06 = word(dsnslist,06)\n    pdseds05 = word(dsnslist,05)\n    pdseds04 = word(dsnslist,04)\n    pdseds03 = word(dsnslist,03)\n    pdseds02 = word(dsnslist,02)\n    pdseds01 = word(dsnslist,01)\n    zcmd     = null\n    zerrsm = 'Moved'\n    zerrlm = 'Dataset' movedsn 'moved to the top of the table.'\n    'Setmsg msg(isrz003)'\n    call save_dslist\n  end\n\n  /* ------------------------------------- *\n  * Sort the datasets in the change list  *\n  * ------------------------------------- */\n  if word(zcmd,1) = 'SORT' then do\n    sort_order = word(zcmd,2)\n    if sort_order = null then sort_order = 'A'\n    if sort_order /= 'A' then sort_order = 'D'\n    zcmd     = null\n    dstem.25 = word(dsnslist,25)\n    dstem.24 = word(dsnslist,24)\n    dstem.23 = word(dsnslist,23)\n    dstem.22 = word(dsnslist,22)\n    dstem.21 = word(dsnslist,21)\n    dstem.20 = word(dsnslist,20)\n    dstem.19 = word(dsnslist,19)\n    dstem.18 = word(dsnslist,18)\n    dstem.17 = word(dsnslist,17)\n    dstem.16 = word(dsnslist,16)\n    dstem.15 = word(dsnslist,15)\n    dstem.14 = word(dsnslist,14)\n    dstem.13 = word(dsnslist,13)\n    dstem.12 = word(dsnslist,12)\n    dstem.11 = word(dsnslist,11)\n    dstem.10 = word(dsnslist,10)\n    dstem.9 = word(dsnslist,09)\n    dstem.8 = word(dsnslist,08)\n    dstem.7 = word(dsnslist,07)\n    dstem.6 = word(dsnslist,06)\n    dstem.5 = word(dsnslist,05)\n    dstem.4 = word(dsnslist,04)\n    dstem.3 = word(dsnslist,03)\n    dstem.2 = word(dsnslist,02)\n    dstem.1 = word(dsnslist,01)\n    dstem.0 = 25\n    /* --------------------------------------- *\n    * rexx command to sort a stem variable    *\n    * Simple bubble sort of \"stem' by dstem.1 *\n    * Ken Singer, Shell Oil, Houston          *\n    * --------------------------------------- */\n    ctr =  dstem.0\n    /* SORT Ascending */\n    if sort_order = 'A' then\n    do y = 1 to  ctr - 1\n      do x = y+1 to ctr\n        if dstem.x < dstem.y then do\n          /* swap these 2 entries */\n          t1 = dstem.y ;\n          dstem.y = dstem.x\n          dstem.x = t1\n        end\n      end x\n    end y\n    else\n    do y = 1 to  ctr - 1\n      do x = y+1 to ctr\n        if dstem.x > dstem.y then do\n          /* swap these 2 entries */\n          t1 = dstem.y ;\n          dstem.y = dstem.x\n          dstem.x = t1\n        end\n      end x\n    end y\n    dsnslist = dstem.1 dstem.2 dstem.3 dstem.4 dstem.5 ,\n      dstem.6 dstem.7 dstem.8 dstem.9 dstem.10 ,\n      dstem.11 dstem.12 dstem.13 dstem.14 dstem.15 ,\n      dstem.16 dstem.17 dstem.18 dstem.19 dstem.20 ,\n      dstem.21 dstem.22 dstem.23 dstem.24 dstem.25\n    pdseds25 = word(dsnslist,25)\n    pdseds24 = word(dsnslist,24)\n    pdseds23 = word(dsnslist,23)\n    pdseds22 = word(dsnslist,22)\n    pdseds21 = word(dsnslist,21)\n    pdseds20 = word(dsnslist,20)\n    pdseds19 = word(dsnslist,19)\n    pdseds18 = word(dsnslist,18)\n    pdseds17 = word(dsnslist,17)\n    pdseds16 = word(dsnslist,16)\n    pdseds15 = word(dsnslist,15)\n    pdseds14 = word(dsnslist,14)\n    pdseds13 = word(dsnslist,13)\n    pdseds12 = word(dsnslist,12)\n    pdseds11 = word(dsnslist,11)\n    pdseds10 = word(dsnslist,10)\n    pdseds09 = word(dsnslist,09)\n    pdseds08 = word(dsnslist,08)\n    pdseds07 = word(dsnslist,07)\n    pdseds06 = word(dsnslist,06)\n    pdseds05 = word(dsnslist,05)\n    pdseds04 = word(dsnslist,04)\n    pdseds03 = word(dsnslist,03)\n    pdseds02 = word(dsnslist,02)\n    pdseds01 = word(dsnslist,01)\n    call save_dslist\n    return\n  end\n\n  /* ------------------------------------- *\n  * Clear the table                       *\n  * ------------------------------------- */\n  if zcmd = 'CLEAR' then do\n    zcmd     = null\n    parse value '' with dsnslist fqdsn ,\n      pdseds01 pdseds02 pdseds03 pdseds04 ,\n      pdseds05 pdseds06 pdseds07 pdseds08 ,\n      pdseds09 pdseds10 pdseds11 pdseds12 ,\n      pdseds13 pdseds14 pdseds15 pdseds16 ,\n      pdseds17 pdseds18 pdseds19 pdseds20 ,\n      pdseds21 pdseds22 pdseds23 pdseds24 ,\n      pdseds25\n    call save_dslist\n    return\n  end\n\n  /* -------------------------------- *\n  * Fully qualify the current dsname *\n  * -------------------------------- */\n  if strip(pdsedsn) = null then return\n  if pdsedsn = '*' > 0 then return\n  if left(pdsedsn,1) /= \"'\" then do\n    if sysvar('syspref') = null\n    then fqdsn = \"'\"pdsedsn\"'\"\n    else fqdsn = \"'\"sysvar(\"syspref\")\".\"pdsedsn\"'\"\n  end\n  else fqdsn = pdsedsn\n\n  /* ------------------------------------------ *\n  * Now test to see if the current pdse dsname *\n  * is in the list - if so exit                *\n  * ------------------------------------------ */\n  if wordpos(fqdsn,dsnslist) > 0 then return\n\n  /* ----------------------------- *\n  * Now update the ispf variables *\n  * ----------------------------- */\n  pdseds25 = word(dsnslist,24)\n  pdseds24 = word(dsnslist,23)\n  pdseds23 = word(dsnslist,22)\n  pdseds22 = word(dsnslist,21)\n  pdseds21 = word(dsnslist,20)\n  pdseds20 = word(dsnslist,19)\n  pdseds19 = word(dsnslist,18)\n  pdseds18 = word(dsnslist,17)\n  pdseds17 = word(dsnslist,16)\n  pdseds16 = word(dsnslist,15)\n  pdseds15 = word(dsnslist,14)\n  pdseds14 = word(dsnslist,13)\n  pdseds13 = word(dsnslist,12)\n  pdseds12 = word(dsnslist,11)\n  pdseds11 = word(dsnslist,10)\n  pdseds10 = word(dsnslist,09)\n  pdseds09 = word(dsnslist,08)\n  pdseds08 = word(dsnslist,07)\n  pdseds07 = word(dsnslist,06)\n  pdseds06 = word(dsnslist,05)\n  pdseds05 = word(dsnslist,04)\n  pdseds04 = word(dsnslist,03)\n  pdseds03 = word(dsnslist,02)\n  pdseds02 = word(dsnslist,01)\n  pdseds01 = fqdsn\n  call save_dslist\n  return\n\nSave_dslist:\n  'vput (pdseds01 pdseds02 pdseds03 pdseds04' ,\n    'pdseds05 pdseds06 pdseds07 pdseds08' ,\n    'pdseds09 pdseds10 pdseds11 pdseds12' ,\n    'pdseds13 pdseds14 pdseds15 pdseds16' ,\n    'pdseds17 pdseds18 pdseds19 pdseds20' ,\n    'pdseds21 pdseds22 pdseds23 pdseds24' ,\n    'pdseds25)' ,\n    'profile'\n  return\n\n  /* -------------------- *\n  * Set Date Filters     *\n  * (toggle)             *\n  *                      *\n  * Today - today's date *\n  * Week  - last 7 days  *\n  * Month - last 30 days *\n  * Year  - this year    *\n  * Since yy/mm/dd       *\n  * Since -nn            *\n  * -------------------- */\nsetup_date_filter:\n  date_filterv = zcmd\n  Select\n    When last_date_filter = zcmd then do\n      parse value '' with date_filter date_filterv ,\n        date_filter_title last_date_filter\n    end\n    When zcmd = 'SINCE' then do\n      parse value '' with date_filter date_filterv ,\n        date_filter_title last_date_filter\n    end\n    When word(zcmd,1) = 'SINCE' then do\n      stdate = word(zcmd,2)\n      if left(stdate,1) = '-' then do\n        parse value stdate with '-' sinced\n        date_filter = date('b') - sinced\n        date_filter_title = 'Since' stdate\n        last_date_filter = zcmd\n      end\n      else do\n        x = date_val(stdate)\n        if x > 0 then do\n          zerrsm = 'Invalid Date'\n          zerrlm = stdate 'is an invalid date format.' ,\n            'The date must be in the format of yy/mm/dd.'\n          'Setmsg msg(isrz003)'\n        end\n        else do\n          zerrsm = null\n          parse value stdate with yy'/'mm'/'dd\n          if mm > 12 then do\n            zerrsm = 'Invalid Date'\n            zerrlm = mm 'is an invalid month -' stdate\n            'setmsg msg(isrz003)'\n          end\n          if yy//4 = 0 then mfb = 29\n          else mfb = 28\n          mlimit = '31' mfb '31 30 31 30 31 31 30 31 30 31'\n          if zerrsm = null then\n          if dd > word(mlimit,mm) then do\n            zerrsm = 'Invalid Date'\n            zerrlm = dd 'is an invalid number of days for the' ,\n              'month of' mm '-' stdate\n            'setmsg msg(isrz003)'\n          end\n          if zerrsm = null then do\n            date_filter = date('b',stdate,'o')\n            date_filter_title = 'Since' stdate\n            last_date_filter = zcmd\n          end\n        end\n      end\n    end\n    When zcmd = 'TODAY' then do\n      if last_date_filter = zcmd then do\n        date_filter = null\n        date_filter_title = null\n        last_date_filter = null\n      end\n      else do\n        date_filter = date('b')\n        date_filter_title = 'Today'\n        last_date_filter = zcmd\n      end\n    end\n    When zcmd = 'WEEK' then do\n      if last_date_filter = zcmd then do\n        date_filter = null\n        date_filter_title = null\n        last_date_filter = null\n      end\n      else do\n        date_filter = date('b')-7\n        date_filter_title = 'Week'\n        last_date_filter = zcmd\n      end\n    end\n    When zcmd = 'MONTH' then do\n      if last_date_filter = zcmd then do\n        date_filter = null\n        date_filter_title = null\n        last_date_filter = null\n      end\n      else do\n        date_filter = date('b')-30\n        date_filter_title = 'Month'\n        last_date_filter = zcmd\n      end\n    end\n    When zcmd = 'YEAR' then do\n      if last_date_filter = zcmd then do\n        date_filter = null\n        date_filter_title = null\n        last_date_filter = null\n      end\n      else do\n        yy          = left(date('o'),2)\n        date_filter = date('b',yy'/01/01',o)\n        date_filter_title = 'Year'\n        last_date_filter = zcmd\n      end\n    end\n    Otherwise nop\n    zcmd = null\n  end\n  return\n\n  /* ----------------------- *\n  * Date Validation Routine *\n  * ----------------------- */\nDate_Val: Procedure\n  arg tdate\n  parse value tdate with y'/'m'/'d .\n  if datatype(d) /= 'NUM' then return 1\n  if datatype(m) /= 'NUM' then return 1\n  if datatype(y) /= 'NUM' then return 1\n  return 0\n\n  /* ----------------------------------------------------- *\n  * Test_Gen routine to verify that a relative generation *\n  * is a valid generation.                                *\n  *                                                       *\n  * parms:  member gen                                    *\n  *                                                       *\n  * return:  0 = ok                                       *\n  *          1 = ng                                       *\n  * ----------------------------------------------------- */\nTest_Gen: procedure expose members. null\n  arg mem gen\n  if gen = 0 then return 0\n  if gen > 0 then return 1\n  gen = substr(gen,2) + 1\n  gw = word(members.mem,gen)\n  if gw = null then return 1\n  return 0\n\n  /* ------------------------------------------- *\n  * Ask_Sort routine                            *\n  *                                             *\n  * used to prompt the user for the sort column *\n  * and sort order                              *\n  * ------------------------------------------- */\nAsk_Sort: Procedure Expose sortcol sort_order\n  parse value '' with sc so scx sox sortcol sort_order null\n  do forever\n    call pfshow 'off'\n    'Addpop Row(3) Column(3)'\n    zcmd = null\n    'display panel(pdsegsrt)'\n    xrc = rc\n    'Rempop'\n    call pfshow 'reset'\n    if xrc > 0 then do\n      return\n    end\n    if left(sox,3) = 'Set' then do\n      so = word(sox,2)\n      sox = null\n    end\n    if scx /= null then do\n      sortcol = scx\n    end\n    select\n      when sc = '1' then sortcol = 'NAME'\n      when sc = '2' then sortcol = 'CREATED'\n      when sc = '3' then sortcol = 'CHANGED'\n      when sc = '4' then sortcol = 'ID'\n      when sc = '5' then sortcol = 'SIZE'\n      when sc = '6' then sortcol = 'INIT'\n      when sc = '7' then sortcol = 'MOD'\n      otherwise nop\n    end\n    if sortcol /= null then do\n      sort_order = so\n      return\n    end\n  end\n  return\n\n  /* --------------------------------------- *\n  | Find High Generation                    |\n  |                                         |\n  | Used by the Delete Promote routine      |\n  |                                         |\n  | Arguments:  dataset-name member-name    |\n  | Returns:    highest absolute generation |\n  * --------------------------------------- */\nFind_HighGen: Procedure\n  arg dsn mem\n  pdseddx = randstr()\n  Address TSO\n  'alloc f('pdseddx') ds('dsn') shr reuse'\n  drop member.\n  Address ISPExec ,\n    'dsinfo dataset('dsn')'\n  if zds#mem > 0\n  then x=pdsegeni(pdseddx)\n  else do\n    rc = 0\n    member.0 = 0\n  end\n  'free f('pdseddx')'\n  Address ISPExec\n  do i = 1 to member.0\n    if mem /= '' then if word(member.i,1) /= 'PDSE'mem then iterate\n    parse value member.i with 5 mbr 13 agen 21 .\n    mbr  = strip(mbr)\n    agen = strip(agen)\n    if agen > 0 then return agen\n  end\n\n  /* ------------------------------------------------ *\n  | Common Do_Command routine to handle command line |\n  | commands                                         |\n  |                                                  |\n  | arguments passed:  command-type                  |\n  * ------------------------------------------------ */\nDo_Command:\n  Parse Arg clinecmd\n  docmd = 1\n  bmgen = null\n  Select\n    When clinecmd = 'B' then dcmd = 'Browse'\n    When clinecmd = 'E' then dcmd = 'Edit'\n    When clinecmd = 'S' then dcmd = 'Submit'\n    When clinecmd = 'V' then dcmd = 'View'\n    Otherwise return\n  end\n  /* --------------------------------- *\n  | Check for a member or member-mask |\n  * --------------------------------- */\n  if words(zcmd) = 1 then do\n    zerrsm = 'Error'\n    zerrlm = dcmd 'requires a member name or mask.'\n    'Setmsg msg(isrz003)'\n    return\n  end\n  /* ------------------------------- *\n  | Test for Submit and Correct DCB |\n  * ------------------------------- */\n  if clinecmd = 'S' then do\n    rc = test_submit()\n    if rc > 0 then return\n  end\n  /* ---------------------------------------------- *\n  | Extract member and generation from the command |\n  | and set submit long message to null            |\n  * ---------------------------------------------- */\n  bmbr = word(zcmd,2)\n  bmgen = word(zcmd,3)\n  agen  = bmgen\n  sublm = null\n  bhit = 0\n  ghit = 0\n  if clinecmd = 'E' then\n  if bmgen = null\n  then bmgen = 0\n  if bmgen = null then do\n    ghit = 0\n    if pos('/',bmbr) > 0 then ghit = 1\n    if pos('%',bmbr) > 0 then ghit = 1\n    if pos('*',bmbr) > 0 then ghit = 1\n    if pos(':',bmbr) > 0 then ghit = 1\n    if ghit = 0 then bmgen = 0\n  end\n  /* -------------------------------------------------- *\n  | Test for a real member being requested by checking |\n  | that the member exists                             |\n  * -------------------------------------------------- */\n  if members.bmbr /= null then bhit = 1\n  if all_members.bmbr /= null then bhit = 1\n  if wordpos('0',all_members.bmbr) = 0 then bhit = 0\n  if bhit = 1 then do\n    mbr = bmbr\n    agen = null\n    if bmgen < 1 then do\n      mgen = bmgen\n      agen = word(all_members.mbr,(mgen*-1)+2)\n      higen = words(all_members.mbr) - 2 * -1\n    end\n    if agen = null then\n    if zdsngen > 0 then do\n      zerrsm  = 'Error'\n      zerrlm  = 'Member:' bmbr 'Gen:' bmgen 'not found'\n      'setmsg msg(isrz003)'\n      clinecmd = null\n      bhit = 0\n    end\n    else do\n      if word(all_members.mbr,2) /= 0 then do\n        agen  = 0\n        mgen  = 0\n        higen = 0\n        if clinecmd /= 'E'\n        then bhit = 0\n      end\n    end\n  end\n  /* ------------------------------------------------ *\n  | If the member is not found and edit is requested |\n  | then set the member name to the member filter    |\n  | and edit it. Only works if filter is not a mask. |\n  * ------------------------------------------------ */\n  if bhit = 0\n  then if clinecmd = 'E'\n  then if filter /= null\n  then do\n    bhit = 1\n    if word(zcmd,2) = '*' then do\n      rtn = test_mask(mbr filter)\n      if rtn = 0 then bmbr = filter\n      else bhit = 0\n    end\n  end\n  /* -------------------------------------- *\n  | The member is a mask or does not exist |\n  * -------------------------------------- */\n  if bhit = 0 then do\n    'tbtop' pdset\n    sublm = null\n    do forever\n      'tbskip' pdset\n      if rc > 0 then leave\n      rtn = test_mask(mbr bmbr)\n      if rtn = 0 then leave\n      if bmgen /= null then\n      if bmgen /= mgen then iterate\n      bhit = 1\n      call Exec_Command\n    end\n  end\n  else do\n    mbr = bmbr\n    call exec_command\n  end\n  if clinecmd /= 'E' then\n  if bhit = 0 then do\n    zerrsm  = 'Error'\n    zerrlm  = 'Member:' bmbr 'Gen:' bmgen 'not found'\n    'setmsg msg(isrz003)'\n  end\n  if clinecmd = 'E' then\n  if bhit = 0 then do\n    mbr = bmbr\n    agen = 0\n    if mbr /= '*' then do\n      if mgen = null then do\n        mgen = 0\n        higen = 0\n        'vput (mgen higen) shared'\n      end\n      call do_edit\n    end\n    else do\n      zerrsm = 'Error'\n      zerrlm = 'Member of * is not supported for Edit'\n      'Setmsg msg(isrz003)'\n    end\n  end\n  if update_table /= null then do\n    call refresh_pdsi\n    call proc_pdsegeni\n    parse value '' with update_table lopt lopts\n  end\n  clinecmd = null\n  if sublm /= null then do\n    zerrsm = 'Submitted'\n    zerrlm = 'Submitted:' sublm\n    'Setmsg msg(isrz003)'\n  end\n  Return\n\n  /* ------------------------------ *\n  | Execute the Do_Command request |\n  * ------------------------------ */\nExec_Command:\n  Select\n    When clinecmd = 'B' then call do_browse\n    When clinecmd = 'E' then do\n      call do_edit\n    end\n    When clinecmd = 'S' then do\n      call do_submit\n      if word(zerrlm,1) = 'JOB'\n      then sublm = sublm word(zerrlm,2)\n      else sublm = sublm zerrlm\n    end\n    When clinecmd = 'V' then call do_view\n    Otherwise return\n  end\n  Return\n\n  /* ----------------------------------------------------- *\n  | Proc_Setting routine                                  |\n  |                                                       |\n  | Display the pdsegset panel to prompt for              |\n  |                                                       |\n  |    Default action for S and / selections              |\n  |    Default table positioning for the last selected    |\n  |      member.   1 positions the last selected member   |\n  |      to the top and 0 leaves the last selected member |\n  |      where it is in the table display.                |\n  |    Default colors.                                    |\n  * ----------------------------------------------------- */\nProc_Settings:\n  arg PSoption\n  Address ISPExec\n  'Vget (clrb clrg clrp clrr clrt clrw clry clrh clrhr' ,\n    'sortb sortc pdsetb csrloc changed useab umaxhist) profile'\n  old_ab = useab\n  if datatype(umaxhist) /= 'NUM'\n  then umaxhist = maxhist\n  if sortb = '' then do\n    sortb = left(base_color,1)\n    sortc = left(sort_color,1)\n  end\n  tb = pdsetb\n  if datatype(csrloc) /= 'NUM' then csrloc = 0\n  cp = csrloc\n  if changed = null then changed = disp_change\n  sc = changed\n  if tb = null then tb = 0\n  if cp = null then cp = 0\n  if clrb = '' then do\n    sb = 'B'\n    sg = 'G'\n    sp = 'P'\n    sr = 'R'\n    st = 'T'\n    sw = 'W'\n    sy = 'Y'\n    sh = 'W'\n    rh = 'N'\n  end\n  else do\n    sortb = left(sortb,1)\n    sortc = left(sortc,1)\n    sb = left(clrb,1)\n    sg = left(clrg,1)\n    sp = left(clrp,1)\n    sh = left(clrh,1)\n    sr = left(clrr,1)\n    st = left(clrt,1)\n    sw = left(clrw,1)\n    sy = left(clry,1)\n    if left(clrhr,1) = 'R'\n    then rh = 'Y'\n    else rh = 'N'\n  end\n  Call Set_defaults\n  if PSoption = null then\n  do forever\n    srtb = sortb\n    srtc = sortc\n    'Display panel(pdsegset)'\n    if rc > 0 then leave\n    sortb = srtb\n    sortc = srtc\n    if oldab /= useab then call change_panels\n    Call Set_defaults\n  end\n  'VPut (clrb clrg clrp clrr clrt clrw clry clrh clrhr' ,\n    'sortb sortc pdsetb csrloc changed useab umaxhist) profile'\n  return\n\n  /* ------------------------------------------------ *\n  | Test the DCB of the current dataset to determine |\n  | if a TSO Submit will work.                       |\n  |                                                  |\n  | DCB must be RECFM=Fx                             |\n  * ------------------------------------------------ */\nTest_Submit:\n  if left(zdsrf,1) /= 'F' then do\n    zerrsm = 'Error'\n    zerrlm = 'Submit not supported with a RECFM='zdsrf\n    'Setmsg msg(isrz003)'\n    return 1\n  end\n  if zdslrec /= 80 then do\n    zerrsm = 'Error'\n    zerrlm = 'Submit not supported with a LRECL='strip(zdslrec)\n    'Setmsg msg(isrz003)'\n    return 1\n  end\n  else return 0\n\n  /* ---------------------------- *\n  | Set the defaults for PDSEGEN |\n  * ---------------------------- */\nSet_Defaults:\n  If rh = 'Y' then clrhr = 'Reverse'\n  else clrhr = ''\n  csrloc = cp\n  pdsetb = tb\n  changed = sc\n  Select  /* Sort Base */\n    When sortb = 'B' then sortb = 'Blue'\n    When sortb = 'G' then sortb = 'Green'\n    When sortb = 'P' then sortb = 'Pink'\n    When sortb = 'R' then sortb = 'Red'\n    When sortb = 'T' then sortb = 'Turq'\n    When sortb = 'W' then sortb = 'White'\n    When sortb = 'Y' then sortb = 'Yellow'\n    Otherwise sortb = 'Blue'\n  end\n  Select  /* Sort Color */\n    When sortc = 'B' then sortc = 'Blue'\n    When sortc = 'G' then sortc = 'Green'\n    When sortc = 'P' then sortc = 'Pink'\n    When sortc = 'R' then sortc = 'Red'\n    When sortc = 'T' then sortc = 'Turq'\n    When sortc = 'W' then sortc = 'White'\n    When sortc = 'Y' then sortc = 'Yellow'\n    Otherwise sortc = 'Turq'\n  end\n  Select  /* Blue */\n    When sb = 'B' then clrb = 'Blue'\n    When sb = 'G' then clrb = 'Green'\n    When sb = 'P' then clrb = 'Pink'\n    When sb = 'R' then clrb = 'Red'\n    When sb = 'T' then clrb = 'Turq'\n    When sb = 'W' then clrb = 'White'\n    When sb = 'Y' then clrb = 'Yellow'\n    Otherwise clrb = 'Blue'\n  end\n  Select  /* Green */\n    When sg = 'B' then clrg = 'Blue'\n    When sg = 'G' then clrg = 'Green'\n    When sg = 'P' then clrg = 'Pink'\n    When sg = 'R' then clrg = 'Red'\n    When sg = 'T' then clrg = 'Turq'\n    When sg = 'W' then clrg = 'White'\n    When sg = 'Y' then clrg = 'Yellow'\n    Otherwise clrg = 'Green'\n  end\n  Select  /* Pink */\n    When sp = 'B' then clrp = 'Blue'\n    When sp = 'G' then clrp = 'Green'\n    When sp = 'P' then clrp = 'Pink'\n    When sp = 'R' then clrp = 'Red'\n    When sp = 'T' then clrp = 'Turq'\n    When sp = 'W' then clrp = 'White'\n    When sp = 'Y' then clrp = 'Yellow'\n    Otherwise clrp = 'Pink'\n  end\n  Select  /* Red  */\n    When sr = 'B' then clrr = 'Blue'\n    When sr = 'G' then clrr = 'Green'\n    When sr = 'P' then clrr = 'Pink'\n    When sr = 'R' then clrr = 'Red'\n    When sr = 'T' then clrr = 'Turq'\n    When sr = 'W' then clrr = 'White'\n    When sr = 'Y' then clrr = 'Yellow'\n    Otherwise clrr = 'Red'\n  end\n  Select  /* Turq */\n    When st = 'B' then clrt = 'Blue'\n    When st = 'G' then clrt = 'Green'\n    When st = 'P' then clrt = 'Pink'\n    When st = 'R' then clrt = 'Red'\n    When st = 'T' then clrt = 'Turq'\n    When st = 'W' then clrt = 'White'\n    When st = 'Y' then clrt = 'Yellow'\n    Otherwise clrt = 'Turq'\n  end\n  Select  /* White */\n    When sw = 'B' then clrw = 'Blue'\n    When sw = 'G' then clrw = 'Green'\n    When sw = 'P' then clrw = 'Pink'\n    When sw = 'R' then clrw = 'Red'\n    When sw = 'T' then clrw = 'Turq'\n    When sw = 'W' then clrw = 'White'\n    When sw = 'Y' then clrw = 'Yellow'\n    Otherwise clrw = 'White'\n  end\n  Select  /* Yellow */\n    When sy = 'B' then clry = 'Blue'\n    When sy = 'G' then clry = 'Green'\n    When sy = 'P' then clry = 'Pink'\n    When sy = 'R' then clry = 'Red'\n    When sy = 'T' then clry = 'Turq'\n    When sy = 'W' then clry = 'White'\n    When sy = 'Y' then clry = 'Yellow'\n    Otherwise clry = 'Yellow'\n  end\n  Select  /* Header */\n    When sh = 'B' then clrh = 'Blue'\n    When sh = 'G' then clrh = 'Green'\n    When sh = 'P' then clrh = 'Pink'\n    When sh = 'R' then clrh = 'Red'\n    When sh = 'T' then clrh = 'Turq'\n    When sh = 'W' then clrh = 'White'\n    When sh = 'Y' then clrh = 'Yellow'\n    Otherwise clrh = 'White'\n  end\n  clrn      = base_color\n  clrmbr    = base_color\n  clrcdate  = base_color\n  clrchang  = base_color\n  clrmcur   = base_color\n  clrminit  = base_color\n  clrmmod   = base_color\n  clrmuser  = base_color\n  Select\n    When sortcol = 'NAME'     then clrmbr   = sort_color\n    When sortcol = 'CREATED'  then clrcdate = sort_color\n    When sortcol = 'CHANGED'  then clrchang = sort_color\n    When sortcol = 'ID'       then clrmuser = sort_color\n    When sortcol = 'SIZE'     then clrmcur  = sort_color\n    When sortcol = 'MOD'      then clrmmod  = sort_color\n    When sortcol = 'INIT'     then clrminit = sort_color\n    otherwise clrmbr = sort_color\n  end\n  return\n\n  /* --------------------------------------------------------- *\n  | Test_Mask routine used when the command contains a member |\n  | or member with mask.                                      |\n  |                                                           |\n  | Arguments passed: member-name mask                        |\n  | Return code:  0 - no match                                |\n  |               1 - match                                   |\n  * --------------------------------------------------------- */\nTest_Mask: procedure\n  arg string mask\n\n  /* ----------------------- *\n  | Define the type of mask |\n  |                         |\n  | 0 = no mask             |\n  | 1 = mask % or *         |\n  | 2 = pattern with :      |\n  | 3 = pattern with /      |\n  * ----------------------- */\n  hit = 0\n  if pos('*',mask) > 0 then hit = 1\n  if pos('%',mask) > 0 then hit = 1\n  if pos(':',mask) > 0 then hit = 2\n  if pos('/',mask) > 0 then hit = 3\n  /* ------------------------- *\n  | Change a filter of ? to % |\n  * ------------------------- */\n  if pos('?',mask) > 0 then do\n    mask = translate(mask,'%','?')\n    hit = 1\n  end\n\n  Select\n    When hit = 1 then do\n      rtn = pdsegmat(string,mask)\n      return rtn\n    end\n    When hit = 2 then do\n      p1 = pos(':',mask)\n      tname = left(mask,p1-1)\n      if tname = left(string,p1-1) then return 1\n      else return 0\n    end\n    When hit = 3 then do\n      tname = strip(translate(mask,' ','/'))\n      if pos(tname,string) > 0 then return 1\n      else return 0\n    end\n    When hit = 0 then do\n      if mask = string then return 1\n      else return 0\n    end\n    Otherwise return 0\n  End\n\nrandstr: procedure\n  /* --------------------  rexx procedure  -------------------- *\n  | Name:      randstr                                         |\n  |                                                            |\n  | Function:  Generate a unique character string for use      |\n  |            in an ISPF Table name, DDName, etc.             |\n  |                                                            |\n  |            This is for ISPF dialogs that may run           |\n  |            concurrently in either multiple split           |\n  |            screens or stacked so as to prevent duplicate   |\n  |            DD or ISPF table names.                         |\n  |                                                            |\n  |            Or any length string with or without            |\n  |            lowercase characters.                           |\n  |                                                            |\n  |            Thus this can be used to generate a random      |\n  |            password or passphrase                          |\n  |                                                            |\n  |            This may also be used for any other need        |\n  |            to have a unique character string that is       |\n  |            a valid DDName, Member Name, etc.               |\n  |                                                            |\n  | Syntax:    x = randstr(n)                                  |\n  |                                                            |\n  |            Where n is the number of characters to          |\n  |            return, always starting with an alpha.          |\n  |                                                            |\n  |            The default if not provided is 8                |\n  |                                                            |\n  |            If 'n' is preceded by L (e.g. L8) then          |\n  |            50% of the characters will be lowercase         |\n  |                                                            |\n  | Notes:     In testing this generated 0 duplicates in 10    |\n  |            tests with 100,000 iterations so this looks     |\n  |            reasonably random - when n is 8.                |\n  |                                                            |\n  |            Using less than 8 will result in a higher       |\n  |            probability of duplicates and using more        |\n  |            will result in lowering the probabilty of       |\n  |            duplicates.                                     |\n  |                                                            |\n  |            DO NOT call this routine RANDOM as it will      |\n  |            confuse the use of the REXX RANDOM function     |\n  |            within the code.                                |\n  |                                                            |\n  | Author:    Lionel B. Dyck                                  |\n  |                                                            |\n  | History:  (most recent on top)                             |\n  |            02/27/18 - Ensure 1st position is alpha         |\n  |            02/26/18 - Add LOTS of comments                 |\n  |            02/23/18 - Insure 1st char is not special char  |\n  |                     - Allow a parm for # of characters     |\n  |                     - Allow Lowercase in string            |\n  |            02/22/18 - Additional doc and randomness        |\n  |            02/21/18 - Creation                             |\n  |                                                            |\n  * ---------------------------------------------------------- */\n  arg numchars\n\n  /* ------------------------------------ *\n  | Check for L (lower case) in the parm |\n  |  - set lowercase flag on             |\n  |  - remove L from the parm (numchars) |\n  | Otherwise set lower case flag off    |\n  * ------------------------------------ */\n  if left(numchars,1) = 'L' then do\n    lowcase = 1\n    numchars = substr(numchars,2)\n  end\n  else lowcase = 0\n\n  /* ----------------------------------------------------- *\n  | Check that numchars is numeric otherwise default to 8 |\n  * ----------------------------------------------------- */\n  if datatype(numchars) /= 'NUM' then numchars = 8\n\n  /* -------------------------- *\n  | Define our default strings |\n  * -------------------------- */\n  alpha  = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ$#@'\n  lowchar= 'abcdefghijklmnopqrstuvwxyz'\n  alpha# = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ$#@0123456789'\n\n  /* -------------------------------------- *\n  | Use 24 digit precision in calculations |\n  * -------------------------------------- */\n  numeric digits 24\n\n  /* ----------------------------- *\n  | Get random character position |\n  * ----------------------------- */\n  ra = random(1,26)\n  /* ------------------------------------------ *\n  | Start the return with the random character |\n  | - then append the seconds since midnight   |\n  |   multiplied by a random 5 digit number    |\n  |   and then multiply again by another       |\n  |   random 5 digit number.                   |\n  | Then truncate at the request number of     |\n  | characters (numchars)                      |\n  * ------------------------------------------ */\n  r = left(substr(alpha,ra,1) || ,\n    time('s') * random(99999) ,\n    * random(99999),numchars)\n\n  /* --------------------------------------------------- *\n  | Overlay the returned string with 3 different random |\n  | characters from the alpha string to make it more    |\n  | random.                                             |\n  | ra = random char location                           |\n  | rc = random target location                         |\n  * --------------------------------------------------- */\n  ra = random(1,29);rc = random(2,numchars)\n  r = overlay(substr(alpha,ra,1),r,rc,1)\n  ra = random(1,29);rc = random(2,numchars)\n  r = overlay(substr(alpha,ra,1),r,rc,1)\n  ra = random(1,29);rc = random(2,numchars)\n  r = overlay(substr(alpha,ra,1),r,rc,1)\n  ra = random(1,29);rc = random(2,numchars)\n  r = overlay(substr(alpha,ra,1),r,rc,1)\n\n  /* --------------------------------- *\n  | Clean up any blanks in the return |\n  | by replacing with random alpha#   |\n  * --------------------------------- */\n  do while pos(' ',r) > 0\n    pb = pos(' ',r)         /* get position of blank           */\n    ra = random(1,39)       /* get a random character position */\n    /* now overlay the random character at the random position */\n    r = overlay(substr(alpha#,ra,1),r,pb,1)\n  end\n\n  /* ------------------------------------- *\n  | Process Lowercase request if provided |\n  | by overlaying 1/2 of all return chars |\n  | with a lower case character.          |\n  * ------------------------------------- */\n  if lowcase = 1 then do\n    lc = numchars%2       /* get 50% of requested length */\n    do i = 1 to lc\n      /* ra = random lowercase character location */\n      /* rc = random character position location  */\n      ra = random(1,26);rc = random(1,numchars)\n      /* now overlay the random character at the random position */\n      r = overlay(substr(lowchar,ra,2),r,rc,1)\n    end\n  end\n\n  /* --------------------- *\n  | Now return the string |\n  * --------------------- */\n  return r\n\n  /* -------------------------------------------- *\n  | Define a fully qualified variable of the dsn |\n  * -------------------------------------------- */\nFixup_pdsedsn:\n  if pdsedsn = '*' then return\n  if pdsedsn = '' then return    /* No dsn so return */\n  if pos('(',pdsedsn) = 0\n  then tdsn = pdsedsn\n  else do\n    parse value pdsedsn with tdsn'('.')'rd\n    tdsn = tdsn''rd\n  end\n  x = listdsi(tdsn)\n  wdsn = sysdsname\n  return\n\nTest_DSN_Alias:\n  if length(pdsedsn) < 9\n  then if pos('.',pdsedsn) = 0\n  then do\n    x = pdsegdsl('>'pdsedsn)\n    if x /= 0 then pdsedsn = x\n  end\n  return\n\n  /* --------------------  rexx procedure  -------------------- *\n  | Name:      VALNAME                                         |\n  |                                                            |\n  | Function:  Validate a string as a valid PDS member name    |\n  |                                                            |\n  | Syntax:    x=valname(name)                                 |\n  |                                                            |\n  | Usage Notes: typically used from within a rexx program     |\n  |                                                            |\n  |            1st char must be alpha or @#$                   |\n  |            2-8th must be alpha, @#$ or 0 thru 9            |\n  |            must be 1 to 8 characters                       |\n  |                                                            |\n  | Author:    Lionel B. Dyck                                  |\n  |                                                            |\n  | History:  (most recent on top)                             |\n  |            04/02/18 - Creation                             |\n  |                                                            |\n  | ---------------------------------------------------------- */\nValName:\n  arg name\n  if strip(name) = '' then return 0\n  good_alpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$'\n  good_nums  = '0123456789'\n  bad_chars  = '%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'\n  tname = translate(translate(name,bad_chars,good_alpha good_nums),' ','%')\n  Select\n    when pos(left(name,1),good_alpha) = 0\n    then bad = 'Invalid 1st Character' left(name,1)\n    when length(name) > 8\n    then bad = 'Too Many Characters' length(name)\n    when strip(tname) /= ''\n    then bad = 'Contains Invalid Characters' strip(tname)\n    otherwise bad = 0\n  end\n  return bad\n\n  /* -------------------------------- *\n  | Age routine from John K's PGLite |\n  * -------------------------------- */\ndo_age: procedure expose member. null\n  tbl. = 0\n  do x = 1 to member.0\n    parse value member.x with . 5 mbr . 22 vrm . 49 adate 56 . 87 dmy .\n    mbr   = strip(mbr)\n    if left(mbr,1) = '00'x then iterate\n    if dmy = 'D' then iterate\n    if vrm = 'N' then do\n      call stats 'unknown'\n      iterate\n    end\n    else do\n      adate  = substr(adate,3,5)\n      adate  = date('o',adate,'j')\n      call do_date_range\n    end\n  end\n  name = 'today'     ; age1 = tbl.name\n  name = 'yesterday' ; age2 = tbl.name\n  name = 'week'      ; age3 = tbl.name\n  name = 'current'   ; age4 = tbl.name\n  name = 'biweek'    ; age5 = tbl.name\n  name = 'month'     ; age6 = tbl.name\n  name = 'bimonth'   ; age7 = tbl.name\n  name = 'quarter'   ; age8 = tbl.name\n  name = 'halfyear'  ; age9 = tbl.name\n  name = 'year'      ; age10 = tbl.name\n  name = 'biyear'    ; age11 = tbl.name\n  name = 'dirt'      ; age12 = tbl.name\n  name = 'unknown'   ; age13 = tbl.name\n  'Addpop'\n  'Display Panel(pdsegage)'\n  'rempop'\n  drop tbl.\n  return\n  /* --------------------------------- *\n  | Member age routine                |\n  * --------------------------------- */\ndo_date_range:\n  if adate = null then\n  return\n  today = date('b')\n  days  = date('b',adate,'o')\n  Select\n    when today - days < 1 then do; call stats 'today'    ; end\n    when today - days = 1 then do; call stats 'yesterday'; end\n    when today - days < 8 then do; call stats 'week'     ; end\n    when today - days < 11 then do; call stats 'current' ; end\n    when today - days < 15 then do; call stats 'biweek'  ; end\n    when today - days < 31 then do; call stats 'month'   ; end\n    when today - days < 61 then do; call stats 'bimonth' ; end\n    when today - days < 91 then do; call stats 'quarter' ; end\n    when today - days < 184 then do; call stats 'halfyear' ; end\n    when today - days < 366 then do; call stats 'year'   ; end\n    when today - days < 731 then do; call stats 'biyear' ; end\n    when today - days > 730 then do; call stats 'dirt'   ; end\n    Otherwise nop\n  end\n  return\n\nChange_Panels:\n  call set_panels\n  suf = right(tpanel,1)\n  if useab = 'Y'\n  then suf = translate(suf,'abcdefgh','12345678')\n  else suf = translate(suf,'12345678','abcdefgh')\n  tpanel = left(tpanel,7)''suf\n  'vput (tpanel) profile'\n  return\n\nSet_Panels:\n  if pos(useab,'YN') = 0 then do\n    useab = 'N'\n    'vput (useab) profile'\n  end\n  if useab = 'N' then do\n  /* panels with absolute gen */\n    table_panel1 = 'pdseged1'  /* 1 character sel - 2 digit year */\n    table_panel2 = 'pdseged2'  /* 1 character sel - 4 digit year */\n    table_panel3 = 'pdseged3'  /* 9 character sel - 2 digit year */\n    table_panel4 = 'pdseged4'  /* 9 character sel - 4 digit year */\n  /* panels without absolute gen */\n    table_panel5 = 'pdseged5'  /* 1 character sel - 2 digit year */\n    table_panel6 = 'pdseged6'  /* 1 character sel - 4 digit year */\n    table_panel7 = 'pdseged7'  /* 9 character sel - 2 digit year */\n    table_panel8 = 'pdseged8'  /* 9 character sel - 4 digit year */\n  end\n  else do\n  /* panels with absolute gen */\n    table_panel1 = 'pdsegeda'  /* 1 character sel - 2 digit year */\n    table_panel2 = 'pdsegedb'  /* 1 character sel - 4 digit year */\n    table_panel3 = 'pdsegedc'  /* 9 character sel - 2 digit year */\n    table_panel4 = 'pdsegedd'  /* 9 character sel - 4 digit year */\n  /* panels without absolute gen */\n    table_panel5 = 'pdsegede'  /* 1 character sel - 2 digit year */\n    table_panel6 = 'pdsegedf'  /* 1 character sel - 4 digit year */\n    table_panel7 = 'pdsegedg'  /* 9 character sel - 2 digit year */\n    table_panel8 = 'pdsegedh'  /* 9 character sel - 4 digit year */\n  end\n  return\n\nstats:\n  parse arg type\n  tbl.type = tbl.type + 1\n  return\n\nCmd_Prompt:\n  arg askopt\n  askstr = null\n  'vput (askopt)'\n  'addpop row(3) column(3)'\n  'display panel(pdsegask)'\n  'rempop'\n  zcmd = askopt askstr\n  return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDSEGENC": {"ttr": 181, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01c\\x00\\x10\\x01\\x16 \\x0f\\x01\\x19%O\\x07'\\x03c\\x01\\xb0\\x00\\x00\\xd7\\xc4\\xe2\\xc5@@@@@@\"", "ispf": {"version": "01.99", "flags": 0, "createdate": "2016-07-18T00:00:00", "modifydate": "2019-09-11T07:27:10", "lines": 867, "newlines": 432, "modlines": 0, "user": "PDSE"}, "text": "/* --------------------  rexx procedure  -------------------- */\n  pdsegver = pdsegver()\n/* Name:      pdsegenc                                        *\n *                                                            *\n * Function:  Copy a PDSE to a new PDSE along with all        *\n *            generations                                     *\n *                                                            *\n * Syntax:    %pdsegenc from to member-pattern  ( options     *\n *                                                            *\n *            Allowed patterns described below                *\n *                                                            *\n *            valid options are:                              *\n *                                                            *\n *            Batch   - used when running under TSO/ISPF to   *\n *                      prevent the popup progress indicator  *\n *                                                            *\n *            New     - will cause the 'to' dataset to be     *\n *                      created using the 'from' for the      *\n *                      allocation info.                      *\n *                                                            *\n *            Replace - will replace members of the same      *\n *                      name during the copy                  *\n *                                                            *\n *            No closing ) for options                        *\n *                                                            *\n *            Defaults: no-batch not-new no-replace           *\n *                                                            *\n * Notes:     All members in the from will be copied into     *\n *            the to dataset, including all generations.      *\n *            Member pattern matching is supported:           *\n *                                                            *\n *    if filter is x: then test for member starting with x    *\n *    if filter is x/ then test for member with x anywhere    *\n *    if filter is /x then test for member with x anywhere    *\n *    if filter is x then test for x                          *\n *    if filter has * or % then test for pattern              *\n *       using pdsegmat (rexx function)                       *\n *    if filter has : within then use from: to                *\n *    if filter is (mem mem mem) with or without masks        *\n *                                                            *\n *    All date filters work as well and may be combined with  *\n *    a pattern.                                              *\n *                                                            *\n *            The ISPF statistics for the base (gen 0)        *\n *            member are retained but for the generations     *\n *            those are effectively created as new by this    *\n *            copy process (since lmcopy doesn't understand   *\n *            generations).                                   *\n *                                                            *\n *            The copy process consists of using ISPF edit    *\n *            macros to copy all the records from the         *\n *            generation (non-0 only) to the clipboard and    *\n *            then paste the records into the member in the   *\n *            target PDSE. The copy is done from the oldest   *\n *            generation to the newest and then lmcopy is     *\n *            used to copy the base. This causes the          *\n *            generation to remain in the same relative       *\n *            order but the absolute generation numbers are   *\n *            lost.                                           *\n *                                                            *\n *            If any dummy members are found then they will   *\n *            be ignored since there is no way to know if     *\n *            they are valid or not and in most cases are not.*\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * History:                                                   *\n *            09/10/19 - Fix pdsegeni parse for mmod          *\n *            08/19/19 - Fix filter/options bug               *\n *            08/13/19 - Support from:to filter               *\n *                     - Support filter (mem mem mem)         *\n *            10/15/18 - Correct long record for lrecl=80     *\n *            05/10/18 - Update if no date_filter and correct *\n *                       copy message if copy error           *\n *            11/27/17 - If no members copied exit with rc 4  *\n *            11/24/17 - Update to support changed PDSEGENS   *\n *            08/14/17 - Change to use pdsegver for pdsegen   *\n *                       version                              *\n *            06/20/17 - Version change only                  *\n *            06/08/17 - Version change only                  *\n *            05/30/17 - Version change only                  *\n *            05/19/17 - Change to use Edit Macro Parm        *\n *            04/04/17 - Correct batch report                 *\n *                     - Recurse into APPL(PDSE) if not       *\n *            03/10/17 - Correct lrecl for browse of msgs     *\n *            03/03/17 - If (batch is specified then browse   *\n *                       messages instead of directing them   *\n *                       to the terminal                      *\n *            01/19/17 - Version change only                  *\n *            01/05/17 - Version change only                  *\n *            12/13/16 - Fix for null members                 *\n *            10/07/16 - Allow null default unit              *\n *                     - correction for ttr check             *\n *            09/12/16 - Get default unit for alloc from      *\n *                       PDSEGENS                             *\n *                     - additional test for null member name *\n *            09/01/16 - Add Batch and New options and use    *\n *                       enhanced pattern matching            *\n *                     - Support Date filtering               *\n *                     - if ttr is x'000000' then ignore as   *\n *                       it's a dummy member                  *\n *            08/25/16 - If the target PDS has maxgen of 0    *\n *                       then don't copy generations          *\n *            08/15/16 - Correction for copy count (dummy)    *\n *            08/04/16 - Correction for noprefix users        *\n *            07/27/16 - Correction if used to copy non-gen   *\n *                       enabled pds                          *\n *            07/25/16 - Change to dsinfo for topdse          *\n *                     - Change from using ISRZ001 to ISRZ002 *\n *            07/21/16 - Add display progress for base members*\n *                     - Add elapsed time to message          *\n *            07/18/16 - Update to use Replace instead of     *\n *                       cut/paste                            *\n *            07/06/16 - Support filter a for member a        *\n *                       and for /a like a/                   *\n *            07/06/16 - Support filter a: like a*            *\n *                       Thanks to John Kalinich              *\n *            06/28/16 - Add member masking like in pdsegen   *\n *            06/24/16 - Update to run in ISPF Batch          *\n *            06/21/16 - Update to use PDSEGENI function      *\n *            06/10/16 - Creation                             *\n *                                                            *\n * ---------------------------------------------------------- *\n * Copyright (c) 2017-2019 by Lionel B. Dyck                  *\n * ---------------------------------------------------------- *\n * License:   This EXEC and related components are released   *\n *            under terms of the GPLV3 License. Please        *\n *            refer to the LICENSE file for more information. *\n *            Or for the latest license text go to:           *\n *                                                            *\n *              http://www.gnu.org/licenses/                  *\n *                                                            *\n * ---------------------------------------------------------- */\n  arg options\n\n/* ---------------------------------------------------- *\n | Check for Applid of PDSE and recurse into it if not. |\n * ---------------------------------------------------- */\n  Address ISPExec\n  'Control Errors Return'\n  \"Vget (Zapplid)\"\n  if zapplid <> \"PDSE\" then do\n    \"Select CMD(%\"sysvar('sysicmd') options \") Newappl(PDSE)\" ,\n      \"Passlib\"\n    exit 0\n  end\n\n  parse value options with frompdse topdse options\n  /* a %pdsegenc from to *   *\n   *   %pdsegenc from to x:d */\n  /* b %pdsegenc from to filter ( options */\n  /* c %pdsegenc from to (a b)            */\n  /* d %pdsegenc from to (a b) ( options  */\n  /* e %pdsegenc from to ( options        */\n  if pos(')',options) > 0\n     then do\n     parse value options with '('filter')' '('options\n     filter = '('filter')'\n     end\n     else parse value options with filter '(' options\n\n/* --------------- *\n | Define defaults |\n * --------------- */\n  parse value '' with null replace batch new members copy_members ,\n    date_filter haltmsg\n  count    = 0\n  trapc    = 0\n  zerrhm   = 'PDSEGH0'\n  zerralrm = 'NO'\n\n/* -------------------- *\n | Check passed options |\n * -------------------- */\n  if wordpos('REPLACE',options) > 0 then replace = 'Replace'\n  if wordpos('BATCH',options) > 0 then batch = 'Batch'\n  if wordpos('NEW',options) > 0 then new = 'New'\n\n/* ---------------------------- *\n * Test for foreground or batch *\n * ---------------------------- */\n  if sysvar('sysenv') = 'FORE'\n  then environment = 1\n  else do\n    environment = 0\n    batch = 'Batch'\n  end\n  if batch /= null then environment = 0\n  if environment = 0 then do\n    call say_msg 'PDSEGENC Processing' date() time()\n    call say_msg ' '\n    call say_msg 'Processing parms:'\n    call say_msg 'From PDSE:' frompdse\n    call say_msg 'To PDSE  :' topdse\n    call say_msg 'Filter:  :' filter\n    call say_msg 'Replace  :' replace\n    call say_msg 'New      :' new\n    call say_msg 'Batch    :' batch\n    call say_msg ' '\n  end\n\n/* ----------------------------- *\n * Validate the input parameters *\n * ----------------------------- */\n  if frompdse = null then call bad_syntax\n  if topdse   = null then call bad_syntax\n  if filter   = null then filter = '*'\n\n  if 'OK' /= sysdsn(frompdse) then call bad_from\n  if new = null\n  then do\n    if 'OK' /= sysdsn(topdse)\n    then call bad_to1\n  end\n  else do\n    if 'OK' = sysdsn(topdse)\n    then call bad_to2\n  end\n\n/* ---------------------------------------------- *\n * Get the defaults from PDSEGENS                 *\n *                                                *\n * (we only are about the default unit (def_unit) *\n * ---------------------------------------------- */\n  x = pdsegens()\n  parse value x with  mail '/' etime '/' higen ,\n    '/' base_color '/' sort_color '/' clean ,\n    '/' prune_prompt '/' tempmem '/' def_unit ,\n    '/' x\n  base_color   = strip(base_color)\n  sort_color   = strip(sort_color)\n  clean        = strip(clean)\n  prune_prompt = strip(prune_prompt)\n  tempmem      = strip(tempmem)\n  def_unit     = strip(def_unit)\n  if def_unit /= null then\n  def_unit = 'unit('def_unit')'\n\n/* ------------------------------ *\n * Allocate the target (new) PDSE *\n * ------------------------------ */\n  if new /= null then do\n    'dsinfo dataset('frompdse')'\n    select\n      when left(zdsspc,1) = 'C' then spaceu = 'Cyl'\n      when left(zdsspc,1) = 'T' then spaceu = 'Trk'\n      when left(zdsspc,1) = 'B' then spaceu = 'Blk'\n      otherwise spaceu = 'B'\n    end\n\n    newgen = zdsngen + 0\n    Address TSO\n    \"Alloc ds(\"topdse\") like(\"frompdse\")\" ,\n      \"dsntype(library,2) maxgens(\"newgen\")\" ,\n      def_unit ,\n      \"space(\"zdstota','zds2ex')'\n    \"Free ds(\"topdse\")\"\n    Address ISPExec\n  end\n\n/* --------------------------------- *\n * Fix up frompdse for testing later *\n * --------------------------------- */\n  if replace = null then do\n    if left(frompdse,1) = \"'\" then do\n      fdsn = substr(frompdse,2,length(frompdse)-2)\n    end\n    else do\n      if sysvar('syspref') = null then hlq = null\n      else hlq = sysvar('sysuid')'.'\n      fdsn = hlq''frompdse\n    end\n  end\n\n/* ------------------------------- *\n * Fix up topdse for testing later *\n * ------------------------------- */\n  if left(topdse,1) = \"'\" then do\n    wdsn = substr(topdse,2,length(topdse)-2)\n  end\n  else do\n    if sysvar('syspref') = null then hlq = null\n    else hlq = sysvar('sysuid')'.'\n    wdsn = hlq''topdse\n  end\n\n/* ------------------------- *\n * Get topdse info (zdsngen) *\n * ------------------------- */\n  'dsinfo dataset('topdse')'\n\n/* ----------------------------------------- *\n * Establish the ISPF setup for the datasets *\n * ----------------------------------------- */\n  \"lminit dataid(fromid) dataset(\"frompdse\")\"\n  \"lminit dataid(toid)     dataset(\"topdse\")\"\n\n/* -------------------------------------------------------- *\n * Copy those members generations that match the            *\n * member pattern.                                          *\n *                                                          *\n * First get a list of all members                          *\n * Then test for generations                                *\n * If generations then test to match pattern and then       *\n * Copy using the pdsegenm macro with options C and PE      *\n * -------------------------------------------------------- */\n\n  x = time('r')\n\n/* ------------------------- *\n * Get a list of all members *\n * ------------------------- */\n  pdd = '$PDSE'random(99)\n  pdg = '$PDSG'random(99)\n  Address TSO\n  \"Alloc f(\"pdd\") shr reuse ds(\"frompdse\")\"\n  x=pdsegeni(pdd)\n  \"Free f(\"pdd\")\"\n  Address ISPExec\n\n/* -------------------------- *\n * Check for a member pattern *\n * -------------------------- */\n  if filter /= '*' then\n  call setup_filter\n\n/* -------------------------------------------- *\n * Process the members from pdsegeni (member.i) *\n * -------------------------------------------- */\n  omem  = null\n  do ifm = 1 to member.0\n    parse value member.ifm with 5 cmem 13 agen 21 . 22 vrm 27 . ,\n      35 cdate 42 . 46 mttr ,\n      49 mdate 56 mtime 63 muser 70 mmod 73 . 75 mcur 79 minit ,\n      83 dmy .\n    cmem = strip(cmem)\n    agen = strip(agen)\n   /* --------------------------------- *\n    * Test for dummy members and ignore *\n    * --------------------------------- */\n    if left(cmem,1) = '00'x then iterate\n    if c2x(ttr) == '000000' then iterate\n    if omem /= cmem then do\n      omem = cmem\n      if agen > 0 then do\n        omem = null\n        iterate\n      end\n    end\n\n   /* ------------------------- *\n    * test for member filtering *\n    * ------------------------- */\n    if filter /= '*' then do\n      ftest =proc_filter(cmem)\n      if ftest = 0 then iterate\n    end\n\n    if length(strip(mcur)) = 0 then mcur = 0\n    else mcur = x2d(c2x(mcur))\n    if length(strip(minit)) = 0 then minit = 0\n    else minit = x2d(c2x(minit))\n    mtime = Substr(mtime,2,2)||':'||Substr(mtime,4,2)\n    mmod = c2x(mmod)\n    mmod = x2d(mmod)\n    if mdate /= '' then do\n      smdate = substr(mdate,1,7)\n      mdate = substr(mdate,3,5)\n      mdate = date('o',mdate,'j')\n    end\n\n   /* ----------------------- *\n    * Test for Date Filtering *\n    * ----------------------- */\n    if date_filter /= null then do\n      if mdate = null then iterate\n      test_date = date('b',mdate,'o')\n      if date_filter > test_date then iterate\n    end\n\n   /* ------------------------------------------ *\n    * Passed all filters so register this member *\n    * ------------------------------------------ */\n    if wordpos(cmem,members) = 0 then do\n      members = members cmem\n      mem.cmem.A = ''\n    end\n    if agen = null then agen = 0\n    mem.cmem.A = mem.cmem.A agen\n\n    if cdate /= '' then do\n      scdate = substr(cdate,1,7)\n      cdate = substr(cdate,3,5)\n      cdate = date('o',cdate,'j')\n    end\n  /* ------------------------------- *\n   * Add the member info to our stem *\n   * ------------------------------- */\n    parse value vrm with iver'.'imod\n    if strip(iver)  = null then iver  = 0\n    if strip(imod)  = null then imod  = 0\n    if strip(cdate) = null then cdate = 0\n    if strip(mdate) = null then mdate = 0\n    if strip(mtime) = null then mtime = '0:0'\n    if strip(muser) = null then muser = '??'\n    mem.cmem.agen = cmem agen'\\'iver'\\'imod'\\'cdate,\n      '\\'mdate'\\' mtime'\\'mcur'\\'minit'\\'mmod'\\'muser\n  end\n\n/* ------------------------------- *\n * Now process the members to copy *\n * ------------------------------- */\n  halt = 0\n  do im = 1 to words(members)\n    if halt /= 0 then leave\n    cmem = word(members,im)\n    if replace = null\n    then if 'OK' = sysdsn(\"'\"wdsn\"(\"cmem\")'\") then iterate\n    if replace /= null then do\n      \"LMInit Dataid(delete) dataset(\"topdse\") enq(shrw)\"\n      \"LMOpen Dataid(\"delete\") Option(Output)\"\n      \"LMMDel  Dataid(\"delete\") Member(\"cmem\") NoEnq\"\n      \"LMClose Dataid(\"delete\")\"\n      \"LMFree Dataid(\"delete\")\"\n    end\n    do ix = words(mem.cmem.A) to 1 by -1\n      igen = word(mem.cmem.A,ix)\n      parse value mem.cmem.igen with x y'\\'iver'\\'imod'\\'cdate,\n        '\\'mdate'\\' mtime'\\'mcur'\\'minit,\n        '\\'mmod'\\'muser\n      if igen = 0 then do\n        if environment = 1\n        then call disp_progress\n        else call say_msg 'Copying member' left(cmem,8) 'base generation'\n        \"lmcopy fromid(\"fromid\") todataid(\"toid\")\" ,\n          \"frommem(\"cmem\") replace\"\n        if rc = 0 then\n        count = count + 1\n        if rc = 20 then do  /* no space in directory */\n          'setmsg msg(isrz002)'\n          haltmsg = zerrsm\n          halt = 1\n          leave\n        end\n      end\n\n      /* Test zdsngen from topdse and if >0 then copy gens */\n      if zdsngen > 0 then\n      if igen /= 0 then do\n           /* ---------------------------------- *\n            * Copy all records from 'old' member *\n            * ---------------------------------- */\n        pdsemopt = 'R'\n        pdsecpds = \"'\"wdsn\"(\"cmem\")'\"\n        'vput (pdsecpds)'\n        'view dataid('fromid') member('cmem') gen('igen')' ,\n          'macro(pdsegenm) parm(pdsemopt)'\n           /* ----------------- *\n            * Document the copy *\n            * ----------------- */\n        if rc < 10 then do\n          count = count + 1\n          if environment = 1\n          then call disp_progress\n          else call say_msg 'Copied member' left(cmem,8) ,\n            'generation' igen\n        end\n           /* ------------------------------------------------ *\n            * Update the target member with the old ISPF stats *\n            * ------------------------------------------------ */\n        if iver > 0  then\n        'LMMStats Dataid('toid')' ,\n          'Member('cmem') version('iver') modlevel('imod')' ,\n          'Created('cdate') Moddate('mdate')' ,\n          'Modtime('mtime') Cursize('mcur')' ,\n          'Initsize('minit') Modrecs('mmod')' ,\n          'User('muser')'\n        else\n        'LMMStats Dataid('toid') member('cmem')  Delete'\n      end\n    end\n  end\n\n/* ------------------------------------- *\n * Free up the ISPF allocations and exit *\n * ------------------------------------- */\n  call proc_etime\n  if environment = 0 then call say_msg ' '\n  zerrsm  = 'Copied' count\n  if haltmsg /= null then zerrsm = zerrsm 'Error'\n  zerrlm  = 'Copied' count 'members from' frompdse 'to' topdse ,\n    'in' etime haltmsg\n  call set_msg\n  \"lmfree dataid(\"fromid\")\"\n  \"lmfree dataid(\"toid\")\"\n  if sysvar('sysenv') = 'BACK'\n  then do i = 1 to trapc\n    say trap.i\n  end\n  else if environment = 0 then\n  if sysvar('sysispf') = 'ACTIVE' then do\n    trap.0 = trapc\n    if length(zerrlm) < 90 then lrecl = 94\n    else lrecl = length(zerrlm) + 4\n    Address TSO\n    'Alloc f('pdd') ds('pdd'.log) new spa(1,1) unit(3390)' ,\n      'Recfm(v b) lrecl('lrecl') blksize(0)'\n    'Execio * diskw' pdd '(finis stem trap.'\n    Address ISPExec 'Browse dataset('pdd'.log)'\n    'free f('pdd') delete'\n  end\n  if count = 0 then Exit 4\n  Exit 0\n\n/* ----------------------------------------------------- *\n * Process ongoing process message                       *\n * ----------------------------------------------------- */\ndisp_progress:\n  \"Control Display Lock\"\n  \"Addpop column(11) row(2)\"\n  \"Display Panel(pdsegcps)\"\n  \"Rempop\"\n  return\n\n/* ------------------------------------------------------- *\n * Setup Filter procedure                                  *\n *                                                         *\n *    if filter is x: then test for member starting with x *\n *       type is 1                                         *\n *    if filter is x/ then test for member with x anywhere *\n *       type is 2                                         *\n *    if filter is /x then test for member with x anywhere *\n *       type is 2                                         *\n *    if filter is x then test for member x                *\n *       type is 3                                         *\n *    if filter has * or %                                 *\n *       type is 4  (uses pdsegmat rexx function)          *\n *    if filter has : within                               *\n *       type is 6  from:to                                *\n *                                                         *\n *    * and OFF turn off Filtering                         *\n *                                                         *\n * variables:                                              *\n *    tfilter = the test filter member                     *\n *    tfilterl = length of tfilter                         *\n *    tfiltert = filter type                               *\n * ------------------------------------------------------- */\nSetup_Filter:\n  filter = strip(filter)\n  if words(filter) > 1 then\n  if left(filter,1) /= '(' then\n  if wordpos(word(filter,1),'SINCE TODAY WEEK MONTH YEAR') = 0 then do\n    dfilter = subword(filter,2)\n    filter = word(filter,1)\n  end\n  else dfilter = null\n  Select\n    When wordpos(word(filter,1),'SINCE TODAY WEEK MONTH YEAR') > 0 then do\n      zcmd = filter\n      call setup_date_filter\n      filter = null\n      zcmd   = null\n    end\n    When translate(filter) = 'OFF' then do\n      filter = null\n      filter_title = null\n      parse value '' with tfilter tfilterl tfiltert ,\n        date_filter date_filter_title\n    end\n    When left(filter,1) = '(' then do\n      tfilter  = filter\n      parse value filter with '('tfilter_list')'\n      tfiltert = 7\n    end\n    When strip(filter) = '*' then do\n      filter = null\n      filter_title = null\n      parse value '' with tfilter tfilterl tfiltert\n    end\n    When right(filter,1) = ':' then do\n      tfilterl = length(filter) -1\n      tfilter  = left(filter,tfilterl)\n      tfiltert = 1\n    end\n    When pos(\":\",filter) > 1 then do\n      tfilter  = filter\n      parse value filter with tfilter_from\":\"tfilter_to .\n      tfiltert = 6\n    end\n    When pos('*',filter) > 0 then do\n      if length(filter) > 1 then\n      tfiltert = 4\n    end\n    When pos('%',filter) > 0 then do\n      if length(filter) > 1 then\n      tfiltert = 4\n    end\n    When pos('/',filter) > 0 then do\n      if pos('/',filter) > 1 then do\n        tfilterl = length(filter) -1\n        tfilter  = left(filter,tfilterl)\n        tfiltert = 2\n      end\n      else do\n        tfilterl = length(filter) -1\n        tfilter  = substr(filter,2)\n        tfiltert = 2\n      end\n    end\n    Otherwise do\n      tfilterl = length(filter)\n      tfilter  = filter\n      tfiltert = 3\n    end\n  end\n  if filter /= null then do\n    filter_title = filter\n    if dfilter /= null then do\n      zcmd = dfilter\n      call setup_date_filter\n      zcmd = null\n    end\n  end\n  return\n\n/* ------------------------------------------------------- *\n * Filter testing using filter type                        *\n *                                                         *\n * return code 0 to bypass                                 *\n *             1 to accept                                 *\n *                                                         *\n * ------------------------------------------------------- */\nProc_Filter:\n  arg filter_member\n  rtn = 1\n  Select\n   /* filter = x: */\n    When tfiltert = 1 then do\n      if left(filter_member,tfilterl) /= tfilter then rtn = 0\n    end\n   /* filter = x/ or /x */\n    When tfiltert = 2 then do\n      if pos(tfilter,filter_member) = 0 then rtn = 0\n    end\n   /* filter = x */\n    When tfiltert = 3 then do\n      if tfilter /= filter_member then rtn = 0\n    end\n   /* filter has * or % */\n    When tfiltert = 4 then do\n      rtn = pdsegmat(filter_member,filter)\n    end\n   /* filter = x:y */\n    When tfiltert = 6 then do\n      rtn = 0\n      if left(filter_member,length(tfilter_from)) >= ,\n        tfilter_from then\n      if left(filter_member,length(tfilter_to)) <= ,\n        tfilter_to then rtn = 1\n    end\n    When tfiltert = 7 then do\n      rtn = 0\n      do mc = 1 to words(tfilter_list)\n        mw = word(tfilter_list,mc)\n        select\n          when filter_member = mw then rtn = 1\n          when pos('/',mw) > 0 then do\n            mw = strip(translate(mw,' ','/'))\n            if pos(mw,filter_member) > 0 then rtn = 1\n          end\n          when pos('*',mw) > 0 then do\n            rc = pdsegmat(filter_member,mw)\n            if rc = 1 then rtn = 1\n          end\n          when pos('%',mw) > 0 then do\n            rc = pdsegmat(filter_member,mw)\n            if rc = 1 then rtn = 1\n          end\n          otherwise nop\n        end\n      end\n    end\n    Otherwise nop\n  end\n  return rtn\n\n/* -------------------------------- *\n | Issue message or save it to stem |\n * -------------------------------- */\nSay_Msg:\n  parse arg pdsegmsg\n  if sysvar('sysispf') = 'ACTIVE'\n  then do\n    trapc = trapc + 1\n    trap.trapc = pdsegmsg\n  end\n  else call say_msg pdsegmsg\n  return\n\n/* -------------------------------------- *\n * Invalid Syntax - tell someone and exit *\n * -------------------------------------- */\nBad_Syntax:\n  zerrsm  = 'Invalid Syntax'\n  zerrlm  = 'Valid syntax requires a from-dsn, a to-dsn,' ,\n    'and an optional member pattern.'\n  call set_msg\n  exit 8\n\n/* -------------------------------------- *\n * Invalid Frompdse                       *\n * -------------------------------------- */\nBad_From:\n  zerrsm  = 'Invalid FromPDSE'\n  zerrlm  = frompdse sysdsn(frompdse)\n  call set_msg\n  exit 8\n\n/* -------------------------------------- *\n * Invalid Topdse                         *\n * -------------------------------------- */\nBad_To1:\n  zerrsm  = 'Invalid ToPDSE'\n  zerrlm  = topdse sysdsn(topdse)\n  call set_msg\n  exit 8\nBad_To2:\n  zerrsm  = 'Invalid ToPDSE'\n  zerrlm  = topdse 'is already allocated so cannot create new.'\n  call set_msg\n  exit 8\n\n/* ----------------------------------------- *\n * Set message either to ISPF or to terminal *\n * ----------------------------------------- */\nSet_MSG:\n  if environment = 1\n  then 'Setmsg msg(isrz002)'\n  else do\n    call say_msg 'Short message: 'zerrsm\n    call say_msg 'Long message: ' zerrlm\n  end\n  return\n\n   /* ------------------- *\n    * Set the Date Filter *\n    * ------------------- */\nsetup_date_filter:\n  Select\n    When word(zcmd,1) = 'SINCE' then do\n      if last_date_filter = zcmd then do\n        date_filter = null\n        date_filter_title = null\n        last_date_filter = null\n      end\n      else do\n        stdate = word(zcmd,2)\n        if left(stdate,1) = '-' then do\n          parse value stdate with '-' sinced\n          date_filter = date('b') - sinced\n          date_filter_title = 'Date: Since' stdate\n          last_date_filter = zcmd\n        end\n        else do\n          x = date_val(stdate)\n          if x > 0 then do\n            zerrsm = 'Invalid Date'\n            zerrlm = stdate 'is an invalid date format.' ,\n              'The date must be in the format of yy/mm/dd.'\n            'Setmsg msg(isrz002)'\n          end\n          else do\n            zerrsm = null\n            parse value stdate with yy'/'mm'/'dd\n            if mm > 12 then do\n              zerrsm = 'Invalid Date'\n              zerrlm = mm 'is an invalid month -' stdate\n              'setmsg msg(isrz002)'\n            end\n            if yy//4 = 0 then mfb = 29\n            else mfb = 28\n            mlimit = '31' mfb '31 30 31 30 31 31 30 31 30 31'\n            if zerrsm = null then\n            if dd > word(mlimit,mm) then do\n              zerrsm = 'Invalid Date'\n              zerrlm = dd 'is an invalid number of days for the' ,\n                'month of' mm '-' stdate\n              'setmsg msg(isrz002)'\n            end\n            if zerrsm = null then do\n              date_filter = date('b',stdate,'o')\n              date_filter_title = 'Date: Since' stdate\n              last_date_filter = zcmd\n            end\n          end\n        end\n      end\n    end\n    When zcmd = 'TODAY' then do\n      if last_date_filter = zcmd then do\n        date_filter = null\n        last_date_filter = null\n      end\n      else do\n        date_filter = date('b')\n        last_date_filter = zcmd\n      end\n    end\n    When zcmd = 'WEEK' then do\n      if last_date_filter = zcmd then do\n        date_filter = null\n        last_date_filter = null\n      end\n      else do\n        date_filter = date('b')-7\n        last_date_filter = zcmd\n      end\n    end\n    When zcmd = 'MONTH' then do\n      if last_date_filter = zcmd then do\n        date_filter = null\n        last_date_filter = null\n      end\n      else do\n        date_filter = date('b')-30\n        last_date_filter = zcmd\n      end\n    end\n    When zcmd = 'YEAR' then do\n      if last_date_filter = zcmd then do\n        date_filter = null\n        last_date_filter = null\n      end\n      else do\n        yy          = left(date('o'),2)\n        date_filter = date('b',yy'/01/01',o)\n        last_date_filter = zcmd\n      end\n    end\n    Otherwise nop\n    zcmd = null\n  end\n  return\n\n/* ----------------------- *\n * Date Validation Routine *\n * ----------------------- */\nDate_Val: Procedure\n  arg tdate\n  parse value tdate with y'/'m'/'d .\n  if datatype(d) /= 'NUM' then return 1\n  if datatype(m) /= 'NUM' then return 1\n  if datatype(y) /= 'NUM' then return 1\n  return 0\n\n/* ------------------------------------ *\n * Process the elapsed time for display *\n * ------------------------------------ */\nProc_eTime:\n  e_time = time(\"E\")\n  parse value e_time with ss \".\" uu\n  numeric digits 6\n  mm = ss % 60 /* get minutes integer */\n  ss = ss // 60 /* get seconds integer */\n  uu = uu // 100 /* get micro seconds integer */\n  etime =  right(mm+100,2)':'right(ss+100,2)'.'right(uu+100,2) '(mm:ss:th)'\n  return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDSEGENM": {"ttr": 183, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00X\\x01\\x16\\x15O\\x01 \\x10/\\t2\\x01 \\x00 \\x00\\x00\\xd7\\xc4\\xe2\\xc5@@@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2016-06-02T00:00:00", "modifydate": "2020-04-11T09:32:58", "lines": 288, "newlines": 32, "modlines": 0, "user": "PDSE"}, "text": "/* --------------------  rexx procedure  -------------------- *\n * Name:      pdsegenm                                        *\n *                                                            *\n * Function:  PDSEGEN ISPF Edit Macro to perform various      *\n *            functions for PDSEGEN                           *\n *                                                            *\n * ISPF Edit macro                                            *\n *                                                            *\n * Options (pulled from ispf variable pdsemopt):              *\n *                                                            *\n *           C   = Copy all records and exit                  *\n *           COM = Compare members                            *\n *           EM  = Edit message                               *\n *           EMV = Edit/View message                          *\n *           F   = Find string (passed as variable pdsegfnd)  *\n *           P   = Paste but first Delete all records         *\n *           PE  = Paste but first Delete all records         *\n *           PN  = Paste but first Delete all Records         *\n *           R   = Copy all records to new member/file        *\n *                 using replace (thanks to a suggestion      *\n *                 from John Kalinich)                        *\n *           S   = Add Stats                                  *\n *           T   = Test and return record count               *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * History:                                                   *\n *            04/11/20 - Correct Compare Parms                *\n *            01/31/20 - Support new Initial Edit Macro       *\n *            05/19/17 - Change to support edit macro parm    *\n *            03/18/17 - Add eXclude on Compare               *\n *            09/28/16 - Add define for compare command       *\n *            09/08/16 - check for dsn with gens before msgs  *\n *            09/06/16 - Reorder options routines alphabetical*\n *                     - Update compare                       *\n *                     - Add Edit Message                     *\n *            09/01/16 - Minor cleanup for compare msg        *\n *            07/27/16 - Remove trace (sigh)                  *\n *            07/22/16 - Add option F (Find)                  *\n *            07/19/16 - Add option S (Stats)                 *\n *            07/16/16 - Add option R (Replace)               *\n *            06/26/16 - Change special to label for message  *\n *                       generated for the compare            *\n *            06/24/16 - Fix to function T                    *\n *            06/24/16 - Add option T to return record count  *\n *            06/24/16 - No longer save version/level since   *\n *                       we have that info from pdsegeni      *\n *                     - support recover/promote if ghost is  *\n *                       empty (from corruption)              *\n *            06/11/16 - Retain caps/num state                *\n *            06/07/16 - Correct compare message              *\n *            06/03/16 - Clean up Compare messages            *\n *            06/03/16 - Updated for more options             *\n *            06/02/16 - Creation                             *\n *                                                            *\n * ---------------------------------------------------------- *\n * Copyright (c) 2017-2020 by Lionel B. Dyck                  *\n * ---------------------------------------------------------- *\n * License:   This EXEC and related components are released   *\n *            under terms of the GPLV3 License. Please        *\n *            refer to the LICENSE file for more information. *\n *            Or for the latest license text go to:           *\n *                                                            *\n *              http://www.gnu.org/licenses/                  *\n *                                                            *\n * ---------------------------------------------------------- */\n address isredit\n 'macro (pdsemopt)'\n address ispexec 'control errors return'\n\n/* ------------------------------------------------------- *\n | Check for an Initial Edit Macro for this dataset suffix |\n * ------------------------------------------------------- */\n address ispexec 'vget (imacvar) profile'\n '(dsn) = dataset'\n dsn    = translate(dsn,' ','.')\n dsnsuf = word(dsn,words(dsn))\n parse value '' with macsuf macro macparm\n if wordpos(dsnsuf,imacvar) > 0 then do\n    wp = wordpos(dsnsuf,imacvar)\n    wc = wordindex(imacvar,wp)\n    imacvar = substr(imacvar,wc)\n    parse value imacvar with macsuf macro macparm '%'\n    end\n\n/* ------------------------------------------------------ *\n | Initial Edit Macro found for this suffix - invoking it |\n * ------------------------------------------------------ */\n if macsuf /= null then do\n    macro macparm\n    end\n\n/* ----------------------------- *\n * Now process the macro options *\n * ----------------------------- */\n Select\n/* ----------------------------- *\n * C = Copy all records and exit *\n * ----------------------------- */\n  When pdsemopt = 'C' then do\n     \"(last)  = linenum .zlast\"\n     if last = 0 then do\n        'caps off'\n        \"line_after .zfirst = '\"blank ghost member\"'\"\n        end\n     'Cut  .zfirst .zlast'\n     '(caps) = caps'\n     '(number) = number'\n     state = caps number\n     address ispexec 'vput (state)'\n     'Cancel'\n     end\n/* --------------------------- *\n * COM = Compare to new member *\n * vget values for compare     *\n * --------------------------- */\n  When pdsemopt = 'COM' then do\n     'Reset'\n     Address ISPExec 'Vget (todsn cmem cfrom cto deltemp)'\n     'Compare' todsn 'x'\n     'L 0'\n     if cto /= 0 then do\n        call outtrap 'x.'\n        Address TSO 'Free DS('todsn') Delete'\n        call outtrap 'off'\n        end\n     msg = left('-',72,'-')\n     call do_msg\n     msg = 'Use Locate label next  or L label next to see' ,\n           'the differences.'\n     call do_msg\n     msg = 'Compare current member' cmem'('cfrom')',\n                       'to' cmem'('cto')'\n     call do_msg\n     if deltemp = 1 then do\n        msg = 'Working in a temporary member. Use Create or Replace' ,\n              'to save updates.'\n        call do_msg\n        end\n     call define_compare\n     end\n/* -------------------------------------------------- *\n * EM - Edit Message                                  *\n *                                                    *\n * Replace the default IBM Edit/View message with one *\n * that reflects the relative generation numbers.     *\n * -------------------------------------------------- */\n When pdsemopt = 'EM' then do\n    Address ISPexec 'vget (mgen agen higen zdsngen)'\n    if zdsngen > 0 then do\n       'Reset'\n       msg = '          Relative gen:' mgen 'Absolute gen:' agen ,\n                       'High gen:' higen\n       call do_msg\n       msg = '-CAUTION- Edit session has been invoked.'\n       call do_msg\n       call define_compare\n       end\n    end\n/* -------------------------------------------------- *\n * EMV - Edit changed to View Message                 *\n *                                                    *\n * Replace the default IBM Edit/View message with one *\n * that reflects the relative generation numbers.     *\n * -------------------------------------------------- */\n When pdsemopt = 'EMV' then do\n    Address ISPexec 'vget (mgen agen higen zdsngen)'\n       if zdsngen > 0 then do\n       'Reset'\n       msg = '       Relative gen:' mgen 'Absolute gen:' agen ,\n                    'High gen:' higen\n       call do_msg\n       msg = '-Note- View session has been invoked -' ,\n             'Changes cannot be saved.'\n       call do_msg\n       call define_compare\n       end\n    end\n/* --------------------------------------------------- *\n * F - Find the string passed in pdsegfnd and return   *\n *     1 if found and 0 if not found in pdsegrc        *\n * --------------------------------------------------- */\n  When pdsemopt = 'F' then do\n       Address ispexec 'vget pdsegfnd'\n       \"Find\" pdsegfnd\n       pdsegrc = rc\n       Address ispexec 'vput pdsegrc'\n       'Cancel'\n       end\n/* -------------------------------------- *\n * P = Paste but first Delete all records *\n * -------------------------------------- */\n  When pdsemopt = 'P' then do\n     'Reset'\n     Address ispexec 'vget (state)'\n     Parse value state with caps number\n     'Caps'    caps\n     'Number'  number\n     'Delete .zfirst .zlast'\n     'Paste after .zfirst'\n     end\n/* --------------------------------------- *\n * PE = Paste but first Delete all records *\n *      then end.                          *\n * --------------------------------------- */\n  When pdsemopt = 'PE' then do\n     'Reset'\n     Address ispexec 'vget (state)'\n     Parse value state with caps number\n     'Caps'    caps\n     'Number'  number\n     'Delete .zfirst .zlast'\n     'Paste after .zfirst'\n     'Save'\n     'End'\n     end\n/* --------------------------------------- *\n * PN = Paste but first Delete all Records *\n *      and set a message for gen 0 replace*\n * --------------------------------------- */\n  When pdsemopt = 'PN' then do\n     'Reset'\n     'Delete .zfirst .zlast'\n     Address ispexec 'vget (state)'\n     Parse value state with caps number\n     'Caps'    caps\n     'Number'  number\n     'Paste after .zfirst'\n     msg = 'Generation 0 has been replaced by a previous' ,\n           'generation.'\n     call do_msg\n     end\n/* --------------------------------------------------- *\n * R - Copy all records in the current member to       *\n *     the target dataset (found in variable pdsecpds) *\n *     using Replace.                                  *\n * --------------------------------------------------- */\n  When pdsemopt = 'R' then do\n       Address ispexec 'vget pdsecpds'\n       \"Replace .zfirst .zlast\" pdsecpds\n       'Cancel'\n       end\n/* --------------------------------------------------- *\n * S - Add Stats to the member                         *\n * --------------------------------------------------- */\n  When pdsemopt = 'S' then do\n       \"Stats On\"\n       'Save'\n       'End'\n       end\n/* ----------------------------- *\n * T = Test for record counts    *\n * ----------------------------- */\n  When pdsemopt = 'T' then do\n     \"(last)  = linenum .zlast\"\n     state = last\n     address ispexec 'vput (state)'\n     'Cancel'\n     end\n/* ----------------------------- *\n * Otherwise issue error message *\n * ----------------------------- */\n  Otherwise do\n     zerrsm  = 'Error'\n     zerrlm  = 'Invalid pdsegenm macro option' pdsemopt\n     zerrhm   = 'PDSEGH0'\n     zerralrm = 'NO'\n     Address ispexec 'setmsg msg(isrz002)'\n     end\n  end\nexit 0\n\n/* -------------------------------------------------- *\n | Do_Msg routine to insert message into edit session |\n * -------------------------------------------------- */\nDo_Msg:\n   \"line_after \" 0 \"= msgline '\"msg\"'\"\n   return\n\n/* --------------------------------------------------- *\n | Define Compare to invoke the Command pdsegcpr       |\n |                                                     |\n | When the Edit session ends the define will be lost. |\n * --------------------------------------------------- */\n Define_Compare:\n 'Define pdsegcpr Macro'\n 'Define Compare alias pdsegcpr'\n return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDSEGENS": {"ttr": 205, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01@\\x00\\x14\\x01\\x16\\x17\\x9f\\x01 4\\x9f\\x06\\x19\\x00\\xb3\\x00?\\x00\\x00\\xd7\\xc4\\xe2\\xc5@@@@@@'", "ispf": {"version": "01.64", "flags": 0, "createdate": "2016-06-27T00:00:00", "modifydate": "2020-12-14T06:19:14", "lines": 179, "newlines": 63, "modlines": 0, "user": "PDSE"}, "text": "/* --------------------  rexx procedure  -------------------- *\n * Name:      PDSEGENS                                        *\n *                                                            *\n * Function:  PDSEGEN Customization Setup Values              *\n *            - This is where each site will set the          *\n *              customizations that are to apply              *\n *                                                            *\n * Syntax:    called by PDSEGEN                               *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * Notes:     Do NOT Change the order of the variables on     *\n *            the return.                                     *\n *                                                            *\n * History:                                                   *\n *            07/26/20 - Default max History Datasets         *\n *            05/06/19 - Change disp_change options           *\n *            04/25/18 - Update for new ispf panels           *\n *            03/30/18 - Make display change option 0         *\n *            11/28/17 - Add display change option            *\n *            11/22/17 - Add default table panel              *\n *            10/27/17 - Make etime default to 0              *\n *            10/05/17 - Make etime default to 1              *\n *            09/12/16 - Add default unit for allocations     *\n *            09/08/16 - Change clean comments and default    *\n *            09/06/16 - Add TempMem value                    *\n *            09/02/16 - Add Prune option                     *\n *            08/16/16 - Add Clean option                     *\n *            07/30/16 - Add default colors                   *\n *            07/01/16 - Remove msgopt                        *\n *            06/27/16 - Creation                             *\n *                                                            *\n * ---------------------------------------------------------- *\n * Copyright (c) 2017-2020 by Lionel B. Dyck                  *\n * ---------------------------------------------------------- */\n\n/* ----------------------------------------------------- *\n * mail setting                                          *\n *                                                       *\n * When set to 1 indicates that xmitip is installed and  *\n * available to use to send the member/generation via    *\n * e-mail.                                               *\n *                                                       *\n * When set to 0 indicates that xmitip is NOT installed. *\n * ----------------------------------------------------- */\n mail   = 1\n\n/* ------------------------------------------------------------ *\n * etime setting                                                *\n *                                                              *\n * this setting enables or disables the display of elapsed time *\n * when the member list table is created initially or           *\n * refreshed.                                                   *\n *                                                              *\n * 0 indicates to disable the display                           *\n * 1 indicates to display the elapsed time                      *\n * ------------------------------------------------------------ */\n etime = 0\n\n/* ------------------------------------------------------------- *\n * higen setting                                                 *\n *                                                               *\n * This setting will enable the display in the member/generation *\n * list of dummy generations.                                    *\n *                                                               *\n * This is NOT recommended.                                      *\n *                                                               *\n * 0 indicates the setting is off                                *\n * 1 indicates the setting is on                                 *\n * ------------------------------------------------------------- */\n higen = 0\n\n/* ------------------------------------------------------------ *\n * Colors                                                       *\n *                                                              *\n * Base_color is the color of the sortable columns that         *\n * are not sorted                                               *\n *                                                              *\n * Sort_color is the color for the column that was just sorted. *\n * ------------------------------------------------------------ */\n base_color = 'green'\n sort_color = 'turq'\n\n/* ------------------------------------------------- *\n * Clean option                                      *\n *                                                   *\n * Set to 1 if APAR OA50214 is installed             *\n * otherwise set to 0                                *\n *                                                   *\n * If APAR is not installed could cause corruption   *\n * to the PDSE                                       *\n * ------------------------------------------------- */\n clean = 1\n\n/* ------------------------------------------------- *\n * Prune option                                      *\n *                                                   *\n * 1 = prune will not prompt if the prune command is *\n *     entered with a number                         *\n * 0 = prune will always prompt                      *\n *                                                   *\n * Note - does not affect RESET prompting            *\n * ------------------------------------------------- */\n prune = 0\n\n/* --------------------------------------------------- *\n * TempMem option                                      *\n *                                                     *\n * this defines the temporary member name to be used   *\n * during a compare if the from member is a non-0 gen. *\n * --------------------------------------------------- */\n tempmem = 'Z$Z@Z9Z8'\n\n/* -------------------------------------------- *\n * Def_Unit                                     *\n *                                              *\n * if null then the system default will be used *\n *                                              *\n * This is the default unit for d/s allocations *\n * -------------------------------------------- */\n def_unit = ''\n\n/* ----------------------------------- *\n | def_panel default settings          |\n |                                     |\n | Use one of the following statements |\n | and delete or comment the others    |\n * ----------------------------------- */\n /* No Action bar panels */\n /* panels with absolute gen */\n /*  pdseged1    1 character sel - 2 digit year */\n /*  pdseged2    1 character sel - 4 digit year */\n /*  pdseged3    9 character sel - 2 digit year */\n /*  pdseged4    9 character sel - 4 digit year */\n /* panels without absolute gen */\n /*  pdseged5    1 character sel - 2 digit year */\n /*  pdseged6    1 character sel - 4 digit year */\n /*  pdseged7    9 character sel - 2 digit year */\n /*  pdseged8    9 character sel - 4 digit year */\n /* Action bar panels */\n /* panels with absolute gen */\n /*  pdsegeda    1 character sel - 2 digit year */\n /*  pdsegedb    1 character sel - 4 digit year */\n /*  pdsegedc    9 character sel - 2 digit year */\n /*  pdsegedd    9 character sel - 4 digit year */\n /* panels without absolute gen */\n /*  pdsegede    1 character sel - 2 digit year */\n /*  pdsegedf    1 character sel - 4 digit year */\n /*  pdsegedg    9 character sel - 2 digit year */\n /*  pdsegedh    9 character sel - 4 digit year */\n\n /* Selected Default */\n def_panel = 'pdsegeda'    /* 1 character sel - 2 digit year */\n\n/* -------------------------------------------------- *\n | Display Change option                              |\n |                                                    |\n | Display only when the pdsegver (version) changes.  |\n |                                                    |\n | - Set to 0 to bypass the Change tutorial display   |\n | - Set to 1 to display the Change tutorial if the   |\n |   version.release has changed.                     |\n | - Set to 2 to display the Change tutorial if the   |\n |   version.release.modication has changed           |\n * -------------------------------------------------- */\n disp_change = 0\n\n/* ------------------------------------------------ *\n | Default Max Number of History Datasets to Retain |\n | - may be changed by the user via set             |\n * ------------------------------------------------ */\n maxhist = 100\n\n/* ---------------------------- *\n * DO NOT CHANGE THIS STATEMENT *\n * ---------------------------- */\n return mail '/' etime '/' higen '/' base_color '/' sort_color ,\n        '/' clean '/' prune '/' tempmem '/' def_unit ,\n        '/' def_panel '/' disp_change '/' maxhist\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PDSEGENX": {"ttr": 173, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x0f\\x00'\\x01\\x16\\x17/\\x01\\x17'\\x7f\\x104\\x00)\\x00\\x1f\\x00\\x00\\xd7\\xc4\\xe2\\xc5@@@@@@\"", "ispf": {"version": "01.15", "flags": 0, "createdate": "2016-06-20T00:00:00", "modifydate": "2017-10-04T10:34:27", "lines": 41, "newlines": 31, "modlines": 0, "user": "PDSE"}, "text": "/* --------------------  rexx procedure  -------------------- *\n * Name:      pdsegenx                                        *\n *                                                            *\n * Function:  dynamically allocate the pdsegen libraries      *\n *            for testing purposes                            *\n *                                                            *\n * Syntax:    %pdsegenx pdse-library filter                   *\n *                                                            *\n *            pdse-library is optional and if not provided    *\n *            will present a prompt to the user               *\n *                                                            *\n *            filter is optional                              *\n *                                                            *\n * Note:      hlq. will be changed by the $RECV exec to       *\n *            match what you restore the libraries to         *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * History:                                                   *\n *            08/31/16 - Add filter                           *\n *            07/13/16 - Add stack to the libdef              *\n *            06/20/16 - Creation                             *\n *                                                            *\n * ---------------------------------------------------------- *\n * Copyright (c) 2017 by Lionel B. Dyck                       *\n * ---------------------------------------------------------- */\n arg pdselib filter\n\n exec   = \"'hlq..exec'\" /* changed during receive */\n load   = \"'hlq..load'\" /* changed during receive */\n panels = \"'hlq..panels'\" /* changed during receive */\n\n 'altlib activate dataset('exec') application(exec)'\n address ispexec\n 'libdef ispllib dataset id('load') stack'\n 'libdef ispplib dataset id('panels') stack'\n 'Select cmd(%pdsegen' pdselib filter ') scrname(pdsegen)'\n 'libdef ispllib'\n 'libdef ispplib'\n address tso\n 'altlib deactivate application(exec)'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDSEGFND": {"ttr": 187, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x15\\x00\\x12\\x01\\x16!_\\x01 \\x17?\\x10@\\x00\\xae\\x00p\\x00\\x00\\xd7\\xc4\\xe2\\xc5@@@@@@'", "ispf": {"version": "01.21", "flags": 0, "createdate": "2016-08-02T00:00:00", "modifydate": "2020-06-21T10:40:12", "lines": 174, "newlines": 112, "modlines": 0, "user": "PDSE"}, "text": "/* --------------------  rexx procedure  -------------------- *\n * Name:      pdsegfnd                                        *\n *                                                            *\n * Function:  Find string in PDSEGEN backup data set with     *\n *            SuperC Search-For. Replace @nnnnnnn generated   *\n *            name with real name and relative generation     *\n *            in the Search-For output (NEWDD).               *\n *                                                            *\n *            Also works in any PDS/PDSE without Member Gens. *\n *                                                            *\n * Syntax:    %pdsegfnd pdsegen-backupdsn 'string'            *\n *         or %pdsegfnd pdsegen-backupdsn 'string' '/\\/\\'     *\n *                                                            *\n *            if the /\\/\\ option is present then the ispf     *\n *            variable mhits will be created with the member  *\n *            names where the search was successful and will  *\n *            not view the superc report.                     *\n *                                                            *\n *            ISPF Variable FTMEMS contains a list of         *\n *            members if member filtering was active or       *\n *            is null if no filtering.                        *\n *                                                            *\n * Author:    John Kalinich, Lionel Dyck                      *\n *                                                            *\n * History:                                                   *\n *            08/07/19 - Add short/long message               *\n *            08/06/19 - enable use of SuperC in non-MG PDSes *\n *                     - return members with hit (lbd)        *\n *            02/23/18 - change to use ispexec select         *\n *            08/02/16 - created                              *\n * ---------------------------------------------------------- */\n  arg pdsedsn string\n  parse value '' with null ispf\n  if right(string,4) = '/\\/\\' then do\n    parse value string with string '/\\/\\'\n    string = strip(string)\n    ispf = 1\n  end\n  Address ISPExec\n  if sysdsn(pdsedsn) /= 'OK' then do\n    zedsmsg = null\n    zedlmsg = 'Error.' pdsedsn sysdsn(pdsedsn)\n    'setmsg msg(isrz001)'\n    return\n  end\n  if left(pdsedsn,1) = \"'\" then do\n    wdsn = substr(pdsedsn,2,length(pdsedsn)-2)\n  end\n  else do\n    if sysvar('syspref') = null then hlq = sysvar('sysuid')\n    else hlq = sysvar('syspref')\n    wdsn = hlq'.'pdsedsn\n  end\n\nProcess_Find:\n\n  call read_$index\n  call superc_srchfor\n  exit\n\nRead_$Index:\n  @names. = null\n  if sysdsn(\"'\"wdsn\"($index)'\") /= \"OK\" then do\n    Address ISPExec\n    \"dsinfo dataset('\"wdsn\"')\"\n    if zdsngen = 0 then     /* allow non member generations */\n    return\n    zedsmsg = 'Error'\n    zedlmsg = 'Error.' \"'\"wdsn\"($index)'\" sysdsn(\"'\"wdsn\"($index)'\")\n    Address ISPExec\n    'setmsg msg(isrz001)'\n    exit\n  end\n  Address TSO\n  \"alloc f($index) da('\"wdsn\"($index)') shr reuse\"\n  'execio * diskr $index (stem index. finis'\n  do im = 1 to index.0\n    parse value index.im with backup_name real_name abs_gen rel_gen .\n    @names.backup_name = Left(real_name,8) right(rel_gen,5)\n  end\n  'free f($index)'\n  return\n\nSuperC_Srchfor:\n  Address ISPExec\n  'vget (zscreen) shared'\n  pdstname = 'RESULT'zscreen\n  Address TSO\n  x = outtrap('delete.','*')\n  'delete srchfor.'pdstname\n  x= outtrap('off')\n  'alloc f(sysin) unit(vio) new reuse space(1,1) tracks',\n    'lrecl(80) recfm(f b) blksize(0) dsorg(ps)'\n  if pos(\"'\",string) > 0 then\n  push \"SRCHFOR \"string\n  else\n  push \"SRCHFOR '\"string\"'\"\n  address ispexec 'vget (ftmems)'\n  if strip(ftmems) /= '' then\n  do mi = 1 to words(ftmems)\n    queue \"SELECT\" word(ftmems,mi)\n  end\n  queue \"\"\n  'execio * diskw sysin (finis'\n  'delstack'\n  \"alloc f(newdd) da('\"wdsn\"') shr reuse\"\n  'alloc f(outdd) da(srchfor.'pdstname') new reuse unit(sysallda)',\n    'space(15,15) tracks recfm(f b a) lrecl(132) blksize(0) dsorg(ps)'\n  parm = 'SRCHCMP,ANYC,NOPRTCC'\n  Address ISPExec 'Select pgm(isrsupc) Parm('parm')'\n  'execio * diskr outdd (stem pds. finis'\n  Address TSO\n  'alloc f(sysin) da(*) shr reuse'\n  'free  f(newdd)'\n  'free  f(outdd) delete'\n\n  do fi = 1 to pds.0\n    if substr(pds.fi,2,1) = '@' then\n    do\n      target = substr(pds.fi,2,8)\n      repl_name = left(@names.target,8)\n      repl_gen  = substr(@names.target,10,5)\n      pds.fi = ' 'target repl_name repl_gen '    ' substr(pds.fi,30,45)\n    end\n  end\n\n  if sysdsn(\"'\"wdsn\"($index)'\") /= \"OK\" then do\n    if ispf = 1 then do\n      mhits = ''\n      do i = 1 to pds.0\n        if pos('FOUND -',pds.i) = 0 then iterate\n        mhits = mhits word(pds.i,1)\n      end\n      mhits = strip(mhits)\n      address ispexec 'vput (mhits)'\n      return\n    end\n  end\n\n  Address TSO\n  'alloc f('dd') unit(vio) new reuse space(10,10) tracks',\n    'lrecl(255) recfm(f b) blksize(0) dsorg(ps)'\n  'execio * diskw' dd '(finis stem pds.'\n  Address ISPExec\n  'lminit dataid(id) ddname('dd') enq(exclu)'\n  if rc \u00ac= 0 then do\n    zedsmsg = 'Error'\n    zedlmsg = 'Error.  LMINIT failed for VIO output file'\n    'setmsg msg(isrz001)'\n    exit\n  end\n  do x = pds.0 to 1 by -1\n    if pos('MEMBERS-W/LNS',pds.x) > 0 then leave\n  end\n  x = x + 1\n  hits = substr(pds.x,26,10)\n  if datatype(hits) /= 'NUM' then hits = 0\n  zedsmsg = 'hits' hits+0\n  zedlmsg = 'Search resulted in' hits+0 'hits.'\n  'Setmsg msg(isrz001)'\n  'view   dataid('id')'\n  'lmfree dataid('id')'\n  if ispf = 1 then do\n    mhits = ''\n    do i = 1 to pds.0\n      if pos('FOUND -',pds.i) = 0 then iterate\n      mhits = mhits word(pds.i,1)\n    end\n    mhits = strip(mhits)\n    address ispexec 'vput (mhits)'\n    return\n  end\n  return\n/* End of PDSEGFND exec */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDSEGRST": {"ttr": 177, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x16\\x00C\\x01\\x17&_\\x01\\x19\\x06?\\x07\\x06\\x01\\x86\\x00[\\x00\\x00\\xd7\\xc4\\xe2\\xc5@@@@@@'", "ispf": {"version": "01.22", "flags": 0, "createdate": "2017-09-22T00:00:00", "modifydate": "2019-03-04T07:06:43", "lines": 390, "newlines": 91, "modlines": 0, "user": "PDSE"}, "text": "/* --------------------  rexx procedure  -------------------- *\n | Name:      PDSEGRST                                        |\n |                                                            |\n | Function:  PDSEGEN Selective Restore                       |\n |                                                            |\n | Syntax:    %pdsegrst backup-dsn target-dsn mbr gen / NEW   |\n |                                                            |\n |            backup-dsn   PDSEGEN Backup PDS                 |\n |            target-dsn   PDS/PDSE to restore to             |\n |                         ** must exist **                   |\n |            mbr          Member name or member pattern      |\n |            gen          Absolute or Relative Gen to        |\n |                         restore                            |\n |                                                            |\n |            / NEW        allocate the target PDSE           |\n |                                                            |\n |            mbr is optional - default is all                |\n |            gen is optional - default is all generations    |\n |            / NEW is optional and may be any non-blank char |\n |                                                            |\n | Usage Notes:                                               |\n |           1. If restoring to a PDS or PDSE without         |\n |              generations then only the base (gen 0)        |\n |              will be restored.                             |\n |           2. If gen is not specified then all generations  |\n |              will be restored starting with the oldest to  |\n |              the newest. This retains the relative         |\n |              generations number.                           |\n |           3. The absolute generation number cannot be      |\n |              retained on restoration.                      |\n |           4. If the member already exists in the target    |\n |              then the existing member/generations will     |\n |              be pushed up the relative generation range    |\n |              until they roll out.                          |\n |           5. If the option / NEW is specified then the     |\n |              target PDSE will be allocated using the DCB   |\n |              and space of the backup PDS/PDSE and using    |\n |              the MAXGEN found in the Backup $ALLOC member  |\n |                                                            |\n | Dependencies:                                              |\n |           1. The PDSEGEN Backup PDS Must have the $INDEX   |\n |              member.                                       |\n |           2. The target PDS must be pre-allocated          |\n |           3. The PDSEGMAT REXX function module must be     |\n |              accessible for pattern matching on the        |\n |              member name if a pattern is used              |\n |           4. Must be run under ISPF or ISPF in Batch       |\n |              as ISPF Services are used                     |\n |                                                            |\n | Author:    Lionel B. Dyck                                  |\n |                                                            |\n | History:  (most recent on top)                             |\n |            03/04/19 - Add numerics for maxgen check        |\n |            11/24/17 - Update to support changed PDSEGENS   |\n |            09/27/17 - Add Progress Meter                   |\n |            09/25/17 - Correct testing for gen selection    |\n |            09/22/17 - Creation                             |\n |                                                            |\n * ---------------------------------------------------------- */\n\n arg parms\n parse value parms with fromdsn targetds mbr gen '/' target_new\n\n parse value '' with null msgnum ispf\n env      = sysvar('sysenv')\n pdsedd   = 'PRST'random(9999)\n mc       = 0\n rcount   = 0\n msgnum   = 0\n zerrhm   = 'PDSEGH0'\n zerralrm = 'NO'\n target_new = strip(target_new)\n\n/* --------------- *\n * Start our timer *\n * --------------- */\n x = time('r')\n\n if env   = 'FORE' then  do\n    ispf = 1\n    end\n\n call do_say 'PDSEGRST Processing on:' date() 'at' time()\n call do_say ' '\n call do_say 'Calling parameters:'\n call do_say '%'sysvar('sysicmd') parms\n call do_say ' '\n call do_say 'Input Backup PDSE:  ' fromdsn\n call do_say 'Outpput Target PDSE:' targetds\n call do_say 'Member (mask):      ' mbr\n call do_say 'Generation:         ' gen\n call do_say 'New Flag:           ' target_new\n call do_say ' '\n\n/* --------------------------------------------------- *\n | Validate that the fromdsn and targetds exist        |\n | and that the $INDEX member exists in the fromdsn |\n * --------------------------------------------------- */\n\n if sysdsn(fromdsn) /= 'OK' then do\n    call do_say 'Backup Dataset Name error:'\n    call do_say \"Dataset:\" fromdsn\n    call do_say \"Error message:\" sysdsn(fromdsn)\n    call do_say 'Try again...'\n    call exit\n    end\n\n if target_new = null then do\n    if sysdsn(targetds) /= 'OK' then do\n       call do_say 'Target Dataset Name error:'\n       call do_say \"Dataset:\" targetds\n       call do_say \"Error message:\" sysdsn(targetds)\n       call do_say 'Try again...'\n       call exit\n       end\n       end\n else do\n    if sysdsn(targetds) = 'OK' then do\n       call do_say 'Target Dataset Name Exists and NEW was specified.'\n       call do_say 'Either remove the' target_new '(New) option or change'\n       call do_say 'the target dataset name.'\n       call do_say 'Try again...'\n       call exit\n       end\n       end\n\n if left(fromdsn,1) = \"'\"\n    then bdsn = \"'\"substr(fromdsn,2,length(fromdsn)-2)\"($INDEX)'\"\n    else bdsn = fromdsn\"($INDEX)\"\n if sysdsn(bdsn) /= 'OK' then do\n    call do_say 'Backup Dataset $INDEX Member Missing'\n    call do_say \"Dataset:\" bdsn\n    call do_say \"Error message:\" sysdsn(bdsn)\n    call do_say 'Try again...'\n    call exit\n    end\n\n/* -------------------------- *\n * Get defaults from PDSEGENS *\n * -------------------------- */\n x = pdsegens()\n parse value x with  x '/' x '/' x ,\n              '/' x '/' x '/' x ,\n              '/' x '/' x '/' def_unit '/' x\n def_unit     = strip(def_unit)\n if def_unit /= null then\n    def_unit = 'unit('def_unit')'\n\n/* ------------------------------------------------ *\n | If NEW then read in the $ALLOC and get DCB/Space |\n * ------------------------------------------------ */\n if target_new /= null then do\n if left(fromdsn,1) = \"'\"\n    then adsn = \"'\"substr(fromdsn,2,length(fromdsn)-2)\"($ALLOC)'\"\n    else adsn = fromdsn\"($ALLOC)\"\n 'Alloc f('pdsedd') shr reuse ds('adsn')'\n 'Execio * diskr' pdsedd '(finis stem $alloc.'\n 'Free  f('pdsedd')'\n  parse value $alloc.1 with .'('amgen')' .\n  Numeric Digits 10\n  CVT      = C2D(Storage(10,4))\n  CVTDFA   = C2D(Storage(D2X(CVT + 1216),4))   /* cvt + 4c0 */\n  DFAMGEN  = C2D(Storage(D2X(cvtdfa + 76),4))  /* dfa + 4c */\n  if amgen > dfamgen then do\n     $alloc.1 = 'MAXGEN('dfamgen')'\n     call do_say 'The requested MAXGEN('amgen') is greater than' ,\n                 'the current system'\n     call do_say 'MAXGENS_LIMIT of' dfamgen'.' ,\n                 'The restore will use the system MAXGENS_LIMIT.'\n     call do_say 'Warning: It is possible that generations beyond the' ,\n                 dfamgen' limit will be'\n     call do_say 'lost during the restore process.'\n     call do_say ' '\n     end\n  'Alloc f('pdsedd') ds('targetds') like('fromdsn')' $alloc.1 ,\n    'dsntype(library,2)' def_unit\n  call do_say 'Allocating target PDSE with' $alloc.1\n  'Free  f('pdsedd')'\n  end\n\n/* ------------------------------- *\n | Read in the Backup Member Index |\n * ------------------------------- */\n 'Alloc f('pdsedd') shr reuse ds('bdsn')'\n 'Execio * diskr' pdsedd '(finis stem index.'\n 'Free  f('pdsedd')'\n\n Address ISPExec\n 'Control Errors Return'\n\n/* ------------------------------------ *\n * Setup for Progress Indicator Display *\n * ------------------------------------ */\n division = 10\n incr = (index.0 % division) + 1\n progc = null\n perc# = 0\n\n/* --------------------------------------------- *\n | If ISPF active (foreground) do progress popup |\n * --------------------------------------------- */\n if ispf = 1 then do\n    prog = 'Preparing...'\n    \"Control Display Lock\"\n    'addpop'\n    'display panel(pdsegpr)'\n    'rempop'\n    end\n\n/* --------------------------------------- *\n | Define the From and To Datasets to ISPF |\n * --------------------------------------- */\n \"lminit dataid(fromid) dataset(\"fromdsn\")\"\n \"lminit dataid(toid)   dataset(\"targetds\")\"\n\n/* ----------------------------------------- *\n | Process the $INDEX for members to restore |\n * ----------------------------------------- */\n dcount = 0\n do in = 1 to index.0\n    parse value index.in with backup_member real_member abs_gen rel_gen .\n    dcount = dcount + 1\n    call disp_progress\n    if mbr = null then call Restore\n    testmrc = test_mask(real_member mbr)\n    if testmrc = 0 then iterate\n    hit = 1\n    if gen /= null then do\n       if gen < 0\n          then if gen /= rel_gen then hit = 0\n       if gen > 0\n          then if gen /= abs_gen then hit = 0\n       if gen = 0\n          then if gen /= abs_gen then hit = 0\n       end\n    if hit = 1 then call Restore\n    end\n\n/* ---------------- *\n | All done so exit |\n * ---------------- */\n Exit:\n if msgnum > 0 then do\n    call proc_etime\n    call do_say ' '\n    call do_say 'Total members/generations restored:' rcount\n    call do_say 'Elapsed Time:                      ' etime\n    call do_say 'PDSEGRST Processing Completed on:  ' date() 'at' time()\n    end\n call Display_Msgs\n \"lmfree dataid(\"fromid\")\"\n \"lmfree dataid(\"toid\")\"\n Exit 0\n\n/* ---------------- *\n * Display progress *\n * ---------------- */\n Disp_Progress:\n if dcount//incr = 0 then do\n    progc = progc'**'\n    perc# = perc# + division\n    perc = perc#\"%\"\n    prog = progc '('perc')'\n    \"Control Display Lock\"\n    'addpop'\n    'display panel(pdsegpr)'\n    'rempop'\n    end\n return\n\n/* --------------- *\n | Restore Routine |\n * --------------- */\nRestore:\n  call do_say 'Restoring member' left(backup_member,8) ,\n              'to member' left(real_member,8) ,\n              'with relative generation' rel_gen\n  \"lmcopy fromid(\"fromid\") todataid(\"toid\")\" ,\n         \"frommem(\"backup_member\") tomem(\"real_member\") replace\"\n  if rc > 0 then do\n    call do_say 'LMCopy failure rc:' rc\n    call do_say zerrsm\n    call do_say zerrlm\n    call exit\n  end\n  rcount = rcount + 1\n  return\n\n/* ----------------------- *\n | Format the Elapsed Time |\n * ----------------------- */\n Proc_eTime:\n    e_time = time(\"E\")\n    parse value e_time with ss \".\" uu\n    numeric digits 6\n    mm = ss % 60 /* get minutes integer */\n    ss = ss // 60 /* get seconds integer */\n    uu = uu // 100 /* get micro seconds integer */\n    etime =  right(mm+100,2)':'right(ss+100,2)'.'right(uu+100,2) '(mm:ss:th)'\n    return\n\n/* -------------------------------------------- *\n | Do_Say routine - put the message into a stem |\n * -------------------------------------------- */\n do_say:\n parse arg message\n msgnum = msgnum + 1\n msgs.msgnum = message\n return\n\n/* --------------------------------------------------------- *\n | Test_Mask routine used when the command contains a member |\n | or member with mask.                                      |\n |                                                           |\n | Arguments passed: member-name mask                        |\n | Return code:  0 - no match                                |\n |               1 - match                                   |\n * --------------------------------------------------------- */\nTest_Mask: procedure\n  arg string mask\n/* ----------------------- *\n | Define the type of mask |\n |                         |\n | 0 = no mask             |\n | 1 = mask % or *         |\n | 2 = pattern with :      |\n | 3 = pattern with /      |\n * ----------------------- */\n  hit = 0\n  if pos('*',mask) > 0 then hit = 1\n  if pos('%',mask) > 0 then hit = 1\n  if pos(':',mask) > 0 then hit = 2\n  if pos('/',mask) > 0 then hit = 3\n\n  Select\n    When hit = 1 then do\n      rtn = pdsegmat(string,mask)\n      return rtn\n    end\n    When hit = 2 then do\n      p1 = pos(':',mask)\n      tname = left(mask,p1-1)\n      if tname = left(string,p1-1) then return 1\n      else return 0\n    end\n    When hit = 3 then do\n      tname = strip(translate(mask,' ','/'))\n      if pos(tname,string) > 0 then return 1\n      else return 0\n    end\n    When hit = 0 then do\n      if mask = string then return 1\n      else return 0\n    end\n    Otherwise return 0\n  End\n  return\n\n/* ----------------------------------- *\n | Display messages or Browse messages |\n * ----------------------------------- */\n Display_Msgs:\n if ispf /= 1 then\n    if msgnum > 0 then\n       do i = 1 to msgnum\n          say msgs.i\n          end\n if ispf = 1 then\n if msgnum > 0 then do\n    if sysvar('syspref') = null\n       then temp = sysvar('sysuid')'.pdsegbak.report'\n       else temp = sysvar('syspref')'.pdsegbak.report'\n    Address TSO\n    if sysdsn(\"'\"temp\"'\") = 'OK' then do\n       call outtrap 'x.'\n       Address TSO \"Delete '\"temp\"'\"\n       call outtrap 'off'\n       end\n    \"Alloc f(\"ddn\") ds('\"temp\"') new spa(1,1) tr\" ,\n      \"recfm(f b) lrecl(80) blksize(6160)\"\n    msgs.0 = msgnum\n    \"Execio * diskw\" ddn \"(finis stem msgs.\"\n    Address TSO \"Free f(\"ddn\")\"\n    Address ISPExec\n    \"Browse dataset('\"temp\"')\"\n    call outtrap 'x.'\n    Address TSO \"Delete '\"temp\"'\"\n    call outtrap 'off'\n    end\n Return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDSEGVAL": {"ttr": 175, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00Q\\x01\\x16!O\\x01\\x171\\x0f\\x10\\x01\\x00\\x85\\x00\\\\\\x00\\x00\\xd7\\xc4\\xe2\\xc5@@@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2016-08-01T00:00:00", "modifydate": "2017-11-06T10:01:51", "lines": 133, "newlines": 92, "modlines": 0, "user": "PDSE"}, "text": "/* --------------------  rexx procedure  -------------------- *\n * Name:      pdsegval                                        *\n *                                                            *\n * Function:  Validate the PDSE using IEBPDSE                 *\n *                                                            *\n * Syntax:    %pdsegval pdsedsn clean                         *\n *                                                            *\n *            pdsedsn is the pdse dataset name                *\n *            clean forces pending delete cleanup             *\n *                                                            *\n * Author:    John Kalinich                                   *\n *            Lionel B. Dyck                                  *\n *                                                            *\n * History:                                                   *\n *            11/06/17 - Enhance the IEBPDSE Report           *\n *                     - Use Browse instead of View for report*\n *            09/12/16 - Removed parm of flush unless Clean   *\n *                       is specified. See OA50214.           *\n *            09/08/16 - Changed call to IEBPDSE and added    *\n *                       Parm of FLUSH                        *\n *                     - Change allocation for report dd      *\n *            08/23/16 - Add sysin dd allocation to make      *\n *                       sure it is dummy                     *\n *            08/16/16 - Update by Lionel to add optional     *\n *                       parm of PERFORMPENDINGDELETE         *\n *                       which forces a cleanup               *\n *            08/01/16 - Minor changes by Lionel Dyck         *\n *            08/01/16 - Creation                             *\n *                                                            *\n * ---------------------------------------------------------- */\n arg pdsedsn clean\n\n/* --------------- *\n * Define defaults *\n * --------------- */\n zerrhm   = 'PDSEGH0'\n zerralrm = 'NO'\n null     = ''\n\n/* ---------------------------- *\n * Test for a PDSE dataset name *\n * ---------------------------- */\n Address ISPExec\n if sysdsn(pdsedsn) /= 'OK' then do\n    zerrsm = null\n    zerrlm = 'Error.' pdsedsn sysdsn(pdsedsn)\n   'setmsg msg(isrz002)'\n   return\n   end\n\n/* ----------------------------------- *\n * Fixup PDSE dataset name if required *\n * ----------------------------------- */\n if left(pdsedsn,1) = \"'\" then do\n    wdsn = substr(pdsedsn,2,length(pdsedsn)-2)\n    end\n else do\n      if sysvar('syspref') = null then hlq = sysvar('sysuid')\n                                else hlq = sysvar('syspref')\n      wdsn = hlq'.'pdsedsn\n      end\n\n/* -------------------------------------------- *\n * Check for the clean option and if found then *\n * set the parm to PERFORMPENDINGDELETE         *\n * -------------------------------------------- */\n if clean /= null\n    then parm = 'FLUSH,PERFORMPENDINGDELETE'\n    else parm = ''\n\n/* -------------------- *\n * Call IEBPDSE routine *\n * -------------------- */\n call iebpdse\n exit\n\n/* --------------- *\n * IEBPDSE routine *\n * --------------- */\nIEBpdse:\n/* ------------------------------------- *\n * Build temp dataset for IEBPDSE Report *\n * ------------------------------------- */\n 'vget (zscreen) shared'\n result = 'RESULT'zscreen\n\n/* ------------ *\n * Call IEBPDSE *\n * ------------ */\n Address TSO\n x = outtrap('delete.','*')\n 'delete iebpdse.'result\n x= outtrap('off')\n \"alloc f(syslib) da('\"wdsn\"') shr reuse\"\n 'alloc f(sysprint) new reuse unit(sysallda)',\n   'space(1,1) tracks'\n 'alloc f(sysin) dummy reuse'\n \"call *(iebpdse) '\"parm\"'\"\n\n 'Execio * diskr sysprint (finis stem sysp.'\n rpt.1 = center('IEBPDSE Report',50)\n rpt.2 = center('Date:' date() 'Time:' time(),50)\n rpt.3 = center(\"PDSE:\" wdsn,50)\n if parm = null then parm = 'None'\n rpt.4 = center(\"Parms:\" parm,50)\n rpt.5 = center(\"System:\" mvsvar('sysname'),50)\n rpt.6 = ' '\n c = 6\n do i = 1 to sysp.0\n    c = c + 1\n    rpt.c = sysp.i\n    end\n rpt.0 = c\n 'Execio * diskw sysprint (finis stem rpt.'\n\n/* ------------------------------- *\n * Display the report using Browse *\n * ------------------------------- */\n Address ISPExec\n 'lminit dataid(id) ddname(sysprint) enq(exclu)'\n if rc \u00ac= 0 then do\n    zerrsm = 'Error'\n    zerrlm = 'Error.  LMINIT failed for SYSPRINT'\n   'setmsg msg(isrz002)'\n   exit\n   end\n 'Browse   dataid('id')'\n 'lmfree dataid('id')'\n\n Address TSO\n'free  f(syslib sysprint)'\n'alloc f(sysin) ds(*) reuse'\n return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDSEGVER": {"ttr": 195, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00&\\x01\\x17\"o\\x01 4\\x9f\\x06\\x17\\x00 \\x00\\x11\\x00\\x00\\xd7\\xc4\\xe2\\xc5@@@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2017-08-14T00:00:00", "modifydate": "2020-12-14T06:17:26", "lines": 32, "newlines": 17, "modlines": 0, "user": "PDSE"}, "text": "/* --------------------  rexx procedure  -------------------- */\n ver = '5.8.5'\n return ver\n/* Name:      PDSEGVER                                        |\n |                                                            |\n | Function:  Set the version for PDSEGEN elements            |\n |                                                            |\n | Syntax:    ver = pdsegver()                                |\n |                                                            |\n | Usage Notes: called by pdsegen elements                    |\n |                                                            |\n | Author:    Lionel B. Dyck                                  |\n |                                                            |\n | History:  (most recent on top)                             |\n |            12/14/20 - 5.8.4 - Reflect updates to package   |\n |            10/27/20 - 5.8.4 - Reflect updates to package   |\n |            09/17/20 - 5.8.3 - Reflect updates to package   |\n |            08/11/20 - 5.8.2 - Reflect updates to package   |\n |            08/06/20 - 5.8.1 - Reflect updates to package   |\n |            08/03/20 - 5.8.0 - Reflect updates to package   |\n |            08/02/20 - 5.7.9 - Reflect updates to package   |\n |            07/30/20 - 5.7.8 - Reflect updates to package   |\n |            07/26/20 - 5.7.7 - Reflect updates to package   |\n |            07/09/20 - 5.7.6 - Reflect updates to package   |\n |            06/26/20 - 5.7.5 - Reflect updates to package   |\n |            06/03/20 - 5.7.4 - Reflect updates to package   |\n |            06/02/20 - 5.7.3 - Reflect updates to package   |\n |            06/01/20 - 5.7.2 - Reflect updates to package   |\n |            05/27/20 - 5.7.1 - Reflect updates to package   |\n |            04/13/20 - 5.7.0 - Reflect updates to package   |\n |                                                            |\n * ---------------------------------------------------------- */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PG": {"ttr": 203, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00)\\x01\\x16\\x17o\\x01\\x17\\x16_\\x12\\x01\\x00\\x03\\x00\\x03\\x00\\x00\\xd7\\xc4\\xe2\\xc5@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-06-24T00:00:00", "modifydate": "2017-06-14T12:01:29", "lines": 3, "newlines": 3, "modlines": 0, "user": "PDSE"}, "text": "/* rexx */\narg options\n'%pdsegen' options\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TRYIT": {"ttr": 199, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01+\\x007\\x01\\x17\\x17\\x1f\\x01 \\x19_\\x08\\x03\\x04\\x1e\\x03\\xcb\\x00\\x00\\xd7\\xc4\\xe2\\xc5@@@@@@'", "ispf": {"version": "01.43", "flags": 0, "createdate": "2017-06-20T00:00:00", "modifydate": "2020-07-13T08:03:37", "lines": 1054, "newlines": 971, "modlines": 0, "user": "PDSE"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT969/CBT.V500.FILE969.PDS/EXEC.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT969/CBT.V500.FILE969.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}