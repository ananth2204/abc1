{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012503000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 411502, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 9, "INMDSNAM": "CBT.V500.FILE623.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE623.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x07\\x13'", "DS1TRBAL": "b'\\x03\\xb8'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\x8d\\x00\\x0c\\x04\\x8e\\x00\\x04\\x00\\x08'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04H\\x00\\x00\\x01\\x06\\x11_\\x01\\x06\\x11_\\tG\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf2@@@'", "ispf": {"version": "04.72", "flags": 0, "createdate": "2006-04-25T00:00:00", "modifydate": "2006-04-25T09:47:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-472"}, "text": "REGULAR CBT TAPE - VERSION 472    FILE:  623\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT472.FILE623\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 19 MEMBERS COUNTED; CUMULATIVE SIZE IS 3,378 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   04/25/06    09:47:07    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE1": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00#\\x01\\x03\\x11_\\x01\\x06\\x11_\\tF\\x005\\x00:\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-04-25T00:00:00", "modifydate": "2006-04-25T09:46:23", "lines": 53, "newlines": 58, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject: AUTOIPL Package: Automatic IPL and Shutdown.\nDate: Thu, 24 Apr 2003 08:04:52 -0400\nFrom: \"Zhou, Guanghui\" <guanghui.zhou@sobeys.com>\nTo: 'Sam Golob' <sbgolob@attglobal.net>\n\nHi Sam,\n\nI have designed a package named AUTOIPL, to automate system IPL\nand shutdown procedure.  This package is running on our production\nsystems for a while.  I would like to share this package on\nCBTTAPE.\n\nHere are the features of this package:\n1. Support automatic shutdown procedure.\n    . Single command (S SHUTDOWN) will bring the system down and\nready to re-IPL or power off.\n    . The shutdown can be in proper sequence to ensure the\nintegrity.\n    . Validate the running tasks to avoid shutting down system by\nmistake.\n2. Support automatic IPL procedure. The IPL procedure\n    . No system command is required to IPL system.\n3. Support some system tasks automation. Such as restart tasks,\nupdate system parameters.\n4. Reply system messages by keywords, not by id.\n5. Support WTO messages and highlighted WTO messages.\n6. Provide option file to control shutdown and IPL sequence.\n\nHere are the package in XMIT format.\n<<AUTOIPL.XMI>>\nHere are the installation guide and user guide (copied from XMIT\npackage):\n\n<<AUTOIPL.INSTALL.TXT>>\n<<AUTOIPL.USERGDE.TXT>>\n\nBest Regards!\n\nHunter Guanghui Zhou\nPhone: 1-(416)-602-9567\nE-mail: zhough2000@yahoo.com\n\n                  Name: AUTOIPL.XMI\n   AUTOIPL.XMI    Type: unspecified type (application/octet-stream)\n              Encoding: base64\n\n                          Name: AUTOIPL.INSTALL.TXT\n   AUTOIPL.INSTALL.TXT    Type: Plain Text (text/plain)\n                      Encoding: quoted-printable\n\n                          Name: AUTOIPL.USERGDE.TXT\n   AUTOIPL.USERGDE.TXT    Type: Plain Text (text/plain)\n                      Encoding: quoted-printable\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE2": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x06\\x11_\\x01\\x06\\x11_\\t!\\x00\\x1a\\x00\\x14\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2006-04-25T00:00:00", "modifydate": "2006-04-25T09:21:31", "lines": 26, "newlines": 20, "modlines": 0, "user": "SBGOLOB"}, "text": "Note from Sam Golob:\n\n   I have made adjustments to the support information in\n   this file, according to the email address and (cell)\n   phone number for Hunter Zhou, which is listed here.\n\nSubject:     Good Luck!\nFrom:        \"Zhou, Hunter\" <hunter.zhou@sobeys.com>\nDate:        Fri, 21 Apr 2006 08:42:57 -0400\nTo:          <zhough2000@yahoo.com>\n\nDear All,\n\nAs you might already know, today is my last day in Sobeys.\n\nI wish you continue to success and enjoy everyday in Sobeys.\nPlease keep in touch, and I can be reached at my personal email\naddress zhough2000@yahoo.com.\n\nThanks again for everything.\n\nYours Sincerely,\n\nHunter Zhou\nEmail: zhough2000@yahoo.com\nCell: (416) 602-9567\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE623": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04H\\x00\\x00\\x01\\x06\\x11_\\x01\\x06\\x11_\\tF\\x00\\x1d\\x00\\x1d\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf2@@@'", "ispf": {"version": "04.72", "flags": 0, "createdate": "2006-04-25T00:00:00", "modifydate": "2006-04-25T09:46:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "CBT-472"}, "text": "//***FILE 623 is from Hunter Guanghui Zhou, and contains a package  *   FILE 623\n//*           to accomplish Automated System Shutdown, and          *   FILE 623\n//*           Automated IPL.  This system has many good features.   *   FILE 623\n//*                                                                 *   FILE 623\n//*     This package also supplies 3 generic utilities:             *   FILE 623\n//*     Issue Console Command, Send WTO message, and WAIT.          *   FILE 623\n//*                                                                 *   FILE 623\n//*           Hunter Guanghui Zhou                                  *   FILE 623\n//*           Phone: 1-(416)-602-9567                               *   FILE 623\n//*           E-mail: zhough2000@yahoo.com                          *   FILE 623\n//*                                                                 *   FILE 623\n//*     Here are the features of this package:                      *   FILE 623\n//*                                                                 *   FILE 623\n//*     1. Support automatic shutdown procedure.                    *   FILE 623\n//*         . Single command (S SHUTDOWN) will bring the system     *   FILE 623\n//*           down and ready to re-IPL or power off.                *   FILE 623\n//*         . The shutdown can be in proper sequence to ensure      *   FILE 623\n//*           the integrity.                                        *   FILE 623\n//*         . Validate the running tasks to avoid shutting down     *   FILE 623\n//*           system by mistake.                                    *   FILE 623\n//*     2. Support automatic IPL procedure.                         *   FILE 623\n//*         . No system command is required to IPL system.          *   FILE 623\n//*     3. Support some system tasks automation. Such as            *   FILE 623\n//*        restart tasks, update system parameters.                 *   FILE 623\n//*     4. Reply system messages by keywords, not by id.            *   FILE 623\n//*     5. Support WTO messages and highlighted WTO messages.       *   FILE 623\n//*     6. Provide option file to control shutdown and IPL          *   FILE 623\n//*        sequence.                                                *   FILE 623\n//*                                                                 *   FILE 623\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@INSTALL": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00F\\x01\\x03\\x11\\x9f\\x01\\x06\\x11_\\t5\\x00\\xa6\\x00\\xa9\\x00\\x00\\xe9\\xc8\\xd6\\xe4@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-04-29T00:00:00", "modifydate": "2006-04-25T09:35:46", "lines": 166, "newlines": 169, "modlines": 0, "user": "ZHOU"}, "text": "AutoIPL Package Installation\n============================\n\nPlease follow following procedures to install the AUTOIPL package\n\n1. Upload the package\n   The package is in TSO XMIT format, allocat a sequential data set\n  (SYS1.AUTOIPL.XMIT) with following attributes:\n\n  LRECL=80,BLKSIZE=3120,SPACE=(TRK,(15,15))\n\n2. Upload the package\n   Upload the package via FTP or 3270 PC file transfer with BINARY\n   mode.\n\n3. Extract the package\n   Issue following TSO command to extract the package:\n\n   RECEIVE INDSN('SYS1.AUTOIPL.XMIT')\n   DATASET('SYS1.AUTOIPL.INSTALL')\n\n   The output data set SYS1.AUTOIPL.INSTALL is a PDS library contains\n   all source to install the package.\n\n4. Allocate Libraries.\n   The package need following PDS libraries, you may use existing\n   PDS libraries in your installation:\n   a. LOADLIB. The load module will be saved to, this libary must\n               me APF authorized, and in LINKLST in your\n               SYS1.PARMLIB(PROGxx).\n\n   b. PROCLIB. The authorized procedure library of your installation.\n               such as SYS1.PROCLIB.\n\n   c. PARMLIB. The parameters to be saved to, you may use SYS1.PARMLIB.\n\n   d. REXXLIB. The rexx program be saved to, you may use SYS1.CLIST.\n\n   In our installation example, we use following names:\n   LOADLIB=SYS1.USER.LINKLIB\n   PROCLIB=SYS1.USER.PROCLIB\n   PARMLIB=SYS1.USER.PARMLIB\n   REXXLIB=SYS1.USER.REXXLIB\n\n5. Build load modules.\n   Edit the member COMPILE and change the job card, LOADLIB, SRCLIB,\n   and submit the job.\n   The required load modules will be generated in your LOADLIB.\n\n6. Copy the REXX programs.\n   There is one REXX program named AUTOIPL.\n\n   You can copy this program to your REXXLIB specified in Step 4.\n\n7. Copy the Procedures.\n   There are two started task procedures need to be copied to your\n   authorized procedure library:\n   IPLCMDS       Started Task to IPL system.\n   SHUTDOWN      Started task to shutdown the system.\n\n   You need to update the PARMLIB and REXXLIB to your installation\n   requirements in step 4.\n\n   You may also need to customize the system level started tasks\n   in these procedures.\n\n8. Copy the parameters.\n   There are 4 parameter members in our installation libraries.\n   They are examples for you to edit to meet your installation require-\n   ments.\n   IPLPROD       Parameter member to IPL the production system\n   IPLTEST       Parameter member to IPL the test system\n   SHUTPROD      Parameter member to shutdown the production system\n   SHUTTEST      Parameter member to shutdown the test system\n\n   Copy these members to your parmlib and edit them.\n   Please refer @USERGDE to learn how to customize these members.\n\n9. Security Setup.\n   You need to assign a user for these two started tasks in step 6.\n   You can setup a generic start task user, i.e. STCUSR, as RACF\n   commands:\n\n   ADDUSER STCUSR OWNER(SYS1) DFLTGRP(STCGRP) NAME('GENERIC USER')\n   CONNECT STCUSR GROUP(STCGRP) OWNER(SYS1) UACC(READ)\n   RDEFINE STARTED IPL*.* STDATA(USER(STCUSR) GROUP(STCGRP) +\n           TRUSTED(YES) PRIVILEGED(NO) TRACE(NO))\"\n   RDEFINE STARTED SHUT*.* STDATA(USER(STCUSR) GROUP(STCGRP) +\n           TRUSTED(YES) PRIVILEGED(NO) TRACE(NO))\"\n\n   This started user must have TSO CONSOLE authority. You can grant it\n   via following RACF command:\n\n   PERMIT MVS.MCSOPER.* CLASS(OPERCMDS) ID(STCGRP) ACCESS(USE)\n\n   Started user should have OPERTATION authority to perform normal\n   sysem operation.\n\n10. Customize JES2 Parameters\n   At IPL time, the procedure IPLCMDS can be started automatically\n   when you put it at the end of JES2 parameters as following statements\n\n   /* Start TSO and all other software. */\n   $VS,'S IPLCMDS,SYSTEM=xxxx'\n\n   Here xxxx is TEST or PROD.\n\n   You may also put this command in SYS1.PARMLIB(COMMANDxx), and you\n   should increase the wait time in IPLCMDS procedure.\n\n11. Customize APF and LINKLST in PROGxx\n   If you create a new LOADLIB to store AUTOIPL load modules. You must\n   add this library into your APF authorized library list and your\n   LINKLST. To do so, you need to change your SYS1.PARMLIB(PROGxx)\n   to add this LOADLIB.\n   Here are the sample statements to add SYS1.USER.LINKLIB:\n\n   APF ADD DSNAME(SYS1.USER.LINKLIB)\n   LNKLST ADD NAME(LNKLST30) DSN(SYS1.USER.LINKLIB)\n\n12. Refresh the LINKLST and APF List\n   You need to update the LLA and APF list.\n   a. If you create a new LOADLIB for AUTOIPL modules, do following:\n      Change the LINKLST name in PROGxx via ISPF change command:\n          C NAME(LNKLST30) NAME(LNKLST31) ALL\n\n      Update the LINKLIST dynamically:\n         SET PROG=xx\n      here xx is your suffix of your running PROGxx.\n\n   b. Refresh LLA for load modules created in Step 5.\n      Issue following MVS command:\n         F LLA,REFRESH\n\n13. Test AUTOIPL package.\n   You should test this package in your test system before you\n   put it into your production.\n\n   a. Shutdown the system:\n      Issue following command from console, or SDSF LOG:\n          S SHUTDOWN,SYSTEM=TEST\n      If you issue this command from SDSF LOG, log off your TSO session.\n      All the tasks should be terminated and you should be able to\n      see following hilighted message:\n\n      'TEST SYSTEM SHUTDOWN IS COMPLETED,'\n      ' IT IS SAFE TO POWER OFF OR RE-IPL &SYSTEM SYSTEM NOW.'\n\n   b. IPL the system\n      After you IPL the system, the AUTOIPL should start all tasks\n      except those in SYS1.PARMLIB(COMMANDxx). You should be able to\n      see following hilighted message:\n\n      'IPL IS COMPLETED, TSO USERS MAY LOGON NOW.'\n\n\nQuestions & suggestions\n=======================\n Should you have any question, please contact Hunter Zhou at\n zhough2000@yahoo.com\n\n April, 2003\n\n Hunter Guanghui Zhou\n Phone: 1-(416)-602-9567\n E-mail: zhough2000@yahoo.com\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@USERGDE": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x004\\x01\\x03\\x11\\x9f\\x01\\x06\\x11_\\t6\\x019\\x01<\\x00\\x00\\xe9\\xc8\\xd6\\xe4@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-04-29T00:00:00", "modifydate": "2006-04-25T09:36:34", "lines": 313, "newlines": 316, "modlines": 0, "user": "ZHOU"}, "text": "AUTOIPL USER GUIDE\n==================\n\nIntroduction\n------------\n  AUTOIPL is a package to automate your shutdown and IPL procedure.\nThis package is a free license and open source package.\n\nThe package has following feature:\n  1. Automatic shutdown the system in proper sequence.\n     After a single command (S SHUTDOWN), the system will be completely\n     shutdown and ready to power off or re-IPL.\n\n  2. Safe to shutdown.\n     As AUTOIPL will not shutdown until all running tasks are stopped,\n     It's safe by issuing the command by mistake.\n\n  3. Proper Messages.\n     The package will show the proper messages to indicate the\n     status of the procedure.\n\n  4. Automatic IPL\n     After system IPLed, the start tasks will be started in proper\n     sequence. There is no user intervention required.\n\nComments\n--------\n Any words beyond '#' will be comments and ignored.\n You can put a '#' at the beginning of the line to comment it out.\n Or. you can put comments at the end of statements.\n\n Examples:\n\n # First Phase: stop most applications.\n # ...\n # Wait 1 minute.\n WAIT 60\n ...\n P TCPIP      # Stop TCP/IP and TCP/IP dependent tasks.\n\n Any space before or after each command will be ignored.\n Any empty line will be ignored.\n\nMVS Commands\n------------\n Each MVS command must be within 70 charaters.\n The AUTOIPL will check the command length and ignore the command\n exceeds 70 characters.\n\nStatements\n----------\n You can put commands in multiple line, for example:\n         STOP(NPFFWTR ,'$PPRT6',\n                       '$PPRT7',\n                       '$PPRT8')\n You must put comma(,) to tell the command continues next line.\n This example is the same as:\n         STOP(NPFFWTR ,'$PPRT6','$PPRT7','$PPRT8')\n\nSpecial Commands\n----------------\n Normally, the statements are treated as MVS system command and\n AUTOIPL will issue it for to system.\n\n There are some special statements.\n\n a. WAIT\n\n    If you need to wait, code following line:\n       WAIT\n    or WAIT seconds\n\n    Specify wait time in seconds, i.e. 'WAIT 300' for 5 minutes.\n\n    There is a special function for WAIT statement. The WAIT statement\n    will also check the completion of previous commands.\n    For shutdown, the WAIT will tell AUTOIPL to wait for the termination\n    of all tasks issued by STOP commands.\n\n    You should use WAIT command when you need to stop tasks in sequence.\n\n    i.e. Stop RMF TCP/IP Server before stop RMF:\n\n    P GPMSERVE     # issue STOP RMF TCP/IP Server command\n    WAIT 30        # WAIT at leat 30 seconds and checking GMPSERVE.\n    P RMF          # stop RMF and RMF III\n\n b. END\n\n    If you need to specify end of the parameter member explicitely,\n    use following statement:\n       END\n    Any line beyond this line will be ignored.\n\n\n c. REPLY or R\n\n    If you need to stop address space by REPLY command,\n    you can specify them by keyword instead of reply number.\n        R keyword,command\n    For example:\n        R EZY0960I,STOP\n    The program will look up the keyword 'EZY0960I' and it's reply\n    number in reply list, and replace the keyword with the number nn,\n    and issue the MVS command:\n        R nn,STOP\n\n    If the keyword is a number, the program will not\n    translate it, it will issue it as a REPLY command.\n\n    If the keyword is a string with space or comma,\n    use quote around the keyword, i.e.:\n        R 'JES328Z - ENTER COMMAND',END\n\n c. STOP\n\n    If you need to issue some special command to shutdown some tasks,\n    use following format:\n\n        STOP(addrname,'command1','command2',CHECK/NOCHECK)\n\n    addrname is the address space name to stop,\n    if this is a hook, just code the start task name.\n    The default option is CHECK, which will check if the given\n    task is running for STOP/MODIFY/CANCEL commands. If the\n    task is not running and option is CHECK or omitted,\n    these commands will not be issued.\n    For some special tasks (FFST), you need code NOCHECK to\n    provent checking FFST's running status before issuing the\n    STOP command because the task name for FFST is EPWFFST.\n    for example:\n          i.  STOP(NPFFWTR,'$PPRT6','$PPRT7','$PPRT8')\n\n         ii.  STOP(DMSAR   ,'S DMSAR,DMSAR=REMOVE')\n            DMSAR is a hook, the program will wait until this\n            DMSAR started task stops.\n\n        iii.  STOP(none    ,'P FFST',NOCHECK)\n              WAIT 10\n              STOP(EPWFFST ,'R EPW0309I,YES')\n\n            Issue STOP FFST, then FFST will issue a reply message,\n            Wait 10 seconds, and reply the message as 'YES'.\n\n e. If you need to wait some task to stop/start without issuing\n    any command (command may be issued before), use following\n    comamnd:\n              WAIT(taskname, STOP/START)\n    The program will detect and wait till the taskname is started or\n    stopped.\n    This feature is useful for those tasks needs a long time to stop.\n\n    Example:\n        STOP(NONE, 'P SLS0')\n         ...\n        WAIT(60)\n         ...\n        WAIT(SLS0, STOP)\n         ...\n        WAIT(10)\n          This technique will use 2 or more stages to allow the task\n          to stop.\n f WTO and WTOH\n   If you need to write console message, use command:\n        WTO('message')\n    or\n        WTO(message)\n   You can use WTOH to issue high light messages\n\n\nConfiguration Statements\n------------------------\n\n   There are some settings control how the program runs.\n\n        CONFIG(keyword)= value\n\n   keyword are:\n     a.OPTION   The options are :\n                IPL           : Tell this is a IPL procedure\n                SHUTDOWN      : Tell this is a SHUTDOWN procedure\n                VALIDATE_ONLY : Validate the commands only.\n                                No MVS command will be issued.\n                                This is for test purpose.\n                The default value is none.\n\n     b.TIMEOUT  The timeout value in seconds.\n                The timeout will be used for waiting for task to stop\n                The default timeout is 300\n\n     c.EXCLUDE_TASK  This is the address space name which will be\n                excluded when the program checking running task.\n                You can specify multiple EXCLUDE_TASK.\n                The default tasks are FTPD, INETD and SYSLOGD\n                These tasks normally are TSO or BATCH jobs.\n\n   For shutdown, the AUTOIPL will check if there is any running\n   jobs. If any, it will issue a console message to show the running\n   task, and check it every 1 minute. All commands will not be issued\n   until these running tasks stops.\n\n   For some environment, there are some running batch jobs or TSO\n   users as part of system running task, not user batch jobs.\n   The example are TCP/IP FTPD, INETD and SYSLOGD.\n   In order to bypass checking these tasks, you need to use\n   CONFIG(EXCLUDE_TASK) to bypass them at shutdown parameter member.\n\n   The CONFIG statement can be anywhere in the parameter member.\n\nExamples\n--------\n  1. IPL examples.\n     IPLCMDS : Started Task for IPL\n     IPLPROD : AUTOIPL Option file for IPLCMDS in production system\n     IPLTEST : AUTOIPL Option file for IPLCMDS in test system\n\n  2. Shutdown examples.\n     SHUTDOWN: Started Task for shutdown\n     SHUTPROD: AUTOIPL Option file for SHUTDOWN in production system\n     SHUTTEST: AUTOIPL Option file for SHUTDOWN in test system\n\n  3. Restart examples.\n     IPLTCPIP: AUTOIPL Option file to automatic OMVS parameter updates:\n               step 1: Stop all TCP/IP applications\n               step 2: Update OMVS parameters via SETOMVS command\n               step 3: Start all TCP/IP applications\n\nGeneral Utilities\n-----------------\n  There are three general utilities shipped with this package:\n  CONSCMD : Issue console command via EXEC PARM\n  WAIT    : Wait or sleep in specific time given in EXEC PARM\n  WTO/WTOH: Send WTO messages (normal or highlighted) to console\n    All these utilities are re-retrent program, you can load them\n  into LPA or LINKLST. CONSCMD must be APF authorized. See installation\n  guide for details.\n\n  1. CONSCMD\n   Issue console command via EXEC PARM\n   The command in parm is a single command form\n     FOR EXAMPLE,\n     //JOBCARD\n     //OFFLINE EXEC PGM=CONSCMD,PARM='V 107A,OFFLINE'\n     //STEPn...\n     //ONLINE  EXEC PGM=CONSCMD,PARM='V 107A,ONLINE'\n\n  2. WAIT\n   Wait or sleep in specific time given in EXEC PARM\n   It support three forms in PARM:\n  a. Complete form: HHMMSSth, wait minimum 0.01 seconds\n     HH: Hour\n     MM: Minute\n     SS: Seconds\n     th: 0.01 seconds\n  Syntax:\n  //WAIT EXEC PGM=WAIT,PARM='HHMMSSth'\n  Example:\n  //WAIT EXEC PGM=WAIT,PARM='00001035'       wait 10.35 seconds\n\n  b. Supressed form: HHMMSS, wait minimum 1 second\n     HH: Hour\n     MM: Minute\n     SS: Seconds\n  Syntax:\n  //WAIT EXEC PGM=WAIT,PARM='HHMMSS'\n  Example:\n  //WAIT EXEC PGM=WAIT,PARM='000030'         wait 30 seconds\n\n  c. Second form: SSSSS, wait minimum 1 second\n     SSSSS: variable number range from 1 to 99999 seconds\n  Syntax:\n  //WAIT EXEC PGM=WAIT,PARM='sssss'\n  Example:\n  //WAIT EXEC PGM=WAIT,PARM=3600             wait 3600 seconds (1 hour)\n\n  2. WTO and WTOH\n  Send WTO messages (normal or highlighted) to console\n  The message can be given in either EXEC PARM or SYSIN DD.\n    a. USING EXEC PARM.\n       Send messages supplied in EXEC PARM to console.\n       This is the primary choice.\n       Sample JCL:\n\n    //WTOMSG EXEC PGM=WTO,    issue normal WTO message\n    //    PARM='Hello, this is a test WTO message.'\n    //WTOH   EXEC PGM=WTOH,   issue high lighted message\n    //    PARM='System is IPLed, TSO user can logon on now.'\n\n    b. USING SYSIN DD\n       Send messages supplied in SYSIN DD to console.\n       This is the secondary choice. When there is any EXEC PARM\n       SYSIN DD will be ignored.\n       The SYSIN DD must be record length of 80\n       The maximum lines is defined at compile time.\n       Sample JCL:\n\n    //WTOMSG EXEC PGM=WTO\n    //SYSIN DD *\n    This is a test WTO message line 1.\n    This is a test WTO message line 2.\n    ...\n    /*\n\nQuestions & suggestions\n=======================\n Should you have any question, please contact Hunter Zhou at\n zhough2000@yahoo.com\n\n April, 2003\n\n Hunter Guanghui Zhou\n Phone: 1-(416)-602-9567\n E-mail: zhough2000@yahoo.com\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASMCMDS": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x004\\x01\\x03\\x11_\\x01\\x06\\x11_\\t7\\x01\\x10\\x01\\x10\\x00\\x00\\xe9\\xc8\\xd6\\xe4@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-04-25T00:00:00", "modifydate": "2006-04-25T09:37:34", "lines": 272, "newlines": 272, "modlines": 0, "user": "ZHOU"}, "text": "CONSCMD  TITLE 'ISSUE MVS SYSTEM COMMAND'\n*---------------------------------------------------------------------*\n* PROGRAM: CONSCMD                                                    *\n* AUTHOR : HUNTER ZHOU, ZHOUGH2000@YAHOO.COM                          *\n* DESCRIPTION: ISSUE MVS CONSOLE COMMAND TO CONSOLE                   *\n*---------------------------------------------------------------------*\n* REQUIREMENT:                                                        *\n*  1. THE PROGRAM WILL BE RUN IN SUPERVISOR MODE.                     *\n*     THE LOADLIB PDS MUST BE IN MVS APF AUTHORIZED LIST.             *\n*     SUCH AS APF LIST IN SYS1.PARMLIB(PROGXX)                        *\n*  2. OPTIONALLY, THE LOADLIB CAN BE PUT IN MVS LINKLST               *\n*     IN SYS1.PARMLIB(PROGXX).                                        *\n*     THE PROGRAM IS REENTRENT PROGRAM AND CAN BE LOADED              *\n*     INTO LPA LIST (SYS1.PARMLIB(LPALSTXX))                          *\n*  3. COMPILE REQUIREMENTS.                                           *\n*     THE LINKEDIT OPTION MUST USE 'RENT,A(1)'                        *\n*     //JOBCARD...                                                    *\n*     //COMPILE EXEC ASMACL,PARM.L='LIST,RENT,AC(1)'                  *\n*     //C.SYSIN   DD DISP=SHR,DSN=SP2487.ASM.SOURCE(CONSCMD) THIS ONE *\n*     //C.SYSLIB  DD DISP=SHR,DSN=SYS1.MACLIB                         *\n*     //          DD DISP=SHR,DSN=SYS1.MODGEN                         *\n*     //L.SYSLMOD DD DISP=SHR,DSN=SYS1.USER.LINKLIB  ANY APF LIBRARY  *\n*     //L.SYSIN   DD *                                                *\n*       NAME CONSCMD(R)                                               *\n*     /*                                                              *\n*  4. THE USER TO RUN THIS PROGRAM MUST HAVE ENGOUGH AUTHORITY.       *\n*     THE SECURITY SOFTWARE WILL CHECK THE AUTHORITY OF THE USERID    *\n*     IF HE HAS THE AUTHORITY TO ISSUE THE MVS COMMAND.               *\n*---------------------------------------------------------------------*\n* USAGE:                                                              *\n*  IT SUPPORT FOLLOWING INPUT FORMAT:                                 *\n*  I. COMMAND FROM PARM IN JCL EXEC STATEMENT.                        *\n*     THE COMMAND IN PARM IS A SINGLE COMMAND FORM                    *\n*     FOR EXAMPLE,                                                    *\n*     //JOBCARD                                                       *\n*     //OFFLINE EXEC PGM=CONSCMD,PARM='V 107A,OFFLINE'                *\n*     //STEPLIB DD  DISP=SHR,DSN=SYS1.USER.LINKLIB                    *\n*     ...                                                             *\n*     //ONLINE  EXEC PGM=CONSCMD,PARM='V 107A,ONLINE'                 *\n*     //STEPLIB DD  DISP=SHR,DSN=SYS1.USER.LINKLIB                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n* END OF DESCRIPTION OF THE PROGRAM                                   *\n*---------------------------------------------------------------------*\n* PROGRAM DESIGN DESCRIPTION                                          *\n*                                                                     *\n* CONSTANT REGISTERS THROUGH THE WHOLE PROGRAM:                       *\n*  R12: BASE ADDRESS                                                  *\n*  R11: ADDRESSING FOR DYNAMIC STORAGE                                *\n*                                                                     *\n* FOLLOWING REGISTERS WILL BE MODIFIED WHILE CALLING MVS MACROS:      *\n*   R0, R1, R14, R15                                                  *\n*                                                                     *\n* FOLLOWING REGISTERS WILL BE USED WITH THEIR PURPOSE:                *\n*   R13: THE ADDRESS OF OUR SAVED AREA.                               *\n*   R12: BASE ADDRESS                                                 *\n*   R11: ADDRESSING FOR DYNAMIC STORAGE                               *\n*   R10: THE ADDRESS OF THE STORAGE.                                  *\n*   R9 : THE LENGTH OF THE STORAGE                                    *\n*   R8 : ANY                                                          *\n*   R7 : ANY                                                          *\n*   R6 : ANY                                                          *\n*   R5 : ANY                                                          *\n*   R3 : ANY                                                          *\n*   R2 : CALLING THE SUB-ROUTINES (BALR)                              *\n*                                                                     *\n* PROGRAM DESIGN POINTS:                                              *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         PRINT NOGEN\nCONSCMD  CSECT\nCONSCMD  AMODE 31\nCONSCMD  RMODE ANY\n         YREGS\n         STM   R14,R12,12(R13)    ;SAVE CALLER'S REGISTERS\n         BALR  R12,0              ;\n         USING *,R12              ;\n         MODID BRANCH=YES         ;\n*---------------------------------------------------------------------*\n* SAVE THE PARAMETER REGISTER FROM R1 TO R7 BEFORE GETMAIN\n*---------------------------------------------------------------------*\n         LR    R7,R1              ;SAVE ADDR OF PARM TO R7\n*---------------------------------------------------------------------*\n* DYNAMICALLY ALLOCATE STORAGE FOR DATA AREAS\n*---------------------------------------------------------------------*\n         GETMAIN RU,LV=DATAEND           ;OBTAIN STORAGE FOR DATA AREAS\n         LR    R11,R1             ;ADDR OF ENTRY POINT\n         USING DATAAREA,R11       ;USING R11 AS STOR ADDRESSING REGS.\n         ST    R13,SAVEAREA+4     ;SET OUR BACKWARD LINK\n         LA    R15,SAVEAREA       ;ADDR OF OUR SAVEAREA\n         ST    R15,8(R13)         ;SET CALLER'S FORWARD LINK\n         LR    R13,R15            ;ADDR OF OUR SAVEAREA\n*---------------------------------------------------------------------*\n* SAVE THE PARAMETER TO PRIVATE STORAGE (PARM AND PARMLEN)\n*---------------------------------------------------------------------*\n         L     R7,0(,R7)          ;LENGTH OF PARM\n         LH    R9,0(,R7)          ;LENGTH OF PARM\n         LA    R10,2(,R7)         ;POINT AT DATA\n         STCM  R9,B'0011',PARMLEN ;COPY THE PARAMETER LENGTH TO PARMLEN\n         BCTR  R9,0               ;DECREMENT LENGTH BY 1\n         EX    R9,MVCPARM         ;COPY PARMATER TO PARM STORAGE\n         SR    R0,R0              ;INDICATE SYSTEM ISSUED COMMAND\n*---------------------------------------------------------------------*\n* INITIALIZE STORAGE AREA WITH CONSTANT DATA\n*---------------------------------------------------------------------*\n* GET THE JOBNAME AS TEMPORARY CONSOLE NAME\n         LA    R3,TIOTA\n         EXTRACT (R3),'S',FIELDS=(TIOT),MF=(E,EXTRMFL) JOB NAME INFO\n         L     R3,TIOTA           TIOT ADDRESS\n         USING TIOT1,R3           TIOT ADDRESSABILITY\n         MVC   CCONNAME,TIOCNJOB  COPY THE JOBNAME AS CONSOL NAME\n         MVC   HCCONSNM,TIOCNJOB  COPY THE JOBNAME AS CONSOL NAME\n         MVC   CMDLEN,CCMDLEN     CONSOLE COMMAND LENGTH\n         DROP  R3\n*\n*---------------------------------------------------------------------*\n* PARPARE OPERPARM\n*---------------------------------------------------------------------*\n         LA    R8,OPERDATA            ADDRESS OF OPERPARM AREA\n         USING MCSOPPRM,R8            IEZVG111 DSECT ADDRESSABILITY\n         XC    MCSOPPRM(MCSOPLEN),MCSOPPRM  CLEAR THE OPERPARM AREA\n***********************************************************************\n* OVERRIDE THE CONSOLE ATTRIBUTES SPECIFIED IN THE USER PROFILE\n* OF THE SECURITY PRODUCT BY TURNING ON BIT MCSOVRDY IN THE MCSOP DATA\n* AREA. REQUEST THE HARDCOPY ATTRIBUTE (TO RECEIVE HARDCOPY MESSAGE SET\n***********************************************************************\n         OI    MCSOFLAG,MCSOVRDY      OVERRIDE CONSOLE ATTRIBUTES\n         OI    MCSOMISC,MCSOHDCY      REQUEST THE HARDCOPY ATTRIBUTE\n         DROP  R8                     DROP ADDRESSABILITY OF IEZVG111\n*\n*---------------------------------------------------------------------*\n* CALL MGCRE TO ISSUE MVS COMMAND\n*---------------------------------------------------------------------*\n         MODESET MF=(E,MODESUP)    ;SUPERVISOR STATE, KEY 0\n***********************************************************************\n* ACTIVATE AN EXTENDED MCS CONSOLE WHOSE NAME IS CONTAINED IN A FIELD\n* CALLED HCCONSNM.  THE ATTRIBUTES OF THE EXTENDED MCS CONSOLE ARE\n* CONTAINED IN A FIELD CALLED OPERDATA, MAPPED BY IEZVG111.  THE\n* CONSOLE WILL HAVE ITS MESSAGES DELIVERED ON A FIRST-IN-FIRST-OUT\n* BASIS.  THE SYSTEM WILL POST A MESSAGE ECB CALLED HCMECB.\n* THE ADDRESS OF THE OUTPUT AREA THAT CONTAINS THE\n* ADDRESS OF THE MCS CONSOLE STATUS AREA IS CONTAINED IN A FIELD\n* CALLED HCSTATUS.  THE ADDRESS OF THE ALET THAT IDENTIFIES THE ADDRESS\n* OR DATA SPACE THAT CONTAINS THE MCS CONSOLE STATUS AREA IS\n* CONTAINED IN A FIELD CALLED HCSTATAL.\n* THE SYSTEM RETURNS THE CONSOLE ID IN THE FIELD CALLED HCCONSID.\n* THE SYSTEM RETURNS A RETURN CODE AND A REASON CODE IN FIELDS\n* CALLED HCRETC AND HCRNC, RESPECTIVELY.\n***********************************************************************\n         MCSOPER REQUEST=ACTIVATE,  ACTIVATE THE CONSOLE               X\n               NAME=HCCONSNM,                                          X\n               TERMNAME=HCCONSNM,                                      X\n               OPERPARM=OPERDATA,                                      X\n               MSGDLVRY=FIFO,                                          X\n               MSGECB=HCMECB,                                          X\n               MCSCSA=HCSTATUS,                                        X\n               MCSCSAA=HCSTATAL,                                       X\n               CONSID=HCCONSID,                                        X\n               RTNCODE=HCRETC,                                         X\n               RSNCODE=HCRSNC,                                         X\n               MF=(E,MCSOPPL)\n         SR    R9,R9               ;CLEAR R9\n         ICM   R9,B'0011',PARMLEN  ;LOAD THE PARAMETER LENGTH TO R9\n         STCM  R9,B'0011',CMDLEN   ;COPY PARAMETER LENGTH TO CMDLEN\n         LA    R10,PARM            ;LOAD THE PARAMETER ADDRESS TO R10\n         BCTR  R9,0               ;DECREMENT LENGTH BY 1\n         EX    R9,MVCCMDS          ;COPY PARMATER TO PARM STORAGE\n*---------------------------------------------------------------------*\n* SEND A MESSAGE TO CONSOLE USING WTO MESSAGE\n*---------------------------------------------------------------------*\n*        SR    R9,R9               ;CLEAR R9\n*        ICM   R9,B'0011',PARMLEN  ;LOAD THE PARAMETER LENGTH TO R9\n*        ITCM  R9,B'0011',WTOLEN   ;COPY PARAMETER LENGTH TO WTOLEN\n*        LA    R10,PARM            ;LOAD PARAMETER ADDRESS TO R10\n*        BCTR  R9,0               ;DECREMENT LENGTH BY 1\n*        EX    R9,MVCWTO           ;COPY PARMATER TO WTO  STORAGE\n*        WTO   TEXT=WTOAREA,MF=(E,WTOCMD) ;SHOW THE COMMAND ON CONSOLE\n*\n*---------------------------------------------------------------------*\n         LA    R10,CMDAREA         ;LOAD THE PARAMETER ADDRESS TO R10\n         MGCRE TEXT=(R10),                  ;CALL MVS COMMAND MGCRE    X\n               CONSNAME=HCCONSNM,MF=(E,MGCAREA)\n         MCSOPER REQUEST=DEACTIVATE,CONSID=HCCONSID,ABTERM=NO,         X\n               RTNCODE=HCRETC,RSNCODE=HCRSNC\n         MODESET MF=(E,MODEPROB)    ;BACK TO NORMAL STATE\n         STIMER WAIT,BINTVL=WAITTIME ;WAIT A LITTLE BIT\n*\n*---------------------------------------------------------------------*\n*  RETURN LINKAGE                                                     *\n*---------------------------------------------------------------------*\nRETURN   EQU   *\n         L     R13,4(R13)         ;ADDR OF CALLER'S SAVEAREA\n         FREEMAIN RU,LV=DATAEND,A=(R11)        ; FREE ALLOCATED STOR\n         RETURN (14,12),RC=(15)   ;RESTORE CALLER'S REGS AND RETURN\n*\n*---------------------------------------------------------------------*\n*  DATA  AREAS                                                        *\n*---------------------------------------------------------------------*\n*  LIST FORMS OF MVS MACROS                                           *\n*---------------------------------------------------------------------*\nMODESUP  MODESET MODE=SUP,KEY=ZERO,MF=L    ;SUPERVISOR STATE\nMODEPROB MODESET MODE=PROB,KEY=NZERO,MF=L  ;PROBLEM STATE (NORMAL)\nMGCAREA  MGCRE   MF=L                      ;MGCRE\nWTOCMD   WTO     TEXT=,MF=L                ;WTO\n*---------------------------------------------------------------------*\n*  MVC INSTRUCTIONS FOR DATA STORAGE                                  *\n*  R10 WILL BE THE LOCATION OF SOURCE STORAGE TO BE COPIED.           *\n*  CALLING SYNTAX:                                                    *\n*        LA    R10,2(,R1)         ; LOAD THE PARAMETER ADDREDD TO R10 *\n*        EX    R9,MVCPARM         ; COPY THE PARAMETER TO PARM        *\n*---------------------------------------------------------------------*\nMVCPARM  MVC   PARM(0),0(R10)     ;COPY THE PARAMETER TO STORAGE PARM\nMVCWTO   MVC   WTOMSG(0),0(R10)   ;COPY THE WTO MESSAGE TO WTOMSG\nMVCCMDS  MVC   CMDTEXT(0),0(R10)  ;COPY THE CONSOLE COMMAND TO CMDTEXT\n*\nCCMDLEN  DC    AL2(126)           ;MAXIMUM COMMAND LENGTH\nWAITTIME DC    A(50)              ;WAIT TIME, IN NUMBER/100 SECONDS\n         SPACE\n*---------------------------------------------------------------------*\n*  DSECT DATA, ALLOCATED DYNAMICALLY.                                 *\n*---------------------------------------------------------------------*\nDATAAREA DSECT\n         DS    0F\nSAVEAREA DS    18F                ;REGISTER SAVE AREA\nCLEAN    DS    CL256' '           ;CLEAN AREA\n*\n*WTO AREA\nWTOAREA  DS    0CL128\nWTOLEN   DS    CL2                ;WTO MESSAGE LENGTH\nWTOMSG   DS    CL126              ;WTO MESSAGE BUFFER, MAX 126 BYTES.\n*\nPARMLEN  DS    CL2                ;THE LENGTH OF THE PARM\nPARM     DS    CL126              ;PARAMETER FROM\n*\nCMDAREA  DS    0CL128             ;COMMAND AREA\nCMDLEN   DS    AL2                ;COMMAND LENGTH, MAXIMUM 126 BYTES\nCMDTEXT  DS    CL126              ;COMMAND TEXT, MAXIMUM 126 BYTES\n*CONSOLE NAME\nCCONNAME DS    CL8                ;CONSOLE NAME\n*TIOT AREA\nTIOTA    DS    F                  TIOT ADDRESS\n*MCSOPER REQUIRED DATA STOREAGE\n*\n         DS    0F\nOPERDATA DS    CL(MCSOPLEN)\nHCCONSNM DS    CL8\nHCCONSID DS    CL4\nHCSTATUS DS    A\nHCSTATAL DS    F\nHCMECB   DS    F\nHCRETC   DS    F\nHCRSNC   DS    F\n         MCSOPER MF=(L,MCSOPPL)\nEXTRMFL  EXTRACT MF=L                      ;EXTRACT JOB NAME INFO\n*\nDATAEND  EQU   *-DATAAREA         ;LENGTH OF DATA AREA\n*\n*---------------------------------------------------------------------*\n*  SYSTEM DSECTS AND MACROS                                           *\n*---------------------------------------------------------------------*\n         IEZVG111\n         IEZMGCR\n         IHAPSA\n         IHAASCB\n         IEFTIOT1\n*\n*---------------------------------------------------------------------*\n*  END OF PROGRAM                                                     *\n*---------------------------------------------------------------------*\n         END   CONSCMD\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMWAIT": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x04\\x01\\x03\\x11_\\x01\\x06\\x11_\\t9\\x00\\xfe\\x00\\xfd\\x00\\x00\\xe9\\xc8\\xd6\\xe4@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-04-25T00:00:00", "modifydate": "2006-04-25T09:39:04", "lines": 254, "newlines": 253, "modlines": 0, "user": "ZHOU"}, "text": "WAIT     TITLE 'SUSPEND EXECUTION FOR GIVEN TIME'\n***********************************************************************\n* PROGRAM: WAIT                                                       *\n* AUTHOR : Hunter Guanghui Zhou                                       *\n*          Phone: 1-(416)-602-9567                                    *\n*          E-mail: zhough2000@yahoo.com                               *\n* UPDATE : April 2003                                                 *\n* PURPOSE: Suspend execution for given time in EXEC PARM              *\n*          The PARM inputs support 3 formats:                         *\n* COMPILE:                                                            *\n*  This program is a re-entreent program, you can put this program    *\n*  in your system LPA (LPALSTxx) or LINKLST (PROGxx).                 *\n*  The linkedit should use RENT keyword to make it re-retreent.       *\n*  Sample Compile JCL:                                                *\n*  // SET  SRCLIB='SP2487.ASM.SOURCE',   <==PDS where source located  *\n*  //      LOADLIB='SYS1.TEST.LINKLIB'                                *\n*  //CPLCMDS  EXEC ASMACL,PARM.L='LIST,RENT'                          *\n*  //C.SYSIN   DD DISP=SHR,DSN=&SRCLIB(ASMWAIT)                       *\n*  //C.SYSLIB  DD DISP=SHR,DSN=SYS1.MACLIB                            *\n*  //          DD DISP=SHR,DSN=SYS1.MODGEN                            *\n*  //L.SYSLMOD DD DISP=SHR,DSN=&LOADLIB                               *\n*  //L.SYSIN   DD *                                                   *\n*    NAME WAIT(R)                                                     *\n*  /*                                                                 *\n*                                                                     *\n* USAGE                                                               *\n* =====                                                               *\n*  1. Complete form: HHMMSSth, wait minimum 0.01 seconds              *\n*     HH: Hour                                                        *\n*     MM: Minute                                                      *\n*     SS: Seconds                                                     *\n*     th: 0.01 seconds                                                *\n*  Syntax:                                                            *\n*  //WAIT EXEC PGM=WAIT,PARM='HHMMSSth'                               *\n*  Example:                                                           *\n*  //WAIT EXEC PGM=WAIT,PARM='00050000'       wait 5 minutes          *\n*                                                                     *\n*  2. Supressed form: HHMMSS, wait minimum 1 second                   *\n*     HH: Hour                                                        *\n*     MM: Minute                                                      *\n*     SS: Seconds                                                     *\n*  Syntax:                                                            *\n*  //WAIT EXEC PGM=WAIT,PARM='HHMMSS'                                 *\n*  Example:                                                           *\n*  //WAIT EXEC PGM=WAIT,PARM='000030'         wait 30 seconds         *\n*                                                                     *\n*  3. Second form: SSSSS, wait minimum 1 second                       *\n*     SSSSS: variable number range from 1 to 99999 seconds            *\n*  Syntax:                                                            *\n*  //WAIT EXEC PGM=WAIT,PARM='sssss'                                  *\n*  Example:                                                           *\n*  //WAIT EXEC PGM=WAIT,PARM='3600'     wait 3600 seconds (1 hour)    *\n*                                                                     *\n*                                                                     *\n* Program Call:                                                       *\n*         R1 -> PARMADDR -> H'8',C'HHMMSSHH'  HOUR-MIN-SEC-S/100      *\n*     OR  R1 -> PARMADDR -> H'6',C'HHMMSS'    HOUR-MIN-SEC            *\n*     OR  R1 -> PARMADDR -> H'N',C'SSSSS'     UP TO 99999 SECONDS     *\n*     R15 RETURN CODE:  0 - SUCCESSFUL   8 - INVALID PARAMETER        *\n*                                                                     *\n* RETURN CODES                                                        *\n* ============                                                        *\n*   0     SUCCESSFUL                                                  *\n*   4     NO PARM GIVEN, RETURN IMMEDIATELY                           *\n*   8     ONE OF FOLLOWING SYNTAX ERROR:                              *\n*         A. THE LENGTH IS INVALID, GREATE THAN 6 BUT NOT 8           *\n*         B. THE HOUR/MINUTE/SECOND ARE IN INVALID RANGE, VALID RANGE:*\n*            HOUR  : 00 - 24                                          *\n*            MINUTE: 00 - 59                                          *\n*            SECOND: 00 - 59                                          *\n*         C. THE PARM CONTAIN NON-DIGIT CHARACTER                     *\n*  16     GETMAIN ERROR, CANNOT ALLOCATE STORAGE FOR BUFFERS          *\n*                                                                     *\n***********************************************************************\n         PRINT NOGEN\nWAIT     CSECT\nWAIT     AMODE 31\nWAIT     RMODE ANY\n*---------------------------------------------------------------------*\n* DEFINE REGISTER EQUALS USING IBM STANDARD MACRO YREGS               *\n*---------------------------------------------------------------------*\n         YREGS\n*---------------------------------------------------------------------*\n* BUILD LINKAGE CONVENTION:                                           *\n* STEP 1: SAVE THE CURRENT REGISTERS TO CALLERS SAVE AREA             *\n* STEP 2: BUILD OUR OWN ADDRESSABILITY                                *\n* STEP 3: SAVE THE CALLERS ADDRESS (R13) INTO OUR SAVE AREA + 4       *\n* STEP 4: SAVE THE OUR STARTING ADDRESS INTO R13                      *\n*         THIS IS TO BUILD THE LINKAGE CHAIN                          *\n*---------------------------------------------------------------------*\n* ESTABLISH ADDRESSABILITY, USING R15 AS TEMPORARY BASE REGISTER\n         USING WAIT,R15           R15 IS CURRENT ADDRESS, USING IT\n         B     WAITSTRT           BRANCH AROUND CONSTANTS\n         DC    C'PROGRAM NAME(WAIT) '          MODULE IDENTIFIER\n         DC    C'COMPILE TIME(&SYSDATE &SYSTIME)'\n         DC    C'WAIT: WAIT with following EXEC PARM sytax: '\n         DC    C'COMPLETE(HHMMSSth),SUPRESS(HHMMSS) or SECONDS(SSSSS) '\n         DC    C'Design: Hunter Zhou, zhough2000@yahoo.com     '\nWAITSTRT DS    0H\n         SAVE  (14,12)            ; SAVE CALLER'S REGISTERS USING SAVE\n         LR    R12,R15            ; COPY THE CURRENT CSECT LOCATION\n         DROP  R15                ; DROP THE TEMPORARY USING\n         USING WAIT,R12           ;\n         MODID BRANCH=YES         ;\n* SAVE THE PARM ADDRESS INTO R4\n         LR    R4,R1              ; COPY THE PARM ADDR FROM R1 TO R4\n*---------------------------------------------------------------------*\n* DYNAMICALLY ALLOCATE STORAGE FOR DATA AREAS\n*---------------------------------------------------------------------*\n         GETMAIN RC,LV=DSALEN,LOC=BELOW ;ALLOCATE STORAGE DSALEN BYTES\n         LTR   R15,R15            ;TEST THE RETURN CODE\n         BNZ   MAINERR            ;IF FAILED, RETURN TO MAINERR\n         LR    R11,R1             ;ADDR OF ENTRY POINT\n         USING DSA,R11            ;USING R11 AS STOR ADDRESSING REGS.\n         ST    R13,SAVEAREA+4     ;SET OUR BACKWARD LINK\n         LA    R15,SAVEAREA       ;ADDR OF OUR SAVEAREA\n         ST    R15,8(R13)         ;SET CALLER'S FORWARD LINK\n         LR    R13,R15            ;ADDR OF OUR SAVEAREA\n*---------------------------------------------------------------------*\n* INITIALIZATION\n*---------------------------------------------------------------------*\n         XC    RETCODE,RETCODE    ; RESET RETURN CODE 0\n         XC    PKNUM1,PKNUM1      ; RESET PACKED NUMBER WITH 0\n         XC    PKNUM2,PKNUM2      ; RESET PACKED NUMBER WITH 0\n         MVC   DECNUM(8),CDECNUM  ; COPY 0S\n         MVC   TIMEBUF(8),HHMMSSHH ; COPY THE DEFAULT TIME\n*---------------------------------------------------------------------*\n* SAVE THE PARAMETER TO PRIVATE STORAGE (PARM AND PARMLEN)\n*---------------------------------------------------------------------*\n         L     R4,0(,R4)          ;START  OF PARM\n         LH    R9,0(,R4)          ;LENGTH OF PARM\n         LTR   R9,R9              ;R9 IS ZERO?\n         BZ    NOPARM             ;NO PARM GIVEN\n         LA    R10,2(,R4)         ;START OF PARM DATA\n         STH   R9,PARMLEN         ;COPY THE PARAMETER LENGTH TO PARMLEN\n         BCTR  R9,0               ;DECREMENT LENGTH BY 1\n         EX    R9,MVCPARM         ;COPY PARMATER TO PARM STORAGE\n*---------------------------------------------------------------------*\n* TEST THE PARM FORMAT\n* 1. THE LENGTH IS 8        : HHMMSSHH\n* 2. THE LENGTH IS 6        : HHMMSS\n* 5. THE LENGTH LESS THAN 6 : SSSSS     IN SECONDS\n*---------------------------------------------------------------------*\n* VERIFY IF ALL BYTES ARE DIGITS.\n         LH    R9,PARMLEN\n         LA    R3,PARM\nVERLOOP  CLI   0(R3),C'0'                                   ALL-DIGITS?\n         BL    WAITERR                                         NO, QUIT\n         LA    R3,1(0,R3)\n         BCT   R9,VERLOOP\n*---------------------------------------------------------------------*\n         LH    R9,PARMLEN\n         LA    R8,X'8'            ; LOAD THE LENGTH\n         CR    R9,R8\n         BE    WAITDINV           ; CONTINUE WITH DECIMAL INVERTAL\n         LA    R8,X'6'            ; LOAD THE LENGTH\n         CR    R9,R8\n         BE    WAITDINV           ; CONTINUE WITH DECIMAL INVERTAL\n         LA    R8,X'6'            ; LOAD THE LENGTH\n         CR    R9,R8\n         BL    WAITBINV           ; CONTINUE WITH BINARY INVERTAL\n* FOR PARM LENGTH GREAT THAN 6 BUT 8, RETURN WITH ERROR\n         B     WAITERR\n* PROCESS WAIT IN HHMMSSTH FORMAT\nWAITDINV EQU   *\n         LA    R6,TIMEBUF\n         LA    R7,PARM\n         LR    R5,R9\n         BCTR  R5,0\n         EX    R5,MVCREC          ; COPY THE TIME PARM\nVERCLOCK CLC   HHMMSSHH(2),=C'24'                            HOURS<=24?\n         BH    WAITERR                                         NO, QUIT\n         CLC   HHMMSSHH+2(2),=C'59'                        MINUTES<=59?\n         BH    WAITERR                                         NO, QUIT\n         CLC   HHMMSSHH+4(2),=C'59'                        SECONDS<=59?\n         BH    WAITERR                                         NO, QUIT\n         LA    R6,TIMEBUF\n         STIMER WAIT,DINTVL=(R6)         WAIT FOR TIME SPECIFIED\n         B     WAITEND\n* PROCESS WAIT IN SECONDS FORMAT\nWAITBINV EQU   *\n         LA    R6,DECNUM                 LOAD THE DECIMAL FORM BUFFER\n         LA    R6,1(0,R6)                SKIP FIRST BYTE\n         LA    R7,PARM                   LOAD SOURCE\n         LH    R5,PARMLEN                LOAD SOURCE LENGTH\n         LA    R4,5                      LOAD THE MAXIMUM LENGTH\n         SR    R4,R5                     GET THE ACTUAL COPY POSITION\n         AR    R6,R4                     MOVE R6 TO COPY POSITION\n         BCTR  R5,0                      DECREASE R5 BY 1\n         EX    R5,MVCREC                 COPY FROM PARM TO DECNUM\n         PACK  PKNUM2(4),DECNUM(8)       PACK THE 8 DIGIT DECIMALS\n         CVB   R5,PKNUM                  CONVERT DECIMAL TO BINARY R5\n         ST    R5,SCNDBUF                SAVE THE WAIT TIME TO SCNDBUF\n         LA    R6,SCNDBUF                SAVE THE WAIT TIME TO SCNDBUF\n         STIMER WAIT,BINTVL=(R6)         WAIT FOR TIME SPECIFIED\n         B     WAITEND\n* PROCESS AND SET RETURN CODES\nNOPARM   EQU   *\n         MVI   RETCODE,X'4'\n         B     WAITEND\nWAITERR  EQU   *\n         MVI   RETCODE,X'8'\n         B     WAITEND\nWAITEND  EQU   *\n         B     RETURN\nMAINERR  EQU   *\n         LA    R15,X'10'\n         B     MAINEXIT\n*---------------------------------------------------------------------*\n*  RETURN LINKAGE TO THE CALLER                                       *\n*---------------------------------------------------------------------*\nRETURN   EQU   *\n         XR    R9,R9\n         ICM   R9,B'0001',RETCODE   ;LOAD THE RETURN CODE TO R9\n         FREEMAIN RU,LV=DSALEN,A=(R11)  ; THE ALLOCATED STORAGE\n         LR    R15,R9               ;SAVE THE RETURN CODE TO R15\nMAINEXIT L     R13,4(R13)           ;ADDR OF CALLER'S SAVEAREA\n         RETURN (14,12),RC=(15)     ;RESTORE CALLER'S REGS AND RETURN\n*======================================================================\n         SPACE 3\n***********************************************************************\n* PROGRAM CONSTANTS --------------------------------------------------*\n***********************************************************************\n*======================================================================\nMVCREC   MVC   0(0,R6),0(R7)     ; COPY RECORD FROM R7 to R6,length R5\nMVCPARM  MVC   PARM(0),0(R10)     ;COPY THE PARAMETER TO STORAGE PARM\nHHMMSSHH DC    CL8'00000000'\nCDECNUM  DC    CL8'00000000'      ; DECIMAL BUFFER\n***********************************************************************\n* DATA STORAGE IN DYNAMIC MODE                                        *\n* THESE DATA STORAGES WILL BE UPDATED DURING EXECUTION.\n***********************************************************************\n         DS    0F\nDSA      DSECT\nSAVEAREA DS    18F                ;REGISTER SAVE AREA\nRETCODE  DS    XL1                ;RETURN CODE\n*\n         DS    0F\nPARMLEN  DS    H                  ;THE LENGTH OF THE PARM\nPARM     DS    CL126              ;PARAMETER FROM\n*\n         DS    0D\nTIMEBUF  DS    CL8                ; DINTVL FORMAT\nSCNDBUF  DS    F                  ; BINTVL FORMAT\n*\nPKNUM    DS    0XL8               ; 8 BYTES AREA\nPKNUM1   DS    XL4                ; ALIGNMENT ONLY SHOULD BE X'00'S\nPKNUM2   DS    XL4                ; PACKED NUMBER FROM DECNUM\nDECNUM   DS    CL8                ; DECIMAL BUF 00+5 IN parm + 00\nDSALEN   EQU   *-DSA\n*---------------------------------------------------------------------*\n*  END OF PROGRAM                                                     *\n*---------------------------------------------------------------------*\n.END     END   WAIT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASMWTO": {"ttr": 1027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01X\\x00\"\\x00\\x83\\x12?\\x01\\x06\\x11_\\t@\\x01m\\x00P\\x00\\x00\\xe9\\xc8\\xd6\\xe4@@@@@@'", "ispf": {"version": "01.88", "flags": 0, "createdate": "1983-05-03T00:00:00", "modifydate": "2006-04-25T09:40:22", "lines": 365, "newlines": 80, "modlines": 0, "user": "ZHOU"}, "text": "***********************************************************************\n* PROGRAM: WTO                                                        *\n* AUTHOR : Hunter Guanghui Zhou                                       *\n*          Phone: 1-(416)-602-9567                                    *\n*          E-mail: zhough2000@yahoo.com                               *\n* UPDATE : April 2003                                                 *\n* PURPOSE: Issue message to MVS console and SYSLOG.                   *\n* USAGE:                                                              *\n*    1. USING EXEC PARM.                                              *\n*       Send messages supplied in EXEC PARM to console.               *\n*       This is the primary choice.                                   *\n*       Sample JCL:                                                   *\n*                                                                     *\n*    //WTOMSG EXEC PGM=WTO,    issue normal WTO message               *\n*    //    PARM='Hello, this is a test WTO message.'                  *\n*    //WTOH   EXEC PGM=WTOH,   issue high lighted message             *\n*    //    PARM='System is IPLed, TSO user can logon on now.'         *\n*                                                                     *\n*    2. USING SYSIN DD                                                *\n*       Send messages supplied in SYSIN DD to console.                *\n*       This is the secondary choice.                                 *\n*       The SYSIN DD must be record length of 80                      *\n*       The maximum lines is defined at compile time.                 *\n*       Sample JCL:                                                   *\n*                                                                     *\n*    //WTOMSG EXEC PGM=WTO                                            *\n*    //SYSIN DD *                                                     *\n*    This is a test WTO message line 1.                               *\n*    This is a test WTO message line 2.                               *\n*    ...                                                              *\n*    /*                                                               *\n*                                                                     *\n* COMPILE:                                                            *\n*  This program is a re-entreent program, you can put this program    *\n*  in your system LPA (LPALSTxx) or LINKLST (PROGxx).                 *\n*  The linkedit should use RENT keyword to make it re-retreent.       *\n*  Compile Option                                                     *\n*  HILIGHT=   Tell whether to send high lighted WTO messages          *\n*  MAXLINE=   Tell the limit of lines in SYSIN DD to send to WTO.     *\n*                                                                     *\n*  Sample Compile JCL for normal WTO                                  *\n*  //jobcard                                                          *\n*  // SET  SRCLIB='SP2487.ASM.SOURCE',   <==PDS where source located  *\n*  //      LOADLIB='SYS1.TEST.LINKLIB'                                *\n*  //* WTO IS A REENTRENT PROGRAM                                     *\n*  //CPLCMDS  EXEC ASMACL,PARM.L='LIST,RENT',                         *\n*  //  PARM.C='SYSPARM(HILIGHT=0,MAXLINE=100)'                        *\n*  //C.SYSIN   DD DISP=SHR,DSN=&SRCLIB(WTO)                           *\n*  //C.SYSLIB  DD DISP=SHR,DSN=SYS1.MACLIB                            *\n*  //          DD DISP=SHR,DSN=SYS1.MODGEN                            *\n*  //L.SYSLMOD DD DISP=SHR,DSN=&LOADLIB                               *\n*  //L.SYSIN   DD *                                                   *\n*    NAME WTO(R)                                                      *\n*  /*                                                                 *\n*                                                                     *\n*  Sample Compile JCL for highlighted WTO:                            *\n*  //jobcard                                                          *\n*  // SET  SRCLIB='SP2487.ASM.SOURCE',   <==PDS where source located  *\n*  //      LOADLIB='SYS1.TEST.LINKLIB'                                *\n*  //* WTO IS A REENTRENT PROGRAM                                     *\n*  //CPLCMDS  EXEC ASMACL,PARM.L='LIST,RENT',                         *\n*  //  PARM.C='SYSPARM(HILIGHT=1,MAXLINE=100)'                        *\n*  //C.SYSIN   DD DISP=SHR,DSN=&SRCLIB(WTO)                           *\n*  //C.SYSLIB  DD DISP=SHR,DSN=SYS1.MACLIB                            *\n*  //          DD DISP=SHR,DSN=SYS1.MODGEN                            *\n*  //L.SYSLMOD DD DISP=SHR,DSN=&LOADLIB                               *\n*  //L.SYSIN   DD *                                                   *\n*    NAME WTOH(R)                                                     *\n*  /*                                                                 *\n*                                                                     *\n* Program Logic:                                                      *\n*  1. Program Setup                                                   *\n*  2. Test if any given PARM.                                         *\n*  3. If not, test any given SYSIN DD.                                *\n*  4. Build up WTO lists.                                             *\n*  5. Issue WTO message                                               *\n*                                                                     *\n***********************************************************************\n*        PRINT NOGEN\nWTO      TITLE 'WRITE MESSAGE TO CONSOLE AND SYSLOG'\nWTO      CSECT\nWTO      AMODE 31\nWTO      RMODE ANY\n* LOCAL CONSTANTS\n         LCLC  &HILITE,&MAXLINE\n&HILIGHT SETC  '&SYSPARM'(9,1)          FLAG TO HIGH LIGHT MESSAGE\n&MAXLINE SETC  '&SYSPARM'(19,*)           MAXIMUM LINES IN SYSIN\n***********************************************************************\n* COMPILE STAGE SYSPARM SYNTAX CHECKING\n***********************************************************************\n         AIF   ('&HILIGHT' NE '1' AND '&HILIGHT' NE '0').ERRHILT,      X\n               ('&MAXLINE' EQ '' OR '&MAXLINE' EQ '0').ERRMSGS\n         AGO   .START\n.ERRHILT MNOTE 12,'The high light (HILIGHT=&HILIGHT) is not 0 or 1.'\n         AGO   .END\n.ERRMSGS MNOTE 12,'The maximum WTO lines must between 1 and 9999.'\n         AGO   .END\n.START   ANOP\n*---------------------------------------------------------------------*\n* DEFINE REGISTER EQUALS USING IBM STANDARD MACRO YREGS               *\n*---------------------------------------------------------------------*\n         YREGS\n*---------------------------------------------------------------------*\n* BUILD LINKAGE CONVENTION:                                           *\n* STEP 1: SAVE THE CURRENT REGISTERS TO CALLERS SAVE AREA             *\n* STEP 2: BUILD OUR OWN ADDRESSABILITY                                *\n* STEP 3: SAVE THE CALLERS ADDRESS (R13) INTO OUR SAVE AREA + 4       *\n* STEP 4: SAVE THE OUR STARTING ADDRESS INTO R13                      *\n*         THIS IS TO BUILD THE LINKAGE CHAIN                          *\n*---------------------------------------------------------------------*\n* ESTABLISH ADDRESSABILITY, USING R15 AS TEMPORARY BASE REGISTER\n         USING WTO,R15            ; R15 IS CURRENT ADDRESS, USING IT\n         B     WTOSTART           Branch around constants\n         DC    CL23'PROGRAM NAME(WTO)'           Module identifier\n         DC    CL29'COMPILE TIME(&SYSDATE &SYSTIME)'\n         DC    CL48'WTO: Write Message to Console and SYSLOG'\n         DC    CL36'CONFIG: HIGHLIGHT(&HILIGHT) MAXLINES(&MAXLINE)'\n         DC    CL48'Design: Hunter Zhou, zhough2000@yahoo.com    '\nWTOSTART DS    0H\n         SAVE  (14,12)            ; SAVE CALLER'S REGISTERS USING SAVE\n         LR    R12,R15            ; COPY THE CURRENT CSECT LOCATION\n         DROP  R15                ; DROP THE TEMPORARY USING\n         USING WTO,R12            ;\n         MODID BRANCH=YES         ;\n* SAVE THE PARM ADDRESS INTO R2\n         LR    R2,R1              ; COPY THE PARM ADDR FROM R1 TO R2\n*---------------------------------------------------------------------*\n* DYNAMICALLY ALLOCATE STORAGE FOR DATA AREAS\n*---------------------------------------------------------------------*\n         GETMAIN RC,LV=DSALEN,LOC=BELOW ;ALLOCATE STORAGE DSALEN BYTES\n         LTR   R15,R15            ;TEST THE RETURN CODE\n         BNZ   MAINERR            ;IF FAILED, RETURN TO MAINERR\n         LR    R11,R1             ;ADDR OF ENTRY POINT\n         USING DSA,R11            ;USING R11 AS STOR ADDRESSING REGS.\n         ST    R13,SAVEAREA+4     ;SET OUR BACKWARD LINK\n         LA    R15,SAVEAREA       ;ADDR OF OUR SAVEAREA\n         ST    R15,8(R13)         ;SET CALLER'S FORWARD LINK\n         LR    R13,R15            ;ADDR OF OUR SAVEAREA\n*---------------------------------------------------------------------*\n* INITIALIZATION\n*---------------------------------------------------------------------*\n         XC    RETCODE,RETCODE    ; RESET RETURN CODE 0\n         MVC   WTOCMD(WTOMDLL),WTOMDL  ;COPY THE MVC MODEL TO MVCCMD\n* LOAD THE JOBNAME AS WTO PREFIX\n         LA    R9,TIOTA\n         EXTRACT (R9),'S',FIELDS=(TIOT),MF=(E,EXTRMFL) JOB NAME INFO\n         L     R9,TIOTA           TIOT ADDRESS\n         USING TIOT1,R9           TIOT ADDRESSABILITY\n         MVC   WTOJOBNM,TIOCNJOB  COPY THE JOBNAME AS CONSOL NAME\n         MVI   WTOSPACE,C' '      COPY ONE SPACE\n         DROP  R9\n*---------------------------------------------------------------------*\n* SAVE THE PARAMETER TO PRIVATE STORAGE (PARM AND PARMLEN)\n*---------------------------------------------------------------------*\n         L     R2,0(,R2)          ;START  OF PARM\n         LH    R9,0(,R2)          ;LENGTH OF PARM\n         LTR   R9,R9              ;R9 IS ZERO?\n         BZ    NOPARM             ;NO PARM GIVEN\n         LA    R10,2(,R2)         ;START OF PARM DATA\n         STCM  R9,B'0011',PARMLEN ;COPY THE PARAMETER LENGTH TO PARMLEN\n         BCTR  R9,0               ;DECREMENT LENGTH BY 1\n         EX    R9,MVCPARM         ;COPY PARMATER TO PARM STORAGE\n*---------------------------------------------------------------------*\n* SEND A MESSAGE TO CONSOLE USING WTO MESSAGE\n*---------------------------------------------------------------------*\n         BAL   R2,WTOPARM         ;CALL WTOPARM\n         B     RETURN\n* PROCESS SYSIN DD\nNOPARM   EQU   *\n         BAL   R2,WTOSYSIN        ;CALL WTOSYSIN\n         B     RETURN\nMAINERR  EQU   *\n         LA    R15,X'10'\n         B     MAINEXIT\n*---------------------------------------------------------------------*\n*  RETURN LINKAGE TO THE CALLER                                       *\n*---------------------------------------------------------------------*\nRETURN   EQU   *\n*  AS FREE ALLOCATION WILL USE R15, JUST LOAD TO R9 TEMPORARILY\n         XR    R9,R9\n         ICM   R9,B'0001',RETCODE   ;LOAD THE RETURN CODE TO R9\n*  FREE ANY ALLOCATION HERE ...\n         FREEMAIN RU,LV=DSALEN,A=(R11)  ; THE ALLOCATED STORAGE\n*  LOAD THE RETURN CODE TO R15.\n         LR    R15,R9               ;SAVE THE RETURN CODE TO R15\nMAINEXIT L     R13,4(R13)           ;ADDR OF CALLER'S SAVEAREA\n         RETURN (14,12),RC=(15)     ;RESTORE CALLER'S REGS AND RETURN\n***********************************************************************\n* ROUTINE: WTOPARM                                                    *\n* PURPOSE: SEND WTO MESSAGE FOR EXEC PARM                             *\n* INPUT  :                                                            *\n*    R2  : RETURN CONTROL                                             *\n*    R2  : RETURN CONTROL                                             *\n***********************************************************************\nWTOPARM  EQU   *\n         SR    R9,R9               ;CLEAR R9\n         ICM   R9,B'0011',PARMLEN  ;LOAD THE PARAMETER LENGTH TO R9\n         LA    R10,PARM            ;LOAD PARAMETER ADDRESS TO R10\n         BCTR  R9,0                ;DECREMENT LENGTH BY 1\n         EX    R9,MVCWTO           ;COPY PARMATER TO WTO  STORAGE\n         LA    R9,10(0,R9)         ;INCREASE R9 BY 9 JOBNAME + SPACE\n         STH   R9,WTOLEN           ;COPY PARAMETER LENGTH TO WTOLEN\n         BAL   R3,WTOBRDR          SHOW THE MESSAGE BORDER\n         BAL   R3,WTOWRITE         SHOW THE MESSAGE ON CONSOLE\n         BAL   R3,WTOBRDR          SHOW THE MESSAGE BORDER\n         BR    R2\n***********************************************************************\n* ROUTINE: WTOSYSIN                                                   *\n* PURPOSE: SEND WTO MESSAGE FOR SYSIN DD                              *\n* INPUT  :                                                            *\n*    R2  : RETURN CONTROL                                             *\n***********************************************************************\nWTOSYSIN DS    0H\n* INITIAL SYSIN DCB/DCBE\n         MVC   SYSIN(CSYSINL),CSYSIN       COPY DCB\n         MVC   SINDCBE(CSINDCEL),CSINDCBE  COPY DCBE\n         MVC   SINOPLST(CSINOPLL),CSINOPL  COPY OPEN LIST\n         LA    R4,SINDCBE\n         ST    R4,SYSIN+(DCBDCBE-IHADCB)   UPDATE DCBE IN DCB\n         LA    R4,SYSIN\n         ST    R4,SINOPLST+4               UPDATE DCB IN OPEN LIST\n* OPEN THE SYSIN\n         OPEN  (SYSIN,(INPUT)),MODE=31,MF=(E,SINOPLST)  OPEN THE DCB\n         LTR   R15,R15            OPEN SUCCESSFULLY?\n         BNZ   WTOSWARN           NO, SYSIN DD NOT SPECIFIED\n         L     R4,MAXLINE         MAX NO. OF MESSAGES IN SYSIN\n         LA    R8,WTOMSG          LOAD THE WTO MESSAGE BUFFER\n         BAL   R3,WTOBRDR         SHOW THE MESSAGE BORDER\nWTOSGET  GET   SYSIN,(R8)         GET ONE MESSAGE RECORD\n         LR    R6,R8              LOAD THE START POSITION\n         LA    R5,79              CHECK OF MESSAGE TEXT LENGTH 80\n         AR    R6,R5              MOVE TO THE END OF MESSAGE\nWTOSCHK  CLI   0(R6),C' '         BLANK?\n         BNE   WTOS001            NO, LAST CHAR OF MESSAGE?\n         BCTR  R6,0               MOVE TO NEXT CHAR\n         BCT   R5,WTOSCHK         CHECK NEXT CHARACTER\nWTOS001  EQU   *\n         LA    R5,10(0,R5)        ADD 10 TO MESSAGE LENGTH\n         STH   R5,WTOLEN          COPY PARAMETER LENGTH TO WTOLEN\n         BAL   R3,WTOWRITE        SHOW THE MESSAGE ON CONSOLE\n         BCT   R4,WTOSGET         GET NEXT MESSAGE RECORD\n* CLOSE THE SYSIN WITH THE SAME LIST FORM AS OPEN MACRO\nSYSINEOF EQU      *\n         BAL   R3,WTOBRDR         SHOW THE MESSAGE BORDER\n         CLOSE SYSIN,MODE=31,MF=(E,SINOPLST)\n         B     WTOSEND\nWTOSWARN EQU   *\n         MVI   RETCODE,X'04'\nWTOSEND  EQU   *\n         BR    R2\n***********************************************************************\n* ROUTINE: WTOWRITE                                                   *\n* PURPOSE: SEND WTO MESSAGE FOR ALL CASES                             *\n* INPUT  :                                                            *\n*    R3  : RETURN CONTROL                                             *\n***********************************************************************\nWTOWRITE EQU   *\n         LA    R9,WTOAREA\n         CLI   HILIGHT,X'01'   NEED A HIGH LIGHT MESSAGE?\n         BNE   WTOWNHL         NO, JUST SEND NORMAL WTO MESSAGE\n         WTO   TEXT=(R9),ROUTCDE=(2),DESC=(11),                        X\n               MCSFLAG=(BUSYEXIT,BRDCST),MF=(E,WTOCMD)\n         B     WTOWEND\nWTOWNHL  EQU   *               NON-HIGHLIGHT NORMAL MESSAGES\n         WTO   TEXT=(R9),MF=(E,WTOCMD)\nWTOWEND  EQU   *\n         BR    R3\n***********************************************************************\n* ROUTINE: WTOBRDR                                                    *\n* PURPOSE: SHOW WTO MESSAGE BORDER                                    *\n* INPUT  :                                                            *\n*    R3  : RETURN CONTROL                                             *\n***********************************************************************\nWTOBRDR  EQU   *\n         WTO   '*******************************************************X\n               ******'\n         BR    R3\n***********************************************************************\n*  PROGRAM CONSTANTS\n*---------------------------------------------------------------------*\nHILIGHT  DC    X'0&HILIGHT'        ;WHETHER THE MESSAGES ARE HIGH LIGHT\nMAXLINE  DC    A(&MAXLINE)        ;MAXIMUM MESSAGES IN LINES\nMVCPARM  MVC   PARM(0),0(R10)     ;COPY THE PARAMETER TO STORAGE PARM\nMVCWTO   MVC   WTOMSG(0),0(R10)   ;COPY THE WTO MESSAGE TO WTOMSG\n         AIF   ('&HILIGHT' EQ '1').AMDLHI\nWTOMDL   WTO   TEXT=,MF=L\n         AGO   .AMDLEND\n.AMDLHI  ANOP\nWTOMDL   WTO   TEXT=,ROUTCDE=(2),DESC=(11),                            X\n               MCSFLAG=(BUSYEXIT,BRDCST),MF=L\n.AMDLEND ANOP\nWTOMDLL  EQU   *-WTOMDL           ;LENGTH OF WTO MODEL\n*---------------------------------------------------------------------*\n* CSYSIN   CONSTANT DCB/DCBE/OPENLIST\n* CSYSIN   CONSTANT DCB FOR SYSIN DD WITH READ\n*---------------------------------------------------------------------*\nCSYSIN   DCB   DSORG=PS,                                               X\n               MACRF=GM,                                               X\n               DDNAME=SYSIN,                                           X\n               RECFM=FB,                                               X\n               LRECL=80,                                               X\n               DCBE=CSINDCBE\nCSYSINL  EQU   *-CSYSIN                LENGTH OF THE OPENLIST\nCSINDCBE DCBE  RMODE31=BUFF,EODAD=SYSINEOF\nCSINDCEL EQU   *-CSINDCBE\nCSINOPL  OPEN  (CSYSIN,(INPUT)),MODE=31,MF=L\nCSINOPLL EQU   *-CSINOPL               LENGTH OF THE OPENLIST\n***********************************************************************\n*---------------------------------------------------------------------*\n* DATA STORAGE IN DYNAMIC MODE                                        *\n* THESE DATA STORAGES WILL BE UPDATED DURING EXECUTION.\n*---------------------------------------------------------------------*\n* DUMMY SECTION\n         DS    0F\nDSA      DSECT\nSAVEAREA DS    18F                ;REGISTER SAVE AREA\nRETCODE  DS    XL1                ;RETURN CODE\n*WTO AREA\n         DS    0F\nWTOAREA  DS    0CL128\nWTOLEN   DS    AL2                ;WTO MESSAGE LENGTH\nWTOJOBNM DS    CL8                ;JOBNAME AS PREFIX\nWTOSPACE DS    CL1                ;SPACE\nWTOMSG   DS    CL118              ;WTO MESSAGE BUFFER, MAX 117 BYTES.\n*\n         DS    0F\nPARMLEN  DS    AL2                ;THE LENGTH OF THE PARM\nPARM     DS    CL126              ;PARAMETER FROM\n*\n*TIOT AREA\nTIOTA    DS    F                  TIOT ADDRESS\n* MACRO LIST FORMS\nEXTRMFL  EXTRACT MF=L                      ;EXTRACT JOB NAME INFO\n         AIF   ('&HILIGHT' EQ '1').AMDLHI2\nWTOCMD   WTO   TEXT=,MF=L\n         AGO   .AMDLEN2\n.AMDLHI2 ANOP\nWTOCMD   WTO   TEXT=,ROUTCDE=(2),DESC=(11),                            X\n               MCSFLAG=(BUSYEXIT,BRDCST),MF=L\n.AMDLEN2 ANOP\n*\n*---------------------------------------------------------------------*\n* SYSIN  DCB/DCBE/OPEN LIST FORM\n* THE DCB MUST BE ALLOCATED BELOW 16MB LINE,\n* SO THE GETMAIN FOR THIS DSECT MUST CODE LOC=BELOW\n*---------------------------------------------------------------------*\nSYSIN    DCB   DSORG=PS,MACRF=GM,DDNAME=SYSIN,                         X\n               RECFM=FB,LRECL=80,DCBE=CSINDCBE\nSINDCBE  DCBE  RMODE31=BUFF,EODAD=SYSINEOF\nSINOPLST OPEN  (CSYSIN,(INPUT)),MODE=31,MF=L\nDSALEN   EQU   *-DSA\n*---------------------------------------------------------------------*\n*  SYSTEM DSECTS AND MACROS                                           *\n*---------------------------------------------------------------------*\nTIOT     DSECT\n         IEFTIOT1\n*  SYSTEM DSECTS FOR DCB/DCBE\n*        'Data Control Block (DCB)'\n         DCBD  DSORG=PS,DEVD=DA\n*        'DCB Extension (DCBE)'\n         IHADCBE\n*---------------------------------------------------------------------*\n*  END OF PROGRAM                                                     *\n*---------------------------------------------------------------------*\n.END     END   WTO\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "AUTOIPL": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x12\\x01\\x04\\x00\\x9f\\x01\\x06\\x11_\\tB\\x04u\\x04x\\x00\\x00\\xe9\\xc8\\xd6\\xe4@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-01-09T00:00:00", "modifydate": "2006-04-25T09:42:12", "lines": 1141, "newlines": 1144, "modlines": 0, "user": "ZHOU"}, "text": "/*REXX*/\n/* PROGRAM: AUTOIPL\n   Purpose: Automatic IPL and Shutdown procedure.\n   Syntax : AUTOIPL\n            All commands should be put in SYSIN DD.\n   Example: See below.\n\nAUTOIPL USER GUIDE\n==================\n\nIntroduction\n------------\n  AUTOIPL is a package to automate your shutdown and IPL procedure.\nThis package is a free license and open source package.\n\nThe package has following feature:\n  1. Automatic shutdown the system in proper sequence.\n     After a single command (S SHUTDOWN), the system will be completely\n     shutdown and ready to power off or re-IPL.\n\n  2. Safe to shutdown.\n     As AUTOIPL will not shutdown until all running tasks are stopped,\n     It's safe by issuing the command by mistake.\n\n  3. Proper Messages.\n     The package will show the proper messages to indicate the\n     status of the procedure.\n\n  4. Automatic IPL\n     After system IPLed, the start tasks will be started in proper\n     sequence. There is no user intervention required.\n\nComments\n--------\n Any words beyond '#' will be comments and ignored.\n You can put a '#' at the beginning of the line to comment it out.\n Or. you can put comments at the end of statements.\n\n Examples:\n\n # First Phase: stop most applications.\n # ...\n # Wait 1 minute.\n WAIT 60\n ...\n P TCPIP      # Stop TCP/IP and TCP/IP dependent tasks.\n\n Any space before or after each command will be ignored.\n Any empty line will be ignored.\n\nMVS Commands\n------------\n Each MVS command must be within 70 charaters.\n The AUTOIPL will check the command length and ignore the command\n exceeds 70 characters.\n\nStatements\n----------\n You can put commands in multiple line, for example:\n         STOP(NPFFWTR ,'$PPRT6',\n                       '$PPRT7',\n                       '$PPRT8')\n You must put comma(,) to tell the command continues next line.\n This example is the same as:\n         STOP(NPFFWTR ,'$PPRT6','$PPRT7','$PPRT8')\n\nSpecial Commands\n----------------\n Normally, the statements are treated as MVS system command and\n AUTOIPL will issue it for to system.\n\n There are some special statements.\n\n a. WAIT\n\n    If you need to wait, code following line:\n       WAIT\n    or WAIT seconds\n\n    Specify wait time in seconds, i.e. 'WAIT 300' for 5 minutes.\n\n    There is a special function for WAIT statement. The WAIT statement\n    will also check the completion of previous commands.\n    For shutdown, the WAIT will tell AUTOIPL to wait for the termination\n    of all tasks issued by STOP commands.\n\n    You should use WAIT command when you need to stop tasks in sequence.\n\n    i.e. Stop RMF TCP/IP Server before stop RMF:\n\n    P GPMSERVE     # issue STOP RMF TCP/IP Server command\n    WAIT 30        # WAIT at leat 30 seconds and checking GMPSERVE.\n    P RMF          # stop RMF and RMF III\n\n b. END\n\n    If you need to specify end of the parameter member explicitely,\n    use following statement:\n       END\n    Any line beyond this line will be ignored.\n\n\n c. REPLY or R\n\n    If you need to stop address space by REPLY command,\n    you can specify them by keyword instead of reply number.\n        R keyword,command\n    For example:\n        R EZY0960I,STOP\n    The program will look up the keyword 'EZY0960I' and it's reply\n    number in reply list, and replace the keyword with the number nn,\n    and issue the MVS command:\n        R nn,STOP\n\n    If the keyword is a number, the program will not\n    translate it, it will issue it as a REPLY command.\n\n    If the keyword is a string with space or comma,\n    use quote around the keyword, i.e.:\n        R 'JES328Z - ENTER COMMAND',END\n\n c. STOP\n\n    If you need to issue some special command to shutdown some tasks,\n    use following format:\n\n        STOP(addrname,'command1','command2',CHECK/NOCHECK)\n\n    addrname is the address space name to stop,\n    if this is a hook, just code the start task name.\n    The default option is CHECK, which will check if the given\n    task is running for STOP/MODIFY/CANCEL commands. If the\n    task is not running and option is CHECK or omitted,\n    these commands will not be issued.\n    For some special tasks (FFST), you need code NOCHECK to\n    provent checking FFST's running status before issuing the\n    STOP command because the task name for FFST is EPWFFST.\n    for example:\n          i.  STOP(NPFFWTR,'$PPRT6','$PPRT7','$PPRT8')\n\n         ii.  STOP(DMSAR   ,'S DMSAR,DMSAR=REMOVE')\n            DMSAR is a hook, the program will wait until this\n            DMSAR started task stops.\n\n        iii.  STOP(none    ,'P FFST',NOCHECK)\n              WAIT 10\n              STOP(EPWFFST ,'R EPW0309I,YES')\n\n            Issue STOP FFST, then FFST will issue a reply message,\n            Wait 10 seconds, and reply the message as 'YES'.\n\n e. If you need to wait some task to stop/start without issuing\n    any command (command may be issued before), use following\n    comamnd:\n              WAIT(taskname, STOP/START)\n    The program will detect and wait till the taskname is started or\n    stopped.\n    This feature is useful for those tasks needs a long time to stop.\n\n    Example:\n        STOP(NONE, 'P SLS0')\n         ...\n        WAIT(60)\n         ...\n        WAIT(SLS0, STOP)\n         ...\n        WAIT(10)\n          This technique will use 2 or more stages to allow the task\n          to stop.\n f WTO and WTOH\n   If you need to write console message, use command:\n        WTO('message')\n    or\n        WTO(message)\n   You can use WTOH to issue high light messages\n\n\nConfiguration Statements\n------------------------\n\n   There are some settings control how the program runs.\n\n        CONFIG(keyword)= value\n\n   keyword are:\n     a.OPTION   The options are :\n                IPL           : Tell this is a IPL procedure\n                SHUTDOWN      : Tell this is a SHUTDOWN procedure\n                VALIDATE_ONLY : Validate the commands only.\n                                No MVS command will be issued.\n                                This is for test purpose.\n                The default value is none.\n\n     b.TIMEOUT  The timeout value in seconds.\n                The timeout will be used for waiting for task to stop\n                The default timeout is 300\n\n     c.EXCLUDE_TASK  This is the address space name which will be\n                excluded when the program checking running task.\n                You can specify multiple EXCLUDE_TASK.\n                The default tasks are FTPD, INETD and SYSLOGD\n                These tasks normally are TSO or BATCH jobs.\n\n   For shutdown, the AUTOIPL will check if there is any running\n   jobs. If any, it will issue a console message to show the running\n   task, and check it every 1 minute. All commands will not be issued\n   until these running tasks stops.\n\n   For some environment, there are some running batch jobs or TSO\n   users as part of system running task, not user batch jobs.\n   The example are TCP/IP FTPD, INETD and SYSLOGD.\n   In order to bypass checking these tasks, you need to use\n   CONFIG(EXCLUDE_TASK) to bypass them at shutdown parameter member.\n\n   The CONFIG statement can be anywhere in the parameter member.\n\nQuestions & suggestions\n=======================\n Should you have any question, please contact Hunter Zhou at\n zhough2000@yahoo.com\n\n April, 2003\n\n Hunter Guanghui Zhou\n Phone: 1-(416)-602-9567\n E-mail: zhough2000@yahoo.com\n\n*/\nmain:\n  parse arg mainargs\n  x=Initialization()\n  Code=Read_Parameters(mainargs)\n  if Code\\=0 then call Program_Ends(Code)\n  Code=Process_Inputs()\n  call Program_Ends(Code)\n/* End of Main Program */\n\n/*===================================================================*/\nInitialization:\n\n  TimeOut = 300      /* default timeout in seconds. */\n  /* Put all job exclusion list here.\n     All jobs listed here will be ignored when detecting\n     running jobs. This is for SHUTDOWN validation.\n  */\n  drop JobExcludeList. StartCmds.\n  JobExcludeList.0 = 0    /* Total Number of exclusion job names. */\n  Code=0                  /* Maximum return code */\n  Title='AUTOIPL Software'\n  x=WriteLog('ATI000I Welcome to 'Title)\n  x=WriteLog('ATI000I Author: Hunter Zhou             ')\n  x=WriteLog('ATI000I Contact: zhough2000@yahoo.com.    ')\n  x=WriteLog('ATI000I Update: November, 2003')\n\nreturn 0\n\n/*===================================================================*/\nRead_Parameters:\n  parse arg args\n  rcode=0\n  drop Lines.\n  if args \\= '' then do /* one command is provided in command option.*/\n    args = strip(args)\n    upper args\n    StartCmds.0 = 1\n    StartCmds.1 = args\n    return rcode\n  end\n  if \\CheckDDName('SYSIN') then do\n    x=WriteLog('ATI002E There is no SYSIN DD allocated and no command option.')\n    rcode=8\n    return rcode\n  end\n  \"EXECIO * DISKR SYSIN (STEM LINES. FINIS\"\n  if RC>0 then do\n     rcode=RC\n     x=WriteLog('ATI003E Cannot read the SYSIN DD.')\n  end\n  if Lines.0 < 1 then do\n     x=WriteLog('ATI004E The SYSIN DD is empty.')\n     rcode=8\n  end\n\n  if rcode\\=0 then return rcode\n  icmd=0\n  continue_line = 0 /* flag of continuous line. */\n  do il=1 to Lines.0\n    line = strip(Lines.il)\n    if line = '' then iterate\n    if left(Line,1) == '#' then iterate\n    if pos('#', line) > 0 then\n       line = strip(substr(line,1,pos('#',line)-1))\n    upline = line\n    upper upline\n    if upLine == 'END' then leave\n\n    if pos('CONFIG(', upline)  == 1 |,\n       pos('CONFIG.', upline)  == 1 then do /* configuration */\n       call Read_Configuration upline\n       iterate\n    end\n    if \\continue_line then do\n       icmd=icmd+1\n       StartCmds.icmd = line\n    end\n    else StartCmds.icmd = StartCmds.iCmd||line\n    if right(upline,1) == ',' then continue_line = 1\n    else continue_line = 0\n  end\n  StartCmds.0=icmd\n  if icmd == 0 then do\n    x=WriteLog('ATI005W The SYSIN DD contains no MVS commands.')\n    rcode = 4\n  end\nreturn rcode\n\nRead_Configuration: Procedure expose JobExcludeList. TimeOut StartOption\n  parse arg configline\n  if pos('CONFIG(', configline) == 1 then\n     parse var configline 'CONFIG(' keyword ')' rest '=' value\n  else\n     parse var configline 'CONFIG.' keyword '=' value\n\n  keyword = strip(keyword)\n  value = strip(value)\n  if keyword == '' | value == '' then do\n      x=WriteLog('ATI040E The configuration line of',\n                 keyword' is invalid and skipped.')\n      return\n  end\n  select\n    when keyword == 'OPTION' then do\n       if value == 'IPL' | value == 'SHUTDOWN' |,\n          value == 'VALIDATE' | value == 'VALIDATE_ONLY' then do\n          x=WriteLog('ATI041I Read option value as' value)\n          StartOption = value\n       end\n       else x=WriteLog('ATI042E OPTION value is invalid.')\n    end\n    when keyword == 'TIMEOUT' then do\n       if datatype(value,'N') then do\n          x=WriteLog('ATI041I Read timeout value as' value)\n          TimeOut = Value\n       end\n       else x=WriteLog('ATI042E TIMEOUT value is invalid.')\n    end\n    when keyword == 'EXCLUDE_TASK' then do\n       found = 0\n       do iJL=1 to JobExcludeList.0\n          if JobExcludeList.iJL == value then do\n             found = 1\n             leave\n          end\n       end\n       if \\found then do /* new exclude task. */\n          found = JobExcludeList.0\n          found = found + 1\n          JobExcludeList.found = value\n          JobExcludeList.0 = found\n          x=WriteLog('ATI043I Read an exclusion task:' value)\n       end\n       else x=WriteLog('ATI044I Read an existing exclusion task:' value)\n    end\n    otherwise:\n      x=WriteLog('ATI045E The configuration line of',\n                 keyword' is invalid and skipped.')\n  end\n  return\n/*===================================================================*/\n/*Issue MVS console commands.\n   the console response is saved in array CON_MSG.\n */\nProcess_Inputs:\n  ConCode = 0\n  drop Item_Cmd. Item_Name. Item_Status. Item_Type.\n  if StartOption == 'SHUTDOWN' then do\n      ConCode = Test_ShutdownCondition()\n      if ConCode\\=0 then return ConCode\n  end\n  ii=0\n  Item_Cmd.0=0\n  do icmd=1 to StartCmds.0\n    ConCmd = StartCmds.icmd\n    upper ConCmd\n    x=writelog('ATI050I Processing Statement: 'StartCmds.icmd)\n\n    if ConCmd == 'WAIT' | pos('WAIT(',ConCmd)==1 |,\n       pos('WAIT ',ConCmd) == 1 then do\n       if ii>0 then do\n          Item_Cmd.0 = ii\n          x=Process_PartialCommands()\n       end\n       parse var ConCmd 'WAIT' WaitSeconds\n       WaitSeconds = strip(WaitSeconds)\n       if pos('(', WaitSeconds) then\n          parse var WaitSeconds '(' WaitSeconds ')'\n       WaitSeconds = strip(WaitSeconds)\n       if WaitSeconds == '' |,\n          datatype(WaitSeconds, 'N') == 1 then do /* wait in seconds */\n          if WaitSeconds \\= '' then do\n            if pos('VALIDATE',StartOption)==0 then do\n               x=WriteLog(\"ATI060I Wait \"WaitSeconds\" seconds.\")\n               x=wait(WaitSeconds)\n            end\n            else do\n               x=WriteLog(\"ATI061W Wait is skipped for validation.\")\n            end\n          end\n       end\n       else do /* wait task to stop/start */\n         parse var WaitSeconds TaskName ',' WaitOpt\n         TaskName       = strip(TaskName)\n         WaitOpt        = strip(WaitOpt)     /* STOP START */\n         if WaitOpt \\= 'STOP' & WaitOpt \\= 'START' then do\n            x=WriteLog('ATI062E The WAIT option is invalid:' ConCmd)\n            x=WriteLog('ATI063W This WAIT Command is skipped.')\n         end\n         else do\n            ii = ii + 1\n            Item_Name.ii   = TaskName\n            Item_Status.ii = 'RUNNING'\n            Item_Type.ii   = WaitOpt\n            Item_Cmd.ii    = ''\n            Item_Cmd.0     = ii\n         end\n      end\n      if ii > 0 then do\n         x=Test_PartialCommands()\n         if x>ConCode then ConCode = x\n         drop Item_Cmd. Item_Name. Item_Status. Item_Type.\n         ii=0\n         if ConCode > 0 then return ConCode\n      end\n      iterate\n    end  /* IF */\n\n\n    ii = ii + 1\n    Item_Cmd.ii    =ConCmd    /* MVS command */\n    Item_Name.ii   =''        /* Related Address Space name */\n    Item_Status.ii ='PENDING' /* PEDING/RUNNING/FINISHED */\n    Item_Type.ii   ='OTHER'\n    Validate = 1\n\n    select\n      when pos('STOP(', ConCmd) == 1 then do /* STOP() command */\n         parse var ConCmd 'STOP(' TaskName ',' CmdLists ')'\n         TaskName = strip(TaskName)\n         CmdLists = strip(CmdLists)\n         Validate = 1\n         select\n           when pos('\"', CmdLists) > 0 then\n                quote = substr(CmdLists, pos('\"', CmdLists), 1)\n           when pos(\"'\", CmdLists) > 0 then\n                quote = substr(CmdLists, pos(\"'\", CmdLists), 1)\n           otherwise quote = '' /* There is no quote */\n         end /* select */\n\n         /* Check if any CHECK/NOCHECK keyword. */\n         if right(CmdLists,1) \\= \"'\" & right(CmdLists,1) \\= '\"' &,\n            pos(\",\", CmdLists) > 0 then do\n            CmdList2 = reverse(CmdLists)\n            parse var CmdList2 Validate ',' CmdLists3\n            CmdLists3 = reverse(strip(CmdLists3))\n            Validate = reverse(strip(Validate))\n            OneCmd = CmdLists3\n            select\n               when Validate == 'NOCHECK' then Validate = 0\n               when Validate == 'CHECK' then Validate = 1\n               otherwise OneCmd = CmdLists\n            end\n            CmdLists = OneCmd\n         end\n         CmdLists = strip(CmdLists)\n         do while CmdLists \\= ''\n            /* remove any leading , and quote */\n            do while left(CmdLists,1) == \",\" | left(CmdLists,1) == quote\n               CmdLists = strip(substr(CmdLists, 2))\n            end\n            do while right(CmdLists,1) == \",\" | right(CmdLists,1) == quote\n               CmdLists = strip(substr(CmdLists, 1, length(CmdLists)-1))\n            end\n\n            select\n               when quote == \"'\" then\n                 parse var CmdLists OneCmd \"'\" CmdLists\n               when quote == '\"' then\n                 parse var CmdLists OneCmd '\"' CmdLists\n               otherwise do /* no quote */\n                 OneCmd   = CmdLists\n                 CmdLists = ''\n               end\n            end /* select */\n            CmdLists = strip(CmdLists)\n            OneCmd   = strip(OneCmd)\n            Item_Name.ii   =TaskName\n            Item_Status.ii ='PENDING'\n            Item_Type.ii   ='STOP'\n            Item_Cmd.ii    = OneCmd\n            if CmdLists\\='' & Validate == 1 then do\n               OneCmd=Validate_Command(Item_Cmd.ii)\n               if OneCmd \\= '' then do\n                  Item_Cmd.ii = OneCmd\n                  ii = ii+1\n               end\n               else do /* remove this command from list */\n                  Item_Cmd.ii = ''\n                  ii = ii-1\n               end\n               do while left(CmdLists,1)==\",\" | left(CmdLists,1)==quote\n                  CmdLists = strip(substr(CmdLists, 2))\n               end\n            end\n         end\n      end\n      when pos('CANCEL(', ConCmd) == 1 then do /* CANCEL() command */\n         parse var ConCmd 'CANCEL(' TaskName ')'\n         TaskName = strip(TaskName)\n         parse value Get_RunningTask(TaskName) with . . taskasid\n         if Taskasid == '' then do\n            x=WriteLog('ATI064E The task' TaskName 'is not running.')\n            x=WriteLog('ATI065W This CANCEL command is skipped.')\n            ii = ii - 1\n         end\n         else do\n            Item_Name.ii   =TaskName\n            Item_Status.ii ='PENDING'\n            Item_Type.ii   ='STOP'\n            Item_Cmd.ii    ='CANCEL 'TaskName',A='TaskAsid\n            x=WriteLog('ATI066I Cancel command is translated to:')\n            x=WriteLog('ATI066I 'Item_Cmd.ii)\n         end\n      end\n      when pos('WAIT(', ConCmd) == 1 then do /* WAIT() command */\n         parse var ConCmd 'WAIT(' TaskName ',' WaitOpt \")\"\n         TaskName       = strip(TaskName)\n         WaitOpt        = strip(WaitOpt)     /* STOP START */\n         if WaitOpt \\= 'STOP' & WaitOpt \\= 'START' then do\n            x=WriteLog('ATI067E WAIT option is invalid:' ConCmd)\n            x=WriteLog('ATI068W This WAIT Command is skipped.')\n            ii = ii - 1\n         end\n         else do\n            Item_Name.ii   = TaskName\n            Item_Status.ii = 'RUNNING'\n            Item_Type.ii   = WaitOpt\n            Item_Cmd.ii    = ''\n            if ii > 0 then do\n               x=Test_PartialCommands()\n               if x>ConCode then ConCode = x\n               drop Item_Cmd. Item_Name. Item_Status. Item_Type.\n               ii=0\n               if ConCode > 0 then return ConCode\n            end\n         end\n      end\n      when pos('WTO(', ConCmd) == 1 then do /* WTO() command */\n         parse var StartCmds.iCmd rest \"(\" WTOMsg \")\"\n         WTOMsg = strip(WTOMsg)\n         if pos(\"'\", WTOMsg) == 1 | pos('\"', WTOMsg) == 1 then do\n            WTOMsg = substr(WTOMsg, 2, length(WTOMsg)-2)\n         end\n         Item_Type.ii   = 'WTO'\n         Item_Cmd.ii    = WTOMsg\n      end\n      when pos('WTOH(', ConCmd) == 1 then do /* WTOH() command */\n         parse var StartCmds.iCmd rest \"(\" WTOMsg \")\"\n         WTOMsg = strip(WTOMsg)\n         if pos(\"'\", WTOMsg) == 1 | pos('\"', WTOMsg) == 1 then do\n            WTOMsg = substr(WTOMsg, 2, length(WTOMsg)-2)\n         end\n         Item_Type.ii   = 'WTOH'\n         Item_Cmd.ii    = WTOMsg\n      end\n      when pos('STOP ',   ConCmd) == 1 | pos('P ', ConCmd) == 1 |,\n           pos('CANCEL ', ConCmd) == 1 | pos('C ', ConCmd) == 1 |,\n           pos('START ',  ConCmd) == 1 | pos('S ', ConCmd) == 1 then do\n        parse var ConCmd command ' ' adspname\n        adspname = strip(substr(adspname,1,8)) /* The max length is 8 */\n        if pos(' ',adspname) > 0 then\n           parse var adspname adspname ' ' rest\n        if pos(',',adspname) > 0 then\n           parse var adspname adspname ',' rest\n        Item_Name.ii =adspname\n        if command=='START' | command=='S' then Item_Type.ii ='START'\n        else Item_Type.ii = 'STOP'\n      end\n      otherwise NOP  /* All other commands */\n    end /*select */\n\n    /* If the command is not WAIT and WTO, validate the command. */\n    if Item_Status.ii \\= 'RUNNING' & Item_Type.ii \\= 'WTO' &,\n       Item_Type.ii \\= 'WTOH' &,\n       Validate == 1 & Item_Cmd.ii \\= '' then do\n       ConCmd=Validate_Command(Item_Cmd.ii)\n       if ConCmd \\= '' then Item_Cmd.ii = ConCmd\n       else ii = ii-1  /* skip invalid command. */\n    end\n  end /* do */\n\n  if ii > 0 then do\n     Item_Cmd.0 = ii\n     x=Process_PartialCommands()\n     if x>ConCode then ConCode = x\n     x=Test_PartialCommands()\n     if x>ConCode then ConCode = x\n     if ConCode > 0 then return ConCode\n  end\n  drop Item_Cmd. Item_Name. Item_Status. Item_Type.\nreturn ConCode\n\n/* Validate the commands.\n   if true, return validated command (command may be changed)\n   if false, return \"\"\n*/\nValidate_Command:\n  parse arg ConCmd\n  select\n   /* plug-in: Test for active address spaces command. */\n   when pos('STOP ', ConCmd) == 1 | pos('P ', ConCmd) == 1 |,\n     pos('CANCEL ', ConCmd) == 1 | pos('C ', ConCmd) == 1 |,\n     pos('MODIFY ', ConCmd) == 1 | pos('F ', ConCmd) == 1 then do\n     parse var ConCmd rest ' ' adspname\n     adspname = strip(substr(adspname,1,8)) /* The max length is 8 */\n     if pos(' ',adspname) > 0 then\n        parse var adspname adspname ' ' rest\n     if pos(',',adspname) > 0 then\n        parse var adspname adspname ',' rest\n     adspname = strip(adspname)\n     if Get_RunningTask(AdspName) == '' then do\n        x=WriteLog(\"ATI120W Address space \"AdspName\" is not started.\")\n        x=WriteLog(\"ATI121I The command '\"ConCmd\"' is skipped.\")\n        ConCmd = \"\"\n     end\n   end\n   /* plug-in: Test for REPLY command. */\n   when pos('REPLY ', ConCmd) == 1 | pos('R ', ConCmd) == 1 then do\n     x=WriteLog(\"ATI122I Checking REPLY command '\"ConCmd\"'.\")\n     RepCmd = Get_ReplyCommand(ConCmd)\n     if RepCmd = '' then\n          x=WriteLog(\"ATI123W Reply command '\"ConCmd\"' is skipped.\")\n     else x=WriteLog(\"ATI124I Translated REPLY command: '\"RepCmd\"'.\")\n     ConCmd=RepCmd\n   end\n   otherwise NOP\n  end\n\n  if length(ConCmd) > 70 then do\n     x=WriteLog(\"ATI125E Following command is longer than 70 characters!\")\n     x=WriteLog(ConCmd)\n     x=WriteLog(\"ATI126I This command is skipped.\")\n     ConCmd = \"\"\n  end\nreturn ConCmd\n\n/*\n  this is for those command not allowed in TSO CONSOLE command.\n\n Process commands in Item_Cmd.\n\n if use IEBGENER, use following allocation:\n\n ALLOC F(SYSUT2) SYSOUT(A) WRITER(INTRDR)\n\n*/\nProcess_PartialCommands:\n  if Item_Cmd.0 == 0 then return 0\n  MVSCommand = 0\n  do iPP=1 to Item_Cmd.0\n    select\n     when Item_Cmd.iPP == '' then do /* WAIT command. */\n        Item_Status.iPP='RUNNING'\n        iterate\n     end\n     when Item_Type.iPP == 'WTO' then do /* WTO Messages. */\n        x=WriteLog('ATI090I Issuing MVS WTO message:')\n        if pos('VALIDATE', StartOption) >0 then do\n           x=Writelog(Item_Cmd.iPP)\n           x=WriteLog('ATI091I WTO is bypassed for validation only.')\n        end\n        else x=WTO(Item_Cmd.iPP)\n        iterate\n     end\n     when Item_Type.iPP == 'WTOH' then do /* WTO Messages. */\n        x=WriteLog('ATI092I Issuing MVS WTO high light message:')\n        if pos('VALIDATE', StartOption) >0 then do\n           x=Writelog(Item_Cmd.iPP)\n           x=WriteLog('ATI093I WTOH is bypassed for validation only.')\n        end\n        else x=WTO(Item_Cmd.iPP,'HIGHLIGHT')\n        iterate\n     end\n     otherwise do\n       /* All other MVS commands. */\n       if pos(\"'\", Item_Cmd.iPP) > 0 then quote='\"'\n       else quote = \"'\"\n       jes2cmd =\"/*$VS,\"||quote||Item_Cmd.iPP||quote\n       if length(jes2cmd) > 80 then do\n           x=WriteLog(\"ATI094E Following command is too long:\")\n           x=WriteLog(Item_Cmd.iPP)\n           x=WriteLog(\"ATI095I This command is skipped.\")\n           iterate\n       end\n       MVSCommand = 1 /* there is at least one MVS command. */\n       if pos('VALIDATE', StartOption)==0 then\n          queue left(jes2cmd,80)\n       x=WriteLog('ATI096I Issuing command: 'Item_Cmd.iPP)\n       if Item_Name.iPP == '' | Item_Name.iPP == 'NONE' then\n          Item_Status.iPP='FINISHED'\n       else Item_Status.iPP='RUNNING'\n     end /* otherwise */\n   end /* select */\n  end /* do */\n\n  if pos('VALIDATE', StartOption) >0 then do\n     x=WriteLog('ATI097I MVS Command is bypassed for validation.')\n     return 0\n  end\n\n  if MVSCommand == 1 then do\n     queue \"\"\n     x=Msg('OFF')\n     \"SUBMIT *\"\n     x=Msg('ON')\n  end\nreturn RC\n\n/* Test if all commands are finished. */\nTest_PartialCommands:\n  x=WriteLog(\"ATI070I Testing pending tasks.\");\n  if Item_Cmd.0 == 0 then return 0\n  if pos('VALIDATE', StartOption) >0 then do\n     do iTP=1 to Item_Cmd.0\n       select\n         when Item_Status.iTP == 'FINISHED' |, /* finished tasks.    */\n              Item_Type.iTP == 'WTO' |,        /* WTO Msg            */\n              Item_Type.iTP == 'WTOH' |,       /* WTOH Msg           */\n              Item_Type.iTP \\= 'STOP' |,       /* non-stop commands. */\n              Get_RunningTask(Item_Name.iTP) == '' then /*stopped.   */\n              NOP\n         otherwise                 /* The task is still running. */\n              x=WriteLog('ATI071W Waiting' Item_Name.iTP 'to stop.')\n       end /* select */\n     end /* do iTP */\n     x=WriteLog('ATI072I Waiting is bypassed for validation.')\n     return 0\n  end\n  iTimes = 0\n  interval = 5  /* wait seconds. */\n  WarnTime = 60 /* issue warning message every 60 seconds.*/\n  Multiple = 12 /* interval of intervals. */\n  do while iTimes * interval  < TimeOut\n     Pending = 0\n     do iTP=1 to Item_Cmd.0\n       select\n         when Item_Status.iTP == 'FINISHED' |, /* finished tasks. */\n              Item_Type.iTP == 'WTO' |,\n              Item_Type.iTP == 'WTOH' then NOP\n         when Item_Type.iTP \\= 'STOP' then     /* non-stop commands. */\n              Item_Status.iTP = 'FINISHED'\n         when Get_RunningTask(Item_Name.iTP) == '' then /*stopped.*/\n              Item_Status.iTP = 'FINISHED'\n         otherwise do              /* The task is still running. */\n           Pending = iTP\n           /* WTO warning every Multiple intervals. */\n           if ITimes>0 & (iTimes//Multiple)==0 then do\n              if StartOption=='SHUTDOWN' then\n                   x=WTO('SHUTDOWN is waiting' Item_Name.iTP 'to stop.')\n              else x=WriteLog('ATI073W Waiting' Item_Name.iTP 'to stop.')\n           end\n         end /* otherwise */\n       end /* select */\n     end /* do iTP */\n     if Pending==0 then leave\n     x=wait(interval) /* test every interval seconds. */\n     iTimes=iTimes + 1\n  end /* do while */\n  if Pending>0 then do\n    x=WriteLog(\"ATI074E Command is not meet the requirement in\",\n               TimeOut\" seconds\")\n    x=WriteLog(Item_Cmd.Pending)\n    return 8\n  end\n  x=WriteLog(\"ATI075I All pending tasks are finished.\");\nreturn 0\n\n/* Test if the system is ready to shutdown. */\nTest_ShutdownCondition:\n  TSCode = 0\n  TSCount = 0\n  Drop WTOMsg.\n  do while TSCount < TimeOut\n     iWTO =0\n     if TSCount == 0 then do\n        iWTO=iWTO+1\n        WTOMsg.iWTO='System Shutdown Task Begins.'\n     end\n     else x=wait(60)\n     TSCount = TSCount + 60\n     x=Get_RunningTasks()\n     if Task_Name.0 == 0 then do    /* No running task then leave */\n        WTOMsg.0=iWTO; x=WTO()\n        leave\n     end\n     iWTO=iWTO+1\n     WTOMsg.iWTO='System Shutdown Task Detects These Running Tasks:'\n     iWTO=iWTO+1\n     WTOMsg.iWTO='TYPE NAME     DESCRIPTION '\n     iWTO=iWTO+1\n     WTOMsg.iWTO='____ ________ ____________________________________'\n     do iTS=1 to Task_Name.0\n        if Task_Type.iTS == 'TSO' then\n             Description = 'TSO Userid, type C U='Task_Name.iTS' to stop.'\n        else\n             Description = 'Batch job,  type C 'Task_Name.iTS' to stop.'\n        iWTO=iWTO+1\n        WTOMsg.iWTO=LEFT(Task_Type.iTS,4)||' '||,\n                    LEFT(Task_Name.iTS,8)||' '||Description\n     end\n     if TSCount < Timeout then do\n        iWTO=iWTO+1\n        WTOMsg.iWTO='Please stop them now, or shutdown will not run!'\n        iWTO=iWTO+1\n        WTOMsg.iWTO='Wait 1 minute for next detection(max',\n                TimeOut 'seconds)...'\n        WTOMsg.0=iWTO; x=WTO()\n     end\n     else do /* it's timeout */\n        iWTO=iWTO+1\n        WTOMsg.iWTO=,\n        'System Shutdown Task cannot go without above tasks stopped.'\n        WTOMsg.0=iWTO; x=WTO()\n        TSCode = 8\n        leave\n     end\n  end /* do while */\n  if TSCode == 0 then x=WTO('System Shutdown continues...')\nreturn TSCode\n/* Get All running TSO User and JOBs.\n   in Task_Name. and Task_Type.\n*/\nGet_RunningTasks:\n  cvt=ptr(16)                         /* Get CVT                    */\n  asvt=ptr(cvt+556)+512               /* Get asvt                   */\n  asvtmaxu=ptr(asvt+4)                /* Get max asvt entries       */\n  asinfo = ''\n  Drop Task_Name. Task_Type. iAS\n  iAS = 0\n  Do a = 0 to asvtmaxu - 1\n    ascb=stg(asvt+16+a*4,4)       /* Get ptr ascb (Skip master) */\n    If bitand(ascb,'80000000'x)=='00000000'x Then /*If in use    */\n    Do\n      ascb=c2d(ascb)                   /* Get ascb address           */\n      cscb=ptr(ascb+56)                /* Get CSCB address           */\n      asid=c2x(stg(ascb+36,2))   /* Get ASID address           */\n      chtrkid=stg(cscb+28,1)           /* Check addr space type      */\n      ascbjbns=ptr(ascb+176)           /* Get ascbjbns               */\n      ascbjbni=ptr(ascb+172)           /* Get ascbjbni               */\n      asinfo = ''\n      If chtrkid='01'x Then            /* If tso user                */\n         If stg(ascbjbns,1)>='4a'x & stg(ascbjbns,1)<='Z' Then\n            asinfo = 'TSO '||strip(stg(ascbjbns,8))||' 'asid\n      If chtrkid='02'x Then            /* If stc user                */\n            asinfo = 'STC '||strip(stg(ascbjbns,8))||' 'asid\n      If chtrkid='03'x & ascbjbni<>0 Then /* If job asid             */\n            asinfo = 'JOB '||strip(stg(ascbjbni,8))||' 'asid\n      If chtrkid='04'x Then            /* If tso user                */\n            asinfo = 'SYS '||strip(stg(ascbjbns,8))||' 'asid\n      if pos('TSO ', asinfo) == 1 | pos('JOB ', asinfo) == 1 then do\n         parse var asinfo astype asname asid\n         exfound = 0\n         do iex=1 to JobExcludeList.0\n            if pos(JobExcludeList.iex, asname) == 1 then do\n               exfound = 1\n               leave\n            end\n         end\n         if exfound then iterate\n         iAS = iAS + 1\n         Task_Name.iAS = asname\n         Task_Type.iAS = astype\n      end\n    End /* if bitand */\n  End /* DO a */\n  Task_Name.0 = iAS\n  Task_Type.0 = iAS\nReturn 0\n\n/* Write to console:\n   the message in either array WTOMsg. or string WTOMsg\n */\nWTO:\n   parse arg WTOMsg,WTOType\n   WTOCode = 0\n   if WTOMsg\\='' then do\n      WTOMsg  = strip(WTOMsg,'T')\n      drop WTOMsg.; WTOMsg.0=1; WTOMsg.1 = WTOMsg\n   end\n   else if \\datatype(WTOMsg.0,'N') then return 8\n   x=Msg('OFF')\n   \"FREE F(SYSIN)\"\n   \"ALLOC F(SYSIN) SPACE(1) TRACK DSORG(PS) BLKSIZE(8000) LRECL(80) NEW DELETE\"\n   if RC \\= 0 then do\n      x=WriteLog(\"ATI130E Cannot allocate SYSIN for WTO messages.\")\n      return 8\n   end\n   \"EXECIO * DISKW SYSIN (STEM WTOMsg. FINIS\"\n   if RC \\= 0 then do\n      \"FREE F(SYSIN)\"\n      x=WriteLog(\"ATI131E Cannot allocate SYSIN for WTO messages.\")\n      return 8\n   end\n   if WTOType=='HIGHLIGHT' then /* issue highlight WTO message */\n      \"CALL *(WTOH)\"\n   else /* issue normal WTO message */\n      \"CALL *(WTO)\"\n   WTOCode = RC\n   \"FREE F(SYSIN)\"\n   x=MSG('ON')\n   do i=1 to WTOMsg.0; x=WriteLog(WTOMsg.i); end\n   drop WTOMsg.\nreturn WTOCode\n\nreturn TSCode\n\n/* Function: Find a running task given the task name, and\n   the asid. List the address space name which asid is not given\n   asid.\n\n   If found, return 'type name asid'\n      type: STC, JOB, TSO or SYS\n      name: The name of address space\n      asid: The address space id which is active and not the same\n            as the given one.\n   ascb_name: The given address space name. Mandatory\n   ascb_asid: The address space id to be excluded. Optional\n*/\nGet_RunningTask:\n  parse arg ascb_name,ascb_asid\n  if ascb_name=='' then return ''      /* The ascb_name is a must.   */\n  cvt=ptr(16)                         /* Get CVT                    */\n  asvt=ptr(cvt+556)+512               /* Get asvt                   */\n  asvtmaxu=ptr(asvt+4)                /* Get max asvt entries       */\n  asinfo = ''\n  Do a = 0 to asvtmaxu - 1\n    ascb=stg(asvt+16+a*4,4)       /* Get ptr ascb (Skip master) */\n    If bitand(ascb,'80000000'x)=='00000000'x Then /*If in use    */\n    Do\n      ascb=c2d(ascb)                   /* Get ascb address           */\n      cscb=ptr(ascb+56)                /* Get CSCB address           */\n      asid=c2x(stg(ascb+36,2))   /* Get ASID address           */\n      chtrkid=stg(cscb+28,1)           /* Check addr space type      */\n      ascbjbns=ptr(ascb+176)           /* Get ascbjbns               */\n      ascbjbni=ptr(ascb+172)           /* Get ascbjbni               */\n      If chtrkid='01'x Then            /* If tso user                */\n         If stg(ascbjbns,1)>='4a'x & stg(ascbjbns,1)<='Z' Then\n            asinfo = 'TSO '||strip(stg(ascbjbns,8))||' 'asid\n      If chtrkid='02'x Then            /* If stc user                */\n            asinfo = 'STC '||strip(stg(ascbjbns,8))||' 'asid\n      If chtrkid='03'x & ascbjbni<>0 Then /* If job asid             */\n            asinfo = 'JOB '||strip(stg(ascbjbni,8))||' 'asid\n      If chtrkid='04'x Then            /* If tso user                */\n            asinfo = 'SYS '||strip(stg(ascbjbns,8))||' 'asid\n      if asinfo\\='' then do\n         parse var asinfo astype asname asid\n         if ascb_name == asname then do\n            if ascb_asid == '' then leave\n            else if ascb_asid\\=asid then leave\n         end\n      end\n      asinfo = ''\n    End\n  End\nReturn asinfo\n\n/*\n  ReplyKeyCommand:\n    'R|REPLY keyword,option'\n  This function will replace the keyword with the number in\n  reply pending list.\n\n  if found the pending reply, return the actual MVS reply command\n  otherwise show the error message and return ''\n*/\nGet_ReplyCommand:\n  parse arg RepKeyCommand\n  drop repkeywords rest firstkey repoption,\n       repfound irep repnumber\n  parse var RepKeyCommand RepCommand ' ' repkeywords /* remove R|REPLY */\n  if pos(',', repkeywords) == 0 then do\n     x=WriteLog(\"ATI080E The REPLY command '\"RepKeyCommand\"' is invalid.\")\n     return \"\"\n  end\n  parse var repkeywords firstkey ',' repoption\n  /* If the keyword is a number, then return the original one. */\n  if datatype(firstkey,'N') then return RepKeyCommand\n  select\n     when pos(\"'\", repkeywords)==1 then do /* there is a ' in keyword.*/\n       parse var repkeywords \"'\" repkeywords    /* remove ' */\n       if pos(\"',\", repkeywords)==0 then do\n          x=WriteLog(\"ATI081E The REPLY command '\"RepKeyCommand\"' is invalid.\")\n          return \"\"\n       end\n       parse var repkeywords repkeywords \"',\" repoption\n    end\n    when pos('\"', repkeywords)==1 then do /* there is a \" in keyword.*/\n       parse var repkeywords '\"' repkeywords    /* remove \" */\n       if pos('\",', repkeywords)==0 then do\n          x=WriteLog(\"ATI082E The REPLY command '\"RepKeyCommand\"' is invalid.\")\n          return \"\"\n       end\n       parse var repkeywords repkeywords '\",' repoption\n    end\n    otherwise parse var repkeywords repkeywords ',' repoption\n  end /* select */\n\n  if repkeywords == '' | repoption == '' then do\n     x=WriteLog(\"ATI083E The REPLY command '\"RepKeyCommand\"' is invalid 4.\")\n     return \"\"\n  end\n  x=Console_Command('D R,L,CN=(ALL)')\n  if ConMsg.0 == 0 then do\n     x=WriteLog(\"ATI084W There is no pending REPLY as keyword\" repkeywords)\n     return \"\"\n  end\n  repfound = 0\n  repbegin = 0\n  do irep=1 to ConMsg.0\n     ConMsg.irep = strip(ConMsg.irep)\n     if pos('MESSAGE TEXT', ConMsg.irep) > 0 then do\n        repbegin = 1\n        iterate\n     end\n     if repbegin then do\n        upline = ConMsg.irep\n        upper upline\n        if pos(repkeywords, upline) > 0 then do\n           parse var ConMsg.irep repnumber ' ' rest\n           repfound = 1\n           leave\n        end\n     end\n  end\n  if \\repfound then do\n     x=WriteLog(\"ATI085W There is no pending REPLY as keyword\" repkeywords)\n     return \"\"\n  end\n  RepCommand=strip(RepCommand) repnumber','strip(repoption)\n  return RepCommand\n\n/* Issue a MVS console command.\n   the console response is saved in arrag CCSCMSG.\n */\nConsole_Command:\n  parse arg con_cmd\n  if con_cmd == '' then return 0\n  DROP CONMSG.\n  CCSC_CART = 'SC'||rand(6)\n  \"CONSPROF SOLDISP(NO)\"\n  \"CONSOLE ACTIVATE NAME(\"CCSC_CART\")\"\n  \"CONSOLE SYSCMD(\"con_cmd\") CART('\"CCSC_CART\"')\"\n  x=GETMSG('CONMSG.','SOL',CCSC_CART,,10)\n  \"CONSOLE DEACTIVATE\"\n  \"CONSPROF SOLDISP(YES)\"\nreturn 0\n\n/*===================================================================*/\n/* Check if the given DD is defined.\n   return 1 if defined.\n   otherwise 0\n*/\nCheckDDName:\n  parse arg GivenDDName\n  if GivenDDName=='' then return 0\n  upper GivenDDName\n  Drop DDResults. iDD\n  x = OUTTRAP('DDResults.')\n  \"LISTALC STATUS\"\n  x = OUTTRAP('OFF')\n  Found = 0\n  do iDD=1 to DDResults.0\n     if POS(GivenDDName' ',Strip(DDResults.iDD))==1 then do\n        Found = 1; leave\n     end\n  end\n  Drop DDResults. GivenDDName iDD\nreturn Found\n\n/*===================================================================*/\n/* Provide common program end interface.\n */\nProgram_Ends:\n  parse arg ExitCode\n  if ExitCode == '' then ExitCode = 0\n  if ExitCode == 0 then status='normally'\n  else status='abnormally'\n  if StartOption == 'SHUTDOWN' then do\n     iWTO=1\n     WTOMsg.iWTO='System Shutdown Task stopped 'status'. RC='ExitCode\n        WTOMsg.0=iWTO; x=WTO()\n  end\n  else do\n        x=WriteLog('ATI020I 'Title' is stopped' status)\n        x=WriteLog('ATI021I Maximum Return Code is' ExitCode)\n  end\n  exit(ExitCode)\n\n/*===================================================================*/\nDebug:\nWriteLog:\n   parse arg Msg\n   LastChar=Right(Msg,1)\n   if Datatype(LastChar,'A') == 1 | LastChar == ')' then Msg=Msg'.'\n   say date('S')','time()','Msg\n   return 0\n\n/*===================================================================*/\n/* The wait in count in seconds. */\n/* Say wait 1 hour, call Wait(3600) */\nWait:\nSleep:\n  parse arg seconds\n  ADDRESS TSO \"CALL *(WAIT) '\"seconds\"'\"\nreturn 0;\n\n/*===================================================================*/\n/* return a radmon number ranged from the server port */\nrand:\n  parse arg length\n  if length == '' then length = 6\n  if \\datatype(length,'NUM') then length = 6\n  min=left(1,length,'0')\n  return RANDOM(min,min+99999)\n\n/*===================================================================*/\n/* return the pointer at given address. */\nptr: return c2d(storage(d2x(arg(1)),4))\n/*===================================================================*/\n/* return the contents at given address. */\nstg: return storage(d2x(arg(1)),arg(2))\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COMPILE": {"ttr": 1544, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x01\\x03\\x11_\\x01\\x06\\x11_\\tC\\x00;\\x009\\x00\\x00\\xe9\\xc8\\xd6\\xe4@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-04-25T00:00:00", "modifydate": "2006-04-25T09:43:18", "lines": 59, "newlines": 57, "modlines": 0, "user": "ZHOU"}, "text": "//SP2487CP JOB (DCTS2INF),HUNTER.Z,MSGCLASS=X,MSGLEVEL=(1,1),CLASS=9,   JOB02090\n//             NOTIFY=&SYSUID\n//********************************************************************\n//*Purpose: Generate LOAD MODULES FOR AUTOIPL\n//*Design : Hunter Guanghui Zhou\n//*         Phone: 1-(416)-602-9567\n//*         E-mail: zhough2000@yahoo.com\n//*Update : April, 2003\n//*********************************************************************\n//* COMPILE TIME UPDATES:                                             *\n//*********************************************************************\n//* LOADLIB: Must be APF Authorized and in your LINKLST.\n// SET  SRCLIB='SYS1.AUTOIPL.INSTALL',   <==THIS PDS LIBRARY\n//      LOADLIB='SYS1.USER.LINKLIB'      <==PDS where loadmod located\n//********************************************************************\n//* THE CONSCMD IS A RE-ENTREENT AND AUTHORIZED PROGRAM.\n//* YOU MUST PUT THE LOAD MODULE TO A LIBARY WITH APF AUTHORIZED.\n//CPLCMDS  EXEC ASMACL,PARM.L='LIST,RENT,AC(1)'\n//C.SYSIN   DD DISP=SHR,DSN=&SRCLIB(ASMCMDS)\n//C.SYSLIB  DD DISP=SHR,DSN=SYS1.MACLIB\n//          DD DISP=SHR,DSN=SYS1.MODGEN\n//L.SYSLMOD DD DISP=SHR,DSN=&LOADLIB\n//L.SYSIN   DD *\n  NAME CONSCMD(R)\n//********************************************************************\n//* THE WAIT IS A RE-ENTREENT PROGRAM.\n//CPLWAIT  EXEC ASMACL,PARM.L='LIST,RENT'\n//C.SYSIN   DD DISP=SHR,DSN=&SRCLIB(ASMWAIT)\n//C.SYSLIB  DD DISP=SHR,DSN=SYS1.MACLIB\n//          DD DISP=SHR,DSN=SYS1.MODGEN\n//L.SYSLMOD DD DISP=SHR,DSN=&LOADLIB\n//L.SYSIN   DD *\n  NAME WAIT(R)\n//********************************************************************\n//* THE WTO  IS A RE-ENTREENT PROGRAM.\n//*HILIGHT: WHETHER THE WTO MESSAGE SHOULD BE HIGH LIGHTED\n//*MAXLINE: THE MAXIMUM LINES TO BE SENT TO WTO FROM SYSIN DD.\n//********************************************************************\n//CPLWTO   EXEC ASMACL,PARM.L='LIST,RENT',\n//  PARM.C='SYSPARM(HILIGHT=0,MAXLINE=100)'\n//C.SYSIN   DD DISP=SHR,DSN=&SRCLIB(ASMWTO)\n//C.SYSLIB  DD DISP=SHR,DSN=SYS1.MACLIB\n//          DD DISP=SHR,DSN=SYS1.MODGEN\n//L.SYSLMOD DD DISP=SHR,DSN=&LOADLIB\n//L.SYSIN   DD *\n  NAME WTO(R)\n//********************************************************************\n//* THE WTOH IS A RE-ENTREENT PROGRAM.\n//*HILIGHT: WHETHER THE WTO MESSAGE SHOULD BE HIGH LIGHTED\n//*MAXLINE: THE MAXIMUM LINES TO BE SENT TO WTO FROM SYSIN DD.\n//CPLWTOH  EXEC ASMACL,PARM.L='LIST,RENT',\n//  PARM.C='SYSPARM(HILIGHT=1,MAXLINE=100)'\n//C.SYSIN   DD DISP=SHR,DSN=&SRCLIB(ASMWTO)\n//C.SYSLIB  DD DISP=SHR,DSN=SYS1.MACLIB\n//          DD DISP=SHR,DSN=SYS1.MODGEN\n//L.SYSLMOD DD DISP=SHR,DSN=&LOADLIB\n//L.SYSIN   DD *\n  NAME WTOH(R)\n//********************************************************************\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CONSCMD": {"ttr": 1546, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x005\\x01\\x03\\x05\\x9f\\x01\\x06\\x11_\\tD\\x01\\x0f\\x01g\\x00\\x00\\xe9\\xc8\\xd6\\xe4@@@@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "2003-02-28T00:00:00", "modifydate": "2006-04-25T09:44:35", "lines": 271, "newlines": 359, "modlines": 0, "user": "ZHOU"}, "text": "CONSCMD  TITLE 'ISSUE MVS SYSTEM COMMAND'\n*---------------------------------------------------------------------*\n* PROGRAM: CONSCMD                                                    *\n* AUTHOR : Hunter Guanghui Zhou                                       *\n*          Phone: 1-(416)-602-9567                                    *\n*          E-mail: zhough2000@yahoo.com                               *\n* DESCRIPTION: ISSUE MVS CONSOLE COMMAND TO CONSOLE                   *\n*---------------------------------------------------------------------*\n* REQUIREMENT:                                                        *\n*  1. THE PROGRAM WILL BE RUN IN SUPERVISOR MODE.                     *\n*     THE LOADLIB PDS MUST BE IN MVS APF AUTHORIZED LIST.             *\n*     SUCH AS APF LIST IN SYS1.PARMLIB(PROGXX)                        *\n*  2. OPTIONALLY, THE LOADLIB CAN BE PUT IN MVS LINKLST               *\n*     IN SYS1.PARMLIB(PROGXX).                                        *\n*     THE PROGRAM IS REENTRENT PROGRAM AND CAN BE LOADED              *\n*     INTO LPA LIST (SYS1.PARMLIB(LPALSTXX))                          *\n*  3. COMPILE REQUIREMENTS.                                           *\n*     THE LINKEDIT OPTION MUST USE 'RENT,A(1)'                        *\n*     //JOBCARD...                                                    *\n*     //COMPILE EXEC ASMACL,PARM.L='LIST,RENT,AC(1)'                  *\n*     //C.SYSIN   DD DISP=SHR,DSN=SP2487.ASM.SOURCE(CONSCMD) THIS ONE *\n*     //C.SYSLIB  DD DISP=SHR,DSN=SYS1.MACLIB                         *\n*     //          DD DISP=SHR,DSN=SYS1.MODGEN                         *\n*     //L.SYSLMOD DD DISP=SHR,DSN=SYS1.USER.LINKLIB  ANY APF LIBRARY  *\n*     //L.SYSIN   DD *                                                *\n*       NAME CONSCMD(R)                                               *\n*     /*                                                              *\n*  4. THE USER TO RUN THIS PROGRAM MUST HAVE ENGOUGH AUTHORITY.       *\n*     THE SECURITY SOFTWARE WILL CHECK THE AUTHORITY OF THE USERID    *\n*     IF HE HAS THE AUTHORITY TO ISSUE THE MVS COMMAND.               *\n*---------------------------------------------------------------------*\n* USAGE:                                                              *\n*  IT SUPPORT FOLLOWING INPUT FORMAT:                                 *\n*  I. COMMAND FROM PARM IN JCL EXEC STATEMENT.                        *\n*     THE COMMAND IN PARM IS A SINGLE COMMAND FORM                    *\n*     FOR EXAMPLE,                                                    *\n*     //JOBCARD                                                       *\n*     //OFFLINE EXEC PGM=CONSCMD,PARM='V 107A,OFFLINE'                *\n*     //STEPLIB DD  DISP=SHR,DSN=SYS1.USER.LINKLIB                    *\n*     ...                                                             *\n*     //ONLINE  EXEC PGM=CONSCMD,PARM='V 107A,ONLINE'                 *\n*     //STEPLIB DD  DISP=SHR,DSN=SYS1.USER.LINKLIB                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n* END OF DESCRIPTION OF THE PROGRAM                                   *\n*---------------------------------------------------------------------*\n* PROGRAM DESIGN DESCRIPTION                                          *\n*                                                                     *\n* CONSTANT REGISTERS THROUGH THE WHOLE PROGRAM:                       *\n*  R12: BASE ADDRESS                                                  *\n*  R11: ADDRESSING FOR DYNAMIC STORAGE                                *\n*                                                                     *\n* FOLLOWING REGISTERS WILL BE MODIFIED WHILE CALLING MVS MACROS:      *\n*   R0, R1, R14, R15                                                  *\n*                                                                     *\n* FOLLOWING REGISTERS WILL BE USED WITH THEIR PURPOSE:                *\n*   R13: THE ADDRESS OF OUR SAVED AREA.                               *\n*   R12: BASE ADDRESS                                                 *\n*   R11: ADDRESSING FOR DYNAMIC STORAGE                               *\n*   R10: THE ADDRESS OF THE STORAGE.                                  *\n*   R9 : THE LENGTH OF THE STORAGE                                    *\n*   R8 : ANY                                                          *\n*   R7 : ANY                                                          *\n*   R6 : ANY                                                          *\n*   R5 : ANY                                                          *\n*   R3 : ANY                                                          *\n*   R2 : CALLING THE SUB-ROUTINES (BALR)                              *\n*                                                                     *\n* PROGRAM DESIGN POINTS:                                              *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         PRINT NOGEN\nCONSCMD  CSECT\nCONSCMD  AMODE 31\nCONSCMD  RMODE ANY\n*---------------------------------------------------------------------*\n* DEFINE REGISTER EQUALS USING IBM STANDARD MACRO YREGS               *\n*---------------------------------------------------------------------*\n         YREGS\n*---------------------------------------------------------------------*\n* BUILD LINKAGE CONVENTION:                                           *\n*---------------------------------------------------------------------*\n* ESTABLISH ADDRESSABILITY, USING R15 AS TEMPORARY BASE REGISTER\n         USING CONSCMD,R15           R15 IS CURRENT ADDRESS, USING IT\n         B     START              BRANCH AROUND CONSTANTS\n         DC    C'PROGRAM NAME(CONSCMD)'        MODULE IDENTIFIER\n         DC    C'COMPILE TIME(&SYSDATE &SYSTIME)'\n         DC    C'CONSCMD: ISSUE MVS COMMAND.'\n         DC    C'Design: Hunter Zhou, zhough2000@yahoo.com     '\nSTART    DS    0H\n         SAVE  (14,12)            ; SAVE CALLER'S REGISTERS USING SAVE\n         LR    R12,R15            ; COPY THE CURRENT CSECT LOCATION\n         DROP  R15                ; DROP THE TEMPORARY USING\n         USING CONSCMD,R12           ;\n         MODID BRANCH=YES         ;\n*---------------------------------------------------------------------*\n* SAVE THE PARAMETER REGISTER FROM R1 TO R7 BEFORE GETMAIN\n*---------------------------------------------------------------------*\n         LR    R7,R1              ;SAVE ADDR OF PARM TO R7\n*---------------------------------------------------------------------*\n* DYNAMICALLY ALLOCATE STORAGE FOR DATA AREAS\n*---------------------------------------------------------------------*\n         GETMAIN RU,LV=DATAEND           ;OBTAIN STORAGE FOR DATA AREAS\n         LR    R11,R1             ;ADDR OF ENTRY POINT\n         USING DATAAREA,R11       ;USING R11 AS STOR ADDRESSING REGS.\n         ST    R13,SAVEAREA+4     ;SET OUR BACKWARD LINK\n         LA    R15,SAVEAREA       ;ADDR OF OUR SAVEAREA\n         ST    R15,8(R13)         ;SET CALLER'S FORWARD LINK\n         LR    R13,R15            ;ADDR OF OUR SAVEAREA\n*---------------------------------------------------------------------*\n* SAVE THE PARAMETER TO PRIVATE STORAGE (PARM AND PARMLEN)\n*---------------------------------------------------------------------*\n         L     R7,0(,R7)          ;LENGTH OF PARM\n         LH    R9,0(,R7)          ;LENGTH OF PARM\n         LA    R10,2(,R7)         ;POINT AT DATA\n         STCM  R9,B'0011',PARMLEN ;COPY THE PARAMETER LENGTH TO PARMLEN\n         BCTR  R9,0               ;DECREMENT LENGTH BY 1\n         EX    R9,MVCPARM         ;COPY PARMATER TO PARM STORAGE\n         SR    R0,R0              ;INDICATE SYSTEM ISSUED COMMAND\n*---------------------------------------------------------------------*\n* INITIALIZE STORAGE AREA WITH CONSTANT DATA\n*---------------------------------------------------------------------*\n* GET THE JOBNAME AS TEMPORARY CONSOLE NAME\n         LA    R3,TIOTA\n         EXTRACT (R3),'S',FIELDS=(TIOT),MF=(E,EXTRMFL) JOB NAME INFO\n         L     R3,TIOTA           TIOT ADDRESS\n         USING TIOT1,R3           TIOT ADDRESSABILITY\n         MVC   CCONNAME,TIOCNJOB  COPY THE JOBNAME AS CONSOL NAME\n         MVC   HCCONSNM,TIOCNJOB  COPY THE JOBNAME AS CONSOL NAME\n         MVC   CMDLEN,CCMDLEN     CONSOLE COMMAND LENGTH\n         DROP  R3\n*\n*---------------------------------------------------------------------*\n* PARPARE OPERPARM\n*---------------------------------------------------------------------*\n         LA    R8,OPERDATA            ADDRESS OF OPERPARM AREA\n         USING MCSOPPRM,R8            IEZVG111 DSECT ADDRESSABILITY\n         XC    MCSOPPRM(MCSOPLEN),MCSOPPRM  CLEAR THE OPERPARM AREA\n***********************************************************************\n* OVERRIDE THE CONSOLE ATTRIBUTES SPECIFIED IN THE USER PROFILE\n* OF THE SECURITY PRODUCT BY TURNING ON BIT MCSOVRDY IN THE MCSOP DATA\n* AREA. REQUEST THE HARDCOPY ATTRIBUTE (TO RECEIVE HARDCOPY MESSAGE SET\n***********************************************************************\n         OI    MCSOFLAG,MCSOVRDY      OVERRIDE CONSOLE ATTRIBUTES\n         OI    MCSOMISC,MCSOHDCY      REQUEST THE HARDCOPY ATTRIBUTE\n         DROP  R8                     DROP ADDRESSABILITY OF IEZVG111\n*\n*---------------------------------------------------------------------*\n* CALL MGCRE TO ISSUE MVS COMMAND\n*---------------------------------------------------------------------*\n         MODESET MF=(E,MODESUP)    ;SUPERVISOR STATE, KEY 0\n***********************************************************************\n* ACTIVATE AN EXTENDED MCS CONSOLE WHOSE NAME IS CONTAINED IN A FIELD\n* CALLED HCCONSNM.  THE ATTRIBUTES OF THE EXTENDED MCS CONSOLE ARE\n* CONTAINED IN A FIELD CALLED OPERDATA, MAPPED BY IEZVG111.  THE\n* CONSOLE WILL HAVE ITS MESSAGES DELIVERED ON A FIRST-IN-FIRST-OUT\n* BASIS.  THE SYSTEM WILL POST A MESSAGE ECB CALLED HCMECB.\n* THE ADDRESS OF THE OUTPUT AREA THAT CONTAINS THE\n* ADDRESS OF THE MCS CONSOLE STATUS AREA IS CONTAINED IN A FIELD\n* CALLED HCSTATUS.  THE ADDRESS OF THE ALET THAT IDENTIFIES THE ADDRESS\n* OR DATA SPACE THAT CONTAINS THE MCS CONSOLE STATUS AREA IS\n* CONTAINED IN A FIELD CALLED HCSTATAL.\n* THE SYSTEM RETURNS THE CONSOLE ID IN THE FIELD CALLED HCCONSID.\n* THE SYSTEM RETURNS A RETURN CODE AND A REASON CODE IN FIELDS\n* CALLED HCRETC AND HCRNC, RESPECTIVELY.\n***********************************************************************\n         MCSOPER REQUEST=ACTIVATE,  ACTIVATE THE CONSOLE               X\n               NAME=HCCONSNM,                                          X\n               TERMNAME=HCCONSNM,                                      X\n               OPERPARM=OPERDATA,                                      X\n               MSGDLVRY=FIFO,                                          X\n               MSGECB=HCMECB,                                          X\n               MCSCSA=HCSTATUS,                                        X\n               MCSCSAA=HCSTATAL,                                       X\n               CONSID=HCCONSID,                                        X\n               RTNCODE=HCRETC,                                         X\n               RSNCODE=HCRSNC,                                         X\n               MF=(E,MCSOPPL)\n         SR    R9,R9               ;CLEAR R9\n         ICM   R9,B'0011',PARMLEN  ;LOAD THE PARAMETER LENGTH TO R9\n         STCM  R9,B'0011',CMDLEN   ;COPY PARAMETER LENGTH TO CMDLEN\n         LA    R10,PARM            ;LOAD THE PARAMETER ADDRESS TO R10\n         BCTR  R9,0               ;DECREMENT LENGTH BY 1\n         EX    R9,MVCCMDS          ;COPY PARMATER TO PARM STORAGE\n***********************************************************************\n         LA    R10,CMDAREA         ;LOAD THE PARAMETER ADDRESS TO R10\n         MGCRE TEXT=(R10),                  ;CALL MVS COMMAND MGCRE    X\n               CONSNAME=HCCONSNM,MF=(E,MGCAREA)\n         MCSOPER REQUEST=DEACTIVATE,CONSID=HCCONSID,ABTERM=NO,         X\n               RTNCODE=HCRETC,RSNCODE=HCRSNC\n         MODESET MF=(E,MODEPROB)    ;BACK TO NORMAL STATE\n         STIMER WAIT,BINTVL=WAITTIME ;WAIT A LITTLE BIT\n*\n*---------------------------------------------------------------------*\n*  RETURN LINKAGE                                                     *\n*---------------------------------------------------------------------*\nRETURN   EQU   *\n         L     R13,4(R13)         ;ADDR OF CALLER'S SAVEAREA\n         FREEMAIN RU,LV=DATAEND,A=(R11)        ; FREE ALLOCATED STOR\n         RETURN (14,12),RC=(15)   ;RESTORE CALLER'S REGS AND RETURN\n*\n*---------------------------------------------------------------------*\n*  DATA  AREAS                                                        *\n*---------------------------------------------------------------------*\n*  LIST FORMS OF MVS MACROS                                           *\n*---------------------------------------------------------------------*\nMODESUP  MODESET MODE=SUP,KEY=ZERO,MF=L    ;SUPERVISOR STATE\nMODEPROB MODESET MODE=PROB,KEY=NZERO,MF=L  ;PROBLEM STATE (NORMAL)\nMGCAREA  MGCRE   MF=L                      ;MGCRE\n*---------------------------------------------------------------------*\n*  MVC INSTRUCTIONS FOR DATA STORAGE                                  *\n*  R10 WILL BE THE LOCATION OF SOURCE STORAGE TO BE COPIED.           *\n*  CALLING SYNTAX:                                                    *\n*        LA    R10,2(,R1)         ; LOAD THE PARAMETER ADDREDD TO R10 *\n*        EX    R9,MVCPARM         ; COPY THE PARAMETER TO PARM        *\n*---------------------------------------------------------------------*\nMVCPARM  MVC   PARM(0),0(R10)     ;COPY THE PARAMETER TO STORAGE PARM\nMVCCMDS  MVC   CMDTEXT(0),0(R10)  ;COPY THE CONSOLE COMMAND TO CMDTEXT\n*\nCCMDLEN  DC    AL2(126)           ;MAXIMUM COMMAND LENGTH\nWAITTIME DC    A(50)              ;WAIT TIME, IN NUMBER/100 SECONDS\n         SPACE\n*---------------------------------------------------------------------*\n*  DSECT DATA, ALLOCATED DYNAMICALLY.                                 *\n*---------------------------------------------------------------------*\nDATAAREA DSECT\n         DS    0F\nSAVEAREA DS    18F                ;REGISTER SAVE AREA\nCLEAN    DS    CL256' '           ;CLEAN AREA\n*\nPARMLEN  DS    CL2                ;THE LENGTH OF THE PARM\nPARM     DS    CL126              ;PARAMETER FROM\n*\nCMDAREA  DS    0CL128             ;COMMAND AREA\nCMDLEN   DS    AL2                ;COMMAND LENGTH, MAXIMUM 126 BYTES\nCMDTEXT  DS    CL126              ;COMMAND TEXT, MAXIMUM 126 BYTES\n*CONSOLE NAME\nCCONNAME DS    CL8                ;CONSOLE NAME\n*TIOT AREA\nTIOTA    DS    F                  TIOT ADDRESS\n*MCSOPER REQUIRED DATA STOREAGE\n*\n         DS    0F\nOPERDATA DS    CL(MCSOPLEN)\nHCCONSNM DS    CL8\nHCCONSID DS    CL4\nHCSTATUS DS    A\nHCSTATAL DS    F\nHCMECB   DS    F\nHCRETC   DS    F\nHCRSNC   DS    F\n         MCSOPER MF=(L,MCSOPPL)\nEXTRMFL  EXTRACT MF=L                      ;EXTRACT JOB NAME INFO\n*\nDATAEND  EQU   *-DATAAREA         ;LENGTH OF DATA AREA\n*\n*---------------------------------------------------------------------*\n*  SYSTEM DSECTS AND MACROS                                           *\n*---------------------------------------------------------------------*\n         IEZVG111\n         IEZMGCR\n         IHAPSA\n         IHAASCB\n         IEFTIOT1\n*\n*---------------------------------------------------------------------*\n*  END OF PROGRAM                                                     *\n*---------------------------------------------------------------------*\n         END   CONSCMD\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IPLCMDS": {"ttr": 1796, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x03\\x11\\x9f\\x01\\x03\\x11\\x9f\\x08\\'\\x00\"\\x00\"\\x00\\x00\\xe9\\xc8\\xd6\\xe4@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-04-29T00:00:00", "modifydate": "2003-04-29T08:27:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "ZHOU"}, "text": "//IPLCMDS  PROC SYSTEM=PROD,       TEST or PROD\n//    PARMLIB=SYS1.USER.PARMLIB,   PARMLIB FOR IPL PARMS\n//    REXXLIB=SYS1.USER.REXXLIB    REXX LIBRARY OF MVSCMD REXX PROGRAM\n//********************************************************************\n//*Purpose: Start the system after JES2 and VTAM are started.\n//*You may put following command in JES2 initialization parameters\n//*SYS1.PARMLIB(JES2PRM&VER),and this PROC can be started automatically.\n//*    $VS,'S IPLCMDS'\n//*\n//*Following software are already started in SYS1.PARMLIB(COMMNDxx):\n//*   JES2,VTAM,VLF,DLF,RRS,EZASSI,FFST,RACF,SYNCG370,SDSF\n//*\n//* Assume JES2 is started, and wait 2 minutes for VTAM to start up.\n//*******************************************************************\n//* START VTAM APPLICATIONS\n//******************************************************************\n//WAITVTAM EXEC PGM=WAIT,PARM=90                 WAIT 90 SECONDS\n//STTSO    EXEC PGM=CONSCMD,PARM='S TSO'                       TSO            91\n//STTCPIP  EXEC PGM=CONSCMD,PARM='S TCPIP,PROFILE=TCPF&SYSTEM' TCP/IP         91\n//STAPPC   EXEC PGM=CONSCMD,PARM='S APPC,SUB=MSTR,APPC=00'     APPC           91\n//STASCH   EXEC PGM=CONSCMD,PARM='S ASCH,SUB=MSTR,ASCH=00'     ASCH           91\n//WAITAPPC EXEC PGM=WAIT,PARM=15                 WAIT 15 SECONDS\n//*******************************************************************\n//* START APPC APPLICATIONS\n//*******************************************************************\n//STOSASF  EXEC PGM=CONSCMD,PARM='S OSASF'                   OSASF            91\n//*******************************************************************\n//* START EVERYTHING ELSE IN MEMBER IPL&SYSTEM\n//*******************************************************************\n//STARTALL EXEC PGM=IKJEFT01,PARM=AUTOIPL\n//SYSEXEC  DD   DISP=SHR,DSN=&REXXLIB\n//SYSIN    DD   DISP=SHR,DSN=&PARMLIB(IPL&SYSTEM)\n//SYSTSPRT DD   SYSOUT=*\n//SYSTSIN  DD   DUMMY\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IPLPROD": {"ttr": 1798, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x03\\x11\\x9f\\x01\\x03\\x11\\x9f\\x08'\\x00;\\x00;\\x00\\x00\\xe9\\xc8\\xd6\\xe4@@@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-04-29T00:00:00", "modifydate": "2003-04-29T08:27:00", "lines": 59, "newlines": 59, "modlines": 0, "user": "ZHOU"}, "text": "######################################################################\n#Member : IPLPROD for IPLCMDS Started Task.\n#Purpose: IPL prod system automatically\n#User Guide: Refer AUTOIPL member @USERGDE\n######################################################################\n# Suppose JES2, VTAM and TSO are started now.\nCONFIG(OPTION) = IPL      #Tell the program this is a IPL\nR IEE021A,Y               # ACKNOWLEDGE STORAGE IS MORE THAN 2GB.\nS CAS9                    # CA License Manager\nS CMDS,LIST=SLINES        # JES2-VTAM Lines.\nS CMDS,LIST=STOPRMTS      # Stop all unused JES2 RMT printers\nS SLS0                    # HSC should be started before CONTROL-T\nS IOASINIT                # IOA initialization\nS IOAOMON1                # IOA initialization\nS DMSAR,DMSAR=INSTALL     # Install CA-Disk Hooks.\n                          # CA-Disk must be started before ca-allocate.\n                          # other commands:\n                          # SHUTDOWN:    S DMSAR,DMSAR=REMOVE\n                          # SHOW STATUS: S DMSAR,DMSAR=STATUS\n                          # SHOW STATUS: S DMSAR\nS RMF                     # RMF\nS ELD                     # STOP/X37\nS TMVSHUB                 # TMON/MVS  MONITOR,\nS TMVSMSTR                # TMON/MVS Master Address Space.\n                          # It will start TMVSLFS AND TMONMVS\nS TMONDLS                 # TMON/CICS MONITOR\nS TMONCSM                 # TMON/CICS MONITOR\nWAIT 60                   # wait 1 minute\nS CONTROLM                # Control-M\nS VAM                     # Install CA-Allocate (VAM) hooks\n                          # it must be started after CA-Disk.\n                          # RELATED Commands:\n                          # SHOW STATUS: \"S VAM,PARM=STATUS\"\n                          # SHUTDOWN   : \"S VAM,PARM=REMOVE\"\nS JES328X                 # JES/328X V3.2\nS JES328Y                 # JES/328X V2.2\n$SPRT6                    # NPF Network printer VCIT1-VCIT4\n$SPRT7                    # NPF Faxgate printers\n$SPRT8                    # NPF Printers\n$SPRT9                    # NPF Printers\n$T PRT5,S=N               # Turn off seperate page of print5.\nS CONTROLD                # Control-D\nWAIT 90                   # wait 1.5 minute\nS CONTROLO                # Control-O\nS CTTINIT                 # Control-T\nF RMF,S III               # Start RMF Monitor III\nS GPMSERVE                # START RMF TCP/IP SERVER\n# Move SYSLOG from HOLD queue to OUTPUT queue, and change class to 2\n# this movememnt is for SYSLOG offload to GDG by TASK XWTR2.\n$TOJOBQ(SYSLOG),HELD,OUTDISP=WRITE,QUEUE=2\n# PURGE ALL GARBAGE OUTPUT OF RMF I,III\n$COJOBQ(RMF),READY\n$COJOBQ(RMFGAT),READY\nS IPLINFO                 # Send IPL information to www.panus.lan\nWAIT 120                  # WAIT 2 MINUTE FOR ALL TASK TO COMPLETE\nWTO('CTO26AI IPLDONE')    # TELL CONTROL-OPC IPL IS FINISHED.\n# ISSUE HIGHLIGHT TWO MESSAGE TO TELL USER IPL IS COMPLETE\nWTOH('IPL IS COMPLETED, TSO USERS MAY LOGON NOW.')\n######################################################################\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IPLTCPIP": {"ttr": 1800, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x03\\x11\\x9f\\x01\\x03\\x11\\x9f\\x08'\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe9\\xc8\\xd6\\xe4@@@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-04-29T00:00:00", "modifydate": "2003-04-29T08:27:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "ZHOU"}, "text": "######################################################################\n#Member : IPLPROD for IPLTCPIP Started Task.\n#Purpose: Reset OMVS parameters and re-start TCP/IP\n#User Guide: Refer AUTOIPL member @USERGDE\n######################################################################\nWTOH('System will restart TCP/IP for OMVS parameter updates.')\nWTOH('Hold all TCP/IP FTP jobs and logoff all TELNET users nows.')\nWTOH('TCP/IP will stopped after one minute.')\nWAIT 60\nWTOH('Now stopping TCP/IP.')\nSTOP(NPFQMGR ,'R EZY0960I,STOP')  #STOP TCP/IP NPF QUEUE MANAGER\nP CCSERVER                              # Change Control Batch Server\nP CCSQUERY                              # Change Control Query Server\nP GPMSERVE                              # RMF TCP/IP SERVER\nWAIT                                    # WAIT TILL ABOVE TASKS TO STOP\nP TCPIP                                 # TCPIP, TELNET, FTPD and WEBSRV\nWAIT 30                                 # WAIT TCPIP TO STOP\nSETOMVS RESET=(TM)                      # RESET OMVS PARAMETERS\nWAIT 10                                 # WAIT OMVS REFRESH PARMS\nWTOH('START TCP/IP NOW.')\nS TCPIP                                 # TCPIP, TELNET, FTPD and WEBSRV\nWAIT 60\nS GPMSERVE                              # START RMF TCP/IP SERVER\nWTOH('RESTART TCPIP IS COMPLETED')\nWTOH('FTP jobs can be released and users can logon now.')\n# end of restart TCP/IP parameter file\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IPLTEST": {"ttr": 1802, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x03\\x11\\x9f\\x01\\x03\\x11\\x9f\\x08'\\x00=\\x00=\\x00\\x00\\xe9\\xc8\\xd6\\xe4@@@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-04-29T00:00:00", "modifydate": "2003-04-29T08:27:00", "lines": 61, "newlines": 61, "modlines": 0, "user": "ZHOU"}, "text": "######################################################################\n#Member : IPLTEST for IPLCMDS Started Task.\n#Purpose: IPL test system automatically\n#User Guide: Refer AUTOIPL member @USERGDE\n######################################################################\n######################################################################\n# Suppose JES2, VTAM and TSO are started now.\n######################################################################\nCONFIG(OPTION) = IPL      #Tell the program this is a IPL\nR IEE021A,Y               # ACKNOWLEDGE STORAGE IS MORE THAN 2GB.\nV 104A,ONLINE             # VARY OSH004(SHARED VOLUME) ONLINE\nS CAS9                    # CA License Manager\nS CMDS,LIST=SLINES        # JES2-VTAM Lines.\nS CMDS,LIST=STOPRMTS      # Stop all JES2 RMT printers\nS SMFCLEAR                # Clear SMF data in SYS1.MANx\nS IOASINIT                # IOA initialization\nS IOAOMON1                # IOA initialization\nS RMF                     # start RMF Monitor\nS DMSAR,DMSAR=INSTALL     # Install CA-Disk Hooks.\n                          # CA-Disk must be started before ca-allocate.\n                          # other commands:\n                          # SHUTDOWN:    S DMSAR,DMSAR=REMOVE\n                          # SHOW STATUS: S DMSAR,DMSAR=STATUS\n                          # SHOW STATUS: S DMSAR\nS ELD                     # STOP/X37\nS SCHEDULE                # Scheduler for OS/390 maintenance,\n                          # this is for test LPAR only.\nS TMVSHUB                 # TMON/MVS  MONITOR,\nS TMVSMSTR                # TMON/MVS Master Address Space.\n                          # It will start TMVSLFS AND TMONMVS\n#S TMONDLS                # TMON/CICS MONITOR\n#S TMONCSM                # TMON/CICS MONITOR\nWAIT 60                   # wait 1 minute\nS CONTROLM               # Control-M\nS VAM                     # Install CA-Allocate (VAM) hooks\n                          # it must be started after CA-Disk.\n                          # other commands:\n                          # SHOW STATUS: \"S VAM,PARM=STATUS\"\n                          # SHUTDOWN   : \"S VAM,PARM=REMOVE\"\n#S JES328X                # JES/328X\n$PPRT6                    # NPF Network printer VCIT1-VCIT4\n$PPRT7                    # STOP! NPF Faxgate printers\n$PPRT8                    # STOP! NPF Printers\nS CONTROLD                # Control-D\nWAIT 60                   # wait 1 minute\nS CONTROLO                # Control-O\nS IPLINFO                 # Send IPL information to www.panus.lan\nR GS999,Y                 # HYPER-BUF EXPIRATION DATE IS NEAR.\nF RMF,S III               # Start RMF Monitor III\nS GPMSERVE                # START RMF TCP/IP SERVER\n# Move SYSLOG from HOLD queue to OUTPUT queue, and change class to 2\n# this movememnt is for SYSLOG offload to GDG by TASK XWTR2.\n$TOJOBQ(SYSLOG),HELD,OUTDISP=WRITE,QUEUE=2\n# PURGE ALL RMF I,III OUTPUT GARBAGE\n$COJOBQ(RMF),READY\n$COJOBQ(RMFGAT),READY\n# ISSUE CONTROL O/PC MESSAGE TO TELL IPL IS COMPLETE\nWTO('CTO26AI IPLDONE')    # TELL CONTROL-OPC IPL IS FINISHED.\n# ISSUE HIGHLIGHT TWO MESSAGE TO TELL USER IPL IS COMPLETE\nWTOH('IPL IS COMPLETED, TSO USERS MAY LOGON NOW.')\n######################################################################\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHUTDOWN": {"ttr": 1804, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x03\\x11\\x9f\\x01\\x03\\x11\\x9f\\x08'\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe9\\xc8\\xd6\\xe4@@@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-04-29T00:00:00", "modifydate": "2003-04-29T08:27:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "ZHOU"}, "text": "//SHUTDOWN PROC SYSTEM=TEST,       TEST OR PROD\n//    PARMLIB=SYS1.USER.PARMLIB,   PARMLIB FOR IPL PARMS\n//    REXXLIB=SYS1.USER.REXXLIB    REXX LIBRARY OF MVSCMD REXX PROGRAM\n//******************************************************************\n//* SYSTEM : TEST or PROD\n//*Purpose:\n//*    Shutdown system, after this job finished normally,\n//*    There are only following address spaces running:\n//*       RACF\n//*Shutdown Parameters is in SYS1.USER.PARMLIB(SHUT&SYSTEM)\n//******************************************************************\n//STOPALL  EXEC PGM=IKJEFT01,PARM=AUTOIPL\n//SYSEXEC  DD   DISP=SHR,DSN=&REXXLIB\n//SYSIN    DD   DISP=SHR,DSN=&PARMLIB(SHUT&SYSTEM)\n//SYSTSPRT DD   SYSOUT=*\n//SYSTSIN  DD   DUMMY\n//*If return code is not 0, bypass all followed steps.\n//STOPTSO  EXEC PGM=CONSCMD,PARM='P TSO',COND=(0,NE)         TSO\n//WAITTSO  EXEC PGM=WAIT,PARM=10,COND=(0,NE)\n//STOPVTAM EXEC PGM=CONSCMD,PARM='Z NET,QUICK',COND=(0,NE)   VTAM\n//WAITVTAM EXEC PGM=WAIT,PARM=120,COND=(0,NE)\n//STOPSMF  EXEC PGM=CONSCMD,PARM='Z EOD',COND=(0,NE)         SMF\n//WAITSMF  EXEC PGM=WAIT,PARM=10,COND=(0,NE)\n//STOPJES2 EXEC PGM=CONSCMD,PARM='$PJES2,TERM',COND=(0,NE)   JES2\n//WAITJES2 EXEC PGM=WAIT,PARM=30,COND=(0,NE)\n//COMPLETE EXEC PGM=WTOH,PARM=('&SYSTEM SYSTEM SHUTDOWN IS COMPLETED',\n//         ' IT IS SAFE TO POWER OFF OR RE-IPL &SYSTEM SYSTEM NOW.'),\n//         COND=(0,NE)\n//*End of SHUTDOWN procedure.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SHUTPROD": {"ttr": 1806, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x03\\x11\\x9f\\x01\\x03\\x11\\x9f\\x08'\\x00j\\x00j\\x00\\x00\\xe9\\xc8\\xd6\\xe4@@@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-04-29T00:00:00", "modifydate": "2003-04-29T08:27:00", "lines": 106, "newlines": 106, "modlines": 0, "user": "ZHOU"}, "text": "######################################################################\n#Member : SHUTPROD for SHUTDOWN Started Task.\n#Purpose: Shutdown prod system automatically\n#User Guide: Refer AUTOIPL member @USERGDE\n######################################################################\n#Configurations\nCONFIG(OPTION)      = SHUTDOWN #Tell the program this is a shutdown\nCONFIG(TIMEOUT)     = 3600     #Time out in seconds. 60 minutes.\nCONFIG(EXCLUDE_TASK)= FTPD     #Exclude FTPD* as a running job\nCONFIG(EXCLUDE_TASK)= INETD    #Exclude INETD* as a running job\nCONFIG(EXCLUDE_TASK)= SYSLOGD  #Exclude SYSLOGD* as a running job\nCONFIG(EXCLUDE_TASK)= CTOTSO   #Exclude CTOTSO* as a running TSO user\nCONFIG(EXCLUDE_TASK)= ONLINE   #Exclude ONLINE*  as a running job\nCONFIG(EXCLUDE_TASK)= CICSQERY #Exclude CICSQERY as a running job\nCONFIG(EXCLUDE_TASK)= CICSRESU #Exclude CICSRESU as a running job\nCONFIG(EXCLUDE_TASK)= CICSTEST #Exclude CICSRESU as a running job\nCONFIG(EXCLUDE_TASK)= CICSDTRN #Exclude CICSRESU as a running job\nCONFIG(EXCLUDE_TASK)= DBCOMPRD #Exclude DBCOMPRD as a running job\nCONFIG(EXCLUDE_TASK)= DBCOMUSR #Exclude DBCOMUSR as a running job\nCONFIG(EXCLUDE_TASK)= DBCOMTST #Exclude DBCOMUSR as a running job\nCONFIG(EXCLUDE_TASK)= DBCOMTRN #Exclude DBCOMUSR as a running job\n#######################################################################\n#Shutdown procedure begins here.\n#Stage 1: Stop most applications\nF TSO,USERMAX=0                         # TSO NOT ACCEPT LOGONS\nWTO('CTO26AI MVSIPL')                   # TELL CONTROL-OPC OF SHUTDOWN.\nF ONLINE,CEMT P,SHUT                    # STOP CICS 'ONLINE' REGION\nF CICSQERY,CEMT P,SHUT                  # STOP CICS 'CICSQERY' REGION\nF CICSRESU,CEMT P,SHUT                  # STOP CICS 'CICSRESU' REGION\nF CICSTEST,CEMT P,SHUT                  # STOP CICS 'CICSRESU' REGION\nF CICSDTRN,CEMT P,SHUT                  # STOP CICS 'CICSDTRN' REGION\nSTOP(NPFFWTR ,'$PPRT6',                 # Stop all NPF printers.\n              '$PPRT7',                 # Faxgate printers\n              '$PPRT8',                 # Multiple lines supported.\n              '$PPRT9',                 # Multiple lines supported.\n              '$PPRT10')                # Multiple lines supported.\nP CCSERVER                              # Change Control Batch Server\nP CCSQUERY                              # Change Control Query Server\nP GPMSERVE                              # RMF TCP/IP SERVER\n#STOP(VAM     ,'S VAM,PARM=REMOVE')      # CA-Allocate Hook\nSTOP(HYPEROFF,'S HYPEROFF')             # HyperBuf\nSTOP(NPFQMGR ,'R EZY0960I,STOP')        # NPF Queue Manager\nSTOP(CTTINIT ,'S CTTINIT,PARM=TERM')    # Control-T\nP IXFP                                  # IXFP\nP OSASF                                 # OSA-2 Driver\nP ELD                                   # Stop-X37\nP SDSF                                  # SDSF\nP JES328X                               # JES/328X new JES/328X V3\nSTOP(JES328Y,'R JES328Y,P')             # JES/328Y old JES/328X V2\nSTOP(NONE    ,'P CONTROLD')             # Stop CONTROLD, no check\nSTOP(NONE    ,'P CONTROLM')             # Stop CONTROLM, no check\nP CONTROLO                              # Control-O\nP IOAOMON1                              # IOA MOnitor\nP SYNCG370                              # Syncsort\nP TMONMVS                               # TMON/MVS  MONITOR\nP TMVSLFS                               # TMON/MVS  LFS\nP TMONDLS                               # TMON/CICS MONITOR\nP TMONCSM                               # TMON/CICS MONITOR\nP RMF                                   # RMF I/III\nSTOP(NONE    ,'P SLS0')                 # STK HSC\nWAIT 60                                 # Minimum WAIT seconds.\n#Each WAIT command is a stage.          # then program will wait for\n                                        # tasks to be stoped.\n#######################################################################\n#Stage 2: Stop TCP/IP and CA-Disk\nP TCPIP                                 # TCPIP, TELNET, FTPD and WEBSRV\nP TMVSHUB                               # TMON/MVS  MONITOR,\nP TMVSMSTR                              # TMON/MVS Master Address Space.\n#STOP(DMSAR   ,'S DMSAR,DMSAR=REMOVE')   # Stop CA-Disk Hook\nSTOP(CMDS    ,'S CMDS,LIST=PLINES')     # Stop JES2-VTAM Lines.\nSTOP(ONLINE  ,'R ONLINE,IGNORE')        # STOP CICS 'ONLINE' REGION\nSTOP(CICSQERY,'R CICSQERY,IGNORE')      # STOP CICS 'CICSQERY' REGION\nSTOP(CICSRESU,'R CICSRESU,IGNORE')      # STOP CICS 'CICSRESU' REGION\nSTOP(CICSTEST,'R CICSTEST,IGNORE')      # STOP CICS 'CICSRESU' REGION\nSTOP(DBCOMPRD,'F DBCOMPRD,EOJ')         # STOP DATACOM DATABASE\nSTOP(DBCOMUSR,'F DBCOMUSR,EOJ')         # STOP DATACOM DATABASE\nSTOP(DBCOMTST,'F DBCOMTST,EOJ')         # STOP DATACOM DATABASE\nSTOP(DBCOMTRN,'F DBCOMTRN,EOJ')         # STOP DATACOM DATABASE\nWAIT 30\n#######################################################################\n#Stage 3: Stop APPC, LLA and UNIX Deamons\nC INETD4                                # UNIX inetd daemon\nC SYSLOGD5                              # UNIX syslogd daemon\nC APPC                                  # APPC\nC ASCH                                  # ASCH\nP LLA                                   # Library Look-Aside\nWAIT(SLS0    ,STOP)                     # WAIT SLS0(HSC) TO STOP\nSTOP(NONE    ,'P FFST',NOCHECK)         # Stop FFST. Do not check if\n                                        # FFST is running or not.\nWAIT 10\n#######################################################################\n#Stage 4: Stop VLF, FFST, RRS\nP VLF                                   # Virtual Library Facility\nF DLF,MODE=DRAIN                        # TELL DLF TO DRAIN\n#STOP(RRS     ,'SETRRS CANCEL')          # RRS\nSTOP(EPWFFST ,'R EPW0309I,YES')         # Reply 'YES' to stop FFST.\nWAIT 10\n#######################################################################\n#Stage 5: Stop DLF\nP DLF                                   # STOP DLF\nWAIT(CONTROLD,STOP)                     # Wait CONTROLD to stop.\nWAIT(CONTROLM,STOP)                     # Wait CONTROLM to stop.\nF BPXOINIT,SHUTDOWN=FORKINIT            # Shutdown UNIX Kernel.\n#######################################################################\n# End of shutdown commands.\n#######################################################################\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SHUTTEST": {"ttr": 1809, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x03\\x11\\x9f\\x01\\x03\\x11\\x9f\\x08'\\x00f\\x00f\\x00\\x00\\xe9\\xc8\\xd6\\xe4@@@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-04-29T00:00:00", "modifydate": "2003-04-29T08:27:00", "lines": 102, "newlines": 102, "modlines": 0, "user": "ZHOU"}, "text": "######################################################################\n#Member : SHUTTEST for SHUTDOWN Started Task.\n#Purpose: Shutdown test system automatically\n#User Guide: Refer AUTOIPL member @USERGDE\n######################################################################\n#Configurations\nCONFIG(OPTION)      = SHUTDOWN #Tell the program this is a shutdown\nCONFIG(TIMEOUT)     = 3600     #Time out in seconds. 60 minutes.\nCONFIG(EXCLUDE_TASK)= FTPD     #Exclude FTPD* as a running job\nCONFIG(EXCLUDE_TASK)= INETD    #Exclude INETD* as a running job\nCONFIG(EXCLUDE_TASK)= SYSLOGD  #Exclude SYSLOGD* as a running job\nCONFIG(EXCLUDE_TASK)= CTOTSO   #Exclude CTOTSO* as a running TSO user\nCONFIG(EXCLUDE_TASK)= ONLINE   #Exclude ONLINE*  as a running job\nCONFIG(EXCLUDE_TASK)= CICSQERY #Exclude CICSQERY as a running job\nCONFIG(EXCLUDE_TASK)= CICSRESU #Exclude CICSRESU as a running job\nCONFIG(EXCLUDE_TASK)= CICSTEST #Exclude CICSRESU as a running job\nCONFIG(EXCLUDE_TASK)= DBCOMPRD #Exclude DBCOMPRD as a running job\nCONFIG(EXCLUDE_TASK)= DBCOMUSR #Exclude DBCOMUSR as a running job\nCONFIG(EXCLUDE_TASK)= DBCOMTST #Exclude DBCOMUSR as a running job\n#######################################################################\n#Shutdown procedure begins here.\n#Stage 1: Stop most applications\nWTO('CTO26AI MVSIPL')                   # TELL CONTROL-OPC OF SHUTDOWN.\nF ONLINE,CEMT P,SHUT                    # STOP CICS 'ONLINE' REGION\nF CICSQERY,CEMT P,SHUT                  # STOP CICS 'CICSQERY' REGION\nF CICSRESU,CEMT P,SHUT                  # STOP CICS 'CICSRESU' REGION\nF CICSTEST,CEMT P,SHUT                  # STOP CICS 'CICSRESU' REGION\nSTOP(NPFFWTR ,'$PPRT6',                 # Stop all NPF printers.\n              '$PPRT7',                 # Faxgate printers\n              '$PPRT8',                 # Multiple lines supported.\n              '$PPRT9',                 # Multiple lines supported.\n              '$PPRT10')                # Multiple lines supported.\nP CCSERVER                              # Change Control Batch Server\nP CCSQUERY                              # Change Control Query Server\nP GPMSERVE                              # RMF TCP/IP SERVER\n#STOP(VAM     ,'S VAM,PARM=REMOVE')      # CA-Allocate Hook\nSTOP(HYPEROFF,'S HYPEROFF')             # HyperBuf\nSTOP(NPFQMGR ,'R EZY0960I,STOP')        # NPF Queue Manager\nSTOP(CTTINIT ,'S CTTINIT,PARM=TERM')    # Control-T\nP SCHEDULE                              # Maintenance Scheduler\nP IXFP                                  # IXFP\nP OSASF                                 # OSA-2 Driver\nP ELD                                   # Stop-X37\nP SDSF                                  # SDSF\nP JES328X                               # JES/328X new JES/328X V3\nSTOP(JES328Y,'R JES328Y,P')             # JES/328Y old JES/328X V2\nP CONTROLO                              # Control-O\nP CONTROLM                              # Control-M\nSTOP(NONE    ,'P CONTROLD')             # Stop FFST. Do not check if\nP IOAOMON1                              # IOA MOnitor\nP SYNCG370                              # Syncsort\nP TMONMVS                               # TMON/MVS  MONITOR\nP TMVSLFS                               # TMON/MVS  LFS\nP TMONDLS                               # TMON/CICS MONITOR\nP TMONCSM                               # TMON/CICS MONITOR\nP RMF                                   # RMF I/III\nSTOP(NONE    ,'P SLS0')                 # STK HSC\nWAIT 60                                 # Minimum WAIT seconds.\n#Each WAIT command is a stage.          # then program will wait for\n                                        # tasks to be stopped.\n#######################################################################\n#Stage 2: Stop TCP/IP and CA-Disk\nP TCPIP                                 # TCPIP, TELNET, FTPD and WEBSRV\nP TMVSHUB                               # TMON/MVS  MONITOR,\nP TMVSMSTR                              # TMON/MVS Master Address Space.\n#STOP(DMSAR   ,'S DMSAR,DMSAR=REMOVE')   # Stop CA-Disk Hook\nSTOP(CMDS    ,'S CMDS,LIST=PLINES')     # Stop JES2-VTAM Lines.\nSTOP(ONLINE  ,'R ONLINE,IGNORE')        # STOP CICS 'ONLINE' REGION\nSTOP(CICSQERY,'R CICSQERY,IGNORE')      # STOP CICS 'CICSQERY' REGION\nSTOP(CICSRESU,'R CICSRESU,IGNORE')      # STOP CICS 'CICSRESU' REGION\nSTOP(CICSTEST,'R CICSTEST,IGNORE')      # STOP CICS 'CICSRESU' REGION\nSTOP(DBCOMPRD,'F DBCOMPRD,EOJ')         # STOP DATACOM DATABASE\nSTOP(DBCOMUSR,'F DBCOMUSR,EOJ')         # STOP DATACOM DATABASE\nSTOP(DBCOMTST,'F DBCOMTST,EOJ')         # STOP DATACOM DATABASE\nSTOP(DBCOMTRN,'F DBCOMTRN,EOJ')         # STOP DATACOM DATABASE\nWAIT 30\n#######################################################################\n#Stage 3: Stop APPC, LLA and UNIX Deamons\nC INETD4                                # UNIX inetd daemon\nC SYSLOGD5                              # UNIX syslogd daemon\nC APPC                                  # APPC\nC ASCH                                  # ASCH\nP LLA                                   # Library Look-Aside\nWAIT(SLS0    ,STOP)                     # WAIT SLS0(HSC) TO STOP\nSTOP(NONE    ,'P FFST',NOCHECK)         # Stop FFST. Do not check if\n                                        # FFST is running or not.\nWAIT 10\n#######################################################################\n#Stage 4: Stop VLF, FFST, RRS\nP VLF                                   # Virtual Library Facility\nF DLF,MODE=DRAIN                        # TELL DLF TO DRAIN\n#STOP(RRS     ,'SETRRS CANCEL')         # RRS\nSTOP(EPWFFST ,'R EPW0309I,YES')         # Reply 'YES' to stop FFST.\nWAIT 10\nWAIT(CONTROLD,STOP)                     # Wait CONTROLD to stop.\n#######################################################################\n#Stage 5: Stop DLF\nP DLF                                   # STOP DLF\nF BPXOINIT,SHUTDOWN=FORKINIT            # Shutdown UNIX Kernels\n#######################################################################\n# End of shutdown commands.\n#######################################################################\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT623/FILE623.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT623", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}