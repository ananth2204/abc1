/* We first need rexx in comment if compiled or read from SYSPROC. */
rexx_msic:
  rexxpgm_version = "01.03"          /* Set with 'ver 1' and 'lev 2'. */

  Parse Arg all_my_arguments
  Address ISPEXEC "CONTROL ERRORS RETURN"

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 This code drives Initialization, Process, and Termination routines.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
rexx_Main_Code:
  return_code = Initialzation_routine()
  If (return_code = 0) Then Do
    return_code = Process_routine()
  End
  return_code = Termination_routine()
  Return return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Put the onus on the user if anything should go wrong.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
standard_global_disclaimer:
  Say ""
  Say "STANDARD GLOBAL DISCLAIMER"
  Say "=========================="
  Say "The author explicitly disavows any claim whatsoever about"
  Say "the correctness or functionality of this program, and"
  Say "disclaims liability for anything and everything bad that"
  Say "might happen in connection with, before, during, or after"
  Say "using it. I have tried to make it work right, and I am"
  Say "personally pretty confident that it does, but everybody"
  Say "makes mistakes, so if you use it, you do so at your own"
  Say "risk."
  Say ""
  Say "The extensible nature of this program allows a software"
  Say "developer to add their own externally called upon routines."
  Say "Contact them if their code causes you concerns and/or issues."
  Say ""
  Say "IBM Corporation reserves the right to modify the IDTF"
  Say "format and has done so over the years."
  Say ""
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

  Contact:  "Kenneth E. Tomiak"<CBT_Ken@KTomiak.BIZ>
  Overview: This is an ISPF dialog driver program, internally known as
            Mainframe Software Installation Customizer (MSIC). It lets
            you list Interactive Data Transfer File (IDTF) data sets
            on your system. You can RECEIVE the contents or just view
            the attributes of the embedded data.

            If the embedded data is an MSIC-compliant PDS you will then
            be allowed to run the Installation Customizer code using
            the MSIC members directives #1TASKS, #2VARS, and #3EDIT.

=======================================================================

  History of Modifications
  ------------------------
vv.mm When     Who  /  What you did
----- -------- --------------------------------------------------------
01.03 20170819 "Kenneth E Tomiak"<CBT_Ken@KTomiak.biz>
               1) Added split-screen invocation.
               2) Modified #1TASKS to two-liners and longer
                  description.
----- -------- --------------------------------------------------------
01.02 20170818 "Kenneth E Tomiak"<CBT_Ken@KTomiak.biz>
               1) Added FIND/RFIND to DS34.
----- -------- --------------------------------------------------------
01.01 20170805 "Kenneth E Tomiak"<CBT_Ken@KTomiak.biz>
               1) Enhanced the frontend to begin with an ISPF 3.4-like
                  list of &sysuid..**.xmi* data sets; support to
                  RECEIVE the data set; and if MSIC-compliant to start
                  the installer.
----- -------- --------------------------------------------------------
01.00 20170719 "Kenneth E Tomiak"<CBT_Ken@KTomiak.biz>
               1) Original code started.
                  This is a completely newly written REXX program based
                  on the concept of using an ISPF table to walk a user
                  thru the steps to install a product. The idea comes
                  from a decade before IBM came out with the ServerPac
                  (CPAC) dialog. I wrote my first IMS DB Installer
                  Dialog while working for Andersen Consulting -
                  Coritel Division.
----- -------- --------------------------------------------------------

=======================================================================

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 This routine initializes constants and variables.
 Finds from whence this was executed, use the hostdd/hostdsn as ISPPLIB
 and ALTLIB, and build tables from #1TASKS and #2VARS.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Initialzation_routine:
  return_code = 0
  PARSE SOURCE,
    source_host_env,
    source_call_type,
    source_uc_exec_name,
    source_hostdd,
    source_hostdsn,
    source_nf_exec_name,
    source_initial_cmd_env,
    source_asid_name,
    source_char8_user_token,
    source_hostother

  Address TSO "MakeBuf"

  sysvar_sysuid = SYSVAR("SYSUID")
  sysvar_syspref = SYSVAR("SYSPREF")

  If (source_hostdsn = "?") Then Do
    function_rc = find_hostdsn()
  End
  listdsi_rc = Listdsi("'"source_hostdsn"'")
  vdef_volser = SYSVOLUME
  vdef_unit = SYSUNIT

  msg_rc = 0
  ZERRALRM = "On"
  ZERRHM = "MSICPHLP"
  verb_help = "HELP"
  ZERRSM = ask_to_get_help()
  ZERRLM = ""

  libdef_plib = 0
  altlib_exec = 0
  ds34_table = "DS34"random(9999)
  TASKTABL = "TASKTABL"
  vdef_table = "VDEF"random(9999)
  tbcreate_idtftbl = 0
  tbcreate_tasktbl = 0
  tbcreate_vdef_table = 0

  valid_names = "@#$ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890"

  Address ISPEXEC "LIBDEF ISPPLIB DATASET",
    "ID('"source_hostdsn"') STACK"
  libdef_rc = RC
  If (libdef_rc <> 0) Then Do
    ZERRLM = "LIBDEF of ISPPLIB failed, rc="libdef_rc
    msg_rc = 1
    return_code = libdef_rc
  End
  libdef_plib = 1

  Address TSO ,
    "Altlib Activate Application(EXEC) Dataset('"source_hostdsn"')"
  altlib_rc = RC
  If (altlib_rc <> 0) Then Do
    ZERRLM = "altlib of ISPPLIB failed, rc="altlib_rc
    msg_rc = 1
    return_code = altlib_rc
  End
  altlib_exec = 1

  ds34_find = 0

  onezerone = "1_0_1"
  twooneone = "2_1_1"
  twotwoone = "2_2_1"
  twotwotwo = "2_2_2"
  twotwothree = "2_2_3"
  threeone = "3_1"
  threetwo = "3_2"

  Return return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 This routine does the processing.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Process_routine:
  idtf_define_rc = ds34_table_create()
  If (idtf_define_rc <> 0) Then Do
    return idtf_define_rc
  End
  Address ISPEXEC "VGet (ZSCREENW)"
  hw = (ZSCREENW - 16) % 2
  ZTDMARK = Copies("-",hw)"> End of data set list. <"Copies("-",hw)

  DS34PTRN = sysvar_sysuid".**.xmi*"
  ds34_table_load_rc = ds34_table_load()

  ZERRLM = ""
  msicppri_tbdispl_rc = 0
  Do While (msicppri_tbdispl_rc < 8)
    Address ISPEXEC "TBDISPL" ds34_table "PANEL(MSICPPRI)"
    msicppri_tbdispl_rc = RC
    If (msicppri_tbdispl_rc = 8) Then Do
      Leave
    End
    Select
      When (msicppri_tbdispl_rc < 5) Then Do
        ds34_table_zcmd_rc = ds34_table_zcmd_procesing()
        If (ds34_table_zcmd_rc <> 0) Then Do
          return ds34_table_zcmd_rc
        End
        ds34_table_zsel_rc = ds34_table_zsel_procesing()
        If (DS34PTRN <> origptrn) Then Do
          empty_rc = ds34_table_empty()
          search_rc = ds34_table_load()
        End
      End
      When (msicppri_tbdispl_rc > 4) Then Do
        ZERRLM = "RC is too high," msicppri_tbdispl_rc"."
        msg_rc = 1
        return msicppri_tbdispl_rc
      End
      Otherwise Do
        NOp
      End
    End
    If (ZERRLM <> "") Then Do
      ZERRSM = ask_to_get_help()
      Address ISPEXEC "SETMSG MSG(ISRZ002)"
    End
  End
  return return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 This routine does any pre-termination cleanup.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Termination_routine:
  If (libdef_plib = 1) Then Do
    Address ISPEXEC "LIBDEF ISPPLIB DATASET"
  End
  If (altlib_exec = 1) Then Do
    Address TSO "AltLib Deactivate Application(EXEC)"
  End
  If (tbcreate_ds34_table = 1) Then Do
    Address ISPEXEC,
      "TBEnd" ds34_table
  End
  If (tbcreate_tasktbl = 1) Then Do
    Address ISPEXEC,
      "TBEnd TASKTABL"
  End
  If (tbcreate_vdef_table = 1) Then Do
    Address ISPEXEC,
      "TBEnd" vdef_table
  End
  If (return_code > 0) Then Do
    If (msg_rc = 1) Then Do
      If (ZERRSM = "") Then Do
        ZERRSM = "An unhappy ending"
        ZERRLM = "Some unhappy turn of events is sending back",
          "a RETURN code higher than 0 with no message."
      End
      ZERRSM = ask_to_get_help()
      Address ISPEXEC "SETMSG MSG(ISRZ002)"
    End
  End
  Address TSO "DROPBUF"
  Return return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Build the DS34 table.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
ds34_table_create:
  Address ISPEXEC,
    "TBEnd" ds34_table
  Address ISPEXEC,
    "TBCREATE" ds34_table ,
    "NAMES(DS34LCMD, DS34DSNM)" ,
    "SHARE" ,
    "NOWRITE"
  tbcreate_rc = RC
  If (tbcreate_rc <> 0) Then Do
    ZERRLM = "ds34_table create failed, RC("tbcreate_rc")."
    msg_rc = 1
    return tbcreate_rc
  End
  tbcreate_ds34_table = 1
  ds34_seek = 0
  Return return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Empty the DS34 table.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
ds34_table_empty:
  Address ISPEXEC "TBTOP" ds34_table
  Address ISPEXEC "TBSKIP" ds34_table
  tbskip_rc = 0
  Do While (tbskip_rc = 0)
    Address ISPEXEC "TBDELETE" ds34_table
    Address ISPEXEC "TBSKIP" ds34_table
    tbskip_rc = rc
  End
  Return return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Load the DS34 table using DS34PTRN.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
ds34_table_load:
  IDTF34 = ""
  Parse Var DS34PTRN DS34PTRN " " .
  Address ISPEXEC "LMDINIT" ,
    "LISTID(IDTF34) LEVEL(&DS34PTRN)"
  lmdinit_rc = RC
  If (lmdinit_rc <> 0 ) Then Do
    ZERRSM = ask_to_get_help()
    ZERRLM = "lmdinit failed," lmdinit_rc
    Address ISPEXEC "SETMSG MSG(ISRZ002)"
  End
  lmdlist_rc = 0
  LISTIDNM = ""
  Do While (lmdlist_rc = 0)
    Address ISPEXEC "LMDLIST" ,
      "LISTID("IDTF34") OPTION(LIST)" ,
      "DATASET(LISTIDNM)"
    lmdlist_rc = RC
    If (lmdlist_rc > 8) Then Do
      ZERRSM = ask_to_get_help()
      ZERRLM = "Pattern" DS34PTRN "is invalid."
      Address ISPEXEC "SETMSG MSG(ISRZ002)"
      Leave
    End
    If (lmdlist_rc > 0) Then Do
      Leave
    End
    Select
      When (lmdlist_rc = 0) Then Do
        Address ISPEXEC "TBVCLEAR" ds34_table
        DS34DSNM = Strip(LISTIDNM,"T"," ")
        Address ISPEXEC "TBADD" ds34_table
        tbadd_rc = RC
      End
      When (lmdlist_rc = 4) Then Do
        ZERRSM = ask_to_get_help()
        ZERRLM = "No data sets match pattern("DS34PTRN")."
        Address ISPEXEC "SETMSG MSG(ISRZ002)"
      End
      Otherwise Do
        NOp
      End
    End
  End
  Address ISPEXEC "LMDLIST" ,
    "LISTID("IDTF34") OPTION(FREE)"
  lmdlist_rc = RC
  Address ISPEXEC "LMDFREE" ,
    "LISTID("IDTF34")"
  lmdfree_rc = RC
  Address ISPEXEC "TBSORT" ds34_table "FIELDS(DS34DSNM,C,A)"
  Address ISPEXEC "TBTOP" ds34_table
  origptrn = DS34PTRN
  Return return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Process ==>Command options.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
ds34_table_zcmd_procesing:
  msg_rc = 0
  Parse Upper Var ZCMD ds34_verb ds34_string
  Address ISPEXEC "VGET (ZVERB)"
  ZCMD = ""
  ZERRSM = ask_to_get_help()
  ZERRLM = Left("Results:",79)
  Select
    When ((ds34_verb = "") & (ZVERB = "")) Then Do
      return return_code
    End
    When (Abbrev("FIND",ds34_verb,1) = 1) Then Do
      rfind_string = ds34_string
      If (ds34_string = "") Then Do
        ZERRLM = ZERRLM || ,
          Left("Find what?",79)
        Address ISPEXEC "SETMSG MSG(ISRZ002)"
        Return 0
      End
      ds34_find = 0
      Address ISPEXEC "TBTOP" ds34_table
      search_rc = ds34_table_search()
      If (ds34_find = 0) Then Do
        ZERRLM = ZERRLM || ,
          Left(ds34_string "not found",79)
        Address ISPEXEC "SETMSG MSG(ISRZ002)"
      End
    End
    When (Abbrev("RFIND",ZVERB,2) = 1) Then Do
      ds34_string = rfind_string
      If (ds34_find = 0) Then Do
        ZERRLM = ZERRLM || ,
          Left(ds34_string "was not found before," ,
            "will not be found now",79)
        Address ISPEXEC "SETMSG MSG(ISRZ002)"
        Return 0
      End
      search_rc = ds34_table_search()
    End
    When (Abbrev("REFRESH",ds34_verb,1) = 1) Then Do
      empty_rc = ds34_table_empty()
      search_rc = ds34_table_load()
      ds34_find = 0
    End
    When (ds34_verb = "X") Then Do
      ZERRSM = "Okay"
      ZERRLM = "You used X to leave."
      Address ISPEXEC "SETMSG MSG(ISRZ002)"
      return_code = 8
    End
    When (ds34_verb = "?") Then Do
      Address ISPEXEC "Control Display Save"
      Address ISPEXEC "AddPop"
      Address ISPEXEC "Display Panel(MSICHDZ1)"
      Address ISPEXEC "RemPop"
      Address ISPEXEC "Control Display Restore"
    End
    Otherwise Do
      ZERRSM = "What?"
      ZERRLM = "Choose a valid option or feature."
      Address ISPEXEC "SETMSG MSG(ISRZ002)"
    End  /* End of OTHERWISE */
  End  /* End of SELECT  */
  Return return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Search the DS34 table using te user provided string.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
ds34_table_search:
  tbskip_rc = 0
  If (Abbrev("RFIND",ZVERB,2) = 1) Then Do
    ds34crow = ds34crow + 0
    Address ISPEXEC "TBTOP" ds34_table
    Address ISPEXEC "TBSKIP" ds34_table "NUMBER(&ds34crow)" ,
      "Position(ds34crow)"
  End
  Do While (tbskip_rc = 0)
    Address ISPEXEC "TBSKIP" ds34_table "Position(ds34crow)"
    tkskip_rc = RC
    If (tbskip_rc > 0) Then Do
      If (Abbrev("RFIND",ZVERB,2) = 1) Then Do
        Address ISPEXEC "TBTOP" ds34_table
        Address ISPEXEC "TBSKIP" ds34_table "Position(ds34crow)"
      End
    End
    If (Pos(ds34_string,DS34DSNM) > 0) Then Do
      ds34_find = 1
      Return 0
    End
  End
  Return return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Loop thru the selected IDTF rows.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
ds34_table_zsel_procesing:
  msicppri2_tbdispl_rc = 0
  ZERRLM = ""
  Do While (ZTDSELS > 0)
    DS34LCMD = To_Uppercase(DS34LCMD)
    function_rc = ds34_table_row_selection()
    DS34LCMD = ""
    Address ISPEXEC "TBPUT" ds34_table
    If (ZTDSELS > 1) Then Do
      Address ISPEXEC "TBDISPL" ds34_table
      msicppri2_tbdispl_rc = RC
    End
    Else Do
      ZTDSELS = 0
    End
  End
  If (ZERRLM <> "") Then Do
    ZERRSM = ask_to_get_help()
    Address ISPEXEC "SETMSG MSG(ISRZ002)"
  End
  Return msicppri2_tbdispl_rc

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
-----------------------------------------------------------------------
 Process the ROW selection.
-----------------------------------------------------------------------
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
ds34_table_row_selection:
  lseldsnm = "'"DS34DSNM"'"
  listdsi_rc = Listdsi(lseldsnm)
  If (listdsi_rc <> 0) Then Do
    ZERRLM = ZERRLM || Left("LISTDSI RC("listdsi_rc")",79)
    ZERRLM = ZERRLM || Left(SYSMSGLVL1,79)
    ZERRLM = ZERRLM || Left(SYSMSGLVL2,79)
    return listdsi_rc
  End

  Select
    When (Abbrev("BROWSE",DS34LCMD,1) = 1) Then Do
      orig_zscr = zscr
      Address ISPEXEC "Control Display Save"
      Address ISPEXEC "Browse DATASET("lseldsnm")"
      browse_rc = RC
      If (browse_rc > 0) Then Do
        ZERRLM = ZERRLM || Left("Bad data set",79)
      End
      Address ISPEXEC "Control Display Restore"
      zscr = orig_zscr
    End
    When (Abbrev("EDIT",DS34LCMD,1) = 1) Then Do
      orig_zscr = zscr
      Address ISPEXEC "Control Display Save"
      Address ISPEXEC "Edit DATASET("lseldsnm")"
      edit_rc = RC
      Address ISPEXEC "Control Display Restore"
      zscr = orig_zscr
    End
    When (Abbrev("VIEW",DS34LCMD,1) = 1) Then Do
      orig_zscr = zscr
      Address ISPEXEC "Control Display Save"
      Address ISPEXEC "View DATASET("lseldsnm")"
      view_rc = RC
      Address ISPEXEC "Control Display Restore"
      zscr = orig_zscr
    End
    When ((Abbrev("HEADERS",DS34LCMD,1) = 1) | ,
          (Left(DS34LCMD,1) = "S")) Then Do
      orig_zscr = zscr
      Address ISPEXEC "Control Display Save"
      idtf_ZTDSELS = ZTDSELS
      function_rc = idtf_headers()
      ZTDSELS = idtf_ZTDSELS
      Address ISPEXEC "Control Display Restore"
      zscr = orig_zscr
    End
    When (Abbrev("RECEIVE",DS34LCMD,1) = 1) Then Do
      Parse Value Reverse(DS34DSNM) with . "." namemain
      mainname = Reverse(namemain)".INSTALL"
      INSTALL_rc = SysDsn("'"mainname"'")
      If (INSTALL_rc = "OK") Then Do
        Address ISPEXEC "CONTROL DISPLAY SAVE"
        Address ISPEXEC "AddPop"
        reason1 = "Warning '"mainname"' already exists. Delete it?"
        reason2 = "Yes will delete it and Then Do the receive."
        reason3 = "Any other response action will add/overlay"
        reason4 = "members in the existing data set."
        reason5 = ""
        Address ISPEXEC "DISPLAY PANEL(MSICPCFM)"
        confirm_rc = RC
        If (confirmd = "Y") Then Do
          Address TSO "Delete '"mainname"'"
        End
        Address ISPEXEC "RemPop"
        Address ISPEXEC "CONTROL DISPLAY RESTORE"
      End
      xmit_dsn = lseldsnm
      Address TSO "Alloc File(INMRCK)" ,
        "Dataset("xmit_dsn") SHR REUSE"
      Address MVS "Execio 1 DISKR INMRCK (Stem inmr. FINIS)"
      Address TSO "Free File(INMRCK)"
      If (Pos("\INMR01",inmr.1) <> 2) Then Do
        ZERRLM = ZERRLM || ,
          Left(lseldsnm "is not an IDTF file - INMR01<>2",79)
      End
      Else Do
        Address TSO "MakeBuf"
        Queue "Dataset('"mainname"')" ,
          "UNIT("vdef_unit") VOLUME("vdef_volser")"
        Queue "END"
        prompting = Prompt("On")
        Address TSO "Receive INDA("lseldsnm")"
        xmit_rc = RC
        prompting = Prompt(prompting)
        Address TSO "DROPBUF"
        ZERRLM = ZERRLM || ,
          Left(DS34DSNM xmit_rc,79)
        If (xmit_rc = 0) Then Do
          sysdsn_rc = SysDsn("'"mainname"("#1TASKS")'")
          If (sysdsn_rc = "OK") Then Do
            task_dsn = "'"mainname"(#1TASKS)'"
            vars_dsn = "'"mainname"(#2VARS)'"
            editdsn = mainname
            ADDRESS ISPEXEC "VPut (EDITDSN) Shared"
            mainname_exec = 0
            Address TSO ,
              "Altlib Activate Application(EXEC)" ,
              "Dataset('"mainname"' '"source_hostdsn"')"
            mainname_rc = RC
            If (mainname_rc <> 0) Then Do
              ZERRLM = "altlib of" MAINNAME "failed, rc="mainname_rc
              msg_rc = 1
              return_code = mainname_rc
            End
            mainname_exec = 1
            install_rc = Tasks_initialization()
            If (install_rc = 0) Then Do
              process_rc = Tasks_processing()
            End
            Else Do
               ZERRLM = ZERRLM || ,
                 Left("Failure proessing #1TASKS and #2VARS",79)
            End
            If (mainname_exec = 1) Then Do
              Address TSO "AltLib Deactivate Application(EXEC)"
            End
          End
          Else Do
            ZERRLM = ZERRLM || ,
              Left(mainname "is not MSIC capable",79)
          End
        End
      End
    End
    When (Abbrev("INSTALL",DS34LCMD,1) = 1) Then Do
      mainname = Strip(DS34DSNM,"B","'")
      If ((Right(mainname,4) = ".XMI") | ,
        (Right(mainname,5) = ".XMIT") | ,
        (Right(mainname,5) = ".IDTF"))  Then Do
        ZERRLM = ZERRLM || ,
          Left(mainname "is not MSIC capable",79)
      End
      Else Do
        sysdsn_rc = SysDsn("'"mainname"("#1TASKS")'")
        If (sysdsn_rc = "OK") Then Do
          task_dsn = "'"mainname"(#1TASKS)'"
          vars_dsn = "'"mainname"(#2VARS)'"
          editdsn = mainname
          ADDRESS ISPEXEC "VPut (EDITDSN) Shared"
          mainname_exec = 0
          Address TSO ,
            "Altlib Activate Application(EXEC)" ,
            "Dataset('"mainname"', '"source_hostdsn"')"
          mainname_rc = RC
          If (mainname_rc <> 0) Then Do
            ZERRLM = "altlib of" MAINNAME "failed, rc="mainname_rc
            msg_rc = 1
            return_code = mainname_rc
          End
          mainname_exec = 1
          install_rc = Tasks_initialization()
          If (install_rc = 0) Then Do
            process_rc = Tasks_processing()
          End
          Else Do
             ZERRLM = ZERRLM || ,
               Left("Failure proessing #1TASKS and #2VARS",79)
          End
        End
        Else Do
          ZERRLM = ZERRLM || ,
            Left(mainname "is not MSIC capable",79)
        End
      End
    End
    When ((DS34LCMD = "/") | (DS34LCMD = "?")) Then Do
      DS34LCMD = ""
      Address ISPEXEC "AddPop"
      Address ISPEXEC "Display Panel(MSICHDL1)"
      Address ISPEXEC "RemPop"
      Select
        When ((DS34LCMD = "/") | (DS34LCMD = "?")) Then Do
          ZERRSM = "No way!"
          ZERRLM = "Asking for recursive help is inexscusable."
          Address ISPEXEC "SETMSG MSG(ISRZ002)"
        End
        Otherwise Do
          DS34LCMD = To_Uppercase(DS34LCMD)
          function_rc = ds34_table_row_selection()
        End
      End
    End
    Otherwise Do
      ZERRSM = "What?" DS34LCMD
      ZERRLM = "Use a valid line command (S, /, ?)."
      Address ISPEXEC "SETMSG MSG(ISRZ002)"
    End
  End
  Return 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 Search a DD to find where this code runs from.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
find_hostdsn:
  Address ISPEXEC ,
    "QBASELIB" source_hostdd "ID(DSNLIST)"
  ISPEXEC_rc = RC
  If (ISPEXEC_rc <> 0) Then Do
    msg_rc = 1
    ZERRLM = "QBASELIB Failed, RC("ISPEXEC_rc")"
    Return 4
  End
  dsnlist_temp = dsnlist
  @trap_state = TRAPMSG("On")
  msg_state = Msg("OFF")
  Do While dsnlist_temp <> ""
    Parse Var dsnlist_temp one_dsn "," dsnlist_temp
    one_dsn = Strip(one_dsn,"B","'")
    sysdsn_rc = SysDsn("'"one_dsn"("source_uc_exec_name")'")
    If (sysdsn_rc = "OK") Then Do
      source_hostdsn = one_dsn
      Leave
    End
  End
  msg_rc = Msg(msg_state)
  @trap_rc = TRAPMSG(@trap_state)
  Return 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 This is an 'Easter Egg', something not shown so it is a HIDDEN choice.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
ZORK_easter_egg:
  Say ""
  Say "Clear your screen and press ENTER for an important message."
  Say ""
  Pull nothing_wanted
  Say ""
  Say "Zork is set in 'the ruins of an ancient empire lying far"
  Say "underground'. The player is a nameless adventurer 'who is"
  Say "venturing into this dangerous land in search of wealth"
  Say "and adventure'. The goal is to return from exploring the"
  Say "'Great Underground Empire' (GUE, for short) alive and with"
  Say "all treasures needed to complete each adventure,"
  Say "ultimately inheriting the desc of Dungeon Master. The"
  Say "dungeons are stocked with many novel creatures, objects,"
  Say "and locations, among them the ferocious but light-fearing"
  Say "grues, zorkmids (the GUE's currency), and Flood Control"
  Say "Dam #3."
  Say ""
  Say ""
  Say "This Easter Egg was brought to you by Kenneth Tomiak."
  Say "To learn more about the ZORK games visit:"
  Say "  https://en.wikipedia.org/wiki/Zork"
  Say ""
  Say ""
  Say "An Easter egg is an intentional inside joke, a hidden"
  Say "message, or a secret feature of an interactive work"
  Say "(often, a computer program, video game or other work)."
  Say ""
  Say ""
  Return 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 Convert string to lowercase.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
To_Lowercase: Parse arg myarg
  If (uppercase_letters = "UPPERCASE_LETTERS") Then Do
    uppercase_letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    lowercase_letters = "abcdefghijklmnopqrstuvwxyz"
  End
  Return Translate(myarg,lowercase_letters,uppercase_letters)

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 Convert string to uppercase.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
To_Uppercase: Parse arg myarg
  If (uppercase_letters = "UPPERCASE_LETTERS") Then Do
    uppercase_letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    lowercase_letters = "abcdefghijklmnopqrstuvwxyz"
  End
  Return Translate(myarg,uppercase_letters,lowercase_letters)

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 Build a string of the left hex values.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Top_Half:
  Parse Arg all_char
  all_hex = c2x(all_char)
  top_hex = ""
  Do th1 = 1 to length(all_hex) by 2
    top_hex = top_hex || SubStr(all_hex,th1,1)
  end
  Return top_hex

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 Build a string of the right hex values.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Bottom_Half:
  Parse Arg all_char
  all_hex = c2x(all_char)
  bottom_hex = ""
  Do bh1 = 2 to length(all_hex) by 2
    bottom_hex = bottom_hex || SubStr(all_hex,bh1,1)
  end
  Return bottom_hex

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 VGET the PFKEY settings amd map to names.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
pfkeys_by_name:
  pfkeys_verb. = ""
  Address ISPEXEC "VGET (ZPF01, ZPF02, ZPF03, ZPF04, ZPF05, ZPF06," ,
                        "ZPF07, ZPF08, ZPF09, ZPF10, ZPF11, ZPF12," ,
                        "ZPF13, ZPF14, ZPF15, ZPF16, ZPF17, ZPF18," ,
                        "ZPF19, ZPF20, ZPF21, ZPF22, ZPF23, ZPF24)"
  vget_rc = RC
  If (vget_rc <> 0) Then Do
    pfkeys_verb.verb_HELP = "Type HELP and press Enter."
    return vget_rc
  End
  ZPF01 = To_Uppercase(ZPF01)
  ZPF02 = To_Uppercase(ZPF02)
  ZPF03 = To_Uppercase(ZPF03)
  ZPF04 = To_Uppercase(ZPF04)
  ZPF05 = To_Uppercase(ZPF05)
  ZPF06 = To_Uppercase(ZPF06)
  ZPF07 = To_Uppercase(ZPF07)
  ZPF08 = To_Uppercase(ZPF08)
  ZPF09 = To_Uppercase(ZPF09)
  ZPF10 = To_Uppercase(ZPF10)
  ZPF11 = To_Uppercase(ZPF11)
  ZPF12 = To_Uppercase(ZPF12)
  ZPF13 = To_Uppercase(ZPF13)
  ZPF14 = To_Uppercase(ZPF14)
  ZPF15 = To_Uppercase(ZPF15)
  ZPF16 = To_Uppercase(ZPF16)
  ZPF17 = To_Uppercase(ZPF17)
  ZPF18 = To_Uppercase(ZPF18)
  ZPF19 = To_Uppercase(ZPF19)
  ZPF20 = To_Uppercase(ZPF20)
  ZPF21 = To_Uppercase(ZPF21)
  ZPF22 = To_Uppercase(ZPF22)
  ZPF23 = To_Uppercase(ZPF23)
  ZPF24 = To_Uppercase(ZPF24)
  pfkeys_verb.ZPF01 = pfkeys_verb.ZPF01"PF01/"
  pfkeys_verb.ZPF02 = pfkeys_verb.ZPF02"PF02/"
  pfkeys_verb.ZPF03 = pfkeys_verb.ZPF03"PF03/"
  pfkeys_verb.ZPF04 = pfkeys_verb.ZPF04"PF04/"
  pfkeys_verb.ZPF05 = pfkeys_verb.ZPF05"PF05/"
  pfkeys_verb.ZPF06 = pfkeys_verb.ZPF06"PF06/"
  pfkeys_verb.ZPF07 = pfkeys_verb.ZPF07"PF07/"
  pfkeys_verb.ZPF08 = pfkeys_verb.ZPF08"PF08/"
  pfkeys_verb.ZPF09 = pfkeys_verb.ZPF09"PF09/"
  pfkeys_verb.ZPF10 = pfkeys_verb.ZPF10"PF10/"
  pfkeys_verb.ZPF11 = pfkeys_verb.ZPF11"PF11/"
  pfkeys_verb.ZPF12 = pfkeys_verb.ZPF12"PF12/"
  pfkeys_verb.ZPF13 = pfkeys_verb.ZPF13"PF13/"
  pfkeys_verb.ZPF14 = pfkeys_verb.ZPF14"PF14/"
  pfkeys_verb.ZPF15 = pfkeys_verb.ZPF15"PF15/"
  pfkeys_verb.ZPF16 = pfkeys_verb.ZPF16"PF16/"
  pfkeys_verb.ZPF17 = pfkeys_verb.ZPF17"PF17/"
  pfkeys_verb.ZPF18 = pfkeys_verb.ZPF18"PF18/"
  pfkeys_verb.ZPF19 = pfkeys_verb.ZPF19"PF19/"
  pfkeys_verb.ZPF20 = pfkeys_verb.ZPF20"PF20/"
  pfkeys_verb.ZPF21 = pfkeys_verb.ZPF21"PF21/"
  pfkeys_verb.ZPF22 = pfkeys_verb.ZPF22"PF22/"
  pfkeys_verb.ZPF23 = pfkeys_verb.ZPF23"PF23/"
  pfkeys_verb.ZPF24 = pfkeys_verb.ZPF24"PF24/"
  pfkeys_verb.ZPF01 = Strip(pfkeys_verb.ZPF01,"T","/")
  pfkeys_verb.ZPF02 = Strip(pfkeys_verb.ZPF02,"T","/")
  pfkeys_verb.ZPF03 = Strip(pfkeys_verb.ZPF03,"T","/")
  pfkeys_verb.ZPF04 = Strip(pfkeys_verb.ZPF04,"T","/")
  pfkeys_verb.ZPF05 = Strip(pfkeys_verb.ZPF05,"T","/")
  pfkeys_verb.ZPF06 = Strip(pfkeys_verb.ZPF06,"T","/")
  pfkeys_verb.ZPF07 = Strip(pfkeys_verb.ZPF07,"T","/")
  pfkeys_verb.ZPF08 = Strip(pfkeys_verb.ZPF08,"T","/")
  pfkeys_verb.ZPF09 = Strip(pfkeys_verb.ZPF09,"T","/")
  pfkeys_verb.ZPF10 = Strip(pfkeys_verb.ZPF10,"T","/")
  pfkeys_verb.ZPF11 = Strip(pfkeys_verb.ZPF11,"T","/")
  pfkeys_verb.ZPF12 = Strip(pfkeys_verb.ZPF12,"T","/")
  pfkeys_verb.ZPF13 = Strip(pfkeys_verb.ZPF13,"T","/")
  pfkeys_verb.ZPF14 = Strip(pfkeys_verb.ZPF14,"T","/")
  pfkeys_verb.ZPF15 = Strip(pfkeys_verb.ZPF15,"T","/")
  pfkeys_verb.ZPF16 = Strip(pfkeys_verb.ZPF16,"T","/")
  pfkeys_verb.ZPF17 = Strip(pfkeys_verb.ZPF17,"T","/")
  pfkeys_verb.ZPF18 = Strip(pfkeys_verb.ZPF18,"T","/")
  pfkeys_verb.ZPF19 = Strip(pfkeys_verb.ZPF19,"T","/")
  pfkeys_verb.ZPF20 = Strip(pfkeys_verb.ZPF20,"T","/")
  pfkeys_verb.ZPF21 = Strip(pfkeys_verb.ZPF21,"T","/")
  pfkeys_verb.ZPF22 = Strip(pfkeys_verb.ZPF22,"T","/")
  pfkeys_verb.ZPF23 = Strip(pfkeys_verb.ZPF23,"T","/")
  pfkeys_verb.ZPF24 = Strip(pfkeys_verb.ZPF24,"T","/")
  Return vget_rc

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Set a string to press a help PFKey.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
ask_to_get_help:
  pfkey_rc = pfkeys_by_name()
  If (Left(pfkeys_verb.verb_help,2) = "PF") Then Do
    press_this = "Press" pfkeys_verb.verb_help
  End
  Else Do
    press_this = pfkeys_verb.verb_help
  End
  Return press_this

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Read the #1TASKS and #2VARS into ISPF tables.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Tasks_initialization:
  @trap_state = TRAPMSG("On")
  msg_state = Msg("OFF")
  sysdsn_rc = SysDsn(task_dsn)
  If (sysdsn_rc <> "OK") Then Do
    msg_rc = 1
    return_code = 16
    Return return_code
  End
  msg_rc = Msg(msg_state)
  @trap_state = TRAPMSG(@trap_state)
  capture_state = OutTrap(captured.)
  Address TSO ,
    "ALLOC File(TASKS) DataSet("task_dsn") SHR REUSE"
  alloc_rc = RC
  Address MVS ,
    "EXECIO * DiskR TASKS (Stem tasklist. Finis)"
  execio_rc = RC
  Address TSO ,
    "FREE File(TASKS)"
  free_rc = RC
  restore_state = OutTrap(capture_state)

  Address ISPEXEC,
    "TBEnd TASKTABL"
  Address ISPEXEC,
    "TBCREATE TASKTABL" ,
    "NAMES(TASKZSEL, TASKSEQ, TASKTYPE, TASKITEM," ,
      "TASKDONE, TASKRC, TASKDESC)" ,
    "REPLACE" ,
    "NOWRITE"
  tbcreate_rc = RC
  If (tbcreate_rc <> 0) Then Do
    Select
      When (tbcreate_rc = 4) Then Do
        ZERRLM = "4 - Duplicate table exists but 'replace' specified"
      End
      When (tbcreate_rc = 8) Then Do
        ZERRLM = "8 - Table already exists; 'replace' not specified"
      End
      When (tbcreate_rc = 12) Then Do
        ZERRLM = "Table in use; enq failed"
      End
      When (tbcreate_rc = 16) Then Do
        ZERRLM = "Table input library not allocated with 'write'"
      End
      When (tbcreate_rc = 20) Then Do
        ZERRLM = "Severe error"
      End
      Otherwise Do
        ZERRLM = tbcreate_rc "is a new value to this code."
      End
    End
    Return tbcreate_rc
  End
  tbcreate_tasktbl = 1
/*
*SQ Type    Item     Description goes on a second line               Done     St
*== ======= ======== =============================================== ======== ==
001 Browse  $$README                                                 20170718 00
Read about the installation tasks.
002 Routine $SETVARS
Set values for variables used.
003 Execute MSICXDSN
Globally changes variables in this PDS.
010 Submit  @03AALC
Allocate the WISHLIST data set.
015 Receive
Receive the XM variable named IDTF members.
020 Edit    USERMBR
Edit a member.
021 View    MSIC$DOC
(Optioonal) View a documentation member.
*/
  Do tx = 1 to tasklist.0
    If (Left(tasklist.tx,1) = "*") Then Iterate
    Parse Var tasklist.tx ,
          tasklist_seq.tx +3 ,
       =5 tasklist_type.tx +7 ,
      =13 tasklist_item.tx +8 ,
      =70 tasklist_done.tx +8 ,
      =79 tasklist_status.tx +2 .
    tasklist_item.tx = Strip(tasklist_item.tx,"T"," ")
    Address ISPEXEC "TBVCLEAR TASKTABL"
    TASKSEQ = tasklist_seq.tx
    TASKTYPE = tasklist_type.tx
    TASKITEM = tasklist_item.tx
    TASKDONE = tasklist_done.tx
    TASKRC = tasklist_status.tx
    tx = tx + 1
    tasklist_descr.tx = Strip(tasklist.tx,"T"," ")
    TASKDESC = tasklist_descr.tx
    Address ISPEXEC "TBAdd TASKTABL"
    tbadd_rc = RC
    If (tbadd_rc <> 0) Then Do
      Select
        When (tbadd_rc = 4) Then Do
          ZERRLM = "TASKTABL TBADD, Number of rows parameter" ,
                   "was specified but storage" ,
                   "was only obtained for a" ,
                   "single row"
          msg_rc = 1
        End
        When (tbadd_rc = 8) Then Do
          ZERRLM = "TASKTABL TBADD, Key tables: a row with the" ,
                   "same key already exists;" ,
                   "crp set to top"
        End
        When (tbadd_rc = 12) Then Do
          ZERRLM = "TASKTABL TBADD, Table is not open"
          msg_rc = 1
        End
        When (tbadd_rc = 16) Then Do
          ZERRLM = "TASKTABL TBADD, Severe error"
          msg_rc = 1
        End
        Otherwise Do
          ZERRLM = "TASKTABL TBADD," ,
            tbadd_rc "is a new value to this code."
          msg_rc = 1
        End
      End
    End
  End
  Address ISPEXEC "TBSort TASKTABL Fields(taskseq,C,A)"
  Address ISPEXEC "TBTop TASKTABL"

/*
*Item    A  Length Description
*======= == ====== =================================================
WISHLIST DS 46     Name of the WISHLIST pds data set.
'GENIE.SYSPROG.WISHLIST'
WISHINDX MB 8      Name of the WISHLIST configuration member.
$$$$$$$$
HLQ      UC 8      High level qualifier for GENIE data sets.
GENIE
USSPATH  MC 80     UNIX System Services directory.
/usr/lpp/java
TIME     N  4      Step card TIME= value.
1420
@05$$$$  XM 46     DSName for GENIE WISHLIST items.
'GENIE.WISHLIST.$$$$'
*/
  @trap_state = TRAPMSG("On")
  msg_state = Msg("OFF")
  sysdsn_rc = SysDsn(vars_dsn)
  If (sysdsn_rc <> "OK") Then Do
    msg_rc = 1
    return_code = 16
    Return return_code
  End
  msg_rc = Msg(msg_state)
  @trap_state = TRAPMSG(@trap_state)
  Address TSO ,
    "ALLOC File(VARS) DataSet("vars_dsn") SHR REUSE"
  alloc_rc = RC
  Address MVS ,
    "EXECIO * DiskR VARS (Stem varslist. Finis)"
  execio_rc = RC
  Address TSO ,
    "FREE File(VARS)"
  free_rc = RC
  Address ISPEXEC,
    "TBEnd" vdef_table
  Address ISPEXEC,
    "TBCREATE" vdef_table ,
    "NAMES(VDEFVAR, VDEFATTR, VDEFLEN," ,
      "VDEFVAL, VDEFDESC)" ,
    "SHARE" ,
    "NOWRITE"
  tbcreate_rc = RC
  If (tbcreate_rc <> 0) Then Do
    ZERRLM = tbcreate_rc "unexpected"
    Return tbcreate_rc
  End
  tbcreate_vdef_table = 1
  Address ISPEXEC "TBVCLEAR" vdef_table
  VDEFVAR = "HOSTDSN1"
  VDEFATTR = "DS"
  VDEFLEN  = 46
  VDEFDESC = "The data set used to launch #SETUP."
  VDEFVAL  = "'"mainname"'"
  Address ISPEXEC "TBAdd" vdef_table
  Address ISPEXEC "TBVCLEAR" vdef_table
  VDEFVAR = "HOSTDSN2"
  VDEFATTR = "DS"
  VDEFLEN  = 44
  VDEFDESC = "The data set used to launch #SETUP."
  VDEFVAL  = mainname
  Address ISPEXEC "TBAdd" vdef_table
  Address ISPEXEC "TBVCLEAR" vdef_table
  VDEFVAR = "UNIT"
  VDEFATTR = "UC"
  VDEFLEN  = 8
  VDEFDESC = "Name of DISK volume for new data sets."
  VDEFVAL  = vdef_unit
  Address ISPEXEC "TBAdd" vdef_table
  Address ISPEXEC "TBVCLEAR" vdef_table
  VDEFVAR = "VOLSER"
  VDEFATTR = "UC"
  VDEFLEN  = 8
  VDEFDESC = "Name of DISK volume for new data sets."
  VDEFVAL  = vdef_volser
  Address ISPEXEC "TBAdd" vdef_table
  Address ISPEXEC "TBVCLEAR" vdef_table
  VDEFVAR = "ZUSER"
  VDEFATTR = "UC"
  VDEFLEN  = 8
  VDEFDESC = "Your current USERID."
  VDEFVAL  = sysvar_sysuid
  Address ISPEXEC "TBAdd" vdef_table
  vdefine_list = ""
  vdefine_attrib. = ""
  vdefine_length. = 0
  vdefine_val. = ""
  Do tx = 1 to varslist.0
    If (Left(varslist.tx,1) = "*") Then Iterate
    Parse Var varslist.tx ,
          varslist_item.tx +8 ,
      =10 varslist_attr.tx +2 ,
      =13 varslist_len.tx " " . ,
      =20 varslist_desc.tx " " .
    varslist_item.tx = Strip(varslist_item.tx,"T"," ")
    varslist_desc.tx = Strip(varslist_desc.tx,"T"," ")
    varslist_key = varslist_item.tx
    vdefine_list = vdefine_list||varslist_key" "
    vdefine_var.varslist_key = tx
    ox = tx
    tx = tx + 1
    varslist_val = Left(varslist.tx,varslist_len.ox)
    Address ISPEXEC "TBVCLEAR" vdef_table
    VDEFVAR = varslist_key
    VDEFATTR = varslist_attr.ox
    VDEFLEN  = varslist_len.ox
    VDEFDESC = varslist_desc.ox
    VDEFVAL  = varslist_val
    Address ISPEXEC "TBAdd" vdef_table
  End

  Return return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Display the task table until the user exits.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Tasks_processing:
  Address ISPEXEC "VGet (ZSCREENW)"
  hw = (ZSCREENW - 16) % 2
  ZTDMARK = Copies("-",hw)"> End of tasks <"Copies("-",hw)
  msicptsk_tbdispl_rc = 0
  Do While (msicptsk_tbdispl_rc < 8)
    Address ISPEXEC "TBDISPL TASKTABL PANEL(MSICPTSK)"
    msicptsk_tbdispl_rc = RC
    Select
      When (msicptsk_tbdispl_rc = 8) Then Do
        Leave
      End
      When (msicptsk_tbdispl_rc > 4) Then Do
        ZERRLM = "RC is too high," msicptsk_tbdispl_rc"."
        msg_rc = 1
        return msicptsk_tbdispl_rc
      End
      Otherwise Do
        tasks_zcmd_rc = tasks_zcmd_procesing()
        If (tasks_zcmd_rc <> 0) Then Do
          return tasks_zcmd_rc
        End
        tasks_zsel_rc = tasks_zsel_procesing()
      End
    End
  End
  return return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Process ==>Command options.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
tasks_zcmd_procesing:
  msg_rc = 0
  task_zcmd = ZCMD
  ZCMD = ""
  Select
    When (task_zcmd = "") Then Do
      return return_code
    End
    When (To_Uppercase(task_zcmd) = "ZORK") Then Do
      function_rc = ZORK_easter_egg()
    End
    When (To_Uppercase(task_zcmd) = "X") Then Do
      ZERRSM = "Okay"
      ZERRLM = "You used X to leave."
      Address ISPEXEC "SETMSG MSG(ISRZ002)"
      return_code = 8
    End
    When (task_zcmd = "?") Then Do
      Address ISPEXEC "Control Display Save"
      Address ISPEXEC "AddPop"
      Address ISPEXEC "Display Panel(MSICHTZ1)"
      Address ISPEXEC "RemPop"
      Address ISPEXEC "Control Display Restore"
      Select
        When ((DS34LCMD = "/") | (DS34LCMD = "?")) Then Do
          ZERRSM = "No way!"
          ZERRLM = "Asking for recursive help is inexscusable."
          Address ISPEXEC "SETMSG MSG(ISRZ002)"
        End
        Otherwise Do
          DS34LCMD = To_Uppercase(DS34LCMD)
          function_rc = ds34_table_row_selection()
        End
      End
    End
    Otherwise Do
      ZERRSM = "What?"
      ZERRLM = "Choose a valid option or feature."
      Address ISPEXEC "SETMSG MSG(ISRZ002)"
    End  /* End of OTHERWISE */
  End  /* End of SELECT  */
  Return return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Loop thru the selected task rows.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
tasks_zsel_procesing:
  msicptsk_tbdispl_rc = 0
  Do While (ZTDSELS > 0)
    TASKZSEL = To_Uppercase(TASKZSEL)
    function_rc = tasks_row_selection()
    TASKZSEL = ""
    Address ISPEXEC "TBPUT TASKTABL"
    save_rc = tasks_save_state()
    If (ZTDSELS > 1) Then Do
      Address ISPEXEC "TBDISPL TASKTABL"
      msicptsk_tbdispl_rc = RC
    End
    Else Do
      ZTDSELS = 0
    End
  End
  Return msicptsk_tbdispl_rc

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
-----------------------------------------------------------------------
 Process the ROW selection.
-----------------------------------------------------------------------
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
tasks_row_selection:
  Select
    When (TASKZSEL = "S") Then Do
      Select
        When (To_uppercase(TASKTYPE) = "BROWSE") Then Do
          out_dsn = "'"mainname"("taskitem")'"
          Address ISPEXEC "Control Display Save"
          orig_zscr = ZSCR
          Address ISPEXEC "Browse DATASET("OUT_DSN")"
          browse_rc = RC
          Address ISPEXEC "Control Display Restore"
          ZSCR = orig_zscr
          taskdone = Date("S")
          taskrc = "00"
          If (browse_rc <> 0) Then Do
            ZERRSM = ask_to_get_help()
            ZERRLM = "Configuration error," taskitem "not present."
            Address ISPEXEC "SETMSG MSG(ISRZ002)"
            taskrc = "NG"
          End
        End
        When (To_uppercase(TASKTYPE) = "EDIT") Then Do
          out_dsn = "'"mainname"("taskitem")'"
          Address ISPEXEC "Control Display Save"
          orig_zscr = ZSCR
          Address ISPEXEC "EDIT DATASET("OUT_DSN")"
          EDIT_rc = RC
          Address ISPEXEC "Control Display Restore"
          ZSCR = orig_zscr
          taskdone = Date("S")
          taskrc = "00"
          If (EDIT_rc <> 0) Then Do
            ZERRSM = ask_to_get_help()
            ZERRLM = "Configuration error," taskitem "not present."
            Address ISPEXEC "SETMSG MSG(ISRZ002)"
            taskrc = "NG"
          End
        End
        When (To_uppercase(TASKTYPE) = "VIEW") Then Do
          out_dsn = "'"mainname"("taskitem")'"
          Address ISPEXEC "Control Display Save"
          orig_zscr = ZSCR
          Address ISPEXEC "VIEW DATASET("OUT_DSN")"
          VIEW_rc = RC
          Address ISPEXEC "Control Display Restore"
          ZSCR = orig_zscr
          taskdone = Date("S")
          taskrc = "00"
          If (VIEW_rc <> 0) Then Do
            ZERRSM = ask_to_get_help()
            ZERRLM = "Configuration error," taskitem "not present."
            Address ISPEXEC "SETMSG MSG(ISRZ002)"
            taskrc = "NG"
          End
        End
        When (To_uppercase(TASKTYPE) = "EXECUTE") Then Do
          Address TSO taskitem
          execute_rc = RC
          taskdone = Date("S")
          taskrc = Right(execute_rc,2,"0")
        End
        When (To_uppercase(TASKTYPE) = "ROUTINE") Then Do
          Interpret "routine_rc = "taskitem"_routine()"
          taskdone = Date("S")
          taskrc = Right(routine_rc,2,"0")
        End
        When (To_uppercase(TASKTYPE) = "RECEIVE") Then Do
          Address ISPEXEC "TBTop" vdef_table
          prompting = Prompt("On")
          zerrsm = "RECEIVE results"
          ZERRLM = ""
          receive_rc = 0
          tbskip_rc = 0
          Do While (tbskip_rc = 0)
            Address ISPEXEC "TBSkip" vdef_table
            tbskip_rc = RC
            If (tbskip_rc = 0) Then Do
              If (vdefattr = "XM") Then Do
                xmit_dsn = "'"mainname"("vdefvar")'"
                xmit_dsn = lseldsnm
                Address TSO "Alloc File(INMRCK)" ,
                  "Dataset("xmit_dsn") SHR REUSE"
                Address MVS "Execio 1 DISKR INMRCK (Stem inmr. FINIS)"
                Address TSO "Free File(INMRCK)"
                If (Pos("\INMR01",inmr.1) <> 2) Then Do
                  ZERRLM = ZERRLM || ,
                    Left(vdefvar "is not an IDTF file = INMR01<>2",79)
                End
                Else Do
                  vdefval = Strip(vdefval,"T"," ")
                  Address TSO "MakeBuf"
                  prompting = Prompt("On")
                  Queue "Dataset("vdefval")" ,
                    "UNIT("vdef_unit") VOLUME("vdef_volser")"
                  Address TSO "Receive INDA("xmit_dsn")"
                  xmit_rc = RC
                  Address TSO "DropBuf"
                  prompting = Prompt(prompting)
                  ZERRLM = ZERRLM || ,
                    Left(vdefvar xmit_rc,79)
                  If (xmit_rc > receive_rc) Then receive_rc = xmit_rc
                End
              End
            End
          End
          prompting = Prompt(prompting)
          ZERRSM = ask_to_get_help()
          Address ISPEXEC "SETMSG MSG(ISRZ002)"
          taskdone = Date("S")
          taskrc = Right(receive_rc,2,"0")
        End
        When (To_uppercase(TASKTYPE) = "SUBMIT") Then Do
          out_dsn = "'"mainname"("taskitem")'"
          Address ISPEXEC "Control Display Save"
          orig_zscr = ZSCR
          @outtrap_state = OutTrap(@caughtit.)
          Address ISPEXEC "Edit DATASET("OUT_DSN") MACRO(MSICMMBR)"
          submit_rc = RC
          @outtrap_state = OutTrap(@outtrap_state)
          Do oxx = 1 to @caughtit.0
            say @caughtit.oxx
          End
          Address ISPEXEC "Control Display Restore"
          ZSCR = orig_zscr
          taskdone = Date("S")
          taskrc = Right(submit_rc,2,"0")
        End
        Otherwise Do
          ZERRSM = ask_to_get_help()
          ZERRLM = "Not ready to" tasktype "on" taskitem"."
          Address ISPEXEC "SETMSG MSG(ISRZ002)"
        End
      End
    End
    When ((TASKZSEL = "/") | (TASKZSEL = "?")) Then Do
      TASKZSEL = ""
      Address ISPEXEC "AddPop"
      Address ISPEXEC "Display Panel(MSICHTL1)"
      Address ISPEXEC "RemPop"
      Select
        When ((TASKZSEL = "/") | (TASKZSEL = "?")) Then Do
          ZERRSM = "No way!"
          ZERRLM = "Asking for recursive help is inexscusable."
          Address ISPEXEC "SETMSG MSG(ISRZ002)"
        End
        Otherwise Do
          TASKZSEL = To_Uppercase(TASKZSEL)
          function_rc = tasks_row_selection()
        End
      End
    End
    Otherwise Do
      ZERRSM = "What?"
      ZERRLM = "Use a valid line command (S, /, ?)."
      Address ISPEXEC "SETMSG MSG(ISRZ002)"
    End
  End
  Return 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Internal routine to prompt for variable values.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
$SETVARS_routine:
  Address ISPEXEC "TBSort" vdef_table "Fields(VDEFVAR,C,A)"
  Address ISPEXEC "TBTop" vdef_table
  hw = (ZSCREENW - 16) % 2
  ZTDMARK = Copies("-",hw)"> End of variables <"Copies("-",hw)
  msicpvar_tbdispl_rc = 0
  Address ISPEXEC "CONTROL DISPLAY SAVE"
  Do While (msicpvar_tbdispl_rc < 8)
    msicpvar_tbdispl_rc = vdef_tbdispl_panel()
  End
  Address ISPEXEC "CONTROL DISPLAY RESTORE"
  return return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 In this routine we display the variable intake panel.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
vdef_tbdispl_panel:
  Address ISPEXEC "TBDISPL" vdef_table "PANEL(MSICPVAR)"
  msicpvar_tbdispl_rc = RC
  Select
    When (msicpvar_tbdispl_rc = 8) Then Do
      return msicpvar_tbdispl_rc
    End
    When (msicpvar_tbdispl_rc > 4) Then Do
      ZERRLM = "RC is too high," msicpvar_tbdispl_rc"."
      return msicpvar_tbdispl_rc
    End
    Otherwise Do
      vdef_zcmd_rc = vdef_zcmd_procesing()
      If (vdef_zcmd_rc <> 0) Then Do
        return vdef_zcmd_rc
      End
      vdef_zsel_rc = vdef_zsel_procesing()
    End
  End
  If (msicpvar_tbdispl_rc = 8) Then Do
    return return_code
  End
  return return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 In this routine we process the zcmd from the variable intake panel.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
vdef_zcmd_procesing:
  msg_rc = 0
  vdef_zcmd = ZCMD
  ZCMD = ""
  Select
    When (vdef_zcmd = "") Then Do
      return return_code
    End
    When (To_Uppercase(vdef_zcmd) = "X") Then Do
      ZERRSM = "Okay"
      ZERRLM = "You used X to leave."
      Address ISPEXEC "SETMSG MSG(ISRZ002)"
      return_code = 8
    End
    When (vdef_zcmd = "?") Then Do
      Address ISPEXEC "AddPop"
      Address ISPEXEC "Display Panel(MSICHVAR)"
      Address ISPEXEC "RemPop"
    End
    Otherwise Do
      ZERRSM = "What?"
      ZERRLM = "Choose a valid option or feature."
      Address ISPEXEC "SETMSG MSG(ISRZ002)"
    End  /* End of OTHERWISE */
  End  /* End of SELECT  */
  Return return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Process all VDEF row changes.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
vdef_zsel_procesing:
  msicpvar_tbdispl_rc = 0
  valid_msg = 0
  ZERRLM = ""
  Do While (ZTDSELS > 0)
    function_rc = vdef_row_selection()
    Address ISPEXEC "TBPUT" vdef_table
    save_rc = vdef_save_updates()
    If (ZTDSELS > 1) Then Do
      Address ISPEXEC "TBDISPL" vdef_table
      msicpvar_tbdispl_rc = RC
    End
    Else Do
      ztdsels = 0
    End
  End
  If (valid_msg = 1) Then Do
    ZERRSM = "Validaion results"
    Address ISPEXEC "SETMSG MSG(ISRZ002)"
  End
  Return msicpvar_tbdispl_rc

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
-----------------------------------------------------------------------
 Process the VDEF ROW selection.
 Validate the value matches the attribute and length.
 DS, LC, MB, MC, N, UC
-----------------------------------------------------------------------
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
vdef_row_selection:
  good_name = 1
  vdefvar = Strip(vdefvar,"T"," ")
  Select
    When (vdefattr = "DS") Then Do
      vdefval = To_Uppercase(Strip(vdefval,"T"," "))
      dsn@len = Length(vdefval)
      If (dsn@len <= vdeflen) Then Do
        tmp_dsn = vdefval
        If (Pos("'",tmp_dsn) > 0) Then Do
          tmp_dsn = Strip(tmp_dsn,"B","'")
        End
        Else Do
          Parse Var vdefval one_qual "." .
          If (one_qual <> sysvar_syspref) Then Do
            tmp_dsn = sysvar_syspref"."tmp_dsn
          End
        End
        Do While (tmp_dsn <> "")
          Parse Var tmp_dsn one_qual "." tmp_dsn
          If (Pos(Left(one_qual,1),Left(valid_names,29)) = 0 ) Then Do
            good_name = 0
            ZERRLM = ZERRLM || ,
              Left(vdefvar "1st character bad:" Left(one_qual,1),79)
          End
          mbr@len = Length(one_qual)
          Do ltr = 2 to mbr@len
            If (Pos(SubStr(one_qual,ltr,1),valid_names) = 0 ) Then Do
              good_name = 0
              ZERRLM = ZERRLM || ,
                Left(vdefvar ltr ,
                  "character bad:" SubStr(one_qual,ltr,1),79)
            End
          End
        End
      End
      Else Do
        good_name = 0
        ZERRLM = ZERRLM || ,
          Left(vdefvar dsn@len "length exceeds" vdeflen,79)
      End
    End
    When (vdefattr = "LC") Then Do
      vdefval = To_Lowercase(vdefval)
    End
    When (vdefattr = "MB") Then Do
      vdefval = To_Uppercase(vdefval)
      mbr@len = Length(vdefval)
      good_name = 1
      If (mbr@len > vdeflen) Then Do
        If (Pos(Left(vdefval,1),Left(valid_names,29)) = 0 ) Then Do
          good_name = 0
          ZERRLM = ZERRLM || ,
            Left(vdefvar "1st character bad:" Left(vdefval,1),79)
        End
        Do ltr = 2 to mbr@len
          If (Pos(SubStr(vdefval,ltr,1),valid_names) = 0 ) Then Do
            good_name = 0
            ZERRLM = ZERRLM || ,
              Left(vdefvar ltr ,
                "character bad:" SubStr(vdefval,ltr,1),79)
          End
        End
      End
      Else Do
        good_name = 0
        ZERRLM = ZERRLM || ,
          Left(vdefvar mbr@len "length exceeds" vdeflen,79)
      End
    End
    When (vdefattr = "MC") Then Do
      NOp
    End
    When (vdefattr = "N") Then Do
      good_name = 1
      val@len = Length(vdefval)
      If (val@len > vdeflen) Then Do
        good_name = 0
        ZERRLM = ZERRLM || ,
          Left(vdefvar val@len "length exceeds" vdeflen,79)
      End
      If (DataType(vdefval) <> "NUM") Then Do
        good_name = 0
        ZERRLM = ZERRLM || ,
          Left(vdefvar "is not numeric",79)
      End
    End
    When (vdefattr = "UC") Then Do
      vdefval = To_Uppercase(vdefval)
    End
    When (vdefattr = "XM") Then Do
      val@len = Length(vdefval)
      If (val@len > vdeflen) Then Do
        good_name = 0
        ZERRLM = ZERRLM || ,
          Left(vdefvar val@len "length exceeds" vdeflen,79)
      End
      xmit_dsn = "'"mainname"("vdefvar")'"
      Address TSO "Alloc File(INMRCK)" ,
        "Dataset("xmit_dsn") SHR REUSE"
      Address MVS "Execio 1 DISKR INMRCK (Stem inmr. FINIS)"
      Address TSO "Free File(INMRCK)"
      If (Pos("\INMR01",inmr.1) <> 2) Then Do
        good_name = 0
        ZERRLM = ZERRLM || ,
          Left(vdefvar "is not an IDTF file XM INMR01<>2",79)
      End
    End
    Otherwise Do
      msg_rc = 1
      ZERRLM = ZERRLM || ,
        Left(vdefvar vdefattr "is a bad attribute to me.",79)
    End
  End
  If (good_name = 0) Then Do
    vdefzsel = "ERR"
  End
  Else Do
    ZERRLM = ZERRLM || ,
      Left(vdefvar "OK",79)
  End
  valid_msg = 1
  Address ISPEXEC "VPut ("vdefvar") Shared"
  If (vdefvar = "VOLSER") Then Do
    vdef_volser = vdefval
  End
  If (vdefvar = "UNIT") Then Do
    vdef_unit = vdefval
  End
  Return 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Save the updated #1TASKS list.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
tasks_save_state:
  line_of_code = get_my_sigl() + 2
/* Tasklist
*
* Mainframe Software Installation Customizer (MSIC)
*
* Tasks require 2 records.
* Record 1:
* =====================================================================
* Seq    N3 Three digit sequence identifier
* Type   C7 What it is you want to do.
*             Browse : Let the user BROWSE a PDS member.
*             Edit   : Let the user EDIT a PDS member.
*             Execute: Run some external REXX code.
*             Receive: Receive all XM variables.
*             Routine: Run an internal REXX routine.
*             Submit : Submit a member to run in the background.
*             View : Let the user VIEW a PDS member.
* Item   C8 What is acted upon.
* Done   D8 The last attempt date filled in by MSIC.
* Status C2 How that last attempt fared filled in by MSIC.
*
* Record 2:
* =====================================================================
* Desc  : A descriptive bit of text.
*
*---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
*SQ Type    Item     Description goes on a second line               Done     St
*== ======= ======== =============================================== ======== ==
End */
  tasklist. = ""
  task_ctr = 0
  Do While (SourceLine(line_of_code) <> "End */")
    task_ctr = task_ctr + 1
    tasklist.task_ctr = SourceLine(line_of_code)
    line_of_code = line_of_code + 1
  End
  Address ISPEXEC "TBTop TASKTABL"
  tbskip_rc = 0
  Do While (tbskip_rc = 0)
    Address ISPEXEC "TBSkip TASKTABL"
    tbskip_rc = RC
    If (tbskip_rc = 0) Then Do
      task_ctr = task_ctr + 1
      tasklist.task_ctr = Right(taskseq,3,"0") ,
        Left(tasktype,7) Left(taskitem,8) ,
        Copies(" ",47) Left(taskdone,8) Left(Taskrc,2)
      task_ctr = task_ctr + 1
      tasklist.task_ctr = taskdesc
    End
  End
  task_ctr = task_ctr + 1
  tasklist.task_ctr = "*"
  task_ctr = task_ctr + 1
  tasklist.task_ctr = "* End of #1TASKS."
  @trap_state = TRAPMSG("On")
  msg_state = Msg("OFF")
  Address TSO ,
    "ALLOC File(TASKS) DataSet("task_dsn") SHR REUSE"
  alloc_rc = RC
  Address MVS ,
    "EXECIO * Diskw TASKS (Stem tasklist. Finis)"
  execio_rc = RC
  Address TSO ,
    "FREE File(TASKS)"
  free_rc = RC
  msg_rc = Msg(msg_state)
  @trap_state = TRAPMSG(@trap_state)
  Return 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Save the updated #2VARS list.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
vdef_save_updates:
  line_of_code = get_my_sigl() + 2
/* Varlist
*
* Mainframe Software Installation Customizer (MSIC)
*
* Variables require 2 records.
* Record 1:
* =====================================================================
* ITEM         C8 The variable name.
*                 You will wrap it with exclamation marks when used.
* Attribute    C2 Provides for limited validation and identification.
*                   DS = Data set name
*                   LC = Lowercase
*                   MB = Member name
*                   MC = Mixed case (ASIS)
*                   N  = Number (digits)
*                   UC = Uppercase
*                   XM = IDTF member to DSName.
* Length      N2  The maximum size of the value.
* Description C61 Describes what the variable is used for.
*
* Record 2:
* =====================================================================
* The initial default value or the user specified value.
*
*---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
*Item    A  Length Description (value is on the next row).
*======= == ====== =============================================================
End */
  vdeflist. = ""
  vdef_ctr = 0
  Do While (SourceLine(line_of_code) <> "End */")
    vdef_ctr = vdef_ctr + 1
    vdeflist.vdef_ctr = SourceLine(line_of_code)
    line_of_code = line_of_code + 1
  End
  Address ISPEXEC "TBTop" vdef_table
  tbskip_rc = 0
  Do While (tbskip_rc = 0)
    Address ISPEXEC "TBSkip" vdef_table
    tbskip_rc = RC
    If (tbskip_rc = 0) Then Do
      vdef_ctr = vdef_ctr + 1
      vdeflist.vdef_ctr = Left(vdefvar,8) ,
        left(vdefattr,2) Left(vdeflen,6) Left(vdefdesc,61)
      vdef_ctr = vdef_ctr + 1
      vdeflist.vdef_ctr = Left(vdefval,80)
    End
  End
  vdef_ctr = vdef_ctr + 1
  vdeflist.vdef_ctr = "*"
  vdef_ctr = vdef_ctr + 1
  vdeflist.vdef_ctr = "* End of #2VARS. Saved:" Date("S") Time()
  @trap_state = TRAPMSG("On")
  msg_state = Msg("OFF")
  Address TSO ,
    "ALLOC File(VARS) DataSet("vars_dsn") SHR REUSE"
  alloc_rc = RC
  Address MVS ,
    "EXECIO * Diskw VARS (Stem vdeflist. Finis)"
  execio_rc = RC
  Address TSO ,
    "FREE File(VARS)"
  free_rc = RC
  msg_rc = Msg(msg_state)
  @trap_state = TRAPMSG(@trap_state)
  Return 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Read a data set{member} and verify IDTF format.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_headers:
  Address ISPEXEC "AddPop Row(5) Column(20)"
  MSICPHSE = "1 of 13 - Build arrays"
  Address ISPEXEC "CONTROL DISPLAY LOCK"
  Address ISPEXEC "DISPLAY PANEL(MSICPPRG)"
  Call idtf_array_creation

  MSICPHSE = "2 of 13 - TBCreate"
  Address ISPEXEC "CONTROL DISPLAY LOCK"
  Address ISPEXEC "DISPLAY PANEL(MSICPPRG)"
  tbcreate_infotabl = 0
  Address ISPEXEC,
    "TBEnd infotabl"
  Address ISPEXEC,
    "TBCREATE infotabl" ,
    "NAMES(INFOKEY, INFOVAL)" ,
    "REPLACE" ,
    "SHARE" ,
    "NOWRITE"
  tbcreate_rc = RC
  If (tbcreate_rc <> 0) Then Do
    ZERRLM = "infotabl create failed, RC("tbcreate_rc")."
    msg_rc = 1
    return tbcreate_rc
  End

  MSICPHSE = "3 of 13 - ListDSI()"
  Address ISPEXEC "CONTROL DISPLAY LOCK"
  Address ISPEXEC "DISPLAY PANEL(MSICPPRG)"
  info_rc = 0
  Address ISPEXEC "CONTROL DISPLAY LOCK"
  Address ISPEXEC "DISPLAY PANEL(MSICPPRG)"
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "LISTDSI()"
  INFOVAL = Copies("=",zscreenw - 11)
  Address ISPEXEC "TBAdd infotabl"

  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "SYSRECFM"
  INFOVAL = SYSRECFM
  Address ISPEXEC "TBAdd infotabl"

  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "SYSBLKSIZE"
  INFOVAL = SYSBLKSIZE
  Address ISPEXEC "TBAdd infotabl"

  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "SYSLRECL"
  INFOVAL = SYSLRECL
  Address ISPEXEC "TBAdd infotabl"

  blkfctr   = SYSBLKSIZE / SYSLRECL
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "Rec/Blk"
  INFOVAL = blkfctr
  Address ISPEXEC "TBAdd infotabl"

  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "SPACE"
  INFOVAL = SYSUNITS
  Address ISPEXEC "TBAdd infotabl"

  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "Used"
  INFOVAL = SYSUSED
  Address ISPEXEC "TBAdd infotabl"

  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "SYSBLKSTRK"
  INFOVAL = SYSBLKSTRK
  Address ISPEXEC "TBAdd infotabl"

  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "SYSCREATE"
  INFOVAL = SYSCREATE
  Address ISPEXEC "TBAdd infotabl"

  Select
    When (SYSUNITS = "CYLINDER") Then Do
      used_blks = (sysused * SYSTRKSCYL * SYSBLKSTRK)
    End
    When (SYSUNITS = "TRACK") Then Do
      used_blks = (sysused * SYSBLKSTRK)
    End
    When (SYSUNITS = "BLOCK") Then Do
      used_blks = sysused
    End
    Otherwise Do
      used_blks = "Unknown"
    End
  End

  MSICPHSE = "4 of 13 - DiskR"
  Address ISPEXEC "CONTROL DISPLAY LOCK"
  Address ISPEXEC "DISPLAY PANEL(MSICPPRG)"
  @trap_state = TRAPMSG("On")
  msg_state = Msg("OFF")
  capture_state = OutTrap(captured.)
  Address TSO ,
    "ALLOC File(IDTF) DataSet("lseldsnm") SHR REUSE"
  alloc_rc = RC
  execio_rc = 0
  blk_ctr = 0
  rec_ctr = 0
  idtf_data = ""
  Do While (execio_rc < 4)
    Address MVS ,
      "EXECIO" blkfctr "DiskR IDTF (Stem idtfraw.)"
    execio_rc = RC
    blk_ctr = blk_ctr + 1
    If (execio_rc < 4) Then Do
      MSICPHSE = "4 of 13 - DiskR: Block:" blk_ctr "of" used_blks
      Address ISPEXEC "CONTROL DISPLAY LOCK"
      Address ISPEXEC "DISPLAY PANEL(MSICPPRG)"
      Do rx = 1 to idtfraw.0
        idtf_data = idtf_data || idtfraw.rx
        rec_ctr = rec_ctr + 1
      End
      Drop idtfraw.
    End
    If (execio_rc = 2) Then Do
      Leave
    End
  End
  Address MVS ,
    "EXECIO 0 DiskR IDTF (Finis)"
  execio_rc = RC
  Address TSO ,
    "FREE File(IDTF)"
  free_rc = RC
  restore_state = OutTrap(capture_state)
  @trap_state = TRAPMSG(@trap_state)
  msg_rc = Msg(msg_state)

  MSICPHSE = "5 of 13"
  Address ISPEXEC "CONTROL DISPLAY LOCK"
  Address ISPEXEC "DISPLAY PANEL(MSICPPRG)"
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "Records"
  INFOVAL = rec_ctr
  Address ISPEXEC "TBAdd infotabl"

  file_size = Length(idtf_data)
  total_blks = file_size % SYSBLKSIZE
  total_rem  = file_size // SYSBLKSIZE
  If (total_rem > 0) then total_blks = Total_blks + 1
  total_recs = file_size / SYSLRECL

  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = ""
  INFOVAL = ""
  Address ISPEXEC "TBAdd infotabl"

  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "EXECIO"
  INFOVAL = Copies("=",zscreenw - 11)
  Address ISPEXEC "TBAdd infotabl"

  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "Blocks"
  INFOVAL = total_blks
  Address ISPEXEC "TBAdd infotabl"

  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "Records"
  INFOVAL = total_recs
  Address ISPEXEC "TBAdd infotabl"

  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "Bytes"
  INFOVAL = file_size
  Address ISPEXEC "TBAdd infotabl"

  go_no_further = 1

  MSICPHSE = "6 of 13"
  Address ISPEXEC "CONTROL DISPLAY LOCK"
  Address ISPEXEC "DISPLAY PANEL(MSICPPRG)"
  If (Pos("\INMR01",idtf_data) <> 2) Then Do
    Address ISPEXEC "TBVCLEAR infotabl"
    INFOKEY = ""
    INFOVAL = ""
    Address ISPEXEC "TBAdd infotabl"
    Address ISPEXEC "TBVCLEAR infotabl"
    INFOKEY = "**ERROR**"
    INFOVAL = "This is not an IDTF data set. \INMR01<>2"
    Address ISPEXEC "TBAdd infotabl"
    Address ISPEXEC "TBVCLEAR infotabl"
    INFOKEY = ""
    INFOVAL = ""
    Address ISPEXEC "TBAdd infotabl"
    go_no_further = 0
  End
  If (Pos("\INMR06",idtf_data) = 0) Then Do
    Address ISPEXEC "TBVCLEAR infotabl"
    INFOKEY = ""
    INFOVAL = ""
    Address ISPEXEC "TBAdd infotabl"
    Address ISPEXEC "TBVCLEAR infotabl"
    INFOKEY = "**ERROR**"
    INFOVAL = "This is either not an IDTF data set" ,
      "or it has been truncated during transmission."
    Address ISPEXEC "TBAdd infotabl"
    Address ISPEXEC "TBVCLEAR infotabl"
    INFOKEY = ""
    INFOVAL = ""
    Address ISPEXEC "TBAdd infotabl"
    go_no_further = 0
  End

  If (go_no_further = 1) Then Do
    idtf_headers_rc = idtf_more_headers()
  End
  Address ISPEXEC "REMPOP"


  Address ISPEXEC "VGet (ZSCREENW)"
  hw = (ZSCREENW - 16) % 2
  ZTDMARK = Copies("-",hw)"> End of IDTF information. <"Copies("-",hw)
  Address ISPEXEC "TBTop infotabl"
  ZERRLM = ""
  msicpinf_tbdispl_rc = 0
  Do While (msicpinf_tbdispl_rc < 8)
    Address ISPEXEC "TBDISPL infotabl PANEL(MSICPINF)"
    msicpinf_tbdispl_rc = RC
    If (msicpinf_tbdispl_rc = 8) Then Do
      Leave
    End
    If (ZERRLM <> "") Then Do
      ZERRSM = ask_to_get_help()
      Address ISPEXEC "SETMSG MSG(ISRZ002)"
    End
  End
  Return 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Process records.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_more_headers:
  MSICPHSE = "7 of 13"
  Address ISPEXEC "CONTROL DISPLAY LOCK"
  Address ISPEXEC "DISPLAY PANEL(MSICPPRG)"
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = ""
  INFOVAL = ""
  Address ISPEXEC "TBAdd infotabl"

  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "INMR"
  INFOVAL = Copies("=",zscreenw - 11)
  Address ISPEXEC "TBAdd infotabl"

  char_idx = 1
  segment_counter = 0
  buffer_data_ebcdic = ""
  control_keys = ""
  buffer_data. = ""
  buffer_data.onezerone.0 = 0
  buffer_data.twooneone.0 = 0
  buffer_data.twotwoone.0 = 0
  buffer_data.twotwotwo.0 = 0
  buffer_data.twotwothree.0 = 0
  buffer_data.threeone.0 = 0
  buffer_data.threetwo.0 = 0
  control_counter. = 0
  cr_last_number = ""

  back_here = "IDTF_abnormal_end"
  Signal On Error   Name trapped_an_error
  Signal On Failure Name trapped_an_error
  Signal On Syntax  Name trapped_an_error
  Do Forever
    If (char_idx > file_size) Then Leave
    segment_counter = segment_counter + 1
    segment_len = c2d(SubStr(idtf_data,char_idx,1)) - 2
    char_idx = char_idx + 1
    segment_desc_flag = SubStr(idtf_data,char_idx,1)
    char_idx = char_idx + 1
    If (segment_len < 1) Then Do
      rpt = "SubStr is about to fail, seglen<1 LOC("char_idx")."
      say rpt
      Leave
    End
    segment_char = SubStr(idtf_data,char_idx,segment_len)
    Select
      When (BitAnd(segment_desc_flag,'E0'x) = 'E0'x) Then Do
        control_type = SubStr(buffer_data_ebcdic,1,6)
        buffer_data_ebcdic = segment_char
        Call idtf_prime_control_key
        Address ISPEXEC "TBVCLEAR infotabl"
        INFOKEY = "  E0 " control_type
        INFOVAL = "Complete control record - Length" ,
          Length(buffer_data_ebcdic)
        Address ISPEXEC "TBAdd infotabl"
        Address ISPEXEC "TBVCLEAR infotabl"
        INFOKEY = "  Ec " control_type
        INFOVAL = buffer_data_ebcdic
        Address ISPEXEC "TBAdd infotabl"
        Address ISPEXEC "TBVCLEAR infotabl"
        INFOKEY = "  Et " control_type
        INFOVAL = Top_Half(segment_char)
        Address ISPEXEC "TBAdd infotabl"
        Address ISPEXEC "TBVCLEAR infotabl"
        INFOKEY = "  Eb " control_type
        INFOVAL = Bottom_Half(segment_char)
        Address ISPEXEC "TBAdd infotabl"
        Call idtf_process_control_record
      End
      When (BitAnd(segment_desc_flag,'A0'x) = 'A0'x) Then Do
        buffer_data_ebcdic = segment_char
        Call idtf_prime_control_key
        Address ISPEXEC "TBVCLEAR infotabl"
        INFOKEY = "  A0 " control_type
        INFOVAL = "Begin of multi-part control record"
        Address ISPEXEC "TBAdd infotabl"
      End
      When (BitAnd(segment_desc_flag,'60'x) = '60'x) Then Do
        buffer_data_ebcdic = buffer_data_ebcdic""segment_char
        Address ISPEXEC "TBVCLEAR infotabl"
        INFOKEY = "  60 " control_type
        INFOVAL = "End of control record - Length" Length(buffer_data_ebcdic)
        Address ISPEXEC "TBAdd infotabl"
        Address ISPEXEC "TBVCLEAR infotabl"
        INFOKEY = "  6c " control_type
        INFOVAL = buffer_data_ebcdic
        Address ISPEXEC "TBAdd infotabl"
        Address ISPEXEC "TBVCLEAR infotabl"
        INFOKEY = "  6t " control_type
        INFOVAL = Top_Half(buffer_data_ebcdic)
        Address ISPEXEC "TBAdd infotabl"
        Address ISPEXEC "TBVCLEAR infotabl"
        INFOKEY = "  6b " control_type
        INFOVAL = Bottom_Half(buffer_data_ebcdic)
        Address ISPEXEC "TBAdd infotabl"
        Call idtf_process_control_record
      End
      When (BitAnd(segment_desc_flag,'20'x) = '20'x) Then Do
        buffer_data_ebcdic = buffer_data_ebcdic""segment_char
        Address ISPEXEC "TBVCLEAR infotabl"
        INFOKEY = "  20 " control_type
        INFOVAL = "Middle of control record"
        Address ISPEXEC "TBAdd infotabl"
      End
      When (BitAnd(segment_desc_flag,'C0'x) = 'C0'x) Then Do
        buffer_data_ebcdic = segment_char
        temp = buffer_data.control_key.0 + 1
        buffer_data.control_key.temp = buffer_data_ebcdic
        buffer_data.control_key.0 = temp
      End
      When (BitAnd(segment_desc_flag,'80'x) = '80'x) Then Do
        buffer_data_ebcdic = segment_char
      End
      When (BitAnd(segment_desc_flag,'40'x) = '40'x) Then Do
        buffer_data_ebcdic = buffer_data_ebcdic""segment_char
        temp = buffer_data.control_key.0 + 1
        buffer_data.control_key.temp = buffer_data_ebcdic
        buffer_data.control_key.0 = temp
      End
      When (BitAnd(segment_desc_flag,'00'x) = '00'x) Then Do
        buffer_data_ebcdic = buffer_data_ebcdic""segment_char
      End
      When (BitAnd(segment_desc_flag,'10'x) = '10'x) Then Do
        Say "10=This is record number of next record. Huh?"
      End
      When (BitAnd(segment_desc_flag,'0F'x) = '0F'x) Then Do
        Say "0F=This is reserved. Whole lot of help that is to me."
      End
      Otherwise Do
        say c2x(segment_desc_flag) "is not in my list"
        buffer_data_ebcdic = buffer_data_ebcdic""segment_char
      End
    End
    char_idx = char_idx + segment_len
  End

  MSICPHSE = "13 of 13"
  Address ISPEXEC "CONTROL DISPLAY LOCK"
  Address ISPEXEC "DISPLAY PANEL(MSICPPRG)"
  If ((txtunit_INMUTILN.twooneone = "INMCOPY") & ,
      (txtunit_INMTERM.twooneone = "Y")) Then Do
    Address ISPEXEC "TBVCLEAR infotabl"
    INFOKEY = ""
    INFOVAL = ""
    Address ISPEXEC "TBAdd infotabl"
    Address ISPEXEC "TBVCLEAR infotabl"
    INFOKEY = "Message"
    INFOVAL = Copies("+",zscreenw - 11)
    Address ISPEXEC "TBAdd infotabl"
    msgmax = buffer_data.threeone.0
    Do mx = 1 to msgmax
      Address ISPEXEC "TBVCLEAR infotabl"
      INFOKEY = "MSG-"Right(mx,Length(msgmax),"0")
      msg = buffer_data.threeone.mx
      INFOVAL = msg
      Address ISPEXEC "TBAdd infotabl"
    End
    Address ISPEXEC "TBVCLEAR infotabl"
    INFOKEY = "Message"
    INFOVAL = Copies("+",zscreenw - 11)
    Address ISPEXEC "TBAdd infotabl"
  End
  If (txtunit_INMUTILN.twooneone = "IEBCOPY") Then Do
    Address ISPEXEC "TBVCLEAR infotabl"
    INFOKEY = ""
    INFOVAL = ""
    Address ISPEXEC "TBAdd infotabl"
    Address ISPEXEC "TBVCLEAR infotabl"
    INFOKEY = "IEBCOPY HDR1"
    INFOVAL = Copies("~",zscreenw - 11)
    Address ISPEXEC "TBAdd infotabl"
    data_line = buffer_data.threeone.1
    Address ISPEXEC "TBVCLEAR infotabl"
    INFOKEY = "IEBCOPY 211 31"
    INFOVAL = c2x(data_line)
    Address ISPEXEC "TBAdd infotabl"
    Call IEBCOPY_decode_hdr1
    Address ISPEXEC "TBVCLEAR infotabl"
    INFOKEY = "IEBCOPY HDR1"
    INFOVAL = Copies("~",zscreenw - 11)
    Address ISPEXEC "TBAdd infotabl"
    Address ISPEXEC "TBVCLEAR infotabl"
    INFOKEY = "IEBCOPY HDR2"
    INFOVAL = Copies("~",zscreenw - 11)
    Address ISPEXEC "TBAdd infotabl"
    data_line = buffer_data.threeone.2
    Call IEBCOPY_decode_hdr2
    Address ISPEXEC "TBVCLEAR infotabl"
    INFOKEY = "IEBCOPY HDR2"
    INFOVAL = Copies("~",zscreenw - 11)
    Address ISPEXEC "TBAdd infotabl"
  End
  If (txtunit_INMUTILN.twotwotwo = "INMCOPY") Then Do
    Address ISPEXEC "TBVCLEAR infotabl"
    INFOKEY = ""
    INFOVAL = ""
    Address ISPEXEC "TBAdd infotabl"
    Address ISPEXEC "TBVCLEAR infotabl"
    INFOKEY = "INMCOPY PS"
    INFOVAL = "Physical sequential data set"
    Address ISPEXEC "TBAdd infotabl"
  End
  If (txtunit_INMUTILN.twotwotwo = "IEBCOPY") Then Do
    Address ISPEXEC "TBVCLEAR infotabl"
    INFOKEY = ""
    INFOVAL = ""
    Address ISPEXEC "TBAdd infotabl"
    Address ISPEXEC "TBVCLEAR infotabl"
    INFOKEY = "IEBCOPY HDR1"
    INFOVAL = Copies("~",zscreenw - 11)
    Address ISPEXEC "TBAdd infotabl"
    data_line = buffer_data.threetwo.1
    Address ISPEXEC "TBVCLEAR infotabl"
    INFOKEY = "IEBCOPY 221 32"
    INFOVAL = c2x(data_line)
    Address ISPEXEC "TBAdd infotabl"
    Call IEBCOPY_decode_hdr1
    Address ISPEXEC "TBVCLEAR infotabl"
    INFOKEY = "IEBCOPY HDR1"
    INFOVAL = Copies("~",zscreenw - 11)
    Address ISPEXEC "TBAdd infotabl"
    Address ISPEXEC "TBVCLEAR infotabl"
    INFOKEY = "IEBCOPY HDR2"
    INFOVAL = Copies("~",zscreenw - 11)
    Address ISPEXEC "TBAdd infotabl"
    data_line = buffer_data.threetwo.2
    Call IEBCOPY_decode_hdr2
    Address ISPEXEC "TBVCLEAR infotabl"
    INFOKEY = "IEBCOPY HDR2"
    INFOVAL = Copies("~",zscreenw - 11)
    Address ISPEXEC "TBAdd infotabl"
  End
IDTF_abnormal_end:
  Return 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Prime the control key based on control_type
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_prime_control_key:
  control_type = SubStr(buffer_data_ebcdic,1,6)
  next_byte = 7
  temp = control_counter.control_type + 1
  control_counter.control_type = temp
  Select
    When (control_type = "INMR01") Then Do
      control_key = "1_"crfile_number"_"control_counter.control_type
      Address ISPEXEC "TBVCLEAR infotabl"
      INFOKEY = "INMR01" control_key
      INFOVAL = Copies("-",zscreenw - 11)
      Address ISPEXEC "TBAdd infotabl"
    End
    When (control_type = "INMR02") Then Do
      inmr02_counter = control_counter.control_type
      crfile_number = c2d(SubStr(buffer_data_ebcdic,next_byte,4))
      control_key = "2_"inmr02_counter"_"crfile_number
      Address ISPEXEC "TBVCLEAR infotabl"
      INFOKEY = "INMR02" control_key
      INFOVAL = Copies("-",zscreenw - 11)
      Address ISPEXEC "TBAdd infotabl"
    End
    When (control_type = "INMR03") Then Do
      inmr03_counter = control_counter.control_type
      control_key = "3_"inmr03_counter
      Address ISPEXEC "TBVCLEAR infotabl"
      INFOKEY = "INMR03" control_key
      INFOVAL = Copies("-",zscreenw - 11)
      Address ISPEXEC "TBAdd infotabl"
    End
    When (control_type = "INMR04") Then Do
      inmr04_counter = control_counter.control_type
      control_key = "4_"inmr04_counter
      Address ISPEXEC "TBVCLEAR infotabl"
      INFOKEY = "INMR04" control_key
      INFOVAL = Copies("-",zscreenw - 11)
      Address ISPEXEC "TBAdd infotabl"
    End
    When (control_type = "INMR06") Then Do
      inmr06_counter = control_counter.control_type
      control_key = "6_"inmr06_counter"_1"
      Address ISPEXEC "TBVCLEAR infotabl"
      INFOKEY = "INMR06" control_key
      INFOVAL = Copies("-",zscreenw - 11)
      Address ISPEXEC "TBAdd infotabl"
    End
    When (control_type = "INMR07") Then Do
      inmr07_counter = control_counter.control_type
      control_key = "7_"inmr07_counter
      Address ISPEXEC "TBVCLEAR infotabl"
      INFOKEY = "INMR07" control_key
      INFOVAL = Copies("-",zscreenw - 11)
      Address ISPEXEC "TBAdd infotabl"
    End
    Otherwise Do
      ZERRSM = ask_to_get_help()
      ZERRLM = ZERRLM || ,
        Left("Bad IDTF data set - truncated?",79)
      Address ISPEXEC "SETMSG MSG(ISRZ002)"
      char_idx = file_size
    End
  End
  Return 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Process INMR* records.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_process_control_record:
  next_byte = 7
  Select
    When (control_type = "INMR01") Then Do
      MSICPHSE = "8 of 13"
      Address ISPEXEC "CONTROL DISPLAY LOCK"
      Address ISPEXEC "DISPLAY PANEL(MSICPPRG)"
      control_key = "1_"crfile_number"_"control_counter.control_type
      control_keys = control_keys || control_key || " "
      Call idtf_parse_subtypes
    End
    When (control_type = "INMR02") Then Do
      MSICPHSE = "9 of 13"
      Address ISPEXEC "CONTROL DISPLAY LOCK"
      Address ISPEXEC "DISPLAY PANEL(MSICPPRG)"
      inmr02_counter = control_counter.control_type
      crfile_number = c2d(SubStr(buffer_data_ebcdic,next_byte,4))
      control_key = "2_"inmr02_counter"_"crfile_number
      cr_last_number = crfile_number
      control_keys = control_keys || control_key || " "
      max_r02.crfile_number = control_counter.control_type
      next_byte = next_byte + 4
      Call idtf_parse_subtypes
    End
    When (control_type = "INMR03") Then Do
      MSICPHSE = "10 of 13"
      Address ISPEXEC "CONTROL DISPLAY LOCK"
      Address ISPEXEC "DISPLAY PANEL(MSICPPRG)"
      inmr03_counter = control_counter.control_type
      control_key = "3_"inmr03_counter
      control_keys = control_keys || control_key || " "
      Call idtf_parse_subtypes
    End
    When (control_type = "INMR04") Then Do
      MSICPHSE = "11 of 13"
      Address ISPEXEC "CONTROL DISPLAY LOCK"
      Address ISPEXEC "DISPLAY PANEL(MSICPPRG)"
      inmr04_counter = control_counter.control_type
      control_key = "4_"inmr04_counter
      control_keys = control_keys || control_key || " "
      Call idtf_parse_subtypes
    End
    When (control_type = "INMR06") Then Do
      MSICPHSE = "13 of 13"
      Address ISPEXEC "CONTROL DISPLAY LOCK"
      Address ISPEXEC "DISPLAY PANEL(MSICPPRG)"
      inmr06_counter = control_counter.control_type
      control_key = "6_"inmr06_counter"_1"
      control_keys = control_keys || control_key || " "
      segment_len = file_size
    End
    When (control_type = "INMR07") Then Do
      MSICPHSE = "12 of 13"
      Address ISPEXEC "CONTROL DISPLAY LOCK"
      Address ISPEXEC "DISPLAY PANEL(MSICPPRG)"
      inmr07_counter = control_counter.control_type
      control_key = "7_"inmr07_counter
      control_keys = control_keys || control_key || " "
      Call idtf_parse_subtypes
    End
    Otherwise Do
      Say "Unknown control record type" control_type"."
      rpt = "     CR # =" crfile_number control_counter.control_type
      Say rpt
    End
  End
  Return 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Decode the dataset attributes
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
IEBCOPY_decode_hdr1:
  Parse Var data_line        /* loadlib    panels   */ ,
                             /* pds        pdse     */ ,
    pds_pdse        +4       /* 00CA6D0F   01CA6D0F */ ,
    dsorg           +2       /* 0200       0200     */ ,
    blksize         +2       /* 7FF8       6D10     */ ,
    lrecl           +2       /* 0000       0050     */ ,
    recfm           +2       /* C000       9000     */ ,
    .               +2       /* 0080       0000     */ ,
    minblksize      +2       /* 0C30       0C30     */ ,
    .               +2       /* 3030       0008     */ ,
    devtype         +1       /* 20         20       */ ,
    dasdtype        +1       /* 0F         00       */ ,
    .               +2       /* 0000       0000     */ ,
    maxblksize      +2       /* 7FF8       7FF8     */ ,
    devcapacity     +2       /* 0D0B       0100     */ ,
    cylcapacity     +2       /* 000F       0100     */ ,
    trkcapacity     +2       /* E5A2       FFFF     */ ,
    .               +2       /* 0000       0000     */ ,
    .               +2       /* 2252       0000     */ ,
    .               +2       /* 0000       0000     */ ,
    .               +2       /* 00B4       0000     */ ,
    .               +1       /* 80         00       */ ,
    used_blksize    +2       /* 7FF8       0000     */ ,
    used_lrecl      +1       /* 50         00       */ ,
    .               +2       /* 0000       0000     */ ,
    .               +2       /* 0F00       0000     */ ,
    .               +4       /* 03135632   00000000 */ ,
    .               +2       /* 0000       0000     */ ,
    .               +2       /* 0000       0000     */ ,
    .               +2       /* 0000       0000     */ ,
    warn_me
  hex_pds_pdse = c2x(pds_pdse)
  dev_trk_cyl = c2d(cylcapacity)
  Select
    When (hex_pds_pdse = "00CA6D0F") Then display_pds_pdse = "PDS"
    When (hex_pds_pdse = "01CA6D0F") Then display_pds_pdse = "PDSE"
    When (hex_pds_pdse = "11CA6D0F") Then display_pds_pdse = "PDSE"
    Otherwise Do
      display_pds_pdse = "UNK-"hex_pds_pdse
    End
  End
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = display_pds_pdse
  INFOVAL = hex_pds_pdse
  Address ISPEXEC "TBAdd infotabl"
  dsorg   = idtf_parse_INMDSORG_meaning(c2x(dsorg))
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "DSORG"
  INFOVAL = dsorg
  Address ISPEXEC "TBAdd infotabl"
  recfm   = idtf_parse_INMRECFM_meaning(c2x(recfm))
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "RECFM"
  INFOVAL = recfm
  Address ISPEXEC "TBAdd infotabl"
  blksize = c2d(blksize)
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "BLKSIZE"
  INFOVAL = blksize
  Address ISPEXEC "TBAdd infotabl"
  lrecl = c2d(lrecl)
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "LRECL"
  INFOVAL = lrecl
  Address ISPEXEC "TBAdd infotabl"
  lrecl = c2d(used_lrecl)
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "Used LRECL"
  INFOVAL = lrecl
  Address ISPEXEC "TBAdd infotabl"
  minblksize = c2d(minblksize)
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "MINBLKSIZE"
  INFOVAL = minblksize
  Address ISPEXEC "TBAdd infotabl"
  maxblksize = c2d(maxblksize)
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "MAXBLKSIZE"
  INFOVAL = maxblksize
  Address ISPEXEC "TBAdd infotabl"
  devcapacity = c2d(devcapacity)
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "DEVCAPACITY"
  INFOVAL = devcapacity
  Address ISPEXEC "TBAdd infotabl"
  cylcapacity = c2d(cylcapacity)
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "CYLCAPACITY"
  INFOVAL = cylcapacity
  Address ISPEXEC "TBAdd infotabl"
  trkcapacity = c2d(trkcapacity)
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "TRKCAPACITY"
  INFOVAL = trkcapacity
  Address ISPEXEC "TBAdd infotabl"
  dasdname = convert_dasdtype(dasdtype devcapacity)
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "DASDNAME"
  INFOVAL = dasdname
  Address ISPEXEC "TBAdd infotabl"
  If (warn_me <> "") Then Do
    Address ISPEXEC "TBVCLEAR infotabl"
    INFOKEY = "Warn Me"
    INFOVAL = c2x(warn_me)
    Address ISPEXEC "TBAdd infotabl"
  End
  mbr_char. = ""
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Convert dasdtype to displayable meaning
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
convert_dasdtype:
  Parse Arg bin_dasdtype dec_devcapacity
  hex_dasdtype = c2x(bin_dasdtype)
  d_dasdtype = Value("dasd_model."hex_dasdtype"."dec_devcapacity)
  Return d_dasdtype
/*dasd_model.{dasdtype}.{max_cyl} = model_type                 */

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Decode the dataset adjustments.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
IEBCOPY_decode_hdr2:
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "Record2"
  INFOVAL = C2X(data_line)
  Address ISPEXEC "TBAdd infotabl"
  Select
    When (c2x(left(data_line,4)) = "01000000") Then Do
      Parse Var data_line,
        control_word    +4       /* 01000000 */ ,
        reserved_1      +4       /* FF000000 */ ,
        reserved_2      +4       /* 8F0AD000 */ ,
        reserved_3      +4       /* 0479D0C8 */ ,
        reserved_4      +4       /* 58F537A0 */ ,
        reserved_5      +2       /* 0000     */ ,
        cc_beg          +2       /* 0976     */ ,
        hh_beg          +2       /*     000A */ ,
        cc_end          +2       /* 097A     */ ,
        hh_end          +2       /*     0009 */ ,
        cc_hh_ctr       +2       /* 003C     */ ,
        reserved_8      +4       /* 00000000 */ ,
        reserved_9      +4       /* 00000000 */ ,
        reserved_10     +4       /* 00000000 */ ,
        reserved_11     +4       /* 00000000 */ ,
        reserved_12     +4       /* 00000000 */ ,
        reserved_13     +4       /* 00000000 */ ,
        reserved_14     +4       /* 00000000 */ ,
        reserved_15     +4       /* 00000000 */ ,
        reserved_16     +212     /* -00-     */ ,
      warn_me
    End
    When (c2x(left(data_line,4)) = "03000000") Then Do
      Parse Var data_line,
        control_word    +4       /* 03000000 */ ,
        reserved_1      +4       /* FF000000 */ ,
        reserved_2      +4       /* 8F000000 */ ,
        reserved_3      +4       /* 04000000 */ ,
        reserved_4      +4       /* 0008C170 */ ,
        cc_beg          +2       /* 0000     */ ,
        hh_beg          +2       /*     0000 */ ,
        cc_hh_ctr       +4       /* 0000007E */ ,
        reserved_7      +4       /* 00FF7F00 */ ,
        reserved_8      +4       /* 0008C170 */ ,
        reserved_9      +4       /* 0000007F */ ,
        reserved_10     +4       /* 000000FD */ ,
        reserved_11     +4       /* 00FF7F00 */ ,
        reserved_12     +4       /* 0008C170 */ ,
        reserved_13     +4       /* 000000FE */ ,
        reserved_14     +4       /* 000000FF */ ,
        reserved_15     +4       /* FF020000 */ ,
        reserved_16     +212     /* ???????? */ ,
      warn_me
    End
    When (c2x(left(data_line,4)) = "04000000") Then Do
      Parse Var data_line,
        control_word    +4       /* 04000000 */ ,
        reserved_1      +4       /* FF000000 */ ,
        reserved_2      +4       /* 8F000000 */ ,
        reserved_3      +4       /* 04000000 */ ,
        reserved_4      +4       /* 0008C170 */ ,
        cc_beg          +2       /* 0000     */ ,
        hh_beg          +2       /*     0000 */ ,
        cc_hh_ctr       +4       /* 0000007E */ ,
        reserved_7      +4       /* 00FF7F00 */ ,
        reserved_8      +4       /* 0008C170 */ ,
        reserved_9      +4       /* 0000007F */ ,
        reserved_10     +4       /* 000000FD */ ,
        reserved_11     +4       /* 00FF7F00 */ ,
        reserved_12     +4       /* 0008C170 */ ,
        reserved_13     +4       /* 000000FE */ ,
        reserved_14     +4       /* 000000FF */ ,
        reserved_15     +4       /* FF020000 */ ,
        reserved_16     +212     /* ???????? */ ,
      warn_me
    End
    Otherwise Do
      control_word = left(data_line,4)
      cc_beg = '0000'x
      hh_beg = '0000'x
    End
  End

  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "Control"
  INFOVAL = C2X(control_word)
  Address ISPEXEC "TBAdd infotabl"
  hex_cc_beg = c2x(cc_beg)
  hex_hh_beg = c2x(hh_beg)
  /*
  dec_cc_beg = c2d(cc_beg)
  dec_hh_beg = c2d(hh_beg)
  */
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "cchh"
  INFOVAL = hex_cc_beg||hex_hh_beg
  Address ISPEXEC "TBAdd infotabl"
  If (warn_me <> "") Then Do
    Address ISPEXEC "TBVCLEAR infotabl"
    INFOKEY = "Warn Me"
    INFOVAL = c2x(warn_me)
    Address ISPEXEC "TBAdd infotabl"
  End
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 control records are made up of text units:
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_subtypes:
  Do While next_byte < Length(buffer_data_ebcdic)
    txtunit_key = c2x(SubStr(buffer_data_ebcdic,next_byte,2))
    next_byte = next_byte + 2
    txtunit_qty = c2d(SubStr(buffer_data_ebcdic,next_byte,2))
    next_byte = next_byte + 2
    Select
      When txtunit_key = '0001' Then Call idtf_parse_INMDDNAM
      When txtunit_key = '0002' Then Call idtf_parse_INMDSNAM
      When txtunit_key = '0003' Then Call idtf_parse_INMMEMBR
      When txtunit_key = '000B' Then Call idtf_parse_INMSECND
      When txtunit_key = '000C' Then Call idtf_parse_INMDIR
      When txtunit_key = '0022' Then Call idtf_parse_INMEXPDT
      When txtunit_key = '0028' Then Call idtf_parse_INMTERM
      When txtunit_key = '0030' Then Call idtf_parse_INMBLKSZ
      When txtunit_key = '003C' Then Call idtf_parse_INMDSORG
      When txtunit_key = '0042' Then Call idtf_parse_INMLRECL
      When txtunit_key = '0049' Then Call idtf_parse_INMRECFM
      When txtunit_key = '1001' Then Call idtf_parse_INMTNODE
      When txtunit_key = '1002' Then Call idtf_parse_INMTUID
      When txtunit_key = '1011' Then Call idtf_parse_INMFNODE
      When txtunit_key = '1012' Then Call idtf_parse_INMFUID
      When txtunit_key = '1020' Then Call idtf_parse_INMLREF
      When txtunit_key = '1021' Then Call idtf_parse_INMLCHG
      When txtunit_key = '1022' Then Call idtf_parse_INMCREAT
      When txtunit_key = '1023' Then Call idtf_parse_INMFVERS
      When txtunit_key = '1024' Then Call idtf_parse_INMFTIME
      When txtunit_key = '1025' Then Call idtf_parse_INMTTIME
      When txtunit_key = '1026' Then Call idtf_parse_INMFACK
      When txtunit_key = '1027' Then Call idtf_parse_INMERRCD
      When txtunit_key = '1028' Then Call idtf_parse_INMUTILN
      When txtunit_key = '1029' Then Call idtf_parse_INMUSERP
      When txtunit_key = '102A' Then Call idtf_parse_INMRECCT
      When txtunit_key = '102C' Then Call idtf_parse_INMSIZE
      When txtunit_key = '102D' Then Call idtf_parse_INMFFM
      When txtunit_key = '102F' Then Call idtf_parse_INMNUMF
      When txtunit_key = '8012' Then Call idtf_parse_INMTYPE
      When txtunit_key = '8018' Then Call idtf_parse_INMLSIZE
      When txtunit_key = '8028' Then Call idtf_parse_INMEATTR
      Otherwise Do
        Address ISPEXEC "TBVCLEAR infotabl"
        INFOKEY = "??ERROR??"
        INFOVAL = txtunit_key "in SG("segment_counter")" ,
          C2X(SubStr(buffer_data_ebcdic,next_byte,20))
        Address ISPEXEC "TBAdd infotabl"
      End
    End
  End
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 DDNAME
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMDDNAM:
  Do txx = 1 to txtunit_qty
    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))
    next_byte = next_byte + 2
    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)
    txtunit_INMDDNAM.control_key = ,
      txtunit_INMDDNAM.control_key""txtunit_char" "
    next_byte = next_byte + txtunit_len
  End
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "0001 INMDDNAM"
  INFOVAL = txtunit_INMDDNAM.control_key
  Address ISPEXEC "TBAdd infotabl"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Dataset name
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMDSNAM:
  full_dsname = ""
  Do txx = 1 to txtunit_qty
    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))
    next_byte = next_byte + 2
    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)
    full_dsname = full_dsname""txtunit_char"."
    next_byte = next_byte + txtunit_len
  End
  full_dsname = strip(full_dsname,"B",".")
  txtunit_INMDSNAM.control_key = ,
    txtunit_INMDSNAM.control_key""full_dsname
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "0002 INMDSNAM"
  INFOVAL = txtunit_INMDSNAM.control_key
  Address ISPEXEC "TBAdd infotabl"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Select member names
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMMEMBR:
  Do txx = 1 to txtunit_qty
    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))
    next_byte = next_byte + 2
    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)
    txtunit_INMMEMBR.control_key = ,
      txtunit_INMMEMBR.control_key||txtunit_char" "
    next_byte = next_byte + txtunit_len
  End
  txtunit_INMMEMBR.control_key = ,
    Strip(txtunit_INMMEMBR.control_key,"T"," ")
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "0003 INMMEMBR"
  INFOVAL = txtunit_INMMEMBR.control_key
  Address ISPEXEC "TBAdd infotabl"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Secondary space
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMSECND:
  Do txx = 1 to txtunit_qty
    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))
    next_byte = next_byte + 2
    txtunit_char = c2d(SubStr(buffer_data_ebcdic,next_byte,txtunit_len))
    txtunit_INMSECND.control_key = ,
      txtunit_INMSECND.control_key""txtunit_char" "
    next_byte = next_byte + txtunit_len
  End
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "000B INMSECND"
  INFOVAL = txtunit_INMSECND.control_key
  Address ISPEXEC "TBAdd infotabl"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Number of directory blocks for PDS
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMDIR:
  Do txx = 1 to txtunit_qty
    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))
    next_byte = next_byte + 2
    txtunit_char = c2d(SubStr(buffer_data_ebcdic,next_byte,txtunit_len))
    txtunit_INMDIR.control_key = ,
      txtunit_INMDIR.control_key""txtunit_char" "
    next_byte = next_byte + txtunit_len
  End
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "000C INMDIR"
  INFOVAL = txtunit_INMDIR.control_key
  Address ISPEXEC "TBAdd infotabl"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Expiration date
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMEXPDT:
  Do txx = 1 to txtunit_qty
    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))
    next_byte = next_byte + 2
    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)
    txtunit_INMEXPDT.control_key = ,
      txtunit_INMEXPDT.control_key""txtunit_char" "
    next_byte = next_byte + txtunit_len
  End
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "0022 INMEXPDT"
  INFOVAL = txtunit_INMEXPDT.control_key
  Address ISPEXEC "TBAdd infotabl"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Was input taken from the terminal (message).
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMTERM:
  txtunit_INMTERM.control_key = ,
    txtunit_INMTERM.control_key"Y"
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "0028 INMTERM"
  INFOVAL = txtunit_INMTERM.control_key
  Address ISPEXEC "TBAdd infotabl"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Block size
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMBLKSZ:
  Do txx = 1 to txtunit_qty
    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))
    next_byte = next_byte + 2
    txtunit_char = c2d(SubStr(buffer_data_ebcdic,next_byte,txtunit_len))
    txtunit_INMBLKSZ.control_key = ,
      txtunit_INMBLKSZ.control_key""txtunit_char" "
    next_byte = next_byte + txtunit_len
  End
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "0030 INMBLKSZ"
  INFOVAL = txtunit_INMBLKSZ.control_key
  Address ISPEXEC "TBAdd infotabl"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Dataset organization
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMDSORG:
  Do txx = 1 to txtunit_qty
    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))
    next_byte = next_byte + 2
    txtunit_char = c2x(SubStr(buffer_data_ebcdic,next_byte,txtunit_len))
    dsorg   = idtf_parse_INMDSORG_meaning(txtunit_char)
    txtunit_INMDSORG.control_key = ,
      txtunit_INMDSORG.control_key""dsorg" "
    next_byte = next_byte + txtunit_len
  End
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "003C INMDSORG"
  INFOVAL = txtunit_INMDSORG.control_key
  Address ISPEXEC "TBAdd infotabl"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 convert dsorg to displayable meaning
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMDSORG_meaning: Procedure
  Parse Arg hex_dsorg
  Select
    When hex_dsorg = "0200" Then real_dsorg = "PO"
    When hex_dsorg = "4000" Then real_dsorg = "PS"
    When hex_dsorg = "0008" Then real_dsorg = "VSAM"  /* Did this ever work? */
    When hex_dsorg = "0000" Then real_dsorg = "U"        /* Obsolete */
    When hex_dsorg = "2000" Then real_dsorg = "DA"       /* Obsolete */
    When hex_dsorg = "8000" Then real_dsorg = "ISAM"     /* Obsolete */
    Otherwise Do
      real_dsorg = "NONE"
    End
  End
  Return real_dsorg

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 logical record length
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMLRECL:
  Do txx = 1 to txtunit_qty
    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))
    next_byte = next_byte + 2
    txtunit_char = c2d(SubStr(buffer_data_ebcdic,next_byte,txtunit_len))
    txtunit_INMLRECL.control_key = ,
      txtunit_INMLRECL.control_key""txtunit_char" "
    next_byte = next_byte + txtunit_len
  End
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "0042 INMLRECL"
  INFOVAL = txtunit_INMLRECL.control_key
  Address ISPEXEC "TBAdd infotabl"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 record format
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMRECFM:
  Do txx = 1 to txtunit_qty
    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))
    next_byte = next_byte + 2
    txtunit_char = c2x(SubStr(buffer_data_ebcdic,next_byte,txtunit_len))
    recfm = idtf_parse_INMRECFM_meaning(txtunit_char)
    txtunit_INMRECFM.control_key = ,
      txtunit_INMRECFM.control_key""recfm" "
    next_byte = next_byte + txtunit_len
  End
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "0049 INMRECFM"
  INFOVAL = txtunit_INMRECFM.control_key
  Address ISPEXEC "TBAdd infotabl"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 convert record format to displayable meaning
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMRECFM_meaning: Procedure
  Parse Arg hex_recfm
  real_recfm = ""
  If (BitAnd(hex_recfm,"0001") = "0001") Then Do
    real_recfm = real_recfm"SVBS"
  End
  If (BitAnd(Right(hex_recfm,2),"02") = "02") Then Do
    real_recfm = real_recfm"+noRDW"
  End
  If (BitAnd(hex_recfm,"C000") = "C000") Then Do
    real_recfm = real_recfm"U"
  End
  If (BitAnd(hex_recfm,"4000") = "4000") Then Do
    real_recfm = real_recfm"V"
  End
  If (BitAnd(hex_recfm,"8000") = "8000") Then Do
    real_recfm = real_recfm"F"
  End
  If (BitAnd(hex_recfm,"1000") = "1000") Then Do
    real_recfm = real_recfm"B"
  End
  If (BitAnd(hex_recfm,"2000") = "2000") Then Do
    real_recfm = real_recfm"T"
  End
  If (BitAnd(hex_recfm,"0800") = "0800") Then Do
    real_recfm = real_recfm"S"
  End
  If (BitAnd(hex_recfm,"0200") = "0200") Then Do
    real_recfm = real_recfm"M"
  End
  If (BitAnd(hex_recfm,"0400") = "0400") Then Do
    real_recfm = real_recfm"A"
  End
  Return real_recfm

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 to node
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMTNODE:
  Do txx = 1 to txtunit_qty
    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))
    next_byte = next_byte + 2
    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)
    txtunit_INMTNODE.control_key = ,
      txtunit_INMTNODE.control_key""txtunit_char" "
    next_byte = next_byte + txtunit_len
  End
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "1001 INMTNODE"
  INFOVAL = txtunit_INMTNODE.control_key
  Address ISPEXEC "TBAdd infotabl"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 to userid
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMTUID:
  Do txx = 1 to txtunit_qty
    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))
    next_byte = next_byte + 2
    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)
    txtunit_INMTUID.control_key = ,
      txtunit_INMTUID.control_key""txtunit_char" "
    next_byte = next_byte + txtunit_len
  End
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "1002 INMTUID"
  INFOVAL = txtunit_INMTUID.control_key
  Address ISPEXEC "TBAdd infotabl"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 from node
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMFNODE:
  Do txx = 1 to txtunit_qty
    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))
    next_byte = next_byte + 2
    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)
    txtunit_INMFNODE.control_key = ,
      txtunit_INMFNODE.control_key""txtunit_char" "
    next_byte = next_byte + txtunit_len
  End
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "1011 INMFNODE"
  INFOVAL = txtunit_INMFNODE.control_key
  Address ISPEXEC "TBAdd infotabl"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 from userid
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMFUID:
  Do txx = 1 to txtunit_qty
    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))
    next_byte = next_byte + 2
    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)
    txtunit_INMFUID.control_key = ,
      txtunit_INMFUID.control_key""txtunit_char" "
    next_byte = next_byte + txtunit_len
  End
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "1012 INMFUID"
  INFOVAL = txtunit_INMFUID.control_key
  Address ISPEXEC "TBAdd infotabl"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 last reference date
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMLREF:
  Do txx = 1 to txtunit_qty
    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))
    next_byte = next_byte + 2
    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)
    formatted_date = idtf_format_timestamp(txtunit_char)
    txtunit_INMLREF.control_key = ,
      txtunit_INMLREF.control_key""formatted_date" "
    next_byte = next_byte + txtunit_len
  End
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "1020 INMLREF"
  INFOVAL = txtunit_INMLREF.control_key
  Address ISPEXEC "TBAdd infotabl"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 last change date
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMLCHG:
  Do txx = 1 to txtunit_qty
    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))
    next_byte = next_byte + 2
    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)
    formatted_date = idtf_format_timestamp(txtunit_char)
    txtunit_INMLCHG.control_key = ,
      txtunit_INMLCHG.control_key""formatted_date" "
    next_byte = next_byte + txtunit_len
  End
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "1021 INMLCHG"
  INFOVAL = txtunit_INMLCHG.control_key
  Address ISPEXEC "TBAdd infotabl"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 creation date
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMCREAT:
  Do txx = 1 to txtunit_qty
    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))
    next_byte = next_byte + 2
    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)
    txtunit_INMCREAT.control_key = ,
      txtunit_INMCREAT.control_key""txtunit_char" "
    next_byte = next_byte + txtunit_len
    rpt = rpt txtunit_char
  End
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "1022 INMCREAT"
  INFOVAL = txtunit_INMCREAT.control_key
  Address ISPEXEC "TBAdd infotabl"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 version
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMFVERS:
  Do txx = 1 to txtunit_qty
    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))
    next_byte = next_byte + 2
    txtunit_char = c2d(SubStr(buffer_data_ebcdic,next_byte,txtunit_len))
    txtunit_INMFVERS.control_key = ,
      txtunit_INMFVERS.control_key""txtunit_char" "
    next_byte = next_byte + txtunit_len
  End
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "1023 INMFVERS"
  INFOVAL = txtunit_INMFVERS.control_key
  Address ISPEXEC "TBAdd infotabl"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 modified time
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMFTIME:
  Do txx = 1 to txtunit_qty
    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))
    next_byte = next_byte + 2
    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)
    formatted_date = idtf_format_timestamp(txtunit_char)
    txtunit_INMFTIME.control_key = ,
      txtunit_INMFTIME.control_key""formatted_date" "
    next_byte = next_byte + txtunit_len
  End
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "1024 INMFTIME"
  INFOVAL = txtunit_INMFTIME.control_key
  Address ISPEXEC "TBAdd infotabl"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 transmit time
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMTTIME:
  Do txx = 1 to txtunit_qty
    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))
    next_byte = next_byte + 2
    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)
    formatted_date = idtf_format_timestamp(txtunit_char)
    txtunit_INMTTIME.control_key = ,
      txtunit_INMTTIME.control_key""formatted_date" "
    next_byte = next_byte + txtunit_len
  End
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "1025 INMTTIME"
  INFOVAL = txtunit_INMTTIME.control_key
  Address ISPEXEC "TBAdd infotabl"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 acknowledgement
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMFACK:
  txtunit_INMFACK.control_key = ,
    txtunit_INMFACK.control_key"Y"
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "1026 INMFACK"
  INFOVAL = txtunit_INMFACK.control_key
  Address ISPEXEC "TBAdd infotabl"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 error return code
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMERRCD:
  Do txx = 1 to txtunit_qty
    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))
    next_byte = next_byte + 2
    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)
    txtunit_INMERRCD.control_key = ,
      txtunit_INMERRCD.control_key""txtunit_char" "
    next_byte = next_byte + txtunit_len
  End
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "1027 INMERRCD"
  INFOVAL = txtunit_INMERRCD.control_key
  Address ISPEXEC "TBAdd infotabl"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 utility program name
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMUTILN:
  Do txx = 1 to txtunit_qty
    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))
    next_byte = next_byte + 2
    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)
    txtunit_INMUTILN.control_key = ,
      txtunit_INMUTILN.control_key""txtunit_char" "
    next_byte = next_byte + txtunit_len
  End
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "1028 INMUTILN"
  INFOVAL = txtunit_INMUTILN.control_key
  Address ISPEXEC "TBAdd infotabl"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 user parameters passed to exits
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMUSERP:
  Do txx = 1 to txtunit_qty
    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))
    next_byte = next_byte + 2
    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)
    txtunit_INMUSERP.control_key = ,
      txtunit_INMUSERP.control_key""txtunit_char" "
    next_byte = next_byte + txtunit_len
  End
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "1029 INMUSERP"
  INFOVAL = txtunit_INMUSERP.control_key
  Address ISPEXEC "TBAdd infotabl"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 record count
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMRECCT:
  Do txx = 1 to txtunit_qty
    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))
    next_byte = next_byte + 2
    txtunit_char = c2d(SubStr(buffer_data_ebcdic,next_byte,txtunit_len))
    txtunit_INMRECCT.control_key = ,
      txtunit_INMRECCT.control_key""txtunit_char" "
    next_byte = next_byte + txtunit_len
  End
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "102A INMRECCT"
  INFOVAL = txtunit_INMRECCT.control_key
  Address ISPEXEC "TBAdd infotabl"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 file size
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMSIZE:
  Do txx = 1 to txtunit_qty
    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))
    next_byte = next_byte + 2
    txtunit_char = c2d(SubStr(buffer_data_ebcdic,next_byte,txtunit_len))
    txtunit_INMSIZE.control_key = ,
      txtunit_INMSIZE.control_key""txtunit_char" "
    next_byte = next_byte + txtunit_len
  End
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "102C INMSIZE"
  INFOVAL = txtunit_INMSIZE.control_key
  Address ISPEXEC "TBAdd infotabl"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 cms file mode
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMFFM:
  Do txx = 1 to txtunit_qty
    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))
    next_byte = next_byte + 2
    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)
    txtunit_INMFFM.control_key = ,
      txtunit_INMFFM.control_key""txtunit_char" "
    next_byte = next_byte + txtunit_len
  End
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "102D INMFFM"
  INFOVAL = txtunit_INMFFM.control_key
  Address ISPEXEC "TBAdd infotabl"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 number of files
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMNUMF:
  Do txx = 1 to txtunit_qty
    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))
    next_byte = next_byte + 2
    txtunit_char = c2d(SubStr(buffer_data_ebcdic,next_byte,txtunit_len))
    txtunit_INMNUMF.control_key = ,
      txtunit_INMNUMF.control_key""txtunit_char" "
    next_byte = next_byte + txtunit_len
  End
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "102F INMNUMF"
  INFOVAL = txtunit_INMNUMF.control_key
  Address ISPEXEC "TBAdd infotabl"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 type of data set
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMTYPE:
  Do txx = 1 to txtunit_qty
    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))
    next_byte = next_byte + 2
    txtunit_char = c2x(SubStr(buffer_data_ebcdic,next_byte,txtunit_len))
    dstype = idtf_parse_INMEATTR_meaning(txtunit_char)
    txtunit_INMTYPE.control_key = ,
      txtunit_INMTYPE.control_key""dstype" "
    next_byte = next_byte + txtunit_len
  End
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "8012 INMTYPE"
  INFOVAL = txtunit_INMTYPE.control_key
  Address ISPEXEC "TBAdd infotabl"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Data set size in megabytes
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMLSIZE:
  Do txx = 1 to txtunit_qty
    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))
    next_byte = next_byte + 2
    txtunit_char = c2x(SubStr(buffer_data_ebcdic,next_byte,txtunit_len))
    dstype = c2d(txtunit_char)  /* was idtf_parse_INMEATTR_meaning() */
    txtunit_INMLSIZE.control_key = ,
      txtunit_INMLSIZE.control_key""dstype" "
    next_byte = next_byte + txtunit_len
  End
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "8018 INMLSIZE"
  INFOVAL = txtunit_INMLSIZE.control_key
  Address ISPEXEC "TBAdd infotabl"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Extended attribute status
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMEATTR:
  Do txx = 1 to txtunit_qty
    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))
    next_byte = next_byte + 2
    txtunit_char = c2x(SubStr(buffer_data_ebcdic,next_byte,txtunit_len))
    dstype = c2x(txtunit_char) /* was idtf_parse_INMEATTR_meaning */
    txtunit_INMEATTR.control_key = ,
      txtunit_INMEATTR.control_key""dstype" "
    next_byte = next_byte + txtunit_len
  End
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "8028 INMEATTR"
  INFOVAL = txtunit_INMEATTR.control_key
  Address ISPEXEC "TBAdd infotabl"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 convert type of data set to displayable meaning
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_parse_INMEATTR_meaning: Procedure
  Parse Arg dstype
  Select
    When (dstype = "80") Then real_dstype = "Data Library"
    When (dstype = "40") Then real_dstype = "Program Library"
    When (dstype = "00") Then real_dstype = "No Library"
    Otherwise Do
      real_dstype = "Unknown-"dstype
    End
  End
  Return real_dstype

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 convert date to displayable meaning
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_format_timestamp: Procedure
  Parse Arg pdate
  pdate_yr = SubStr(pdate,1,4)
  pdate_mm = SubStr(pdate,5,2)
  pdate_dy = SubStr(pdate,7,2)
  pdate_hr = SubStr(pdate,9,2)
  pdate_mn = SubStr(pdate,11,2)
  pdate_sc = SubStr(pdate,13,2)
  ddate = pdate_yr'-'pdate_mm'-'pdate_dy,
    pdate_hr":"pdate_mn":"pdate_sc
  Return ddate

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 In this routine we build stem variables for character translations
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
idtf_array_creation:
  crfile_number = 0
  cr_last_number = 0
  control_counter. = 0
  inm_idx = 1
  not_sure = 0
  alias_created. = ""
  output_progress = 0
  txtunit_INMDDNAM. = ""
  txtunit_INMDSNAM. = ""
  txtunit_INMMEMBR. = ""
  txtunit_INMSECND. = ""
  txtunit_INMDIR.    = ""
  txtunit_INMEXPDT. = ""
  txtunit_INMTERM.   = ""
  txtunit_INMBLKSZ. = ""
  txtunit_INMDSORG. = ""
  txtunit_INMLRECL. = ""
  txtunit_INMRECFM. = ""
  txtunit_INMTNODE. = ""
  txtunit_INMTUID.   = ""
  txtunit_INMFNODE. = ""
  txtunit_INMFUID.   = ""
  txtunit_INMLREF.   = ""
  txtunit_INMLCHG.   = ""
  txtunit_INMCREAT. = ""
  txtunit_INMFVERS. = ""
  txtunit_INMFTIME. = ""
  txtunit_INMTTIME. = ""
  txtunit_INMFACK.   = ""
  txtunit_INMERRCD. = ""
  txtunit_INMUTILN. = ""
  txtunit_INMUSERP. = ""
  txtunit_INMRECCT. = ""
  txtunit_INMSIZE.   = ""
  txtunit_INMFFM.    = ""
  txtunit_INMNUMF.   = ""
  txtunit_INMTYPE.   = ""

  dasd_model. = "Custom"
  dasd_model.01.200   = "2311 no-alt"
  dasd_model.01.203   = "2311"
  dasd_model.02.0     = "2301"
  dasd_model.04.0     = "2302"
  dasd_model.04.1440  = "9345-1"
  dasd_model.04.2156  = "9345-2"
  dasd_model.03.0     = "2303"
  dasd_model.05.0     = "2321"
  dasd_model.06.48    = "2305-1 no-alt"
  dasd_model.06.54    = "2305-1"
  dasd_model.07.96    = "2305-2 no-alt"
  dasd_model.07.108   = "2305-2"
  dasd_model.08.200   = "2314 no-alt"
  dasd_model.08.203   = "2314"
  dasd_model.09.404   = "3330-1 no-alt"
  dasd_model.09.411   = "3330-1"
  dasd_model.0A.808   = "3330-11 no-alt"
  dasd_model.0A.815   = "3330-11"
  dasd_model.0B.348   = "3340-35 no-alt"
  dasd_model.0B.360   = "3340-35"
  dasd_model.0B.696   = "3340-70 no-alt"
  dasd_model.0B.708   = "3340-70"
  dasd_model.0C.555   = "3350 no-alt"
  dasd_model.0C.560   = "3350"
  dasd_model.0D.959   = "3375 no-alt"
  dasd_model.0D.960   = "3375"
  dasd_model.0E.885   = "3380-A/B/D/J no-alt"
  dasd_model.0E.886   = "3380-A/B/D/J"
  dasd_model.0E.1770  = "3380-E no-alt"
  dasd_model.0E.1772  = "3380-E"
  dasd_model.0E.2655  = "3380-K no-alt"
  dasd_model.0E.2658  = "3380-K"
  dasd_model.0E.3339  = "3380-Custom"
  dasd_model.0E.3339  = "EMC3380-K no-alt"
  dasd_model.0E.3342  = "EMC3380-K"
  dasd_model.0E.3993  = "EMC3380-KK no-alt"
  dasd_model.0E.3996  = "EMC3380-KK"
  dasd_model.0F.1113  = "3390-1 no-alt"
  dasd_model.0F.1114  = "3390-1"
  dasd_model.0F.2226  = "3390-2 no-alt"
  dasd_model.0F.2227  = "3390-2"
  dasd_model.0F.3339  = "3390-3 no-alt"
  dasd_model.0F.3340  = "3390-3"
  dasd_model.0F.10017 = "3390-9 no-alt"
  dasd_model.0F.10020 = "3390-9"
  dasd_model.0F.32760 = "3390-27 no-alt"
  dasd_model.0F.32763 = "3390-27"
  dasd_model.0F.65520 = "3390-54 no-alt"
  dasd_model.0F.65523 = "3390-54"
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Return from which line this was called from.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
get_my_sigl: Return sigl

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 More than just rounding.
   Floor always goes down to a multiple of height.
   Ceiling always goes up to a multiple of height.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Floor_rtn: Procedure
  Parse Arg @number, @height
  @occurs = (@number % @height)
  Select
    When (@remainder = 0) Then @adjustment = 0
    When (@number < 0) Then @adjustment = -1
    Otherwise Do
      @adjustment = 0
    End
  End
  @result = (@occurs + @adjustment) * @height
  return @result

Ceiling_rtn: Procedure
  Parse Arg @number, @height
  @occurs = @number % @height
  @remainder = @number - (@occurs * @height)
  Select
    When (@remainder = 0) Then @adjustment = 0
    When (@number > 0) Then @adjustment = 1
    Otherwise Do
      @adjustment = 0
    End
  End
  @result = (@occurs + @adjustment) * @height
  return @result

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Set the short message to press a help PFKey.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
trapped_an_error:
  Signal Off Error
  Signal Off Failure
  Signal Off Syntax
  error_line = Sigl
  Address ISPEXEC "TBVCLEAR infotabl"
  INFOKEY = "!ERR!"
  INFOVAL = "On or near" error_line":"Sourceline(error_line)
  Address ISPEXEC "TBAdd infotabl"
  ZERRSM = ask_to_get_help()
  ZERRLM = ZERRLM || ,
    Left("Bad IDTF data set - truncated?",79)
  Address ISPEXEC "SETMSG MSG(ISRZ002)"
  interpret "call" back_here
  Return

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 End of code.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
__DATA__
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================

  SA22-7783-07 z/OS TSO/E Customization
  Chapter 37. Customizing TRANSMIT and RECEIVE

  Text Units and Text Unit Pointer Lists
  --------------------------------------
  Types of text units
  -------------------
  Key  Field    Max Description
  0030 INMBLKSZ    8 Block size
  1022 INMCREAT    8 Creation date GMT
  0001 INMDDNAM    8 DDNAME for the file
  000C INMDIR      8 Number of directory blocks
  0002 INMDSNAM 22*8 Name of the file
                  44 In MVS: # of fields max 22 at up to 8 bytes per
                  16 In CMS: 8b8b2 INMFFM holds filemode number
  003C INMDSORG    2 File organization
                     X'0008' for VSAM
                     X'0200' for partitioned organization
                     X'4000' for physical sequential
  1027 INMERRCD    8 RECEIVE command error code
  0022 INMEXPDT    8 Expiration date GMT
  1026 INMFACK    64 Originator requested notification
  102D INMFFM      1 Filemode number for CMS
  1011 INMFNODE    8 Origin node name or node number
  1024 INMFTIME    8 Origin timestamp
  1012 INMFUID     7 Origin user ID
  1023 INMFVERS    8 Origin version number of the data format
  1021 INMLCHG     8 Date last changed GMT
  0042 INMLRECL    8 Logical record length
  1020 INMLREF     8 Date last referenced GMT
  0003 INMMEMBR  x*8 Member name list
  102F INMNUMF     8 Number of files transmitted
  102A INMRECCT    8 Transmitted record count
  0049 INMRECFM    2 Record format
                     X'0001' Shortened VBS format used for transmission
                     X'xx02' Varying length records without the RDW
                     X'0200' Data includes machine code printer CC
                     X'0400' Data contains ASA printer CC
                     X'0800' Standard fixed or spanned variable records
                     X'1000' Blocked records
                     X'2000' Track overflow or variable ASCII records
                     X'4000' Variable-length records
                     X'8000' Fixed-length records
                     X'C000' Undefined records
  000B INMSECND    3 Secondary space quantity
  102C INMSIZE     8 File size in bytes
  0028 INMTERM     0 Data transmitted as a message
  1001 INMTNODE    8 Target node name or node number
  1025 INMTTIME    8 Destination timestamp
  1002 INMTUID     7 Target user ID
  8012 INMTYPE     1 Data set type
                     X'80' Data library
                     X'40' Program library
                     X'04' extended-format sequential data sets
                     X'01' large format sequential data sets
                     X'00' Assume no library
  1029 INMUSERP  251 User parameter string
  1028 INMUTILN    8 Name of utility program
                     INMCOPY  - Convert to sequential
                     IEBCOPY  - Invoke IEBCOPY to reload PDS
                     AMSCIPHR - AMD for VSAM
  8018 INMLSIZE    4 Size in MB up to 4096 TB  (new with z/OS 1.9)
  8028 INMEATTR    1 Extended attribute status (new with z/OS 1.11)
                     X'00' Unspecified
                     X'01' NO
                     X'02' OPT

  Format of transmitted data
  --------------------------
  Segemented into 255 bytes
    1   (+1) segment length
    2   (+1) segment descriptor flag
             X'E0' Entire control record             '80'x+'40'x+'20'x
             X'C0' Entire data record                '80'x+'40'x
             X'A0' First segment of control record   '80'x+      '20'x
             X'80' First segment of data record.     '80'x
             X'60' Last segment of control record.         '40'x+'20'x
             X'40' Last segment of original record.        '40'x
             X'20' Middle of a control record.                   '20'x
             X'10' This is record number of next record.
             X'0F' Reserved
             X'00' Middle of a data record.
    3 (+253) segment data

  control record formats
  ----------------------
  INMR01 -- header record - Always 1st, only 1
  -----------------------
                   6 INMR02
  REQUIRED:
  1011 INMFNODE    8 Origin node name or node number
  1024 INMFTIME    8 Origin timestamp
  1012 INMFUID     7 Origin user ID
  0042 INMLRECL    8 Logical record length
  1001 INMTNODE    8 Target node name or node number
  1002 INMTUID     7 Target user ID
  OPTIONAL:
  1026 INMFACK    64 Originator requested notification
  1023 INMFVERS    8 Origin version number of the data format
  102F INMNUMF     8 Number of files transmitted
  1029 INMUSERP  251 User parameter string

  INMR02 -- file utility control record 1 or more in reverse order
  -------------------------------------
                   6 INMR02
                   4 Number of the file
  REQUIRED:
  003C INMDSORG    2 File organization
  0042 INMLRECL    8 Logical record length
  0049 INMRECFM    2 Record format
  102C INMSIZE     8 File size in bytes
  1028 INMUTILN    8 Name of utility program
                     INMCOPY  - Convert to sequential
                     IEBCOPY  - Invoke IEBCOPY to reload PDS
                     AMSCIPHR - AMD for VSAM
  OPTIONAL:
  0030 INMBLKSZ    8 Block size
  1022 INMCREAT    8 Creation date GMT
  000C INMDIR      8 Number of directory blocks
  0002 INMDSNAM 22*8 Name of the file
  0022 INMEXPDT    8 Expiration date GMT
  102D INMFFM      1 Filemode number for CMS
  1021 INMLCHG     8 Date last changed GMT
  1020 INMLREF     8 Date last referenced GMT
  0003 INMMEMBR  x*8 Member name list
  0028 INMTERM     0 Data transmitted as a message
  1029 INMUSERP  251 User parameter string

  INMR03 -- data control record immediately precedes data
  -----------------------------
                   6 INMR03
  REQUIRED:
  003C INMDSORG    2 File organization
  0042 INMLRECL    8 Logical record length
  0049 INMRECFM    2 Record format
  102C INMSIZE     8 File size in bytes

  INMR04 -- user control record  anywhere in the control records
  -----------------------------
                   6 INMR04
  REQUIRED:
  1029 INMUSERP  251 User parameter string

  INMR06 -- trailer control record always last
  --------------------------------
                   6 INMR06

  INMR07 -- notification control record
  -------------------------------------
                   6 INMR07
  REQUIRED:
  1024 INMFTIME    8 Origin timestamp
  0002 INMDSNAM 22*8 Name of the file
   OR
  0028 INMTERM     0 Data transmitted as a message
  OPTIONAL:
  1027 INMERRCD    8 RECEIVE command error code
  1026 INMFACK    64 Originator requested notification
  102D INMFFM      1 Filemode number for CMS
  1029 INMUSERP  251 User parameter string


  File data
  ---------
  Dependent on original file and DSORG.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
  Build array of dasd types and characteristics
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
set_dasdtype:
/*                devt   trk_cyl   okey  nokey trk_cap  chr_trk  */
  dasd_type.01 = "2311        10      0     00       0     3625"
  dasd_type.02 = "2301         0      0     00       0        0"
  dasd_type.03 = "2303         0      0     00       0        0"
  dasd_type.04 = "2302/9345    0      0     00       0        0"
  dasd_type.05 = "2321         0      0     00       0        0"
  dasd_type.06 = "2305-1       8    634    202   14568    14136"
  dasd_type.07 = "2305-2       8    289     91   14858    14660"
  dasd_type.08 = "2314        20    191     45    7294     7294"
  dasd_type.09 = "3330-1      19    191     56   13165    13030"
  dasd_type.0A = "3330-11     19    191     56   13165    13030"
  dasd_type.0B = "3340        12    242     75    8535     8368"
  dasd_type.0C = "3350        30    267     82   19254    19069"
  dasd_type.0D = "3375        12    544    160   36000    35616"
  dasd_type.0E = "3380        15    728    236   47968    47476"
  dasd_type.0F = "3390        15      0      0   58786    56664"
  /*  Usage:

      PRE 2305 devices are DRUMs and CELLs, so old I do not have
      device geometry information for them.

      9345 and 3390 okey and nokey are zero because there is a
      complex formula required to determine how much space an
      actual block takes.

      Through trial and error I came up with the 3390 sector sizes
      shown below. Fit your block size in the sector where it fits
      and then determine how many sectors per track you get.

      Otherwise, the trk_cap is how many bytes may be written on
      a track. To your block size you add the overhead bytes. That
      might be not-keyed or keyed. The only keyed dataset I recall
      using was the MVS PASSWORD dataset. These tables are included
      so the information does not get lost.

  device_stats = dasd_type.hex_dasdtype
  Parse Var device_stats,
    dev_name,
    dev_trk_cyl,
    dev_phy_blk,
    dev_blk_key,
    dev_trk_cap,
    dev_chr_trk,
    .
  hex_trk_cap = c2x(dev_trk_cap)
  */
  Return 0

set_3390_sector_sizes:
  bytes_per_sector = ,
            "56664 27998 18542 13682 10796 8906 7548 6518",
            " 5726  5064  4566  4136  3768 3440 3174 2942",
            " 2710  2546  2376  2212  2082 1946 1850 1748",
            " 1646  1550  1482  1386  1318 1250 1182 1154",
            " 1086  1018   984   950   888  854  820  786",
            "  752   718   690   656   622  588  554  520",
            "  486   458   424   390   356  322  288  254",
            "  226   192   158   124    90   56   22"
  bytes_per_sector.0 = words(bytes_per_sector)
  sectors_per_track = ,
            "    1     2     3     4     5    6    7    8",
            "    9    10    11    12    13   14   15   16",
            "   17    18    19    20    21   22   23   24",
            "   25    26    27    28    29   30   31   32",
            "   33    34    35    36    37   38   39   40",
            "   41    42    43    44    45   46   48   49",
            "   50    52    54    55    57   59   61   64",
            "   66    69    72    75    78   82   86"
  sectors_per_track.0 = words(sectors_per_track)
  Return

set_3380_sector_sizes:
/*
Blocks per 3380 track for different (non-keyed) physical block sizes:

     Blocksize Range       Records/Track        Records/Cylinder
   ----------------------------------------------------------------
     47,476 - 23,477             1                    15
     23,476 - 15,477             2                    30
     15,476 - 11,477             3                    45
     11,476 -  9,077             4                    60
      9,076 -  7,477             5                    75
      7,476 -  6,357             6                    90
      6,356 -  5,493             7                   105
      5,492 -  4,821             8                   120
      4,820 -  4,277             9                   135
      4,276 -  3,861            10                   150
      3,860 -  3,477            11                   165
      3,476 -  3,189            12                   180
      3,188 -  2,933            13                   195
      2,932 -  2,677            14                   210
      2,676 -  2,485            15                   225
      2,484 -  2,325            16                   240
      2,324 -  2,165            17                   255
      2,164 -  2,005            18                   270
      2,004 -  1,877            19                   285
      1,877 -  1,781            20                   300
      1,780 -  1,685            21                   315
      1,684 -  1,589            22                   330
      1,588 -  1,493            23                   345
      1,492 -  1,397            24                   360
      1,396 -  1,333            25                   375
      1,332 -  1,269            26                   390
      1,268 -  1,205            27                   405
      1,204 -  1,141            28                   420
      1,140 -  1,077            29                   435
      1,076 -  1,045            30                   450
      1,044 -    981            31                   465
        980 -    949            32                   480
        948 -    917            33                   495
        916 -    853            34                   510
        852 -    821            35                   525
        820 -    789            36                   540
        788 -    757            37                   555
        756 -    725            38                   570
        724 -    693            39                   585
        692 -    661            40                   600
        660 -    629            41                   615
        628 -    597            42                   630
        596 -    565            44                   660
        564 -    533            45                   675
        532 -    501            46                   690
        500 -    469            48                   720
        468 -    437            49                   735
        436 -    405            51                   765
        404 -    373            53                   795
        372 -    341            55                   825
        340 -    309            57                   855
        308 -    277            59                   885
        276 -    245            62                   930
        244 -    213            65                   975
        212 -    181            68                 1,020
        180 -    149            70                 1,065
        148 -    117            74                 1,110
        116 -     85            78                 1,170
         84 -     53            83                 1,245
         52 -     21            88                 1,320
         20 -      1            93                 1,395
*/
  Return 0

set_3375_sector_sizes:
/*
Blocks per 3375 track for different (non-keyed) physical block sizes:

Blocksize Range       Records/Track        Records/Cylinder
--------------------------------------------------------------
35,616 - 17,601             1                    12
17,600 - 11,616             2                    24
11,615 -  8,609             3                    36
 8,608 -  6,817             4                    48
 6,816 -  5,601             5                    60
 5,600 -  4,737             6                    72
 4,736 -  4,097             7                    84
 4,096 -  3,617             8                    96
 3,616 -  3,201             9                   108
 3,200 -  2,881            10                   120
 2,880 -  2,593            11                   132
 2,592 -  2,369            12                   144
 2,368 -  2,177            13                   156
 2,176 -  2,017            14                   168
 2,016 -  1,857            15                   180
 1,856 -  1,729            16                   192
 1,728 -  1,601            17                   204
 1,600 -  1,505            18                   216
 1,504 -  1,409            19                   228
 1,408 -  1,313            20                   240
 1,312 -  1,249            21                   252
 1,248 -  1,153            22                   264
 1,152 -  1,089            23                   276
 1,088 -  1,057            24                   288
 1,056 -    993            25                   300
   992 -    929            26                   312
   928 -    897            27                   324
   832 -    801            29                   348
   800 -    769            30                   360
   768 -    737            31                   372
   736 -    705            32                   384
   704 -    673            33                   396
   672 -    641            34                   408
   640 -    609            35                   420
   608 -    577            36                   432
   576 -    545            37                   444
   544 -    513            38                   456
   512 -    481            40                   480
   480 -    449            41                   492
   448 -    417            43                   516
   416 -    385            45                   540
   384 -    353            46                   552
   352 -    321            48                   576
   320 -    289            51                   612
   288 -    257            53                   636
   256 -    225            56                   672
   224 -    193            59                   708
   192 -    161            62                   744
   160 -    129            70                   840
   128 -     97            75                   900
    96 -     65            80                   960
    32 -      1            86                 1,032
*/
  Return 0

set_3350_sector_sizes:
/*
Blocks per 3350 track for different (non-keyed) physical block sizes:
Blocksize Range       Records/Track        Records/Cylinder
--------------------------------------------------------------
19,069 -  9,443             1                    30
 9,442 -  6,234             2                    60
 6,233 -  4,629             3                    90
 4,628 -  3,666             4                   120
 3,665 -  3,025             5                   150
 3,024 -  2,566             6                   180
 2,565 -  2,222             7                   210
 2,221 -  1,955             8                   240
 1,954 -  1,741             9                   270
 1,740 -  1,566            10                   300
 1,565 -  1,420            11                   330
 1,419 -  1,297            12                   360
 1,296 -  1,191            13                   390
 1,190 -  1,099            14                   420
 1,098 -  1,019            15                   450
 1,018 -    948            16                   480
   947 -    885            17                   510
   884 -    829            18                   540
   828 -    778            19                   570
   777 -    732            20                   600
   731 -    691            21                   630
   690 -    653            22                   660
   652 -    618            23                   690
   617 -    586            24                   720
   585 -    556            25                   750
   555 -    529            26                   780
   528 -    503            27                   810
   502 -    479            28                   840
   478 -    457            29                   870
   456 -    437            30                   900
   436 -    417            31                   930
   416 -    399            32                   960
   398 -    382            33                   990
   381 -    366            34                 1,020
   365 -    350            35                 1,050
   349 -    336            36                 1,080
   335 -    322            37                 1,110
   321 -    309            38                 1,140
   308 -    297            39                 1,170
   296 -    285            40                 1,200
   284 -    274            41                 1,230
   273 -    263            42                 1,260
   262 -    253            43                 1,290
   252 -    243            44                 1,320
   242 -    234            45                 1,350
   233 -    225            46                 1,380
   224 -    217            47                 1,410
   216 -    298            48                 1,440
   207 -    201            49                 1,470
   200 -    193            50                 1,500
   192 -    186            51                 1,530
   185 -    179            52                 1,560
   178 -    172            53                 1,590
   171 -    166            54                 1,620
   165 -    159            55                 1,650
   158 -    153            56                 1,680
   152 -    147            57                 1,710
   146 -    142            58                 1,740
   141 -    136            59                 1,770
   135 -    131            60                 1,800
   130 -    126            61                 1,830
   125 -    121            62                 1,860
   120 -    116            63                 1,890
   115 -    112            64                 1,920
   111 -    107            65                 1,950
   106 -    103            66                 1,980
   102 -     99            67                 2,010
    98 -     95            68                 2,040
    94 -     91            69                 2,070
    90 -     87            70                 2,100
    86 -     83            71                 2,130
    82 -     79            72                 2,160
    78 -     76            73                 2,190
    75 -     72            74                 2,220
    71 -     69            75                 2,250
    68 -     66            76                 2,280
    65 -     62            77                 2,310
    61 -     59            78                 2,340
    58 -     56            79                 2,370
    55 -     53            80                 2,400
    52 -     50            81                 2,430
    49 -     47            82                 2,460
    46 -     45            83                 2,490
    44 -     42            84                 2,520
    41 -     39            85                 2,550
    38 -     37            86                 2,580
    36 -     34            87                 2,610
    33 -     32            88                 2,640
    31 -     29            89                 2,670
    28 -     27            90                 2,700
    26 -     25            91                 2,730
    24 -     23            92                 2,760
    22 -     20            93                 2,790
    19 -     18            94                 2,820
    17 -     16            95                 2,850
    15 -     14            96                 2,880
    13 -     12            97                 2,910
    11 -     10            98                 2,940
     9 -      8            99                 2,970
     7 -      6           100                 3,000
     5 -      4           101                 3,030
     3 -      2           102                 3,060
     1                    103                 3,090
*/
  Return 0

set_3330_sector_sizes:
  Return 0

set_9345_sector_sizes:
/*
Blocks per 9345 track for different (non-keyed) physical block sizes:

Blocksize Range       Records/Track        Records/Cylinder
--------------------------------------------------------------

22,929 - 46,456             1                    15
15,075 - 22,928             2                    30
11,159 - 15,074             3                    45
 8,811 - 11,158             4                    60
 7,215 -  8,810             5                    75
 6,089 -  7,214             6                    90
 5,263 -  6,088             7                   105
 4,601 -  5,262             8                   120
 4,103 -  4,600             9                   135
 3,673 -  4,102            10                   150
 3,305 -  3,672            11                   165
 3,011 -  3,304            12                   180
 2,745 -  3,010            13                   195
 2,513 -  2,744            14                   210
 2,315 -  2,512            15                   225
 2,145 -  2,314            16                   240
 1,981 -  2,144            17                   255
 1,851 -  1,980            18                   270
 1,749 -  1,850            19                   285
 1,619 -  1,748            20                   300
 1,517 -  1,618            21                   315
 1,415 -  1,516            22                   330
 1,353 -  1,414            23                   345
 1,251 -  1,352            24                   360
 1,183 -  1,250            25                   375
 1,121 -  1,182            26                   390
 1,053 -  1,120            27                   405
   985 -  1,052            28                   420
   951 -    984            29                   435
   889 -    950            30                   450
   855 -    888            31                   465
   821 -    854            32                   480
   753 -    820            33                   495
   719 -    752            34                   510
   691 -    718            35                   525
   657 -    690            36                   540
   623 -    656            37                   555
   589 -    622            38                   570
   555 -    588            39                   585
   521 -    554            40                   600
   487 -    520            41                   615
   459 -    486            43                   645
   425 -    458            44                   660
   391 -    424            45                   675
   357 -    390            47                   705
   323 -    356            48                   720
   289 -    322            50                   750
   255 -    288            52                   780
   227 -    254            54                   810
   193 -    226            56                   840
   159 -    192            59                   885
   125 -    158            61                   915
    91 -    124            64                   960
    57 -     90            67                  1005
    23 -     56            71                  1065
     1 -     22            74                  1110
*/
  Return 0

/*

COPYR1 DEVTYPE data
Sample: 3030 20 0E 00007FF8 0D0B 000F BB60 01 00 20 52 010B

DVAOPTS   3030 = 12336 ?meaning what?
DVACLASS  20 = DASD
DVAUNIT   0E = 3380
DVAMAXRC  00007FF8 = 32760
DVACYL    0D0B = 3339
DVATRK    000F = 15
DVATRKLN  BB60 = 47968  (DASD-3380)
DVAOVNLB  01 =
DVAOVLB   00 =
DVAOVNK   20 =
DVAFLAGS  52 =
010B = 267

DVAOPTS  DS    XL2      UCB OPTIONS
DVACLASS DS    XL1      DEVICE CLASS
DVAUNIT  DS    XL1      UNIT TYPE
DVAMAXRC DS    F        MAXIMUM BLOCK SIZE WHEN NOT USING SAM LBI (7FF8 = 32760)
DVACYL   DS    H        PHYSICAL NUMBER OF CYLINDERS PER VOLUME
DVATRK   DS    H        NUMBER OF TRACKS PER CYLINDER
DVATRKLN DS    H        NUMBER OF BYTES PER TRACK, INCLUDING OVERHEAD
DVAOVNLB DS    FL1      OVERHEAD IF NOT LAST BLOCK
DVAOVLB  DS    FL1      OVERHEAD IF LAST BLOCK
DVAOVNK  DS    FL1      OVERHEAD DECREMENT IF BLOCK NOT KEYED
DVAFLAGS DS    XL1
  DVABDCYL EQU   X'80'     IF 1, DVACYL IS INVALID
  DVADEFLR EQU   X'40'     DEFINE EXTENT, LOCATE RECORD & RELATED TRANSFER COMMA
  DVADEFEX EQU   X'20'     DEFINE EXTENT IMPLEMENTED
  DVA2BOV  EQU   X'08'     IF 1, USE DVAOVHD
  *                        IF 0, USE DVAOVNLB,DVAOVLB
  DVAMODL  EQU   X'10'     IF 1 USE DVAMOD1, DVAOVH1, DVAOVH2
  DVAPAGES EQU   X'04'     IF 1, DEVICE SUPPORTS PAGING CCWS
  *                        IF 0, DEVICE DOES NOT SUPPORT PAGING CCWS
  DVANOALT EQU   X'02'     NO ALTERNATE TRACKS ARE AVAILABLE
  DVAFTOL  EQU   X'01'     IF 1, APPLY TOLERANCE FACTOR
DVATOL   DS    H        TOLERANCE FACTOR
*                                 *************************************
*                                 * APPLY TOLERANCE FACTOR AS FOLLOWS:*
*                                 * 1. ADD BLOCKSIZE AND KEYLENGTH    *
*                                 * 2. MULTIPLY BY DVATOL             *
*                                 * 3. SHIFT RIGHT DVASHFT BITS       *
*                                 * 4. ADD APPROPRIATE OVERHEADS      *
*                                 *************************************
DVASHFT  EQU   9                        SHIFT AMT TO DIVIDE BY 512


Table 50. Output from DEVTYPE Macro   DASD Devices
IBM Device                                           MaxSz  DEVTAB
---------------------------------------------------- -----  ---- ---- ---- ----
3380 Models AD4, AJ4, BD4, BJ4, and CJ2 Disk Storage  7FF8  0376 000F BB60 0100
3380 Models AD4, AJ4, BD4, BJ4, Disk Storage          7FF8  0376 000F BB60 0100
3380 Models AE4 and BE4 Disk Storage                  7FF8  06EB 000F BB60 0100
3380 Models AE4 and BE4 Disk Storage                  7FF8  06EB 000F BB60 0100
3380 Models AK4 and BK4 Disk Storage                  7FF8  0A60 000F BB60 0100
3380 Models AK4 and BK4 Disk Storage                  7FF8  0A60 000F BB60 0100
3390 Model 1 (attached to a 3990 Model 2)             7FF8  0459 000F E5A2 0000
3390 Model 1 (attached to a 3990 Model 3)             7FF8  0459 000F E5A2 0000
3390 Model 2 (attached to a 3990 Model 2)             7FF8  08B2 000F E5A2 0000
3390 Model 2 (attached to 3990 Model 3)               7FF8  08B2 000F E5A2 0000
3390 Model 3 (attached to a 3990 Model 2)             7FF8  0D0B 000F E5A2 0000
3390 Model 3 (attached to a 3990 Model 3)             7FF8  0D0B 000F E5A2 0000
3390 Model 3 (attached to a 3990 Model 6)             7FF8  0D0B 000F E5A2 0000
3390 Model 9 (attached to a 3990 Model 2)             7FF8  2721 000F E5A2 0000
3390 Model 9 (attached to a 3990 Model 3)             7FF8  2721 000F E5A2 0000
3390 Model 9 (attached to a 3990 Model 6)             7FF8  2721 000F E5A2 0000
9345 Model 1                                          7FF8  05A0 000F BC98 0000



#>

<#

VTOC DSCB Format-1

**CCHHR- 000100071A RECORD LENGTH- 00008C
000000 D2C5 E3F2 F8F1 F24B E7D4 C9E3 4BD7 D6C5 C640 4040 4040 4040 4040 4040 404
000020 4040 4040 4040 4040 4040 4040 F1E3 E2D6 F0F0 F100 0172 0006 0000 0001 000
000040 D4D6 E2E5 E2F2 4040 4040 4072 000F 8880 7FD0 0200 8000 0050 0050 0000 008
000060 0005 0000 0000 0000 0001 0000 6000 0000 6000 0300 0000 0000 0000 0000 000
000080 0000 0000 0000 0000 0000 0000


DS1DSNAM 44 D2C5 E3F2 F8F1 F24B E7D4 C9E3 4BD7 D6C5 C640 4040 4040 4040 4040 404
DS1FMTID  1 F1 = 1
DS1DSSN   6 E3 E2D6 F0F0 F1 = TSO001
DS1VOLSQ  2 00 01 = 1
DS1CREDT  3 72 0006 = 2014.006 x'72' = 114 + 1900 = 2014 0006 = 006
DS1EXPDT  3 0000 00 = 0 = None
DS1NOEPV  1 01 = 1 Extent on this volume
DS1NODBD  1 00 = 0 bytes in last directory block
DS1FLAG1  1 00 = none of what it might be
DS1SYSCD 13 C9C2 D4D6 E2E5 E2F2 4040 4040 40 = IBMOSVS2
DS1REFD   3 72 000F = 2014.015
DS1SMSFG  1 88 = "S" and PDSE or HFS
DS1SCEXT  3  If DS1SCAL1 bitand x'10' else ...
DS1SCXTF  1 80 = Original block length follows...
DS1SCXTV  2 7FD0 = 32720
DS1RECFM  1 02 = (HUH? 20 = Fixed, 02 = Machine control character)
DS1OPTCD  1 00 = none of what it could be
DS1BLKL   2 8000 = 32768
DS1LRECL  2 0050 = 80
DS1KEYL   1 00 = 0
DS1RKP    2 5000 = 20480
DS1DSIND  1 00 = none of what it might be
DS1CALO   4  When? Else ....
DS1SCAL1  1 00
DS1CAL3   3 82 5000 = 8540160 of what? bytes? divided into what?
DS1LSTAR  3 000500 = TTR
00 0000 0000 0001 0000 6000 0000 6000 0300 0000 0000 0000 0000 0000 0000 0000 00


#>

*/
