{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013701000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 646646, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 12, "INMDSNAM": "CBT.V500.FILE983.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 646646, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 646646, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE983.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x0b\\x11'", "DS1TRBAL": "b'F '"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\nl\\x00\\x0b\\nm\\x00\\x07\\x00\\x0c'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04a\\x000\\x01\\x182_\\x01\\x182_ X\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf7@@@'", "ispf": {"version": "04.97", "flags": 0, "createdate": "2018-11-21T00:00:00", "modifydate": "2018-11-21T20:58:30", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-497"}, "text": "REGULAR CBT TAPE - VERSION 497    FILE:  983\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT497.FILE983\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 36 MEMBERS COUNTED; CUMULATIVE SIZE IS 5,634 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   11/21/18    20:58:29    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$README": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\t\\x01\\x17#_\\x01\\x18\\x03?\\x07\\x16\\x00\\x14\\x00\\x14\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-08-23T00:00:00", "modifydate": "2018-02-02T07:16:09", "lines": 20, "newlines": 20, "modlines": 0, "user": "KTOMIAK"}, "text": "\n       Mainframe Software Installation Customizer (MSIC)\n\nThis FreeWare Tool is a generalized and extensible ISPF Dialog\nthat aids in installing and customizing the type of FreeWare you\nmight develop and contribute to the CBTTape.Org respository.\n\n- You build #1TASKS that the user should execute in the proper sequence.\n- You build #2VARS for any variable replacement needed in members.\n- You build #3EDIT to identify which members are eligible for variable\n  replacement.\n- You do the TRANSMIT on your PDS data sets and then copy the IDTF\n  into your install PDS.\n- You identify those members in #2VARS and MSIC can do the RECEIVE\n  for the installer.\n\nThe basic tasks used to extract IDTF and replace variables are built into\nMSIC. If you have a need for more than that then either provide a sample\nJOB or build your own external routine.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$SETUP": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x05\\x01\\x17#_\\x01\\x18\\x03?\\x07\\x17\\x00\\x13\\x00\\r\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2017-08-23T00:00:00", "modifydate": "2018-02-02T07:17:05", "lines": 19, "newlines": 13, "modlines": 0, "user": "KTOMIAK"}, "text": "\n       Mainframe Software Installation Customizer (MSIC)\n\nYou can (in recommendation order):\n\n- use ISPF 3.4 to member list this data set and then use the 'exec' line\n  command on the MSIC member\n\n- build a front-end allocation that does: tso exec 'hlq.msic.pds(msic)'\n  replace hlq with the prefix of this data set.\n\n- type: tso exec 'hlq.msic.pds(msic)'\n  replace hlq with the prefix of this data set.\n\n- Copy MSICR* members to your //SYSEXEC concatenation (or //SYSPROC)\n  Copy MSICH* members to your //ISPPLIB concatenation.\n  Copy MSICP* members to your //ISPPLIB concatenation.\n  Copy MSICT* members to your //ISPPLIB concatenation.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$DISCLAM": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x002\\x01\\x18\\x03/\\x01\\x18\\x03?\\x07\\x18\\x00\\x0c\\x00\\x10\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-02-01T00:00:00", "modifydate": "2018-02-02T07:18:32", "lines": 12, "newlines": 16, "modlines": 0, "user": "KTOMIAK"}, "text": "\nSTANDARD GLOBAL DISCLAIMER\n--------------------------\nThe author explicitly disavows any claim whatsoever about the\ncorrectness or functionality of this program, and disclaims liability\nfor anything and everything bad that might happen in connection with,\nbefore, during, or after using it. I have tried to make it work right,\nand I am personally pretty confident that it does, but everybody makes\nmistakes, so if you use it, you do so at your own risk.\n\nSincerely yours,\n\"Kenneth E Tomiak\"<CBT_Ken@KTomiak.biz>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE983": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04a\\x00\\x18\\x01\\x182_\\x01\\x182_ X\\x00\"\\x00\"\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf7@@@'", "ispf": {"version": "04.97", "flags": 0, "createdate": "2018-11-21T00:00:00", "modifydate": "2018-11-21T20:58:18", "lines": 34, "newlines": 34, "modlines": 0, "user": "CBT-497"}, "text": "//***FILE 983 is from (the late) Ken Tomiak and contains his MSIC   *   FILE 983\n//*           system for installing software packages, such as      *   FILE 983\n//*           those coming from the CBT Tape.  Please read his      *   FILE 983\n//*           description of the system, below.                     *   FILE 983\n//*                                                                 *   FILE 983\n//*           email:   sbgolob@cbttape.org                          *   FILE 983\n//*                                                                 *   FILE 983\n//*        Mainframe Software Installation Customizer (MSIC)        *   FILE 983\n//*                                                                 *   FILE 983\n//*     This FreeWare Tool is a generalized and extensible ISPF     *   FILE 983\n//*     Dialog that aids in installing and customizing the type     *   FILE 983\n//*     of FreeWare you might develop and contribute to the         *   FILE 983\n//*     CBTTape.Org respository.                                    *   FILE 983\n//*                                                                 *   FILE 983\n//*     - You build #1TASKS that the user should execute in the     *   FILE 983\n//*       proper sequence.                                          *   FILE 983\n//*                                                                 *   FILE 983\n//*     - You build #2VARS for any variable replacement needed      *   FILE 983\n//*       in members.                                               *   FILE 983\n//*                                                                 *   FILE 983\n//*     - You build #3EDIT to identify which members are            *   FILE 983\n//*       eligible for variable replacement.                        *   FILE 983\n//*                                                                 *   FILE 983\n//*     - You do the TRANSMIT on your PDS data sets and then        *   FILE 983\n//*       copy the IDTF into your install PDS.                      *   FILE 983\n//*                                                                 *   FILE 983\n//*     - You identify those members in #2VARS and MSIC can do      *   FILE 983\n//*       the RECEIVE for the installer.                            *   FILE 983\n//*                                                                 *   FILE 983\n//*     The basic tasks used to extract IDTF and replace            *   FILE 983\n//*     variables are built into MSIC. If you have a need for       *   FILE 983\n//*     more than that then either provide a sample JOB or build    *   FILE 983\n//*     your own external routine.                                  *   FILE 983\n//*                                                                 *   FILE 983\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MSIC": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x06\\x00T\\x01\\x17!/\\x01\\x17$_\\x14'\\x10\\xd2\\x05\\xce\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@\"", "ispf": {"version": "01.06", "flags": 0, "createdate": "2017-07-31T00:00:00", "modifydate": "2017-09-02T14:27:54", "lines": 4306, "newlines": 1486, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\nrexx_msic:\n  rexxpgm_version = \"01.03\"          /* Set with 'ver 1' and 'lev 2'. */\n\n  Parse Arg all_my_arguments\n  Address ISPEXEC \"CONTROL ERRORS RETURN\"\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nrexx_Main_Code:\n  return_code = Initialzation_routine()\n  If (return_code = 0) Then Do\n    return_code = Process_routine()\n  End\n  return_code = Termination_routine()\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Put the onus on the user if anything should go wrong.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nstandard_global_disclaimer:\n  Say \"\"\n  Say \"STANDARD GLOBAL DISCLAIMER\"\n  Say \"==========================\"\n  Say \"The author explicitly disavows any claim whatsoever about\"\n  Say \"the correctness or functionality of this program, and\"\n  Say \"disclaims liability for anything and everything bad that\"\n  Say \"might happen in connection with, before, during, or after\"\n  Say \"using it. I have tried to make it work right, and I am\"\n  Say \"personally pretty confident that it does, but everybody\"\n  Say \"makes mistakes, so if you use it, you do so at your own\"\n  Say \"risk.\"\n  Say \"\"\n  Say \"The extensible nature of this program allows a software\"\n  Say \"developer to add their own externally called upon routines.\"\n  Say \"Contact them if their code causes you concerns and/or issues.\"\n  Say \"\"\n  Say \"IBM Corporation reserves the right to modify the IDTF\"\n  Say \"format and has done so over the years.\"\n  Say \"\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog driver program, internally known as\n            Mainframe Software Installation Customizer (MSIC). It lets\n            you list Interactive Data Transfer File (IDTF) data sets\n            on your system. You can RECEIVE the contents or just view\n            the attributes of the embedded data.\n\n            If the embedded data is an MSIC-compliant PDS you will then\n            be allowed to run the Installation Customizer code using\n            the MSIC members directives #1TASKS, #2VARS, and #3EDIT.\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.03 20170819 \"Kenneth E Tomiak\"<CBT_Ken@KTomiak.biz>\n               1) Added split-screen invocation.\n               2) Modified #1TASKS to two-liners and longer\n                  description.\n----- -------- --------------------------------------------------------\n01.02 20170818 \"Kenneth E Tomiak\"<CBT_Ken@KTomiak.biz>\n               1) Added FIND/RFIND to DS34.\n----- -------- --------------------------------------------------------\n01.01 20170805 \"Kenneth E Tomiak\"<CBT_Ken@KTomiak.biz>\n               1) Enhanced the frontend to begin with an ISPF 3.4-like\n                  list of &sysuid..**.xmi* data sets; support to\n                  RECEIVE the data set; and if MSIC-compliant to start\n                  the installer.\n----- -------- --------------------------------------------------------\n01.00 20170719 \"Kenneth E Tomiak\"<CBT_Ken@KTomiak.biz>\n               1) Original code started.\n                  This is a completely newly written REXX program based\n                  on the concept of using an ISPF table to walk a user\n                  thru the steps to install a product. The idea comes\n                  from a decade before IBM came out with the ServerPac\n                  (CPAC) dialog. I wrote my first IMS DB Installer\n                  Dialog while working for Andersen Consulting -\n                  Coritel Division.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n Finds from whence this was executed, use the hostdd/hostdsn as ISPPLIB\n and ALTLIB, and build tables from #1TASKS and #2VARS.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialzation_routine:\n  return_code = 0\n  PARSE SOURCE,\n    source_host_env,\n    source_call_type,\n    source_uc_exec_name,\n    source_hostdd,\n    source_hostdsn,\n    source_nf_exec_name,\n    source_initial_cmd_env,\n    source_asid_name,\n    source_char8_user_token,\n    source_hostother\n\n  Address TSO \"MakeBuf\"\n\n  sysvar_sysuid = SYSVAR(\"SYSUID\")\n  sysvar_syspref = SYSVAR(\"SYSPREF\")\n\n  If (source_hostdsn = \"?\") Then Do\n    function_rc = find_hostdsn()\n  End\n  listdsi_rc = Listdsi(\"'\"source_hostdsn\"'\")\n  vdef_volser = SYSVOLUME\n  vdef_unit = SYSUNIT\n\n  msg_rc = 0\n  ZERRALRM = \"On\"\n  ZERRHM = \"MSICPHLP\"\n  verb_help = \"HELP\"\n  ZERRSM = ask_to_get_help()\n  ZERRLM = \"\"\n\n  libdef_plib = 0\n  altlib_exec = 0\n  ds34_table = \"DS34\"random(9999)\n  TASKTABL = \"TASKTABL\"\n  vdef_table = \"VDEF\"random(9999)\n  tbcreate_idtftbl = 0\n  tbcreate_tasktbl = 0\n  tbcreate_vdef_table = 0\n\n  valid_names = \"@#$ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890\"\n\n  Address ISPEXEC \"LIBDEF ISPPLIB DATASET\",\n    \"ID('\"source_hostdsn\"') STACK\"\n  libdef_rc = RC\n  If (libdef_rc <> 0) Then Do\n    ZERRLM = \"LIBDEF of ISPPLIB failed, rc=\"libdef_rc\n    msg_rc = 1\n    return_code = libdef_rc\n  End\n  libdef_plib = 1\n\n  Address TSO ,\n    \"Altlib Activate Application(EXEC) Dataset('\"source_hostdsn\"')\"\n  altlib_rc = RC\n  If (altlib_rc <> 0) Then Do\n    ZERRLM = \"altlib of ISPPLIB failed, rc=\"altlib_rc\n    msg_rc = 1\n    return_code = altlib_rc\n  End\n  altlib_exec = 1\n\n  ds34_find = 0\n\n  onezerone = \"1_0_1\"\n  twooneone = \"2_1_1\"\n  twotwoone = \"2_2_1\"\n  twotwotwo = \"2_2_2\"\n  twotwothree = \"2_2_3\"\n  threeone = \"3_1\"\n  threetwo = \"3_2\"\n\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_routine:\n  idtf_define_rc = ds34_table_create()\n  If (idtf_define_rc <> 0) Then Do\n    return idtf_define_rc\n  End\n  Address ISPEXEC \"VGet (ZSCREENW)\"\n  hw = (ZSCREENW - 16) % 2\n  ZTDMARK = Copies(\"-\",hw)\"> End of data set list. <\"Copies(\"-\",hw)\n\n  DS34PTRN = sysvar_sysuid\".**.xmi*\"\n  ds34_table_load_rc = ds34_table_load()\n\n  ZERRLM = \"\"\n  msicppri_tbdispl_rc = 0\n  Do While (msicppri_tbdispl_rc < 8)\n    Address ISPEXEC \"TBDISPL\" ds34_table \"PANEL(MSICPPRI)\"\n    msicppri_tbdispl_rc = RC\n    If (msicppri_tbdispl_rc = 8) Then Do\n      Leave\n    End\n    Select\n      When (msicppri_tbdispl_rc < 5) Then Do\n        ds34_table_zcmd_rc = ds34_table_zcmd_procesing()\n        If (ds34_table_zcmd_rc <> 0) Then Do\n          return ds34_table_zcmd_rc\n        End\n        ds34_table_zsel_rc = ds34_table_zsel_procesing()\n        If (DS34PTRN <> origptrn) Then Do\n          empty_rc = ds34_table_empty()\n          search_rc = ds34_table_load()\n        End\n      End\n      When (msicppri_tbdispl_rc > 4) Then Do\n        ZERRLM = \"RC is too high,\" msicppri_tbdispl_rc\".\"\n        msg_rc = 1\n        return msicppri_tbdispl_rc\n      End\n      Otherwise Do\n        NOp\n      End\n    End\n    If (ZERRLM <> \"\") Then Do\n      ZERRSM = ask_to_get_help()\n      Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    End\n  End\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_routine:\n  If (libdef_plib = 1) Then Do\n    Address ISPEXEC \"LIBDEF ISPPLIB DATASET\"\n  End\n  If (altlib_exec = 1) Then Do\n    Address TSO \"AltLib Deactivate Application(EXEC)\"\n  End\n  If (tbcreate_ds34_table = 1) Then Do\n    Address ISPEXEC,\n      \"TBEnd\" ds34_table\n  End\n  If (tbcreate_tasktbl = 1) Then Do\n    Address ISPEXEC,\n      \"TBEnd TASKTABL\"\n  End\n  If (tbcreate_vdef_table = 1) Then Do\n    Address ISPEXEC,\n      \"TBEnd\" vdef_table\n  End\n  If (return_code > 0) Then Do\n    If (msg_rc = 1) Then Do\n      If (ZERRSM = \"\") Then Do\n        ZERRSM = \"An unhappy ending\"\n        ZERRLM = \"Some unhappy turn of events is sending back\",\n          \"a RETURN code higher than 0 with no message.\"\n      End\n      ZERRSM = ask_to_get_help()\n      Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    End\n  End\n  Address TSO \"DROPBUF\"\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Build the DS34 table.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nds34_table_create:\n  Address ISPEXEC,\n    \"TBEnd\" ds34_table\n  Address ISPEXEC,\n    \"TBCREATE\" ds34_table ,\n    \"NAMES(DS34LCMD, DS34DSNM)\" ,\n    \"SHARE\" ,\n    \"NOWRITE\"\n  tbcreate_rc = RC\n  If (tbcreate_rc <> 0) Then Do\n    ZERRLM = \"ds34_table create failed, RC(\"tbcreate_rc\").\"\n    msg_rc = 1\n    return tbcreate_rc\n  End\n  tbcreate_ds34_table = 1\n  ds34_seek = 0\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Empty the DS34 table.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nds34_table_empty:\n  Address ISPEXEC \"TBTOP\" ds34_table\n  Address ISPEXEC \"TBSKIP\" ds34_table\n  tbskip_rc = 0\n  Do While (tbskip_rc = 0)\n    Address ISPEXEC \"TBDELETE\" ds34_table\n    Address ISPEXEC \"TBSKIP\" ds34_table\n    tbskip_rc = rc\n  End\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Load the DS34 table using DS34PTRN.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nds34_table_load:\n  IDTF34 = \"\"\n  Parse Var DS34PTRN DS34PTRN \" \" .\n  Address ISPEXEC \"LMDINIT\" ,\n    \"LISTID(IDTF34) LEVEL(&DS34PTRN)\"\n  lmdinit_rc = RC\n  If (lmdinit_rc <> 0 ) Then Do\n    ZERRSM = ask_to_get_help()\n    ZERRLM = \"lmdinit failed,\" lmdinit_rc\n    Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n  End\n  lmdlist_rc = 0\n  LISTIDNM = \"\"\n  Do While (lmdlist_rc = 0)\n    Address ISPEXEC \"LMDLIST\" ,\n      \"LISTID(\"IDTF34\") OPTION(LIST)\" ,\n      \"DATASET(LISTIDNM)\"\n    lmdlist_rc = RC\n    If (lmdlist_rc > 8) Then Do\n      ZERRSM = ask_to_get_help()\n      ZERRLM = \"Pattern\" DS34PTRN \"is invalid.\"\n      Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      Leave\n    End\n    If (lmdlist_rc > 0) Then Do\n      Leave\n    End\n    Select\n      When (lmdlist_rc = 0) Then Do\n        Address ISPEXEC \"TBVCLEAR\" ds34_table\n        DS34DSNM = Strip(LISTIDNM,\"T\",\" \")\n        Address ISPEXEC \"TBADD\" ds34_table\n        tbadd_rc = RC\n      End\n      When (lmdlist_rc = 4) Then Do\n        ZERRSM = ask_to_get_help()\n        ZERRLM = \"No data sets match pattern(\"DS34PTRN\").\"\n        Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      End\n      Otherwise Do\n        NOp\n      End\n    End\n  End\n  Address ISPEXEC \"LMDLIST\" ,\n    \"LISTID(\"IDTF34\") OPTION(FREE)\"\n  lmdlist_rc = RC\n  Address ISPEXEC \"LMDFREE\" ,\n    \"LISTID(\"IDTF34\")\"\n  lmdfree_rc = RC\n  Address ISPEXEC \"TBSORT\" ds34_table \"FIELDS(DS34DSNM,C,A)\"\n  Address ISPEXEC \"TBTOP\" ds34_table\n  origptrn = DS34PTRN\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Process ==>Command options.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nds34_table_zcmd_procesing:\n  msg_rc = 0\n  Parse Upper Var ZCMD ds34_verb ds34_string\n  Address ISPEXEC \"VGET (ZVERB)\"\n  ZCMD = \"\"\n  ZERRSM = ask_to_get_help()\n  ZERRLM = Left(\"Results:\",79)\n  Select\n    When ((ds34_verb = \"\") & (ZVERB = \"\")) Then Do\n      return return_code\n    End\n    When (Abbrev(\"FIND\",ds34_verb,1) = 1) Then Do\n      rfind_string = ds34_string\n      If (ds34_string = \"\") Then Do\n        ZERRLM = ZERRLM || ,\n          Left(\"Find what?\",79)\n        Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n        Return 0\n      End\n      ds34_find = 0\n      Address ISPEXEC \"TBTOP\" ds34_table\n      search_rc = ds34_table_search()\n      If (ds34_find = 0) Then Do\n        ZERRLM = ZERRLM || ,\n          Left(ds34_string \"not found\",79)\n        Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      End\n    End\n    When (Abbrev(\"RFIND\",ZVERB,2) = 1) Then Do\n      ds34_string = rfind_string\n      If (ds34_find = 0) Then Do\n        ZERRLM = ZERRLM || ,\n          Left(ds34_string \"was not found before,\" ,\n            \"will not be found now\",79)\n        Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n        Return 0\n      End\n      search_rc = ds34_table_search()\n    End\n    When (Abbrev(\"REFRESH\",ds34_verb,1) = 1) Then Do\n      empty_rc = ds34_table_empty()\n      search_rc = ds34_table_load()\n      ds34_find = 0\n    End\n    When (ds34_verb = \"X\") Then Do\n      ZERRSM = \"Okay\"\n      ZERRLM = \"You used X to leave.\"\n      Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      return_code = 8\n    End\n    When (ds34_verb = \"?\") Then Do\n      Address ISPEXEC \"Control Display Save\"\n      Address ISPEXEC \"AddPop\"\n      Address ISPEXEC \"Display Panel(MSICHDZ1)\"\n      Address ISPEXEC \"RemPop\"\n      Address ISPEXEC \"Control Display Restore\"\n    End\n    Otherwise Do\n      ZERRSM = \"What?\"\n      ZERRLM = \"Choose a valid option or feature.\"\n      Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    End  /* End of OTHERWISE */\n  End  /* End of SELECT  */\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Search the DS34 table using te user provided string.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nds34_table_search:\n  tbskip_rc = 0\n  If (Abbrev(\"RFIND\",ZVERB,2) = 1) Then Do\n    ds34crow = ds34crow + 0\n    Address ISPEXEC \"TBTOP\" ds34_table\n    Address ISPEXEC \"TBSKIP\" ds34_table \"NUMBER(&ds34crow)\" ,\n      \"Position(ds34crow)\"\n  End\n  Do While (tbskip_rc = 0)\n    Address ISPEXEC \"TBSKIP\" ds34_table \"Position(ds34crow)\"\n    tkskip_rc = RC\n    If (tbskip_rc > 0) Then Do\n      If (Abbrev(\"RFIND\",ZVERB,2) = 1) Then Do\n        Address ISPEXEC \"TBTOP\" ds34_table\n        Address ISPEXEC \"TBSKIP\" ds34_table \"Position(ds34crow)\"\n      End\n    End\n    If (Pos(ds34_string,DS34DSNM) > 0) Then Do\n      ds34_find = 1\n      Return 0\n    End\n  End\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Loop thru the selected IDTF rows.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nds34_table_zsel_procesing:\n  msicppri2_tbdispl_rc = 0\n  ZERRLM = \"\"\n  Do While (ZTDSELS > 0)\n    DS34LCMD = To_Uppercase(DS34LCMD)\n    function_rc = ds34_table_row_selection()\n    DS34LCMD = \"\"\n    Address ISPEXEC \"TBPUT\" ds34_table\n    If (ZTDSELS > 1) Then Do\n      Address ISPEXEC \"TBDISPL\" ds34_table\n      msicppri2_tbdispl_rc = RC\n    End\n    Else Do\n      ZTDSELS = 0\n    End\n  End\n  If (ZERRLM <> \"\") Then Do\n    ZERRSM = ask_to_get_help()\n    Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n  End\n  Return msicppri2_tbdispl_rc\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n Process the ROW selection.\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nds34_table_row_selection:\n  lseldsnm = \"'\"DS34DSNM\"'\"\n  listdsi_rc = Listdsi(lseldsnm)\n  If (listdsi_rc <> 0) Then Do\n    ZERRLM = ZERRLM || Left(\"LISTDSI RC(\"listdsi_rc\")\",79)\n    ZERRLM = ZERRLM || Left(SYSMSGLVL1,79)\n    ZERRLM = ZERRLM || Left(SYSMSGLVL2,79)\n    return listdsi_rc\n  End\n\n  Select\n    When (Abbrev(\"BROWSE\",DS34LCMD,1) = 1) Then Do\n      orig_zscr = zscr\n      Address ISPEXEC \"Control Display Save\"\n      Address ISPEXEC \"Browse DATASET(\"lseldsnm\")\"\n      browse_rc = RC\n      If (browse_rc > 0) Then Do\n        ZERRLM = ZERRLM || Left(\"Bad data set\",79)\n      End\n      Address ISPEXEC \"Control Display Restore\"\n      zscr = orig_zscr\n    End\n    When (Abbrev(\"EDIT\",DS34LCMD,1) = 1) Then Do\n      orig_zscr = zscr\n      Address ISPEXEC \"Control Display Save\"\n      Address ISPEXEC \"Edit DATASET(\"lseldsnm\")\"\n      edit_rc = RC\n      Address ISPEXEC \"Control Display Restore\"\n      zscr = orig_zscr\n    End\n    When (Abbrev(\"VIEW\",DS34LCMD,1) = 1) Then Do\n      orig_zscr = zscr\n      Address ISPEXEC \"Control Display Save\"\n      Address ISPEXEC \"View DATASET(\"lseldsnm\")\"\n      view_rc = RC\n      Address ISPEXEC \"Control Display Restore\"\n      zscr = orig_zscr\n    End\n    When ((Abbrev(\"HEADERS\",DS34LCMD,1) = 1) | ,\n          (Left(DS34LCMD,1) = \"S\")) Then Do\n      orig_zscr = zscr\n      Address ISPEXEC \"Control Display Save\"\n      idtf_ZTDSELS = ZTDSELS\n      function_rc = idtf_headers()\n      ZTDSELS = idtf_ZTDSELS\n      Address ISPEXEC \"Control Display Restore\"\n      zscr = orig_zscr\n    End\n    When (Abbrev(\"RECEIVE\",DS34LCMD,1) = 1) Then Do\n      Parse Value Reverse(DS34DSNM) with . \".\" namemain\n      mainname = Reverse(namemain)\".INSTALL\"\n      INSTALL_rc = SysDsn(\"'\"mainname\"'\")\n      If (INSTALL_rc = \"OK\") Then Do\n        Address ISPEXEC \"CONTROL DISPLAY SAVE\"\n        Address ISPEXEC \"AddPop\"\n        reason1 = \"Warning '\"mainname\"' already exists. Delete it?\"\n        reason2 = \"Yes will delete it and Then Do the receive.\"\n        reason3 = \"Any other response action will add/overlay\"\n        reason4 = \"members in the existing data set.\"\n        reason5 = \"\"\n        Address ISPEXEC \"DISPLAY PANEL(MSICPCFM)\"\n        confirm_rc = RC\n        If (confirmd = \"Y\") Then Do\n          Address TSO \"Delete '\"mainname\"'\"\n        End\n        Address ISPEXEC \"RemPop\"\n        Address ISPEXEC \"CONTROL DISPLAY RESTORE\"\n      End\n      xmit_dsn = lseldsnm\n      Address TSO \"Alloc File(INMRCK)\" ,\n        \"Dataset(\"xmit_dsn\") SHR REUSE\"\n      Address MVS \"Execio 1 DISKR INMRCK (Stem inmr. FINIS)\"\n      Address TSO \"Free File(INMRCK)\"\n      If (Pos(\"\\INMR01\",inmr.1) <> 2) Then Do\n        ZERRLM = ZERRLM || ,\n          Left(lseldsnm \"is not an IDTF file - INMR01<>2\",79)\n      End\n      Else Do\n        Address TSO \"MakeBuf\"\n        Queue \"Dataset('\"mainname\"')\" ,\n          \"UNIT(\"vdef_unit\") VOLUME(\"vdef_volser\")\"\n        Queue \"END\"\n        prompting = Prompt(\"On\")\n        Address TSO \"Receive INDA(\"lseldsnm\")\"\n        xmit_rc = RC\n        prompting = Prompt(prompting)\n        Address TSO \"DROPBUF\"\n        ZERRLM = ZERRLM || ,\n          Left(DS34DSNM xmit_rc,79)\n        If (xmit_rc = 0) Then Do\n          sysdsn_rc = SysDsn(\"'\"mainname\"(\"#1TASKS\")'\")\n          If (sysdsn_rc = \"OK\") Then Do\n            task_dsn = \"'\"mainname\"(#1TASKS)'\"\n            vars_dsn = \"'\"mainname\"(#2VARS)'\"\n            editdsn = mainname\n            ADDRESS ISPEXEC \"VPut (EDITDSN) Shared\"\n            mainname_exec = 0\n            Address TSO ,\n              \"Altlib Activate Application(EXEC)\" ,\n              \"Dataset('\"mainname\"' '\"source_hostdsn\"')\"\n            mainname_rc = RC\n            If (mainname_rc <> 0) Then Do\n              ZERRLM = \"altlib of\" MAINNAME \"failed, rc=\"mainname_rc\n              msg_rc = 1\n              return_code = mainname_rc\n            End\n            mainname_exec = 1\n            install_rc = Tasks_initialization()\n            If (install_rc = 0) Then Do\n              process_rc = Tasks_processing()\n            End\n            Else Do\n               ZERRLM = ZERRLM || ,\n                 Left(\"Failure proessing #1TASKS and #2VARS\",79)\n            End\n            If (mainname_exec = 1) Then Do\n              Address TSO \"AltLib Deactivate Application(EXEC)\"\n            End\n          End\n          Else Do\n            ZERRLM = ZERRLM || ,\n              Left(mainname \"is not MSIC capable\",79)\n          End\n        End\n      End\n    End\n    When (Abbrev(\"INSTALL\",DS34LCMD,1) = 1) Then Do\n      mainname = Strip(DS34DSNM,\"B\",\"'\")\n      If ((Right(mainname,4) = \".XMI\") | ,\n        (Right(mainname,5) = \".XMIT\") | ,\n        (Right(mainname,5) = \".IDTF\"))  Then Do\n        ZERRLM = ZERRLM || ,\n          Left(mainname \"is not MSIC capable\",79)\n      End\n      Else Do\n        sysdsn_rc = SysDsn(\"'\"mainname\"(\"#1TASKS\")'\")\n        If (sysdsn_rc = \"OK\") Then Do\n          task_dsn = \"'\"mainname\"(#1TASKS)'\"\n          vars_dsn = \"'\"mainname\"(#2VARS)'\"\n          editdsn = mainname\n          ADDRESS ISPEXEC \"VPut (EDITDSN) Shared\"\n          mainname_exec = 0\n          Address TSO ,\n            \"Altlib Activate Application(EXEC)\" ,\n            \"Dataset('\"mainname\"', '\"source_hostdsn\"')\"\n          mainname_rc = RC\n          If (mainname_rc <> 0) Then Do\n            ZERRLM = \"altlib of\" MAINNAME \"failed, rc=\"mainname_rc\n            msg_rc = 1\n            return_code = mainname_rc\n          End\n          mainname_exec = 1\n          install_rc = Tasks_initialization()\n          If (install_rc = 0) Then Do\n            process_rc = Tasks_processing()\n          End\n          Else Do\n             ZERRLM = ZERRLM || ,\n               Left(\"Failure proessing #1TASKS and #2VARS\",79)\n          End\n        End\n        Else Do\n          ZERRLM = ZERRLM || ,\n            Left(mainname \"is not MSIC capable\",79)\n        End\n      End\n    End\n    When ((DS34LCMD = \"/\") | (DS34LCMD = \"?\")) Then Do\n      DS34LCMD = \"\"\n      Address ISPEXEC \"AddPop\"\n      Address ISPEXEC \"Display Panel(MSICHDL1)\"\n      Address ISPEXEC \"RemPop\"\n      Select\n        When ((DS34LCMD = \"/\") | (DS34LCMD = \"?\")) Then Do\n          ZERRSM = \"No way!\"\n          ZERRLM = \"Asking for recursive help is inexscusable.\"\n          Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n        End\n        Otherwise Do\n          DS34LCMD = To_Uppercase(DS34LCMD)\n          function_rc = ds34_table_row_selection()\n        End\n      End\n    End\n    Otherwise Do\n      ZERRSM = \"What?\" DS34LCMD\n      ZERRLM = \"Use a valid line command (S, /, ?).\"\n      Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    End\n  End\n  Return 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Search a DD to find where this code runs from.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nfind_hostdsn:\n  Address ISPEXEC ,\n    \"QBASELIB\" source_hostdd \"ID(DSNLIST)\"\n  ISPEXEC_rc = RC\n  If (ISPEXEC_rc <> 0) Then Do\n    msg_rc = 1\n    ZERRLM = \"QBASELIB Failed, RC(\"ISPEXEC_rc\")\"\n    Return 4\n  End\n  dsnlist_temp = dsnlist\n  @trap_state = TRAPMSG(\"On\")\n  msg_state = Msg(\"OFF\")\n  Do While dsnlist_temp <> \"\"\n    Parse Var dsnlist_temp one_dsn \",\" dsnlist_temp\n    one_dsn = Strip(one_dsn,\"B\",\"'\")\n    sysdsn_rc = SysDsn(\"'\"one_dsn\"(\"source_uc_exec_name\")'\")\n    If (sysdsn_rc = \"OK\") Then Do\n      source_hostdsn = one_dsn\n      Leave\n    End\n  End\n  msg_rc = Msg(msg_state)\n  @trap_rc = TRAPMSG(@trap_state)\n  Return 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n This is an 'Easter Egg', something not shown so it is a HIDDEN choice.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nZORK_easter_egg:\n  Say \"\"\n  Say \"Clear your screen and press ENTER for an important message.\"\n  Say \"\"\n  Pull nothing_wanted\n  Say \"\"\n  Say \"Zork is set in 'the ruins of an ancient empire lying far\"\n  Say \"underground'. The player is a nameless adventurer 'who is\"\n  Say \"venturing into this dangerous land in search of wealth\"\n  Say \"and adventure'. The goal is to return from exploring the\"\n  Say \"'Great Underground Empire' (GUE, for short) alive and with\"\n  Say \"all treasures needed to complete each adventure,\"\n  Say \"ultimately inheriting the desc of Dungeon Master. The\"\n  Say \"dungeons are stocked with many novel creatures, objects,\"\n  Say \"and locations, among them the ferocious but light-fearing\"\n  Say \"grues, zorkmids (the GUE's currency), and Flood Control\"\n  Say \"Dam #3.\"\n  Say \"\"\n  Say \"\"\n  Say \"This Easter Egg was brought to you by Kenneth Tomiak.\"\n  Say \"To learn more about the ZORK games visit:\"\n  Say \"  https://en.wikipedia.org/wiki/Zork\"\n  Say \"\"\n  Say \"\"\n  Say \"An Easter egg is an intentional inside joke, a hidden\"\n  Say \"message, or a secret feature of an interactive work\"\n  Say \"(often, a computer program, video game or other work).\"\n  Say \"\"\n  Say \"\"\n  Return 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: Parse arg myarg\n  If (uppercase_letters = \"UPPERCASE_LETTERS\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: Parse arg myarg\n  If (uppercase_letters = \"UPPERCASE_LETTERS\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Build a string of the left hex values.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTop_Half:\n  Parse Arg all_char\n  all_hex = c2x(all_char)\n  top_hex = \"\"\n  Do th1 = 1 to length(all_hex) by 2\n    top_hex = top_hex || SubStr(all_hex,th1,1)\n  end\n  Return top_hex\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Build a string of the right hex values.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nBottom_Half:\n  Parse Arg all_char\n  all_hex = c2x(all_char)\n  bottom_hex = \"\"\n  Do bh1 = 2 to length(all_hex) by 2\n    bottom_hex = bottom_hex || SubStr(all_hex,bh1,1)\n  end\n  Return bottom_hex\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n VGET the PFKEY settings amd map to names.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\npfkeys_by_name:\n  pfkeys_verb. = \"\"\n  Address ISPEXEC \"VGET (ZPF01, ZPF02, ZPF03, ZPF04, ZPF05, ZPF06,\" ,\n                        \"ZPF07, ZPF08, ZPF09, ZPF10, ZPF11, ZPF12,\" ,\n                        \"ZPF13, ZPF14, ZPF15, ZPF16, ZPF17, ZPF18,\" ,\n                        \"ZPF19, ZPF20, ZPF21, ZPF22, ZPF23, ZPF24)\"\n  vget_rc = RC\n  If (vget_rc <> 0) Then Do\n    pfkeys_verb.verb_HELP = \"Type HELP and press Enter.\"\n    return vget_rc\n  End\n  ZPF01 = To_Uppercase(ZPF01)\n  ZPF02 = To_Uppercase(ZPF02)\n  ZPF03 = To_Uppercase(ZPF03)\n  ZPF04 = To_Uppercase(ZPF04)\n  ZPF05 = To_Uppercase(ZPF05)\n  ZPF06 = To_Uppercase(ZPF06)\n  ZPF07 = To_Uppercase(ZPF07)\n  ZPF08 = To_Uppercase(ZPF08)\n  ZPF09 = To_Uppercase(ZPF09)\n  ZPF10 = To_Uppercase(ZPF10)\n  ZPF11 = To_Uppercase(ZPF11)\n  ZPF12 = To_Uppercase(ZPF12)\n  ZPF13 = To_Uppercase(ZPF13)\n  ZPF14 = To_Uppercase(ZPF14)\n  ZPF15 = To_Uppercase(ZPF15)\n  ZPF16 = To_Uppercase(ZPF16)\n  ZPF17 = To_Uppercase(ZPF17)\n  ZPF18 = To_Uppercase(ZPF18)\n  ZPF19 = To_Uppercase(ZPF19)\n  ZPF20 = To_Uppercase(ZPF20)\n  ZPF21 = To_Uppercase(ZPF21)\n  ZPF22 = To_Uppercase(ZPF22)\n  ZPF23 = To_Uppercase(ZPF23)\n  ZPF24 = To_Uppercase(ZPF24)\n  pfkeys_verb.ZPF01 = pfkeys_verb.ZPF01\"PF01/\"\n  pfkeys_verb.ZPF02 = pfkeys_verb.ZPF02\"PF02/\"\n  pfkeys_verb.ZPF03 = pfkeys_verb.ZPF03\"PF03/\"\n  pfkeys_verb.ZPF04 = pfkeys_verb.ZPF04\"PF04/\"\n  pfkeys_verb.ZPF05 = pfkeys_verb.ZPF05\"PF05/\"\n  pfkeys_verb.ZPF06 = pfkeys_verb.ZPF06\"PF06/\"\n  pfkeys_verb.ZPF07 = pfkeys_verb.ZPF07\"PF07/\"\n  pfkeys_verb.ZPF08 = pfkeys_verb.ZPF08\"PF08/\"\n  pfkeys_verb.ZPF09 = pfkeys_verb.ZPF09\"PF09/\"\n  pfkeys_verb.ZPF10 = pfkeys_verb.ZPF10\"PF10/\"\n  pfkeys_verb.ZPF11 = pfkeys_verb.ZPF11\"PF11/\"\n  pfkeys_verb.ZPF12 = pfkeys_verb.ZPF12\"PF12/\"\n  pfkeys_verb.ZPF13 = pfkeys_verb.ZPF13\"PF13/\"\n  pfkeys_verb.ZPF14 = pfkeys_verb.ZPF14\"PF14/\"\n  pfkeys_verb.ZPF15 = pfkeys_verb.ZPF15\"PF15/\"\n  pfkeys_verb.ZPF16 = pfkeys_verb.ZPF16\"PF16/\"\n  pfkeys_verb.ZPF17 = pfkeys_verb.ZPF17\"PF17/\"\n  pfkeys_verb.ZPF18 = pfkeys_verb.ZPF18\"PF18/\"\n  pfkeys_verb.ZPF19 = pfkeys_verb.ZPF19\"PF19/\"\n  pfkeys_verb.ZPF20 = pfkeys_verb.ZPF20\"PF20/\"\n  pfkeys_verb.ZPF21 = pfkeys_verb.ZPF21\"PF21/\"\n  pfkeys_verb.ZPF22 = pfkeys_verb.ZPF22\"PF22/\"\n  pfkeys_verb.ZPF23 = pfkeys_verb.ZPF23\"PF23/\"\n  pfkeys_verb.ZPF24 = pfkeys_verb.ZPF24\"PF24/\"\n  pfkeys_verb.ZPF01 = Strip(pfkeys_verb.ZPF01,\"T\",\"/\")\n  pfkeys_verb.ZPF02 = Strip(pfkeys_verb.ZPF02,\"T\",\"/\")\n  pfkeys_verb.ZPF03 = Strip(pfkeys_verb.ZPF03,\"T\",\"/\")\n  pfkeys_verb.ZPF04 = Strip(pfkeys_verb.ZPF04,\"T\",\"/\")\n  pfkeys_verb.ZPF05 = Strip(pfkeys_verb.ZPF05,\"T\",\"/\")\n  pfkeys_verb.ZPF06 = Strip(pfkeys_verb.ZPF06,\"T\",\"/\")\n  pfkeys_verb.ZPF07 = Strip(pfkeys_verb.ZPF07,\"T\",\"/\")\n  pfkeys_verb.ZPF08 = Strip(pfkeys_verb.ZPF08,\"T\",\"/\")\n  pfkeys_verb.ZPF09 = Strip(pfkeys_verb.ZPF09,\"T\",\"/\")\n  pfkeys_verb.ZPF10 = Strip(pfkeys_verb.ZPF10,\"T\",\"/\")\n  pfkeys_verb.ZPF11 = Strip(pfkeys_verb.ZPF11,\"T\",\"/\")\n  pfkeys_verb.ZPF12 = Strip(pfkeys_verb.ZPF12,\"T\",\"/\")\n  pfkeys_verb.ZPF13 = Strip(pfkeys_verb.ZPF13,\"T\",\"/\")\n  pfkeys_verb.ZPF14 = Strip(pfkeys_verb.ZPF14,\"T\",\"/\")\n  pfkeys_verb.ZPF15 = Strip(pfkeys_verb.ZPF15,\"T\",\"/\")\n  pfkeys_verb.ZPF16 = Strip(pfkeys_verb.ZPF16,\"T\",\"/\")\n  pfkeys_verb.ZPF17 = Strip(pfkeys_verb.ZPF17,\"T\",\"/\")\n  pfkeys_verb.ZPF18 = Strip(pfkeys_verb.ZPF18,\"T\",\"/\")\n  pfkeys_verb.ZPF19 = Strip(pfkeys_verb.ZPF19,\"T\",\"/\")\n  pfkeys_verb.ZPF20 = Strip(pfkeys_verb.ZPF20,\"T\",\"/\")\n  pfkeys_verb.ZPF21 = Strip(pfkeys_verb.ZPF21,\"T\",\"/\")\n  pfkeys_verb.ZPF22 = Strip(pfkeys_verb.ZPF22,\"T\",\"/\")\n  pfkeys_verb.ZPF23 = Strip(pfkeys_verb.ZPF23,\"T\",\"/\")\n  pfkeys_verb.ZPF24 = Strip(pfkeys_verb.ZPF24,\"T\",\"/\")\n  Return vget_rc\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Set a string to press a help PFKey.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nask_to_get_help:\n  pfkey_rc = pfkeys_by_name()\n  If (Left(pfkeys_verb.verb_help,2) = \"PF\") Then Do\n    press_this = \"Press\" pfkeys_verb.verb_help\n  End\n  Else Do\n    press_this = pfkeys_verb.verb_help\n  End\n  Return press_this\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Read the #1TASKS and #2VARS into ISPF tables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTasks_initialization:\n  @trap_state = TRAPMSG(\"On\")\n  msg_state = Msg(\"OFF\")\n  sysdsn_rc = SysDsn(task_dsn)\n  If (sysdsn_rc <> \"OK\") Then Do\n    msg_rc = 1\n    return_code = 16\n    Return return_code\n  End\n  msg_rc = Msg(msg_state)\n  @trap_state = TRAPMSG(@trap_state)\n  capture_state = OutTrap(captured.)\n  Address TSO ,\n    \"ALLOC File(TASKS) DataSet(\"task_dsn\") SHR REUSE\"\n  alloc_rc = RC\n  Address MVS ,\n    \"EXECIO * DiskR TASKS (Stem tasklist. Finis)\"\n  execio_rc = RC\n  Address TSO ,\n    \"FREE File(TASKS)\"\n  free_rc = RC\n  restore_state = OutTrap(capture_state)\n\n  Address ISPEXEC,\n    \"TBEnd TASKTABL\"\n  Address ISPEXEC,\n    \"TBCREATE TASKTABL\" ,\n    \"NAMES(TASKZSEL, TASKSEQ, TASKTYPE, TASKITEM,\" ,\n      \"TASKDONE, TASKRC, TASKDESC)\" ,\n    \"REPLACE\" ,\n    \"NOWRITE\"\n  tbcreate_rc = RC\n  If (tbcreate_rc <> 0) Then Do\n    Select\n      When (tbcreate_rc = 4) Then Do\n        ZERRLM = \"4 - Duplicate table exists but 'replace' specified\"\n      End\n      When (tbcreate_rc = 8) Then Do\n        ZERRLM = \"8 - Table already exists; 'replace' not specified\"\n      End\n      When (tbcreate_rc = 12) Then Do\n        ZERRLM = \"Table in use; enq failed\"\n      End\n      When (tbcreate_rc = 16) Then Do\n        ZERRLM = \"Table input library not allocated with 'write'\"\n      End\n      When (tbcreate_rc = 20) Then Do\n        ZERRLM = \"Severe error\"\n      End\n      Otherwise Do\n        ZERRLM = tbcreate_rc \"is a new value to this code.\"\n      End\n    End\n    Return tbcreate_rc\n  End\n  tbcreate_tasktbl = 1\n/*\n*SQ Type    Item     Description goes on a second line               Done     St\n*== ======= ======== =============================================== ======== ==\n001 Browse  $$README                                                 20170718 00\nRead about the installation tasks.\n002 Routine $SETVARS\nSet values for variables used.\n003 Execute MSICXDSN\nGlobally changes variables in this PDS.\n010 Submit  @03AALC\nAllocate the WISHLIST data set.\n015 Receive\nReceive the XM variable named IDTF members.\n020 Edit    USERMBR\nEdit a member.\n021 View    MSIC$DOC\n(Optioonal) View a documentation member.\n*/\n  Do tx = 1 to tasklist.0\n    If (Left(tasklist.tx,1) = \"*\") Then Iterate\n    Parse Var tasklist.tx ,\n          tasklist_seq.tx +3 ,\n       =5 tasklist_type.tx +7 ,\n      =13 tasklist_item.tx +8 ,\n      =70 tasklist_done.tx +8 ,\n      =79 tasklist_status.tx +2 .\n    tasklist_item.tx = Strip(tasklist_item.tx,\"T\",\" \")\n    Address ISPEXEC \"TBVCLEAR TASKTABL\"\n    TASKSEQ = tasklist_seq.tx\n    TASKTYPE = tasklist_type.tx\n    TASKITEM = tasklist_item.tx\n    TASKDONE = tasklist_done.tx\n    TASKRC = tasklist_status.tx\n    tx = tx + 1\n    tasklist_descr.tx = Strip(tasklist.tx,\"T\",\" \")\n    TASKDESC = tasklist_descr.tx\n    Address ISPEXEC \"TBAdd TASKTABL\"\n    tbadd_rc = RC\n    If (tbadd_rc <> 0) Then Do\n      Select\n        When (tbadd_rc = 4) Then Do\n          ZERRLM = \"TASKTABL TBADD, Number of rows parameter\" ,\n                   \"was specified but storage\" ,\n                   \"was only obtained for a\" ,\n                   \"single row\"\n          msg_rc = 1\n        End\n        When (tbadd_rc = 8) Then Do\n          ZERRLM = \"TASKTABL TBADD, Key tables: a row with the\" ,\n                   \"same key already exists;\" ,\n                   \"crp set to top\"\n        End\n        When (tbadd_rc = 12) Then Do\n          ZERRLM = \"TASKTABL TBADD, Table is not open\"\n          msg_rc = 1\n        End\n        When (tbadd_rc = 16) Then Do\n          ZERRLM = \"TASKTABL TBADD, Severe error\"\n          msg_rc = 1\n        End\n        Otherwise Do\n          ZERRLM = \"TASKTABL TBADD,\" ,\n            tbadd_rc \"is a new value to this code.\"\n          msg_rc = 1\n        End\n      End\n    End\n  End\n  Address ISPEXEC \"TBSort TASKTABL Fields(taskseq,C,A)\"\n  Address ISPEXEC \"TBTop TASKTABL\"\n\n/*\n*Item    A  Length Description\n*======= == ====== =================================================\nWISHLIST DS 46     Name of the WISHLIST pds data set.\n'GENIE.SYSPROG.WISHLIST'\nWISHINDX MB 8      Name of the WISHLIST configuration member.\n$$$$$$$$\nHLQ      UC 8      High level qualifier for GENIE data sets.\nGENIE\nUSSPATH  MC 80     UNIX System Services directory.\n/usr/lpp/java\nTIME     N  4      Step card TIME= value.\n1420\n@05$$$$  XM 46     DSName for GENIE WISHLIST items.\n'GENIE.WISHLIST.$$$$'\n*/\n  @trap_state = TRAPMSG(\"On\")\n  msg_state = Msg(\"OFF\")\n  sysdsn_rc = SysDsn(vars_dsn)\n  If (sysdsn_rc <> \"OK\") Then Do\n    msg_rc = 1\n    return_code = 16\n    Return return_code\n  End\n  msg_rc = Msg(msg_state)\n  @trap_state = TRAPMSG(@trap_state)\n  Address TSO ,\n    \"ALLOC File(VARS) DataSet(\"vars_dsn\") SHR REUSE\"\n  alloc_rc = RC\n  Address MVS ,\n    \"EXECIO * DiskR VARS (Stem varslist. Finis)\"\n  execio_rc = RC\n  Address TSO ,\n    \"FREE File(VARS)\"\n  free_rc = RC\n  Address ISPEXEC,\n    \"TBEnd\" vdef_table\n  Address ISPEXEC,\n    \"TBCREATE\" vdef_table ,\n    \"NAMES(VDEFVAR, VDEFATTR, VDEFLEN,\" ,\n      \"VDEFVAL, VDEFDESC)\" ,\n    \"SHARE\" ,\n    \"NOWRITE\"\n  tbcreate_rc = RC\n  If (tbcreate_rc <> 0) Then Do\n    ZERRLM = tbcreate_rc \"unexpected\"\n    Return tbcreate_rc\n  End\n  tbcreate_vdef_table = 1\n  Address ISPEXEC \"TBVCLEAR\" vdef_table\n  VDEFVAR = \"HOSTDSN1\"\n  VDEFATTR = \"DS\"\n  VDEFLEN  = 46\n  VDEFDESC = \"The data set used to launch #SETUP.\"\n  VDEFVAL  = \"'\"mainname\"'\"\n  Address ISPEXEC \"TBAdd\" vdef_table\n  Address ISPEXEC \"TBVCLEAR\" vdef_table\n  VDEFVAR = \"HOSTDSN2\"\n  VDEFATTR = \"DS\"\n  VDEFLEN  = 44\n  VDEFDESC = \"The data set used to launch #SETUP.\"\n  VDEFVAL  = mainname\n  Address ISPEXEC \"TBAdd\" vdef_table\n  Address ISPEXEC \"TBVCLEAR\" vdef_table\n  VDEFVAR = \"UNIT\"\n  VDEFATTR = \"UC\"\n  VDEFLEN  = 8\n  VDEFDESC = \"Name of DISK volume for new data sets.\"\n  VDEFVAL  = vdef_unit\n  Address ISPEXEC \"TBAdd\" vdef_table\n  Address ISPEXEC \"TBVCLEAR\" vdef_table\n  VDEFVAR = \"VOLSER\"\n  VDEFATTR = \"UC\"\n  VDEFLEN  = 8\n  VDEFDESC = \"Name of DISK volume for new data sets.\"\n  VDEFVAL  = vdef_volser\n  Address ISPEXEC \"TBAdd\" vdef_table\n  Address ISPEXEC \"TBVCLEAR\" vdef_table\n  VDEFVAR = \"ZUSER\"\n  VDEFATTR = \"UC\"\n  VDEFLEN  = 8\n  VDEFDESC = \"Your current USERID.\"\n  VDEFVAL  = sysvar_sysuid\n  Address ISPEXEC \"TBAdd\" vdef_table\n  vdefine_list = \"\"\n  vdefine_attrib. = \"\"\n  vdefine_length. = 0\n  vdefine_val. = \"\"\n  Do tx = 1 to varslist.0\n    If (Left(varslist.tx,1) = \"*\") Then Iterate\n    Parse Var varslist.tx ,\n          varslist_item.tx +8 ,\n      =10 varslist_attr.tx +2 ,\n      =13 varslist_len.tx \" \" . ,\n      =20 varslist_desc.tx \" \" .\n    varslist_item.tx = Strip(varslist_item.tx,\"T\",\" \")\n    varslist_desc.tx = Strip(varslist_desc.tx,\"T\",\" \")\n    varslist_key = varslist_item.tx\n    vdefine_list = vdefine_list||varslist_key\" \"\n    vdefine_var.varslist_key = tx\n    ox = tx\n    tx = tx + 1\n    varslist_val = Left(varslist.tx,varslist_len.ox)\n    Address ISPEXEC \"TBVCLEAR\" vdef_table\n    VDEFVAR = varslist_key\n    VDEFATTR = varslist_attr.ox\n    VDEFLEN  = varslist_len.ox\n    VDEFDESC = varslist_desc.ox\n    VDEFVAL  = varslist_val\n    Address ISPEXEC \"TBAdd\" vdef_table\n  End\n\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Display the task table until the user exits.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTasks_processing:\n  Address ISPEXEC \"VGet (ZSCREENW)\"\n  hw = (ZSCREENW - 16) % 2\n  ZTDMARK = Copies(\"-\",hw)\"> End of tasks <\"Copies(\"-\",hw)\n  msicptsk_tbdispl_rc = 0\n  Do While (msicptsk_tbdispl_rc < 8)\n    Address ISPEXEC \"TBDISPL TASKTABL PANEL(MSICPTSK)\"\n    msicptsk_tbdispl_rc = RC\n    Select\n      When (msicptsk_tbdispl_rc = 8) Then Do\n        Leave\n      End\n      When (msicptsk_tbdispl_rc > 4) Then Do\n        ZERRLM = \"RC is too high,\" msicptsk_tbdispl_rc\".\"\n        msg_rc = 1\n        return msicptsk_tbdispl_rc\n      End\n      Otherwise Do\n        tasks_zcmd_rc = tasks_zcmd_procesing()\n        If (tasks_zcmd_rc <> 0) Then Do\n          return tasks_zcmd_rc\n        End\n        tasks_zsel_rc = tasks_zsel_procesing()\n      End\n    End\n  End\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Process ==>Command options.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\ntasks_zcmd_procesing:\n  msg_rc = 0\n  task_zcmd = ZCMD\n  ZCMD = \"\"\n  Select\n    When (task_zcmd = \"\") Then Do\n      return return_code\n    End\n    When (To_Uppercase(task_zcmd) = \"ZORK\") Then Do\n      function_rc = ZORK_easter_egg()\n    End\n    When (To_Uppercase(task_zcmd) = \"X\") Then Do\n      ZERRSM = \"Okay\"\n      ZERRLM = \"You used X to leave.\"\n      Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      return_code = 8\n    End\n    When (task_zcmd = \"?\") Then Do\n      Address ISPEXEC \"Control Display Save\"\n      Address ISPEXEC \"AddPop\"\n      Address ISPEXEC \"Display Panel(MSICHTZ1)\"\n      Address ISPEXEC \"RemPop\"\n      Address ISPEXEC \"Control Display Restore\"\n      Select\n        When ((DS34LCMD = \"/\") | (DS34LCMD = \"?\")) Then Do\n          ZERRSM = \"No way!\"\n          ZERRLM = \"Asking for recursive help is inexscusable.\"\n          Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n        End\n        Otherwise Do\n          DS34LCMD = To_Uppercase(DS34LCMD)\n          function_rc = ds34_table_row_selection()\n        End\n      End\n    End\n    Otherwise Do\n      ZERRSM = \"What?\"\n      ZERRLM = \"Choose a valid option or feature.\"\n      Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    End  /* End of OTHERWISE */\n  End  /* End of SELECT  */\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Loop thru the selected task rows.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\ntasks_zsel_procesing:\n  msicptsk_tbdispl_rc = 0\n  Do While (ZTDSELS > 0)\n    TASKZSEL = To_Uppercase(TASKZSEL)\n    function_rc = tasks_row_selection()\n    TASKZSEL = \"\"\n    Address ISPEXEC \"TBPUT TASKTABL\"\n    save_rc = tasks_save_state()\n    If (ZTDSELS > 1) Then Do\n      Address ISPEXEC \"TBDISPL TASKTABL\"\n      msicptsk_tbdispl_rc = RC\n    End\n    Else Do\n      ZTDSELS = 0\n    End\n  End\n  Return msicptsk_tbdispl_rc\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n Process the ROW selection.\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\ntasks_row_selection:\n  Select\n    When (TASKZSEL = \"S\") Then Do\n      Select\n        When (To_uppercase(TASKTYPE) = \"BROWSE\") Then Do\n          out_dsn = \"'\"mainname\"(\"taskitem\")'\"\n          Address ISPEXEC \"Control Display Save\"\n          orig_zscr = ZSCR\n          Address ISPEXEC \"Browse DATASET(\"OUT_DSN\")\"\n          browse_rc = RC\n          Address ISPEXEC \"Control Display Restore\"\n          ZSCR = orig_zscr\n          taskdone = Date(\"S\")\n          taskrc = \"00\"\n          If (browse_rc <> 0) Then Do\n            ZERRSM = ask_to_get_help()\n            ZERRLM = \"Configuration error,\" taskitem \"not present.\"\n            Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n            taskrc = \"NG\"\n          End\n        End\n        When (To_uppercase(TASKTYPE) = \"EDIT\") Then Do\n          out_dsn = \"'\"mainname\"(\"taskitem\")'\"\n          Address ISPEXEC \"Control Display Save\"\n          orig_zscr = ZSCR\n          Address ISPEXEC \"EDIT DATASET(\"OUT_DSN\")\"\n          EDIT_rc = RC\n          Address ISPEXEC \"Control Display Restore\"\n          ZSCR = orig_zscr\n          taskdone = Date(\"S\")\n          taskrc = \"00\"\n          If (EDIT_rc <> 0) Then Do\n            ZERRSM = ask_to_get_help()\n            ZERRLM = \"Configuration error,\" taskitem \"not present.\"\n            Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n            taskrc = \"NG\"\n          End\n        End\n        When (To_uppercase(TASKTYPE) = \"VIEW\") Then Do\n          out_dsn = \"'\"mainname\"(\"taskitem\")'\"\n          Address ISPEXEC \"Control Display Save\"\n          orig_zscr = ZSCR\n          Address ISPEXEC \"VIEW DATASET(\"OUT_DSN\")\"\n          VIEW_rc = RC\n          Address ISPEXEC \"Control Display Restore\"\n          ZSCR = orig_zscr\n          taskdone = Date(\"S\")\n          taskrc = \"00\"\n          If (VIEW_rc <> 0) Then Do\n            ZERRSM = ask_to_get_help()\n            ZERRLM = \"Configuration error,\" taskitem \"not present.\"\n            Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n            taskrc = \"NG\"\n          End\n        End\n        When (To_uppercase(TASKTYPE) = \"EXECUTE\") Then Do\n          Address TSO taskitem\n          execute_rc = RC\n          taskdone = Date(\"S\")\n          taskrc = Right(execute_rc,2,\"0\")\n        End\n        When (To_uppercase(TASKTYPE) = \"ROUTINE\") Then Do\n          Interpret \"routine_rc = \"taskitem\"_routine()\"\n          taskdone = Date(\"S\")\n          taskrc = Right(routine_rc,2,\"0\")\n        End\n        When (To_uppercase(TASKTYPE) = \"RECEIVE\") Then Do\n          Address ISPEXEC \"TBTop\" vdef_table\n          prompting = Prompt(\"On\")\n          zerrsm = \"RECEIVE results\"\n          ZERRLM = \"\"\n          receive_rc = 0\n          tbskip_rc = 0\n          Do While (tbskip_rc = 0)\n            Address ISPEXEC \"TBSkip\" vdef_table\n            tbskip_rc = RC\n            If (tbskip_rc = 0) Then Do\n              If (vdefattr = \"XM\") Then Do\n                xmit_dsn = \"'\"mainname\"(\"vdefvar\")'\"\n                xmit_dsn = lseldsnm\n                Address TSO \"Alloc File(INMRCK)\" ,\n                  \"Dataset(\"xmit_dsn\") SHR REUSE\"\n                Address MVS \"Execio 1 DISKR INMRCK (Stem inmr. FINIS)\"\n                Address TSO \"Free File(INMRCK)\"\n                If (Pos(\"\\INMR01\",inmr.1) <> 2) Then Do\n                  ZERRLM = ZERRLM || ,\n                    Left(vdefvar \"is not an IDTF file = INMR01<>2\",79)\n                End\n                Else Do\n                  vdefval = Strip(vdefval,\"T\",\" \")\n                  Address TSO \"MakeBuf\"\n                  prompting = Prompt(\"On\")\n                  Queue \"Dataset(\"vdefval\")\" ,\n                    \"UNIT(\"vdef_unit\") VOLUME(\"vdef_volser\")\"\n                  Address TSO \"Receive INDA(\"xmit_dsn\")\"\n                  xmit_rc = RC\n                  Address TSO \"DropBuf\"\n                  prompting = Prompt(prompting)\n                  ZERRLM = ZERRLM || ,\n                    Left(vdefvar xmit_rc,79)\n                  If (xmit_rc > receive_rc) Then receive_rc = xmit_rc\n                End\n              End\n            End\n          End\n          prompting = Prompt(prompting)\n          ZERRSM = ask_to_get_help()\n          Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n          taskdone = Date(\"S\")\n          taskrc = Right(receive_rc,2,\"0\")\n        End\n        When (To_uppercase(TASKTYPE) = \"SUBMIT\") Then Do\n          out_dsn = \"'\"mainname\"(\"taskitem\")'\"\n          Address ISPEXEC \"Control Display Save\"\n          orig_zscr = ZSCR\n          @outtrap_state = OutTrap(@caughtit.)\n          Address ISPEXEC \"Edit DATASET(\"OUT_DSN\") MACRO(MSICMMBR)\"\n          submit_rc = RC\n          @outtrap_state = OutTrap(@outtrap_state)\n          Do oxx = 1 to @caughtit.0\n            say @caughtit.oxx\n          End\n          Address ISPEXEC \"Control Display Restore\"\n          ZSCR = orig_zscr\n          taskdone = Date(\"S\")\n          taskrc = Right(submit_rc,2,\"0\")\n        End\n        Otherwise Do\n          ZERRSM = ask_to_get_help()\n          ZERRLM = \"Not ready to\" tasktype \"on\" taskitem\".\"\n          Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n        End\n      End\n    End\n    When ((TASKZSEL = \"/\") | (TASKZSEL = \"?\")) Then Do\n      TASKZSEL = \"\"\n      Address ISPEXEC \"AddPop\"\n      Address ISPEXEC \"Display Panel(MSICHTL1)\"\n      Address ISPEXEC \"RemPop\"\n      Select\n        When ((TASKZSEL = \"/\") | (TASKZSEL = \"?\")) Then Do\n          ZERRSM = \"No way!\"\n          ZERRLM = \"Asking for recursive help is inexscusable.\"\n          Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n        End\n        Otherwise Do\n          TASKZSEL = To_Uppercase(TASKZSEL)\n          function_rc = tasks_row_selection()\n        End\n      End\n    End\n    Otherwise Do\n      ZERRSM = \"What?\"\n      ZERRLM = \"Use a valid line command (S, /, ?).\"\n      Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    End\n  End\n  Return 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Internal routine to prompt for variable values.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n$SETVARS_routine:\n  Address ISPEXEC \"TBSort\" vdef_table \"Fields(VDEFVAR,C,A)\"\n  Address ISPEXEC \"TBTop\" vdef_table\n  hw = (ZSCREENW - 16) % 2\n  ZTDMARK = Copies(\"-\",hw)\"> End of variables <\"Copies(\"-\",hw)\n  msicpvar_tbdispl_rc = 0\n  Address ISPEXEC \"CONTROL DISPLAY SAVE\"\n  Do While (msicpvar_tbdispl_rc < 8)\n    msicpvar_tbdispl_rc = vdef_tbdispl_panel()\n  End\n  Address ISPEXEC \"CONTROL DISPLAY RESTORE\"\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n In this routine we display the variable intake panel.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nvdef_tbdispl_panel:\n  Address ISPEXEC \"TBDISPL\" vdef_table \"PANEL(MSICPVAR)\"\n  msicpvar_tbdispl_rc = RC\n  Select\n    When (msicpvar_tbdispl_rc = 8) Then Do\n      return msicpvar_tbdispl_rc\n    End\n    When (msicpvar_tbdispl_rc > 4) Then Do\n      ZERRLM = \"RC is too high,\" msicpvar_tbdispl_rc\".\"\n      return msicpvar_tbdispl_rc\n    End\n    Otherwise Do\n      vdef_zcmd_rc = vdef_zcmd_procesing()\n      If (vdef_zcmd_rc <> 0) Then Do\n        return vdef_zcmd_rc\n      End\n      vdef_zsel_rc = vdef_zsel_procesing()\n    End\n  End\n  If (msicpvar_tbdispl_rc = 8) Then Do\n    return return_code\n  End\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n In this routine we process the zcmd from the variable intake panel.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nvdef_zcmd_procesing:\n  msg_rc = 0\n  vdef_zcmd = ZCMD\n  ZCMD = \"\"\n  Select\n    When (vdef_zcmd = \"\") Then Do\n      return return_code\n    End\n    When (To_Uppercase(vdef_zcmd) = \"X\") Then Do\n      ZERRSM = \"Okay\"\n      ZERRLM = \"You used X to leave.\"\n      Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      return_code = 8\n    End\n    When (vdef_zcmd = \"?\") Then Do\n      Address ISPEXEC \"AddPop\"\n      Address ISPEXEC \"Display Panel(MSICHVAR)\"\n      Address ISPEXEC \"RemPop\"\n    End\n    Otherwise Do\n      ZERRSM = \"What?\"\n      ZERRLM = \"Choose a valid option or feature.\"\n      Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    End  /* End of OTHERWISE */\n  End  /* End of SELECT  */\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Process all VDEF row changes.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nvdef_zsel_procesing:\n  msicpvar_tbdispl_rc = 0\n  valid_msg = 0\n  ZERRLM = \"\"\n  Do While (ZTDSELS > 0)\n    function_rc = vdef_row_selection()\n    Address ISPEXEC \"TBPUT\" vdef_table\n    save_rc = vdef_save_updates()\n    If (ZTDSELS > 1) Then Do\n      Address ISPEXEC \"TBDISPL\" vdef_table\n      msicpvar_tbdispl_rc = RC\n    End\n    Else Do\n      ztdsels = 0\n    End\n  End\n  If (valid_msg = 1) Then Do\n    ZERRSM = \"Validaion results\"\n    Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n  End\n  Return msicpvar_tbdispl_rc\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n-----------------------------------------------------------------------\n Process the VDEF ROW selection.\n Validate the value matches the attribute and length.\n DS, LC, MB, MC, N, UC\n-----------------------------------------------------------------------\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nvdef_row_selection:\n  good_name = 1\n  vdefvar = Strip(vdefvar,\"T\",\" \")\n  Select\n    When (vdefattr = \"DS\") Then Do\n      vdefval = To_Uppercase(Strip(vdefval,\"T\",\" \"))\n      dsn@len = Length(vdefval)\n      If (dsn@len <= vdeflen) Then Do\n        tmp_dsn = vdefval\n        If (Pos(\"'\",tmp_dsn) > 0) Then Do\n          tmp_dsn = Strip(tmp_dsn,\"B\",\"'\")\n        End\n        Else Do\n          Parse Var vdefval one_qual \".\" .\n          If (one_qual <> sysvar_syspref) Then Do\n            tmp_dsn = sysvar_syspref\".\"tmp_dsn\n          End\n        End\n        Do While (tmp_dsn <> \"\")\n          Parse Var tmp_dsn one_qual \".\" tmp_dsn\n          If (Pos(Left(one_qual,1),Left(valid_names,29)) = 0 ) Then Do\n            good_name = 0\n            ZERRLM = ZERRLM || ,\n              Left(vdefvar \"1st character bad:\" Left(one_qual,1),79)\n          End\n          mbr@len = Length(one_qual)\n          Do ltr = 2 to mbr@len\n            If (Pos(SubStr(one_qual,ltr,1),valid_names) = 0 ) Then Do\n              good_name = 0\n              ZERRLM = ZERRLM || ,\n                Left(vdefvar ltr ,\n                  \"character bad:\" SubStr(one_qual,ltr,1),79)\n            End\n          End\n        End\n      End\n      Else Do\n        good_name = 0\n        ZERRLM = ZERRLM || ,\n          Left(vdefvar dsn@len \"length exceeds\" vdeflen,79)\n      End\n    End\n    When (vdefattr = \"LC\") Then Do\n      vdefval = To_Lowercase(vdefval)\n    End\n    When (vdefattr = \"MB\") Then Do\n      vdefval = To_Uppercase(vdefval)\n      mbr@len = Length(vdefval)\n      good_name = 1\n      If (mbr@len > vdeflen) Then Do\n        If (Pos(Left(vdefval,1),Left(valid_names,29)) = 0 ) Then Do\n          good_name = 0\n          ZERRLM = ZERRLM || ,\n            Left(vdefvar \"1st character bad:\" Left(vdefval,1),79)\n        End\n        Do ltr = 2 to mbr@len\n          If (Pos(SubStr(vdefval,ltr,1),valid_names) = 0 ) Then Do\n            good_name = 0\n            ZERRLM = ZERRLM || ,\n              Left(vdefvar ltr ,\n                \"character bad:\" SubStr(vdefval,ltr,1),79)\n          End\n        End\n      End\n      Else Do\n        good_name = 0\n        ZERRLM = ZERRLM || ,\n          Left(vdefvar mbr@len \"length exceeds\" vdeflen,79)\n      End\n    End\n    When (vdefattr = \"MC\") Then Do\n      NOp\n    End\n    When (vdefattr = \"N\") Then Do\n      good_name = 1\n      val@len = Length(vdefval)\n      If (val@len > vdeflen) Then Do\n        good_name = 0\n        ZERRLM = ZERRLM || ,\n          Left(vdefvar val@len \"length exceeds\" vdeflen,79)\n      End\n      If (DataType(vdefval) <> \"NUM\") Then Do\n        good_name = 0\n        ZERRLM = ZERRLM || ,\n          Left(vdefvar \"is not numeric\",79)\n      End\n    End\n    When (vdefattr = \"UC\") Then Do\n      vdefval = To_Uppercase(vdefval)\n    End\n    When (vdefattr = \"XM\") Then Do\n      val@len = Length(vdefval)\n      If (val@len > vdeflen) Then Do\n        good_name = 0\n        ZERRLM = ZERRLM || ,\n          Left(vdefvar val@len \"length exceeds\" vdeflen,79)\n      End\n      xmit_dsn = \"'\"mainname\"(\"vdefvar\")'\"\n      Address TSO \"Alloc File(INMRCK)\" ,\n        \"Dataset(\"xmit_dsn\") SHR REUSE\"\n      Address MVS \"Execio 1 DISKR INMRCK (Stem inmr. FINIS)\"\n      Address TSO \"Free File(INMRCK)\"\n      If (Pos(\"\\INMR01\",inmr.1) <> 2) Then Do\n        good_name = 0\n        ZERRLM = ZERRLM || ,\n          Left(vdefvar \"is not an IDTF file XM INMR01<>2\",79)\n      End\n    End\n    Otherwise Do\n      msg_rc = 1\n      ZERRLM = ZERRLM || ,\n        Left(vdefvar vdefattr \"is a bad attribute to me.\",79)\n    End\n  End\n  If (good_name = 0) Then Do\n    vdefzsel = \"ERR\"\n  End\n  Else Do\n    ZERRLM = ZERRLM || ,\n      Left(vdefvar \"OK\",79)\n  End\n  valid_msg = 1\n  Address ISPEXEC \"VPut (\"vdefvar\") Shared\"\n  If (vdefvar = \"VOLSER\") Then Do\n    vdef_volser = vdefval\n  End\n  If (vdefvar = \"UNIT\") Then Do\n    vdef_unit = vdefval\n  End\n  Return 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Save the updated #1TASKS list.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\ntasks_save_state:\n  line_of_code = get_my_sigl() + 2\n/* Tasklist\n*\n* Mainframe Software Installation Customizer (MSIC)\n*\n* Tasks require 2 records.\n* Record 1:\n* =====================================================================\n* Seq    N3 Three digit sequence identifier\n* Type   C7 What it is you want to do.\n*             Browse : Let the user BROWSE a PDS member.\n*             Edit   : Let the user EDIT a PDS member.\n*             Execute: Run some external REXX code.\n*             Receive: Receive all XM variables.\n*             Routine: Run an internal REXX routine.\n*             Submit : Submit a member to run in the background.\n*             View : Let the user VIEW a PDS member.\n* Item   C8 What is acted upon.\n* Done   D8 The last attempt date filled in by MSIC.\n* Status C2 How that last attempt fared filled in by MSIC.\n*\n* Record 2:\n* =====================================================================\n* Desc  : A descriptive bit of text.\n*\n*---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8\n*SQ Type    Item     Description goes on a second line               Done     St\n*== ======= ======== =============================================== ======== ==\nEnd */\n  tasklist. = \"\"\n  task_ctr = 0\n  Do While (SourceLine(line_of_code) <> \"End */\")\n    task_ctr = task_ctr + 1\n    tasklist.task_ctr = SourceLine(line_of_code)\n    line_of_code = line_of_code + 1\n  End\n  Address ISPEXEC \"TBTop TASKTABL\"\n  tbskip_rc = 0\n  Do While (tbskip_rc = 0)\n    Address ISPEXEC \"TBSkip TASKTABL\"\n    tbskip_rc = RC\n    If (tbskip_rc = 0) Then Do\n      task_ctr = task_ctr + 1\n      tasklist.task_ctr = Right(taskseq,3,\"0\") ,\n        Left(tasktype,7) Left(taskitem,8) ,\n        Copies(\" \",47) Left(taskdone,8) Left(Taskrc,2)\n      task_ctr = task_ctr + 1\n      tasklist.task_ctr = taskdesc\n    End\n  End\n  task_ctr = task_ctr + 1\n  tasklist.task_ctr = \"*\"\n  task_ctr = task_ctr + 1\n  tasklist.task_ctr = \"* End of #1TASKS.\"\n  @trap_state = TRAPMSG(\"On\")\n  msg_state = Msg(\"OFF\")\n  Address TSO ,\n    \"ALLOC File(TASKS) DataSet(\"task_dsn\") SHR REUSE\"\n  alloc_rc = RC\n  Address MVS ,\n    \"EXECIO * Diskw TASKS (Stem tasklist. Finis)\"\n  execio_rc = RC\n  Address TSO ,\n    \"FREE File(TASKS)\"\n  free_rc = RC\n  msg_rc = Msg(msg_state)\n  @trap_state = TRAPMSG(@trap_state)\n  Return 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Save the updated #2VARS list.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nvdef_save_updates:\n  line_of_code = get_my_sigl() + 2\n/* Varlist\n*\n* Mainframe Software Installation Customizer (MSIC)\n*\n* Variables require 2 records.\n* Record 1:\n* =====================================================================\n* ITEM         C8 The variable name.\n*                 You will wrap it with exclamation marks when used.\n* Attribute    C2 Provides for limited validation and identification.\n*                   DS = Data set name\n*                   LC = Lowercase\n*                   MB = Member name\n*                   MC = Mixed case (ASIS)\n*                   N  = Number (digits)\n*                   UC = Uppercase\n*                   XM = IDTF member to DSName.\n* Length      N2  The maximum size of the value.\n* Description C61 Describes what the variable is used for.\n*\n* Record 2:\n* =====================================================================\n* The initial default value or the user specified value.\n*\n*---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8\n*Item    A  Length Description (value is on the next row).\n*======= == ====== =============================================================\nEnd */\n  vdeflist. = \"\"\n  vdef_ctr = 0\n  Do While (SourceLine(line_of_code) <> \"End */\")\n    vdef_ctr = vdef_ctr + 1\n    vdeflist.vdef_ctr = SourceLine(line_of_code)\n    line_of_code = line_of_code + 1\n  End\n  Address ISPEXEC \"TBTop\" vdef_table\n  tbskip_rc = 0\n  Do While (tbskip_rc = 0)\n    Address ISPEXEC \"TBSkip\" vdef_table\n    tbskip_rc = RC\n    If (tbskip_rc = 0) Then Do\n      vdef_ctr = vdef_ctr + 1\n      vdeflist.vdef_ctr = Left(vdefvar,8) ,\n        left(vdefattr,2) Left(vdeflen,6) Left(vdefdesc,61)\n      vdef_ctr = vdef_ctr + 1\n      vdeflist.vdef_ctr = Left(vdefval,80)\n    End\n  End\n  vdef_ctr = vdef_ctr + 1\n  vdeflist.vdef_ctr = \"*\"\n  vdef_ctr = vdef_ctr + 1\n  vdeflist.vdef_ctr = \"* End of #2VARS. Saved:\" Date(\"S\") Time()\n  @trap_state = TRAPMSG(\"On\")\n  msg_state = Msg(\"OFF\")\n  Address TSO ,\n    \"ALLOC File(VARS) DataSet(\"vars_dsn\") SHR REUSE\"\n  alloc_rc = RC\n  Address MVS ,\n    \"EXECIO * Diskw VARS (Stem vdeflist. Finis)\"\n  execio_rc = RC\n  Address TSO ,\n    \"FREE File(VARS)\"\n  free_rc = RC\n  msg_rc = Msg(msg_state)\n  @trap_state = TRAPMSG(@trap_state)\n  Return 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Read a data set{member} and verify IDTF format.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_headers:\n  Address ISPEXEC \"AddPop Row(5) Column(20)\"\n  MSICPHSE = \"1 of 13 - Build arrays\"\n  Address ISPEXEC \"CONTROL DISPLAY LOCK\"\n  Address ISPEXEC \"DISPLAY PANEL(MSICPPRG)\"\n  Call idtf_array_creation\n\n  MSICPHSE = \"2 of 13 - TBCreate\"\n  Address ISPEXEC \"CONTROL DISPLAY LOCK\"\n  Address ISPEXEC \"DISPLAY PANEL(MSICPPRG)\"\n  tbcreate_infotabl = 0\n  Address ISPEXEC,\n    \"TBEnd infotabl\"\n  Address ISPEXEC,\n    \"TBCREATE infotabl\" ,\n    \"NAMES(INFOKEY, INFOVAL)\" ,\n    \"REPLACE\" ,\n    \"SHARE\" ,\n    \"NOWRITE\"\n  tbcreate_rc = RC\n  If (tbcreate_rc <> 0) Then Do\n    ZERRLM = \"infotabl create failed, RC(\"tbcreate_rc\").\"\n    msg_rc = 1\n    return tbcreate_rc\n  End\n\n  MSICPHSE = \"3 of 13 - ListDSI()\"\n  Address ISPEXEC \"CONTROL DISPLAY LOCK\"\n  Address ISPEXEC \"DISPLAY PANEL(MSICPPRG)\"\n  info_rc = 0\n  Address ISPEXEC \"CONTROL DISPLAY LOCK\"\n  Address ISPEXEC \"DISPLAY PANEL(MSICPPRG)\"\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"LISTDSI()\"\n  INFOVAL = Copies(\"=\",zscreenw - 11)\n  Address ISPEXEC \"TBAdd infotabl\"\n\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"SYSRECFM\"\n  INFOVAL = SYSRECFM\n  Address ISPEXEC \"TBAdd infotabl\"\n\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"SYSBLKSIZE\"\n  INFOVAL = SYSBLKSIZE\n  Address ISPEXEC \"TBAdd infotabl\"\n\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"SYSLRECL\"\n  INFOVAL = SYSLRECL\n  Address ISPEXEC \"TBAdd infotabl\"\n\n  blkfctr   = SYSBLKSIZE / SYSLRECL\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"Rec/Blk\"\n  INFOVAL = blkfctr\n  Address ISPEXEC \"TBAdd infotabl\"\n\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"SPACE\"\n  INFOVAL = SYSUNITS\n  Address ISPEXEC \"TBAdd infotabl\"\n\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"Used\"\n  INFOVAL = SYSUSED\n  Address ISPEXEC \"TBAdd infotabl\"\n\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"SYSBLKSTRK\"\n  INFOVAL = SYSBLKSTRK\n  Address ISPEXEC \"TBAdd infotabl\"\n\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"SYSCREATE\"\n  INFOVAL = SYSCREATE\n  Address ISPEXEC \"TBAdd infotabl\"\n\n  Select\n    When (SYSUNITS = \"CYLINDER\") Then Do\n      used_blks = (sysused * SYSTRKSCYL * SYSBLKSTRK)\n    End\n    When (SYSUNITS = \"TRACK\") Then Do\n      used_blks = (sysused * SYSBLKSTRK)\n    End\n    When (SYSUNITS = \"BLOCK\") Then Do\n      used_blks = sysused\n    End\n    Otherwise Do\n      used_blks = \"Unknown\"\n    End\n  End\n\n  MSICPHSE = \"4 of 13 - DiskR\"\n  Address ISPEXEC \"CONTROL DISPLAY LOCK\"\n  Address ISPEXEC \"DISPLAY PANEL(MSICPPRG)\"\n  @trap_state = TRAPMSG(\"On\")\n  msg_state = Msg(\"OFF\")\n  capture_state = OutTrap(captured.)\n  Address TSO ,\n    \"ALLOC File(IDTF) DataSet(\"lseldsnm\") SHR REUSE\"\n  alloc_rc = RC\n  execio_rc = 0\n  blk_ctr = 0\n  rec_ctr = 0\n  idtf_data = \"\"\n  Do While (execio_rc < 4)\n    Address MVS ,\n      \"EXECIO\" blkfctr \"DiskR IDTF (Stem idtfraw.)\"\n    execio_rc = RC\n    blk_ctr = blk_ctr + 1\n    If (execio_rc < 4) Then Do\n      MSICPHSE = \"4 of 13 - DiskR: Block:\" blk_ctr \"of\" used_blks\n      Address ISPEXEC \"CONTROL DISPLAY LOCK\"\n      Address ISPEXEC \"DISPLAY PANEL(MSICPPRG)\"\n      Do rx = 1 to idtfraw.0\n        idtf_data = idtf_data || idtfraw.rx\n        rec_ctr = rec_ctr + 1\n      End\n      Drop idtfraw.\n    End\n    If (execio_rc = 2) Then Do\n      Leave\n    End\n  End\n  Address MVS ,\n    \"EXECIO 0 DiskR IDTF (Finis)\"\n  execio_rc = RC\n  Address TSO ,\n    \"FREE File(IDTF)\"\n  free_rc = RC\n  restore_state = OutTrap(capture_state)\n  @trap_state = TRAPMSG(@trap_state)\n  msg_rc = Msg(msg_state)\n\n  MSICPHSE = \"5 of 13\"\n  Address ISPEXEC \"CONTROL DISPLAY LOCK\"\n  Address ISPEXEC \"DISPLAY PANEL(MSICPPRG)\"\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"Records\"\n  INFOVAL = rec_ctr\n  Address ISPEXEC \"TBAdd infotabl\"\n\n  file_size = Length(idtf_data)\n  total_blks = file_size % SYSBLKSIZE\n  total_rem  = file_size // SYSBLKSIZE\n  If (total_rem > 0) then total_blks = Total_blks + 1\n  total_recs = file_size / SYSLRECL\n\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"\"\n  INFOVAL = \"\"\n  Address ISPEXEC \"TBAdd infotabl\"\n\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"EXECIO\"\n  INFOVAL = Copies(\"=\",zscreenw - 11)\n  Address ISPEXEC \"TBAdd infotabl\"\n\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"Blocks\"\n  INFOVAL = total_blks\n  Address ISPEXEC \"TBAdd infotabl\"\n\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"Records\"\n  INFOVAL = total_recs\n  Address ISPEXEC \"TBAdd infotabl\"\n\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"Bytes\"\n  INFOVAL = file_size\n  Address ISPEXEC \"TBAdd infotabl\"\n\n  go_no_further = 1\n\n  MSICPHSE = \"6 of 13\"\n  Address ISPEXEC \"CONTROL DISPLAY LOCK\"\n  Address ISPEXEC \"DISPLAY PANEL(MSICPPRG)\"\n  If (Pos(\"\\INMR01\",idtf_data) <> 2) Then Do\n    Address ISPEXEC \"TBVCLEAR infotabl\"\n    INFOKEY = \"\"\n    INFOVAL = \"\"\n    Address ISPEXEC \"TBAdd infotabl\"\n    Address ISPEXEC \"TBVCLEAR infotabl\"\n    INFOKEY = \"**ERROR**\"\n    INFOVAL = \"This is not an IDTF data set. \\INMR01<>2\"\n    Address ISPEXEC \"TBAdd infotabl\"\n    Address ISPEXEC \"TBVCLEAR infotabl\"\n    INFOKEY = \"\"\n    INFOVAL = \"\"\n    Address ISPEXEC \"TBAdd infotabl\"\n    go_no_further = 0\n  End\n  If (Pos(\"\\INMR06\",idtf_data) = 0) Then Do\n    Address ISPEXEC \"TBVCLEAR infotabl\"\n    INFOKEY = \"\"\n    INFOVAL = \"\"\n    Address ISPEXEC \"TBAdd infotabl\"\n    Address ISPEXEC \"TBVCLEAR infotabl\"\n    INFOKEY = \"**ERROR**\"\n    INFOVAL = \"This is either not an IDTF data set\" ,\n      \"or it has been truncated during transmission.\"\n    Address ISPEXEC \"TBAdd infotabl\"\n    Address ISPEXEC \"TBVCLEAR infotabl\"\n    INFOKEY = \"\"\n    INFOVAL = \"\"\n    Address ISPEXEC \"TBAdd infotabl\"\n    go_no_further = 0\n  End\n\n  If (go_no_further = 1) Then Do\n    idtf_headers_rc = idtf_more_headers()\n  End\n  Address ISPEXEC \"REMPOP\"\n\n\n  Address ISPEXEC \"VGet (ZSCREENW)\"\n  hw = (ZSCREENW - 16) % 2\n  ZTDMARK = Copies(\"-\",hw)\"> End of IDTF information. <\"Copies(\"-\",hw)\n  Address ISPEXEC \"TBTop infotabl\"\n  ZERRLM = \"\"\n  msicpinf_tbdispl_rc = 0\n  Do While (msicpinf_tbdispl_rc < 8)\n    Address ISPEXEC \"TBDISPL infotabl PANEL(MSICPINF)\"\n    msicpinf_tbdispl_rc = RC\n    If (msicpinf_tbdispl_rc = 8) Then Do\n      Leave\n    End\n    If (ZERRLM <> \"\") Then Do\n      ZERRSM = ask_to_get_help()\n      Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n    End\n  End\n  Return 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Process records.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_more_headers:\n  MSICPHSE = \"7 of 13\"\n  Address ISPEXEC \"CONTROL DISPLAY LOCK\"\n  Address ISPEXEC \"DISPLAY PANEL(MSICPPRG)\"\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"\"\n  INFOVAL = \"\"\n  Address ISPEXEC \"TBAdd infotabl\"\n\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"INMR\"\n  INFOVAL = Copies(\"=\",zscreenw - 11)\n  Address ISPEXEC \"TBAdd infotabl\"\n\n  char_idx = 1\n  segment_counter = 0\n  buffer_data_ebcdic = \"\"\n  control_keys = \"\"\n  buffer_data. = \"\"\n  buffer_data.onezerone.0 = 0\n  buffer_data.twooneone.0 = 0\n  buffer_data.twotwoone.0 = 0\n  buffer_data.twotwotwo.0 = 0\n  buffer_data.twotwothree.0 = 0\n  buffer_data.threeone.0 = 0\n  buffer_data.threetwo.0 = 0\n  control_counter. = 0\n  cr_last_number = \"\"\n\n  back_here = \"IDTF_abnormal_end\"\n  Signal On Error   Name trapped_an_error\n  Signal On Failure Name trapped_an_error\n  Signal On Syntax  Name trapped_an_error\n  Do Forever\n    If (char_idx > file_size) Then Leave\n    segment_counter = segment_counter + 1\n    segment_len = c2d(SubStr(idtf_data,char_idx,1)) - 2\n    char_idx = char_idx + 1\n    segment_desc_flag = SubStr(idtf_data,char_idx,1)\n    char_idx = char_idx + 1\n    If (segment_len < 1) Then Do\n      rpt = \"SubStr is about to fail, seglen<1 LOC(\"char_idx\").\"\n      say rpt\n      Leave\n    End\n    segment_char = SubStr(idtf_data,char_idx,segment_len)\n    Select\n      When (BitAnd(segment_desc_flag,'E0'x) = 'E0'x) Then Do\n        control_type = SubStr(buffer_data_ebcdic,1,6)\n        buffer_data_ebcdic = segment_char\n        Call idtf_prime_control_key\n        Address ISPEXEC \"TBVCLEAR infotabl\"\n        INFOKEY = \"  E0 \" control_type\n        INFOVAL = \"Complete control record - Length\" ,\n          Length(buffer_data_ebcdic)\n        Address ISPEXEC \"TBAdd infotabl\"\n        Address ISPEXEC \"TBVCLEAR infotabl\"\n        INFOKEY = \"  Ec \" control_type\n        INFOVAL = buffer_data_ebcdic\n        Address ISPEXEC \"TBAdd infotabl\"\n        Address ISPEXEC \"TBVCLEAR infotabl\"\n        INFOKEY = \"  Et \" control_type\n        INFOVAL = Top_Half(segment_char)\n        Address ISPEXEC \"TBAdd infotabl\"\n        Address ISPEXEC \"TBVCLEAR infotabl\"\n        INFOKEY = \"  Eb \" control_type\n        INFOVAL = Bottom_Half(segment_char)\n        Address ISPEXEC \"TBAdd infotabl\"\n        Call idtf_process_control_record\n      End\n      When (BitAnd(segment_desc_flag,'A0'x) = 'A0'x) Then Do\n        buffer_data_ebcdic = segment_char\n        Call idtf_prime_control_key\n        Address ISPEXEC \"TBVCLEAR infotabl\"\n        INFOKEY = \"  A0 \" control_type\n        INFOVAL = \"Begin of multi-part control record\"\n        Address ISPEXEC \"TBAdd infotabl\"\n      End\n      When (BitAnd(segment_desc_flag,'60'x) = '60'x) Then Do\n        buffer_data_ebcdic = buffer_data_ebcdic\"\"segment_char\n        Address ISPEXEC \"TBVCLEAR infotabl\"\n        INFOKEY = \"  60 \" control_type\n        INFOVAL = \"End of control record - Length\" Length(buffer_data_ebcdic)\n        Address ISPEXEC \"TBAdd infotabl\"\n        Address ISPEXEC \"TBVCLEAR infotabl\"\n        INFOKEY = \"  6c \" control_type\n        INFOVAL = buffer_data_ebcdic\n        Address ISPEXEC \"TBAdd infotabl\"\n        Address ISPEXEC \"TBVCLEAR infotabl\"\n        INFOKEY = \"  6t \" control_type\n        INFOVAL = Top_Half(buffer_data_ebcdic)\n        Address ISPEXEC \"TBAdd infotabl\"\n        Address ISPEXEC \"TBVCLEAR infotabl\"\n        INFOKEY = \"  6b \" control_type\n        INFOVAL = Bottom_Half(buffer_data_ebcdic)\n        Address ISPEXEC \"TBAdd infotabl\"\n        Call idtf_process_control_record\n      End\n      When (BitAnd(segment_desc_flag,'20'x) = '20'x) Then Do\n        buffer_data_ebcdic = buffer_data_ebcdic\"\"segment_char\n        Address ISPEXEC \"TBVCLEAR infotabl\"\n        INFOKEY = \"  20 \" control_type\n        INFOVAL = \"Middle of control record\"\n        Address ISPEXEC \"TBAdd infotabl\"\n      End\n      When (BitAnd(segment_desc_flag,'C0'x) = 'C0'x) Then Do\n        buffer_data_ebcdic = segment_char\n        temp = buffer_data.control_key.0 + 1\n        buffer_data.control_key.temp = buffer_data_ebcdic\n        buffer_data.control_key.0 = temp\n      End\n      When (BitAnd(segment_desc_flag,'80'x) = '80'x) Then Do\n        buffer_data_ebcdic = segment_char\n      End\n      When (BitAnd(segment_desc_flag,'40'x) = '40'x) Then Do\n        buffer_data_ebcdic = buffer_data_ebcdic\"\"segment_char\n        temp = buffer_data.control_key.0 + 1\n        buffer_data.control_key.temp = buffer_data_ebcdic\n        buffer_data.control_key.0 = temp\n      End\n      When (BitAnd(segment_desc_flag,'00'x) = '00'x) Then Do\n        buffer_data_ebcdic = buffer_data_ebcdic\"\"segment_char\n      End\n      When (BitAnd(segment_desc_flag,'10'x) = '10'x) Then Do\n        Say \"10=This is record number of next record. Huh?\"\n      End\n      When (BitAnd(segment_desc_flag,'0F'x) = '0F'x) Then Do\n        Say \"0F=This is reserved. Whole lot of help that is to me.\"\n      End\n      Otherwise Do\n        say c2x(segment_desc_flag) \"is not in my list\"\n        buffer_data_ebcdic = buffer_data_ebcdic\"\"segment_char\n      End\n    End\n    char_idx = char_idx + segment_len\n  End\n\n  MSICPHSE = \"13 of 13\"\n  Address ISPEXEC \"CONTROL DISPLAY LOCK\"\n  Address ISPEXEC \"DISPLAY PANEL(MSICPPRG)\"\n  If ((txtunit_INMUTILN.twooneone = \"INMCOPY\") & ,\n      (txtunit_INMTERM.twooneone = \"Y\")) Then Do\n    Address ISPEXEC \"TBVCLEAR infotabl\"\n    INFOKEY = \"\"\n    INFOVAL = \"\"\n    Address ISPEXEC \"TBAdd infotabl\"\n    Address ISPEXEC \"TBVCLEAR infotabl\"\n    INFOKEY = \"Message\"\n    INFOVAL = Copies(\"+\",zscreenw - 11)\n    Address ISPEXEC \"TBAdd infotabl\"\n    msgmax = buffer_data.threeone.0\n    Do mx = 1 to msgmax\n      Address ISPEXEC \"TBVCLEAR infotabl\"\n      INFOKEY = \"MSG-\"Right(mx,Length(msgmax),\"0\")\n      msg = buffer_data.threeone.mx\n      INFOVAL = msg\n      Address ISPEXEC \"TBAdd infotabl\"\n    End\n    Address ISPEXEC \"TBVCLEAR infotabl\"\n    INFOKEY = \"Message\"\n    INFOVAL = Copies(\"+\",zscreenw - 11)\n    Address ISPEXEC \"TBAdd infotabl\"\n  End\n  If (txtunit_INMUTILN.twooneone = \"IEBCOPY\") Then Do\n    Address ISPEXEC \"TBVCLEAR infotabl\"\n    INFOKEY = \"\"\n    INFOVAL = \"\"\n    Address ISPEXEC \"TBAdd infotabl\"\n    Address ISPEXEC \"TBVCLEAR infotabl\"\n    INFOKEY = \"IEBCOPY HDR1\"\n    INFOVAL = Copies(\"~\",zscreenw - 11)\n    Address ISPEXEC \"TBAdd infotabl\"\n    data_line = buffer_data.threeone.1\n    Address ISPEXEC \"TBVCLEAR infotabl\"\n    INFOKEY = \"IEBCOPY 211 31\"\n    INFOVAL = c2x(data_line)\n    Address ISPEXEC \"TBAdd infotabl\"\n    Call IEBCOPY_decode_hdr1\n    Address ISPEXEC \"TBVCLEAR infotabl\"\n    INFOKEY = \"IEBCOPY HDR1\"\n    INFOVAL = Copies(\"~\",zscreenw - 11)\n    Address ISPEXEC \"TBAdd infotabl\"\n    Address ISPEXEC \"TBVCLEAR infotabl\"\n    INFOKEY = \"IEBCOPY HDR2\"\n    INFOVAL = Copies(\"~\",zscreenw - 11)\n    Address ISPEXEC \"TBAdd infotabl\"\n    data_line = buffer_data.threeone.2\n    Call IEBCOPY_decode_hdr2\n    Address ISPEXEC \"TBVCLEAR infotabl\"\n    INFOKEY = \"IEBCOPY HDR2\"\n    INFOVAL = Copies(\"~\",zscreenw - 11)\n    Address ISPEXEC \"TBAdd infotabl\"\n  End\n  If (txtunit_INMUTILN.twotwotwo = \"INMCOPY\") Then Do\n    Address ISPEXEC \"TBVCLEAR infotabl\"\n    INFOKEY = \"\"\n    INFOVAL = \"\"\n    Address ISPEXEC \"TBAdd infotabl\"\n    Address ISPEXEC \"TBVCLEAR infotabl\"\n    INFOKEY = \"INMCOPY PS\"\n    INFOVAL = \"Physical sequential data set\"\n    Address ISPEXEC \"TBAdd infotabl\"\n  End\n  If (txtunit_INMUTILN.twotwotwo = \"IEBCOPY\") Then Do\n    Address ISPEXEC \"TBVCLEAR infotabl\"\n    INFOKEY = \"\"\n    INFOVAL = \"\"\n    Address ISPEXEC \"TBAdd infotabl\"\n    Address ISPEXEC \"TBVCLEAR infotabl\"\n    INFOKEY = \"IEBCOPY HDR1\"\n    INFOVAL = Copies(\"~\",zscreenw - 11)\n    Address ISPEXEC \"TBAdd infotabl\"\n    data_line = buffer_data.threetwo.1\n    Address ISPEXEC \"TBVCLEAR infotabl\"\n    INFOKEY = \"IEBCOPY 221 32\"\n    INFOVAL = c2x(data_line)\n    Address ISPEXEC \"TBAdd infotabl\"\n    Call IEBCOPY_decode_hdr1\n    Address ISPEXEC \"TBVCLEAR infotabl\"\n    INFOKEY = \"IEBCOPY HDR1\"\n    INFOVAL = Copies(\"~\",zscreenw - 11)\n    Address ISPEXEC \"TBAdd infotabl\"\n    Address ISPEXEC \"TBVCLEAR infotabl\"\n    INFOKEY = \"IEBCOPY HDR2\"\n    INFOVAL = Copies(\"~\",zscreenw - 11)\n    Address ISPEXEC \"TBAdd infotabl\"\n    data_line = buffer_data.threetwo.2\n    Call IEBCOPY_decode_hdr2\n    Address ISPEXEC \"TBVCLEAR infotabl\"\n    INFOKEY = \"IEBCOPY HDR2\"\n    INFOVAL = Copies(\"~\",zscreenw - 11)\n    Address ISPEXEC \"TBAdd infotabl\"\n  End\nIDTF_abnormal_end:\n  Return 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Prime the control key based on control_type\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_prime_control_key:\n  control_type = SubStr(buffer_data_ebcdic,1,6)\n  next_byte = 7\n  temp = control_counter.control_type + 1\n  control_counter.control_type = temp\n  Select\n    When (control_type = \"INMR01\") Then Do\n      control_key = \"1_\"crfile_number\"_\"control_counter.control_type\n      Address ISPEXEC \"TBVCLEAR infotabl\"\n      INFOKEY = \"INMR01\" control_key\n      INFOVAL = Copies(\"-\",zscreenw - 11)\n      Address ISPEXEC \"TBAdd infotabl\"\n    End\n    When (control_type = \"INMR02\") Then Do\n      inmr02_counter = control_counter.control_type\n      crfile_number = c2d(SubStr(buffer_data_ebcdic,next_byte,4))\n      control_key = \"2_\"inmr02_counter\"_\"crfile_number\n      Address ISPEXEC \"TBVCLEAR infotabl\"\n      INFOKEY = \"INMR02\" control_key\n      INFOVAL = Copies(\"-\",zscreenw - 11)\n      Address ISPEXEC \"TBAdd infotabl\"\n    End\n    When (control_type = \"INMR03\") Then Do\n      inmr03_counter = control_counter.control_type\n      control_key = \"3_\"inmr03_counter\n      Address ISPEXEC \"TBVCLEAR infotabl\"\n      INFOKEY = \"INMR03\" control_key\n      INFOVAL = Copies(\"-\",zscreenw - 11)\n      Address ISPEXEC \"TBAdd infotabl\"\n    End\n    When (control_type = \"INMR04\") Then Do\n      inmr04_counter = control_counter.control_type\n      control_key = \"4_\"inmr04_counter\n      Address ISPEXEC \"TBVCLEAR infotabl\"\n      INFOKEY = \"INMR04\" control_key\n      INFOVAL = Copies(\"-\",zscreenw - 11)\n      Address ISPEXEC \"TBAdd infotabl\"\n    End\n    When (control_type = \"INMR06\") Then Do\n      inmr06_counter = control_counter.control_type\n      control_key = \"6_\"inmr06_counter\"_1\"\n      Address ISPEXEC \"TBVCLEAR infotabl\"\n      INFOKEY = \"INMR06\" control_key\n      INFOVAL = Copies(\"-\",zscreenw - 11)\n      Address ISPEXEC \"TBAdd infotabl\"\n    End\n    When (control_type = \"INMR07\") Then Do\n      inmr07_counter = control_counter.control_type\n      control_key = \"7_\"inmr07_counter\n      Address ISPEXEC \"TBVCLEAR infotabl\"\n      INFOKEY = \"INMR07\" control_key\n      INFOVAL = Copies(\"-\",zscreenw - 11)\n      Address ISPEXEC \"TBAdd infotabl\"\n    End\n    Otherwise Do\n      ZERRSM = ask_to_get_help()\n      ZERRLM = ZERRLM || ,\n        Left(\"Bad IDTF data set - truncated?\",79)\n      Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      char_idx = file_size\n    End\n  End\n  Return 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Process INMR* records.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_process_control_record:\n  next_byte = 7\n  Select\n    When (control_type = \"INMR01\") Then Do\n      MSICPHSE = \"8 of 13\"\n      Address ISPEXEC \"CONTROL DISPLAY LOCK\"\n      Address ISPEXEC \"DISPLAY PANEL(MSICPPRG)\"\n      control_key = \"1_\"crfile_number\"_\"control_counter.control_type\n      control_keys = control_keys || control_key || \" \"\n      Call idtf_parse_subtypes\n    End\n    When (control_type = \"INMR02\") Then Do\n      MSICPHSE = \"9 of 13\"\n      Address ISPEXEC \"CONTROL DISPLAY LOCK\"\n      Address ISPEXEC \"DISPLAY PANEL(MSICPPRG)\"\n      inmr02_counter = control_counter.control_type\n      crfile_number = c2d(SubStr(buffer_data_ebcdic,next_byte,4))\n      control_key = \"2_\"inmr02_counter\"_\"crfile_number\n      cr_last_number = crfile_number\n      control_keys = control_keys || control_key || \" \"\n      max_r02.crfile_number = control_counter.control_type\n      next_byte = next_byte + 4\n      Call idtf_parse_subtypes\n    End\n    When (control_type = \"INMR03\") Then Do\n      MSICPHSE = \"10 of 13\"\n      Address ISPEXEC \"CONTROL DISPLAY LOCK\"\n      Address ISPEXEC \"DISPLAY PANEL(MSICPPRG)\"\n      inmr03_counter = control_counter.control_type\n      control_key = \"3_\"inmr03_counter\n      control_keys = control_keys || control_key || \" \"\n      Call idtf_parse_subtypes\n    End\n    When (control_type = \"INMR04\") Then Do\n      MSICPHSE = \"11 of 13\"\n      Address ISPEXEC \"CONTROL DISPLAY LOCK\"\n      Address ISPEXEC \"DISPLAY PANEL(MSICPPRG)\"\n      inmr04_counter = control_counter.control_type\n      control_key = \"4_\"inmr04_counter\n      control_keys = control_keys || control_key || \" \"\n      Call idtf_parse_subtypes\n    End\n    When (control_type = \"INMR06\") Then Do\n      MSICPHSE = \"13 of 13\"\n      Address ISPEXEC \"CONTROL DISPLAY LOCK\"\n      Address ISPEXEC \"DISPLAY PANEL(MSICPPRG)\"\n      inmr06_counter = control_counter.control_type\n      control_key = \"6_\"inmr06_counter\"_1\"\n      control_keys = control_keys || control_key || \" \"\n      segment_len = file_size\n    End\n    When (control_type = \"INMR07\") Then Do\n      MSICPHSE = \"12 of 13\"\n      Address ISPEXEC \"CONTROL DISPLAY LOCK\"\n      Address ISPEXEC \"DISPLAY PANEL(MSICPPRG)\"\n      inmr07_counter = control_counter.control_type\n      control_key = \"7_\"inmr07_counter\n      control_keys = control_keys || control_key || \" \"\n      Call idtf_parse_subtypes\n    End\n    Otherwise Do\n      Say \"Unknown control record type\" control_type\".\"\n      rpt = \"     CR # =\" crfile_number control_counter.control_type\n      Say rpt\n    End\n  End\n  Return 0\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Decode the dataset attributes\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nIEBCOPY_decode_hdr1:\n  Parse Var data_line        /* loadlib    panels   */ ,\n                             /* pds        pdse     */ ,\n    pds_pdse        +4       /* 00CA6D0F   01CA6D0F */ ,\n    dsorg           +2       /* 0200       0200     */ ,\n    blksize         +2       /* 7FF8       6D10     */ ,\n    lrecl           +2       /* 0000       0050     */ ,\n    recfm           +2       /* C000       9000     */ ,\n    .               +2       /* 0080       0000     */ ,\n    minblksize      +2       /* 0C30       0C30     */ ,\n    .               +2       /* 3030       0008     */ ,\n    devtype         +1       /* 20         20       */ ,\n    dasdtype        +1       /* 0F         00       */ ,\n    .               +2       /* 0000       0000     */ ,\n    maxblksize      +2       /* 7FF8       7FF8     */ ,\n    devcapacity     +2       /* 0D0B       0100     */ ,\n    cylcapacity     +2       /* 000F       0100     */ ,\n    trkcapacity     +2       /* E5A2       FFFF     */ ,\n    .               +2       /* 0000       0000     */ ,\n    .               +2       /* 2252       0000     */ ,\n    .               +2       /* 0000       0000     */ ,\n    .               +2       /* 00B4       0000     */ ,\n    .               +1       /* 80         00       */ ,\n    used_blksize    +2       /* 7FF8       0000     */ ,\n    used_lrecl      +1       /* 50         00       */ ,\n    .               +2       /* 0000       0000     */ ,\n    .               +2       /* 0F00       0000     */ ,\n    .               +4       /* 03135632   00000000 */ ,\n    .               +2       /* 0000       0000     */ ,\n    .               +2       /* 0000       0000     */ ,\n    .               +2       /* 0000       0000     */ ,\n    warn_me\n  hex_pds_pdse = c2x(pds_pdse)\n  dev_trk_cyl = c2d(cylcapacity)\n  Select\n    When (hex_pds_pdse = \"00CA6D0F\") Then display_pds_pdse = \"PDS\"\n    When (hex_pds_pdse = \"01CA6D0F\") Then display_pds_pdse = \"PDSE\"\n    When (hex_pds_pdse = \"11CA6D0F\") Then display_pds_pdse = \"PDSE\"\n    Otherwise Do\n      display_pds_pdse = \"UNK-\"hex_pds_pdse\n    End\n  End\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = display_pds_pdse\n  INFOVAL = hex_pds_pdse\n  Address ISPEXEC \"TBAdd infotabl\"\n  dsorg   = idtf_parse_INMDSORG_meaning(c2x(dsorg))\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"DSORG\"\n  INFOVAL = dsorg\n  Address ISPEXEC \"TBAdd infotabl\"\n  recfm   = idtf_parse_INMRECFM_meaning(c2x(recfm))\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"RECFM\"\n  INFOVAL = recfm\n  Address ISPEXEC \"TBAdd infotabl\"\n  blksize = c2d(blksize)\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"BLKSIZE\"\n  INFOVAL = blksize\n  Address ISPEXEC \"TBAdd infotabl\"\n  lrecl = c2d(lrecl)\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"LRECL\"\n  INFOVAL = lrecl\n  Address ISPEXEC \"TBAdd infotabl\"\n  lrecl = c2d(used_lrecl)\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"Used LRECL\"\n  INFOVAL = lrecl\n  Address ISPEXEC \"TBAdd infotabl\"\n  minblksize = c2d(minblksize)\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"MINBLKSIZE\"\n  INFOVAL = minblksize\n  Address ISPEXEC \"TBAdd infotabl\"\n  maxblksize = c2d(maxblksize)\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"MAXBLKSIZE\"\n  INFOVAL = maxblksize\n  Address ISPEXEC \"TBAdd infotabl\"\n  devcapacity = c2d(devcapacity)\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"DEVCAPACITY\"\n  INFOVAL = devcapacity\n  Address ISPEXEC \"TBAdd infotabl\"\n  cylcapacity = c2d(cylcapacity)\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"CYLCAPACITY\"\n  INFOVAL = cylcapacity\n  Address ISPEXEC \"TBAdd infotabl\"\n  trkcapacity = c2d(trkcapacity)\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"TRKCAPACITY\"\n  INFOVAL = trkcapacity\n  Address ISPEXEC \"TBAdd infotabl\"\n  dasdname = convert_dasdtype(dasdtype devcapacity)\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"DASDNAME\"\n  INFOVAL = dasdname\n  Address ISPEXEC \"TBAdd infotabl\"\n  If (warn_me <> \"\") Then Do\n    Address ISPEXEC \"TBVCLEAR infotabl\"\n    INFOKEY = \"Warn Me\"\n    INFOVAL = c2x(warn_me)\n    Address ISPEXEC \"TBAdd infotabl\"\n  End\n  mbr_char. = \"\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Convert dasdtype to displayable meaning\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nconvert_dasdtype:\n  Parse Arg bin_dasdtype dec_devcapacity\n  hex_dasdtype = c2x(bin_dasdtype)\n  d_dasdtype = Value(\"dasd_model.\"hex_dasdtype\".\"dec_devcapacity)\n  Return d_dasdtype\n/*dasd_model.{dasdtype}.{max_cyl} = model_type                 */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Decode the dataset adjustments.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nIEBCOPY_decode_hdr2:\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"Record2\"\n  INFOVAL = C2X(data_line)\n  Address ISPEXEC \"TBAdd infotabl\"\n  Select\n    When (c2x(left(data_line,4)) = \"01000000\") Then Do\n      Parse Var data_line,\n        control_word    +4       /* 01000000 */ ,\n        reserved_1      +4       /* FF000000 */ ,\n        reserved_2      +4       /* 8F0AD000 */ ,\n        reserved_3      +4       /* 0479D0C8 */ ,\n        reserved_4      +4       /* 58F537A0 */ ,\n        reserved_5      +2       /* 0000     */ ,\n        cc_beg          +2       /* 0976     */ ,\n        hh_beg          +2       /*     000A */ ,\n        cc_end          +2       /* 097A     */ ,\n        hh_end          +2       /*     0009 */ ,\n        cc_hh_ctr       +2       /* 003C     */ ,\n        reserved_8      +4       /* 00000000 */ ,\n        reserved_9      +4       /* 00000000 */ ,\n        reserved_10     +4       /* 00000000 */ ,\n        reserved_11     +4       /* 00000000 */ ,\n        reserved_12     +4       /* 00000000 */ ,\n        reserved_13     +4       /* 00000000 */ ,\n        reserved_14     +4       /* 00000000 */ ,\n        reserved_15     +4       /* 00000000 */ ,\n        reserved_16     +212     /* -00-     */ ,\n      warn_me\n    End\n    When (c2x(left(data_line,4)) = \"03000000\") Then Do\n      Parse Var data_line,\n        control_word    +4       /* 03000000 */ ,\n        reserved_1      +4       /* FF000000 */ ,\n        reserved_2      +4       /* 8F000000 */ ,\n        reserved_3      +4       /* 04000000 */ ,\n        reserved_4      +4       /* 0008C170 */ ,\n        cc_beg          +2       /* 0000     */ ,\n        hh_beg          +2       /*     0000 */ ,\n        cc_hh_ctr       +4       /* 0000007E */ ,\n        reserved_7      +4       /* 00FF7F00 */ ,\n        reserved_8      +4       /* 0008C170 */ ,\n        reserved_9      +4       /* 0000007F */ ,\n        reserved_10     +4       /* 000000FD */ ,\n        reserved_11     +4       /* 00FF7F00 */ ,\n        reserved_12     +4       /* 0008C170 */ ,\n        reserved_13     +4       /* 000000FE */ ,\n        reserved_14     +4       /* 000000FF */ ,\n        reserved_15     +4       /* FF020000 */ ,\n        reserved_16     +212     /* ???????? */ ,\n      warn_me\n    End\n    When (c2x(left(data_line,4)) = \"04000000\") Then Do\n      Parse Var data_line,\n        control_word    +4       /* 04000000 */ ,\n        reserved_1      +4       /* FF000000 */ ,\n        reserved_2      +4       /* 8F000000 */ ,\n        reserved_3      +4       /* 04000000 */ ,\n        reserved_4      +4       /* 0008C170 */ ,\n        cc_beg          +2       /* 0000     */ ,\n        hh_beg          +2       /*     0000 */ ,\n        cc_hh_ctr       +4       /* 0000007E */ ,\n        reserved_7      +4       /* 00FF7F00 */ ,\n        reserved_8      +4       /* 0008C170 */ ,\n        reserved_9      +4       /* 0000007F */ ,\n        reserved_10     +4       /* 000000FD */ ,\n        reserved_11     +4       /* 00FF7F00 */ ,\n        reserved_12     +4       /* 0008C170 */ ,\n        reserved_13     +4       /* 000000FE */ ,\n        reserved_14     +4       /* 000000FF */ ,\n        reserved_15     +4       /* FF020000 */ ,\n        reserved_16     +212     /* ???????? */ ,\n      warn_me\n    End\n    Otherwise Do\n      control_word = left(data_line,4)\n      cc_beg = '0000'x\n      hh_beg = '0000'x\n    End\n  End\n\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"Control\"\n  INFOVAL = C2X(control_word)\n  Address ISPEXEC \"TBAdd infotabl\"\n  hex_cc_beg = c2x(cc_beg)\n  hex_hh_beg = c2x(hh_beg)\n  /*\n  dec_cc_beg = c2d(cc_beg)\n  dec_hh_beg = c2d(hh_beg)\n  */\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"cchh\"\n  INFOVAL = hex_cc_beg||hex_hh_beg\n  Address ISPEXEC \"TBAdd infotabl\"\n  If (warn_me <> \"\") Then Do\n    Address ISPEXEC \"TBVCLEAR infotabl\"\n    INFOKEY = \"Warn Me\"\n    INFOVAL = c2x(warn_me)\n    Address ISPEXEC \"TBAdd infotabl\"\n  End\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n control records are made up of text units:\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_subtypes:\n  Do While next_byte < Length(buffer_data_ebcdic)\n    txtunit_key = c2x(SubStr(buffer_data_ebcdic,next_byte,2))\n    next_byte = next_byte + 2\n    txtunit_qty = c2d(SubStr(buffer_data_ebcdic,next_byte,2))\n    next_byte = next_byte + 2\n    Select\n      When txtunit_key = '0001' Then Call idtf_parse_INMDDNAM\n      When txtunit_key = '0002' Then Call idtf_parse_INMDSNAM\n      When txtunit_key = '0003' Then Call idtf_parse_INMMEMBR\n      When txtunit_key = '000B' Then Call idtf_parse_INMSECND\n      When txtunit_key = '000C' Then Call idtf_parse_INMDIR\n      When txtunit_key = '0022' Then Call idtf_parse_INMEXPDT\n      When txtunit_key = '0028' Then Call idtf_parse_INMTERM\n      When txtunit_key = '0030' Then Call idtf_parse_INMBLKSZ\n      When txtunit_key = '003C' Then Call idtf_parse_INMDSORG\n      When txtunit_key = '0042' Then Call idtf_parse_INMLRECL\n      When txtunit_key = '0049' Then Call idtf_parse_INMRECFM\n      When txtunit_key = '1001' Then Call idtf_parse_INMTNODE\n      When txtunit_key = '1002' Then Call idtf_parse_INMTUID\n      When txtunit_key = '1011' Then Call idtf_parse_INMFNODE\n      When txtunit_key = '1012' Then Call idtf_parse_INMFUID\n      When txtunit_key = '1020' Then Call idtf_parse_INMLREF\n      When txtunit_key = '1021' Then Call idtf_parse_INMLCHG\n      When txtunit_key = '1022' Then Call idtf_parse_INMCREAT\n      When txtunit_key = '1023' Then Call idtf_parse_INMFVERS\n      When txtunit_key = '1024' Then Call idtf_parse_INMFTIME\n      When txtunit_key = '1025' Then Call idtf_parse_INMTTIME\n      When txtunit_key = '1026' Then Call idtf_parse_INMFACK\n      When txtunit_key = '1027' Then Call idtf_parse_INMERRCD\n      When txtunit_key = '1028' Then Call idtf_parse_INMUTILN\n      When txtunit_key = '1029' Then Call idtf_parse_INMUSERP\n      When txtunit_key = '102A' Then Call idtf_parse_INMRECCT\n      When txtunit_key = '102C' Then Call idtf_parse_INMSIZE\n      When txtunit_key = '102D' Then Call idtf_parse_INMFFM\n      When txtunit_key = '102F' Then Call idtf_parse_INMNUMF\n      When txtunit_key = '8012' Then Call idtf_parse_INMTYPE\n      When txtunit_key = '8018' Then Call idtf_parse_INMLSIZE\n      When txtunit_key = '8028' Then Call idtf_parse_INMEATTR\n      Otherwise Do\n        Address ISPEXEC \"TBVCLEAR infotabl\"\n        INFOKEY = \"??ERROR??\"\n        INFOVAL = txtunit_key \"in SG(\"segment_counter\")\" ,\n          C2X(SubStr(buffer_data_ebcdic,next_byte,20))\n        Address ISPEXEC \"TBAdd infotabl\"\n      End\n    End\n  End\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n DDNAME\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMDDNAM:\n  Do txx = 1 to txtunit_qty\n    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))\n    next_byte = next_byte + 2\n    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)\n    txtunit_INMDDNAM.control_key = ,\n      txtunit_INMDDNAM.control_key\"\"txtunit_char\" \"\n    next_byte = next_byte + txtunit_len\n  End\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"0001 INMDDNAM\"\n  INFOVAL = txtunit_INMDDNAM.control_key\n  Address ISPEXEC \"TBAdd infotabl\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Dataset name\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMDSNAM:\n  full_dsname = \"\"\n  Do txx = 1 to txtunit_qty\n    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))\n    next_byte = next_byte + 2\n    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)\n    full_dsname = full_dsname\"\"txtunit_char\".\"\n    next_byte = next_byte + txtunit_len\n  End\n  full_dsname = strip(full_dsname,\"B\",\".\")\n  txtunit_INMDSNAM.control_key = ,\n    txtunit_INMDSNAM.control_key\"\"full_dsname\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"0002 INMDSNAM\"\n  INFOVAL = txtunit_INMDSNAM.control_key\n  Address ISPEXEC \"TBAdd infotabl\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Select member names\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMMEMBR:\n  Do txx = 1 to txtunit_qty\n    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))\n    next_byte = next_byte + 2\n    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)\n    txtunit_INMMEMBR.control_key = ,\n      txtunit_INMMEMBR.control_key||txtunit_char\" \"\n    next_byte = next_byte + txtunit_len\n  End\n  txtunit_INMMEMBR.control_key = ,\n    Strip(txtunit_INMMEMBR.control_key,\"T\",\" \")\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"0003 INMMEMBR\"\n  INFOVAL = txtunit_INMMEMBR.control_key\n  Address ISPEXEC \"TBAdd infotabl\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Secondary space\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMSECND:\n  Do txx = 1 to txtunit_qty\n    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))\n    next_byte = next_byte + 2\n    txtunit_char = c2d(SubStr(buffer_data_ebcdic,next_byte,txtunit_len))\n    txtunit_INMSECND.control_key = ,\n      txtunit_INMSECND.control_key\"\"txtunit_char\" \"\n    next_byte = next_byte + txtunit_len\n  End\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"000B INMSECND\"\n  INFOVAL = txtunit_INMSECND.control_key\n  Address ISPEXEC \"TBAdd infotabl\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Number of directory blocks for PDS\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMDIR:\n  Do txx = 1 to txtunit_qty\n    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))\n    next_byte = next_byte + 2\n    txtunit_char = c2d(SubStr(buffer_data_ebcdic,next_byte,txtunit_len))\n    txtunit_INMDIR.control_key = ,\n      txtunit_INMDIR.control_key\"\"txtunit_char\" \"\n    next_byte = next_byte + txtunit_len\n  End\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"000C INMDIR\"\n  INFOVAL = txtunit_INMDIR.control_key\n  Address ISPEXEC \"TBAdd infotabl\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Expiration date\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMEXPDT:\n  Do txx = 1 to txtunit_qty\n    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))\n    next_byte = next_byte + 2\n    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)\n    txtunit_INMEXPDT.control_key = ,\n      txtunit_INMEXPDT.control_key\"\"txtunit_char\" \"\n    next_byte = next_byte + txtunit_len\n  End\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"0022 INMEXPDT\"\n  INFOVAL = txtunit_INMEXPDT.control_key\n  Address ISPEXEC \"TBAdd infotabl\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Was input taken from the terminal (message).\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMTERM:\n  txtunit_INMTERM.control_key = ,\n    txtunit_INMTERM.control_key\"Y\"\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"0028 INMTERM\"\n  INFOVAL = txtunit_INMTERM.control_key\n  Address ISPEXEC \"TBAdd infotabl\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Block size\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMBLKSZ:\n  Do txx = 1 to txtunit_qty\n    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))\n    next_byte = next_byte + 2\n    txtunit_char = c2d(SubStr(buffer_data_ebcdic,next_byte,txtunit_len))\n    txtunit_INMBLKSZ.control_key = ,\n      txtunit_INMBLKSZ.control_key\"\"txtunit_char\" \"\n    next_byte = next_byte + txtunit_len\n  End\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"0030 INMBLKSZ\"\n  INFOVAL = txtunit_INMBLKSZ.control_key\n  Address ISPEXEC \"TBAdd infotabl\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Dataset organization\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMDSORG:\n  Do txx = 1 to txtunit_qty\n    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))\n    next_byte = next_byte + 2\n    txtunit_char = c2x(SubStr(buffer_data_ebcdic,next_byte,txtunit_len))\n    dsorg   = idtf_parse_INMDSORG_meaning(txtunit_char)\n    txtunit_INMDSORG.control_key = ,\n      txtunit_INMDSORG.control_key\"\"dsorg\" \"\n    next_byte = next_byte + txtunit_len\n  End\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"003C INMDSORG\"\n  INFOVAL = txtunit_INMDSORG.control_key\n  Address ISPEXEC \"TBAdd infotabl\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n convert dsorg to displayable meaning\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMDSORG_meaning: Procedure\n  Parse Arg hex_dsorg\n  Select\n    When hex_dsorg = \"0200\" Then real_dsorg = \"PO\"\n    When hex_dsorg = \"4000\" Then real_dsorg = \"PS\"\n    When hex_dsorg = \"0008\" Then real_dsorg = \"VSAM\"  /* Did this ever work? */\n    When hex_dsorg = \"0000\" Then real_dsorg = \"U\"        /* Obsolete */\n    When hex_dsorg = \"2000\" Then real_dsorg = \"DA\"       /* Obsolete */\n    When hex_dsorg = \"8000\" Then real_dsorg = \"ISAM\"     /* Obsolete */\n    Otherwise Do\n      real_dsorg = \"NONE\"\n    End\n  End\n  Return real_dsorg\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n logical record length\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMLRECL:\n  Do txx = 1 to txtunit_qty\n    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))\n    next_byte = next_byte + 2\n    txtunit_char = c2d(SubStr(buffer_data_ebcdic,next_byte,txtunit_len))\n    txtunit_INMLRECL.control_key = ,\n      txtunit_INMLRECL.control_key\"\"txtunit_char\" \"\n    next_byte = next_byte + txtunit_len\n  End\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"0042 INMLRECL\"\n  INFOVAL = txtunit_INMLRECL.control_key\n  Address ISPEXEC \"TBAdd infotabl\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n record format\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMRECFM:\n  Do txx = 1 to txtunit_qty\n    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))\n    next_byte = next_byte + 2\n    txtunit_char = c2x(SubStr(buffer_data_ebcdic,next_byte,txtunit_len))\n    recfm = idtf_parse_INMRECFM_meaning(txtunit_char)\n    txtunit_INMRECFM.control_key = ,\n      txtunit_INMRECFM.control_key\"\"recfm\" \"\n    next_byte = next_byte + txtunit_len\n  End\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"0049 INMRECFM\"\n  INFOVAL = txtunit_INMRECFM.control_key\n  Address ISPEXEC \"TBAdd infotabl\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n convert record format to displayable meaning\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMRECFM_meaning: Procedure\n  Parse Arg hex_recfm\n  real_recfm = \"\"\n  If (BitAnd(hex_recfm,\"0001\") = \"0001\") Then Do\n    real_recfm = real_recfm\"SVBS\"\n  End\n  If (BitAnd(Right(hex_recfm,2),\"02\") = \"02\") Then Do\n    real_recfm = real_recfm\"+noRDW\"\n  End\n  If (BitAnd(hex_recfm,\"C000\") = \"C000\") Then Do\n    real_recfm = real_recfm\"U\"\n  End\n  If (BitAnd(hex_recfm,\"4000\") = \"4000\") Then Do\n    real_recfm = real_recfm\"V\"\n  End\n  If (BitAnd(hex_recfm,\"8000\") = \"8000\") Then Do\n    real_recfm = real_recfm\"F\"\n  End\n  If (BitAnd(hex_recfm,\"1000\") = \"1000\") Then Do\n    real_recfm = real_recfm\"B\"\n  End\n  If (BitAnd(hex_recfm,\"2000\") = \"2000\") Then Do\n    real_recfm = real_recfm\"T\"\n  End\n  If (BitAnd(hex_recfm,\"0800\") = \"0800\") Then Do\n    real_recfm = real_recfm\"S\"\n  End\n  If (BitAnd(hex_recfm,\"0200\") = \"0200\") Then Do\n    real_recfm = real_recfm\"M\"\n  End\n  If (BitAnd(hex_recfm,\"0400\") = \"0400\") Then Do\n    real_recfm = real_recfm\"A\"\n  End\n  Return real_recfm\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n to node\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMTNODE:\n  Do txx = 1 to txtunit_qty\n    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))\n    next_byte = next_byte + 2\n    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)\n    txtunit_INMTNODE.control_key = ,\n      txtunit_INMTNODE.control_key\"\"txtunit_char\" \"\n    next_byte = next_byte + txtunit_len\n  End\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"1001 INMTNODE\"\n  INFOVAL = txtunit_INMTNODE.control_key\n  Address ISPEXEC \"TBAdd infotabl\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n to userid\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMTUID:\n  Do txx = 1 to txtunit_qty\n    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))\n    next_byte = next_byte + 2\n    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)\n    txtunit_INMTUID.control_key = ,\n      txtunit_INMTUID.control_key\"\"txtunit_char\" \"\n    next_byte = next_byte + txtunit_len\n  End\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"1002 INMTUID\"\n  INFOVAL = txtunit_INMTUID.control_key\n  Address ISPEXEC \"TBAdd infotabl\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n from node\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMFNODE:\n  Do txx = 1 to txtunit_qty\n    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))\n    next_byte = next_byte + 2\n    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)\n    txtunit_INMFNODE.control_key = ,\n      txtunit_INMFNODE.control_key\"\"txtunit_char\" \"\n    next_byte = next_byte + txtunit_len\n  End\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"1011 INMFNODE\"\n  INFOVAL = txtunit_INMFNODE.control_key\n  Address ISPEXEC \"TBAdd infotabl\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n from userid\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMFUID:\n  Do txx = 1 to txtunit_qty\n    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))\n    next_byte = next_byte + 2\n    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)\n    txtunit_INMFUID.control_key = ,\n      txtunit_INMFUID.control_key\"\"txtunit_char\" \"\n    next_byte = next_byte + txtunit_len\n  End\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"1012 INMFUID\"\n  INFOVAL = txtunit_INMFUID.control_key\n  Address ISPEXEC \"TBAdd infotabl\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n last reference date\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMLREF:\n  Do txx = 1 to txtunit_qty\n    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))\n    next_byte = next_byte + 2\n    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)\n    formatted_date = idtf_format_timestamp(txtunit_char)\n    txtunit_INMLREF.control_key = ,\n      txtunit_INMLREF.control_key\"\"formatted_date\" \"\n    next_byte = next_byte + txtunit_len\n  End\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"1020 INMLREF\"\n  INFOVAL = txtunit_INMLREF.control_key\n  Address ISPEXEC \"TBAdd infotabl\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n last change date\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMLCHG:\n  Do txx = 1 to txtunit_qty\n    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))\n    next_byte = next_byte + 2\n    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)\n    formatted_date = idtf_format_timestamp(txtunit_char)\n    txtunit_INMLCHG.control_key = ,\n      txtunit_INMLCHG.control_key\"\"formatted_date\" \"\n    next_byte = next_byte + txtunit_len\n  End\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"1021 INMLCHG\"\n  INFOVAL = txtunit_INMLCHG.control_key\n  Address ISPEXEC \"TBAdd infotabl\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n creation date\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMCREAT:\n  Do txx = 1 to txtunit_qty\n    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))\n    next_byte = next_byte + 2\n    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)\n    txtunit_INMCREAT.control_key = ,\n      txtunit_INMCREAT.control_key\"\"txtunit_char\" \"\n    next_byte = next_byte + txtunit_len\n    rpt = rpt txtunit_char\n  End\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"1022 INMCREAT\"\n  INFOVAL = txtunit_INMCREAT.control_key\n  Address ISPEXEC \"TBAdd infotabl\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n version\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMFVERS:\n  Do txx = 1 to txtunit_qty\n    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))\n    next_byte = next_byte + 2\n    txtunit_char = c2d(SubStr(buffer_data_ebcdic,next_byte,txtunit_len))\n    txtunit_INMFVERS.control_key = ,\n      txtunit_INMFVERS.control_key\"\"txtunit_char\" \"\n    next_byte = next_byte + txtunit_len\n  End\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"1023 INMFVERS\"\n  INFOVAL = txtunit_INMFVERS.control_key\n  Address ISPEXEC \"TBAdd infotabl\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n modified time\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMFTIME:\n  Do txx = 1 to txtunit_qty\n    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))\n    next_byte = next_byte + 2\n    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)\n    formatted_date = idtf_format_timestamp(txtunit_char)\n    txtunit_INMFTIME.control_key = ,\n      txtunit_INMFTIME.control_key\"\"formatted_date\" \"\n    next_byte = next_byte + txtunit_len\n  End\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"1024 INMFTIME\"\n  INFOVAL = txtunit_INMFTIME.control_key\n  Address ISPEXEC \"TBAdd infotabl\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n transmit time\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMTTIME:\n  Do txx = 1 to txtunit_qty\n    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))\n    next_byte = next_byte + 2\n    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)\n    formatted_date = idtf_format_timestamp(txtunit_char)\n    txtunit_INMTTIME.control_key = ,\n      txtunit_INMTTIME.control_key\"\"formatted_date\" \"\n    next_byte = next_byte + txtunit_len\n  End\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"1025 INMTTIME\"\n  INFOVAL = txtunit_INMTTIME.control_key\n  Address ISPEXEC \"TBAdd infotabl\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n acknowledgement\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMFACK:\n  txtunit_INMFACK.control_key = ,\n    txtunit_INMFACK.control_key\"Y\"\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"1026 INMFACK\"\n  INFOVAL = txtunit_INMFACK.control_key\n  Address ISPEXEC \"TBAdd infotabl\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n error return code\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMERRCD:\n  Do txx = 1 to txtunit_qty\n    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))\n    next_byte = next_byte + 2\n    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)\n    txtunit_INMERRCD.control_key = ,\n      txtunit_INMERRCD.control_key\"\"txtunit_char\" \"\n    next_byte = next_byte + txtunit_len\n  End\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"1027 INMERRCD\"\n  INFOVAL = txtunit_INMERRCD.control_key\n  Address ISPEXEC \"TBAdd infotabl\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n utility program name\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMUTILN:\n  Do txx = 1 to txtunit_qty\n    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))\n    next_byte = next_byte + 2\n    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)\n    txtunit_INMUTILN.control_key = ,\n      txtunit_INMUTILN.control_key\"\"txtunit_char\" \"\n    next_byte = next_byte + txtunit_len\n  End\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"1028 INMUTILN\"\n  INFOVAL = txtunit_INMUTILN.control_key\n  Address ISPEXEC \"TBAdd infotabl\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n user parameters passed to exits\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMUSERP:\n  Do txx = 1 to txtunit_qty\n    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))\n    next_byte = next_byte + 2\n    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)\n    txtunit_INMUSERP.control_key = ,\n      txtunit_INMUSERP.control_key\"\"txtunit_char\" \"\n    next_byte = next_byte + txtunit_len\n  End\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"1029 INMUSERP\"\n  INFOVAL = txtunit_INMUSERP.control_key\n  Address ISPEXEC \"TBAdd infotabl\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n record count\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMRECCT:\n  Do txx = 1 to txtunit_qty\n    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))\n    next_byte = next_byte + 2\n    txtunit_char = c2d(SubStr(buffer_data_ebcdic,next_byte,txtunit_len))\n    txtunit_INMRECCT.control_key = ,\n      txtunit_INMRECCT.control_key\"\"txtunit_char\" \"\n    next_byte = next_byte + txtunit_len\n  End\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"102A INMRECCT\"\n  INFOVAL = txtunit_INMRECCT.control_key\n  Address ISPEXEC \"TBAdd infotabl\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n file size\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMSIZE:\n  Do txx = 1 to txtunit_qty\n    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))\n    next_byte = next_byte + 2\n    txtunit_char = c2d(SubStr(buffer_data_ebcdic,next_byte,txtunit_len))\n    txtunit_INMSIZE.control_key = ,\n      txtunit_INMSIZE.control_key\"\"txtunit_char\" \"\n    next_byte = next_byte + txtunit_len\n  End\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"102C INMSIZE\"\n  INFOVAL = txtunit_INMSIZE.control_key\n  Address ISPEXEC \"TBAdd infotabl\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n cms file mode\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMFFM:\n  Do txx = 1 to txtunit_qty\n    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))\n    next_byte = next_byte + 2\n    txtunit_char = SubStr(buffer_data_ebcdic,next_byte,txtunit_len)\n    txtunit_INMFFM.control_key = ,\n      txtunit_INMFFM.control_key\"\"txtunit_char\" \"\n    next_byte = next_byte + txtunit_len\n  End\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"102D INMFFM\"\n  INFOVAL = txtunit_INMFFM.control_key\n  Address ISPEXEC \"TBAdd infotabl\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n number of files\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMNUMF:\n  Do txx = 1 to txtunit_qty\n    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))\n    next_byte = next_byte + 2\n    txtunit_char = c2d(SubStr(buffer_data_ebcdic,next_byte,txtunit_len))\n    txtunit_INMNUMF.control_key = ,\n      txtunit_INMNUMF.control_key\"\"txtunit_char\" \"\n    next_byte = next_byte + txtunit_len\n  End\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"102F INMNUMF\"\n  INFOVAL = txtunit_INMNUMF.control_key\n  Address ISPEXEC \"TBAdd infotabl\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n type of data set\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMTYPE:\n  Do txx = 1 to txtunit_qty\n    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))\n    next_byte = next_byte + 2\n    txtunit_char = c2x(SubStr(buffer_data_ebcdic,next_byte,txtunit_len))\n    dstype = idtf_parse_INMEATTR_meaning(txtunit_char)\n    txtunit_INMTYPE.control_key = ,\n      txtunit_INMTYPE.control_key\"\"dstype\" \"\n    next_byte = next_byte + txtunit_len\n  End\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"8012 INMTYPE\"\n  INFOVAL = txtunit_INMTYPE.control_key\n  Address ISPEXEC \"TBAdd infotabl\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Data set size in megabytes\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMLSIZE:\n  Do txx = 1 to txtunit_qty\n    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))\n    next_byte = next_byte + 2\n    txtunit_char = c2x(SubStr(buffer_data_ebcdic,next_byte,txtunit_len))\n    dstype = c2d(txtunit_char)  /* was idtf_parse_INMEATTR_meaning() */\n    txtunit_INMLSIZE.control_key = ,\n      txtunit_INMLSIZE.control_key\"\"dstype\" \"\n    next_byte = next_byte + txtunit_len\n  End\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"8018 INMLSIZE\"\n  INFOVAL = txtunit_INMLSIZE.control_key\n  Address ISPEXEC \"TBAdd infotabl\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Extended attribute status\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMEATTR:\n  Do txx = 1 to txtunit_qty\n    txtunit_len = c2d(SubStr(buffer_data_ebcdic,next_byte,2))\n    next_byte = next_byte + 2\n    txtunit_char = c2x(SubStr(buffer_data_ebcdic,next_byte,txtunit_len))\n    dstype = c2x(txtunit_char) /* was idtf_parse_INMEATTR_meaning */\n    txtunit_INMEATTR.control_key = ,\n      txtunit_INMEATTR.control_key\"\"dstype\" \"\n    next_byte = next_byte + txtunit_len\n  End\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"8028 INMEATTR\"\n  INFOVAL = txtunit_INMEATTR.control_key\n  Address ISPEXEC \"TBAdd infotabl\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n convert type of data set to displayable meaning\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_parse_INMEATTR_meaning: Procedure\n  Parse Arg dstype\n  Select\n    When (dstype = \"80\") Then real_dstype = \"Data Library\"\n    When (dstype = \"40\") Then real_dstype = \"Program Library\"\n    When (dstype = \"00\") Then real_dstype = \"No Library\"\n    Otherwise Do\n      real_dstype = \"Unknown-\"dstype\n    End\n  End\n  Return real_dstype\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n convert date to displayable meaning\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_format_timestamp: Procedure\n  Parse Arg pdate\n  pdate_yr = SubStr(pdate,1,4)\n  pdate_mm = SubStr(pdate,5,2)\n  pdate_dy = SubStr(pdate,7,2)\n  pdate_hr = SubStr(pdate,9,2)\n  pdate_mn = SubStr(pdate,11,2)\n  pdate_sc = SubStr(pdate,13,2)\n  ddate = pdate_yr'-'pdate_mm'-'pdate_dy,\n    pdate_hr\":\"pdate_mn\":\"pdate_sc\n  Return ddate\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n In this routine we build stem variables for character translations\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nidtf_array_creation:\n  crfile_number = 0\n  cr_last_number = 0\n  control_counter. = 0\n  inm_idx = 1\n  not_sure = 0\n  alias_created. = \"\"\n  output_progress = 0\n  txtunit_INMDDNAM. = \"\"\n  txtunit_INMDSNAM. = \"\"\n  txtunit_INMMEMBR. = \"\"\n  txtunit_INMSECND. = \"\"\n  txtunit_INMDIR.    = \"\"\n  txtunit_INMEXPDT. = \"\"\n  txtunit_INMTERM.   = \"\"\n  txtunit_INMBLKSZ. = \"\"\n  txtunit_INMDSORG. = \"\"\n  txtunit_INMLRECL. = \"\"\n  txtunit_INMRECFM. = \"\"\n  txtunit_INMTNODE. = \"\"\n  txtunit_INMTUID.   = \"\"\n  txtunit_INMFNODE. = \"\"\n  txtunit_INMFUID.   = \"\"\n  txtunit_INMLREF.   = \"\"\n  txtunit_INMLCHG.   = \"\"\n  txtunit_INMCREAT. = \"\"\n  txtunit_INMFVERS. = \"\"\n  txtunit_INMFTIME. = \"\"\n  txtunit_INMTTIME. = \"\"\n  txtunit_INMFACK.   = \"\"\n  txtunit_INMERRCD. = \"\"\n  txtunit_INMUTILN. = \"\"\n  txtunit_INMUSERP. = \"\"\n  txtunit_INMRECCT. = \"\"\n  txtunit_INMSIZE.   = \"\"\n  txtunit_INMFFM.    = \"\"\n  txtunit_INMNUMF.   = \"\"\n  txtunit_INMTYPE.   = \"\"\n\n  dasd_model. = \"Custom\"\n  dasd_model.01.200   = \"2311 no-alt\"\n  dasd_model.01.203   = \"2311\"\n  dasd_model.02.0     = \"2301\"\n  dasd_model.04.0     = \"2302\"\n  dasd_model.04.1440  = \"9345-1\"\n  dasd_model.04.2156  = \"9345-2\"\n  dasd_model.03.0     = \"2303\"\n  dasd_model.05.0     = \"2321\"\n  dasd_model.06.48    = \"2305-1 no-alt\"\n  dasd_model.06.54    = \"2305-1\"\n  dasd_model.07.96    = \"2305-2 no-alt\"\n  dasd_model.07.108   = \"2305-2\"\n  dasd_model.08.200   = \"2314 no-alt\"\n  dasd_model.08.203   = \"2314\"\n  dasd_model.09.404   = \"3330-1 no-alt\"\n  dasd_model.09.411   = \"3330-1\"\n  dasd_model.0A.808   = \"3330-11 no-alt\"\n  dasd_model.0A.815   = \"3330-11\"\n  dasd_model.0B.348   = \"3340-35 no-alt\"\n  dasd_model.0B.360   = \"3340-35\"\n  dasd_model.0B.696   = \"3340-70 no-alt\"\n  dasd_model.0B.708   = \"3340-70\"\n  dasd_model.0C.555   = \"3350 no-alt\"\n  dasd_model.0C.560   = \"3350\"\n  dasd_model.0D.959   = \"3375 no-alt\"\n  dasd_model.0D.960   = \"3375\"\n  dasd_model.0E.885   = \"3380-A/B/D/J no-alt\"\n  dasd_model.0E.886   = \"3380-A/B/D/J\"\n  dasd_model.0E.1770  = \"3380-E no-alt\"\n  dasd_model.0E.1772  = \"3380-E\"\n  dasd_model.0E.2655  = \"3380-K no-alt\"\n  dasd_model.0E.2658  = \"3380-K\"\n  dasd_model.0E.3339  = \"3380-Custom\"\n  dasd_model.0E.3339  = \"EMC3380-K no-alt\"\n  dasd_model.0E.3342  = \"EMC3380-K\"\n  dasd_model.0E.3993  = \"EMC3380-KK no-alt\"\n  dasd_model.0E.3996  = \"EMC3380-KK\"\n  dasd_model.0F.1113  = \"3390-1 no-alt\"\n  dasd_model.0F.1114  = \"3390-1\"\n  dasd_model.0F.2226  = \"3390-2 no-alt\"\n  dasd_model.0F.2227  = \"3390-2\"\n  dasd_model.0F.3339  = \"3390-3 no-alt\"\n  dasd_model.0F.3340  = \"3390-3\"\n  dasd_model.0F.10017 = \"3390-9 no-alt\"\n  dasd_model.0F.10020 = \"3390-9\"\n  dasd_model.0F.32760 = \"3390-27 no-alt\"\n  dasd_model.0F.32763 = \"3390-27\"\n  dasd_model.0F.65520 = \"3390-54 no-alt\"\n  dasd_model.0F.65523 = \"3390-54\"\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Return from which line this was called from.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nget_my_sigl: Return sigl\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n More than just rounding.\n   Floor always goes down to a multiple of height.\n   Ceiling always goes up to a multiple of height.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nFloor_rtn: Procedure\n  Parse Arg @number, @height\n  @occurs = (@number % @height)\n  Select\n    When (@remainder = 0) Then @adjustment = 0\n    When (@number < 0) Then @adjustment = -1\n    Otherwise Do\n      @adjustment = 0\n    End\n  End\n  @result = (@occurs + @adjustment) * @height\n  return @result\n\nCeiling_rtn: Procedure\n  Parse Arg @number, @height\n  @occurs = @number % @height\n  @remainder = @number - (@occurs * @height)\n  Select\n    When (@remainder = 0) Then @adjustment = 0\n    When (@number > 0) Then @adjustment = 1\n    Otherwise Do\n      @adjustment = 0\n    End\n  End\n  @result = (@occurs + @adjustment) * @height\n  return @result\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n Set the short message to press a help PFKey.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\ntrapped_an_error:\n  Signal Off Error\n  Signal Off Failure\n  Signal Off Syntax\n  error_line = Sigl\n  Address ISPEXEC \"TBVCLEAR infotabl\"\n  INFOKEY = \"!ERR!\"\n  INFOVAL = \"On or near\" error_line\":\"Sourceline(error_line)\n  Address ISPEXEC \"TBAdd infotabl\"\n  ZERRSM = ask_to_get_help()\n  ZERRLM = ZERRLM || ,\n    Left(\"Bad IDTF data set - truncated?\",79)\n  Address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n  interpret \"call\" back_here\n  Return\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n__DATA__\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n\n  SA22-7783-07 z/OS TSO/E Customization\n  Chapter 37. Customizing TRANSMIT and RECEIVE\n\n  Text Units and Text Unit Pointer Lists\n  --------------------------------------\n  Types of text units\n  -------------------\n  Key  Field    Max Description\n  0030 INMBLKSZ    8 Block size\n  1022 INMCREAT    8 Creation date GMT\n  0001 INMDDNAM    8 DDNAME for the file\n  000C INMDIR      8 Number of directory blocks\n  0002 INMDSNAM 22*8 Name of the file\n                  44 In MVS: # of fields max 22 at up to 8 bytes per\n                  16 In CMS: 8b8b2 INMFFM holds filemode number\n  003C INMDSORG    2 File organization\n                     X'0008' for VSAM\n                     X'0200' for partitioned organization\n                     X'4000' for physical sequential\n  1027 INMERRCD    8 RECEIVE command error code\n  0022 INMEXPDT    8 Expiration date GMT\n  1026 INMFACK    64 Originator requested notification\n  102D INMFFM      1 Filemode number for CMS\n  1011 INMFNODE    8 Origin node name or node number\n  1024 INMFTIME    8 Origin timestamp\n  1012 INMFUID     7 Origin user ID\n  1023 INMFVERS    8 Origin version number of the data format\n  1021 INMLCHG     8 Date last changed GMT\n  0042 INMLRECL    8 Logical record length\n  1020 INMLREF     8 Date last referenced GMT\n  0003 INMMEMBR  x*8 Member name list\n  102F INMNUMF     8 Number of files transmitted\n  102A INMRECCT    8 Transmitted record count\n  0049 INMRECFM    2 Record format\n                     X'0001' Shortened VBS format used for transmission\n                     X'xx02' Varying length records without the RDW\n                     X'0200' Data includes machine code printer CC\n                     X'0400' Data contains ASA printer CC\n                     X'0800' Standard fixed or spanned variable records\n                     X'1000' Blocked records\n                     X'2000' Track overflow or variable ASCII records\n                     X'4000' Variable-length records\n                     X'8000' Fixed-length records\n                     X'C000' Undefined records\n  000B INMSECND    3 Secondary space quantity\n  102C INMSIZE     8 File size in bytes\n  0028 INMTERM     0 Data transmitted as a message\n  1001 INMTNODE    8 Target node name or node number\n  1025 INMTTIME    8 Destination timestamp\n  1002 INMTUID     7 Target user ID\n  8012 INMTYPE     1 Data set type\n                     X'80' Data library\n                     X'40' Program library\n                     X'04' extended-format sequential data sets\n                     X'01' large format sequential data sets\n                     X'00' Assume no library\n  1029 INMUSERP  251 User parameter string\n  1028 INMUTILN    8 Name of utility program\n                     INMCOPY  - Convert to sequential\n                     IEBCOPY  - Invoke IEBCOPY to reload PDS\n                     AMSCIPHR - AMD for VSAM\n  8018 INMLSIZE    4 Size in MB up to 4096 TB  (new with z/OS 1.9)\n  8028 INMEATTR    1 Extended attribute status (new with z/OS 1.11)\n                     X'00' Unspecified\n                     X'01' NO\n                     X'02' OPT\n\n  Format of transmitted data\n  --------------------------\n  Segemented into 255 bytes\n    1   (+1) segment length\n    2   (+1) segment descriptor flag\n             X'E0' Entire control record             '80'x+'40'x+'20'x\n             X'C0' Entire data record                '80'x+'40'x\n             X'A0' First segment of control record   '80'x+      '20'x\n             X'80' First segment of data record.     '80'x\n             X'60' Last segment of control record.         '40'x+'20'x\n             X'40' Last segment of original record.        '40'x\n             X'20' Middle of a control record.                   '20'x\n             X'10' This is record number of next record.\n             X'0F' Reserved\n             X'00' Middle of a data record.\n    3 (+253) segment data\n\n  control record formats\n  ----------------------\n  INMR01 -- header record - Always 1st, only 1\n  -----------------------\n                   6 INMR02\n  REQUIRED:\n  1011 INMFNODE    8 Origin node name or node number\n  1024 INMFTIME    8 Origin timestamp\n  1012 INMFUID     7 Origin user ID\n  0042 INMLRECL    8 Logical record length\n  1001 INMTNODE    8 Target node name or node number\n  1002 INMTUID     7 Target user ID\n  OPTIONAL:\n  1026 INMFACK    64 Originator requested notification\n  1023 INMFVERS    8 Origin version number of the data format\n  102F INMNUMF     8 Number of files transmitted\n  1029 INMUSERP  251 User parameter string\n\n  INMR02 -- file utility control record 1 or more in reverse order\n  -------------------------------------\n                   6 INMR02\n                   4 Number of the file\n  REQUIRED:\n  003C INMDSORG    2 File organization\n  0042 INMLRECL    8 Logical record length\n  0049 INMRECFM    2 Record format\n  102C INMSIZE     8 File size in bytes\n  1028 INMUTILN    8 Name of utility program\n                     INMCOPY  - Convert to sequential\n                     IEBCOPY  - Invoke IEBCOPY to reload PDS\n                     AMSCIPHR - AMD for VSAM\n  OPTIONAL:\n  0030 INMBLKSZ    8 Block size\n  1022 INMCREAT    8 Creation date GMT\n  000C INMDIR      8 Number of directory blocks\n  0002 INMDSNAM 22*8 Name of the file\n  0022 INMEXPDT    8 Expiration date GMT\n  102D INMFFM      1 Filemode number for CMS\n  1021 INMLCHG     8 Date last changed GMT\n  1020 INMLREF     8 Date last referenced GMT\n  0003 INMMEMBR  x*8 Member name list\n  0028 INMTERM     0 Data transmitted as a message\n  1029 INMUSERP  251 User parameter string\n\n  INMR03 -- data control record immediately precedes data\n  -----------------------------\n                   6 INMR03\n  REQUIRED:\n  003C INMDSORG    2 File organization\n  0042 INMLRECL    8 Logical record length\n  0049 INMRECFM    2 Record format\n  102C INMSIZE     8 File size in bytes\n\n  INMR04 -- user control record  anywhere in the control records\n  -----------------------------\n                   6 INMR04\n  REQUIRED:\n  1029 INMUSERP  251 User parameter string\n\n  INMR06 -- trailer control record always last\n  --------------------------------\n                   6 INMR06\n\n  INMR07 -- notification control record\n  -------------------------------------\n                   6 INMR07\n  REQUIRED:\n  1024 INMFTIME    8 Origin timestamp\n  0002 INMDSNAM 22*8 Name of the file\n   OR\n  0028 INMTERM     0 Data transmitted as a message\n  OPTIONAL:\n  1027 INMERRCD    8 RECEIVE command error code\n  1026 INMFACK    64 Originator requested notification\n  102D INMFFM      1 Filemode number for CMS\n  1029 INMUSERP  251 User parameter string\n\n\n  File data\n  ---------\n  Dependent on original file and DSORG.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n  Build array of dasd types and characteristics\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nset_dasdtype:\n/*                devt   trk_cyl   okey  nokey trk_cap  chr_trk  */\n  dasd_type.01 = \"2311        10      0     00       0     3625\"\n  dasd_type.02 = \"2301         0      0     00       0        0\"\n  dasd_type.03 = \"2303         0      0     00       0        0\"\n  dasd_type.04 = \"2302/9345    0      0     00       0        0\"\n  dasd_type.05 = \"2321         0      0     00       0        0\"\n  dasd_type.06 = \"2305-1       8    634    202   14568    14136\"\n  dasd_type.07 = \"2305-2       8    289     91   14858    14660\"\n  dasd_type.08 = \"2314        20    191     45    7294     7294\"\n  dasd_type.09 = \"3330-1      19    191     56   13165    13030\"\n  dasd_type.0A = \"3330-11     19    191     56   13165    13030\"\n  dasd_type.0B = \"3340        12    242     75    8535     8368\"\n  dasd_type.0C = \"3350        30    267     82   19254    19069\"\n  dasd_type.0D = \"3375        12    544    160   36000    35616\"\n  dasd_type.0E = \"3380        15    728    236   47968    47476\"\n  dasd_type.0F = \"3390        15      0      0   58786    56664\"\n  /*  Usage:\n\n      PRE 2305 devices are DRUMs and CELLs, so old I do not have\n      device geometry information for them.\n\n      9345 and 3390 okey and nokey are zero because there is a\n      complex formula required to determine how much space an\n      actual block takes.\n\n      Through trial and error I came up with the 3390 sector sizes\n      shown below. Fit your block size in the sector where it fits\n      and then determine how many sectors per track you get.\n\n      Otherwise, the trk_cap is how many bytes may be written on\n      a track. To your block size you add the overhead bytes. That\n      might be not-keyed or keyed. The only keyed dataset I recall\n      using was the MVS PASSWORD dataset. These tables are included\n      so the information does not get lost.\n\n  device_stats = dasd_type.hex_dasdtype\n  Parse Var device_stats,\n    dev_name,\n    dev_trk_cyl,\n    dev_phy_blk,\n    dev_blk_key,\n    dev_trk_cap,\n    dev_chr_trk,\n    .\n  hex_trk_cap = c2x(dev_trk_cap)\n  */\n  Return 0\n\nset_3390_sector_sizes:\n  bytes_per_sector = ,\n            \"56664 27998 18542 13682 10796 8906 7548 6518\",\n            \" 5726  5064  4566  4136  3768 3440 3174 2942\",\n            \" 2710  2546  2376  2212  2082 1946 1850 1748\",\n            \" 1646  1550  1482  1386  1318 1250 1182 1154\",\n            \" 1086  1018   984   950   888  854  820  786\",\n            \"  752   718   690   656   622  588  554  520\",\n            \"  486   458   424   390   356  322  288  254\",\n            \"  226   192   158   124    90   56   22\"\n  bytes_per_sector.0 = words(bytes_per_sector)\n  sectors_per_track = ,\n            \"    1     2     3     4     5    6    7    8\",\n            \"    9    10    11    12    13   14   15   16\",\n            \"   17    18    19    20    21   22   23   24\",\n            \"   25    26    27    28    29   30   31   32\",\n            \"   33    34    35    36    37   38   39   40\",\n            \"   41    42    43    44    45   46   48   49\",\n            \"   50    52    54    55    57   59   61   64\",\n            \"   66    69    72    75    78   82   86\"\n  sectors_per_track.0 = words(sectors_per_track)\n  Return\n\nset_3380_sector_sizes:\n/*\nBlocks per 3380 track for different (non-keyed) physical block sizes:\n\n     Blocksize Range       Records/Track        Records/Cylinder\n   ----------------------------------------------------------------\n     47,476 - 23,477             1                    15\n     23,476 - 15,477             2                    30\n     15,476 - 11,477             3                    45\n     11,476 -  9,077             4                    60\n      9,076 -  7,477             5                    75\n      7,476 -  6,357             6                    90\n      6,356 -  5,493             7                   105\n      5,492 -  4,821             8                   120\n      4,820 -  4,277             9                   135\n      4,276 -  3,861            10                   150\n      3,860 -  3,477            11                   165\n      3,476 -  3,189            12                   180\n      3,188 -  2,933            13                   195\n      2,932 -  2,677            14                   210\n      2,676 -  2,485            15                   225\n      2,484 -  2,325            16                   240\n      2,324 -  2,165            17                   255\n      2,164 -  2,005            18                   270\n      2,004 -  1,877            19                   285\n      1,877 -  1,781            20                   300\n      1,780 -  1,685            21                   315\n      1,684 -  1,589            22                   330\n      1,588 -  1,493            23                   345\n      1,492 -  1,397            24                   360\n      1,396 -  1,333            25                   375\n      1,332 -  1,269            26                   390\n      1,268 -  1,205            27                   405\n      1,204 -  1,141            28                   420\n      1,140 -  1,077            29                   435\n      1,076 -  1,045            30                   450\n      1,044 -    981            31                   465\n        980 -    949            32                   480\n        948 -    917            33                   495\n        916 -    853            34                   510\n        852 -    821            35                   525\n        820 -    789            36                   540\n        788 -    757            37                   555\n        756 -    725            38                   570\n        724 -    693            39                   585\n        692 -    661            40                   600\n        660 -    629            41                   615\n        628 -    597            42                   630\n        596 -    565            44                   660\n        564 -    533            45                   675\n        532 -    501            46                   690\n        500 -    469            48                   720\n        468 -    437            49                   735\n        436 -    405            51                   765\n        404 -    373            53                   795\n        372 -    341            55                   825\n        340 -    309            57                   855\n        308 -    277            59                   885\n        276 -    245            62                   930\n        244 -    213            65                   975\n        212 -    181            68                 1,020\n        180 -    149            70                 1,065\n        148 -    117            74                 1,110\n        116 -     85            78                 1,170\n         84 -     53            83                 1,245\n         52 -     21            88                 1,320\n         20 -      1            93                 1,395\n*/\n  Return 0\n\nset_3375_sector_sizes:\n/*\nBlocks per 3375 track for different (non-keyed) physical block sizes:\n\nBlocksize Range       Records/Track        Records/Cylinder\n--------------------------------------------------------------\n35,616 - 17,601             1                    12\n17,600 - 11,616             2                    24\n11,615 -  8,609             3                    36\n 8,608 -  6,817             4                    48\n 6,816 -  5,601             5                    60\n 5,600 -  4,737             6                    72\n 4,736 -  4,097             7                    84\n 4,096 -  3,617             8                    96\n 3,616 -  3,201             9                   108\n 3,200 -  2,881            10                   120\n 2,880 -  2,593            11                   132\n 2,592 -  2,369            12                   144\n 2,368 -  2,177            13                   156\n 2,176 -  2,017            14                   168\n 2,016 -  1,857            15                   180\n 1,856 -  1,729            16                   192\n 1,728 -  1,601            17                   204\n 1,600 -  1,505            18                   216\n 1,504 -  1,409            19                   228\n 1,408 -  1,313            20                   240\n 1,312 -  1,249            21                   252\n 1,248 -  1,153            22                   264\n 1,152 -  1,089            23                   276\n 1,088 -  1,057            24                   288\n 1,056 -    993            25                   300\n   992 -    929            26                   312\n   928 -    897            27                   324\n   832 -    801            29                   348\n   800 -    769            30                   360\n   768 -    737            31                   372\n   736 -    705            32                   384\n   704 -    673            33                   396\n   672 -    641            34                   408\n   640 -    609            35                   420\n   608 -    577            36                   432\n   576 -    545            37                   444\n   544 -    513            38                   456\n   512 -    481            40                   480\n   480 -    449            41                   492\n   448 -    417            43                   516\n   416 -    385            45                   540\n   384 -    353            46                   552\n   352 -    321            48                   576\n   320 -    289            51                   612\n   288 -    257            53                   636\n   256 -    225            56                   672\n   224 -    193            59                   708\n   192 -    161            62                   744\n   160 -    129            70                   840\n   128 -     97            75                   900\n    96 -     65            80                   960\n    32 -      1            86                 1,032\n*/\n  Return 0\n\nset_3350_sector_sizes:\n/*\nBlocks per 3350 track for different (non-keyed) physical block sizes:\nBlocksize Range       Records/Track        Records/Cylinder\n--------------------------------------------------------------\n19,069 -  9,443             1                    30\n 9,442 -  6,234             2                    60\n 6,233 -  4,629             3                    90\n 4,628 -  3,666             4                   120\n 3,665 -  3,025             5                   150\n 3,024 -  2,566             6                   180\n 2,565 -  2,222             7                   210\n 2,221 -  1,955             8                   240\n 1,954 -  1,741             9                   270\n 1,740 -  1,566            10                   300\n 1,565 -  1,420            11                   330\n 1,419 -  1,297            12                   360\n 1,296 -  1,191            13                   390\n 1,190 -  1,099            14                   420\n 1,098 -  1,019            15                   450\n 1,018 -    948            16                   480\n   947 -    885            17                   510\n   884 -    829            18                   540\n   828 -    778            19                   570\n   777 -    732            20                   600\n   731 -    691            21                   630\n   690 -    653            22                   660\n   652 -    618            23                   690\n   617 -    586            24                   720\n   585 -    556            25                   750\n   555 -    529            26                   780\n   528 -    503            27                   810\n   502 -    479            28                   840\n   478 -    457            29                   870\n   456 -    437            30                   900\n   436 -    417            31                   930\n   416 -    399            32                   960\n   398 -    382            33                   990\n   381 -    366            34                 1,020\n   365 -    350            35                 1,050\n   349 -    336            36                 1,080\n   335 -    322            37                 1,110\n   321 -    309            38                 1,140\n   308 -    297            39                 1,170\n   296 -    285            40                 1,200\n   284 -    274            41                 1,230\n   273 -    263            42                 1,260\n   262 -    253            43                 1,290\n   252 -    243            44                 1,320\n   242 -    234            45                 1,350\n   233 -    225            46                 1,380\n   224 -    217            47                 1,410\n   216 -    298            48                 1,440\n   207 -    201            49                 1,470\n   200 -    193            50                 1,500\n   192 -    186            51                 1,530\n   185 -    179            52                 1,560\n   178 -    172            53                 1,590\n   171 -    166            54                 1,620\n   165 -    159            55                 1,650\n   158 -    153            56                 1,680\n   152 -    147            57                 1,710\n   146 -    142            58                 1,740\n   141 -    136            59                 1,770\n   135 -    131            60                 1,800\n   130 -    126            61                 1,830\n   125 -    121            62                 1,860\n   120 -    116            63                 1,890\n   115 -    112            64                 1,920\n   111 -    107            65                 1,950\n   106 -    103            66                 1,980\n   102 -     99            67                 2,010\n    98 -     95            68                 2,040\n    94 -     91            69                 2,070\n    90 -     87            70                 2,100\n    86 -     83            71                 2,130\n    82 -     79            72                 2,160\n    78 -     76            73                 2,190\n    75 -     72            74                 2,220\n    71 -     69            75                 2,250\n    68 -     66            76                 2,280\n    65 -     62            77                 2,310\n    61 -     59            78                 2,340\n    58 -     56            79                 2,370\n    55 -     53            80                 2,400\n    52 -     50            81                 2,430\n    49 -     47            82                 2,460\n    46 -     45            83                 2,490\n    44 -     42            84                 2,520\n    41 -     39            85                 2,550\n    38 -     37            86                 2,580\n    36 -     34            87                 2,610\n    33 -     32            88                 2,640\n    31 -     29            89                 2,670\n    28 -     27            90                 2,700\n    26 -     25            91                 2,730\n    24 -     23            92                 2,760\n    22 -     20            93                 2,790\n    19 -     18            94                 2,820\n    17 -     16            95                 2,850\n    15 -     14            96                 2,880\n    13 -     12            97                 2,910\n    11 -     10            98                 2,940\n     9 -      8            99                 2,970\n     7 -      6           100                 3,000\n     5 -      4           101                 3,030\n     3 -      2           102                 3,060\n     1                    103                 3,090\n*/\n  Return 0\n\nset_3330_sector_sizes:\n  Return 0\n\nset_9345_sector_sizes:\n/*\nBlocks per 9345 track for different (non-keyed) physical block sizes:\n\nBlocksize Range       Records/Track        Records/Cylinder\n--------------------------------------------------------------\n\n22,929 - 46,456             1                    15\n15,075 - 22,928             2                    30\n11,159 - 15,074             3                    45\n 8,811 - 11,158             4                    60\n 7,215 -  8,810             5                    75\n 6,089 -  7,214             6                    90\n 5,263 -  6,088             7                   105\n 4,601 -  5,262             8                   120\n 4,103 -  4,600             9                   135\n 3,673 -  4,102            10                   150\n 3,305 -  3,672            11                   165\n 3,011 -  3,304            12                   180\n 2,745 -  3,010            13                   195\n 2,513 -  2,744            14                   210\n 2,315 -  2,512            15                   225\n 2,145 -  2,314            16                   240\n 1,981 -  2,144            17                   255\n 1,851 -  1,980            18                   270\n 1,749 -  1,850            19                   285\n 1,619 -  1,748            20                   300\n 1,517 -  1,618            21                   315\n 1,415 -  1,516            22                   330\n 1,353 -  1,414            23                   345\n 1,251 -  1,352            24                   360\n 1,183 -  1,250            25                   375\n 1,121 -  1,182            26                   390\n 1,053 -  1,120            27                   405\n   985 -  1,052            28                   420\n   951 -    984            29                   435\n   889 -    950            30                   450\n   855 -    888            31                   465\n   821 -    854            32                   480\n   753 -    820            33                   495\n   719 -    752            34                   510\n   691 -    718            35                   525\n   657 -    690            36                   540\n   623 -    656            37                   555\n   589 -    622            38                   570\n   555 -    588            39                   585\n   521 -    554            40                   600\n   487 -    520            41                   615\n   459 -    486            43                   645\n   425 -    458            44                   660\n   391 -    424            45                   675\n   357 -    390            47                   705\n   323 -    356            48                   720\n   289 -    322            50                   750\n   255 -    288            52                   780\n   227 -    254            54                   810\n   193 -    226            56                   840\n   159 -    192            59                   885\n   125 -    158            61                   915\n    91 -    124            64                   960\n    57 -     90            67                  1005\n    23 -     56            71                  1065\n     1 -     22            74                  1110\n*/\n  Return 0\n\n/*\n\nCOPYR1 DEVTYPE data\nSample: 3030 20 0E 00007FF8 0D0B 000F BB60 01 00 20 52 010B\n\nDVAOPTS   3030 = 12336 ?meaning what?\nDVACLASS  20 = DASD\nDVAUNIT   0E = 3380\nDVAMAXRC  00007FF8 = 32760\nDVACYL    0D0B = 3339\nDVATRK    000F = 15\nDVATRKLN  BB60 = 47968  (DASD-3380)\nDVAOVNLB  01 =\nDVAOVLB   00 =\nDVAOVNK   20 =\nDVAFLAGS  52 =\n010B = 267\n\nDVAOPTS  DS    XL2      UCB OPTIONS\nDVACLASS DS    XL1      DEVICE CLASS\nDVAUNIT  DS    XL1      UNIT TYPE\nDVAMAXRC DS    F        MAXIMUM BLOCK SIZE WHEN NOT USING SAM LBI (7FF8 = 32760)\nDVACYL   DS    H        PHYSICAL NUMBER OF CYLINDERS PER VOLUME\nDVATRK   DS    H        NUMBER OF TRACKS PER CYLINDER\nDVATRKLN DS    H        NUMBER OF BYTES PER TRACK, INCLUDING OVERHEAD\nDVAOVNLB DS    FL1      OVERHEAD IF NOT LAST BLOCK\nDVAOVLB  DS    FL1      OVERHEAD IF LAST BLOCK\nDVAOVNK  DS    FL1      OVERHEAD DECREMENT IF BLOCK NOT KEYED\nDVAFLAGS DS    XL1\n  DVABDCYL EQU   X'80'     IF 1, DVACYL IS INVALID\n  DVADEFLR EQU   X'40'     DEFINE EXTENT, LOCATE RECORD & RELATED TRANSFER COMMA\n  DVADEFEX EQU   X'20'     DEFINE EXTENT IMPLEMENTED\n  DVA2BOV  EQU   X'08'     IF 1, USE DVAOVHD\n  *                        IF 0, USE DVAOVNLB,DVAOVLB\n  DVAMODL  EQU   X'10'     IF 1 USE DVAMOD1, DVAOVH1, DVAOVH2\n  DVAPAGES EQU   X'04'     IF 1, DEVICE SUPPORTS PAGING CCWS\n  *                        IF 0, DEVICE DOES NOT SUPPORT PAGING CCWS\n  DVANOALT EQU   X'02'     NO ALTERNATE TRACKS ARE AVAILABLE\n  DVAFTOL  EQU   X'01'     IF 1, APPLY TOLERANCE FACTOR\nDVATOL   DS    H        TOLERANCE FACTOR\n*                                 *************************************\n*                                 * APPLY TOLERANCE FACTOR AS FOLLOWS:*\n*                                 * 1. ADD BLOCKSIZE AND KEYLENGTH    *\n*                                 * 2. MULTIPLY BY DVATOL             *\n*                                 * 3. SHIFT RIGHT DVASHFT BITS       *\n*                                 * 4. ADD APPROPRIATE OVERHEADS      *\n*                                 *************************************\nDVASHFT  EQU   9                        SHIFT AMT TO DIVIDE BY 512\n\n\nTable 50. Output from DEVTYPE Macro   DASD Devices\nIBM Device                                           MaxSz  DEVTAB\n---------------------------------------------------- -----  ---- ---- ---- ----\n3380 Models AD4, AJ4, BD4, BJ4, and CJ2 Disk Storage  7FF8  0376 000F BB60 0100\n3380 Models AD4, AJ4, BD4, BJ4, Disk Storage          7FF8  0376 000F BB60 0100\n3380 Models AE4 and BE4 Disk Storage                  7FF8  06EB 000F BB60 0100\n3380 Models AE4 and BE4 Disk Storage                  7FF8  06EB 000F BB60 0100\n3380 Models AK4 and BK4 Disk Storage                  7FF8  0A60 000F BB60 0100\n3380 Models AK4 and BK4 Disk Storage                  7FF8  0A60 000F BB60 0100\n3390 Model 1 (attached to a 3990 Model 2)             7FF8  0459 000F E5A2 0000\n3390 Model 1 (attached to a 3990 Model 3)             7FF8  0459 000F E5A2 0000\n3390 Model 2 (attached to a 3990 Model 2)             7FF8  08B2 000F E5A2 0000\n3390 Model 2 (attached to 3990 Model 3)               7FF8  08B2 000F E5A2 0000\n3390 Model 3 (attached to a 3990 Model 2)             7FF8  0D0B 000F E5A2 0000\n3390 Model 3 (attached to a 3990 Model 3)             7FF8  0D0B 000F E5A2 0000\n3390 Model 3 (attached to a 3990 Model 6)             7FF8  0D0B 000F E5A2 0000\n3390 Model 9 (attached to a 3990 Model 2)             7FF8  2721 000F E5A2 0000\n3390 Model 9 (attached to a 3990 Model 3)             7FF8  2721 000F E5A2 0000\n3390 Model 9 (attached to a 3990 Model 6)             7FF8  2721 000F E5A2 0000\n9345 Model 1                                          7FF8  05A0 000F BC98 0000\n\n\n\n#>\n\n<#\n\nVTOC DSCB Format-1\n\n**CCHHR- 000100071A RECORD LENGTH- 00008C\n000000 D2C5 E3F2 F8F1 F24B E7D4 C9E3 4BD7 D6C5 C640 4040 4040 4040 4040 4040 404\n000020 4040 4040 4040 4040 4040 4040 F1E3 E2D6 F0F0 F100 0172 0006 0000 0001 000\n000040 D4D6 E2E5 E2F2 4040 4040 4072 000F 8880 7FD0 0200 8000 0050 0050 0000 008\n000060 0005 0000 0000 0000 0001 0000 6000 0000 6000 0300 0000 0000 0000 0000 000\n000080 0000 0000 0000 0000 0000 0000\n\n\nDS1DSNAM 44 D2C5 E3F2 F8F1 F24B E7D4 C9E3 4BD7 D6C5 C640 4040 4040 4040 4040 404\nDS1FMTID  1 F1 = 1\nDS1DSSN   6 E3 E2D6 F0F0 F1 = TSO001\nDS1VOLSQ  2 00 01 = 1\nDS1CREDT  3 72 0006 = 2014.006 x'72' = 114 + 1900 = 2014 0006 = 006\nDS1EXPDT  3 0000 00 = 0 = None\nDS1NOEPV  1 01 = 1 Extent on this volume\nDS1NODBD  1 00 = 0 bytes in last directory block\nDS1FLAG1  1 00 = none of what it might be\nDS1SYSCD 13 C9C2 D4D6 E2E5 E2F2 4040 4040 40 = IBMOSVS2\nDS1REFD   3 72 000F = 2014.015\nDS1SMSFG  1 88 = \"S\" and PDSE or HFS\nDS1SCEXT  3  If DS1SCAL1 bitand x'10' else ...\nDS1SCXTF  1 80 = Original block length follows...\nDS1SCXTV  2 7FD0 = 32720\nDS1RECFM  1 02 = (HUH? 20 = Fixed, 02 = Machine control character)\nDS1OPTCD  1 00 = none of what it could be\nDS1BLKL   2 8000 = 32768\nDS1LRECL  2 0050 = 80\nDS1KEYL   1 00 = 0\nDS1RKP    2 5000 = 20480\nDS1DSIND  1 00 = none of what it might be\nDS1CALO   4  When? Else ....\nDS1SCAL1  1 00\nDS1CAL3   3 82 5000 = 8540160 of what? bytes? divided into what?\nDS1LSTAR  3 000500 = TTR\n00 0000 0000 0001 0000 6000 0000 6000 0300 0000 0000 0000 0000 0000 0000 0000 00\n\n\n#>\n\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSIC$DOC": {"ttr": 2308, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00&\\x01\\x17!/\\x01\\x17#_\\x05\\x15\\x00\\x97\\x003\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2017-07-31T00:00:00", "modifydate": "2017-08-23T05:15:26", "lines": 151, "newlines": 51, "modlines": 0, "user": "KTOMIAK"}, "text": "\n       Mainframe Software Installation Customizer (MSIC)\n\nThis SHAREWARE Tool is a generalized and extensible ISPF Dialog\nthat aids in installing and customizing the type of SHAREWARE you\nmight develop and contribute to the CBTTape.Org respository.\n\nYou will decide what needs to be done to install and configure\nyour SHAREWARE and from that you will build #1TASKS for the user\nto act upon. Along the way you may have a need for the user to\nprovide values, e.g. High Level Qualifier and VOLSER, and you\nwill build #2VARS listing the variable, some simple attributes,\nand an initial value. You build #3EDIT to identify which members\nvariable replacement should act upon.\n\nMSIC has some built-in action types (internal routine) and a few\nexternal action types (separate REXX members). If you need more\nthan this then you add the external action to your install PDS.\n\nConfiguration members:\n----------------------\n#1TASKS : Identifies the sequence of actions to be performed.\n#2VARS  : The variables you use to install and configure your\n          SHAREWARE item.\n#3EDIT  : A list of members edited with Macro(MSICRMBR) to\n          accomplish variable substitution.\n\nAction types:\n-------------\nBrowse  : Let the user BROWSE a PDS member.\nEdit    : Let the user EDIT a PDS member.\nExecute : Run some external REXX code.\nReceive : Receive all XM variables.\nRoutine : Run an internal REXX routine.\nSubmit  : Submit a member to run in the background.\nView    : Let the user VIEW a PDS member.\n\nProvided external action:\n-------------------------\nMSICREDT: Reads #3EDIT and invokes EDIT with Macro(MSICRMBR) to\n          do variable substitution.\nMSICRMBR: Uses table VDEFTABL to do variable substitution.\nMSICRSUB: Edit macro to insert INFO and NOTE lines at the top\n          of the member to inform the user what to do.\n\n#2VARS variables and values added by MSIC:\n------------------------------------------\nHOSTDSN1: Added by MSIC; contains the data set name from whence\n          MSIC was run from. It is also the ISPPLIB and ALTLIB\n          added data set.\nHOSTDSN2: Added by MSIC, same as above, minus the apostrophes.\nUNIT    : Added by MSIC, the device type the extract data set is on.\nVOLSER  : Added by MSIC, the volume the extract data set is on.\nZUSER   : Added by MSIC, the current userid.\n\n\nDEMO suitable example\n---------------------\nMy DEMO shareware Tool is a good example of how to setup the\n#1TASKS, #2VARS, and #3EDIT members.\n\nBuilding #1TASKS\n----------------\n*\n* Mainframe Software Installation Customizer (MSIC)\n*\n* Tasks require 2 records.\n* Record 1:\n* =====================================================================\n* Seq    N3 Three digit sequence identifier\n* Type   C7 What it is you want to do.\n*             Browse : Let the user BROWSE a PDS member.\n*             Edit   : Let the user EDIT a PDS member.\n*             Execute: Run some external REXX code.\n*             Receive: Receive all XM variables.\n*             Routine: Run an internal REXX routine.\n*             Submit : Submit a member to run in the background.\n*             View : Let the user VIEW a PDS member.\n* Item   C8 What is acted upon.\n* Done   D8 The last attempt date filled in by MSIC.\n* Status C2 How that last attempt fared filled in by MSIC.\n*\n* Record 2:\n* =====================================================================\n* Desc  : A descriptive bit of text.\n*\n*---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8\n*SQ Type    Item     Description goes on a second line               Done     St\n*== ======= ======== =============================================== ======== ==\n\nTips:\n-----\n- Use the sequence to put things in chronological order.\n- Use sequence as a range for similar events.\n- Browse, Edit, and View should be used appropriately.\n  Browse is read-only.\n  View allows editing while denying SAVE.\n  Edit allows full editing and saving.\n- Use Windows copy and paste of member names to ensure correctness.\n\n\nBuilding #2VARS\n---------------\n*\n* Mainframe Software Installation Customizer (MSIC)\n*\n* Variables require 2 records.\n* Record 1:\n* =====================================================================\n* ITEM         C8 The variable name.\n*                 You will wrap it with exclamation marks when used.\n* Attribute    C2 Provides for limited validation and identification.\n*                   DS = Data set name\n*                   LC = Lowercase\n*                   MB = Member name\n*                   MC = Mixed case (ASIS)\n*                   N  = Number (digits)\n*                   UC = Uppercase\n*                   XM = IDTF member to DSName.\n* Length      N2  The maximum size of the value.\n* Description C61 Describes what the variable is used for.\n*\n* Record 2:\n* =====================================================================\n* The initial default value or the user specified value.\n*\n*---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8\n*Item    A  Length Description (value is on the next row).\n*======= == ====== =============================================================\n\nTips:\n-----\n- Variable replacement using #3EDIT along with MSICREDT and MSICRMBR\n  will run through the variables twice, thus you can use a variable\n  in a value and have it replaced on the second pass.\n\n\nBuilding #3EDIT\n---------------\n*\n* Mainframe Software Installation Customizer\n*\n* This is a list of members that will undergo variable replacement.\n*\n\nTips:\n-----\n- List the member names in your install PDS that should undergo\n  variable replacement.\n- Have a backup copy if you need recoverability.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MSICHDL1": {"ttr": 2312, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\t\\x01\\x17\"o\\x01\\x17$_\\x14(\\x00\\x1b\\x00\\x19\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2017-08-14T00:00:00", "modifydate": "2017-09-02T14:28:09", "lines": 27, "newlines": 25, "modlines": 0, "user": "KTOMIAK"}, "text": ")ATTR DEFAULT(%+_)\n %   TYPE(TEXT) INTENS(HIGH) Caps(Off)\n +   TYPE(TEXT) INTENS(LOW) Caps(Off)\n _   TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) Hilite(UScore)\n)BODY Expand(||) Width(40)\n%|-| MSIC IDTF Line Commands |-|\n+\n%Enter Line Command ==>_z+\n%Line Function\n+---- |-|\n%  B +Browse the data set.\n%  E +Edit the data set.\n%  H +Show the IDTF and IEBCOPY tags.\n%  I +Install a MSIC compliant Tool.\n%  R +Receive the data set.\n%  V +View the data set.\n%  / +Brings up this pop-up panel.\n%  ? +Brings up this pop-up panel.\n+---- |-|\n+\n)INIT\n.ZVARS = 'IDTFLCMD'\n)REINIT\n)PROC\n)HELP\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICHDZ1": {"ttr": 2314, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x19\\x01\\x17\"o\\x01\\x17$_\\x14(\\x00\\x10\\x00\\x10\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2017-08-14T00:00:00", "modifydate": "2017-09-02T14:28:19", "lines": 16, "newlines": 16, "modlines": 0, "user": "KTOMIAK"}, "text": ")ATTR DEFAULT(%+_)\n %   TYPE(TEXT) INTENS(HIGH) Caps(Off)\n +   TYPE(TEXT) INTENS(LOW) Caps(Off)\n _   TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) Hilite(UScore)\n)BODY Expand(||)\n%-|-|- MSIC: DS34 Command -|-|-\n+\n%Command            Function\n+------------------ |-|\n%?                 +Brings up this pop-up panel.\n%Refresh           +Reread the configuration file and rebuild table.\n+---------- |-|\n+\n)PROC\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICHTF1": {"ttr": 2316, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00)\\x01\\x17\"o\\x01\\x17$_\\x14(\\x00\\n\\x00\\n\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-08-14T00:00:00", "modifydate": "2017-09-02T14:28:29", "lines": 10, "newlines": 10, "modlines": 0, "user": "KTOMIAK"}, "text": ")ATTR DEFAULT(%+_)\n % TYPE(TEXT) INTENS(HIGH) Caps(Off)\n + TYPE(TEXT) INTENS(LOW) Caps(Off)\n _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) Hilite(UScore)\n)BODY Expand(||) Width(78)\n%-|-|- MSIC TASK ZCMD Field -|-|-\n+\n+You can enter ISPF commands in this field.\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICHTF2": {"ttr": 2318, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x007\\x01\\x17\"o\\x01\\x17$_\\x14(\\x00\\n\\x00\\n\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-08-14T00:00:00", "modifydate": "2017-09-02T14:28:37", "lines": 10, "newlines": 10, "modlines": 0, "user": "KTOMIAK"}, "text": ")ATTR DEFAULT(%+_)\n % TYPE(TEXT) INTENS(HIGH) Caps(Off)\n + TYPE(TEXT) INTENS(LOW) Caps(Off)\n _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) Hilite(UScore)\n)BODY Expand(||) Width(78)\n%-|-|- MSIC TASK Sel Field -|-|-\n+\n+You can enter line commands in this field.\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICHTF3": {"ttr": 2320, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00D\\x01\\x17\"o\\x01\\x17$_\\x14(\\x00\\r\\x00\\r\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-08-14T00:00:00", "modifydate": "2017-09-02T14:28:44", "lines": 13, "newlines": 13, "modlines": 0, "user": "KTOMIAK"}, "text": ")ATTR DEFAULT(%+_)\n % TYPE(TEXT) INTENS(HIGH) Caps(Off)\n + TYPE(TEXT) INTENS(LOW) Caps(Off)\n _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) Hilite(UScore)\n)BODY Expand(||) Width(78)\n%-|-|- MSIC TASK Description Field -|-|-\n+\n+This gives a brief description of what the task does.\n+If a lenghty explanation is wirthwhile then the Tool\n+Developer should have preceded this with a Browse action.\n+\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICHTL1": {"ttr": 2322, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00R\\x01\\x17\"o\\x01\\x17$_\\x14(\\x00\\x15\\x00\\x15\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-08-14T00:00:00", "modifydate": "2017-09-02T14:28:52", "lines": 21, "newlines": 21, "modlines": 0, "user": "KTOMIAK"}, "text": ")ATTR DEFAULT(%+_)\n %   TYPE(TEXT) INTENS(HIGH) Caps(Off)\n +   TYPE(TEXT) INTENS(LOW) Caps(Off)\n _   TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) Hilite(UScore)\n)BODY Expand(||) Width(78)\n%|-| MSIC Tasks Line Commands |-|\n+\n%Enter Line Command ==>_z+\n%Line Function\n+---- |-|\n%  S +Select and perform the underlying action.\n%/ ? +Brings up this pop-up panel.\n+---- |-|\n+\n)INIT\n.ZVARS = 'TASKZSEL'\n)REINIT\n)PROC\n)HELP\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICHTZ1": {"ttr": 2324, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00X\\x01\\x17\"o\\x01\\x17$_\\x14(\\x00\\x15\\x00\\x10\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2017-08-14T00:00:00", "modifydate": "2017-09-02T14:28:58", "lines": 21, "newlines": 16, "modlines": 0, "user": "KTOMIAK"}, "text": ")ATTR DEFAULT(%+_)\n %   TYPE(TEXT) INTENS(HIGH) Caps(Off)\n +   TYPE(TEXT) INTENS(LOW) Caps(Off)\n _   TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) Hilite(UScore)\n)BODY Expand(||)\n%-|-|- MSIC: Tasks Command -|-|-\n+\n%Command            Function\n+------------------ |-|\n%Select {seq}      +Selects an item by sequence number.\n%?                 +Brings up this pop-up panel.\n%Find {string}     +Finds your string in Descriptions and\n%                  +in (AKA) keyword fields.\n%Locate            +Scroll to the location of an item.\n%?                 +Brings up this pop-up panel.\n%Refresh           +Reread the configuration file and rebuild table.\n+------------------ |-|\n+\n)PROC\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICHVAR": {"ttr": 2326, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x10\\x01\\x17 \\x9f\\x01\\x17$_\\x14)\\x00\\r\\x00\\x18\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2017-07-28T00:00:00", "modifydate": "2017-09-02T14:29:10", "lines": 13, "newlines": 24, "modlines": 0, "user": "KTOMIAK"}, "text": ")ATTR DEFAULT(%+_)\n %   TYPE(TEXT) INTENS(HIGH) Caps(Off)\n +   TYPE(TEXT) INTENS(LOW) Caps(Off)\n _   TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) Hilite(UScore)\n)BODY Expand(||) Width(78)\n%-|-|- MSIC VDEF Line Commands -|-|-\n+\n+You can scroll and change as many variables as you like\n+without having to select them. Selecting an item, changed\n+or not, will undergo validation.\n+\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICHVL1": {"ttr": 2328, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x19\\x01\\x17\"o\\x01\\x17$_\\x14)\\x00\\x11\\x00\\x11\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-08-14T00:00:00", "modifydate": "2017-09-02T14:29:19", "lines": 17, "newlines": 17, "modlines": 0, "user": "KTOMIAK"}, "text": ")ATTR DEFAULT(%+_)\n %   TYPE(TEXT) INTENS(HIGH) Caps(Off)\n +   TYPE(TEXT) INTENS(LOW) Caps(Off)\n _   TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) Hilite(UScore)\n)BODY Expand(||) Width(78)\n%|-| MSIC Variables Line Commands |-|\n+\n+You can update as many variables' values as you want\n+before pressing Enter or scrolling down/up.\n+\n)INIT\n.ZVARS = 'TASKZSEL'\n)REINIT\n)PROC\n)HELP\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICHVZ1": {"ttr": 2330, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00B\\x01\\x17\"o\\x01\\x17$_\\x14)\\x00\\x0c\\x00\\x0c\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-08-14T00:00:00", "modifydate": "2017-09-02T14:29:42", "lines": 12, "newlines": 12, "modlines": 0, "user": "KTOMIAK"}, "text": ")ATTR DEFAULT(%+_)\n %   TYPE(TEXT) INTENS(HIGH) Caps(Off)\n +   TYPE(TEXT) INTENS(LOW) Caps(Off)\n _   TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) Hilite(UScore)\n)BODY Expand(||)\n%-|-|- MSIC: Variables Command -|-|-\n+\n+No commands are defined.\n+\n)PROC\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICPCFM": {"ttr": 2332, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00I\\x01\\x17\"\\x1f\\x01\\x17$_\\x14)\\x00\\x16\\x00\\x10\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2017-08-09T00:00:00", "modifydate": "2017-09-02T14:29:49", "lines": 22, "newlines": 16, "modlines": 0, "user": "KTOMIAK"}, "text": ")ATTR DEFAULT(%+_)\n  % TYPE(TEXT) INTENS(HIGH)\n  + TYPE(TEXT) INTENS(LOW)\n  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)\n)BODY WIDTH(80) Expand(||) WINDOW(80,12)\n%| | MSIC Confirmation Required | |\n+\n+&Reason1\n%Confirm:_Z+  Y for YES or N for NO.\n+\n+&Reason2\n+&Reason3\n+&Reason4\n+&Reason5\n+\n)INIT\n.ZVARS = 'CONFIRMD'\n&CONFIRMD = '?'\n)PROC\nVer(&CONFIRMD,LIST,Y,N)\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICPHLP": {"ttr": 2334, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00V\\x01\\x17\"_\\x01\\x17$_\\x14)\\x00\\x16\\x00\\x16\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2017-08-13T00:00:00", "modifydate": "2017-09-02T14:29:56", "lines": 22, "newlines": 22, "modlines": 0, "user": "KTOMIAK"}, "text": ")ATTR DEFAULT(%+_)\n      /*  % TYPE(TEXT) INTENS(HIGH)      defaults displayed for      */\n      /*  + TYPE(TEXT) INTENS(LOW)       information only            */\n      /*  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)             */\n)BODY Expand(||)\n%|-| MSIC: Help |-|\n%SELECTION ===>_ZCMD                                                           +\n%\n%           -----------------------------------------------------\n            | Mainframe Software Installation Customizer (MSIC) |\n            -----------------------------------------------------\n+\nThis SHAREWARE tool assists in installing other tools that conform to the MSIC\ndesign. You, the end-user, benefit from having a similar installation and\ncustomization experience. The tool author benfits from not having to create a\nnew process.\n\nWork your way down the tasks in the numbered sequence. Feel free to press your\nHELP PFKey whenever the upper right hand corner indicates there is a longer\nresponse to share with you.\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICPHZC": {"ttr": 2561, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x05\\x01\\x17 \\x8f\\x01\\x17$_\\x140\\x00\\x11\\x00+\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2017-07-27T00:00:00", "modifydate": "2017-09-02T14:30:05", "lines": 17, "newlines": 43, "modlines": 0, "user": "KTOMIAK"}, "text": ")PANEL KEYLIST (ISRHELP ISR)\n)ATTR DEFAULT(%+_)\n % TYPE(TEXT) INTENS(HIGH)\n + TYPE(TEXT) INTENS(LOW)\n _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)\n)BODY Expand(||)\n%Help |-| MSIC: OPTION |-| Help\n%OPTION  ===>_ZCMD                                                             +\n%\n+Valid OPTION commands are:\n+\n+\n+\n)INIT\n)PROC\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICPHZD": {"ttr": 2563, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x12\\x01\\x17\"_\\x01\\x17$_\\x140\\x00\\x11\\x00\\x10\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2017-08-13T00:00:00", "modifydate": "2017-09-02T14:30:12", "lines": 17, "newlines": 16, "modlines": 0, "user": "KTOMIAK"}, "text": ")PANEL KEYLIST (ISRHELP ISR)\n)ATTR DEFAULT(%+_)\n % TYPE(TEXT) INTENS(HIGH)\n + TYPE(TEXT) INTENS(LOW)\n _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)\n)BODY Expand(||)\n%Help |-| MSIC: DESCRIPTION |-| Help\n%OPTION  ===>_ZCMD                                                             +\n%\n+The description tells you what the task is about.\n+\n+\n+\n)INIT\n)PROC\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICPHZS": {"ttr": 2565, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x19\\x01\\x17\"_\\x01\\x17$_\\x140\\x00\\x11\\x00\\x10\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2017-08-13T00:00:00", "modifydate": "2017-09-02T14:30:19", "lines": 17, "newlines": 16, "modlines": 0, "user": "KTOMIAK"}, "text": ")PANEL KEYLIST (ISRHELP ISR)\n)ATTR DEFAULT(%+_)\n % TYPE(TEXT) INTENS(HIGH)\n + TYPE(TEXT) INTENS(LOW)\n _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)\n)BODY Expand(||)\n%Help |-| MSIC: SEL |-| Help\n%OPTION  ===>_ZCMD                                                             +\n%\n+Valid SEL commands are:\n+\n+\n+\n)INIT\n)PROC\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICPINF": {"ttr": 2567, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00%\\x01\\x17!O\\x01\\x17$_\\x140\\x00\\x16\\x00\\x14\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2017-08-02T00:00:00", "modifydate": "2017-09-02T14:30:25", "lines": 22, "newlines": 20, "modlines": 0, "user": "KTOMIAK"}, "text": ")ATTR DEFAULT(%+_)\n      /*  % TYPE(TEXT) INTENS(HIGH)      defaults displayed for      */\n  + TYPE(TEXT) INTENS(LOW) Skip(On)\n  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) Hilite(UScore)\n  $ Type(Output) Intens(High) Caps(Off) Just(Left)\n  # Type(Output) Intens(Low)  Caps(Off) Just(Left)\n)BODY Expand(||) Width(&ZSCREENW)\n%|-| IDTF Information |-|\n%COMMAND ===>_ZCMD               | |Scroll ===>_ZSCR+\n%\n+Data set=>#LSELDSNM\n+\n%  KEY          Value\n+-------------- |-|\n)MODEL\n$INFOKEY       #INFOVAL\n)INIT\n)PROC\n)Field\nField(INFOVAL) Len(80) SCROLL(On)\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICPPRG": {"ttr": 2569, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x005\\x01\\x17!_\\x01\\x17$_\\x140\\x00\\x0e\\x00\\x06\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2017-08-03T00:00:00", "modifydate": "2017-09-02T14:30:35", "lines": 14, "newlines": 6, "modlines": 0, "user": "KTOMIAK"}, "text": ")ATTR DEFAULT(%+_)\n  % TYPE(TEXT) INTENS(HIGH)\n  + TYPE(TEXT) INTENS(LOW)\n  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)\n)BODY WIDTH(60) Expand(||) WINDOW(62,07)\n%| | MSIC: Progress | |\n+\n+Dataset: &LSELDSNM\n%Phase:+&MSICPHSE\n+\n)INIT\n)PROC\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICPPRI": {"ttr": 2571, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00C\\x01\\x17!/\\x01\\x17$_\\x140\\x00\\x17\\x00\\x13\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2017-07-31T00:00:00", "modifydate": "2017-09-02T14:30:43", "lines": 23, "newlines": 19, "modlines": 0, "user": "KTOMIAK"}, "text": ")ATTR DEFAULT(%+_)\n  % TYPE(TEXT) INTENS(HIGH)\n  + TYPE(TEXT) INTENS(LOW) Skip(On)\n  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) Hilite(UScore)\n  $ TYPE(Input) INTENS(LOW) JUST(LEFT) Hilite(UScore)\n)BODY Expand(||) Width(&ZSCREENW)\n%|-| Mainframe Software Installation Customizer |-|\n%COMMAND ===>_ZCMD               | |Scroll ===>_ZSCR+\n%\n+Enter a data set pattern to list your IDTF data sets.\n+Pattern=>_DS34PTRN                                    +\n+Actions: B, E, H, I, R, V, /, ?\n%-Action-  Dataset\n+--------  --------------------------------------------\n)MODEL\n_DS34LCMD+$DS34DSNM                                    +\n)INIT\n.HELP = MSICT000\n&ZHTOP = MSICT000   /* TUTORIAL TABLE OF CONTENTS        */\n&ZHINDEX = MSICTX00 /* TUTORIAL INDEX - 1ST PAGE         */\n)PROC\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICPTSK": {"ttr": 2573, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00X\\x01\\x17 /\\x01\\x17$_\\x140\\x00\\x1a\\x00\\x17\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2017-07-21T00:00:00", "modifydate": "2017-09-02T14:30:58", "lines": 26, "newlines": 23, "modlines": 0, "user": "KTOMIAK"}, "text": ")ATTR DEFAULT(%+_) FORMAT(MIX)\n /* % TYPE(TEXT) INTENS(HIGH)                                         */\n + TYPE(TEXT) INTENS(LOW) Skip(On)\n _ TYPE(Input)  Intens(High) Caps(Off) Just(Left) Pas(On)\n   Hilite(UScore)\n # Type(Output) Intens(High) Caps(Off) Just(Left)\n $ Type(Output) Intens(Low)  Caps(Off) Just(Left) Pas(On)\n)BODY EXPAND(\\\\) Width(&ZSCREENW)\n%-\\-\\- MSIC Task List -\\-\\-\n%Command ==>_ZCMD \\ \\%Scroll ==>_ZSCR\n%\n%Sel Seq Type      Done     RC Description\n+--- --- --------- -------- -- \\-\\\n)Model\n_Z  $Z  #TASKTYPE #TASKDONE#Z $TASKDESC\n)INIT\n.ZVARS = 'TASKZSEL, TASKSEQ, TASKRC'\n)PROC\n)HELP\nFIELD(ZCMD) PANEL(MSICHTF1)\nFIELD(TASKZSEL) PANEL(MSICHTF2)\nFIELD(TASKDESC) PANEL(MSICHTF3)\n)Field\nField(TASKDESC) Len(80) SCROLL(On)\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICPVAR": {"ttr": 2575, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x05\\x01\\x17#/\\x01\\x17$_\\x141\\x00\\x1a\\x00\\x1a\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2017-08-20T00:00:00", "modifydate": "2017-09-02T14:31:05", "lines": 26, "newlines": 26, "modlines": 0, "user": "KTOMIAK"}, "text": ")ATTR DEFAULT(%+_) FORMAT(MIX)\n /* % TYPE(TEXT) INTENS(HIGH)                                         */\n + TYPE(TEXT) INTENS(LOW) Skip(On)\n _ TYPE(Input)  Intens(High) Caps(Off) Just(Left) Pas(On)\n   Hilite(UScore)\n # Type(Output) Intens(High) Caps(Off) Just(Left)\n $ Type(Output) Intens(Low)  Caps(Off) Just(Left) Pas(On)\n)BODY EXPAND(||) Width(&ZSCREENW)\n%-|-|- MSIC Variable list -|-|-\n%Command ==>_ZCMD | |%Scroll ==>_ZSCR\n%\n%Name     Type     Length  St  Description / Value is on the next row.\n+-------- -------- ------- --- |-|\n)Model\n#VDEFVAR $VDEFATTR$VDEFLEN#Z  $VDEFDESC\n_VDEFVAL\n+\n)INIT\n.ZVAR = 'VDEFZSEL'\n)PROC\n)HELP\nFIELD(ZCMD) PANEL(MSICHVF1)\n)Field\nField(VDEFDESC) Len(80) SCROLL(On)\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICREDT": {"ttr": 2577, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00&\\x01\\x17 \\x9f\\x01\\x17$_\\x141\\x00\\x86\\x00\\xe1\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-07-28T00:00:00", "modifydate": "2017-09-02T14:31:26", "lines": 134, "newlines": 225, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\nrexx_msicredt:\n  rexxpgm_version = \"01.00\"          /* Set with 'ver 1' and 'lev 2'. */\n\n  ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nrexx_Main_Code:\n  return_code = Initialization_routine()\n  If (return_code = 0) Then Do\n    return_code = Process_routine()\n  End\n  return_code = Termination_routine()\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF dialog program called to do variable\n            replacement in identified members.\n\n  Syntax:   Called from MSIC.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.00 20170728 \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_routine:\n  return_code = 0\n  msg_rc = 0\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_routine:\n  ADDRESS ISPEXEC \"VGET (EDITDSN)\"\n  @trap_state = TRAPMSG(\"On\")\n  msg_state = Msg(\"OFF\")\n  sysdsn_rc = SysDsn(\"'\"editdsn\"'\")\n  If (sysdsn_rc <> \"OK\") Then Do\n    msg_rc = 1\n    return_code = 16\n    Return return_code\n  End\n  msg_rc = Msg(msg_state)\n  @trap_state = TRAPMSG(@trap_state)\n  Address TSO ,\n    \"ALLOC File(@EDIT) DataSet('\"editdsn\"(#3EDIT)') SHR REUSE\"\n  alloc_rc = RC\n  Address MVS ,\n    \"EXECIO * DiskR @EDIT (Stem editlist. Finis)\"\n  execio_rc = RC\n  Address TSO ,\n    \"FREE File(@EDIT)\"\n  free_rc = RC\n\n  zerrlm = \"\"\n  Do tx = 1 to editlist.0\n    If (Left(editlist.tx,1) = \"*\") Then Iterate\n    editlist_item = Strip(Left(editlist.tx,8),\"T\",\" \")\n    Address ISPEXEC \"EDIT\" ,\n      \"Dataset('\"editdsn\"(\"editlist_item\")') MACRO(MSICRMBR)\"\n    edit_rc = RC\n    If (edit_rc = 0) Then Do\n      zerrlm = zerrlm || Left(editlist_item \"OK\",79)\n    End\n    Else Do\n      zerrlm = zerrlm || Left(editlist_item \"Nothing changed\",79)\n    End\n  End\n  ZERRALRM = \"Yes\"\n  ZERRSM = \"Edit results\"\n  ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_routine:\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to lowercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Lowercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,lowercase_letters,uppercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n Convert string to uppercase.\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTo_Uppercase: Parse arg myarg\n  defined_state = Symbol(uppercase_letters)\n  If (defined_state = \"LIT\") Then Do\n    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\n  End\n  Return Translate(myarg,uppercase_letters,lowercase_letters)\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICREXT": {"ttr": 2580, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00X\\x01\\x17\\x19_\\x01\\x18\\x03\\x7f\\x150\\x00\\x99\\x00f\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2017-07-14T00:00:00", "modifydate": "2018-02-06T15:30:58", "lines": 153, "newlines": 102, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\nrexx_msicrext:\n  rexxpgm_version = \"01.01\"          /* Set with 'ver 1' and 'lev 2'. */\n\n/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n=======================================================================\n\n  Dataset: MSIC.PDS(MSICREXT)\n  Contact: \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Syntax:  MSICREXT {input-pds} {output-ps} {,member-prefix}\n           input-pds = Where the source is.\n           output-ps = Where the IDTF records will end up.\n           member-prefix = The leftmost matching prefix.\n  Purpose: This code uses ISPF library services to gather selected\n           members and creates a transmit command of all members\n           matching the prefix.\n\n    TRANSMIT ken COPYLIST PROLOG EPILOG NOLOG +\n       NONOTIFY DATASET({input-pds}) +\n       MEMBERS({,member-prefix}) +\n       MSGDATASET('KTOMIAK.MSIC.PDS(XMIMSG)') +\n       OUTDATASET({output-ps})\n\n-----------------------------------------------------------------------\n\n History of Modifications\n ------------------------\nvv.mm When     Who / What you did ... (Newest change at the top.)\n----- -------- --------------------------------------------------------\n01.00 20180123 KTOMIAK \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Moved message into this PDS.\n               2) Corrected internal name and syntax.\n----- -------- --------------------------------------------------------\n01.00 20170714 KTOMIAK \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\nSTANDARD GLOBAL DISCLAIMER\nThe author explicitly disavows any claim whatsoever about the\ncorrectness or functionality of this program, and disclaims liability\nfor anything and everything bad that might happen in connection with,\nbefore, during, or after using it.  I have tried to make it work right,\nand I am personally pretty confident that it does, but everybody makes\nmistakes, so if you use it, you do so at your own risk.\n\n<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */\n\n  Parse Arg input_pds output_ps members\n  ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n  return_code = 0\n  say \"Dataset:\" input_pds\n  ADDRESS ISPEXEC \"LMINIT DATAID(DATAID)\",\n    \"DATASET(\"input_pds\") ENQ(SHR)\"\n  MYCC = RC\n  IF (MYCC <> 0) THEN do\n    say \"Dataset:\" input_pds \"LMINIT failed, RC(\"mycc\").\"\n    Return 16\n  End\n  allmbrs = \"\"\n  maxpfx = Words(members)\n  Do MX = 1 to maxpfx\n    Say mx \"=\" Word(members, mx)\n    extract = Strip(Word(members, mx),\"T\",\" \")\n    extractl = Length(extract)\n    ADDRESS ISPEXEC \"LMOPEN DATAID(\"DATAID\")\",\n      \"OPTION(INPUT) LRECL(MYRECLN)\"\n    MYCC = RC\n    IF (MYCC > 0) THEN do\n      say \"Dataset:\" input_pds \"LMOPEN failed, RC(\"mycc\").\"\n      Return 16\n    End\n    PDSMBR = \"\"\n    mycc = 0\n    function_rc = extract_members()\n    ADDRESS ISPEXEC \"LMMLIST DATAID(\"DATAID\") OPTION(FREE)\"\n    ADDRESS ISPEXEC \"LMCLOSE DATAID(\"DATAID\")\"\n  End\n  function_rc = normal_exit()\n  Return 0\n\nextract_members:\n  do while (mycc = 0)\n    ADDRESS ISPEXEC \"LMMLIST DATAID(\"DATAID\")\",\n      \"MEMBER(PDSMBR) STATS(NO)\"\n    MYCC = RC\n    If (MYCC = 8) THEN do\n      return 0\n    End\n    If (Left(Pdsmbr, extractl) = extract) Then Do\n      allmbrs = allmbrs Strip(PDSMBR,\"T\",\" \")\n    End\n  End\n  return 0\n\nNORMAL_EXIT:\n  ADDRESS ISPEXEC \"LMFREE DATAID(\"DATAID\")\"\n\n  maxmbrs = Words(allmbrs)\n  line_pairs = maxmbrs % 5\n  last_pairs = maxmbrs // 5\n  if (last_pairs > 0) then line_pairs = line_pairs + 1\n  say \"\"\n  say \"TRANSMIT Command:\"\n  say \"-----------------\"\n  cmdtxt = \"TRANSMIT ken COPYLIST PROLOG EPILOG NOLOG +\"\n  say cmdtxt\n  queue cmdtxt\n  cmdtxt = \"NONOTIFY DATASET(\"input_pds\") +\"\n  say cmdtxt\n  queue cmdtxt\n  If (allmbrs <> \"\") Then Do\n    endtxt = \" +\"\n    Do mx = 1 to line_pairs\n      parse var allmbrs mbr1 mbr2 mbr3 mbr4 mbr5 allmbrs\n      mbr1 = Strip(mbr1,\"B\",\" \")\n      mbr2 = Strip(mbr2,\"B\",\" \")\n      mbr3 = Strip(mbr3,\"B\",\" \")\n      mbr4 = Strip(mbr4,\"B\",\" \")\n      mbr5 = Strip(mbr5,\"B\",\" \")\n      If (mx = 1) Then Do\n        cmdtxt = \"MEMBERS(\"\n      End\n      If (mx = line_pairs) Then Do\n        endtxt = \") +\"\n      End\n      If (mbr2 <> \"\") Then mbr1 = mbr1\", \"\n      If (mbr3 <> \"\") Then mbr2 = mbr2\", \"\n      If (mbr4 <> \"\") Then mbr3 = mbr3\", \"\n      If (mbr5 <> \"\") Then mbr4 = mbr4\", \"\n      If (mx < line_pairs) then mbr5 = mbr5\",\"\n      cmdtxt = cmdtxt||mbr1||mbr2||mbr3||mbr4||mbr5||endtxt\n      say cmdtxt\n      queue cmdtxt\n      cmdtxt = \"\"\n    End\n  End\n  cmdtxt = \"MSGDATASET('KTOMIAK.MSIC.PDS(XMIMSG)') +\"\n  say cmdtxt\n  queue cmdtxt\n  cmdtxt = \"OUTDATASET(\"output_ps\")\"\n  say cmdtxt\n  queue cmdtxt\n  cmdtxt = \"\"\n  say cmdtxt\n  queue cmdtxt\n  cmdlen = Queued()\n  Address MVS ,\n    \"EXECIO * DISKW TRANSMIT (Finis)\"\n  SAY \"EXITING MICREXT.\"\n  return return_code\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICRMBR": {"ttr": 2584, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00&\\x01\\x17 \\x9f\\x01\\x17$_\\x142\\x00\\xda\\x00\\xe1\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2017-07-28T00:00:00", "modifydate": "2017-09-02T14:32:26", "lines": 218, "newlines": 225, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\nrexx_MSICRMBR:\n  rexxpgm_version = \"01.00\"          /* Set with 'ver 1' and 'lev 2'. */\n\n  Address ISREDIT 'MACRO () NOPROCESS'\n  Address ISPEXEC \"CONTROL ERRORS Return\"\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nrexx_Main_Code:\n  return_code = Initialization_routine()\n  If (return_code = 0) Then Do\n    return_code = Process_routine()\n  End\n  return_code = Termination_routine()\n  Address ISREDIT \"MEND\"\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF edit macro called to do variable\n            replacement in identified members.\n\n  Syntax: Address ISPEXEC \"EDIT DATASET('abc.xyz(mbr)') Macro(MSICREDT)\"\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.01 20170822 \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Added compress if save RC = 12.\n----- -------- --------------------------------------------------------\n01.00 20170729 \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_routine:\n  return_code = 0\n  compress_free = 0\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_routine:\n  Address ISPEXEC \"TBOpen VDEFTABL NOWRITE SHARE\"\n  tbopen_rc = RC\n  If (tbopen_rc <> 0) Then Do\n    Say \"TBOpen failed, RC(\"tbopen_rc\").\"\n    return tbopen_rc\n  End\n  Address ISPEXEC \"TBSort VDEFTABL Fields(VDEFVAR)\"\n  Do loop = 1 to 2\n    Address ISPEXEC \"TBTop VDEFTABL\"\n    tbskip_rc = 0\n    Do While (tbskip_rc = 0)\n      Address ISPEXEC \"TBSkip VDEFTABL\"\n      tbskip_rc = RC\n      If (tbskip_rc = 0) Then Do\n        vdefval = Strip(vdefval,\"T\",\" \")\n        If (Pos(\"'\",vdefval) > 0) Then Do\n          Address ISREDIT 'c \"!'vdefvar'!\" \"&vdefval\" all'\n          isredit_rc = RC\n        End\n        Else Do\n          Address ISREDIT \"c '!\"vdefvar\"!' '&vdefval' all\"\n          isredit_rc = RC\n        End\n      End\n    End\n  End\n  Address ISPEXEC \"TBEnd VDEFTABL\"\n\n  Address ISREDIT \"(ischange) = DATA_CHANGED\"\n  If (ischange = \"YES\") Then Do\n    Address ISREDIT \"SAVE\"\n    save_rc = RC\n    If (save_rc = 0) Then Do\n      Address ISREDIT \"End\"\n    End\n    Else Do\n      ADDRESS ISREDIT \"(CURRDSN) = DATASET\"\n      currdsn = \"'\"currdsn\"'\"\n      compress_rc = Compress_CURRDSN()\n      If (compress_rc = 0) Then Do\n        Address ISREDIT \"SAVE\"\n        save_rc = RC\n        If (save_rc = 0) Then Do\n          Address ISREDIT \"End\"\n        End\n        Else Do\n          Address ISREDIT \"Cancel\"\n        End\n      End\n    End\n  End\n  Else Do\n    Address ISREDIT \"CANCEL\"\n  End\n\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_routine:\n  If (compress_free = 1) Then Do\n    Address TSO \"Free File(SYSUT1)\"\n    Address TSO \"Free File(SYSUT2)\"\n    Address TSO \"Free File(SYSPRINT)\"\n    Address TSO \"Free File(SYSIN)\"\n  End\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine runs IEBCOPY to compress the PDS.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nCompress_CURRDSN:\n  compress_free = 1\n  Address TSO \"Alloc File(SYSUT1) DataSet(\"CURRDSN\") OLD REUSE\"\n  sysut1_rc = RC\n  If (sysut1_rc <> 0) Then Do\n    Say \"Sorry, Alloc //SYSUT1    DD DISP=OLD,DSN=\"CURRDSN ,\n      \"failed, RC(\"sysut1_rc\").\"\n    return sysut1_rc\n  End\n  Address TSO \"Alloc File(SYSUT2) DataSet(\"CURRDSN\") OLD REUSE\"\n  sysut2_rc = RC\n  If (sysut2_rc <> 0) Then Do\n    Say \"Sorry, Alloc //SYSUT2    DD DISP=OLD,DSN=\"CURRDSN ,\n      \"failed, RC(\"sysut2_rc\").\"\n    return sysut2_rc\n  End\n  Address TSO \"Alloc File(SYSPRINT) NEW DELETE REUSE\" ,\n    \"TRACKS SPACE(1,1)\" ,\n    \"DSORG(PS) RECFM(F B A) BLKSIZE(0) LRECL(121)\"\n  SYSPRINT_rc = RC\n  If (SYSPRINT_rc <> 0) Then Do\n    Say \"Sorry, Alloc //SYSPRINT  DD DSN=&&temp\" ,\n      \"failed, RC(\"SYSPRINT_rc\").\"\n    return SYSPRINT_rc\n  End\n  Address TSO \"Alloc File(SYSIN) NEW DELETE REUSE\" ,\n    \"TRACKS SPACE(1,1)\" ,\n    \"DSORG(PS) RECFM(F) BLKSIZE(80) LRECL(80)\"\n  SYSIN_rc = RC\n  If (SYSIN_rc <> 0) Then Do\n    Say \"Sorry, Alloc //SYSIN     DD DSN=&&temp\" ,\n      \"failed, RC(\"SYSIN_rc\").\"\n    return SYSIN_rc\n  End\n  Address TSO \"MAKEBUF\"\n  Queue \" COPY OUTDD=SYSUT2,INDD=SYSUT1\"\n  Address MVS \"EXECIO\" queued() \"DISKW SYSIN (Finis)\"\n  Address TSO \"DROPBUF\"\n  Call   On ERROR    Name ERROR_HANDLER_ROUTINE\n  Call   On FAILURE  Name ERROR_HANDLER_ROUTINE\n  address LINKMVS \"IEBCOPY\"\n  iebcopy_rc = RC\ngood_004:\n  Call   Off ERROR\n  Call   Off FAILURE\n  /*\n  Address MVS \"ExecIO * DISKR SYSPRINT (Stem iebc. Finis)\"\n  Say \"SYSPRINT has\" iebc.0 \"record(s).\"\n  ix = iebc.0\n  Say Left(iebc.ix,79)\n  */\n/*  IEB147I END OF JOB - 0 WAS HIGHEST SEVERITY CODE */\n  return iebcopy_rc\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine handles several conditions and returns after the fault.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nERROR_HANDLER_ROUTINE:\n  err_rc   = RC\n  signal_type = Condition(\"C\")\n  error_code = -1\n  Select\n    When (signal_type = \"ERROR\") Then error_code = 8\n    When (signal_type = \"FAILURE\") Then error_code = 12\n    When (signal_type = \"HALT\") Then error_code = 16\n    When (signal_type = \"NOVALUE\") Then error_code = 2\n    When (signal_type = \"SYNTAX\") Then error_code = 4\n    Otherwise error_code = 20\n  End\n  result = err_rc\n  Signal Value signal_type\"_\"come_back\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n End of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICRSUB": {"ttr": 2821, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00C\\x01\\x17!\\x0f\\x01\\x17$_\\x142\\x00S\\x00r\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-07-29T00:00:00", "modifydate": "2017-09-02T14:32:43", "lines": 83, "newlines": 114, "modlines": 0, "user": "KTOMIAK"}, "text": "/* We first need rexx in comment if compiled or read from SYSPROC. */\nrexx_msicrsub:\n  rexxpgm_version = \"01.00\"          /* Set with 'ver 1' and 'lev 2'. */\n\n  Address ISREDIT 'MACRO () NOPROCESS'\n  Address ISPEXEC \"CONTROL ERRORS Return\"\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This code drives Initialization, Process, and Termination routines.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nrexx_Main_Code:\n  return_code = Initialization_routine()\n  If (return_code = 0) Then Do\n    return_code = Process_routine()\n  End\n  return_code = Termination_routine()\n  Address ISREDIT \"MEND\"\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n  Contact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n  Overview: This is an ISPF edit macro called to do guide the person\n            to submitting a member.\n\n  Syntax:   Called from MSIC.\n\n\n=======================================================================\n\n  History of Modifications\n  ------------------------\nvv.mm When     Who  /  What you did\n----- -------- --------------------------------------------------------\n01.00 20170729 \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n               1) Original code started.\n\n----- -------- --------------------------------------------------------\n\n=======================================================================\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine initializes constants and variables.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nInitialization_routine:\n  return_code = 0\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does the processing.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nProcess_routine:\n  lptr = 1\n  infodata = \" \"\n  Address IsrEdit \"LINE_BEFORE &lptr = INFOLINE '&infodata'\"\n  lb_rc = RC\n  infodata = \"Make any site dependent changes and then submit.\"\n  Address IsrEdit \"LINE_BEFORE &lptr = NOTELINE '&infodata'\"\n  infodata = \" \"\n  Address IsrEdit \"LINE_BEFORE &lptr = INFOLINE '&infodata'\"\n  return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\n This routine does any pre-termination cleanup.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nTermination_routine:\n  Return return_code\n\n/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n=======================================================================\nEnd of code.\n=======================================================================\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICT000": {"ttr": 2824, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00V\\x01\\x17\"_\\x01\\x17$_\\x142\\x00&\\x00$\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2017-08-13T00:00:00", "modifydate": "2017-09-02T14:32:56", "lines": 38, "newlines": 36, "modlines": 0, "user": "KTOMIAK"}, "text": ")ATTR DEFAULT(%+_)\n      /*  % TYPE(TEXT) INTENS(HIGH)      defaults displayed for      */\n      /*  + TYPE(TEXT) INTENS(LOW)       information only            */\n      /*  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)             */\n)BODY Expand(||)\n%|-| MSIC: Tutorial |-|\n%SELECTION ===>_ZCMD                                                           +\n%\n%           -----------------------------------------------------\n            ! Mainframe Software Installation Customizer (MSIC) !\n            -----------------------------------------------------\n+\nThis SHAREWARE tool assists in installing other tools that conform to the MSIC\ndesign. You, the end-user, benefit from having a similar installation and\ncustomization experience. The tool author benfits from not having to create a\nnew process.\n\n   The following topics are presented in sequence, or may be selected by\n   number:\n\n  %1+ DS34       - ISPF 3.4-like list of IDTF data sets.\n  %2+ Tasks      - Executing tasks to install a Tool.\n+\n   The following topic will be presented only if selected by number:\n\n  %3+ Variables  - Setting values for customization variables.\n\n)PROC\n&ZSEL = TRANS( &ZCMD\n           1,MSICT001\n           2,MSICT002\n           3,*MSICT003\n           *,'?'\n           )\n&ZUP = MSICPHLP\n&ZDOWN = MSICT001\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICT001": {"ttr": 2826, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x05\\x01\\x17\"_\\x01\\x17$_\\x143\\x00\\x1d\\x00\\x13\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2017-08-13T00:00:00", "modifydate": "2017-09-02T14:33:05", "lines": 29, "newlines": 19, "modlines": 0, "user": "KTOMIAK"}, "text": ")ATTR DEFAULT(%+_)\n      /*  % TYPE(TEXT) INTENS(HIGH)      defaults displayed for      */\n      /*  + TYPE(TEXT) INTENS(LOW)       information only            */\n      /*  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)             */\n)BODY Expand(||)\n%|-| MSIC: Tutorial: DS34 |-|\n%Command ===>_ZCMD | |\n%\n%           -----------------------------------------------------\n            ! Mainframe Software Installation Customizer (MSIC) !\n            -----------------------------------------------------\n+\n\n  %1+ DS34       - ISPF 3.4-like list of IDTF data sets.\n\nFrom the DS34 panel you can rceive IDTF data sets. If the resulting\nEXTrACT data set is MSIC compliant then you will automatically continue\non to the Installation and Customizer routines.\n\nYou can also change the DS34 pattern to find previously received data sets\nand run INSTALL manually.\n\nYou can also Browse, Edit, and View the data sets.\n\n)PROC\n&ZUP = MSICT000\n&ZDOWN = MSICT002\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICT002": {"ttr": 2828, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x16\\x01\\x17\"o\\x01\\x17$_\\x143\\x00\\x19\\x00\\x13\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2017-08-14T00:00:00", "modifydate": "2017-09-02T14:33:16", "lines": 25, "newlines": 19, "modlines": 0, "user": "KTOMIAK"}, "text": ")ATTR DEFAULT(%+_)\n      /*  % TYPE(TEXT) INTENS(HIGH)      defaults displayed for      */\n      /*  + TYPE(TEXT) INTENS(LOW)       information only            */\n      /*  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)             */\n)BODY Expand(||)\n%|-| MSIC: Tutorial: Phrase 2 |-|\n%Command ===>_ZCMD | |\n%\n%           -----------------------------------------------------\n            ! Mainframe Software Installation Customizer (MSIC) !\n            -----------------------------------------------------\n+\n\n   %2+ Tasks      - Executing tasks to install a Tool.\n\nMSIC compliant data sets have special members that will lead you thru the\ninstallation and customizer steps to complete making the Tool available\nfor use.\n\n\n)PROC\n&ZUP = MSICT001\n&ZDOWN = ''\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSICT003": {"ttr": 2830, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00$\\x01\\x17\"o\\x01\\x17$_\\x143\\x00\\x19\\x00\\x14\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2017-08-14T00:00:00", "modifydate": "2017-09-02T14:33:24", "lines": 25, "newlines": 20, "modlines": 0, "user": "KTOMIAK"}, "text": ")ATTR DEFAULT(%+_)\n      /*  % TYPE(TEXT) INTENS(HIGH)      defaults displayed for      */\n      /*  + TYPE(TEXT) INTENS(LOW)       information only            */\n      /*  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)             */\n)BODY Expand(||)\n%|-| MSIC: Tutorial: Phrase 3 |-|\n%Command ===>_ZCMD | |\n%\n%           -----------------------------------------------------\n            ! Mainframe Software Installation Customizer (MSIC) !\n            -----------------------------------------------------\n+\n\n  %3+ Variables  - Setting values for customization variables.\n\nInstalling a MSIC compliant Tool may require you to provide values for\nvariables.\n\n\n\n)PROC\n&ZUP = MSICT000\n&ZDOWN = ''\n)END\nContact:  \"Kenneth E. Tomiak\"<CBT_Ken@KTomiak.BIZ>\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XMIMSG": {"ttr": 2832, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x08\\x01\\x18\\x02?\\x01\\x18\\x02?\\tT\\x00\\t\\x00\\t\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-01-23T00:00:00", "modifydate": "2018-01-23T09:54:08", "lines": 9, "newlines": 9, "modlines": 0, "user": "KTOMIAK"}, "text": "\nSTANDARD GLOBAL DISCLAIMER\n--------------------------\nThe author explicitly disavows any claim whatsoever about the\ncorrectness or functionality of this program, and disclaims liability\nfor anything and everything bad that might happen in connection with,\nbefore, during, or after using it. I have tried to make it work right,\nand I am personally pretty confident that it does, but everybody makes\nmistakes, so if you use it, you do so at your own risk.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT983/FILE983.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT983", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}