{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013137000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 470288, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE868.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE868.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x08\\x0b'", "DS1TRBAL": "b'\\x1d\\xe2'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x07`\\x00\\x00\\x07`\\x00\\x08\\x00\\t'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04T\\x00)\\x01\\x12\\x10\\x8f\\x01\\x12\\x10\\x8f\"\\x06\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf4@@@'", "ispf": {"version": "04.84", "flags": 0, "createdate": "2012-04-17T00:00:00", "modifydate": "2012-04-17T22:06:29", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-484"}, "text": "REGULAR CBT TAPE - VERSION 484    FILE:  868\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT484.FILE868\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 13 MEMBERS COUNTED; CUMULATIVE SIZE IS 4,101 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   04/17/12    22:06:29    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE01": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00U\\x01\\x12\\x10\\x0f\\x01\\x12\\x10\\x0f\\x11B\\x00%\\x00%\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-04-09T00:00:00", "modifydate": "2012-04-09T11:42:55", "lines": 37, "newlines": 37, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  DiskComp program\nFrom:     \"Claudio Mauceri\" <Claudio.Mauceri@hds.com>\nDate:     Sat, 7 Apr 2012 15:51:39 -0400\nTo:       <sbgolob@cbttape.org>\n\nHello Sam,\n\nRecently we have had a specific necessity, so the attached\nprogram has been created.\n\nIt is a simple (?) assembler program able to perform a\ntrack-by-track compare of two offline dasd packs.\n\nBecause I believe it could of interest for someone else, I've\ndecided to send it to you to see if it could be suitable for\ncbttape.\n\nIts invocation is pretty simple and intuitive, so I'm not sure if\nfurther explanations and comments are needed:\n\n*   Invocation:\n*      //step   EXEC PGM=DISKCOMP,\n*      //       PARM='unit1,unit2,locyl,hicyl,msgddn'\n*      //STEPLIB  DD DISP=SHR,DSN=apf.authorized.loadlib\n*      //msgddn   DD SYSOUT=*\n*\n*    locyl, hicyl and msgddn are optional\n*\n*    locyl defaults to 0\n*    hicyl defaults to highest cylinder on smallest unit\n*    msgddn defaults to SYSPRINT\n\nThe attached file is the source in zipped XMIT format.\n\nBest regards,\nClaudio Mauceri.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE02": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Q\\x01\\x12\\x10\\x8f\\x01\\x12\\x10\\x8f\\x118\\x000\\x000\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-04-17T00:00:00", "modifydate": "2012-04-17T11:38:51", "lines": 48, "newlines": 48, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  R: Help with EAV\nFrom:     \"Claudio Mauceri\" <Claudio.Mauceri@hds.com>\nDate:     Mon, 16 Apr 2012 18:50:58 -0400\nTo:       \"Sam Golob\" <sbgolob@cbttape.org>,\n          <Andreas.Freybier@beiersdorf.com>\n\nHello Sam,\n\nI've tried to modify the program in order to support EAV.\n\nThe strategy is simple: if in the last 4 bytes of RDC there's a\nvalue different from zero, the program uses it instead of\nRDCprime. Then there's just some math to play between absolute\nand normalized track address (I've used the standard TRKADDR to\nperform this stuff). Every change to program has been labeled\n@020.\n\nI've tried in several condition, with 3390-3/9 and 3390-A with\nmore of 65520 cyls, and it seems to work just fine. Here's a\nsample of the new output; note the two different track formats,\ni.e. CCCC:cccH (absolute) and cccCCCC:H (normalized):\n\ndiskcomp 0.2.0 starting compare 16 Apr 2012 14:53:26, unit1=e035,\n        unit2=e034, locyl=0017d00, hicyl=0017dff\n7d48:0010 (0017d48:0) length  mismatch, length1 is 24, length2 is 49272\n7d48:0011 (0017d48:1) length  mismatch, length1 is 24, length2 is 49272...\n\nOr, when packs are different:\n\nDevice e035 has 100170 cyls, device e030 has 3339 cyls.\n        Defaulting to 0000d0a for high cyl\ndiskcomp 0.2.0 starting compare 16 Apr 2012  4:23:29, unit1=e035,\n        unit2=e030, locyl=0000000, hicyl=0000d0a\n0000:0000 (0000000:0) compare mismatch\n0000:0001 (0000000:1) compare mismatch\n0005:0000 (0000005:0) length  mismatch, length1 is 49224, length2 is 43200\n0005:0001 (0000005:1) length  mismatch, length1 is 49224, length2 is 43200...\n\nThe problem is that the preliminary assumption (use of last four\nRDC bytes) comes just from observation and not from any IBM\ndocumentation.  So, I can't be sure that it will work in future,\nand may be is too early to give it to community.  I would like to\nhave some beta-tester... for sure I forgot to consider some\nnibble somewhere.\n\nCiao,\nClaudio.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE03": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x02\\x01\\x12\\x10\\x8f\\x01\\x12\\x10\\x8f\"\\x06\\x00 \\x00 \\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-04-17T00:00:00", "modifydate": "2012-04-17T22:06:02", "lines": 32, "newlines": 32, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  R: R: R: R: Help with EAV\nFrom:     \"Claudio Mauceri\" <Claudio.Mauceri@hds.com>\nDate:     Tue, 17 Apr 2012 18:50:03 -0400\nTo:       \"Sam Golob\" <sbgolob@cbttape.org>\n\nHello Sam,\n\nI've checked the current file 868, and I've seen that you have\nput just the version 0.2.0. I suggest you to keep in the file\nboth versions 0.1 and 0.2, for some reasons:\n\n1)      I've massively used just the 0.1, and the 0.2 has just\n        been written. So, also if I've tried the new version in\n        some circumstance, I believe it needs some more test.\n\n2)      The 0.2 uses an assumption coming from RDC\n        'reverse-engineering', and so far I've not found any IBM\n        documentation about it.\n\n3)      The 0.2 uses the relatively new macro TRKADDR for tracks\n        math, and maybe there's still someone who wants to use\n        the program with an old z/OS version. I could write the\n        program without using the macro, for example just putting\n        in it the macro expansions, but I don't like this\n        solution. If someone has an old z/OS version, without the\n        EAV support, perhaps he doesn't care about the new\n        absolute and normalized track address format, and he\n        could prefer to reduce the output.\n\nBest regards,\nClaudio.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE868": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04T\\x00\"\\x01\\x12\\x10\\x8f\\x01\\x12\\x10\\x8f\"\\x06\\x00+\\x00+\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf4@@@'", "ispf": {"version": "04.84", "flags": 0, "createdate": "2012-04-17T00:00:00", "modifydate": "2012-04-17T22:06:22", "lines": 43, "newlines": 43, "modlines": 0, "user": "CBT-484"}, "text": "//***FILE 868 is from Claudio Mauceri, and contains a program to    *   FILE 868\n//*           do a track-by-track compare of two offline DASD       *   FILE 868\n//*           packs.                                                *   FILE 868\n//*                                                                 *   FILE 868\n//*           email:  Claudio.Mauceri@hds.com                       *   FILE 868\n//*                                                                 *   FILE 868\n//*     Note from Sam Golob:  It seems to me that the packs are     *   FILE 868\n//*          not REQUIRED to be offline.  I tested with one pack    *   FILE 868\n//*          online and one pack offline.  Since they had the       *   FILE 868\n//*          same volser, only one could be online at a time.       *   FILE 868\n//*                                                                 *   FILE 868\n//*     Version 0.2.0 of DISKCOMP has EAV support.                  *   FILE 868\n//*                                                                 *   FILE 868\n//*     Version 0.1.0 of DISKCOMP is member DSKCMP01 of this pds.   *   FILE 868\n//*                                                                 *   FILE 868\n//*     DESCRIPTION:                                                *   FILE 868\n//*                                                                 *   FILE 868\n//*     Recently we have had a specific necessity, so the           *   FILE 868\n//*     attached program has been created.                          *   FILE 868\n//*                                                                 *   FILE 868\n//*     It is a simple (?) assembler program able to perform a      *   FILE 868\n//*     track-by-track compare of two offline dasd packs.           *   FILE 868\n//*                                                                 *   FILE 868\n//*     Because I believe it could of interest for someone          *   FILE 868\n//*     else, I've decided to send it to you to see if it could     *   FILE 868\n//*     be suitable for cbttape.                                    *   FILE 868\n//*                                                                 *   FILE 868\n//*     Its invocation is pretty simple and intuitive, so I'm       *   FILE 868\n//*     not sure if further explanations and comments are           *   FILE 868\n//*     needed:  (See member SAMPJCL for JCL examples.)             *   FILE 868\n//*                                                                 *   FILE 868\n//*     *   Invocation:                                             *   FILE 868\n//*     *      //step   EXEC PGM=DISKCOMP,                          *   FILE 868\n//*     *      //       PARM='unit1,unit2,locyl,hicyl,msgddn'       *   FILE 868\n//*     *      //STEPLIB  DD DISP=SHR,DSN=apf.authorized.loadlib    *   FILE 868\n//*     *      //msgddn   DD SYSOUT=*                               *   FILE 868\n//*     *                                                           *   FILE 868\n//*     *    locyl, hicyl and msgddn are optional                   *   FILE 868\n//*     *                                                           *   FILE 868\n//*     *    locyl defaults to 0                                    *   FILE 868\n//*     *    hicyl defaults to highest cylinder on smallest unit    *   FILE 868\n//*     *    msgddn defaults to SYSPRINT                            *   FILE 868\n//*                                                                 *   FILE 868\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DISKCOM$": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x02\\x00\\x11\\x01\\x12\\x10\\x0f\\x01\\x12\\x10\\x0f\\x11G\\x00\\x1d\\x00\\x1c\\x00\\x00\\xc1\\xe2\\xd4\\xd3\\xc9\\xd5\\xd2@@@'", "ispf": {"version": "00.02", "flags": 0, "createdate": "2012-04-09T00:00:00", "modifydate": "2012-04-09T11:47:11", "lines": 29, "newlines": 28, "modlines": 0, "user": "ASMLINK"}, "text": "//SBGOLOBM JOB (CCMVS),'HI FOLKS',\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.CBT484.FILE868(DISKCOMP)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n ENTRY DISKCOMP\n SETSSI  CB484868\n SETCODE AC(1)\n NAME    DISKCOMP(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DISKCOMP": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x02\\x00\\x01\\x01\\x12\\x10\\x8f\\x01\\x12\\x10\\x8f\\x11\\x10\\x07u\\x07u\\x00\\x00\\xd4\\xc1\\xe4\\xc3\\xc5\\xd9\\xc9@@@'", "ispf": {"version": "00.02", "flags": 0, "createdate": "2012-04-17T00:00:00", "modifydate": "2012-04-17T11:10:01", "lines": 1909, "newlines": 1909, "modlines": 0, "user": "MAUCERI"}, "text": "*/* -------------------------------------------------------------------\n*   Quick&Dirty program to compare two offline devices\n*\n*   Invocation:\n*      //step   EXEC PGM=DISKCOMP,\n*      //       PARM='unit1,unit2,locyl,hicyl,msgddn'\n*      //STEPLIB  DD DISP=SHR,DSN=apf.authorized.loadlib\n*      //msgddn   DD SYSOUT=*\n*\n*    locyl, hicyl and msgddn are optional\n*\n*    locyl defaults to 0\n*    hicyl defaults to highest cylinder on smallest unit\n*    msgddn defaults to SYSPRINT\n*\n*   Claudio Mauceri  Claudio.Mauceri@hds.com\n*   Greg Smith       gsmith@nc.rr.com\n*\n* Modifications:\n* @020 2012-04-17: EAV support added\n*\n* ------------------------------------------------------------------ */\n\n*/* -------------------------------------------------------------------\n*   local macros\n* ------------------------------------------------------------------ */\n         MACRO\n&L      #MSG   &MSG,&TYPE=CALL\n         LCLA  &A,&N,&O\n         LCLC  &C\n         GBLA  &MSG_IX\n         GBLC  &MSGS(256)\n         AIF   ('&TYPE' EQ 'CALL').CALL,                               x\n               ('&TYPE' EQ 'GEN').GEN\n         MNOTE 8,'Invalid type specified'\n         MEXIT\n.*\n.CALL    ANOP\n&MSG_IX  SETA  &MSG_IX+1\n&MSGS(&MSG_IX) SETC '&MSG'\n&L       L     re,=A(#MSG&MSG_IX)\n         LA    rf,L'#MSG&MSG_IX\n&A       SETA  2\n&O       SETA  0\n&N       SETA  N'&SYSLIST\n         AGO   .PL0\n.PLLOOP  ANOP\n         LA    re,&SYSLIST(&A)\n&A       SETA  &A+1\n         AIF   (&A GT &N).PLX14\n         LA    rf,&SYSLIST(&A)\n&A       SETA  &A+1\n.PL0     ANOP\n         AIF   (&A GT &N).PLX15\n         LA    r0,&SYSLIST(&A)\n&A       SETA  &A+1\n         AIF   (&A GT &N).PLX0\n         LA    r1,&SYSLIST(&A)\n&A       SETA  &A+1\n         AIF   (&A GT &N).PLX1\n         STM   re,r1,dcwmsgpl+&O\n&O       SETA  &O+16\n         AGO   .PLLOOP\n.PLX14   ST    re,dcwmsgpl+&O\n         AGO   .CALL2\n.PLX15   STM   re,rf,dcwmsgpl+&O\n         AGO   .CALL2\n.PLX0    STM   re,r0,dcwmsgpl+&O\n         AGO   .CALL2\n.PLX1    STM   re,r1,dcwmsgpl+&O\n.CALL2   LA    r1,dcwmsgpl\n         L     rf,=a(msgr)\n         BALR  re,rf\n         MEXIT\n.*\n.GEN     ANOP\n         AIF   ('&L' EQ '').GENNOL\n&L       DS    0H\n.GENNOL  ANOP\n&A       SETA  1\n.GENLOOP AIF   (&A GT &MSG_IX).MEND\n#MSG&A   DC    C&MSGS(&A)\n&A       SETA  &A+1\n         AGO   .GENLOOP\n.MEND    MEND\n\n*/* -------------------------------------------------------------------\n*   mainline routine\n* ------------------------------------------------------------------ */\nDISKCOMP CSECT ,\nDISKCOMP AMODE 31\nDISKCOMP RMODE ANY\n         j     init\n         DC    AL1(init-*)\npgmid    DC    CL8'diskcomp'\nvrm      DC    X'000200'          version 0 release 2 modlvl 0\n         DC    C' &SYSDATE &SYSTIME '\ninit     SAVE  (14,12)\n         LR    rc,rf              set base reg\n         USING DISKCOMP,rc\n         LA    ra,4095(,rc)       set 2nd base reg\n         USING (DISKCOMP+4095,mainend),ra\n         LR    r2,r1              copy parm reg\n\n*/* -------------------------------------------------------------------\n*   obtain and initialize workareas\n* ------------------------------------------------------------------ */\n         STORAGE OBTAIN,LENGTH=dcwl get work area\n         ST    r1,8(,rd)          chain save areas\n         ST    rd,4(,r1)\n         LR    rd,r1              set area base\n         USING dcw,rd\n         MVC   dcwid,=C'dcw '     set area identifier\n         LA    r0,dcw+8           clear the area\n         L     r1,=a(dcwl-8)\n         SLR   rf,rf\n         MVCL  r0,re\n         STORAGE OBTAIN,LENGTH=dcw24l,LOC=BELOW get 24-bit work area\n         ST    r1,dcw24a          save address\n         LR    rb,r1              set 24-bit area base\n         USING dcw24,rb\n         MVC   dcw24id,=C'dc24'   set 24-bit area identifier\n         LA    r0,dcw24+4         clear the 24-bit area\n         L     r1,=a(dcw24l-4)\n         SLR   rf,rf\n         MVCL  r0,re\n\n*/* -------------------------------------------------------------------\n*   process PARM= : <unit1>,<unit2>,<locyl>,<hicyl>,<msgddn>\n* ------------------------------------------------------------------ */\n         NILH  r2,X'7fff'         turn hi parameter reg bit off\n         LTR   r2,r2               test parameter reg\n         jz    Enoparm             invalid parameter list\n         L     r3,0(,r2)          point to parameters\n         NILH  r3,X'7fff'         turn hi parameters addr bit off\n         LTR   r3,r3               test parameters addr reg\n         jZ    Enoparm              invalid parameter list\n         LH    r4,0(,r3)          get length of parameters\n         LTR   r4,r4               test length\n         jnp   Enoparm              invalid parameter list\n         AHI   r4,-1              decrement length for EX\n         AHI   r3,2               point past length\n         SLR   r2,r2              clear TRT register\n\n*/*      1st parm is hex unit address of the offline device 1\n         XC    dcwdw,dcwdw        clear double-word work area\n         LA    r1,1(r3,r4)        point to parameter end\n         EX    r4,delimtrt        search for `,'\n*/*      TRT   0(0,r3),delimtab   *** executed ***                   */\n         SR    r1,r3              calculate parameter length\n         AHI   r1,-1               minus one\n         jm    Ebadparm           error if 1st parm is missing\n         CHI   r1,4               check 2nd parm length\n         jnl   Ebadparm           error if too long\n         EX    r1,parmmvc         copy 2nd parameter\n*/*      MVC   dcwdw(0),0(r3)     *** executed ***                   */\n         TR    dcwdw,upcase       convert to uppercase\n         SLR   r5,r5              clear unit address\n         EX    r1,parmhexc        test if all hex digits\n*/*      TRT   drcdw(0),hexchars  *** executed ***                   */\n         jnz   Ebadparm            error if not\n         EX    r1,parmhex         convert to hex digits\n*/*      TR    dcwdw(0),hextab    *** executed ***                   */\n         LA    rf,1(,r1)          need an extra byte for pack\n         EX    rf,parmpack        get hex value\n*/*      PACK  dcwdw2,dcwdw(0)    *** executed ***                   */\n         ICM   r5,3,dcwdw2+5      load hex value\n         STCM  r5,3,dcwunit1      save unit address\n         LA    r1,2(,r1)          length of parm + `,'\n         AR    r3,r1              point to 2nd parameter\n         SR    r4,r1              readjust length left\n\n*/*      2nd parm is hex unit address of the offline device 2\n         LTR   r4,r4              test for 2nd parm\n         jm    Ebadparm            error if offline device is missing\n         XC    dcwdw,dcwdw        clear double-word work area\n         LA    r1,1(r3,r4)        point to parameter end\n         EX    r4,delimtrt        search for `,'\n*/*      TRT   0(0,r3),delimtab   *** executed ***                   */\n         SR    r1,r3              calculate parameter length\n         AHI   r1,-1               minus one\n         jm    Ebadparm           error if 1st parm is missing\n         CHI   r1,4               check parm length\n         jnl   Ebadparm           error if too long\n         EX    r1,parmmvc         copy parameter\n*/*      MVC   dcwdw(0),0(r3)     *** executed ***                   */\n         TR    dcwdw,upcase       convert to uppercase\n         SLR   r5,r5              clear unit address\n         EX    r1,parmhexc        test if all hex digits\n*/*      TRT   drcdw(0),hexchars  *** executed ***                   */\n         jnz   Ebadparm            error if not\n         EX    r1,parmhex         convert to hex digits\n*/*      TR    dcwdw(0),hextab    *** executed ***                   */\n         LA    rf,1(,r1)          need an extra byte for pack\n         EX    rf,parmpack        get hex value\n*/*      PACK  dcwdw2,dcwdw(0)    *** executed ***                   */\n         ICM   r5,3,dcwdw2+5      load hex value\n         STCM  r5,3,dcwunit2      save unit address\n         LA    r1,2(,r1)          length of parm + `,'\n         AR    r3,r1              point to 2nd parameter\n         SR    r4,r1              readjust length left\n\n*/*      3rd parm is low cylinder to compare in hex                  */\n         SLR   r1,r1              clear reg 1\n         LHI   r5,0                -1\n         LTR   r4,r4              test for low cylinder\n         jm    gotlocyl            continue if missing\n         LA    r1,1(r3,r4)        point to parameter end\n         EX    r4,delimtrt        search for `,'\n         SR    r1,r3              calculate parameter length\n         AHI   r1,-1               minus one\n         jm    gotlocyl             continue if missing\n         XC    dcwdw,dcwdw        clear double-word work area\n         CHI   r1,7               check parm length                @020\n         jnl   Ebadparm           error if too long\n         EX    r1,parmmvc         copy parameter\n*/*      MVC   dcwdw(0),0(r3)     *** executed ***                   */\n         TR    dcwdw,upcase       convert to uppercase\n         EX    r1,parmhexc        test if all hex digits\n*/*      TRT   drcdw(0),hexchars  *** executed ***                   */\n         jnz   Ebadparm            error if not\n         EX    r1,parmhex         convert to hex digits\n*/*      TR    dcwdw(0),hextab    *** executed ***                   */\n         LA    rf,1(,r1)          need an extra byte for pack\n         EX    rf,parmpack        get hex value\n*/*      PACK  dcwdw2,dcwdw(0)    *** executed ***                   */\n         SLR   r5,r5              clear low cylinder\n*        ICM   r5,3,dcwdw2+5      load hex value                   @020\n         ICM   r5,15,dcwdw2+3     load hex value                   @020\n*gotlocyl STCM  r5,3,dcwlocyl      save low cylinder               @020\ngotlocyl ST    r5,dcwlocyl      save low cylinder                  @020\n         LA    r1,2(,r1)          length of parm + `,'\n         AR    r3,r1              point to 2nd parameter\n         SR    r4,r1              readjust length left\n\n*/*      4th parm is high cylinder to compare in hex                 */\n         SLR   r1,r1              clear reg 1\n         LHI   r5,-1               -1\n         LTR   r4,r4              test for high cylinder\n         jm    gothicyl            continue if missing\n         LA    r1,1(r3,r4)        point to parameter end\n         EX    r4,delimtrt        search for `,'\n         SR    r1,r3              calculate parameter length\n         AHI   r1,-1               minus one\n         jm    gothicyl             continue if missing\n         XC    dcwdw,dcwdw        clear double-word work area\n         CHI   r1,7               check parm length                @020\n         jnl   Ebadparm           error if too long\n         EX    r1,parmmvc         copy parameter\n         TR    dcwdw,upcase       convert to uppercase\n         EX    r1,parmhexc        test if all hex digits\n         jnz   Ebadparm            error if not\n         EX    r1,parmhex         convert to hex digits\n         LA    rf,1(,r1)          need an extra byte for pack\n         EX    rf,parmpack        get hex value\n*/*      PACK  dcwdw2,dcwdw(0)    *** executed ***                   */\n         SLR   r5,r5              clear high cylinder\n*        ICM   r5,3,dcwdw2+5      load hex value                   @020\n         icm   r5,b'1111',dcwdw2+3 load hex value                  @020\n*gothicyl STCM  r5,3,dcwhicyl      save high cylinder              @020\ngothicyl ST    r5,dcwhicyl        save high cylinder               @020\n         LA    r1,2(,r1)          length of parm + `,'\n         AR    r3,r1              point to 2nd parameter\n         SR    r4,r1              readjust length left\n\n*/*      5th (and last) parm is the message ddname                   */\n         SLR   r1,r1              clear reg 1\n         MVC   dcwprddn,=CL8'SYSPRINT' init message ddname\n         LTR   r4,r4              test length left\n         jm    gotprddn            continue if nothing left\n         LA    r1,1(r3,r4)        point to parameter end\n****     EX    r4,delimtrt        search for `,'\n         SR    r1,r3              calculate parameter length\n         AHI   r1,-1               minus one\n         jm    gotprddn            continue if missing\n         CHI   r1,8               test length\n         jnl   Ebadparm            error if too long\n         XC    dcwdw,dcwdw        clear double word work area\n         EX    r1,parmmvc         copy 3rd parameter\n         TR    dcwdw,upcase       convert to uppercase\n         MVC   dcwprddn,dcwdw     copy the message ddname\ngotprddn LA    r1,2(,r1)          length of parm + `,'\n         AR    r3,r1              point to 2nd parameter\n         SR    r4,r1              readjust length left\n\n*//FIXME: fake-open should be a subroutine\n*/* -------------------------------------------------------------------\n*   `fake-open' offline device 1\n* ------------------------------------------------------------------ */\n\n*   look for the ucb for the unit & make sure it's an offline dasd\n         MVC   dcwulpl,ulpl       copy ucblook parameter list\n         MODESET MODE=SUP\n         UCBLOOK DEVN=dcwunit1,UCBPTR=dcwucb1,PIN,PTOKEN=dcwptok1,     X\n               DYNAMIC=YES,RANGE=ALL,LOC=ANY,MF=(E,dcwulpl),           X\n               TEXT==C'DISKCOMP offline dasd lookup1'\n         STM   rf,r0,dcwretcd     save ret/rsn codes across MODESET\n         MODESET MODE=PROB\n         LM    rf,r0,dcwretcd     restore ret/rsn codes\n         LTR   rf,rf              test ucblook return code\n         LA    r2,dcwunit1         bad unit addr if error\n         jnz   Ebaducbl           ucblook error\n         OI    dcwflag1,dcwpin    indicate ucb has been pinned\n         L     r2,dcwucb1         load ucb addr\n         USING UCBOB,r2\n         CLI   UCBTBYT3,UCB3DACC  check for dasd ucb\n         jne   Ebaducbt            not a dasd unit\n         TM    UCBSTAT,UCBONLI    is device online ?\n*//CHANGE NOP to JO if unit MUST be offline\n         nop   Ebaducbs            dasd unit is not offline\n\n*   if we got a 31-bit address then we need to `capture' a 24-bit addr\n         MVC   dcwcucb1,dcwucb1   copy ucb address\n         TM    dcwucb1,X'ff'      is it a 31 bit address ?\n         jz    cucbok1             no, continue\n         MVC   dcwcupl,cupl       copy isocapu parameter list\n         MODESET MODE=SUP\n         IOSCAPU CAPTUCB,UCBPTR=dcwucb1,CAPTPTR=dcwcucb1,              X\n               MF=(E,dcwcupl)     capture a 24-bit ucb addr\n         STM   rf,r0,dcwretcd     save ret/rsn codes across MODESET\n         MODESET MODE=PROB\n         LM    rf,r0,dcwretcd     restore ret/rsn codes\n         LTR   rf,rf              test ioscapu return code\n         jnz   Ebaducbc           ioscapu error\n         OI    dcwflag1,dcwcucb   indicate ucb has been captured\n         L     r2,dcwcucb1        load captured deb addr\ncucbok1  DS    0H\n\n*   build dcb for the offline unit 1\n         MVC   dcwdcb1,moddcb     copy otptut model dcb\ndcb1     USING IHADCB,dcwdcb1\n         MVC   dcb1.DCBMACRF,dcb1.DCBMACR copy macro reference bits\n\n*   build deb for the offline unit 1\n         MODESET MODE=SUP,KEY=ZERO\n         GETMAIN RU,LV=DEBLENGTH,SP=230,LOC=BELOW\n         ST    r1,dcwdeb1         save deb address\n         XC    0(DEBLENGTH,r1),0(r1) clear the deb\n         LR    r3,r1              appendage vector table/basic sections\n         USING DEBAVT,r3\n         LA    r4,DEBBASND-DEBAVT(,r3) debdasd section\n         USING DEBDASD,r4\n         LA    r5,DEBDASDE-DEBDASD(,r4) deb extension section\n         USING DEBXTN,r5\n         L     r6,CVTPTR          get cvt address\n         USING CVT,r6\n         L     rf,CVTXAPG         ios appendage vector table\n         MVC   DEBAVT(DEBPREFX-DEBAVT),0(rf) copy vector table\n         ST    r5,DEBXTNP         set extension address\n         USING PSA,r0\n         L     r7,PSATOLD         get tcb address\n         USING TCB,r7\n         ST    r7,DEBTCBAD        set tcb address\n         OI    DEBFLGS1,DEBXTNIN  indicate extension exists\n         LA    r0,dcwdcb1         get dcb address\n         ST    r0,DEBDCBAD        set dcb address\n         MVI   DEBDEBID,15        set deb identifier\n         OC    DEBPROTG,TCBPKF    set protection key\n         ST    r3,DEBAPPAD        set appendage table address\n         STCM  r2,7,DEBUCBA       set ucb address\n         MVC   DEBXLNGH,=Y(DEBXLEN) set extension length\n         LA    r1,DEBBASIC        get basic section address\n         STCM  r1,7,dcb1.DCBDEBA  set deb address in the dcb\n         SETLOCK OBTAIN,TYPE=LOCAL,REGS=STDSAVE,MODE=UNCOND\n         MVC   DEBDEBB,TCBDEB+1   set address next deb\n         LA    r1,DEBBASIC        get basic section address\n         ST    r1,TCBDEB          chain deb to the tcb\n         SETLOCK RELEASE,TYPE=LOCAL,REGS=STDSAVE\n         MODESET MODE=PROB,KEY=NZERO\n\n*   add deb to the deb list\n         MODESET MODE=SUP,KEY=ZERO\n         DEBCHK dcwdcb1,TYPE=ADD,AM=EXCP\n         STM   rf,r0,dcwretcd\n         MODESET MODE=PROB,KEY=NZERO\n         LM    rf,r0,dcwretcd\n         LTR   rf,rf              test debchk add return code\n         jnz   Ebaddeba             debchk add failed\n         OI    dcwflag1,dcwdebad  indicate deb was added\n\n*   build the dasd extent\n         MODESET MODE=SUP,KEY=ZERO\n         ST    r2,DEBUCBAD        set 24-bit ucb addr\n         MVI   DEBDVMOD,0         set device modifier\n***      MVC   DEBENDCC,=X'7fff'  set end cylinder\n***      MVC   DEBENDHH,=X'00ff'  set end head\n***      MVC   DEBNMTRK,=X'7fff'  set number tracks in extent\n         MVC   DEBENDCC,=X'ffff'  set end cylinder\n         MVC   DEBENDHH,=X'ffff'  set end head\n         MVC   DEBNMTRK,=X'ffff'  set number tracks in extent\n         MODESET MODE=PROB,KEY=NZERO\n\n*   build the iob\niob1     USING IOBSTDRD,dcwiob1\n         OI    iob1.IOBFLAG1,IOBDATCH+IOBCMDCH+IOBUNREL\n         LA    r1,dcwecb1\n         ST    r1,iob1.IOBECBPT\n         LA    r1,dcwccw1\n         ST    r1,iob1.IOBSTART\n         LA    r1,dcwdcb1\n         ST    r1,iob1.IOBDCBPT\n\n*   turn off the `not ready' bit\n         TM    UCBFLA,UCBNRY     is `not ready' bit on ?\n         BNO   nryok1             no, continue\n         MODESET MODE=SUP,KEY=ZERO\n         NI    UCBFLA,255-UCBNRY turn off `not ready' bit\n         MODESET MODE=PROB,KEY=NZERO\n         OI    dcwflag1,dcwnry   indicate we turned the bit off\nnryok1   DS    0H\n\n*   sense the offline device unit 1\n         MODESET MODE=SUP,KEY=ZERO\n         OI    DEBXFLG2,DEBCHCMP+DEBBYP bypass excp prefixing\n         MODESET MODE=PROB,KEY=NZERO\n         LA    r8,dcwccw1\n         USING CCW0,r8\n         LA    r9,dcwiob1\n         USING IOBSTDRD,r9\n\n*        Seek\n         XC    dcwecb1,dcwecb1    clear the ecb\n         XC    dcwccw1(dcwccwl),dcwccw1 clear the ccws\n         MVI   CCW0CMD,SK         set seek command\n         LA    r1,dcwzeros\n         STCM  r1,7,CCW0ADDR      set data address\n         MVI   CCW0FLAG,CCW0SLI   set sli flag bit\n         MVC   CCW0CNT,=Y(6)      set count\n         EXCP  dcwiob1\n         WAIT  1,ECB=dcwecb1      wait for SK\n         CLI   dcwecb1,ECBNORM   test post code\n         BNE   Esnserr              error\n\n*        Sense ID\n         XC    dcwecb1,dcwecb1    clear the ecb\n         XC    dcwccw1(dcwccwl),dcwccw1 clear the ccws\n         MVI   CCW0CMD,SNSID      set sense-id command\n         LA    r1,dcwsnsi1\n         STCM  r1,7,CCW0ADDR      set data address\n         MVI   CCW0FLAG,CCW0SLI   set sli flag bit\n         MVC   CCW0CNT,=Y(L'dcwsnsi1) set count\n         EXCP  dcwiob1\n         WAIT  1,ECB=dcwecb1      wait for SNSID\n         CLI   dcwecb1,ECBNORM   test post code\n         BNE   Esnserr              error\n\n*        Sense\n         XC    dcwecb1,dcwecb1    clear the ecb\n         XC    dcwccw1(dcwccwl),dcwccw1 clear the ccws\n         MVI   CCW0CMD,SNS        set sense command\n         LA    r1,dcwsns1\n         STCM  r1,7,CCW0ADDR      set data address\n         MVI   CCW0FLAG,CCW0SLI   set sli flag bit\n         MVC   CCW0CNT,=Y(L'dcwsns1)  set count\n         EXCP  dcwiob1\n         WAIT  1,ECB=dcwecb1      wait for SNS\n         CLI   dcwecb1,ECBNORM   test post code\n         BNE   Esnserr              error\n\n*        Read Device Characteristics\n         XC    dcwecb1,dcwecb1    clear the ecb\n         XC    dcwccw1(dcwccwl),dcwccw1 clear the ccws\n         MVI   CCW0CMD,RDC        set read-characteristics command\n         LA    r1,dcwrdc1\n         STCM  r1,7,CCW0ADDR      set data address\n         MVI   CCW0FLAG,0         clear flag bits\n         MVC   CCW0CNT,=Y(L'dcwrdc1)  set count\n         EXCP  dcwiob1\n         WAIT  1,ECB=dcwecb1      wait for RDC\n         CLI   dcwecb1,ECBNORM   test post code\n         BNE   Esnserr              error\n\n*        Sense Subsystem Status\n         XC    dcwecb1,dcwecb1    clear the ecb\n         XC    dcwccw1(dcwccwl),dcwccw1 clear the ccws\n         MVI   CCW0CMD,SNSS       set sense-subsystem-status command\n         LA    r1,dcwsnss1\n         STCM  r1,7,CCW0ADDR      set data address\n         MVI   CCW0FLAG,CCW0SLI   set sli flag bit\n         MVC   CCW0CNT,=Y(L'dcwsnss1) set count\n         EXCP  dcwiob1\n         WAIT  1,ECB=dcwecb1      wait for SNSS\n         CLI   dcwecb1,ECBNORM   test post code\n         BNE   Esnserr              error\n\n         MODESET MODE=SUP,KEY=ZERO\n         NI    DEBXFLG2,255-DEBCHCMP-DEBBYP\n         MODESET MODE=PROB,KEY=NZERO\n         DROP  r2,r3,r4,r5,r6,r7,r8,r9\n\n*/* -------------------------------------------------------------------\n*   `fake-open' offline device 2\n* ------------------------------------------------------------------ */\n\n*   look for the ucb for the unit & make sure it's an offline dasd\n         MVC   dcwulpl,ulpl       copy ucblook parameter list\n         MODESET MODE=SUP\n         UCBLOOK DEVN=dcwunit2,UCBPTR=dcwucb2,PIN,PTOKEN=dcwptok2,     X\n               DYNAMIC=YES,RANGE=ALL,LOC=ANY,MF=(E,dcwulpl),           X\n               TEXT==C'DISKCOMP offline dasd lookup2'\n         STM   rf,r0,dcwretcd     save ret/rsn codes across MODESET\n         MODESET MODE=PROB\n         LM    rf,r0,dcwretcd     restore ret/rsn codes\n         LTR   rf,rf              test ucblook return code\n         LA    r2,dcwunit2         bad unit addr if error\n         jnz   Ebaducbl           ucblook error\n         OI    dcwflag2,dcwpin    indicate ucb has been pinned\n         L     r2,dcwucb2         load ucb addr\n         USING UCBOB,r2\n         CLI   UCBTBYT3,UCB3DACC  check for dasd ucb\n         jne   Ebaducbt            not a dasd unit\n         TM    UCBSTAT,UCBONLI    is device online ?\n*//CHANGE NOP to JO if unit MUST be offline\n         nop   Ebaducbs            dasd unit is not offline\n\n*   if we got a 31-bit address then we need to `capture' a 24-bit addr\n         MVC   dcwcucb2,dcwucb2   copy ucb address\n         TM    dcwucb2,X'ff'      is it a 31 bit address ?\n         jz    cucbok2             no, continue\n         MVC   dcwcupl,cupl       copy isocapu parameter list\n         MODESET MODE=SUP\n         IOSCAPU CAPTUCB,UCBPTR=dcwucb2,CAPTPTR=dcwcucb2,              X\n               MF=(E,dcwcupl)     capture a 24-bit ucb addr\n         STM   rf,r0,dcwretcd     save ret/rsn codes across MODESET\n         MODESET MODE=PROB\n         LM    rf,r0,dcwretcd     restore ret/rsn codes\n         LTR   rf,rf              test ioscapu return code\n         jnz   Ebaducbc           ioscapu error\n         OI    dcwflag2,dcwcucb   indicate ucb has been captured\n         L     r2,dcwcucb2        load captured ucb addr\ncucbok2  DS    0H\n\n*   build dcb for the offline unit 2\n         MVC   dcwdcb2,moddcb     copy otptut model dcb\ndcb2     USING IHADCB,dcwdcb2\n         MVC   dcb2.DCBMACRF,dcb2.DCBMACR copy macro reference bits\n\n*   build deb for the offline unit 2\n         MODESET MODE=SUP,KEY=ZERO\n         GETMAIN RU,LV=DEBLENGTH,SP=230,LOC=BELOW\n         ST    r1,dcwdeb2         save deb address\n         XC    0(DEBLENGTH,r1),0(r1) clear the deb\n         LR    r3,r1              appendage vector table/basic sections\n         USING DEBAVT,r3\n         LA    r4,DEBBASND-DEBAVT(,r3) debdasd section\n         USING DEBDASD,r4\n         LA    r5,DEBDASDE-DEBDASD(,r4) deb extension section\n         USING DEBXTN,r5\n         L     r6,CVTPTR          get cvt address\n         USING CVT,r6\n         L     rf,CVTXAPG         ios appendage vector table\n         MVC   DEBAVT(DEBPREFX-DEBAVT),0(rf) copy vector table\n         ST    r5,DEBXTNP         set extension address\n         USING PSA,r0\n         L     r7,PSATOLD         get tcb address\n         USING TCB,r7\n         ST    r7,DEBTCBAD        set tcb address\n         OI    DEBFLGS1,DEBXTNIN  indicate extension exists\n         LA    r0,dcwdcb2         get dcb address\n         ST    r0,DEBDCBAD        set dcb address\n         MVI   DEBDEBID,15        set deb identifier\n         OC    DEBPROTG,TCBPKF    set protection key\n         ST    r3,DEBAPPAD        set appendage table address\n         STCM  r2,7,DEBUCBA       set ucb address\n         MVC   DEBXLNGH,=Y(DEBXLEN) set extension length\n         LA    r1,DEBBASIC        get basic section address\n         STCM  r1,7,dcb2.DCBDEBA  set deb address in the dcb\n         SETLOCK OBTAIN,TYPE=LOCAL,REGS=STDSAVE,MODE=UNCOND\n         MVC   DEBDEBB,TCBDEB+1   set address next deb\n         LA    r1,DEBBASIC        get basic section address\n         ST    r1,TCBDEB          chain deb to the tcb\n         SETLOCK RELEASE,TYPE=LOCAL,REGS=STDSAVE\n         MODESET MODE=PROB,KEY=NZERO\n\n*   add deb to the deb list\n         MODESET MODE=SUP,KEY=ZERO\n         DEBCHK dcwdcb2,TYPE=ADD,AM=EXCP\n         STM   rf,r0,dcwretcd\n         MODESET MODE=PROB,KEY=NZERO\n         LM    rf,r0,dcwretcd\n         LTR   rf,rf              test debchk add return code\n         jnz   Ebaddeba             debchk add failed\n         OI    dcwflag2,dcwdebad  indicate deb was added\n\n*   build the dasd extent\n         MODESET MODE=SUP,KEY=ZERO\n         ST    r2,DEBUCBAD        set 24-bit ucb addr\n         MVI   DEBDVMOD,0         set device modifier\n***      MVC   DEBENDCC,=X'7fff'  set end cylinder\n***      MVC   DEBENDHH,=X'00ff'  set end head\n***      MVC   DEBNMTRK,=X'7fff'  set number tracks in extent\n         MVC   DEBENDCC,=X'ffff'  set end cylinder\n         MVC   DEBENDHH,=X'ffff'  set end head\n         MVC   DEBNMTRK,=X'ffff'  set number tracks in extent\n         MODESET MODE=PROB,KEY=NZERO\n\n*   build the iob\niob2     USING IOBSTDRD,dcwiob2\n         OI    iob2.IOBFLAG1,IOBDATCH+IOBCMDCH+IOBUNREL\n         LA    r1,dcwecb2\n         ST    r1,iob2.IOBECBPT\n         LA    r1,dcwccw2\n         ST    r1,iob2.IOBSTART\n         LA    r1,dcwdcb2\n         ST    r1,iob2.IOBDCBPT\n\n*   turn off the `not ready' bit\n         TM    UCBFLA,UCBNRY     is `not ready' bit on ?\n         BNO   nryok2             no, continue\n         MODESET MODE=SUP,KEY=ZERO\n         NI    UCBFLA,255-UCBNRY turn off `not ready' bit\n         MODESET MODE=PROB,KEY=NZERO\n         OI    dcwflag2,dcwnry   indicate we turned the bit off\nnryok2   DS    0H\n\n*   sense the offline device unit 2\n         MODESET MODE=SUP,KEY=ZERO\n         OI    DEBXFLG2,DEBCHCMP+DEBBYP bypass excp prefixing\n         MODESET MODE=PROB,KEY=NZERO\n         LA    r8,dcwccw2\n         USING CCW0,r8\n         LA    r9,dcwiob2\n         USING IOBSTDRD,r9\n\n*        Seek\n         XC    dcwecb2,dcwecb2    clear the ecb\n         XC    dcwccw2(dcwccwl),dcwccw2 clear the ccws\n         MVI   CCW0CMD,SK         set seek command\n         LA    r1,dcwzeros\n         STCM  r1,7,CCW0ADDR      set data address\n         MVI   CCW0FLAG,CCW0SLI   set sli flag bit\n         MVC   CCW0CNT,=Y(6)      set count\n         EXCP  dcwiob2\n         WAIT  1,ECB=dcwecb2      wait for SK\n         CLI   dcwecb2,ECBNORM   test post code\n         BNE   Esnserr              error\n\n*        Sense ID\n         XC    dcwecb2,dcwecb2    clear the ecb\n         XC    dcwccw2(dcwccwl),dcwccw2 clear the ccws\n         MVI   CCW0CMD,SNSID      set sense-id command\n         LA    r1,dcwsnsi2\n         STCM  r1,7,CCW0ADDR      set data address\n         MVI   CCW0FLAG,CCW0SLI   set sli flag bit\n         MVC   CCW0CNT,=Y(L'dcwsnsi2) set count\n         EXCP  dcwiob2\n         WAIT  1,ECB=dcwecb2      wait for SNSID\n         CLI   dcwecb2,ECBNORM   test post code\n         BNE   Esnserr              error\n\n*        Sense\n         XC    dcwecb2,dcwecb2    clear the ecb\n         XC    dcwccw2(dcwccwl),dcwccw2 clear the ccws\n         MVI   CCW0CMD,SNS        set sense command\n         LA    r1,dcwsns2\n         STCM  r1,7,CCW0ADDR      set data address\n         MVI   CCW0FLAG,CCW0SLI   set sli flag bit\n         MVC   CCW0CNT,=Y(L'dcwsns2)  set count\n         EXCP  dcwiob2\n         WAIT  1,ECB=dcwecb2      wait for SNS\n         CLI   dcwecb2,ECBNORM   test post code\n         BNE   Esnserr              error\n\n*        Read Device Characteristics\n         XC    dcwecb2,dcwecb2    clear the ecb\n         XC    dcwccw2(dcwccwl),dcwccw2 clear the ccws\n         MVI   CCW0CMD,RDC        set read-characteristics command\n         LA    r1,dcwrdc2\n         STCM  r1,7,CCW0ADDR      set data address\n         MVI   CCW0FLAG,0         clear flag bits\n         MVC   CCW0CNT,=Y(L'dcwrdc2)  set count\n         EXCP  dcwiob2\n         WAIT  1,ECB=dcwecb2      wait for RDC\n         CLI   dcwecb2,ECBNORM   test post code\n         BNE   Esnserr              error\n\n*        Sense Subsystem Status\n         XC    dcwecb2,dcwecb2    clear the ecb\n         XC    dcwccw2(dcwccwl),dcwccw2 clear the ccws\n         MVI   CCW0CMD,SNSS       set sense-subsystem-status command\n         LA    r1,dcwsnss2\n         STCM  r1,7,CCW0ADDR      set data address\n         MVI   CCW0FLAG,CCW0SLI   set sli flag bit\n         MVC   CCW0CNT,=Y(L'dcwsnss2) set count\n         EXCP  dcwiob2\n         WAIT  1,ECB=dcwecb2      wait for SNSS\n         CLI   dcwecb2,ECBNORM   test post code\n         BNE   Esnserr              error\n\n         MODESET MODE=SUP,KEY=ZERO\n         NI    DEBXFLG2,255-DEBCHCMP-DEBBYP\n         MODESET MODE=PROB,KEY=NZERO\n         DROP  r2,r3,r4,r5,r6,r7,r8,r9\n\n*/* -------------------------------------------------------------------\n*   compare tracks\n* ------------------------------------------------------------------ */\n\n*        setup buffers\n         LA    r1,dcwbufs\n         ST    r1,dcwbuf1\n         A     r1,=F'65536'\n         ST    r1,dcwbuf2\n\nrdc1     USING RDCinfo,dcwrdc1\nrdc2     USING RDCinfo,dcwrdc2\n\n*        check device types\n         clc   rdc1.RDCdevt,rdc2.RDCdevt\n         jne   Edifdevt\n\n*        get number of cylinders for unit1 and unit2 using RDCinfo @020\n         l     r1,rdc1.RDCeavc   try first if unit1 is a 3390-A    @020\n         ltr   r1,r1             is a valid number?                @020\n         jnz   is3390a1          yes, cylinders are valid          @020\n         llh   r1,rdc1.RDCprime  otherwise, load old style cyls    @020\nis3390a1 ds    0h                                                  @020\n         st    r1,dcwncyl1       save number of cyliders for unit1 @020\n         bctr  r1,0              minus 1 to have high cylinder     @020\n         l     r2,rdc2.RDCeavc   try first if unit2 is a 3390-A    @020\n         ltr   r2,r2             is a valid number?                @020\n         jnz   is3390a2          yes, cylinders are valid          @020\n         llh   r2,rdc2.RDCprime  otherwise, load old style cyls    @020\nis3390a2 ds    0h                                                  @020\n         st    r2,dcwncyl2       save number of cyliders for unit2 @020\n         bctr  r2,0              minus 1 to have high cylinder     @020\n*        llh   r0,dcwhicyl                                         @020\n         l     r0,dcwhicyl                                         @020\n*         c     r0,=A(X'0000ffff')                                 @020\n         c     r0,=A(X'ffffffff') check if no hicyl has been spec  @020\n         jne   hicylok           something has been specified      @020\n*        set default high cyl to high cyl on the smallest device\n         lr    r0,r1             save unit1 info                   @020\n         clr   r1,r2             compare unit1 and unit2 hicyl     @020\n         jnh   sethicyl          jump if unit1 is not higher       @020\n         lr    r0,r2             unit1 is higher, then use unit2   @020\n*sethicyl stcm  r0,3,dcwhicyl                                      @020\nsethicyl st    r0,dcwhicyl       save lower cylinders              @020\n*        warning if cylinders differ between the devices\n         clr   r1,r2             are hicyls different?             @020\n         je    hicylok           if not, skip defaulting message   @020\n        #MSG   'Device %x4:2 has %d:4 cyls, device %x4:2 has %d:4 cyls.X\n                Defaulting to %x7:4 for high cyl',                     X\n               dcwunit1,dcwncyl1,dcwunit2,dcwncyl2,dcwhicyl\nhicylok  DS    0H\n*        check hi cyl\n*         llh   r0,dcwhicyl                                        @020\n         l     r0,dcwhicyl                                         @020\n*        llh   r1,rdc1.RDCprime                                    @020\n         l     r1,dcwncyl1       get number of cylinders for unit1 @020\n         la    r2,dcwunit1\n         clr   r0,r1\n         jnl   Ebadhcyl\n*        llh   r1,rdc2.RDCprime                                    @020\n         l     r1,dcwncyl2       get number of cylinders for unit2 @020\n         la    r2,dcwunit2\n         clr   r0,r1\n         jnl   Ebadhcyl\n\n*        check hi cyl vs lo cyl\n*         llh   r1,dcwlocyl                                        @020\n         l     r1,dcwlocyl                                         @020\n*         llh   r2,dcwhicyl                                        @020\n         l     r2,dcwhicyl                                         @020\n         CLR   r1,r2\n         JH    Ebadlcyl\n\n*        build ecb wait list\n         LA    r1,dcwecb1\n         LA    r2,dcwecb2\n         STM   r1,r2,dcwecbl\n         OI    dcwecbl+4,x'80'\n\n*        set starting cylinder, head\n*         XC    dcwcchh,dcwcchh                                    @020\n*         MVC   dcwcc,dcwlocyl                                     @020\n         l      r0,dcwlocyl                                        @020\n         trkaddr setcyl,dcwcchh,reg=(r0)                           @020\n\n*        print initialization message\n         TIME  DEC\n         STM   r0,r1,dcwctime     get start time\n         LA    r1,dcwctime\n         LA    r0,dcwdtime\n         BAL   re,dtime\n        #MSG   '%s:8 %d:1.%d:1.%d:1 starting compare %s:20, unit1=%x4:2X\n               , unit2=%x4:2, locyl=%x7:4, hicyl=%x7:4',               X\n               pgmid,vrm,vrm+1,vrm+2,dcwdtime,                         X\n               dcwunit1,dcwunit2,dcwlocyl,dcwhicyl                     X\n\ndcloop   DS    0h\n\n*        setup unit 1 for read\n         XC    iob1.IOBSEEK,iob1.IOBSEEK\n         MVC   iob1.IOBCC,dcwcc\n         MVC   iob1.IOBHH,dcwhh\n         LA    r2,dcwccw1\n         USING CCW0,R2\n         XC    dcwccw1(dcwccwl),dcwccw1\n*        build LR ccw\n         MVI   CCW0CMD,LR\n         LA    r1,dcwlrp1\n         STCM  r1,7,CCW0ADDR\n         MVI   CCW0FLAG,CCW0CC\n         LA    r1,L'dcwlrp1\n         STCM  r1,3,CCW0CNT\n         LA    r2,CCW0END\n*        build LR parameter\n         XC    dcwlrp1,dcwlrp1\nlrp1     USING LRparm,dcwlrp1\n         MVI   lrp1.LRop,LRohome+LRrt\n         MVI   lrp1.LRcount,1\n         MVC   lrp1.LRseek,iob1.IOBCC\n         MVC   lrp1.LRsearch,iob1.IOBCC\n*        build RT ccw\n         MVI   CCW0CMD,RT\n         L     r1,dcwbuf1\n         STCM  r1,7,CCW0ADDR\n         MVI   CCW0FLAG,CCW0SLI\n         ICM   r1,7,rdc1.RDCtrkln\n         STCM  r1,3,CCW0CNT\n         DROP  r2\n*        start channel program\n         xc    dcwecb1,dcwecb1\n         EXCP  iob1.IOBSTDRD\n***      WAIT  1,ECB=dcwecb1\n\n*        setup unit 2 for read\n         XC    iob2.IOBSEEK,iob2.IOBSEEK\n         MVC   iob2.IOBCC,dcwcc\n         MVC   iob2.IOBHH,dcwhh\n         LA    r2,dcwccw2\n         USING CCW0,R2\n         XC    dcwccw2(dcwccwl),dcwccw2\n*        build LR ccw\n         MVI   CCW0CMD,LR\n         LA    r1,dcwlrp2\n         STCM  r1,7,CCW0ADDR\n         MVI   CCW0FLAG,CCW0CC\n         LA    r1,L'dcwlrp2\n         STCM  r1,3,CCW0CNT\n         LA    r2,CCW0END\n*        build LR parameter\n         XC    dcwlrp2,dcwlrp2\nlrp2     USING LRparm,dcwlrp2\n         MVI   lrp2.LRop,LRohome+LRrt\n         MVI   lrp2.LRcount,1\n         MVC   lrp2.LRseek,iob2.IOBCC\n         MVC   lrp2.LRsearch,iob2.IOBCC\n*        build RT ccw\n         MVI   CCW0CMD,RT\n         L     r1,dcwbuf2\n         STCM  r1,7,CCW0ADDR\n         MVI   CCW0FLAG,CCW0SLI\n         ICM   r1,7,rdc2.RDCtrkln\n         STCM  r1,3,CCW0CNT\n         DROP  r2\n*        start channel program\n         xc    dcwecb2,dcwecb2\n         EXCP  iob2.IOBSTDRD\n***      WAIT  1,ECB=dcwecb2\n\n         WAIT  2,ECBLIST=dcwecbl\n\n*        check i/o completion codes\n         cli   dcwecb1,ECBNORM\n         jne   Eioerr1\n         cli   dcwecb2,ECBNORM\n         jne   Eioerr2\n\n*        increment tracks read\n         L     r1,dcwtrks\n         AHI   r1,1\n         ST    r1,dcwtrks\n\n*        get track lengths\n         l     r2,dcwbuf1\n         slr   r3,r3\n         icm   r3,7,rdc1.RDCtrkln\n         llh   r0,iob1.IOBCSW8+6\n         slr   r3,r0\n         l     r4,dcwbuf2\n         slr   r5,r5\n         icm   r5,7,rdc2.RDCtrkln\n         llh   r0,iob2.IOBCSW8+6\n         slr   r5,r0\n\n*        check lengths\n         clr   r3,r5\n         je    dclenok\n         st    r3,dcwlen1\n         st    r5,dcwlen2\n         trkaddr extractcyl,dcwcchh,reg=(r1)                       @020\n         st    r1,dcwncc                                           @020\n         trkaddr extracttrk,dcwcchh,reg=(r1)                       @020\n         stcm  r1,b'0001',dcwnhh                                   @020\n        #MSG   '%x4:2:%x4:2 (%x7:4:%x1:1) length  mismatch, length1 is X\n               %d, length2 is %d',                                     X\n               dcwcc,dcwhh,dcwncc,dcwnhh,dcwlen1,dcwlen2           @020\n         l     r1,dcwdiffs\n         ahi   r1,1\n         st    r1,dcwdiffs\n         mvc   dcwrsult,=F'4'\n         j     dcnext\ndclenok  DS    0H\n\n*        compare images\n         clcl  r2,r4\n         je    dcnext\n         trkaddr extractcyl,dcwcchh,reg=(r1)                       @020\n         st    r1,dcwncc                                           @020\n         trkaddr extracttrk,dcwcchh,reg=(r1)                       @020\n         stcm  r1,b'0001',dcwnhh                                   @020\n        #MSG   '%x4:2:%x4:2 (%x7:4:%x1:1) compare mismatch',       @020X\n               dcwcc,dcwhh,dcwncc,dcwnhh                           @020\n         l     r1,dcwdiffs\n         ahi   r1,1\n         st    r1,dcwdiffs\n         mvc   dcwrsult,=F'4'\n\ndcnext   ds    0h\n*        increment head\n*         lh    r1,dcwhh                                           @020\n*         ahi   r1,1                                               @020\n*         sth   r1,dcwhh                                           @020\n*         ch    r1,rdc1.RDCheads                                   @020\n*         jl    dcloop                                             @020\n*        increment cylinder\n*         xc    dcwhh,dcwhh                                        @020\n*         llh   r1,dcwcc                                           @020\n*         ahi   r1,1                                               @020\n*         stcm  r1,3,dcwcc                                         @020\n*                                                                  @020\n*        use the powerful of trkaddr to increment track!           @020\n         trkaddr nexttrack,dcwcchh,reg=(r1)                        @020\n*         llh   r2,dcwhicyl                                        @020\n         l      r2,dcwhicyl                                        @020\n         trkaddr extractcyl,dcwcchh,reg=(r1)                       @020\n         clr   r1,r2\n         jnh   dcloop\n\n*        finished\n        #MSG   '%d tracks read, %d track differences',dcwtrks,dcwdiffs\n\n*/* -------------------------------------------------------------------\n*   cleanup and terminate\n* ------------------------------------------------------------------ */\n\nterminat DS    0H\n\n*/* call debchk to delete the debs                                   */\nterm1    TM    dcwflag1,dcwdebad was deb added to the deb chain ?\n         jno   term1a             no, continue\n         MODESET MODE=SUP,KEY=ZERO\n         DEBCHK dcwdcb1,TYPE=DELETE,AM=EXCP delete the deb\n         MODESET MODE=PROB,KEY=NZERO\n         NI    dcwflag1,255-dcwdebad\nterm1a   DS    0H\n         TM    dcwflag2,dcwdebad was deb added to the deb chain ?\n         jno   term1b             no, continue\n         MODESET MODE=SUP,KEY=ZERO\n         DEBCHK dcwdcb2,TYPE=DELETE,AM=EXCP delete the deb\n         MODESET MODE=PROB,KEY=NZERO\n         NI    dcwflag1,255-dcwdebad\nterm1b   DS    0H\n\n*/* remove deb 1 from the chain and free its storage                 */\nterm2    L     r2,dcwdeb1        load deb area addr\n         LTR   r2,r2              any deb area ?\n         BZ    term3               no, continue\n*/*      remove the deb from the deb chain                           */\n         USING DEBAVT,r2\n         LA    r3,DEBBASIC\n         DROP  r2\n         L     r4,PSATOLD-PSA    get tcb addr\n         USING TCB,r4\n         LA    r5,TCBDEB-(DEBDEBAD-DEBBASIC)\n         USING DEBBASIC,r4\n         MODESET MODE=SUP,KEY=ZERO\n         SETLOCK OBTAIN,TYPE=LOCAL,REGS=STDSAVE,MODE=UNCOND\n         SPKA  X'80'\nterm2a   LR    r4,r5\n         SLR   r5,r5\n         ICM   r5,7,DEBDEBB      addr next deb\n         BZ    term2b             exit if we didn't found ours\n         CLR   r3,r5             found our deb ?\n         BNE   term2a             no, keep looking\n         SPKA  0                   need key 0 to update a deb\n         MVC   DEBDEBB,DEBDEBB-DEBBASIC(r5) remove the deb\n         DROP  r4\nterm2b   SPKA  0                   need key 0 to update a deb\n         SETLOCK RELEASE,TYPE=LOCAL,REGS=STDSAVE\n         MODESET MODE=PROB,KEY=NZERO\n*/*      free deb storage                                            */\n         MODESET MODE=SUP,KEY=ZERO\n         FREEMAIN RU,A=(r2),LV=DEBLENGTH,SP=230 free the deb storage\n         MODESET MODE=PROB,KEY=NZERO\n         XC    dcwdeb1,dcwdeb1\n\n*/* remove deb 2 from the chain and free its storage                 */\nterm3    L     r2,dcwdeb2        load deb area addr\n         LTR   r2,r2              any deb area ?\n         BZ    term4               no, continue\n*/*      remove the deb from the deb chain                           */\n         USING DEBAVT,r2\n         LA    r3,DEBBASIC\n         DROP  r2\n         L     r4,PSATOLD-PSA    get tcb addr\n         USING TCB,r4\n         LA    r5,TCBDEB-(DEBDEBAD-DEBBASIC)\n         USING DEBBASIC,r4\n         MODESET MODE=SUP,KEY=ZERO\n         SETLOCK OBTAIN,TYPE=LOCAL,REGS=STDSAVE,MODE=UNCOND\n         SPKA  X'80'\nterm3a   LR    r4,r5\n         SLR   r5,r5\n         ICM   r5,7,DEBDEBB      addr next deb\n         BZ    term3b             exit if we didn't found ours\n         CLR   r3,r5             found our deb ?\n         BNE   term3a             no, keep looking\n         SPKA  0                   need key 0 to update a deb\n         MVC   DEBDEBB,DEBDEBB-DEBBASIC(r5) remove the deb\n         DROP  r4\nterm3b   SPKA  0                   need key 0 to update a deb\n         SETLOCK RELEASE,TYPE=LOCAL,REGS=STDSAVE\n         MODESET MODE=PROB,KEY=NZERO\n*/*      free deb storage                                            */\n         MODESET MODE=SUP,KEY=ZERO\n         FREEMAIN RU,A=(r2),LV=DEBLENGTH,SP=230 free the deb storage\n         MODESET MODE=PROB,KEY=NZERO\n         XC    dcwdeb2,dcwdeb2\n\n*/*      turn the ucb `not ready' bit back on if we turned it off    */\nterm4    TM    dcwflag1,dcwnry   did we turn the bit off ?\n         BNO   term4a             no, continue\n         L     r2,dcwucb1        load ucb address\n         USING UCBOB,r2\n         MODESET MODE=SUP,KEY=ZERO\n         OI    UCBFLA,UCBNRY     turn the bit back on\n         MODESET MODE=PROB,KEY=NZERO\n         DROP  r2\nterm4a   TM    dcwflag2,dcwnry   did we turn the bit off ?\n         BNO   term4b             no, continue\n         L     r2,dcwucb1        load ucb address\n         USING UCBOB,r2\n         MODESET MODE=SUP,KEY=ZERO\n         OI    UCBFLA,UCBNRY     turn the bit back on\n         MODESET MODE=PROB,KEY=NZERO\n         DROP  r2\nterm4b   DS    0H\n\n*/*      uncapture the ucbs                                          */\nterm5    TM    dcwflag1,dcwcucb  was ucb captured ?\n         jno   term5a             no, continue\n         MVC   dcwcupl,cupl        copy isocapu parameter list\n         MODESET MODE=SUP\n         IOSCAPU UCAPTUCB,CAPTPTR=dcwcucb1,                            X\n               MF=(E,dcwcupl)       uncapture the 24-bit ucb addr\n         MODESET MODE=PROB\nterm5a   TM    dcwflag2,dcwcucb  was ucb captured ?\n         jno   term5b             no, continue\n         MVC   dcwcupl,cupl        copy isocapu parameter list\n         MODESET MODE=SUP\n         IOSCAPU UCAPTUCB,CAPTPTR=dcwcucb2,                            X\n               MF=(E,dcwcupl)       uncapture the 24-bit ucb addr\n         MODESET MODE=PROB\nterm5b   DS    0H\n\n*/*      unpin the ucbs                                              */\nterm6    TM    dcwflag1,dcwpin   was ucb pinned ?\n         BNO   term6a             no, continue\n         MVC   dcwuupl,uupl        copy ucbpin unpin  parameter list\n         MODESET MODE=SUP\n         UCBPIN UNPIN,PTOKEN=dcwptok1,MF=(E,dcwuupl)  unpin the ucb\n         MODESET MODE=PROB\nterm6a   TM    dcwflag2,dcwpin   was ucb pinned ?\n         BNO   term6b             no, continue\n         MVC   dcwuupl,uupl        copy ucbpin unpin  parameter list\n         MODESET MODE=SUP\n         UCBPIN UNPIN,PTOKEN=dcwptok2,MF=(E,dcwuupl)  unpin the ucb\n         MODESET MODE=PROB\nterm6b   DS    0H\n\n*/* close the sysprint file                                          */\nterm7    DS    0H\npdcb     USING IHADCB,dcwpdcb\n         TM    pdcb.DCBOFLGS,DCBOFOPN is sysprint file open ?\n         BNO   term8                    no, continue\n         CLOSE (dcwpdcb),MODE=31,MF=(E,dcwopenl)\n\n*/*      free the work areas                                         */\nterm8    DS    0H\n         STORAGE RELEASE,ADDR=(rb),LENGTH=dcw24l free 24-bit area\n         LR    r1,rd\n         L     r2,dcwrsult\n         L     rd,4(,rd)\n         STORAGE RELEASE,ADDR=(1),LENGTH=dcwl   free work area\n\n         LR    rf,r2                            copy result reg\n         RETURN (14,12),RC=(15)\n\n*/* -------------------------------------------------------------------\n*   format date & time\n* ------------------------------------------------------------------ */\ndtime    STM   re,r2,12(rd)       save some regs\n         LR    r2,r0              copy output area address\n         MVI   0(r2),C' '         blank the output area\n         MVC   1(19,r2),0(r2)\n         MVC   11(9,r2),=X'4021207a20207a2020' edit pattern for time\n         ED    11(9,r2),0(r1)     edited time\n         XC    dcwdw,dcwdw        clear double word work area\n         SLR   rf,rf\n         ICM   rf,3,4(r1)         decimal year\n         SLL   rf,4               shift over a nibble\n         ST    rf,dcwdw+4         store in the double word\n         OI    dcwdw+7,X'0f'      set bottom nibble\n         AP    dcwdw,=P'1900'     calculate the year\n         OI    dcwdw+7,X'0f'      fix bottom nibble for unpk\n         UNPK  7(4,r2),dcwdw      set the year\n         CVB   rf,dcwdw           get binary year\n         N     rf,=A(3)           test for leap year\n         BZ    *+8                 jumps if leap year\n         LA    rf,2                 else set non-leapyr offset\n         ZAP   dcwdw,6(2,r1)      get julian day in double word\n         CVB   r0,dcwdw           get julian day binary\n         LA    re,dtjtab          point to julian table\ndtfind   CH    r0,8(rf,re)        found table entry ?\n         BNH   dtfound             yes, exit loop\n         LA    re,8(,re)          point to next entry\n         B     dtfind              and loop back\ndtfound  MVC   3(3,r2),4(re)      set month from the table\n         SH    r0,0(rf,re)        calculate day of month\n         CVD   r0,dcwdw           get day of month packed\n         L     r0,dcwdw+4         load packed day\n         SLL   r0,20              shift out hi bits\n         SRL   r0,28              shift down\n         STC   r0,0(,r2)          set 1st digit of the month\n         OI    0(r2),C'0'         convert to ebcdic character\n         L     r0,dcwdw+4         load packed day\n         SLL   r0,24              shift out hi bits\n         SRL   r0,28              shift down\n         STC   r0,1(,r2)          set 2nd digit of the month\n         OI    1(r2),C'0'         convert to ebcdic character\n         LM    re,r2,12(rd)       restore regs\n         BR    re                  and thankfully return\ndtjtab   DC    Y(0,0),C'Jan '     Julian date table\n         DC    Y(31,31),C'Feb '\n         DC    Y(60,59),C'Mar '\n         DC    Y(91,90),C'Apr '\n         DC    Y(121,120),C'May '\n         DC    Y(152,151),C'Jun '\n         DC    Y(182,181),C'Jul '\n         DC    Y(213,212),C'Aug '\n         DC    Y(244,243),C'Sep '\n         DC    Y(274,273),C'Oct '\n         DC    Y(305,304),C'Nov '\n         DC    Y(335,334),C'Dec '\n         DC    Y(999,999),C'??? '\n\n*/* -------------------------------------------------------------------\n*   error routines\n* ------------------------------------------------------------------ */\n\nEnoparm #MSG   'No parameters were specified'\n         j     Eexit\nEbadparm MVC   dcwdw4,=CL8' '     init dw to blanks\n         CHI   r4,8               test parameter length left\n         jnh   *+8                 continue if not too long\n         LHI   r4,8                 else reset length\n         AHI   r4,-1              decrement for EX\n         jm    *+4+4+6             bypass copy if nothing left\n         EX    r4,*+4               copy area near the error\n         MVC   dcwdw4(0),0(r3)       (executed)\n        #MSG   '** Error in parameters near %s:8',dcwdw4\n         j     Eexit\nEbaducbl CH    RF,=Y(4)\n         je    Enoucb\n        #MSG   '** UCBLOOK error for unit %x4:2: rc 0x%x rsn 0x%x',    X\n               0(r2),dcwretcd,dcwrsncd\n         j     Eexit\nEnoucb  #MSG   '** UCB not found for unit %x4:2',0(r2)\n         j     Eexit\nEbaducbt DS    0H\n         USING UCBOB,r2\n        #MSG   '** UCB for unit %x4:2 is not dasd, type is %x:1',      X\n               UCBCHAN,UCBTBYT3\n         j     Eexit\n         DROP  r2\nEbaducbs DS    0H\n         USING UCBOB,r2\n         #MSG  '** Device %x4:2 is not offline',UCBCHAN\n         j     Eexit\n         DROP  r2\nEbaducbc DS    0H\n         USING UCBOB,r2\n         #MSG  '** IOSCAPU CAPTUCB failed for %x4:2; rc=0x%x rsn=0x%x',X\n               UCBCHAN,dcwretcd,dcwrsncd\n         j     Eexit\n         DROP  r2\nEbaddeba DS    0H\n         USING UCBOB,r2\n         #MSG  '** DEBCHK ADD for %x4:2 failed; rc=0x%x',              X\n               UCBCHAN,dcwretcd\n         j     Eexit\n         DROP  r2\nEsnserr  DS    0H\n         C     r2,dcwcucb1\n         jne   Esnserr2\nEsnserr1 #MSG  '** Sense failed for 0x%x4:2: command %x2:1, CC 0x%x2:1,X\n                Stat 0x%x4:2',dcwunit1,dcwccw1,dcwecb1,iob1.IOBSTBYT\n         j     Eexit\nEsnserr2 #MSG  '** Sense failed for 0x%x4:2: command %x2:1, CC 0x%x2:1,X\n                Stat 0x%x4:2',dcwunit2,dcwccw2,dcwecb2,iob2.IOBSTBYT\n         j     Eexit\nEdifdevt #MSG  '** Device types differ: %x4:2 is %x4:2, %x4:2 is %x4:2'X\n               ,dcwunit1,rdc1.RDCdevt,dcwunit2,rdc2.RDCdevt\n         j     Eexit\n\nEbadhcyl ahi   r1,-1\n*         stcm  r1,3,dcwcc                                         @020\n         st    r1,dcwfw                                            @020\n        #MSG   '** High cyl %x7:4 exceeds device %x4:2 high cyl %x7:4',X\n               dcwhicyl,0(r2),dcwfw\n         j     Eexit\n\nEbadlcyl #MSG  '** Low cyl %x7:4 greater than high cyl %x7:4',         X\n               dcwlocyl,dcwhicyl\n         j     Eexit\n\nEioerr1  #MSG  '** I/O error %x4:2 cchh=%x8:4 cc=%x2:1 csw=%x8:4%x8:4',X\n               dcwunit1,dcwcchh,dcwecb1,iob1.IOBCSW8,iob1.IOBCSW8+4\n         j     Eexit\n\nEioerr2  #MSG  '** I/O error %x4:2 cchh=%x8:4 cc=%x2:1 csw=%x8:4%x8:4',X\n               dcwunit2,dcwcchh,dcwecb2,iob2.IOBCSW8,iob2.IOBCSW8+4\n         j     Eexit\n\nEexit    MVC   dcwrsult,=A(16)    error return code\n         j     terminat           terminate\n\n*/* -------------------------------------------------------------------\n*   literals and constants\n* ------------------------------------------------------------------ */\n         LTORG ,\ndelimtrt TRT   0(0,r3),delimtab   *** executed ***\nparmmvc  MVC   dcwdw(0),0(r3)     *** executed ***\nparmclc  CLC   0(0,rf),dcwdw      *** executed ***\nparmhexc TRT   dcwdw(0),hexchars  *** executed ***\nparmhex  TR    dcwdw(0),hextab    *** executed ***\nparmpack PACK  dcwdw2,dcwdw(0)    *** executed ***\nmoddcb   DCB   DDNAME=0,DSORG=PS,MACRF=E\nmoddcbl  EQU   *-moddcb\nprtdcb   DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PL,DCBE=PRTDCBE\nprtdcbl  EQU   *-prtdcb\nprtdcbe  DCBE  RMODE31=BUFF\nprtdcbel EQU   *-prtdcbe\nopenl    OPEN  (0),MODE=31,MF=L\nopenll   EQU   *-openl\n         UCBLOOK MF=(L,ulpl)\n         UCBPIN MF=(L,uupl)\n         IOSCAPU MF=(L,cupl)\nhextab   DC    256X'00'\n         ORG   hextab+C'0'\n         DC    AL1(0,1,2,3,4,5,6,7,8,9)\n         ORG   hextab+C'a'\n         DC    AL1(10,11,12,13,14,15)\n         ORG   hextab+C'A'\n         DC    AL1(10,11,12,13,14,15)\n         ORG   hextab+256\ndelimtab DC    256x'0'\n         ORG   delimtab+C','\n         DC    X'ff'\n         ORG   delimtab+256\n         DROP  ,\nhexchars DC    256x'ff'\n         ORG   hexchars+C'a'\n         DC    6x'0'\n         ORG   hexchars+C'A'\n         DC    6x'0'\n         ORG   hexchars+C'0'\n         DC    10x'0'\n         ORG   hexchars+256\nupcase   DC    C' ',255AL1(*-upcase)\n         ORG   upcase+c'a'\n         DC    C'ABCDEFGHI'\n         ORG   upcase+c'j'\n         DC    C'JKLMNOPQR'\n         ORG   upcase+c's'\n         DC    C'STUVWXYZ'\n         ORG   upcase+256\nhex2char EQU   *-240\n         DC    C'0123456789ABCDEF'\n         DROP  ,\nmainend  DS    0D\n\n\n*/* -------------------------------------------------------------------\n*        subroutine to issue messages\n* ------------------------------------------------------------------ */\n          USING msgr,r9\n          USING dcw,rd\n          USING dcw24,rb\n          USING DISKCOMP,rc\n          USING (DISKCOMP+4095,mainend),ra\nmsgr      STM  r0,rf,dcwsave1\n          LR   r9,rf\n          USING IHADCB,dcwpdcb\n          TM   DCBOFLGS,DCBOFOPN\n          BO   mr_opened            continue if message file is opened\n\n          LR   r2,r1                save reg 1\n          TM   dcwflags,dcwnoprt    test if no print file\n          BO   mr_ret                return if not\n          CLI  dcwprddn,0           print ddname specified yet ?\n          BNE  mr_open2              yes, continue\n          DEVTYPE =C'SYSPRINT',dcwdw  is SYSPRINT available ?\n          LR   r1,r2                   restore reg 1\n          LTR  rf,rf                    no, issue WTO\n          BNZ  mr_opened\n          MVC  dcwprddn,=C'SYSPRINT'     else use SYSPRINT ddname\nmr_open2  MVC  dcwpdcb,prtdcb       copy the model print dcb\n          MVC  DCBDDNAM,dcwprddn    set the print ddname\n          MVC  dcwpdcbe,prtdcbe     copy model print dcbe\n          LA   r1,dcwpdcbe          set dcbe address\n          ST   r1,DCBDCBE            in the dcb\n          OI   dcwflags,dcwnoprt    presume no print\n          DEVTYPE DCBDDNAM,dcwdw    issue devtype for the ddname\n          LTR  rf,rf                test devtype return code\n          BNZ  mr_ret                return if some error\n          L    r1,=A(mr_oxit)       get address of the open exit\n          LA   rf,mr_oxitl          get open exit length\n          BCTR rf,0                 decrement\n          EX   rf,*+4               copy the open exit\n          MVC  dcwoxit(0),0(r1)     *** executed ***\n          LA   r1,dcwoxit           get open exit addr\n          ST   r1,dcwexlst          set in exit list\n          MVI  dcwexlst,x'85'       set exit type\n          LA   r1,dcwexlst          point to exit list\n          STCM r1,7,DCBEXLSA        set exlst addr in the dcb\n          MVC  dcwopenl,openl       copy model open list\n          OPEN (dcwpdcb,OUTPUT),MODE=31,MF=(E,dcwopenl)\n          TM   DCBOFLGS,DCBOFOPN    did the file open ?\n          BNO  mr_ret                no, return\n          NI   dcwflags,255-dcwnoprt  else turn off `noprt' bit\n          LR   r1,r2                restore reg 1\n\nmr_opened LM   r4,r5,0(r1)          pattern addr, length\n\n          BCTR r5,0\n          LA   r3,8(,r1)            first parameter\n          LA   r6,dcwmsg\n          MVI  dcwmsg,C' '          init msg to blanks\n          MVC  dcwmsg+1(L'dcwmsg-1),dcwmsg\n\nmr_loop   LTR  r5,r5\n          BM   mr_exit\n          LA   r1,1(r4,r5)\n          SLR  r2,r2\n          EX   r5,mr_trt1\n          SR   r1,r4                length scanned\n          BNP  mr_skip1\n          LR   rf,r1\n          BCTR rf,0\n          EX   rf,mr_mvc1           copy literal text\n          AR   r6,r1\nmr_skip1  AR   r4,r1\n          SR   r5,r1\n          BM   mr_exit\n          BP   mr_skip2\n\n          MVC  0(1,r6),0(r4)        string ends in special char\n          LA   r6,1(,r6)\n          B    mr_exit\n\nmr_skip2  B    *(r2)                br on special char type\n          B    mr_pct               '%'\n          B    mr_bs                '\\'\n\nmr_pct    CLI  1(r4),C's'\n          BE   mr_pct_s\n          CLI  1(r4),C'x'\n          BE   mr_pct_x\n          CLI  1(r4),C'd'\n          BE   mr_pct_d\n          MVC  0(1,r6),0(r4)        treat '%' as any other char\n          LA   r6,1(,r6)\n          LA   r4,1(,r4)\n          BCTR r5,0\n          B    mr_loop\nmr_pct_s  L    r7,0(,r3)            load string ptr\n          LA   r3,4(,r3)\n          LA   r4,2(,r4)            point past '%s'\n          SH   r5,=Y(2)\n          BAL  re,mr_op             r1 - target len, r2 - source len\n          LTR  r2,r2\n          BNZ  mr_pct_s3\n          LR   r2,r7                source len = 0, find end of string\nmr_pct_s1 CLI  0(r2),C' '\n          BNH  mr_pct_s2\n          LA   r2,1(,r2)\n          B    mr_pct_s1\nmr_pct_s2 SR   r2,r7\n          BNP  mr_loop\nmr_pct_s3 LR   rf,r2                copy source string to the msg\n          BCTR rf,0\n          EX   rf,mr_mvc2\n          LTR  r1,r1\n          BNZ  mr_pct_s5\n          AR   r6,r2                truncate trailing spaces if\nmr_pct_s4 BCTR r6,0                  target len is 0\n          CLI  0(r6),C' '\n          BNH  mr_pct_s4\n          LA   r6,1(,r6)\n          B    mr_loop\nmr_pct_s5 CR   r1,r2\n          BH   mr_pct_s6\n          AR   r6,r1                truncate the string\n          B    mr_loop\nmr_pct_s6 AR   r6,r2                pad string with trailing blanks\n          SR   r1,r2\nmr_pct_s7 MVI  0(r6),C' '\n          LA   r6,1(,r6)\n          BCT  r1,mr_pct_s7\n          B    mr_loop\n\nmr_pct_x  L    r7,0(,r3)            load hex ptr\n          LA   r3,4(,r3)\n          LA   r4,2(,r4)            point past '%x'\n          SH   r5,=Y(2)\n          BAL  re,mr_op             r1 - target len, r2 - source len\n          LTR  r2,r2\n          BNZ  *+8\n          LA   r2,4                 default source len is 4\n          EX   r2,mr_pct_x_unpk\n          TR   dcwdw,mr_hextab\n          LTR  r1,r1\n          BNZ  mr_pct_x1\n          LA   r1,8                 determine default target len\n          CLC  =C'00',dcwdw\n          BNE  mr_pct_x1\n          LA   r1,6\n          CLC  =C'0000',dcwdw\n          BNE  mr_pct_x1\n          LA   r1,4\n          CLC  =C'000000',dcwdw\n          BNE  mr_pct_x1\n          LA   r1,2\nmr_pct_x1 LA   r7,dcwdw+8           copy the hex string to the msg\n          SR   r7,r1\n          BCTR r1,0\n          EX   r1,mr_mvc2\n          LA   r6,1(r1,r6)\n          B    mr_loop\n\nmr_pct_d  L    r7,0(,r3)            load decimal ptr\n          LA   r3,4(,r3)\n          LA   r4,2(,r4)            point past '%d'\n          SH   r5,=Y(2)\n          BAL  re,mr_op             r1 - target len, r2 - source len\n          LTR  r2,r2\n          BNZ  *+8\n          LA   r2,4                 default source len is 4\n          LA   rf,4\n          SR   rf,r2\n          LA   re,15\n          SRL  re,0(rf)\n          EX   re,mr_pct_d_icm\n          CVD  rf,dcwdw\n         MVC  DCWDW2(16),=X'40202020202020202020202020202120'\n          ED   dcwdw2(16),dcwdw\n          LTR  r1,r1\n          BNZ  mr_pct_d2\n          LA   rf,dcwdw2+16         default length -\nmr_pct_d1 BCTR rf,0                  truncate leading spaces\n          CLI  0(rf),C' '\n          BH   mr_pct_d1\n          LA   r1,dcwdw2+15\n          SR   r1,rf\nmr_pct_d2 LA   r7,dcwdw2+16\n          SR   r7,r1\n          BCTR r1,0\n          EX   r1,mr_mvc2\n          LA   r6,1(r1,r6)\n          B    mr_loop\n\nmr_bs     MVC  0(1,r6),1(r4)        copy char following '\\'\n          LA   r6,1(,r6)\n          LA   r4,2(,r4)\n          SH   r5,=Y(2)\n          B    mr_loop\n\nmr_exit   LA   r1,dcwmsg\n          SR   r6,r1                calculate msg length\n          BNP  mr_ret\n          TM   DCBRECFM,DCBRECCA+DCBRECCM\n          BZ   *+8\n          LA   r6,1(,r6)            increment for carriage control\n\n          TM   DCBOFLGS,DCBOFOPN\n          BNO  mr_wto\n          TM   DCBRECFM,DCBRECU\n          BO   mr_u\n          TM   DCBRECFM,DCBRECF\n          BO   mr_f\n          TM   DCBRECFM,DCBRECV\n          BO   mr_v\n\nmr_u      CH   r6,DCBBLKSI\n          BNH  *+8\n          LH   r6,DCBBLKSI\n          STH  r6,DCBLRECL\n          PUT  IHADCB\n          TM   DCBRECFM,DCBRECCA+DCBRECCM\n          BZ   mr_u1\n          MVI  0(r1),C' '\n          LA   r1,1(,r1)\n          BCTR r6,0\n          TM   DCBRECFM,DCBRECCA\n          BO   mr_u1\n          BCTR r1,0\n          MVI  0(r1),X'09'\n          LA   r1,1(,r1)\nmr_u1     BCTR r6,0\n          EX   r6,mr_mvc3\n          B    mr_ret\n\nmr_f      CH   r6,DCBLRECL\n          BNH  *+8\n          LH   r6,DCBLRECL\n          PUT  IHADCB\n          TM   DCBRECFM,DCBRECCA+DCBRECCM\n          BZ   mr_f1\n          MVI  0(r1),C' '\n          LA   r1,1(,r1)\n          BCTR r6,0\n          TM   DCBRECFM,DCBRECCA\n          BO   mr_f1\n          BCTR r1,0\n          MVI  0(r1),X'09'\n          LA   r1,1(,r1)\nmr_f1     BCTR r6,0\n          EX   r6,mr_mvc3\n          B    mr_ret\n\nmr_v      LA   r6,4(,r6)\n          LH   r1,DCBBLKSI\n          SH   r1,=Y(4)\n          CR   r6,r1\n          BNH  *+6\n          LR   r6,r1\n          STH  r6,DCBLRECL\n          PUT  IHADCB\n          STH  r6,0(,r1)\n          XC   2(2,r1),2(r1)\n          LA   r1,4(,r1)\n          SH   r6,=Y(4)\n          TM   DCBRECFM,DCBRECCA+DCBRECCM\n          BZ   mr_v1\n          MVI  0(r1),C' '\n          LA   r1,1(,r1)\n          BCTR r6,0\n          TM   DCBRECFM,DCBRECCA\n          BO   mr_v1\n          BCTR r1,0\n          MVI  0(r1),X'09'\n          LA   r1,1(,r1)\nmr_v1     BCTR r6,0\n          EX   r6,mr_mvc3\n          B    mr_ret\n\nmr_wto    LA   r6,4(,r6)\n          STH  r6,dcwmsgl\n          MVC  dcwmsgl+2(2),=X'8000'\n          LA   r1,dcwmsg(r6)\n         MVC  0(4,R1),=X'00000020'\n          WTO  MF=(E,dcwmsgl)\n\n\nmr_ret    LM   r0,rf,dcwsave1\n          BR   re\n\n*/* -------------------------------------------------------------------\n* message subroutine to get operand lengths\n* ------------------------------------------------------------------ */\n\nmr_op     SLR  r1,r1\n          SLR  r2,r2\nmr_op1    LTR  r5,r5                first number is target length\n          BMR  re\n          CLI  0(r4),C'0'\n          BL   mr_op2\n          IC   rf,0(,r4)\n          N    rf,=A(X'0000000f')\n          MH   r1,=Y(10)\n          AR   r1,rf\n          LA   r4,1(,r4)\n          BCTR r5,0\n          B    mr_op1\nmr_op2    CLI  0(r4),C':'          second number follows a ':'\n          BNER re\nmr_op3    LA   r4,1(,r4)           second number is source length\n          SH   r5,=Y(1)\n          BMR  re\n          CLI  0(r4),C'0'\n          BLR  re\n          IC   rf,0(,r4)\n          N    rf,=A(X'0000000f')\n          MH   r2,=Y(10)\n          AR   r2,rf\n          B    mr_op3\n\n*/* ---------------------------------------------------------------- */\n\nmr_mvc1   MVC  0(0,r6),0(r4)\nmr_trt1   TRT  0(0,r4),mr_tab1\nmr_mvc2   MVC  0(0,r6),0(r7)\nmr_mvc3   MVC  0(0,r1),dcwmsg\nmr_pct_x_unpk  UNPK dcwdw(9),0(0,r7)\nmr_pct_d_icm   ICM rf,0,0(r7)\nmr_tab1   DC   XL256'0'\n          ORG  mr_tab1+C'%'\n          DC   AL1(4)\n          ORG  mr_tab1+C'\\'\n          DC   AL1(8)\n          ORG  mr_tab1+256\nmr_hextab EQU  *-240\n          DC   C'0123456789abcdef'\n          LTORG ,\n         #MSG  TYPE=GEN           messages\n          DROP ,\n\n\n*/* -------------------------------------------------------------------\n*   message open exit - relocated to 24 bit storage\n* ------------------------------------------------------------------ */\n\n         USING mr_oxit,rf\n         USING IHADCB,R1\nmr_oxit  CLI   DCBRECFM,0          any record format ?\n         BNE   *+8                  jumps if yes\n         MVI   DCBRECFM,DCBRECV+DCBRECBR else set to `vb'\n\n         SLR   r0,r0               get a zero\n         CH    r0,DCBLRECL         any lrecl\n         BNE   *+10                 jumps if yes\n         MVC   DCBLRECL,=Y(125)      copy default lrecl\n\n         CH    r0,DCBBLKSI         any blksize\n         BNE   *+10                 jumps if yes\n         MVC   DCBBLKSI,=Y(4096)     copy default blksize\n\n         TM    DCBRECFM,DCBRECU    test record type\n         BO    mr_oxitu             undefined\n         TM    DCBRECFM,DCBRECV    test record type\n         BO    mr_oxitv             variable\n         TM    DCBRECFM,DCBRECF    test record type\n         BO    mr_oxitf             fixed\n         B     mr_oxit0            unknown, return\n\nmr_oxitu MVC   DCBLRECL,DCBBLKSI   undefined, set lrecl from blksize\n         B     mr_oxit0            return\n\nmr_oxitv LH    r3,DCBBLKSI         variable, load blksize\n         LA    r0,4                calculate maximum\n         SR    r3,r0                lrecl\n         CH    r3,DCBLRECL         check against lrecl\n         BNL   mr_oxit0             return if not too high\n         STH   r3,DCBLRECL           else reset to max\n         B     mr_oxit0            return\n\nmr_oxitf LH    r3,DCBBLKSI         fixed, load blksize\n         SLR   r2,r2               clear for divide\n         LH    r0,DCBLRECL         load lrecl\n         DR    r2,r0               divide lrecl into blksize\n         LTR   r2,r2               test if any remainder\n         BZ    mr_oxit0            return if not\n         MH    r3,DCBLRECL         calculate new blksize\n         STH   r3,DCBBLKSI         set new blksize\n\nmr_oxit0 BR    re\n         LTORG ,\nmr_oxitl EQU   *-mr_oxit\n         DROP  ,\n\n*/* -------------------------------------------------------------------\n*   workareas\n* ------------------------------------------------------------------ */\ndcw      DSECT ,                  offline dump/restore workarea\ndcwid    DS    0CL4'dcw '         identifier\ndcwsave  DS    18F                standard save area\ndcwsave0 DS    16F                save area for dumpr/restorer\ndcwsave1 DS    16F                save area for writer\ndcw24a   DS    A                  24-bit work area address\ndcwrsult DS    F                  result (return) value\ndcwfcn   DS    CL8                function (backup or restore)\ndcwflags DS    X                  flag bits\ndcwnoprt EQU   X'80'              messsage dataset not available\ndcwflag1 DS    X                  flag bits for unit 1\ndcwflag2 DS    X                  flag bits for unit 2\ndcwpin   EQU   X'80'              offline dasd ucb pinned\ndcwcucb  EQU   X'40'              offline dasd ucb captured\ndcwdebad EQU   X'20'              offline dasd ucb deb added\ndcwnry   EQU   X'10'              offline dasd ucb `not ready' bit\ndcwunit1 DS    H                  offline unit 1 address\ndcwunit2 DS    H                  offline unit 2 address\ndcwlocyl DS    F                  low cylinder to dump             @020\ndcwhicyl DS    F                  high cylinder to dump            @020\ndcwncyl1 DS    F                  number of cylinders for unit1    @020\ndcwncyl2 DS    F                  number of cylinders for unit2    @020\ndcwretcd DS    F                  return code\ndcwrsncd DS    F                  reason code\ndcwucb1  DS    A                  ucb 1 address\ndcwucb2  DS    A                  ucb 2 address\ndcwcucb1 DS    A                  captured ucb 1 address\ndcwcucb2 DS    A                  captured ucb 2 address\ndcwdeb1  DS    A                  deb 1 address\ndcwdeb2  DS    A                  deb 2 address\ndcwptok1 DS    D                  ucb 1 pin token\ndcwptok2 DS    D                  ucb 2 pin token\ndcwctime DS    D                  current date/time\ndcwdtime DS    CL20               dat/time display area\ndcwdw    DS    D                  double word work areas\ndcwdw2   DS    D\ndcwdw3   DS    D\ndcwdw4   DS    D\ndcwfw    DS    F                  full word work areas             @020\ndcwtrks  DS    F                  tracks read\ndcwdiffs DS    F                  differences found\ndcwlen1  DS    F                  unit 1 track length\ndcwlen2  DS    F                  unit 2 track length\n         DS    0D\ndcwprddn DS    CL8                print ddname\ndcwpdcbe DS    XL(prtdcbel)       print dcbe\n         DS    0D\ndcwopenl DS    XL(openll)         open parameter list\n         DS    0D\ndcwulpl  DS    XL(ulpll)          ucblook parameter list\n         DS    0D\ndcwuupl  DS    XL(uupll)          ucbpin unpin parameter list\n         DS    0D\ndcwcupl  DS    XL(cupll)          ioscapu parameter list\n         DS    0D\ndcwmsgl  DS    F                  message length (for WTO)\ndcwmsg   DS    CL256              message\ndcwmsgpl DS    24F                message parameter list\ndcwl     EQU   *-dcw\n\ndcw24    DSECT ,                  24-bit work area\ndcw24id  DC    CL4'dc24'          identifier\ndcwzeros DS    XL16               24-bit zeroes\ndcwpdcb  DS    XL(prtdcbl)        print dcb\ndcwexlst DS    F                  dcb exit list\ndcwdcb1  DS    XL(moddcbl)        device 1 dcb\ndcwccw1  DS    8D                 device 1 channel program\ndcwccwl  EQU   *-dcwccw1                   channel program length\ndcwiob1  DS    XL40               device 1 iob\ndcwlrp1  DS    XL16               device 1 locate record parm area\ndcwecb1  DS    F                  device 1 ecb\ndcwsnsi1 DS    XL20               device 1 snsid info\ndcwrdc1  DS    XL64               device 1 rdc info\ndcwrcd1  DS    XL256              device 1 rcd info\ndcwsnss1 DS    XL40               device 1 snss info\ndcwsns1  DS    XL32               device 1 sense info\ndcwdcb2  DS    XL(moddcbl)        device 2 dcb\ndcwccw2  DS    8D                 device 2 channel program\ndcwiob2  DS    XL40               device 2 iob\ndcwlrp2  DS    XL16               device 2 locate record parm area\ndcwecb2  DS    F                  device 2 ecb\ndcwsnsi2 DS    XL20               device 2 snsid info\ndcwrdc2  DS    XL64               device 2 rdc info\ndcwrcd2  DS    XL256              device 2 rcd info\ndcwsnss2 DS    XL40               device 2 snss info\ndcwsns2  DS    XL32               device 2 sense info\ndcwoxit  DS    XL256              relocated message open exit\ndcwcchh  DS    0F                 current cchh in absolute trk adr @020\ndcwcc    DS    H\ndcwhh    DS    H\ndcwncchh DS    0XL5               current cchh in normalized fmt   @020\ndcwncc   DS    F                  current cc in normalized fmt     @020\ndcwnhh   DS    X                  current hh in normalized fmt     @020\n         DS    0D\ndcwecbl  DS    2A                 ecb wait list\ndcwbuf1  DS    A                  device 1 buffer address\ndcwbuf2  DS    A                  device 2 buffer address\ndcwbufs  DS    (2*65536)X         buffers\ndcw24l   EQU   *-dcw24\n\nRDCinfo  DSECT ,                  read device characteristics info\nRDCsdt   DS    XL2                storage director type\nRDCsdmi  DS    X                  storage director model information\nRDCdevt  DS    XL2                device type\nRDCdevm  DS    X                  device model\nRDCdasdf DS    XL4                device & storage director facilities\nRDCclass DS    X                  device class code\nRDCtype  DS    X                  device type code\nRDCprime DS    XL2                number of primary cylinders\nRDCheads DS    XL2                tracks per cylinder\nRDCsctrs DS    X                  number of sectors\nRDCtrkln DS    XL3                total track length (usable)\nRDChar0  DS    XL2                length of ha and r0\nRDCtccf  DS    X                  track capacity calculation formula\nRDCfctrs DS    XL5                track capacity calculation factors\nRDCacyl  DS    XL2                address of first alternate cylinder\nRDCacyln DS    XL2                number of alternate tracks\nRDCdcyl  DS    XL2                address of first diagnostic cylinder\nRDCdcyln DS    XL2                number of diagnostic tracks\nRDCscyl  DS    XL2                address of first device support cyl\nRDCscyln DS    XL2                number of device support tracks\nRDCmdrid DS    X                  mdr record id\nRDCobrid DS    X                  obr record id\nRDCsdtc  DS    X                  storage director type code\nRDCrtspl DS    X                  read trackset parameter length\nRDCmaxr0 DS    XL2                maximum record zero data length\n         DS    X                  (reserved)\nRDCtss   DS    X                  track set size\nRDCatccf DS    X                  additional track capacity calc. factr\nRDCrps   DS    XL2                rps sector calculation factors\n         DS    XL3                (reserved)\nRDCgdff  DS    X                  generic device/cu functions/features\n         DS    X                  (reserved -- zeroes)\nRDCrduc  DS    X                  real control unit code\nRDCrdc   DS    X                  real device code\n*         DS    XL6                (reserved)                      @020\n         DS    XL2                (reserved)                       @020\nRDCeavc  DS    XL4                number of cylinders for 3390-A   @020\nRDCinfol EQU   *-RDCinfo\n\nLRparm   DSECT ,                  locate record paramete\nLRop     DS    X                  operation byte\nLRocount EQU   B'00000000'        orient count\nLRohome  EQU   B'01000000'        orient home\nLRodata  EQU   B'10000000'        orient data\nLRoindex EQU   B'11000000'        orient index\nLRorient EQU   X'00'              orient\nLRwrite  EQU   X'01'              write data\nLRfwrite EQU   X'03'              format write\nLRread   EQU   X'06'              read data\nLRwt     EQU   X'0b'              write track\nLRrt     EQU   X'0c'              read tracks\nLRrd     EQU   X'16'              read\nLRaux    DS    X                  auxiliary byte\nLRusetlf EQU   B'10000000'        transfer length factor specified\nLRrcccw  EQU   B'00000001'        a read count ccw is suffixed\n         DS    X\nLRcount  DS    X                  count parameter\nLRseek   DS    0XL4               seek addr\nLRseekcc DS    XL2\nLRseekhh DS    XL2\nLRsearch DS    0XL5               search arg\nLRsrchcc DS    XL2\nLRsrchhh DS    XL2\nLRsrchr  DS    X\nLRsector DS    X\nLRtlf    DS    XL2                transfer length factor\nLRparml  EQU   *-LRparm\n\n*/* -------------------------------------------------------------------\n*   dsects\n* ------------------------------------------------------------------ */\n         PRINT NOGEN\n         DCBD  DSORG=PS\n         IHADCBE ,\nUCBDSECT DSECT ,\n         IEFUCBOB ,\n         IEZDEB ,\nDEBLENGTH EQU  (DEBBASND-DEBAVT)+(DEBDASDE-DEBDASD)+DEBXLEN\n         IEZIOB ,\n         IHAECB ,\n         IOSDCCW ,\n         CVT   DSECT=YES\n         IHAPSA ,\n         IKJTCB ,\n\n*/* -------------------------------------------------------------------\n*   equates\n* ------------------------------------------------------------------ */\nSK    EQU X'07'\nSNSID EQU X'e4'\nSNS   EQU X'04'\nRDC   EQU X'64'\nSNSS  EQU X'54'\nRT    EQU X'de'\nDX    EQU X'63'\nLR    EQU X'47'\nWR0   EQU X'15'\nWCKD  EQU X'1d'\nTIC   EQU X'08'\nPSF   EQU X'27'\nRSSD  EQU X'3E'\nRCD   EQU X'FA'\n\nr0 EQU 0\nr1 EQU 1\nr2 EQU 2\nr3 EQU 3\nr4 EQU 4\nr5 EQU 5\nr6 EQU 6\nr7 EQU 7\nr8 EQU 8\nr9 EQU 9\nra EQU 10\nrb EQU 11\nrc EQU 12\nrd EQU 13\nre EQU 14\nrf EQU 15\n\n   END ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DSKCJCL1": {"ttr": 1288, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x14\\x01\\x12\\x10\\x8f\\x01\\x12\\x10\\x8f\\x13A\\x00\\n\\x00\\x05\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2012-04-17T00:00:00", "modifydate": "2012-04-17T13:41:14", "lines": 10, "newlines": 5, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBC JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//*    COMPARE 2 ENTIRE PACKS\n//*\n//STEP1  EXEC PGM=DISKCOMP,\n//       PARM='0ACD,0AEF'\n//*      PARM='UNIT1,UNIT2,LOCYL,HICYL,MSGDDN'\n//STEPLIB  DD DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DSKCJCL2": {"ttr": 1290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x008\\x01\\x12\\x10\\x8f\\x01\\x12\\x10\\x8f\\x138\\x00\\n\\x00\\x05\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2012-04-17T00:00:00", "modifydate": "2012-04-17T13:38:38", "lines": 10, "newlines": 5, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBC JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//*    LIMIT RANGE OF CYLINDERS COMPARED\n//*\n//STEP1  EXEC PGM=DISKCOMP,\n//       PARM='0AA2,0AEF,0000,0050'\n//*      PARM='UNIT1,UNIT2,LOCYL,HICYL,MSGDDN'\n//STEPLIB  DD DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DSKCJCL3": {"ttr": 1292, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00$\\x01\\x12\\x10\\x8f\\x01\\x12\\x10\\x8f\\x12)\\x00\\n\\x00\\x05\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2012-04-17T00:00:00", "modifydate": "2012-04-17T12:29:24", "lines": 10, "newlines": 5, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBC JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//*  REALLY IDENTICAL DISKS - ONE ONLINE, ONE OFFLINE\n//*\n//STEP1  EXEC PGM=DISKCOMP,\n//       PARM='0ACC,0AEF'\n//*      PARM='UNIT1,UNIT2,LOCYL,HICYL,MSGDDN'\n//STEPLIB  DD DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DSKCMP0$": {"ttr": 1294, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x01\\x001\\x01\\x12\\x10\\x0f\\x01\\x12\\x10\\x8f\\x11W\\x00\\x1d\\x00\\x1c\\x00\\x00\\xc1\\xe2\\xd4\\xd3\\xc9\\xd5\\xd2@@@'", "ispf": {"version": "00.01", "flags": 0, "createdate": "2012-04-09T00:00:00", "modifydate": "2012-04-17T11:57:31", "lines": 29, "newlines": 28, "modlines": 0, "user": "ASMLINK"}, "text": "//SBGOLOBM JOB (CCMVS),'HI FOLKS',\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(DSKCMP01)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n ENTRY DISKCOMP\n SETSSI  CB484868\n SETCODE AC(1)\n NAME    DSKCMP01(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DSKCMP01": {"ttr": 1296, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x01\\x00F\\x01\\x12\\x10/\\x01\\x12\\x10/\\x08T\\x07=\\x07=\\x00\\x00\\xe5`\\xf0K\\xf1K\\xf0@@@'", "ispf": {"version": "00.01", "flags": 0, "createdate": "2012-04-11T00:00:00", "modifydate": "2012-04-11T08:54:46", "lines": 1853, "newlines": 1853, "modlines": 0, "user": "V-0.1.0"}, "text": "*/* -------------------------------------------------------------------\n*   Quick&Dirty program to compare two offline devices\n*\n*   Invocation:\n*      //step   EXEC PGM=DISKCOMP,\n*      //       PARM='unit1,unit2,locyl,hicyl,msgddn'\n*      //STEPLIB  DD DISP=SHR,DSN=apf.authorized.loadlib\n*      //msgddn   DD SYSOUT=*\n*\n*    locyl, hicyl and msgddn are optional\n*\n*    locyl defaults to 0\n*    hicyl defaults to highest cylinder on smallest unit\n*    msgddn defaults to SYSPRINT\n*\n*   Claudio Mauceri  Claudio.Mauceri@hds.com\n*   Greg Smith       gsmith@nc.rr.com\n*\n* ------------------------------------------------------------------ */\n\n*/* -------------------------------------------------------------------\n*   local macros\n* ------------------------------------------------------------------ */\n         MACRO\n&L      #MSG   &MSG,&TYPE=CALL\n         LCLA  &A,&N,&O\n         LCLC  &C\n         GBLA  &MSG_IX\n         GBLC  &MSGS(256)\n         AIF   ('&TYPE' EQ 'CALL').CALL,                               x\n               ('&TYPE' EQ 'GEN').GEN\n         MNOTE 8,'Invalid type specified'\n         MEXIT\n.*\n.CALL    ANOP\n&MSG_IX  SETA  &MSG_IX+1\n&MSGS(&MSG_IX) SETC '&MSG'\n&L       L     re,=A(#MSG&MSG_IX)\n         LA    rf,L'#MSG&MSG_IX\n&A       SETA  2\n&O       SETA  0\n&N       SETA  N'&SYSLIST\n         AGO   .PL0\n.PLLOOP  ANOP\n         LA    re,&SYSLIST(&A)\n&A       SETA  &A+1\n         AIF   (&A GT &N).PLX14\n         LA    rf,&SYSLIST(&A)\n&A       SETA  &A+1\n.PL0     ANOP\n         AIF   (&A GT &N).PLX15\n         LA    r0,&SYSLIST(&A)\n&A       SETA  &A+1\n         AIF   (&A GT &N).PLX0\n         LA    r1,&SYSLIST(&A)\n&A       SETA  &A+1\n         AIF   (&A GT &N).PLX1\n         STM   re,r1,dcwmsgpl+&O\n&O       SETA  &O+16\n         AGO   .PLLOOP\n.PLX14   ST    re,dcwmsgpl+&O\n         AGO   .CALL2\n.PLX15   STM   re,rf,dcwmsgpl+&O\n         AGO   .CALL2\n.PLX0    STM   re,r0,dcwmsgpl+&O\n         AGO   .CALL2\n.PLX1    STM   re,r1,dcwmsgpl+&O\n.CALL2   LA    r1,dcwmsgpl\n         L     rf,=a(msgr)\n         BALR  re,rf\n         MEXIT\n.*\n.GEN     ANOP\n         AIF   ('&L' EQ '').GENNOL\n&L       DS    0H\n.GENNOL  ANOP\n&A       SETA  1\n.GENLOOP AIF   (&A GT &MSG_IX).MEND\n#MSG&A   DC    C&MSGS(&A)\n&A       SETA  &A+1\n         AGO   .GENLOOP\n.MEND    MEND\n\n*/* -------------------------------------------------------------------\n*   mainline routine\n* ------------------------------------------------------------------ */\nDISKCOMP CSECT ,\nDISKCOMP AMODE 31\nDISKCOMP RMODE ANY\n         j     init\n         DC    AL1(init-*)\npgmid    DC    CL8'diskcomp'\nvrm      DC    X'000101'          version 0 release 1 modlvl 0\n         DC    C' &SYSDATE &SYSTIME '\ninit     SAVE  (14,12)\n         LR    rc,rf              set base reg\n         USING DISKCOMP,rc\n         LA    ra,4095(,rc)       set 2nd base reg\n         USING (DISKCOMP+4095,mainend),ra\n         LR    r2,r1              copy parm reg\n\n*/* -------------------------------------------------------------------\n*   obtain and initialize workareas\n* ------------------------------------------------------------------ */\n         STORAGE OBTAIN,LENGTH=dcwl get work area\n         ST    r1,8(,rd)          chain save areas\n         ST    rd,4(,r1)\n         LR    rd,r1              set area base\n         USING dcw,rd\n         MVC   dcwid,=C'dcw '     set area identifier\n         LA    r0,dcw+8           clear the area\n         L     r1,=a(dcwl-8)\n         SLR   rf,rf\n         MVCL  r0,re\n         STORAGE OBTAIN,LENGTH=dcw24l,LOC=BELOW get 24-bit work area\n         ST    r1,dcw24a          save address\n         LR    rb,r1              set 24-bit area base\n         USING dcw24,rb\n         MVC   dcw24id,=C'dc24'   set 24-bit area identifier\n         LA    r0,dcw24+4         clear the 24-bit area\n         L     r1,=a(dcw24l-4)\n         SLR   rf,rf\n         MVCL  r0,re\n\n*/* -------------------------------------------------------------------\n*   process PARM= : <unit1>,<unit2>,<locyl>,<hicyl>,<msgddn>\n* ------------------------------------------------------------------ */\n         NILH  r2,X'7fff'         turn hi parameter reg bit off\n         LTR   r2,r2               test parameter reg\n         jz    Enoparm             invalid parameter list\n         L     r3,0(,r2)          point to parameters\n         NILH  r3,X'7fff'         turn hi parameters addr bit off\n         LTR   r3,r3               test parameters addr reg\n         jZ    Enoparm              invalid parameter list\n         LH    r4,0(,r3)          get length of parameters\n         LTR   r4,r4               test length\n         jnp   Enoparm              invalid parameter list\n         AHI   r4,-1              decrement length for EX\n         AHI   r3,2               point past length\n         SLR   r2,r2              clear TRT register\n\n*/*      1st parm is hex unit address of the offline device 1\n         XC    dcwdw,dcwdw        clear double-word work area\n         LA    r1,1(r3,r4)        point to parameter end\n         EX    r4,delimtrt        search for `,'\n*/*      TRT   0(0,r3),delimtab   *** executed ***                   */\n         SR    r1,r3              calculate parameter length\n         AHI   r1,-1               minus one\n         jm    Ebadparm           error if 1st parm is missing\n         CHI   r1,4               check 2nd parm length\n         jnl   Ebadparm           error if too long\n         EX    r1,parmmvc         copy 2nd parameter\n*/*      MVC   dcwdw(0),0(r3)     *** executed ***                   */\n         TR    dcwdw,upcase       convert to uppercase\n         SLR   r5,r5              clear unit address\n         EX    r1,parmhexc        test if all hex digits\n*/*      TRT   drcdw(0),hexchars  *** executed ***                   */\n         jnz   Ebadparm            error if not\n         EX    r1,parmhex         convert to hex digits\n*/*      TR    dcwdw(0),hextab    *** executed ***                   */\n         LA    rf,1(,r1)          need an extra byte for pack\n         EX    rf,parmpack        get hex value\n*/*      PACK  dcwdw2,dcwdw(0)    *** executed ***                   */\n         ICM   r5,3,dcwdw2+5      load hex value\n         STCM  r5,3,dcwunit1      save unit address\n         LA    r1,2(,r1)          length of parm + `,'\n         AR    r3,r1              point to 2nd parameter\n         SR    r4,r1              readjust length left\n\n*/*      2nd parm is hex unit address of the offline device 2\n         LTR   r4,r4              test for 2nd parm\n         jm    Ebadparm            error if offline device is missing\n         XC    dcwdw,dcwdw        clear double-word work area\n         LA    r1,1(r3,r4)        point to parameter end\n         EX    r4,delimtrt        search for `,'\n*/*      TRT   0(0,r3),delimtab   *** executed ***                   */\n         SR    r1,r3              calculate parameter length\n         AHI   r1,-1               minus one\n         jm    Ebadparm           error if 1st parm is missing\n         CHI   r1,4               check parm length\n         jnl   Ebadparm           error if too long\n         EX    r1,parmmvc         copy parameter\n*/*      MVC   dcwdw(0),0(r3)     *** executed ***                   */\n         TR    dcwdw,upcase       convert to uppercase\n         SLR   r5,r5              clear unit address\n         EX    r1,parmhexc        test if all hex digits\n*/*      TRT   drcdw(0),hexchars  *** executed ***                   */\n         jnz   Ebadparm            error if not\n         EX    r1,parmhex         convert to hex digits\n*/*      TR    dcwdw(0),hextab    *** executed ***                   */\n         LA    rf,1(,r1)          need an extra byte for pack\n         EX    rf,parmpack        get hex value\n*/*      PACK  dcwdw2,dcwdw(0)    *** executed ***                   */\n         ICM   r5,3,dcwdw2+5      load hex value\n         STCM  r5,3,dcwunit2      save unit address\n         LA    r1,2(,r1)          length of parm + `,'\n         AR    r3,r1              point to 2nd parameter\n         SR    r4,r1              readjust length left\n\n*/*      3rd parm is low cylinder to compare in hex                  */\n         SLR   r1,r1              clear reg 1\n         LHI   r5,0                -1\n         LTR   r4,r4              test for low cylinder\n         jm    gotlocyl            continue if missing\n         LA    r1,1(r3,r4)        point to parameter end\n         EX    r4,delimtrt        search for `,'\n         SR    r1,r3              calculate parameter length\n         AHI   r1,-1               minus one\n         jm    gotlocyl             continue if missing\n         XC    dcwdw,dcwdw        clear double-word work area\n         CHI   r1,4               check parm length\n         jnl   Ebadparm           error if too long\n         EX    r1,parmmvc         copy parameter\n         TR    dcwdw,upcase       convert to uppercase\n         EX    r1,parmhexc        test if all hex digits\n         jnz   Ebadparm            error if not\n         EX    r1,parmhex         convert to hex digits\n         LA    rf,1(,r1)          need an extra byte for pack\n         EX    rf,parmpack        get hex value\n         SLR   r5,r5              clear low cylinder\n         ICM   r5,3,dcwdw2+5      load hex value\ngotlocyl STCM  r5,3,dcwlocyl      save low cylinder\n         LA    r1,2(,r1)          length of parm + `,'\n         AR    r3,r1              point to 2nd parameter\n         SR    r4,r1              readjust length left\n\n*/*      4th parm is high cylinder to compare in hex                 */\n         SLR   r1,r1              clear reg 1\n         LHI   r5,-1               -1\n         LTR   r4,r4              test for high cylinder\n         jm    gothicyl            continue if missing\n         LA    r1,1(r3,r4)        point to parameter end\n         EX    r4,delimtrt        search for `,'\n         SR    r1,r3              calculate parameter length\n         AHI   r1,-1               minus one\n         jm    gothicyl             continue if missing\n         XC    dcwdw,dcwdw        clear double-word work area\n         CHI   r1,4               check parm length\n         jnl   Ebadparm           error if too long\n         EX    r1,parmmvc         copy parameter\n         TR    dcwdw,upcase       convert to uppercase\n         EX    r1,parmhexc        test if all hex digits\n         jnz   Ebadparm            error if not\n         EX    r1,parmhex         convert to hex digits\n         LA    rf,1(,r1)          need an extra byte for pack\n         EX    rf,parmpack        get hex value\n         SLR   r5,r5              clear high cylinder\n         ICM   r5,3,dcwdw2+5      load hex value\ngothicyl STCM  r5,3,dcwhicyl      save high cylinder\n         LA    r1,2(,r1)          length of parm + `,'\n         AR    r3,r1              point to 2nd parameter\n         SR    r4,r1              readjust length left\n\n*/*      5th (and last) parm is the message ddname                   */\n         SLR   r1,r1              clear reg 1\n         MVC   dcwprddn,=CL8'SYSPRINT' init message ddname\n         LTR   r4,r4              test length left\n         jm    gotprddn            continue if nothing left\n         LA    r1,1(r3,r4)        point to parameter end\n****     EX    r4,delimtrt        search for `,'\n         SR    r1,r3              calculate parameter length\n         AHI   r1,-1               minus one\n         jm    gotprddn            continue if missing\n         CHI   r1,8               test length\n         jnl   Ebadparm            error if too long\n         XC    dcwdw,dcwdw        clear double word work area\n         EX    r1,parmmvc         copy 3rd parameter\n         TR    dcwdw,upcase       convert to uppercase\n         MVC   dcwprddn,dcwdw     copy the message ddname\ngotprddn LA    r1,2(,r1)          length of parm + `,'\n         AR    r3,r1              point to 2nd parameter\n         SR    r4,r1              readjust length left\n\n*//FIXME: fake-open should be a subroutine\n*/* -------------------------------------------------------------------\n*   `fake-open' offline device 1\n* ------------------------------------------------------------------ */\n\n*   look for the ucb for the unit & make sure it's an offline dasd\n         MVC   dcwulpl,ulpl       copy ucblook parameter list\n         MODESET MODE=SUP\n         UCBLOOK DEVN=dcwunit1,UCBPTR=dcwucb1,PIN,PTOKEN=dcwptok1,     X\n               DYNAMIC=YES,RANGE=ALL,LOC=ANY,MF=(E,dcwulpl),           X\n               TEXT==C'DISKCOMP offline dasd lookup1'\n         STM   rf,r0,dcwretcd     save ret/rsn codes across MODESET\n         MODESET MODE=PROB\n         LM    rf,r0,dcwretcd     restore ret/rsn codes\n         LTR   rf,rf              test ucblook return code\n         LA    r2,dcwunit1         bad unit addr if error\n         jnz   Ebaducbl           ucblook error\n         OI    dcwflag1,dcwpin    indicate ucb has been pinned\n         L     r2,dcwucb1         load ucb addr\n         USING UCBOB,r2\n         CLI   UCBTBYT3,UCB3DACC  check for dasd ucb\n         jne   Ebaducbt            not a dasd unit\n         TM    UCBSTAT,UCBONLI    is device online ?\n*//CHANGE NOP to JO if unit MUST be offline\n         nop   Ebaducbs            dasd unit is not offline\n\n*   if we got a 31-bit address then we need to `capture' a 24-bit addr\n         MVC   dcwcucb1,dcwucb1   copy ucb address\n         TM    dcwucb1,X'ff'      is it a 31 bit address ?\n         jz    cucbok1             no, continue\n         MVC   dcwcupl,cupl       copy isocapu parameter list\n         MODESET MODE=SUP\n         IOSCAPU CAPTUCB,UCBPTR=dcwucb1,CAPTPTR=dcwcucb1,              X\n               MF=(E,dcwcupl)     capture a 24-bit ucb addr\n         STM   rf,r0,dcwretcd     save ret/rsn codes across MODESET\n         MODESET MODE=PROB\n         LM    rf,r0,dcwretcd     restore ret/rsn codes\n         LTR   rf,rf              test ioscapu return code\n         jnz   Ebaducbc           ioscapu error\n         OI    dcwflag1,dcwcucb   indicate ucb has been captured\n         L     r2,dcwcucb1        load captured deb addr\ncucbok1  DS    0H\n\n*   build dcb for the offline unit 1\n         MVC   dcwdcb1,moddcb     copy otptut model dcb\ndcb1     USING IHADCB,dcwdcb1\n         MVC   dcb1.DCBMACRF,dcb1.DCBMACR copy macro reference bits\n\n*   build deb for the offline unit 1\n         MODESET MODE=SUP,KEY=ZERO\n         GETMAIN RU,LV=DEBLENGTH,SP=230,LOC=BELOW\n         ST    r1,dcwdeb1         save deb address\n         XC    0(DEBLENGTH,r1),0(r1) clear the deb\n         LR    r3,r1              appendage vector table/basic sections\n         USING DEBAVT,r3\n         LA    r4,DEBBASND-DEBAVT(,r3) debdasd section\n         USING DEBDASD,r4\n         LA    r5,DEBDASDE-DEBDASD(,r4) deb extension section\n         USING DEBXTN,r5\n         L     r6,CVTPTR          get cvt address\n         USING CVT,r6\n         L     rf,CVTXAPG         ios appendage vector table\n         MVC   DEBAVT(DEBPREFX-DEBAVT),0(rf) copy vector table\n         ST    r5,DEBXTNP         set extension address\n         USING PSA,r0\n         L     r7,PSATOLD         get tcb address\n         USING TCB,r7\n         ST    r7,DEBTCBAD        set tcb address\n         OI    DEBFLGS1,DEBXTNIN  indicate extension exists\n         LA    r0,dcwdcb1         get dcb address\n         ST    r0,DEBDCBAD        set dcb address\n         MVI   DEBDEBID,15        set deb identifier\n         OC    DEBPROTG,TCBPKF    set protection key\n         ST    r3,DEBAPPAD        set appendage table address\n         STCM  r2,7,DEBUCBA       set ucb address\n         MVC   DEBXLNGH,=Y(DEBXLEN) set extension length\n         LA    r1,DEBBASIC        get basic section address\n         STCM  r1,7,dcb1.DCBDEBA  set deb address in the dcb\n         SETLOCK OBTAIN,TYPE=LOCAL,REGS=STDSAVE,MODE=UNCOND\n         MVC   DEBDEBB,TCBDEB+1   set address next deb\n         LA    r1,DEBBASIC        get basic section address\n         ST    r1,TCBDEB          chain deb to the tcb\n         SETLOCK RELEASE,TYPE=LOCAL,REGS=STDSAVE\n         MODESET MODE=PROB,KEY=NZERO\n\n*   add deb to the deb list\n         MODESET MODE=SUP,KEY=ZERO\n         DEBCHK dcwdcb1,TYPE=ADD,AM=EXCP\n         STM   rf,r0,dcwretcd\n         MODESET MODE=PROB,KEY=NZERO\n         LM    rf,r0,dcwretcd\n         LTR   rf,rf              test debchk add return code\n         jnz   Ebaddeba             debchk add failed\n         OI    dcwflag1,dcwdebad  indicate deb was added\n\n*   build the dasd extent\n         MODESET MODE=SUP,KEY=ZERO\n         ST    r2,DEBUCBAD        set 24-bit ucb addr\n         MVI   DEBDVMOD,0         set device modifier\n***      MVC   DEBENDCC,=X'7fff'  set end cylinder\n***      MVC   DEBENDHH,=X'00ff'  set end head\n***      MVC   DEBNMTRK,=X'7fff'  set number tracks in extent\n         MVC   DEBENDCC,=X'ffff'  set end cylinder\n         MVC   DEBENDHH,=X'ffff'  set end head\n         MVC   DEBNMTRK,=X'ffff'  set number tracks in extent\n         MODESET MODE=PROB,KEY=NZERO\n\n*   build the iob\niob1     USING IOBSTDRD,dcwiob1\n         OI    iob1.IOBFLAG1,IOBDATCH+IOBCMDCH+IOBUNREL\n         LA    r1,dcwecb1\n         ST    r1,iob1.IOBECBPT\n         LA    r1,dcwccw1\n         ST    r1,iob1.IOBSTART\n         LA    r1,dcwdcb1\n         ST    r1,iob1.IOBDCBPT\n\n*   turn off the `not ready' bit\n         TM    UCBFLA,UCBNRY     is `not ready' bit on ?\n         BNO   nryok1             no, continue\n         MODESET MODE=SUP,KEY=ZERO\n         NI    UCBFLA,255-UCBNRY turn off `not ready' bit\n         MODESET MODE=PROB,KEY=NZERO\n         OI    dcwflag1,dcwnry   indicate we turned the bit off\nnryok1   DS    0H\n\n*   sense the offline device unit 1\n         MODESET MODE=SUP,KEY=ZERO\n         OI    DEBXFLG2,DEBCHCMP+DEBBYP bypass excp prefixing\n         MODESET MODE=PROB,KEY=NZERO\n         LA    r8,dcwccw1\n         USING CCW0,r8\n         LA    r9,dcwiob1\n         USING IOBSTDRD,r9\n\n*        Seek\n         XC    dcwecb1,dcwecb1    clear the ecb\n         XC    dcwccw1(dcwccwl),dcwccw1 clear the ccws\n         MVI   CCW0CMD,SK         set seek command\n         LA    r1,dcwzeros\n         STCM  r1,7,CCW0ADDR      set data address\n         MVI   CCW0FLAG,CCW0SLI   set sli flag bit\n         MVC   CCW0CNT,=Y(6)      set count\n         EXCP  dcwiob1\n         WAIT  1,ECB=dcwecb1      wait for SK\n         CLI   dcwecb1,ECBNORM   test post code\n         BNE   Esnserr              error\n\n*        Sense ID\n         XC    dcwecb1,dcwecb1    clear the ecb\n         XC    dcwccw1(dcwccwl),dcwccw1 clear the ccws\n         MVI   CCW0CMD,SNSID      set sense-id command\n         LA    r1,dcwsnsi1\n         STCM  r1,7,CCW0ADDR      set data address\n         MVI   CCW0FLAG,CCW0SLI   set sli flag bit\n         MVC   CCW0CNT,=Y(L'dcwsnsi1) set count\n         EXCP  dcwiob1\n         WAIT  1,ECB=dcwecb1      wait for SNSID\n         CLI   dcwecb1,ECBNORM   test post code\n         BNE   Esnserr              error\n\n*        Sense\n         XC    dcwecb1,dcwecb1    clear the ecb\n         XC    dcwccw1(dcwccwl),dcwccw1 clear the ccws\n         MVI   CCW0CMD,SNS        set sense command\n         LA    r1,dcwsns1\n         STCM  r1,7,CCW0ADDR      set data address\n         MVI   CCW0FLAG,CCW0SLI   set sli flag bit\n         MVC   CCW0CNT,=Y(L'dcwsns1)  set count\n         EXCP  dcwiob1\n         WAIT  1,ECB=dcwecb1      wait for SNS\n         CLI   dcwecb1,ECBNORM   test post code\n         BNE   Esnserr              error\n\n*        Read Device Characteristics\n         XC    dcwecb1,dcwecb1    clear the ecb\n         XC    dcwccw1(dcwccwl),dcwccw1 clear the ccws\n         MVI   CCW0CMD,RDC        set read-characteristics command\n         LA    r1,dcwrdc1\n         STCM  r1,7,CCW0ADDR      set data address\n         MVI   CCW0FLAG,0         clear flag bits\n         MVC   CCW0CNT,=Y(L'dcwrdc1)  set count\n         EXCP  dcwiob1\n         WAIT  1,ECB=dcwecb1      wait for RDC\n         CLI   dcwecb1,ECBNORM   test post code\n         BNE   Esnserr              error\n\n*        Sense Subsystem Status\n         XC    dcwecb1,dcwecb1    clear the ecb\n         XC    dcwccw1(dcwccwl),dcwccw1 clear the ccws\n         MVI   CCW0CMD,SNSS       set sense-subsystem-status command\n         LA    r1,dcwsnss1\n         STCM  r1,7,CCW0ADDR      set data address\n         MVI   CCW0FLAG,CCW0SLI   set sli flag bit\n         MVC   CCW0CNT,=Y(L'dcwsnss1) set count\n         EXCP  dcwiob1\n         WAIT  1,ECB=dcwecb1      wait for SNSS\n         CLI   dcwecb1,ECBNORM   test post code\n         BNE   Esnserr              error\n\n         MODESET MODE=SUP,KEY=ZERO\n         NI    DEBXFLG2,255-DEBCHCMP-DEBBYP\n         MODESET MODE=PROB,KEY=NZERO\n         DROP  r2,r3,r4,r5,r6,r7,r8,r9\n\n*/* -------------------------------------------------------------------\n*   `fake-open' offline device 2\n* ------------------------------------------------------------------ */\n\n*   look for the ucb for the unit & make sure it's an offline dasd\n         MVC   dcwulpl,ulpl       copy ucblook parameter list\n         MODESET MODE=SUP\n         UCBLOOK DEVN=dcwunit2,UCBPTR=dcwucb2,PIN,PTOKEN=dcwptok2,     X\n               DYNAMIC=YES,RANGE=ALL,LOC=ANY,MF=(E,dcwulpl),           X\n               TEXT==C'DISKCOMP offline dasd lookup2'\n         STM   rf,r0,dcwretcd     save ret/rsn codes across MODESET\n         MODESET MODE=PROB\n         LM    rf,r0,dcwretcd     restore ret/rsn codes\n         LTR   rf,rf              test ucblook return code\n         LA    r2,dcwunit2         bad unit addr if error\n         jnz   Ebaducbl           ucblook error\n         OI    dcwflag2,dcwpin    indicate ucb has been pinned\n         L     r2,dcwucb2         load ucb addr\n         USING UCBOB,r2\n         CLI   UCBTBYT3,UCB3DACC  check for dasd ucb\n         jne   Ebaducbt            not a dasd unit\n         TM    UCBSTAT,UCBONLI    is device online ?\n*//CHANGE NOP to JO if unit MUST be offline\n         nop   Ebaducbs            dasd unit is not offline\n\n*   if we got a 31-bit address then we need to `capture' a 24-bit addr\n         MVC   dcwcucb2,dcwucb2   copy ucb address\n         TM    dcwucb2,X'ff'      is it a 31 bit address ?\n         jz    cucbok2             no, continue\n         MVC   dcwcupl,cupl       copy isocapu parameter list\n         MODESET MODE=SUP\n         IOSCAPU CAPTUCB,UCBPTR=dcwucb2,CAPTPTR=dcwcucb2,              X\n               MF=(E,dcwcupl)     capture a 24-bit ucb addr\n         STM   rf,r0,dcwretcd     save ret/rsn codes across MODESET\n         MODESET MODE=PROB\n         LM    rf,r0,dcwretcd     restore ret/rsn codes\n         LTR   rf,rf              test ioscapu return code\n         jnz   Ebaducbc           ioscapu error\n         OI    dcwflag2,dcwcucb   indicate ucb has been captured\n         L     r2,dcwcucb2        load captured ucb addr\ncucbok2  DS    0H\n\n*   build dcb for the offline unit 2\n         MVC   dcwdcb2,moddcb     copy otptut model dcb\ndcb2     USING IHADCB,dcwdcb2\n         MVC   dcb2.DCBMACRF,dcb2.DCBMACR copy macro reference bits\n\n*   build deb for the offline unit 2\n         MODESET MODE=SUP,KEY=ZERO\n         GETMAIN RU,LV=DEBLENGTH,SP=230,LOC=BELOW\n         ST    r1,dcwdeb2         save deb address\n         XC    0(DEBLENGTH,r1),0(r1) clear the deb\n         LR    r3,r1              appendage vector table/basic sections\n         USING DEBAVT,r3\n         LA    r4,DEBBASND-DEBAVT(,r3) debdasd section\n         USING DEBDASD,r4\n         LA    r5,DEBDASDE-DEBDASD(,r4) deb extension section\n         USING DEBXTN,r5\n         L     r6,CVTPTR          get cvt address\n         USING CVT,r6\n         L     rf,CVTXAPG         ios appendage vector table\n         MVC   DEBAVT(DEBPREFX-DEBAVT),0(rf) copy vector table\n         ST    r5,DEBXTNP         set extension address\n         USING PSA,r0\n         L     r7,PSATOLD         get tcb address\n         USING TCB,r7\n         ST    r7,DEBTCBAD        set tcb address\n         OI    DEBFLGS1,DEBXTNIN  indicate extension exists\n         LA    r0,dcwdcb2         get dcb address\n         ST    r0,DEBDCBAD        set dcb address\n         MVI   DEBDEBID,15        set deb identifier\n         OC    DEBPROTG,TCBPKF    set protection key\n         ST    r3,DEBAPPAD        set appendage table address\n         STCM  r2,7,DEBUCBA       set ucb address\n         MVC   DEBXLNGH,=Y(DEBXLEN) set extension length\n         LA    r1,DEBBASIC        get basic section address\n         STCM  r1,7,dcb2.DCBDEBA  set deb address in the dcb\n         SETLOCK OBTAIN,TYPE=LOCAL,REGS=STDSAVE,MODE=UNCOND\n         MVC   DEBDEBB,TCBDEB+1   set address next deb\n         LA    r1,DEBBASIC        get basic section address\n         ST    r1,TCBDEB          chain deb to the tcb\n         SETLOCK RELEASE,TYPE=LOCAL,REGS=STDSAVE\n         MODESET MODE=PROB,KEY=NZERO\n\n*   add deb to the deb list\n         MODESET MODE=SUP,KEY=ZERO\n         DEBCHK dcwdcb2,TYPE=ADD,AM=EXCP\n         STM   rf,r0,dcwretcd\n         MODESET MODE=PROB,KEY=NZERO\n         LM    rf,r0,dcwretcd\n         LTR   rf,rf              test debchk add return code\n         jnz   Ebaddeba             debchk add failed\n         OI    dcwflag2,dcwdebad  indicate deb was added\n\n*   build the dasd extent\n         MODESET MODE=SUP,KEY=ZERO\n         ST    r2,DEBUCBAD        set 24-bit ucb addr\n         MVI   DEBDVMOD,0         set device modifier\n***      MVC   DEBENDCC,=X'7fff'  set end cylinder\n***      MVC   DEBENDHH,=X'00ff'  set end head\n***      MVC   DEBNMTRK,=X'7fff'  set number tracks in extent\n         MVC   DEBENDCC,=X'ffff'  set end cylinder\n         MVC   DEBENDHH,=X'ffff'  set end head\n         MVC   DEBNMTRK,=X'ffff'  set number tracks in extent\n         MODESET MODE=PROB,KEY=NZERO\n\n*   build the iob\niob2     USING IOBSTDRD,dcwiob2\n         OI    iob2.IOBFLAG1,IOBDATCH+IOBCMDCH+IOBUNREL\n         LA    r1,dcwecb2\n         ST    r1,iob2.IOBECBPT\n         LA    r1,dcwccw2\n         ST    r1,iob2.IOBSTART\n         LA    r1,dcwdcb2\n         ST    r1,iob2.IOBDCBPT\n\n*   turn off the `not ready' bit\n         TM    UCBFLA,UCBNRY     is `not ready' bit on ?\n         BNO   nryok2             no, continue\n         MODESET MODE=SUP,KEY=ZERO\n         NI    UCBFLA,255-UCBNRY turn off `not ready' bit\n         MODESET MODE=PROB,KEY=NZERO\n         OI    dcwflag2,dcwnry   indicate we turned the bit off\nnryok2   DS    0H\n\n*   sense the offline device unit 2\n         MODESET MODE=SUP,KEY=ZERO\n         OI    DEBXFLG2,DEBCHCMP+DEBBYP bypass excp prefixing\n         MODESET MODE=PROB,KEY=NZERO\n         LA    r8,dcwccw2\n         USING CCW0,r8\n         LA    r9,dcwiob2\n         USING IOBSTDRD,r9\n\n*        Seek\n         XC    dcwecb2,dcwecb2    clear the ecb\n         XC    dcwccw2(dcwccwl),dcwccw2 clear the ccws\n         MVI   CCW0CMD,SK         set seek command\n         LA    r1,dcwzeros\n         STCM  r1,7,CCW0ADDR      set data address\n         MVI   CCW0FLAG,CCW0SLI   set sli flag bit\n         MVC   CCW0CNT,=Y(6)      set count\n         EXCP  dcwiob2\n         WAIT  1,ECB=dcwecb2      wait for SK\n         CLI   dcwecb2,ECBNORM   test post code\n         BNE   Esnserr              error\n\n*        Sense ID\n         XC    dcwecb2,dcwecb2    clear the ecb\n         XC    dcwccw2(dcwccwl),dcwccw2 clear the ccws\n         MVI   CCW0CMD,SNSID      set sense-id command\n         LA    r1,dcwsnsi2\n         STCM  r1,7,CCW0ADDR      set data address\n         MVI   CCW0FLAG,CCW0SLI   set sli flag bit\n         MVC   CCW0CNT,=Y(L'dcwsnsi2) set count\n         EXCP  dcwiob2\n         WAIT  1,ECB=dcwecb2      wait for SNSID\n         CLI   dcwecb2,ECBNORM   test post code\n         BNE   Esnserr              error\n\n*        Sense\n         XC    dcwecb2,dcwecb2    clear the ecb\n         XC    dcwccw2(dcwccwl),dcwccw2 clear the ccws\n         MVI   CCW0CMD,SNS        set sense command\n         LA    r1,dcwsns2\n         STCM  r1,7,CCW0ADDR      set data address\n         MVI   CCW0FLAG,CCW0SLI   set sli flag bit\n         MVC   CCW0CNT,=Y(L'dcwsns2)  set count\n         EXCP  dcwiob2\n         WAIT  1,ECB=dcwecb2      wait for SNS\n         CLI   dcwecb2,ECBNORM   test post code\n         BNE   Esnserr              error\n\n*        Read Device Characteristics\n         XC    dcwecb2,dcwecb2    clear the ecb\n         XC    dcwccw2(dcwccwl),dcwccw2 clear the ccws\n         MVI   CCW0CMD,RDC        set read-characteristics command\n         LA    r1,dcwrdc2\n         STCM  r1,7,CCW0ADDR      set data address\n         MVI   CCW0FLAG,0         clear flag bits\n         MVC   CCW0CNT,=Y(L'dcwrdc2)  set count\n         EXCP  dcwiob2\n         WAIT  1,ECB=dcwecb2      wait for RDC\n         CLI   dcwecb2,ECBNORM   test post code\n         BNE   Esnserr              error\n\n*        Sense Subsystem Status\n         XC    dcwecb2,dcwecb2    clear the ecb\n         XC    dcwccw2(dcwccwl),dcwccw2 clear the ccws\n         MVI   CCW0CMD,SNSS       set sense-subsystem-status command\n         LA    r1,dcwsnss2\n         STCM  r1,7,CCW0ADDR      set data address\n         MVI   CCW0FLAG,CCW0SLI   set sli flag bit\n         MVC   CCW0CNT,=Y(L'dcwsnss2) set count\n         EXCP  dcwiob2\n         WAIT  1,ECB=dcwecb2      wait for SNSS\n         CLI   dcwecb2,ECBNORM   test post code\n         BNE   Esnserr              error\n\n         MODESET MODE=SUP,KEY=ZERO\n         NI    DEBXFLG2,255-DEBCHCMP-DEBBYP\n         MODESET MODE=PROB,KEY=NZERO\n         DROP  r2,r3,r4,r5,r6,r7,r8,r9\n\n*/* -------------------------------------------------------------------\n*   compare tracks\n* ------------------------------------------------------------------ */\n\n*        setup buffers\n         LA    r1,dcwbufs\n         ST    r1,dcwbuf1\n         A     r1,=F'65536'\n         ST    r1,dcwbuf2\n\nrdc1     USING RDCinfo,dcwrdc1\nrdc2     USING RDCinfo,dcwrdc2\n\n*        check device types\n         clc   rdc1.RDCdevt,rdc2.RDCdevt\n         jne   Edifdevt\n\n*        set default high cyl to high cyl on the smallest device\n         llh   r0,dcwhicyl\n         c     r0,=A(X'0000ffff')\n         jne   hicylok\n         llh   r1,rdc1.RDCprime\n         ahi   r1,-1\n         lr    r0,r1\n         llh   r2,rdc2.RDCprime\n         ahi   r2,-1\n         clr   r1,r2\n         jnh   sethicyl\n         lr    r0,r2\nsethicyl stcm  r0,3,dcwhicyl\n*        warning if cylinders differ between the devices\n         clr   r1,r2\n         je    hicylok\n        #MSG   'Device %x4:2 has %d:2 cyls, device %x4:2 has %d:2 cyls.X\n                Defaulting to %x4:2 for high cyl',                     X\n               dcwunit1,rdc1.RDCprime,dcwunit2,rdc2.RDCprime,dcwhicyl\nhicylok  DS    0H\n\n*        check hi cyl\n         llh   r0,dcwhicyl\n         llh   r1,rdc1.RDCprime\n         la    r2,dcwunit1\n         clr   r0,r1\n         jnl   Ebadhcyl\n         llh   r1,rdc2.RDCprime\n         la    r2,dcwunit2\n         clr   r0,r1\n         jnl   Ebadhcyl\n\n*        check hi cyl vs lo cyl\n         llh   r1,dcwlocyl\n         llh   r2,dcwhicyl\n         CLR   r1,r2\n         JH    Ebadlcyl\n\n*        build ecb wait list\n         LA    r1,dcwecb1\n         LA    r2,dcwecb2\n         STM   r1,r2,dcwecbl\n         OI    dcwecbl+4,x'80'\n\n*        set starting cylinder, head\n         XC    dcwcchh,dcwcchh\n         MVC   dcwcc,dcwlocyl\n\n*        print initialization message\n         TIME  DEC\n         STM   r0,r1,dcwctime     get start time\n         LA    r1,dcwctime\n         LA    r0,dcwdtime\n         BAL   re,dtime\n        #MSG   '%s:8 %d:1.%d:1.%d:1 starting compare %s:20, unit1=%x4:2X\n               , unit2=%x4:2, locyl=%x4:2, hicyl=%x4:2',               X\n               pgmid,vrm,vrm+1,vrm+2,dcwdtime,                         X\n               dcwunit1,dcwunit2,dcwlocyl,dcwhicyl                     X\n\ndcloop   DS    0h\n\n*        setup unit 1 for read\n         XC    iob1.IOBSEEK,iob1.IOBSEEK\n         MVC   iob1.IOBCC,dcwcc\n         MVC   iob1.IOBHH,dcwhh\n         LA    r2,dcwccw1\n         USING CCW0,R2\n         XC    dcwccw1(dcwccwl),dcwccw1\n*        build LR ccw\n         MVI   CCW0CMD,LR\n         LA    r1,dcwlrp1\n         STCM  r1,7,CCW0ADDR\n         MVI   CCW0FLAG,CCW0CC\n         LA    r1,L'dcwlrp1\n         STCM  r1,3,CCW0CNT\n         LA    r2,CCW0END\n*        build LR parameter\n         XC    dcwlrp1,dcwlrp1\nlrp1     USING LRparm,dcwlrp1\n         MVI   lrp1.LRop,LRohome+LRrt\n         MVI   lrp1.LRcount,1\n         MVC   lrp1.LRseek,iob1.IOBCC\n         MVC   lrp1.LRsearch,iob1.IOBCC\n*        build RT ccw\n         MVI   CCW0CMD,RT\n         L     r1,dcwbuf1\n         STCM  r1,7,CCW0ADDR\n         MVI   CCW0FLAG,CCW0SLI\n         ICM   r1,7,rdc1.RDCtrkln\n         STCM  r1,3,CCW0CNT\n         DROP  r2\n*        start channel program\n         xc    dcwecb1,dcwecb1\n         EXCP  iob1.IOBSTDRD\n***      WAIT  1,ECB=dcwecb1\n\n*        setup unit 2 for read\n         XC    iob2.IOBSEEK,iob2.IOBSEEK\n         MVC   iob2.IOBCC,dcwcc\n         MVC   iob2.IOBHH,dcwhh\n         LA    r2,dcwccw2\n         USING CCW0,R2\n         XC    dcwccw2(dcwccwl),dcwccw2\n*        build LR ccw\n         MVI   CCW0CMD,LR\n         LA    r1,dcwlrp2\n         STCM  r1,7,CCW0ADDR\n         MVI   CCW0FLAG,CCW0CC\n         LA    r1,L'dcwlrp2\n         STCM  r1,3,CCW0CNT\n         LA    r2,CCW0END\n*        build LR parameter\n         XC    dcwlrp2,dcwlrp2\nlrp2     USING LRparm,dcwlrp2\n         MVI   lrp2.LRop,LRohome+LRrt\n         MVI   lrp2.LRcount,1\n         MVC   lrp2.LRseek,iob2.IOBCC\n         MVC   lrp2.LRsearch,iob2.IOBCC\n*        build RT ccw\n         MVI   CCW0CMD,RT\n         L     r1,dcwbuf2\n         STCM  r1,7,CCW0ADDR\n         MVI   CCW0FLAG,CCW0SLI\n         ICM   r1,7,rdc2.RDCtrkln\n         STCM  r1,3,CCW0CNT\n         DROP  r2\n*        start channel program\n         xc    dcwecb2,dcwecb2\n         EXCP  iob2.IOBSTDRD\n***      WAIT  1,ECB=dcwecb2\n\n         WAIT  2,ECBLIST=dcwecbl\n\n*        check i/o completion codes\n         cli   dcwecb1,ECBNORM\n         jne   Eioerr1\n         cli   dcwecb2,ECBNORM\n         jne   Eioerr2\n\n*        increment tracks read\n         L     r1,dcwtrks\n         AHI   r1,1\n         ST    r1,dcwtrks\n\n*        get track lengths\n         l     r2,dcwbuf1\n         slr   r3,r3\n         icm   r3,7,rdc1.RDCtrkln\n         llh   r0,iob1.IOBCSW8+6\n         slr   r3,r0\n         l     r4,dcwbuf2\n         slr   r5,r5\n         icm   r5,7,rdc2.RDCtrkln\n         llh   r0,iob2.IOBCSW8+6\n         slr   r5,r0\n\n*        check lengths\n         clr   r3,r5\n         je    dclenok\n         st    r3,dcwlen1\n         st    r5,dcwlen2\n        #MSG   '%x4:2 %x4:2 length  mismatch, length1 is %d, length2 isX\n                %d',dcwcc,dcwhh,dcwlen1,dcwlen2\n         l     r1,dcwdiffs\n         ahi   r1,1\n         st    r1,dcwdiffs\n         mvc   dcwrsult,=F'4'\n         j     dcnext\ndclenok  DS    0H\n\n*        compare images\n         clcl  r2,r4\n         je    dcnext\n        #MSG   '%x4:2 %x4:2 compare mismatch',dcwcc,dcwhh\n         l     r1,dcwdiffs\n         ahi   r1,1\n         st    r1,dcwdiffs\n         mvc   dcwrsult,=F'4'\n\ndcnext   ds    0h\n*        increment head\n         lh    r1,dcwhh\n         ahi   r1,1\n         sth   r1,dcwhh\n         ch    r1,rdc1.RDCheads\n         jl    dcloop\n*        increment cylinder\n         xc    dcwhh,dcwhh\n         llh   r1,dcwcc\n         ahi   r1,1\n         stcm  r1,3,dcwcc\n         llh   r2,dcwhicyl\n         clr   r1,r2\n         jnh   dcloop\n\n*        finished\n        #MSG   '%d tracks read, %d track differences',dcwtrks,dcwdiffs\n\n*/* -------------------------------------------------------------------\n*   cleanup and terminate\n* ------------------------------------------------------------------ */\n\nterminat DS    0H\n\n*/* call debchk to delete the debs                                   */\nterm1    TM    dcwflag1,dcwdebad was deb added to the deb chain ?\n         jno   term1a             no, continue\n         MODESET MODE=SUP,KEY=ZERO\n         DEBCHK dcwdcb1,TYPE=DELETE,AM=EXCP delete the deb\n         MODESET MODE=PROB,KEY=NZERO\n         NI    dcwflag1,255-dcwdebad\nterm1a   DS    0H\n         TM    dcwflag2,dcwdebad was deb added to the deb chain ?\n         jno   term1b             no, continue\n         MODESET MODE=SUP,KEY=ZERO\n         DEBCHK dcwdcb2,TYPE=DELETE,AM=EXCP delete the deb\n         MODESET MODE=PROB,KEY=NZERO\n         NI    dcwflag1,255-dcwdebad\nterm1b   DS    0H\n\n*/* remove deb 1 from the chain and free its storage                 */\nterm2    L     r2,dcwdeb1        load deb area addr\n         LTR   r2,r2              any deb area ?\n         BZ    term3               no, continue\n*/*      remove the deb from the deb chain                           */\n         USING DEBAVT,r2\n         LA    r3,DEBBASIC\n         DROP  r2\n         L     r4,PSATOLD-PSA    get tcb addr\n         USING TCB,r4\n         LA    r5,TCBDEB-(DEBDEBAD-DEBBASIC)\n         USING DEBBASIC,r4\n         MODESET MODE=SUP,KEY=ZERO\n         SETLOCK OBTAIN,TYPE=LOCAL,REGS=STDSAVE,MODE=UNCOND\n         SPKA  X'80'\nterm2a   LR    r4,r5\n         SLR   r5,r5\n         ICM   r5,7,DEBDEBB      addr next deb\n         BZ    term2b             exit if we didn't found ours\n         CLR   r3,r5             found our deb ?\n         BNE   term2a             no, keep looking\n         SPKA  0                   need key 0 to update a deb\n         MVC   DEBDEBB,DEBDEBB-DEBBASIC(r5) remove the deb\n         DROP  r4\nterm2b   SPKA  0                   need key 0 to update a deb\n         SETLOCK RELEASE,TYPE=LOCAL,REGS=STDSAVE\n         MODESET MODE=PROB,KEY=NZERO\n*/*      free deb storage                                            */\n         MODESET MODE=SUP,KEY=ZERO\n         FREEMAIN RU,A=(r2),LV=DEBLENGTH,SP=230 free the deb storage\n         MODESET MODE=PROB,KEY=NZERO\n         XC    dcwdeb1,dcwdeb1\n\n*/* remove deb 2 from the chain and free its storage                 */\nterm3    L     r2,dcwdeb2        load deb area addr\n         LTR   r2,r2              any deb area ?\n         BZ    term4               no, continue\n*/*      remove the deb from the deb chain                           */\n         USING DEBAVT,r2\n         LA    r3,DEBBASIC\n         DROP  r2\n         L     r4,PSATOLD-PSA    get tcb addr\n         USING TCB,r4\n         LA    r5,TCBDEB-(DEBDEBAD-DEBBASIC)\n         USING DEBBASIC,r4\n         MODESET MODE=SUP,KEY=ZERO\n         SETLOCK OBTAIN,TYPE=LOCAL,REGS=STDSAVE,MODE=UNCOND\n         SPKA  X'80'\nterm3a   LR    r4,r5\n         SLR   r5,r5\n         ICM   r5,7,DEBDEBB      addr next deb\n         BZ    term3b             exit if we didn't found ours\n         CLR   r3,r5             found our deb ?\n         BNE   term3a             no, keep looking\n         SPKA  0                   need key 0 to update a deb\n         MVC   DEBDEBB,DEBDEBB-DEBBASIC(r5) remove the deb\n         DROP  r4\nterm3b   SPKA  0                   need key 0 to update a deb\n         SETLOCK RELEASE,TYPE=LOCAL,REGS=STDSAVE\n         MODESET MODE=PROB,KEY=NZERO\n*/*      free deb storage                                            */\n         MODESET MODE=SUP,KEY=ZERO\n         FREEMAIN RU,A=(r2),LV=DEBLENGTH,SP=230 free the deb storage\n         MODESET MODE=PROB,KEY=NZERO\n         XC    dcwdeb2,dcwdeb2\n\n*/*      turn the ucb `not ready' bit back on if we turned it off    */\nterm4    TM    dcwflag1,dcwnry   did we turn the bit off ?\n         BNO   term4a             no, continue\n         L     r2,dcwucb1        load ucb address\n         USING UCBOB,r2\n         MODESET MODE=SUP,KEY=ZERO\n         OI    UCBFLA,UCBNRY     turn the bit back on\n         MODESET MODE=PROB,KEY=NZERO\n         DROP  r2\nterm4a   TM    dcwflag2,dcwnry   did we turn the bit off ?\n         BNO   term4b             no, continue\n         L     r2,dcwucb1        load ucb address\n         USING UCBOB,r2\n         MODESET MODE=SUP,KEY=ZERO\n         OI    UCBFLA,UCBNRY     turn the bit back on\n         MODESET MODE=PROB,KEY=NZERO\n         DROP  r2\nterm4b   DS    0H\n\n*/*      uncapture the ucbs                                          */\nterm5    TM    dcwflag1,dcwcucb  was ucb captured ?\n         jno   term5a             no, continue\n         MVC   dcwcupl,cupl        copy isocapu parameter list\n         MODESET MODE=SUP\n         IOSCAPU UCAPTUCB,CAPTPTR=dcwcucb1,                            X\n               MF=(E,dcwcupl)       uncapture the 24-bit ucb addr\n         MODESET MODE=PROB\nterm5a   TM    dcwflag2,dcwcucb  was ucb captured ?\n         jno   term5b             no, continue\n         MVC   dcwcupl,cupl        copy isocapu parameter list\n         MODESET MODE=SUP\n         IOSCAPU UCAPTUCB,CAPTPTR=dcwcucb2,                            X\n               MF=(E,dcwcupl)       uncapture the 24-bit ucb addr\n         MODESET MODE=PROB\nterm5b   DS    0H\n\n*/*      unpin the ucbs                                              */\nterm6    TM    dcwflag1,dcwpin   was ucb pinned ?\n         BNO   term6a             no, continue\n         MVC   dcwuupl,uupl        copy ucbpin unpin  parameter list\n         MODESET MODE=SUP\n         UCBPIN UNPIN,PTOKEN=dcwptok1,MF=(E,dcwuupl)  unpin the ucb\n         MODESET MODE=PROB\nterm6a   TM    dcwflag2,dcwpin   was ucb pinned ?\n         BNO   term6b             no, continue\n         MVC   dcwuupl,uupl        copy ucbpin unpin  parameter list\n         MODESET MODE=SUP\n         UCBPIN UNPIN,PTOKEN=dcwptok2,MF=(E,dcwuupl)  unpin the ucb\n         MODESET MODE=PROB\nterm6b   DS    0H\n\n*/* close the sysprint file                                          */\nterm7    DS    0H\npdcb     USING IHADCB,dcwpdcb\n         TM    pdcb.DCBOFLGS,DCBOFOPN is sysprint file open ?\n         BNO   term8                    no, continue\n         CLOSE (dcwpdcb),MODE=31,MF=(E,dcwopenl)\n\n*/*      free the work areas                                         */\nterm8    DS    0H\n         STORAGE RELEASE,ADDR=(rb),LENGTH=dcw24l free 24-bit area\n         LR    r1,rd\n         L     r2,dcwrsult\n         L     rd,4(,rd)\n         STORAGE RELEASE,ADDR=(1),LENGTH=dcwl   free work area\n\n         LR    rf,r2                            copy result reg\n         RETURN (14,12),RC=(15)\n\n*/* -------------------------------------------------------------------\n*   format date & time\n* ------------------------------------------------------------------ */\ndtime    STM   re,r2,12(rd)       save some regs\n         LR    r2,r0              copy output area address\n         MVI   0(r2),C' '         blank the output area\n         MVC   1(19,r2),0(r2)\n         MVC   11(9,r2),=X'4021207a20207a2020' edit pattern for time\n         ED    11(9,r2),0(r1)     edited time\n         XC    dcwdw,dcwdw        clear double word work area\n         SLR   rf,rf\n         ICM   rf,3,4(r1)         decimal year\n         SLL   rf,4               shift over a nibble\n         ST    rf,dcwdw+4         store in the double word\n         OI    dcwdw+7,X'0f'      set bottom nibble\n         AP    dcwdw,=P'1900'     calculate the year\n         OI    dcwdw+7,X'0f'      fix bottom nibble for unpk\n         UNPK  7(4,r2),dcwdw      set the year\n         CVB   rf,dcwdw           get binary year\n         N     rf,=A(3)           test for leap year\n         BZ    *+8                 jumps if leap year\n         LA    rf,2                 else set non-leapyr offset\n         ZAP   dcwdw,6(2,r1)      get julian day in double word\n         CVB   r0,dcwdw           get julian day binary\n         LA    re,dtjtab          point to julian table\ndtfind   CH    r0,8(rf,re)        found table entry ?\n         BNH   dtfound             yes, exit loop\n         LA    re,8(,re)          point to next entry\n         B     dtfind              and loop back\ndtfound  MVC   3(3,r2),4(re)      set month from the table\n         SH    r0,0(rf,re)        calculate day of month\n         CVD   r0,dcwdw           get day of month packed\n         L     r0,dcwdw+4         load packed day\n         SLL   r0,20              shift out hi bits\n         SRL   r0,28              shift down\n         STC   r0,0(,r2)          set 1st digit of the month\n         OI    0(r2),C'0'         convert to ebcdic character\n         L     r0,dcwdw+4         load packed day\n         SLL   r0,24              shift out hi bits\n         SRL   r0,28              shift down\n         STC   r0,1(,r2)          set 2nd digit of the month\n         OI    1(r2),C'0'         convert to ebcdic character\n         LM    re,r2,12(rd)       restore regs\n         BR    re                  and thankfully return\ndtjtab   DC    Y(0,0),C'Jan '     Julian date table\n         DC    Y(31,31),C'Feb '\n         DC    Y(60,59),C'Mar '\n         DC    Y(91,90),C'Apr '\n         DC    Y(121,120),C'May '\n         DC    Y(152,151),C'Jun '\n         DC    Y(182,181),C'Jul '\n         DC    Y(213,212),C'Aug '\n         DC    Y(244,243),C'Sep '\n         DC    Y(274,273),C'Oct '\n         DC    Y(305,304),C'Nov '\n         DC    Y(335,334),C'Dec '\n         DC    Y(999,999),C'??? '\n\n*/* -------------------------------------------------------------------\n*   error routines\n* ------------------------------------------------------------------ */\n\nEnoparm #MSG   'No parameters were specified'\n         j     Eexit\nEbadparm MVC   dcwdw4,=CL8' '     init dw to blanks\n         CHI   r4,8               test parameter length left\n         jnh   *+8                 continue if not too long\n         LHI   r4,8                 else reset length\n         AHI   r4,-1              decrement for EX\n         jm    *+4+4+6             bypass copy if nothing left\n         EX    r4,*+4               copy area near the error\n         MVC   dcwdw4(0),0(r3)       (executed)\n        #MSG   '** Error in parameters near %s:8',dcwdw4\n         j     Eexit\nEbaducbl CH    RF,=Y(4)\n         je    Enoucb\n        #MSG   '** UCBLOOK error for unit %x4:2: rc 0x%x rsn 0x%x',    X\n               0(r2),dcwretcd,dcwrsncd\n         j     Eexit\nEnoucb  #MSG   '** UCB not found for unit %x4:2',0(r2)\n         j     Eexit\nEbaducbt DS    0H\n         USING UCBOB,r2\n        #MSG   '** UCB for unit %x4:2 is not dasd, type is %x:1',      X\n               UCBCHAN,UCBTBYT3\n         j     Eexit\n         DROP  r2\nEbaducbs DS    0H\n         USING UCBOB,r2\n         #MSG  '** Device %x4:2 is not offline',UCBCHAN\n         j     Eexit\n         DROP  r2\nEbaducbc DS    0H\n         USING UCBOB,r2\n         #MSG  '** IOSCAPU CAPTUCB failed for %x4:2; rc=0x%x rsn=0x%x',X\n               UCBCHAN,dcwretcd,dcwrsncd\n         j     Eexit\n         DROP  r2\nEbaddeba DS    0H\n         USING UCBOB,r2\n         #MSG  '** DEBCHK ADD for %x4:2 failed; rc=0x%x',              X\n               UCBCHAN,dcwretcd\n         j     Eexit\n         DROP  r2\nEsnserr  DS    0H\n         C     r2,dcwcucb1\n         jne   Esnserr2\nEsnserr1 #MSG  '** Sense failed for 0x%x4:2: command %x2:1, CC 0x%x2:1,X\n                Stat 0x%x4:2',dcwunit1,dcwccw1,dcwecb1,iob1.IOBSTBYT\n         j     Eexit\nEsnserr2 #MSG  '** Sense failed for 0x%x4:2: command %x2:1, CC 0x%x2:1,X\n                Stat 0x%x4:2',dcwunit2,dcwccw2,dcwecb2,iob2.IOBSTBYT\n         j     Eexit\nEdifdevt #MSG  '** Device types differ: %x4:2 is %x4:2, %x4:2 is %x4:2'X\n               ,dcwunit1,rdc1.RDCdevt,dcwunit2,rdc2.RDCdevt\n         j     Eexit\n\nEbadhcyl ahi   r1,-1\n         stcm  r1,3,dcwcc\n        #MSG   '** High cyl %x4:2 exceeds device %x4:2 high cyl %x4:2',X\n               dcwhicyl,0(r2),dcwcc\n         j     Eexit\n\nEbadlcyl #MSG  '** Low cyl %x4:2 greater than high cyl %x4:2',         X\n               dcwlocyl,dcwhicyl\n         j     Eexit\n\nEioerr1  #MSG  '** I/O error %x4:2 cchh=%x8:4 cc=%x2:1 csw=%x8:4%x8:4',X\n               dcwunit1,dcwcchh,dcwecb1,iob1.IOBCSW8,iob1.IOBCSW8+4\n         j     Eexit\n\nEioerr2  #MSG  '** I/O error %x4:2 cchh=%x8:4 cc=%x2:1 csw=%x8:4%x8:4',X\n               dcwunit2,dcwcchh,dcwecb2,iob2.IOBCSW8,iob2.IOBCSW8+4\n         j     Eexit\n\nEexit    MVC   dcwrsult,=A(16)    error return code\n         j     terminat           terminate\n\n*/* -------------------------------------------------------------------\n*   literals and constants\n* ------------------------------------------------------------------ */\n         LTORG ,\ndelimtrt TRT   0(0,r3),delimtab   *** executed ***\nparmmvc  MVC   dcwdw(0),0(r3)     *** executed ***\nparmclc  CLC   0(0,rf),dcwdw      *** executed ***\nparmhexc TRT   dcwdw(0),hexchars  *** executed ***\nparmhex  TR    dcwdw(0),hextab    *** executed ***\nparmpack PACK  dcwdw2,dcwdw(0)    *** executed ***\nmoddcb   DCB   DDNAME=0,DSORG=PS,MACRF=E\nmoddcbl  EQU   *-moddcb\nprtdcb   DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PL,DCBE=PRTDCBE\nprtdcbl  EQU   *-prtdcb\nprtdcbe  DCBE  RMODE31=BUFF\nprtdcbel EQU   *-prtdcbe\nopenl    OPEN  (0),MODE=31,MF=L\nopenll   EQU   *-openl\n         UCBLOOK MF=(L,ulpl)\n         UCBPIN MF=(L,uupl)\n         IOSCAPU MF=(L,cupl)\nhextab   DC    256X'00'\n         ORG   hextab+C'0'\n         DC    AL1(0,1,2,3,4,5,6,7,8,9)\n         ORG   hextab+C'a'\n         DC    AL1(10,11,12,13,14,15)\n         ORG   hextab+C'A'\n         DC    AL1(10,11,12,13,14,15)\n         ORG   hextab+256\ndelimtab DC    256x'0'\n         ORG   delimtab+C','\n         DC    X'ff'\n         ORG   delimtab+256\n         DROP  ,\nhexchars DC    256x'ff'\n         ORG   hexchars+C'a'\n         DC    6x'0'\n         ORG   hexchars+C'A'\n         DC    6x'0'\n         ORG   hexchars+C'0'\n         DC    10x'0'\n         ORG   hexchars+256\nupcase   DC    C' ',255AL1(*-upcase)\n         ORG   upcase+c'a'\n         DC    C'ABCDEFGHI'\n         ORG   upcase+c'j'\n         DC    C'JKLMNOPQR'\n         ORG   upcase+c's'\n         DC    C'STUVWXYZ'\n         ORG   upcase+256\nhex2char EQU   *-240\n         DC    C'0123456789ABCDEF'\n         DROP  ,\nmainend  DS    0D\n\n\n*/* -------------------------------------------------------------------\n*        subroutine to issue messages\n* ------------------------------------------------------------------ */\n          USING msgr,r9\n          USING dcw,rd\n          USING dcw24,rb\n          USING DISKCOMP,rc\n          USING (DISKCOMP+4095,mainend),ra\nmsgr      STM  r0,rf,dcwsave1\n          LR   r9,rf\n          USING IHADCB,dcwpdcb\n          TM   DCBOFLGS,DCBOFOPN\n          BO   mr_opened            continue if message file is opened\n\n          LR   r2,r1                save reg 1\n          TM   dcwflags,dcwnoprt    test if no print file\n          BO   mr_ret                return if not\n          CLI  dcwprddn,0           print ddname specified yet ?\n          BNE  mr_open2              yes, continue\n          DEVTYPE =C'SYSPRINT',dcwdw  is SYSPRINT available ?\n          LR   r1,r2                   restore reg 1\n          LTR  rf,rf                    no, issue WTO\n          BNZ  mr_opened\n          MVC  dcwprddn,=C'SYSPRINT'     else use SYSPRINT ddname\nmr_open2  MVC  dcwpdcb,prtdcb       copy the model print dcb\n          MVC  DCBDDNAM,dcwprddn    set the print ddname\n          MVC  dcwpdcbe,prtdcbe     copy model print dcbe\n          LA   r1,dcwpdcbe          set dcbe address\n          ST   r1,DCBDCBE            in the dcb\n          OI   dcwflags,dcwnoprt    presume no print\n          DEVTYPE DCBDDNAM,dcwdw    issue devtype for the ddname\n          LTR  rf,rf                test devtype return code\n          BNZ  mr_ret                return if some error\n          L    r1,=A(mr_oxit)       get address of the open exit\n          LA   rf,mr_oxitl          get open exit length\n          BCTR rf,0                 decrement\n          EX   rf,*+4               copy the open exit\n          MVC  dcwoxit(0),0(r1)     *** executed ***\n          LA   r1,dcwoxit           get open exit addr\n          ST   r1,dcwexlst          set in exit list\n          MVI  dcwexlst,x'85'       set exit type\n          LA   r1,dcwexlst          point to exit list\n          STCM r1,7,DCBEXLSA        set exlst addr in the dcb\n          MVC  dcwopenl,openl       copy model open list\n          OPEN (dcwpdcb,OUTPUT),MODE=31,MF=(E,dcwopenl)\n          TM   DCBOFLGS,DCBOFOPN    did the file open ?\n          BNO  mr_ret                no, return\n          NI   dcwflags,255-dcwnoprt  else turn off `noprt' bit\n          LR   r1,r2                restore reg 1\n\nmr_opened LM   r4,r5,0(r1)          pattern addr, length\n\n          BCTR r5,0\n          LA   r3,8(,r1)            first parameter\n          LA   r6,dcwmsg\n          MVI  dcwmsg,C' '          init msg to blanks\n          MVC  dcwmsg+1(L'dcwmsg-1),dcwmsg\n\nmr_loop   LTR  r5,r5\n          BM   mr_exit\n          LA   r1,1(r4,r5)\n          SLR  r2,r2\n          EX   r5,mr_trt1\n          SR   r1,r4                length scanned\n          BNP  mr_skip1\n          LR   rf,r1\n          BCTR rf,0\n          EX   rf,mr_mvc1           copy literal text\n          AR   r6,r1\nmr_skip1  AR   r4,r1\n          SR   r5,r1\n          BM   mr_exit\n          BP   mr_skip2\n\n          MVC  0(1,r6),0(r4)        string ends in special char\n          LA   r6,1(,r6)\n          B    mr_exit\n\nmr_skip2  B    *(r2)                br on special char type\n          B    mr_pct               '%'\n          B    mr_bs                '\\'\n\nmr_pct    CLI  1(r4),C's'\n          BE   mr_pct_s\n          CLI  1(r4),C'x'\n          BE   mr_pct_x\n          CLI  1(r4),C'd'\n          BE   mr_pct_d\n          MVC  0(1,r6),0(r4)        treat '%' as any other char\n          LA   r6,1(,r6)\n          LA   r4,1(,r4)\n          BCTR r5,0\n          B    mr_loop\nmr_pct_s  L    r7,0(,r3)            load string ptr\n          LA   r3,4(,r3)\n          LA   r4,2(,r4)            point past '%s'\n          SH   r5,=Y(2)\n          BAL  re,mr_op             r1 - target len, r2 - source len\n          LTR  r2,r2\n          BNZ  mr_pct_s3\n          LR   r2,r7                source len = 0, find end of string\nmr_pct_s1 CLI  0(r2),C' '\n          BNH  mr_pct_s2\n          LA   r2,1(,r2)\n          B    mr_pct_s1\nmr_pct_s2 SR   r2,r7\n          BNP  mr_loop\nmr_pct_s3 LR   rf,r2                copy source string to the msg\n          BCTR rf,0\n          EX   rf,mr_mvc2\n          LTR  r1,r1\n          BNZ  mr_pct_s5\n          AR   r6,r2                truncate trailing spaces if\nmr_pct_s4 BCTR r6,0                  target len is 0\n          CLI  0(r6),C' '\n          BNH  mr_pct_s4\n          LA   r6,1(,r6)\n          B    mr_loop\nmr_pct_s5 CR   r1,r2\n          BH   mr_pct_s6\n          AR   r6,r1                truncate the string\n          B    mr_loop\nmr_pct_s6 AR   r6,r2                pad string with trailing blanks\n          SR   r1,r2\nmr_pct_s7 MVI  0(r6),C' '\n          LA   r6,1(,r6)\n          BCT  r1,mr_pct_s7\n          B    mr_loop\n\nmr_pct_x  L    r7,0(,r3)            load hex ptr\n          LA   r3,4(,r3)\n          LA   r4,2(,r4)            point past '%x'\n          SH   r5,=Y(2)\n          BAL  re,mr_op             r1 - target len, r2 - source len\n          LTR  r2,r2\n          BNZ  *+8\n          LA   r2,4                 default source len is 4\n          EX   r2,mr_pct_x_unpk\n          TR   dcwdw,mr_hextab\n          LTR  r1,r1\n          BNZ  mr_pct_x1\n          LA   r1,8                 determine default target len\n          CLC  =C'00',dcwdw\n          BNE  mr_pct_x1\n          LA   r1,6\n          CLC  =C'0000',dcwdw\n          BNE  mr_pct_x1\n          LA   r1,4\n          CLC  =C'000000',dcwdw\n          BNE  mr_pct_x1\n          LA   r1,2\nmr_pct_x1 LA   r7,dcwdw+8           copy the hex string to the msg\n          SR   r7,r1\n          BCTR r1,0\n          EX   r1,mr_mvc2\n          LA   r6,1(r1,r6)\n          B    mr_loop\n\nmr_pct_d  L    r7,0(,r3)            load decimal ptr\n          LA   r3,4(,r3)\n          LA   r4,2(,r4)            point past '%d'\n          SH   r5,=Y(2)\n          BAL  re,mr_op             r1 - target len, r2 - source len\n          LTR  r2,r2\n          BNZ  *+8\n          LA   r2,4                 default source len is 4\n          LA   rf,4\n          SR   rf,r2\n          LA   re,15\n          SRL  re,0(rf)\n          EX   re,mr_pct_d_icm\n          CVD  rf,dcwdw\n          MVC  dcwdw2(16),=X'40202020202020202020202020202120'\n          ED   dcwdw2(16),dcwdw\n          LTR  r1,r1\n          BNZ  mr_pct_d2\n          LA   rf,dcwdw2+16         default length -\nmr_pct_d1 BCTR rf,0                  truncate leading spaces\n          CLI  0(rf),C' '\n          BH   mr_pct_d1\n          LA   r1,dcwdw2+15\n          SR   r1,rf\nmr_pct_d2 LA   r7,dcwdw2+16\n          SR   r7,r1\n          BCTR r1,0\n          EX   r1,mr_mvc2\n          LA   r6,1(r1,r6)\n          B    mr_loop\n\nmr_bs     MVC  0(1,r6),1(r4)        copy char following '\\'\n          LA   r6,1(,r6)\n          LA   r4,2(,r4)\n          SH   r5,=Y(2)\n          B    mr_loop\n\nmr_exit   LA   r1,dcwmsg\n          SR   r6,r1                calculate msg length\n          BNP  mr_ret\n          TM   DCBRECFM,DCBRECCA+DCBRECCM\n          BZ   *+8\n          LA   r6,1(,r6)            increment for carriage control\n\n          TM   DCBOFLGS,DCBOFOPN\n          BNO  mr_wto\n          TM   DCBRECFM,DCBRECU\n          BO   mr_u\n          TM   DCBRECFM,DCBRECF\n          BO   mr_f\n          TM   DCBRECFM,DCBRECV\n          BO   mr_v\n\nmr_u      CH   r6,DCBBLKSI\n          BNH  *+8\n          LH   r6,DCBBLKSI\n          STH  r6,DCBLRECL\n          PUT  IHADCB\n          TM   DCBRECFM,DCBRECCA+DCBRECCM\n          BZ   mr_u1\n          MVI  0(r1),C' '\n          LA   r1,1(,r1)\n          BCTR r6,0\n          TM   DCBRECFM,DCBRECCA\n          BO   mr_u1\n          BCTR r1,0\n          MVI  0(r1),X'09'\n          LA   r1,1(,r1)\nmr_u1     BCTR r6,0\n          EX   r6,mr_mvc3\n          B    mr_ret\n\nmr_f      CH   r6,DCBLRECL\n          BNH  *+8\n          LH   r6,DCBLRECL\n          PUT  IHADCB\n          TM   DCBRECFM,DCBRECCA+DCBRECCM\n          BZ   mr_f1\n          MVI  0(r1),C' '\n          LA   r1,1(,r1)\n          BCTR r6,0\n          TM   DCBRECFM,DCBRECCA\n          BO   mr_f1\n          BCTR r1,0\n          MVI  0(r1),X'09'\n          LA   r1,1(,r1)\nmr_f1     BCTR r6,0\n          EX   r6,mr_mvc3\n          B    mr_ret\n\nmr_v      LA   r6,4(,r6)\n          LH   r1,DCBBLKSI\n          SH   r1,=Y(4)\n          CR   r6,r1\n          BNH  *+6\n          LR   r6,r1\n          STH  r6,DCBLRECL\n          PUT  IHADCB\n          STH  r6,0(,r1)\n          XC   2(2,r1),2(r1)\n          LA   r1,4(,r1)\n          SH   r6,=Y(4)\n          TM   DCBRECFM,DCBRECCA+DCBRECCM\n          BZ   mr_v1\n          MVI  0(r1),C' '\n          LA   r1,1(,r1)\n          BCTR r6,0\n          TM   DCBRECFM,DCBRECCA\n          BO   mr_v1\n          BCTR r1,0\n          MVI  0(r1),X'09'\n          LA   r1,1(,r1)\nmr_v1     BCTR r6,0\n          EX   r6,mr_mvc3\n          B    mr_ret\n\nmr_wto    LA   r6,4(,r6)\n          STH  r6,dcwmsgl\n          MVC  dcwmsgl+2(2),=X'8000'\n          LA   r1,dcwmsg(r6)\n          MVC  0(4,r1),=X'00000020'\n          WTO  MF=(E,dcwmsgl)\n\n\nmr_ret    LM   r0,rf,dcwsave1\n          BR   re\n\n*/* -------------------------------------------------------------------\n* message subroutine to get operand lengths\n* ------------------------------------------------------------------ */\n\nmr_op     SLR  r1,r1\n          SLR  r2,r2\nmr_op1    LTR  r5,r5                first number is target length\n          BMR  re\n          CLI  0(r4),C'0'\n          BL   mr_op2\n          IC   rf,0(,r4)\n          N    rf,=A(X'0000000f')\n          MH   r1,=Y(10)\n          AR   r1,rf\n          LA   r4,1(,r4)\n          BCTR r5,0\n          B    mr_op1\nmr_op2    CLI  0(r4),C':'          second number follows a ':'\n          BNER re\nmr_op3    LA   r4,1(,r4)           second number is source length\n          SH   r5,=Y(1)\n          BMR  re\n          CLI  0(r4),C'0'\n          BLR  re\n          IC   rf,0(,r4)\n          N    rf,=A(X'0000000f')\n          MH   r2,=Y(10)\n          AR   r2,rf\n          B    mr_op3\n\n*/* ---------------------------------------------------------------- */\n\nmr_mvc1   MVC  0(0,r6),0(r4)\nmr_trt1   TRT  0(0,r4),mr_tab1\nmr_mvc2   MVC  0(0,r6),0(r7)\nmr_mvc3   MVC  0(0,r1),dcwmsg\nmr_pct_x_unpk  UNPK dcwdw(9),0(0,r7)\nmr_pct_d_icm   ICM rf,0,0(r7)\nmr_tab1   DC   XL256'0'\n          ORG  mr_tab1+C'%'\n          DC   AL1(4)\n          ORG  mr_tab1+C'\\'\n          DC   AL1(8)\n          ORG  mr_tab1+256\nmr_hextab EQU  *-240\n          DC   C'0123456789abcdef'\n          LTORG ,\n         #MSG  TYPE=GEN           messages\n          DROP ,\n\n\n*/* -------------------------------------------------------------------\n*   message open exit - relocated to 24 bit storage\n* ------------------------------------------------------------------ */\n\n         USING mr_oxit,rf\n         USING IHADCB,R1\nmr_oxit  CLI   DCBRECFM,0          any record format ?\n         BNE   *+8                  jumps if yes\n         MVI   DCBRECFM,DCBRECV+DCBRECBR else set to `vb'\n\n         SLR   r0,r0               get a zero\n         CH    r0,DCBLRECL         any lrecl\n         BNE   *+10                 jumps if yes\n         MVC   DCBLRECL,=Y(125)      copy default lrecl\n\n         CH    r0,DCBBLKSI         any blksize\n         BNE   *+10                 jumps if yes\n         MVC   DCBBLKSI,=Y(4096)     copy default blksize\n\n         TM    DCBRECFM,DCBRECU    test record type\n         BO    mr_oxitu             undefined\n         TM    DCBRECFM,DCBRECV    test record type\n         BO    mr_oxitv             variable\n         TM    DCBRECFM,DCBRECF    test record type\n         BO    mr_oxitf             fixed\n         B     mr_oxit0            unknown, return\n\nmr_oxitu MVC   DCBLRECL,DCBBLKSI   undefined, set lrecl from blksize\n         B     mr_oxit0            return\n\nmr_oxitv LH    r3,DCBBLKSI         variable, load blksize\n         LA    r0,4                calculate maximum\n         SR    r3,r0                lrecl\n         CH    r3,DCBLRECL         check against lrecl\n         BNL   mr_oxit0             return if not too high\n         STH   r3,DCBLRECL           else reset to max\n         B     mr_oxit0            return\n\nmr_oxitf LH    r3,DCBBLKSI         fixed, load blksize\n         SLR   r2,r2               clear for divide\n         LH    r0,DCBLRECL         load lrecl\n         DR    r2,r0               divide lrecl into blksize\n         LTR   r2,r2               test if any remainder\n         BZ    mr_oxit0            return if not\n         MH    r3,DCBLRECL         calculate new blksize\n         STH   r3,DCBBLKSI         set new blksize\n\nmr_oxit0 BR    re\n         LTORG ,\nmr_oxitl EQU   *-mr_oxit\n         DROP  ,\n\n*/* -------------------------------------------------------------------\n*   workareas\n* ------------------------------------------------------------------ */\ndcw      DSECT ,                  offline dump/restore workarea\ndcwid    DS    0CL4'dcw '         identifier\ndcwsave  DS    18F                standard save area\ndcwsave0 DS    16F                save area for dumpr/restorer\ndcwsave1 DS    16F                save area for writer\ndcw24a   DS    A                  24-bit work area address\ndcwrsult DS    F                  result (return) value\ndcwfcn   DS    CL8                function (backup or restore)\ndcwflags DS    X                  flag bits\ndcwnoprt EQU   X'80'              messsage dataset not available\ndcwflag1 DS    X                  flag bits for unit 1\ndcwflag2 DS    X                  flag bits for unit 2\ndcwpin   EQU   X'80'              offline dasd ucb pinned\ndcwcucb  EQU   X'40'              offline dasd ucb captured\ndcwdebad EQU   X'20'              offline dasd ucb deb added\ndcwnry   EQU   X'10'              offline dasd ucb `not ready' bit\ndcwunit1 DS    H                  offline unit 1 address\ndcwunit2 DS    H                  offline unit 2 address\ndcwlocyl DS    H                  low cylinder to dump\ndcwhicyl DS    H                  high cylinder to dump\ndcwretcd DS    F                  return code\ndcwrsncd DS    F                  reason code\ndcwucb1  DS    A                  ucb 1 address\ndcwucb2  DS    A                  ucb 2 address\ndcwcucb1 DS    A                  captured ucb 1 address\ndcwcucb2 DS    A                  captured ucb 2 address\ndcwdeb1  DS    A                  deb 1 address\ndcwdeb2  DS    A                  deb 2 address\ndcwptok1 DS    D                  ucb 1 pin token\ndcwptok2 DS    D                  ucb 2 pin token\ndcwctime DS    D                  current date/time\ndcwdtime DS    CL20               dat/time display area\ndcwdw    DS    D                  double word work areas\ndcwdw2   DS    D\ndcwdw3   DS    D\ndcwdw4   DS    D\ndcwtrks  DS    F                  tracks read\ndcwdiffs DS    F                  differences found\ndcwlen1  DS    F                  unit 1 track length\ndcwlen2  DS    F                  unit 2 track length\n         DS    0D\ndcwprddn DS    CL8                print ddname\ndcwpdcbe DS    XL(prtdcbel)       print dcbe\n         DS    0D\ndcwopenl DS    XL(openll)         open parameter list\n         DS    0D\ndcwulpl  DS    XL(ulpll)          ucblook parameter list\n         DS    0D\ndcwuupl  DS    XL(uupll)          ucbpin unpin parameter list\n         DS    0D\ndcwcupl  DS    XL(cupll)          ioscapu parameter list\n         DS    0D\ndcwmsgl  DS    F                  message length (for WTO)\ndcwmsg   DS    CL256              message\ndcwmsgpl DS    24F                message parameter list\ndcwl     EQU   *-dcw\n\ndcw24    DSECT ,                  24-bit work area\ndcw24id  DC    CL4'dc24'          identifier\ndcwzeros DS    XL16               24-bit zeroes\ndcwpdcb  DS    XL(prtdcbl)        print dcb\ndcwexlst DS    F                  dcb exit list\ndcwdcb1  DS    XL(moddcbl)        device 1 dcb\ndcwccw1  DS    8D                 device 1 channel program\ndcwccwl  EQU   *-dcwccw1                   channel program length\ndcwiob1  DS    XL40               device 1 iob\ndcwlrp1  DS    XL16               device 1 locate record parm area\ndcwecb1  DS    F                  device 1 ecb\ndcwsnsi1 DS    XL20               device 1 snsid info\ndcwrdc1  DS    XL64               device 1 rdc info\ndcwrcd1  DS    XL256              device 1 rcd info\ndcwsnss1 DS    XL40               device 1 snss info\ndcwsns1  DS    XL32               device 1 sense info\ndcwdcb2  DS    XL(moddcbl)        device 2 dcb\ndcwccw2  DS    8D                 device 2 channel program\ndcwiob2  DS    XL40               device 2 iob\ndcwlrp2  DS    XL16               device 2 locate record parm area\ndcwecb2  DS    F                  device 2 ecb\ndcwsnsi2 DS    XL20               device 2 snsid info\ndcwrdc2  DS    XL64               device 2 rdc info\ndcwrcd2  DS    XL256              device 2 rcd info\ndcwsnss2 DS    XL40               device 2 snss info\ndcwsns2  DS    XL32               device 2 sense info\ndcwoxit  DS    XL256              relocated message open exit\ndcwcchh  DS    0F                 current cchh\ndcwcc    DS    H\ndcwhh    DS    H\n         DS    0D\ndcwecbl  DS    2A                 ecb wait list\ndcwbuf1  DS    A                  device 1 buffer address\ndcwbuf2  DS    A                  device 2 buffer address\ndcwbufs  DS    (2*65536)X         buffers\ndcw24l   EQU   *-dcw24\n\nRDCinfo  DSECT ,                  read device characteristics info\nRDCsdt   DS    XL2                storage director type\nRDCsdmi  DS    X                  storage director model information\nRDCdevt  DS    XL2                device type\nRDCdevm  DS    X                  device model\nRDCdasdf DS    XL4                device & storage director facilities\nRDCclass DS    X                  device class code\nRDCtype  DS    X                  device type code\nRDCprime DS    XL2                number of primary cylinders\nRDCheads DS    XL2                tracks per cylinde\nRDCsctrs DS    X                  number of sectors\nRDCtrkln DS    XL3                total track length (usable)\nRDChar0  DS    XL2                length of ha and r0\nRDCtccf  DS    X                  track capacity calculation formula\nRDCfctrs DS    XL5                track capacity calculation factors\nRDCacyl  DS    XL2                address of first alternate cylinder\nRDCacyln DS    XL2                number of alternate tracks\nRDCdcyl  DS    XL2                address of first diagnostic cylinder\nRDCdcyln DS    XL2                number of diagnostic tracks\nRDCscyl  DS    XL2                address of first device support cyl\nRDCscyln DS    XL2                number of device support tracks\nRDCmdrid DS    X                  mdr record id\nRDCobrid DS    X                  obr record id\nRDCsdtc  DS    X                  storage director type code\nRDCrtspl DS    X                  read trackset parameter length\nRDCmaxr0 DS    XL2                maximum record zero data length\n         DS    X                  (reserved)\nRDCtss   DS    X                  track set size\nRDCatccf DS    X                  additional track capacity calc. factr\nRDCrps   DS    XL2                rps sector calculation factors\n         DS    XL3                (reserved)\nRDCgdff  DS    X                  generic device/cu functions/features\n         DS    X                  (reserved -- zeroes)\nRDCrduc  DS    X                  real control unit code\nRDCrdc   DS    X                  real device code\n         DS    XL6                (reserved)\nRDCinfol EQU   *-RDCinfo\n\nLRparm   DSECT ,                  locate record paramete\nLRop     DS    X                  operation byte\nLRocount EQU   B'00000000'        orient count\nLRohome  EQU   B'01000000'        orient home\nLRodata  EQU   B'10000000'        orient data\nLRoindex EQU   B'11000000'        orient index\nLRorient EQU   X'00'              orient\nLRwrite  EQU   X'01'              write data\nLRfwrite EQU   X'03'              format write\nLRread   EQU   X'06'              read data\nLRwt     EQU   X'0b'              write track\nLRrt     EQU   X'0c'              read tracks\nLRrd     EQU   X'16'              read\nLRaux    DS    X                  auxiliary byte\nLRusetlf EQU   B'10000000'        transfer length factor specified\nLRrcccw  EQU   B'00000001'        a read count ccw is suffixed\n         DS    X\nLRcount  DS    X                  count parameter\nLRseek   DS    0XL4               seek addr\nLRseekcc DS    XL2\nLRseekhh DS    XL2\nLRsearch DS    0XL5               search arg\nLRsrchcc DS    XL2\nLRsrchhh DS    XL2\nLRsrchr  DS    X\nLRsector DS    X\nLRtlf    DS    XL2                transfer length factor\nLRparml  EQU   *-LRparm\n\n*/* -------------------------------------------------------------------\n*   dsects\n* ------------------------------------------------------------------ */\n         PRINT NOGEN\n         DCBD  DSORG=PS\n         IHADCBE ,\nUCBDSECT DSECT ,\n         IEFUCBOB ,\n         IEZDEB ,\nDEBLENGTH EQU  (DEBBASND-DEBAVT)+(DEBDASDE-DEBDASD)+DEBXLEN\n         IEZIOB ,\n         IHAECB ,\n         IOSDCCW ,\n         CVT   DSECT=YES\n         IHAPSA ,\n         IKJTCB ,\n\n*/* -------------------------------------------------------------------\n*   equates\n* ------------------------------------------------------------------ */\nSK    EQU X'07'\nSNSID EQU X'e4'\nSNS   EQU X'04'\nRDC   EQU X'64'\nSNSS  EQU X'54'\nRT    EQU X'de'\nDX    EQU X'63'\nLR    EQU X'47'\nWR0   EQU X'15'\nWCKD  EQU X'1d'\nTIC   EQU X'08'\nPSF   EQU X'27'\nRSSD  EQU X'3E'\nRCD   EQU X'FA'\n\nr0 EQU 0\nr1 EQU 1\nr2 EQU 2\nr3 EQU 3\nr4 EQU 4\nr5 EQU 5\nr6 EQU 6\nr7 EQU 7\nr8 EQU 8\nr9 EQU 9\nra EQU 10\nrb EQU 11\nrc EQU 12\nrd EQU 13\nre EQU 14\nrf EQU 15\n\n   END ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SAMPJCL": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\"\\x01\\x12\\x10o\\x01\\x12\\x10\\x8f\\x11\\'\\x00O\\x00U\\x00\\x00\\xd4\\xc1\\xe4\\xc3\\xc5\\xd9\\xc9@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2012-04-15T00:00:00", "modifydate": "2012-04-17T11:27:22", "lines": 79, "newlines": 85, "modlines": 0, "user": "MAUCERI"}, "text": "Subject:  R: R: R: R: DiskComp program\nFrom:     \"Claudio Mauceri\" <Claudio.Mauceri@hds.com>\nDate:     Thu, 12 Apr 2012 17:27:25 -0400\nTo:       \"Sam Golob\" <sbgolob@cbttape.org>\n\nNote.  This was a request from Sam Golob for Claudio to supply some\n       sample JCL to run the DISKCOMP program and to display output.\n\nHello Sam,\n\nSure, for example, start with two disks (3390-A of 3339 cylinders)\nidentical.\n\n\nJCL:\n\n//STEP1  EXEC PGM=DISKCOMP,\n//       PARM='E030,E930'\n//*      PARM='UNIT1,UNIT2,LOCYL,HICYL,MSGDDN'\n//STEPLIB  DD DISP=SHR,DSN=USER.LINKLIB\n//SYSPRINT DD SYSOUT=*\n\nOutput:\n\ndiskcomp 0.1.1 starting compare 12 Apr 2012 13:54:34, unit1=e030,\n        unit2=e930,locyl=0000, hicyl=0d0a\n50085 tracks read, 0 track differences\n\n\n\nThen, I've put online the first (E030), and I have edited one dataset:\n\nSame JCL:\n\n//STEP1  EXEC PGM=DISKCOMP,\n//       PARM='E030,E930'\n//*      PARM='UNIT1,UNIT2,LOCYL,HICYL,MSGDDN'\n//STEPLIB  DD DISP=SHR,DSN=USER.LINKLIB\n//SYSPRINT DD SYSOUT=*\n\nOutput:\n\ndiskcomp 0.1.1 starting compare 12 Apr 2012 13:56:27, unit1=e030,\n        unit2=e930,locyl=0000, hicyl=0d0a\n0000 0001 compare mismatch\n0027 0008 length  mismatch, length1 is 39090, length2 is 39108\n\nProgram has found CCHH 00000001 different (probably the refdate\nin VTOC),  and CCHH 00270008 of different length (I have deleted\none line from a sequential dataset).\n\n\nIf I limit the program scan range, for example:\n\nJCL:\n\n//STEP1  EXEC PGM=DISKCOMP,\n//       PARM='E030,E930,26,28'\n//*      PARM='UNIT1,UNIT2,LOCYL,HICYL,MSGDDN'\n//STEPLIB  DD DISP=SHR,DSN=USER.LINKLIB\n//SYSPRINT DD SYSOUT=*\n\n\nOutput:\n\ndiskcomp 0.1.1 starting compare 12 Apr 2012 13:57:58, unit1=e030,\n        unit2=e930, locyl=0026, hicyl=0028\n0027 0008 length  mismatch, length1 is 39090, length2 is 39108\n45 tracks read, 1 track differences\n\n\nIt has scanned just the three indicated cylinders  Note that RC\nis 0 if the two packs (or range) are identical, and 4 if not.\n\nAs said, it is really simple.\n\nCiao,\nClaudio.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT868/FILE868.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT868", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}