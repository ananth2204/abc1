*/* -------------------------------------------------------------------
*   Quick&Dirty program to compare two offline devices
*
*   Invocation:
*      //step   EXEC PGM=DISKCOMP,
*      //       PARM='unit1,unit2,locyl,hicyl,msgddn'
*      //STEPLIB  DD DISP=SHR,DSN=apf.authorized.loadlib
*      //msgddn   DD SYSOUT=*
*
*    locyl, hicyl and msgddn are optional
*
*    locyl defaults to 0
*    hicyl defaults to highest cylinder on smallest unit
*    msgddn defaults to SYSPRINT
*
*   Claudio Mauceri  Claudio.Mauceri@hds.com
*   Greg Smith       gsmith@nc.rr.com
*
* Modifications:
* @020 2012-04-17: EAV support added
*
* ------------------------------------------------------------------ */

*/* -------------------------------------------------------------------
*   local macros
* ------------------------------------------------------------------ */
         MACRO
&L      #MSG   &MSG,&TYPE=CALL
         LCLA  &A,&N,&O
         LCLC  &C
         GBLA  &MSG_IX
         GBLC  &MSGS(256)
         AIF   ('&TYPE' EQ 'CALL').CALL,                               x
               ('&TYPE' EQ 'GEN').GEN
         MNOTE 8,'Invalid type specified'
         MEXIT
.*
.CALL    ANOP
&MSG_IX  SETA  &MSG_IX+1
&MSGS(&MSG_IX) SETC '&MSG'
&L       L     re,=A(#MSG&MSG_IX)
         LA    rf,L'#MSG&MSG_IX
&A       SETA  2
&O       SETA  0
&N       SETA  N'&SYSLIST
         AGO   .PL0
.PLLOOP  ANOP
         LA    re,&SYSLIST(&A)
&A       SETA  &A+1
         AIF   (&A GT &N).PLX14
         LA    rf,&SYSLIST(&A)
&A       SETA  &A+1
.PL0     ANOP
         AIF   (&A GT &N).PLX15
         LA    r0,&SYSLIST(&A)
&A       SETA  &A+1
         AIF   (&A GT &N).PLX0
         LA    r1,&SYSLIST(&A)
&A       SETA  &A+1
         AIF   (&A GT &N).PLX1
         STM   re,r1,dcwmsgpl+&O
&O       SETA  &O+16
         AGO   .PLLOOP
.PLX14   ST    re,dcwmsgpl+&O
         AGO   .CALL2
.PLX15   STM   re,rf,dcwmsgpl+&O
         AGO   .CALL2
.PLX0    STM   re,r0,dcwmsgpl+&O
         AGO   .CALL2
.PLX1    STM   re,r1,dcwmsgpl+&O
.CALL2   LA    r1,dcwmsgpl
         L     rf,=a(msgr)
         BALR  re,rf
         MEXIT
.*
.GEN     ANOP
         AIF   ('&L' EQ '').GENNOL
&L       DS    0H
.GENNOL  ANOP
&A       SETA  1
.GENLOOP AIF   (&A GT &MSG_IX).MEND
#MSG&A   DC    C&MSGS(&A)
&A       SETA  &A+1
         AGO   .GENLOOP
.MEND    MEND

*/* -------------------------------------------------------------------
*   mainline routine
* ------------------------------------------------------------------ */
DISKCOMP CSECT ,
DISKCOMP AMODE 31
DISKCOMP RMODE ANY
         j     init
         DC    AL1(init-*)
pgmid    DC    CL8'diskcomp'
vrm      DC    X'000200'          version 0 release 2 modlvl 0
         DC    C' &SYSDATE &SYSTIME '
init     SAVE  (14,12)
         LR    rc,rf              set base reg
         USING DISKCOMP,rc
         LA    ra,4095(,rc)       set 2nd base reg
         USING (DISKCOMP+4095,mainend),ra
         LR    r2,r1              copy parm reg

*/* -------------------------------------------------------------------
*   obtain and initialize workareas
* ------------------------------------------------------------------ */
         STORAGE OBTAIN,LENGTH=dcwl get work area
         ST    r1,8(,rd)          chain save areas
         ST    rd,4(,r1)
         LR    rd,r1              set area base
         USING dcw,rd
         MVC   dcwid,=C'dcw '     set area identifier
         LA    r0,dcw+8           clear the area
         L     r1,=a(dcwl-8)
         SLR   rf,rf
         MVCL  r0,re
         STORAGE OBTAIN,LENGTH=dcw24l,LOC=BELOW get 24-bit work area
         ST    r1,dcw24a          save address
         LR    rb,r1              set 24-bit area base
         USING dcw24,rb
         MVC   dcw24id,=C'dc24'   set 24-bit area identifier
         LA    r0,dcw24+4         clear the 24-bit area
         L     r1,=a(dcw24l-4)
         SLR   rf,rf
         MVCL  r0,re

*/* -------------------------------------------------------------------
*   process PARM= : <unit1>,<unit2>,<locyl>,<hicyl>,<msgddn>
* ------------------------------------------------------------------ */
         NILH  r2,X'7fff'         turn hi parameter reg bit off
         LTR   r2,r2               test parameter reg
         jz    Enoparm             invalid parameter list
         L     r3,0(,r2)          point to parameters
         NILH  r3,X'7fff'         turn hi parameters addr bit off
         LTR   r3,r3               test parameters addr reg
         jZ    Enoparm              invalid parameter list
         LH    r4,0(,r3)          get length of parameters
         LTR   r4,r4               test length
         jnp   Enoparm              invalid parameter list
         AHI   r4,-1              decrement length for EX
         AHI   r3,2               point past length
         SLR   r2,r2              clear TRT register

*/*      1st parm is hex unit address of the offline device 1
         XC    dcwdw,dcwdw        clear double-word work area
         LA    r1,1(r3,r4)        point to parameter end
         EX    r4,delimtrt        search for `,'
*/*      TRT   0(0,r3),delimtab   *** executed ***                   */
         SR    r1,r3              calculate parameter length
         AHI   r1,-1               minus one
         jm    Ebadparm           error if 1st parm is missing
         CHI   r1,4               check 2nd parm length
         jnl   Ebadparm           error if too long
         EX    r1,parmmvc         copy 2nd parameter
*/*      MVC   dcwdw(0),0(r3)     *** executed ***                   */
         TR    dcwdw,upcase       convert to uppercase
         SLR   r5,r5              clear unit address
         EX    r1,parmhexc        test if all hex digits
*/*      TRT   drcdw(0),hexchars  *** executed ***                   */
         jnz   Ebadparm            error if not
         EX    r1,parmhex         convert to hex digits
*/*      TR    dcwdw(0),hextab    *** executed ***                   */
         LA    rf,1(,r1)          need an extra byte for pack
         EX    rf,parmpack        get hex value
*/*      PACK  dcwdw2,dcwdw(0)    *** executed ***                   */
         ICM   r5,3,dcwdw2+5      load hex value
         STCM  r5,3,dcwunit1      save unit address
         LA    r1,2(,r1)          length of parm + `,'
         AR    r3,r1              point to 2nd parameter
         SR    r4,r1              readjust length left

*/*      2nd parm is hex unit address of the offline device 2
         LTR   r4,r4              test for 2nd parm
         jm    Ebadparm            error if offline device is missing
         XC    dcwdw,dcwdw        clear double-word work area
         LA    r1,1(r3,r4)        point to parameter end
         EX    r4,delimtrt        search for `,'
*/*      TRT   0(0,r3),delimtab   *** executed ***                   */
         SR    r1,r3              calculate parameter length
         AHI   r1,-1               minus one
         jm    Ebadparm           error if 1st parm is missing
         CHI   r1,4               check parm length
         jnl   Ebadparm           error if too long
         EX    r1,parmmvc         copy parameter
*/*      MVC   dcwdw(0),0(r3)     *** executed ***                   */
         TR    dcwdw,upcase       convert to uppercase
         SLR   r5,r5              clear unit address
         EX    r1,parmhexc        test if all hex digits
*/*      TRT   drcdw(0),hexchars  *** executed ***                   */
         jnz   Ebadparm            error if not
         EX    r1,parmhex         convert to hex digits
*/*      TR    dcwdw(0),hextab    *** executed ***                   */
         LA    rf,1(,r1)          need an extra byte for pack
         EX    rf,parmpack        get hex value
*/*      PACK  dcwdw2,dcwdw(0)    *** executed ***                   */
         ICM   r5,3,dcwdw2+5      load hex value
         STCM  r5,3,dcwunit2      save unit address
         LA    r1,2(,r1)          length of parm + `,'
         AR    r3,r1              point to 2nd parameter
         SR    r4,r1              readjust length left

*/*      3rd parm is low cylinder to compare in hex                  */
         SLR   r1,r1              clear reg 1
         LHI   r5,0                -1
         LTR   r4,r4              test for low cylinder
         jm    gotlocyl            continue if missing
         LA    r1,1(r3,r4)        point to parameter end
         EX    r4,delimtrt        search for `,'
         SR    r1,r3              calculate parameter length
         AHI   r1,-1               minus one
         jm    gotlocyl             continue if missing
         XC    dcwdw,dcwdw        clear double-word work area
         CHI   r1,7               check parm length                @020
         jnl   Ebadparm           error if too long
         EX    r1,parmmvc         copy parameter
*/*      MVC   dcwdw(0),0(r3)     *** executed ***                   */
         TR    dcwdw,upcase       convert to uppercase
         EX    r1,parmhexc        test if all hex digits
*/*      TRT   drcdw(0),hexchars  *** executed ***                   */
         jnz   Ebadparm            error if not
         EX    r1,parmhex         convert to hex digits
*/*      TR    dcwdw(0),hextab    *** executed ***                   */
         LA    rf,1(,r1)          need an extra byte for pack
         EX    rf,parmpack        get hex value
*/*      PACK  dcwdw2,dcwdw(0)    *** executed ***                   */
         SLR   r5,r5              clear low cylinder
*        ICM   r5,3,dcwdw2+5      load hex value                   @020
         ICM   r5,15,dcwdw2+3     load hex value                   @020
*gotlocyl STCM  r5,3,dcwlocyl      save low cylinder               @020
gotlocyl ST    r5,dcwlocyl      save low cylinder                  @020
         LA    r1,2(,r1)          length of parm + `,'
         AR    r3,r1              point to 2nd parameter
         SR    r4,r1              readjust length left

*/*      4th parm is high cylinder to compare in hex                 */
         SLR   r1,r1              clear reg 1
         LHI   r5,-1               -1
         LTR   r4,r4              test for high cylinder
         jm    gothicyl            continue if missing
         LA    r1,1(r3,r4)        point to parameter end
         EX    r4,delimtrt        search for `,'
         SR    r1,r3              calculate parameter length
         AHI   r1,-1               minus one
         jm    gothicyl             continue if missing
         XC    dcwdw,dcwdw        clear double-word work area
         CHI   r1,7               check parm length                @020
         jnl   Ebadparm           error if too long
         EX    r1,parmmvc         copy parameter
         TR    dcwdw,upcase       convert to uppercase
         EX    r1,parmhexc        test if all hex digits
         jnz   Ebadparm            error if not
         EX    r1,parmhex         convert to hex digits
         LA    rf,1(,r1)          need an extra byte for pack
         EX    rf,parmpack        get hex value
*/*      PACK  dcwdw2,dcwdw(0)    *** executed ***                   */
         SLR   r5,r5              clear high cylinder
*        ICM   r5,3,dcwdw2+5      load hex value                   @020
         icm   r5,b'1111',dcwdw2+3 load hex value                  @020
*gothicyl STCM  r5,3,dcwhicyl      save high cylinder              @020
gothicyl ST    r5,dcwhicyl        save high cylinder               @020
         LA    r1,2(,r1)          length of parm + `,'
         AR    r3,r1              point to 2nd parameter
         SR    r4,r1              readjust length left

*/*      5th (and last) parm is the message ddname                   */
         SLR   r1,r1              clear reg 1
         MVC   dcwprddn,=CL8'SYSPRINT' init message ddname
         LTR   r4,r4              test length left
         jm    gotprddn            continue if nothing left
         LA    r1,1(r3,r4)        point to parameter end
****     EX    r4,delimtrt        search for `,'
         SR    r1,r3              calculate parameter length
         AHI   r1,-1               minus one
         jm    gotprddn            continue if missing
         CHI   r1,8               test length
         jnl   Ebadparm            error if too long
         XC    dcwdw,dcwdw        clear double word work area
         EX    r1,parmmvc         copy 3rd parameter
         TR    dcwdw,upcase       convert to uppercase
         MVC   dcwprddn,dcwdw     copy the message ddname
gotprddn LA    r1,2(,r1)          length of parm + `,'
         AR    r3,r1              point to 2nd parameter
         SR    r4,r1              readjust length left

*//FIXME: fake-open should be a subroutine
*/* -------------------------------------------------------------------
*   `fake-open' offline device 1
* ------------------------------------------------------------------ */

*   look for the ucb for the unit & make sure it's an offline dasd
         MVC   dcwulpl,ulpl       copy ucblook parameter list
         MODESET MODE=SUP
         UCBLOOK DEVN=dcwunit1,UCBPTR=dcwucb1,PIN,PTOKEN=dcwptok1,     X
               DYNAMIC=YES,RANGE=ALL,LOC=ANY,MF=(E,dcwulpl),           X
               TEXT==C'DISKCOMP offline dasd lookup1'
         STM   rf,r0,dcwretcd     save ret/rsn codes across MODESET
         MODESET MODE=PROB
         LM    rf,r0,dcwretcd     restore ret/rsn codes
         LTR   rf,rf              test ucblook return code
         LA    r2,dcwunit1         bad unit addr if error
         jnz   Ebaducbl           ucblook error
         OI    dcwflag1,dcwpin    indicate ucb has been pinned
         L     r2,dcwucb1         load ucb addr
         USING UCBOB,r2
         CLI   UCBTBYT3,UCB3DACC  check for dasd ucb
         jne   Ebaducbt            not a dasd unit
         TM    UCBSTAT,UCBONLI    is device online ?
*//CHANGE NOP to JO if unit MUST be offline
         nop   Ebaducbs            dasd unit is not offline

*   if we got a 31-bit address then we need to `capture' a 24-bit addr
         MVC   dcwcucb1,dcwucb1   copy ucb address
         TM    dcwucb1,X'ff'      is it a 31 bit address ?
         jz    cucbok1             no, continue
         MVC   dcwcupl,cupl       copy isocapu parameter list
         MODESET MODE=SUP
         IOSCAPU CAPTUCB,UCBPTR=dcwucb1,CAPTPTR=dcwcucb1,              X
               MF=(E,dcwcupl)     capture a 24-bit ucb addr
         STM   rf,r0,dcwretcd     save ret/rsn codes across MODESET
         MODESET MODE=PROB
         LM    rf,r0,dcwretcd     restore ret/rsn codes
         LTR   rf,rf              test ioscapu return code
         jnz   Ebaducbc           ioscapu error
         OI    dcwflag1,dcwcucb   indicate ucb has been captured
         L     r2,dcwcucb1        load captured deb addr
cucbok1  DS    0H

*   build dcb for the offline unit 1
         MVC   dcwdcb1,moddcb     copy otptut model dcb
dcb1     USING IHADCB,dcwdcb1
         MVC   dcb1.DCBMACRF,dcb1.DCBMACR copy macro reference bits

*   build deb for the offline unit 1
         MODESET MODE=SUP,KEY=ZERO
         GETMAIN RU,LV=DEBLENGTH,SP=230,LOC=BELOW
         ST    r1,dcwdeb1         save deb address
         XC    0(DEBLENGTH,r1),0(r1) clear the deb
         LR    r3,r1              appendage vector table/basic sections
         USING DEBAVT,r3
         LA    r4,DEBBASND-DEBAVT(,r3) debdasd section
         USING DEBDASD,r4
         LA    r5,DEBDASDE-DEBDASD(,r4) deb extension section
         USING DEBXTN,r5
         L     r6,CVTPTR          get cvt address
         USING CVT,r6
         L     rf,CVTXAPG         ios appendage vector table
         MVC   DEBAVT(DEBPREFX-DEBAVT),0(rf) copy vector table
         ST    r5,DEBXTNP         set extension address
         USING PSA,r0
         L     r7,PSATOLD         get tcb address
         USING TCB,r7
         ST    r7,DEBTCBAD        set tcb address
         OI    DEBFLGS1,DEBXTNIN  indicate extension exists
         LA    r0,dcwdcb1         get dcb address
         ST    r0,DEBDCBAD        set dcb address
         MVI   DEBDEBID,15        set deb identifier
         OC    DEBPROTG,TCBPKF    set protection key
         ST    r3,DEBAPPAD        set appendage table address
         STCM  r2,7,DEBUCBA       set ucb address
         MVC   DEBXLNGH,=Y(DEBXLEN) set extension length
         LA    r1,DEBBASIC        get basic section address
         STCM  r1,7,dcb1.DCBDEBA  set deb address in the dcb
         SETLOCK OBTAIN,TYPE=LOCAL,REGS=STDSAVE,MODE=UNCOND
         MVC   DEBDEBB,TCBDEB+1   set address next deb
         LA    r1,DEBBASIC        get basic section address
         ST    r1,TCBDEB          chain deb to the tcb
         SETLOCK RELEASE,TYPE=LOCAL,REGS=STDSAVE
         MODESET MODE=PROB,KEY=NZERO

*   add deb to the deb list
         MODESET MODE=SUP,KEY=ZERO
         DEBCHK dcwdcb1,TYPE=ADD,AM=EXCP
         STM   rf,r0,dcwretcd
         MODESET MODE=PROB,KEY=NZERO
         LM    rf,r0,dcwretcd
         LTR   rf,rf              test debchk add return code
         jnz   Ebaddeba             debchk add failed
         OI    dcwflag1,dcwdebad  indicate deb was added

*   build the dasd extent
         MODESET MODE=SUP,KEY=ZERO
         ST    r2,DEBUCBAD        set 24-bit ucb addr
         MVI   DEBDVMOD,0         set device modifier
***      MVC   DEBENDCC,=X'7fff'  set end cylinder
***      MVC   DEBENDHH,=X'00ff'  set end head
***      MVC   DEBNMTRK,=X'7fff'  set number tracks in extent
         MVC   DEBENDCC,=X'ffff'  set end cylinder
         MVC   DEBENDHH,=X'ffff'  set end head
         MVC   DEBNMTRK,=X'ffff'  set number tracks in extent
         MODESET MODE=PROB,KEY=NZERO

*   build the iob
iob1     USING IOBSTDRD,dcwiob1
         OI    iob1.IOBFLAG1,IOBDATCH+IOBCMDCH+IOBUNREL
         LA    r1,dcwecb1
         ST    r1,iob1.IOBECBPT
         LA    r1,dcwccw1
         ST    r1,iob1.IOBSTART
         LA    r1,dcwdcb1
         ST    r1,iob1.IOBDCBPT

*   turn off the `not ready' bit
         TM    UCBFLA,UCBNRY     is `not ready' bit on ?
         BNO   nryok1             no, continue
         MODESET MODE=SUP,KEY=ZERO
         NI    UCBFLA,255-UCBNRY turn off `not ready' bit
         MODESET MODE=PROB,KEY=NZERO
         OI    dcwflag1,dcwnry   indicate we turned the bit off
nryok1   DS    0H

*   sense the offline device unit 1
         MODESET MODE=SUP,KEY=ZERO
         OI    DEBXFLG2,DEBCHCMP+DEBBYP bypass excp prefixing
         MODESET MODE=PROB,KEY=NZERO
         LA    r8,dcwccw1
         USING CCW0,r8
         LA    r9,dcwiob1
         USING IOBSTDRD,r9

*        Seek
         XC    dcwecb1,dcwecb1    clear the ecb
         XC    dcwccw1(dcwccwl),dcwccw1 clear the ccws
         MVI   CCW0CMD,SK         set seek command
         LA    r1,dcwzeros
         STCM  r1,7,CCW0ADDR      set data address
         MVI   CCW0FLAG,CCW0SLI   set sli flag bit
         MVC   CCW0CNT,=Y(6)      set count
         EXCP  dcwiob1
         WAIT  1,ECB=dcwecb1      wait for SK
         CLI   dcwecb1,ECBNORM   test post code
         BNE   Esnserr              error

*        Sense ID
         XC    dcwecb1,dcwecb1    clear the ecb
         XC    dcwccw1(dcwccwl),dcwccw1 clear the ccws
         MVI   CCW0CMD,SNSID      set sense-id command
         LA    r1,dcwsnsi1
         STCM  r1,7,CCW0ADDR      set data address
         MVI   CCW0FLAG,CCW0SLI   set sli flag bit
         MVC   CCW0CNT,=Y(L'dcwsnsi1) set count
         EXCP  dcwiob1
         WAIT  1,ECB=dcwecb1      wait for SNSID
         CLI   dcwecb1,ECBNORM   test post code
         BNE   Esnserr              error

*        Sense
         XC    dcwecb1,dcwecb1    clear the ecb
         XC    dcwccw1(dcwccwl),dcwccw1 clear the ccws
         MVI   CCW0CMD,SNS        set sense command
         LA    r1,dcwsns1
         STCM  r1,7,CCW0ADDR      set data address
         MVI   CCW0FLAG,CCW0SLI   set sli flag bit
         MVC   CCW0CNT,=Y(L'dcwsns1)  set count
         EXCP  dcwiob1
         WAIT  1,ECB=dcwecb1      wait for SNS
         CLI   dcwecb1,ECBNORM   test post code
         BNE   Esnserr              error

*        Read Device Characteristics
         XC    dcwecb1,dcwecb1    clear the ecb
         XC    dcwccw1(dcwccwl),dcwccw1 clear the ccws
         MVI   CCW0CMD,RDC        set read-characteristics command
         LA    r1,dcwrdc1
         STCM  r1,7,CCW0ADDR      set data address
         MVI   CCW0FLAG,0         clear flag bits
         MVC   CCW0CNT,=Y(L'dcwrdc1)  set count
         EXCP  dcwiob1
         WAIT  1,ECB=dcwecb1      wait for RDC
         CLI   dcwecb1,ECBNORM   test post code
         BNE   Esnserr              error

*        Sense Subsystem Status
         XC    dcwecb1,dcwecb1    clear the ecb
         XC    dcwccw1(dcwccwl),dcwccw1 clear the ccws
         MVI   CCW0CMD,SNSS       set sense-subsystem-status command
         LA    r1,dcwsnss1
         STCM  r1,7,CCW0ADDR      set data address
         MVI   CCW0FLAG,CCW0SLI   set sli flag bit
         MVC   CCW0CNT,=Y(L'dcwsnss1) set count
         EXCP  dcwiob1
         WAIT  1,ECB=dcwecb1      wait for SNSS
         CLI   dcwecb1,ECBNORM   test post code
         BNE   Esnserr              error

         MODESET MODE=SUP,KEY=ZERO
         NI    DEBXFLG2,255-DEBCHCMP-DEBBYP
         MODESET MODE=PROB,KEY=NZERO
         DROP  r2,r3,r4,r5,r6,r7,r8,r9

*/* -------------------------------------------------------------------
*   `fake-open' offline device 2
* ------------------------------------------------------------------ */

*   look for the ucb for the unit & make sure it's an offline dasd
         MVC   dcwulpl,ulpl       copy ucblook parameter list
         MODESET MODE=SUP
         UCBLOOK DEVN=dcwunit2,UCBPTR=dcwucb2,PIN,PTOKEN=dcwptok2,     X
               DYNAMIC=YES,RANGE=ALL,LOC=ANY,MF=(E,dcwulpl),           X
               TEXT==C'DISKCOMP offline dasd lookup2'
         STM   rf,r0,dcwretcd     save ret/rsn codes across MODESET
         MODESET MODE=PROB
         LM    rf,r0,dcwretcd     restore ret/rsn codes
         LTR   rf,rf              test ucblook return code
         LA    r2,dcwunit2         bad unit addr if error
         jnz   Ebaducbl           ucblook error
         OI    dcwflag2,dcwpin    indicate ucb has been pinned
         L     r2,dcwucb2         load ucb addr
         USING UCBOB,r2
         CLI   UCBTBYT3,UCB3DACC  check for dasd ucb
         jne   Ebaducbt            not a dasd unit
         TM    UCBSTAT,UCBONLI    is device online ?
*//CHANGE NOP to JO if unit MUST be offline
         nop   Ebaducbs            dasd unit is not offline

*   if we got a 31-bit address then we need to `capture' a 24-bit addr
         MVC   dcwcucb2,dcwucb2   copy ucb address
         TM    dcwucb2,X'ff'      is it a 31 bit address ?
         jz    cucbok2             no, continue
         MVC   dcwcupl,cupl       copy isocapu parameter list
         MODESET MODE=SUP
         IOSCAPU CAPTUCB,UCBPTR=dcwucb2,CAPTPTR=dcwcucb2,              X
               MF=(E,dcwcupl)     capture a 24-bit ucb addr
         STM   rf,r0,dcwretcd     save ret/rsn codes across MODESET
         MODESET MODE=PROB
         LM    rf,r0,dcwretcd     restore ret/rsn codes
         LTR   rf,rf              test ioscapu return code
         jnz   Ebaducbc           ioscapu error
         OI    dcwflag2,dcwcucb   indicate ucb has been captured
         L     r2,dcwcucb2        load captured ucb addr
cucbok2  DS    0H

*   build dcb for the offline unit 2
         MVC   dcwdcb2,moddcb     copy otptut model dcb
dcb2     USING IHADCB,dcwdcb2
         MVC   dcb2.DCBMACRF,dcb2.DCBMACR copy macro reference bits

*   build deb for the offline unit 2
         MODESET MODE=SUP,KEY=ZERO
         GETMAIN RU,LV=DEBLENGTH,SP=230,LOC=BELOW
         ST    r1,dcwdeb2         save deb address
         XC    0(DEBLENGTH,r1),0(r1) clear the deb
         LR    r3,r1              appendage vector table/basic sections
         USING DEBAVT,r3
         LA    r4,DEBBASND-DEBAVT(,r3) debdasd section
         USING DEBDASD,r4
         LA    r5,DEBDASDE-DEBDASD(,r4) deb extension section
         USING DEBXTN,r5
         L     r6,CVTPTR          get cvt address
         USING CVT,r6
         L     rf,CVTXAPG         ios appendage vector table
         MVC   DEBAVT(DEBPREFX-DEBAVT),0(rf) copy vector table
         ST    r5,DEBXTNP         set extension address
         USING PSA,r0
         L     r7,PSATOLD         get tcb address
         USING TCB,r7
         ST    r7,DEBTCBAD        set tcb address
         OI    DEBFLGS1,DEBXTNIN  indicate extension exists
         LA    r0,dcwdcb2         get dcb address
         ST    r0,DEBDCBAD        set dcb address
         MVI   DEBDEBID,15        set deb identifier
         OC    DEBPROTG,TCBPKF    set protection key
         ST    r3,DEBAPPAD        set appendage table address
         STCM  r2,7,DEBUCBA       set ucb address
         MVC   DEBXLNGH,=Y(DEBXLEN) set extension length
         LA    r1,DEBBASIC        get basic section address
         STCM  r1,7,dcb2.DCBDEBA  set deb address in the dcb
         SETLOCK OBTAIN,TYPE=LOCAL,REGS=STDSAVE,MODE=UNCOND
         MVC   DEBDEBB,TCBDEB+1   set address next deb
         LA    r1,DEBBASIC        get basic section address
         ST    r1,TCBDEB          chain deb to the tcb
         SETLOCK RELEASE,TYPE=LOCAL,REGS=STDSAVE
         MODESET MODE=PROB,KEY=NZERO

*   add deb to the deb list
         MODESET MODE=SUP,KEY=ZERO
         DEBCHK dcwdcb2,TYPE=ADD,AM=EXCP
         STM   rf,r0,dcwretcd
         MODESET MODE=PROB,KEY=NZERO
         LM    rf,r0,dcwretcd
         LTR   rf,rf              test debchk add return code
         jnz   Ebaddeba             debchk add failed
         OI    dcwflag2,dcwdebad  indicate deb was added

*   build the dasd extent
         MODESET MODE=SUP,KEY=ZERO
         ST    r2,DEBUCBAD        set 24-bit ucb addr
         MVI   DEBDVMOD,0         set device modifier
***      MVC   DEBENDCC,=X'7fff'  set end cylinder
***      MVC   DEBENDHH,=X'00ff'  set end head
***      MVC   DEBNMTRK,=X'7fff'  set number tracks in extent
         MVC   DEBENDCC,=X'ffff'  set end cylinder
         MVC   DEBENDHH,=X'ffff'  set end head
         MVC   DEBNMTRK,=X'ffff'  set number tracks in extent
         MODESET MODE=PROB,KEY=NZERO

*   build the iob
iob2     USING IOBSTDRD,dcwiob2
         OI    iob2.IOBFLAG1,IOBDATCH+IOBCMDCH+IOBUNREL
         LA    r1,dcwecb2
         ST    r1,iob2.IOBECBPT
         LA    r1,dcwccw2
         ST    r1,iob2.IOBSTART
         LA    r1,dcwdcb2
         ST    r1,iob2.IOBDCBPT

*   turn off the `not ready' bit
         TM    UCBFLA,UCBNRY     is `not ready' bit on ?
         BNO   nryok2             no, continue
         MODESET MODE=SUP,KEY=ZERO
         NI    UCBFLA,255-UCBNRY turn off `not ready' bit
         MODESET MODE=PROB,KEY=NZERO
         OI    dcwflag2,dcwnry   indicate we turned the bit off
nryok2   DS    0H

*   sense the offline device unit 2
         MODESET MODE=SUP,KEY=ZERO
         OI    DEBXFLG2,DEBCHCMP+DEBBYP bypass excp prefixing
         MODESET MODE=PROB,KEY=NZERO
         LA    r8,dcwccw2
         USING CCW0,r8
         LA    r9,dcwiob2
         USING IOBSTDRD,r9

*        Seek
         XC    dcwecb2,dcwecb2    clear the ecb
         XC    dcwccw2(dcwccwl),dcwccw2 clear the ccws
         MVI   CCW0CMD,SK         set seek command
         LA    r1,dcwzeros
         STCM  r1,7,CCW0ADDR      set data address
         MVI   CCW0FLAG,CCW0SLI   set sli flag bit
         MVC   CCW0CNT,=Y(6)      set count
         EXCP  dcwiob2
         WAIT  1,ECB=dcwecb2      wait for SK
         CLI   dcwecb2,ECBNORM   test post code
         BNE   Esnserr              error

*        Sense ID
         XC    dcwecb2,dcwecb2    clear the ecb
         XC    dcwccw2(dcwccwl),dcwccw2 clear the ccws
         MVI   CCW0CMD,SNSID      set sense-id command
         LA    r1,dcwsnsi2
         STCM  r1,7,CCW0ADDR      set data address
         MVI   CCW0FLAG,CCW0SLI   set sli flag bit
         MVC   CCW0CNT,=Y(L'dcwsnsi2) set count
         EXCP  dcwiob2
         WAIT  1,ECB=dcwecb2      wait for SNSID
         CLI   dcwecb2,ECBNORM   test post code
         BNE   Esnserr              error

*        Sense
         XC    dcwecb2,dcwecb2    clear the ecb
         XC    dcwccw2(dcwccwl),dcwccw2 clear the ccws
         MVI   CCW0CMD,SNS        set sense command
         LA    r1,dcwsns2
         STCM  r1,7,CCW0ADDR      set data address
         MVI   CCW0FLAG,CCW0SLI   set sli flag bit
         MVC   CCW0CNT,=Y(L'dcwsns2)  set count
         EXCP  dcwiob2
         WAIT  1,ECB=dcwecb2      wait for SNS
         CLI   dcwecb2,ECBNORM   test post code
         BNE   Esnserr              error

*        Read Device Characteristics
         XC    dcwecb2,dcwecb2    clear the ecb
         XC    dcwccw2(dcwccwl),dcwccw2 clear the ccws
         MVI   CCW0CMD,RDC        set read-characteristics command
         LA    r1,dcwrdc2
         STCM  r1,7,CCW0ADDR      set data address
         MVI   CCW0FLAG,0         clear flag bits
         MVC   CCW0CNT,=Y(L'dcwrdc2)  set count
         EXCP  dcwiob2
         WAIT  1,ECB=dcwecb2      wait for RDC
         CLI   dcwecb2,ECBNORM   test post code
         BNE   Esnserr              error

*        Sense Subsystem Status
         XC    dcwecb2,dcwecb2    clear the ecb
         XC    dcwccw2(dcwccwl),dcwccw2 clear the ccws
         MVI   CCW0CMD,SNSS       set sense-subsystem-status command
         LA    r1,dcwsnss2
         STCM  r1,7,CCW0ADDR      set data address
         MVI   CCW0FLAG,CCW0SLI   set sli flag bit
         MVC   CCW0CNT,=Y(L'dcwsnss2) set count
         EXCP  dcwiob2
         WAIT  1,ECB=dcwecb2      wait for SNSS
         CLI   dcwecb2,ECBNORM   test post code
         BNE   Esnserr              error

         MODESET MODE=SUP,KEY=ZERO
         NI    DEBXFLG2,255-DEBCHCMP-DEBBYP
         MODESET MODE=PROB,KEY=NZERO
         DROP  r2,r3,r4,r5,r6,r7,r8,r9

*/* -------------------------------------------------------------------
*   compare tracks
* ------------------------------------------------------------------ */

*        setup buffers
         LA    r1,dcwbufs
         ST    r1,dcwbuf1
         A     r1,=F'65536'
         ST    r1,dcwbuf2

rdc1     USING RDCinfo,dcwrdc1
rdc2     USING RDCinfo,dcwrdc2

*        check device types
         clc   rdc1.RDCdevt,rdc2.RDCdevt
         jne   Edifdevt

*        get number of cylinders for unit1 and unit2 using RDCinfo @020
         l     r1,rdc1.RDCeavc   try first if unit1 is a 3390-A    @020
         ltr   r1,r1             is a valid number?                @020
         jnz   is3390a1          yes, cylinders are valid          @020
         llh   r1,rdc1.RDCprime  otherwise, load old style cyls    @020
is3390a1 ds    0h                                                  @020
         st    r1,dcwncyl1       save number of cyliders for unit1 @020
         bctr  r1,0              minus 1 to have high cylinder     @020
         l     r2,rdc2.RDCeavc   try first if unit2 is a 3390-A    @020
         ltr   r2,r2             is a valid number?                @020
         jnz   is3390a2          yes, cylinders are valid          @020
         llh   r2,rdc2.RDCprime  otherwise, load old style cyls    @020
is3390a2 ds    0h                                                  @020
         st    r2,dcwncyl2       save number of cyliders for unit2 @020
         bctr  r2,0              minus 1 to have high cylinder     @020
*        llh   r0,dcwhicyl                                         @020
         l     r0,dcwhicyl                                         @020
*         c     r0,=A(X'0000ffff')                                 @020
         c     r0,=A(X'ffffffff') check if no hicyl has been spec  @020
         jne   hicylok           something has been specified      @020
*        set default high cyl to high cyl on the smallest device
         lr    r0,r1             save unit1 info                   @020
         clr   r1,r2             compare unit1 and unit2 hicyl     @020
         jnh   sethicyl          jump if unit1 is not higher       @020
         lr    r0,r2             unit1 is higher, then use unit2   @020
*sethicyl stcm  r0,3,dcwhicyl                                      @020
sethicyl st    r0,dcwhicyl       save lower cylinders              @020
*        warning if cylinders differ between the devices
         clr   r1,r2             are hicyls different?             @020
         je    hicylok           if not, skip defaulting message   @020
        #MSG   'Device %x4:2 has %d:4 cyls, device %x4:2 has %d:4 cyls.X
                Defaulting to %x7:4 for high cyl',                     X
               dcwunit1,dcwncyl1,dcwunit2,dcwncyl2,dcwhicyl
hicylok  DS    0H
*        check hi cyl
*         llh   r0,dcwhicyl                                        @020
         l     r0,dcwhicyl                                         @020
*        llh   r1,rdc1.RDCprime                                    @020
         l     r1,dcwncyl1       get number of cylinders for unit1 @020
         la    r2,dcwunit1
         clr   r0,r1
         jnl   Ebadhcyl
*        llh   r1,rdc2.RDCprime                                    @020
         l     r1,dcwncyl2       get number of cylinders for unit2 @020
         la    r2,dcwunit2
         clr   r0,r1
         jnl   Ebadhcyl

*        check hi cyl vs lo cyl
*         llh   r1,dcwlocyl                                        @020
         l     r1,dcwlocyl                                         @020
*         llh   r2,dcwhicyl                                        @020
         l     r2,dcwhicyl                                         @020
         CLR   r1,r2
         JH    Ebadlcyl

*        build ecb wait list
         LA    r1,dcwecb1
         LA    r2,dcwecb2
         STM   r1,r2,dcwecbl
         OI    dcwecbl+4,x'80'

*        set starting cylinder, head
*         XC    dcwcchh,dcwcchh                                    @020
*         MVC   dcwcc,dcwlocyl                                     @020
         l      r0,dcwlocyl                                        @020
         trkaddr setcyl,dcwcchh,reg=(r0)                           @020

*        print initialization message
         TIME  DEC
         STM   r0,r1,dcwctime     get start time
         LA    r1,dcwctime
         LA    r0,dcwdtime
         BAL   re,dtime
        #MSG   '%s:8 %d:1.%d:1.%d:1 starting compare %s:20, unit1=%x4:2X
               , unit2=%x4:2, locyl=%x7:4, hicyl=%x7:4',               X
               pgmid,vrm,vrm+1,vrm+2,dcwdtime,                         X
               dcwunit1,dcwunit2,dcwlocyl,dcwhicyl                     X

dcloop   DS    0h

*        setup unit 1 for read
         XC    iob1.IOBSEEK,iob1.IOBSEEK
         MVC   iob1.IOBCC,dcwcc
         MVC   iob1.IOBHH,dcwhh
         LA    r2,dcwccw1
         USING CCW0,R2
         XC    dcwccw1(dcwccwl),dcwccw1
*        build LR ccw
         MVI   CCW0CMD,LR
         LA    r1,dcwlrp1
         STCM  r1,7,CCW0ADDR
         MVI   CCW0FLAG,CCW0CC
         LA    r1,L'dcwlrp1
         STCM  r1,3,CCW0CNT
         LA    r2,CCW0END
*        build LR parameter
         XC    dcwlrp1,dcwlrp1
lrp1     USING LRparm,dcwlrp1
         MVI   lrp1.LRop,LRohome+LRrt
         MVI   lrp1.LRcount,1
         MVC   lrp1.LRseek,iob1.IOBCC
         MVC   lrp1.LRsearch,iob1.IOBCC
*        build RT ccw
         MVI   CCW0CMD,RT
         L     r1,dcwbuf1
         STCM  r1,7,CCW0ADDR
         MVI   CCW0FLAG,CCW0SLI
         ICM   r1,7,rdc1.RDCtrkln
         STCM  r1,3,CCW0CNT
         DROP  r2
*        start channel program
         xc    dcwecb1,dcwecb1
         EXCP  iob1.IOBSTDRD
***      WAIT  1,ECB=dcwecb1

*        setup unit 2 for read
         XC    iob2.IOBSEEK,iob2.IOBSEEK
         MVC   iob2.IOBCC,dcwcc
         MVC   iob2.IOBHH,dcwhh
         LA    r2,dcwccw2
         USING CCW0,R2
         XC    dcwccw2(dcwccwl),dcwccw2
*        build LR ccw
         MVI   CCW0CMD,LR
         LA    r1,dcwlrp2
         STCM  r1,7,CCW0ADDR
         MVI   CCW0FLAG,CCW0CC
         LA    r1,L'dcwlrp2
         STCM  r1,3,CCW0CNT
         LA    r2,CCW0END
*        build LR parameter
         XC    dcwlrp2,dcwlrp2
lrp2     USING LRparm,dcwlrp2
         MVI   lrp2.LRop,LRohome+LRrt
         MVI   lrp2.LRcount,1
         MVC   lrp2.LRseek,iob2.IOBCC
         MVC   lrp2.LRsearch,iob2.IOBCC
*        build RT ccw
         MVI   CCW0CMD,RT
         L     r1,dcwbuf2
         STCM  r1,7,CCW0ADDR
         MVI   CCW0FLAG,CCW0SLI
         ICM   r1,7,rdc2.RDCtrkln
         STCM  r1,3,CCW0CNT
         DROP  r2
*        start channel program
         xc    dcwecb2,dcwecb2
         EXCP  iob2.IOBSTDRD
***      WAIT  1,ECB=dcwecb2

         WAIT  2,ECBLIST=dcwecbl

*        check i/o completion codes
         cli   dcwecb1,ECBNORM
         jne   Eioerr1
         cli   dcwecb2,ECBNORM
         jne   Eioerr2

*        increment tracks read
         L     r1,dcwtrks
         AHI   r1,1
         ST    r1,dcwtrks

*        get track lengths
         l     r2,dcwbuf1
         slr   r3,r3
         icm   r3,7,rdc1.RDCtrkln
         llh   r0,iob1.IOBCSW8+6
         slr   r3,r0
         l     r4,dcwbuf2
         slr   r5,r5
         icm   r5,7,rdc2.RDCtrkln
         llh   r0,iob2.IOBCSW8+6
         slr   r5,r0

*        check lengths
         clr   r3,r5
         je    dclenok
         st    r3,dcwlen1
         st    r5,dcwlen2
         trkaddr extractcyl,dcwcchh,reg=(r1)                       @020
         st    r1,dcwncc                                           @020
         trkaddr extracttrk,dcwcchh,reg=(r1)                       @020
         stcm  r1,b'0001',dcwnhh                                   @020
        #MSG   '%x4:2:%x4:2 (%x7:4:%x1:1) length  mismatch, length1 is X
               %d, length2 is %d',                                     X
               dcwcc,dcwhh,dcwncc,dcwnhh,dcwlen1,dcwlen2           @020
         l     r1,dcwdiffs
         ahi   r1,1
         st    r1,dcwdiffs
         mvc   dcwrsult,=F'4'
         j     dcnext
dclenok  DS    0H

*        compare images
         clcl  r2,r4
         je    dcnext
         trkaddr extractcyl,dcwcchh,reg=(r1)                       @020
         st    r1,dcwncc                                           @020
         trkaddr extracttrk,dcwcchh,reg=(r1)                       @020
         stcm  r1,b'0001',dcwnhh                                   @020
        #MSG   '%x4:2:%x4:2 (%x7:4:%x1:1) compare mismatch',       @020X
               dcwcc,dcwhh,dcwncc,dcwnhh                           @020
         l     r1,dcwdiffs
         ahi   r1,1
         st    r1,dcwdiffs
         mvc   dcwrsult,=F'4'

dcnext   ds    0h
*        increment head
*         lh    r1,dcwhh                                           @020
*         ahi   r1,1                                               @020
*         sth   r1,dcwhh                                           @020
*         ch    r1,rdc1.RDCheads                                   @020
*         jl    dcloop                                             @020
*        increment cylinder
*         xc    dcwhh,dcwhh                                        @020
*         llh   r1,dcwcc                                           @020
*         ahi   r1,1                                               @020
*         stcm  r1,3,dcwcc                                         @020
*                                                                  @020
*        use the powerful of trkaddr to increment track!           @020
         trkaddr nexttrack,dcwcchh,reg=(r1)                        @020
*         llh   r2,dcwhicyl                                        @020
         l      r2,dcwhicyl                                        @020
         trkaddr extractcyl,dcwcchh,reg=(r1)                       @020
         clr   r1,r2
         jnh   dcloop

*        finished
        #MSG   '%d tracks read, %d track differences',dcwtrks,dcwdiffs

*/* -------------------------------------------------------------------
*   cleanup and terminate
* ------------------------------------------------------------------ */

terminat DS    0H

*/* call debchk to delete the debs                                   */
term1    TM    dcwflag1,dcwdebad was deb added to the deb chain ?
         jno   term1a             no, continue
         MODESET MODE=SUP,KEY=ZERO
         DEBCHK dcwdcb1,TYPE=DELETE,AM=EXCP delete the deb
         MODESET MODE=PROB,KEY=NZERO
         NI    dcwflag1,255-dcwdebad
term1a   DS    0H
         TM    dcwflag2,dcwdebad was deb added to the deb chain ?
         jno   term1b             no, continue
         MODESET MODE=SUP,KEY=ZERO
         DEBCHK dcwdcb2,TYPE=DELETE,AM=EXCP delete the deb
         MODESET MODE=PROB,KEY=NZERO
         NI    dcwflag1,255-dcwdebad
term1b   DS    0H

*/* remove deb 1 from the chain and free its storage                 */
term2    L     r2,dcwdeb1        load deb area addr
         LTR   r2,r2              any deb area ?
         BZ    term3               no, continue
*/*      remove the deb from the deb chain                           */
         USING DEBAVT,r2
         LA    r3,DEBBASIC
         DROP  r2
         L     r4,PSATOLD-PSA    get tcb addr
         USING TCB,r4
         LA    r5,TCBDEB-(DEBDEBAD-DEBBASIC)
         USING DEBBASIC,r4
         MODESET MODE=SUP,KEY=ZERO
         SETLOCK OBTAIN,TYPE=LOCAL,REGS=STDSAVE,MODE=UNCOND
         SPKA  X'80'
term2a   LR    r4,r5
         SLR   r5,r5
         ICM   r5,7,DEBDEBB      addr next deb
         BZ    term2b             exit if we didn't found ours
         CLR   r3,r5             found our deb ?
         BNE   term2a             no, keep looking
         SPKA  0                   need key 0 to update a deb
         MVC   DEBDEBB,DEBDEBB-DEBBASIC(r5) remove the deb
         DROP  r4
term2b   SPKA  0                   need key 0 to update a deb
         SETLOCK RELEASE,TYPE=LOCAL,REGS=STDSAVE
         MODESET MODE=PROB,KEY=NZERO
*/*      free deb storage                                            */
         MODESET MODE=SUP,KEY=ZERO
         FREEMAIN RU,A=(r2),LV=DEBLENGTH,SP=230 free the deb storage
         MODESET MODE=PROB,KEY=NZERO
         XC    dcwdeb1,dcwdeb1

*/* remove deb 2 from the chain and free its storage                 */
term3    L     r2,dcwdeb2        load deb area addr
         LTR   r2,r2              any deb area ?
         BZ    term4               no, continue
*/*      remove the deb from the deb chain                           */
         USING DEBAVT,r2
         LA    r3,DEBBASIC
         DROP  r2
         L     r4,PSATOLD-PSA    get tcb addr
         USING TCB,r4
         LA    r5,TCBDEB-(DEBDEBAD-DEBBASIC)
         USING DEBBASIC,r4
         MODESET MODE=SUP,KEY=ZERO
         SETLOCK OBTAIN,TYPE=LOCAL,REGS=STDSAVE,MODE=UNCOND
         SPKA  X'80'
term3a   LR    r4,r5
         SLR   r5,r5
         ICM   r5,7,DEBDEBB      addr next deb
         BZ    term3b             exit if we didn't found ours
         CLR   r3,r5             found our deb ?
         BNE   term3a             no, keep looking
         SPKA  0                   need key 0 to update a deb
         MVC   DEBDEBB,DEBDEBB-DEBBASIC(r5) remove the deb
         DROP  r4
term3b   SPKA  0                   need key 0 to update a deb
         SETLOCK RELEASE,TYPE=LOCAL,REGS=STDSAVE
         MODESET MODE=PROB,KEY=NZERO
*/*      free deb storage                                            */
         MODESET MODE=SUP,KEY=ZERO
         FREEMAIN RU,A=(r2),LV=DEBLENGTH,SP=230 free the deb storage
         MODESET MODE=PROB,KEY=NZERO
         XC    dcwdeb2,dcwdeb2

*/*      turn the ucb `not ready' bit back on if we turned it off    */
term4    TM    dcwflag1,dcwnry   did we turn the bit off ?
         BNO   term4a             no, continue
         L     r2,dcwucb1        load ucb address
         USING UCBOB,r2
         MODESET MODE=SUP,KEY=ZERO
         OI    UCBFLA,UCBNRY     turn the bit back on
         MODESET MODE=PROB,KEY=NZERO
         DROP  r2
term4a   TM    dcwflag2,dcwnry   did we turn the bit off ?
         BNO   term4b             no, continue
         L     r2,dcwucb1        load ucb address
         USING UCBOB,r2
         MODESET MODE=SUP,KEY=ZERO
         OI    UCBFLA,UCBNRY     turn the bit back on
         MODESET MODE=PROB,KEY=NZERO
         DROP  r2
term4b   DS    0H

*/*      uncapture the ucbs                                          */
term5    TM    dcwflag1,dcwcucb  was ucb captured ?
         jno   term5a             no, continue
         MVC   dcwcupl,cupl        copy isocapu parameter list
         MODESET MODE=SUP
         IOSCAPU UCAPTUCB,CAPTPTR=dcwcucb1,                            X
               MF=(E,dcwcupl)       uncapture the 24-bit ucb addr
         MODESET MODE=PROB
term5a   TM    dcwflag2,dcwcucb  was ucb captured ?
         jno   term5b             no, continue
         MVC   dcwcupl,cupl        copy isocapu parameter list
         MODESET MODE=SUP
         IOSCAPU UCAPTUCB,CAPTPTR=dcwcucb2,                            X
               MF=(E,dcwcupl)       uncapture the 24-bit ucb addr
         MODESET MODE=PROB
term5b   DS    0H

*/*      unpin the ucbs                                              */
term6    TM    dcwflag1,dcwpin   was ucb pinned ?
         BNO   term6a             no, continue
         MVC   dcwuupl,uupl        copy ucbpin unpin  parameter list
         MODESET MODE=SUP
         UCBPIN UNPIN,PTOKEN=dcwptok1,MF=(E,dcwuupl)  unpin the ucb
         MODESET MODE=PROB
term6a   TM    dcwflag2,dcwpin   was ucb pinned ?
         BNO   term6b             no, continue
         MVC   dcwuupl,uupl        copy ucbpin unpin  parameter list
         MODESET MODE=SUP
         UCBPIN UNPIN,PTOKEN=dcwptok2,MF=(E,dcwuupl)  unpin the ucb
         MODESET MODE=PROB
term6b   DS    0H

*/* close the sysprint file                                          */
term7    DS    0H
pdcb     USING IHADCB,dcwpdcb
         TM    pdcb.DCBOFLGS,DCBOFOPN is sysprint file open ?
         BNO   term8                    no, continue
         CLOSE (dcwpdcb),MODE=31,MF=(E,dcwopenl)

*/*      free the work areas                                         */
term8    DS    0H
         STORAGE RELEASE,ADDR=(rb),LENGTH=dcw24l free 24-bit area
         LR    r1,rd
         L     r2,dcwrsult
         L     rd,4(,rd)
         STORAGE RELEASE,ADDR=(1),LENGTH=dcwl   free work area

         LR    rf,r2                            copy result reg
         RETURN (14,12),RC=(15)

*/* -------------------------------------------------------------------
*   format date & time
* ------------------------------------------------------------------ */
dtime    STM   re,r2,12(rd)       save some regs
         LR    r2,r0              copy output area address
         MVI   0(r2),C' '         blank the output area
         MVC   1(19,r2),0(r2)
         MVC   11(9,r2),=X'4021207a20207a2020' edit pattern for time
         ED    11(9,r2),0(r1)     edited time
         XC    dcwdw,dcwdw        clear double word work area
         SLR   rf,rf
         ICM   rf,3,4(r1)         decimal year
         SLL   rf,4               shift over a nibble
         ST    rf,dcwdw+4         store in the double word
         OI    dcwdw+7,X'0f'      set bottom nibble
         AP    dcwdw,=P'1900'     calculate the year
         OI    dcwdw+7,X'0f'      fix bottom nibble for unpk
         UNPK  7(4,r2),dcwdw      set the year
         CVB   rf,dcwdw           get binary year
         N     rf,=A(3)           test for leap year
         BZ    *+8                 jumps if leap year
         LA    rf,2                 else set non-leapyr offset
         ZAP   dcwdw,6(2,r1)      get julian day in double word
         CVB   r0,dcwdw           get julian day binary
         LA    re,dtjtab          point to julian table
dtfind   CH    r0,8(rf,re)        found table entry ?
         BNH   dtfound             yes, exit loop
         LA    re,8(,re)          point to next entry
         B     dtfind              and loop back
dtfound  MVC   3(3,r2),4(re)      set month from the table
         SH    r0,0(rf,re)        calculate day of month
         CVD   r0,dcwdw           get day of month packed
         L     r0,dcwdw+4         load packed day
         SLL   r0,20              shift out hi bits
         SRL   r0,28              shift down
         STC   r0,0(,r2)          set 1st digit of the month
         OI    0(r2),C'0'         convert to ebcdic character
         L     r0,dcwdw+4         load packed day
         SLL   r0,24              shift out hi bits
         SRL   r0,28              shift down
         STC   r0,1(,r2)          set 2nd digit of the month
         OI    1(r2),C'0'         convert to ebcdic character
         LM    re,r2,12(rd)       restore regs
         BR    re                  and thankfully return
dtjtab   DC    Y(0,0),C'Jan '     Julian date table
         DC    Y(31,31),C'Feb '
         DC    Y(60,59),C'Mar '
         DC    Y(91,90),C'Apr '
         DC    Y(121,120),C'May '
         DC    Y(152,151),C'Jun '
         DC    Y(182,181),C'Jul '
         DC    Y(213,212),C'Aug '
         DC    Y(244,243),C'Sep '
         DC    Y(274,273),C'Oct '
         DC    Y(305,304),C'Nov '
         DC    Y(335,334),C'Dec '
         DC    Y(999,999),C'??? '

*/* -------------------------------------------------------------------
*   error routines
* ------------------------------------------------------------------ */

Enoparm #MSG   'No parameters were specified'
         j     Eexit
Ebadparm MVC   dcwdw4,=CL8' '     init dw to blanks
         CHI   r4,8               test parameter length left
         jnh   *+8                 continue if not too long
         LHI   r4,8                 else reset length
         AHI   r4,-1              decrement for EX
         jm    *+4+4+6             bypass copy if nothing left
         EX    r4,*+4               copy area near the error
         MVC   dcwdw4(0),0(r3)       (executed)
        #MSG   '** Error in parameters near %s:8',dcwdw4
         j     Eexit
Ebaducbl CH    RF,=Y(4)
         je    Enoucb
        #MSG   '** UCBLOOK error for unit %x4:2: rc 0x%x rsn 0x%x',    X
               0(r2),dcwretcd,dcwrsncd
         j     Eexit
Enoucb  #MSG   '** UCB not found for unit %x4:2',0(r2)
         j     Eexit
Ebaducbt DS    0H
         USING UCBOB,r2
        #MSG   '** UCB for unit %x4:2 is not dasd, type is %x:1',      X
               UCBCHAN,UCBTBYT3
         j     Eexit
         DROP  r2
Ebaducbs DS    0H
         USING UCBOB,r2
         #MSG  '** Device %x4:2 is not offline',UCBCHAN
         j     Eexit
         DROP  r2
Ebaducbc DS    0H
         USING UCBOB,r2
         #MSG  '** IOSCAPU CAPTUCB failed for %x4:2; rc=0x%x rsn=0x%x',X
               UCBCHAN,dcwretcd,dcwrsncd
         j     Eexit
         DROP  r2
Ebaddeba DS    0H
         USING UCBOB,r2
         #MSG  '** DEBCHK ADD for %x4:2 failed; rc=0x%x',              X
               UCBCHAN,dcwretcd
         j     Eexit
         DROP  r2
Esnserr  DS    0H
         C     r2,dcwcucb1
         jne   Esnserr2
Esnserr1 #MSG  '** Sense failed for 0x%x4:2: command %x2:1, CC 0x%x2:1,X
                Stat 0x%x4:2',dcwunit1,dcwccw1,dcwecb1,iob1.IOBSTBYT
         j     Eexit
Esnserr2 #MSG  '** Sense failed for 0x%x4:2: command %x2:1, CC 0x%x2:1,X
                Stat 0x%x4:2',dcwunit2,dcwccw2,dcwecb2,iob2.IOBSTBYT
         j     Eexit
Edifdevt #MSG  '** Device types differ: %x4:2 is %x4:2, %x4:2 is %x4:2'X
               ,dcwunit1,rdc1.RDCdevt,dcwunit2,rdc2.RDCdevt
         j     Eexit

Ebadhcyl ahi   r1,-1
*         stcm  r1,3,dcwcc                                         @020
         st    r1,dcwfw                                            @020
        #MSG   '** High cyl %x7:4 exceeds device %x4:2 high cyl %x7:4',X
               dcwhicyl,0(r2),dcwfw
         j     Eexit

Ebadlcyl #MSG  '** Low cyl %x7:4 greater than high cyl %x7:4',         X
               dcwlocyl,dcwhicyl
         j     Eexit

Eioerr1  #MSG  '** I/O error %x4:2 cchh=%x8:4 cc=%x2:1 csw=%x8:4%x8:4',X
               dcwunit1,dcwcchh,dcwecb1,iob1.IOBCSW8,iob1.IOBCSW8+4
         j     Eexit

Eioerr2  #MSG  '** I/O error %x4:2 cchh=%x8:4 cc=%x2:1 csw=%x8:4%x8:4',X
               dcwunit2,dcwcchh,dcwecb2,iob2.IOBCSW8,iob2.IOBCSW8+4
         j     Eexit

Eexit    MVC   dcwrsult,=A(16)    error return code
         j     terminat           terminate

*/* -------------------------------------------------------------------
*   literals and constants
* ------------------------------------------------------------------ */
         LTORG ,
delimtrt TRT   0(0,r3),delimtab   *** executed ***
parmmvc  MVC   dcwdw(0),0(r3)     *** executed ***
parmclc  CLC   0(0,rf),dcwdw      *** executed ***
parmhexc TRT   dcwdw(0),hexchars  *** executed ***
parmhex  TR    dcwdw(0),hextab    *** executed ***
parmpack PACK  dcwdw2,dcwdw(0)    *** executed ***
moddcb   DCB   DDNAME=0,DSORG=PS,MACRF=E
moddcbl  EQU   *-moddcb
prtdcb   DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PL,DCBE=PRTDCBE
prtdcbl  EQU   *-prtdcb
prtdcbe  DCBE  RMODE31=BUFF
prtdcbel EQU   *-prtdcbe
openl    OPEN  (0),MODE=31,MF=L
openll   EQU   *-openl
         UCBLOOK MF=(L,ulpl)
         UCBPIN MF=(L,uupl)
         IOSCAPU MF=(L,cupl)
hextab   DC    256X'00'
         ORG   hextab+C'0'
         DC    AL1(0,1,2,3,4,5,6,7,8,9)
         ORG   hextab+C'a'
         DC    AL1(10,11,12,13,14,15)
         ORG   hextab+C'A'
         DC    AL1(10,11,12,13,14,15)
         ORG   hextab+256
delimtab DC    256x'0'
         ORG   delimtab+C','
         DC    X'ff'
         ORG   delimtab+256
         DROP  ,
hexchars DC    256x'ff'
         ORG   hexchars+C'a'
         DC    6x'0'
         ORG   hexchars+C'A'
         DC    6x'0'
         ORG   hexchars+C'0'
         DC    10x'0'
         ORG   hexchars+256
upcase   DC    C' ',255AL1(*-upcase)
         ORG   upcase+c'a'
         DC    C'ABCDEFGHI'
         ORG   upcase+c'j'
         DC    C'JKLMNOPQR'
         ORG   upcase+c's'
         DC    C'STUVWXYZ'
         ORG   upcase+256
hex2char EQU   *-240
         DC    C'0123456789ABCDEF'
         DROP  ,
mainend  DS    0D


*/* -------------------------------------------------------------------
*        subroutine to issue messages
* ------------------------------------------------------------------ */
          USING msgr,r9
          USING dcw,rd
          USING dcw24,rb
          USING DISKCOMP,rc
          USING (DISKCOMP+4095,mainend),ra
msgr      STM  r0,rf,dcwsave1
          LR   r9,rf
          USING IHADCB,dcwpdcb
          TM   DCBOFLGS,DCBOFOPN
          BO   mr_opened            continue if message file is opened

          LR   r2,r1                save reg 1
          TM   dcwflags,dcwnoprt    test if no print file
          BO   mr_ret                return if not
          CLI  dcwprddn,0           print ddname specified yet ?
          BNE  mr_open2              yes, continue
          DEVTYPE =C'SYSPRINT',dcwdw  is SYSPRINT available ?
          LR   r1,r2                   restore reg 1
          LTR  rf,rf                    no, issue WTO
          BNZ  mr_opened
          MVC  dcwprddn,=C'SYSPRINT'     else use SYSPRINT ddname
mr_open2  MVC  dcwpdcb,prtdcb       copy the model print dcb
          MVC  DCBDDNAM,dcwprddn    set the print ddname
          MVC  dcwpdcbe,prtdcbe     copy model print dcbe
          LA   r1,dcwpdcbe          set dcbe address
          ST   r1,DCBDCBE            in the dcb
          OI   dcwflags,dcwnoprt    presume no print
          DEVTYPE DCBDDNAM,dcwdw    issue devtype for the ddname
          LTR  rf,rf                test devtype return code
          BNZ  mr_ret                return if some error
          L    r1,=A(mr_oxit)       get address of the open exit
          LA   rf,mr_oxitl          get open exit length
          BCTR rf,0                 decrement
          EX   rf,*+4               copy the open exit
          MVC  dcwoxit(0),0(r1)     *** executed ***
          LA   r1,dcwoxit           get open exit addr
          ST   r1,dcwexlst          set in exit list
          MVI  dcwexlst,x'85'       set exit type
          LA   r1,dcwexlst          point to exit list
          STCM r1,7,DCBEXLSA        set exlst addr in the dcb
          MVC  dcwopenl,openl       copy model open list
          OPEN (dcwpdcb,OUTPUT),MODE=31,MF=(E,dcwopenl)
          TM   DCBOFLGS,DCBOFOPN    did the file open ?
          BNO  mr_ret                no, return
          NI   dcwflags,255-dcwnoprt  else turn off `noprt' bit
          LR   r1,r2                restore reg 1

mr_opened LM   r4,r5,0(r1)          pattern addr, length

          BCTR r5,0
          LA   r3,8(,r1)            first parameter
          LA   r6,dcwmsg
          MVI  dcwmsg,C' '          init msg to blanks
          MVC  dcwmsg+1(L'dcwmsg-1),dcwmsg

mr_loop   LTR  r5,r5
          BM   mr_exit
          LA   r1,1(r4,r5)
          SLR  r2,r2
          EX   r5,mr_trt1
          SR   r1,r4                length scanned
          BNP  mr_skip1
          LR   rf,r1
          BCTR rf,0
          EX   rf,mr_mvc1           copy literal text
          AR   r6,r1
mr_skip1  AR   r4,r1
          SR   r5,r1
          BM   mr_exit
          BP   mr_skip2

          MVC  0(1,r6),0(r4)        string ends in special char
          LA   r6,1(,r6)
          B    mr_exit

mr_skip2  B    *(r2)                br on special char type
          B    mr_pct               '%'
          B    mr_bs                '\'

mr_pct    CLI  1(r4),C's'
          BE   mr_pct_s
          CLI  1(r4),C'x'
          BE   mr_pct_x
          CLI  1(r4),C'd'
          BE   mr_pct_d
          MVC  0(1,r6),0(r4)        treat '%' as any other char
          LA   r6,1(,r6)
          LA   r4,1(,r4)
          BCTR r5,0
          B    mr_loop
mr_pct_s  L    r7,0(,r3)            load string ptr
          LA   r3,4(,r3)
          LA   r4,2(,r4)            point past '%s'
          SH   r5,=Y(2)
          BAL  re,mr_op             r1 - target len, r2 - source len
          LTR  r2,r2
          BNZ  mr_pct_s3
          LR   r2,r7                source len = 0, find end of string
mr_pct_s1 CLI  0(r2),C' '
          BNH  mr_pct_s2
          LA   r2,1(,r2)
          B    mr_pct_s1
mr_pct_s2 SR   r2,r7
          BNP  mr_loop
mr_pct_s3 LR   rf,r2                copy source string to the msg
          BCTR rf,0
          EX   rf,mr_mvc2
          LTR  r1,r1
          BNZ  mr_pct_s5
          AR   r6,r2                truncate trailing spaces if
mr_pct_s4 BCTR r6,0                  target len is 0
          CLI  0(r6),C' '
          BNH  mr_pct_s4
          LA   r6,1(,r6)
          B    mr_loop
mr_pct_s5 CR   r1,r2
          BH   mr_pct_s6
          AR   r6,r1                truncate the string
          B    mr_loop
mr_pct_s6 AR   r6,r2                pad string with trailing blanks
          SR   r1,r2
mr_pct_s7 MVI  0(r6),C' '
          LA   r6,1(,r6)
          BCT  r1,mr_pct_s7
          B    mr_loop

mr_pct_x  L    r7,0(,r3)            load hex ptr
          LA   r3,4(,r3)
          LA   r4,2(,r4)            point past '%x'
          SH   r5,=Y(2)
          BAL  re,mr_op             r1 - target len, r2 - source len
          LTR  r2,r2
          BNZ  *+8
          LA   r2,4                 default source len is 4
          EX   r2,mr_pct_x_unpk
          TR   dcwdw,mr_hextab
          LTR  r1,r1
          BNZ  mr_pct_x1
          LA   r1,8                 determine default target len
          CLC  =C'00',dcwdw
          BNE  mr_pct_x1
          LA   r1,6
          CLC  =C'0000',dcwdw
          BNE  mr_pct_x1
          LA   r1,4
          CLC  =C'000000',dcwdw
          BNE  mr_pct_x1
          LA   r1,2
mr_pct_x1 LA   r7,dcwdw+8           copy the hex string to the msg
          SR   r7,r1
          BCTR r1,0
          EX   r1,mr_mvc2
          LA   r6,1(r1,r6)
          B    mr_loop

mr_pct_d  L    r7,0(,r3)            load decimal ptr
          LA   r3,4(,r3)
          LA   r4,2(,r4)            point past '%d'
          SH   r5,=Y(2)
          BAL  re,mr_op             r1 - target len, r2 - source len
          LTR  r2,r2
          BNZ  *+8
          LA   r2,4                 default source len is 4
          LA   rf,4
          SR   rf,r2
          LA   re,15
          SRL  re,0(rf)
          EX   re,mr_pct_d_icm
          CVD  rf,dcwdw
         MVC  DCWDW2(16),=X'40202020202020202020202020202120'
          ED   dcwdw2(16),dcwdw
          LTR  r1,r1
          BNZ  mr_pct_d2
          LA   rf,dcwdw2+16         default length -
mr_pct_d1 BCTR rf,0                  truncate leading spaces
          CLI  0(rf),C' '
          BH   mr_pct_d1
          LA   r1,dcwdw2+15
          SR   r1,rf
mr_pct_d2 LA   r7,dcwdw2+16
          SR   r7,r1
          BCTR r1,0
          EX   r1,mr_mvc2
          LA   r6,1(r1,r6)
          B    mr_loop

mr_bs     MVC  0(1,r6),1(r4)        copy char following '\'
          LA   r6,1(,r6)
          LA   r4,2(,r4)
          SH   r5,=Y(2)
          B    mr_loop

mr_exit   LA   r1,dcwmsg
          SR   r6,r1                calculate msg length
          BNP  mr_ret
          TM   DCBRECFM,DCBRECCA+DCBRECCM
          BZ   *+8
          LA   r6,1(,r6)            increment for carriage control

          TM   DCBOFLGS,DCBOFOPN
          BNO  mr_wto
          TM   DCBRECFM,DCBRECU
          BO   mr_u
          TM   DCBRECFM,DCBRECF
          BO   mr_f
          TM   DCBRECFM,DCBRECV
          BO   mr_v

mr_u      CH   r6,DCBBLKSI
          BNH  *+8
          LH   r6,DCBBLKSI
          STH  r6,DCBLRECL
          PUT  IHADCB
          TM   DCBRECFM,DCBRECCA+DCBRECCM
          BZ   mr_u1
          MVI  0(r1),C' '
          LA   r1,1(,r1)
          BCTR r6,0
          TM   DCBRECFM,DCBRECCA
          BO   mr_u1
          BCTR r1,0
          MVI  0(r1),X'09'
          LA   r1,1(,r1)
mr_u1     BCTR r6,0
          EX   r6,mr_mvc3
          B    mr_ret

mr_f      CH   r6,DCBLRECL
          BNH  *+8
          LH   r6,DCBLRECL
          PUT  IHADCB
          TM   DCBRECFM,DCBRECCA+DCBRECCM
          BZ   mr_f1
          MVI  0(r1),C' '
          LA   r1,1(,r1)
          BCTR r6,0
          TM   DCBRECFM,DCBRECCA
          BO   mr_f1
          BCTR r1,0
          MVI  0(r1),X'09'
          LA   r1,1(,r1)
mr_f1     BCTR r6,0
          EX   r6,mr_mvc3
          B    mr_ret

mr_v      LA   r6,4(,r6)
          LH   r1,DCBBLKSI
          SH   r1,=Y(4)
          CR   r6,r1
          BNH  *+6
          LR   r6,r1
          STH  r6,DCBLRECL
          PUT  IHADCB
          STH  r6,0(,r1)
          XC   2(2,r1),2(r1)
          LA   r1,4(,r1)
          SH   r6,=Y(4)
          TM   DCBRECFM,DCBRECCA+DCBRECCM
          BZ   mr_v1
          MVI  0(r1),C' '
          LA   r1,1(,r1)
          BCTR r6,0
          TM   DCBRECFM,DCBRECCA
          BO   mr_v1
          BCTR r1,0
          MVI  0(r1),X'09'
          LA   r1,1(,r1)
mr_v1     BCTR r6,0
          EX   r6,mr_mvc3
          B    mr_ret

mr_wto    LA   r6,4(,r6)
          STH  r6,dcwmsgl
          MVC  dcwmsgl+2(2),=X'8000'
          LA   r1,dcwmsg(r6)
         MVC  0(4,R1),=X'00000020'
          WTO  MF=(E,dcwmsgl)


mr_ret    LM   r0,rf,dcwsave1
          BR   re

*/* -------------------------------------------------------------------
* message subroutine to get operand lengths
* ------------------------------------------------------------------ */

mr_op     SLR  r1,r1
          SLR  r2,r2
mr_op1    LTR  r5,r5                first number is target length
          BMR  re
          CLI  0(r4),C'0'
          BL   mr_op2
          IC   rf,0(,r4)
          N    rf,=A(X'0000000f')
          MH   r1,=Y(10)
          AR   r1,rf
          LA   r4,1(,r4)
          BCTR r5,0
          B    mr_op1
mr_op2    CLI  0(r4),C':'          second number follows a ':'
          BNER re
mr_op3    LA   r4,1(,r4)           second number is source length
          SH   r5,=Y(1)
          BMR  re
          CLI  0(r4),C'0'
          BLR  re
          IC   rf,0(,r4)
          N    rf,=A(X'0000000f')
          MH   r2,=Y(10)
          AR   r2,rf
          B    mr_op3

*/* ---------------------------------------------------------------- */

mr_mvc1   MVC  0(0,r6),0(r4)
mr_trt1   TRT  0(0,r4),mr_tab1
mr_mvc2   MVC  0(0,r6),0(r7)
mr_mvc3   MVC  0(0,r1),dcwmsg
mr_pct_x_unpk  UNPK dcwdw(9),0(0,r7)
mr_pct_d_icm   ICM rf,0,0(r7)
mr_tab1   DC   XL256'0'
          ORG  mr_tab1+C'%'
          DC   AL1(4)
          ORG  mr_tab1+C'\'
          DC   AL1(8)
          ORG  mr_tab1+256
mr_hextab EQU  *-240
          DC   C'0123456789abcdef'
          LTORG ,
         #MSG  TYPE=GEN           messages
          DROP ,


*/* -------------------------------------------------------------------
*   message open exit - relocated to 24 bit storage
* ------------------------------------------------------------------ */

         USING mr_oxit,rf
         USING IHADCB,R1
mr_oxit  CLI   DCBRECFM,0          any record format ?
         BNE   *+8                  jumps if yes
         MVI   DCBRECFM,DCBRECV+DCBRECBR else set to `vb'

         SLR   r0,r0               get a zero
         CH    r0,DCBLRECL         any lrecl
         BNE   *+10                 jumps if yes
         MVC   DCBLRECL,=Y(125)      copy default lrecl

         CH    r0,DCBBLKSI         any blksize
         BNE   *+10                 jumps if yes
         MVC   DCBBLKSI,=Y(4096)     copy default blksize

         TM    DCBRECFM,DCBRECU    test record type
         BO    mr_oxitu             undefined
         TM    DCBRECFM,DCBRECV    test record type
         BO    mr_oxitv             variable
         TM    DCBRECFM,DCBRECF    test record type
         BO    mr_oxitf             fixed
         B     mr_oxit0            unknown, return

mr_oxitu MVC   DCBLRECL,DCBBLKSI   undefined, set lrecl from blksize
         B     mr_oxit0            return

mr_oxitv LH    r3,DCBBLKSI         variable, load blksize
         LA    r0,4                calculate maximum
         SR    r3,r0                lrecl
         CH    r3,DCBLRECL         check against lrecl
         BNL   mr_oxit0             return if not too high
         STH   r3,DCBLRECL           else reset to max
         B     mr_oxit0            return

mr_oxitf LH    r3,DCBBLKSI         fixed, load blksize
         SLR   r2,r2               clear for divide
         LH    r0,DCBLRECL         load lrecl
         DR    r2,r0               divide lrecl into blksize
         LTR   r2,r2               test if any remainder
         BZ    mr_oxit0            return if not
         MH    r3,DCBLRECL         calculate new blksize
         STH   r3,DCBBLKSI         set new blksize

mr_oxit0 BR    re
         LTORG ,
mr_oxitl EQU   *-mr_oxit
         DROP  ,

*/* -------------------------------------------------------------------
*   workareas
* ------------------------------------------------------------------ */
dcw      DSECT ,                  offline dump/restore workarea
dcwid    DS    0CL4'dcw '         identifier
dcwsave  DS    18F                standard save area
dcwsave0 DS    16F                save area for dumpr/restorer
dcwsave1 DS    16F                save area for writer
dcw24a   DS    A                  24-bit work area address
dcwrsult DS    F                  result (return) value
dcwfcn   DS    CL8                function (backup or restore)
dcwflags DS    X                  flag bits
dcwnoprt EQU   X'80'              messsage dataset not available
dcwflag1 DS    X                  flag bits for unit 1
dcwflag2 DS    X                  flag bits for unit 2
dcwpin   EQU   X'80'              offline dasd ucb pinned
dcwcucb  EQU   X'40'              offline dasd ucb captured
dcwdebad EQU   X'20'              offline dasd ucb deb added
dcwnry   EQU   X'10'              offline dasd ucb `not ready' bit
dcwunit1 DS    H                  offline unit 1 address
dcwunit2 DS    H                  offline unit 2 address
dcwlocyl DS    F                  low cylinder to dump             @020
dcwhicyl DS    F                  high cylinder to dump            @020
dcwncyl1 DS    F                  number of cylinders for unit1    @020
dcwncyl2 DS    F                  number of cylinders for unit2    @020
dcwretcd DS    F                  return code
dcwrsncd DS    F                  reason code
dcwucb1  DS    A                  ucb 1 address
dcwucb2  DS    A                  ucb 2 address
dcwcucb1 DS    A                  captured ucb 1 address
dcwcucb2 DS    A                  captured ucb 2 address
dcwdeb1  DS    A                  deb 1 address
dcwdeb2  DS    A                  deb 2 address
dcwptok1 DS    D                  ucb 1 pin token
dcwptok2 DS    D                  ucb 2 pin token
dcwctime DS    D                  current date/time
dcwdtime DS    CL20               dat/time display area
dcwdw    DS    D                  double word work areas
dcwdw2   DS    D
dcwdw3   DS    D
dcwdw4   DS    D
dcwfw    DS    F                  full word work areas             @020
dcwtrks  DS    F                  tracks read
dcwdiffs DS    F                  differences found
dcwlen1  DS    F                  unit 1 track length
dcwlen2  DS    F                  unit 2 track length
         DS    0D
dcwprddn DS    CL8                print ddname
dcwpdcbe DS    XL(prtdcbel)       print dcbe
         DS    0D
dcwopenl DS    XL(openll)         open parameter list
         DS    0D
dcwulpl  DS    XL(ulpll)          ucblook parameter list
         DS    0D
dcwuupl  DS    XL(uupll)          ucbpin unpin parameter list
         DS    0D
dcwcupl  DS    XL(cupll)          ioscapu parameter list
         DS    0D
dcwmsgl  DS    F                  message length (for WTO)
dcwmsg   DS    CL256              message
dcwmsgpl DS    24F                message parameter list
dcwl     EQU   *-dcw

dcw24    DSECT ,                  24-bit work area
dcw24id  DC    CL4'dc24'          identifier
dcwzeros DS    XL16               24-bit zeroes
dcwpdcb  DS    XL(prtdcbl)        print dcb
dcwexlst DS    F                  dcb exit list
dcwdcb1  DS    XL(moddcbl)        device 1 dcb
dcwccw1  DS    8D                 device 1 channel program
dcwccwl  EQU   *-dcwccw1                   channel program length
dcwiob1  DS    XL40               device 1 iob
dcwlrp1  DS    XL16               device 1 locate record parm area
dcwecb1  DS    F                  device 1 ecb
dcwsnsi1 DS    XL20               device 1 snsid info
dcwrdc1  DS    XL64               device 1 rdc info
dcwrcd1  DS    XL256              device 1 rcd info
dcwsnss1 DS    XL40               device 1 snss info
dcwsns1  DS    XL32               device 1 sense info
dcwdcb2  DS    XL(moddcbl)        device 2 dcb
dcwccw2  DS    8D                 device 2 channel program
dcwiob2  DS    XL40               device 2 iob
dcwlrp2  DS    XL16               device 2 locate record parm area
dcwecb2  DS    F                  device 2 ecb
dcwsnsi2 DS    XL20               device 2 snsid info
dcwrdc2  DS    XL64               device 2 rdc info
dcwrcd2  DS    XL256              device 2 rcd info
dcwsnss2 DS    XL40               device 2 snss info
dcwsns2  DS    XL32               device 2 sense info
dcwoxit  DS    XL256              relocated message open exit
dcwcchh  DS    0F                 current cchh in absolute trk adr @020
dcwcc    DS    H
dcwhh    DS    H
dcwncchh DS    0XL5               current cchh in normalized fmt   @020
dcwncc   DS    F                  current cc in normalized fmt     @020
dcwnhh   DS    X                  current hh in normalized fmt     @020
         DS    0D
dcwecbl  DS    2A                 ecb wait list
dcwbuf1  DS    A                  device 1 buffer address
dcwbuf2  DS    A                  device 2 buffer address
dcwbufs  DS    (2*65536)X         buffers
dcw24l   EQU   *-dcw24

RDCinfo  DSECT ,                  read device characteristics info
RDCsdt   DS    XL2                storage director type
RDCsdmi  DS    X                  storage director model information
RDCdevt  DS    XL2                device type
RDCdevm  DS    X                  device model
RDCdasdf DS    XL4                device & storage director facilities
RDCclass DS    X                  device class code
RDCtype  DS    X                  device type code
RDCprime DS    XL2                number of primary cylinders
RDCheads DS    XL2                tracks per cylinder
RDCsctrs DS    X                  number of sectors
RDCtrkln DS    XL3                total track length (usable)
RDChar0  DS    XL2                length of ha and r0
RDCtccf  DS    X                  track capacity calculation formula
RDCfctrs DS    XL5                track capacity calculation factors
RDCacyl  DS    XL2                address of first alternate cylinder
RDCacyln DS    XL2                number of alternate tracks
RDCdcyl  DS    XL2                address of first diagnostic cylinder
RDCdcyln DS    XL2                number of diagnostic tracks
RDCscyl  DS    XL2                address of first device support cyl
RDCscyln DS    XL2                number of device support tracks
RDCmdrid DS    X                  mdr record id
RDCobrid DS    X                  obr record id
RDCsdtc  DS    X                  storage director type code
RDCrtspl DS    X                  read trackset parameter length
RDCmaxr0 DS    XL2                maximum record zero data length
         DS    X                  (reserved)
RDCtss   DS    X                  track set size
RDCatccf DS    X                  additional track capacity calc. factr
RDCrps   DS    XL2                rps sector calculation factors
         DS    XL3                (reserved)
RDCgdff  DS    X                  generic device/cu functions/features
         DS    X                  (reserved -- zeroes)
RDCrduc  DS    X                  real control unit code
RDCrdc   DS    X                  real device code
*         DS    XL6                (reserved)                      @020
         DS    XL2                (reserved)                       @020
RDCeavc  DS    XL4                number of cylinders for 3390-A   @020
RDCinfol EQU   *-RDCinfo

LRparm   DSECT ,                  locate record paramete
LRop     DS    X                  operation byte
LRocount EQU   B'00000000'        orient count
LRohome  EQU   B'01000000'        orient home
LRodata  EQU   B'10000000'        orient data
LRoindex EQU   B'11000000'        orient index
LRorient EQU   X'00'              orient
LRwrite  EQU   X'01'              write data
LRfwrite EQU   X'03'              format write
LRread   EQU   X'06'              read data
LRwt     EQU   X'0b'              write track
LRrt     EQU   X'0c'              read tracks
LRrd     EQU   X'16'              read
LRaux    DS    X                  auxiliary byte
LRusetlf EQU   B'10000000'        transfer length factor specified
LRrcccw  EQU   B'00000001'        a read count ccw is suffixed
         DS    X
LRcount  DS    X                  count parameter
LRseek   DS    0XL4               seek addr
LRseekcc DS    XL2
LRseekhh DS    XL2
LRsearch DS    0XL5               search arg
LRsrchcc DS    XL2
LRsrchhh DS    XL2
LRsrchr  DS    X
LRsector DS    X
LRtlf    DS    XL2                transfer length factor
LRparml  EQU   *-LRparm

*/* -------------------------------------------------------------------
*   dsects
* ------------------------------------------------------------------ */
         PRINT NOGEN
         DCBD  DSORG=PS
         IHADCBE ,
UCBDSECT DSECT ,
         IEFUCBOB ,
         IEZDEB ,
DEBLENGTH EQU  (DEBBASND-DEBAVT)+(DEBDASDE-DEBDASD)+DEBXLEN
         IEZIOB ,
         IHAECB ,
         IOSDCCW ,
         CVT   DSECT=YES
         IHAPSA ,
         IKJTCB ,

*/* -------------------------------------------------------------------
*   equates
* ------------------------------------------------------------------ */
SK    EQU X'07'
SNSID EQU X'e4'
SNS   EQU X'04'
RDC   EQU X'64'
SNSS  EQU X'54'
RT    EQU X'de'
DX    EQU X'63'
LR    EQU X'47'
WR0   EQU X'15'
WCKD  EQU X'1d'
TIC   EQU X'08'
PSF   EQU X'27'
RSSD  EQU X'3E'
RCD   EQU X'FA'

r0 EQU 0
r1 EQU 1
r2 EQU 2
r3 EQU 3
r4 EQU 4
r5 EQU 5
r6 EQU 6
r7 EQU 7
r8 EQU 8
r9 EQU 9
ra EQU 10
rb EQU 11
rc EQU 12
rd EQU 13
re EQU 14
rf EQU 15

   END ,
