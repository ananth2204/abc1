{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011126000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 352716, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "CBT.V500.FILE045.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 352716, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 352716, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE045.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x06\\x08'", "DS1TRBAL": "b':\\n'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x00T\\x00\\r\\x00U\\x00\\x04\\x00\\x07'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$DOC": {"ttr": 516, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "JES2 SOURCE COMPARE SYSTEM\n\n     ALSO INCLUDED IN THIS PDS IS THE ORIGINAL PDS COMPARE PROGRAM\n     CALL PDSCMPR                                           AXC\n\n DEVELOPED BY:\n     BRENT TOLMAN\n     TMS\n     SALT LAKE CITY\n     UTAH 84118\n\nPURPOSE:\n     SHOW ALL CHANGE ACTIVITY BETWEEN TWO RELEASES OF JES2 ON THE\n     ASSEMBLY LISTINGS.\n\nCOMPONENTS:\n     PDSCMPR  - ORIGINAL PDS COMPARE PROGRAM\n     JES2CMPR - AN ASSEMBLY LANGUAGE PROGRAM THAT IS A MODIFICATION OF\n                THE PDSCMPR PROGRAM.  THIS PROGRAM CREATES A PDS THAT\n                CONTAINS ALL OF THE CHANGES BETWEEN TWO RELEASES.\n     JES2LIST - AN ASSEMBLY LANGUAGE PROGRAM THAT READS THE ABOVE PDS,\n                THE SYSPRINT OUTPUT FROM THE ASSEMBLER AND PRINTS A\n                NEW ASSEMBLY LISTING SHOWING WERE CHANGES HAVE OCCURRED.\n     CMPRPDS  - A JCL STREAM THAT EXECUTES JES2CMPR.\n     JES2ASM2 - A PROC THAT EXECUTES THE ASSEMBLER AND THEN JES2LIST TO\n                CREATE THE POST ASSEMBLY LISTING\n     ASM88888 - A JCL STREAM THAT ASSEMBLES ALL OF THE JES2 MODULES.\n\nNOTES:\n   1)  THE SYSTEM ISN'T AS POLISHED AS IT MIGHT BE, BUT IT DOES WORK\n       FAIRLY WELL:\n\n           - SINCE BOTH THE OLD CODE AND THE NEW CODE ARE SHOWN IN THE\n             POST ASSEMBLY LISTING, A LITTLE CAUTION IS REQUIRED WHEN\n             READING THE LISTING TO NOTE WHAT IS COMMENTS AND WHAT IS\n             EXECUTED CODE.  THE LISTING CLEARLY FLAGS CHANGES IN THE\n             RIGHT HAND MARGIN TO HELP AVOID CONFUSION.  IF DESIRED,\n             THE JES2LIST PROGRAM COULD BE MODIFIED SO THE OLD \"WAS\"\n             CODE DOESN'T PRINT.\n\n           - DEPENDING ON HOW THE JES2 CHANGE TEAM SEQUENCES THEIR\n             CHANGES, SOME OF THE NEW CODE MAY LIST BOTH AS EXECUTED\n             CODE AND AS COMMENTS.  THIS HAPPENS WHEN THE NEW CODE\n             HAS A SEQUENCE NUMBER LESS THAN THE OLD CODE.  FOR\n             EXAMPLE, IF THE OLD CODE WAS:\n\n                 MVI X,C' '      X00001200\n                 MVI Z,C' '      X00001300\n\n             AND THE NEW CODE IS\n\n                 MVI X,C'0'      X00001180\n                 MVI Y,C'0'      X00001200\n                 MVI Z,C'0'      X00001300\n\n             THE MVI X,C'0'      X00001180 WOULD LIST BOTH AS EXECUTED\n             CODE AND AS A COMMENT SAYING \"NEW\".  THIS WILL BE MUCH MORE\n             CLEAR AFTER YOU USE THE SYSTEM.  IT COULD BE CORRECTED BY\n             MODIFYING JES2LIST; AT THE PRESENT TIME, JES2LIST READS THE\n             OLD CODE CHANGES FIRST AND THEN THE NEW CODE CHANGES.  TO\n             FIX THIS PROBLEM, JES2LIST WOULD HAVE TO READ BOTH THE OLD\n             AND NEW CODE CHANGES AND THEN PROCESS WHICH EVER ONE HAD\n             THE LOWEST SEQUENCE NUMBER FIRST.  AGAIN, IF YOU PAY\n             ATTENTION TO THE FLAGS IN THE RIGHT HAND MARGIN, THIS ISN'T\n             MUCH OF A PROBLEM.\n\n           - IF THERE ARE NO CHANGES IN A MODULE, THEN JES2LIST WILL GET\n             A S013-18 ABEND.  THIS COULD HAVE BEEN CORRECTED A NUMBER OF\n             WAYS IN THE CODE, BUT HAS SIMPLY BEEN HANDLED WITH JCL; IF\n             THE JES2LIST STEP ABENDS, THEN AN \"IEBGENER\" STEP IS EXECUTED\n             TO COPY THE ORIGINAL ASSEMLY LISTING TO A SYSOUT DATA SET.\n\n           - JES2LIST SHOWS MACROS THAT HAVE BEEN CHANGED, BUT DOESN'T TRY TO\n             SHOW ANY CHANGES IN THE CODE THAT GETS EXPANDED.\n             FOR EXAMPLE, IF THE $#CKPT MACRO HAS CHANGED BETWEEN RELEASE,\n             EACH TIME THE  $#CKPT MACRO IS CODED, THERE WILL BE A FLAG IN THE\n             MARGIN, BUT THERE WILL BE NO FLAGS TO NOTE IF THERE ARE CHANGES IN\n             THE CODE THAT THE MACRO GENERATED.\n\n  2) THE SYSTEMS WAS DESIGNED AND IS BEING USED BY TMS TO CLEARLY SHOW JES2\n     CHANGES, BUT OBVIOUSLY COULD BE USED FOR ANY APPLICATION WRITTEN\n     IN ASSEMBLER.  IT SPECIFICALLY TREATS APPLICATIONS WITH MORE THAN\n     ONE MODULE, BUT THERE IS NO REASON IT COULDN'T BE USED WITH INDIVID-\n     UAL PROGRAMS.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASM88888": {"ttr": 519, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//JES2COMM JOB (%SYSUACCT),%SYSUNAME,CLASS=A,NOTIFY=%SYSUID\n//*PROCLIB DSN=T0JES2.JCL.CNTL\n/*CNTL JES2ASM2,EXC\n//JES2COMM EXEC JES2ASM2,M=HASPCOMM\n//*\n//\n//JES2PRPU JOB (%SYSUACCT),%SYSUNAME,CLASS=A,NOTIFY=%SYSUID\n//*PROCLIB DSN=T0JES2.JCL.CNTL\n/*CNTL JES2ASM2,EXC\n//JES2PRPU EXEC JES2ASM2,M=HASPPRPU\n//*\n//\n//JES2ACCT JOB (%SYSUACCT),%SYSUNAME,CLASS=A,NOTIFY=%SYSUID\n//*PROCLIB DSN=T0JES2.JCL.CNTL\n/*CNTL JES2ASM2,EXC\n//JES2ACCT EXEC JES2ASM2,M=HASPACCT\n//*\n//\n//JES2MISC JOB (%SYSUACCT),%SYSUNAME,CLASS=A,NOTIFY=%SYSUID\n//*PROCLIB DSN=T0JES2.JCL.CNTL\n/*CNTL JES2ASM2,EXC\n//JES2MISC EXEC JES2ASM2,M=HASPMISC\n//*\n//\n//JES2CON  JOB (%SYSUACCT),%SYSUNAME,CLASS=A,NOTIFY=%SYSUID\n//*PROCLIB DSN=T0JES2.JCL.CNTL\n/*CNTL JES2ASM2,EXC\n//JES2CON  EXEC JES2ASM2,M=HASPCON\n//*\n//\n//JES2INIT JOB (%SYSUACCT),%SYSUNAME,CLASS=A,NOTIFY=%SYSUID\n//*PROCLIB DSN=T0JES2.JCL.CNTL\n/*CNTL JES2ASM2,EXC\n//JES2INIT EXEC JES2ASM2,M=HASPINIT\n//*\n//\n//JES2RTAM JOB (%SYSUACCT),%SYSUNAME,CLASS=A,NOTIFY=%SYSUID\n//*PROCLIB DSN=T0JES2.JCL.CNTL\n/*CNTL JES2ASM2,EXC\n//HASPRTAM EXEC JES2ASM2,M=HASPRTAM\n//*\n//\n//JES2RDR  JOB (%SYSUACCT),%SYSUNAME,CLASS=A,NOTIFY=%SYSUID\n//*PROCLIB DSN=T0JES2.JCL.CNTL\n/*CNTL JES2ASM2,EXC\n//JES2RDR  EXEC JES2ASM2,M=HASPRDR\n//*\n//\n//JES2SSSM JOB (%SYSUACCT),%SYSUNAME,CLASS=A,NOTIFY=%SYSUID\n//*PROCLIB DSN=T0JES2.JCL.CNTL\n/*CNTL JES2ASM2,EXC\n//JES2SSSM EXEC JES2ASM2,M=HASPSSSM\n//*\n//\n//JES2NUC  JOB (%SYSUACCT),%SYSUNAME,CLASS=A,NOTIFY=%SYSUID\n//*PROCLIB DSN=T0JES2.JCL.CNTL\n/*CNTL JES2ASM2,EXC\n//JES2NUC  EXEC JES2ASM2,M=HASPNUC\n//*\n//\n//JES2XEQ  JOB (%SYSUACCT),%SYSUNAME,CLASS=A,NOTIFY=%SYSUID\n//*PROCLIB DSN=T0JES2.JCL.CNTL\n/*CNTL JES2ASM2,EXC\n//JES2XEQ  EXEC JES2ASM2,M=HASPXEQ\n//*\n//\n//JES2CB   JOB (%SYSUACCT),%SYSUNAME,CLASS=A,NOTIFY=%SYSUID\n//*PROCLIB DSN=T0JES2.JCL.CNTL\n/*CNTL JES2ASM2,EXC\n//JES2CB   EXEC JES2ASM2,M=HASPCB,XREF=LONG\n//SYSPRINT DD  SYSOUT=D\n//*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CBTJCL": {"ttr": 522, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//CBT1274 JOB 527TSO000S0008,'CBT1274',CLASS=B,MSGCLASS=6,\n// NOTIFY=TS15500\n/*JOBPARM ROOM=F04L\n//STEP01   EXEC BANNER,P='CBT1274!!CBT1274',COPY=3\n// EXEC ASMBLR,SO=6\n//SYSIN DD DISP=SHR,DSN=TS15500.CBT1274.PDS(PDSCMPR)\n// EXEC LINKX,SO=6,NAME=CBT1274,LIB='SYS2.MLINKLIB'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CMPRPDS": {"ttr": 524, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//CMPR050  JOB (%SYSUACCT),%SYSUNAME,CLASS=D,NOTIFY=%SYSUID\n//*\n//ALLOC    EXEC PGM=IEFBR14,COND=(5,LT)\n//DD1      DD  DSN=T0JES2.CHANGES.ASM,DISP=(,CATLG,DELETE),\n//             UNIT=3330V,DCB=(LRECL=80,BLKSIZE=3600,RECFM=FB),\n//             SPACE=(CYL,(15,5,84),RLSE),VOL=SER=SYSV03\n//*\n//CMPRPDS  EXEC PGM=JES2CMPR,COND=(5,LT)\n//SYSPRINT DD  SYSOUT=*\n//CHANGE   DD  DSN=T0JES2.CHANGES.ASM,DISP=SHR\n//NEW      DD  DSN=T0JES2.SOURCE,DISP=SHR\n//OLD      DD  DSN=T0JES2.OLD.SOURCE,DISP=SHR\n//SYSUDUMP DD  SYSOUT=*\n//STEPLIB  DD  DSN=T0MVS.PDS.LOAD,DISP=SHR\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JES2ASM2": {"ttr": 526, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//JES2ASM2 PROC XREF=SHORT\n//ALLOC    EXEC PGM=IEFBR14\n//IPODLB   DD  UNIT=3330V,VOL=SER=IPODLB,DISP=SHR\n//*\n//JES2     EXEC PGM=ASMBLR,PARM='DECK,XREF(&XREF)',REGION=250K\n//SYSLIB   DD  DSN=TMS1.BLK12960,DISP=SHR\n//         DD  DSN=SYS1.AMACLIB,DISP=SHR,UNIT=3330V,VOL=SER=IPODLB\n//         DD  DSN=SYS1.AMODGEN,DISP=SHR,UNIT=3330V,VOL=SER=IPODLB\n//         DD  DSN=T0JES2.TUCMODS.ASM,DISP=SHR\n//         DD  DSN=T0JES2.SOURCE,DISP=SHR\n//         DD  DSN=T0JES2.LOCALMOD.ASM,DISP=SHR\n//SYSUT1   DD  DSN=&&SYSUT1,UNIT=SYSDA,SPACE=(CYL,(5,15))\n//SYSUT2   DD  DSN=&&SYSUT2,UNIT=SYSDA,SPACE=(CYL,(5,15))\n//SYSUT3   DD  DSN=&&SYSUT3,UNIT=SYSDA,SPACE=(CYL,(5,15))\n//SYSPRINT DD  DSN=&M.,DISP=(,PASS),UNIT=SYSDA,\n//             SPACE=(CYL,(5,5)),DCB=BLKSIZE=12100\n//SYSIN    DD  DSN=T0JES2.SOURCE(&M.),DISP=SHR\n//SYSPUNCH DD  DSN=T0JES2.OBJ(&M.),DISP=SHR\n//*\n//*\n//JES2LIST EXEC PGM=JES2LIST\n//SYSPRINT DD  SYSOUT=*\n//PRINTIN  DD  DSN=&M,DISP=(OLD,PASS),UNIT=SYSDA\n//PRINTOUT DD  SYSOUT=*\n//CHGMEM   DD  DSN=T0JES2.CHANGES.ASM(&M),DISP=SHR\n//CHGPDS   DD  DSN=T0JES2.CHANGES.ASM,DISP=SHR\n//STEPLIB  DD  DSN=T0MVS.PDS.LOAD,DISP=SHR\n//*\n//*\n//LISTONLY EXEC PGM=USCCOPY,COND=ONLY\n//* *****************************************************************\n//* * JES2LIST WILL ABEND WITH A S013-18 IF THERE WERE NO CHANGES   *\n//* * TO A MODULE AND CONSEQUENTLY NO MEMBER IN T0JES2.CHANGES.ASM. *\n//* * IF THAT HAPPENS, THIS JOB STEP WILL PRINT THE ASSEMBLY.       *\n//* *****************************************************************\n//SYSPRINT DD  SYSOUT=*\n//SYSUT01  DD  DSN=&M,DISP=(OLD,DELETE),UNIT=SYSDA\n//SYSUT01D DD  SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JES2CMPR": {"ttr": 528, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         TITLE 'JES2 COMPARE PROGRAM -- USE YALE COMPARE PGM LOGIC'\n*\n*   THIS IS A MODIFICATION OF THE PDS COMPARE PROGRAM WHICH IS A\n*   MODIFICATION TO THE YALE COMPARE PROGRAM THAT IS DISTRIBUTED AS\n*   FILE 226 ON THE CONN. BANK MODS TAPE.  THIS VERSION OF THE PROGRAM\n*   DOES A PDS COMPARE ON TWO JES2 PDS LIBRARIES (AT DIFFERENT PTF\n*   LEVELS) AND NOTES ALL THE DIFFERENCES IN A NEW PDS.  THEN WHEN\n*   THE NEW JES2 IS ASSEMBLED THE SYSPRINT IS WRITTEN TO A DATA SET\n*   AND A POST PROCESSOR ADDS INDICATORS IN THE ASSEMBLY LISTING\n*   SHOWING WHERE THERE ARE CHANGES.\n*\n*   THE JCL NEEDED TO EXECUTE THE PROGRAM FOLLOWS:\n*       1) //         EXEC PGM=JES2CMPR\n*       2) //CHANGES  DD  DSN=JES2.DIFF.PDS,DISP=(,CATLG)\n*       3) //NEW      DD  DSN=NEW.JES2.SOURCE,DISP=SHR\n*       4) //OLD      DD  DSN=OLD.JES2.SOURCE,DISP=SHR\n*\n*   THE 'NEW' AND 'OLD' DD STATMENTS WILL BE USED TO PROCESS BOTH THE\n*   DIRECTORIES AND MEMBERS OF THE JES2 FILES.  MEMBER NAMES SHOULD NOT\n*   BE CODED.  OPEN TYPE=J WILL BE USED TO ACCESS THE MEMBERS.\n*\n*   THE JES2.DIFF.PDS WILL CONTAIN ALL THE CHANGES BETWEEN THE TWO\n*   VERSIONS.  IT SHOULD BE CREATED AS A NEW PDS EACH TIME SO THAT:\n*     - NO DIFFERENCES FROM OLD COMPARISONS ARE LEFT OVER\n*     - THERE IS NO DANGER OF OVERLAYING GOOD DATA USED FOR OTHER\n*       OTHER PURPOSES\n*\n*   THE PROGRAM WILL LIST ALL OF THE CHANGES IN ADDITION TO CREATING\n*   THE CHANGES REPORT.  THE DETAILED LISTING SHOWS:\n*      - THE MEMBER NAME, DATA SET NAME, AND VOL/SER OF EACH MEMBER\n*        PROCESSED.\n*      - ANY DIFFERENCES THAT EXIST BETWEEN THE MEMBERS.\n*      - A COUNT OF UNEQUAL BLOCKS OF DATA AS WELL AS THE RECORD COUNTS\n*        FOR EACH MEMBER.\n*   THE RECAP LISTING FORMAT IS:\n*      OLD MEM=XXXXXXXX PAGE NNNN NEW MEM=YYYYYYYY STATUS\n*      THE STATUS MAY BE\n*          - EQUAL           BOTH MEMBERS ARE THE SAME\n*          - NOT EQUAL       THERE ARE DIFFERENCES\n*          - NO MATCH        THE MEMBER EXISTS IN ONLY ONE JES2\n*\n*\n*   BRENT TOLMAN\n*   TRANSPORTAION MANAGEMENT SERVICES\n*   SALT LAKE CITY, UT\n*\n*\n*\n*\n          EJECT\nJES2CMPR CSECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 3\n         STM   R14,R12,12(R13)     SAVE THEIR REGS IN THEIR AREA\n         LR    R10,R15             LOAD BASE REG WITH ENTRY ADDR\n         LA    R6,4095(,R10)       LOAD SECOND BASE\n         LA    R6,1(,R6)           WITH PROPER ADDRESS\n         USING JES2CMPR,R10,R6     ESTABLISH ADDRESSABILITY\n         B     JES2LINK            NOW GO LINK SAVE AREAS\n         SPACE\nJES2PGM  DC    CL8'JES2CMPR'       PROGRAM NAME\nJES2DATE DC    CL8'&SYSDATE'       SYSTEM DATE OF ASSEMBLY\n         DC    CL3' '\nJES2TIME DC    CL5'&SYSTIME'       SYSTEM TIME OF ASSEMBLY\n         SPACE 2\nJES2SAVE DC    9D'0'               SAVE AREA FOR JES2CMPR\nRETCODE  DC    F'0'                RETURN CODE\nRETURN   L     R15,RETCODE         GET RETURN CODE\n         L     R13,JES2SAVE+4      GET ADD OF THEIR SAVE AREA\n         L     R14,12(,R13)        RESTORE RETURN ADDRESS\n         LM    R0,R12,20(R13)      RESTORE R0 THRU R12\n         BR    R14                 RETURN TO CALLER\n         SPACE 2\nJES2LINK LA    R14,JES2SAVE        GET ADDR OF OUR SAVE AREA\n         ST    R14,8(,R13)         SAVE OUR ADDR IN THEIR AREA\n         ST    R13,4(,R14)         SAVE THEIR ADDR IN OUR AREA\n         LR    R13,R14             POINT R13 TO OUR AREA NOW\n         EJECT\nPARM     EQU   *                   PROCESS PARM DATA SUPPLIED BY USER\n* PARM\n*        R1 - SCP POINTER TO PARM AT ENTRY\n*        R2 - PARM LENGTH\n*        R3 - POINTER TO PARM DATA WHILE EVALUATING\n*        R4 - POINTER TO PARM VALUE SAVE AREAS\n*        R5 - LOOP CONTROL AND SAVE AREA POINTER\n*\n*        BAL   R12,NUMB  - CONVERT VALUE TO BINARY\n*        B     GETM\n***********************************************************************\n         L     R1,0(,R1)           POINT TO PARM AREA\n         LH    R2,0(,R1)           GET LENGTH IN R2\n         STM   R1,R2,PARMVALS      SAVE ADDR AND LEN\n         LTR   R2,R2               IS THERE A PARM FROM USER?\n***********************************************************************\n* I HAVE FORCED JES2CMPR TO TAKE THE DEFAULT PARM VALUES. IF YOU WANT *\n* TO HAVE THE ABILITY TO CHANGE THE OPTIONS, CHANGE THE FOLLOWING B   *\n* TO A BZ AND IT WILL BE THE SAME AS PDSCMPR.  BRENT TOLMAN           *\n*                                                                     *\n* DEFAULT FOR TYPE HAS BEEN CHANGED FROM PART TO FULL                 *\n*                                                                     *\n***********************************************************************\n         B     PARMEND             NO  -- TAKE DEFAULTS\n         SPACE\n         LA    R3,1(,R1)           IN LOOP R3 POINTS TO DATA\n         LA    R2,1(,R2)           ADJUST LEN FOR 1ST PASS\nPARM2    EQU   *                   EVALUATE NEXT KEYWORD\n         LTR   R2,R2               IS THERE SOME LENGHT LEFT?\n         BNP   PARMEND             NO  -- EVALUATION COMPLETE\n         LA    R3,1(,R3)           POINT TO START OF KEYWORD\n         BCT   R2,PARM2B           REDUCE LEN - BRANCH AT END\n         B     PARMEND\nPARM2B   EQU   *                   DETERMINE WHICH KEYWORD NOW\n         CLC   =C'TYPE=',0(R3)     LIBRARY TYPE SPECIFICATION?    PAN\n         BE    PARM5                                              PAN\n         CLC   =C'PRINT=',0(R3)    RANGE SPECIFICATION?\n         BE    PARM6               YES\n         CLC   =C'SIZE=',0(R3)     SIZE OF JES2?\n         BE    PARM8\n         SPACE\nPARM2D   EQU   *                   INVALID PARAMETER\n         WTO   'INVALID PARM VALUE SPECIFIED -- PROCESSING TERMINATED'\n         MVC   RETCODE,=F'16'      SET RETURN CODE TO 16\n         B     RETURN              RETURN TO SCP\n         SPACE\nPARM5    EQU   *                   LIBRARY TYPE ANALYSIS\n         LA    R3,5(,R3)           POINT PAST KEYWORD\n         SH    R2,=H'5'            KEEP REMAINING LEN ACCURATE\n         MVC   PARMTYPE,=F'0'      INITIALIZE SAVE AREA\n         LA    R4,PARMTYPE         POINT TO SAVE AREA\n         BAL   R12,PARM10          GO GET USER VAUE\n         CLC   PARMTYPE,=C'PART'   DID USER SPECIFY FULL COMPARE?\n         BNE   PARM2               NO  -- USE DEFAULT VALUE 'PART'\n         MVI   MLENGTH,X'47'       YES -- SET MOVE LENGTH TO 72\n         B     PARM2               NO FURTHER EVALUATION\n         EJECT\nPARM6    EQU   *                   RANGE PROCESSING\n         LA    R3,6(,R3)           POINT PAST KEYWORD\n         SH    R2,=H'6'            KEEP LEN CORRECT\n         LA    R4,PARMPRNT         POINT TO FIRST SAVE AREA\n         BAL   R12,PARM10          GO GET USER VALUE\n         CLC   PARMPRNT(3),=C'MEM' DID USER SAY TO PRINT ENTIRE MEMBER?\n         BE    PARM6H              YES\n         CLC   PARMPRNT(3),=C'DIR' DID USER SAY TO PRINT DIRECTRY ONLY?\n         BE    PARM6H              YES\n         MVC   PARMPRNT,=C'NAME'   NO -- SET TO NAME ONLY\nPARM6H   EQU   *                   EVALUATE\n         B     PARM2               GO GET NEXT KEYWORD\n         SPACE 2\nPARM8    EQU   *                   SIZE SPECIFICATION\n         LA    R3,5(,R3)           POINT TO VALUE\n         SH    R2,=H'5'            CORRECT REMAINING LEN\n         MVC   PARMSIZE,=F'0'      INITIALIZE SAVE AREA\n         LA    R4,PARMSIZE         POINT TO SAVE AREA\n         BAL   R12,PARM10          GO GET USER VALUE\nPARM8D   EQU   *                   EVALUALTE\n         LA    R5,PARMSIZE+3       POINT TO END OF SAVE AREA\n         BAL   R12,NUMB            CONVERT VAUE TO BINARY\n         CLC   PARMSIZE,=F'100'    LESS THAN 100 MEMBERS?\n         BH    PARM8F              NO  -- OK\n         MVC   PARMSIZE,=F'100'    PUT IN MINIMUM VALUE\nPARM8F   EQU   *\n         B     PARM2               AND RETURN\n         SPACE 2\nPARM10   EQU   *                   ISSOLATE VALUE SUPPLIED BY USER\n         LA    R5,5                MAX OF FOUR CHAR + DLM ALLOWED\nPARM10B  EQU   *                   MOVE VALUE TO SAVE AREA\n         CLC   0(1,R3),PARMDLM     DELIMITING VALUE?\n         BE    0(,R12)             YES -- WE NOW HAVE THE VALUE\n         MVC   0(1,R4),0(R3)       MOVE ONE CHAR FROM PARM TO SAVE ARE\n         LA    R4,1(,R4)           BUMP POINTER TO SAVE AREA\n         LA    R3,1(,R3)           UPDATE PARM DATA POINTER\n         BCT   R2,PARM10D          REDUCE REMAINING LEN\n         BR    R12                 RETURN TO CALLER IF EXHAUSTED\nPARM10D  EQU   *\n         BCT   R5,PARM10B          LOOP TIL VALUE IS DONE\n         B     PARM2D              MORE THAN FOUR CHARS IN VALUE\n         SPACE 2\nPARMEND  EQU   *                                                  PAN\n         B     GETM                GET STORAGE FOR WORK AREAS AND TBLS\n         EJECT\nNUMB     EQU   *                   CONVERT PARM VALUE TO BINARY\n* NUMB\n*        R5 - PARM SAVE AREA POINTER AT ENTRY\n*        R9 - LOOP CONTROL\n*        R7    WORK AREA POINTER\n*        R8 - PARM VALUE SAVE ARA POINTER\n*\n*        RETURN WITH BR R12\n***********************************************************************\n         SPACE 2\n         LR    R8,R5               SAVE POINTER TO END OF SAVE ARA\n         SH    R8,=H'3'            POINT TO START OF SAVE AREA\n         LA    R7,FULL+3           POINT TO END OF WORK AREA\n         LA    R9,4                MAX NUMBER OF TIMES THRU LOOP\n         MVC   FULL,=C'0000'       INITIALIZE WORK AREAA\nNUMB2    EQU   *                   MOVE DATA TO WORK AREA(RIGHT JUSTIFY\n         CLI   0(R5),X'00'         DATA CHAR?\n         BE    NUMB2D              NO  -- SKIP TO NEXT COL\n         CLI   0(R5),C'0'          LESS THAN ZERO?\n         BL    PARM2D              YES -- ERROR\n         CLI   0(R5),C'9'          GREATERTHAN NINE\n         BH    PARM2D              YES -- ERROR\n         MVC   0(1,R7),0(R5)       MOVE ONE DATA CHAR\n         BCTR  R7,0                BACKUP WORK AREA POINTER\nNUMB2D   EQU   *\n         BCTR  R5,0                BACKUP SAVE AREA POINTER\n         BCT   R9,NUMB2            CHECK FOUR COLS\n         SPACE\n         PACK  DOUBLE,FULL         CONVERT FROM CHAR TO DECIMAL\n         CVB   R7,DOUBLE           CONVERT DECIMAL TO BINARY\n         ST    R7,0(,R8)           SAVE BINARY VALUE\n         BR    R12                 RETURN TO CALLER\n         EJECT\nGETM     EQU   *                   OBTAIN STORAGE\n* 1 12 BYTE ENTRY NEEDED FOR EACH NEW MEMBER\n*           (8 BYTE MEMBER NAME, 2 BYTE PAGE NUMBER, 2 BYTE FLAGS)\n*\n* 1 12 BYTE ENTRY NEEDED FOR EACH OLD MEMBER\n*           (SAME AS NEW ENTRY)\n*\n*\n* GETM\n*        R2 - PARMSIZE VALUE (ESTIMATED NUMBER OF MEMS)\n*        R3 - GOTTEN STORAGE POINTER\n*\n*        B     NDIR\n***********************************************************************\n         SPACE 2\n         LH    R2,CHGDCB+62        PDS BLKSIZE\n         GETMAIN EU,LV=(R2),A=CHGADDR\n         MVC   CHGADR1,CHGADDR\n         L     R2,CHGADDR\n         AH    R2,CHGDCB+62\n         ST    R2,CHGEND\n         SPACE 2\n         L     R2,PARMSIZE         GET BINARY NUMBER OF MEMBERS\nGETM2    EQU   *                   GET STORAGE FOR NEW OLD AND SEQ\n         MH    R2,=H'24'           12 BYTES FOR NEW - 12 BYTES FOR OLD\nGETM2D   EQU   *                   REQUEST STORAGE\n         GETMAIN EC,LV=(R2),A=NMEM\n         LTR   R15,R15             WAS SOTARAGE AVAILABLE?\n         BZ    GETM4               YES -- CONTINUE\n         WTO   'GETMAIN FAILURE -- RUN IN LARGER REGION'\n         MVC   RETCODE,=F'16'      SET RETURN CODE TO U6\n         B     RETURN              RETURN TO SCP\n         SPACE 3\nGETM4    EQU   *                   DIVIDE STORAGE UP\n         L     R3,PARMSIZE         NUMBER OF ESTIMATED MEMBERS\n         MH    R3,=H'12'           12 BYTES PER MEMBER IN EACH LIST\n         L     R4,NMEM             ADDRESS OF OBTAINED STORAGE\n         AR    R4,R3               END OF FIRST LIST\n         ST    R4,OMEM             START ADDR OF OLD MEMBER LIST\n         EJECT\nGETM6    EQU   *\n******************************************************************\n*        THIS CODE HAS BEEN MOVED FROM THE YALE COMP PGM         *\n******************************************************************\n         GETMAIN VU,LA=MIN,A=STARTADD    GET ALL AVAILABLE STORAGE\n         LM    R0,R2,FOURK         LOAD 4K, START, SIZE\n         SR    R2,R0               SUBTRACT OFF 4K\n         ST    R2,SIZE             UPDATE REGION SIZE\n         AR    R1,R2               LAST USEABLE BYTE\n         ST    R1,HIGHCORE         SAVE FOR LATER\n         SPACE\n         FREEMAIN R,LV=(0),A=(1)   FREE THE 4K DYNAMIC AREA\n         L     R2,STARTADD         STARTADD\n         ST    R2,FIRSTIG          SAVE AS FIRST IGNORE ADDR\n         OPEN  (SYSPRINT,OUTPUT,IGNORE)\n         TM    IGNORE+48,X'10'     DID IGNORE OPEN?\n         BO    GETIG               YES -- GO READ AND STORE\n         MVC   FIRSTIG(8),IGASMS   NO  -- FIRST AND LAST IGNORES\n         ST    R2,LASTIG\n         B     NDIR\nGETIG    GET   IGNORE,(R2)         GET A RECORD\n         LA    R2,80(,R2)          BUMP PONITER\n         B     GETIG               READ TIL END OF FILE\nENDIG    CLOSE (IGNORE)            CLOSE THE DCB\n         ST    R2,LASTIG           SAVE ADDR OF LAST IGNORE REC\n         SPACE 3\n         B     NDIR                GO PROCESS NEW DIRECTORY\n         EJECT\nNDIR     EQU   *                   OPEN AND PROCEES NEW DIRECTORY\n*\n* NDIR\n*        R1 - WORK REG\n*        R2 - LOOP CONTROL (MAX NUMBER OF MEMS)\n*        R3 - POINTER TO NEW DIRECTORY LIST\n*        R4 - DIRECTORY RECORD POINTER IN WORK AREA\n*\n*        BAL   R12,JSORT    SORT ENTRIES IN DESIRED SEQUENCE\n*        B     ODIR\n***********************************************************************\n         RDJFCB (NEWDCB)\n         MVC   NEWDSN,NEWJFCB\n         MVC   NEWVOL,NEWJFCB+118\n         RDJFCB (OLDDCB)\n         MVC   OLDDSN,OLDJFCB\n         MVC   OLDVOL,OLDJFCB+118\n         RDJFCB (CHGDCB)           INITIALIZE CHGJFCB BEFORE 1ST OPEN\n         SPACE 2\n         RDJFCB (NEWDIR,,OLDDIR)   GET JFCB DATA FROM DD STATEMENT\n         OI    NJFCB+52,X'0A'      TURN ON DON'T MERGE DCB TO JFCB BIT\n         OI    OJFCB+52,X'0A'      TURN ON DON'T MERGE DCB TO JFCB BIT\n         MVC   NJFCB+44(8),BLANK   SET MEMBER NAME TO BLANKS\n         MVC   OJFCB+44(8),BLANK   SET MEMBER NAME TO BLANKS\n         OPEN  (NEWDIR,INPUT,OLDDIR,INPUT),TYPE=J\n         SPACE 2\n         L     R2,PARMSIZE         ESTIMATED MEMBER COUNT\n         L     R3,NMEM             POINT TO START OF LIST\nNDIR2    EQU   *                   READ A DIRECTORY BLOCK\n         READ  NDIR2ECB,SF,NEWDIR,DIRWORK\n         CHECK NDIR2ECB            WAIT TIL READ COMPLETES\n         LA    R4,DIRWORK+10       POINT PAST KEY TO FIRST DATA\nNDIR2B   EQU   *                   PROCESS DIRECTORY LBOCK\n         CLC   0(8,R4),=8X'FF'     LOGICAL END OF DATA?\n         BE    NEWDEOD             YES -- TREAT AS PHYSICAL EOD\n         MVC   0(08,R3),0(R4)      MEMBER NAME\n         MVC   8(4,R3),=4X'0000FFFF' PAGE NUM. AND FLAGS\nNDIR2D   EQU   *\n         CLC   DIRWORK(8),0(R4)    AT END OF BLOCK?\n         BNE   NDIR2F              NO  -- UPDATE POINTERS AND CONT.\n         LA    R3,12(,R3)          YES -- POINT TO NEXT NEW MEMBER ENT\n         BCT   R2,NDIR2                   READ NEXT BLOCK\n         B     NDIR2H                     LIST EXCEEDED\n         SPACE\nNDIR2F   EQU   *\n         SR    R1,R1               CLEAR WORK REG\n         IC    R1,11(R4)           GET TYPE BYTE FROM DIRECTRY\n         N     R1,=X'0000001F'     COUNT OF USER HALF WORDS\n         MH    R1,=H'2'            NOW COUNT OF USER BYTES\n         LA    R4,12(R1,R4)        POINT TO LNEXT ENTRY IN BLOCK\n         LA    R3,12(,R3)          NEXT NEW MEMBER ENTRY\n         BCT   R2,NDIR2B           PROCESS NEXT ENTRY IN BLOCK\nNDIR2H   EQU   *                   TOO MANY MEMBERS\n         WTO   'TOO MANY MEMBERS IN JES2 -- PARM=''SIZE=XXX'' NEEDED'\n         MVC   RETCODE,=F'16'      SET RETURN CODE\n         B     RETURN              RETURN TO SCP\n         SPACE 3\nNEWDEOD  EQU   *\n         MVC   0(8,R3),=X'FF'      SET LOGICAL END OF LIST\n         CLOSE (NEWDIR)            CLOSE THE DIRECTORY DCB\n         B     ODIR                PROCESS OLD DIRECTORY\n         EJECT\nODIR     EQU   *                   PROCESS OLD DIRECTORY\n*\n* ODIR\n*        R1 - WORK REG\n*        R2 - LOOP CONTROL (MAX NUMBER OF MEMS)\n*        R3 - POINTER TO OLD DIRECTORYL IST\n*        R4 - DIRECTORY RECORD POINTER IN WORK AREA\n*\n*        B     OPEN1\n***********************************************************************\n         SPACE 2\n         L     R2,PARMSIZE         NUMBER OF ESTIMATED MEMBERS\n         L     R3,OMEM             POINT TO OLD MEMER LIST\nODIR2    EQU   *                   READ A DIRECTORY BLOCK\n         READ ODIR2ECB,SF,OLDDIR,DIRWORK\n         CHECK ODIR2ECB            WAIT TILL READ COMPLETES\n         LA    R4,DIRWORK+10       POINT PAST KEY TO FIRST DATA\nODIR2B   EQU   *\n         CLC   0(8,R4),=8X'FF'     LOGOCAL END OF DATA?\n         BE    OLDDEOD             YES -- SAME AS PYSICAL EOD\n         MVC   0(08,R3),0(R4)      MEMBER NAME\n         MVC   8(4,R3),=4X'0000FFFF' PAGE NUMBER AND FLAGS\nODIR2D   EQU   *\n         CLC   DIRWORK(8),0(R4)    AT END OF BLOCK?\n         BNE   ODIR2F              NO\n         LA    R3,12(,R3)          YES -- POINT TO NEXT OLD ENTRY\n         BCT   R2,ODIR2                   READ NEXT BLOCK\n         B     ODIR2H                     ESTIMATED MEMBERS EXCEEDED\n         SPACE 3\nODIR2F   EQU   *\n         SR    R1,R1               CLEAR WORK REG\n         IC    R1,11(,R4)          GET TYPE BYTE\n         N     R1,=X'0000001F'     ISOLATE USER HALF WORDS\n         MH    R1,=H'2'            NOW USER BYTES\n         LA    R4,12(R1,R4)        POINT TO NEXT DIRECTRY ENTRY\n         LA    R3,12(,R3)          POINT TO NEXT OLD MEMBER ENTRY\n         BCT   R2,ODIR2B           PROCESS NEXT ENTRY\nODIR2H   EQU   *\n         B     NDIR2H\n         SPACE 3\nOLDDEOD  EQU   *                   END OF DATA FOR DIRECTORY\n         MVC   0(8,R3),=X'FF'      LOGICAL END OF DATA\n         CLOSE (OLDDIR)            CLOSE DIRECTORY\n         B     LOOP\n         EJECT\nLOOP     EQU   *                   LOOP THRU DIRECTORIES\n         L     R2,NMEM             R2 POINTS TO NEXT MEMBER IN NEW JES2\n         L     R3,OMEM             R3 POINTS TO NEXT MEMBER IN OLD JES2\nLOOP1    EQU   *                   COMPARE NEW TO OLD\n         CLC   0(8,R2),0(R3)\n         BE    COMPARE             SAME MEMBER NAME IN OLD AND NEW\n         BL    NEWONLY             MEMBER IS ONLY IN NEW JES2\n         BH    OLDONLY             MEMBER IS ONLY IN OLD JES2\n         EJECT\nCOMPARE  EQU   *                   COMPARE OLD AND NEW MEMBERS\n         CLI   0(R2),X'FF'         EQUAL AND X'FF'?\n         BE    DIR                 YES -- TIME TO PRINT DIRECTORY\n         MVC   OLDJFCB+44(8),0(R3) MOVE IN OLD MEMBER NAME\n         MVC   NEWJFCB+44(8),0(R2) MOVE IN NEW MEMBER NAME\n         MVC   CHGJFCB+44(8),0(R2) MOVE IN CHG MEMBER NAME TO CHG PDS\n         MVC   OLDMEM,0(R3)\n         MVC   NEWMEM,0(R3)\n         OI    OLDJFCB+52,X'08'    DONT REWRITE JFCB\n         OI    NEWJFCB+52,X'08'    DONT REWRITE JFCB\n         OI    CHGJFCB+52,X'08'    DONT REWRITE JFCB\n         OI    OLDJFCB+86,X'01'    DATA SET IS MEMBER OF A PDS\n         OI    NEWJFCB+86,X'01'    DATA SET IS MEMBER OF A PDS\n         OI    CHGJFCB+86,X'01'    DATA SET IS MEMBER OF A PDS\n         CLC   PARMPRNT(3),=C'DIR' DIRECTORY ONLY?\n         BE    COMPARE2\n         OPEN  (OLDDCB,,NEWDCB,,CHGDCB,OUTPUT),TYPE=J\n         MVI   CHGFLG,C'0'         TURN OFF CHANGE NOTE/STOW FLAG\n         MVC   CHGADDR,CHGADR1     START AT THE BEGINNING\n         MVC   STOWMEM,0(R2)       MOVE MEMBER NAME TO STOW LIST\n         BAL   R12,PAGE            TOP OF FORM\n         BAL   R12,YALECOMP        GO DO THE COMPARISON\n         MVC   10(2,R2),RC         SAVE RETURN CODE\n         MVC   10(2,R3),RC         SAVE RETURN CODE\nCOMPARE2 EQU   *\n*        CLOSE (OLDDCB,,NEWDCB,,CHGDCB) CLOSE IS DONE BY YALE COMP\n         LA    R2,12(,R2)          POINT TO NEXT NEW MEMBER NAME\n         LA    R3,12(,R3)          POINT TO NEXT OLD MEMBER NAME\n         B     LOOP1               NOW GO CHECK CURRENT STATUS\n         SPACE 3\nNEWONLY  EQU   *                   COMPARE OLD AND NEW MEMBERS\n         MVC   NEWJFCB+44(8),0(R2) MOVE IN NEW MEMBER NAME\n         MVC   CHGJFCB+44(8),0(R2) MOVE IN CHG MEMBER NAME\n         MVC   NEWMEM,0(R2)\n         OI    NEWJFCB+52,X'08'    DONT REWRITE JFCB\n         OI    CHGJFCB+52,X'08'    DONT REWRITE JFCB\n         OI    NEWJFCB+86,X'01'    DATA SET IS A MEMBER OF A PDS\n         OI    CHGJFCB+86,X'01'    DATA SET IS A MEMBER OF A PDS\n         MVC   OLDMEM,=8C'*'       INDICATE NO MEMBER IN OLD JES2\n         CLC   PARMPRNT(3),=C'MEM' DOES USER WANT MEMBERS?\n         BNE   NEWONLY2            NO  -- SKIP YALECOMP\n         OPEN  (NEWDCB),TYPE=J     ADD MEMBER NAMES TO JFCB\n         BAL   R12,PAGE            TOP OF FORM\n         BAL   R12,YALECOMP        YES -- COMPARE WILL LIST NEW\n         MVC   10(2,R2),=X'0005'          NO MATCHING MEMBER\nNEWONLY2 EQU   *\n*        CLOSE (OLDDCB,,NEWDCB)    CLOSE IS DONE BY YALE COMP\n         LA    R2,12(,R2)          POINT TO NEXT NEW MEMBER NAME\n         B     LOOP1               NOW GO CHECK CURRENT STATUS\n         SPACE 3\nOLDONLY  EQU   *                   COMPARE OLD AND NEW MEMBERS\n         MVC   OLDJFCB+44(8),0(R3) MOVE IN OLD MEMBER NAME\n         MVC   CHGJFCB+44(8),0(R3) MOVE IN CHG MEMBER NAME\n         MVC   OLDMEM,0(R3)\n         OI    OLDJFCB+52,X'08'    DONT REWRITE JFCB\n         OI    CHGJFCB+52,X'08'    DONT REWRITE JFCB\n         OI    OLDJFCB+86,X'01'    DATA SET IS MEMBER OF JES2\n         OI    CHGJFCB+86,X'01'    DATA SET IS MEMBER OF JES2\n         MVC   NEWMEM,=8C'*'       INDICATE NO MEMBER IN NEW JES2\n         CLC   PARMPRNT(3),=C'MEM' DOES USER WANT MEMBERS?\n         BNE   OLDONLY2            NO  -- SKIP YALECOMP\n         OPEN  (OLDDCB),TYPE=J     ADD MEMBER NAMES TO JFCB\n         BAL   R12,PAGE            TOP OF FORM\n         BAL   R12,YALECOMP        YES -- COMPARE WILL LIST NEW\n         MVC   10(2,R3),=X'0005'\nOLDONLY2 EQU   *\n*        CLOSE (OLDDCB,,NEWDCB)    CLOSE IS DONE BY YALE COMP\n         LA    R3,12(,R3)          POINT TO NEXT OLD MEMBER NAME\n         B     LOOP1               NOW GO CHECK CURRENT STATUS\n         EJECT\nPAGE     EQU   *                   TOP OF FORM ROUTINE\n         LH    R1,PAGECNT          GET OLD PAGE COUNT\n         LA    R1,1(,R1)           ADD ONE\n         STH   R1,PAGECNT          SAVE FOR NEXT TIME\n         CLC   OLDMEM,=8C'*'       IS THERE AN OLD MEMBER NAME\n         BE    PAGE2               NO  -- DON'T TRY TO SAVE PAGE NO.\n         STH   R1,8(,R3)           YES -- SAVE PAGE NUMBER\nPAGE2    EQU   *\n         CLC   NEWMEM,=8C'*'       IS THERE A NEW MEMBER NAME\n         BE    PAGE4               NO  -- DON'T TRY TO SAVE PAGE NO.\n         STH   R1,8(,R2)           YES -- SAVE PAGE NUMBER\nPAGE4    EQU   *\n         CVD   R1,DOUBLE           CONVERT PAGE NUMBER TO PACKED\n         UNPK  PAGENO,DOUBLE       NOW CHARACTER\n         OI    PAGENO+3,C'0'       NOW FIX SIGN\n         PUT   SYSPRINT,NEWHDG     PRINT NEW JES2 DSN AND MEMBER NAME\n         PUT   SYSPRINT,OLDHDG     PRINT OLD JES2 DSN AND MEMBER NAME\n         ZAP   LINECNT,=P'0'\n         BR    R12                 RETURN TO CALLER\n         EJECT\nDIR      EQU   *                   PRINT DIRECTORY\n         MVC   OLDMEM,=CL8'* OLD *'\n         MVC   NEWMEM,=CL8'* NEW *'\n         BAL   R12,PAGE\n         SPACE 3\n         L     R2,NMEM             LIST OF NEW MEMBERS\n         L     R3,OMEM             LIST OF OLD MEMBERS\nDIR2     EQU   *\n         CLC   0(8,R2),0(R3)       OLD AND NEW MATCH?\n         BE    DIRE                MEMBER IN EACH\n         BL    DIRN                ONLY NEW MEMBER\n         BH    DIRO                ONLY OLD MEMBER\n         SPACE  2\nDIRE     EQU   *                   MEMBER IN EACH\n         CLI   0(R2),X'FF'         BOTH EQUAL AND X'FF'\n         BE    CLOSE               YES -- DIRECTORY IS DONE\n         MVC   DIRLOLD,0(R3)       OLD MEMBER NAME\n         MVC   DIRLNEW,0(R2)       NEW MEMBER NAME\n         LH    R4,8(,R2)           PAGE NUMBER\n         CVD   R4,DOUBLE           CONVERT TO PACKED\n         UNPK  DIRLPGE,DOUBLE      NOW CHARACTER\n         OI    DIRLPGE+3,C'0'      NOW FIX SIGN\n         MVC   DIRLEQ,BLANK\n         MVC   DIRLNEQ,BLANK\n         MVC   DIRLMTCH,BLANK\n         CLI   11(R2),X'00'        EQUAL MATCH\n         BNE   DIRE2               NO\n         MVC   DIRLEQ,=CL8'EQUAL'\n         B     DIRE10\nDIRE2    EQU   *\n         CLI   11(R2),X'04'        NOT EQUAL\n         BNE   DIRE4               NO\n         MVC   DIRLNEQ,=CL9'NOT EQUAL'\n         MVC   CHGJFCB+44(8),0(R2) MOVE MEMBER NAME TO JFCB\n         MVI   CHGJFCB+44,C'@'     CHANGE FIRST CHARACTER\n         OI    CHGJFCB+52,X'08'    DONT REWRITE JFCB\n         OI    CHGJFCB+86,X'01'    DATA SET IS A MEMBER OF A PDS\n         OPEN  (CHGDCB,OUTPUT)\n         LA    R7,109              LENGTH IS ONE RECORD\n         WRITE CHGDECB1,SF,CHGDCB,CHGNOTEQ,(7)\n         CHECK CHGDECB1\n         MVC   STOWMEM,0(R2)       PUT MEMBER NAME IS STOW LIST\n         MVI   STOWMEM,C'@'        INDICATE MIS-MATCHES\n         NOTE  CHGDCB              GET TTR OF FIRST RECORD\n         ST    R1,STOWTTR          SAVE IT\n         STOW  CHGDCB,STOWLIST,A   ADD ENTRY TO DIRECTORY\n         CLOSE (CHGDCB)\n         B     DIRE10\nDIRE4    EQU   *\n         CLI   11(R2),X'05'        NO MATCH\n         BNE   DIRE10\n         MVC   DIRLMTCH,=CL8'NO MATCH'\nDIRE10   EQU   *\n         PUT   SYSPRINT,DIRLINE    PRINT THE LINE\n         MVI   DIRLCC,C' '\n         LA    R2,12(,R2)          NEXT NEW MEMBER\n         LA    R3,12(,R3)          NEWT OLD MEMBER\n         B     DIR2                LOOP TILL DONE\n         EJECT\nDIRN     EQU   *                   MEMBER IN EACH\n         MVC   DIRLOLD,BLANK       OLD MEMBER NAME\n         MVC   DIRLNEW,0(R2)       NEW MEMBER NAME\n         LH    R4,8(,R2)           PAGE NUMBER\n         CVD   R4,DOUBLE           CONVERT TO PACKED\n         UNPK  DIRLPGE,DOUBLE      NOW CHARACTER\n         OI    DIRLPGE+3,C'0'      NOW FIX SIGN\n         MVC   DIRLEQ,BLANK\n         MVC   DIRLNEQ,BLANK\n         MVC   DIRLMTCH,=CL8'NO MATCH'\n         MVC   CHGJFCB+44(8),0(R2) MOVE MEMBER NAME TO JFCB\n         MVI   CHGJFCB+44,C'@'     CHANGE FIRST CHARACTER\n         OI    CHGJFCB+52,X'08'    DONT REWRITE JFCB\n         OI    CHGJFCB+86,X'01'    DATA SET IS A MEMBER OF A PDS\n         OPEN  (CHGDCB,OUTPUT)\n         LA    R7,109              LENGTH IS ONE RECORD\n         WRITE CHGDECB2,SF,CHGDCB,CHGNOOLD,(7)\n         CHECK CHGDECB2\n         MVC   STOWMEM,0(R2)       PUT MEMBER NAME IS STOW LIST\n         MVI   STOWMEM,C'#'        SIGNAL NO MATCHING MEMBER\n         NOTE  CHGDCB              GET TTR OF FIRST RECORD\n         ST    R1,STOWTTR          SAVE IT\n         STOW  CHGDCB,STOWLIST,A   ADD ENTRY TO DIRECTORY\n         CLOSE (CHGDCB)\nDIRN10   EQU   *\n         PUT   SYSPRINT,DIRLINE    PRINT THE LINE\n         MVI   DIRLCC,C' '\n         LA    R2,12(,R2)          NEXT NEW MEMBER\n         B     DIR2                LOOP TILL DONE\n         SPACE 3\nDIRO     EQU   *                   MEMBER IN EACH\n         MVC   DIRLOLD,0(R3)       OLD MEMBER NAME\n         MVC   DIRLNEW,BLANK       NEW MEMBER NAME\n         LH    R4,8(,R3)           PAGE NUMBER\n         CVD   R4,DOUBLE           CONVERT TO PACKED\n         UNPK  DIRLPGE,DOUBLE      NOW CHARACTER\n         OI    DIRLPGE+3,C'0'      NOW FIX SIGN\n         MVC   DIRLEQ,BLANK\n         MVC   DIRLNEQ,BLANK\n         MVC   DIRLMTCH,=CL8'NO MATCH'\n         MVC   CHGJFCB+44(8),0(R3) MOVE MEMBER NAME TO JFCB\n         MVI   CHGJFCB+44,C'@'     CHANGE FIRST CHARACTER\n         OI    CHGJFCB+52,X'08'    DONT REWRITE JFCB\n         OI    CHGJFCB+86,X'01'    DATA SET IS A MEMBER OF A PDS\n         OPEN  (CHGDCB,OUTPUT)\n         LA    R7,109              LENGTH IS ONE RECORD\n         WRITE CHGDECB3,SF,CHGDCB,CHGNONEW,(7)\n         CHECK CHGDECB3\n         MVC   STOWMEM,0(R3)       PUT MEMBER NAME IS STOW LIST\n         MVI   STOWMEM,C'#'        SIGNAL NO MATCHING MEMBER\n         NOTE  CHGDCB              GET TTR OF FIRST RECORD\n         ST    R1,STOWTTR          SAVE IT\n         STOW  CHGDCB,STOWLIST,A   ADD ENTRY TO DIRECTORY\n         CLOSE (CHGDCB)\nDIRO10   EQU   *\n         PUT   SYSPRINT,DIRLINE    PRINT THE LINE\n         MVI   DIRLCC,C' '\n         LA    R3,12(,R3)          NEXT NEW MEMBER\n         B     DIR2                LOOP TILL DONE\n         SPACE 3\nCLOSE    EQU   *\n         CLOSE (SYSPRINT)\n         B     RETURN\n         EJECT\n         LTORG\n         SPACE 3\nBLANK    DC    80C' '\nFULL     DC    F'0'\nDOUBLE   DC    D'0'\nPAGECNT  DC    H'0'\nLINECNT  DC    PL3'0'\nLINEMAX  DC    PL3'50'\n         SPACE 3\nSTOWLIST DS    0F\nSTOWMEM  DS    CL8\nSTOWTTR  DS    F\n         SPACE 3\nCHGFLG   DC    C'0'\nCHGADDR  DC    F'0'                ADDR OF NEXT REC IN WORK AREA\nCHGADR1  DC    F'0'                ADDR OF FIRST REC IN WORK AREA\nCHGEND   DC    F'0'                ADDR OF END OF WORK AREA\n         EJECT\nPARMVALS DS    0F                  PARAM REALTED VALUES\nPARMADDR DC    F'0'                ADDR OF USER PARM\nPARMLEN  DC    F'0'                LEN OF USER PARM\nPARMPRNT DC    F'0'                PRINT NAME ONLY OR ENTIRE MEMBER\nPARMSIZE DC    F'1000'             ESTIMATED NUMBER MEMBERS IN JES2\nPARMTYPE DC    F'0000'             LIBRARY TYPE                   PAN\nPARMDLM  DC    C','                PARM VALUE DELIMITOR\n         SPACE 3\n         EJECT\nNMEM     DC    F'0'                ADDR OF NEW MEMBER LIST\nNMEMS    EQU   NMEM\nOMEM     DC    F'0'                ADDR OF OLD EMMBER LIST\nOMEMS    EQU   OMEM\n         PRINT NOGEN\nOLDDAD1  EQU   *\nOLDDIR   DCB   BLKSIZE=256,DEVD=DA,DSORG=PS,DDNAME=OLD,EXLST=OXLST,    X\n               KEYLEN=8,LRECL=256,MACRF=(R),RECFM=F,EODAD=OLDDEOD\n         SPACE 3\nNEWDAD1  EQU   *\nNEWDIR   DCB   BLKSIZE=256,DEVD=DA,DSORG=PS,DDNAME=NEW,EXLST=NXLST,    X\n               KEYLEN=8,LRECL=256,MACRF=(R),RECFM=F,EODAD=NEWDEOD\n         SPACE 3\nOXLST    DS    0F\n         DC    X'87'\n         DC    AL3(OJFCB)\n         SPACE\nOJFCB    DC    CL176' '\n         SPACE 3\nNXLST    DS    0F\n         DC    X'87'\n         DC    AL3(NJFCB)\n         SPACE\nNJFCB    DC    CL176' '\n         SPACE 3\nOLDXLIST DS    0F\n         DC    X'05'\n         DC    AL3(DCBEXIT)\nOLDXLST2 EQU   *\n         DC    X'87'\n         DC    AL3(OLDJFCB)\n         SPACE\nOLDJFCB  DC    CL176' '\n         SPACE 3\nNEWXLIST DS    0F\n         DC    X'05'\n         DC    AL3(DCBEXIT)\nNEWXLST2 EQU   *\n         DC    X'87'\n         DC    AL3(NEWJFCB)\n         SPACE\nNEWJFCB  DC    CL176' '\n         EJECT\nCHGXLIST DS    0F\n         DC    X'05'\n         DC    AL3(DCBEXIT)\nCHGXLST2 EQU   *\n         DC    X'87'\n         DC    AL3(CHGJFCB)\n         SPACE\nCHGJFCB  DC    CL176' '\n         EJECT\nDIRWORK  DS    CL264               WORK AREA FOR DIRECOTRY BLOCK READS\n         SPACE 3\nMEMBR    DC    CL8' ',C'  '        SAVE AREA FOR MEMBER NAMES\nMEMBR1   DC    CL8' '              SAVE AREA FOR MEMBER NAMES\nMEMBR2   DC    CL8' '              SAVE AREA FOR MEMBER NAMES\nOLDBLKSZ DC    F'0'                BLOCKSIZE FOR OLD JES2\nNEWBLKSZ DC    F'0'                BLOCKSIZE FOR NEW JES2\nOLDBLKA  DC    F'0'                ADDR OF OLD JES2 BUFFER FOR READS\nNEWBLKA  DC    F'0'                ADDR OF NEW BUFFER FOR READS\nNEWBLKE  DC    F'0'                END ADDR FOR NEW BUFFER\nOLDBLKE  DC    F'0'                END OF BUFFER ADDR FOR OLD\n         SPACE 3\nCHGNOTEQ DC    CL109'NOT EQUAL'\nCHGNOOLD DC    CL109'NO OLD MEMBER'\nCHGNONEW DC    CL109'NO NEW MEMBER'\n         EJECT\nNEWHDG   DC    CL109' '\n         ORG   NEWHDG\n         DC    C'1',C'VOL=SER='\nNEWVOL   DC    CL6' ',C'  MEMBER='\nNEWMEM   DC    CL8' ',C'  NEW DSN='\nNEWDSN   DC    CL44' ',C'    PAGE  '\nPAGENO   DC    CL4' '\n         ORG   NEWHDG+109\n         SPACE 3\nOLDHDG   DC    CL109' '\n         ORG   OLDHDG\n         DC    C'0',C'VOL=SER='\nOLDVOL   DC    CL6' ',C'  MEMBER='\nOLDMEM   DC    CL8' ',C'  OLD DSN='\nOLDDSN   DC    CL44' '\n         ORG   OLDHDG+109\n         SPACE 3\nDIRLINE  DC    CL109' '\n         ORG   DIRLINE\nDIRLCC   DC    C'-',C'OLD MEM='\nDIRLOLD  DC    CL8' ',C' PAGE '\nDIRLPGE  DC    CL4' ',C' NEW MEM='\nDIRLNEW  DC    CL8' ',C' '\nDIRLEQ   DC    CL8' ',C' '\nDIRLNEQ  DC    CL9' ',C' '\nDIRLMTCH DC    CL8' ',C' '\n         ORG   DIRLINE+109\n*          DATA SET CBT881     AT LEVEL 003 AS OF 01/31/79\n TITLE 'YALE COMPARE     ---  BRUCE LELAND   ---  VERSION 2.0    '\n*     CMPRSEQ  CSECT\n*\n*   THIS COMPARE PROGRAM ORIGINATED AT YALE UNIVERSITY AND WAS OBTAINED\n*     FROM THE CONNECTICUT BANK AND TRUST COMPANY MODS TAPE (FILE 226)\n*\n*   THIS COMPARE PROGRAM USES ONLY COLUMNS ONE THROUGH 72; THUS, ANY\n*     TWO VERSIONS OF A PROGRAM MAY BE EASILY COMPARED EVEN IF ONE\n*     (OR BOTH) OF THE FILES HAS BEEN RESEQUENCED.  IF NEITHER FILE\n*     HAS BEEN RESEQUENCED, A PARM OF \"FULL\" MAY BE CODED TO REQUEST\n*     THAT ALL EIGHTY COLUMNS BE USED IN THE COMPARISON.  A FACILITY\n*     IS ALSO PROVIDED TO IGNORE TRIVIAL CARD IMAGES (SUCH AS \" EJECT \"\n*     OR \" SPACE 3 \" IN AN ASSEMBLER SOURCE PROGRAM).\n*\n*   THIS PROGRAM USES ALL AVAILABLE CORE IN ITS REGION AFTER OPENING\n*     ITS INPUT/OUTPUT FILES (EXCEPT FOR 4K WHICH IS RELEASED).  THE\n*     OBTAINED CORE AREA IS USED AS A COMPARE BUFFER WHICH IS ONLY\n*     DUMPED (WRITTEN TO SYSPRINT) WHEN IDENTICAL RECORDS (BASED ON\n*     THE FIRST 72 BYTES) ARE FOUND IN THE OLD AND NEW DATA SETS.  IF\n*     THE COMPARE BUFFER OVERFLOWS, THE PROGRAM TERMINATES.  THEREFORE,\n*     IF IT IS SUSPECTED THAT THE TWO DATA SETS MAY BE VERY FAR OUT OF\n*     SYNC, A LARGE REGION SHOULD BE USED.  THE NUMBER OF UNMATCHED\n*     RECORDS THAT CAN BE BUFFERED AT ONE TIME CAN BE CALCULATED FROM\n*     THE EXPRESSION:  (REGION SIZE - 8K - BUFFERS) / 160\n*     AS A GENERAL RULE, 30K IS SUFFICIENT FOR ABOUT 100 UNMATCHED\n*     RECORDS AT A TIME, AND 100K IS SUFFICIENT FOR ABOUT 500 UNMATCHED\n*     RECORDS AT A TIME.\n*\n*   CARD IMAGES OF THE TRIVAL DATA IS INPUT FROM THE IGNORE DDNAME;\n*     IF THE DDCARD IS MISSING, A TABLE OF TRIVIAL DATA FOR ASSEMBLER\n*     SOURCE CODE WILL BE ASSUMED (THIS INCLUDES \" EJECT \", \" SPACE   \"\n*     \" SPACE 1 \", \" SPACE 2 \", \" SPACE 3 \" AND BLANK COMMENT CARDS).\n*\n*\n*\n*   THE PROGRAM FORMAT ON THE CBT MODS TAPE WAS DISASSEMBLED SOURCE; IT\n*     WAS RECOMMENTED, RESYMBOLIZED, REDOCUMENTED AND SLIGHTLY MODIFIED\n*     BY  A. BRUCE LELAND (ABL)  OCTOBER, 1978\n*\n*\n*   JCL:\n*\n*   //STEPNAME   EXEC  PGM=COMPARE,REGION=100K\n*   //OLD        DD    DSN=OLD.SEQ.DSN ....\n*   //NEW        DD    DSN=NEW.SEQ.DSN ....\n*   //SYSPRINT   DD    SYSOUT=A\n*   //IGNORE     DD    *      (OR DUMMY  --  OR OMITTED)\n*     TRIVIAL CARD IMAGES THAT ARE TO BE IGNORED IN THE COMPARISON\n*   /*\n*\n         EJECT\n*        USING CMPRSEQ,R15\n         DS    0D\nYALECOMP EQU   *\n         CLC   PARMPRNT(3),=C'DIR'\n         BE    0(,R12)            USER ONLY WANT DIRECTORY LIST\n         PRINT GEN\n*        SAVE  (14,12),,*\n         STM   R0,R15,SAVE\n*        LR    R11,R13\n*        LA    R13,SAVE\n*        USING SAVE,R13\n*        ST    R13,8(,R11)\n*        ST    R11,4(,R13)\n         B     INIT\nSAVE     DC    18F'0'\n*PARM     L     R1,0(,R1)\n*         CLC   2(4,R1),FULL\n*         BNE   OPEN\n*         MVI   MLENGTH,X'4F'\n*OPEN     OPEN  (NEW,,OLD,,SYSPRINT,OUTPUT,IGNORE)\n*         SPACE\n*         GETMAIN VU,LA=MIN,A=STARTADD      GET ALL AVAILABLE CORE\n*         LM    R0,R2,FOURK                 LOAD 4K, START, SIZE\n*         SR    R2,R0                       SUBTRACT OFF 4K\n*         ST    R2,SIZE                     UPDATE REGION SIZE\n*         AR    R1,R2                       LAST USEABLE BYTE\n*         ST    R1,HIGHCORE                 SAVE FOR LATER\n*         SPACE\n*         FREEMAIN R,LV=(0),A=(1)           FREE THE 4K DYNAMIC AREA\n*         L     R2,STARTADD\n*         ST    R2,FIRSTIG\n*         TM    IGNORE+48,X'10'             IGNORE OPEN?\n*         BO    GETIG                       YES, BRANCH             ABL\n*         MVC   FIRSTIG(8),IGASMS           FIRST AND LAST IGNORES  ABL\n*         B     NOIG                          FOR ASSEMBLER SOURCE  ABL\n*         SPACE\n*GETIG    GET   IGNORE,(2)\n*         LA    R2,80(,R2)\n*         B     GETIG\n*         SPACE\n*ENDIG    CLOSE (IGNORE)\n*         ST    R2,LASTIG                                          ABL\nINIT     EQU   *\n         L     R2,LASTIG           ADDRESS OF GOTTEN BUFFER+ IGNORES\n         L     R3,SIZE             SIZE OF GOTTEN BUFFER\n         S     R3,LASTIG\n         A     R3,STARTADD         SIZE OF BUFFER TO BE CLEARED\n         LA    R8,=F'0'            FULL WORD OF HEX ZERO\n         LA    R9,4                LENGTH OF 2ND OPERAND + FILLER CHAR\n         MVCL  R2,R8\n         L     R2,LASTIG\n         XC    COUNT,COUNT\n         XC    RC,RC\n         ST    R2,LOWOLD                                           ABL\n         ST    R2,HIGHOLD\n         ST    R2,CURROLD\n         LA    R2,80(,R2)\n         ST    R2,LOWNEW\n         ST    R2,HIGHNEW\n         ST    R2,CURRNEW\n         LA    R8,OLDDCB\n         LA    R9,NEWDCB\n         ZAP   OLDCNT,=P'-1'        ALLOW FOR GET ON END OF DATA\n         ZAP   NEWCNT,=P'-1'        ALLOW FOR GET ON END OF DATA\n*\n*    THIS COMPLETES THE PROGRAM INITIALIZATION\n         EJECT\nSWAP     XR    R9,R8\n         XR    R8,R9\n         XR    R9,R8\n         L     R3,CURR(,R9)\n         C     R3,HIGH(,R9)\n         BL    NOINPUT\n         TM    48(R9),X'10'            CURRENT DCB OPEN?\n         BZ    SWAP                    NO, BRANCH (AND SWAP)\n         LA    R1,0(,R9)\n         C     R1,=A(NEWDCB)\n         BE    SWAP2\n         AP    OLDCNT,=P'1'\n         B     SWAP4\nSWAP2    EQU   *\n         AP    NEWCNT,=P'1'\nSWAP4    EQU   *\n         GET   (1)\n         LA    R0,80(,R3)\n         C     R0,HIGHCORE             FIT IN CORE?\n         BH    NOTCORE                 NO, BRANCH\n         MVC   0(80,R3),0(R1)\n         LA    R0,160(,R3)\n         ST    R0,HIGH(,R9)\n         SPACE 2\n*  SEE IF THIS RECORD IS ANYWHERE IN THE OTHER BUFFER\n*\nNOINPUT  L     R2,LOW(,R8)\n         IC    R1,MLENGTH\nNEXT8    C     R2,CURR(,R8)\n         BNL   NO8\n         CLC   0(1,R3),0(R2)\n         EX    R1,*-6\n         BE    FOUND8\n         LA    R2,160(,R2)\n         B     NEXT8\nNO8      LA    R3,160(,R3)          NOT IN THE BUFFER,\n         ST    R3,CURR(,R9)           UPDATE THE CURRENT POINTER\n         B     SWAP\n         SPACE 2\n*    DOES NOT FIT IN THE ALLOCATED CORE\n*\nNOTCORE  BAL   R12,NOTEQUAL               OUTPUT NOT EQUAL MESSAGE\n         CLOSE (NEWDCB,,OLDDCB,,CHGDCB)\n         MVI   RC+1,8                     RETURN CODE 8\n         MVC   BUFFER(35),CORE-1          CORE OVERFLOW MESSAGE\n         MVC   BUFFER+35(74),BUFFER+34    CLEAR THE REMAINDER\n         PUT   SYSPRINT,BUFFER\n         MVI   BUFFER,X'40'\n         B     CORETERM\n         EJECT\n*   RECORD WAS FOUND -- SEE IF IT IS TO BE IGNORED\n*\nFOUND8   CLC   CURR(4,R9),LOW(R9)           RECORDS IN ACTIVE BUFFER?\n         BNE   CHKIG                        YES, CHECK IGNORES\n         ST    R2,CURR(,R8)\n         B     IGEQUAL\nCHKIG    L     R15,FIRSTIG                FIRST IGNORE\nLOOPIG   C     R15,LASTIG                 LAST IGNORE?\n         BNL   NOTIG                      YES, BRANCH\n         CLC   0(1,R3),0(R15)\n         EX    R1,*-6                     AN IGNORE RECORD?\n         BE    NO8                        YES, BRANCH\n         LA    R15,80(,R15)\n         B     LOOPIG                     CHECK ALL IGNORES\n*\nNOTIG    ST    R2,CURR(,R8)               NOT AN IGNORE RECORD\n         BAL   R12,NOTEQUAL               OUTPUT \"NOT EQUAL\"\nIGEQUAL  BAL   R12,INBUFF                 ADD TO COMPARE BUFFER\n         XR    R9,R8\n         XR    R8,R9\n         XR    R9,R8\n         BAL   R12,INBUFF                 ADD TO OTHER BUFFER\n         B     SWAP\n         SPACE 2\n*  END OF FILE (OLD OR NEW)\n*\nEOLDNEW  CLOSE ((9))                      CLOSE THE CURRENT FILE\n         XR    R9,R8\n         XR    R8,R9\n         XR    R9,R8\n         TM    48(R9),X'10'               OTHER FILE STILL OPEN?\n         BNZ   SWAP                       YES, BRANCH\n         CLC   LOWOLD(4),HIGHOLD          BUFFER EMPTY?\n         BNE   *+14                       NO, BRANCH\n         CLC   LOWNEW(4),HIGHNEW          OTHER BUFFER EMPTY TOO?\n         BE    TRIPLE                     YES, QUIT\n         BAL   R12,NOTEQUAL               FLUSH THE CURRENT BUFFERS\n         B     TRIPLE\n         EJECT\n*  TERMINATE -- LIST NUMBER OF UNEQUAL COMPARES\n*\nTRIPLE   EQU   *\n         CLC   CHGADDR,CHGADR1    IS NEXT RECORD THE FIRST RECORD?\n         BE    TR2                YES -- BLOCK IS EMPTY\n         L     R7,CHGADDR         NEXT AVAIL WORK AREA SLOT\n         S     R7,CHGADR1         CALCULATE LENGHT\n         L     R11,CHGADR1        POINT TO START\n         WRITE CHGDECB4,SF,CHGDCB,(11),(7)\n         CHECK CHGDECB4\n         MVC   CHGADDR,CHGADR1     POINT TO START AGAIN\n         CLI   CHGFLG,C'0'         IS THIS THE FIRST BLOCK?\n         BNE   TR2                 NO  -- ALREADY DID NOTE\n         NOTE  CHGDCB              YES -- GET TTR\n         ST    R1,STOWTTR                 SAVE IT\n         MVI   CHGFLG,C'1'                SET FLAG FOR STOW\nTR2      EQU   *\n         CLI   CHGFLG,C'0'         ANY WRITES?\n         BE    TR4                 NO  -- DON'T ADD A MEMBER\n         STOW  CHGDCB,STOWLIST,A   ADD ENTRY TO DIRECTORY\nTR4      EQU   *\n         MVI   BUFFER,C'-'\nCORETERM MVC   BUFFER+1(6),EDCOUNT          EDIT MASK\n         MVC   BUFFER+7(35),BLOCKS          UNEQUAL BLOCKS MESSAGE\n         MVC   BUFFER+42(67),BUFFER+41      BLANK REMAINDER\n         LH    R1,COUNT\n         CVD   R1,DOUBLE\n         ED    BUFFER+1(6),DOUBLE+5\n         PUT   SYSPRINT,BUFFER\n         MVC   BUFFER+7(35),BLANK   CLEAR MESSAGE FROM BUFFER\n         CP    NEWCNT,=P'-1'\n         BNE   CKCNT2\n         ZAP   NEWCNT,=P'0'\nCKCNT2   EQU   *\n         CP    OLDCNT,=P'-1'\n         BNE   CKCNT4\n         ZAP   OLDCNT,=P'0'\nCKCNT4   EQU   *\n         MVI   BUFFER,C'-'\n         MVC   BUFFER+1(6),EDCOUNT          EDIT MASK\n         MVC   BUFFER+7(35),NEWCMSG         UNEQUAL BLOCKS MESSAGE\n         MVC   BUFFER+42(67),BUFFER+41      BLANK REMAINDER\n         ED    BUFFER+1(6),NEWCNT+5\n         PUT   SYSPRINT,BUFFER\n         MVC   BUFFER+7(35),BLANK   CLEAR MESSAGE FROM BUFFER\n         MVI   BUFFER,C' '\n         MVC   BUFFER+1(6),EDCOUNT          EDIT MASK\n         MVC   BUFFER+7(35),OLDCMSG         UNEQUAL BLOCKS MESSAGE\n         MVC   BUFFER+42(67),BUFFER+41      BLANK REMAINDER\n         ED    BUFFER+1(6),OLDCNT+5\n         PUT   SYSPRINT,BUFFER\n         MVC   BUFFER+7(35),BLANK   CLEAR MESSAGE FROM BUFFER\n*        CLOSE (SYSPRINT)           CLOSE IS DONE BY FRONT END\n         LH   R15,RC\n*        L    R13,4(,R13)                                           ABL\n*        RETURN (14,12),RC=(15)                                     ABL\n         LM    R0,R14,SAVE\n         BR    R12\n         SPACE 2\n*  RE-INITIALIZE THE ACTIVE BUFFER -- SLIDE UNUSED RECORDS DOWN\n*\nINBUFF   L     R1,LOW(,R9)\n         L     R2,CURR(,R9)\n         ST    R1,CURR(,R9)\nNXTREC   LA    R2,160(,R2)\n         C     R2,HIGH(,R9)                  FINISHED REINITIALIZING?\n         BNL   REINIT                        YES, BRANCH\n         MVC   0(80,R1),0(R2)\n         LA    R1,160(,R1)\n         B     NXTREC\nREINIT   ST    R1,HIGH(,R9)                  RESET MAXIMUM POINTER\n         BR    R12\n         EJECT\n*     FLUSH OUT THE NON-EQUAL RECORDS\n*\nNOTEQUAL MVI   RC+1,4                  RETURN CODE 4\n         LH    R1,COUNT\n         LA    R1,1(,R1)\n         STH   R1,COUNT\n         MVI   BUFFER,C'-'\n         AP    LINECNT,=P'2'\n         LA    R3,OLDDCB\nMOVES    MVC   BUFFER+9(3),OLDNEW(R3)\n         MVC   BUFFER+98(3),OLDNEW(R3)\n         MVI   BUFFER+7,C'-'\n         MVI   BUFFER+102,C'-'\n         ZAP   NUMBER(3),ZERO\n         L     R5,LOW(,R3)\nFLUSHED  C     R5,CURR(,R3)               IS THIS BUFFER FLUSHED?\n         BNL   GETNEW                     YES, BRANCH\n         MVC   BUFFER+15(80),0(R5)\n         AP    NUMBER(3),ONE\n         MVC   DOUBLE(6),EDMKPAT\n         EDMK  DOUBLE(6),NUMBER\n         LA    R14,DOUBLE+5\n         SR    R14,R1\n         STC   R14,MOVEA+1\n         NOPR  R0\nMOVEA    MVC   BUFFER+103(1),0(R1)\n         LA    R15,BUFFER+104(R14)\n         MVI   0(R15),X'60'\n         LA    R14,1(,R14)\n         STC   R14,MOVEB+1\n         LA    R1,BUFFER+6\n         SR    R1,R14\nMOVEB    MVC   0(1,R1),BUFFER+102\n         PUT   SYSPRINT,BUFFER\n         AP    LINECNT,=P'1'      ADD 1 TO LINE COUNT\n         CP    LINECNT,LINEMAX    TIME TO SKIP?\n         BL    MOVEB1             NOT YET\n         LH    R1,PAGECNT\n         LA    R1,1(,R1)\n         STH   R1,PAGECNT\n         CVD   R1,DOUBLE\n         UNPK  PAGENO,DOUBLE\n         OI    PAGENO+3,C'0'\n         PUT   SYSPRINT,NEWHDG    NEW\n         PUT   SYSPRINT,OLDHDG    OLD\n         ZAP   LINECNT,=P'0'\nMOVEB1   EQU   *\n         L     R7,CHGADDR         NEXT AVAIL WORK AREA SLOT\n         MVC   0(109,R7),BUFFER   MOVE IN THE RECORD\n         LA    R7,109(,R7)        POINT TO NEXT\n         ST    R7,CHGADDR         SAVE FOR NEXT TIME\n         C     R7,CHGEND          DID WE JUST FILL UP A BLOCK?\n         BL    MOVEB2             NO  -- CONTINUE\n         LH    R7,CHGDCB+62       YES -- GET BLOCK LENGTH\n         L     R11,CHGADR1               POINT TO START\n         WRITE CHGDECB5,SF,CHGDCB,(11),(7)\n         CHECK CHGDECB5\n         MVC   CHGADDR,CHGADR1           POINT TO START AGAIN\n         CLI   CHGFLG,C'0'         1ST WRITE?\n         BNE   MOVEB2              NO  -- ALREADY DID STOW\n         NOTE  CHGDCB              GET TTR OF FIRST RECORD\n         ST    R1,STOWTTR          SAVE IT\n         MVI   CHGFLG,C'1'         SET FLAG\nMOVEB2   EQU   *\n         MVI   BUFFER,X'40'\n         LA    R5,160(,R5)\n         B     FLUSHED\n*\nGETNEW   LA    R1,NEWDCB\n         CR    R3,R1                      NEW DONE?\n         BER   R12                        YES, RETURN\n         LR    R3,R1                      NOW SETUP THE NEW BUFFER\n         MVC   BUFFER+1(7),BLANKS\n         MVI   BUFFER+9,C'-'\n         MVC   BUFFER+10(91),BUFFER+9\n         MVC   BUFFER+102(7),BLANKS\n         PUT   SYSPRINT,BUFFER            CENTER LINE OF DASHES\n         MVI   BUFFER,X'40'\n         B     MOVES\n         EJECT\n*        DCB EXIT ROUTINE (USED BY ALL FILES)\n*\nDCBEXIT  LH    R3,62(,R1)                 BLKSIZE\n         LH    R4,82(,R1)                 LRECL\n         SR    R2,R2\n         DR    R2,R4                      BLOCKSIZE/LRECL\n         MR    R2,R4                      BLOCKING*LRECL\n         CR    R3,R4                      BLOCKSIZE >  LRECL?\n         BH    *+10                       YES, BRANCH\n         LR    R3,R4                      MAKE BLKSIZE=LRECL\n         NI    36(R1),X'EF'               TURN OFF BLOCKING\n         STH   R3,62(,R1)                 NEW BLOCKSIZE\n         STH   R3,24(,R1)                 BUFLEN PARAMETER\n         CLI   20(R1),X'00'               BUFNO=0?\n         BNER  R14                        NO, QUIT\n         MVI   20(R1),X'03'               DEFAULT TO 3 BUFFERS\n         BR    R14                         EXIT\n         EJECT\nDUMP     DC    D'0'\n         PRINT NOGEN\nSYSPRINT DCB  LRECL=109,RECFM=FBA,EXLST=EXITDCB,DDNAME=SYSPRINT,       X\n               MACRF=(PM),DSORG=PS\n         SPACE 3\nCHGDCB   DCB  LRECL=109,RECFM=U,EXLST=CHGXLIST,DDNAME=CHANGE,          X\n               MACRF=(W),DSORG=PO,DEVD=DA,BLKSIZE=6213\n         SPACE 3\nIGNORE   DCB  LRECL=80,RECFM=FB,EXLST=EXITDCB,DDNAME=IGNORE,           X\n               EODAD=ENDIG,MACRF=(GM),DSORG=PS\nFIRSTIG  DC    F'0'                     POINTER TO FIRST IGNORE RECORD\nLASTIG   DC    F'0'                     POINTER TO LAST IGNORE RECORD\n         SPACE 3\nOLDDCB   DCB   DEVD=DA,DDNAME=OLD,MACRF=(GL),DSORG=PS,EXLST=OLDXLST2,  X\n               EODAD=EOLDNEW,OPTCD=C\n* OLD    DCB   EXLST=EXITDCB,DDNAME=OLD,                              X\n*              EODAD=EOLDNEW,MACRF=(GL),DSORG=PS,OPTCD=C\nLOWOLD   DC    F'0'                     FIRST OLD RECORD\nHIGHOLD  DC    F'0'                     HIGHEST USED OLD RECORD\nCURROLD  DC    F'0'                     CURRENT OLD RECORD\nOLDLIT   DC    C'OLD'\n         SPACE 3\nNEWDCB   DCB   DEVD=DA,DDNAME=NEW,MACRF=(GL),DSORG=PS,EXLST=NEWXLST2,  X\n               EODAD=EOLDNEW,OPTCD=C\n* NEW    DCB   EXLST=EXITDCB,DDNAME=NEW,                              X\n*              EODAD=EOLDNEW,MACRF=(GL),DSORG=PS,OPTCD=C\nLOWNEW   DC    F'0'                     FIRST NEW RECORD\nHIGHNEW  DC    F'0'                     HIGHEST USED NEW RECORD\nCURRNEW  DC    F'0'                     CURRENT NEW RECORD\nLOW      EQU   LOWNEW-NEWDCB      DISPLACEMENT TO LOWOLD AND LOWNEW\nHIGH     EQU   HIGHNEW-NEWDCB     DISPLACEMENT TO HIGHOLD AND HIGHNEW\nCURR     EQU   CURRNEW-NEWDCB     DISPLACEMENT TO CURROLD AND CURRNEW\nNEWLIT   DC    C'NEW'\nOLDNEW   EQU   NEWLIT-NEWDCB      DISPLACEMENT TO OLD OR NEW LITERAL\n         EJECT\n*OUBLE   DC    D'0'\nEXITDCB  DC    X'85',AL3(DCBEXIT)\nRC       DC    H'0'\nCOUNT    DC    H'0'\nNUMBER   DC    XL3'0'\nMLENGTH  DC    X'4F'               COMPARE LENGTH FOR EACH RECORD\nMIN      DC    F'05120'             MINIMUM CORE TO GETMAIN\nMAX      DC    X'00800000'          MAXIMUM CORE TO GETMAIN\nFOURK    DC    F'04096'             AMOUNT OF CORE TO RELEASE\nSTARTADD DC    F'0'                 BUFFER START ADDRESS\nSIZE     DC    F'0'                 SIZE OF THE BUFFER AREA\nHIGHCORE DC    F'0'                 MAXIMUM BUFFER ADDRESS\nBUFFER   DC    X'004040404040406040000000606060'\n         DC    80X'00',X'606060000000',X'4060404040404040',7X'00'\n*FULL    DC    C'FULL'\nEDCOUNT  DC    X'402020202120'\nEDMKPAT  DC    X'40202020202060'\nCORE     DC    C'CORE OVERFLOW - COMPARE ABANDONED '\nBLOCKS   DC    C' BLOCKS OF COMPARE ERRORS DETECTED '\nNEWCMSG  DC    C' = NEW FILE RECORD COUNT           '\nOLDCMSG  DC    C' = OLD FILE RECORD COUNT           '\nNEWCNT   DC    PL8'0'\nOLDCNT   DC    PL8'0'\nZERO     DC    PL1'0'\nONE      DC    PL1'1'\nBLANKS   DC    C'       '\n*R0       EQU   0\n*R1       EQU   1\n*R2       EQU   2\n*R3       EQU   3\n*R4       EQU   4\n*R5       EQU   5\n*R6       EQU   6\n*R7       EQU   7\n*R8       EQU   8\n*R9       EQU   9\n*R10      EQU   10\n*R11      EQU   11\n*R12      EQU   12\n*R13      EQU   13\n*R14      EQU   14\n*R15      EQU   15\nIGASMS   DC    A(DFTIG,ENDDFTIG)        DEFAULT IGNORE TABLE        ABL\nDFTIG    DC    CL80'         EJECT   '                              ABL\n         DC    CL80'         SPACE   '                              ABL\n         DC    CL80'         SPACE 1 '                              ABL\n         DC    CL80'         SPACE 2 '                              ABL\n         DC    CL80'         SPACE 3 '                              ABL\n         DC    CL80'*                '                              ABL\nENDDFTIG EQU   *                                                    ABL\n         EJECT\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JES2LIST": {"ttr": 1031, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "JES2LIST CSECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 3\n         STM   R14,R12,12(R13)     SAVE THEIR REGS IN THEIR AREA\n         LR    R10,R15             LOAD BASE REG WITH ENTRY ADDR\n         LA    R6,4095(,R10)       LOAD SECOND BASE\n         LA    R6,1(,R6)           WITH PROPER ADDRESS\n         USING JES2LIST,R10,R6     ESTABLISH\n         B     JES2LINK            NOW GO LINK SAVE AREAS\n         SPACE\nJES2PGM  DC    CL8'JES2LIST'       PROGRAM NAME\nJES2DATE DC    CL8'&SYSDATE'       SYSTEMD DATE OF ASSEMBLY\n         DC    CL3' '\nJES2TIME DC    CL5'&SYSTIME'       SYSTEM TIME OF ASSEMBLY\n         SPACE 3\nJES2SAVE DC    9D'0'               SAVE AREA FOR JES2LIST\nRETCODE  DC    F'0'                RETURN CODE\nRETURN   EQU   *\n         CLOSE (CHGMEM,,CHGPDS,,PRINTIN,,PRINTOUT)\n         SPACE\n         L     R15,RETCODE         GET RETURN CODE\n         L     R13,JES2SAVE+4      GET ADDR OF THEIR SAVE AREA\n         L     R14,12(,R13)        RESTORE RETURN ADDR\n         LM    R0,R12,20(R13)      RESTORE R0 THRU R12\n         BR    R14                 RETURN TO CALLER\n         SPACE 2\nJES2LINK LA    R14,JES2SAVE        GET ADDR OF OUR SAVE AREA\n         ST    R14,9(,R13)         SAVE OUR ADDR IN THEIR AREA\n         ST    R13,4(,R14)         SAVE THEIR ADDR IN OUR AREA\n         LR    R13,R14             POINT R13 TO OUR AREA NOW\n         EJECT\nDATA     EQU   *\n         OPEN (CHGMEM,INPUT,CHGPDS,INPUT,PRINTIN,INPUT,PRINTOUT,OUTPUT)\n         SPACE 3\nDATA2    EQU   *\n         BAL   R12,GETREC          GET RECORDS\n         BAL   R12,PUTREC          PUT RECORDS\n         B     DATA2\n         EJECT\nGETREC   EQU   *                   GET RECORDS FROM CHGMEM AND PRINTIN\n         MVC   OUTMSG,BLANKS       CLEAR OLD MESSAGES\n         MVC   CHGMSG,BLANKS\n         CLI   INFLG,X'00'         TIME TO GET A NEW PRINTIN RECORD?\n         BNE   GETREC6             NO  -- DON'T GET ONE NOW\n         GET   PRINTIN,INWRK       YES -- MOVE IT TO INWRK\n         TRT   INSEQ+2(6),DIGET    YES -- IS THERE A SEQUENCE NUMBER?\n         BNZ   GETREC1                    YES\n         TRT   INSEQ(1),ALPHA             IS THERE A ONE CHAR MEM?\n         BZ    GETREC1A                   YES\nGETREC1  EQU   *\n         PUT   PRINTOUT,INWRK             NO  -- JUST PRINT IT\n         B     GETREC\nGETREC1A EQU   *\n         CLI   MEMALPHA,C' '\n         BNE   GETREC1B            DO WE HAVE MEMER ALPHA YET?\n         MVC   MEMALPHA,INSEQ\nGETREC1B EQU   *\n         CLC   MEMALPHA,INSEQ      IS THIS A LINE FROM HASPXXX?\n         BE    GETREC1D            YES -- CONTINUE\n         PUT   PRINTOUT,INWRK      NO  -- JUST PRINT IT\n         B     GETREC\nGETREC1D EQU   *\n         MVI   INFLG,X'01'         SET FLAG\n         MVC   INST,BLANKS         INITIALIZE WORK AREA\n         CLI   INWRK+40,C'+'       MACRO EXPANSION?\n         BE    GETREC6             YES -- DON'T LOOK FOR INSTUCTION\n         CLI   INWRK+41,C'*'       COMMENT\n         BE    GETREC6             YES --DON'T LOOK FOR INSTRUCTION\nGETREC2  EQU   *                   ISOLATE OPERATOR AND OPERAND\n         LA    R2,72               SCAN 72 COLS\n         LA    R3,INST             SAVE INSTRUCTION IN INST WORK AREA\n         LA    R4,INWRK+41         INPUT RECORD\n         LA    R5,9                MAX LENGTH\n         CLI   INWRK+41,C' '       IS THE FIRST CHAR BLANK?\n         BE    GETREC4             YES -- SKIP LABEL LOOP\nGETREC2B EQU   *                   SCAN PAST LABEL\n         CLI   0(R4),C' '          IS THIS THE END OF THE LABEL\n         BE    GETREC4             YES -- SCAN FOR INSTRUCTION\n         BCT   R2,GETREC2D         REDUCE LENGHT REMAINING IN RECORD\n         B     GETREC6             FORMAT WRONG FOR A LABEL\nGETREC2D EQU   *\n         LA    R4,1(,R4)           POINT TO NEXT INPUT COL\n         BCT   R5,GETREC2B\n         B     GETREC6             FORMAT WRONG FOR A LABEL\n         EJECT\nGETREC4  EQU   *                   ISOLATE INSTRUCTION\n         LA    R5,9                NO MORE THAN 8BYTES FOR INST\n         CLI   0(R4),C' '          FIRST NON-BLANK (AFTER LABEL)?\n         BNE   GETREC4B            YES -- START SAVING\n         LA    R4,1(,R4)           NO  -- UPDATE INWRK POINTER\n         BCT   R2,GETREC4                 LOOP TIL FOUND\n         B     GETREC6                    NO INSTRUCTION\nGETREC4B EQU   *\n         CLI   0(R4),C' '          DELIMITING BLANK?\n         BE    GETREC4F            YES -- CHECK INST\n         MVC   0(1,R3),0(R4)       SAVE ONE BYTE OF THE INSTRUCTION\n         BCT   R2,GETREC4D         LENGTH REMAINING\n         MVC   INST,BLANKS         ERASE ANYTHING THAT WAS SAVED\n         B     GETREC6             DIDN'T END BEFORE COL 72\nGETREC4D EQU   *\n         LA    R3,1(,R3)           NEXT BYTE IN SAVE AREA\n         LA    R4,1(,R4)           NEXT BYTE IN INPUT AREA\n         BCT   R5,GETREC4B         LOOP TIL DONE\n         MVC   INST,BLANKS         ERASE ANYTHING THAT WAS SAVED\n         B     GETREC6\nGETREC4F EQU   *\n         CLC   =C'COPY ',INST      IS THIS A COPY REQUEST?\n         BE    GETREC5             YES -- GO GET ITS NAME\n         EJECT\nGETREC4M EQU   *\n         CLI   INST,C'$'           IS THIS A JES2 MACRO\n         BNE   GETREC6             NO  -- JUST A NORMAL INSTRUCTION\n         MVC   FINDNAME,INST       NEW COPY OF INSTRUCTIONNAME\n         MVI   FINDNAME,C'@'       CHARACTER FOR CHANGES\n         FIND  CHGPDS,FINDNAME,D   SEARCH DIRECTORY\n         LTR   R15,R15\n         BNZ   GETREC4O            CHANGE RECORD ISN'T THERE\n         MVC   OUTMSG,=CL12' CHGD MACRO*'\n         PUT   PRINTOUT,INWRK      TELL USER MACRO HAD CHANGES\n         MVI   INFLG,X'00'         NEED A NEW RECORD\n         BR    R12                 AND RETURN\nGETREC4O EQU   *\n         MVI   FINDNAME,C'#'       CHARACTER FOR NO MATCH\n         FIND  CHGPDS,FINDNAME,D   SEARCH DIRECTORY\n         LTR   R15,R15\n         BNZ   GETREC6             MACRO HASN'T CHANGED\n         MVC   OUTMSG,=CL12' NEW MACRO*'\n         PUT   PRINTOUT,INWRK      TELL USER MACRO IS NEW\n         MVI   INFLG,X'00'         NEW A NEW RECORD\n         BR    R12                 AND RETURN\n         EJECT\nGETREC5  EQU   *\n         MVC   COPYNAME,BLANKS     CLEAR WORK AREA\n         LA    R3,COPYNAME         POINT TO WORK AREA\n         LA    R5,9                NO MORE THAN 8 BYTES FOR NAME\nGETREC5A EQU   *\n         CLI   0(R4),C' '          FIRST NON-BLANK (AFTER INST)?\n         BNE   GETREC5B            YES -- START SAVING\n         LA    R4,1(,R4)           NO  -- UPDATE INWRK POINTER\n         BCT   R2,GETREC5A                LOOP TIL FOUND\n         B     GETREC6                    NO INSTRUCTION\nGETREC5B EQU   *\n         CLI   0(R4),C' '          DELIMITING BLANK?\n         BE    GETREC5M            YES -- CHECK INST\n         MVC   0(1,R3),0(R4)       SAVE ONE BYTE OF THE INSTRUCTION\n         BCT   R2,GETREC5D         LENGTH REMAINING\n         MVC   COPYNAME,BLANKS     ERASE ANYTHING THAT WAS SAVED\n         B     GETREC6             DIDN'T END BEFORE COL 72\nGETREC5D EQU   *\n         LA    R3,1(,R3)           NEXT BYTE IN SAVE AREA\n         LA    R4,1(,R4)           NEXT BYTE IN INPUT AREA\n         BCT   R5,GETREC5B         LOOP TIL DONE\n         MVC   COPYNAME,BLANKS     ERASE ANYTHING THAT WAS SAVED\n         B     GETREC6\n         EJECT\nGETREC5M EQU   *\n         MVC   FINDNAME,COPYNAME   NEW COPY OF COPY NAME\n         MVI   FINDNAME,C'@'       CHARACTER FOR CHANGES\n         FIND  CHGPDS,FINDNAME,D   SEARCH DIRECTORY\n         LTR   R15,R15\n         BNZ   GETREC5O            CHANGE RECORD ISN'T THERE\n         MVC   OUTMSG,=CL12' *CHGD COPY**'\n         PUT   PRINTOUT,INWRK      TELL USER MACRO HAD CHANGES\n         MVI   INFLG,X'00'         NEED A NEW RECORD\n         BR    R12                 AND RETURN\nGETREC5O EQU   *\n         MVI   FINDNAME,C'#'       CHARACTER FOR NO MATCH\n         FIND  CHGPDS,FINDNAME,D   SEARCH DIRECTORY\n         LTR   R15,R15\n         BNZ   GETREC6             MACRO HASN'T CHANGED\n         MVC   OUTMSG,=CL12' *NEW  COPY**'\n         PUT   PRINTOUT,INWRK      TELL USER MACRO IS NEW\n         MVI   INFLG,X'00'         NEED NEW RECORD\n         BR    R12                 RETURN\n         EJECT\nGETREC6  EQU   *\n         CLI   CHGFLG,X'00'        TIME TO GET A NEW CHANGE RECORD?\n         BNE   GETREC6B            NO  -- DON'T GET ONE NOW\n         GET   CHGMEM,CHGWRK       YES -- MOVE IT TO CHGWORK\n         CLC   =C'OLD---',CHGWRK+9 IS THIS A RECORD WE WANT\n         BE    GETREC6B            YES -- CONTINUE\n         CLC   =C'NEW---',CHGWRK+9 ONE LAST TRY TO ACCETP\n         BNE   GETREC6             DON'T SAVE UNUSED RECORDS\nGETREC6B EQU   *\n         MVI   CHGFLG,X'01'        SET FLAG\n         BR    R12                 RETURN TO CALLER\n         EJECT\nPUTREC   EQU   *                   PUT RECORDS TO PRINTOUT\n         MVC   OUTMSG,BLANKS       CLEAR MESSAGE AREA\n         MVC   CHGMSG,BLANKS\n         CLC   CHGSEQ,INSEQ        COMPARE SEQUENCE NUMBERS\n         BNH   PUTREC2\n         PUT   PRINTOUT,INWRK      NO CHANGES TO THIS CODE\n         MVI   INFLG,X'00'         NEED A NEW PRINTIN RECORD\n         BR    R12                 ALL DONE WITH THIS CALL\nPUTREC2  EQU   *\n         CLC   =C'OLD---',CHGWRK+9 IS THIS AN OLD RECORD?\n         BNE   PUTREC4             NO  -- MUST BE NEW CODE\nPUTREC2B EQU   *\n         MVC   CHGMSG,=CL12' ***WAS*****'\n         PUT   PRINTOUT,CHGOUT     PRINT THIS OLD RECORD\n         GET   CHGMEM,CHGWRK       GET A NEW RECORD\n         CLC   =C'OLD---',CHGWRK+9 STILL AN OLD RECORD?\n         BE    PUTREC2B            YES -- PRINT THEM ALL\n         MVI   CHGFLG,X'00'        TIME TO READ A NEW CHG RECORD\n         CLC   =C'------',CHGWRK   SEPARATOR RECORD\n         BE    0(,R12)             AS EXPECTED, JUST RETURN\n         MVI   CHGFLG,X'01'        NO  -- RESET READ FLAG\n         BR    R12                        AND RETURN\n         EJECT\nPUTREC4  EQU   *                   NEW CODE\n         CLC   CHGSEQ,INSEQ        SAME SEQ NUMBER?\n         BE    PUTREC4B            YES\n         MVC   CHGMSG,=CL12' *** NEW ***'\n         PUT   PRINTOUT,CHGOUT\nPUTREC4A EQU   *\n         MVI   CHGFLG,X'00'        NEED A NEW CHGMEM\n         BR    R12\n         SPACE\nPUTREC4B EQU   *\n         MVC   OUTMSG,=CL12' *** NEW ***'\n         MVI   INFLG,X'00'         NEED NEW PRINTIN\n         MVI   CHGFLG,X'00'        NEED NEW CHGMEM\n         PUT   PRINTOUT,INWRK      PRINT RECORD\n         BR    R12                 RETURN\n         EJECT\nCHGEOD   EQU   *\n         MVI   CHGFLG,X'FF'\n         MVC   CHGSEQ+1(7),=X'FFFFFFFFFFFFFF'\n         BR    R12\n         EJECT\n         LTORG\n         EJECT\n         PRINT NOGEN\nDCBADDR1 DS    0D\nCHGMEM   DCB   MACRF=(GM),DDNAME=CHGMEM,DSORG=PS,LRECL=109,RECFM=FB,   *\n               EODAD=CHGEOD\n         SPACE\nDCBADDR2 DS    0D\nCHGPDS   DCB   MACRF=(R),DDNAME=CHGPDS,DSORG=PO,LRECL=121,RECFM=FB\n         SPACE\nDCBADDR3 DS    0D\nPRINTIN  DCB   MACRF=(GM),DDNAME=PRINTIN,DSORG=PS,LRECL=121,RECFM=FB,  *\n               EODAD=RETURN\n         SPACE\nDCBADDR4 DS    0D\nPRINTOUT DCB   MACRF=(PM),DDNAME=PRINTOUT,DSORG=PS,LRECL=133,RECFM=FBA\n         SPACE 3\nINFLG    DC    X'00'               PRINTIN FLAG BYTE\n         SPACE\nINWRK    EQU   *                   PRINTIN AND PRINTOUT WORK AREA\n         DC    CL113' '\nINSEQ    DC    CL8' '\nOUTMSG   DC    CL12' '\n         SPACE 3\nCHGFLG   DC    X'00'               CHGMEM FLAG BYTE\n         SPACE\n********************************** NEXT INSTRUCTION MUST PROCEED CHGWRK\nCHGOUT   DC    CL26' '             LINE UP FOR ASSEMBLY LISTING\nCHGWRK   EQU   *                   CHGMEM WORK AREA\n         DC    CL87' '\nCHGSEQ   DC    CL8' '\nCHGMSG   DC    CL12' ',CL8' '\n         SPACE 3\nINST     DC    CL8' '              LAST INSTRUCTION\nCOPYNAME DC    CL8' '              COPY MEMBER NAME\nFINDNAME DC    CL8' '              NAME USED FOR FIND MACRO\n         SPACE 3\nBLANKS   DC    CL80' '\n         SPACE\nMEMALPHA DC     C' '\n         SPACE 3\nDIGET    DC    256X'01'\n         ORG   DIGET+C'0'\n         DC    10X'00'\n         ORG   DIGET+256\n         SPACE\nALPHA    DC    256X'01'\n         ORG   ALPHA+C'A'\n         DC    XL9'00'\n         ORG   ALPHA+C'J'\n         DC    XL9'00'\n         ORG   ALPHA+C'S'\n         DC    XL8'00'\n         ORG   ALPHA+256\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PDSCMPR": {"ttr": 1281, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*          DATA SET CBT1274J   AT LEVEL 002 AS OF 07/20/83\n* CHANGED PARM DEFAULT FROM 1000 TO 9999     AXC-CBT\n         TITLE 'PDS COMPARE PROGRAM -- USE YALE COMPARE PGM LOGIC'\n*\n*   THIS IS AN ENHANCEMENT TO THE YALE COMPARE PROGRAM THAT IS\n*   DISTRIBTED AS FILE 226 ON THE CONN. BANK MODS TAPE.  THE PURPOSE\n*   OF THE ENHANCEMENT IS TO ALLOW THE COMPARE PROGRAM TO PROCESS\n*   TWO PDS FILES RATHER THAN TWO SEQUENTIAL FILES.  THE ORIGINAL\n*   PROGRAM HAS BEEN MODIFIED A LITTLE TO ACCOMODATE THE FRONT\n*   END PDS PROCESSOR.\n*\n*   THE PROGRAM IS SELF CONTAINED;  SIMPLY ASSEMBLE ANDLINK\n*   AND ITS READY TO USE.\n*\n*   THE JCL NEEDED TO EXECUTE THE PROGRAM FOLLOWS:\n*       1) //         EXEC PGM=PDSCMPR,\n*       2) //             PARM='SIZE=NNNN,TYPE=OPT1,PRINT=OPT2'\n*       3) //SYSPRINT DD  SYSOUT=*\n*       4) //NEW      DD  DSN=PDS1,DISP=SHR\n*       5) //OLD      DD  DSN=PDS2,DISP=SHR\n*   WHERE    NNNN IS 3 OR 4 NUMERICS INDICATING AN ESTIMATE OF HOW\n*                 MANY MEMBERS EXIST IN THE PDS WITH THE MOST MEMBERS.\n*                 THE DEFAULT VALUE IS 1000.  IF A VALUE OF LESS THAN\n*                 100 IS SUPPLIED, THE PROGRAM WILL CHANGE THE VALUE\n*                 TO 100.  IF THERE ARE MORE MEMBERS THAN INDICATED\n*                 BY THE SIZE PARAMETER, THE PROGRAM MAY ABEND.\n*\n*            OPT1 IS EITHER 'FULL' OR 'PART'; 'PART' IS THE DEFAULT\n*                 VALUE.  ACTUALLY, IF THE USER PROVIDES ANY VALUE\n*                 OTHER THAN 'FULL', THEN 'PART' WILL BE ASSUMED.\n*                 TYPE=FULL INDICATES THAT ALL 80 COLS OF THE CARD\n*                 IMAGE PDS WILL BE USED IN THE COMPARISON.\n*                 TYPE=PART INDICATES THAT ONLY COLS 1-72 WILL BE\n*                 USED.\n*\n*            OPT2 IS 'MEM', 'DIR', OR 'NAME'; 'NAME' IS THE DEFAULT\n*                 VALUE.  PRINT=MEM INDICATES THAT IF ONE PDS CONTAINS\n*                 A MEMBER, BUT THE OTHER PDS DOES NOT CONTAIN A MEMBER\n*                 WITH THE SAME NAME, THE  ENTIRE MEM WILL BE LISTED.\n*                 PRINT=DIR INDICATES THAT THE COMPARISON OF MEMBERS\n*                 WON'T TAKE PLACE, BUT THE RECAP RPT WILL BE PRODUCED\n*                 TO SHOW WHICH MEMBERS EXISTS IN EACH PDS.  PRINT=NAME\n*                 INDICATES THAT UNMATCHED MEMBERS WILL NOT BE PRINTED\n*                 IN THEIR ENTIRITY, HOWEVER, THEY WILL BE FLAGGED AS\n*                 UNMATCHED ON THE RECAP REPORT.\n*\n*   THE 'NEW' AND 'OLD' DD STATMENTS WILL BE USED TO PROCESS BOTH THE\n*   DIRECTORIES AND MEMBERS OF THE PDS FILES.  MEMBER NAMES SHOULD NOT\n*   BE CODED.  OPEN TYPE=J WILL BE USED TO ACCESS THE MEMBERS.\n*\n*\n*   THE OUTPUT OF THE PROGRAM CONSISTS OF A DETAILED LISTING AND A\n*   RECAP REPORT.  THE DETAILED LISTING SHOWS:\n*      - THE MEMBER NAME, DATA SET NAME, AND VOL/SER OF EACH MEMBER\n*        PROCESSED.\n*      - ANY DIFFERENCES THAT EXIST BETWEEN THE MEMBERS.\n*      - A COUNT OF UNEQUAL BLOCKS OF DATA AS WELL AS THE RECORD COUNTS\n*        FOR EACH MEMBER.\n*   THE RECAP LISTING FORMAT IS:\n*      OLD MEM=XXXXXXXX PAGE NNNN NEW MEM=YYYYYYYY STATUS\n*      THE STATUS MAY BE\n*          - EQUAL           BOTH MEMBERS ARE THE SAME\n*          - NOT EQUAL       THERE ARE DIFFERENCES\n*          - NO MATCH        THE MEMBER EXISTS IN ONLY ONE PDS\n*\n*   WE USE THE PROGRAM TO COMPARE PARMLIB, PROCLIBS, ETC. FROM ONE\n*   CPU TO ANOTHER AND ALSO AS AN AID WHEN INSTALLING NEW SCP RELEASES.\n*\n*   BRENT TOLMAN\n*   TRANSPORTAION MANAGEMENT SERVICES\n*   SALT LAKE CITY, UT\n*\n*\n*\n*\n          EJECT\nPDSCMPR  CSECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 3\n         STM   R14,R12,12(R13)     SAVE THEIR REGS IN THEIR AREA\n         LR    R10,R15             LOAD BASE REG WITH ENTRY ADDR\n         LA    R6,4095(,R10)       LOAD SECOND BASE\n         LA    R6,1(,R6)           WITH PROPER ADDRESS\n         USING PDSCMPR,R10,R6      ESTABLISH ADDRESSABILITY\n         B     PDSLINK             NOW GO LINK SAVE AREAS\n         SPACE\nPDSPGM   DC    CL8'PDSCMPR'        PROGRAM NAME\nPDSDATE  DC    CL8'&SYSDATE'       SYSTEM DATE OF ASSEMBLY\n         DC    CL3' '\nPDSTIME  DC    CL5'&SYSTIME'       SYSTEM TIME OF ASSEMBLY\n         SPACE 2\nPDSSAVE  DC    9D'0'               SAVE AREA FOR PDSCMPR\nRETCODE  DC    F'0'                RETURN CODE\nRETURN   L     R15,RETCODE         GET RETURN CODE\n         L     R13,PDSSAVE+4       GET ADD OF THEIR SAVE AREA\n         L     R14,12(,R13)        RESTORE RETURN ADDRESS\n         LM    R0,R12,20(R13)      RESTORE R0 THRU R12\n         BR    R14                 RETURN TO CALLER\n         SPACE 2\nPDSLINK  LA    R14,PDSSAVE         GET ADDR OF OUR SAVE AREA\n         ST    R14,8(,R13)         SAVE OUR ADDR IN THEIR AREA\n         ST    R13,4(,R14)         SAVE THEIR ADDR IN OUR AREA\n         LR    R13,R14             POINT R13 TO OUR AREA NOW\n         EJECT\nPARM     EQU   *                   PROCESS PARM DATA SUPPLIED BY USER\n* PARM\n*        R1 - SCP POINTER TO PARM AT ENTRY\n*        R2 - PARM LENGTH\n*        R3 - POINTER TO PARM DATA WHILE EVALUATING\n*        R4 - POINTER TO PARM VALUE SAVE AREAS\n*        R5 - LOOP CONTROL AND SAVE AREA POINTER\n*\n*        BAL   R12,NUMB  - CONVERT VALUE TO BINARY\n*        B     GETM\n***********************************************************************\n         L     R1,0(,R1)           POINT TO PARM AREA\n         LH    R2,0(,R1)           GET LENGTH IN R2\n         STM   R1,R2,PARMVALS      SAVE ADDR AND LEN\n         LTR   R2,R2               IS THERE A PARM FROM USER?\n         BZ    PARMEND             NO  -- TAKE DEFAULTS\n         SPACE\n         LA    R3,1(,R1)           IN LOOP R3 POINTS TO DATA\n         LA    R2,1(,R2)           ADJUST LEN FOR 1ST PASS\nPARM2    EQU   *                   EVALUATE NEXT KEYWORD\n         LTR   R2,R2               IS THERE SOME LENGHT LEFT?\n         BNP   PARMEND             NO  -- EVALUATION COMPLETE\n         LA    R3,1(,R3)           POINT TO START OF KEYWORD\n         BCT   R2,PARM2B           REDUCE LEN - BRANCH AT END\n         B     PARMEND\nPARM2B   EQU   *                   DETERMINE WHICH KEYWORD NOW\n         CLC   =C'TYPE=',0(R3)     LIBRARY TYPE SPECIFICATION?    PAN\n         BE    PARM5                                              PAN\n         CLC   =C'PRINT=',0(R3)    RANGE SPECIFICATION?\n         BE    PARM6               YES\n         CLC   =C'SIZE=',0(R3)     SIZE OF PDS?\n         BE    PARM8\n         SPACE\nPARM2D   EQU   *                   INVALID PARAMETER\n         WTO   'INVALID PARM VALUE SPECIFIED -- PROCESSING TERMINATED'\n         MVC   RETCODE,=F'16'      SET RETURN CODE TO 16\n         B     RETURN              RETURN TO SCP\n         SPACE\nPARM5    EQU   *                   LIBRARY TYPE ANALYSIS\n         LA    R3,5(,R3)           POINT PAST KEYWORD\n         SH    R2,=H'5'            KEEP REMAINING LEN ACCURATE\n         MVC   PARMTYPE,=F'0'      INITIALIZE SAVE AREA\n         LA    R4,PARMTYPE         POINT TO SAVE AREA\n         BAL   R12,PARM10          GO GET USER VAUE\n         CLC   PARMTYPE,=C'FULL'   DID USER SPECIFY FULL COMPARE?\n         BNE   PARM2               NO  -- USE DEFAULT VALUE 'PART'\n         MVI   MLENGTH,X'4F'       YES -- SET MOVE LENGTH TO 80\n         B     PARM2               NO FURTHER EVALUATION\n         EJECT\nPARM6    EQU   *                   RANGE PROCESSING\n         LA    R3,6(,R3)           POINT PAST KEYWORD\n         SH    R2,=H'6'            KEEP LEN CORRECT\n         LA    R4,PARMPRNT         POINT TO FIRST SAVE AREA\n         BAL   R12,PARM10          GO GET USER VALUE\n         CLC   PARMPRNT(3),=C'MEM' DID USER SAY TO PRINT ENTIRE MEMBER?\n         BE    PARM6H              YES\n         CLC   PARMPRNT(3),=C'DIR' DID USER SAY TO PRINT DIRECTRY ONLY?\n         BE    PARM6H              YES\n         MVC   PARMPRNT,=C'NAME'   NO -- SET TO NAME ONLY\nPARM6H   EQU   *                   EVALUATE\n         B     PARM2               GO GET NEXT KEYWORD\n         SPACE 2\nPARM8    EQU   *                   SIZE SPECIFICATION\n         LA    R3,5(,R3)           POINT TO VALUE\n         SH    R2,=H'5'            CORRECT REMAINING LEN\n         MVC   PARMSIZE,=F'0'      INITIALIZE SAVE AREA\n         LA    R4,PARMSIZE         POINT TO SAVE AREA\n         BAL   R12,PARM10          GO GET USER VALUE\nPARM8D   EQU   *                   EVALUALTE\n         LA    R5,PARMSIZE+3       POINT TO END OF SAVE AREA\n         BAL   R12,NUMB            CONVERT VAUE TO BINARY\n         CLC   PARMSIZE,=F'100'    LESS THAN 100 MEMBERS?\n         BH    PARM8F              NO  -- OK\n         MVC   PARMSIZE,=F'100'    PUT IN MINIMUM VALUE\nPARM8F   EQU   *\n         B     PARM2               AND RETURN\n         SPACE 2\nPARM10   EQU   *                   ISSOLATE VALUE SUPPLIED BY USER\n         LA    R5,5                MAX OF FOUR CHAR + DLM ALLOWED\nPARM10B  EQU   *                   MOVE VALUE TO SAVE AREA\n         CLC   0(1,R3),PARMDLM     DELIMITING VALUE?\n         BE    0(,R12)             YES -- WE NOW HAVE THE VALUE\n         MVC   0(1,R4),0(R3)       MOVE ONE CHAR FROM PARM TO SAVE ARE\n         LA    R4,1(,R4)           BUMP POINTER TO SAVE AREA\n         LA    R3,1(,R3)           UPDATE PARM DATA POINTER\n         BCT   R2,PARM10D          REDUCE REMAINING LEN\n         BR    R12                 RETURN TO CALLER IF EXHAUSTED\nPARM10D  EQU   *\n         BCT   R5,PARM10B          LOOP TIL VALUE IS DONE\n         B     PARM2D              MORE THAN FOUR CHARS IN VALUE\n         SPACE 2\nPARMEND  EQU   *                                                  PAN\n         B     GETM                GET STORAGE FOR WORK AREAS AND TBLS\n         EJECT\nNUMB     EQU   *                   CONVERT PARM VALUE TO BINARY\n* NUMB\n*        R5 - PARM SAVE AREA POINTER AT ENTRY\n*        R9 - LOOP CONTROL\n*        R7    WORK AREA POINTER\n*        R8 - PARM VALUE SAVE ARA POINTER\n*\n*        RETURN WITH BR R12\n***********************************************************************\n         SPACE 2\n         LR    R8,R5               SAVE POINTER TO END OF SAVE ARA\n         SH    R8,=H'3'            POINT TO START OF SAVE AREA\n         LA    R7,FULL+3           POINT TO END OF WORK AREA\n         LA    R9,4                MAX NUMBER OF TIMES THRU LOOP\n         MVC   FULL,=C'0000'       INITIALIZE WORK AREAA\nNUMB2    EQU   *                   MOVE DATA TO WORK AREA(RIGHT JUSTIFY\n         CLI   0(R5),X'00'         DATA CHAR?\n         BE    NUMB2D              NO  -- SKIP TO NEXT COL\n         CLI   0(R5),C'0'          LESS THAN ZERO?\n         BL    PARM2D              YES -- ERROR\n         CLI   0(R5),C'9'          GREATERTHAN NINE\n         BH    PARM2D              YES -- ERROR\n         MVC   0(1,R7),0(R5)       MOVE ONE DATA CHAR\n         BCTR  R7,0                BACKUP WORK AREA POINTER\nNUMB2D   EQU   *\n         BCTR  R5,0                BACKUP SAVE AREA POINTER\n         BCT   R9,NUMB2            CHECK FOUR COLS\n         SPACE\n         PACK  DOUBLE,FULL         CONVERT FROM CHAR TO DECIMAL\n         CVB   R7,DOUBLE           CONVERT DECIMAL TO BINARY\n         ST    R7,0(,R8)           SAVE BINARY VALUE\n         BR    R12                 RETURN TO CALLER\n         EJECT\nGETM     EQU   *                   OBTAIN STORAGE\n* 1 12 BYTE ENTRY NEEDED FOR EACH NEW MEMBER\n*           (8 BYTE MEMBER NAME, 2 BYTE PAGE NUMBER, 2 BYTE FLAGS)\n*\n* 1 12 BYTE ENTRY NEEDED FOR EACH OLD MEMBER\n*           (SAME AS NEW ENTRY)\n*\n*\n* GETM\n*        R2 - PARMSIZE VALUE (ESTIMATED NUMBER OF MEMS)\n*        R3 - GOTTEN STORAGE POINTER\n*\n*        B     NDIR\n***********************************************************************\n         SPACE 2\n         L     R2,PARMSIZE         GET BINARY NUMBER OF MEMBERS\nGETM2    EQU   *                   GET STORAGE FOR NEW OLD AND SEQ\n         MH    R2,=H'24'           12 BYTES FOR NEW - 12 BYTES FOR OLD\nGETM2D   EQU   *                   REQUEST STORAGE\n         GETMAIN EC,LV=(R2),A=NMEM\n         LTR   R15,R15             WAS SOTARAGE AVAILABLE?\n         BZ    GETM4               YES -- CONTINUE\n         WTO   'GETMAIN FAILURE -- RUN IN LARGER REGION'\n         MVC   RETCODE,=F'16'      SET RETURN CODE TO U6\n         B     RETURN              RETURN TO SCP\n         SPACE 3\nGETM4    EQU   *                   DIVIDE STORAGE UP\n         L     R3,PARMSIZE         NUMBER OF ESTIMATED MEMBERS\n         MH    R3,=H'12'           12 BYTES PER MEMBER IN EACH LIST\n         L     R4,NMEM             ADDRESS OF OBTAINED STORAGE\n         AR    R4,R3               END OF FIRST LIST\n         ST    R4,OMEM             START ADDR OF OLD MEMBER LIST\n         EJECT\nGETM6    EQU   *\n******************************************************************\n*        THIS CODE HAS BEEN MOVED FROM THE YALE COMP PGM         *\n******************************************************************\n         GETMAIN VU,LA=MIN,A=STARTADD    GET ALL AVAILABLE STORAGE\n         LM    R0,R2,FOURK         LOAD 4K, START, SIZE\n         SR    R2,R0               SUBTRACT OFF 4K\n         ST    R2,SIZE             UPDATE REGION SIZE\n         AR    R1,R2               LAST USEABLE BYTE\n         ST    R1,HIGHCORE         SAVE FOR LATER\n         SPACE\n         FREEMAIN R,LV=(0),A=(1)   FREE THE 4K DYNAMIC AREA\n         L     R2,STARTADD         STARTADD\n         ST    R2,FIRSTIG          SAVE AS FIRST IGNORE ADDR\n         OPEN  (SYSPRINT,OUTPUT,IGNORE)\n         TM    IGNORE+48,X'10'     DID IGNORE OPEN?\n         BO    GETIG               YES -- GO READ AND STORE\n         MVC   FIRSTIG(8),IGASMS   NO  -- FIRST AND LAST IGNORES\n         ST    R2,LASTIG\n         B     NDIR\nGETIG    GET   IGNORE,(R2)         GET A RECORD\n         LA    R2,80(,R2)          BUMP PONITER\n         B     GETIG               READ TIL END OF FILE\nENDIG    CLOSE (IGNORE)            CLOSE THE DCB\n         ST    R2,LASTIG           SAVE ADDR OF LAST IGNORE REC\n         SPACE 3\n         B     NDIR                GO PROCESS NEW DIRECTORY\n         EJECT\nNDIR     EQU   *                   OPEN AND PROCEES NEW DIRECTORY\n*\n* NDIR\n*        R1 - WORK REG\n*        R2 - LOOP CONTROL (MAX NUMBER OF MEMS)\n*        R3 - POINTER TO NEW DIRECTORY LIST\n*        R4 - DIRECTORY RECORD POINTER IN WORK AREA\n*\n*        BAL   R12,JSORT    SORT ENTRIES IN DESIRED SEQUENCE\n*        B     ODIR\n***********************************************************************\n         RDJFCB (NEWDCB)\n         MVC   NEWDSN,NEWJFCB\n         MVC   NEWVOL,NEWJFCB+118\n         RDJFCB (OLDDCB)\n         MVC   OLDDSN,OLDJFCB\n         MVC   OLDVOL,OLDJFCB+118\n         SPACE 2\n         RDJFCB (NEWDIR,,OLDDIR)   GET JFCB DATA FROM DD STATEMENT\n         OI    NJFCB+52,X'0A'      TURN ON DON'T MERGE DCB TO JFCB BIT\n         OI    OJFCB+52,X'0A'      TURN ON DON'T MERGE DCB TO JFCB BIT\n         MVC   NJFCB+44(8),BLANK   SET MEMBER NAME TO BLANKS\n         MVC   OJFCB+44(8),BLANK   SET MEMBER NAME TO BLANKS\n         OPEN  (NEWDIR,INPUT,OLDDIR,INPUT),TYPE=J\n         SPACE 2\n         L     R2,PARMSIZE         ESTIMATED MEMBER COUNT\n         L     R3,NMEM             POINT TO START OF LIST\nNDIR2    EQU   *                   READ A DIRECTORY BLOCK\n         READ  NDIR2ECB,SF,NEWDIR,DIRWORK\n         CHECK NDIR2ECB            WAIT TIL READ COMPLETES\n         LA    R4,DIRWORK+10       POINT PAST KEY TO FIRST DATA\nNDIR2B   EQU   *                   PROCESS DIRECTORY LBOCK\n         CLC   0(8,R4),=8X'FF'     LOGICAL END OF DATA?\n         BE    NEWDEOD             YES -- TREAT AS PHYSICAL EOD\n         MVC   0(08,R3),0(R4)      MEMBER NAME\n         MVC   8(4,R3),=4X'0000FFFF' PAGE NUM. AND FLAGS\nNDIR2D   EQU   *\n         CLC   DIRWORK(8),0(R4)    AT END OF BLOCK?\n         BNE   NDIR2F              NO  -- UPDATE POINTERS AND CONT.\n         LA    R3,12(,R3)          YES -- POINT TO NEXT NEW MEMBER ENT\n         BCT   R2,NDIR2                   READ NEXT BLOCK\n         B     NDIR2H                     LIST EXCEEDED\n         SPACE\nNDIR2F   EQU   *\n         SR    R1,R1               CLEAR WORK REG\n         IC    R1,11(R4)           GET TYPE BYTE FROM DIRECTRY\n         N     R1,=X'0000001F'     COUNT OF USER HALF WORDS\n         MH    R1,=H'2'            NOW COUNT OF USER BYTES\n         LA    R4,12(R1,R4)        POINT TO LNEXT ENTRY IN BLOCK\n         LA    R3,12(,R3)          NEXT NEW MEMBER ENTRY\n         BCT   R2,NDIR2B           PROCESS NEXT ENTRY IN BLOCK\nNDIR2H   EQU   *                   TOO MANY MEMBERS\n         WTO   'TOO MANY MEMBERS IN PDS -- PARM=''SIZE=XXX'' NEEDED'\n         MVC   RETCODE,=F'16'      SET RETURN CODE\n         B     RETURN              RETURN TO SCP\n         SPACE 3\nNEWDEOD  EQU   *\n         MVC   0(8,R3),=X'FF'      SET LOGICAL END OF LIST\n         CLOSE (NEWDIR)            CLOSE THE DIRECTORY DCB\n         B     ODIR                PROCESS OLD DIRECTORY\n         EJECT\nODIR     EQU   *                   PROCESS OLD DIRECTORY\n*\n* ODIR\n*        R1 - WORK REG\n*        R2 - LOOP CONTROL (MAX NUMBER OF MEMS)\n*        R3 - POINTER TO OLD DIRECTORYL IST\n*        R4 - DIRECTORY RECORD POINTER IN WORK AREA\n*\n*        B     OPEN1\n***********************************************************************\n         SPACE 2\n         L     R2,PARMSIZE         NUMBER OF ESTIMATED MEMBERS\n         L     R3,OMEM             POINT TO OLD MEMER LIST\nODIR2    EQU   *                   READ A DIRECTORY BLOCK\n         READ ODIR2ECB,SF,OLDDIR,DIRWORK\n         CHECK ODIR2ECB            WAIT TILL READ COMPLETES\n         LA    R4,DIRWORK+10       POINT PAST KEY TO FIRST DATA\nODIR2B   EQU   *\n         CLC   0(8,R4),=8X'FF'     LOGOCAL END OF DATA?\n         BE    OLDDEOD             YES -- SAME AS PYSICAL EOD\n         MVC   0(08,R3),0(R4)      MEMBER NAME\n         MVC   8(4,R3),=4X'0000FFFF' PAGE NUMBER AND FLAGS\nODIR2D   EQU   *\n         CLC   DIRWORK(8),0(R4)    AT END OF BLOCK?\n         BNE   ODIR2F              NO\n         LA    R3,12(,R3)          YES -- POINT TO NEXT OLD ENTRY\n         BCT   R2,ODIR2                   READ NEXT BLOCK\n         B     ODIR2H                     ESTIMATED MEMBERS EXCEEDED\n         SPACE 3\nODIR2F   EQU   *\n         SR    R1,R1               CLEAR WORK REG\n         IC    R1,11(,R4)          GET TYPE BYTE\n         N     R1,=X'0000001F'     ISOLATE USER HALF WORDS\n         MH    R1,=H'2'            NOW USER BYTES\n         LA    R4,12(R1,R4)        POINT TO NEXT DIRECTRY ENTRY\n         LA    R3,12(,R3)          POINT TO NEXT OLD MEMBER ENTRY\n         BCT   R2,ODIR2B           PROCESS NEXT ENTRY\nODIR2H   EQU   *\n         B     NDIR2H\n         SPACE 3\nOLDDEOD  EQU   *                   END OF DATA FOR DIRECTORY\n         MVC   0(8,R3),=X'FF'      LOGICAL END OF DATA\n         CLOSE (OLDDIR)            CLOSE DIRECTORY\n         B     LOOP\n         EJECT\nLOOP     EQU   *                   LOOP THRU DIRECTORIES\n         L     R2,NMEM             R2 POINTS TO NEXT MEMBER IN NEW PDS\n         L     R3,OMEM             R3 POINTS TO NEXT MEMBER IN OLD PDS\nLOOP1    EQU   *                   COMPARE NEW TO OLD\n         CLC   0(8,R2),0(R3)\n         BE    COMPARE             SAME MEMBER NAME IN OLD AND NEW\n         BL    NEWONLY             MEMBER IS ONLY IN NEW PDS\n         BH    OLDONLY             MEMBER IS ONLY IN OLD PDS\n         EJECT\nCOMPARE  EQU   *                   COMPARE OLD AND NEW MEMBERS\n         CLI   0(R2),X'FF'         EQUAL AND X'FF'?\n         BE    DIR                 YES -- TIME TO PRINT DIRECTORY\n         MVC   OLDJFCB+44(8),0(R3) MOVE IN OLD MEMBER NAME\n         MVC   NEWJFCB+44(8),0(R2) MOVE IN NEW MEMBER NAME\n         MVC   OLDMEM,0(R3)\n         MVC   NEWMEM,0(R3)\n         OI    OLDJFCB+52,X'08'    DONT REWRITE JFCB\n         OI    NEWJFCB+52,X'08'    DONT REWRITE JFCB\n         OI    OLDJFCB+86,X'01'    DATA SET IS MEMBER OF PDS\n         OI    NEWJFCB+86,X'01'    DATA SET IS MEMBER OF PDS\n         CLC   PARMPRNT(3),=C'DIR' DIRECTORY ONLY?\n         BE    COMPARE2\n         OPEN  (OLDDCB,,NEWDCB),TYPE=J   ADD MEMBER NAMES TO JFCB\n         BAL   R12,PAGE            TOP OF FORM\n         BAL   R12,YALECOMP        GO DO THE COMPARISON\n         MVC   10(2,R2),RC         SAVE RETURN CODE\n         MVC   10(2,R3),RC         SAVE RETURN CODE\nCOMPARE2 EQU   *\n*        CLOSE (OLDDCB,,NEWDCB)    CLOSE IS DONE BY YALE COMP\n         LA    R2,12(,R2)          POINT TO NEXT NEW MEMBER NAME\n         LA    R3,12(,R3)          POINT TO NEXT OLD MEMBER NAME\n         B     LOOP1               NOW GO CHECK CURRENT STATUS\n         SPACE 3\nNEWONLY  EQU   *                   COMPARE OLD AND NEW MEMBERS\n         MVC   NEWJFCB+44(8),0(R2) MOVE IN NEW MEMBER NAME\n         MVC   NEWMEM,0(R2)\n         OI    NEWJFCB+52,X'08'    DONT REWRITE JFCB\n         OI    NEWJFCB+86,X'01'    DATA SET IS A MEMBER OF PDS\n         MVC   OLDMEM,=8C'*'       INDICATE NO MEMBER IN OLD PDS\n         CLC   PARMPRNT(3),=C'MEM' DOES USER WANT MEMBERS?\n         BNE   NEWONLY2            NO  -- SKIP YALECOMP\n         OPEN  (NEWDCB),TYPE=J     ADD MEMBER NAMES TO JFCB\n         BAL   R12,PAGE            TOP OF FORM\n         BAL   R12,YALECOMP        YES -- COMPARE WILL LIST NEW\n         MVC   10(2,R2),=X'0005'          NO MATCHING MEMBER\nNEWONLY2 EQU   *\n*        CLOSE (OLDDCB,,NEWDCB)    CLOSE IS DONE BY YALE COMP\n         LA    R2,12(,R2)          POINT TO NEXT NEW MEMBER NAME\n         B     LOOP1               NOW GO CHECK CURRENT STATUS\n         SPACE 3\nOLDONLY  EQU   *                   COMPARE OLD AND NEW MEMBERS\n         MVC   OLDJFCB+44(8),0(R3) MOVE IN OLD MEMBER NAME\n         MVC   OLDMEM,0(R3)\n         OI    OLDJFCB+52,X'08'    DONT REWRITE JFCB\n         OI    OLDJFCB+86,X'01'    DATA SET IS MEMBER OF PDS\n         MVC   NEWMEM,=8C'*'       INDICATE NO MEMBER IN NEW PDS\n         CLC   PARMPRNT(3),=C'MEM' DOES USER WANT MEMBERS?\n         BNE   OLDONLY2            NO  -- SKIP YALECOMP\n         OPEN  (OLDDCB),TYPE=J     ADD MEMBER NAMES TO JFCB\n         BAL   R12,PAGE            TOP OF FORM\n         BAL   R12,YALECOMP        YES -- COMPARE WILL LIST NEW\n         MVC   10(2,R3),=X'0005'\nOLDONLY2 EQU   *\n*        CLOSE (OLDDCB,,NEWDCB)    CLOSE IS DONE BY YALE COMP\n         LA    R3,12(,R3)          POINT TO NEXT OLD MEMBER NAME\n         B     LOOP1               NOW GO CHECK CURRENT STATUS\n         EJECT\nPAGE     EQU   *                   TOP OF FORM ROUTINE\n         LH    R1,PAGECNT          GET OLD PAGE COUNT\n         LA    R1,1(,R1)           ADD ONE\n         STH   R1,PAGECNT          SAVE FOR NEXT TIME\n         CLC   OLDMEM,=8C'*'       IS THERE AN OLD MEMBER NAME\n         BE    PAGE2               NO  -- DON'T TRY TO SAVE PAGE NO.\n         STH   R1,8(,R3)           YES -- SAVE PAGE NUMBER\nPAGE2    EQU   *\n         CLC   NEWMEM,=8C'*'       IS THERE A NEW MEMBER NAME\n         BE    PAGE4               NO  -- DON'T TRY TO SAVE PAGE NO.\n         STH   R1,8(,R2)           YES -- SAVE PAGE NUMBER\nPAGE4    EQU   *\n         CVD   R1,DOUBLE           CONVERT PAGE NUMBER TO PACKED\n         UNPK  PAGENO,DOUBLE       NOW CHARACTER\n         OI    PAGENO+3,C'0'       NOW FIX SIGN\n         PUT   SYSPRINT,EJECT      GO TO TOP OF FORM AND PRINT PAGE\n         PUT   SYSPRINT,NEWHDG     PRINT NEW PDS DSN AND MEMBER NAME\n         PUT   SYSPRINT,OLDHDG     PRINT OLD PDS DSN AND MEMBER NAME\n         BR    R12                 RETURN TO CALLER\n         EJECT\nDIR      EQU   *                   PRINT DIRECTORY\n         MVC   OLDMEM,=CL8'* OLD *'\n         MVC   NEWMEM,=CL8'* NEW *'\n         BAL   R12,PAGE\n         SPACE 3\n         L     R2,NMEM             LIST OF NEW MEMBERS\n         L     R3,OMEM             LIST OF OLD MEMBERS\nDIR2     EQU   *\n         CLC   0(8,R2),0(R3)       OLD AND NEW MATCH?\n         BE    DIRE                MEMBER IN EACH\n         BL    DIRN                ONLY NEW MEMBER\n         BH    DIRO                ONLY OLD MEMBER\n         SPACE  2\nDIRE     EQU   *                   MEMBER IN EACH\n         CLI   0(R2),X'FF'         BOTH EQUAL AND X'FF'\n         BE    CLOSE               YES -- DIRECTORY IS DONE\n         MVC   DIRLOLD,0(R3)       OLD MEMBER NAME\n         MVC   DIRLNEW,0(R2)       NEW MEMBER NAME\n         LH    R4,8(,R2)           PAGE NUMBER\n         CVD   R4,DOUBLE           CONVERT TO PACKED\n         UNPK  DIRLPGE,DOUBLE      NOW CHARACTER\n         OI    DIRLPGE+3,C'0'      NOW FIX SIGN\n         MVC   DIRLEQ,BLANK\n         MVC   DIRLNEQ,BLANK\n         MVC   DIRLMTCH,BLANK\n         CLI   11(R2),X'00'        EQUAL MATCH\n         BNE   DIRE2               NO\n         MVC   DIRLEQ,=CL8'EQUAL'\n         B     DIRE10\nDIRE2    EQU   *\n         CLI   11(R2),X'04'        NOT EQUAL\n         BNE   DIRE4               NO\n         MVC   DIRLNEQ,=CL9'NOT EQUAL'\n         B     DIRE10\nDIRE4    EQU   *\n         CLI   11(R2),X'05'        NO MATCH\n         BNE   DIRE10\n         MVC   DIRLMTCH,=CL8'NO MATCH'\nDIRE10   EQU   *\n         PUT   SYSPRINT,DIRLINE    PRINT THE LINE\n         MVI   DIRLCC,C' '\n         LA    R2,12(,R2)          NEXT NEW MEMBER\n         LA    R3,12(,R3)          NEWT OLD MEMBER\n         B     DIR2                LOOP TILL DONE\n         EJECT\nDIRN     EQU   *                   MEMBER IN EACH\n         MVC   DIRLOLD,BLANK       OLD MEMBER NAME\n         MVC   DIRLNEW,0(R2)       NEW MEMBER NAME\n         LH    R4,8(,R2)           PAGE NUMBER\n         CVD   R4,DOUBLE           CONVERT TO PACKED\n         UNPK  DIRLPGE,DOUBLE      NOW CHARACTER\n         OI    DIRLPGE+3,C'0'      NOW FIX SIGN\n         MVC   DIRLEQ,BLANK\n         MVC   DIRLNEQ,BLANK\n         MVC   DIRLMTCH,=CL8'NO MATCH'\nDIRN10   EQU   *\n         PUT   SYSPRINT,DIRLINE    PRINT THE LINE\n         MVI   DIRLCC,C' '\n         LA    R2,12(,R2)          NEXT NEW MEMBER\n         B     DIR2                LOOP TILL DONE\n         SPACE 3\nDIRO     EQU   *                   MEMBER IN EACH\n         MVC   DIRLOLD,0(R3)       OLD MEMBER NAME\n         MVC   DIRLNEW,BLANK       NEW MEMBER NAME\n         LH    R4,8(,R3)           PAGE NUMBER\n         CVD   R4,DOUBLE           CONVERT TO PACKED\n         UNPK  DIRLPGE,DOUBLE      NOW CHARACTER\n         OI    DIRLPGE+3,C'0'      NOW FIX SIGN\n         MVC   DIRLEQ,BLANK\n         MVC   DIRLNEQ,BLANK\n         MVC   DIRLMTCH,=CL8'NO MATCH'\nDIRO10   EQU   *\n         PUT   SYSPRINT,DIRLINE    PRINT THE LINE\n         MVI   DIRLCC,C' '\n         LA    R3,12(,R3)          NEXT NEW MEMBER\n         B     DIR2                LOOP TILL DONE\n         SPACE 3\nCLOSE    EQU   *\n         CLOSE (SYSPRINT)\n         B     RETURN\n         EJECT\n         LTORG\n         SPACE 3\nBLANK    DC    80C' '\nFULL     DC    F'0'\nDOUBLE   DC    D'0'\nPAGECNT  DC    H'0'\n         SPACE 3\n         EJECT\nPARMVALS DS    0F                  PARAM REALTED VALUES\nPARMADDR DC    F'0'                ADDR OF USER PARM\nPARMLEN  DC    F'0'                LEN OF USER PARM\nPARMPRNT DC    F'0'                PRINT NAME ONLY OR ENTIRE MEMBER\n*ARMSIZE DC    F'1000'             ESTIMATED NUMBER MEMBERS IN PDS\nPARMSIZE DC    F'9999'             ESTIMATED NUMBER MEMBERS IN PDS\nPARMTYPE DC    F'0000'             LIBRARY TYPE                   PAN\nPARMDLM  DC    C','                PARM VALUE DELIMITOR\n         SPACE 3\n         EJECT\nNMEM     DC    F'0'                ADDR OF NEW MEMBER LIST\nNMEMS    EQU   NMEM\nOMEM     DC    F'0'                ADDR OF OLD EMMBER LIST\nOMEMS    EQU   OMEM\n         PRINT NOGEN\nOLDDAD1  EQU   *\nOLDDIR   DCB   BLKSIZE=256,DEVD=DA,DSORG=PS,DDNAME=OLD,EXLST=OXLST,    X\n               KEYLEN=8,LRECL=256,MACRF=(R),RECFM=F,EODAD=OLDDEOD\n         SPACE 3\nNEWDAD1  EQU   *\nNEWDIR   DCB   BLKSIZE=256,DEVD=DA,DSORG=PS,DDNAME=NEW,EXLST=NXLST,    X\n               KEYLEN=8,LRECL=256,MACRF=(R),RECFM=F,EODAD=NEWDEOD\n         SPACE 3\nOXLST    DS    0F\n         DC    X'87'\n         DC    AL3(OJFCB)\n         SPACE\nOJFCB    DC    CL176' '\n         SPACE 3\nNXLST    DS    0F\n         DC    X'87'\n         DC    AL3(NJFCB)\n         SPACE\nNJFCB    DC    CL176' '\n         SPACE 3\nOLDXLIST DS    0F\n         DC    X'05'\n         DC    AL3(DCBEXIT)\nOLDXLST2 EQU   *\n         DC    X'87'\n         DC    AL3(OLDJFCB)\n         SPACE\nOLDJFCB  DC    CL176' '\n         SPACE 3\nNEWXLIST DS    0F\n         DC    X'05'\n         DC    AL3(DCBEXIT)\nNEWXLST2 EQU   *\n         DC    X'87'\n         DC    AL3(NEWJFCB)\n         SPACE\nNEWJFCB  DC    CL176' '\n         EJECT\nDIRWORK  DS    CL264               WORK AREA FOR DIRECOTRY BLOCK READS\n         SPACE\nMEMBR    DC    CL8' ',C'  '        SAVE AREA FOR MEMBER NAMES\nMEMBR1   DC    CL8' '              SAVE AREA FOR MEMBER NAMES\nMEMBR2   DC    CL8' '              SAVE AREA FOR MEMBER NAMES\nOLDBLKSZ DC    F'0'                BLOCKSIZE FOR OLD PDS\nNEWBLKSZ DC    F'0'                BLOCKSIZE FOR NEW PDS\nOLDBLKA  DC    F'0'                ADDR OF OLD PDS BUFFER FOR READS\nNEWBLKA  DC    F'0'                ADDR OF NEW BUFFER FOR READS\nNEWBLKE  DC    F'0'                END ADDR FOR NEW BUFFER\nOLDBLKE  DC    F'0'                END OF BUFFER ADDR FOR OLD\n         EJECT\nEJECT    DC    CL109' '\n         ORG   EJECT\n         DC    C'1',C'PAGE  '\nPAGENO   DC    CL4' '\n         ORG   EJECT+109\n         SPACE 2\nNEWHDG   DC    CL109' '\n         ORG   NEWHDG\n         DC    C'-',C'VOL=SER='\nNEWVOL   DC    CL6' ',C'  MEMBER='\nNEWMEM   DC    CL8' ',C'  NEW DSN='\nNEWDSN   DC    CL44' '\n         ORG   NEWHDG+109\n         SPACE 3\nOLDHDG   DC    CL109' '\n         ORG   OLDHDG\n         DC    C'-',C'VOL=SER='\nOLDVOL   DC    CL6' ',C'  MEMBER='\nOLDMEM   DC    CL8' ',C'  OLD DSN='\nOLDDSN   DC    CL44' '\n         ORG   OLDHDG+109\n         SPACE 3\nDIRLINE  DC    CL109' '\n         ORG   DIRLINE\nDIRLCC   DC    C'-',C'OLD MEM='\nDIRLOLD  DC    CL8' ',C' PAGE '\nDIRLPGE  DC    CL4' ',C' NEW MEM='\nDIRLNEW  DC    CL8' ',C' '\nDIRLEQ   DC    CL8' ',C' '\nDIRLNEQ  DC    CL9' ',C' '\nDIRLMTCH DC    CL8' ',C' '\n         ORG   DIRLINE+109\n*          DATA SET CBT881     AT LEVEL 003 AS OF 01/31/79\n TITLE 'YALE COMPARE     ---  BRUCE LELAND   ---  VERSION 2.0    '\n*     CMPRSEQ  CSECT\n*\n*   THIS COMPARE PROGRAM ORIGINATED AT YALE UNIVERSITY AND WAS OBTAINED\n*     FROM THE CONNECTICUT BANK AND TRUST COMPANY MODS TAPE (FILE 226)\n*\n*   THIS COMPARE PROGRAM USES ONLY COLUMNS ONE THROUGH 72; THUS, ANY\n*     TWO VERSIONS OF A PROGRAM MAY BE EASILY COMPARED EVEN IF ONE\n*     (OR BOTH) OF THE FILES HAS BEEN RESEQUENCED.  IF NEITHER FILE\n*     HAS BEEN RESEQUENCED, A PARM OF \"FULL\" MAY BE CODED TO REQUEST\n*     THAT ALL EIGHTY COLUMNS BE USED IN THE COMPARISON.  A FACILITY\n*     IS ALSO PROVIDED TO IGNORE TRIVIAL CARD IMAGES (SUCH AS \" EJECT \"\n*     OR \" SPACE 3 \" IN AN ASSEMBLER SOURCE PROGRAM).\n*\n*   THIS PROGRAM USES ALL AVAILABLE CORE IN ITS REGION AFTER OPENING\n*     ITS INPUT/OUTPUT FILES (EXCEPT FOR 4K WHICH IS RELEASED).  THE\n*     OBTAINED CORE AREA IS USED AS A COMPARE BUFFER WHICH IS ONLY\n*     DUMPED (WRITTEN TO SYSPRINT) WHEN IDENTICAL RECORDS (BASED ON\n*     THE FIRST 72 BYTES) ARE FOUND IN THE OLD AND NEW DATA SETS.  IF\n*     THE COMPARE BUFFER OVERFLOWS, THE PROGRAM TERMINATES.  THEREFORE,\n*     IF IT IS SUSPECTED THAT THE TWO DATA SETS MAY BE VERY FAR OUT OF\n*     SYNC, A LARGE REGION SHOULD BE USED.  THE NUMBER OF UNMATCHED\n*     RECORDS THAT CAN BE BUFFERED AT ONE TIME CAN BE CALCULATED FROM\n*     THE EXPRESSION:  (REGION SIZE - 8K - BUFFERS) / 160\n*     AS A GENERAL RULE, 30K IS SUFFICIENT FOR ABOUT 100 UNMATCHED\n*     RECORDS AT A TIME, AND 100K IS SUFFICIENT FOR ABOUT 500 UNMATCHED\n*     RECORDS AT A TIME.\n*\n*   CARD IMAGES OF THE TRIVAL DATA IS INPUT FROM THE IGNORE DDNAME;\n*     IF THE DDCARD IS MISSING, A TABLE OF TRIVIAL DATA FOR ASSEMBLER\n*     SOURCE CODE WILL BE ASSUMED (THIS INCLUDES \" EJECT \", \" SPACE   \"\n*     \" SPACE 1 \", \" SPACE 2 \", \" SPACE 3 \" AND BLANK COMMENT CARDS).\n*\n*\n*\n*   THE PROGRAM FORMAT ON THE CBT MODS TAPE WAS DISASSEMBLED SOURCE; IT\n*     WAS RECOMMENTED, RESYMBOLIZED, REDOCUMENTED AND SLIGHTLY MODIFIED\n*     BY  A. BRUCE LELAND (ABL)  OCTOBER, 1978\n*\n*\n*   JCL:\n*\n*   //STEPNAME   EXEC  PGM=COMPARE,REGION=100K\n*   //OLD        DD    DSN=OLD.SEQ.DSN ....\n*   //NEW        DD    DSN=NEW.SEQ.DSN ....\n*   //SYSPRINT   DD    SYSOUT=A\n*   //IGNORE     DD    *      (OR DUMMY  --  OR OMITTED)\n*     TRIVIAL CARD IMAGES THAT ARE TO BE IGNORED IN THE COMPARISON\n*   /*\n*\n         EJECT\n*        USING CMPRSEQ,R15\n         DS    0D\nYALECOMP EQU   *\n         CLC   PARMPRNT(3),=C'DIR'\n         BE    0(,R12)            USER ONLY WANT DIRECTORY LIST\n         PRINT GEN\n*        SAVE  (14,12),,*\n         STM   R0,R15,SAVE\n*        LR    R11,R13\n*        LA    R13,SAVE\n*        USING SAVE,R13\n*        ST    R13,8(,R11)\n*        ST    R11,4(,R13)\n         B     INIT\nSAVE     DC    18F'0'\n*PARM     L     R1,0(,R1)\n*         CLC   2(4,R1),FULL\n*         BNE   OPEN\n*         MVI   MLENGTH,X'4F'\n*OPEN     OPEN  (NEW,,OLD,,SYSPRINT,OUTPUT,IGNORE)\n*         SPACE\n*         GETMAIN VU,LA=MIN,A=STARTADD      GET ALL AVAILABLE CORE\n*         LM    R0,R2,FOURK                 LOAD 4K, START, SIZE\n*         SR    R2,R0                       SUBTRACT OFF 4K\n*         ST    R2,SIZE                     UPDATE REGION SIZE\n*         AR    R1,R2                       LAST USEABLE BYTE\n*         ST    R1,HIGHCORE                 SAVE FOR LATER\n*         SPACE\n*         FREEMAIN R,LV=(0),A=(1)           FREE THE 4K DYNAMIC AREA\n*         L     R2,STARTADD\n*         ST    R2,FIRSTIG\n*         TM    IGNORE+48,X'10'             IGNORE OPEN?\n*         BO    GETIG                       YES, BRANCH             ABL\n*         MVC   FIRSTIG(8),IGASMS           FIRST AND LAST IGNORES  ABL\n*         B     NOIG                          FOR ASSEMBLER SOURCE  ABL\n*         SPACE\n*GETIG    GET   IGNORE,(2)\n*         LA    R2,80(,R2)\n*         B     GETIG\n*         SPACE\n*ENDIG    CLOSE (IGNORE)\n*         ST    R2,LASTIG                                          ABL\nINIT     EQU   *\n         L     R2,LASTIG           ADDRESS OF GOTTEN BUFFER+ IGNORES\n         L     R3,SIZE             SIZE OF GOTTEN BUFFER\n         S     R3,LASTIG\n         A     R3,STARTADD         SIZE OF BUFFER TO BE CLEARED\n         LA    R8,=F'0'            FULL WORD OF HEX ZERO\n         LA    R9,4                LENGTH OF 2ND OPERAND + FILLER CHAR\n         MVCL  R2,R8\n         L     R2,LASTIG\n         XC    COUNT,COUNT\n         XC    RC,RC\n         ST    R2,LOWOLD                                           ABL\n         ST    R2,HIGHOLD\n         ST    R2,CURROLD\n         LA    R2,80(,R2)\n         ST    R2,LOWNEW\n         ST    R2,HIGHNEW\n         ST    R2,CURRNEW\n         LA    R8,OLDDCB\n         LA    R9,NEWDCB\n         ZAP   OLDCNT,=P'-1'        ALLOW FOR GET ON END OF DATA\n         ZAP   NEWCNT,=P'-1'        ALLOW FOR GET ON END OF DATA\n*\n*    THIS COMPLETES THE PROGRAM INITIALIZATION\n         EJECT\nSWAP     XR    R9,R8\n         XR    R8,R9\n         XR    R9,R8\n         L     R3,CURR(,R9)\n         C     R3,HIGH(,R9)\n         BL    NOINPUT\n         TM    48(R9),X'10'            CURRENT DCB OPEN?\n         BZ    SWAP                    NO, BRANCH (AND SWAP)\n         LA    R1,0(,R9)\n         C     R1,=A(NEWDCB)\n         BE    SWAP2\n         AP    OLDCNT,=P'1'\n         B     SWAP4\nSWAP2    EQU   *\n         AP    NEWCNT,=P'1'\nSWAP4    EQU   *\n         GET   (1)\n         LA    R0,80(,R3)\n         C     R0,HIGHCORE             FIT IN CORE?\n         BH    NOTCORE                 NO, BRANCH\n         MVC   0(80,R3),0(R1)\n         LA    R0,160(,R3)\n         ST    R0,HIGH(,R9)\n         SPACE 2\n*  SEE IF THIS RECORD IS ANYWHERE IN THE OTHER BUFFER\n*\nNOINPUT  L     R2,LOW(,R8)\n         IC    R1,MLENGTH\nNEXT8    C     R2,CURR(,R8)\n         BNL   NO8\n         CLC   0(1,R3),0(R2)\n         EX    R1,*-6\n         BE    FOUND8\n         LA    R2,160(,R2)\n         B     NEXT8\nNO8      LA    R3,160(,R3)          NOT IN THE BUFFER,\n         ST    R3,CURR(,R9)           UPDATE THE CURRENT POINTER\n         B     SWAP\n         SPACE 2\n*    DOES NOT FIT IN THE ALLOCATED CORE\n*\nNOTCORE  BAL   R12,NOTEQUAL               OUTPUT NOT EQUAL MESSAGE\n         CLOSE (NEWDCB,,OLDDCB)\n         MVI   RC+1,8                     RETURN CODE 8\n         MVC   BUFFER(35),CORE-1          CORE OVERFLOW MESSAGE\n         MVC   BUFFER+35(74),BUFFER+34    CLEAR THE REMAINDER\n         PUT   SYSPRINT,BUFFER\n         MVI   BUFFER,X'40'\n         B     CORETERM\n         EJECT\n*   RECORD WAS FOUND -- SEE IF IT IS TO BE IGNORED\n*\nFOUND8   CLC   CURR(4,R9),LOW(R9)           RECORDS IN ACTIVE BUFFER?\n         BNE   CHKIG                        YES, CHECK IGNORES\n         ST    R2,CURR(,R8)\n         B     IGEQUAL\nCHKIG    L     R15,FIRSTIG                FIRST IGNORE\nLOOPIG   C     R15,LASTIG                 LAST IGNORE?\n         BNL   NOTIG                      YES, BRANCH\n         CLC   0(1,R3),0(R15)\n         EX    R1,*-6                     AN IGNORE RECORD?\n         BE    NO8                        YES, BRANCH\n         LA    R15,80(,R15)\n         B     LOOPIG                     CHECK ALL IGNORES\n*\nNOTIG    ST    R2,CURR(,R8)               NOT AN IGNORE RECORD\n         BAL   R12,NOTEQUAL               OUTPUT \"NOT EQUAL\"\nIGEQUAL  BAL   R12,INBUFF                 ADD TO COMPARE BUFFER\n         XR    R9,R8\n         XR    R8,R9\n         XR    R9,R8\n         BAL   R12,INBUFF                 ADD TO OTHER BUFFER\n         B     SWAP\n         SPACE 2\n*  END OF FILE (OLD OR NEW)\n*\nEOLDNEW  CLOSE ((9))                      CLOSE THE CURRENT FILE\n         XR    R9,R8\n         XR    R8,R9\n         XR    R9,R8\n         TM    48(R9),X'10'               OTHER FILE STILL OPEN?\n         BNZ   SWAP                       YES, BRANCH\n         CLC   LOWOLD(4),HIGHOLD          BUFFER EMPTY?\n         BNE   *+14                       NO, BRANCH\n         CLC   LOWNEW(4),HIGHNEW          OTHER BUFFER EMPTY TOO?\n         BE    TRIPLE                     YES, QUIT\n         BAL   R12,NOTEQUAL               FLUSH THE CURRENT BUFFERS\n         B     TRIPLE\n         EJECT\n*  TERMINATE -- LIST NUMBER OF UNEQUAL COMPARES\n*\nTRIPLE   MVI   BUFFER,C'-'\nCORETERM MVC   BUFFER+1(6),EDCOUNT          EDIT MASK\n         MVC   BUFFER+7(35),BLOCKS          UNEQUAL BLOCKS MESSAGE\n         MVC   BUFFER+42(67),BUFFER+41      BLANK REMAINDER\n         LH    R1,COUNT\n         CVD   R1,DOUBLE\n         ED    BUFFER+1(6),DOUBLE+5\n         PUT   SYSPRINT,BUFFER\n         MVC   BUFFER+7(35),BLANK   CLEAR MESSAGE FROM BUFFER\n         CP    NEWCNT,=P'-1'\n         BNE   CKCNT2\n         ZAP   NEWCNT,=P'0'\nCKCNT2   EQU   *\n         CP    OLDCNT,=P'-1'\n         BNE   CKCNT4\n         ZAP   OLDCNT,=P'0'\nCKCNT4   EQU   *\n         MVI   BUFFER,C'-'\n         MVC   BUFFER+1(6),EDCOUNT          EDIT MASK\n         MVC   BUFFER+7(35),NEWCMSG         UNEQUAL BLOCKS MESSAGE\n         MVC   BUFFER+42(67),BUFFER+41      BLANK REMAINDER\n         ED    BUFFER+1(6),NEWCNT+5\n         PUT   SYSPRINT,BUFFER\n         MVC   BUFFER+7(35),BLANK   CLEAR MESSAGE FROM BUFFER\n         MVI   BUFFER,C' '\n         MVC   BUFFER+1(6),EDCOUNT          EDIT MASK\n         MVC   BUFFER+7(35),OLDCMSG         UNEQUAL BLOCKS MESSAGE\n         MVC   BUFFER+42(67),BUFFER+41      BLANK REMAINDER\n         ED    BUFFER+1(6),OLDCNT+5\n         PUT   SYSPRINT,BUFFER\n         MVC   BUFFER+7(35),BLANK   CLEAR MESSAGE FROM BUFFER\n*        CLOSE (SYSPRINT)           CLOSE IS DONE BY FRONT END\n         LH   R15,RC\n*        L    R13,4(,R13)                                           ABL\n*        RETURN (14,12),RC=(15)                                     ABL\n         LM    R0,R14,SAVE\n         BR    R12\n         SPACE 2\n*  RE-INITIALIZE THE ACTIVE BUFFER -- SLIDE UNUSED RECORDS DOWN\n*\nINBUFF   L     R1,LOW(,R9)\n         L     R2,CURR(,R9)\n         ST    R1,CURR(,R9)\nNXTREC   LA    R2,160(,R2)\n         C     R2,HIGH(,R9)                  FINISHED REINITIALIZING?\n         BNL   REINIT                        YES, BRANCH\n         MVC   0(80,R1),0(R2)\n         LA    R1,160(,R1)\n         B     NXTREC\nREINIT   ST    R1,HIGH(,R9)                  RESET MAXIMUM POINTER\n         BR    R12\n         EJECT\n*     FLUSH OUT THE NON-EQUAL RECORDS\n*\nNOTEQUAL MVI   RC+1,4                  RETURN CODE 4\n         LH    R1,COUNT\n         LA    R1,1(,R1)\n         STH   R1,COUNT\n         MVI   BUFFER,C'-'\n         LA    R3,OLDDCB\nMOVES    MVC   BUFFER+9(3),OLDNEW(R3)\n         MVC   BUFFER+98(3),OLDNEW(R3)\n         MVI   BUFFER+7,C'-'\n         MVI   BUFFER+102,C'-'\n         ZAP   NUMBER(3),ZERO\n         L     R5,LOW(,R3)\nFLUSHED  C     R5,CURR(,R3)               IS THIS BUFFER FLUSHED?\n         BNL   GETNEW                     YES, BRANCH\n         MVC   BUFFER+15(80),0(R5)\n         AP    NUMBER(3),ONE\n         MVC   DOUBLE(6),EDMKPAT\n         EDMK  DOUBLE(6),NUMBER\n         LA    R14,DOUBLE+5\n         SR    R14,R1\n         STC   R14,MOVEA+1\n         NOPR  R0\nMOVEA    MVC   BUFFER+103(1),0(R1)\n         LA    R15,BUFFER+104(R14)\n         MVI   0(R15),X'60'\n         LA    R14,1(,R14)\n         STC   R14,MOVEB+1\n         LA    R1,BUFFER+6\n         SR    R1,R14\nMOVEB    MVC   0(1,R1),BUFFER+102\n         PUT   SYSPRINT,BUFFER\n         MVI   BUFFER,X'40'\n         LA    R5,160(,R5)\n         B     FLUSHED\n*\nGETNEW   LA    R1,NEWDCB\n         CR    R3,R1                      NEW DONE?\n         BER   R12                        YES, RETURN\n         LR    R3,R1                      NOW SETUP THE NEW BUFFER\n         MVC   BUFFER+1(7),BLANKS\n         MVI   BUFFER+9,C'-'\n         MVC   BUFFER+10(91),BUFFER+9\n         MVC   BUFFER+102(7),BLANKS\n         PUT   SYSPRINT,BUFFER            CENTER LINE OF DASHES\n         MVI   BUFFER,X'40'\n         B     MOVES\n         EJECT\n*        DCB EXIT ROUTINE (USED BY ALL FILES)\n*\nDCBEXIT  LH    R3,62(,R1)                 BLKSIZE\n         LH    R4,82(,R1)                 LRECL\n         SR    R2,R2\n         DR    R2,R4                      BLOCKSIZE/LRECL\n         MR    R2,R4                      BLOCKING*LRECL\n         CR    R3,R4                      BLOCKSIZE >  LRECL?\n         BH    *+10                       YES, BRANCH\n         LR    R3,R4                      MAKE BLKSIZE=LRECL\n         NI    36(R1),X'EF'               TURN OFF BLOCKING\n         STH   R3,62(,R1)                 NEW BLOCKSIZE\n         STH   R3,24(,R1)                 BUFLEN PARAMETER\n         CLI   20(R1),X'00'               BUFNO=0?\n         BNER  R14                        NO, QUIT\n         MVI   20(R1),X'03'               DEFAULT TO 3 BUFFERS\n         BR    R14                         EXIT\n         EJECT\nDUMP     DC    D'0'\n         PRINT NOGEN\nSYSPRINT DCB  LRECL=109,RECFM=FBA,EXLST=EXITDCB,DDNAME=SYSPRINT,       X\n               MACRF=(PM),DSORG=PS\n         SPACE 3\nIGNORE   DCB  LRECL=80,RECFM=FB,EXLST=EXITDCB,DDNAME=IGNORE,           X\n               EODAD=ENDIG,MACRF=(GM),DSORG=PS\nFIRSTIG  DC    F'0'                     POINTER TO FIRST IGNORE RECORD\nLASTIG   DC    F'0'                     POINTER TO LAST IGNORE RECORD\n         SPACE 3\nOLDDCB   DCB   DEVD=DA,DDNAME=OLD,MACRF=(GL),DSORG=PS,EXLST=OLDXLST2,  X\n               EODAD=EOLDNEW,OPTCD=C\n* OLD    DCB   EXLST=EXITDCB,DDNAME=OLD,                              X\n*              EODAD=EOLDNEW,MACRF=(GL),DSORG=PS,OPTCD=C\nLOWOLD   DC    F'0'                     FIRST OLD RECORD\nHIGHOLD  DC    F'0'                     HIGHEST USED OLD RECORD\nCURROLD  DC    F'0'                     CURRENT OLD RECORD\nOLDLIT   DC    C'OLD'\n         SPACE 3\nNEWDCB   DCB   DEVD=DA,DDNAME=NEW,MACRF=(GL),DSORG=PS,EXLST=NEWXLST2,  X\n               EODAD=EOLDNEW,OPTCD=C\n* NEW    DCB   EXLST=EXITDCB,DDNAME=NEW,                              X\n*              EODAD=EOLDNEW,MACRF=(GL),DSORG=PS,OPTCD=C\nLOWNEW   DC    F'0'                     FIRST NEW RECORD\nHIGHNEW  DC    F'0'                     HIGHEST USED NEW RECORD\nCURRNEW  DC    F'0'                     CURRENT NEW RECORD\nLOW      EQU   LOWNEW-NEWDCB      DISPLACEMENT TO LOWOLD AND LOWNEW\nHIGH     EQU   HIGHNEW-NEWDCB     DISPLACEMENT TO HIGHOLD AND HIGHNEW\nCURR     EQU   CURRNEW-NEWDCB     DISPLACEMENT TO CURROLD AND CURRNEW\nNEWLIT   DC    C'NEW'\nOLDNEW   EQU   NEWLIT-NEWDCB      DISPLACEMENT TO OLD OR NEW LITERAL\n         EJECT\n*OUBLE   DC    D'0'\nEXITDCB  DC    X'85',AL3(DCBEXIT)\nRC       DC    H'0'\nCOUNT    DC    H'0'\nNUMBER   DC    XL3'0'\nMLENGTH  DC    X'47'               COMPARE LENGTH FOR EACH RECORD\nMIN      DC    F'05120'             MINIMUM CORE TO GETMAIN\n*AX      DC    X'00800000'          MAXIMUM CORE TO GETMAIN\nMAX      DC    X'00100000'  CBT     MAXIMUM CORE TO GETMAIN\nFOURK    DC    F'04096'             AMOUNT OF CORE TO RELEASE\nSTARTADD DC    F'0'                 BUFFER START ADDRESS\nSIZE     DC    F'0'                 SIZE OF THE BUFFER AREA\nHIGHCORE DC    F'0'                 MAXIMUM BUFFER ADDRESS\nBUFFER   DC    X'004040404040406040000000606060'\n         DC    80X'00',X'606060000000',X'4060404040404040',7X'00'\n*FULL    DC    C'FULL'\nEDCOUNT  DC    X'402020202120'\nEDMKPAT  DC    X'40202020202060'\nCORE     DC    C'CORE OVERFLOW - COMPARE ABANDONED '\nBLOCKS   DC    C' BLOCKS OF COMPARE ERRORS DETECTED '\nNEWCMSG  DC    C' = NEW FILE RECORD COUNT           '\nOLDCMSG  DC    C' = OLD FILE RECORD COUNT           '\nNEWCNT   DC    PL8'0'\nOLDCNT   DC    PL8'0'\nZERO     DC    PL1'0'\nONE      DC    PL1'1'\nBLANKS   DC    C'       '\n*R0       EQU   0\n*R1       EQU   1\n*R2       EQU   2\n*R3       EQU   3\n*R4       EQU   4\n*R5       EQU   5\n*R6       EQU   6\n*R7       EQU   7\n*R8       EQU   8\n*R9       EQU   9\n*R10      EQU   10\n*R11      EQU   11\n*R12      EQU   12\n*R13      EQU   13\n*R14      EQU   14\n*R15      EQU   15\nIGASMS   DC    A(DFTIG,ENDDFTIG)        DEFAULT IGNORE TABLE        ABL\nDFTIG    DC    CL80'         EJECT   '                              ABL\n         DC    CL80'         SPACE   '                              ABL\n         DC    CL80'         SPACE 1 '                              ABL\n         DC    CL80'         SPACE 2 '                              ABL\n         DC    CL80'         SPACE 3 '                              ABL\n         DC    CL80'*                '                              ABL\nENDDFTIG EQU   *                                                    ABL\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT045/FILE045.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT045", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}