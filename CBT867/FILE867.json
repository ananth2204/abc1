{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013136000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 117572, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "CBT.V500.FILE867.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE867.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x03\\x01'", "DS1TRBAL": "b'\\xe2\\xfa'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x07_\\x00\\x0b\\x07_\\x00\\x0e\\x00\\x04'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04T\\x005\\x01\\x12\\t\\x0f\\x01\\x12\\t\\x0f\\x13Q\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf4@@@'", "ispf": {"version": "04.84", "flags": 0, "createdate": "2012-03-30T00:00:00", "modifydate": "2012-03-30T13:51:35", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-484"}, "text": "REGULAR CBT TAPE - VERSION 484    FILE:  867\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT484.FILE867\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 5 MEMBERS COUNTED; CUMULATIVE SIZE IS 556 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   03/30/12    13:51:35    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE867": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04T\\x00$\\x01\\x12\\t\\x0f\\x01\\x12\\t\\x0f\\x13Q\\x00,\\x00,\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf4@@@'", "ispf": {"version": "04.84", "flags": 0, "createdate": "2012-03-30T00:00:00", "modifydate": "2012-03-30T13:51:24", "lines": 44, "newlines": 44, "modlines": 0, "user": "CBT-484"}, "text": "//***FILE 867 is from somitcw and contains programs to help in      *   FILE 867\n//*           transporting data files from one system to another.   *   FILE 867\n//*                                                                 *   FILE 867\n//*               email:  somitcw@yahoo.com                         *   FILE 867\n//*                                                                 *   FILE 867\n//*    Programs:                                                    *   FILE 867\n//*                                                                 *   FILE 867\n//*    RDW2VB   - Program which supplies Block Descriptor Words     *   FILE 867\n//*               (BDW's) to a dataset that was FTP'ed from         *   FILE 867\n//*               somewhere else, to properly reconstruct a VB      *   FILE 867\n//*               file from a VB file that was FTP'ed to a PC       *   FILE 867\n//*               previously.                                       *   FILE 867\n//*                                                                 *   FILE 867\n//*               The problem is:  When you ftp a RECFM=VB          *   FILE 867\n//*               data set to a PC as binary the default is         *   FILE 867\n//*               to remove any record indicator.  If               *   FILE 867\n//*               locsite rdw or quote site rdw is                  *   FILE 867\n//*               specified then the RDW is saved but there         *   FILE 867\n//*               is no standard way to return the data to          *   FILE 867\n//*               the main frame and reconstruct a RECFM=VB         *   FILE 867\n//*               data set.                                         *   FILE 867\n//*                                                                 *   FILE 867\n//*               This program will copy the binary data            *   FILE 867\n//*               with RDWs to a RECFM=VB data set.                 *   FILE 867\n//*                                                                 *   FILE 867\n//*    RECU2AWS - This program copies the blocks of a               *   FILE 867\n//*               sequential data set or member to an AWSTAPE       *   FILE 867\n//*               image data set.  It pretends that the input       *   FILE 867\n//*               is RECFM=U whether it is or not to use QSAM       *   FILE 867\n//*               to read blocks of data instead of logical         *   FILE 867\n//*               records.                                          *   FILE 867\n//*                                                                 *   FILE 867\n//*               Note: RECU2AWS may be replaced with a program     *   FILE 867\n//*               DSET2AWS that uses BSAM for input as soon as      *   FILE 867\n//*               I have time.                                      *   FILE 867\n//*                                                                 *   FILE 867\n//*               Override note: I have not written DSET2AWS        *   FILE 867\n//*               but changed this program to also handle           *   FILE 867\n//*               RECFM=FB and RECFM=VB input.                      *   FILE 867\n//*                                                                 *   FILE 867\n//*               Warning: this program is for sequential data,     *   FILE 867\n//*               not a PDS.  Trying to use it on a PDS would       *   FILE 867\n//*               only get the directory.                           *   FILE 867\n//*                                                                 *   FILE 867\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RDW2VB": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x02\\x01\\x12\\t\\x0f\\x01\\x12\\t\\x0f\\x12Q\\x00\\xcc\\x00\\xcc\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-03-30T00:00:00", "modifydate": "2012-03-30T12:51:02", "lines": 204, "newlines": 204, "modlines": 0, "user": "SOMITCW"}, "text": "//HERC01R  JOB (XXXXXXXX,XXXX,1439,9999),RDW2VB-HERC01,\n//             CLASS=A,MSGCLASS=C,\n//             NOTIFY=HERC01,COND=(0,NE)\n//*\n//ASM     EXEC PGM=IFOX00,PARM=(RENT,OBJECT,NODECK,TERM)\n//SYSTERM  DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB\n//*        DD  DISP=SHR,DSN=SYS1.AMODGEN\n//*\nPASS     TITLE 'RDW2VB - - - Convert PC file with RDW to RECFM=VB'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*   The problem is:  When you ftp a RECFM=VB data set to a PC\n* as binary the default is to remove any record indicator.\n* If locsite rdw or quote site rdw is specified then the\n* RDW is saved but there is no standard way to return the\n* data to the main frame and reconstruct a RECFM=VB data set.\n*\n*   This program will copy the binary data with RDWs to a\n* RECFM=VB data set.\n*\n* SYSUT1 is input and will be opened as RECFM=U so that is what\n* it should be.  I could support RECFM=VB but no reason to and\n* that might confuse someone.\n*\n* SYSUT2 is output and will be opened as RECFM=VB and the JCL\n* must specify the LRECL\n*\n* Written: 2008-10-21\n*\n* Blame: somitcw@yahoo.com\n*\n* R13 = Save and work area\n* R12 = Program base register\n* R11 = Location of current record in I/O area\n* R10 = Length of data in the I/O area\n* R9  = Top of 64K windows in I/O area\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nRDW2VB   CSECT ,\n         USING *,R15              Set temporary base register\n         SAVE  (14,12),,'RDW2VB.&SYSDATE..&SYSTIME' Save reg.s\n         DROP  R15                Drop the temporary base register\n         LR    R12,R15            Load this program's base register\n         USING RDW2VB,R12         Give the assembler the new base\n         L     R0,WORKLEN         Load length to GETMAIN\n         GETMAIN R,LV=(0)         Get memory for save and work area\n         XC    0(256,R1),0(R1)    Clear first part of save/work area\n         ST    R1,8(,R13)         Chain old and new save areas\n         ST    R13,4(,R1)         Chain old and new save areas\n         LR    R13,R1             Chain old and new save areas\n         USING WORK,R13           Give the assembler save area base\n         MVC   SYSUT1,UT1DUM      Copy input DCB template to work area\n         MVI   OPENCLOS,X'80'     Initialize OPEN/CLOSE parameter list\n         OPEN  SYSUT1,MF=(E,OPENCLOS)  OPEN the input file\n         MVC   SYSUT2,UT2DUM      Copy output DCB template to work area\n         MVI   OPENCLOS,X'80'     Initialize OPEN/CLOSE parameter list\n         OPEN  (SYSUT2,OUTPUT),MF=(E,OPENCLOS)  OPEN the output file\n*        MVC   SYSUT3,UT3DUM      Copy output DCB template to work area\n*        MVI   OPENCLOS,X'80'     Initialize OPEN/CLOSE parameter list\n*        OPEN  (SYSUT3,OUTPUT),MF=(E,OPENCLOS)  OPEN the trace file\n         LA    R11,IOAREA         Initialize I/O record location\n         SR    R10,R10            Initialize I/O record length in use\n         LR    R9,R11             Find when to slide data in I/O area\n         A     R9,F93304          Find when to slide data in I/O area\n*        MVC   REGS(L'CREGS),CREGS  Put eye-catcher for registers\n*        MVC   REGS+4(L'CREGS),CREGS  Put eye-catcher for registers\nGET      DS    0H\n         LA    R0,0(R10,R11)      Locate where to read a record to\n         GET   SYSUT1,(0)         Read a block from the input file\n         SR    R8,R8              Clear a work register\n         ICM   R8,B'0011',SYSUT1+DCBLRECL-IHADCB  Get length of block\n         AR    R10,R8             Add to length of data in I/O AREA\nPUT      DS    0H\n         C     R10,F4             Insure that we have at least 4 bytes\n         BL    GET                Not 4 bytes, go get more data\n         SR    R7,R7              Clear a work register\n         ICM   R7,B'0011',0(R11)  Load current record length\n* Next instruction is due to a bug in the free IND$FILE v1.1.1 that\n* pads a few binary zeroes on the end of RECFM=U data sets.\n         BZ    EODAD              If no data, go close files\n         CR    R10,R7             See if complete record in memory\n         BL    GET                Not full record, go get more data\n         CLC   2(2,R11),F0        See if RDW bytes 3 and 4 are zero\n         BNE   ABEND1             RDW not valid RECFM=VB so go abend\n*        STM   R7,R6,REGS+8       Store registers for PUT\n*        PUT   SYSUT3,REGS        Trace the registers\n         PUT   SYSUT2,(R11)       Put current record\n         LA    R11,0(R7,R11)      Bump to next record\n         SR    R10,R7             Decrease size of data in I/O area\n         CR    R11,R9             See if above window to slide data\n         BL    PUT                Not above, go PUT next record\n         C     R10,F4             Insure that we have at least 4 bytes\n         BL    GET                Not 4 bytes, don't slide data yet\n         LA    R2,IOAREA          Load address data is going to\n         LR    R3,R10             Load length of output data\n         LR    R4,R11             Load address data is coming from\n         LR    R5,R10             Load length of input data\n         MVCL  R2,R4              Slide data to start of I/O area\n         LA    R11,IOAREA         Load new current record address\n         B     PUT                Go to write the next record\n*\nABEND1   DS    0H\n         WTO   'RDW not valid for RECFM=VB so RDW2VB is abending',     C\n               ROUTCDE=11\n         WTO   'Perhaps data was not uploaded as RECFM=U ?',ROUTCDE=11\n         WTO   'Perhaps data is RECFM=VBS instead of VB ?',ROUTCDE=11\n         ABEND 1234,DUMP          Abend with a dump\n*\nEODAD    DS    0H\n*        MVI   OPENCLOS,X'80'     Initialize OPEN/CLOSE parameter list\n*        CLOSE SYSUT3,MF=(E,OPENCLOS)  Close trace file\n         MVI   OPENCLOS,X'80'     Initialize OPEN/CLOSE parameter list\n         CLOSE SYSUT2,MF=(E,OPENCLOS)  Close output file\n         MVI   OPENCLOS,X'80'     Initialize OPEN/CLOSE parameter list\n         CLOSE SYSUT1,MF=(E,OPENCLOS)  Close input file\n         LR    R1,R13             Save save area address\n         L     R13,4(,R13)        Restore the caller's save area addr.\n         L     R0,WORKLEN         Load length to GETMAIN\n         FREEMAIN R,LV=(0),A=(1)  Free save and work area\n         RETURN (14,12),RC=0      Return to caller\n         DROP   R12,R13           Drop all registers\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Data Control Blocks and Constants\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n         DS    0D                Align DCBs on double word boundary\nUT1DUM   DCB   DDNAME=SYSUT1,DSORG=PS,EODAD=EODAD,MACRF=GM,RECFM=U\nUT1LEN   EQU   *-UT1DUM           Length of input DCB\nUT2DUM   DCB   DDNAME=SYSUT2,DSORG=PS,MACRF=PM,RECFM=VB,BUFNO=1\nUT2LEN   EQU   *-UT2DUM           Length of output DCB\n* UT3DUM   DCB   DDNAME=SYSUT3,DSORG=PS,MACRF=PM,RECFM=F,LRECL=80,    C\n*              BLKSIZE=80,BUFNO=1\n* UT3LEN   EQU   *-UT3DUM           Length of output DCB\n*\nWORKLEN  DC    A(SAVELEN+196608)  Length of WORK DSECT\nF93304   DC    F'93304'           To calculate address to read data to\nF4       DC    F'4'               To compare for minimum LRECL\nF0       DC    F'0'               To compare for valid RDW bytes 3 & 4\n* CREGS    DC    C'REGS'            Constant to find registers\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Register save area and other DSECTs\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 2\nWORK     DSECT ,\nSAVEAREA DS    18F                Register save area\n* REGS     DS    10D                C'REGS' and registers ( 80 bytes )\nOPENCLOS DS    D                  OPEN/CLOSE parameter list\nSYSUT1   DS    XL(UT1LEN)         Will be the input DCB\nSYSUT2   DS    XL(UT2LEN)         Will be the output DCB\n* SYSUT3   DS    XL(UT3LEN)         Will be the trace DCB\nSAVELEN  EQU   *-WORK             Len.of save/work area before I/O area\nIOAREA   DS    D                  Will be 196,608 bytes  ( 192KB ),\n*                                 Which is 64KB times 3\n*\n         DCBD   DSORG=PS,DEVD=DA  DSECT for a sequential DCB\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Register equates\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nR0       EQU   0                  Register equate for register 0\nR1       EQU   1                  Register equate for register 1\nR2       EQU   2                  Register equate for register 2\nR3       EQU   3                  Register equate for register 3\nR4       EQU   4                  Register equate for register 4\nR5       EQU   5                  Register equate for register 5\nR6       EQU   6                  Register equate for register 6\nR7       EQU   7                  Register equate for register 7\nR8       EQU   8                  Register equate for register 8\nR9       EQU   9                  Register equate for register 9\nR10      EQU   10                 Register equate for register 10\nR11      EQU   11                 Register equate for register 11\nR12      EQU   12                 Register equate for register 12\nR13      EQU   13                 Register equate for register 13\nR14      EQU   14                 Register equate for register 14\nR15      EQU   15                 Register equate for register 15\n         END   ,                  The end of the program\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(CYL,(5,5))\n//SYSUT2   DD  UNIT=SYSDA,SPACE=(CYL,(5,5))\n//SYSUT3   DD  UNIT=SYSDA,SPACE=(CYL,(5,5))\n//SYSGO    DD  UNIT=SYSDA,SPACE=(CYL,(5,5)),\n//             DCB=BLKSIZE=3120,DISP=(,PASS)\n//*\n//LKED    EXEC PGM=IEWL,PARM=(TERM,LIST,RENT,REUS,REFR)\n//SYSTERM  DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DISP=(SHR,DELETE),DSN=*.ASM.SYSGO\n//         DD  *\n NAME RDW2VB\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(CYL,(5,5))\n//SYSLMOD  DD  DISP=SHR,DSN=SYS2.LINKLIB\n//*\n//CHECKCC EXEC PGM=IEFBR14\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RDW2VB#": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00V\\x01\\x12\\t\\x0f\\x01\\x12\\t\\x0f\\x12S\\x00\\x15\\x00\\x15\\x00\\x00\\xe2\\xc1\\xd4\\xd7\\xd1\\xc3\\xd3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-03-30T00:00:00", "modifydate": "2012-03-30T12:53:56", "lines": 21, "newlines": 21, "modlines": 0, "user": "SAMPJCL"}, "text": "//HERC01R  JOB (XXXXXXXX,XXXX,1439,9999),RDW2VBJ-HERC01,\n//             CLASS=A,MSGCLASS=C,\n//             NOTIFY=HERC01,COND=(0,NE)\n//*\n//MODDEL  EXEC PGM=IEFBR14\n//MODDEL1  DD  DISP=(MOD,DELETE),DSN=HERC01.MCFDBD.RELOAD,\n//             UNIT=3390,SPACE=(TRK,1)\n//MODDEL2  DD  DISP=(MOD,DELETE),DSN=HERC01.MCFDBD.TRACE,\n//             UNIT=3390,SPACE=(TRK,1)\n//*\n//RDW2VB  EXEC PGM=RDW2VB\n//SYSUT1   DD  DISP=SHR,DSN=HERC01.MCFDBD.UNLOAD\n//SYSUT2   DD  DISP=(,CATLG),DSN=HERC01.MCFDBD.RELOAD,\n//             UNIT=SYSDA,SPACE=(TRK,(600,450),RLSE),\n//             DCB=(DSORG=PS,RECFM=VB,LRECL=1580,BLKSIZE=27998)\n//* SYSUT3   DD  DISP=(,CATLG),DSN=HERC01.MCFDBD.TRACE,\n//*          UNIT=SYSDA,SPACE=(TRK,(600,450),RLSE),\n//*          DCB=(DSORG=PS,RECFM=F,LRECL=80,BLKSIZE=80)\n//SYSUDUMP DD  SYSOUT=*\n//*\n//CHECKCC EXEC PGM=IEFBR14\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RECU2AWS": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x12\\t\\x0f\\x01\\x12\\t\\x0f\\x13\\x03\\x01\\x13\\x01\\x13\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-03-30T00:00:00", "modifydate": "2012-03-30T13:03:54", "lines": 275, "newlines": 275, "modlines": 0, "user": "SOMITCW"}, "text": "//HERC01R  JOB (XXXXXXXX,XXXX,1439,9999),RECU2AWS-HERC01,\n//         CLASS=A,MSGCLASS=C,\n//         NOTIFY=HERC01,COND=(0,NE)\n//RECU2AWS EXEC ASMFCL,\n//             PARM.ASM=(RENT,TERM,NODECK,OBJ,LIST),\n//             PARM.LKED=(REUS,RENT,REFR,TERM,LIST,XREF,NOLET,NOCALL)\nPASS     TITLE 'RECU2AWS - - - Copy file to AWSTAPE image file'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n* Change log:\n*\n* 2012-03-29 Removed the RECFM=U input restriction by hard-coding the\n*   W.A.M.   SYSUT1 DCB too always claim that the input is RECFM=U\n*\n* 2011-10-23 LTR R10,R10 replaced SLR R10,R10 between label EOF and\n*   W.A.M.   label EOF2.  Thank you Dave Kreiss\n*\n* This program copies the blocks of a sequential data set or member\n* to an AWSTAPE image data set.  It pretends that the input is\n* RECFM=U whether it is or not to use QSAM to read blocks of data\n* instead of logical records.\n*\n* Note: RECU2AWS may be replaced with a program DSET2AWS\n* that uses BSAM for input as soon as I have time.\n*\n* Override note: I have not written DSET2AWS but changed this\n* program to also handle RECFM=FB and RECFM=VB input.\n*\n* Warning: this program is for sequential data, not a PDS.\n* Trying to use it on a PDS would only get the directory.\n*\n* Date written: 2011-10-21\n*\n* Blame: somitcw@yahoo.com\n*\n* Sample JCL #1:\n*\n* //HERC01R JOB  (xxxxxxxx,xxxx,1439,9999,9999),RECU2AWS-HERC01,\n* //             COND=(0,NE),NOTIFY=HERC01,CLASS=A,MSGCLASS=C\n* //ADRDUMP EXEC PGM=ADRDSSU\n* //SYSPRINT DD  SYSOUT=*\n*  DUMP INDDNAME(INPUT) OUTDDNAME(OUTPUT) COMPRESS\n* //INPUT    DD  DISP=SHARE,UNIT=SYSDA,VOL=SER=xxxxxx\n* //OUTPUT   DD  DISP=(,PASS,DELETE),\n* //             UNIT=(SYSDA,5),SPACE=(TRK,(65535,65535),RLSE),\n* //             DCB=(RECFM=U,LRECL=0,BLKSIZE=27998)\n* //*\n* //RECU2AWS EXEC PGM=RECU2AWS,COND=(0,NE)\n* //SYSUDUMP DD  SYSOUT=*  Please send dumps to the above \"Blame:\"\n* //SYSUT1   DD  DISP=(SHARE,DELETE),DSNAME=*.ADRDUMP.OUTPUT\n* //SYSUT2   DD  DISP=(,CATLG,DELETE),DSNAME=&SYSUID..Vxxxxxx.AWS,\n* //             UNIT=(SYSDA,4),SPACE=(TRK,(65535,65535),RLSE),\n* //             DCB=(RECFM=U,LRECL=0,BLKSIZE=27998)\n* //*\n* //CHECKCC EXEC PGM=IEFBR14\n* //\n*\n* Sample JCL #2:\n*\n* //HERC01R JOB  (xxxxxxxx,xxxx,1439,9999,9999),RECU2AWS-HERC01,\n* //             COND=(0,NE),NOTIFY=HERC01,CLASS=A,MSGCLASS=C\n* //*\n* //RECU2AWS EXEC PGM=RECU2AWS\n* //SYSUDUMP DD  SYSOUT=*  Please send dumps to the above \"Blame:\"\n* //SYSUT1   DD  DISP=SHR,DSN=HERC01.A.DATA(RECU2AWS)\n* //SYSUT2   DD  DISP=(,CATLG,DELETE),DSN=HERC01.A.RECU2AWS,\n* //             UNIT=3390,SPACE=(TRK,1),\n* //             DCB=(RECFM=U,LRECL=0,BLKSIZE=27998)\n* //*\n* //CHECKCC EXEC PGM=IEFBR14\n* //\n*\n*      DCL 1 T_Header,\n*           2 t_size  fixed(16),  /* Size of the following block */\n*           2 t_psize fixed(16),  /* Size of the previous block  */\n*           2 t_flags,            /* Control flags.              */\n*             3 t_Newrec  bit,    /* start of new record         */\n*             3 t_eof     bit,    /* end-of-file mark            */\n*             3 t_Endrec  bit,    /* End of a record             */\n*             3 *         bit,    /* Must be zero                */\n*             3 *         bit,    /* Reserved                    */\n*             3 reserved bit(11); /* Must be zero                */\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n         PRINT ON,DATA,GEN        Give me all assembler information\nRECU2AWS CSECT ,\n         USING *,R15              Set temporary base register\n         SAVE  (14,12),,'RECU2AWS.&SYSDATE..&SYSTIME' Save reg.s\n         DROP  R15                DROP the temporary base register\n         LR    R12,R15            Load RECU2AWS base register\n         USING RECU2AWS,R12       Give the assembler the new base reg.\n         L     R0,WORKSIZE        Load register for FREEMAIN size\n         GETMAIN R,LV=(0)         Get memory for work area\n         XC    0(256,R1),0(R1)    Clear first part of work area\n         ST    R1,8(,R13)         Chain RECU2AWS old and new save areas\n         ST    R13,4(,R1)         Chain RECU2AWS old and new save areas\n         LR    R13,R1             Chain RECU2AWS old and new save areas\n         USING WORKAREA,R13       Give the assembler the work area reg.\n         MVC   SYSUT1(DUMUT1SZ),DUMUT1  Copy DCB template to DCB area\n         MVI   OPENCLOS,X'80'     Mark last DCB in OPEN/CLOSE list\n         OPEN  SYSUT1,MF=(E,OPENCLOS)  OPEN input file\n*20120329 TM    SYSUT1+DCBRECFM-IHADCB,DCBRECU  See if RECFM=U\n*20120329 BNO   ABEND1             Not RECFM=U, go abend\n         MVC   SYSUT2(DUMUT2SZ),DUMUT2  Copy DCB template to DCB area\n         MVI   OPENCLOS,X'80'     Mark last DCB in OPEN/CLOSE list\n         OPEN  (SYSUT2,OUTPUT),MF=(E,OPENCLOS)  OPEN output file\n         TM    SYSUT2+DCBRECFM-IHADCB,DCBRECU  See if RECFM=U\n         BNO   ABEND2             Not RECFM=U, go abend\n         SLR   R11,R11            Clear a work register\n         ICM   R11,B'0011',SYSUT2+DCBBLKSI-IHADCB  Load output BLKSIZE\n         ST    R11,BLKSIZE        Save the maximum output BLLSIZE\n         LA    R11,BUFFER         Set R11 to current location in buffer\n         LA    R10,0              Set R10 to amount of data in buffer\nGET      DS    0H\n         LA    R9,6(,R11)         Find where to read data\n         GET   SYSUT1,(R9)        Read a record from the input file\n         SLR   R9,R9              Clear a work register\n         ICM   R9,B'0011',SYSUT1+DCBLRECL-IHADCB  Load data size read\n* Build AWSTAPE header\n         STC   R9,0(,R11)         Build AWSTAPE header, block size\n         STCM  R9,B'0010',1(R11)  Build AWSTAPE header, block size\n         MVC   2(2,R11),OLDSIZE   Build AWSTAPE header, previous size\n         MVI   4(R11),X'A0'       Indicate start and end of block\n         MVI   5(R11),X'00'       Clear all bits in last header byte\n* AWSTAPE header has been built\n         MVC   OLDSIZE(2),0(R11)  Save new block length for next block\n         LA    R10,6(R9,R10)      Find new amount of data in buffer\n         LA    R11,6(R9,R11)      Find new current loc. for next block\n         CL    R10,BLKSIZE        Is full SYSUT2 block available?\n         BL    GET                Not enough data yet, go get more data\n         BAL   R8,PUTROUT         Else, go write some output data\n         B     GET                Go to get more input data\n*\n* PUTROUT sub-routine writes at least one block of data even if not\n* large enough for a full output BLKSIZE.  The \"always write one\n* block even if short\" is to handle the last short block.\n* PUTROUT sub-routine will normally write full output blocks until\n* there is not enough data in the buffer to write a full block.\n* PUTROUT then slides remaining data in the buffer to the beginning\n* of the buffer area so the data should never over-flow the buffer.\n*\nPUTROUT  DS    0H\n         LA    R11,BUFFER         Load address of input data\n         L     R9,BLKSIZE         Load maximum size of block to put\n         CR    R10,R9             See if enough data for maximum block\n         BNL   PUTBLOCK           Have maximum available, go PUT\n         LR    R9,R10             Set to put a short block\nPUTBLOCK DS    0H\n         STH   R9,SYSUT2+DCBLRECL-IHADCB  Update SYSUT2 DCB with\n*                                 amount of data to write\n         PUT   SYSUT2,(R11)       Write a SYSUT2 block\n         SR    R10,R9             Find new data length left\n         AR    R11,R9             Find location of remaining data\n         CL    R10,BLKSIZE        See if enough data for another block\n         BL    SHIFTBUF           Not enough, go shift data in buffer\n         L     R9,BLKSIZE         Load maximum size of block to put\n         B     PUTBLOCK           Go back to write another block\nSHIFTBUF DS    0H\n         LA    R2,BUFFER          Load MVCL output address\n         LR    R4,R11             Copy data address to MVCL input addr.\n         LA    R11,0(R10,R2)      Set R11 to location after data\n         LTR   R3,R10             Load length of data in buffer\n         BZR   R8                 Buffer is empty, return to main-line\n         LR    R5,R3              Copy MVCL output length to input len.\n         MVCL  R2,R4              Slide unwritten data to buffer start\n         BNZ   ABEND3             Error, MVCL destructive over-lap?\n         BR    R8                 Return to main-line code\n* End of sub-routine PUTROUT\n*\nEOJ      DS    0H\n         MVC   0(12,R11),EOTMARKS Put tapemarks after last block\n         MVC   2(2,R11),OLDSIZE   Update previous block length\n         LA    R10,12(,R10)       Add length of tapemarks\n         BAL   R8,PUTROUT         Go write some output data\n         LTR   R10,R10            Has all data been written?\n         BZ    EOJ2               Output buffer empty, go close files\n         BAL   R8,PUTROUT         Else, write last block of output data\nEOJ2     DS    0H\n         MVI   OPENCLOS,X'80'     Mark last DCB in OPEN/CLOSE list\n         CLOSE SYSUT2,MF=(E,OPENCLOS)  CLOSE the output file first\n         MVI   OPENCLOS,X'80'     Mark last DCB in OPEN/CLOSE list\n         CLOSE SYSUT1,MF=(E,OPENCLOS)  CLOSE the input file last\n         L     R0,WORKSIZE        Load register for FREEMAIN size\n         LR    R1,R13             RECU2AWS work area addr. for FREEMAIN\n         L     R13,4(,R13)        Restore the caller's save area addr.\n         FREEMAIN R,LV=(0),A=(1)  Free work area\n         RETURN (14,12),RC=0      Return to caller\n*\n*20120329 ABEND1   DS    0H\n*20120329 WTO   'SYSUT1 is not RECFM=U, RECU2AWS abending',ROUTCDE=11\n*20120329 ABEND 3331               Abend without a dump\n*\nABEND2   DS    0H\n         WTO   'SYSUT2 is not RECFM=U, RECU2AWS abending',ROUTCDE=11\n         ABEND 3332               Abend without a dump\n*\nABEND3   DS    0H\n         WTO   'MVCL destructive overlap, RECU2AWS abending',ROUTCDE=11\n         ABEND 3333,DUMP          Abend with a dump\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Constants Data Control Blocks\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nEOTMARKS DC    XL12'000000004000000000004000' Will overlay bytes +2 & 3\n*                  +0 1 2 3 4 5 6 7 8 9 a b\nWORKSIZE DC    A(WORKLEN)         Length of work area\n         DS    0D                 To have a better dump DCB alignment\nDUMUT1   DCB   DDNAME=SYSUT1,     Should be RECFM=U and LRECL=0        C\n               DSORG=PS,          Data Set Org. Physical Sequential    C\n               EODAD=EOJ,         End Of Data Address of label EOJ     C\n               MACRF=GM,          Input GET move-mode file             C\n               RECFM=U            Pretend that input is RECFM=U to\n*                                 read input as blocks 2012-03-29\nDUMUT1SZ EQU   *-DUMUT1           Length of dummy Data Control Block\n*\nDUMUT2   DCB   DDNAME=SYSUT2,                                          C\n               DSORG=PS,          Data Set Org. Physical Sequential    C\n               LRECL=0,           Logical Record Length                C\n               MACRF=PM,          Output PUT move-mode file            C\n               RECFM=U            RECord ForMat is Undefined\nDUMUT2SZ EQU   *-DUMUT2           Length of dummy Data Control Block\n*\n         LTORG ,                  In case someone adds literals\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DSECTs\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nWORKAREA DSECT ,\nSAVEAREA DS    18F                Register save area\nOLDSIZE  DS    H                  Old header block size inited to zero\nBLKSIZE  DS    F                  SYSUT2 output maximum BLKSIZE\n         DS    0D                 Like DCBs on a double word boundary\nSYSUT1   DS    XL(DUMUT1SZ)       Hold memory for SYSUT1 DCB\nSYSUT2   DS    XL(DUMUT2SZ)       Hold memory for SYSUT2 DCB\nOPENCLOS DS    D                  OPEN/CLOSE parameter list\nBUFFER   DS    132XL1024          I/O and work buffer\nWORKLEN  EQU   *-WORKAREA         Length of work area\n*\n* DCB DSECT follows\n         DCBD   DSORG=PS,DEVD=DA  DSECT for a sequential DCB\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      Register equates\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nR0       EQU   0                  Register equate for register 0\nR1       EQU   1                  Register equate for register 1\nR2       EQU   2                  Register equate for register 2\nR3       EQU   3                  Register equate for register 3\nR4       EQU   4                  Register equate for register 4\nR5       EQU   5                  Register equate for register 5\nR6       EQU   6                  Register equate for register 6\nR7       EQU   7                  Register equate for register 7\nR8       EQU   8                  Register equate for register 8\nR9       EQU   9                  Register equate for register 9\nR10      EQU   10                 Register equate for register 10\nR11      EQU   11                 Register equate for register 11\nR12      EQU   12                 Register equate for register 12\nR13      EQU   13                 Register equate for register 13\nR14      EQU   14                 Register equate for register 14\nR15      EQU   15                 Register equate for register 15\n         END   ,                  The end of the program\n//LKED.SYSLMOD  DD  DSN=SYS2.LINKLIB,DISP=SHR,SPACE=\n NAME RECU2AWS\n//CHECKCC EXEC PGM=IEFBR14\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT867/FILE867.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT867", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}