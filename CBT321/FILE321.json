{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011747000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 3938662, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 11, "INMDSNAM": "CBT.V500.FILE321.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 3938662, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 3938662, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE321.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00=\\x05'", "DS1TRBAL": "b'\\x89\\xdc'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x02o\\x00\\x0b\\x02s\\x00\\x0c\\x00>'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00\\x08\\x01  \\x9f\\x01  \\x9f\\x11G\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf5\\xf0\\xf0@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "2020-07-27T00:00:00", "modifydate": "2020-07-27T11:47:08", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-500"}, "text": "REGULAR CBT TAPE - VERSION 500    FILE:  321\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT500.FILE321\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 30 MEMBERS COUNTED; CUMULATIVE SIZE IS 36,907 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   07/27/20    11:47:08    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x10\\x01\\x15\\x17O\\x01 \\x02\\x9f\\x14!\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xf0\\xf8@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2015-06-23T00:00:00", "modifydate": "2020-01-29T14:21:10", "lines": 28, "newlines": 28, "modlines": 0, "user": "SYSP08"}, "text": "Enterprise Cobol V5 and the FIB. There is no documented way to\nfind the FIB in a static way like COBAnal does. I opened a PMR with\nIBM and got the following reply\n----------------------------------------------------------------------\nAs the developers were a little too busy to respond on this issue in a\ntimely fashion, I took a look at the LIST output for enlightenment.\n\nYou'll see there's an internal entry called __COMPUNITsinit (compile\nunit static init) that populates the portion of the WSA (writeable\nstatic area\u00dd1\u00a8) that belongs to the compile unit with values from the\nconstant area and/or constants created in the instruction stream,\nincluding the FIBs and other Cobol control blocks.\n\nThe upshot is that the FIBs don't exist as such until the\n__COMPUNITsinit has been run. Even if you can see what appears to\nperhaps be an FIB image in the constant area, there's no guarantee all\nthe FIB fields will be there, or that the constant area layout will be\nthe same under different optimization schemes or compiler releases.\n\nIn other words, the approach you were using with the previous versions\nof the compiler is untenable under COBOL v5, and looking at the source\ncode is the only real alternative.\n\nxxxxxx\n\n\u00dd1\u00a8 The WSA contains the working-storage and other data, including the\n    FIBs, that have a lifetime of the run unit.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE01": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00&\\x01 \\x02\\x9f\\x01 \\x02\\x9f\\x14I\\x00\\x1e\\x00\\x07\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2020-01-29T00:00:00", "modifydate": "2020-01-29T14:49:26", "lines": 30, "newlines": 7, "modlines": 0, "user": "SBGOLOB"}, "text": "Note from Sam Golob....\n\nThis version was supplied to me by John Loch, who had it directly\nfrom Roland Schiradin.  It must have fallen through the cracks, if\nand when Roland sent it to me.  Since what John had, was later than\nwhat I had, I asked him to send it to me, so everyone could (finally)\nbenefit from it.\n\nI checked my emails from that time, and it seems that Roland never\nsent this version to me, but I'm not really 100 percent sure.\n(It may have landed in my spam filter, then.)\n\nemail:   John.1.Loch@perspecta.com\n\nCopy of John's email:\n\nSubject:  RE: PDS COBANAL v1.52\nFrom:     \"Loch, John1\" <John.1.Loch@perspecta.com>\nDate:     1/29/2020, 1:22 PM\nTo:       \"sbgolobn@cbttape.org\"\n\nHere is a copy of my FILE321 (in TSO XMIT/RECEIVE format) with\nthe updates from John and Roland.\u00a0 Note, Roland's changes\nsupersede John's.\n\nRegards,\nJohn Loch\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$README": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01'\\x00\\x19\\x00\\x98\\x07\\x8f\\x01\\x16\\t\\x8f \\x10\\x00|\\x00\\x15\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xf0\\xf8@@@@\"", "ispf": {"version": "01.39", "flags": 0, "createdate": "1998-03-19T00:00:00", "modifydate": "2016-04-07T20:10:19", "lines": 124, "newlines": 21, "modlines": 0, "user": "SYSP08"}, "text": "     This is my contribution to CBT. I like the idea behind CBT and\n     like to say a big \"Thank you\" to Sam Golob for his support and\n     Gilbert Saint-Flour for giving me access to his P/390.\n\n     A big \"Thank you\" to Tom Ross from IBM helping in order to\n     get the Enterprise Cobol stuff working or other questions.\n\n     It is distributed on an as is, where is basis, without expressed\n     or implied warranty of any kind. It is distributed in hope that\n     it may save other members of the project some wheel re-inventing.\n\n     A big \"Thank you\" to Steve Stocker from CSC for his\n     enhancements.\n\n     Regards\n     Roland Schiradin (November 2007)\n     home: Roland@schiradin.de\n\n\n     ------------------- Index           ---------------------\n\n     COBANAL   Frozen version, only bug-fixes\n               This version support pre OS/390 R10\n\n               Last Change: April 2002\n\n     COBANALJ  A sample JCL to assemble CobAnal or CobAnalZ\n\n               Last Change: November 2002\n\n     COBANALZ  This Program analyze your Cobol-Load-Modules.\n               There is no need for the source. Support\n               for single programs also for a complete load-lib.\n               This program require the STRING macro from FILE183.\n               I have include the current versions of STRING\n               Thanks to Gilbert Saint-Flour\n\n               Full support for Enterprise Cobol V3\n               Full support for COBOL for OS/390 & VM V2\n               Full support for COBOL for OS/390 & VM V1\n               Full support for COBOL for MVS and VM formally called\n               COBOL/370 or ADCYLE COBOl/370.\n               Full support for COBOL-II every version.\n               Few support for COBOL-1.\n\n               If you have old or newer Cobol-Programs please\n               send me the Load to Roland(at)Schiradin.de. I'll\n               add some code to support these Cobol-Versions.\n\n               If you like to get the newest Version please contact\n               Roland(at)Schiradin.de\n\n               You can find a nice ISPF interface for CobAnal on\n               CBT File 330\n\n               Last Change: Apr 2016\n\n     COBJCL    A sample JCL for COBANAL\n\n               Last Change: November 2006\n\n     EXCIJCL   Sample JCL to invoke the CICS-Batch-Interface\n\n               Last Change: March 1999\n\n     EXCIRDO   CSD for CICS 4.1 and higher\n\n               Last Change: March 1999\n\n     EXCI      The CEMT-Batch-Interface written in Cobol\n               Note: You need the EXCI-Stub (DFHEXLI) in your\n               BIND-Job !!!! Please specify EXCI and COBOL3 as\n               the precompiler option.\n\n               Last Change: March 1999\n\n     EXCISE    The CICS-Server-Program written in Assembler.\n               Please expand the program to your needs.\n\n               Last Change: March 1999\n\n     PIDTABLE  Copybook for COBANALZ\n\n               Last Change: July 2008\n\n     STCCHECK  This program check if a started Task is allready\n               active. This avoid abend U1800 if a operator\n               start the same CICS again. Please note this works\n               only on the same MVS-image, I'll add somtimes\n               code to check the SYSPLEX.\n\n               //*******************  EXECUTE CICS\n               //*****************************************\n               //STCCHECK EXEC PGM=STCCHECK,PARM='DCCA201'\n               //SYSPRINT  DD SYSOUT=*\n               //SYSUDUMP  DD SYSOUT=D\n               //*****************************************\n               //DCCSTRT IF (STCCHECK.RC = 0) THEN\n               //DCCA201 EXEC PROC=DCICSA\n               //EDCCSTRT ENDIF\n\n               rc = 0   DCCA201 is not active\n               rc not 0 DCCA201 is active\n\n               Last Change: March 1998\n\n     STRING    Provides functions similar to PL/I's\n               PUT EDIT or COBOL's STRING.\n\n               Taken from FILE183.\n\n     STRING64  Provides functions similar to PL/I's\n               PUT EDIT or COBOL's STRING.\n               Partial 64bit support\n\n     SYEXCIC   Cobol-Source to invoke the CEDA INSTALL from Batch\n\n               Last Change: March 1996\n\n     SYEXCIS   Assembler-Source to invoke the CEDA INSTALL\n\n               Last Change: March 1996\n     --------------------------------------------------------\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$WHATSN": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x17\\x00G\\x00\\x99\\x06\\x0f\\x01\\x15\\x17O\\x12\\x12\\x00\\x19\\x00\\x02\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xf0\\xf8@@@@'", "ispf": {"version": "01.23", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "2015-06-23T12:12:47", "lines": 25, "newlines": 2, "modlines": 0, "user": "SYSP08"}, "text": "SYEXCIC  CEDA install via Batch Cobol-Source (Client)\nSYEXCIS  CEDA install via Batch Assembler-Source (Server)\nCOBANALJ JCL to assemble CobAnal or CobAnalZ\nCOBANALZ Support for Enterprise Cobol V5\n         Support for Enterprise Cobol V3R4M1\n         Require z/Architecure\n         Merged code from Steve Stocker with a lot of enhancements\n         More Binder info for all load modules\n         COBOL File section\n         CEEUOPT for Cobol/PL1/C/C++/LE-enabled Assembler\n         EZYTrieve Support\n         Modifications from Peter Farley (Thank you so much)\n         Modifications from Craig Schneiderwent (Thank you so much)\nCOBANAL  Support for Enterprise Cobol V3R1 (Version for pre OS/390 R10)\n         Frozen code for pre OS/390 R9\nSTRING   V512\nSTRING64 V515\n\nThe SUMMARY DD is new and was introduced by Steve Stocker\n(sstocker\u00a7csc.com.au) from downunder. It's a very nice enhancement\nI really like it and I guess you too. Enjoy\n\nThe JUSTDATA DD is new and was introduced by Craig Schneiderwent.\nIt's a fixed record-orienated output rather then the SYSPRINT and\nSUMMARY. This allow you to post-process the data\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "##README": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x00\\x99\\x12/\\x00\\x99\\x12/\\x19\\x02\\x002\\x00'\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-05-02T00:00:00", "modifydate": "1999-05-02T19:02:00", "lines": 50, "newlines": 39, "modlines": 0, "user": "SBGOLOB"}, "text": "Notes on the ISPF interface to Roland Schiradin's Cobanal Program\n by Fritz Alber.  This ISPF interface consists of four libraries,\n which are condensed into members of this pds.  Each member can be\n expanded into a full pds by the PDSLOAD program (from File 093 of\n the CBT Tape, load module on File 035), or by IEBUPDTE.\n\nThe four members are:   SISPEXEC, SISPMENU, SISPPENU, SISPTENU.\n\nThe job to create separate pds'es is #PDSLOAD.\n\n\n     ----------------------- ISPF application --------------------------\n\n     supplement to CBT File 321\n\n     COBA      This Application analyse the output from the\n               Cobol analyse program developed by Roland Schiradin\n               This application requires ISPF Version 4\n               The application consist of 4 datasets.\n               Rexx library\n               Panel Library\n               Message and skeleton Library\n               Table Libary\n\n               You have to change member $COBA in the Rexx library\n               See section/label Coba_Parms thru End_Coba_Parms.\n               Please change the following variables to your standards\n\n               ACCOUNT\n               CLASS\n               MSGCLASS\n               STEPLIB\n               ISPFHLQ\n               COBAAPPL\n               COBAHLQ\n               LLQCLIB\n               LLQPLIB\n               LLQMLIB\n               LLQSLIB\n               LLQTLIB\n               LLQTABL\n\n               After these changes you can execute procedure $COBA\n               First you'll see a selection panel to display\n               or create analyse tables.\n\n               If you have any problems, comments or improvements\n               please contact\n               Alber(at)alber-edv.de\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#PDSLOAD": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x91\\x13o\\x00\\x99\\x12/\\x19\\x10\\x00$\\x00\\x0b\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1991-05-16T00:00:00", "modifydate": "1999-05-02T19:10:00", "lines": 36, "newlines": 11, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU  JOB (ACCT#),S-GOLOB,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X\n//*\n//UPDATE1  EXEC  PGM=PDSLOAD,PARM='UPDTE(><)',COND=EVEN\n//STEPLIB  DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DSN=SBGOLOB.FILE321.PDS(SISPEXEC),DISP=SHR\n//SYSUT2   DD  DSN=SBGOLOB.COBA.SISPEXEC,DISP=(NEW,CATLG,DELETE),\n//         UNIT=SYSDA,DCB=(RECFM=FB,LRECL=80,BLKSIZE=27920),\n//         SPACE=(TRK,(30,30,44),RLSE)\n//*\n//UPDATE2  EXEC  PGM=PDSLOAD,PARM='UPDTE(><)',COND=EVEN\n//STEPLIB  DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DSN=SBGOLOB.FILE321.PDS(SISPMENU),DISP=SHR\n//SYSUT2   DD  DSN=SBGOLOB.COBA.SISPMENU,DISP=(NEW,CATLG,DELETE),\n//         UNIT=SYSDA,DCB=(RECFM=FB,LRECL=80,BLKSIZE=27920),\n//         SPACE=(TRK,(15,15,44),RLSE)\n//*\n//UPDATE3  EXEC  PGM=PDSLOAD,PARM='UPDTE(><)',COND=EVEN\n//STEPLIB  DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DSN=SBGOLOB.FILE321.PDS(SISPPENU),DISP=SHR\n//SYSUT2   DD  DSN=SBGOLOB.COBA.SISPPENU,DISP=(NEW,CATLG,DELETE),\n//         UNIT=SYSDA,DCB=(RECFM=FB,LRECL=80,BLKSIZE=27920),\n//         SPACE=(TRK,(30,30,44),RLSE)\n//*\n//UPDATE4  EXEC  PGM=PDSLOAD,PARM='UPDTE(><)',COND=EVEN\n//STEPLIB  DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DSN=SBGOLOB.FILE321.PDS(SISPTENU),DISP=SHR\n//SYSUT2   DD  DSN=SBGOLOB.COBA.SISPTENU,DISP=(NEW,CATLG,DELETE),\n//         UNIT=SYSDA,DCB=(RECFM=FB,LRECL=80,BLKSIZE=27920),\n//         SPACE=(TRK,(30,30,44),RLSE)\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE321": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00V\\x01  \\x9f\\x01  \\x9f\\x11F\\x00\\x80\\x00\\x80\\x00\\x00\\xc3\\xc2\\xe3`\\xf5\\xf0\\xf0@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "2020-07-27T00:00:00", "modifydate": "2020-07-27T11:46:56", "lines": 128, "newlines": 128, "modlines": 0, "user": "CBT-500"}, "text": "//***FILE 321 is from Roland Schiradin of Eltville, Germany.        *   FILE 321\n//*           This file contains several programs:  One is a        *   FILE 321\n//*           COBOL load module analyzer, which will tell you       *   FILE 321\n//*           what options a COBOL CSECT was compiled with.         *   FILE 321\n//*           Another is a started task tester, to check if a       *   FILE 321\n//*           certain started task is running, and to set a         *   FILE 321\n//*           condition code in a batch job as a result.            *   FILE 321\n//*                                                                 *   FILE 321\n//*           Addition of a CICS CEMT interface for batch.          *   FILE 321\n//*           Addition of a CICS CEDA INSTALL interface for batch   *   FILE 321\n//*                                                                 *   FILE 321\n//*       ADDRESS:   ROLAND SCHIRADIN                               *   FILE 321\n//*                  TAUSUSSTR 52                                   *   FILE 321\n//*                  65343 ELTVILLE, GERMANY                        *   FILE 321\n//*                                                                 *   FILE 321\n//*       PHONE:     49-6123-899708                                 *   FILE 321\n//*                                                                 *   FILE 321\n//*       EMAIL:     ROLAND@SCHIRADIN.DE (fix)                      *   FILE 321\n//*                                                                 *   FILE 321\n//*     Roland Schiradin (November 2007)                            *   FILE 321\n//*                                                                 *   FILE 321\n//* --------------------------------------------------------------  *   FILE 321\n//*                                                                 *   FILE 321\n//*     These programs are distributed on an as is, where is        *   FILE 321\n//*     basis, without expressed or implied warranty of any         *   FILE 321\n//*     kind. It is distributed in hope that it may save other      *   FILE 321\n//*     people some wheel re-inventing.                             *   FILE 321\n//*                                                                 *   FILE 321\n//* --------------------------------------------------------------  *   FILE 321\n//*                                                                 *   FILE 321\n//*       -------------------  Index  ---------------------         *   FILE 321\n//*                                                                 *   FILE 321\n//*                                                                 *   FILE 321\n//*  COBANAL   Frozen version, only bug-fixes                       *   FILE 321\n//*            This version support pre OS/390 R10                  *   FILE 321\n//*                                                                 *   FILE 321\n//*            Last Change: April 2002                              *   FILE 321\n//*                                                                 *   FILE 321\n//*  COBANALJ  A sample JCL to assemble CobAnal or CobAnalZ         *   FILE 321\n//*                                                                 *   FILE 321\n//*            Last Change: November 2002                           *   FILE 321\n//*                                                                 *   FILE 321\n//*  COBANALZ  This Program analyze your Cobol-Load-Modules.        *   FILE 321\n//*            There is no need for the source. Support             *   FILE 321\n//*            for single programs also for a complete load-lib.    *   FILE 321\n//*            This program require the STRING macro from FILE183.  *   FILE 321\n//*            I have include the current versions of STRING        *   FILE 321\n//*            Thanks to Gilbert Saint-Flour                        *   FILE 321\n//*                                                                 *   FILE 321\n//*            Full support for Enterprise Cobol V3                 *   FILE 321\n//*            Full support for COBOL for OS/390 & VM V2            *   FILE 321\n//*            Full support for COBOL for OS/390 & VM V1            *   FILE 321\n//*            Full support for COBOL for MVS and VM formally called*   FILE 321\n//*            COBOL/370 or ADCYLE COBOl/370.                       *   FILE 321\n//*            Full support for COBOL-II every version.             *   FILE 321\n//*            Few support for COBOL-I.                             *   FILE 321\n//*                                                                 *   FILE 321\n//*            If you have old or newer Cobol-Programs please       *   FILE 321\n//*            send me the Load to Roland(at)Schiradin.de. I'll     *   FILE 321\n//*            add some code to support those Cobol-Versions.       *   FILE 321\n//*                                                                 *   FILE 321\n//*            If you like to get the newest Version please contact *   FILE 321\n//*            Roland(at)Schiradin.de                               *   FILE 321\n//*                                                                 *   FILE 321\n//*            Last Change: November 2007                           *   FILE 321\n//*                                                                 *   FILE 321\n//*  COBJCL    A sample JCL for COBANAL                             *   FILE 321\n//*                                                                 *   FILE 321\n//*            Last Change: November 2006                           *   FILE 321\n//*                                                                 *   FILE 321\n//*  EXCIJCL   Sample JCL to invoke the CICS-Batch-Interface        *   FILE 321\n//*                                                                 *   FILE 321\n//*            Last Change: March 1999                              *   FILE 321\n//*                                                                 *   FILE 321\n//*  EXCIRDO   CSD for CICS 4.1 and higher                          *   FILE 321\n//*                                                                 *   FILE 321\n//*            Last Change: March 1999                              *   FILE 321\n//*                                                                 *   FILE 321\n//*  EXCI      The CEMT-Batch-Interface written in Cobol            *   FILE 321\n//*            Note: You need the EXCI-Stub (DFHEXLI) in your       *   FILE 321\n//*            BIND-Job !!!! Please specify EXCI and COBOL3 as      *   FILE 321\n//*            the precompiler option.                              *   FILE 321\n//*                                                                 *   FILE 321\n//*            Last Change: March 1999                              *   FILE 321\n//*                                                                 *   FILE 321\n//*  EXCISE    The CICS-Server-Program written in Assembler.        *   FILE 321\n//*            Please expand the program to your needs.             *   FILE 321\n//*                                                                 *   FILE 321\n//*            Last Change: March 1999                              *   FILE 321\n//*  STCCHECK  This program check if a started Task is allready     *   FILE 321\n//*            active. This avoid abend U1800 if a operator         *   FILE 321\n//*            start the same CICS again. Please note this works    *   FILE 321\n//*            only on the same MVS-image, I'll add somtimes        *   FILE 321\n//*            code to check the SYSPLEX.                           *   FILE 321\n//*                                                                 *   FILE 321\n//*            //*******************  EXECUTE CICS                  *   FILE 321\n//*            //*****************************************          *   FILE 321\n//*            //STCCHECK EXEC PGM=STCCHECK,PARM='DCCA201'          *   FILE 321\n//*            //SYSPRINT  DD SYSOUT=*                              *   FILE 321\n//*            //SYSUDUMP  DD SYSOUT=D                              *   FILE 321\n//*            //*****************************************          *   FILE 321\n//*            //DCCSTRT IF (STCCHECK.RC = 0) THEN                  *   FILE 321\n//*            //DCCA201 EXEC PROC=DCICSA                           *   FILE 321\n//*            //EDCCSTRT ENDIF                                     *   FILE 321\n//*                                                                 *   FILE 321\n//*            rc = 0   DCCA201 is not active                       *   FILE 321\n//*            rc not 0 DCCA201 is active                           *   FILE 321\n//*                                                                 *   FILE 321\n//*            Last Change: March 1998                              *   FILE 321\n//*                                                                 *   FILE 321\n//*  STRING    Provides functions similar to PL/I's                 *   FILE 321\n//*            PUT EDIT or COBOL's STRING.                          *   FILE 321\n//*                                                                 *   FILE 321\n//*            Taken from FILE183.                                  *   FILE 321\n//*                                                                 *   FILE 321\n//*  STRING64  Provides functions similar to PL/I's                 *   FILE 321\n//*            PUT EDIT or COBOL's STRING.                          *   FILE 321\n//*            Partial 64bit support.                               *   FILE 321\n//*                                                                 *   FILE 321\n//*  SYEXCIC   Cobol-Source to invoke the CEDA INSTALL from Batch   *   FILE 321\n//*                                                                 *   FILE 321\n//*            Last Change: March 1996                              *   FILE 321\n//*                                                                 *   FILE 321\n//*  SYEXCIS   Assembler-Source to invoke the CEDA INSTALL          *   FILE 321\n//*                                                                 *   FILE 321\n//*            Last Change: March 1996                              *   FILE 321\n//*  --------------------------------------------------------       *   FILE 321\n//*                                                                 *   FILE 321\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "COBALOAD": {"ttr": 534, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x004\\x7f\\x01\\x004\\x7f\\x183\\x00\\xca\\x00\\xca\\x00\\x00\\xc6\\xd9\\xc1\\xd3\\xc2\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-12-12T00:00:00", "modifydate": "2000-12-12T18:33:00", "lines": 202, "newlines": 202, "modlines": 0, "user": "FRALBER"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "COBANAL": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00\\x17\\x01\\x02\\x01o\\x01\\x03\\x02?\\x01\\x07\\x08E\\x08\\x1d\\x00\\x00\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2002-01-16T00:00:00", "modifydate": "2003-01-23T01:07:17", "lines": 2117, "newlines": 2077, "modlines": 0, "user": "XSSGSCH"}, "text": "***********************************************************************\n*                                                                     *\n* Name:         COBANAL                                               *\n*                                                                     *\n* Author:       Roland Schiradin                                      *\n*               roland(at)Schiradin.de                                *\n*                                                                     *\n* Date:         Februar 1996                                          *\n*                                                                     *\n* Description:  Show compile-settings and some other information      *\n*                                                                     *\n* Changes:      16.12.1996 (european)                                 *\n*               Support for VS/COBOL1 (just a few)                    *\n*               String macro no longer inside this source             *\n*               (request FILE183 from Naspa or drop me an email)      *\n*               28.04.1997 (european)                                 *\n*               Support for COBOL for MVS and VM Release 2 (formally  *\n*               called AD/Cycle COBOL/370)                            *\n*               04.03.1998 (european)                                 *\n*               MODID-marco dropped                                   *\n*               Direct Load-Library support                           *\n*               Some parts of Dave Alcocks code (DA$COBR)             *\n*               (You can contact him at dalcock(at)csw.com)           *\n*               24.03.1998 (european)                                 *\n*               Prevent S15D abend you invoke COBANAL from TSO-CALL   *\n*               (reported by Dave Alcock)                             *\n*               Support for newer STRING macro STRING GENERATE instead*\n*               of STRING FINAL_CALL                                  *\n*               (reported by Dave Alcock)                             *\n*               Fixed a bug in statement list. Y now means Yes and not*\n*               vice versa. Sorry                                     *\n*               15.02.1999 (european)                                 *\n*               Support for COBOL OS/390 and VM V2R1                  *\n*               Some new Compile-options                              *\n*               Compile-Date is European style, added long name       *\n*               Some minor fixes I cant remember in detail            *\n*               Support for MVS 4.3 (AMODE switching)                 *\n*               10.06.1999 (european)                                 *\n*               Fixed bugs reported by Mr. Smets (Thank you)          *\n*               Show ?? as the century for COBOL2                     *\n*               Support for Entrypoints (e.g. ENTRY 'DLITCBL')        *\n*               Note: There is no need to do this for IMS             *\n*               25.10.1999 (european)                                 *\n*               Check ParmLength for Parameter \"ALL\".                 *\n*               Close all datasets                                    *\n*               Make CobAnal reentrant (LinkList!!!)                  *\n*               Release storage                                       *\n*               Load modules from DD COBANAL if exist                 *\n*               29.12.1999 (european)                                 *\n*               Abend 0C4 fixed                                       *\n*               Add PPA2 support                                      *\n*               Detect C/C++ and LE-enabled Assembler Programs        *\n*               The product name for COBOL1 is OS/VS Cobol (MVS) and  *\n*               DOS/VS COBOL (VSE)                                    *\n*               13.04.2000 (european)                                 *\n*               Support for some infos I missed (INVOKE, GLOBAL and   *\n*               so on) Thank you Mr. Gross                            *\n*               Add a third base register                             *\n*               23.04.2000 (european)                                 *\n*               Tested with STRING V507 from FILE183                  *\n*               19.07.2000 (european)                                 *\n*               Support for COBOL1 OEM products (e.g. CA-Optimzer)    *\n*               Thank you Mr. Pfeifer                                 *\n*               02.10.2000 (european)                                 *\n*               Support for COBOL for OS/390 & VM V2R2                *\n*               New TEST(SEPARATE)/NO TEST(SEPARATE)                  *\n*               New ARITH(EXTEND)/ARITH(COMPAT)                       *\n*               New line-sequential file                              *\n*               Thank you IBM for HFS-Support and Display under CICS  *\n*               Save some literal pool                                *\n*               I know I need to re-design the program but the        *\n*               time (you may know) is limited. At the start it       *\n*               was intend to run once and then throw it away         *\n*               Thanks for all ideas to do it better, if I'm retired  *\n*               I would spent some time on it. Don't expect that      *\n*               within the next 25 years !!!                          *\n*               09.10.1999 (european)                                 *\n*               End-Substract changed to End-Subtract                 *\n*               Corect a length for moving literal Subtract           *\n*               08.01.2001 (european)                                 *\n*               Loop bug fixed                                        *\n*               04.12.2001 (european)                                 *\n*               Fixed bug reporting CLOSE Y/N                         *\n*               Support for Cobol Enterprise V3R1 (BETA)              *\n*               Support for generic member names                      *\n*                 You can use ? or * in the member name to minimize   *\n*                 output instead of ALL or a single load member       *\n*                 '?' stand for any single character                  *\n*                 '*' stand for any character                         *\n*                 Be aware this feature require SYS1.MODGEN(ASAXWC)   *\n*                 introduced with MVS 5.2                             *\n*               ** Attention ****                                     *\n*                  CobAnal require MVS 5.2                            *\n*               ** Attention ****                                     *\n*               ASAXWC is not GUPI but I raised a requirement         *\n*               If you think ASAXWC might be useful for you too,      *\n*               please open a requirement                             *\n*               12.02.2002 (european)                                 *\n*               Support for IMS programs with an Entry Point DLITCBL  *\n*               I still believe such an entry point is not needed     *\n*               but it seems it's in use. However David Sumner        *\n*               made the needed changes and I merged it to the        *\n*               current source so it will be a part of CobAnal        *\n*               Special thank you to David Sumner                     *\n*               16.04.2002 (european)                                 *\n*               Bug-fix                                               *\n*               17.01.2003 (european)                                 *\n*               CMPR2 is not supported for Enterprise Cobol           *\n***********************************************************************\n         TITLE 'Show Compile-Option and some more nice info'\nCOBANAL  CSECT\nCOBANAL  AMODE 31\nCOBANAL  RMODE 24\n         BAKR  R14,R0             Save register\n         LA    R10,1\n         LR    R6,R15             set base register\n         LA    R7,4095(R10,R6)    second base register\n         LA    R12,4095(R10,R7)   third base register\n         USING COBANAL,R6,R7,R12     Addressebility\n         L     R9,0(R1)           Save Parmlist\n         USING COBANAL_PARM,R9    addressebility\n         LA    R0,COBANAL_WORK_LENGTH\n         STORAGE OBTAIN,LENGTH=(R0),ADDR=(R1),COND=NO,LOC=BELOW\n         LR    R11,R1             COBANAL_WORK register\n         USING COBANAL_WORK,R11   addressebility\n         MVC   EYECATCHER,=CL8'COBANAL'\n         MVI   DOALL,C'N'         Default\n         MVI   DD_COBANAL,C'N'    Default\n         XC    SAVEAREA,SAVEAREA  clear saveare\n         LA    R15,SAVEAREA       get address of savearea\n         ST    R13,4(,R15)        chain the savearea back pointer\n         ST    R15,8(,R13)        chain saveare forward\n         LR    R13,R15            set new savearea\n         ST    R11,ADR_COBANAL_WORK  save address\n         ST    R9,ADR_COBANAL_PARM   save address\n*------------------------------------------------------------*\n*        Check JCL-Parm                                      *\n*------------------------------------------------------------*\n         MVC   PARM_LENGTH,COBANAL_PARM_LENGTH\n         LH    R10,PARM_LENGTH\n         LA    R9,2(R9)            jump length field\n         MVC   PGMNAME,BLANKS      clear PGMNANE\n         MVC   PGMNAME_GET,BLANKS  clear PGMNANE GETMEM\n         LA    R8,PGMNAME          first parm\nCOBANAL_010 DS  0H                 do until first ',' or end\n         CLI   0(R9),C','          parm separator\n         BE    COBANAL_020         next parm\n         MVC   0(1,R8),0(R9)\n         LA    R8,1(R8)            next digit\n         LA    R9,1(R9)            next digit\n         BCT   R10,COBANAL_010     loop\nCOBANAL_020 DS  0H\n         MVC   SYSPRINT(SYSPRINT_FIX_LENGTH),SYSPRINT_FIX\n         MVC   PARMLIST(C_LSTOL),C_LSTO\n         LA    R9,SYSPRINT\n         USING IHADCB,R9\n         MVC   DCBDDNAM,=C'SYSPRINT'\n         OPEN  ((R9),OUTPUT),MF=(E,PARMLIST)\n         DROP  R9\n         DEVTYPE =CL8'COBANAL',DOUBLE     Get COBANAL information\n         LTR   R15,R15                    Is it allocated?\n         BNZ   COBANAL_021                No, continue\n         MVI   DD_COBANAL,C'Y'    Default\n         MVC   INPUT(INPUT_FIX_LENGTH),INPUT_FIX\n         MVC   PARMLIST(C_LSTIL),C_LSTI\n         LA    R9,INPUT\n         USING IHADCB,R9\n         MVC   DCBDDNAM,=C'COBANAL '\n         OPEN  ((R9),INPUT),MF=(E,PARMLIST)\n         DROP  R9\nCOBANAL_021 DS  0H\n         STRING 'COBOL module analysis is starting',INTO=RECORD\n         BAL   R14,SPACE1                 Print starting message\n         CLC   PGMNAME,BLANKS      check PGMNAME\n         BE    COBANAL_PARM_ERROR  if clear ==> Error\n         CLC   PGMNAME(3),=C'ALL'  PGMNAME = ALL indicate analyzing\n         BNE   COBANAL_025         a complete Load, but check for\n         CLC   PARM_LENGTH,=H'3'   length; maybe it is a prog called\n         BNE   COBANAL_025         ALLWAYS :-))\n         CLI   DD_COBANAL,C'Y'        Did you read the docs?\n         BE    COBANAL_022           yes, thats fine\n         STRING 'Parameter=ALL specified but DD-Name COBANAL missing', *\n               INTO=RECORD\n         BAL   R14,SPACE1                 Print starting message\n         MVC   RETCODE,=F'12'\n         B     COBANAL_EXIT         no, leave\n** Loop\nCOBANAL_022 DS  0H\n         MVI   DOALL,C'Y'          remember that\n         BAL   R14,GETMEM          get the member name\n         CLC   PGMNAME_GET,XFF         more entries?\n         BE    COBANAL_EXIT          leave\n*------------------------------------------------------------*\n*        Load the progamm from DD COBANAL                    *\n*------------------------------------------------------------*\n         LOAD  EPLOC=PGMNAME_GET,DCB=INPUT,ERRET=COBANAL_LOAD_ERROR\n         B     COBANAL_027\nCOBANAL_025 DS  0H\n         LA    R5,PGMNAME         start search at address\n         LA    R4,L'PGMNAME       length of string to be searched\n         AR    R4,R5              + start of address\n         LA    R0,C'?'            search for ?\n         SRST  R4,R5              issue search\n         BC    4,COBANAL_028      wildcard ? found\n         LA    R5,PGMNAME         start search at address\n         LA    R4,L'PGMNAME       length of string to be searched\n         AR    R4,R5              + start of address\n         LA    R0,C'*'            search for *\n         SRST  R4,R5              issue search\n         BC    4,COBANAL_028      wildcard * found\n         MVC   PGMNAME_GET,PGMNAME\n         CLI   DD_COBANAL,C'Y'    load from DD Cobanal ?\n         BE    COBANAL_026           yes\n*------------------------------------------------------------*\n*        Load the progamm                                    *\n*------------------------------------------------------------*\n         LOAD  EPLOC=PGMNAME_GET   Load the pgm\n         B     COBANAL_027\nCOBANAL_026 DS  0H\n*------------------------------------------------------------*\n*        Load the progamm from DD COBANAL                    *\n*------------------------------------------------------------*\n         LOAD  EPLOC=PGMNAME,DCB=INPUT,ERRET=COBANAL_LOAD_ERROR\nCOBANAL_027 DS  0H\n         LTR   R15,R15             check response\n         BNZ   COBANAL_LOAD_ERROR if greater zero ==> Error\n         ST    R0,ADR_PGMNAME      save the address\n*------------------------------------------------------------*\n*        Check length                                        *\n*------------------------------------------------------------*\n         CSVQUERY SEARCH=JPALPA,       SEARCH JPAQ                     +\n               INADDR=ADR_PGMNAME,     ADDRESS                         +\n               OUTLOADPT=CSV_LOADPT,                                DEH+\n               OUTLENGTH=CSV_LENGTH,                                   +\n               MF=(E,CSVQRYWK)         WORK AREA\n         LTR   R2,R15                  pass return code\n         BNZ   COBANAL_CSV_ERROR if greater zero ==> Error\n         B     COBANAL_03\nCOBANAL_028 DS  0H\n         MVI   DOALL,C'X'          remember that (eXclude)\n         BAL   R14,GETMEM          get the member name\n         CLC   PGMNAME_GET,XFF         more entries?\n         BE    COBANAL_EXIT          leave\n         ASAXWC    PATTERNSTR=PGMNAME,                                 X\n               PATTERNSTRLEN==A(L'PGMNAME),                            X\n               STRING=PGMNAME_GET,                                     X\n               STRINGLEN==A(L'PGMNAME_GET),                            X\n               ZEROORMORE==CL1'*',                                     X\n               ONECHAR==CL1'?',                                        X\n               DELIMITER==CL1' ',                                      X\n               RETCODE=RETCODE,                                        X\n               MF=(E,MYLIST)\n*        STRING 'Program Name= ',PGMNAME_GET,                          @\n               ' Pattern= ',PGMNAME,'RC= ',(RETCODE,,X),               @\n               INTO=RECORD                    debug\n*        BAL   R14,SPACE1\n         CLC   RETCODE,=F'0'\n         BNE   COBANAL_028\n*------------------------------------------------------------*\n*        Load the progamm from DD COBANAL                    *\n*------------------------------------------------------------*\n         LOAD  EPLOC=PGMNAME_GET,DCB=INPUT,ERRET=COBANAL_LOAD_ERROR\n         B     COBANAL_027\n*------------------------------------------------------------*\n*        Write info to sysprint                              *\n*------------------------------------------------------------*\nCOBANAL_03 DS  0H\n         STRING 'Program Name= ',PGMNAME_GET,                          @\n               ' was loaded into storage at EPA= ',(ADR_PGMNAME,,X),   @\n               INTO=RECORD\n         BAL   R14,SPACE1\n*\n*        Dump the first 256 Bytes for Identification.\n*        Should be activate only in case of problems\n*\n*        L     R4,ADR_PGMNAME\n*        LA    R3,256/16               LOOP COUNTER\n*LOOP\nCOBANAL_04 DS  0H\n*        STRING 4X,((R4),4,X),1X,(4(R4),4,X),1X,(8(R4),4,X),1X,        X\n               (12(R4),4,X),3X,((R4),16),                              $\n               INTO=RECORD\n*        BAL   R14,SPACE1          <== next line\n*        LA    R4,016(,R4)             BUMP POINTER\n*        BCT   R3,COBANAL_04\n*ENDLOOP\n         L     R4,ADR_PGMNAME       Load-Entry-Point\n         USING COBOL_370_DSECT,R4\n         CLC   CSV_LENGTH,=F'24'    At least 24 bytes!!!\n         BNH   COBANAL_06            prevent S0C4\n         CLC   CEE_EYECATCHER,C_COBOL370   COBOL/370 ?  X'00C3C5C5'\n         BE    COBOL_370\n         CLC   CEE_EYECATCHER,C_OPLINK     C         ?  X'01C3C5C5'\n         BE    C_370\n         USING COBOL_2_DSECT,R4\n         CLC   C2_EYECATCHER,=CL4' C2 '     COBOL/2 ?  X'40C3F240'\n         BE    COBOL_2\n         USING COBOL_1_DSECT,R4\n* ???    CLC   C1_EYECATCHER,=CL2'AN'       ANS4 COBOL ?\n* ???    BE    COBOL_1\n         CLC   C1_EYECATCHER(4),=CL4'VSR1'       OS/VS COBOL/1 ?\n         BE    COBOL_1\n         CLC   C1_EYECATCHER(4),=CL4'VSR2'       OS/VS COBOL/1 ?\n         BE    COBOL_1\n* The following code is essentially a copy of the code above.       DEH\n* The purpose is to continue analysis at the load point if we       DEH\n*      have been unsuccessful at the entry point. This seems        DEH\n*      to be of benefit for IMS load modules.                       DEH\n         STRING 'Program Name= ',PGMNAME_GET,                       DEH@\n               ' was loaded at address= ',(CSV_LOADPT,,X),          DEH@\n               INTO=RECORD                                          DEH\n         BAL   R14,SPACE1                                           DEH\n         L     R4,CSV_LOADPT        Load Load Address               DEH\n         USING COBOL_370_DSECT,R4                                   DEH\n         CLC   CSV_LENGTH,=F'24'    At least 24 bytes!!!            DEH\n         BNH   COBANAL_06            prevent S0C4                   DEH\n         CLC   CEE_EYECATCHER,C_COBOL370   COBOL/370 ?  X'00C3C5C5' DEH\n         BE    COBOL_370                                            DEH\n         CLC   CEE_EYECATCHER,C_OPLINK     C         ?  X'01C3C5C5' DEH\n         BE    C_370                                                DEH\n         USING COBOL_2_DSECT,R4                                     DEH\n         CLC   C2_EYECATCHER,=CL4' C2 '     COBOL/2 ?  X'40C3F240'  DEH\n         BE    COBOL_2                                              DEH\n         USING COBOL_1_DSECT,R4                                     DEH\n* ???    CLC   C1_EYECATCHER,=CL2'AN'       ANS4 COBOL ?            DEH\n* ???    BE    COBOL_1                                              DEH\n         CLC   C1_EYECATCHER(4),=CL4'VSR1'       OS/VS COBOL/1 ?    DEH\n         BE    COBOL_1                                              DEH\n         CLC   C1_EYECATCHER(4),=CL4'VSR2'       OS/VS COBOL/1 ?    DEH\n         BE    COBOL_1                                              DEH\nCOBANAL_06 DS  0H\n         STRING 'Can not established the program_language',INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'8'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_08 DS  0H\n         STRING 'Program=',PGMNAME_GET,' seems to be LE but',          X\n               ' PPA1 looks invalid',INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'8'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_09 DS  0H\n         CLI   0(R2),X'03'          ID = C       (03) ?\n         BNE   COBANAL_10             no check Assembler\n         STRING 'Program=',PGMNAME_GET,' is a C-Program ',INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'8'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_10 DS  0H\n         CLI   0(R2),X'0F'          ID = Assembler (15) ?\n         BNE   COBANAL_06             no, unknown language\n         STRING 'Program=',PGMNAME_GET,' is a LE-enabled ',            X\n               'Assembler',INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'8'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_PARM_ERROR DS  0H\n         STRING 'Error parm statement, check it',INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'12'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_LOAD_ERROR DS  0H\n         STRING 'Error during load of program=',PGMNAME_GET,           X\n               INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'12'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_CSV_ERROR DS  0H\n         STRING 'CSVQUERY failed, RC=',((R2),,L),INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'12'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_EXIT       DS 0H\n         DELETE EPLOC=PGMNAME_GET   Delete the pgm\n         CLI   DOALL,C'N'           Default\n         BE    COBANAL_FIN\n         CLI   DOALL,C'X'           Exclude with wildcards?\n         BE    COBANAL_EXIT_1         No leave\n         CLC   PGMNAME_GET,XFF      Last Program?\n         BNE   COBANAL_022            no loop\n         B     COBANAL_FIN          finish\nCOBANAL_EXIT_1     DS 0H\n         CLC   PGMNAME_GET,XFF      Last Program?\n         BNE   COBANAL_028           no loop\nCOBANAL_FIN        DS 0H\n         LA    R9,SYSPRINT\n         USING IHADCB,R9\n         TM    DCBOFLGS-IHADCB(R9),DCBOFOPN Is it OPEN?\n         BNO   COBANAL_FIN_1              No, ignore it\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE\n         CLOSE ((R9)),MF=(E,PARMLIST)      Close it\n         DROP  R9\nCOBANAL_FIN_1      DS 0H\n         LA    R9,INPUT\n         USING IHADCB,R9\n         TM    DCBOFLGS-IHADCB(R9),DCBOFOPN Is it OPEN?\n         BNO   COBANAL_FIN_2              No, ignore it\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE\n         CLOSE ((R9)),MF=(E,PARMLIST)      Close it\n         DROP  R9\nCOBANAL_FIN_2      DS 0H\n         LA    R0,COBANAL_WORK_LENGTH\n         STORAGE RELEASE,              free Storage                    *\n               LENGTH=(R0),            Length                          *\n               ADDR=((R11))\n         L     R15,RETCODE\n         PR\n*============================================================*\n*    C/370 Program OPLINK Bit on !!!!!                       *\n*    Offset instead of relative pointer!!!                   *\n*============================================================*\nC_370    DS 0H\n         LR    R2,R4\n         A     R2,12(,R4)          PPA1\n         CLI   1(R2),X'CE'         Check PPA1\n         BNE   COBANAL_08            seems invalid PPA1\n         A     R4,4(,R2)           PPA2 pointer\n         LR    R2,R4\n         B     COBANAL_09          check languages\n*============================================================*\n*    COBOL/370 Program                                       *\n*============================================================*\nCOBOL_370 DS 0H\n         USING COBOL_370_DSECT,R4\n         LR    R2,R4\n         A     R2,12(,R4)          PPA1\n         CLI   1(R2),X'CE'         Check PPA1\n         BNE   COBANAL_08            seems invalid PPA1\n         ICM   R2,B'1111',4(R2)    PPA2 pointer\n         BZ    COBANAL_08            seems invalid PPA2\n         CLI   0(R2),X'05'         ID = Cobol!! (15)\n         BNE   COBANAL_09            no, error\n         MVI   LE_SWITCH,C'1'\n         L     R4,CEE_PRI_EP_ADDRESS\n         MVC   LE_VERS,CEE_VERS\n         MVC   LE_REL,CEE_REL\n         MVC   LE_MOD,CEE_MOD\n         MVC   LE_CCSID,CEE_CCSID\n         MVC   LE_PGM_NAME,CEE_PGM_NAME\n         MVC   LE_COMP_DAY,CEE_COMP_DAY\n         MVC   LE_COMP_MONTH,CEE_COMP_MONTH\n         MVC   LE_COMP_YEAR,CEE_COMP_YEAR\n         MVC   LE_COMP_HOURS,CEE_COMP_HOURS\n         MVC   LE_COMP_MIN,CEE_COMP_MIN\n         MVC   LE_COMP_SEC,CEE_COMP_SEC\n         MVC   LE_DATA_STATEMENTS,CEE_DATA_STATEMENTS\n         MVC   LE_PROC_LINES,CEE_PROC_LINES\n         MVC   LE_YEAR_WINDOW,CEE_YEAR_WINDOW\n         MVC   LE_STATUS_BYTE_01,CEE_STATUS_BYTE_01\n         MVC   LE_STATUS_BYTE_02,CEE_STATUS_BYTE_02\n         MVC   LE_STATUS_BYTE_03,CEE_STATUS_BYTE_03\n         MVC   LE_STATUS_BYTE_04,CEE_STATUS_BYTE_04\n         MVC   LE_STATUS_BYTE_05,CEE_STATUS_BYTE_05\n         MVC   LE_STATUS_BYTE_06,CEE_STATUS_BYTE_06\n         MVC   LE_STATUS_BYTE_07,CEE_STATUS_BYTE_07\n         MVC   LE_STATUS_BYTE_08,CEE_STATUS_BYTE_08\n         MVC   LE_STATUS_BYTE_09,CEE_STATUS_BYTE_09\n         MVC   LE_STATUS_BYTE_10,CEE_STATUS_BYTE_10\n         MVC   LE_STATUS_BYTE_11,CEE_STATUS_BYTE_11\n         MVC   LE_STATUS_BYTE_12,CEE_STATUS_BYTE_12\n         MVC   LE_STATUS_BYTE_13,CEE_STATUS_BYTE_13\n         MVC   LE_STATUS_BYTE_14,CEE_STATUS_BYTE_14\n         MVC   LE_STATUS_BYTE_15,CEE_STATUS_BYTE_15\n         MVC   LE_STATUS_BYTE_16,CEE_STATUS_BYTE_16\n         MVC   LE_STATUS_BYTE_17,CEE_STATUS_BYTE_17\n         MVC   LE_STATUS_BYTE_18,CEE_STATUS_BYTE_18\n         MVC   LE_STATUS_BYTE_19,CEE_STATUS_BYTE_19\n         MVC   LE_STATUS_BYTE_20,CEE_STATUS_BYTE_20\n         MVC   LE_STATUS_BYTE_21,CEE_STATUS_BYTE_21\n         MVC   LE_STATUS_BYTE_22,CEE_STATUS_BYTE_22\n         MVC   LE_STATUS_BYTE_23,CEE_STATUS_BYTE_23\n         MVC   LE_STATUS_BYTE_24,CEE_STATUS_BYTE_24\n         MVC   LE_STATUS_BYTE_25,CEE_STATUS_BYTE_25\n         MVC   LE_STATUS_BYTE_26,CEE_STATUS_BYTE_26\n         MVC   LE_STATUS_BYTE_27,CEE_STATUS_BYTE_27\n         MVC   LE_STATUS_BYTE_28,CEE_STATUS_BYTE_28\n         MVC   LE_STATUS_BYTE_29,CEE_STATUS_BYTE_29\n         B     LE370_INFO\n*============================================================*\n*    COBOL/2 Program                                         *\n*============================================================*\nCOBOL_2 DS 0H\n         USING COBOL_2_DSECT,R4\n         MVI   LE_SWITCH,C'2'\n         L     R4,C2_GET_ENTRY\n         L     R4,0(R4)\n         MVC   LE_VERS,C2_VERS\n         MVC   LE_REL,C2_REL\n         MVC   LE_MOD,C2_MOD\n         MVC   LE_PGM_NAME,C2_PGM_NAME\n         MVC   LE_COMP_DAY,C2_COMP_DAY\n         MVC   LE_COMP_MONTH,C2_COMP_MONTH\n         MVC   LE_COMP_YEAR(2),=C'??'    COBOL2 not Y2K ready\n         MVC   LE_COMP_YEAR+2(2),C2_COMP_YEAR\n         MVC   LE_COMP_HOURS,C2_COMP_HOURS\n         MVC   LE_COMP_MIN,C2_COMP_MIN\n         MVC   LE_COMP_SEC,C2_COMP_SEC\n         MVC   LE_DATA_STATEMENTS,C2_DATA_STATEMENTS\n         MVC   LE_PROC_LINES,C2_PROC_LINES\n         MVC   LE_STATUS_BYTE_01,C2_STATUS_BYTE_01\n         MVC   LE_STATUS_BYTE_02,C2_STATUS_BYTE_02\n         MVC   LE_STATUS_BYTE_03,C2_STATUS_BYTE_03\n         MVC   LE_STATUS_BYTE_04,C2_STATUS_BYTE_04\n         MVC   LE_STATUS_BYTE_05,C2_STATUS_BYTE_05\n         MVC   LE_STATUS_BYTE_06,C2_STATUS_BYTE_06\n         MVC   LE_STATUS_BYTE_07,C2_STATUS_BYTE_07\n         MVC   LE_STATUS_BYTE_08,C2_STATUS_BYTE_08\n         MVC   LE_STATUS_BYTE_09,C2_STATUS_BYTE_09\n         MVC   LE_STATUS_BYTE_10,C2_STATUS_BYTE_10\n         MVC   LE_STATUS_BYTE_11,C2_STATUS_BYTE_11\n         MVC   LE_STATUS_BYTE_12,C2_STATUS_BYTE_12\n         MVC   LE_STATUS_BYTE_13,C2_STATUS_BYTE_13\n         MVC   LE_STATUS_BYTE_14,C2_STATUS_BYTE_14\n         MVC   LE_STATUS_BYTE_15,C2_STATUS_BYTE_15\n         MVC   LE_STATUS_BYTE_16,C2_STATUS_BYTE_16\n         MVC   LE_STATUS_BYTE_17,C2_STATUS_BYTE_17\n         MVC   LE_STATUS_BYTE_18,C2_STATUS_BYTE_18\n         MVC   LE_STATUS_BYTE_19,C2_STATUS_BYTE_19\n         MVC   LE_STATUS_BYTE_20,C2_STATUS_BYTE_20\n         MVC   LE_STATUS_BYTE_21,C2_STATUS_BYTE_21\n         MVC   LE_STATUS_BYTE_22,C2_STATUS_BYTE_22\n         MVC   LE_STATUS_BYTE_23,C2_STATUS_BYTE_23\n         MVC   LE_STATUS_BYTE_24,C2_STATUS_BYTE_24\n         MVC   LE_STATUS_BYTE_25,C2_STATUS_BYTE_25\n         B     LE370_INFO\n*============================================================*\n* OS/VS COBOL   Program                                      *\n*============================================================*\nCOBOL_1 DS 0H\n         USING COBOL_1_DSECT,R4\n         MVI   LE_SWITCH,C'3'\n         MVC   LE_VERS,BLANKS\n         MVC   LE_REL,C1_REL\n         MVC   LE_MOD,BLANKS\n         MVC   LE_PGM_NAME,C1_PGM_NAME\n         MVC   LE_COMP_DAY,C1_COMP_DAY\n         MVC   LE_COMP_MONTH,C1_COMP_MONTH\n         MVC   LE_COMP_YEAR,C1_COMP_YEAR\n         MVC   LE_COMP_HOURS,C1_COMP_HOURS\n         MVC   LE_COMP_MIN,C1_COMP_MIN\n         MVC   LE_COMP_SEC,C1_COMP_SEC\n         L     R5,C1_TGT_PTR\n         USING COBOL_1_TGT,R5\n         CLC   C1_CHECK,=CL8'SYSOUT'     check\n         BE    LE370_INFO\n*\n*        UNABLE TO FIND THE TASK GLOBAL TABLE  -\n*\nNOTTGT   DS    0H\n         STRING 'Program ',PGMNAME_GET,' failed the TGT (Task Global', @\n               'Table) test',INTO=RECORD\n         BAL   R14,SPACE2\n         LA    R15,8\n         B     COBANAL_EXIT\nLE370_INFO DS  0H\n         STRING '============ Info ==================================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         CLI   LE_SWITCH,C'1'\n         BNE   JUMP_AROUND_1\n         STRING 'Program: ',PGMNAME_GET,' is COBOL/370 Version ',      X, *\n               LE_VERS,                                                X\n               ' Release ',LE_REL,' Mod-Level ',LE_MOD,INTO=RECORD\n         CLC   LE_VERS(4),=C'0301'  Vers+Rel < 0301 COBOL V3R1\n         BL    JUMP_AROUND_2         yes\n         STRING 'Program: ',PGMNAME_GET,' is COBOL Enterprise',        X, *\n               ' Version ',LE_VERS,                                    X\n               ' Release ',LE_REL,' Mod-Level ',LE_MOD,INTO=RECORD\n         B     JUMP_AROUND_2\nJUMP_AROUND_1 DS 0H\n         STRING 'Program: ',PGMNAME_GET,' is COBOL/2 Version ',LE_VERS,X*\n               ' Release ',LE_REL,' Mod-Level ',LE_MOD,INTO=RECORD\n         CLI   LE_SWITCH,C'2'\n         BE    JUMP_AROUND_2\n         STRING 'Program: ',PGMNAME_GET,' is OS/VS COBOL Release ',    XL, *\n               LE_REL,                                                 X\n               INTO=RECORD\nJUMP_AROUND_2 DS 0H\n         BAL   R14,SPACE2\n         STRING '============ Timestamps ============================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING 'Compiled program name ',LE_PGM_NAME,INTO=RECORD\n         BAL   R14,SPACE1\n         BAL   R9,LE_370_12\n         DC    CL2'01',CL3'Jan'      Long name\n         DC    CL2'02',CL3'Feb'      for our non-european user\n         DC    CL2'03',CL3'Mar'\n         DC    CL2'04',CL3'Apr'\n         DC    CL2'05',CL3'May'\n         DC    CL2'06',CL3'Jun'\n         DC    CL2'07',CL3'Jul'\n         DC    CL2'08',CL3'Aug'\n         DC    CL2'09',CL3'Sep'\n         DC    CL2'10',CL3'Okt'\n         DC    CL2'11',CL3'Nov'\n         DC    CL2'12',CL3'Dec'\n         DC    X'0000',CL3'n/a'             end of table\nLE_370_12 DS   0H\n         CLC   LE_COMP_MONTH(2),0(R9)         check properties\n         BE    LE_370_14               jump if on\n         LA    R9,5(,R9)              Skip entry\n         CLI   0(R9),0                 end of table?\n         BNE   LE_370_12               not yet, loop\nLE_370_14 DS   0H\n         STRING 'Date: ',LE_COMP_DAY,'.',(LE_COMP_MONTH,2),'.',        *\n               LE_COMP_YEAR,' (european) ',LE_COMP_DAY,'.',            *\n               (2(R9),3,T),'.',LE_COMP_YEAR,' (long) ',                *\n               ' Time: ',LE_COMP_HOURS,':',LE_COMP_MIN,                *\n               ':',LE_COMP_SEC,INTO=RECORD\n         CLI   LE_SWITCH,C'3'    OS/VS COBOL ?\n         BNE   JUMP_AROUND_3       no, go ahead\n         STRING 'Date: ',LE_COMP_DAY,'.',LE_COMP_MONTH,'.',            *\n               LE_COMP_YEAR,' Time: ',LE_COMP_HOURS,':',LE_COMP_MIN,   *\n               ':',LE_COMP_SEC,INTO=RECORD\n         BAL   R14,SPACE2\n         B     INFO_COBOL            sorry no more information\nJUMP_AROUND_3 DS 0H\n         BAL   R14,SPACE2\n         STRING '============ Statistics ============================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING 'Number of data items  : ',(LE_DATA_STATEMENTS,F,R7B), *\n               INTO=RECORD\n         BAL   R14,SPACE1\n         STRING 'Number of instructions: ',(LE_PROC_LINES,F,R7B),      *\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING '============ Options in effect =====================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         MVC   RECORD,BLANKS\n         LA    R15,RECORD\n         MVC   1(3,R15),=C'ADV'\n         TM    LE_STATUS_BYTE_01,BIT0\n         BO    *+10\n         MVC   1(5,R15),=C'NOADV'\n         LA    R15,8(R15)\n         MVC   0(5,R15),=C'APOST'\n         TM    LE_STATUS_BYTE_01,BIT1\n         BO    *+10\n         MVC   0(5,R15),=C'QUOTE'\n         LA    R15,8(R15)\n         MVC   RECORD+16(9),=CL9'DATA(31)'\n         TM    LE_STATUS_BYTE_01,BIT2\n         BO    *+10\n         MVC   RECORD+16(9),=CL9'DATA(24)'\n         MVC   RECORD+25(6),=CL6'DECK'\n         TM    LE_STATUS_BYTE_01,BIT3\n         BO    *+10\n         MVC   RECORD+25(6),=CL6'NODECK'\n         MVC   RECORD+33(6),=CL6'DUMP'\n         TM    LE_STATUS_BYTE_01,BIT4\n         BO    *+10\n         MVC   RECORD+33(6),=CL6'NODUMP'\n         MVC   RECORD+40(8),=CL8'DYNAM'\n         TM    LE_STATUS_BYTE_01,BIT5\n         BO    *+10\n         MVC   RECORD+40(8),=CL8'NODYNAM'\n         MVC   RECORD+51(10),=CL10'FASTSRT'\n         TM    LE_STATUS_BYTE_01,BIT6\n         BO    *+10\n         MVC   RECORD+51(10),=CL10'NOFASTSRT'\n         MVC   RECORD+62(8),=CL8'FDUMP'\n         TM    LE_STATUS_BYTE_01,BIT7\n         BO    *+10\n         MVC   RECORD+62(8),=CL8'NOFDUMP'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(6),=CL6'LIB'\n         TM    LE_STATUS_BYTE_02,BIT0\n         BO    *+10\n         MVC   RECORD+1(6),=CL6'NOLIB'\n         MVC   RECORD+8(7),=CL7'LIST'\n         TM    LE_STATUS_BYTE_02,BIT1\n         BO    *+10\n         MVC   RECORD+8(7),=CL7'NOLIST'\n         MVC   RECORD+16(9),=CL9'MAP'\n         TM    LE_STATUS_BYTE_02,BIT2\n         BO    *+10\n         MVC   RECORD+16(9),=CL9'NOMAP'\n         MVC   RECORD+25(6),=CL6'NUM'\n         TM    LE_STATUS_BYTE_02,BIT3\n         BO    *+10\n         MVC   RECORD+25(6),=CL6'NONUM'\n         MVC   RECORD+33(6),=CL6'OBJ'\n         TM    LE_STATUS_BYTE_02,BIT4\n         BO    *+10\n         MVC   RECORD+33(6),=CL6'NOOBJ'\n         MVC   RECORD+40(8),=CL8'OFFSET'\n         TM    LE_STATUS_BYTE_02,BIT5\n         BO    *+10\n         MVC   RECORD+40(8),=CL8'NOOFFSET'\n         MVC   RECORD+51(10),=CL10'OPTIMIZE'\n         TM    LE_STATUS_BYTE_02,BIT6\n         BO    *+10\n         MVC   RECORD+51(10),=CL10'NOOPTIMIZE'\n         CLI   LE_SWITCH,C'1'   COBOL/370\n         BNE   LE_370_18\n         CLC   LE_VERS(4),=C'0301'  Vers+Rel < 0301 COBOL V3R1\n         BL    LE_370_18             yes\n         MVC   RECORD+62(18),=CL18'OUTDD(SYSOUT)'\n         TM    LE_STATUS_BYTE_02,BIT7\n         BO    *+10\n         MVC   RECORD+62(18),=CL18'OUTDD(Supplied)'\n         BAL   R14,SPACE1\n         B     LE_370_19\nLE_370_18 DS 0H\n         MVC   RECORD+62(17),=CL17'OUTDD(Default)'\n         TM    LE_STATUS_BYTE_02,BIT7\n         BO    *+10\n         MVC   RECORD+62(17),=CL17'OUTDD(Supplied)'\n         BAL   R14,SPACE1\nLE_370_19 DS 0H\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(15),=CL15'NUMPROC(MIG)'\n         TM    LE_STATUS_BYTE_05,BIT0\n         BO    LE_370_21\n         MVC   RECORD+1(15),=CL15'NUMPROC(PFD)'\n         TM    LE_STATUS_BYTE_03,BIT0\n         BO    *+10\n         MVC   RECORD+1(15),=CL15'NUMPROC(NOPFD)'\nLE_370_21 DS 0H\n         MVC   RECORD+16(7),=CL7'RENT'\n         TM    LE_STATUS_BYTE_03,BIT1\n         BO    *+10\n         MVC   RECORD+16(7),=CL7'NORENT'\n         MVC   RECORD+25(6),=CL6'RES'\n         TM    LE_STATUS_BYTE_03,BIT2\n         BO    *+10\n         MVC   RECORD+25(6),=CL6'NORES'\n         MVC   RECORD+33(6),=CL6'SEQ'\n         TM    LE_STATUS_BYTE_03,BIT3\n         BO    *+10\n         MVC   RECORD+33(6),=CL6'NOSEQ'\n         MVC   RECORD+40(12),=CL12'SIZE(MAX)'\n         TM    LE_STATUS_BYTE_03,BIT4\n         BO    *+10\n         MVC   RECORD+40(12),=CL12'SIZE(value)'\n         MVC   RECORD+51(9),=CL9'SOURCE'\n         TM    LE_STATUS_BYTE_03,BIT5\n         BO    *+10\n         MVC   RECORD+51(9),=CL9'NOSOURCE'\n         MVC   RECORD+62(10),=CL10'SSRANGE'\n         TM    LE_STATUS_BYTE_03,BIT6\n         BO    *+10\n         MVC   RECORD+62(10),=CL10'NOSSRANGE'\n         MVC   RECORD+72(8),=CL8'TERM'\n         TM    LE_STATUS_BYTE_03,BIT7\n         BO    *+10\n         MVC   RECORD+72(8),=CL8'NOTERM'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(8),=CL8'TEST'\n         TM    LE_STATUS_BYTE_04,BIT0\n         BO    *+10\n         MVC   RECORD+1(8),=CL8'NOTEST'\n         MVC   RECORD+8(10),=CL11'TRUNC(BIN)'\n         TM    LE_STATUS_BYTE_05,BIT4\n         BO    LE_370_33\n         MVC   RECORD+8(10),=CL11'TRUNC(STD)'\n         TM    LE_STATUS_BYTE_04,BIT1\n         BO    *+10\n         MVC   RECORD+8(10),=CL11'TRUNC(OPT)'\nLE_370_33 DS 0H\n         MVC   RECORD+25(9),=CL9'WORD(xx)'\n         TM    LE_STATUS_BYTE_04,BIT2\n         BO    *+10\n         MVC   RECORD+25(9),=CL9'NOWORD'                                t'\n         MVC   RECORD+33(8),=CL8'VBREF'\n         TM    LE_STATUS_BYTE_04,BIT3\n         BO    *+10\n         MVC   RECORD+33(8),=CL8'NOVBREF'\n         MVC   RECORD+40(6),=CL6'XREF'\n         TM    LE_STATUS_BYTE_04,BIT4\n         BO    *+10\n         MVC   RECORD+40(6),=CL6'NOXREF'\n         MVC   RECORD+51(6),=CL6'ZWB'\n         TM    LE_STATUS_BYTE_04,BIT5\n         BO    *+10\n         MVC   RECORD+51(6),=CL6'NOZWB'\n         MVC   RECORD+62(7),=CL7'NAME'\n         TM    LE_STATUS_BYTE_04,BIT6\n         BO    *+10\n         MVC   RECORD+62(7),=CL7'NONAME'\n         CLC   LE_VERS(4),=C'0300'  Vers+Rel > 0300 COBOL V3R1   RS0301\n         BH    LE_370_40             yes, CMPR2 no longer valid  RS0301\n         MVC   RECORD+72(8),=CL8'CMPR2'\n         TM    LE_STATUS_BYTE_04,BIT7\n         BO    *+10\n         MVC   RECORD+72(8),=CL8'NOCMPR2'\nLE_370_40 DS 0H\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(12),=CL12'NUMCLS'  other Cobol\n         TM    LE_STATUS_BYTE_05,BIT1\n         BO    *+10\n         MVC   RECORD+1(12),=CL12'NONUMCLS'\n         CLI   LE_SWITCH,C'1'   COBOL/370\n         BNE   LE_370_42\n         CLC   LE_VERS(4),=C'0102'  Vers+Rel < 0102 COBOL MVS and VM\n         BL    LE_370_42             yes\n         MVC   RECORD+1(12),=CL12'NUMCLS(ALT)'\n         TM    LE_STATUS_BYTE_05,BIT1\n         BO    *+10\n         MVC   RECORD+1(12),=CL12'NUMCLS(PRIM)'\nLE_370_42 DS 0H\n         MVC   RECORD+16(7),=CL7'DBCS'\n         TM    LE_STATUS_BYTE_05,BIT2\n         BO    *+10\n         MVC   RECORD+16(7),=CL7'NODBCS'\n         MVC   RECORD+25(6),=CL6'AWO'\n         TM    LE_STATUS_BYTE_05,BIT3\n         BO    *+10\n         MVC   RECORD+25(6),=CL6'NOAWO'\n         CLI   LE_SWITCH,C'1'                  Cobol/370\n         BNE   LE_370_48                       no, jump around\n         MVC   RECORD+33(9),=CL9'EVENTS'       n/a COBOL/2\n         TM    LE_STATUS_BYTE_05,BIT5\n         BO    *+10\n         MVC   RECORD+33(9),=CL9'NOEVENTS'\n         MVC   RECORD+51(11),=CL11'CURRENCY'   n/a COBOL/2\n         TM    LE_STATUS_BYTE_05,BIT6\n         BO    *+10\n         MVC   RECORD+51(11),=CL11'NOCURRENCY'\nLE_370_48 DS 0H\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(40),=CL40'Compilation unit = Class'\n         TM    LE_STATUS_BYTE_05,BIT7\n         BO    *+10\n         MVC   RECORD+1(40),=CL40'Compilation unit = Program'\n         CLI   LE_SWITCH,C'1'   COBOL/370 ?\n         BNE   LE_370_50Z         no\n         CLC   LE_VERS(4),=C'0102'  Vers+Rel < 0102 COBOL MVS and VM\n         BL    LE_370_50Z         no\n*                         Supported only for COBOL MVS and VM R2\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(11),=CL11'RMODE(ANY)'\n         TM    LE_STATUS_BYTE_26,BIT0\n         BO    *+10\n         MVC   RECORD+1(11),=CL11'RMODE(24)'\n         MVC   RECORD+16(13),=CL13'TEST(STMT)'\n         TM    LE_STATUS_BYTE_26,BIT1\n         BO    *+10\n         MVC   RECORD+16(13),=CL13'NO TEST(STMT)'\n         MVC   RECORD+33(13),=CL13'TEST(PATH)'\n         TM    LE_STATUS_BYTE_26,BIT2\n         BO    *+10\n         MVC   RECORD+33(13),=CL13'NO TEST(PATH)'\n         MVC   RECORD+51(14),=CL14'TEST(BLOCK)'\n         TM    LE_STATUS_BYTE_26,BIT3\n         BO    *+10\n         MVC   RECORD+51(14),=CL14'NO TEST(BLOCK)'\n         MVC   RECORD+72(17),=CL17'OPT(FULL)'\n         TM    LE_STATUS_BYTE_26,BIT4\n         BO    *+10\n         MVC   RECORD+72(17),=CL17'NOOPT OR OPT(STD)'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(13),=CL13'INTDATE(LIL)'\n         TM    LE_STATUS_BYTE_26,BIT5\n         BO    *+10\n         MVC   RECORD+1(13),=CL13'INTDATE(ANSI)'\n         MVC   RECORD+16(3),=CL3'N/A'                            RS1000\n         CLC   LE_VERS(4),=C'0202'  Vers+Rel < 0202 COBOL MVS and VM\n         BL    LE_370_50Y           no lower                     RS1000\n         MVC   RECORD+16(14),=CL14'TEST(SEPARATE)'               RS1000\n         TM    LE_STATUS_BYTE_26,BIT6                            RS1000\n         BO    *+10                                              RS1000\n         MVC   RECORD+16(17),=CL17'NO TEST(SEPARATE)'            RS1000\nLE_370_50Y DS  0H\n         MVC   RECORD+35(22),=CL22'PGMNAME(LONGUPPER)'\n         TM    LE_STATUS_BYTE_27,BIT0\n         BO    *+10\n         MVC   RECORD+35(22),=CL22'NOT PGMNAME(LONGUPPER)'\n         MVC   RECORD+60(22),=CL22'PGMNAME(LONGMIXED)'\n         TM    LE_STATUS_BYTE_27,BIT1\n         BO    *+10\n         MVC   RECORD+60(22),=CL22'NOT PGMNAME(LONGMIXED)'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(5),=CL5'DLL'\n         TM    LE_STATUS_BYTE_27,BIT2\n         BO    *+10\n         MVC   RECORD+1(5),=CL5'NODLL'\n         MVC   RECORD+16(11),=CL11'EXPORTALL'\n         TM    LE_STATUS_BYTE_27,BIT3\n         BO    *+10\n         MVC   RECORD+16(11),=CL11'NOEXPORTALL'\n         MVC   RECORD+33(10),=CL10'DATEPROC'\n         TM    LE_STATUS_BYTE_27,BIT4\n         BO    *+10\n         MVC   RECORD+33(10),=CL10'NODATEPROC'\n         STRING (RECORD,,L),1X,'YEARWINDOW(',(LE_YEAR_WINDOW,H,R4B),   *\n               ')',INTO=RECORD\n         CLC   LE_VERS(4),=C'0202'  Vers+Rel < 0202 COBOL MVS and VM\n         BL    LE_370_50Z           no lower                     RS1000\n         MVC   RECORD+62(13),=CL13'ARITH(EXTEND)'                RS1000\n         TM    LE_STATUS_BYTE_27,BIT5                            RS1000\n         BO    *+10                                              RS1000\n         MVC   RECORD+62(13),=CL13'ARITH(COMPAT)'                RS1000\n         CLI   LE_SWITCH,C'1'   COBOL/370\n         BNE   LE_370_50Z\n         CLC   LE_VERS(4),=C'0301'  Vers+Rel < 0301 COBOL V3R1\n         BL    LE_370_50Z            yes\n         MVC   RECORD+76(11),=CL11'THREAD(YES)'\n         TM    LE_STATUS_BYTE_27,BIT6\n         BO    *+10\n         MVC   RECORD+76(11),=CL11'THREAD(NO)'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         STRING (RECORD,,L),1X,'CODEPAGE(',(LE_CCSID,H,R4B),')',       X\n               INTO=RECORD\nLE_370_50Z DS 0H\n         BAL   R14,SPACE2\n         STRING '============ Additional information ================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE1\n         STRING '============ about DATA DIVISION    ================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING 'Program use',' no',' QSAM or SAM access method',      *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT0\n         BNO   LE_370_51\n         STRING 'Program use',' QSAM or SAM access method',INTO=RECORD\nLE_370_51 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' VSAM sequential files',          *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT1\n         BNO   LE_370_52\n         STRING 'Program use',' VSAM sequential files',INTO=RECORD\nLE_370_52 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' VSAM indexed files',INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT2\n         BNO   LE_370_53\n         STRING 'Program use',' VSAM indexed files',INTO=RECORD\nLE_370_53 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' VSAM RBA files',INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT3\n         BNO   LE_370_54\n         STRING 'Program use',' VSAM RBA files',INTO=RECORD\nLE_370_54 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' CODE-SET (ASCII files)',         *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT4\n         BNO   LE_370_55\n         STRING 'Program use',' CODE-SET (ASCII files)',INTO=RECORD\nLE_370_55 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' spanned records',INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT5\n         BNO   LE_370_56\n         STRING 'Program use',' spanned records',INTO=RECORD\nLE_370_56 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' picture G (DBCS) items',         *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT6\n         BNO   LE_370_57\n         STRING 'Program has',' picture G (DBCS) items',INTO=RECORD\nLE_370_57 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' OCCURS DEPENDING ON items',      *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT7\n         BNO   LE_370_58\n         STRING 'Program has',' OCCURS DEPENDING ON items',INTO=RECORD\nLE_370_58 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' SYNCHRONIZED clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT0\n         BNO   LE_370_59\n         STRING 'Program has',' SYNCHRONIZED clause',INTO=RECORD\nLE_370_59 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' JUSTIFIED clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT1\n         BNO   LE_370_60\n         STRING 'Program has',' JUSTIFIED clause',INTO=RECORD\nLE_370_60 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' POINTER items',INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT2\n         BNO   LE_370_61\n         STRING 'Program has',' POINTER items',INTO=RECORD\nLE_370_61 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' complex ODO clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT3\n         BNO   LE_370_62\n         STRING 'Program has',' complex ODO clause',INTO=RECORD\nLE_370_62 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' external',                       *\n               ' floating-point items',                                *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT4\n         BNO   LE_370_63\n         STRING 'Program has',' external',' floating-point items',     *\n               INTO=RECORD\nLE_370_63 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' internal',                       *RD\n               ' floating-point items',                                *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT5\n         BNO   LE_370_63_1\n         STRING 'Program has',' internal',' floating-point items',     *\n               INTO=RECORD\nLE_370_63_1 DS 0H\n         CLI   LE_SWITCH,C'1'                  Cobol/370\n         BNE   LE_370_64                       no, jump around\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' Proc-Pointer or Func-Pointer ',  X\n               'items',INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT7\n         BNO   LE_370_63_2\n         STRING 'Program has',' Proc or Func-Pointer items',INTO=RECORD\nLE_370_63_2 DS 0H\n         CLC   LE_VERS(4),=C'0202'  Vers+Rel < 0202 COBOL MVS and VM\n         BL    LE_370_64            no lower                     RS1000\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' Line-sequential file',           *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT6\n         BNO   LE_370_64\n         STRING 'Program has',' Line-sequential file',                 *\n               INTO=RECORD\nLE_370_64 DS 0H\n         BAL   R14,SPACE2\n         STRING '============ Additional information    =============',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE1\n         STRING '============ about ENVIROMENT DIVISION =============',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING 'Program use',' no',' FILE-STATUS clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_08,BIT0\n         BNO   LE_370_66\n         STRING 'Program use',' FILE-STATUS clause',INTO=RECORD\nLE_370_66 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' RERUN clause in I/O-control',    *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_08,BIT1\n         BNO   LE_370_67\n         STRING 'Program has',' RERUN clause in I/O-control',          *\n               INTO=RECORD\nLE_370_67 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' UPSI switches',INTO=RECORD\n         TM    LE_STATUS_BYTE_08,BIT2\n         BNO   LE_370_68\n         STRING 'Program use',' UPSI switches',INTO=RECORD\nLE_370_68 DS 0H\n         BAL   R14,SPACE2\n         STRING '============ Additional information    =============',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE1\n         STRING '============ about PROCEDURE DIVISION  =============',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING 'Following statements in control (check Y/N):',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(6),=CL6'Accept'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_09,BIT0\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(3),=CL3'Add'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_09,BIT1\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(5),=CL5'Alter'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_09,BIT2\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(4),=CL4'Call'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_09,BIT3\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(6),=CL6'Cancel'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_09,BIT4\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(5),=CL5'Close'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_09,BIT6\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(7),=CL7'Compute'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_10,BIT0\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(6),=CL6'Delete'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_10,BIT2\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(7),=CL7'Display'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_10,BIT4\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(6),=CL6'Divide'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_10,BIT5\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(11),=CL11'End-Perform'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_11,BIT1\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(5),=CL5'Enter'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_11,BIT2\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(5),=CL5'Entry'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_11,BIT3\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(4),=CL4'Exit'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_11,BIT4\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(5),=CL5'Go to'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_11,BIT6\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(2),=CL2'If'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_11,BIT7\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(10),=CL10'Initialize'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_12,BIT0\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         CLI   LE_SWITCH,C'1'   COBOL/370 ?\n         BNE   LE_370_70          no, jump around\n         MVC   RECORD+86(6),=CL6'Invoke'   comes with COBOL/370\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_12,BIT1\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\nLE_370_70 DS 0H\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(7),=CL7'Inspect'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_12,BIT2\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(5),=CL5'Merge'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_12,BIT3\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(4),=CL4'Move'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_12,BIT4\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(8),=CL8'Multiply'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_12,BIT5\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(4),=CL4'Open'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_12,BIT6\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(7),=CL7'Perform'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_12,BIT7\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(4),=CL4'Read'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_13,BIT0\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(7),=CL7'Release'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_13,BIT2\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(6),=CL6'Return'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_13,BIT3\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(7),=CL7'Rewrite'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_13,BIT4\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(6),=CL6'Search'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_13,BIT5\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(3),=CL3'Set'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_13,BIT7\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(4),=CL4'Sort'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_14,BIT0\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(5),=CL5'Start'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_14,BIT1\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(4),=CL4'Stop'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_14,BIT2\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(6),=CL6'String'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_14,BIT3\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(8),=CL8'Subtract'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_14,BIT4\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(8),=CL8'Unstring'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_14,BIT7\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(3),=CL3'Use'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_15,BIT0\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(5),=CL5'Write'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_15,BIT1\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(8),=CL8'Continue'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_15,BIT2\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(7),=CL7'End-Add'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_15,BIT3\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(8),=CL8'End-Call'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_15,BIT4\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(11),=CL11'End-Compute'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_15,BIT5\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(10),=CL10'End-Delete'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_15,BIT6\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(10),=CL10'End-Divide'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_15,BIT7\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(12),=CL12'End-Evaluate'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_16,BIT0\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(6),=CL6'End-If'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_16,BIT1\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(11),=CL11'End-Muliply'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_16,BIT2\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(8),=CL8'End-Read'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_16,BIT3\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(10),=CL10'End-Return'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_16,BIT4\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(11),=CL11'End-Rewrite'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_16,BIT5\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(10),=CL10'End-Search'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_16,BIT6\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(9),=CL9'End-Start'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_16,BIT7\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(10),=CL10'End-String'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_17,BIT0\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(12),=CL12'End-Subtract'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_17,BIT1\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(12),=CL12'End-Unstring'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_17,BIT2\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(9),=CL9'End-Write'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_17,BIT3\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(6),=CL6'Goback'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_17,BIT4\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(9),=CL9'Evaluate'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_17,BIT5\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(7),=CL7'Service'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_17,BIT7\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(10),=CL10'End-Invoke'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_18,BIT0\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         CLI   LE_SWITCH,C'1'   COBOL/370\n         BNE   LE_370_125\n         CLC   LE_VERS(4),=C'0301'  Vers+Rel < 0301 COBOL V3R1\n         BL    LE_370_125            yes\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(10),=CL10'Exec'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_11,BIT5\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(9),=CL9'End-Exec'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_18,BIT2\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(9),=CL9'End-Exec'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_18,BIT2\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(3),=CL3'XML'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_18,BIT3\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(3),=CL3'END-XML'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_18,BIT3\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         BAL   R14,SPACE1\nLE_370_125 DS 0H\n         STRING '====================================================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING 'No hexadecimal literals',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT0\n         BNO   LE_370_128\n         STRING 'Procedure include hexadecimal literals',INTO=RECORD\nLE_370_128 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No altered GO TO',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT1\n         BNO   LE_370_129\n         STRING 'Program contains altered GO TO',INTO=RECORD\nLE_370_129 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','I/O error declarative',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT2\n         BNO   LE_370_130\n         STRING 'I/O error declarative',INTO=RECORD\nLE_370_130 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Label declarative',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT3\n         BNO   LE_370_131\n         STRING 'Label declarative',INTO=RECORD\nLE_370_131 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Debugging declarative',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT4\n         BNO   LE_370_132\n         STRING 'Debugging declarative',INTO=RECORD\nLE_370_132 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Program segmentation',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT5\n         BNO   LE_370_133\n         STRING 'Program segmentation',INTO=RECORD\nLE_370_133 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Open Extend',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT6\n         BNO   LE_370_134\n         STRING 'Open Extend',INTO=RECORD\nLE_370_134 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Exit Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT7\n         BNO   LE_370_135\n         STRING 'Exit Program',INTO=RECORD\nLE_370_135 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No call literal',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT0\n         BNO   LE_370_136\n         STRING 'Call literal (static?), see options',INTO=RECORD\nLE_370_136 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Call identifier',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT1\n         BNO   LE_370_137\n         STRING 'Call identifier',INTO=RECORD\nLE_370_137 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Call on overflow',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT2\n         BNO   LE_370_138\n         STRING 'Call on overflow',INTO=RECORD\nLE_370_138 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Call length of',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT3\n         BNO   LE_370_139\n         STRING 'Call length of',INTO=RECORD\nLE_370_139 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Call address of',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT4\n         BNO   LE_370_140\n         STRING 'Call address of',INTO=RECORD\nLE_370_140 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Close reel/unit',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT5\n         BNO   LE_370_141\n         STRING 'Close reel/unit',INTO=RECORD\nLE_370_141 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Exponentiation used',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT6\n         BNO   LE_370_142\n         STRING 'Exponentiation used',INTO=RECORD\nLE_370_142 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Floating point items used',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT7\n         BNO   LE_370_143\n         STRING 'Floating point items used',INTO=RECORD\nLE_370_143 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Copy-Statements',INTO=RECORD\n         TM    LE_STATUS_BYTE_23,BIT0\n         BNO   LE_370_144\n         STRING 'Copy-Statements',INTO=RECORD\nLE_370_144 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Basis-Statements',INTO=RECORD\n         TM    LE_STATUS_BYTE_23,BIT1\n         BNO   LE_370_145\n         STRING 'Basis-Statements',INTO=RECORD\nLE_370_145 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','DBCS-Name in Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_23,BIT2\n         BNO   LE_370_146\n         STRING 'DBCS-Name in Program',INTO=RECORD\nLE_370_146 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Shift-In/Shift-Out',INTO=RECORD\n         TM    LE_STATUS_BYTE_23,BIT3\n         BNO   LE_370_147\n         STRING 'Shift-In/Shift-Out',INTO=RECORD\nLE_370_147 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','DBCS literal',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT0\n         BNO   LE_370_148\n         STRING 'DBCS literal',INTO=RECORD\nLE_370_148 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Replace-Statements',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT1\n         BNO   LE_370_149\n         STRING 'Replace-Statements',INTO=RECORD\nLE_370_149 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Reference modification was used',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT2\n         BNO   LE_370_150\n         STRING 'Reference modification was used',INTO=RECORD\nLE_370_150 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Nested Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT3\n         BNO   LE_370_151\n         STRING 'Nested Program',INTO=RECORD\nLE_370_151 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','INITIAL Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT4\n         BNO   LE_370_152\n         STRING 'INITIAL Program',INTO=RECORD\nLE_370_152 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','COMMON Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT5\n         BNO   LE_370_153\n         STRING 'COMMON Program',INTO=RECORD\nLE_370_153 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Select Optional Files',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT6\n         BNO   LE_370_154\n         STRING 'Select Optional Files',INTO=RECORD\nLE_370_154 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','External Files',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT7\n         BNO   LE_370_155\n         STRING 'External Files',INTO=RECORD\nLE_370_155 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Global Files',INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT0\n         BNO   LE_370_156\n         STRING 'Global Files',INTO=RECORD\nLE_370_156 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Record is varying clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT1\n         BNO   LE_370_157\n         STRING 'Record is varying clause',INTO=RECORD\nLE_370_157 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Accept from SYSIPT used in Label Declarative',  *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT2\n         BNO   LE_370_158\n         STRING 'Accept from SYSIPT used in Label Declarative',        *\n               INTO=RECORD\nLE_370_158 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Display upon SYSLST used in Label Declarative', *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT3\n         BNO   LE_370_159\n         STRING 'Display upon SYSLST used in Label Declarative',       *\n               INTO=RECORD\nLE_370_159 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Display upon SYSPCH used in Label Declarative', *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT4\n         BNO   LE_370_160\n         STRING 'Display upon SYSPCH used in Label Declarative',       *\n               INTO=RECORD\nLE_370_160 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Intrinsic function was used',INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT5\n         BNO   LE_370_161\n         STRING 'Intrinsic function was used',INTO=RECORD\nLE_370_161 DS 0H\n         CLI   LE_SWITCH,C'1'   COBOL/370\n         BNE   LE_370_177\n         CLC   LE_VERS(4),=C'0301'  Vers+Rel < 0301 COBOL V3R1\n         BL    LE_370_177            yes\n         BAL   R14,SPACE1\n         STRING 'No ','Function Random was used',INTO=RECORD\n         TM    LE_STATUS_BYTE_29,BIT1\n         BNO   LE_370_162\n         STRING 'Function Random was used',INTO=RECORD\nLE_370_162 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Java-based OO syntax was used',INTO=RECORD\n         TM    LE_STATUS_BYTE_29,BIT0\n         BNO   LE_370_163\n         STRING 'Java-based OO syntax was used',INTO=RECORD\nLE_370_163 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','National data was used',INTO=RECORD\n         TM    LE_STATUS_BYTE_29,BIT0\n         BNO   LE_370_177\n         STRING 'National data was used',INTO=RECORD\nLE_370_177 DS 0H\n         BAL   R14,SPACE1\n         STRING '============ End  ==================================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         LA    R15,0\n         B     COBANAL_EXIT\nINFO_COBOL DS 0H\n         CLI   C1_OEM_MOD_AREA,X'00' low-value ?                 RS0700\n         BE    INFO_COBOL_OEM                                    RS0700\n         STRING '============ OEM Modified Area =====================',*\n               '=============================================',        *RD\n               INTO=RECORD                                       RS0700\n         BAL   R14,SPACE2                                        RS0700\n         STRING ' ',C1_OEM_MOD_AREA,INTO=RECORD                  RS0700\n         BAL   R14,SPACE2                                        RS0700\nINFO_COBOL_OEM DS 0H                                             RS0700\n         STRING '============ Options in effect =====================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(8),=CL8'SYMDMP'\n         TM    C1_STATUS_BYTE_01,X'08'\n         BO    *+10\n         MVC   RECORD+1(8),=CL8'NOSYMDMP'\n         MVC   RECORD+10(6),=CL6'FLOW'\n         TM    C1_STATUS_BYTE_01,X'04'\n         BO    *+10\n         MVC   RECORD+10(6),=CL6'NOFLOW'\n         MVC   RECORD+17(7),=CL7'STATE'\n         TM    C1_STATUS_BYTE_01,X'02'\n         BO    *+10\n         MVC   RECORD+17(7),=CL7'NOSTATE'\n         MVC   RECORD+25(6),=CL6'OPT'\n         TM    C1_STATUS_BYTE_01,X'01'\n         BO    *+10\n         MVC   RECORD+25(6),=CL6'NOOPT'\n         MVC   RECORD+32(6),=CL6'TEST'\n         TM    C1_STATUS_BYTE_02,X'10'\n         BO    *+10\n         MVC   RECORD+32(6),=CL6'NOTEST'\n         MVC   RECORD+39(6),=CL6'RES'\n         TM    C1_STATUS_BYTE_03,X'80'\n         BO    *+10\n         MVC   RECORD+39(6),=CL6'NORES'\n         MVC   RECORD+46(8),=CL8'ENDJOB'\n         TM    C1_STATUS_BYTE_03,X'40'\n         BO    *+10\n         MVC   RECORD+46(8),=CL8'NOENDJOB'\n         MVC   RECORD+55(8),=CL8'OBJ370'\n         TM    C1_STATUS_BYTE_03,X'20'\n         BO    *+10\n         MVC   RECORD+55(8),=CL8'NOOBJ370'\n         MVC   RECORD+64(8),=CL8'COUNT'\n         TM    C1_STATUS_BYTE_03,X'08'\n         BO    *+10\n         MVC   RECORD+64(8),=CL8'NOCOUNT'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(11),=CL11'READY TRACE'\n         TM    C1_STATUS_BYTE_03,X'04'\n         BO    *+10\n         MVC   RECORD+1(11),=CL11'NO TRACE'\n         BAL   R14,SPACE1\n         STRING 'Sorry no more infomation for OS/VS COBOL',INTO=RECORD\n         BAL   R14,SPACE1\n         STRING 'You better upgrade to COBOL for OS/390 (MVS) and VM', *\n               INTO=RECORD\n         BAL   R14,SPACE1\n         STRING '============ End  ==================================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         LA    R15,0\n         B     COBANAL_EXIT\n*============================================================*\n* Print                                                      *\n*============================================================*\nSPACE2   DS 0H\n         ST    R14,SAVER14\n         LA    R1,SYSPRINT         GET OUTPUT DCB ADDRESS\n         LA    R0,RECORD           GET OBJECT NAME ADDRESS\n         PUT   (1),(0)             WRITE NAME TO NOTIFY DATA SET\n         LA    R1,SYSPRINT         GET OUTPUT DCB ADDRESS\n         LA    R0,BLANKS           GET OBJECT NAME ADDRESS\n         BAS   R14,AMODE24             AMode24\n         PUT   (1),(0)             WRITE NAME TO NOTIFY DATA SET\n         BAS   R14,AMODE31             AMode31\n         L     R14,SAVER14\n         BR    R14            return\nSPACE1   DS 0H\n         ST    R14,SAVER14\n         LA    R1,SYSPRINT         GET OUTPUT DCB ADDRESS\n         LA    R0,RECORD           GET OBJECT NAME ADDRESS\n         BAS   R14,AMODE24             AMode24\n         PUT   (1),(0)             WRITE NAME TO NOTIFY DATA SET\n         BAS   R14,AMODE31             AMode31\n         L     R14,SAVER14\n         BR    R14            return\n***************************************************************\n*\n*                  get Member Name from PDS-Directory\n*\n***************************************************************\nGETMEM   EQU   *\n         ST    R14,GETMSAVE            save return address\n         L     R4,ADBLKPTR             restore pointer\n         CLC   DIRAREA(2),=XL2'0000'   Directory present?\n         BNE   NEWNAME                   yes, get next\nNEWBLOCK EQU   *\n         BAS   R14,AMODE24             Amode24\n         GET   INPUT,DIRAREA           get a new directory\n         BAS   R14,AMODE31             Amode24\n         LA    R4,DIRAREA              get work area address\n         AH    R4,DIRAREA              + length\n         ST    R4,ADBLKEND             save ending address\n         LA    R4,DIRAREA+2            Skip LL bytes\n         ST    R4,ADBLKPTR             save pointer\nNEWNAME  EQU   *\n         C     R4,ADBLKEND             end of current dir block\n         BNL   NEWBLOCK                  yes, get new block\n         MVC   PGMNAME_GET,0(R4)       Save member-name\n         IC    R5,11(R4)               LOOK FOR ANY USER TTRN'S\n         SLL   R5,27                   SHIFT OFF UNWANTED BITS\n         SRL   R5,26                   SHIFT BACK THE USABLE BI\n         LA    R4,12(R4,R5)            ADD DISPL TO GET OVER TT\n         ST    R4,ADBLKPTR             save Pointer next mem\n         L     R14,GETMSAVE            restore return address\n         BR    R14                     goback\nAMODE24  LA    R14,0(,R14)             remove XA bit\n         BSM   R0,R14                  return\n         SPACE 2\nAMODE31  O     R14,HIBIT               add XA bit\n         BSM   R0,R14                  return\n*\n*============================================================*\n* SONSTIGE DEFINITIONS                                       *\n*============================================================*\n****************************** CONSTANTS *****************************\nC_COBOL370 DC X'00',C'CEE'                   COBOL/370 ?  X'00C3C5C5'\nC_OPLINK   DC X'01',C'CEE'                   COBOL/370 ?  X'01C3C5C5'\nHIBIT    DC    A(X'80000000')         XA BIT CONSTANS\nBLANKS   DC    CL255' '           just blanks\nC_LSTO   OPEN  (*-*,(OUTPUT)),MF=L\nC_LSTOL  EQU   *-C_LSTO\nC_LSTI   OPEN  (*-*,(INPUT)),MF=L\nC_LSTIL  EQU   *-C_LSTI\nC_CLOSE  CLOSE (*-*),MF=L\nC_CLOSEL EQU   *-C_CLOSE\nXFF      DC    XL8'FFFFFFFFFFFFFFFF' just High-value\nSYSPRINT_FIX DCB   DSORG=PS,DDNAME=SYSPRINT,MACRF=PM,                  *\n               RECFM=FB,LRECL=121\nSYSPRINT_FIX_LENGTH EQU *-SYSPRINT_FIX   Length workarea\nINPUT_FIX DCB   DSORG=PS,DDNAME=COBANAL,MACRF=(GM),                    *\n               RECFM=U,BLKSIZE=256\n*INPUT_FIX DCB   DSORG=PO,DDNAME=COBANAL,MACRF=(R),                    *\n               RECFM=U,BLKSIZE=256\nINPUT_FIX_LENGTH EQU *-INPUT_FIX     Length workarea\n*\n*============================================================*\n* Workarea below the line                                    *\n*============================================================*\nCOBANAL_WORK        DSECT\nEYECATCHER          DS    CL8   'COBANAL'\nPGMNAME             DS    CL8   Pgmname from the parmlist\nPGMNAME_GET         DS    CL8   Pgmname from GETMEM\nSAVEAREA            DS    18F\nSAVER14             DS    F\nRETCODE             DS    F\nADR_COBANAL_WORK    DS    F     Save Workarea pointer\nADR_COBANAL_PARM    DS    F     Save Parmlist pointer\nADR_PGMNAME         DS    F     Save entry-point Application PGM\nRC_PGMNAME          DS    F     Save application RC\nPARM_LENGTH         DS    H     Parm length wihout header\nGETMSAVE            DS    F     Parm length wihout header\nADBLKPTR            DS    F     Parm length wihout header\nADBLKEND            DS    F     Parm length wihout header\nDOALL               DS    CL1   Analyze a complete loadlib\nDD_COBANAL          DS    CL1   Switch for DD CobAnal\nDOUBLE              DS    D\nCSV_LENGTH          DS    F     Length returned by CSVQuery\nCSV_LOADPT          DS    F     Length returned by CSVQuery\n         CSVQUERY MF=(L,CSVQRYWK)\n         ASAXWC    MF=(L,MYLIST)\n****************************** VARIABLES *****************************\nLE_SWITCH           DS    CL1   Switch for COBOL/370 or COBOL/2\nLE_PGM_NAME         DS CL8  name of program\nLE_COMP_YEAR        DS CL4  year of compilation\n*  3 bytes because of OS/VS COBOL\nLE_COMP_MONTH       DS CL3  month of compilation\nLE_COMP_DAY         DS CL2  day of compilation\nLE_COMP_HOURS       DS CL2  hours of compilation\nLE_COMP_MIN         DS CL2  minutes of compilation\nLE_COMP_SEC         DS CL2  seconds of compilation\nLE_VERS             DS CL2  version\nLE_REL              DS CL2  release\nLE_MOD              DS CL2  modification level\nLE_CCSID            DS XL2  Codepage\nLE_STATUS_BYTE      DS    0C   signature bytes\nLE_STATUS_BYTE_01   DS X    status byte\nLE_STATUS_BYTE_02   DS X    status byte\nLE_STATUS_BYTE_03   DS X    status byte\nLE_STATUS_BYTE_04   DS X    status byte\nLE_STATUS_BYTE_05   DS X    status byte\nLE_STATUS_BYTE_06   DS X    status byte\nLE_STATUS_BYTE_07   DS X    status byte\nLE_STATUS_BYTE_08   DS X    status byte\nLE_STATUS_BYTE_09   DS X    status byte\nLE_STATUS_BYTE_10   DS X    status byte\nLE_STATUS_BYTE_11   DS X    status byte\nLE_STATUS_BYTE_12   DS X    status byte\nLE_STATUS_BYTE_13   DS X    status byte\nLE_STATUS_BYTE_14   DS X    status byte\nLE_STATUS_BYTE_15   DS X    status byte\nLE_STATUS_BYTE_16   DS X    status byte\nLE_STATUS_BYTE_17   DS X    status byte\nLE_STATUS_BYTE_18   DS X    status byte\nLE_STATUS_BYTE_19   DS X    status byte\nLE_STATUS_BYTE_20   DS X    status byte\nLE_STATUS_BYTE_21   DS X    status byte\nLE_STATUS_BYTE_22   DS X    status byte\nLE_STATUS_BYTE_23   DS X    status byte\nLE_STATUS_BYTE_24   DS X    status byte\nLE_STATUS_BYTE_25   DS X    status byte\nLE_STATUS_BYTE_26   DS X    status byte Cobol for MVS and VM\nLE_STATUS_BYTE_27   DS X    status byte Cobol for MVS and VM\nLE_STATUS_BYTE_28   DS X    status byte Cobol V3R1\nLE_STATUS_BYTE_29   DS X    status byte Cobol V3R1\nLE_COBOL_SIGNAT     DS X    cobol signature level\nLE_DATA_STATEMENTS  DS XL4  number of data items\nLE_PROC_LINES       DS XL4  number of proc statements\nLE_YEAR_WINDOW      DS H    YearWindow\nSYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,                      *\n               RECFM=FB,LRECL=121\nINPUT    DCB   DSORG=PS,DDNAME=COBANAL,MACRF=(GM),                     *\n               RECFM=U,BLKSIZE=256\nDIRAREA             DS    XL256 PDS-Directory input area\nPARMLIST            DS XL40\nRECORD              DS CL132\nCOBANAL_WORK_LENGTH EQU *-COBANAL_WORK  Length workarea\n*\n*============================================================*\n* Parameter (JCL)                                            *\n*============================================================*\nCOBANAL_PARM        DSECT\nCOBANAL_PARM_LENGTH DS H\n*\n*\n*============================================================*\n* COBOL/370 DCL\n*============================================================*\nCOBOL_370_DSECT     DSECT\n                    DS CL4  bypass\nCEE_EYECATCHER      DS CL4  excatcher\nCEE_STACK_FRAME     DS F    stack frame size\nCEE_PPA1_OFFSET     DS F    offset to first ppa1\n                    DS CL4  reserved\nCEE_PPA1_START      DS 0C\nCEE_OFFSET          DS X    offset to length of name from ppa1\nCEE_SIGNATURE       DS X    CEL-Signature\nCEE_FLAG1           DS X    CEL-FLAGS Bitmask\nCEE_FLAG2           DS X    Member Flags for Cobol\nCEE_ADDRESS_OF_PPA2 DS F    Address of PPA2\nCEE_OFFSET_DBI      DS F    Offset BDI (None)\nCEE_EP_DESCRIPTOR   DS F    Entry Point Descriptor\nCEE_STACK_OVERFLOW  DS F    Offset for Stack overflow\n                    DS F    available word\n                    DS F    available word\n                    DS F    available word\n                    DS F    available word\nCEE_PRIMARY_EP      DS 0C\nCEE_PRI_EP_ADDRESS  DS A    primary entry-point address\nCEE_PGT_ADDRESS     DS A    PGT-Address\nCEE_TGT_ADDRESS     DS A    PGT-Address\nCEE_EP_NAME         DS A    Offset to entry_point_name\nCEE_CURRENT_EP      DS A    current EP-Address\nCEE_START           DS A    procedure code Address\nCEE_INIT_PROG       DS A    Initialize Routine\nCEE_PARM_LIST       DS A    Address of parm list for CEEINT\n                    DS F    available word\n                    DS H    available half-word\nCEE_LENGTH_NAME     DS XL2  length of program_name\nCEE_NAME_PART       DS 0C\nCEE_PGM_NAME        DS CL8  name of program\nCEE_COMP_YEAR       DS CL4  year of compilation\nCEE_COMP_MONTH      DS CL2  month of compilation\nCEE_COMP_DAY        DS CL2  day of compilation\nCEE_COMP_HOURS      DS CL2  hours of compilation\nCEE_COMP_MIN        DS CL2  minutes of compilation\nCEE_COMP_SEC        DS CL2  seconds of compilation\nCEE_VERS            DS CL2  version\nCEE_REL             DS CL2  release\nCEE_MOD             DS CL2  modification level\nCEE_CCSID           DS XL2  Codepage (COBOL V3R1 only)\n                    DS H    available halfword\nCEE_STATUS_BYTE_28  DS X    status byte\nCEE_STATUS_BYTE_29  DS X    status byte\nCEE_YEAR_WINDOW     DS H    YearWindow\nCEE_STATUS_BYTE_01  DS X    status byte\nCEE_STATUS_BYTE_02  DS X    status byte\nCEE_STATUS_BYTE_03  DS X    status byte\nCEE_STATUS_BYTE_04  DS X    status byte\nCEE_STATUS_BYTE_05  DS X    status byte\nCEE_STATUS_BYTE_06  DS X    status byte\nCEE_STATUS_BYTE_07  DS X    status byte\nCEE_STATUS_BYTE_08  DS X    status byte\nCEE_STATUS_BYTE_09  DS X    status byte\nCEE_STATUS_BYTE_10  DS X    status byte\nCEE_STATUS_BYTE_11  DS X    status byte\nCEE_STATUS_BYTE_12  DS X    status byte\nCEE_STATUS_BYTE_13  DS X    status byte\nCEE_STATUS_BYTE_14  DS X    status byte\nCEE_STATUS_BYTE_15  DS X    status byte\nCEE_STATUS_BYTE_16  DS X    status byte\nCEE_STATUS_BYTE_17  DS X    status byte\nCEE_STATUS_BYTE_18  DS X    status byte\nCEE_STATUS_BYTE_19  DS X    status byte\nCEE_STATUS_BYTE_20  DS X    status byte\nCEE_STATUS_BYTE_21  DS X    status byte\nCEE_STATUS_BYTE_22  DS X    status byte\nCEE_STATUS_BYTE_23  DS X    status byte\nCEE_COBOL_SIGNAT    DS X    cobol signature level\nCEE_DATA_STATEMENTS DS XL4  number of data items\nCEE_PROC_LINES      DS XL4  number of proc statements\nCEE_STATUS_BYTE_24  DS X    status byte\nCEE_STATUS_BYTE_25  DS X    status byte\nCEE_STATUS_BYTE_26  DS X    status byte\nCEE_STATUS_BYTE_27  DS X    status byte\n*============================================================*\n* COBOL2 DCL\n*============================================================*\nCOBOL_2_DSECT      DSECT\n                   DS CL4  bypass\n                   DS X\nC2_PGM_NAME        DS CL8  name of program\nC2_EYECATCHER      DS CL4  eyecatcher\nC2_VERS            DS CL2  version\nC2_REL             DS CL2  release\nC2_MOD             DS CL2  modification level\nC2_COMP_MONTH      DS CL2  month of compilation\n                   DS CL1\nC2_COMP_DAY        DS CL2  day of compilation\n                   DS CL1\nC2_COMP_YEAR       DS CL2  year of compilation\n                   DS CL1\nC2_COMP_HOURS      DS CL2  hours of compilation\n                   DS CL1\nC2_COMP_MIN        DS CL2  minutes of compilation\n                   DS CL1\nC2_COMP_SEC        DS CL2  seconds of compilation\nC2_GET_ENTRY       DS A    Address of address\nC2_STATUS_BYTE_01  DS X    status byte\nC2_STATUS_BYTE_02  DS X    status byte\nC2_STATUS_BYTE_03  DS X    status byte\nC2_STATUS_BYTE_04  DS X    status byte\nC2_STATUS_BYTE_05  DS X    status byte\nC2_STATUS_BYTE_06  DS X    status byte\nC2_STATUS_BYTE_07  DS X    status byte\nC2_STATUS_BYTE_08  DS X    status byte\nC2_STATUS_BYTE_09  DS X    status byte\nC2_STATUS_BYTE_10  DS X    status byte\nC2_STATUS_BYTE_11  DS X    status byte\nC2_STATUS_BYTE_12  DS X    status byte\nC2_STATUS_BYTE_13  DS X    status byte\nC2_STATUS_BYTE_14  DS X    status byte\nC2_STATUS_BYTE_15  DS X    status byte\nC2_STATUS_BYTE_16  DS X    status byte\nC2_STATUS_BYTE_17  DS X    status byte\nC2_STATUS_BYTE_18  DS X    status byte\nC2_STATUS_BYTE_19  DS X    status byte\nC2_STATUS_BYTE_20  DS X    status byte\nC2_STATUS_BYTE_21  DS X    status byte\nC2_STATUS_BYTE_22  DS X    status byte\nC2_STATUS_BYTE_23  DS X    status byte\n                   DS X    cobol signature level\nC2_DATA_STATEMENTS DS XL4  number of data items\nC2_PROC_LINES      DS XL4  number of proc statements\nC2_STATUS_BYTE_24  DS X    status byte\nC2_STATUS_BYTE_25  DS X    status byte\n                   DS XL2  status byte\n                   DS CL4  status byte\nC2_PRI_EP_ADDRESS  DS A    primary entry-point address\n*\n*============================================================*\n* OS/VS COBOL\n*============================================================*\nCOBOL_1_DSECT      DSECT\n                   DS CL12 bypass\nC1_PGM_NAME        DS CL8  name of program\nC1_EYECATCHER      DS CL2  eyecatcher\nC1_REL             DS CL2  release\n                   DS CL36\nC1_TGT_PTR         DS F    pointer to tgt\n                   DS CL8  unknown                               RS0700\nC1_OEM_MOD_AREA    DS CL60 Optimizer Info orgin COBOL low-values RS0700\n                   DS CL4  unknown                               RS0700\nC1_COMP_HOURS      DS CL2  hours of compilation\n                   DS CL1\nC1_COMP_MIN        DS CL2  minutes of compilation\n                   DS CL1\nC1_COMP_SEC        DS CL2  seconds of compilation\nC1_COMP_MONTH      DS CL3  month of compilation\n                   DS CL1\nC1_COMP_DAY        DS CL2  day of compilation\n                   DS CL2\nC1_COMP_YEAR       DS CL4  year of compilation\nCOBOL_1_TGT        DSECT\n                   DS CL72 ?\nC1_STATUS_BYTE_01  DS X    status byte\nC1_STATUS_BYTE_02  DS X    status byte\nC1_STATUS_BYTE_03  DS X    status byte\n                   DS CL369\nC1_CHECK           DS CL8  check TGT for SYSOUT\n*\n         DCBD    DSORG=QS\n         STRING GENERATE\nBIT0     EQU   B'10000000'\nBIT1     EQU   B'01000000'\nBIT2     EQU   B'00100000'\nBIT3     EQU   B'00010000'\nBIT4     EQU   B'00001000'\nBIT5     EQU   B'00000100'\nBIT6     EQU   B'00000010'\nBIT7     EQU   B'00000001'\n*------------------------------------------------------------*\n* Program equates                                            *\n*------------------------------------------------------------*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBANALJ": {"ttr": 1544, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00D\\x01\\x02\\x12\\x7f\\x01\\x073\\x1f\\x131\\x00$\\x00\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xf0\\xf8@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2002-05-07T00:00:00", "modifydate": "2007-11-27T13:31:44", "lines": 36, "newlines": 27, "modlines": 0, "user": "SYSP08"}, "text": "//XXRSCHIC JOB (62715),\n//           'SCHIRADIN-TEL.NNNN',\n//           CLASS=A,\n//           MSGLEVEL=(1,1),\n//           MSGCLASS=X,\n//           REGION=4M,\n//           NOTIFY=&SYSUID\n//ASMH EXEC PGM=ASMA90,\n// PARM=(OBJECT,TERM,BATCH,NOESD,NORLD,NOXREF,SIZE(MAX-1M,ABOVE))\n//*  If you run OS/390 R10 and higher use COBANALZ.\n//*  COBANALZ require z/Architecture\n//*  Others should use COBANAL\n//*YSIN     DD DISP=SHR,DSN=<FILE321.PDS(COBANAL)>  Input customize\n//SYSIN     DD DISP=SHR,DSN=XXRSCHI.FILE321.PDS(COBANALZ)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=XXRSCHI.FILE321.PDS\n//SYSPRINT DD SYSOUT=*\n//SYSTERM  DD SYSOUT=*\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,10),DISP=(,PASS),DCB=BLKSIZE=3200\n//SYSLMOD  DD DISP=SHR,DSN=XXRSCHI.PRIVATE.LOAD\n//*\n//* COBANALZ works with AMODE=31,RMODE=ANY\n//* COBANAL require AMODE=31,RMODE=24\n//*\n//  SET STEP=ASMH\n//  IF ( &STEP..RUN EQ TRUE  AND  &STEP..RC LE 4 ) THEN\n//BIND    EXEC PGM=IEWL,PARM='LIST,MAP,RENT,REUS,AMODE=31,RMODE=ANY'\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,1)\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//         DD *\n NAME COBANAL(R)\n//SYSPRINT DD SYSOUT=*\n//SYSLMOD  DD DISP=SHR,DSN=*.ASMH.SYSLMOD\n//  ENDIF\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "COBANALZ": {"ttr": 1546, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00S\\x01\\x08\\x17\\x7f\\x01  _\\x19W#0\\x1b\\x8b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xf0\\xf8@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2008-06-25T00:00:00", "modifydate": "2020-07-23T19:57:53", "lines": 9008, "newlines": 7051, "modlines": 0, "user": "SYSP08"}, "text": "***********************************************************************\n*                                                                     *\n* Name:         COBANAL                                               *\n*                                                                     *\n* Author:       Roland Schiradin                                      *\n*               roland(at)Schiradin.de                                *\n*                                                                     *\n* Date:         February 1996                                         *\n*                                                                     *\n* Description:  Show compile-settings and some other information      *\n*                                                                     *\n* Changes:      16.12.1996 (european)                                 *\n*               Support for VS/COBOL1 (just a few)                    *\n*               String macro no longer inside this source             *\n*               (request FILE183 from Naspa or drop me an email)      *\n*               28.04.1997 (european)                                 *\n*               Support for COBOL for MVS and VM Release 2 (formally  *\n*               called AD/Cycle COBOL/370)                            *\n*               04.03.1998 (european)                                 *\n*               MODID-marco dropped                                   *\n*               Direct Load-Library support                           *\n*               Some parts of Dave Alcocks code (DA$COBR)             *\n*               (You can contact him at dalcock(at)csw.com)           *\n*               24.03.1998 (european)                                 *\n*               Prevent S15D abend you invoke COBANAL from TSO-CALL   *\n*               (reported by Dave Alcock)                             *\n*               Support for newer STRING macro STRING GENERATE instead*\n*               of STRING FINAL_CALL                                  *\n*               (reported by Dave Alcock)                             *\n*               Fixed a bug in statement list. Y now means Yes and not*\n*               vice versa. Sorry                                     *\n*               15.02.1999 (european)                                 *\n*               Support for COBOL OS/390 and VM V2R1                  *\n*               Some new Compile-options                              *\n*               Compile-Date is European style, added long name       *\n*               Some minor fixes I cant remember in detail            *\n*               Support for MVS 4.3 (AMODE switching)                 *\n*               10.06.1999 (european)                                 *\n*               Fixed bugs reported by Mr. Smets (Thank you)          *\n*               Show ?? as the century for COBOL2                     *\n*               Support for Entrypoints (e.g. ENTRY 'DLITCBL')        *\n*               Note: There is no need to do this for IMS             *\n*               25.10.1999 (european)                                 *\n*               Check ParmLength for Parameter \"ALL\".                 *\n*               Close all datasets                                    *\n*               Make CobAnal reentrant (LinkList|||)                  *\n*               Release storage                                       *\n*               Load modules from DD COBANAL if exist                 *\n*               29.12.1999 (european)                                 *\n*               Abend 0C4 fixed                                       *\n*               Add PPA2 support                                      *\n*               Detect C/C++ and LE-enabled Assembler Programs        *\n*               The product name for COBOL1 is OS/VS Cobol (MVS) and  *\n*               DOS/VS COBOL (VSE)                                    *\n*               13.04.2000 (european)                                 *\n*               Support for some infos I missed (INVOKE, GLOBAL and   *\n*               so on) Thank you Mr. Gross                            *\n*               Add a third base register                             *\n*               23.04.2000 (european)                                 *\n*               Tested with STRING V507 from FILE183                  *\n*               19.07.2000 (european)                                 *\n*               Support for COBOL1 OEM products (e.g. CA-Optimzer)    *\n*               Thank you Mr. Pfeifer                                 *\n*               02.10.2000 (european)                                 *\n*               Support for COBOL for OS/390 & VM V2R2                *\n*               New TEST(SEPARATE)/NO TEST(SEPARATE)                  *\n*               New ARITH(EXTEND)/ARITH(COMPAT)                       *\n*               New line-sequential file                              *\n*               Thank you IBM for HFS-Support and Display under CICS  *\n*               Save some literal pool                                *\n*               I know I need to re-design the program but the        *\n*               time (you may know) is limited. At the start it       *\n*               was intend to run once and then throw it away         *\n*               Thanks for all ideas to do it better, if I'm retired  *\n*               I would spent some time on it. Don't expect that      *\n*               within the next 25 years |||                          *\n*               09.10.1999 (european)                                 *\n*               End-Substract changed to End-Subtract                 *\n*               Corect a length for moving literal Subtract           *\n*               08.01.2001 (european)                                 *\n*               Loop bug fixed                                        *\n*               04.12.2001 (european)                                 *\n*               Fixed bug reporting CLOSE Y/N                         *\n*               Support for Cobol Enterprise V3R1                     *\n*               Support for generic member names                      *\n*                 You can use ? or * in the member name to minimize   *\n*                 output instead of ALL or a single load member       *\n*                 '?' stand for any single character                  *\n*                 '*' stand for any character                         *\n*                 Be aware this feature require SYS1.MODGEN(ASAXWC)   *\n*                 introduced with MVS 5.2                             *\n*               ** Attention ****                                     *\n*                  CobAnal require MVS 5.2                            *\n*               ** Attention ****                                     *\n*               ASAXWC is not GUPI but I raised a requirement         *\n*               If you think ASAXWC might be useful for you too,      *\n*               please open a requirement                             *\n*               12.02.2002 (european)                                 *\n*               Support for IMS programs with an Entry Point DLITCBL  *\n*               I still believe such an entry point is not needed     *\n*               but it seems it's in use. However David Sumner        *\n*               made the needed changes and I merged it to the        *\n*               current source so it will be a part of CobAnal        *\n*               Special thank you to David Sumner                     *\n*               14.04.2002 (european)                                 *\n*               CobanalZ require now Architecure Level 1 this means   *\n*               it has the same requirement as OS/390 R10. If your    *\n*               hardware doesn't support OS/390 R10 you can not use   *\n*               CobAnalZ you have to use the old version called       *\n*               CobAnal. New features will be added to CobAnalZ       *\n*               but bug-fixes also for CobAnal.                       *\n*               No base register needed (base-less)                   *\n*               Support RMODE(ANY)                                    *\n*               Prepared for z/OS R3 with AMODE(64)                   *\n*               01.11.2002 (european)                                 *\n*               Support for Cobol Enterprise V3R2                     *\n*               Avoid LARL instruction                                *\n*               17.01.2003 (european)                                 *\n*               CMPR2 is not supported for Enterprise Cobol           *\n*               29.01.2004 (european)                                 *\n*               Merged code from Mike Giaquinto to prevent a S0C4     *\n*               if the entry point is close to the end of the load    *\n*               12.03.2004 (european)                                 *\n*               Support for Cobol Enterprise V3R3                     *\n*               Support for IEWBIND to display binder info (basic)    *\n*               Display CICS Precompiler version                      *\n*               Display CICS STUB version                             *\n*               Display CICS EXCI version                             *\n*               Changed the RC handling                               *\n*               17.05.2004 (european)                                 *\n*               Support for MOD level 1. Indicator DB2 V8 SQL is      *\n*               supported by V3R2 and V3R3 (PQ83744)                  *\n*               Detect PLI, DCE, Sockets programs                     *\n*               08.07.2004 (european)                                 *\n*               Support for DLL with multiple extents, but            *\n*               CobAnal just analyze the first extent. In the past    *\n*               it could abend with a S0C4                            *\n*               (reported by Adam Hojniak)                            *\n*               21.07.2004 (european)                                 *\n*               Spelling problem (End-Multiply)                       *\n*               20.01.2005 (european)                                 *\n*               AbendS80A                                             *\n*               Release storage in case of Binder RC <> 0             *\n*               (reported by Didier Lamare)                           *\n*               14.03.2005 (european)                                 *\n*               Support for new C and C++ layout                      *\n*               07.07.2005 (european)                                 *\n*               Support for Cobol Enterprise V3R4                     *\n*               FDUMP not for Cobol/370 (Enterprise Cobol)            *\n*               Minor fixes                                           *\n*              *V1.1  - April 2006: S.Stocker modified for CSC    *CSC*\n*               - NOTE: All changes developed&run on OS/390 V2.10 *CSC*\n*               - Add SUMMARY DD to provide a single-line summary *CSC*\n*                 module by module highlighting the key info such *CSC*\n*                 as Langauge and Compiler and then info relating *CSC*\n*                 to 31-bit exploitation and Reentrancy. Invoked  *CSC*\n*                 by PARM=SUMMARY so you lose wildcard function|  *CSC*\n*               - Added identification of BMS Maps.               *CSC*\n*               - COBOL2 versus COBOL3 CICS Translate option      *CSC*\n*               - Identify Languages translated by CICS           *CSC*\n*               - Tally of modules by language.                   *CSC*\n*               - No support for COBOL CICS integrated translator *CSC*\n*               - All changes (hopefully) are marked *CSC*        *CSC*\n*              *V1.2  - April 2006:                               *CSC*\n*               - Fix S0C4: loss of addressability to COBOL1 TGT  *CSC*\n*               - Fix S0C4: on very small modules. Now enforce    *CSC*\n*                 no analysis for modules < 32 bytes. Messages    *CSC*\n*                 are issued in both reports.                     *CSC*\n*               - Remove need for PARM='SUMMARY' to produce the   *CSC*\n*                 SUMMARY report. This means all the wildcard     *CSC*\n*                 searching is now available again. Yeah|         *CSC*\n*               - Add specific messages for modules marked as     *CSC*\n*                 NX (Not Executable).                            *CSC*\n*               - Ensure at least module name and *INVALID is     *CSC*\n*                 written to SUMMARY RPT for unloadable modules.  *CSC*\n*               - Change sub-headings from ======= to -------     *CSC*\n*                 improve ease of locating start of next module.  *CSC*\n*              *V1.2a - April 2006: Fix z/OS V1.4 TIOT problem    *CSC*\n*              *V1.2b - Rework Mr Schiradin's latest fixes:       *CSC*\n*               06.02.2006 (european)                                 *\n*               New PL/1 looks like new C/C++                         *\n*              *V1.30 - October 2007 R.Schiradin                 RS1007\n*               - Release-ID is now dynamic                      RS1007\n*               - RUSE changed to REUS (like the binder)         RS1007\n*               - Some info lines are to short                   RS1007\n*               - End-Multiply literal was to short              RS1007\n*               - Tested with Cobol Enterprise V3R4M1            RS1007\n*               - Reformat the compile options                   RS1007\n*               - Provide more BINDER info                       RS1007\n*               - Debugcode for IEWBIND (add DDNAME              RS1007\n*                 BINDEROU DD SYSOUT=* to activate)              RS1007\n*               - get the real TGT but of no use so far          RS1007\n*               - Support for long names listed as $PRIVnnnnnn   RS1007\n*               - Support for new C/C++ and new PL1 formats      RS1007\n*               - Display Binder info for NON-COBOL              RS1007\n*               - Support for large include names                RS1007\n*               - Report TGT usage via R9 or R13 (Peter Haus)    RS1107\n*               - Report working storage size                    RS1107\n*               - Report FCB for Cobol/370 and COBOL/ENT (P.Haus)RS1107\n*               - C/370 now C/C++                                RS1107\n*               - PK54632 for some missing END-XXXX (FIN APAR)   RS1107\n*               - Minor fixes (John P. Kalinich)                 RS1107\n* ------->      - z/Architecture required                        RS1107\n*               - Use STRING64 instead of STRING                 RS1107\n*               - Report CEEUOPT/#pragma/PLXOPT if present       RS1107\n*               - Yearwindow for COBOL/2                         JK1107\n*               - Report FCB for COBOL/2                         RS1107\n*               - Cobol-submodul-infos (lmod only)               HP1107\n*               - cobol-submodul-infos (main=asm  )              RS1107\n*               - Update CSCCOMP only for main                   RS1107\n*               - program-objects : associated CSV_OUTXTLST_ELPx HP1107\n*                 search a second extent for CEEUOPT             HP1107\n*               - Fixed S0C4                                     RS1107\n*               - Show only changed CEEUOPTs                     RS1107\n*              *V1.40 - December 2007 R.Schiradin                RS1207\n*               - Fixed S0C4 (John Kalinich)                     RS1207\n*               - First version to identify FORTRAN (J. Kalinich)RS1207\n*               - Report \"RENT REUS\" wrong (John Kalinich)       RS1207\n*               - Report AMODE64 (John Kalinich)                 RS1207\n*               - CICS-Eyecatcher case sensitive (report wrong   RS1207\n*                 COBOL3 option) since CTS 3.1                   RS1207\n*               - Support for member list via SYSIN              RS1207\n*               - Support for Enterprise Cobol V4.1              RS1207\n*               - Cosmetical change FCB-Header (John Kalinich)   RS1207\n*               - Wrong Compiler Version in the summary report   RS0108\n*                 (John Kalinich)                                RS1207\n*               - Omit analyze of includes (add DDNAME           RS0108\n*                 MAINONLY DD DUMMY to activate)                 RS0108\n*                 (Engelbert Smets)                              RS0108\n*               - Fixed S0C4 (Ludwig Hartmann)                   RS0108\n*                 EP2 is not always the correct entry point.     RS0108\n*              *V1.41 - June 2008 R.Schiradin                    RS0608\n*               - Fixed S0C4 (Werner Tomek)                      RS0608\n*                 Missing parm cause abend                       RS0608\n*               - Fix bug from using IEW_SECTION+2 in calls to   PF0608\n*                 STRING64 macro.  Set up separate _LEN and      PF0608\n*                 _DATA names so length is computed correctly    PF0608\n*               - Increase available STATIC_AREA by moving all   PF0608\n*                 initializing static DCB/DCBE's to separate     PF0608\n*                 CSECT's                                        PF0608\n*               - Introduce new DCB/DCBE named LOADL with        PF0608\n*                 DSORG=PO for LOAD from COBANAL so that the     PF0608\n*                 COBANAL DD can be concatenated (multiple DSN's)PF0608\n*               - Add reset for indentation in all cases, so     PF0608\n*                 that load-module-level information is not      PF0608\n*                 incorrectly indented                           PF0608\n*               - Add comments for each IEWBUFF area describing  PF0608\n*                 what kind of data is returned in each one      PF0608\n*               - Avoid msg IEW2134S from IEWBIND FUNC=ENDD when PF0608\n*                 FUNC=STARTD failed for any reason              PF0608\n*               - Avoid IEWBIND FUNC=DELETEW when FUNC=CREATEW   PF0608\n*                 failed for any reason                          PF0608\n*               - Avoid DELETE when PGMNAME_GET is XL8'FF' or    PF0608\n*                 the LOAD failed for any reason                 PF0608\n*               - Try to open SUMMARY file even if no COBANAL    PF0608\n*                 is present so all scanned members will be      PF0608\n*                 summarized                                     PF0608\n*               - Issue CLOSE for SYSIN (avoid SC03 abend at EOJ)PF0608\n*               - Do not subtract one from count of names so     PF0608\n*                 that all names are processed                   PF0608\n*               - From SD/ED entries in ESD section try to       PF0608\n*                 provide AMODE/RMODE info and from IDRL section PF0608\n*                 try to provide compiler/language/compile-date  PF0608\n*                 info for load modules that are \"UNKNOWN\" after PF0608\n*                 scans of load module text                      PF0608\n*               - From ED/LD entries in ESD section try to       PF0608\n*                 provide actual entry point name in CSCLPRM     PF0608\n*                 field in SUMMARY line for load modules that    PF0608\n*                 are \"UNKNOWN\" after scans of load module text  PF0608\n*               - Save the Binder date and (if present) main     PF0608\n*                 CSECT compile date for placement into the      PF0608\n*                 SUMMARY line in case no date is found based on PF0608\n*                 the object text                                PF0608\n*               - Recover from IEWBIND FUNC=INCLUDE when RC=8    PF0608\n*                 and RSNCODE=X'83000514' by re-trying INCLUDE   PF0608\n*                 from DD COBANAL and member name (INTYPE=NAME)  PF0608\n*                 using new DSORG=PO DCB/DCBE LOADL (see above)  PF0608\n*               - Adjust a few messages for spelling and/or for  PF0608\n*                 grammar                                        PF0608\n*               - Add language indicators to PID table and also  PF0608\n*                 sort by language, then use language indicators PF0608\n*                 to adjust language counters for main EP's only PF0608\n*               - Also made the PID Table an external member for PF0608\n*                 easier modifications and sorting of entries    PF0608\n*               - Fix AMODE bug for SUMMARY line in LE_370 code  PF0608\n*                 for modules that start out \"UNKNOWN\"           PF0608\n*               - Fix RENT  bug for SUMMARY line in LE_370 code  PF0608\n*                 for modules that start out \"UNKNOWN\"           PF0608\n*               - Add detection for compiled EZTrieve+ programs  PF0708\n*                 and display EZTrieve+ version and compile date PF0708\n*               - Fix error in BINDER_INFO_32 code so an actual  PF0708\n*                 FORTRAN IDL entry is not ignored when found    PF0708\n*              *V1.42 - September 2008 R.Schiradin               RS0908\n*               - Minor fix in the display                       RS0908\n*               - COBANAL was not RENT. Invocation from          RS0908\n*                 LINKLIST gets S0C4 or using SETPROG REFRPROT   RS0908\n*                 cause abend S0C4. I missed to use the List and RS0908\n*                 Execute form of Macro Load.                    RS0908\n*               - Correct setting of DCBE in the DCB             RS0908\n*               - Abend0C4 for EZtrieve programs                 RS1208\n*               - Case sensitive coding                          RS1208\n*               - Count Unknown as other was wrong               RS1208\n*              *V1.43 - February 2009 R.Schiradin                RS0209\n*               - Allow comments in the SYSIN                    RS0209\n*                 - May 2009 Craig Schneiderwent                 =CMS=\n*               - Added JUSTDATA DD for those who wish to        =CMS=\n*                 perform post-processing on the results         =CMS=\n*                 - June 2009 Kirk Poschman                      KP0609\n*               - Not fully rent                                 KP0609\n*               - Alignment                                      KP0609\n*              *V1.44 - February 2009 R.Schiradin                RS0712\n*               - CMPR2 report missing for Cobol/2               RS0209\n*              *V1.45 - January 2015  R.Schiradin                RS0115\n*               - New PID for Enterprise Cobol V4 and V5         RS0115\n*               - Basic support for Ent. Cobol V4 and V5         RS0115\n*              *V1.46 - July 2015 R.Schiradin                    RS0615\n*               - Fixed issue reported and almost fixed by       RS0615\n*               Steve Stocker                                    RS0615\n*              *V1.47 - October 2015 R.Schiradin                 RS1015\n*               - Full support for Enterprise Cobol V5.1+V5.2    RS1015\n*              *V1.50 - January 2016  E.Simonsen                 ES0116\n*               - use whole words in report for                  ES0116\n*               - options and procedure                          ES0116\n*               New PID for Enterprise Cobol V6                  RS0316\n*               Abend 0C4 fixed when load contains included      RS0316\n*               Enterprise Cobol V5 sub routines                 RS0316\n*               Use the binder info for invalid programs too     RS0316\n*               Display RMODE in the SUMMARY                     RS0316\n*              *V1.51 - May 2016 Roland Schiradin                RS0516\n*               - Support for Enterprise Cobol V6.1              RS0516\n*               - NOTEST(DWARF) was wrong                        RS0516\n*               - Binder RMODE is now working using BLDL         RS0516\n*               - RC4 instead of RC12 for PGM not found by SYSIN RS0516\n*               - XMLPARSE option was wrong                      RS0616\n*              *V1.52 - Dec 2016 Roland Schiradin                RS1216\n*               - Fix abend S0C4                                 RS1216\n*               - Fix abend S206-0C clear load parms             RS1216\n*              *V1.53 - April 2020 Peter Farley                  PF0420\n*               - Prevent S0C4 when analyzing program objects    PF0420\n*                 with statically linked COBOL subroutines that  PF0420\n*                 can be analyzed by this program                PF0420\n*               - Fix access to statically linked sections in    PF0420\n*                 program objects, which require the class       PF0420\n*                 offset from the class name list to add to the  PF0420\n*                 ESD 'ED' entry's ESD_ELEM_OFFSET value to get  PF0420\n*                 to the actual program location in storage.     PF0420\n*                 Binder API documentation seems to state that   PF0420\n*                 field ESD_CLASS_OFFSET will be automatically   PF0420\n*                 recalcualted by the Binder, but discussions    PF0420\n*                 with binder developers indicate that the CLASS PF0420\n*                 offset is only recalculated when using the     PF0420\n*                 binder API to store/update a program object,   PF0420\n*                 not when only loading it into a work area.     PF0420\n*               - Add new BNLI buffer to hold CLASS information  PF0420\n*                 for executables (only program objects will     PF0420\n*                 have non-zero CLASS_OFFSET)                    PF0420\n*               - CURSOR and COUNT values must be zeroed before  PF0420\n*                 every IEWBIND request for data                 PF0420\n*               - Change ENTCOBOLV5 access to PPA1 program name  PF0420\n*                 field to use PPA1 name offset to name instead  PF0420\n*                 of a fixed offset and adjust for FASTLINK      PF0420\n*                 objects and use offset*2 instead of offset     PF0420\n*               - Change one \"BNL\" to \"JNL\" in JK1107 changes    PF0420\n*                 for COBOL/2                                    PF0420\n*               - Moved DIRAREA to a doubleword boundary to      PF0420\n*                 avoid a storage alignment warning              PF0420\n*               - Clear CSECT_TABLE area completely at start of  PF0420\n*                 each module analysis, not just the first entry PF0420\n*               - Ensure that all stored module addresses clear  PF0420\n*                 the high-order bit to permit address compares  PF0420\n*               - Removed unnecessary code using field HADR to   PF0420\n*                 compare load and entry addresses because now   PF0420\n*                 code that stores addresses always clears the   PF0420\n*                 high-order-bit when the address is stored      PF0420\n*               - Ignore peuedo-register and merge class entries PF0420\n*                 when processing ESD entries                    PF0420\n*               - Only print ESD lines for ESD_CLASS_NAME C_CODE PF0420\n*                 and B_TEXT ESD entries                         PF0420\n*               - Correct names of some OS Binder versions and   PF0420\n*                 add OS/360 E and F level linkage editor ID's   PF0420\n*               - Fix for observed bug at z/OS V2.2: 2nd and     PF0420\n*                 subsequent IDRL entries can be offset by 2 or  PF0420\n*                 more bytes with binary zeroes or garbage bytes PF0420\n*                 less than '$', so bypass any such entry        PF0420\n*                 Observed data in such entries APPEAR to be a   PF0420\n*                 \"time of day\" but there is no documentation of PF0420\n*                 that found yet, so just bypass                 PF0420\n*               - Increase NAME and ESD buffer sizes to 500      PF0420\n*                 entries to prevent having to read more than    PF0420\n*                 one buffer per binder type for modules with    PF0420\n*                 large amounts of binder information            PF0420\n*               - Initial changes to support ANS COBOL V4        PF0420\n*                 Programs are recognized and reported as such   PF0420\n*                 but no data about the V4 programs is extracted PF0420\n*               - Added commented debugging code in several      PF0420\n*                 different areas                                PF0420\n*               - Commented out several places where the count   PF0420\n*                 of retrieved items from IEWBIND calls was      PF0420\n*                 reduced by 1 so that all returned entries are  PF0420\n*                 always processed                               PF0420\n*               - Added NAME field to IDRL and IDRU output       PF0420\n*               - When we think we have a COBOL_370 module then  PF0420\n*                 verify the language type via the PPA2 language PF0420\n*                 identifier byte                                PF0420\n*              *V1.54 - Roland Schiradin                         RS1216\n*               - ARCH and OPT now decimal                       RS1216\n*               - SIZE option ignored for E.C. >5.0              RS1216\n*               - LIB option default for E.C. v6                 RS1216\n*               - Changed CEEOCB Eyecatcher                      RS0317\n*               - Fix access to statically linked sections in    PF0618\n*                 program objects, which require the class       PF0618\n*                 offset from the class name list to add to the  PF0618\n*                 ESD 'ED' entry's ESD_CLASS_OFFSET value to get PF0618\n*                 to the actual location in storage.             PF0618\n*               - Binder API documetation seems to state that    PF0618\n*                 field ESD_ELEM_OFFSET will be automatically    PF0618\n*                 recalcualted by the Binder, but experience has PF0618\n*                 demonstrated that it does not do this, even at PF0618\n*                 VERSION=7 for the Binder API macros at z/OS    PF0618\n*                 Version 2.2.                                   PF0618\n*               - Change one \"BNL\" to \"JNL\" in JK1107 cnanges    PF0618\n*                 for COBOL/2                                    PF0618\n*               - Initial changes to support ANS COBOL V4        PF0718\n*                 Programs are recognized and reported as such   PF0718\n*                 but no data about the V4 programs is extracted PF0718\n*               - Corrections to V1.51 changes for CLASS offsets PF0718\n*                 CURSOR and COUNT values must be zeroed before  PF0718\n*                 every IEWBIND request for data                 PF0718\n*               - Put PIDTABLE in dynamic storage for reentrancy PF0718\n*               - Convert CSECT to RSECT to enforce reentrancy   PF0718\n*               - Correct analysis when first CSECT name is not  PF0718\n*                 the same name as the member name               PF0718\n*               - Correct behavior when no IDL data are availble PF0718\n*                 in the loaded program                          PF0718\n*               - Cobol 6.2 support                              RS1118\n*               - New PPA1 layout (Vector Register)              RS1118\n*               - Wrong bit for DISPSIGN option                  RS1118\n*              *V1.55 - June 2020 Roland Schiradin               PS0620\n*               - Compiled program name was corrupted            RS0620\n*               - Support Cobol V6.3                             RS0620\n         MACRO\n&NAME   #STATUS &BYTE,&BIT,&MSG\n         AIF   ('&BYTE'(1,3) EQ 'CVT' AND NOT D'&BIT).MEND\n&NAME    TM    &BYTE,&BIT              check flag\n         BRASL R14,$$STATUS            check CC, move, bump ptr\n&N       SETA  K'&MSG-3\n         DC    AL1(&N),C&MSG,0H'0'     Length,text,alignment\n.MEND    MEND\n         MACRO                                                    MACRO\n&NAME   #SNAP  &ADDR=(1),&LENGTH=(0)                              MACRO\n&NAME    STM   R14,R3,SNAPREGS         save registers             MACRO\n         IHBINNRA &ADDR,&LENGTH                                   MACRO\n         BRASL R14,SNAP00           <- SNAP STORAGE               MACRO\n         LM    R14,R3,SNAPREGS         restore registers          MACRO\n.MEND    MEND                                                     MACRO\n&REL     SETC 'V1.55'                  Release number            RS0620\n***********************************************************************\n         TITLE 'CobAnal &REL Cobol-Analyser and a bit more'      RS1007\nCOBANAL  RSECT ,                                                 PF0718\nCOBANAL  AMODE 31\nCOBANAL  RMODE ANY\n         SYSSTATE ARCHLVL=1\n         COPY  IEABRC\n         BAKR  R14,R0             Save register\n         BRAS  R6,COBANAL_000                                    PF0718\n         DC    A(STATIC_AREA)                                    RS1102\n         DC    A(STATIC_AREA+4096)                               PF0718\nCOBANAL_000 DS  0H                Load STATIC_AREA base regs     PF0718\n         L     R11,4(R6,0)                                       PF0718\n         L     R6,0(R6,0)                                        RS1102\n         USING STATIC_AREA,R6,R11 Addressebility                 PF0718\n         L     R9,0(R1)           Save Parmlist\n         USING COBANAL_PARM,R9    addressebility\n         LAY   R0,COBANAL_WORK_LENGTH                            RS0918\n         STORAGE OBTAIN,LENGTH=(R0),ADDR=(R1),COND=NO,LOC=BELOW\n         USING SAVF4SA,R1                Address of my SaveArea  PF0718\n         USING SAVER,R13                 Address of OS SaveArea  PF0718\n         XC    SAVF4SA(SAVF4SA_LEN),SAVF4SA   Clear my SaveArea  PF0718\n         MVC   SAVF4SAID,=C'F4SA'        Indicate F4SA format    PF0718\n         ST    R13,SAVF4SAPREV+4         Prev SaveArea           PF0718\n         ST    R1,SAVNEXT                Next SaveArea           PF0718\n         DROP  R1,R13                                            PF0718\n         LR    R13,R1             COBANAL_WORK register          PF0718\n         USING COBANAL_WORK,R13   addressability                 PF0718\n         ST    R13,ADR_COBANAL_WORK      save address            PF0718\n         ST    R9,ADR_COBANAL_PARM       save address            PF0718\n         MVC   EYECATCHER,=CL8'COBANAL'\n         MVC   PGMNAME,BLANKS     clear PGMNAME                  RS0608\n         MVC   PGMNAME_GET,BLANKS  clear PGMNANE GETMEM          RS0608\n*        Getmain area for IEWBIND\n         L     R0,BNLI_BUFFER_LENG\n         STORAGE OBTAIN,LENGTH=(R0),ADDR=(R1),COND=NO,LOC=31\n         ST    R1,IEW_BNLI_PTR\n         L     R0,BNLI_BUFFER_LENG                               PF0618\n         STORAGE OBTAIN,LENGTH=(R0),ADDR=(R1),COND=NO,LOC=31     PF0618\n         ST    R1,IEW_CLASS_BNLI_PTR                             PF0618\n         L     R0,IDLI_BUFFER_LENG                               RS1007\n         STORAGE OBTAIN,LENGTH=(R0),ADDR=(R1),COND=NO,LOC=31     RS1007\n         ST    R1,IEW_IDLI_PTR                                   RS1007\n         L     R0,ESDI_BUFFER_LENG                               RS1007\n         STORAGE OBTAIN,LENGTH=(R0),ADDR=(R1),COND=NO,LOC=31     RS1007\n         ST    R1,IEW_ESDI_PTR                                   RS1007\n         L     R0,IDUI_BUFFER_LENG                               RS1007\n         STORAGE OBTAIN,LENGTH=(R0),ADDR=(R1),COND=NO,LOC=31     RS1007\n         ST    R1,IEW_IDUI_PTR                                   RS1007\n         L     R0,IDZI_BUFFER_LENG                               RS1007\n         STORAGE OBTAIN,LENGTH=(R0),ADDR=(R1),COND=NO,LOC=31     RS1007\n         ST    R1,IEW_IDZI_PTR                                   RS1007\n         L     R0,IDBI_BUFFER_LENG                               RS1007\n         STORAGE OBTAIN,LENGTH=(R0),ADDR=(R1),COND=NO,LOC=31     RS1007\n         ST    R1,IEW_IDBI_PTR                                   RS1007\n*        Getmain area for PIDTABLE and copy in data from CSECT   PF0718\n         LA    R0,PID_TABLE_LEN                                  PF0718\n         STORAGE OBTAIN,LENGTH=(R0),ADDR=(R1),COND=NO,LOC=31     PF0718\n         ST    R1,ADR_PIDTABLE                                   PF0718\n         LR    R0,R1    Set up and move data                     PF0718\n         LA    R1,PID_TABLE_LEN                                  PF0718\n         L     R14,=V(PIDCSECT)                                  PF0718\n         LR    R15,R1                                            PF0718\n         MVCL  R0,R14                                            PF0718\n         MVI   CSCSUMM,X'40'              Insert a blank          *CSC*\n         MVC   CSCSUMM+1(L'CSCSUMM-1),CSCSUMM Repeat to clear     *CSC*\n         ZAP   CNT_ASSEMBLER,=P'0'       Clear Assembler counter  *CSC*\n         ZAP   CNT_BMS,=P'0'             Clear BMS       counter  *CSC*\n         ZAP   CNT_COBOL4,=P'0'          Clear V4 COBOL  counter PF0718\n         ZAP   CNT_COBOLI,=P'0'          Clear OS/VS/COB counter  *CSC*\n         ZAP   CNT_COBOL2,=P'0'          Clear VS/COB2   counter  *CSC*\n         ZAP   CNT_COBOLLE,=P'0'         Clear LE COBOL  counter  *CSC*\n         ZAP   CNT_C370,=P'0'            Clear C/C++     counter  *CSC*\n         ZAP   CNT_FORTRAN,=P'0'         Clear FORTRAN   counter  *CSC*\n         ZAP   CNT_INVALID,=P'0'         Clear Invalid   counter  *CSC*\n         ZAP   CNT_LEASS,=P'0'           Clear LE Assem  counter  *CSC*\n         ZAP   CNT_OTHER,=P'0'           Clear Other     counter  *CSC*\n         ZAP   CNT_PLI,=P'0'             Clear PLI       counter  *CSC*\n         ZAP   CNT_TOTAL,=P'0'           Clear TOTAL     counter  *CSC*\n         ZAP   CNT_UNKNOWN,=P'0'         Clear UNKNOWN   counter  *CSC*\n         ZAP   CNT_NOTLOAD,=P'0'         Clear Notloaded counter PF0608\n         ZAP   CNT_EZTRV,=P'0'           Clear EZTrieve+ counter PF0708\n         MVI   JUSTDATA_R,C'N'           Default                  =CMS=\n         MVI   SUMMARYR,C'N'             Default                  *CSC*\n         MVI   LEFOUND,C'N'              Default                  *CSC*\n         MVI   DOALL,C'N'                Default\n         MVI   DD_COBANAL,C'N'           Default\n         MVI   LOADERR,C'N'              Default                 PF0608\n         MVI   FIXEDSUM,C'N'             Default                 PF0608\n         MVI   SETRMODE,C'N'             Default                 RS0316\n         MVC   SUM_DATE_SAVE,BLANKS      Default                 PF0608\n         MVC   JUST_SPACE,BLANKS         Default\n         XC    SAVEAREA,SAVEAREA         clear SaveArea\n         LA    R13,SAVEAREA              get address of SaveArea\n         MVC   4(4,R13),=C'F1SA'         indicate Linkage Stack 72bytes\n         ST    R11,ADR_COBANAL_WORK      save address\n         ST    R9,ADR_COBANAL_PARM       save address\n*------------------------------------------------------------*\n*        Check JCL-Parm                                      *\n*------------------------------------------------------------*\n         MVC   PARM_LENGTH,COBANAL_PARM_LENGTH\n         LH    R10,PARM_LENGTH                                   RS0608\n         LTR   R10,R10                                           RS0608\n         JZ    COBANAL_020                                       RS0608\nCOBANAL_005 DS  0H                 do until first ',' or end\n         LA    R9,2(R9)            jump length field\n*        MVC   PGMNAME,BLANKS      clear PGMNANE                 RS0608\n*        MVC   PGMNAME_GET,BLANKS  clear PGMNANE GETMEM          RS0608\n         LA    R8,PGMNAME          first parm\nCOBANAL_010 DS  0H                 do until first ',' or end\n         CLI   0(R9),C','          parm separator\n         JE    COBANAL_020         next parm\n         MVC   0(1,R8),0(R9)\n         LA    R8,1(R8)            next digit\n         LA    R9,1(R9)            next digit\n         BRCT  R10,COBANAL_010     loop\nCOBANAL_020 DS  0H\n         L     R15,=V(FIXSYSPR)                                  PF0608\n         MVC   SYSPRINT(SYSPRINT_FIX_LENGTH),0(R15)              PF0608\n         MVC   PARMLIST(C_LSTOL),C_LSTO\n         LA    R9,SYSPRINT\n         USING IHADCB,R9\n         MVC   DCBDDNAM,=C'SYSPRINT'\n         OPEN  ((R9),OUTPUT),MF=(E,PARMLIST),MODE=31\n         DROP  R9\n         LTR   R15,R15                   OPEN worked?             *CSC*\n         JZ    COBANAL_020A              Yep, continue            *CSC*\n*                                                                 *CSC*\n         MVC   RETCODE,=F'16'            Set bad return code      *CSC*\n         J     COBANAL_FIN_A             Lets get out of here     *CSC*\n*                                                                 *CSC*\nCOBANAL_020A DS  0H                                               *CSC*\n         DEVTYPE =CL8'COBANAL',DOUBLE     Get COBANAL information\n         LTR   R15,R15                    Is it allocated?\n         JNZ   TIOT110                    No, continue           PF0608\n* Go check SUMMARY file anyway even if no COBANAL, because it    PF0608\n* could be SYSIN input and STEPLIB load modules needing SUMMARY  PF0608\n* -------------------------------------------------------------- PF0608\n         MVI   DD_COBANAL,C'Y'    Default\n         L     R15,=V(FIXINPUT)                                  PF0608\n         MVC   INPUT(INPUT_FIX_LENGTH),0(R15)                    PF0608\n         MVC   PARMLIST(C_LSTIL),C_LSTI\n         LA    R9,INPUT\n         USING IHADCB,R9\n         MVC   DCBDDNAM,=C'COBANAL '\n         OPEN  ((R9),INPUT),MF=(E,PARMLIST),MODE=31\n         DROP  R9\n*                                                                 *CSC*\n         L     R15,=V(FIXLOADL)                                  PF0608\n         MVC   LOADL(LOADL_FIX_LENGTH),0(R15)                    PF0608\n         MVC   PARMLIST(C_LSTIL),C_LSTI                          PF0608\n         LA    R9,LOADL                                          PF0608\n         USING IHADCB,R9                                         PF0608\n         MVC   DCBDDNAM,=C'COBANAL '                             PF0608\n         LA    R0,LOADLE                Point DCB copy to        RS0516\n         ST    R0,DCBDCBE               DCBE copy                RS0516\n         OPEN  ((R9),INPUT),MF=(E,PARMLIST),MODE=31              PF0608\n         DROP  R9                                                PF0608\n*                                                                PF0608\n*-----------------------------------------------------------------*CSC*\n*  LOCATE A COBANAL DD CARD IF ONE SUPPLIED                      RS1007\n*-----------------------------------------------------------------*CSC*\nTIOT000  DS    0H                                                 *CSC*\n         MVI   CSCDSN,X'40'                   First Space         *CSC*\n         MVC   CSCDSN+1(L'CSCDSN-1),CSCDSN    Repeat to clear     *CSC*\n         L     R3,PSATOLD-PSA                   CURRENT TCB       *CSC*\n         L     R3,TCBTIO-TCB(R3)                TIOT              *CSC*\n         LA    R3,TIOENTRY-TIOT(R3)           DDNAME ENTRIES      *CSC*\n         USING TIOENTRY,R3                                        *CSC*\n         SR    R4,R4                          CLEAR REGISTER      *CSC*\nTIOT100  DS    0H                                                 *CSC*\n         CLI   TIOELNGH,X'00'                 END OF TIOT DDNAMES?*CSC*\n         JE    TIOT110                        YES,CONTINUE IF TSO *CSC*\n         CLC   TIOEDDNM,=CL8'COBANAL'         NO, COBANAL DDNAME? *CSC*\n         JNE   TIOT105                        NO, KEEP LOOKING    *CSC*\n*                                                                 *CSC*\nTIOTZOS  DS    0H                                                 *CSC*\n         LA    R2,SWAWORK+4                   WORK AREA           *CSC*\n         ST    R2,SWAWORK                     WORK AREA           *CSC*\n         USING ZB505,R2                                           *CSC*\n         XC    SWAEPAX,SWAEPAX                CLEAR WORK AREA     *CSC*\n         MVC   SWVA,TIOEJFCB                  SVA OF THE JFCB     *CSC*\n         SWAREQ FCODE=RL,EPA=SWAWORK,MF=(E,SWAREQL1),UNAUTH=YES   *CSC*\n         L     R2,SWBLKPTR                    31'ADDRESS OF JFCB  *CSC*\n         DROP  R2                                                 *CSC*\n         USING INFMJFCB,R2                    Addressability      *CSC*\n*                                                                 *CSC*\nTIOTDSN  DS    0H                                                 *CSC*\n         MVC   CSCDSN(44),JFCBDSNM            GET DATASET NAME    *CSC*\n         J     SUMMARY_OPEN                                       *CSC*\n*                                                                 *CSC*\nTIOT105  DS    0H                                                 *CSC*\n         IC    R4,TIOELNGH                    TIOT ENTRY LENGTH   *CSC*\n         LA    R3,0(R4,R3)                    POINT AT NEXT TIOT  *CSC*\n         J     TIOT100                        EXAMINE NEXT ENTRY  *CSC*\n         DROP  R2                                                 *CSC*\n         DROP  R3                                                 *CSC*\n*                                                                 *CSC*\nTIOT110  DS    0H                                                 *CSC*\n         MVC   CSCDSN(44),=CL9'*UNKNOWN*' DATASET NAME unknown    *CSC*\n*                                                                 *CSC*\nSUMMARY_OPEN DS  0H                                               *CSC*\n         DEVTYPE =CL8'SUMMARY',DOUBLE     Get COBANAL information *CSC*\n         LTR   R15,R15                    Is it allocated?        *CSC*\n         JNZ   JUSTDATA_OPEN              No, continue            =CMS=\n*                                                                 *CSC*\n         L     R15,=V(FIXSUMMA)                                  PF0608\n         MVC   SUMMARY(SUMMARY_FIX_LENGTH),0(R15)                PF0608\n         MVC   PARMLIST(C_LSTOL),C_LSTO                           *CSC*\n         LA    R9,SUMMARY                                         *CSC*\n         USING IHADCB,R9                                          *CSC*\n         MVC   DCBDDNAM,=C'SUMMARY '                              *CSC*\n         OPEN  ((R9),OUTPUT),MF=(E,PARMLIST),MODE=31              *CSC*\n         DROP  R9                                                 *CSC*\n         LTR   R15,R15                   OPEN worked?             *CSC*\n         JZ    SUMMARY_HEADING           Yep, continue            *CSC*\n*                                                                 *CSC*\n         STRING64 'Error OPENing SUMMARY DD. RC=',((R15),,X),     *CSC*X\n               INTO=RECORD                                        *CSC*\n         BRAS  R14,SPACE1                Print starting message   *CSC*\n         MVC   RETCODE,=F'8'             Set bad return code      *CSC*\n         J     COBANAL_021               But continue.            *CSC*\n*                                                                 *CSC*\nSUMMARY_HEADING DS  0H                                            *CSC*\n         MVI   SUMMARYR,C'Y'              Yep, a SUMMARY REPORT   *CSC*\n         STRING64 'COBANAL &REL - SUMMARY Report. ',                   X\n               ' Dataset=',CSCDSN,INTO=RECORD                     *CSC*\n         BRAS  R14,SUMMARY1               Print starting message  *CSC*\n         STRING64 '                ',                             *CSC*X\n               'PARM=',PGMNAME,INTO=RECORD                        *CSC*\n         BRAS  R14,SUMMARY2               Print starting message  *CSC*\n         STRING64 '                    ',                         *CSC*X\n               '|Translate|',                                     *CSC*X\n               '|--C o m p i l e r  ',                            *CSC*X\n               'R e l a t e d--| ',                               *CSC*X\n               '|--L K E D   O p t i o n s--|',                   *CSC*X\n               INTO=RECORD                                        *CSC*\n         BRAS  R14,SUMMARY1               Print starting message  *CSC*\n         STRING64 'Program   ',                                   *CSC*X\n               'Language  ',                                      *CSC*X\n               'CICS ',                                           *CSC*X\n               'COBOL  ',                                         *CSC*X\n               'Compiler          ',                              *CSC*X\n               'LE  ',                                            *CSC*X\n               'DATA ',                                           *CSC*X\n               'RM  ',                                            *CSC*X\n               'RENT ',                                           *CSC*X\n               'RM  ',                                            *CSC*X\n               'AM  ',                                            *CSC*X\n               'LKED ATTRIBUTES           ',                      *CSC*X\n               'COMPDATE    ',                                    *CSC*X\n               INTO=RECORD                                        *CSC*\n         BRAS  R14,SUMMARY1               Print starting message  *CSC*\n         STRING64 '--------- ',                                   *CSC*X\n               '--------- ',                                      *CSC*X\n               '---- ',                                           *CSC*X\n               '------ ',                                         *CSC*X\n               '----------------- ',                              *CSC*X\n               '--- ',                                            *CSC*X\n               '---- ',                                           *CSC*X\n               '--- ',                                            *CSC*X\n               '---- ',                                           *CSC*X\n               '--- ',                                            *CSC*X\n               '--- ',                                            *CSC*X\n               '------------------------- ',                      *CSC*X\n               '----------- ',                                    *CSC*X\n               INTO=RECORD                                        *CSC*\n         BRAS  R14,SUMMARY2               Print starting message  *CSC*\n*                                                                 *CSC*\nJUSTDATA_OPEN DS  0H                                              =CMS=\n         DEVTYPE =CL8'JUSTDATA',DOUBLE   Get JUSTDATA information =CMS=\n         LTR   R15,R15                    Is it allocated?        =CMS=\n         JNZ   COBANAL_021                No, continue            =CMS=\n*                                                                 =CMS=\n         L     R15,=V(FIXJUSTD)                                   =CMS=\n         MVC   JUSTDATA(JUSTDATA_FIX_LENGTH),0(R15)               =CMS=\n         MVC   PARMLIST(C_LSTOL),C_LSTO                           =CMS=\n         LA    R9,JUSTDATA                                        =CMS=\n         USING IHADCB,R9                                          =CMS=\n         MVC   DCBDDNAM,=C'JUSTDATA'                              =CMS=\n         OPEN  ((R9),OUTPUT),MF=(E,PARMLIST),MODE=31              =CMS=\n         DROP  R9                                                 =CMS=\n         LTR   R15,R15                   OPEN worked?             =CMS=\n         JZ    JUSTDATA_OK               Yep, continue            =CMS=\n*                                                                 =CMS=\n         STRING64 'Error OPENing JUSTDATA DD. RC=',((R15),,X),    =CMS=X\n               INTO=RECORD                                        =CMS=\n         BRAS  R14,SPACE1                Print starting message   =CMS=\n         MVC   RETCODE,=F'8'             Set bad return code      =CMS=\n         J     COBANAL_021               But continue.            =CMS=\n*                                                                 =CMS=\nJUSTDATA_OK EQU *\n         MVI   JUSTDATA_R,C'Y'\n*                                                                 =CMS=\nCOBANAL_021 DS  0H\n         DEVTYPE =CL8'SYSIN',DOUBLE       Get SYSIN information  RS1207\n         LTR   R15,R15                    Is it allocated?       RS1207\n         JNZ   COBANAL_0210               No, continue           RS1207\n         MVI   DD_SYSIN,C'Y'    Default                          RS1207\n         L     R15,=V(FIXSYSIN)                                  PF0608\n         MVC   SYSIN(SYSIN_FIX_LENGTH),0(R15)                    PF0608\n         MVC   PARMLIST(C_LSTIL),C_LSTI                          RS1207\n         LA    R9,SYSIN                                          RS1207\n         USING IHADCB,R9                                         RS1207\n         MVC   DCBDDNAM,=C'SYSIN   '                             RS1207\n         LA    R0,SYSINE                Point DCB copy to        RS0908\n         ST    R0,DCBDCBE               DCBE copy                RS0908\n         OPEN  ((R9),INPUT),MF=(E,PARMLIST),MODE=31              RS1207\n         DROP  R9                                                RS1207\nCOBANAL_0210 DS  0H                                              RS1207\n         STRING64 'COBANAL &REL - DETAIL Report.  ',             RS1007X\n               ' Dataset=',CSCDSN,INTO=RECORD                     *CSC*\n         BRAS  R14,SPACE1                 Print starting message  *CSC*\n         STRING64 '                ',                             *CSC*X\n               'PARM=',PGMNAME,INTO=RECORD                        *CSC*\n         BRAS  R14,SPACE2                 Print starting message  *CSC*\n         CLI   SUMMARYR,C'Y'       Is SUMMARY DD Allocated?       *CSC*\n         JE    COBANAL_021A        Yes,Skip information message   *CSC*\n*                                                                 *CSC*\n         STRING64 '**NOTE: ',                                     *CSC*X\n               'SUMMARY SYSOUT DD not allocated, skipping ',      *CSC*X\n               'generation of SUMMARY Report.',INTO=RECORD        *CSC*\n         BRAS  R14,SPACE2                 Print starting message  *CSC*\n*                                                                 *CSC*\nCOBANAL_021A DS  0H                                               *CSC*\n         STRING64 FOOTER,INTO=RECORD                              *CSC*\n         BRAS  R14,SPACE2                                         *CSC*\n         CLC   PGMNAME,BLANKS      check PGMNAME\n         JE    COBANAL_PARM_ERROR  if clear ==> Error\n         CLC   PGMNAME(3),=C'ALL'  PGMNAME = ALL indicate analyzing\n         JNE   COBANAL_025         a complete Load, but check for\n         CLC   PARM_LENGTH,=H'3'   length; maybe it is a prog called\n         JNE   COBANAL_025         ALLWAYS :-))\n         CLI   DD_COBANAL,C'Y'        Did you read the docs?\n         JE    COBANAL_022           yes, thats fine\n         STRING64 'Parameter=ALL specified but DD-Name COBANAL',       X\n               ' missing',                                             X\n               INTO=RECORD\n         BRAS  R14,SPACE1                 Print starting message\n         MVC   RETCODE,=F'12'\n         J     COBANAL_EXIT         no, leave\n** Loop\nCOBANAL_022 DS  0H\n         MVI   DOALL,C'Y'          remember that\n         BRAS  R14,GETMEM          get the member name\n         CLC   PGMNAME_GET,XFF         more entries?\n         JE    COBANAL_EXIT          leave\n*------------------------------------------------------------*\n*        Load the progamm from DD COBANAL                    *\n*------------------------------------------------------------*\n         XC    LOADWK(16),LOADWK      clear                      RS1216\n         LA    R14,PGMNAME_GET                                   PF0608\n         LA    R15,LOADL                                         PF0608\n*        LOAD  EPLOC=PGMNAME_GET,DCB=LOADL,                      PF0608\n         LOAD  EPLOC=(14),DCB=(15),                              PF0608X\n               LSEARCH=YES,                                      PF0608X\n               ERRET=COBANAL_LOAD_ERROR,SF=(E,LOADWK)            RS0908\n         J     COBANAL_027\nCOBANAL_025 DS  0H\n         CLC   PGMNAME(5),=C'SYSIN' SYSIN indicate analyzing     RS1207\n         JNE   COBANAL_025B        a given member list via SYSIN RS1207\n         CLC   PARM_LENGTH,=H'5'   length; maybe it is a prog called1\n         JNE   COBANAL_025B        SYSINXX :-))                  RS1207\n         CLI   DD_SYSIN,C'Y'       Did you read the docs?        RS1207\n         JE    COBANAL_025A          yes, thats fine             RS1207\n         STRING64 'Parameter=SYSIN specified but DD-Name SYSIN', RS1207X\n               ' missing',                                       RS1207X\n               INTO=RECORD                                       RS1207\n         BRAS  R14,SPACE1          Print error message           RS1207\n         MVC   RETCODE,=F'12' Returncode                         RS1207\n         J     COBANAL_EXIT_B      leave                         RS0516\nCOBANAL_025A DS  0H                                              RS1207\n         MVI   DOALL,C'S'          remember that (Sysin)         RS1207\n         GET   SYSIN,SYSIN_DATA    get a member name from SYSIN  RS1207\n         CLI   SYSIN_DATA,C'*'     Comment ?                     RS0209\n         JE    COBANAL_025A          yes ignore                  RS0209\n         MVC   PGMNAME_GET,SYSIN_DATA   remember PGMNAME         RS1207\n         MVC   PGMNAME,PGMNAME_GET  remember PGMNAME             RS1207\n         J     COBANAL_026        load programm from             RS1207\nCOBANAL_025B DS  0H                                              RS1207\n         ST    R5,SAVER5          Save Register 5                RS0104\n         LA    R5,PGMNAME         start search at address\n         LA    R4,L'PGMNAME       length of string to be searched\n         AR    R4,R5              + start of address\n         LA    R0,C'?'            search for ?\n         SRST  R4,R5              issue search\n         BRC   4,COBANAL_028      wildcard ? found\n         LA    R5,PGMNAME         start search at address\n         LA    R4,L'PGMNAME       length of string to be searched\n         AR    R4,R5              + start of address\n         LA    R0,C'*'            search for *\n         SRST  R4,R5              issue search\n         BRC   4,COBANAL_028      wildcard * found\n         L     R5,SAVER5          Reload Register 5              RS0104\n         MVC   PGMNAME_GET,PGMNAME\n         CLI   DD_COBANAL,C'Y'    load from DD Cobanal ?\n         JE    COBANAL_026           yes\n*------------------------------------------------------------*\n*        Load the progamm                                    *\n*------------------------------------------------------------*\n         XC    LOADWK(16),LOADWK      clear                      RS1216\n         LOAD  EPLOC=PGMNAME_GET,ERRET=COBANAL_LOAD_ERROR,       PF0608X\n               SF=(E,LOADWK)                                     RS0908\n         J     COBANAL_027\nCOBANAL_026 DS  0H\n*------------------------------------------------------------*\n*        Load the progamm from DD COBANAL                    *\n*------------------------------------------------------------*\n         XC    LOADWK(16),LOADWK      clear                      RS1216\n         LA    R14,PGMNAME_GET                                   PF0608\n         LA    R15,LOADL                                         PF0608\n*        LOAD  EPLOC=PGMNAME_GET,DCB=LOADL,                      PF0608\n         LOAD  EPLOC=(14),DCB=(15),                              PF0608X\n               LSEARCH=YES,                                      PF0608X\n               ERRET=COBANAL_LOAD_ERROR,SF=(E,LOADWK)            RS0908\nCOBANAL_027 DS  0H\n         LTR   R15,R15             check response\n         JNZ   COBANAL_LOAD_ERROR if greater zero ==> Error\n         ST    R0,ADR_PGMNAME      save the address\n         NI    ADR_PGMNAME,X'7F'   Clear HOB of address          PF0718\n*>---------------------------------------------------------------HP1107\n         la    R3,csect_table                                    HP1107\n         st    R3,csect_tabelem_act                              HP1107\n         mvc   csect_anz_tabelem,=h'0'                           HP1107\n         USING CSECT_ENTRY,R3                                    PF0420\n         LA    R15,50               COUNT OF CSECT_TABLE ENTRIES PF0420\nCSECT_CLEAR DS 0H              LOOP TO CLEAR CSECT_TABLE ENTRIES PF0420\n         XC    CSECT_ENTRY,CSECT_ENTRY   CLEAR CSECT_TABLE ENTRY PF0420\n         LA    R3,L'CSECT_ENTRY(,R3) BUMP TO NEXT ENTRY          PF0420\n         JCT   R15,CSECT_CLEAR       LOOP FOR ALL ENTRIES        PF0420\n         MVI   csect_analyze_kz,C'M'                             HP1107\n*>---------------------------------------------------------------HP1107\n*------------------------------------------------------------*\n*        Check length                                        *\n*------------------------------------------------------------*\n*        MVC   CSV_OUTXTLST_ENTR,=F'8' Want 8 entries back       RS0704\n         MVC   CSV_OUTXTLST_ENTR,=F'9' Want 9 entries back       PF0608\n         CSVQUERY SEARCH=JPALPA,       SEARCH JPAQ                     X\n               INADDR=ADR_PGMNAME,     ADDRESS                         X\n               OUTLOADPT=CSV_LOADPT,                                DEHX\n               OUTLENGTH=CSV_LENGTH,                                   X\n               OUTEPTKN=CSV_EPTOKEN,                                   X\n               OUTVALID=CSV_OUTVALID,                            RS0704X\n               OUTATTR1=CSV_OUTATTR1,                            *CSC* X\n               OUTATTR2=CSV_OUTATTR2,                            *CSC* X\n               OUTATTR3=CSV_OUTATTR3,                            *CSC* X\n               OUTXTLST=CSV_OUTXTLST,                            RS0704X\n               OUTPID=CSV_OUTPID,                                PF0608X\n               MF=(E,CSVQRYWK)         WORK AREA\n         LTR   R2,R15                  pass return code\n         JNZ   COBANAL_CSV_ERROR if greater zero ==> Error\n         NI    CSV_LOADPT,X'7F'    Clear HOB of address          PF0420\n         AP    CNT_TOTAL,=P'1'           Increment counter        *CSC*\n*        STRING64 '**Program Name= ',PGMNAME_GET,                PF0608X\n               '   INADDR=',(ADR_PGMNAME,,X),                    PF0608X\n               ' OUTLOADP=',(CSV_LOADPT,,X),                     PF0608X\n               ' OUTLENGT=',(CSV_LENGTH,,X),                     PF0608X\n               '  EPTOKEN=',(CSV_EPTOKEN,,X),                    PF0608X\n               INTO=RECORD                                       PF0608\n*        BRAS  R14,SPACE1                                        PF0608\n         STRING64 '**Program Name= ',PGMNAME_GET,                 *CSC*X\n               ' OUTATTR1=',(CSV_OUTATTR1,,X),                    *CSC*X\n               ' OUTATTR2=',(CSV_OUTATTR2,,X),                    *CSC*X\n               ' OUTATTR3=',(CSV_OUTATTR3,,X),                    *CSC*X\n               ' OUTVALID=',(CSV_OUTVALID,,X),                    *CSC*X\n               ' OUTPID=',CSV_OUTPID,                            PF0420X\n               INTO=RECORD                                        *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         MVC   CSCLPRM,BLANKS                                    RS1007\n         TM    CSV_OUTVALID,BIT5         Is CSV_OUTATTR1 Valid?   *CSC*\n         JZ    AMODE                     NOPE ---                 *CSC*\nRENTRUSE DS    0H                                                 *CSC*\n         TM    CSV_OUTATTR1,BIT2+BIT3    Reentrant and REUS?      *CSC*\n         JNO   RENT                      no                      RS1207\n         STRING64 'RENT REUS',INTO=CSCLPRM                       RS1007\n         J     AMODE                     Go analyze AMODE        PF0608\nRENT     DS    0H                                                 *CSC*\n         TM    CSV_OUTATTR1,BIT2         REENTRANT?               *CSC*\n         JZ    RUSE                      NOPE ---                 *CSC*\n         STRING64 'RENT ',INTO=CSCLPRM                    *CSC*\nRUSE     DS    0H                                                 *CSC*\n         TM    CSV_OUTATTR1,BIT3         Serially Reusable        *CSC*\n         JZ    AMODE                     Go analyze AMODE        PF0608\n         STRING64 'REUS ',INTO=CSCLPRM                           JK1207\nAMODE    DS    0H                                                 *CSC*\n         TM    CSV_OUTVALID,BIT6         Is CSV_OUTATTR2 Valid?   *CSC*\n         JO    AMODEANY                  Yes,Check value         RS1207\n         STRING64 '???',INTO=CSCAM       No, Set unknown value    *CSC*\n         J     CONT                     Skip remaining validationRS1207\nAMODEANY DS    0H                                                 *CSC*\n         STRING64 '24 ',INTO=CSCAM                                *CSC*\n         TM    CSV_OUTATTR2,BIT2         AMODEANY?                *CSC*\n         JZ    AMODE31                   NOPE ---                 *CSC*\n         STRING64 'ANY',INTO=CSCAM                                *CSC*\nAMODE31  DS    0H                                                 *CSC*\n         TM    CSV_OUTATTR2,BIT3         AMODE31?                 *CSC*\n         JZ    AMODE64                   NOPE ---                RS1207\n         STRING64 '31 ',INTO=CSCAM                                *CSC*\nAMODE64  DS    0H                                                RS1207\n         TM    CSV_OUTATTR2,BIT7         AMODE64?                RS1207\n         JZ    CONT                      NOPE ---                RS1207\n         STRING64 '64 ',INTO=CSCAM                               RS1207\nCONT     DS    0H                                                 *CSC*\n         J     COBANAL_03\n*                                                                 *CSC*\nCOBANAL_028 DS  0H\n         L     R5,SAVER5          Reload Register 5              RS0104\n         MVI   DOALL,C'X'          remember that (eXclude)\n         BRAS  R14,GETMEM          get the member name\n         CLC   PGMNAME_GET,XFF         more entries?\n         JE    COBANAL_EXIT          leave\n         ASAXWC    PATTERNSTR=PGMNAME,                                 X\n               PATTERNSTRLEN==A(L'PGMNAME),                            X\n               STRING=PGMNAME_GET,                                     X\n               STRINGLEN==A(L'PGMNAME_GET),                            X\n               ZEROORMORE==CL1'*',                                     X\n               ONECHAR==CL1'?',                                        X\n               DELIMITER==CL1' ',                                      X\n               RETCODE=IRETCODE,                                       X\n               MF=(E,MYLIST)\n*        STRING64 'Program Name= ',PGMNAME_GET,                        X\n               ' Pattern= ',PGMNAME,'RC= ',(IRETCODE,,X),              X\n               INTO=RECORD                    debug\n*        BRAS  R14,SPACE1\n         CLC   IRETCODE,=F'0'\n         JNE   COBANAL_028\n*------------------------------------------------------------*\n*        Load the progamm from DD COBANAL                    *\n*------------------------------------------------------------*\n         LA    R14,PGMNAME_GET                                   PF0608\n         LA    R15,LOADL                                         PF0608\n*        LOAD  EPLOC=PGMNAME_GET,DCB=LOADL,                      PF0608\n         LOAD  EPLOC=(14),DCB=(15),                              PF0608X\n               LSEARCH=YES,                                      PF0608X\n               ERRET=COBANAL_LOAD_ERROR,SF=(E,LOADWK)            RS0908\n         J     COBANAL_027\n*------------------------------------------------------------*\n*        Write info to sysprint                              *\n*------------------------------------------------------------*\nCOBANAL_03 DS  0H\n*        STRING64 'Program Name= ',PGMNAME_GET,                        X\n               ' was loaded into storage at EPA= ',(ADR_PGMNAME,,X),   X\n               INTO=RECORD\n*        BRAS  R14,SPACE1\n*        STRING64 'CSV-LOAD-PTR= ',(CSV_LOADPT,,X),1X,                 X\n               ' Length= ',(CSV_LENGTH,,X),                            X\n               ' Valid= ',(CSV_OUTVALID,,X),                           X\n               ' Token= ',(CSV_EPTOKEN,,X),                            X\n               INTO=RECORD                    debug\n*        BRAS  R14,SPACE1\n*        STRING64 'CSV-Entries= ',(CSV_OUTXTLST_ENTRR,,X),             X\n               ' LP-1= ',(CSV_OUTXTLST_ELP1,,X),                       X\n               ' L-1= ',(CSV_OUTXTLST_EL1,,X),                         X\n               INTO=RECORD                    debug\n*        BRAS  R14,SPACE1\n*        STRING64 'CSV-Entries= ',(CSV_OUTXTLST_ENTRR,,X),             X\n               ' LP-2= ',(CSV_OUTXTLST_ELP2,,X),                       X\n               ' L-2= ',(CSV_OUTXTLST_EL2,,X),                         X\n               INTO=RECORD                    debug\n*        BRAS  R14,SPACE1\n*\n*        Dump the first 256 Bytes for Identification.\n*        Should be activate only in case of problems\n*\n*        L     R4,ADR_PGMNAME\n*        LA    R3,2048/16              LOOP COUNTER\n*LOOP\nCOBANAL_04 DS  0H\n*        STRING64 4X,((R4),4,X),1X,(4(R4),4,X),1X,(8(R4),4,X),1X,      X\n               (12(R4),4,X),3X,((R4),16),                              X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        LA    R4,016(,R4)             BUMP POINTER\n*        BRCT  R3,COBANAL_04\n*ENDLOOP\n         MVC   CSCPNAM(8),PGMNAME_GET                             *CSC*\n         L     R4,ADR_PGMNAME       Load-Entry-Point\n         USING COBOL_370_DSECT,R4\n*        STRING64 ' R4=',((R4),4,X),1X,(4(R4),4,X),1X,(8(R4),4,X),1X,  X\n               (12(R4),4,X),3X,((R4),16),                              X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 4X,(16(R4),4,X),1X,(20(R4),4,X),1X,(24(R4),4,X),1X,  X\n               (28(R4),4,X),3X,(16(R4),16),                            X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 4X,(32(R4),4,X),1X,(36(R4),4,X),1X,(40(R4),4,X),1X,  X\n               (44(R4),4,X),3X,(32(R4),16),                            X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n* Compute offset of entry point for later use in ESD processing  PF0608\n         XC    OFF_PGMNAME,OFF_PGMNAME Assume zero offset        PF0608\n         TM    CSV_OUTVALID+1,BIT0  Is CSV_LOADPT Valid?         PF0608\n         JZ    COBANAL_04_1         NOPE ---                     PF0608\n         L     R2,CSV_LOADPT        R2 => Load Point             PF0608\n         SR    R4,R2                Get entry point offset       PF0608\n         ST    R4,OFF_PGMNAME       Save offset for CSECT scan   PF0608\n         L     R4,ADR_PGMNAME       Reload Entry-Point           PF0608\nCOBANAL_04_1 DS  0H                                              PF0608\n         CLC   CSV_LENGTH,=F'36'    At least 36 bytes]]]          *CSC*\n         JNH   COBANAL_06_A         Try using Load Point          *CSC*\n         L     R2,CSV_LOADPT        R2 => Load Point             MG0104\n*        STRING64 ' R2=',((R2),4,X),1X,(4(R2),4,X),1X,(8(R2),4,X),1X,  X\n               (12(R2),4,X),3X,((R2),16),                              X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 4X,(16(R2),4,X),1X,(20(R2),4,X),1X,(24(R2),4,X),1X,  X\n               (28(R2),4,X),3X,(16(R2),16),                            X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 4X,(32(R2),4,X),1X,(36(R2),4,X),1X,(40(R2),4,X),1X,  X\n               (44(R2),4,X),3X,(32(R2),16),                            X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n         A     R2,CSV_LENGTH        R2 => End of module          MG0104\n         L     R10,ADR_PGMNAME      R10 => Entry Point           MG0104\n         N     R10,=X'7FFFFFFF'     Turn off high order bit      MG0104\n         SR    R2,R10               Get entry point length       MG0104\n         C     R2,=F'36'            At least 36 bytes|||         RS1207\n         JNH   COBANAL_06_A         Try using Load Point          *CSC*\n         C     R2,=F'52'            At least 52 bytes?           PF0708\n         JNH   COBANAL_04_2         No, can't be EZTrieve+       PF0708\n         USING EZTRIEVE_DSECT,R4                                 PF0708\n         CLC   EZ_EYECATCHER,=CL8'EZTPA00 ' Compiled EZTRIEVE?   PF0708\n         JE    COBANAL_15           Yes, go process              PF0708\n         USING COBOL_370_DSECT,R4   No, continue analysis        PF0708\nCOBANAL_04_2 DS  0H                                              PF0608\n         L     R2,CSV_LOADPT        R2 => Load Point              *CSC*\n         BRAS  R14,PGMNAME_2_MBR  Move PGMNAME to IEW_MBR        PF0708\n         BRAS  R14,CREATE_PLINAME Create PLINAME for later use   PF0708\n         CLC   0(10,R2),=XL4'58F0C12858F0F5D807FF' PLI ?         RS0117\n         JE    COBANAL_10A                     no                RS0117\n         CLC   28(8,R2),=CL8'PLISTART'      PLI V2.3?            RS0108\n         JE    COBANAL_10A                                        *CSC*\n         CLC   CEE_EYECATCHER,C_COBOL370   COBOL/370 ?  X'00C3C5C5'\n         JE    COBOL_370\n         CLC   CEE_EYECATCHER,C_COBV5 Enter Cobol V5 ?  X'01C3C5C5'\n         JE    ENTCOBOLV5\n         CLC   CEE_EYECATCHER,=XL4'47000002' C    ?  X'47000002' RS0305\n         JE    C_370_NEW                                         RS0305\n         CLC   CEE_EYECATCHER,C_OPLINK     C         ?  X'01C3C5C5'\n         JE    C_370\n         USING COBOL_2_DSECT,R4\n         CLC   C2_EYECATCHER,=CL4' C2 '     COBOL/2 ?  X'40C3F240'\n         JE    COBOL_2\n         USING COBOL_1_DSECT,R4\n         CLC   =CL4'ANS4',C1_EYECATCHER          ANS4 COBOL ?    PF0420\n         JE    COBOL_4                                           PF0420\n         CLC   C1_EYECATCHER(4),=CL4'VSR1'       OS/VS COBOL/1 ?\n         JE    COBOL_1\n         CLC   C1_EYECATCHER(4),=CL4'VSR2'       OS/VS COBOL/1 ?\n         JE    COBOL_1\n         CLC   0(4,R2),=XL4'47F0F028'        Fortran ?           RS1207\n         JNE   COBANAL_05                      no                RS1207\n         CLC   CSV_LENGTH,=F'112'   At least 112 bytes ]]]       RS1207\n         JNH   COBANAL_05           Try using Load Point         RS1207\n         CLC   104(8,R2),=CL8'#PIBTAB#'      Fortran ?           RS1207\n         JE    COBANAL_11A                                       RS1207\n* The following code is essentially a copy of the code above.       DEH\n* The purpose is to continue analysis at the load point if we       DEH\n*      have been unsuccessful at the entry point. This seems        DEH\n*      to be of benefit for IMS load modules.                       DEH\nCOBANAL_05 DS  0H                                                MG0104\n         STRING64 'Program= ',PGMNAME_GET,                    *CSC* DEHX\n               ' loaded at address= ',(CSV_LOADPT,,X),           PF0608X\n               ' in ',(CSV_OUTXTLST_ENTRR,F,R3B),' extents',           X\n               ' for length=',(CSV_LENGTH,,X),                   PF0608X\n               ', EPA is at address=',(ADR_PGMNAME,,X),          PF0420X\n               INTO=RECORD                                          DEH\n         BRAS  R14,SPACE1                                           DEH\n*        STRING64 'CSV-LOAD-PTR= ',(CSV_LOADPT,,X),1X,                 X\n               ' Length= ',(CSV_LENGTH,,X),                            X\n               INTO=RECORD                    debug\n*        BRAS  R14,SPACE1\n         MVC   CSCPNAM(8),PGMNAME_GET                             *CSC*\n         L     R4,CSV_LOADPT        Load Load Address               DEH\n         USING COBOL_370_DSECT,R4                                   DEH\n         CLC   CSV_LENGTH,=F'32'    At least 32 bytes|||          *CSC*\n         JNH   COBANAL_06_A          prevent S0C4                 *CSC*\n         CLC   CEE_EYECATCHER,C_COBOL370   COBOL/370 ?  X'00C3C5C5'\n         JE    COBOL_370\n         CLC   CEE_EYECATCHER,C_COBV5 Enter Cobol V5 ?  X'01C3C5C5'\n         JE    ENTCOBOLV5\n         CLC   CEE_EYECATCHER,=XL4'47000002' C    ?  X'47000002' RS0305\n         JE    C_370_NEW                                         RS0305\n         CLC   CEE_EYECATCHER,C_OPLINK     C         ?  X'01C3C5C5' DEH\n         JE    C_370                                                DEH\n         USING COBOL_2_DSECT,R4                                     DEH\n         CLC   C2_EYECATCHER,=CL4' C2 '     COBOL/2 ?  X'40C3F240'  DEH\n         JE    COBOL_2                                              DEH\n         USING COBOL_1_DSECT,R4                                     DEH\n         CLC   C1_EYECATCHER(4),=CL4'ANS4'       ANS4 COBOL ?    PF0420\n         JE    COBOL_4                                           PF0420\n         CLC   C1_EYECATCHER(4),=CL4'VSR1'       OS/VS COBOL/1 ?    DEH\n         JE    COBOL_1                                              DEH\n         CLC   C1_EYECATCHER(4),=CL4'VSR2'       OS/VS COBOL/1 ?    DEH\n         JE    COBOL_1                                              DEH\nCOBANAL_06 DS  0H\n* See if this program is a CICS/BMS Map. I noticed that at x'09'  *CSC*\n* from the LOADpoint is a fairly common header that occassionally *CSC*\n* changes.                                                        *CSC*\n         MVC   CSCLANG(9),=CL9'BMS Map  '     Indicate BMS Mapset *CSC*\n*                                                                 *CSC*\n         CLC   9(5,R4),=XL5'704040004F'       CICS/VS BMS Map?    *CSC*\n         JNE   COBANAL_BMS_CICSMVS            No, try CICSMVS BMS *CSC*\n         MVC   CSCCICS(4),=CL4'B170'          and OLD|            *CSC*\n         J     COBANAL_BMS_MESSAGE            Skip to message send*CSC*\nCOBANAL_BMS_CICSMVS DS  0H                                        *CSC*\n         CLC   9(5,R4),=XL5'214040004F'       CICS/MVS BMS Map?   *CSC*\n         JNE   COBANAL_BMS_CICSESA            No, try CICSESA BMS *CSC*\n         MVC   CSCCICS(4),=CL4'B210'          CICS/MVS V2.1 Level *CSC*\n         J     COBANAL_BMS_MESSAGE            Skip to message send*CSC*\nCOBANAL_BMS_CICSESA DS  0H                                        *CSC*\n         CLC   9(5,R4),=XL5'324040004F'       CICS/ESA BMS Map?   *CSC*\n         JNE   COBANAL_07                     No, Not BMS         *CSC*\n         MVC   CSCCICS(4),=CL4'B320'          CICS/ESA V3.2 Level *CSC*\nCOBANAL_BMS_MESSAGE DS  0H                                        *CSC*\n         AP    CNT_BMS,=P'1'             Increment counter        *CSC*\n         STRING64 PGMNAME_GET,' is probably a CICS/BMS Mapset',   *CSC*X\n               INTO=RECORD                                        *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         J     COBANAL_EXIT         no, leave                     *CSC*\n*                                                                 *CSC*\nCOBANAL_06_A DS  0H                                               *CSC*\n         AP    CNT_UNKNOWN,=P'1'         Increment counter        *CSC*\n         MVC   CSCPNAM(8),PGMNAME_GET    Save info for summary   RS1107\n         MVC   CSCLANG(9),=CL9'Unknown'  Save info for summary    *CSC*\n         MVC   CSCLPRM(21),=CL21'*Too small to analyse' summary   *CSC*\n*                                                                 *CSC*\n         STRING64 'Program= ',PGMNAME_GET,                        *CSC*X\n               ' was loaded at address= ',(CSV_LOADPT,,X),        *CSC*X\n               ' in ',(CSV_OUTXTLST_ENTRR,F,R3B),' extents',      *CSC*X\n               INTO=RECORD                                        *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         STRING64 'Program is too short to safely analyse| It ',  *CSC*X\n               'is only x',(CSV_LENGTH,,X),' bytes in length',    *CSC*X\n               INTO=RECORD                                        *CSC*\n         BRAS  R14,SPACE2                                         *CSC*\n*                                                                 *CSC*\n         J     COBANAL_EXIT         no, leave                     *CSC*\n*                                                                 *CSC*\nCOBANAL_07 DS  0H                                                 *CSC*\n         L     R2,CSV_LOADPT        R2 => Load Point              *CSC*\n*        STRING64 ' R2=',(16(R2),4,X),1X,(20(R2),4,X),                 X\n               1X,(24(R2),4,X),1X,                                     X\n               1X,(28(R2),4,X),3X,(16(R2),16),                         X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n         CLC   20(6,R2),=CL6'DFHPL1' CICS PL/I Stub?              *CSC*\n         JE    COBANAL_07_C         Yes,Cool.                     *CSC*\n         CLC   0(4,R2),=CL4'DFHY'   CICS Stub?                    *CSC*\n         JNE   COBANAL_07_D         No, no idea, sorry.           *CSC*\n         CLI   4(R2),C'A'           Yes,Assembler?                *CSC*\n         JNE   COBANAL_07_A         No, Try COBOL                 *CSC*\n*                                                                 *CSC*\n         STRING64 'Program=',PGMNAME_GET,                         *CSC*X\n               ' is a CICS Assembler program',                    *CSC*X\n               INTO=RECORD                                        *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         MVC   CSCLANG(9),=CL9'ASSEMBLER' Assembler.              *CSC*\n         STRING64 'S',(5(R2),3),INTO=CSCCICS                      *CSC*\n         AP    CNT_ASSEMBLER,=P'1'  Increment counter             *CSC*\n         J     COBANAL_EXIT                                       *CSC*\n*                                                                 *CSC*\nCOBANAL_07_A  DS  0H   ** Checking for COBOL here is redundant||  *CSC*\n         CLI   4(R2),C'C'           CICS COBOL Stub?              *CSC*\n         JNE   COBANAL_07_B         No, Try C/C++                RS1107\n*                                                                 *CSC*\n         MVC   CSCLANG(7),=CL7'COBOL  ' COBOL                     *CSC*\n         STRING64 'Program=',PGMNAME_GET,                         *CSC*X\n               ' is a CICS COBOL program',                        *CSC*X\n               INTO=RECORD                                        *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         STRING64 'S',(5(R2),3),INTO=CSCCICS                      *CSC*\n         AP    CNT_OTHER,=P'1'      Redundant, so add to OTHER    *CSC*\n         J     COBANAL_EXIT                                       *CSC*\n*                                                                 *CSC*\nCOBANAL_07_B  DS  0H                                              *CSC*\n         CLI   4(R2),C'I'           CICS C/C++ Stub?             RS1107\n         JNE   COBANAL_07_C         No, Try PL/1 PL/I PL1 PLI     *CSC*\n*                                                                 *CSC*\n         STRING64 'Program=',PGMNAME_GET,                         *CSC*X\n               ' is a CICS C/C++ program',                       RS1107X\n               INTO=RECORD                                        *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         MVC   CSCLANG(7),=CL7'C/C++  ' C/C++                    RS1107\n         STRING64 'S',(5(R2),3),INTO=CSCCICS                      *CSC*\n         AP    CNT_C370,=P'1'       Increment counter             *CSC*\n         J     COBANAL_EXIT                                       *CSC*\n*                                                                 *CSC*\nCOBANAL_07_C  DS  0H                                              *CSC*\n         STRING64 'Program=',PGMNAME_GET,                         *CSC*X\n               ' is a CICS PL/I program',                         *CSC*X\n               INTO=RECORD                                        *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         MVC   CSCLANG(7),=CL7'PL/I   ' PL/1 PL/I PL1 PLI         *CSC*\n         MVC   CSCCICS(3),=CL3'YES'     PL/1 PL/I PL1 PLI         *CSC*\n         STRING64 'PLI ',(28(R2),8),INTO=CSCCOMP                  *CSC*\n         AP    CNT_PLI,=P'1'        Increment counter             *CSC*\n         J     COBANAL_EXIT                                       *CSC*\n*                                                                 *CSC*\nCOBANAL_07_D  DS  0H                                              *CSC*\n         AP    CNT_UNKNOWN,=P'1'         Increment counter        *CSC*\n         MVC   CSCLANG(9),=CL9'Unknown'                           *CSC*\n         STRING64 'Can not establish the program language. ',    PF0608X\n               'It is possibly assembler.',INTO=RECORD           PF0608\n         BRAS  R14,SPACE1                                        PF0608\n         STRING64 'See the SUMMARY listing for Binder record ',  PF0608X\n               'info about language and other features.',        PF0608X\n               INTO=RECORD                                       PF0608\n         BRAS  R14,SPACE2                                        RS1007\n         BRAS  R14,BINDER_INFO                                   RS1007\n*>---------------------------------------------------------------HP1107\n*>   any more csect's ? -> return to csect-loop                  HP1107\n         CLI   csect_analyze_kz,C'S'  any more csects ?          HP1107\n         je    COBANAL_Csect_Loop                                HP1107\n*>---------------------------------------------------------------HP1107\n         STRING64 '------------ End  --------------------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD                                       RS1007\n         BRAS  R14,SPACE2                                        RS1007\n         MVC   PGMNAME_GET,PGMNAME_SAV                           PF0608\n         MVI   PRINT_LEAD_SPACE,C'N' Insert NO space             PF0608\n         MVC   RETCODE,=F'4'\n         J     COBANAL_EXIT         no, leave\nCOBANAL_08 DS  0H\n         AP    CNT_INVALID,=P'1'         Increment counter        *CSC*\n         MVC   CSCLANG(9),=CL9'*INVALID'                          *CSC*\n         STRING64 'Program=',PGMNAME_GET,' seems to be LE but',        X\n               ' PPA1 or PPA2 look invalid',INTO=RECORD          PF0420\n         BRAS  R14,SPACE2\n         MVC   RETCODE,=F'8'\n         BRAS  R14,BINDER_INFO                                   RS1007\n         STRING64 '------------ End  --------------------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD                                       RS1007\n         BRAS  R14,SPACE2                                        RS1007\n*                                                                 *CSC*\n         J     COBANAL_EXIT         no, leave\nCOBANAL_09 DS  0H\n         CLI   0(R2),X'04'          ID = Enterprise Cobol V5 (04)RS0115\n         JE    COBANAL_10             no check PLI\n         CLI   0(R2),X'03'          ID = C       (03) ?\n         JNE   COBANAL_10             no check PLI\nCOBANAL_09A DS  0H                                                *CSC*\n         AP    CNT_C370,=P'1'            Increment counter        *CSC*\n         MVC   CSCLANG(9),=CL9'C/C++'                            RS1007\n         STRING64 'Program=',PGMNAME_GET,' is a C/C++-Program ', RS1007X\n               INTO=RECORD                                       RS1007\n         BRAS  R14,SPACE2                                        RS1007\n         BRAS  R14,BINDER_INFO                                   RS1007\n         BRAS  R14,CEEUOPT_INFO                                  RS1107\n         STRING64 '------------ End  --------------------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD                                       RS1007\n         BRAS  R14,SPACE2                                        RS1007\n         MVC   RETCODE,=F'4'\n         J     COBANAL_EXIT         no, leave\nCOBANAL_10 DS  0H\n         CLI   0(R2),X'0A'          ID = PLI       (10) ?\n         JNE   COBANAL_11             no, Check Fortran\nCOBANAL_10A DS  0H                                                *CSC*\n         AP    CNT_PLI,=P'1'             Increment counter        *CSC*\n         MVC   CSCLANG(9),=CL9'PL/I'                              *CSC*\n         STRING64 'Program=',PGMNAME_GET,' is a PLI-Program ',         X\n               INTO=RECORD\n         BRAS  R14,SPACE2                                        RS1007\n         BRAS  R14,BINDER_INFO                                   RS1007\n         BRAS  R14,CEEUOPT_INFO                                  RS1107\n         STRING64 '------------ End  --------------------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD                                       RS1007\n         BRAS  R14,SPACE2                                        RS1007\n         MVC   RETCODE,=F'4'\n         J     COBANAL_EXIT         no, leave\nCOBANAL_11 DS  0H\n         CLI   0(R2),X'07'          ID = Fortran   (07) ?\n         JNE   COBANAL_12             no, Check DCE\nCOBANAL_11A DS  0H                                               RS1107\n         AP    CNT_FORTRAN,=P'1'         Increment counter        *CSC*\n         MVC   CSCLANG(9),=CL9'FORTRAN'                           *CSC*\n         STRING64 'Program=',PGMNAME_GET,' is a Fortran-Program ',     X\n               INTO=RECORD\n         BRAS  R14,SPACE2                                        RS1007\n         BRAS  R14,BINDER_INFO                                   RS1007\n         BRAS  R14,CEEUOPT_INFO                                  RS1107\n         STRING64 '------------ End  --------------------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD                                       RS1007\n         BRAS  R14,SPACE2                                        RS1007\n         MVC   RETCODE,=F'4'\n         J     COBANAL_EXIT         no, leave\nCOBANAL_12 DS  0H\n         CLI   0(R2),X'08'          ID = DCE       (08) ?\n         JNE   COBANAL_13             no, Check Socket\n         AP    CNT_OTHER,=P'1'           Increment counter        *CSC*\n         MVC   CSCLANG(9),=CL9'DCE'                               *CSC*\n         STRING64 'Program=',PGMNAME_GET,' is a DCE-Program ',         X\n               INTO=RECORD\n         BRAS  R14,SPACE2                                        RS1007\n         BRAS  R14,BINDER_INFO                                   RS1007\n         BRAS  R14,CEEUOPT_INFO                                  RS1107\n         STRING64 '------------ End  --------------------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD                                       RS1007\n         BRAS  R14,SPACE2                                        RS1007\n         MVC   RETCODE,=F'4'\n         J     COBANAL_EXIT         no, leave\nCOBANAL_13 DS  0H\n         CLI   0(R2),X'0C'          ID = Sockets   (12) ?\n         JNE   COBANAL_14             no, Check Socket\n         AP    CNT_OTHER,=P'1'           Increment counter        *CSC*\n         MVC   CSCLANG(9),=CL9'SOCKETS'                           *CSC*\n         STRING64 'Program=',PGMNAME_GET,' is a Sockets-Program',      X\n               INTO=RECORD\n         BRAS  R14,SPACE2                                        RS1007\n         BRAS  R14,BINDER_INFO                                   RS1007\n         BRAS  R14,CEEUOPT_INFO                                  RS1107\n         STRING64 '------------ End  --------------------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD                                       RS1007\n         BRAS  R14,SPACE2                                        RS1007\n         MVC   RETCODE,=F'4'\n         J     COBANAL_EXIT         no, leave\nCOBANAL_14 DS  0H\n         CLI   0(R2),X'0F'          ID = Assembler (15) ?\n         JNE   COBANAL_06             no, unknown language\n         AP    CNT_LEASS,=P'1'           Increment counter        *CSC*\n         MVC   CSCLANG(9),=CL9'ASSEMBLER'                         *CSC*\n         STRING64 'Program=',PGMNAME_GET,' is a LE-enabled ',          X\n               'Assembler',INTO=RECORD\n         BRAS  R14,SPACE2                                        RS1007\n         MVI   LEFOUND,C'Y'                                      PF0420\n         MVC   CSCLE(3),=CL3'YES'                                PF0420\n         BRAS  R14,BINDER_INFO                                   RS1007\n         BRAS  R14,CEEUOPT_INFO                                  RS1107\n         STRING64 '------------ End  --------------------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD                                       RS1007\n         BRAS  R14,SPACE2                                        RS1007\n         MVC   RETCODE,=F'4'\n         J     COBANAL_EXIT         no, leave\nCOBANAL_15 DS  0H                                                PF0708\n         AP    CNT_EZTRV,=P'1'           Increment counter       PF0708\n         MVC   CSCLANG(9),=CL9'EZTRIEVE+'                        PF0708\n         STRING64 'Program=',PGMNAME_GET,' is a compiled ',      PF0708X\n               'EZTrieve+',INTO=RECORD                           PF0708\n         BRAS  R14,SPACE2                                        PF0708\n* Now must search table of offsets to find JNLnnnnn CSECT        PF0708\n* It is OK to pick the first one for our purposes                PF0708\n         STRING64 ' R4=',((R4),4,X),1X,(4(R4),4,X),1X,(8(R4),4,X),1X,  X\n               (12(R4),4,X),3X,((R4),16),                              X\n               INTO=RECORD\n         BRAS  R14,SPACE1          <== next line\n         STRING64 4X,(16(R4),4,X),1X,(20(R4),4,X),1X,(24(R4),4,X),1X,  X\n               (28(R4),4,X),3X,(16(R4),16),                            X\n               INTO=RECORD\n         BRAS  R14,SPACE1          <== next line\n         STRING64 4X,(32(R4),4,X),1X,(36(R4),4,X),1X,(40(R4),4,X),1X,  X\n               (44(R4),4,X),3X,(32(R4),16),                            X\n               INTO=RECORD\n         BRAS  R14,SPACE1          <== next line\n         STRING64 4X,(48(R4),4,X),1X,(52(R4),4,X),1X,(56(R4),4,X),1X,  X\n               (60(R4),4,X),3X,(32(R4),16),                            X\n               INTO=RECORD\n         BRAS  R14,SPACE1          <== next line\n         USING EZTRIEVE_DSECT,R4                                 PF0708\n         LR    R2,R4          R2 = A(EntryPoint)                 PF0708\n         A     R2,EZ_TABLE_OFFSET  R2 = A(EZ_OFFSET_TABLE)       PF0708\n         LR    R14,R4         R14= A(EntryPoint)                 PF0708\n         A     R14,EZ_TBLEND_OFFSET R14= A(End of table)         PF0708\n         DROP  R4             Drop initial table addressibility  PF0708\n         USING EZ_OFFSET_TABLE,R2  Set table addressibility      PF0708\nCOBANAL_15A DS  0H            Loop to search for JNLnnnn CSECT   PF0708\n         CR    R2,R14         End of table?                      PF0708\n         JNL   COBANAL_15X    Yes, unknown EZTrieve version      PF0708\n         OC    EZ_TBL_WORD1,EZ_TBL_WORD1 Word1 = 0?              PF0708\n         JZ    COBANAL_15B    Yes, bypass this table entry       PF0708\n         OC    EZ_TBL_WORD2,EZ_TBL_WORD2 Word2 = 0?              PF0708\n         JZ    COBANAL_15B    Yes, bypass this table entry       PF0708\n         LR    R15,R4         R15= A(EntryPoint)                 PF0708\n         CLC   CSV_LENGTH,EZ_TBL_WORD2 Check length              RS1208\n         JNH   COBANAL_15B           prevent S0C4                RS1208\n         A     R15,EZ_TBL_WORD2 R15= A(Entrypoint + offset)      PF0708\n         USING EZTRIEVE_JNL_DSECT,R15                            PF0708\n         CLC   EZ_JNL_START_CODE,=X'47F0F0' Good starting code?  PF0708\n         JNE   COBANAL_15B    No, keep looking                   PF0708\n         CLC   EZ_JNL_R4_R5_CATCH,=C'E Z T  ' R4/R5 eyecatcher?  PF0708\n         JE    COBANAL_15C    Yes, go process R4/R5              PF0708\n         CLC   EZ_JNL_R6_CATCH,=C'CA-EASYTRIEVE ' R6 eyecatcher? PF0708\n         JE    COBANAL_15D    Yes, go process R6                 PF0708\nCOBANAL_15B DS  0H            No, keep looking                   PF0708\n         LA    R2,L'EZ_OFFSET_TABLE(,R2) Next table entry        PF0708\n         J     COBANAL_15A    Loop                               PF0708\n         DROP  R2                                                RS1108\nCOBANAL_15C DS  0H                   Move R4/R5 info             PF0708\n         MVC   CSCCOMP,EZ_JNL_R4_R5_EYECT                        PF0708\n         MVC   CSCDATE(L'EZ_JNL_R4_R5_CDATE),EZ_JNL_R4_R5_CDATE  PF0708\n         CLI   CSCDATE,C' '   Space at start of date?            PF0708\n         JNE   COBANAL_15X    No, done                           PF0708\n         MVI   CSCDATE,C'0'   Yes, set to zero                   PF0708\n         J     COBANAL_15X           Done                        PF0708\nCOBANAL_15D DS  0H                   Move R6 info                PF0708\n         MVC   CSCCOMP(4),=CL4'EZT '                             PF0708\n         MVC   CSCCOMP+4(L'EZ_JNL_R6_VERSN),EZ_JNL_R6_VERSN      PF0708\n         MVC   CSCDATE(L'EZ_JNL_R6_CDATE),EZ_JNL_R6_CDATE        PF0708\n         CLI   CSCDATE,C' '   Space at start of date?            PF0708\n         JNE   COBANAL_15X    No, done                           PF0708\n         MVI   CSCDATE,C'0'   Yes, set to zero                   PF0708\nCOBANAL_15X DS  0H                                               PF0708\n         DROP  R15                                               PF0420\n         BRAS  R14,BINDER_INFO                                   PF0708\n         BRAS  R14,CEEUOPT_INFO                                  PF0708\n         STRING64 '------------ End  --------------------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD                                       PF0708\n         BRAS  R14,SPACE2                                        PF0708\n         MVC   RETCODE,=F'4'                                     PF0708\n         J     COBANAL_EXIT         no, leave                    PF0708\nCOBANAL_PARM_ERROR DS  0H\n         STRING64 'Error parm statement, check it',INTO=RECORD\n         BRAS  R14,SPACE1\n         MVC   RETCODE,=F'12'\n         J     COBANAL_EXIT         no, leave\nCOBANAL_LOAD_ERROR DS  0H\n         ST    R1,SAVER1                 Save for later           *CSC*\n         ST    R15,SAVER15               Save for later           *CSC*\n         AP    CNT_NOTLOAD,=P'1'         Increment counter       PF0608\n         MVI   LOADERR,C'Y'              Remember we didn't LOAD PF0608\n         MVC   CSCPNAM(8),PGMNAME_GET    Save info for summary   RS1107\n         MVC   CSCLANG(9),=CL9'*NOTLOAD' Save info for summary   PF0608\n         MVC   CSCCOMP(17),=CL17'Program not found'              PF0608\n*                                                                 *CSC*\n         STRING64 'Error during LOAD of program=',PGMNAME_GET,    *CSC*X\n               ' R1=',(SAVER1,,X),' R15=',(SAVER15,,X),           *CSC*X\n               ' SYSIN',DD_SYSIN,                                 *CSC*X\n               INTO=RECORD                                        *CSC*\n         BRAS  R14,SPACE1\n         STRING64 'R1=',(SAVER1,,X),                              *CSC*X\n               ' R15=',(SAVER15,,X),INTO=CSCLPRM                  *CSC*\n         MVC   RETCODE,=F'12'\n         CLI   DD_SYSIN,C'Y'             via SYSIN ?             RS0516\n         JNE   COBANAL_LOAD_ERROR_RC12   no set RC12             RS0516\n         MVC   RETCODE,=F'4'             yes set RC4             RS0516\nCOBANAL_LOAD_ERROR_RC12 DS 0H                                    RS0516\n*                                                                 *CSC*\n         CLC   SAVER1,=X'00000706'       ABENDS706?               *CSC*\n         JNE   COBANAL_EXIT              No, Leave                *CSC*\n*                                                                 *CSC*\n         STRING64 'Module marked NX (Not Executable)',INTO=RECORD *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         MVC   CSCLPRM(25),=CL25'NX (Not Executable)'             *CSC*\n         J     COBANAL_EXIT              Leave\n*                                                                 *CSC*\nCOBANAL_CSV_ERROR DS  0H\n         STRING64 'CSVQUERY failed, RC=',((R2),,L),INTO=RECORD\n         BRAS  R14,SPACE1\n         MVC   RETCODE,=F'12'\n         J     COBANAL_EXIT         no, leave\nCOBANAL_EXIT       DS 0H\n         STRING64 FOOTER,INTO=RECORD Write a line of =====        *CSC*\n         BRAS  R14,SPACE2                                         *CSC*\n*                                                                 *CSC*\n         CLC   PGMNAME_GET,XFF      No more members?             PF0608\n         JE    COBANAL_EXIT_B       Yes, bypass DELETE           PF0608\n         CLI   LOADERR,C'Y'         Did we have a LOAD error?    PF0608\n         JNE   COBANAL_EXIT_A       No, go issue DELETE          PF0608\n         MVI   LOADERR,C'N'         Yes, reset switch            PF0608\n         J     COBANAL_EXIT_B       Bypass DELETE                PF0608\nCOBANAL_EXIT_A     DS 0H                                         PF0608\n         DELETE EPLOC=PGMNAME_GET   Delete the pgm\n         LTR   R15,R15              Error on delete?             PF0608\n         JZ    COBANAL_EXIT_B       No, bypass error message     PF0608\n         ST    R1,SAVER1            Store for display            PF0608\n         ST    R15,SAVER15          Store for display            PF0608\n         STRING64 'Error during DELETE of program=',PGMNAME_GET, PF0608X\n               ' R1=',(SAVER1,,X),' R15=',(SAVER15,,X),          PF0608X\n               ' PGMSAV=',PGMNAME_SAV,                           PF0608X\n               INTO=RECORD                                       PF0608\n         BRAS  R14,SPACE1                                        PF0608\nCOBANAL_EXIT_B     DS 0H                                         PF0608\n         CLC   CSCDATE,BLANKS       Did we get a SUMMARY date?   PF0608\n         JNE   COBANAL_EXIT_C       Yes, go print it             PF0608\n         CLC   SUM_DATE_SAVE,BLANKS Do we have another date?     PF0608\n         JE    COBANAL_EXIT_C       No, have to do without       PF0608\n*                                   Compiler date to SUMMARY     PF0608\n         STRING64 (SUM_DATE_SAVE,4),'.',                         PF0608X\n               (SUM_DATE_SAVE+4,3),INTO=CSCDATE                  PF0608\nCOBANAL_EXIT_C     DS 0H                                         PF0608\n*                                                                 *CSC*\n         STRING64 CSCSUMM,INTO=RECORD                             *CSC*\n         BRAS  R14,SUMMARY1               Print starting message  *CSC*\n         MVI   CSCSUMM,X'40'              Insert a blank          *CSC*\n         MVC   CSCSUMM+1(L'CSCSUMM-1),CSCSUMM Repeat to clear     *CSC*\n         MVC   SUM_DATE_SAVE,BLANKS  Clear saved date info       PF0608\n         MVI   FIXEDSUM,C'N'         Clear SUMMARY-fixed switch  PF0608\n         MVI   SETRMODE,C'N'         Clear SUMMARY-fixed switch  RS0316\n         MVI   LEFOUND,C'N'       Default                         *CSC*\n*                                                                 *CSC*\n         CLI   DOALL,C'N'           Default\n         JE    COBANAL_FIN\n         CLI   DOALL,C'X'           Exclude with wildcards?\n         JE    COBANAL_EXIT_1         yes get next\n         CLI   DOALL,C'S'           Read fom SYSIN?              RS1207\n         JE    COBANAL_EXIT_2         yes get next               RS1207\n         CLC   PGMNAME_GET,XFF      Last Program?\n         JNE   COBANAL_022            no loop\n         J     COBANAL_FIN          finish\nCOBANAL_EXIT_1     DS 0H\n         CLC   PGMNAME_GET,XFF      Last Program?\n         JNE   COBANAL_028           no loop\n         J     COBANAL_FIN          leave                        RS1207\nCOBANAL_EXIT_2     DS 0H                                         RS1207\n         GET   SYSIN,SYSIN_DATA    get a member name from SYSIN  RS1207\n*   End of file??                                                RS1207\n         CLI   SYSIN_DATA,C'*'     Comment ?                     RS0209\n         JE    COBANAL_EXIT_2        yes ignore                  RS0209\n         CLC   PGMNAME_GET,SYSIN_DATA   Same as last one?        PF0608\n         JE    COBANAL_EXIT_2      Yes, try the next one         PF0608\n         MVC   PGMNAME_GET,SYSIN_DATA   remember PGMNAME         RS1207\n         MVC   PGMNAME,PGMNAME_GET  remember PGMNAME             RS1207\n         J     COBANAL_026        load programm from             RS1207\nCOBANAL_FIN        DS 0H\n*                                                                 *CSC*\n         MVC   WORK(6),MASKTOT           Remove leading zeros     *CSC*\n         ED    WORK(6),CNT_ASSEMBLER     EDIT BMS                 *CSC*\n         MVC   TOT_ASSEMBLER(5),WORK+1   Assembler   Total        *CSC*\n         MVC   WORK(6),MASKTOT           Remove leading zeros     *CSC*\n         ED    WORK(6),CNT_BMS           EDIT BMS                 *CSC*\n         MVC   TOT_BMS(5),WORK+1         BMS         Total        *CSC*\n         MVC   WORK(6),MASKTOT           Remove leading zeros    PF0420\n         ED    WORK(6),CNT_COBOL4        EDIT COBOL4    programs PF0420\n         MVC   TOT_COBOL4(5),WORK+1      COBOL4      Total       PF0420\n         MVC   WORK(6),MASKTOT           Remove leading zeros     *CSC*\n         ED    WORK(6),CNT_COBOLI        EDIT COBOLI              *CSC*\n         MVC   TOT_COBOLI(5),WORK+1      COBOLI      Total        *CSC*\n         MVC   WORK(6),MASKTOT           Remove leading zeros     *CSC*\n         ED    WORK(6),CNT_COBOL2        EDIT COBOL2              *CSC*\n         MVC   TOT_COBOL2(5),WORK+1      COBOL2      Total        *CSC*\n         MVC   WORK(6),MASKTOT           Remove leading zeros     *CSC*\n         ED    WORK(6),CNT_COBOLLE       EDIT LE enabled COBOL    *CSC*\n         MVC   TOT_COBOLLE(5),WORK+1     LE COBOL    Total        *CSC*\n         MVC   WORK(6),MASKTOT           Remove leading zeros     *CSC*\n         ED    WORK(6),CNT_C370          EDIT C/C++ programs     RS1107\n         MVC   TOT_C370(5),WORK+1        C/C++ programs total    RS1107\n         MVC   WORK(6),MASKTOT           Remove leading zeros     *CSC*\n         ED    WORK(6),CNT_FORTRAN       EDIT FORTRAN programs    *CSC*\n         MVC   TOT_FORTRAN(5),WORK+1     FORTRAN     Total        *CSC*\n         MVC   WORK(6),MASKTOT           Remove leading zeros     *CSC*\n         ED    WORK(6),CNT_INVALID       EDIT INVALID    COBOL    *CSC*\n         MVC   TOT_INVALID(5),WORK+1     INVALID     Total        *CSC*\n         MVC   WORK(6),MASKTOT           Remove leading zeros     *CSC*\n         ED    WORK(6),CNT_LEASS         EDIT LE Assemble progrs  *CSC*\n         MVC   TOT_LEASS(5),WORK+1       LE Assembler Total       *CSC*\n         MVC   WORK(6),MASKTOT           Remove leading zeros     *CSC*\n         ED    WORK(6),CNT_OTHER         EDIT Other programs      *CSC*\n         MVC   TOT_OTHER(5),WORK+1       OTHER progs Total        *CSC*\n         MVC   WORK(6),MASKTOT           Remove leading zeros     *CSC*\n         ED    WORK(6),CNT_PLI           EDIT PL/I                *CSC*\n         MVC   TOT_PLI(5),WORK+1         PLI         Total        *CSC*\n         MVC   WORK(6),MASKTOT           Remove leading zeros     *CSC*\n         ED    WORK(6),CNT_TOTAL         EDIT Total   programs    *CSC*\n         MVC   TOT_TOTAL(5),WORK+1       Total programs           *CSC*\n         MVC   WORK(6),MASKTOT           Remove leading zeros     *CSC*\n         ED    WORK(6),CNT_UNKNOWN       EDIT UNKNOWN programs    *CSC*\n         MVC   TOT_UNKNOWN(5),WORK+1     UNKNOWN     Total        *CSC*\n         MVC   WORK(6),MASKTOT           Remove leading zeros    PF0608\n         ED    WORK(6),CNT_NOTLOAD       EDIT Notloaded programs PF0608\n         MVC   TOT_NOTLOAD(5),WORK+1     Notloaded   Total       PF0608\n         MVC   WORK(6),MASKTOT           Remove leading zeros    PF0708\n         ED    WORK(6),CNT_EZTRV         EDIT EZTrieve+ programs PF0708\n         MVC   TOT_EZTRV(5),WORK+1       EZTrieve+   Total       PF0708\n*                                                                 *CSC*\n         STRING64 FOOTER,INTO=RECORD                             RS0908\n         BRAS  R14,SPACE2                                         *CSC*\n         STRING64 FOOTER,'============',INTO=RECORD              RS0908\n         BRAS  R14,SUMMARY2                                       *CSC*\n         STRING64 '                BMS Maps:',                    *CSC*X\n               TOT_BMS,INTO=RECORD                                *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         BRAS  R14,SUMMARY1                                       *CSC*\n         STRING64 '                COBOL V4:',                   PF0420X\n               TOT_COBOL4,INTO=RECORD                            PF0420\n         BRAS  R14,SPACE1                                        PF0420\n         BRAS  R14,SUMMARY1                                      PF0420\n         STRING64 '             OS/VS/COBOL:',                    *CSC*X\n               TOT_COBOLI,INTO=RECORD                             *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         BRAS  R14,SUMMARY1                                       *CSC*\n         STRING64 '               VS/COBOL2:',                    *CSC*X\n               TOT_COBOL2,INTO=RECORD                             *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         BRAS  R14,SUMMARY1                                       *CSC*\n         STRING64 '     LE-conforming COBOL:',                    *CSC*X\n               TOT_COBOLLE,INTO=RECORD                            *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         BRAS  R14,SUMMARY1                                       *CSC*\n         STRING64 '                   C/C++:',                   RS1107X\n               TOT_C370,INTO=RECORD                               *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         BRAS  R14,SUMMARY1                                       *CSC*\n         STRING64 '                 FORTRAN:',                    *CSC*X\n               TOT_FORTRAN,INTO=RECORD                            *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         BRAS  R14,SUMMARY1                                       *CSC*\n         STRING64 '                 INVALID:',                    *CSC*X\n               TOT_INVALID,INTO=RECORD                            *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         BRAS  R14,SUMMARY1                                       *CSC*\n         STRING64 '               Assembler:',                    *CSC*X\n               TOT_ASSEMBLER,INTO=RECORD                          *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         BRAS  R14,SUMMARY1                                       *CSC*\n         STRING64 '    LE Enabled Assembler:',                    *CSC*X\n               TOT_LEASS,INTO=RECORD                              *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         BRAS  R14,SUMMARY1                                       *CSC*\n         STRING64 '                   OTHER:',                    *CSC*X\n               TOT_OTHER,INTO=RECORD                              *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         BRAS  R14,SUMMARY1                                       *CSC*\n         STRING64 '               EZTrieve+:',                   PF0708X\n               TOT_EZTRV,INTO=RECORD                             PF0708\n         BRAS  R14,SPACE1                                        PF0708\n         BRAS  R14,SUMMARY1                                      PF0708\n         STRING64 '                    PL/I:',                    *CSC*X\n               TOT_PLI,INTO=RECORD                                *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         BRAS  R14,SUMMARY1                                       *CSC*\n         STRING64 '                 UNKNOWN:',                    *CSC*X\n               TOT_UNKNOWN,INTO=RECORD                            *CSC*\n         BRAS  R14,SPACE2                                         *CSC*\n         BRAS  R14,SUMMARY2                                       *CSC*\n         STRING64 '   Total loaded Programs:',TOT_TOTAL,          *CSC*X*\n               INTO=RECORD\n         BRAS  R14,SPACE1                                         *CSC*\n         BRAS  R14,SUMMARY1                                       *CSC*\n         STRING64 '(includes do not count)',                     PF0608X*\n               INTO=RECORD\n         BRAS  R14,SPACE2                                         *CSC*\n         BRAS  R14,SUMMARY2                                       *CSC*\n*                                                                 *CSC*\n         STRING64 '     Could not be Loaded:',                   PF0608X\n               TOT_NOTLOAD,INTO=RECORD                           PF0608\n         BRAS  R14,SPACE1                                        PF0608\n         BRAS  R14,SUMMARY1                                      PF0608\n         AP    CNT_TOTAL,CNT_NOTLOAD     Add for total processed PF0608\n         MVC   WORK(6),MASKTOT           Remove leading zeros    PF0608\n         ED    WORK(6),CNT_TOTAL         EDIT Total   programs   PF0608\n         MVC   TOT_TOTAL(5),WORK+1       Total programs          PF0608\n         STRING64 'Total Programs processed:',                   PF0608X\n               TOT_TOTAL,INTO=RECORD                             PF0608\n         BRAS  R14,SPACE1                                        PF0608\n         BRAS  R14,SUMMARY1                                      PF0608\n*                                                                PF0608\nCOBANAL_FIN_A      DS 0H                                          *CSC*\n         LA    R9,SYSPRINT\n         USING IHADCB,R9\n         TM    DCBOFLGS-IHADCB(R9),DCBOFOPN Is it OPEN?\n         JNO   COBANAL_FIN_1              No, ignore it\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE\n         CLOSE ((R9)),MF=(E,PARMLIST),MODE=31     Close it\n         DROP  R9\n*                                                                 *CSC*\n         CLI   SUMMARYR,C'Y'                                      *CSC*\n         JNE   COBANAL_FIN_1                                      *CSC*\n         LA    R9,SUMMARY                                         *CSC*\n         USING IHADCB,R9                                          *CSC*\n         TM    DCBOFLGS-IHADCB(R9),DCBOFOPN Is it OPEN?           *CSC*\n         JNO   COBANAL_FIN_1              No, ignore it           *CSC*\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE                         *CSC*\n         CLOSE ((R9)),MF=(E,PARMLIST),MODE=31     Close it        *CSC*\n         DROP  R9                                                 *CSC*\nCOBANAL_FIN_1      DS 0H\n         CLI   DD_COBANAL,C'Y'                                   PF0608\n         JNE   COBANAL_FIN_2                                     PF0608\n         LA    R9,INPUT\n         USING IHADCB,R9\n         TM    DCBOFLGS-IHADCB(R9),DCBOFOPN Is it OPEN?\n         JNO   COBANAL_FIN_2              No, ignore it\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE\n         CLOSE ((R9)),MF=(E,PARMLIST),MODE=31     Close it\n         DROP  R9\nCOBANAL_FIN_2      DS 0H\n         LA    R9,LOADL                                          PF0608\n         USING IHADCB,R9                                         PF0608\n         TM    DCBOFLGS-IHADCB(R9),DCBOFOPN Is it OPEN?          PF0608\n         JNO   COBANAL_FIN_2A             No, ignore it          PF0608\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE                        PF0608\n         CLOSE ((R9)),MF=(E,PARMLIST),MODE=31     Close it       PF0608\n         DROP  R9                                                PF0608\nCOBANAL_FIN_2A     DS 0H                                         PF0608\n*                                                                PF0608\n         CLI   DD_SYSIN,C'Y'                                     PF0608\n         JNE   COBANAL_FIN_2B                                     =CMS=\n         LA    R9,SYSIN                                          PF0608\n         USING IHADCB,R9                                         PF0608\n         TM    DCBOFLGS-IHADCB(R9),DCBOFOPN Is it OPEN?          PF0608\n         JNO   COBANAL_FIN_3              No, ignore it          PF0608\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE                        PF0608\n         CLOSE ((R9)),MF=(E,PARMLIST),MODE=31     Close it       PF0608\n         DROP  R9                                                PF0608\nCOBANAL_FIN_2B     DS 0H                                         PF0608\n         CLI   JUSTDATA_R,C'Y'                                    =CMS=\n         JNE   COBANAL_FIN_3                                      =CMS=\n         LA    R9,JUSTDATA                                        =CMS=\n         USING IHADCB,R9                                          =CMS=\n         TM    DCBOFLGS-IHADCB(R9),DCBOFOPN Is it OPEN?           =CMS=\n         JNO   COBANAL_FIN_3              No, ignore it           =CMS=\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE                         =CMS=\n         CLOSE ((R9)),MF=(E,PARMLIST),MODE=31     Close it        =CMS=\n         DROP  R9                                                 =CMS=\nCOBANAL_FIN_3      DS 0H                                         PF0608\n*        Freemain area for IEWBIND\n         L     R0,BNLI_BUFFER_LENG\n         L     R1,IEW_BNLI_PTR\n         STORAGE RELEASE,LENGTH=(R0),ADDR=(R1)\n         L     R0,BNLI_BUFFER_LENG                               PF0420\n         L     R1,IEW_CLASS_BNLI_PTR                             PF0420\n         STORAGE RELEASE,LENGTH=(R0),ADDR=(R1)                   PF0420\n         L     R0,IDLI_BUFFER_LENG                               RS1007\n         L     R1,IEW_IDLI_PTR                                   RS1007\n         STORAGE RELEASE,LENGTH=(R0),ADDR=(R1)                   RS1007\n         L     R0,ESDI_BUFFER_LENG                               RS1007\n         L     R1,IEW_ESDI_PTR                                   RS1007\n         STORAGE RELEASE,LENGTH=(R0),ADDR=(R1)                   RS1007\n         L     R0,IDUI_BUFFER_LENG                               RS1007\n         L     R1,IEW_IDUI_PTR                                   RS1007\n         STORAGE RELEASE,LENGTH=(R0),ADDR=(R1)                   RS1007\n         L     R0,IDZI_BUFFER_LENG                               RS1007\n         L     R1,IEW_IDZI_PTR                                   RS1007\n         STORAGE RELEASE,LENGTH=(R0),ADDR=(R1)                   RS1007\n         L     R0,IDBI_BUFFER_LENG                               RS1007\n         L     R1,IEW_IDBI_PTR                                   RS1007\n         STORAGE RELEASE,LENGTH=(R0),ADDR=(R1)                   RS1007\n         L     R8,RETCODE                                        RS1107\n         LAY   R0,COBANAL_WORK_LENGTH                            RS1206\n         STORAGE RELEASE,              free Storage                    X\n               LENGTH=(R0),            Length                          X\n               ADDR=((R13))                                      PF0718\n         LR    R15,R8                                            RS1107\n         PR\n*------------------------------------------------------------*\n* Binder Info                                                *\n* The code reside at this location as the LOAD macro         *\n* on OS/390 R10 require a base register. At z/OS R4          *\n* the LOAD macro works without a base register|||            *\n*------------------------------------------------------------*\n*\nBINDER_INFO DS 0H\n         mvc   PGMNAME_sav,PGMNAME_GET                           HP1107\n         ST    R14,BINDSAVE\n         STRING64 ADDINFO,INTO=RECORD                             *CSC*\n         BRAS  R14,SPACE1\n         STRING64 '------------ about the Binder          -----------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD\n         BRAS  R14,SPACE2\n         STRING64 'This program contains the following CSECTS',        X\n               INTO=RECORD\n         BRAS  R14,SPACE2                                        RS1007\n*** FIRST SET UP CLASS NAMES INFO AREA FOR CLASS SEGMENT OFFSETS PF0420\n         L     R4,IEW_CLASS_BNLI_PTR                             PF0420\n         USING CLASS_IEWBBNL,R4                                  PF0420\n         LA    R5,CLASS_BNLH_END                                 PF0420\n         USING CLASS_BNL_ENTRY,R5                                PF0420\n*        IEWBUFF FUNC=INITBUF,TYPE=NAME    Init the buffer       PF0420\n         MVC   CLASS_IEWBBNL(BNLH_LENG),CLASS_BNLI_INIT_VALUES   PF0420\n         DROP  R4,R5                                             PF0420\n         L     R4,IEW_BNLI_PTR\n         USING IEWBBNL,R4\n         LA    R5,BNLH_END\n         USING BNL_ENTRY,R5\n*        IEWBUFF FUNC=INITBUF,TYPE=NAME    Init the buffer\n         MVC   IEWBBNL(BNLH_LENG),BNLI_INIT_VALUES\n         MVC   IEW_DTOKEN,=D'0'       Clear dialog token\n*        Clear WKTOKEN here in case STARTD fails                 PF0608\n         MVC   IEW_WKTOKEN,=D'0'      Clear workmod token        PF0608\n         MVC   IEWBIND_FUNCTION,=CL8'STARTD'                      *CSC*\n         DEVTYPE =CL8'BINDEROU',DOUBLE    Get BINDEROU informationS1007\n         LTR   R15,R15                    Is it allocated?       RS1007\n         JNZ   BINDER_INFO_01             No, continue           RS1007\n         IEWBIND FUNC=STARTD,     Start dialog with Debug-File         X\n               RETCODE=IRETCODE,                                       X\n               RSNCODE=RSNCODE,                                        X\n               DIALOG=IEW_DTOKEN,                                      X\n               FILES=FILELIST,           <- Has file list for print    X\n               OPTIONS=OPTLIST3,         <- Has term off and print on  X\n               VERSION=4,                                              X\n               MF=(E,IEWBIND)                                    RS1007\n         J     BINDER_INFO_02             jump around            RS1007\nBINDER_INFO_01 DS 0H                                             RS1007\n         IEWBIND FUNC=STARTD,     Start dialog                         X\n               RETCODE=IRETCODE,                                       X\n               RSNCODE=RSNCODE,                                        X\n               DIALOG=IEW_DTOKEN,                                      X\n               VERSION=4,                                              X\n               MF=(E,IEWBIND)\nBINDER_INFO_02 DS 0H                                             RS1007\n         CLC   RSNCODE,=F'0'      Check the reason code\n         JE    BINDER_INFO_03     Zero, OK to continue           PF0608\n         MVC   IEW_DTOKEN,XFF     Remember no dialog was started PF0608\n         J     BINDER_ERROR       Exit, bad STARTD               PF0608\nBINDER_INFO_03 DS 0H                                             PF0608\n         MVC   IEWBIND_FUNCTION,=CL8'CREATEW'                     *CSC*\n         IEWBIND FUNC=CREATEW,    Create workmod Access only           X\n               RETCODE=IRETCODE,                                       X\n               RSNCODE=RSNCODE,                                        X\n               WORKMOD=IEW_WKTOKEN,                                    X\n               DIALOG=IEW_DTOKEN,                                      X\n               INTENT=ACCESS,                                          X\n               VERSION=4,                                              X\n               MF=(E,IEWBIND)\n*        STRING64 'CREATEW: RC: ',(IRETCODE,,X),' RSN: ',(RSNCODE,,X), X\n               'DTOKEN: ',(IEW_DTOKEN,,X),                             X\n               INTO=RECORD\n*        BRAS  R14,SPACE1\n         CLC   RSNCODE,=F'0'      Check the reason code\n         JE    BINDER_INFO_031    Zero, OK to continue           PF0608\n         MVC   IEW_WKTOKEN,XFF    Remember we have no workmod    PF0608\n         J     BINDER_ERROR       Exit, bad CREATEW              PF0608\nBINDER_INFO_031 DS 0H                                            PF0608\n         DEVTYPE =CL8'BINDEROU',DOUBLE  Get BINDEROU information RS1007\n         LTR   R15,R15                  Is it allocated?         RS1007\n         JNZ   BINDER_INFO_04           No, continue             RS1007\n         MVC   IEWBIND_FUNCTION,=CL8'SETO'                       RS1007\n         IEWBIND FUNC=SETO,        Set Options                         X\n               RETCODE=IRETCODE,                                       X\n               RSNCODE=RSNCODE,                                        X\n               WORKMOD=IEW_WKTOKEN,                                    X\n               OPTION=O_LIST,OPTVAL=V_ALL,      LIST(ALL)              X\n               VERSION=4,                                              X\n               MF=(E,IEWBIND)                                    RS1007\n*        STRING64 'INCLUDE: RC: ',(IRETCODE,,X),' RSN: ',(RSNCODE,,X), X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1                                        RS1007\n         CLC   RSNCODE,=F'0'      Check the reason code          RS1007\n         JNE   BINDER_ERROR       Exit if not zero               RS1007\nBINDER_INFO_04 DS 0H                                             RS1007\n         MVC   IEWBIND_FUNCTION,=CL8'INCLUDE'                     *CSC*\n* Try INCLUDE from EPTOKEN first, then use NAME and COBANAL if   PF0608\n* EPTOKEN attempt gets RC=8, RSN=83000514                        PF0608\n         IEWBIND FUNC=INCLUDE,                                         X\n               RETCODE=IRETCODE,                                       X\n               RSNCODE=RSNCODE,                                        X\n               WORKMOD=IEW_WKTOKEN,                                    X\n               INTYPE=TOKEN,                                           X\n               EPTOKEN=CSV_EPTOKEN,                                    X\n               VERSION=4,                                              X\n               MF=(E,IEWBIND)\n*        STRING64 'INCLUDE: RC= ',(IRETCODE,,X),                 PF0608X\n               '   INADDR=',(ADR_PGMNAME,,X),                    PF0608X\n               ' OUTLOADP=',(CSV_LOADPT,,X),                     PF0608X\n               ' IEWTOKEN=',(IEW_WKTOKEN,,X),                    PF0608X\n               '  EPTOKEN=',(CSV_EPTOKEN,,X),                    PF0608X\n               INTO=RECORD                                       PF0608\n*        BRAS  R14,SPACE1                                        PF0608\n*        STRING64 'INCLUDE: RC: ',(IRETCODE,,X),' RSN: ',(RSNCODE,,X), X\n               INTO=RECORD\n*        BRAS  R14,SPACE1\n         CLC   RSNCODE,=F'0'      Check the reason code\n         JE    BINDER_INFO_05     Continue if zero               PF0608\n* Possible INCLUDE error, check to see if it is only a warning   PF0608\n         CLC   IRETCODE,=F'4'     Warning only?                  PF0608\n         JNH   BINDER_INFO_05     Yes, OK to continue            PF0608\n* INCLUDE error, check to see if we can retry with NAME/DDN/MBR  PF0608\n         CLC   RSNCODE,=X'83000514' Retryable reason code?       PF0608\n         JNE   BINDER_ERROR       No, don't retry                PF0608\n         CLI   DD_COBANAL,C'Y'    Do we have a COBANAL DD?       PF0608\n         JNE   BINDER_ERROR       No, can't try INCLUDE again    PF0608\n* OK, we can retry INCLUDE with NAME/DDN/MBR                     PF0608\n* First a message saying what has happened                       PF0608\n         STRING64 'EPTOKEN access to the load module failed,',   PF0608X\n               ' trying NAME access',                            PF0608X\n               INTO=RECORD                                       PF0608\n         BRAS  R14,SPACE1                                        PF0608\n         BRAS  R14,PGMNAME_2_MBR  Move PGMNAME to IEW_MBR        PF0708\n* Now retry the INCLUDE with NAME/DDN/MBR                        PF0608\n         IEWBIND FUNC=INCLUDE,                                   PF0608X\n               RETCODE=IRETCODE,                                 PF0608X\n               RSNCODE=RSNCODE,                                  PF0608X\n               WORKMOD=IEW_WKTOKEN,                              PF0608X\n               INTYPE=NAME,                                      PF0608X\n               DDNAME=IEW_DDN,                                   PF0608X\n               MEMBER=IEW_MBR,                                   PF0608X\n               VERSION=4,                                        PF0608X\n               MF=(E,IEWBIND)                                    PF0608\n*        STRING64 'INCLUDE: RC= ',(IRETCODE,,X),                 PF0608X\n               '   INADDR=',(ADR_PGMNAME,,X),                    PF0608X\n               ' OUTLOADP=',(CSV_LOADPT,,X),                     PF0608X\n               ' IEWTOKEN=',(IEW_WKTOKEN,,X),                    PF0608X\n               INTO=RECORD                                       PF0608\n*        BRAS  R14,SPACE1                                        PF0608\n*        STRING64 'INCLUDE: ',                                   PF0608X\n               '  DD NAME=',IEW_DDNN,                            PF0608X\n               ' MBR LENG=',(IEW_MBRL,,X),                       PF0608X\n               ' MBR NAME=',IEW_MBRN,                            PF0608X\n               INTO=RECORD                                       PF0608\n*        BRAS  R14,SPACE1                                        PF0608\n*        STRING64 'INCLUDE: RC: ',(IRETCODE,,X),' RSN: ',        PF0608X\n               (RSNCODE,,X),INTO=RECORD                          PF0608\n*        BRAS  R14,SPACE1                                        PF0608\n         CLC   RSNCODE,=F'0'      Check the reason code          PF0608\n         JE    BINDER_INFO_05     Continue if zero               PF0608\n* Possible INCLUDE error, check to see if it is only a warning   PF0608\n         CLC   IRETCODE,=F'4'     Warning only?                  PF0608\n         JH    BINDER_ERROR       No, signal error               PF0608\nBINDER_INFO_05 DS 0H                                             PF0608\n         MVC   IEW_CURSORN,=F'0'      Clear Cursor\n         MVC   IEWBIND_FUNCTION,=CL8'GETN'                        *CSC*\n*** GET CLASS NAMES FIRST FOR PROGRAM OBJECT SEGMENT OFFSETS     PF0420\n         L     R4,IEW_CLASS_BNLI_PTR                             PF0420\n         MVC   IEW_CURSORN,=F'0'      Clear Cursor               PF0420\n         MVC   IEW_COUNTN_CLASS,=F'0' Clear Count                PF0420\n         IEWBIND FUNC=GETN,                                      PF0420X\n               RETCODE=IRETCODE,                                 PF0420X\n               RSNCODE=RSNCODE,                                  PF0420X\n               WORKMOD=IEW_WKTOKEN,                              PF0420X\n               AREA=IEWBBNL,                                     PF0420X\n               CURSOR=IEW_CURSORN,                               PF0420X\n               COUNT=IEW_COUNTN_CLASS,                           PF0420X\n               TCOUNT=IEW_TCOUNT_CLASS,                          PF0420X\n               NTYPE=C,                                          PF0420X\n               VERSION=4,                                        PF0420X\n               MF=(E,IEWBIND)                                    PF0420\n         CLC   RSNCODE,=F'0'      Check reason code              PF0420\n         JE    BINDER_INFO_07     continue if zero               PF0420\n         CLC   IRETCODE,=F'4'     Do we have all the names       PF0420\n         JH    BINDER_ERROR       Any higher is an error         PF0420\n*                                                                PF0420\nBINDER_INFO_07 DS 0H                                             PF0420\n         L     R4,IEW_BNLI_PTR                                   PF0420\n         MVC   IEW_CURSORN,=F'0'      Clear Cursor               PF0420\n         MVC   IEW_COUNTN,=F'0'       Clear Count                PF0420\n         IEWBIND FUNC=GETN,                                            X\n               RETCODE=IRETCODE,                                       X\n               RSNCODE=RSNCODE,                                        X\n               WORKMOD=IEW_WKTOKEN,                                    X\n               AREA=IEWBBNL,                                           X\n               CURSOR=IEW_CURSORN,                                     X\n               COUNT=IEW_COUNTN,                                       X\n               TCOUNT=IEW_TCOUNT,                                      X\n               NTYPE=S,                                                X\n               VERSION=4,                                              X\n               MF=(E,IEWBIND)\n*        STRING64 '   GETN: RC: ',(IRETCODE,,X),' RSN: ',(RSNCODE,,X), X\n               'COUNT: ',(IEW_COUNTN,,X),' Token: ',(IEW_WKTOKEN,,X),  X\n               INTO=RECORD\n*        BRAS  R14,SPACE1\n*\n*        Dump the first 256 Bytes for Identification.\n*        Should be activated only in case of problems\n*        STRING64 4X,((R8),4,X),1X,(4(R8),4,X),1X,(8(R8),4,X),1X,      X\n               (12(R8),4,X),3X,((R8),16),                              X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 4X,(16(R8),4,X),1X,(20(R8),4,X),1X,(24(R8),4,X),1X,  X\n               (28(R8),4,X),3X,(16(R8),16),                            X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 4X,((R9),4,X),1X,(4(R9),4,X),1X,(8(R9),4,X),1X,      X\n               (12(R9),4,X),3X,((R9),16),                              X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 4X,(16(R9),4,X),1X,(20(R9),4,X),1X,(24(R9),4,X),1X,  X\n               (28(R9),4,X),3X,(16(R9),16),                            X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n         CLC   RSNCODE,=F'0'      Check reason code\n         JE    BINDER_INFO_10     continue if zero\n         CLC   IRETCODE,=F'4'     Do we have all the names\n         JH    BINDER_ERROR       Any higher is an error\n*                                                                 *CSC*\nBINDER_INFO_10 DS 0H\n         L     R12,IEW_COUNTN     Number of sections\n*        BCTR  R12,0              Not -1| Process all names      PF0608\n*loop\nBINDER_INFO_20 DS 0H\n         L     R3,BNL_NAME_PTR    Extract section name\n         MVC   IEW_SECTION_DATA(255),BLANKS                      PF0608\n         LH    R2,BNL_NAME_CHARS\n         STH   R2,IEW_SECTION_LEN                                PF0608\n         STRING64 (0(R3),(R2),),INTO=IEW_SECTION_DATA Name       PF0608\n         CLI   LEFOUND,C'Y'                                       *CSC*\n         JE    BINDER_INFO_30                                    RS1007\n         CLC   CSCLANG(9),=CL9'Unknown'                          RS1107\n         JE    BINDER_INFO_30                                    RS1107\n         CLI   FIXEDSUM,C'Y'      Did it start out as UNKNOWN?   PF0608\n         JE    BINDER_INFO_30     Yes, don't update LE column    PF0608\n         MVC   CSCLE(3),=CL3'NO '                                 *CSC*\n         CLC   0(3,R3),=CL3'CEE'                                  *CSC*\n         JNE   BINDER_INFO_30                                    RS1007\n         MVC   CSCLE(3),=CL3'YES'                                 *CSC*\n         MVI   LEFOUND,C'Y'                                       *CSC*\nBINDER_INFO_30 DS 0H                                             RS1007\n         LH    R8,IEW_SECTION_LEN                                PF0608\n         STRING64 2X,(IEW_SECTION_DATA,(R8),),INTO=RECORD        PF0608\n         MVC   IEW_SECT_NAME,BLANKS Keep it for later            PF0420\n         STRING64 (IEW_SECTION_DATA,(R8),),INTO=IEW_SECT_NAME    PF0420\n         ST    R8,IEW_SECT_LEN                                   PF0420\n         CLI   IEW_SECTION_DATA,X'00'                            PF0608\n         JNE   BINDER_INFO_30_NOPRIV                             RS1007\n         STRING64 2X,'$PRIV',(IEW_SECTION_DATA,4,X),INTO=RECORD  PF0608\n         BRAS  R14,SPACE1          <== next line                 PF0718\n         MVC   RECORD,BLANKS      Clear line                     PF0718\nBINDER_INFO_30_NOPRIV DS 0H                                      RS1007\n         BRAS  R14,SPACE1          <== next line                 RS1007\n         LH    R8,IEW_SECTION_LEN                                PF0608\n         MVC   IEW_CURSORD,=F'0'      Clear Cursor               RS1007\n         MVC   IEW_COUNTD,=F'0'       Clear Count                PF0420\n         STM   R4,R5,SAVER4_AND_R5                               RS1007\n         L     R4,IEW_IDLI_PTR                                   RS1007\n         USING IEWBIDL,R4                                        RS1007\n*        IEWBUFF FUNC=INITBUF,TYPE=IDL     Init the buffer       RS1007\n         MVC   IEWBIDL(IDLH_LENG),IDLI_INIT_VALUES               RS1007\n         MVC   IEWBIND_FUNCTION,=CL8'GETD-IDL'                   RS1007\n         LA    R5,IDLH_END                                       RS1007\n         USING IDL_ENTRY,R5                                      RS1007\n         IEWBIND FUNC=GETD,                                            X\n               RETCODE=IRETCODE,                                       X\n               RSNCODE=RSNCODE,                                        X\n               WORKMOD=IEW_WKTOKEN,                                    X\n               CLASS=IEW_IDL,                                          X\n               SECTION=IEW_SECTION,                                    X\n               AREA=IEWBIDL,                                           X\n               CURSOR=IEW_CURSORD,                                     X\n               COUNT=IEW_COUNTD,                                       X\n               VERSION=4,                                              X\n               MF=(E,IEWBIND)                                    RS1007\n*        Should be activated only in case of problems            PF0420\n*        STRING64 '   GETD: IDL ',(IRETCODE,,X),' RSN: ',(RSNCODE,,X), X\n               'COUNT: ',(IEW_COUNTD,,X),' Token: ',(IEW_WKTOKEN,,X),  X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1                                        RS1007\n         CLC   RSNCODE,=F'0'      Check reason code              RS1007\n         JE    BINDER_INFO_31     continue if zero               RS1007\n*        CLC   IRETCODE,=F'4'     Do we have all the names       RS1007\n*        JH    BINDER_ERROR       Any higher is an error         RS1007\nBINDER_INFO_31 DS 0H                                             RS1007\n*        Should be activated only in case of problems            RS1007\n*        STRING64 4X,((R4),4,X),1X,(4(R4),4,X),1X,(8(R4),4,X),1X,      X\n               (12(R4),4,X),3X,((R4),16),                              X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(16(R4),4,X),1X,(20(R4),4,X),1X,(24(R4),4,X),1X,  X\n               (28(R4),4,X),3X,(16(R4),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE2          <== next line                 RS1007\n*        PIDTABLE moved to dynamic storage, get addressibility   PF0718\n         L     R7,ADR_PIDTABLE                                   PF0718\n         USING PIDCSECT,R7                                       PF0718\n         LR    R9,R7                   Start at first PID entry  PF0718\n*        ST    R5,DOUBLE           SET ADDRESS OF 1ST 16 BYTES   PF0420\n*        STRING64 4X,(DOUBLE,4,X),1X,                            PF0420X\n               ((R5),4,X),1X,(4(R5),4,X),1X,(8(R5),4,X),1X,      PF0420X\n               (12(R5),4,X),3X,((R5),16),                              X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        LA    R14,16(,R5)         GET ADDRESS OF NXT 16 BYTES   PF0420\n*        ST    R14,DOUBLE          SET ADDRESS OF NXT 16 BYTES   PF0420\n*        STRING64 4X,(DOUBLE,4,X),1X,                            PF0420X\n               (16(R5),4,X),1X,(20(R5),4,X),1X,(24(R5),4,X),1X,  PF0420X\n               (28(R5),4,X),3X,(16(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        LA    R14,32(,R5)         GET ADDRESS OF NXT 16 BYTES   PF0420\n*        ST    R14,DOUBLE          SET ADDRESS OF NXT 16 BYTES   PF0420\n*        STRING64 4X,(DOUBLE,4,X),1X,                            PF0420X\n               (32(R5),4,X),1X,(36(R5),4,X),1X,(40(R5),4,X),1X,  PF0420X\n               (44(R5),4,X),3X,(32(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n         MVC   CSECT_ACT_KZ(2),BLANKS  LANGUAGE-KZ               RS1107\n         L     R10,IEW_COUNTD            Number of sections      RS1007\n         LTR   R10,R10                                           RS1007\n         JNZ   BINDER_INFO_32          Have some, go analyze     PF0608\n         CLI   IEW_SECTION_DATA,X'00'  Binder-level name?        PF0608\n         JE    BINDER_INFO_31_1        Yes, don't save here      RS1007\n         LARL  R10,PID_TABLE_LAST      None avail, initialize    PF0608\n         ST    R10,ADR_PIDENTRY        Save for ESD scan         PF0608\n*        MVC   2(10,R10),=CL10'UnknownPID' Set PID to UNKNOWN    KP0609\n         CLC   SUM_DATE_SAVE,BLANKS    Any date saved yet?       PF0608\n         JNE   BINDER_INFO_31_1        Yes, don't change it      PF0608\n         MVC   SUM_DATE_SAVE,BLANKS    Clear for SUMMARY         PF0608\n         MVC   SUM_DATE_SAVE(9),=CL9'Unknown' Set to UNKNOWN     PF0608\nBINDER_INFO_31_1 DS 0H                                           PF0608\n         CLC   =CL9'Unknown',CSCLANG   Is main unknown?          PF0608\n         JNE   BINDER_INFO_40          No, leave SUMMARY alone   PF0608\n         MVI   FIXEDSUM,C'Y'           Remember we fixed this    PF0718\n         MVC   CSCCOMP(17),=CL17'No info available'              PF0608\n         J     BINDER_INFO_40          Leave, no entries at all  PF0608\n*        BCTR  R10,0               Not -1, process all entries   PF0608\nBINDER_INFO_32 DS 0H                                             RS1007\n         MVC   SUM_DATE_SAVE,IDL_DATE_PROCESSED Save for SUMMARY PF0608\n         USING IDL_ENTRY,R5                                      RS1007\n         LH    R15,IDL_RESIDENT_CHARS                            PF0420\n         BCTR  R15,0                  Decrement for EXecute      PF0420\n         L     R14,IDL_RESIDENT_PTR                              PF0420\n         MVC   ITEMNAME,BLANKS                                   PF0420\n         EX    R15,MOVE_ITEM_NAME                                PF0420\n         STRING64 11X,' B_IDRL ',                                      X\n               (IDL_DATE_PROCESSED,4),'.',                             X\n               (IDL_DATE_PROCESSED+4,3),1X,(IDL_PID_ID,10),            X\n               ' V',IDL_VERSION,                                       X\n               ' M',IDL_MOD_LEVEL,                               PF0420X\n               9X,',NAME=',ITEMNAME,   Leave room for PID name   PF0420X\n               INTO=RECORD                                       PF0420\n*        BRAS  R9,BINDER_INFO_32_1    ??????                     RS0620\n*   Most taken from Dave Alcock                                  RS1007\n*   Add indicators for all languages and sort by indicator/lang  PF0608\n*   and put it into a separate copy member to ease maintenance   PF0608\n*>---------------------------------------------------------------HP1107\n*   PIDTABLE moved to dynamic storage, R7 = Base, R9 = Current   PF0718\nBINDER_INFO_32_1 DS 0H                                           RS1007\n** table suffix 2byte for additional csect-analysis\n         CLC   IDL_PID_ID(10),2(R9)         check                HP1107\n         JE    BINDER_INFO_32_2        jump if on                RS1007\n         LA    R9,20(,R9)              Skip entry                HP1107\n         CLI   0(R9),0                 end of table?             RS1007\n         JNE   BINDER_INFO_32_1        not yet, loop             RS1007\nBINDER_INFO_32_2 DS 0H                                           RS1007\n         MVC   RECORD+47(8),12(R9)     long text for PID         HP1107\n         mvc   csect_act_kz(2),0(r9)   language-kz               HP1107\n         ST    R9,ADR_PIDENTRY         Save entry for ESD scan   PF0608\n*        CLI   0(R9),0                 End of table?             KP0609\n*        JNE   BINDER_INFO_32_3        No, don't copy Binder PID KP0609\n*        MVC   2(10,R9),IDL_PID_ID     Copy unknown PID to table KP0609\nBINDER_INFO_32_3 DS 0H                                           PF0608\n         CLC   =CL9'ASSEMBLER',CSCLANG Is main LE Assembler?     PF0718\n         JE    BINDER_INFO_32_4B       Yes, go fix compiler+date PF0718\n*                                      but not count values|     PF0718\n         CLC   =CL9'Unknown',CSCLANG   Is main unknown?          PF0608\n         JE    BINDER_INFO_32_31       Yes, try to fix language  PF0708\n         CLC   =CL9'*INVALID',CSCLANG  Is main invalid?          RS0316\n         JE    BINDER_INFO_32_30       Yes, try to fix language  RS0316\n         J     BINDER_INFO_32_5        No, leave SUMMARY alone   RS0316\nBINDER_INFO_32_30 DS 0H          Adjust counter and reset RC     RS0316\n         MVC   RETCODE,=F'0'           Reset RC                  RS0316\n         SP    CNT_INVALID,=P'1'  Subtract from INVALID count    RS0316\n         AP    CNT_UNKNOWN,=P'1'  Add from UNKNOWN count         RS0316\nBINDER_INFO_32_31 DS 0H                                          PF0608\n         CLC   PGMNAME_GET,IEW_SECT_NAME Section = LOAD name?    PF0420\n         JE    BINDER_INFO_32_4        Yes, go fix SUMMARY       PF0708\n         CLC   =CL8'MAIN',IEW_SECT_NAME Name = MAIN = FORTRAN?   PF0420\n         JNE   BINDER_INFO_32_5        No, leave SUMMARY alone   PF0708\nBINDER_INFO_32_4 DS 0H                                           PF0708\n         MVI   FIXEDSUM,C'Y'           Remember we fixed this    PF0608\n         BRAS  R14,ADJUST_COUNTS       Adjust language counts    PF0718\nBINDER_INFO_32_4A DS 0H                                          PF0718\n         MVC   CSCLANG(8),12(R9)       Compiler name to SUMMARY  PF0608\nBINDER_INFO_32_4B DS 0H                                          PF0718\n         MVC   CSCCOMP,02(R9)          PID, compname to SUMMARY  PF0608\n*                                      Compiler date to SUMMARY  PF0608\n         STRING64 (IDL_DATE_PROCESSED,4),'.',                    PF0608X\n               (IDL_DATE_PROCESSED+4,3),INTO=CSCDATE             PF0608\n*>---------------------------------------------------------------HP1107\nBINDER_INFO_32_5 DS 0H                                           PF0708\n         BRAS  R14,SPACE1          <== next line\n*        CLI   IDL_ENTRY+28,X'00'  Don't check here for more     PF0608\n*        JE    BINDER_INFO_33      entries, will process all     PF0608\n         J     BINDER_INFO_34    Go check for more entries       PF0608\nBINDER_INFO_32_6 DS 0H           Here for 2nd etc. IDRL entries  PF0708\n         LH    R15,IDL_RESIDENT_CHARS                            PF0420\n         BCTR  R15,0                  Decrement for EXecute      PF0420\n         L     R14,IDL_RESIDENT_PTR                              PF0420\n         MVC   ITEMNAME,BLANKS                                   PF0420\n         EX    R15,MOVE_ITEM_NAME                                PF0420\n         STRING64 11X,' B_IDRL ',                                PF0608X\n               (IDL_DATE_PROCESSED,4),'.',                       PF0608X\n               (IDL_DATE_PROCESSED+4,3),1X,(IDL_PID_ID,10),      PF0608X\n               ' V',IDL_VERSION,                                 PF0608X\n               ' M',IDL_MOD_LEVEL,                               PF0420X\n               9X,',NAME=',ITEMNAME,   Leave room for PID name   PF0420X\n               INTO=RECORD                                       PF0420\n         BRAS  R14,SPACE1          <== next line                 RS1007\nBINDER_INFO_33 DS 0H                                             RS1007\n*        STM   R14,R3,SNAPREGS         save registers            RS1007\n*        STRING64 '0-3 ',(SNAPREGS+08,4,X),1X,(SNAPREGS+12,4,X),       X\n               1X,(SNAPREGS+16,4,X),1X,(SNAPREGS+20,4,X),              X\n               '  4-7 ',((R4),,X),1X,((R5),,X),                        X\n               1X,((R6),,X),1X,((R7),,X),INTO=RECORD             RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 '8-B ',((R8),,X),1X,((R9),,X),1X,((R10),,X),         X\n               1X,((R11),,X),'  C-F ',((R12),,X),1X,((R13),,X),        X\n               1X,(SNAPREGS+00,4,X),1X,(SNAPREGS+04,4,X),INTO=RECORD\n*        BRAS  R14,SPACE2          <== next line                 RS1007\n*        Should be activated only in case of problems            PF0420\n*        ST    R5,DOUBLE           SET ADDRESS OF 1ST 16 BYTES   PF0420\n*        STRING64 4X,(DOUBLE,4,X),1X,                            PF0420X\n               ((R5),4,X),1X,(4(R5),4,X),1X,(8(R5),4,X),1X,      PF0420X\n               (12(R5),4,X),3X,((R5),16),                              X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        LA    R14,16(,R5)         GET ADDRESS OF NXT 16 BYTES   PF0420\n*        ST    R14,DOUBLE          SET ADDRESS OF 1ST 16 BYTES   PF0420\n*        STRING64 4X,(DOUBLE,4,X),1X,                            PF0420X\n               (16(R5),4,X),1X,(20(R5),4,X),1X,(24(R5),4,X),     PF0420X\n               1X,(28(R5),4,X),3X,(16(R5),16),                   PF0420X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        LA    R14,32(,R5)         GET ADDRESS OF NXT 16 BYTES   PF0420\n*        ST    R14,DOUBLE          SET ADDRESS OF 1ST 16 BYTES   PF0420\n*        STRING64 4X,(DOUBLE,4,X),1X,                            PF0420X\n               (32(R5),4,X),1X,(36(R5),4,X),1X,(40(R5),4,X),1X,  PF0420X\n               (44(R5),4,X),3X,(32(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(48(R5),4,X),1X,(52(R5),4,X),1X,(56(R5),4,X),1X,  X\n               (60(R5),4,X),3X,(48(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(64(R5),4,X),1X,(68(R5),4,X),1X,(72(R5),4,X),1X,  X\n               (76(R5),4,X),3X,(64(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(80(R5),4,X),1X,(84(R5),4,X),1X,(88(R5),4,X),1X,  X\n               (92(R5),4,X),3X,(80(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(96(R5),4,X),1X,(100(R5),4,X),1X,(104(R5),4,X),1X,X\n               (108(R5),4,X),3X,(96(R5),16),                           X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(112(R5),4,X),1X,(114(R5),4,X),1X,(116(R5),4,X),1X,\n               (122(R5),4,X),3X,(112(R5),16),                          X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE2          <== next line                 RS1007\nBINDER_INFO_34 DS 0H                                             RS1007\n         LTR   R10,R10              Only one entry?              RS1007\n         JZ    BINDER_INFO_40     yes, leave                     RS1007\n         A     R5,IDLH_ENTRY_LENG   Move to next section name    RS1007\n         CLI   IDL_PID_ID,C'$'    1st Byte of PID > dollar sign? PF0420\n         BNL   BINDER_INFO_34_1   Yes, good to go                PF0420\n         AHI   R10,-1             No, decrement entry counter    PF0420\n         J     BINDER_INFO_34     Go check entry count again     PF0420\nBINDER_INFO_34_1 DS 0H            Good to go at next entry       PF0420\n         BRCT  R10,BINDER_INFO_32_6 Just print info for 2nd etc. PF0708\n*        BRCT  R10,BINDER_INFO_32   Use second just like first?  PF0718\n*endloop\nBINDER_INFO_40 DS 0H\n         MVC   IEW_CURSORD,=F'0'      Clear Cursor               RS1007\n         MVC   IEW_COUNTD,=F'0'       Clear Count                PF0420\n         L     R4,IEW_ESDI_PTR                                   RS1007\n         USING IEWBESD,R4                                        RS1007\n*        IEWBUFF FUNC=INITBUF,TYPE=ESD     Init the buffer       RS1007\n         MVC   IEWBESD(ESDH_LENG),ESDI_INIT_VALUES               RS1007\n         MVC   IEWBIND_FUNCTION,=CL8'GETD-ESD'                   RS1007\n         LA    R5,ESDH_END                                       RS1007\n         USING ESD_ENTRY,R5                                      RS1007\n         IEWBIND FUNC=GETD,                                            X\n               RETCODE=IRETCODE,                                       X\n               RSNCODE=RSNCODE,                                        X\n               WORKMOD=IEW_WKTOKEN,                                    X\n               CLASS=IEW_ESD,                                          X\n               SECTION=IEW_SECTION,                                    X\n               AREA=IEWBESD,                                           X\n               CURSOR=IEW_CURSORD,                                     X\n               COUNT=IEW_COUNTD,                                       X\n               VERSION=4,                                              X\n               MF=(E,IEWBIND)                                    RS1007\n*        STRING64 '   GETD: ESD ',(IRETCODE,,X),' RSN: ',(RSNCODE,,X), X\n               'COUNT: ',(IEW_COUNTD,,X),' Token: ',(IEW_WKTOKEN,,X),  X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1                                        RS1007\n         CLC   RSNCODE,=F'0'      Check reason code              RS1007\n         JE    BINDER_INFO_41     continue if zero               RS1007\n*        CLC   IRETCODE,=F'4'     Do we have all the names       RS1007\n*        JH    BINDER_ERROR       Any higher is an error         RS1007\nBINDER_INFO_41 DS 0H                                             RS1007\n*                                                                RS1007\n*        Should be activated only in case of problems            RS1007\n*        STRING64 4X,((R4),4,X),1X,(4(R4),4,X),1X,(8(R4),4,X),1X,      X\n               (12(R4),4,X),3X,((R4),16),                              X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(16(R4),4,X),1X,(20(R4),4,X),1X,(24(R4),4,X),1X,  X\n               (28(R4),4,X),3X,(16(R4),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE2          <== next line                 RS1007\n         L     R10,IEW_COUNTD            Number of sections      RS1007\n         LTR   R10,R10                                           RS1007\n         JZ    BINDER_INFO_50                                    RS1007\n*        BCTR  R10,0                Not -1, process all entries  PF0420\n         USING ESD_ENTRY,R5                                      RS1007\nBINDER_INFO_42 DS 0H                                             RS1007\n         CLI   ESD_NAME_SPACE,X'02' Psuedo-Register name space?  PF0718\n         JE    BINDER_INFO_43       Yes, no useful info here     PF0718\n         CLI   ESD_NAME_SPACE,X'03' Parts in merge classes?      PF0718\n         JE    BINDER_INFO_43       Yes, no useful info here     PF0718\n*        Should be activated only in case of problems            PF0420\n*        STRING64 4X,((R5),4,X),1X,(4(R5),4,X),1X,(8(R5),4,X),   PF0420X\n               1X,(12(R5),4,X),2X,                               PF0420X\n               (16(R5),4,X),1X,(20(R5),4,X),1X,(24(R5),4,X),1X,  PF0420X\n               (28(R5),4,X),1X,                                  PF0420X\n               2X,'*',((R5),32),'*',                             PF0420X\n               INTO=RECORD                                       PF0420\n*        BRAS  R14,SPACE1          <== next line                 PF0420\n*        STRING64 4X,(32(R5),4,X),1X,(36(R5),4,X),1X,            PF0420X\n               (40(R5),4,X),1X,(44(R5),4,X),2X,                  PF0420X\n               (48(R5),4,X),1X,(52(R5),4,X),1X,(56(R5),4,X),1X,  PF0420X\n               11X,'*',(32(R5),28),'    *',                      PF0420X\n               INTO=RECORD                                       PF0420\n*        BRAS  R14,SPACE1          <== next line                 PF0420\n         CLI   ESD_NAME_SPACE,X'02' Psuedo-Register name space?  PF0420\n         JE    BINDER_INFO_43       Yes, no useful info here     PF0420\n         CLI   ESD_NAME_SPACE,X'03' Parts in merge classes?      PF0420\n         JE    BINDER_INFO_43       Yes, no useful info here     PF0420\n         MVC   ESDNAME,BLANKS       Initialize ESD name          PF0608\n         LH    R8,IEW_SECTION_LEN   Length of ESD name           PF0608\n         STRING64 (IEW_SECTION_DATA,(R8),),INTO=ESDNAME          PF0608\n*        Should be activated only in case of problems            PF0420\n*        STRING64 4X,'SECNAME=',(ESDNAME,,L8),                   PF0420X\n               ',ESD_TYPE=',(ESD_TYPE,,L2),                      PF0420X\n               ',NAME_CHARS=',(ESD_NAME_CHARS,,X),               PF0420X\n               ',NAME_PTR=',(ESD_NAME_PTR,,X),                   PF0420X\n               ',RES_CLASS_CHARS=',(ESD_RES_CLASS_CHARS,,X),     PF0420X\n               ',RES_CLASS_PTR=',(ESD_RES_CLASS_PTR,,X),         PF0420X\n               INTO=RECORD                                       PF0420\n*        BRAS  R14,SPACE1          <== next line                 PF0420\n*        LH    R1,ESD_NAME_CHARS      Length of  ESD   name      PF0420\n*        L     R2,ESD_NAME_PTR        Pointer to ESD   name      PF0420\n*        LTR   R1,R1                                             PF0420\n*        JZ    BINDER_INFO_42_BY1                                PF0420\n*        STRING64 4X,'SECTION=',(ESDNAME,,L8),                   PF0420X\n               ',ESD_NAME=',(0(R2),(R1),L),                      PF0420X\n               INTO=RECORD                                       PF0420\n*        BRAS  R14,SPACE1          <== next line                 PF0420\n*INDER_INFO_42_BY1 DS 0H                                         PF0420\n*        LH    R1,ESD_RES_CLASS_CHARS  Length of  CLASS name     PF0420\n*        L     R2,ESD_RES_CLASS_PTR    Pointer to CLASS name     PF0420\n*        LTR   R1,R1                                             PF0420\n*        JZ    BINDER_INFO_42_BY2                                PF0420\n*        STRING64 4X,'SECTION=',(ESDNAME,,L8),                   PF0420X\n               ',CLASS_NAME=',(0(R2),(R1),L),                    PF0420X\n               INTO=RECORD                                       PF0420\n*        BRAS  R14,SPACE1          <== next line                 PF0420\n*INDER_INFO_42_BY2 DS 0H                                         PF0420\n         CLC   ESD_TYPE,=C'SD'      Control section?             PF0608\n         JNE   BINDER_INFO_42_AMX   No, go check for Element Def PF0608\n         CLC   CSCAM,BLANKS         Already have AMODE?          PF0608\n         JNE   BINDER_INFO_42_AMX   Yes, go check for Element DefPF0608\n         CLI   FIXEDSUM,C'Y'        Fixed SUMMARY line?          PF0608\n         JE    BINDER_INFO_42_AM0   Yes, go get AMODE            PF0608\n         CLC   =CL9'Unknown',CSCLANG Is language UNKNOWN?        PF0608\n         JNE   BINDER_INFO_43       No, done with this element   PF0608\nBINDER_INFO_42_AM0 DS 0H                                         PF0608\n         CLC   PGMNAME_GET,ESDNAME  ESD name = LOAD name?        PF0608\n         JNE   BINDER_INFO_43       No, leave SUMMARY alone      PF0608\n         STRING64 '???',INTO=CSCAM  Start with unknown value     PF0608\n         CLI   ESD_AMODE,X'00'      Unspecified?                 PF0608\n         JE    BINDER_INFO_43       Yes, done with this element  PF0420\nBINDER_INFO_42_AM1 DS 0H                                         PF0608\n         CLI   ESD_AMODE,X'01'      24-bit?                      PF0608\n         JNE   BINDER_INFO_42_AM2   No, keep checking            PF0608\n         STRING64 '24 ',INTO=CSCAM  Set 24-bit in SUMMARY        PF0608\n         J     BINDER_INFO_43       Done with this element       PF0608\nBINDER_INFO_42_AM2 DS 0H                                         PF0608\n         CLI   ESD_AMODE,X'02'      31-bit?                      PF0608\n         JNE   BINDER_INFO_42_AM3   No, keep checking            PF0608\n         STRING64 '31 ',INTO=CSCAM  Set 31-bit in SUMMARY        PF0608\n         J     BINDER_INFO_43       Done with this element       PF0608\nBINDER_INFO_42_AM3 DS 0H                                         PF0608\n         CLI   ESD_AMODE,X'03'      ANY?                         PF0608\n         JNE   BINDER_INFO_42_AM4   No, keep checking            PF0608\n         STRING64 'ANY',INTO=CSCAM  Set ANY in SUMMARY           PF0608\n         J     BINDER_INFO_43       Done with this element       PF0608\nBINDER_INFO_42_AM4 DS 0H                                         PF0608\n         CLI   ESD_AMODE,X'06'      64-bit?                      PF0608\n         JNE   BINDER_INFO_42_AMX   No, keep checking            PF0608\n         STRING64 '64 ',INTO=CSCAM  Set 64-bit in SUMMARY        PF0608\n         J     BINDER_INFO_43       Done with this element       PF0608\nBINDER_INFO_42_AMX DS 0H                                         PF0608\n         CLC   ESD_TYPE,=C'ED'      Element Defnintion?          PF0608\n         JNE   BINDER_INFO_42_CSX   No, go check for Label Def   PF0608\n         BRAS  R14,GET_CLASS_INFO   Get CLASS offset for ED      PF0420\n         CLC   CSCRMODE,BLANKS      Already set RMODE?           PF0608\n         JNE   BINDER_INFO_42_RMX   Yes, done with RMODE analysisPF0608\n         CLI   FIXEDSUM,C'Y'        Fixed SUMMARY line?          PF0608\n         JE    BINDER_INFO_42_RMX   Yes, go get RMODE            PF0608\n         CLC   =CL9'Unknown',CSCLANG Is language UNKNOWN?        PF0608\n         JNE   BINDER_INFO_42_RMX   No, done with RMODE analysis PF0608\n         CLC   PGMNAME_GET,IEW_SECT_NAME Sect name = LOAD name?  PF0420\n         JE    BINDER_INFO_42_RM1      Yes, go get RMODE         PF0608\n***      REAL OFFSET IN P.O. IS CLASS OFFSET + ELEMENT OFFSET    PF0420\n***      ELEM OFFSET IN LMOD IS ZERO, SO WE CAN ALWAYS DO THIS   PF0420\n***      CLC   OFF_PGMNAME,ESD_CLASS_OFFSET At EP offset?        PF0420\n         L     R14,ESD_CLASS_OFFSET                              PF0420\n         A     R14,ESD_ELEM_OFFSET                               PF0420\n         C     R14,OFF_PGMNAME      At EP offset?                PF0420\n         JNE   BINDER_INFO_42_RMX   No, done with RMODE analysis PF0608\nBINDER_INFO_42_RM1 DS 0H                                         PF0608\n         STRING64 '???',INTO=CSCRMODE Start with unknown value   PF0608\n         CLI   ESD_RMODE,X'00'      Unspecified?                 PF0608\n         JE    BINDER_INFO_42_RMX   Yes, done with RMODE analysisPF0608\n         CLI   ESD_RMODE,X'01'      24-bit?                      PF0608\n         JNE   BINDER_INFO_42_RM2   No, keep checking            PF0608\n         STRING64 '24 ',INTO=CSCRMODE Set 24-bit in SUMMARY      PF0608\n         J     BINDER_INFO_42_RMX   Done with RMODE analysis     PF0608\nBINDER_INFO_42_RM2 DS 0H                                         PF0608\n         CLI   ESD_RMODE,X'03'      ANY?                         PF0608\n         JNE   BINDER_INFO_42_RMX   No, done with RMODE analysis PF0608\n         STRING64 'ANY',INTO=CSCRMODE Set ANY in SUMMARY         PF0608\nBINDER_INFO_42_RMX DS 0H                                         PF0608\n         CLC   PGMNAME_GET,ESDNAME  ESD name = LOAD name?        RS0316\n         JE    BINDER_INFO_42_RMX1  Yes, go set RMODE            RS0316\n         CLI   SETRMODE,C'Y'        Set RMODE done?              RS0316\n         JE    BINDER_INFO_42_RMY   Yes, no need to fix it twice RS0316\n         CLC   =CL8'CEESTART',ESDNAME     C/C++ or PLI           RS0316\n         JE    BINDER_INFO_42_RMX1        Yes, go fix SUMMARY    RS0316\n         CLC   =CL8'PLISTART',ESDNAME     PLI                    RS0316\n         JE    BINDER_INFO_42_RMX1        Yes, go fix SUMMARY    RS0316\n         CLC   OFF_PGMNAME,ESD_CLASS_OFFSET Correct offset?      RS0316\n         JNE   BINDER_INFO_42_RMY   no, dont set RMODE           RS0316\nBINDER_INFO_42_RMX1 DS 0H                                        RS0316\n         MVI   SETRMODE,C'Y'        Fixed SUMMARY line?          RS0316\n         MVC   BLDL_FF,=H'1'         number of entries           RS0516\n         MVC   BLDL_LL,=H'74'        lenght of entry             RS0516\n         MVC   BLDL_NAME,PGMNAME_GET name                        RS0516\n         BLDL  LOADL,BLDLLIST,NOCONNECT                          RS0516\n*        LA    R9,BLDLLIST\n*        STRING64 4X,((R9),4,X),1X,(4(R9),4,X),1X,(8(R9),4,X),1X,      X\n               (12(R9),4,X),3X,((R9),16),                              X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 4X,(16(R9),4,X),1X,(20(R9),4,X),1X,(24(R9),4,X),1X,  X\n               (28(R9),4,X),3X,(16(R9),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 4X,(32(R9),4,X),1X,(36(R9),4,X),1X,(40(R9),4,X),1X,  X\n               (44(R9),4,X),3X,(32(R9),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line\n         STRING64 '24',INTO=CSCRM    Start with RMODE 24         RS0516\n         TM    DIRATTR3,DIRRMANY    RMODE ANY specified          RS0516\n         JNO   BINDER_INFO_42_RMY   Yes, done with RMODE analysisRS0516\n         STRING64 'ANY',INTO=CSCRM    Set ANY in SUMMARY         RS0516\nBINDER_INFO_42_RMY DS 0H                                         RS0516\n         CLI   FIXEDSUM,C'Y'        Fixed SUMMARY line?          PF0608\n         JE    BINDER_INFO_42_UNX   Yes, no need to fix it twice PF0608\n         CLC   =CL9'Unknown',CSCLANG   Is main still unknown?    PF0608\n         JNE   BINDER_INFO_42_UNX      No, leave SUMMARY alone   PF0608\n         CLC   PGMNAME_GET,IEW_SECT_NAME Sect name = LOAD name?  PF0420\n         JE    BINDER_INFO_42_UN2      Yes, go fix SUMMARY       PF0608\n***      REAL OFFSET IN P.O. IS CLASS OFFSET + ELEMENT OFFSET    PF0420\n***      ELEM OFFSET IN LMOD IS ZERO, SO WE CAN ALWAYS DO THIS   PF0420\n***      CLC   OFF_PGMNAME,ESD_CLASS_OFFSET At EP offset?        PF0420\n         L     R14,ESD_CLASS_OFFSET                              PF0420\n         A     R14,ESD_ELEM_OFFSET                               PF0420\n         C     R14,OFF_PGMNAME      At EP offset?                PF0420\n         JH    BINDER_INFO_42_UNX      EP earlier, so done now   PF0420\n         JL    BINDER_INFO_42_UN1      Might be here, go check   PF0420\n* OK, this ESD is the entry point of the load module             PF0608\n         CLC   =CL8'MAIN',ESDNAME   ESD name = MAIN = FORTRAN?   PF0608\n         JNE   BINDER_INFO_42_UN2   No, go fix SUMMARY           PF0608\n* Not only EP, probably FORTRAN of some kind so set up PID Entry PF0608\n         L     R9,ADR_PIDENTRY      Check if PID is Unknown      PF0708\n         CLI   0(R9),0              Unknown entry is zeroes      PF0708\n         JNE   BINDER_INFO_42_UN2   Not unknown, leave it alone  PF0708\n         LARL  R9,PID_ENTRY_UNKFORT Get a(Unknown FORTRAN entry) PF0608\n         ST    R9,ADR_PIDENTRY      Save A(PID Table entry)      PF0608\n         J     BINDER_INFO_42_UN2      Now go fix SUMMARY        PF0708\nBINDER_INFO_42_UN1 DS 0H                                         PF0608\n         L     R15,ESD_LENG         Compute ESD end offset       PF0608\n         A     R15,ESD_CLASS_OFFSET                              PF0608\n***      REAL OFFSET IN P.O. IS CLASS OFFSET + ELEMENT OFFSET    PF0420\n***      ELEM OFFSET IN LMOD IS ZERO, SO WE CAN ALWAYS DO THIS   PF0420\n         A     R15,ESD_ELEM_OFFSET                               PF0420\n         C     R15,OFF_PGMNAME      Is end offset > Entry Offset?PF0608\n         JNH   BINDER_INFO_42_UNX   No, Entry Pt. not here       PF0608\nBINDER_INFO_42_UN2 DS 0H                                         PF0608\n         MVI   FIXEDSUM,C'Y'           Remember we fixed this    PF0608\n         L     R9,ADR_PIDENTRY         Get A(PID Table entry)    PF0608\n         MVC   CSCLANG(9),BLANKS       Initialize Compiler name  PF0420\n         MVC   CSCLANG(8),12(R9)       Compiler name to SUMMARY  PF0608\n         MVC   CSCCOMP,02(R9)          PID, compname to SUMMARY  PF0608\n*                                      Compiler date to SUMMARY  PF0608\n         STRING64 (SUM_DATE_SAVE,4),'.',                         PF0608X\n               (SUM_DATE_SAVE+4,3),INTO=CSCDATE                  PF0608\n         STRING64 'EP=',(OFF_PGMNAME,4,X),',NAME=',ESDNAME,      PF0608X\n               INTO=CSCLPRM                                      PF0608\n         BRAS  R14,ADJUST_COUNTS       Adjust language counts    PF0608\nBINDER_INFO_42_UNX DS 0H                                         PF0608\n         CLC   ESD_TYPE,=C'ED'      Element Defnintion?          PF0420\n         JNE   BINDER_INFO_42_XIT   No, don't print it           PF0420\n         LH    R15,ESD_RES_CLASS_CHARS  Length to move CLASS     PF0420\n         CHI   R15,8                Is length > 8?               PF0420\n         JH    BINDER_INFO_42_XIT   Yes, cannot be code class    PF0420\n         L     R14,ESD_RES_CLASS_PTR  A(ESD class name) to check PF0420\n         CLC   =C'C_CODE',0(R14)    Is it code?                  PF0420\n         JE    BINDER_INFO_42_PRT   Yes, print it                PF0420\n         CLC   =C'B_TEXT',0(R14)    Is it code?                  PF0420\n         JNE   BINDER_INFO_42_XIT   No, don't print it           PF0420\nBINDER_INFO_42_PRT DS 0H                                         PF0420\n         STRING64 11X,' B_ESD  ',9X,                                   X\n               'Length: ',(ESD_LENG,4,X),' Offsets: Class: ',    PF0420X\n               (ESD_CLASS_OFFSET,4,X),' Elem: ',                 PF0420X\n               (ESD_ELEM_OFFSET,4,X),' PGM: ',                   PF0420X\n               (OFF_PGMNAME,4,X),' NAME: ',                      PF0420X\n               (ESDNAME),' RM: ',                                PF0420X\n               (ESD_RMODE,1,X),                                  PF0420X\n               INTO=RECORD                                       PF0420\n         BRAS  R14,SPACE1          <== next line                 RS1007\nBINDER_INFO_42_XIT DS 0H                                         PF0420\n*>---------------------------------------------------------------HP1107\n*>- check & save cobol-csect-info                               -HP1107\n*>---------------------------------------------------------------HP1107\n         st    R3,saveR3                                         HP1107\n         st    R4,saveR4                                         HP1107\n         CLC   IEW_SECTION_DATA(8),=CL8'IGZESTUB' ignore         PF0608\n         JE    BINDER_INFO_42_0       Yes, skip                  PF0420\n         DEVTYPE =CL8'MAINONLY',DOUBLE  Get MAINONLY DD          RS0108\n         LTR   R15,R15                    Is it allocated?       RS0108\n         JZ    BINDER_INFO_42_0           Yes, leave             RS0108\n         CLC   PGMNAME_SAV,IEW_SECT_NAME Section = load?         PF0420\n         JE    BINDER_INFO_42_0       Yes, skip                  PF0420\n         cli   csect_act_kz,C'C'             cobol ?             HP1107\n         jne   BINDER_INFO_42_0              no, skip            HP1107\n         lh    R3,csect_anz_tabelem                              HP1107\n         LA    R3,1(,R3)                                         PF0718\n         ch    r3,=h'50'                     table full ?        HP1107\n         jh    BINDER_INFO_42_0              yes, skip           HP1107\n*******\n         L     R4,ESD_CLASS_OFFSET  CLASS-OFFSET                 PF0420\n***      REAL OFFSET IN P.O. IS CLASS OFFSET + ELEMENT OFFSET    PF0420\n***      ELEM OFFSET IN LMOD IS ZERO, SO WE CAN ALWAYS DO THIS   PF0420\n         A     R4,ESD_ELEM_OFFSET   ELEM-OFFSET                  PF0420\n         l     r1,CSV_LOADPT        load-point  lmod             HP1107\n         ar    r4,r1                csect-postion in lmod        HP1107\n         st    r4,csect_anf         csect-postion in lmod        HP1107\n         L     R1,ADR_PGMNAME       ep                           PF0420\n         cr    r4,r1                                             HP1107\n         je    BINDER_INFO_42_0     main-csect  |                HP1107\n*******\n         sth   R3,csect_anz_tabelem                              HP1107\n         l     R3,csect_tabelem_act                              HP1107\n         USING CSECT_ENTRY,R3                                    PF0420\n         mvc   0(2,r3),csect_act_kz          save that           HP1107\n***      REAL OFFSET IN P.O. IS CLASS OFFSET + ELEMENT OFFSET    PF0420\n***      ELEM OFFSET IN LMOD IS ZERO, SO WE CAN ALWAYS DO THIS   PF0420\n***      MVC   2(4,R3),ESD_CLASS_OFFSET                          PF0420\n         L     R15,ESD_CLASS_OFFSET                              PF0420\n         A     R15,ESD_ELEM_OFFSET                               PF0420\n         STCM  R15,B'1111',CE_OFF                                PF0420\n         MVC   CE_LEN,ESD_LENG                                   PF0420\n         LA    R3,L'CSECT_ENTRY(,R3)         next table entry    PF0420\n         st    R3,csect_tabelem_act                              HP1107\n         MVI   csect_analyze_kz,C'S'                             HP1107\n         DROP  R3                                                PF0420\nBINDER_INFO_42_0      DS 0H                                      HP1107\n         l     R3,saveR3                                         HP1107\n         l     R4,saveR4                                         HP1107\n*>---------------------------------------------------------------HP1107\n*        STM   R14,R3,SNAPREGS         save registers            RS1007\n*        STRING64 '0-3 ',(SNAPREGS+08,4,X),1X,(SNAPREGS+12,4,X),       X\n               1X,(SNAPREGS+16,4,X),1X,(SNAPREGS+20,4,X),              X\n               '  4-7 ',((R4),,X),1X,((R5),,X),                        X\n               1X,((R6),,X),1X,((R7),,X),INTO=RECORD             RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 '8-B ',((R8),,X),1X,((R9),,X),1X,((R10),,X),         X\n               1X,((R11),,X),'  C-F ',((R12),,X),1X,((R13),,X),        X\n               1X,(SNAPREGS+00,4,X),1X,(SNAPREGS+04,4,X),INTO=RECORD\n*        BRAS  R14,SPACE2          <== next line                 RS1007\n*        LM    R14,R3,SNAPREGS         save registers            RS1007\n*        STRING64 4X,((R5),4,X),1X,(4(R5),4,X),1X,(8(R5),4,X),1X,      X\n               (12(R5),4,X),3X,((R5),16),                              X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(16(R5),4,X),1X,(20(R5),4,X),1X,(24(R5),4,X),1X,  X\n               (28(R5),4,X),3X,(16(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(32(R5),4,X),1X,(36(R5),4,X),1X,(40(R5),4,X),1X,  X\n               (44(R5),4,X),3X,(32(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(48(R5),4,X),1X,(52(R5),4,X),1X,(56(R5),4,X),1X,  X\n               (60(R5),4,X),3X,(48(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(64(R5),4,X),1X,(68(R5),4,X),1X,(72(R5),4,X),1X,  X\n               (76(R5),4,X),3X,(64(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(80(R5),4,X),1X,(84(R5),4,X),1X,(88(R5),4,X),1X,  X\n               (92(R5),4,X),3X,(80(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(96(R5),4,X),1X,(100(R5),4,X),1X,(104(R5),4,X),1X,X\n               (108(R5),4,X),3X,(96(R5),16),                           X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(112(R5),4,X),1X,(114(R5),4,X),1X,(116(R5),4,X),1X,\n               (122(R5),4,X),3X,(112(R5),16),                          X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE2          <== next line                 RS1007\n*        J     BINDER_INFO_50      Only one ESD_TYPE = ED !!!!   PF0608\n         J     BINDER_INFO_43      No, now also process SD, LD   PF0608\nBINDER_INFO_42_CSX DS 0H                                         PF0608\n         CLC   ESD_TYPE,=C'LD'      Label Definition?            PF0608\n         JNE   BINDER_INFO_43       No, done with this element   PF0608\n         CLI   FIXEDSUM,C'Y'        Fixed SUMMARY line?          PF0608\n         JNE   BINDER_INFO_43       No, done with this element   PF0608\n***      REAL OFFSET IN P.O. IS CLASS OFFSET + ELEMENT OFFSET    PF0420\n***      ELEM OFFSET IN LMOD IS ZERO, SO WE CAN ALWAYS DO THIS   PF0420\n***      CLC   OFF_PGMNAME,ESD_CLASS_OFFSET At EP offset?        PF0420\n         L     R14,ESD_CLASS_OFFSET                              PF0420\n         A     R14,ESD_ELEM_OFFSET                               PF0420\n         C     R14,OFF_PGMNAME      At EP offset?                PF0420\n         JNE   BINDER_INFO_43       No, done with this element   PF0608\n* OK, this LD is the entry point of the UNKNOWN load module      PF0608\n         LH    R8,ESD_NAME_CHARS    Length of LD name            PF0608\n         L     R2,ESD_NAME_PTR      Name pointer                 PF0608\n         STRING64 'EP=',(OFF_PGMNAME,4,X),',NAME=',              PF0608X\n               (0(R2),(R8),),INTO=CSCLPRM                        PF0608\n*        J     BINDER_INFO_43       Now done with this element   PF0608\nBINDER_INFO_43 DS 0H                                             RS1007\n         LTR   R10,R10              Only one entry?              RS1007\n         JZ    BINDER_INFO_50     yes, leave                     RS1007\n         A     R5,ESDH_ENTRY_LENG   Move to next section name    RS1007\n         BRCT  R10,BINDER_INFO_42                                RS1007\n*endloop                                                         RS1007\nBINDER_INFO_50 DS 0H                                             RS1007\n         LA    R3,IEW_SECT_NAME   Extract section name           PF0420\n         MVC   IEW_SECTION_DATA(255),BLANKS                      PF0420\n         L     R2,IEW_SECT_LEN                                   PF0420\n         STH   R2,IEW_SECTION_LEN                                PF0420\n         STRING64 (0(R3),(R2),),INTO=IEW_SECTION_DATA Set Name   PF0420\n         MVC   IEW_CURSORD,=F'0'      Clear Cursor               RS1007\n         L     R4,IEW_IDUI_PTR                                   RS1007\n         USING IEWBIDU,R4                                        RS1007\n*        IEWBUFF FUNC=INITBUF,TYPE=IDU     Init the buffer       RS1007\n         MVC   IEWBIDU(IDUH_LENG),IDUI_INIT_VALUES               RS1007\n         MVC   IEWBIND_FUNCTION,=CL8'GETD-IDU'                   RS1007\n         LA    R5,IDUH_END                                       RS1007\n         USING IDU_ENTRY,R5                                      PF0420\n         IEWBIND FUNC=GETD,                                            X\n               RETCODE=IRETCODE,                                       X\n               RSNCODE=RSNCODE,                                        X\n               WORKMOD=IEW_WKTOKEN,                                    X\n               CLASS=IEW_IDU,                                          X\n               SECTION=IEW_SECTION,                                    X\n               AREA=IEWBIDU,                                           X\n               CURSOR=IEW_CURSORD,                                     X\n               COUNT=IEW_COUNTD,                                       X\n               VERSION=4,                                              X\n               MF=(E,IEWBIND)                                    RS1007\n*        STRING64 '   GETD: IDU ',(IRETCODE,,X),' RSN: ',(RSNCODE,,X), X\n               'COUNT: ',(IEW_COUNTD,,X),' Token: ',(IEW_WKTOKEN,,X),  X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1                                        RS1007\n         CLC   RSNCODE,=F'0'      Check reason code              RS1007\n         JE    BINDER_INFO_51     continue if zero               RS1007\n*        CLC   IRETCODE,=F'4'     Do we have all the names       RS1007\n*        JH    BINDER_ERROR       Any higher is an error         RS1007\nBINDER_INFO_51 DS 0H                                             RS1007\n*        Should be activated only in case of problems            RS1007\n*        STRING64 4X,'IDU COUNT=',(IEW_COUNTD,,X),               PF0420X\n               INTO=RECORD                                       PF0420\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,((R4),4,X),1X,(4(R4),4,X),1X,(8(R4),4,X),1X,      X\n               (12(R4),4,X),3X,((R4),16),                              X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(16(R4),4,X),1X,(20(R4),4,X),1X,(24(R4),4,X),1X,  X\n               (28(R4),4,X),3X,(16(R4),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE2          <== next line                 RS1007\n         L     R10,IEW_COUNTD            Number of sections      RS1007\n         LTR   R10,R10                                           RS1007\n         JZ    BINDER_INFO_60                                    RS1007\n*        BCTR  R10,0                Not -1, process all entries  PF0420\nBINDER_INFO_52 DS 0H                                             RS1007\n         LH    R15,IDU_RESIDENT_CHARS                            PF0420\n         BCTR  R15,0                  Decrement for EXecute      PF0420\n         L     R14,IDU_RESIDENT_PTR                              PF0420\n         MVC   ITEMNAME,BLANKS                                   PF0420\n         EX    R15,MOVE_ITEM_NAME                                PF0420\n*        STRING64 4X,'ITEM=',(ITEMNAME,L'IEW_SECT_NAME),         PF0420X\n               ',IEW_SECT_NAME=',IEW_SECT_NAME,                  PF0420X\n               INTO=RECORD                                       PF0420\n*        BRAS  R14,SPACE1          <== next line                 PF0420\n         CLC   ITEMNAME,IEW_SECT_NAME  Same name?                PF0420\n         JNE   BINDER_INFO_53      If not the same do not print  PF0420\n         LH    R0,IDU_DATA_CHARS                                 RS1007\n*        STRING64 11X,'B_IDRU ',                                       X\n               (IDU_CREATE_DATE,4),'.',(IDU_CREATE_DATE+4,3),          X\n               1X,(IDU_DATA,(R0),),INTO=RECORD                   RS1007\n         STRING64 11X,' B_IDRU ',                                      X\n               (IDU_CREATE_DATE,4),'.',(IDU_CREATE_DATE+4,3),          X\n               1X,(IDU_DATA,(R0),),                              PF0420X\n               ',NAME=',ITEMNAME,                                PF0420X\n               INTO=RECORD                                       PF0420\n         BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 2X,((R3),(R2),),1X,IDL_PID_ID,1X,'V',IDL_VERSION,    X\n               ' M',IDL_MOD_LEVEL,1X,(IDL_DATE_PROCESSED,4),'.',       X\n               (IDL_DATE_PROCESSED+4,,3),INTO=RECORD             RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STM   R14,R3,SNAPREGS         save registers            RS1007\n*        STRING64 '0-3 ',(SNAPREGS+08,4,X),1X,(SNAPREGS+12,4,X),       X\n               1X,(SNAPREGS+16,4,X),1X,(SNAPREGS+20,4,X),              X\n               '  4-7 ',((R4),,X),1X,((R5),,X),                        X\n               1X,((R6),,X),1X,((R7),,X),INTO=RECORD             RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 '8-B ',((R8),,X),1X,((R9),,X),1X,((R10),,X),         X\n               1X,((R11),,X),'  C-F ',((R12),,X),1X,((R13),,X),        X\n               1X,(SNAPREGS+00,4,X),1X,(SNAPREGS+04,4,X),INTO=RECORD\n*        BRAS  R14,SPACE2          <== next line                 RS1007\n*        LM    R14,R3,SNAPREGS         save registers            RS1007\n*        STRING64 4X,((R5),4,X),1X,(4(R5),4,X),1X,(8(R5),4,X),1X,      X\n               (12(R5),4,X),3X,((R5),16),                              X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(16(R5),4,X),1X,(20(R5),4,X),1X,(24(R5),4,X),1X,  X\n               (28(R5),4,X),3X,(16(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(32(R5),4,X),1X,(36(R5),4,X),1X,(40(R5),4,X),1X,  X\n               (44(R5),4,X),3X,(32(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(48(R5),4,X),1X,(52(R5),4,X),1X,(56(R5),4,X),1X,  X\n               (60(R5),4,X),3X,(48(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(64(R5),4,X),1X,(68(R5),4,X),1X,(72(R5),4,X),1X,  X\n               (76(R5),4,X),3X,(64(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(80(R5),4,X),1X,(84(R5),4,X),1X,(88(R5),4,X),1X,  X\n               (92(R5),4,X),3X,(80(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(96(R5),4,X),1X,(100(R5),4,X),1X,(104(R5),4,X),1X,X\n               (108(R5),4,X),3X,(96(R5),16),                           X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(112(R5),4,X),1X,(114(R5),4,X),1X,(116(R5),4,X),  X\n               1X,(122(R5),4,X),3X,(112(R5),16),                       X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE2          <== next line                 RS1007\nBINDER_INFO_53 DS 0H                                             RS1007\n         LTR   R10,R10              Only one entry?              RS1007\n         JZ    BINDER_INFO_60     yes, leave                     RS1007\n         A     R5,IDUH_ENTRY_LENG   Move to next section name    RS1007\n         BRCT  R10,BINDER_INFO_52                                RS1007\n*endloop                                                         RS1007\nBINDER_INFO_60 DS 0H                                             RS1007\n         MVC   IEW_CURSORD,=F'0'      Clear Cursor               RS1007\n         L     R4,IEW_IDZI_PTR                                   RS1007\n         USING IEWBIDZ,R4                                        RS1007\n*        IEWBUFF FUNC=INITBUF,TYPE=IDL     Init the buffer       RS1007\n         MVC   IEWBIDZ(IDZH_LENG),IDZI_INIT_VALUES               RS1007\n         MVC   IEWBIND_FUNCTION,=CL8'GETD-IDZ'                   RS1007\n         LA    R5,IDZH_END                                       RS1007\n         USING IDZ_ENTRY,R5                                      RS1007\n         IEWBIND FUNC=GETD,                                            X\n               RETCODE=IRETCODE,                                       X\n               RSNCODE=RSNCODE,                                        X\n               WORKMOD=IEW_WKTOKEN,                                    X\n               CLASS=IEW_IDZ,                                          X\n               SECTION=IEW_SECTION,                                    X\n               AREA=IEWBIDZ,                                           X\n               CURSOR=IEW_CURSORD,                                     X\n               COUNT=IEW_COUNTD,                                       X\n               VERSION=4,                                              X\n               MF=(E,IEWBIND)                                    RS1007\n*        STRING64 '   GETD: IDZ ',(IRETCODE,,X),' RSN: ',(RSNCODE,,X), X\n               'COUNT: ',(IEW_COUNTD,,X),' Token: ',(IEW_WKTOKEN,,X),  X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1                                        RS1007\n         CLC   RSNCODE,=F'0'      Check reason code              RS1007\n         JE    BINDER_INFO_61     continue if zero               RS1007\n*        CLC   IRETCODE,=F'4'     Do we have all the names       RS1007\n*        JH    BINDER_ERROR       Any higher is an error         RS1007\nBINDER_INFO_61 DS 0H                                             RS1007\n*        Should be activated only in case of problems            RS1007\n*        STRING64 4X,((R4),4,X),1X,(4(R4),4,X),1X,(8(R4),4,X),1X,      X\n               (12(R4),4,X),3X,((R4),16),                              X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(16(R4),4,X),1X,(20(R4),4,X),1X,(24(R4),4,X),1X,  X\n               (28(R4),4,X),3X,(16(R4),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE2          <== next line                 RS1007\n         L     R10,IEW_COUNTD            Number of sections      RS1007\n         LTR   R10,R10                                           RS1007\n         JZ    BINDER_INFO_70                                    RS1007\n*        BCTR  R10,0                Not -1, process all entries  PF0420\n         USING IDZ_ENTRY,R5                                      RS1007\nBINDER_INFO_62 DS 0H                                             RS1007\n*        STRING64 11X,' B_IDRZ ',(IDZ_DATE,4),'.',(IDZ_DATE+4,3),      X\n               1X,(IDZ_ZAP_DATA,8),INTO=RECORD                   RS1007\n         STRING64 21X,' B_IDRZ ',                                      X\n               (IDZ_DATE,4),'.',(IDZ_DATE+4,3),                        X\n               1X,(IDZ_ZAP_DATA,8),INTO=RECORD                   RS1007\n         BRAS  R14,SPACE1          <== next line                 RS1007\n*        STM   R14,R3,SNAPREGS         save registers            RS1007\n*        STRING64 '0-3 ',(SNAPREGS+08,4,X),1X,(SNAPREGS+12,4,X),       X\n               1X,(SNAPREGS+16,4,X),1X,(SNAPREGS+20,4,X),              X\n               '  4-7 ',((R4),,X),1X,((R5),,X),                        X\n               1X,((R6),,X),1X,((R7),,X),INTO=RECORD             RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 '8-B ',((R8),,X),1X,((R9),,X),1X,((R10),,X),         X\n               1X,((R11),,X),'  C-F ',((R12),,X),1X,((R13),,X),        X\n               1X,(SNAPREGS+00,4,X),1X,(SNAPREGS+04,4,X),INTO=RECORD\n*        BRAS  R14,SPACE2          <== next line                 RS1007\n*        LM    R14,R3,SNAPREGS         save registers            RS1007\n*        STRING64 4X,((R5),4,X),1X,(4(R5),4,X),1X,(8(R5),4,X),1X,      X\n               (12(R5),4,X),3X,((R5),16),                              X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(16(R5),4,X),1X,(20(R5),4,X),1X,(24(R5),4,X),1X,  X\n               (28(R5),4,X),3X,(16(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(32(R5),4,X),1X,(36(R5),4,X),1X,(40(R5),4,X),1X,  X\n               (44(R5),4,X),3X,(32(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(48(R5),4,X),1X,(52(R5),4,X),1X,(56(R5),4,X),1X,  X\n               (60(R5),4,X),3X,(48(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(64(R5),4,X),1X,(68(R5),4,X),1X,(72(R5),4,X),1X,  X\n               (76(R5),4,X),3X,(64(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(80(R5),4,X),1X,(84(R5),4,X),1X,(88(R5),4,X),1X,  X\n               (92(R5),4,X),3X,(80(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(96(R5),4,X),1X,(100(R5),4,X),1X,(104(R5),4,X),1X,X\n               (108(R5),4,X),3X,(96(R5),16),                           X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(112(R5),4,X),1X,(114(R5),4,X),1X,(116(R5),4,X),1X,\n               (122(R5),4,X),3X,(112(R5),16),                          X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE2          <== next line                 RS1007\nBINDER_INFO_63 DS 0H                                             RS1007\n         LTR   R10,R10              Only one entry?              RS1007\n         JZ    BINDER_INFO_70     yes, leave                     RS1007\n         A     R5,IDZH_ENTRY_LENG   Move to next section name    RS1007\n         BRCT  R10,BINDER_INFO_62                                RS1007\n*endloop                                                         RS1007\nBINDER_INFO_70 DS 0H                                             RS1007\n         MVC   IEW_CURSORD,=F'0'      Clear Cursor               RS1007\n         L     R4,IEW_IDBI_PTR                                   RS1007\n         USING IEWBIDB,R4                                        RS1007\n*        IEWBUFF FUNC=INITBUF,TYPE=IDB     Init the buffer       RS1007\n         MVC   IEWBIDB(IDBH_LENG),IDBI_INIT_VALUES               RS1007\n         MVC   IEWBIND_FUNCTION,=CL8'GETD-IDB'                   RS1007\n         LA    R5,IDBH_END                                       RS1007\n         USING IDB_ENTRY,R5                                      RS1007\n         IEWBIND FUNC=GETD,                                            X\n               RETCODE=IRETCODE,                                       X\n               RSNCODE=RSNCODE,                                        X\n               WORKMOD=IEW_WKTOKEN,                                    X\n               CLASS=IEW_IDB,                                          X\n               SECTION=IEW_SECTION,                                    X\n               AREA=IEWBIDB,                                           X\n               CURSOR=IEW_CURSORD,                                     X\n               COUNT=IEW_COUNTD,                                       X\n               VERSION=4,                                              X\n               MF=(E,IEWBIND)                                    RS1007\n*        STRING64 '   GETD: IDB ',(IRETCODE,,X),' RSN: ',(RSNCODE,,X), X\n               'COUNT: ',(IEW_COUNTD,,X),' Token: ',(IEW_WKTOKEN,,X),  X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1                                        RS1007\n         CLC   RSNCODE,=F'0'      Check reason code              RS1007\n         JE    BINDER_INFO_71     continue if zero               RS1007\n*        CLC   IRETCODE,=F'4'     Do we have all the names       RS1007\n*        JH    BINDER_ERROR       Any higher is an error         RS1007\nBINDER_INFO_71 DS 0H                                             RS1007\n*        Should be activated only in case of problems            RS1007\n*        STRING64 4X,((R4),4,X),1X,(4(R4),4,X),1X,(8(R4),4,X),1X,      X\n               (12(R4),4,X),3X,((R4),16),                              X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(16(R4),4,X),1X,(20(R4),4,X),1X,(24(R4),4,X),1X,  X\n               (28(R4),4,X),3X,(16(R4),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE2          <== next line                 RS1007\n         L     R10,IEW_COUNTD            Number of sections      RS1007\n         LTR   R10,R10                                           RS1007\n         JZ    BINDER_INFO_80                                    RS1007\n         BCTR  R10,0                     -1                      RS1007\n         USING IDB_ENTRY,R5                                      RS1007\n         CLC   SUM_DATE_SAVE,BLANKS    Any date saved yet?       PF0608\n         JNE   BINDER_INFO_72          Yes, don't change it      PF0608\n         MVC   SUM_DATE_SAVE,IDB_DATE_BOUND Save for SUMMARY     PF0608\nBINDER_INFO_72 DS 0H                                             RS1007\n         STRING64 '  Bound   :',' B_IDRB ',                            X\n               (IDB_DATE_BOUND,4),'.',(IDB_DATE_BOUND+4,3),1X,         X\n               (IDB_BINDER_ID,10),' V',(IDB_VERSION,2),' M',           X\n               (IDB_RELEASE,2),INTO=RECORD                       RS1007\n         BRAS  R9,BINDER_INFO_72_1                               RS1007\n*   Most Taken from Dave Alcock                                  RS1007\n         DC    CL10'5695DF108 ',CL16'DFSMS Binder'               RS1007\n         DC    CL10'566528408 ',CL16'DFP/XA LKED'                PF0420\n         DC    CL10'566529508 ',CL16'DFP/370 LKED'               PF0420\n         DC    CL10'5752SC104 ',CL16'OS/VS LKED'                 PF0420\n         DC    CL10'04LE960488',CL16'MVSLKED'                    RS1007\n*   Roland                                                       RS1007\n         DC    CL10'5695PMB01 ',CL16'z/OS Binder '               RS1007\n*   Gilbert St-Fleur                                             PF0420\n         DC    CL10'360SED510 ',CL16'OS/360 LKED (E)'            PF0420\n         DC    CL10'360SED521 ',CL16'OS/360 LKED (F)'            PF0420\n         DC    XL10'0000',CL16'Unknown'             end of table RS1007\nBINDER_INFO_72_1 DS 0H                                           RS1007\n         CLC   IDB_BINDER_ID(10),0(R9)         check             RS1007\n         JE    BINDER_INFO_72_2        jump if on                RS1007\n         LA    R9,26(,R9)              Skip entry                RS1007\n         CLI   0(R9),0                 end of table?             RS1007\n         JNE   BINDER_INFO_72_1        not yet, loop             RS1007\nBINDER_INFO_72_2 DS 0H                                           RS1007\n         MVC   RECORD+47(16),10(R9)    long text for Binder-ID   RS1007\n         BRAS  R14,SPACE2          <== next line                 RS1007\n*        STM   R14,R3,SNAPREGS         save registers            RS1007\n*        STRING64 '0-3 ',(SNAPREGS+08,4,X),1X,(SNAPREGS+12,4,X),       X\n               1X,(SNAPREGS+16,4,X),1X,(SNAPREGS+20,4,X),              X\n               '  4-7 ',((R4),,X),1X,((R5),,X),                        X\n               1X,((R6),,X),1X,((R7),,X),INTO=RECORD             RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 '8-B ',((R8),,X),1X,((R9),,X),1X,((R10),,X),         X\n               1X,((R11),,X),'  C-F ',((R12),,X),1X,((R13),,X),        X\n               1X,(SNAPREGS+00,4,X),1X,(SNAPREGS+04,4,X),INTO=RECORD\n*        BRAS  R14,SPACE2          <== next line                 RS1007\n*        LM    R14,R3,SNAPREGS         save registers            RS1007\n*        STRING64 4X,((R5),4,X),1X,(4(R5),4,X),1X,(8(R5),4,X),1X,      X\n               (12(R5),4,X),3X,((R5),16),                              X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(16(R5),4,X),1X,(20(R5),4,X),1X,(24(R5),4,X),1X,  X\n               (28(R5),4,X),3X,(16(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(32(R5),4,X),1X,(36(R5),4,X),1X,(40(R5),4,X),1X,  X\n               (44(R5),4,X),3X,(32(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(48(R5),4,X),1X,(52(R5),4,X),1X,(56(R5),4,X),1X,  X\n               (60(R5),4,X),3X,(48(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(64(R5),4,X),1X,(68(R5),4,X),1X,(72(R5),4,X),1X,  X\n               (76(R5),4,X),3X,(64(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(80(R5),4,X),1X,(84(R5),4,X),1X,(88(R5),4,X),1X,  X\n               (92(R5),4,X),3X,(80(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(96(R5),4,X),1X,(100(R5),4,X),1X,(104(R5),4,X),1X,X\n               (108(R5),4,X),3X,(96(R5),16),                           X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(112(R5),4,X),1X,(114(R5),4,X),1X,(116(R5),4,X),1X,\n               (122(R5),4,X),3X,(112(R5),16),                          X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE2          <== next line                 RS1007\nBINDER_INFO_73 DS 0H                                             RS1007\n         LTR   R10,R10              Only one entry?              RS1007\n         JZ    BINDER_INFO_80     yes, leave                     RS1007\n         A     R5,IDBH_ENTRY_LENG   Move to next section name    RS1007\n         BRCT  R10,BINDER_INFO_72                                RS1007\n*endloop                                                         RS1007\nBINDER_INFO_80 DS 0H                                             RS1007\n         LM    R4,R5,SAVER4_AND_R5                               RS1007\n         USING IEWBBNL,R4                                        RS1007\n         USING BNL_ENTRY,R5                                      RS1007\n         A     R5,BNLH_ENTRY_LENG   Move to next section name\n         BRCT  R12,BINDER_INFO_20\n*endloop                                                         RS1007\n*                                                                 *CSC*\nBINDER_INFO_85 DS 0H                                             RS1007\n         CLC   IEW_WKTOKEN,XFF      Do we have a workmod?        PF0608\n         JE    BINDER_INFO_90       No, bypass DELETEW           PF0608\n         MVC   IEWBIND_FUNCTION,=CL8'DELETEW'                     *CSC*\n         IEWBIND FUNC=DELETEW,                                         X\n               RETCODE=IRETCODE,                                       X\n               RSNCODE=RSNCODE,                                        X\n               WORKMOD=IEW_WKTOKEN,                                    X\n               PROTECT=YES,                                            X\n               VERSION=4,                                              X\n               MF=(E,IEWBIND)\n*        STRING64 'DELETEW: RC: ',(IRETCODE,,X),' RSN: ',(RSNCODE,,X), X\n               INTO=RECORD\n*        BRAS  R14,SPACE1\n         CLI   DOUBLE,C'Y'          Invoked from Binder-Error ?  RS0105\n         JE    BINDER_INFO_90          don't check RC            RS1007\n         CLC   RSNCODE,=F'0'\n         JNE   BINDER_ERROR\nBINDER_INFO_90 DS 0H                                             RS1007\n         CLC   IEW_DTOKEN,XFF       Was a dialog started?        PF0608\n         JE    BINDER_END           No, just exit                PF0608\n         MVC   IEWBIND_FUNCTION,=CL8'ENDD'                        *CSC*\n         IEWBIND FUNC=ENDD,                                            X\n               RETCODE=IRETCODE,                                       X\n               RSNCODE=RSNCODE,                                        X\n               DIALOG=IEW_DTOKEN,                                      X\n               VERSION=4,                                              X\n               MF=(E,IEWBIND)\n*        STRING64 'ENDD   : RC: ',(IRETCODE,,X),' RSN: ',(RSNCODE,,X), X\n               'DTOKEN: ',(IEW_DTOKEN,,X),                             X\n               INTO=RECORD\n*        BRAS  R14,SPACE1\n         CLI   DOUBLE,C'Y'          Invoked from Binder-Error ?  RS0105\n         JE    BINDER_END              don't check RC            RS0105\n         CLC   RSNCODE,=F'0'\n         JNE   BINDER_ERROR\n*        IEWBUFF FUNC=FREEBUF,TYPE=NAME\n         J     BINDER_END\nBINDER_ERROR DS 0H\n         MVI   DOUBLE,C'Y'     Status Binder_Error ||            RS0105\n         STRING64 'IEWBIND: RC: ',(IRETCODE,,X),' RSN: ',(RSNCODE,,X), X\n               ' FUNCTION:',IEWBIND_FUNCTION,                     *CSC*X\n               ' SEC-L:',(IEW_SECTION_LEN,2,X),INTO=RECORD       PF0608\n         BRAS  R14,SPACE1\n         STRING64 'Binder function failed, no further ',         PF0608X\n               'information is available from the binder.',      PF0608X\n               INTO=RECORD                                       PF0608\n         BRAS  R14,SPACE1                                        PF0608\n         J     BINDER_INFO_85       Issue DELETEW to rel storage RS1007\nBINDER_END   DS 0H\n*>---------------------------------------------------------------HP1107\n         CLI   csect_analyze_kz,C'S'  any more csects ?          HP1107\n         jne   BINDER_END_0                                      HP1107\n         BRAS  R14,BLANK1                                        HP1107\n         STRING64 '------------ Found additional COBOL modules includ',X\n               'ed, will report them later ------------------------',  X\n               INTO=RECORD\n         BRAS  R14,SPACE2                                        HP1107\nBINDER_END_0 DS 0H\n         st    R3,saveR3                                         HP1107\n         la    R3,csect_table       anf of csect-table (cobol)   HP1107\n         st    R3,csect_tabelem_act                              HP1107\n         l     R3,saveR3                                         HP1107\n*>---------------------------------------------------------------HP1107\n         MVI   DOUBLE,C' '     Status Binder_Error ||            RS0105\n         L     R14,BINDSAVE         Restore R14\n         BR    R14            return\n         DROP  R4,R5\n*------------------------------------------------------------*   PF0420\n* Find ESD Class Name in Class buffer and copy segment offset*   PF0420\n*------------------------------------------------------------*   PF0420\n*                                                                PF0420\nGET_CLASS_INFO DS 0H                                             PF0420\n         USING IEWBESD,R4                                        PF0420\n         USING ESD_ENTRY,R5                                      PF0420\n         ST    R14,CLASSSAVE  Save return register               PF0420\n         STM   R8,R10,CLASSSAVE2 Save working registers          PF0420\n         L     R8,IEW_CLASS_BNLI_PTR Point to class buffer       PF0420\n         USING CLASS_IEWBBNL,R8                                  PF0420\n         LA    R9,CLASS_BNLH_END Point to class entries          PF0420\n         USING CLASS_BNL_ENTRY,R9                                PF0420\n         L     R10,IEW_COUNTN_CLASS Count of class names         PF0420\n         L     R14,ESD_RES_CLASS_PTR  Get ESD class name to find PF0420\n         LH    R15,ESD_RES_CLASS_CHARS  and length to move       PF0420\n         BCTR  R15,0                Less 1 for move              PF0420\n         MVC   ESD_CLASS_NAME,BLANKS                             PF0420\n         EX    R15,MOVE_ESD_CLASS   Move to work area            PF0420\nGET_CLASS_LOOP DS 0H                                             PF0420\n         L     R14,CLASS_BNL_NAME_PTR Get BNL class name         PF0420\n         LH    R15,CLASS_BNL_NAME_CHARS and length to move       PF0420\n         BCTR  R15,0                Less 1 for move              PF0420\n         MVC   BNL_CLASS_NAME,BLANKS                             PF0420\n         EX    R15,MOVE_BNL_CLASS   Move to work area            PF0420\n         CLC   BNL_CLASS_NAME,ESD_CLASS_NAME Got it?             PF0420\n         JE    GET_CLASS_DONE         Yes                        PF0420\n         A     R9,CLASS_BNLH_ENTRY_LENG Bump to next class entry PF0420\n         BRCT  R10,GET_CLASS_LOOP     No, keep looking           PF0420\n*        Did not find name, don't update ESD offset              PF0420\n         J     GET_CLASS_EXIT                                    PF0420\nGET_CLASS_DONE DS 0H                                             PF0420\n         MVC   ESD_ELEM_OFFSET,CLASS_BNL_SEGM_OFF                PF0420\nGET_CLASS_EXIT DS 0H                                             PF0420\n         LM    R8,R10,CLASSSAVE2 Restore working registers       PF0420\n         L     R14,CLASSSAVE  Restore R14                        PF0420\n         BR    R14            return                             PF0420\n         DROP  R4,R5                                             PF0420\n         DROP  R8,R9                                             PF0420\n*------------------------------------------------------------*   PF0708\n* Move PGMNAME to IEW_MBR, calculating length in IEW_MBRL    *   PF0708\n*------------------------------------------------------------*   PF0708\n*                                                                PF0708\nPGMNAME_2_MBR  DS 0H                                             PF0708\n         ST    R14,CNT_R14SAVE    Can re-use this save word here PF0708\n* Calculate length of member name first                          PF0708\n         XC    IEW_MBRL,IEW_MBRL  Clear length to zero           PF0708\n         LA    R15,8              Max length is 8                PF0708\n         LA    R14,PGMNAME_GET+L'PGMNAME_GET-1 Point to name end PF0708\nPGMNAME_2_MBR_1 DS 0H             Loop for length                PF0708\n         CLI   0(R14),C' '        Space or not?                  PF0708\n         JNE   PGMNAME_2_MBR_2    Not space, have length         PF0708\n         BCTR  R14,0              Is a space, decrement address  PF0708\n         BRCT  R15,PGMNAME_2_MBR_1 Then decrement length + loop  PF0708\n         J     PGMNAME_2_MBR_X    Zero length, exit              PF0708\nPGMNAME_2_MBR_2 DS 0H             Have name length now           PF0708\n         STH   R15,IEW_MBRL       Store length                   PF0708\n         MVC   IEW_MBRN,PGMNAME_GET Copy the member name         PF0708\nPGMNAME_2_MBR_X DS 0H             Exit here                      PF0708\n         L     R14,CNT_R14SAVE    Restore                        PF0708\n         BR    R14                And return                     PF0708\n*------------------------------------------------------------*   PF0708\n* Create PL/I-style internal name from member name IEW_MBR   *   PF0708\n*------------------------------------------------------------*   PF0708\n*                                                                PF0708\nCREATE_PLINAME DS 0H                                             PF0708\n         ST    R14,CNT_R14SAVE    Can re-use this save word here PF0708\n         MVC   PLINAME_LEN,IEW_MBRL+1 Name length                PF0708\n         MVI   PLINAME,C'*'       Pre-fill name with '*' chars   PF0708\n         MVC   PLINAME+1(L'PLINAME-1),PLINAME                    PF0708\n         LHI   R14,L'PLINAME      Compute where to start name    PF0708\n         LH    R15,IEW_MBRL       How much to move               PF0708\n         CHI   R15,L'PLINAME-1    But no more than can fit       PF0420\n         JNH   CREATE_PLINAME_1   OK, not more than can fit      PF0708\n         LHI   R15,L'PLINAME-1    More than can fit, use first   PF0420\nCREATE_PLINAME_1 DS 0H                                           PF0708\n         SR    R14,R15            Finish calculation             PF0708\n         LA    R14,PLINAME(R14)   R14=where to start             PF0708\n         BCTR  R15,0              Length minus one for EXecute   PF0708\n         EX    R15,MOVE_PLINAME   Move to PLINAME                PF0708\n         L     R14,CNT_R14SAVE    Restore                        PF0708\n         BR    R14                And return                     PF0708\n*------------------------------------------------------------*   PF0608\n* Adjust language counts for UNKNOWN load modules            *   PF0608\n*------------------------------------------------------------*   PF0608\n*                                                                PF0608\nADJUST_COUNTS DS 0H                                              PF0608\n         ST    R14,CNT_R14SAVE                                   PF0608\n         CLI   0(R9),C'A'         Assembler?                     PF0608\n         JNE   ADJ_CNT_01_1       No, keep checking              PF0608\n         AP    CNT_ASSEMBLER,=P'1' Yes, add to Assembler count   PF0608\n         J     ADJ_CNT_END        Done                           PF0608\nADJ_CNT_01_1 DS 0H                                               PF0608\n         CLI   0(R9),C'C'         COBOL?                         PF0420\n         JNE   ADJ_CNT_02         No, keep checking              PF0420\n         CLI   1(R9),C'4'         COBOL 4?                       PF0420\n         JNE   ADJ_CNT_01_1A      No, keep checking              PF0420\n         AP    CNT_COBOL4,=P'1'   Yes, add to COBOL 4   count    PF0420\n         J     ADJ_CNT_END        Done                           PF0420\nADJ_CNT_01_1A DS 0H                                              PF0420\n         CLI   1(R9),C'3'         COBOL 1?                       PF0608\n         JNE   ADJ_CNT_01_2       No, keep checking              PF0608\n         AP    CNT_COBOLI,=P'1'   Yes, add to COBOL 1   count    PF0608\n         J     ADJ_CNT_END        Done                           PF0608\nADJ_CNT_01_2 DS 0H                                               PF0608\n         CLI   1(R9),C'2'         COBOL 2?                       PF0608\n         JNE   ADJ_CNT_01_3       No, keep checking              PF0608\n         AP    CNT_COBOL2,=P'1'   Yes, add to COBOL 2   count    PF0608\n         J     ADJ_CNT_END        Done                           PF0608\nADJ_CNT_01_3 DS 0H                                               PF0608\n         CLI   1(R9),C'1'         COBOL LE?                      PF0608\n         JNE   ADJ_CNT_EXIT       No, not recognized, exit       PF0608\n         AP    CNT_COBOLLE,=P'1'  Yes, add to COBOL LE  count    PF0608\n         J     ADJ_CNT_END        Done                           PF0608\nADJ_CNT_02 DS 0H                                                 PF0608\n         CLI   0(R9),C'F'         FORTRAN?                       PF0608\n         JNE   ADJ_CNT_03         No, keep checking              PF0608\n         AP    CNT_FORTRAN,=P'1'  Yes, add to FORTRAN   count    PF0608\n         J     ADJ_CNT_END        Done                           PF0608\nADJ_CNT_03 DS 0H                                                 PF0608\n         CLI   0(R9),C'P'         PL/1?                          PF0608\n         JNE   ADJ_CNT_04         No, keep checking              PF0608\n         AP    CNT_PLI,=P'1'      Yes, add to PL/1      count    PF0608\n         J     ADJ_CNT_END        Done                           PF0608\nADJ_CNT_04 DS 0H                                                 PF0608\n         CLI   0(R9),C'U'         C/C++?                         PF0608\n         JNE   ADJ_CNT_05         No, keep checking              PF0608\n         AP    CNT_C370,=P'1'     Yes, add to C370      count    PF0608\n         J     ADJ_CNT_END        Done                           PF0608\nADJ_CNT_05 DS 0H                                                 PF0608\n*        Not any of the above, adjust OTHER count                PF0608\n         CLI   0(R9),0            Unknown ?                      RS1208\n         JE    ADJ_CNT_EXIT         Yes, leave                   RS1208\n         AP    CNT_OTHER,=P'1'    Yes, add to OTHER     count    PF0608\nADJ_CNT_END DS 0H                                                PF0608\n         SP    CNT_UNKNOWN,=P'1'  Subtract from UNKNOWN count    PF0608\nADJ_CNT_EXIT DS 0H                                               PF0608\n         L     R14,CNT_R14SAVE                                   PF0608\n         BR    R14                                               PF0608\n*------------------------------------------------------------*\n* CEEUOPT_INFO                                               *   RS1107\n*------------------------------------------------------------*\n*\nCEEUOPT_INFO DS 0H\n         ST    R14,BINDSAVE\n         BRAS  R14,BLANK1\n         STRING64 ADDINFO,INTO=RECORD\n         BRAS  R14,SPACE1\n         STRING64 '------------ about the CEEUOPT/#pragma/PLXOPT ----',X\n               '---------------------------------------------------',  X\n               INTO=RECORD\n         BRAS  R14,SPACE2\n         L     R5,CSV_OUTXTLST_ELP1  Start of data to be searched\n         L     R4,CSV_OUTXTLST_EL1   Length of string\n         AR    R4,R5         Points to the end of data\n         LR    R8,R4         keep it for later\n         LA    R0,C'C'       Search for 'C'\nCEEUOPT_05  DS    0H\n         SRST  R4,R5         Search\n         BRC   1,CEEUOPT_05  Search interrupted, continue\n         BRC   2,CEEUOPT_10  String not found\n         LR    R2,R8         End of string\n         SR    R2,R4         minus found at\n         CH    R2,=H'6'      at least 5 bytes ???\n         JL    CEEUOPT_10    no leave\n         CLC   =C'CEEOCB  ',0(R4)  CEEUOPT ?????                 RS0317\n         JE    CEEUOPT_20\n         LR    R5,R4\n         LA    R5,1(,R5)     +1\n         LR    R4,R8\n         J     CEEUOPT_05    Search again\nCEEUOPT_10  DS    0H\n         CLC   CSV_OUTXTLST_ENTRR,=F'1' more then 1 extend ?     RS1107\n         JNH   CEEUOPT_90                 no leave               RS1107\n         L     R5,CSV_OUTXTLST_ELP2  Start of data to be searched\n         L     R4,CSV_OUTXTLST_EL2   Length of string\n         AR    R4,R5         Points to the end of data\n         LR    R8,R4         keep it for later\n         LA    R0,C'C'       Search for 'C'\nCEEUOPT_15  DS    0H\n         SRST  R4,R5         Search\n         BRC   1,CEEUOPT_15  Search interrupted, continue\n         BRC   2,CEEUOPT_90  String not found\n         LR    R2,R8         End of string\n         SR    R2,R4         minus found at\n         CH    R2,=H'6'      at least 5 bytes ???\n         JL    CEEUOPT_90    no leave\n         CLC   =C'CEEOCB  ',0(R4)  CEEUOPT ?????                 RS0317\n         JE    CEEUOPT_20\n         LR    R5,R4\n         LA    R5,1(,R5)     +1\n         LR    R4,R8\n         J     CEEUOPT_15    Search again\nCEEUOPT_20  DS    0H\n         STRING64 'LE User Options present',INTO=RECORD\n         BRAS  R14,SPACE2\n         USING CEEOCB,R4\n         CLC   =C'CEEOCB  ',CEEOCB_EYEC   Eyecatcher             RS0317\n         JNE   CEEUOPT_98\n         CLC   CEEOCB_VER,=H'15'        Version 15 ? z/OS R4\n         JE    CEEUOPT_11\n         CLC   CEEOCB_VER,=H'16'        Version 16 ? z/OS R5\n         JE    CEEUOPT_11\n         CLC   CEEOCB_VER,=H'17'        Version 17 ? z/OS R8\n         JE    CEEUOPT_11\n         CLC   CEEOCB_VER,=H'18'        Version 18 ? z/OS R9\n         JE    CEEUOPT_11\n         J     CEEUOPT_97               version not supported\nCEEUOPT_11 DS   0H\n         LR    R5,R4\n         CLI   OPTION_ABPE_FLAG,X'81'    CEEUOPT specified ?\n         JNE   CEEUOPT_ABPERCX              no leave\n         A     R5,OPTION_ABPE_SUB\n         USING SUBOPT_ABPE,R5\n         STRING64 '      ABPERC(NONE)',INTO=RECORD\n         TM    SUBOPT_ABPE_US,X'80'     None\n         JO    CEEUOPT_ABPERC9\n         STRING64 '      ABPERC(',INTO=RECORD\n         TM    SUBOPT_ABPE_US,X'40'     User abendcode\n         JNO   CEEUOPT_ABPERC1\n         STRING64 (RECORD,,T),'U',(SUBOPT_ABPE_CODE,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         J     CEEUOPT_ABPERC9\nCEEUOPT_ABPERC1 DS 0H\n         TM    SUBOPT_ABPE_US,X'20'     System abendcode\n         JNO   CEEUOPT_ABPERC2\n         STRING64 (RECORD,,T),'S',(SUBOPT_ABPE_CODE,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         J     CEEUOPT_ABPERC9\nCEEUOPT_ABPERC2 DS 0H                   Other Abcode\n         STRING64 (RECORD,,T),SUBOPT_ABPE_ABC,INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\nCEEUOPT_ABPERC9 DS 0H\n         BRASL R14,SPACE1\nCEEUOPT_ABPERCX DS 0H\n         DROP  R5\n         CLI   OPTION_ABTE_FLAG,X'81'    CEEUOPT specified ?\n         JNE   CEEUOPT_ABTERMENCX           no leave\n         LR    R5,R4\n         A     R5,OPTION_ABTE_SUB\n         USING SUBOPT_ABTE,R5\n         STRING64 '      ABTERMENC(RETCODE)',INTO=RECORD\n         CLC   SUBOPT_ABTE_OPT,=F'1'\n         JE    CEEUOPT_ABTERMENC\n         STRING64 '      ABTERMENC(ABEND)',INTO=RECORD\nCEEUOPT_ABTERMENC DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_ABTERMENCX DS 0H\n         DROP  R5\n         CLI   OPTION_AIXB_FLAG,X'81'    CEEUOPT specified ?\n         JNE   CEEUOPT_AIXBX                no leave\n         STRING64 '      AIXBLD',INTO=RECORD\n         TM    OPTION_AIXB_FLAG,X'80'\n         JO    CEEUOPT_AIXBLD\n         STRING64 '    NOAIXBLD',INTO=RECORD\nCEEUOPT_AIXBLD DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_AIXBX  DS 0H\n         CLI   OPTION_ALL3_FLAG,X'81'    CEEUOPT specified ?\n         JNH   CEEUOPT_ALL3X                no leave\n         STRING64 '      ALL31(ON)',INTO=RECORD\n         TM    OPTION_ALL3_FLAG,X'80'\n         JO    CEEUOPT_ALL31\n         STRING64 '      ALL31(OFF)',INTO=RECORD\nCEEUOPT_ALL31  DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_ALL3X  DS 0H\n         CLI   OPTION_ANYH_FLAG,X'81'    CEEUOPT specified ?\n         JNE   CEEUOPT_ANYHX                no leave\n         LR    R5,R4\n         A     R5,OPTION_ANYH_SUB\n         USING SUBOPT_ANYH,R5\n         STRING64 '      ANYHEAP(',INTO=RECORD\n         STRING64 (RECORD,,T),(SUBOPT_ANYH_INIT,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_ANYH_INC,F,L9B),INTO=RECORD\n         TM    SUBOPT_ANYH_ALLOC,X'80'  Below\n         JO    CEEUOPT_ANYHEAP1\n         STRING64 (RECORD,,T),',ANYWHERE',INTO=RECORD\n         J     CEEUOPT_ANYHEAP2\nCEEUOPT_ANYHEAP1       DS  0H\n         STRING64 (RECORD,,T),',BELOW',INTO=RECORD\nCEEUOPT_ANYHEAP2       DS  0H\n         TM    SUBOPT_ANYH_ALLOC,X'40'  Free\n         JO    CEEUOPT_ANYHEAP3\n         STRING64 (RECORD,,T),',KEEP)',INTO=RECORD\n         J     CEEUOPT_ANYHEAP4\nCEEUOPT_ANYHEAP3       DS  0H\n         STRING64 (RECORD,,T),',FREE)',INTO=RECORD\nCEEUOPT_ANYHEAP4       DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_ANYHX  DS 0H\n         DROP  R5\n         CLI   OPTION_AUTO_FLAG,X'81'    CEEUOPT specified ?\n         JNE   CEEUOPT_AUTOX                no leave\n         LR    R5,R4\n         A     R5,OPTION_AUTO_SUB\n         USING SUBOPT_AUTO,R5\n         STRING64 '      AUTOTASK(',SUBOPT_AUTO_LMOD,',',              X\n               (SUBOPT_AUTO_NO,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         TM    OPTION_AUTO_FLAG,X'80'\n         JO    CEEUOPT_AUTOTASK\n         STRING64 '    NOAUTOTASK',INTO=RECORD\nCEEUOPT_AUTOTASK DS 0H\n         BRASL R14,SPACE1\nCEEUOPT_AUTOX  DS 0H\n         CLI   OPTION_BELH_FLAG,X'81'    CEEUOPT specified ?\n         JNE   CEEUOPT_BELHX                no leave\n         LR    R5,R4\n         A     R5,OPTION_BELH_SUB\n         USING SUBOPT_BELH,R5\n         STRING64 '      BELOWHEAP(',INTO=RECORD\n         STRING64 (RECORD,,T),(SUBOPT_BELH_INIT,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_BELH_INC,F,L9B),INTO=RECORD\n         TM    SUBOPT_BELH_ALLOC,X'40'  Free?\n         JO    CEEUOPT_BELOWHEAP1\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         J     CEEUOPT_BELOWHEAP\nCEEUOPT_BELOWHEAP1  DS  0H\n         STRING64 (RECORD,,T),',FREE)',INTO=RECORD\nCEEUOPT_BELOWHEAP   DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_BELHX  DS 0H\n         CLI   OPTION_CBLO_FLAG,X'81'    CEEUOPT specified ?\n         JNE   CEEUOPT_CBLOX                no leave\n         DROP  R5\n         STRING64 '      CBLOPTS(ON)',INTO=RECORD\n         TM    OPTION_CBLO_FLAG,X'80'\n         JO    CEEUOPT_CBLOPTS\n         STRING64 '      CBLOPTS(OFF)',INTO=RECORD\nCEEUOPT_CBLOPTS DS 0H\n         BRASL R14,SPACE1\nCEEUOPT_CBLOX  DS 0H\n         CLI   OPTION_CBLP_FLAG,X'81'    CEEUOPT specified ?\n         JNE   CEEUOPT_CBLPX                no leave\n         STRING64 '      CBLPSHPOP(ON)',INTO=RECORD\n         TM    OPTION_CBLP_FLAG,X'80'\n         JO    CEEUOPT_CBLPSHPOP\n         STRING64 '      CBLPSHPOP(OFF)',INTO=RECORD\nCEEUOPT_CBLPSHPOP DS 0H\n         BRASL R14,SPACE1\nCEEUOPT_CBLPX  DS  0H\n         CLI   OPTION_CBLQ_FLAG,X'81'    CEEUOPT specified ?\n         JNE   CEEUOPT_CBLQX                no leave\n         STRING64 '      CBLQDA(ON)',INTO=RECORD\n         TM    OPTION_CBLQ_FLAG,X'80'\n         JO    CEEUOPT_CBLQDA\n         STRING64 '      CBLQDA(OFF)',INTO=RECORD\nCEEUOPT_CBLQDA   DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_CBLQX  DS 0H\n         CLC   CEEOCB_VER,=H'18'        Version 18 ? z/OS R9\n         JL    CEEUOPT_CEEDMPX\n         CLI   OPTION_CEEDMP_FLAG,X'81'    CEEUOPT specified ?\n         JNE   CEEUOPT_CEEDMPX              no leave\n         LR    R5,R4\n         A     R5,OPTION_CEEDMP_SUB\n         USING SUBOPT_CEEDMP,R5\n         STRING64 '      CEEDUMP(',(SUBOPT_CEEDMP_PAGL,F,L3B),         X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',SYSOUT=(',SUBOPT_CEEDMP_SYSC,          X\n               ',',SUBOPT_CEEDMP_SYSO,'),',INTO=RECORD\n         TM    SUBOPT_CEEDMP_FREE,X'00'  Free=end of close\n         JNZ   CEEUOPT_CEEDMP2\n         STRING64 (RECORD,,T),'FREE=END,',INTO=RECORD\n         J     CEEUOPT_CEEDMP3\nCEEUOPT_CEEDMP2     DS  0H\n         STRING64 (RECORD,,T),'FREE=CLOSE',INTO=RECORD\nCEEUOPT_CEEDMP3     DS  0H\n         TM    SUBOPT_CEEDMP_SPIN,X'00'  SPIN=Unalloc or NO\n         JNZ   CEEUOPT_CEEDMP4\n         STRING64 (RECORD,,T),'SPIN=UNALLOC)',INTO=RECORD\n         J     CEEUOPT_CEEDMP5\nCEEUOPT_CEEDMP4     DS  0H\n         STRING64 (RECORD,,T),'SPIN=NO)',INTO=RECORD\nCEEUOPT_CEEDMP5     DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_CEEDMPX DS 0H\n         CLI   OPTION_CHEC_FLAG,X'81'    CEEUOPT specified ?\n         JNE   CEEUOPT_CHECX                no leave\n         STRING64 '      CHECK(ON)',INTO=RECORD\n         TM    OPTION_CHEC_FLAG,X'80'\n         JO    CEEUOPT_CHECK\n         STRING64 '      CHECK(OFF)',INTO=RECORD\nCEEUOPT_CHECK  DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_CHECX  DS 0H\n         CLI   OPTION_COUN_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_COUNX                no leave\n         LR    R5,R4\n         A     R5,OPTION_COUN_SUB\n         USING SUBOPT_COUN,R5\n         STRING64 '      COUNTRY(',SUBOPT_COUN_ID,')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_COUNX  DS 0H\n         CLI   OPTION_DEBU_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_DEBUX                no leave\n         STRING64 '      DEBUG',INTO=RECORD\n         TM    OPTION_DEBU_FLAG,X'80'\n         JO    CEEUOPT_DEBUG\n         STRING64 '    NODEBUG',INTO=RECORD\nCEEUOPT_DEBUG    DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_DEBUX  DS 0H\n         DROP  R5\n         CLI   OPTION_DEPT_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_DEPTX                no leave\n         LR    R5,R4\n         A     R5,OPTION_DEPT_SUB\n         USING SUBOPT_DEPT,R5\n         STRING64 '      DEPTHCONDLMT(',(SUBOPT_DEPT_COUNT,F,L9B),     X\n               INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_DEPTX  DS 0H\n         DROP  R5\n         CLC   CEEOCB_VER,=H'17'        Version 17 ? z/OS R8\n         JL    CEEUOPT_NODYNDUMP\n         CLI   OPTION_DYNDMP_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_DYNDMPX              no leave\n         LR    R5,R4\n         A     R5,OPTION_DYNDMP_SUB\n         USING SUBOPT_DYNDMP,R5\n         LR    R8,R4\n         A     R8,SUBOPT_DYNDMP_HLQP\n         USING SUBOPT_DYNDMP_HLQO,R8\n         LH    R0,SUBOPT_DYNDMP_HLQL  length\n         STRING64 '      DYNDUMP(\"',(SUBOPT_DYNDMP_HLQS,(R0)),         X\n               INTO=RECORD\n         TM    SUBOPT_DYNDMP_FLG1,X'80'  Dynamic\n         JZ    CEEUOPT_DYNDMP1\n         STRING64 (RECORD,,T),',DYNAMIC',INTO=RECORD\n         J     CEEUOPT_DYNDMP4\nCEEUOPT_DYNDMP1     DS  0H\n         TM    SUBOPT_DYNDMP_FLG1,X'40'  Nodynamic\n         JZ    CEEUOPT_DYNDMP2\n         STRING64 (RECORD,,T),',NODYNAMIC',INTO=RECORD\n         J     CEEUOPT_DYNDMP4\nCEEUOPT_DYNDMP2     DS  0H\n         TM    SUBOPT_DYNDMP_FLG1,X'20'  Force\n         JZ    CEEUOPT_DYNDMP3\n         STRING64 (RECORD,,T),',FORCE',INTO=RECORD\n         J     CEEUOPT_DYNDMP4\nCEEUOPT_DYNDMP3     DS  0H\n         TM    SUBOPT_DYNDMP_FLG1,X'10'  Both\n         JZ    CEEUOPT_DYNDMP4\n         STRING64 (RECORD,,T),',BOTH',INTO=RECORD\nCEEUOPT_DYNDMP4     DS  0H\n         TM    SUBOPT_DYNDMP_FLG2,X'80'  TDUMP\n         JZ    CEEUOPT_DYNDMP5\n         STRING64 (RECORD,,T),',TDUMP\")',INTO=RECORD\n         BRASL R14,SPACE1\n         J     CEEUOPT_NODYNDUMP\nCEEUOPT_DYNDMP5     DS  0H\n         TM    SUBOPT_DYNDMP_FLG2,X'40'  NOTDUMP\n         JZ    CEEUOPT_NODYNDUMP\n         STRING64 (RECORD,,T),',NOTDUMP\")',INTO=RECORD\n         BRASL R14,SPACE1\n         DROP  R5,R8                                             PF0420\nCEEUOPT_NODYNDUMP DS  0H\nCEEUOPT_DYNDMPX DS 0H\n         CLI   OPTION_ENVA_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_ENVAX                no leave\n         LR    R5,R4\n         A     R5,OPTION_ENVA_SUB\n         USING SUBOPT_ENVA,R5\n         STRING64 '      ENVAR(\"\")',INTO=RECORD\n         CLC   SUBOPT_ENVA_LEN,=H'0'\n         JE    CEEUOPT_ENVAR\n         STRING64 '      ENVAR(\"',(SUBOPT_ENVA_STR,60),'\")',INTO=RECORD\nCEEUOPT_ENVAR    DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_ENVAX  DS 0H\n         DROP  R5\n         CLI   OPTION_ERRC_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_ERRCX                no leave\n         LR    R5,R4\n         A     R5,OPTION_ERRC_SUB\n         USING SUBOPT_ERRC,R5\n         STRING64 '      ERRCOUNT(',(SUBOPT_ERRC_COUNT,F,L9B),         X\n               INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_ERRCX  DS 0H\n         DROP  R5\n         CLI   OPTION_ERRU_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_ERRUX                no leave\n         LR    R5,R4\n         A     R5,OPTION_ERRU_SUB\n         USING SUBOPT_ERRU,R5\n         STRING64 '      ERRUNIT(',(SUBOPT_ERRU_COUNT,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_ERRUX  DS 0H\n         DROP  R5\n         CLI   OPTION_FILE_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_FILEX                no leave\n         STRING64 '      FILEHIST',INTO=RECORD\n         TM    OPTION_FILE_FLAG,X'80'\n         JO    CEEUOPT_FILEHIST\n         STRING64 '    NOFILEHIST',INTO=RECORD\nCEEUOPT_FILEHIST DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_FILEX  DS 0H\n         CLI   OPTION_FILT_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_FILTX                no leave\n         LR    R5,R4\n         A     R5,OPTION_FILT_SUB\n         USING SUBOPT_FILT,R5\n         STRING64 '      FILETAG(AUTOCVT,',INTO=RECORD\n         TM    SUBOPT_FILT_FLG,X'80'\n         JO    CEEUOPT_FILETAG1\n         STRING64 '      FILETAG(NOAUTOCVT,',INTO=RECORD\nCEEUOPT_FILETAG1 DS  0H\n         TM    SUBOPT_FILT_FLG,X'40'\n         JO    CEEUOPT_FILETAG2\n         STRING64 (RECORD,,T),'NOAUTOTAG)',INTO=RECORD\n         J     CEEUOPT_FILETAG3\nCEEUOPT_FILETAG2 DS  0H\n         STRING64 (RECORD,,T),'AUTOTAG)',INTO=RECORD\nCEEUOPT_FILETAG3 DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_FILTX  DS 0H\n         DROP  R5\n         CLI   OPTION_FLOW_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_FLOWX                no leave\n         STRING64 '      FLOW',INTO=RECORD\n         TM    OPTION_FLOW_FLAG,X'80'\n         JO    CEEUOPT_FLOW\n         STRING64 '    NOFLOW',INTO=RECORD\nCEEUOPT_FLOW     DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_FLOWX  DS 0H\n         CLI   OPTION_HEAP_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_HEAPX                no leave\n         LR    R5,R4\n         A     R5,OPTION_HEAP_SUB\n         USING SUBOPT_HEAP,R5\n         STRING64 '      HEAP(',INTO=RECORD\n         STRING64 (RECORD,,T),(SUBOPT_HEAP_INIT,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEAP_INC,F,L9B),INTO=RECORD\n         TM    SUBOPT_HEAP_ALLOC,X'80'  Below\n         JO    CEEUOPT_HEAP1\n         STRING64 (RECORD,,T),',ANYWHERE',INTO=RECORD\n         J     CEEUOPT_HEAP2\nCEEUOPT_HEAP1       DS  0H\n         STRING64 (RECORD,,T),',BELOW',INTO=RECORD\nCEEUOPT_HEAP2       DS  0H\n         TM    SUBOPT_HEAP_ALLOC,X'40'  Free\n         JO    CEEUOPT_HEAP3\n         STRING64 (RECORD,,T),',KEEP,',INTO=RECORD\n         J     CEEUOPT_HEAP4\nCEEUOPT_HEAP3       DS  0H\n         STRING64 (RECORD,,T),',FREE,',INTO=RECORD\nCEEUOPT_HEAP4       DS  0H\n         STRING64 (RECORD,,T),(SUBOPT_HEAP24_INIT,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEAP24_INC,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_HEAPX  DS 0H\n         DROP  R5\n*        CLI   WKCELL1,C'1'            64bit LE-Option\n*        JNE   CEEUOPT_NOHEAP64          no leave\n         CLI   OPTION_HE64_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_HE64X                no leave\n         LR    R5,R4\n         A     R5,OPTION_HE64_SUB\n         USING SUBOPT_HE64,R5\n         STRING64 '      HEAP64(',INTO=RECORD\n         STRING64 (RECORD,,T),(SUBOPT_HE64_INIT,FD,L16B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HE64_INC,FD,L16B),INTO=RECORD\n         TM    SUBOPT_HE64_ALLOC,X'40'  Free\n         JO    CEEUOPT_HEAP64_1\n         STRING64 (RECORD,,T),',KEEP,',INTO=RECORD\n         J     CEEUOPT_HEAP64_2\nCEEUOPT_HEAP64_1    DS  0H\n         STRING64 (RECORD,,T),',FREE,',INTO=RECORD\nCEEUOPT_HEAP64_2    DS  0H\n         STRING64 (RECORD,,T),(SUBOPT_HE6431_INIT,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HE6431_INC,F,L9B),INTO=RECORD\n         TM    SUBOPT_HE6431_ALLOC,X'40'  Free\n         JO    CEEUOPT_HEAP64_3\n         STRING64 (RECORD,,T),',KEEP,',INTO=RECORD\n         J     CEEUOPT_HEAP64_4\nCEEUOPT_HEAP64_3    DS  0H\n         STRING64 (RECORD,,T),',FREE,',INTO=RECORD\nCEEUOPT_HEAP64_4    DS  0H\n         STRING64 (RECORD,,T),(SUBOPT_HE6424_INIT,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HE6424_INC,F,L9B),INTO=RECORD\n         TM    SUBOPT_HE6424_ALLOC,X'40'  Free\n         JO    CEEUOPT_HEAP64_5\n         STRING64 (RECORD,,T),',KEEP)',INTO=RECORD\n         J     CEEUOPT_HEAP64_6\nCEEUOPT_HEAP64_5    DS  0H\n         STRING64 (RECORD,,T),',FREE)',INTO=RECORD\nCEEUOPT_HEAP64_6    DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_HE64X  DS 0H\n         DROP  R5\nCEEUOPT_NOHEAP64    DS  0H\n         CLI   OPTION_HCHK_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_HCHKX                no leave\n         LR    R5,R4\n         A     R5,OPTION_HCHK_SUB\n         USING SUBOPT_HCHK,R5\n         STRING64 '      HEAPCHK(ON,',INTO=RECORD\n         TM    OPTION_HCHK_FLAG,X'80'\n         JO    CEEUOPT_HEAPCHECK\n         STRING64 '      HEAPCHK(OFF,',INTO=RECORD\nCEEUOPT_HEAPCHECK DS 0H\n         STRING64 (RECORD,,T),(SUBOPT_HCHK_FREQ,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HCHK_INIT,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HCHK_CLVL,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HCHK_PLVL,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_HCHKX  DS 0H\n         DROP  R5\n         CLI   OPTION_HEPP_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_HEPPX                no leave\n         LR    R5,R4\n         A     R5,OPTION_HEPP_SUB\n         USING SUBOPT_HEPP,R5\n         STRING64 '      HEAPPOOLS(ON',INTO=RECORD\n         TM    OPTION_HEPP_FLAG,X'80'\n         JO    CEEUOPT_HEAPPOOLS\n         STRING64 '      HEAPPOOLS(OFF',INTO=RECORD\nCEEUOPT_HEAPPOOLS DS 0H\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP1S,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP1P,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP2S,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP2P,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP3S,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP3P,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP4S,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP4P,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP5S,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP5P,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP6S,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP6P,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP7S,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP7P,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP8S,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP8P,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP9S,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP9P,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP10S,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP10P,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP11S,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP11P,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP12S,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP12P,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_HEPPX  DS 0H\n         DROP  R5\n*        CLI   WKCELL1,C'1'            64bit LE-Option\n*        JNE   CEEUOPT_NOHEAPP64         no leave\n         CLI   OPTION_HEPP64_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_HEPP64X              no leave\n         LR    R5,R4\n         A     R5,OPTION_HEPP64_SUB\n         USING SUBOPT_HEPP64,R5\n         STRING64 '      HEAPPOOLS64(ON,',INTO=RECORD\n         TM    OPTION_HEPP64_FLAG,X'80'\n         JO    CEEUOPT_HEAPP64\n         STRING64 '      HEAPPOOLS64(OFF,',INTO=RECORD\nCEEUOPT_HEAPP64   DS 0H\n         STRING64 (RECORD,,T),(SUBOPT_HEPP64_CP1S,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP1P,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP2S,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP2P,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP3S,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP3P,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP4S,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP4P,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP5S,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP5P,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP6S,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP6P,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP7S,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP7P,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP8S,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP8P,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP9S,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP9P,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP10S,F,L9B),         X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP10P,F,L9B),         X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP11S,F,L9B),         X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP11P,F,L9B),         X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP12S,F,L9B),         X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP12P,F,L9B),         X\n               INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_HEPP64X DS 0H\n         DROP  R5\nCEEUOPT_NOHEAPP64 DS 0H\n         CLI   OPTION_INFO_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_INFOX                no leave\n         LR    R5,R4\n         A     R5,OPTION_INFO_SUB\n         USING SUBOPT_INFO,R5\n         STRING64 '      INFOMSGFILTER(ON,',SUBOPT_INFO_ID1,INTO=RECORD\n         STRING64 (RECORD,,T),',',SUBOPT_INFO_ID2,INTO=RECORD\n         STRING64 (RECORD,,T),',',SUBOPT_INFO_ID3,INTO=RECORD\n         STRING64 (RECORD,,T),',',SUBOPT_INFO_ID4,INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         TM    OPTION_INFO_FLAG,X'80'\n         JO    CEEUOPT_INFOMSGFILTER\n         STRING64 '      INFOMSGFILTER(OFF,',SUBOPT_INFO_ID1,          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',SUBOPT_INFO_ID2,INTO=RECORD\n         STRING64 (RECORD,,T),',',SUBOPT_INFO_ID3,INTO=RECORD\n         STRING64 (RECORD,,T),',',SUBOPT_INFO_ID4,INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\nCEEUOPT_INFOMSGFILTER DS 0H\n         BRASL R14,SPACE1\nCEEUOPT_INFOX  DS 0H\n         DROP  R5\n         CLI   OPTION_INQP_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_INQPX                no leave\n         STRING64 '      INQPCOPN',INTO=RECORD\n         TM    OPTION_INQP_FLAG,X'80'\n         JO    CEEUOPT_INQPCOPN\n         STRING64 '    NOINQPCOPN',INTO=RECORD\nCEEUOPT_INQPCOPN DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_INQPX  DS 0H\n         CLI   OPTION_INTE_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_INTEX                no leave\n         STRING64 '      INTERRUPT(ON)',INTO=RECORD\n         TM    OPTION_INTE_FLAG,X'80'\n         JO    CEEUOPT_INTERRUPT\n         STRING64 '      INTERRUPT(OFF)',INTO=RECORD\nCEEUOPT_INTERRUPT DS 0H\n         BRASL R14,SPACE1\nCEEUOPT_INTEX  DS 0H\n*        CLI   WKCELL1,C'1'            64bit LE-Option\n*        JNE   CEEUOPT_NOIOHEAP64        no leave\n         CLI   OPTION_IOHE64_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_IOHE64X              no leave\n         LR    R5,R4\n         A     R5,OPTION_IOHE64_SUB\n         USING SUBOPT_IOHE64,R5\n         STRING64 '      IOHEAP64(',INTO=RECORD\n         STRING64 (RECORD,,T),(SUBOPT_IOHE64_INIT,FD,L16B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_IOHE64_INC,FD,L16B),         X\n               INTO=RECORD\n         TM    SUBOPT_IOHE64_ALLOC,X'40'  Free\n         JO    CEEUOPT_IOHEAP64_1\n         STRING64 (RECORD,,T),',KEEP,',INTO=RECORD\n         J     CEEUOPT_IOHEAP64_2\nCEEUOPT_IOHEAP64_1    DS  0H\n         STRING64 (RECORD,,T),',FREE,',INTO=RECORD\nCEEUOPT_IOHEAP64_2    DS  0H\n         STRING64 (RECORD,,T),(SUBOPT_IOHE6431_INIT,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_IOHE6431_INC,F,L9B),         X\n               INTO=RECORD\n         TM    SUBOPT_IOHE6431_ALLOC,X'40'  Free\n         JO    CEEUOPT_IOHEAP64_3\n         STRING64 (RECORD,,T),',KEEP,',INTO=RECORD\n         J     CEEUOPT_IOHEAP64_4\nCEEUOPT_IOHEAP64_3    DS  0H\n         STRING64 (RECORD,,T),',FREE,',INTO=RECORD\nCEEUOPT_IOHEAP64_4    DS  0H\n         STRING64 (RECORD,,T),(SUBOPT_IOHE6424_INIT,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_IOHE6424_INC,F,L9B),         X\n               INTO=RECORD\n         TM    SUBOPT_IOHE6424_ALLOC,X'40'  Free\n         JO    CEEUOPT_IOHEAP64_5\n         STRING64 (RECORD,,T),',KEEP)',INTO=RECORD\n         J     CEEUOPT_IOHEAP64_6\nCEEUOPT_IOHEAP64_5    DS  0H\n         STRING64 (RECORD,,T),',FREE)',INTO=RECORD\nCEEUOPT_IOHEAP64_6    DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_IOHE64X DS 0H\n         DROP  R5\nCEEUOPT_NOIOHEAP64    DS  0H\n*        CLI   WKCELL1,C'1'            64bit LE-Option\n*        JNE   CEEUOPT_NOLIBHEAP64       no leave\n         CLI   OPTION_LIHE64_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_LIHE64X              no leave\n         LR    R5,R4\n         A     R5,OPTION_LIHE64_SUB\n         USING SUBOPT_LIHE64,R5\n         STRING64 '      LIBHEAP64(',INTO=RECORD\n         STRING64 (RECORD,,T),(SUBOPT_LIHE64_INIT,FD,L16B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_LIHE64_INC,FD,L16B),         X\n               INTO=RECORD\n         TM    SUBOPT_LIHE64_ALLOC,X'40'  Free\n         JO    CEEUOPT_LIBHEAP64_1\n         STRING64 (RECORD,,T),',KEEP,',INTO=RECORD\n         J     CEEUOPT_LIBHEAP64_2\nCEEUOPT_LIBHEAP64_1    DS  0H\n         STRING64 (RECORD,,T),',FREE,',INTO=RECORD\nCEEUOPT_LIBHEAP64_2    DS  0H\n         STRING64 (RECORD,,T),(SUBOPT_LIHE6431_INIT,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_LIHE6431_INC,F,L9B),         X\n               INTO=RECORD\n         TM    SUBOPT_LIHE6431_ALLOC,X'40'  Free\n         JO    CEEUOPT_LIBHEAP64_3\n         STRING64 (RECORD,,T),',KEEP,',INTO=RECORD\n         J     CEEUOPT_LIBHEAP64_4\nCEEUOPT_LIBHEAP64_3    DS  0H\n         STRING64 (RECORD,,T),',FREE,',INTO=RECORD\nCEEUOPT_LIBHEAP64_4    DS  0H\n         STRING64 (RECORD,,T),(SUBOPT_LIHE6424_INIT,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_LIHE6424_INC,F,L9B),         X\n               INTO=RECORD\n         TM    SUBOPT_LIHE6424_ALLOC,X'40'  Free\n         JO    CEEUOPT_LIBHEAP64_5\n         STRING64 (RECORD,,T),',KEEP)',INTO=RECORD\n         J     CEEUOPT_LIBHEAP64_6\nCEEUOPT_LIBHEAP64_5    DS  0H\n         STRING64 (RECORD,,T),',FREE)',INTO=RECORD\nCEEUOPT_LIBHEAP64_6    DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_LIHE64X DS 0H\n         DROP  R5\nCEEUOPT_NOLIBHEAP64    DS  0H\n         CLI   OPTION_LIBS_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_LIBSX                no leave\n         LR    R5,R4\n         A     R5,OPTION_LIBS_SUB\n         USING SUBOPT_LIBS,R5\n         STRING64 '      LIBSTACK(',(SUBOPT_LIBS_INIT,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_LIBS_INC,F,L9B),INTO=RECORD\n         TM    SUBOPT_LIBS_ALLOC,X'40'  Free?\n         JO    CEEUOPT_LIBSTACK1\n         STRING64 (RECORD,,T),',KEEP)',INTO=RECORD\n         J     CEEUOPT_LIBSTACK2\nCEEUOPT_LIBSTACK1   DS  0H\n         STRING64 (RECORD,,T),',FREE)',INTO=RECORD\nCEEUOPT_LIBSTACK2   DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_LIBSX  DS 0H\n         DROP  R5\n         CLI   OPTION_MSGF_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_MSGFX                no leave\n         LR    R5,R4\n         A     R5,OPTION_MSGF_SUB\n         USING SUBOPT_MSGF,R5\n         STRING64 '      MSGFILE(',SUBOPT_MSGF_DD,INTO=RECORD\n         STRING64 (RECORD,,T),',',SUBOPT_MSGF_RFM,INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_MSGF_RECL,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_MSGF_BLKS,F,L9B),INTO=RECORD\n         CLC   SUBOPT_MSGF_ENQ,BLANKS\n         JE    CEEUOPT_MSGFILE1\n         STRING64 (RECORD,,T),',ENQ)',INTO=RECORD\n         J     CEEUOPT_MSGFILE2\nCEEUOPT_MSGFILE1 DS  0H\n         STRING64 (RECORD,,T),',NOENQ)',INTO=RECORD\nCEEUOPT_MSGFILE2 DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_MSGFX  DS 0H\n         DROP  R5\n         CLI   OPTION_MSGQ_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_MSGQX                no leave\n         LR    R5,R4\n         A     R5,OPTION_MSGQ_SUB\n         USING SUBOPT_MSGQ,R5\n         STRING64 '      MSGQ(',(SUBOPT_MSGQ_COUNT,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_MSGQX  DS 0H\n         DROP  R5\n         CLI   OPTION_NATL_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_NATLX                no leave\n         LR    R5,R4\n         A     R5,OPTION_NATL_SUB\n         USING SUBOPT_NATL,R5\n         STRING64 '      NATLANG(',SUBOPT_NATL_ID,')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_NATLX  DS 0H\n         DROP  R5\n         CLI   OPTION_OCST_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_OCSTX                no leave\n         STRING64 '      OCSTATUS',INTO=RECORD\n         TM    OPTION_OCST_FLAG,X'80'\n         JO    CEEUOPT_OCSTATUS\n         STRING64 '    NOOCSTATUS',INTO=RECORD\nCEEUOPT_OCSTATUS DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_OCSTX  DS 0H\n         CLI   OPTION_PC_FLAG,X'81'         CEEUOPT specified ?\n         JNE   CEEUOPT_PCX                  no leave\n         STRING64 '      PC',INTO=RECORD\n         TM    OPTION_PC_FLAG,X'80'\n         JO    CEEUOPT_PC\n         STRING64 '    NOPC',INTO=RECORD\nCEEUOPT_PC       DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_PCX    DS 0H\n         CLI   OPTION_PLIT_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_PLITX                no leave\n         LR    R5,R4\n         A     R5,OPTION_PLIT_SUB\n         USING SUBOPT_PLIT,R5\n         STRING64 '      PLITASKCOUNT(',(SUBOPT_PLIT_COUNT,F,L9B),     X\n               INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_PLITX  DS 0H\n         CLI   OPTION_POSI_FLAG,X'81'       CEEUOPT specified ?\n         JNH   CEEUOPT_POSIX                no leave\n         DROP  R5\n         STRING64 '      POSIX(ON)',INTO=RECORD\n         TM    OPTION_POSI_FLAG,X'80'\n         JO    CEEUOPT_POSIX1\n         STRING64 '      POSIX(OFF)',INTO=RECORD\nCEEUOPT_POSIX1   DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_POSIX  DS 0H\n         CLI   OPTION_PROF_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_PROFX                no leave\n         LR    R5,R4\n         A     R5,OPTION_PROF_SUB\n         USING SUBOPT_PROF,R5\n         STRING64 '      PROFILE(ON',INTO=RECORD\n         TM    OPTION_PROF_FLAG,X'80'\n         JO    CEEUOPT_PROFILE\n         STRING64 '      PROFILE(OFF',INTO=RECORD\nCEEUOPT_PROFILE  DS  0H\n         CLC   SUBOPT_PROF_STRL,=H'0'\n         JE    CEEUOPT_PROFILE1\n         STRING64 (RECORD,,T),',\"',(SUBOPT_PROF_STR,60),'\")',          X\n               INTO=RECORD\n         J     CEEUOPT_PROFILE9\nCEEUOPT_PROFILE1 DS  0H\n         STRING64 (RECORD,,T),',\"\")',INTO=RECORD\nCEEUOPT_PROFILE9 DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_PROFX  DS 0H\n         DROP  R5\n         CLI   OPTION_PRTU_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_PRTUX                no leave\n         LR    R5,R4\n         A     R5,OPTION_PRTU_SUB\n         USING SUBOPT_PRTU,R5\n         STRING64 '      PRTUNIT(',(SUBOPT_PRTU_COUNT,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_PRTUX  DS 0H\n         DROP  R5\n         CLI   OPTION_PUNU_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_PUNUX                no leave\n         LR    R5,R4\n         A     R5,OPTION_PUNU_SUB\n         USING SUBOPT_PUNU,R5\n         STRING64 '      PUNUNIT(',(SUBOPT_PUNU_COUNT,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_PUNUX  DS 0H\n         DROP  R5\n         CLI   OPTION_RDRU_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_RDRUX                no leave\n         LR    R5,R4\n         A     R5,OPTION_RDRU_SUB\n         USING SUBOPT_RDRU,R5\n         STRING64 '      RDRUNIT(',(SUBOPT_RDRU_COUNT,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_RDRUX  DS 0H\n         DROP  R5\n         CLI   OPTION_RECP_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_RECPX                no leave\n         LR    R5,R4\n         A     R5,OPTION_RECP_SUB\n         USING SUBOPT_RECP,R5\n         STRING64 '      RECPAD(OFF)',INTO=RECORD\n         CLC   SUBOPT_RECP_FLG,=F'4'\n         JE    CEEUOPT_RECPAD\n         STRING64 '      RECPAD(ON)',INTO=RECORD\n         CLC   SUBOPT_RECP_FLG,=F'2'\n         JE    CEEUOPT_RECPAD\n         STRING64 '      RECPAD(VAR)',INTO=RECORD\nCEEUOPT_RECPAD   DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_RECPX  DS 0H\n         DROP  R5\n         CLI   OPTION_RPTO_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_RPTOX                no leave\n         STRING64 '      RPTOPTS(ON)',INTO=RECORD\n         TM    OPTION_RPTO_FLAG,X'80'\n         JO    CEEUOPT_RPTOPTS\n         STRING64 '      RPTOPTS(OFF)',INTO=RECORD\nCEEUOPT_RPTOPTS  DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_RPTOX  DS 0H\n         CLI   OPTION_RPTS_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_RPTSX                no leave\n         STRING64 '      RPTSTG(ON)',INTO=RECORD\n         TM    OPTION_RPTS_FLAG,X'80'\n         JO    CEEUOPT_RPTSTG\n         STRING64 '      RPTSTG(OFF)',INTO=RECORD\nCEEUOPT_RPTSTG   DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_RPTSX  DS 0H\n         CLI   OPTION_RTER_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_RTERX                no leave\n         STRING64 '      RTEREUS',INTO=RECORD\n         TM    OPTION_RTER_FLAG,X'80'\n         JO    CEEUOPT_RTEREUS\n         STRING64 '    NORTEREUS',INTO=RECORD\nCEEUOPT_RTEREUS  DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_RTERX  DS 0H\n         CLI   OPTION_SIMV_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_SIMVX                no leave\n         STRING64 '      SIMVRD',INTO=RECORD\n         TM    OPTION_SIMV_FLAG,X'80'\n         JO    CEEUOPT_SIMVRD\n         STRING64 '    NOSIMVRD',INTO=RECORD\nCEEUOPT_SIMVRD   DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_SIMVX  DS 0H\n         CLI   OPTION_STAC_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_STACX                no leave\n         LR    R5,R4\n         A     R5,OPTION_STAC_SUB\n         USING SUBOPT_STAC,R5\n         STRING64 '      STACK(',INTO=RECORD\n         STRING64 (RECORD,,T),(SUBOPT_STAC_INIT,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_STAC_INC,F,L9B),INTO=RECORD\n         TM    SUBOPT_STAC_ALLOC,X'80'  Below\n         JO    CEEUOPT_STACK1\n         STRING64 (RECORD,,T),',ANYWHERE',INTO=RECORD\n         J     CEEUOPT_STACK2\nCEEUOPT_STACK1      DS  0H\n         STRING64 (RECORD,,T),',BELOW',INTO=RECORD\nCEEUOPT_STACK2      DS  0H\n         TM    SUBOPT_STAC_ALLOC,X'40'  Free\n         JO    CEEUOPT_STACK3\n         STRING64 (RECORD,,T),',KEEP,',INTO=RECORD\n         J     CEEUOPT_STACK4\nCEEUOPT_STACK3      DS  0H\n         STRING64 (RECORD,,T),',FREE,',INTO=RECORD\nCEEUOPT_STACK4      DS  0H\n         STRING64 (RECORD,,T),(SUBOPT_STAC_DINIT,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_STAC_DINC,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_STACX  DS 0H\n*        CLI   WKCELL1,C'1'            64bit LE-Option\n*        JNE   CEEUOPT_NOSTACK64         no leave\n         CLI   OPTION_STAC64_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_STAC64X              no leave\n         LR    R5,R4\n         A     R5,OPTION_STAC64_SUB\n         USING SUBOPT_STAC64,R5\n         STRING64 '      STACK64(',INTO=RECORD\n         STRING64 (RECORD,,T),(SUBOPT_STAC64_INIT,FD,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),'M,',(SUBOPT_STAC64_INC,FD,L9B),         X\n               INTO=RECORD\n         STRING64 (RECORD,,T),'M,',(SUBOPT_STAC64_MAX,FD,L9B),         X\n               INTO=RECORD\n         STRING64 (RECORD,,T),'M)',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_STAC64X DS 0H\n         DROP  R5\nCEEUOPT_NOSTACK64   DS  0H\n         CLI   OPTION_STOR_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_STORX                no leave\n         LR    R5,R4\n         A     R5,OPTION_STOR_SUB\n         USING SUBOPT_STOR,R5\n         STRING64 '      STORAGE(',INTO=RECORD\n         TM    SUBOPT_STOR_CSF,X'80'\n         JO    CEEUOPT_STORAGE1\n         STRING64 (RECORD,,T),'NONE,',INTO=RECORD\n         JNE   CEEUOPT_STORAGE2\nCEEUOPT_STORAGE1       DS  0H\n         STRING64 (RECORD,,T),(SUBOPT_STOR_AHSC,1,X),',',INTO=RECORD\nCEEUOPT_STORAGE2       DS  0H\n         TM    SUBOPT_STOR_CSF,X'40'\n         JO    CEEUOPT_STORAGE3\n         STRING64 (RECORD,,T),'NONE,',INTO=RECORD\n         JNE   CEEUOPT_STORAGE4\nCEEUOPT_STORAGE3       DS  0H\n         STRING64 (RECORD,,T),(SUBOPT_STOR_FHSC,1,X),',',INTO=RECORD\nCEEUOPT_STORAGE4       DS  0H\n         TM    SUBOPT_STOR_CSF,X'20'\n         JO    CEEUOPT_STORAGE5\n         STRING64 (RECORD,,T),'NONE,',INTO=RECORD\n         JNE   CEEUOPT_STORAGE6\nCEEUOPT_STORAGE5       DS  0H\n         STRING64 (RECORD,,T),(SUBOPT_STOR_ADSC,1,X),',',INTO=RECORD\nCEEUOPT_STORAGE6       DS  0H\n         STRING64 (RECORD,,T),(SUBOPT_STOR_SOSSZ,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_STORX  DS 0H\n         CLI   OPTION_TERM_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_TERMX                no leave\n         LR    R5,R4\n         A     R5,OPTION_TERM_SUB\n         USING SUBOPT_TERM,R5\n         STRING64 '      TERMTHDACT(QUIET,',INTO=RECORD\n         CLC   SUBOPT_TERM_FLG,=F'8'\n         JE    CEEUOPT_TERMTHDACT1\n         STRING64 '      TERMTHDACT(MSG,',INTO=RECORD\n         CLC   SUBOPT_TERM_FLG,=F'4'\n         JE    CEEUOPT_TERMTHDACT1\n         STRING64 '      TERMTHDACT(TRACE,',INTO=RECORD\n         CLC   SUBOPT_TERM_FLG,=F'2'\n         JE    CEEUOPT_TERMTHDACT1\n         STRING64 '      TERMTHDACT(DUMP,',INTO=RECORD\nCEEUOPT_TERMTHDACT1    DS  0H\n         TM    SUBOPT_TERM_CESE,X'80'     CESE\n         JNO   CEEUOPT_TERMTHDACT2\n         STRING64 (RECORD,,T),'CESE',INTO=RECORD\n         J     CEEUOPT_TERMTHDACT3\nCEEUOPT_TERMTHDACT2    DS  0H\n         TM    SUBOPT_TERM_CESE,X'40'     CICSDDS\n         JNO   CEEUOPT_TERMTHDACT3\n         STRING64 (RECORD,,T),'CICSDDS',INTO=RECORD\nCEEUOPT_TERMTHDACT3    DS  0H\n         STRING64 (RECORD,,T),',',(SUBOPT_TERM_STOR,H,L3B),')',        X\n               INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_TERMX  DS 0H\n         DROP  R5\n         CLI   OPTION_TEST_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_TESTX                no leave\n         LR    R5,R4\n         A     R5,OPTION_TEST_SUB\n         USING SUBOPT_TEST,R5\n         STRING64 '      TEST(',INTO=RECORD\n         TM    OPTION_TEST_FLAG,X'80'\n         JO    CEEUOPT_TEST\n         STRING64 '    NOTEST(',INTO=RECORD\nCEEUOPT_TEST     DS  0H\n         CLC   SUBOPT_TEST_OPT,=F'4'\n         JNE   CEEUOPT_TEST1\n         STRING64 (RECORD,,T),'ALL,',INTO=RECORD\n         J     CEEUOPT_TEST3\nCEEUOPT_TEST1    DS  0H\n         CLC   SUBOPT_TEST_OPT,=F'2'\n         JNE   CEEUOPT_TEST3\n         STRING64 (RECORD,,T),'ERROR,',INTO=RECORD\n         BRASL R14,SPACE1\n         J     CEEUOPT_TEST3\nCEEUOPT_TEST2    DS  0H\n         STRING64 (RECORD,,T),'NONE,',INTO=RECORD\nCEEUOPT_TEST3    DS  0H\n         STRING64 (RECORD,,T),SUBOPT_TEST_CF,INTO=RECORD\n         STRING64 (RECORD,,T),',',SUBOPT_TEST_CL,INTO=RECORD\n         STRING64 (RECORD,,T),',',SUBOPT_TEST_PF,INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_TESTX  DS 0H\n         DROP  R5\n         CLI   OPTION_THRH_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_THRHX                no leave\n         LR    R5,R4\n         A     R5,OPTION_THRH_SUB\n         USING SUBOPT_THRH,R5\n         STRING64 '      THREADHEAP(',INTO=RECORD\n         STRING64 (RECORD,,T),(SUBOPT_THRH_INIT,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_THRH_INC,F,L9B),INTO=RECORD\n         TM    SUBOPT_THRH_ALLOC,X'80'  Below\n         JO    CEEUOPT_THREADHEAP1\n         STRING64 (RECORD,,T),',ANYWHERE',INTO=RECORD\n         J     CEEUOPT_THREADHEAP2\nCEEUOPT_THREADHEAP1    DS  0H\n         STRING64 (RECORD,,T),',BELOW',INTO=RECORD\nCEEUOPT_THREADHEAP2    DS  0H\n         TM    SUBOPT_THRH_ALLOC,X'40'  Free\n         JO    CEEUOPT_THREADHEAP3\n         STRING64 (RECORD,,T),',KEEP)',INTO=RECORD\n         J     CEEUOPT_THREADHEAP4\nCEEUOPT_THREADHEAP3    DS  0H\n         STRING64 (RECORD,,T),',FREE)',INTO=RECORD\nCEEUOPT_THREADHEAP4    DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_THRHX  DS 0H\n         CLI   OPTION_THRS_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_THRSX                no leave\n         LR    R5,R4\n         A     R5,OPTION_THRS_SUB\n         USING SUBOPT_THRS,R5\n         STRING64 '      THREADSTACK(',INTO=RECORD\n         STRING64 (RECORD,,T),(SUBOPT_THRS_INIT,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_THRS_INC,F,L9B),INTO=RECORD\n         TM    SUBOPT_THRS_ALLOC,X'80'  Below\n         JO    CEEUOPT_THREADSTACK1\n         STRING64 (RECORD,,T),',ANYWHERE',INTO=RECORD\n         J     CEEUOPT_THREADSTACK2\nCEEUOPT_THREADSTACK1    DS  0H\n         STRING64 (RECORD,,T),',BELOW',INTO=RECORD\nCEEUOPT_THREADSTACK2    DS  0H\n         TM    SUBOPT_THRS_ALLOC,X'40'  Free\n         JO    CEEUOPT_THREADSTACK3\n         STRING64 (RECORD,,T),',KEEP)',INTO=RECORD\n         J     CEEUOPT_THREADSTACK4\nCEEUOPT_THREADSTACK3    DS  0H\n         STRING64 (RECORD,,T),',FREE)',INTO=RECORD\nCEEUOPT_THREADSTACK4    DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_THRSX  DS 0H\n         DROP  R5\n         LR    R5,R4\n*        CLI   WKCELL1,C'1'            64bit LE-Option\n*        JNE   CEEUOPT_NOTHRS64          no leave\n         CLI   OPTION_THRS64_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_THRS64X              no leave\n         LR    R5,R4\n         A     R5,OPTION_THRS64_SUB\n         USING SUBOPT_THRS64,R5\n         STRING64 '      THREADSTACK64(',INTO=RECORD\n         STRING64 (RECORD,,T),(SUBOPT_THRS64_INIT,FD,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),'M,',(SUBOPT_THRS64_INC,FD,L9B),         X\n               INTO=RECORD\n         STRING64 (RECORD,,T),'M,',(SUBOPT_THRS64_MAX,FD,L9B),         X\n               INTO=RECORD\n         STRING64 (RECORD,,T),'M)',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_THRS64X DS 0H\nCEEUOPT_NOTHRS64       DS  0H\n         CLI   OPTION_TRAC_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_TRACX                no leave\n         LR    R5,R4\n         A     R5,OPTION_TRAC_SUB\n         USING SUBOPT_TRAC,R5\n         STRING64 '      TRACE(ON,',INTO=RECORD\n         TM    OPTION_TRAP_FLAG,X'80'\n         JO    CEEUOPT_TRACE\n         STRING64 '      TRACE(OFF,',INTO=RECORD\nCEEUOPT_TRACE          DS  0H\n         STRING64 (RECORD,,T),(SUBOPT_TRAC_SIZE,F,L9B),INTO=RECORD\n         TM    SUBOPT_TRAC_FLG1,X'80'       DUMP\n         JO    CEEUOPT_TRACE1\n         STRING64 (RECORD,,T),',NODUMP,',INTO=RECORD\n         JO    CEEUOPT_TRACE2\nCEEUOPT_TRACE1         DS  0H\n         STRING64 (RECORD,,T),',DUMP,',INTO=RECORD\nCEEUOPT_TRACE2         DS  0H\n         STRING64 (RECORD,,T),'LE=',(SUBOPT_TRAC_GFLG,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_TRACX  DS 0H\n         DROP  R5\n         CLI   OPTION_TRAP_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_TRAPX                no leave\n         LR    R5,R4\n         A     R5,OPTION_TRAP_SUB\n         USING SUBOPT_TRAP,R5\n         STRING64 '      TRAP(ON,',INTO=RECORD\n         TM    OPTION_TRAP_FLAG,X'80'\n         JO    CEEUOPT_TRAP1\n         STRING64 '      TRAP(OFF,',INTO=RECORD\nCEEUOPT_TRAP1          DS  0H\n         TM    SUBOPT_TRAP_FLG,X'80'   SPIE ?\n         JO    CEEUOPT_TRAP2\n         STRING64 (RECORD,,T),'NOSPIE)',INTO=RECORD\n         J     CEEUOPT_TRAP3\nCEEUOPT_TRAP2          DS  0H\n         STRING64 (RECORD,,T),'SPIE)',INTO=RECORD\nCEEUOPT_TRAP3          DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_TRAPX  DS 0H\n         DROP  R5\n         CLI   OPTION_UPSI_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_UPSIX                no leave\n         LR    R5,R4\n         A     R5,OPTION_UPSI_SUB\n         USING SUBOPT_UPSI,R5\n         STRING64 '      UPSI(',SUBOPT_UPSI_SW,')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_UPSIX  DS 0H\n         DROP  R5\n         CLI   OPTION_USRH_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_USRHX                no leave\n         LR    R5,R4\n         A     R5,OPTION_USRH_SUB\n         USING SUBOPT_USRH,R5\n         STRING64 '      USRHDLR(',SUBOPT_USRH_UN1,INTO=RECORD\n         TM    OPTION_USRH_FLAG,X'80'\n         JO    CEEUOPT_USRHDLR\n         STRING64 '    NOUSRHDLR(',SUBOPT_USRH_UN1,INTO=RECORD\nCEEUOPT_USRHDLR        DS  0H\n         STRING64 (RECORD,,T),',',SUBOPT_USRH_UN2,INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_USRHX  DS 0H\n         DROP  R5\n         CLI   OPTION_VCTR_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_VCTRX                no leave\n         STRING64 '      VCTRSAVE(ON)',INTO=RECORD\n         TM    OPTION_VCTR_FLAG,X'80'\n         JO    CEEUOPT_VCTRSAVE\n         STRING64 '      VCTRSAVE(OFF)',INTO=RECORD\nCEEUOPT_VCTRSAVE DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_VCTRX  DS 0H\n         CLI   OPTION_XPLI_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_XPLIX                no leave\n         STRING64 '      XPLINK(ON)',INTO=RECORD\n         TM    OPTION_XPLI_FLAG,X'80'\n         JO    CEEUOPT_XPLINK\n         STRING64 '      XPLINK(OFF)',INTO=RECORD\nCEEUOPT_XPLINK   DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_XPLIX  DS 0H\n         CLI   OPTION_XUFL_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_XUFLX                no leave\n         LR    R5,R4\n         A     R5,OPTION_XUFL_SUB\n         USING SUBOPT_XUFL,R5\n         STRING64 '      XUFLOW(OFF)',INTO=RECORD\n         CLC   OPTION_XUFL_FLAG,=F'4'\n         JE    CEEUOPT_XUFLOW\n         STRING64 '      XUFLOW(ON)',INTO=RECORD\n         CLC   OPTION_XUFL_FLAG,=F'2'\n         JE    CEEUOPT_XUFLOW\n         STRING64 '      XUFLOW(AUTO)',INTO=RECORD\nCEEUOPT_XUFLOW   DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_XUFLX  DS 0H\n         DROP  R5\n         J     CEEUOPT_99              end\nCEEUOPT_90 DS 0H\n         STRING64 'No ','LE User Options present',INTO=RECORD\n         BRAS  R14,SPACE1\n         J     CEEUOPT_99              end\nCEEUOPT_97 DS    0H\n         STRING64 '    CEEOCB Version not valid: ',(8(R4),2,X),        X\n               INTO=RECORD\n         BRASL R14,SPACE1\n         J     CEEUOPT_99              end\nCEEUOPT_98 DS    0H\n         STRING64 '    Eyecatcher CEEOCB not valid: ',(0(R4),8),       X\n               INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_99   DS 0H\n         BRAS  R14,BLANK1\n         L     R14,BINDSAVE         Restore R14\n         BR    R14            return\n         DROP  R4\n*------------------------------------------------------------*\n*    C/370 Program OPLINK Bit on |||||                       *\n*    Offset instead of relative pointer|||                   *\n*------------------------------------------------------------*\nC_370    DS 0H\n         LR    R2,R4\n         A     R2,12(,R4)          PPA1\n         CLI   1(R2),X'CE'         Check PPA1\n         JNE   COBANAL_08            seems invalid PPA1\n         A     R4,4(,R2)           PPA2 pointer\n         LR    R2,R4\n         J     COBANAL_09          check languages\n*------------------------------------------------------------*   RS0305\n*    C/C++ New layout                                        *   RS1107\n*------------------------------------------------------------*   RS0305\nC_370_NEW DS 0H                  C/C++ or PL1?                   RS0305\n         CLC   20(2,R4),=X'CE03'    CEL C/C++?                   RS1007\n         JE    COBANAL_09A                                       RS1007\n         CLC   20(2,R4),=X'CE01'    CEL C/C++?                   RS1007\n         JE    COBANAL_09A                                       RS1007\n         CLC   20(2,R4),=X'CE0A'    CEL PL1?                     RS1007\n         JE    COBANAL_10A                                       RS1007\n         BRAS  R14,SPACE1\n         J     COBANAL_08            seems invalid               RS0305\n*------------------------------------------------------------*\n*    Enterprise COBOL V5+ Program                            *   PF0420\n*------------------------------------------------------------*\nENTCOBOLV5 DS 0H\n*        C_370 and Cobol V5 sharing the same CEE-Eyecatcher\n         CLC   0(4,R4),=XL4'47F0F014' Not Cobol V5               RS0316\n         JNE   C_370      looks like C                           RS0316\n         USING COBOL_370_DSECT,R4                                PF0420\n         MVC   LE_TGT_WS_LENGTH,CEE_STACK_FRAME                  PF0420\n         LR    R2,R4\n         A     R2,CEE_PPA1_OFFSET      PPA1                      PF0420\n         DROP  R4                                                PF0420\n         USING CEE_PPA1_START,R2                                 PF0420\n         MVC   LE_PGM_NAME,BLANKS                                RS0116\n         SR    R15,R15                 CLEAR R15 FOR INSERT      PF0420\n         IC    R15,CEE_OFFSET          INSERT OFFSET TO PGMNAME  PF0420\n         DROP  R2                                                PF0420\n         USING COBOL_370_DSECT,R4                                PF0420\n         CLI   CEE_EYECATCHER,X'01'    FASTLINK?                 PF0420\n         JNE   NOTFASTL                NO, OFFSET TO NAME IS OK  PF0420\n         SLL   R15,1                   FASTLINK USES OFFSET/2    PF0420\n         DROP  R4                                                PF0420\nNOTFASTL DS    0H                      GET LENGTH OF NAME        PF0420\n         AR    R15,R2                  R15=A(H(PGMNAME_LEN))     PF0420\n         LA    R1,2(,R15)              R1 = A(PGMNAME)           PF0420\n         LH    R15,0(,R15)             R15=PGMNAME_LEN           PF0420\n         AHI   R15,-1                  -1                        RS0116\n         EX    R15,MOVE_PGM_NAME       move pgm name             RS0116\n         L     R2,44(,R4)              A(Options)                PF0420\n         USING COBOLV5_DSECT,R2\n         MVI   LE_SWITCH,C'1'\n         MVC   LE_CCSID,CV5_CCSID\n         MVC   LE_DATA_STATEMENTS,CV5_DATA_STATEMENTS\n         MVC   LE_PROC_LINES,CV5_PROC_LINES\n         XC    LE_YEAR_WINDOW,LE_YEAR_WINDOW\n         XC    LE_TGT_NO_FCB,LE_TGT_NO_FCB   No FIB for COB V5   RS0116\n*        ICM   R2,B'1111',CV5_TGT_ADDRESS    Start of data       RS1007\n*        JZ    COBOL_370_15      not present leave               RS1007\n*        USING COBOL_DAB_DSECT,R2  DAB for RENT                  RS1007\n*        CLC   CV5_DAB_EYEC,=CL4'IDBA' Test RENT                 RS1007\n*        JNE   COBOL_370_05      NORENT                          RS1007\n*        MVC   LE_DAB_FIB_OFF+1,CV5_DAB_FIB_OFF                  RS1007\n*        L     R2,CV5_DAB_TGT    TGT                             RS1007\n*        AHI   R2,6              but +6 for some reason          RS1007\n*        ST    R2,LE_TGT_ADDRESS Save for later                  RS1007\n*        USING COBOL_TGT_DSECT,R2  TGT                           RS1007\n*        MVC   LE_TGT_NO_FCB,CV5_TGT_NO_FCBS                     RS1007\n*        MVC   LE_TGT_WS_LENGTH,CV5_TGT_WS_LENGTH                RS1007\n*        MVC   LE_TGT_REG,CV5_TGT_REG                            RS1007\n*        L     R2,LE_DAB_FIB_OFF  FIB offset 3 Bytes             RS1007\n*        A     R2,CV5_PRI_EP_ADDRESS + Entry-Point               RS1007\n*        ST    R2,LE_TGT_FIB_PTR     Save for later              RS1007\n*        J     COBOL_370_15                                      RS1007\n*OBOL_370_05 DS 0H               NORENT                          RS1007\n*        ST    R2,LE_TGT_ADDRESS Save for later                  RS1007\n*        USING COBOL_TGT_DSECT,R2  TGT                           RS1007\n*        MVC   LE_TGT_NO_FCB,CV5_TGT_NO_FCBS                     RS1007\n*        MVC   LE_TGT_WS_LENGTH,CV5_TGT_WS_LENGTH                RS1007\n*        MVC   LE_TGT_REG,CV5_TGT_REG                            RS1007\n*        MVC   LE_TGT_PTR_FCB_CELL,CV5_TGT_PTR_FCB_CELL          RS1007\n*OBOL_370_15 DS 0H\n*        STRING64 'CV5_STATUS_BYTE_01 ',(CV5_STATUS_BYTE_01,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_02 ',(CV5_STATUS_BYTE_02,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_03 ',(CV5_STATUS_BYTE_03,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_04 ',(CV5_STATUS_BYTE_04,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_05 ',(CV5_STATUS_BYTE_05,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_06 ',(CV5_STATUS_BYTE_06,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_07 ',(CV5_STATUS_BYTE_07,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_08 ',(CV5_STATUS_BYTE_08,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_09 ',(CV5_STATUS_BYTE_09,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_10 ',(CV5_STATUS_BYTE_10,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_11 ',(CV5_STATUS_BYTE_11,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_12 ',(CV5_STATUS_BYTE_12,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_13 ',(CV5_STATUS_BYTE_13,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_14 ',(CV5_STATUS_BYTE_14,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_15 ',(CV5_STATUS_BYTE_15,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_16 ',(CV5_STATUS_BYTE_16,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_17 ',(CV5_STATUS_BYTE_17,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_18 ',(CV5_STATUS_BYTE_18,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_19 ',(CV5_STATUS_BYTE_19,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_20 ',(CV5_STATUS_BYTE_20,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_21 ',(CV5_STATUS_BYTE_21,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_22 ',(CV5_STATUS_BYTE_22,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_23 ',(CV5_STATUS_BYTE_23,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_24 ',(CV5_STATUS_BYTE_24,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_25 ',(CV5_STATUS_BYTE_25,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_26 ',(CV5_STATUS_BYTE_26,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_27 ',(CV5_STATUS_BYTE_27,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_28 ',(CV5_STATUS_BYTE_28,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n         MVC   LE_STATUS_BYTE_01,CV5_STATUS_BYTE_01\n         MVC   LE_STATUS_BYTE_02,CV5_STATUS_BYTE_02\n         MVC   LE_STATUS_BYTE_03,CV5_STATUS_BYTE_03\n         MVC   LE_STATUS_BYTE_04,CV5_STATUS_BYTE_04\n         MVC   LE_STATUS_BYTE_05,CV5_STATUS_BYTE_05\n         MVC   LE_STATUS_BYTE_06,CV5_STATUS_BYTE_06\n         MVC   LE_STATUS_BYTE_07,CV5_STATUS_BYTE_07\n         MVC   LE_STATUS_BYTE_08,CV5_STATUS_BYTE_08\n         MVC   LE_STATUS_BYTE_09,CV5_STATUS_BYTE_09\n         MVC   LE_STATUS_BYTE_10,CV5_STATUS_BYTE_10\n         MVC   LE_STATUS_BYTE_11,CV5_STATUS_BYTE_11\n         MVC   LE_STATUS_BYTE_12,CV5_STATUS_BYTE_12\n         MVC   LE_STATUS_BYTE_13,CV5_STATUS_BYTE_13\n         MVC   LE_STATUS_BYTE_14,CV5_STATUS_BYTE_14\n         MVC   LE_STATUS_BYTE_15,CV5_STATUS_BYTE_15\n         MVC   LE_STATUS_BYTE_16,CV5_STATUS_BYTE_16\n         MVC   LE_STATUS_BYTE_17,CV5_STATUS_BYTE_17\n         MVC   LE_STATUS_BYTE_18,CV5_STATUS_BYTE_18\n         MVC   LE_STATUS_BYTE_19,CV5_STATUS_BYTE_19\n         MVC   LE_STATUS_BYTE_20,CV5_STATUS_BYTE_20\n         MVC   LE_STATUS_BYTE_21,CV5_STATUS_BYTE_21\n         MVC   LE_STATUS_BYTE_22,CV5_STATUS_BYTE_22\n         MVC   LE_STATUS_BYTE_23,CV5_STATUS_BYTE_23\n         MVC   LE_STATUS_BYTE_24,CV5_STATUS_BYTE_24\n         MVC   LE_STATUS_BYTE_25,CV5_STATUS_BYTE_25\n         MVC   LE_STATUS_BYTE_26,CV5_STATUS_BYTE_26\n         MVC   LE_STATUS_BYTE_27,CV5_STATUS_BYTE_27\n         MVC   LE_STATUS_BYTE_28,CV5_STATUS_BYTE_28\n         MVC   LE_STATUS_BYTE_29,CV5_STATUS_BYTE_29\n         MVC   LE_STATUS_BYTE_30,CV5_STATUS_BYTE_30\n         MVC   LE_STATUS_BYTE_31,CV5_STATUS_BYTE_31\n         MVC   LE_STATUS_BYTE_32,CV5_STATUS_BYTE_32   V6.3       RS0620\n         MVC   LE_STATUS_BYTE_33,CV5_STATUS_BYTE_33   V6.3       RS0620\n         MVC   LE_STATUS_BYTE_34,CV5_STATUS_BYTE_34   V6.3       RS0620\n         MVC   LE_STATUS_BYTE_35,CV5_STATUS_BYTE_35   V6.3       RS0620\n         MVC   LE_ARCHLEVEL,CV5_ARCHLEVEL\n         MVC   LE_OPT_LEVEL,CV5_OPT_LEVEL\n         MVC   LE_BUILD_LEVEL,CV5_BUILD_LEVEL  only for Cobol V6 RS0316\n         LR    R1,R4             Entry Point\n         USING COBOL_370_DSECT,R1                                PF0420\n         A     R1,CEE_PPA1_OFFSET PPA1                           PF0420\n         DROP  R1                                                PF0420\n         USING CEE_PPA1_START,R1                                 PF0420\n         LR    R2,R4             Entry Point\n         A     R2,CEE_ADDRESS_OF_PPA2 offset to PPA2 from PPA1   PF0420\n         A     R2,12(,R2)        Timestamp string\n         DROP  R1                                                PF0420\n         USING COBOLV5_COMP_INFO,R2\n         MVC   LE_COMP_DAY,CV5_COMP_DAY\n         MVC   LE_COMP_MONTH,CV5_COMP_MONTH\n         MVC   LE_COMP_YEAR,CV5_COMP_YEAR\n         MVC   LE_COMP_HOURS,CV5_COMP_HOURS\n         MVC   LE_COMP_MIN,CV5_COMP_MIN\n         MVC   LE_COMP_SEC,CV5_COMP_SEC\n         MVC   LE_VERS,CV5_VERS\n         MVC   LE_REL,CV5_REL\n         MVC   LE_MOD,CV5_MOD\n         J     LE370_INFO\n*------------------------------------------------------------*\n*    COBOL/370 Program                                       *\n*------------------------------------------------------------*\nCOBOL_370 DS 0H\n         USING COBOL_370_DSECT,R4\n         LR    R2,R4\n         A     R2,12(,R4)          PPA1\n         CLI   1(R2),X'CE'         Check PPA1\n         JE    COBOL_370_01          yes                         PF0420\n         CLC   0(4,R2),=XL4'47F0F028' NO, OLD FORMAT V3.4?       PF0420\n         JNE   COBANAL_08             NO, UNKNOWN COBOL          PF0420\nCOBOL_370_01 DS 0H                                               PF0420\n         ICM   R2,B'1111',4(R2)    PPA2 pointer\n         JZ    COBANAL_08            seems invalid PPA2\n***      SEE LE VENDOR INTERFACES MANUAL FOR LIST OF PPA2 ID'S,  PF0420\n***      Figure 15. Language Environment-enabled language member PF0420\n***      identifiers in Chapter 1, Common interfaces and         PF0420\n***      conventions                                             PF0420\n         CLI   0(R2),X'05'         ID = Cobol!! (05)=COBOL/370   PF0420\n         JE    COBOL_370_03          yes                         PF0420\n         CLI   0(R2),X'04'         ID = Cobol!! (04)=ENTCOBOL V5+PF0420\n         JE    ENTCOBOLV5            yes                         PF0420\n         JNE   COBANAL_09            no, error                   PF0420\nCOBOL_370_03 DS 0H                                               PF0420\n         MVI   LE_SWITCH,C'1'\n         L     R4,CEE_PRI_EP_ADDRESS\n         MVC   LE_VERS,CEE_VERS\n         MVC   LE_REL,CEE_REL\n         MVC   LE_MOD,CEE_MOD\n         MVC   LE_CCSID,CEE_CCSID\n         MVC   LE_PGM_NAME,CEE_PGM_NAME\n         MVC   LE_COMP_DAY,CEE_COMP_DAY\n         MVC   LE_COMP_MONTH,CEE_COMP_MONTH\n         MVC   LE_COMP_YEAR,CEE_COMP_YEAR\n         MVC   LE_COMP_HOURS,CEE_COMP_HOURS\n         MVC   LE_COMP_MIN,CEE_COMP_MIN\n         MVC   LE_COMP_SEC,CEE_COMP_SEC\n         MVC   LE_DATA_STATEMENTS,CEE_DATA_STATEMENTS\n         MVC   LE_PROC_LINES,CEE_PROC_LINES\n         MVC   LE_YEAR_WINDOW,CEE_YEAR_WINDOW\n         ICM   R2,B'1111',CEE_TGT_ADDRESS    Start of data       RS1007\n         JZ    COBOL_370_15      not present leave               RS1007\n         USING COBOL_DAB_DSECT,R2  DAB for RENT                  RS1007\n         CLC   CEE_DAB_EYEC,=CL4'IDBA' Test RENT                 RS1007\n         JNE   COBOL_370_05      NORENT                          RS1007\n         MVC   LE_DAB_FIB_OFF+1,CEE_DAB_FIB_OFF                  RS1007\n         L     R2,CEE_DAB_TGT    TGT                             RS1007\n         AHI   R2,6              but +6 for some reason          RS1007\n         ST    R2,LE_TGT_ADDRESS Save for later                  RS1007\n         USING COBOL_TGT_DSECT,R2  TGT                           RS1007\n         MVC   LE_TGT_NO_FCB,CEE_TGT_NO_FCBS                     RS1007\n         MVC   LE_TGT_WS_LENGTH,CEE_TGT_WS_LENGTH                RS1007\n         MVC   LE_TGT_REG,CEE_TGT_REG                            RS1007\n         L     R2,LE_DAB_FIB_OFF  FIB offset 3 Bytes             RS1007\n         A     R2,CEE_PRI_EP_ADDRESS + Entry-Point               RS1007\n         ST    R2,LE_TGT_FIB_PTR     Save for later              RS1007\n         J     COBOL_370_15                                      RS1007\nCOBOL_370_05 DS 0H               NORENT                          RS1007\n         ST    R2,LE_TGT_ADDRESS Save for later                  RS1007\n         USING COBOL_TGT_DSECT,R2  TGT                           RS1007\n         MVC   LE_TGT_NO_FCB,CEE_TGT_NO_FCBS                     RS1007\n         MVC   LE_TGT_WS_LENGTH,CEE_TGT_WS_LENGTH                RS1007\n         MVC   LE_TGT_REG,CEE_TGT_REG                            RS1007\n         MVC   LE_TGT_PTR_FCB_CELL,CEE_TGT_PTR_FCB_CELL          RS1007\nCOBOL_370_15 DS 0H\n         DROP  R2\n*        STRING64 'CEE_STATUS_BYTE_01 ',(CEE_STATUS_BYTE_01,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_02 ',(CEE_STATUS_BYTE_02,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_03 ',(CEE_STATUS_BYTE_03,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_04 ',(CEE_STATUS_BYTE_04,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_05 ',(CEE_STATUS_BYTE_05,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_06 ',(CEE_STATUS_BYTE_06,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_07 ',(CEE_STATUS_BYTE_07,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_08 ',(CEE_STATUS_BYTE_08,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_09 ',(CEE_STATUS_BYTE_09,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_10 ',(CEE_STATUS_BYTE_10,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_11 ',(CEE_STATUS_BYTE_11,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_12 ',(CEE_STATUS_BYTE_12,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_13 ',(CEE_STATUS_BYTE_13,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_14 ',(CEE_STATUS_BYTE_14,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_15 ',(CEE_STATUS_BYTE_15,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_16 ',(CEE_STATUS_BYTE_16,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_17 ',(CEE_STATUS_BYTE_17,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_18 ',(CEE_STATUS_BYTE_18,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_19 ',(CEE_STATUS_BYTE_19,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_20 ',(CEE_STATUS_BYTE_20,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_21 ',(CEE_STATUS_BYTE_21,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_22 ',(CEE_STATUS_BYTE_22,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_23 ',(CEE_STATUS_BYTE_23,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_24 ',(CEE_STATUS_BYTE_24,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_25 ',(CEE_STATUS_BYTE_25,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_26 ',(CEE_STATUS_BYTE_26,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_27 ',(CEE_STATUS_BYTE_27,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_28 ',(CEE_STATUS_BYTE_28,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n         MVC   LE_STATUS_BYTE_01,CEE_STATUS_BYTE_01\n         MVC   LE_STATUS_BYTE_02,CEE_STATUS_BYTE_02\n         MVC   LE_STATUS_BYTE_03,CEE_STATUS_BYTE_03\n         MVC   LE_STATUS_BYTE_04,CEE_STATUS_BYTE_04\n         MVC   LE_STATUS_BYTE_05,CEE_STATUS_BYTE_05\n         MVC   LE_STATUS_BYTE_06,CEE_STATUS_BYTE_06\n         MVC   LE_STATUS_BYTE_07,CEE_STATUS_BYTE_07\n         MVC   LE_STATUS_BYTE_08,CEE_STATUS_BYTE_08\n         MVC   LE_STATUS_BYTE_09,CEE_STATUS_BYTE_09\n         MVC   LE_STATUS_BYTE_10,CEE_STATUS_BYTE_10\n         MVC   LE_STATUS_BYTE_11,CEE_STATUS_BYTE_11\n         MVC   LE_STATUS_BYTE_12,CEE_STATUS_BYTE_12\n         MVC   LE_STATUS_BYTE_13,CEE_STATUS_BYTE_13\n         MVC   LE_STATUS_BYTE_14,CEE_STATUS_BYTE_14\n         MVC   LE_STATUS_BYTE_15,CEE_STATUS_BYTE_15\n         MVC   LE_STATUS_BYTE_16,CEE_STATUS_BYTE_16\n         MVC   LE_STATUS_BYTE_17,CEE_STATUS_BYTE_17\n         MVC   LE_STATUS_BYTE_18,CEE_STATUS_BYTE_18\n         MVC   LE_STATUS_BYTE_19,CEE_STATUS_BYTE_19\n         MVC   LE_STATUS_BYTE_20,CEE_STATUS_BYTE_20\n         MVC   LE_STATUS_BYTE_21,CEE_STATUS_BYTE_21\n         MVC   LE_STATUS_BYTE_22,CEE_STATUS_BYTE_22\n         MVC   LE_STATUS_BYTE_23,CEE_STATUS_BYTE_23\n         MVC   LE_STATUS_BYTE_24,CEE_STATUS_BYTE_24\n         MVC   LE_STATUS_BYTE_25,CEE_STATUS_BYTE_25\n         MVC   LE_STATUS_BYTE_26,CEE_STATUS_BYTE_26\n         MVC   LE_STATUS_BYTE_27,CEE_STATUS_BYTE_27\n         MVC   LE_STATUS_BYTE_28,CEE_STATUS_BYTE_28\n         MVC   LE_STATUS_BYTE_29,CEE_STATUS_BYTE_29\n         J     LE370_INFO\n*------------------------------------------------------------*\n*    COBOL/2 Program                                         *\n*------------------------------------------------------------*\nCOBOL_2 DS 0H\n         USING COBOL_2_DSECT,R4\n         MVI   LE_SWITCH,C'2'\n         L     R4,C2_GET_ENTRY\n         L     R4,0(R4)\n         L     R2,92(R4)          VS/COBOL II TGT                RS1107\n         LTR   R2,R2              Check TGT                      RS1107\n         JZ    COBOL_2_15        not present leave               RS1107\n*>---------------------------------------------------------------HP1107\n*        st    r2,c2_tgt                                         HP1107\n*>---------------------------------------------------------------HP1107\n         USING COBOL_DAB_DSECT,R2  DAB for RENT                  RS1107\n         CLC   CEE_DAB_EYEC,=CL4'IDBA' Test RENT                 RS1107\n         JNE   COBOL_2_05        NORENT                          RS1107\n         MVC   LE_DAB_FIB_OFF+1,CEE_DAB_FIB_OFF                  RS1107\n         L     R2,CEE_DAB_TGT    TGT                             RS1107\n         AHI   R2,6              but +6 for some reason          RS1107\n         ST    R2,LE_TGT_ADDRESS Save for later                  RS1107\n         USING COBOL_TGT_DSECT,R2  TGT                           RS1107\n         MVC   LE_TGT_NO_FCB,CEE_TGT_NO_FCBS                     RS1107\n         MVC   LE_TGT_WS_LENGTH,CEE_TGT_WS_LENGTH                RS1107\n         XC    LE_TGT_REG,LE_TGT_REG   clear                     RS1107\n         L     R2,LE_DAB_FIB_OFF  FIB offset 3 Bytes             RS1107\n         A     R2,C2_PRI_EP_ADDRESS + Entry-Point                RS1107\n         ST    R2,LE_TGT_FIB_PTR     Save for later              RS1107\n         J     COBOL_2_15                                        RS1107\nCOBOL_2_05   DS 0H               NORENT                          RS1107\n         ST    R2,LE_TGT_ADDRESS Save for later                  RS1107\n         USING COBOL_TGT_DSECT,R2  TGT                           RS1107\n         MVC   LE_TGT_NO_FCB,CEE_TGT_NO_FCBS                     RS1107\n         MVC   LE_TGT_WS_LENGTH,CEE_TGT_WS_LENGTH                RS1107\n         XC    LE_TGT_REG,LE_TGT_REG   clear                     RS1107\n         MVC   LE_TGT_PTR_FCB_CELL,CEE_TGT_PTR_FCB_CELL          RS1107\nCOBOL_2_15   DS 0H\n         MVC   LE_VERS,C2_VERS\n         MVC   LE_REL,C2_REL\n         MVC   LE_MOD,C2_MOD\n         MVC   LE_PGM_NAME,C2_PGM_NAME\n         MVC   LE_COMP_DAY,C2_COMP_DAY\n         MVC   LE_COMP_MONTH,C2_COMP_MONTH\n*        MVC   LE_COMP_YEAR(2),=C'??'    COBOL2 not Y2K ready    JK1107\n         MVC   LE_COMP_YEAR(2),=C'19'    Assume 19xx             JK1107\n         CLC   C2_COMP_YEAR,=C'66'       Y2K?                    JK1107\n         JNL   COBOL_2_DATE              No                      PF0420\n         MVC   LE_COMP_YEAR(2),=C'20'    Yes                     JK1107\nCOBOL_2_DATE DS 0H                                               JK1107\n         MVC   LE_COMP_YEAR+2(2),C2_COMP_YEAR\n         MVC   LE_COMP_HOURS,C2_COMP_HOURS\n         MVC   LE_COMP_MIN,C2_COMP_MIN\n         MVC   LE_COMP_SEC,C2_COMP_SEC\n         MVC   LE_DATA_STATEMENTS,C2_DATA_STATEMENTS\n         MVC   LE_PROC_LINES,C2_PROC_LINES\n         MVC   LE_STATUS_BYTE_01,C2_STATUS_BYTE_01\n         MVC   LE_STATUS_BYTE_02,C2_STATUS_BYTE_02\n         MVC   LE_STATUS_BYTE_03,C2_STATUS_BYTE_03\n         MVC   LE_STATUS_BYTE_04,C2_STATUS_BYTE_04\n         MVC   LE_STATUS_BYTE_05,C2_STATUS_BYTE_05\n         MVC   LE_STATUS_BYTE_06,C2_STATUS_BYTE_06\n         MVC   LE_STATUS_BYTE_07,C2_STATUS_BYTE_07\n         MVC   LE_STATUS_BYTE_08,C2_STATUS_BYTE_08\n         MVC   LE_STATUS_BYTE_09,C2_STATUS_BYTE_09\n         MVC   LE_STATUS_BYTE_10,C2_STATUS_BYTE_10\n         MVC   LE_STATUS_BYTE_11,C2_STATUS_BYTE_11\n         MVC   LE_STATUS_BYTE_12,C2_STATUS_BYTE_12\n         MVC   LE_STATUS_BYTE_13,C2_STATUS_BYTE_13\n         MVC   LE_STATUS_BYTE_14,C2_STATUS_BYTE_14\n         MVC   LE_STATUS_BYTE_15,C2_STATUS_BYTE_15\n         MVC   LE_STATUS_BYTE_16,C2_STATUS_BYTE_16\n         MVC   LE_STATUS_BYTE_17,C2_STATUS_BYTE_17\n         MVC   LE_STATUS_BYTE_18,C2_STATUS_BYTE_18\n         MVC   LE_STATUS_BYTE_19,C2_STATUS_BYTE_19\n         MVC   LE_STATUS_BYTE_20,C2_STATUS_BYTE_20\n         MVC   LE_STATUS_BYTE_21,C2_STATUS_BYTE_21\n         MVC   LE_STATUS_BYTE_22,C2_STATUS_BYTE_22\n         MVC   LE_STATUS_BYTE_23,C2_STATUS_BYTE_23\n         MVC   LE_STATUS_BYTE_24,C2_STATUS_BYTE_24\n         MVC   LE_STATUS_BYTE_25,C2_STATUS_BYTE_25\n         CLI   CSECT_ANALYZE_KZ,C'M' First csect (main-ep)?      PF0608\n         JNE   LE370_INFO            No,don't set CSCLANG or cnt PF0608\n         AP    CNT_COBOL2,=P'1'          Increment counter        *CSC*\n         MVC   CSCLANG(9),=CL9'COBOL'                             *CSC*\n         J     LE370_INFO\n*------------------------------------------------------------*\n* OS/VS COBOL   Program                                      *\n*------------------------------------------------------------*\nCOBOL_1 DS 0H\n         USING COBOL_1_DSECT,R4\n         MVI   LE_SWITCH,C'3'\n         MVC   LE_VERS,BLANKS\n         MVC   LE_REL,C1_REL\n         MVC   LE_MOD,BLANKS\n         MVC   LE_PGM_NAME,C1_PGM_NAME\n         MVC   LE_COMP_DAY,C1_COMP_DAY\n         MVC   LE_COMP_MONTH,C1_COMP_MONTH\n         MVC   LE_COMP_YEAR,C1_COMP_YEAR\n         MVC   LE_COMP_HOURS,C1_COMP_HOURS\n         MVC   LE_COMP_MIN,C1_COMP_MIN\n         MVC   LE_COMP_SEC,C1_COMP_SEC\n         CLI   csect_analyze_kz,C'M' first csect (main-ep)       RS0108\n         JNE   COBOL_1_05            don't set CSCCOMP           RS0108\n         AP    CNT_COBOLI,=P'1'          Increment counter       PF0608\n         MVC   CSCLANG(9),=CL9'COBOL'                             *CSC*\n         STRING64 'OS/VS/COBOL ',C1_EYECATCHER,C1_REL,INTO=CSCCOMP CSC*\nCOBOL_1_05 DS 0H                                                 RS0108\n         L     R5,C1_TGT_PTR\n         USING COBOL_1_TGT,R5\n         CLC   C1_CHECK,=CL8'SYSOUT'     check\n         JE    LE370_INFO\n*\n*        UNABLE TO FIND THE TASK GLOBAL TABLE  -\n*\nNOTTGT   DS    0H\n         STRING64 'Program ',PGMNAME_GET,' failed the TGT (Task Global'X\n               'Table) test',INTO=RECORD\n         BRAS  R14,SPACE2\n         LA    R15,8\n         J     COBANAL_EXIT\n*------------------------------------------------------------*   PF0420\n* ANS COBOL V4 Program                                       *   PF0420\n*------------------------------------------------------------*   PF0420\nCOBOL_4 DS 0H                                                    PF0420\n         USING COBOL_1_DSECT,R4                                  PF0420\n         MVI   LE_SWITCH,C'4'        Mark as ANS COBOL V4        PF0420\n*        DC    H'0'                  Abend to analyze ANS4 dump  PF0420\n         MVC   LE_VERS,=CL2'??'                                  PF0420\n         MVC   LE_REL,=CL2'??'                                   PF0420\n         MVC   LE_MOD,=CL2'??'                                   PF0420\n         MVC   LE_PGM_NAME,C1_PGM_NAME                           PF0420\n         XC    LE_TGT_FIB_PTR,LE_TGT_FIB_PTR No FIB for ANS V4?  PF0420\n*        MVC   LE_COMP_DAY,C1_COMP_DAY                           PF0420\n*        MVC   LE_COMP_MONTH,C1_COMP_MONTH                       PF0420\n*        MVC   LE_COMP_YEAR,C1_COMP_YEAR                         PF0420\n*        MVC   LE_COMP_HOURS,C1_COMP_HOURS                       PF0420\n*        MVC   LE_COMP_MIN,C1_COMP_MIN                           PF0420\n*        MVC   LE_COMP_SEC,C1_COMP_SEC                           PF0420\n         CLI   csect_analyze_kz,C'M' first csect (main-ep)       PF0420\n         JNE   COBOL_4_05            don't set CSCCOMP           PF0420\n         AP    CNT_COBOL4,=P'1'          Increment counter       PF0420\n         MVC   CSCLANG(9),=CL9'COBOL V4'                         PF0420\n         STRING64 'ANS COBOL V4',                                PF0420X\n               INTO=CSCCOMP                                      PF0420\nCOBOL_4_05 DS 0H                                                 PF0420\n         L     R5,C1_TGT_PTR                                     PF0420\n         USING COBOL_1_TGT,R5                                    PF0420\n         CLC   C1_CHECK,=CL8'SYSOUT'     check                   PF0420\n         JE    LE370_INFO                                        PF0420\n*                                                                PF0420\n*        UNABLE TO FIND THE TASK GLOBAL TABLE  -                 PF0420\n*                                                                PF0420\nNOTTGT4  DS    0H                                                PF0420\n         STRING64 'Program ',PGMNAME_GET,                        PF0420X\n               ' failed the TGT (Task Global Table) test',       PF0420X\n               INTO=RECORD                                       PF0420\n         BRAS  R14,SPACE2                                        PF0420\n         LA    R15,8                                             PF0420\n         J     COBANAL_EXIT                                      PF0420\nLE370_INFO DS  0H\n*>---------------------------------------------------------------HP1107\n         MVI   PRINT_LEAD_SPACE,C'N' Insert space                HP1107\n         CLI   csect_analyze_kz,C'M' first csect (main-ep)       HP1107\n         je    LE370_INFO_0                                      HP1107\n         STRING64 '------------ This module is an included Member ---',X\n               '---------------------------------------------------',  X\n               INTO=RECORD\n         BRAS  R14,SPACE2\n         mvc   PGMNAME_GET,LE_PGM_NAME                           HP1107\n         MVI   PRINT_LEAD_SPACE,C'Y' Insert space                HP1107\nLE370_INFO_0 DS  0H                                              HP1107\n*>---------------------------------------------------------------HP1107\n         STRING64 '------------ Info --------------------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD\n         BRAS  R14,SPACE2\n         MVC   JUSTDATA_LANG,=CL8'COBOL'                          =CMS=\n         MVC   JUSTDATA_PGM,LE_PGM_NAME                           =CMS=\n         MVC   JUSTDATA_VV,LE_VERS                                =CMS=\n         MVC   JUSTDATA_RR,LE_REL                                 =CMS=\n         MVC   JUSTDATA_MM,LE_MOD                                 =CMS=\n         CLI   LE_SWITCH,C'1'\n         JNE   JUMP_AROUND_1\n         STRING64 'Program: ',PGMNAME_GET,' is COBOL/370 Version ',    X\n               LE_VERS,                                                X\n               ' Release ',LE_REL,' Mod-Level ',LE_MOD,INTO=RECORD\n         MVC   JUSTDATA_COMPILER,=C'COBOL370'                     =CMS=\n         CLI   csect_analyze_kz,C'M' first csect (main-ep)       RS1107\n         JNE   LE370_INFO_0V         don't set CSCCOMP           RS1107\n         AP    CNT_COBOLLE,=P'1'         Increment counter       PF0608\n         MVC   CSCLANG(9),=CL9'COBOL'                            PF0608\n         STRING64 'COBOL/370 ',                                   *CSC*X\n               'V',(LE_VERS+1,1),                                 *CSC*X\n               '.',(LE_REL+1,1),                                  *CSC*X\n               '.',(LE_MOD+1,1),                                  *CSC*X\n               INTO=CSCCOMP                                       *CSC*\nLE370_INFO_0V DS  0H                                             RS1107\n         CLC   LE_VERS(4),=C'0301'  Vers+Rel < 0301 COBOL V3R1\n         JL    JUMP_AROUND_2         yes\n         STRING64 'Program: ',PGMNAME_GET,' is COBOL Enterprise',      X\n               ' Version ',LE_VERS,                                    X\n               ' Release ',LE_REL,' Mod-Level ',LE_MOD,INTO=RECORD\n         MVC   JUSTDATA_COMPILER,=C'ECOBOL  '                     =CMS=\n         CLI   csect_analyze_kz,C'M' first csect (main-ep)       RS1107\n         JNE   LE370_INFO_0W         don't set CSCCOMP           RS1107\n         STRING64 'COBOL/ENT ',                                   *CSC*X\n               'V',(LE_VERS+1,1),                                 *CSC*X\n               '.',(LE_REL+1,1),                                  *CSC*X\n               '.',(LE_MOD+1,1),                                  *CSC*X\n               INTO=CSCCOMP                                       *CSC*\nLE370_INFO_0W DS  0H                                             RS1107\n         J     JUMP_AROUND_2\nJUMP_AROUND_1 DS 0H\n         CLI   LE_SWITCH,C'4'        ANS COBOL V4?               PF0420\n         JE    LE370_INFO_4          Yes                         PF0420\n         MVC   JUSTDATA_COMPILER,=C'VSCOBOL2'                     =CMS=\n         CLI   csect_analyze_kz,C'M' first csect (main-ep)       RS1107\n         JNE   LE370_INFO_0X         don't set CSCCOMP           RS1107\n         MVC   CSCLANG(9),=CL9'COBOL'                            PF0608\n         STRING64 'VS/COBOL2 ',                                   *CSC*X\n               'V',(LE_VERS,1),                                   *CSC*X\n               '.',(LE_REL,1),                                    *CSC*X\n               '.',(LE_MOD,1),                                    *CSC*X\n               INTO=CSCCOMP                                       *CSC*\nLE370_INFO_0X DS  0H                                             RS1107\n         STRING64 'Program: ',PGMNAME_GET,' is COBOL/2 Version ',      X\n               LE_VERS,' Release ',LE_REL,' Mod-Level ',LE_MOD,        X\n               INTO=RECORD\n         CLI   LE_SWITCH,C'2'\n         JE    JUMP_AROUND_2\n         CLI   csect_analyze_kz,C'M' first csect (main-ep)       RS1107\n         JNE   LE370_INFO_0Y         don't set CSCCOMP           RS1107\n         STRING64 'OS/VS/COBOL ',C1_EYECATCHER,C1_REL,INTO=CSCCOMP *CSC\nLE370_INFO_0Y DS  0H                                             RS1107\n         STRING64 'Program: ',PGMNAME_GET,' is OS/VS COBOL Release ',  X\n               LE_REL,                                                 X\n               INTO=RECORD\n         MVC   JUSTDATA_COMPILER,=C'OSVSCBL '                     =CMS=\n         J     JUMP_AROUND_2                                     PF0420\nLE370_INFO_4  DS  0H                                             PF0420\n         STRING64 'Program: ',PGMNAME_GET,                       PF0420X\n               ' is ANS COBOL V4',                               PF0420X\n               INTO=RECORD                                       PF0420\nJUMP_AROUND_2 DS 0H\n         CLI   LE_SWITCH,C'4'        ANS COBOL V4?               PF0420\n         JE    LE_370_177            Yes, bypass LE info for now PF0420\n         BRAS  R14,SPACE2\n         STRING64 '------------ Timestamps --------------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD\n         BRAS  R14,SPACE2\n         STRING64 'Compiled program name ',LE_PGM_NAME,INTO=RECORD\n         BRAS  R14,SPACE1\n         BRAS  R9,LE_370_12\nMMM_TBL  DC    CL2'01',CL3'Jan',CL3'JAN'  Long name\n#MMM_TBL EQU   *-MMM_TBL\n         DC    CL2'02',CL3'Feb',CL3'FEB'  for our non-european user\n         DC    CL2'03',CL3'Mar',CL3'MAR'\n         DC    CL2'04',CL3'Apr',CL3'APR'\n         DC    CL2'05',CL3'May',CL3'MAY'\n         DC    CL2'06',CL3'Jun',CL3'JUN'\n         DC    CL2'07',CL3'Jul',CL3'JUL'\n         DC    CL2'08',CL3'Aug',CL3'AUG'\n         DC    CL2'09',CL3'Sep',CL3'SEP'\n         DC    CL2'10',CL3'Oct',CL3'OCT'                          *CSC*\n         DC    CL2'11',CL3'Nov',CL3'NOV'\n         DC    CL2'12',CL3'Dec',CL3'DEC'\n         DC    X'0000',CL3'n/a',CL3'N/A'    end of table\nLE_370_12 DS   0H\n         CLC   LE_COMP_MONTH(2),0(R9)         check properties\n         JE    LE_370_14               jump if on\n         CLC   LE_COMP_MONTH,5(R9)     Matching for OS/VS month   =CMS=\n         JE    LE_370_14               jump if found              =CMS=\n         LA    R9,#MMM_TBL(,R9)        Skip entry\n         CLI   0(R9),0                 end of table?\n         JNE   LE_370_12               not yet, loop\nLE_370_14 DS   0H\n         MVC   JUSTDATA_LE_CYEAR,LE_COMP_YEAR                     =CMS=\n         CLC   JUSTDATA_LE_CYEAR,=C'1950'          OSVS fixup     =CMS=\n         JH    AROUND_A                                           =CMS=\n         MVC   JUSTDATA_LE_CYEAR(2),=C'20'                        =CMS=\nAROUND_A EQU   *                                                  =CMS=\n         MVC   JUSTDATA_LE_CMONTH,0(R9)                           =CMS=\n         MVC   JUSTDATA_LE_CDAY,LE_COMP_DAY                       =CMS=\n         CLI   JUSTDATA_LE_CDAY,C' '               OSVS fixup     =CMS=\n         JNE   AROUND_B                                           =CMS=\n         MVI   JUSTDATA_LE_CDAY,C'0'                              =CMS=\nAROUND_B EQU   *                                                  =CMS=\n         MVC   JUSTDATA_LE_CHOURS,LE_COMP_HOURS                   =CMS=\n         CLI   JUSTDATA_LE_CHOURS,C' '             OSVS fixup     =CMS=\n         JNE   AROUND_C                                           =CMS=\n         MVI   JUSTDATA_LE_CHOURS,C'0'                            =CMS=\nAROUND_C EQU   *                                                  =CMS=\n         MVC   JUSTDATA_LE_CMIN,LE_COMP_MIN                       =CMS=\n         MVC   JUSTDATA_LE_CSEC,LE_COMP_SEC                       =CMS=\n         STRING64 'Date: ',LE_COMP_DAY,'.',(LE_COMP_MONTH,2),'.',      X\n               LE_COMP_YEAR,' (european) ',LE_COMP_DAY,'.',            X\n               (2(R9),3,T),'.',LE_COMP_YEAR,' (long) ',                X\n               ' Time: ',LE_COMP_HOURS,':',LE_COMP_MIN,                X\n               ':',LE_COMP_SEC,INTO=RECORD\n         CLI   CSECT_ANALYZE_KZ,C'M' First csect (main-ep)?      PF0608\n         JNE   LE_370_14A            No,don't set CSCDATE        PF0608\n         STRING64 LE_COMP_DAY,'.',(2(R9),3,T),'.',LE_COMP_YEAR,   *CSC*X\n               INTO=CSCDATE\nLE_370_14A DS   0H                                               PF0608\n         BRAS  R14,JUSTDATA_PUT                                   =CMS=\n         CLI   LE_SWITCH,C'3'    OS/VS COBOL ?\n         JNE   JUMP_AROUND_3       no, go ahead\n         STRING64 'Date: ',LE_COMP_DAY,'.',LE_COMP_MONTH,'.',          X\n               LE_COMP_YEAR,' Time: ',LE_COMP_HOURS,':',LE_COMP_MIN,   X\n               ':',LE_COMP_SEC,INTO=RECORD\n         BRAS  R14,SPACE2\n         ST    R4,SAVER4             Save for re-addressability  PF0708\n         CLI   CSECT_ANALYZE_KZ,C'M' First csect (main-ep)?      PF0708\n         JNE   INFO_COBOL            No,don't set CSCDATE        PF0708\n         STRING64 LE_COMP_DAY,'.',LE_COMP_MONTH,'.',LE_COMP_YEAR, *CSC*X\n               INTO=CSCDATE\n*        ST    R4,SAVER4             Save for re-addressability  PF0708\n*        J     CICS                  Check CICS and then no more| *CSC*\n         DROP  R4\n         J     INFO_COBOL            sorry no more information\nJUMP_AROUND_3 DS 0H\n         BRAS  R14,SPACE2\n         STRING64 '------------ Statistics --------------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD\n         BRAS  R14,SPACE2\n         STRING64 'Number of data items  : ',                          X\n               (LE_DATA_STATEMENTS,F,R7B),INTO=RECORD\n         BRAS  R14,SPACE1\n         STRING64 'Number of instructions: ',(LE_PROC_LINES,F,R7B),    X\n               INTO=RECORD\n         BRAS  R14,SPACE2\n         STRING64 '------------ Options in effect -------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD\n         BRAS  R14,SPACE2\n         MVC   RECORD,BLANKS\n         LA    R15,RECORD\n         MVC   1(3,R15),=C'ADV'\n         TM    LE_STATUS_BYTE_01,BIT0\n         JO    LE_370_15_#1                                       *CSC*\n         MVC   1(5,R15),=C'NOADV'\nLE_370_15_#1 DS 0H                                                *CSC*\n         LA    R15,9(R15)                                        RS1007\n         MVC   0(5,R15),=C'APOST'\n         TM    LE_STATUS_BYTE_01,BIT1\n         JO    LE_370_15_#2                                       *CSC*\n         MVC   0(5,R15),=C'QUOTE'\nLE_370_15_#2 DS 0H                                                *CSC*\n* The COBANAL SUMMARY report is only generated for Mainline      SS0615\n* modules. As DATA \"31\"/\"24\" reporting appears in SUMMARY we     SS0615\n* need to ensure that we only set DATA \"31\" or \"24\" in CSCD31 if SS0615\n* this is a Mainline module and not a subroutine.                SS0615\n         MVC   RECORD+17(9),=CL9'DATA(31)'                       RS1007\n         CLI   CSECT_ANALYZE_KZ,C'M' First csect (main-ep)?      PF0608\n         JNE   LE_370_15_#21         No,don't set CSCD31         SS0615\n         MVC   CSCD31(2),=CL3'31'                                 *CSC*\nLE_370_15_#21 DS 0H                                              SS0615\n         TM    LE_STATUS_BYTE_01,BIT2\n         JO    LE_370_15_#3                                       *CSC*\n         MVC   RECORD+17(9),=CL9'DATA(24)'                       RS1007\n         CLI   CSECT_ANALYZE_KZ,C'M' First csect (main-ep)?      SS0615\n         JNE   LE_370_15_#3          No,don't set CSCD31         SS0615\n         MVC   CSCD31(2),=CL3'24'                                 *CSC*\nLE_370_15_#3 DS 0H                                                *CSC*\n         MVC   RECORD+27(6),=CL6'DECK'                           RS1007\n         TM    LE_STATUS_BYTE_01,BIT3\n         JO    LE_370_15_#4                                       *CSC*\n         MVC   RECORD+27(6),=CL6'NODECK'                         RS1007\nLE_370_15_#4 DS 0H                                                *CSC*\n         MVC   RECORD+36(6),=CL6'DUMP'                           RS1007\n         TM    LE_STATUS_BYTE_01,BIT4\n         JO    LE_370_15_#5                                       *CSC*\n         MVC   RECORD+36(6),=CL6'NODUMP'                         RS1007\nLE_370_15_#5 DS 0H                                                *CSC*\n         MVC   RECORD+44(8),=CL8'DYNAM'                          RS1007\n         TM    LE_STATUS_BYTE_01,BIT5\n         JO    LE_370_15_#6                                       *CSC*\n         MVC   RECORD+44(8),=CL8'NODYNAM'                        RS1007\nLE_370_15_#6 DS 0H                                                *CSC*\n         MVC   RECORD+55(10),=CL10'FASTSRT'                      RS1007\n         TM    LE_STATUS_BYTE_01,BIT6\n         JO    LE_370_15_#7                                       *CSC*\n         MVC   RECORD+55(10),=CL10'NOFASTSRT'                    RS1007\nLE_370_15_#7 DS 0H                                                *CSC*\n         CLC   LE_VERS(4),=C'0501'  Vers+Rel < 0501 E.Cob V5.1   RS1015\n         JL    LE_370_15_#8          no                          RS1015\n         MVC   RECORD+66(8),=CL8'SQLIMS'                         RS1015\n         TM    LE_STATUS_BYTE_01,BIT7                            RS1015\n         JO    LE_370_15_#8                                      RS1015\n         MVC   RECORD+66(8),=CL8'NOSQLIMS'                       RS1015\nLE_370_15_#8   DS 0H                                             RS1015\n         CLI   LE_SWITCH,C'1'   COBOL/370 FDUMP not valid        RS0705\n         JE    LE_370_17                                         RS0705\n         MVC   RECORD+66(8),=CL8'FDUMP'                          RS1007\n         TM    LE_STATUS_BYTE_01,BIT7\n         JO    LE_370_17                                          *CSC*\n         MVC   RECORD+66(8),=CL8'NOFDUMP'\nLE_370_17 DS 0H                                                  RS0705\n         CLC   LE_VERS(4),=C'0600'  Vers+Rel < 0600 E.Cob V6     RS1216\n         JH    LE_370_17_#1          no                          RS1216\n         MVC   RECORD+76(6),=CL6'LIB'                            RS1007\n         TM    LE_STATUS_BYTE_02,BIT0                            RS1007\n         JO    LE_370_17_#1                                      RS1007\n         MVC   RECORD+76(6),=CL6'NOLIB'                          RS1007\nLE_370_17_#1 DS 0H                                               RS1007\n         MVC   RECORD+92(7),=CL7'LIST'                           RS1007\n         TM    LE_STATUS_BYTE_02,BIT1                            RS1007\n         JO    LE_370_17_#2                                      RS1007\n         MVC   RECORD+92(7),=CL7'NOLIST'                         RS1007\nLE_370_17_#2 DS 0H                                               RS1007\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(3),=CL3'MAP'                             RS1007\n         TM    LE_STATUS_BYTE_02,BIT2\n         JO    LE_370_17_#3                                       *CSC*\n         MVC   RECORD+1(5),=CL5'NOMAP'                           RS1007\nLE_370_17_#3 DS 0H                                                *CSC*\n         MVC   RECORD+9(6),=CL6'NUM'                             RS1007\n         TM    LE_STATUS_BYTE_02,BIT3\n         JO    LE_370_17_#4                                       *CSC*\n         MVC   RECORD+9(6),=CL6'NONUM'                           RS1007\nLE_370_17_#4 DS 0H                                                *CSC*\n         MVC   RECORD+17(6),=CL6'OBJ'\n         TM    LE_STATUS_BYTE_02,BIT4\n         JO    LE_370_17_#5                                       *CSC*\n         MVC   RECORD+17(6),=CL6'NOOBJ'                          RS1007\nLE_370_17_#5 DS 0H                                                *CSC*\n         MVC   RECORD+27(8),=CL8'OFFSET'                         RS1007\n         TM    LE_STATUS_BYTE_02,BIT5\n         JO    LE_370_17_#6                                       *CSC*\n         MVC   RECORD+27(8),=CL8'NOOFFSET'                       RS1007\nLE_370_17_#6 DS 0H                                                *CSC*\n         MVC   RECORD+36(10),=CL10'OPTIMIZE'                     RS1007\n         TM    LE_STATUS_BYTE_02,BIT6\n         JO    LE_370_17_#7                                       *CSC*\n         MVC   RECORD+36(10),=CL10'NOOPTIMIZE'                   RS1007\nLE_370_17_#7 DS 0H                                                *CSC*\n         CLI   LE_SWITCH,C'1'   COBOL/370\n         JNE   LE_370_18\n         CLC   LE_VERS(4),=C'0301'  Vers+Rel < 0301 COBOL V3R1\n         JL    LE_370_18             yes\n         MVC   RECORD+55(18),=CL18'OUTDD(SYSOUT)'                RS1007\n         TM    LE_STATUS_BYTE_02,BIT7\n         JO    LE_370_19                                         RS1007\n         MVC   RECORD+55(18),=CL18'OUTDD(Supplied)'              RS1007\n*        BRAS  R14,SPACE1                                        RS1007\n         J     LE_370_19\nLE_370_18 DS 0H\n         MVC   RECORD+55(17),=CL17'OUTDD(Default)'               RS1007\n         TM    LE_STATUS_BYTE_02,BIT7\n         JO    LE_370_19                                         RS1007\n         MVC   RECORD+55(17),=CL17'OUTDD(Supplied)'              RS1007\n*        BRAS  R14,SPACE1                                        RS1007\nLE_370_19 DS 0H\n         MVC   RECORD+76(15),=CL15'NUMPROC(MIG)'                 RS1007\n         TM    LE_STATUS_BYTE_05,BIT0\n         JO    LE_370_21\n         MVC   RECORD+76(15),=CL15'NUMPROC(PFD)'\n         TM    LE_STATUS_BYTE_03,BIT0\n         JO    LE_370_21\n         MVC   RECORD+76(15),=CL15'NUMPROC(NOPFD)'               RS1007\nLE_370_21 DS 0H\n         MVC   RECORD+92(7),=CL7'RENT'                           RS1007\n         CLI   CSECT_ANALYZE_KZ,C'M' First csect (main-ep)?      PF0608\n         JNE   LE_370_21_#0          No,don't set CSCCRNT        SS0615\n         MVC   CSCCRNT(3),=CL3'YES'                               *CSC*\nLE_370_21_#0 DS 0H                                               SS0615\n         TM    LE_STATUS_BYTE_03,BIT1\n         JO    LE_370_21_#1                                       *CSC*\n         MVC   RECORD+92(7),=CL7'NORENT'                         RS1007\n         CLI   CSECT_ANALYZE_KZ,C'M' First csect (main-ep)?      SS0615\n         JNE   LE_370_21_#1          No,don't set CSCCRNT        SS0615\n         MVC   CSCCRNT(3),=CL3'NO '                               *CSC*\nLE_370_21_#1 DS 0H                                                *CSC*\n         BRAS  R14,SPACE1                                        RS1007\n         MVC   RECORD,BLANKS                                     RS1007\n         MVC   RECORD+1(6),=CL6'RES'                             RS1007\n         TM    LE_STATUS_BYTE_03,BIT2\n         JO    LE_370_21_#2                                       *CSC*\n         MVC   RECORD+1(6),=CL6'NORES'                           RS1007\nLE_370_21_#2 DS 0H                                                *CSC*\n         MVC   RECORD+9(6),=CL6'SEQ'                             RS1007\n         TM    LE_STATUS_BYTE_03,BIT3\n         JO    LE_370_21_#3                                       *CSC*\n         MVC   RECORD+9(6),=CL6'NOSEQ'                           RS1007\nLE_370_21_#3 DS 0H                                                *CSC*\n         CLC   LE_VERS(4),=C'0501'  Vers+Rel < 0501 E.Cob V5.1   RS1216\n         JH    LE_370_21_#4          yes                         RS1216\n         MVC   RECORD+17(9),=CL9'SIZE(MAX)'                      RS1007\n         TM    LE_STATUS_BYTE_03,BIT4\n         JO    LE_370_21_#4                                       *CSC*\n         MVC   RECORD+17(9),=CL9'SIZE(VAL)'                      RS1007\nLE_370_21_#4 DS 0H                                                *CSC*\n         MVC   RECORD+27(9),=CL9'SOURCE'                         RS1007\n         TM    LE_STATUS_BYTE_03,BIT5\n         JO    LE_370_21_#5                                       *CSC*\n         MVC   RECORD+27(9),=CL9'NOSOURCE'                       RS1007\nLE_370_21_#5 DS 0H                                                *CSC*\n         MVC   RECORD+36(20),=CL20'SSRANGE(ZLEN/NOZLEN)'         RS0516\n         CLC   LE_VERS(4),=C'0600'  Vers+Rel>0600 is V6.1        RS0516\n         JH    LE_370_21_#51          yes                        RS0516\n         MVC   RECORD+36(20),=CL20'SSRANGE'                      RS1007\nLE_370_21_#51 DS 0H                                              RS0516\n         TM    LE_STATUS_BYTE_03,BIT6\n         JO    LE_370_21_#6                                       *CSC*\n         MVC   RECORD+36(20),=CL20'NOSSRANGE'                    RS1007\nLE_370_21_#6 DS 0H                                                *CSC*\n         MVC   RECORD+55(8),=CL8'TERM'                           RS1007\n         TM    LE_STATUS_BYTE_03,BIT7\n         JO    LE_370_21_#7                                       *CSC*\n         MVC   RECORD+55(8),=CL8'NOTERM'\nLE_370_21_#7 DS 0H                                                *CSC*\n         MVC   RECORD+66(8),=CL8'TEST'                           RS1007\n         TM    LE_STATUS_BYTE_04,BIT0                            RS1007\n         JO    LE_370_21_#8                                      RS1007\n         MVC   RECORD+66(8),=CL8'NOTEST'                         RS1007\nLE_370_21_#8 DS 0H                                               RS1007\n         MVC   RECORD+76(10),=CL11'TRUNC(BIN)'                   RS1007\n         TM    LE_STATUS_BYTE_05,BIT4                            RS1007\n         JO    LE_370_33                                         RS1007\n         MVC   RECORD+76(10),=CL11'TRUNC(STD)'                   RS1007\n         TM    LE_STATUS_BYTE_04,BIT1                            RS1007\n         JO    LE_370_33                                         RS1007\n         MVC   RECORD+76(10),=CL11'TRUNC(OPT)'                   RS1007\nLE_370_33 DS 0H                                                  RS1007\n         MVC   RECORD+92(9),=CL9'WORD(xx)'                       RS1007\n         TM    LE_STATUS_BYTE_04,BIT2                            RS1007\n         JO    LE_370_33_#1                                      RS1007\n         MVC   RECORD+92(9),=CL9'NOWORD'                         RS1007\nLE_370_33_#1 DS 0H                                               RS1007\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(8),=CL8'VBREF'                           RS1007\n         TM    LE_STATUS_BYTE_04,BIT3\n         JO    LE_370_33_#2                                       *CSC*\n         MVC   RECORD+1(8),=CL8'NOVBREF'                         RS1007\nLE_370_33_#2 DS 0H                                                *CSC*\n         MVC   RECORD+9(6),=CL6'XREF'                            RS1007\n         TM    LE_STATUS_BYTE_04,BIT4\n         JO    LE_370_33_#3                                       *CSC*\n         MVC   RECORD+9(6),=CL6'NOXREF'\nLE_370_33_#3 DS 0H                                                *CSC*\n         MVC   RECORD+17(6),=CL6'ZWB'                            RS1007\n         TM    LE_STATUS_BYTE_04,BIT5\n         JO    LE_370_33_#4                                       *CSC*\n         MVC   RECORD+17(6),=CL6'NOZWB'                          RS1007\nLE_370_33_#4 DS 0H                                                *CSC*\n         MVC   RECORD+27(7),=CL7'NAME'                           RS1007\n         TM    LE_STATUS_BYTE_04,BIT6\n         JO    LE_370_33_#5                                       *CSC*\n         MVC   RECORD+27(7),=CL7'NONAME'\nLE_370_33_#5 DS 0H                                                *CSC*\n         CLI   LE_VERS+1,C'.'       Cobol/2 ?                    RS0712\n         JE    LE_370_33_#6          yes                         RS0712\n         CLC   LE_VERS(4),=C'0300'  Vers+Rel > 0300 COBOL V3R1   RS0103\n         JH    LE_370_40             yes, CMPR2 no longer valid   *CSC*\nLE_370_33_#6 DS 0H                                               RS0712\n         MVC   RECORD+36(8),=CL8'CMPR2'                          RS1007\n         TM    LE_STATUS_BYTE_04,BIT7\n         JO    LE_370_40                                          *CSC*\n         MVC   RECORD+36(8),=CL8'NOCMPR2'                        RS1007\nLE_370_40 DS 0H                                                  RS0103\n         MVC   RECORD+44(12),=CL12'NUMCLS'  other Cobol          RS1007\n         TM    LE_STATUS_BYTE_05,BIT1\n         JO    LE_370_40_#1                                       *CSC*\n         MVC   RECORD+44(12),=CL12'NONUMCLS'                     RS1007\nLE_370_40_#1 DS 0H                                                *CSC*\n         CLI   LE_SWITCH,C'1'   COBOL/370\n         JNE   LE_370_42\n         CLC   LE_VERS(4),=C'0102'  Vers+Rel < 0102 COBOL MVS and VM\n         JL    LE_370_42             yes\n         MVC   RECORD+44(12),=CL12'NUMCLS(ALT)'                  RS1007\n         TM    LE_STATUS_BYTE_05,BIT1\n         JO    LE_370_52                                         RS1007\n         MVC   RECORD+44(12),=CL12'NUMCLS(PRIM)'                 RS1007\nLE_370_42 DS 0H\n         MVC   RECORD+66(7),=CL7'DBCS'                           RS1007\n         TM    LE_STATUS_BYTE_05,BIT2\n         JO    LE_370_42_#1                                       *CSC*\n         MVC   RECORD+66(7),=CL7'NODBCS'                         RS1007\nLE_370_42_#1 DS 0H                                                *CSC*\n         MVC   RECORD+76(6),=CL6'AWO'                            RS1007\n         TM    LE_STATUS_BYTE_05,BIT3\n         JO    LE_370_42_#2                                       *CSC*\n         MVC   RECORD+76(6),=CL6'NOAWO'                          RS1007\nLE_370_42_#2 DS 0H                                                *CSC*\n         CLI   LE_SWITCH,C'1'                  Cobol/370\n         JNE   LE_370_50Z                      no                RS1007\n         CLC   LE_VERS(4),=C'0300'  Vers+Rel > 0300 COBOL V3R1\n         JL    LE_370_45             yes, Events not for E.C.\n         MVC   RECORD+92(9),=CL9'EVENTS'       n/a COBOL/2\n         TM    LE_STATUS_BYTE_05,BIT5\n         JO    LE_370_45                                          *CSC*\n         MVC   RECORD+92(9),=CL9'NOEVENTS'                       RS1007\nLE_370_45 DS 0H\n         BRAS  R14,SPACE1                                        RS1007\n         MVC   RECORD,BLANKS                                     RS1007\n         MVC   RECORD+1(11),=CL11'CURRENCY'   n/a COBOL/2        RS1007\n         TM    LE_STATUS_BYTE_05,BIT6\n         JO    LE_370_48                                          *CSC*\n         MVC   RECORD+1(11),=CL11'NOCURRENCY'                    RS1007\nLE_370_48 DS 0H\n         MVC   RECORD+17(40),=CL40'Compilation_unit_Class'       ES0116\n         TM    LE_STATUS_BYTE_05,BIT7\n         JO    LE_370_48_#1                                       *CSC*\n         MVC   RECORD+17(40),=CL40'Compilation_unit_Program'     ES0116\nLE_370_48_#1 DS 0H                                                *CSC*\n         CLC   LE_VERS(4),=C'0102'  Vers+Rel < 0102 COBOL MVS and VM\n         JL    LE_370_50Z         no\n*                         Supported only for COBOL MVS and VM R2\n         BRAS  R14,SPACE1\n* The COBANAL SUMMARY report is only generated for Mainline      SS0615\n* modules. As RMODE(24/ANY)\" reporting appears in SUMMARY we     SS0615\n* need to ensure that we only set \"RM\" to 24 or ANY in CSCRMODE  SS0615\n* if this is a Mainline module and not a subroutine.             SS0615\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(11),=CL11'RMODE(ANY)'\n         CLI   CSECT_ANALYZE_KZ,C'M' First csect (main-ep)?      SS0615\n         JNE   LE_370_48_#11         No,do not set CSCRMODE      SS0615\n         MVC   CSCRMODE(3),=CL3'ANY'                              *CSC*\nLE_370_48_#11 DS 0H                                              SS0615\n         TM    LE_STATUS_BYTE_26,BIT0\n         JO    LE_370_48_#2                                       *CSC*\n         MVC   RECORD+1(11),=CL11'RMODE(24)'\n         CLI   CSECT_ANALYZE_KZ,C'M' First csect (main-ep)?      SS0615\n         JNE   LE_370_48_#2          No,do not set CSCRMODE      SS0615\n         MVC   CSCRMODE(3),=CL3'24 '                              *CSC*\nLE_370_48_#2 DS 0H                                                *CSC*\n         CLC   LE_VERS(4),=C'0401'  Vers+Rel < 0401 E.Cob V4.1   RS1207\n         JL    LE_370_48_#21         no                          RS1207\n         MVC   RECORD+17(13),=CL13'TEST(HOOK)'                   RS1207\n         TM    LE_STATUS_BYTE_26,BIT1                            RS1207\n         JO    LE_370_48_#5                                      RS1207\n         TM    LE_STATUS_BYTE_26,BIT2                            RS1207\n         JO    LE_370_48_#5                                      RS1207\n         TM    LE_STATUS_BYTE_26,BIT3                            RS1207\n         JO    LE_370_48_#5                                      RS1207\n         MVC   RECORD+17(13),=CL13'NO_TEST(HOOK)'                ES0116\nLE_370_48_#21 DS 0H                                              RS1207\n         MVC   RECORD+17(13),=CL13'TEST(STMT)'                   RS1007\n         TM    LE_STATUS_BYTE_26,BIT1\n         JO    LE_370_48_#3                                       *CSC*\n         MVC   RECORD+17(13),=CL13'NO_TEST(STMT)'                ES0116\nLE_370_48_#3 DS 0H                                                *CSC*\n         MVC   RECORD+36(13),=CL13'TEST(PATH)'                   RS1007\n         TM    LE_STATUS_BYTE_26,BIT2\n         JO    LE_370_48_#4                                       *CSC*\n         MVC   RECORD+36(13),=CL13'NO_TEST(PATH)'                ES0116\nLE_370_48_#4 DS 0H                                                *CSC*\n         MVC   RECORD+55(14),=CL14'TEST(BLOCK)'                  RS1007\n         TM    LE_STATUS_BYTE_26,BIT3\n         JO    LE_370_48_#5                                       *CSC*\n         MVC   RECORD+55(14),=CL14'NO_TEST(BLOCK)'               ES0116\nLE_370_48_#5 DS 0H                                                *CSC*\n         MVC   RECORD+76(17),=CL17'OPT(FULL)'                    RS1007\n         TM    LE_STATUS_BYTE_26,BIT4\n         JO    LE_370_48_#6                                       *CSC*\n         MVC   RECORD+76(17),=CL17'NOOPT_OR_OPT(STD)'            ES0116\nLE_370_48_#6 DS 0H                                                *CSC*\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(13),=CL13'INTDATE(LIL)'\n         TM    LE_STATUS_BYTE_26,BIT5\n         JO    LE_370_48_#7                                       *CSC*\n         MVC   RECORD+1(13),=CL13'INTDATE(ANSI)'\nLE_370_48_#7 DS 0H                                                *CSC*\n         CLC   LE_VERS(4),=C'0202'  Vers+Rel < 0202 COBOL MVS and VM\n         JL    LE_370_50Y           no lower                     RS1000\n         MVC   RECORD+17(14),=CL14'TEST(SEPARATE)'               RS1007\n         TM    LE_STATUS_BYTE_26,BIT6                            RS1000\n         JO    LE_370_50Y                                         *CSC*\n         MVC   RECORD+17(17),=CL17'NO_TEST(SEPARATE)'            ES0116\nLE_370_50Y DS  0H\n         MVC   RECORD+44(22),=CL22'PGMNAME(LONGUPPER)'           RS1007\n         TM    LE_STATUS_BYTE_27,BIT0\n         JO    LE_370_50Y_#1                                      *CSC*\n         MVC   RECORD+44(22),=CL22'NOT_PGMNAME(LONGUPPER)'       ES0116\nLE_370_50Y_#1 DS 0H                                               *CSC*\n         MVC   RECORD+76(22),=CL22'PGMNAME(LONGMIXED)'\n         TM    LE_STATUS_BYTE_27,BIT1\n         JO    LE_370_SRST                                       RS0704\n         MVC   RECORD+76(22),=CL22'NOT_PGMNAME(LONGMIXED)'       ES0116\nLE_370_SRST    DS 0H                                             RS0704\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(5),=CL5'DLL'\n         TM    LE_STATUS_BYTE_27,BIT2\n         JO    LE_370_SRST_#1                                     *CSC*\n         MVC   RECORD+1(5),=CL5'NODLL'\nLE_370_SRST_#1 DS 0H                                              *CSC*\n         MVC   RECORD+17(11),=CL11'EXPORTALL'                    RS1007\n         TM    LE_STATUS_BYTE_27,BIT3\n         JO    LE_370_SRST_#2                                     *CSC*\n         MVC   RECORD+17(11),=CL11'NOEXPORTALL'                  RS1007\nLE_370_SRST_#2 DS 0H                                              *CSC*\n         MVC   RECORD+36(10),=CL10'DATEPROC'                     RS1007\n         TM    LE_STATUS_BYTE_27,BIT4\n         JO    LE_370_SRST_#3                                     *CSC*\n         MVC   RECORD+36(10),=CL10'NODATEPROC'                   RS1007\nLE_370_SRST_#3 DS 0H                                              *CSC*\n         CLC   LE_VERS(4),=C'0500'  Vers+Rel =>0500 E.Cob V5.1   RS1015\n         JH    LE_370_SRST_#3_1       yes (YEARWINDOW obsolete)  RS1015\n         STRING64 (RECORD,,L),9X,'YEARWINDOW(',(LE_YEAR_WINDOW,H,R4B), X\n               ')',INTO=RECORD                                   RS1007\nLE_370_SRST_#3_1 DS 0H                                            *CSC*\n         CLC   LE_VERS(4),=C'0202'  Vers+Rel < 0202 COBOL MVS and VM\n         JL    LE_370_50Z           no lower                     RS1000\n         MVC   RECORD+76(13),=CL13'ARITH(EXTEND)'                RS1007\n         TM    LE_STATUS_BYTE_27,BIT5                            RS1000\n         JO    LE_370_SRST_#4                                     *CSC*\n         MVC   RECORD+76(13),=CL13'ARITH(COMPAT)'                RS1007\nLE_370_SRST_#4 DS 0H                                              *CSC*\n         CLI   LE_SWITCH,C'1'   COBOL/370\n         JNE   LE_370_50Z\n         CLC   LE_VERS(4),=C'0301'  Vers+Rel < 0301 COBOL V3R1\n         JL    LE_370_50Z            yes\n         MVC   RECORD+92(6),=CL6'THREAD'                         RS1007\n         TM    LE_STATUS_BYTE_27,BIT6\n         JO    LE_370_SRST_#40                                    *CSC*\n         MVC   RECORD+92(8),=CL8'NOTHREAD'                       RS1007\nLE_370_SRST_#40 DS 0H                                             *CSC*\n         CLC   LE_VERS(6),=C'030401' Vers/Rel/Mod E.C. 3.4.1     RS1207\n         JL    LE_370_50Z            no                          RS1207\n         BRAS  R14,SPACE1                                        RS1207\n         MVC   RECORD,BLANKS                                     RS1207\n         CLC   LE_VERS(4),=C'0401'  Vers+Rel < 0401 E.Cob V4.1   RS1207\n         JL    LE_370_SRST_#41       no                          RS1207\n         MVC   RECORD+1(10),=CL10'TEST(EJPD)'                    RS1207\n         TM    LE_STATUS_BYTE_27,BIT7                            RS1207\n         JO    LE_370_SRST_#41                                   RS1207\n         MVC   RECORD+1(12),=CL12'TEST(NOEJPD)'                  RS1207\nLE_370_SRST_#41 DS 0H\n         MVC   RECORD+17(3),=CL3'SQL'                            RS1207\n         TM    LE_STATUS_BYTE_28,BIT0                            RS1207\n         JO    LE_370_SRST_#42                                   RS1207\n         MVC   RECORD+17(5),=CL5'NOSQL'                          RS1207\nLE_370_SRST_#42 DS 0H                                            RS1207\n         MVC   RECORD+27(4),=CL4'CICS'                           RS1207\n         TM    LE_STATUS_BYTE_28,BIT1                            RS1207\n         JO    LE_370_SRST_#43                                   RS1207\n         MVC   RECORD+27(6),=CL6'NOCICS'                         RS1207\nLE_370_SRST_#43 DS 0H                                            RS1207\n         CLC   LE_VERS(4),=C'0401'  Vers+Rel < 0401 E.Cob V4.1   RS1207\n         JL    LE_370_SRST_#44       no                          RS1207\n         MVC   RECORD+44(7),=CL7'MDECK'                          RS1207\n         TM    LE_STATUS_BYTE_28,BIT2                            RS1207\n         JO    LE_370_SRST_#44                                   RS1207\n         MVC   RECORD+44(7),=CL7'NOMDECK'                        RS1207\nLE_370_SRST_#44 DS 0H                                            RS1207\n         MVC   RECORD+55(10),=CL10'SQLCCSID'                     RS1207\n         TM    LE_STATUS_BYTE_28,BIT3                            RS1207\n         JO    LE_370_SRST_#45                                   RS1207\n         MVC   RECORD+55(10),=CL10'NOSQLCCSID'                   RS1207\nLE_370_SRST_#45 DS 0H                                            RS1207\n         CLC   LE_VERS(4),=C'0401'  Vers+Rel < 0401 E.Cob V4.1   RS1207\n         JL    LE_370_50Z            no                          RS1207\n         MVC   RECORD+66(9),=CL9'OPTFILE'                        RS1207\n         TM    LE_STATUS_BYTE_28,BIT4                            RS1207\n         JO    LE_370_SRST_#46                                   RS1207\n         MVC   RECORD+66(9),=CL9'NOOPTFILE'                      RS1207\nLE_370_SRST_#46 DS 0H                                            RS1207\n         MVC   RECORD+76(16),=CL16'XMLPARSE(XMLSS)'              RS0616\n         TM    LE_STATUS_BYTE_28,BIT5                            RS1207\n         JO    LE_370_SRST_#47                                   RS1207\n         MVC   RECORD+76(16),=CL16'XMLPARSE(COMPAT)'             RS0616\nLE_370_SRST_#47 DS 0H                                            RS1207\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         CLC   LE_VERS(4),=C'0402'  Vers+Rel < 0402 E.Cob V4.2   RS1015\n         JL    LE_370_50Z            no                          RS1015\n         MVC   RECORD+1(8),=CL8'BLOCK0'                          RS1015\n         TM    LE_STATUS_BYTE_28,BIT6                            RS1015\n         JO    LE_370_SRST_#48                                   RS1015\n         MVC   RECORD+1(8),=CL8'NOBLOCK0'                        RS1015\nLE_370_SRST_#48 DS 0H                                            RS1015\n         CLC   LE_VERS(4),=C'0501'  Vers+Rel < 0501 E.Cob V5.1   RS1015\n         JL    LE_370_50Z            no                          RS1015\n         MVC   RECORD+17(13),=CL13'DISPSIGN(SEP)'                RS1015\n         TM    LE_STATUS_BYTE_28,BIT7                            RS1118\n         JO    LE_370_SRST_#49                                   RS1015\n         MVC   RECORD+17(16),=CL16'DISPSIGN(COMPAT)'             RS1015\nLE_370_SRST_#49 DS 0H                                            RS1015\n         MVC   RECORD+36(8),=CL8'STGOPT'                         RS1015\n         TM    LE_STATUS_BYTE_29,BIT4                            RS1015\n         JO    LE_370_SRST_#50                                   RS1015\n         MVC   RECORD+36(8),=CL8'NOSTGOPT'                       RS1015\nLE_370_SRST_#50 DS 0H                                            RS1015\n         MVC   RECORD+45(13),=CL13'AFP(VOLATILE)'                RS1015\n         TM    LE_STATUS_BYTE_29,BIT5                            RS1015\n         JO    LE_370_SRST_#51                                   RS1015\n         MVC   RECORD+45(15),=CL15'AFP(NOVOLATILE)'              RS1015\nLE_370_SRST_#51 DS 0H                                            RS1015\n         MVC   RECORD+61(14),=CL14'HPGR(PRESERVE)'               RS1015\n         TM    LE_STATUS_BYTE_29,BIT6                            RS1015\n         JO    LE_370_SRST_#52                                   RS1015\n         MVC   RECORD+61(16),=CL16'HPGR(NOPRESERVE)'             RS1015\nLE_370_SRST_#52 DS 0H                                            RS1015\n         MVC   RECORD+78(17),=CL17'NOT_NOTEST(DWARF)'            RS0316\n         TM    LE_STATUS_BYTE_29,BIT7                            RS1015\n         JO    LE_370_SRST_#53                                   RS1015\n         MVC   RECORD+78(17),=CL17'NOTEST(DWARF)'                RS0316\nLE_370_SRST_#53 DS 0H                                            RS1015\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(15),=CL15'QUALIFY(EXTEND)'               RS1015\n         TM    LE_STATUS_BYTE_30,BIT0                            RS1015\n         JO    LE_370_SRST_#54                                   RS1015\n         MVC   RECORD+1(15),=CL15'QUALIFY(COMPAT)'               RS1015\nLE_370_SRST_#54 DS 0H                                            RS1015\n         MVC   RECORD+17(11),=CL11'VLR(COMPAT)'                  RS1015\n         TM    LE_STATUS_BYTE_30,BIT1                            RS1015\n         JO    LE_370_SRST_#55                                   RS1015\n         MVC   RECORD+17(13),=CL13'VLR(STANDARD)'                RS1015\nLE_370_SRST_#55 DS 0H                                            RS1015\n         MVC   RECORD+36(9),=CL9'COPYRIGHT'                      RS1015\n         TM    LE_STATUS_BYTE_30,BIT2                            RS1015\n         JO    LE_370_SRST_#56                                   RS1015\n         MVC   RECORD+36(11),=CL11'NOCOPYRIGHT'                  RS1015\nLE_370_SRST_#56 DS 0H                                            RS1015\n         MVC   RECORD+48(7),=CL7'SERVICE'                        RS1015\n         TM    LE_STATUS_BYTE_30,BIT3                            RS1015\n         JO    LE_370_SRST_#57                                   RS1015\n         MVC   RECORD+48(9),=CL9'NOSERVICE'                      RS1015\nLE_370_SRST_#57 DS 0H                                            RS1015\n         MVC   RECORD+58(13),=CL13'ZONEDATA(MIG)'                RS1015\n         TM    LE_STATUS_BYTE_30,BIT4                            RS1015\n         JO    LE_370_SRST_#58                                   RS1015\n         MVC   RECORD+58(17),=CL17'NOT_ZONEDATA(MIG)'            RS1118\nLE_370_SRST_#58 DS 0H                                            RS1118\n         MVC   RECORD+58(15),=CL15'ZONEDATA(NOPFD)'              RS0620\n         TM    LE_STATUS_BYTE_30,BIT5                            RS1118\n         JO    LE_370_SRST_#59                                   RS1118\n         MVC   RECORD+58(19),=CL19'NOT_ZONEDATA(NOPFD)'          RS0620\nLE_370_SRST_#59 DS 0H                                            RS1015\n         CLC   LE_VERS(4),=C'0601'  Vers+Rel < 0601 E.Cob V6.1   RS0516\n         JL    LE_370_50Z            no                          RS0516\n         BRAS  R14,SPACE1                                        RS0516\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(10),=CL10'NONUMCHECK'                    RS0620\n         TM    LE_STATUS_BYTE_31,BIT0+BIT1+BIT2                  RS1015\n         JZ    LE_370_SRST_#5D       all off                     RS1015\n         MVC   RECORD+1(22),=CL22'NUMCHECK(ZON(ALPHNUM),'        RS1015\n         TM    LE_STATUS_BYTE_31,BIT0                            RS1015\n         JO    LE_370_SRST_#5A                                   RS1015\n         MVC   RECORD+1(9),=CL24'NUMCHECK(NOZON,'                RS1015\nLE_370_SRST_#5A DS 0H                                            RS1015\n         TM    LE_STATUS_BYTE_31,BIT1                            RS1015\n         JZ    LE_370_SRST_#5A1                                  RS1015\n         STRING64 (RECORD,,T),'PAC,',INTO=RECORD\n         J     LE_370_SRST_#5B                                   RS1015\nLE_370_SRST_#5A1 DS 0H                                           RS1015\n         STRING64 (RECORD,,T),'NOPAC,',INTO=RECORD\nLE_370_SRST_#5B DS 0H                                            RS1015\n         TM    LE_STATUS_BYTE_31,BIT2                            RS1015\n         JZ    LE_370_SRST_#5B1                                  RS1015\n         STRING64 (RECORD,,T),'BIN,',INTO=RECORD\n         J     LE_370_SRST_#5C                                   RS1015\nLE_370_SRST_#5B1 DS 0H                                           RS1015\n         STRING64 (RECORD,,T),'NOBIN,',INTO=RECORD\nLE_370_SRST_#5C DS 0H                                            RS1015\n         TM    LE_STATUS_BYTE_31,BIT3                            RS1015\n         JZ    LE_370_SRST_#5D                                   RS1015\n         STRING64 (RECORD,,T),'ABD)',INTO=RECORD\nLE_370_SRST_#5C1 DS 0H                                           RS1015\n         STRING64 (RECORD,,T),'MSG)',INTO=RECORD\nLE_370_SRST_#5D  DS 0H                                           RS1015\n         BRAS  R14,SPACE1                                        RS0516\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(9),=CL9'PARMCHECK'                       RS1015\n         TM    LE_STATUS_BYTE_31,BIT4                            RS1015\n         JO    LE_370_SRST_#5E                                   RS1015\n         MVC   RECORD+1(11),=CL11'NOPARMCHECK'                   RS1015\n         J     LE_370_SRST_#5F  leave no PARMCHECK(MSG) or (ABD) RS1015\nLE_370_SRST_#5E DS 0H                                            RS1015\n         MVC   RECORD+17(14),=CL14'PARMCHECK(ABD)'               RS1015\n         TM    LE_STATUS_BYTE_31,BIT5                            RS1015\n         JO    LE_370_SRST_#5F                                   RS1015\n         MVC   RECORD+17(14),=CL14'PARMCHECK(MSG)'               RS1015\nLE_370_SRST_#5F DS 0H                                            RS1015\n         BRAS  R14,SPACE1                                        RS0516\n         MVC   RECORD,BLANKS\n         STRING64 (RECORD,,L),1X,'BUILD_LEVEL_INFO(',            RS0516X\n               (LE_BUILD_LEVEL),')',                             RS0516X\n               INTO=RECORD                                       RS0516\nLE_370_SRST_#6 DS 0H                                              *CSC*\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         STRING64 (RECORD,,L),1X,'CODEPAGE(',(LE_CCSID,H,R4B),')',     X\n               INTO=RECORD\nLE_370_50Z DS 0H\n         CLC   LE_VERS(4),=C'0501'  Vers+Rel < 0501 E.Cob V5.1   RS1015\n         JL    LE_370_50ZZ           no                          RS1015\n         STRING64 (RECORD,,L),'  ARCH(',(LE_ARCHLEVEL,FL1,L),    RS1216X\n               ') OPT(',(LE_OPT_LEVEL,FL1,L),')',INTO=RECORD     RS1216\n         BRAS  R14,SPACE1\n         CLC   LE_VERS(4),=C'0600'  Vers+Rel < 0600 E.Cob V6.1   RS0620\n         JL    LE_370_50ZZ             yes leave                 RS0620\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(10),=CL10'NOSUPPRESS'                    RS1015\n         TM    LE_STATUS_BYTE_23,BIT4                            RS0620\n         JNO   LE_370_50ZA                                       RS0620\n         MVC   RECORD+1(10),=CL10'SUPPRESS  '                    RS1015\nLE_370_50ZA DS 0H                                                RS0620\n         MVC   RECORD+17(8),=CL8'NOINLINE'                       RS1015\n         TM    LE_STATUS_BYTE_23,BIT7                            RS0620\n         JNO   LE_370_50ZB                                       RS0620\n         MVC   RECORD+17(8),=CL8'INLINE  '                       RS1015\nLE_370_50ZB DS 0H                                                RS0620\n         BRAS  R14,SPACE1                                        RS0620\n         CLC   LE_VERS(4),=C'0603'  Vers+Rel < 0630 E.Cob V6.3   RS0620\n         JL    LE_370_50ZZ             yes leave                 RS0620\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(29),=CL29'TEST/NOTEST(SEPARATE(DSNAME))' RS1015\n         TM    LE_STATUS_BYTE_31,BIT7                            RS1015\n         JO    LE_370_50ZC                                       RS1015\n         MVC   RECORD+1(31),=CL31'TEST/NOTEST(SEPARATE(NODSNAME))' 0620\nLE_370_50ZC DS 0H                                                RS0620\n         BRAS  R14,SPACE1                                        RS0620\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(6),=CL6'LP(64)'                          RS1015\n         TM    LE_STATUS_BYTE_32,BIT0                            RS1015\n         JO    LE_370_50ZE                                       RS1015\n         MVC   RECORD+1(6),=CL6'LP(32)'                          RS0620\nLE_370_50ZE DS 0H                                                RS0620\n         BRAS  R14,SPACE1                                        RS0620\nLE_370_50ZZ DS 0H\n         BRAS  R14,BLANK1                                        RS0620\n         STRING64 ADDINFO,INTO=RECORD                             *CSC*\n         BRAS  R14,SPACE1\n         STRING64 '------------ about DATA DIVISION    --------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD\n         BRAS  R14,SPACE2\n         STRING64 'Program use',' no',' QSAM or SAM access method',    X\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT0\n         JNO   LE_370_51\n         STRING64 'Program use',' QSAM or SAM access method',          X\n               INTO=RECORD\nLE_370_51 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'Program use',' no',' VSAM sequential files',        X\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT1\n         JNO   LE_370_52\n         STRING64 'Program use',' VSAM sequential files',INTO=RECORD\nLE_370_52 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'Program use',' no',' VSAM indexed files',INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT2\n         JNO   LE_370_53\n         STRING64 'Program use',' VSAM indexed files',INTO=RECORD\nLE_370_53 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'Program use',' no',' VSAM RBA files',INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT3\n         JNO   LE_370_54\n         STRING64 'Program use',' VSAM RBA files',INTO=RECORD\nLE_370_54 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'Program use',' no',' CODE-SET (ASCII files)',       X\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT4\n         JNO   LE_370_55\n         STRING64 'Program use',' CODE-SET (ASCII files)',INTO=RECORD\nLE_370_55 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'Program use',' no',' spanned records',INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT5\n         JNO   LE_370_56\n         STRING64 'Program use',' spanned records',INTO=RECORD\nLE_370_56 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'Program has',' no',' picture G (DBCS) items',       X\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT6\n         JNO   LE_370_57\n         STRING64 'Program has',' picture G (DBCS) items',INTO=RECORD\nLE_370_57 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'Program has',' no',' OCCURS DEPENDING ON items',    X\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT7\n         JNO   LE_370_58\n         STRING64 'Program has',' OCCURS DEPENDING ON items',          X\n               INTO=RECORD\nLE_370_58 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'Program has',' no',' SYNCHRONIZED clause',          X\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT0\n         JNO   LE_370_59\n         STRING64 'Program has',' SYNCHRONIZED clause',INTO=RECORD\nLE_370_59 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'Program has',' no',' JUSTIFIED clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT1\n         JNO   LE_370_60\n         STRING64 'Program has',' JUSTIFIED clause',INTO=RECORD\nLE_370_60 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'Program has',' no',' POINTER items',INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT2\n         JNO   LE_370_61\n         STRING64 'Program has',' POINTER items',INTO=RECORD\nLE_370_61 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'Program has',' no',' complex ODO clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT3\n         JNO   LE_370_62\n         STRING64 'Program has',' complex ODO clause',INTO=RECORD\nLE_370_62 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'Program has',' no',' external',                     X\n               ' floating-point items',                                X\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT4\n         JNO   LE_370_63\n         STRING64 'Program has',' external',' floating-point items',   X\n               INTO=RECORD\nLE_370_63 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'Program has',' no',' internal',                     X\n               ' floating-point items',                                X\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT5\n         JNO   LE_370_63_1\n         STRING64 'Program has',' internal',' floating-point items',   X\n               INTO=RECORD\nLE_370_63_1 DS 0H\n         CLI   LE_SWITCH,C'1'                  Cobol/370\n         JNE   LE_370_64                       no, jump around\n         BRAS  R14,SPACE1\n         STRING64 'Program has',' no',' Proc-Pointer or Func-Pointer', X\n               ' items',INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT7\n         JNO   LE_370_63_2\n         STRING64 'Program has',' Proc or Func-Pointer',' items',      X\n               INTO=RECORD\nLE_370_63_2 DS 0H\n         CLC   LE_VERS(4),=C'0202'  Vers+Rel < 0202 COBOL MVS and VM\n         JL    LE_370_64            no lower                     RS1000\n         BRAS  R14,SPACE1\n         STRING64 'Program has',' no',' Line-sequential file',         X\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT6\n         JNO   LE_370_64\n         STRING64 'Program has',' Line-sequential file',               X\n               INTO=RECORD\nLE_370_64 DS 0H\n         STRING64 'The working storage/DSA size is ',            RS0316X\n               (LE_TGT_WS_LENGTH,F,R9B),INTO=RECORD              RS1007\n         BRAS  R14,SPACE1                                        RS0316\nLE_370_65 DS 0H                                                  RS0316\n         BRAS  R14,BLANK1                                        RS0316\n         STRING64 ADDINFO,INTO=RECORD                             *CSC*\n         BRAS  R14,SPACE1\n         STRING64 '------------ about ENVIROMENT DIVISION -----------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD\n         BRAS  R14,SPACE2\n         STRING64 'Program use',' no',' FILE-STATUS clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_08,BIT0\n         JNO   LE_370_66\n         STRING64 'Program use',' FILE-STATUS clause',INTO=RECORD\nLE_370_66 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'Program use',' no',' RERUN clause in I/O-control',  X\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_08,BIT1\n         JNO   LE_370_67\n         STRING64 'Program has',' RERUN clause in I/O-control',        X\n               INTO=RECORD\nLE_370_67 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'Program use',' no',' UPSI switches',INTO=RECORD\n         TM    LE_STATUS_BYTE_08,BIT2\n         JNO   LE_370_68\n         STRING64 'Program use',' UPSI switches',INTO=RECORD\nLE_370_68 DS 0H\n         CLC   LE_VERS(4),=C'0600'  Vers+Rel > 0600 E.Cob V6.1   RS0516\n         JL    LE_370_70               no leave                  RS0516\n         BRAS  R14,SPACE1                                        RS0516\n         STRING64 'WSOPT bit is ','off',INTO=RECORD              RS0516\n         TM    LE_STATUS_BYTE_08,BIT3                            RS0516\n         JNO   LE_370_69                                         RS0516\n         STRING64 'WSOPT bit is ','on',INTO=RECORD               RS0516\nLE_370_69 DS 0H                                                  RS0516\n         BRAS  R14,SPACE1                                        RS0516\n         STRING64 'VSAMOPENFS is ','off',INTO=RECORD             RS0516\n         TM    LE_STATUS_BYTE_08,BIT4                            RS0516\n         JNO   LE_370_70                                         RS0516\n         STRING64 'VSAMOPENFS is ','on',INTO=RECORD              RS0516\nLE_370_70 DS 0H                                                  RS0516\n         BRAS  R14,SPACE1                                        RS0215\n         CLC   LE_VERS(4),=C'0500'  Vers+Rel > 0500 E.Cob V5.1   RS0215\n         JH    LE_370_71_1              yes leave                RS0215\n         STRING64 'Program address TGT via ','R13',INTO=RECORD   RS1007\n         TM    LE_TGT_REG,BIT0                                   RS1007\n         JNO   LE_370_71                                         RS1007\n         STRING64 'Program address TGT via ','R9',INTO=RECORD    RS1007\nLE_370_71 DS 0H\n         BRAS  R14,SPACE1                                        RS0215\nLE_370_71_1 DS 0H                                                RS0215\n         BRAS  R14,BLANK1                                        RS0215\n         STRING64 ADDINFO,INTO=RECORD                             *CSC*\n         BRAS  R14,SPACE1\n         STRING64 '------------ about PROCEDURE DIVISION  -----------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD\n         BRAS  R14,SPACE2\n         STRING64 'Following statements in control (check Y/N):',      X\n               INTO=RECORD\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(6),=CL6'Accept'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_09,BIT0\n         JNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(3),=CL3'Add'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_09,BIT1\n         JNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(5),=CL5'Alter'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_09,BIT2\n         JNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(4),=CL4'Call'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_09,BIT3\n         JNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(6),=CL6'Cancel'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_09,BIT4\n         JNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(5),=CL5'Close'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_09,BIT6\n         JNO   *+8\n         MVI   RECORD+100,C'Y'\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(7),=CL7'Compute'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_10,BIT0\n         JNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(6),=CL6'Delete'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_10,BIT2\n         JNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(7),=CL7'Display'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_10,BIT4\n         JNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(6),=CL6'Divide'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_10,BIT5\n         JNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(11),=CL11'End-Perform'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_11,BIT1\n         JNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(5),=CL5'Enter'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_11,BIT2\n         JNO   *+8\n         MVI   RECORD+100,C'Y'\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(5),=CL5'Entry'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_11,BIT3\n         JNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(4),=CL4'Exit'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_11,BIT4\n         JNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(5),=CL5'Go_to'                          ES0116\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_11,BIT6\n         JNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(2),=CL2'If'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_11,BIT7\n         JNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(10),=CL10'Initialize'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_12,BIT0\n         JNO   *+8\n         MVI   RECORD+83,C'Y'\n         CLI   LE_SWITCH,C'1'   COBOL/370 ?\n         JNE   LE_370_75          no, jump around\n         MVC   RECORD+86(6),=CL6'Invoke'   comes with COBOL/370\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_12,BIT1\n         JNO   *+8\n         MVI   RECORD+100,C'Y'\nLE_370_75 DS 0H\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(7),=CL7'Inspect'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_12,BIT2\n         JNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(5),=CL5'Merge'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_12,BIT3\n         JNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(4),=CL4'Move'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_12,BIT4\n         JNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(8),=CL8'Multiply'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_12,BIT5\n         JNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(4),=CL4'Open'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_12,BIT6\n         JNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(7),=CL7'Perform'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_12,BIT7\n         JNO   *+8\n         MVI   RECORD+100,C'Y'\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(4),=CL4'Read'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_13,BIT0\n         JNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(7),=CL7'Release'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_13,BIT2\n         JNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(6),=CL6'Return'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_13,BIT3\n         JNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(7),=CL7'Rewrite'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_13,BIT4\n         JNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(6),=CL6'Search'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_13,BIT5\n         JNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(3),=CL3'Set'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_13,BIT7\n         JNO   *+8\n         MVI   RECORD+100,C'Y'\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(4),=CL4'Sort'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_14,BIT0\n         JNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(5),=CL5'Start'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_14,BIT1\n         JNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(4),=CL4'Stop'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_14,BIT2\n         JNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(6),=CL6'String'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_14,BIT3\n         JNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(8),=CL8'Subtract'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_14,BIT4\n         JNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(8),=CL8'Unstring'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_14,BIT7\n         JNO   *+8\n         MVI   RECORD+100,C'Y'\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(3),=CL3'Use'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_15,BIT0\n         JNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(5),=CL5'Write'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_15,BIT1\n         JNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(8),=CL8'Continue'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_15,BIT2\n         JNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(7),=CL7'End-Add'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_15,BIT3\n         JNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(8),=CL8'End-Call'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_15,BIT4\n         JNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(11),=CL11'End-Compute'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_15,BIT5\n         JNO   *+8\n         MVI   RECORD+100,C'Y'\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(10),=CL10'End-Delete'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_15,BIT6\n         JNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(10),=CL10'End-Divide'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_15,BIT7\n         JNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(12),=CL12'End-Evaluate'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_16,BIT0\n         JNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(6),=CL6'End-If'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_16,BIT1\n         JNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(12),=CL12'End-Multiply'                 RS1007\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_16,BIT2\n         JNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(8),=CL8'End-Read'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_16,BIT3\n         JNO   *+8\n         MVI   RECORD+100,C'Y'\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(10),=CL10'End-Return'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_16,BIT4\n         JNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(11),=CL11'End-Rewrite'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_16,BIT5\n         JNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(10),=CL10'End-Search'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_16,BIT6\n         JNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(9),=CL9'End-Start'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_16,BIT7\n         JNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(10),=CL10'End-String'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_17,BIT0\n         JNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(12),=CL12'End-Subtract'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_17,BIT1\n         JNO   *+8\n         MVI   RECORD+100,C'Y'\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(12),=CL12'End-Unstring'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_17,BIT2\n         JNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(9),=CL9'End-Write'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_17,BIT3\n         JNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(6),=CL6'Goback'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_17,BIT4\n         JNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(9),=CL9'Evaluate'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_17,BIT5\n         JNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(7),=CL7'Service'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_17,BIT7\n         JNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(10),=CL10'End-Invoke'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_18,BIT0\n         JNO   *+8\n         MVI   RECORD+100,C'Y'\n         BRAS  R14,SPACE1\n         CLI   LE_SWITCH,C'1'   COBOL/370\n         JNE   LE_370_125\n         CLC   LE_VERS(4),=C'0301'  Vers+Rel < 0301 COBOL V3R1\n         JL    LE_370_125            yes\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(4),=CL4'Exec'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_11,BIT5\n         JNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(8),=CL8'End-Exec'                       RS0705\n         MVI   RECORD+32,C'N'                                    RS0705\n         TM    LE_STATUS_BYTE_18,BIT1                            RS0705\n         JNO   *+8                                               RS0705\n         MVI   RECORD+32,C'Y'                                    RS0705\n         MVC   RECORD+35(3),=CL3'XML'                            RS0705\n         MVI   RECORD+49,C'N'                                    RS0705\n         TM    LE_STATUS_BYTE_18,BIT2                            RS0705\n         JNO   *+8                                               RS0705\n         MVI   RECORD+49,C'Y'                                    RS0705\n         MVC   RECORD+52(7),=CL7'End-XML'                        RS0705\n         MVI   RECORD+66,C'N'                                    RS0705\n         TM    LE_STATUS_BYTE_18,BIT3                            RS0705\n         JNO   *+8                                               RS0705\n         MVI   RECORD+66,C'Y'                                    RS0705\n         CLC   LE_VERS(4),=C'0600'  Vers+Rel < 0602 COBOL V6R2   RS1118\n         JL    LE_370_120            yes                         RS1118\n         MVC   RECORD+69(9),=CL9'Allocate'                       RS1118\n         MVI   RECORD+83,C'N'                                    RS1118\n         TM    LE_STATUS_BYTE_18,BIT4                            RS1118\n         JNO   *+8                                               RS1118\n         MVI   RECORD+83,C'Y'                                    RS1118\n         MVC   RECORD+86(4),=CL4'Free'                           RS1118\n         MVI   RECORD+100,C'N'                                   RS1118\n         TM    LE_STATUS_BYTE_18,BIT5                            RS1118\n         JNO   *+8                                               RS1118\n         MVI   RECORD+100,C'Y'                                   RS1118\n         BRAS  R14,SPACE1                                        RS1118\n         MVC   RECORD,BLANKS                                     RS1118\n         MVC   RECORD+1(4),=CL4'Json'                            RS1118\n         MVI   RECORD+15,C'N'                                    RS1118\n         TM    LE_STATUS_BYTE_18,BIT6                            RS1118\n         JNO   *+8                                               RS1118\n         MVI   RECORD+15,C'Y'                                    RS1118\n         MVC   RECORD+18(8),=CL8'End-Json'                       RS1118\n         MVI   RECORD+32,C'N'                                    RS1118\n         TM    LE_STATUS_BYTE_18,BIT7                            RS1118\n         JNO   *+8                                               RS1118\n         MVI   RECORD+32,C'Y'                                    RS1118\nLE_370_120 DS 0H                                                 RS1118\n         BRAS  R14,SPACE1\nLE_370_125 DS 0H\n         STRING64 '- - - - - - - - - - - - - - - - - - - - - - - ', *CSX\n               '- - - - - - - - - - - - - - - - - - - - - - - - - - -',X\n               ' -',                                                   X\n               INTO=RECORD                                       RS1007\n         BRAS  R14,SPACE2\n         STRING64 'No hexadecimal literals',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT0\n         JNO   LE_370_128\n         STRING64 'Procedure include hexadecimal literals',INTO=RECORD\nLE_370_128 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No altered GO TO',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT1\n         JNO   LE_370_129\n         STRING64 'Program contains altered GO TO',INTO=RECORD\nLE_370_129 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','I/O error declarative',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT2\n         JNO   LE_370_130\n         STRING64 'I/O error declarative',INTO=RECORD\nLE_370_130 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Label declarative',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT3\n         JNO   LE_370_131\n         STRING64 'Label declarative',INTO=RECORD\nLE_370_131 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Debugging declarative',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT4\n         JNO   LE_370_132\n         STRING64 'Debugging declarative',INTO=RECORD\nLE_370_132 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Program segmentation',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT5\n         JNO   LE_370_133\n         STRING64 'Program segmentation',INTO=RECORD\nLE_370_133 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Open Extend',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT6\n         JNO   LE_370_134\n         STRING64 'Open Extend',INTO=RECORD\nLE_370_134 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Exit Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT7\n         JNO   LE_370_135\n         STRING64 'Exit Program',INTO=RECORD\nLE_370_135 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No call literal',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT0\n         JNO   LE_370_136\n         STRING64 'Call literal (static?), see options',INTO=RECORD\nLE_370_136 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Call identifier',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT1\n         JNO   LE_370_137\n         STRING64 'Call identifier',INTO=RECORD\nLE_370_137 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Call on overflow',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT2\n         JNO   LE_370_138\n         STRING64 'Call on overflow',INTO=RECORD\nLE_370_138 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Call length of',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT3\n         JNO   LE_370_139\n         STRING64 'Call length of',INTO=RECORD\nLE_370_139 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Call address of',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT4\n         JNO   LE_370_140\n         STRING64 'Call address of',INTO=RECORD\nLE_370_140 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Close reel/unit',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT5\n         JNO   LE_370_141\n         STRING64 'Close reel/unit',INTO=RECORD\nLE_370_141 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Exponentiation used',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT6\n         JNO   LE_370_142\n         STRING64 'Exponentiation used',INTO=RECORD\nLE_370_142 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Floating point items used',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT7\n         JNO   LE_370_143\n         STRING64 'Floating point items used',INTO=RECORD\nLE_370_143 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Copy-Statements',INTO=RECORD\n         TM    LE_STATUS_BYTE_23,BIT0\n         JNO   LE_370_144\n         STRING64 'Copy-Statements',INTO=RECORD\nLE_370_144 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Basis-Statements',INTO=RECORD\n         TM    LE_STATUS_BYTE_23,BIT1\n         JNO   LE_370_145\n         STRING64 'Basis-Statements',INTO=RECORD\nLE_370_145 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','DBCS-Name in Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_23,BIT2\n         JNO   LE_370_146\n         STRING64 'DBCS-Name in Program',INTO=RECORD\nLE_370_146 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Shift-In/Shift-Out',INTO=RECORD\n         TM    LE_STATUS_BYTE_23,BIT3\n         JNO   LE_370_146_1                                      RS0620\n         STRING64 'Shift-In/Shift-Out',INTO=RECORD\nLE_370_146_1 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','DBCS literal',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT0\n         JNO   LE_370_148\n         STRING64 'DBCS literal',INTO=RECORD\nLE_370_148 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Replace-Statements',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT1\n         JNO   LE_370_149\n         STRING64 'Replace-Statements',INTO=RECORD\nLE_370_149 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Reference modification was used',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT2\n         JNO   LE_370_150\n         STRING64 'Reference modification was used',INTO=RECORD\nLE_370_150 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Nested Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT3\n         JNO   LE_370_151\n         STRING64 'Nested Program',INTO=RECORD\nLE_370_151 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','INITIAL Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT4\n         JNO   LE_370_152\n         STRING64 'INITIAL Program',INTO=RECORD\nLE_370_152 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','COMMON Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT5\n         JNO   LE_370_153\n         STRING64 'COMMON Program',INTO=RECORD\nLE_370_153 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Select Optional Files',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT6\n         JNO   LE_370_154\n         STRING64 'Select Optional Files',INTO=RECORD\nLE_370_154 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','External Files',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT7\n         JNO   LE_370_155\n         STRING64 'External Files',INTO=RECORD\nLE_370_155 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Global Files',INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT0\n         JNO   LE_370_156\n         STRING64 'Global Files',INTO=RECORD\nLE_370_156 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Record is varying clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT1\n         JNO   LE_370_157\n         STRING64 'Record is varying clause',INTO=RECORD\nLE_370_157 DS 0H\n         BRAS  R14,SPACE1\n         CLC   LE_VERS(4),=C'0400'  Vers+Rel > 0400 E.Cob V4.1   RS1015\n         JH    LE_370_157_1          yes                         RS1015\n         STRING64 'No ','Accept',' from ','SYSIPT',                    X\n               ' used in Label Declarative',                           X\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT2\n         JNO   LE_370_158\n         STRING64 'Accept',' from ','SYSIPT',                          X\n               ' used in Label Declarative',                           X\n               INTO=RECORD\n         J     LE_370_158\nLE_370_157_1 DS 0H                          Enterprise Cobol\n         STRING64 'No ','Volatile',                                    X\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT2\n         JNO   LE_370_158\n         STRING64 'Volatile',                                          X\n               INTO=RECORD\nLE_370_158 DS 0H\n         BRAS  R14,SPACE1\n         CLC   LE_VERS(4),=C'0400'  Vers+Rel > 0400 E.Cob V4.1   RS1015\n         JH    LE_370_160_#1         yes                         RS1015\n         STRING64 'No ','Display',' upon ','SYSLST',                   X\n               ' used in Label Declarative',                           X\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT3\n         JNO   LE_370_159\n         STRING64 'Display',' upon ','SYSLST',                         X\n               ' used in Label Declarative',                           X\n               INTO=RECORD\nLE_370_159 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Display',' upon ','SYSPCH',                   X\n               ' used in Label Declarative',                           X\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT4\n         JNO   LE_370_160\n         STRING64 'Display',' upon ','SYSPCH',                         X\n               ' used in Label Declarative',                           X\n               INTO=RECORD\nLE_370_160 DS 0H\n         BRAS  R14,SPACE1\nLE_370_160_#1 DS 0H\n         CLC   LE_VERS(4),=C'0603'  Vers+Rel < 0630 E.Cob V6.3\n         JL    LE_370_160_1          yes\n         STRING64 'Program use ','no ','UTF-8 data',                   X\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT3\n         JNO   LE_370_160_#2\n         STRING64 'Program use ','UTF-8 data',INTO=RECORD\nLE_370_160_#2 DS 0H\nLE_370_160_1 DS 0H\n         BRAS  R14,SPACE1\n         CLC   LE_VERS(4),=C'0400'  Vers+Rel > 0400 E.Cob V4.1   RS1015\n         JL    LE_370_161_2          no                          RS1015\n         STRING64 'No ','Z-literal found',INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT5\n         JNO   LE_370_160_2\n         STRING64 'Z-literal found',INTO=RECORD\nLE_370_160_2 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Recursive',INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT5\n         JNO   LE_370_161\n         STRING64 'Recursive',INTO=RECORD\nLE_370_161 DS 0H\n         BRAS  R14,SPACE1\nLE_370_161_2 DS 0H\n         CLI   LE_SWITCH,C'1'   COBOL/370\n         JNE   LE_370_177\n         CLC   LE_VERS(4),=C'0301'  Vers+Rel < 0301 COBOL V3R1\n         JL    LE_370_177            yes\n         STRING64 'No ','Function Random was used',INTO=RECORD\n         TM    LE_STATUS_BYTE_29,BIT1\n         JNO   LE_370_162\n         STRING64 'Function Random was used',INTO=RECORD\nLE_370_162 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Java-based OO syntax was used',INTO=RECORD\n         TM    LE_STATUS_BYTE_29,BIT0\n         JNO   LE_370_163\n         STRING64 'Java-based OO syntax was used',INTO=RECORD\nLE_370_163 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','National data was used',INTO=RECORD\n         TM    LE_STATUS_BYTE_29,BIT2\n         JNO   LE_370_164                                        RS1015\n         STRING64 'National data was used',INTO=RECORD\nLE_370_164 DS 0H                                                 RS1015\n         BRAS  R14,SPACE1                                        RS1015\n         STRING64 'No ','XML PARSE with schema validation',INTO=RECORD\n         TM    LE_STATUS_BYTE_29,BIT2                            RS1015\n         JNO   LE_370_177                                        RS1015\n         STRING64 'XML PARSE with schema validation',INTO=RECORD RS1015\nLE_370_177 DS 0H\n         BRAS  R14,SPACE2\n*>--moved start -------------------------------------------------HP1107\n         ICM   R8,B'1111',LE_TGT_FIB_PTR                         PF0420\n         JZ    LE_FCB_END        no FIB, leave                   PF0420\n         USING COBOL_FIB_DSECT,R8                                RS1007\n         ICM   R9,B'1111',LE_TGT_NO_FCB  for the loop            RS1007\n         JZ    LE_FCB_END        no entry leave                  RS1007\n         TM    LE_STATUS_BYTE_03,BIT1 RENT?                      RS1107\n         JO    LE_FCB_RENT                                       RS1107\n         L     R8,LE_TGT_PTR_FCB_CELL Point to FCB-Cells         RS1107\n         ST    R8,SAVE_CUR_FCB_CELL   Keep it for later\n         L     R8,0(R8)               First FCB\n         L     R8,164(R8)             First FIB\nLE_FCB_RENT DS 0H                                                RS1007\n         STRING64 '------------ FCB-Analysis ------------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD                                       RS1007\n         BRAS  R14,SPACE2                                        RS1007\n         STRING64 'DDName   RecFM Acc  DSOrg       RecL      Blk   RM',X\n               INTO=RECORD                                       RS1207\n         BRAS  R14,SPACE1                                        RS1007\n*loop                                                            RS1007\nLE_FCB_01  DS 0H                                                 RS1007\n         CLC   COBOL_FIB_EYEC,=C'FIB'  is this a FIB ??          RS1007\n         JE    LE_FCB_02                                         RS1007\n         AHI   R8,4                    try +4                    RS1007\n         J     LE_FCB_01               loop                      RS1007\nLE_FCB_02      DS 0H                                             RS1007\n***      STRING64 (COBOL_FIB_DDN),1X,(COBOL_FIB_RECFM,,X),4X,          X\n               (COBOL_FIB_ACCESS,,X),3X,(COBOL_FIB_DSORG,,X),3X,       X\n               (COBOL_FIB_LRECL,,X),1X,(COBOL_FIB_BLK,,X),1X,          X\n               (COBOL_FIB_RM,,X),1X,(COBOL_FIB_OPEN_CLOSE,,X),1X,      X\n               (COBOL_FIB_I_O_VERB1,,X),1X,                            X\n               (COBOL_FIB_I_O_VERB2,,X),1X,                            X\n               (COBOL_FIB_BYTE18,,X),1X,(COBOL_FIB_BYTE19,,X),1X,      X\n               (COBOL_FIB_FS1,,X),1X,                                  X\n               (COBOL_FIB_FS2,,X),                                     X\n               INTO=RECORD             debugcode                 RS1007\n***      BRAS  R14,SPACE1              debugcode                 HP1107\n         STRING64 (COBOL_FIB_DDN),INTO=RECORD                    RS1007\n         BRAS  R10,LE_FCB_05                                     RS1007\n         DC    XL1'C0',CL3'U  '                                  HP1107\n         DC    XL1'98',CL3'FBS'                                  RS1007\n         DC    XL1'94',CL3'FBA'                                  RS1007\n         DC    XL1'92',CL3'FBM'                                  RS1007\n         DC    XL1'90',CL3'FB '                                  RS1007\n         DC    XL1'84',CL3'FA '                                  RS1007\n         DC    XL1'82',CL3'FM '                                  RS1007\n         DC    XL1'80',CL3'F  '                                  RS1007\n         DC    XL1'58',CL3'VBS'                                  RS1007\n         DC    XL1'54',CL3'VBA'                                  RS1007\n         DC    XL1'52',CL3'VBM'                                  RS1007\n         DC    XL1'50',CL3'VB '                                  RS1007\n         DC    XL1'44',CL3'VA '                                  RS1007\n         DC    XL1'42',CL3'VM '                                  RS1007\n         DC    XL1'40',CL3'V  '                                  RS1007\n         DC    XL1'20',CL3'U  '                                  HP1107\n         DC    XL1'00',CL3'???'                 end of table     RS1007\n*  loop                                                          RS1007\nLE_FCB_05      DS 0H                                             RS1007\n         CLC   COBOL_FIB_RECFM,0(R10)          check             RS1007\n         JE    LE_FCB_06               jump if on                RS1007\n         LA    R10,4(,R10)             Skip entry                RS1007\n         CLI   0(R10),0                end of table?             RS1007\n         JNE   LE_FCB_05               not yet, loop             RS1007\n*  endloop                                                       RS1007\nLE_FCB_06      DS 0H                                             RS1007\n         MVC   RECORD+9(3),1(R10)      long text for RECFM       RS1007\n         BRAS  R10,LE_FCB_10                                     RS1007\n         DC    XL1'80',CL3'SEQ'                                  RS1007\n         DC    XL1'40',CL3'RAN'                                  RS1007\n         DC    XL1'20',CL3'DYN'                                  RS1007\n         DC    XL1'10',CL3'SPA'                                  RS1107\n         DC    XL1'00',CL3'???'                 end of table     RS1007\n*  loop                                                          RS1007\nLE_FCB_10      DS 0H                                             RS1007\n         CLC   COBOL_FIB_ACCESS,0(R10)         check             RS1007\n         JE    LE_FCB_11               jump if on                RS1007\n         LA    R10,4(,R10)             Skip entry                RS1007\n         CLI   0(R10),0                end of table?             RS1007\n         JNE   LE_FCB_10               not yet, loop             RS1007\n*  endloop                                                       RS1007\nLE_FCB_11      DS 0H                                             RS1007\n         MVC   RECORD+15(3),1(R10)     long text for Access      RS1007\n         BRAS  R10,LE_FCB_15                                     RS1007\n         DC    XL1'88',CL4'ESDS'                                 RS1007\n         DC    XL1'84',CL4'PS  '                                 RS1007\n         DC    XL1'80',CL4'PS  '                                 RS1007\n         DC    XL1'48',CL4'KSDS'                                 RS1007\n         DC    XL1'40',CL4'KSDS'                                 RS1007\n         DC    XL1'28',CL4'RRDS'                                 RS1007\n         DC    XL1'20',CL4'RRDS'                                 RS1007\n         DC    XL1'10',CL4'LSEQ'                                 HP1107\n         DC    XL1'00',CL4'??? '                end of table     RS1007\n*  loop                                                          RS1007\nLE_FCB_15      DS 0H                                             RS1007\n         CLC   COBOL_FIB_DSORG,0(R10)          check             RS1007\n         JE    LE_FCB_16               jump if on                RS1007\n         LA    R10,5(,R10)             Skip entry                RS1007\n         CLI   0(R10),0                end of table?             RS1007\n         JNE   LE_FCB_15               not yet, loop             RS1007\n*  endloop                                                       RS1007\nLE_FCB_16      DS 0H                                             RS1007\n         MVC   RECORD+20(4),1(R10)     long text for DSORG       RS1007\n         STRING64 (RECORD,26),1X,                                      X\n               (COBOL_FIB_LRECL,F,R9B),1X,(COBOL_FIB_BLK,F,R9B),       X\n               INTO=RECORD                                       RS1007\n         BRAS  R10,LE_FCB_20                                     RS1007\n         DC    XL1'80',CL2'F '                                   RS1007\n         DC    XL1'40',CL2'V '                                   RS1007\n         DC    XL1'20',CL2'U '                                   RS1007\n         DC    XL1'10',CL2'D '                                   RS1007\n         DC    XL1'00',CL4'??? '                end of table     RS1007\n*  loop\nLE_FCB_20      DS 0H                                             RS1007\n         CLC   COBOL_FIB_RM,0(R10)\n         JE    LE_FCB_21               jump if on                RS1007\n         LA    R10,3(,R10)             Skip entry                RS1007\n         CLI   0(R10),0                end of table?             RS1007\n         JNE   LE_FCB_20               not yet, loop             RS1007\n*  endloop\nLE_FCB_21      DS 0H                                             RS1007\n         MVC   RECORD+48(2),1(R10)     text for recording mode   HP1107\n         LA    R3,RECORD+51            R3 for #STATUS            HP1107\n        #STATUS COBOL_FIB_OPEN_CLOSE,BIT0,'Input'                RS1007\n        #STATUS COBOL_FIB_OPEN_CLOSE,BIT1,'Output'               RS1007\n        #STATUS COBOL_FIB_OPEN_CLOSE,BIT2,'IO'                   RS1007\n        #STATUS COBOL_FIB_OPEN_CLOSE,BIT3,'Extent'               RS1007\n        #STATUS COBOL_FIB_OPEN_CLOSE,BIT4,'Reverse'              RS1007\n        #STATUS COBOL_FIB_OPEN_CLOSE,BIT5,'Norewind'             RS1007\n        #STATUS COBOL_FIB_OPEN_CLOSE,BIT6,'Close'                RS1007\n        #STATUS COBOL_FIB_OPEN_CLOSE,BIT7,'Close-R'              RS1007\n        #STATUS COBOL_FIB_I_O_VERB1,BIT4,'Read-IO'               RS1007\n        #STATUS COBOL_FIB_I_O_VERB1,BIT2+BIT3+BIT5,'Write-IO'    RS1007\n        #STATUS COBOL_FIB_I_O_VERB1,BIT6,'Rewrite-IO'            RS1007\n        #STATUS COBOL_FIB_I_O_VERB1,BIT7,'Start-IO'              RS1007\n        #STATUS COBOL_FIB_I_O_VERB2,BIT0,'Delete-IO'             RS1007\n        #STATUS COBOL_FIB_I_O_VERB2,BIT1,'Sort-IO-G'             RS1007\n        #STATUS COBOL_FIB_I_O_VERB2,BIT2,'Sort-IO-U'             RS1007\n         MVC   0(2,R3),=C'E '                                    RS1007\n        #STATUS COBOL_FIB_BYTE18,BIT4,'L'                        RS1007\n         BRASL R14,SPACE1                                        RS1007\n         CHI   R9,1                   Last entry?                RS1107\n         JE    LE_FCB_97              jump around RENT           RS1107\n         TM    LE_STATUS_BYTE_03,BIT1 RENT?                      RS1107\n         JO    LE_FCB_95                yes                      RS1107\n         L     R8,SAVE_CUR_FCB_CELL   Restore last FCB-CELL\n         AHI   R8,4                   Next FCB-CELL\n         ST    R8,SAVE_CUR_FCB_CELL   Keep it for later\n         L     R8,0(R8)               Next FCB\n         L     R8,164(R8)             Next FIB\n         J     LE_FCB_97              jump around RENT           RS1107\nLE_FCB_95 DS 0H\n*              Was 160(R8), but COBOL/2 V1 M2 R0 is only 128...  PF0608\n         LA    R8,128(R8)              next entry                PF0608\nLE_FCB_97 DS 0H\n         BRCT  R9,LE_FCB_01            loop                      RS1007\n*  endloop                                                       RS1007\nLE_FCB_END DS 0H                                                 RS1007\n         BRAS  R14,BLANK1                                        RS1107\n         STRING64 '------------ End  --------------------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD\n         BRAS  R14,SPACE2\n*>--moved end ---------------------------------------------------HP1107\n*>---------------------------------------------------------------HP1107\n*>-      check for submodul-analysis                             HP1107\n*>---------------------------------------------------------------HP1107\n         CLI   csect_analyze_kz,C'M'  first csect (main-ep)      HP1107\n         je    BINDER_Anf             yes, skip csect-info       HP1107\n         CLI   csect_analyze_kz,C'S'  any more csects ?          HP1107\n         je    COBANAL_Csect_Loop                                HP1107\n         mvc   PGMNAME_GET,PGMNAME_sav                           HP1107\n         MVI   PRINT_LEAD_SPACE,C'N' Insert space                HP1107\n         J     COBANAL_EXIT           main-loop                  HP1107\nBINDER_Anf  DS    0H                                             HP1107\n*>---------------------------------------------------------------HP1107\n         BRAS  R14,BINDER_INFO\n         BRAS  R14,CEEUOPT_INFO\nCICS     DS    0H\n         STRING64 '------------ CICS (contains also included Csects) ',X\n               '---------------------------------------------------',  X\n               INTO=RECORD\n         BRAS  R14,SPACE2\n         CLC   CSV_OUTXTLST_ENTRR,=F'1' only one extent ??       RS0704\n         JNH   LE_CICS                                           RS0704\n         STRING64 'This module was loaded into more then one extent,', X\n               ' perhaps it is a DLL with different RMODE',INTO=RECORD\n         BRAS  R14,SPACE1                                        RS0704\n         STRING64 'CobAnal analyze the first extent only|||',          X\n               INTO=RECORD\n         BRAS  R14,SPACE1                                        RS0704\nLE_CICS  DS    0H\n         L     R5,CSV_OUTXTLST_ELP1  Start of data to be searchedRS0704\n*        STRING64 4X,(00(R5),4,X),1X,(04(R5),4,X),1X,(08(R5),4,X),1X,  X\n               (12(R5),4,X),3X,(00(R5),16),                            X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n         L     R4,CSV_OUTXTLST_EL1   Length of string            RS0704\n         AR    R4,R5         Points to the end of data\n         LR    R8,R4         keep it for later\n         LA    R0,C'D'       Search for 'D'\nLE_CICS_10  DS    0H\n         SRST  R4,R5         Search\n         BRC   1,LE_CICS_10  Search interrupted, continue        RS1007\n         BRC   2,LE_CICS_20  String not found                    RS1007\n         LR    R2,R8         End of string\n         SR    R2,R4         minus found at\n         CH    R2,=H'9'      at least 9 bytes ???\n         JL    LE_CICS_20    no leave\n         CLC   =C'DFHEITAB ',0(R4)\n         JE    LE_CICS_11\n         LR    R5,R4\n         LA    R5,1(,R5)     +1\n         LR    R4,R8\n         J     LE_CICS_10    Search again\nLE_CICS_11  DS    0F\n*        STRING64 'CICS Precompiler Debug2 R2=',((R2),,X),'<- ',       X\n               'R4=',((R4),,X),'<- ',                                  X\n               'R8=',((R8),,X),'<- ',                                  X\n               'VALUE=',(9(R4),3,T),'<-',                              X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n         STRING64 'COBOL2',INTO=CSCCOBOL                          *CSC*\n         STRING64 'P',(9(R4),3,T),INTO=CSCCICS                    *CSC*\n         STRING64 'CICS Precompiler Version: ',                        X\n               (9(R4),3,T),INTO=RECORD\n         CLC   CSCCOMP(11),=CL11'OS/VS/COBOL' OS/VS/Cobol ?      RS1107\n         JNE   LE_CICS_12             no, jump arounded          RS1107\n         STRING64 'n/a',INTO=CSCCOBOL Set n/a for OS/VS Cobol    RS1107\nLE_CICS_12  DS    0H                                             RS1107\n         J     LE_CICS_50    end\nLE_CICS_20  DS    0H                                             RS1207\n         L     R5,CSV_OUTXTLST_ELP1  Start of data to be searchedRS1207\n         L     R4,CSV_OUTXTLST_EL1   Length of string            RS1207\n         AR    R4,R5         Points to the end of data           RS1207\n         LR    R8,R4         keep it for later                   RS1207\n         LA    R0,C'd'       Search for 'D'                      RS1207\nLE_CICS_21  DS    0H                                             RS1207\n         SRST  R4,R5         Search                              RS1207\n         BRC   1,LE_CICS_21  Search interrupted, continue        RS1207\n         BRC   2,LE_CICS_30  String not found                    RS1207\n         LR    R2,R8         End of string Test                  RS1207\n         SR    R2,R4         minus found at                      RS1207\n         CH    R2,=H'9'      at least 9 bytes ???                RS1207\n         JL    LE_CICS_30    no leave                            RS1207\n         CLC   =C'dfheitab ',0(R4)                               RS1207\n         JE    LE_CICS_22                                        RS1207\n         LR    R5,R4                                             RS1207\n         LA    R5,1(,R5)     +1                                  RS1207\n         LR    R4,R8                                             RS1207\n         J     LE_CICS_21    Search again                        RS1207\nLE_CICS_22  DS    0F                                             RS1207\n*        STRING64 'CICS Precompiler Debug2 R2=',((R2),,X),'<- ', RS1207X\n               'R4=',((R4),,X),'<- ',                            RS1207X\n               'R8=',((R8),,X),'<- ',                            RS1207X\n               'VALUE=',(9(R4),3,T),'<-',                        RS1207X\n               INTO=RECORD                                       RS1207\n*        BRAS  R14,SPACE1          <== next line                 RS1207\n         STRING64 'COBOL2',INTO=CSCCOBOL                         RS1207\n         STRING64 'P',(9(R4),3,T),INTO=CSCCICS                   RS1207\n         STRING64 'CICS Precompiler Version: ',                  RS1207X\n               (9(R4),3,T),INTO=RECORD Columns                   RS1207\n         CLC   CSCCOMP(11),=CL11'OS/VS/COBOL' OS/VS/Cobol ?      RS1207\n         JNE   LE_CICS_29             no, jump arounded          RS1207\n         STRING64 'n/a',INTO=CSCCOBOL Set n/a for OS/VS Cobol    RS1207\nLE_CICS_29  DS    0H                                             RS1207\n         J     LE_CICS_50    end Scroll                          RS1207\nLE_CICS_30 DS 0H ===>\n*        STRING64 'CICS Precompiler Debug3 R2=',((R2),,X),'<- ',       X\n               'R4=',((R4),,X),'<- ',                                  X\n               'R8=',((R8),,X),'<- ',                                  X\n               'VALUE=',(9(R4),3,T),'<-',                              X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n         STRING64 'CICS Precompiler Version: ','n/a',INTO=RECORD\nLE_CICS_50  DS    0H\n         BRAS  R14,SPACE1\n         L     R5,CSV_OUTXTLST_ELP1  Start of data to be searchedRS0704\n         L     R4,CSV_OUTXTLST_EL1   Length of string            RS0704\n         AR    R4,R5         Points to the end of data\n         LR    R8,R4         keep it for later\n         LA    R0,C'D'       Search for 'D'\nLE_CICS_60  DS    0H\n         SRST  R4,R5         Search\n         BRC   1,LE_CICS_60  Search interrupted, continue        RS1007\n         BRC   2,LE_CICS_80  String not found                    RS1007\n         LR    R2,R8         End of string\n         SR    R2,R4         minus found at\n         CH    R2,=H'5'      at least 5 bytes ???\n         JL    LE_CICS_80    no leave\n         CLC   =C'DFHYI',0(R4)  DFHEILII\n         JE    LE_CICS_70\n         CLC   =C'DFHYC',0(R4)  DFHECI\n         JE    LE_CICS_70\n         LR    R5,R4\n         LA    R5,1(,R5)     +1\n         LR    R4,R8\n         J     LE_CICS_60    Search again\nLE_CICS_70  DS    0H\n         CLC   CSCCOBOL,=CL6'COBOL2'                              *CSC*\n         JE    LE_CICS_75                                         *CSC*\n*        Stub included but no precompiler so COBOL3 assumed\n         STRING64 'COBOL3',INTO=CSCCOBOL                          *CSC*\nLE_CICS_75  DS    0H\n         STRING64 'S',(5(R4),3,T),INTO=CSCCICS                    *CSC*\n         STRING64 'CICS Stub Version: ',                               X\n               (5(R4),3,T),INTO=RECORD\n         CLC   CSCCOMP(11),=CL11'OS/VS/COBOL' OS/VS/Cobol ?      RS1107\n         JNE   LE_CICS_76             no, jump arounded          RS1107\n         STRING64 'n/a',INTO=CSCCOBOL Set n/a for OS/VS Cobol    RS1107\nLE_CICS_76  DS    0H                                             RS1107\n         J     LE_CICS_90\nLE_CICS_80 DS 0H\n         STRING64 'CICS Stub Version: ','n/a',INTO=RECORD\nLE_CICS_90  DS    0H\n         BRAS  R14,SPACE1\n         L     R5,CSV_OUTXTLST_ELP1  Start of data to be searchedRS0704\n         L     R4,CSV_OUTXTLST_EL1   Length of string            RS0704\n         AR    R4,R5         Points to the end of data\n         LR    R8,R4         keep it for later\n         LA    R0,C'D'       Search for 'D'\nLE_CICS_100 DS    0H\n         SRST  R4,R5         Search\n         BRC   1,LE_CICS_100 Search interrupted, continue        RS1007\n         BRC   2,LE_CICS_120 String not found                    RS1007\n         LR    R2,R8         End of string\n         SR    R2,R4         minus found at\n         CH    R2,=H'8'      at least 8 bytes ???\n         JL    LE_CICS_120   no leave\n         CLC   =C'DFHXCSTB',0(R4)\n         JE    LE_CICS_110\n         LR    R5,R4\n         LA    R5,1(,R5)     +1\n         LR    R4,R8\n         J     LE_CICS_100   Search again\nLE_CICS_110 DS    0H\n         STRING64 'X',(13(R4),3,T),INTO=CSCCICS                  RS1007\n         STRING64 'CICS EXCI Version: ',                               X\n               (13(R4),3,T),INTO=RECORD\n         BRAS  R14,SPACE2                                         *CSC*\n         STRING64 'Note: This program uses the CICS EXCI ',       *CSC*X\n               'Interface.',INTO=RECORD                           *SC*X\n         J     LE_CICS_END   end\nLE_CICS_120 DS 0H\n         STRING64 'CICS EXCI Version: ','n/a',INTO=RECORD\nLE_CICS_END DS 0H\n         BRAS  R14,SPACE2\n*>---------------------------------------------------------------HP1107\n*>   any more csect's ? -> return to csect-loop                  HP1107\n         CLI   LE_SWITCH,C'3'    OS/VS COBOL ?                   RS1107\n         JE    INFO_COBOL_END      no, go ahead                  RS1107\n         CLI   csect_analyze_kz,C'S'  any more csects ?          HP1107\n         je    COBANAL_Csect_Loop                                HP1107\n*>---------------------------------------------------------------HP1107\n         MVC   PGMNAME_GET,PGMNAME_SAV                           PF0608\n         MVI   PRINT_LEAD_SPACE,C'N' Insert no space             PF0608\n         LA    R15,0\n         J     COBANAL_EXIT\nINFO_COBOL DS 0H\n         L     R4,SAVER4                                          *CSC*\n         USING COBOL_1_DSECT,R4                                   *CSC*\n         L     R5,C1_TGT_PTR     Ensure still point to COBOL1 TGT *CSC*\n*                                                                 *CSC*\n         CLI   C1_OEM_MOD_AREA,X'00' low-value ?                 RS0700\n         JE    INFO_COBOL_OEM                                    RS0700\n         STRING64 '------------ OEM Modified Area -------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD                                       RS0700\n         BRAS  R14,SPACE2                                        RS0700\n         STRING64 ' ',C1_OEM_MOD_AREA,INTO=RECORD                RS0700\n         BRAS  R14,SPACE2                                        RS0700\nINFO_COBOL_OEM DS 0H                                             RS0700\n         STRING64 '------------ Options in effect -------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD\n         BRAS  R14,SPACE2\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(8),=CL8'SYMDMP'\n         TM    C1_STATUS_BYTE_01,X'08'\n         JO    *+10\n         MVC   RECORD+1(8),=CL8'NOSYMDMP'\n         MVC   RECORD+10(6),=CL6'FLOW'\n         TM    C1_STATUS_BYTE_01,X'04'\n         JO    *+10\n         MVC   RECORD+10(6),=CL6'NOFLOW'\n         MVC   RECORD+17(7),=CL7'STATE'\n         TM    C1_STATUS_BYTE_01,X'02'\n         JO    *+10\n         MVC   RECORD+17(7),=CL7'NOSTATE'\n         MVC   RECORD+25(6),=CL6'OPT'\n         TM    C1_STATUS_BYTE_01,X'01'\n         JO    *+10\n         MVC   RECORD+25(6),=CL6'NOOPT'\n         MVC   RECORD+32(6),=CL6'TEST'\n         TM    C1_STATUS_BYTE_02,X'10'\n         JO    *+10\n         MVC   RECORD+32(6),=CL6'NOTEST'\n         MVC   RECORD+39(6),=CL6'RES'\n         TM    C1_STATUS_BYTE_03,X'80'\n         JO    *+10\n         MVC   RECORD+39(6),=CL6'NORES'\n         MVC   RECORD+46(8),=CL8'ENDJOB'\n         TM    C1_STATUS_BYTE_03,X'40'\n         JO    *+10\n         MVC   RECORD+46(8),=CL8'NOENDJOB'\n         MVC   RECORD+55(8),=CL8'OBJ370'\n         TM    C1_STATUS_BYTE_03,X'20'\n         JO    *+10\n         MVC   RECORD+55(8),=CL8'NOOBJ370'\n         MVC   RECORD+64(8),=CL8'COUNT'\n         TM    C1_STATUS_BYTE_03,X'08'\n         JO    *+10\n         MVC   RECORD+64(8),=CL8'NOCOUNT'\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(11),=CL11'READY_TRACE'                   RS0116\n         TM    C1_STATUS_BYTE_03,X'04'\n         JO    *+10\n         MVC   RECORD+1(11),=CL11'NO_TRACE'                      RS0116\n         BRAS  R14,SPACE2\n         CLI   csect_analyze_kz,C'M'  first csect (main-ep)      RS1107\n         jne   INFO_COBOL_OPT         yes, skip csect-info       RS1107\n         BRAS  R14,BINDER_INFO                                   RS1107\nINFO_COBOL_OPT DS 0H                                             RS1107\n         BRAS  R14,CEEUOPT_INFO                                  RS1107\n         J     CICS                                              RS1107\nINFO_COBOL_END DS 0H                                             RS1107\n         STRING64 '- - - - - - - - - - - - - - - - - - - - - - - ',    X\n               '- - - - - - - - - - - - - - - - - - - - - - - - - - -',X\n               ' -',                                                   X\n               INTO=RECORD                                       RS1107\n         BRAS  R14,SPACE2                                        RS1107\n         STRING64 'Sorry no more infomation for OS/VS COBOL',          X\n               INTO=RECORD\n         BRAS  R14,SPACE2                                         *CSC*\n         STRING64 'This should be considered a significant ',     *CSC*X\n               'business risk.',INTO=RECORD                       *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         STRING64 'Please SERIOUSLY consider ',                   *CSC*X\n               'upgrading this program to Enterprise COBOL V3',   *CSC*X\n               INTO=RECORD\n         BRAS  R14,SPACE1\n         STRING64 '------------ End  --------------------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD\n         BRAS  R14,SPACE2\n*>---------------------------------------------------------------HP1107\n*>   any more csect's ? -> return to csect-loop                  HP1107\n*>---------------------------------------------------------------HP1107\n         CLI   csect_analyze_kz,C'S'  any more csects ?          HP1107\n         je    COBANAL_Csect_Loop                                HP1107\n*>---------------------------------------------------------------HP1107\n         MVC   PGMNAME_GET,PGMNAME_SAV                           PF0608\n         MVI   PRINT_LEAD_SPACE,C'N' Insert no space             PF0608\n         LA    R15,0\n         J     COBANAL_EXIT\n         DROP  R4,R5\n*------------------------------------------------------------*\n* Print                                                      *\n*------------------------------------------------------------*\nBLANK1   DS 0H                                                   RS1107\n         ST    R14,SAVER14                                       RS1107\n         LA    R1,SYSPRINT         GET OUTPUT DCB ADDRESS        RS1107\n         LA    R0,BLANKS           GET OBJECT NAME ADDRESS       RS1107\n         PUT   (1),(0)             WRITE NAME TO NOTIFY DATA SET RS1107\n         L     R14,SAVER14                                       RS1107\n         BR    R14            return                             RS1107\nSPACE2   DS 0H\n         ST    R14,SAVER14\n         LA    R1,SYSPRINT         GET OUTPUT DCB ADDRESS\n         LA    R0,RECORD           GET OBJECT NAME ADDRESS\n         CLI   PRINT_LEAD_SPACE,C'Y' Insert space                HP1107\n         JNE   SPACE2_01\n         AHI   R0,-4\nSPACE2_01 DS 0H\n         PUT   (1),(0)             WRITE NAME TO NOTIFY DATA SET\n         LA    R1,SYSPRINT         GET OUTPUT DCB ADDRESS\n         LA    R0,BLANKS           GET OBJECT NAME ADDRESS\n         PUT   (1),(0)             WRITE NAME TO NOTIFY DATA SET\n         L     R14,SAVER14\n         BR    R14            return\nSPACE1   DS 0H\n         ST    R14,SAVER14\n         LA    R1,SYSPRINT         GET OUTPUT DCB ADDRESS\n         LA    R0,RECORD           GET OBJECT NAME ADDRESS\n         CLI   PRINT_LEAD_SPACE,C'Y'  Insert space               HP1107\n         JNE   SPACE1_01\n         AHI   R0,-4\nSPACE1_01 DS 0H\n         PUT   (1),(0)             WRITE NAME TO NOTIFY DATA SET\n         L     R14,SAVER14\n         BR    R14            return\n*------------------------------------------------------------*    *CSC*\n* Print SUMMARY                                              *    *CSC*\n*------------------------------------------------------------*    *CSC*\nSUMMARY2 DS 0H                                                    *CSC*\n         CLI   SUMMARYR,C'N'       Is SUMMARY DD Allocated?       *CSC*\n         BER   R14                 No, No point in writing|       *CSC*\n         ST    R14,SAVER14                                        *CSC*\n         LA    R1,SUMMARY          GET OUTPUT DCB ADDRESS         *CSC*\n         LA    R0,RECORD           GET OBJECT NAME ADDRESS        *CSC*\n         PUT   (1),(0)             WRITE NAME TO NOTIFY DATA SET  *CSC*\n         LA    R1,SUMMARY          GET OUTPUT DCB ADDRESS         *CSC*\n         LA    R0,BLANKS           GET OBJECT NAME ADDRESS        *CSC*\n         PUT   (1),(0)             WRITE NAME TO NOTIFY DATA SET  *CSC*\n         L     R14,SAVER14                                        *CSC*\n         BR    R14            return                              *CSC*\nSUMMARY1 DS 0H                                                    *CSC*\n         CLI   SUMMARYR,C'N'       Is SUMMARY DD Allocated?       *CSC*\n         BER   R14                 No, No point in writing|       *CSC*\n         ST    R14,SAVER14                                        *CSC*\n         LA    R1,SUMMARY          GET OUTPUT DCB ADDRESS         *CSC*\n         LA    R0,RECORD           GET OBJECT NAME ADDRESS        *CSC*\n         PUT   (1),(0)             WRITE NAME TO NOTIFY DATA SET  *CSC*\n         L     R14,SAVER14                                        *CSC*\n         BR    R14            return                              *CSC*\nJUSTDATA_PUT EQU *                                                =CMS=\n         CLI   JUSTDATA_R,C'N'     Is JUSTDATA DD Allocated?      =CMS=\n         BER   R14                 No, No point in writing]       =CMS=\n         MVC   JUSTDATA_DSN,CSCDSN                                =CMS=\n         ST    R14,SAVER14                                        =CMS=\n         LA    R1,JUSTDATA         GET OUTPUT DCB ADDRESS         =CMS=\n         LA    R0,JUSTDATA_        GET OBJECT NAME ADDRESS        =CMS=\n         PUT   (1),(0)             WRITE NAME TO NOTIFY DATA SET  =CMS=\n         L     R14,SAVER14                                        =CMS=\n         BR    R14            return                              =CMS=\n***************************************************************\n*\n*                  get Member Name from PDS-Directory\n*\n***************************************************************\nGETMEM   DS    0H                                                PF0608\n         ST    R14,GETMSAVE            save return address\n         L     R4,ADBLKPTR             restore pointer\n         CLC   DIRAREA(2),=XL2'0000'   Directory present?\n         JNE   NEWNAME                   yes, get next\nNEWBLOCK DS    0H                                                PF0608\n         GET   INPUT,DIRAREA           get a new directory\n         LA    R4,DIRAREA              get work area address\n         AH    R4,DIRAREA              + length\n         ST    R4,ADBLKEND             save ending address\n         LA    R4,DIRAREA+2            Skip LL bytes\n         ST    R4,ADBLKPTR             save pointer\nNEWNAME  DS    0H                                                PF0608\n         C     R4,ADBLKEND             end of current dir block\n         JNL   NEWBLOCK                  yes, get new block\n         MVC   PGMNAME_GET,0(R4)       Save member-name\n         IC    R5,11(R4)               LOOK FOR ANY USER TTRN'S\n         SLL   R5,27                   SHIFT OFF UNWANTED BITS\n         SRL   R5,26                   SHIFT BACK THE USABLE BITS\n         LA    R4,12(R4,R5)            ADD DISPL TO GET OVER TT\n         ST    R4,ADBLKPTR             save Pointer next mem\n         L     R14,GETMSAVE            restore return address\n         BR    R14                     goback\n*---------------------------------------------------------------------*\n*        move status flags                                            *\n*---------------------------------------------------------------------*\n$$STATUS LA    R15,0                   do not change CC          RS1007\n         IC    R15,0(,R14)             get length                RS1007\n         JZ    $$STATUS8               flag off, goback          RS1007\n         EX    R15,MOVE_$STATUS        move status flags         PF0708\n*        EX    R15,=S(X'200'(R13),0(R3),1(R14)) MVC 0(*-*,R3),1(R14)007\n         LA    R3,2(R15,R3)            bump pointer up           RS1007\n$$STATUS8 LA   R14,2(R15,R14)          return address            RS1007\n         CLI   0(R14),0                alignment byte?           RS1007\n         BNER  R14                     no, goback                RS1007\n         B     1(,R14)                 yes, skip it              RS1007\nCOBANAL_END    DS  0D\n*>---------------------------------------------------------------HP1107\n*>   additional csect-analysis for sub-module                    HP1107\n*>---------------------------------------------------------------HP1107\nCOBANAL_Csect_Loop DS 0H                                         HP1107\n         lh    R3,csect_anz_tabelem                              HP1107\n         ch    r3,=h'0'             any more csects ?            HP1107\n         Je    COBANAL_EXIT         no, leave                    HP1107\n*>avoid s0c4 within program-objects                              HP1107\n*>unknown, how to see, what's the associated CSV_OUTXTLST_ELPx   HP1107\n         CLC   CSV_OUTXTLST_ENTRR,=F'1' only one extent ??       HP1107\n         JNH   COBANAL_Csect_Check0A                             HP1107\n*>just for test ]                                                HP1107\n*        CLC   CSV_OUTXTLST_ENTRR,=F'2' p.o. with 2 extends ?    RS0108\n*        JNE   COBANAL_Csect_Check0B                             RS0108\n*        mvc   CSV_LOADPT,CSV_OUTXTLST_ELP2                      RS0108\n*        J     COBANAL_Csect_Check0A                             HP1107\nCOBANAL_Csect_Check0B   DS 0H                                    HP1107\n         STRING64 'This module was loaded into more then one extent,', X\n               ' sub-module analysis aborted',                   PF0608X\n               INTO=RECORD                                       PF0608\n         BRAS  R14,SPACE1                                        HP1107\n         J     COBANAL_EXIT         do some more research ?]     HP1107\nCOBANAL_Csect_Check0A   DS 0H                                    HP1107\n         BCTR  R3,0                                              HP1107\n         sth   R3,csect_anz_tabelem                              HP1107\n         ch    r3,=h'0'             last csect        ?          HP1107\n         Jne   COBANAL_Csect_Check0                              HP1107\n         MVI   csect_analyze_kz,C'L'                             HP1107\nCOBANAL_Csect_Check0    DS 0H                                    HP1107\n         l     R3,csect_tabelem_act csect-elem                   HP1107\n         USING CSECT_ENTRY,R3                                    PF0420\n         la    R4,L'CSECT_ENTRY(,R3)                             PF0420\n         st    R4,csect_tabelem_act next-entry                   HP1107\n         ICM   R4,B'1111',CE_OFF    csect-offset                 PF0420\n         l     r1,CSV_LOADPT        load-point  lmod             HP1107\n         ar    r4,r1                csect-postion in lmod        HP1107\n         st    r4,csect_anf         csect-postion in lmod        HP1107\n         l     r1,ADR_PGMNAME       ep                           PF0420\n         cr    r4,r1                                             HP1107\n         je    COBANAL_Csect_Loop   main-csect  ]                HP1107\nCOBANAL_Csect_Check4    DS 0H                                    RS0316\n         clc   CE_TYPE,=C'C5'       Enterprise Cobol V5          PF0420\n         jne   COBANAL_Csect_Check3                              RS0316\n         J     ENTCOBOLV5                                        RS0316\nCOBANAL_Csect_Check3    DS 0H                                    HP1107\n         clc   CE_TYPE,=C'C1'       cobol/370 ff                 PF0420\n         jne   COBANAL_Csect_Check2                              HP1107\n         J     COBOL_370                                         HP1107\nCOBANAL_Csect_Check2    DS 0H                                    HP1107\n         clc   CE_TYPE,=C'C2'       cobol2                       PF0420\n         jne   COBANAL_Csect_Check1                              HP1107\n         J     COBOL_2                                           HP1107\nCOBANAL_Csect_Check1    DS 0H                                    HP1107\n         clc   CE_TYPE,=C'C3'       osvs                         PF0420\n         jne   COBANAL_Csect_Loop   no cobol-csect               HP1107\n         J     COBOL_1                                           HP1107\n         DROP  R3                                                PF0420\n*        l     R3,saveR3                                         HP1107\n*>---------------------------------------------------------------HP1107\n*\n*---------------------------------------------------------------------*\n*        SNAP ROUTINE    R0=LENGTH,R1=ADDRESS                         *\n*---------------------------------------------------------------------*\nSNAP00   DS    0H\n         SLR   R15,R15                 offset=0000\n         STM   R14,R15,SNAPREGS+24     return address\n         STRING64 '0-3 ',(SNAPREGS+08,4,X),1X,(SNAPREGS+12,4,X),       X\n               1X,(SNAPREGS+16,4,X),1X,(SNAPREGS+20,4,X),              X\n               '  4-7 ',((R4),,X),1X,((R5),,X),                        X\n               1X,((R6),,X),1X,((R7),,X),INTO=RECORD\n         STM   R0,R1,SNAPREGS+32       Save\n         BRASL R14,SPACE1          <== next line\n         LM    R0,R1,SNAPREGS+32       Restore\n         STRING64 '8-B ',((R8),,X),1X,((R9),,X),1X,((R10),,X),         X\n               1X,((R11),,X),'  C-F ',((R12),,X),1X,((R13),,X),        X\n               1X,(SNAPREGS+00,4,X),1X,(SNAPREGS+04,4,X),INTO=RECORD\n         STM   R0,R1,SNAPREGS+32       Save\n         BRASL R14,SPACE1           <== next line\n         LM    R0,R1,SNAPREGS+32       Restore\n*LOOP\nSNAP11   L     R14,SNAPREGS+24         return address\n         LTR   R0,R0                   # OF REMAINING BYTES\n         BNPR  R14                     FINISHED, QUIT\n         STRING64 '  +',(SNAPREGS+30,2,X),1X,((R1),,X),3X,36X,'   *',  X\n               16X,'*',INTO=RECORD\n         LA    R14,16                  # of bytes on a line\n         AL    R14,SNAPREGS+28         increment offset\n         ST    R14,SNAPREGS+28         increment offset\n*\n         LA    R14,16                  # of chars on a line\n         CLR   R14,R0                  is this a short line?\n         JL    *+6                     no, jump\n         LR    R14,R0                  truncate last line\n         BCTR  R14,0                   FOR EX\n         EXRL  R14,SNAPMOVE            Excecute MOVE FIELD\n*        TR    RECORD+59(16),TRTPRINT\n*\n         LA    R2,RECORD+19            start of hex data\n         BRASL R14,SNAP33              edit 4 bytes\n         BRASL R14,SNAP33              edit 4 bytes\n         LA    R2,1(,R2)               2-byte margin\n         BRASL R14,SNAP33              edit 4 bytes\n         BRASL R14,SNAP33              edit 4 bytes\n         STM   R0,R1,SNAPREGS+32       Save\n         BRASL R14,SPACE1          <== next line\n         LM    R0,R1,SNAPREGS+32       Restore\n         J     SNAP11                  snap next line\n*ENDLOOP\n*\nSNAP33   LTR   R0,R0                   # OF REMAINING BYTES\n         BNPR  R14                     FINISHED, QUIT\n         UNPK  0(9,R2),0(5,R1)         translate to hex\n         L     R15,=A(@STRHEXT-240)    (from STRING64 macro)\n         TR    0(8,R2),0(R15)          translate to hex\n         AHI   R0,-4\n         LA    R1,4(,R1)               ptr in input area\n         MVI   8(R2),C' '\n         LA    R2,9(,R2)               ptr in output line\n         BR    R14\nSNAPMOVE MVC   RECORD+59(*-*),0(R1)    MOVE FIELD\n*------------------------------------------------------------*\n* OTHER DEFINITIONS                                          *   PF0420\n*------------------------------------------------------------*\n****************************** CONSTANTS *****************************\n*------------------------------------------------------------*   PF0420\n* CSECT Table entry                                          *   PF0420\n*------------------------------------------------------------*   PF0420\nCSECT_ENTRY    DSECT , CSECT Table entry                         PF0420\nCE_TYPE  DS    CL2     CSECT language type                       PF0420\nCE_OFF   DS    XL4     CSECT offset from entry point in storage  PF0420\nCE_LEN   DS    XL4     CSECT length in storage                   PF0420\n*\n*------------------------------------------------------------*\n* Workarea below the line                                    *\n*------------------------------------------------------------*\nCOBANAL_WORK        DSECT\nSAVEAREA            DS    36F   SaveArea for AMODE64 (144 Bytes) PF0718\nEYECATCHER          DS    CL8   'COBANAL'\n*>---------------------------------------------------------------HP1107\nCSECT_ANF           DS    F                                      HP1107\nSAVER3              DS    F                                      HP1107\nHADR                DS    F                                      HP1107\nPGMNAME_SAV         DS    CL8                                    HP1107\nCSECT_ANALYZE_KZ    DS    CL1                                    HP1107\nCSECT_ACT_KZ        DS    CL2                                    HP1107\nCSECT_TABELEM_ACT   DS    F                                      HP1107\nCSECT_ANZ_TABELEM   DS    H                                      HP1107\nCSECT_TABLE         DS    50CL10                                 HP1107\n*>---------------------------------------------------------------HP1107\nPGMNAME             DS    CL8   Pgmname from the parmlist\nPGMNAME_GET         DS    CL8   Pgmname from GETMEM\nPGMNAME_PDS2FTB2    DS    CL2   PDS2FTB2 from GETMEM             RS0316\nSAVER1              DS    F                                       *CSC*\nSAVER4              DS    F                                       *CSC*\nSAVER5              DS    F\nSAVER4_AND_R5       DS    F,F                                    RS1007\nSNAPREGS DS    AD(14,15,0,1,2,3,14,15)                           RS0207\nSAVER14             DS    F\nSAVER15             DS    F                                       *CSC*\nIRETCODE            DS    F\nRETCODE             DS    F\nRSNCODE             DS    F\nADR_COBANAL_WORK    DS    F     Save Workarea pointer\nADR_COBANAL_PARM    DS    F     Save Parmlist pointer\nADR_PGMNAME         DS    F     Save entry-point Application PGM\nADR_PIDTABLE        DS    F     A(PIDTABLE) dynamic storage      PF0718\nADR_PIDENTRY        DS    F     Save A(PIDTABLE) entry found     PF0608\nOFF_PGMNAME         DS    F     Save entry-point offset          PF0608\nCNT_R14SAVE         DS    F     Save for R14 in ADJUST_COUNTS    PF0608\nRC_PGMNAME          DS    F     Save application RC\nPARM_LENGTH         DS    H     Parm length wihout header\n                    DS    H     FILLER                           PF0608\nGETMSAVE            DS    F     Save R14 for GETM\nBINDSAVE            DS    F     Save R14 for Binder-Info\nCLASSSAVE           DS    F     Save R14 for GET_CLASS_INFO      PF0420\nCLASSSAVE2          DS    3F    Save work regs in GET_CLASS_INFO PF0420\nADBLKPTR            DS    F     Directory block ptr for PARM=ALL PF0420\nADBLKEND            DS    F     Directory block ptr for PARM=ALL PF0420\nDOALL               DS    CL1   Analyze a complete loadlib\nDD_COBANAL          DS    CL1   Switch for DD CobAnal\nDD_SYSIN            DS    CL1   Switch for DD SYSIN              RS1207\nLOADERR             DS    CL1   Switch for LOAD errors           PF0608\nFIXEDSUM            DS    CL1   Remember fixed LANG in SUMMARY   PF0608\nSETRMODE            DS    CL1   Remember already set RMODE       RS0316\n                    DS    CL2   FILLER                           PF0608\nDOUBLE              DS    D\nCSV_OUTVALID        DS    F     Length returned by CSVQuery\nCSV_OUTPID          DS    CL4   PID   returned by CSVQuery       PF0608\nCSV_OUTEPA64        DS    D     EPA64 returned by CSVQuery\nCSV_LENGTH          DS    F     Length returned by CSVQuery\nCSV_LOADPT          DS    F     Loadptr returned by CSVQuery\nCSV_EPTOKEN         DS    CL8   TOKEN returned by CSVQuery\nCSV_OUTXTLST        DS    0C\nCSV_OUTXTLST_ENTR   DS    F     Number of entries (reserved room)\nCSV_OUTXTLST_ENTRR  DS    F     Number of entries returned\nCSV_OUTXTLST_ELP1   DS    F     Extent-1 load point\nCSV_OUTXTLST_EL1    DS    F     Extent-1 Length\nCSV_OUTXTLST_ELP2   DS    F     Extent-2 load point\nCSV_OUTXTLST_EL2    DS    F     Extent-2 Length\nCSV_OUTXTLST_ELP3   DS    F     Extent-3 load point\nCSV_OUTXTLST_EL3    DS    F     Extent-3 Length\nCSV_OUTXTLST_ELP4   DS    F     Extent-4 load point\nCSV_OUTXTLST_EL4    DS    F     Extent-4 Length\nCSV_OUTXTLST_ELP5   DS    F     Extent-5 load point\nCSV_OUTXTLST_EL5    DS    F     Extent-5 Length\nCSV_OUTXTLST_ELP6   DS    F     Extent-6 load point\nCSV_OUTXTLST_EL6    DS    F     Extent-6 Length\nCSV_OUTXTLST_ELP7   DS    F     Extent-7 load point\nCSV_OUTXTLST_EL7    DS    F     Extent-7 Length\nCSV_OUTXTLST_ELP8   DS    F     Extent-8 load point\nCSV_OUTXTLST_EL8    DS    F     Extent-8 Length\nCSV_OUTXTLST_FILLER DS    CL64\nCSV_OUTATTR1        DS    C\nCSV_OUTATTR2        DS    C\nCSV_OUTATTR3        DS    C\n                    DS    C     FILLER                           PF0608\nIEW_BNLI_PTR        DS    F     Ptr of IEWBUFF area\nIEW_CLASS_BNLI_PTR  DS    F     Ptr of IEWBUFF area              PF0420\nIEW_IDLI_PTR        DS    F     Ptr of IEWBUFF area              RS1007\nIEW_ESDI_PTR        DS    F     Ptr of IEWBUFF area              RS1007\nIEW_IDUI_PTR        DS    F     Ptr of IEWBUFF area              RS1007\nIEW_IDZI_PTR        DS    F     Ptr of IEWBUFF area              RS1007\nIEW_IDBI_PTR        DS    F     Ptr of IEWBUFF area              RS1007\nIEW_DTOKEN          DS    CL8   Dialog Token for IEWBIND\nIEW_WKTOKEN         DS    CL8   Workmod Token for IEWBIND\nIEW_CURSORN         DS    F     Cursor for GETN\nIEW_CURSORD         DS    F     Cursor for GETD\nIEW_COUNTN          DS    F     Count for GETN\nIEW_COUNTD          DS    F     Count for GETD\nIEW_TCOUNT          DS    F     Total number of Sections\nIEW_COUNTN_CLASS    DS    F     Count for GETN for Classes       PF0420\nIEW_TCOUNT_CLASS    DS    F     Total number of Classes          PF0420\nIEW_MBR             DS    0H    Label for MEMBER=   for INCLUDE  PF0608\nIEW_MBRL            DS    H     Length of IEW_MBRN  for INCLUDE  PF0608\nIEW_MBRN            DS    CL8   Copy of PGMNAME_GET for INCLUDE  PF0608\nIEWBIND_FUNCTION    DS    CL8   IEWBIND Funtion for error        RS1007\nPRINT_LEAD_SPACE    DS    C     Insert space for sub-modules     RS1107\nSUM_DATE_SAVE       DS    CL7   Copy of IDL_DATE_PROCESSED       PF0608\n         CSVQUERY MF=(L,CSVQRYWK)\n         ASAXWC    MF=(L,MYLIST)\n         IEWBIND2 PLISTVER=MAX,MF=(L,IEWBIND)\n****************************** VARIABLES *****************************\nLE_SWITCH           DS    CL1   Switch for COBOL/370 or COBOL/2\nLE_PGM_NAME         DS CL8  name of program\nLE_COMP_YEAR        DS CL4  year of compilation\n*  3 bytes because of OS/VS COBOL\nLE_COMP_MONTH       DS CL3  month of compilation\nLE_COMP_DAY         DS CL2  day of compilation\nLE_COMP_HOURS       DS CL2  hours of compilation\nLE_COMP_MIN         DS CL2  minutes of compilation\nLE_COMP_SEC         DS CL2  seconds of compilation\nLE_VERS             DS CL2  version\nLE_REL              DS CL2  release\nLE_MOD              DS CL2  modification level\nLE_CCSID            DS XL2  Codepage\nLE_TGT_ADDRESS      DS A    TGT-Address (NORENT) or DAB (RENT)   RS1007\nLE_TGT_REG          DS X    80 = R13 40 ? R9                     RS1007\n                    DS CL3  Boundary                             RS1007\nLE_DAB_FIB_OFF      DS F    IDBA FIB Offset                      RS1007\nLE_TGT_FIB_PTR      DS F    FIB Pointer (RENT)                   RS1007\nLE_TGT_PTR_FCB_CELL DS F    FCB Pointer                          RS1007\nLE_TGT_NO_FCB       DS F    No of FCBs                           RS1007\nLE_TGT_WS_LENGTH    DS F    Length of working storage            RS1007\nLE_STATUS_BYTE      DS    0C   signature bytes\nLE_STATUS_BYTE_01   DS X    status byte\nLE_STATUS_BYTE_02   DS X    status byte\nLE_STATUS_BYTE_03   DS X    status byte\nLE_STATUS_BYTE_04   DS X    status byte\nLE_STATUS_BYTE_05   DS X    status byte\nLE_STATUS_BYTE_06   DS X    status byte\nLE_STATUS_BYTE_07   DS X    status byte\nLE_STATUS_BYTE_08   DS X    status byte\nLE_STATUS_BYTE_09   DS X    status byte\nLE_STATUS_BYTE_10   DS X    status byte\nLE_STATUS_BYTE_11   DS X    status byte\nLE_STATUS_BYTE_12   DS X    status byte\nLE_STATUS_BYTE_13   DS X    status byte\nLE_STATUS_BYTE_14   DS X    status byte\nLE_STATUS_BYTE_15   DS X    status byte\nLE_STATUS_BYTE_16   DS X    status byte\nLE_STATUS_BYTE_17   DS X    status byte\nLE_STATUS_BYTE_18   DS X    status byte\nLE_STATUS_BYTE_19   DS X    status byte\nLE_STATUS_BYTE_20   DS X    status byte\nLE_STATUS_BYTE_21   DS X    status byte\nLE_STATUS_BYTE_22   DS X    status byte\nLE_STATUS_BYTE_23   DS X    status byte\nLE_STATUS_BYTE_24   DS X    status byte\nLE_STATUS_BYTE_25   DS X    status byte\nLE_STATUS_BYTE_26   DS X    status byte Cobol for MVS and VM\nLE_STATUS_BYTE_27   DS X    status byte Cobol for MVS and VM\nLE_STATUS_BYTE_28   DS X    status byte Cobol V3R1\nLE_STATUS_BYTE_29   DS X    status byte Cobol V3R1\nLE_STATUS_BYTE_30   DS X    status byte E.C. V5\nLE_STATUS_BYTE_31   DS X    status byte E.C. V5\nLE_STATUS_BYTE_32   DS X    status byte E.C. V6\nLE_STATUS_BYTE_33   DS X    status byte E.C. V6\nLE_STATUS_BYTE_34   DS X    status byte E.C. V6\nLE_STATUS_BYTE_35   DS X    status byte E.C. V6\nLE_COBOL_SIGNAT     DS X    cobol signature level\nLE_DATA_STATEMENTS  DS XL4  number of data items\nLE_PROC_LINES       DS XL4  number of proc statements\nLE_YEAR_WINDOW      DS H    YearWindow\nLE_ARCHLEVEL        DS X    Architecure level\nLE_OPT_LEVEL        DS X    Optimization evel\nLE_BUILD_LEVEL      DS CL7  Build Level                          RS0316\n                    DS 0D   force alignment                      RS1118\nSYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,                      X\n               RECFM=FB,LRECL=121\nSUMMARY  DCB   DSORG=PS,MACRF=PM,DDNAME=SUMMARY,                  *CSC*X\n               RECFM=FB,LRECL=121                                 *CSC*\nJUSTDATA DCB   DSORG=PS,MACRF=PM,DDNAME=JUSTDATA,                 =CMS=X\n               RECFM=FB,LRECL=#JUSTDATA_                          =CMS=\nINPUT    DCB   DSORG=PS,DDNAME=COBANAL,MACRF=(GM),                     X\n               RECFM=U,BLKSIZE=256\nLOADL    DCB   DSORG=PO,DDNAME=COBANAL,MACRF=(R),                PF0608X\n               RECFM=U,DCBE=*-*                                  PF0608\nLOADLE   DCBE RMODE31=BUFF                                       RS0516\nSYSIN    DCB   DSORG=PS,DDNAME=SYSIN,MACRF=(GM),                 RS1207X\n               RECFM=FB,LRECL=80,DCBE=SYSINE                     RS0908\nSYSINE   DCBE RMODE31=BUFF,EODAD=COBANAL_FIN                     RS0908\n* MOVED DIRAREA TO AVOID ALIGNMENT WARNING, KEEP IT THAT WAY     PF0420\nDIRAREA             DS    XL256        PDS-Directory input area  PF0420\nJUSTDATA_R          DS CL1                                        =CMS=\nJUSTDATA_           DS 0C                                         =CMS=\nJUSTDATA_DSN        DS CL44                                       =CMS=\nJUSTDATA_MEM        DS CL8                                        =CMS=\nJUSTDATA_PGM        DS CL8                                        =CMS=\nJUSTDATA_LANG       DS CL8                                        =CMS=\nJUSTDATA_COMPILER   DS CL8                                        =CMS=\nJUSTDATA_VV         DS CL2                                        =CMS=\nJUSTDATA_RR         DS CL2                                        =CMS=\nJUSTDATA_MM         DS CL2                                        =CMS=\nJUSTDATA_LE_CYEAR   DS CL4  year of compilation                   =CMS=\nJUSTDATA_LE_CMONTH  DS CL2  month of compilation                  =CMS=\nJUSTDATA_LE_CDAY    DS CL2  day of compilation                    =CMS=\nJUSTDATA_LE_CHOURS  DS CL2  hours of compilation                  =CMS=\nJUSTDATA_LE_CMIN    DS CL2  minutes of compilation                =CMS=\nJUSTDATA_LE_CSEC    DS CL2  seconds of compilation                =CMS=\n#JUSTDATA_          EQU *-JUSTDATA_                               =CMS=\nSYSIN_DATA          DS CL80                                      RS1207\nPARMLIST            DS XL40\nJUST_SPACE          DS CL4               Please leave it here\nRECORD              DS CL132\n*                                                                 *CSC*\n* CSC WORKAREA                                                    *CSC*\nLEFOUND             DS    CL1            LE/370 module located?   *CSC*\nSUMMARYR            DS    CL1            Perform CSC Summary Func *CSC*\n*                                                                 *CSC*\nCSCDSN              DS   CL44            Dataset Name             *CSC*\n*                                                                 *CSC*\nCSCSUMM             DS   0CL122                                   *CSC*\nCSCPNAM             DS    CL9            Program Name             *CSC*\n                    DS    CL1            Filler                   *CSC*\nCSCLANG             DS    CL9            Program Language         *CSC*\n                    DS    CL1            Filler                   *CSC*\nCSCCICS             DS    CL4            CICS EI Stub level       *CSC*\n                    DS    CL1            Filler                   *CSC*\nCSCCOBOL            DS    CL6            CICS EI Stub level       *CSC*\n                    DS    CL1            Filler                   *CSC*\nCSCCOMP             DS    CL17           Compiler Details         *CSC*\n                    DS    CL1            Filler                   *CSC*\nCSCLE               DS    CL3            LE370? YES/NO            *CSC*\n                    DS    CL2            Filler                   *CSC*\nCSCD31              DS    CL2            DATA(31)? YES/NO         *CSC*\n                    DS    CL2            Filler                   *CSC*\nCSCRMODE            DS    CL3            RMODE - Compiler         *CSC*\n                    DS    CL1            Filler                   *CSC*\nCSCCRNT             DS    CL3            Compiled RENT? YES/NO    *CSC*\n                    DS    CL2            Filler                   *CSC*\nCSCRM               DS    CL3            RMODE - LINK            RS0316\n                    DS    CL1            Filler                  RS0316\nCSCAM               DS    CL3            AMODE - LINK             *CSC*\n                    DS    CL1            Filler                   *CSC*\nCSCLPRM             DS    CL25           Link Parameters          *CSC*\n                    DS    CL1            Filler                   *CSC*\nCSCDATE             DS    CL11           Comp Date yy.ddd         *CSC*\n                    DS    CL13           Filler                   *CSC*\n*                                                                 *CSC*\nCNT_ASSEMBLER       DS    PL3            Count of ASSEMBLER Progs *CSC*\nCNT_BMS             DS    PL3            Count of BMS Maps        *CSC*\nCNT_COBOL4          DS    PL3            Count of COBOL V4  ProgsPF0420\nCNT_COBOLI          DS    PL3            Count of COBOL1    Progs *CSC*\nCNT_COBOL2          DS    PL3            Count of VS/COBOL2 Progs *CSC*\nCNT_COBOLLE         DS    PL3            Count of LE COBOL  Progs *CSC*\nCNT_C370            DS    PL3            Count of C/C++     Progs *CSC*\nCNT_FORTRAN         DS    PL3            Count of FORTRAN   Progs *CSC*\nCNT_INVALID         DS    PL3            Count of Invalid   Progs *CSC*\nCNT_NOTLOAD         DS    PL3            Count of NotLoaded ProgsPF0608\nCNT_EZTRV           DS    PL3            Count of EZTrieve+ ProgsPF0708\nCNT_LEASS           DS    PL3            Count of LE Assem  Progs *CSC*\nCNT_OTHER           DS    PL3            Count of Other     Progs *CSC*\nCNT_PLI             DS    PL3            Count of PL/I      Progs *CSC*\nCNT_TOTAL           DS    PL3            Count of Total     Progs *CSC*\nCNT_UNKNOWN         DS    PL3            Count of UNKNOWN   Progs *CSC*\nTOT_ASSEMBLER       DS    CL5            Total of ASSEMBLER Progs *CSC*\nTOT_BMS             DS    CL5            Total of BMS Maps        *CSC*\nTOT_COBOL4          DS    CL5            Total of COBOL V4  ProgsPF0420\nTOT_COBOLI          DS    CL5            Total of COBOL1    Progs *CSC*\nTOT_COBOL2          DS    CL5            Total of VS/COBOL2 Progs *CSC*\nTOT_COBOLLE         DS    CL5            Total of LE COBOL  Progs *CSC*\nTOT_C370            DS    CL5            Total of C/C++     ProgsRS1107\nTOT_FORTRAN         DS    CL5            Total of FORTRAN   Progs *CSC*\nTOT_INVALID         DS    CL5            Total of Invalid   Progs *CSC*\nTOT_NOTLOAD         DS    CL5            Total of Notloaded ProgsPF0608\nTOT_EZTRV           DS    CL5            Total of EZTrieve+ ProgsPF0708\nTOT_LEASS           DS    CL5            Total of LE Assem  Progs *CSC*\nTOT_OTHER           DS    CL5            Total of Other     Progs *CSC*\nTOT_PLI             DS    CL5            Total of PL/I      Progs *CSC*\nTOT_TOTAL           DS    CL5            Total of all programs    *CSC*\nTOT_UNKNOWN         DS    CL5            Total of UNKNOWN   Progs *CSC*\nWORK                DS    D              General WORK AREA        *CSC*\nESDNAME             DS    D              ESD entry nams          PF0608\nPLINAME_AREA        DS    0D             PL/I internal name area PF0708\nPLINAME             DS    CL7            PL/I name w/leading '*' PF0708\nPLINAME_LEN         DS    X              PL/I internal name len  PF0708\nBNL_CLASS_NAME      DS    CL16           Class name (16 bytes)   PF0420\nESD_CLASS_NAME      DS    CL16           Class name (16 bytes)   PF0420\nITEMNAME            DS    CL16           Item  name (16 bytes)   PF0420\nIEW_SECT_NAME       DS    CL16           Section Name (16 bytes) PF0420\nIEW_SECT_LEN        DS    F              Section Name Length     PF0420\nSAVE_CUR_FCB_CELL   DS    F              Save current FCB-CELL   RS1107\n*                                                                 *CSC*\n*                                                                 *CSC*\nSWAWORK             DS    10F            WORK AREA                *CSC*\nSWAREQL1 SWAREQ MF=L                     WORK AREA FOR SWAREQ     *CSC*\nLOADWK   LOAD  EPLOC=,DCB=,                                      RS0908X\n               LSEARCH=,SF=L                                     RS0908\nBLDLLIST            DS    0CL100                                 RS0516\nBLDL_FF             DS    H             No of entries            RS0516\nBLDL_LL             DS    H             Length of entry          RS0516\nBLDL_NAME           DS    CL8           Name                     RS0516\nDIRTTRP             DS    CL3           TTR                      RS0516\nBLDL_CNCT DS    FL1            CONCATENATION NUMBER OF THE DATA SET\nBLDL_LIBF DS    C              LIBRARY FLAG FIELD\nBLDLLNRM EQU   X'00'          NORMAL CASE\nBLDLLLNK EQU   X'01'          IF DCB OPERAND IN BLDL MACRO INTRUCTION\n*                             WAS SPECIFIED AS ZERO, NAME WAS FOUND IN\n*                             LINK LIBRARY\nBLDLLJOB EQU   X'02'          IF DCB OPERAND IN BLDL MACRO INTRUCTION\n*                             WAS SPECIFIED AS ZERO, NAME WAS FOUND IN\n*                             JOB LIBRARY\nDIRFLAG  DS    X\nDIRALIAS EQU   X'80'          MEMBER IS AN ALIAS\nDIR2TTR  EQU   X'40'          TWO TTR'S TO UPDATE\nDIR1TTR  EQU   X'20'          ONE TTR TO UPDATE\nDIRUSER  DS    XL62\n         ORG   DIRUSER  FOLLOWING FOR LOAD MODULES\nDIRSTART DS    XL4            TTR OF FIRST TEXT BLOCK\nDIRNOTE  DS    XL3            TTR OF NOTELIST\nDIRNOTE# DS    X              NUMBER OF NOTELIST ENTRIES\nDIRATTR  DS    XL2            MEMBER ATTRIBUTES\nDIRSTORE DS    XL3            SIZE OF LOAD MODULE\nDIRTEXTL DS    XL2            LENGTH OF 1ST TEXT RECORD\nDIREPA   DS    XL3            ENTRY POINT ADDRESS\nDIRATTR2 DS    X          ADDITIONAL ATTRIBUTE BYTES:\nDIRAOSLE EQU   X'80'          VS LINKAGE EDITOR CREATED THIS MODULE\nDIR2BIG  EQU   X'40'          REQUIRES 16M OR MORE OF VIRTUAL STORAGE\nDIR2PAGA EQU   X'20'          PAGE ALIGNMENT REQUIRED FOR THIS MODULE\nDIR2SSI  EQU   X'10'          SSI INFORMATION IS PRESENT FOR MODULE\nDIRAPFLG EQU   X'08'          APF INFORMATION FOR THIS MODULE IS VALID\nDIR2LFMT EQU   X'04'          MODULE IS IN PROGRAM OBJECT FORMAT\nDIRATTR3 DS    X          ADDITIONAL ATTRIBUTE BYTES:\nDIRRMANY EQU   X'10'          RMODE=ANY\nDIRAA31  EQU   X'08'          AMODE=31 (ALIAS ENTRY)\nDIRAA64  EQU   X'04'          AMODE=64 (ALIAS ENTRY)          DRK OCT02\nDIRAA24  EQU   X'00'          AMODE=24 (ALIAS ENTRY)          DRK OCT02\nDIRAM31  EQU   X'02'          AMODE=31 (MAIN ENTRY)\nDIRAM64  EQU   X'01'          AMODE=64 (MAIN ENTRY)           DRK OCT02\nDIRAM24  EQU   X'00'          AMODE=24 (MAIN ENTRY)           DRK OCT02\nDIRATTR4 DS    X              COUNT OF RLD ENTRIES AFTER FIRST TEXT\nDIRAPF   DS    0XL2           APF (IF NOT SCAT, SSI OR ALIAS)\nDIREP    DS    XL3            ENTRY POINT (MAIN MEMBER)\nDIRREAL  DS    CL8            REAL NAME OF MEMBER\nDIRAPF2  DS    XL2            APF INFORMATION (ALIAS, NO SCAT OR SSI)\nDIREND2  DS    0X             END OF ALIAS SECTION\nIEW_SECTION         DS    0CL1049       Length (H), Name 1047    PF0608\nIEW_SECTION_LEN     DS    H             Length (H)               PF0608\nIEW_SECTION_DATA    DS    CL1047        Name 1047                PF0608\nCOBANAL_WORK_LENGTH EQU *-COBANAL_WORK  Length workarea\n*\n*------------------------------------------------------------*\n* Parameter (JCL)                                            *\n*------------------------------------------------------------*\nCOBANAL_PARM        DSECT\nCOBANAL_PARM_LENGTH DS H\n*\n*\n*------------------------------------------------------------*\n* Enterprise Cobol V5\n*------------------------------------------------------------*\nCOBOLV5_DSECT       DSECT\nCV5_Length          DS H\nCV5_CCSID           DS XL2  Codepage (COBOL V3R1 only)\nCV5_ARCHLEVEL       DS X    Architecure level\nCV5_OPT_LEVEL       DS X    Optimization evel\nCV5_STATUS_BYTE_28  DS X    status byte\nCV5_STATUS_BYTE_29  DS X    status byte\nCV5_STATUS_BYTE_30  DS X    status byte\nCV5_STATUS_BYTE_31  DS X    status byte\nCV5_STATUS_BYTE_01  DS X    status byte\nCV5_STATUS_BYTE_02  DS X    status byte\nCV5_STATUS_BYTE_03  DS X    status byte\nCV5_STATUS_BYTE_04  DS X    status byte\nCV5_STATUS_BYTE_05  DS X    status byte\nCV5_STATUS_BYTE_06  DS X    status byte\nCV5_STATUS_BYTE_07  DS X    status byte\nCV5_STATUS_BYTE_08  DS X    status byte\nCV5_STATUS_BYTE_09  DS X    status byte\nCV5_STATUS_BYTE_10  DS X    status byte\nCV5_STATUS_BYTE_11  DS X    status byte\nCV5_STATUS_BYTE_12  DS X    status byte\nCV5_STATUS_BYTE_13  DS X    status byte\nCV5_STATUS_BYTE_14  DS X    status byte\nCV5_STATUS_BYTE_15  DS X    status byte\nCV5_STATUS_BYTE_16  DS X    status byte\nCV5_STATUS_BYTE_17  DS X    status byte\nCV5_STATUS_BYTE_18  DS X    status byte\nCV5_STATUS_BYTE_19  DS X    status byte\nCV5_STATUS_BYTE_20  DS X    status byte\nCV5_STATUS_BYTE_21  DS X    status byte\nCV5_STATUS_BYTE_22  DS X    status byte\nCV5_STATUS_BYTE_23  DS X    status byte\nCV5_COBOL_SIGNAT    DS X    cobol signature level\nCV5_DATA_STATEMENTS DS XL4  number of data items\nCV5_PROC_LINES      DS XL4  number of proc statements\nCV5_STATUS_BYTE_24  DS X    status byte\nCV5_STATUS_BYTE_25  DS X    status byte\nCV5_STATUS_BYTE_26  DS X    status byte\nCV5_STATUS_BYTE_27  DS X    status byte\nCV5_BUILD_LEVEL     DS CL7  Build Level INFO                     RS0316\nCV5_STATUS_BYTE_32  DS X    status byte              V6.3        RS0620\nCV5_STATUS_BYTE_33  DS X    status byte              V6.3        RS0620\nCV5_STATUS_BYTE_34  DS X    status byte              V6.3        RS0620\nCV5_STATUS_BYTE_35  DS X    status byte              V6.3        RS0620\nCOBOLV5_COMP_INFO   DSECT\nCV5_COMP_YEAR       DS CL4  year of compilation\nCV5_COMP_MONTH      DS CL2  month of compilation\nCV5_COMP_DAY        DS CL2  day of compilation\nCV5_COMP_HOURS      DS CL2  hours of compilation\nCV5_COMP_MIN        DS CL2  minutes of compilation\nCV5_COMP_SEC        DS CL2  seconds of compilation\nCV5_VERS            DS CL2  version\nCV5_REL             DS CL2  release\nCV5_MOD             DS CL2  modification level\n*------------------------------------------------------------*\n* COBOL/370 DCL\n*------------------------------------------------------------*\nCOBOL_370_DSECT     DSECT\n                    DS CL4  bypass\nCEE_EYECATCHER      DS CL4  eyecatcher\nCEE_STACK_FRAME     DS F    stack frame size\nCEE_PPA1_OFFSET     DS F    offset to first ppa1\n                    DS CL4  reserved\nCEE_PPA1_START      DS 0C\nCEE_OFFSET          DS X    offset to length of name from ppa1\nCEE_SIGNATURE       DS X    CEL-Signature\nCEE_FLAG1           DS X    CEL-FLAGS Bitmask\nCEE_FLAG2           DS X    Member Flags for Cobol\nCEE_ADDRESS_OF_PPA2 DS F    Address of PPA2\nCEE_OFFSET_DBI      DS F    Offset BDI (None)\nCEE_EP_DESCRIPTOR   DS F    Entry Point Descriptor\nCEE_STACK_OVERFLOW  DS F    Offset for Stack overflow\n                    DS F    available word\n                    DS F    available word\n                    DS F    available word\n                    DS F    available word\nCEE_PRIMARY_EP      DS 0C\nCEE_PRI_EP_ADDRESS  DS A    primary entry-point address\nCEE_PGT_ADDRESS     DS A    PGT-Address\nCEE_TGT_ADDRESS     DS A    TGT-Address or DAB RENT/NORENT       RS1007\nCEE_EP_NAME         DS A    Offset to entry_point_name\nCEE_CURRENT_EP      DS A    current EP-Address\nCEE_START           DS A    procedure code Address\nCEE_INIT_PROG       DS A    Initialize Routine\nCEE_PARM_LIST       DS A    Address of parm list for CEEINT\nCEE_COMP_LEVEL      DS XL2  0010                                 RS1007\nCEE_TGT_REG         DS X    80 = R13 40 ? R9                     RS1007\n                    DS X                                         RS1007\n                    DS H    available half-word\nCEE_LENGTH_NAME     DS XL2  length of program_name\nCEE_NAME_PART       DS 0C\nCEE_PGM_NAME        DS CL8  name of program\nCEE_COMP_YEAR       DS CL4  year of compilation\nCEE_COMP_MONTH      DS CL2  month of compilation\nCEE_COMP_DAY        DS CL2  day of compilation\nCEE_COMP_HOURS      DS CL2  hours of compilation\nCEE_COMP_MIN        DS CL2  minutes of compilation\nCEE_COMP_SEC        DS CL2  seconds of compilation\nCEE_VERS            DS CL2  version\nCEE_REL             DS CL2  release\nCEE_MOD             DS CL2  modification level\nCEE_CCSID           DS XL2  Codepage (COBOL V3R1 only)\n                    DS H    available halfword\nCEE_STATUS_BYTE_28  DS X    status byte\nCEE_STATUS_BYTE_29  DS X    status byte\nCEE_YEAR_WINDOW     DS H    YearWindow\nCEE_STATUS_BYTE_01  DS X    status byte\nCEE_STATUS_BYTE_02  DS X    status byte\nCEE_STATUS_BYTE_03  DS X    status byte\nCEE_STATUS_BYTE_04  DS X    status byte\nCEE_STATUS_BYTE_05  DS X    status byte\nCEE_STATUS_BYTE_06  DS X    status byte\nCEE_STATUS_BYTE_07  DS X    status byte\nCEE_STATUS_BYTE_08  DS X    status byte\nCEE_STATUS_BYTE_09  DS X    status byte\nCEE_STATUS_BYTE_10  DS X    status byte\nCEE_STATUS_BYTE_11  DS X    status byte\nCEE_STATUS_BYTE_12  DS X    status byte\nCEE_STATUS_BYTE_13  DS X    status byte\nCEE_STATUS_BYTE_14  DS X    status byte\nCEE_STATUS_BYTE_15  DS X    status byte\nCEE_STATUS_BYTE_16  DS X    status byte\nCEE_STATUS_BYTE_17  DS X    status byte\nCEE_STATUS_BYTE_18  DS X    status byte\nCEE_STATUS_BYTE_19  DS X    status byte\nCEE_STATUS_BYTE_20  DS X    status byte\nCEE_STATUS_BYTE_21  DS X    status byte\nCEE_STATUS_BYTE_22  DS X    status byte\nCEE_STATUS_BYTE_23  DS X    status byte\nCEE_COBOL_SIGNAT    DS X    cobol signature level\nCEE_DATA_STATEMENTS DS XL4  number of data items\nCEE_PROC_LINES      DS XL4  number of proc statements\nCEE_STATUS_BYTE_24  DS X    status byte\nCEE_STATUS_BYTE_25  DS X    status byte\nCEE_STATUS_BYTE_26  DS X    status byte\nCEE_STATUS_BYTE_27  DS X    status byte\n*------------------------------------------------------------*\n* COBOL2 DCL\n*------------------------------------------------------------*\nCOBOL_2_DSECT      DSECT\n                   DS CL4  bypass\n                   DS X\nC2_PGM_NAME        DS CL8  name of program\nC2_EYECATCHER      DS CL4  eyecatcher\nC2_VERS            DS CL2  version\nC2_REL             DS CL2  release\nC2_MOD             DS CL2  modification level\nC2_COMP_MONTH      DS CL2  month of compilation\n                   DS CL1\nC2_COMP_DAY        DS CL2  day of compilation\n                   DS CL1\nC2_COMP_YEAR       DS CL2  year of compilation\n                   DS CL1\nC2_COMP_HOURS      DS CL2  hours of compilation\n                   DS CL1\nC2_COMP_MIN        DS CL2  minutes of compilation\n                   DS CL1\nC2_COMP_SEC        DS CL2  seconds of compilation\nC2_GET_ENTRY       DS A    Address of address\nC2_STATUS_BYTE_01  DS X    status byte\nC2_STATUS_BYTE_02  DS X    status byte\nC2_STATUS_BYTE_03  DS X    status byte\nC2_STATUS_BYTE_04  DS X    status byte\nC2_STATUS_BYTE_05  DS X    status byte\nC2_STATUS_BYTE_06  DS X    status byte\nC2_STATUS_BYTE_07  DS X    status byte\nC2_STATUS_BYTE_08  DS X    status byte\nC2_STATUS_BYTE_09  DS X    status byte\nC2_STATUS_BYTE_10  DS X    status byte\nC2_STATUS_BYTE_11  DS X    status byte\nC2_STATUS_BYTE_12  DS X    status byte\nC2_STATUS_BYTE_13  DS X    status byte\nC2_STATUS_BYTE_14  DS X    status byte\nC2_STATUS_BYTE_15  DS X    status byte\nC2_STATUS_BYTE_16  DS X    status byte\nC2_STATUS_BYTE_17  DS X    status byte\nC2_STATUS_BYTE_18  DS X    status byte\nC2_STATUS_BYTE_19  DS X    status byte\nC2_STATUS_BYTE_20  DS X    status byte\nC2_STATUS_BYTE_21  DS X    status byte\nC2_STATUS_BYTE_22  DS X    status byte\nC2_STATUS_BYTE_23  DS X    status byte\n                   DS X    cobol signature level\nC2_DATA_STATEMENTS DS XL4  number of data items\nC2_PROC_LINES      DS XL4  number of proc statements\nC2_STATUS_BYTE_24  DS X    status byte\nC2_STATUS_BYTE_25  DS X    status byte\n                   DS XL2  status byte\n                   DS CL4  status byte\nC2_PRI_EP_ADDRESS  DS A    primary entry-point address\n*\n*------------------------------------------------------------*\n* OS/VS COBOL\n*------------------------------------------------------------*\nCOBOL_1_DSECT      DSECT\n                   DS CL12 bypass\nC1_PGM_NAME        DS CL8  name of program\nC1_EYECATCHER      DS CL2  eyecatcher\nC1_REL             DS CL2  release\n                   DS CL36\nC1_TGT_PTR         DS F    pointer to tgt\n                   DS CL8  unknown                               RS0700\nC1_OEM_MOD_AREA    DS CL60 Optimizer Info orgin COBOL low-values RS0700\n                   DS CL4  unknown                               RS0700\nC1_COMP_HOURS      DS CL2  hours of compilation\n                   DS CL1\nC1_COMP_MIN        DS CL2  minutes of compilation\n                   DS CL1\nC1_COMP_SEC        DS CL2  seconds of compilation\nC1_COMP_MONTH      DS CL3  month of compilation\n                   DS CL1\nC1_COMP_DAY        DS CL2  day of compilation\n                   DS CL2\nC1_COMP_YEAR       DS CL4  year of compilation\nCOBOL_1_TGT        DSECT\n                   DS CL72 ?\nC1_STATUS_BYTE_01  DS X    status byte\nC1_STATUS_BYTE_02  DS X    status byte\nC1_STATUS_BYTE_03  DS X    status byte\n                   DS CL369\nC1_CHECK           DS CL8  check TGT for SYSOUT\n*------------------------------------------------------------*   PF0708\n* Compiled EZTRIEVE PLUS Main entry point (STINIT)               PF0708\n*------------------------------------------------------------*   PF0708\nEZTRIEVE_DSECT     DSECT ,                                       PF0708\n                   DS CL44 bypass                                PF0708\nEZ_EYECATCHER      DS CL8  eyecatcher EZTPA00                    PF0708\nEZ_TABLE_OFFSET    DS F    Offset to start of table of offsets   PF0708\nEZ_TBLEND_OFFSET   DS F    Offset to end of table (=CL4'OPTT')   PF0708\n                   DS CL4  bypass                                PF0708\nEZ_OFFSET_TABLE    DS 0CL8 Table of offsets                      PF0708\nEZ_TBL_WORD1       DS F    If =F'0' bypass                       PF0708\nEZ_TBL_WORD2       DS F    If =F'0' bypass                       PF0708\n*------------------------------------------------------------*   PF0708\n* Compiled EZTRIEVE PLUS JNLx entry point (JNLnnnnn)             PF0708\n*------------------------------------------------------------*   PF0708\nEZTRIEVE_JNL_DSECT DSECT ,                                       PF0708\nEZ_JNL_START_CODE  DS CL3  =X'47F0F0'                            PF0708\n                   DS CL1  =5+EZ_JNL_IDENT_LEN                   PF0708\nEZ_JNL_IDENT_LEN   DS XL1  eyecatcher total length               PF0708\nEZ_JNL_R4_R5       DS 0CL44 R4-R5 JNL area                       PF0708\nEZ_JNL_R4_R5_EYECT DS 0CL17 eyecatcher 'E Z T  ' etc.            PF0708\nEZ_JNL_R4_R5_CATCH DS CL7  eyecatcher 'E Z T  '                  PF0708\nEZ_JNL_R4_R5_VERSN DS CL10 eyecatcher 'PLUS ' and version        PF0708\n                   DS CL1  hyphen '-'                            PF0708\nEZ_JNL_R4_R5_TMSTP DS 0CL23 R4-R5 timestamp+JSN level            PF0708\nEZ_JNL_R4_R5_CDATE DS CL8  R4-R5 compile date                    PF0708\n                   DS CL1  hyphen '-'                            PF0708\nEZ_JNL_R4_R5_CTIME DS CL5  R4-R5 compile time                    PF0708\n                   DS CL1  hyphen '-'                            PF0708\nEZ_JNL_R4_R5_JSNID DS CL8  R4-R5 JSNnnnnn value                  PF0708\n                   ORG EZ_JNL_R4_R5                              PF0708\nEZ_JNL_R6          DS 0CL51 R6 JNL area                          PF0708\nEZ_JNL_R6_EYECT    DS 0CL27 eyecatcher 'CA-EASYTRIEVE ' etc.     PF0708\nEZ_JNL_R6_CATCH    DS CL14 eyecatcher 'CA-EASYTRIEVE '           PF0708\nEZ_JNL_R6_VERSN    DS CL13 eyecatcher 'PLUS ' and version        PF0708\n                   DS CL1  hyphen '-'                            PF0708\nEZ_JNL_R6_TMSTP    DS 0CL23 R6 timestamp+JSN level               PF0708\nEZ_JNL_R6_CDATE    DS CL8  R4-R5 compile date                    PF0708\n                   DS CL1  hyphen '-'                            PF0708\nEZ_JNL_R6_CTIME    DS CL5  R4-R5 compile time                    PF0708\n                   DS CL1  hyphen '-'                            PF0708\nEZ_JNL_R6_JSNID    DS CL8  R4-R5 JSNnnnnn value                  PF0708\n*------------------------------------------------------------*   RS1007\n* COBOL/370 DAB for RENT Cobol-Programs                          RS1007\n*------------------------------------------------------------*   RS1007\nCOBOL_DAB_DSECT     DSECT                                        RS1007\nCEE_DAB_ADR         DS F    ??                                   RS1007\n                    DS CL4                                       RS1007\nCEE_DAB_TGT         DS F    TGT - 6 Bytes ]]]                    RS1007\nCEE_DAB_EYEC        DS CL4  CL'IDBA'                             RS1007\n                    DS CL8                                       RS1007\nCEE_DAB_FIB_OFF     DS CL3  Offset to FIB from Entry-Point       RS1007\n*------------------------------------------------------------*   RS1007\n* COBOL/370 TGT                                                  RS1007\n*------------------------------------------------------------*   RS1007\nCOBOL_TGT_DSECT     DSECT                                        RS1007\n                    DS CL72 Reserved 72 Bytes                    RS1007\nCEE_TGT_IDENT       DS CL4  TGT identifier                       RS1007\n                    DS CL4  Reserved 4 Bytes                     RS1007\nCEE_TGT_LEVEL       DS X    TGT level indicator                  RS1007\n                    DS CL3  Reserved 3 Bytes                     RS1007\nCEE_TGT_32BIT_SWITCH DS F    32 bit switch                       RS1007\nCEE_TGT_PTR_RUNCOM  DS F    Pointer to RUNCOM                    RS1007\nCEE_TGT_PTR_COBVEC  DS F    Pointer to COBVEC                    RS1007\nCEE_TGT_PTR_PDBT    DS F    Pointer to Program Dynamic Block TableS1007\nCEE_TGT_NO_FCBS     DS F    Number of FCBs                       RS1007\nCEE_TGT_WS_LENGTH   DS F    Working-Storage Length               RS1007\n                    DS CL4  Reserved 4 Bytes                     RS1007\nCEE_TGT_IGZEMSG_W   DS F    Address of IGZESMG Work Ares         RS1007\nCEE_TGT_GETMAIN_B   DS F    Address of 1st Getmain Block (Space Mgr)007\n                    DS CL6  Reserved 6 Bytes                     RS1007\nCEE_TGT_MERG_FILE_NO DS H   Merge File Number                    RS1007\nCEE_TGT_CEL_CAA     DS F    Address of CEL Common Anchor Area    RS1007\nCEE_TGT_LENGTH      DS F    Length of TGT                        RS1007\n                    DS CL1  Reserved 1 Byte                      RS1007\nCEE_TGT_PGM_MASK    DS X    Program Mask used by this Program    RS1007\n                    DS CL2  Reserved 2 Bytes                     RS1007\nCEE_TGT_NO_SEC_FCBS  DS F    Number of secondary FCB Cells       RS1007\n                    DS CL128 ?? (see compile output)             RS1007\nCEE_TGT_PTR_FCB_CELL DS F   Pointer to first FCB Cell (NORENT)   RS1007\nCEE_TGT_WS_PTR      DS F    Working-Storage Address              RS1007\nCEE_TGT_PTR_FCB_SEC_CELL DS F  Pointer to first secondary FCB CellS1007\n*------------------------------------------------------------*   RS1007\n* COBOL/370 FIB                                                  RS1007\n*------------------------------------------------------------*   RS1007\nCOBOL_FIB_DSECT     DSECT                                        RS1007\nCOBOL_FIB_EYEC      DS CL3  Eyecatcher FIB                       RS1007\nCOBOL_FIB_NUM       DS CL2                                       RS1007\nCOBOL_FIB_LEVEL     DS XL1                                       RS1007\nCOBOL_FIB_DDN       DS CL8  DD-Name                              RS1007\n                    DS CL1                                       RS1007\nCOBOL_FIB_DSORG     DS CL1                                       RS1007\nCOBOL_FIB_ACCESS    DS CL1                                       RS1007\nCOBOL_FIB_RM        DS CL1                                       RS1007\nCOBOL_FIB_BYTE18    DS CL1                                       RS1007\nCOBOL_FIB_BYTE19    DS CL1                                       RS1007\n                    DS CL2                                       RS1007\nCOBOL_FIB_RECFM     DS CL1                                       RS1007\n                    DS CL1                                       RS1007\nCOBOL_FIB_BLK       DS F                                         RS1007\nCOBOL_FIB_LRECL     DS F                                         RS1007\n                    DS CL16                                      RS1007\nCOBOL_FIB_OPEN_CLOSE DS CL1                                      RS1007\nCOBOL_FIB_I_O_VERB1 DS CL1                                       RS1007\nCOBOL_FIB_I_O_VERB2 DS CL1                                       RS1007\n                    DS CL9                                       RS1007\nCOBOL_FIB_FS1       DS F                                         RS1007\nCOBOL_FIB_FS2       DS F                                         RS1007\n         DCBD    DSORG=QS\n         STRING64 GENERATE\nBIT0     EQU   B'10000000'\nBIT1     EQU   B'01000000'\nBIT2     EQU   B'00100000'\nBIT3     EQU   B'00010000'\nBIT4     EQU   B'00001000'\nBIT5     EQU   B'00000100'\nBIT6     EQU   B'00000010'\nBIT7     EQU   B'00000001'\n*------------------------------------------------------------*\n* Program equates                                            *\n*------------------------------------------------------------*\nR0       EQU   0  Scratch,Sys                                    PF0718\nR1       EQU   1  Scratch,Sys                                    PF0718\nR2       EQU   2  Scratch                                        PF0718\nR3       EQU   3  Scratch                                        PF0718\nR4       EQU   4  Scratch                                        PF0718\nR5       EQU   5  Scratch,A(Various Binder Areas) BINDER_INFO_xx PF0718\nR6       EQU   6  A(STATIC_AREA)                                 PF0718\nR7       EQU   7  A(PIDTABLE) dynamic stg during BINDER_INFO_32  PF0718\nR8       EQU   8  Scratch,various lengths during BINDER_INFO_xx  PF0718\nR9       EQU   9  Scratch,A(Current PID entry) in BINDER_INFO_32 PF0718\nR10      EQU   10 Value of IEW_COUNTD during BINDER_INFO_xx      PF0718\n*                 Scratch during LE_FCB analysis                 PF0718\nR11      EQU   11 A(STATIC_AREA+4096) 2nd STATIC_AREA base reg   PF0718\nR12      EQU   12 Value of IEW_COUNTN during BINDER_INFO_xx      PF0718\nR13      EQU   13 A(COBANAL_WORK) Dynamic storage, save area     PF0718\nR14      EQU   14 Scratch,Link,Sys                               PF0718\nR15      EQU   15 Scratch,Link,Sys,A(EZTRIEVE_JNL_DSECT)         PF0718\nCOBANAL  RSECT ,                                                 PF0718\n         USING COBANAL_WORK,R13   addressability                 PF0718\nSTATIC_AREA DS 0D\nADDINFO  DC    C'------------ Additional information    ---------------X\n               -----------------------------------------------'\nFOOTER   DC    C'======================================================X\n               ==============================================='\nMASKTOT  DC    XL6'402020202120'       Mask for totals            *CSC*\nC_COBOL370 DC X'00',C'CEE'                   COBOL/370 ?  X'00C3C5C5'\nC_OPLINK   DC X'01',C'CEE'                   C370         X'01C3C5C5'\nC_COBV5   EQU C_OPLINK                 Enterprise CobV5?  X'01C3C5C5'\n*EW_IDL DC H'5',C'B_IDL'                                         RS1007\nIEW_IDL  DC H'6',C'B_IDRL'                                       RS1007\nIEW_ESD  DC H'5',C'B_ESD'                                        RS1007\nIEW_IDU  DC H'6',C'B_IDRU'                                       RS1007\nIEW_IDZ  DC H'6',C'B_IDRZ'                                       RS1007\nIEW_IDB  DC H'6',C'B_IDRB'                                       RS1007\nIEW_DDN  DC 0H                                                   PF0608\nIEW_DDNL DC H'7'                                                 PF0608\nIEW_DDNN DC CL8'COBANAL'                                         PF0608\nO_LIST   DC    H'4',C'LIST'               Option: List           RS1007\nV_ALL    DC    H'3',C'ALL'                Value: All             RS1007\nFILELIST DS    0F                         ddname                 RS1007\n         DC    F'1'                       Number                 RS1007\n         DC    CL8'PRINT',F'8',A(PRINTX)  Type, length of ddname, addr\nPRINTX   DC    CL8'BINDEROU'              The ddname             RS1007\nOPTION_Y DC    C'Y'                                              RS1007\nOPTION_N DC    C'N'                                              RS1007\n*                                                                RS1007\nOPTLIST3 DS    0F                         Global options specs   RS1007\n         DC    F'2'                       Number of list entries RS1007\n         DC    CL8'TERM    ',F'1',A(OPTION_N)                    RS1007\n         DC    CL8'PRINT   ',F'1',A(OPTION_Y)                    RS1007\n* EXecuted moves                                                 PF0708\nMOVE_PLINAME MVC 0(0,R14),IEW_MBRN        Move name to PLINAME   PF0708\nMOVE_$STATUS MVC 0(*-*,R3),1(R14)         Move status flags      PF0708\n*OVE_PGM_NAME MVC LE_PGM_NAME(0),58(R2)      Move PGM-Name       RS0116\nMOVE_PGM_NAME MVC LE_PGM_NAME(0),0(R1)       Move PGM-Name       PF0420\nMOVE_BNL_CLASS MVC BNL_CLASS_NAME(0),0(R14) Move class name      PF0420\nMOVE_ESD_CLASS MVC ESD_CLASS_NAME(0),0(R14) Move class name      PF0420\nMOVE_ITEM_NAME MVC ITEMNAME(0),0(R14)       Move item  name      PF0420\nBLANKS   DC    CL255' '           just blanks\nC_LSTO   OPEN  (*-*,(OUTPUT)),MODE=31,MF=L\nC_LSTOL  EQU   *-C_LSTO\nC_LSTI   OPEN  (*-*,(INPUT)),MODE=31,MF=L\nC_LSTIL  EQU   *-C_LSTI\nC_CLOSE  CLOSE (*-*),MF=L\nC_CLOSEL EQU   *-C_CLOSE\nXFF      DC    XL8'FFFFFFFFFFFFFFFF' just High-value\n* Initializing DCB/DCBE's moved to separate CSECTS to make more  PF0608\n* space available in the STATIC_AREA                             PF0608\n* NAME The names of each section or class in the workmod, a      PF0608\n*      count of the total number of sections or classes, and the PF0608\n*      compile unit (CU) numbers for each section.               PF0608\n         IEWBUFF FUNC=MAPBUF,TYPE=NAME,SIZE=500,                 PF0420X\n               HEADREG=8,ENTRYREG=9,VERSION=4                     *CSC*\n* NAME Second copy of NAME buffer for CLASS names                PF0420\n         IEWBUFF FUNC=MAPBUF,TYPE=NAME,SIZE=500,                 PF0420X\n               HEADREG=8,ENTRYREG=9,VERSION=4,PREFIX=CLASS       PF0420\n* IDL Language processor identification record, indicating the   PF0608\n*     compilers that created the binder input, the date of       PF0608\n*     compilation and the binder size.                           PF0608\n         IEWBUFF FUNC=MAPBUF,TYPE=IDRL,SIZE=50,                        X\n               HEADREG=8,ENTRYREG=9,VERSION=4                    RS1007\n* ESD External Symbol Dictionary, a catalog containing all       PF0608\n*     symbols that are available to the binder. These symbols    PF0608\n*     include section and class names, as well as ordinary       PF0608\n*     symbol definitions and references.                         PF0608\n         IEWBUFF FUNC=MAPBUF,TYPE=ESD,SIZE=500,                  PF0420X\n               HEADREG=8,ENTRYREG=9,VERSION=4                    RS1007\n* IDU User-specified identification record, containing data      PF0608\n*     provided on an IDENTIFY control statement.                 PF0608\n         IEWBUFF FUNC=MAPBUF,TYPE=IDRU,SIZE=50,                        X\n               HEADREG=8,ENTRYREG=9,VERSION=4                    RS1007\n* IDZ AMASPZAP identification record, for programs that have     PF0608\n*     been modified at the object level.                         PF0608\n         IEWBUFF FUNC=MAPBUF,TYPE=IDRZ,SIZE=50,                        X\n               HEADREG=8,ENTRYREG=9,VERSION=4                    RS1007\n* IDB Binder identification record, indicating the binder        PF0608\n*     version, size, and how and when the program object was     PF0608\n*     created.                                                   PF0608\n         IEWBUFF FUNC=MAPBUF,TYPE=IDRB,SIZE=50,                        X\n               HEADREG=8,ENTRYREG=9,VERSION=4                    RS1007\n         LTORG\nSTATIC_AREA_END DS 0D\n* -------------------------------------------------------------- PF0718\n* Separate CSECT for PIDTABLE data (copied to dynamic storage)   PF0718\n* -------------------------------------------------------------- PF0718\n*   Most taken from Dave Alcock                                  PF0718\n*   Add indicators for all languages and sort by indicator/lang  PF0718\n*   and put it into a separate copy member to ease maintenance.  PF0718\n*   It is copied to dynamic storage to keep reentrancy and       PF0718\n*   allow various \"unknown\" entries to be modified               PF0718\nPIDCSECT CSECT ,                                                 PF0718\nPIDCSECT AMODE 31                                                PF0718\nPIDCSECT RMODE ANY                                               PF0718\n         COPY  PIDTABLE                                          PF0718\nPID_TABLE_LAST DS 0H                                             PF0718\n    dc XL2'0',cl10'UnknownPID',CL8'Unknown'        end of table  PF0718\nPID_TABLE_LEN EQU *-PIDCSECT                                     PF0718\n* -------------------------------------------------------------- PF0608\n* Separate CSECT for each initializing DCB/DCBE                  PF0608\n* -------------------------------------------------------------- PF0608\nFIXSYSPR CSECT ,                                                 PF0608\nFIXSYSPR AMODE 31\nFIXSYSPR RMODE ANY\n* Output information for selected programs                       PF0608\nSYSPRINT_FIX DCB   DSORG=PS,DDNAME=SYSPRINT,MACRF=PM,            PF0608X\n               RECFM=FB,LRECL=121,DCBE=SYSPRE                    PF0608\nSYSPRINT_FIX_LENGTH EQU *-SYSPRINT_FIX   Length workarea         PF0608\nSYSPRE   DCBE RMODE31=BUFF                                       PF0608\nFIXSUMMA CSECT ,                                                 PF0608\nFIXSUMMA AMODE 31\nFIXSUMMA RMODE ANY\n* Summary WORK file for CSC Summary report.                      PF0608\nSUMMARY_FIX DCB   DSORG=PS,DDNAME=SUMMARY,MACRF=PM,              PF0608X\n               RECFM=FB,LRECL=121,DCBE=SUMPRE                    PF0608\nSUMMARY_FIX_LENGTH EQU *-SUMMARY_FIX   Length workarea           PF0608\nSUMPRE   DCBE RMODE31=BUFF                                       PF0608\nFIXJUSTD CSECT ,                                                 =CMS=\nFIXJUSTD AMODE 31\nFIXJUSTD RMODE ANY\n* JUSTDATA file for CMS data                                     =CMS=\nJUSTDATA_FIX DCB   DSORG=PS,DDNAME=JUSTDATA,MACRF=PM,            =CMS= X\n               RECFM=FB,LRECL=#JUSTDATA_,DCBE=JUSTDPRE\nJUSTDATA_FIX_LENGTH EQU *-JUSTDATA_FIX   Length workarea         =CMS=\nJUSTDPRE DCBE RMODE31=BUFF                                       =CMS=\nFIXINPUT CSECT ,                                                 PF0608\nFIXINPUT AMODE 31\nFIXINPUT RMODE ANY\n* PDS Directory input file for PARM=ALL and COBANAL DD           PF0608\nINPUT_FIX DCB   DSORG=PS,DDNAME=COBANAL,MACRF=(GM),              PF0608X\n               RECFM=U,BLKSIZE=256,DCBE=INPUTE                   PF0608\nINPUT_FIX_LENGTH EQU *-INPUT_FIX     Length workarea             PF0608\nINPUTE   DCBE RMODE31=BUFF                                       PF0608\nFIXLOADL CSECT ,                                                 PF0608\nFIXLOADL AMODE 31\nFIXLOADL RMODE ANY\n* PDS input file for IEWBIND FUNC=INCLUDE and COBANAL DD         PF0608\nLOADL_FIX DCB   DSORG=PO,DDNAME=COBANAL,MACRF=(R),               PF0608X\n               RECFM=U,DCBE=LOADLE_FIX                           RS0516\nLOADLE_FIX   DCBE RMODE31=BUFF                                   RS0516\nLOADL_FIX_LENGTH EQU *-LOADL_FIX     Length workarea             PF0608\nFIXSYSIN CSECT ,                                                 PF0608\nFIXSYSIN AMODE 31\nFIXSYSIN RMODE ANY\n* Optional input file for list of programs to process            PF0608\nSYSIN_FIX DCB   DSORG=PS,DDNAME=SYSIN,MACRF=GM,                  RS0908X\n               RECFM=FB,LRECL=80,DCBE=SYSINE_FIX                 RS0908\nSYSINE_FIX  DCBE RMODE31=BUFF,EODAD=COBANAL_FIN                  RS0908\nSYSIN_FIX_LENGTH EQU *-SYSIN_FIX     Length workarea             PF0608\nCOBANAL  RSECT ,                                                 PF0718\n         IHAPSA ,                                                 *CSC*\n         IKJTCB ,                                                 *CSC*\n         IEFJFCBN ,                                               *CSC*\nTIOT     DSECT ,                                                  *CSC*\n         IEFTIOT1 ,                                               *CSC*\n         USING INFMJFCB,R2                                        *CSC*\n         IEFZB505 LOCEPAX=YES          EPA MAPPING FOR SWAREQ     *CSC*\n         CVT   PREFIX=YES,DSECT=YES,LIST=NO    CVT                *CSC*\n         IEFJESCT ,                    JES VECTOR TABLE           *CSC*\n         IEFQMIDS ,                    SWA Block Identifiers      *CSC*\n         IHASAVER DSECT=YES,LIST=YES,TITLE=NO,SAVER=YES,         PF0718X\n               SAVF4SA=YES,SAVF5SA=NO,SAVF7SA=NO,SAVF8SA=NO      PF0718\nCEEOCB   DSECT      LE option cblock (OCO)\nCEEOCB_EYEC       DS CL8               Eyecatcher\nCEEOCB_VER        DS H                 Version\nCEEOCB_LEN        DS AL2               Length of OCB\nCEEOCB_EVP        DS A                 Expansion vector pointer\n                  DS A                 Reserved for future use\nOPTION_RES1       DS 0C                Reserved option\nOPTION_RES1_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_RES1_WHSET DS H                 Where set\n*                                      50 default\n*                                      100 DOPT\n*                                      200 UOPT\n*                                      500 ROPT\nOPTION_RES1_SUBOPT DS A                Offset to sub-options\nOPTION_AIXB       DS 0C                AIXBLD\nOPTION_AIXB_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_AIXB_WHSET DS H                 Where set\n*                                      50 default\n*                                      100 DOPT\n*                                      200 UOPT\n*                                      500 ROPT\nOPTION_AIXB_SUB   DS A                 Offset to sub-options\nOPTION_ALL3       DS 0C                ALL31\nOPTION_ALL3_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_ALL3_WHSET DS H                 Where set\nOPTION_ALL3_SUB   DS A                 Offset to sub-options\nOPTION_BELH       DS 0C                BELOWHEAP\nOPTION_BELH_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_BELH_WHSET DS H                 Where set\nOPTION_BELH_SUB   DS A                 Offset to sub-options\nOPTION_CHEC       DS 0C                CHECK\nOPTION_CHEC_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_CHEC_WHSET DS H                 Where set\nOPTION_CHEC_SUB   DS A                 Offset to sub-options\nOPTION_PLIT       DS 0C                PLITASKCOUNT\nOPTION_PLIT_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_PLIT_WHSET DS H                 Where set\nOPTION_PLIT_SUB   DS A                 Offset to sub-options\nOPTION_ABTE       DS 0C                ABTERMENC\nOPTION_ABTE_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_ABTE_WHSET DS H                 Where set\nOPTION_ABTE_SUB   DS A                 Offset to sub-options\nOPTION_COUN       DS 0C                COUNTRY\nOPTION_COUN_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_COUN_WHSET DS H                 Where set\nOPTION_COUN_SUB   DS A                 Offset to sub-options\nOPTION_DEBU       DS 0C                DEBUG\nOPTION_DEBU_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_DEBU_WHSET DS H                 Where set\nOPTION_DEBU_SUB   DS A                 Offset to sub-options\nOPTION_ERRC       DS 0C                ERRCOUNT\nOPTION_ERRC_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_ERRC_WHSET DS H                 Where set\nOPTION_ERRC_SUB   DS A                 Offset to sub-options\nOPTION_FILE       DS 0C                FILEHIST\nOPTION_FILE_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_FILE_WHSET DS H                 Where set\nOPTION_FILE_SUB   DS A                 Offset to sub-options\nOPTION_ENVA       DS 0C                ENVAR\nOPTION_ENVA_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_ENVA_WHSET DS H                 Where set\nOPTION_ENVA_SUB   DS A                 Offset to sub-options\nOPTION_FLOW       DS 0C                FLOW\nOPTION_FLOW_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_FLOW_WHSET DS H                 Where set\nOPTION_FLOW_SUB   DS A                 Offset to sub-options\nOPTION_HEAP       DS 0C                HEAP\nOPTION_HEAP_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_HEAP_WHSET DS H                 Where set\nOPTION_HEAP_SUB   DS A                 Offset to sub-options\nOPTION_INQP       DS 0C                INQPCOPN\nOPTION_INQP_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_INQP_WHSET DS H                 Where set\nOPTION_INQP_SUB   DS A                 Offset to sub-options\nOPTION_INTE       DS 0C                INTERRUPT\nOPTION_INTE_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_INTE_WHSET DS H                 Where set\nOPTION_INTE_SUB   DS A                 Offset to sub-options\nOPTION_LIBS       DS 0C                LIBSTACK\nOPTION_LIBS_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_LIBS_WHSET DS H                 Where set\nOPTION_LIBS_SUB   DS A                 Offset to sub-options\nOPTION_MSGQ       DS 0C                MSGQ\nOPTION_MSGQ_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_MSGQ_WHSET DS H                 Where set\nOPTION_MSGQ_SUB   DS A                 Offset to sub-options\nOPTION_MSGF       DS 0C                MSGFILE\nOPTION_MSGF_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_MSGF_WHSET DS H                 Where set\nOPTION_MSGF_SUB   DS A                 Offset to sub-options\nOPTION_NATL       DS 0C                NATLANG\nOPTION_NATL_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_NATL_WHSET DS H                 Where set\nOPTION_NATL_SUB   DS A                 Offset to sub-options\nOPTION_ERRU       DS 0C                ERRUNIT\nOPTION_ERRU_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_ERRU_WHSET DS H                 Where set\nOPTION_ERRU_SUB   DS A                 Offset to sub-options\nOPTION_OCST       DS 0C                OCSTATUS\nOPTION_OCST_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_OCST_WHSET DS H                 Where set\nOPTION_OCST_SUB   DS A                 Offset to sub-options\nOPTION_POSI       DS 0C                POSIX\nOPTION_POSI_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_POSI_WHSET DS H                 Where set\nOPTION_POSI_SUB   DS A                 Offset to sub-options\nOPTION_RPTS       DS 0C                RPTSTG\nOPTION_RPTS_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_RPTS_WHSET DS H                 Where set\nOPTION_RPTS_SUB   DS A                 Offset to sub-options\nOPTION_RTER       DS 0C                RTEREUS\nOPTION_RTER_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_RTER_WHSET DS H                 Where set\nOPTION_RTER_SUB   DS A                 Offset to sub-options\nOPTION_SIMV       DS 0C                SIMVRD\nOPTION_SIMV_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_SIMV_WHSET DS H                 Where set\nOPTION_SIMV_SUB   DS A                 Offset to sub-options\nOPTION_STAC       DS 0C                STACK\nOPTION_STAC_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_STAC_WHSET DS H                 Where set\nOPTION_STAC_SUB   DS A                 Offset to sub-options\nOPTION_STOR       DS 0C                STORAGE\nOPTION_STOR_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_STOR_WHSET DS H                 Where set\nOPTION_STOR_SUB   DS A                 Offset to sub-options\nOPTION_AUTO       DS 0C                AUTOTASK\nOPTION_AUTO_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_AUTO_WHSET DS H                 Where set\nOPTION_AUTO_SUB   DS A                 Offset to sub-options\nOPTION_TRAC       DS 0C                TRACE\nOPTION_TRAC_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_TRAC_WHSET DS H                 Where set\nOPTION_TRAC_SUB   DS A                 Offset to sub-options\nOPTION_THRH       DS 0C                THREADHEAP\nOPTION_THRH_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_THRH_WHSET DS H                 Where set\nOPTION_THRH_SUB   DS A                 Offset to sub-options\nOPTION_TEST       DS 0C                TEST\nOPTION_TEST_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_TEST_WHSET DS H                 Where set\nOPTION_TEST_SUB   DS A                 Offset to sub-options\nOPTION_THRS       DS 0C                THREADSTACK\nOPTION_THRS_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_THRS_WHSET DS H                 Where set\nOPTION_THRS_SUB   DS A                 Offset to sub-options\nOPTION_TRAP       DS 0C                TRAP\nOPTION_TRAP_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_TRAP_WHSET DS H                 Where set\nOPTION_TRAP_SUB   DS A                 Offset to sub-options\nOPTION_UPSI       DS 0C                UPSI\nOPTION_UPSI_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_UPSI_WHSET DS H                 Where set\nOPTION_UPSI_SUB   DS A                 Offset to sub-options\nOPTION_VCTR       DS 0C                VCTRSAVE\nOPTION_VCTR_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_VCTR_WHSET DS H                 Where set\nOPTION_VCTR_SUB   DS A                 Offset to sub-options\nOPTION_PRTU       DS 0C                PRTUNIT\nOPTION_PRTU_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_PRTU_WHSET DS H                 Where set\nOPTION_PRTU_SUB   DS A                 Offset to sub-options\nOPTION_XUFL       DS 0C                XUFLOW\nOPTION_XUFL_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_XUFL_WHSET DS H                 Where set\nOPTION_XUFL_SUB   DS A                 Offset to sub-options\nOPTION_CBLO       DS 0C                CBLOPTS\nOPTION_CBLO_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_CBLO_WHSET DS H                 Where set\nOPTION_CBLO_SUB   DS A                 Offset to sub-options\nOPTION_NONI       DS 0C                NONIPTSTACK\nOPTION_NONI_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_NONI_WHSET DS H                 Where set\nOPTION_NONI_SUB   DS A                 Offset to sub-options\nOPTION_RPTO       DS 0C                RPTOPTS\nOPTION_RPTO_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_RPTO_WHSET DS H                 Where set\nOPTION_RPTO_SUB   DS A                 Offset to sub-options\nOPTION_ANYH       DS 0C                ANYHEAP\nOPTION_ANYH_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_ANYH_WHSET DS H                 Where set\nOPTION_ANYH_SUB   DS A                 Offset to sub-options\nOPTION_ABPE       DS 0C                ABPERC\nOPTION_ABPE_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_ABPE_WHSET DS H                 Where set\nOPTION_ABPE_SUB   DS A                 Offset to sub-options\nOPTION_TERM       DS 0C                TERMTHDACT\nOPTION_TERM_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_TERM_WHSET DS H                 Where set\nOPTION_TERM_SUB   DS A                 Offset to sub-options\nOPTION_DEPT       DS 0C                DEPTHCONDLMT\nOPTION_DEPT_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_DEPT_WHSET DS H                 Where set\nOPTION_DEPT_SUB   DS A                 Offset to sub-options\nOPTION_CBLP       DS 0C                CBLPSHPOP\nOPTION_CBLP_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_CBLP_WHSET DS H                 Where set\nOPTION_CBLP_SUB   DS A                 Offset to sub-options\nOPTION_CBLQ       DS 0C                CBLQDA\nOPTION_CBLQ_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_CBLQ_WHSET DS H                 Where set\nOPTION_CBLQ_SUB   DS A                 Offset to sub-options\nOPTION_PUNU       DS 0C                PUNUNIT\nOPTION_PUNU_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_PUNU_WHSET DS H                 Where set\nOPTION_PUNU_SUB   DS A                 Offset to sub-options\nOPTION_RDRU       DS 0C                RDRUNIT\nOPTION_RDRU_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_RDRU_WHSET DS H                 Where set\nOPTION_RDRU_SUB   DS A                 Offset to sub-options\nOPTION_RECP       DS 0C                RECPAD\nOPTION_RECP_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_RECP_WHSET DS H                 Where set\nOPTION_RECP_SUB   DS A                 Offset to sub-options\nOPTION_USRH       DS 0C                USRHDLR\nOPTION_USRH_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_USRH_WHSET DS H                 Where set\nOPTION_USRH_SUB   DS A                 Offset to sub-options\nOPTION_RES2       DS 0C                Reserved option\nOPTION_RES2_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_RES2_WHSET DS H                 Where set\nOPTION_RES2_SUB   DS A                 Offset to sub-options\nOPTION_PC         DS 0C                PC\nOPTION_PC_FLAG    DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_PC_WHSET   DS H                 Where set\nOPTION_PC_SUB     DS A                 Offset to sub-options\nOPTION_LIBR       DS 0C                LIBRARY\nOPTION_LIBR_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_LIBR_WHSET DS H                 Where set\nOPTION_LIBR_SUB   DS A                 Offset to sub-options\nOPTION_VERS       DS 0C                VERSION\nOPTION_VERS_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_VERS_WHSET DS H                 Where set\nOPTION_VERS_SUB   DS A                 Offset to sub-options\nOPTION_RTLS       DS 0C                RTLS\nOPTION_RTLS_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_RTLS_WHSET DS H                 Where set\nOPTION_RTLS_SUB   DS A                 Offset to sub-options\nOPTION_HCHK       DS 0C                HEAPCHK\nOPTION_HCHK_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_HCHK_WHSET DS H                 Where set\nOPTION_HCHK_SUB   DS A                 Offset to sub-options\nOPTION_PROF       DS 0C                PROFILE\nOPTION_PROF_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_PROF_WHSET DS H                 Where set\nOPTION_PROF_SUB   DS A                 Offset to sub-options\nOPTION_HEPP       DS 0C                HEAPPOOLS\nOPTION_HEPP_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_HEPP_WHSET DS H                 Where set\nOPTION_HEPP_SUB   DS A                 Offset to sub-options\nOPTION_INFO       DS 0C                INFOMSGFILTER\nOPTION_INFO_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_INFO_WHSET DS H                 Where set\nOPTION_INFO_SUB   DS A                 Offset to sub-options\nOPTION_XPLI       DS 0C                XPLINK\nOPTION_XPLI_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_XPLI_WHSET DS H                 Where set\nOPTION_XPLI_SUB   DS A                 Offset to sub-options\nOPTION_FILT       DS 0C                FILETAG\nOPTION_FILT_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_FILT_WHSET DS H                 Where set\nOPTION_FILT_SUB   DS A                 Offset to sub-options\nOPTION_HE64       DS 0C                HEAP64\nOPTION_HE64_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_HE64_WHSET DS H                 Where set\nOPTION_HE64_SUB   DS A                 Offset to sub-options\nOPTION_HEPP64     DS 0C                HEAPPOOLS64\nOPTION_HEPP64_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_HEPP64_WHSET DS H                 Where set\nOPTION_HEPP64_SUB   DS A                 Offset to sub-options\nOPTION_IOHE64     DS 0C                IOHEAP64\nOPTION_IOHE64_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_IOHE64_WHSET DS H                 Where set\nOPTION_IOHE64_SUB   DS A                 Offset to sub-options\nOPTION_LIHE64     DS 0C                LIBHEAP64\nOPTION_LIHE64_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_LIHE64_WHSET DS H                 Where set\nOPTION_LIHE64_SUB   DS A                 Offset to sub-options\nOPTION_STAC64     DS 0C                STACK64\nOPTION_STAC64_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_STAC64_WHSET DS H                 Where set\nOPTION_STAC64_SUB   DS A                 Offset to sub-options\nOPTION_THRS64     DS 0C                THREADSTACK64\nOPTION_THRS64_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_THRS64_WHSET DS H                 Where set\nOPTION_THRS64_SUB   DS A                 Offset to sub-options\nOPTION_DYNDMP     DS 0C                DYNDUMP                   RS0806\nOPTION_DYNDMP_FLAG  DS AL1               Flag for option         RS0806\n                  DS X                 Unused                    RS0806\nOPTION_DYNDMP_WHSET DS H                 Where set               RS0806\nOPTION_DYNDMP_SUB   DS A                 Offset to sub-options   RS0806\nOPTION_CEEDMP     DS 0C                CEEDUMP                   RS1007\nOPTION_CEEDMP_FLAG  DS AL1               Flag for option         RS1007\n                  DS X                 Unused                    RS1007\nOPTION_CEEDMP_WHSET DS H                 Where set               RS1007\nOPTION_CEEDMP_SUB   DS A                 Offset to sub-options   RS1007\nSUBOPT_BELH       DSECT                Suboptions BELOWHEAP\nSUBOPT_BELH_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_BELH_INIT  DS F                 BELOWHEAP initial size\nSUBOPT_BELH_INC   DS F                 BELOWHEAP increment size\nSUBOPT_BELH_ALLOC DS AL1               128 = BELOW, 64 = FREE\nSUBOPT_PLIT       DSECT                Suboptions PLITASKCOUNT\nSUBOPT_PLIT_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_PLIT_COUNT DS F                 PLITASKCOUNT # condition limit\nSUBOPT_ABTE       DSECT                Suboptions ABTERMENC\nSUBOPT_ABTE_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_ABTE_OPT   DS F                 2=ABEND, 1=RETCODE\nSUBOPT_COUN       DSECT                Suboptions COUNTRY\nSUBOPT_COUN_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_COUN_ID    DS CL2               COUNTRY identifier\n                  DS AL2               Unused\nSUBOPT_ERRC       DSECT                Suboptions ERRCOUNT\nSUBOPT_ERRC_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_ERRC_COUNT DS F                 ERRCOUNT # non-fatal errors\nSUBOPT_ENVA       DSECT                Suboptions ENVAR\nSUBOPT_ENVA_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_ENVA_OFFS  DS F                 Offset to envar string\nSUBOPT_ENVA_LEN   DS H                 length of envar\nSUBOPT_ENVA_STR   DS CL250             envar string\nSUBOPT_FLOW       DSECT                Suboptions FLOW\nSUBOPT_FLOW_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_FLOW_COUNT DS F                 FLOWC max # procedures\nSUBOPT_HEAP       DSECT                Suboptions HEAP\nSUBOPT_HEAP_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_HEAP_INIT  DS F                 HEAP initial size\nSUBOPT_HEAP_INC   DS F                 HEAP increment size\nSUBOPT_HEAP_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                  DS AL3               Unused\nSUBOPT_HEAP24_INIT DS F                HEAP24 initial size\nSUBOPT_HEAP24_INC DS F                 HEAP24 increment size\nSUBOPT_LIBS       DSECT                Suboptions LIBSTACK\nSUBOPT_LIBS_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_LIBS_INIT  DS F                 LIBSTACK initial size\nSUBOPT_LIBS_INC   DS F                 LIBSTACK increment size\nSUBOPT_LIBS_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                  DS AL3               Unused\nSUBOPT_MSGQ       DS 0C                Suboptions MSGQ\nSUBOPT_MSGQ_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_MSGQ_COUNT DS F                 MSGQ maximum # MIB entries\nSUBOPT_MSGF       DSECT                Suboptions MSGFILE\nSUBOPT_MSGF_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_MSGF_DDO   DS A                 Offset to DDNAME\nSUBOPT_MSGF_RFMO  DS A                 Offset to RECFM\nSUBOPT_MSGF_RECL  DS F                 RECL\nSUBOPT_MSGF_BLKS  DS F                 Block size\nSUBOPT_MSGF_DDL   DS H                 Effective length of following\nSUBOPT_MSGF_DD    DS CL8               MSGFILE DDname\nSUBOPT_MSGF_ENQ   DS CL2               Space = NOENQ ' *' = ENQ\nSUBOPT_MSGF_RFML  DS H                 Effective length of following\nSUBOPT_MSGF_RFM   DS CL5               Record format\n                  DS CL1               Unused\nSUBOPT_NATL       DSECT                Suboptions NATLANG\nSUBOPT_NATL_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_NATL_ID    DS CL3               COUNTRY identifier\n                  DS AL1               Unused\nSUBOPT_ERRU       DSECT                Suboptions ERRUNIT\nSUBOPT_ERRU_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_ERRU_COUNT DS F                 ERRUNIT # non-fatal errors\nSUBOPT_STAC       DSECT                Suboptions STACK\nSUBOPT_STAC_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_STAC_INIT  DS F                 STACK initial size\nSUBOPT_STAC_INC   DS F                 STACK increment size\nSUBOPT_STAC_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                  DS AL3               Unused\nSUBOPT_STAC_DINIT DS F                 DownSTACK initial size\nSUBOPT_STAC_DINC  DS F                 DownSTACK increment size\nSUBOPT_STOR       DSECT                Suboptions STACK\nSUBOPT_STOR_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_STOR_CSF   DS AL1               Characters-specified flags\nSUBOPT_STOR_AHSC  DS X                 Allocated heap storage character\nSUBOPT_STOR_FHSC  DS X                 Freed heap storage character\nSUBOPT_STOR_ADSC  DS X                 Allocated DSA storage character\nSUBOPT_STOR_SOSSZ DS F                 Short on storage reserve size\nSUBOPT_AUTO       DSECT                Suboptions AUTOTASK\nSUBOPT_AUTO_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_AUTO_LMO   DS A                 Offset to loadmod\nSUBOPT_AUTO_NO    DS F                 Number of subtasks\nSUBOPT_AUTO_LEN   DS H                 Length of Loadmod\nSUBOPT_AUTO_LMOD  DS CL8               Loadmod\n                  DS AL2               Unused\nSUBOPT_TRAC       DSECT                Suboptions TRACE\nSUBOPT_TRAC_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_TRAC_SIZE  DS F                 Trace buffer size\nSUBOPT_TRAC_GFLG  DS XL4               Global trace level bits\nSUBOPT_TRAC_FLG1  DS X                 Trace flags ('80xxxxxx' = DUMP)\nSUBOPT_TRAC_FLG2  DS X                 Trace flags ('xx00xxxx'       )\nSUBOPT_TRAC_FLG3  DS X                 Trace flags ('xxxx00xx'       )\nSUBOPT_TRAC_FLG4  DS X                 Trace flags ('xxxxxx00'       )\nSUBOPT_TRAC_TRVO  DS A                 Offset of Trace level verify\nSUBOPT_TRAC_TRSO  DS A                 Offset of Trace level set\nSUBOPT_TRAC_TRAO  DS A                 Offset of Trace level array\nSUBOPT_TRAC_TRVA  DS AL1               Verify flags for the following\n                  DS AL1                array of trace level\n                  DS AL1\n                  DS AL1\nSUBOPT_TRAC_TRSA  DS XL4               Trace level set flags array\nSUBOPT_TRAC_TRAA  DS XL4               Unused trace level bits\n                  DS XL4               CEL trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               C/370 trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               DCE trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               Sockets trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               Unused trace level bits\nSUBOPT_THRH       DSECT                Suboptions THREADHEAP\nSUBOPT_THRH_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_THRH_INIT  DS F                 THREADHEAP initial size\nSUBOPT_THRH_INC   DS F                 THREADHEAP increment size\nSUBOPT_THRH_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                  DS AL3               Unused\nSUBOPT_TEST       DSECT                Suboptions TEST\nSUBOPT_TEST_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_TEST_OPT   DS F                 1 = NONE, 2 = ERROR, 4 = ALL\nSUBOPT_TEST_CFO   DS A                 Offset of commands_file\nSUBOPT_TEST_CLO   DS A                 Offset of command_list]prompt\nSUBOPT_TEST_PFO   DS A                 Offset of preference_file\nSUBOPT_TEST_CFL   DS H                 Effective length of following\nSUBOPT_TEST_CF    DS CL80              Commands_file name\n                  DS CL2               unused\nSUBOPT_TEST_CLL   DS H                 Effective length of following\nSUBOPT_TEST_CL    DS CL250             Command_list name]prompt option\nSUBOPT_TEST_PFL   DS H                 Effective length of following\nSUBOPT_TEST_PF    DS CL80              Preference_file name\n                  DS CL2               Unused\nSUBOPT_THRS       DSECT                Suboptions THREADSTACK\nSUBOPT_THRS_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_THRS_INIT  DS F                 ThreadStack initial size\nSUBOPT_THRS_INC   DS F                 ThreadStack increment size\nSUBOPT_THRS_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                  DS AL3               Unused\nSUBOPT_THRS_DINIT DS F                 Down STACK initial size\nSUBOPT_THRS_DINC  DS F                 Down  STACK increment size\nSUBOPT_TRAP       DSECT                Suboptions TRAP\nSUBOPT_TRAP_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_TRAP_FLG   DS AL1               Trap  flags ('80xxxxxx' = SPIE)\n                  DS AL3               Unused\nSUBOPT_UPSI       DSECT                Suboptions UPSI\nSUBOPT_UPSI_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_UPSI_SW    DS CL8               8 UPSI switches\nSUBOPT_PRTU       DSECT                Suboptions PRTUNIT\nSUBOPT_PRTU_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_PRTU_COUNT DS F                 PRTUNIT # non-fatal errors\nSUBOPT_XUFL       DSECT                Suboptions XUFLOW\nSUBOPT_XUFL_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_XUFL_COUNT DS F                 4 = OFF, 2 = ON, 1 = AUTOs\nSUBOPT_NONI       DSECT                Suboptions NONIPTSTACK\nSUBOPT_NONI_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_NONI_INIT  DS F                 NONIPTSTACK initial size\nSUBOPT_NONI_INC   DS F                 NONIPTSTACK increment size\nSUBOPT_NONI_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                  DS AL3               Unused\nSUBOPT_ANYH       DSECT                Suboptions ANYHEAP\nSUBOPT_ANYH_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_ANYH_INIT  DS F                 ANYHEAP initial size\nSUBOPT_ANYH_INC   DS F                 ANYHEAP increment size\nSUBOPT_ANYH_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                  DS AL3               Unused\nSUBOPT_ABPE       DSECT                Suboptions ABPERC\nSUBOPT_ABPE_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_ABPE_US    DS AL1               128=NONE, 64=U, 32=S, 16=other\n                  DS AL3               Unused\nSUBOPT_ABPE_CODE  DS F                 Numeric portion of U or S abcode\nSUBOPT_ABPE_ABC   DS CL8               Abcode (blank-padded)\nSUBOPT_TERM       DSECT                Suboptions TERMTHDACT\nSUBOPT_TERM_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_TERM_FLG   DS F                 8=QUIET, 4=MSG, 2=TRACE, 1=DUMP\nSUBOPT_TERM_CESE  DS AL1               128=CESE,64=CICSDDS\n                  DS AL3               Unused\nSUBOPT_TERM_STOR  DS H                 reg_stor_amount suboption\n                  DS AL2               Unused\nSUBOPT_DEPT       DSECT                Suboptions DEPTHCONDLMT\nSUBOPT_DEPT_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_DEPT_COUNT DS F                 DEPTHCONDLMT # condition limit\nSUBOPT_PUNU       DSECT                Suboptions PUNUNIT\nSUBOPT_PUNU_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_PUNU_COUNT DS F                 PUNUNIT # non-fatal errors\nSUBOPT_RDRU       DSECT                Suboptions RDRUNIT\nSUBOPT_RDRU_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_RDRU_COUNT DS F                 RDRUNIT # non-fatal errors\nSUBOPT_RECP       DSECT                Suboptions RECPAD\nSUBOPT_RECP_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_RECP_FLG   DS F                 4 = OFF, 2 = ON, 1 = VAR\nSUBOPT_USRH       DSECT                Suboptions USRHDLR\nSUBOPT_USRH_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_USRH_UN1O  DS A                 Offset of UHname\nSUBOPT_USRH_UN2O  DS A                 Offset of UHname2\nSUBOPT_USRH_UN1L  DS H                 Effective length of following\nSUBOPT_USRH_UN1   DS CL8               USRHDLR UHname\n                  DS CL2\nSUBOPT_USRH_UN2L  DS H                 Effective length of following\nSUBOPT_USRH_UN2   DS CL8               USRHDLR UHname2\n                  DS CL2\nSUBOPT_RES2       DSECT                Suboptions\nSUBOPT_RES2_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_RES2_LVL   DS F                 Level information\nSUBOPT_LIBR       DSECT                Suboptions LIBRARY\nSUBOPT_LIBR_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_LIBR_LMO   DS A                 Offset of load module name\nSUBOPT_LIBR_LML   DS H                 Effective length of following\nSUBOPT_LIBR_LM    DS CL8               Name of load module\n                  DS CL2\nSUBOPT_VERS       DSECT                Suboptions VERSION\nSUBOPT_VERS_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_VERS_LMO   DS A                 Offset of load module name\nSUBOPT_VERS_LML   DS H                 Effective length of following\nSUBOPT_VERS_LM    DS CL8               Name of load module\n                  DS CL2\nSUBOPT_HCHK       DSECT                Suboptions HEAPCHK\nSUBOPT_HCHK_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_HCHK_FREQ  DS F                 HeapChk frequency\nSUBOPT_HCHK_INIT  DS F                 HeapChk initial delay\nSUBOPT_HCHK_CLVL  DS F                 HeapChk call level\nSUBOPT_HCHK_PLVL  DS F                 HeapChk pool call level\nSUBOPT_PROF       DSECT                Suboptions PROFILE\nSUBOPT_PROF_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_PROF_STRO  DS A                 Offset of Profiler string\nSUBOPT_PROF_STRL  DS H                 Effective length of following\nSUBOPT_PROF_STR   DS CL250             PROFILE String\nSUBOPT_HEPP       DSECT                Suboptions HEAPPOOLS\nSUBOPT_HEPP_FLG1  DS AL1               Suboption valid bits\nSUBOPT_HEPP_FLG2  DS AL1               Suboption valid bits\n                  DS AL2               Unused suboption valid bits\nSUBOPT_HEPP_CP1S  DS F                 cell pool 1 size\nSUBOPT_HEPP_CP1P  DS F                 cell pool 1 percentage\nSUBOPT_HEPP_CP2S  DS F                 cell pool 2 size\nSUBOPT_HEPP_CP2P  DS F                 cell pool 2 percentage\nSUBOPT_HEPP_CP3S  DS F                 cell pool 3 size\nSUBOPT_HEPP_CP3P  DS F                 cell pool 3 percentage\nSUBOPT_HEPP_CP4S  DS F                 cell pool 4 size\nSUBOPT_HEPP_CP4P  DS F                 cell pool 4 percentage\nSUBOPT_HEPP_CP5S  DS F                 cell pool 5 size\nSUBOPT_HEPP_CP5P  DS F                 cell pool 5 percentage\nSUBOPT_HEPP_CP6S  DS F                 cell pool 6 size\nSUBOPT_HEPP_CP6P  DS F                 cell pool 6 percentage\nSUBOPT_HEPP_CP7S  DS F                 cell pool 7 size\nSUBOPT_HEPP_CP7P  DS F                 cell pool 7 percentage\nSUBOPT_HEPP_CP8S  DS F                 cell pool 8 size\nSUBOPT_HEPP_CP8P  DS F                 cell pool 8 percentage\nSUBOPT_HEPP_CP9S  DS F                 cell pool 9 size\nSUBOPT_HEPP_CP9P  DS F                 cell pool 9 percentage\nSUBOPT_HEPP_CP10S DS F                 cell pool 10 size\nSUBOPT_HEPP_CP10P DS F                 cell pool 10 percentage\nSUBOPT_HEPP_CP11S DS F                 cell pool 11 size\nSUBOPT_HEPP_CP11P DS F                 cell pool 11 percentage\nSUBOPT_HEPP_CP12S DS F                 cell pool 12 size\nSUBOPT_HEPP_CP12P DS F                 cell pool 12 percentage\nSUBOPT_INFO       DSECT                Suboptions INFOMSGFILTER\nSUBOPT_INFO_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_INFO_ID1   DS CL1               Single char environment ids\nSUBOPT_INFO_ID2   DS CL1\nSUBOPT_INFO_ID3   DS CL1\nSUBOPT_INFO_ID4   DS CL1\nSUBOPT_FILT       DSECT                Suboptions FILETAG\nSUBOPT_FILT_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_FILT_FLG   DS AL1               FILETAG Flags\n                  DS CL3               Unused\nSUBOPT_HE64       DSECT                Suboptions HEAP\nSUBOPT_HE64_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_HE64_INIT  DS FDL8              HEAP initial size\nSUBOPT_HE64_INC   DS FDL8              HEAP increment size\nSUBOPT_HE64_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                  DS AL3               Unused\nSUBOPT_HE6431_INIT DS F                HEAP24 initial size\nSUBOPT_HE6431_INC  DS F                 HEAP24 increment size\nSUBOPT_HE6431_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                   DS AL3               Unused\nSUBOPT_HE6424_INIT DS F                HEAP24 initial size\nSUBOPT_HE6424_INC  DS F                 HEAP24 increment size\nSUBOPT_HE6424_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                   DS AL3               Unused\nSUBOPT_HEPP64     DSECT                Suboptions HEAPPOOLS\nSUBOPT_HEPP64_FLG1  DS AL1               Suboption valid bits\nSUBOPT_HEPP64_FLG2  DS AL1               Suboption valid bits\n                  DS AL2               Unused suboption valid bits\nSUBOPT_HEPP64_CP1S  DS F                 cell pool 1 size\nSUBOPT_HEPP64_CP1P  DS F                 cell pool 1 percentage\nSUBOPT_HEPP64_CP2S  DS F                 cell pool 2 size\nSUBOPT_HEPP64_CP2P  DS F                 cell pool 2 percentage\nSUBOPT_HEPP64_CP3S  DS F                 cell pool 3 size\nSUBOPT_HEPP64_CP3P  DS F                 cell pool 3 percentage\nSUBOPT_HEPP64_CP4S  DS F                 cell pool 4 size\nSUBOPT_HEPP64_CP4P  DS F                 cell pool 4 percentage\nSUBOPT_HEPP64_CP5S  DS F                 cell pool 5 size\nSUBOPT_HEPP64_CP5P  DS F                 cell pool 5 percentage\nSUBOPT_HEPP64_CP6S  DS F                 cell pool 6 size\nSUBOPT_HEPP64_CP6P  DS F                 cell pool 6 percentage\nSUBOPT_HEPP64_CP7S  DS F                 cell pool 7 size\nSUBOPT_HEPP64_CP7P  DS F                 cell pool 7 percentage\nSUBOPT_HEPP64_CP8S  DS F                 cell pool 8 size\nSUBOPT_HEPP64_CP8P  DS F                 cell pool 8 percentage\nSUBOPT_HEPP64_CP9S  DS F                 cell pool 9 size\nSUBOPT_HEPP64_CP9P  DS F                 cell pool 9 percentage\nSUBOPT_HEPP64_CP10S DS F                 cell pool 10 size\nSUBOPT_HEPP64_CP10P DS F                 cell pool 10 percentage\nSUBOPT_HEPP64_CP11S DS F                 cell pool 11 size\nSUBOPT_HEPP64_CP11P DS F                 cell pool 11 percentage\nSUBOPT_HEPP64_CP12S DS F                 cell pool 12 size\nSUBOPT_HEPP64_CP12P DS F                 cell pool 12 percentage\nSUBOPT_IOHE64       DSECT                Suboptions IOHEAP64\nSUBOPT_IOHE64_FLAG  DS AL1               Suboption valid bits\nSUBOPT_IOHE64_OPT   DS AL1               Suboption valid bits (part 2)\n                    DS AL2               Unused suboption valid bits\nSUBOPT_IOHE64_INIT  DS FDL8              IOHEAP64 initial size 64\nSUBOPT_IOHE64_INC   DS FDL8              IOHEAP64 increment size 64\nSUBOPT_IOHE64_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                    DS AL3               Unused\nSUBOPT_IOHE6431_INIT DS F                IOHEAP64 initial size 31\nSUBOPT_IOHE6431_INC  DS F                IOHEAP64 increment size 31\nSUBOPT_IOHE6431_ALLOC DS AL1             128 = BELOW, 64 = FREE\n                    DS AL3               Unused\nSUBOPT_IOHE6424_INIT DS F                IOHEAP64 initial size 24\nSUBOPT_IOHE6424_INC  DS F                IOHEAP64 increment size 24\nSUBOPT_IOHE6424_ALLOC DS AL1             128 = BELOW, 64 = FREE\nSUBOPT_LIHE64       DSECT                Suboptions LIBHEAP64\nSUBOPT_LIHE64_FLAG  DS AL1               Suboption valid bits\nSUBOPT_LIHE64_OPT   DS AL1               Suboption valid bits (part 2)\n                    DS AL2               Unused suboption valid bits\nSUBOPT_LIHE64_INIT  DS FDL8              LIBHEAP64 initial size 64\nSUBOPT_LIHE64_INC   DS FDL8              LIBHEAP64 increment size 64\nSUBOPT_LIHE64_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                    DS AL3               Unused\nSUBOPT_LIHE6431_INIT DS F                LIBHEAP64 initial size 31\nSUBOPT_LIHE6431_INC  DS F                LIBHEAP64 increment size 31\nSUBOPT_LIHE6431_ALLOC DS AL1             128 = BELOW, 64 = FREE\n                    DS AL3               Unused\nSUBOPT_LIHE6424_INIT DS F                LIBHEAP64 initial size 24\nSUBOPT_LIHE6424_INC  DS F                LIBHEAP64 increment size 24\nSUBOPT_LIHE6424_ALLOC DS AL1             128 = BELOW, 64 = FREE\n                    DS AL3               Unused\nSUBOPT_STAC64       DSECT                Suboptions STACK64\nSUBOPT_STAC64_FLAG  DS AL1               Suboption valid bits\n                    DS AL3               Unused suboption valid bits\nSUBOPT_STAC64_INIT  DS FDL8              STACK64 initial size\nSUBOPT_STAC64_INC   DS FDL8              STACK64 increment size\nSUBOPT_STAC64_MAX   DS FDL8              STACK64 maximum\nSUBOPT_THRS64       DSECT                Suboptions THREADSTACK64\nSUBOPT_THRS64_FLAG  DS AL1               Suboption valid bits\n                    DS AL3               Unused suboption valid bits\nSUBOPT_THRS64_INIT  DS FDL8              THREADSTACK64 initial size\nSUBOPT_THRS64_INC   DS FDL8              THREADSTACK64 increment size\nSUBOPT_THRS64_MAX   DS FDL8              THREADSTACK64 maximum\nSUBOPT_DYNDMP       DSECT                Suboptions DYNDUMP      RS0806\nSUBOPT_DYNDMP_FLAG  DS AL1               Suboption valid bits    RS0806\n                    DS AL3               Unused suboption valid bits806\nSUBOPT_DYNDMP_HLQP  DS A                 DYNDUMP HLQ-Option Ptr  RS0806\nSUBOPT_DYNDMP_FLG1  DS X                 DYNDUMP FLAG 4039       RS0806\nSUBOPT_DYNDMP_FLG2  DS X                 DYNDUMP FLAG 40xx       RS0806\nSUBOPT_DYNDMP_HLQO  DSECT                DYNDUMP HLQ             RS0806\nSUBOPT_DYNDMP_HLQL  DS H                 Length of DYNDUMP HLQ   RS0806\nSUBOPT_DYNDMP_HLQS  DS CL26              String of DYNDUMP HLQ   RS0806\nSUBOPT_CEEDMP       DSECT                Suboptions CEEDUMP      RS1007\nSUBOPT_CEEDMP_FLAG  DS AL1               Suboption valid bits    RS1007\n                    DS AL3               Unused suboption valid bits007\nSUBOPT_CEEDMP_PAGL  DS F                 CEEDUMP Pagelength      RS1007\nSUBOPT_CEEDMP_SYSO  DS CL4               CEEDUMP Sysout-Fname    RS1007\nSUBOPT_CEEDMP_SYSC  DS CL1               CEEDUMP Sysout-Class    RS1007\nSUBOPT_CEEDMP_FREE  DS X                 CEEDUMP 0=FREE=END      RS1007\nSUBOPT_CEEDMP_SPIN  DS X                 CEEDUMP 0=SPIN=UNALLOC  RS1007\n                    DS X                 CEEDUMP padding         RS1007\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBJCL": {"ttr": 5377, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x01\\x00\\x98\\x07\\x8f\\x01\\t\\x12\\x8f\\x07!\\x00.\\x00\\x14\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xf0\\xf8@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "1998-03-19T00:00:00", "modifydate": "2009-05-08T07:21:01", "lines": 46, "newlines": 20, "modlines": 0, "user": "SYSP08"}, "text": "//XXRSCHIC JOB (62715),\n//           'SCHIRADIN-TEL.NNNN',\n//           CLASS=A,\n//           MSGLEVEL=(1,1),\n//           MSGCLASS=X,\n//           REGION=4M,\n//           NOTIFY=&SYSUID\n//*\n//*  PARM=ALL analyze all load-members in the library\n//*  DDNAME COBANAL\n//*  PARM=SYSIN analyze all load-members given in the SYSIN DD\n//*  DDNAME COBANAL\n//*  PARM=<pgmname> analyze a single members BUT load it from\n//*  DDNAME STEPLIB (see sample below)\n//*\n//COMP    EXEC PGM=COBANAL,PARM='ALL'\n//*COMP    EXEC PGM=COBANAL,PARM='SYSIN' Read SYSIN for names\n//STEPLIB   DD DISP=SHR,DSN=<your.load>\n//COBANAL   DD DISP=SHR,DSN=<your.load.to.analyze>\n//SYSPRINT  DD SYSOUT=*\n//SUMMARY   DD SYSOUT=*\n//*BINDEROU  DD SYSOUT=* Binder-Output in case of debugging\n//*MAINONLY  DD DUMMY    Analyze only main programs\n//*SYSIN     DD *     Member names via SYSIN only first 8 bytes count\n//*JUSTDATA  DD SYSOUT=* fixed record-oriented to post-process\n//\n//*  PARM=<pgmname> load the module from your Steplib\n//*  and create a single report (max 8 characters)\n//*\n//*\n//COMP    EXEC PGM=COBANAL,PARM='<pgmname>'\n//STEPLIB   DD DISP=SHR,DSN=<your.load>\n//          DD DISP=SHR,DSN=<your.load.to.analyze>\n//SYSPRINT  DD SYSOUT=*\n//SUMMARY   DD SYSOUT=*\n//*BINDEROU  DD SYSOUT=* Binder-Output in case of debugging\n//*\n//*  PARM=FR%G*   Support for wildcards\n//*\n//*\n//COMP    EXEC PGM=COBANAL,PARM='FR%G*'\n//STEPLIB   DD DISP=SHR,DSN=<your.load>\n//COBANAL   DD DISP=SHR,DSN=<your.load.to.analyze>\n//SYSPRINT  DD SYSOUT=*\n//SUMMARY   DD SYSOUT=*\n//*BINDEROU  DD SYSOUT=* Binder-Output in case of debugging\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EXCI": {"ttr": 5379, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x99\\x06\\x0f\\x01\\x00\\x10_\\x11X\\x01]\\x01]\\x00\\x00\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "2000-04-14T11:58:00", "lines": 349, "newlines": 349, "modlines": 0, "user": "XSSGSCH"}, "text": "000100 Identification Division.\n000200 Program-Id. EXCI is INITIAL\n000300****************************************************************\n000400*                                                              *\n000500*  PROGRAM NAME: EXCI                                          *\n000600*                                                              *\n000700*  TITLE: Cemt Commands from Batch                             *\n000800*                                                              *\n000900*  DATE: March 1998                                            *\n001000*                                                              *\n001100*                                                              *\n001200*  INPUT:         The target CICS system with which this       *\n001300*                 batch client program communicates musst be   *\n001400*                 specified via the EINGABE DD statement.      *\n001500*                                                              *\n001600*  OUTPUT:        The whole of the Target File will be output  *\n001700*                 to the SYSPRINT log, together with status    *\n001800*                 information.                                 *\n001900*                                                              *\n002000****************************************************************\n002100 Environment Division.\n002200*==============================================================*\n002300 Input-Output Section.\n002400 File-Control.\n002500     Select Printer assign to SYSPRINT.\n002600     Select Optional Eingabe assign to SYSIN.\n002700 Data Division.\n002800*==============================================================*\n002900 File Section.\n003000*==============================================================*\n003100 fd  Printer\n003200     Record contains 128 Characters\n003210     Block  contains 0 Records\n003300     Recording Mode S\n003400     Label Records omitted.\n003500 01  Output-Record      pic x(128).\n003600 fd  Eingabe\n003610     Record contains 80 Characters\n003620     Block  contains 0 Records\n003800     Recording mode f.\n003900 01  Input-Record.\n004000     05 I-Target-Applid pic x(8).\n004100     05 Filler          pic x.\n004200     05 I-Command       pic x(8).\n004300     05 Filler          pic x.\n004400     05 I-Type          pic x(8).\n004500     05 Filler          pic x.\n004600     05 I-Resource      pic x(8).\n004700     05 Filler          pic x.\n004800     05 I-Status        pic x(20).\n004810     05 Filler          pic x(24).\n004900*DCCTT01  SET      FILE     TRAC     CLOSE\n005000*DCCTT01  START    TRANSID  D1SA     SBDC C=001,N=FTS....\n005100 Working-Storage Section.\n005200*==============================================================*\n005300*   Declare Call level,DPL, and EXEC level Return Code areas.  *\n005400*==============================================================*\n005500 COPY DFHXCPLO.\n005600*==============================================================*\n005700*   Declare Areas to be used for outputting return codes.      *\n005800*==============================================================*\n005900 01  Output-RetArea.\n006000   05                   pic x(20)  value Spaces.\n006100   05  O-Resp           pic 9(8).\n006200   05                   pic xx     value Spaces.\n006300   05  O-Resp2          pic 9(8).\n006400   05                   pic xx     value Spaces.\n006500   05  OExci-Sub-Reason1 pic 9(8).\n006600   05  O-AbCode-Line    redefines OExci-Sub-Reason1.\n006700       10  O-AbCode     pic x(4).\n006800       10  Opad-AbCode  pic x(4).\n006900   05                   pic x(80) value Spaces.\n007000 01  Sub                pic s9(8) binary.\n007200 01  Exci-Sev-Highest   pic 9(2)  value 0.\n007300 01  Out-Rec.\n007400   05 Out-Rec-Elem      pic x occurs 128 times.\n007500*==============================================================*\n007600*   Initialise Target information variables.                   *\n007700*==============================================================*\n007800 01  Application        pic x(8)       value 'EXCI'.\n007810 01  Target-Program     pic x(8)       value 'EXCISE'.\n007900 01  Target-Transid     pic x(4)       value 'EXCI'.\n007901 01  User-Token         pic S9(9) binary value zero.                    20\n007910 01  Pipe-Token         pic S9(9) binary value zero.                    20\n007911 01  Comm-Length        pic S9(8) binary.                               24\n007920 01  Data-Length        pic S9(8) binary.                               24\n007930 01  U-Cics-Rc          pic 99.                                         24\n008000*==============================================================*\n008100*   Define Commarea struct.                                    *\n008200*==============================================================*\n008300 01  Commarea.\n008400   03  Commarea-Data.\n008500     05 Cics-Command      pic x(8).\n008600     05 Filler            pic x.\n008700     05 Cics-Type         pic x(8).\n008800     05 Filler            pic x.\n008900     05 Cics-Resource     pic x(8).\n009000     05 Filler            pic x.\n009100     05 Cics-Status       pic x(20).\n009200     05 Filler            pic x.\n009300     05 Cics-RC           pic s9(4) binary.\n009310     05 Cics-Message      pic x(80).\n009400*==============================================================*\n009500*   Initialise program specific variables and flags.           *\n009600*==============================================================*\n009700 01  Program-Flags.\n009800   05  Abort-Flag       pic x(3)       value 'NO '.\n009900       88 Abort                        value 'YES'.\n010000       88 No-Abort                     value 'NO '.\n010100   05  Eof-Flag         pic x(3)       value 'NO '.\n010200       88 Eof                          value 'YES'.\n010300       88 No-Eof                       value 'NO '.\n010400 01  Program-Messages.\n010500   05  Msg00  pic x(128) value Spaces.\n010600   05  Msg01  pic x(128) value '*===================== Batch CICS-\n010700-     'Commands ====================================*'.\n010800   05  Msg02  pic x(128) value '*\n010900-     '                                             *'.\n011000   05  Msg03  pic x(128) value '*  Following Command will be proce\n011100-     'ed:                                          *'.\n011200   05  Msg11  pic x(128) value '*    The Link Request has failed.\n011300-     ' Return codes are:                           *'.\n011400   05  Msg13  pic x(128) value '*    A message was received from t\n011500-     'he target CICS system:                       *'.\n011600   05  MSg14  pic x(128) value '*    >>>> Aborting further process\n011700-     'ing <<<<                                     *'.\n011701   05  MSG23  PIC X(128) VALUE '*    The connection has been unsuc      37\n011710-     'cessful.  Return codes are:                  *'.                 37\n011711   05  MSG25  PIC X(128) VALUE '*      The DPL request has failed.      37\n011712-     '                                             *'.                 37\n011713   05  MSG26  PIC X(128) VALUE '*      Link return codes are:           38\n011714-     '                                             *'.                 38\n011715   05  MSG27  PIC X(128) VALUE '*      DPL return codes are:            38\n011720-     '                                             *'.                 38\n011800   05  Msg31  pic x(128) value '*=================== End of Batch\n011900-     'CICS-Commands ===============================*'.\n012000*==============================================================*\n012100 linkage section.\n012200   01  Null-ptr  usage is Pointer.\n012300*\n012400   01  Exec-Level-Msg.\n012500     05 Exec-Level-Msg-Text pic x occurs 128 times.\n012600*\n012601   01  Call-Level-Msg.\n012602     05 Call-Level-Msg-Len  pic s9(4) binary.\n012603     05                     pic s9(4) binary.\n012610     05 Call-Level-Msg-Text pic x occurs 128 times.\n012700\n012800 Procedure Division.\n012900     Open output Printer\n013000     Open input Eingabe\n013100     Write Output-Record from Msg00\n013200     Write Output-Record from Msg01\n013300     Write Output-Record from Msg02\n013310*\n013320***  Perform the Initialise User Call\n013330*\n013340     Call 'DFHXCIS' using Version-1\n013350                          Exci-Return-Code\n013360                          User-Token\n013370                          Init-User\n013380                          Application\n013390\n013420*==============================================================*\n013500*    Get data from Eingabe                                     *\n013600*==============================================================*\n013700     Perform until eof or abort\n013800       Read Eingabe\n013900         at end\n014000           Set Eof to true\n014100       End-Read\n014200       If eof\n014300         Continue\n014400       else\n014420*        Perform the Allocate Pipe Call\n014440         Call 'DFHXCIS' using Version-1\n014450                              Exci-Return-Code\n014460                              User-Token\n014470                              Allocate-Pipe\n014480                              Pipe-Token\n014490                              I-Target-Applid\n014491                              Generic-Pipe\n014493*        Perform the Open Pipe Call.\n014495         Call 'DFHXCIS' using Version-1\n014496                              Exci-Return-Code\n014497                              User-Token\n014498                              Open-Pipe\n014499                              Pipe-Token\n014500         if Exci-Response = 0\n014501           Continue\n014502         else\n014503           Write Output-Record    from Msg23\n014504           Move  Exci-Response    to   O-Resp\n014505           Move  Exci-Reason      to   O-Resp2\n014506           Move  Exci-Sub-Reason1 to   OExci-Sub-Reason1\n014507           Write Output-record    from Output-Retarea\n014508           Write Output-record    from Msg14\n014509           Set Abort to true\n014510         end-if\n014511         If Abort\n014512           Continue\n014513         else\n014520*          Set up the Commarea for transmission.\n014600           Move Spaces       to Commarea\n014700           Move I-Command    to Cics-Command\n014800           Move I-Type       to Cics-Type\n014900           Move I-Resource   to Cics-Resource\n015000           Move I-Status     to Cics-Status\n015300           Write Output-Record from Msg03\n015400           Move Spaces       to Out-Rec\n015500           Move '* '         to Out-Rec (1:3)\n015600           Move 'Cics:'      to Out-Rec (4:5)\n015700           Move I-Target-Applid to Out-Rec (9:8)\n015800           Move Commarea     to Out-Rec (18:61)\n015900           Move '*'          to Out-Rec (80:1)\n016000           Write Output-Record from Out-Rec\n016100*          Perform the Link Request\n016110           Perform Dpl-Program\n017900         end-If\n017902*        Perform Close Pipe call\n017904         Call 'DFHXCIS' using Version-1\n017905                              Exci-Return-Code\n017906                              User-Token\n017907                              Close-Pipe\n017908                              Pipe-Token\n017910*        Perform Deallocate Pipe call\n017912         Call 'DFHXCIS' using Version-1\n017913                              Exci-Return-Code\n017914                              User-Token\n017915                              Deallocate-Pipe\n017916                              Pipe-Token\n017920       end-If\n018000     end-Perform\n018020\n018100     Write Output-record from Msg02\n018200     Write Output-record from Msg31\n018300     Close Printer Eingabe\n018400     Move  Exci-Sev-Highest to Return-Code\n018500     If Abort\n018600       Move 12  to Return-Code\n018700     end-if\n018800     stop run\n018900     .\n023900******************************************************************\n024000*\n024100*  Dpl-Program\n024300*\n024400******************************************************************\n024500 Dpl-Program Section.\n024501\n024502     set address of null-ptr to nulls\n024503     Move Length of Commarea to Comm-Length                             24\n024504                                Data-Length                             24\n024505*\n024506*    set up the call, and perform the dpl request.\n024507*\n024508     Call 'DFHXCIS' using Version-1\n024509                          Exci-Return-Code\n024510                          User-Token\n024511                          Dpl-Request\n024512                          Pipe-Token\n024513                          Target-Program\n024514                          Commarea\n024515                          Comm-Length                                   24\n024516                          Data-Length                                   24\n024520                          Target-TransId\n024521                          Null-Ptr\n024522                          Null-Ptr\n024523                          Exci-Dpl-RetArea\n024524                          SyncOnReturn\n024525*\n024526*  Check how successful the Call was.  If it has worked, then\n024527*  we have a Record on the Commarea to be output to the\n024528*  Sysprint log.\n024529*\n024530     If Exci-Response = 4 and Exci-Reason = 7\n024531*      Server-Cics terminated\n024532       Move Spaces         to Out-Rec\n024533       Move '* '           to Out-Rec (1:3)\n024534       Move 'RC:00'        to Out-Rec (4:5)\n024536       Move 'Cics shutdown complete'  to Out-Rec (10:70)\n024537       Move '*'            to Out-Rec (80:1)\n024538       Write Output-Record from Out-Rec\n024539       Write Output-Record from Msg02\n024540       Go to Dpl-Program-End\n024541     end-if\n024542\n024544     If Exci-Response = 0\n024545       If Exci-Dpl-Resp = 0 then\n024546         Move Spaces         to Out-Rec\n024547         Move '* '           to Out-Rec (1:3)\n024548         Move 'RC:'          to Out-Rec (4:3)\n024549         Move Cics-RC        to U-Cics-Rc\n024550         Move U-Cics-RC      to Out-Rec (7:2)\n024551         Move Cics-Message   to Out-Rec (10:70)\n024552         Move '*'            to Out-Rec (80:1)\n024553         Write Output-Record from Out-Rec\n024554         Write Output-Record from Msg02\n024555         If Cics-Rc > Exci-Sev-Highest\n024556            Move Cics-Rc    to Exci-Sev-Highest\n024557         end-if\n024558       else\n024559         Write Output-Record from Msg25\n024560         Write Output-Record from Msg27\n024561         Move  Exci-Dpl-Resp to O-Resp\n024562         Move  Exci-Dpl-Resp2 to O-Resp2\n024563         Move  Spaces to Opad-Abcode\n024564         Move  Exci-Dpl-Abcode to O-Abcode\n024565         Write Output-Record from Output-Retarea\n024566         Write Output-Record from Msg14\n024567         Set Abort to true\n024568       end-if\n024569     else\n024570       Write Output-Record from Msg11\n024571       Move  Exci-Response to   O-Resp\n024572       Move  Exci-Reason   to   O-Resp2\n024573       move  Exci-Sub-Reason1 to OExci-Sub-Reason1                      84\n024574       Write Output-record    from Output-Retarea\n024575       Write Output-record    from Msg14\n024576       Write Output-Record from Output-Retarea\n024577       If Exci-Msg-Ptr equal Nulls\n024578         Continue\n024579       else\n024580         Write Output-Record from Msg13\n024581         Write Output-Record from Msg02\n024582         Set address of Call-Level-Msg to Exci-Msg-Ptr\n024583         Move Spaces to Out-Rec\n024584         Subtract 4 from Call-Level-Msg-Len\n024585         Perform test before\n024586            varying Sub from 1 by 1\n024587            until Sub > Call-Level-Msg-Len\n024588           Move Call-Level-Msg-Text (sub) to Out-Rec-Elem (sub)\n024589         End-Perform\n024590         Write Output-Record from Out-Rec\n024591         Write Output-Record from Msg02\n024592       end-if\n024593       Write Output-Record from Msg27\n024594       Move  Exci-Dpl-Resp to O-Resp\n024595       Move  Exci-Dpl-Resp2 to O-Resp2\n024596       Move  Spaces to Opad-Abcode\n024597       Move  Exci-Dpl-Abcode to O-Abcode\n024598       Write Output-Record from Output-Retarea\n024599       Write Output-Record from Msg14\n024620       Set Abort to true\n024700     end-if\n026800     .\n026900 Dpl-Program-End.\n027000     exit\n027100     .\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EXCIJCL": {"ttr": 5385, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x98\\x18\\x0f\\x00\\x99\\x06\\x0f!1\\x00\\x19\\x00\\x15\\x00\\x00\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1998-06-29T00:00:00", "modifydate": "1999-03-01T21:31:00", "lines": 25, "newlines": 21, "modlines": 0, "user": "XSSGSCH"}, "text": "//IBMUSER JOB (ACCT),'SCHIRADIN, ROLAND',\n//             CLASS=X,MSGCLASS=T,MSGLEVEL=(1,1),\n//             NOTIFY=&SYSUID\n//**********************************************************************\n//* Cemt-Batch Interface\n//* Description:\n//* Close VSAN-Files\n//**********************************************************************\n//EXCI    EXEC PGM=SYEXCI\n//STEPLIB   DD DISP=SHR,DSN=<your.load>,DISP=SHR\n//SYSPRINT  DD SYSOUT=*\n//SYSUDUMP  DD SYSOUT=*\n//**********************************************************************\n//*  1 -8  CICS-ID in the SYSPLEX\n//*  10-17 CEMT COMMAND (SET/PERFORM)\n//*  19-26 CEMT RESOURCE (FILE/PROG)\n//*  28-35 NAME\n//*  37-44 SUBFUNCTION\n//**********************************************************************\n//SYSIN     DD *\nDCCFT01  SET      FILE     TAACONDI CLOSE\nDCCFT01  SET      FILE     TAATRACE CLOSE\nDCCFT01  SET      FILE     TAATIME  CLOSE\nDCCFT01  SET      PROG     TEST     NEW\nDCCFT01  PERFORM  SHUT     I\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EXCIRDO": {"ttr": 5387, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x98\\x18\\x0f\\x00\\x99\\x06\\x0f!2\\x00\\x15\\x00\\t\\x00\\x13\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1998-06-29T00:00:00", "modifydate": "1999-03-01T21:32:00", "lines": 21, "newlines": 9, "modlines": 19, "user": "XSSGSCH"}, "text": "DEFINE PROGRAM(SYEXCISE) GROUP(EXCI) LANGUAGE(ASSEMBLER)\n       DESCRIPTION(Server for Batch Cemt) EXECKEY(USER)\n       DATALOCATION(ANY) CEDF(NO)\nDEFINE TRANSACTION(EXCI) GROUP(EXCI)\n       DESCRIPTION(Transid for Batch)\n       PROGRAM(DFHMIRS) TWASIZE(0)\n       TASKDATAL(ANY) TASKDATAK(USER)\n       PRIORITY(255) PROF(DFHCICSA)\nDEFINE CONNECTION(EXCG) GROUP(EXCI)\n       DESCRIPTION(EXTERNAL CICS GENERIC CONNECTION)\n       ACCESSMETHOD(IRC) PROTOCOL(EXCI) CONNTYPE(GENERIC)\n       SINGLESESS(NO) DATASTREAM(USER) RECORDFORMAT(U) QUEUELIMIT(NO)\n       MAXQTIME(NO) AUTOCONNECT(NO) INSERVICE(YES) ATTACHSEC(IDENTIFY)\n       BINDSECURITY(NO) USEDFLTUSER(NO)\nDEFINE SESSIONS(EXCG) GROUP(EXCI)\n       DESCRIPTION(EXTERNAL CICS GENERIC SESSIONS DEFINITION)\n       CONNECTION(EXCG) PROTOCOL(EXCI) MAXIMUM(0,0) RECEIVEPFX(RG)\n       RECEIVECOUNT(4) SENDSIZE(4096) RECEIVESIZE(4096) SESSPRIORITY(0)\n       AUTOCONNECT(NO) BUILDCHAIN(YES) USERAREALEN(0)\n       IOAREALEN(4096,4096) RELREQ(NO) DISCREQ(NO) NEPCLASS(0)\n       RECOVOPTION(SYSDEFAULT)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EXCISE": {"ttr": 5389, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00B\\x00\\x98\\x18\\x0f\\x01\\x06\\x15?\\x04W\\x00\\xf6\\x00\\xf6\\x00\\x06\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1998-06-29T00:00:00", "modifydate": "2006-06-02T04:57:42", "lines": 246, "newlines": 246, "modlines": 6, "user": "XSSGSCH"}, "text": "*ASM XOPTS(SP)\n***********************************************************************\n*                                                                     *\n* Name:         EXCISE                                                *\n*                                                                     *\n* Author:       Roland Schiradin                                      *\n*                                                                     *\n* Date:         March 1998                                            *\n*                                                                     *\n* Descrition:   Cics ExCi-server for Cemt-Commands                    *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n*=====================================================================*\n*                                                                     *\n*      Working Storage.                                               *\n*                                                                     *\n*=====================================================================*\n*\nDFHEISTG DSECT  ,                    |Program Variables.             |\nEYECATCHER   DC CL10'*EXCISE*'       |                               |\nOPT_FLAG     DS F                    |  Flag indicate Copy-option    |\nCICS_RESP    DS F                    |  CICS-Response Code           |\nTRY_COUNT    DS H                    |  Counter                      |\nWS#ABSTI DS   PL8\nWS#TXTMS     DS   0CL84\nFILL1        DS   CL12\nWS#APPL      DS   CL8\nFILL2        DS   CL9\nWS#SYSID     DS   CL4\nFILL3        DS   CL23\nWS#DATE      DS   CL10\nFILL4        DS   CL4\nWS#TIME      DS   CL8\nFILL5        DS   CL6\nWS#TXTLE     DS   F\n*=====================================================================*\n*                                                                     *\n*      Commarea DSECT.                                                *\n*                                                                     *\n*=====================================================================*\n*\nCOMMAREA DSECT\nCOM_COMMAND  DS CL8                Command\n             DS CL1                Filler\nCOM_TYPE     DS CL8                Type\n             DS CL1                Filler\nCOM_RESOURCE DS CL8                Resource\n             DS CL1                Filler\nCOM_STATUS   DS CL20               Status\n             DS CL1                Filler\nCOM_RC       DS H                  Feedback RC\nCOM_MSG      DS CL80               Message Feedback\n*\nEXCISE   DFHEIENT CODEREG=(R3),DATAREG=(R6,R7)\n*\n*=====================================================================*\n*   Check that a COMMAREA has been passed. If we don't have a commarea*\n*   we cannot even return a return code back to the client, so issue  *\n*   an abend instead.                                                 *\n*=====================================================================*\n         CLC   EIBCALEN,=H'0'\n         BNE   PARSE\n         EXEC CICS ABEND ABCODE('NCOM')\n*\n*=====================================================================*\n*   Map the COMMAREA DSECT onto the Commarea passed.                  *\n*=====================================================================*\nPARSE    DS    0H\n         EXEC CICS ADDRESS COMMAREA(R4)\n         USING COMMAREA,R4              tell assembly\n         MVC   COM_RC,=H'0'             set rc\n         EXEC CICS ASKTIME ABSTIME(WS#ABSTI) NOHANDLE\n*\n         EXEC CICS FORMATTIME ABSTIME(WS#ABSTI)                        *\n               DATESEP('/')     TIMESEP(':')                           *\n               DDMMYYYY(WS#DATE) TIME(WS#TIME) NOHANDLE\n*\n         EXEC CICS ASSIGN                                              *\n               APPLID(WS#APPL)                                         *\n               SYSID(WS#SYSID) NOHANDLE\n         MVC   FILL1,=C'***** Cics: '\n         MVC   FILL2,=C' (Sysid: '\n         MVC   FILL3,=C') Batch-Command issued '\n         MVC   FILL4,=C' at '\n         MVC   FILL5,=C' *****'\n         MVC   WS#TXTLE,=F'84'\n         EXEC CICS WRITE OPERATOR                                      *\n               TEXT(WS#TXTMS) TEXTLENGTH(WS#TXTLE)                     *\n               EVENTUAL NOHANDLE\n*\n***      Check Command\n*\n         CLC   COM_COMMAND,=CL8'SET'      valid\n         BE    CEMT_SET                      yes, do set\n         CLC   COM_COMMAND,=CL8'PERFORM'  valid\n         BE    CEMT_PERFORM                  yes, do perform\n         MVC   COM_MSG,=CL80'Can not process unknown Command'\n         MVC   COM_RC,=H'12'\n         B     RETURN\nCEMT_SET  DS    0H\n         CLC   COM_TYPE,=CL8'PROG'        Programm?\n         BE    CEMT_SET_PROG                 yes, do set\n         CLC   COM_TYPE,=CL8'FILE'        File?\n         BE    CEMT_SET_FILE                 yes, do set\n         CLC   COM_TYPE,=CL8'MONITOR'     Monitoring?\n         BE    CEMT_SET_MONITOR              yes, do set\n         MVC   COM_MSG,=CL80'Can not process unknown Type'\n         MVC   COM_RC,=H'12'\n         B     RETURN\nCEMT_SET_PROG  DS 0H\n         MVC   COM_MSG,=CL80'Newcopy successfull'\n         MVC   OPT_FLAG,DFHVALUE(NEWCOPY)\n         EXEC CICS SET PROGRAM(COM_RESOURCE),COPY(OPT_FLAG),           *\n               RESP(CICS_RESP)\n         CLC   CICS_RESP,DFHRESP(NORMAL)    ok?\n         BE    RETURN                        yes, back\n         CLC   CICS_RESP,DFHRESP(PGMIDERR)  Program not found ?\n         BNE   CEMT_SET_PROG_20               check next\n         MVC   COM_MSG,=CL80'Program not found, Newcopy on first req.'\n         B     RETURN                       back\nCEMT_SET_PROG_20  DS 0H\n         MVC   COM_MSG,=CL80'Program in use, Newcopy for new requests'\n         MVC   OPT_FLAG,DFHVALUE(PHASEIN)\n         EXEC CICS SET PROGRAM(COM_RESOURCE),COPY(OPT_FLAG),           *\n               RESP(CICS_RESP)\n         CLC   CICS_RESP,DFHRESP(NORMAL)    ok?\n         BE    RETURN                        yes, back\n         MVC   COM_MSG,=CL80'Can not perform the Newcopy-Request'\n         B     RETURN                        yes, back\nCEMT_SET_FILE  DS 0H\n         CLC   COM_STATUS(8),=CL8'CLOSE'\n         BE    CEMT_SET_FILE_CLOSE\n         CLC   COM_STATUS(8),=CL8'OPEN'\n         BE    CEMT_SET_FILE_OPEN\n         MVC   COM_MSG,=CL80'Can not process unknown Status'\n         MVC   COM_RC,=H'12'\n         B     RETURN\nCEMT_SET_FILE_CLOSE  DS 0H\n         MVC   COM_MSG,=CL80'Close successfull'\n         MVC   OPT_FLAG,DFHVALUE(CLOSED)\n         EXEC CICS SET FILE(COM_RESOURCE),OPENSTATUS(OPT_FLAG),        *\n               RESP(CICS_RESP)\n         CLC   CICS_RESP,DFHRESP(NORMAL)    ok?\n         BE    RETURN                        yes, back\n         MVC   COM_MSG,=CL80'Can not close this File'\n         MVC   COM_RC,=H'12'\n         B     RETURN                       back\nCEMT_SET_FILE_OPEN  DS 0H\n         MVC   COM_MSG,=CL80'Open successfull'\n         MVC   OPT_FLAG,DFHVALUE(OPEN)\n         EXEC CICS SET FILE(COM_RESOURCE),OPENSTATUS(OPT_FLAG),        *\n               RESP(CICS_RESP)\n         CLC   CICS_RESP,DFHRESP(NORMAL)    ok?\n         BE    RETURN                        yes, back\n         MVC   COM_MSG,=CL80'Can not open this File'\n         MVC   COM_RC,=H'12'\n         B     RETURN                       back\nCEMT_SET_MONITOR DS 0H\n         CLC   COM_RESOURCE(8),=CL8'ON'\n         BE    CEMT_SET_MONITOR_ON\n         CLC   COM_RESOURCE(8),=CL8'OFF'\n         BE    CEMT_SET_MONITOR_OFF\n         MVC   COM_MSG,=CL80'Can not process unknown Status'\n         MVC   COM_RC,=H'12'\n         B     RETURN\nCEMT_SET_MONITOR_ON DS 0H\n         MVC   COM_MSG,=CL80'Monitoring on'\n         MVC   OPT_FLAG,DFHVALUE(ON)\n         EXEC CICS SET MONITOR STATUS(OPT_FLAG)                        *\n               RESP(CICS_RESP)\n         CLC   CICS_RESP,DFHRESP(NORMAL)    ok?\n         BE    RETURN                        yes, back\n         MVC   COM_MSG,=CL80'Can not change Monitoring-Status'\n         MVC   COM_RC,=H'12'\n         B     RETURN                       back\nCEMT_SET_MONITOR_OFF DS 0H\n         MVC   COM_MSG,=CL80'Monitoring off'\n         MVC   OPT_FLAG,DFHVALUE(OFF)            RS0606\n         EXEC CICS SET MONITOR STATUS(OPT_FLAG)                        *\n               RESP(CICS_RESP)\n         CLC   CICS_RESP,DFHRESP(NORMAL)    ok?\n         BE    RETURN                        yes, back\n         MVC   COM_MSG,=CL80'Can not change Monitoring-Status'\n         MVC   COM_RC,=H'12'\n         B     RETURN                       back\nCEMT_PERFORM DS  0H\n         CLC   COM_TYPE,=CL8'SHUT'        Shutdown ?\n         BE    CEMT_PERFORM_SHUT             yes, do set\n         MVC   COM_MSG,=CL80'Can not process unknown Type'\n         MVC   COM_RC,=H'12'\n         B     RETURN\nCEMT_PERFORM_SHUT DS  0H\n         CLC   COM_RESOURCE,=CL8'I'         Shutdown immediate\n         BE    CEMT_PERFORM_SHUT_I           yes, do set\n         MVC   COM_MSG,=CL80'Normal Shutdown'\n         EXEC CICS PERFORM SHUTDOWN,                                   *\n               RESP(CICS_RESP)\n         CLC   CICS_RESP,DFHRESP(NORMAL)    ok?\n         BE    CEMT_PERFORM_SHUT_10          yes, check status\n         MVC   COM_MSG,=CL80'Can not shutdown this CICS'\n         MVC   COM_RC,=H'12'\n         B     RETURN                       back\nCEMT_PERFORM_SHUT_10 DS  0H\n         CLC   TRY_COUNT,=H'2'              Do it 3 times\n         BH    CEMT_PERFORM_SHUT_I           then shutdown asap\n         LH    R5,TRY_COUNT\n         AH    R5,=H'1'\n         STH   R5,TRY_COUNT\n         EXEC CICS DELAY FOR SECONDS(30) NOHANDLE\n         EXEC CICS INQUIRE SYSTEM CICSSTATUS(OPT_FLAG) NOHANDLE\n         CLC   OPT_FLAG,DFHVALUE(ACTIVE)\n         BE    CEMT_PERFORM_SHUT_10          yes, loop\n         CLC   OPT_FLAG,DFHVALUE(FIRSTQUIESCE)\n         BE    CEMT_PERFORM_SHUT_10          yes, loop\n         CLC   OPT_FLAG,DFHVALUE(FINALQUIESCE)\n         BE    RETURN                         ok leave\nCEMT_PERFORM_SHUT_I DS  0H\n         MVC   COM_MSG,=CL80'Shutdown immediate'\n         EXEC CICS PERFORM SHUTDOWN IMMEDIATE                          *\n               RESP(CICS_RESP)\n         CLC   CICS_RESP,DFHRESP(NORMAL)    ok?\n         BE    RETURN                        yes, back\n         MVC   COM_MSG,=CL80'Can not shutdown this CICS'\n         MVC   COM_RC,=H'12'\n         B     RETURN                       back\n*\n*=====================================================================*\n*   All calls return to here.  Control is passed back to the Client   *\n*=====================================================================*\n*\nRETURN   DS    0H\n         MVC   FILL1,=C'***** Cics: '\n         MVC   FILL2,=C' (Sysid: '\n         MVC   FILL3,=C') Batch-Command done   '\n         MVC   FILL4,=C' at '\n         MVC   FILL5,=C' *****'\n         MVC   WS#TXTLE,=F'84'\n         EXEC CICS WRITE OPERATOR                                      *\n               TEXT(WS#TXTMS) TEXTLENGTH(WS#TXTLE)                     *\n               EVENTUAL NOHANDLE\n         EXEC CICS RETURN\nBLANKS   DC  CL256' '\n*\n         DFHREGS\n         END EXCISE\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PIDTABL$": {"ttr": 5636, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x17\\x01\\x16\\x07\\x0f\\x01\\x16\\x07\\x0f\\x167\\x00=\\x00=\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xf0\\xf8@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-03-10T00:00:00", "modifydate": "2016-03-10T16:37:17", "lines": 61, "newlines": 61, "modlines": 0, "user": "SYSP08"}, "text": "    dc cl2'A1',CL10'569623400 ',CL8'ASMA90  ' HIGH LEVEL ASSEMBLEPF0608\n    dc cl2'A2',CL10'566896201 ',CL8'ASMH    ' ASSEMBLER H        PF0608\n    dc cl2'A2',CL10'5734AS1   ',CL8'ASMH    ' OLD                PF0608\n    dc cl2'A3',CL10'360SAS037 ',CL8'IFOX00  ' OLD IFOX           PF0608\n    dc cl2'A3',CL10'360SAS038 ',CL8'IFOX00  ' OLD IFOX           PF0608\n    dc cl2'A3',CL10'52ASM32B88',CL8'IFOX00  ' STRANGE IFOX       PF0608\n    dc cl2'A3',CL10'52ASM31686',CL8'IFOX00  ' STRANGE IFOX       PF0608\n    dc cl2'A3',CL10'5741SC103 ',CL8'IFOX00  ' 1972-1987          PF0608\n    dc cl2'A3',CL10'5734AS100 ',CL8'IFOX00  ' 1977-1992          PF0608\n    dc cl2'A3',CL10'ASMG21FEB ',CL8'ASM-G   ' U of Waterloo ??   RS1208\n    dc cl2'C1',CL10'5648A2500 ',CL8'Cobol370' Cobol for os390/vm HP1107\n    dc cl2'C1',CL10'566895807 ',CL8'COBOL370' COBOL for mvs/vm   HP1107\n    dc cl2'C1',CL10'5655G5300 ',CL8'Ent. Cob' Enterprise Cobol   RS1007\n    dc cl2'C1',CL10'5655S7100 ',CL8'Ent. Cob' Enterprise Cobol V4RS0115\n    dc cl2'C5',CL10'5655W32   ',CL8'Ent. Cob' Enterprise Cobol V5RS0316\n    dc cl2'C5',CL10'5655EC6   ',CL8'Ent. Cob' Enterprise Cobol V6RS0316\n    dc cl2'C1',CL10'568819802 ',CL8'LECOBOL ' LE COBOL           RS1007\n    dc cl2'C2',CL10'566895801 ',CL8'COBOLII ' COBOL II           RS1007\n    dc cl2'C2',CL10'566895901 ',CL8'COBOLII ' COBOL II           RS1007\n    dc cl2'C3',CL10'5740CB103 ',CL8'COBOLVS ' COBOL VS2          RS1007\n    dc cl2'C3',CL10'12345     ',CL8'COBOLVS ' OLD                RS1007\n    dc cl2'C3',CL10'40CB1     ',CL8'COBOLVS ' SEE APAR PP80690   RS1007\n    dc cl2'C3',CL10'40CB-1    ',CL8'CAPEXOPT' CAPEX OPTIMIZER    PF0608\n    dc cl2'C4',CL10'5752SC104 ',CL8'COBOLV4 ' COBOL   V4         RS1007\n    dc cl2'C4',CL10'1234-5    ',CL8'COBOLV4 ' OLD                RS1007\n    dc cl2'E1',CL10'EZTPA00   ',CL8'EZTRIEVE' COMPILED EZTRIEVE+ PF0608\n    dc cl2'F1',CL10' 5796-PKR ',CL8'EXT.EXP.' EXT. EXPONENT FORTRPF0608\n    dc cl2'F1',CL10'5668-806  ',CL8'FORTRANV' FORTRAN VS         PF0608\n    dc cl2'F1',CL10'5748-FO3  ',CL8'FORTRANV' FORTRAN VS         PF0608\n    dc cl2'F1',CL10'568819804 ',CL8'LEFORT  ' LE FORTRAN         PF0608\n    dc cl2'F2',CL10'5734-FO3  ',CL8'FORTRANH' FORTRAN H          PF0608\n    dc cl2'F3',CL10'5734-FO2  ',CL8'FORTRANG' FORTRAN G          PF0608\nPID_ENTRY_UNKFORT DS 0H         Unknown FORTRAN entry            PF0608\n    dc cl2'F?',CL10'????????  ',CL8'FORTRAN?' FORTRAN ?          PF0608\n    dc cl2'I1',CL10'566528444 ',CL8'IEBIMAGE' IEBIMAGE           PF0608\n    dc cl2'I1',CL10'5742SC1UM ',CL8'IEBIMAGE' IEBIMAGE           PF0608\n    dc cl2'I1',CL10'5752SC1UM ',CL8'IEBIMAGE' IEBIMAGE           PF0608\n    dc cl2'L1',CL10'568819801 ',CL8'LECOMMON' LE COMMON EXEC     PF0608\n    dc cl2'P1',CL10'568819803 ',CL8'LEPL/I  ' LE PL/I            PF0608\n    dc cl2'P1',CL10'5688-235  ',CL8'PL1     ' PL/1 FOR MVS AND VMPF0608\n    dc cl2'P2',CL10'5668-910  ',CL8'PL1     ' PL/1 V2            PF0608\n    dc cl2'P3',CL10'5734-PL1  ',CL8'PL1     ' PL/1 V1            PF0608\n    dc cl2'R1',CL10'5740RG1   ',CL8'RPG     ' RPG                PF0608\n    dc cl2'S1',CL10'566876701 ',CL8'PASCAL  ' PASCAL             PF0608\n    dc cl2'T1',CL10'TMCOMPIL  ',CL8'XPEDITER' XPIDITER           PF0608\n    dc cl2'U1',CL10'5694A01   ',CL8'z/OS C  ' C/C++              PF0608\n    dc cl2'U1',CL10'5645001   ',CL8'LE_C++r2' OS/390 v1r2        PF0608\n    dc cl2'U1',CL10'568819805 ',CL8'LEC++   ' LE C++             PF0608\n    dc cl2'U1',CL10'5647A01   ',CL8'OS/390 C' C/C++              PF0608\n    dc cl2'U2',CL10'5688187   ',CL8'C370    ' C/370              PF0608\n    dc cl2'U2',CL10'5688216   ',CL8'C370    ' C/370              PF0608\n    dc cl2'U2',CL10'5688040   ',CL8'C370    ' C/370              PF0608\n    dc cl2'U3',CL10'SAS/C     ',CL8'SAS/C   ' SAS/C              PF0608\n    dc cl2'U3',CL10'LC370B    ',CL8'SAS/C   ' SAS/C              PF0608\n    dc cl2'U3',CL10'SAS/C/    ',CL8'SAS/C   ' SAS/C              PF0608\n    dc cl2'U3',CL10'SDS080888 ',CL8'SAS/C   ' SAS/C              PF0608\n    dc cl2'U3',CL10'BLD121988 ',CL8'SAS/C   ' SAS/C              PF0608\n    dc cl2'X1',CL10'569501301 ',CL8'REXX370 ' COMPILED REXX      PF0608\n    dc cl2'Z1',CL10'PL/X-370  ',CL8'PL/X-370' PL/X               PF0608\n    dc cl2'Z2',CL10'CA-PLNK 0 ',CL8'CA PL/S ' CA-PL/S CLONE      PF0608\n    dc cl2'Z2',CL10'C''PLS-III''',CL8'PLS-III ' PLS-III          PF0608\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PIDTABLE": {"ttr": 5638, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00\\x08\\x01\\x08\\x18\\x0f\\x01\\x18%\\x7f\\x06\\x02\\x00Q\\x00:\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xf0\\xf8@@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2008-06-28T00:00:00", "modifydate": "2018-09-14T06:02:08", "lines": 81, "newlines": 58, "modlines": 0, "user": "SYSP08"}, "text": "    DC CL2'A1',CL10'569623400 ',CL8'ASMA90  ' HIGH LEVEL ASSEMBLEPF0608\n    DC CL2'A2',CL10'566896201 ',CL8'ASMH    ' ASSEMBLER H V2     PF0718\n    DC CL2'A2',CL10'5734AS1   ',CL8'ASMH    ' ASSEMBLER H OS/360 PF0718\n    DC CL2'A3',CL10'360SAS037 ',CL8'IEUASM  ' OS/360 ASM F       PF0718\n    DC CL2'A3',CL10'360SAS038 ',CL8'IEUASM  ' OS/360 ASM ?       PF0718\n    DC CL2'A3',CL10'52ASM32B88',CL8'IFOX00  ' STRANGE IFOX       PF0608\n    DC CL2'A3',CL10'52ASM31686',CL8'IFOX00  ' STRANGE IFOX       PF0608\n    DC CL2'A3',CL10'5741SC103 ',CL8'IFOX00  ' 1972-1987          PF0608\n    DC CL2'A3',CL10'5734AS100 ',CL8'IFOX00  ' 1977-1992          PF0608\n    DC CL2'A3',CL10'ASMG21FEB ',CL8'ASM-G   ' U of Waterloo ??   RS1208\n    DC CL2'A3',CL10'ASMG21SEP ',CL8'ASM-G   ' U of Waterloo ??   PF0718\n    DC CL2'C1',CL10'5648A2500 ',CL8'Cobol370' Cobol for os390/vm HP1107\n    DC CL2'C1',CL10'566895807 ',CL8'COBOL370' COBOL for mvs/vm   HP1107\n    DC CL2'C1',CL10'5655G5300 ',CL8'EntCOBOL' Enterprise Cobol V3RS1007\n    DC CL2'C1',CL10'5655S7100 ',CL8'EntCOBOL' Enterprise Cobol V4RS1007\n    DC CL2'C5',CL10'5655W32   ',CL8'EntCOBOL' Enterprise Cobol V5RS0316\n    DC CL2'C5',CL10'5655EC6   ',CL8'EntCOBOL' Enterprise Cobol V6RS0316\n    DC CL2'C1',CL10'568819802 ',CL8'LEntCob ' LE COBOL           RS1007\n    DC CL2'C2',CL10'566895801 ',CL8'COBOLII ' COBOL II           RS1007\n    DC CL2'C2',CL10'566895901 ',CL8'COBOLII ' COBOL II           RS1007\n    DC CL2'C3',CL10'5740CB103 ',CL8'COBOLVS ' COBOL VS2          RS1007\n    DC CL2'C3',CL10'12345     ',CL8'COBOLVS ' OLD                RS1007\n    DC CL2'C3',CL10'40CB1     ',CL8'COBOLVS ' SEE APAR PP80690   RS1007\n    DC CL2'C3',CL10'40CB-1    ',CL8'CAPEXOPT' CAPEX OPTIMIZER    PF0608\n    DC CL2'C4',CL10'5734CB2   ',CL8'COBOL V4' ANS COBOL V4 (ANS4)RS1007\n    DC CL2'C4',CL10'1234-5    ',CL8'COBOL V4' OLD                RS1007\n    DC CL2'C4',CL10'5734CB1   ',CL8'COBOL V3' ANS COBOL V3       PF0718\n    DC CL2'C4',CL10'360SCB545 ',CL8'COBOL V1' ANS COBOL V1/2     PF0718\n    DC CL2'C4',CL10'360SCB524 ',CL8'COBOL F ' COBOL (F)          PF0718\n    DC CL2'C4',CL10'360SCO503 ',CL8'COBOL E ' COBOL (E)          PF0718\nPID_ENTRY_UNKCOBL DS 0H         Unknown COBOL entry ANS 1/2, (F)?PF0718\n    DC CL2'C?',CL10'????????  ',CL8'COBOL?  ' COBOL ?            PF0608\n    DC CL2'E1',CL10'EZTPA00   ',CL8'EZTRIEVE' COMPILED EZTRIEVE+ PF0608\n    DC CL2'F1',CL10' 5796-PKR ',CL8'EXT.EXP.' EXT. EXPONENT FORTRPF0608\nPID_ENTRY_FORTV26 DS 0H         VS FORTRAN V2.6 ENTRY            PF0718\n    DC CL2'F1',CL10'5688-087  ',CL8'FORTVS26' VS FORTRAN V2.6    PF0718\nPID_ENTRY_FORTV2D DS 0H         VS FORTRAN V2/DBG ENTRY          PF0718\n    DC CL2'F1',CL10'5668-806  ',CL8'FORTVS2D' VS FORTRAN V2.x/DBGPF0718\nPID_ENTRY_FORTV1  DS 0H         VS FORTRAN V1 ENTRY              PF0718\n    DC CL2'F1',CL10'5748-FO3  ',CL8'FORTVS1 ' VS FORTRAN V1      PF0718\n    DC CL2'F1',CL10'568819804 ',CL8'LEFORT  ' LE FORTRAN         PF0608\n    DC CL2'F2',CL10'5734-FO3  ',CL8'FORTEXTH' FORTRAN H EXTENDED PF0718\n    DC CL2'F3',CL10'5734-FO2  ',CL8'FORTRANG' FORTRAN G1         PF0718\nPID_ENTRY_FORT4H  DS 0H         FORTRAN H (OS/360) ENTRY         PF0718\n    DC CL2'F4',CL10'360SFO500 ',CL8'FORT360H' OS/360 FORTRAN H   PF0718\n    DC CL2'F4',CL10'360SFO520 ',CL8'FORT360G' OS/360 FORTRAN G   PF0718\nPID_ENTRY_UNKFORT DS 0H         Unknown FORTRAN entry            PF0608\n    DC CL2'F?',CL10'????????  ',CL8'FORTRAN?' FORTRAN ?          PF0608\n    DC CL2'I1',CL10'566528444 ',CL8'IEBIMAGE' IEBIMAGE           PF0608\n    DC CL2'I1',CL10'5742SC1UM ',CL8'IEBIMAGE' IEBIMAGE           PF0608\n    DC CL2'I1',CL10'5752SC1UM ',CL8'IEBIMAGE' IEBIMAGE           PF0608\n    DC CL2'L1',CL10'568819801 ',CL8'LECOMMON' LE COMMON EXEC     PF0608\n    DC CL2'P1',CL10'568819803 ',CL8'LEPL/I  ' LE PL/I            PF0608\n    DC CL2'P1',CL10'5688-235  ',CL8'PL1     ' PL/1 FOR MVS AND VMPF0608\n    DC CL2'P2',CL10'5668-910  ',CL8'PL1     ' PL/1 V2            PF0608\n    DC CL2'P3',CL10'5734-PL1  ',CL8'PL1     ' PL/1 V1            PF0608\nPID_ENTRY_PL1F DS 0H            PL/1 (F) (OS/360)                PF0718\n    DC CL2'P4',CL10'360SNL511 ',CL8'PL1(F)  ' PL/1 (F) (OS/360)  PF0718\nPID_ENTRY_RPG2 DS 0H            RPG II   (OS/VS)                 PF0718\n    DC CL2'R1',CL10'5740RG1   ',CL8'RPG     ' OS/VS RPG II       PF0718\n    DC CL2'S1',CL10'566876701 ',CL8'PASCAL  ' PASCAL             PF0608\n    DC CL2'T1',CL10'TMCOMPIL  ',CL8'XPEDITER' XPIDITER           PF0608\n    DC CL2'U1',CL10'5694A01   ',CL8'z/OS C  ' C/C++              PF0608\n    DC CL2'U1',CL10'5645001   ',CL8'LE_C++r2' OS/390 v1r2        PF0608\n    DC CL2'U1',CL10'568819805 ',CL8'LEC++   ' LE C++             PF0608\n    DC CL2'U1',CL10'5647A01   ',CL8'OS/390 C' C/C++              PF0608\n    DC CL2'U2',CL10'5688187   ',CL8'C370    ' C/370              PF0608\n    DC CL2'U2',CL10'5688216   ',CL8'C370    ' C/370              PF0608\n    DC CL2'U2',CL10'5688040   ',CL8'C370    ' C/370              PF0608\n    DC CL2'U2',CL10'5650ZOS   ',CL8'z/OS C  ' z/OS C/C++/MetalC  PF0608\n    DC CL2'U3',CL10'SAS/C     ',CL8'SAS/C   ' SAS/C              PF0608\n    DC CL2'U3',CL10'LC370B    ',CL8'SAS/C   ' SAS/C              PF0608\n    DC CL2'U3',CL10'SAS/C/    ',CL8'SAS/C   ' SAS/C              PF0608\n    DC CL2'U3',CL10'SDS080888 ',CL8'SAS/C   ' SAS/C              PF0608\n    DC CL2'U3',CL10'BLD121988 ',CL8'SAS/C   ' SAS/C              PF0608\n    DC CL2'X1',CL10'569501301 ',CL8'REXX370 ' COMPILED REXX      PF0608\n    DC CL2'Z1',CL10'PL/X-370  ',CL8'PL/X-370' PL/X 370           PF0608\n    DC CL2'Z1',CL10'PL/X-390  ',CL8'PL/X-390' PL/X 390           PF0718\n    DC CL2'Z2',CL10'CA-PLNK 0 ',CL8'CA PL/S ' CA-PL/S CLONE      PF0608\n    DC CL2'Z2',CL10'C''PLS-III''',CL8'PLS-III ' PLS-III          PF0608\n    DC CL2'Z3',CL10'C''PL/AS''  ',CL8'PL/AS   ' PL/AS            PF0718\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SISPEXEC": {"ttr": 5641, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x023\\x1f\\x01\\x023\\x1f\\x002$\\x01$\\x01\\x00\\x00\\xc6\\xd9\\xc1\\xd3\\xc2\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-27T00:00:00", "modifydate": "2002-11-27T00:32:00", "lines": 9217, "newlines": 9217, "modlines": 0, "user": "FRALBER"}, "text": "./ ADD NAME=$$README 0100-99159-99159-0712-00044-00044-00000-DESTS03\n     ----------------------- ISPF application --------------------------\n\n     supplement to CBT File 419\n\n     COBA      This Application analyse the output from the\n               Cobol analyse program developed by Roland Schiradin\n               Roland(at)Schiradin.de\n               To simlify the procedure, the program COBANAL is\n               included in this library\n               This application requires ISPF Version 4\n               The application consist of 4 datasets.\n               Rexx library\n               Panel Library\n               Message and Skeleton Library\n               Table Libary\n\n               You have to change member $COBA in the Rexx library\n               See section/label Coba_Parms thru End_Coba_Parms.\n               Please change the following variables to your standards\n\n               ACCOUNT\n               CLASS\n               MSGCLASS\n               STEPLIB\n               ISPFHLQ\n               COBAAPPL\n               COBAHLQ\n               LLQCLIB\n               LLQPLIB\n               LLQMLIB\n               LLQSLIB\n               LLQTLIB\n               LLQTABL\n\n               After these changes you can execute procedure $COBA\n               First you'll see a selection panel to display\n               or create analyse tables.\n\n               If you have any problems, comments or improvements\n               please contact\n               Alber(at)alber-edv.de\n               If case of a problem please send the output from\n               the COBANAL program and the edited output file.\n\n./ ADD NAME=$$WHATSN 0101-99348-99348-1649-00003-00002-00000-DESTS03\nCOBANAL  A new version\nSISP*    The ISPF interface changed rexx's and panels\n         for new output from COBANAL program\n./ ADD NAME=$COBA    0101-99265-99350-0738-00072-00072-00000-EX31022\n/*---- REXX -- COPYRIGHT - 1999 -- COBA ---- ISPF-DIALOG -----*/\n/*                                                            */\n/*     COBOL ANALYSE ISPF DIALOG                              */\n/*     supplement to cbt file 419 program cobanal             */\n/*     developed by roland schiradin                          */\n/*                                                            */\n/*     Fritz Alber                                            */\n/*     Albstr. 19                                             */\n/*     D 72649 Wolfschlugen                                   */\n/*     TEL. 0049-7022/959234                                  */\n/*     FAX. 0049-7022/959236                                  */\n/*                                                            */\n/*     E-MAIL  : Alber\u00a7alber-edv.de                           */\n/*     INTERNET: www.alber-edv.de                             */\n/*                                                            */\n/*     Please customize section Coba_parms to your values     */\n/*                                                            */\n/*------------------------------------------------------------*/\n\nCoba_Parms:              /*  -------- Start COBA Parms ------ */\n                         /*  --------- JCL Parameters ------- */\nACCOUNT = '#ACCNT'       /*  Account Info for JOB card        */\nCLASS   = 'S'            /*  Job class                        */\nMSGCLASS= 'T'            /*  Job message class                */\nISPFHLQ = 'ISP'          /*  ISPFHLQ = HLQ for ISP system dsn */\n                         /*  Steplib for COBANAL program      */\nSTEPLIB = 'EX31022.COBA.SISPLOAD'\n                         /*  ------- End JCL Parameters ----- */\n                         /*  ----------- ISPF Parms --------- */\nCOBAHLQ = 'EX31022.COBA' /*  COBAHLQ = HLQ for COBA ISPF appl */\n                         /*                                   */\nCOBAAPPL = COBA          /*  ISPF Application name for COBA   */\n                         /*  application                      */\nLLQCLIB  = SISPEXEC      /*  LOW LEVEL QUALIFIER for EXEC and */\n                         /*  CLISTS. Change to your value     */\nLLQMLIB  = SISPMENU      /*  LOW LEVEL QUALIFIER for  MESSAGES*/\n                         /*  Change to your value             */\nLLQPLIB  = SISPPENU      /*  LOW LEVEL QUALIFIER for  PANELS  */\n                         /*  Change to your value             */\nLLQSLIB  = SISPMENU      /*  LOW LEVEL QUALIFIER for  SKELS   */\n                         /*  Change to your value             */\nLLQTLIB  = SISPTENU      /*  LOW LEVEL QUALIFIER for  TABLE   */\n                         /*  INPUT. Change to your value      */\nLLQTABL  = SISPTENU      /*  LOW LEVEL QUALIFIER for  TABLE   */\n                         /*  OUTPUT. Change to your value     */\n                         /*  ------- End of ISPF Parms ------ */\nEnd_Coba_Parms:          /*  ------  End of Coba Parms ------ */\n\nADDRESS TSO\n\"ALTLIB ACTIVATE APPL(CLIST) DATASET('\"COBAHLQ\".\"LLQCLIB\"')\"\n\nADDRESS ISPEXEC\n\"LIBDEF ISPMLIB DATASET ID('\"COBAHLQ\".\"LLQMLIB\"') STACK\"\n\"LIBDEF ISPPLIB DATASET ID('\"COBAHLQ\".\"LLQPLIB\"') STACK\"\n\"LIBDEF ISPSLIB DATASET ID('\"COBAHLQ\".\"LLQSLIB\"') STACK\"\n\"LIBDEF ISPTLIB DATASET ID('\"COBAHLQ\".\"LLQTLIB\"') STACK\"\n\"LIBDEF ISPTABL DATASET ID('\"COBAHLQ\".\"LLQTABL\"') STACK\"\n\n\"SELECT CMD(COBANL \" STEPLIB COBAAPPL COBAHLQ ,\n            LLQCLIB LLQMLIB LLQPLIB LLQSLIB LLQTLIB LLQTABL ,\n            ACCOUNT CLASS MSGCLASS ISPFHLQ\") ,\n            PASSLIB NEWAPPL(\"COBAAPPL\")\"\n\n\"LIBDEF ISPMLIB\"\n\"LIBDEF ISPPLIB\"\n\"LIBDEF ISPSLIB\"\n\"LIBDEF ISPTLIB\"\n\"LIBDEF ISPTABL\"\n\nADDRESS TSO \"ALTLIB DEACTIVATE APPL(CLIST)\"\n\nEXIT\n./ ADD NAME=COBA#MAC 0101-00010-00346-0953-00239-00239-00001-DESTS03\n/* REXX */\nTRACE\nADDRESS ISPEXEC\n\"ISREDIT MACRO\"\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'was loaded' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Sorry no'   ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'You better' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Can not estab' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND '=== End  ====' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'No call'    ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'No program' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Call Liter' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Call iden'  ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Call address'  ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Copy-'      ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Program has' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Program use' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND ' DATA DIVISION' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND ' ENVIROMENT DIVISION' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Additional' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'User supplied' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Following' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Installation def' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'hexadecimal' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Exponent' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Floating' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Basis-St' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Shift-In' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Compilation' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT CHANGE 'no Default' 'no-Default'                          ALL\"\n\"ISREDIT RESET\"\n\"ISREDIT CHANGE 'SIZE(value)SOURCE' 'SIZE(value) SOURCE'           ALL\"\n\"ISREDIT RESET\"\n\"ISREDIT CHANGE 'SIZE(value)NOSOURCE' 'SIZE(value) NOSOURCE'       ALL\"\n\"ISREDIT RESET\"\n\"ISREDIT CHANGE 'Go to' 'Go-to'                                    ALL\"\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT BOUNDS 1 50\"\n\"ISREDIT FIND '                                                  ' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT CHANGE 'NO TRACE ' 'NO-TRACE '                            ALL\"\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT BOUNDS 1 50\"\n\"ISREDIT FIND '==================================================' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT BOUNDS 1 20\"\n\"ISREDIT FIND 'Open Exten' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Error during load' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'DBCS-Name in' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT BOUNDS 1 3\"\n\"ISREDIT FIND 'No ' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT BOUNDS\"\n\"ISREDIT END \"\nEXIT\n./ ADD NAME=COBAI34\n/*-------- REXX -------------------------------------------*/\n/* Function   : display information ISPF 3.4 panel         */\n/* callers    : COBA application                           */\n/*---------------------------------------------------------*/\n/*\n   TRACE ?R\n*/\n\narg type arg1 arg2\n\nif type = 'VOL'\nthen do\n  zdldsnlv = \" \"\n  zdlpvl   = arg1\nend\nelse do\n  if type = 'BOTH'\n  then do\n    zdldsnlv = arg1\n    zdlpvl   = arg2\n  end\n  else do\n    zdldsnlv = arg1\n    zdlpvl   = \"\"\n  end\nend\n\n\"ispexec vput (zdldsnlv zdlpvl) profile\"\n\"ISPEXEC SELECT PGM(ISRUDL) PARM(ISRUDLP)\"\n\nexit\n./ ADD NAME=COBANAL  0100-02015-02015-1439-02075-02075-00000-EX31022\n***********************************************************************\n*                                                                     *\n* Name:         COBANAL                                               *\n*                                                                     *\n* Author:       Roland Schiradin                                      *\n*               roland(at)Schiradin.de                                *\n*                                                                     *\n* Date:         Februar 1996                                          *\n*                                                                     *\n* Description:  Show compile-settings and some other information      *\n*                                                                     *\n* Changes:      16.12.1996 (european)                                 *\n*               Support for VS/COBOL1 (just a few)                    *\n*               String macro no longer inside this source             *\n*               (request FILE183 from Naspa or drop me an email)      *\n*               28.04.1997 (european)                                 *\n*               Support for COBOL for MVS and VM Release 2 (formally  *\n*               called AD/Cycle COBOL/370)                            *\n*               04.03.1998 (european)                                 *\n*               MODID-marco dropped                                   *\n*               Direct Load-Library support                           *\n*               Some parts of Dave Alcocks code (DA$COBR)             *\n*               (You can contact him at dalcock(at)csw.com)           *\n*               24.03.1998 (european)                                 *\n*               Prevent S15D abend you invoke COBANAL from TSO-CALL   *\n*               (reported by Dave Alcock)                             *\n*               Support for newer STRING macro STRING GENERATE instead*\n*               of STRING FINAL_CALL                                  *\n*               (reported by Dave Alcock)                             *\n*               Fixed a bug in statement list. Y now means Yes and not*\n*               vice versa. Sorry                                     *\n*               15.02.1999 (european)                                 *\n*               Support for COBOL OS/390 and VM V2R1                  *\n*               Some new Compile-options                              *\n*               Compile-Date is European style, added long name       *\n*               Some minor fixes I cant remember in detail            *\n*               Support for MVS 4.3 (AMODE switching)                 *\n*               10.06.1999 (european)                                 *\n*               Fixed bugs reported by Mr. Smets (Thank you)          *\n*               Show ?? as the century for COBOL2                     *\n*               Support for Entrypoints (e.g. ENTRY 'DLITCBL')        *\n*               Note: There is no need to do this for IMS             *\n*               25.10.1999 (european)                                 *\n*               Check ParmLength for Parameter \"ALL\".                 *\n*               Close all datasets                                    *\n*               Make CobAnal reentrant (LinkList!!!)                  *\n*               Release storage                                       *\n*               Load modules from DD COBANAL if exist                 *\n*               29.12.1999 (european)                                 *\n*               Abend 0C4 fixed                                       *\n*               Add PPA2 support                                      *\n*               Detect C/C++ and LE-enabled Assembler Programs        *\n*               The product name for COBOL1 is OS/VS Cobol (MVS) and  *\n*               DOS/VS COBOL (VSE)                                    *\n*               13.04.2000 (european)                                 *\n*               Support for some infos I missed (INVOKE, GLOBAL and   *\n*               so on) Thank you Mr. Gross                            *\n*               Add a third base register                             *\n*               23.04.2000 (european)                                 *\n*               Tested with STRING V507 from FILE183                  *\n*               19.07.2000 (european)                                 *\n*               Support for COBOL1 OEM products (e.g. CA-Optimzer)    *\n*               Thank you Mr. Pfeifer                                 *\n*               02.10.2000 (european)                                 *\n*               Support for COBOL for OS/390 & VM V2R2                *\n*               New TEST(SEPARATE)/NO TEST(SEPARATE)                  *\n*               New ARITH(EXTEND)/ARITH(COMPAT)                       *\n*               New line-sequential file                              *\n*               Thank you IBM for HFS-Support and Display under CICS  *\n*               Save some literal pool                                *\n*               I know I need to re-design the program but the        *\n*               time (you may know) is limited. At the start it       *\n*               was intend to run once and then throw it away         *\n*               Thanks for all ideas to do it better, if I'm retired  *\n*               I would spent some time on it. Don't expect that      *\n*               within the next 25 years !!!                          *\n*               09.10.1999 (european)                                 *\n*               End-Substract changed to End-Subtract                 *\n*               Corect a length for moving literal Subtract           *\n*               08.01.2001 (european)                                 *\n*               Loop bug fixed                                        *\n*               04.12.2001 (european)                                 *\n*               Fixed buf reporting CLOSE Y/N                         *\n*               Support for Cobol Enterprise V3R1 (BETA)              *\n*               Support for generic member names                      *\n*                 You can use ? or * in the member name to minimize   *\n*                 output instead of ALL or a single load member       *\n*                 '?' stand for any single character                  *\n*                 '*' stand for any character                         *\n*                 Be aware this feature require SYS1.MODGEN(ASAXWC)   *\n*                 introduced with MVS 5.2                             *\n*               ** Attention ****                                     *\n*                  CobAnal require MVS 5.2                            *\n*               ** Attention ****                                     *\n*               ASAXWC is not GUPI but I raised a requirement         *\n*               If you think ASAXWC might be useful for you too,      *\n*               please open a requirement                             *\n***********************************************************************\n         TITLE 'Show Compile-Option and some more nice info'\nCOBANAL  CSECT\nCOBANAL  AMODE 31\nCOBANAL  RMODE 24\n         BAKR  R14,R0             Save register\n         LA    R10,1\n         LR    R6,R15             set base register\n         LA    R7,4095(R10,R6)    second base register\n         LA    R12,4095(R10,R7)   third base register\n         USING COBANAL,R6,R7,R12     Addressebility\n         L     R9,0(R1)           Save Parmlist\n         USING COBANAL_PARM,R9    addressebility\n         LA    R0,COBANAL_WORK_LENGTH\n         STORAGE OBTAIN,LENGTH=(R0),ADDR=(R1),COND=NO,LOC=BELOW\n         LR    R11,R1             COBANAL_WORK register\n         USING COBANAL_WORK,R11   addressebility\n         MVC   EYECATCHER,=CL8'COBANAL'\n         MVI   DOALL,C'N'         Default\n         MVI   DD_COBANAL,C'N'    Default\n         XC    SAVEAREA,SAVEAREA  clear saveare\n         LA    R15,SAVEAREA       get address of savearea\n         ST    R13,4(,R15)        chain the savearea back pointer\n         ST    R15,8(,R13)        chain saveare forward\n         LR    R13,R15            set new savearea\n         ST    R11,ADR_COBANAL_WORK  save address\n         ST    R9,ADR_COBANAL_PARM   save address\n*------------------------------------------------------------*\n*        Check JCL-Parm                                      *\n*------------------------------------------------------------*\n         MVC   PARM_LENGTH,COBANAL_PARM_LENGTH\n         LH    R10,PARM_LENGTH\n         LA    R9,2(R9)            jump length field\n         MVC   PGMNAME,BLANKS      clear PGMNANE\n         MVC   PGMNAME_GET,BLANKS  clear PGMNANE GETMEM\n         LA    R8,PGMNAME          first parm\nCOBANAL_010 DS  0H                 do until first ',' or end\n         CLI   0(R9),C','          parm separator\n         BE    COBANAL_020         next parm\n         MVC   0(1,R8),0(R9)\n         LA    R8,1(R8)            next digit\n         LA    R9,1(R9)            next digit\n         BCT   R10,COBANAL_010     loop\nCOBANAL_020 DS  0H\n         MVC   SYSPRINT(SYSPRINT_FIX_LENGTH),SYSPRINT_FIX\n         MVC   PARMLIST(C_LSTOL),C_LSTO\n         LA    R9,SYSPRINT\n         USING IHADCB,R9\n         MVC   DCBDDNAM,=C'SYSPRINT'\n         OPEN  ((R9),OUTPUT),MF=(E,PARMLIST)\n         DROP  R9\n         DEVTYPE =CL8'COBANAL',DOUBLE     Get COBANAL information\n         LTR   R15,R15                    Is it allocated?\n         BNZ   COBANAL_021                No, continue\n         MVI   DD_COBANAL,C'Y'    Default\n         MVC   INPUT(INPUT_FIX_LENGTH),INPUT_FIX\n         MVC   PARMLIST(C_LSTIL),C_LSTI\n         LA    R9,INPUT\n         USING IHADCB,R9\n         MVC   DCBDDNAM,=C'COBANAL '\n         OPEN  ((R9),INPUT),MF=(E,PARMLIST)\n         DROP  R9\nCOBANAL_021 DS  0H\n         STRING 'COBOL module analysis is starting',INTO=RECORD\n         BAL   R14,SPACE1                 Print starting message\n         CLC   PGMNAME,BLANKS      check PGMNAME\n         BE    COBANAL_PARM_ERROR  if clear ==> Error\n         CLC   PGMNAME(3),=C'ALL'  PGMNAME = ALL indicate analyzing\n         BNE   COBANAL_025         a complete Load, but check for\n         CLC   PARM_LENGTH,=H'3'   length; maybe it is a prog called\n         BNE   COBANAL_025         ALLWAYS :-))\n         CLI   DD_COBANAL,C'Y'        Did you read the docs?\n         BE    COBANAL_022           yes, thats fine\n         STRING 'Parameter=ALL specified but DD-Name COBANAL missing', *\n               INTO=RECORD\n         BAL   R14,SPACE1                 Print starting message\n         MVC   RETCODE,=F'12'\n         B     COBANAL_EXIT         no, leave\n** Loop\nCOBANAL_022 DS  0H\n         MVI   DOALL,C'Y'          remember that\n         BAL   R14,GETMEM          get the member name\n         CLC   PGMNAME_GET,XFF         more entries?\n         BE    COBANAL_EXIT          leave\n*------------------------------------------------------------*\n*        Load the progamm from DD COBANAL                    *\n*------------------------------------------------------------*\n         LOAD  EPLOC=PGMNAME_GET,DCB=INPUT,ERRET=COBANAL_LOAD_ERROR\n         B     COBANAL_027\nCOBANAL_025 DS  0H\n         LA    R5,PGMNAME         start search at address\n         LA    R4,L'PGMNAME       length of string to be searched\n         AR    R4,R5              + start of address\n         LA    R0,C'?'            search for ?\n         SRST  R4,R5              issue search\n         BC    4,COBANAL_028      wildcard ? found\n         LA    R5,PGMNAME         start search at address\n         LA    R4,L'PGMNAME       length of string to be searched\n         AR    R4,R5              + start of address\n         LA    R0,C'*'            search for *\n         SRST  R4,R5              issue search\n         BC    4,COBANAL_028      wildcard * found\n         MVC   PGMNAME_GET,PGMNAME\n         CLI   DD_COBANAL,C'Y'    load from DD Cobanal ?\n         BE    COBANAL_026           yes\n*------------------------------------------------------------*\n*        Load the progamm                                    *\n*------------------------------------------------------------*\n         LOAD  EPLOC=PGMNAME_GET   Load the pgm\n         B     COBANAL_027\nCOBANAL_026 DS  0H\n*------------------------------------------------------------*\n*        Load the progamm from DD COBANAL                    *\n*------------------------------------------------------------*\n         LOAD  EPLOC=PGMNAME,DCB=INPUT,ERRET=COBANAL_LOAD_ERROR\nCOBANAL_027 DS  0H\n         LTR   R15,R15             check response\n         BNZ   COBANAL_LOAD_ERROR if greater zero ==> Error\n         ST    R0,ADR_PGMNAME      save the address\n*------------------------------------------------------------*\n*        Check length                                        *\n*------------------------------------------------------------*\n         CSVQUERY SEARCH=JPALPA,       SEARCH JPAQ                     +\n               INADDR=ADR_PGMNAME,     ADDRESS                         +\n               OUTLENGTH=CSV_LENGTH,                                   +\n               MF=(E,CSVQRYWK)         WORK AREA\n         LTR   R2,R15                  pass return code\n         BNZ   COBANAL_CSV_ERROR if greater zero ==> Error\n         B     COBANAL_03\nCOBANAL_028 DS  0H\n         MVI   DOALL,C'X'          remember that (eXclude)\n         BAL   R14,GETMEM          get the member name\n         CLC   PGMNAME_GET,XFF         more entries?\n         BE    COBANAL_EXIT          leave\n         ASAXWC    PATTERNSTR=PGMNAME,                                 X\n               PATTERNSTRLEN==A(L'PGMNAME),                            X\n               STRING=PGMNAME_GET,                                     X\n               STRINGLEN==A(L'PGMNAME_GET),                            X\n               ZEROORMORE==CL1'*',                                     X\n               ONECHAR==CL1'?',                                        X\n               DELIMITER==CL1' ',                                      X\n               RETCODE=RETCODE,                                        X\n               MF=(E,MYLIST)\n*        STRING 'Program Name= ',PGMNAME_GET,                          @\n               ' Pattern= ',PGMNAME,'RC= ',(RETCODE,,X),               @\n               INTO=RECORD                    debug\n*        BAL   R14,SPACE1\n         CLC   RETCODE,=F'0'\n         BNE   COBANAL_028\n*------------------------------------------------------------*\n*        Load the progamm from DD COBANAL                    *\n*------------------------------------------------------------*\n         LOAD  EPLOC=PGMNAME_GET,DCB=INPUT,ERRET=COBANAL_LOAD_ERROR\n         B     COBANAL_027\n*------------------------------------------------------------*\n*        Write info to sysprint                              *\n*------------------------------------------------------------*\nCOBANAL_03 DS  0H\n         STRING 'Program Name= ',PGMNAME_GET,                          @\n               ' was loaded into storage at EPA= ',(ADR_PGMNAME,,X),   @\n               INTO=RECORD\n         BAL   R14,SPACE1\n*\n*        Dump the first 256 Bytes for Identification.\n*        Should be activate only in case of problems\n*\n*        L     R4,ADR_PGMNAME\n*        LA    R3,256/16               LOOP COUNTER\n*LOOP\nCOBANAL_04 DS  0H\n*        STRING 4X,((R4),4,X),1X,(4(R4),4,X),1X,(8(R4),4,X),1X,        X\n               (12(R4),4,X),3X,((R4),16),                              $\n               INTO=RECORD\n*        BAL   R14,SPACE1          <== next line\n*        LA    R4,016(,R4)             BUMP POINTER\n*        BCT   R3,COBANAL_04\n*ENDLOOP\n         L     R4,ADR_PGMNAME       Load-Entry-Point\n         USING COBOL_370_DSECT,R4\n         CLC   CSV_LENGTH,=F'24'    At least 24 bytes!!!\n         BNH   COBANAL_06            prevent S0C4\n         CLC   CEE_EYECATCHER,C_COBOL370   COBOL/370 ?  X'00C3C5C5'\n         BE    COBOL_370\n         CLC   CEE_EYECATCHER,C_OPLINK     C         ?  X'01C3C5C5'\n         BE    C_370\n         USING COBOL_2_DSECT,R4\n         CLC   C2_EYECATCHER,=CL4' C2 '     COBOL/2 ?  X'40C3F240'\n         BE    COBOL_2\n         USING COBOL_1_DSECT,R4\n* ???    CLC   C1_EYECATCHER,=CL2'AN'       ANS4 COBOL ?\n* ???    BE    COBOL_1\n         CLC   C1_EYECATCHER(4),=CL4'VSR1'       OS/VS COBOL/1 ?\n         BE    COBOL_1\n         CLC   C1_EYECATCHER(4),=CL4'VSR2'       OS/VS COBOL/1 ?\n         BE    COBOL_1\nCOBANAL_06 DS  0H\n         STRING 'Can not established the program_language',INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'8'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_08 DS  0H\n         STRING 'Program=',PGMNAME_GET,' seems to be LE but',          X\n               ' PPA1 looks invalid',INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'8'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_09 DS  0H\n         CLI   0(R2),X'03'          ID = C       (03) ?\n         BNE   COBANAL_10             no check Assembler\n         STRING 'Program=',PGMNAME_GET,' is a C-Program ',INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'8'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_10 DS  0H\n         CLI   0(R2),X'0F'          ID = Assembler (15) ?\n         BNE   COBANAL_06             no, unknown language\n         STRING 'Program=',PGMNAME_GET,' is a LE-enabled ',            X\n               'Assembler',INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'8'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_PARM_ERROR DS  0H\n         STRING 'Error parm statement, check it',INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'12'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_LOAD_ERROR DS  0H\n         STRING 'Error during load of program=',PGMNAME_GET,           X\n               INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'12'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_CSV_ERROR DS  0H\n         STRING 'CSVQUERY failed, RC=',((R2),,L),INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'12'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_EXIT       DS 0H\n         DELETE EPLOC=PGMNAME_GET   Delete the pgm\n         CLI   DOALL,C'N'           Default\n         BE    COBANAL_FIN\n         CLI   DOALL,C'X'           Exclude with wildcards?\n         BE    COBANAL_EXIT_1         No leave\n         CLC   PGMNAME_GET,XFF      Last Program?\n         BNE   COBANAL_022            no loop\n         B     COBANAL_FIN          finish\nCOBANAL_EXIT_1     DS 0H\n         CLC   PGMNAME_GET,XFF      Last Program?\n         BNE   COBANAL_028           no loop\nCOBANAL_FIN        DS 0H\n         LA    R9,SYSPRINT\n         USING IHADCB,R9\n         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is it OPEN?\n         BNO   COBANAL_FIN_1              No, ignore it\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE\n         CLOSE ((R9)),MF=(E,PARMLIST)      Close it\n         DROP  R9\nCOBANAL_FIN_1      DS 0H\n         LA    R9,INPUT\n         USING IHADCB,R9\n         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is it OPEN?\n         BNO   COBANAL_FIN_2              No, ignore it\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE\n         CLOSE ((R9)),MF=(E,PARMLIST)      Close it\n         DROP  R9\nCOBANAL_FIN_2      DS 0H\n         LA    R0,COBANAL_WORK_LENGTH\n         STORAGE RELEASE,              free Storage                    *\n               LENGTH=(R0),            Length                          *\n               ADDR=((R11))\n         L     R15,RETCODE\n         PR\n*============================================================*\n*    C/370 Program OPLINK Bit on !!!!!                       *\n*    Offset instead of relative pointer!!!                   *\n*============================================================*\nC_370    DS 0H\n         LR    R2,R4\n         A     R2,12(,R4)          PPA1\n         CLI   1(R2),X'CE'         Check PPA1\n         BNE   COBANAL_08            seems invalid PPA1\n         A     R4,4(,R2)           PPA2 pointer\n         LR    R2,R4\n         B     COBANAL_09          check languages\n*============================================================*\n*    COBOL/370 Program                                       *\n*============================================================*\nCOBOL_370 DS 0H\n         USING COBOL_370_DSECT,R4\n         LR    R2,R4\n         A     R2,12(,R4)          PPA1\n         CLI   1(R2),X'CE'         Check PPA1\n         BNE   COBANAL_08            seems invalid PPA1\n         ICM   R2,B'1111',4(R2)    PPA2 pointer\n         BZ    COBANAL_08            seems invalid PPA2\n         CLI   0(R2),X'05'         ID = Cobol!! (15)\n         BNE   COBANAL_09            no, error\n         MVI   LE_SWITCH,C'1'\n         L     R4,CEE_PRI_EP_ADDRESS\n         MVC   LE_VERS,CEE_VERS\n         MVC   LE_REL,CEE_REL\n         MVC   LE_MOD,CEE_MOD\n         MVC   LE_CCSID,CEE_CCSID\n         MVC   LE_PGM_NAME,CEE_PGM_NAME\n         MVC   LE_COMP_DAY,CEE_COMP_DAY\n         MVC   LE_COMP_MONTH,CEE_COMP_MONTH\n         MVC   LE_COMP_YEAR,CEE_COMP_YEAR\n         MVC   LE_COMP_HOURS,CEE_COMP_HOURS\n         MVC   LE_COMP_MIN,CEE_COMP_MIN\n         MVC   LE_COMP_SEC,CEE_COMP_SEC\n         MVC   LE_DATA_STATEMENTS,CEE_DATA_STATEMENTS\n         MVC   LE_PROC_LINES,CEE_PROC_LINES\n         MVC   LE_YEAR_WINDOW,CEE_YEAR_WINDOW\n         MVC   LE_STATUS_BYTE_01,CEE_STATUS_BYTE_01\n         MVC   LE_STATUS_BYTE_02,CEE_STATUS_BYTE_02\n         MVC   LE_STATUS_BYTE_03,CEE_STATUS_BYTE_03\n         MVC   LE_STATUS_BYTE_04,CEE_STATUS_BYTE_04\n         MVC   LE_STATUS_BYTE_05,CEE_STATUS_BYTE_05\n         MVC   LE_STATUS_BYTE_06,CEE_STATUS_BYTE_06\n         MVC   LE_STATUS_BYTE_07,CEE_STATUS_BYTE_07\n         MVC   LE_STATUS_BYTE_08,CEE_STATUS_BYTE_08\n         MVC   LE_STATUS_BYTE_09,CEE_STATUS_BYTE_09\n         MVC   LE_STATUS_BYTE_10,CEE_STATUS_BYTE_10\n         MVC   LE_STATUS_BYTE_11,CEE_STATUS_BYTE_11\n         MVC   LE_STATUS_BYTE_12,CEE_STATUS_BYTE_12\n         MVC   LE_STATUS_BYTE_13,CEE_STATUS_BYTE_13\n         MVC   LE_STATUS_BYTE_14,CEE_STATUS_BYTE_14\n         MVC   LE_STATUS_BYTE_15,CEE_STATUS_BYTE_15\n         MVC   LE_STATUS_BYTE_16,CEE_STATUS_BYTE_16\n         MVC   LE_STATUS_BYTE_17,CEE_STATUS_BYTE_17\n         MVC   LE_STATUS_BYTE_18,CEE_STATUS_BYTE_18\n         MVC   LE_STATUS_BYTE_19,CEE_STATUS_BYTE_19\n         MVC   LE_STATUS_BYTE_20,CEE_STATUS_BYTE_20\n         MVC   LE_STATUS_BYTE_21,CEE_STATUS_BYTE_21\n         MVC   LE_STATUS_BYTE_22,CEE_STATUS_BYTE_22\n         MVC   LE_STATUS_BYTE_23,CEE_STATUS_BYTE_23\n         MVC   LE_STATUS_BYTE_24,CEE_STATUS_BYTE_24\n         MVC   LE_STATUS_BYTE_25,CEE_STATUS_BYTE_25\n         MVC   LE_STATUS_BYTE_26,CEE_STATUS_BYTE_26\n         MVC   LE_STATUS_BYTE_27,CEE_STATUS_BYTE_27\n         MVC   LE_STATUS_BYTE_28,CEE_STATUS_BYTE_28\n         MVC   LE_STATUS_BYTE_29,CEE_STATUS_BYTE_29\n         B     LE370_INFO\n*============================================================*\n*    COBOL/2 Program                                         *\n*============================================================*\nCOBOL_2 DS 0H\n         USING COBOL_2_DSECT,R4\n         MVI   LE_SWITCH,C'2'\n         L     R4,C2_GET_ENTRY\n         L     R4,0(R4)\n         MVC   LE_VERS,C2_VERS\n         MVC   LE_REL,C2_REL\n         MVC   LE_MOD,C2_MOD\n         MVC   LE_PGM_NAME,C2_PGM_NAME\n         MVC   LE_COMP_DAY,C2_COMP_DAY\n         MVC   LE_COMP_MONTH,C2_COMP_MONTH\n         MVC   LE_COMP_YEAR(2),=C'??'    COBOL2 not Y2K ready\n         MVC   LE_COMP_YEAR+2(2),C2_COMP_YEAR\n         MVC   LE_COMP_HOURS,C2_COMP_HOURS\n         MVC   LE_COMP_MIN,C2_COMP_MIN\n         MVC   LE_COMP_SEC,C2_COMP_SEC\n         MVC   LE_DATA_STATEMENTS,C2_DATA_STATEMENTS\n         MVC   LE_PROC_LINES,C2_PROC_LINES\n         MVC   LE_STATUS_BYTE_01,C2_STATUS_BYTE_01\n         MVC   LE_STATUS_BYTE_02,C2_STATUS_BYTE_02\n         MVC   LE_STATUS_BYTE_03,C2_STATUS_BYTE_03\n         MVC   LE_STATUS_BYTE_04,C2_STATUS_BYTE_04\n         MVC   LE_STATUS_BYTE_05,C2_STATUS_BYTE_05\n         MVC   LE_STATUS_BYTE_06,C2_STATUS_BYTE_06\n         MVC   LE_STATUS_BYTE_07,C2_STATUS_BYTE_07\n         MVC   LE_STATUS_BYTE_08,C2_STATUS_BYTE_08\n         MVC   LE_STATUS_BYTE_09,C2_STATUS_BYTE_09\n         MVC   LE_STATUS_BYTE_10,C2_STATUS_BYTE_10\n         MVC   LE_STATUS_BYTE_11,C2_STATUS_BYTE_11\n         MVC   LE_STATUS_BYTE_12,C2_STATUS_BYTE_12\n         MVC   LE_STATUS_BYTE_13,C2_STATUS_BYTE_13\n         MVC   LE_STATUS_BYTE_14,C2_STATUS_BYTE_14\n         MVC   LE_STATUS_BYTE_15,C2_STATUS_BYTE_15\n         MVC   LE_STATUS_BYTE_16,C2_STATUS_BYTE_16\n         MVC   LE_STATUS_BYTE_17,C2_STATUS_BYTE_17\n         MVC   LE_STATUS_BYTE_18,C2_STATUS_BYTE_18\n         MVC   LE_STATUS_BYTE_19,C2_STATUS_BYTE_19\n         MVC   LE_STATUS_BYTE_20,C2_STATUS_BYTE_20\n         MVC   LE_STATUS_BYTE_21,C2_STATUS_BYTE_21\n         MVC   LE_STATUS_BYTE_22,C2_STATUS_BYTE_22\n         MVC   LE_STATUS_BYTE_23,C2_STATUS_BYTE_23\n         MVC   LE_STATUS_BYTE_24,C2_STATUS_BYTE_24\n         MVC   LE_STATUS_BYTE_25,C2_STATUS_BYTE_25\n         B     LE370_INFO\n*============================================================*\n* OS/VS COBOL   Program                                      *\n*============================================================*\nCOBOL_1 DS 0H\n         USING COBOL_1_DSECT,R4\n         MVI   LE_SWITCH,C'3'\n         MVC   LE_VERS,BLANKS\n         MVC   LE_REL,C1_REL\n         MVC   LE_MOD,BLANKS\n         MVC   LE_PGM_NAME,C1_PGM_NAME\n         MVC   LE_COMP_DAY,C1_COMP_DAY\n         MVC   LE_COMP_MONTH,C1_COMP_MONTH\n         MVC   LE_COMP_YEAR,C1_COMP_YEAR\n         MVC   LE_COMP_HOURS,C1_COMP_HOURS\n         MVC   LE_COMP_MIN,C1_COMP_MIN\n         MVC   LE_COMP_SEC,C1_COMP_SEC\n         L     R5,C1_TGT_PTR\n         USING COBOL_1_TGT,R5\n         CLC   C1_CHECK,=CL8'SYSOUT'     check\n         BE    LE370_INFO\n*\n*        UNABLE TO FIND THE TASK GLOBAL TABLE  -\n*\nNOTTGT   DS    0H\n         STRING 'Program ',PGMNAME_GET,' failed the TGT (Task Global', @\n               'Table) test',INTO=RECORD\n         BAL   R14,SPACE2\n         LA    R15,8\n         B     COBANAL_EXIT\nLE370_INFO DS  0H\n         STRING '============ Info ==================================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         CLI   LE_SWITCH,C'1'\n         BNE   JUMP_AROUND_1\n         STRING 'Program: ',PGMNAME_GET,' is COBOL/370 Version ',      X, *\n               LE_VERS,                                                X\n               ' Release ',LE_REL,' Mod-Level ',LE_MOD,INTO=RECORD\n         CLC   LE_VERS(4),=C'0301'  Vers+Rel < 0301 COBOL V3R1\n         BL    JUMP_AROUND_2         yes\n         STRING 'Program: ',PGMNAME_GET,' is COBOL Enterprise',        X, *\n               ' Version ',LE_VERS,                                    X\n               ' Release ',LE_REL,' Mod-Level ',LE_MOD,INTO=RECORD\n         B     JUMP_AROUND_2\nJUMP_AROUND_1 DS 0H\n         STRING 'Program: ',PGMNAME_GET,' is COBOL/2 Version ',LE_VERS,X*\n               ' Release ',LE_REL,' Mod-Level ',LE_MOD,INTO=RECORD\n         CLI   LE_SWITCH,C'2'\n         BE    JUMP_AROUND_2\n         STRING 'Program: ',PGMNAME_GET,' is OS/VS COBOL Release ',    XL, *\n               LE_REL,                                                 X\n               INTO=RECORD\nJUMP_AROUND_2 DS 0H\n         BAL   R14,SPACE2\n         STRING '============ Timestamps ============================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING 'Compiled program name ',LE_PGM_NAME,INTO=RECORD\n         BAL   R14,SPACE1\n         BAL   R9,LE_370_12\n         DC    CL2'01',CL3'Jan'      Long name\n         DC    CL2'02',CL3'Feb'      for our non-european user\n         DC    CL2'03',CL3'Mar'\n         DC    CL2'04',CL3'Apr'\n         DC    CL2'05',CL3'May'\n         DC    CL2'06',CL3'Jun'\n         DC    CL2'07',CL3'Jul'\n         DC    CL2'08',CL3'Aug'\n         DC    CL2'09',CL3'Sep'\n         DC    CL2'10',CL3'Okt'\n         DC    CL2'11',CL3'Nov'\n         DC    CL2'12',CL3'Dec'\n         DC    X'0000',CL3'n/a'             end of table\nLE_370_12 DS   0H\n         CLC   LE_COMP_MONTH(2),0(R9)         check properties\n         BE    LE_370_14               jump if on\n         LA    R9,5(,R9)              Skip entry\n         CLI   0(R9),0                 end of table?\n         BNE   LE_370_12               not yet, loop\nLE_370_14 DS   0H\n         STRING 'Date: ',LE_COMP_DAY,'.',(LE_COMP_MONTH,2),'.',        *\n               LE_COMP_YEAR,' (european) ',LE_COMP_DAY,'.',            *\n               (2(R9),3,T),'.',LE_COMP_YEAR,' (long) ',                *\n               ' Time: ',LE_COMP_HOURS,':',LE_COMP_MIN,                *\n               ':',LE_COMP_SEC,INTO=RECORD\n         CLI   LE_SWITCH,C'3'    OS/VS COBOL ?\n         BNE   JUMP_AROUND_3       no, go ahead\n         STRING 'Date: ',LE_COMP_DAY,'.',LE_COMP_MONTH,'.',            *\n               LE_COMP_YEAR,' Time: ',LE_COMP_HOURS,':',LE_COMP_MIN,   *\n               ':',LE_COMP_SEC,INTO=RECORD\n         BAL   R14,SPACE2\n         B     INFO_COBOL            sorry no more information\nJUMP_AROUND_3 DS 0H\n         BAL   R14,SPACE2\n         STRING '============ Statistics ============================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING 'Number of data items  : ',(LE_DATA_STATEMENTS,F,R7B), *\n               INTO=RECORD\n         BAL   R14,SPACE1\n         STRING 'Number of instructions: ',(LE_PROC_LINES,F,R7B),      *\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING '============ Options in effect =====================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         MVC   RECORD,BLANKS\n         LA    R15,RECORD\n         MVC   1(3,R15),=C'ADV'\n         TM    LE_STATUS_BYTE_01,BIT0\n         BO    *+10\n         MVC   1(5,R15),=C'NOADV'\n         LA    R15,8(R15)\n         MVC   0(5,R15),=C'APOST'\n         TM    LE_STATUS_BYTE_01,BIT1\n         BO    *+10\n         MVC   0(5,R15),=C'QUOTE'\n         LA    R15,8(R15)\n         MVC   RECORD+16(9),=CL9'DATA(31)'\n         TM    LE_STATUS_BYTE_01,BIT2\n         BO    *+10\n         MVC   RECORD+16(9),=CL9'DATA(24)'\n         MVC   RECORD+25(6),=CL6'DECK'\n         TM    LE_STATUS_BYTE_01,BIT3\n         BO    *+10\n         MVC   RECORD+25(6),=CL6'NODECK'\n         MVC   RECORD+33(6),=CL6'DUMP'\n         TM    LE_STATUS_BYTE_01,BIT4\n         BO    *+10\n         MVC   RECORD+33(6),=CL6'NODUMP'\n         MVC   RECORD+40(8),=CL8'DYNAM'\n         TM    LE_STATUS_BYTE_01,BIT5\n         BO    *+10\n         MVC   RECORD+40(8),=CL8'NODYNAM'\n         MVC   RECORD+51(10),=CL10'FASTSRT'\n         TM    LE_STATUS_BYTE_01,BIT6\n         BO    *+10\n         MVC   RECORD+51(10),=CL10'NOFASTSRT'\n         MVC   RECORD+62(8),=CL8'FDUMP'\n         TM    LE_STATUS_BYTE_01,BIT7\n         BO    *+10\n         MVC   RECORD+62(8),=CL8'NOFDUMP'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(6),=CL6'LIB'\n         TM    LE_STATUS_BYTE_02,BIT0\n         BO    *+10\n         MVC   RECORD+1(6),=CL6'NOLIB'\n         MVC   RECORD+8(7),=CL7'LIST'\n         TM    LE_STATUS_BYTE_02,BIT1\n         BO    *+10\n         MVC   RECORD+8(7),=CL7'NOLIST'\n         MVC   RECORD+16(9),=CL9'MAP'\n         TM    LE_STATUS_BYTE_02,BIT2\n         BO    *+10\n         MVC   RECORD+16(9),=CL9'NOMAP'\n         MVC   RECORD+25(6),=CL6'NUM'\n         TM    LE_STATUS_BYTE_02,BIT3\n         BO    *+10\n         MVC   RECORD+25(6),=CL6'NONUM'\n         MVC   RECORD+33(6),=CL6'OBJ'\n         TM    LE_STATUS_BYTE_02,BIT4\n         BO    *+10\n         MVC   RECORD+33(6),=CL6'NOOBJ'\n         MVC   RECORD+40(8),=CL8'OFFSET'\n         TM    LE_STATUS_BYTE_02,BIT5\n         BO    *+10\n         MVC   RECORD+40(8),=CL8'NOOFFSET'\n         MVC   RECORD+51(10),=CL10'OPTIMIZE'\n         TM    LE_STATUS_BYTE_02,BIT6\n         BO    *+10\n         MVC   RECORD+51(10),=CL10'NOOPTIMIZE'\n         CLI   LE_SWITCH,C'1'   COBOL/370\n         BNE   LE_370_18\n         CLC   LE_VERS(4),=C'0301'  Vers+Rel < 0301 COBOL V3R1\n         BL    LE_370_18             yes\n         MVC   RECORD+62(18),=CL18'OUTDD(SYSOUT)'\n         TM    LE_STATUS_BYTE_02,BIT7\n         BO    *+10\n         MVC   RECORD+62(18),=CL18'OUTDD(Supplied)'\n         BAL   R14,SPACE1\n         B     LE_370_19\nLE_370_18 DS 0H\n         MVC   RECORD+62(17),=CL17'OUTDD(Default)'\n         TM    LE_STATUS_BYTE_02,BIT7\n         BO    *+10\n         MVC   RECORD+62(17),=CL17'OUTDD(Supplied)'\n         BAL   R14,SPACE1\nLE_370_19 DS 0H\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(15),=CL15'NUMPROC(MIG)'\n         TM    LE_STATUS_BYTE_05,BIT0\n         BO    LE_370_21\n         MVC   RECORD+1(15),=CL15'NUMPROC(PFD)'\n         TM    LE_STATUS_BYTE_03,BIT0\n         BO    *+10\n         MVC   RECORD+1(15),=CL15'NUMPROC(NOPFD)'\nLE_370_21 DS 0H\n         MVC   RECORD+16(7),=CL7'RENT'\n         TM    LE_STATUS_BYTE_03,BIT1\n         BO    *+10\n         MVC   RECORD+16(7),=CL7'NORENT'\n         MVC   RECORD+25(6),=CL6'RES'\n         TM    LE_STATUS_BYTE_03,BIT2\n         BO    *+10\n         MVC   RECORD+25(6),=CL6'NORES'\n         MVC   RECORD+33(6),=CL6'SEQ'\n         TM    LE_STATUS_BYTE_03,BIT3\n         BO    *+10\n         MVC   RECORD+33(6),=CL6'NOSEQ'\n         MVC   RECORD+40(12),=CL12'SIZE(MAX)'\n         TM    LE_STATUS_BYTE_03,BIT4\n         BO    *+10\n         MVC   RECORD+40(12),=CL12'SIZE(value)'\n         MVC   RECORD+51(9),=CL9'SOURCE'\n         TM    LE_STATUS_BYTE_03,BIT5\n         BO    *+10\n         MVC   RECORD+51(9),=CL9'NOSOURCE'\n         MVC   RECORD+62(10),=CL10'SSRANGE'\n         TM    LE_STATUS_BYTE_03,BIT6\n         BO    *+10\n         MVC   RECORD+62(10),=CL10'NOSSRANGE'\n         MVC   RECORD+72(8),=CL8'TERM'\n         TM    LE_STATUS_BYTE_03,BIT7\n         BO    *+10\n         MVC   RECORD+72(8),=CL8'NOTERM'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(8),=CL8'TEST'\n         TM    LE_STATUS_BYTE_04,BIT0\n         BO    *+10\n         MVC   RECORD+1(8),=CL8'NOTEST'\n         MVC   RECORD+8(10),=CL11'TRUNC(BIN)'\n         TM    LE_STATUS_BYTE_05,BIT4\n         BO    LE_370_33\n         MVC   RECORD+8(10),=CL11'TRUNC(STD)'\n         TM    LE_STATUS_BYTE_04,BIT1\n         BO    *+10\n         MVC   RECORD+8(10),=CL11'TRUNC(OPT)'\nLE_370_33 DS 0H\n         MVC   RECORD+25(9),=CL9'WORD(xx)'\n         TM    LE_STATUS_BYTE_04,BIT2\n         BO    *+10\n         MVC   RECORD+25(9),=CL9'NOWORD'                                t'\n         MVC   RECORD+33(8),=CL8'VBREF'\n         TM    LE_STATUS_BYTE_04,BIT3\n         BO    *+10\n         MVC   RECORD+33(8),=CL8'NOVBREF'\n         MVC   RECORD+40(6),=CL6'XREF'\n         TM    LE_STATUS_BYTE_04,BIT4\n         BO    *+10\n         MVC   RECORD+40(6),=CL6'NOXREF'\n         MVC   RECORD+51(6),=CL6'ZWB'\n         TM    LE_STATUS_BYTE_04,BIT5\n         BO    *+10\n         MVC   RECORD+51(6),=CL6'NOZWB'\n         MVC   RECORD+62(7),=CL7'NAME'\n         TM    LE_STATUS_BYTE_04,BIT6\n         BO    *+10\n         MVC   RECORD+62(7),=CL7'NONAME'\n         MVC   RECORD+72(8),=CL8'CMPR2'\n         TM    LE_STATUS_BYTE_04,BIT7\n         BO    *+10\n         MVC   RECORD+72(8),=CL8'NOCMPR2'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(12),=CL12'NUMCLS'  other Cobol\n         TM    LE_STATUS_BYTE_05,BIT1\n         BO    *+10\n         MVC   RECORD+1(12),=CL12'NONUMCLS'\n         CLI   LE_SWITCH,C'1'   COBOL/370\n         BNE   LE_370_42\n         CLC   LE_VERS(4),=C'0102'  Vers+Rel < 0102 COBOL MVS and VM\n         BL    LE_370_42             yes\n         MVC   RECORD+1(12),=CL12'NUMCLS(ALT)'\n         TM    LE_STATUS_BYTE_05,BIT1\n         BO    *+10\n         MVC   RECORD+1(12),=CL12'NUMCLS(PRIM)'\nLE_370_42 DS 0H\n         MVC   RECORD+16(7),=CL7'DBCS'\n         TM    LE_STATUS_BYTE_05,BIT2\n         BO    *+10\n         MVC   RECORD+16(7),=CL7'NODBCS'\n         MVC   RECORD+25(6),=CL6'AWO'\n         TM    LE_STATUS_BYTE_05,BIT3\n         BO    *+10\n         MVC   RECORD+25(6),=CL6'NOAWO'\n         CLI   LE_SWITCH,C'1'                  Cobol/370\n         BNE   LE_370_48                       no, jump around\n         MVC   RECORD+33(9),=CL9'EVENTS'       n/a COBOL/2\n         TM    LE_STATUS_BYTE_05,BIT5\n         BO    *+10\n         MVC   RECORD+33(9),=CL9'NOEVENTS'\n         MVC   RECORD+51(11),=CL11'CURRENCY'   n/a COBOL/2\n         TM    LE_STATUS_BYTE_05,BIT6\n         BO    *+10\n         MVC   RECORD+51(11),=CL11'NOCURRENCY'\nLE_370_48 DS 0H\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(40),=CL40'Compilation unit = Class'\n         TM    LE_STATUS_BYTE_05,BIT7\n         BO    *+10\n         MVC   RECORD+1(40),=CL40'Compilation unit = Program'\n         CLI   LE_SWITCH,C'1'   COBOL/370 ?\n         BNE   LE_370_50Z         no\n         CLC   LE_VERS(4),=C'0102'  Vers+Rel < 0102 COBOL MVS and VM\n         BL    LE_370_50Z         no\n*                         Supported only for COBOL MVS and VM R2\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(11),=CL11'RMODE(ANY)'\n         TM    LE_STATUS_BYTE_26,BIT0\n         BO    *+10\n         MVC   RECORD+1(11),=CL11'RMODE(24)'\n         MVC   RECORD+16(13),=CL13'TEST(STMT)'\n         TM    LE_STATUS_BYTE_26,BIT1\n         BO    *+10\n         MVC   RECORD+16(13),=CL13'NO TEST(STMT)'\n         MVC   RECORD+33(13),=CL13'TEST(PATH)'\n         TM    LE_STATUS_BYTE_26,BIT2\n         BO    *+10\n         MVC   RECORD+33(13),=CL13'NO TEST(PATH)'\n         MVC   RECORD+51(14),=CL14'TEST(BLOCK)'\n         TM    LE_STATUS_BYTE_26,BIT3\n         BO    *+10\n         MVC   RECORD+51(14),=CL14'NO TEST(BLOCK)'\n         MVC   RECORD+72(17),=CL17'OPT(FULL)'\n         TM    LE_STATUS_BYTE_26,BIT4\n         BO    *+10\n         MVC   RECORD+72(17),=CL17'NOOPT OR OPT(STD)'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(13),=CL13'INTDATE(LIL)'\n         TM    LE_STATUS_BYTE_26,BIT5\n         BO    *+10\n         MVC   RECORD+1(13),=CL13'INTDATE(ANSI)'\n         MVC   RECORD+16(3),=CL3'N/A'                            RS1000\n         CLC   LE_VERS(4),=C'0202'  Vers+Rel < 0202 COBOL MVS and VM\n         BL    LE_370_50Y           no lower                     RS1000\n         MVC   RECORD+16(14),=CL14'TEST(SEPARATE)'               RS1000\n         TM    LE_STATUS_BYTE_26,BIT6                            RS1000\n         BO    *+10                                              RS1000\n         MVC   RECORD+16(17),=CL17'NO TEST(SEPARATE)'            RS1000\nLE_370_50Y DS  0H\n         MVC   RECORD+35(22),=CL22'PGMNAME(LONGUPPER)'\n         TM    LE_STATUS_BYTE_27,BIT0\n         BO    *+10\n         MVC   RECORD+35(22),=CL22'NOT PGMNAME(LONGUPPER)'\n         MVC   RECORD+60(22),=CL22'PGMNAME(LONGMIXED)'\n         TM    LE_STATUS_BYTE_27,BIT1\n         BO    *+10\n         MVC   RECORD+60(22),=CL22'NOT PGMNAME(LONGMIXED)'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(5),=CL5'DLL'\n         TM    LE_STATUS_BYTE_27,BIT2\n         BO    *+10\n         MVC   RECORD+1(5),=CL5'NODLL'\n         MVC   RECORD+16(11),=CL11'EXPORTALL'\n         TM    LE_STATUS_BYTE_27,BIT3\n         BO    *+10\n         MVC   RECORD+16(11),=CL11'NOEXPORTALL'\n         MVC   RECORD+33(10),=CL10'DATEPROC'\n         TM    LE_STATUS_BYTE_27,BIT4\n         BO    *+10\n         MVC   RECORD+33(10),=CL10'NODATEPROC'\n         STRING (RECORD,,L),1X,'YEARWINDOW(',(LE_YEAR_WINDOW,H,R4B),   *\n               ')',INTO=RECORD\n         CLC   LE_VERS(4),=C'0202'  Vers+Rel < 0202 COBOL MVS and VM\n         BL    LE_370_50Z           no lower                     RS1000\n         MVC   RECORD+62(13),=CL13'ARITH(EXTEND)'                RS1000\n         TM    LE_STATUS_BYTE_27,BIT5                            RS1000\n         BO    *+10                                              RS1000\n         MVC   RECORD+62(13),=CL13'ARITH(COMPAT)'                RS1000\n         CLI   LE_SWITCH,C'1'   COBOL/370\n         BNE   LE_370_50Z\n         CLC   LE_VERS(4),=C'0301'  Vers+Rel < 0301 COBOL V3R1\n         BL    LE_370_50Z            yes\n         MVC   RECORD+76(11),=CL11'THREAD(YES)'\n         TM    LE_STATUS_BYTE_27,BIT6\n         BO    *+10\n         MVC   RECORD+76(11),=CL11'THREAD(NO)'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         STRING (RECORD,,L),1X,'CODEPAGE(',(LE_CCSID,H,R4B),')',       X\n               INTO=RECORD\nLE_370_50Z DS 0H\n         BAL   R14,SPACE2\n         STRING '============ Additional information ================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE1\n         STRING '============ about DATA DIVISION    ================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING 'Program use',' no',' QSAM or SAM access method',      *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT0\n         BNO   LE_370_51\n         STRING 'Program use',' QSAM or SAM access method',INTO=RECORD\nLE_370_51 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' VSAM sequential files',          *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT1\n         BNO   LE_370_52\n         STRING 'Program use',' VSAM sequential files',INTO=RECORD\nLE_370_52 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' VSAM indexed files',INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT2\n         BNO   LE_370_53\n         STRING 'Program use',' VSAM indexed files',INTO=RECORD\nLE_370_53 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' VSAM RBA files',INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT3\n         BNO   LE_370_54\n         STRING 'Program use',' VSAM RBA files',INTO=RECORD\nLE_370_54 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' CODE-SET (ASCII files)',         *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT4\n         BNO   LE_370_55\n         STRING 'Program use',' CODE-SET (ASCII files)',INTO=RECORD\nLE_370_55 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' spanned records',INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT5\n         BNO   LE_370_56\n         STRING 'Program use',' spanned records',INTO=RECORD\nLE_370_56 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' picture G (DBCS) items',         *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT6\n         BNO   LE_370_57\n         STRING 'Program has',' picture G (DBCS) items',INTO=RECORD\nLE_370_57 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' OCCURS DEPENDING ON items',      *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT7\n         BNO   LE_370_58\n         STRING 'Program has',' OCCURS DEPENDING ON items',INTO=RECORD\nLE_370_58 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' SYNCHRONIZED clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT0\n         BNO   LE_370_59\n         STRING 'Program has',' SYNCHRONIZED clause',INTO=RECORD\nLE_370_59 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' JUSTIFIED clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT1\n         BNO   LE_370_60\n         STRING 'Program has',' JUSTIFIED clause',INTO=RECORD\nLE_370_60 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' POINTER items',INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT2\n         BNO   LE_370_61\n         STRING 'Program has',' POINTER items',INTO=RECORD\nLE_370_61 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' complex ODO clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT3\n         BNO   LE_370_62\n         STRING 'Program has',' complex ODO clause',INTO=RECORD\nLE_370_62 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' external',                       *\n               ' floating-point items',                                *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT4\n         BNO   LE_370_63\n         STRING 'Program has',' external',' floating-point items',     *\n               INTO=RECORD\nLE_370_63 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' internal',                       *RD\n               ' floating-point items',                                *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT5\n         BNO   LE_370_63_1\n         STRING 'Program has',' internal',' floating-point items',     *\n               INTO=RECORD\nLE_370_63_1 DS 0H\n         CLI   LE_SWITCH,C'1'                  Cobol/370\n         BNE   LE_370_64                       no, jump around\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' Proc-Pointer or Func-Pointer ',  X\n               'items',INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT7\n         BNO   LE_370_63_2\n         STRING 'Program has',' Proc or Func-Pointer items',INTO=RECORD\nLE_370_63_2 DS 0H\n         CLC   LE_VERS(4),=C'0202'  Vers+Rel < 0202 COBOL MVS and VM\n         BL    LE_370_64            no lower                     RS1000\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' Line-sequential file',           *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT6\n         BNO   LE_370_64\n         STRING 'Program has',' Line-sequential file',                 *\n               INTO=RECORD\nLE_370_64 DS 0H\n         BAL   R14,SPACE2\n         STRING '============ Additional information    =============',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE1\n         STRING '============ about ENVIROMENT DIVISION =============',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING 'Program use',' no',' FILE-STATUS clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_08,BIT0\n         BNO   LE_370_66\n         STRING 'Program use',' FILE-STATUS clause',INTO=RECORD\nLE_370_66 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' RERUN clause in I/O-control',    *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_08,BIT1\n         BNO   LE_370_67\n         STRING 'Program has',' RERUN clause in I/O-control',          *\n               INTO=RECORD\nLE_370_67 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' UPSI switches',INTO=RECORD\n         TM    LE_STATUS_BYTE_08,BIT2\n         BNO   LE_370_68\n         STRING 'Program use',' UPSI switches',INTO=RECORD\nLE_370_68 DS 0H\n         BAL   R14,SPACE2\n         STRING '============ Additional information    =============',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE1\n         STRING '============ about PROCEDURE DIVISION  =============',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING 'Following statements in control (check Y/N):',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(6),=CL6'Accept'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_09,BIT0\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(3),=CL3'Add'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_09,BIT1\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(5),=CL5'Alter'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_09,BIT2\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(4),=CL4'Call'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_09,BIT3\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(6),=CL6'Cancel'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_09,BIT4\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(5),=CL5'Close'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_09,BIT6\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(7),=CL7'Compute'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_10,BIT0\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(6),=CL6'Delete'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_10,BIT2\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(7),=CL7'Display'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_10,BIT4\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(6),=CL6'Divide'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_10,BIT5\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(11),=CL11'End-Perform'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_11,BIT1\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(5),=CL5'Enter'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_11,BIT2\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(5),=CL5'Entry'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_11,BIT3\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(4),=CL4'Exit'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_11,BIT4\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(5),=CL5'Go to'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_11,BIT6\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(2),=CL2'If'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_11,BIT7\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(10),=CL10'Initialize'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_12,BIT0\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         CLI   LE_SWITCH,C'1'   COBOL/370 ?\n         BNE   LE_370_70          no, jump around\n         MVC   RECORD+86(6),=CL6'Invoke'   comes with COBOL/370\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_12,BIT1\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\nLE_370_70 DS 0H\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(7),=CL7'Inspect'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_12,BIT2\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(5),=CL5'Merge'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_12,BIT3\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(4),=CL4'Move'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_12,BIT4\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(8),=CL8'Multiply'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_12,BIT5\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(4),=CL4'Open'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_12,BIT6\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(7),=CL7'Perform'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_12,BIT7\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(4),=CL4'Read'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_13,BIT0\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(7),=CL7'Release'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_13,BIT2\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(6),=CL6'Return'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_13,BIT3\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(7),=CL7'Rewrite'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_13,BIT4\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(6),=CL6'Search'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_13,BIT5\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(3),=CL3'Set'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_13,BIT7\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(4),=CL4'Sort'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_14,BIT0\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(5),=CL5'Start'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_14,BIT1\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(4),=CL4'Stop'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_14,BIT2\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(6),=CL6'String'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_14,BIT3\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(8),=CL8'Subtract'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_14,BIT4\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(8),=CL8'Unstring'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_14,BIT7\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(3),=CL3'Use'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_15,BIT0\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(5),=CL5'Write'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_15,BIT1\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(8),=CL8'Continue'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_15,BIT2\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(7),=CL7'End-Add'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_15,BIT3\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(8),=CL8'End-Call'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_15,BIT4\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(11),=CL11'End-Compute'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_15,BIT5\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(10),=CL10'End-Delete'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_15,BIT6\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(10),=CL10'End-Divide'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_15,BIT7\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(12),=CL12'End-Evaluate'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_16,BIT0\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(6),=CL6'End-If'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_16,BIT1\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(11),=CL11'End-Muliply'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_16,BIT2\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(8),=CL8'End-Read'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_16,BIT3\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(10),=CL10'End-Return'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_16,BIT4\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(11),=CL11'End-Rewrite'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_16,BIT5\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(10),=CL10'End-Search'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_16,BIT6\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(9),=CL9'End-Start'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_16,BIT7\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(10),=CL10'End-String'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_17,BIT0\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(12),=CL12'End-Subtract'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_17,BIT1\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(12),=CL12'End-Unstring'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_17,BIT2\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(9),=CL9'End-Write'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_17,BIT3\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(6),=CL6'Goback'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_17,BIT4\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(9),=CL9'Evaluate'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_17,BIT5\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(7),=CL7'Service'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_17,BIT7\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(10),=CL10'End-Invoke'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_18,BIT0\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         CLI   LE_SWITCH,C'1'   COBOL/370\n         BNE   LE_370_125\n         CLC   LE_VERS(4),=C'0301'  Vers+Rel < 0301 COBOL V3R1\n         BL    LE_370_125            yes\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(10),=CL10'Exec'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_11,BIT5\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(9),=CL9'End-Exec'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_18,BIT2\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(9),=CL9'End-Exec'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_18,BIT2\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(3),=CL3'XML'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_18,BIT3\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(3),=CL3'END-XML'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_18,BIT3\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         BAL   R14,SPACE1\nLE_370_125 DS 0H\n         STRING '====================================================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING 'No hexadecimal literals',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT0\n         BNO   LE_370_128\n         STRING 'Procedure include hexadecimal literals',INTO=RECORD\nLE_370_128 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No altered GO TO',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT1\n         BNO   LE_370_129\n         STRING 'Program contains altered GO TO',INTO=RECORD\nLE_370_129 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','I/O error declarative',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT2\n         BNO   LE_370_130\n         STRING 'I/O error declarative',INTO=RECORD\nLE_370_130 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Label declarative',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT3\n         BNO   LE_370_131\n         STRING 'Label declarative',INTO=RECORD\nLE_370_131 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Debugging declarative',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT4\n         BNO   LE_370_132\n         STRING 'Debugging declarative',INTO=RECORD\nLE_370_132 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Program segmentation',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT5\n         BNO   LE_370_133\n         STRING 'Program segmentation',INTO=RECORD\nLE_370_133 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Open Extend',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT6\n         BNO   LE_370_134\n         STRING 'Open Extend',INTO=RECORD\nLE_370_134 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Exit Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT7\n         BNO   LE_370_135\n         STRING 'Exit Program',INTO=RECORD\nLE_370_135 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No call literal',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT0\n         BNO   LE_370_136\n         STRING 'Call literal (static?), see options',INTO=RECORD\nLE_370_136 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Call identifier',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT1\n         BNO   LE_370_137\n         STRING 'Call identifier',INTO=RECORD\nLE_370_137 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Call on overflow',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT2\n         BNO   LE_370_138\n         STRING 'Call on overflow',INTO=RECORD\nLE_370_138 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Call length of',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT3\n         BNO   LE_370_139\n         STRING 'Call length of',INTO=RECORD\nLE_370_139 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Call address of',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT4\n         BNO   LE_370_140\n         STRING 'Call address of',INTO=RECORD\nLE_370_140 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Close reel/unit',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT5\n         BNO   LE_370_141\n         STRING 'Close reel/unit',INTO=RECORD\nLE_370_141 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Exponentiation used',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT6\n         BNO   LE_370_142\n         STRING 'Exponentiation used',INTO=RECORD\nLE_370_142 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Floating point items used',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT7\n         BNO   LE_370_143\n         STRING 'Floating point items used',INTO=RECORD\nLE_370_143 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Copy-Statements',INTO=RECORD\n         TM    LE_STATUS_BYTE_23,BIT0\n         BNO   LE_370_144\n         STRING 'Copy-Statements',INTO=RECORD\nLE_370_144 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Basis-Statements',INTO=RECORD\n         TM    LE_STATUS_BYTE_23,BIT1\n         BNO   LE_370_145\n         STRING 'Basis-Statements',INTO=RECORD\nLE_370_145 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','DBCS-Name in Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_23,BIT2\n         BNO   LE_370_146\n         STRING 'DBCS-Name in Program',INTO=RECORD\nLE_370_146 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Shift-In/Shift-Out',INTO=RECORD\n         TM    LE_STATUS_BYTE_23,BIT3\n         BNO   LE_370_147\n         STRING 'Shift-In/Shift-Out',INTO=RECORD\nLE_370_147 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','DBCS literal',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT0\n         BNO   LE_370_148\n         STRING 'DBCS literal',INTO=RECORD\nLE_370_148 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Replace-Statements',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT1\n         BNO   LE_370_149\n         STRING 'Replace-Statements',INTO=RECORD\nLE_370_149 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Reference modification was used',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT2\n         BNO   LE_370_150\n         STRING 'Reference modification was used',INTO=RECORD\nLE_370_150 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Nested Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT3\n         BNO   LE_370_151\n         STRING 'Nested Program',INTO=RECORD\nLE_370_151 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','INITIAL Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT4\n         BNO   LE_370_152\n         STRING 'INITIAL Program',INTO=RECORD\nLE_370_152 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','COMMON Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT5\n         BNO   LE_370_153\n         STRING 'COMMON Program',INTO=RECORD\nLE_370_153 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Select Optional Files',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT6\n         BNO   LE_370_154\n         STRING 'Select Optional Files',INTO=RECORD\nLE_370_154 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','External Files',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT7\n         BNO   LE_370_155\n         STRING 'External Files',INTO=RECORD\nLE_370_155 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Global Files',INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT0\n         BNO   LE_370_156\n         STRING 'Global Files',INTO=RECORD\nLE_370_156 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Record is varying clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT1\n         BNO   LE_370_157\n         STRING 'Record is varying clause',INTO=RECORD\nLE_370_157 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Accept from SYSIPT used in Label Declarative',  *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT2\n         BNO   LE_370_158\n         STRING 'Accept from SYSIPT used in Label Declarative',        *\n               INTO=RECORD\nLE_370_158 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Display upon SYSLST used in Label Declarative', *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT3\n         BNO   LE_370_159\n         STRING 'Display upon SYSLST used in Label Declarative',       *\n               INTO=RECORD\nLE_370_159 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Display upon SYSPCH used in Label Declarative', *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT4\n         BNO   LE_370_160\n         STRING 'Display upon SYSPCH used in Label Declarative',       *\n               INTO=RECORD\nLE_370_160 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Intrinsic function was used',INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT5\n         BNO   LE_370_161\n         STRING 'Intrinsic function was used',INTO=RECORD\nLE_370_161 DS 0H\n         CLI   LE_SWITCH,C'1'   COBOL/370\n         BNE   LE_370_177\n         CLC   LE_VERS(4),=C'0301'  Vers+Rel < 0301 COBOL V3R1\n         BL    LE_370_177            yes\n         BAL   R14,SPACE1\n         STRING 'No ','Function Random was used',INTO=RECORD\n         TM    LE_STATUS_BYTE_29,BIT1\n         BNO   LE_370_162\n         STRING 'Function Random was used',INTO=RECORD\nLE_370_162 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Java-based OO syntax was used',INTO=RECORD\n         TM    LE_STATUS_BYTE_29,BIT0\n         BNO   LE_370_163\n         STRING 'Java-based OO syntax was used',INTO=RECORD\nLE_370_163 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','National data was used',INTO=RECORD\n         TM    LE_STATUS_BYTE_29,BIT0\n         BNO   LE_370_177\n         STRING 'National data was used',INTO=RECORD\nLE_370_177 DS 0H\n         BAL   R14,SPACE1\n         STRING '============ End  ==================================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         LA    R15,0\n         B     COBANAL_EXIT\nINFO_COBOL DS 0H\n         CLI   C1_OEM_MOD_AREA,X'00' low-value ?                 RS0700\n         BE    INFO_COBOL_OEM                                    RS0700\n         STRING '============ OEM Modified Area =====================',*\n               '=============================================',        *RD\n               INTO=RECORD                                       RS0700\n         BAL   R14,SPACE2                                        RS0700\n         STRING ' ',C1_OEM_MOD_AREA,INTO=RECORD                  RS0700\n         BAL   R14,SPACE2                                        RS0700\nINFO_COBOL_OEM DS 0H                                             RS0700\n         STRING '============ Options in effect =====================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(8),=CL8'SYMDMP'\n         TM    C1_STATUS_BYTE_01,X'08'\n         BO    *+10\n         MVC   RECORD+1(8),=CL8'NOSYMDMP'\n         MVC   RECORD+10(6),=CL6'FLOW'\n         TM    C1_STATUS_BYTE_01,X'04'\n         BO    *+10\n         MVC   RECORD+10(6),=CL6'NOFLOW'\n         MVC   RECORD+17(7),=CL7'STATE'\n         TM    C1_STATUS_BYTE_01,X'02'\n         BO    *+10\n         MVC   RECORD+17(7),=CL7'NOSTATE'\n         MVC   RECORD+25(6),=CL6'OPT'\n         TM    C1_STATUS_BYTE_01,X'01'\n         BO    *+10\n         MVC   RECORD+25(6),=CL6'NOOPT'\n         MVC   RECORD+32(6),=CL6'TEST'\n         TM    C1_STATUS_BYTE_02,X'10'\n         BO    *+10\n         MVC   RECORD+32(6),=CL6'NOTEST'\n         MVC   RECORD+39(6),=CL6'RES'\n         TM    C1_STATUS_BYTE_03,X'80'\n         BO    *+10\n         MVC   RECORD+39(6),=CL6'NORES'\n         MVC   RECORD+46(8),=CL8'ENDJOB'\n         TM    C1_STATUS_BYTE_03,X'40'\n         BO    *+10\n         MVC   RECORD+46(8),=CL8'NOENDJOB'\n         MVC   RECORD+55(8),=CL8'OBJ370'\n         TM    C1_STATUS_BYTE_03,X'20'\n         BO    *+10\n         MVC   RECORD+55(8),=CL8'NOOBJ370'\n         MVC   RECORD+64(8),=CL8'COUNT'\n         TM    C1_STATUS_BYTE_03,X'08'\n         BO    *+10\n         MVC   RECORD+64(8),=CL8'NOCOUNT'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(11),=CL11'READY TRACE'\n         TM    C1_STATUS_BYTE_03,X'04'\n         BO    *+10\n         MVC   RECORD+1(11),=CL11'NO TRACE'\n         BAL   R14,SPACE1\n         STRING 'Sorry no more infomation for OS/VS COBOL',INTO=RECORD\n         BAL   R14,SPACE1\n         STRING 'You better upgrade to COBOL for OS/390 (MVS) and VM', *\n               INTO=RECORD\n         BAL   R14,SPACE1\n         STRING '============ End  ==================================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         LA    R15,0\n         B     COBANAL_EXIT\n*============================================================*\n* Print                                                      *\n*============================================================*\nSPACE2   DS 0H\n         ST    R14,SAVER14\n         LA    R1,SYSPRINT         GET OUTPUT DCB ADDRESS\n         LA    R0,RECORD           GET OBJECT NAME ADDRESS\n         PUT   (1),(0)             WRITE NAME TO NOTIFY DATA SET\n         LA    R1,SYSPRINT         GET OUTPUT DCB ADDRESS\n         LA    R0,BLANKS           GET OBJECT NAME ADDRESS\n         BAS   R14,AMODE24             AMode24\n         PUT   (1),(0)             WRITE NAME TO NOTIFY DATA SET\n         BAS   R14,AMODE31             AMode31\n         L     R14,SAVER14\n         BR    R14            return\nSPACE1   DS 0H\n         ST    R14,SAVER14\n         LA    R1,SYSPRINT         GET OUTPUT DCB ADDRESS\n         LA    R0,RECORD           GET OBJECT NAME ADDRESS\n         BAS   R14,AMODE24             AMode24\n         PUT   (1),(0)             WRITE NAME TO NOTIFY DATA SET\n         BAS   R14,AMODE31             AMode31\n         L     R14,SAVER14\n         BR    R14            return\n***************************************************************\n*\n*                  get Member Name from PDS-Directory\n*\n***************************************************************\nGETMEM   EQU   *\n         ST    R14,GETMSAVE            save return address\n         L     R4,ADBLKPTR             restore pointer\n         CLC   DIRAREA(2),=XL2'0000'   Directory present?\n         BNE   NEWNAME                   yes, get next\nNEWBLOCK EQU   *\n         BAS   R14,AMODE24             Amode24\n         GET   INPUT,DIRAREA           get a new directory\n         BAS   R14,AMODE31             Amode24\n         LA    R4,DIRAREA              get work area address\n         AH    R4,DIRAREA              + length\n         ST    R4,ADBLKEND             save ending address\n         LA    R4,DIRAREA+2            Skip LL bytes\n         ST    R4,ADBLKPTR             save pointer\nNEWNAME  EQU   *\n         C     R4,ADBLKEND             end of current dir block\n         BNL   NEWBLOCK                  yes, get new block\n         MVC   PGMNAME_GET,0(R4)       Save member-name\n         IC    R5,11(R4)               LOOK FOR ANY USER TTRN'S\n         SLL   R5,27                   SHIFT OFF UNWANTED BITS\n         SRL   R5,26                   SHIFT BACK THE USABLE BI\n         LA    R4,12(R4,R5)            ADD DISPL TO GET OVER TT\n         ST    R4,ADBLKPTR             save Pointer next mem\n         L     R14,GETMSAVE            restore return address\n         BR    R14                     goback\nAMODE24  LA    R14,0(,R14)             remove XA bit\n         BSM   R0,R14                  return\n         SPACE 2\nAMODE31  O     R14,HIBIT               add XA bit\n         BSM   R0,R14                  return\n*\n*============================================================*\n* SONSTIGE DEFINITIONS                                       *\n*============================================================*\n****************************** CONSTANTS *****************************\nC_COBOL370 DC X'00',C'CEE'                   COBOL/370 ?  X'00C3C5C5'\nC_OPLINK   DC X'01',C'CEE'                   COBOL/370 ?  X'01C3C5C5'\nHIBIT    DC    A(X'80000000')         XA BIT CONSTANS\nBLANKS   DC    CL255' '           just blanks\nC_LSTO   OPEN  (*-*,(OUTPUT)),MF=L\nC_LSTOL  EQU   *-C_LSTO\nC_LSTI   OPEN  (*-*,(INPUT)),MF=L\nC_LSTIL  EQU   *-C_LSTI\nC_CLOSE  CLOSE (*-*),MF=L\nC_CLOSEL EQU   *-C_CLOSE\nXFF      DC    XL8'FFFFFFFFFFFFFFFF' just High-value\nSYSPRINT_FIX DCB   DSORG=PS,DDNAME=SYSPRINT,MACRF=PM,                  *\n               RECFM=FB,LRECL=121\nSYSPRINT_FIX_LENGTH EQU *-SYSPRINT_FIX   Length workarea\nINPUT_FIX DCB   DSORG=PS,DDNAME=COBANAL,MACRF=(GM),                    *\n               RECFM=U,BLKSIZE=256\n*INPUT_FIX DCB   DSORG=PO,DDNAME=COBANAL,MACRF=(R),                    *\n               RECFM=U,BLKSIZE=256\nINPUT_FIX_LENGTH EQU *-INPUT_FIX     Length workarea\n*\n*============================================================*\n* Workarea below the line                                    *\n*============================================================*\nCOBANAL_WORK        DSECT\nEYECATCHER          DS    CL8   'COBANAL'\nPGMNAME             DS    CL8   Pgmname from the parmlist\nPGMNAME_GET         DS    CL8   Pgmname from GETMEM\nSAVEAREA            DS    18F\nSAVER14             DS    F\nRETCODE             DS    F\nADR_COBANAL_WORK    DS    F     Save Workarea pointer\nADR_COBANAL_PARM    DS    F     Save Parmlist pointer\nADR_PGMNAME         DS    F     Save entry-point Application PGM\nRC_PGMNAME          DS    F     Save application RC\nPARM_LENGTH         DS    H     Parm length wihout header\nGETMSAVE            DS    F     Parm length wihout header\nADBLKPTR            DS    F     Parm length wihout header\nADBLKEND            DS    F     Parm length wihout header\nDOALL               DS    CL1   Analyze a complete loadlib\nDD_COBANAL          DS    CL1   Switch for DD CobAnal\nDOUBLE              DS    D\nCSV_LENGTH          DS    F     Length returned by CSVQuery\n         CSVQUERY MF=(L,CSVQRYWK)\n         ASAXWC    MF=(L,MYLIST)\n****************************** VARIABLES *****************************\nLE_SWITCH           DS    CL1   Switch for COBOL/370 or COBOL/2\nLE_PGM_NAME         DS CL8  name of program\nLE_COMP_YEAR        DS CL4  year of compilation\n*  3 bytes because of OS/VS COBOL\nLE_COMP_MONTH       DS CL3  month of compilation\nLE_COMP_DAY         DS CL2  day of compilation\nLE_COMP_HOURS       DS CL2  hours of compilation\nLE_COMP_MIN         DS CL2  minutes of compilation\nLE_COMP_SEC         DS CL2  seconds of compilation\nLE_VERS             DS CL2  version\nLE_REL              DS CL2  release\nLE_MOD              DS CL2  modification level\nLE_CCSID            DS XL2  Codepage\nLE_STATUS_BYTE      DS    0C   signature bytes\nLE_STATUS_BYTE_01   DS X    status byte\nLE_STATUS_BYTE_02   DS X    status byte\nLE_STATUS_BYTE_03   DS X    status byte\nLE_STATUS_BYTE_04   DS X    status byte\nLE_STATUS_BYTE_05   DS X    status byte\nLE_STATUS_BYTE_06   DS X    status byte\nLE_STATUS_BYTE_07   DS X    status byte\nLE_STATUS_BYTE_08   DS X    status byte\nLE_STATUS_BYTE_09   DS X    status byte\nLE_STATUS_BYTE_10   DS X    status byte\nLE_STATUS_BYTE_11   DS X    status byte\nLE_STATUS_BYTE_12   DS X    status byte\nLE_STATUS_BYTE_13   DS X    status byte\nLE_STATUS_BYTE_14   DS X    status byte\nLE_STATUS_BYTE_15   DS X    status byte\nLE_STATUS_BYTE_16   DS X    status byte\nLE_STATUS_BYTE_17   DS X    status byte\nLE_STATUS_BYTE_18   DS X    status byte\nLE_STATUS_BYTE_19   DS X    status byte\nLE_STATUS_BYTE_20   DS X    status byte\nLE_STATUS_BYTE_21   DS X    status byte\nLE_STATUS_BYTE_22   DS X    status byte\nLE_STATUS_BYTE_23   DS X    status byte\nLE_STATUS_BYTE_24   DS X    status byte\nLE_STATUS_BYTE_25   DS X    status byte\nLE_STATUS_BYTE_26   DS X    status byte Cobol for MVS and VM\nLE_STATUS_BYTE_27   DS X    status byte Cobol for MVS and VM\nLE_STATUS_BYTE_28   DS X    status byte Cobol V3R1\nLE_STATUS_BYTE_29   DS X    status byte Cobol V3R1\nLE_COBOL_SIGNAT     DS X    cobol signature level\nLE_DATA_STATEMENTS  DS XL4  number of data items\nLE_PROC_LINES       DS XL4  number of proc statements\nLE_YEAR_WINDOW      DS H    YearWindow\nSYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,                      *\n               RECFM=FB,LRECL=121\nINPUT    DCB   DSORG=PS,DDNAME=COBANAL,MACRF=(GM),                     *\n               RECFM=U,BLKSIZE=256\nDIRAREA             DS    XL256 PDS-Directory input area\nPARMLIST            DS XL40\nRECORD              DS CL132\nCOBANAL_WORK_LENGTH EQU *-COBANAL_WORK  Length workarea\n*\n*============================================================*\n* Parameter (JCL)                                            *\n*============================================================*\nCOBANAL_PARM        DSECT\nCOBANAL_PARM_LENGTH DS H\n*\n*\n*============================================================*\n* COBOL/370 DCL\n*============================================================*\nCOBOL_370_DSECT     DSECT\n                    DS CL4  bypass\nCEE_EYECATCHER      DS CL4  excatcher\nCEE_STACK_FRAME     DS F    stack frame size\nCEE_PPA1_OFFSET     DS F    offset to first ppa1\n                    DS CL4  reserved\nCEE_PPA1_START      DS 0C\nCEE_OFFSET          DS X    offset to length of name from ppa1\nCEE_SIGNATURE       DS X    CEL-Signature\nCEE_FLAG1           DS X    CEL-FLAGS Bitmask\nCEE_FLAG2           DS X    Member Flags for Cobol\nCEE_ADDRESS_OF_PPA2 DS F    Address of PPA2\nCEE_OFFSET_DBI      DS F    Offset BDI (None)\nCEE_EP_DESCRIPTOR   DS F    Entry Point Descriptor\nCEE_STACK_OVERFLOW  DS F    Offset for Stack overflow\n                    DS F    available word\n                    DS F    available word\n                    DS F    available word\n                    DS F    available word\nCEE_PRIMARY_EP      DS 0C\nCEE_PRI_EP_ADDRESS  DS A    primary entry-point address\nCEE_PGT_ADDRESS     DS A    PGT-Address\nCEE_TGT_ADDRESS     DS A    PGT-Address\nCEE_EP_NAME         DS A    Offset to entry_point_name\nCEE_CURRENT_EP      DS A    current EP-Address\nCEE_START           DS A    procedure code Address\nCEE_INIT_PROG       DS A    Initialize Routine\nCEE_PARM_LIST       DS A    Address of parm list for CEEINT\n                    DS F    available word\n                    DS H    available half-word\nCEE_LENGTH_NAME     DS XL2  length of program_name\nCEE_NAME_PART       DS 0C\nCEE_PGM_NAME        DS CL8  name of program\nCEE_COMP_YEAR       DS CL4  year of compilation\nCEE_COMP_MONTH      DS CL2  month of compilation\nCEE_COMP_DAY        DS CL2  day of compilation\nCEE_COMP_HOURS      DS CL2  hours of compilation\nCEE_COMP_MIN        DS CL2  minutes of compilation\nCEE_COMP_SEC        DS CL2  seconds of compilation\nCEE_VERS            DS CL2  version\nCEE_REL             DS CL2  release\nCEE_MOD             DS CL2  modification level\nCEE_CCSID           DS XL2  Codepage (COBOL V3R1 only)\n                    DS H    available halfword\nCEE_STATUS_BYTE_28  DS X    status byte\nCEE_STATUS_BYTE_29  DS X    status byte\nCEE_YEAR_WINDOW     DS H    YearWindow\nCEE_STATUS_BYTE_01  DS X    status byte\nCEE_STATUS_BYTE_02  DS X    status byte\nCEE_STATUS_BYTE_03  DS X    status byte\nCEE_STATUS_BYTE_04  DS X    status byte\nCEE_STATUS_BYTE_05  DS X    status byte\nCEE_STATUS_BYTE_06  DS X    status byte\nCEE_STATUS_BYTE_07  DS X    status byte\nCEE_STATUS_BYTE_08  DS X    status byte\nCEE_STATUS_BYTE_09  DS X    status byte\nCEE_STATUS_BYTE_10  DS X    status byte\nCEE_STATUS_BYTE_11  DS X    status byte\nCEE_STATUS_BYTE_12  DS X    status byte\nCEE_STATUS_BYTE_13  DS X    status byte\nCEE_STATUS_BYTE_14  DS X    status byte\nCEE_STATUS_BYTE_15  DS X    status byte\nCEE_STATUS_BYTE_16  DS X    status byte\nCEE_STATUS_BYTE_17  DS X    status byte\nCEE_STATUS_BYTE_18  DS X    status byte\nCEE_STATUS_BYTE_19  DS X    status byte\nCEE_STATUS_BYTE_20  DS X    status byte\nCEE_STATUS_BYTE_21  DS X    status byte\nCEE_STATUS_BYTE_22  DS X    status byte\nCEE_STATUS_BYTE_23  DS X    status byte\nCEE_COBOL_SIGNAT    DS X    cobol signature level\nCEE_DATA_STATEMENTS DS XL4  number of data items\nCEE_PROC_LINES      DS XL4  number of proc statements\nCEE_STATUS_BYTE_24  DS X    status byte\nCEE_STATUS_BYTE_25  DS X    status byte\nCEE_STATUS_BYTE_26  DS X    status byte\nCEE_STATUS_BYTE_27  DS X    status byte\n*============================================================*\n* COBOL2 DCL\n*============================================================*\nCOBOL_2_DSECT      DSECT\n                   DS CL4  bypass\n                   DS X\nC2_PGM_NAME        DS CL8  name of program\nC2_EYECATCHER      DS CL4  eyecatcher\nC2_VERS            DS CL2  version\nC2_REL             DS CL2  release\nC2_MOD             DS CL2  modification level\nC2_COMP_MONTH      DS CL2  month of compilation\n                   DS CL1\nC2_COMP_DAY        DS CL2  day of compilation\n                   DS CL1\nC2_COMP_YEAR       DS CL2  year of compilation\n                   DS CL1\nC2_COMP_HOURS      DS CL2  hours of compilation\n                   DS CL1\nC2_COMP_MIN        DS CL2  minutes of compilation\n                   DS CL1\nC2_COMP_SEC        DS CL2  seconds of compilation\nC2_GET_ENTRY       DS A    Address of address\nC2_STATUS_BYTE_01  DS X    status byte\nC2_STATUS_BYTE_02  DS X    status byte\nC2_STATUS_BYTE_03  DS X    status byte\nC2_STATUS_BYTE_04  DS X    status byte\nC2_STATUS_BYTE_05  DS X    status byte\nC2_STATUS_BYTE_06  DS X    status byte\nC2_STATUS_BYTE_07  DS X    status byte\nC2_STATUS_BYTE_08  DS X    status byte\nC2_STATUS_BYTE_09  DS X    status byte\nC2_STATUS_BYTE_10  DS X    status byte\nC2_STATUS_BYTE_11  DS X    status byte\nC2_STATUS_BYTE_12  DS X    status byte\nC2_STATUS_BYTE_13  DS X    status byte\nC2_STATUS_BYTE_14  DS X    status byte\nC2_STATUS_BYTE_15  DS X    status byte\nC2_STATUS_BYTE_16  DS X    status byte\nC2_STATUS_BYTE_17  DS X    status byte\nC2_STATUS_BYTE_18  DS X    status byte\nC2_STATUS_BYTE_19  DS X    status byte\nC2_STATUS_BYTE_20  DS X    status byte\nC2_STATUS_BYTE_21  DS X    status byte\nC2_STATUS_BYTE_22  DS X    status byte\nC2_STATUS_BYTE_23  DS X    status byte\n                   DS X    cobol signature level\nC2_DATA_STATEMENTS DS XL4  number of data items\nC2_PROC_LINES      DS XL4  number of proc statements\nC2_STATUS_BYTE_24  DS X    status byte\nC2_STATUS_BYTE_25  DS X    status byte\n                   DS XL2  status byte\n                   DS CL4  status byte\nC2_PRI_EP_ADDRESS  DS A    primary entry-point address\n*\n*============================================================*\n* OS/VS COBOL\n*============================================================*\nCOBOL_1_DSECT      DSECT\n                   DS CL12 bypass\nC1_PGM_NAME        DS CL8  name of program\nC1_EYECATCHER      DS CL2  eyecatcher\nC1_REL             DS CL2  release\n                   DS CL36\nC1_TGT_PTR         DS F    pointer to tgt\n                   DS CL8  unknown                               RS0700\nC1_OEM_MOD_AREA    DS CL60 Optimizer Info orgin COBOL low-values RS0700\n                   DS CL4  unknown                               RS0700\nC1_COMP_HOURS      DS CL2  hours of compilation\n                   DS CL1\nC1_COMP_MIN        DS CL2  minutes of compilation\n                   DS CL1\nC1_COMP_SEC        DS CL2  seconds of compilation\nC1_COMP_MONTH      DS CL3  month of compilation\n                   DS CL1\nC1_COMP_DAY        DS CL2  day of compilation\n                   DS CL2\nC1_COMP_YEAR       DS CL4  year of compilation\nCOBOL_1_TGT        DSECT\n                   DS CL72 ?\nC1_STATUS_BYTE_01  DS X    status byte\nC1_STATUS_BYTE_02  DS X    status byte\nC1_STATUS_BYTE_03  DS X    status byte\n                   DS CL369\nC1_CHECK           DS CL8  check TGT for SYSOUT\n*\n         DCBD    DSORG=QS\n         STRING GENERATE\nBIT0     EQU   B'10000000'\nBIT1     EQU   B'01000000'\nBIT2     EQU   B'00100000'\nBIT3     EQU   B'00010000'\nBIT4     EQU   B'00001000'\nBIT5     EQU   B'00000100'\nBIT6     EQU   B'00000010'\nBIT7     EQU   B'00000001'\n*------------------------------------------------------------*\n* Program equates                                            *\n*------------------------------------------------------------*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n./ ADD NAME=COBANAL1 0177-99161-01011-0758-01916-01635-00000-XSSGSCH\n***********************************************************************\n*                                                                     *\n* Name:         COBANAL                                               *\n*                                                                     *\n* Author:       Roland Schiradin                                      *\n*               roland(at)Schiradin.de                                *\n*                                                                     *\n* Date:         Februar 1996                                          *\n*                                                                     *\n* Description:  Show compile-settings and some other information      *\n*                                                                     *\n* Changes:      16.12.1996 (european)                                 *\n*               Support for VS/COBOL1 (just a few)                    *\n*               String macro no longer inside this source             *\n*               (request FILE183 from Naspa or drop me an email)      *\n*               28.04.1997 (european)                                 *\n*               Support for COBOL for MVS and VM Release 2 (formally  *\n*               called AD/Cycle COBOL/370)                            *\n*               04.03.1998 (european)                                 *\n*               MODID-marco dropped                                   *\n*               Direct Load-Library support                           *\n*               Some parts of Dave Alcocks code (DA$COBR)             *\n*               (You can contact him at dalcock(at)csw.com)           *\n*               24.03.1998 (european)                                 *\n*               Prevent S15D abend you invoke COBANAL from TSO-CALL   *\n*               (reported by Dave Alcock)                             *\n*               Support for newer STRING macro STRING GENERATE instaed*\n*               of STRING FINAL_CALL                                  *\n*               (reported by Dave Alcock)                             *\n*               Fixed a bug in statement list. Y now means Yes and not*\n*               vice versa. Sorry                                     *\n*               15.02.1999 (european)                                 *\n*               Support for COBOL OS/390 and VM V2R1                  *\n*               Some new Compile-options                              *\n*               Compile-Date is European style, added long name       *\n*               Some minor fixes I cant remember in detail            *\n*               Support for MVS 4.3 (AMODE switching)                 *\n*               10.06.1999 (european)                                 *\n*               Fixed bugs reported by Mr. Smets (Thank you)          *\n*               Show ?? as the century for COBOL2                     *\n*               Support for Entrypoints (e.g. ENTRY 'DLITCBL')        *\n*               Note: There is no need to do this for IMS             *\n*               25.10.1999 (european)                                 *\n*               Check ParmLength for Parameter \"ALL\".                 *\n*               Close all datasets                                    *\n*               Make CobAnal reentrant (LinkList!!!)                  *\n*               Release storage                                       *\n*               Load modules from DD COBANAL if exist                 *\n*               29.12.1999 (european)                                 *\n*               Abend 0C4 fixed                                       *\n*               Add PPA2 support                                      *\n*               Detect C/C++ and LE-enabled Assembler Programs        *\n*               The product name for COBOL1 is OS/VS Cobol (MVS) and  *\n*               DOS/VS COBOL (VSE)                                    *\n*               13.04.2000 (european)                                 *\n*               Support for some infos I missed (INVOKE, GLOBAL and   *\n*               so on) Thank you Mr. Gross                            *\n*               Add a third base register                             *\n*               23.04.2000 (european)                                 *\n*               Tested with STRING V507 from FILE183                  *\n*               19.07.2000 (european)                                 *\n*               Support for COBOL1 OEM products (e.g. CA-Optimzer)    *\n*               Thank you Mr. Pfeifer                                 *\n*               02.10.2000 (european)                                 *\n*               Support for COBOL for OS/390 & VM V2R2                *\n*               New TEST(SEPARATE)/NO TEST(SEPARATE)                  *\n*               New ARITH(EXTEND)/ARITH(COMPAT)                       *\n*               New line-sequential file                              *\n*               Thank you IBM for HFS-Support and Display under CICS  *\n*               Save some literal pool                                *\n*               I know I need to re-design the program but the        *\n*               time (you may know) is limited. At the start it       *\n*               was intend to run once and then throw it away         *\n*               Thanks for all ideas to do it better, if I'm retired  *\n*               I would spent some time on it. Don't expect that      *\n*               within the next 25 years !!!                          *\n*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 09.10.1999 (european)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 *\n*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 End-Substract changed to End-Subtract\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 *\n*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Corect a length for moving literal Subtract\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 *\n*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 08.01.2001 (european)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 *\n*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Loop bug fixed\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 *\n***********************************************************************\n         TITLE 'Show Compile-Option and some more nice info'\nCOBANAL  CSECT\nCOBANAL  AMODE 31\nCOBANAL  RMODE 24\n         BAKR  R14,R0             Save register\n         LA    R10,1\n         LR    R6,R15             set base register\n         LA    R7,4095(R10,R6)    second base register\n         LA    R12,4095(R10,R7)   third base register\n         USING COBANAL,R6,R7,R12     Addressebility\n         L     R9,0(R1)           Save Parmlist\n         USING COBANAL_PARM,R9    addressebility\n         LA    R0,COBANAL_WORK_LENGTH\n         STORAGE OBTAIN,LENGTH=(R0),ADDR=(R1),COND=NO,LOC=BELOW\n         LR    R11,R1             COBANAL_WORK register\n         USING COBANAL_WORK,R11   addressebility\n         MVC   EYECATCHER,=CL8'COBANAL'\n         MVI   DOALL,C'N'         Default\n         MVI   DD_COBANAL,C'N'    Default\n         XC    SAVEAREA,SAVEAREA  clear saveare\n         LA    R15,SAVEAREA       get address of savearea\n         ST    R13,4(,R15)        chain the savearea back pointer\n         ST    R15,8(,R13)        chain saveare forward\n         LR    R13,R15            set new savearea\n         ST    R11,ADR_COBANAL_WORK  save address\n         ST    R9,ADR_COBANAL_PARM   save address\n*------------------------------------------------------------*\n*        Check JCL-Parm                                      *\n*------------------------------------------------------------*\n         MVC   PARM_LENGTH,COBANAL_PARM_LENGTH\n         LH    R10,PARM_LENGTH\n         LA    R9,2(R9)            jump length field\n         MVC   PGMNAME,BLANKS      clear PGMNANE\n         LA    R8,PGMNAME          first parm\nCOBANAL_010 DS  0H                 do until first ',' or end\n         CLI   0(R9),C','          parm separator\n         BE    COBANAL_020         next parm\n         MVC   0(1,R8),0(R9)\n         LA    R8,1(R8)            next digit\n         LA    R9,1(R9)            next digit\n         BCT   R10,COBANAL_010     loop\nCOBANAL_020 DS  0H\n         MVC   SYSPRINT(SYSPRINT_FIX_LENGTH),SYSPRINT_FIX\n         MVC   PARMLIST(C_LSTOL),C_LSTO\n         LA    R9,SYSPRINT\n         USING IHADCB,R9\n         MVC   DCBDDNAM,=C'SYSPRINT'\n         OPEN  ((R9),OUTPUT),MF=(E,PARMLIST)\n         DROP  R9\n         DEVTYPE =CL8'COBANAL',DOUBLE     Get COBANAL information\n         LTR   R15,R15                    Is it allocated?\n         BNZ   COBANAL_021                No, continue\n         MVI   DD_COBANAL,C'Y'    Default\n         MVC   INPUT(INPUT_FIX_LENGTH),INPUT_FIX\n         MVC   PARMLIST(C_LSTIL),C_LSTI\n         LA    R9,INPUT\n         USING IHADCB,R9\n         MVC   DCBDDNAM,=C'COBANAL '\n         OPEN  ((R9),INPUT),MF=(E,PARMLIST)\n         DROP  R9\nCOBANAL_021 DS  0H\n         STRING 'COBOL module analysis is starting',INTO=RECORD\n         BAL   R14,SPACE1                 Print starting message\n         CLC   PGMNAME,BLANKS      check PGMNAME\n         BE    COBANAL_PARM_ERROR  if clear ==> Error\n         CLC   PGMNAME(3),=C'ALL'  PGMNAME = ALL indicate analyzing\n         BNE   COBANAL_025         a complete Load, but check for\n         CLC   PARM_LENGTH,=H'3'   length; maybe it is a prog called\n         BNE   COBANAL_025         ALLWAYS :-))\n         CLI   DD_COBANAL,C'Y'        Did you read the docs?\n         BE    COBANAL_022           yes, thats fine\n         STRING 'Parameter=ALL specified but DD-Name COBANAL missing', *\n               INTO=RECORD\n         BAL   R14,SPACE1                 Print starting message\n         MVC   RETCODE,=F'12'\n         B     COBANAL_EXIT         no, leave\n** Loop\nCOBANAL_022 DS  0H\n         MVI   DOALL,C'Y'          remember that\n         BAL   R14,GETMEM          get the member name\n         CLC   PGMNAME,XFF         more entries?\n         BE    COBANAL_EXIT          leave\n*------------------------------------------------------------*\n*        Load the progamm from DD COBANAL                    *\n*------------------------------------------------------------*\n         LOAD  EPLOC=PGMNAME,DCB=INPUT,ERRET=COBANAL_LOAD_ERROR\n         B     COBANAL_027\nCOBANAL_025 DS  0H\n         CLI   DD_COBANAL,C'Y'    load from DD Cobanal ?\n         BE    COBANAL_026           yes\n*------------------------------------------------------------*\n*        Load the progamm                                    *\n*------------------------------------------------------------*\n         LOAD  EPLOC=PGMNAME       Load the pgm\n         B     COBANAL_027\nCOBANAL_026 DS  0H\n*------------------------------------------------------------*\n*        Load the progamm from DD COBANAL                    *\n*------------------------------------------------------------*\n         LOAD  EPLOC=PGMNAME,DCB=INPUT,ERRET=COBANAL_LOAD_ERROR\nCOBANAL_027 DS  0H\n         LTR   R15,R15             check response\n         BNZ   COBANAL_LOAD_ERROR if greater zero ==> Error\n         ST    R0,ADR_PGMNAME      save the address\n*------------------------------------------------------------*\n*        Check length                                        *\n*------------------------------------------------------------*\n         CSVQUERY SEARCH=JPALPA,       SEARCH JPAQ                     +\n               INADDR=ADR_PGMNAME,     ADDRESS                         +\n               OUTLENGTH=CSV_LENGTH,                                   +\n               MF=(E,CSVQRYWK)         WORK AREA\n         LTR   R2,R15                  pass return code\n         BNZ   COBANAL_CSV_ERROR if greater zero ==> Error\n*------------------------------------------------------------*\n*        Write info to sysprint                              *\n*------------------------------------------------------------*\nCOBANAL_03 DS  0H\n         STRING 'Program Name= ',PGMNAME,                              @\n               ' was loaded into storage at EPA= ',(ADR_PGMNAME,,X),   @\n               INTO=RECORD\n         BAL   R14,SPACE1\n*\n*        Dump the first 256 Bytes for Identification.\n*        Should be activate only in case of problems\n*\n*        L     R4,ADR_PGMNAME\n*        LA    R3,256/16               LOOP COUNTER\n*LOOP\nCOBANAL_04 DS  0H\n*        STRING 4X,((R4),4,X),1X,(4(R4),4,X),1X,(8(R4),4,X),1X,        X\n               (12(R4),4,X),3X,((R4),16),                              $\n               INTO=RECORD\n*        BAL   R14,SPACE1          <== next line\n*        LA    R4,016(,R4)             BUMP POINTER\n*        BCT   R3,COBANAL_04\n*ENDLOOP\n         L     R4,ADR_PGMNAME       Load-Entry-Point\n         USING COBOL_370_DSECT,R4\n         CLC   CSV_LENGTH,=F'24'    At least 24 bytes!!!\n         BNH   COBANAL_06            prevent S0C4\n         CLC   CEE_EYECATCHER,C_COBOL370   COBOL/370 ?  X'00C3C5C5'\n         BE    COBOL_370\n         CLC   CEE_EYECATCHER,C_OPLINK     C         ?  X'01C3C5C5'\n         BE    C_370\n         USING COBOL_2_DSECT,R4\n         CLC   C2_EYECATCHER,=CL4' C2 '     COBOL/2 ?  X'40C3F240'\n         BE    COBOL_2\n         USING COBOL_1_DSECT,R4\n* ???    CLC   C1_EYECATCHER,=CL2'AN'       ANS4 COBOL ?\n* ???    BE    COBOL_1\n         CLC   C1_EYECATCHER(4),=CL4'VSR1'       OS/VS COBOL/1 ?\n         BE    COBOL_1\n         CLC   C1_EYECATCHER(4),=CL4'VSR2'       OS/VS COBOL/1 ?\n         BE    COBOL_1\nCOBANAL_06 DS  0H\n         STRING 'Can not established the program_language',INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'8'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_08 DS  0H\n         STRING 'Program=',PGMNAME,' seems to be LE but',              X\n               ' PPA1 looks invalid',INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'8'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_09 DS  0H\n         CLI   0(R2),X'03'          ID = C       (03) ?\n         BNE   COBANAL_10             no check Assembler\n         STRING 'Program=',PGMNAME,' is a C-Program ',INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'8'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_10 DS  0H\n         CLI   0(R2),X'0F'          ID = Assembler (15) ?\n         BNE   COBANAL_06             no, unknown language\n         STRING 'Program=',PGMNAME,' is a LE-enabled ',                X\n               'Assembler',INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'8'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_PARM_ERROR DS  0H\n         STRING 'Error parm statement, check it',INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'12'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_LOAD_ERROR DS  0H\n         STRING 'Error during load of program=',PGMNAME,INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'12'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_CSV_ERROR DS  0H\n         STRING 'CSVQUERY failed, RC5=',((R2),,L),INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'12'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_EXIT       DS 0H\n         DELETE EPLOC=PGMNAME       Delete the pgm\n         CLI   DOALL,C'N'           Default\n         BE    COBANAL_FIN\n         CLC   PGMNAME,XFF          Last Program?\n         BNE   COBANAL_022           no loop\nCOBANAL_FIN        DS 0H\n         LA    R9,SYSPRINT\n         USING IHADCB,R9\n         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is it OPEN?\n         BNO   COBANAL_FIN_1              No, ignore it\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE\n         CLOSE ((R9)),MF=(E,PARMLIST)      Close it\n         DROP  R9\nCOBANAL_FIN_1      DS 0H\n         LA    R9,INPUT\n         USING IHADCB,R9\n         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is it OPEN?\n         BNO   COBANAL_FIN_2              No, ignore it\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE\n         CLOSE ((R9)),MF=(E,PARMLIST)      Close it\n         DROP  R9\nCOBANAL_FIN_2      DS 0H\n         LA    R0,COBANAL_WORK_LENGTH\n         STORAGE RELEASE,              free Storage                    *\n               LENGTH=(R0),            Length                          *\n               ADDR=((R11))\n         L     R15,RETCODE\n         PR\n*============================================================*\n*    C/370 Program OPLINK Bit on !!!!!                       *\n*    Offset instead of relative pointer!!!                   *\n*============================================================*\nC_370    DS 0H\n         LR    R2,R4\n         A     R2,12(,R4)          PPA1\n         CLI   1(R2),X'CE'         Check PPA1\n         BNE   COBANAL_08            seems invalid PPA1\n         A     R4,4(,R2)           PPA2 pointer\n         LR    R2,R4\n         B     COBANAL_09          check languages\n*============================================================*\n*    COBOL/370 Program                                       *\n*============================================================*\nCOBOL_370 DS 0H\n         USING COBOL_370_DSECT,R4\n         LR    R2,R4\n         A     R2,12(,R4)          PPA1\n         CLI   1(R2),X'CE'         Check PPA1\n         BNE   COBANAL_08            seems invalid PPA1\n         ICM   R2,B'1111',4(R2)    PPA2 pointer\n         BZ    COBANAL_08            seems invalid PPA1\n         CLI   0(R2),X'05'         ID = Cobol!! (15)\n         BNE   COBANAL_09            no, error\n         MVI   LE_SWITCH,C'1'\n         L     R4,CEE_PRI_EP_ADDRESS\n         MVC   LE_VERS,CEE_VERS\n         MVC   LE_REL,CEE_REL\n         MVC   LE_MOD,CEE_MOD\n         MVC   LE_PGM_NAME,CEE_PGM_NAME\n         MVC   LE_COMP_DAY,CEE_COMP_DAY\n         MVC   LE_COMP_MONTH,CEE_COMP_MONTH\n         MVC   LE_COMP_YEAR,CEE_COMP_YEAR\n         MVC   LE_COMP_HOURS,CEE_COMP_HOURS\n         MVC   LE_COMP_MIN,CEE_COMP_MIN\n         MVC   LE_COMP_SEC,CEE_COMP_SEC\n         MVC   LE_DATA_STATEMENTS,CEE_DATA_STATEMENTS\n         MVC   LE_PROC_LINES,CEE_PROC_LINES\n         MVC   LE_YEAR_WINDOW,CEE_YEAR_WINDOW\n         MVC   LE_STATUS_BYTE_01,CEE_STATUS_BYTE_01\n         MVC   LE_STATUS_BYTE_02,CEE_STATUS_BYTE_02\n         MVC   LE_STATUS_BYTE_03,CEE_STATUS_BYTE_03\n         MVC   LE_STATUS_BYTE_04,CEE_STATUS_BYTE_04\n         MVC   LE_STATUS_BYTE_05,CEE_STATUS_BYTE_05\n         MVC   LE_STATUS_BYTE_06,CEE_STATUS_BYTE_06\n         MVC   LE_STATUS_BYTE_07,CEE_STATUS_BYTE_07\n         MVC   LE_STATUS_BYTE_08,CEE_STATUS_BYTE_08\n         MVC   LE_STATUS_BYTE_09,CEE_STATUS_BYTE_09\n         MVC   LE_STATUS_BYTE_10,CEE_STATUS_BYTE_10\n         MVC   LE_STATUS_BYTE_11,CEE_STATUS_BYTE_11\n         MVC   LE_STATUS_BYTE_12,CEE_STATUS_BYTE_12\n         MVC   LE_STATUS_BYTE_13,CEE_STATUS_BYTE_13\n         MVC   LE_STATUS_BYTE_14,CEE_STATUS_BYTE_14\n         MVC   LE_STATUS_BYTE_15,CEE_STATUS_BYTE_15\n         MVC   LE_STATUS_BYTE_16,CEE_STATUS_BYTE_16\n         MVC   LE_STATUS_BYTE_17,CEE_STATUS_BYTE_17\n         MVC   LE_STATUS_BYTE_18,CEE_STATUS_BYTE_18\n         MVC   LE_STATUS_BYTE_19,CEE_STATUS_BYTE_19\n         MVC   LE_STATUS_BYTE_20,CEE_STATUS_BYTE_20\n         MVC   LE_STATUS_BYTE_21,CEE_STATUS_BYTE_21\n         MVC   LE_STATUS_BYTE_22,CEE_STATUS_BYTE_22\n         MVC   LE_STATUS_BYTE_23,CEE_STATUS_BYTE_23\n         MVC   LE_STATUS_BYTE_24,CEE_STATUS_BYTE_24\n         MVC   LE_STATUS_BYTE_25,CEE_STATUS_BYTE_25\n         MVC   LE_STATUS_BYTE_26,CEE_STATUS_BYTE_26\n         MVC   LE_STATUS_BYTE_27,CEE_STATUS_BYTE_27\n         B     LE370_INFO\n*============================================================*\n*    COBOL/2 Program                                         *\n*============================================================*\nCOBOL_2 DS 0H\n         USING COBOL_2_DSECT,R4\n         MVI   LE_SWITCH,C'2'\n         L     R4,C2_GET_ENTRY\n         L     R4,0(R4)\n         MVC   LE_VERS,C2_VERS\n         MVC   LE_REL,C2_REL\n         MVC   LE_MOD,C2_MOD\n         MVC   LE_PGM_NAME,C2_PGM_NAME\n         MVC   LE_COMP_DAY,C2_COMP_DAY\n         MVC   LE_COMP_MONTH,C2_COMP_MONTH\n         MVC   LE_COMP_YEAR(2),=C'??'    COBOL2 not Y2K ready\n         MVC   LE_COMP_YEAR+2(2),C2_COMP_YEAR\n         MVC   LE_COMP_HOURS,C2_COMP_HOURS\n         MVC   LE_COMP_MIN,C2_COMP_MIN\n         MVC   LE_COMP_SEC,C2_COMP_SEC\n         MVC   LE_DATA_STATEMENTS,C2_DATA_STATEMENTS\n         MVC   LE_PROC_LINES,C2_PROC_LINES\n         MVC   LE_STATUS_BYTE_01,C2_STATUS_BYTE_01\n         MVC   LE_STATUS_BYTE_02,C2_STATUS_BYTE_02\n         MVC   LE_STATUS_BYTE_03,C2_STATUS_BYTE_03\n         MVC   LE_STATUS_BYTE_04,C2_STATUS_BYTE_04\n         MVC   LE_STATUS_BYTE_05,C2_STATUS_BYTE_05\n         MVC   LE_STATUS_BYTE_06,C2_STATUS_BYTE_06\n         MVC   LE_STATUS_BYTE_07,C2_STATUS_BYTE_07\n         MVC   LE_STATUS_BYTE_08,C2_STATUS_BYTE_08\n         MVC   LE_STATUS_BYTE_09,C2_STATUS_BYTE_09\n         MVC   LE_STATUS_BYTE_10,C2_STATUS_BYTE_10\n         MVC   LE_STATUS_BYTE_11,C2_STATUS_BYTE_11\n         MVC   LE_STATUS_BYTE_12,C2_STATUS_BYTE_12\n         MVC   LE_STATUS_BYTE_13,C2_STATUS_BYTE_13\n         MVC   LE_STATUS_BYTE_14,C2_STATUS_BYTE_14\n         MVC   LE_STATUS_BYTE_15,C2_STATUS_BYTE_15\n         MVC   LE_STATUS_BYTE_16,C2_STATUS_BYTE_16\n         MVC   LE_STATUS_BYTE_17,C2_STATUS_BYTE_17\n         MVC   LE_STATUS_BYTE_18,C2_STATUS_BYTE_18\n         MVC   LE_STATUS_BYTE_19,C2_STATUS_BYTE_19\n         MVC   LE_STATUS_BYTE_20,C2_STATUS_BYTE_20\n         MVC   LE_STATUS_BYTE_21,C2_STATUS_BYTE_21\n         MVC   LE_STATUS_BYTE_22,C2_STATUS_BYTE_22\n         MVC   LE_STATUS_BYTE_23,C2_STATUS_BYTE_23\n         MVC   LE_STATUS_BYTE_24,C2_STATUS_BYTE_24\n         MVC   LE_STATUS_BYTE_25,C2_STATUS_BYTE_25\n         B     LE370_INFO\n*============================================================*\n* OS/VS COBOL   Program                                      *\n*============================================================*\nCOBOL_1 DS 0H\n         USING COBOL_1_DSECT,R4\n         MVI   LE_SWITCH,C'3'\n         MVC   LE_VERS,BLANKS\n         MVC   LE_REL,C1_REL\n         MVC   LE_MOD,BLANKS\n         MVC   LE_PGM_NAME,C1_PGM_NAME\n         MVC   LE_COMP_DAY,C1_COMP_DAY\n         MVC   LE_COMP_MONTH,C1_COMP_MONTH\n         MVC   LE_COMP_YEAR,C1_COMP_YEAR\n         MVC   LE_COMP_HOURS,C1_COMP_HOURS\n         MVC   LE_COMP_MIN,C1_COMP_MIN\n         MVC   LE_COMP_SEC,C1_COMP_SEC\n         L     R5,C1_TGT_PTR\n         USING COBOL_1_TGT,R5\n         CLC   C1_CHECK,=CL8'SYSOUT'     check\n         BE    LE370_INFO\n*\n*        UNABLE TO FIND THE TASK GLOBAL TABLE  -\n*\nNOTTGT   DS    0H\n         STRING 'Program ',PGMNAME,' failed the TGT (Task Global',     @\n               'Table) test',INTO=RECORD\n         BAL   R14,SPACE2\n         LA    R15,8\n         B     COBANAL_EXIT\nLE370_INFO DS  0H\n         STRING '============ Info ==================================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING 'Program: ',PGMNAME,' is COBOL/370 Version ',LE_VERS,  *\n               ' Release ',LE_REL,' Mod-Level ',LE_MOD,INTO=RECORD\n         CLI   LE_SWITCH,C'1'\n         BE    JUMP_AROUND\n         STRING 'Program: ',PGMNAME,' is COBOL/2 Version ',LE_VERS,    *\n               ' Release ',LE_REL,' Mod-Level ',LE_MOD,INTO=RECORD\n         CLI   LE_SWITCH,C'2'\n         BE    JUMP_AROUND\n         STRING 'Program: ',PGMNAME,' is OS/VS COBOL Release ',LE_REL, *\n               INTO=RECORD\nJUMP_AROUND DS 0H\n         BAL   R14,SPACE2\n         STRING '============ Timestamps ============================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING 'Compiled program name ',LE_PGM_NAME,INTO=RECORD\n         BAL   R14,SPACE1\n         BAL   R9,LE_370_12\n         DC    CL2'01',CL3'Jan'      Long name\n         DC    CL2'02',CL3'Feb'      for our non-european user\n         DC    CL2'03',CL3'Mar'\n         DC    CL2'04',CL3'Apr'\n         DC    CL2'05',CL3'May'\n         DC    CL2'06',CL3'Jun'\n         DC    CL2'07',CL3'Jul'\n         DC    CL2'08',CL3'Aug'\n         DC    CL2'09',CL3'Sep'\n         DC    CL2'10',CL3'Okt'\n         DC    CL2'11',CL3'Nov'\n         DC    CL2'12',CL3'Dec'\n         DC    X'0000',CL3'n/a'             end of table\nLE_370_12 DS   0H\n         CLC   LE_COMP_MONTH(2),0(R9)         check properties\n         BE    LE_370_14               jump if on\n         LA    R9,5(,R9)              Skip entry\n         CLI   0(R9),0                 end of table?\n         BNE   LE_370_12               not yet, loop\nLE_370_14 DS   0H\n         STRING 'Date: ',LE_COMP_DAY,'.',(LE_COMP_MONTH,2),'.',        *\n               LE_COMP_YEAR,' (european) ',LE_COMP_DAY,'.',            *\n               (2(R9),3,T),'.',LE_COMP_YEAR,' (long) ',                *\n               ' Time: ',LE_COMP_HOURS,':',LE_COMP_MIN,                *\n               ':',LE_COMP_SEC,INTO=RECORD\n         CLI   LE_SWITCH,C'3'    OS/VS COBOL ?\n         BNE   JUMP_AROUND_2       no, go ahead\n         STRING 'Date: ',LE_COMP_DAY,'.',LE_COMP_MONTH,'.',            *\n               LE_COMP_YEAR,' Time: ',LE_COMP_HOURS,':',LE_COMP_MIN,   *\n               ':',LE_COMP_SEC,INTO=RECORD\n         BAL   R14,SPACE2\n         B     INFO_COBOL            sorry no more information\nJUMP_AROUND_2 DS 0H\n         BAL   R14,SPACE2\n         STRING '============ Statistics ============================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING 'Number of data items  : ',(LE_DATA_STATEMENTS,F,R7B), *\n               INTO=RECORD\n         BAL   R14,SPACE1\n         STRING 'Number of instructions: ',(LE_PROC_LINES,F,R7B),      *\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING '============ Options in effect =====================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         MVC   RECORD,BLANKS\n         LA    R15,RECORD\n         MVC   1(3,R15),=C'ADV'\n         TM    LE_STATUS_BYTE_01,BIT0\n         BO    *+10\n         MVC   1(5,R15),=C'NOADV'\n         LA    R15,8(R15)\n         MVC   0(5,R15),=C'APOST'\n         TM    LE_STATUS_BYTE_01,BIT1\n         BO    *+10\n         MVC   0(5,R15),=C'QUOTE'\n         LA    R15,8(R15)\n         MVC   RECORD+16(9),=CL9'DATA(31)'\n         TM    LE_STATUS_BYTE_01,BIT2\n         BO    *+10\n         MVC   RECORD+16(9),=CL9'DATA(24)'\n         MVC   RECORD+25(6),=CL6'DECK'\n         TM    LE_STATUS_BYTE_01,BIT3\n         BO    *+10\n         MVC   RECORD+25(6),=CL6'NODECK'\n         MVC   RECORD+33(6),=CL6'DUMP'\n         TM    LE_STATUS_BYTE_01,BIT4\n         BO    *+10\n         MVC   RECORD+33(6),=CL6'NODUMP'\n         MVC   RECORD+40(8),=CL8'DYNAM'\n         TM    LE_STATUS_BYTE_01,BIT5\n         BO    *+10\n         MVC   RECORD+40(8),=CL8'NODYNAM'\n         MVC   RECORD+51(10),=CL10'FASTSRT'\n         TM    LE_STATUS_BYTE_01,BIT6\n         BO    *+10\n         MVC   RECORD+51(10),=CL10'NOFASTSRT'\n         MVC   RECORD+62(8),=CL8'FDUMP'\n         TM    LE_STATUS_BYTE_01,BIT7\n         BO    *+10\n         MVC   RECORD+62(8),=CL8'NOFDUMP'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(6),=CL6'LIB'\n         TM    LE_STATUS_BYTE_02,BIT0\n         BO    *+10\n         MVC   RECORD+1(6),=CL6'NOLIB'\n         MVC   RECORD+8(7),=CL7'LIST'\n         TM    LE_STATUS_BYTE_02,BIT1\n         BO    *+10\n         MVC   RECORD+8(7),=CL7'NOLIST'\n         MVC   RECORD+16(9),=CL9'MAP'\n         TM    LE_STATUS_BYTE_02,BIT2\n         BO    *+10\n         MVC   RECORD+16(9),=CL9'NOMAP'\n         MVC   RECORD+25(6),=CL6'NUM'\n         TM    LE_STATUS_BYTE_02,BIT3\n         BO    *+10\n         MVC   RECORD+25(6),=CL6'NONUM'\n         MVC   RECORD+33(6),=CL6'OBJ'\n         TM    LE_STATUS_BYTE_02,BIT4\n         BO    *+10\n         MVC   RECORD+33(6),=CL6'NOOBJ'\n         MVC   RECORD+40(8),=CL8'OFFSET'\n         TM    LE_STATUS_BYTE_02,BIT5\n         BO    *+10\n         MVC   RECORD+40(8),=CL8'NOOFFSET'\n         MVC   RECORD+51(10),=CL10'OPTIMIZE'\n         TM    LE_STATUS_BYTE_02,BIT6\n         BO    *+10\n         MVC   RECORD+51(10),=CL10'NOOPTIMIZE'\n         MVC   RECORD+62(17),=CL17'DDNAME(no Default)'\n         TM    LE_STATUS_BYTE_02,BIT7\n         BO    *+10\n         MVC   RECORD+62(17),=CL17'DDNAME(Default)'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(15),=CL15'NUMPROC(MIG)'\n         TM    LE_STATUS_BYTE_05,BIT0\n         BO    LE_370_21\n         MVC   RECORD+1(15),=CL15'NUMPROC(PFD)'\n         TM    LE_STATUS_BYTE_03,BIT0\n         BO    *+10\n         MVC   RECORD+1(15),=CL15'NUMPROC(NOPFD)'\nLE_370_21 DS 0H\n         MVC   RECORD+16(7),=CL7'RENT'\n         TM    LE_STATUS_BYTE_03,BIT1\n         BO    *+10\n         MVC   RECORD+16(7),=CL7'NORENT'\n         MVC   RECORD+25(6),=CL6'RES'\n         TM    LE_STATUS_BYTE_03,BIT2\n         BO    *+10\n         MVC   RECORD+25(6),=CL6'NORES'\n         MVC   RECORD+33(6),=CL6'SEQ'\n         TM    LE_STATUS_BYTE_03,BIT3\n         BO    *+10\n         MVC   RECORD+33(6),=CL6'NOSEQ'\n         MVC   RECORD+40(12),=CL12'SIZE(MAX)'\n         TM    LE_STATUS_BYTE_03,BIT4\n         BO    *+10\n         MVC   RECORD+40(12),=CL12'SIZE(value)'\n         MVC   RECORD+51(9),=CL9'SOURCE'\n         TM    LE_STATUS_BYTE_03,BIT5\n         BO    *+10\n         MVC   RECORD+51(9),=CL9'NOSOURCE'\n         MVC   RECORD+62(10),=CL10'SSRANGE'\n         TM    LE_STATUS_BYTE_03,BIT6\n         BO    *+10\n         MVC   RECORD+62(10),=CL10'NOSSRANGE'\n         MVC   RECORD+72(8),=CL8'TERM'\n         TM    LE_STATUS_BYTE_03,BIT7\n         BO    *+10\n         MVC   RECORD+72(8),=CL8'NOTERM'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(8),=CL8'TEST'\n         TM    LE_STATUS_BYTE_04,BIT0\n         BO    *+10\n         MVC   RECORD+1(8),=CL8'NOTEST'\n         MVC   RECORD+8(10),=CL11'TRUNC(BIN)'\n         TM    LE_STATUS_BYTE_05,BIT4\n         BO    LE_370_33\n         MVC   RECORD+8(10),=CL11'TRUNC(STD)'\n         TM    LE_STATUS_BYTE_04,BIT1\n         BO    *+10\n         MVC   RECORD+8(10),=CL11'TRUNC(OPT)'\nLE_370_33 DS 0H\n         MVC   RECORD+25(8),=CL8'VBREF'\n         TM    LE_STATUS_BYTE_04,BIT3\n         BO    *+10\n         MVC   RECORD+25(8),=CL8'NOVBREF'\n         MVC   RECORD+33(6),=CL6'XREF'\n         TM    LE_STATUS_BYTE_04,BIT4\n         BO    *+10\n         MVC   RECORD+33(6),=CL6'NOXREF'\n         MVC   RECORD+40(6),=CL6'ZWB'\n         TM    LE_STATUS_BYTE_04,BIT5\n         BO    *+10\n         MVC   RECORD+40(6),=CL6'NOZWB'\n         MVC   RECORD+51(7),=CL7'NAME'\n         TM    LE_STATUS_BYTE_04,BIT6\n         BO    *+10\n         MVC   RECORD+51(7),=CL7'NONAME'\n         MVC   RECORD+62(8),=CL8'CMPR2'\n         TM    LE_STATUS_BYTE_04,BIT7\n         BO    *+10\n         MVC   RECORD+62(8),=CL8'NOCMPR2'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(12),=CL12'NUMCLS'  other Cobol\n         TM    LE_STATUS_BYTE_05,BIT1\n         BO    *+10\n         MVC   RECORD+1(12),=CL12'NONUMCLS'\n         CLI   LE_SWITCH,C'1'   COBOL/370\n         BNE   LE_370_42\n         CLC   LE_VERS(4),=C'0102'  Vers+Rel < 0102 COBOL MVS and VM\n         BL    LE_370_42             yes\n         MVC   RECORD+1(12),=CL12'NUMCLS(ALT)'\n         TM    LE_STATUS_BYTE_05,BIT1\n         BO    *+10\n         MVC   RECORD+1(12),=CL12'NUMCLS(PRIM)'\nLE_370_42 DS 0H\n         MVC   RECORD+16(7),=CL7'DBCS'\n         TM    LE_STATUS_BYTE_05,BIT2\n         BO    *+10\n         MVC   RECORD+16(7),=CL7'NODBCS'\n         MVC   RECORD+25(6),=CL6'AWO'\n         TM    LE_STATUS_BYTE_05,BIT3\n         BO    *+10\n         MVC   RECORD+25(6),=CL6'NOAWO'\n         CLI   LE_SWITCH,C'1'                  Cobol/370\n         BNE   LE_370_48                       no, jump around\n         MVC   RECORD+33(9),=CL9'EVENTS'       n/a COBOL/2\n         TM    LE_STATUS_BYTE_05,BIT5\n         BO    *+10\n         MVC   RECORD+33(9),=CL9'NOEVENTS'\n         MVC   RECORD+51(11),=CL11'CURRENCY'   n/a COBOL/2\n         TM    LE_STATUS_BYTE_05,BIT6\n         BO    *+10\n         MVC   RECORD+51(11),=CL11'NOCURRENCY'\nLE_370_48 DS 0H\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(40),=CL40'Compilation unit = Class'\n         TM    LE_STATUS_BYTE_05,BIT7\n         BO    *+10\n         MVC   RECORD+1(40),=CL40'Compilation unit = Program'\n         BAL   R14,SPACE1\n         MVC   RECORD+1(40),=CL40'User supplied reserved word list'\n         TM    LE_STATUS_BYTE_04,BIT2\n         BO    *+10\n         MVC   RECORD+1(40),=CL40'Installation default res. word list'  t'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         CLI   LE_SWITCH,C'1'   COBOL/370 ?\n         BNE   LE_370_50Z         no\n         CLC   LE_VERS(4),=C'0102'  Vers+Rel < 0102 COBOL MVS and VM\n         BL    LE_370_50Z         no\n*                         Supportet only for COBOL MVS and VM R2\n         MVC   RECORD+1(11),=CL11'RMODE(ANY)'\n         TM    LE_STATUS_BYTE_26,BIT0\n         BO    *+10\n         MVC   RECORD+1(11),=CL11'RMODE(24)'\n         MVC   RECORD+16(13),=CL13'TEST(STMT)'\n         TM    LE_STATUS_BYTE_26,BIT1\n         BO    *+10\n         MVC   RECORD+16(13),=CL13'NO TEST(STMT)'\n         MVC   RECORD+33(13),=CL13'TEST(PATH)'\n         TM    LE_STATUS_BYTE_26,BIT2\n         BO    *+10\n         MVC   RECORD+33(13),=CL13'NO TEST(PATH)'\n         MVC   RECORD+51(14),=CL14'TEST(BLOCK)'\n         TM    LE_STATUS_BYTE_26,BIT3\n         BO    *+10\n         MVC   RECORD+51(14),=CL14'NO TEST(BLOCK)'\n         MVC   RECORD+72(17),=CL17'OPT(FULL)'\n         TM    LE_STATUS_BYTE_26,BIT4\n         BO    *+10\n         MVC   RECORD+72(17),=CL17'NOOPT OR OPT(STD)'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(13),=CL13'INTDATE(LIL)'\n         TM    LE_STATUS_BYTE_26,BIT5\n         BO    *+10\n         MVC   RECORD+1(13),=CL13'INTDATE(ANSI)'\n         MVC   RECORD+16(3),=CL3'N/A'                            RS1000\n         CLC   LE_VERS(4),=C'0202'  Vers+Rel < 0202 COBOL MVS and VM\n         BL    LE_370_50Y           no lower                     RS1000\n         MVC   RECORD+16(14),=CL14'TEST(SEPARATE)'               RS1000\n         TM    LE_STATUS_BYTE_26,BIT6                            RS1000\n         BO    *+10                                              RS1000\n         MVC   RECORD+16(17),=CL17'NO TEST(SEPARATE)'            RS1000\nLE_370_50Y DS  0H\n         MVC   RECORD+35(22),=CL22'PGMNAME(LONGUPPER)'\n         TM    LE_STATUS_BYTE_27,BIT0\n         BO    *+10\n         MVC   RECORD+35(22),=CL22'NOT PGMNAME(LONGUPPER)'\n         MVC   RECORD+60(22),=CL22'PGMNAME(LONGMIXED)'\n         TM    LE_STATUS_BYTE_27,BIT1\n         BO    *+10\n         MVC   RECORD+60(22),=CL22'NOT PGMNAME(LONGMIXED)'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(5),=CL5'DLL'\n         TM    LE_STATUS_BYTE_27,BIT2\n         BO    *+10\n         MVC   RECORD+1(5),=CL5'NODLL'\n         MVC   RECORD+16(11),=CL11'EXPORTALL'\n         TM    LE_STATUS_BYTE_27,BIT3\n         BO    *+10\n         MVC   RECORD+16(11),=CL11'NOEXPORTALL'\n         MVC   RECORD+33(10),=CL10'DATEPROC'\n         TM    LE_STATUS_BYTE_27,BIT4\n         BO    *+10\n         MVC   RECORD+33(10),=CL10'NODATEPROC'\n         STRING (RECORD,,L),1X,'YEARWINDOW(',(LE_YEAR_WINDOW,H,R4B),   *\n               ')',INTO=RECORD\n         CLC   LE_VERS(4),=C'0202'  Vers+Rel < 0202 COBOL MVS and VM\n         BL    LE_370_50Z           no lower                     RS1000\n         MVC   RECORD+62(13),=CL13'ARITH(EXTEND)'                RS1000\n         TM    LE_STATUS_BYTE_27,BIT5                            RS1000\n         BO    *+10                                              RS1000\n         MVC   RECORD+62(13),=CL13'ARITH(COMPAT)'                RS1000\nLE_370_50Z DS 0H\n         BAL   R14,SPACE2\n         STRING '============ Additional information ================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE1\n         STRING '============ about DATA DIVISION    ================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING 'Program use',' no',' QSAM or SAM access method',      *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT0\n         BNO   LE_370_51\n         STRING 'Program use',' QSAM or SAM access method',INTO=RECORD\nLE_370_51 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' VSAM sequential files',          *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT1\n         BNO   LE_370_52\n         STRING 'Program use',' VSAM sequential files',INTO=RECORD\nLE_370_52 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' VSAM indexed files',INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT2\n         BNO   LE_370_53\n         STRING 'Program use',' VSAM indexed files',INTO=RECORD\nLE_370_53 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' VSAM RBA files',INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT3\n         BNO   LE_370_54\n         STRING 'Program use',' VSAM RBA files',INTO=RECORD\nLE_370_54 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' CODE-SET (ASCII files)',         *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT4\n         BNO   LE_370_55\n         STRING 'Program use',' CODE-SET (ASCII files)',INTO=RECORD\nLE_370_55 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' spanned records',INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT5\n         BNO   LE_370_56\n         STRING 'Program use',' spanned records',INTO=RECORD\nLE_370_56 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' picture G (DBCS) items',         *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT6\n         BNO   LE_370_57\n         STRING 'Program has',' picture G (DBCS) items',INTO=RECORD\nLE_370_57 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' OCCURS DEPENDING ON items',      *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT7\n         BNO   LE_370_58\n         STRING 'Program has',' OCCURS DEPENDING ON items',INTO=RECORD\nLE_370_58 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' SYNCHRONIZED clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT0\n         BNO   LE_370_59\n         STRING 'Program has',' SYNCHRONIZED clause',INTO=RECORD\nLE_370_59 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' JUSTIFIED clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT1\n         BNO   LE_370_60\n         STRING 'Program has',' JUSTIFIED clause',INTO=RECORD\nLE_370_60 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' POINTER items',INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT2\n         BNO   LE_370_61\n         STRING 'Program has',' POINTER items',INTO=RECORD\nLE_370_61 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' complex ODO clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT3\n         BNO   LE_370_62\n         STRING 'Program has',' complex ODO clause',INTO=RECORD\nLE_370_62 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' external',                       *\n               ' floating-point items',                                *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT4\n         BNO   LE_370_63\n         STRING 'Program has',' external',' floating-point items',     *\n               INTO=RECORD\nLE_370_63 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' internal',                       *RD\n               ' floating-point items',                                *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT5\n         BNO   LE_370_63_1\n         STRING 'Program has',' internal',' floating-point items',     *\n               INTO=RECORD\nLE_370_63_1 DS 0H\n         CLI   LE_SWITCH,C'1'                  Cobol/370\n         BNE   LE_370_64                       no, jump around\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' procedure-pointer items',        *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT7       n/a cobol/2 or OS/VS COBOL\n         BNO   LE_370_64\n         STRING 'Program has',' procedure-pointer items',              *\n               INTO=RECORD\n         CLC   LE_VERS(4),=C'0202'  Vers+Rel < 0202 COBOL MVS and VM\n         BL    LE_370_64            no lower                     RS1000\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' Line-sequential file',           *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT6\n         BNO   LE_370_64\n         STRING 'Program has',' Line-sequential file',                 *\n               INTO=RECORD\nLE_370_64 DS 0H\n         BAL   R14,SPACE2\n         STRING '============ Additional information    =============',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE1\n         STRING '============ about ENVIROMENT DIVISION =============',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING 'Program use',' no',' FILE-STATUS clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_08,BIT0\n         BNO   LE_370_66\n         STRING 'Program use',' FILE-STATUS clause',INTO=RECORD\nLE_370_66 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' RERUN clause in I/O-control',    *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_08,BIT1\n         BNO   LE_370_67\n         STRING 'Program has',' RERUN clause in I/O-control',          *\n               INTO=RECORD\nLE_370_67 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' UPSI switches',INTO=RECORD\n         TM    LE_STATUS_BYTE_08,BIT2\n         BNO   LE_370_68\n         STRING 'Program use',' UPSI switches',INTO=RECORD\nLE_370_68 DS 0H\n         BAL   R14,SPACE2\n         STRING '============ Additional information    =============',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE1\n         STRING '============ about PROCEDURE DIVISION  =============',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING 'Following statements in control (check Y/N):',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(6),=CL6'Accept'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_09,BIT0\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(3),=CL3'Add'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_09,BIT1\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(5),=CL5'Alter'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_09,BIT2\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(4),=CL4'Call'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_09,BIT3\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(6),=CL6'Cancel'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_09,BIT4\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(5),=CL5'Close'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_09,BIT7\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(7),=CL7'Compute'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_10,BIT0\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(6),=CL6'Delete'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_10,BIT2\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(7),=CL7'Display'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_10,BIT4\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(6),=CL6'Divide'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_10,BIT5\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(11),=CL11'End-Perform'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_11,BIT1\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(5),=CL5'Enter'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_11,BIT2\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(5),=CL5'Entry'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_11,BIT3\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(4),=CL4'Exit'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_11,BIT4\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(5),=CL5'Go to'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_11,BIT6\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(2),=CL2'If'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_11,BIT7\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(10),=CL10'Initialize'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_12,BIT0\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         CLI   LE_SWITCH,C'1'   COBOL/370 ?\n         BNE   LE_370_70          no, jump around\n         MVC   RECORD+86(6),=CL6'Invoke'   comes with COBOL/370\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_12,BIT1\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\nLE_370_70 DS 0H\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(7),=CL7'Inspect'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_12,BIT2\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(5),=CL5'Merge'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_12,BIT3\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(4),=CL4'Move'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_12,BIT4\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(8),=CL8'Multiply'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_12,BIT5\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(4),=CL4'Open'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_12,BIT6\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(7),=CL7'Perform'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_12,BIT7\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(4),=CL4'Read'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_13,BIT0\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(7),=CL7'Release'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_13,BIT2\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(6),=CL6'Return'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_13,BIT3\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(7),=CL7'Rewrite'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_13,BIT4\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(6),=CL6'Search'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_13,BIT5\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(3),=CL3'Set'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_13,BIT7\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(4),=CL4'Sort'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_14,BIT0\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(5),=CL5'Start'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_14,BIT1\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(4),=CL4'Stop'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_14,BIT2\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(6),=CL6'String'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_14,BIT3\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(8),=CL8'Subtract'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_14,BIT4\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(8),=CL8'Unstring'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_14,BIT7\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(3),=CL3'Use'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_15,BIT0\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(5),=CL5'Write'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_15,BIT1\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(8),=CL8'Continue'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_15,BIT2\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(7),=CL7'End-Add'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_15,BIT3\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(8),=CL8'End-Call'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_15,BIT4\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(11),=CL11'End-Compute'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_15,BIT5\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(10),=CL10'End-Delete'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_15,BIT6\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(10),=CL10'End-Divide'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_15,BIT7\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(12),=CL12'End-Evaluate'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_16,BIT0\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(6),=CL6'End-If'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_16,BIT1\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(11),=CL11'End-Muliply'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_16,BIT2\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(8),=CL8'End-Read'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_16,BIT3\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(10),=CL10'End-Return'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_16,BIT4\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(11),=CL11'End-Rewrite'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_16,BIT5\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(10),=CL10'End-Search'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_16,BIT6\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(9),=CL9'End-Start'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_16,BIT7\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(10),=CL10'End-String'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_17,BIT0\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(12),=CL12'End-Subtract'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_17,BIT1\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(12),=CL12'End-Unstring'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_17,BIT2\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(9),=CL9'End-Write'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_17,BIT3\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(6),=CL6'Goback'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_17,BIT4\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(9),=CL9'Evaluate'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_17,BIT5\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(7),=CL7'Service'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_17,BIT7\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(10),=CL10'End-Invoke'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_18,BIT0\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         STRING '====================================================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING 'No hexadecimal literals',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT0\n         BNO   LE_370_128\n         STRING 'Procedure include hexadecimal literals',INTO=RECORD\nLE_370_128 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No altered GO TO',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT1\n         BNO   LE_370_129\n         STRING 'Program contains altered GO TO',INTO=RECORD\nLE_370_129 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','I/O error declarative',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT2\n         BNO   LE_370_130\n         STRING 'I/O error declarative',INTO=RECORD\nLE_370_130 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Label declarative',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT3\n         BNO   LE_370_131\n         STRING 'Label declarative',INTO=RECORD\nLE_370_131 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Debugging declarative',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT4\n         BNO   LE_370_132\n         STRING 'Debugging declarative',INTO=RECORD\nLE_370_132 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Program segmentation',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT5\n         BNO   LE_370_133\n         STRING 'Program segmentation',INTO=RECORD\nLE_370_133 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Open Extend',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT6\n         BNO   LE_370_134\n         STRING 'Open Extend',INTO=RECORD\nLE_370_134 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Exit Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT7\n         BNO   LE_370_135\n         STRING 'Exit Program',INTO=RECORD\nLE_370_135 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No call literal',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT0\n         BNO   LE_370_136\n         STRING 'Call literal (static?), see options',INTO=RECORD\nLE_370_136 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Call identifier',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT1\n         BNO   LE_370_137\n         STRING 'Call identifier',INTO=RECORD\nLE_370_137 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Call on overflow',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT2\n         BNO   LE_370_138\n         STRING 'Call on overflow',INTO=RECORD\nLE_370_138 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Call length of',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT3\n         BNO   LE_370_139\n         STRING 'Call length of',INTO=RECORD\nLE_370_139 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Call address of',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT4\n         BNO   LE_370_140\n         STRING 'Call address of',INTO=RECORD\nLE_370_140 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Close reel/unit',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT5\n         BNO   LE_370_141\n         STRING 'Close reel/unit',INTO=RECORD\nLE_370_141 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Exponentiation used',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT6\n         BNO   LE_370_142\n         STRING 'Exponentiation used',INTO=RECORD\nLE_370_142 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Floating point items used',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT7\n         BNO   LE_370_143\n         STRING 'Floating point items used',INTO=RECORD\nLE_370_143 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Copy-Statements',INTO=RECORD\n         TM    LE_STATUS_BYTE_23,BIT0\n         BNO   LE_370_144\n         STRING 'Copy-Statements',INTO=RECORD\nLE_370_144 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Basis-Statements',INTO=RECORD\n         TM    LE_STATUS_BYTE_23,BIT1\n         BNO   LE_370_145\n         STRING 'Basis-Statements',INTO=RECORD\nLE_370_145 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','DBCS-Name in Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_23,BIT2\n         BNO   LE_370_146\n         STRING 'DBCS-Name in Program',INTO=RECORD\nLE_370_146 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Shift-In/Shift-Out',INTO=RECORD\n         TM    LE_STATUS_BYTE_23,BIT3\n         BNO   LE_370_147\n         STRING 'Shift-In/Shift-Out',INTO=RECORD\nLE_370_147 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','DBCS literal',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT0\n         BNO   LE_370_148\n         STRING 'DBCS literal',INTO=RECORD\nLE_370_148 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Replace-Statements',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT1\n         BNO   LE_370_149\n         STRING 'Replace-Statements',INTO=RECORD\nLE_370_149 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Reference modification was used',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT2\n         BNO   LE_370_150\n         STRING 'Reference modification was used',INTO=RECORD\nLE_370_150 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Nested Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT3\n         BNO   LE_370_151\n         STRING 'Nested Program',INTO=RECORD\nLE_370_151 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','INITIAL Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT4\n         BNO   LE_370_152\n         STRING 'INITIAL Program',INTO=RECORD\nLE_370_152 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','COMMON Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT5\n         BNO   LE_370_153\n         STRING 'COMMON Program',INTO=RECORD\nLE_370_153 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Select Optional Files',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT6\n         BNO   LE_370_154\n         STRING 'Select Optional Files',INTO=RECORD\nLE_370_154 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','External Files',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT7\n         BNO   LE_370_155\n         STRING 'External Files',INTO=RECORD\nLE_370_155 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Global Files',INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT0\n         BNO   LE_370_156\n         STRING 'Global Files',INTO=RECORD\nLE_370_156 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Record is varying clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT1\n         BNO   LE_370_157\n         STRING 'Record is varying clause',INTO=RECORD\nLE_370_157 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Accept from SYSIPT used in Label Declarative',  *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT2\n         BNO   LE_370_158\n         STRING 'Accept from SYSIPT used in Label Declarative',        *\n               INTO=RECORD\nLE_370_158 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Display upon SYSLST used in Label Declarative', *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT3\n         BNO   LE_370_159\n         STRING 'Display upon SYSLST used in Label Declarative',       *\n               INTO=RECORD\nLE_370_159 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Display upon SYSPCH used in Label Declarative', *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT4\n         BNO   LE_370_160\n         STRING 'Display upon SYSPCH used in Label Declarative',       *\n               INTO=RECORD\nLE_370_160 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Intrinsic function was used',INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT5\n         BNO   LE_370_161\n         STRING 'Intrinsic function was used',INTO=RECORD\nLE_370_161 DS 0H\n         BAL   R14,SPACE1\n         STRING '============ End  ==================================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         LA    R15,0\n         B     COBANAL_EXIT\nINFO_COBOL DS 0H\n         CLI   C1_OEM_MOD_AREA,X'00' low-value ?                 RS0700\n         BE    INFO_COBOL_OEM                                    RS0700\n         STRING '============ OEM Modified Area =====================',*\n               '=============================================',        *RD\n               INTO=RECORD                                       RS0700\n         BAL   R14,SPACE2                                        RS0700\n         STRING ' ',C1_OEM_MOD_AREA,INTO=RECORD                  RS0700\n         BAL   R14,SPACE2                                        RS0700\nINFO_COBOL_OEM DS 0H                                             RS0700\n         STRING '============ Options in effect =====================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(8),=CL8'SYMDMP'\n         TM    C1_STATUS_BYTE_01,X'08'\n         BO    *+10\n         MVC   RECORD+1(8),=CL8'NOSYMDMP'\n         MVC   RECORD+10(6),=CL6'FLOW'\n         TM    C1_STATUS_BYTE_01,X'04'\n         BO    *+10\n         MVC   RECORD+10(6),=CL6'NOFLOW'\n         MVC   RECORD+17(7),=CL7'STATE'\n         TM    C1_STATUS_BYTE_01,X'02'\n         BO    *+10\n         MVC   RECORD+17(7),=CL7'NOSTATE'\n         MVC   RECORD+25(6),=CL6'OPT'\n         TM    C1_STATUS_BYTE_01,X'01'\n         BO    *+10\n         MVC   RECORD+25(6),=CL6'NOOPT'\n         MVC   RECORD+32(6),=CL6'TEST'\n         TM    C1_STATUS_BYTE_02,X'10'\n         BO    *+10\n         MVC   RECORD+32(6),=CL6'NOTEST'\n         MVC   RECORD+39(6),=CL6'RES'\n         TM    C1_STATUS_BYTE_03,X'80'\n         BO    *+10\n         MVC   RECORD+39(6),=CL6'NORES'\n         MVC   RECORD+46(8),=CL8'ENDJOB'\n         TM    C1_STATUS_BYTE_03,X'40'\n         BO    *+10\n         MVC   RECORD+46(8),=CL8'NOENDJOB'\n         MVC   RECORD+55(8),=CL8'OBJ370'\n         TM    C1_STATUS_BYTE_03,X'20'\n         BO    *+10\n         MVC   RECORD+55(8),=CL8'NOOBJ370'\n         MVC   RECORD+64(8),=CL8'COUNT'\n         TM    C1_STATUS_BYTE_03,X'08'\n         BO    *+10\n         MVC   RECORD+64(8),=CL8'NOCOUNT'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(11),=CL11'READY TRACE'\n         TM    C1_STATUS_BYTE_03,X'04'\n         BO    *+10\n         MVC   RECORD+1(11),=CL11'NO TRACE'\n         BAL   R14,SPACE1\n         STRING 'Sorry no more infomation for OS/VS COBOL',INTO=RECORD\n         BAL   R14,SPACE1\n         STRING 'You better upgrade to COBOL for OS/390 (MVS) and VM', *\n               INTO=RECORD\n         BAL   R14,SPACE1\n         STRING '============ End  ==================================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         LA    R15,0\n         B     COBANAL_EXIT\n*============================================================*\n* Print                                                      *\n*============================================================*\nSPACE2   DS 0H\n         ST    R14,SAVER14\n         LA    R1,SYSPRINT         GET OUTPUT DCB ADDRESS\n         LA    R0,RECORD           GET OBJECT NAME ADDRESS\n         PUT   (1),(0)             WRITE NAME TO NOTIFY DATA SET\n         LA    R1,SYSPRINT         GET OUTPUT DCB ADDRESS\n         LA    R0,BLANKS           GET OBJECT NAME ADDRESS\n         BAS   R14,AMODE24             AMode24\n         PUT   (1),(0)             WRITE NAME TO NOTIFY DATA SET\n         BAS   R14,AMODE31             AMode31\n         L     R14,SAVER14\n         BR    R14            return\nSPACE1   DS 0H\n         ST    R14,SAVER14\n         LA    R1,SYSPRINT         GET OUTPUT DCB ADDRESS\n         LA    R0,RECORD           GET OBJECT NAME ADDRESS\n         BAS   R14,AMODE24             AMode24\n         PUT   (1),(0)             WRITE NAME TO NOTIFY DATA SET\n         BAS   R14,AMODE31             AMode31\n         L     R14,SAVER14\n         BR    R14            return\n***************************************************************\n*\n*                  get Member Name from PDS-Directory\n*\n***************************************************************\nGETMEM   EQU   *\n         ST    R14,GETMSAVE            save return address\n         L     R4,ADBLKPTR             restore pointer\n         CLC   DIRAREA(2),=XL2'0000'   Directory present?\n         BNE   NEWNAME                   yes, get next\nNEWBLOCK EQU   *\n         BAS   R14,AMODE24             Amode24\n         GET   INPUT,DIRAREA           get a new directory\n         BAS   R14,AMODE31             Amode24\n         LA    R4,DIRAREA              get work area address\n         AH    R4,DIRAREA              + length\n         ST    R4,ADBLKEND             save ending address\n         LA    R4,DIRAREA+2            Skip LL bytes\n         ST    R4,ADBLKPTR             save pointer\nNEWNAME  EQU   *\n         C     R4,ADBLKEND             end of current dir block\n         BNL   NEWBLOCK                  yes, get new block\n         MVC   PGMNAME,0(R4)           Save member-name\n         IC    R5,11(R4)               LOOK FOR ANY USER TTRN'S\n         SLL   R5,27                   SHIFT OFF UNWANTED BITS\n         SRL   R5,26                   SHIFT BACK THE USABLE BI\n         LA    R4,12(R4,R5)            ADD DISPL TO GET OVER TT\n         ST    R4,ADBLKPTR             save Pointer next mem\n         L     R14,GETMSAVE            restore return address\n         BR    R14                     goback\nAMODE24  LA    R14,0(,R14)             remove XA bit\n         BSM   R0,R14                  return\n         SPACE 2\nAMODE31  O     R14,HIBIT               add XA bit\n         BSM   R0,R14                  return\n*\n*============================================================*\n* SONSTIGE DEFINITIONS                                       *\n*============================================================*\n****************************** CONSTANTS *****************************\nC_COBOL370 DC X'00',C'CEE'                   COBOL/370 ?  X'00C3C5C5'\nC_OPLINK   DC X'01',C'CEE'                   COBOL/370 ?  X'01C3C5C5'\nHIBIT    DC    A(X'80000000')         XA BIT CONSTANS\nBLANKS   DC    CL255' '           just blanks\nC_LSTO   OPEN  (*-*,(OUTPUT)),MF=L\nC_LSTOL  EQU   *-C_LSTO\nC_LSTI   OPEN  (*-*,(INPUT)),MF=L\nC_LSTIL  EQU   *-C_LSTI\nC_CLOSE  CLOSE (*-*),MF=L\nC_CLOSEL EQU   *-C_CLOSE\nXFF      DC    XL8'FFFFFFFFFFFFFFFF' just High-value\nSYSPRINT_FIX DCB   DSORG=PS,DDNAME=SYSPRINT,MACRF=PM,                  *\n               RECFM=FB,LRECL=121\nSYSPRINT_FIX_LENGTH EQU *-SYSPRINT_FIX   Length workarea\nINPUT_FIX DCB   DSORG=PS,DDNAME=COBANAL,MACRF=(GM),                    *\n               RECFM=U,BLKSIZE=256\n*INPUT_FIX DCB   DSORG=PO,DDNAME=COBANAL,MACRF=(R),                    *\n               RECFM=U,BLKSIZE=256\nINPUT_FIX_LENGTH EQU *-INPUT_FIX     Length workarea\n*\n*============================================================*\n* Workarea below the line                                    *\n*============================================================*\nCOBANAL_WORK        DSECT\nEYECATCHER          DS    CL8   'COBANAL'\nPGMNAME             DS    CL8   Pgmname from the parmlist\nSAVEAREA            DS    18F\nSAVER14             DS    F\nRETCODE             DS    F\nADR_COBANAL_WORK    DS    F     Save Workarea pointer\nADR_COBANAL_PARM    DS    F     Save Parmlist pointer\nADR_PGMNAME         DS    F     Save entry-point Application PGM\nRC_PGMNAME          DS    F     Save application RC\nPARM_LENGTH         DS    H     Parm length wihout header\nGETMSAVE            DS    F     Parm length wihout header\nADBLKPTR            DS    F     Parm length wihout header\nADBLKEND            DS    F     Parm length wihout header\nDOALL               DS    CL1   Analyze a complete loadlib\nDD_COBANAL          DS    CL1   Switch for DD CobAnal\nDOUBLE              DS    D\nCSV_LENGTH          DS    F     Length returned by CSVQuery\n         CSVQUERY MF=(L,CSVQRYWK)\n****************************** VARIABLES *****************************\nLE_SWITCH           DS    CL1   Switch for COBOL/370 or COBOL/2\nLE_PGM_NAME         DS CL8  name of program\nLE_COMP_YEAR        DS CL4  year of compilation\n*  3 bytes because of OS/VS COBOL\nLE_COMP_MONTH       DS CL3  month of compilation\nLE_COMP_DAY         DS CL2  day of compilation\nLE_COMP_HOURS       DS CL2  hours of compilation\nLE_COMP_MIN         DS CL2  minutes of compilation\nLE_COMP_SEC         DS CL2  seconds of compilation\nLE_VERS             DS CL2  version\nLE_REL              DS CL2  release\nLE_MOD              DS CL2  modification level\nLE_STATUS_BYTE      DS    0C   signature bytes\nLE_STATUS_BYTE_01   DS X    status byte\nLE_STATUS_BYTE_02   DS X    status byte\nLE_STATUS_BYTE_03   DS X    status byte\nLE_STATUS_BYTE_04   DS X    status byte\nLE_STATUS_BYTE_05   DS X    status byte\nLE_STATUS_BYTE_06   DS X    status byte\nLE_STATUS_BYTE_07   DS X    status byte\nLE_STATUS_BYTE_08   DS X    status byte\nLE_STATUS_BYTE_09   DS X    status byte\nLE_STATUS_BYTE_10   DS X    status byte\nLE_STATUS_BYTE_11   DS X    status byte\nLE_STATUS_BYTE_12   DS X    status byte\nLE_STATUS_BYTE_13   DS X    status byte\nLE_STATUS_BYTE_14   DS X    status byte\nLE_STATUS_BYTE_15   DS X    status byte\nLE_STATUS_BYTE_16   DS X    status byte\nLE_STATUS_BYTE_17   DS X    status byte\nLE_STATUS_BYTE_18   DS X    status byte\nLE_STATUS_BYTE_19   DS X    status byte\nLE_STATUS_BYTE_20   DS X    status byte\nLE_STATUS_BYTE_21   DS X    status byte\nLE_STATUS_BYTE_22   DS X    status byte\nLE_STATUS_BYTE_23   DS X    status byte\nLE_STATUS_BYTE_24   DS X    status byte\nLE_STATUS_BYTE_25   DS X    status byte\nLE_STATUS_BYTE_26   DS X    status byte Cobol for MVS and VM\nLE_STATUS_BYTE_27   DS X    status byte Cobol for MVS and VM\nLE_COBOL_SIGNAT     DS X    cobol signature level\nLE_DATA_STATEMENTS  DS XL4  number of data items\nLE_PROC_LINES       DS XL4  number of proc statements\nLE_YEAR_WINDOW      DS H    YearWindow\nSYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,                      *\n               RECFM=FB,LRECL=121\nINPUT    DCB   DSORG=PS,DDNAME=COBANAL,MACRF=(GM),                     *\n               RECFM=U,BLKSIZE=256\nDIRAREA             DS    XL256 PDS-Directory input area\nPARMLIST            DS XL40\nRECORD              DS CL132\nCOBANAL_WORK_LENGTH EQU *-COBANAL_WORK  Length workarea\n*\n*============================================================*\n* Parameter (JCL)                                            *\n*============================================================*\nCOBANAL_PARM        DSECT\nCOBANAL_PARM_LENGTH DS H\n*\n*\n*============================================================*\n* COBOL/370 DCL\n*============================================================*\nCOBOL_370_DSECT     DSECT\n                    DS CL4  bypass\nCEE_EYECATCHER      DS CL4  excatcher\nCEE_STACK_FRAME     DS F    stack frame size\nCEE_PPA1_OFFSET     DS F    offset to first ppa1\n                    DS CL4  reserved\nCEE_PPA1_START      DS 0C\nCEE_OFFSET          DS X    offset to length of name from ppa1\nCEE_SIGNATURE       DS X    CEL-Signature\nCEE_FLAG1           DS X    CEL-FLAGS Bitmask\nCEE_FLAG2           DS X    Member Flags for Cobol\nCEE_ADDRESS_OF_PPA2 DS F    Address of PPA2\nCEE_OFFSET_DBI      DS F    Offset BDI (None)\nCEE_EP_DESCRIPTOR   DS F    Entry Point Descriptor\nCEE_STACK_OVERFLOW  DS F    Offset for Stack overflow\n                    DS F    available word\n                    DS F    available word\n                    DS F    available word\n                    DS F    available word\nCEE_PRIMARY_EP      DS 0C\nCEE_PRI_EP_ADDRESS  DS A    primary entry-point address\nCEE_PGT_ADDRESS     DS A    PGT-Address\nCEE_TGT_ADDRESS     DS A    PGT-Address\nCEE_EP_NAME         DS A    Offset to entry_point_name\nCEE_CURRENT_EP      DS A    current EP-Address\nCEE_START           DS A    procedure code Address\nCEE_INIT_PROG       DS A    Initialize Routine\nCEE_PARM_LIST       DS A    Address of parm list for CEEINT\n                    DS F    available word\n                    DS H    available half-word\nCEE_LENGTH_NAME     DS XL2  length of program_name\nCEE_NAME_PART       DS 0C\nCEE_PGM_NAME        DS CL8  name of program\nCEE_COMP_YEAR       DS CL4  year of compilation\nCEE_COMP_MONTH      DS CL2  month of compilation\nCEE_COMP_DAY        DS CL2  day of compilation\nCEE_COMP_HOURS      DS CL2  hours of compilation\nCEE_COMP_MIN        DS CL2  minutes of compilation\nCEE_COMP_SEC        DS CL2  seconds of compilation\nCEE_VERS            DS CL2  version\nCEE_REL             DS CL2  release\nCEE_MOD             DS CL2  modification level\n                    DS F    available word\n                    DS H\nCEE_YEAR_WINDOW     DS H    YearWindow\nCEE_STATUS_BYTE_01  DS X    status byte\nCEE_STATUS_BYTE_02  DS X    status byte\nCEE_STATUS_BYTE_03  DS X    status byte\nCEE_STATUS_BYTE_04  DS X    status byte\nCEE_STATUS_BYTE_05  DS X    status byte\nCEE_STATUS_BYTE_06  DS X    status byte\nCEE_STATUS_BYTE_07  DS X    status byte\nCEE_STATUS_BYTE_08  DS X    status byte\nCEE_STATUS_BYTE_09  DS X    status byte\nCEE_STATUS_BYTE_10  DS X    status byte\nCEE_STATUS_BYTE_11  DS X    status byte\nCEE_STATUS_BYTE_12  DS X    status byte\nCEE_STATUS_BYTE_13  DS X    status byte\nCEE_STATUS_BYTE_14  DS X    status byte\nCEE_STATUS_BYTE_15  DS X    status byte\nCEE_STATUS_BYTE_16  DS X    status byte\nCEE_STATUS_BYTE_17  DS X    status byte\nCEE_STATUS_BYTE_18  DS X    status byte\nCEE_STATUS_BYTE_19  DS X    status byte\nCEE_STATUS_BYTE_20  DS X    status byte\nCEE_STATUS_BYTE_21  DS X    status byte\nCEE_STATUS_BYTE_22  DS X    status byte\nCEE_STATUS_BYTE_23  DS X    status byte\nCEE_COBOL_SIGNAT    DS X    cobol signature level\nCEE_DATA_STATEMENTS DS XL4  number of data items\nCEE_PROC_LINES      DS XL4  number of proc statements\nCEE_STATUS_BYTE_24  DS X    status byte\nCEE_STATUS_BYTE_25  DS X    status byte\nCEE_STATUS_BYTE_26  DS X    status byte\nCEE_STATUS_BYTE_27  DS X    status byte\n*============================================================*\n* COBOL2 DCL\n*============================================================*\nCOBOL_2_DSECT      DSECT\n                   DS CL4  bypass\n                   DS X\nC2_PGM_NAME        DS CL8  name of program\nC2_EYECATCHER      DS CL4  eyecatcher\nC2_VERS            DS CL2  version\nC2_REL             DS CL2  release\nC2_MOD             DS CL2  modification level\nC2_COMP_MONTH      DS CL2  month of compilation\n                   DS CL1\nC2_COMP_DAY        DS CL2  day of compilation\n                   DS CL1\nC2_COMP_YEAR       DS CL2  year of compilation\n                   DS CL1\nC2_COMP_HOURS      DS CL2  hours of compilation\n                   DS CL1\nC2_COMP_MIN        DS CL2  minutes of compilation\n                   DS CL1\nC2_COMP_SEC        DS CL2  seconds of compilation\nC2_GET_ENTRY       DS A    Address of address\nC2_STATUS_BYTE_01  DS X    status byte\nC2_STATUS_BYTE_02  DS X    status byte\nC2_STATUS_BYTE_03  DS X    status byte\nC2_STATUS_BYTE_04  DS X    status byte\nC2_STATUS_BYTE_05  DS X    status byte\nC2_STATUS_BYTE_06  DS X    status byte\nC2_STATUS_BYTE_07  DS X    status byte\nC2_STATUS_BYTE_08  DS X    status byte\nC2_STATUS_BYTE_09  DS X    status byte\nC2_STATUS_BYTE_10  DS X    status byte\nC2_STATUS_BYTE_11  DS X    status byte\nC2_STATUS_BYTE_12  DS X    status byte\nC2_STATUS_BYTE_13  DS X    status byte\nC2_STATUS_BYTE_14  DS X    status byte\nC2_STATUS_BYTE_15  DS X    status byte\nC2_STATUS_BYTE_16  DS X    status byte\nC2_STATUS_BYTE_17  DS X    status byte\nC2_STATUS_BYTE_18  DS X    status byte\nC2_STATUS_BYTE_19  DS X    status byte\nC2_STATUS_BYTE_20  DS X    status byte\nC2_STATUS_BYTE_21  DS X    status byte\nC2_STATUS_BYTE_22  DS X    status byte\nC2_STATUS_BYTE_23  DS X    status byte\n                   DS X    cobol signature level\nC2_DATA_STATEMENTS DS XL4  number of data items\nC2_PROC_LINES      DS XL4  number of proc statements\nC2_STATUS_BYTE_24  DS X    status byte\nC2_STATUS_BYTE_25  DS X    status byte\n                   DS XL2  status byte\n                   DS CL4  status byte\nC2_PRI_EP_ADDRESS  DS A    primary entry-point address\n*\n*============================================================*\n* OS/VS COBOL\n*============================================================*\nCOBOL_1_DSECT      DSECT\n                   DS CL12 bypass\nC1_PGM_NAME        DS CL8  name of program\nC1_EYECATCHER      DS CL2  eyecatcher\nC1_REL             DS CL2  release\n                   DS CL36\nC1_TGT_PTR         DS F    pointer to tgt\n                   DS CL8  unknown                               RS0700\nC1_OEM_MOD_AREA    DS CL60 Optimizer Info orgin COBOL low-values RS0700\n                   DS CL4  unknown                               RS0700\nC1_COMP_HOURS      DS CL2  hours of compilation\n                   DS CL1\nC1_COMP_MIN        DS CL2  minutes of compilation\n                   DS CL1\nC1_COMP_SEC        DS CL2  seconds of compilation\nC1_COMP_MONTH      DS CL3  month of compilation\n                   DS CL1\nC1_COMP_DAY        DS CL2  day of compilation\n                   DS CL2\nC1_COMP_YEAR       DS CL4  year of compilation\nCOBOL_1_TGT        DSECT\n                   DS CL72 ?\nC1_STATUS_BYTE_01  DS X    status byte\nC1_STATUS_BYTE_02  DS X    status byte\nC1_STATUS_BYTE_03  DS X    status byte\n                   DS CL369\nC1_CHECK           DS CL8  check TGT for SYSOUT\n*\n         DCBD    DSORG=QS\n         STRING GENERATE\nBIT0     EQU   B'10000000'\nBIT1     EQU   B'01000000'\nBIT2     EQU   B'00100000'\nBIT3     EQU   B'00010000'\nBIT4     EQU   B'00001000'\nBIT5     EQU   B'00000100'\nBIT6     EQU   B'00000010'\nBIT7     EQU   B'00000001'\n*------------------------------------------------------------*\n* Program equates                                            *\n*------------------------------------------------------------*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n./ ADD NAME=COBANL   0100-01345-01345-1143-00259-00259-00000-EX31022\n/*-------- REXX -------------------------------------------*/\n/* Function   : display Cobanl selection menu              */\n/*---------------------------------------------------------*/\n/*\n    trace ?r\n*/\n\n\"ispexec control errors return\"\nparse source xx yy procname rest\nsignal on syntax  name failures\nsignal on failure name failures\n\narg steplib  ,              /* steplib for cobanal pgm       */\n    cobaappl ,              /* applname for coba application */\n    cobahlq  ,              /* hlq for coba datasets         */\n    llqclib  ,              /* llq for exec und clist        */\n    llqmlib  ,              /* llq for mlib                  */\n    llqplib  ,              /* llq for plib                  */\n    llqslib  ,              /* llq for slib                  */\n    llqtlib  ,              /* llq for tlib                  */\n    llqtabl  ,              /* llq tabl                      */\n    account  ,\n    class    ,\n    msgclass ,\n    ispfhlq\n\nuserhlq = userid()\n\n\"ISPEXEC VPUT (STEPLIB COBAAPPL COBAHLQ USERHLQ)\"\n\"ISPEXEC VPUT (LLQCLIB LLQMLIB LLQPLIB LLQSLIB LLQTLIB LLQTABL)\"\n\"ISPEXEC VPUT (ACCOUNT CLASS MSGCLASS ISPFHLQ)\"\n\nSTART:\n\"ISPEXEC DISPLAY PANEL(COBANL)\"\n\nIF RC = 12 | RC = 20\nTHEN do\n  CALL COBA000 cobanl cobanl rc\n  EXIT\nend\n\nIF ZCMD = TRACE\nTHEN DO\n  zcmd = ' '\n  trace ?r\nend\n\nIF RC = 8\nTHEN do\n  \"ISPEXEC TBEND COBANL00\"\n  \"ISPEXEC TBEND COBANL01\"\n  \"ISPEXEC TBEND COBANL02\"\n  \"ISPEXEC TBEND COBANL03\"\n  \"ISPEXEC TBEND COBANL04\"\n  EXIT\nend\n\n\nselect\n  when zcmd = 1\n  then do\n    mess1   = 'Please edit the follwoing JCL to your '\n    mess2   = 'namings and submit the job'\n    mess3   = 'For permant change edit member COBANAL'\n    mess4   = 'in ISPSLIB dataset'\n    \"ISPEXEC ADDPOP ROW(03) COLUMN(10)\"\n    \"ISPEXEC DISPLAY PANEL(COBA000)\"\n    IF ZCMD = TRACE\n    THEN DO\n      zcmd = ' '\n      trace ?r\n    end\n    IF RC = 8\n    THEN do\n      \"ISPEXEC TBEND COBANL00\"\n      \"ISPEXEC TBEND COBANL01\"\n      \"ISPEXEC TBEND COBANL02\"\n      \"ISPEXEC TBEND COBANL03\"\n      \"ISPEXEC TBEND COBANL04\"\n      \"ISPEXEC REMPOP\"\n      signal start\n    end\n    mess    = 'please enter dsn of loadlib to analyse'\n    \"ISPEXEC REMPOP\"\n    \"ISPEXEC ADDPOP ROW(03) COLUMN(10)\"\n    \"ISPEXEC DISPLAY PANEL(COBANLLO)\"\n    IF ZCMD = TRACE\n    THEN DO\n      zcmd = ' '\n      trace ?r\n    end\n    IF RC = 8\n    THEN do\n      \"ISPEXEC TBEND COBANL00\"\n      \"ISPEXEC TBEND COBANL01\"\n      \"ISPEXEC TBEND COBANL02\"\n      \"ISPEXEC TBEND COBANL03\"\n      \"ISPEXEC TBEND COBANL04\"\n      \"ISPEXEC REMPOP\"\n      signal start\n    end\n    \"ISPEXEC REMPOP\"\n    \"ISPEXEC ADDPOP ROW(03) COLUMN(10)\"\n    \"ISPEXEC DISPLAY PANEL(COBANL04)\"\n    IF ZCMD = TRACE\n    THEN DO\n      zcmd = ' '\n      trace ?r\n    end\n    IF RC = 8\n    THEN do\n      \"ISPEXEC TBEND COBANL00\"\n      \"ISPEXEC TBEND COBANL01\"\n      \"ISPEXEC TBEND COBANL02\"\n      \"ISPEXEC TBEND COBANL03\"\n      \"ISPEXEC TBEND COBANL04\"\n      \"ISPEXEC REMPOP\"\n      signal start\n    end\n    \"ISPEXEC REMPOP\"\n    call cobasubp dsn t\n  end\n  when zcmd = 2 THEN CALL COBANLDS\n  when zcmd = 3\n  then do\n    call open_tables\n    sel = 'all cobol programs '\n    tkey1   = 'PGMKEY'\n    \"ispexec vput tkey1\"\n    call cobanldt ALL ,\n                  COBANL00 ,\n                  COBANL01 ,\n                  COBANL02 ,\n                  COBANL00 ,\n                  COBANLF0 ,\n                  COBANLL0 ,\n                  COBANLS0 ,\n                  COBANL  ,\n                  sel\n  end\n  when zcmd = 4\n  then do\n    call open_tables\n    sel = 'all cobol compile options'\n    tkey1   = 'OPTION'\n    \"ispexec vput tkey1\"\n    call cobanldt ALL ,\n                  COBANL01 ,\n                  COBANL00 ,\n                  COBANL02 ,\n                  COBANL01 ,\n                  COBANLF1 ,\n                  COBANLLI ,\n                  COBANLS1 ,\n                  COBANL  ,\n                  sel\n  end\n  when zcmd = 5\n  then do\n    call open_tables\n    sel = 'all cobol compiler versions'\n    tkey1   = 'COBVERS'\n    \"ispexec vput tkey1\"\n    call cobanldt ALL ,\n                  COBANL02 ,\n                  COBANL00 ,\n                  COBANL01 ,\n                  COBANL02 ,\n                  COBANLF2 ,\n                  COBANLLI ,\n                  COBANLS2 ,\n                  COBANL  ,\n                  sel\n  end\n  when zcmd = 6\n  then do\n    call open_tables\n    sel = 'all procedure division statements'\n    tkey1   = 'STMT'\n    \"ispexec vput tkey1\"\n    call cobanldt ALL ,\n                  COBANL03 ,\n                  COBANL00 ,\n                  COBANL01 ,\n                  COBANL07 ,\n                  COBANLF3 ,\n                  COBANLLI ,\n                  COBANLS3 ,\n                  COBANL  ,\n                  sel\n  end\n  when zcmd = 7\n  then do\n    call open_tables\n    sel = 'all analyzed loadlibs'\n    tkey1   = 'LOADLIB'\n    \"ispexec vput tkey1\"\n    call cobanldt ALL ,\n                  COBANL04 ,\n                  COBANL00 ,\n                  COBANL01 ,\n                  COBANL09 ,\n                  COBANLF2 ,\n                  COBANLL9 ,\n                  COBANLS2 ,\n                  COBANL  ,\n                  sel\n  end\n  when zcmd = 8\n  then do\n    call cobanlpg\n  end\n  when zcmd = 9\n  then do\n    call open_tables\n    tkey1   = 'OPTION'\n    \"ispexec vput tkey1\"\n    call cobanl03\n  end\n  when zcmd = 10\n  then do\n    zcmd = isplibd\n    \"ispexec display panel(ispllsa) command(zcmd)\"\n  end\n  when zcmd = 11\n  then do\n    call isrddn\n  end\n  when zcmd = 12\n  then do\n    zcmd = sarea\n    \"ispexec display panel(ispsammn) command(zcmd)\"\n  end\n  when zcmd = 13\n  then do\n    call cobasysi\n  end\n  otherwise  signal start\nend\n\nSIGNAL START\n\nEXIT\n\nopen_tables:\n\n\"ISPEXEC TBOPEN COBANL00 NOWRITE\"\n\"ISPEXEC TBOPEN COBANL01 NOWRITE\"\n\"ISPEXEC TBOPEN COBANL02 NOWRITE\"\n\"ISPEXEC TBOPEN COBANL03 NOWRITE\"\n\"ISPEXEC TBOPEN COBANL04 NOWRITE\"\n\nreturn\n\nfailures:\nsay  \"line = \" strip(sourceline(sigl))\nsay  \"Cond = \" condition('C') condition('D')\nsay  \"Error= \" errortext(rc)\nexit\n./ ADD NAME=COBANLBL 0127-99348-02330-1150-00670-00577-00000-EX31022\n/*-------- REXX -------------------------------------------*/\n/* Function   : build cobanal tables                       */\n/*---------------------------------------------------------*/\n/*\n    trace ?r\n*/\n\narg ptyp loadlib\n\nsay 'create analyse report started'\nsay 'parameter ptyp    = ' ptyp\nsay 'parameter loadlib = ' loadlib\n\n\"ispexec control errors return\"\nparse source xx yy procname rest\nsignal on syntax  name failures\nsignal on failure name failures\n\nDSNAME   = LISTDSI(COBANAL FILE)\ndsname   = sysdsname\n\nif SYSDSN(\"'\"DSNAME\"'\") \u00ac= 'OK'\nthen do\n  say \"DSN = \" dsname \" notfound\"\n  exit\nend\n\n\"ISPEXEC EDIT DATASET('\"dsname\"') MACRO(COBA#MAC)\"\n\nif rc > 4\nthen do\n  say  \"/*----------------------------------------------------------*/\"\n  say  \"Error during editing listing dataset \"\n  say  \"Dataset = \" dsname\n  say  \"Returncode = \" rc\n  say  \"Possible reasons\"\n  say  \"1. Regionsize to low  ---> increase region size\"\n  say  \"2. Edit region size limited by installation modification\"\n  say  \"   via ISRCONFG parameter EDITSTOR\"\n  say  \"   ---> set parameter EDITSTOR to zero, increase region size\"\n  say  \"            if not possible, pray and asked your  \"\n  say  \"            systemprogrammer\"\n  say  \"3. Wrong input dataset\"\n  say  \"/*----------------------------------------------------------*/\"\n  zispfrc = 17\n  \"ispexec vput zispfrc shared\"\n  exit zispfrc\nend\n\n/*----- Cobal tables -----------------------------*/\n/*                                                */\n/*    COBANL00 Table Programm information         */\n/*    COBANL01 Table Option   information         */\n/*    COBANL02 Table Compiler information         */\n/*    COBANL03 Table procedur information         */\n/*    COBANL04 Table loadlib  information         */\n/*                                                */\n/*------------------------------------------------*/\n\n\"ISPEXEC TBEND    COBANL00\"\n\"ISPEXEC TBEND    COBANL01\"\n\"ISPEXEC TBEND    COBANL02\"\n\"ISPEXEC TBEND    COBANL03\"\n\"ISPEXEC TBEND    COBANL04\"\n\nloadlib  = strip(loadlib,L,' ')\n\nif ptyp  \u00ac= 'E'\nthen do\n  \"ISPEXEC TBERASE  COBANL00\"\n  names = \"COBREL COBVERS COMPREL COMPNAME COMPDATE COMPTIME ANZITEM ANZINSTR \"\n  names = names || \"O1 O2 O3 O4 O5 O6 O7 O8 O9 O10 O11 O12 O13 O14 O15 O16 O17 \"\n  names = names || \"O18 O19 O20 O21 O22 O23 O24 O25 O26 O27 O28 O29 O30 O31 \"\n  names = names || \"O32 O33 O34 O35 O36 O37 O38 O39 O40 O41 O42 O43 O44 O45 \"\n  names = names || \"P1 P2 P3 P4 P5 P6 P7 P8 P9 \"\n  names = names || \"P10 P11 P12 P13 P14 P15 P16 P17 P18 P19 \"\n  names = names || \"P20 P21 P22 P23 P24 P25 P26 P27 P28 P29 \"\n  names = names || \"P30 P31 P32 P33 P34 P35 P36 P37 P38 P39 \"\n  names = names || \"P40 P41 P42 P43 P44 P45 P46 P47 P48 P49 \"\n  names = names || \"P50 P51 P52 P53 P54 P55 P56 P57 P58 P59 \"\n  names = names || \"P60 P61 P62 P63 P64 P65 P66 P67 P68 P69 \"\n  names = names || \"PGMNAME LOADLIB\"\n  \"ISPEXEC TBCREATE COBANL00 KEYS(PGMKEY) NAMES(\"names\")\"\n\n \"ISPEXEC TBERASE  COBANL01\"\n \"ISPEXEC TBCREATE COBANL01 KEYS(OPTION) NAMES(FN ANZPGM)\"\n\n \"ISPEXEC TBERASE  COBANL02\"\n \"ISPEXEC TBCREATE COBANL02 KEYS(COBVERS) NAMES(COBREL ANZPGM)\"\n\n \"ISPEXEC TBERASE  COBANL03\"\n \"ISPEXEC TBCREATE COBANL03 KEYS(STMT) NAMES(FN ANZPGM)\"\n\n \"ISPEXEC TBERASE  COBANL04\"\n \"ISPEXEC TBCREATE COBANL04 KEYS(LOADLIB)\n          NAMES (ANZPGMCO ANZCOBVS ANZCOBII ANZCOB37 REPDAY REPDATE)\"\nend\nelse do\n  \"ISPEXEC TBOPEN   COBANL04\"\n  \"ispexec tbget cobanl04\"\n  if rc = 0\n  then do\n    say  \"loadlib = \" loadlib \" already analyzed\"\n    \"ISPEXEC TBCLOSE  COBANL04\"\n    exit\n  end\n  \"ISPEXEC TBOPEN   COBANL00\"\n  \"ISPEXEC TBOPEN   COBANL01\"\n  \"ISPEXEC TBOPEN   COBANL02\"\n  \"ISPEXEC TBOPEN   COBANL03\"\nend\n\nrepday   = '---n/a---'\nanzpgmco = 0\nanzcobvs = 0\nanzcobii = 0\nanzcob37 = 0\n\nrepdate  = date('E')\n\nif sysvar(systsoe) >= 2060 then repday = date('W',repdate,'E')\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\n\"EXECIO 1 DISKR COBANAL\"\n\nIF RC = 2\nTHEN\n  EOF = J\nELSE\n  EOF = N\n\nDO WHILE EOF = N\n  parse PULL RECORD\n  select\n    when pos('was loaded',record) > 0\n    then do\n      do i     = 1 to 70\n        fn1    = 'o'||i\n        ini    = ' '\n        call     value fn1,ini\n        fn1    = 'p'||i\n        call     value fn1,ini\n      end\n      cobrel   = 'NO Cobol'\n      cobvers  = 'n/a'\n      comprel  = 'n/a'\n      compname = 'n/a'\n      compdate = 'n/a'\n      comptime = 'n/a'\n      anzitem  = 'n/a'\n      anzinstr = 'n/a'\n      pgmname  = word(record,3)\n      pgmkey   = pgmname||loadlib\n      \"ispexec tbadd cobanl00\"\n    end\n    when pos('= Info =',record) > 0\n    then do\n      \"EXECIO 1 DISKR COBANAL\"\n      parse PULL RECORD\n      call pgm_record\n    end\n    when pos('= Timestamps =',record) > 0\n    then do\n      \"EXECIO 1 DISKR COBANAL\"\n      parse PULL RECORD\n      call timestamp_record\n    end\n    when pos('= Statistics =',record) > 0\n    then do\n      \"EXECIO 1 DISKR COBANAL\"\n      parse PULL RECORD\n      call statistic_record\n    end\n    when pos('= Options in effect =',record) > 0\n    then do\n      \"EXECIO 1 DISKR COBANAL\"\n      parse PULL RECORD\n      call option_record\n      if cobrel     = 'OS/VS'\n      then\n        \"ispexec tbmod cobanl00\"\n    end\n    when pos('PROCEDURE DIVISION',record) > 0\n    then do\n      \"EXECIO 1 DISKR COBANAL\"\n      parse PULL RECORD\n      call procedure_record\n      \"ispexec tbmod cobanl00\"\n    end\n    otherwise\n  end\n  \"EXECIO 1 DISKR COBANAL\"\n  IF RC = 2\n  THEN DO\n    EOF = J\n  END\nEND\n\n\"EXECIO 0 DISKR COBANAL (FINIS\"\n\"FREE F(COBANAL)\"\n\n\"ISPEXEC TBMOD   COBANL04\"\n\n\"ISPEXEC TBSORT  COBANL00 FIELDS(PGMNAME)\"\n\"ISPEXEC TBSORT  COBANL01 FIELDS(OPTION)\"\n\"ISPEXEC TBSORT  COBANL02 FIELDS(COBREL,C,A,COBVERS,C,A)\"\n\"ISPEXEC TBSORT  COBANL03 FIELDS(STMT)\"\n\"ISPEXEC TBSORT  COBANL04 FIELDS(LOADLIB)\"\n\n\"ISPEXEC TBCLOSE COBANL00\"\n\"ISPEXEC TBCLOSE COBANL01\"\n\"ISPEXEC TBCLOSE COBANL02\"\n\"ISPEXEC TBCLOSE COBANL03\"\n\"ISPEXEC TBCLOSE COBANL04\"\n\nsay 'create analyse report ended'\n\nexit\n\npgm_record:\n\npgmname       = word(record,2)\npgmkey        = pgmname||loadlib\ncobrel        = word(record,4)\ncobvers       = word(record,6)\n\nif cobrel     = \"COBOL\"\nthen do\n  cobvers     = word(record,5)\nend\n\nif cobrel     = \"OS/VS\"\nthen do\n  cobvers     = word(record,7)\nend\n\nselect\n  when cobvers  = \"Enterprise\"\n  then do\n    cobrel      = cobrel || '/' || cobvers\n    cobvers     = 'V' || word(record,7)\n    cobvers     = strip(cobvers,T,'.')\n    cobvers     = cobvers || 'R' || word(record,9)\n    cobvers     = strip(cobvers,T,'.')\n    cobvers     = cobvers || 'M' || word(record,11)\n    cobvers     = strip(cobvers,T,'.')\n  end\n  when cobvers   \u00ac= \"R1\"\n  then do\n    cobvers     = 'V' || word(record,6)\n    cobvers     = strip(cobvers,T,'.')\n    cobvers     = cobvers || 'R' || word(record,8)\n    cobvers     = strip(cobvers,T,'.')\n    cobvers     = cobvers || 'M' || word(record,10)\n    cobvers     = strip(cobvers,T,'.')\n  end\n  otherwise\nend\n\n\"ispexec        tbget cobanl02\"\nif rc         > 0\nthen do\n  anzpgm      = 1\n  \"ispexec      tbadd cobanl02\"\nend\nelse do\n  anzpgm      = anzpgm + 1\n  \"ispexec      tbmod cobanl02\"\nend\n\npcomprel      = pos('Version',record)\nif pcomprel   = 0\nthen do\n  pcomprel    = pos('Release',record)\nend\ncomprel       = substr(record,pcomprel)\n\nreturn\n\ntimestamp_record:\n\ncompname      = word(record,4)\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\n\ncompdate      = word(record,2)\n\nif cobrel     = 'OS/VS'\nthen do\n  comptime    = word(record,4)\n  anzcobvs    = anzcobvs + 1\nend\nelse do\n  if cobrel     = 'COBOL/2'\n  then do\n    if cobvers  = 'V1R1M0' | cobvers = 'V1R2M0'\n    then do\n      comptime  = word(record,7)\n      compdate  = word(record,4)\n    end\n    else do\n      wordindd  = wordpos(\"(european)\",record)\n      compdate  = word(record,wordindd+1)\n      wordindt  = wordpos('Time:',record)\n      comptime  = word(record,wordindt+1)\n    end\n    if pos('??',compdate) > 0\n    then do\n      p1        = pos('??',compdate)\n      if substr(compdate,p1+2,2)  > 70 then oj = 19\n                                       else oj = 20\n      compdate  = overlay(oj,compdate,p1)\n    end\n    anzcobii    = anzcobii + 1\n  end\n  else do\n    comptime    = word(record,7)\n    compdate    = word(record,4)\n    anzcob37    = anzcob37 + 1\n  end\nend\n\nif pos('??',compdate) > 0\nthen do\n  jp   = pos('??',compdate)\n  compyear  = substr(compdate,jp+2,2)\n  if compyear > '70'\n  then compdate = overlay('19',compdate,jp)\n  else compdate = overlay('20',compdate,jp)\nend\n\nanzpgmco      = anzpgmco + 1\n\nanzitem       = 'n/a'\nanzinstr      = 'n/a'\n\nreturn\n\nstatistic_record:\n\nanzitem       = word(record,6)\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\nanzinstr      = word(record,4)\n\nreturn\n\noption_record:\n\ndo i   = 1 to 70\n  fn1  = 'o'||i\n  ini  = ' '\n  call   value fn1,ini\n  fn1  = 'p'||i\n  call   value fn1,ini\nend\n\ni      = 0\n\nnword  = words(record)\n\ndo j   = 1 to nword\n  i    = i + 1\n  fn   = 'o'||i\n  call   value fn,word(record,j)\n  option='OPTION'\n  call   value option,word(record,j)\n  call   update_options\nend\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\n\nnword  = words(record)\n\ndo j   = 1 to nword\n  i    = i + 1\n  fn   = 'o'||i\n  call   value fn,word(record,j)\n  option='OPTION'\n  call   value option,word(record,j)\n  call   update_options\nend\n\nif cobrel     = 'OS/VS' then return\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\n\nnword  = words(record)\n\ndo j   = 1 to nword\n  i    = i + 1\n  fn   = 'o'||i\n  call   value fn,word(record,j)\n  option='OPTION'\n  call   value option,word(record,j)\n  call   update_options\nend\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\n\nnword  = words(record)\n\ndo j   = 1 to nword\n  i    = i + 1\n  fn   = 'o'||i\n  call   value fn,word(record,j)\n  option='OPTION'\n  call   value option,word(record,j)\n  call   update_options\nend\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\n\nnword  = words(record)\n\ndo j   = 1 to nword\n  i    = i + 1\n  fn   = 'o'||i\n  call   value fn,word(record,j)\n  option='OPTION'\n  call   value option,word(record,j)\n  call   update_options\nend\n\nreturn\n\nupdate_options:\n\n\"ispexec        tbget cobanl01\"\nif rc         > 0\nthen do\n  anzpgm      = 1\n  \"ispexec      tbadd cobanl01\"\nend\nelse do\n  anzpgm      = anzpgm + 1\n  \"ispexec      tbmod cobanl01\"\nend\n\nreturn\n\nprocedure_record:\n\ni      = 0\n\nnword  = words(record)\n\ndo j   = 1 to nword\n  i    = i + 1\n  fn   = 'p'||i\n  if word(record,j+1) = 'Y'\n  then do\n    call   value fn,word(record,j)\n    option='STMT'\n    call   value option,word(record,j)\n    call   update_stmt\n  end\n  j = j + 1\nend\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\n\nnword  = words(record)\n\ndo j   = 1 to nword\n  i    = i + 1\n  fn   = 'p'||i\n  if word(record,j+1) = 'Y'\n  then do\n    call   value fn,word(record,j)\n    option='STMT'\n    call   value option,word(record,j)\n    call   update_stmt\n  end\n  j = j + 1\nend\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\n\nnword  = words(record)\n\ndo j   = 1 to nword\n  i    = i + 1\n  fn   = 'p'||i\n  if word(record,j+1) = 'Y'\n  then do\n    call   value fn,word(record,j)\n    option='STMT'\n    call   value option,word(record,j)\n    call   update_stmt\n  end\n  j = j + 1\nend\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\n\nnword  = words(record)\n\ndo j   = 1 to nword\n  i    = i + 1\n  fn   = 'p'||i\n  if word(record,j+1) = 'Y'\n  then do\n    call   value fn,word(record,j)\n    option='STMT'\n    call   value option,word(record,j)\n    call   update_stmt\n  end\n  j = j + 1\nend\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\n\nnword  = words(record)\n\ndo j   = 1 to nword\n  i    = i + 1\n  fn   = 'p'||i\n  if word(record,j+1) = 'Y'\n  then do\n    call   value fn,word(record,j)\n    option='STMT'\n    call   value option,word(record,j)\n    call   update_stmt\n  end\n  j = j + 1\nend\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\n\nnword  = words(record)\n\ndo j   = 1 to nword\n  i    = i + 1\n  fn   = 'p'||i\n  if word(record,j+1) = 'Y'\n  then do\n    call   value fn,word(record,j)\n    option='STMT'\n    call   value option,word(record,j)\n    call   update_stmt\n  end\n  j = j + 1\nend\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\n\nnword  = words(record)\n\ndo j   = 1 to nword\n  i    = i + 1\n  fn   = 'p'||i\n  if word(record,j+1) = 'Y'\n  then do\n    call   value fn,word(record,j)\n    option='STMT'\n    call   value option,word(record,j)\n    call   update_stmt\n  end\n  j = j + 1\nend\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\n\nnword  = words(record)\n\ndo j   = 1 to nword\n  i    = i + 1\n  fn   = 'p'||i\n  if word(record,j+1) = 'Y'\n  then do\n    call   value fn,word(record,j)\n    option='STMT'\n    call   value option,word(record,j)\n    call   update_stmt\n  end\n  j = j + 1\nend\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\n\nnword  = words(record)\n\ndo j   = 1 to nword\n  i    = i + 1\n  fn   = 'p'||i\n  if word(record,j+1) = 'Y'\n  then do\n    call   value fn,word(record,j)\n    option='STMT'\n    call   value option,word(record,j)\n    call   update_stmt\n  end\n  j = j + 1\nend\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\n\nnword  = words(record)\n\ndo j   = 1 to nword\n  i    = i + 1\n  fn   = 'p'||i\n  if word(record,j+1) = 'Y'\n  then do\n    call   value fn,word(record,j)\n    option='STMT'\n    call   value option,word(record,j)\n    call   update_stmt\n  end\n  j = j + 1\nend\n\nif cobrel    \u00ac= 'COBOL/Enterprise' then return\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\n\ndo j   = 1 to nword\n  i    = i + 1\n  fn   = 'p'||i\n  if word(record,j+1) = 'Y'\n  then do\n    call   value fn,word(record,j)\n    option='STMT'\n    call   value option,word(record,j)\n    call   update_stmt\n  end\n  j = j + 1\nend\n\nreturn\n\nupdate_stmt:\n\n\"ispexec        tbget cobanl03\"\nif rc         > 0\nthen do\n  anzpgm      = 1\n  \"ispexec      tbadd cobanl03\"\nend\nelse do\n  anzpgm      = anzpgm + 1\n  \"ispexec      tbmod cobanl03\"\nend\n\nreturn\n\nfailures:\nsay  record\nsay  \"line = \" strip(sourceline(sigl))\nsay  \"Cond = \" condition('C') condition('D')\nsay  \"Error= \" errortext(rc)\nexit\n./ ADD NAME=COBANLDS\n/*-------- REXX -------------------------------------------*/\n/* Function   : display cobanal output                     */\n/*---------------------------------------------------------*/\n/*\n    trace ?r\n*/\n\ndsnlist = userid()||\".COBANAL.LISTING\"\ndsnedit = userid()||\".COBANAL.LISTEDIT\"\n\n\"ispexec control errors return\"\nparse source xx yy procname rest\nsignal on syntax  name failures\nsignal on failure name failures\n\nstart:\n\"ISPEXEC ADDPOP ROW(03) COLUMN(10)\"\n\"ISPEXEC DISPLAY PANEL(COBANLDS)\"\n\nIF RC = 12 | RC = 20\nTHEN do\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\nIF ZCMD = TRACE\nTHEN DO\n  zcmd = ' '\n  trace ?r\nend\n\nIF RC = 8\nTHEN do\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\n\"ISPEXEC REMPOP\"\n\nif zcmd  = 1 then dsn = dsnlist\n             else dsn = dsnedit\n\nif SYSDSN(\"'\"DSN\"'\") \u00ac= 'OK'\nthen do\n  mess = 'dataset ' dsn sysdsn(\"'\"dsn\"'\")\n  signal start\nend\n\n\"ISPEXEC VIEW DATASET('\"dsn\"')\"\n\nsignal start\n\nfailures:\nsay  \"line = \" strip(sourceline(sigl))\nsay  \"Cond = \" condition('C') condition('D')\nsay  \"Error= \" errortext(rc)\nexit\n./ ADD NAME=COBANLDT 0101-01254-01254-1012-00174-00175-00000-EX31022\n/*-------- REXX -------------------------------------------*/\n/* Function   : display information from table             */\n/* callers    : cob application                            */\n/* parameter  : kz        selection type                   */\n/*            : table     table to display                 */\n/*            : table2    table to process                 */\n/*            : table3    table to process                 */\n/*            : panel     panel to display                 */\n/*            : filtproc  name of filter procedure         */\n/*            : lineproc  name of line selection procedure */\n/*            : sortproc  name of sort selection procedure */\n/*            : fromproc  name of calling procedure        */\n/*            : sel       selection comment                */\n/*---------------------------------------------------------*/\n/*\n   trace ?r\n*/\n\n\"ispexec   control errors return\"\nparse      source xx yy procname rest\nsignal     on syntax  name failures\nsignal     on failure name failures\n\n\"ispexec   vget (tkey1 debug)\"\n\narg        kz  ,                   /*    reference /mark       */\n           table    ,              /*    tablename             */\n           table2   ,              /*    tablename             */\n           table3   ,              /*    tablename             */\n           panel    ,              /*    panel to display      */\n           filtproc ,              /*    procedure for filter  */\n           lineproc ,              /*    procedure line select */\n           fromproc ,              /*    calling procname      */\n           sel\n\ncursor   = 'zcmd'\nzcmd     = ' '\nanzscan  = 0\n\nif kz    = 'ALL' then rowsv = kz\nelse do\n  rowsv  = SCAN\n  signal display\n  rc     = 0\n  do while rc = 0\n    \"ISPEXEC TBSCAN \" table\n    if rc     > 0 then leave\n    anzscan   = anzscan + 1\n  end\nend\n\n/*------------------------------------------------------------*/\n/*   Display table information                                */\n/*------------------------------------------------------------*/\n\ndisplay:\na        = \"\"\n\"ispexec   tbdispl \" table \" panel(\"panel\") cursor(\"cursor\")\"\n\nif rc    = 12 | rc = 20\nthen do\n  call     coba000 procname panel rc\n  exit\nend\n\nif substr(zcmd,1,6) = filter\nthen do\n  if sel = 'FILTERLINE'\n  then do\n    fi   = length(zcmd)\n    if fi > 6\n    then do\n      zparm    =  substr(zcmd,8,fi-6)\n      if zparm = 'CLEAR'\n      then do\n        \"ispexec setmsg msg(coba006) msgloc(zcmd)\"\n        \"ispexec vput zparm\"\n      end\n    end\n    zcmd     =  substr(zcmd,1,6)\n    \"ispexec vput zcmd\"\n    exit\n  end\n  fi     = length(zcmd)\n  if fi  > 6\n  then do\n    zparm    =  substr(zcmd,8,fi-6)\n    if zparm = 'CLEAR'\n    then do\n      \"ispexec setmsg msg(coba006) msgloc(zcmd)\"\n      signal display\n    end\n  end\n  zcmd   = \" \"                /*  zcmd clear wegen Abfrage in   */\n  \"ispexec vput zcmd\"         /*  in Filtproc                   */\n  filtproc 'FI'     ,\n           table    ,\n           table2   ,\n           table3   ,\n           panel    ,\n           filtproc ,\n           lineproc ,\n           fromproc ,\n           'filterline'\n  zcmd   = ' '\n  csel   = ' '\n  f1     = \"\"\n  f2     = \"\"\n  f3     = \"\"\n  f4     = \"\"\n  f5     = \"\"\n  f6     = \"\"\n  f7     = \"\"\n  f8     = \"\"\n  f9     = \"\"\n  signal     display\nend\n\nif zcmd = 'TRACE' | csel = 'TR'\nthen do\n  zcmd  = ' '\n  csel  = ' '\n  trace ?r\nend\n\nif rc = 8\nthen do\n  zcmd   = \" \"                /*  zcmd clear wegen Abfrage in   */\n  \"ispexec vput zcmd\"         /*  in Filtproc                   */\n  exit\nend\n\nif rc = 0\nthen do\n  if substr(zcmd,1,1) = 'F' | substr(zcmd,1,1) = 'L'\n  then do\n    fi = length(zcmd)\n    if fi < 3\n    then do\n      \"ispexec setmsg msg(coba001)\"\n      signal display\n    end\n    else do\n      call value tkey1,substr(zcmd,3,fi-2)\n      \"ispexec tbtop \" table\n      \"ispexec tbscan \" table \" arglist(\"tkey1\") condlist(ge)\"\n      signal display\n    end\n  end\nend\n\ndo while ztdsels > 0\n  if a = 'S' | a = '/'\n  then do\n    lineproc value(tkey1) table table2 fromproc a\n  end\n  if a = 'X'\n  then do\n    cobanllx value(tkey1) table table2 fromproc a\n  end\n  if ztdsels = 1 then signal display\n  \"ispexec tbdispl \" table\nend\n\nsignal display\n\nexit\n\nfailures:\nline = strip(sourceline(sigl))\ncond = condition('c') condition('d')\n\"ispexec vput (cond line)\"\ncall cobasynt procname sigl errortext(rc) /* show what went wrong */\nexit\n./ ADD NAME=COBANLF0\n/*-------- REXX -------------------------------------------*/\n/* Function   : cobol information select program info      */\n/*---------------------------------------------------------*/\n/*\n   TRACE ?R\n*/\n\n\"ispexec control errors return\"\nparse source xx yy procname rest\nsignal on syntax  name failures\nsignal on failure name failures\n\narg           kz       ,\n              table    ,\n              table2   ,\n              table3   ,\n              panel    ,\n              filtproc ,\n              lineproc ,\n              fromproc ,\n              sel\n\n\"ispexec vget (csel f1 f2 f3)\"\n\nIF f1 = \"\" & f2 = \"\" & f3 = \"\"\nthen nop\nelse do\n  v1   = EQ\n  v2   = EQ\n  v3   = EQ\n  kz   = FS\n  signal filter_done\nend\n\nSTART:\ncall fill_names\n\"ISPEXEC ADDPOP ROW(03) COLUMN(10)\"\n\"ISPEXEC DISPLAY PANEL(COBAFI10)\"\n\nIF RC = 12 | RC = 20\nTHEN do\n  CALL coba000 procname cobafi10 RC\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\nIF ZCMD = TRACE\nTHEN DO\n  zcmd = ' '\n  trace ?r\nend\n\nIF RC = 8\nTHEN do\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\n\"ISPEXEC REMPOP\"\n\nif substr(zcmd,1,6) = filter\nthen do\n  fi = length(zcmd)\n  if fi > 6\n  then do\n    zparm =  substr(zcmd,8,fi-6)\n    if zparm = 'CLEAR'\n    then do\n      \"ispexec setmsg msg(coba006) msgloc(zcmd)\"\n      f1 = \"\"\n      f2 = \"\"\n      f3 = \"\"\n      zparm  = \"\"\n      \"ispexec vput zparm\"\n      signal start\n    end\n  end\n  signal start\nend\n\nIF f1 = \"\" & f2 = \"\" & f3 = \"\"\nTHEN do\n  MESS1 = \"no filter criteria specified\"\n  \"ISPEXEC ADDPOP\"\n  \"ISPEXEC DISPLAY PANEL(coba000)\"\n  \"ISPEXEC REMPOP\"\n  signal start\nend\n\n\"ispexec vput (f1 f2 f3)\"\n\nfilter_done:\n\n\"ISPEXEC TBVCLEAR \" table\n\nfieldn = \"\"\n\nif f1 > \"\"\nthen do\n  field  = 'PGMNAME,'\n  field  = field||v1\n  fieldn = field\n  pkomma = pos(',',field)\n  name   = substr(field,1,pkomma-1)\n  f1n    = name\n  if pos('*',f1) = 0 then f1 = f1||'*'\n  fieldv = f1\n  call value name,fieldv\nend\n\nif f2 > \"\"\nthen do\n  field  = 'COBREL,'\n  field  = field||v2\n  if fieldn \u00ac= \"\" then fieldn = fieldn||','\n  fieldn = fieldn || field\n  pkomma = pos(',',field)\n  name   = substr(field,1,pkomma-1)\n  f2n    = name\n  if pos('*',f2) = 0 then f2 = f2||'*'\n  fieldv = f2\n  call value name,fieldv\nend\n\nif f3 > \"\"\nthen do\n  field  = 'COBVERS,'\n  field  = field||v3\n  if fieldn \u00ac= \"\" then fieldn = fieldn||','\n  fieldn = fieldn || field\n  pkomma = pos(',',field)\n  name   = substr(field,1,pkomma-1)\n  f3n    = name\n  if pos('*',f3) = 0 then f3 = f3||'*'\n  fieldv = f3\n  call value name,fieldv\nend\n\ntabname = 'R'||time('S')\n\n\"ISPEXEC TBQUERY\" table \" KEYS(TKEYS) KEYNUM(TKEYNUM) NAMES(TNAMES)\"\n\"ISPEXEC TBSARG \" table \" NEXT NAMECOND(\"fieldn\")\"\n\n\"ISPEXEC TBERASE  \" tabname\n\"ISPEXEC TBCREATE \" TABNAME \" KEYS\"TKEYS \"NOWRITE NAMES\"TNAMES\n\nrc = 0\nrecfound = n\n\ndo while rc = 0\n  \"ISPEXEC TBSCAN \" table\n  if rc > 0 then leave\n  \"ISPEXEC TBADD \" tabname \" MULT(1000)\"\n  recfound = y\nend\n\nIF recfound = n\nTHEN do\n  MESS1 = \"no rows with searchargument found\"\n  MESS2 = \"searchargument \"\n  MESS3 = f1n \" = \" f1\n  MESS4 = f2n \" = \" f2\n  MESS5 = f3n \" = \" f3\n  \"ISPEXEC ADDPOP\"\n  \"ISPEXEC DISPLAY PANEL(coba000)\"\n  \"ISPEXEC REMPOP\"\n  \"ISPEXEC TBEND\" tabname\n  signal start\nend\n\n\"ISPEXEC TBTOP \" tabname\n\ncall cobanldt ALL      ,\n              tabname  ,\n              table2   ,\n              table3   ,\n              panel    ,\n              filtproc ,\n              lineproc ,\n              COBANLF0 ,\n              sel\n\n\"ISPEXEC TBEND \" tabname\n\n\"ispexec vget (zparm zcmd)\"\n\nif zcmd     = FILTER\nthen do\n  if zparm  = 'CLEAR'\n  then do\n    f1      = \"\"\n    f2      = \"\"\n    f3      = \"\"\n    zparm   = \"\"\n    \"ispexec  vput zparm\"\n  end\n  signal      start\nend\n\nif kz       = FI then signal start\n\nf1          = \"\"\nf2          = \"\"\nf3          = \"\"\n\n\"ispexec      vput (f1 f2 f3)\"\n\nexit\n\nfill_names:\n\nf1n    = 'Program'\nf1K    = 'Name of program(s) to select'\nf2n    = 'Cobol'\nf2K    = 'Cobol version (COBOL/VS,COBOL/2)'\nf3n    = 'Compiler'\nf3K    = 'Compiler Version'\n\nreturn\n\nfailures:\nline = strip(sourceline(sigl))\nCond = condition('C') condition('D')\n\"ispexec vput (cond line)\"\ncall cobasynt procname sigl errortext(rc) /* show what went wrong */\nexit\n./ ADD NAME=COBANLF1\n/*-------- REXX -------------------------------------------*/\n/* Function   : cobol information select program info      */\n/*---------------------------------------------------------*/\n/*\n   TRACE ?R\n*/\n\n\"ispexec control errors return\"\nparse source xx yy procname rest\nsignal on syntax  name failures\nsignal on failure name failures\n\narg           kz       ,\n              table    ,\n              table2   ,\n              table3   ,\n              panel    ,\n              filtproc ,\n              lineproc ,\n              fromproc ,\n              sel\n\n\"ispexec vget (csel f1)\"\n\nIF f1 = \"\"\nthen nop\nelse do\n  v1    = EQ\n  v2    = EQ\n  v3    = EQ\n  kz    = FS\n  signal filter_done\nend\n\nSTART:\ncall fill_names\n\"ISPEXEC ADDPOP ROW(03) COLUMN(10)\"\n\"ISPEXEC DISPLAY PANEL(COBAFI10)\"\n\nIF RC = 12 | RC = 20\nTHEN do\n  CALL coba000 procname cobafi10 RC\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\nIF ZCMD = TRACE\nTHEN DO\n  zcmd = ' '\n  trace ?r\nend\n\nIF RC = 8\nTHEN do\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\n\"ISPEXEC REMPOP\"\n\nif substr(zcmd,1,6) = filter\nthen do\n  fi = length(zcmd)\n  if fi > 6\n  then do\n    zparm =  substr(zcmd,8,fi-6)\n    if zparm = 'CLEAR'\n    then do\n      \"ispexec setmsg msg(coba006) msgloc(zcmd)\"\n      f1 = \"\"\n      zparm  = \"\"\n      \"ispexec vput zparm\"\n      signal start\n    end\n  end\n  signal start\nend\n\nIF f1 = \"\"\nTHEN do\n  MESS1 = \"no filter criteria specified\"\n  \"ISPEXEC ADDPOP\"\n  \"ISPEXEC DISPLAY PANEL(coba000)\"\n  \"ISPEXEC REMPOP\"\n  signal start\nend\n\n\"ispexec vput (f1)\"\n\nfilter_done:\n\n\"ISPEXEC TBVCLEAR \" table\n\nfieldn = \"\"\n\nif f1 > \"\"\nthen do\n  field  = 'OPTION,'\n  field  = field||v1\n  fieldn = field\n  pkomma = pos(',',field)\n  name   = substr(field,1,pkomma-1)\n  f1n    = name\n  if pos('*',f1) = 0 then f1 = f1||'*'\n  fieldv = f1\n  call value name,fieldv\nend\n\ntabname = 'R'||time('S')\n\n\"ISPEXEC TBQUERY\" table \" KEYS(TKEYS) KEYNUM(TKEYNUM) NAMES(TNAMES)\"\n\"ISPEXEC TBSARG \" table \" NEXT NAMECOND(\"fieldn\")\"\n\n\"ISPEXEC TBERASE  \" tabname\n\"ISPEXEC TBCREATE \" TABNAME \" KEYS\"TKEYS \"NOWRITE NAMES\"TNAMES\n\nrc = 0\nrecfound = n\n\ndo while rc = 0\n  \"ISPEXEC TBSCAN \" table\n  if rc > 0 then leave\n  \"ISPEXEC TBADD \" tabname \" MULT(1000)\"\n  recfound = y\nend\n\nIF recfound = n\nTHEN do\n  MESS1 = \"no rows with searchargument found\"\n  MESS2 = \"searchargument \"\n  MESS3 = f1n \" = \" f1\n  \"ISPEXEC ADDPOP\"\n  \"ISPEXEC DISPLAY PANEL(coba000)\"\n  \"ISPEXEC REMPOP\"\n  \"ISPEXEC TBEND\" tabname\n  signal start\nend\n\n\"ISPEXEC TBTOP \" tabname\n\ncall cobanldt kz       ,\n              tabname  ,\n              table2   ,\n              table3   ,\n              panel    ,\n              filtproc ,\n              lineproc ,\n              COBANLF1 ,\n              sel\n\n\"ISPEXEC TBEND \" tabname\n\n\"ispexec vget (zparm zcmd)\"\n\nif zcmd     = FILTER\nthen do\n  if zparm  = 'CLEAR'\n  then do\n    f1      = \"\"\n    zparm   = \"\"\n    \"ispexec  vput zparm\"\n  end\n  signal      start\nend\n\nif kz       = FI then signal start\n\nf1          = \"\"\n\n\"ispexec      vput (f1)\"\n\nexit\n\nfill_names:\n\nf1n    = 'Option '\nf1K    = 'select cobol option'\nf2n    = ' '\nf2K    = ' '\nf3n    = ' '\nf3K    = ' '\n\nreturn\n\nfailures:\nline = strip(sourceline(sigl))\nCond = condition('C') condition('D')\n\"ispexec vput (cond line)\"\ncall cobasynt procname sigl errortext(rc) /* show what went wrong */\nexit\n./ ADD NAME=COBANLF3\n/*-------- REXX -------------------------------------------*/\n/* Function   : cobol information select statement info    */\n/*---------------------------------------------------------*/\n/*\n   TRACE ?R\n*/\n\n\"ispexec control errors return\"\nparse source xx yy procname rest\nsignal on syntax  name failures\nsignal on failure name failures\n\narg           kz       ,\n              table    ,\n              table2   ,\n              table3   ,\n              panel    ,\n              filtproc ,\n              lineproc ,\n              fromproc ,\n              sel\n\n\"ispexec vget (csel f1)\"\n\nIF f1 = \"\"\nthen nop\nelse do\n  v1    = EQ\n  v2    = EQ\n  v3    = EQ\n  kz    = FS\n  signal filter_done\nend\n\nSTART:\ncall fill_names\n\"ISPEXEC ADDPOP ROW(03) COLUMN(10)\"\n\"ISPEXEC DISPLAY PANEL(COBAFI10)\"\n\nIF RC = 12 | RC = 20\nTHEN do\n  CALL coba000 procname cobafi10 RC\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\nIF ZCMD = TRACE\nTHEN DO\n  zcmd = ' '\n  trace ?r\nend\n\nIF RC = 8\nTHEN do\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\n\"ISPEXEC REMPOP\"\n\nif substr(zcmd,1,6) = filter\nthen do\n  fi = length(zcmd)\n  if fi > 6\n  then do\n    zparm =  substr(zcmd,8,fi-6)\n    if zparm = 'CLEAR'\n    then do\n      \"ispexec setmsg msg(coba006) msgloc(zcmd)\"\n      f1 = \"\"\n      zparm  = \"\"\n      \"ispexec vput zparm\"\n      signal start\n    end\n  end\n  signal start\nend\n\nIF f1 = \"\"\nTHEN do\n  MESS1 = \"no filter criteria specified\"\n  \"ISPEXEC ADDPOP\"\n  \"ISPEXEC DISPLAY PANEL(coba000)\"\n  \"ISPEXEC REMPOP\"\n  signal start\nend\n\n\"ispexec vput (f1)\"\n\nfilter_done:\n\n\"ISPEXEC TBVCLEAR \" table\n\nfieldn = \"\"\n\nif f1 > \"\"\nthen do\n  field  = 'STMT,'\n  field  = field||v1\n  fieldn = field\n  pkomma = pos(',',field)\n  name   = substr(field,1,pkomma-1)\n  f1n    = name\n  if pos('*',f1) = 0 then f1 = f1||'*'\n  fieldv = f1\n  call value name,fieldv\nend\n\ntabname = 'R'||time('S')\n\n\"ISPEXEC TBQUERY\" table \" KEYS(TKEYS) KEYNUM(TKEYNUM) NAMES(TNAMES)\"\n\"ISPEXEC TBSARG \" table \" NEXT NAMECOND(\"fieldn\")\"\n\n\"ISPEXEC TBERASE  \" tabname\n\"ISPEXEC TBCREATE \" TABNAME \" KEYS\"TKEYS \"NOWRITE NAMES\"TNAMES\n\nrc = 0\nrecfound = n\n\ndo while rc = 0\n  \"ISPEXEC TBSCAN \" table\n  if rc > 0 then leave\n  \"ISPEXEC TBADD \" tabname \" MULT(1000)\"\n  recfound = y\nend\n\nIF recfound = n\nTHEN do\n  MESS1 = \"no rows with searchargument found\"\n  MESS2 = \"searchargument \"\n  MESS3 = f1n \" = \" f1\n  \"ISPEXEC ADDPOP\"\n  \"ISPEXEC DISPLAY PANEL(coba000)\"\n  \"ISPEXEC REMPOP\"\n  \"ISPEXEC TBEND\" tabname\n  signal start\nend\n\n\"ISPEXEC TBTOP \" tabname\n\ncall cobanldt kz       ,\n              tabname  ,\n              table2   ,\n              table3   ,\n              panel    ,\n              filtproc ,\n              lineproc ,\n              COBANLF3 ,\n              sel\n\n\"ISPEXEC TBEND \" tabname\n\n\"ispexec vget (zparm zcmd)\"\n\nif zcmd     = FILTER\nthen do\n  if zparm  = 'CLEAR'\n  then do\n    f1      = \"\"\n    zparm   = \"\"\n    \"ispexec  vput zparm\"\n  end\n  signal      start\nend\n\nif kz       = FI then signal start\n\nf1          = \"\"\n\n\"ispexec      vput (f1)\"\n\nexit\n\nfill_names:\n\nf1n    = 'Statement'\nf1K    = 'select cobol procedure division statement'\nf2n    = ' '\nf2K    = ' '\nf3n    = ' '\nf3K    = ' '\n\nreturn\n\nfailures:\nline = strip(sourceline(sigl))\nCond = condition('C') condition('D')\n\"ispexec vput (cond line)\"\ncall cobasynt procname sigl errortext(rc) /* show what went wrong */\nexit\n./ ADD NAME=COBANLLI 0108-01254-01254-1012-00101-00096-00000-EX31022\n/*-------- REXX -------------------------------------------*/\n/* Function   : select cobanal programs                    */\n/* caller     : general table display procedure            */\n/*---------------------------------------------------------*/\n/*\n    trace ?r\n*/\n\n\"ispexec control errors return\"\nparse source xx yy procname rest\nsignal on syntax  name failures\nsignal on failure name failures\n\nparse arg selection table table2 fromproc a sel\n\n\n\"ispexec vget tkey1\"\nztkey1   = tkey1\ntkey1    = 'PGMKEY'\n\"ispexec vput tkey1\"\n\nselect\n  when ztkey1 = 'OPTION'\n  then do\n    option    = selection\n  end\n  when ztkey1 = 'LOADLIB'\n  then do\n    fn        = 'LOADLIB'\n    loadlib   = selection\n    sel      = 'all programs from library ' selection\n  end\n  when ztkey1 = 'COBVERS'\n  then do\n    fn        = 'COBVERS'\n    cobvers   = selection\n    sel      = 'all programs compiler ' selection\n  end\n  when ztkey1 = 'STMT'\n  then do\n    fn        = 'STMT'\n    stmt      = selection\n    sel      = 'all programs with statement ' selection\n  end\n  otherwise do\n    MESS1 = \"invalid option specified\"\n    MESS2 = \"searchargument follows\"\n    MESS3 = 'TKEY1 = ' ztkey1\n    MESS4 = 'Selection = ' selection\n    \"ISPEXEC ADDPOP\"\n    \"ISPEXEC DISPLAY PANEL(COBA000)\"\n    \"ISPEXEC REMPOP\"\n    signal finish\n  end\nend\n\n\"ispexec tbget \" table\n\ncall value fn,selection\n\n\"ISPEXEC TBSARG \" table2 \" NEXT NAMECOND(\"fn\",EQ)\"\n\nIF rc > 0\nTHEN do\n  MESS1 = \"no rows with searchargument found\"\n  MESS2 = \"searchargument follows\"\n  MESS3 = 'TKEY1 = ' ztkey1\n  MESS4 = 'Selection = ' selection\n  \"ISPEXEC ADDPOP\"\n  \"ISPEXEC DISPLAY PANEL(COBA000)\"\n  \"ISPEXEC REMPOP\"\n  signal finish\nend\n\nif sel  = \"\"\nthen\n  Sel = 'programs with compile option ' option                            000038\n\ncall cobanldt 'OP'     ,\n              table2   ,\n              table2   ,\n              table3   ,\n              COBANL00 ,\n              COBANLF0 ,\n              COBANLL0 ,\n              COBANLLI ,\n              sel\n\nfinish:\ntkey1    = ztkey1\n\"ispexec vput tkey1\"\n\nexit\n\nfailures:\nline = strip(sourceline(sigl))\nCond = condition('C') condition('D')\n\"ispexec vput (cond line)\"\nparse source x y procname z\ncall cobasynt procname sigl errortext(rc) /* show what went wrong */\nexit\n./ ADD NAME=COBANLLX\n/*-------- REXX -------------------------------------------*/\n/* Function   : select cobanal programs                    */\n/* caller     : general table display procedure            */\n/*---------------------------------------------------------*/\n/*\n    trace ?r\n*/\n\n\"ispexec control errors return\"\nparse source xx yy procname rest\nsignal on syntax  name failures\nsignal on failure name failures\n\narg selection table table2 fromproc a\n\n\"ispexec vget tkey1\"\nztkey1   = tkey1\ntkey1    = 'PGMKEY'\n\"ispexec vput tkey1\"\n\nselect\n  when ztkey1 = 'OPTION'\n  then do\n    option    = selection\n  end\n  when ztkey1 = 'COBVERS'\n  then do\n    fn        = 'COBVERS'\n    cobvers   = selection\n  end\n  when ztkey1 = 'STMT'\n  then do\n    fn        = 'STMT'\n    stmt      = selection\n  end\n  when ztkey1 = 'LOADLIB'\n  then do\n    fn        = 'LOADLIB'\n    loadlib   = selection\n  end\n  otherwise do\n    MESS1 = \"invalid option specified\"\n    MESS2 = \"searchargument follows\"\n    MESS3 = 'TKEY1 = ' ztkey1\n    MESS4 = 'Selection = ' selection\n    \"ISPEXEC ADDPOP\"\n    \"ISPEXEC DISPLAY PANEL(COBA000)\"\n    \"ISPEXEC REMPOP\"\n    signal finish\n  end\nend\n\n\"ispexec tbget \" table\n\ncall value fn,selection\n\n\"ISPEXEC TBQUERY\" table2 \" KEYS(TKEY) KEYNUM(TKEYNUM) NAMES(TNAMES)\"\n\ntabname     = 'R'||time('S')\n\n\"ISPEXEC TBERASE \" tabname\n\n\"ISPEXEC TBCREATE \" TABNAME \" KEYS\"TKEY \"NOWRITE NAMES\"TNAMES\n\nrc          = 0\nrecfound    = n\n\n\"ISPEXEC TBSARG \" table2 \" NEXT NAMECOND(\"fn\")\"\n\ndo while rc = 0\n  \"ISPEXEC TBSCAN \" table2\n  if rc     > 0 then leave\n  \"ISPEXEC TBADD \" tabname \" MULT(1000)\"\n  recfound  = y\nend\n\nIF recfound = n\nTHEN do\n  MESS1 = \"no rows with searchargument found\"\n  MESS2 = \"searchargument follows\"\n  \"ISPEXEC ADDPOP\"\n  \"ISPEXEC DISPLAY PANEL(COBA000)\"\n  \"ISPEXEC REMPOP\"\n  \"ISPEXEC TBEND\" tabname\n  signal finish\nend\n\n\"ISPEXEC TBTOP \" tabname\n\nSel = 'programs with ' ztkey1 '=' selection\n\ncall cobanldt 'ALL'    ,\n              tabname  ,\n              table2   ,\n              table3   ,\n              COBANL00 ,\n              COBANLF0 ,\n              COBANLL0 ,\n              COBANLLI ,\n              sel\n\nfinish:\ntkey1    = ztkey1\n\"ispexec vput tkey1\"\n\nexit\n\nfailures:\nline = strip(sourceline(sigl))\nCond = condition('C') condition('D')\n\"ispexec vput (cond line)\"\nparse source x y procname z\ncall cobasynt procname sigl errortext(rc) /* show what went wrong */\nexit\n./ ADD NAME=COBANLL0\n/*-------- REXX -------------------------------------------*/\n/* Function   : display cobanal programm compiler options  */\n/*---------------------------------------------------------*/\n/*\n    trace ?r\n*/\n\narg pgmkey rest\n\n\"ispexec tbget cobanl00\"\n\n\"ispexec control errors return\"\nparse source xx yy procname rest\nsignal on syntax  name failures\nsignal on failure name failures\n\nstart:\n\"ISPEXEC ADDPOP ROW(03) COLUMN(10)\"\n\"ISPEXEC DISPLAY PANEL(COBANLL0)\"\n\nIF RC = 12 | RC = 20\nTHEN do\n  CALL COBA000 procname  procname rc\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\nIF ZCMD = TRACE\nTHEN DO\n  zcmd = ' '\n  trace ?r\nend\n\nIF RC = 8\nTHEN do\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\n\"ISPEXEC REMPOP\"\n\nif COBREL = 'VS/COBOL'\nthen do\n  mess1   = 'no more information for VS/COBOL program'\n  \"ISPEXEC ADDPOP ROW(03) COLUMN(10)\"\n  \"ISPEXEC DISPLAY PANEL(COBA000)\"\n  \"ISPEXEC REMPOP\"\n  signal start\nend\n\ndo i   = 1 to 59\n  fn1  = 's'||i\n  ini  = ' '\n  call   value fn1,ini\nend\n\nj      = 0\n\ndo i   = 1 to 59\n  fn1  = 'f'||i\n  fn2  = 'p'||i\n  if value(fn2) > \"\"\n  then do\n    j  = j + 1\n    fn3= 's'||j\n    call   value fn3,value(fn2)\n  end\nend\n\n\"ISPEXEC ADDPOP ROW(03) COLUMN(10)\"\n\"ISPEXEC DISPLAY PANEL(COBANL08)\"\n\nIF RC = 12 | RC = 20\nTHEN do\n  CALL COBA000 procname cobanl08 rc\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\nIF ZCMD = TRACE\nTHEN DO\n  zcmd = ' '\n  trace ?r\nend\n\nIF RC = 8\nTHEN do\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\n\"ISPEXEC REMPOP\"\n\nsignal start\n\nexit\n\nfailures:\nsay  \"line = \" strip(sourceline(sigl))\nsay  \"Cond = \" condition('C') condition('D')\nsay  \"Error= \" errortext(rc)\nexit\n./ ADD NAME=COBANLL9 0103-01254-01254-1001-00115-00115-00000-EX31022\n/*-------- REXX -------------------------------------------*/\n/* Function   : display information for loadlibs           */\n/* callers    : coba application                           */\n/*---------------------------------------------------------*/\n/*\n    trace ?r\n*/\n\n\"ispexec control errors return\"\nparse source xx yy procname rest\nsignal on syntax  name failures\nsignal on failure name failures\n\narg loadlib table table2 fromproc a\n\n\"ispexec tbget \" table\n\n\"ispexec vget tkey1\"\nztkey1   = tkey1\n\nSTART:\n\"ISPEXEC ADDPOP ROW(05) COLUMN(04)\"\n\"ISPEXEC DISPLAY PANEL(COBANLL9)\"\n\nIF RC = 12 | RC = 20\nTHEN do\n  CALL COBA000 procname procname RC\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\nIF ZCMD = TRACE\nTHEN DO\n  zcmd = ' '\n  trace ?r\nend\n\nIF RC = 8\nTHEN do\n  tkey1    = ztkey1                                                       000050\n  \"ispexec vput tkey1\"                                                    000051\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\n\"ISPEXEC REMPOP\"\n\nselect\n  when zcmd   = 1\n  then do\n    tkey1    = ztkey1                                                       0000\n    \"ispexec vput tkey1\"                                                    0000\n    call cobanlli loadlib table table2 COBANLL9 zcmd\n    signal start\n  end\n  when zcmd   = 2\n  then do\n    cobrel    = 'OS/VS'\n    ausw      = 'Cobol/VS '\n  end\n  when zcmd   = 3\n  then do\n    cobrel    = 'COBOL/2'\n    ausw      = 'Cobol/II '\n  end\n  when zcmd   = 4\n  then do\n    cobrel    = 'COBOL/370'\n    ausw      = 'Cobol/370 '\n  end\n  when zcmd   = 5\n  then do\n    call cobai34 'DSN' loadlib\n    signal start\n  end\n  otherwise signal start\nEND\n\nfn        = 'COBREL,EQ,LOADLIB,EQ'\nausw      = ausw 'programs from library' loadlib\ntkey1     = 'PGMKEY'\n\"ispexec vput tkey1\"\n\n\"ISPEXEC TBSARG COBANL00 NEXT NAMECOND(\"fn\")\"\n\nIF rc > 0\nTHEN do\n  MESS1 = \"no rows with searchargument found\"\n  MESS2 = \"searchargument follows\"\n  MESS3 = 'COBREL = ' cobrel\n  MESS4 = 'LOADLIB= ' loadlib\n  \"ISPEXEC ADDPOP\"\n  \"ISPEXEC DISPLAY PANEL(COBA000)\"\n  \"ISPEXEC REMPOP\"\n  signal start\nend\n\ncall cobanldt 'LO'     ,\n              COBANL00 ,\n              table2   ,\n              table3   ,\n              COBANL00 ,\n              COBANLF0 ,\n              COBANLL0 ,\n              COBANLLI ,\n              ausw\n\nsignal start\n\nfailures:\nline = strip(sourceline(sigl))\nCond = condition('C') condition('D')\n\"ispexec vput (cond line)\"\ncall cobasynt procname sigl errortext(rc) /* show what went wrong */\nexit\n./ ADD NAME=COBANLPG 0101-99348-99348-1005-00094-00094-00000-DESTS03\n/*-------- REXX -------------------------------------------*/\n/* Function   : display Cobanl program selection panel     */\n/*---------------------------------------------------------*/\n/*\n    trace ?r\n*/\n\n\"ispexec control errors return\"\nparse source xx yy procname rest\nsignal on syntax  name failures\n\nstart:\nmess    = 'please enter program name and loadlib'\n\"ISPEXEC ADDPOP ROW(03) COLUMN(10)\"\n\"ISPEXEC DISPLAY PANEL(COBANLPG)\"\nIF ZCMD = TRACE\nTHEN DO\n  zcmd = ' '\n  trace ?r\nend\nIF RC = 8\nTHEN do\n  \"ISPEXEC REMPOP\"\n  exit\nend\n\n\"ISPEXEC REMPOP\"\n\nM = MSG(OFF)\nX = SYSDSN(\"'\"dsn\"'\")\n\nIF X \u00ac= 'OK'\nTHEN DO\n  mess1   = 'load library = ' dsn\n  mess2   = 'not cataloged'\n  \"ISPEXEC ADDPOP ROW(03) COLUMN(10)\"\n  \"ISPEXEC DISPLAY PANEL(COBA000)\"\n  \"ISPEXEC REMPOP\"\n  signal start\nEND\n\n\"ispexec vget steplib\"\n\n\"FREE F(SYSPRINT)\"\n\"FREE F(COBANAL)\"\n\nodataset = userid()\".COBANAL.PGMLIST\"\n\nADDRESS TSO \"DELETE '\"odataset\"'\"\n\nADDRESS TSO \"ALLOC F(SYSPRINT) \",\n            \"DA('\"odataset\"') \",\n            \"NEW REU \",\n            \"LRECL(121)\",\n            \"RECFM(F B)\",\n            \"BLKSIZE(0)\",\n            \"TRACKS\",\n            \"SPACE(1 1)\"\n\nADDRESS TSO \"ALLOC F(COBANAL) \",\n            \"DA('\"dsn\"') \",\n            \"SHR\"\n\n\"CALL '\"STEPLIB\"(COBANAL)' '\"pgm\"'\"\nmess1 = 'CALL 'STEPLIB'(COBANAL)' pgm\n\nif rc     > 4\nthen do\n  mess2   = 'Returncode = ' rc\n  mess3   = 'Possible reason could be S806'\n  mess4   = 'module COBANAL not found'\n  \"ISPEXEC ADDPOP ROW(03) COLUMN(10)\"\n  \"ISPEXEC DISPLAY PANEL(COBA000)\"\n  \"ISPEXEC REMPOP\"\nend\nelse do\n  \"ISPEXEC VIEW DATASET('\"ODATASET\"')\"\nend\n\n\"FREE F(SYSPRINT)\"\n\"FREE F(COBANAL)\"\n\nADDRESS TSO \"DELETE '\"odataset\"'\"\nM = MSG(ON)\n\nSIGNAL START\n\nfailures:\nline = strip(sourceline(sigl))\nCond = condition('C') condition('D')\n\"ispexec vput (cond line)\"\nparse source x y procname z\ncall cobasynt procname sigl errortext(rc) /* show what went wrong */\nexit\n./ ADD NAME=COBANL03 0101-02330-02330-1054-00388-00383-00005-EX31022\n/*-------- REXX -------------------------------------------*/\n/* Function   : select  cobanal options                    */\n/*---------------------------------------------------------*/\n/*\n    trace ?r\n*/\n\n\"ispexec control errors return\"\nparse source xx yy procname rest\nsignal on syntax  name failures\nsignal on failure name failures\n\ninit:\n\"ISPEXEC ADDPOP\"\n\"ISPEXEC DISPLAY PANEL(COBANL05)\"\n\nIF RC = 12 | RC = 20\nTHEN do\n  \"ISPEXEC REMPOP\"\n  CALL COBA000 procname cobanl05 rc\n  EXIT\nend\n\nIF ZCMD = TRACE\nTHEN DO\n  zcmd = ' '\n  trace ?r\nend\n\nIF RC = 8\nTHEN do\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\n\"ISPEXEC REMPOP\"\n\nselect\n  when zcmd = 1\n  then do\n    call      cobanl06\n    signal    init\n  end\n  when zcmd = 2 then nop\n  when zcmd = 3\n  then do\n    call      cobanl10\n    signal    init\n  end\n  otherwise   signal init\nend\n\nstart:\n\"ISPEXEC ADDPOP\"\n\"ISPEXEC DISPLAY PANEL(COBANL03)\"\n\nIF RC = 12 | RC = 20\nTHEN do\n  \"ISPEXEC REMPOP\"\n  CALL COBA000 procname procname rc\n  EXIT\nend\n\nIF ZCMD = TRACE\nTHEN DO\n  zcmd = ' '\n  trace ?r\nend\n\nIF RC = 8\nTHEN do\n  \"ISPEXEC REMPOP\"\n  signal init\nend\n\n\"ISPEXEC REMPOP\"\n\nselect\n  when zcmd = 1\n  then do\n    fieldv  = ADV\n  end\n  when zcmd = 2\n  then do\n    fieldv  = NOADV\n  end\n  when zcmd = 3\n  then do\n    fieldv  = QUOTE\n  end\n  when zcmd = 4\n  then do\n    fieldv  = NOQUOTE\n  end\n  when zcmd = 5\n  then do\n    fieldv  = 'DATA(24)'\n  end\n  when zcmd = 6\n  then do\n    fieldv  = 'DATA(31)'\n  end\n  when zcmd = 7\n  then do\n    fieldv  = DECK\n  end\n  when zcmd = 8\n  then do\n    fieldv  = NODECK\n  end\n  when zcmd = 9\n  then do\n    fieldv  = DUMP\n  end\n  when zcmd = 10\n  then do\n    fieldv  = NODUMP\n  end\n  when zcmd = 11\n  then do\n    fieldv  = DYNAM\n  end\n  when zcmd = 12\n  then do\n    fieldv  = NODYNAM\n  end\n  when zcmd = 13\n  then do\n    fieldv  = FASTSRT\n  end\n  when zcmd = 14\n  then do\n    fieldv  = NOFASTSRT\n  end\n  when zcmd = 15\n  then do\n    fieldv  = FDUMP\n  end\n  when zcmd = 16\n  then do\n    fieldv  = NOFDUMP\n  end\n  when zcmd = 17\n  then do\n    fieldv  = LIB\n  end\n  when zcmd = 18\n  then do\n    fieldv  = NOLIB\n  end\n  when zcmd = 19\n  then do\n    fieldv  = LIST\n  end\n  when zcmd = 20\n  then do\n    fieldv  = NOLIST\n  end\n  when zcmd = 21\n  then do\n    fieldv  = MAP\n  end\n  when zcmd = 22\n  then do\n    fieldv  = NOMAP\n  end\n  when zcmd = 23\n  then do\n    fieldv  = NUM\n  end\n  when zcmd = 24\n  then do\n    fieldv  = NONUM\n  end\n  when zcmd = 25\n  then do\n    fieldv  = OBJ\n  end\n  when zcmd = 26\n  then do\n    fieldv  = NOOBJ\n  end\n  when zcmd = 27\n  then do\n    fieldv  = OFFSET\n  end\n  when zcmd = 28\n  then do\n    fieldv  = NOOFFSET\n  end\n  when zcmd = 29\n  then do\n    fieldv  = OPTIMIZE\n  end\n  when zcmd = 30\n  then do\n    fieldv  = NOOPTIMIZE\n  end\n  when zcmd = 31\n  then do\n    fieldv  = 'DDNAME(Default)'\n  end\n  when zcmd = 32\n  then do\n    fieldv  = 'DDNAME(no-Default)'\n  end\n  when zcmd = 33\n  then do\n    fieldv  = 'NUMPROC(PFD)'\n  end\n  when zcmd = 34\n  then do\n    fieldv  = 'NUMPROC(NOPFD)'\n  end\n  when zcmd = 35\n  then do\n    fieldv  = RENT\n  end\n  when zcmd = 36\n  then do\n    fieldv  = NORENT\n  end\n  when zcmd = 37\n  then do\n    fieldv  = RES\n  end\n  when zcmd = 38\n  then do\n    fieldv  = NORES\n  end\n  when zcmd = 39\n  then do\n    fieldv  = SEQ\n  end\n  when zcmd = 40\n  then do\n    fieldv  = NOSEQ\n  end\n  when zcmd = 41\n  then do\n    fieldv  = 'SIZE(MAX)'\n  end\n  when zcmd = 42\n  then do\n    fieldv  = 'SIZE(NOMAX)'\n  end\n  when zcmd = 43\n  then do\n    fieldv  = SOURCE\n  end\n  when zcmd = 44\n  then do\n    fieldv  = NOSOURCE\n  end\n  when zcmd = 45\n  then do\n    fieldv  = SSRANGE\n  end\n  when zcmd = 46\n  then do\n    fieldv  = NOSSRANGE\n  end\n  when zcmd = 47\n  then do\n    fieldv  = TERM\n  end\n  when zcmd = 48\n  then do\n    fieldv  = NOTERM\n  end\n  when zcmd = 49\n  then do\n    fieldv  = TEST\n  end\n  when zcmd = 50\n  then do\n    fieldv  = NOTEST\n  end\n  when zcmd = 51\n  then do\n    fieldv  = 'TRUNC(BIN)'\n  end\n  when zcmd = 52\n  then do\n    fieldv  = 'TRUNC(OPT)'\n  end\n  when zcmd = 53\n  then do\n    fieldv  = VBREF\n  end\n  when zcmd = 54\n  then do\n    fieldv  = NOVBREF\n  end\n  when zcmd = 55\n  then do\n    fieldv  = XREF\n  end\n  when zcmd = 56\n  then do\n    fieldv  = NOXREF\n  end\n  when zcmd = 57\n  then do\n    fieldv  = ZWB\n  end\n  when zcmd = 58\n  then do\n    fieldv  = NOZWB\n  end\n  when zcmd = 59\n  then do\n    fieldv  = NAME\n  end\n  when zcmd = 60\n  then do\n    fieldv  = NONAME\n  end\n  when zcmd = 61\n  then do\n    fieldv  = CMPR2\n  end\n  when zcmd = 62\n  then do\n    fieldv  = NOCMPR2\n  end\n  when zcmd = 63\n  then do\n    fieldv  = NUMCLS\n  end\n  when zcmd = 64\n  then do\n    fieldv  = NONUMCLS\n  end\n  when zcmd = 65\n  then do\n    fieldv  = DBCS\n  end\n  when zcmd = 66\n  then do\n    fieldv  = NODBCS\n  end\n  when zcmd = 67\n  then do\n    fieldv  = AWO\n  end\n  when zcmd = 68\n  then do\n    fieldv  = NOAWO\n  end\n  when zcmd = 69\n  then do\n    fieldv  = EVENTS\n  end\n  when zcmd = 70\n  then do\n    fieldv  = NOEVENTS\n  end\n  when zcmd = 71\n  then do\n    fieldv  = CURRENCY\n  end\n  when zcmd = 72\n  then do\n    fieldv  = NOCURRENCY\n  end\n  when zcmd = 73\n  then do\n    fieldv  = WORD\n  end\n  when zcmd = 74\n  then do\n    fieldv  = NOWORD\n  end\n  otherwise   signal start\nend\n\ncall cobanlli fieldv cobanl01 cobanl00 cobanl03 s\n\nsignal start\n\nexit\n\nfailures:\nsay  \"line = \" strip(sourceline(sigl))\nsay  \"Cond = \" condition('C') condition('D')\nsay  \"Error= \" errortext(rc)\nexit\n./ ADD NAME=COBANL06\n/*-------- REXX -------------------------------------------*/\n/* Function   : select  cobanal options                    */\n/*---------------------------------------------------------*/\n/*\n    trace ?r\n*/\n\n\"ispexec control errors return\"\nparse source xx yy procname rest\nsignal on syntax  name failures\nsignal on failure name failures\n\nstart:\n\"ISPEXEC ADDPOP\"\n\"ISPEXEC DISPLAY PANEL(COBANL06)\"\n\nIF RC = 12 | RC = 20\nTHEN do\n  \"ISPEXEC REMPOP\"\n  CALL COBA000 procname cobanl06 rc\n  EXIT\nend\n\nIF ZCMD = TRACE\nTHEN DO\n  zcmd = ' '\n  trace ?r\nend\n\nIF RC = 8\nTHEN do\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\n\"ISPEXEC REMPOP\"\n\nselect\n  when zcmd = 1\n  then do\n    fieldv  = SYMDMP\n  end\n  when zcmd = 2\n  then do\n    fieldv  = NOSYMDMP\n  end\n  when zcmd = 3\n  then do\n    fieldv  = FLOW\n  end\n  when zcmd = 4\n  then do\n    fieldv  = NOFLOW\n  end\n  when zcmd = 5\n  then do\n    fieldv  = STATE\n  end\n  when zcmd = 6\n  then do\n    fieldv  = NOSTATE\n  end\n  when zcmd = 7\n  then do\n    fieldv  = OPT\n  end\n  when zcmd = 8\n  then do\n    fieldv  = NOOPT\n  end\n  when zcmd = 9\n  then do\n    fieldv  = TEST\n  end\n  when zcmd = 10\n  then do\n    fieldv  = NOTEST\n  end\n  when zcmd = 11\n  then do\n    fieldv  = RES\n  end\n  when zcmd = 12\n  then do\n    fieldv  = NORES\n  end\n  when zcmd = 13\n  then do\n    fieldv  = ENDJOB\n  end\n  when zcmd = 14\n  then do\n    fieldv  = NOENDJOB\n  end\n  when zcmd = 15\n  then do\n    fieldv  = OBJ370\n  end\n  when zcmd = 16\n  then do\n    fieldv  = NOOBJ370\n  end\n  when zcmd = 17\n  then do\n    fieldv  = COUNT\n  end\n  when zcmd = 18\n  then do\n    fieldv  = NOCOUNT\n  end\n  when zcmd = 19\n  then do\n    fieldv  = LIST\n  end\n  when zcmd = 20\n  then do\n    fieldv  = TRACE\n  end\n  when zcmd = 21\n  then do\n    fieldv  = 'NO-TRACE'\n  end\n  otherwise   signal start\nend\n\ncall cobanlli fieldv cobanl01 cobanl00 cobanl03 s\n\nsignal start\n\nexit\n\nfailures:\nsay  \"line = \" strip(sourceline(sigl))\nsay  \"Cond = \" condition('C') condition('D')\nsay  \"Error= \" errortext(rc)\nexit\n./ ADD NAME=COBANL10 0102-02330-02330-1109-00348-00348-00001-EX31022\n/*-------- REXX -------------------------------------------*/\n/* Function   : select  cobanal options                    */\n/*---------------------------------------------------------*/\n/*\n    trace ?r\n*/\n\n\"ispexec control errors return\"\nparse source xx yy procname rest\nsignal on syntax  name failures\nsignal on failure name failures\n\nstart:\n\"ISPEXEC ADDPOP\"\n\"ISPEXEC DISPLAY PANEL(COBANL10)\"\n\nIF RC = 12 | RC = 20\nTHEN do\n  \"ISPEXEC REMPOP\"\n  CALL COBA000 procname procname rc\n  EXIT\nend\n\nIF ZCMD = TRACE\nTHEN DO\n  zcmd = ' '\n  trace ?r\nend\n\nIF RC = 8\nTHEN do\n  \"ISPEXEC REMPOP\"\n  exit\nend\n\n\"ISPEXEC REMPOP\"\n\nselect\n  when zcmd = 1\n  then do\n    fieldv  = ADV\n  end\n  when zcmd = 2\n  then do\n    fieldv  = NOADV\n  end\n  when zcmd = 3\n  then do\n    fieldv  = QUOTE\n  end\n  when zcmd = 4\n  then do\n    fieldv  = NOQUOTE\n  end\n  when zcmd = 5\n  then do\n    fieldv  = 'DATA(24)'\n  end\n  when zcmd = 6\n  then do\n    fieldv  = 'DATA(31)'\n  end\n  when zcmd = 7\n  then do\n    fieldv  = DECK\n  end\n  when zcmd = 8\n  then do\n    fieldv  = NODECK\n  end\n  when zcmd = 9\n  then do\n    fieldv  = DUMP\n  end\n  when zcmd = 10\n  then do\n    fieldv  = NODUMP\n  end\n  when zcmd = 11\n  then do\n    fieldv  = DYNAM\n  end\n  when zcmd = 12\n  then do\n    fieldv  = NODYNAM\n  end\n  when zcmd = 13\n  then do\n    fieldv  = FASTSRT\n  end\n  when zcmd = 14\n  then do\n    fieldv  = NOFASTSRT\n  end\n  when zcmd = 15\n  then do\n    fieldv  = FDUMP\n  end\n  when zcmd = 16\n  then do\n    fieldv  = NOFDUMP\n  end\n  when zcmd = 17\n  then do\n    fieldv  = LIB\n  end\n  when zcmd = 18\n  then do\n    fieldv  = NOLIB\n  end\n  when zcmd = 19\n  then do\n    fieldv  = LIST\n  end\n  when zcmd = 20\n  then do\n    fieldv  = NOLIST\n  end\n  when zcmd = 21\n  then do\n    fieldv  = MAP\n  end\n  when zcmd = 22\n  then do\n    fieldv  = NOMAP\n  end\n  when zcmd = 23\n  then do\n    fieldv  = NUM\n  end\n  when zcmd = 24\n  then do\n    fieldv  = NONUM\n  end\n  when zcmd = 25\n  then do\n    fieldv  = OBJ\n  end\n  when zcmd = 26\n  then do\n    fieldv  = NOOBJ\n  end\n  when zcmd = 27\n  then do\n    fieldv  = OFFSET\n  end\n  when zcmd = 28\n  then do\n    fieldv  = NOOFFSET\n  end\n  when zcmd = 29\n  then do\n    fieldv  = OPTIMIZE\n  end\n  when zcmd = 30\n  then do\n    fieldv  = NOOPTIMIZE\n  end\n  when zcmd = 31\n  then do\n    fieldv  = 'DDNAME(Default)'\n  end\n  when zcmd = 32\n  then do\n    fieldv  = 'DDNAME(no-Default)'\n  end\n  when zcmd = 33\n  then do\n    fieldv  = 'NUMPROC(PFD)'\n  end\n  when zcmd = 34\n  then do\n    fieldv  = 'NUMPROC(NOPFD)'\n  end\n  when zcmd = 35\n  then do\n    fieldv  = RENT\n  end\n  when zcmd = 36\n  then do\n    fieldv  = NORENT\n  end\n  when zcmd = 37\n  then do\n    fieldv  = RES\n  end\n  when zcmd = 38\n  then do\n    fieldv  = NORES\n  end\n  when zcmd = 39\n  then do\n    fieldv  = SEQ\n  end\n  when zcmd = 40\n  then do\n    fieldv  = NOSEQ\n  end\n  when zcmd = 41\n  then do\n    fieldv  = 'SIZE(MAX)'\n  end\n  when zcmd = 42\n  then do\n    fieldv  = 'SIZE(NOMAX)'\n  end\n  when zcmd = 43\n  then do\n    fieldv  = SOURCE\n  end\n  when zcmd = 44\n  then do\n    fieldv  = NOSOURCE\n  end\n  when zcmd = 45\n  then do\n    fieldv  = SSRANGE\n  end\n  when zcmd = 46\n  then do\n    fieldv  = NOSSRANGE\n  end\n  when zcmd = 47\n  then do\n    fieldv  = TERM\n  end\n  when zcmd = 48\n  then do\n    fieldv  = NOTERM\n  end\n  when zcmd = 49\n  then do\n    fieldv  = TEST\n  end\n  when zcmd = 50\n  then do\n    fieldv  = NOTEST\n  end\n  when zcmd = 51\n  then do\n    fieldv  = 'TRUNC(BIN)'\n  end\n  when zcmd = 52\n  then do\n    fieldv  = 'TRUNC(OPT)'\n  end\n  when zcmd = 53\n  then do\n    fieldv  = VBREF\n  end\n  when zcmd = 54\n  then do\n    fieldv  = NOVBREF\n  end\n  when zcmd = 55\n  then do\n    fieldv  = XREF\n  end\n  when zcmd = 56\n  then do\n    fieldv  = NOXREF\n  end\n  when zcmd = 57\n  then do\n    fieldv  = ZWB\n  end\n  when zcmd = 58\n  then do\n    fieldv  = NOZWB\n  end\n  when zcmd = 59\n  then do\n    fieldv  = NAME\n  end\n  when zcmd = 60\n  then do\n    fieldv  = NONAME\n  end\n  when zcmd = 61\n  then do\n    fieldv  = CMPR2\n  end\n  when zcmd = 62\n  then do\n    fieldv  = NOCMPR2\n  end\n  when zcmd = 63\n  then do\n    fieldv  = NUMCLS\n  end\n  when zcmd = 64\n  then do\n    fieldv  = NONUMCLS\n  end\n  when zcmd = 65\n  then do\n    fieldv  = DBCS\n  end\n  when zcmd = 66\n  then do\n    fieldv  = NODBCS\n  end\n  when zcmd = 67\n  then do\n    fieldv  = AWO\n  end\n  when zcmd = 68\n  then do\n    fieldv  = NOAWO\n  end\n  when zcmd = 69\n  then do\n    fieldv  = EVENTS\n  end\n  when zcmd = 70\n  then do\n    fieldv  = NOEVENTS\n  end\n  when zcmd = 71\n  then do\n    fieldv  = CURRENCY\n  end\n  when zcmd = 72\n  then do\n    fieldv  = NOCURRENCY\n  end\n  when zcmd = 73\n  then do\n    fieldv  = WORD\n  end\n  when zcmd = 74\n  then do\n    fieldv  = NOWORD\n  end\n  otherwise   signal start\nend\n\ncall cobanlli fieldv cobanl01 cobanl00 cobanl03 s\n\nsignal start\n\nexit\n\nfailures:\nsay  \"line = \" strip(sourceline(sigl))\nsay  \"Cond = \" condition('C') condition('D')\nsay  \"Error= \" errortext(rc)\nexit\n./ ADD NAME=COBASUBP 0100-01038-01038-0657-00103-00103-00000-EX31022\n/*--- REXX -------------------------------------------*/\n/*\n   trace ?r\n*/\n\nARG loadlib ptype\n\n\"ISPEXEC CONTROL ERRORS RETURN\"\n\ndsname   = listdsi(ISPPROF FILE)\n\nif dsname = 16\nthen do\n  JCLLIB  = USERID()||.ISPF.ISPPROF\nend\nelse do\n  jcllib   = sysdsname\nend\n\n\"ALLOC DD(ISPFILE) DSN('\"JCLLIB\"') SHR REUSE\"\n\n\"ISPEXEC VGET (STEPLIB COBAAPPL)\"\n\"ISPEXEC VGET (COBAHLQ LLQCLIB LLQMLIB LLQPLIB LLQSLIB LLQTLIB LLQTABL)\"\n\"ISPEXEC VGET (ACCOUNT CLASS MSGCLASS ISPFHLQ)\"\n\n\"ISPEXEC FTCLOSE NAME(COBAJOB0)\"\n\n\"ISPEXEC FTOPEN\"\n\nif rc > 0\nthen do\n  select\n    when rc = 8\n    then do\n      MESS2 = \"file tailoring already in progress\"\n    end\n    when rc = 12\n    then do\n      MESS2 = \"output file in use. ENQ failed\"\n    end\n    when rc = 16\n    then do\n      MESS2 = \"ISPFILE not allocated\"\n    end\n    when rc = 20\n    then do\n      MESS2 = \"severe error\"\n    end\n    otherwise\n  end\n  MESS1 = \"error FTOPEN\"\n  MESS3 = \"returncode = \" || rc\n  MESS4 = \"Procedur = COBASUBP\"\n  \"ISPEXEC ADDPOP\"\n  \"ISPEXEC DISPLAY PANEL(COBA000)\"\n  \"ISPEXEC REMPOP\"\n  \"ISPEXEC FTCLOSE\"\n  signal free_file\nend\n\n\"ISPEXEC FTINCL COBANAL\"\n\nif rc > 0\nthen do\n  select\n    when rc = 8\n    then do\n      MESS1 = \"output skeleton not defined\"\n    end\n    when rc = 12\n    then do\n      MESS1 = \"output skeleton in use. ENQ failed\"\n    end\n    when rc = 16\n    then do\n      MESS1 = \"data truncation occured\"\n    end\n    when rc = 20\n    then do\n      MESS1 = \"severe error\"\n    end\n    otherwise\n  end\n  MESS2 = \"please contact system support\"\n  MESS3 = \"skeleton = \" || COBANAL\n  \"ISPEXEC ADDPOP\"\n  \"ISPEXEC DISPLAY PANEL(COBA000)\"\n  \"ISPEXEC FTCLOSE\"\n  \"ISPEXEC REMPOP\"\n  signal ende\nend\n\n\"ISPEXEC FTCLOSE NAME(COBAJOB0)\"\n\n\"ISPEXEC EDIT DATASET('\"JCLLIB\"(COBAJOB0)')\"\n\nende:\n\"ISPEXEC FTERASE COBAJOB0\"\n\nfree_file:\n\"FREE DD(ISPFILE)\"\n\nEXIT\n./ ADD NAME=COBASYNT\n/*--- REXX -------------------------------------------*/\n/*\n   TRACE ?R\n*/\n\narg proc sline err\n\n\"ISPEXEC CONTROL ERRORS RETURN \"\n\n\"ispexec vget (line cond)\"\n\n\"ISPEXEC ADDPOP ROW(04) COLUMN(08)\"\n\nSTART:\n\"ISPEXEC DISPLAY PANEL(COBASYNT)\"\n\nIF RC = 12 | RC = 20\nTHEN do\n  CALL COBA000 COBASYNT COBASYNT RC\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\nIF RC = 8\nTHEN do\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\nsignal start\n\nexit\n./ ADD NAME=COBASYSI\n/*-------- REXX -------------------------------------------*/\n/* Function   : display information for system             */\n/* callers    : coba information application               */\n/*---------------------------------------------------------*/\n/*\n    trace ?r\n*/\n\n\"ispexec control errors return\"\nparse source xx yy procname rest\nsignal on syntax  name failures\nsignal on failure name failures\n\ncpu     = storage(208,4)\ncpu     = storage(d2x(c2d(cpu)+12),4)\ncvt     = storage(10,4)\ncvtprod = d2x(c2d(cvt) - c2d('28'x))\nmvslvl  = storage(cvtprod,16)\n\nx = syscpus(cpu.)\ncpun    = cpu.0\ncpu1    = cpu.1\nif cpun > 1 then cpu2    = cpu.2\nif cpun > 2 then cpu3    = cpu.3\nif cpun > 3 then cpu4    = cpu.4\nif cpun > 4 then cpu5    = cpu.5\nif cpun > 5 then cpu6    = cpu.6\n\nmvslvl  = mvsvar(sysopsys)\nsyslvl  = mvsvar(sysname)\nsmfid   = mvsvar(syssmfid)\ncput    = sysvar(syscpu)\n\njeslvl  = sysvar(sysjes)\ntsolvl  = sysvar(systsoe)\nracflvl = sysvar(syslracf)\nparse version rexxlvl\n\n\"ISPEXEC ADDPOP ROW(08) COLUMN(10)\"\n\n\"ISPEXEC DISPLAY PANEL(COBASYSI)\"\n\nIF RC = 12 | RC = 20\nTHEN do\n  CALL COBA000 procname cobasysi RC\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\n\"ISPEXEC REMPOP\"\n\nIF ZCMD = TRACE\nTHEN DO\n  zcmd = ' '\n  trace ?r\nend\n\nEXIT\n\nsyntax:\nparse source x y procname z\ncall cobasynt procname sigl errortext(rc)\nexit\n./ ADD NAME=COBAUMWA 0101-02008-02008-1011-00033-00033-00001-EX31022\n//COBAUMWA PROC NAME=,\n//             COBAHLQ='EX31022.COBA',\n//             LLQSRCE=SISPEXEC,\n//             LLQLOAD=SISPLOAD,\n//             OUTC='*',\n//             REG=1024K,\n//             WORK=SYSALLDA\n//*\n//ASM     EXEC PGM=ASMA90,\n//             REGION=&REG,\n//             PARM='DECK,NOOBJECT,LIST'\n//SYSLIB    DD DSN=&COBAHLQ..&LLQSRCE,DISP=SHR\n//          DD DSN=SYS1.MACLIB,DISP=SHR\n//          DD DSN=SYS1.AMODGEN,DISP=SHR\n//SYSIN     DD DSN=&COBAHLQ..&LLQSRCE(&NAME),DISP=SHR\n//SYSUT1    DD UNIT=&WORK,SPACE=(1700,(400,400))\n//SYSUT2    DD UNIT=&WORK,SPACE=(1700,(400,400))\n//SYSUT3    DD UNIT=&WORK,SPACE=(1700,(400,400))\n//SYSPUNCH  DD DSN=&&LOADSET,\n//             UNIT=&WORK,DISP=(,PASS),\n//             SPACE=(400,(100,100)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=400)\n//SYSPRINT  DD SYSOUT=&OUTC\n//LKED    EXEC PGM=IEWL,REGION=&REG,\n//             PARM=XREF,COND=(5,LT,ASM)\n//SYSLIB    DD DSN=ISP.SISPLOAD,DISP=SHR\n//SYSUT1    DD UNIT=&WORK,DCB=BLKSIZE=1024,\n//             SPACE=(1024,(200,20))\n//SYSPRINT  DD SYSOUT=&OUTC\n//SYSPUNCH  DD DSN=&&LOADSET,DISP=(OLD,PASS)\n//SYSLIN    DD DSN=&&LOADSET,\n//             DISP=(OLD,PASS),VOL=REF=*.SYSPUNCH\n//SYSLMOD   DD DSN=&COBAHLQ..&LLQLOAD(&NAME),DISP=SHR\n./ ADD NAME=COBA000\n/*-------- REXX -------------------------------------------*/\n/* Function   : display information for panel error        */\n/* callers    : cob analysys  application                  */\n/*---------------------------------------------------------*/\n/*\n   TRACE ?R\n*/\n\narg procname panel disrc\n\n/* Rexx get panelid of last displayed panel                          */\n/* Not a general use programming interface                           */\n/* This method is subject to breakage by maintanence or new releases */\n/* die folgende zuweisung zeigt letztes gezeigtes Panel an           */\n\npnl   = storage(d2x(ptr(ptr(ptr(ptr(ptr(540)+132)+112)+24))+352),8)\n\nMESS1 = 'panel display/query error in procedur '\nMESS2 = 'Procname   = '||procname\nMESS3 = 'Panel name = '||panel\nMESS4 = 'returncode = '||disrc\n\nif disrc = 20 then mess6 = \"severe error\"\nelse do\n  mess6 = \"no table rows to display\"\n  mess7 = \"or panel does not exist\"\nend\n\n\"ISPEXEC ADDPOP\"\n\"ISPEXEC DISPLAY PANEL(COBA000)\"\n\"ISPEXEC REMPOP\"\n\nexit\n\n/* Rexx get panelid of last displayed panel                          */\n/* Not a general use programming interface                           */\n/* This method is subject to breakage by maintanence or new releases */\n\nptr: Return c2d(bitand(storage(d2x(Arg(1)),4),'7FFFFFFF'x))\n./ ADD NAME=JUMWCOBA 0101-02008-02015-1440-00011-00011-00000-EX31022\n//EX31022A JOB (#ACCNT),'NAME',\n//             CLASS=S,MSGCLASS=T,MSGLEVEL=(1,1)\n//*\n//MYLIB JCLLIB ORDER=(EX31022.COBA.SISPEXEC)\n//*\n//*        UMWANDLUNG/LINK      ASSEMBLER BATCH\n//*\n//STEP1   EXEC COBAUMWA,NAME=COBANAL\n//ASM.SYSIN DD DSN=EX31022.COBA.SISPEXEC(&NAME)\n//LKED.SYSLMOD DD DSN=EX31022.COBA.SISPLOAD(&NAME),DISP=SHR\n//*\n./ ADD NAME=STRING   0505-78239-00114-1747-01363-00025-01363-ROLANDS\n*//IBMUSERM JOB (ACCT#),STRING,\n*// NOTIFY=&SYSUID,\n*// CLASS=A,MSGCLASS=X,COND=(0,NE)\n*//ASMH EXEC PGM=IEV90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF,NOBATCH)\n***********************************************************************\n*                                                                     *\n* MACRO NAME = STRING                                                 *\n*                                                                     *\n* DESCRIPTIVE NAME = STRING Macro Instruction.                        *\n*                                                                     *\n* FUNCTION = Provide capabilities similar to PUT EDIT (of PL/I)       *\n*            or STRING (of COBOL) to assembler programs.              *\n*                                                                     *\n* STATUS = R507                                                       *\n*                                                                     *\n* AUTHOR = Gilbert Saint-flour <gsf@pobox.com>                        *\n*                                                                     *\n* ENVIRONMENT = SEE BELOW                                             *\n*                                                                     *\n*     AMODE = ANY                                                     *\n*     SCP   = MVS/XA, MVS/ESA or OS/390                               *\n*     KEY   = ANY                                                     *\n*     MODE  = ANY                                                     *\n*     APF   = OFF                                                     *\n*                                                                     *\n* OPERATION = SEE DOCUMENTATION AT THE END OF THIS FILE               *\n*                                                                     *\n* INVOCATION = SEE DOCUMENTATION AT THE END OF THIS FILE              *\n*                                                                     *\n* NOTES = SEE DOCUMENTATION AT THE END OF THIS FILE                   *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n*  $301  FIX BUGS WITH (XYZ,,L8) AND INTO=((R1),(R2))                 *\n*  $302  GENERATE $DEBUG BOOT-STRAP IN FINAL_CALL INVOCATION          *\n*  $303  REPLACE @STRPAD WITH @STRBLANKS                              *\n*  $304  USE @00-@15 INSTEAD OF R0-R15 FOR REGISTER EQUATES           *\n*  $306  TAILOR @STRING CSECT TO PROGRAM'S REQUIREMENTS               *\n*        LITERALS CAN BE CODED AS 'ABC' OR C'ABC' OR X'C1C2C3'        *\n*        USE L'PSATOLD AS IMPLICIT LENGTH FOR (PSATOLD-PSA,,X)        *\n*  $307  FINAL_CALL OPTION CHANGED TO GENERATE                        *\n*        ADD NOCSECT AND LOCTR OPTIONS TO GENERATE CALL               *\n*  $308  USE L'RBCDE AS IMPLICIT LENGTH FOR (PRB.RBCDE,,X)            *\n*        PREVENT S0C4 WHEN ADDR IS BAD AND LENGTH IS ZERO             *\n*  $400  REORG THE CODE TO SIMPLIFY FEATURE SELECTION                 *\n*        BLANKS NO LONGER USED OR GENERATED                           *\n*  $401  GENERATE @STRHEXT WHEN ((REG),,X) ONLY HEX FIELD             *\n*  $502  @STRING ROUTINE REWRITTEN FOR MVS/ESA:                       *\n*        -  USE LINKAGE STACK TO STORE CALLER'S REGISTERS             *\n*        -  ADD SUPPORT FOR AR MODE                                   *\n*  $503  DATE CONVERSION TO YYYY-MM-DD FORMAT (ISO STANDARD)          *\n*        IMPROVE SUPPORT FOR AR MODE                                  *\n*  $504  SET &STRBLANKS TO 10 WHEN PROCESSING DATES                   *\n*  $505  Allow for 128K-offset                                        *\n*  $506  Remove literal from BAL instruction for HLASM R3             *\n*  $507  Merge STRINGXA code, add AR_MODE option                      *\n*        Change syntax of GENERATE call                               *\n***********************************************************************\n         MACRO\n&NAME    STRING &INTO=,&PRINT=NOGEN\n         GBLC  &STRING_MACRO_VERSION\n&STRING_MACRO_VERSION SETC '507'       current version\n         AIF   ('&PRINT' EQ 'NOGEN').NOGEN\n         PUSH  PRINT\n         PRINT GEN\n.NOGEN   GBLA  &$_LIT\n         GBLB  &$_FEAT(16)             FEATURES\n.*                                       1 LITERALS\n.*                                       2 REGISTER (BIN)\n.*                                       3 REGISTER (HEX)\n.*                                       4 PACKED\n.*                                       5 JDATE\n.*                                       6 BINARY\n.*                                       7 HEX\n.*                                       8 NUMERIC\n.*                                       9 LEFT JUST (NUMERIC)\n.*                                       10 LEADING ZEROES\n.*                                       11 TRUNCATE (CHAR STRING)\n.*                                       12 %TIME\n         GBLC  &$_LITS(9999)           LITERALS\n         LCLA  &I,&J,&N\n         AIF   (T'&INTO EQ 'O' AND N'&SYSLIST EQ 1                     X\n               AND '&SYSLIST(1,1)' EQ 'GENERATE').GENL\n&LABEL   SETC  'IHB&SYSNDX'            STEM FOR LOCAL LABELS\n&LQ      SETC  'L'''                   LENGTH ATTRIBUTE\n&STR     SETC  '  R&STRING_MACRO_VERSION'\n&NAME    BAS   R14,$STRING&STR         CALL @STRING SUB-ROUTINE\n         AIF   (N'&SYSLIST EQ 0).ERR1  NO POSITIONAL OPERANDS, ERROR\n         AIF   (T'&INTO EQ 'O').ERR2   NO RECEIVING FIELD, ERROR\n         AIF   (N'&INTO GT 2).ERR2     INTO=(A,32,BLURB)\n         DC    AL2((&LABEL.P-*)/2)     OFFSET TO FIELD DESCRIPTORS\n         AIF   (D'$LITERAL).LOCTR2     NOT FIRST TIME, JUMP\n$LTORG   LOCTR                         ADDRESSABLE CONSTANTS\n$FARRTNE LOCTR                         FAR ROUTINES\n.LOCTR2  ANOP\n$LITERAL LOCTR                         NON-ADDRESSABLE CONSTANTS\n&TO1     SETC  '&INTO(1)'\n&TO2     SETC  '&LQ&INTO'\n         AIF   (N'&INTO EQ 1).PUNTO8            JUMP IF INTO=XXX\n         AIF   ('&INTO(1)'(1,1) NE '(').PUNTO3  JUMP IF INTO=(XXX,44)\n&TO1     SETC  '0&INTO(1)'                              INTO=((R3),44)\n.PUNTO3  ANOP\n&TO2     SETC  '&INTO(2)'                               INTO=(XXX,LL)\n         AIF   ('&INTO(2)'(1,1) NE '(').PUNTO8  JUMP IF INTO=(XXX,44)\n&TO2     SETC  '0&INTO(2)'                              INTO=(XXX,(R1))\n.PUNTO8  ANOP\n&LABEL.P DC    S(&TO1,&TO2)\n.*--------------------------------------------------------------------*\n.*-------      FIELDS       ------------------------------------------*\n.*--------------------------------------------------------------------*\n         LCLB  &LAST,&BIN,&HEX,&REG,&PACKED,&LEFT,&ZERO,&TRUNC\n&I       SETA  1\n.*LOOP\n.LOOP1   ANOP\n         AIF   (N'&SYSLIST(&I) GT 3).FLD990   TOO MANY SUB-OPERANDS\n&LAST    SETB  (&I EQ N'&SYSLIST)                LOOP\n         AIF   ('&SYSLIST(&I)'(1,1) EQ '''').LIT00\n         AIF   ('&SYSLIST(&I)'(K'&SYSLIST(&I),1) EQ '''').LIT01\n.*--------------------------------------------------------------------*\n.*       PROCESS FIRST SUBPARAMETER (ADDRESS)                         *\n.*--------------------------------------------------------------------*\n&P1S     SETC  '&SYSLIST(&I,1)'\n&P2L     SETC  '0'                     INPUT LENGTH\n&P3L     SETC  '0'                     OUTPUT LENGTH\n         AIF   ('&SYSLIST(&I)'(1,1) GE '0').FLD180 SPACES\n         AIF   ('&SYSLIST(&I)' EQ '%TIME').FLD190 %TIME\n         AIF   ('&SYSLIST(&I,1)'(1,1) NE '(').FLD115 (R2)\n         AIF   (T'&SYSLIST(&I,2) EQ 'O').FLD250\n&P1S     SETC  '0&SYSLIST(&I,1)'       CHANGE (R1) TO 0(R1)\n.FLD115  ANOP\n.*\n.*       EXTRACT RBCDE FROM PRB.RBCDE (HLASM)\n.*\n&L       SETA  1\n.*--LOOP\n.FLD131  AIF   ('&P1S'(&L,1) EQ '.').FLD133\n&L       SETA  &L+1\n         AIF   (&L LT K'&P1S).FLD131\n.*--ENDLOOP\n&P2L     SETC  '&P1S'                    ABCDEF FROM ABCDEF\n         AGO   .FLD134\n.FLD133  ANOP\n&P2L     SETC  '&P1S'(&L+1,K'&P1S-&L)    RBCDE FROM PRB.RBCDE\n.FLD134  ANOP\n.*\n         AIF   (T'&SYSLIST(&I,2) NE 'O').FLD200\n.*\n         AIF   (NOT D'&P2L).FLD140\n&P2C     SETC  T'&P2L\n.*MNOTE *,'&P1 &P2C'\n         AIF   ('&P2C' EQ 'F' OR '&P2C' EQ 'H' OR '&P2C' EQ 'P').FLD220\n         AIF   ('&P2C' EQ 'G').FLD210  FL2\n.FLD140  ANOP\n.*\n.*       EXTRACT PSATOLD FROM PSATOLD-PSA\n.*\n&L       SETA  1\n.*--LOOP\n.FLD141  AIF   ('&P2L'(&L,1) EQ '-').FLD143\n         AIF   ('&P2L'(&L,1) EQ '+').FLD143\n&L       SETA  &L+1\n         AIF   (&L LT K'&P2L).FLD141\n.*--ENDLOOP\n&P2L     SETC  '&LQ&P2L'               L'ABCDEF\n         AGO   .FLD300\n.FLD143  ANOP\n&P2L     SETC  '&LQ'.'&P2L'(1,&L-1)    L'PSATOLD FROM PSATOLD-PSA\n         AGO   .FLD300\n.*\n.FLD180  AIF   ('&SYSLIST(&I)'(K'&SYSLIST(&I),1) NE 'X').FLD800\n&P2L     SETC  '&SYSLIST(&I)'(1,K'&SYSLIST(&I)-1) 12\n&J       SETA  X'4000'+&LAST*X'8000'\n         DC    AL2(0,&P2L,&J)          BLANKS\n&$_FEAT(1) SETB 1                      LITERAL\n         AGO   .LIT99\n.*\n.FLD190  ANOP                          %TIME\n&P1S     SETC  '1(14)'                 %TIME\n&$_FEAT(12) SETB 1                     %TIME\n         AGO   .FLD800\n.*--------------------------------------------------------------------*\n.*       PROCESS SECOND SUBPARAMETER (LENGTH/TYPE)                    *\n.*--------------------------------------------------------------------*\n.FLD200  AIF   (T'&SYSLIST(&I,2) EQ 'O').FLD300 NO LENGTH SPECIFIED\n&P2C     SETC  '&SYSLIST(&I,2)'\n         AGO   .FLD220\n.*T'&P1=G\n.FLD210  ANOP\n&L       SETA  L'&SYSLIST(&I)          T'&P1 = 'G'\n&P2C     SETC  'FL&L'                  T'&P1 = 'G'\n.*\n.FLD220  ANOP\n&P2L     SETC  '0&P2C'                 (R2) LENGTH\n         AIF   ('&P2C'(1,1) EQ '(').FLD300\n&P2L     SETC  '&P2C'                  3(R2) LENGTH\n         AIF   ('&P2C'(K'&P2C,1) EQ ')').FLD300\n&P2L     SETC  '0'\n&PACKED  SETB  ('&P2C' EQ 'P')\n         AIF   (&PACKED).FLD300\n&P2L     SETC  '1'\n         AIF   ('&P2C' EQ 'FL1').FLD240\n&P2L     SETC  '3'\n         AIF   ('&P2C' EQ 'FL2' OR '&P2C' EQ 'H').FLD240\n&P2L     SETC  '7'\n         AIF   ('&P2C' EQ 'FL3').FLD240\n&P2L     SETC  '15'\n         AIF   ('&P2C' EQ 'F').FLD240\n&P2L     SETC  '&P2C'                  IMMEDIATE LENGTH, FIELD\n         AGO   .FLD300\n.*\n.FLD240  ANOP                          BINARY VARIABLE\n&BIN     SETB  1\n         AGO   .FLD300\n.*\n.FLD250  ANOP                          REGISTER CONTENT\n&REG     SETB  1\n.*--------------------------------------------------------------------*\n.*       PROCESS THIRD SUBPARAMETER (OUTPUT FORMAT)                   *\n.*--------------------------------------------------------------------*\n.FLD300  AIF   (T'&SYSLIST(&I,3) EQ 'O').FLD800\n&HEX     SETB  ('&SYSLIST(&I,3)' EQ 'X') HEXADECIMAL\n&TRUNC   SETB  ('&SYSLIST(&I,3)' EQ 'T') TRUNCATE\n         AIF   (&HEX OR &TRUNC).FLD800\n.*\n&P3C     SETC  '&SYSLIST(&I,3)'\n&P3L     SETC  '248'\n         AIF   ('&P3C' EQ 'YYYY-MM-DD' AND &PACKED).FLD308\n&P3L     SETC  '249'\n         AIF   ('&P3C' EQ 'YYYYMMDD' AND &PACKED).FLD308\n&P3L     SETC  '250'\n         AIF   ('&P3C' EQ 'YY/MM/DD' AND &PACKED).FLD308\n&P3L     SETC  '251'\n         AIF   ('&P3C' EQ 'DD/MM/YY' AND &PACKED).FLD308\n&P3L     SETC  '252'\n         AIF   ('&P3C' EQ 'MM/DD/YY' AND &PACKED).FLD308\n&P3L     SETC  '253'\n         AIF   ('&P3C' EQ 'YYMMDD'   AND &PACKED).FLD308\n&P3L     SETC  '0'\n         AIF   (T'&SYSLIST(&I,2) NE 'N').FLD310\n         MNOTE 8,'EDIT PATTERN NOT ALLOWED WITH CHARACTER STRING'\n         AGO   .FLD310\n.FLD308  ANOP\n&$_FEAT(5) SETB 1                      JDATE\n         AGO   .FLD800\n.*--LOOP\n.FLD310  AIF   ('&P3C'(1,1) EQ 'R').FLD318       DEFAULT\n         AIF   ('&P3C'(1,1) EQ 'B').FLD318       DEFAULT\n         AIF   ('&P3C'(1,1) NE 'L').FLD311\n&LEFT    SETB  1\n         AGO   .FLD318\n.FLD311  AIF   ('&P3C'(1,1) NE 'Z').FLD312\n&ZERO    SETB  1\n         AGO   .FLD318\n.FLD312  AIF   ('&P3C'(1,1) LT '0').FLD993\n&P3L     SETC  '&P3L'.'&P3C'(1,1)\n.FLD318  ANOP\n.*MNOTE *,'&SYSLIST(&I) P3C=/&P3C/ P3L=/&P3L/'\n&P3C     SETC  '&P3C'(2,K'&P3C-1)     STRIP OFF FIRST CHARACTER\n         AIF   (K'&P3C GT 0).FLD310\n.*--ENDLOOP\n.*--------------------------------------------------------------------*\n.FLD800  ANOP\n&NUMERIC SETB  (&BIN OR &PACKED OR (&REG AND NOT &HEX))\n&TRUNC   SETB  (&TRUNC OR (&LEFT AND NOT &NUMERIC))\n&LEFT    SETB  (&LEFT AND &NUMERIC)\n         AIF   (NOT &NUMERIC).FLD810\n         AIF   (&LEFT OR '&P3L' NE '0').FLD810\n&P3L     SETC  '7'                     DEFAULT OUTPUT LENGTH ((R3))\n         AIF   (&REG).FLD810\n&P3L     SETC  '3'                     DEFAULT OUTPUT LENGTH\n         AIF   ('&P2C' EQ 'FL1').FLD810\n&P3L     SETC  '5'                     DEFAULT OUTPUT LENGTH\n         AIF   ('&P2C' EQ 'H' OR '&P2C' EQ 'FL2').FLD810\n&P3L     SETC  '7'                     DEFAULT OUTPUT LENGTH\n.FLD810  ANOP\n&FLAG    SETA  &LAST*128+&HEX*8+&BIN*4+&PACKED*2+&REG*1\n&LEN2    SETA  &TRUNC*128+&LEFT*128+&ZERO*64+&P3L\n         DC    S(&P1S,&P2L),AL1(&FLAG,&LEN2)\n&$_FEAT(2) SETB (&$_FEAT(2) OR (&REG AND NOT &HEX))   REGISTER (BIN)\n&$_FEAT(3) SETB (&$_FEAT(3) OR (&REG AND &HEX))       REGISTER (HEX)\n&$_FEAT(4) SETB (&$_FEAT(4) OR &PACKED)               PACKED\n&$_FEAT(6) SETB (&$_FEAT(6) OR &BIN)                  BINARY\n&$_FEAT(7) SETB (&$_FEAT(7) OR (&HEX AND NOT &REG))   HEX\n&$_FEAT(8) SETB (&$_FEAT(8) OR &NUMERIC)              BIN,PACKED\n&$_FEAT(9) SETB (&$_FEAT(9) OR (&LEFT AND &NUMERIC))\n&$_FEAT(10) SETB (&$_FEAT(10) OR &ZERO)\n&$_FEAT(11) SETB (&$_FEAT(11) OR &TRUNC)\n&BIN     SETB  0                    RESET FLAGS\n&HEX     SETB  0                    RESET FLAGS\n&REG     SETB  0                    RESET FLAGS\n&PACKED  SETB  0                    RESET FLAGS\n&LEFT    SETB  0                    RESET FLAGS\n&ZERO    SETB  0                    RESET FLAGS\n&TRUNC   SETB  0                    RESET FLAGS\n         AGO   .LIT99\n.FLD990  MNOTE 12,'OPERAND &I HAS TOO MANY SUB-OPERANDS'\n         AGO   .LIT99\n.FLD993  MNOTE 8,'THIRD SUBPARAMETER IS INVALID: ''&SYSLIST(&I,3)'''\n         AGO   .LIT99\n.*--------------------------------------------------------------------*\n.*------------ LITERALS ----------------------------------------------*\n.*--------------------------------------------------------------------*\n.LIT00   ANOP\n&LIT     SETC  'C&SYSLIST(&I)'\n         AGO   .LIT09\n.LIT01   ANOP\n&LIT     SETC  '&SYSLIST(&I)'\n.LIT09   AIF   (&$_LIT EQ 0).LIT50\n&N       SETA  1\n         ACTR  &$_LIT*3+200\n.LIT10   AIF   (&N GT &$_LIT).LIT50                  LOOP\n&L       SETA  &N+1000                               LOOP\n         AIF   ('&LIT' EQ '&$_LITS(&N)').LIT80 LOOP\n&N       SETA  &N+1                                  LOOP\n         AGO   .LIT10                                LOOP\n.LIT50   ANOP\n&$_LIT   SETA  &$_LIT+1\n&$_LITS(&$_LIT) SETC '&LIT'\n&L       SETA  &$_LIT+1000\n.LIT80   ANOP\n&J       SETA  X'4000'+&LAST*X'8000'\n         DC    AL2($LIT&L-*,&LQ.$LIT&L,&J)\n&$_FEAT(1) SETB 1                      LITERAL\n.LIT99   ANOP\n.*--------------------------------------------------------------------*\n&I       SETA  1+&I                              LOOP\n         AIF   (&I LE N'&SYSLIST).LOOP1          LOOP\n.*ENDLOOP\n&SYSLOC  LOCTR\n         AGO   .MEND\n.ERR1    MNOTE 12,'AT LEAST ONE INPUT FIELD MUST BE SPECIFIED'\n         AGO   .MEND\n.ERR2    MNOTE 12,'INVALID OUTPUT AREA SPECIFICATION'\n         AGO   .MEND\n.**********************************************************************\n.*       GENERATE: GENERATE LITERALS AND PROCESSING ROUTINE           *\n.**********************************************************************\n.GENL    ANOP\n         AIF   (N'&SYSLIST(1) GT 3).GENL1R\n&OPT2    SETC  '&SYSLIST(1,2)'\n         AIF   ('&OPT2' NE '' AND '&OPT2' NE 'AR_MODE'                 X\n               AND '&OPT2' NE 'NO_CSECT').GENL1R\n&OPT3    SETC  '&SYSLIST(1,3)'\n         AIF   ('&OPT3' NE '' AND '&OPT3' NE 'LOCTR').GENL1R\n         AIF   ('&OPT2' EQ 'NO_CSECT' AND '&OPT3' EQ 'LOCTR').GENL1R\n         AGO   .GENL1D\n.GENL1R  MNOTE 12,'Invalid GENERATE options, default used'\n&OPT2    SETC  ''\n&OPT3    SETC  ''\n.GENL1D  ANOP\n&STRBLANKS SETA 2\n         AIF   (D'$LTORG).GENL1F             CSECT-ONLY\n&$_FEAT(1) SETB 1,1,1,1,1,1,1,1,1,1,1,1\n.GENL1F  ANOP\n&ALLFEAT SETC  '&$_FEAT(1)&$_FEAT(2)&$_FEAT(3)&$_FEAT(4)'\n&ALLFEAT SETC  '&ALLFEAT&$_FEAT(5)&$_FEAT(7)&$_FEAT(6)&$_FEAT(8)'\n&ALLFEAT SETC  '&ALLFEAT&$_FEAT(9)&$_FEAT(10)&$_FEAT(11)&$_FEAT(12)'\n&STR     SETC  '&STRING_MACRO_VERSION'\n         MNOTE *,'STRING R&STR - FEATURES GENERATED: &ALLFEAT'\n         AIF   (&$_LIT EQ 0).GENL3\n$LITERAL LOCTR\n.GENL2   ANOP                                LOOP\n&N       SETA  &N+1                          LOOP\n&I       SETA  &N+1000                       LOOP\n$LIT&I   DC    &$_LITS(&N)\n         AIF   (&N LT &$_LIT).GENL2          LOOP\n.GENL3   ANOP\n         AIF   ('&OPT2' EQ 'NO_CSECT').GENL8\n&ARMODE  SETB  ('&OPT2' EQ 'AR_MODE')\n.**********************************************************************\n.*                                                                    *\n.*       STRING SUB-ROUTINE                                           *\n.*                                                                    *\n.*             CAUTION: BYTES 49-72 OF THE CALLER'S SAVE AREA         *\n.*                      (R7-R12 SLOTS) ARE USED AS WORK SPACE         *\n.*                                                                    *\n.**********************************************************************\n         AIF   ('&OPT3' EQ 'LOCTR').GENL4L\n@STRING  CSECT\n@STRING  RMODE ANY\n         AGO   .GENL4X\n.GENL4L  PUSH  USING                   GENERATE,LOCTR\n         DROP\n@STRING@ LOCTR\n@STRING  DS    0H                      ALIGNMENT\n.GENL4X  ANOP\n@00      EQU   0                       WORK REGISTER\n@01      EQU   1                       WORK REGISTER\n@02      EQU   2                       WORK REGISTER\n@03      EQU   3                       WORK REGISTER\n@04      EQU   4                       WORK REGISTER\n@05      EQU   5                       WORK REGISTER\n@06      EQU   6                       WORK REGISTER\n         AIF   (NOT &ARMODE).ARMODE1N\n@07      EQU   7                       WORK REGISTER\n@08      EQU   8                       WORK REGISTER\n@09      EQU   9                       WORK REGISTER\n@10      EQU   10                      WORK REGISTER\n@11      EQU   11                      WORK REGISTER\n@12      EQU   12                      WORK REGISTER\n@13      EQU   13                      CALLER'S SAVE AREA\n@14      EQU   14                      WORK REGISTER\n@15      EQU   15                      BASE REG\n         USING @STRING,@15\n         USING @STRSAVE,@13\n         B     @STR003                 BRANCH AROUND EYE-CATCHER\n         DC    C'@STRING/390 R&STRING_MACRO_VERSION &ALLFEAT',0H'0'\n@STR002  DC    H'2'\n@STR003  STM   @14,@12,12(@13)         SAVE REGS (DEBUGGING ONLY)\n         AH    @14,@STR002-@STRING(@15) POINT PARM PARM-LIST OFFSET\n         BAKR  @14,0                   SAVE REGS AND RETURN ADDRESS\n         BCTR  @14,0                   ADJUST ADDR OF PARM LIST OFFSET\n         BCTR  @14,0                   ADJUST ADDR OF PARM LIST OFFSET\n         LAE   @06,0                   R6=0 AR6=0\n         CPYA  @14,@06                 AR14=0\n         CPYA  @15,@06                 AR15=0\n&LAE     SETC  'LAE'\n         AGO   .ARMODE1X\n.ARMODE1N ANOP\n@13      EQU   13                      CALLER'S SAVE AREA\n@14      EQU   14                      WORK REGISTER\n@15      EQU   15                      BASE REG\n&LAE     SETC  'LA'\n         SAVE  (14,6),,'@STRING/370 R&STRING_MACRO_VERSION &ALLFEAT'\n         USING @STRING,@15\n         USING @STRSAVE,@13\n         SLR   @06,@06                 R6=0\n.ARMODE1X ANOP\n         ICM   @06,B'0011',0(@14)      PICK UP PARM-LIST 1/2 OFFSET\n         ALR   @06,@06                 PICK UP PARM-LIST OFFSET\n         ALR   @06,@14                 R6 NOW POINTS TO PARM LIST\n         USING @STRPARM,@06\n         &LAE  @02,@STRSCON            RESOLVE FIRST SCON (ADDR)\n         BAL   @14,@STRS2A             GET ADDRESS IN R2\n         &LAE  @04,0(,@02)             KEEP ADDRESS OF \"INTO\" FIELD\n         L     @14,12(,@13)            RESTORE ADDR OF STRING MACRO\n         OI    0(@04),0                GET CLEAN S0C4 IF ADDRESS IS BAD\n         &LAE  @02,@STRFLEN            RESOLVE SECOND S-CON (LEN)\n         BAL   @14,@STRS2A             GET LENGTH IN R2\n         LR    @05,@02                 KEEP LENGTH OF \"INTO\" FIELD\n         CR    @05,@04                 END ADDRESS?\n         BL    @STR282                 NO, JUMP\n         SR    @05,@04                 CALCULATE LENGTH\n         AIF   (NOT &ARMODE).ARMODE5N\n@STR282  MSTA  @04                     SAVE R4,R5 ON LINKAGE STACK\n.*SLAC   DC    X'B247,0040'            SLAC assembler error\n         AGO   .ARMODE5X\n.ARMODE5N ANOP\n@STR282  ST    @04,8(,@13)             SAVE ADDRESS FOR LATER\n.ARMODE5X ANOP\n.**********************************************************************\n.*       MOVE FIELDS TO OUTPUT AREA                                   *\n.**********************************************************************\n         &LAE  @06,@STRFLAG            POINT TO 1ST FIELD DESC\n.*LOOP\n@STR310  EQU   *\n         AIF   (NOT &$_FEAT(1)).FEAT1A\n         TM    @STRFLAG,@STRLIT        IS THIS A LITERAL?\n         BO    @STR372                 YES, JUMP\n.FEAT1A  ANOP\n         AIF   (NOT &$_FEAT(2) AND NOT &$_FEAT(3)).FEAT23A\n         TM    @STRFLAG,@STRREG        REGISTER?\n         BO    @STR323                 YES, JUMP\n.FEAT23A ANOP\n         AIF   (NOT &$_FEAT(12)).FEAT12A\n         CLI   @STRSCON,X'E0'          IS IT %TIME ?\n         BE    @STR378                 YES, JUMP\n.FEAT12A ANOP\n.*\n.*       IT'S A FIELD (SCON)\n.*\n         &LAE  @02,@STRFLEN            RESOLVE SECOND S-CON (LEN)\n         BAL   @14,@STRS2A             GET LENGTH IN R2\n         AIF   (&$_FEAT(9)).FEAT9E1    (LEFT JUSTIFICATION, NUMERIC)\n         LTR   @03,@02                 KEEP/TEST LENGTH\n         BZ    @STR398                 ZERO LENGTH, DO NOT EDIT\n         AGO   .FEAT9E2\n.FEAT9E1 LTR   @03,@02                 KEEP/TEST LENGTH\n         BP    @STR313                 LENGTH POSITIVE, JUMP\n         TM    @STRLEN2,@STRLEFT       LEFT JUSTIFICATION?\n         BNO   @STR398                 NO, ZERO LENGTH IS NOT OK\n@STR313  EQU   *\n.FEAT9E2 ANOP\n         &LAE  @02,@STRSCON            RESOLVE FIRST SCON (ADDR)\n         BAL   @14,@STRS2A             GET ADDRESS IN R2\n         L     @14,12(,@13)            RESTORE ADDR OF STRING MACRO\n         CLI   0(@02),0                GET CLEAN S0C4 IF ADDRESS IS BAD\n         CR    @03,@02                 END ADDRESS?\n         BL    @STR314                 NO, JUMP\n         LA    @00,X'0080'             PSA ADDRESS\n         CLR   @02,@00                 PSA REFERENCE?\n         BL    @STR314                 YES, JUMP\n         SR    @03,@02                 CALCULATE LENGTH\n@STR314  EQU   *\n         AIF   (NOT &$_FEAT(6)).FEAT6A\n         TM    @STRFLAG,@STRBIN        BINARY FIELD?\n         BO    @STR328                 YES, JUMP\n.FEAT6A  ANOP\n         AIF   (NOT &$_FEAT(4)).FEAT4A\n         TM    @STRFLAG,@STRPACK       PACKED FIELD?\n         BO    @STR351                 YES, JUMP\n.FEAT4A  ANOP\n         AIF   (NOT &$_FEAT(7)).FEAT7A\n         TM    @STRFLAG,@STRHEX        EDIT IN HEX?\n         BO    @STR376                 YES, JUMP\n.FEAT7A  ANOP\n.*\n.*       TRUNCATE CHARACTER STRING\n.*\n         AIF   (NOT &$_FEAT(11)).FEAT11A\n         CLI   @STRLEN2,@STRLEFT       CHECK JUSTIFICATION, OUTPUT LEN\n         BNE   @STR390                 NO STRING TRUNCATION, JUMP\n         &LAE  @01,0(@03,@02)          FIRST BYTE AFTER FIELD\n@STR318  BCTR  @01,0                   DOWN 1 BYTE                 LOOP\n         CLI   0(@01),C' '             IS IT A SPACE ?             LOOP\n         BNE   @STR390                 LAST NON-BLANK BYTE         LOOP\n         BCT   @03,@STR318             LOOP UNTIL 1ST NON-BLANK    LOOP\n         B     @STR398                 BLANK FIELD, DO NOT EDIT\n         AGO   .FEAT11B\n.FEAT11A ANOP\n         AIF (&$_FEAT(2)+&$_FEAT(3)+&$_FEAT(4)+&$_FEAT(6) EQ 0).FEAT11B\n         B     @STR390                 EDIT\n.FEAT11B ANOP\n.*\n.*       REGISTER (R0-R13)\n.*\n         AIF   (NOT &$_FEAT(2) AND NOT &$_FEAT(3)).FEAT23B\n         AIF   (NOT &ARMODE).ARMODE7N\n@STR323  LH    @01,@STRSCON            REG NUMBER IN BITS 28-31\n         CLI   @STRSCON+1,@06          IS THIS R7-R13?\n         BH    @STR323R                YES, JUMP\n         LR    @07,@01                 SAVE R1 (R)\n         LAE   @10,0(,@04)             SAVE R4\n         LR    @11,@05                 SAVE R5\n         LAE   @12,0(,@06)             SAVE R6\n         EREG  @00,@06                 RELOAD CALLER'S R0-R6\n         EX    @07,@STR323L            COPY R0-R6 VALUE\n         LAE   @04,0(,@10)             RESTORE R4\n         LR    @05,@11                 RESTORE R5\n         LAE   @06,0(,@12)             RESTORE R6\n         B     @STR323T\n@STR323L LR    @00,*-*                 COPY VALUE FOR EDIT\n@STR323R EQU   *\n         EREG  @07,@12                 RESTORE CALLER'S R7-R12\n         EX    @01,@STR323L            COPY R7-R13 INTO R0\n         AGO   .ARMODE7X\n.ARMODE7N ANOP\n@STR323L LR    @00,*-*                 COPY VALUE FOR EDIT\n@STR323  LH    @01,@STRSCON            REG NUMBER IN BITS 28-31\n         EX    @01,@STR323L            COPY R7-R13 INTO R0\n         CLI   @STRSCON+1,@06+1        IS THIS R7-R13?\n         BNL   @STR323T                YES, JUMP\n         SLL   @01,2                   R1= 000000BB BASE * 4\n         L     @00,20(@01,@13)         PICK UP VALUE FOR R0-R6\n.ARMODE7X ANOP\n@STR323T EQU   *\n         AIF   (NOT &$_FEAT(3)).FEAT3R REG,HEX\n         AIF   (NOT &$_FEAT(2)).FEAT2H REG,BIN\n         TM    @STRFLAG,@STRHEX        EDIT IN HEX?\n         BNO   @STR330                 NO, EDIT FWD\n.FEAT2H  ANOP\n         STCM  @00,B'1111',@STRDWD-1   STORE IT FOR CVD/UNPK\n         LA    @03,8                   OUTPUT LENGTH\n         B     @STR376X                EDIT IN HEX\n.FEAT3R  ANOP\n         AIF   (NOT &$_FEAT(6)).FEAT23B\n         B     @STR330                 EDIT R0\n.FEAT23B ANOP\n.*\n.*       BINARY VARIABLE: @03 CONTAINS THE ICM MASK (1 3 7 F)\n.*\n         AIF   (NOT &$_FEAT(6)).FEAT6B\n@STR328M ICM   @00,*-*,0(@02)          **EXECUTED INSTRUCTION**\n@STR328  SLR   @00,@00\n         EX    @03,@STR328M            LOAD THE BINARY VARIABLE\n.FEAT6B  ANOP\n.*\n         AIF   (NOT &$_FEAT(2) AND NOT &$_FEAT(6)).FEAT6C\n@STR330  CVD   @00,@STRDWD             CONVERT VALUE TO DECIMAL\n         AIF   (NOT &$_FEAT(4)).FEAT6C\n         B     @STR361                 EDIT DWD\n.FEAT6C  ANOP\n.*\n.*       PACKED FIELD\n.*\n         AIF   (NOT &$_FEAT(4)).FEAT4B\n@STRZAP  ZAP   @STRDWD,0(*-*,@02)      MOVE TO @STRDWD\n@STR351  &LAE  @03,0(,@02)             FIRST BYTE OF PACKED FIELD\n         BALR  @14,0\n         TM    0(@03),X'0C'            IS THIS THE SIGN BYTE?\n         LA    @03,1(,@03)              (NEXT BYTE)\n         BNOR  @14                     NO, LOOP MORE\n         SLR   @03,@02                 GET LENGTH OF PACKED FIELD\n         BCTR  @03,0\n         EX    @03,@STRZAP             EXECUTE ZAP\n         AIF   (NOT &$_FEAT(5)).FEAT4B\n         CLI   @STRLEN2,248            JULIAN-TO-YYMMDD CONV?\n         BNL   @STR375                 YES, JUMP\n.FEAT4B  ANOP                          PACKED\n.*\n.*       EDIT @STRDWD (BIN, REG, PACKED)\n.*\n         AIF   (NOT &$_FEAT(8)).FEAT8B\n@STR361  IC    @00,@STRLEN2            OUTPUT LENGTH\n         LA    @03,X'003F'             MASK FOR \"AND\"\n         NR    @03,@00                 OUTPUT LENGTH\n         MVC   @STRWK16(16),@STRMASK   EDIT MASK\n.*\n.*       LEFT-JUSTIFICATION (NUMERIC)\n.*\n         AIF   (NOT &$_FEAT(9)).FEAT9B\n         TM    @STRLEN2,@STRLEFT       LEFT JUSTIFICATION?\n         BNO   @STR367                 NO, JUMP\n         &LAE  @01,@STRWK16+15         PREVENT BAD R1\n         EDMK  @STRWK16(16),@STRDWD    ZONED DECIMAL\n         &LAE  @02,0(,@01)             FIRST STRING POSITION\n         LTR   @03,@03                 CHECK OUTPUT LENGTH\n         BNZ   @STR363                 JUMP IF NOT ZERO\n.*       L0    (LEFT JUSTIFIED, NO PADDING)\n         &LAE  @03,@STRWK16+16         FIRST POSITION AFTER STRING\n         SR    @03,@02                 COMPUTE STRING LENGTH\n         B     @STR390                 MOVE FIELD TO OUTPUT LINE\n.*       L1-L63 (LEFT JUSTIFIED, PADDING)\n@STR363  CR    @03,@05                 COMPARE LENGTH TO REMAINING LEN\n         BNH   @STR364                 LARGE ENOUGH, JUMP\n         LR    @03,@05                 TOO BIG, TRUNCATE TO REM. LEN.\n@STR364  SR    @05,@03                 COMPUTE REMAINING LENGTH\n         AIF   (NOT &ARMODE).ARMODE8N\n         LAE   @08,0(,@04)             POINTER IN OUTPUT LINE\n         LR    @09,@03                 LENGTH WITH PADDING\n         AGO   .ARMODE8X\n.ARMODE8N ANOP\n         LR    @00,@04                 POINTER IN OUTPUT LINE\n         LR    @01,@03                 LENGTH WITH PADDING\n.ARMODE8X ANOP\n         LA    @03,@STRWK16+16         FIRST POSITION AFTER STRING\n         SR    @03,@02                 COMPUTE STRING LENGTH\n         B     @STR392                 MOVE FIELD TO OUTPUT LINE\n@STR367  EQU   *\n.FEAT9B  ANOP\n         AIF   (NOT &$_FEAT(10)).FEAT10B\n         TM    @STRLEN2,@STRZERO       LEADING ZEROES REQ'D?\n         BNO   @STR368                 NO, JUMP\n         MVI   @STRWK16,C'0'           YES, CHANGE X'40' TO C'0'\n@STR368  EQU   *\n.FEAT10B ANOP\n         ED    @STRWK16(16),@STRDWD    ZONED DECIMAL\n         &LAE  @02,@STRWK16+16         FIRST POSITION AFTER STRING\n         SR    @02,@03                 FIRST STRING POSITION\n.FEAT8B  ANOP\n.*\n.*       LITERAL (@STRSCON IS A 16-BIT OFFSET)\n.*       BLANKS  (@STRSCON=ZERO)\n.*\n         AIF   (NOT &$_FEAT(1)).FEAT1B\n         B     @STR390                 MOVE STRING TO OUTPUT LINE\n@STR372  &LAE  @02,0                   R2=0,AR2=0\n         ICM   @02,B'0011',@STRSCON    LOAD LITERAL OFFSET\n         BZ    @STR372L                BLANKS, JUMP\n         LA    @02,@STRSCON(@02)       CONVERT OFFSET TO FULL ADDRESS\n@STR372L LH    @03,@STRFLEN            GET LITERAL LENGTH\n.FEAT1B  ANOP\n.*\n.*       CONVERT JULIAN DATE TO YYMMDD\n.*\n         AIF   (NOT &$_FEAT(5)).FEAT5F\n         B     @STR390                 MOVE STRING TO OUTPUT LINE\n@STR375  LA    @00,248                 MASK FOR 'SLR'\n         SLR   @01,@01\n         IC    @01,@STRLEN2            248-255\n         SLR   @01,@00                 000-007\n         LA    @00,12                  L'@STR375W\n         MR    @00,@00                 COMPUTE OFFSET\n         &LAE  @01,@STR375W(@01)       ENTRY IN \"TR\" MASK TABLE\n         SLR   @03,@03\n         IC    @03,0(,@01)             LENGTH OF DATE (6, 8 OR 10)\n         ZAP   @STRDWD,@STRDWD         DATE=0000000?               @JDT\n         BNZ   @STR375B                NO, JUMP                    @JDT\n@STR375Z &LAE  @02,@STRBLANKS          WORK AREA\n&STRBLANKS SETA 10                     WE NEED AT LEAST 10 BLANKS\n         B     @STR390                 MOVE FIELD TO OUTPUT LINE\n@STR375W DC    AL1(10,C'-',0,1,2,3,8,4,5,8,6,7) YYYY-MM-DD   248\n         DC    AL1(8,C' ',0,1,2,3,4,5,6,7,8,8)  YYYYMMDD//   249\n         DC    AL1(8,C'/',2,3,8,4,5,8,6,7,8,8)  YY/MM/DD//   250\n         DC    AL1(8,C'/',6,7,8,4,5,8,2,3,8,8)  DD/MM/YY//   251\n         DC    AL1(8,C'/',4,5,8,6,7,8,2,3,8,8)  MM/DD/YY//   252\n         DC    AL1(6,C' ',2,3,4,5,6,7,8,8,8,8)  YYMMDD       253\n.*       DC    AL1(6,C' ',6,7,4,5,2,3,8,8,8,8)  DDMMYY       254\n.*       DC    AL1(6,C' ',4,5,6,7,2,3,8,8,8,8)  MMDDYY       255\n@STR375T DC    P'59,31,29,31,30,31,30,31,31,30,31,30,31'\n@STR375B CLI   @STRDWD+4,X'01'         YEAR 2000 OR ABOVE?\n         BH    @STR375C                CC>01, JUMP (MUST BE 19 OR 20)\n         MVI   @STRDWD+4,X'20'         CC=01, CHANGE TO CC=20\n         BE    @STR375C                CC=01, USE CC=20\n         CLI   @STRDWD+4+1,X'50'       YY<50?\n         BL    @STR375C                YES, USE CC=20\n         MVI   @STRDWD+4,X'19'         NO, FORCE CC=19\n@STR375C UNPK  @STRWK16(5),@STRDWD+4(3) CCYY?\n         ZAP   @STRDWD+1(2),@STR375T+9(1) INIT MONTH COUNTER\n         &LAE  @02,@STR375T            TABLE OF MONTHS (NUMBER OF DAYS)\n         TM    @STRDWD+4+1,X'01'       ODD YEARS\n         BO    @STR375N                  AREN'T LEAP YEARS\n         TM    @STRDWD+4+1,X'12'       ZEROES IN 1980, ALL ONES IN 1992\n         BNM   @STR375L                MIXED IN 1982/1990\n.*       IF IT'S NOT A LEAP YEAR AND DDD>59, THEN ADD 1 TO DDD\n@STR375N CP    @STRDWD+4+2(2),@STR375T ARE WE PAST FEB 28 (DDD>59) ?\n         BNH   @STR375L                NO, JUMP\n         AP    @STRDWD+4+2(2),@STR375T+3(1) ADD 1 (FROM 31) TO DDD\n.*--LOOP WHILE DDD > 0\n@STR375L AP    @STRDWD+1(2),@STR375T+3(1)   ADD 1 (FROM 31) TO MONTH\n         LA    @02,2(,@02)             NEXT ENTRY IN \"MONTHS\" TABLE\n         SP    @STRDWD+4+2(2),0(2,@02) SUB DAYS-IN-MONTH FROM DDD\n         BP    @STR375L\n.*--ENDLOOP\n         AP    @STRDWD+4+2(2),0(2,@02) UNDO LAST \"SP\" INSTRUCTION\n         UNPK  @STRWK16+4(2),@STRDWD+1(2) FYFYFYFY,FMCM??\n         UNPK  @STRWK16+6(2),@STRDWD+6(2) FYFYFYFY,FMCMFDCD\n         MVZ   @STRWK16+1(7),@STRWK16     FYFYFYFY,FMCMFDCD\n         MVC   @STRWK16+8(1),1(@01)    SEPARATOR\n         &LAE  @02,@STRWK16+9          WORK AREA\n         MVC   0(10,@02),2(@01)        MOVE CORRESPONDING MASK\n         TR    0(10,@02),@STRWK16      CONVERT DATE TO THE RIGHT FORMAT\n.FEAT5F  ANOP                          JDATE\n.*\n.*       HEX STRING\n.*\n         AIF   (NOT &$_FEAT(7)).FEAT7B\n         B     @STR390                 MOVE STRING TO OUTPUT LINE\n@STR376M MVC   @STRDWD-1(*-*),0(@02)   PREVENT S0C4 IN UNPK\n@STR376  LA    @00,8                   MAX LENGTH\n         CLR   @03,@00                 CHECK LENGTH\n         BNH   @STR376B                JUMP IF LE 8\n         LR    @03,@00                 TRUNCATE TO MAXIMUM LENGTH\n@STR376B LR    @01,@03                 INPUT LENGTH\n         BCTR  @01,0\n         EX    @01,@STR376M            MOVE DATA TO SAFE STORAGE\n         ALR   @03,@03                 OUTPUT LENGTH\n         AGO   .FEAT37B\n.FEAT7B  ANOP\n         AIF   (NOT &$_FEAT(3)).FEAT37C\n         B     @STR390                 MOVE STRING TO OUTPUT LINE\n.FEAT37B ANOP\n@STR376X &LAE  @02,@STRWK16            WORK AREA\n         UNPK  0(9,@02),@STRDWD-1(5)   EXPAND SOURCE BYTES FOR \"TR\"\n         UNPK  8(9,@02),@STRDWD+3(5)   EXPAND SOURCE BYTES FOR \"TR\"\n         TR    0(16,@02),@STRHEXT-240  =C'0123456789ABCDEF'\n.FEAT37C ANOP\n.*\n.*       %TIME\n.*\n         AIF   (NOT &$_FEAT(12)).FEAT12B\n         B     @STR390                 MOVE STRING TO OUTPUT LINE\n@STRTIME DC    X'4021207A20207A20207A20204000'    0X.XX.XX.XX\n@STR378  LR    @02,@15                 SAVE BASE REG\n         TIME  DEC                     GET HHMMSSHH\n         LR    @15,@02                 RESTORE BASE REG\n         ST    @00,@STRDWD             STORE HHMMSSHH\n         MVC   @STRWK16(13),@STRTIME   MOVE EDIT MASK\n         ED    @STRWK16(13),@STRDWD    EDIT HH:MM:SS:HH\n         &LAE  @02,@STRWK16+1          WORK AREA\n         LA    @03,12                  HH:MM:SS:HH+ SPACE\n.FEAT12B ANOP\n.*MOVE\n@STR390  CR    @03,@05                 COMPARE LENGTH TO REMAINING LEN\n         BNH   @STR391                 LARGE ENOUGH, JUMP\n         LR    @03,@05                 TOO BIG, TRUNCATE TO REM. LEN.\n@STR391  SR    @05,@03                 COMPUTE REMAINING LENGTH\n         AIF   (NOT &ARMODE).ARMODE39N\n         LAE   @08,0(,@04)             POINTER IN OUTPUT LINE\n         LR    @09,@03                 PASS REMAINING LENGTH\n         AGO   .ARMODE39X\n.ARMODE39N ANOP\n         LR    @00,@04                 POINTER IN OUTPUT LINE\n         LR    @01,@03                 PASS REMAINING LENGTH\n.ARMODE39X ANOP\n         LTR   @02,@02                 BLANKS?\n         BNZ   @STR392                 NO, JUMP\n         SLR   @03,@03                 YES, ZERO LENGTH\n@STR392  ICM   @03,B'1000',@STRBLANKS  PAD WITH BLANKS\n         AIF   (NOT &ARMODE).ARMODE44N\n         MVCL  @08,@02                 MOVE FIELD TO OUTPUT LINE\n         LR    @04,@08                 NEW POINTER IN OUTPUT LINE\n         AGO   .ARMODE44X\n.ARMODE44N ANOP\n         MVCL  @00,@02                 MOVE FIELD TO OUTPUT LINE\n         LR    @04,@00                 NEW POINTER IN OUTPUT LINE\n.ARMODE44X ANOP\n@STR398  TM    @STRFLAG,@STRLAST       TEST LAST-ENTRY INDICATOR\n         LA    @06,@STRNEXT            BUMP UP TO NEXT ENTRY\n         BNO   @STR310                 PROCESS NEXT ENTRY\n.*ENDLOOP\n.*\n.*       END-OF-LINE PROCESSING - PAD WITH BLANKS\n.*\n         SLR   @01,@01                 SET UP R1 FOR PADDING\n         ICM   @01,B'1000',@STRBLANKS  SET UP R1 FOR PADDING\n         AIF   (NOT &ARMODE).ARMODE52N\n.***     DROP  @06,@13,@15\n         LA    @15,3                   MODIFIABLE AREA\n         ESTA  @14,@15                 R14 = START OF OUTPUT AREA\n         LR    @15,@04                 END OF OUTPUT AREA\n         SR    @15,@14                 R15 = LENGTH USED IN OUTPUT AREA\n         MVCL  @04,@00                 PAD WITH BLANKS\n         EREG  @00,@14                 RESTORE WORK REGISTERS\n         STM   @14,@12,12(@13)         MAKE SAVE AREA LOOK NORMAL\n         OI    15(@13),1               SIMULATE \"T\" OPTION OF RETURN\n         PR                            RETURN TO CALLER\n         AGO   .ARMODE52X\n.ARMODE52N ANOP\n         LA    @14,2                   INCREMENT\n         AL    @14,12(,@13)            RETURN ADDRESS\n         SLR   @01,@01                 SET UP R1 FOR PADDING\n         ICM   @01,B'1000',@STRBLANKS  SET UP R1 FOR PADDING\n         LR    @15,@04                 CURRENT POINTER IN OUTPUT FIELD\n         SL    @15,8(,@13)             CALCULATE LENGTH USED\n         MVCL  @04,@00                 PAD WITH BLANKS\n         LM    @00,@06,20(@13)         RESTORE WORK REGISTERS\n         STM   @06+1,@13-1,48(@13)     MAKE SAVE AREA LOOK NORMAL\n         OI    15(@13),1               SIMULATE \"T\" OPTION OF RETURN\n         BR    @14                     RETURN TO CALLER\n.ARMODE52X ANOP\n.*\n         AIF   (NOT (&$_FEAT(3) OR &$_FEAT(7))).FEAT37T\n@STRHEXT DC    C'0123456789ABCDEF'     HEX-TO-EBCDIC CONVERSION\n.FEAT37T ANOP\n         AIF   (NOT &$_FEAT(8)).FEAT8T\n@STRMASK DC    X'4020202020202020,2020202020202120'\n.FEAT8T  ANOP\n.**********************************************************************\n.*       CONVERT S-CON TO 31-BIT ADDRESS (RESULT RETURNED IN R2)      *\n.**********************************************************************\n@STRS2A  SLR   @00,@00\n         ICM   @00,B'0011',0(@02)      R0 = 0000BDDD\n         SRDL  @00,12                  R0 = 0000000B, R1= DDD.....\n         SRL   @01,20                  R1 = 00000DDD (DISPLACEMENT)\n         AIF   (NOT &ARMODE).ARMODE88N\n         SLL   @00,2                   MULT BY 4\n         CLI   0(@02),@07*16           R7-R13?\n         BNL   @STRS2A7                YES, JUMP\n.*BASE REG IS R0-R6\n@STRS2A4 LTR   @02,@00                 IS R0 THE BASE REG?\n         BNZ   @STRS2A5                NO, JUMP\n         LTR   @02,@01                 IS THIS A PSA ADDRESS?\n         BNZR  @14                     YES, GOBACK\n         EREG  @00,@00                 POP R0\n         LAE   @02,0                   R2=0 AR2=0\n         LR    @02,@00                 PASS R0 VALUE\n         LA    @02,0(,@02)             CLEAN UP\n         BR    @14                     GOBACK\n@STRS2A5 LR    @07,@00                 SAVE R0 (B*4)\n         LR    @08,@01                 SAVE R1 (DDD)\n         LR    @09,@03                 SAVE R3\n         LAE   @10,0(,@04)             SAVE R4\n         LR    @11,@05                 SAVE R5\n         LAE   @12,0(,@06)             SAVE R6\n         EREG  @01,@06                 RELOAD CALLER'S R1-R6\n         EX    0,@STRS2A9-4(@07)       ADD BASE REG VALUE TO DISPL\n         LR    @03,@09                 RESTORE R3\n         LAE   @04,0(,@10)             RESTORE R4\n         LR    @05,@11                 RESTORE R5\n         LAE   @06,0(,@12)             RESTORE R6\n         BR    @14                     GOBACK\n.*BASE REG IS R7-R13\n@STRS2A7 LR    @02,@00                 R2= 0000000B (BASE REG NUMBER)\n         EREG  @07,@12                 RESTORE CALLER'S R7-R12\n         EX    0,@STRS2A9-4(@02)       ADD BASE REG VALUE TO DISPL\n         BR    @14                     GOBACK\n@STRS2A9 LAE   @02,0(@08,@01)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@08,@02)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@08,@03)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@08,@04)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@08,@05)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@08,@06)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@07)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@08)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@09)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@10)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@11)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@12)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@13)          ADD BASE REG VALUE TO DISPL\n         AGO   .ARMODE88X\n.ARMODE88N ANOP\n         CLI   0(@02),(@06+1)*16       R7-R13?\n         BL    @STRS2A5                NO, JUMP\n.*BASE REG IS R7-R13\n         LR    @02,@00                 R2= 0000000B (BASE REG NUMBER)\n         EX    @02,@STRS2A4            ADD BASE REG VALUE TO DISPL\n         B     @STRS2A7                CLEAN UP ADDRESS\n@STRS2A4 LA    @02,0(*-*,@01)          ADD BASE REG VALUE TO DISPL\n.*BASE REG IS R0-R6\n@STRS2A5 LTR   @02,@00                 IS R0 THE BASE REG?\n         BNZ   @STRS2A6                NO, JUMP\n         LTR   @02,@01                 IS THIS A PSA ADDRESS?\n         BNZR  @14                     YES, GOBACK\n@STRS2A6 SLL   @02,2                   R2= 000000BB BASE * 4\n         L     @02,20(@02,@13)         PICK UP BASE REG VALUE\n         LA    @02,0(@02,@01)          ADD BASE REG VALUE TO DISPL\n.*CLEAN UP R2 BASED ON CALLER'S AMODE\n@STRS2A7 TM    12(@13),X'80'           CALLER'S IN AMODE31?\n         BOR   @14                     YES, GOBACK\n         ICM   @02,B'1000',16          NO, ZERO HI-ORDER BYTE\n         BR    @14\n.ARMODE88X ANOP\n         AIF   ('&OPT3' EQ 'LOCTR').GENL7L\n@STRBLANKS DC  CL((((*+&STRBLANKS+7-@STRING)/8)*8)-(*-@STRING))' '\n         AGO   .GENL7X\n.GENL7L  ANOP\n@STRBLANKS DC  CL&STRBLANKS.' '\n.GENL7X  ANOP\n@STRING_SIZE EQU *-@STRING             SIZE OF GENERATED CSECT\n.**********************************************************************\n.*       WORK AREA (CALLER'S SAVE AREA)                               *\n.**********************************************************************\n@STRSAVE DSECT                         24-BYTE WORK AREA\n         DS    A(0,@STRSAVE,@STRSAVE,14,15,0,1,2,3,4,5,6)\n@STRWK16 DS    F'7,8,9,10'             WORK AREA\n@STRDWD  DS    D'1112'                 WORK AREA\n@STRPARM DSECT\n@STRSCON DS    S                   +0  FIELD ADDRESS\n@STRFLEN DS    S                   +2  FIELD LENGTH\n@STRFLAG DS    B                   +4  FORMAT, FLAGS\n@STRLAST EQU   X'80'                     LAST ENTRY\n@STRLIT  EQU   X'40'                     LITERAL, @STRSCON IS AN OFFSET\n@STRJDT  EQU   X'20'                     JULIAN DATE\n.*             X'3F'                   CONVERSION REQUIRED\n@STRHEX  EQU   X'08'                     HEXADECIMAL\n@STRBIN  EQU   X'04'                     BINARY\n@STRPACK EQU   X'02'                     PACKED\n@STRREG  EQU   X'01'                     REGISTER\n@STRLEN2 DS    B                   +5  FORMAT, OUTPUT LENGTH\n@STRLEFT EQU   X'80'                     LEFT JUSTIFICATION\n@STRZERO EQU   X'40'                     LEADING ZEROES\n.*             X'3F'                     OUTPUT LENGTH, 0 MEANS TRUNC.\n@STRNEXT EQU   *                   +6\n         AIF   (NOT D'$LTORG).MEND99   CSECT-ONLY\n         AIF   (D'$STRING).MEND99      CSECT-ONLY\n$LTORG   LOCTR\n         AIF   ('&OPT3' EQ 'LOCTR').GENL9L\n         CNOP  0,4\n$STRING  BALR  @15,0                   LOCAL BASE\n         L     @15,6(@15,0)            ROUTINE ADDRESS           00\n         BR    @15                     GO TO @STRING             04\n         AGO   .GENL9\n.GENL8   ANOP                          GENERATE,NOCSECT\n&$_LIT   SETA  0                       DO NOT GENERATE LITERALS TWICE\n&$_FEAT(1) SETB 1,1,1,1,1,1,1,1,1,1,1,1   GENERATE=FULL\n$LTORG   LOCTR\n         CNOP  0,4\n$STRING  BALR  R15,0                   LOCAL BASE\n         L     R15,6(R15,0)            ROUTINE ADDRESS           00\n         BR    R15                     GO TO @STRING             04\n.GENL9   ANOP\n         DC    V(@STRING)              ROUTINE ADDRESS           06\n         AGO   .MEND\n.GENL9L  POP   USING                   GENERATE,LOCTR\n$STRING  BAS   R15,$STRING2\n         DC    Y(@STRING-*)            OFFSET TO @STRING ROUTINE\n$STRING2 AH    R15,0(R15)\n         BR    R15\n.MEND    AIF   ('&PRINT' EQ 'NOGEN').MEND99\n         POP   PRINT\n.MEND99  MEND\n         EJECT\n**********************************************************************\n**********************************************************************\n********* TEST PROGRAM FOR THE 'STRING' MACRO ************************\n**********************************************************************\n**********************************************************************\n**       STRING (GENERATE,AR_MODE)\n**       END\n         LCLA  &ASMH_HLASM\n         AIF   (T'&ASMH_HLASM EQ 'N').ASMH1X\n&SYSVER  SETC  'ASMH'\n&SYSDATC SETC  '20'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)\n.ASMH1X  ANOP\nTESTPGM  START X'027000'\n         BALR  R12,0\n         USING *,R12\n LOAD EP=SYSDEBUG\n LR R15,R0\n BASSM R14,R15\n*STRING 1X,INTO=XXX\n         OPEN  (SYSPRINT,OUTPUT)\n         STRING 'Assembler is &SYSVER, DATE is &SYSDATC',INTO=XXX\n         PUT   SYSPRINT,XXX\nRBPREFIX EQU   *\nRBINTCOD EQU   *+6,2,C'H'\nASCBASID EQU   *+8,2,C'X'\n         L     R1,PSATOLD-PSA\n         L     R1,0(,R1)               TCBRBP\n         STRING 'SVC',(RBINTCOD-RBPREFIX(R1),H,R3Z),                   X\n               1X,(WWWW,,T),' - ',     VV.MM OF SVC RTNE               X\n               ((R8),,X),1X,           COM-REG ADDR                    X\n               (ASCBASID,,X),1X,       ASID                            X\n               PARM1,1X,               MAIN PGM NAME                   X\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n*\n         LA    R2,XXX\n         STRING 1X,INTO=((R2),8)\n         MACRO                                       JDATE MACRO\n        @JDATE &DATE                                 JDATE MACRO\n         LA    R1,=P'&DATE'                          JDATE MACRO\n*** STRING ((R1),P),2X,((R1),P),INTO=XXX\n         STRING ((R1),P),2X,((R1),P,YYMMDD),INTO=XXX,                  X\n               3X,((R1),P,YY/MM/DD),                                   X\n               3X,((R1),P,DD/MM/YY),                                   X\n               3X,((R1),P,MM/DD/YY),                                   X\n               3X,((R1),P,YYYYMMDD),                                   X\n               3X,((R1),P,YYYY-MM-DD)\n         PUT   SYSPRINT,XXX                          JDATE MACRO\n         MEND                                        JDATE MACRO\n        @JDATE 90058\n        @JDATE 91059\n        @JDATE 93060\n        @JDATE 94365\n        @JDATE 80058\n        @JDATE 84059\n        @JDATE 88060\n        @JDATE 92061\n        @JDATE 00366\n         LA    R2,1234\n         STRING 'CVTPTR=X''',(CVTPTR,4,X),'''',INTO=XXX,               X\n               ' 1234=',((R2),,R4Z)\n         PUT   SYSPRINT,XXX\n         L     R1,CVTPTR\n         STRING 'CVTDATE=',(56(R1),P,YYMMDD),INTO=XXX\n         PUT   SYSPRINT,XXX\n         LA    R0,1000\n         LA    R3,0033\n         STRING 'D1=/',D1,'/,WWWW=/',WWWW,'/',                         X\n               ((R3),,L),'/',((R3),,X),'/',((R0),,L),'/',              X\n               ((R3),,R9B),'/',INTO=XXX\n         LR    R4,R15                   LENGTH USED\n         PUT   SYSPRINT,XXX\n         STRING WWWW,                                                  X\n               (4(R13),4,X),'''',(4(R13),F),'''',                      X\n               (4(R13),F,L),'''',                                      X\n               (4(R13),F,L11),'''',                                    X\n               (4(R13),F,Z9),'''',                                     X\n               8X,'R4=',((R4),,L),      LENGTH USED                    X\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n         STRING %TIME,D1,'B12345678B',5X,(CTR1,P),1X,PARM1,1X,PARM2,   X\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n         LA    R3,22\n         STRING INTO=XXX,'CCC1234A',(D1,(R3)),'.',(CTR1,P,R7Z)\n         PUT   SYSPRINT,XXX\n         STRING C'DDN2(',(D1,,T),')',X'40C1C2C3C4',                    +\n               ' PSATOLD=',(PSATOLD-PSA,,X),                           +\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n         AIF   ('&SYSVER' EQ 'ASMH').HLASM99\nPSABASE  USING PSA,R0\n         STRING 'PSATOLD=',(PSABASE.PSATOLD,,X),                       +\n               ' PSATOLD=',(PSATOLD-PSA,,X),                           +\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n.HLASM99 ANOP\n         BALR  R0,0\n         STRING 'R0=',((R0),,X),'   16(R0)=',(16(R0),4,X),INTO=XXX\n         PUT   SYSPRINT,XXX\n*\nAMODE31  LA    R12,0(,R12)             BALR->BASR\n         L     R15,=A(*+X'80000006')   AMODE=31\n         BSM   0,R15                   AMODE=31\n         L     R1,=A(@STRING)          point at CSECT\n         CLC   =C'/390',11(R1)         (GENERATE,AR_MODE) ?\n         BNE   EXIT                    no, prevent S0E0\n         DSPSERV CREATE,                                               X\n               NAME==CL8'STRING00',    C'STRING00'                     X\n               BLOCKS=HDRBLKS,         SIZE IN PAGES                   X\n               STOKEN=DSPCSTKN,                                        X\n               ORIGIN=DSPCORG\n         ALESERV ADD,STOKEN=DSPCSTKN,ALET=DSPCALET\n         LAM   R8,R8,DSPCALET          POINT TO THE DATA SPACE\n         L     R8,DSPCORG              SPACE ORIGIN (0 OR 4096)\n         SAC   512                     MODE=AR\n LAM R14,R6,TESTPGM+40                 S0E0-28\n         STRING WWWW,'AR_MODE WORKED OK',INTO=(2048(R8),100)\n         LAM   R2,R2,DSPCALET          POINT TO THE DATA SPACE\n         LR    R2,R8                   SPACE ORIGIN (0 OR 4096)\n         STRING (2048+L'WWWW(R2),30,T),INTO=XXX\n         SAC   0                       MODE=AR OFF\n         PUT   SYSPRINT,XXX            AR_MODE WORKS OK\n*\nEXIT     SLR   R15,R15\n         SVC   3                       GOBACK\nD1       DC    C'D1-----D1    '\nWWWW     DC    C'WWWW'\nCTR1     DC    P'1'\nPARM1    DC    C'<-PARM1->'\nPARM2    DC    C'<-PARM2->'\nXXX      DS    CL132\nDSPCSTKN DS    XL8                  0  AS TOKEN\nDSPCALET DS    F                    8  ALET\nDSPCORG  DS    F                   12  ORIGIN\nHDRBLKS  DC    F'100'\nCVTPTR   EQU   0016,4,C'A'\nSYSPRINT DCB   DSORG=PS,DDNAME=SYSPRINT,MACRF=PM,RECFM=FB,LRECL=121\nXYZ      DSECT\n         STRING GENERATE\n**       STRING (GENERATE,NO_CSECT) -\\\n**       STRING (GENERATE,AR_MODE)  -/\n**       STRING (GENERATE,,LOCTR)\n**       STRING (GENERATE,AR_MODE,LOCTR)\n**       STRING (GENERATE,NO_CSECT,LOCTR)    invalid combination\n         YREGS\nPSA      DSECT\nPSATOLD  EQU   *+X'21C',4,C'A'\n         END\n*/SYSPRINT DD SYSOUT=*\n*/SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n*/SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n*/SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n*/*\n*/GO      EXEC PGM=LOADER,PARM=PRINT,TIME=(,1)\n*/SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,DELETE)\n*/SYSLOUT  DD SYSOUT=*\n*/SYSPRINT DD SYSOUT=*\n*/ABNLTERM DD SYSOUT=*\n*/ABNLIGNR DD DUMMY\n*/SYSDEBUG DD SYSOUT=*\n*/SYSUDUMP DD SYSOUT=*\n*/\n*/        +----------------------------------------+\n*/        +                                        +\n*/        +   Documentation for the STRING macro   +\n*/        +                                        +\n*/        +       Last update: 13 Dec 1999         +\n*/        +----------------------------------------+\n*/\n*/The STRING macro is functionally similar to the COBOL DISPLAY\n*/or PL/I PUT EDIT instructions.\n*/\n*/Using STRING, you can concatenate any number of fields, edit\n*/each of them if necessary, and get the result in the work area\n*/you specify.\n*/\n*/Formats:\n*/\n*/  (1) label  STRING {field_specification1}\n*/                    {,field_specification2}...\n*/                    ,INTO=workarea|(workarea,length)\n*/                    {,PRINT=GEN|NOGEN}\n*/\n*/  (2) label  STRING GENERATE\n*/                    {,PRINT=GEN|NOGEN}\n*/\n*/\n*/field_specification\n*/\n*/  Each field to be printed is described as a positional\n*/  operand.  Each operand specifies the field address, its\n*/  length, and its formatting requirements.\n*/\n*/  Four field description formats are supported:\n*/\n*/    1.   symbol\n*/    2.   (symbol,length,format)\n*/    3.   (d(r)|(r),length,format)\n*/    4.   ((r),,format)\n*/    5.   'character string'\n*/\n*/Symbol specifies the field address.  It must be an\n*/  S-type (relocatable) address.\n*/\n*/d(r) may be used to specify the field address in S/370\n*/  base-displacement format.  If d is zero, it may be omitted.\n*/  If d(r) or (r) is used, length must also be specified.  R14\n*/  and R15 may not be used.  If d(0) is used, it is handled the\n*/  way the assembler does, i.e. R0 as a base register is assumed\n*/  to contain zero: 16(0) is equivalent to 16, CVTPTR or, X'10'.\n*/\n*/((r),,format) specifies that (r) contains the value\n*/  itself, not an address.  R14 and R15 may not be used.\n*/\n*/'character string' specifies a literal enclosed in single quotes\n*/  as specified in a DC instruction.  Hex strings or character\n*/  strings are supported.  The following expressions are equivalent:\n*/  'ABC' C'ABC' X'C1C2C3'\n*/\n*/Length specifies the length and/or the type of the input field.\n*/  It may be specified as an integer, a symbol, a register, or a\n*/  constant.  When used with symbol, it overrides the assembled\n*/  length and/or type.  Length is required if field is specified\n*/  as d(r) or (r).  If a zero length is specified, the field is\n*/  ignored.\n*/\n*/      nn   field length in bytes\n*/      H    half-word\n*/      F    full-word\n*/      FL1  1-byte binary integer\n*/      FL3  3-byte binary integer\n*/      P    packed field\n*/      (r)  length of character string (R0 thru R12)\n*/      d(r) length of character string (R1 thru R12)\n*/\n*/Notes:  If the field address is specified as a symbol that\n*/        has been defined previously in the program, the symbol\n*/        type is known and there is no need to specify it.\n*/\n*/        If the length is specified as (r) or d(r) and the value\n*/        is greater than the address itself, (r) or d(r) is\n*/        considered to be the end address +1 instead of the length.\n*/\n*/        The length is not specified for packed fields.  The\n*/        @STRING subroutine scans the field left-to-right until it\n*/        finds a byte with a valid sign in the low-order 4 bits.\n*/\n*/        If symbol is an arithmetic expression and no length is coded,\n*/        the implicit length will be that of the first symbol in the\n*/        expression;  for example, if symbol is coded as PSATOLD-PSA,\n*/        then the implicit length will be L'PSATOLD.\n*/\n*/        All numeric items are assumed positive.\n*/\n*/format  optionally indicates editing options that must\n*/        be applied to a field.\n*/\n*/    L        left justified\n*/    R        right justified\n*/    nn       output length\n*/    0        adjust length\n*/    Z        leading zeroes\n*/    B        leading/trailing blanks\n*/    T        truncate character string after last non-blank\n*/    X        display in hexadecimal\n*/    YYMMDD   convert julian date to YYMMDD\n*/    YY/MM/DD convert julian date to YY/MM/DD\n*/    DD/MM/YY convert julian date to DD/MM/YY\n*/    MM/DD/YY convert julian date to MM/DD/YY\n*/    YYYYMMDD convert julian date to YYYYMMDD\n*/    YYYY-MM-DD convert julian date to YYYY-MM-DD\n*/\n*/  The default format depends on the field type:\n*/\n*/      Type                   Default Format\n*/\n*/      character string             L\n*/      FL1                          R3B\n*/      H or FL2                     R5B\n*/      other numeric fields         R7B\n*/\n*/  Note: L0 and T are equivalent for character strings.\n*/\n*/'character string' is any character string enclosed in\n*/single quotes.  Blank spaces may be specified as nnX,\n*/where nn is the number of X'40' bytes you want to be\n*/inserted in the output line.  %TIME may be specified to\n*/obtain the current time in hh.mm.ss.hh format.\n*/\n*INTO=workarea|(workarea,length)\n*/\n*/INTO indicates the address and length of the output work area\n*/into which the result of the concatenation should be placed\n*/(left justified).  If the work area is too small, truncation\n*/will occur.  If it is too large, it is padded with blanks.\n*/\n*/The address may be a symbol, d(r) (S-type address) or (r).\n*/\n*/The length may be specified as an integer, a symbol, a register,\n*/or a constant; it is required if the address is coded as d(r) or\n*/(r).  If length is not specified for a symbol-type address, the\n*/assembled length of the symbol is used.\n*/\n*/Upon return from STRING, R15 contains the length actually used\n*/in the output work area (before padding).\n*/\n*PRINT=GEN|NOGEN\n*/\n*/This operand allows you to temporarily override the PRINT\n*/specification (GEN or NOGEN).\n*/\n*GENERATE (format 2)\n*/\n*/The GENERATE format must be specified once at the end of the\n*/program.  It generates the @STRING sub-routine as well as all\n*/the literals specified in previous invocations of the macro.\n*/\n*/The GENERATE format allows the specifications of the\n*/AR_MODE, NO_CSECT and LOCTR options.\n*/\n*/       STRING GENERATE<,AR_MODE<,LOCTR>>>\n*/                        NO_CSECT\n*/\n*/The following combinations are valid:\n*/\n*/       STRING GENERATE\n*/       STRING (GENERATE,NO_CSECT)\n*/       STRING (GENERATE,AR_MODE)\n*/       STRING (GENERATE,,LOCTR)\n*/       STRING (GENERATE,AR_MODE,LOCTR)\n*/\n*/The AR_MODE option can be specified to generate a\n*/@STRING module that supportd AR mode.  Example:\n*/\n*/       STRING (GENERATE,AR_MODE)\n*/\n*/The NO_CSECT option can be specified to indicate that the\n*/@STRING module should not be generated; only the literals\n*/are generated in this case.  Example:\n*/\n*/       STRING (GENERATE,NO_CSECT)\n*/\n*/The @STRING CSECT contains optional functions (such as %TIME or\n*/julian date conversion) that are only generated if they have\n*/been specified in the previous invocations of the STRING macro.\n*/\n*/To generate of a @STRING CSECT that supports all of the optional\n*/functions, two STRING GENERATE macros must be specified:\n*/\n*/       STRING (GENERATE,NO_CSECT)        Generate Literals\n*/       STRING GENERATE                   Generate CSECT\n*/\n*Examples:\n*/\n*/   STRING 'ERROR===>',LINE1,'<=== POS ',((R6),,L0),INTO=WORKAREA\n*/\n*/   STRING 8X,C'ERRORS FOUND: ',(ERRORS,,L0),INTO=((R7),44)\n*/\n*/   STRING 'CVT ADDR IS ',(CVTPTR,4,X),X'40C1C2C3C4',INTO=LINE\n*/\n*/   LA    R5,WORK+16              end addr +1\n*/   STRING 'R4=',((R4),,X),INTO=(WORK,(R5)),PRINT=GEN\n*/\n*/   STRING '//JOBLIB DD DSN=',(DSN1,,T),',DISP=SHR',INTO=((R2),72)\n*/\n*/   PUT31 SYSLIN\n*/   LH    R0,SYSLIN+82            LRECL\n*/   STRING '   NAME  ',(4(R3),8,T),'(R)',INTO=((R1),(R0))\n*/\n*/   STRING GENERATE         Generate literals and sub-routine\n*/\n*/\n*Programming Notes:\n*/\n*/A STRING macro generates only 6 bytes that need to be covered by\n*/base registers.  More code is generated at the end of the\n*/current CSECT (using LOCTR pseudo instruction), but this code\n*/does not require addressability.  This is particularly useful\n*/when STRING calls specify a large number of literals.\n*/\n*/Additionally, STRING does not use A-type constants (ACON), but\n*/S-type constants (SCON) which require symbols to be addressable\n*/at the point in the program where STRING is issued.\n*/\n*/While this reduces the number of base registers required to\n*/cover the program's code and makes it easier to write reentrant\n*/programs, it will produce assembly errors in the following\n*/situations:\n*/\n*/a.  STRING is used in more than one CSECT in the same assembly\n*/\n*/b.  the CSECT in which STRING is used is longer than 64K\n*/\n*/c.  symbols are not addressable at the point in the program\n*/    where STRING is issued\n*/\n*/d.  the $STRING symbol (generated in the $LTORG LOCTR during the\n*/    GENERATE invocation of the STRING macro) is not addressable\n*/    in some of the STRING calls.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SISPLOAD": {"ttr": 9475, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x023\\x1f\\x01\\x023\\x1f\\x002\\x02\\xde\\x02\\xde\\x00\\x00\\xe7\\xd4\\xc9\\xe3@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-27T00:00:00", "modifydate": "2002-11-27T00:32:00", "lines": 734, "newlines": 734, "modlines": 0, "user": "XMIT"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "SISPMENU": {"ttr": 9733, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x023\\x1f\\x01\\x023\\x1f\\x004\\x00R\\x00R\\x00\\x00\\xc6\\xd9\\xc1\\xd3\\xc2\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-27T00:00:00", "modifydate": "2002-11-27T00:34:00", "lines": 82, "newlines": 82, "modlines": 0, "user": "FRALBER"}, "text": "./ ADD NAME=COBANAL  0103-99348-01345-1147-00062-00061-00000-EX31022\n//&USERHLQ.A JOB (&ACCOUNT),&USERHLQ,REGION=0K,\n//             CLASS=&CLASS,MSGCLASS=&MSGCLASS,MSGLEVEL=(1,1)\n//*\n//DELETE  EXEC PGM=IEFBR14\n//COBANAL   DD DSN=&USERHLQ..COBANAL.LISTING,DISP=(MOD,DELETE),\n//             SPACE=(TRK,(1,1))\n//COBANALE  DD DSN=&USERHLQ..COBANAL.LISTEDIT,DISP=(MOD,DELETE),\n//             SPACE=(TRK,(1,1))\n//*\n//COMP    EXEC PGM=COBANAL,PARM='ALL'\n//STEPLIB   DD DISP=SHR,DSN=&STEPLIB\n//COBANAL   DD DISP=SHR,DSN=&LOADLIB\n//SYSPRINT  DD DSN=&USERHLQ..COBANAL.LISTING,\n//             SPACE=(CYL,(5,1)),\n//             DISP=(,CATLG),RECFM=FB,LRECL=121\n//XYSPRINT  DD SYSOUT=*\n//SYSUDUMP  DD SYSOUT=*\n//*\n//COPY1   EXEC PGM=IEBCOPY\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD DSN=&COBAHLQ..&LLQTLIB,DISP=SHR\n//SYSUT2    DD DSN=&&ISPPROF,\n//             DISP=(MOD,PASS,DELETE),\n//             UNIT=SYSALLDA,RECFM=FB,LRECL=80,\n//             SPACE=(TRK,(2,1,5))\n//SYSIN     DD *\n COPY INDD=SYSUT1,OUTDD=SYSUT2\n SELECT MEMBER=((ISPCMDS,,R))\n SELECT MEMBER=((ISPSPROF,,R))\n SELECT MEMBER=((ISPPROF,,R))\n/*\n//GENER   EXEC PGM=IEBGENER\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD DSN=&USERHLQ..COBANAL.LISTING,DISP=SHR\n//SYSUT2    DD DSN=&USERHLQ..COBANAL.LISTEDIT,\n//             SPACE=(CYL,(5,1)),\n//             DISP=(,CATLG),RECFM=FB,LRECL=121\n//SYSIN     DD DUMMY\n/*\n//ANALYSE EXEC PGM=IKJEFT01\n//SYSPROC   DD DISP=SHR,DSN=&COBAHLQ..&LLQCLIB\n//SYSEXEC   DD DISP=SHR,DSN=&COBAHLQ..&LLQCLIB\n//COBANAL   DD DISP=SHR,DSN=&USERHLQ..COBANAL.LISTEDIT\n//ISPTABL   DD DISP=SHR,DSN=&COBAHLQ..&LLQTABL\n//ISPTLIB   DD DISP=SHR,DSN=&COBAHLQ..&LLQTLIB\n//ISPPROF   DD DISP=(OLD,DELETE),DSN=&&ISPPROF\n//ISPPLIB   DD DISP=SHR,DSN=&COBAHLQ..&LLQPLIB\n//ISPSLIB   DD DISP=SHR,DSN=&COBAHLQ..&LLQSLIB\n//ISPMLIB   DD DISP=SHR,DSN=&COBAHLQ..&LLQMLIB\n//          DD DISP=SHR,DSN=&ISPFHLQ..SISPMENU\n//ISPLOG    DD DSN=&SPFTEMP,\n//             DISP=(NEW,DELETE,DELETE),\n//             UNIT=SYSALLDA,RECFM=V,LRECL=132,\n//             SPACE=(TRK,(5,1))\n//SYSPRINT  DD SYSOUT=*\n//SYSTSPRT  DD SYSOUT=*\n//SYSUDUMP  DD SYSOUT=*\n//SYSTSIN   DD *\n ISPSTART CMD(COBANLBL &PTYPE +\n          &LOADLIB) +\n          NEWAPPL(&COBAAPPL)\n/*\n./ ADD NAME=COBA00\nCOBA001 'Input required' .ALARM=YES .WINDOW=RESP\n'you have to type in a value'\nCOBA002 'invalid line selection' .ALARM=YES .WINDOW=RESP\n'Please enter S or /  '\nCOBA003 'invalid value' .ALARM=YES .WINDOW=RESP\n'valid operator GE,GT,EQ,LE,LT'\nCOBA004 'invalid value' .ALARM=YES .WINDOW=RESP\n'select value from selection list'\nCOBA005 'invalid value' .ALARM=YES .WINDOW=RESP\n'select value D or E from selection list'\nCOBA006 'filter cleared         ' .ALARM=YES .WINDOW=RESP\n'no filter active          '\nCOBA008     '                        '            .ALARM=NO\n'COBA - Cobol anaylse reporting                                              ' +\n'Welcome to the COBA application                                             ' +\n'These application analyze the output from the                               ' +\n'COBANAL program developed by Roland Schiradin                               ' +\n'Email: Roland(at)Schiradin.de                                               '\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SISPPENU": {"ttr": 9736, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x023\\x1f\\x01\\x023\\x1f\\x005\\x07\\xd0\\x07\\xd0\\x00\\x00\\xc6\\xd9\\xc1\\xd3\\xc2\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-27T00:00:00", "modifydate": "2002-11-27T00:35:00", "lines": 2000, "newlines": 2000, "modlines": 0, "user": "FRALBER"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "SISPTENU": {"ttr": 10504, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x026O\\x01\\x026O\\x10\\x02\\x01K\\x01K\\x00\\x00\\xc6\\xd9\\xc1\\xd3\\xc2\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-12-30T00:00:00", "modifydate": "2002-12-30T10:02:00", "lines": 331, "newlines": 331, "modlines": 0, "user": "FRALBER"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "STCCHECK": {"ttr": 10756, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x960?\\x00\\x98\\x07\\x9f\\x15\\x06\\x00\\xa1\\x00\\xc5\\x00\\x00\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1996-10-29T00:00:00", "modifydate": "1998-03-20T15:06:00", "lines": 161, "newlines": 197, "modlines": 0, "user": "XSSGSCH"}, "text": "***********************************************************************\n*                                                                     *\n* NAME:         STCCHECK                                              *\n*                                                                     *\n* AUTHOR:       Roland Schiradin                                      *\n*                                                                     *\n* DATUM:        Oktober 1996                                          *\n*                                                                     *\n* BESCHREIBUNG: Check if cics or STC is up                            *\n*                                                                     *\n***********************************************************************\n         TITLE 'Check if cics is up, avoid U1800 system abends'\nSTCCHECK CSECT\nSTCCHECK AMODE 31\nSTCCHECK RMODE ANY\n         BAKR  R14,R0             Save register\n         LR    R12,R15            set base register\n         USING STCCHECK,R12       Addressebility\n         L     R9,0(R1)           Save Parmlist\n         USING STCCHECK_PARM,R9   addressebility\n         LA    R0,STCCHECK_WORK_LENGTH\n         STORAGE OBTAIN,LENGTH=(R0),ADDR=(R1),COND=NO,LOC=(ANY,ANY)\n         LR    R11,R1             STCCHECK_WORK register\n         USING STCCHECK_WORK,R11  addressebility\n         MVC   EYECATCHER,=CL8'STCCHECK'\n         XC    SAVEAREA,SAVEAREA  clear saveare\n         LA    R15,SAVEAREA       get address of savearea\n         ST    R13,4(,R15)        chain the savearea back pointer\n         ST    R15,8(,R13)        chain saveare forward\n         LR    R13,R15            set new savearea\n         ST    R11,ADR_STCCHECK_WORK save address\n         ST    R9,ADR_STCCHECK_PARM  save address\n*------------------------------------------------------------*\n*        Check JCL-Parm                                      *\n*------------------------------------------------------------*\n         MVC   PARM_LENGTH,STCCHECK_PARM_LENGTH\n         CLC   PARM_LENGTH,=H'8'  length of plist > 8\n         BH    STCCHECK_PARM_ERROR  yes, error\n         CLC   PARM_LENGTH,=H'6'  length of plist < 6\n         BL    STCCHECK_PARM_ERROR  yes, error\n         LH    R10,PARM_LENGTH\n         LA    R9,2(R9)            jump length field\n         MVC   STCNAME,BLANK       clear STCNAME\n         LA    R8,STCNAME          first parm\nSTCCHECK_010 DS 0H                 do until first ',' or end\n         MVC   0(1,R8),0(R9)\n         LA    R8,1(R8)            next digit\n         LA    R9,1(R9)            next digit\n         BCT   R10,STCCHECK_010    loop\nSTCCHECK_020 DS 0H\n         CLC   STCNAME,BLANK       check STC-ID\n         BE    STCCHECK_PARM_ERROR if clear ==> Error\n*------------------------------------------------------------*\n*        Common Vector Table                                 *\n*------------------------------------------------------------*\n         L     R8,CVTPTR           load CVT-Pointer\n         USING CVTMAP,R8           tell assembler\n*------------------------------------------------------------*\n*        Get own Asid                                        *\n*------------------------------------------------------------*\n         L     R6,PSAAOLD-PSA        my ASCB\n         USING ASCB,R6               tell assembler\n         MVC   MY_OWN_ASID,ASCBASID  remember that\n         DROP  R6                    free for use\n*------------------------------------------------------------*\n*        Check STC-ID                                        *\n*------------------------------------------------------------*\n         LA    R4,1                    first ASID\n         L     R5,CVTASVT              point to ASVT\n         L     R5,ASVTMAXU-ASVT(,R5)   max ASID\n*loop\nSTCCHECK_25 DS 0H\n         LOCASCB ASID=(R4)             get addr of owner's ASCB\n         LTR   R7,R1                  valid Asid?\n         BNP   STCCHECK_30              no, next\n         ICM   R1,B'1111',ASCBJBNI-ASCB(R7) Jobname present\n         BNZ   STCCHECK_30              yes, next\n         ICM   R1,B'1111',ASCBJBNS-ASCB(R7) Start/Mount/Logon\n         L     R14,ASCBOUCB-ASCB(,R7)  point to OUCB\n         TM    OUCBYFL-OUCB(R14),OUCBSTT+OUCBMNT  Start or Mount ?\n         BZ    STCCHECK_30              no, next\n         CLC   MY_OWN_ASID,ASCBASID-ASCB(R7) ignore own ASID\n         BE    STCCHECK_30              equal, next\n         CLC   0(8,R1),STCNAME         compare STC-id\n         BNE   STCCHECK_30              not equal, next\n         WTO 'STCCHECK: This Subsystem is already active',             *\n               ROUTCDE=11\n         LA    R15,8                   set returncode 8\n         B     STCCHECK_EXIT            not equal, next\nSTCCHECK_30 DS 0H\n         LA    R4,1(,R4)               bump ASID\n         BCT   R5,STCCHECK_25          next address space\n         LA    R15,0                   set returncode\nSTCCHECK_EXIT      DS 0H\n         PR                         back\nSTCCHECK_PARM_ERROR DS 0H\n*        Parm-Error\n         WTO 'STCCHECK: PLIST-Error, please check',                    *\n               ROUTCDE=11\n         LA    R15,12\n         B     STCCHECK_EXIT\n*============================================================*\n* SONSTIGE DEFINITIONS                                       *\n*============================================================*\n****************************** CONSTANTS *****************************\nBLANK    DC    CL255' '           just blanks\n*============================================================*\n* Workarea                                                   *\n*============================================================*\nSTCCHECK_WORK       DSECT\nEYECATCHER          DS    CL8   'STCCHECK'\nSTCNAME             DS    CL8   Pgmname from the parmlist\nADR_STCCHECK_WORK   DS    F     Save Workarea pointer\nADR_STCCHECK_PARM   DS    F     Save Parmlist pointer\nPARM_LENGTH         DS    H     Save Parmlist length\nMY_OWN_ASID         DS    H     Save My Own Asid\nXXX                 DS    CL132 only for trace\nSAVER14             DS    F     Save Parmlist pointer\nSAVEAREA            DS    18F\n****************************** VARIABLES *****************************\nWTODATA  DS 0F\n         WTO TEXT=,MF=L\nSTCCHECK_WORK_LENGTH EQU *-STCCHECK_WORK Length workarea\n*\n*============================================================*\n* Parameter (JCL)                                            *\n*============================================================*\nSTCCHECK_PARM       DSECT\nSTCCHECK_PARM_LENGTH DS H\n*------------------------------------------------------------*\n* Programm equates                                           *\n*------------------------------------------------------------*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*------------------------------------------------------------*\n* MVS control blocks                                         *\n*------------------------------------------------------------*\n*------------------------------------------------------------*\n*        Common Vector Table                                 *\n*------------------------------------------------------------*\n         CVT   PREFIX=YES,DSECT=YES,LIST=YES  CVT\n         IHAASCB DSECT=YES             Address Space Control Block\n         IHAASVT DSECT=YES             Address Space Vector Table\n         IHAASXB DSECT=YES             Address Space Extension Block\n         IRAOUCB DSECT=YES             SRM parms\n         IHAPSA  DSECT=YES             Prefixed Storage Area\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STRING": {"ttr": 10760, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x0b\\x00\\x00\\x00x#\\x9f\\x01\\x04\\x08\\x1f\\x00I\\x05\\xac\\x00\\x19\\x05\\xac\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "05.11", "flags": 0, "createdate": "1978-08-27T00:00:00", "modifydate": "2004-03-21T00:49:00", "lines": 1452, "newlines": 25, "modlines": 1452, "user": "XSSGSCH"}, "text": "*/GILBERTM JOB (ACCT#),STRING,\n*/ NOTIFY=&SYSUID,\n*/ CLASS=A,MSGCLASS=X,COND=(0,NE)\n*/ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF,\n*/*FLAG(PAGE0),NORXREF,NODXREF,                   HLASM R3\n*/ NOBATCH)\n***********************************************************************\n*                                                                     *\n* MACRO NAME = STRING                                                 *\n*                                                                     *\n* DESCRIPTIVE NAME = STRING Macro Instruction.                        *\n*                                                                     *\n* FUNCTION = Provide capabilities similar to PUT EDIT (of PL/I)       *\n*            or STRING (of COBOL) to assembler programs.              *\n*                                                                     *\n* STATUS = R512                                                       *\n*                                                                     *\n* AUTHOR = Gilbert Saint-flour <gsf@pobox.com>                        *\n*                                                                     *\n* ENVIRONMENT = SEE BELOW                                             *\n*                                                                     *\n*     AMODE = ANY                                                     *\n*     SCP   = OS/360, OS/VS, MVS/370, MVS/XA, MVS/ESA, OS/390 or z/OS *\n*     KEY   = ANY                                                     *\n*     MODE  = ANY                                                     *\n*     APF   = OFF                                                     *\n*                                                                     *\n* OPERATION = SEE DOCUMENTATION AT THE END OF THIS FILE               *\n*                                                                     *\n* INVOCATION = SEE DOCUMENTATION AT THE END OF THIS FILE              *\n*                                                                     *\n* NOTES = SEE DOCUMENTATION AT THE END OF THIS FILE                   *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n*  $301  FIX BUGS WITH (XYZ,,L8) AND INTO=((R1),(R2))                 *\n*  $302  GENERATE $DEBUG BOOT-STRAP IN FINAL_CALL INVOCATION          *\n*  $303  REPLACE @STRPAD WITH @STRBLANKS                              *\n*  $304  USE @00-@15 INSTEAD OF R0-R15 FOR REGISTER EQUATES           *\n*  $306  TAILOR @STRING CSECT TO PROGRAM'S REQUIREMENTS               *\n*        LITERALS CAN BE CODED AS 'ABC' OR C'ABC' OR X'C1C2C3'        *\n*        USE L'PSATOLD AS IMPLICIT LENGTH FOR (PSATOLD-PSA,,X)        *\n*  $307  FINAL_CALL OPTION CHANGED TO GENERATE                        *\n*        ADD NOCSECT AND LOCTR OPTIONS TO GENERATE CALL               *\n*  $308  USE L'RBCDE AS IMPLICIT LENGTH FOR (PRB.RBCDE,,X)            *\n*        PREVENT S0C4 WHEN ADDR IS BAD AND LENGTH IS ZERO             *\n*  $400  REORG THE CODE TO SIMPLIFY FEATURE SELECTION                 *\n*        BLANKS NO LONGER USED OR GENERATED                           *\n*  $401  GENERATE @STRHEXT WHEN ((REG),,X) ONLY HEX FIELD             *\n*  $502  @STRING ROUTINE REWRITTEN FOR MVS/ESA:                       *\n*        -  USE LINKAGE STACK TO STORE CALLER'S REGISTERS             *\n*        -  ADD SUPPORT FOR AR MODE                                   *\n*        -  @STRING now executes in caller's AMODE                    *\n*        -  Rename previous version to STRINGXA                       *\n*  $503  DATE CONVERSION TO YYYY-MM-DD FORMAT (ISO STANDARD)          *\n*        IMPROVE SUPPORT FOR AR MODE                                  *\n*  $504  SET &STRBLANKS TO 10 WHEN PROCESSING DATES                   *\n*  $505  Allow for 128K-offset                                        *\n*  $506  Remove literal from BAL instruction for HLASM R3             *\n*  $507  Merge STRINGXA code, add AR_MODE option                      *\n*        Change syntax of GENERATE call                               *\n*  $508  Compatibility with FLAG(PAGE0) in HLASM R3                   *\n*        Compatibility with pre-XA version of the SAVE macro          *\n*        Remove AMODE-based R2 cleanup in 370 mode                    *\n*  $509  Length of parm-list entries can vary between 2 and 6 bytes   *\n*        Short Literals (one to five bytes) are generated in parm list*\n*        Hex string can contain commas, e.g. X'12,3456,7890'          *\n*  $510  JDATE=90366 produces 90/13/01 instead of S0C7                *\n*  $511  Prevent ACTR error with long literals                        *\n*  $512  Packed fields no longer ignored when R0=0                    *\n***********************************************************************\n         MACRO\n&NAME    STRING &INTO=,&PRINT=NOGEN\n         GBLC  &STRING_MACRO_VERSION\n&STRING_MACRO_VERSION SETC '512'       current version\n         AIF   ('&PRINT' EQ 'NOGEN').NOGEN\n         PUSH  PRINT\n         PRINT GEN\n.NOGEN   GBLA  &$_LIT\n         GBLB  &$_FEAT(16)             FEATURES\n.*                                       1 LITERALS\n.*                                       2 REGISTER (BIN)\n.*                                       3 REGISTER (HEX)\n.*                                       4 PACKED\n.*                                       5 JDATE\n.*                                       6 BINARY\n.*                                       7 HEX\n.*                                       8 NUMERIC\n.*                                       9 LEFT JUST (NUMERIC)\n.*                                       10 LEADING ZEROES\n.*                                       11 TRUNCATE (CHAR STRING)\n.*                                       12 %TIME\n         GBLC  &$_LITS(9999)           LITERALS\n         LCLA  &I,&J,&N\n         AIF   (T'&INTO EQ 'O' AND N'&SYSLIST EQ 1                     X\n               AND '&SYSLIST(1,1)' EQ 'GENERATE').GENL\n&LABEL   SETC  'IHB&SYSNDX'            STEM FOR LOCAL LABELS\n&LQ      SETC  'L'''                   LENGTH ATTRIBUTE\n&STR     SETC  '  R&STRING_MACRO_VERSION'\n&NAME    BAS   R14,$STRING&STR         CALL @STRING SUB-ROUTINE\n         AIF   (N'&SYSLIST EQ 0).ERR1  NO POSITIONAL OPERANDS, ERROR\n         AIF   (T'&INTO EQ 'O').ERR2   NO RECEIVING FIELD, ERROR\n         AIF   (N'&INTO GT 2).ERR2     INTO=(A,32,BLURB)\n         DC    AL2((&LABEL.P-*)/2)     OFFSET TO FIELD DESCRIPTORS\n         AIF   (D'$LITERAL).LOCTR2     NOT FIRST TIME, JUMP\n$LTORG   LOCTR                         ADDRESSABLE CONSTANTS\n$FARRTNE LOCTR                         FAR ROUTINES\n.LOCTR2  ANOP\n$LITERAL LOCTR                         NON-ADDRESSABLE CONSTANTS\n&TO1     SETC  '&INTO(1)'\n&TO2     SETC  '&LQ&INTO'\n         AIF   (N'&INTO EQ 1).PUNTO8            JUMP IF INTO=XXX\n         AIF   ('&INTO(1)'(1,1) NE '(').PUNTO3  JUMP IF INTO=(XXX,44)\n&TO1     SETC  '0&INTO(1)'                              INTO=((R3),44)\n.PUNTO3  ANOP\n&TO2     SETC  '&INTO(2)'                               INTO=(XXX,LL)\n         AIF   ('&INTO(2)'(1,1) NE '(').PUNTO8  JUMP IF INTO=(XXX,44)\n&TO2     SETC  '0&INTO(2)'                              INTO=(XXX,(R1))\n.PUNTO8  ANOP\n&LABEL.P DC    S(&TO1,&TO2)\n.*--------------------------------------------------------------------*\n.*-------      FIELDS       ------------------------------------------*\n.*--------------------------------------------------------------------*\n         LCLB  &LAST,&BIN,&HEX,&REG,&PACKED,&LEFT,&ZERO,&TRUNC\n&I       SETA  1\n.*LOOP\n.LOOP1   ANOP\n         ACTR  200                            SYSDEBUG/DIAG055\n         AIF   (N'&SYSLIST(&I) GT 3).FLD990   TOO MANY SUB-OPERANDS\n&LAST    SETB  (&I EQ N'&SYSLIST)                LOOP\n         AIF   ('&SYSLIST(&I)'(1,1) EQ '''').LIT00\n         AIF   ('&SYSLIST(&I)'(K'&SYSLIST(&I),1) EQ '''').LIT01\n.*--------------------------------------------------------------------*\n.*       PROCESS FIRST SUBPARAMETER (ADDRESS)                         *\n.*--------------------------------------------------------------------*\n&P1S     SETC  '&SYSLIST(&I,1)'\n&P2L     SETC  '0'                     INPUT LENGTH\n&P3L     SETC  '0'                     OUTPUT LENGTH\n         AIF   ('&SYSLIST(&I)'(1,1) GE '0').FLD180 SPACES\n         AIF   ('&SYSLIST(&I)' EQ '%TIME').FLD190 %TIME\n         AIF   ('&SYSLIST(&I,1)'(1,1) NE '(').FLD115 (R2)\n         AIF   (T'&SYSLIST(&I,2) EQ 'O').FLD250\n&P1S     SETC  '0&SYSLIST(&I,1)'       CHANGE (R1) TO 0(R1)\n.FLD115  ANOP\n.*\n.*       EXTRACT RBCDE FROM PRB.RBCDE (HLASM)\n.*\n&L       SETA  1\n.*--LOOP\n.FLD131  AIF   ('&P1S'(&L,1) EQ '.').FLD133\n&L       SETA  &L+1\n         AIF   (&L LT K'&P1S).FLD131\n.*--ENDLOOP\n&P2L     SETC  '&P1S'                    ABCDEF FROM ABCDEF\n         AGO   .FLD134\n.FLD133  ANOP\n&P2L     SETC  '&P1S'(&L+1,K'&P1S-&L)    RBCDE FROM PRB.RBCDE\n.FLD134  ANOP\n.*\n         AIF   (T'&SYSLIST(&I,2) NE 'O').FLD200\n.*\n         AIF   (NOT D'&P2L).FLD140\n&P2C     SETC  T'&P2L\n.*MNOTE *,'&P1 &P2C'\n         AIF   ('&P2C' EQ 'F' OR '&P2C' EQ 'H' OR '&P2C' EQ 'P').FLD220\n         AIF   ('&P2C' EQ 'G').FLD210  FL2\n.FLD140  ANOP\n.*\n.*       EXTRACT PSATOLD FROM PSATOLD-PSA\n.*\n&L       SETA  1\n.*--LOOP\n.FLD141  AIF   ('&P2L'(&L,1) EQ '-').FLD143\n         AIF   ('&P2L'(&L,1) EQ '+').FLD143\n&L       SETA  &L+1\n         AIF   (&L LT K'&P2L).FLD141\n.*--ENDLOOP\n&P2L     SETC  '&LQ&P2L'               L'ABCDEF\n         AGO   .FLD300\n.FLD143  ANOP\n&P2L     SETC  '&LQ'.'&P2L'(1,&L-1)    L'PSATOLD FROM PSATOLD-PSA\n         AGO   .FLD300\n.*\n.FLD180  AIF   ('&SYSLIST(&I)'(K'&SYSLIST(&I),1) NE 'X').FLD800\n&P2L     SETC  '&SYSLIST(&I)'(1,K'&SYSLIST(&I)-1) 12\n         AIF   (&LAST).FLD186\n         DC    X'60',AL1(&P2L)         BLANKS\n         AGO   .LIT90\n.FLD186  DC    X'E0',AL1(&P2L),0S(0)   BLANKS\n         AGO   .LIT90\n.*\n.FLD190  ANOP                          %TIME\n&P1S     SETC  '1(14)'                 %TIME\n&$_FEAT(12) SETB 1                     %TIME\n         AGO   .FLD800\n.*--------------------------------------------------------------------*\n.*       PROCESS SECOND SUBPARAMETER (LENGTH/TYPE)                    *\n.*--------------------------------------------------------------------*\n.FLD200  AIF   (T'&SYSLIST(&I,2) EQ 'O').FLD300 NO LENGTH SPECIFIED\n&P2C     SETC  '&SYSLIST(&I,2)'\n         AGO   .FLD220\n.*T'&P1=G\n.FLD210  ANOP\n&L       SETA  L'&SYSLIST(&I)          T'&P1 = 'G'\n&P2C     SETC  'FL&L'                  T'&P1 = 'G'\n.*\n.FLD220  ANOP\n&P2L     SETC  '0&P2C'                 (R2) LENGTH\n         AIF   ('&P2C'(1,1) EQ '(').FLD300\n&P2L     SETC  '&P2C'                  3(R2) LENGTH\n         AIF   ('&P2C'(K'&P2C,1) EQ ')').FLD300\n&P2L     SETC  '0'\n&PACKED  SETB  ('&P2C' EQ 'P')\n         AIF   (&PACKED).FLD290\n&P2L     SETC  '1'\n         AIF   ('&P2C' EQ 'FL1').FLD240\n&P2L     SETC  '3'\n         AIF   ('&P2C' EQ 'FL2' OR '&P2C' EQ 'H').FLD240\n&P2L     SETC  '7'\n         AIF   ('&P2C' EQ 'FL3').FLD240\n&P2L     SETC  '15'\n         AIF   ('&P2C' EQ 'F').FLD240\n&P2L     SETC  '&P2C'                  IMMEDIATE LENGTH, FIELD\n         AGO   .FLD300\n.*\n.FLD240  ANOP                          BINARY VARIABLE\n&BIN     SETB  1\n         AGO   .FLD300\n.*\n.FLD250  ANOP                          REGISTER CONTENT\n&REG     SETB  1\n         AGO   .FLD300\n.*\n.FLD290  ANOP                          PACKED\n&P2L     SETC  '1'\n.*--------------------------------------------------------------------*\n.*       PROCESS THIRD SUBPARAMETER (OUTPUT FORMAT)                   *\n.*--------------------------------------------------------------------*\n.FLD300  AIF   (T'&SYSLIST(&I,3) EQ 'O').FLD800\n&HEX     SETB  ('&SYSLIST(&I,3)' EQ 'X') HEXADECIMAL\n&TRUNC   SETB  ('&SYSLIST(&I,3)' EQ 'T') TRUNCATE\n         AIF   (&HEX OR &TRUNC).FLD800\n.*\n&P3C     SETC  '&SYSLIST(&I,3)'\n&P3L     SETC  '248'\n         AIF   ('&P3C' EQ 'YYYY-MM-DD' AND &PACKED).FLD308\n&P3L     SETC  '249'\n         AIF   ('&P3C' EQ 'YYYYMMDD' AND &PACKED).FLD308\n&P3L     SETC  '250'\n         AIF   ('&P3C' EQ 'YY/MM/DD' AND &PACKED).FLD308\n&P3L     SETC  '251'\n         AIF   ('&P3C' EQ 'DD/MM/YY' AND &PACKED).FLD308\n&P3L     SETC  '252'\n         AIF   ('&P3C' EQ 'MM/DD/YY' AND &PACKED).FLD308\n&P3L     SETC  '253'\n         AIF   ('&P3C' EQ 'YYMMDD'   AND &PACKED).FLD308\n&P3L     SETC  '0'\n         AIF   (T'&SYSLIST(&I,2) NE 'N').FLD310\n         MNOTE 8,'EDIT PATTERN NOT ALLOWED WITH CHARACTER STRING'\n         AGO   .FLD310\n.FLD308  ANOP\n&$_FEAT(5) SETB 1                      JDATE\n         AGO   .FLD800\n.*--LOOP\n.FLD310  AIF   ('&P3C'(1,1) EQ 'R').FLD318       DEFAULT\n         AIF   ('&P3C'(1,1) EQ 'B').FLD318       DEFAULT\n         AIF   ('&P3C'(1,1) NE 'L').FLD311\n&LEFT    SETB  1\n         AGO   .FLD318\n.FLD311  AIF   ('&P3C'(1,1) NE 'Z').FLD312\n&ZERO    SETB  1\n         AGO   .FLD318\n.FLD312  AIF   ('&P3C'(1,1) LT '0').FLD993\n&P3L     SETC  '&P3L'.'&P3C'(1,1)\n.FLD318  ANOP\n.*MNOTE *,'&SYSLIST(&I) P3C=/&P3C/ P3L=/&P3L/'\n&P3C     SETC  '&P3C'(2,K'&P3C-1)     STRIP OFF FIRST CHARACTER\n         AIF   (K'&P3C GT 0).FLD310\n.*--ENDLOOP\n.*--------------------------------------------------------------------*\n.FLD800  ANOP\n&NUMERIC SETB  (&BIN OR &PACKED OR (&REG AND NOT &HEX))\n&TRUNC   SETB  (&TRUNC OR (&LEFT AND NOT &NUMERIC))\n&LEFT    SETB  (&LEFT AND &NUMERIC)\n         AIF   (NOT &NUMERIC).FLD810\n         AIF   (&LEFT OR '&P3L' NE '0').FLD810\n&P3L     SETC  '7'                     DEFAULT OUTPUT LENGTH ((R3))\n         AIF   (&REG).FLD810\n&P3L     SETC  '3'                     DEFAULT OUTPUT LENGTH\n         AIF   ('&P2C' EQ 'FL1').FLD810\n&P3L     SETC  '5'                     DEFAULT OUTPUT LENGTH\n         AIF   ('&P2C' EQ 'H' OR '&P2C' EQ 'FL2').FLD810\n&P3L     SETC  '7'                     DEFAULT OUTPUT LENGTH\n.FLD810  ANOP\n&FLAG    SETA  &HEX*8+&BIN*4+&PACKED*2+&REG*1\n&LEN2    SETA  &TRUNC*128+&LEFT*128+&ZERO*64+&P3L\n&$_FEAT(2) SETB (&$_FEAT(2) OR (&REG AND NOT &HEX))   REGISTER (BIN)\n&$_FEAT(3) SETB (&$_FEAT(3) OR (&REG AND &HEX))       REGISTER (HEX)\n&$_FEAT(4) SETB (&$_FEAT(4) OR &PACKED)               PACKED\n&$_FEAT(6) SETB (&$_FEAT(6) OR &BIN)                  BINARY\n&$_FEAT(7) SETB (&$_FEAT(7) OR (&HEX AND NOT &REG))   HEX\n&$_FEAT(8) SETB (&$_FEAT(8) OR &NUMERIC)              BIN,PACKED\n&$_FEAT(9) SETB (&$_FEAT(9) OR (&LEFT AND &NUMERIC))\n&$_FEAT(10) SETB (&$_FEAT(10) OR &ZERO)\n&$_FEAT(11) SETB (&$_FEAT(11) OR &TRUNC)\n&BIN     SETB  0                    RESET FLAGS\n&HEX     SETB  0                    RESET FLAGS\n&REG     SETB  0                    RESET FLAGS\n&PACKED  SETB  0                    RESET FLAGS\n&LEFT    SETB  0                    RESET FLAGS\n&ZERO    SETB  0                    RESET FLAGS\n&TRUNC   SETB  0                    RESET FLAGS\n         AIF   (&FLAG GE 10).FLD995\n         AIF   (&LAST).FLD816\n         DC    X'0&FLAG',AL1(&LEN2),SL2(&P1S,&P2L)\n         AGO   .LIT99\n.FLD816  DC    X'8&FLAG',AL1(&LEN2),SL2(&P1S,&P2L),0S(0)\n         AGO   .LIT99\n.FLD990  MNOTE 12,'OPERAND &I HAS TOO MANY SUB-OPERANDS'\n         AGO   .LIT99\n.FLD993  MNOTE 8,'THIRD SUBPARAMETER IS INVALID: ''&SYSLIST(&I,3)'''\n         AGO   .LIT99\n.FLD995  MNOTE 8,'Invalid Combination of Attributes: &SYSLIST(&I)'\n         AGO   .LIT99\n.*--------------------------------------------------------------------*\n.*------------ LITERALS ----------------------------------------------*\n.*--------------------------------------------------------------------*\n.LIT00   ANOP\n&LIT     SETC  'C&SYSLIST(&I)'\n         AGO   .LIT09\n.LIT01   ANOP\n&LIT     SETC  '&SYSLIST(&I)'\n.LIT09   ANOP                              calculate length of literal\n&J       SETA  3\n&L       SETA  0\n         ACTR  K'&LIT+K'&LIT+100\n         AIF   ('&LIT'(1,1) EQ 'X').LIT11X\n.*LOOP\n.LIT11C  AIF   ('&LIT'(&J,1) NE '''' AND '&LIT'(&J,1) NE '&&').LIT12C\n&J       SETA  &J+1\n.LIT12C  ANOP\n&J       SETA  &J+1\n&L       SETA  &L+1\n         AIF   (&J LT K'&LIT).LIT11C\n.*ENDLOOP\n         AGO   .LIT15\n.*LOOP\n.LIT11X  AIF   ('&LIT'(&J,1) EQ ',').LIT12X\n&L       SETA  &L+1\n.LIT12X  ANOP\n&J       SETA  &J+1\n         AIF   (&J LT K'&LIT).LIT11X\n.*ENDLOOP\n&L       SETA  (&L+1)/2\n.LIT15   ANOP                               generate in-line literal\n         AIF   (&L GT 5).LIT40\n         AIF   (&LAST).LIT16\n         DC    X'4&L',&LIT\n         AGO   .LIT90\n.LIT16   DC    X'C&L',&LIT,0S(0)\n         AGO   .LIT90\n.LIT40   ANOP                                  check literal table\n         AIF   (&$_LIT EQ 0).LIT50\n&N       SETA  1\n         ACTR  &$_LIT*3+200\n.LIT41   AIF   ('&LIT' EQ '&$_LITS(&N)').LIT80       LOOP\n&N       SETA  &N+1                                  LOOP\n         AIF   (&N LE &$_LIT).LIT41                  LOOP\n.LIT50   ANOP\n&$_LIT   SETA  &$_LIT+1\n&$_LITS(&$_LIT) SETC '&LIT'\n&N       SETA  &$_LIT\n.LIT80   ANOP                               generate remote literal\n&N       SETA  &N+1000\n         AIF   (&LAST).LIT86\n         DC    X'40',AL1(&L),AL2($LIT&N-*)\n         AGO   .LIT90\n.LIT86   DC    X'C0',AL1(&L),AL2($LIT&N-*),0S(0)\n.LIT90   ANOP\n&$_FEAT(1) SETB 1                      LITERAL\n.LIT99   ANOP\n.*--------------------------------------------------------------------*\n&I       SETA  1+&I                              LOOP\n         AIF   (&I LE N'&SYSLIST).LOOP1          LOOP\n.*ENDLOOP\n&SYSLOC  LOCTR\n         AGO   .MEND\n.ERR1    MNOTE 12,'AT LEAST ONE INPUT FIELD MUST BE SPECIFIED'\n         AGO   .MEND\n.ERR2    MNOTE 12,'INVALID OUTPUT AREA SPECIFICATION'\n         AGO   .MEND\n.**********************************************************************\n.*       GENERATE: GENERATE LITERALS AND PROCESSING ROUTINE           *\n.**********************************************************************\n.GENL    ANOP\n         AIF   (N'&SYSLIST(1) GT 3).GENL1R\n&OPT2    SETC  '&SYSLIST(1,2)'\n         AIF   ('&OPT2' NE '' AND '&OPT2' NE 'AR_MODE'                 X\n               AND '&OPT2' NE 'NO_CSECT').GENL1R\n&OPT3    SETC  '&SYSLIST(1,3)'\n         AIF   ('&OPT3' NE '' AND '&OPT3' NE 'LOCTR').GENL1R\n         AIF   ('&OPT2' EQ 'NO_CSECT' AND '&OPT3' EQ 'LOCTR').GENL1R\n         AGO   .GENL1D\n.GENL1R  MNOTE 12,'Invalid GENERATE options, default used'\n&OPT2    SETC  ''\n&OPT3    SETC  ''\n.GENL1D  ANOP\n&STRBLANKS SETA 2\n         AIF   (D'$LTORG).GENL1F             CSECT-ONLY\n&$_FEAT(1) SETB 1,1,1,1,1,1,1,1,1,1,1,1\n.GENL1F  ANOP\n&ALLFEAT SETC  '&$_FEAT(1)&$_FEAT(2)&$_FEAT(3)&$_FEAT(4)'\n&ALLFEAT SETC  '&ALLFEAT&$_FEAT(5)&$_FEAT(7)&$_FEAT(6)&$_FEAT(8)'\n&ALLFEAT SETC  '&ALLFEAT&$_FEAT(9)&$_FEAT(10)&$_FEAT(11)&$_FEAT(12)'\n&STR     SETC  '&STRING_MACRO_VERSION'\n         MNOTE *,'STRING R&STR - FEATURES GENERATED: &ALLFEAT'\n         AIF   (&$_LIT EQ 0).GENL3\n$LITERAL LOCTR\n.GENL2   ANOP                                LOOP\n&N       SETA  &N+1                          LOOP\n&I       SETA  &N+1000                       LOOP\n$LIT&I   DC    &$_LITS(&N)\n         AIF   (&N LT &$_LIT).GENL2          LOOP\n.GENL3   ANOP\n         AIF   ('&OPT2' EQ 'NO_CSECT').GENL8\n&ARMODE  SETB  ('&OPT2' EQ 'AR_MODE')\n.**********************************************************************\n.*                                                                    *\n.*       STRING SUB-ROUTINE                                           *\n.*                                                                    *\n.*             CAUTION: BYTES 49-72 OF THE CALLER'S SAVE AREA         *\n.*                      (R7-R12 SLOTS) ARE USED AS WORK SPACE         *\n.*                                                                    *\n.**********************************************************************\n         AIF   ('&OPT3' EQ 'LOCTR').GENL4L\n@STRING  CSECT\n@STRING  RMODE ANY\n         AGO   .GENL4X\n.GENL4L  PUSH  USING                   GENERATE,LOCTR\n         DROP\n@STRING@ LOCTR\n@STRING  DS    0H                      ALIGNMENT\n.GENL4X  ANOP\n@00      EQU   0                       WORK REGISTER\n@01      EQU   1                       WORK REGISTER\n@02      EQU   2                       WORK REGISTER\n@03      EQU   3                       WORK REGISTER\n@04      EQU   4                       WORK REGISTER\n@05      EQU   5                       WORK REGISTER\n@06      EQU   6                       WORK REGISTER\n         AIF   (NOT &ARMODE).ARMODE1X\n@07      EQU   7                       WORK REGISTER\n@08      EQU   8                       WORK REGISTER\n@09      EQU   9                       WORK REGISTER\n@10      EQU   10                      WORK REGISTER\n@11      EQU   11                      WORK REGISTER\n@12      EQU   12                      WORK REGISTER\n.ARMODE1X ANOP\n@13      EQU   13                      CALLER'S SAVE AREA\n@14      EQU   14                      WORK REGISTER\n@15      EQU   15                      BASE REG\n         USING @STRING,@15\n         USING @STRSAVE,@13\n         B     @STR003                 BRANCH AROUND EYE-CATCHER\n         AIF   (&ARMODE).ARMODE2Y\n         DC    C'@STRING/370 R&STRING_MACRO_VERSION &ALLFEAT',0H'0'\n@STR003  STM   @14,@06,12(@13)         Save caller's registers\n         SLR   @06,@06                 R6=0\n&LAE     SETC  'LA'\n         AGO   .ARMODE2X\n.ARMODE2Y ANOP\n         DC    C'@STRING/390 R&STRING_MACRO_VERSION &ALLFEAT',0H'0'\n@STR002  DC    H'2'\n@STR003  STM   @14,@12,12(@13)         SAVE REGS (DEBUGGING ONLY)\n.*+++    BSM   @14,0                   Set AMODE when invoked via BAL\n         AH    @14,@STR002-@STRING(@15,0) POINT PAST PARM-LIST OFFSET\n         BAKR  @14,0                   SAVE REGS AND RETURN ADDRESS\n         BCTR  @14,0                   ADJUST ADDR OF PARM LIST OFFSET\n         BCTR  @14,0                   ADJUST ADDR OF PARM LIST OFFSET\n         LAE   @06,0                   R6=0 AR6=0\n         CPYA  @14,@06                 AR14=0\n         CPYA  @15,@06                 AR15=0\n&LAE     SETC  'LAE'\n.ARMODE2X ANOP\n         ICM   @06,B'0011',0(@14)      PICK UP PARM-LIST 1/2 OFFSET\n         ALR   @06,@06                 PICK UP PARM-LIST OFFSET\n         ALR   @06,@14                 R6 NOW POINTS TO PARM LIST\n         USING @STRSCON,@06\n         &LAE  @02,@STRSCON            RESOLVE FIRST SCON (ADDR)\n         BAL   @14,@STRS2A             GET ADDRESS IN R2\n         &LAE  @04,0(,@02)             KEEP ADDRESS OF \"INTO\" FIELD\n         L     @14,12(,@13)            RESTORE ADDR OF STRING MACRO\n         OI    0(@04),0                GET CLEAN S0C4 IF ADDRESS IS BAD\n         &LAE  @02,@STRFLEN            RESOLVE SECOND S-CON (LEN)\n         BAL   @14,@STRS2A             GET LENGTH IN R2\n         LR    @05,@02                 KEEP LENGTH OF \"INTO\" FIELD\n         CR    @05,@04                 END ADDRESS?\n         BL    @STR282                 NO, JUMP\n         SR    @05,@04                 CALCULATE LENGTH\n         AIF   (NOT &ARMODE).ARMODE5N\n@STR282  MSTA  @04                     SAVE R4,R5 ON LINKAGE STACK\n.*SLAC   DC    X'B247,0040'            SLAC assembler error\n         AGO   .ARMODE5X\n.ARMODE5N ANOP\n@STR282  ST    @04,8(,@13)             SAVE ADDRESS FOR LATER\n.ARMODE5X ANOP\n.**********************************************************************\n.*       MOVE FIELDS TO OUTPUT AREA                                   *\n.**********************************************************************\n         &LAE  @06,@STRNEXT            POINT TO 1ST FIELD DESC\n         USING @STRPARM,@06\n.*LOOP\n@STR310  EQU   *\n         AIF   (NOT &$_FEAT(1)).FEAT1A\n         TM    @STRFLAG,@STRLIT        IS THIS A LITERAL?\n         BO    @STR372                 YES, JUMP\n.FEAT1A  ANOP\n         AIF   (NOT &$_FEAT(2) AND NOT &$_FEAT(3)).FEAT23A\n         TM    @STRFLAG,@STRREG        REGISTER?\n         BO    @STR323                 YES, JUMP\n.FEAT23A ANOP\n         AIF   (NOT &$_FEAT(12)).FEAT12A\n         CLI   @STRSCON,X'E0'          IS IT %TIME ?\n         BE    @STR378                 YES, JUMP\n.FEAT12A ANOP\n.*\n.*       IT'S A FIELD (SCON)\n.*\n         &LAE  @02,@STRFLEN            RESOLVE SECOND S-CON (LEN)\n         BAL   @14,@STRS2A             GET LENGTH IN R2\n         AIF   (&$_FEAT(9)).FEAT9E1    (LEFT JUSTIFICATION, NUMERIC)\n         LTR   @03,@02                 KEEP/TEST LENGTH\n         BZ    @STR398                 ZERO LENGTH, DO NOT EDIT\n         AGO   .FEAT9E2\n.FEAT9E1 LTR   @03,@02                 KEEP/TEST LENGTH\n         BP    @STR313                 LENGTH POSITIVE, JUMP\n         TM    @STRLEN2,@STRLEFT       LEFT JUSTIFICATION?\n         BNO   @STR398                 NO, ZERO LENGTH IS NOT OK\n@STR313  EQU   *\n.FEAT9E2 ANOP\n         &LAE  @02,@STRSCON            RESOLVE FIRST SCON (ADDR)\n         BAL   @14,@STRS2A             GET ADDRESS IN R2\n         L     @14,12(,@13)            RESTORE ADDR OF STRING MACRO\n         CLI   0(@02),0                GET CLEAN S0C4 IF ADDRESS IS BAD\n         CR    @03,@02                 END ADDRESS?\n         BL    @STR314                 NO, JUMP\n         LA    @00,X'0080'             PSA ADDRESS\n         CLR   @02,@00                 PSA REFERENCE?\n         BL    @STR314                 YES, JUMP\n         SR    @03,@02                 CALCULATE LENGTH\n@STR314  EQU   *\n         AIF   (NOT &$_FEAT(6)).FEAT6A\n         TM    @STRFLAG,@STRBIN        BINARY FIELD?\n         BO    @STR328                 YES, JUMP\n.FEAT6A  ANOP\n         AIF   (NOT &$_FEAT(4)).FEAT4A\n         TM    @STRFLAG,@STRPACK       PACKED FIELD?\n         BO    @STR351                 YES, JUMP\n.FEAT4A  ANOP\n         AIF   (NOT &$_FEAT(7)).FEAT7A\n         TM    @STRFLAG,@STRHEX        EDIT IN HEX?\n         BO    @STR376                 YES, JUMP\n.FEAT7A  ANOP\n.*\n.*       TRUNCATE CHARACTER STRING\n.*\n         AIF   (NOT &$_FEAT(11)).FEAT11A\n         CLI   @STRLEN2,@STRLEFT       CHECK JUSTIFICATION, OUTPUT LEN\n         BNE   @STR390                 NO STRING TRUNCATION, JUMP\n         &LAE  @01,0(@03,@02)          FIRST BYTE AFTER FIELD\n@STR318  BCTR  @01,0                   DOWN 1 BYTE                 LOOP\n         CLI   0(@01),C' '             IS IT A SPACE ?             LOOP\n         BNE   @STR390                 LAST NON-BLANK BYTE         LOOP\n         BCT   @03,@STR318             LOOP UNTIL 1ST NON-BLANK    LOOP\n         B     @STR398                 BLANK FIELD, DO NOT EDIT\n         AGO   .FEAT11B\n.FEAT11A ANOP\n         AIF (&$_FEAT(2)+&$_FEAT(3)+&$_FEAT(4)+&$_FEAT(6) EQ 0).FEAT11B\n         B     @STR390                 EDIT\n.FEAT11B ANOP\n.*\n.*       REGISTER (R0-R13)\n.*\n         AIF   (NOT &$_FEAT(2) AND NOT &$_FEAT(3)).FEAT23B\n         AIF   (NOT &ARMODE).ARMODE7N\n@STR323  LH    @01,@STRSCON            REG NUMBER IN BITS 28-31\n         CLI   @STRSCON+1,@06          IS THIS R7-R13?\n         BH    @STR323R                YES, JUMP\n         LR    @07,@01                 SAVE R1 (R)\n         LAE   @10,0(,@04)             SAVE R4\n         LR    @11,@05                 SAVE R5\n         LAE   @12,0(,@06)             SAVE R6\n         EREG  @00,@06                 RELOAD CALLER'S R0-R6\n         EX    @07,@STR323L            COPY R0-R6 VALUE\n         LAE   @04,0(,@10)             RESTORE R4\n         LR    @05,@11                 RESTORE R5\n         LAE   @06,0(,@12)             RESTORE R6\n         B     @STR323T\n@STR323L LR    @00,*-*                 COPY VALUE FOR EDIT\n@STR323R EQU   *\n         EREG  @07,@12                 RESTORE CALLER'S R7-R12\n         EX    @01,@STR323L            COPY R7-R13 INTO R0\n         AGO   .ARMODE7X\n.ARMODE7N ANOP\n@STR323L LR    @00,*-*                 COPY VALUE FOR EDIT\n@STR323  LH    @01,@STRSCON            REG NUMBER IN BITS 28-31\n         EX    @01,@STR323L            COPY R7-R13 INTO R0\n         CLI   @STRSCON+1,@06+1        IS THIS R7-R13?\n         BNL   @STR323T                YES, JUMP\n         SLL   @01,2                   R1= 000000BB BASE * 4\n         L     @00,20(@01,@13)         PICK UP VALUE FOR R0-R6\n.ARMODE7X ANOP\n@STR323T EQU   *\n         AIF   (NOT &$_FEAT(3)).FEAT3R REG,HEX\n         AIF   (NOT &$_FEAT(2)).FEAT2H REG,BIN\n         TM    @STRFLAG,@STRHEX        EDIT IN HEX?\n         BNO   @STR330                 NO, EDIT FWD\n.FEAT2H  ANOP\n         STCM  @00,B'1111',@STRDWD-1   STORE IT FOR CVD/UNPK\n         LA    @03,8                   OUTPUT LENGTH\n         B     @STR376X                EDIT IN HEX\n.FEAT3R  ANOP\n         AIF   (NOT &$_FEAT(6)).FEAT23B\n         B     @STR330                 EDIT R0\n.FEAT23B ANOP\n.*\n.*       BINARY VARIABLE: @03 CONTAINS THE ICM MASK (1 3 7 F)\n.*\n         AIF   (NOT &$_FEAT(6)).FEAT6B\n@STR328M ICM   @00,*-*,0(@02)          **EXECUTED INSTRUCTION**\n@STR328  SLR   @00,@00\n         EX    @03,@STR328M            LOAD THE BINARY VARIABLE\n.FEAT6B  ANOP\n.*\n         AIF   (NOT &$_FEAT(2) AND NOT &$_FEAT(6)).FEAT6C\n@STR330  CVD   @00,@STRDWD             CONVERT VALUE TO DECIMAL\n         AIF   (NOT &$_FEAT(4)).FEAT6C\n         B     @STR361                 EDIT DWD\n.FEAT6C  ANOP\n.*\n.*       PACKED FIELD\n.*\n         AIF   (NOT &$_FEAT(4)).FEAT4B\n@STRZAP  ZAP   @STRDWD,0(*-*,@02)      MOVE TO @STRDWD\n@STR351  &LAE  @03,0(,@02)             FIRST BYTE OF PACKED FIELD\n         BALR  @14,0\n         TM    0(@03),X'0C'            IS THIS THE SIGN BYTE?\n         LA    @03,1(,@03)              (NEXT BYTE)\n         BNOR  @14                     NO, LOOP MORE\n         SLR   @03,@02                 GET LENGTH OF PACKED FIELD\n         BCTR  @03,0\n         EX    @03,@STRZAP             EXECUTE ZAP\n         AIF   (NOT &$_FEAT(5)).FEAT4B\n         CLI   @STRLEN2,248            JULIAN-TO-YYMMDD CONV?\n         BNL   @STR375                 YES, JUMP\n.FEAT4B  ANOP                          PACKED\n.*\n.*       EDIT @STRDWD (BIN, REG, PACKED)\n.*\n         AIF   (NOT &$_FEAT(8)).FEAT8B\n@STR361  IC    @00,@STRLEN2            OUTPUT LENGTH\n         LA    @03,X'003F'             MASK FOR \"AND\"\n         NR    @03,@00                 OUTPUT LENGTH\n         MVC   @STRWK16(16),@STRMASK   EDIT MASK\n.*\n.*       LEFT-JUSTIFICATION (NUMERIC)\n.*\n         AIF   (NOT &$_FEAT(9)).FEAT9B\n         TM    @STRLEN2,@STRLEFT       LEFT JUSTIFICATION?\n         BNO   @STR367                 NO, JUMP\n         &LAE  @01,@STRWK16+15         PREVENT BAD R1\n         EDMK  @STRWK16(16),@STRDWD    ZONED DECIMAL\n         &LAE  @02,0(,@01)             FIRST STRING POSITION\n         LTR   @03,@03                 CHECK OUTPUT LENGTH\n         BNZ   @STR363                 JUMP IF NOT ZERO\n.*       L0    (LEFT JUSTIFIED, NO PADDING)\n         &LAE  @03,@STRWK16+16         FIRST POSITION AFTER STRING\n         SR    @03,@02                 COMPUTE STRING LENGTH\n         B     @STR390                 MOVE FIELD TO OUTPUT LINE\n.*       L1-L63 (LEFT JUSTIFIED, PADDING)\n@STR363  CR    @03,@05                 COMPARE LENGTH TO REMAINING LEN\n         BNH   @STR364                 LARGE ENOUGH, JUMP\n         LR    @03,@05                 TOO BIG, TRUNCATE TO REM. LEN.\n@STR364  SR    @05,@03                 COMPUTE REMAINING LENGTH\n         AIF   (NOT &ARMODE).ARMODE8N\n         LAE   @08,0(,@04)             POINTER IN OUTPUT LINE\n         LR    @09,@03                 LENGTH WITH PADDING\n         AGO   .ARMODE8X\n.ARMODE8N ANOP\n         LR    @00,@04                 POINTER IN OUTPUT LINE\n         LR    @01,@03                 LENGTH WITH PADDING\n.ARMODE8X ANOP\n         LA    @03,@STRWK16+16         FIRST POSITION AFTER STRING\n         SR    @03,@02                 COMPUTE STRING LENGTH\n         B     @STR392                 MOVE FIELD TO OUTPUT LINE\n@STR367  EQU   *\n.FEAT9B  ANOP\n         AIF   (NOT &$_FEAT(10)).FEAT10B\n         TM    @STRLEN2,@STRZERO       LEADING ZEROES REQ'D?\n         BNO   @STR368                 NO, JUMP\n         MVI   @STRWK16,C'0'           YES, CHANGE X'40' TO C'0'\n@STR368  EQU   *\n.FEAT10B ANOP\n         ED    @STRWK16(16),@STRDWD    ZONED DECIMAL\n         &LAE  @02,@STRWK16+16         FIRST POSITION AFTER STRING\n         SR    @02,@03                 FIRST STRING POSITION\n.FEAT8B  ANOP\n.*\n.*       LITERAL (@STRSCON IS A 16-BIT OFFSET)\n.*       Short Literal (low-order 4 bits of @STRFLAG contains length)\n.*       BLANKS  (@STRSCON=ZERO)\n.*\n         AIF   (NOT &$_FEAT(1)).FEAT1B\n         B     @STR390                 MOVE STRING TO OUTPUT LINE\n@STR372  LA    @01,7                   mask for NR\n         &LAE  @02,@STRLEN2            1st byte of short literal\n         IC    @03,@STRFLAG            pick up flags+length\n         NR    @03,@01                 R3 has length of short literal\n         BNZ   @STR390                 short literal, go move it\n         SLR   @02,@02                 Clear Address Register\n         IC    @03,@STRLEN2            GET LITERAL LENGTH\n         TM    @STRFLAG,@STRX40        string of spaces?\n         BO    @STR390                 yes, go move them\n         ICM   @02,B'0011',@STRSCON    LOAD LITERAL OFFSET\n         LA    @02,@STRSCON(@02)       CONVERT OFFSET TO FULL ADDRESS\n.FEAT1B  ANOP\n.*\n.*       CONVERT JULIAN DATE TO YYMMDD\n.*\n         AIF   (NOT &$_FEAT(5)).FEAT5F\n         B     @STR390                 MOVE STRING TO OUTPUT LINE\n@STR375  LA    @00,248                 MASK FOR 'SLR'\n         SLR   @01,@01\n         IC    @01,@STRLEN2            248-255\n         SLR   @01,@00                 000-007\n         LA    @00,12                  L'@STR375W\n         MR    @00,@00                 COMPUTE OFFSET\n         &LAE  @01,@STR375W(@01)       ENTRY IN \"TR\" MASK TABLE\n         SLR   @03,@03\n         IC    @03,0(,@01)             LENGTH OF DATE (6, 8 OR 10)\n         ZAP   @STRDWD,@STRDWD         DATE=0000000?               @JDT\n         BNZ   @STR375B                NO, JUMP                    @JDT\n@STR375Z &LAE  @02,@STRBLANKS          WORK AREA\n&STRBLANKS SETA 10                     WE NEED AT LEAST 10 BLANKS\n         B     @STR390                 MOVE FIELD TO OUTPUT LINE\n@STR375W DC    AL1(10,C'-',0,1,2,3,8,4,5,8,6,7) YYYY-MM-DD   248\n         DC    AL1(8,C' ',0,1,2,3,4,5,6,7,8,8)  YYYYMMDD//   249\n         DC    AL1(8,C'/',2,3,8,4,5,8,6,7,8,8)  YY/MM/DD//   250\n         DC    AL1(8,C'/',6,7,8,4,5,8,2,3,8,8)  DD/MM/YY//   251\n         DC    AL1(8,C'/',4,5,8,6,7,8,2,3,8,8)  MM/DD/YY//   252\n         DC    AL1(6,C' ',2,3,4,5,6,7,8,8,8,8)  YYMMDD       253\n.*       DC    AL1(6,C' ',6,7,4,5,2,3,8,8,8,8)  DDMMYY       254\n.*       DC    AL1(6,C' ',4,5,6,7,2,3,8,8,8,8)  MMDDYY       255\n@STR375T DC    P'59,31,29,31,30,31,30,31,31,30,31,30,31'\n         DC    P'999'                  Prevent S0C7 with 90366\n@STR375B CLI   @STRDWD+4,X'01'         YEAR 2000 OR ABOVE?\n         BH    @STR375C                CC>01, JUMP (MUST BE 19 OR 20)\n         MVI   @STRDWD+4,X'20'         CC=01, CHANGE TO CC=20\n         BE    @STR375C                CC=01, USE CC=20\n         CLI   @STRDWD+4+1,X'50'       YY<50?\n         BL    @STR375C                YES, USE CC=20\n         MVI   @STRDWD+4,X'19'         NO, FORCE CC=19\n@STR375C UNPK  @STRWK16(5),@STRDWD+4(3) CCYY?\n         ZAP   @STRDWD+1(2),@STR375T+9(1) INIT MONTH COUNTER\n         &LAE  @02,@STR375T            TABLE OF MONTHS (NUMBER OF DAYS)\n         TM    @STRDWD+4+1,X'01'       ODD YEARS\n         BO    @STR375N                  AREN'T LEAP YEARS\n         TM    @STRDWD+4+1,X'12'       ZEROES IN 1980, ALL ONES IN 1992\n         BNM   @STR375L                MIXED IN 1982/1990\n.*       IF IT'S NOT A LEAP YEAR AND DDD>59, THEN ADD 1 TO DDD\n@STR375N CP    @STRDWD+4+2(2),@STR375T ARE WE PAST FEB 28 (DDD>59) ?\n         BNH   @STR375L                NO, JUMP\n         AP    @STRDWD+4+2(2),@STR375T+3(1) ADD 1 (FROM 31) TO DDD\n.*--LOOP WHILE DDD > 0\n@STR375L AP    @STRDWD+1(2),@STR375T+3(1)   ADD 1 (FROM 31) TO MONTH\n         LA    @02,2(,@02)             NEXT ENTRY IN \"MONTHS\" TABLE\n         SP    @STRDWD+4+2(2),0(2,@02) SUB DAYS-IN-MONTH FROM DDD\n         BP    @STR375L\n.*--ENDLOOP\n         AP    @STRDWD+4+2(2),0(2,@02) UNDO LAST \"SP\" INSTRUCTION\n         UNPK  @STRWK16+4(2),@STRDWD+1(2) FYFYFYFY,FMCM??\n         UNPK  @STRWK16+6(2),@STRDWD+6(2) FYFYFYFY,FMCMFDCD\n         MVZ   @STRWK16+1(7),@STRWK16     FYFYFYFY,FMCMFDCD\n         MVC   @STRWK16+8(1),1(@01)    SEPARATOR\n         &LAE  @02,@STRWK16+9          WORK AREA\n         MVC   0(10,@02),2(@01)        MOVE CORRESPONDING MASK\n         TR    0(10,@02),@STRWK16      CONVERT DATE TO THE RIGHT FORMAT\n.FEAT5F  ANOP                          JDATE\n.*\n.*       HEX STRING\n.*\n         AIF   (NOT &$_FEAT(7)).FEAT7B\n         B     @STR390                 MOVE STRING TO OUTPUT LINE\n@STR376M MVC   @STRDWD-1(*-*),0(@02)   PREVENT S0C4 IN UNPK\n@STR376  LA    @00,8                   MAX LENGTH\n         CLR   @03,@00                 CHECK LENGTH\n         BNH   @STR376B                JUMP IF LE 8\n         LR    @03,@00                 TRUNCATE TO MAXIMUM LENGTH\n@STR376B LR    @01,@03                 INPUT LENGTH\n         BCTR  @01,0\n         EX    @01,@STR376M            MOVE DATA TO SAFE STORAGE\n         ALR   @03,@03                 OUTPUT LENGTH\n         AGO   .FEAT37B\n.FEAT7B  ANOP\n         AIF   (NOT &$_FEAT(3)).FEAT37C\n         B     @STR390                 MOVE STRING TO OUTPUT LINE\n.FEAT37B ANOP\n@STR376X &LAE  @02,@STRWK16            WORK AREA\n         UNPK  0(9,@02),@STRDWD-1(5)   EXPAND SOURCE BYTES FOR \"TR\"\n         UNPK  8(9,@02),@STRDWD+3(5)   EXPAND SOURCE BYTES FOR \"TR\"\n         TR    0(16,@02),@STRHEXT-240  =C'0123456789ABCDEF'\n.FEAT37C ANOP\n.*\n.*       %TIME\n.*\n         AIF   (NOT &$_FEAT(12)).FEAT12B\n         B     @STR390                 MOVE STRING TO OUTPUT LINE\n@STRTIME DC    X'4021207A20207A20207A20204000'    0X.XX.XX.XX\n@STR378  LR    @02,@15                 SAVE BASE REG\n         TIME  DEC                     GET HHMMSSHH\n         LR    @15,@02                 RESTORE BASE REG\n         ST    @00,@STRDWD             STORE HHMMSSHH\n         MVC   @STRWK16(13),@STRTIME   MOVE EDIT MASK\n         ED    @STRWK16(13),@STRDWD    EDIT HH:MM:SS:HH\n         &LAE  @02,@STRWK16+1          WORK AREA\n         LA    @03,12                  HH:MM:SS:HH+ SPACE\n.FEAT12B ANOP\n.*MOVE\n@STR390  CR    @03,@05                 COMPARE LENGTH TO REMAINING LEN\n         BNH   @STR391                 LARGE ENOUGH, JUMP\n         LR    @03,@05                 TOO BIG, TRUNCATE TO REM. LEN.\n@STR391  SR    @05,@03                 COMPUTE REMAINING LENGTH\n         AIF   (NOT &ARMODE).ARMODE39N\n         LAE   @08,0(,@04)             POINTER IN OUTPUT LINE\n         LR    @09,@03                 PASS REMAINING LENGTH\n         AGO   .ARMODE39X\n.ARMODE39N ANOP\n         LR    @00,@04                 POINTER IN OUTPUT LINE\n         LR    @01,@03                 PASS REMAINING LENGTH\n.ARMODE39X ANOP\n         LTR   @02,@02                 BLANKS?\n         BNZ   @STR392                 NO, JUMP\n         SLR   @03,@03                 YES, ZERO LENGTH\n@STR392  ICM   @03,B'1000',@STRBLANKS  PAD WITH BLANKS\n         AIF   (NOT &ARMODE).ARMODE44N\n         MVCL  @08,@02                 MOVE FIELD TO OUTPUT LINE\n         LR    @04,@08                 NEW POINTER IN OUTPUT LINE\n         AGO   .ARMODE44X\n.ARMODE44N ANOP\n         MVCL  @00,@02                 MOVE FIELD TO OUTPUT LINE\n         LR    @04,@00                 NEW POINTER IN OUTPUT LINE\n.ARMODE44X ANOP\n@STR398  TM    @STRFLAG,@STRLAST       TEST LAST-ENTRY INDICATOR\n         BO    @STR399                 Done, exit\n         AIF   (NOT &$_FEAT(1)).FEAT1C\n         TM    @STRFLAG,@STRLIT+@STRX40 literal or spaces?\n         BM    @STR398L                Literal, not spaces\n         BZ    @STR398X                Neither literal nor spaces\n         LA    @06,@STRSCON            2-byte entry for blank spaces\n         B     @STR310                 PROCESS NEXT ENTRY\n@STR398L LA    @01,7                   mask for NR\n         IC    @03,@STRFLAG            pick up flags+length\n         NR    @03,@01                 R3 has length of short literal\n         BZ    @STR398T                not an in-line literal, jump\n         LA    @06,@STRLEN2(@03)       Skip VL parm for in-line literal\n         B     @STR310                 PROCESS NEXT ENTRY\n@STR398T LA    @06,@STRFLEN            4-byte parm for remote literal\n         B     @STR310                 PROCESS NEXT ENTRY\n.FEAT1C  ANOP\n@STR398X LA    @06,@STRNEXT            BUMP UP TO NEXT ENTRY\n         B     @STR310                 PROCESS NEXT ENTRY\n.*ENDLOOP\n.*\n.*       END-OF-LINE PROCESSING - PAD WITH BLANKS\n.*\n@STR399  SLR   @01,@01                 SET UP R1 FOR PADDING\n         ICM   @01,B'1000',@STRBLANKS  SET UP R1 FOR PADDING\n.***     DROP  @06,@13,@15\n         AIF   (&ARMODE).ARMODE52Y\n         LA    @14,2                   INCREMENT\n         AL    @14,12(,@13)            RETURN ADDRESS\n         LR    @15,@04                 CURRENT POINTER IN OUTPUT FIELD\n         SL    @15,8(,@13)             CALCULATE LENGTH USED\n         MVCL  @04,@00                 PAD WITH BLANKS\n         LM    @00,@06,20(@13)         RESTORE WORK REGISTERS\n         STM   @06+1,@13-1,48(@13)     MAKE SAVE AREA LOOK NORMAL\n         OI    15(@13),1               SIMULATE \"T\" OPTION OF RETURN\n         BR    @14                     RETURN TO CALLER\n         AGO   .ARMODE52X\n.ARMODE52Y ANOP\n         LA    @15,3                   MODIFIABLE AREA\n         ESTA  @14,@15                 R14 = START OF OUTPUT AREA\n         LR    @15,@04                 END OF OUTPUT AREA\n         SR    @15,@14                 R15 = LENGTH USED IN OUTPUT AREA\n         MVCL  @04,@00                 PAD WITH BLANKS\n         EREG  @00,@14                 RESTORE WORK REGISTERS\n         STM   @14,@12,12(@13)         MAKE SAVE AREA LOOK NORMAL\n         OI    15(@13),1               SIMULATE \"T\" OPTION OF RETURN\n         PR                            RETURN TO CALLER\n.ARMODE52X ANOP\n.*\n         AIF   (NOT (&$_FEAT(3) OR &$_FEAT(7))).FEAT37T\n@STRHEXT DC    C'0123456789ABCDEF'     HEX-TO-EBCDIC CONVERSION\n.FEAT37T ANOP\n         AIF   (NOT &$_FEAT(8)).FEAT8T\n@STRMASK DC    X'4020202020202020,2020202020202120'\n.FEAT8T  ANOP\n.**********************************************************************\n.*       Convert S-con to address                                     *\n.*             Input: GPR2 points to an S-CON in the remote parm list *\n.*             Output: GPR2 contains the address                      *\n.**********************************************************************\n@STRS2A  SLR   @00,@00\n         ICM   @00,B'0011',0(@02)      R0 = 0000BDDD\n         SRDL  @00,12                  R0 = 0000000B, R1= DDD.....\n         SRL   @01,20                  R1 = 00000DDD (DISPLACEMENT)\n         AIF   (&ARMODE).ARMODE88Y\n         CLI   0(@02),@06*16+15        R7-R13?\n         BH    @STRS2A3                YES, JUMP\n.*BASE REG IS R0-R6\n         LTR   @02,@00                 IS R0 THE BASE REG?\n         BNZ   @STRS2A2                NO, JUMP\n         LTR   @02,@01                 IS THIS A PSA ADDRESS?\n         BNZR  @14                     YES, GOBACK\n@STRS2A2 SLL   @02,2                   R2= 000000BB BASE * 4\n         L     @02,20(@02,@13)         PICK UP BASE REG VALUE\n         LA    @02,0(@02,@01)          ADD BASE REG VALUE TO DISPL\n         BR    @14\n.*BASE REG IS R7-R13\n@STRS2A3 LR    @02,@00                 R2= 0000000B (BASE REG NUMBER)\n         EX    @02,@STRS2A4            ADD BASE REG VALUE TO DISPL\n         BR    @14\n@STRS2A4 LA    @02,0(*-*,@01)          ADD BASE REG VALUE TO DISPL\n         AGO   .ARMODE88X\n.ARMODE88Y ANOP                        AR_MODE=YES\n         SLL   @00,2                   MULT BY 4\n         CLI   0(@02),@06*16+15        R7-R13?\n         BH    @STRS2A6                YES, JUMP\n.*BASE REG IS R0-R6\n         LTR   @02,@00                 IS R0 THE BASE REG?\n         BNZ   @STRS2A5                NO, JUMP\n         LTR   @02,@01                 IS THIS A PSA ADDRESS?\n         BNZR  @14                     YES, GOBACK\n         EREG  @00,@00                 POP R0\n         LAE   @02,0                   R2=0 AR2=0\n         LR    @02,@00                 PASS R0 VALUE\n         LA    @02,0(,@02)             CLEAN UP\n         BR    @14                     GOBACK\n.*BASE REG IS R1-R6\n@STRS2A5 LR    @07,@00                 SAVE R0 (B*4)\n         LR    @08,@01                 SAVE R1 (DDD)\n         LR    @09,@03                 SAVE R3\n         LAE   @10,0(,@04)             SAVE R4\n         LR    @11,@05                 SAVE R5\n         LAE   @12,0(,@06)             SAVE R6\n         EREG  @01,@06                 RELOAD CALLER'S R1-R6\n         EX    0,@STRS2A7-4(@07)       ADD BASE REG VALUE TO DISPL\n         LR    @03,@09                 RESTORE R3\n         LAE   @04,0(,@10)             RESTORE R4\n         LR    @05,@11                 RESTORE R5\n         LAE   @06,0(,@12)             RESTORE R6\n         BR    @14                     GOBACK\n.*BASE REG IS R7-R13\n@STRS2A6 LR    @02,@00                 R2= 0000000B (BASE REG NUMBER)\n         EREG  @07,@12                 RESTORE CALLER'S R7-R12\n         EX    0,@STRS2A7-4(@02)       ADD BASE REG VALUE TO DISPL\n         BR    @14                     GOBACK\n@STRS2A7 LAE   @02,0(@08,@01)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@08,@02)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@08,@03)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@08,@04)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@08,@05)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@08,@06)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@07)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@08)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@09)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@10)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@11)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@12)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@13)          ADD BASE REG VALUE TO DISPL\n.ARMODE88X ANOP\n         AIF   ('&OPT3' EQ 'LOCTR').GENL7L\n@STRBLANKS DC  CL((((*+&STRBLANKS+7-@STRING)/8)*8)-(*-@STRING))' '\n         AGO   .GENL7X\n.GENL7L  ANOP\n@STRBLANKS DC  CL&STRBLANKS.' '\n.GENL7X  ANOP\n@STRING_SIZE EQU *-@STRING             SIZE OF GENERATED CSECT\n         DROP  @06,@13,@15\n.**********************************************************************\n.*       WORK AREA (CALLER'S SAVE AREA)                               *\n.**********************************************************************\n@STRSAVE DSECT                         24-BYTE WORK AREA\n         DS    A(0,@STRSAVE,@STRSAVE,14,15,0,1,2,3,4,5,6)\n@STRWK16 DS    F'7,8,9,10'             WORK AREA\n@STRDWD  DS    D'1112'                 WORK AREA\n@STRPARM DSECT\n@STRFLAG DS    B                   +0  FORMAT, FLAGS\n@STRLAST EQU   X'80'                     LAST ENTRY\n@STRLIT  EQU   X'40'                     LITERAL, @STRSCON IS AN OFFSET\n@STRX40  EQU   X'20'                   String of Spaces\n.*             X'0F'                   CONVERSION REQUIRED\n.*                                     or length of short literal\n@STRHEX  EQU   X'08'                     HEXADECIMAL\n@STRBIN  EQU   X'04'                     BINARY\n@STRPACK EQU   X'02'                     PACKED\n@STRREG  EQU   X'01'                     REGISTER\n@STRLEN2 DS    B                   +1  FORMAT, OUTPUT LENGTH\n.*                                     or start of short literal\n@STRLEFT EQU   X'80'                     LEFT JUSTIFICATION\n@STRZERO EQU   X'40'                     LEADING ZEROES\n.*             X'3F'                     OUTPUT LENGTH, 0 MEANS TRUNC.\n@STRSCON DS    S                   +2  FIELD ADDRESS\n@STRFLEN DS    S                   +4  FIELD LENGTH\n@STRNEXT EQU   *                   +6\n         AIF   (NOT D'$LTORG).MEND99   CSECT-ONLY\n         AIF   (D'$STRING).MEND99      CSECT-ONLY\n$LTORG   LOCTR\n         AIF   ('&OPT3' EQ 'LOCTR').GENL9L\n         CNOP  0,4\n$STRING  BALR  @15,0                   LOCAL BASE\n         L     @15,6(@15,0)            ROUTINE ADDRESS           00\n         BR    @15                     GO TO @STRING             04\n         AGO   .GENL9\n.GENL8   ANOP                          GENERATE,NOCSECT\n&$_LIT   SETA  0                       DO NOT GENERATE LITERALS TWICE\n&$_FEAT(1) SETB 1,1,1,1,1,1,1,1,1,1,1,1   GENERATE=FULL\n$LTORG   LOCTR\n         CNOP  0,4\n$STRING  BALR  R15,0                   LOCAL BASE\n         L     R15,6(R15,0)            ROUTINE ADDRESS           00\n         BR    R15                     GO TO @STRING             04\n.GENL9   ANOP\n         DC    V(@STRING)              ROUTINE ADDRESS           06\n         AGO   .MEND\n.GENL9L  POP   USING                   GENERATE,LOCTR\n$STRING  BAS   R15,$STRING2\n         DC    Y(@STRING-*)            OFFSET TO @STRING ROUTINE\n$STRING2 AH    R15,0(R15,0)\n         BR    R15\n.MEND    AIF   ('&PRINT' EQ 'NOGEN').MEND99\n         POP   PRINT\n.MEND99  MEND\n         EJECT\n**********************************************************************\n**********************************************************************\n********* TEST PROGRAM FOR THE 'STRING' MACRO ************************\n**********************************************************************\n**********************************************************************\n**       STRING (GENERATE,AR_MODE)\n**       END\n         LCLA  &ASMH_HLASM\n         AIF   (T'&ASMH_HLASM EQ 'N').ASMH1X\n&SYSVER  SETC  'ASMH'\n&SYSDATC SETC  '20'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)\n.ASMH1X  ANOP\nTESTPGM  START X'027000'\nTESTPGM  AMODE 24                      (PRE-SMS PUT)\n         BALR  R12,0\n         USING *,R12\n LOAD EP=SYSDEBUG\n LR R15,R0\n BASSM R14,R15\n*STRING 1X,INTO=XXX\n         OPEN  (SYSPRINT,OUTPUT)\n         STRING 'Assembler is &SYSVER, DATE is &SYSDATC',INTO=XXX\n         PUT   SYSPRINT,XXX\nRBPREFIX EQU   *\nRBINTCOD EQU   *+6,2,C'H'\nASCBASID EQU   *+8,2,C'X'\n         L     R1,PSATOLD-PSA(0,0)\n         L     R1,0(,R1)               TCBRBP\n         STRING 'SVC',(RBINTCOD-RBPREFIX(R1),H,R3Z),                   X\n               1X,(WWWW,,T),' - ',     VV.MM OF SVC RTNE               X\n               ((R8),,X),1X,           COM-REG ADDR                    X\n               (ASCBASID,,X),1X,       ASID                            X\n               PARM1,1X,               MAIN PGM NAME                   X\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n*\n         LA    R2,XXX\n         STRING 1X,INTO=((R2),8)\n         MACRO                                       JDATE MACRO\n        @JDATE &DATE                                 JDATE MACRO\n         LA    R1,=P'&DATE'                          JDATE MACRO\n*** STRING ((R1),P),2X,((R1),P),INTO=XXX\n         STRING ((R1),P),2X,((R1),P,YYMMDD),INTO=XXX,                  X\n               3X,((R1),P,YY/MM/DD),                                   X\n               3X,((R1),P,DD/MM/YY),                                   X\n               3X,((R1),P,MM/DD/YY),                                   X\n               3X,((R1),P,YYYYMMDD),                                   X\n               3X,((R1),P,YYYY-MM-DD)\n         PUT   SYSPRINT,XXX                          JDATE MACRO\n         MEND                                        JDATE MACRO\n        @JDATE 90058\n        @JDATE 91059\n        @JDATE 93060\n        @JDATE 94365\n        @JDATE 80058\n        @JDATE 84059\n        @JDATE 88060\n        @JDATE 92061\n        @JDATE 00366\n         LA    R2,1234\n         STRING 'CVTPTR=X''',(CVTPTR,4,X),'''',INTO=XXX,               X\n               ' 1234=',((R2),,R4Z)\n         PUT   SYSPRINT,XXX\n         L     R1,CVTPTR(0,0)\n         STRING 'CVTDATE=',(56(R1),P,YYMMDD),INTO=XXX\n         PUT   SYSPRINT,XXX\n         LA    R0,1000\n         LA    R3,0033\n         STRING 'D1=/',D1,'/,WWWW=/',WWWW,'/',                         X\n               ((R3),,L),'/',((R3),,X),'/',((R0),,L),'/',              X\n               ((R3),,R9B),'/',INTO=XXX\n         LR    R4,R15                   LENGTH USED\n         PUT   SYSPRINT,XXX\n         STRING WWWW,                                                  X\n               (4(R13),4,X),'''',(4(R13),F),'''',                      X\n               (4(R13),F,L),'''',                                      X\n               (4(R13),F,L11),'''',                                    X\n               (4(R13),F,Z9),'''',                                     X\n               8X,'R4=',((R4),,L),      LENGTH USED                    X\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n         STRING %TIME,D1,'B12345678B',5X,(CTR1,P),1X,PARM1,1X,PARM2,   X\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n         LA    R3,22\n         STRING INTO=XXX,'CCC1234A',(D1,(R3)),'.',(CTR1,P,R7Z)\n         PUT   SYSPRINT,XXX\n         STRING C'DDN2(',(D1,,T),')',X'40C1C2,C3C4',                   +\n               ' PSATOLD=',(PSATOLD-PSA,,X),                           +\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n         AIF   ('&SYSVER' EQ 'ASMH').HLASM99\nPSABASE  USING PSA,R0\n         STRING 'PSATOLD=',(PSABASE.PSATOLD,,X),                       +\n               ' PSATOLD=',(PSATOLD-PSA,,X),                           +\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n.HLASM99 ANOP\n         BALR  R0,0\n         STRING 'R0=',((R0),,X),'   16(R0)=',(16(R0),4,X),INTO=XXX\n         PUT   SYSPRINT,XXX\n         STRING 'R0=',((R0),,X),'   CTR1=',(CTR1,P,R5B),INTO=XXX\n         PUT   SYSPRINT,XXX\n         SLR   R0,R0\n         STRING 'R0=',((R0),,X),'   CTR1=',(CTR1,P,R5B),INTO=XXX\n         PUT   SYSPRINT,XXX\n*\nAMODE31  LA    R12,0(,R12)             BALR->BASR\n         L     R15,=A(*+X'80000006')   AMODE=31\n         BSM   0,R15                   AMODE=31\n         L     R1,=A(@STRING)          point at CSECT\n         CLC   =C'/390',11(R1)         (GENERATE,AR_MODE) ?\n         BNE   EXIT                    no, prevent S0E0\n         DSPSERV CREATE,                                               X\n               NAME==CL8'STRING00',    C'STRING00'                     X\n               BLOCKS=HDRBLKS,         SIZE IN PAGES                   X\n               STOKEN=DSPCSTKN,                                        X\n               ORIGIN=DSPCORG\n         ALESERV ADD,STOKEN=DSPCSTKN,ALET=DSPCALET\n         LAM   R8,R8,DSPCALET          POINT TO THE DATA SPACE\n         L     R8,DSPCORG              SPACE ORIGIN (0 OR 4096)\n         SAC   512                     MODE=AR\n LAM R14,R6,TESTPGM+40                 S0E0-28\n         STRING WWWW,'AR_MODE WORKED OK',INTO=(2048(R8),100)\n         LAM   R2,R2,DSPCALET          POINT TO THE DATA SPACE\n         LR    R2,R8                   SPACE ORIGIN (0 OR 4096)\n         STRING (2048+L'WWWW(R2),30,T),INTO=XXX\n         SAC   0                       MODE=AR OFF\n         PUT   SYSPRINT,XXX            AR_MODE WORKS OK\n*\nEXIT     SLR   R15,R15\n         SVC   3                       GOBACK\nD1       DC    C'D1-----D1    '\nWWWW     DC    C'WWWW'\nCTR1     DC    P'1'\nPARM1    DC    C'<-PARM1->'\nPARM2    DC    C'<-PARM2->'\nXXX      DS    CL132\nDSPCSTKN DS    XL8                  0  AS TOKEN\nDSPCALET DS    F                    8  ALET\nDSPCORG  DS    F                   12  ORIGIN\nHDRBLKS  DC    F'100'\nCVTPTR   EQU   0016,4,C'A'\nSYSPRINT DCB   DSORG=PS,DDNAME=SYSPRINT,MACRF=PM,RECFM=FB,LRECL=121\nXYZ      DSECT\n         STRING GENERATE\n**       STRING (GENERATE,NO_CSECT) -\\\n**       STRING (GENERATE,AR_MODE)  -/\n**       STRING (GENERATE,,LOCTR)\n**       STRING (GENERATE,AR_MODE,LOCTR)\n**       STRING (GENERATE,NO_CSECT,LOCTR)    invalid combination\n         YREGS\nPSA      DSECT\nPSATOLD  EQU   *+X'21C',4,C'A'\n         END\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DISP=SHR,DSN=MVT.MACLIB           SAVE/GET          -DEL-\n//         DD DISP=SHR,DSN=SYS1.MACLIB                            -DEL-\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//*\n//GO      EXEC PGM=LOADER,PARM=PRINT,TIME=(,2)\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,DELETE)\n//SYSLOUT  DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n//ABNLTERM DD SYSOUT=*\n//ABNLIGNR DD DUMMY\n//SYSDEBUG DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n\n          +----------------------------------------+\n          +                                        +\n          +   Documentation for the STRING macro   +\n          +                                        +\n          +       Last update: 13 Dec 1999         +\n          +----------------------------------------+\n\n  The STRING macro is functionally similar to the COBOL DISPLAY\n  or PL/I PUT EDIT instructions.\n\n  Using STRING, you can concatenate any number of fields, edit\n  each of them if necessary, and get the result in the work area\n  you specify.\n\n  Formats:\n\n    (1) label  STRING {field_specification1}\n                      {,field_specification2}...\n                      ,INTO=workarea|(workarea,length)\n                      {,PRINT=GEN|NOGEN}\n\n    (2) label  STRING GENERATE\n                      {,PRINT=GEN|NOGEN}\n\n\n  field_specification\n\n    Each field to be printed is described as a positional\n    operand.  Each operand specifies the field address, its\n    length, and its formatting requirements.\n\n    Four field description formats are supported:\n\n      1.   symbol\n      2.   (symbol,length,format)\n      3.   (d(r)|(r),length,format)\n      4.   ((r),,format)\n      5.   'character string'\n\n  Symbol specifies the field address.  It must be an\n    S-type (relocatable) address.\n\n  d(r) may be used to specify the field address in S/370\n    base-displacement format.  If d is zero, it may be omitted.\n    If d(r) or (r) is used, length must also be specified.  R14\n    and R15 may not be used.  If d(0) is used, it is handled the\n    way the assembler does, i.e. R0 as a base register is assumed\n    to contain zero: 16(0) is equivalent to 16, CVTPTR or, X'10'.\n\n  ((r),,format) specifies that (r) contains the value\n    itself, not an address.  R14 and R15 may not be used.\n\n  'character string' specifies a literal enclosed in single quotes\n    as specified in a DC instruction.  Hex strings or character\n    strings are supported.  The following expressions are equivalent:\n    'ABC' C'ABC' X'C1C2C3'\n\n  Length specifies the length and/or the type of the input field.\n    It may be specified as an integer, a symbol, a register, or a\n    constant.  When used with symbol, it overrides the assembled\n    length and/or type.  Length is required if field is specified\n    as d(r) or (r).  If a zero length is specified, the field is\n    ignored.\n\n        nn   field length in bytes\n        H    half-word\n        F    full-word\n        FL1  1-byte binary integer\n        FL3  3-byte binary integer\n        P    packed field\n        (r)  length of character string (R0 thru R12)\n        d(r) length of character string (R1 thru R12)\n\n  Notes:  If the field address is specified as a symbol that\n          has been defined previously in the program, the symbol\n          type is known and there is no need to specify it.\n\n          If the length is specified as (r) or d(r) and the value\n          is greater than the address itself, (r) or d(r) is\n          considered to be the end address +1 instead of the length.\n\n          The length is not specified for packed fields.  The\n          @STRING subroutine scans the field left-to-right until it\n          finds a byte with a valid sign in the low-order 4 bits.\n\n          If symbol is an arithmetic expression and no length is coded,\n          the implicit length will be that of the first symbol in the\n          expression;  for example, if symbol is coded as PSATOLD-PSA,\n          then the implicit length will be L'PSATOLD.\n\n          All numeric items are assumed positive.\n\n  format  optionally indicates editing options that must\n          be applied to a field.\n\n      L        left justified\n      R        right justified\n      nn       output length\n      0        adjust length\n      Z        leading zeroes\n      B        leading/trailing blanks\n      T        truncate character string after last non-blank\n      X        display in hexadecimal\n      YYMMDD   convert julian date to YYMMDD\n      YY/MM/DD convert julian date to YY/MM/DD\n      DD/MM/YY convert julian date to DD/MM/YY\n      MM/DD/YY convert julian date to MM/DD/YY\n      YYYYMMDD convert julian date to YYYYMMDD\n      YYYY-MM-DD convert julian date to YYYY-MM-DD\n\n    The default format depends on the field type:\n\n        Type                   Default Format\n\n        character string             L\n        FL1                          R3B\n        H or FL2                     R5B\n        other numeric fields         R7B\n\n    Note: L0 and T are equivalent for character strings.\n\n  'character string' is any character string enclosed in\n  single quotes.  Blank spaces may be specified as nnX,\n  where nn is the number of X'40' bytes you want to be\n  inserted in the output line.  %TIME may be specified to\n  obtain the current time in hh.mm.ss.hh format.\n\nINTO=workarea|(workarea,length)\n\n  INTO indicates the address and length of the output work area\n  into which the result of the concatenation should be placed\n  (left justified).  If the work area is too small, truncation\n  will occur.  If it is too large, it is padded with blanks.\n\n  The address may be a symbol, d(r) (S-type address) or (r).\n\n  The length may be specified as an integer, a symbol, a register,\n  or a constant; it is required if the address is coded as d(r) or\n  (r).  If length is not specified for a symbol-type address, the\n  assembled length of the symbol is used.\n\n  Upon return from STRING, R15 contains the length actually used\n  in the output work area (before padding).\n\nPRINT=GEN|NOGEN\n\n  This operand allows you to temporarily override the PRINT\n  specification (GEN or NOGEN).\n\nGENERATE (format 2)\n\n  The GENERATE format must be specified once at the end of the\n  program.  It generates the @STRING sub-routine as well as all\n  the literals specified in previous invocations of the macro.\n\n  The GENERATE format allows the specifications of the\n  AR_MODE, NO_CSECT and LOCTR options.\n\n         STRING GENERATE<,AR_MODE<,LOCTR>>>\n                          NO_CSECT\n\n  The following combinations are valid:\n\n         STRING GENERATE\n         STRING (GENERATE,NO_CSECT)\n         STRING (GENERATE,AR_MODE)\n         STRING (GENERATE,,LOCTR)\n         STRING (GENERATE,AR_MODE,LOCTR)\n\n  The AR_MODE option can be specified to generate a\n  @STRING module that supportd AR mode.  Example:\n\n         STRING (GENERATE,AR_MODE)\n\n  The NO_CSECT option can be specified to indicate that the\n  @STRING module should not be generated; only the literals\n  are generated in this case.  Example:\n\n         STRING (GENERATE,NO_CSECT)\n\n  The @STRING CSECT contains optional functions (such as %TIME or\n  julian date conversion) that are only generated if they have\n  been specified in the previous invocations of the STRING macro.\n\n  To generate of a @STRING CSECT that supports all of the optional\n  functions, two STRING GENERATE macros must be specified:\n\n         STRING (GENERATE,NO_CSECT)        Generate Literals\n         STRING GENERATE                   Generate CSECT\n\nExamples:\n\n     STRING 'ERROR===>',LINE1,'<=== POS ',((R6),,L0),INTO=WORKAREA\n\n     STRING 8X,C'ERRORS FOUND: ',(ERRORS,,L0),INTO=((R7),44)\n\n     STRING 'CVT ADDR IS ',(CVTPTR,4,X),X'40C1C2C3C4',INTO=LINE\n\n     LA    R5,WORK+16              end addr +1\n     STRING 'R4=',((R4),,X),INTO=(WORK,(R5)),PRINT=GEN\n\n     STRING '//JOBLIB DD DSN=',(DSN1,,T),',DISP=SHR',INTO=((R2),72)\n\n     PUT31 SYSLIN\n     LH    R0,SYSLIN+82            LRECL\n     STRING '   NAME  ',(4(R3),8,T),'(R)',INTO=((R1),(R0))\n\n     STRING GENERATE         Generate literals and sub-routine\n\n\nProgramming Notes:\n\n  A STRING macro generates only 6 bytes that need to be covered by\n  base registers.  More code is generated at the end of the\n  current CSECT (using LOCTR pseudo instruction), but this code\n  does not require addressability.  This is particularly useful\n  when STRING calls specify a large number of literals.\n\n  Additionally, STRING does not use A-type constants (ACON), but\n  S-type constants (SCON) which require symbols to be addressable\n  at the point in the program where STRING is issued.\n\n  While this reduces the number of base registers required to\n  cover the program's code and makes it easier to write reentrant\n  programs, it will produce assembly errors in the following\n  situations:\n\n  a.  STRING is used in more than one CSECT in the same assembly\n\n  b.  the CSECT in which STRING is used is longer than 64K\n\n  c.  symbols are not addressable at the point in the program\n      where STRING is issued\n\n  d.  the $STRING symbol (generated in the $LTORG LOCTR during the\n      GENERATE invocation of the STRING macro) is not addressable\n      in some of the STRING calls.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STRING64": {"ttr": 11274, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x15\\x00\\x07\\x01\\x06\\x11\\x1f\\x01\\x17\\x05O\\x16\\x11\\x06\\x85\\x05\\x88\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xf0\\xf8@@@@'", "ispf": {"version": "01.21", "flags": 0, "createdate": "2006-04-21T00:00:00", "modifydate": "2017-02-23T16:11:07", "lines": 1669, "newlines": 1416, "modlines": 0, "user": "SYSP08"}, "text": "*/GILBERTM JOB (ACCT#),STRING,\n*/ NOTIFY=&SYSUID,\n*/ CLASS=A,MSGCLASS=X,COND=(0,NE)\n*/ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF,\n*/*FLAG(PAGE0),NORXREF,NODXREF,                   HLASM R3\n*/ NOBATCH)\n***********************************************************************\n*                                                                     *\n* MACRO NAME = STRING                                                 *\n*                                                                     *\n* DESCRIPTIVE NAME = STRING Macro Instruction.                        *\n*                                                                     *\n* FUNCTION = Provide capabilities similar to PUT EDIT (of PL/I)       *\n*            or STRING (of COBOL) to assembler programs.              *\n*                                                                     *\n* STATUS = R617                                                       *\n*                                                                     *\n* AUTHOR = Gilbert Saint-flour <gsf@pobox.com>                        *\n*                                                                     *\n* ENVIRONMENT = SEE BELOW                                             *\n*                                                                     *\n*     AMODE = ANY                                                     *\n*     SCP   = OS/360, OS/VS, MVS/370, MVS/XA, MVS/ESA, OS/390 or z/OS *\n*     KEY   = ANY                                                     *\n*     MODE  = ANY                                                     *\n*     APF   = ANY                                                     *\n*                                                                     *\n* OPERATION = SEE DOCUMENTATION AT THE END OF THIS FILE               *\n*                                                                     *\n* INVOCATION = SEE DOCUMENTATION AT THE END OF THIS FILE              *\n*                                                                     *\n* NOTES = SEE DOCUMENTATION AT THE END OF THIS FILE                   *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n*  $301  FIX BUGS WITH (XYZ,,L8) AND INTO=((R1),(R2))                 *\n*  $302  GENERATE $DEBUG BOOT-STRAP IN FINAL_CALL INVOCATION          *\n*  $303  REPLACE @STRPAD WITH @STRBLANKS                              *\n*  $304  USE @00-@15 INSTEAD OF R0-R15 FOR REGISTER EQUATES           *\n*  $306  TAILOR @STRING CSECT TO PROGRAM'S REQUIREMENTS               *\n*        LITERALS CAN BE CODED AS 'ABC' OR C'ABC' OR X'C1C2C3'        *\n*        USE L'PSATOLD AS IMPLICIT LENGTH FOR (PSATOLD-PSA,,X)        *\n*  $307  FINAL_CALL OPTION CHANGED TO GENERATE                        *\n*        ADD NOCSECT AND LOCTR OPTIONS TO GENERATE CALL               *\n*  $308  USE L'RBCDE AS IMPLICIT LENGTH FOR (PRB.RBCDE,,X)            *\n*        PREVENT S0C4 WHEN ADDR IS BAD AND LENGTH IS ZERO             *\n*  $400  REORG THE CODE TO SIMPLIFY FEATURE SELECTION                 *\n*        BLANKS NO LONGER USED OR GENERATED                           *\n*  $401  GENERATE @STRHEXT WHEN ((REG),,X) ONLY HEX FIELD             *\n*  $502  @STRING ROUTINE REWRITTEN FOR MVS/ESA:                       *\n*        -  USE LINKAGE STACK TO STORE CALLER'S REGISTERS             *\n*        -  ADD SUPPORT FOR AR MODE                                   *\n*        -  @STRING now executes in caller's AMODE                    *\n*        -  Rename previous version to STRINGXA                       *\n*  $503  DATE CONVERSION TO YYYY-MM-DD FORMAT (ISO STANDARD)          *\n*        IMPROVE SUPPORT FOR AR MODE                                  *\n*  $504  SET &STRBLANKS TO 10 WHEN PROCESSING DATES                   *\n*  $505  Allow for 128K-offset                                        *\n*  $506  Remove literal from BAL instruction for HLASM R3             *\n*  $507  Merge STRINGXA code, add AR_MODE option                      *\n*        Change syntax of GENERATE call                               *\n*  $508  Compatibility with FLAG(PAGE0) in HLASM R3                   *\n*        Compatibility with pre-XA version of the SAVE macro          *\n*        Remove AMODE-based R2 cleanup in 370 mode                    *\n*  $509  Length of parm-list entries can vary between 2 and 6 bytes   *\n*        Short Literals (one to five bytes) are generated in parm list*\n*        Hex string can contain commas, e.g. X'12,3456,7890'          *\n*  $510  JDATE=90366 produces 90/13/01 instead of S0C7                *\n*  $511  Prevent ACTR error with long literals                        *\n*  $512  Packed fields no longer ignored when R0=0                    *\n*  $613  Basic support for z/Architecture (compat)              RS0306*\n*  $614  Name changed to STRING64                               RS0306*\n*        - Require a 64bit SaveArea (36F) (not compat !!!)      RS0306*\n*          Format F4SA                                          RS0306*\n*        - Support for FD                                       RS0306*\n*        - R&I instruction                                      RS0306*\n*        - Start using grande register                          RS0306*\n*        - AR_MODE is now the default                           RS0306*\n*        - z/Architecture required                              RS0306*\n*  $615  64bit register display                                 RS0207*\n*        - Support for AD                                       RS0207*\n*  $616  Allow for 2G offset                                    RS0909*\n*  $617  Merge fixes from STRING (GSF) 513-515                  RS0909*\n***********************************************************************\n         MACRO\n&NAME    STRING64 &INTO=,&PRINT=GEN\n         GBLC  &STRING_MACRO_VERSION\n&STRING_MACRO_VERSION SETC '617'       current version          RS0909\n         GBLA  &SYSALVL                ARCHLVL 0,1,2            RS0306\n         GBLC  &SYSAM64                AMODE64 YES/NO           RS0306\n         SYSSTATE TEST                 Test SYSSTATE            RS0306\n         LCLC  &BAS                    BAS or BRASL             RS0306\n         AIF   (&SYSALVL GT 1).ALVL1A  ARCHLVL greater 1 ?      RS0306\n         AIF   ('&SYSAM64' EQ 'YES').ALVL1A AMODE64 YES ?       RS0306\n&BAS     SETC  'BAS'                   Default                  RS0306\n         AGO   .ALVL1B                 jump around              RS0306\n.ALVL1A  ANOP                                                   RS0306\n&BAS     SETC  'BRASL'              Archlvl gt 1 or AMODE64=YES RS0306\n.ALVL1B  ANOP\n         AIF   ('&PRINT' EQ 'NOGEN').NOGEN\n         PUSH  PRINT\n         PRINT GEN\n.NOGEN   GBLA  &$_LIT\n         GBLA  &$_CSECT_NO             Number of CSECTs\n         GBLB  &$_FEAT(16)             FEATURES\n.*                                       1 LITERALS\n.*                                       2 REGISTER (BIN)\n.*                                       3 REGISTER (HEX)\n.*                                       4 PACKED\n.*                                       5 JDATE\n.*                                       6 BINARY\n.*                                       7 HEX\n.*                                       8 NUMERIC\n.*                                       9 LEFT JUST (NUMERIC)\n.*                                       10 LEADING ZEROES\n.*                                       11 TRUNCATE (CHAR STRING)\n.*                                       12 %TIME\n         GBLC  &$_LITS(9999)           LITERALS\n         GBLC  &$_CSECT(99)            CSECTs\n         GBLC  &$_LITS_CSECT(9999)     CSECT OF LITERALS\n         LCLA  &I,&J,&L,&N,&FLAG,&LEN2,&STRBLANKS\n         LCLB  &LAST,&BIN,&HEX,&REG,&PACKED,&LEFT,&ZERO,&TRUNC,&NUMERIC\n         LCLC  &LABEL,&LQ,&STR,&TO1,&TO2,&P1S,&P2C,&P2L,&P3C,&P3L\n         LCLC  &LIT,&ALLFEAT,&OPT2,&OPT3\n         LCLC  &LOCTR1,&SYSECT2\n         AIF   (T'&INTO EQ 'O' AND N'&SYSLIST EQ 1                     X\n               AND '&SYSLIST(1,1)' EQ 'GENERATE').GENL\n&LABEL   SETC  'IHB&SYSNDX'            STEM FOR LOCAL LABELS\n&LQ      SETC  'L'''                   LENGTH ATTRIBUTE\n&STR     SETC  '  R&STRING_MACRO_VERSION'\n&SYSECT2 SETC  '&SYSECT'\n         AIF   ('&SYSECT' NE '').CSECT21\n&SYSECT2 SETC  'NO_NAME'\n.CSECT21 ANOP\n         AIF   (&$_CSECT_NO GT 0).CSECT22\n&$_CSECT_NO SETA 1\n&$_CSECT(1) SETC '&SYSECT2'\n.CSECT22 ANOP\n&I       SETA  1\n.*loop\n.CSECT23 ANOP\n         AIF   ('&$_CSECT(&I)' EQ '&SYSECT2').CSECT27\n&I       SETA  1+&I\n         AIF   (&I LE &$_CSECT_NO).CSECT23\n.*endloop\n&$_CSECT_NO SETA &I\n&$_CSECT(&I) SETC '&SYSECT2'\n.*MNOTE ' &$_CSECT_NO &$_CSECT(&I) .'\n.CSECT27 ANOP                                         <=== New line\n         AIF   (&I EQ 1).CSECT28                      <=== New line\n.**      AIF   ('&SYSECT' EQ '&$_CSECT(&I)').CSECT28\n&STR     SETC  '_'.'&SYSECT2'          $STRING_CSECT2\n.CSECT28 ANOP\n&NAME    &BAS  R14,$STRING&STR         CALL @STRING SUB-ROUTINE\n         AIF   (N'&SYSLIST EQ 0).ERR1  NO POSITIONAL OPERANDS, ERROR\n         AIF   (T'&INTO EQ 'O').ERR2   NO RECEIVING FIELD, ERROR\n         AIF   (N'&INTO GT 2).ERR2     INTO=(A,32,BLURB)\n         DC    AL4(&LABEL.P-*)         OFFSET TO FIELD DESCR.    RS0909\n&LOCTR1  SETC  '&SYSLOC'\n         AIF   ('&SYSLOC' NE '').LOCTR1X\n&LOCTR1  SETC  'LOCTR_'.'NO_NAME'\n&LOCTR1  LOCTR                         IN-LINE CODE IN FIRST CSECT\n.*MNOTE 1,'LOCTR1=&LOCTR1'\n.LOCTR1X ANOP\n         AIF   (D'$LITERAL).LOCTR2     NOT FIRST TIME, JUMP\n$LTORG   LOCTR                         ADDRESSABLE CONSTANTS\n$FARRTNE LOCTR                         FAR ROUTINES\n.LOCTR2  AIF   ('&SYSECT2' NE '&$_CSECT(1)').LOCTR3\n$LITERAL LOCTR                         NON-ADDRESSABLE CONSTANTS\n.LOCTR3  AIF   ('&SYSECT2' EQ '&$_CSECT(1)').LOCTR5\n&STR     SETC  '$LTORG_&$_CSECT(&I)'\n         AIF   (D'&STR).LOCTR4         NOT FIRST TIME, JUMP\n&STR     LOCTR                         ADDRESSABLE CONSTANTS\n&STR     SETC  '$FARRTNE_&$_CSECT(&I)'\n&STR     LOCTR                         FAR ROUTINES\n.LOCTR4  ANOP\n&STR     SETC  '$LITERAL_&$_CSECT(&I)'\n&STR     LOCTR                         NON-ADDRESSABLE CONSTANTS\n.LOCTR5  ANOP\n.*once   DS    0H\n$LITERAL LOCTR                         NON-ADDRESSABLE CONSTANTS\n&TO1     SETC  '&INTO(1)'\n&TO2     SETC  '&LQ&INTO'\n         AIF   (N'&INTO EQ 1).PUNTO8            JUMP IF INTO=XXX\n         AIF   ('&INTO(1)'(1,1) NE '(').PUNTO3  JUMP IF INTO=(XXX,44)\n&TO1     SETC  '0&INTO(1)'                              INTO=((R3),44)\n.PUNTO3  ANOP\n&TO2     SETC  '&INTO(2)'                               INTO=(XXX,LL)\n         AIF   ('&INTO(2)'(1,1) NE '(').PUNTO8  JUMP IF INTO=(XXX,44)\n&TO2     SETC  '0&INTO(2)'                              INTO=(XXX,(R1))\n.PUNTO8  ANOP\n&LABEL.P DC    S(&TO1,&TO2)\n.*--------------------------------------------------------------------*\n.*-------      FIELDS       ------------------------------------------*\n.*--------------------------------------------------------------------*\n&I       SETA  1\n.*LOOP\n.LOOP1   ANOP\n         ACTR  200                            SYSDEBUG/DIAG055\n         AIF   (N'&SYSLIST(&I) GT 3).FLD990   TOO MANY SUB-OPERANDS\n&LAST    SETB  (&I EQ N'&SYSLIST)                LOOP\n         AIF   ('&SYSLIST(&I)'(1,1) EQ '''').LIT00\n         AIF   ('&SYSLIST(&I)'(K'&SYSLIST(&I),1) EQ '''').LIT01\n.*--------------------------------------------------------------------*\n.*       PROCESS FIRST SUBPARAMETER (ADDRESS)                         *\n.*--------------------------------------------------------------------*\n&P1S     SETC  '&SYSLIST(&I,1)'\n&P2L     SETC  '0'                     INPUT LENGTH\n&P3L     SETC  '0'                     OUTPUT LENGTH\n         AIF   ('&SYSLIST(&I)'(1,1) GE '0').FLD180 SPACES\n         AIF   ('&SYSLIST(&I)' EQ '%TIME').FLD190 %TIME\n         AIF   ('&SYSLIST(&I,1)'(1,1) NE '(').FLD115 (R2)\n         AIF   (T'&SYSLIST(&I,2) EQ 'O').FLD250\n&P1S     SETC  '0&SYSLIST(&I,1)'       CHANGE (R1) TO 0(R1)\n.FLD115  ANOP\n.*\n         AIF   (T'&SYSLIST(&I,2) NE 'O').FLD200\n.*\n.*       EXTRACT RBCDE FROM PRB.RBCDE (HLASM)\n.*\n&L       SETA  1\n.*--LOOP\n.FLD131  AIF   ('&P1S'(&L,1) EQ '.').FLD133\n&L       SETA  &L+1\n         AIF   (&L LT K'&P1S).FLD131\n.*--ENDLOOP\n&P2L     SETC  '&P1S'                    ABCDEF FROM ABCDEF\n         AGO   .FLD134\n.FLD133  ANOP\n&P2L     SETC  '&P1S'(&L+1,K'&P1S-&L)    RBCDE FROM PRB.RBCDE\n.FLD134  ANOP\n.*\n         AIF   (T'&SYSLIST(&I,2) NE 'O').FLD200\n.*\n         AIF   (NOT D'&P2L).FLD140\n&P2C     SETC  T'&P2L\n.*MNOTE *,'&P1 &P2C'\n         AIF   ('&P2C' EQ 'F' OR '&P2C' EQ 'H' OR '&P2C' EQ 'P').FLD220\n         AIF   ('&P2C' EQ 'FD').FLD220  FD                       RS0306\n         AIF   ('&P2C' EQ 'AD').FLD220  AD                       RS0207\n         AIF   ('&P2C' EQ 'G').FLD210  FL2\n.FLD140  ANOP\n.*\n.*       EXTRACT PSATOLD FROM PSATOLD-PSA\n.*\n&L       SETA  1\n.*--LOOP\n.FLD141  AIF   ('&P2L'(&L,1) EQ '-').FLD143\n         AIF   ('&P2L'(&L,1) EQ '+').FLD143\n&L       SETA  &L+1\n         AIF   (&L LT K'&P2L).FLD141\n.*--ENDLOOP\n&P2L     SETC  '&LQ&P2L'               L'ABCDEF\n         AGO   .FLD300\n.FLD143  ANOP\n&P2L     SETC  '&LQ'.'&P2L'(1,&L-1)    L'PSATOLD FROM PSATOLD-PSA\n         AGO   .FLD300\n.*\n.FLD180  AIF   ('&SYSLIST(&I)'(K'&SYSLIST(&I),1) NE 'X').FLD800\n&P2L     SETC  '&SYSLIST(&I)'(1,K'&SYSLIST(&I)-1) 12\n         AIF   (&LAST).FLD186\n         DC    X'60',AL1(&P2L)         BLANKS\n         AGO   .LIT90\n.FLD186  DC    X'E0',AL1(&P2L),0S(0)   BLANKS\n         AGO   .LIT90\n.*\n.FLD190  AIF   (N'&SYSLIST(&I) GT 2).FLD992\n&P1S     SETC  '1(14)'                 %TIME\n&$_FEAT(12) SETB 1                     %TIME\n&P2L     SETC  '12'                    hh:mm:ss.hh\n         AIF   (N'&SYSLIST(&I) EQ 1).FLD1905\n         AIF   (T'&SYSLIST(&I,2) NE 'N').FLD1904\n&P2L     SETC  '&SYSLIST(&I,2)'        5,8,11,12\n&L       SETA  &SYSLIST(&I,2)\n         AIF   (&L EQ 5 OR &L EQ 8 OR &L EQ 11 OR &L EQ 12).FLD1905\n.FLD1904 MNOTE 8,'Second sub-parameter is invalid: &SYSLIST(&I)'\n.FLD1905 ANOP\n.*MNOTE 1,'FLD1905 &SYSLIST(&I) &P1S &P2L '\n         AGO   .FLD800\n.*--------------------------------------------------------------------*\n.*       PROCESS SECOND SUBPARAMETER (LENGTH/TYPE)                    *\n.*--------------------------------------------------------------------*\n.FLD200  AIF   (T'&SYSLIST(&I,2) EQ 'O').FLD300 NO LENGTH SPECIFIED\n&P2C     SETC  '&SYSLIST(&I,2)'\n         AGO   .FLD220\n.*T'&P1=G\n.FLD210  ANOP\n&L       SETA  L'&SYSLIST(&I)          T'&P1 = 'G'\n&P2C     SETC  'FL&L'                  T'&P1 = 'G'\n.*\n.FLD220  ANOP\n&P2L     SETC  '0&P2C'                 (R2) LENGTH\n         AIF   ('&P2C'(1,1) EQ '(').FLD300\n&P2L     SETC  '&P2C'                  3(R2) LENGTH\n         AIF   ('&P2C'(K'&P2C,1) EQ ')').FLD300\n&P2L     SETC  '0'\n&PACKED  SETB  ('&P2C' EQ 'P')\n         AIF   (&PACKED).FLD290\n&P2L     SETC  '1'\n         AIF   ('&P2C' EQ 'FL1').FLD240\n&P2L     SETC  '3'\n         AIF   ('&P2C' EQ 'FL2' OR '&P2C' EQ 'H').FLD240\n&P2L     SETC  '7'\n         AIF   ('&P2C' EQ 'FL3').FLD240\n&P2L     SETC  '15'\n         AIF   ('&P2C' EQ 'F').FLD240\n&P2L     SETC  '31'                                              RS0306\n         AIF   ('&P2C' EQ 'FD').FLD240                           RS0306\n         AIF   ('&P2C' EQ 'AD').FLD240                           RS0207\n&P2L     SETC  '&P2C'                  IMMEDIATE LENGTH, FIELD\n         AGO   .FLD300\n.*\n.FLD240  ANOP                          BINARY VARIABLE\n&BIN     SETB  1\n         AGO   .FLD300\n.*\n.FLD250  ANOP                          REGISTER CONTENT\n&REG     SETB  1\n         AGO   .FLD300\n.*\n.FLD290  ANOP                          PACKED\n&P2L     SETC  '1'\n.*--------------------------------------------------------------------*\n.*       PROCESS THIRD SUBPARAMETER (OUTPUT FORMAT)                   *\n.*--------------------------------------------------------------------*\n.FLD300  AIF   (T'&SYSLIST(&I,3) EQ 'O').FLD800\n&HEX     SETB  ('&SYSLIST(&I,3)' EQ 'X') HEXADECIMAL\n&TRUNC   SETB  ('&SYSLIST(&I,3)' EQ 'T') TRUNCATE\n         AIF   (&HEX OR &TRUNC).FLD800\n.*\n&P3C     SETC  '&SYSLIST(&I,3)'\n&P3L     SETC  '248'\n         AIF   ('&P3C' EQ 'YYYY-MM-DD' AND &PACKED).FLD308\n&P3L     SETC  '249'\n         AIF   ('&P3C' EQ 'YYYYMMDD' AND &PACKED).FLD308\n&P3L     SETC  '250'\n         AIF   ('&P3C' EQ 'YY/MM/DD' AND &PACKED).FLD308\n&P3L     SETC  '251'\n         AIF   ('&P3C' EQ 'DD/MM/YY' AND &PACKED).FLD308\n&P3L     SETC  '252'\n         AIF   ('&P3C' EQ 'MM/DD/YY' AND &PACKED).FLD308\n&P3L     SETC  '253'\n         AIF   ('&P3C' EQ 'YYMMDD'   AND &PACKED).FLD308\n&P3L     SETC  '0'\n         AIF   (T'&SYSLIST(&I,2) NE 'N').FLD310\n         MNOTE 8,'EDIT PATTERN NOT ALLOWED WITH CHARACTER STRING'\n         AGO   .FLD310\n.FLD308  ANOP\n&$_FEAT(5) SETB 1                      JDATE\n         AGO   .FLD800\n.*--LOOP\n.FLD310  AIF   ('&P3C'(1,1) EQ 'R').FLD318       DEFAULT\n         AIF   ('&P3C'(1,1) EQ 'B').FLD318       DEFAULT\n         AIF   ('&P3C'(1,1) NE 'L').FLD311\n&LEFT    SETB  1\n         AGO   .FLD318\n.FLD311  AIF   ('&P3C'(1,1) NE 'Z').FLD312\n&ZERO    SETB  1\n         AGO   .FLD318\n.FLD312  AIF   ('&P3C'(1,1) LT '0').FLD993       nn in RnnB is not num\n         AIF   ('&P3C'(1,1) GT '9').FLD993       nn in RnnB is not num\n&P3L     SETC  '&P3L'.'&P3C'(1,1)\n.FLD318  ANOP\n.*MNOTE *,'&SYSLIST(&I) P3C=/&P3C/ P3L=/&P3L/'\n&P3C     SETC  '&P3C '(2,K'&P3C-1)     STRIP OFF FIRST CHARACTER\n         AIF   (K'&P3C GT 0).FLD310\n.*--ENDLOOP\n         AIF   (&P3L GT 16).FLD993               nn in RnnB is too big\n.*--------------------------------------------------------------------*\n.FLD800  ANOP\n&NUMERIC SETB  (&BIN OR &PACKED OR (&REG AND NOT &HEX))\n&TRUNC   SETB  (&TRUNC OR (&LEFT AND NOT &NUMERIC))\n&LEFT    SETB  (&LEFT AND &NUMERIC)\n         AIF   (NOT &NUMERIC).FLD810\n         AIF   (&LEFT OR '&P3L' NE '0').FLD810\n&P3L     SETC  '7'                     DEFAULT OUTPUT LENGTH ((R3))\n         AIF   (&REG).FLD810\n&P3L     SETC  '3'                     DEFAULT OUTPUT LENGTH\n         AIF   ('&P2C' EQ 'FL1').FLD810\n&P3L     SETC  '5'                     DEFAULT OUTPUT LENGTH\n         AIF   ('&P2C' EQ 'H' OR '&P2C' EQ 'FL2').FLD810\n&P3L     SETC  '31'                    DEFAULT OUTPUT LENGTH     RS0306\n         AIF   ('&P2C' EQ 'FD').FLD810                           RS0306\n         AIF   ('&P2C' EQ 'AD').FLD810                           RS0207\n&P3L     SETC  '7'                     DEFAULT OUTPUT LENGTH\n.FLD810  ANOP\n         AIF   (NOT &REG AND NOT &HEX).FLD811                    RS0207\n         AIF   ('&SYSLIST(&I,1)'(1,2) NE '(G').FLD811 no grande reg\n&P3L     SETC  '16'                                              RS0207\n.FLD811  ANOP                                                    RS0207\n&FLAG    SETA  &HEX*8+&BIN*4+&PACKED*2+&REG*1\n&LEN2    SETA  &TRUNC*128+&LEFT*128+&ZERO*64+&P3L\n&$_FEAT(2) SETB (&$_FEAT(2) OR (&REG AND NOT &HEX))   REGISTER (BIN)\n&$_FEAT(3) SETB (&$_FEAT(3) OR (&REG AND &HEX))       REGISTER (HEX)\n&$_FEAT(4) SETB (&$_FEAT(4) OR &PACKED)               PACKED\n&$_FEAT(6) SETB (&$_FEAT(6) OR &BIN)                  BINARY\n&$_FEAT(7) SETB (&$_FEAT(7) OR (&HEX AND NOT &REG))   HEX\n&$_FEAT(8) SETB (&$_FEAT(8) OR &NUMERIC)              BIN,PACKED\n&$_FEAT(9) SETB (&$_FEAT(9) OR (&LEFT AND &NUMERIC))\n&$_FEAT(10) SETB (&$_FEAT(10) OR &ZERO)\n&$_FEAT(11) SETB (&$_FEAT(11) OR &TRUNC)\n&BIN     SETB  0                    RESET FLAGS\n&HEX     SETB  0                    RESET FLAGS\n&REG     SETB  0                    RESET FLAGS\n&PACKED  SETB  0                    RESET FLAGS\n&LEFT    SETB  0                    RESET FLAGS\n&ZERO    SETB  0                    RESET FLAGS\n&TRUNC   SETB  0                    RESET FLAGS\n         AIF   (&FLAG GE 10).FLD995\n         AIF   (&LAST).FLD816\n         DC    X'0&FLAG',AL1(&LEN2),SL2(&P1S,&P2L)\n         AGO   .LIT99\n.FLD816  DC    X'8&FLAG',AL1(&LEN2),SL2(&P1S,&P2L),0S(0)\n         AGO   .LIT99\n.FLD990  MNOTE 12,'OPERAND &I HAS TOO MANY SUB-OPERANDS'\n         AGO   .LIT99\n.FLD992  MNOTE 12,'Too many sub-operands: &SYSLIST,(&I)'\n         AGO   .LIT99\n.FLD993  MNOTE 8,'THIRD SUBPARAMETER IS INVALID: ''&SYSLIST(&I,3)'''\n         AGO   .LIT99\n.FLD995  MNOTE 8,'Invalid Combination of Attributes: &SYSLIST(&I)'\n         AGO   .LIT99\n.*--------------------------------------------------------------------*\n.*------------ LITERALS ----------------------------------------------*\n.*--------------------------------------------------------------------*\n.LIT00   ANOP\n&LIT     SETC  'C&SYSLIST(&I)'\n         AGO   .LIT09\n.LIT01   ANOP\n&LIT     SETC  '&SYSLIST(&I)'\n.LIT09   ANOP                              calculate length of literal\n&J       SETA  3\n&L       SETA  0\n         ACTR  K'&LIT+K'&LIT+100\n         AIF   ('&LIT'(1,1) EQ 'X').LIT11X\n.*LOOP\n.LIT11C AIF ('&LIT'(&J,1) NE '''' AND '&LIT'(&J,1) NE '&&'(1,1)).LIT12C\n&J       SETA  &J+1\n.LIT12C  ANOP\n&J       SETA  &J+1\n&L       SETA  &L+1\n         AIF   (&J LT K'&LIT).LIT11C\n.*ENDLOOP\n         AGO   .LIT15\n.*LOOP\n.LIT11X  AIF   ('&LIT'(&J,1) EQ ',').LIT12X\n&L       SETA  &L+1\n.LIT12X  ANOP\n&J       SETA  &J+1\n         AIF   (&J LT K'&LIT).LIT11X\n.*ENDLOOP\n&L       SETA  (&L+1)/2\n.LIT15   ANOP                               generate in-line literal\n         AIF   (&L GT 5).LIT40\n         AIF   (&LAST).LIT16\n         DC    X'4&L',&LIT\n         AGO   .LIT90\n.LIT16   DC    X'C&L',&LIT,0S(0)\n         AGO   .LIT90\n.LIT40   ANOP                                  check literal table\n         AIF   (&$_LIT EQ 0).LIT50\n&N       SETA  1\n         ACTR  &$_LIT*3+200\n         AIF   (&$_CSECT_NO GT 1).LIT42\n.*--loop\n.LIT41   AIF   ('&LIT' EQ '&$_LITS(&N)').LIT80       LOOP\n&N       SETA  &N+1                                  LOOP\n         AIF   (&N LE &$_LIT).LIT41                  LOOP\n.*--endloop\n         AGO   .LIT50\n.LIT42   ANOP\n.*--loop\n.LIT422  AIF   ('&$_LITS_CSECT(&N)' EQ '&SYSECT2' AND                  X\n               '&LIT' EQ '&$_LITS(&N)').LIT80 LOOP\n&N       SETA  &N+1                                  LOOP\n         AIF   (&N LE &$_LIT).LIT422                 LOOP\n.*--endloop\n.LIT50   ANOP\n&$_LIT   SETA  &$_LIT+1\n&$_LITS(&$_LIT) SETC '&LIT'\n&$_LITS_CSECT(&$_LIT) SETC '&SYSECT2'\n.LIT55   ANOP\n.*NOTE 0,' &$_LIT &$_LITS_CSECT(&$_LIT) &SYSECT'\n.*NOTE 0,'&$_CSECT_NO &$_CSECT(1) &$_CSECT(2) &$_CSECT(3) &$_CSECT(4)'\n.**            &$_LITS(9999)           LITERALS\n&N       SETA  &$_LIT\n.LIT80   ANOP                               generate remote literal\n&N       SETA  &N+1000\n         AIF   (&LAST).LIT86\n         DC    X'40',AL1(&L),AL2($LIT&N-*)\n         AGO   .LIT90\n.LIT86   DC    X'C0',AL1(&L),AL2($LIT&N-*),0S(0)\n.LIT90   ANOP\n&$_FEAT(1) SETB 1                      LITERAL\n.LIT99   ANOP\n.*--------------------------------------------------------------------*\n&I       SETA  1+&I                              LOOP\n         AIF   (&I LE N'&SYSLIST).LOOP1          LOOP\n.*ENDLOOP\n&SYSLOC  LOCTR\n         AGO   .MEND\n.ERR1    MNOTE 12,'At least one Input Field must be specified'\n         AGO   .MEND\n.ERR2    MNOTE 12,'Invalid Output Area Specification'\n         AGO   .MEND\n.**********************************************************************\n.*       GENERATE: GENERATE LITERALS AND PROCESSING ROUTINE           *\n.**********************************************************************\n.GENL    ANOP\n         AIF   (N'&SYSLIST(1) GT 3).GENL1R\n&OPT2    SETC  '&SYSLIST(1,2)'\n         AIF   ('&OPT2' NE '' AND '&OPT2' NE 'AR_MODE'                 X\n               AND '&OPT2' NE 'NO_CSECT').GENL1R\n&OPT3    SETC  '&SYSLIST(1,3)'\n         AIF   ('&OPT3' NE '' AND '&OPT3' NE 'LOCTR').GENL1R\n         AIF   ('&OPT2' EQ 'NO_CSECT' AND '&OPT3' EQ 'LOCTR').GENL1R\n         AGO   .GENL1D\n.GENL1R  MNOTE 12,'Invalid GENERATE options, default used'\n&OPT2    SETC  ''\n&OPT3    SETC  ''\n.GENL1D  ANOP\n&STRBLANKS SETA 2\n         AIF   (D'$LTORG).GENL1F             CSECT-ONLY\n&$_FEAT(1) SETB 1,1,1,1,1,1,1,1,1,1,1,1\n.GENL1F  ANOP\n&ALLFEAT SETC  '&$_FEAT(1)&$_FEAT(2)&$_FEAT(3)&$_FEAT(4)'\n&ALLFEAT SETC  '&ALLFEAT&$_FEAT(5)&$_FEAT(7)&$_FEAT(6)&$_FEAT(8)'\n&ALLFEAT SETC  '&ALLFEAT&$_FEAT(9)&$_FEAT(10)&$_FEAT(11)&$_FEAT(12)'\n&STR     SETC  '&STRING_MACRO_VERSION'\n         MNOTE *,'STRING R&STR - FEATURES GENERATED: &ALLFEAT'\n         AIF   (&$_LIT EQ 0).GENL3\n&STR     SETC  '*CSECT'\n.*LOOP\n.GENL2   ANOP                                LOOP\n&N       SETA  &N+1                          LOOP\n&I       SETA  &N+1000                       LOOP\n.*MNOTE *,'&$_LITS_CSECT(1) &$_LITS_CSECT(&N) &N &I'\n         AIF   ('&STR' EQ '&$_LITS_CSECT(&N)').GENL2L\n&STR     SETC  '&$_LITS_CSECT(&N)'           LOOP\n&LOCTR1  SETC  '$LITERAL'                    LOOP\n         AIF   ('&$_CSECT(1)' EQ '&$_LITS_CSECT(&N)').GENL2D\n&LOCTR1  SETC  '$LITERAL_&STR'               LOOP\n.GENL2D  ANOP                                LOOP\n&LOCTR1  LOCTR\n.GENL2L  ANOP                                LOOP\n$LIT&I   DC    &$_LITS(&N)\n         AIF   (&N LT &$_LIT).GENL2          LOOP\n.*ENDLOOP\n.GENL3   ANOP\n         AIF   ('&OPT2' EQ 'NO_CSECT').GENL8\n.**********************************************************************\n.*                                                                    *\n.*       STRING SUB-ROUTINE                                           *\n.*                                                                    *\n.*             CAUTION: BYTES 49-72 OF THE CALLER'S SAVE AREA         *\n.*                      (R7-R12 SLOTS) ARE USED AS WORK SPACE         *\n.*                                                                    *\n.**********************************************************************\n         AIF   ('&OPT3' EQ 'LOCTR').GENL4L\n@STRING  CSECT\n@STRING  RMODE ANY\n         AGO   .GENL4X\n.GENL4L  PUSH  USING                   GENERATE,LOCTR\n         DROP\n@STRING@ LOCTR\n@STRING  DS    0H                      ALIGNMENT\n.GENL4X  ANOP\n@00      EQU   0                       WORK REGISTER\n@01      EQU   1                       WORK REGISTER\n@02      EQU   2                       WORK REGISTER\n@03      EQU   3                       WORK REGISTER\n@04      EQU   4                       WORK REGISTER\n@05      EQU   5                       WORK REGISTER\n@06      EQU   6                       WORK REGISTER\n@07      EQU   7                       WORK REGISTER\n@08      EQU   8                       WORK REGISTER\n@09      EQU   9                       WORK REGISTER\n@10      EQU   10                      WORK REGISTER\n@11      EQU   11                      WORK REGISTER\n@12      EQU   12                      WORK REGISTER\n@13      EQU   13                      CALLER'S SAVE AREA\n@14      EQU   14                      WORK REGISTER\n@15      EQU   15                      BASE REG\n         USING @STRING,@15\n         USING @STRSAVE,@13\n         J     @STR003                 BRANCH AROUND EYE-CATCHER\n         DC    C'@STRING64/390 R&STRING_MACRO_VERSION &ALLFEAT',0H'0'\n@STR002  DC    H'4'                                              RS0909\n@STR003  STMG  @14,@12,8(@13)          SAVE REGS (DEBUGGING ONLY)RS0306\n         AH    @14,@STR002-@STRING(@15,0) POINT PAST PARM-LIST OFFSET\n         BAKR  @14,0                   SAVE REGS AND RETURN ADDRESS\n         AHI   @14,-4            adjust addr of parm list offset RS0909\n         LAE   @06,0                   R6=0 AR6=0\n         CPYA  @14,@06                 AR14=0\n         CPYA  @15,@06                 AR15=0\n&LAE     SETC  'LAE'\n         ICM   @06,B'1111',0(@14)      pick up parm list offset  RS0909\n         ALR   @06,@14                 R6 NOW POINTS TO PARM LIST\n         USING @STRSCON,@06\n         &LAE  @02,@STRSCON            RESOLVE FIRST SCON (ADDR)\n         &BAS  @14,@STRS2A             GET ADDRESS IN R2\n         &LAE  @04,0(,@02)             KEEP ADDRESS OF \"INTO\" FIELD\n         L     @14,12(,@13)            RESTORE ADDR OF STRING MACRO\n         OI    0(@04),0                GET CLEAN S0C4 IF ADDRESS IS BAD\n         &LAE  @02,@STRFLEN            RESOLVE SECOND S-CON (LEN)\n         &BAS  @14,@STRS2A             GET LENGTH IN R2\n* RS no  CLC   0(6,R6),@STRDUMP RS NO      FORCE DUMP\n* RS no  JE    @STRS2XX\n         LR    @05,@02                 KEEP LENGTH OF \"INTO\" FIELD\n         CR    @05,@04                 END ADDRESS?\n         JL    @STR282                 NO, JUMP\n         SR    @05,@04                 CALCULATE LENGTH\n@STR282  MSTA  @04                     SAVE R4,R5 ON LINKAGE STACK\n.**********************************************************************\n.*       MOVE FIELDS TO OUTPUT AREA                                   *\n.**********************************************************************\n         &LAE  @06,@STRNEXT            POINT TO 1ST FIELD DESC\n         USING @STRPARM,@06\n.*LOOP\n@STR310  EQU   *\n         AIF   (NOT &$_FEAT(1)).FEAT1A\n         TM    @STRFLAG,@STRLIT        IS THIS A LITERAL?\n         JO    @STR372                 YES, JUMP\n.FEAT1A  ANOP\n         AIF   (NOT &$_FEAT(2) AND NOT &$_FEAT(3)).FEAT23A\n         TM    @STRFLAG,@STRREG        REGISTER?\n         JO    @STR323                 YES, JUMP\n.FEAT23A ANOP\n         AIF   (NOT &$_FEAT(12)).FEAT12A\n         CLI   @STRSCON,X'E0'          IS IT %TIME ?\n         BE    @STR378                 YES, JUMP\n.FEAT12A ANOP\n.*\n.*       IT'S A FIELD (SCON)\n.*\n         &LAE  @02,@STRFLEN            RESOLVE SECOND S-CON (LEN)\n         &BAS  @14,@STRS2A             GET LENGTH IN R2\n         AIF   (&$_FEAT(9)).FEAT9E1    (LEFT JUSTIFICATION, NUMERIC)\n         LTR   @03,@02                 KEEP/TEST LENGTH\n         JZ    @STR398                 ZERO LENGTH, DO NOT EDIT\n         AGO   .FEAT9E2\n.FEAT9E1 LTR   @03,@02                 KEEP/TEST LENGTH\n         JP    @STR313                 LENGTH POSITIVE, JUMP\n         TM    @STRLEN2,@STRLEFT       LEFT JUSTIFICATION?\n         JNO   @STR398                 NO, ZERO LENGTH IS NOT OK\n@STR313  EQU   *\n.FEAT9E2 ANOP\n         &LAE  @02,@STRSCON            RESOLVE FIRST SCON (ADDR)\n*RS Ja   CLC   0(6,R6),@STRDUMP            FORCE DUMP\n*RS Ja   JE    @STRS2XX\n         &BAS  @14,@STRS2A             GET ADDRESS IN R2\n         L     @14,12(,@13)            RESTORE ADDR OF STRING MACRO\n*RS ja   CLC   0(6,R6),@STRDUMP            FORCE DUMP\n*RS ja   JE    @STRS2XX\n         CLI   0(@02),0                GET CLEAN S0C4 IF ADDRESS IS BAD\n         CR    @03,@02                 END ADDRESS?\n         JL    @STR314                 NO, JUMP\n* No     CLC   0(6,R6),@STRDUMP            FORCE DUMP\n* No     JE    @STRS2XX\n         LA    @00,X'0080'             PSA ADDRESS\n         CLR   @02,@00                 PSA REFERENCE?\n         JL    @STR314                 YES, JUMP\n         SR    @03,@02                 CALCULATE LENGTH\n@STR314  EQU   *\n         AIF   (NOT &$_FEAT(6)).FEAT6A\n         TM    @STRFLAG,@STRBIN        BINARY FIELD?\n         JO    @STR328                 YES, JUMP\n* No     CLC   0(6,R6),@STRDUMP            FORCE DUMP\n* No     JE    @STRS2XX\n.FEAT6A  ANOP\n         AIF   (NOT &$_FEAT(4)).FEAT4A\n         TM    @STRFLAG,@STRPACK       PACKED FIELD?\n         JO    @STR351                 YES, JUMP\n.FEAT4A  ANOP\n         AIF   (NOT &$_FEAT(7)).FEAT7A\n         TM    @STRFLAG,@STRHEX        EDIT IN HEX?\n         JO    @STR376                 YES, JUMP\n.FEAT7A  ANOP\n.*\n.*       TRUNCATE CHARACTER STRING\n.*\n         AIF   (NOT &$_FEAT(11)).FEAT11A\n         CLI   @STRLEN2,@STRLEFT       CHECK JUSTIFICATION, OUTPUT LEN\n         JNE   @STR390                 NO STRING TRUNCATION, JUMP\n         &LAE  @01,0(@03,@02)          FIRST BYTE AFTER FIELD\n@STR318  BCTR  @01,0                   DOWN 1 BYTE                 LOOP\n         CLI   0(@01),C' '             IS IT A SPACE ?             LOOP\n         JNE   @STR390                 LAST NON-BLANK BYTE         LOOP\n         BRCT  @03,@STR318             LOOP UNTIL 1ST NON-BLANK    LOOP\n         J     @STR398                 BLANK FIELD, DO NOT EDIT\n         AGO   .FEAT11B\n.FEAT11A ANOP\n         AIF (&$_FEAT(2)+&$_FEAT(3)+&$_FEAT(4)+&$_FEAT(6) EQ 0).FEAT11B\n         J     @STR390                 EDIT\n.FEAT11B ANOP\n.*\n.*       REGISTER (R0-R13)\n.*\n         AIF   (NOT &$_FEAT(2) AND NOT &$_FEAT(3)).FEAT23B\n@STR323  DS    0H                                                RS0207\n         LH    @01,@STRSCON            REG NUMBER IN BITS 28-31  RS0207\n         CLI   @STRLEN2,X'10'          Mask eq 16 (grand reg)?   RS0207\n         JNE   @STR325                   yes use                 RS0207\n         CLI   @STRSCON+1,@06          IS THIS R7-R13?\n         JH    @STR323R                YES, JUMP\n         LR    @07,@01                 SAVE R1 (R)\n         LAE   @10,0(,@04)             SAVE R4\n         LR    @11,@05                 SAVE R5\n         LAE   @12,0(,@06)             SAVE R6\n         EREGG @00,@06                 RELOAD CALLER'S R0-R6     RS0207\n*        EX    @07,@STR323L            COPY R0-R6 VALUE          RS0207\n         CHI   @07,0                   EX doesn't work with LGR  RS0207\n         JE    @STR323G                                          RS0207\n         CHI   @07,1                                             RS0207\n         JNE   @STR323A                                          RS0207\n         LGR   @00,@01                                           RS0207\n         J     @STR323G                                          RS0207\n@STR323A DS    0H                                                RS0207\n         CHI   @07,2                                             RS0207\n         JNE   @STR323B                                          RS0207\n         LGR   @00,@02                                           RS0207\n         J     @STR323G                                          RS0207\n@STR323B DS    0H                                                RS0207\n         CHI   @07,3                                             RS0207\n         JNE   @STR323C                                          RS0207\n         LGR   @00,@03                                           RS0207\n         J     @STR323G                                          RS0207\n@STR323C DS    0H                                                RS0207\n         CHI   @07,4                                             RS0207\n         JNE   @STR323D                                          RS0207\n         LGR   @00,@04                                           RS0207\n         J     @STR323G                                          RS0207\n@STR323D DS    0H                                                RS0207\n         CHI   @07,5                                             RS0207\n         JNE   @STR323E                                          RS0207\n         LGR   @00,@05                                           RS0207\n         J     @STR323G                                          RS0207\n@STR323E DS    0H                                                RS0207\n         CHI   @07,6                                             RS0207\n         JNE   @STR323F                                          RS0207\n         LGR   @00,@06                                           RS0207\n         J     @STR323G                                          RS0207\n@STR323F DS    0H                                                RS0207\n         DC    H'0'                    force abend               RS0207\n@STR323G DS    0H                                                RS0207\n         LAE   @04,0(,@10)             RESTORE R4\n         LR    @05,@11                 RESTORE R5\n         LAE   @06,0(,@12)             RESTORE R6\n         J     @STR325T                                          RS0207\n*@STR323L LGR   @00,*-*                 COPY VALUE FOR EDIT      RS0207\n@STR323R EQU   *                                                 RS0207\n         EREGG @07,@12                 RESTORE CALLER'S R7-R12   RS0207\n*        EX    @01,@STR323L            COPY R7-R13 INTO R0       RS0207\n         CHI   @01,7                   ex doesn't work with LGR  RS0207\n         JNE   @STR323H                                          RS0207\n         LGR   @00,@07                                           RS0207\n         J     @STR325T                                          RS0207\n@STR323H DS    0H                                                RS0207\n         CHI   @01,8                                             RS0207\n         JNE   @STR323I                                          RS0207\n         LGR   @00,@08                                           RS0207\n         J     @STR325T                                          RS0207\n@STR323I DS    0H                                                RS0207\n         CHI   @01,9                                             RS0207\n         JNE   @STR323J                                          RS0207\n         LGR   @00,@09                                           RS0207\n         J     @STR325T                                          RS0207\n@STR323J DS    0H                                                RS0207\n         CHI   @01,10                                            RS0207\n         JNE   @STR323K                                          RS0207\n         LGR   @00,@10                                           RS0207\n         J     @STR325T                                          RS0207\n@STR323K DS    0H                                                RS0207\n         CHI   @01,11                                            RS0207\n         JNE   @STR323L                                          RS0207\n         LGR   @00,@11                                           RS0207\n         J     @STR325T                                          RS0207\n@STR323L DS    0H                                                RS0207\n         CHI   @01,12                                            RS0207\n         JNE   @STR323M                                          RS0207\n         LGR   @00,@12                                           RS0207\n         J     @STR325T                                          RS0207\n@STR323M DS    0H                                                RS0207\n         CHI   @01,13                                            RS0207\n         JNE   @STR323N                                          RS0207\n         LGR   @00,@13                                           RS0207\n         J     @STR325T                                          RS0207\n@STR323N DS    0H                                                RS0207\n         DC    H'0'                    force abend               RS0207\n         J     @STR325T                                          RS0207\n@STR325  DS   0H                                                 RS0207\n         CLI   @STRSCON+1,@06          IS THIS R7-R13?           RS0207\n         JH    @STR325R                YES, JUMP                 RS0207\n         LR    @07,@01                 SAVE R1 (R)               RS0207\n         LAE   @10,0(,@04)             SAVE R4                   RS0207\n         LR    @11,@05                 SAVE R5                   RS0207\n         LAE   @12,0(,@06)             SAVE R6                   RS0207\n         EREG  @00,@06                 RELOAD CALLER'S R0-R6     RS0207\n         EX    @07,@STR325L            COPY R0-R6 VALUE          RS0207\n         LAE   @04,0(,@10)             RESTORE R4                RS0207\n         LR    @05,@11                 RESTORE R5                RS0207\n         LAE   @06,0(,@12)             RESTORE R6                RS0207\n         J     @STR325T                                          RS0207\n@STR325L LR    @00,*-*                 COPY VALUE FOR EDIT       RS0207\n@STR325R EQU   *                                                 RS0207\n         EREG  @07,@12                 RESTORE CALLER'S R7-R12\n         EX    @01,@STR325L            COPY R7-R13 INTO R0       RS0207\n@STR325T EQU   *                                                 RS0207\n         AIF   (NOT &$_FEAT(3)).FEAT3R REG,HEX\n         AIF   (NOT &$_FEAT(2)).FEAT2H REG,BIN\n         TM    @STRFLAG,@STRHEX        EDIT IN HEX?\n         JNO   @STR330                 NO, EDIT FWD\n.FEAT2H  ANOP\n         SR    @03,@03                 clear R3                  RS0207\n         ICM   @03,B'0001',@STRLEN2    Length present ?          RS0207\n         JZ    @STR325U                   Yes use it             RS0207\n         STCMY @00,B'1111',@STRDWD+3   STORE IT FOR CVD/UNPK     RS0207\n         STCMH @00,B'1111',@STRDWD-1   STORE IT FOR CVD/UNPK     RS0207\n         J     @STR325V                                          RS0207\n@STR325U EQU   *                                                 RS0207\n         STCM  @00,B'1111',@STRDWD-1   STORE IT FOR CVD/UNPK\n         LA    @03,8                   OUTPUT LENGTH\n@STR325V EQU   *                                                 RS0207\n         J     @STR376X                EDIT IN HEX\n.FEAT3R  ANOP\n         AIF   (NOT &$_FEAT(6)).FEAT23B\n         J     @STR330                 EDIT R0\n.FEAT23B ANOP\n.*\n.*       BINARY VARIABLE: @03 CONTAINS THE ICM MASK (1 3 7 F)\n.*\n         AIF   (NOT &$_FEAT(6)).FEAT6B\n@STR328M ICM   @00,*-*,0(@02)          **EXECUTED INSTRUCTION**\n@STR328  SLR   @00,@00\n         CHI   @03,15                  Mask GT 15                RS0306\n         JH    @STR329                   yes use CVDG            RS0306\n         EX    @03,@STR328M            LOAD THE BINARY VARIABLE\n* Ja     CLC   0(6,R6),@STRDUMP            FORCE DUMP\n* Ja     JE    @STRS2XX\n         J     @STR329E                                          RS0306\n@STR329  LG    @00,0(@02)                                        RS0306\n         CVDG  @00,@STRDWD                                       RS0306\n         J     @STR361                                           RS0306\n@STR329E DS    0H                                                RS0306\n.FEAT6B  ANOP\n.*\n         AIF   (NOT &$_FEAT(2) AND NOT &$_FEAT(6)).FEAT6C\n@STR330  XC    @STRDWD(8),@STRDWD      clear first part          RS0306\n         CVD   @00,@STRDWD+8           CONVERT VALUE TO DECIMAL  RS0306\n         AIF   (NOT &$_FEAT(4)).FEAT6C\n         J     @STR361                 EDIT DWD\n.FEAT6C  ANOP\n.*\n.*       PACKED FIELD\n.*\n         AIF   (NOT &$_FEAT(4)).FEAT4B\n@STRZAP  ZAP   @STRDWD(16),0(*-*,@02)      MOVE TO @STRDWD       RS0306\n@STR351  &LAE  @03,0(,@02)             FIRST BYTE OF PACKED FIELD\n         BALR  @14,0\n         TM    0(@03),X'0C'            IS THIS THE SIGN BYTE?\n         LA    @03,1(,@03)              (NEXT BYTE)\n         BNOR  @14                     NO, LOOP MORE\n         SLR   @03,@02                 GET LENGTH OF PACKED FIELD\n         BCTR  @03,0\n         EX    @03,@STRZAP             EXECUTE ZAP\n         AIF   (NOT &$_FEAT(5)).FEAT4B\n         CLI   @STRLEN2,248            JULIAN-TO-YYMMDD CONV?\n         JNL   @STR375                 YES, JUMP\n.FEAT4B  ANOP                          PACKED\n.*\n.*       EDIT @STRDWD (BIN, REG, PACKED)\n.*\n         AIF   (NOT &$_FEAT(8)).FEAT8B\n@STR361  IC    @00,@STRLEN2            OUTPUT LENGTH\n         LA    @03,X'003F'             MASK FOR \"AND\"\n         NR    @03,@00                 OUTPUT LENGTH\n         MVC   @STRWK32(32),@STRMASK32 EDIT MASK                 RS0306\n* ja     CLC   0(6,R6),@STRDUMP            FORCE DUMP\n* ja     JE    @STRS2XX\n@STR362  EQU   *\n.*\n.*       LEFT-JUSTIFICATION (NUMERIC)\n.*\n         AIF   (NOT &$_FEAT(9)).FEAT9B\n         TM    @STRLEN2,@STRLEFT       LEFT JUSTIFICATION?\n         JNO   @STR367                 NO, JUMP\n         &LAE  @01,@STRWK32+31         PREVENT BAD R1\n         EDMK  @STRWK32(32),@STRDWD    ZONED DECIMAL\n         BNM   @STR362A                skip if not a negative number\n         BCTR  @01,0                   R1 = significance start ptr -1\n         MVI   0(@01),C'-'             sink negative sign in front\n@STR362A &LAE  @02,0(,@01)             FIRST STRING POSITION\n         LTR   @03,@03                 CHECK OUTPUT LENGTH\n         JNZ   @STR363                 JUMP IF NOT ZERO\n.*       L0    (LEFT JUSTIFIED, NO PADDING)\n         &LAE  @03,@STRWK32+32         1. POSITION AFTER STRING  RS0306\n         SR    @03,@02                 COMPUTE STRING LENGTH\n         J     @STR390                 MOVE FIELD TO OUTPUT LINE\n.*       L1-L63 (LEFT JUSTIFIED, PADDING)\n@STR363  CR    @03,@05                 COMPARE LENGTH TO REMAINING LEN\n         JNH   @STR364                 LARGE ENOUGH, JUMP\n         LR    @03,@05                 TOO BIG, TRUNCATE TO REM. LEN.\n@STR364  SR    @05,@03                 COMPUTE REMAINING LENGTH\n         LAE   @08,0(,@04)             POINTER IN OUTPUT LINE\n         LR    @09,@03                 LENGTH WITH PADDING\n         LA    @03,@STRWK32+32         1. POSITION AFTER STRING\n         SR    @03,@02                 COMPUTE STRING LENGTH\n* ja     CLC   0(6,R6),@STRDUMP            FORCE DUMP\n* ja     JE    @STRS2XX\n         J     @STR392                 MOVE FIELD TO OUTPUT LINE\n@STR367  EQU   *\n.FEAT9B  ANOP\n         AIF   (NOT &$_FEAT(10)).FEAT10B\n         TM    @STRLEN2,@STRZERO       LEADING ZEROES REQ'D?\n         JNO   @STR368                 NO, JUMP\n         MVI   @STRWK32,C'0'           YES, CHANGE X'40' TO C'0'\n@STR368  EQU   *\n.FEAT10B ANOP\n         &LAE  @01,@STRWK32+31         PREVENT BAD R1\n         EDMK  @STRWK32(32),@STRDWD    ZONED DECIMAL\n         BNM   @STR369                 skip if not a negative number\n         BCTR  @01,0                   R1 = significance start ptr -1\n         MVI   0(@01),C'-'             sink negative sign in front\n@STR369  &LAE  @02,@STRWK32+32         1. POSITION AFTER STRING\n         SR    @02,@03                 FIRST STRING POSITION\n.FEAT8B  ANOP\n.*\n.*       LITERAL (@STRSCON IS A 16-BIT OFFSET)\n.*       Short Literal (low-order 4 bits of @STRFLAG contains length)\n.*       BLANKS  (@STRSCON=ZERO)\n.*\n         AIF   (NOT &$_FEAT(1)).FEAT1B\n         J     @STR390                 MOVE STRING TO OUTPUT LINE\n@STR372  LA    @01,7                   mask for NR\n         &LAE  @02,@STRLEN2            1st byte of short literal\n         IC    @03,@STRFLAG            pick up flags+length\n         NR    @03,@01                 R3 has length of short literal\n         JNZ   @STR390                 short literal, go move it\n         SLR   @02,@02                 Clear Address Register\n         IC    @03,@STRLEN2            GET LITERAL LENGTH\n         TM    @STRFLAG,@STRX40        string of spaces?\n         JO    @STR390                 yes, go move them\n         ICM   @02,B'0011',@STRSCON    LOAD LITERAL OFFSET\n         LA    @02,@STRSCON(@02)       CONVERT OFFSET TO FULL ADDRESS\n.FEAT1B  ANOP\n.*\n.*       CONVERT JULIAN DATE TO YYMMDD\n.*\n         AIF   (NOT &$_FEAT(5)).FEAT5F\n         J     @STR390                 MOVE STRING TO OUTPUT LINE\n@STR375  LA    @00,248                 MASK FOR 'SLR'\n         SLR   @01,@01\n         IC    @01,@STRLEN2            248-255\n         SLR   @01,@00                 000-007\n         LA    @00,12                  L'@STR375W\n         MR    @00,@00                 COMPUTE OFFSET\n         &LAE  @01,@STR375W(@01)       ENTRY IN \"TR\" MASK TABLE\n         SLR   @03,@03\n         IC    @03,0(,@01)             LENGTH OF DATE (6, 8 OR 10)\n         ZAP   @STRDWD(16),@STRDWD(16)     DATE=0000000?\n         JNZ   @STR375B                NO, JUMP                    @JDT\n@STR375Z &LAE  @02,@STRBLANKS          WORK AREA\n&STRBLANKS SETA 10                     WE NEED AT LEAST 10 BLANKS\n         J     @STR390                 MOVE FIELD TO OUTPUT LINE\n@STR375W DC    AL1(10,C'-',0,1,2,3,8,4,5,8,6,7) YYYY-MM-DD   248\n         DC    AL1(8,C' ',0,1,2,3,4,5,6,7,8,8)  YYYYMMDD//   249\n         DC    AL1(8,C'/',2,3,8,4,5,8,6,7,8,8)  YY/MM/DD//   250\n         DC    AL1(8,C'/',6,7,8,4,5,8,2,3,8,8)  DD/MM/YY//   251\n         DC    AL1(8,C'/',4,5,8,6,7,8,2,3,8,8)  MM/DD/YY//   252\n         DC    AL1(6,C' ',2,3,4,5,6,7,8,8,8,8)  YYMMDD       253\n.*       DC    AL1(6,C' ',6,7,4,5,2,3,8,8,8,8)  DDMMYY       254\n.*       DC    AL1(6,C' ',4,5,6,7,2,3,8,8,8,8)  MMDDYY       255\n@STR375T DC    P'59,31,29,31,30,31,30,31,31,30,31,30,31'\n         DC    P'999'                  Prevent S0C7 with 90366\n@STR375B CLI   @STRDWD+12,X'01'         YEAR 2000 OR ABOVE?\n         JH    @STR375C                CC>01, JUMP (MUST BE 19 OR 20)\n         MVI   @STRDWD+12,X'20'         CC=01, CHANGE TO CC=20\n         JE    @STR375C                CC=01, USE CC=20\n         CLI   @STRDWD+12+1,X'50'       YY<50?\n         JL    @STR375C                YES, USE CC=20\n         MVI   @STRDWD+12,X'19'         NO, FORCE CC=19\n@STR375C UNPK  @STRWK32(5),@STRDWD+12(3) CCYY?\n         ZAP   @STRDWD+9(2),@STR375T+9(1) INIT MONTH COUNTER\n         &LAE  @02,@STR375T            TABLE OF MONTHS (NUMBER OF DAYS)\n         TM    @STRDWD+12+1,X'01'       ODD YEARS\n         JO    @STR375N                  AREN'T LEAP YEARS\n         TM    @STRDWD+12+1,X'12'      ZEROES IN 1980, ALL ONES IN 1992\n         JNM   @STR375L                MIXED IN 1982/1990\n.*       IF IT'S NOT A LEAP YEAR AND DDD>59, THEN ADD 1 TO DDD\n@STR375N CP    @STRDWD+12+2(2),@STR375T ARE WE PAST FEB 28 (DDD>59) ?\n         JNH   @STR375L                NO, JUMP\n         AP    @STRDWD+12+2(2),@STR375T+3(1) ADD 1 (FROM 31) TO DDD\n.*--LOOP WHILE DDD > 0\n@STR375L AP    @STRDWD+9(2),@STR375T+3(1)   ADD 1 (FROM 31) TO MONTH\n         LA    @02,2(,@02)             NEXT ENTRY IN \"MONTHS\" TABLE\n         SP    @STRDWD+12+2(2),0(2,@02) SUB DAYS-IN-MONTH FROM DDD\n         JP    @STR375L\n.*--ENDLOOP\n         AP    @STRDWD+12+2(2),0(2,@02) UNDO LAST \"SP\" INSTRUCTION\n         UNPK  @STRWK32+4(2),@STRDWD+9(2) FYFYFYFY,FMCM??\n         UNPK  @STRWK32+6(2),@STRDWD+14(2) FYFYFYFY,FMCMFDCD\n         MVZ   @STRWK32+1(7),@STRWK32     FYFYFYFY,FMCMFDCD\n         MVC   @STRWK32+8(1),1(@01)    SEPARATOR\n         &LAE  @02,@STRWK32+9          WORK AREA\n         MVC   0(10,@02),2(@01)        MOVE CORRESPONDING MASK\n         TR    0(10,@02),@STRWK32      CONVERT DATE TO THE RIGHT FORMAT\n.FEAT5F  ANOP                          JDATE\n.*\n.*       HEX STRING\n.*\n         AIF   (NOT &$_FEAT(7)).FEAT7B\n         J     @STR390                 MOVE STRING TO OUTPUT LINE\n@STR376M MVC   @STRDWD-1(*-*),0(@02)   PREVENT S0C4 IN UNPK\n@STR376  LA    @00,8                   MAX LENGTH\n         CLR   @03,@00                 CHECK LENGTH\n         JNH   @STR376B                JUMP IF LE 8\n         LR    @03,@00                 TRUNCATE TO MAXIMUM LENGTH\n@STR376B LR    @01,@03                 INPUT LENGTH\n         BCTR  @01,0\n         EX    @01,@STR376M            MOVE DATA TO SAFE STORAGE\n         ALR   @03,@03                 OUTPUT LENGTH\n         AGO   .FEAT37B\n.FEAT7B  ANOP\n         AIF   (NOT &$_FEAT(3)).FEAT37C\n         J     @STR390                 MOVE STRING TO OUTPUT LINE\n.FEAT37B ANOP\n@STR376X &LAE  @02,@STRWK32            WORK AREA\n         UNPK  0(9,@02),@STRDWD-1(5)   EXPAND SOURCE BYTES FOR \"TR\"\n         UNPK  8(9,@02),@STRDWD+3(5)   EXPAND SOURCE BYTES FOR \"TR\"\n         TR    0(16,@02),@STRHEXT-240  =C'0123456789ABCDEF'\n.FEAT37C ANOP\n.*\n.*       %TIME\n.*\n         AIF   (NOT &$_FEAT(12)).FEAT12B\n         J     @STR390                 MOVE STRING TO OUTPUT LINE\n@STRTIME DC    X'4021207A20207A20207A20204000'    0X.XX.XX.XX\n@STR378  LR    @02,@15                 SAVE BASE REG\n         TIME  DEC                     GET HHMMSSHH\n         LR    @15,@02                 RESTORE BASE REG\n         ST    @00,@STRDWD             STORE HHMMSSHH\n         MVC   @STRWK32(13),@STRTIME   MOVE EDIT MASK\n         ED    @STRWK32(13),@STRDWD    EDIT HH:MM:SS:HH\n         &LAE  @02,@STRWK32+1          WORK AREA\n         LA    @03,12                  HH:MM:SS:HH+ SPACE\n.FEAT12B ANOP\n.*MOVE\n@STR390  DS    0H                                                RS0207\n         CR    @03,@05                 COMPARE LENGTH TO REMAININGSLEN\n         JNH   @STR391                 LARGE ENOUGH, JUMP\n         LR    @03,@05                 TOO BIG, TRUNCATE TO REM. LEN.\n@STR391  SR    @05,@03                 COMPUTE REMAINING LENGTH\n         LAE   @08,0(,@04)             POINTER IN OUTPUT LINE\n         LR    @09,@03                 PASS REMAINING LENGTH\n         LTR   @02,@02                 BLANKS?\n         JNZ   @STR392                 NO, JUMP\n         SLR   @03,@03                 YES, ZERO LENGTH\n@STR392  ICM   @03,B'1000',@STRBLANKS  PAD WITH BLANKS\n         MVCL  @08,@02                 MOVE FIELD TO OUTPUT LINE\n         LR    @04,@08                 NEW POINTER IN OUTPUT LINE\n* ja     CLC   0(6,R6),@STRDUMP            FORCE DUMP\n* ja     JE    @STRS2XX\n@STR398  TM    @STRFLAG,@STRLAST       TEST LAST-ENTRY INDICATOR\n         JO    @STR399                 Done, exit\n         AIF   (NOT &$_FEAT(1)).FEAT1C\n         TM    @STRFLAG,@STRLIT+@STRX40 literal or spaces?\n         JM    @STR398L                Literal, not spaces\n         JZ    @STR398X                Neither literal nor spaces\n         LA    @06,@STRSCON            2-byte entry for blank spaces\n         J     @STR310                 PROCESS NEXT ENTRY\n@STR398L LA    @01,7                   mask for NR\n         IC    @03,@STRFLAG            pick up flags+length\n         NR    @03,@01                 R3 has length of short literal\n         JZ    @STR398T                not an in-line literal, jump\n         LA    @06,@STRLEN2(@03)       Skip VL parm for in-line literal\n         J     @STR310                 PROCESS NEXT ENTRY\n@STR398T LA    @06,@STRFLEN            4-byte parm for remote literal\n         J     @STR310                 PROCESS NEXT ENTRY\n.FEAT1C  ANOP\n@STR398X LA    @06,@STRNEXT            BUMP UP TO NEXT ENTRY\n         J     @STR310                 PROCESS NEXT ENTRY\n.*ENDLOOP\n.*\n.*       END-OF-LINE PROCESSING - PAD WITH BLANKS\n.*\n@STR399  SLR   @01,@01                 SET UP R1 FOR PADDING\n         ICM   @01,B'1000',@STRBLANKS  SET UP R1 FOR PADDING\n.***     DROP  @06,@13,@15\n*        CLC   0(6,R6),@STRDUMP            FORCE DUMP\n*        JE    @STRS2XX\n         LA    @15,3                   MODIFIABLE AREA\n         ESTA  @14,@15                 R14 = START OF OUTPUT AREA\n         LR    @15,@04                 END OF OUTPUT AREA\n         SR    @15,@14                 R15 = LENGTH USED IN OUTPUT AREA\n         MVCL  @04,@00                 PAD WITH BLANKS\n         EREG  @00,@14                 RESTORE WORK REGISTERS\n         STMG  @14,@12,8(@13)          MAKE SAVE AREA LOOK NORMALRS0306\n         OI    15(@13),1               SIMULATE \"T\" OPTION OF RETURN\n         PR                            RETURN TO CALLER\n.*\n         AIF   (NOT (&$_FEAT(3) OR &$_FEAT(7))).FEAT37T\n@STRHEXT DC    C'0123456789ABCDEF'     HEX-TO-EBCDIC CONVERSION\n.FEAT37T ANOP\n         AIF   (NOT &$_FEAT(8)).FEAT8T\n@STRMASK32 DC    X'4020202020202020,2020202020202020'            RS0306\n         DC    X'2020202020202020,2020202020202120'              RS0306\n.FEAT8T  ANOP\n.**********************************************************************\n.*       Convert S-con to address                                     *\n.*             Input: GPR2 points to an S-CON in the remote parm list *\n.*             Output: GPR2 contains the address                      *\n.**********************************************************************\n@STRS2A  SLR   @00,@00\n         ICM   @00,B'0011',0(@02)      R0 = 0000BDDD\n         SRDL  @00,12                  R0 = 0000000B, R1= DDD.....\n         SRL   @01,20                  R1 = 00000DDD (DISPLACEMENT)\n         SLL   @00,2                   MULT BY 4\n         CLI   0(@02),@06*16+15        R7-R13?\n         JH    @STRS2A6                YES, JUMP\n.*BASE REG IS R0-R6\n*RS  ja  CLC   0(6,R6),@STRDUMP            FORCE DUMP\n*RS  ja  JE    @STRS2XX\n         LTR   @02,@00                 IS R0 THE BASE REG?\n         JNZ   @STRS2A5                NO, JUMP\n*        CLC   0(6,R6),@STRDUMP            FORCE DUMP\n*        JE    @STRS2XX\n         LTR   @02,@01                 IS THIS A PSA ADDRESS?\n         BNZR  @14                     YES, GOBACK\n*RS no   CLC   0(6,R6),@STRDUMP            FORCE DUMP\n*RS no   JE    @STRS2XX\n         EREG  @00,@00                 POP R0\n         LAE   @02,0                   R2=0 AR2=0\n         LR    @02,@00                 PASS R0 VALUE\n         LA    @02,0(,@02)             CLEAN UP\n         BR    @14                     GOBACK\n.*BASE REG IS R1-R6\n@STRS2A5 LR    @07,@00                 SAVE R0 (B*4)\n         LR    @08,@01                 SAVE R1 (DDD)\n         LR    @09,@03                 SAVE R3\n         LAE   @10,0(,@04)             SAVE R4\n         LR    @11,@05                 SAVE R5\n         LAE   @12,0(,@06)             SAVE R6\n         EREG  @01,@06                 RELOAD CALLER'S R1-R6\n*        CLC   0(6,R6),@STRDUMP            FORCE DUMP\n*        JE    @STRS2XX\n         EX    0,@STRS2A7-4(@07)       ADD BASE REG VALUE TO DISPL\n         LR    @03,@09                 RESTORE R3\n         LAE   @04,0(,@10)             RESTORE R4\n         LR    @05,@11                 RESTORE R5\n         LAE   @06,0(,@12)             RESTORE R6\n         BR    @14                     GOBACK\n@STRDUMP DC    XL6'84895004000F'      Dump string\n@STRS2XX DC    H'0'                    force dump\n.*BASE REG IS R7-R13\n@STRS2A6 LR    @02,@00                 R2= 0000000B (BASE REG NUMBER)\n         EREG  @07,@12                 RESTORE CALLER'S R7-R12\n         EX    0,@STRS2A7-4(@02)       ADD BASE REG VALUE TO DISPL\n         BR    @14                     GOBACK\n@STRS2A7 LAE   @02,0(@08,@01)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@08,@02)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@08,@03)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@08,@04)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@08,@05)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@08,@06)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@07)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@08)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@09)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@10)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@11)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@12)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@13)          ADD BASE REG VALUE TO DISPL\n         AIF   ('&OPT3' EQ 'LOCTR').GENL7L\n@STRBLANKS DC  CL((((*+&STRBLANKS+7-@STRING)/8)*8)-(*-@STRING))' '\n         AGO   .GENL7X\n.GENL7L  ANOP\n@STRBLANKS DC  CL&STRBLANKS.' '\n.GENL7X  ANOP\n@STRING_SIZE EQU *-@STRING             SIZE OF GENERATED CSECT\n         DROP  @06,@13,@15\n.**********************************************************************\n.*       WORK AREA (CALLER'S SAVE AREA)                               *\n.**********************************************************************\n@STRSAVE DSECT                         WORK AREA 144 Byte Savearea\n         DS    A(0,@STRSAVE)\n         DS    AD(14,15,0,1,2,3,4,5,6)\n@STRWK32 DS    FD'7,8,9,10'            WORK AREA\n@STRDWD  DS    FD'11,12'               WORK AREA                 RS0306\n         DS    A(@STRSAVE,@STRSAVE)\n@STRPARM DSECT\n@STRFLAG DS    B                   +0  FORMAT, FLAGS\n@STRLAST EQU   X'80'                     LAST ENTRY\n@STRLIT  EQU   X'40'                     LITERAL, @STRSCON IS AN OFFSET\n@STRX40  EQU   X'20'                   String of Spaces\n.*             X'0F'                   CONVERSION REQUIRED\n.*                                     or length of short literal\n@STRHEX  EQU   X'08'                     HEXADECIMAL\n@STRBIN  EQU   X'04'                     BINARY\n@STRPACK EQU   X'02'                     PACKED\n@STRREG  EQU   X'01'                     REGISTER\n@STRLEN2 DS    B                   +1  FORMAT, OUTPUT LENGTH\n.*                                     or start of short literal\n@STRLEFT EQU   X'80'                     LEFT JUSTIFICATION\n@STRZERO EQU   X'40'                     LEADING ZEROES\n.*             X'3F'                     OUTPUT LENGTH, 0 MEANS TRUNC.\n@STRSCON DS    S                   +2  FIELD ADDRESS\n@STRFLEN DS    S                   +4  FIELD LENGTH\n@STRNEXT EQU   *                   +6\n         AIF   (NOT D'$LTORG).MEND99   CSECT-ONLY\n         AIF   (D'$STRING).MEND99      CSECT-ONLY\n$LTORG   LOCTR\n         AIF   ('&OPT3' EQ 'LOCTR').GENL9L\n         CNOP  0,4\n$STRING  BALR  @15,0                   LOCAL BASE\n         L     @15,6(@15,0)            ROUTINE ADDRESS           00\n         BR    @15                     GO TO @STRING             04\n         AGO   .GENL9\n.GENL8   ANOP                          GENERATE,NOCSECT\n&$_LIT   SETA  0                       DO NOT GENERATE LITERALS TWICE\n&$_FEAT(1) SETB 1,1,1,1,1,1,1,1,1,1,1,1   GENERATE=FULL\n$LTORG   LOCTR\n         CNOP  0,4\n$STRING  BALR  R15,0                   LOCAL BASE\n         L     R15,6(R15,0)            ROUTINE ADDRESS           00\n         BR    R15                     GO TO @STRING             04\n.GENL9   ANOP\n         DC    V(@STRING)              ROUTINE ADDRESS           06\n.* MNOTE   1,'&$_CSECT_NO '\n         AIF   (&$_CSECT_NO EQ 1).MEND\n&I       SETA  2\n.*loop\n.GENL8K  ANOP\n.* MNOTE   1,'&$_CSECT(&I) '\n         AIF   ('&$_CSECT(&I)' EQ '').MEND\n&STR     SETC  '&$_CSECT(&I)'\n$LTORG_&STR LOCTR\n         CNOP  0,4\n$STRING_&STR BALR R15,0                LOCAL BASE\n         L     R15,6(R15,0)            ROUTINE ADDRESS           00\n         BR    R15                     GO TO @STRING             04\n         DC    V(@STRING)              ROUTINE ADDRESS           06\n&I       SETA  1+&I\n         AGO   .GENL8K\n.*endloop\n         AGO   .MEND\n.GENL9L  POP   USING                   GENERATE,LOCTR\n$STRING  BAS   R15,$STRING2\n         DC    Y(@STRING-*)            OFFSET TO @STRING ROUTINE\n$STRING2 AH    R15,0(R15,0)\n         BR    R15\n.MEND    AIF   ('&PRINT' EQ 'NOGEN').MEND99\n         POP   PRINT\n.MEND99  MEND\n         EJECT\n**********************************************************************\n**********************************************************************\n********* TEST PROGRAM FOR THE 'STRING' MACRO ************************\n**********************************************************************\n**********************************************************************\n**       STRING (GENERATE,AR_MODE)\n**       END\n         LCLA  &ASMH_HLASM\n         AIF   (T'&ASMH_HLASM EQ 'N').ASMH1X\n&SYSVER  SETC  'ASMH'\n&SYSDATC SETC  '20'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)\n.ASMH1X  ANOP\nTESTPGM  START X'027000'\nTESTPGM  AMODE 24                      (PRE-SMS PUT)\n         BALR  R12,0\n         USING *,R12\n*LOAD EP=SYSDEBUG\n*LR R15,R0\n*BASSM R14,R15\n*STRING641X,INTO=XXX\n         OPEN  (SYSPRINT,OUTPUT)\n         STRING64 'Assembler is &SYSVER, DATE is &SYSDATC',INTO=XXX\n         PUT   SYSPRINT,XXX\nRBPREFIX EQU   *\nRBINTCOD EQU   *+6,2,C'H'\nASCBASID EQU   *+8,2,C'X'\n         L     R1,PSATOLD-PSA(0,0)\n         L     R1,0(,R1)               TCBRBP\n         STRING64 'SVC',(RBINTCOD-RBPREFIX(R1),H,R3Z),                 X\n               1X,(WWWW,,T),' - ',     VV.MM OF SVC RTNE               X\n               ((R8),,X),1X,           COM-REG ADDR                    X\n               (ASCBASID,,X),1X,       ASID                            X\n               PARM1,1X,               MAIN PGM NAME                   X\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n*\n         LA    R2,XXX\n         STRING64 1X,INTO=((R2),8)\n         MACRO                                       JDATE MACRO\n        @JDATE &DATE                                 JDATE MACRO\n         LA    R1,=P'&DATE'                          JDATE MACRO\n*** STRING64((R1),P),2X,((R1),P),INTO=XXX\n         STRING64 ((R1),P),2X,((R1),P,YYMMDD),INTO=XXX,                X\n               3X,((R1),P,YY/MM/DD),                                   X\n               3X,((R1),P,DD/MM/YY),                                   X\n               3X,((R1),P,MM/DD/YY),                                   X\n               3X,((R1),P,YYYYMMDD),                                   X\n               3X,((R1),P,YYYY-MM-DD)\n         PUT   SYSPRINT,XXX                          JDATE MACRO\n         MEND                                        JDATE MACRO\n        @JDATE 90058\n        @JDATE 91059\n        @JDATE 93060\n        @JDATE 94365\n        @JDATE 80058\n        @JDATE 84059\n        @JDATE 88060\n        @JDATE 92061\n        @JDATE 00366\n         LA    R2,1234\n         STRING64 'CVTPTR=X''',(CVTPTR,4,X),'''',INTO=XXX,             X\n               ' 1234=',((R2),,R4Z)\n         PUT   SYSPRINT,XXX\n         L     R1,CVTPTR(0,0)\n         STRING64 'CVTDATE=',(56(R1),P,YYMMDD),INTO=XXX\n         PUT   SYSPRINT,XXX\n         LA    R0,1000\n         LA    R3,0033\n         STRING64 'D1=/',D1,'/,WWWW=/',WWWW,'/',                       X\n               ((R3),,L),'/',((R3),,X),'/',((R0),,L),'/',              X\n               ((R3),,R9B),'/',INTO=XXX\n         LR    R4,R15                   LENGTH USED\n         PUT   SYSPRINT,XXX\n         STRING64 WWWW,                                                X\n               (4(R13),4,X),'''',(4(R13),F),'''',                      X\n               (4(R13),F,L),'''',                                      X\n               (4(R13),F,L11),'''',                                    X\n               (4(R13),F,Z9),'''',                                     X\n               8X,'R4=',((R4),,L),      LENGTH USED                    X\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n         STRING64 %TIME,D1,'B12345678B',5X,(CTR1,P),1X,PARM1,1X,PARM2, X\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n         LA    R3,22\n         STRING64 INTO=XXX,'CCC1234A',(D1,(R3)),'.',(CTR1,P,R7Z)\n         PUT   SYSPRINT,XXX\n         STRING64 C'DDN2(',(D1,,T),')',X'40C1C2,C3C4',                 +\n               ' PSATOLD=',(PSATOLD-PSA,,X),                           +\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n         AIF   ('&SYSVER' EQ 'ASMH').HLASM99\nPSABASE  USING PSA,R0\n         STRING64 'PSATOLD=',(PSABASE.PSATOLD,,X),                     +\n               ' PSATOLD=',(PSATOLD-PSA,,X),                           +\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n.HLASM99 ANOP\n         BALR  R0,0\n         STRING64 'R0=',((R0),,X),'   16(R0)=',(16(R0),4,X),INTO=XXX\n         PUT   SYSPRINT,XXX\n         STRING64 'R0=',((R0),,X),'   CTR1=',(CTR1,P,R5B),INTO=XXX\n         PUT   SYSPRINT,XXX\n         SLR   R0,R0\n         STRING64 'R0=',((R0),,X),'   CTR2=',(CTR2,P,L),INTO=XXX\n         PUT   SYSPRINT,XXX\n*\nAMODE31  LA    R12,0(,R12)             BALR->BASR\n         L     R15,=A(*+X'80000006')   AMODE=31\n         BSM   0,R15                   AMODE=31\n         L     R1,=A(@STRING)          point at CSECT\n         CLC   =C'/390',11(R1)         (GENERATE,AR_MODE) ?\n         BNE   EXIT                    no, prevent S0E0\n         DSPSERV CREATE,                                               X\n               NAME==CL8'STRING00',    C'STRING00'                     X\n               BLOCKS=HDRBLKS,         SIZE IN PAGES                   X\n               STOKEN=DSPCSTKN,                                        X\n               ORIGIN=DSPCORG\n         ALESERV ADD,STOKEN=DSPCSTKN,ALET=DSPCALET\n         LAM   R8,R8,DSPCALET          POINT TO THE DATA SPACE\n         L     R8,DSPCORG              SPACE ORIGIN (0 OR 4096)\n         SAC   512                     MODE=AR\n LAM R14,R6,TESTPGM+40                 S0E0-28\n         STRING64 WWWW,'AR_MODE WORKED OK',INTO=(2048(R8),100)\n         LAM   R2,R2,DSPCALET          POINT TO THE DATA SPACE\n         LR    R2,R8                   SPACE ORIGIN (0 OR 4096)\n         STRING64 (2048+L'WWWW(R2),30,T),INTO=XXX\n         SAC   0                       MODE=AR OFF\n         PUT   SYSPRINT,XXX            AR_MODE WORKS OK\n*\nEXIT     SLR   R15,R15\n         SVC   3                       GOBACK\nD1       DC    C'D1-----D1    '\nWWWW     DC    C'WWWW'\nCTR1     DC    P'1'\nCTR2     DC    P'-33'\nPARM1    DC    C'<-PARM1->'\nPARM2    DC    C'<-PARM2->'\nXXX      DS    CL132\nDSPCSTKN DS    XL8                  0  AS TOKEN\nDSPCALET DS    F                    8  ALET\nDSPCORG  DS    F                   12  ORIGIN\nHDRBLKS  DC    F'100'\nCVTPTR   EQU   0016,4,C'A'\nSYSPRINT DCB   DSORG=PS,DDNAME=SYSPRINT,MACRF=PM,RECFM=FB,LRECL=121\nXYZ      DSECT\n         STRING64 GENERATE\n**       STRING (GENERATE,NO_CSECT) -\\\n**       STRING (GENERATE,AR_MODE)  -/\n**       STRING (GENERATE,,LOCTR)\n**       STRING (GENERATE,AR_MODE,LOCTR)\n**       STRING (GENERATE,NO_CSECT,LOCTR)    invalid combination\n         YREGS\nPSA      DSECT\nPSATOLD  EQU   *+X'21C',4,C'A'\n         END\n//SYSPRINT DD SYSOUT=*\n//*YSLIB   DD DISP=SHR,DSN=MVT.MACLIB           SAVE/GET          -DEL-\n//*        DD DISP=SHR,DSN=SYS1.MACLIB                            -DEL-\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//*\n//GO      EXEC PGM=LOADER,PARM=PRINT TIME=(,9)\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,DELETE)\n//SYSLOUT  DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n//ABNLTERM DD SYSOUT=*\n//ABNLIGNR DD DUMMY\n//SYSDEBUG DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n\n          +----------------------------------------+\n          +                                        +\n          +   Documentation for the STRING macro   +\n          +                                        +\n          +       Last update: 13 Dec 1999         +\n          +----------------------------------------+\n\n  The STRING macro is functionally similar to the COBOL DISPLAY\n  or PL/I PUT EDIT instructions.\n\n  Using STRING, you can concatenate any number of fields, edit\n  each of them if necessary, and get the result in the work area\n  you specify.\n\n  Formats:\n\n    (1) label  STRING {field_specification1}\n                      {,field_specification2}...\n                      ,INTO=workarea|(workarea,length)\n                      {,PRINT=GEN|NOGEN}\n\n    (2) label  STRING GENERATE\n                      {,PRINT=GEN|NOGEN}\n\n\n  field_specification\n\n    Each field to be printed is described as a positional\n    operand.  Each operand specifies the field address, its\n    length, and its formatting requirements.\n\n    Four field description formats are supported:\n\n      1.   symbol\n      2.   (symbol,length,format)\n      3.   (d(r)|(r),length,format)\n                                                                 RS0207\n      4.   ((r),,format) or ((Gr),,format)                       RS0207\n      5.   'character string'\n\n  Symbol specifies the field address.  It must be an\n    S-type (relocatable) address.\n\n  d(r) may be used to specify the field address in S/370\n    base-displacement format.  If d is zero, it may be omitted.\n    If d(r) or (r) is used, length must also be specified.  R14\n    and R15 may not be used.  If d(0) is used, it is handled the\n    way the assembler does, i.e. R0 as a base register is assumed\n    to contain zero: 16(0) is equivalent to 16, CVTPTR or, X'10'.\n\n  ((r),,format) specifies that (r) contains the value\n    itself, not an address.  R14 and R15 may not be used.\n\n  ((Gr),,format) specifies that (Gr) contains the value          RS0207\n    itself, not an address.  GR14 and GR15 may not be used.      RS0207\n    The display is the 64bit value                               RS0207\n\n  'character string' specifies a literal enclosed in single quotes\n    as specified in a DC instruction.  Hex strings or character\n    strings are supported.  The following expressions are equivalent:\n    'ABC' C'ABC' X'C1C2C3'\n\n  Length specifies the length and/or the type of the input field.\n    It may be specified as an integer, a symbol, a register, or a\n    constant.  When used with symbol, it overrides the assembled\n    length and/or type.  Length is required if field is specified\n    as d(r) or (r).  If a zero length is specified, the field is\n    ignored.\n\n        nn   field length in bytes\n        H    half-word\n        F    full-word\n        FL1  1-byte binary integer\n        FL3  3-byte binary integer\n        FD   Full-doubleword                                     RS0306\n        P    packed field\n        (r)  length of character string (R0 thru R12)\n        d(r) length of character string (R1 thru R12)\n\n  Notes:  If the field address is specified as a symbol that\n          has been defined previously in the program, the symbol\n          type is known and there is no need to specify it.\n\n          If the length is specified as (r) or d(r) and the value\n          is greater than the address itself, (r) or d(r) is\n          considered to be the end address +1 instead of the length.\n\n          The length is not specified for packed fields.  The\n          @STRING subroutine scans the field left-to-right until it\n          finds a byte with a valid sign in the low-order 4 bits.\n\n          If symbol is an arithmetic expression and no length is coded,\n          the implicit length will be that of the first symbol in the\n          expression;  for example, if symbol is coded as PSATOLD-PSA,\n          then the implicit length will be L'PSATOLD.\n\n          All numeric items are assumed positive.\n\n  format  optionally indicates editing options that must\n          be applied to a field.\n\n      L        left justified\n      R        right justified\n      nn       output length\n      0        adjust length\n      Z        leading zeroes\n      B        leading/trailing blanks\n      T        truncate character string after last non-blank\n      X        display in hexadecimal\n      YYMMDD   convert julian date to YYMMDD\n      YY/MM/DD convert julian date to YY/MM/DD\n      DD/MM/YY convert julian date to DD/MM/YY\n      MM/DD/YY convert julian date to MM/DD/YY\n      YYYYMMDD convert julian date to YYYYMMDD\n      YYYY-MM-DD convert julian date to YYYY-MM-DD\n\n    The default format depends on the field type:\n\n        Type                   Default Format\n\n        character string             L\n        FL1                          R3B\n        H or FL2                     R5B\n        FD/AD                        R16B                        RS0207\n        other numeric fields         R7B\n\n    Note: L0 and T are equivalent for character strings.\n\n  'character string' is any character string enclosed in\n  single quotes.  Blank spaces may be specified as nnX,\n  where nn is the number of X'40' bytes you want to be\n  inserted in the output line.  %TIME may be specified to\n  obtain the current time in hh.mm.ss.hh format.\n\nINTO=workarea|(workarea,length)\n\n  INTO indicates the address and length of the output work area\n  into which the result of the concatenation should be placed\n  (left justified).  If the work area is too small, truncation\n  will occur.  If it is too large, it is padded with blanks.\n\n  The address may be a symbol, d(r) (S-type address) or (r).\n\n  The length may be specified as an integer, a symbol, a register,\n  or a constant; it is required if the address is coded as d(r) or\n  (r).  If length is not specified for a symbol-type address, the\n  assembled length of the symbol is used.\n\n  Upon return from STRING, R15 contains the length actually used\n  in the output work area (before padding).\n\nPRINT=GEN|NOGEN\n\n  This operand allows you to temporarily override the PRINT\n  specification (GEN or NOGEN).\n\nGENERATE (format 2)\n\n  The GENERATE format must be specified once at the end of the\n  program.  It generates the @STRING sub-routine as well as all\n  the literals specified in previous invocations of the macro.\n\n  The GENERATE format allows the specifications of the\n  AR_MODE, NO_CSECT and LOCTR options.\n\n         STRING GENERATE<,AR_MODE<,LOCTR>>>\n                          NO_CSECT\n\n  The following combinations are valid:\n\n         STRING GENERATE              obsolete AR_MODE is always on\n         STRING (GENERATE,NO_CSECT)\n         STRING (GENERATE,AR_MODE)\n         STRING (GENERATE,,LOCTR)\n         STRING (GENERATE,AR_MODE,LOCTR)\n\n  The AR_MODE option can be specified to generate a @STRING module\n  supports AR mode (This is the default).  Example:\n\n         STRING (GENERATE,AR_MODE)\n\n  The NO_CSECT option can be specified to indicate that the\n  @STRING module should not be generated; only the literals\n  are generated in this case.  Example:\n\n         STRING (GENERATE,NO_CSECT)\n\n  The @STRING CSECT contains optional functions (such as %TIME or\n  julian date conversion) that are only generated if they have\n  been specified in the previous invocations of the STRING macro.\n\n  To generate of a @STRING CSECT that supports all of the optional\n  functions, two STRING GENERATE macros must be specified:\n\n         STRING (GENERATE,NO_CSECT)        Generate Literals\n         STRING GENERATE                   Generate CSECT\n\nExamples:\n\n     STRING 'ERROR===>',LINE1,'<=== POS ',((R6),,L0),INTO=WORKAREA\n\n     STRING 8X,C'ERRORS FOUND: ',(ERRORS,,L0),INTO=((R7),44)\n\n     STRING 'CVT ADDR IS ',(CVTPTR,4,X),X'40C1C2C3C4',INTO=LINE\n\n     LA    R5,WORK+16              end addr +1\n     STRING 'R4=',((R4),,X),INTO=(WORK,(R5)),PRINT=GEN\n\n     STRING '//JOBLIB DD DSN=',(DSN1,,T),',DISP=SHR',INTO=((R2),72)\n\n     PUT31 SYSLIN\n     LH    R0,SYSLIN+82            LRECL\n     STRING '   NAME  ',(4(R3),8,T),'(R)',INTO=((R1),(R0))\n\n     STRING GENERATE         Generate literals and sub-routine\n\n\nProgramming Notes:\n\n  A STRING macro generates only 6 bytes that need to be covered by\n  base registers.  More code is generated at the end of the\n  current CSECT (using LOCTR pseudo instruction), but this code\n  does not require addressability.  This is particularly useful\n  when STRING calls specify a large number of literals.\n\n  Additionally, STRING does not use A-type constants (ACON), but\n  S-type constants (SCON) which require symbols to be addressable\n  at the point in the program where STRING is issued.\n\n  While this reduces the number of base registers required to\n  cover the program's code and makes it easier to write reentrant\n  programs, it will produce assembly errors in the following\n  situations:\n\n  a.  STRING is used in more than one CSECT in the same assembly\n\n  b.  the CSECT in which STRING is used is longer than 64K\n\n  c.  symbols are not addressable at the point in the program\n      where STRING is issued\n\n  d.  the $STRING symbol (generated in the $LTORG LOCTR during the\n      GENERATE invocation of the STRING macro) is not addressable\n      in some of the STRING calls.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SYEXCIC": {"ttr": 12039, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00C\\x01\\x021\\x9f\\x01\\x021\\x9f\\x00#\\x00\\xf8\\x00\\xf8\\x00\\x00\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-15T00:00:00", "modifydate": "2002-11-15T00:23:43", "lines": 248, "newlines": 248, "modlines": 0, "user": "XSSGSCH"}, "text": "000200 Identification Division.\n000300 Program-Id. SYEXCIC.\n000400****************************************************************\n000500*                                                              *\n000600*  PROGRAM NAME: SYEXCIC                                       *\n000700*                                                              *\n000800*  TITLE: Ceda Commands from Batch                             *\n000900*                                                              *\n001000*  DATE: 28.12.96                                              *\n001100*                                                              *\n002100*                                                              *\n002200*  INPUT:         The target CICS system with which this       *\n002300*                 batch client program communicates can be     *\n002400*                 specified via the JCL PARM statement,        *\n002500*                 otherwise it defaults to applid DBDCCICS.    *\n002600*                 The target file is hardcoded as FILEA.       *\n002700*                                                              *\n002800*  OUTPUT:        The whole of the Target File will be output  *\n002900*                 to the SYSPRINT log, together with status    *\n003000*                 information.                                 *\n003100*                                                              *\n003200****************************************************************\n003300 Environment Division.\n003400*==============================================================*\n003500 Input-Output Section.\n003600 File-Control.\n003700     Select Printer assign to SYSPRINT.\n003710     Select Eingabe assign to SYSIN.\n003800 Data Division.\n003900*==============================================================*\n004000 File Section.\n004100*==============================================================*\n004200 fd  Printer\n004210     Block contains 128 Characters\n004300     Recording Mode S\n004400     Label Records omitted.\n004500 01  Output-Record      pic x(128).\n004501 fd  Eingabe\n004510     Block contains 80 Characters\n004520     Recording mode f.\n004540 01  Input-Record.\n004550     05 I-Target-Applid pic x(8).\n004560     05 I-Csd-Group     pic x(8).\n004570     05 Filler          pic x(64).\n004600 Working-Storage Section.\n004700*==============================================================*\n004800*   Declare Call level,DPL, and EXEC level Return Code areas.  *\n004900*==============================================================*\n005000 COPY DFHXCPLO.\n005100*==============================================================*\n005200*   Declare Areas to be used for outputting return codes.      *\n005300*==============================================================*\n005400 01  Output-RetArea.\n005500   05                   pic x(20)  value Spaces.\n005600   05  O-Resp           pic 9(8).\n005700   05                   pic xx     value Spaces.\n005800   05  O-Resp2          pic 9(8).\n005900   05                   pic xx     value Spaces.\n006000   05  OExci-Sub-Reason1 pic 9(8).\n006100   05  O-AbCode-Line    redefines OExci-Sub-Reason1.\n006200       10  O-AbCode     pic x(4).\n006300       10  Opad-AbCode  pic x(4).\n006400   05                   pic x(80) value Spaces.\n006500 01  Sub                pic s9(8) comp.\n006510 01  Ceda-Sev-Num       pic 9(2)  value 0.\n006520 01  Ceda-Sev-Highest   pic 9(2)  value 0.\n006600 01  Out-Rec.\n006700   05 Out-Rec-Elem      pic x occurs 128 times.\n008100*==============================================================*\n008200*   Initialise Target information variables.                   *\n008300*==============================================================*\n008500 01  Target-Program     pic x(8)       value 'SYEXCIS '.\n008600 01  Target-Transid     pic x(4)       value 'EXCI'.\n009500*==============================================================*\n009600*   Define Commarea struct.                                    *\n009700*==============================================================*\n009800 01  Commarea.\n009801   03  Commarea-Data.\n009810     05  Length-Commarea-Comm pic s9(4)  comp.\n009820     05  Commarea-Comm.\n009900       10  Cics-Transaction pic x(4)     value 'CEDA'.\n009910       10                   pic x        value Spaces.\n010000       10                   pic x(10)    value 'INSTALL G('.\n010100       10  Cics-Tran-Ext    pic x(8)     value Spaces.\n010110       10                   pic x        value ')'.\n010111       10                   pic x(70)    value Spaces.\n010112     05  Length-Commarea-Rcv pic s9(4)   comp.\n010120   03  Commarea-Rcv.\n010130     05                   pic s9(4)      comp.\n010140     05                   pic s9(4)      comp.\n010150     05                   pic s9(4)      comp.\n010160     05                   pic s9(4)      comp.\n010170     05 No-of-Msgs        pic s9(4)      comp.\n010180     05 Ceda-Severity     pic s9(4)      comp.\n010190     05                   pic x.\n010200     05 Ceda-Message      pic x(80).\n010300     05                   pic x(3905).\n011000*==============================================================*\n011100*   Initialise program specific variables and flags.           *\n011200*==============================================================*\n011400 01  Program-Flags.\n011500   05  Abort-Flag       pic x(3)       value 'NO '.\n011600       88 Abort                        value 'YES'.\n011700       88 No-Abort                     value 'NO '.\n011800   05  Eof-Flag         pic x(3)       value 'NO '.\n011810       88 Eof                          value 'YES'.\n011820       88 No-Eof                       value 'NO '.\n011900 01  Program-Messages.\n012000   05  Msg00  pic x(128) value Spaces.\n012100   05  Msg01  pic x(128) value '*===================== Batch CSD-I\n012200-     'nstall ======================================*'.\n012300   05  Msg02  pic x(128) value '*\n012400-     '                                             *'.\n012500   05  Msg03  pic x(128) value '*  Following Command will be proce\n012600-     'ed:                                          *'.\n014100   05  Msg11  pic x(128) value '*    The Link Request has failed.\n014200-     ' Return codes are:                           *'.\n014300   05  Msg13  pic x(128) value '*    A message was received from t\n014400-     'he target CICS system:                       *'.\n014500   05  MSg14  pic x(128) value '*    >>>> Aborting further process\n014600-     'ing <<<<                                     *'.\n017700   05  Msg31  pic x(128) value '*=================== End of Batch\n017800-     'CSD-Install =================================*'.\n017900*==============================================================*\n018000 linkage section.\n018100   01  Null-ptr  usage is Pointer.\n018200*\n018900   01  Exec-Level-Msg.\n019000     05 Exec-Level-Msg-Text pic x occurs 128 times.\n019100*\n019500\n019600 Procedure Division.\n019700     Open output Printer\n019710     Open input Eingabe\n019720     Write Output-Record from Msg00\n019730     Write Output-Record from Msg01\n019740     Write Output-Record from Msg02\n019800*==============================================================*\n019900*    Get data from Eingabe                                     *\n020000*==============================================================*\n020010     Perform until eof or abort\n020100       Read Eingabe\n020110         at end\n020120           Set Eof to true\n020130       End-Read\n020140       If eof\n020141         Continue\n020142       else\n023200*        Set up the Commarea for transmission.\n023600         Move Spaces         to   Commarea-Rcv\n023610         Move I-Csd-Group    to   Cics-Tran-Ext\n023620         Move Length of CommArea-Comm to Length-Commarea-Comm\n023630         Move Length of CommArea-Rcv  to Length-Commarea-Rcv\n023700         Write Output-Record from Msg03\n023701         Move Spaces         to Out-Rec\n023702         Move '* '           to Out-Rec (1:3)\n023703         Move 'Cics:'        to Out-Rec (4:5)\n023704         Move I-Target-Applid to Out-Rec (9:8)\n023705         Move Commarea-Comm  to Out-Rec (18:61)\n023710         Move '*'            to Out-Rec (80:1)\n023720         Write Output-Record from Out-Rec\n023800*        Perform the Link Request\n024000         Exec Cics Link Program(Target-Program)\n024100                        TransId(Target-TransId)\n024200                        Applid(I-Target-Applid)\n024300                        Commarea(Commarea)\n024400                        Length(Length of Commarea)\n024500                        DataLength(Length of Commarea-Data)\n024600                        RetCode(Exci-Exec-Return-Code)\n024700                        SyncOnReturn\n024800         End-Exec\n025000*        Check on how well the request has performed. We may have\n025100*        to abort further processing if either the link, or the\n025200*        server program failed in any way.\n025400         If Exec-Resp = 0\n025500           Perform Check-Server\n025600         else\n025700           Perform Link-not-ok\n025710         end-If\n025711       end-If\n025712     end-Perform\n025720     Write Output-record from Msg02\n025730     Write Output-record from Msg31\n025740     Close Printer Eingabe\n025741     Move  Ceda-Sev-Highest to Return-Code\n025742     If Abort\n025743       Move 12  to Return-Code\n025744     end-if\n025760     stop run\n026110     .\n026200******************************************************************\n026210*\n026300*  The following code performs the required response checking\n026400*  and will decide whether an abort is neccessary.\n026500*\n026510******************************************************************\n026600 Check-Server Section.\n026602     Move Spaces        to Out-Rec\n026603     Move '*'           to Out-Rec (1:3)\n026604     Move 'Returncode:' to Out-Rec (4:12)\n026605     Move Ceda-Severity to Ceda-Sev-num\n026607     Move Ceda-Sev-num  to Out-Rec (16:2)\n026608     If Ceda-Sev-num > Ceda-Sev-Highest\n026610       Move Ceda-Sev-num to Ceda-Sev-Highest\n026611     end-If\n026612     If Ceda-Severity > 0\n026613        Move Ceda-Message  to Out-Rec (19:60)\n026614     end-If\n026615     Move '*'           to Out-Rec (80:1)\n026616     Write Output-Record from Out-Rec\n026617     Write Output-Record from Msg02\n026620     .\n029100 Check-Server-End.\n029200     exit\n029210     .\n029220******************************************************************\n029230*\n029240*  The following code performs the required response checking\n029250*  and will decide whether an abort is neccessary.\n029260*\n029270******************************************************************\n029300 Link-not-ok Section.\n029400     Write Output-Record from Msg11\n029500     Move  Exec-Resp     to   O-Resp\n029600     Move  Exec-Resp2    to   O-Resp2\n029700     Move  Spaces        to   Opad-AbCode\n029900     Move  Exec-Abcode   to   O-AbCode\n030000     Write Output-Record from Output-Retarea\n030100     If Exec-Msg-Ptr equal Nulls\n030110       Continue\n030120     else\n030200       Write Output-Record from Msg13\n030300       Write Output-Record from Msg02\n030400       Set   Address of Exec-Level-Msg to Exec-Msg-ptr\n030500       Move  Spaces to Out-Rec\n030600       Perform test before varying Sub from 1 by 1\n030800                           until Sub > Exec-Msg-Len\n030900         Move Exec-Level-Msg-Text (Sub) to Out-Rec-Elem (Sub)\n031000       end-Perform\n031100       Write Output-Record from Out-Rec\n031200       Write Output-Record from Msg02\n031300     end-If\n031400     Write Output-Record from Msg14\n031500     Set Abort to true\n031710     .\n031720 Link-Not-ok-End.\n031730     exit\n031740     .\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SYEXCIS": {"ttr": 12289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01\\x021\\x9f\\x01\\x021\\x9f\\x00$\\x00]\\x00]\\x00\\x00\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-15T00:00:00", "modifydate": "2002-11-15T00:24:32", "lines": 93, "newlines": 93, "modlines": 0, "user": "XSSGSCH"}, "text": "*ASM XOPTS(SP)\n***********************************************************************\n*                                                                     *\n* Name:         SYSEXCIS                                              *\n*                                                                     *\n* Author:       Roland Schiradin                                      *\n*                                                                     *\n* Date:         December 1996                                         *\n*                                                                     *\n* Descrition:   Cics ExCi-server for Ceda-Commands                    *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n*=====================================================================*\n*                                                                     *\n*      Working Storage.                                               *\n*                                                                     *\n*=====================================================================*\n*\nDFHEISTG DSECT  ,                    |Program Variables.             |\nEYECATCHER   DC CL8'WSTORAGE'        |                               |\nIO_FLAG      DS X'00'                |  Flag indicate Output of ceda |\nCEDA_PARAMETER DS 0F                 |  Ceda_Parameter               |\nCEDA_PARM1     DS F                  |    First Parm                 |\nCEDA_PARM2     DS F                  |    Second Parm                |\nCEDA_PARM3     DS F                  |    Third Parm                 |\nCEDA_PARM4     DS F                  |    Fourth Parm                |\nCEDA_PARM5     DS F                  |    Fifth Parm                 |\n*=====================================================================*\n*                                                                     *\n*      Commarea DSECT.                                                *\n*                                                                     *\n*=====================================================================*\n*\nCOMMAREA DSECT\nL_COMMAREA_COMM DS H\nCOMMAREA_COMM DS  CL94               | CommArea-Command\nL_COMMAREA_DATA DS H\nCOMMAREA_DATA DS  CL3998             | CommArea-Data\n*\nSYEXCIS  DFHEIENT CODEREG=(R3),DATAREG=(R6,R7)\n*\n*=====================================================================*\n*   Check that a COMMAREA has been passed. If we don't have a commarea*\n*   we cannot even return a return code back to the client, so issue  *\n*   an abend instead.                                                 *\n*=====================================================================*\n         CLC   EIBCALEN,=H'0'\n         BNE   PARSE\n         EXEC CICS ABEND ABCODE('NCOM')\n*\n*=====================================================================*\n*   Map the COMMAREA DSECT onto the Commarea passed.                  *\n*=====================================================================*\nPARSE    DS    0H\n         EXEC CICS ADDRESS COMMAREA(R4)\n         USING COMMAREA,R4              tell assembly\n*\n*=====================================================================*\n*   Setup the Parmeterlist                                            *\n*=====================================================================*\n         LA    R5,COMMAREA_COMM         setup the PLIST\n         ST    R5,CEDA_PARM1\n         LA    R5,L_COMMAREA_COMM\n         ST    R5,CEDA_PARM2\n         LA    R5,IO_FLAG\n         ST    R5,CEDA_PARM3\n         LA    R5,COMMAREA_DATA\n         ST    R5,CEDA_PARM4\n         LA    R5,L_COMMAREA_DATA\n         ST    R5,CEDA_PARM5\n         OI    CEDA_PARM5,X'80'         mark as last parm\n*\n*=====================================================================*\n*   Set parms                                                         *\n*=====================================================================*\n         MVI   IO_FLAG,X'00'            avoid Terminalputput\n*\n*=====================================================================*\n*   Link to DfhEdap                                                   *\n*=====================================================================*\n         EXEC CICS LINK PROGRAM('DFHEDAP') COMMAREA(CEDA_PARAMETER)\n*\n*=====================================================================*\n*   All calls return to here.  Control is passed back to the Client   *\n*=====================================================================*\n*\nRETURN   DS    0H\n         EXEC CICS RETURN\nBLANKS   DC  CL256' '\n*\n         DFHREGS\n         END SYEXCIS\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZOBANALZ": {"ttr": 12292, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00\"\\x01\\x08\\x17\\x7f\\x01\\x165\\x7f\\x13\\x02 g\\x1b\\x8b\\x00\\x00\\xe5\\xf1K\\xf5K\\xf2@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2008-06-25T00:00:00", "modifydate": "2016-12-22T13:02:22", "lines": 8295, "newlines": 7051, "modlines": 0, "user": "V1.5.2"}, "text": "***********************************************************************\n*                                                                     *\n* Name:         COBANAL                                               *\n*                                                                     *\n* Author:       Roland Schiradin                                      *\n*               roland(at)Schiradin.de                                *\n*                                                                     *\n* Date:         February 1996                                         *\n*                                                                     *\n* Description:  Show compile-settings and some other information      *\n*                                                                     *\n* Changes:      16.12.1996 (european)                                 *\n*               Support for VS/COBOL1 (just a few)                    *\n*               String macro no longer inside this source             *\n*               (request FILE183 from Naspa or drop me an email)      *\n*               28.04.1997 (european)                                 *\n*               Support for COBOL for MVS and VM Release 2 (formally  *\n*               called AD/Cycle COBOL/370)                            *\n*               04.03.1998 (european)                                 *\n*               MODID-marco dropped                                   *\n*               Direct Load-Library support                           *\n*               Some parts of Dave Alcocks code (DA$COBR)             *\n*               (You can contact him at dalcock(at)csw.com)           *\n*               24.03.1998 (european)                                 *\n*               Prevent S15D abend you invoke COBANAL from TSO-CALL   *\n*               (reported by Dave Alcock)                             *\n*               Support for newer STRING macro STRING GENERATE instead*\n*               of STRING FINAL_CALL                                  *\n*               (reported by Dave Alcock)                             *\n*               Fixed a bug in statement list. Y now means Yes and not*\n*               vice versa. Sorry                                     *\n*               15.02.1999 (european)                                 *\n*               Support for COBOL OS/390 and VM V2R1                  *\n*               Some new Compile-options                              *\n*               Compile-Date is European style, added long name       *\n*               Some minor fixes I cant remember in detail            *\n*               Support for MVS 4.3 (AMODE switching)                 *\n*               10.06.1999 (european)                                 *\n*               Fixed bugs reported by Mr. Smets (Thank you)          *\n*               Show ?? as the century for COBOL2                     *\n*               Support for Entrypoints (e.g. ENTRY 'DLITCBL')        *\n*               Note: There is no need to do this for IMS             *\n*               25.10.1999 (european)                                 *\n*               Check ParmLength for Parameter \"ALL\".                 *\n*               Close all datasets                                    *\n*               Make CobAnal reentrant (LinkList!!!)                  *\n*               Release storage                                       *\n*               Load modules from DD COBANAL if exist                 *\n*               29.12.1999 (european)                                 *\n*               Abend 0C4 fixed                                       *\n*               Add PPA2 support                                      *\n*               Detect C/C++ and LE-enabled Assembler Programs        *\n*               The product name for COBOL1 is OS/VS Cobol (MVS) and  *\n*               DOS/VS COBOL (VSE)                                    *\n*               13.04.2000 (european)                                 *\n*               Support for some infos I missed (INVOKE, GLOBAL and   *\n*               so on) Thank you Mr. Gross                            *\n*               Add a third base register                             *\n*               23.04.2000 (european)                                 *\n*               Tested with STRING V507 from FILE183                  *\n*               19.07.2000 (european)                                 *\n*               Support for COBOL1 OEM products (e.g. CA-Optimzer)    *\n*               Thank you Mr. Pfeifer                                 *\n*               02.10.2000 (european)                                 *\n*               Support for COBOL for OS/390 & VM V2R2                *\n*               New TEST(SEPARATE)/NO TEST(SEPARATE)                  *\n*               New ARITH(EXTEND)/ARITH(COMPAT)                       *\n*               New line-sequential file                              *\n*               Thank you IBM for HFS-Support and Display under CICS  *\n*               Save some literal pool                                *\n*               I know I need to re-design the program but the        *\n*               time (you may know) is limited. At the start it       *\n*               was intend to run once and then throw it away         *\n*               Thanks for all ideas to do it better, if I'm retired  *\n*               I would spent some time on it. Don't expect that      *\n*               within the next 25 years !!!                          *\n*               09.10.1999 (european)                                 *\n*               End-Substract changed to End-Subtract                 *\n*               Corect a length for moving literal Subtract           *\n*               08.01.2001 (european)                                 *\n*               Loop bug fixed                                        *\n*               04.12.2001 (european)                                 *\n*               Fixed bug reporting CLOSE Y/N                         *\n*               Support for Cobol Enterprise V3R1                     *\n*               Support for generic member names                      *\n*                 You can use ? or * in the member name to minimize   *\n*                 output instead of ALL or a single load member       *\n*                 '?' stand for any single character                  *\n*                 '*' stand for any character                         *\n*                 Be aware this feature require SYS1.MODGEN(ASAXWC)   *\n*                 introduced with MVS 5.2                             *\n*               ** Attention ****                                     *\n*                  CobAnal require MVS 5.2                            *\n*               ** Attention ****                                     *\n*               ASAXWC is not GUPI but I raised a requirement         *\n*               If you think ASAXWC might be useful for you too,      *\n*               please open a requirement                             *\n*               12.02.2002 (european)                                 *\n*               Support for IMS programs with an Entry Point DLITCBL  *\n*               I still believe such an entry point is not needed     *\n*               but it seems it's in use. However David Sumner        *\n*               made the needed changes and I merged it to the        *\n*               current source so it will be a part of CobAnal        *\n*               Special thank you to David Sumner                     *\n*               14.04.2002 (european)                                 *\n*               CobanalZ require now Architecure Level 1 this means   *\n*               it has the same requirement as OS/390 R10. If your    *\n*               hardware doesn't support OS/390 R10 you can not use   *\n*               CobAnalZ you have to use the old version called       *\n*               CobAnal. New features will be added to CobAnalZ       *\n*               but bug-fixes also for CobAnal.                       *\n*               No base register needed (base-less)                   *\n*               Support RMODE(ANY)                                    *\n*               Prepared for z/OS R3 with AMODE(64)                   *\n*               01.11.2002 (european)                                 *\n*               Support for Cobol Enterprise V3R2                     *\n*               Avoid LARL instruction                                *\n*               17.01.2003 (european)                                 *\n*               CMPR2 is not supported for Enterprise Cobol           *\n*               29.01.2004 (european)                                 *\n*               Merged code from Mike Giaquinto to prevent a S0C4     *\n*               if the entry point is close to the end of the load    *\n*               12.03.2004 (european)                                 *\n*               Support for Cobol Enterprise V3R3                     *\n*               Support for IEWBIND to display binder info (basic)    *\n*               Display CICS Precompiler version                      *\n*               Display CICS STUB version                             *\n*               Display CICS EXCI version                             *\n*               Changed the RC handling                               *\n*               17.05.2004 (european)                                 *\n*               Support for MOD level 1. Indicator DB2 V8 SQL is      *\n*               supported by V3R2 and V3R3 (PQ83744)                  *\n*               Detect PLI, DCE, Sockets programs                     *\n*               08.07.2004 (european)                                 *\n*               Support for DLL with multiple extents, but            *\n*               CobAnal just analyze the first extent. In the past    *\n*               it could abend with a S0C4                            *\n*               (reported by Adam Hojniak)                            *\n*               21.07.2004 (european)                                 *\n*               Spelling problem (End-Multiply)                       *\n*               20.01.2005 (european)                                 *\n*               AbendS80A                                             *\n*               Release storage in case of Binder RC <> 0             *\n*               (reported by Didier Lamare)                           *\n*               14.03.2005 (european)                                 *\n*               Support for new C and C++ layout                      *\n*               07.07.2005 (european)                                 *\n*               Support for Cobol Enterprise V3R4                     *\n*               FDUMP not for Cobol/370 (Enterprise Cobol)            *\n*               Minor fixes                                           *\n*              *V1.1  - April 2006: S.Stocker modified for CSC    *CSC*\n*               - NOTE: All changes developed&run on OS/390 V2.10 *CSC*\n*               - Add SUMMARY DD to provide a single-line summary *CSC*\n*                 module by module highlighting the key info such *CSC*\n*                 as Langauge and Compiler and then info relating *CSC*\n*                 to 31-bit exploitation and Reentrancy. Invoked  *CSC*\n*                 by PARM=SUMMARY so you lose wildcard function!  *CSC*\n*               - Added identification of BMS Maps.               *CSC*\n*               - COBOL2 versus COBOL3 CICS Translate option      *CSC*\n*               - Identify Languages translated by CICS           *CSC*\n*               - Tally of modules by language.                   *CSC*\n*               - No support for COBOL CICS integrated translator *CSC*\n*               - All changes (hopefully) are marked *CSC*        *CSC*\n*              *V1.2  - April 2006:                               *CSC*\n*               - Fix S0C4: loss of addressability to COBOL1 TGT  *CSC*\n*               - Fix S0C4: on very small modules. Now enforce    *CSC*\n*                 no analysis for modules < 32 bytes. Messages    *CSC*\n*                 are issued in both reports.                     *CSC*\n*               - Remove need for PARM='SUMMARY' to produce the   *CSC*\n*                 SUMMARY report. This means all the wildcard     *CSC*\n*                 searching is now available again. Yeah!         *CSC*\n*               - Add specific messages for modules marked as     *CSC*\n*                 NX (Not Executable).                            *CSC*\n*               - Ensure at least module name and *INVALID is     *CSC*\n*                 written to SUMMARY RPT for unloadable modules.  *CSC*\n*               - Change sub-headings from ======= to -------     *CSC*\n*                 improve ease of locating start of next module.  *CSC*\n*              *V1.2a - April 2006: Fix z/OS V1.4 TIOT problem    *CSC*\n*              *V1.2b - Rework Mr Schiradin's latest fixes:       *CSC*\n*               06.02.2006 (european)                                 *\n*               New PL/1 looks like new C/C++                         *\n*              *V1.30 - October 2007 R.Schiradin                 RS1007\n*               - Release-ID is now dynamic                      RS1007\n*               - RUSE changed to REUS (like the binder)         RS1007\n*               - Some info lines are to short                   RS1007\n*               - End-Multiply literal was to short              RS1007\n*               - Tested with Cobol Enterprise V3R4M1            RS1007\n*               - Reformat the compile options                   RS1007\n*               - Provide more BINDER info                       RS1007\n*               - Debugcode for IEWBIND (add DDNAME              RS1007\n*                 BINDEROU DD SYSOUT=* to activate)              RS1007\n*               - get the real TGT but of no use so far          RS1007\n*               - Support for long names listed as $PRIVnnnnnn   RS1007\n*               - Support for new C/C++ and new PL1 formats      RS1007\n*               - Display Binder info for NON-COBOL              RS1007\n*               - Support for large include names                RS1007\n*               - Report TGT usage via R9 or R13 (Peter Haus)    RS1107\n*               - Report working storage size                    RS1107\n*               - Report FCB for Cobol/370 and COBOL/ENT (P.Haus)RS1107\n*               - C/370 now C/C++                                RS1107\n*               - PK54632 for some missing END-XXXX (FIN APAR)   RS1107\n*               - Minor fixes (John P. Kalinich)                 RS1107\n* ------->      - z/Architecture required                        RS1107\n*               - Use STRING64 instead of STRING                 RS1107\n*               - Report CEEUOPT/#pragma/PLXOPT if present       RS1107\n*               - Yearwindow for COBOL/2                         JK1107\n*               - Report FCB for COBOL/2                         RS1107\n*               - Cobol-submodul-infos (lmod only)               HP1107\n*               - cobol-submodul-infos (main=asm  )              RS1107\n*               - Update CSCCOMP only for main                   RS1107\n*               - program-objects : associated CSV_OUTXTLST_ELPx HP1107\n*                 search a second extent for CEEUOPT             HP1107\n*               - Fixed S0C4                                     RS1107\n*               - Show only changed CEEUOPTs                     RS1107\n*              *V1.40 - December 2007 R.Schiradin                RS1207\n*               - Fixed S0C4 (John Kalinich)                     RS1207\n*               - First version to identify FORTRAN (J. Kalinich)RS1207\n*               - Report \"RENT REUS\" wrong (John Kalinich)       RS1207\n*               - Report AMODE64 (John Kalinich)                 RS1207\n*               - CICS-Eyecatcher case sensitive (report wrong   RS1207\n*                 COBOL3 option) since CTS 3.1                   RS1207\n*               - Support for member list via SYSIN              RS1207\n*               - Support for Enterprise Cobol V4.1              RS1207\n*               - Cosmetical change FCB-Header (John Kalinich)   RS1207\n*               - Wrong Compiler Version in the summary report   RS0108\n*                 (John Kalinich)                                RS1207\n*               - Omit analyze of includes (add DDNAME           RS0108\n*                 MAINONLY DD DUMMY to activate)                 RS0108\n*                 (Engelbert Smets)                              RS0108\n*               - Fixed S0C4 (Ludwig Hartmann)                   RS0108\n*                 EP2 is not always the correct entry point.     RS0108\n*              *V1.41 - June 2008 R.Schiradin                    RS0608\n*               - Fixed S0C4 (Werner Tomek)                      RS0608\n*                 Missing parm cause abend                       RS0608\n*               - Fix bug from using IEW_SECTION+2 in calls to   PF0608\n*                 STRING64 macro.  Set up separate _LEN and      PF0608\n*                 _DATA names so length is computed correctly    PF0608\n*               - Increase available STATIC_AREA by moving all   PF0608\n*                 initializing static DCB/DCBE's to separate     PF0608\n*                 CSECT's                                        PF0608\n*               - Introduce new DCB/DCBE named LOADL with        PF0608\n*                 DSORG=PO for LOAD from COBANAL so that the     PF0608\n*                 COBANAL DD can be concatenated (multiple DSN's)PF0608\n*               - Add reset for indentation in all cases, so     PF0608\n*                 that load-module-level information is not      PF0608\n*                 incorrectly indented                           PF0608\n*               - Add comments for each IEWBUFF area describing  PF0608\n*                 what kind of data is returned in each one      PF0608\n*               - Avoid msg IEW2134S from IEWBIND FUNC=ENDD when PF0608\n*                 FUNC=STARTD failed for any reason              PF0608\n*               - Avoid IEWBIND FUNC=DELETEW when FUNC=CREATEW   PF0608\n*                 failed for any reason                          PF0608\n*               - Avoid DELETE when PGMNAME_GET is XL8'FF' or    PF0608\n*                 the LOAD failed for any reason                 PF0608\n*               - Try to open SUMMARY file even if no COBANAL    PF0608\n*                 is present so all scanned members will be      PF0608\n*                 summarized                                     PF0608\n*               - Issue CLOSE for SYSIN (avoid SC03 abend at EOJ)PF0608\n*               - Do not subtract one from count of names so     PF0608\n*                 that all names are processed                   PF0608\n*               - From SD/ED entries in ESD section try to       PF0608\n*                 provide AMODE/RMODE info and from IDRL section PF0608\n*                 try to provide compiler/language/compile-date  PF0608\n*                 info for load modules that are \"UNKNOWN\" after PF0608\n*                 scans of load module text                      PF0608\n*               - From ED/LD entries in ESD section try to       PF0608\n*                 provide actual entry point name in CSCLPRM     PF0608\n*                 field in SUMMARY line for load modules that    PF0608\n*                 are \"UNKNOWN\" after scans of load module text  PF0608\n*               - Save the Binder date and (if present) main     PF0608\n*                 CSECT compile date for placement into the      PF0608\n*                 SUMMARY line in case no date is found based on PF0608\n*                 the object text                                PF0608\n*               - Recover from IEWBIND FUNC=INCLUDE when RC=8    PF0608\n*                 and RSNCODE=X'83000514' by re-trying INCLUDE   PF0608\n*                 from DD COBANAL and member name (INTYPE=NAME)  PF0608\n*                 using new DSORG=PO DCB/DCBE LOADL (see above)  PF0608\n*               - Adjust a few messages for spelling and/or for  PF0608\n*                 grammar                                        PF0608\n*               - Add language indicators to PID table and also  PF0608\n*                 sort by language, then use language indicators PF0608\n*                 to adjust language counters for main EP's only PF0608\n*               - Also made the PID Table an external member for PF0608\n*                 easier modifications and sorting of entries    PF0608\n*               - Fix AMODE bug for SUMMARY line in LE_370 code  PF0608\n*                 for modules that start out \"UNKNOWN\"           PF0608\n*               - Fix RENT  bug for SUMMARY line in LE_370 code  PF0608\n*                 for modules that start out \"UNKNOWN\"           PF0608\n*               - Add detection for compiled EZTrieve+ programs  PF0708\n*                 and display EZTrieve+ version and compile date PF0708\n*               - Fix error in BINDER_INFO_32 code so an actual  PF0708\n*                 FORTRAN IDL entry is not ignored when found    PF0708\n*              *V1.42 - September 2008 R.Schiradin               RS0908\n*               - Minor fix in the display                       RS0908\n*               - COBANAL was not RENT. Invocation from          RS0908\n*                 LINKLIST gets S0C4 or using SETPROG REFRPROT   RS0908\n*                 cause abend S0C4. I missed to use the List and RS0908\n*                 Execute form of Macro Load.                    RS0908\n*               - Correct setting of DCBE in the DCB             RS0908\n*               - Abend0C4 for EZtrieve programs                 RS1208\n*               - Case sensitive coding                          RS1208\n*               - Count Unknown as other was wrong               RS1208\n*              *V1.43 - February 2009 R.Schiradin                RS0209\n*               - Allow comments in the SYSIN                    RS0209\n*                 - May 2009 Craig Schneiderwent                 =CMS=\n*               - Added JUSTDATA DD for those who wish to        =CMS=\n*                 perform post-processing on the results         =CMS=\n*                 - June 2009 Kirk Poschman                      KP0609\n*               - Not fully rent                                 KP0609\n*               - Alignment                                      KP0609\n*              *V1.44 - February 2009 R.Schiradin                RS0712\n*               - CMPR2 report missing for Cobol/2               RS0209\n*              *V1.45 - January 2015  R.Schiradin                RS0115\n*               - New PID for Enterprise Cobol V4 and V5         RS0115\n*               - Basic support for Ent. Cobol V4 and V5         RS0115\n*              *V1.46 - July 2015 R.Schiradin                    RS0615\n*               - Fixed issue reported and almost fixed by       RS0615\n*               Steve Stocker                                    RS0615\n*              *V1.47 - October 2015 R.Schiradin                 RS1015\n*               - Full support for Enterprise Cobol V5.1+V5.2    RS1015\n*              *V1.50 - January 2016  E.Simonsen                 ES0116\n*               - use whole words in report for                  ES0116\n*               - options and procedure                          ES0116\n*               New PID for Enterprise Cobol V6                  RS0316\n*               Abend 0C4 fixed when load contains included      RS0316\n*               Enterprise Cobol V5 sub routines                 RS0316\n*               Use the binder info for invalid programs too     RS0316\n*               Display RMODE in the SUMMARY                     RS0316\n*              *V1.51 - May 2016 Roland Schiradin                RS0516\n*               - Support for Enterprise Cobol V6.1              RS0516\n*               - NOTEST(DWARF) was wrong                        RS0516\n*               - Binder RMODE is now working using BLDL         RS0516\n*               - RC4 instead of RC12 for PGM not found by SYSIN RS0516\n*               - XMLPARSE option was wrong                      RS0616\n*              *V1.52 - Dec 2016 Roland Schiradin                RS1216\n*               - Fix abend S0C4                                 RS1216\n*               - Fix abend S206-0C clear load parms             RS1216\n         MACRO\n&NAME   #STATUS &BYTE,&BIT,&MSG\n         AIF   ('&BYTE'(1,3) EQ 'CVT' AND NOT D'&BIT).MEND\n&NAME    TM    &BYTE,&BIT              check flag\n         BRASL R14,$$STATUS            check CC, move, bump ptr\n&N       SETA  K'&MSG-3\n         DC    AL1(&N),C&MSG,0H'0'     Length,text,alignment\n.MEND    MEND\n&REL     SETC 'V1.52'                  Release number            RS0316\n***********************************************************************\n         TITLE 'CobAnal &REL Cobol-Analyser and a bit more'      RS1007\nCOBANAL  CSECT\nCOBANAL  AMODE 31\nCOBANAL  RMODE ANY\n         SYSSTATE ARCHLVL=1\n         COPY  IEABRC\n         BAKR  R14,R0             Save register\n         BRAS  R6,*+8                                            RS1102\n         DC    A(STATIC_AREA)                                    RS1102\n         L     R6,0(R6,0)                                        RS1102\n         USING STATIC_AREA,R6     Addressebility                 RS1102\n         L     R9,0(R1)           Save Parmlist\n         USING COBANAL_PARM,R9    addressebility\n         LAY   R0,COBANAL_WORK_LENGTH                            RS1206\n         STORAGE OBTAIN,LENGTH=(R0),ADDR=(R1),COND=NO,LOC=BELOW\n         LR    R11,R1             COBANAL_WORK register\n         USING COBANAL_WORK,R11   addressebility\n         MVC   EYECATCHER,=CL8'COBANAL'\n         MVC   PGMNAME,BLANKS     clear PGMNAME                  RS0608\n         MVC   PGMNAME_GET,BLANKS  clear PGMNANE GETMEM          RS0608\n*        Getmain area for IEWBIND\n         L     R0,BNLI_BUFFER_LENG\n         STORAGE OBTAIN,LENGTH=(R0),ADDR=(R1),COND=NO,LOC=31\n         ST    R1,IEW_BNLI_PTR\n         L     R0,IDLI_BUFFER_LENG                               RS1007\n         STORAGE OBTAIN,LENGTH=(R0),ADDR=(R1),COND=NO,LOC=31     RS1007\n         ST    R1,IEW_IDLI_PTR                                   RS1007\n         L     R0,ESDI_BUFFER_LENG                               RS1007\n         STORAGE OBTAIN,LENGTH=(R0),ADDR=(R1),COND=NO,LOC=31     RS1007\n         ST    R1,IEW_ESDI_PTR                                   RS1007\n         L     R0,IDUI_BUFFER_LENG                               RS1007\n         STORAGE OBTAIN,LENGTH=(R0),ADDR=(R1),COND=NO,LOC=31     RS1007\n         ST    R1,IEW_IDUI_PTR                                   RS1007\n         L     R0,IDZI_BUFFER_LENG                               RS1007\n         STORAGE OBTAIN,LENGTH=(R0),ADDR=(R1),COND=NO,LOC=31     RS1007\n         ST    R1,IEW_IDZI_PTR                                   RS1007\n         L     R0,IDBI_BUFFER_LENG                               RS1007\n         STORAGE OBTAIN,LENGTH=(R0),ADDR=(R1),COND=NO,LOC=31     RS1007\n         ST    R1,IEW_IDBI_PTR                                   RS1007\n         MVI   CSCSUMM,X'40'              Insert a blank          *CSC*\n         MVC   CSCSUMM+1(L'CSCSUMM-1),CSCSUMM Repeat to clear     *CSC*\n         ZAP   CNT_ASSEMBLER,=P'0'       Clear Assembler counter  *CSC*\n         ZAP   CNT_BMS,=P'0'             Clear BMS       counter  *CSC*\n         ZAP   CNT_COBOLI,=P'0'          Clear OS/VS/COB counter  *CSC*\n         ZAP   CNT_COBOL2,=P'0'          Clear VS/COB2   counter  *CSC*\n         ZAP   CNT_COBOLLE,=P'0'         Clear LE COBOL  counter  *CSC*\n         ZAP   CNT_C370,=P'0'            Clear C/C++     counter  *CSC*\n         ZAP   CNT_FORTRAN,=P'0'         Clear FORTRAN   counter  *CSC*\n         ZAP   CNT_INVALID,=P'0'         Clear Invalid   counter  *CSC*\n         ZAP   CNT_LEASS,=P'0'           Clear LE Assem  counter  *CSC*\n         ZAP   CNT_OTHER,=P'0'           Clear Other     counter  *CSC*\n         ZAP   CNT_PLI,=P'0'             Clear PLI       counter  *CSC*\n         ZAP   CNT_TOTAL,=P'0'           Clear TOTAL     counter  *CSC*\n         ZAP   CNT_UNKNOWN,=P'0'         Clear UNKNOWN   counter  *CSC*\n         ZAP   CNT_NOTLOAD,=P'0'         Clear Notloaded counter PF0608\n         ZAP   CNT_EZTRV,=P'0'           Clear EZTrieve+ counter PF0708\n         MVI   JUSTDATA_R,C'N'           Default                  =CMS=\n         MVI   SUMMARYR,C'N'             Default                  *CSC*\n         MVI   LEFOUND,C'N'              Default                  *CSC*\n         MVI   DOALL,C'N'                Default\n         MVI   DD_COBANAL,C'N'           Default\n         MVI   LOADERR,C'N'              Default                 PF0608\n         MVI   FIXEDSUM,C'N'             Default                 PF0608\n         MVI   SETRMODE,C'N'             Default                 RS0316\n         MVC   SUM_DATE_SAVE,BLANKS      Default                 PF0608\n         MVC   JUST_SPACE,BLANKS         Default\n         XC    SAVEAREA,SAVEAREA         clear SaveArea\n         LA    R13,SAVEAREA              get address of SaveArea\n         MVC   4(4,R13),=C'F1SA'         indicate Linkage Stack 72bytes\n         ST    R11,ADR_COBANAL_WORK      save address\n         ST    R9,ADR_COBANAL_PARM       save address\n*------------------------------------------------------------*\n*        Check JCL-Parm                                      *\n*------------------------------------------------------------*\n         MVC   PARM_LENGTH,COBANAL_PARM_LENGTH\n         LH    R10,PARM_LENGTH                                   RS0608\n         LTR   R10,R10                                           RS0608\n         JZ    COBANAL_020                                       RS0608\nCOBANAL_005 DS  0H                 do until first ',' or end\n         LA    R9,2(R9)            jump length field\n*        MVC   PGMNAME,BLANKS      clear PGMNANE                 RS0608\n*        MVC   PGMNAME_GET,BLANKS  clear PGMNANE GETMEM          RS0608\n         LA    R8,PGMNAME          first parm\nCOBANAL_010 DS  0H                 do until first ',' or end\n         CLI   0(R9),C','          parm separator\n         JE    COBANAL_020         next parm\n         MVC   0(1,R8),0(R9)\n         LA    R8,1(R8)            next digit\n         LA    R9,1(R9)            next digit\n         BRCT  R10,COBANAL_010     loop\nCOBANAL_020 DS  0H\n         L     R15,=V(FIXSYSPR)                                  PF0608\n         MVC   SYSPRINT(SYSPRINT_FIX_LENGTH),0(R15)              PF0608\n         MVC   PARMLIST(C_LSTOL),C_LSTO\n         LA    R9,SYSPRINT\n         USING IHADCB,R9\n         MVC   DCBDDNAM,=C'SYSPRINT'\n         OPEN  ((R9),OUTPUT),MF=(E,PARMLIST),MODE=31\n         DROP  R9\n         LTR   R15,R15                   OPEN worked?             *CSC*\n         JZ    COBANAL_020A              Yep, continue            *CSC*\n*                                                                 *CSC*\n         MVC   RETCODE,=F'16'            Set bad return code      *CSC*\n         J     COBANAL_FIN_A             Lets get out of here     *CSC*\n*                                                                 *CSC*\nCOBANAL_020A DS  0H                                               *CSC*\n         DEVTYPE =CL8'COBANAL',DOUBLE     Get COBANAL information\n         LTR   R15,R15                    Is it allocated?\n         JNZ   TIOT110                    No, continue           PF0608\n* Go check SUMMARY file anyway even if no COBANAL, because it    PF0608\n* could be SYSIN input and STEPLIB load modules needing SUMMARY  PF0608\n* -------------------------------------------------------------- PF0608\n         MVI   DD_COBANAL,C'Y'    Default\n         L     R15,=V(FIXINPUT)                                  PF0608\n         MVC   INPUT(INPUT_FIX_LENGTH),0(R15)                    PF0608\n         MVC   PARMLIST(C_LSTIL),C_LSTI\n         LA    R9,INPUT\n         USING IHADCB,R9\n         MVC   DCBDDNAM,=C'COBANAL '\n         OPEN  ((R9),INPUT),MF=(E,PARMLIST),MODE=31\n         DROP  R9\n*                                                                 *CSC*\n         L     R15,=V(FIXLOADL)                                  PF0608\n         MVC   LOADL(LOADL_FIX_LENGTH),0(R15)                    PF0608\n         MVC   PARMLIST(C_LSTIL),C_LSTI                          PF0608\n         LA    R9,LOADL                                          PF0608\n         USING IHADCB,R9                                         PF0608\n         MVC   DCBDDNAM,=C'COBANAL '                             PF0608\n         LA    R0,LOADLE                Point DCB copy to        RS0516\n         ST    R0,DCBDCBE               DCBE copy                RS0516\n         OPEN  ((R9),INPUT),MF=(E,PARMLIST),MODE=31              PF0608\n         DROP  R9                                                PF0608\n*                                                                PF0608\n*-----------------------------------------------------------------*CSC*\n*  LOCATE A COBANAL DD CARD IF ONE SUPPLIED                      RS1007\n*-----------------------------------------------------------------*CSC*\nTIOT000  DS    0H                                                 *CSC*\n         MVI   CSCDSN,X'40'                   First Space         *CSC*\n         MVC   CSCDSN+1(L'CSCDSN-1),CSCDSN    Repeat to clear     *CSC*\n         L     R3,PSATOLD-PSA                   CURRENT TCB       *CSC*\n         L     R3,TCBTIO-TCB(R3)                TIOT              *CSC*\n         LA    R3,TIOENTRY-TIOT(R3)           DDNAME ENTRIES      *CSC*\n         USING TIOENTRY,R3                                        *CSC*\n         SR    R4,R4                          CLEAR REGISTER      *CSC*\nTIOT100  DS    0H                                                 *CSC*\n         CLI   TIOELNGH,X'00'                 END OF TIOT DDNAMES?*CSC*\n         JE    TIOT110                        YES,CONTINUE IF TSO *CSC*\n         CLC   TIOEDDNM,=CL8'COBANAL'         NO, COBANAL DDNAME? *CSC*\n         JNE   TIOT105                        NO, KEEP LOOKING    *CSC*\n*                                                                 *CSC*\nTIOTZOS  DS    0H                                                 *CSC*\n         LA    R2,SWAWORK+4                   WORK AREA           *CSC*\n         ST    R2,SWAWORK                     WORK AREA           *CSC*\n         USING ZB505,R2                                           *CSC*\n         XC    SWAEPAX,SWAEPAX                CLEAR WORK AREA     *CSC*\n         MVC   SWVA,TIOEJFCB                  SVA OF THE JFCB     *CSC*\n         SWAREQ FCODE=RL,EPA=SWAWORK,MF=(E,SWAREQL1),UNAUTH=YES   *CSC*\n         L     R2,SWBLKPTR                    31'ADDRESS OF JFCB  *CSC*\n         DROP  R2                                                 *CSC*\n         USING INFMJFCB,R2                    Addressability      *CSC*\n*                                                                 *CSC*\nTIOTDSN  DS    0H                                                 *CSC*\n         MVC   CSCDSN(44),JFCBDSNM            GET DATASET NAME    *CSC*\n         J     SUMMARY_OPEN                                       *CSC*\n*                                                                 *CSC*\nTIOT105  DS    0H                                                 *CSC*\n         IC    R4,TIOELNGH                    TIOT ENTRY LENGTH   *CSC*\n         LA    R3,0(R4,R3)                    POINT AT NEXT TIOT  *CSC*\n         J     TIOT100                        EXAMINE NEXT ENTRY  *CSC*\n         DROP  R2                                                 *CSC*\n         DROP  R3                                                 *CSC*\n*                                                                 *CSC*\nTIOT110  DS    0H                                                 *CSC*\n         MVC   CSCDSN(44),=CL9'*UNKNOWN*' DATASET NAME unknown    *CSC*\n*                                                                 *CSC*\nSUMMARY_OPEN DS  0H                                               *CSC*\n         DEVTYPE =CL8'SUMMARY',DOUBLE     Get COBANAL information *CSC*\n         LTR   R15,R15                    Is it allocated?        *CSC*\n         JNZ   JUSTDATA_OPEN              No, continue            =CMS=\n*                                                                 *CSC*\n         L     R15,=V(FIXSUMMA)                                  PF0608\n         MVC   SUMMARY(SUMMARY_FIX_LENGTH),0(R15)                PF0608\n         MVC   PARMLIST(C_LSTOL),C_LSTO                           *CSC*\n         LA    R9,SUMMARY                                         *CSC*\n         USING IHADCB,R9                                          *CSC*\n         MVC   DCBDDNAM,=C'SUMMARY '                              *CSC*\n         OPEN  ((R9),OUTPUT),MF=(E,PARMLIST),MODE=31              *CSC*\n         DROP  R9                                                 *CSC*\n         LTR   R15,R15                   OPEN worked?             *CSC*\n         JZ    SUMMARY_HEADING           Yep, continue            *CSC*\n*                                                                 *CSC*\n         STRING64 'Error OPENing SUMMARY DD. RC=',((R15),,X),     *CSC*X\n               INTO=RECORD                                        *CSC*\n         BRAS  R14,SPACE1                Print starting message   *CSC*\n         MVC   RETCODE,=F'8'             Set bad return code      *CSC*\n         J     COBANAL_021               But continue.            *CSC*\n*                                                                 *CSC*\nSUMMARY_HEADING DS  0H                                            *CSC*\n         MVI   SUMMARYR,C'Y'              Yep, a SUMMARY REPORT   *CSC*\n         STRING64 'COBANAL &REL - SUMMARY Report. ',                   X\n               ' Dataset=',CSCDSN,INTO=RECORD                     *CSC*\n         BRAS  R14,SUMMARY1               Print starting message  *CSC*\n         STRING64 '                ',                             *CSC*X\n               'PARM=',PGMNAME,INTO=RECORD                        *CSC*\n         BRAS  R14,SUMMARY2               Print starting message  *CSC*\n         STRING64 '                    ',                         *CSC*X\n               '|Translate|',                                     *CSC*X\n               '|--C o m p i l e r  ',                            *CSC*X\n               'R e l a t e d--| ',                               *CSC*X\n               '|--L K E D   O p t i o n s--|',                   *CSC*X\n               INTO=RECORD                                        *CSC*\n         BRAS  R14,SUMMARY1               Print starting message  *CSC*\n         STRING64 'Program   ',                                   *CSC*X\n               'Language  ',                                      *CSC*X\n               'CICS ',                                           *CSC*X\n               'COBOL  ',                                         *CSC*X\n               'Compiler          ',                              *CSC*X\n               'LE  ',                                            *CSC*X\n               'DATA ',                                           *CSC*X\n               'RM  ',                                            *CSC*X\n               'RENT ',                                           *CSC*X\n               'RM  ',                                            *CSC*X\n               'AM  ',                                            *CSC*X\n               'LKED ATTRIBUTES           ',                      *CSC*X\n               'COMPDATE    ',                                    *CSC*X\n               INTO=RECORD                                        *CSC*\n         BRAS  R14,SUMMARY1               Print starting message  *CSC*\n         STRING64 '--------- ',                                   *CSC*X\n               '--------- ',                                      *CSC*X\n               '---- ',                                           *CSC*X\n               '------ ',                                         *CSC*X\n               '----------------- ',                              *CSC*X\n               '--- ',                                            *CSC*X\n               '---- ',                                           *CSC*X\n               '--- ',                                            *CSC*X\n               '---- ',                                           *CSC*X\n               '--- ',                                            *CSC*X\n               '--- ',                                            *CSC*X\n               '------------------------- ',                      *CSC*X\n               '----------- ',                                    *CSC*X\n               INTO=RECORD                                        *CSC*\n         BRAS  R14,SUMMARY2               Print starting message  *CSC*\n*                                                                 *CSC*\nJUSTDATA_OPEN DS  0H                                              =CMS=\n         DEVTYPE =CL8'JUSTDATA',DOUBLE   Get JUSTDATA information =CMS=\n         LTR   R15,R15                    Is it allocated?        =CMS=\n         JNZ   COBANAL_021                No, continue            =CMS=\n*                                                                 =CMS=\n         L     R15,=V(FIXJUSTD)                                   =CMS=\n         MVC   JUSTDATA(JUSTDATA_FIX_LENGTH),0(R15)               =CMS=\n         MVC   PARMLIST(C_LSTOL),C_LSTO                           =CMS=\n         LA    R9,JUSTDATA                                        =CMS=\n         USING IHADCB,R9                                          =CMS=\n         MVC   DCBDDNAM,=C'JUSTDATA'                              =CMS=\n         OPEN  ((R9),OUTPUT),MF=(E,PARMLIST),MODE=31              =CMS=\n         DROP  R9                                                 =CMS=\n         LTR   R15,R15                   OPEN worked?             =CMS=\n         JZ    JUSTDATA_OK               Yep, continue            =CMS=\n*                                                                 =CMS=\n         STRING64 'Error OPENing JUSTDATA DD. RC=',((R15),,X),    =CMS=X\n               INTO=RECORD                                        =CMS=\n         BRAS  R14,SPACE1                Print starting message   =CMS=\n         MVC   RETCODE,=F'8'             Set bad return code      =CMS=\n         J     COBANAL_021               But continue.            =CMS=\n*                                                                 =CMS=\nJUSTDATA_OK EQU *\n         MVI   JUSTDATA_R,C'Y'\n*                                                                 =CMS=\nCOBANAL_021 DS  0H\n         DEVTYPE =CL8'SYSIN',DOUBLE       Get SYSIN information  RS1207\n         LTR   R15,R15                    Is it allocated?       RS1207\n         JNZ   COBANAL_0210               No, continue           RS1207\n         MVI   DD_SYSIN,C'Y'    Default                          RS1207\n         L     R15,=V(FIXSYSIN)                                  PF0608\n         MVC   SYSIN(SYSIN_FIX_LENGTH),0(R15)                    PF0608\n         MVC   PARMLIST(C_LSTIL),C_LSTI                          RS1207\n         LA    R9,SYSIN                                          RS1207\n         USING IHADCB,R9                                         RS1207\n         MVC   DCBDDNAM,=C'SYSIN   '                             RS1207\n         LA    R0,SYSINE                Point DCB copy to        RS0908\n         ST    R0,DCBDCBE               DCBE copy                RS0908\n         OPEN  ((R9),INPUT),MF=(E,PARMLIST),MODE=31              RS1207\n         DROP  R9                                                RS1207\nCOBANAL_0210 DS  0H                                              RS1207\n         STRING64 'COBANAL &REL - DETAIL Report.  ',             RS1007X\n               ' Dataset=',CSCDSN,INTO=RECORD                     *CSC*\n         BRAS  R14,SPACE1                 Print starting message  *CSC*\n         STRING64 '                ',                             *CSC*X\n               'PARM=',PGMNAME,INTO=RECORD                        *CSC*\n         BRAS  R14,SPACE2                 Print starting message  *CSC*\n         CLI   SUMMARYR,C'Y'       Is SUMMARY DD Allocated?       *CSC*\n         JE    COBANAL_021A        Yes,Skip information message   *CSC*\n*                                                                 *CSC*\n         STRING64 '**NOTE: ',                                     *CSC*X\n               'SUMMARY SYSOUT DD not allocated, skipping ',      *CSC*X\n               'generation of SUMMARY Report.',INTO=RECORD        *CSC*\n         BRAS  R14,SPACE2                 Print starting message  *CSC*\n*                                                                 *CSC*\nCOBANAL_021A DS  0H                                               *CSC*\n         STRING64 FOOTER,INTO=RECORD                              *CSC*\n         BRAS  R14,SPACE2                                         *CSC*\n         CLC   PGMNAME,BLANKS      check PGMNAME\n         JE    COBANAL_PARM_ERROR  if clear ==> Error\n         CLC   PGMNAME(3),=C'ALL'  PGMNAME = ALL indicate analyzing\n         JNE   COBANAL_025         a complete Load, but check for\n         CLC   PARM_LENGTH,=H'3'   length; maybe it is a prog called\n         JNE   COBANAL_025         ALLWAYS :-))\n         CLI   DD_COBANAL,C'Y'        Did you read the docs?\n         JE    COBANAL_022           yes, thats fine\n         STRING64 'Parameter=ALL specified but DD-Name COBANAL',       X\n               ' missing',                                             X\n               INTO=RECORD\n         BRAS  R14,SPACE1                 Print starting message\n         MVC   RETCODE,=F'12'\n         J     COBANAL_EXIT         no, leave\n** Loop\nCOBANAL_022 DS  0H\n         MVI   DOALL,C'Y'          remember that\n         BRAS  R14,GETMEM          get the member name\n         CLC   PGMNAME_GET,XFF         more entries?\n         JE    COBANAL_EXIT          leave\n*------------------------------------------------------------*\n*        Load the progamm from DD COBANAL                    *\n*------------------------------------------------------------*\n         XC    LOADWK(16),LOADWK      clear                      RS1216\n         LA    R14,PGMNAME_GET                                   PF0608\n         LA    R15,LOADL                                         PF0608\n*        LOAD  EPLOC=PGMNAME_GET,DCB=LOADL,                      PF0608\n         LOAD  EPLOC=(14),DCB=(15),                              PF0608X\n               LSEARCH=YES,                                      PF0608X\n               ERRET=COBANAL_LOAD_ERROR,SF=(E,LOADWK)            RS0908\n         J     COBANAL_027\nCOBANAL_025 DS  0H\n         CLC   PGMNAME(5),=C'SYSIN' SYSIN indicate analyzing     RS1207\n         JNE   COBANAL_025B        a given member list via SYSIN RS1207\n         CLC   PARM_LENGTH,=H'5'   length; maybe it is a prog called1\n         JNE   COBANAL_025B        SYSINXX :-))                  RS1207\n         CLI   DD_SYSIN,C'Y'       Did you read the docs?        RS1207\n         JE    COBANAL_025A          yes, thats fine             RS1207\n         STRING64 'Parameter=SYSIN specified but DD-Name SYSIN', RS1207X\n               ' missing',                                       RS1207X\n               INTO=RECORD                                       RS1207\n         BRAS  R14,SPACE1          Print error message           RS1207\n         MVC   RETCODE,=F'12' Returncode                         RS1207\n         J     COBANAL_EXIT_B      leave                         RS0516\nCOBANAL_025A DS  0H                                              RS1207\n         MVI   DOALL,C'S'          remember that (Sysin)         RS1207\n         GET   SYSIN,SYSIN_DATA    get a member name from SYSIN  RS1207\n         CLI   SYSIN_DATA,C'*'     Comment ?                     RS0209\n         JE    COBANAL_025A          yes ignore                  RS0209\n         MVC   PGMNAME_GET,SYSIN_DATA   remember PGMNAME         RS1207\n         MVC   PGMNAME,PGMNAME_GET  remember PGMNAME             RS1207\n         J     COBANAL_026        load programm from             RS1207\nCOBANAL_025B DS  0H                                              RS1207\n         ST    R5,SAVER5          Save Register 5                RS0104\n         LA    R5,PGMNAME         start search at address\n         LA    R4,L'PGMNAME       length of string to be searched\n         AR    R4,R5              + start of address\n         LA    R0,C'?'            search for ?\n         SRST  R4,R5              issue search\n         BRC   4,COBANAL_028      wildcard ? found\n         LA    R5,PGMNAME         start search at address\n         LA    R4,L'PGMNAME       length of string to be searched\n         AR    R4,R5              + start of address\n         LA    R0,C'*'            search for *\n         SRST  R4,R5              issue search\n         BRC   4,COBANAL_028      wildcard * found\n         L     R5,SAVER5          Reload Register 5              RS0104\n         MVC   PGMNAME_GET,PGMNAME\n         CLI   DD_COBANAL,C'Y'    load from DD Cobanal ?\n         JE    COBANAL_026           yes\n*------------------------------------------------------------*\n*        Load the progamm                                    *\n*------------------------------------------------------------*\n         XC    LOADWK(16),LOADWK      clear                      RS1216\n         LOAD  EPLOC=PGMNAME_GET,ERRET=COBANAL_LOAD_ERROR,       PF0608X\n               SF=(E,LOADWK)                                     RS0908\n         J     COBANAL_027\nCOBANAL_026 DS  0H\n*------------------------------------------------------------*\n*        Load the progamm from DD COBANAL                    *\n*------------------------------------------------------------*\n         XC    LOADWK(16),LOADWK      clear                      RS1216\n         LA    R14,PGMNAME_GET                                   PF0608\n         LA    R15,LOADL                                         PF0608\n*        LOAD  EPLOC=PGMNAME_GET,DCB=LOADL,                      PF0608\n         LOAD  EPLOC=(14),DCB=(15),                              PF0608X\n               LSEARCH=YES,                                      PF0608X\n               ERRET=COBANAL_LOAD_ERROR,SF=(E,LOADWK)            RS0908\nCOBANAL_027 DS  0H\n         LTR   R15,R15             check response\n         JNZ   COBANAL_LOAD_ERROR if greater zero ==> Error\n         ST    R0,ADR_PGMNAME      save the address\n*>---------------------------------------------------------------HP1107\n         la    R3,csect_table                                    HP1107\n         st    R3,csect_tabelem_act                              HP1107\n         mvc   csect_anz_tabelem,=h'0'                           HP1107\n         MVI   csect_analyze_kz,C'M'                             HP1107\n*>---------------------------------------------------------------HP1107\n*------------------------------------------------------------*\n*        Check length                                        *\n*------------------------------------------------------------*\n*        MVC   CSV_OUTXTLST_ENTR,=F'8' Want 8 entries back       RS0704\n         MVC   CSV_OUTXTLST_ENTR,=F'9' Want 9 entries back       PF0608\n         CSVQUERY SEARCH=JPALPA,       SEARCH JPAQ                     X\n               INADDR=ADR_PGMNAME,     ADDRESS                         X\n               OUTLOADPT=CSV_LOADPT,                                DEHX\n               OUTLENGTH=CSV_LENGTH,                                   X\n               OUTEPTKN=CSV_EPTOKEN,                                   X\n               OUTVALID=CSV_OUTVALID,                            RS0704X\n               OUTATTR1=CSV_OUTATTR1,                            *CSC* X\n               OUTATTR2=CSV_OUTATTR2,                            *CSC* X\n               OUTATTR3=CSV_OUTATTR3,                            *CSC* X\n               OUTXTLST=CSV_OUTXTLST,                            RS0704X\n               OUTPID=CSV_OUTPID,                                PF0608X\n               MF=(E,CSVQRYWK)         WORK AREA\n         LTR   R2,R15                  pass return code\n         JNZ   COBANAL_CSV_ERROR if greater zero ==> Error\n         AP    CNT_TOTAL,=P'1'           Increment counter        *CSC*\n*        STRING64 '**Program Name= ',PGMNAME_GET,                PF0608X\n               '   INADDR=',(ADR_PGMNAME,,X),                    PF0608X\n               ' OUTLOADP=',(CSV_LOADPT,,X),                     PF0608X\n               ' OUTLENGT=',(CSV_LENGTH,,X),                     PF0608X\n               '  EPTOKEN=',(CSV_EPTOKEN,,X),                    PF0608X\n               INTO=RECORD                                       PF0608\n*        BRAS  R14,SPACE1                                        PF0608\n         STRING64 '**Program Name= ',PGMNAME_GET,                 *CSC*X\n               ' OUTATTR1=',(CSV_OUTATTR1,,X),                    *CSC*X\n               ' OUTATTR2=',(CSV_OUTATTR2,,X),                    *CSC*X\n               ' OUTATTR3=',(CSV_OUTATTR3,,X),                    *CSC*X\n               ' OUTVALID=',(CSV_OUTVALID,,X),                    *CSC*X\n               INTO=RECORD                                        *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         MVC   CSCLPRM,BLANKS                                    RS1007\n         TM    CSV_OUTVALID,BIT5         Is CSV_OUTATTR1 Valid?   *CSC*\n         JZ    AMODE                     NOPE ---                 *CSC*\nRENTRUSE DS    0H                                                 *CSC*\n         TM    CSV_OUTATTR1,BIT2+BIT3    Reentrant and REUS?      *CSC*\n         JNO   RENT                      no                      RS1207\n         STRING64 'RENT REUS',INTO=CSCLPRM                       RS1007\n         J     AMODE                     Go analyze AMODE        PF0608\nRENT     DS    0H                                                 *CSC*\n         TM    CSV_OUTATTR1,BIT2         REENTRANT?               *CSC*\n         JZ    RUSE                      NOPE ---                 *CSC*\n         STRING64 'RENT ',INTO=CSCLPRM                    *CSC*\nRUSE     DS    0H                                                 *CSC*\n         TM    CSV_OUTATTR1,BIT3         Serially Reusable        *CSC*\n         JZ    AMODE                     Go analyze AMODE        PF0608\n         STRING64 'REUS ',INTO=CSCLPRM                           JK1207\nAMODE    DS    0H                                                 *CSC*\n         TM    CSV_OUTVALID,BIT6         Is CSV_OUTATTR2 Valid?   *CSC*\n         JO    AMODEANY                  Yes,Check value         RS1207\n         STRING64 '???',INTO=CSCAM       No, Set unknown value    *CSC*\n         J     CONT                     Skip remaining validationRS1207\nAMODEANY DS    0H                                                 *CSC*\n         STRING64 '24 ',INTO=CSCAM                                *CSC*\n         TM    CSV_OUTATTR2,BIT2         AMODEANY?                *CSC*\n         JZ    AMODE31                   NOPE ---                 *CSC*\n         STRING64 'ANY',INTO=CSCAM                                *CSC*\nAMODE31  DS    0H                                                 *CSC*\n         TM    CSV_OUTATTR2,BIT3         AMODE31?                 *CSC*\n         JZ    AMODE64                   NOPE ---                RS1207\n         STRING64 '31 ',INTO=CSCAM                                *CSC*\nAMODE64  DS    0H                                                RS1207\n         TM    CSV_OUTATTR2,BIT7         AMODE64?                RS1207\n         JZ    CONT                      NOPE ---                RS1207\n         STRING64 '64 ',INTO=CSCAM                               RS1207\nCONT     DS    0H                                                 *CSC*\n         J     COBANAL_03\n*                                                                 *CSC*\nCOBANAL_028 DS  0H\n         L     R5,SAVER5          Reload Register 5              RS0104\n         MVI   DOALL,C'X'          remember that (eXclude)\n         BRAS  R14,GETMEM          get the member name\n         CLC   PGMNAME_GET,XFF         more entries?\n         JE    COBANAL_EXIT          leave\n         ASAXWC    PATTERNSTR=PGMNAME,                                 X\n               PATTERNSTRLEN==A(L'PGMNAME),                            X\n               STRING=PGMNAME_GET,                                     X\n               STRINGLEN==A(L'PGMNAME_GET),                            X\n               ZEROORMORE==CL1'*',                                     X\n               ONECHAR==CL1'?',                                        X\n               DELIMITER==CL1' ',                                      X\n               RETCODE=IRETCODE,                                       X\n               MF=(E,MYLIST)\n*        STRING64 'Program Name= ',PGMNAME_GET,                        X\n               ' Pattern= ',PGMNAME,'RC= ',(IRETCODE,,X),              X\n               INTO=RECORD                    debug\n*        BRAS  R14,SPACE1\n         CLC   IRETCODE,=F'0'\n         JNE   COBANAL_028\n*------------------------------------------------------------*\n*        Load the progamm from DD COBANAL                    *\n*------------------------------------------------------------*\n         XC    LOADWK(16),LOADWK      clear                      RS1216\n         LA    R14,PGMNAME_GET                                   PF0608\n         LA    R15,LOADL                                         PF0608\n*        LOAD  EPLOC=PGMNAME_GET,DCB=LOADL,                      PF0608\n         LOAD  EPLOC=(14),DCB=(15),                              PF0608X\n               LSEARCH=YES,                                      PF0608X\n               ERRET=COBANAL_LOAD_ERROR,SF=(E,LOADWK)            RS0908\n         J     COBANAL_027\n*------------------------------------------------------------*\n*        Write info to sysprint                              *\n*------------------------------------------------------------*\nCOBANAL_03 DS  0H\n*        STRING64 'Program Name= ',PGMNAME_GET,                        X\n               ' was loaded into storage at EPA= ',(ADR_PGMNAME,,X),   X\n               INTO=RECORD\n*        BRAS  R14,SPACE1\n*        STRING64 'CSV-LOAD-PTR= ',(CSV_LOADPT,,X),1X,                 X\n               ' Length= ',(CSV_LENGTH,,X),                            X\n               ' Valid= ',(CSV_OUTVALID,,X),                           X\n               ' Token= ',(CSV_EPTOKEN,,X),                            X\n               INTO=RECORD                    debug\n*        BRAS  R14,SPACE1\n*        STRING64 'CSV-Entries= ',(CSV_OUTXTLST_ENTRR,,X),             X\n               ' LP-1= ',(CSV_OUTXTLST_ELP1,,X),                       X\n               ' L-1= ',(CSV_OUTXTLST_EL1,,X),                         X\n               INTO=RECORD                    debug\n*        BRAS  R14,SPACE1\n*        STRING64 'CSV-Entries= ',(CSV_OUTXTLST_ENTRR,,X),             X\n               ' LP-2= ',(CSV_OUTXTLST_ELP2,,X),                       X\n               ' L-2= ',(CSV_OUTXTLST_EL2,,X),                         X\n               INTO=RECORD                    debug\n*        BRAS  R14,SPACE1\n*\n*        Dump the first 256 Bytes for Identification.\n*        Should be activate only in case of problems\n*\n*        L     R4,ADR_PGMNAME\n*        LA    R3,2048/16              LOOP COUNTER\n*LOOP\nCOBANAL_04 DS  0H\n*        STRING64 4X,((R4),4,X),1X,(4(R4),4,X),1X,(8(R4),4,X),1X,      X\n               (12(R4),4,X),3X,((R4),16),                              X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        LA    R4,016(,R4)             BUMP POINTER\n*        BRCT  R3,COBANAL_04\n*ENDLOOP\n         MVC   CSCPNAM(8),PGMNAME_GET                             *CSC*\n         L     R4,ADR_PGMNAME       Load-Entry-Point\n         USING COBOL_370_DSECT,R4\n*        STRING64 ' R4=',((R4),4,X),1X,(4(R4),4,X),1X,(8(R4),4,X),1X,  X\n               (12(R4),4,X),3X,((R4),16),                              X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 4X,(16(R4),4,X),1X,(20(R4),4,X),1X,(24(R4),4,X),1X,  X\n               (28(R4),4,X),3X,(16(R4),16),                            X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 4X,(32(R4),4,X),1X,(36(R4),4,X),1X,(40(R4),4,X),1X,  X\n               (44(R4),4,X),3X,(32(R4),16),                            X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n* Compute offset of entry point for later use in ESD processing  PF0608\n         XC    OFF_PGMNAME,OFF_PGMNAME Assume zero offset        PF0608\n         TM    CSV_OUTVALID+1,BIT0  Is CSV_LOADPT Valid?         PF0608\n         JZ    COBANAL_04_1         NOPE ---                     PF0608\n         L     R2,CSV_LOADPT        R2 => Load Point             PF0608\n         N     R4,=X'7FFFFFFF'      Turn off high order bit      PF0608\n         N     R2,=X'7FFFFFFF'      Turn off high order bit      PF0608\n         SR    R4,R2                Get entry point offset       PF0608\n         ST    R4,OFF_PGMNAME       Save offset for CSECT scan   PF0608\n         L     R4,ADR_PGMNAME       Reload Entry-Point           PF0608\nCOBANAL_04_1 DS  0H                                              PF0608\n         CLC   CSV_LENGTH,=F'36'    At least 36 bytes|||          *CSC*\n         JNH   COBANAL_06_A         Try using Load Point          *CSC*\n         L     R2,CSV_LOADPT        R2 => Load Point             MG0104\n*        STRING64 ' R2=',((R2),4,X),1X,(4(R2),4,X),1X,(8(R2),4,X),1X,  X\n               (12(R2),4,X),3X,((R2),16),                              X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 4X,(16(R2),4,X),1X,(20(R2),4,X),1X,(24(R2),4,X),1X,  X\n               (28(R2),4,X),3X,(16(R2),16),                            X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 4X,(32(R2),4,X),1X,(36(R2),4,X),1X,(40(R2),4,X),1X,  X\n               (44(R2),4,X),3X,(32(R2),16),                            X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n         A     R2,CSV_LENGTH        R2 => End of module          MG0104\n         L     R10,ADR_PGMNAME      R10 => Entry Point           MG0104\n         N     R10,=X'7FFFFFFF'     Turn off high order bit      MG0104\n         SR    R2,R10               Get entry point length       MG0104\n         C     R2,=F'36'            At least 36 bytes|||         RS1207\n         JNH   COBANAL_06_A         Try using Load Point          *CSC*\n         C     R2,=F'52'            At least 52 bytes?           PF0708\n         JNH   COBANAL_04_2         No, can't be EZTrieve+       PF0708\n         USING EZTRIEVE_DSECT,R4                                 PF0708\n         CLC   EZ_EYECATCHER,=CL8'EZTPA00 ' Compiled EZTRIEVE?   PF0708\n         JE    COBANAL_15           Yes, go process              PF0708\n         USING COBOL_370_DSECT,R4   No, continue analysis        PF0708\nCOBANAL_04_2 DS  0H                                              PF0608\n         L     R2,CSV_LOADPT        R2 => Load Point              *CSC*\n         BRAS  R14,PGMNAME_2_MBR  Move PGMNAME to IEW_MBR        PF0708\n         BRAS  R14,CREATE_PLINAME Create PLINAME for later use   PF0708\n         CLC   28(8,R2),=CL8'PLISTART'      PLI V2.3?            RS0108\n         JE    COBANAL_10A                                        *CSC*\n         CLC   CEE_EYECATCHER,C_COBOL370   COBOL/370 ?  X'00C3C5C5'\n         JE    COBOL_370\n*   WHY ???\n*        CLC   0(4,R4),=XL4'47F0F026' C or Cobol V5 ?  X'01C3C5C5'\n*        JE    ENTCOBOLV5\n         CLC   CEE_EYECATCHER,C_COBV5 Enter Cobol V5 ?  X'01C3C5C5'\n         JE    ENTCOBOLV5\n         CLC   CEE_EYECATCHER,=XL4'47000002' C    ?  X'47000002' RS0305\n         JE    C_370_NEW                                         RS0305\n         CLC   CEE_EYECATCHER,C_OPLINK     C         ?  X'01C3C5C5'\n         JE    C_370\n         USING COBOL_2_DSECT,R4\n         CLC   C2_EYECATCHER,=CL4' C2 '     COBOL/2 ?  X'40C3F240'\n         JE    COBOL_2\n         USING COBOL_1_DSECT,R4\n* ???    CLC   C1_EYECATCHER,=CL2'AN'       ANS4 COBOL ?\n* ???    JE    COBOL_1\n         CLC   C1_EYECATCHER(4),=CL4'VSR1'       OS/VS COBOL/1 ?\n         JE    COBOL_1\n         CLC   C1_EYECATCHER(4),=CL4'VSR2'       OS/VS COBOL/1 ?\n         JE    COBOL_1\n         CLC   0(4,R2),=XL4'47F0F028'        Fortran ?           RS1207\n         JNE   COBANAL_05                      no                RS1207\n         CLC   CSV_LENGTH,=F'112'   At least 112 bytes |||       RS1207\n         JNH   COBANAL_05           Try using Load Point         RS1207\n         CLC   104(8,R2),=CL8'#PIBTAB#'      Fortran ?           RS1207\n         JE    COBANAL_11A                                       RS1207\n* The following code is essentially a copy of the code above.       DEH\n* The purpose is to continue analysis at the load point if we       DEH\n*      have been unsuccessful at the entry point. This seems        DEH\n*      to be of benefit for IMS load modules.                       DEH\nCOBANAL_05 DS  0H                                                MG0104\n         STRING64 'Program= ',PGMNAME_GET,                    *CSC* DEHX\n               ' loaded at address= ',(CSV_LOADPT,,X),           PF0608X\n               ' in ',(CSV_OUTXTLST_ENTRR,F,R3B),' extents',           X\n               ' for length=',(CSV_LENGTH,,X),                   PF0608X\n               INTO=RECORD                                          DEH\n         BRAS  R14,SPACE1                                           DEH\n*        STRING64 'CSV-LOAD-PTR= ',(CSV_LOADPT,,X),1X,                 X\n               ' Length= ',(CSV_LENGTH,,X),                            X\n               INTO=RECORD                    debug\n*        BRAS  R14,SPACE1\n         MVC   CSCPNAM(8),PGMNAME_GET                             *CSC*\n         L     R4,CSV_LOADPT        Load Load Address               DEH\n         USING COBOL_370_DSECT,R4                                   DEH\n         CLC   CSV_LENGTH,=F'32'    At least 32 bytes!!!          *CSC*\n         JNH   COBANAL_06_A          prevent S0C4                 *CSC*\n         CLC   CEE_EYECATCHER,C_COBOL370   COBOL/370 ?  X'00C3C5C5'\n         JE    COBOL_370\n         CLC   CEE_EYECATCHER,C_COBV5 Enter Cobol V5 ?  X'01C3C5C5'\n         JE    ENTCOBOLV5\n         CLC   CEE_EYECATCHER,=XL4'47000002' C    ?  X'47000002' RS0305\n         JE    C_370_NEW                                         RS0305\n         CLC   CEE_EYECATCHER,C_OPLINK     C         ?  X'01C3C5C5' DEH\n         JE    C_370                                                DEH\n         USING COBOL_2_DSECT,R4                                     DEH\n         CLC   C2_EYECATCHER,=CL4' C2 '     COBOL/2 ?  X'40C3F240'  DEH\n         JE    COBOL_2                                              DEH\n         USING COBOL_1_DSECT,R4                                     DEH\n* ???    CLC   C1_EYECATCHER,=CL2'AN'       ANS4 COBOL ?            DEH\n* ???    JE    COBOL_1                                              DEH\n         CLC   C1_EYECATCHER(4),=CL4'VSR1'       OS/VS COBOL/1 ?    DEH\n         JE    COBOL_1                                              DEH\n         CLC   C1_EYECATCHER(4),=CL4'VSR2'       OS/VS COBOL/1 ?    DEH\n         JE    COBOL_1                                              DEH\nCOBANAL_06 DS  0H\n* See if this program is a CICS/BMS Map. I noticed that at x'09'  *CSC*\n* from the LOADpoint is a fairly common header that occassionally *CSC*\n* changes.                                                        *CSC*\n         MVC   CSCLANG(9),=CL9'BMS Map  '     Indicate BMS Mapset *CSC*\n*                                                                 *CSC*\n         CLC   9(5,R4),=XL5'704040004F'       CICS/VS BMS Map?    *CSC*\n         JNE   COBANAL_BMS_CICSMVS            No, try CICSMVS BMS *CSC*\n         MVC   CSCCICS(4),=CL4'B170'          and OLD!            *CSC*\n         J     COBANAL_BMS_MESSAGE            Skip to message send*CSC*\nCOBANAL_BMS_CICSMVS DS  0H                                        *CSC*\n         CLC   9(5,R4),=XL5'214040004F'       CICS/MVS BMS Map?   *CSC*\n         JNE   COBANAL_BMS_CICSESA            No, try CICSESA BMS *CSC*\n         MVC   CSCCICS(4),=CL4'B210'          CICS/MVS V2.1 Level *CSC*\n         J     COBANAL_BMS_MESSAGE            Skip to message send*CSC*\nCOBANAL_BMS_CICSESA DS  0H                                        *CSC*\n         CLC   9(5,R4),=XL5'324040004F'       CICS/ESA BMS Map?   *CSC*\n         JNE   COBANAL_07                     No, Not BMS         *CSC*\n         MVC   CSCCICS(4),=CL4'B320'          CICS/ESA V3.2 Level *CSC*\nCOBANAL_BMS_MESSAGE DS  0H                                        *CSC*\n         AP    CNT_BMS,=P'1'             Increment counter        *CSC*\n         STRING64 PGMNAME_GET,' is probably a CICS/BMS Mapset',   *CSC*X\n               INTO=RECORD                                        *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         J     COBANAL_EXIT         no, leave                     *CSC*\n*                                                                 *CSC*\nCOBANAL_06_A DS  0H                                               *CSC*\n         AP    CNT_UNKNOWN,=P'1'         Increment counter        *CSC*\n         MVC   CSCPNAM(8),PGMNAME_GET    Save info for summary   RS1107\n         MVC   CSCLANG(9),=CL9'Unknown'  Save info for summary    *CSC*\n         MVC   CSCLPRM(21),=CL21'*Too small to analyse' summary   *CSC*\n*                                                                 *CSC*\n         STRING64 'Program= ',PGMNAME_GET,                        *CSC*X\n               ' was loaded at address= ',(CSV_LOADPT,,X),        *CSC*X\n               ' in ',(CSV_OUTXTLST_ENTRR,F,R3B),' extents',      *CSC*X\n               INTO=RECORD                                        *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         STRING64 'Program is too short to safely analyse! It ',  *CSC*X\n               'is only x',(CSV_LENGTH,,X),' bytes in length',    *CSC*X\n               INTO=RECORD                                        *CSC*\n         BRAS  R14,SPACE2                                         *CSC*\n*                                                                 *CSC*\n         J     COBANAL_EXIT         no, leave                     *CSC*\n*                                                                 *CSC*\nCOBANAL_07 DS  0H                                                 *CSC*\n         L     R2,CSV_LOADPT        R2 => Load Point              *CSC*\n*        STRING64 ' R2=',(16(R2),4,X),1X,(20(R2),4,X),                 X\n               1X,(24(R2),4,X),1X,                                     X\n               1X,(28(R2),4,X),3X,(16(R2),16),                         X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n         CLC   20(6,R2),=CL6'DFHPL1' CICS PL/I Stub?              *CSC*\n         JE    COBANAL_07_C         Yes,Cool.                     *CSC*\n         CLC   0(4,R2),=CL4'DFHY'   CICS Stub?                    *CSC*\n         JNE   COBANAL_07_D         No, no idea, sorry.           *CSC*\n         CLI   4(R2),C'A'           Yes,Assembler?                *CSC*\n         JNE   COBANAL_07_A         No, Try COBOL                 *CSC*\n*                                                                 *CSC*\n         STRING64 'Program=',PGMNAME_GET,                         *CSC*X\n               ' is a CICS Assembler program',                    *CSC*X\n               INTO=RECORD                                        *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         MVC   CSCLANG(9),=CL9'ASSEMBLER' Assembler.              *CSC*\n         STRING64 'S',(5(R2),3),INTO=CSCCICS                      *CSC*\n         AP    CNT_ASSEMBLER,=P'1'  Increment counter             *CSC*\n         J     COBANAL_EXIT                                       *CSC*\n*                                                                 *CSC*\nCOBANAL_07_A  DS  0H   ** Checking for COBOL here is redundant!!  *CSC*\n         CLI   4(R2),C'C'           CICS COBOL Stub?              *CSC*\n         JNE   COBANAL_07_B         No, Try C/C++                RS1107\n*                                                                 *CSC*\n         MVC   CSCLANG(7),=CL7'COBOL  ' COBOL                     *CSC*\n         STRING64 'Program=',PGMNAME_GET,                         *CSC*X\n               ' is a CICS COBOL program',                        *CSC*X\n               INTO=RECORD                                        *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         STRING64 'S',(5(R2),3),INTO=CSCCICS                      *CSC*\n         AP    CNT_OTHER,=P'1'      Redundant, so add to OTHER    *CSC*\n         J     COBANAL_EXIT                                       *CSC*\n*                                                                 *CSC*\nCOBANAL_07_B  DS  0H                                              *CSC*\n         CLI   4(R2),C'I'           CICS C/C++ Stub?             RS1107\n         JNE   COBANAL_07_C         No, Try PL/1 PL/I PL1 PLI     *CSC*\n*                                                                 *CSC*\n         STRING64 'Program=',PGMNAME_GET,                         *CSC*X\n               ' is a CICS C/C++ program',                       RS1107X\n               INTO=RECORD                                        *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         MVC   CSCLANG(7),=CL7'C/C++  ' C/C++                    RS1107\n         STRING64 'S',(5(R2),3),INTO=CSCCICS                      *CSC*\n         AP    CNT_C370,=P'1'       Increment counter             *CSC*\n         J     COBANAL_EXIT                                       *CSC*\n*                                                                 *CSC*\nCOBANAL_07_C  DS  0H                                              *CSC*\n         STRING64 'Program=',PGMNAME_GET,                         *CSC*X\n               ' is a CICS PL/I program',                         *CSC*X\n               INTO=RECORD                                        *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         MVC   CSCLANG(7),=CL7'PL/I   ' PL/1 PL/I PL1 PLI         *CSC*\n         MVC   CSCCICS(3),=CL3'YES'     PL/1 PL/I PL1 PLI         *CSC*\n         STRING64 'PLI ',(28(R2),8),INTO=CSCCOMP                  *CSC*\n         AP    CNT_PLI,=P'1'        Increment counter             *CSC*\n         J     COBANAL_EXIT                                       *CSC*\n*                                                                 *CSC*\nCOBANAL_07_D  DS  0H                                              *CSC*\n         AP    CNT_UNKNOWN,=P'1'         Increment counter        *CSC*\n         MVC   CSCLANG(9),=CL9'Unknown'                           *CSC*\n         STRING64 'Can not establish the program language. ',    PF0608X\n               'It is possibly assembler.',INTO=RECORD           PF0608\n         BRAS  R14,SPACE1                                        PF0608\n         STRING64 'See the SUMMARY listing for Binder record ',  PF0608X\n               'info about language and other features.',        PF0608X\n               INTO=RECORD                                       PF0608\n         BRAS  R14,SPACE2                                        RS1007\n         BRAS  R14,BINDER_INFO                                   RS1007\n*>---------------------------------------------------------------HP1107\n*>   any more csect's ? -> return to csect-loop                  HP1107\n         CLI   csect_analyze_kz,C'S'  any more csects ?          HP1107\n         je    COBANAL_Csect_Loop                                HP1107\n*>---------------------------------------------------------------HP1107\n         STRING64 '------------ End  --------------------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD                                       RS1007\n         BRAS  R14,SPACE2                                        RS1007\n         MVC   PGMNAME_GET,PGMNAME_SAV                           PF0608\n         MVI   PRINT_LEAD_SPACE,C'N' Insert NO space             PF0608\n         MVC   RETCODE,=F'4'\n         J     COBANAL_EXIT         no, leave\nCOBANAL_08 DS  0H\n         AP    CNT_INVALID,=P'1'         Increment counter        *CSC*\n         MVC   CSCLANG(9),=CL9'*INVALID'                          *CSC*\n         STRING64 'Program=',PGMNAME_GET,' seems to be LE but',        X\n               ' PPA1 looks invalid',INTO=RECORD\n         BRAS  R14,SPACE2\n         MVC   RETCODE,=F'8'\n         BRAS  R14,BINDER_INFO                                   RS1007\n         STRING64 '------------ End  --------------------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD                                       RS1007\n         BRAS  R14,SPACE2                                        RS1007\n*                                                                 *CSC*\n         J     COBANAL_EXIT         no, leave\nCOBANAL_09 DS  0H\n         CLI   0(R2),X'04'          ID = Enterprise Cobol V5 (04)RS0115\n         JE    COBANAL_10             no check PLI\n         CLI   0(R2),X'03'          ID = C       (03) ?\n         JNE   COBANAL_10             no check PLI\nCOBANAL_09A DS  0H                                                *CSC*\n         AP    CNT_C370,=P'1'            Increment counter        *CSC*\n         MVC   CSCLANG(9),=CL9'C/C++'                            RS1007\n         STRING64 'Program=',PGMNAME_GET,' is a C/C++-Program ', RS1007X\n               INTO=RECORD                                       RS1007\n         BRAS  R14,SPACE2                                        RS1007\n         BRAS  R14,BINDER_INFO                                   RS1007\n         BRAS  R14,CEEUOPT_INFO                                  RS1107\n         STRING64 '------------ End  --------------------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD                                       RS1007\n         BRAS  R14,SPACE2                                        RS1007\n         MVC   RETCODE,=F'4'\n         J     COBANAL_EXIT         no, leave\nCOBANAL_10 DS  0H\n         CLI   0(R2),X'0A'          ID = PLI       (10) ?\n         JNE   COBANAL_11             no, Check Fortran\nCOBANAL_10A DS  0H                                                *CSC*\n         AP    CNT_PLI,=P'1'             Increment counter        *CSC*\n         MVC   CSCLANG(9),=CL9'PL/I'                              *CSC*\n         STRING64 'Program=',PGMNAME_GET,' is a PLI-Program ',         X\n               INTO=RECORD\n         BRAS  R14,SPACE2                                        RS1007\n         BRAS  R14,BINDER_INFO                                   RS1007\n         BRAS  R14,CEEUOPT_INFO                                  RS1107\n         STRING64 '------------ End  --------------------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD                                       RS1007\n         BRAS  R14,SPACE2                                        RS1007\n         MVC   RETCODE,=F'4'\n         J     COBANAL_EXIT         no, leave\nCOBANAL_11 DS  0H\n         CLI   0(R2),X'07'          ID = Fortran   (07) ?\n         JNE   COBANAL_12             no, Check DCE\nCOBANAL_11A DS  0H                                               RS1107\n         AP    CNT_FORTRAN,=P'1'         Increment counter        *CSC*\n         MVC   CSCLANG(9),=CL9'FORTRAN'                           *CSC*\n         STRING64 'Program=',PGMNAME_GET,' is a Fortran-Program ',     X\n               INTO=RECORD\n         BRAS  R14,SPACE2                                        RS1007\n         BRAS  R14,BINDER_INFO                                   RS1007\n         BRAS  R14,CEEUOPT_INFO                                  RS1107\n         STRING64 '------------ End  --------------------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD                                       RS1007\n         BRAS  R14,SPACE2                                        RS1007\n         MVC   RETCODE,=F'4'\n         J     COBANAL_EXIT         no, leave\nCOBANAL_12 DS  0H\n         CLI   0(R2),X'08'          ID = DCE       (08) ?\n         JNE   COBANAL_13             no, Check Socket\n         AP    CNT_OTHER,=P'1'           Increment counter        *CSC*\n         MVC   CSCLANG(9),=CL9'DCE'                               *CSC*\n         STRING64 'Program=',PGMNAME_GET,' is a DCE-Program ',         X\n               INTO=RECORD\n         BRAS  R14,SPACE2                                        RS1007\n         BRAS  R14,BINDER_INFO                                   RS1007\n         BRAS  R14,CEEUOPT_INFO                                  RS1107\n         STRING64 '------------ End  --------------------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD                                       RS1007\n         BRAS  R14,SPACE2                                        RS1007\n         MVC   RETCODE,=F'4'\n         J     COBANAL_EXIT         no, leave\nCOBANAL_13 DS  0H\n         CLI   0(R2),X'0C'          ID = Sockets   (12) ?\n         JNE   COBANAL_14             no, Check Socket\n         AP    CNT_OTHER,=P'1'           Increment counter        *CSC*\n         MVC   CSCLANG(9),=CL9'SOCKETS'                           *CSC*\n         STRING64 'Program=',PGMNAME_GET,' is a Sockets-Program',      X\n               INTO=RECORD\n         BRAS  R14,SPACE2                                        RS1007\n         BRAS  R14,BINDER_INFO                                   RS1007\n         BRAS  R14,CEEUOPT_INFO                                  RS1107\n         STRING64 '------------ End  --------------------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD                                       RS1007\n         BRAS  R14,SPACE2                                        RS1007\n         MVC   RETCODE,=F'4'\n         J     COBANAL_EXIT         no, leave\nCOBANAL_14 DS  0H\n         CLI   0(R2),X'0F'          ID = Assembler (15) ?\n         JNE   COBANAL_06             no, unknown language\n         AP    CNT_LEASS,=P'1'           Increment counter        *CSC*\n         MVC   CSCLANG(9),=CL9'ASSEMBLER'                         *CSC*\n         STRING64 'Program=',PGMNAME_GET,' is a LE-enabled ',          X\n               'Assembler',INTO=RECORD\n         BRAS  R14,SPACE2                                        RS1007\n         BRAS  R14,BINDER_INFO                                   RS1007\n         BRAS  R14,CEEUOPT_INFO                                  RS1107\n         STRING64 '------------ End  --------------------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD                                       RS1007\n         BRAS  R14,SPACE2                                        RS1007\n         MVC   RETCODE,=F'4'\n         J     COBANAL_EXIT         no, leave\nCOBANAL_15 DS  0H                                                PF0708\n         AP    CNT_EZTRV,=P'1'           Increment counter       PF0708\n         MVC   CSCLANG(9),=CL9'EZTRIEVE+'                        PF0708\n         STRING64 'Program=',PGMNAME_GET,' is a compiled ',      PF0708X\n               'EZTrieve+',INTO=RECORD                           PF0708\n         BRAS  R14,SPACE2                                        PF0708\n* Now must search table of offsets to find JNLnnnnn CSECT        PF0708\n* It is OK to pick the first one for our purposes                PF0708\n         STRING64 ' R4=',((R4),4,X),1X,(4(R4),4,X),1X,(8(R4),4,X),1X,  X\n               (12(R4),4,X),3X,((R4),16),                              X\n               INTO=RECORD\n         BRAS  R14,SPACE1          <== next line\n         STRING64 4X,(16(R4),4,X),1X,(20(R4),4,X),1X,(24(R4),4,X),1X,  X\n               (28(R4),4,X),3X,(16(R4),16),                            X\n               INTO=RECORD\n         BRAS  R14,SPACE1          <== next line\n         STRING64 4X,(32(R4),4,X),1X,(36(R4),4,X),1X,(40(R4),4,X),1X,  X\n               (44(R4),4,X),3X,(32(R4),16),                            X\n               INTO=RECORD\n         BRAS  R14,SPACE1          <== next line\n         STRING64 4X,(48(R4),4,X),1X,(52(R4),4,X),1X,(56(R4),4,X),1X,  X\n               (60(R4),4,X),3X,(32(R4),16),                            X\n               INTO=RECORD\n         BRAS  R14,SPACE1          <== next line\n         USING EZTRIEVE_DSECT,R4                                 PF0708\n         LR    R2,R4          R2 = A(EntryPoint)                 PF0708\n         A     R2,EZ_TABLE_OFFSET  R2 = A(EZ_OFFSET_TABLE)       PF0708\n         LR    R14,R4         R14= A(EntryPoint)                 PF0708\n         A     R14,EZ_TBLEND_OFFSET R14= A(End of table)         PF0708\n         DROP  R4             Drop initial table addressibility  PF0708\n         USING EZ_OFFSET_TABLE,R2  Set table addressibility      PF0708\nCOBANAL_15A DS  0H            Loop to search for JNLnnnn CSECT   PF0708\n         CR    R2,R14         End of table?                      PF0708\n         JNL   COBANAL_15X    Yes, unknown EZTrieve version      PF0708\n         OC    EZ_TBL_WORD1,EZ_TBL_WORD1 Word1 = 0?              PF0708\n         JZ    COBANAL_15B    Yes, bypass this table entry       PF0708\n         OC    EZ_TBL_WORD2,EZ_TBL_WORD2 Word2 = 0?              PF0708\n         JZ    COBANAL_15B    Yes, bypass this table entry       PF0708\n         LR    R15,R4         R15= A(EntryPoint)                 PF0708\n         CLC   CSV_LENGTH,EZ_TBL_WORD2 Check length              RS1208\n         JNH   COBANAL_15B           prevent S0C4                RS1208\n         A     R15,EZ_TBL_WORD2 R15= A(Entrypoint + offset)      PF0708\n         USING EZTRIEVE_JNL_DSECT,R15                            PF0708\n         CLC   EZ_JNL_START_CODE,=X'47F0F0' Good starting code?  PF0708\n         JNE   COBANAL_15B    No, keep looking                   PF0708\n         CLC   EZ_JNL_R4_R5_CATCH,=C'E Z T  ' R4/R5 eyecatcher?  PF0708\n         JE    COBANAL_15C    Yes, go process R4/R5              PF0708\n         CLC   EZ_JNL_R6_CATCH,=C'CA-EASYTRIEVE ' R6 eyecatcher? PF0708\n         JE    COBANAL_15D    Yes, go process R6                 PF0708\nCOBANAL_15B DS  0H            No, keep looking                   PF0708\n         LA    R2,L'EZ_OFFSET_TABLE(,R2) Next table entry        PF0708\n         J     COBANAL_15A    Loop                               PF0708\n         DROP  R2                                                RS1108\nCOBANAL_15C DS  0H                   Move R4/R5 info             PF0708\n         MVC   CSCCOMP,EZ_JNL_R4_R5_EYECT                        PF0708\n         MVC   CSCDATE(L'EZ_JNL_R4_R5_CDATE),EZ_JNL_R4_R5_CDATE  PF0708\n         CLI   CSCDATE,C' '   Space at start of date?            PF0708\n         JNE   COBANAL_15X    No, done                           PF0708\n         MVI   CSCDATE,C'0'   Yes, set to zero                   PF0708\n         J     COBANAL_15X           Done                        PF0708\nCOBANAL_15D DS  0H                   Move R6 info                PF0708\n         MVC   CSCCOMP(4),=CL4'EZT '                             PF0708\n         MVC   CSCCOMP+4(L'EZ_JNL_R6_VERSN),EZ_JNL_R6_VERSN      PF0708\n         MVC   CSCDATE(L'EZ_JNL_R6_CDATE),EZ_JNL_R6_CDATE        PF0708\n         CLI   CSCDATE,C' '   Space at start of date?            PF0708\n         JNE   COBANAL_15X    No, done                           PF0708\n         MVI   CSCDATE,C'0'   Yes, set to zero                   PF0708\nCOBANAL_15X DS  0H                                               PF0708\n         BRAS  R14,BINDER_INFO                                   PF0708\n         BRAS  R14,CEEUOPT_INFO                                  PF0708\n         STRING64 '------------ End  --------------------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD                                       PF0708\n         BRAS  R14,SPACE2                                        PF0708\n         MVC   RETCODE,=F'4'                                     PF0708\n         J     COBANAL_EXIT         no, leave                    PF0708\nCOBANAL_PARM_ERROR DS  0H\n         STRING64 'Error parm statement, check it',INTO=RECORD\n         BRAS  R14,SPACE1\n         MVC   RETCODE,=F'12'\n         J     COBANAL_EXIT         no, leave\nCOBANAL_LOAD_ERROR DS  0H\n         ST    R1,SAVER1                 Save for later           *CSC*\n         ST    R15,SAVER15               Save for later           *CSC*\n         AP    CNT_NOTLOAD,=P'1'         Increment counter       PF0608\n         MVI   LOADERR,C'Y'              Remember we didn't LOAD PF0608\n         MVC   CSCPNAM(8),PGMNAME_GET    Save info for summary   RS1107\n         MVC   CSCLANG(9),=CL9'*NOTLOAD' Save info for summary   PF0608\n         MVC   CSCCOMP(17),=CL17'Program not found'              PF0608\n*                                                                 *CSC*\n         STRING64 'Error during LOAD of program=',PGMNAME_GET,    *CSC*X\n               ' R1=',(SAVER1,,X),' R15=',(SAVER15,,X),           *CSC*X\n               ' SYSIN',DD_SYSIN,                                 *CSC*X\n               INTO=RECORD                                        *CSC*\n         BRAS  R14,SPACE1\n         STRING64 'R1=',(SAVER1,,X),                              *CSC*X\n               ' R15=',(SAVER15,,X),INTO=CSCLPRM                  *CSC*\n         MVC   RETCODE,=F'12'\n         CLI   DD_SYSIN,C'Y'             via SYSIN ?             RS0516\n         JNE   COBANAL_LOAD_ERROR_RC12   no set RC12             RS0516\n         MVC   RETCODE,=F'4'             yes set RC4             RS0516\nCOBANAL_LOAD_ERROR_RC12 DS 0H                                    RS0516\n*                                                                 *CSC*\n         CLC   SAVER1,=X'00000706'       ABENDS706?               *CSC*\n         JNE   COBANAL_EXIT              No, Leave                *CSC*\n*                                                                 *CSC*\n         STRING64 'Module marked NX (Not Executable)',INTO=RECORD *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         MVC   CSCLPRM(25),=CL25'NX (Not Executable)'             *CSC*\n         J     COBANAL_EXIT              Leave\n*                                                                 *CSC*\nCOBANAL_CSV_ERROR DS  0H\n         STRING64 'CSVQUERY failed, RC=',((R2),,L),INTO=RECORD\n         BRAS  R14,SPACE1\n         MVC   RETCODE,=F'12'\n         J     COBANAL_EXIT         no, leave\nCOBANAL_EXIT       DS 0H\n         STRING64 FOOTER,INTO=RECORD Write a line of =====        *CSC*\n         BRAS  R14,SPACE2                                         *CSC*\n*                                                                 *CSC*\n         CLC   PGMNAME_GET,XFF      No more members?             PF0608\n         JE    COBANAL_EXIT_B       Yes, bypass DELETE           PF0608\n         CLI   LOADERR,C'Y'         Did we have a LOAD error?    PF0608\n         JNE   COBANAL_EXIT_A       No, go issue DELETE          PF0608\n         MVI   LOADERR,C'N'         Yes, reset switch            PF0608\n         J     COBANAL_EXIT_B       Bypass DELETE                PF0608\nCOBANAL_EXIT_A     DS 0H                                         PF0608\n         DELETE EPLOC=PGMNAME_GET   Delete the pgm\n         LTR   R15,R15              Error on delete?             PF0608\n         JZ    COBANAL_EXIT_B       No, bypass error message     PF0608\n         ST    R1,SAVER1            Store for display            PF0608\n         ST    R15,SAVER15          Store for display            PF0608\n         STRING64 'Error during DELETE of program=',PGMNAME_GET, PF0608X\n               ' R1=',(SAVER1,,X),' R15=',(SAVER15,,X),          PF0608X\n               ' PGMSAV=',PGMNAME_SAV,                           PF0608X\n               INTO=RECORD                                       PF0608\n         BRAS  R14,SPACE1                                        PF0608\nCOBANAL_EXIT_B     DS 0H                                         PF0608\n         CLC   CSCDATE,BLANKS       Did we get a SUMMARY date?   PF0608\n         JNE   COBANAL_EXIT_C       Yes, go print it             PF0608\n         CLC   SUM_DATE_SAVE,BLANKS Do we have another date?     PF0608\n         JE    COBANAL_EXIT_C       No, have to do without       PF0608\n*                                   Compiler date to SUMMARY     PF0608\n         STRING64 (SUM_DATE_SAVE,4),'.',                         PF0608X\n               (SUM_DATE_SAVE+4,3),INTO=CSCDATE                  PF0608\nCOBANAL_EXIT_C     DS 0H                                         PF0608\n*                                                                 *CSC*\n         STRING64 CSCSUMM,INTO=RECORD                             *CSC*\n         BRAS  R14,SUMMARY1               Print starting message  *CSC*\n         MVI   CSCSUMM,X'40'              Insert a blank          *CSC*\n         MVC   CSCSUMM+1(L'CSCSUMM-1),CSCSUMM Repeat to clear     *CSC*\n         MVC   SUM_DATE_SAVE,BLANKS  Clear saved date info       PF0608\n         MVI   FIXEDSUM,C'N'         Clear SUMMARY-fixed switch  PF0608\n         MVI   SETRMODE,C'N'         Clear SUMMARY-fixed switch  RS0316\n         MVI   LEFOUND,C'N'       Default                         *CSC*\n*                                                                 *CSC*\n         CLI   DOALL,C'N'           Default\n         JE    COBANAL_FIN\n         CLI   DOALL,C'X'           Exclude with wildcards?\n         JE    COBANAL_EXIT_1         yes get next\n         CLI   DOALL,C'S'           Read fom SYSIN?              RS1207\n         JE    COBANAL_EXIT_2         yes get next               RS1207\n         CLC   PGMNAME_GET,XFF      Last Program?\n         JNE   COBANAL_022            no loop\n         J     COBANAL_FIN          finish\nCOBANAL_EXIT_1     DS 0H\n         CLC   PGMNAME_GET,XFF      Last Program?\n         JNE   COBANAL_028           no loop\n         J     COBANAL_FIN          leave                        RS1207\nCOBANAL_EXIT_2     DS 0H                                         RS1207\n         GET   SYSIN,SYSIN_DATA    get a member name from SYSIN  RS1207\n*   End of file??                                                RS1207\n         CLI   SYSIN_DATA,C'*'     Comment ?                     RS0209\n         JE    COBANAL_EXIT_2        yes ignore                  RS0209\n         CLC   PGMNAME_GET,SYSIN_DATA   Same as last one?        PF0608\n         JE    COBANAL_EXIT_2      Yes, try the next one         PF0608\n         MVC   PGMNAME_GET,SYSIN_DATA   remember PGMNAME         RS1207\n         MVC   PGMNAME,PGMNAME_GET  remember PGMNAME             RS1207\n         J     COBANAL_026        load programm from             RS1207\nCOBANAL_FIN        DS 0H\n*                                                                 *CSC*\n         MVC   WORK(6),MASKTOT           Remove leading zeros     *CSC*\n         ED    WORK(6),CNT_ASSEMBLER     EDIT BMS                 *CSC*\n         MVC   TOT_ASSEMBLER(5),WORK+1   Assembler   Total        *CSC*\n         MVC   WORK(6),MASKTOT           Remove leading zeros     *CSC*\n         ED    WORK(6),CNT_BMS           EDIT BMS                 *CSC*\n         MVC   TOT_BMS(5),WORK+1         BMS         Total        *CSC*\n         MVC   WORK(6),MASKTOT           Remove leading zeros     *CSC*\n         ED    WORK(6),CNT_COBOLI        EDIT COBOLI              *CSC*\n         MVC   TOT_COBOLI(5),WORK+1      COBOLI      Total        *CSC*\n         MVC   WORK(6),MASKTOT           Remove leading zeros     *CSC*\n         ED    WORK(6),CNT_COBOL2        EDIT COBOL2              *CSC*\n         MVC   TOT_COBOL2(5),WORK+1      COBOL2      Total        *CSC*\n         MVC   WORK(6),MASKTOT           Remove leading zeros     *CSC*\n         ED    WORK(6),CNT_COBOLLE       EDIT LE enabled COBOL    *CSC*\n         MVC   TOT_COBOLLE(5),WORK+1     LE COBOL    Total        *CSC*\n         MVC   WORK(6),MASKTOT           Remove leading zeros     *CSC*\n         ED    WORK(6),CNT_C370          EDIT C/C++ programs     RS1107\n         MVC   TOT_C370(5),WORK+1        C/C++ programs total    RS1107\n         MVC   WORK(6),MASKTOT           Remove leading zeros     *CSC*\n         ED    WORK(6),CNT_FORTRAN       EDIT FORTRAN programs    *CSC*\n         MVC   TOT_FORTRAN(5),WORK+1     FORTRAN     Total        *CSC*\n         MVC   WORK(6),MASKTOT           Remove leading zeros     *CSC*\n         ED    WORK(6),CNT_INVALID       EDIT INVALID    COBOL    *CSC*\n         MVC   TOT_INVALID(5),WORK+1     INVALID     Total        *CSC*\n         MVC   WORK(6),MASKTOT           Remove leading zeros     *CSC*\n         ED    WORK(6),CNT_LEASS         EDIT LE Assemble progrs  *CSC*\n         MVC   TOT_LEASS(5),WORK+1       LE Assembler Total       *CSC*\n         MVC   WORK(6),MASKTOT           Remove leading zeros     *CSC*\n         ED    WORK(6),CNT_OTHER         EDIT Other programs      *CSC*\n         MVC   TOT_OTHER(5),WORK+1       OTHER progs Total        *CSC*\n         MVC   WORK(6),MASKTOT           Remove leading zeros     *CSC*\n         ED    WORK(6),CNT_PLI           EDIT PL/I                *CSC*\n         MVC   TOT_PLI(5),WORK+1         PLI         Total        *CSC*\n         MVC   WORK(6),MASKTOT           Remove leading zeros     *CSC*\n         ED    WORK(6),CNT_TOTAL         EDIT Total   programs    *CSC*\n         MVC   TOT_TOTAL(5),WORK+1       Total programs           *CSC*\n         MVC   WORK(6),MASKTOT           Remove leading zeros     *CSC*\n         ED    WORK(6),CNT_UNKNOWN       EDIT UNKNOWN programs    *CSC*\n         MVC   TOT_UNKNOWN(5),WORK+1     UNKNOWN     Total        *CSC*\n         MVC   WORK(6),MASKTOT           Remove leading zeros    PF0608\n         ED    WORK(6),CNT_NOTLOAD       EDIT Notloaded programs PF0608\n         MVC   TOT_NOTLOAD(5),WORK+1     Notloaded   Total       PF0608\n         MVC   WORK(6),MASKTOT           Remove leading zeros    PF0708\n         ED    WORK(6),CNT_EZTRV         EDIT EZTrieve+ programs PF0708\n         MVC   TOT_EZTRV(5),WORK+1       EZTrieve+   Total       PF0708\n*                                                                 *CSC*\n         STRING64 FOOTER,INTO=RECORD                             RS0908\n         BRAS  R14,SPACE2                                         *CSC*\n         STRING64 FOOTER,'========',INTO=RECORD                  RS0908\n         BRAS  R14,SUMMARY2                                       *CSC*\n         STRING64 '                BMS Maps:',                    *CSC*X\n               TOT_BMS,INTO=RECORD                                *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         BRAS  R14,SUMMARY1                                       *CSC*\n         STRING64 '             OS/VS/COBOL:',                    *CSC*X\n               TOT_COBOLI,INTO=RECORD                             *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         BRAS  R14,SUMMARY1                                       *CSC*\n         STRING64 '               VS/COBOL2:',                    *CSC*X\n               TOT_COBOL2,INTO=RECORD                             *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         BRAS  R14,SUMMARY1                                       *CSC*\n         STRING64 '     LE-conforming COBOL:',                    *CSC*X\n               TOT_COBOLLE,INTO=RECORD                            *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         BRAS  R14,SUMMARY1                                       *CSC*\n         STRING64 '                   C/C++:',                   RS1107X\n               TOT_C370,INTO=RECORD                               *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         BRAS  R14,SUMMARY1                                       *CSC*\n         STRING64 '                 FORTRAN:',                    *CSC*X\n               TOT_FORTRAN,INTO=RECORD                            *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         BRAS  R14,SUMMARY1                                       *CSC*\n         STRING64 '                 INVALID:',                    *CSC*X\n               TOT_INVALID,INTO=RECORD                            *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         BRAS  R14,SUMMARY1                                       *CSC*\n         STRING64 '               Assembler:',                    *CSC*X\n               TOT_ASSEMBLER,INTO=RECORD                          *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         BRAS  R14,SUMMARY1                                       *CSC*\n         STRING64 '    LE Enabled Assembler:',                    *CSC*X\n               TOT_LEASS,INTO=RECORD                              *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         BRAS  R14,SUMMARY1                                       *CSC*\n         STRING64 '                   OTHER:',                    *CSC*X\n               TOT_OTHER,INTO=RECORD                              *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         BRAS  R14,SUMMARY1                                       *CSC*\n         STRING64 '               EZTrieve+:',                   PF0708X\n               TOT_EZTRV,INTO=RECORD                             PF0708\n         BRAS  R14,SPACE1                                        PF0708\n         BRAS  R14,SUMMARY1                                      PF0708\n         STRING64 '                    PL/I:',                    *CSC*X\n               TOT_PLI,INTO=RECORD                                *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         BRAS  R14,SUMMARY1                                       *CSC*\n         STRING64 '                 UNKNOWN:',                    *CSC*X\n               TOT_UNKNOWN,INTO=RECORD                            *CSC*\n         BRAS  R14,SPACE2                                         *CSC*\n         BRAS  R14,SUMMARY2                                       *CSC*\n         STRING64 '   Total loaded Programs:',TOT_TOTAL,          *CSC*X*\n               INTO=RECORD\n         BRAS  R14,SPACE1                                         *CSC*\n         BRAS  R14,SUMMARY1                                       *CSC*\n         STRING64 '(includes do not count)',                     PF0608X*\n               INTO=RECORD\n         BRAS  R14,SPACE2                                         *CSC*\n         BRAS  R14,SUMMARY2                                       *CSC*\n*                                                                 *CSC*\n         STRING64 '     Could not be Loaded:',                   PF0608X\n               TOT_NOTLOAD,INTO=RECORD                           PF0608\n         BRAS  R14,SPACE1                                        PF0608\n         BRAS  R14,SUMMARY1                                      PF0608\n         AP    CNT_TOTAL,CNT_NOTLOAD     Add for total processed PF0608\n         MVC   WORK(6),MASKTOT           Remove leading zeros    PF0608\n         ED    WORK(6),CNT_TOTAL         EDIT Total   programs   PF0608\n         MVC   TOT_TOTAL(5),WORK+1       Total programs          PF0608\n         STRING64 'Total Programs processed:',                   PF0608X\n               TOT_TOTAL,INTO=RECORD                             PF0608\n         BRAS  R14,SPACE1                                        PF0608\n         BRAS  R14,SUMMARY1                                      PF0608\n*                                                                PF0608\nCOBANAL_FIN_A      DS 0H                                          *CSC*\n         LA    R9,SYSPRINT\n         USING IHADCB,R9\n         TM    DCBOFLGS-IHADCB(R9),DCBOFOPN Is it OPEN?\n         JNO   COBANAL_FIN_1              No, ignore it\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE\n         CLOSE ((R9)),MF=(E,PARMLIST),MODE=31     Close it\n         DROP  R9\n*                                                                 *CSC*\n         CLI   SUMMARYR,C'Y'                                      *CSC*\n         JNE   COBANAL_FIN_1                                      *CSC*\n         LA    R9,SUMMARY                                         *CSC*\n         USING IHADCB,R9                                          *CSC*\n         TM    DCBOFLGS-IHADCB(R9),DCBOFOPN Is it OPEN?           *CSC*\n         JNO   COBANAL_FIN_1              No, ignore it           *CSC*\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE                         *CSC*\n         CLOSE ((R9)),MF=(E,PARMLIST),MODE=31     Close it        *CSC*\n         DROP  R9                                                 *CSC*\nCOBANAL_FIN_1      DS 0H\n         CLI   DD_COBANAL,C'Y'                                   PF0608\n         JNE   COBANAL_FIN_2                                     PF0608\n         LA    R9,INPUT\n         USING IHADCB,R9\n         TM    DCBOFLGS-IHADCB(R9),DCBOFOPN Is it OPEN?\n         JNO   COBANAL_FIN_2              No, ignore it\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE\n         CLOSE ((R9)),MF=(E,PARMLIST),MODE=31     Close it\n         DROP  R9\nCOBANAL_FIN_2      DS 0H\n         LA    R9,LOADL                                          PF0608\n         USING IHADCB,R9                                         PF0608\n         TM    DCBOFLGS-IHADCB(R9),DCBOFOPN Is it OPEN?          PF0608\n         JNO   COBANAL_FIN_2A             No, ignore it          PF0608\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE                        PF0608\n         CLOSE ((R9)),MF=(E,PARMLIST),MODE=31     Close it       PF0608\n         DROP  R9                                                PF0608\nCOBANAL_FIN_2A     DS 0H                                         PF0608\n*                                                                PF0608\n         CLI   DD_SYSIN,C'Y'                                     PF0608\n         JNE   COBANAL_FIN_2B                                     =CMS=\n         LA    R9,SYSIN                                          PF0608\n         USING IHADCB,R9                                         PF0608\n         TM    DCBOFLGS-IHADCB(R9),DCBOFOPN Is it OPEN?          PF0608\n         JNO   COBANAL_FIN_3              No, ignore it          PF0608\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE                        PF0608\n         CLOSE ((R9)),MF=(E,PARMLIST),MODE=31     Close it       PF0608\n         DROP  R9                                                PF0608\nCOBANAL_FIN_2B     DS 0H                                         PF0608\n         CLI   JUSTDATA_R,C'Y'                                    =CMS=\n         JNE   COBANAL_FIN_3                                      =CMS=\n         LA    R9,JUSTDATA                                        =CMS=\n         USING IHADCB,R9                                          =CMS=\n         TM    DCBOFLGS-IHADCB(R9),DCBOFOPN Is it OPEN?           =CMS=\n         JNO   COBANAL_FIN_3              No, ignore it           =CMS=\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE                         =CMS=\n         CLOSE ((R9)),MF=(E,PARMLIST),MODE=31     Close it        =CMS=\n         DROP  R9                                                 =CMS=\nCOBANAL_FIN_3      DS 0H                                         PF0608\n*        Freemain area for IEWBIND\n         L     R0,BNLI_BUFFER_LENG\n         L     R1,IEW_BNLI_PTR\n         STORAGE RELEASE,LENGTH=(R0),ADDR=(R1)\n         L     R0,IDLI_BUFFER_LENG                               RS1007\n         L     R1,IEW_IDLI_PTR                                   RS1007\n         STORAGE RELEASE,LENGTH=(R0),ADDR=(R1)                   RS1007\n         L     R0,ESDI_BUFFER_LENG                               RS1007\n         L     R1,IEW_ESDI_PTR                                   RS1007\n         STORAGE RELEASE,LENGTH=(R0),ADDR=(R1)                   RS1007\n         L     R0,IDUI_BUFFER_LENG                               RS1007\n         L     R1,IEW_IDUI_PTR                                   RS1007\n         STORAGE RELEASE,LENGTH=(R0),ADDR=(R1)                   RS1007\n         L     R0,IDZI_BUFFER_LENG                               RS1007\n         L     R1,IEW_IDZI_PTR                                   RS1007\n         STORAGE RELEASE,LENGTH=(R0),ADDR=(R1)                   RS1007\n         L     R0,IDBI_BUFFER_LENG                               RS1007\n         L     R1,IEW_IDBI_PTR                                   RS1007\n         STORAGE RELEASE,LENGTH=(R0),ADDR=(R1)                   RS1007\n         L     R8,RETCODE                                        RS1107\n         LAY   R0,COBANAL_WORK_LENGTH                            RS1206\n         STORAGE RELEASE,              free Storage                    X\n               LENGTH=(R0),            Length                          X\n               ADDR=((R11))\n         LR    R15,R8                                            RS1107\n         PR\n*------------------------------------------------------------*\n* Binder Info                                                *\n* The code reside at this location as the LOAD macro         *\n* on OS/390 R10 require a base register. At z/OS R4          *\n* the LOAD macro works without a base register!!!            *\n*------------------------------------------------------------*\n*\nBINDER_INFO DS 0H\n         mvc   PGMNAME_sav,PGMNAME_GET                           HP1107\n         ST    R14,BINDSAVE\n         STRING64 ADDINFO,INTO=RECORD                             *CSC*\n         BRAS  R14,SPACE1\n         STRING64 '------------ about the Binder          -----------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD\n         BRAS  R14,SPACE2\n         STRING64 'This program contains the following CSECTS',        X\n               INTO=RECORD\n         BRAS  R14,SPACE2                                        RS1007\n         L     R4,IEW_BNLI_PTR\n         USING IEWBBNL,R4\n         LA    R5,BNLH_END\n         USING BNL_ENTRY,R5\n*        IEWBUFF FUNC=INITBUF,TYPE=NAME    Init the buffer\n         MVC   IEWBBNL(BNLH_LENG),BNLI_INIT_VALUES\n         MVC   IEW_DTOKEN,=D'0'       Clear dialog token\n*        Clear WKTOKEN here in case STARTD fails                 PF0608\n         MVC   IEW_WKTOKEN,=D'0'      Clear workmod token        PF0608\n         MVC   IEWBIND_FUNCTION,=CL8'STARTD'                      *CSC*\n         DEVTYPE =CL8'BINDEROU',DOUBLE    Get BINDEROU informationS1007\n         LTR   R15,R15                    Is it allocated?       RS1007\n         JNZ   BINDER_INFO_01             No, continue           RS1007\n         IEWBIND FUNC=STARTD,     Start dialog with Debug-File         X\n               RETCODE=IRETCODE,                                       X\n               RSNCODE=RSNCODE,                                        X\n               DIALOG=IEW_DTOKEN,                                      X\n               FILES=FILELIST,           <- Has file list for print    X\n               OPTIONS=OPTLIST3,         <- Has term off and print on  X\n               VERSION=4,                                              X\n               MF=(E,IEWBIND)                                    RS1007\n         J     BINDER_INFO_02             jump around            RS1007\nBINDER_INFO_01 DS 0H                                             RS1007\n         IEWBIND FUNC=STARTD,     Start dialog                         X\n               RETCODE=IRETCODE,                                       X\n               RSNCODE=RSNCODE,                                        X\n               DIALOG=IEW_DTOKEN,                                      X\n               VERSION=4,                                              X\n               MF=(E,IEWBIND)\nBINDER_INFO_02 DS 0H                                             RS1007\n         CLC   RSNCODE,=F'0'      Check the reason code\n         JE    BINDER_INFO_03     Zero, OK to continue           PF0608\n         MVC   IEW_DTOKEN,XFF     Remember no dialog was started PF0608\n         J     BINDER_ERROR       Exit, bad STARTD               PF0608\nBINDER_INFO_03 DS 0H                                             PF0608\n         MVC   IEWBIND_FUNCTION,=CL8'CREATEW'                     *CSC*\n         IEWBIND FUNC=CREATEW,    Create workmod Access only           X\n               RETCODE=IRETCODE,                                       X\n               RSNCODE=RSNCODE,                                        X\n               WORKMOD=IEW_WKTOKEN,                                    X\n               DIALOG=IEW_DTOKEN,                                      X\n               INTENT=ACCESS,                                          X\n               VERSION=4,                                              X\n               MF=(E,IEWBIND)\n*        STRING64 'CREATEW: RC: ',(IRETCODE,,X),' RSN: ',(RSNCODE,,X), X\n               'DTOKEN: ',(IEW_DTOKEN,,X),                             X\n               INTO=RECORD\n*        BRAS  R14,SPACE1\n         CLC   RSNCODE,=F'0'      Check the reason code\n         JE    BINDER_INFO_031    Zero, OK to continue           PF0608\n         MVC   IEW_WKTOKEN,XFF    Remember we have no workmod    PF0608\n         J     BINDER_ERROR       Exit, bad CREATEW              PF0608\nBINDER_INFO_031 DS 0H                                            PF0608\n         DEVTYPE =CL8'BINDEROU',DOUBLE  Get BINDEROU information RS1007\n         LTR   R15,R15                  Is it allocated?         RS1007\n         JNZ   BINDER_INFO_04           No, continue             RS1007\n         MVC   IEWBIND_FUNCTION,=CL8'SETO'                       RS1007\n         IEWBIND FUNC=SETO,        Set Options                         X\n               RETCODE=IRETCODE,                                       X\n               RSNCODE=RSNCODE,                                        X\n               WORKMOD=IEW_WKTOKEN,                                    X\n               OPTION=O_LIST,OPTVAL=V_ALL,      LIST(ALL)              X\n               VERSION=4,                                              X\n               MF=(E,IEWBIND)                                    RS1007\n*        STRING64 'INCLUDE: RC: ',(IRETCODE,,X),' RSN: ',(RSNCODE,,X), X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1                                        RS1007\n         CLC   RSNCODE,=F'0'      Check the reason code          RS1007\n         JNE   BINDER_ERROR       Exit if not zero               RS1007\nBINDER_INFO_04 DS 0H                                             RS1007\n         MVC   IEWBIND_FUNCTION,=CL8'INCLUDE'                     *CSC*\n* Try INCLUDE from EPTOKEN first, then use NAME and COBANAL if   PF0608\n* EPTOKEN attempt gets RC=8, RSN=83000514                        PF0608\n         IEWBIND FUNC=INCLUDE,                                         X\n               RETCODE=IRETCODE,                                       X\n               RSNCODE=RSNCODE,                                        X\n               WORKMOD=IEW_WKTOKEN,                                    X\n               INTYPE=TOKEN,                                           X\n               EPTOKEN=CSV_EPTOKEN,                                    X\n               VERSION=4,                                              X\n               MF=(E,IEWBIND)\n*        STRING64 'INCLUDE: RC= ',(IRETCODE,,X),                 PF0608X\n               '   INADDR=',(ADR_PGMNAME,,X),                    PF0608X\n               ' OUTLOADP=',(CSV_LOADPT,,X),                     PF0608X\n               ' IEWTOKEN=',(IEW_WKTOKEN,,X),                    PF0608X\n               '  EPTOKEN=',(CSV_EPTOKEN,,X),                    PF0608X\n               INTO=RECORD                                       PF0608\n*        BRAS  R14,SPACE1                                        PF0608\n*        STRING64 'INCLUDE: RC: ',(IRETCODE,,X),' RSN: ',(RSNCODE,,X), X\n               INTO=RECORD\n*        BRAS  R14,SPACE1\n         CLC   RSNCODE,=F'0'      Check the reason code\n         JE    BINDER_INFO_05     Continue if zero               PF0608\n* Possible INCLUDE error, check to see if it is only a warning   PF0608\n         CLC   IRETCODE,=F'4'     Warning only?                  PF0608\n         JNH   BINDER_INFO_05     Yes, OK to continue            PF0608\n* INCLUDE error, check to see if we can retry with NAME/DDN/MBR  PF0608\n         CLC   RSNCODE,=X'83000514' Retryable reason code?       PF0608\n         JNE   BINDER_ERROR       No, don't retry                PF0608\n         CLI   DD_COBANAL,C'Y'    Do we have a COBANAL DD?       PF0608\n         JNE   BINDER_ERROR       No, can't try INCLUDE again    PF0608\n* OK, we can retry INCLUDE with NAME/DDN/MBR                     PF0608\n* First a message saying what has happened                       PF0608\n         STRING64 'EPTOKEN access to the load module failed,',   PF0608X\n               ' trying NAME access',                            PF0608X\n               INTO=RECORD                                       PF0608\n         BRAS  R14,SPACE1                                        PF0608\n         BRAS  R14,PGMNAME_2_MBR  Move PGMNAME to IEW_MBR        PF0708\n* Now retry the INCLUDE with NAME/DDN/MBR                        PF0608\n         IEWBIND FUNC=INCLUDE,                                   PF0608X\n               RETCODE=IRETCODE,                                 PF0608X\n               RSNCODE=RSNCODE,                                  PF0608X\n               WORKMOD=IEW_WKTOKEN,                              PF0608X\n               INTYPE=NAME,                                      PF0608X\n               DDNAME=IEW_DDN,                                   PF0608X\n               MEMBER=IEW_MBR,                                   PF0608X\n               VERSION=4,                                        PF0608X\n               MF=(E,IEWBIND)                                    PF0608\n*        STRING64 'INCLUDE: RC= ',(IRETCODE,,X),                 PF0608X\n               '   INADDR=',(ADR_PGMNAME,,X),                    PF0608X\n               ' OUTLOADP=',(CSV_LOADPT,,X),                     PF0608X\n               ' IEWTOKEN=',(IEW_WKTOKEN,,X),                    PF0608X\n               INTO=RECORD                                       PF0608\n*        BRAS  R14,SPACE1                                        PF0608\n*        STRING64 'INCLUDE: ',                                   PF0608X\n               '  DD NAME=',IEW_DDNN,                            PF0608X\n               ' MBR LENG=',(IEW_MBRL,,X),                       PF0608X\n               ' MBR NAME=',IEW_MBRN,                            PF0608X\n               INTO=RECORD                                       PF0608\n*        BRAS  R14,SPACE1                                        PF0608\n*        STRING64 'INCLUDE: RC: ',(IRETCODE,,X),' RSN: ',        PF0608X\n               (RSNCODE,,X),INTO=RECORD                          PF0608\n*        BRAS  R14,SPACE1                                        PF0608\n         CLC   RSNCODE,=F'0'      Check the reason code          PF0608\n         JE    BINDER_INFO_05     Continue if zero               PF0608\n* Possible INCLUDE error, check to see if it is only a warning   PF0608\n         CLC   IRETCODE,=F'4'     Warning only?                  PF0608\n         JH    BINDER_ERROR       No, signal error               PF0608\nBINDER_INFO_05 DS 0H                                             PF0608\n         MVC   IEW_CURSORN,=F'0'      Clear Cursor\n         MVC   IEWBIND_FUNCTION,=CL8'GETN'                        *CSC*\n         IEWBIND FUNC=GETN,                                            X\n               RETCODE=IRETCODE,                                       X\n               RSNCODE=RSNCODE,                                        X\n               WORKMOD=IEW_WKTOKEN,                                    X\n               AREA=IEWBBNL,                                           X\n               CURSOR=IEW_CURSORN,                                     X\n               COUNT=IEW_COUNTN,                                       X\n               TCOUNT=IEW_TCOUNT,                                      X\n               NTYPE=S,                                                X\n               VERSION=4,                                              X\n               MF=(E,IEWBIND)\n*        STRING64 '   GETN: RC: ',(IRETCODE,,X),' RSN: ',(RSNCODE,,X), X\n               'COUNT: ',(IEW_COUNTN,,X),' Token: ',(IEW_WKTOKEN,,X),  X\n               INTO=RECORD\n*        BRAS  R14,SPACE1\n*\n*        Dump the first 256 Bytes for Identification.\n*        Should be activated only in case of problems\n*        STRING64 4X,((R8),4,X),1X,(4(R8),4,X),1X,(8(R8),4,X),1X,      X\n               (12(R8),4,X),3X,((R8),16),                              X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 4X,(16(R8),4,X),1X,(20(R8),4,X),1X,(24(R8),4,X),1X,  X\n               (28(R8),4,X),3X,(16(R8),16),                            X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 4X,((R9),4,X),1X,(4(R9),4,X),1X,(8(R9),4,X),1X,      X\n               (12(R9),4,X),3X,((R9),16),                              X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 4X,(16(R9),4,X),1X,(20(R9),4,X),1X,(24(R9),4,X),1X,  X\n               (28(R9),4,X),3X,(16(R9),16),                            X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n         CLC   RSNCODE,=F'0'      Check reason code\n         JE    BINDER_INFO_10     continue if zero\n         CLC   IRETCODE,=F'4'     Do we have all the names\n         JH    BINDER_ERROR       Any higher is an error\n*                                                                 *CSC*\nBINDER_INFO_10 DS 0H\n         L     R12,IEW_COUNTN     Number of sections\n*        BCTR  R12,0              Not -1! Process all names      PF0608\n*loop\nBINDER_INFO_20 DS 0H\n         L     R3,BNL_NAME_PTR    Extract section name\n         MVC   IEW_SECTION_DATA(255),BLANKS                      PF0608\n         LH    R2,BNL_NAME_CHARS\n         STH   R2,IEW_SECTION_LEN                                PF0608\n         STRING64 (0(R3),(R2),),INTO=IEW_SECTION_DATA Name       PF0608\n         CLI   LEFOUND,C'Y'                                       *CSC*\n         JE    BINDER_INFO_30                                    RS1007\n         CLC   CSCLANG(9),=CL9'Unknown'                          RS1107\n         JE    BINDER_INFO_30                                    RS1107\n         CLI   FIXEDSUM,C'Y'      Did it start out as UNKNOWN?   PF0608\n         JE    BINDER_INFO_30     Yes, don't update LE column    PF0608\n         MVC   CSCLE(3),=CL3'NO '                                 *CSC*\n         CLC   0(3,R3),=CL3'CEE'                                  *CSC*\n         JNE   BINDER_INFO_30                                    RS1007\n         MVC   CSCLE(3),=CL3'YES'                                 *CSC*\n         MVI   LEFOUND,C'Y'                                       *CSC*\nBINDER_INFO_30 DS 0H                                             RS1007\n         LH    R8,IEW_SECTION_LEN                                PF0608\n         STRING64 2X,(IEW_SECTION_DATA,(R8),),INTO=RECORD        PF0608\n         MVC   WORK,BLANKS        Keep it for later              RS1107\n         STRING64 (IEW_SECTION_DATA,(R8),),INTO=WORK             PF0608\n         CLI   IEW_SECTION_DATA,X'00'                            PF0608\n         JNE   BINDER_INFO_30_NOPRIV                             RS1007\n         STRING64 2X,'$PRIV',(IEW_SECTION_DATA,4,X),INTO=RECORD  PF0608\nBINDER_INFO_30_NOPRIV DS 0H                                      RS1007\n         BRAS  R14,SPACE1          <== next line                 RS1007\n         LH    R8,IEW_SECTION_LEN                                PF0608\n         MVC   IEW_CURSORD,=F'0'      Clear Cursor               RS1007\n         STM   R4,R5,SAVER4_AND_R5                               RS1007\n         L     R4,IEW_IDLI_PTR                                   RS1007\n         USING IEWBIDL,R4                                        RS1007\n*        IEWBUFF FUNC=INITBUF,TYPE=IDL     Init the buffer       RS1007\n         MVC   IEWBIDL(IDLH_LENG),IDLI_INIT_VALUES               RS1007\n         MVC   IEWBIND_FUNCTION,=CL8'GETD-IDL'                   RS1007\n         LA    R5,IDLH_END                                       RS1007\n         USING IDL_ENTRY,R5                                      RS1007\n         IEWBIND FUNC=GETD,                                            X\n               RETCODE=IRETCODE,                                       X\n               RSNCODE=RSNCODE,                                        X\n               WORKMOD=IEW_WKTOKEN,                                    X\n               CLASS=IEW_IDL,                                          X\n               SECTION=IEW_SECTION,                                    X\n               AREA=IEWBIDL,                                           X\n               CURSOR=IEW_CURSORD,                                     X\n               COUNT=IEW_COUNTD,                                       X\n               VERSION=4,                                              X\n               MF=(E,IEWBIND)                                    RS1007\n*        STRING64 '   GETD: IDL ',(IRETCODE,,X),' RSN: ',(RSNCODE,,X), X\n               'COUNT: ',(IEW_COUNTD,,X),' Token: ',(IEW_WKTOKEN,,X),  X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1                                        RS1007\n         CLC   RSNCODE,=F'0'      Check reason code              RS1007\n         JE    BINDER_INFO_31     continue if zero               RS1007\n*        CLC   IRETCODE,=F'4'     Do we have all the names       RS1007\n*        JH    BINDER_ERROR       Any higher is an error         RS1007\nBINDER_INFO_31 DS 0H                                             RS1007\n*        Should be activated only in case of problems            RS1007\n*        STRING64 4X,((R4),4,X),1X,(4(R4),4,X),1X,(8(R4),4,X),1X,      X\n               (12(R4),4,X),3X,((R4),16),                              X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(16(R4),4,X),1X,(20(R4),4,X),1X,(24(R4),4,X),1X,  X\n               (28(R4),4,X),3X,(16(R4),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE2          <== next line                 RS1007\n         MVC   CSECT_ACT_KZ(2),BLANKS  LANGUAGE-KZ               RS1107\n         L     R10,IEW_COUNTD            Number of sections      RS1007\n         LTR   R10,R10                                           RS1007\n         JNZ   BINDER_INFO_32          Have some, go analyze     PF0608\n         CLI   IEW_SECTION_DATA,X'00'  Binder-level name?        PF0608\n         JE    BINDER_INFO_31_1        Yes, don't save here      RS1007\n         LARL  R10,PID_TABLE_LAST      None avail, initialize    PF0608\n         ST    R10,ADR_PIDENTRY        Save for ESD scan         PF0608\n*        MVC   2(10,R10),=CL10'UnknownPID' Set PID to UNKNOWN    KP0609\n         CLC   SUM_DATE_SAVE,BLANKS    Any date saved yet?       PF0608\n         JNE   BINDER_INFO_31_1        Yes, don't change it      PF0608\n         MVC   SUM_DATE_SAVE,BLANKS    Clear for SUMMARY         PF0608\n         MVC   SUM_DATE_SAVE(9),=CL9'Unknown' Set to UNKNOWN     PF0608\nBINDER_INFO_31_1 DS 0H                                           PF0608\n         CLC   =CL9'Unknown',CSCLANG   Is main unknown?          PF0608\n         JNE   BINDER_INFO_40          No, leave SUMMARY alone   PF0608\n         MVC   CSCCOMP(17),=CL17'No info available'              PF0608\n         J     BINDER_INFO_40          Leave, no entries at all  PF0608\n*        BCTR  R10,0               Not -1, process all entries   PF0608\nBINDER_INFO_32 DS 0H                                             RS1007\n         MVC   SUM_DATE_SAVE,IDL_DATE_PROCESSED Save for SUMMARY PF0608\n         USING IDL_ENTRY,R5                                      RS1007\n         STRING64 11X,' B_IDRL ',                                      X\n               (IDL_DATE_PROCESSED,4),'.',                             X\n               (IDL_DATE_PROCESSED+4,3),1X,(IDL_PID_ID,10),            X\n               ' V',IDL_VERSION,                                       X\n               ' M',IDL_MOD_LEVEL,INTO=RECORD                    RS1007\n         BRAS  R9,BINDER_INFO_32_1                               RS1007\n*   Most taken from Dave Alcock                                  RS1007\n*   Add indicators for all languages and sort by indicator/lang  PF0608\n*   and put it into a separate copy member to ease maintenance   PF0608\n*>---------------------------------------------------------------HP1107\n         COPY  PIDTABLE                                          PF0608\nPID_TABLE_LAST DS 0H                                             PF0608\n    dc XL2'0',cl10'UnknownPID',CL8'Unknown'        end of table  KP0609\nBINDER_INFO_32_1 DS 0H                                           RS1007\n** table suffix 2byte for additional csect-analysis\n         CLC   IDL_PID_ID(10),2(R9)         check                HP1107\n         JE    BINDER_INFO_32_2        jump if on                RS1007\n         LA    R9,20(,R9)              Skip entry                HP1107\n         CLI   0(R9),0                 end of table?             RS1007\n         JNE   BINDER_INFO_32_1        not yet, loop             RS1007\nBINDER_INFO_32_2 DS 0H                                           RS1007\n         MVC   RECORD+47(8),12(R9)     long text for PID         HP1107\n         mvc   csect_act_kz(2),0(r9)   language-kz               HP1107\n         ST    R9,ADR_PIDENTRY         Save entry for ESD scan   PF0608\n*        CLI   0(R9),0                 End of table?             KP0609\n*        JNE   BINDER_INFO_32_3        No, don't copy Binder PID KP0609\n*        MVC   2(10,R9),IDL_PID_ID     Copy unknown PID to table KP0609\nBINDER_INFO_32_3 DS 0H                                           PF0608\n         CLC   =CL9'Unknown',CSCLANG   Is main unknown?          PF0608\n         JE    BINDER_INFO_32_31       Yes, try to fix language  PF0708\n         CLC   =CL9'*INVALID',CSCLANG  Is main invalid?          RS0316\n         JE    BINDER_INFO_32_30       Yes, try to fix language  RS0316\n         J     BINDER_INFO_32_5        No, leave SUMMARY alone   RS0316\nBINDER_INFO_32_30 DS 0H          Adjust counter and reset RC     RS0316\n         MVC   RETCODE,=F'0'           Reset RC                  RS0316\n         SP    CNT_INVALID,=P'1'  Subtract from INVALID count    RS0316\n         AP    CNT_UNKNOWN,=P'1'  Add from UNKNOWN count         RS0316\nBINDER_INFO_32_31 DS 0H                                          PF0608\n         CLC   PGMNAME_GET,WORK        Section name = LOAD name? PF0608\n         JE    BINDER_INFO_32_4        Yes, go fix SUMMARY       PF0708\n         CLC   =CL8'MAIN',WORK   Section name = MAIN = FORTRAN?  PF0708\n         JNE   BINDER_INFO_32_5        No, leave SUMMARY alone   PF0708\nBINDER_INFO_32_4 DS 0H                                           PF0708\n         MVI   FIXEDSUM,C'Y'           Remember we fixed this    PF0608\n         MVC   CSCLANG(8),12(R9)       Compiler name to SUMMARY  PF0608\n         MVC   CSCCOMP,02(R9)          PID, compname to SUMMARY  PF0608\n*                                      Compiler date to SUMMARY  PF0608\n         STRING64 (IDL_DATE_PROCESSED,4),'.',                    PF0608X\n               (IDL_DATE_PROCESSED+4,3),INTO=CSCDATE             PF0608\n         BRAS  R14,ADJUST_COUNTS       Adjust language counts    PF0608\n*>---------------------------------------------------------------HP1107\nBINDER_INFO_32_5 DS 0H                                           PF0708\n         BRAS  R14,SPACE1          <== next line\n*        CLI   IDL_ENTRY+28,X'00'  Don't check here for more     PF0608\n*        JE    BINDER_INFO_33      entries, will process all     PF0608\n         J     BINDER_INFO_34    Go check for more entries       PF0608\nBINDER_INFO_32_6 DS 0H           Here for 2nd etc. IDRL entries  PF0708\n         STRING64 11X,' B_IDRL ',                                PF0608X\n               (IDL_DATE_PROCESSED,4),'.',                       PF0608X\n               (IDL_DATE_PROCESSED+4,3),1X,(IDL_PID_ID,10),      PF0608X\n               ' V',IDL_VERSION,                                 PF0608X\n               ' M',IDL_MOD_LEVEL,INTO=RECORD                    PF0608\n         BRAS  R14,SPACE1          <== next line                 RS1007\nBINDER_INFO_33 DS 0H                                             RS1007\n*        STM   R14,R3,SNAPREGS         save registers            RS1007\n*        STRING64 '0-3 ',(SNAPREGS+08,4,X),1X,(SNAPREGS+12,4,X),       X\n               1X,(SNAPREGS+16,4,X),1X,(SNAPREGS+20,4,X),              X\n               '  4-7 ',((R4),,X),1X,((R5),,X),                        X\n               1X,((R6),,X),1X,((R7),,X),INTO=RECORD             RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 '8-B ',((R8),,X),1X,((R9),,X),1X,((R10),,X),         X\n               1X,((R11),,X),'  C-F ',((R12),,X),1X,((R13),,X),        X\n               1X,(SNAPREGS+00,4,X),1X,(SNAPREGS+04,4,X),INTO=RECORD\n*        BRAS  R14,SPACE2          <== next line                 RS1007\n*        STRING64 4X,((R5),4,X),1X,(4(R5),4,X),1X,(8(R5),4,X),1X,      X\n               (12(R5),4,X),3X,((R5),16),                              X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(16(R5),4,X),1X,(20(R5),4,X),1X,(24(R5),4,X),1X,  X\n               (28(R5),4,X),3X,(16(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(32(R5),4,X),1X,(36(R5),4,X),1X,(40(R5),4,X),1X,  X\n               (44(R5),4,X),3X,(32(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(48(R5),4,X),1X,(52(R5),4,X),1X,(56(R5),4,X),1X,  X\n               (60(R5),4,X),3X,(48(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(64(R5),4,X),1X,(68(R5),4,X),1X,(72(R5),4,X),1X,  X\n               (76(R5),4,X),3X,(64(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(80(R5),4,X),1X,(84(R5),4,X),1X,(88(R5),4,X),1X,  X\n               (92(R5),4,X),3X,(80(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(96(R5),4,X),1X,(100(R5),4,X),1X,(104(R5),4,X),1X,X\n               (108(R5),4,X),3X,(96(R5),16),                           X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(112(R5),4,X),1X,(114(R5),4,X),1X,(116(R5),4,X),1X,\n               (122(R5),4,X),3X,(112(R5),16),                          X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE2          <== next line                 RS1007\nBINDER_INFO_34 DS 0H                                             RS1007\n         LTR   R10,R10              Only one entry?              RS1007\n         JZ    BINDER_INFO_40     yes, leave                     RS1007\n         A     R5,IDLH_ENTRY_LENG   Move to next section name    RS1007\n         BRCT  R10,BINDER_INFO_32_6 Just print info for 2nd etc. PF0708\n*endloop\nBINDER_INFO_40 DS 0H\n         MVC   IEW_CURSORD,=F'0'      Clear Cursor               RS1007\n         L     R4,IEW_ESDI_PTR                                   RS1007\n         USING IEWBESD,R4                                        RS1007\n*        IEWBUFF FUNC=INITBUF,TYPE=ESD     Init the buffer       RS1007\n         MVC   IEWBESD(ESDH_LENG),ESDI_INIT_VALUES               RS1007\n         MVC   IEWBIND_FUNCTION,=CL8'GETD-ESD'                   RS1007\n         LA    R5,ESDH_END                                       RS1007\n         USING ESD_ENTRY,R5                                      RS1007\n         IEWBIND FUNC=GETD,                                            X\n               RETCODE=IRETCODE,                                       X\n               RSNCODE=RSNCODE,                                        X\n               WORKMOD=IEW_WKTOKEN,                                    X\n               CLASS=IEW_ESD,                                          X\n               SECTION=IEW_SECTION,                                    X\n               AREA=IEWBESD,                                           X\n               CURSOR=IEW_CURSORD,                                     X\n               COUNT=IEW_COUNTD,                                       X\n               VERSION=4,                                              X\n               MF=(E,IEWBIND)                                    RS1007\n*        STRING64 '   GETD: ESD ',(IRETCODE,,X),' RSN: ',(RSNCODE,,X), X\n               'COUNT: ',(IEW_COUNTD,,X),' Token: ',(IEW_WKTOKEN,,X),  X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1                                        RS1007\n         CLC   RSNCODE,=F'0'      Check reason code              RS1007\n         JE    BINDER_INFO_41     continue if zero               RS1007\n*        CLC   IRETCODE,=F'4'     Do we have all the names       RS1007\n*        JH    BINDER_ERROR       Any higher is an error         RS1007\nBINDER_INFO_41 DS 0H                                             RS1007\n*                                                                RS1007\n*        Should be activated only in case of problems            RS1007\n*        STRING64 4X,((R4),4,X),1X,(4(R4),4,X),1X,(8(R4),4,X),1X,      X\n               (12(R4),4,X),3X,((R4),16),                              X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(16(R4),4,X),1X,(20(R4),4,X),1X,(24(R4),4,X),1X,  X\n               (28(R4),4,X),3X,(16(R4),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE2          <== next line                 RS1007\n         L     R10,IEW_COUNTD            Number of sections      RS1007\n         LTR   R10,R10                                           RS1007\n         JZ    BINDER_INFO_50                                    RS1007\n         BCTR  R10,0                     -1                      RS1007\n         USING ESD_ENTRY,R5                                      RS1007\nBINDER_INFO_42 DS 0H                                             RS1007\n         MVC   ESDNAME,BLANKS       Initialize ESD name          PF0608\n         LH    R8,IEW_SECTION_LEN   Length of ESD name           PF0608\n         STRING64 (IEW_SECTION_DATA,(R8),),INTO=ESDNAME          PF0608\n         CLC   ESD_TYPE,=C'SD'      Control section?             PF0608\n         JNE   BINDER_INFO_42_AMX   No, go check for Element Def PF0608\n         CLC   CSCAM,BLANKS         Already have AMODE?          PF0608\n         JNE   BINDER_INFO_42_AMX   Yes, go check for Element DefPF0608\n         CLI   FIXEDSUM,C'Y'        Fixed SUMMARY line?          PF0608\n         JE    BINDER_INFO_42_AM0   Yes, go get AMODE            PF0608\n         CLC   =CL9'Unknown',CSCLANG Is language UNKNOWN?        PF0608\n         JNE   BINDER_INFO_43       No, done with this element   PF0608\nBINDER_INFO_42_AM0 DS 0H                                         PF0608\n         CLC   PGMNAME_GET,ESDNAME  ESD name = LOAD name?        PF0608\n         JNE   BINDER_INFO_43       No, leave SUMMARY alone      PF0608\n         STRING64 '???',INTO=CSCAM  Start with unknown value     PF0608\n         CLI   ESD_AMODE,X'00'      Unspecified?                 PF0608\n         JNE   BINDER_INFO_42_AM1   No, keep checking            PF0608\nBINDER_INFO_42_AM1 DS 0H                                         PF0608\n         CLI   ESD_AMODE,X'01'      24-bit?                      PF0608\n         JNE   BINDER_INFO_42_AM2   No, keep checking            PF0608\n         STRING64 '24 ',INTO=CSCAM  Set 24-bit in SUMMARY        PF0608\n         J     BINDER_INFO_43       Done with this element       PF0608\nBINDER_INFO_42_AM2 DS 0H                                         PF0608\n         CLI   ESD_AMODE,X'02'      31-bit?                      PF0608\n         JNE   BINDER_INFO_42_AM3   No, keep checking            PF0608\n         STRING64 '31 ',INTO=CSCAM  Set 31-bit in SUMMARY        PF0608\n         J     BINDER_INFO_43       Done with this element       PF0608\nBINDER_INFO_42_AM3 DS 0H                                         PF0608\n         CLI   ESD_AMODE,X'03'      ANY?                         PF0608\n         JNE   BINDER_INFO_42_AM4   No, keep checking            PF0608\n         STRING64 'ANY',INTO=CSCAM  Set ANY in SUMMARY           PF0608\n         J     BINDER_INFO_43       Done with this element       PF0608\nBINDER_INFO_42_AM4 DS 0H                                         PF0608\n         CLI   ESD_AMODE,X'06'      64-bit?                      PF0608\n         JNE   BINDER_INFO_42_AMX   No, keep checking            PF0608\n         STRING64 '64 ',INTO=CSCAM  Set 64-bit in SUMMARY        PF0608\n         J     BINDER_INFO_43       Done with this element       PF0608\nBINDER_INFO_42_AMX DS 0H                                         PF0608\n         CLC   ESD_TYPE,=C'ED'      Element Defnintion?          PF0608\n         JNE   BINDER_INFO_42_CSX   No, go check for Label Def   PF0608\n         CLC   CSCRMODE,BLANKS      Already set RMODE?           PF0608\n         JNE   BINDER_INFO_42_RMX   Yes, done with RMODE analysisPF0608\n         CLI   FIXEDSUM,C'Y'        Fixed SUMMARY line?          PF0608\n         JE    BINDER_INFO_42_RMX   Yes, go get RMODE            PF0608\n         CLC   =CL9'Unknown',CSCLANG Is language UNKNOWN?        PF0608\n         JNE   BINDER_INFO_42_RMX   No, done with RMODE analysis PF0608\n         CLC   PGMNAME_GET,WORK        Section name = LOAD name? PF0608\n         JE    BINDER_INFO_42_RM1      Yes, go get RMODE         PF0608\n         CLC   OFF_PGMNAME,ESD_CLASS_OFFSET At EP offset?        PF0608\n         JNE   BINDER_INFO_42_RMX   No, done with RMODE analysis PF0608\nBINDER_INFO_42_RM1 DS 0H                                         PF0608\n         STRING64 '???',INTO=CSCRMODE Start with unknown value   PF0608\n         CLI   ESD_RMODE,X'00'      Unspecified?                 PF0608\n         JE    BINDER_INFO_42_RMX   Yes, done with RMODE analysisPF0608\n         CLI   ESD_RMODE,X'01'      24-bit?                      PF0608\n         JNE   BINDER_INFO_42_RM2   No, keep checking            PF0608\n         STRING64 '24 ',INTO=CSCRMODE Set 24-bit in SUMMARY      PF0608\n         J     BINDER_INFO_42_RMX   Done with RMODE analysis     PF0608\nBINDER_INFO_42_RM2 DS 0H                                         PF0608\n         CLI   ESD_RMODE,X'03'      ANY?                         PF0608\n         JNE   BINDER_INFO_42_RMX   No, done with RMODE analysis PF0608\n         STRING64 'ANY',INTO=CSCRMODE Set ANY in SUMMARY         PF0608\nBINDER_INFO_42_RMX DS 0H                                         PF0608\n         CLC   PGMNAME_GET,ESDNAME  ESD name = LOAD name?        RS0316\n         JE    BINDER_INFO_42_RMX1  Yes, go set RMODE            RS0316\n         CLI   SETRMODE,C'Y'        Set RMODE done?              RS0316\n         JE    BINDER_INFO_42_RMY   Yes, no need to fix it twice RS0316\nBINDER_INFO_42_RMX1 DS 0H                                        RS0316\n         MVI   SETRMODE,C'Y'        Fixed SUMMARY line?          RS0316\n         MVC   BLDL_FF,=H'1'         number of entries           RS0516\n         MVC   BLDL_LL,=H'74'        lenght of entry             RS0516\n         MVC   BLDL_NAME,PGMNAME_GET name                        RS0516\n         BLDL  LOADL,BLDLLIST,NOCONNECT                          RS0516\n*        LA    R9,BLDLLIST\n*        STRING64 4X,((R9),4,X),1X,(4(R9),4,X),1X,(8(R9),4,X),1X,      X\n               (12(R9),4,X),3X,((R9),16),                              X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 4X,(16(R9),4,X),1X,(20(R9),4,X),1X,(24(R9),4,X),1X,  X\n               (28(R9),4,X),3X,(16(R9),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 4X,(32(R9),4,X),1X,(36(R9),4,X),1X,(40(R9),4,X),1X,  X\n               (44(R9),4,X),3X,(32(R9),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line\n         STRING64 '24',INTO=CSCRM    Start with RMODE 24         RS0516\n         TM    DIRATTR3,DIRRMANY    RMODE ANY specified          RS0516\n         JNO   BINDER_INFO_42_RMY   Yes, done with RMODE analysisRS0516\n         STRING64 'ANY',INTO=CSCRM    Set ANY in SUMMARY         RS0516\nBINDER_INFO_42_RMY DS 0H                                         RS0516\n         CLI   FIXEDSUM,C'Y'        Fixed SUMMARY line?          PF0608\n         JE    BINDER_INFO_42_UNX   Yes, no need to fix it twice PF0608\n         CLC   =CL9'Unknown',CSCLANG   Is main still unknown?    PF0608\n         JNE   BINDER_INFO_42_UNX      No, leave SUMMARY alone   PF0608\n         CLC   PGMNAME_GET,WORK        Section name = LOAD name? PF0608\n         JE    BINDER_INFO_42_UN2      Yes, go fix SUMMARY       PF0608\n         CLC   OFF_PGMNAME,ESD_CLASS_OFFSET At EP offset?        PF0608\n         JL    BINDER_INFO_42_UNX      EP earlier, so done now   PF0608\n         JH    BINDER_INFO_42_UN1      Might be here, go check   PF0608\n* OK, this ESD is the entry point of the load module             PF0608\n         CLC   =CL8'MAIN',ESDNAME   ESD name = MAIN = FORTRAN?   PF0608\n         JNE   BINDER_INFO_42_UN2   No, go fix SUMMARY           PF0608\n* Not only EP, probably FORTRAN of some kind so set up PID Entry PF0608\n         L     R9,ADR_PIDENTRY      Check if PID is Unknown      PF0708\n         CLI   0(R9),0              Unknown entry is zeroes      PF0708\n         JNE   BINDER_INFO_42_UN2   Not unknown, leave it alone  PF0708\n         LARL  R9,PID_ENTRY_UNKFORT Get a(Unknown FORTRAN entry) PF0608\n         ST    R9,ADR_PIDENTRY      Save A(PID Table entry)      PF0608\n         J     BINDER_INFO_42_UN2      Now go fix SUMMARY        PF0708\nBINDER_INFO_42_UN1 DS 0H                                         PF0608\n         L     R15,ESD_LENG         Compute ESD end offset       PF0608\n         A     R15,ESD_CLASS_OFFSET                              PF0608\n         C     R15,OFF_PGMNAME      Is end offset > Entry Offset?PF0608\n         JNH   BINDER_INFO_42_UNX   No, Entry Pt. not here       PF0608\nBINDER_INFO_42_UN2 DS 0H                                         PF0608\n         MVI   FIXEDSUM,C'Y'           Remember we fixed this    PF0608\n         L     R9,ADR_PIDENTRY         Get A(PID Table entry)    PF0608\n         MVC   CSCLANG(8),12(R9)       Compiler name to SUMMARY  PF0608\n         MVC   CSCCOMP,02(R9)          PID, compname to SUMMARY  PF0608\n*                                      Compiler date to SUMMARY  PF0608\n         STRING64 (SUM_DATE_SAVE,4),'.',                         PF0608X\n               (SUM_DATE_SAVE+4,3),INTO=CSCDATE                  PF0608\n         STRING64 'EP=',(OFF_PGMNAME,4,X),',NAME=',ESDNAME,      PF0608X\n               INTO=CSCLPRM                                      PF0608\n         BRAS  R14,ADJUST_COUNTS       Adjust language counts    PF0608\nBINDER_INFO_42_UNX DS 0H                                         PF0608\n         STRING64 11X,' B_ESD  ',9X,                                   X\n               'Length: ',(ESD_LENG,4,X),' Offset: ',                  X\n               (ESD_CLASS_OFFSET,4,X),' PGM','Offset: ',               X\n               (OFF_PGMNAME,4,X),INTO=RECORD\n         BRAS  R14,SPACE1          <== next line                 RS1007\n*>---------------------------------------------------------------HP1107\n*>- check & save cobol-csect-info                               -HP1107\n*>---------------------------------------------------------------HP1107\n         st    R3,saveR3                                         HP1107\n         st    R4,saveR4                                         HP1107\n         CLC   IEW_SECTION_DATA(8),=CL8'IGZESTUB' ignore         PF0608\n         jE    BINDER_INFO_42_0        no, skip                  RS1107\n         DEVTYPE =CL8'MAINONLY',DOUBLE  Get MAINONLY DD          RS0108\n         LTR   R15,R15                    Is it allocated?       RS0108\n         JZ    BINDER_INFO_42_0           Yes, leave             RS0108\n         CLC   WORK(8),PGMNAME_SAV  Section = load?              RS1107\n         jE    BINDER_INFO_42_0        no, skip                  RS1107\n         cli   csect_act_kz,C'C'             cobol ?             HP1107\n         jne   BINDER_INFO_42_0              no, skip            HP1107\n         lh    R3,csect_anz_tabelem                              HP1107\n         la    r3,1(r3)                                          HP1107\n         ch    r3,=h'50'                     table full ?        HP1107\n         jh    BINDER_INFO_42_0              yes, skip           HP1107\n*******\n         l     R4,ESD_CLASS_OFFSET  csect-offset                 HP1107\n         xr    r1,r1                                             HP1107\n         l     r1,CSV_LOADPT        load-point  lmod             HP1107\n         ar    r4,r1                csect-postion in lmod        HP1107\n         st    r4,csect_anf         csect-postion in lmod        HP1107\n         mvc   hadr,ADR_PGMNAME     ep                           HP1107\n         cli   hadr,x'00'                                        HP1107\n         je    BINDER_INFO_42_0a\n         xi    hadr,x'80'                                        HP1107\nBINDER_INFO_42_0a     DS 0H                                      HP1107\n         l     r1,hadr              ep                           HP1107\n         cr    r4,r1                                             HP1107\n         je    BINDER_INFO_42_0     main-csect  |                HP1107\n*******\n         sth   R3,csect_anz_tabelem                              HP1107\n         l     R3,csect_tabelem_act                              HP1107\n         mvc   0(2,r3),csect_act_kz          save that           HP1107\n         mvc   2(4,r3),ESD_CLASS_OFFSET                          HP1107\n         mvc   6(4,r3),ESD_LENG                                  HP1107\n         la    R3,10(r3)                     next table entry    HP1107\n         st    R3,csect_tabelem_act                              HP1107\n         MVI   csect_analyze_kz,C'S'                             HP1107\nBINDER_INFO_42_0      DS 0H                                      HP1107\n         l     R3,saveR3                                         HP1107\n         l     R4,saveR4                                         HP1107\n*>---------------------------------------------------------------HP1107\n*        STM   R14,R3,SNAPREGS         save registers            RS1007\n*        STRING64 '0-3 ',(SNAPREGS+08,4,X),1X,(SNAPREGS+12,4,X),       X\n               1X,(SNAPREGS+16,4,X),1X,(SNAPREGS+20,4,X),              X\n               '  4-7 ',((R4),,X),1X,((R5),,X),                        X\n               1X,((R6),,X),1X,((R7),,X),INTO=RECORD             RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 '8-B ',((R8),,X),1X,((R9),,X),1X,((R10),,X),         X\n               1X,((R11),,X),'  C-F ',((R12),,X),1X,((R13),,X),        X\n               1X,(SNAPREGS+00,4,X),1X,(SNAPREGS+04,4,X),INTO=RECORD\n*        BRAS  R14,SPACE2          <== next line                 RS1007\n*        LM    R14,R3,SNAPREGS         save registers            RS1007\n*        STRING64 4X,((R5),4,X),1X,(4(R5),4,X),1X,(8(R5),4,X),1X,      X\n               (12(R5),4,X),3X,((R5),16),                              X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(16(R5),4,X),1X,(20(R5),4,X),1X,(24(R5),4,X),1X,  X\n               (28(R5),4,X),3X,(16(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(32(R5),4,X),1X,(36(R5),4,X),1X,(40(R5),4,X),1X,  X\n               (44(R5),4,X),3X,(32(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(48(R5),4,X),1X,(52(R5),4,X),1X,(56(R5),4,X),1X,  X\n               (60(R5),4,X),3X,(48(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(64(R5),4,X),1X,(68(R5),4,X),1X,(72(R5),4,X),1X,  X\n               (76(R5),4,X),3X,(64(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(80(R5),4,X),1X,(84(R5),4,X),1X,(88(R5),4,X),1X,  X\n               (92(R5),4,X),3X,(80(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(96(R5),4,X),1X,(100(R5),4,X),1X,(104(R5),4,X),1X,X\n               (108(R5),4,X),3X,(96(R5),16),                           X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(112(R5),4,X),1X,(114(R5),4,X),1X,(116(R5),4,X),1X,\n               (122(R5),4,X),3X,(112(R5),16),                          X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE2          <== next line                 RS1007\n*        J     BINDER_INFO_50      Only one ESD_TYPE = ED !!!!   PF0608\n         J     BINDER_INFO_43      No, now also process SD, LD   PF0608\nBINDER_INFO_42_CSX DS 0H                                         PF0608\n         CLC   ESD_TYPE,=C'LD'      Label Definition?            PF0608\n         JNE   BINDER_INFO_43       No, done with this element   PF0608\n         CLI   FIXEDSUM,C'Y'        Fixed SUMMARY line?          PF0608\n         JNE   BINDER_INFO_43       No, done with this element   PF0608\n         CLC   OFF_PGMNAME,ESD_CLASS_OFFSET At EP offset?        PF0608\n         JNE   BINDER_INFO_43       No, done with this element   PF0608\n* OK, this LD is the entry point of the UNKNOWN load module      PF0608\n         LH    R8,ESD_NAME_CHARS    Length of LD name            PF0608\n         L     R2,ESD_NAME_PTR      Name pointer                 PF0608\n         STRING64 'EP=',(OFF_PGMNAME,4,X),',NAME=',              PF0608X\n               (0(R2),(R8),),INTO=CSCLPRM                        PF0608\n*        J     BINDER_INFO_43       Now done with this element   PF0608\nBINDER_INFO_43 DS 0H                                             RS1007\n         LTR   R10,R10              Only one entry?              RS1007\n         JZ    BINDER_INFO_50     yes, leave                     RS1007\n         A     R5,ESDH_ENTRY_LENG   Move to next section name    RS1007\n         BRCT  R10,BINDER_INFO_42                                RS1007\n*endloop                                                         RS1007\nBINDER_INFO_50 DS 0H                                             RS1007\n         MVC   IEW_CURSORD,=F'0'      Clear Cursor               RS1007\n         L     R4,IEW_IDUI_PTR                                   RS1007\n         USING IEWBIDU,R4                                        RS1007\n*        IEWBUFF FUNC=INITBUF,TYPE=IDU     Init the buffer       RS1007\n         MVC   IEWBIDU(IDUH_LENG),IDUI_INIT_VALUES               RS1007\n         MVC   IEWBIND_FUNCTION,=CL8'GETD-IDU'                   RS1007\n         LA    R5,IDUH_END                                       RS1007\n         USING ESD_ENTRY,R5                                      RS1007\n         IEWBIND FUNC=GETD,                                            X\n               RETCODE=IRETCODE,                                       X\n               RSNCODE=RSNCODE,                                        X\n               WORKMOD=IEW_WKTOKEN,                                    X\n               CLASS=IEW_IDU,                                          X\n               SECTION=IEW_SECTION,                                    X\n               AREA=IEWBIDU,                                           X\n               CURSOR=IEW_CURSORD,                                     X\n               COUNT=IEW_COUNTD,                                       X\n               VERSION=4,                                              X\n               MF=(E,IEWBIND)                                    RS1007\n*        STRING64 '   GETD: IDU ',(IRETCODE,,X),' RSN: ',(RSNCODE,,X), X\n               'COUNT: ',(IEW_COUNTD,,X),' Token: ',(IEW_WKTOKEN,,X),  X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1                                        RS1007\n         CLC   RSNCODE,=F'0'      Check reason code              RS1007\n         JE    BINDER_INFO_51     continue if zero               RS1007\n*        CLC   IRETCODE,=F'4'     Do we have all the names       RS1007\n*        JH    BINDER_ERROR       Any higher is an error         RS1007\nBINDER_INFO_51 DS 0H                                             RS1007\n*        Should be activated only in case of problems            RS1007\n*        STRING64 4X,((R4),4,X),1X,(4(R4),4,X),1X,(8(R4),4,X),1X,      X\n               (12(R4),4,X),3X,((R4),16),                              X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(16(R4),4,X),1X,(20(R4),4,X),1X,(24(R4),4,X),1X,  X\n               (28(R4),4,X),3X,(16(R4),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE2          <== next line                 RS1007\n         L     R10,IEW_COUNTD            Number of sections      RS1007\n         LTR   R10,R10                                           RS1007\n         JZ    BINDER_INFO_60                                    RS1007\n         BCTR  R10,0                     -1                      RS1007\n         USING IDU_ENTRY,R5                                      RS1007\nBINDER_INFO_52 DS 0H                                             RS1007\n         LH    R0,IDU_DATA_CHARS                                 RS1007\n*        STRING64 11X,'B_IDRU ',                                       X\n               (IDU_CREATE_DATE,4),'.',(IDU_CREATE_DATE+4,3),          X\n               1X,(IDU_DATA,(R0),),INTO=RECORD                   RS1007\n         STRING64 11X,' B_IDRU ',                                      X\n               (IDU_CREATE_DATE,4),'.',(IDU_CREATE_DATE+4,3),          X\n               1X,(IDU_DATA,(R0),),INTO=RECORD                   RS1007\n         BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 2X,((R3),(R2),),1X,IDL_PID_ID,1X,'V',IDL_VERSION,    X\n               ' M',IDL_MOD_LEVEL,1X,(IDL_DATE_PROCESSED,4),'.',       X\n               (IDL_DATE_PROCESSED+4,,3),INTO=RECORD             RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STM   R14,R3,SNAPREGS         save registers            RS1007\n*        STRING64 '0-3 ',(SNAPREGS+08,4,X),1X,(SNAPREGS+12,4,X),       X\n               1X,(SNAPREGS+16,4,X),1X,(SNAPREGS+20,4,X),              X\n               '  4-7 ',((R4),,X),1X,((R5),,X),                        X\n               1X,((R6),,X),1X,((R7),,X),INTO=RECORD             RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 '8-B ',((R8),,X),1X,((R9),,X),1X,((R10),,X),         X\n               1X,((R11),,X),'  C-F ',((R12),,X),1X,((R13),,X),        X\n               1X,(SNAPREGS+00,4,X),1X,(SNAPREGS+04,4,X),INTO=RECORD\n*        BRAS  R14,SPACE2          <== next line                 RS1007\n*        LM    R14,R3,SNAPREGS         save registers            RS1007\n*        STRING64 4X,((R5),4,X),1X,(4(R5),4,X),1X,(8(R5),4,X),1X,      X\n               (12(R5),4,X),3X,((R5),16),                              X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(16(R5),4,X),1X,(20(R5),4,X),1X,(24(R5),4,X),1X,  X\n               (28(R5),4,X),3X,(16(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(32(R5),4,X),1X,(36(R5),4,X),1X,(40(R5),4,X),1X,  X\n               (44(R5),4,X),3X,(32(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(48(R5),4,X),1X,(52(R5),4,X),1X,(56(R5),4,X),1X,  X\n               (60(R5),4,X),3X,(48(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(64(R5),4,X),1X,(68(R5),4,X),1X,(72(R5),4,X),1X,  X\n               (76(R5),4,X),3X,(64(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(80(R5),4,X),1X,(84(R5),4,X),1X,(88(R5),4,X),1X,  X\n               (92(R5),4,X),3X,(80(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(96(R5),4,X),1X,(100(R5),4,X),1X,(104(R5),4,X),1X,X\n               (108(R5),4,X),3X,(96(R5),16),                           X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(112(R5),4,X),1X,(114(R5),4,X),1X,(116(R5),4,X),1X,\n               (122(R5),4,X),3X,(112(R5),16),                          X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE2          <== next line                 RS1007\nBINDER_INFO_53 DS 0H                                             RS1007\n         LTR   R10,R10              Only one entry?              RS1007\n         JZ    BINDER_INFO_60     yes, leave                     RS1007\n         A     R5,IDUH_ENTRY_LENG   Move to next section name    RS1007\n         BRCT  R10,BINDER_INFO_52                                RS1007\n*endloop                                                         RS1007\nBINDER_INFO_60 DS 0H                                             RS1007\n         MVC   IEW_CURSORD,=F'0'      Clear Cursor               RS1007\n         L     R4,IEW_IDZI_PTR                                   RS1007\n         USING IEWBIDZ,R4                                        RS1007\n*        IEWBUFF FUNC=INITBUF,TYPE=IDL     Init the buffer       RS1007\n         MVC   IEWBIDZ(IDZH_LENG),IDZI_INIT_VALUES               RS1007\n         MVC   IEWBIND_FUNCTION,=CL8'GETD-IDZ'                   RS1007\n         LA    R5,IDZH_END                                       RS1007\n         USING IDZ_ENTRY,R5                                      RS1007\n         IEWBIND FUNC=GETD,                                            X\n               RETCODE=IRETCODE,                                       X\n               RSNCODE=RSNCODE,                                        X\n               WORKMOD=IEW_WKTOKEN,                                    X\n               CLASS=IEW_IDZ,                                          X\n               SECTION=IEW_SECTION,                                    X\n               AREA=IEWBIDZ,                                           X\n               CURSOR=IEW_CURSORD,                                     X\n               COUNT=IEW_COUNTD,                                       X\n               VERSION=4,                                              X\n               MF=(E,IEWBIND)                                    RS1007\n*        STRING64 '   GETD: IDZ ',(IRETCODE,,X),' RSN: ',(RSNCODE,,X), X\n               'COUNT: ',(IEW_COUNTD,,X),' Token: ',(IEW_WKTOKEN,,X),  X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1                                        RS1007\n         CLC   RSNCODE,=F'0'      Check reason code              RS1007\n         JE    BINDER_INFO_61     continue if zero               RS1007\n*        CLC   IRETCODE,=F'4'     Do we have all the names       RS1007\n*        JH    BINDER_ERROR       Any higher is an error         RS1007\nBINDER_INFO_61 DS 0H                                             RS1007\n*        Should be activated only in case of problems            RS1007\n*        STRING64 4X,((R4),4,X),1X,(4(R4),4,X),1X,(8(R4),4,X),1X,      X\n               (12(R4),4,X),3X,((R4),16),                              X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(16(R4),4,X),1X,(20(R4),4,X),1X,(24(R4),4,X),1X,  X\n               (28(R4),4,X),3X,(16(R4),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE2          <== next line                 RS1007\n         L     R10,IEW_COUNTD            Number of sections      RS1007\n         LTR   R10,R10                                           RS1007\n         JZ    BINDER_INFO_70                                    RS1007\n         BCTR  R10,0                     -1                      RS1007\n         USING IDZ_ENTRY,R5                                      RS1007\nBINDER_INFO_62 DS 0H                                             RS1007\n*        STRING64 11X,' B_IDRZ ',(IDZ_DATE,4),'.',(IDZ_DATE+4,3),      X\n               1X,(IDZ_ZAP_DATA,8),INTO=RECORD                   RS1007\n         STRING64 21X,' B_IDRZ ',                                      X\n               (IDZ_DATE,4),'.',(IDZ_DATE+4,3),                        X\n               1X,(IDZ_ZAP_DATA,8),INTO=RECORD                   RS1007\n         BRAS  R14,SPACE1          <== next line                 RS1007\n*        STM   R14,R3,SNAPREGS         save registers            RS1007\n*        STRING64 '0-3 ',(SNAPREGS+08,4,X),1X,(SNAPREGS+12,4,X),       X\n               1X,(SNAPREGS+16,4,X),1X,(SNAPREGS+20,4,X),              X\n               '  4-7 ',((R4),,X),1X,((R5),,X),                        X\n               1X,((R6),,X),1X,((R7),,X),INTO=RECORD             RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 '8-B ',((R8),,X),1X,((R9),,X),1X,((R10),,X),         X\n               1X,((R11),,X),'  C-F ',((R12),,X),1X,((R13),,X),        X\n               1X,(SNAPREGS+00,4,X),1X,(SNAPREGS+04,4,X),INTO=RECORD\n*        BRAS  R14,SPACE2          <== next line                 RS1007\n*        LM    R14,R3,SNAPREGS         save registers            RS1007\n*        STRING64 4X,((R5),4,X),1X,(4(R5),4,X),1X,(8(R5),4,X),1X,      X\n               (12(R5),4,X),3X,((R5),16),                              X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(16(R5),4,X),1X,(20(R5),4,X),1X,(24(R5),4,X),1X,  X\n               (28(R5),4,X),3X,(16(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(32(R5),4,X),1X,(36(R5),4,X),1X,(40(R5),4,X),1X,  X\n               (44(R5),4,X),3X,(32(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(48(R5),4,X),1X,(52(R5),4,X),1X,(56(R5),4,X),1X,  X\n               (60(R5),4,X),3X,(48(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(64(R5),4,X),1X,(68(R5),4,X),1X,(72(R5),4,X),1X,  X\n               (76(R5),4,X),3X,(64(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(80(R5),4,X),1X,(84(R5),4,X),1X,(88(R5),4,X),1X,  X\n               (92(R5),4,X),3X,(80(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(96(R5),4,X),1X,(100(R5),4,X),1X,(104(R5),4,X),1X,X\n               (108(R5),4,X),3X,(96(R5),16),                           X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(112(R5),4,X),1X,(114(R5),4,X),1X,(116(R5),4,X),1X,\n               (122(R5),4,X),3X,(112(R5),16),                          X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE2          <== next line                 RS1007\nBINDER_INFO_63 DS 0H                                             RS1007\n         LTR   R10,R10              Only one entry?              RS1007\n         JZ    BINDER_INFO_70     yes, leave                     RS1007\n         A     R5,IDZH_ENTRY_LENG   Move to next section name    RS1007\n         BRCT  R10,BINDER_INFO_62                                RS1007\n*endloop                                                         RS1007\nBINDER_INFO_70 DS 0H                                             RS1007\n         MVC   IEW_CURSORD,=F'0'      Clear Cursor               RS1007\n         L     R4,IEW_IDBI_PTR                                   RS1007\n         USING IEWBIDB,R4                                        RS1007\n*        IEWBUFF FUNC=INITBUF,TYPE=IDB     Init the buffer       RS1007\n         MVC   IEWBIDB(IDBH_LENG),IDBI_INIT_VALUES               RS1007\n         MVC   IEWBIND_FUNCTION,=CL8'GETD-IDB'                   RS1007\n         LA    R5,IDBH_END                                       RS1007\n         USING IDB_ENTRY,R5                                      RS1007\n         IEWBIND FUNC=GETD,                                            X\n               RETCODE=IRETCODE,                                       X\n               RSNCODE=RSNCODE,                                        X\n               WORKMOD=IEW_WKTOKEN,                                    X\n               CLASS=IEW_IDB,                                          X\n               SECTION=IEW_SECTION,                                    X\n               AREA=IEWBIDB,                                           X\n               CURSOR=IEW_CURSORD,                                     X\n               COUNT=IEW_COUNTD,                                       X\n               VERSION=4,                                              X\n               MF=(E,IEWBIND)                                    RS1007\n*        STRING64 '   GETD: IDB ',(IRETCODE,,X),' RSN: ',(RSNCODE,,X), X\n               'COUNT: ',(IEW_COUNTD,,X),' Token: ',(IEW_WKTOKEN,,X),  X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1                                        RS1007\n         CLC   RSNCODE,=F'0'      Check reason code              RS1007\n         JE    BINDER_INFO_71     continue if zero               RS1007\n*        CLC   IRETCODE,=F'4'     Do we have all the names       RS1007\n*        JH    BINDER_ERROR       Any higher is an error         RS1007\nBINDER_INFO_71 DS 0H                                             RS1007\n*        Should be activated only in case of problems            RS1007\n*        STRING64 4X,((R4),4,X),1X,(4(R4),4,X),1X,(8(R4),4,X),1X,      X\n               (12(R4),4,X),3X,((R4),16),                              X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(16(R4),4,X),1X,(20(R4),4,X),1X,(24(R4),4,X),1X,  X\n               (28(R4),4,X),3X,(16(R4),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE2          <== next line                 RS1007\n         L     R10,IEW_COUNTD            Number of sections      RS1007\n         LTR   R10,R10                                           RS1007\n         JZ    BINDER_INFO_80                                    RS1007\n         BCTR  R10,0                     -1                      RS1007\n         USING IDB_ENTRY,R5                                      RS1007\n         CLC   SUM_DATE_SAVE,BLANKS    Any date saved yet?       PF0608\n         JNE   BINDER_INFO_72          Yes, don't change it      PF0608\n         MVC   SUM_DATE_SAVE,IDB_DATE_BOUND Save for SUMMARY     PF0608\nBINDER_INFO_72 DS 0H                                             RS1007\n         STRING64 '  Bound   :',' B_IDRB ',                            X\n               (IDB_DATE_BOUND,4),'.',(IDB_DATE_BOUND+4,3),1X,         X\n               (IDB_BINDER_ID,10),' V',(IDB_VERSION,2),' M',           X\n               (IDB_RELEASE,2),INTO=RECORD                       RS1007\n         BRAS  R9,BINDER_INFO_72_1                               RS1007\n*   Most Taken from Dave Alcock                                  RS1007\n         DC    CL10'5695DF108 ',CL16'DFSMS Binder'               RS1007\n         DC    CL10'566528408 ',CL16'DFP LKED'                   RS1007\n         DC    CL10'566529508 ',CL16'DFP LKED'                   RS1007\n         DC    CL10'5752SC104 ',CL16'LKED-F'                     RS1007\n         DC    CL10'04LE960488',CL16'MVSLKED'                    RS1007\n*   Roland                                                       RS1007\n         DC    CL10'5695PMB01 ',CL16'z/OS Binder '               RS1007\n         DC    XL10'0000',CL16'Unknown'             end of table RS1007\nBINDER_INFO_72_1 DS 0H                                           RS1007\n         CLC   IDB_BINDER_ID(10),0(R9)         check             RS1007\n         JE    BINDER_INFO_72_2        jump if on                RS1007\n         LA    R9,26(,R9)              Skip entry                RS1007\n         CLI   0(R9),0                 end of table?             RS1007\n         JNE   BINDER_INFO_72_1        not yet, loop             RS1007\nBINDER_INFO_72_2 DS 0H                                           RS1007\n         MVC   RECORD+47(16),10(R9)    long text for Binder-ID   RS1007\n         BRAS  R14,SPACE2          <== next line                 RS1007\n*        STM   R14,R3,SNAPREGS         save registers            RS1007\n*        STRING64 '0-3 ',(SNAPREGS+08,4,X),1X,(SNAPREGS+12,4,X),       X\n               1X,(SNAPREGS+16,4,X),1X,(SNAPREGS+20,4,X),              X\n               '  4-7 ',((R4),,X),1X,((R5),,X),                        X\n               1X,((R6),,X),1X,((R7),,X),INTO=RECORD             RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 '8-B ',((R8),,X),1X,((R9),,X),1X,((R10),,X),         X\n               1X,((R11),,X),'  C-F ',((R12),,X),1X,((R13),,X),        X\n               1X,(SNAPREGS+00,4,X),1X,(SNAPREGS+04,4,X),INTO=RECORD\n*        BRAS  R14,SPACE2          <== next line                 RS1007\n*        LM    R14,R3,SNAPREGS         save registers            RS1007\n*        STRING64 4X,((R5),4,X),1X,(4(R5),4,X),1X,(8(R5),4,X),1X,      X\n               (12(R5),4,X),3X,((R5),16),                              X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(16(R5),4,X),1X,(20(R5),4,X),1X,(24(R5),4,X),1X,  X\n               (28(R5),4,X),3X,(16(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(32(R5),4,X),1X,(36(R5),4,X),1X,(40(R5),4,X),1X,  X\n               (44(R5),4,X),3X,(32(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(48(R5),4,X),1X,(52(R5),4,X),1X,(56(R5),4,X),1X,  X\n               (60(R5),4,X),3X,(48(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(64(R5),4,X),1X,(68(R5),4,X),1X,(72(R5),4,X),1X,  X\n               (76(R5),4,X),3X,(64(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(80(R5),4,X),1X,(84(R5),4,X),1X,(88(R5),4,X),1X,  X\n               (92(R5),4,X),3X,(80(R5),16),                            X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(96(R5),4,X),1X,(100(R5),4,X),1X,(104(R5),4,X),1X,X\n               (108(R5),4,X),3X,(96(R5),16),                           X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE1          <== next line                 RS1007\n*        STRING64 4X,(112(R5),4,X),1X,(114(R5),4,X),1X,(116(R5),4,X),1X,\n               (122(R5),4,X),3X,(112(R5),16),                          X\n               INTO=RECORD                                       RS1007\n*        BRAS  R14,SPACE2          <== next line                 RS1007\nBINDER_INFO_73 DS 0H                                             RS1007\n         LTR   R10,R10              Only one entry?              RS1007\n         JZ    BINDER_INFO_80     yes, leave                     RS1007\n         A     R5,IDBH_ENTRY_LENG   Move to next section name    RS1007\n         BRCT  R10,BINDER_INFO_72                                RS1007\n*endloop                                                         RS1007\nBINDER_INFO_80 DS 0H                                             RS1007\n         LM    R4,R5,SAVER4_AND_R5                               RS1007\n         USING IEWBBNL,R4                                        RS1007\n         USING BNL_ENTRY,R5                                      RS1007\n         A     R5,BNLH_ENTRY_LENG   Move to next section name\n         BRCT  R12,BINDER_INFO_20\n*endloop                                                         RS1007\n*                                                                 *CSC*\nBINDER_INFO_85 DS 0H                                             RS1007\n         CLC   IEW_WKTOKEN,XFF      Do we have a workmod?        PF0608\n         JE    BINDER_INFO_90       No, bypass DELETEW           PF0608\n         MVC   IEWBIND_FUNCTION,=CL8'DELETEW'                     *CSC*\n         IEWBIND FUNC=DELETEW,                                         X\n               RETCODE=IRETCODE,                                       X\n               RSNCODE=RSNCODE,                                        X\n               WORKMOD=IEW_WKTOKEN,                                    X\n               PROTECT=YES,                                            X\n               VERSION=4,                                              X\n               MF=(E,IEWBIND)\n*        STRING64 'DELETEW: RC: ',(IRETCODE,,X),' RSN: ',(RSNCODE,,X), X\n               INTO=RECORD\n*        BRAS  R14,SPACE1\n         CLI   DOUBLE,C'Y'          Invoked from Binder-Error ?  RS0105\n         JE    BINDER_INFO_90          don't check RC            RS1007\n         CLC   RSNCODE,=F'0'\n         JNE   BINDER_ERROR\nBINDER_INFO_90 DS 0H                                             RS1007\n         CLC   IEW_DTOKEN,XFF       Was a dialog started?        PF0608\n         JE    BINDER_END           No, just exit                PF0608\n         MVC   IEWBIND_FUNCTION,=CL8'ENDD'                        *CSC*\n         IEWBIND FUNC=ENDD,                                            X\n               RETCODE=IRETCODE,                                       X\n               RSNCODE=RSNCODE,                                        X\n               DIALOG=IEW_DTOKEN,                                      X\n               VERSION=4,                                              X\n               MF=(E,IEWBIND)\n*        STRING64 'ENDD   : RC: ',(IRETCODE,,X),' RSN: ',(RSNCODE,,X), X\n               'DTOKEN: ',(IEW_DTOKEN,,X),                             X\n               INTO=RECORD\n*        BRAS  R14,SPACE1\n         CLI   DOUBLE,C'Y'          Invoked from Binder-Error ?  RS0105\n         JE    BINDER_END              don't check RC            RS0105\n         CLC   RSNCODE,=F'0'\n         JNE   BINDER_ERROR\n*        IEWBUFF FUNC=FREEBUF,TYPE=NAME\n         J     BINDER_END\nBINDER_ERROR DS 0H\n         MVI   DOUBLE,C'Y'     Status Binder_Error !!            RS0105\n         STRING64 'IEWBIND: RC: ',(IRETCODE,,X),' RSN: ',(RSNCODE,,X), X\n               ' FUNCTION:',IEWBIND_FUNCTION,                     *CSC*X\n               ' SEC-L:',(IEW_SECTION_LEN,2,X),INTO=RECORD       PF0608\n         BRAS  R14,SPACE1\n         STRING64 'Binder function failed, no further ',         PF0608X\n               'information is available from the binder.',      PF0608X\n               INTO=RECORD                                       PF0608\n         BRAS  R14,SPACE1                                        PF0608\n         J     BINDER_INFO_85       Issue DELETEW to rel storage RS1007\nBINDER_END   DS 0H\n*>---------------------------------------------------------------HP1107\n         CLI   csect_analyze_kz,C'S'  any more csects ?          HP1107\n         jne   BINDER_END_0                                      HP1107\n         BRAS  R14,BLANK1                                        HP1107\n         STRING '------------ Found additional COBOL modules included',X\n               ', will report them later ------------------------',    X\n               INTO=RECORD\n         BRAS  R14,SPACE2                                        HP1107\nBINDER_END_0 DS 0H\n         st    R3,saveR3                                         HP1107\n         la    R3,csect_table       anf of csect-table (cobol)   HP1107\n         st    R3,csect_tabelem_act                              HP1107\n         l     R3,saveR3                                         HP1107\n*>---------------------------------------------------------------HP1107\n         MVI   DOUBLE,C' '     Status Binder_Error !!            RS0105\n         L     R14,BINDSAVE         Restore R14\n         BR    R14            return\n         DROP  R4,R5\n*------------------------------------------------------------*   PF0708\n* Move PGMNAME to IEW_MBR, calculating length in IEW_MBRL    *   PF0708\n*------------------------------------------------------------*   PF0708\n*                                                                PF0708\nPGMNAME_2_MBR  DS 0H                                             PF0708\n         ST    R14,CNT_R14SAVE    Can re-use this save word here PF0708\n* Calculate length of member name first                          PF0708\n         XC    IEW_MBRL,IEW_MBRL  Clear length to zero           PF0708\n         LA    R15,8              Max length is 8                PF0708\n         LA    R14,PGMNAME_GET+L'PGMNAME_GET-1 Point to name end PF0708\nPGMNAME_2_MBR_1 DS 0H             Loop for length                PF0708\n         CLI   0(R14),C' '        Space or not?                  PF0708\n         JNE   PGMNAME_2_MBR_2    Not space, have length         PF0708\n         BCTR  R14,0              Is a space, decrement address  PF0708\n         BRCT  R15,PGMNAME_2_MBR_1 Then decrement length + loop  PF0708\n         J     PGMNAME_2_MBR_X    Zero length, exit              PF0708\nPGMNAME_2_MBR_2 DS 0H             Have name length now           PF0708\n         STH   R15,IEW_MBRL       Store length                   PF0708\n         MVC   IEW_MBRN,PGMNAME_GET Copy the member name         PF0708\nPGMNAME_2_MBR_X DS 0H             Exit here                      PF0708\n         L     R14,CNT_R14SAVE    Restore                        PF0708\n         BR    R14                And return                     PF0708\n*------------------------------------------------------------*   PF0708\n* Create PL/I-style internal name from member name IEW_MBR   *   PF0708\n*------------------------------------------------------------*   PF0708\n*                                                                PF0708\nCREATE_PLINAME DS 0H                                             PF0708\n         ST    R14,CNT_R14SAVE    Can re-use this save word here PF0708\n         MVC   PLINAME_LEN,IEW_MBRL+1 Name length                PF0708\n         MVI   PLINAME,C'*'       Pre-fill name with '*' chars   PF0708\n         MVC   PLINAME+1(L'PLINAME-1),PLINAME                    PF0708\n         LHI   R14,L'PLINAME      Compute where to start name    PF0708\n         LH    R15,IEW_MBRL       How much to move               PF0708\n         CHI   R15,L'PLINAME      But no more than can fit       PF0708\n         JNH   CREATE_PLINAME_1   OK, not more than can fit      PF0708\n         LHI   R15,L'PLINAME      More than can fit, use first   PF0708\nCREATE_PLINAME_1 DS 0H                                           PF0708\n         SR    R14,R15            Finish calculation             PF0708\n         LA    R14,PLINAME(R14)   R14=where to start             PF0708\n         BCTR  R15,0              Length minus one for EXecute   PF0708\n         EX    R15,MOVE_PLINAME   Move to PLINAME                PF0708\n         L     R14,CNT_R14SAVE    Restore                        PF0708\n         BR    R14                And return                     PF0708\n*------------------------------------------------------------*   PF0608\n* Adjust language counts for UNKNOWN load modules            *   PF0608\n*------------------------------------------------------------*   PF0608\n*                                                                PF0608\nADJUST_COUNTS DS 0H                                              PF0608\n         ST    R14,CNT_R14SAVE                                   PF0608\n         CLI   0(R9),C'A'         Assembler?                     PF0608\n         JNE   ADJ_CNT_01_1       No, keep checking              PF0608\n         AP    CNT_ASSEMBLER,=P'1' Yes, add to Assembler count   PF0608\n         J     ADJ_CNT_END        Done                           PF0608\nADJ_CNT_01_1 DS 0H                                               PF0608\n         CLI   1(R9),C'3'         COBOL 1?                       PF0608\n         JNE   ADJ_CNT_01_2       No, keep checking              PF0608\n         AP    CNT_COBOLI,=P'1'   Yes, add to COBOL 1   count    PF0608\n         J     ADJ_CNT_END        Done                           PF0608\nADJ_CNT_01_2 DS 0H                                               PF0608\n         CLI   1(R9),C'2'         COBOL 2?                       PF0608\n         JNE   ADJ_CNT_01_3       No, keep checking              PF0608\n         AP    CNT_COBOL2,=P'1'   Yes, add to COBOL 2   count    PF0608\n         J     ADJ_CNT_END        Done                           PF0608\nADJ_CNT_01_3 DS 0H                                               PF0608\n         CLI   1(R9),C'1'         COBOL LE?                      PF0608\n         JNE   ADJ_CNT_EXIT       No, not recognized, exit       PF0608\n         AP    CNT_COBOLLE,=P'1'  Yes, add to COBOL LE  count    PF0608\n         J     ADJ_CNT_END        Done                           PF0608\nADJ_CNT_02 DS 0H                                                 PF0608\n         CLI   0(R9),C'F'         FORTRAN?                       PF0608\n         JNE   ADJ_CNT_03         No, keep checking              PF0608\n         AP    CNT_FORTRAN,=P'1'  Yes, add to FORTRAN   count    PF0608\n         J     ADJ_CNT_END        Done                           PF0608\nADJ_CNT_03 DS 0H                                                 PF0608\n         CLI   0(R9),C'P'         PL/1?                          PF0608\n         JNE   ADJ_CNT_04         No, keep checking              PF0608\n         AP    CNT_PLI,=P'1'      Yes, add to PL/1      count    PF0608\n         J     ADJ_CNT_END        Done                           PF0608\nADJ_CNT_04 DS 0H                                                 PF0608\n         CLI   0(R9),C'U'         C/C++?                         PF0608\n         JNE   ADJ_CNT_05         No, keep checking              PF0608\n         AP    CNT_C370,=P'1'     Yes, add to C370      count    PF0608\n         J     ADJ_CNT_END        Done                           PF0608\nADJ_CNT_05 DS 0H                                                 PF0608\n*        Not any of the above, adjust OTHER count                PF0608\n         CLI   0(R9),0            Unknown ?                      RS1208\n         JE    ADJ_CNT_EXIT         Yes, leave                   RS1208\n         AP    CNT_OTHER,=P'1'    Yes, add to OTHER     count    PF0608\nADJ_CNT_END DS 0H                                                PF0608\n         SP    CNT_UNKNOWN,=P'1'  Subtract from UNKNOWN count    PF0608\nADJ_CNT_EXIT DS 0H                                               PF0608\n         L     R14,CNT_R14SAVE                                   PF0608\n         BR    R14                                               PF0608\n*------------------------------------------------------------*\n* CEEUOPT_INFO                                               *   RS1107\n*------------------------------------------------------------*\n*\nCEEUOPT_INFO DS 0H\n         ST    R14,BINDSAVE\n         BRAS  R14,BLANK1\n         STRING64 ADDINFO,INTO=RECORD\n         BRAS  R14,SPACE1\n         STRING64 '------------ about the CEEUOPT/#pragma/PLXOPT ----',X\n               '---------------------------------------------------',  X\n               INTO=RECORD\n         BRAS  R14,SPACE2\n         L     R5,CSV_OUTXTLST_ELP1  Start of data to be searched\n         L     R4,CSV_OUTXTLST_EL1   Length of string\n         AR    R4,R5         Points to the end of data\n         LR    R8,R4         keep it for later\n         LA    R0,C'C'       Search for 'C'\nCEEUOPT_05  DS    0H\n         SRST  R4,R5         Search\n         BRC   1,CEEUOPT_05  Search interrupted, continue\n         BRC   2,CEEUOPT_10  String not found\n         LR    R2,R8         End of string\n         SR    R2,R4         minus found at\n         CH    R2,=H'6'      at least 5 bytes ???\n         JL    CEEUOPT_10    no leave\n         CLC   =C'CEEOCB',0(R4)  CEEUOPT ?????\n         JE    CEEUOPT_20\n         LR    R5,R4\n         LA    R5,1(,R5)     +1\n         LR    R4,R8\n         J     CEEUOPT_05    Search again\nCEEUOPT_10  DS    0H\n         CLC   CSV_OUTXTLST_ENTRR,=F'1' more then 1 extend ?     RS1107\n         JNH   CEEUOPT_90                 no leave               RS1107\n         L     R5,CSV_OUTXTLST_ELP2  Start of data to be searched\n         L     R4,CSV_OUTXTLST_EL2   Length of string\n         AR    R4,R5         Points to the end of data\n         LR    R8,R4         keep it for later\n         LA    R0,C'C'       Search for 'C'\nCEEUOPT_15  DS    0H\n         SRST  R4,R5         Search\n         BRC   1,CEEUOPT_15  Search interrupted, continue\n         BRC   2,CEEUOPT_90  String not found\n         LR    R2,R8         End of string\n         SR    R2,R4         minus found at\n         CH    R2,=H'6'      at least 5 bytes ???\n         JL    CEEUOPT_90    no leave\n         CLC   =C'CEEOCB',0(R4)  CEEUOPT ?????\n         JE    CEEUOPT_20\n         LR    R5,R4\n         LA    R5,1(,R5)     +1\n         LR    R4,R8\n         J     CEEUOPT_15    Search again\nCEEUOPT_20  DS    0H\n         STRING64 'LE User Options present',INTO=RECORD\n         BRAS  R14,SPACE2\n         USING CEEOCB,R4\n         CLC   =C'CEEOCB',CEEOCB_EYEC   Eyecatcher\n         JNE   CEEUOPT_98\n         CLC   CEEOCB_VER,=H'15'        Version 15 ? z/OS R4\n         JE    CEEUOPT_11\n         CLC   CEEOCB_VER,=H'16'        Version 16 ? z/OS R5\n         JE    CEEUOPT_11\n         CLC   CEEOCB_VER,=H'17'        Version 17 ? z/OS R8\n         JE    CEEUOPT_11\n         CLC   CEEOCB_VER,=H'18'        Version 18 ? z/OS R9\n         JE    CEEUOPT_11\n         J     CEEUOPT_97               version not supported\nCEEUOPT_11 DS   0H\n         LR    R5,R4\n         CLI   OPTION_ABPE_FLAG,X'81'    CEEUOPT specified ?\n         JNE   CEEUOPT_ABPERCX              no leave\n         A     R5,OPTION_ABPE_SUB\n         USING SUBOPT_ABPE,R5\n         STRING64 '      ABPERC(NONE)',INTO=RECORD\n         TM    SUBOPT_ABPE_US,X'80'     None\n         JO    CEEUOPT_ABPERC9\n         STRING64 '      ABPERC(',INTO=RECORD\n         TM    SUBOPT_ABPE_US,X'40'     User abendcode\n         JNO   CEEUOPT_ABPERC1\n         STRING64 (RECORD,,T),'U',(SUBOPT_ABPE_CODE,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         J     CEEUOPT_ABPERC9\nCEEUOPT_ABPERC1 DS 0H\n         TM    SUBOPT_ABPE_US,X'20'     System abendcode\n         JNO   CEEUOPT_ABPERC2\n         STRING64 (RECORD,,T),'S',(SUBOPT_ABPE_CODE,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         J     CEEUOPT_ABPERC9\nCEEUOPT_ABPERC2 DS 0H                   Other Abcode\n         STRING64 (RECORD,,T),SUBOPT_ABPE_ABC,INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\nCEEUOPT_ABPERC9 DS 0H\n         BRASL R14,SPACE1\nCEEUOPT_ABPERCX DS 0H\n         DROP  R5\n         CLI   OPTION_ABTE_FLAG,X'81'    CEEUOPT specified ?\n         JNE   CEEUOPT_ABTERMENCX           no leave\n         LR    R5,R4\n         A     R5,OPTION_ABTE_SUB\n         USING SUBOPT_ABTE,R5\n         STRING64 '      ABTERMENC(RETCODE)',INTO=RECORD\n         CLC   SUBOPT_ABTE_OPT,=F'1'\n         JE    CEEUOPT_ABTERMENC\n         STRING64 '      ABTERMENC(ABEND)',INTO=RECORD\nCEEUOPT_ABTERMENC DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_ABTERMENCX DS 0H\n         DROP  R5\n         CLI   OPTION_AIXB_FLAG,X'81'    CEEUOPT specified ?\n         JNE   CEEUOPT_AIXBX                no leave\n         STRING64 '      AIXBLD',INTO=RECORD\n         TM    OPTION_AIXB_FLAG,X'80'\n         JO    CEEUOPT_AIXBLD\n         STRING64 '    NOAIXBLD',INTO=RECORD\nCEEUOPT_AIXBLD DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_AIXBX  DS 0H\n         CLI   OPTION_ALL3_FLAG,X'81'    CEEUOPT specified ?\n         JNH   CEEUOPT_ALL3X                no leave\n         STRING64 '      ALL31(ON)',INTO=RECORD\n         TM    OPTION_ALL3_FLAG,X'80'\n         JO    CEEUOPT_ALL31\n         STRING64 '      ALL31(OFF)',INTO=RECORD\nCEEUOPT_ALL31  DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_ALL3X  DS 0H\n         CLI   OPTION_ANYH_FLAG,X'81'    CEEUOPT specified ?\n         JNE   CEEUOPT_ANYHX                no leave\n         LR    R5,R4\n         A     R5,OPTION_ANYH_SUB\n         USING SUBOPT_ANYH,R5\n         STRING64 '      ANYHEAP(',INTO=RECORD\n         STRING64 (RECORD,,T),(SUBOPT_ANYH_INIT,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_ANYH_INC,F,L9B),INTO=RECORD\n         TM    SUBOPT_ANYH_ALLOC,X'80'  Below\n         JO    CEEUOPT_ANYHEAP1\n         STRING64 (RECORD,,T),',ANYWHERE',INTO=RECORD\n         J     CEEUOPT_ANYHEAP2\nCEEUOPT_ANYHEAP1       DS  0H\n         STRING64 (RECORD,,T),',BELOW',INTO=RECORD\nCEEUOPT_ANYHEAP2       DS  0H\n         TM    SUBOPT_ANYH_ALLOC,X'40'  Free\n         JO    CEEUOPT_ANYHEAP3\n         STRING64 (RECORD,,T),',KEEP)',INTO=RECORD\n         J     CEEUOPT_ANYHEAP4\nCEEUOPT_ANYHEAP3       DS  0H\n         STRING64 (RECORD,,T),',FREE)',INTO=RECORD\nCEEUOPT_ANYHEAP4       DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_ANYHX  DS 0H\n         DROP  R5\n         CLI   OPTION_AUTO_FLAG,X'81'    CEEUOPT specified ?\n         JNE   CEEUOPT_AUTOX                no leave\n         LR    R5,R4\n         A     R5,OPTION_AUTO_SUB\n         USING SUBOPT_AUTO,R5\n         STRING64 '      AUTOTASK(',SUBOPT_AUTO_LMOD,',',              X\n               (SUBOPT_AUTO_NO,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         TM    OPTION_AUTO_FLAG,X'80'\n         JO    CEEUOPT_AUTOTASK\n         STRING64 '    NOAUTOTASK',INTO=RECORD\nCEEUOPT_AUTOTASK DS 0H\n         BRASL R14,SPACE1\nCEEUOPT_AUTOX  DS 0H\n         CLI   OPTION_BELH_FLAG,X'81'    CEEUOPT specified ?\n         JNE   CEEUOPT_BELHX                no leave\n         LR    R5,R4\n         A     R5,OPTION_BELH_SUB\n         USING SUBOPT_BELH,R5\n         STRING64 '      BELOWHEAP(',INTO=RECORD\n         STRING64 (RECORD,,T),(SUBOPT_BELH_INIT,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_BELH_INC,F,L9B),INTO=RECORD\n         TM    SUBOPT_BELH_ALLOC,X'40'  Free?\n         JO    CEEUOPT_BELOWHEAP1\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         J     CEEUOPT_BELOWHEAP\nCEEUOPT_BELOWHEAP1  DS  0H\n         STRING64 (RECORD,,T),',FREE)',INTO=RECORD\nCEEUOPT_BELOWHEAP   DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_BELHX  DS 0H\n         CLI   OPTION_CBLO_FLAG,X'81'    CEEUOPT specified ?\n         JNE   CEEUOPT_CBLOX                no leave\n         DROP  R5\n         STRING64 '      CBLOPTS(ON)',INTO=RECORD\n         TM    OPTION_CBLO_FLAG,X'80'\n         JO    CEEUOPT_CBLOPTS\n         STRING64 '      CBLOPTS(OFF)',INTO=RECORD\nCEEUOPT_CBLOPTS DS 0H\n         BRASL R14,SPACE1\nCEEUOPT_CBLOX  DS 0H\n         CLI   OPTION_CBLP_FLAG,X'81'    CEEUOPT specified ?\n         JNE   CEEUOPT_CBLPX                no leave\n         STRING64 '      CBLPSHPOP(ON)',INTO=RECORD\n         TM    OPTION_CBLP_FLAG,X'80'\n         JO    CEEUOPT_CBLPSHPOP\n         STRING64 '      CBLPSHPOP(OFF)',INTO=RECORD\nCEEUOPT_CBLPSHPOP DS 0H\n         BRASL R14,SPACE1\nCEEUOPT_CBLPX  DS  0H\n         CLI   OPTION_CBLQ_FLAG,X'81'    CEEUOPT specified ?\n         JNE   CEEUOPT_CBLQX                no leave\n         STRING64 '      CBLQDA(ON)',INTO=RECORD\n         TM    OPTION_CBLQ_FLAG,X'80'\n         JO    CEEUOPT_CBLQDA\n         STRING64 '      CBLQDA(OFF)',INTO=RECORD\nCEEUOPT_CBLQDA   DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_CBLQX  DS 0H\n         CLC   CEEOCB_VER,=H'18'        Version 18 ? z/OS R9\n         JL    CEEUOPT_CEEDMPX\n         CLI   OPTION_CEEDMP_FLAG,X'81'    CEEUOPT specified ?\n         JNE   CEEUOPT_CEEDMPX              no leave\n         LR    R5,R4\n         A     R5,OPTION_CEEDMP_SUB\n         USING SUBOPT_CEEDMP,R5\n         STRING64 '      CEEDUMP(',(SUBOPT_CEEDMP_PAGL,F,L3B),         X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',SYSOUT=(',SUBOPT_CEEDMP_SYSC,          X\n               ',',SUBOPT_CEEDMP_SYSO,'),',INTO=RECORD\n         TM    SUBOPT_CEEDMP_FREE,X'00'  Free=end of close\n         JNZ   CEEUOPT_CEEDMP2\n         STRING64 (RECORD,,T),'FREE=END,',INTO=RECORD\n         J     CEEUOPT_CEEDMP3\nCEEUOPT_CEEDMP2     DS  0H\n         STRING64 (RECORD,,T),'FREE=CLOSE',INTO=RECORD\nCEEUOPT_CEEDMP3     DS  0H\n         TM    SUBOPT_CEEDMP_SPIN,X'00'  SPIN=Unalloc or NO\n         JNZ   CEEUOPT_CEEDMP4\n         STRING64 (RECORD,,T),'SPIN=UNALLOC)',INTO=RECORD\n         J     CEEUOPT_CEEDMP5\nCEEUOPT_CEEDMP4     DS  0H\n         STRING64 (RECORD,,T),'SPIN=NO)',INTO=RECORD\nCEEUOPT_CEEDMP5     DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_CEEDMPX DS 0H\n         CLI   OPTION_CHEC_FLAG,X'81'    CEEUOPT specified ?\n         JNE   CEEUOPT_CHECX                no leave\n         STRING64 '      CHECK(ON)',INTO=RECORD\n         TM    OPTION_CHEC_FLAG,X'80'\n         JO    CEEUOPT_CHECK\n         STRING64 '      CHECK(OFF)',INTO=RECORD\nCEEUOPT_CHECK  DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_CHECX  DS 0H\n         CLI   OPTION_COUN_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_COUNX                no leave\n         LR    R5,R4\n         A     R5,OPTION_COUN_SUB\n         USING SUBOPT_COUN,R5\n         STRING64 '      COUNTRY(',SUBOPT_COUN_ID,')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_COUNX  DS 0H\n         CLI   OPTION_DEBU_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_DEBUX                no leave\n         STRING64 '      DEBUG',INTO=RECORD\n         TM    OPTION_DEBU_FLAG,X'80'\n         JO    CEEUOPT_DEBUG\n         STRING64 '    NODEBUG',INTO=RECORD\nCEEUOPT_DEBUG    DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_DEBUX  DS 0H\n         DROP  R5\n         CLI   OPTION_DEPT_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_DEPTX                no leave\n         LR    R5,R4\n         A     R5,OPTION_DEPT_SUB\n         USING SUBOPT_DEPT,R5\n         STRING64 '      DEPTHCONDLMT(',(SUBOPT_DEPT_COUNT,F,L9B),     X\n               INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_DEPTX  DS 0H\n         DROP  R5\n         CLC   CEEOCB_VER,=H'17'        Version 17 ? z/OS R8\n         JL    CEEUOPT_NODYNDUMP\n         CLI   OPTION_DYNDMP_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_DYNDMPX              no leave\n         LR    R5,R4\n         A     R5,OPTION_DYNDMP_SUB\n         USING SUBOPT_DYNDMP,R5\n         LR    R8,R4\n         A     R8,SUBOPT_DYNDMP_HLQP\n         USING SUBOPT_DYNDMP_HLQO,R8\n         LH    R0,SUBOPT_DYNDMP_HLQL  length\n         STRING64 '      DYNDUMP(\"',(SUBOPT_DYNDMP_HLQS,(R0)),         X\n               INTO=RECORD\n         TM    SUBOPT_DYNDMP_FLG1,X'80'  Dynamic\n         JZ    CEEUOPT_DYNDMP1\n         STRING64 (RECORD,,T),',DYNAMIC',INTO=RECORD\n         J     CEEUOPT_DYNDMP4\nCEEUOPT_DYNDMP1     DS  0H\n         TM    SUBOPT_DYNDMP_FLG1,X'40'  Nodynamic\n         JZ    CEEUOPT_DYNDMP2\n         STRING64 (RECORD,,T),',NODYNAMIC',INTO=RECORD\n         J     CEEUOPT_DYNDMP4\nCEEUOPT_DYNDMP2     DS  0H\n         TM    SUBOPT_DYNDMP_FLG1,X'20'  Force\n         JZ    CEEUOPT_DYNDMP3\n         STRING64 (RECORD,,T),',FORCE',INTO=RECORD\n         J     CEEUOPT_DYNDMP4\nCEEUOPT_DYNDMP3     DS  0H\n         TM    SUBOPT_DYNDMP_FLG1,X'10'  Both\n         JZ    CEEUOPT_DYNDMP4\n         STRING64 (RECORD,,T),',BOTH',INTO=RECORD\nCEEUOPT_DYNDMP4     DS  0H\n         TM    SUBOPT_DYNDMP_FLG2,X'80'  TDUMP\n         JZ    CEEUOPT_DYNDMP5\n         STRING64 (RECORD,,T),',TDUMP\")',INTO=RECORD\n         BRASL R14,SPACE1\n         J     CEEUOPT_NODYNDUMP\nCEEUOPT_DYNDMP5     DS  0H\n         TM    SUBOPT_DYNDMP_FLG2,X'40'  NOTDUMP\n         JZ    CEEUOPT_NODYNDUMP\n         STRING64 (RECORD,,T),',NOTDUMP\")',INTO=RECORD\n         BRASL R14,SPACE1\n         DROP  R5\nCEEUOPT_NODYNDUMP DS  0H\nCEEUOPT_DYNDMPX DS 0H\n         CLI   OPTION_ENVA_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_ENVAX                no leave\n         LR    R5,R4\n         A     R5,OPTION_ENVA_SUB\n         USING SUBOPT_ENVA,R5\n         STRING64 '      ENVAR(\"\")',INTO=RECORD\n         CLC   SUBOPT_ENVA_LEN,=H'0'\n         JE    CEEUOPT_ENVAR\n         STRING64 '      ENVAR(\"',(SUBOPT_ENVA_STR,60),'\")',INTO=RECORD\nCEEUOPT_ENVAR    DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_ENVAX  DS 0H\n         DROP  R5\n         CLI   OPTION_ERRC_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_ERRCX                no leave\n         LR    R5,R4\n         A     R5,OPTION_ERRC_SUB\n         USING SUBOPT_ERRC,R5\n         STRING64 '      ERRCOUNT(',(SUBOPT_ERRC_COUNT,F,L9B),         X\n               INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_ERRCX  DS 0H\n         DROP  R5\n         CLI   OPTION_ERRU_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_ERRUX                no leave\n         LR    R5,R4\n         A     R5,OPTION_ERRU_SUB\n         USING SUBOPT_ERRU,R5\n         STRING64 '      ERRUNIT(',(SUBOPT_ERRU_COUNT,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_ERRUX  DS 0H\n         DROP  R5\n         CLI   OPTION_FILE_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_FILEX                no leave\n         STRING64 '      FILEHIST',INTO=RECORD\n         TM    OPTION_FILE_FLAG,X'80'\n         JO    CEEUOPT_FILEHIST\n         STRING64 '    NOFILEHIST',INTO=RECORD\nCEEUOPT_FILEHIST DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_FILEX  DS 0H\n         CLI   OPTION_FILT_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_FILTX                no leave\n         LR    R5,R4\n         A     R5,OPTION_FILT_SUB\n         USING SUBOPT_FILT,R5\n         STRING64 '      FILETAG(AUTOCVT,',INTO=RECORD\n         TM    SUBOPT_FILT_FLG,X'80'\n         JO    CEEUOPT_FILETAG1\n         STRING64 '      FILETAG(NOAUTOCVT,',INTO=RECORD\nCEEUOPT_FILETAG1 DS  0H\n         TM    SUBOPT_FILT_FLG,X'40'\n         JO    CEEUOPT_FILETAG2\n         STRING64 (RECORD,,T),'NOAUTOTAG)',INTO=RECORD\n         J     CEEUOPT_FILETAG3\nCEEUOPT_FILETAG2 DS  0H\n         STRING64 (RECORD,,T),'AUTOTAG)',INTO=RECORD\nCEEUOPT_FILETAG3 DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_FILTX  DS 0H\n         DROP  R5\n         CLI   OPTION_FLOW_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_FLOWX                no leave\n         STRING64 '      FLOW',INTO=RECORD\n         TM    OPTION_FLOW_FLAG,X'80'\n         JO    CEEUOPT_FLOW\n         STRING64 '    NOFLOW',INTO=RECORD\nCEEUOPT_FLOW     DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_FLOWX  DS 0H\n         CLI   OPTION_HEAP_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_HEAPX                no leave\n         LR    R5,R4\n         A     R5,OPTION_HEAP_SUB\n         USING SUBOPT_HEAP,R5\n         STRING64 '      HEAP(',INTO=RECORD\n         STRING64 (RECORD,,T),(SUBOPT_HEAP_INIT,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEAP_INC,F,L9B),INTO=RECORD\n         TM    SUBOPT_HEAP_ALLOC,X'80'  Below\n         JO    CEEUOPT_HEAP1\n         STRING64 (RECORD,,T),',ANYWHERE',INTO=RECORD\n         J     CEEUOPT_HEAP2\nCEEUOPT_HEAP1       DS  0H\n         STRING64 (RECORD,,T),',BELOW',INTO=RECORD\nCEEUOPT_HEAP2       DS  0H\n         TM    SUBOPT_HEAP_ALLOC,X'40'  Free\n         JO    CEEUOPT_HEAP3\n         STRING64 (RECORD,,T),',KEEP,',INTO=RECORD\n         J     CEEUOPT_HEAP4\nCEEUOPT_HEAP3       DS  0H\n         STRING64 (RECORD,,T),',FREE,',INTO=RECORD\nCEEUOPT_HEAP4       DS  0H\n         STRING64 (RECORD,,T),(SUBOPT_HEAP24_INIT,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEAP24_INC,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_HEAPX  DS 0H\n         DROP  R5\n*        CLI   WKCELL1,C'1'            64bit LE-Option\n*        JNE   CEEUOPT_NOHEAP64          no leave\n         CLI   OPTION_HE64_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_HE64X                no leave\n         LR    R5,R4\n         A     R5,OPTION_HE64_SUB\n         USING SUBOPT_HE64,R5\n         STRING64 '      HEAP64(',INTO=RECORD\n         STRING64 (RECORD,,T),(SUBOPT_HE64_INIT,FD,L16B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HE64_INC,FD,L16B),INTO=RECORD\n         TM    SUBOPT_HE64_ALLOC,X'40'  Free\n         JO    CEEUOPT_HEAP64_1\n         STRING64 (RECORD,,T),',KEEP,',INTO=RECORD\n         J     CEEUOPT_HEAP64_2\nCEEUOPT_HEAP64_1    DS  0H\n         STRING64 (RECORD,,T),',FREE,',INTO=RECORD\nCEEUOPT_HEAP64_2    DS  0H\n         STRING64 (RECORD,,T),(SUBOPT_HE6431_INIT,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HE6431_INC,F,L9B),INTO=RECORD\n         TM    SUBOPT_HE6431_ALLOC,X'40'  Free\n         JO    CEEUOPT_HEAP64_3\n         STRING64 (RECORD,,T),',KEEP,',INTO=RECORD\n         J     CEEUOPT_HEAP64_4\nCEEUOPT_HEAP64_3    DS  0H\n         STRING64 (RECORD,,T),',FREE,',INTO=RECORD\nCEEUOPT_HEAP64_4    DS  0H\n         STRING64 (RECORD,,T),(SUBOPT_HE6424_INIT,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HE6424_INC,F,L9B),INTO=RECORD\n         TM    SUBOPT_HE6424_ALLOC,X'40'  Free\n         JO    CEEUOPT_HEAP64_5\n         STRING64 (RECORD,,T),',KEEP)',INTO=RECORD\n         J     CEEUOPT_HEAP64_6\nCEEUOPT_HEAP64_5    DS  0H\n         STRING64 (RECORD,,T),',FREE)',INTO=RECORD\nCEEUOPT_HEAP64_6    DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_HE64X  DS 0H\n         DROP  R5\nCEEUOPT_NOHEAP64    DS  0H\n         CLI   OPTION_HCHK_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_HCHKX                no leave\n         LR    R5,R4\n         A     R5,OPTION_HCHK_SUB\n         USING SUBOPT_HCHK,R5\n         STRING64 '      HEAPCHK(ON,',INTO=RECORD\n         TM    OPTION_HCHK_FLAG,X'80'\n         JO    CEEUOPT_HEAPCHECK\n         STRING64 '      HEAPCHK(OFF,',INTO=RECORD\nCEEUOPT_HEAPCHECK DS 0H\n         STRING64 (RECORD,,T),(SUBOPT_HCHK_FREQ,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HCHK_INIT,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HCHK_CLVL,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HCHK_PLVL,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_HCHKX  DS 0H\n         DROP  R5\n         CLI   OPTION_HEPP_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_HEPPX                no leave\n         LR    R5,R4\n         A     R5,OPTION_HEPP_SUB\n         USING SUBOPT_HEPP,R5\n         STRING64 '      HEAPPOOLS(ON,',INTO=RECORD\n         TM    OPTION_HEPP_FLAG,X'80'\n         JO    CEEUOPT_HEAPPOOLS\n         STRING64 '      HEAPPOOLS(OFF,',INTO=RECORD\nCEEUOPT_HEAPPOOLS DS 0H\n         STRING64 (RECORD,,T),(SUBOPT_HEPP_CP1S,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP1P,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP2S,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP2P,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP3S,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP3P,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP4S,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP4P,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP5S,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP5P,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP6S,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP6P,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP7S,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP7P,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP8S,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP8P,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP9S,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP9P,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP10S,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP10P,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP11S,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP11P,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP12S,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP_CP12P,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_HEPPX  DS 0H\n         DROP  R5\n*        CLI   WKCELL1,C'1'            64bit LE-Option\n*        JNE   CEEUOPT_NOHEAPP64         no leave\n         CLI   OPTION_HEPP64_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_HEPP64X              no leave\n         LR    R5,R4\n         A     R5,OPTION_HEPP64_SUB\n         USING SUBOPT_HEPP64,R5\n         STRING64 '      HEAPPOOLS64(ON,',INTO=RECORD\n         TM    OPTION_HEPP64_FLAG,X'80'\n         JO    CEEUOPT_HEAPP64\n         STRING64 '      HEAPPOOLS64(OFF,',INTO=RECORD\nCEEUOPT_HEAPP64   DS 0H\n         STRING64 (RECORD,,T),(SUBOPT_HEPP64_CP1S,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP1P,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP2S,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP2P,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP3S,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP3P,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP4S,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP4P,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP5S,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP5P,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP6S,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP6P,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP7S,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP7P,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP8S,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP8P,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP9S,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP9P,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP10S,F,L9B),         X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP10P,F,L9B),         X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP11S,F,L9B),         X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP11P,F,L9B),         X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP12S,F,L9B),         X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_HEPP64_CP12P,F,L9B),         X\n               INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_HEPP64X DS 0H\n         DROP  R5\nCEEUOPT_NOHEAPP64 DS 0H\n         CLI   OPTION_INFO_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_INFOX                no leave\n         LR    R5,R4\n         A     R5,OPTION_INFO_SUB\n         USING SUBOPT_INFO,R5\n         STRING64 '      INFOMSGFILTER(ON,',SUBOPT_INFO_ID1,INTO=RECORD\n         STRING64 (RECORD,,T),',',SUBOPT_INFO_ID2,INTO=RECORD\n         STRING64 (RECORD,,T),',',SUBOPT_INFO_ID3,INTO=RECORD\n         STRING64 (RECORD,,T),',',SUBOPT_INFO_ID4,INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         TM    OPTION_INFO_FLAG,X'80'\n         JO    CEEUOPT_INFOMSGFILTER\n         STRING64 '      INFOMSGFILTER(OFF,',SUBOPT_INFO_ID1,          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',SUBOPT_INFO_ID2,INTO=RECORD\n         STRING64 (RECORD,,T),',',SUBOPT_INFO_ID3,INTO=RECORD\n         STRING64 (RECORD,,T),',',SUBOPT_INFO_ID4,INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\nCEEUOPT_INFOMSGFILTER DS 0H\n         BRASL R14,SPACE1\nCEEUOPT_INFOX  DS 0H\n         DROP  R5\n         CLI   OPTION_INQP_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_INQPX                no leave\n         STRING64 '      INQPCOPN',INTO=RECORD\n         TM    OPTION_INQP_FLAG,X'80'\n         JO    CEEUOPT_INQPCOPN\n         STRING64 '    NOINQPCOPN',INTO=RECORD\nCEEUOPT_INQPCOPN DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_INQPX  DS 0H\n         CLI   OPTION_INTE_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_INTEX                no leave\n         STRING64 '      INTERRUPT(ON)',INTO=RECORD\n         TM    OPTION_INTE_FLAG,X'80'\n         JO    CEEUOPT_INTERRUPT\n         STRING64 '      INTERRUPT(OFF)',INTO=RECORD\nCEEUOPT_INTERRUPT DS 0H\n         BRASL R14,SPACE1\nCEEUOPT_INTEX  DS 0H\n*        CLI   WKCELL1,C'1'            64bit LE-Option\n*        JNE   CEEUOPT_NOIOHEAP64        no leave\n         CLI   OPTION_IOHE64_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_IOHE64X              no leave\n         LR    R5,R4\n         A     R5,OPTION_IOHE64_SUB\n         USING SUBOPT_IOHE64,R5\n         STRING64 '      IOHEAP64(',INTO=RECORD\n         STRING64 (RECORD,,T),(SUBOPT_IOHE64_INIT,FD,L16B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_IOHE64_INC,FD,L16B),         X\n               INTO=RECORD\n         TM    SUBOPT_IOHE64_ALLOC,X'40'  Free\n         JO    CEEUOPT_IOHEAP64_1\n         STRING64 (RECORD,,T),',KEEP,',INTO=RECORD\n         J     CEEUOPT_IOHEAP64_2\nCEEUOPT_IOHEAP64_1    DS  0H\n         STRING64 (RECORD,,T),',FREE,',INTO=RECORD\nCEEUOPT_IOHEAP64_2    DS  0H\n         STRING64 (RECORD,,T),(SUBOPT_IOHE6431_INIT,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_IOHE6431_INC,F,L9B),         X\n               INTO=RECORD\n         TM    SUBOPT_IOHE6431_ALLOC,X'40'  Free\n         JO    CEEUOPT_IOHEAP64_3\n         STRING64 (RECORD,,T),',KEEP,',INTO=RECORD\n         J     CEEUOPT_IOHEAP64_4\nCEEUOPT_IOHEAP64_3    DS  0H\n         STRING64 (RECORD,,T),',FREE,',INTO=RECORD\nCEEUOPT_IOHEAP64_4    DS  0H\n         STRING64 (RECORD,,T),(SUBOPT_IOHE6424_INIT,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_IOHE6424_INC,F,L9B),         X\n               INTO=RECORD\n         TM    SUBOPT_IOHE6424_ALLOC,X'40'  Free\n         JO    CEEUOPT_IOHEAP64_5\n         STRING64 (RECORD,,T),',KEEP)',INTO=RECORD\n         J     CEEUOPT_IOHEAP64_6\nCEEUOPT_IOHEAP64_5    DS  0H\n         STRING64 (RECORD,,T),',FREE)',INTO=RECORD\nCEEUOPT_IOHEAP64_6    DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_IOHE64X DS 0H\n         DROP  R5\nCEEUOPT_NOIOHEAP64    DS  0H\n*        CLI   WKCELL1,C'1'            64bit LE-Option\n*        JNE   CEEUOPT_NOLIBHEAP64       no leave\n         CLI   OPTION_LIHE64_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_LIHE64X              no leave\n         LR    R5,R4\n         A     R5,OPTION_LIHE64_SUB\n         USING SUBOPT_LIHE64,R5\n         STRING64 '      LIBHEAP64(',INTO=RECORD\n         STRING64 (RECORD,,T),(SUBOPT_LIHE64_INIT,FD,L16B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_LIHE64_INC,FD,L16B),         X\n               INTO=RECORD\n         TM    SUBOPT_LIHE64_ALLOC,X'40'  Free\n         JO    CEEUOPT_LIBHEAP64_1\n         STRING64 (RECORD,,T),',KEEP,',INTO=RECORD\n         J     CEEUOPT_LIBHEAP64_2\nCEEUOPT_LIBHEAP64_1    DS  0H\n         STRING64 (RECORD,,T),',FREE,',INTO=RECORD\nCEEUOPT_LIBHEAP64_2    DS  0H\n         STRING64 (RECORD,,T),(SUBOPT_LIHE6431_INIT,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_LIHE6431_INC,F,L9B),         X\n               INTO=RECORD\n         TM    SUBOPT_LIHE6431_ALLOC,X'40'  Free\n         JO    CEEUOPT_LIBHEAP64_3\n         STRING64 (RECORD,,T),',KEEP,',INTO=RECORD\n         J     CEEUOPT_LIBHEAP64_4\nCEEUOPT_LIBHEAP64_3    DS  0H\n         STRING64 (RECORD,,T),',FREE,',INTO=RECORD\nCEEUOPT_LIBHEAP64_4    DS  0H\n         STRING64 (RECORD,,T),(SUBOPT_LIHE6424_INIT,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_LIHE6424_INC,F,L9B),         X\n               INTO=RECORD\n         TM    SUBOPT_LIHE6424_ALLOC,X'40'  Free\n         JO    CEEUOPT_LIBHEAP64_5\n         STRING64 (RECORD,,T),',KEEP)',INTO=RECORD\n         J     CEEUOPT_LIBHEAP64_6\nCEEUOPT_LIBHEAP64_5    DS  0H\n         STRING64 (RECORD,,T),',FREE)',INTO=RECORD\nCEEUOPT_LIBHEAP64_6    DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_LIHE64X DS 0H\n         DROP  R5\nCEEUOPT_NOLIBHEAP64    DS  0H\n         CLI   OPTION_LIBS_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_LIBSX                no leave\n         LR    R5,R4\n         A     R5,OPTION_LIBS_SUB\n         USING SUBOPT_LIBS,R5\n         STRING64 '      LIBSTACK(',(SUBOPT_LIBS_INIT,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_LIBS_INC,F,L9B),INTO=RECORD\n         TM    SUBOPT_LIBS_ALLOC,X'40'  Free?\n         JO    CEEUOPT_LIBSTACK1\n         STRING64 (RECORD,,T),',KEEP)',INTO=RECORD\n         J     CEEUOPT_LIBSTACK2\nCEEUOPT_LIBSTACK1   DS  0H\n         STRING64 (RECORD,,T),',FREE)',INTO=RECORD\nCEEUOPT_LIBSTACK2   DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_LIBSX  DS 0H\n         DROP  R5\n         CLI   OPTION_MSGF_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_MSGFX                no leave\n         LR    R5,R4\n         A     R5,OPTION_MSGF_SUB\n         USING SUBOPT_MSGF,R5\n         STRING64 '      MSGFILE(',SUBOPT_MSGF_DD,INTO=RECORD\n         STRING64 (RECORD,,T),',',SUBOPT_MSGF_RFM,INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_MSGF_RECL,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_MSGF_BLKS,F,L9B),INTO=RECORD\n         CLC   SUBOPT_MSGF_ENQ,BLANKS\n         JE    CEEUOPT_MSGFILE1\n         STRING64 (RECORD,,T),',ENQ)',INTO=RECORD\n         J     CEEUOPT_MSGFILE2\nCEEUOPT_MSGFILE1 DS  0H\n         STRING64 (RECORD,,T),',NOENQ)',INTO=RECORD\nCEEUOPT_MSGFILE2 DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_MSGFX  DS 0H\n         DROP  R5\n         CLI   OPTION_MSGQ_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_MSGQX                no leave\n         LR    R5,R4\n         A     R5,OPTION_MSGQ_SUB\n         USING SUBOPT_MSGQ,R5\n         STRING64 '      MSGQ(',(SUBOPT_MSGQ_COUNT,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_MSGQX  DS 0H\n         DROP  R5\n         CLI   OPTION_NATL_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_NATLX                no leave\n         LR    R5,R4\n         A     R5,OPTION_NATL_SUB\n         USING SUBOPT_NATL,R5\n         STRING64 '      NATLANG(',SUBOPT_NATL_ID,')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_NATLX  DS 0H\n         DROP  R5\n         CLI   OPTION_OCST_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_OCSTX                no leave\n         STRING64 '      OCSTATUS',INTO=RECORD\n         TM    OPTION_OCST_FLAG,X'80'\n         JO    CEEUOPT_OCSTATUS\n         STRING64 '    NOOCSTATUS',INTO=RECORD\nCEEUOPT_OCSTATUS DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_OCSTX  DS 0H\n         CLI   OPTION_PC_FLAG,X'81'         CEEUOPT specified ?\n         JNE   CEEUOPT_PCX                  no leave\n         STRING64 '      PC',INTO=RECORD\n         TM    OPTION_PC_FLAG,X'80'\n         JO    CEEUOPT_PC\n         STRING64 '    NOPC',INTO=RECORD\nCEEUOPT_PC       DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_PCX    DS 0H\n         CLI   OPTION_PLIT_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_PLITX                no leave\n         LR    R5,R4\n         A     R5,OPTION_PLIT_SUB\n         USING SUBOPT_PLIT,R5\n         STRING64 '      PLITASKCOUNT(',(SUBOPT_PLIT_COUNT,F,L9B),     X\n               INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_PLITX  DS 0H\n         CLI   OPTION_POSI_FLAG,X'81'       CEEUOPT specified ?\n         JNH   CEEUOPT_POSIX                no leave\n         DROP  R5\n         STRING64 '      POSIX(ON)',INTO=RECORD\n         TM    OPTION_POSI_FLAG,X'80'\n         JO    CEEUOPT_POSIX1\n         STRING64 '      POSIX(OFF)',INTO=RECORD\nCEEUOPT_POSIX1   DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_POSIX  DS 0H\n         CLI   OPTION_PROF_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_PROFX                no leave\n         LR    R5,R4\n         A     R5,OPTION_PROF_SUB\n         USING SUBOPT_PROF,R5\n         STRING64 '      PROFILE(ON',INTO=RECORD\n         TM    OPTION_PROF_FLAG,X'80'\n         JO    CEEUOPT_PROFILE\n         STRING64 '      PROFILE(OFF',INTO=RECORD\nCEEUOPT_PROFILE  DS  0H\n         CLC   SUBOPT_PROF_STRL,=H'0'\n         JE    CEEUOPT_PROFILE1\n         STRING64 (RECORD,,T),',\"',(SUBOPT_PROF_STR,60),'\")',          X\n               INTO=RECORD\n         J     CEEUOPT_PROFILE9\nCEEUOPT_PROFILE1 DS  0H\n         STRING64 (RECORD,,T),',\"\")',INTO=RECORD\nCEEUOPT_PROFILE9 DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_PROFX  DS 0H\n         DROP  R5\n         CLI   OPTION_PRTU_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_PRTUX                no leave\n         LR    R5,R4\n         A     R5,OPTION_PRTU_SUB\n         USING SUBOPT_PRTU,R5\n         STRING64 '      PRTUNIT(',(SUBOPT_PRTU_COUNT,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_PRTUX  DS 0H\n         DROP  R5\n         CLI   OPTION_PUNU_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_PUNUX                no leave\n         LR    R5,R4\n         A     R5,OPTION_PUNU_SUB\n         USING SUBOPT_PUNU,R5\n         STRING64 '      PUNUNIT(',(SUBOPT_PUNU_COUNT,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_PUNUX  DS 0H\n         DROP  R5\n         CLI   OPTION_RDRU_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_RDRUX                no leave\n         LR    R5,R4\n         A     R5,OPTION_RDRU_SUB\n         USING SUBOPT_RDRU,R5\n         STRING64 '      RDRUNIT(',(SUBOPT_RDRU_COUNT,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_RDRUX  DS 0H\n         DROP  R5\n         CLI   OPTION_RECP_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_RECPX                no leave\n         LR    R5,R4\n         A     R5,OPTION_RECP_SUB\n         USING SUBOPT_RECP,R5\n         STRING64 '      RECPAD(OFF)',INTO=RECORD\n         CLC   SUBOPT_RECP_FLG,=F'4'\n         JE    CEEUOPT_RECPAD\n         STRING64 '      RECPAD(ON)',INTO=RECORD\n         CLC   SUBOPT_RECP_FLG,=F'2'\n         JE    CEEUOPT_RECPAD\n         STRING64 '      RECPAD(VAR)',INTO=RECORD\nCEEUOPT_RECPAD   DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_RECPX  DS 0H\n         DROP  R5\n         CLI   OPTION_RPTO_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_RPTOX                no leave\n         STRING64 '      RPTOPTS(ON)',INTO=RECORD\n         TM    OPTION_RPTO_FLAG,X'80'\n         JO    CEEUOPT_RPTOPTS\n         STRING64 '      RPTOPTS(OFF)',INTO=RECORD\nCEEUOPT_RPTOPTS  DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_RPTOX  DS 0H\n         CLI   OPTION_RPTS_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_RPTSX                no leave\n         STRING64 '      RPTSTG(ON)',INTO=RECORD\n         TM    OPTION_RPTS_FLAG,X'80'\n         JO    CEEUOPT_RPTSTG\n         STRING64 '      RPTSTG(OFF)',INTO=RECORD\nCEEUOPT_RPTSTG   DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_RPTSX  DS 0H\n         CLI   OPTION_RTER_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_RTERX                no leave\n         STRING64 '      RTEREUS',INTO=RECORD\n         TM    OPTION_RTER_FLAG,X'80'\n         JO    CEEUOPT_RTEREUS\n         STRING64 '    NORTEREUS',INTO=RECORD\nCEEUOPT_RTEREUS  DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_RTERX  DS 0H\n         CLI   OPTION_SIMV_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_SIMVX                no leave\n         STRING64 '      SIMVRD',INTO=RECORD\n         TM    OPTION_SIMV_FLAG,X'80'\n         JO    CEEUOPT_SIMVRD\n         STRING64 '    NOSIMVRD',INTO=RECORD\nCEEUOPT_SIMVRD   DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_SIMVX  DS 0H\n         CLI   OPTION_STAC_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_STACX                no leave\n         LR    R5,R4\n         A     R5,OPTION_STAC_SUB\n         USING SUBOPT_STAC,R5\n         STRING64 '      STACK(',INTO=RECORD\n         STRING64 (RECORD,,T),(SUBOPT_STAC_INIT,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_STAC_INC,F,L9B),INTO=RECORD\n         TM    SUBOPT_STAC_ALLOC,X'80'  Below\n         JO    CEEUOPT_STACK1\n         STRING64 (RECORD,,T),',ANYWHERE',INTO=RECORD\n         J     CEEUOPT_STACK2\nCEEUOPT_STACK1      DS  0H\n         STRING64 (RECORD,,T),',BELOW',INTO=RECORD\nCEEUOPT_STACK2      DS  0H\n         TM    SUBOPT_STAC_ALLOC,X'40'  Free\n         JO    CEEUOPT_STACK3\n         STRING64 (RECORD,,T),',KEEP,',INTO=RECORD\n         J     CEEUOPT_STACK4\nCEEUOPT_STACK3      DS  0H\n         STRING64 (RECORD,,T),',FREE,',INTO=RECORD\nCEEUOPT_STACK4      DS  0H\n         STRING64 (RECORD,,T),(SUBOPT_STAC_DINIT,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_STAC_DINC,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_STACX  DS 0H\n*        CLI   WKCELL1,C'1'            64bit LE-Option\n*        JNE   CEEUOPT_NOSTACK64         no leave\n         CLI   OPTION_STAC64_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_STAC64X              no leave\n         LR    R5,R4\n         A     R5,OPTION_STAC64_SUB\n         USING SUBOPT_STAC64,R5\n         STRING64 '      STACK64(',INTO=RECORD\n         STRING64 (RECORD,,T),(SUBOPT_STAC64_INIT,FD,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),'M,',(SUBOPT_STAC64_INC,FD,L9B),         X\n               INTO=RECORD\n         STRING64 (RECORD,,T),'M,',(SUBOPT_STAC64_MAX,FD,L9B),         X\n               INTO=RECORD\n         STRING64 (RECORD,,T),'M)',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_STAC64X DS 0H\n         DROP  R5\nCEEUOPT_NOSTACK64   DS  0H\n         CLI   OPTION_STOR_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_STORX                no leave\n         LR    R5,R4\n         A     R5,OPTION_STOR_SUB\n         USING SUBOPT_STOR,R5\n         STRING64 '      STORAGE(',INTO=RECORD\n         TM    SUBOPT_STOR_CSF,X'80'\n         JO    CEEUOPT_STORAGE1\n         STRING64 (RECORD,,T),'NONE,',INTO=RECORD\n         JNE   CEEUOPT_STORAGE2\nCEEUOPT_STORAGE1       DS  0H\n         STRING64 (RECORD,,T),(SUBOPT_STOR_AHSC,1,X),',',INTO=RECORD\nCEEUOPT_STORAGE2       DS  0H\n         TM    SUBOPT_STOR_CSF,X'40'\n         JO    CEEUOPT_STORAGE3\n         STRING64 (RECORD,,T),'NONE,',INTO=RECORD\n         JNE   CEEUOPT_STORAGE4\nCEEUOPT_STORAGE3       DS  0H\n         STRING64 (RECORD,,T),(SUBOPT_STOR_FHSC,1,X),',',INTO=RECORD\nCEEUOPT_STORAGE4       DS  0H\n         TM    SUBOPT_STOR_CSF,X'20'\n         JO    CEEUOPT_STORAGE5\n         STRING64 (RECORD,,T),'NONE,',INTO=RECORD\n         JNE   CEEUOPT_STORAGE6\nCEEUOPT_STORAGE5       DS  0H\n         STRING64 (RECORD,,T),(SUBOPT_STOR_ADSC,1,X),',',INTO=RECORD\nCEEUOPT_STORAGE6       DS  0H\n         STRING64 (RECORD,,T),(SUBOPT_STOR_SOSSZ,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_STORX  DS 0H\n         CLI   OPTION_TERM_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_TERMX                no leave\n         LR    R5,R4\n         A     R5,OPTION_TERM_SUB\n         USING SUBOPT_TERM,R5\n         STRING64 '      TERMTHDACT(QUIET,',INTO=RECORD\n         CLC   SUBOPT_TERM_FLG,=F'8'\n         JE    CEEUOPT_TERMTHDACT1\n         STRING64 '      TERMTHDACT(MSG,',INTO=RECORD\n         CLC   SUBOPT_TERM_FLG,=F'4'\n         JE    CEEUOPT_TERMTHDACT1\n         STRING64 '      TERMTHDACT(TRACE,',INTO=RECORD\n         CLC   SUBOPT_TERM_FLG,=F'2'\n         JE    CEEUOPT_TERMTHDACT1\n         STRING64 '      TERMTHDACT(DUMP,',INTO=RECORD\nCEEUOPT_TERMTHDACT1    DS  0H\n         TM    SUBOPT_TERM_CESE,X'80'     CESE\n         JNO   CEEUOPT_TERMTHDACT2\n         STRING64 (RECORD,,T),'CESE',INTO=RECORD\n         J     CEEUOPT_TERMTHDACT3\nCEEUOPT_TERMTHDACT2    DS  0H\n         TM    SUBOPT_TERM_CESE,X'40'     CICSDDS\n         JNO   CEEUOPT_TERMTHDACT3\n         STRING64 (RECORD,,T),'CICSDDS',INTO=RECORD\nCEEUOPT_TERMTHDACT3    DS  0H\n         STRING64 (RECORD,,T),',',(SUBOPT_TERM_STOR,H,L3B),')',        X\n               INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_TERMX  DS 0H\n         DROP  R5\n         CLI   OPTION_TEST_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_TESTX                no leave\n         LR    R5,R4\n         A     R5,OPTION_TEST_SUB\n         USING SUBOPT_TEST,R5\n         STRING64 '      TEST(',INTO=RECORD\n         TM    OPTION_TEST_FLAG,X'80'\n         JO    CEEUOPT_TEST\n         STRING64 '    NOTEST(',INTO=RECORD\nCEEUOPT_TEST     DS  0H\n         CLC   SUBOPT_TEST_OPT,=F'4'\n         JNE   CEEUOPT_TEST1\n         STRING64 (RECORD,,T),'ALL,',INTO=RECORD\n         J     CEEUOPT_TEST3\nCEEUOPT_TEST1    DS  0H\n         CLC   SUBOPT_TEST_OPT,=F'2'\n         JNE   CEEUOPT_TEST3\n         STRING64 (RECORD,,T),'ERROR,',INTO=RECORD\n         BRASL R14,SPACE1\n         J     CEEUOPT_TEST3\nCEEUOPT_TEST2    DS  0H\n         STRING64 (RECORD,,T),'NONE,',INTO=RECORD\nCEEUOPT_TEST3    DS  0H\n         STRING64 (RECORD,,T),SUBOPT_TEST_CF,INTO=RECORD\n         STRING64 (RECORD,,T),',',SUBOPT_TEST_CL,INTO=RECORD\n         STRING64 (RECORD,,T),',',SUBOPT_TEST_PF,INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_TESTX  DS 0H\n         DROP  R5\n         CLI   OPTION_THRH_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_THRHX                no leave\n         LR    R5,R4\n         A     R5,OPTION_THRH_SUB\n         USING SUBOPT_THRH,R5\n         STRING64 '      THREADHEAP(',INTO=RECORD\n         STRING64 (RECORD,,T),(SUBOPT_THRH_INIT,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_THRH_INC,F,L9B),INTO=RECORD\n         TM    SUBOPT_THRH_ALLOC,X'80'  Below\n         JO    CEEUOPT_THREADHEAP1\n         STRING64 (RECORD,,T),',ANYWHERE',INTO=RECORD\n         J     CEEUOPT_THREADHEAP2\nCEEUOPT_THREADHEAP1    DS  0H\n         STRING64 (RECORD,,T),',BELOW',INTO=RECORD\nCEEUOPT_THREADHEAP2    DS  0H\n         TM    SUBOPT_THRH_ALLOC,X'40'  Free\n         JO    CEEUOPT_THREADHEAP3\n         STRING64 (RECORD,,T),',KEEP)',INTO=RECORD\n         J     CEEUOPT_THREADHEAP4\nCEEUOPT_THREADHEAP3    DS  0H\n         STRING64 (RECORD,,T),',FREE)',INTO=RECORD\nCEEUOPT_THREADHEAP4    DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_THRHX  DS 0H\n         CLI   OPTION_THRS_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_THRSX                no leave\n         LR    R5,R4\n         A     R5,OPTION_THRS_SUB\n         USING SUBOPT_THRS,R5\n         STRING64 '      THREADSTACK(',INTO=RECORD\n         STRING64 (RECORD,,T),(SUBOPT_THRS_INIT,F,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),',',(SUBOPT_THRS_INC,F,L9B),INTO=RECORD\n         TM    SUBOPT_THRS_ALLOC,X'80'  Below\n         JO    CEEUOPT_THREADSTACK1\n         STRING64 (RECORD,,T),',ANYWHERE',INTO=RECORD\n         J     CEEUOPT_THREADSTACK2\nCEEUOPT_THREADSTACK1    DS  0H\n         STRING64 (RECORD,,T),',BELOW',INTO=RECORD\nCEEUOPT_THREADSTACK2    DS  0H\n         TM    SUBOPT_THRS_ALLOC,X'40'  Free\n         JO    CEEUOPT_THREADSTACK3\n         STRING64 (RECORD,,T),',KEEP)',INTO=RECORD\n         J     CEEUOPT_THREADSTACK4\nCEEUOPT_THREADSTACK3    DS  0H\n         STRING64 (RECORD,,T),',FREE)',INTO=RECORD\nCEEUOPT_THREADSTACK4    DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_THRSX  DS 0H\n         DROP  R5\n         LR    R5,R4\n*        CLI   WKCELL1,C'1'            64bit LE-Option\n*        JNE   CEEUOPT_NOTHRS64          no leave\n         CLI   OPTION_THRS64_FLAG,X'81'     CEEUOPT specified ?\n         JNE   CEEUOPT_THRS64X              no leave\n         LR    R5,R4\n         A     R5,OPTION_THRS64_SUB\n         USING SUBOPT_THRS64,R5\n         STRING64 '      THREADSTACK64(',INTO=RECORD\n         STRING64 (RECORD,,T),(SUBOPT_THRS64_INIT,FD,L9B),INTO=RECORD\n         STRING64 (RECORD,,T),'M,',(SUBOPT_THRS64_INC,FD,L9B),         X\n               INTO=RECORD\n         STRING64 (RECORD,,T),'M,',(SUBOPT_THRS64_MAX,FD,L9B),         X\n               INTO=RECORD\n         STRING64 (RECORD,,T),'M)',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_THRS64X DS 0H\nCEEUOPT_NOTHRS64       DS  0H\n         CLI   OPTION_TRAC_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_TRACX                no leave\n         LR    R5,R4\n         A     R5,OPTION_TRAC_SUB\n         USING SUBOPT_TRAC,R5\n         STRING64 '      TRACE(ON,',INTO=RECORD\n         TM    OPTION_TRAP_FLAG,X'80'\n         JO    CEEUOPT_TRACE\n         STRING64 '      TRACE(OFF,',INTO=RECORD\nCEEUOPT_TRACE          DS  0H\n         STRING64 (RECORD,,T),(SUBOPT_TRAC_SIZE,F,L9B),INTO=RECORD\n         TM    SUBOPT_TRAC_FLG1,X'80'       DUMP\n         JO    CEEUOPT_TRACE1\n         STRING64 (RECORD,,T),',NODUMP,',INTO=RECORD\n         JO    CEEUOPT_TRACE2\nCEEUOPT_TRACE1         DS  0H\n         STRING64 (RECORD,,T),',DUMP,',INTO=RECORD\nCEEUOPT_TRACE2         DS  0H\n         STRING64 (RECORD,,T),'LE=',(SUBOPT_TRAC_GFLG,F,L9B),          X\n               INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_TRACX  DS 0H\n         DROP  R5\n         CLI   OPTION_TRAP_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_TRAPX                no leave\n         LR    R5,R4\n         A     R5,OPTION_TRAP_SUB\n         USING SUBOPT_TRAP,R5\n         STRING64 '      TRAP(ON,',INTO=RECORD\n         TM    OPTION_TRAP_FLAG,X'80'\n         JO    CEEUOPT_TRAP1\n         STRING64 '      TRAP(OFF,',INTO=RECORD\nCEEUOPT_TRAP1          DS  0H\n         TM    SUBOPT_TRAP_FLG,X'80'   SPIE ?\n         JO    CEEUOPT_TRAP2\n         STRING64 (RECORD,,T),'NOSPIE)',INTO=RECORD\n         J     CEEUOPT_TRAP3\nCEEUOPT_TRAP2          DS  0H\n         STRING64 (RECORD,,T),'SPIE)',INTO=RECORD\nCEEUOPT_TRAP3          DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_TRAPX  DS 0H\n         DROP  R5\n         CLI   OPTION_UPSI_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_UPSIX                no leave\n         LR    R5,R4\n         A     R5,OPTION_UPSI_SUB\n         USING SUBOPT_UPSI,R5\n         STRING64 '      UPSI(',SUBOPT_UPSI_SW,')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_UPSIX  DS 0H\n         DROP  R5\n         CLI   OPTION_USRH_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_USRHX                no leave\n         LR    R5,R4\n         A     R5,OPTION_USRH_SUB\n         USING SUBOPT_USRH,R5\n         STRING64 '      USRHDLR(',SUBOPT_USRH_UN1,INTO=RECORD\n         TM    OPTION_USRH_FLAG,X'80'\n         JO    CEEUOPT_USRHDLR\n         STRING64 '    NOUSRHDLR(',SUBOPT_USRH_UN1,INTO=RECORD\nCEEUOPT_USRHDLR        DS  0H\n         STRING64 (RECORD,,T),',',SUBOPT_USRH_UN2,INTO=RECORD\n         STRING64 (RECORD,,T),')',INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_USRHX  DS 0H\n         DROP  R5\n         CLI   OPTION_VCTR_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_VCTRX                no leave\n         STRING64 '      VCTRSAVE(ON)',INTO=RECORD\n         TM    OPTION_VCTR_FLAG,X'80'\n         JO    CEEUOPT_VCTRSAVE\n         STRING64 '      VCTRSAVE(OFF)',INTO=RECORD\nCEEUOPT_VCTRSAVE DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_VCTRX  DS 0H\n         CLI   OPTION_XPLI_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_XPLIX                no leave\n         STRING64 '      XPLINK(ON)',INTO=RECORD\n         TM    OPTION_XPLI_FLAG,X'80'\n         JO    CEEUOPT_XPLINK\n         STRING64 '      XPLINK(OFF)',INTO=RECORD\nCEEUOPT_XPLINK   DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_XPLIX  DS 0H\n         CLI   OPTION_XUFL_FLAG,X'81'       CEEUOPT specified ?\n         JNE   CEEUOPT_XUFLX                no leave\n         LR    R5,R4\n         A     R5,OPTION_XUFL_SUB\n         USING SUBOPT_XUFL,R5\n         STRING64 '      XUFLOW(OFF)',INTO=RECORD\n         CLC   OPTION_XUFL_FLAG,=F'4'\n         JE    CEEUOPT_XUFLOW\n         STRING64 '      XUFLOW(ON)',INTO=RECORD\n         CLC   OPTION_XUFL_FLAG,=F'2'\n         JE    CEEUOPT_XUFLOW\n         STRING64 '      XUFLOW(AUTO)',INTO=RECORD\nCEEUOPT_XUFLOW   DS  0H\n         BRASL R14,SPACE1\nCEEUOPT_XUFLX  DS 0H\n         DROP  R5\n         J     CEEUOPT_99              end\nCEEUOPT_90 DS 0H\n         STRING64 'No ','LE User Options present',INTO=RECORD\n         BRAS  R14,SPACE1\n         J     CEEUOPT_99              end\nCEEUOPT_97 DS    0H\n         STRING64 '    CEEOCB Version not valid: ',(8(R4),2,X),        X\n               INTO=RECORD\n         BRASL R14,SPACE1\n         J     CEEUOPT_99              end\nCEEUOPT_98 DS    0H\n         STRING64 '    Eyecatcher CEEOCB not valid: ',(0(R4),8),       X\n               INTO=RECORD\n         BRASL R14,SPACE1\nCEEUOPT_99   DS 0H\n         BRAS  R14,BLANK1\n         L     R14,BINDSAVE         Restore R14\n         BR    R14            return\n         DROP  R4,R8\n*------------------------------------------------------------*\n*    C/370 Program OPLINK Bit on !!!!!                       *\n*    Offset instead of relative pointer!!!                   *\n*------------------------------------------------------------*\nC_370    DS 0H\n         LR    R2,R4\n         A     R2,12(,R4)          PPA1\n         CLI   1(R2),X'CE'         Check PPA1\n         JNE   COBANAL_08            seems invalid PPA1\n         A     R4,4(,R2)           PPA2 pointer\n         LR    R2,R4\n         J     COBANAL_09          check languages\n*------------------------------------------------------------*   RS0305\n*    C/C++ New layout                                        *   RS1107\n*------------------------------------------------------------*   RS0305\nC_370_NEW DS 0H                  C/C++ or PL1?                   RS0305\n         CLC   20(2,R4),=X'CE03'    CEL C/C++?                   RS1007\n         JE    COBANAL_09A                                       RS1007\n         CLC   20(2,R4),=X'CE01'    CEL C/C++?                   RS1007\n         JE    COBANAL_09A                                       RS1007\n         CLC   20(2,R4),=X'CE0A'    CEL PL1?                     RS1007\n         JE    COBANAL_10A                                       RS1007\n         BRAS  R14,SPACE1\n         J     COBANAL_08            seems invalid               RS0305\n*------------------------------------------------------------*\n*    COBOL/370 Program                                       *\n*------------------------------------------------------------*\nENTCOBOLV5 DS 0H\n*        C_370 and Cobol V5 sharing the same CEE-Eyecatcher\n         CLC   0(4,R4),=XL4'47F0F014' Not Cobol V5               RS0316\n         JNE   C_370      looks like C                           RS0316\n         MVC   LE_TGT_WS_LENGTH,8(R4)                            RS1007\n         LR    R2,R4\n         A     R2,12(,R4)      PPA1\n         MVC   LE_PGM_NAME,BLANKS                                RS0116\n         IC    R15,57(,R2)             get length                RS0116\n         AHI   R15,-1                  -1                        RS0116\n         EX    R15,MOVE_PGM_NAME       move pgm name             RS0116\n         L     R2,44(,R4)      Options\n         USING COBOLV5_DSECT,R2\n         MVI   LE_SWITCH,C'1'\n         MVC   LE_CCSID,CV5_CCSID\n         MVC   LE_DATA_STATEMENTS,CV5_DATA_STATEMENTS\n         MVC   LE_PROC_LINES,CV5_PROC_LINES\n         XC    LE_YEAR_WINDOW,LE_YEAR_WINDOW\n         XC    LE_TGT_NO_FCB,LE_TGT_NO_FCB   No FIB for COB V5   RS0116\n*        ICM   R2,B'1111',CV5_TGT_ADDRESS    Start of data       RS1007\n*        JZ    COBOL_370_15      not present leave               RS1007\n*        USING COBOL_DAB_DSECT,R2  DAB for RENT                  RS1007\n*        CLC   CV5_DAB_EYEC,=CL4'IDBA' Test RENT                 RS1007\n*        JNE   COBOL_370_05      NORENT                          RS1007\n*        MVC   LE_DAB_FIB_OFF+1,CV5_DAB_FIB_OFF                  RS1007\n*        L     R2,CV5_DAB_TGT    TGT                             RS1007\n*        AHI   R2,6              but +6 for some reason          RS1007\n*        ST    R2,LE_TGT_ADDRESS Save for later                  RS1007\n*        USING COBOL_TGT_DSECT,R2  TGT                           RS1007\n*        MVC   LE_TGT_NO_FCB,CV5_TGT_NO_FCBS                     RS1007\n*        MVC   LE_TGT_WS_LENGTH,CV5_TGT_WS_LENGTH                RS1007\n*        MVC   LE_TGT_REG,CV5_TGT_REG                            RS1007\n*        L     R2,LE_DAB_FIB_OFF  FIB offset 3 Bytes             RS1007\n*        A     R2,CV5_PRI_EP_ADDRESS + Entry-Point               RS1007\n*        ST    R2,LE_TGT_FIB_PTR     Save for later              RS1007\n*        J     COBOL_370_15                                      RS1007\n*OBOL_370_05 DS 0H               NORENT                          RS1007\n*        ST    R2,LE_TGT_ADDRESS Save for later                  RS1007\n*        USING COBOL_TGT_DSECT,R2  TGT                           RS1007\n*        MVC   LE_TGT_NO_FCB,CV5_TGT_NO_FCBS                     RS1007\n*        MVC   LE_TGT_WS_LENGTH,CV5_TGT_WS_LENGTH                RS1007\n*        MVC   LE_TGT_REG,CV5_TGT_REG                            RS1007\n*        MVC   LE_TGT_PTR_FCB_CELL,CV5_TGT_PTR_FCB_CELL          RS1007\n*OBOL_370_15 DS 0H\n*        STRING64 'CV5_STATUS_BYTE_01 ',(CV5_STATUS_BYTE_01,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_02 ',(CV5_STATUS_BYTE_02,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_03 ',(CV5_STATUS_BYTE_03,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_04 ',(CV5_STATUS_BYTE_04,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_05 ',(CV5_STATUS_BYTE_05,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_06 ',(CV5_STATUS_BYTE_06,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_07 ',(CV5_STATUS_BYTE_07,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_08 ',(CV5_STATUS_BYTE_08,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_09 ',(CV5_STATUS_BYTE_09,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_10 ',(CV5_STATUS_BYTE_10,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_11 ',(CV5_STATUS_BYTE_11,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_12 ',(CV5_STATUS_BYTE_12,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_13 ',(CV5_STATUS_BYTE_13,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_14 ',(CV5_STATUS_BYTE_14,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_15 ',(CV5_STATUS_BYTE_15,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_16 ',(CV5_STATUS_BYTE_16,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_17 ',(CV5_STATUS_BYTE_17,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_18 ',(CV5_STATUS_BYTE_18,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_19 ',(CV5_STATUS_BYTE_19,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_20 ',(CV5_STATUS_BYTE_20,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_21 ',(CV5_STATUS_BYTE_21,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_22 ',(CV5_STATUS_BYTE_22,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_23 ',(CV5_STATUS_BYTE_23,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_24 ',(CV5_STATUS_BYTE_24,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_25 ',(CV5_STATUS_BYTE_25,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_26 ',(CV5_STATUS_BYTE_26,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_27 ',(CV5_STATUS_BYTE_27,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CV5_STATUS_BYTE_28 ',(CV5_STATUS_BYTE_28,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n         MVC   LE_STATUS_BYTE_01,CV5_STATUS_BYTE_01\n         MVC   LE_STATUS_BYTE_02,CV5_STATUS_BYTE_02\n         MVC   LE_STATUS_BYTE_03,CV5_STATUS_BYTE_03\n         MVC   LE_STATUS_BYTE_04,CV5_STATUS_BYTE_04\n         MVC   LE_STATUS_BYTE_05,CV5_STATUS_BYTE_05\n         MVC   LE_STATUS_BYTE_06,CV5_STATUS_BYTE_06\n         MVC   LE_STATUS_BYTE_07,CV5_STATUS_BYTE_07\n         MVC   LE_STATUS_BYTE_08,CV5_STATUS_BYTE_08\n         MVC   LE_STATUS_BYTE_09,CV5_STATUS_BYTE_09\n         MVC   LE_STATUS_BYTE_10,CV5_STATUS_BYTE_10\n         MVC   LE_STATUS_BYTE_11,CV5_STATUS_BYTE_11\n         MVC   LE_STATUS_BYTE_12,CV5_STATUS_BYTE_12\n         MVC   LE_STATUS_BYTE_13,CV5_STATUS_BYTE_13\n         MVC   LE_STATUS_BYTE_14,CV5_STATUS_BYTE_14\n         MVC   LE_STATUS_BYTE_15,CV5_STATUS_BYTE_15\n         MVC   LE_STATUS_BYTE_16,CV5_STATUS_BYTE_16\n         MVC   LE_STATUS_BYTE_17,CV5_STATUS_BYTE_17\n         MVC   LE_STATUS_BYTE_18,CV5_STATUS_BYTE_18\n         MVC   LE_STATUS_BYTE_19,CV5_STATUS_BYTE_19\n         MVC   LE_STATUS_BYTE_20,CV5_STATUS_BYTE_20\n         MVC   LE_STATUS_BYTE_21,CV5_STATUS_BYTE_21\n         MVC   LE_STATUS_BYTE_22,CV5_STATUS_BYTE_22\n         MVC   LE_STATUS_BYTE_23,CV5_STATUS_BYTE_23\n         MVC   LE_STATUS_BYTE_24,CV5_STATUS_BYTE_24\n         MVC   LE_STATUS_BYTE_25,CV5_STATUS_BYTE_25\n         MVC   LE_STATUS_BYTE_26,CV5_STATUS_BYTE_26\n         MVC   LE_STATUS_BYTE_27,CV5_STATUS_BYTE_27\n         MVC   LE_STATUS_BYTE_28,CV5_STATUS_BYTE_28\n         MVC   LE_STATUS_BYTE_29,CV5_STATUS_BYTE_29\n         MVC   LE_STATUS_BYTE_30,CV5_STATUS_BYTE_30\n         MVC   LE_STATUS_BYTE_31,CV5_STATUS_BYTE_31\n         MVC   LE_ARCHLEVEL,CV5_ARCHLEVEL\n         MVC   LE_OPT_LEVEL,CV5_OPT_LEVEL\n         MVC   LE_BUILD_LEVEL,CV5_BUILD_LEVEL  only for Cobol V6 RS0316\n         LR    R1,R4             Entry Point\n         A     R1,12(,R4)        PPA1\n         LR    R2,R4             Entry Point\n         A     R2,4(,R1)         Offset to PPA2 from PPA1\n         A     R2,12(,R2)        Timestamp string\n         USING COBOLV5_COMP_INFO,R2\n         MVC   LE_COMP_DAY,CV5_COMP_DAY\n         MVC   LE_COMP_MONTH,CV5_COMP_MONTH\n         MVC   LE_COMP_YEAR,CV5_COMP_YEAR\n         MVC   LE_COMP_HOURS,CV5_COMP_HOURS\n         MVC   LE_COMP_MIN,CV5_COMP_MIN\n         MVC   LE_COMP_SEC,CV5_COMP_SEC\n         MVC   LE_VERS,CV5_VERS\n         MVC   LE_REL,CV5_REL\n         MVC   LE_MOD,CV5_MOD\n         J     LE370_INFO\n*------------------------------------------------------------*\n*    COBOL/370 Program                                       *\n*------------------------------------------------------------*\nCOBOL_370 DS 0H\n         USING COBOL_370_DSECT,R4\n         LR    R2,R4\n         A     R2,12(,R4)          PPA1\n         CLI   1(R2),X'CE'         Check PPA1\n         JNE   COBANAL_08            seems invalid PPA1\n         ICM   R2,B'1111',4(R2)    PPA2 pointer\n         JZ    COBANAL_08            seems invalid PPA2\n         CLI   0(R2),X'05'         ID = Cobol!! (05)\n         JNE   COBANAL_09            no, error\n         MVI   LE_SWITCH,C'1'\n         L     R4,CEE_PRI_EP_ADDRESS\n         MVC   LE_VERS,CEE_VERS\n         MVC   LE_REL,CEE_REL\n         MVC   LE_MOD,CEE_MOD\n         MVC   LE_CCSID,CEE_CCSID\n         MVC   LE_PGM_NAME,CEE_PGM_NAME\n         MVC   LE_COMP_DAY,CEE_COMP_DAY\n         MVC   LE_COMP_MONTH,CEE_COMP_MONTH\n         MVC   LE_COMP_YEAR,CEE_COMP_YEAR\n         MVC   LE_COMP_HOURS,CEE_COMP_HOURS\n         MVC   LE_COMP_MIN,CEE_COMP_MIN\n         MVC   LE_COMP_SEC,CEE_COMP_SEC\n         MVC   LE_DATA_STATEMENTS,CEE_DATA_STATEMENTS\n         MVC   LE_PROC_LINES,CEE_PROC_LINES\n         MVC   LE_YEAR_WINDOW,CEE_YEAR_WINDOW\n         ICM   R2,B'1111',CEE_TGT_ADDRESS    Start of data       RS1007\n         JZ    COBOL_370_15      not present leave               RS1007\n         USING COBOL_DAB_DSECT,R2  DAB for RENT                  RS1007\n         CLC   CEE_DAB_EYEC,=CL4'IDBA' Test RENT                 RS1007\n         JNE   COBOL_370_05      NORENT                          RS1007\n         MVC   LE_DAB_FIB_OFF+1,CEE_DAB_FIB_OFF                  RS1007\n         L     R2,CEE_DAB_TGT    TGT                             RS1007\n         AHI   R2,6              but +6 for some reason          RS1007\n         ST    R2,LE_TGT_ADDRESS Save for later                  RS1007\n         USING COBOL_TGT_DSECT,R2  TGT                           RS1007\n         MVC   LE_TGT_NO_FCB,CEE_TGT_NO_FCBS                     RS1007\n         MVC   LE_TGT_WS_LENGTH,CEE_TGT_WS_LENGTH                RS1007\n         MVC   LE_TGT_REG,CEE_TGT_REG                            RS1007\n         L     R2,LE_DAB_FIB_OFF  FIB offset 3 Bytes             RS1007\n         A     R2,CEE_PRI_EP_ADDRESS + Entry-Point               RS1007\n         ST    R2,LE_TGT_FIB_PTR     Save for later              RS1007\n         J     COBOL_370_15                                      RS1007\nCOBOL_370_05 DS 0H               NORENT                          RS1007\n         ST    R2,LE_TGT_ADDRESS Save for later                  RS1007\n         USING COBOL_TGT_DSECT,R2  TGT                           RS1007\n         MVC   LE_TGT_NO_FCB,CEE_TGT_NO_FCBS                     RS1007\n         MVC   LE_TGT_WS_LENGTH,CEE_TGT_WS_LENGTH                RS1007\n         MVC   LE_TGT_REG,CEE_TGT_REG                            RS1007\n         MVC   LE_TGT_PTR_FCB_CELL,CEE_TGT_PTR_FCB_CELL          RS1007\nCOBOL_370_15 DS 0H\n         DROP  R2\n*        STRING64 'CEE_STATUS_BYTE_01 ',(CEE_STATUS_BYTE_01,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_02 ',(CEE_STATUS_BYTE_02,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_03 ',(CEE_STATUS_BYTE_03,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_04 ',(CEE_STATUS_BYTE_04,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_05 ',(CEE_STATUS_BYTE_05,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_06 ',(CEE_STATUS_BYTE_06,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_07 ',(CEE_STATUS_BYTE_07,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_08 ',(CEE_STATUS_BYTE_08,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_09 ',(CEE_STATUS_BYTE_09,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_10 ',(CEE_STATUS_BYTE_10,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_11 ',(CEE_STATUS_BYTE_11,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_12 ',(CEE_STATUS_BYTE_12,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_13 ',(CEE_STATUS_BYTE_13,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_14 ',(CEE_STATUS_BYTE_14,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_15 ',(CEE_STATUS_BYTE_15,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_16 ',(CEE_STATUS_BYTE_16,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_17 ',(CEE_STATUS_BYTE_17,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_18 ',(CEE_STATUS_BYTE_18,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_19 ',(CEE_STATUS_BYTE_19,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_20 ',(CEE_STATUS_BYTE_20,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_21 ',(CEE_STATUS_BYTE_21,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_22 ',(CEE_STATUS_BYTE_22,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_23 ',(CEE_STATUS_BYTE_23,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_24 ',(CEE_STATUS_BYTE_24,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_25 ',(CEE_STATUS_BYTE_25,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_26 ',(CEE_STATUS_BYTE_26,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_27 ',(CEE_STATUS_BYTE_27,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n*        STRING64 'CEE_STATUS_BYTE_28 ',(CEE_STATUS_BYTE_28,,X),       X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n         MVC   LE_STATUS_BYTE_01,CEE_STATUS_BYTE_01\n         MVC   LE_STATUS_BYTE_02,CEE_STATUS_BYTE_02\n         MVC   LE_STATUS_BYTE_03,CEE_STATUS_BYTE_03\n         MVC   LE_STATUS_BYTE_04,CEE_STATUS_BYTE_04\n         MVC   LE_STATUS_BYTE_05,CEE_STATUS_BYTE_05\n         MVC   LE_STATUS_BYTE_06,CEE_STATUS_BYTE_06\n         MVC   LE_STATUS_BYTE_07,CEE_STATUS_BYTE_07\n         MVC   LE_STATUS_BYTE_08,CEE_STATUS_BYTE_08\n         MVC   LE_STATUS_BYTE_09,CEE_STATUS_BYTE_09\n         MVC   LE_STATUS_BYTE_10,CEE_STATUS_BYTE_10\n         MVC   LE_STATUS_BYTE_11,CEE_STATUS_BYTE_11\n         MVC   LE_STATUS_BYTE_12,CEE_STATUS_BYTE_12\n         MVC   LE_STATUS_BYTE_13,CEE_STATUS_BYTE_13\n         MVC   LE_STATUS_BYTE_14,CEE_STATUS_BYTE_14\n         MVC   LE_STATUS_BYTE_15,CEE_STATUS_BYTE_15\n         MVC   LE_STATUS_BYTE_16,CEE_STATUS_BYTE_16\n         MVC   LE_STATUS_BYTE_17,CEE_STATUS_BYTE_17\n         MVC   LE_STATUS_BYTE_18,CEE_STATUS_BYTE_18\n         MVC   LE_STATUS_BYTE_19,CEE_STATUS_BYTE_19\n         MVC   LE_STATUS_BYTE_20,CEE_STATUS_BYTE_20\n         MVC   LE_STATUS_BYTE_21,CEE_STATUS_BYTE_21\n         MVC   LE_STATUS_BYTE_22,CEE_STATUS_BYTE_22\n         MVC   LE_STATUS_BYTE_23,CEE_STATUS_BYTE_23\n         MVC   LE_STATUS_BYTE_24,CEE_STATUS_BYTE_24\n         MVC   LE_STATUS_BYTE_25,CEE_STATUS_BYTE_25\n         MVC   LE_STATUS_BYTE_26,CEE_STATUS_BYTE_26\n         MVC   LE_STATUS_BYTE_27,CEE_STATUS_BYTE_27\n         MVC   LE_STATUS_BYTE_28,CEE_STATUS_BYTE_28\n         MVC   LE_STATUS_BYTE_29,CEE_STATUS_BYTE_29\n         J     LE370_INFO\n*------------------------------------------------------------*\n*    COBOL/2 Program                                         *\n*------------------------------------------------------------*\nCOBOL_2 DS 0H\n         USING COBOL_2_DSECT,R4\n         MVI   LE_SWITCH,C'2'\n         L     R4,C2_GET_ENTRY\n         L     R4,0(R4)\n         L     R2,92(R4)          VS/COBOL II TGT                RS1107\n         LTR   R2,R2              Check TGT                      RS1107\n         JZ    COBOL_2_15        not present leave               RS1107\n*>---------------------------------------------------------------HP1107\n*        st    r2,c2_tgt                                         HP1107\n*>---------------------------------------------------------------HP1107\n         USING COBOL_DAB_DSECT,R2  DAB for RENT                  RS1107\n         CLC   CEE_DAB_EYEC,=CL4'IDBA' Test RENT                 RS1107\n         JNE   COBOL_2_05        NORENT                          RS1107\n         MVC   LE_DAB_FIB_OFF+1,CEE_DAB_FIB_OFF                  RS1107\n         L     R2,CEE_DAB_TGT    TGT                             RS1107\n         AHI   R2,6              but +6 for some reason          RS1107\n         ST    R2,LE_TGT_ADDRESS Save for later                  RS1107\n         USING COBOL_TGT_DSECT,R2  TGT                           RS1107\n         MVC   LE_TGT_NO_FCB,CEE_TGT_NO_FCBS                     RS1107\n         MVC   LE_TGT_WS_LENGTH,CEE_TGT_WS_LENGTH                RS1107\n         XC    LE_TGT_REG,LE_TGT_REG   clear                     RS1107\n         L     R2,LE_DAB_FIB_OFF  FIB offset 3 Bytes             RS1107\n         A     R2,C2_PRI_EP_ADDRESS + Entry-Point                RS1107\n         ST    R2,LE_TGT_FIB_PTR     Save for later              RS1107\n         J     COBOL_2_15                                        RS1107\nCOBOL_2_05   DS 0H               NORENT                          RS1107\n         ST    R2,LE_TGT_ADDRESS Save for later                  RS1107\n         USING COBOL_TGT_DSECT,R2  TGT                           RS1107\n         MVC   LE_TGT_NO_FCB,CEE_TGT_NO_FCBS                     RS1107\n         MVC   LE_TGT_WS_LENGTH,CEE_TGT_WS_LENGTH                RS1107\n         XC    LE_TGT_REG,LE_TGT_REG   clear                     RS1107\n         MVC   LE_TGT_PTR_FCB_CELL,CEE_TGT_PTR_FCB_CELL          RS1107\nCOBOL_2_15   DS 0H\n         MVC   LE_VERS,C2_VERS\n         MVC   LE_REL,C2_REL\n         MVC   LE_MOD,C2_MOD\n         MVC   LE_PGM_NAME,C2_PGM_NAME\n         MVC   LE_COMP_DAY,C2_COMP_DAY\n         MVC   LE_COMP_MONTH,C2_COMP_MONTH\n*        MVC   LE_COMP_YEAR(2),=C'??'    COBOL2 not Y2K ready    JK1107\n         MVC   LE_COMP_YEAR(2),=C'19'    Assume 19xx             JK1107\n         CLC   C2_COMP_YEAR,=C'66'       Y2K?                    JK1107\n         BNL   COBOL_2_DATE              No                      JK1107\n         MVC   LE_COMP_YEAR(2),=C'20'    Yes                     JK1107\nCOBOL_2_DATE DS 0H                                               JK1107\n         MVC   LE_COMP_YEAR+2(2),C2_COMP_YEAR\n         MVC   LE_COMP_HOURS,C2_COMP_HOURS\n         MVC   LE_COMP_MIN,C2_COMP_MIN\n         MVC   LE_COMP_SEC,C2_COMP_SEC\n         MVC   LE_DATA_STATEMENTS,C2_DATA_STATEMENTS\n         MVC   LE_PROC_LINES,C2_PROC_LINES\n         MVC   LE_STATUS_BYTE_01,C2_STATUS_BYTE_01\n         MVC   LE_STATUS_BYTE_02,C2_STATUS_BYTE_02\n         MVC   LE_STATUS_BYTE_03,C2_STATUS_BYTE_03\n         MVC   LE_STATUS_BYTE_04,C2_STATUS_BYTE_04\n         MVC   LE_STATUS_BYTE_05,C2_STATUS_BYTE_05\n         MVC   LE_STATUS_BYTE_06,C2_STATUS_BYTE_06\n         MVC   LE_STATUS_BYTE_07,C2_STATUS_BYTE_07\n         MVC   LE_STATUS_BYTE_08,C2_STATUS_BYTE_08\n         MVC   LE_STATUS_BYTE_09,C2_STATUS_BYTE_09\n         MVC   LE_STATUS_BYTE_10,C2_STATUS_BYTE_10\n         MVC   LE_STATUS_BYTE_11,C2_STATUS_BYTE_11\n         MVC   LE_STATUS_BYTE_12,C2_STATUS_BYTE_12\n         MVC   LE_STATUS_BYTE_13,C2_STATUS_BYTE_13\n         MVC   LE_STATUS_BYTE_14,C2_STATUS_BYTE_14\n         MVC   LE_STATUS_BYTE_15,C2_STATUS_BYTE_15\n         MVC   LE_STATUS_BYTE_16,C2_STATUS_BYTE_16\n         MVC   LE_STATUS_BYTE_17,C2_STATUS_BYTE_17\n         MVC   LE_STATUS_BYTE_18,C2_STATUS_BYTE_18\n         MVC   LE_STATUS_BYTE_19,C2_STATUS_BYTE_19\n         MVC   LE_STATUS_BYTE_20,C2_STATUS_BYTE_20\n         MVC   LE_STATUS_BYTE_21,C2_STATUS_BYTE_21\n         MVC   LE_STATUS_BYTE_22,C2_STATUS_BYTE_22\n         MVC   LE_STATUS_BYTE_23,C2_STATUS_BYTE_23\n         MVC   LE_STATUS_BYTE_24,C2_STATUS_BYTE_24\n         MVC   LE_STATUS_BYTE_25,C2_STATUS_BYTE_25\n         CLI   CSECT_ANALYZE_KZ,C'M' First csect (main-ep)?      PF0608\n         JNE   LE370_INFO            No,don't set CSCLANG or cnt PF0608\n         AP    CNT_COBOL2,=P'1'          Increment counter        *CSC*\n         MVC   CSCLANG(9),=CL9'COBOL'                             *CSC*\n         J     LE370_INFO\n*------------------------------------------------------------*\n* OS/VS COBOL   Program                                      *\n*------------------------------------------------------------*\nCOBOL_1 DS 0H\n         USING COBOL_1_DSECT,R4\n         MVI   LE_SWITCH,C'3'\n         MVC   LE_VERS,BLANKS\n         MVC   LE_REL,C1_REL\n         MVC   LE_MOD,BLANKS\n         MVC   LE_PGM_NAME,C1_PGM_NAME\n         MVC   LE_COMP_DAY,C1_COMP_DAY\n         MVC   LE_COMP_MONTH,C1_COMP_MONTH\n         MVC   LE_COMP_YEAR,C1_COMP_YEAR\n         MVC   LE_COMP_HOURS,C1_COMP_HOURS\n         MVC   LE_COMP_MIN,C1_COMP_MIN\n         MVC   LE_COMP_SEC,C1_COMP_SEC\n         CLI   csect_analyze_kz,C'M' first csect (main-ep)       RS0108\n         JNE   COBOL_1_05            don't set CSCCOMP           RS0108\n         AP    CNT_COBOLI,=P'1'          Increment counter       PF0608\n         MVC   CSCLANG(9),=CL9'COBOL'                             *CSC*\n         STRING64 'OS/VS/COBOL ',C1_EYECATCHER,C1_REL,INTO=CSCCOMP CSC*\nCOBOL_1_05 DS 0H                                                 RS0108\n         L     R5,C1_TGT_PTR\n         USING COBOL_1_TGT,R5\n         CLC   C1_CHECK,=CL8'SYSOUT'     check\n         JE    LE370_INFO\n*\n*        UNABLE TO FIND THE TASK GLOBAL TABLE  -\n*\nNOTTGT   DS    0H\n         STRING64 'Program ',PGMNAME_GET,' failed the TGT (Task Global'X\n               'Table) test',INTO=RECORD\n         BRAS  R14,SPACE2\n         LA    R15,8\n         J     COBANAL_EXIT\nLE370_INFO DS  0H\n*>---------------------------------------------------------------HP1107\n         MVI   PRINT_LEAD_SPACE,C'N' Insert space                HP1107\n         CLI   csect_analyze_kz,C'M' first csect (main-ep)       HP1107\n         je    LE370_INFO_0                                      HP1107\n         STRING64 '------------ This module is an included Member ---',X\n               '---------------------------------------------------',  X\n               INTO=RECORD\n         BRAS  R14,SPACE2\n         mvc   PGMNAME_GET,LE_PGM_NAME                           HP1107\n         MVI   PRINT_LEAD_SPACE,C'Y' Insert space                HP1107\nLE370_INFO_0 DS  0H                                              HP1107\n*>---------------------------------------------------------------HP1107\n         STRING64 '------------ Info --------------------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD\n         BRAS  R14,SPACE2\n         MVC   JUSTDATA_LANG,=CL8'COBOL'                          =CMS=\n         MVC   JUSTDATA_PGM,LE_PGM_NAME                           =CMS=\n         MVC   JUSTDATA_VV,LE_VERS                                =CMS=\n         MVC   JUSTDATA_RR,LE_REL                                 =CMS=\n         MVC   JUSTDATA_MM,LE_MOD                                 =CMS=\n         CLI   LE_SWITCH,C'1'\n         JNE   JUMP_AROUND_1\n         STRING64 'Program: ',PGMNAME_GET,' is COBOL/370 Version ',    X\n               LE_VERS,                                                X\n               ' Release ',LE_REL,' Mod-Level ',LE_MOD,INTO=RECORD\n         MVC   JUSTDATA_COMPILER,=C'COBOL370'                     =CMS=\n         CLI   csect_analyze_kz,C'M' first csect (main-ep)       RS1107\n         JNE   LE370_INFO_0V         don't set CSCCOMP           RS1107\n         AP    CNT_COBOLLE,=P'1'         Increment counter       PF0608\n         MVC   CSCLANG(9),=CL9'COBOL'                            PF0608\n         STRING64 'COBOL/370 ',                                   *CSC*X\n               'V',(LE_VERS+1,1),                                 *CSC*X\n               '.',(LE_REL+1,1),                                  *CSC*X\n               '.',(LE_MOD+1,1),                                  *CSC*X\n               INTO=CSCCOMP                                       *CSC*\nLE370_INFO_0V DS  0H                                             RS1107\n         CLC   LE_VERS(4),=C'0301'  Vers+Rel < 0301 COBOL V3R1\n         JL    JUMP_AROUND_2         yes\n         STRING64 'Program: ',PGMNAME_GET,' is COBOL Enterprise',      X\n               ' Version ',LE_VERS,                                    X\n               ' Release ',LE_REL,' Mod-Level ',LE_MOD,INTO=RECORD\n         MVC   JUSTDATA_COMPILER,=C'ECOBOL  '                     =CMS=\n         CLI   csect_analyze_kz,C'M' first csect (main-ep)       RS1107\n         JNE   LE370_INFO_0W         don't set CSCCOMP           RS1107\n         STRING64 'COBOL/ENT ',                                   *CSC*X\n               'V',(LE_VERS+1,1),                                 *CSC*X\n               '.',(LE_REL+1,1),                                  *CSC*X\n               '.',(LE_MOD+1,1),                                  *CSC*X\n               INTO=CSCCOMP                                       *CSC*\nLE370_INFO_0W DS  0H                                             RS1107\n         J     JUMP_AROUND_2\nJUMP_AROUND_1 DS 0H\n         MVC   JUSTDATA_COMPILER,=C'VSCOBOL2'                     =CMS=\n         CLI   csect_analyze_kz,C'M' first csect (main-ep)       RS1107\n         JNE   LE370_INFO_0X         don't set CSCCOMP           RS1107\n         MVC   CSCLANG(9),=CL9'COBOL'                            PF0608\n         STRING64 'VS/COBOL2 ',                                   *CSC*X\n               'V',(LE_VERS,1),                                   *CSC*X\n               '.',(LE_REL,1),                                    *CSC*X\n               '.',(LE_MOD,1),                                    *CSC*X\n               INTO=CSCCOMP                                       *CSC*\nLE370_INFO_0X DS  0H                                             RS1107\n         STRING64 'Program: ',PGMNAME_GET,' is COBOL/2 Version ',      X\n               LE_VERS,' Release ',LE_REL,' Mod-Level ',LE_MOD,        X\n               INTO=RECORD\n         CLI   LE_SWITCH,C'2'\n         JE    JUMP_AROUND_2\n         CLI   csect_analyze_kz,C'M' first csect (main-ep)       RS1107\n         JNE   LE370_INFO_0Y         don't set CSCCOMP           RS1107\n         STRING64 'OS/VS/COBOL ',C1_EYECATCHER,C1_REL,INTO=CSCCOMP *CSC\nLE370_INFO_0Y DS  0H                                             RS1107\n         STRING64 'Program: ',PGMNAME_GET,' is OS/VS COBOL Release ',  X\n               LE_REL,                                                 X\n               INTO=RECORD\n         MVC   JUSTDATA_COMPILER,=C'OSVSCBL '                     =CMS=\nJUMP_AROUND_2 DS 0H\n         BRAS  R14,SPACE2\n         STRING64 '------------ Timestamps --------------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD\n         BRAS  R14,SPACE2\n         STRING64 'Compiled program name ',LE_PGM_NAME,INTO=RECORD\n         BRAS  R14,SPACE1\n         BRAS  R9,LE_370_12\nMMM_TBL  DC    CL2'01',CL3'Jan',CL3'JAN'  Long name\n#MMM_TBL EQU   *-MMM_TBL\n         DC    CL2'02',CL3'Feb',CL3'FEB'  for our non-european user\n         DC    CL2'03',CL3'Mar',CL3'MAR'\n         DC    CL2'04',CL3'Apr',CL3'APR'\n         DC    CL2'05',CL3'May',CL3'MAY'\n         DC    CL2'06',CL3'Jun',CL3'JUN'\n         DC    CL2'07',CL3'Jul',CL3'JUL'\n         DC    CL2'08',CL3'Aug',CL3'AUG'\n         DC    CL2'09',CL3'Sep',CL3'SEP'\n         DC    CL2'10',CL3'Oct',CL3'OCT'                          *CSC*\n         DC    CL2'11',CL3'Nov',CL3'NOV'\n         DC    CL2'12',CL3'Dec',CL3'DEC'\n         DC    X'0000',CL3'n/a',CL3'N/A'    end of table\nLE_370_12 DS   0H\n         CLC   LE_COMP_MONTH(2),0(R9)         check properties\n         JE    LE_370_14               jump if on\n         CLC   LE_COMP_MONTH,5(R9)     Matching for OS/VS month   =CMS=\n         JE    LE_370_14               jump if found              =CMS=\n         LA    R9,#MMM_TBL(,R9)        Skip entry\n         CLI   0(R9),0                 end of table?\n         JNE   LE_370_12               not yet, loop\nLE_370_14 DS   0H\n         MVC   JUSTDATA_LE_CYEAR,LE_COMP_YEAR                     =CMS=\n         CLC   JUSTDATA_LE_CYEAR,=C'1950'          OSVS fixup     =CMS=\n         JH    AROUND_A                                           =CMS=\n         MVC   JUSTDATA_LE_CYEAR(2),=C'20'                        =CMS=\nAROUND_A EQU   *                                                  =CMS=\n         MVC   JUSTDATA_LE_CMONTH,0(R9)                           =CMS=\n         MVC   JUSTDATA_LE_CDAY,LE_COMP_DAY                       =CMS=\n         CLI   JUSTDATA_LE_CDAY,C' '               OSVS fixup     =CMS=\n         JNE   AROUND_B                                           =CMS=\n         MVI   JUSTDATA_LE_CDAY,C'0'                              =CMS=\nAROUND_B EQU   *                                                  =CMS=\n         MVC   JUSTDATA_LE_CHOURS,LE_COMP_HOURS                   =CMS=\n         CLI   JUSTDATA_LE_CHOURS,C' '             OSVS fixup     =CMS=\n         JNE   AROUND_C                                           =CMS=\n         MVI   JUSTDATA_LE_CHOURS,C'0'                            =CMS=\nAROUND_C EQU   *                                                  =CMS=\n         MVC   JUSTDATA_LE_CMIN,LE_COMP_MIN                       =CMS=\n         MVC   JUSTDATA_LE_CSEC,LE_COMP_SEC                       =CMS=\n         STRING64 'Date: ',LE_COMP_DAY,'.',(LE_COMP_MONTH,2),'.',      X\n               LE_COMP_YEAR,' (european) ',LE_COMP_DAY,'.',            X\n               (2(R9),3,T),'.',LE_COMP_YEAR,' (long) ',                X\n               ' Time: ',LE_COMP_HOURS,':',LE_COMP_MIN,                X\n               ':',LE_COMP_SEC,INTO=RECORD\n         CLI   CSECT_ANALYZE_KZ,C'M' First csect (main-ep)?      PF0608\n         JNE   LE_370_14A            No,don't set CSCDATE        PF0608\n         STRING64 LE_COMP_DAY,'.',(2(R9),3,T),'.',LE_COMP_YEAR,   *CSC*X\n               INTO=CSCDATE\nLE_370_14A DS   0H                                               PF0608\n         BRAS  R14,JUSTDATA_PUT                                   =CMS=\n         CLI   LE_SWITCH,C'3'    OS/VS COBOL ?\n         JNE   JUMP_AROUND_3       no, go ahead\n         STRING64 'Date: ',LE_COMP_DAY,'.',LE_COMP_MONTH,'.',          X\n               LE_COMP_YEAR,' Time: ',LE_COMP_HOURS,':',LE_COMP_MIN,   X\n               ':',LE_COMP_SEC,INTO=RECORD\n         BRAS  R14,SPACE2\n         ST    R4,SAVER4             Save for re-addressability  PF0708\n         CLI   CSECT_ANALYZE_KZ,C'M' First csect (main-ep)?      PF0708\n         JNE   INFO_COBOL            No,don't set CSCDATE        PF0708\n         STRING64 LE_COMP_DAY,'.',LE_COMP_MONTH,'.',LE_COMP_YEAR, *CSC*X\n               INTO=CSCDATE\n*        ST    R4,SAVER4             Save for re-addressability  PF0708\n*        J     CICS                  Check CICS and then no more! *CSC*\n         DROP  R4\n         J     INFO_COBOL            sorry no more information\nJUMP_AROUND_3 DS 0H\n         BRAS  R14,SPACE2\n         STRING64 '------------ Statistics --------------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD\n         BRAS  R14,SPACE2\n         STRING64 'Number of data items  : ',                          X\n               (LE_DATA_STATEMENTS,F,R7B),INTO=RECORD\n         BRAS  R14,SPACE1\n         STRING64 'Number of instructions: ',(LE_PROC_LINES,F,R7B),    X\n               INTO=RECORD\n         BRAS  R14,SPACE2\n         STRING64 '------------ Options in effect -------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD\n         BRAS  R14,SPACE2\n         MVC   RECORD,BLANKS\n         LA    R15,RECORD\n         MVC   1(3,R15),=C'ADV'\n         TM    LE_STATUS_BYTE_01,BIT0\n         JO    LE_370_15_#1                                       *CSC*\n         MVC   1(5,R15),=C'NOADV'\nLE_370_15_#1 DS 0H                                                *CSC*\n         LA    R15,9(R15)                                        RS1007\n         MVC   0(5,R15),=C'APOST'\n         TM    LE_STATUS_BYTE_01,BIT1\n         JO    LE_370_15_#2                                       *CSC*\n         MVC   0(5,R15),=C'QUOTE'\nLE_370_15_#2 DS 0H                                                *CSC*\n* The COBANAL SUMMARY report is only generated for Mainline      SS0615\n* modules. As DATA \"31\"/\"24\" reporting appears in SUMMARY we     SS0615\n* need to ensure that we only set DATA \"31\" or \"24\" in CSCD31 if SS0615\n* this is a Mainline module and not a subroutine.                SS0615\n         MVC   RECORD+17(9),=CL9'DATA(31)'                       RS1007\n         CLI   CSECT_ANALYZE_KZ,C'M' First csect (main-ep)?      PF0608\n         JNE   LE_370_15_#21         No,don't set CSCD31         SS0615\n         MVC   CSCD31(2),=CL3'31'                                 *CSC*\nLE_370_15_#21 DS 0H                                              SS0615\n         TM    LE_STATUS_BYTE_01,BIT2\n         JO    LE_370_15_#3                                       *CSC*\n         MVC   RECORD+17(9),=CL9'DATA(24)'                       RS1007\n         CLI   CSECT_ANALYZE_KZ,C'M' First csect (main-ep)?      SS0615\n         JNE   LE_370_15_#3          No,don't set CSCD31         SS0615\n         MVC   CSCD31(2),=CL3'24'                                 *CSC*\nLE_370_15_#3 DS 0H                                                *CSC*\n         MVC   RECORD+27(6),=CL6'DECK'                           RS1007\n         TM    LE_STATUS_BYTE_01,BIT3\n         JO    LE_370_15_#4                                       *CSC*\n         MVC   RECORD+27(6),=CL6'NODECK'                         RS1007\nLE_370_15_#4 DS 0H                                                *CSC*\n         MVC   RECORD+36(6),=CL6'DUMP'                           RS1007\n         TM    LE_STATUS_BYTE_01,BIT4\n         JO    LE_370_15_#5                                       *CSC*\n         MVC   RECORD+36(6),=CL6'NODUMP'                         RS1007\nLE_370_15_#5 DS 0H                                                *CSC*\n         MVC   RECORD+44(8),=CL8'DYNAM'                          RS1007\n         TM    LE_STATUS_BYTE_01,BIT5\n         JO    LE_370_15_#6                                       *CSC*\n         MVC   RECORD+44(8),=CL8'NODYNAM'                        RS1007\nLE_370_15_#6 DS 0H                                                *CSC*\n         MVC   RECORD+55(10),=CL10'FASTSRT'                      RS1007\n         TM    LE_STATUS_BYTE_01,BIT6\n         JO    LE_370_15_#7                                       *CSC*\n         MVC   RECORD+55(10),=CL10'NOFASTSRT'                    RS1007\nLE_370_15_#7 DS 0H                                                *CSC*\n         CLC   LE_VERS(4),=C'0501'  Vers+Rel < 0501 E.Cob V5.1   RS1015\n         JL    LE_370_15_#8          no                          RS1015\n         MVC   RECORD+66(8),=CL8'SQLIMS'                         RS1015\n         TM    LE_STATUS_BYTE_01,BIT7                            RS1015\n         JO    LE_370_15_#8                                      RS1015\n         MVC   RECORD+66(8),=CL8'NOSQLIMS'                       RS1015\nLE_370_15_#8   DS 0H                                             RS1015\n         CLI   LE_SWITCH,C'1'   COBOL/370 FDUMP not valid        RS0705\n         JE    LE_370_17                                         RS0705\n         MVC   RECORD+66(8),=CL8'FDUMP'                          RS1007\n         TM    LE_STATUS_BYTE_01,BIT7\n         JO    LE_370_17                                          *CSC*\n         MVC   RECORD+66(8),=CL8'NOFDUMP'\nLE_370_17 DS 0H                                                  RS0705\n         MVC   RECORD+76(6),=CL6'LIB'                            RS1007\n         TM    LE_STATUS_BYTE_02,BIT0                            RS1007\n         JO    LE_370_17_#1                                      RS1007\n         MVC   RECORD+76(6),=CL6'NOLIB'                          RS1007\nLE_370_17_#1 DS 0H                                               RS1007\n         MVC   RECORD+92(7),=CL7'LIST'                           RS1007\n         TM    LE_STATUS_BYTE_02,BIT1                            RS1007\n         JO    LE_370_17_#2                                      RS1007\n         MVC   RECORD+92(7),=CL7'NOLIST'                         RS1007\nLE_370_17_#2 DS 0H                                               RS1007\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(3),=CL3'MAP'                             RS1007\n         TM    LE_STATUS_BYTE_02,BIT2\n         JO    LE_370_17_#3                                       *CSC*\n         MVC   RECORD+1(5),=CL5'NOMAP'                           RS1007\nLE_370_17_#3 DS 0H                                                *CSC*\n         MVC   RECORD+9(6),=CL6'NUM'                             RS1007\n         TM    LE_STATUS_BYTE_02,BIT3\n         JO    LE_370_17_#4                                       *CSC*\n         MVC   RECORD+9(6),=CL6'NONUM'                           RS1007\nLE_370_17_#4 DS 0H                                                *CSC*\n         MVC   RECORD+17(6),=CL6'OBJ'\n         TM    LE_STATUS_BYTE_02,BIT4\n         JO    LE_370_17_#5                                       *CSC*\n         MVC   RECORD+17(6),=CL6'NOOBJ'                          RS1007\nLE_370_17_#5 DS 0H                                                *CSC*\n         MVC   RECORD+27(8),=CL8'OFFSET'                         RS1007\n         TM    LE_STATUS_BYTE_02,BIT5\n         JO    LE_370_17_#6                                       *CSC*\n         MVC   RECORD+27(8),=CL8'NOOFFSET'                       RS1007\nLE_370_17_#6 DS 0H                                                *CSC*\n         MVC   RECORD+36(10),=CL10'OPTIMIZE'                     RS1007\n         TM    LE_STATUS_BYTE_02,BIT6\n         JO    LE_370_17_#7                                       *CSC*\n         MVC   RECORD+36(10),=CL10'NOOPTIMIZE'                   RS1007\nLE_370_17_#7 DS 0H                                                *CSC*\n         CLI   LE_SWITCH,C'1'   COBOL/370\n         JNE   LE_370_18\n         CLC   LE_VERS(4),=C'0301'  Vers+Rel < 0301 COBOL V3R1\n         JL    LE_370_18             yes\n         MVC   RECORD+55(18),=CL18'OUTDD(SYSOUT)'                RS1007\n         TM    LE_STATUS_BYTE_02,BIT7\n         JO    LE_370_19                                         RS1007\n         MVC   RECORD+55(18),=CL18'OUTDD(Supplied)'              RS1007\n*        BRAS  R14,SPACE1                                        RS1007\n         J     LE_370_19\nLE_370_18 DS 0H\n         MVC   RECORD+55(17),=CL17'OUTDD(Default)'               RS1007\n         TM    LE_STATUS_BYTE_02,BIT7\n         JO    LE_370_19                                         RS1007\n         MVC   RECORD+55(17),=CL17'OUTDD(Supplied)'              RS1007\n*        BRAS  R14,SPACE1                                        RS1007\nLE_370_19 DS 0H\n         MVC   RECORD+76(15),=CL15'NUMPROC(MIG)'                 RS1007\n         TM    LE_STATUS_BYTE_05,BIT0\n         JO    LE_370_21\n         MVC   RECORD+76(15),=CL15'NUMPROC(PFD)'\n         TM    LE_STATUS_BYTE_03,BIT0\n         JO    LE_370_21\n         MVC   RECORD+76(15),=CL15'NUMPROC(NOPFD)'               RS1007\nLE_370_21 DS 0H\n         MVC   RECORD+92(7),=CL7'RENT'                           RS1007\n         CLI   CSECT_ANALYZE_KZ,C'M' First csect (main-ep)?      PF0608\n         JNE   LE_370_21_#0          No,don't set CSCCRNT        SS0615\n         MVC   CSCCRNT(3),=CL3'YES'                               *CSC*\nLE_370_21_#0 DS 0H                                               SS0615\n         TM    LE_STATUS_BYTE_03,BIT1\n         JO    LE_370_21_#1                                       *CSC*\n         MVC   RECORD+92(7),=CL7'NORENT'                         RS1007\n         CLI   CSECT_ANALYZE_KZ,C'M' First csect (main-ep)?      SS0615\n         JNE   LE_370_21_#1          No,don't set CSCCRNT        SS0615\n         MVC   CSCCRNT(3),=CL3'NO '                               *CSC*\nLE_370_21_#1 DS 0H                                                *CSC*\n         BRAS  R14,SPACE1                                        RS1007\n         MVC   RECORD,BLANKS                                     RS1007\n         MVC   RECORD+1(6),=CL6'RES'                             RS1007\n         TM    LE_STATUS_BYTE_03,BIT2\n         JO    LE_370_21_#2                                       *CSC*\n         MVC   RECORD+1(6),=CL6'NORES'                           RS1007\nLE_370_21_#2 DS 0H                                                *CSC*\n         MVC   RECORD+9(6),=CL6'SEQ'                             RS1007\n         TM    LE_STATUS_BYTE_03,BIT3\n         JO    LE_370_21_#3                                       *CSC*\n         MVC   RECORD+9(6),=CL6'NOSEQ'                           RS1007\nLE_370_21_#3 DS 0H                                                *CSC*\n         MVC   RECORD+17(9),=CL9'SIZE(MAX)'                      RS1007\n         TM    LE_STATUS_BYTE_03,BIT4\n         JO    LE_370_21_#4                                       *CSC*\n         MVC   RECORD+17(9),=CL9'SIZE(VAL)'                      RS1007\nLE_370_21_#4 DS 0H                                                *CSC*\n         MVC   RECORD+27(9),=CL9'SOURCE'                         RS1007\n         TM    LE_STATUS_BYTE_03,BIT5\n         JO    LE_370_21_#5                                       *CSC*\n         MVC   RECORD+27(9),=CL9'NOSOURCE'                       RS1007\nLE_370_21_#5 DS 0H                                                *CSC*\n         MVC   RECORD+36(20),=CL20'SSRANGE(ZLEN/NOZLEN)'         RS0516\n         CLC   LE_VERS(4),=C'0600'  Vers+Rel>0600 is V6.1        RS0516\n         JH    LE_370_21_#51          yes                        RS0516\n         MVC   RECORD+36(20),=CL20'SSRANGE'                      RS1007\nLE_370_21_#51 DS 0H                                              RS0516\n         TM    LE_STATUS_BYTE_03,BIT6\n         JO    LE_370_21_#6                                       *CSC*\n         MVC   RECORD+36(20),=CL20'NOSSRANGE'                    RS1007\nLE_370_21_#6 DS 0H                                                *CSC*\n         MVC   RECORD+55(8),=CL8'TERM'                           RS1007\n         TM    LE_STATUS_BYTE_03,BIT7\n         JO    LE_370_21_#7                                       *CSC*\n         MVC   RECORD+55(8),=CL8'NOTERM'\nLE_370_21_#7 DS 0H                                                *CSC*\n         MVC   RECORD+66(8),=CL8'TEST'                           RS1007\n         TM    LE_STATUS_BYTE_04,BIT0                            RS1007\n         JO    LE_370_21_#8                                      RS1007\n         MVC   RECORD+66(8),=CL8'NOTEST'                         RS1007\nLE_370_21_#8 DS 0H                                               RS1007\n         MVC   RECORD+76(10),=CL11'TRUNC(BIN)'                   RS1007\n         TM    LE_STATUS_BYTE_05,BIT4                            RS1007\n         JO    LE_370_33                                         RS1007\n         MVC   RECORD+76(10),=CL11'TRUNC(STD)'                   RS1007\n         TM    LE_STATUS_BYTE_04,BIT1                            RS1007\n         JO    LE_370_33                                         RS1007\n         MVC   RECORD+76(10),=CL11'TRUNC(OPT)'                   RS1007\nLE_370_33 DS 0H                                                  RS1007\n         MVC   RECORD+92(9),=CL9'WORD(xx)'                       RS1007\n         TM    LE_STATUS_BYTE_04,BIT2                            RS1007\n         JO    LE_370_33_#1                                      RS1007\n         MVC   RECORD+92(9),=CL9'NOWORD'                         RS1007\nLE_370_33_#1 DS 0H                                               RS1007\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(8),=CL8'VBREF'                           RS1007\n         TM    LE_STATUS_BYTE_04,BIT3\n         JO    LE_370_33_#2                                       *CSC*\n         MVC   RECORD+1(8),=CL8'NOVBREF'                         RS1007\nLE_370_33_#2 DS 0H                                                *CSC*\n         MVC   RECORD+9(6),=CL6'XREF'                            RS1007\n         TM    LE_STATUS_BYTE_04,BIT4\n         JO    LE_370_33_#3                                       *CSC*\n         MVC   RECORD+9(6),=CL6'NOXREF'\nLE_370_33_#3 DS 0H                                                *CSC*\n         MVC   RECORD+17(6),=CL6'ZWB'                            RS1007\n         TM    LE_STATUS_BYTE_04,BIT5\n         JO    LE_370_33_#4                                       *CSC*\n         MVC   RECORD+17(6),=CL6'NOZWB'                          RS1007\nLE_370_33_#4 DS 0H                                                *CSC*\n         MVC   RECORD+27(7),=CL7'NAME'                           RS1007\n         TM    LE_STATUS_BYTE_04,BIT6\n         JO    LE_370_33_#5                                       *CSC*\n         MVC   RECORD+27(7),=CL7'NONAME'\nLE_370_33_#5 DS 0H                                                *CSC*\n         CLI   LE_VERS+1,C'.'       Cobol/2 ?                    RS0712\n         JE    LE_370_33_#6          yes                         RS0712\n         CLC   LE_VERS(4),=C'0300'  Vers+Rel > 0300 COBOL V3R1   RS0103\n         JH    LE_370_40             yes, CMPR2 no longer valid   *CSC*\nLE_370_33_#6 DS 0H                                               RS0712\n         MVC   RECORD+36(8),=CL8'CMPR2'                          RS1007\n         TM    LE_STATUS_BYTE_04,BIT7\n         JO    LE_370_40                                          *CSC*\n         MVC   RECORD+36(8),=CL8'NOCMPR2'                        RS1007\nLE_370_40 DS 0H                                                  RS0103\n         MVC   RECORD+44(12),=CL12'NUMCLS'  other Cobol          RS1007\n         TM    LE_STATUS_BYTE_05,BIT1\n         JO    LE_370_40_#1                                       *CSC*\n         MVC   RECORD+44(12),=CL12'NONUMCLS'                     RS1007\nLE_370_40_#1 DS 0H                                                *CSC*\n         CLI   LE_SWITCH,C'1'   COBOL/370\n         JNE   LE_370_42\n         CLC   LE_VERS(4),=C'0102'  Vers+Rel < 0102 COBOL MVS and VM\n         JL    LE_370_42             yes\n         MVC   RECORD+44(12),=CL12'NUMCLS(ALT)'                  RS1007\n         TM    LE_STATUS_BYTE_05,BIT1\n         JO    LE_370_52                                         RS1007\n         MVC   RECORD+44(12),=CL12'NUMCLS(PRIM)'                 RS1007\nLE_370_42 DS 0H\n         MVC   RECORD+66(7),=CL7'DBCS'                           RS1007\n         TM    LE_STATUS_BYTE_05,BIT2\n         JO    LE_370_42_#1                                       *CSC*\n         MVC   RECORD+66(7),=CL7'NODBCS'                         RS1007\nLE_370_42_#1 DS 0H                                                *CSC*\n         MVC   RECORD+76(6),=CL6'AWO'                            RS1007\n         TM    LE_STATUS_BYTE_05,BIT3\n         JO    LE_370_42_#2                                       *CSC*\n         MVC   RECORD+76(6),=CL6'NOAWO'                          RS1007\nLE_370_42_#2 DS 0H                                                *CSC*\n         CLI   LE_SWITCH,C'1'                  Cobol/370\n         JNE   LE_370_50Z                      no                RS1007\n         CLC   LE_VERS(4),=C'0300'  Vers+Rel > 0300 COBOL V3R1\n         JL    LE_370_45             yes, Events not for E.C.\n         MVC   RECORD+92(9),=CL9'EVENTS'       n/a COBOL/2\n         TM    LE_STATUS_BYTE_05,BIT5\n         JO    LE_370_45                                          *CSC*\n         MVC   RECORD+92(9),=CL9'NOEVENTS'                       RS1007\nLE_370_45 DS 0H\n         BRAS  R14,SPACE1                                        RS1007\n         MVC   RECORD,BLANKS                                     RS1007\n         MVC   RECORD+1(11),=CL11'CURRENCY'   n/a COBOL/2        RS1007\n         TM    LE_STATUS_BYTE_05,BIT6\n         JO    LE_370_48                                          *CSC*\n         MVC   RECORD+1(11),=CL11'NOCURRENCY'                    RS1007\nLE_370_48 DS 0H\n         MVC   RECORD+17(40),=CL40'Compilation_unit_Class'       ES0116\n         TM    LE_STATUS_BYTE_05,BIT7\n         JO    LE_370_48_#1                                       *CSC*\n         MVC   RECORD+17(40),=CL40'Compilation_unit_Program'     ES0116\nLE_370_48_#1 DS 0H                                                *CSC*\n         CLC   LE_VERS(4),=C'0102'  Vers+Rel < 0102 COBOL MVS and VM\n         JL    LE_370_50Z         no\n*                         Supported only for COBOL MVS and VM R2\n         BRAS  R14,SPACE1\n* The COBANAL SUMMARY report is only generated for Mainline      SS0615\n* modules. As RMODE(24/ANY)\" reporting appears in SUMMARY we     SS0615\n* need to ensure that we only set \"RM\" to 24 or ANY in CSCRMODE  SS0615\n* if this is a Mainline module and not a subroutine.             SS0615\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(11),=CL11'RMODE(ANY)'\n         CLI   CSECT_ANALYZE_KZ,C'M' First csect (main-ep)?      SS0615\n         JNE   LE_370_48_#11         No,do not set CSCRMODE      SS0615\n         MVC   CSCRMODE(3),=CL3'ANY'                              *CSC*\nLE_370_48_#11 DS 0H                                              SS0615\n         TM    LE_STATUS_BYTE_26,BIT0\n         JO    LE_370_48_#2                                       *CSC*\n         MVC   RECORD+1(11),=CL11'RMODE(24)'\n         CLI   CSECT_ANALYZE_KZ,C'M' First csect (main-ep)?      SS0615\n         JNE   LE_370_48_#2          No,do not set CSCRMODE      SS0615\n         MVC   CSCRMODE(3),=CL3'24 '                              *CSC*\nLE_370_48_#2 DS 0H                                                *CSC*\n         CLC   LE_VERS(4),=C'0401'  Vers+Rel < 0401 E.Cob V4.1   RS1207\n         JL    LE_370_48_#21         no                          RS1207\n         MVC   RECORD+17(13),=CL13'TEST(HOOK)'                   RS1207\n         TM    LE_STATUS_BYTE_26,BIT1                            RS1207\n         JO    LE_370_48_#5                                      RS1207\n         TM    LE_STATUS_BYTE_26,BIT2                            RS1207\n         JO    LE_370_48_#5                                      RS1207\n         TM    LE_STATUS_BYTE_26,BIT3                            RS1207\n         JO    LE_370_48_#5                                      RS1207\n         MVC   RECORD+17(13),=CL13'NO_TEST(HOOK)'                ES0116\nLE_370_48_#21 DS 0H                                              RS1207\n         MVC   RECORD+17(13),=CL13'TEST(STMT)'                   RS1007\n         TM    LE_STATUS_BYTE_26,BIT1\n         JO    LE_370_48_#3                                       *CSC*\n         MVC   RECORD+17(13),=CL13'NO_TEST(STMT)'                ES0116\nLE_370_48_#3 DS 0H                                                *CSC*\n         MVC   RECORD+36(13),=CL13'TEST(PATH)'                   RS1007\n         TM    LE_STATUS_BYTE_26,BIT2\n         JO    LE_370_48_#4                                       *CSC*\n         MVC   RECORD+36(13),=CL13'NO_TEST(PATH)'                ES0116\nLE_370_48_#4 DS 0H                                                *CSC*\n         MVC   RECORD+55(14),=CL14'TEST(BLOCK)'                  RS1007\n         TM    LE_STATUS_BYTE_26,BIT3\n         JO    LE_370_48_#5                                       *CSC*\n         MVC   RECORD+55(14),=CL14'NO_TEST(BLOCK)'               ES0116\nLE_370_48_#5 DS 0H                                                *CSC*\n         MVC   RECORD+76(17),=CL17'OPT(FULL)'                    RS1007\n         TM    LE_STATUS_BYTE_26,BIT4\n         JO    LE_370_48_#6                                       *CSC*\n         MVC   RECORD+76(17),=CL17'NOOPT_OR_OPT(STD)'            ES0116\nLE_370_48_#6 DS 0H                                                *CSC*\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(13),=CL13'INTDATE(LIL)'\n         TM    LE_STATUS_BYTE_26,BIT5\n         JO    LE_370_48_#7                                       *CSC*\n         MVC   RECORD+1(13),=CL13'INTDATE(ANSI)'\nLE_370_48_#7 DS 0H                                                *CSC*\n         CLC   LE_VERS(4),=C'0202'  Vers+Rel < 0202 COBOL MVS and VM\n         JL    LE_370_50Y           no lower                     RS1000\n         MVC   RECORD+17(14),=CL14'TEST(SEPARATE)'               RS1007\n         TM    LE_STATUS_BYTE_26,BIT6                            RS1000\n         JO    LE_370_50Y                                         *CSC*\n         MVC   RECORD+17(17),=CL17'NO_TEST(SEPARATE)'            ES0116\nLE_370_50Y DS  0H\n         MVC   RECORD+44(22),=CL22'PGMNAME(LONGUPPER)'           RS1007\n         TM    LE_STATUS_BYTE_27,BIT0\n         JO    LE_370_50Y_#1                                      *CSC*\n         MVC   RECORD+44(22),=CL22'NOT_PGMNAME(LONGUPPER)'       ES0116\nLE_370_50Y_#1 DS 0H                                               *CSC*\n         MVC   RECORD+76(22),=CL22'PGMNAME(LONGMIXED)'\n         TM    LE_STATUS_BYTE_27,BIT1\n         JO    LE_370_SRST                                       RS0704\n         MVC   RECORD+76(22),=CL22'NOT_PGMNAME(LONGMIXED)'       ES0116\nLE_370_SRST    DS 0H                                             RS0704\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(5),=CL5'DLL'\n         TM    LE_STATUS_BYTE_27,BIT2\n         JO    LE_370_SRST_#1                                     *CSC*\n         MVC   RECORD+1(5),=CL5'NODLL'\nLE_370_SRST_#1 DS 0H                                              *CSC*\n         MVC   RECORD+17(11),=CL11'EXPORTALL'                    RS1007\n         TM    LE_STATUS_BYTE_27,BIT3\n         JO    LE_370_SRST_#2                                     *CSC*\n         MVC   RECORD+17(11),=CL11'NOEXPORTALL'                  RS1007\nLE_370_SRST_#2 DS 0H                                              *CSC*\n         MVC   RECORD+36(10),=CL10'DATEPROC'                     RS1007\n         TM    LE_STATUS_BYTE_27,BIT4\n         JO    LE_370_SRST_#3                                     *CSC*\n         MVC   RECORD+36(10),=CL10'NODATEPROC'                   RS1007\nLE_370_SRST_#3 DS 0H                                              *CSC*\n         CLC   LE_VERS(4),=C'0500'  Vers+Rel =>0500 E.Cob V5.1   RS1015\n         JH    LE_370_SRST_#3_1       yes (YEARWINDOW obsolete)  RS1015\n         STRING64 (RECORD,,L),9X,'YEARWINDOW(',(LE_YEAR_WINDOW,H,R4B), X\n               ')',INTO=RECORD                                   RS1007\nLE_370_SRST_#3_1 DS 0H                                            *CSC*\n         CLC   LE_VERS(4),=C'0202'  Vers+Rel < 0202 COBOL MVS and VM\n         JL    LE_370_50Z           no lower                     RS1000\n         MVC   RECORD+76(13),=CL13'ARITH(EXTEND)'                RS1007\n         TM    LE_STATUS_BYTE_27,BIT5                            RS1000\n         JO    LE_370_SRST_#4                                     *CSC*\n         MVC   RECORD+76(13),=CL13'ARITH(COMPAT)'                RS1007\nLE_370_SRST_#4 DS 0H                                              *CSC*\n         CLI   LE_SWITCH,C'1'   COBOL/370\n         JNE   LE_370_50Z\n         CLC   LE_VERS(4),=C'0301'  Vers+Rel < 0301 COBOL V3R1\n         JL    LE_370_50Z            yes\n         MVC   RECORD+92(6),=CL6'THREAD'                         RS1007\n         TM    LE_STATUS_BYTE_27,BIT6\n         JO    LE_370_SRST_#40                                    *CSC*\n         MVC   RECORD+92(8),=CL8'NOTHREAD'                       RS1007\nLE_370_SRST_#40 DS 0H                                             *CSC*\n         CLC   LE_VERS(6),=C'030401' Vers/Rel/Mod E.C. 3.4.1     RS1207\n         JL    LE_370_SRST_#5        no                          RS1207\n         BRAS  R14,SPACE1                                        RS1207\n         MVC   RECORD,BLANKS                                     RS1207\n         CLC   LE_VERS(4),=C'0401'  Vers+Rel < 0401 E.Cob V4.1   RS1207\n         JL    LE_370_SRST_#41       no                          RS1207\n         MVC   RECORD+1(10),=CL10'TEST(EJPD)'                    RS1207\n         TM    LE_STATUS_BYTE_27,BIT7                            RS1207\n         JO    LE_370_SRST_#41                                   RS1207\n         MVC   RECORD+1(12),=CL12'TEST(NOEJPD)'                  RS1207\nLE_370_SRST_#41 DS 0H\n         MVC   RECORD+17(3),=CL3'SQL'                            RS1207\n         TM    LE_STATUS_BYTE_28,BIT0                            RS1207\n         JO    LE_370_SRST_#42                                   RS1207\n         MVC   RECORD+17(5),=CL5'NOSQL'                          RS1207\nLE_370_SRST_#42 DS 0H                                            RS1207\n         MVC   RECORD+27(4),=CL4'CICS'                           RS1207\n         TM    LE_STATUS_BYTE_28,BIT1                            RS1207\n         JO    LE_370_SRST_#43                                   RS1207\n         MVC   RECORD+27(6),=CL6'NOCICS'                         RS1207\nLE_370_SRST_#43 DS 0H                                            RS1207\n         CLC   LE_VERS(4),=C'0401'  Vers+Rel < 0401 E.Cob V4.1   RS1207\n         JL    LE_370_SRST_#44       no                          RS1207\n         MVC   RECORD+44(7),=CL7'MDECK'                          RS1207\n         TM    LE_STATUS_BYTE_28,BIT2                            RS1207\n         JO    LE_370_SRST_#44                                   RS1207\n         MVC   RECORD+44(7),=CL7'NOMDECK'                        RS1207\nLE_370_SRST_#44 DS 0H                                            RS1207\n         MVC   RECORD+55(10),=CL10'SQLCCSID'                     RS1207\n         TM    LE_STATUS_BYTE_28,BIT3                            RS1207\n         JO    LE_370_SRST_#45                                   RS1207\n         MVC   RECORD+55(10),=CL10'NOSQLCCSID'                   RS1207\nLE_370_SRST_#45 DS 0H                                            RS1207\n         CLC   LE_VERS(4),=C'0401'  Vers+Rel < 0401 E.Cob V4.1   RS1207\n         JL    LE_370_SRST_#5        no                          RS1207\n         MVC   RECORD+66(9),=CL9'OPTFILE'                        RS1207\n         TM    LE_STATUS_BYTE_28,BIT4                            RS1207\n         JO    LE_370_SRST_#46                                   RS1207\n         MVC   RECORD+66(9),=CL9'NOOPTFILE'                      RS1207\nLE_370_SRST_#46 DS 0H                                            RS1207\n         MVC   RECORD+76(16),=CL16'XMLPARSE(XMLSS)'              RS0616\n         TM    LE_STATUS_BYTE_28,BIT5                            RS1207\n         JO    LE_370_SRST_#47                                   RS1207\n         MVC   RECORD+76(16),=CL16'XMLPARSE(COMPAT)'             RS0616\nLE_370_SRST_#47 DS 0H                                            RS1207\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         CLC   LE_VERS(4),=C'0402'  Vers+Rel < 0402 E.Cob V4.2   RS1015\n         JL    LE_370_SRST_#5        no                          RS1015\n         MVC   RECORD+1(8),=CL8'BLOCK0'                          RS1015\n         TM    LE_STATUS_BYTE_28,BIT6                            RS1015\n         JO    LE_370_SRST_#48                                   RS1015\n         MVC   RECORD+1(8),=CL8'NOBLOCK0'                        RS1015\nLE_370_SRST_#48 DS 0H                                            RS1015\n         CLC   LE_VERS(4),=C'0501'  Vers+Rel < 0501 E.Cob V5.1   RS1015\n         JL    LE_370_SRST_#58       no                          RS1015\n         MVC   RECORD+17(13),=CL13'DISPSIGN(SEP)'                RS1015\n         TM    LE_STATUS_BYTE_28,BIT6                            RS1015\n         JO    LE_370_SRST_#49                                   RS1015\n         MVC   RECORD+17(16),=CL16'DISPSIGN(COMPAT)'             RS1015\nLE_370_SRST_#49 DS 0H                                            RS1015\n         MVC   RECORD+36(8),=CL8'STGOPT'                         RS1015\n         TM    LE_STATUS_BYTE_29,BIT4                            RS1015\n         JO    LE_370_SRST_#50                                   RS1015\n         MVC   RECORD+36(8),=CL8'NOSTGOPT'                       RS1015\nLE_370_SRST_#50 DS 0H                                            RS1015\n         MVC   RECORD+45(13),=CL13'AFP(VOLATILE)'                RS1015\n         TM    LE_STATUS_BYTE_29,BIT5                            RS1015\n         JO    LE_370_SRST_#51                                   RS1015\n         MVC   RECORD+45(15),=CL15'AFP(NOVOLATILE)'              RS1015\nLE_370_SRST_#51 DS 0H                                            RS1015\n         MVC   RECORD+61(14),=CL14'HPGR(PRESERVE)'               RS1015\n         TM    LE_STATUS_BYTE_29,BIT6                            RS1015\n         JO    LE_370_SRST_#52                                   RS1015\n         MVC   RECORD+61(16),=CL16'HPGR(NOPRESERVE)'             RS1015\nLE_370_SRST_#52 DS 0H                                            RS1015\n         MVC   RECORD+78(17),=CL17'NOT_NOTEST(DWARF)'            RS0316\n         TM    LE_STATUS_BYTE_29,BIT7                            RS1015\n         JO    LE_370_SRST_#53                                   RS1015\n         MVC   RECORD+78(17),=CL17'NOTEST(DWARF)'                RS0316\nLE_370_SRST_#53 DS 0H                                            RS1015\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(15),=CL15'QUALIFY(EXTEND)'               RS1015\n         TM    LE_STATUS_BYTE_30,BIT0                            RS1015\n         JO    LE_370_SRST_#54                                   RS1015\n         MVC   RECORD+1(15),=CL15'QUALIFY(COMPAT)'               RS1015\nLE_370_SRST_#54 DS 0H                                            RS1015\n         MVC   RECORD+17(11),=CL11'VLR(COMPAT)'                  RS1015\n         TM    LE_STATUS_BYTE_30,BIT1                            RS1015\n         JO    LE_370_SRST_#55                                   RS1015\n         MVC   RECORD+17(13),=CL13'VLR(STANDARD)'                RS1015\nLE_370_SRST_#55 DS 0H                                            RS1015\n         MVC   RECORD+36(9),=CL9'COPYRIGHT'                      RS1015\n         TM    LE_STATUS_BYTE_30,BIT2                            RS1015\n         JO    LE_370_SRST_#56                                   RS1015\n         MVC   RECORD+36(11),=CL11'NOCOPYRIGHT'                  RS1015\nLE_370_SRST_#56 DS 0H                                            RS1015\n         MVC   RECORD+48(7),=CL7'SERVICE'                        RS1015\n         TM    LE_STATUS_BYTE_30,BIT3                            RS1015\n         JO    LE_370_SRST_#57                                   RS1015\n         MVC   RECORD+48(9),=CL9'NOSERVICE'                      RS1015\nLE_370_SRST_#57 DS 0H                                            RS1015\n         MVC   RECORD+58(13),=CL13'ZONEDATA(MIG)'                RS1015\n         TM    LE_STATUS_BYTE_30,BIT4                            RS1015\n         JO    LE_370_SRST_#58                                   RS1015\n         MVC   RECORD+58(13),=CL13'ZONEDATA(PFD)'                RS1015\nLE_370_SRST_#58 DS 0H                                            RS1015\n         CLC   LE_VERS(4),=C'0601'  Vers+Rel < 0601 E.Cob V6.1   RS0516\n         JL    LE_370_SRST_#5        no                          RS0516\n         BRAS  R14,SPACE1                                        RS0516\n         MVC   RECORD,BLANKS                                     RS0516\n         STRING64 (RECORD,,L),1X,'BUILD_LEVEL_INFO(',            RS0516X\n               (LE_BUILD_LEVEL),')',                             RS0516X\n               INTO=RECORD                                       RS0516\nLE_370_SRST_#5 DS 0H                                              *CSC*\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         STRING64 (RECORD,,L),1X,'CODEPAGE(',(LE_CCSID,H,R4B),')',     X\n               INTO=RECORD\nLE_370_SRST_#99 DS 0H                                            RS1015\n         CLC   LE_VERS(4),=C'0501'  Vers+Rel < 0501 E.Cob V5.1   RS1015\n         JL    LE_370_50Z            no                          RS1015\n         STRING64 (RECORD,,L),'  ARCH(',(LE_ARCHLEVEL,,X),             X\n               ') OPT(',(LE_OPT_LEVEL,,X),')',INTO=RECORD        RS1015\nLE_370_50Z DS 0H\n         BRAS  R14,SPACE2\n         STRING64 ADDINFO,INTO=RECORD                             *CSC*\n         BRAS  R14,SPACE1\n         STRING64 '------------ about DATA DIVISION    --------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD\n         BRAS  R14,SPACE2\n         STRING64 'Program use',' no',' QSAM or SAM access method',    X\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT0\n         JNO   LE_370_51\n         STRING64 'Program use',' QSAM or SAM access method',          X\n               INTO=RECORD\nLE_370_51 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'Program use',' no',' VSAM sequential files',        X\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT1\n         JNO   LE_370_52\n         STRING64 'Program use',' VSAM sequential files',INTO=RECORD\nLE_370_52 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'Program use',' no',' VSAM indexed files',INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT2\n         JNO   LE_370_53\n         STRING64 'Program use',' VSAM indexed files',INTO=RECORD\nLE_370_53 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'Program use',' no',' VSAM RBA files',INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT3\n         JNO   LE_370_54\n         STRING64 'Program use',' VSAM RBA files',INTO=RECORD\nLE_370_54 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'Program use',' no',' CODE-SET (ASCII files)',       X\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT4\n         JNO   LE_370_55\n         STRING64 'Program use',' CODE-SET (ASCII files)',INTO=RECORD\nLE_370_55 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'Program use',' no',' spanned records',INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT5\n         JNO   LE_370_56\n         STRING64 'Program use',' spanned records',INTO=RECORD\nLE_370_56 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'Program has',' no',' picture G (DBCS) items',       X\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT6\n         JNO   LE_370_57\n         STRING64 'Program has',' picture G (DBCS) items',INTO=RECORD\nLE_370_57 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'Program has',' no',' OCCURS DEPENDING ON items',    X\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT7\n         JNO   LE_370_58\n         STRING64 'Program has',' OCCURS DEPENDING ON items',          X\n               INTO=RECORD\nLE_370_58 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'Program has',' no',' SYNCHRONIZED clause',          X\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT0\n         JNO   LE_370_59\n         STRING64 'Program has',' SYNCHRONIZED clause',INTO=RECORD\nLE_370_59 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'Program has',' no',' JUSTIFIED clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT1\n         JNO   LE_370_60\n         STRING64 'Program has',' JUSTIFIED clause',INTO=RECORD\nLE_370_60 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'Program has',' no',' POINTER items',INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT2\n         JNO   LE_370_61\n         STRING64 'Program has',' POINTER items',INTO=RECORD\nLE_370_61 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'Program has',' no',' complex ODO clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT3\n         JNO   LE_370_62\n         STRING64 'Program has',' complex ODO clause',INTO=RECORD\nLE_370_62 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'Program has',' no',' external',                     X\n               ' floating-point items',                                X\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT4\n         JNO   LE_370_63\n         STRING64 'Program has',' external',' floating-point items',   X\n               INTO=RECORD\nLE_370_63 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'Program has',' no',' internal',                     X\n               ' floating-point items',                                X\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT5\n         JNO   LE_370_63_1\n         STRING64 'Program has',' internal',' floating-point items',   X\n               INTO=RECORD\nLE_370_63_1 DS 0H\n         CLI   LE_SWITCH,C'1'                  Cobol/370\n         JNE   LE_370_64                       no, jump around\n         BRAS  R14,SPACE1\n         STRING64 'Program has',' no',' Proc-Pointer or Func-Pointer', X\n               ' items',INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT7\n         JNO   LE_370_63_2\n         STRING64 'Program has',' Proc or Func-Pointer',' items',      X\n               INTO=RECORD\nLE_370_63_2 DS 0H\n         CLC   LE_VERS(4),=C'0202'  Vers+Rel < 0202 COBOL MVS and VM\n         JL    LE_370_64            no lower                     RS1000\n         BRAS  R14,SPACE1\n         STRING64 'Program has',' no',' Line-sequential file',         X\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT6\n         JNO   LE_370_64\n         STRING64 'Program has',' Line-sequential file',               X\n               INTO=RECORD\nLE_370_64 DS 0H\n         STRING64 'The working storage/DSA size is ',            RS0316X\n               (LE_TGT_WS_LENGTH,F,R9B),INTO=RECORD              RS1007\n         BRAS  R14,SPACE1                                        RS0316\nLE_370_65 DS 0H                                                  RS0316\n         BRAS  R14,BLANK1                                        RS0316\n         STRING64 ADDINFO,INTO=RECORD                             *CSC*\n         BRAS  R14,SPACE1\n         STRING64 '------------ about ENVIROMENT DIVISION -----------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD\n         BRAS  R14,SPACE2\n         STRING64 'Program use',' no',' FILE-STATUS clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_08,BIT0\n         JNO   LE_370_66\n         STRING64 'Program use',' FILE-STATUS clause',INTO=RECORD\nLE_370_66 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'Program use',' no',' RERUN clause in I/O-control',  X\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_08,BIT1\n         JNO   LE_370_67\n         STRING64 'Program has',' RERUN clause in I/O-control',        X\n               INTO=RECORD\nLE_370_67 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'Program use',' no',' UPSI switches',INTO=RECORD\n         TM    LE_STATUS_BYTE_08,BIT2\n         JNO   LE_370_68\n         STRING64 'Program use',' UPSI switches',INTO=RECORD\nLE_370_68 DS 0H\n         CLC   LE_VERS(4),=C'0600'  Vers+Rel > 0600 E.Cob V6.1   RS0516\n         JL    LE_370_70               no leave                  RS0516\n         BRAS  R14,SPACE1                                        RS0516\n         STRING64 'WSOPT bit is ','off',INTO=RECORD              RS0516\n         TM    LE_STATUS_BYTE_08,BIT3                            RS0516\n         JNO   LE_370_69                                         RS0516\n         STRING64 'WSOPT bit is ','on',INTO=RECORD               RS0516\nLE_370_69 DS 0H                                                  RS0516\n         BRAS  R14,SPACE1                                        RS0516\n         STRING64 'VSAMOPENFS is ','off',INTO=RECORD             RS0516\n         TM    LE_STATUS_BYTE_08,BIT4                            RS0516\n         JNO   LE_370_70                                         RS0516\n         STRING64 'VSAMOPENFS is ','on',INTO=RECORD              RS0516\nLE_370_70 DS 0H                                                  RS0516\n         BRAS  R14,SPACE1                                        RS0215\n         CLC   LE_VERS(4),=C'0500'  Vers+Rel > 0500 E.Cob V5.1   RS0215\n         JH    LE_370_71_1              yes leave                RS0215\n         STRING64 'Program address TGT via ','R13',INTO=RECORD   RS1007\n         TM    LE_TGT_REG,BIT0                                   RS1007\n         JNO   LE_370_71                                         RS1007\n         STRING64 'Program address TGT via ','R9',INTO=RECORD    RS1007\nLE_370_71 DS 0H\n         BRAS  R14,SPACE1                                        RS0215\nLE_370_71_1 DS 0H                                                RS0215\n         BRAS  R14,BLANK1                                        RS0215\n         STRING64 ADDINFO,INTO=RECORD                             *CSC*\n         BRAS  R14,SPACE1\n         STRING64 '------------ about PROCEDURE DIVISION  -----------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD\n         BRAS  R14,SPACE2\n         STRING64 'Following statements in control (check Y/N):',      X\n               INTO=RECORD\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(6),=CL6'Accept'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_09,BIT0\n         JNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(3),=CL3'Add'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_09,BIT1\n         JNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(5),=CL5'Alter'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_09,BIT2\n         JNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(4),=CL4'Call'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_09,BIT3\n         JNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(6),=CL6'Cancel'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_09,BIT4\n         JNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(5),=CL5'Close'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_09,BIT6\n         JNO   *+8\n         MVI   RECORD+100,C'Y'\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(7),=CL7'Compute'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_10,BIT0\n         JNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(6),=CL6'Delete'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_10,BIT2\n         JNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(7),=CL7'Display'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_10,BIT4\n         JNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(6),=CL6'Divide'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_10,BIT5\n         JNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(11),=CL11'End-Perform'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_11,BIT1\n         JNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(5),=CL5'Enter'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_11,BIT2\n         JNO   *+8\n         MVI   RECORD+100,C'Y'\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(5),=CL5'Entry'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_11,BIT3\n         JNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(4),=CL4'Exit'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_11,BIT4\n         JNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(5),=CL5'Go_to'                          ES0116\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_11,BIT6\n         JNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(2),=CL2'If'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_11,BIT7\n         JNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(10),=CL10'Initialize'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_12,BIT0\n         JNO   *+8\n         MVI   RECORD+83,C'Y'\n         CLI   LE_SWITCH,C'1'   COBOL/370 ?\n         JNE   LE_370_75          no, jump around\n         MVC   RECORD+86(6),=CL6'Invoke'   comes with COBOL/370\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_12,BIT1\n         JNO   *+8\n         MVI   RECORD+100,C'Y'\nLE_370_75 DS 0H\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(7),=CL7'Inspect'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_12,BIT2\n         JNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(5),=CL5'Merge'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_12,BIT3\n         JNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(4),=CL4'Move'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_12,BIT4\n         JNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(8),=CL8'Multiply'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_12,BIT5\n         JNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(4),=CL4'Open'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_12,BIT6\n         JNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(7),=CL7'Perform'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_12,BIT7\n         JNO   *+8\n         MVI   RECORD+100,C'Y'\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(4),=CL4'Read'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_13,BIT0\n         JNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(7),=CL7'Release'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_13,BIT2\n         JNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(6),=CL6'Return'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_13,BIT3\n         JNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(7),=CL7'Rewrite'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_13,BIT4\n         JNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(6),=CL6'Search'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_13,BIT5\n         JNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(3),=CL3'Set'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_13,BIT7\n         JNO   *+8\n         MVI   RECORD+100,C'Y'\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(4),=CL4'Sort'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_14,BIT0\n         JNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(5),=CL5'Start'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_14,BIT1\n         JNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(4),=CL4'Stop'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_14,BIT2\n         JNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(6),=CL6'String'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_14,BIT3\n         JNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(8),=CL8'Subtract'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_14,BIT4\n         JNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(8),=CL8'Unstring'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_14,BIT7\n         JNO   *+8\n         MVI   RECORD+100,C'Y'\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(3),=CL3'Use'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_15,BIT0\n         JNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(5),=CL5'Write'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_15,BIT1\n         JNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(8),=CL8'Continue'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_15,BIT2\n         JNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(7),=CL7'End-Add'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_15,BIT3\n         JNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(8),=CL8'End-Call'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_15,BIT4\n         JNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(11),=CL11'End-Compute'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_15,BIT5\n         JNO   *+8\n         MVI   RECORD+100,C'Y'\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(10),=CL10'End-Delete'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_15,BIT6\n         JNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(10),=CL10'End-Divide'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_15,BIT7\n         JNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(12),=CL12'End-Evaluate'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_16,BIT0\n         JNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(6),=CL6'End-If'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_16,BIT1\n         JNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(12),=CL12'End-Multiply'                 RS1007\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_16,BIT2\n         JNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(8),=CL8'End-Read'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_16,BIT3\n         JNO   *+8\n         MVI   RECORD+100,C'Y'\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(10),=CL10'End-Return'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_16,BIT4\n         JNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(11),=CL11'End-Rewrite'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_16,BIT5\n         JNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(10),=CL10'End-Search'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_16,BIT6\n         JNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(9),=CL9'End-Start'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_16,BIT7\n         JNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(10),=CL10'End-String'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_17,BIT0\n         JNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(12),=CL12'End-Subtract'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_17,BIT1\n         JNO   *+8\n         MVI   RECORD+100,C'Y'\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(12),=CL12'End-Unstring'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_17,BIT2\n         JNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(9),=CL9'End-Write'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_17,BIT3\n         JNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(6),=CL6'Goback'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_17,BIT4\n         JNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(9),=CL9'Evaluate'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_17,BIT5\n         JNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(7),=CL7'Service'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_17,BIT7\n         JNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(10),=CL10'End-Invoke'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_18,BIT0\n         JNO   *+8\n         MVI   RECORD+100,C'Y'\n         BRAS  R14,SPACE1\n         CLI   LE_SWITCH,C'1'   COBOL/370\n         JNE   LE_370_125\n         CLC   LE_VERS(4),=C'0301'  Vers+Rel < 0301 COBOL V3R1\n         JL    LE_370_125            yes\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(4),=CL4'Exec'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_11,BIT5\n         JNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(8),=CL8'End-Exec'                       RS0705\n         MVI   RECORD+32,C'N'                                    RS0705\n         TM    LE_STATUS_BYTE_18,BIT1                            RS0705\n         JNO   *+8                                               RS0705\n         MVI   RECORD+32,C'Y'                                    RS0705\n         MVC   RECORD+35(3),=CL3'XML'                            RS0705\n         MVI   RECORD+49,C'N'                                    RS0705\n         TM    LE_STATUS_BYTE_18,BIT2                            RS0705\n         JNO   *+8                                               RS0705\n         MVI   RECORD+49,C'Y'                                    RS0705\n         MVC   RECORD+52(7),=CL7'End-XML'                        RS0705\n         MVI   RECORD+66,C'N'                                    RS0705\n         TM    LE_STATUS_BYTE_18,BIT3                            RS0705\n         JNO   *+8                                               RS0705\n         MVI   RECORD+66,C'Y'                                    RS0705\n         BRAS  R14,SPACE1\nLE_370_125 DS 0H\n         STRING64 '- - - - - - - - - - - - - - - - - - - - - - - ', *CSX\n               '- - - - - - - - - - - - - - - - - - - - - - - - - - -',X\n               ' -',                                                   X\n               INTO=RECORD                                       RS1007\n         BRAS  R14,SPACE2\n         STRING64 'No hexadecimal literals',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT0\n         JNO   LE_370_128\n         STRING64 'Procedure include hexadecimal literals',INTO=RECORD\nLE_370_128 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No altered GO TO',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT1\n         JNO   LE_370_129\n         STRING64 'Program contains altered GO TO',INTO=RECORD\nLE_370_129 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','I/O error declarative',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT2\n         JNO   LE_370_130\n         STRING64 'I/O error declarative',INTO=RECORD\nLE_370_130 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Label declarative',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT3\n         JNO   LE_370_131\n         STRING64 'Label declarative',INTO=RECORD\nLE_370_131 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Debugging declarative',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT4\n         JNO   LE_370_132\n         STRING64 'Debugging declarative',INTO=RECORD\nLE_370_132 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Program segmentation',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT5\n         JNO   LE_370_133\n         STRING64 'Program segmentation',INTO=RECORD\nLE_370_133 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Open Extend',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT6\n         JNO   LE_370_134\n         STRING64 'Open Extend',INTO=RECORD\nLE_370_134 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Exit Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT7\n         JNO   LE_370_135\n         STRING64 'Exit Program',INTO=RECORD\nLE_370_135 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No call literal',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT0\n         JNO   LE_370_136\n         STRING64 'Call literal (static?), see options',INTO=RECORD\nLE_370_136 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Call identifier',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT1\n         JNO   LE_370_137\n         STRING64 'Call identifier',INTO=RECORD\nLE_370_137 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Call on overflow',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT2\n         JNO   LE_370_138\n         STRING64 'Call on overflow',INTO=RECORD\nLE_370_138 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Call length of',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT3\n         JNO   LE_370_139\n         STRING64 'Call length of',INTO=RECORD\nLE_370_139 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Call address of',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT4\n         JNO   LE_370_140\n         STRING64 'Call address of',INTO=RECORD\nLE_370_140 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Close reel/unit',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT5\n         JNO   LE_370_141\n         STRING64 'Close reel/unit',INTO=RECORD\nLE_370_141 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Exponentiation used',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT6\n         JNO   LE_370_142\n         STRING64 'Exponentiation used',INTO=RECORD\nLE_370_142 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Floating point items used',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT7\n         JNO   LE_370_143\n         STRING64 'Floating point items used',INTO=RECORD\nLE_370_143 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Copy-Statements',INTO=RECORD\n         TM    LE_STATUS_BYTE_23,BIT0\n         JNO   LE_370_144\n         STRING64 'Copy-Statements',INTO=RECORD\nLE_370_144 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Basis-Statements',INTO=RECORD\n         TM    LE_STATUS_BYTE_23,BIT1\n         JNO   LE_370_145\n         STRING64 'Basis-Statements',INTO=RECORD\nLE_370_145 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','DBCS-Name in Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_23,BIT2\n         JNO   LE_370_146\n         STRING64 'DBCS-Name in Program',INTO=RECORD\nLE_370_146 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Shift-In/Shift-Out',INTO=RECORD\n         TM    LE_STATUS_BYTE_23,BIT3\n         JNO   LE_370_146_1                                      RS0316\n         STRING64 'Shift-In/Shift-Out',INTO=RECORD\nLE_370_146_1 DS 0H\n         CLC   LE_VERS(4),=C'0600'  Vers+Rel > 0600 E.Cob V6.1   RS0316\n         JL    LE_370_147              no leave                  RS0316\n         BRAS  R14,SPACE1                                        RS0316\n         STRING64 'No ','Suppress',INTO=RECORD                   RS0316\n         TM    LE_STATUS_BYTE_23,BIT4                            RS0316\n         JNO   LE_370_147                                        RS0316\n         STRING64 'Suppress',INTO=RECORD                         RS0316\nLE_370_147 DS 0H                                                 RS0316\n         BRAS  R14,SPACE1\n         STRING64 'No ','DBCS literal',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT0\n         JNO   LE_370_148\n         STRING64 'DBCS literal',INTO=RECORD\nLE_370_148 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Replace-Statements',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT1\n         JNO   LE_370_149\n         STRING64 'Replace-Statements',INTO=RECORD\nLE_370_149 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Reference modification was used',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT2\n         JNO   LE_370_150\n         STRING64 'Reference modification was used',INTO=RECORD\nLE_370_150 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Nested Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT3\n         JNO   LE_370_151\n         STRING64 'Nested Program',INTO=RECORD\nLE_370_151 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','INITIAL Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT4\n         JNO   LE_370_152\n         STRING64 'INITIAL Program',INTO=RECORD\nLE_370_152 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','COMMON Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT5\n         JNO   LE_370_153\n         STRING64 'COMMON Program',INTO=RECORD\nLE_370_153 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Select Optional Files',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT6\n         JNO   LE_370_154\n         STRING64 'Select Optional Files',INTO=RECORD\nLE_370_154 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','External Files',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT7\n         JNO   LE_370_155\n         STRING64 'External Files',INTO=RECORD\nLE_370_155 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Global Files',INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT0\n         JNO   LE_370_156\n         STRING64 'Global Files',INTO=RECORD\nLE_370_156 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Record is varying clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT1\n         JNO   LE_370_157\n         STRING64 'Record is varying clause',INTO=RECORD\nLE_370_157 DS 0H\n         BRAS  R14,SPACE1\n         CLC   LE_VERS(4),=C'0400'  Vers+Rel > 0400 E.Cob V4.1   RS1015\n         JH    LE_370_157_1          yes                         RS1015\n         STRING64 'No ','Accept',' from ','SYSIPT',                    X\n               ' used in Label Declarative',                           X\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT2\n         JNO   LE_370_158\n         STRING64 'Accept',' from ','SYSIPT',                          X\n               ' used in Label Declarative',                           X\n               INTO=RECORD\n         J     LE_370_158\nLE_370_157_1 DS 0H                          Enterprise Cobol\n         STRING64 'No ','Volatile',                                    X\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT2\n         JNO   LE_370_158\n         STRING64 'Volatile',                                          X\n               INTO=RECORD\nLE_370_158 DS 0H\n         BRAS  R14,SPACE1\n         CLC   LE_VERS(4),=C'0400'  Vers+Rel > 0400 E.Cob V4.1   RS1015\n         JH    LE_370_160_#1         yes                         RS1015\n         STRING64 'No ','Display',' upon ','SYSLST',                   X\n               ' used in Label Declarative',                           X\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT3\n         JNO   LE_370_159\n         STRING64 'Display',' upon ','SYSLST',                         X\n               ' used in Label Declarative',                           X\n               INTO=RECORD\nLE_370_159 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Display',' upon ','SYSPCH',                   X\n               ' used in Label Declarative',                           X\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT4\n         JNO   LE_370_160\n         STRING64 'Display',' upon ','SYSPCH',                         X\n               ' used in Label Declarative',                           X\n               INTO=RECORD\nLE_370_160 DS 0H\n         BRAS  R14,SPACE1\nLE_370_160_#1 DS 0H\n         STRING64 'No ','Intrinsic function was used',INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT5\n         JNO   LE_370_160_1\n         STRING64 'Intrinsic function was used',INTO=RECORD\nLE_370_160_1 DS 0H\n         BRAS  R14,SPACE1\n         CLC   LE_VERS(4),=C'0400'  Vers+Rel > 0400 E.Cob V4.1   RS1015\n         JL    LE_370_161            no                          RS1015\n         STRING64 'No ','Z-literal found',INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT5\n         JNO   LE_370_160_2\n         STRING64 'Z-literal found',INTO=RECORD\nLE_370_160_2 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Recursive',INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT5\n         JNO   LE_370_161\n         STRING64 'Recursive',INTO=RECORD\nLE_370_161 DS 0H\n         CLI   LE_SWITCH,C'1'   COBOL/370\n         JNE   LE_370_177\n         CLC   LE_VERS(4),=C'0301'  Vers+Rel < 0301 COBOL V3R1\n         JL    LE_370_177            yes\n         BRAS  R14,SPACE1\n         STRING64 'No ','Function Random was used',INTO=RECORD\n         TM    LE_STATUS_BYTE_29,BIT1\n         JNO   LE_370_162\n         STRING64 'Function Random was used',INTO=RECORD\nLE_370_162 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','Java-based OO syntax was used',INTO=RECORD\n         TM    LE_STATUS_BYTE_29,BIT0\n         JNO   LE_370_163\n         STRING64 'Java-based OO syntax was used',INTO=RECORD\nLE_370_163 DS 0H\n         BRAS  R14,SPACE1\n         STRING64 'No ','National data was used',INTO=RECORD\n         TM    LE_STATUS_BYTE_29,BIT2\n         JNO   LE_370_164                                        RS1015\n         STRING64 'National data was used',INTO=RECORD\nLE_370_164 DS 0H                                                 RS1015\n         BRAS  R14,SPACE1                                        RS1015\n         STRING64 'No ','XML PARSE with schema validation',INTO=RECORD\n         TM    LE_STATUS_BYTE_29,BIT2                            RS1015\n         JNO   LE_370_177                                        RS1015\n         STRING64 'XML PARSE with schema validation',INTO=RECORD RS1015\nLE_370_177 DS 0H\n         BRAS  R14,SPACE2\n*>--moved start -------------------------------------------------HP1107\n         L     R8,LE_TGT_FIB_PTR                                 RS1007\n         USING COBOL_FIB_DSECT,R8                                RS1007\n         ICM   R9,B'1111',LE_TGT_NO_FCB  for the loop            RS1007\n         JZ    LE_FCB_END        no entry leave                  RS1007\n         TM    LE_STATUS_BYTE_03,BIT1 RENT?                      RS1107\n         JO    LE_FCB_RENT                                       RS1107\n         L     R8,LE_TGT_PTR_FCB_CELL Point to FCB-Cells         RS1107\n         ST    R8,SAVE_CUR_FCB_CELL   Keep it for later\n         L     R8,0(R8)               First FCB\n         L     R8,164(R8)             First FIB\nLE_FCB_RENT DS 0H                                                RS1007\n         STRING64 '------------ FCB-Analysis ------------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD                                       RS1007\n         BRAS  R14,SPACE2                                        RS1007\n         STRING64 'DDName   RecFM Acc  DSOrg       RecL      Blk   RM',X\n               INTO=RECORD                                       RS1207\n         BRAS  R14,SPACE1                                        RS1007\n*loop                                                            RS1007\nLE_FCB_01  DS 0H                                                 RS1007\n         CLC   COBOL_FIB_EYEC,=C'FIB'  is this a FIB ??          RS1007\n         JE    LE_FCB_02                                         RS1007\n         AHI   R8,4                    try +4                    RS1007\n         J     LE_FCB_01               loop                      RS1007\nLE_FCB_02      DS 0H                                             RS1007\n***      STRING64 (COBOL_FIB_DDN),1X,(COBOL_FIB_RECFM,,X),4X,          X\n               (COBOL_FIB_ACCESS,,X),3X,(COBOL_FIB_DSORG,,X),3X,       X\n               (COBOL_FIB_LRECL,,X),1X,(COBOL_FIB_BLK,,X),1X,          X\n               (COBOL_FIB_RM,,X),1X,(COBOL_FIB_OPEN_CLOSE,,X),1X,      X\n               (COBOL_FIB_I_O_VERB1,,X),1X,                            X\n               (COBOL_FIB_I_O_VERB2,,X),1X,                            X\n               (COBOL_FIB_BYTE18,,X),1X,(COBOL_FIB_BYTE19,,X),1X,      X\n               (COBOL_FIB_FS1,,X),1X,                                  X\n               (COBOL_FIB_FS2,,X),                                     X\n               INTO=RECORD             debugcode                 RS1007\n***      BRAS  R14,SPACE1              debugcode                 HP1107\n         STRING64 (COBOL_FIB_DDN),INTO=RECORD                    RS1007\n         BRAS  R10,LE_FCB_05                                     RS1007\n         DC    XL1'C0',CL3'U  '                                  HP1107\n         DC    XL1'98',CL3'FBS'                                  RS1007\n         DC    XL1'94',CL3'FBA'                                  RS1007\n         DC    XL1'92',CL3'FBM'                                  RS1007\n         DC    XL1'90',CL3'FB '                                  RS1007\n         DC    XL1'84',CL3'FA '                                  RS1007\n         DC    XL1'82',CL3'FM '                                  RS1007\n         DC    XL1'80',CL3'F  '                                  RS1007\n         DC    XL1'58',CL3'VBS'                                  RS1007\n         DC    XL1'54',CL3'VBA'                                  RS1007\n         DC    XL1'52',CL3'VBM'                                  RS1007\n         DC    XL1'50',CL3'VB '                                  RS1007\n         DC    XL1'44',CL3'VA '                                  RS1007\n         DC    XL1'42',CL3'VM '                                  RS1007\n         DC    XL1'40',CL3'V  '                                  RS1007\n         DC    XL1'20',CL3'U  '                                  HP1107\n         DC    XL1'00',CL3'???'                 end of table     RS1007\n*  loop                                                          RS1007\nLE_FCB_05      DS 0H                                             RS1007\n         CLC   COBOL_FIB_RECFM,0(R10)          check             RS1007\n         JE    LE_FCB_06               jump if on                RS1007\n         LA    R10,4(,R10)             Skip entry                RS1007\n         CLI   0(R10),0                end of table?             RS1007\n         JNE   LE_FCB_05               not yet, loop             RS1007\n*  endloop                                                       RS1007\nLE_FCB_06      DS 0H                                             RS1007\n         MVC   RECORD+9(3),1(R10)      long text for RECFM       RS1007\n         BRAS  R10,LE_FCB_10                                     RS1007\n         DC    XL1'80',CL3'SEQ'                                  RS1007\n         DC    XL1'40',CL3'RAN'                                  RS1007\n         DC    XL1'20',CL3'DYN'                                  RS1007\n         DC    XL1'10',CL3'SPA'                                  RS1107\n         DC    XL1'00',CL3'???'                 end of table     RS1007\n*  loop                                                          RS1007\nLE_FCB_10      DS 0H                                             RS1007\n         CLC   COBOL_FIB_ACCESS,0(R10)         check             RS1007\n         JE    LE_FCB_11               jump if on                RS1007\n         LA    R10,4(,R10)             Skip entry                RS1007\n         CLI   0(R10),0                end of table?             RS1007\n         JNE   LE_FCB_10               not yet, loop             RS1007\n*  endloop                                                       RS1007\nLE_FCB_11      DS 0H                                             RS1007\n         MVC   RECORD+15(3),1(R10)     long text for Access      RS1007\n         BRAS  R10,LE_FCB_15                                     RS1007\n         DC    XL1'88',CL4'ESDS'                                 RS1007\n         DC    XL1'84',CL4'PS  '                                 RS1007\n         DC    XL1'80',CL4'PS  '                                 RS1007\n         DC    XL1'48',CL4'KSDS'                                 RS1007\n         DC    XL1'40',CL4'KSDS'                                 RS1007\n         DC    XL1'28',CL4'RRDS'                                 RS1007\n         DC    XL1'20',CL4'RRDS'                                 RS1007\n         DC    XL1'10',CL4'LSEQ'                                 HP1107\n         DC    XL1'00',CL4'??? '                end of table     RS1007\n*  loop                                                          RS1007\nLE_FCB_15      DS 0H                                             RS1007\n         CLC   COBOL_FIB_DSORG,0(R10)          check             RS1007\n         JE    LE_FCB_16               jump if on                RS1007\n         LA    R10,5(,R10)             Skip entry                RS1007\n         CLI   0(R10),0                end of table?             RS1007\n         JNE   LE_FCB_15               not yet, loop             RS1007\n*  endloop                                                       RS1007\nLE_FCB_16      DS 0H                                             RS1007\n         MVC   RECORD+20(4),1(R10)     long text for DSORG       RS1007\n         STRING64 (RECORD,26),1X,                                      X\n               (COBOL_FIB_LRECL,F,R9B),1X,(COBOL_FIB_BLK,F,R9B),       X\n               INTO=RECORD                                       RS1007\n         BRAS  R10,LE_FCB_20                                     RS1007\n         DC    XL1'80',CL2'F '                                   RS1007\n         DC    XL1'40',CL2'V '                                   RS1007\n         DC    XL1'20',CL2'U '                                   RS1007\n         DC    XL1'10',CL2'D '                                   RS1007\n         DC    XL1'00',CL4'??? '                end of table     RS1007\n*  loop\nLE_FCB_20      DS 0H                                             RS1007\n         CLC   COBOL_FIB_RM,0(R10)\n         JE    LE_FCB_21               jump if on                RS1007\n         LA    R10,3(,R10)             Skip entry                RS1007\n         CLI   0(R10),0                end of table?             RS1007\n         JNE   LE_FCB_20               not yet, loop             RS1007\n*  endloop\nLE_FCB_21      DS 0H                                             RS1007\n         MVC   RECORD+48(2),1(R10)     text for recording mode   HP1107\n         LA    R3,RECORD+51            R3 for #STATUS            HP1107\n        #STATUS COBOL_FIB_OPEN_CLOSE,BIT0,'Input'                RS1007\n        #STATUS COBOL_FIB_OPEN_CLOSE,BIT1,'Output'               RS1007\n        #STATUS COBOL_FIB_OPEN_CLOSE,BIT2,'IO'                   RS1007\n        #STATUS COBOL_FIB_OPEN_CLOSE,BIT3,'Extent'               RS1007\n        #STATUS COBOL_FIB_OPEN_CLOSE,BIT4,'Reverse'              RS1007\n        #STATUS COBOL_FIB_OPEN_CLOSE,BIT5,'Norewind'             RS1007\n        #STATUS COBOL_FIB_OPEN_CLOSE,BIT6,'Close'                RS1007\n        #STATUS COBOL_FIB_OPEN_CLOSE,BIT7,'Close-R'              RS1007\n        #STATUS COBOL_FIB_I_O_VERB1,BIT4,'Read-IO'               RS1007\n        #STATUS COBOL_FIB_I_O_VERB1,BIT2+BIT3+BIT5,'Write-IO'    RS1007\n        #STATUS COBOL_FIB_I_O_VERB1,BIT6,'Rewrite-IO'            RS1007\n        #STATUS COBOL_FIB_I_O_VERB1,BIT7,'Start-IO'              RS1007\n        #STATUS COBOL_FIB_I_O_VERB2,BIT0,'Delete-IO'             RS1007\n        #STATUS COBOL_FIB_I_O_VERB2,BIT1,'Sort-IO-G'             RS1007\n        #STATUS COBOL_FIB_I_O_VERB2,BIT2,'Sort-IO-U'             RS1007\n         MVC   0(2,R3),=C'E '                                    RS1007\n        #STATUS COBOL_FIB_BYTE18,BIT4,'L'                        RS1007\n         BRASL R14,SPACE1                                        RS1007\n         CHI   R9,1                   Last entry?                RS1107\n         JE    LE_FCB_97              jump around RENT           RS1107\n         TM    LE_STATUS_BYTE_03,BIT1 RENT?                      RS1107\n         JO    LE_FCB_95                yes                      RS1107\n         L     R8,SAVE_CUR_FCB_CELL   Restore last FCB-CELL\n         AHI   R8,4                   Next FCB-CELL\n         ST    R8,SAVE_CUR_FCB_CELL   Keep it for later\n         L     R8,0(R8)               Next FCB\n         L     R8,164(R8)             Next FIB\n         J     LE_FCB_97              jump around RENT           RS1107\nLE_FCB_95 DS 0H\n*              Was 160(R8), but COBOL/2 V1 M2 R0 is only 128...  PF0608\n         LA    R8,128(R8)              next entry                PF0608\nLE_FCB_97 DS 0H\n         BRCT  R9,LE_FCB_01            loop                      RS1007\n*  endloop                                                       RS1007\nLE_FCB_END DS 0H                                                 RS1007\n         BRAS  R14,BLANK1                                        RS1107\n         STRING64 '------------ End  --------------------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD\n         BRAS  R14,SPACE2\n*>--moved end ---------------------------------------------------HP1107\n*>---------------------------------------------------------------HP1107\n*>-      check for submodul-analysis                             HP1107\n*>---------------------------------------------------------------HP1107\n         CLI   csect_analyze_kz,C'M'  first csect (main-ep)      HP1107\n         je    BINDER_Anf             yes, skip csect-info       HP1107\n         CLI   csect_analyze_kz,C'S'  any more csects ?          HP1107\n         je    COBANAL_Csect_Loop                                HP1107\n         mvc   PGMNAME_GET,PGMNAME_sav                           HP1107\n         MVI   PRINT_LEAD_SPACE,C'N' Insert space                HP1107\n         J     COBANAL_EXIT           main-loop                  HP1107\nBINDER_Anf  DS    0H                                             HP1107\n*>---------------------------------------------------------------HP1107\n         BRAS  R14,BINDER_INFO\n         BRAS  R14,CEEUOPT_INFO\nCICS     DS    0H\n         STRING64 '------------ CICS (contains also included Csects) ',X\n               '---------------------------------------------------',  X\n               INTO=RECORD\n         BRAS  R14,SPACE2\n         CLC   CSV_OUTXTLST_ENTRR,=F'1' only one extent ??       RS0704\n         JNH   LE_CICS                                           RS0704\n         STRING64 'This module was loaded into more then one extent,', X\n               ' perhaps it is a DLL with different RMODE',INTO=RECORD\n         BRAS  R14,SPACE1                                        RS0704\n         STRING64 'CobAnal analyze the first extent only!!!',          X\n               INTO=RECORD\n         BRAS  R14,SPACE1                                        RS0704\nLE_CICS  DS    0H\n         L     R5,CSV_OUTXTLST_ELP1  Start of data to be searchedRS0704\n*        STRING64 4X,(00(R5),4,X),1X,(04(R5),4,X),1X,(08(R5),4,X),1X,  X\n               (12(R5),4,X),3X,(00(R5),16),                            X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n         L     R4,CSV_OUTXTLST_EL1   Length of string            RS0704\n         AR    R4,R5         Points to the end of data\n         LR    R8,R4         keep it for later\n         LA    R0,C'D'       Search for 'D'\nLE_CICS_10  DS    0H\n         SRST  R4,R5         Search\n         BRC   1,LE_CICS_10  Search interrupted, continue        RS1007\n         BRC   2,LE_CICS_20  String not found                    RS1007\n         LR    R2,R8         End of string\n         SR    R2,R4         minus found at\n         CH    R2,=H'9'      at least 9 bytes ???\n         JL    LE_CICS_20    no leave\n         CLC   =C'DFHEITAB ',0(R4)\n         JE    LE_CICS_11\n         LR    R5,R4\n         LA    R5,1(,R5)     +1\n         LR    R4,R8\n         J     LE_CICS_10    Search again\nLE_CICS_11  DS    0F\n*        STRING64 'CICS Precompiler Debug2 R2=',((R2),,X),'<- ',       X\n               'R4=',((R4),,X),'<- ',                                  X\n               'R8=',((R8),,X),'<- ',                                  X\n               'VALUE=',(9(R4),3,T),'<-',                              X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n         STRING64 'COBOL2',INTO=CSCCOBOL                          *CSC*\n         STRING64 'P',(9(R4),3,T),INTO=CSCCICS                    *CSC*\n         STRING64 'CICS Precompiler Version: ',                        X\n               (9(R4),3,T),INTO=RECORD\n         CLC   CSCCOMP(11),=CL11'OS/VS/COBOL' OS/VS/Cobol ?      RS1107\n         JNE   LE_CICS_12             no, jump arounded          RS1107\n         STRING64 'n/a',INTO=CSCCOBOL Set n/a for OS/VS Cobol    RS1107\nLE_CICS_12  DS    0H                                             RS1107\n         J     LE_CICS_50    end\nLE_CICS_20  DS    0H                                             RS1207\n         L     R5,CSV_OUTXTLST_ELP1  Start of data to be searchedRS1207\n         L     R4,CSV_OUTXTLST_EL1   Length of string            RS1207\n         AR    R4,R5         Points to the end of data           RS1207\n         LR    R8,R4         keep it for later                   RS1207\n         LA    R0,C'd'       Search for 'D'                      RS1207\nLE_CICS_21  DS    0H                                             RS1207\n         SRST  R4,R5         Search                              RS1207\n         BRC   1,LE_CICS_21  Search interrupted, continue        RS1207\n         BRC   2,LE_CICS_30  String not found                    RS1207\n         LR    R2,R8         End of string Test                  RS1207\n         SR    R2,R4         minus found at                      RS1207\n         CH    R2,=H'9'      at least 9 bytes ???                RS1207\n         JL    LE_CICS_30    no leave                            RS1207\n         CLC   =C'dfheitab ',0(R4)                               RS1207\n         JE    LE_CICS_22                                        RS1207\n         LR    R5,R4                                             RS1207\n         LA    R5,1(,R5)     +1                                  RS1207\n         LR    R4,R8                                             RS1207\n         J     LE_CICS_21    Search again                        RS1207\nLE_CICS_22  DS    0F                                             RS1207\n*        STRING64 'CICS Precompiler Debug2 R2=',((R2),,X),'<- ', RS1207X\n               'R4=',((R4),,X),'<- ',                            RS1207X\n               'R8=',((R8),,X),'<- ',                            RS1207X\n               'VALUE=',(9(R4),3,T),'<-',                        RS1207X\n               INTO=RECORD                                       RS1207\n*        BRAS  R14,SPACE1          <== next line                 RS1207\n         STRING64 'COBOL2',INTO=CSCCOBOL                         RS1207\n         STRING64 'P',(9(R4),3,T),INTO=CSCCICS                   RS1207\n         STRING64 'CICS Precompiler Version: ',                  RS1207X\n               (9(R4),3,T),INTO=RECORD Columns                   RS1207\n         CLC   CSCCOMP(11),=CL11'OS/VS/COBOL' OS/VS/Cobol ?      RS1207\n         JNE   LE_CICS_29             no, jump arounded          RS1207\n         STRING64 'n/a',INTO=CSCCOBOL Set n/a for OS/VS Cobol    RS1207\nLE_CICS_29  DS    0H                                             RS1207\n         J     LE_CICS_50    end Scroll                          RS1207\nLE_CICS_30 DS 0H ===>\n*        STRING64 'CICS Precompiler Debug3 R2=',((R2),,X),'<- ',       X\n               'R4=',((R4),,X),'<- ',                                  X\n               'R8=',((R8),,X),'<- ',                                  X\n               'VALUE=',(9(R4),3,T),'<-',                              X\n               INTO=RECORD\n*        BRAS  R14,SPACE1          <== next line\n         STRING64 'CICS Precompiler Version: ','n/a',INTO=RECORD\nLE_CICS_50  DS    0H\n         BRAS  R14,SPACE1\n         L     R5,CSV_OUTXTLST_ELP1  Start of data to be searchedRS0704\n         L     R4,CSV_OUTXTLST_EL1   Length of string            RS0704\n         AR    R4,R5         Points to the end of data\n         LR    R8,R4         keep it for later\n         LA    R0,C'D'       Search for 'D'\nLE_CICS_60  DS    0H\n         SRST  R4,R5         Search\n         BRC   1,LE_CICS_60  Search interrupted, continue        RS1007\n         BRC   2,LE_CICS_80  String not found                    RS1007\n         LR    R2,R8         End of string\n         SR    R2,R4         minus found at\n         CH    R2,=H'5'      at least 5 bytes ???\n         JL    LE_CICS_80    no leave\n         CLC   =C'DFHYI',0(R4)  DFHEILII\n         JE    LE_CICS_70\n         CLC   =C'DFHYC',0(R4)  DFHECI\n         JE    LE_CICS_70\n         LR    R5,R4\n         LA    R5,1(,R5)     +1\n         LR    R4,R8\n         J     LE_CICS_60    Search again\nLE_CICS_70  DS    0H\n         CLC   CSCCOBOL,=CL6'COBOL2'                              *CSC*\n         JE    LE_CICS_75                                         *CSC*\n*        Stub included but no precompiler so COBOL3 assumed\n         STRING64 'COBOL3',INTO=CSCCOBOL                          *CSC*\nLE_CICS_75  DS    0H\n         STRING64 'S',(5(R4),3,T),INTO=CSCCICS                    *CSC*\n         STRING64 'CICS Stub Version: ',                               X\n               (5(R4),3,T),INTO=RECORD\n         CLC   CSCCOMP(11),=CL11'OS/VS/COBOL' OS/VS/Cobol ?      RS1107\n         JNE   LE_CICS_76             no, jump arounded          RS1107\n         STRING64 'n/a',INTO=CSCCOBOL Set n/a for OS/VS Cobol    RS1107\nLE_CICS_76  DS    0H                                             RS1107\n         J     LE_CICS_90\nLE_CICS_80 DS 0H\n         STRING64 'CICS Stub Version: ','n/a',INTO=RECORD\nLE_CICS_90  DS    0H\n         BRAS  R14,SPACE1\n         L     R5,CSV_OUTXTLST_ELP1  Start of data to be searchedRS0704\n         L     R4,CSV_OUTXTLST_EL1   Length of string            RS0704\n         AR    R4,R5         Points to the end of data\n         LR    R8,R4         keep it for later\n         LA    R0,C'D'       Search for 'D'\nLE_CICS_100 DS    0H\n         SRST  R4,R5         Search\n         BRC   1,LE_CICS_100 Search interrupted, continue        RS1007\n         BRC   2,LE_CICS_120 String not found                    RS1007\n         LR    R2,R8         End of string\n         SR    R2,R4         minus found at\n         CH    R2,=H'8'      at least 8 bytes ???\n         JL    LE_CICS_120   no leave\n         CLC   =C'DFHXCSTB',0(R4)\n         JE    LE_CICS_110\n         LR    R5,R4\n         LA    R5,1(,R5)     +1\n         LR    R4,R8\n         J     LE_CICS_100   Search again\nLE_CICS_110 DS    0H\n         STRING64 'X',(13(R4),3,T),INTO=CSCCICS                  RS1007\n         STRING64 'CICS EXCI Version: ',                               X\n               (13(R4),3,T),INTO=RECORD\n         BRAS  R14,SPACE2                                         *CSC*\n         STRING64 'Note: This program uses the CICS EXCI ',       *CSC*X\n               'Interface.',INTO=RECORD                           *SC*X\n         J     LE_CICS_END   end\nLE_CICS_120 DS 0H\n         STRING64 'CICS EXCI Version: ','n/a',INTO=RECORD\nLE_CICS_END DS 0H\n         BRAS  R14,SPACE2\n*>---------------------------------------------------------------HP1107\n*>   any more csect's ? -> return to csect-loop                  HP1107\n         CLI   LE_SWITCH,C'3'    OS/VS COBOL ?                   RS1107\n         JE    INFO_COBOL_END      no, go ahead                  RS1107\n         CLI   csect_analyze_kz,C'S'  any more csects ?          HP1107\n         je    COBANAL_Csect_Loop                                HP1107\n*>---------------------------------------------------------------HP1107\n         MVC   PGMNAME_GET,PGMNAME_SAV                           PF0608\n         MVI   PRINT_LEAD_SPACE,C'N' Insert no space             PF0608\n         LA    R15,0\n         J     COBANAL_EXIT\nINFO_COBOL DS 0H\n         L     R4,SAVER4                                          *CSC*\n         USING COBOL_1_DSECT,R4                                   *CSC*\n         L     R5,C1_TGT_PTR     Ensure still point to COBOL1 TGT *CSC*\n*                                                                 *CSC*\n         CLI   C1_OEM_MOD_AREA,X'00' low-value ?                 RS0700\n         JE    INFO_COBOL_OEM                                    RS0700\n         STRING64 '------------ OEM Modified Area -------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD                                       RS0700\n         BRAS  R14,SPACE2                                        RS0700\n         STRING64 ' ',C1_OEM_MOD_AREA,INTO=RECORD                RS0700\n         BRAS  R14,SPACE2                                        RS0700\nINFO_COBOL_OEM DS 0H                                             RS0700\n         STRING64 '------------ Options in effect -------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD\n         BRAS  R14,SPACE2\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(8),=CL8'SYMDMP'\n         TM    C1_STATUS_BYTE_01,X'08'\n         JO    *+10\n         MVC   RECORD+1(8),=CL8'NOSYMDMP'\n         MVC   RECORD+10(6),=CL6'FLOW'\n         TM    C1_STATUS_BYTE_01,X'04'\n         JO    *+10\n         MVC   RECORD+10(6),=CL6'NOFLOW'\n         MVC   RECORD+17(7),=CL7'STATE'\n         TM    C1_STATUS_BYTE_01,X'02'\n         JO    *+10\n         MVC   RECORD+17(7),=CL7'NOSTATE'\n         MVC   RECORD+25(6),=CL6'OPT'\n         TM    C1_STATUS_BYTE_01,X'01'\n         JO    *+10\n         MVC   RECORD+25(6),=CL6'NOOPT'\n         MVC   RECORD+32(6),=CL6'TEST'\n         TM    C1_STATUS_BYTE_02,X'10'\n         JO    *+10\n         MVC   RECORD+32(6),=CL6'NOTEST'\n         MVC   RECORD+39(6),=CL6'RES'\n         TM    C1_STATUS_BYTE_03,X'80'\n         JO    *+10\n         MVC   RECORD+39(6),=CL6'NORES'\n         MVC   RECORD+46(8),=CL8'ENDJOB'\n         TM    C1_STATUS_BYTE_03,X'40'\n         JO    *+10\n         MVC   RECORD+46(8),=CL8'NOENDJOB'\n         MVC   RECORD+55(8),=CL8'OBJ370'\n         TM    C1_STATUS_BYTE_03,X'20'\n         JO    *+10\n         MVC   RECORD+55(8),=CL8'NOOBJ370'\n         MVC   RECORD+64(8),=CL8'COUNT'\n         TM    C1_STATUS_BYTE_03,X'08'\n         JO    *+10\n         MVC   RECORD+64(8),=CL8'NOCOUNT'\n         BRAS  R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(11),=CL11'READY_TRACE'                   RS0116\n         TM    C1_STATUS_BYTE_03,X'04'\n         JO    *+10\n         MVC   RECORD+1(11),=CL11'NO_TRACE'                      RS0116\n         BRAS  R14,SPACE2\n         CLI   csect_analyze_kz,C'M'  first csect (main-ep)      RS1107\n         jne   INFO_COBOL_OPT         yes, skip csect-info       RS1107\n         BRAS  R14,BINDER_INFO                                   RS1107\nINFO_COBOL_OPT DS 0H                                             RS1107\n         BRAS  R14,CEEUOPT_INFO                                  RS1107\n         J     CICS                                              RS1107\nINFO_COBOL_END DS 0H                                             RS1107\n         STRING64 '- - - - - - - - - - - - - - - - - - - - - - - ',    X\n               '- - - - - - - - - - - - - - - - - - - - - - - - - - -',X\n               ' -',                                                   X\n               INTO=RECORD                                       RS1107\n         BRAS  R14,SPACE2                                        RS1107\n         STRING64 'Sorry no more infomation for OS/VS COBOL',          X\n               INTO=RECORD\n         BRAS  R14,SPACE2                                         *CSC*\n         STRING64 'This should be considered a significant ',     *CSC*X\n               'business risk.',INTO=RECORD                       *CSC*\n         BRAS  R14,SPACE1                                         *CSC*\n         STRING64 'Please SERIOUSLY consider ',                   *CSC*X\n               'upgrading this program to Enterprise COBOL V3',   *CSC*X\n               INTO=RECORD\n         BRAS  R14,SPACE1\n         STRING64 '------------ End  --------------------------------',X\n               '---------------------------------------------------',  X\n               INTO=RECORD\n         BRAS  R14,SPACE2\n*>---------------------------------------------------------------HP1107\n*>   any more csect's ? -> return to csect-loop                  HP1107\n*>---------------------------------------------------------------HP1107\n         CLI   csect_analyze_kz,C'S'  any more csects ?          HP1107\n         je    COBANAL_Csect_Loop                                HP1107\n*>---------------------------------------------------------------HP1107\n         MVC   PGMNAME_GET,PGMNAME_SAV                           PF0608\n         MVI   PRINT_LEAD_SPACE,C'N' Insert no space             PF0608\n         LA    R15,0\n         J     COBANAL_EXIT\n         DROP  R4,R5\n*------------------------------------------------------------*\n* Print                                                      *\n*------------------------------------------------------------*\nBLANK1   DS 0H                                                   RS1107\n         ST    R14,SAVER14                                       RS1107\n         LA    R1,SYSPRINT         GET OUTPUT DCB ADDRESS        RS1107\n         LA    R0,BLANKS           GET OBJECT NAME ADDRESS       RS1107\n         PUT   (1),(0)             WRITE NAME TO NOTIFY DATA SET RS1107\n         L     R14,SAVER14                                       RS1107\n         BR    R14            return                             RS1107\nSPACE2   DS 0H\n         ST    R14,SAVER14\n         LA    R1,SYSPRINT         GET OUTPUT DCB ADDRESS\n         LA    R0,RECORD           GET OBJECT NAME ADDRESS\n         CLI   PRINT_LEAD_SPACE,C'Y' Insert space                HP1107\n         JNE   SPACE2_01\n         AHI   R0,-4\nSPACE2_01 DS 0H\n         PUT   (1),(0)             WRITE NAME TO NOTIFY DATA SET\n         LA    R1,SYSPRINT         GET OUTPUT DCB ADDRESS\n         LA    R0,BLANKS           GET OBJECT NAME ADDRESS\n         PUT   (1),(0)             WRITE NAME TO NOTIFY DATA SET\n         L     R14,SAVER14\n         BR    R14            return\nSPACE1   DS 0H\n         ST    R14,SAVER14\n         LA    R1,SYSPRINT         GET OUTPUT DCB ADDRESS\n         LA    R0,RECORD           GET OBJECT NAME ADDRESS\n         CLI   PRINT_LEAD_SPACE,C'Y'  Insert space               HP1107\n         JNE   SPACE1_01\n         AHI   R0,-4\nSPACE1_01 DS 0H\n         PUT   (1),(0)             WRITE NAME TO NOTIFY DATA SET\n         L     R14,SAVER14\n         BR    R14            return\n*------------------------------------------------------------*    *CSC*\n* Print SUMMARY                                              *    *CSC*\n*------------------------------------------------------------*    *CSC*\nSUMMARY2 DS 0H                                                    *CSC*\n         CLI   SUMMARYR,C'N'       Is SUMMARY DD Allocated?       *CSC*\n         BER   R14                 No, No point in writing!       *CSC*\n         ST    R14,SAVER14                                        *CSC*\n         LA    R1,SUMMARY          GET OUTPUT DCB ADDRESS         *CSC*\n         LA    R0,RECORD           GET OBJECT NAME ADDRESS        *CSC*\n         PUT   (1),(0)             WRITE NAME TO NOTIFY DATA SET  *CSC*\n         LA    R1,SUMMARY          GET OUTPUT DCB ADDRESS         *CSC*\n         LA    R0,BLANKS           GET OBJECT NAME ADDRESS        *CSC*\n         PUT   (1),(0)             WRITE NAME TO NOTIFY DATA SET  *CSC*\n         L     R14,SAVER14                                        *CSC*\n         BR    R14            return                              *CSC*\nSUMMARY1 DS 0H                                                    *CSC*\n         CLI   SUMMARYR,C'N'       Is SUMMARY DD Allocated?       *CSC*\n         BER   R14                 No, No point in writing!       *CSC*\n         ST    R14,SAVER14                                        *CSC*\n         LA    R1,SUMMARY          GET OUTPUT DCB ADDRESS         *CSC*\n         LA    R0,RECORD           GET OBJECT NAME ADDRESS        *CSC*\n         PUT   (1),(0)             WRITE NAME TO NOTIFY DATA SET  *CSC*\n         L     R14,SAVER14                                        *CSC*\n         BR    R14            return                              *CSC*\nJUSTDATA_PUT EQU *                                                =CMS=\n         CLI   JUSTDATA_R,C'N'     Is JUSTDATA DD Allocated?      =CMS=\n         BER   R14                 No, No point in writing|       =CMS=\n         MVC   JUSTDATA_DSN,CSCDSN                                =CMS=\n         ST    R14,SAVER14                                        =CMS=\n         LA    R1,JUSTDATA         GET OUTPUT DCB ADDRESS         =CMS=\n         LA    R0,JUSTDATA_        GET OBJECT NAME ADDRESS        =CMS=\n         PUT   (1),(0)             WRITE NAME TO NOTIFY DATA SET  =CMS=\n         L     R14,SAVER14                                        =CMS=\n         BR    R14            return                              =CMS=\n***************************************************************\n*\n*                  get Member Name from PDS-Directory\n*\n***************************************************************\nGETMEM   DS    0H                                                PF0608\n         ST    R14,GETMSAVE            save return address\n         L     R4,ADBLKPTR             restore pointer\n         CLC   DIRAREA(2),=XL2'0000'   Directory present?\n         JNE   NEWNAME                   yes, get next\nNEWBLOCK DS    0H                                                PF0608\n         GET   INPUT,DIRAREA           get a new directory\n         LA    R4,DIRAREA              get work area address\n         AH    R4,DIRAREA              + length\n         ST    R4,ADBLKEND             save ending address\n         LA    R4,DIRAREA+2            Skip LL bytes\n         ST    R4,ADBLKPTR             save pointer\nNEWNAME  DS    0H                                                PF0608\n         C     R4,ADBLKEND             end of current dir block\n         JNL   NEWBLOCK                  yes, get new block\n         MVC   PGMNAME_GET,0(R4)       Save member-name\n         IC    R5,11(R4)               LOOK FOR ANY USER TTRN'S\n         SLL   R5,27                   SHIFT OFF UNWANTED BITS\n         SRL   R5,26                   SHIFT BACK THE USABLE BITS\n         LA    R4,12(R4,R5)            ADD DISPL TO GET OVER TT\n         ST    R4,ADBLKPTR             save Pointer next mem\n         L     R14,GETMSAVE            restore return address\n         BR    R14                     goback\n*---------------------------------------------------------------------*\n*        move status flags                                            *\n*---------------------------------------------------------------------*\n$$STATUS LA    R15,0                   do not change CC          RS1007\n         IC    R15,0(,R14)             get length                RS1007\n         JZ    $$STATUS8               flag off, goback          RS1007\n         EX    R15,MOVE_$STATUS        move status flags         PF0708\n*        EX    R15,=S(X'200'(R13),0(R3),1(R14)) MVC 0(*-*,R3),1(R14)007\n         LA    R3,2(R15,R3)            bump pointer up           RS1007\n$$STATUS8 LA   R14,2(R15,R14)          return address            RS1007\n         CLI   0(R14),0                alignment byte?           RS1007\n         BNER  R14                     no, goback                RS1007\n         B     1(,R14)                 yes, skip it              RS1007\nCOBANAL_END    DS  0D\n*>---------------------------------------------------------------HP1107\n*>   additional csect-analysis for sub-module                    HP1107\n*>---------------------------------------------------------------HP1107\nCOBANAL_Csect_Loop DS 0H                                         HP1107\n         lh    R3,csect_anz_tabelem                              HP1107\n         ch    r3,=h'0'             any more csects ?            HP1107\n         Je    COBANAL_EXIT         no, leave                    HP1107\n*>avoid s0c4 within program-objects                              HP1107\n*>unknown, how to see, what's the associated CSV_OUTXTLST_ELPx   HP1107\n         CLC   CSV_OUTXTLST_ENTRR,=F'1' only one extent ??       HP1107\n         JNH   COBANAL_Csect_Check0A                             HP1107\n*>just for test |                                                HP1107\n*        CLC   CSV_OUTXTLST_ENTRR,=F'2' p.o. with 2 extends ?    RS0108\n*        JNE   COBANAL_Csect_Check0B                             RS0108\n*        mvc   CSV_LOADPT,CSV_OUTXTLST_ELP2                      RS0108\n*        J     COBANAL_Csect_Check0A                             HP1107\nCOBANAL_Csect_Check0B   DS 0H                                    HP1107\n         STRING64 'This module was loaded into more then one extent,', X\n               ' sub-module analysis aborted',                   PF0608X\n               INTO=RECORD                                       PF0608\n         BRAS  R14,SPACE1                                        HP1107\n         J     COBANAL_EXIT         do some more research ?|     HP1107\nCOBANAL_Csect_Check0A   DS 0H                                    HP1107\n         BCTR  R3,0                                              HP1107\n         sth   R3,csect_anz_tabelem                              HP1107\n         ch    r3,=h'0'             last csect        ?          HP1107\n         Jne   COBANAL_Csect_Check0                              HP1107\n         MVI   csect_analyze_kz,C'L'                             HP1107\nCOBANAL_Csect_Check0    DS 0H                                    HP1107\n         l     R3,csect_tabelem_act csect-elem                   HP1107\n         la    R4,10(r3)                                         HP1107\n         st    R4,csect_tabelem_act next-entry                   HP1107\n         l     R4,2(r3)             csect-offset                 HP1107\n         xr    r1,r1                                             HP1107\n         l     r1,CSV_LOADPT        load-point  lmod             HP1107\n         ar    r4,r1                csect-postion in lmod        HP1107\n         st    r4,csect_anf         csect-postion in lmod        HP1107\n         mvc   hadr,ADR_PGMNAME     ep                           HP1107\n         xi    hadr,x'80'                                        HP1107\n         l     r1,hadr              ep                           HP1107\n         cr    r4,r1                                             HP1107\n         je    COBANAL_Csect_Loop   main-csect  |                HP1107\nCOBANAL_Csect_Check4    DS 0H                                    RS0316\n         clc   0(2,R3),=C'C5'       Enterprise Cobol V5          RS0316\n         jne   COBANAL_Csect_Check3                              RS0316\n         J     ENTCOBOLV5                                        RS0316\nCOBANAL_Csect_Check3    DS 0H                                    HP1107\n         clc   0(2,R3),=C'C1'       cobol/370 ff                 HP1107\n         jne   COBANAL_Csect_Check2                              HP1107\n         J     COBOL_370                                         HP1107\nCOBANAL_Csect_Check2    DS 0H                                    HP1107\n         clc   0(2,R3),=C'C2'       cobol2                       HP1107\n         jne   COBANAL_Csect_Check1                              HP1107\n         J     COBOL_2                                           HP1107\nCOBANAL_Csect_Check1    DS 0H                                    HP1107\n         clc   0(2,R3),=C'C3'       osvs                         HP1107\n         jne   COBANAL_Csect_Loop   no cobol-csect               HP1107\n         J     COBOL_1                                           HP1107\n*        l     R3,saveR3                                         HP1107\n*>---------------------------------------------------------------HP1107\n*\n*------------------------------------------------------------*\n* SONSTIGE DEFINITIONS                                       *\n*------------------------------------------------------------*\n****************************** CONSTANTS *****************************\n*\n*------------------------------------------------------------*\n* Workarea below the line                                    *\n*------------------------------------------------------------*\nCOBANAL_WORK        DSECT\nEYECATCHER          DS    CL8   'COBANAL'\n*>---------------------------------------------------------------HP1107\nCSECT_ANF           DS    F                                      HP1107\nSAVER3              DS    F                                      HP1107\nHADR                DS    F                                      HP1107\nPGMNAME_SAV         DS    CL8                                    HP1107\nCSECT_ANALYZE_KZ    DS    CL1                                    HP1107\nCSECT_ACT_KZ        DS    CL2                                    HP1107\nCSECT_TABELEM_ACT   DS    F                                      HP1107\nCSECT_ANZ_TABELEM   DS    H                                      HP1107\nCSECT_TABLE         DS    50CL10                                 HP1107\n*>---------------------------------------------------------------HP1107\nPGMNAME             DS    CL8   Pgmname from the parmlist\nPGMNAME_GET         DS    CL8   Pgmname from GETMEM\nPGMNAME_PDS2FTB2    DS    CL2   PDS2FTB2 from GETMEM             RS0316\nSAVEAREA            DS    36F   SaveArea for AMODE64 (144 Bytes)\nSAVER1              DS    F                                       *CSC*\nSAVER4              DS    F                                       *CSC*\nSAVER5              DS    F\nSAVER4_AND_R5       DS    F,F                                    RS1007\nSNAPREGS DS    A(14,15,0,1,2,3,14,15)                            RS1007\nSAVER14             DS    F\nSAVER15             DS    F                                       *CSC*\nIRETCODE            DS    F\nRETCODE             DS    F\nRSNCODE             DS    F\nADR_COBANAL_WORK    DS    F     Save Workarea pointer\nADR_COBANAL_PARM    DS    F     Save Parmlist pointer\nADR_PGMNAME         DS    F     Save entry-point Application PGM\nADR_PIDENTRY        DS    F     Save A(PIDTABLE) entry found     PF0608\nOFF_PGMNAME         DS    F     Save entry-point offset          PF0608\nCNT_R14SAVE         DS    F     Save for R14 in ADJUST_COUNTS    PF0608\nRC_PGMNAME          DS    F     Save application RC\nPARM_LENGTH         DS    H     Parm length wihout header\n                    DS    H     FILLER                           PF0608\nGETMSAVE            DS    F     Save R14 for GETM\nBINDSAVE            DS    F Save R14 for Binder-Info\nADBLKPTR            DS    F     Parm length without header\nADBLKEND            DS    F     Parm+length without header\nDOALL               DS    CL1   Analyze a complete loadlib\nDD_COBANAL          DS    CL1   Switch for DD CobAnal\nDD_SYSIN            DS    CL1   Switch for DD SYSIN              RS1207\nLOADERR             DS    CL1   Switch for LOAD errors           PF0608\nFIXEDSUM            DS    CL1   Remember fixed LANG in SUMMARY   PF0608\nSETRMODE            DS    CL1   Remember already set RMODE       RS0316\n                    DS    CL2   FILLER                           PF0608\nDOUBLE              DS    D\nCSV_OUTVALID        DS    F     Length returned by CSVQuery\nCSV_OUTPID          DS    CL4   PID   returned by CSVQuery       PF0608\nCSV_OUTEPA64        DS    D     EPA64 returned by CSVQuery\nCSV_LENGTH          DS    F     Length returned by CSVQuery\nCSV_LOADPT          DS    F     Loadptr returned by CSVQuery\nCSV_EPTOKEN         DS    CL8   TOKEN returned by CSVQuery\nCSV_OUTXTLST        DS    0C\nCSV_OUTXTLST_ENTR   DS    F     Number of entries (reserved room)\nCSV_OUTXTLST_ENTRR  DS    F     Number of entries returned\nCSV_OUTXTLST_ELP1   DS    F     Extent-1 load point\nCSV_OUTXTLST_EL1    DS    F     Extent-1 Length\nCSV_OUTXTLST_ELP2   DS    F     Extent-2 load point\nCSV_OUTXTLST_EL2    DS    F     Extent-2 Length\nCSV_OUTXTLST_ELP3   DS    F     Extent-3 load point\nCSV_OUTXTLST_EL3    DS    F     Extent-3 Length\nCSV_OUTXTLST_ELP4   DS    F     Extent-4 load point\nCSV_OUTXTLST_EL4    DS    F     Extent-4 Length\nCSV_OUTXTLST_ELP5   DS    F     Extent-5 load point\nCSV_OUTXTLST_EL5    DS    F     Extent-5 Length\nCSV_OUTXTLST_ELP6   DS    F     Extent-6 load point\nCSV_OUTXTLST_EL6    DS    F     Extent-6 Length\nCSV_OUTXTLST_ELP7   DS    F     Extent-7 load point\nCSV_OUTXTLST_EL7    DS    F     Extent-7 Length\nCSV_OUTXTLST_ELP8   DS    F     Extent-8 load point\nCSV_OUTXTLST_EL8    DS    F     Extent-8 Length\nCSV_OUTXTLST_FILLER DS    CL64\nCSV_OUTATTR1        DS    C\nCSV_OUTATTR2        DS    C\nCSV_OUTATTR3        DS    C\n                    DS    C     FILLER                           PF0608\nIEW_BNLI_PTR        DS    F     Ptr of IEWBUFF area\nIEW_IDLI_PTR        DS    F     Ptr of IEWBUFF area              RS1007\nIEW_ESDI_PTR        DS    F     Ptr of IEWBUFF area              RS1007\nIEW_IDUI_PTR        DS    F     Ptr of IEWBUFF area              RS1007\nIEW_IDZI_PTR        DS    F     Ptr of IEWBUFF area              RS1007\nIEW_IDBI_PTR        DS    F     Ptr of IEWBUFF area              RS1007\nIEW_DTOKEN          DS    CL8   Dialog Token for IEWBIND\nIEW_WKTOKEN         DS    CL8   Workmod Token for IEWBIND\nIEW_CURSORN         DS    F     Cursor for GETN\nIEW_CURSORD         DS    F     Cursor for GETD\nIEW_COUNTN          DS    F     Count for GETN\nIEW_COUNTD          DS    F     Count for GETD\nIEW_TCOUNT          DS    F     Total number of Sections\nIEW_MBR             DS    0H    Label for MEMBER=   for INCLUDE  PF0608\nIEW_MBRL            DS    H     Length of IEW_MBRN  for INCLUDE  PF0608\nIEW_MBRN            DS    CL8   Copy of PGMNAME_GET for INCLUDE  PF0608\nIEWBIND_FUNCTION    DS    CL8   IEWBIND Funtion for error        RS1007\nPRINT_LEAD_SPACE    DS    C     Insert space for sub-modules     RS1107\nSUM_DATE_SAVE       DS    CL7   Copy of IDL_DATE_PROCESSED       PF0608\n         CSVQUERY MF=(L,CSVQRYWK)\n         ASAXWC    MF=(L,MYLIST)\n         IEWBIND2 PLISTVER=MAX,MF=(L,IEWBIND)\n****************************** VARIABLES *****************************\nLE_SWITCH           DS    CL1   Switch for COBOL/370 or COBOL/2\nLE_PGM_NAME         DS CL8  name of program\nLE_COMP_YEAR        DS CL4  year of compilation\n*  3 bytes because of OS/VS COBOL\nLE_COMP_MONTH       DS CL3  month of compilation\nLE_COMP_DAY         DS CL2  day of compilation\nLE_COMP_HOURS       DS CL2  hours of compilation\nLE_COMP_MIN         DS CL2  minutes of compilation\nLE_COMP_SEC         DS CL2  seconds of compilation\nLE_VERS             DS CL2  version\nLE_REL              DS CL2  release\nLE_MOD              DS CL2  modification level\nLE_CCSID            DS XL2  Codepage\nLE_TGT_ADDRESS      DS A    TGT-Address (NORENT) or DAB (RENT)   RS1007\nLE_TGT_REG          DS X    80 = R13 40 ? R9                     RS1007\n                    DS CL3  Boundary                             RS1007\nLE_DAB_FIB_OFF      DS F    IDBA FIB Offset                      RS1007\nLE_TGT_FIB_PTR      DS F    FIB Pointer (RENT)                   RS1007\nLE_TGT_PTR_FCB_CELL DS F    FCB Pointer                          RS1007\nLE_TGT_NO_FCB       DS F    No of FCBs                           RS1007\nLE_TGT_WS_LENGTH    DS F    Length of working storage            RS1007\nLE_STATUS_BYTE      DS    0C   signature bytes\nLE_STATUS_BYTE_01   DS X    status byte\nLE_STATUS_BYTE_02   DS X    status byte\nLE_STATUS_BYTE_03   DS X    status byte\nLE_STATUS_BYTE_04   DS X    status byte\nLE_STATUS_BYTE_05   DS X    status byte\nLE_STATUS_BYTE_06   DS X    status byte\nLE_STATUS_BYTE_07   DS X    status byte\nLE_STATUS_BYTE_08   DS X    status byte\nLE_STATUS_BYTE_09   DS X    status byte\nLE_STATUS_BYTE_10   DS X    status byte\nLE_STATUS_BYTE_11   DS X    status byte\nLE_STATUS_BYTE_12   DS X    status byte\nLE_STATUS_BYTE_13   DS X    status byte\nLE_STATUS_BYTE_14   DS X    status byte\nLE_STATUS_BYTE_15   DS X    status byte\nLE_STATUS_BYTE_16   DS X    status byte\nLE_STATUS_BYTE_17   DS X    status byte\nLE_STATUS_BYTE_18   DS X    status byte\nLE_STATUS_BYTE_19   DS X    status byte\nLE_STATUS_BYTE_20   DS X    status byte\nLE_STATUS_BYTE_21   DS X    status byte\nLE_STATUS_BYTE_22   DS X    status byte\nLE_STATUS_BYTE_23   DS X    status byte\nLE_STATUS_BYTE_24   DS X    status byte\nLE_STATUS_BYTE_25   DS X    status byte\nLE_STATUS_BYTE_26   DS X    status byte Cobol for MVS and VM\nLE_STATUS_BYTE_27   DS X    status byte Cobol for MVS and VM\nLE_STATUS_BYTE_28   DS X    status byte Cobol V3R1\nLE_STATUS_BYTE_29   DS X    status byte Cobol V3R1\nLE_STATUS_BYTE_30   DS X    status byte E.C. V5\nLE_STATUS_BYTE_31   DS X    status byte E.C. V5\nLE_COBOL_SIGNAT     DS X    cobol signature level\nLE_DATA_STATEMENTS  DS XL4  number of data items\nLE_PROC_LINES       DS XL4  number of proc statements\nLE_YEAR_WINDOW      DS H    YearWindow\nLE_ARCHLEVEL        DS X    Architecure level\nLE_OPT_LEVEL        DS X    Optimization evel\nLE_BUILD_LEVEL      DS CL7  Build Level                          RS0316\nSYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,                      X\n               RECFM=FB,LRECL=121\nSUMMARY  DCB   DSORG=PS,MACRF=PM,DDNAME=SUMMARY,                  *CSC*X\n               RECFM=FB,LRECL=121                                 *CSC*\nJUSTDATA DCB   DSORG=PS,MACRF=PM,DDNAME=JUSTDATA,                 =CMS=X\n               RECFM=FB,LRECL=#JUSTDATA_                          =CMS=\nINPUT    DCB   DSORG=PS,DDNAME=COBANAL,MACRF=(GM),                     X\n               RECFM=U,BLKSIZE=256\nLOADL    DCB   DSORG=PO,DDNAME=COBANAL,MACRF=(R),                PF0608X\n               RECFM=U,DCBE=*-*                                  PF0608\nLOADLE   DCBE RMODE31=BUFF                                       RS0516\nSYSIN    DCB   DSORG=PS,DDNAME=SYSIN,MACRF=(GM),                 RS1207X\n               RECFM=FB,LRECL=80,DCBE=SYSINE                     RS0908\nSYSINE   DCBE RMODE31=BUFF,EODAD=COBANAL_FIN                     RS0908\nJUSTDATA_R          DS CL1                                        =CMS=\nJUSTDATA_           DS 0C                                         =CMS=\nJUSTDATA_DSN        DS CL44                                       =CMS=\nJUSTDATA_MEM        DS CL8                                        =CMS=\nJUSTDATA_PGM        DS CL8                                        =CMS=\nJUSTDATA_LANG       DS CL8                                        =CMS=\nJUSTDATA_COMPILER   DS CL8                                        =CMS=\nJUSTDATA_VV         DS CL2                                        =CMS=\nJUSTDATA_RR         DS CL2                                        =CMS=\nJUSTDATA_MM         DS CL2                                        =CMS=\nJUSTDATA_LE_CYEAR   DS CL4  year of compilation                   =CMS=\nJUSTDATA_LE_CMONTH  DS CL2  month of compilation                  =CMS=\nJUSTDATA_LE_CDAY    DS CL2  day of compilation                    =CMS=\nJUSTDATA_LE_CHOURS  DS CL2  hours of compilation                  =CMS=\nJUSTDATA_LE_CMIN    DS CL2  minutes of compilation                =CMS=\nJUSTDATA_LE_CSEC    DS CL2  seconds of compilation                =CMS=\n#JUSTDATA_          EQU *-JUSTDATA_                               =CMS=\nDIRAREA             DS    XL256          PDS-Directory input area\nSYSIN_DATA          DS CL80                                      RS1207\nPARMLIST            DS XL40\nJUST_SPACE          DS CL4               Please leave it here\nRECORD              DS CL132\n*                                                                 *CSC*\n* CSC WORKAREA                                                    *CSC*\nLEFOUND             DS    CL1            LE/370 module located?   *CSC*\nSUMMARYR            DS    CL1            Perform CSC Summary Func *CSC*\n*                                                                 *CSC*\nCSCDSN              DS   CL44            Dataset Name             *CSC*\n*                                                                 *CSC*\nCSCSUMM             DS   0CL122                                   *CSC*\nCSCPNAM             DS    CL9            Program Name             *CSC*\n                    DS    CL1            Filler                   *CSC*\nCSCLANG             DS    CL9            Program Language         *CSC*\n                    DS    CL1            Filler                   *CSC*\nCSCCICS             DS    CL4            CICS EI Stub level       *CSC*\n                    DS    CL1            Filler                   *CSC*\nCSCCOBOL            DS    CL6            CICS EI Stub level       *CSC*\n                    DS    CL1            Filler                   *CSC*\nCSCCOMP             DS    CL17           Compiler Details         *CSC*\n                    DS    CL1            Filler                   *CSC*\nCSCLE               DS    CL3            LE370? YES/NO            *CSC*\n                    DS    CL2            Filler                   *CSC*\nCSCD31              DS    CL2            DATA(31)? YES/NO         *CSC*\n                    DS    CL2            Filler                   *CSC*\nCSCRMODE            DS    CL3            RMODE - Compiler         *CSC*\n                    DS    CL1            Filler                   *CSC*\nCSCCRNT             DS    CL3            Compiled RENT? YES/NO    *CSC*\n                    DS    CL2            Filler                   *CSC*\nCSCRM               DS    CL3            RMODE - LINK            RS0316\n                    DS    CL1            Filler                  RS0316\nCSCAM               DS    CL3            AMODE - LINK             *CSC*\n                    DS    CL1            Filler                   *CSC*\nCSCLPRM             DS    CL25           Link Parameters          *CSC*\n                    DS    CL1            Filler                   *CSC*\nCSCDATE             DS    CL11           Comp Date yy.ddd         *CSC*\n                    DS    CL13           Filler                   *CSC*\n*                                                                 *CSC*\nCNT_ASSEMBLER       DS    PL3            Count of ASSEMBLER Progs *CSC*\nCNT_BMS             DS    PL3            Count of BMS Maps        *CSC*\nCNT_COBOLI          DS    PL3            Count of COBOL1    Progs *CSC*\nCNT_COBOL2          DS    PL3            Count of VS/COBOL2 Progs *CSC*\nCNT_COBOLLE         DS    PL3            Count of LE COBOL  Progs *CSC*\nCNT_C370            DS    PL3            Count of C/C++     Progs *CSC*\nCNT_FORTRAN         DS    PL3            Count of FORTRAN   Progs *CSC*\nCNT_INVALID         DS    PL3            Count of Invalid   Progs *CSC*\nCNT_NOTLOAD         DS    PL3            Count of NotLoaded ProgsPF0608\nCNT_EZTRV           DS    PL3            Count of EZTrieve+ ProgsPF0708\nCNT_LEASS           DS    PL3            Count of LE Assem  Progs *CSC*\nCNT_OTHER           DS    PL3            Count of Other     Progs *CSC*\nCNT_PLI             DS    PL3            Count of PL/I      Progs *CSC*\nCNT_TOTAL           DS    PL3            Count of Total     Progs *CSC*\nCNT_UNKNOWN         DS    PL3            Count of UNKNOWN   Progs *CSC*\nTOT_ASSEMBLER       DS    CL5            Total of ASSEMBLER Progs *CSC*\nTOT_BMS             DS    CL5            Total of BMS Maps        *CSC*\nTOT_COBOLI          DS    CL5            Total of COBOL1    Progs *CSC*\nTOT_COBOL2          DS    CL5            Total of VS/COBOL2 Progs *CSC*\nTOT_COBOLLE         DS    CL5            Total of LE COBOL  Progs *CSC*\nTOT_C370            DS    CL5            Total of C/C++     ProgsRS1107\nTOT_FORTRAN         DS    CL5            Total of FORTRAN   Progs *CSC*\nTOT_INVALID         DS    CL5            Total of Invalid   Progs *CSC*\nTOT_NOTLOAD         DS    CL5            Total of Notloaded ProgsPF0608\nTOT_EZTRV           DS    CL5            Total of EZTrieve+ ProgsPF0708\nTOT_LEASS           DS    CL5            Total of LE Assem  Progs *CSC*\nTOT_OTHER           DS    CL5            Total of Other     Progs *CSC*\nTOT_PLI             DS    CL5            Total of PL/I      Progs *CSC*\nTOT_TOTAL           DS    CL5            Total of all programs    *CSC*\nTOT_UNKNOWN         DS    CL5            Total of UNKNOWN   Progs *CSC*\nWORK                DS    D              General WORK AREA        *CSC*\nESDNAME             DS    D              ESD entry nams          PF0608\nPLINAME_AREA        DS    0D             PL/I internal name area PF0708\nPLINAME             DS    CL7            PL/I name w/leading '*' PF0708\nPLINAME_LEN         DS    X              PL/I internal name len  PF0708\nSAVE_CUR_FCB_CELL   DS    F              Save current FCB-CELL RS1107\n*                                                                 *CSC*\n*                                                                 *CSC*\nSWAWORK             DS    10F            WORK AREA                *CSC*\nSWAREQL1 SWAREQ MF=L                     WORK AREA FOR SWAREQ     *CSC*\nLOADWK   LOAD  EPLOC=,DCB=,                                      RS0908X\n               LSEARCH=,SF=L                                     RS0908\nBLDLLIST            DS    0CL100                                 RS0516\nBLDL_FF             DS    H             No of entries            RS0516\nBLDL_LL             DS    H             Length of entry          RS0516\nBLDL_NAME           DS    CL8           Name                     RS0516\nDIRTTRP             DS    CL3           TTR                      RS0516\nBLDL_CNCT DS    FL1            CONCATENATION NUMBER OF THE DATA SET\nBLDL_LIBF DS    C              LIBRARY FLAG FIELD\nBLDLLNRM EQU   X'00'          NORMAL CASE\nBLDLLLNK EQU   X'01'          IF DCB OPERAND IN BLDL MACRO INTRUCTION\n*                             WAS SPECIFIED AS ZERO, NAME WAS FOUND IN\n*                             LINK LIBRARY\nBLDLLJOB EQU   X'02'          IF DCB OPERAND IN BLDL MACRO INTRUCTION\n*                             WAS SPECIFIED AS ZERO, NAME WAS FOUND IN\n*                             JOB LIBRARY\nDIRFLAG  DS    X\nDIRALIAS EQU   X'80'          MEMBER IS AN ALIAS\nDIR2TTR  EQU   X'40'          TWO TTR'S TO UPDATE\nDIR1TTR  EQU   X'20'          ONE TTR TO UPDATE\nDIRUSER  DS    XL62\n         ORG   DIRUSER  FOLLOWING FOR LOAD MODULES\nDIRSTART DS    XL4            TTR OF FIRST TEXT BLOCK\nDIRNOTE  DS    XL3            TTR OF NOTELIST\nDIRNOTE# DS    X              NUMBER OF NOTELIST ENTRIES\nDIRATTR  DS    XL2            MEMBER ATTRIBUTES\nDIRSTORE DS    XL3            SIZE OF LOAD MODULE\nDIRTEXTL DS    XL2            LENGTH OF 1ST TEXT RECORD\nDIREPA   DS    XL3            ENTRY POINT ADDRESS\nDIRATTR2 DS    X          ADDITIONAL ATTRIBUTE BYTES:\nDIRAOSLE EQU   X'80'          VS LINKAGE EDITOR CREATED THIS MODULE\nDIR2BIG  EQU   X'40'          REQUIRES 16M OR MORE OF VIRTUAL STORAGE\nDIR2PAGA EQU   X'20'          PAGE ALIGNMENT REQUIRED FOR THIS MODULE\nDIR2SSI  EQU   X'10'          SSI INFORMATION IS PRESENT FOR MODULE\nDIRAPFLG EQU   X'08'          APF INFORMATION FOR THIS MODULE IS VALID\nDIR2LFMT EQU   X'04'          MODULE IS IN PROGRAM OBJECT FORMAT\nDIRATTR3 DS    X          ADDITIONAL ATTRIBUTE BYTES:\nDIRRMANY EQU   X'10'          RMODE=ANY\nDIRAA31  EQU   X'08'          AMODE=31 (ALIAS ENTRY)\nDIRAA64  EQU   X'04'          AMODE=64 (ALIAS ENTRY)          DRK OCT02\nDIRAA24  EQU   X'00'          AMODE=24 (ALIAS ENTRY)          DRK OCT02\nDIRAM31  EQU   X'02'          AMODE=31 (MAIN ENTRY)\nDIRAM64  EQU   X'01'          AMODE=64 (MAIN ENTRY)           DRK OCT02\nDIRAM24  EQU   X'00'          AMODE=24 (MAIN ENTRY)           DRK OCT02\nDIRATTR4 DS    X              COUNT OF RLD ENTRIES AFTER FIRST TEXT\nDIRAPF   DS    0XL2           APF (IF NOT SCAT, SSI OR ALIAS)\nDIREP    DS    XL3            ENTRY POINT (MAIN MEMBER)\nDIRREAL  DS    CL8            REAL NAME OF MEMBER\nDIRAPF2  DS    XL2            APF INFORMATION (ALIAS, NO SCAT OR SSI)\nDIREND2  DS    0X             END OF ALIAS SECTION\nIEW_SECTION         DS    0CL1049       Length (H), Name 1047    PF0608\nIEW_SECTION_LEN     DS    H             Length (H)               PF0608\nIEW_SECTION_DATA    DS    CL1047        Name 1047                PF0608\nCOBANAL_WORK_LENGTH EQU *-COBANAL_WORK  Length workarea\n*\n*------------------------------------------------------------*\n* Parameter (JCL)                                            *\n*------------------------------------------------------------*\nCOBANAL_PARM        DSECT\nCOBANAL_PARM_LENGTH DS H\n*\n*\n*------------------------------------------------------------*\n* Enterprise Cobol V5\n*------------------------------------------------------------*\nCOBOLV5_DSECT       DSECT\nCV5_Length          DS H\nCV5_CCSID           DS XL2  Codepage (COBOL V3R1 only)\nCV5_ARCHLEVEL       DS X    Architecure level\nCV5_OPT_LEVEL       DS X    Optimization evel\nCV5_STATUS_BYTE_28  DS X    status byte\nCV5_STATUS_BYTE_29  DS X    status byte\nCV5_STATUS_BYTE_30  DS X    status byte\nCV5_STATUS_BYTE_31  DS X    status byte\nCV5_STATUS_BYTE_01  DS X    status byte\nCV5_STATUS_BYTE_02  DS X    status byte\nCV5_STATUS_BYTE_03  DS X    status byte\nCV5_STATUS_BYTE_04  DS X    status byte\nCV5_STATUS_BYTE_05  DS X    status byte\nCV5_STATUS_BYTE_06  DS X    status byte\nCV5_STATUS_BYTE_07  DS X    status byte\nCV5_STATUS_BYTE_08  DS X    status byte\nCV5_STATUS_BYTE_09  DS X    status byte\nCV5_STATUS_BYTE_10  DS X    status byte\nCV5_STATUS_BYTE_11  DS X    status byte\nCV5_STATUS_BYTE_12  DS X    status byte\nCV5_STATUS_BYTE_13  DS X    status byte\nCV5_STATUS_BYTE_14  DS X    status byte\nCV5_STATUS_BYTE_15  DS X    status byte\nCV5_STATUS_BYTE_16  DS X    status byte\nCV5_STATUS_BYTE_17  DS X    status byte\nCV5_STATUS_BYTE_18  DS X    status byte\nCV5_STATUS_BYTE_19  DS X    status byte\nCV5_STATUS_BYTE_20  DS X    status byte\nCV5_STATUS_BYTE_21  DS X    status byte\nCV5_STATUS_BYTE_22  DS X    status byte\nCV5_STATUS_BYTE_23  DS X    status byte\nCV5_COBOL_SIGNAT    DS X    cobol signature level\nCV5_DATA_STATEMENTS DS XL4  number of data items\nCV5_PROC_LINES      DS XL4  number of proc statements\nCV5_STATUS_BYTE_24  DS X    status byte\nCV5_STATUS_BYTE_25  DS X    status byte\nCV5_STATUS_BYTE_26  DS X    status byte\nCV5_STATUS_BYTE_27  DS X    status byte\nCV5_BUILD_LEVEL     DS CL7  Build Level INFO                     RS0316\nCOBOLV5_COMP_INFO   DSECT\nCV5_COMP_YEAR       DS CL4  year of compilation\nCV5_COMP_MONTH      DS CL2  month of compilation\nCV5_COMP_DAY        DS CL2  day of compilation\nCV5_COMP_HOURS      DS CL2  hours of compilation\nCV5_COMP_MIN        DS CL2  minutes of compilation\nCV5_COMP_SEC        DS CL2  seconds of compilation\nCV5_VERS            DS CL2  version\nCV5_REL             DS CL2  release\nCV5_MOD             DS CL2  modification level\n*------------------------------------------------------------*\n* COBOL/370 DCL\n*------------------------------------------------------------*\nCOBOL_370_DSECT     DSECT\n                    DS CL4  bypass\nCEE_EYECATCHER      DS CL4  eyecatcher\nCEE_STACK_FRAME     DS F    stack frame size\nCEE_PPA1_OFFSET     DS F    offset to first ppa1\n                    DS CL4  reserved\nCEE_PPA1_START      DS 0C\nCEE_OFFSET          DS X    offset to length of name from ppa1\nCEE_SIGNATURE       DS X    CEL-Signature\nCEE_FLAG1           DS X    CEL-FLAGS Bitmask\nCEE_FLAG2           DS X    Member Flags for Cobol\nCEE_ADDRESS_OF_PPA2 DS F    Address of PPA2\nCEE_OFFSET_DBI      DS F    Offset BDI (None)\nCEE_EP_DESCRIPTOR   DS F    Entry Point Descriptor\nCEE_STACK_OVERFLOW  DS F    Offset for Stack overflow\n                    DS F    available word\n                    DS F    available word\n                    DS F    available word\n                    DS F    available word\nCEE_PRIMARY_EP      DS 0C\nCEE_PRI_EP_ADDRESS  DS A    primary entry-point address\nCEE_PGT_ADDRESS     DS A    PGT-Address\nCEE_TGT_ADDRESS     DS A    TGT-Address or DAB RENT/NORENT       RS1007\nCEE_EP_NAME         DS A    Offset to entry_point_name\nCEE_CURRENT_EP      DS A    current EP-Address\nCEE_START           DS A    procedure code Address\nCEE_INIT_PROG       DS A    Initialize Routine\nCEE_PARM_LIST       DS A    Address of parm list for CEEINT\nCEE_COMP_LEVEL      DS XL2  0010                                 RS1007\nCEE_TGT_REG         DS X    80 = R13 40 ? R9                     RS1007\n                    DS X                                         RS1007\n                    DS H    available half-word\nCEE_LENGTH_NAME     DS XL2  length of program_name\nCEE_NAME_PART       DS 0C\nCEE_PGM_NAME        DS CL8  name of program\nCEE_COMP_YEAR       DS CL4  year of compilation\nCEE_COMP_MONTH      DS CL2  month of compilation\nCEE_COMP_DAY        DS CL2  day of compilation\nCEE_COMP_HOURS      DS CL2  hours of compilation\nCEE_COMP_MIN        DS CL2  minutes of compilation\nCEE_COMP_SEC        DS CL2  seconds of compilation\nCEE_VERS            DS CL2  version\nCEE_REL             DS CL2  release\nCEE_MOD             DS CL2  modification level\nCEE_CCSID           DS XL2  Codepage (COBOL V3R1 only)\n                    DS H    available halfword\nCEE_STATUS_BYTE_28  DS X    status byte\nCEE_STATUS_BYTE_29  DS X    status byte\nCEE_YEAR_WINDOW     DS H    YearWindow\nCEE_STATUS_BYTE_01  DS X    status byte\nCEE_STATUS_BYTE_02  DS X    status byte\nCEE_STATUS_BYTE_03  DS X    status byte\nCEE_STATUS_BYTE_04  DS X    status byte\nCEE_STATUS_BYTE_05  DS X    status byte\nCEE_STATUS_BYTE_06  DS X    status byte\nCEE_STATUS_BYTE_07  DS X    status byte\nCEE_STATUS_BYTE_08  DS X    status byte\nCEE_STATUS_BYTE_09  DS X    status byte\nCEE_STATUS_BYTE_10  DS X    status byte\nCEE_STATUS_BYTE_11  DS X    status byte\nCEE_STATUS_BYTE_12  DS X    status byte\nCEE_STATUS_BYTE_13  DS X    status byte\nCEE_STATUS_BYTE_14  DS X    status byte\nCEE_STATUS_BYTE_15  DS X    status byte\nCEE_STATUS_BYTE_16  DS X    status byte\nCEE_STATUS_BYTE_17  DS X    status byte\nCEE_STATUS_BYTE_18  DS X    status byte\nCEE_STATUS_BYTE_19  DS X    status byte\nCEE_STATUS_BYTE_20  DS X    status byte\nCEE_STATUS_BYTE_21  DS X    status byte\nCEE_STATUS_BYTE_22  DS X    status byte\nCEE_STATUS_BYTE_23  DS X    status byte\nCEE_COBOL_SIGNAT    DS X    cobol signature level\nCEE_DATA_STATEMENTS DS XL4  number of data items\nCEE_PROC_LINES      DS XL4  number of proc statements\nCEE_STATUS_BYTE_24  DS X    status byte\nCEE_STATUS_BYTE_25  DS X    status byte\nCEE_STATUS_BYTE_26  DS X    status byte\nCEE_STATUS_BYTE_27  DS X    status byte\n*------------------------------------------------------------*\n* COBOL2 DCL\n*------------------------------------------------------------*\nCOBOL_2_DSECT      DSECT\n                   DS CL4  bypass\n                   DS X\nC2_PGM_NAME        DS CL8  name of program\nC2_EYECATCHER      DS CL4  eyecatcher\nC2_VERS            DS CL2  version\nC2_REL             DS CL2  release\nC2_MOD             DS CL2  modification level\nC2_COMP_MONTH      DS CL2  month of compilation\n                   DS CL1\nC2_COMP_DAY        DS CL2  day of compilation\n                   DS CL1\nC2_COMP_YEAR       DS CL2  year of compilation\n                   DS CL1\nC2_COMP_HOURS      DS CL2  hours of compilation\n                   DS CL1\nC2_COMP_MIN        DS CL2  minutes of compilation\n                   DS CL1\nC2_COMP_SEC        DS CL2  seconds of compilation\nC2_GET_ENTRY       DS A    Address of address\nC2_STATUS_BYTE_01  DS X    status byte\nC2_STATUS_BYTE_02  DS X    status byte\nC2_STATUS_BYTE_03  DS X    status byte\nC2_STATUS_BYTE_04  DS X    status byte\nC2_STATUS_BYTE_05  DS X    status byte\nC2_STATUS_BYTE_06  DS X    status byte\nC2_STATUS_BYTE_07  DS X    status byte\nC2_STATUS_BYTE_08  DS X    status byte\nC2_STATUS_BYTE_09  DS X    status byte\nC2_STATUS_BYTE_10  DS X    status byte\nC2_STATUS_BYTE_11  DS X    status byte\nC2_STATUS_BYTE_12  DS X    status byte\nC2_STATUS_BYTE_13  DS X    status byte\nC2_STATUS_BYTE_14  DS X    status byte\nC2_STATUS_BYTE_15  DS X    status byte\nC2_STATUS_BYTE_16  DS X    status byte\nC2_STATUS_BYTE_17  DS X    status byte\nC2_STATUS_BYTE_18  DS X    status byte\nC2_STATUS_BYTE_19  DS X    status byte\nC2_STATUS_BYTE_20  DS X    status byte\nC2_STATUS_BYTE_21  DS X    status byte\nC2_STATUS_BYTE_22  DS X    status byte\nC2_STATUS_BYTE_23  DS X    status byte\n                   DS X    cobol signature level\nC2_DATA_STATEMENTS DS XL4  number of data items\nC2_PROC_LINES      DS XL4  number of proc statements\nC2_STATUS_BYTE_24  DS X    status byte\nC2_STATUS_BYTE_25  DS X    status byte\n                   DS XL2  status byte\n                   DS CL4  status byte\nC2_PRI_EP_ADDRESS  DS A    primary entry-point address\n*\n*------------------------------------------------------------*\n* OS/VS COBOL\n*------------------------------------------------------------*\nCOBOL_1_DSECT      DSECT\n                   DS CL12 bypass\nC1_PGM_NAME        DS CL8  name of program\nC1_EYECATCHER      DS CL2  eyecatcher\nC1_REL             DS CL2  release\n                   DS CL36\nC1_TGT_PTR         DS F    pointer to tgt\n                   DS CL8  unknown                               RS0700\nC1_OEM_MOD_AREA    DS CL60 Optimizer Info orgin COBOL low-values RS0700\n                   DS CL4  unknown                               RS0700\nC1_COMP_HOURS      DS CL2  hours of compilation\n                   DS CL1\nC1_COMP_MIN        DS CL2  minutes of compilation\n                   DS CL1\nC1_COMP_SEC        DS CL2  seconds of compilation\nC1_COMP_MONTH      DS CL3  month of compilation\n                   DS CL1\nC1_COMP_DAY        DS CL2  day of compilation\n                   DS CL2\nC1_COMP_YEAR       DS CL4  year of compilation\nCOBOL_1_TGT        DSECT\n                   DS CL72 ?\nC1_STATUS_BYTE_01  DS X    status byte\nC1_STATUS_BYTE_02  DS X    status byte\nC1_STATUS_BYTE_03  DS X    status byte\n                   DS CL369\nC1_CHECK           DS CL8  check TGT for SYSOUT\n*------------------------------------------------------------*   PF0708\n* Compiled EZTRIEVE PLUS Main entry point (STINIT)               PF0708\n*------------------------------------------------------------*   PF0708\nEZTRIEVE_DSECT     DSECT ,                                       PF0708\n                   DS CL44 bypass                                PF0708\nEZ_EYECATCHER      DS CL8  eyecatcher EZTPA00                    PF0708\nEZ_TABLE_OFFSET    DS F    Offset to start of table of offsets   PF0708\nEZ_TBLEND_OFFSET   DS F    Offset to end of table (=CL4'OPTT')   PF0708\n                   DS CL4  bypass                                PF0708\nEZ_OFFSET_TABLE    DS 0CL8 Table of offsets                      PF0708\nEZ_TBL_WORD1       DS F    If =F'0' bypass                       PF0708\nEZ_TBL_WORD2       DS F    If =F'0' bypass                       PF0708\n*------------------------------------------------------------*   PF0708\n* Compiled EZTRIEVE PLUS JNLx entry point (JNLnnnnn)             PF0708\n*------------------------------------------------------------*   PF0708\nEZTRIEVE_JNL_DSECT DSECT ,                                       PF0708\nEZ_JNL_START_CODE  DS CL3  =X'47F0F0'                            PF0708\n                   DS CL1  =5+EZ_JNL_IDENT_LEN                   PF0708\nEZ_JNL_IDENT_LEN   DS XL1  eyecatcher total length               PF0708\nEZ_JNL_R4_R5       DS 0CL44 R4-R5 JNL area                       PF0708\nEZ_JNL_R4_R5_EYECT DS 0CL17 eyecatcher 'E Z T  ' etc.            PF0708\nEZ_JNL_R4_R5_CATCH DS CL7  eyecatcher 'E Z T  '                  PF0708\nEZ_JNL_R4_R5_VERSN DS CL10 eyecatcher 'PLUS ' and version        PF0708\n                   DS CL1  hyphen '-'                            PF0708\nEZ_JNL_R4_R5_TMSTP DS 0CL23 R4-R5 timestamp+JSN level            PF0708\nEZ_JNL_R4_R5_CDATE DS CL8  R4-R5 compile date                    PF0708\n                   DS CL1  hyphen '-'                            PF0708\nEZ_JNL_R4_R5_CTIME DS CL5  R4-R5 compile time                    PF0708\n                   DS CL1  hyphen '-'                            PF0708\nEZ_JNL_R4_R5_JSNID DS CL8  R4-R5 JSNnnnnn value                  PF0708\n                   ORG EZ_JNL_R4_R5                              PF0708\nEZ_JNL_R6          DS 0CL51 R6 JNL area                          PF0708\nEZ_JNL_R6_EYECT    DS 0CL27 eyecatcher 'CA-EASYTRIEVE ' etc.     PF0708\nEZ_JNL_R6_CATCH    DS CL14 eyecatcher 'CA-EASYTRIEVE '           PF0708\nEZ_JNL_R6_VERSN    DS CL13 eyecatcher 'PLUS ' and version        PF0708\n                   DS CL1  hyphen '-'                            PF0708\nEZ_JNL_R6_TMSTP    DS 0CL23 R6 timestamp+JSN level               PF0708\nEZ_JNL_R6_CDATE    DS CL8  R4-R5 compile date                    PF0708\n                   DS CL1  hyphen '-'                            PF0708\nEZ_JNL_R6_CTIME    DS CL5  R4-R5 compile time                    PF0708\n                   DS CL1  hyphen '-'                            PF0708\nEZ_JNL_R6_JSNID    DS CL8  R4-R5 JSNnnnnn value                  PF0708\n*------------------------------------------------------------*   RS1007\n* COBOL/370 DAB for RENT Cobol-Programs                          RS1007\n*------------------------------------------------------------*   RS1007\nCOBOL_DAB_DSECT     DSECT                                        RS1007\nCEE_DAB_ADR         DS F    ??                                   RS1007\n                    DS CL4                                       RS1007\nCEE_DAB_TGT         DS F    TGT - 6 Bytes |||                    RS1007\nCEE_DAB_EYEC        DS CL4  CL'IDBA'                             RS1007\n                    DS CL8                                       RS1007\nCEE_DAB_FIB_OFF     DS CL3  Offset to FIB from Entry-Point       RS1007\n*------------------------------------------------------------*   RS1007\n* COBOL/370 TGT                                                  RS1007\n*------------------------------------------------------------*   RS1007\nCOBOL_TGT_DSECT     DSECT                                        RS1007\n                    DS CL72 Reserved 72 Bytes                    RS1007\nCEE_TGT_IDENT       DS CL4  TGT identifier                       RS1007\n                    DS CL4  Reserved 4 Bytes                     RS1007\nCEE_TGT_LEVEL       DS X    TGT level indicator                  RS1007\n                    DS CL3  Reserved 3 Bytes                     RS1007\nCEE_TGT_32BIT_SWITCH DS F    32 bit switch                       RS1007\nCEE_TGT_PTR_RUNCOM  DS F    Pointer to RUNCOM                    RS1007\nCEE_TGT_PTR_COBVEC  DS F    Pointer to COBVEC                    RS1007\nCEE_TGT_PTR_PDBT    DS F    Pointer to Program Dynamic Block TableS1007\nCEE_TGT_NO_FCBS     DS F    Number of FCBs                       RS1007\nCEE_TGT_WS_LENGTH   DS F    Working-Storage Length               RS1007\n                    DS CL4  Reserved 4 Bytes                     RS1007\nCEE_TGT_IGZEMSG_W   DS F    Address of IGZESMG Work Ares         RS1007\nCEE_TGT_GETMAIN_B   DS F    Address of 1st Getmain Block (Space Mgr)007\n                    DS CL6  Reserved 6 Bytes                     RS1007\nCEE_TGT_MERG_FILE_NO DS H   Merge File Number                    RS1007\nCEE_TGT_CEL_CAA     DS F    Address of CEL Common Anchor Area    RS1007\nCEE_TGT_LENGTH      DS F    Length of TGT                        RS1007\n                    DS CL1  Reserved 1 Byte                      RS1007\nCEE_TGT_PGM_MASK    DS X    Program Mask used by this Program    RS1007\n                    DS CL2  Reserved 2 Bytes                     RS1007\nCEE_TGT_NO_SEC_FCBS  DS F    Number of secondary FCB Cells       RS1007\n                    DS CL128 ?? (see compile output)             RS1007\nCEE_TGT_PTR_FCB_CELL DS F   Pointer to first FCB Cell (NORENT)   RS1007\nCEE_TGT_WS_PTR      DS F    Working-Storage Address              RS1007\nCEE_TGT_PTR_FCB_SEC_CELL DS F  Pointer to first secondary FCB CellS1007\n*------------------------------------------------------------*   RS1007\n* COBOL/370 FIB                                                  RS1007\n*------------------------------------------------------------*   RS1007\nCOBOL_FIB_DSECT     DSECT                                        RS1007\nCOBOL_FIB_EYEC      DS CL3  Eyecatcher FIB                       RS1007\nCOBOL_FIB_NUM       DS CL2                                       RS1007\nCOBOL_FIB_LEVEL     DS XL1                                       RS1007\nCOBOL_FIB_DDN       DS CL8  DD-Name                              RS1007\n                    DS CL1                                       RS1007\nCOBOL_FIB_DSORG     DS CL1                                       RS1007\nCOBOL_FIB_ACCESS    DS CL1                                       RS1007\nCOBOL_FIB_RM        DS CL1                                       RS1007\nCOBOL_FIB_BYTE18    DS CL1                                       RS1007\nCOBOL_FIB_BYTE19    DS CL1                                       RS1007\n                    DS CL2                                       RS1007\nCOBOL_FIB_RECFM     DS CL1                                       RS1007\n                    DS CL1                                       RS1007\nCOBOL_FIB_BLK       DS F                                         RS1007\nCOBOL_FIB_LRECL     DS F                                         RS1007\n                    DS CL16                                      RS1007\nCOBOL_FIB_OPEN_CLOSE DS CL1                                      RS1007\nCOBOL_FIB_I_O_VERB1 DS CL1                                       RS1007\nCOBOL_FIB_I_O_VERB2 DS CL1                                       RS1007\n                    DS CL9                                       RS1007\nCOBOL_FIB_FS1       DS F                                         RS1007\nCOBOL_FIB_FS2       DS F                                         RS1007\n         DCBD    DSORG=QS\n         STRING64 GENERATE\nBIT0     EQU   B'10000000'\nBIT1     EQU   B'01000000'\nBIT2     EQU   B'00100000'\nBIT3     EQU   B'00010000'\nBIT4     EQU   B'00001000'\nBIT5     EQU   B'00000100'\nBIT6     EQU   B'00000010'\nBIT7     EQU   B'00000001'\n*------------------------------------------------------------*\n* Program equates                                            *\n*------------------------------------------------------------*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*                                                                 *CSC*\nCOBANAL  CSECT ,                                                 PF0608\nSTATIC_AREA DS 0D\nADDINFO  DC    C'------------ Additional information    ---------------X\n               -----------------------------------------------'\nFOOTER   DC    C'======================================================X\n               ==============================================='\nMASKTOT  DC    XL6'402020202120'       Mask for totals            *CSC*\nC_COBOL370 DC X'00',C'CEE'                   COBOL/370 ?  X'00C3C5C5'\nC_OPLINK   DC X'01',C'CEE'                   C370         X'01C3C5C5'\nC_COBV5   EQU C_OPLINK                 Enterprise CobV5?  X'01C3C5C5'\n*EW_IDL DC H'5',C'B_IDL'                                         RS1007\nIEW_IDL  DC H'6',C'B_IDRL'                                       RS1007\nIEW_ESD  DC H'5',C'B_ESD'                                        RS1007\nIEW_IDU  DC H'6',C'B_IDRU'                                       RS1007\nIEW_IDZ  DC H'6',C'B_IDRZ'                                       RS1007\nIEW_IDB  DC H'6',C'B_IDRB'                                       RS1007\nIEW_DDN  DC 0H                                                   PF0608\nIEW_DDNL DC H'7'                                                 PF0608\nIEW_DDNN DC CL8'COBANAL'                                         PF0608\nO_LIST   DC    H'4',C'LIST'               Option: List           RS1007\nV_ALL    DC    H'3',C'ALL'                Value: All             RS1007\nFILELIST DS    0F                         ddname                 RS1007\n         DC    F'1'                       Number                 RS1007\n         DC    CL8'PRINT',F'8',A(PRINTX)  Type, length of ddname, addr\nPRINTX   DC    CL8'BINDEROU'              The ddname             RS1007\nOPTION_Y DC    C'Y'                                              RS1007\nOPTION_N DC    C'N'                                              RS1007\n*                                                                RS1007\nOPTLIST3 DS    0F                         Global options specs   RS1007\n         DC    F'2'                       Number of list entries RS1007\n         DC    CL8'TERM    ',F'1',A(OPTION_N)                    RS1007\n         DC    CL8'PRINT   ',F'1',A(OPTION_Y)                    RS1007\n* EXecuted moves                                                 PF0708\nMOVE_PLINAME MVC 0(0,R14),IEW_MBRN        Move name to PLINAME   PF0708\nMOVE_$STATUS MVC 0(*-*,R3),1(R14)         Move status flags      PF0708\nMOVE_PGM_NAME MVC LE_PGM_NAME(0),58(R2)      Move PGM-Name       RS0116\nBLANKS   DC    CL255' '           just blanks\nC_LSTO   OPEN  (*-*,(OUTPUT)),MODE=31,MF=L\nC_LSTOL  EQU   *-C_LSTO\nC_LSTI   OPEN  (*-*,(INPUT)),MODE=31,MF=L\nC_LSTIL  EQU   *-C_LSTI\nC_CLOSE  CLOSE (*-*),MF=L\nC_CLOSEL EQU   *-C_CLOSE\nXFF      DC    XL8'FFFFFFFFFFFFFFFF' just High-value\n* Initializing DCB/DCBE's moved to separate CSECTS to make more  PF0608\n* space available in the STATIC_AREA                             PF0608\n* NAME The names of each section or class in the workmod, a      PF0608\n*      count of the total number of sections or classes, and the PF0608\n*      compile unit (CU) numbers for each section.               PF0608\n         IEWBUFF FUNC=MAPBUF,TYPE=NAME,SIZE=200,                  *CSC*X\n               HEADREG=8,ENTRYREG=9,VERSION=4                     *CSC*\n* IDL Language processor identification record, indicating the   PF0608\n*     compilers that created the binder input, the date of       PF0608\n*     compilation and the binder size.                           PF0608\n         IEWBUFF FUNC=MAPBUF,TYPE=IDRL,SIZE=50,                        X\n               HEADREG=8,ENTRYREG=9,VERSION=4                    RS1007\n* ESD External Symbol Dictionary, a catalog containing all       PF0608\n*     symbols that are available to the binder. These symbols    PF0608\n*     include section and class names, as well as ordinary       PF0608\n*     symbol definitions and references.                         PF0608\n         IEWBUFF FUNC=MAPBUF,TYPE=ESD,SIZE=50,                         X\n               HEADREG=8,ENTRYREG=9,VERSION=4                    RS1007\n* IDU User-specified identification record, containing data      PF0608\n*     provided on an IDENTIFY control statement.                 PF0608\n         IEWBUFF FUNC=MAPBUF,TYPE=IDRU,SIZE=50,                        X\n               HEADREG=8,ENTRYREG=9,VERSION=4                    RS1007\n* IDZ AMASPZAP identification record, for programs that have     PF0608\n*     been modified at the object level.                         PF0608\n         IEWBUFF FUNC=MAPBUF,TYPE=IDRZ,SIZE=50,                        X\n               HEADREG=8,ENTRYREG=9,VERSION=4                    RS1007\n* IDB Binder identification record, indicating the binder        PF0608\n*     version, size, and how and when the program object was     PF0608\n*     created.                                                   PF0608\n         IEWBUFF FUNC=MAPBUF,TYPE=IDRB,SIZE=50,                        X\n               HEADREG=8,ENTRYREG=9,VERSION=4                    RS1007\n         LTORG\nSTATIC_AREA_END DS 0D\n* -------------------------------------------------------------- PF0608\n* Separate CSECT for each initializing DCB/DCBE                  PF0608\n* -------------------------------------------------------------- PF0608\nFIXSYSPR CSECT ,                                                 PF0608\nFIXSYSPR AMODE 31\nFIXSYSPR RMODE ANY\n* Output information for selected programs                       PF0608\nSYSPRINT_FIX DCB   DSORG=PS,DDNAME=SYSPRINT,MACRF=PM,            PF0608X\n               RECFM=FB,LRECL=121,DCBE=SYSPRE                    PF0608\nSYSPRINT_FIX_LENGTH EQU *-SYSPRINT_FIX   Length workarea         PF0608\nSYSPRE   DCBE RMODE31=BUFF                                       PF0608\nFIXSUMMA CSECT ,                                                 PF0608\nFIXSUMMA AMODE 31\nFIXSUMMA RMODE ANY\n* Summary WORK file for CSC Summary report.                      PF0608\nSUMMARY_FIX DCB   DSORG=PS,DDNAME=SUMMARY,MACRF=PM,              PF0608X\n               RECFM=FB,LRECL=121,DCBE=SUMPRE                    PF0608\nSUMMARY_FIX_LENGTH EQU *-SUMMARY_FIX   Length workarea           PF0608\nSUMPRE   DCBE RMODE31=BUFF                                       PF0608\nFIXJUSTD CSECT ,                                                 =CMS=\nFIXJUSTD AMODE 31\nFIXJUSTD RMODE ANY\n* JUSTDATA file for CMS data                                     =CMS=\nJUSTDATA_FIX DCB   DSORG=PS,DDNAME=JUSTDATA,MACRF=PM,            =CMS= X\n               RECFM=FB,LRECL=#JUSTDATA_,DCBE=JUSTDPRE\nJUSTDATA_FIX_LENGTH EQU *-JUSTDATA_FIX   Length workarea         =CMS=\nJUSTDPRE DCBE RMODE31=BUFF                                       =CMS=\nFIXINPUT CSECT ,                                                 PF0608\nFIXINPUT AMODE 31\nFIXINPUT RMODE ANY\n* PDS Directory input file for PARM=ALL and COBANAL DD           PF0608\nINPUT_FIX DCB   DSORG=PS,DDNAME=COBANAL,MACRF=(GM),              PF0608X\n               RECFM=U,BLKSIZE=256,DCBE=INPUTE                   PF0608\nINPUT_FIX_LENGTH EQU *-INPUT_FIX     Length workarea             PF0608\nINPUTE   DCBE RMODE31=BUFF                                       PF0608\nFIXLOADL CSECT ,                                                 PF0608\nFIXLOADL AMODE 31\nFIXLOADL RMODE ANY\n* PDS input file for IEWBIND FUNC=INCLUDE and COBANAL DD         PF0608\nLOADL_FIX DCB   DSORG=PO,DDNAME=COBANAL,MACRF=(R),               PF0608X\n               RECFM=U,DCBE=LOADLE_FIX                           RS0516\nLOADLE_FIX   DCBE RMODE31=BUFF                                   RS0516\nLOADL_FIX_LENGTH EQU *-LOADL_FIX     Length workarea             PF0608\nFIXSYSIN CSECT ,                                                 PF0608\nFIXSYSIN AMODE 31\nFIXSYSIN RMODE ANY\n* Optional input file for list of programs to process            PF0608\nSYSIN_FIX DCB   DSORG=PS,DDNAME=SYSIN,MACRF=GM,                  RS0908X\n               RECFM=FB,LRECL=80,DCBE=SYSINE_FIX                 RS0908\nSYSINE_FIX  DCBE RMODE31=BUFF,EODAD=COBANAL_FIN                  RS0908\nSYSIN_FIX_LENGTH EQU *-SYSIN_FIX     Length workarea             PF0608\nCOBANAL  CSECT ,                                                 PF0608\n         IHAPSA                                                   *CSC*\n         IKJTCB                                                   *CSC*\n         IEFJFCBN                                                 *CSC*\nTIOT     DSECT                                                    *CSC*\n         IEFTIOT1                                                 *CSC*\n         USING INFMJFCB,R2                                        *CSC*\n         IEFZB505 LOCEPAX=YES          EPA MAPPING FOR SWAREQ     *CSC*\n         CVT   PREFIX=YES,DSECT=YES,LIST=NO    CVT                *CSC*\n         IEFJESCT                      JES VECTOR TABLE           *CSC*\n         IEFQMIDS                      SWA Block Identifiers      *CSC*\n*        IHAPDS                        PDS Directory             RS0316\nCEEOCB   DSECT      LE option cblock (OCO)\nCEEOCB_EYEC       DS CL8               Eyecatcher\nCEEOCB_VER        DS H                 Version\nCEEOCB_LEN        DS AL2               Length of OCB\nCEEOCB_EVP        DS A                 Expansion vector pointer\n                  DS A                 Reserved for future use\nOPTION_RES1       DS 0C                Reserved option\nOPTION_RES1_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_RES1_WHSET DS H                 Where set\n*                                      50 default\n*                                      100 DOPT\n*                                      200 UOPT\n*                                      500 ROPT\nOPTION_RES1_SUBOPT DS A                Offset to sub-options\nOPTION_AIXB       DS 0C                AIXBLD\nOPTION_AIXB_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_AIXB_WHSET DS H                 Where set\n*                                      50 default\n*                                      100 DOPT\n*                                      200 UOPT\n*                                      500 ROPT\nOPTION_AIXB_SUB   DS A                 Offset to sub-options\nOPTION_ALL3       DS 0C                ALL31\nOPTION_ALL3_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_ALL3_WHSET DS H                 Where set\nOPTION_ALL3_SUB   DS A                 Offset to sub-options\nOPTION_BELH       DS 0C                BELOWHEAP\nOPTION_BELH_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_BELH_WHSET DS H                 Where set\nOPTION_BELH_SUB   DS A                 Offset to sub-options\nOPTION_CHEC       DS 0C                CHECK\nOPTION_CHEC_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_CHEC_WHSET DS H                 Where set\nOPTION_CHEC_SUB   DS A                 Offset to sub-options\nOPTION_PLIT       DS 0C                PLITASKCOUNT\nOPTION_PLIT_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_PLIT_WHSET DS H                 Where set\nOPTION_PLIT_SUB   DS A                 Offset to sub-options\nOPTION_ABTE       DS 0C                ABTERMENC\nOPTION_ABTE_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_ABTE_WHSET DS H                 Where set\nOPTION_ABTE_SUB   DS A                 Offset to sub-options\nOPTION_COUN       DS 0C                COUNTRY\nOPTION_COUN_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_COUN_WHSET DS H                 Where set\nOPTION_COUN_SUB   DS A                 Offset to sub-options\nOPTION_DEBU       DS 0C                DEBUG\nOPTION_DEBU_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_DEBU_WHSET DS H                 Where set\nOPTION_DEBU_SUB   DS A                 Offset to sub-options\nOPTION_ERRC       DS 0C                ERRCOUNT\nOPTION_ERRC_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_ERRC_WHSET DS H                 Where set\nOPTION_ERRC_SUB   DS A                 Offset to sub-options\nOPTION_FILE       DS 0C                FILEHIST\nOPTION_FILE_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_FILE_WHSET DS H                 Where set\nOPTION_FILE_SUB   DS A                 Offset to sub-options\nOPTION_ENVA       DS 0C                ENVAR\nOPTION_ENVA_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_ENVA_WHSET DS H                 Where set\nOPTION_ENVA_SUB   DS A                 Offset to sub-options\nOPTION_FLOW       DS 0C                FLOW\nOPTION_FLOW_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_FLOW_WHSET DS H                 Where set\nOPTION_FLOW_SUB   DS A                 Offset to sub-options\nOPTION_HEAP       DS 0C                HEAP\nOPTION_HEAP_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_HEAP_WHSET DS H                 Where set\nOPTION_HEAP_SUB   DS A                 Offset to sub-options\nOPTION_INQP       DS 0C                INQPCOPN\nOPTION_INQP_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_INQP_WHSET DS H                 Where set\nOPTION_INQP_SUB   DS A                 Offset to sub-options\nOPTION_INTE       DS 0C                INTERRUPT\nOPTION_INTE_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_INTE_WHSET DS H                 Where set\nOPTION_INTE_SUB   DS A                 Offset to sub-options\nOPTION_LIBS       DS 0C                LIBSTACK\nOPTION_LIBS_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_LIBS_WHSET DS H                 Where set\nOPTION_LIBS_SUB   DS A                 Offset to sub-options\nOPTION_MSGQ       DS 0C                MSGQ\nOPTION_MSGQ_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_MSGQ_WHSET DS H                 Where set\nOPTION_MSGQ_SUB   DS A                 Offset to sub-options\nOPTION_MSGF       DS 0C                MSGFILE\nOPTION_MSGF_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_MSGF_WHSET DS H                 Where set\nOPTION_MSGF_SUB   DS A                 Offset to sub-options\nOPTION_NATL       DS 0C                NATLANG\nOPTION_NATL_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_NATL_WHSET DS H                 Where set\nOPTION_NATL_SUB   DS A                 Offset to sub-options\nOPTION_ERRU       DS 0C                ERRUNIT\nOPTION_ERRU_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_ERRU_WHSET DS H                 Where set\nOPTION_ERRU_SUB   DS A                 Offset to sub-options\nOPTION_OCST       DS 0C                OCSTATUS\nOPTION_OCST_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_OCST_WHSET DS H                 Where set\nOPTION_OCST_SUB   DS A                 Offset to sub-options\nOPTION_POSI       DS 0C                POSIX\nOPTION_POSI_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_POSI_WHSET DS H                 Where set\nOPTION_POSI_SUB   DS A                 Offset to sub-options\nOPTION_RPTS       DS 0C                RPTSTG\nOPTION_RPTS_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_RPTS_WHSET DS H                 Where set\nOPTION_RPTS_SUB   DS A                 Offset to sub-options\nOPTION_RTER       DS 0C                RTEREUS\nOPTION_RTER_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_RTER_WHSET DS H                 Where set\nOPTION_RTER_SUB   DS A                 Offset to sub-options\nOPTION_SIMV       DS 0C                SIMVRD\nOPTION_SIMV_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_SIMV_WHSET DS H                 Where set\nOPTION_SIMV_SUB   DS A                 Offset to sub-options\nOPTION_STAC       DS 0C                STACK\nOPTION_STAC_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_STAC_WHSET DS H                 Where set\nOPTION_STAC_SUB   DS A                 Offset to sub-options\nOPTION_STOR       DS 0C                STORAGE\nOPTION_STOR_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_STOR_WHSET DS H                 Where set\nOPTION_STOR_SUB   DS A                 Offset to sub-options\nOPTION_AUTO       DS 0C                AUTOTASK\nOPTION_AUTO_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_AUTO_WHSET DS H                 Where set\nOPTION_AUTO_SUB   DS A                 Offset to sub-options\nOPTION_TRAC       DS 0C                TRACE\nOPTION_TRAC_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_TRAC_WHSET DS H                 Where set\nOPTION_TRAC_SUB   DS A                 Offset to sub-options\nOPTION_THRH       DS 0C                THREADHEAP\nOPTION_THRH_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_THRH_WHSET DS H                 Where set\nOPTION_THRH_SUB   DS A                 Offset to sub-options\nOPTION_TEST       DS 0C                TEST\nOPTION_TEST_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_TEST_WHSET DS H                 Where set\nOPTION_TEST_SUB   DS A                 Offset to sub-options\nOPTION_THRS       DS 0C                THREADSTACK\nOPTION_THRS_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_THRS_WHSET DS H                 Where set\nOPTION_THRS_SUB   DS A                 Offset to sub-options\nOPTION_TRAP       DS 0C                TRAP\nOPTION_TRAP_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_TRAP_WHSET DS H                 Where set\nOPTION_TRAP_SUB   DS A                 Offset to sub-options\nOPTION_UPSI       DS 0C                UPSI\nOPTION_UPSI_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_UPSI_WHSET DS H                 Where set\nOPTION_UPSI_SUB   DS A                 Offset to sub-options\nOPTION_VCTR       DS 0C                VCTRSAVE\nOPTION_VCTR_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_VCTR_WHSET DS H                 Where set\nOPTION_VCTR_SUB   DS A                 Offset to sub-options\nOPTION_PRTU       DS 0C                PRTUNIT\nOPTION_PRTU_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_PRTU_WHSET DS H                 Where set\nOPTION_PRTU_SUB   DS A                 Offset to sub-options\nOPTION_XUFL       DS 0C                XUFLOW\nOPTION_XUFL_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_XUFL_WHSET DS H                 Where set\nOPTION_XUFL_SUB   DS A                 Offset to sub-options\nOPTION_CBLO       DS 0C                CBLOPTS\nOPTION_CBLO_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_CBLO_WHSET DS H                 Where set\nOPTION_CBLO_SUB   DS A                 Offset to sub-options\nOPTION_NONI       DS 0C                NONIPTSTACK\nOPTION_NONI_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_NONI_WHSET DS H                 Where set\nOPTION_NONI_SUB   DS A                 Offset to sub-options\nOPTION_RPTO       DS 0C                RPTOPTS\nOPTION_RPTO_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_RPTO_WHSET DS H                 Where set\nOPTION_RPTO_SUB   DS A                 Offset to sub-options\nOPTION_ANYH       DS 0C                ANYHEAP\nOPTION_ANYH_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_ANYH_WHSET DS H                 Where set\nOPTION_ANYH_SUB   DS A                 Offset to sub-options\nOPTION_ABPE       DS 0C                ABPERC\nOPTION_ABPE_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_ABPE_WHSET DS H                 Where set\nOPTION_ABPE_SUB   DS A                 Offset to sub-options\nOPTION_TERM       DS 0C                TERMTHDACT\nOPTION_TERM_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_TERM_WHSET DS H                 Where set\nOPTION_TERM_SUB   DS A                 Offset to sub-options\nOPTION_DEPT       DS 0C                DEPTHCONDLMT\nOPTION_DEPT_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_DEPT_WHSET DS H                 Where set\nOPTION_DEPT_SUB   DS A                 Offset to sub-options\nOPTION_CBLP       DS 0C                CBLPSHPOP\nOPTION_CBLP_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_CBLP_WHSET DS H                 Where set\nOPTION_CBLP_SUB   DS A                 Offset to sub-options\nOPTION_CBLQ       DS 0C                CBLQDA\nOPTION_CBLQ_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_CBLQ_WHSET DS H                 Where set\nOPTION_CBLQ_SUB   DS A                 Offset to sub-options\nOPTION_PUNU       DS 0C                PUNUNIT\nOPTION_PUNU_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_PUNU_WHSET DS H                 Where set\nOPTION_PUNU_SUB   DS A                 Offset to sub-options\nOPTION_RDRU       DS 0C                RDRUNIT\nOPTION_RDRU_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_RDRU_WHSET DS H                 Where set\nOPTION_RDRU_SUB   DS A                 Offset to sub-options\nOPTION_RECP       DS 0C                RECPAD\nOPTION_RECP_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_RECP_WHSET DS H                 Where set\nOPTION_RECP_SUB   DS A                 Offset to sub-options\nOPTION_USRH       DS 0C                USRHDLR\nOPTION_USRH_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_USRH_WHSET DS H                 Where set\nOPTION_USRH_SUB   DS A                 Offset to sub-options\nOPTION_RES2       DS 0C                Reserved option\nOPTION_RES2_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_RES2_WHSET DS H                 Where set\nOPTION_RES2_SUB   DS A                 Offset to sub-options\nOPTION_PC         DS 0C                PC\nOPTION_PC_FLAG    DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_PC_WHSET   DS H                 Where set\nOPTION_PC_SUB     DS A                 Offset to sub-options\nOPTION_LIBR       DS 0C                LIBRARY\nOPTION_LIBR_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_LIBR_WHSET DS H                 Where set\nOPTION_LIBR_SUB   DS A                 Offset to sub-options\nOPTION_VERS       DS 0C                VERSION\nOPTION_VERS_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_VERS_WHSET DS H                 Where set\nOPTION_VERS_SUB   DS A                 Offset to sub-options\nOPTION_RTLS       DS 0C                RTLS\nOPTION_RTLS_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_RTLS_WHSET DS H                 Where set\nOPTION_RTLS_SUB   DS A                 Offset to sub-options\nOPTION_HCHK       DS 0C                HEAPCHK\nOPTION_HCHK_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_HCHK_WHSET DS H                 Where set\nOPTION_HCHK_SUB   DS A                 Offset to sub-options\nOPTION_PROF       DS 0C                PROFILE\nOPTION_PROF_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_PROF_WHSET DS H                 Where set\nOPTION_PROF_SUB   DS A                 Offset to sub-options\nOPTION_HEPP       DS 0C                HEAPPOOLS\nOPTION_HEPP_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_HEPP_WHSET DS H                 Where set\nOPTION_HEPP_SUB   DS A                 Offset to sub-options\nOPTION_INFO       DS 0C                INFOMSGFILTER\nOPTION_INFO_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_INFO_WHSET DS H                 Where set\nOPTION_INFO_SUB   DS A                 Offset to sub-options\nOPTION_XPLI       DS 0C                XPLINK\nOPTION_XPLI_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_XPLI_WHSET DS H                 Where set\nOPTION_XPLI_SUB   DS A                 Offset to sub-options\nOPTION_FILT       DS 0C                FILETAG\nOPTION_FILT_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_FILT_WHSET DS H                 Where set\nOPTION_FILT_SUB   DS A                 Offset to sub-options\nOPTION_HE64       DS 0C                HEAP64\nOPTION_HE64_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_HE64_WHSET DS H                 Where set\nOPTION_HE64_SUB   DS A                 Offset to sub-options\nOPTION_HEPP64     DS 0C                HEAPPOOLS64\nOPTION_HEPP64_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_HEPP64_WHSET DS H                 Where set\nOPTION_HEPP64_SUB   DS A                 Offset to sub-options\nOPTION_IOHE64     DS 0C                IOHEAP64\nOPTION_IOHE64_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_IOHE64_WHSET DS H                 Where set\nOPTION_IOHE64_SUB   DS A                 Offset to sub-options\nOPTION_LIHE64     DS 0C                LIBHEAP64\nOPTION_LIHE64_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_LIHE64_WHSET DS H                 Where set\nOPTION_LIHE64_SUB   DS A                 Offset to sub-options\nOPTION_STAC64     DS 0C                STACK64\nOPTION_STAC64_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_STAC64_WHSET DS H                 Where set\nOPTION_STAC64_SUB   DS A                 Offset to sub-options\nOPTION_THRS64     DS 0C                THREADSTACK64\nOPTION_THRS64_FLAG  DS AL1               Flag for option\n                  DS X                 Unused\nOPTION_THRS64_WHSET DS H                 Where set\nOPTION_THRS64_SUB   DS A                 Offset to sub-options\nOPTION_DYNDMP     DS 0C                DYNDUMP                   RS0806\nOPTION_DYNDMP_FLAG  DS AL1               Flag for option         RS0806\n                  DS X                 Unused                    RS0806\nOPTION_DYNDMP_WHSET DS H                 Where set               RS0806\nOPTION_DYNDMP_SUB   DS A                 Offset to sub-options   RS0806\nOPTION_CEEDMP     DS 0C                CEEDUMP                   RS1007\nOPTION_CEEDMP_FLAG  DS AL1               Flag for option         RS1007\n                  DS X                 Unused                    RS1007\nOPTION_CEEDMP_WHSET DS H                 Where set               RS1007\nOPTION_CEEDMP_SUB   DS A                 Offset to sub-options   RS1007\nSUBOPT_BELH       DSECT                Suboptions BELOWHEAP\nSUBOPT_BELH_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_BELH_INIT  DS F                 BELOWHEAP initial size\nSUBOPT_BELH_INC   DS F                 BELOWHEAP increment size\nSUBOPT_BELH_ALLOC DS AL1               128 = BELOW, 64 = FREE\nSUBOPT_PLIT       DSECT                Suboptions PLITASKCOUNT\nSUBOPT_PLIT_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_PLIT_COUNT DS F                 PLITASKCOUNT # condition limit\nSUBOPT_ABTE       DSECT                Suboptions ABTERMENC\nSUBOPT_ABTE_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_ABTE_OPT   DS F                 2=ABEND, 1=RETCODE\nSUBOPT_COUN       DSECT                Suboptions COUNTRY\nSUBOPT_COUN_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_COUN_ID    DS CL2               COUNTRY identifier\n                  DS AL2               Unused\nSUBOPT_ERRC       DSECT                Suboptions ERRCOUNT\nSUBOPT_ERRC_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_ERRC_COUNT DS F                 ERRCOUNT # non-fatal errors\nSUBOPT_ENVA       DSECT                Suboptions ENVAR\nSUBOPT_ENVA_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_ENVA_OFFS  DS F                 Offset to envar string\nSUBOPT_ENVA_LEN   DS H                 length of envar\nSUBOPT_ENVA_STR   DS CL250             envar string\nSUBOPT_FLOW       DSECT                Suboptions FLOW\nSUBOPT_FLOW_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_FLOW_COUNT DS F                 FLOWC max # procedures\nSUBOPT_HEAP       DSECT                Suboptions HEAP\nSUBOPT_HEAP_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_HEAP_INIT  DS F                 HEAP initial size\nSUBOPT_HEAP_INC   DS F                 HEAP increment size\nSUBOPT_HEAP_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                  DS AL3               Unused\nSUBOPT_HEAP24_INIT DS F                HEAP24 initial size\nSUBOPT_HEAP24_INC DS F                 HEAP24 increment size\nSUBOPT_LIBS       DSECT                Suboptions LIBSTACK\nSUBOPT_LIBS_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_LIBS_INIT  DS F                 LIBSTACK initial size\nSUBOPT_LIBS_INC   DS F                 LIBSTACK increment size\nSUBOPT_LIBS_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                  DS AL3               Unused\nSUBOPT_MSGQ       DS 0C                Suboptions MSGQ\nSUBOPT_MSGQ_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_MSGQ_COUNT DS F                 MSGQ maximum # MIB entries\nSUBOPT_MSGF       DSECT                Suboptions MSGFILE\nSUBOPT_MSGF_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_MSGF_DDO   DS A                 Offset to DDNAME\nSUBOPT_MSGF_RFMO  DS A                 Offset to RECFM\nSUBOPT_MSGF_RECL  DS F                 RECL\nSUBOPT_MSGF_BLKS  DS F                 Block size\nSUBOPT_MSGF_DDL   DS H                 Effective length of following\nSUBOPT_MSGF_DD    DS CL8               MSGFILE DDname\nSUBOPT_MSGF_ENQ   DS CL2               Space = NOENQ ' *' = ENQ\nSUBOPT_MSGF_RFML  DS H                 Effective length of following\nSUBOPT_MSGF_RFM   DS CL5               Record format\n                  DS CL1               Unused\nSUBOPT_NATL       DSECT                Suboptions NATLANG\nSUBOPT_NATL_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_NATL_ID    DS CL3               COUNTRY identifier\n                  DS AL1               Unused\nSUBOPT_ERRU       DSECT                Suboptions ERRUNIT\nSUBOPT_ERRU_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_ERRU_COUNT DS F                 ERRUNIT # non-fatal errors\nSUBOPT_STAC       DSECT                Suboptions STACK\nSUBOPT_STAC_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_STAC_INIT  DS F                 STACK initial size\nSUBOPT_STAC_INC   DS F                 STACK increment size\nSUBOPT_STAC_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                  DS AL3               Unused\nSUBOPT_STAC_DINIT DS F                 DownSTACK initial size\nSUBOPT_STAC_DINC  DS F                 DownSTACK increment size\nSUBOPT_STOR       DSECT                Suboptions STACK\nSUBOPT_STOR_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_STOR_CSF   DS AL1               Characters-specified flags\nSUBOPT_STOR_AHSC  DS X                 Allocated heap storage character\nSUBOPT_STOR_FHSC  DS X                 Freed heap storage character\nSUBOPT_STOR_ADSC  DS X                 Allocated DSA storage character\nSUBOPT_STOR_SOSSZ DS F                 Short on storage reserve size\nSUBOPT_AUTO       DSECT                Suboptions AUTOTASK\nSUBOPT_AUTO_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_AUTO_LMO   DS A                 Offset to loadmod\nSUBOPT_AUTO_NO    DS F                 Number of subtasks\nSUBOPT_AUTO_LEN   DS H                 Length of Loadmod\nSUBOPT_AUTO_LMOD  DS CL8               Loadmod\n                  DS AL2               Unused\nSUBOPT_TRAC       DSECT                Suboptions TRACE\nSUBOPT_TRAC_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_TRAC_SIZE  DS F                 Trace buffer size\nSUBOPT_TRAC_GFLG  DS XL4               Global trace level bits\nSUBOPT_TRAC_FLG1  DS X                 Trace flags ('80xxxxxx' = DUMP)\nSUBOPT_TRAC_FLG2  DS X                 Trace flags ('xx00xxxx'       )\nSUBOPT_TRAC_FLG3  DS X                 Trace flags ('xxxx00xx'       )\nSUBOPT_TRAC_FLG4  DS X                 Trace flags ('xxxxxx00'       )\nSUBOPT_TRAC_TRVO  DS A                 Offset of Trace level verify\nSUBOPT_TRAC_TRSO  DS A                 Offset of Trace level set\nSUBOPT_TRAC_TRAO  DS A                 Offset of Trace level array\nSUBOPT_TRAC_TRVA  DS AL1               Verify flags for the following\n                  DS AL1                array of trace level\n                  DS AL1\n                  DS AL1\nSUBOPT_TRAC_TRSA  DS XL4               Trace level set flags array\nSUBOPT_TRAC_TRAA  DS XL4               Unused trace level bits\n                  DS XL4               CEL trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               C/370 trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               DCE trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               Sockets trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               Unused trace level bits\n                  DS XL4               Unused trace level bits\nSUBOPT_THRH       DSECT                Suboptions THREADHEAP\nSUBOPT_THRH_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_THRH_INIT  DS F                 THREADHEAP initial size\nSUBOPT_THRH_INC   DS F                 THREADHEAP increment size\nSUBOPT_THRH_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                  DS AL3               Unused\nSUBOPT_TEST       DSECT                Suboptions TEST\nSUBOPT_TEST_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_TEST_OPT   DS F                 1 = NONE, 2 = ERROR, 4 = ALL\nSUBOPT_TEST_CFO   DS A                 Offset of commands_file\nSUBOPT_TEST_CLO   DS A                 Offset of command_list|prompt\nSUBOPT_TEST_PFO   DS A                 Offset of preference_file\nSUBOPT_TEST_CFL   DS H                 Effective length of following\nSUBOPT_TEST_CF    DS CL80              Commands_file name\n                  DS CL2               unused\nSUBOPT_TEST_CLL   DS H                 Effective length of following\nSUBOPT_TEST_CL    DS CL250             Command_list name|prompt option\nSUBOPT_TEST_PFL   DS H                 Effective length of following\nSUBOPT_TEST_PF    DS CL80              Preference_file name\n                  DS CL2               Unused\nSUBOPT_THRS       DSECT                Suboptions THREADSTACK\nSUBOPT_THRS_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_THRS_INIT  DS F                 ThreadStack initial size\nSUBOPT_THRS_INC   DS F                 ThreadStack increment size\nSUBOPT_THRS_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                  DS AL3               Unused\nSUBOPT_THRS_DINIT DS F                 Down STACK initial size\nSUBOPT_THRS_DINC  DS F                 Down  STACK increment size\nSUBOPT_TRAP       DSECT                Suboptions TRAP\nSUBOPT_TRAP_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_TRAP_FLG   DS AL1               Trap  flags ('80xxxxxx' = SPIE)\n                  DS AL3               Unused\nSUBOPT_UPSI       DSECT                Suboptions UPSI\nSUBOPT_UPSI_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_UPSI_SW    DS CL8               8 UPSI switches\nSUBOPT_PRTU       DSECT                Suboptions PRTUNIT\nSUBOPT_PRTU_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_PRTU_COUNT DS F                 PRTUNIT # non-fatal errors\nSUBOPT_XUFL       DSECT                Suboptions XUFLOW\nSUBOPT_XUFL_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_XUFL_COUNT DS F                 4 = OFF, 2 = ON, 1 = AUTOs\nSUBOPT_NONI       DSECT                Suboptions NONIPTSTACK\nSUBOPT_NONI_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_NONI_INIT  DS F                 NONIPTSTACK initial size\nSUBOPT_NONI_INC   DS F                 NONIPTSTACK increment size\nSUBOPT_NONI_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                  DS AL3               Unused\nSUBOPT_ANYH       DSECT                Suboptions ANYHEAP\nSUBOPT_ANYH_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_ANYH_INIT  DS F                 ANYHEAP initial size\nSUBOPT_ANYH_INC   DS F                 ANYHEAP increment size\nSUBOPT_ANYH_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                  DS AL3               Unused\nSUBOPT_ABPE       DSECT                Suboptions ABPERC\nSUBOPT_ABPE_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_ABPE_US    DS AL1               128=NONE, 64=U, 32=S, 16=other\n                  DS AL3               Unused\nSUBOPT_ABPE_CODE  DS F                 Numeric portion of U or S abcode\nSUBOPT_ABPE_ABC   DS CL8               Abcode (blank-padded)\nSUBOPT_TERM       DSECT                Suboptions TERMTHDACT\nSUBOPT_TERM_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_TERM_FLG   DS F                 8=QUIET, 4=MSG, 2=TRACE, 1=DUMP\nSUBOPT_TERM_CESE  DS AL1               128=CESE,64=CICSDDS\n                  DS AL3               Unused\nSUBOPT_TERM_STOR  DS H                 reg_stor_amount suboption\n                  DS AL2               Unused\nSUBOPT_DEPT       DSECT                Suboptions DEPTHCONDLMT\nSUBOPT_DEPT_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_DEPT_COUNT DS F                 DEPTHCONDLMT # condition limit\nSUBOPT_PUNU       DSECT                Suboptions PUNUNIT\nSUBOPT_PUNU_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_PUNU_COUNT DS F                 PUNUNIT # non-fatal errors\nSUBOPT_RDRU       DSECT                Suboptions RDRUNIT\nSUBOPT_RDRU_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_RDRU_COUNT DS F                 RDRUNIT # non-fatal errors\nSUBOPT_RECP       DSECT                Suboptions RECPAD\nSUBOPT_RECP_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_RECP_FLG   DS F                 4 = OFF, 2 = ON, 1 = VAR\nSUBOPT_USRH       DSECT                Suboptions USRHDLR\nSUBOPT_USRH_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_USRH_UN1O  DS A                 Offset of UHname\nSUBOPT_USRH_UN2O  DS A                 Offset of UHname2\nSUBOPT_USRH_UN1L  DS H                 Effective length of following\nSUBOPT_USRH_UN1   DS CL8               USRHDLR UHname\n                  DS CL2\nSUBOPT_USRH_UN2L  DS H                 Effective length of following\nSUBOPT_USRH_UN2   DS CL8               USRHDLR UHname2\n                  DS CL2\nSUBOPT_RES2       DSECT                Suboptions\nSUBOPT_RES2_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_RES2_LVL   DS F                 Level information\nSUBOPT_LIBR       DSECT                Suboptions LIBRARY\nSUBOPT_LIBR_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_LIBR_LMO   DS A                 Offset of load module name\nSUBOPT_LIBR_LML   DS H                 Effective length of following\nSUBOPT_LIBR_LM    DS CL8               Name of load module\n                  DS CL2\nSUBOPT_VERS       DSECT                Suboptions VERSION\nSUBOPT_VERS_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_VERS_LMO   DS A                 Offset of load module name\nSUBOPT_VERS_LML   DS H                 Effective length of following\nSUBOPT_VERS_LM    DS CL8               Name of load module\n                  DS CL2\nSUBOPT_HCHK       DSECT                Suboptions HEAPCHK\nSUBOPT_HCHK_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_HCHK_FREQ  DS F                 HeapChk frequency\nSUBOPT_HCHK_INIT  DS F                 HeapChk initial delay\nSUBOPT_HCHK_CLVL  DS F                 HeapChk call level\nSUBOPT_HCHK_PLVL  DS F                 HeapChk pool call level\nSUBOPT_PROF       DSECT                Suboptions PROFILE\nSUBOPT_PROF_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_PROF_STRO  DS A                 Offset of Profiler string\nSUBOPT_PROF_STRL  DS H                 Effective length of following\nSUBOPT_PROF_STR   DS CL250             PROFILE String\nSUBOPT_HEPP       DSECT                Suboptions HEAPPOOLS\nSUBOPT_HEPP_FLG1  DS AL1               Suboption valid bits\nSUBOPT_HEPP_FLG2  DS AL1               Suboption valid bits\n                  DS AL2               Unused suboption valid bits\nSUBOPT_HEPP_CP1S  DS F                 cell pool 1 size\nSUBOPT_HEPP_CP1P  DS F                 cell pool 1 percentage\nSUBOPT_HEPP_CP2S  DS F                 cell pool 2 size\nSUBOPT_HEPP_CP2P  DS F                 cell pool 2 percentage\nSUBOPT_HEPP_CP3S  DS F                 cell pool 3 size\nSUBOPT_HEPP_CP3P  DS F                 cell pool 3 percentage\nSUBOPT_HEPP_CP4S  DS F                 cell pool 4 size\nSUBOPT_HEPP_CP4P  DS F                 cell pool 4 percentage\nSUBOPT_HEPP_CP5S  DS F                 cell pool 5 size\nSUBOPT_HEPP_CP5P  DS F                 cell pool 5 percentage\nSUBOPT_HEPP_CP6S  DS F                 cell pool 6 size\nSUBOPT_HEPP_CP6P  DS F                 cell pool 6 percentage\nSUBOPT_HEPP_CP7S  DS F                 cell pool 7 size\nSUBOPT_HEPP_CP7P  DS F                 cell pool 7 percentage\nSUBOPT_HEPP_CP8S  DS F                 cell pool 8 size\nSUBOPT_HEPP_CP8P  DS F                 cell pool 8 percentage\nSUBOPT_HEPP_CP9S  DS F                 cell pool 9 size\nSUBOPT_HEPP_CP9P  DS F                 cell pool 9 percentage\nSUBOPT_HEPP_CP10S DS F                 cell pool 10 size\nSUBOPT_HEPP_CP10P DS F                 cell pool 10 percentage\nSUBOPT_HEPP_CP11S DS F                 cell pool 11 size\nSUBOPT_HEPP_CP11P DS F                 cell pool 11 percentage\nSUBOPT_HEPP_CP12S DS F                 cell pool 12 size\nSUBOPT_HEPP_CP12P DS F                 cell pool 12 percentage\nSUBOPT_INFO       DSECT                Suboptions INFOMSGFILTER\nSUBOPT_INFO_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_INFO_ID1   DS CL1               Single char environment ids\nSUBOPT_INFO_ID2   DS CL1\nSUBOPT_INFO_ID3   DS CL1\nSUBOPT_INFO_ID4   DS CL1\nSUBOPT_FILT       DSECT                Suboptions FILETAG\nSUBOPT_FILT_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_FILT_FLG   DS AL1               FILETAG Flags\n                  DS CL3               Unused\nSUBOPT_HE64       DSECT                Suboptions HEAP\nSUBOPT_HE64_FLAG  DS AL1               Suboption valid bits\n                  DS AL3               Unused suboption valid bits\nSUBOPT_HE64_INIT  DS FDL8              HEAP initial size\nSUBOPT_HE64_INC   DS FDL8              HEAP increment size\nSUBOPT_HE64_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                  DS AL3               Unused\nSUBOPT_HE6431_INIT DS F                HEAP24 initial size\nSUBOPT_HE6431_INC  DS F                 HEAP24 increment size\nSUBOPT_HE6431_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                   DS AL3               Unused\nSUBOPT_HE6424_INIT DS F                HEAP24 initial size\nSUBOPT_HE6424_INC  DS F                 HEAP24 increment size\nSUBOPT_HE6424_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                   DS AL3               Unused\nSUBOPT_HEPP64     DSECT                Suboptions HEAPPOOLS\nSUBOPT_HEPP64_FLG1  DS AL1               Suboption valid bits\nSUBOPT_HEPP64_FLG2  DS AL1               Suboption valid bits\n                  DS AL2               Unused suboption valid bits\nSUBOPT_HEPP64_CP1S  DS F                 cell pool 1 size\nSUBOPT_HEPP64_CP1P  DS F                 cell pool 1 percentage\nSUBOPT_HEPP64_CP2S  DS F                 cell pool 2 size\nSUBOPT_HEPP64_CP2P  DS F                 cell pool 2 percentage\nSUBOPT_HEPP64_CP3S  DS F                 cell pool 3 size\nSUBOPT_HEPP64_CP3P  DS F                 cell pool 3 percentage\nSUBOPT_HEPP64_CP4S  DS F                 cell pool 4 size\nSUBOPT_HEPP64_CP4P  DS F                 cell pool 4 percentage\nSUBOPT_HEPP64_CP5S  DS F                 cell pool 5 size\nSUBOPT_HEPP64_CP5P  DS F                 cell pool 5 percentage\nSUBOPT_HEPP64_CP6S  DS F                 cell pool 6 size\nSUBOPT_HEPP64_CP6P  DS F                 cell pool 6 percentage\nSUBOPT_HEPP64_CP7S  DS F                 cell pool 7 size\nSUBOPT_HEPP64_CP7P  DS F                 cell pool 7 percentage\nSUBOPT_HEPP64_CP8S  DS F                 cell pool 8 size\nSUBOPT_HEPP64_CP8P  DS F                 cell pool 8 percentage\nSUBOPT_HEPP64_CP9S  DS F                 cell pool 9 size\nSUBOPT_HEPP64_CP9P  DS F                 cell pool 9 percentage\nSUBOPT_HEPP64_CP10S DS F                 cell pool 10 size\nSUBOPT_HEPP64_CP10P DS F                 cell pool 10 percentage\nSUBOPT_HEPP64_CP11S DS F                 cell pool 11 size\nSUBOPT_HEPP64_CP11P DS F                 cell pool 11 percentage\nSUBOPT_HEPP64_CP12S DS F                 cell pool 12 size\nSUBOPT_HEPP64_CP12P DS F                 cell pool 12 percentage\nSUBOPT_IOHE64       DSECT                Suboptions IOHEAP64\nSUBOPT_IOHE64_FLAG  DS AL1               Suboption valid bits\nSUBOPT_IOHE64_OPT   DS AL1               Suboption valid bits (part 2)\n                    DS AL2               Unused suboption valid bits\nSUBOPT_IOHE64_INIT  DS FDL8              IOHEAP64 initial size 64\nSUBOPT_IOHE64_INC   DS FDL8              IOHEAP64 increment size 64\nSUBOPT_IOHE64_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                    DS AL3               Unused\nSUBOPT_IOHE6431_INIT DS F                IOHEAP64 initial size 31\nSUBOPT_IOHE6431_INC  DS F                IOHEAP64 increment size 31\nSUBOPT_IOHE6431_ALLOC DS AL1             128 = BELOW, 64 = FREE\n                    DS AL3               Unused\nSUBOPT_IOHE6424_INIT DS F                IOHEAP64 initial size 24\nSUBOPT_IOHE6424_INC  DS F                IOHEAP64 increment size 24\nSUBOPT_IOHE6424_ALLOC DS AL1             128 = BELOW, 64 = FREE\nSUBOPT_LIHE64       DSECT                Suboptions LIBHEAP64\nSUBOPT_LIHE64_FLAG  DS AL1               Suboption valid bits\nSUBOPT_LIHE64_OPT   DS AL1               Suboption valid bits (part 2)\n                    DS AL2               Unused suboption valid bits\nSUBOPT_LIHE64_INIT  DS FDL8              LIBHEAP64 initial size 64\nSUBOPT_LIHE64_INC   DS FDL8              LIBHEAP64 increment size 64\nSUBOPT_LIHE64_ALLOC DS AL1               128 = BELOW, 64 = FREE\n                    DS AL3               Unused\nSUBOPT_LIHE6431_INIT DS F                LIBHEAP64 initial size 31\nSUBOPT_LIHE6431_INC  DS F                LIBHEAP64 increment size 31\nSUBOPT_LIHE6431_ALLOC DS AL1             128 = BELOW, 64 = FREE\n                    DS AL3               Unused\nSUBOPT_LIHE6424_INIT DS F                LIBHEAP64 initial size 24\nSUBOPT_LIHE6424_INC  DS F                LIBHEAP64 increment size 24\nSUBOPT_LIHE6424_ALLOC DS AL1             128 = BELOW, 64 = FREE\n                    DS AL3               Unused\nSUBOPT_STAC64       DSECT                Suboptions STACK64\nSUBOPT_STAC64_FLAG  DS AL1               Suboption valid bits\n                    DS AL3               Unused suboption valid bits\nSUBOPT_STAC64_INIT  DS FDL8              STACK64 initial size\nSUBOPT_STAC64_INC   DS FDL8              STACK64 increment size\nSUBOPT_STAC64_MAX   DS FDL8              STACK64 maximum\nSUBOPT_THRS64       DSECT                Suboptions THREADSTACK64\nSUBOPT_THRS64_FLAG  DS AL1               Suboption valid bits\n                    DS AL3               Unused suboption valid bits\nSUBOPT_THRS64_INIT  DS FDL8              THREADSTACK64 initial size\nSUBOPT_THRS64_INC   DS FDL8              THREADSTACK64 increment size\nSUBOPT_THRS64_MAX   DS FDL8              THREADSTACK64 maximum\nSUBOPT_DYNDMP       DSECT                Suboptions DYNDUMP      RS0806\nSUBOPT_DYNDMP_FLAG  DS AL1               Suboption valid bits    RS0806\n                    DS AL3               Unused suboption valid bits806\nSUBOPT_DYNDMP_HLQP  DS A                 DYNDUMP HLQ-Option Ptr  RS0806\nSUBOPT_DYNDMP_FLG1  DS X                 DYNDUMP FLAG 4039       RS0806\nSUBOPT_DYNDMP_FLG2  DS X                 DYNDUMP FLAG 40xx       RS0806\nSUBOPT_DYNDMP_HLQO  DSECT                DYNDUMP HLQ             RS0806\nSUBOPT_DYNDMP_HLQL  DS H                 Length of DYNDUMP HLQ   RS0806\nSUBOPT_DYNDMP_HLQS  DS CL26              String of DYNDUMP HLQ   RS0806\nSUBOPT_CEEDMP       DSECT                Suboptions CEEDUMP      RS1007\nSUBOPT_CEEDMP_FLAG  DS AL1               Suboption valid bits    RS1007\n                    DS AL3               Unused suboption valid bits007\nSUBOPT_CEEDMP_PAGL  DS F                 CEEDUMP Pagelength      RS1007\nSUBOPT_CEEDMP_SYSO  DS CL4               CEEDUMP Sysout-Fname    RS1007\nSUBOPT_CEEDMP_SYSC  DS CL1               CEEDUMP Sysout-Class    RS1007\nSUBOPT_CEEDMP_FREE  DS X                 CEEDUMP 0=FREE=END      RS1007\nSUBOPT_CEEDMP_SPIN  DS X                 CEEDUMP 0=SPIN=UNALLOC  RS1007\n                    DS X                 CEEDUMP padding         RS1007\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT321/FILE321.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT321", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}