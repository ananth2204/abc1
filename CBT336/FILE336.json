{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011805000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 3292016, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 12, "INMDSNAM": "CBT.V500.FILE336.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 3292016, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 3292016, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE336.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x005\\x0f'", "DS1TRBAL": "b'BF'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x02\\x82\\x00\\x01\\x02\\x85\\x00\\t\\x006'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$INDEX": {"ttr": 516, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "$$$INDEX.......THIS MEMBER - CREATED AT CBT BY ARNIE\n               MEMBERS ENDING IN @ ARE DOCUMENTS\n               MEMBERS ENDING IN $ ARE JCL MEMBERS\n               MEMBERS ENDING IN # ARE HELP MEMBERS\n$$DOC..........DOCUMENT FILE FOR WHAT IS IN THIS FILE - FORMAT=FBA\nASMDSA.........MACRO FOR THE DSA\nASMTCA.........MACRO FOR THE PSEUDO-TCA\nASMVDA.........MACRO FOR THE VDA-HEADER\nASM04@.........DOC FOR SAVEX AND RETURNX MACRO INSTRUCTION\nBANNER.........BANNER MACRO\nCLUSTSPAR......SOURCE FOR IKJPARS-LIKE PARSING ROUTINE\nCMDIN..........SOME KIND OF TAPE OF TSO COMMANDS (?)\nCOB02@.........DOC FOR JULIAN-GREGORIAN DATE CONV ROUTINE\nCOPYVTOC.......DISK MAPPER - VTOC COPY ROUTINE\nDISKUTI$.......JCL FOR DISK UTILITY PROGRAM\nDISKUTIL.......DISK UTILITY PROGRAM\nFORMAT4........DISK MAPPER - TIOT AND JFCB MODIFIER\nFUNCACC@.......DOC FOR THE TSO FUNCTIONAL ACCOUNT ENHANCEMENT\nIECSDSL1.......PL/I DSECT OR CSECT OF SOME SORT\nIEEMB846.......MACRO\nIKJEXTEN.......MACRO THAT IS A MODIFIED VER OF THE SVS IKJIDENT\nINT18@.........DOC ON REQUIREMENTS FOR LOCAL MVS TSO COMMANDS\nJES2PARM.......JES2 PARM MEMBER THAT HANDLES LOCAL FORMS\nJULIAN.........JULIAN DATE PROGRAM\nLIBEL..........MACRO TO GENERATE CODE FOR A LABEL\nLIBLOCK........MACRO\nLICOND.........MACRO TRANSLATES CONDITION INTO PL/I ERROR CODES\nLIENTRY........MACRO\nLIENVASM.......SOURCE - SIMULATED PL/I ENVIRONMENT ROUTINES\nLIENVPLI.......SOURCE - PL/I ENVIRONMENT INTERFACE ROUTINES\nLIERRSET.......MACRO FOR LIE\nLIERSET........SOURCE - ASSEMBLER ENVIRONMENT ERROR TRACE ROUTINE\nLIES@..........DOC FOR THE LANGUAGE INDEPENT ENVIRONMENT (LIE)\nLIEXIT.........MACRO GENERATES LANGUAGE-INDEPENDENT CODE TO RETURN\nLIFO...........MACRO GENERATES LANGUAGE INDEPENDENT CODE-GET STORAGE\nLIFREE.........MACRO GENERATES LANGUAGE INDEPENDENT CODE FREE STORAGE\nLIGET..........MACRO\nLIGOTO.........MACRO\nLINSURE........MACRO\nLION...........MACRO\nLIONCB.........MACRO\nLIREVERT.......MACRO\nLIRLSE.........MACRO\nLISECT.........MACRO\nLISIGNAL.......MACRO\nLISTM..........SOURCE FOR LIST MEMBERS COMMAND\nLISTM#.........HELP FOR LIST MEMBERS COMMAND\nLISTU..........SOURCE FOR LIST USERS COMMAND\nLISTU#.........HELP FOR LIST USERS COMMAND\nMAPDISK........SOURCE FOR MAPDISK - MAIN ROUTINE\nMAPDISK$.......JCL TO EXECUTE MAPDISK\nMLPA...........MODPREP PROGRAM\nPARSE@.........DOC ON PARSE AND RICE'S REPLACEMENT\nPLIDSA.........MACRO\nPLIONCB........MACRO\nPLITCA.........MACRO\nPRINTPD$.......JCL FOR PRINTING PDS'S\nRCB02A1........USERMOD IN SMP FORMAT\nRCB05A1........USERMOD IN SMP FORMAT\nRCB06A1........USERMOD IN SMP FORMAT\nRCB07A1........USERMOD IN SMP FORMAT\nRDA01U1........USERMOD IN SMP FORMAT\nREGISTER.......MACRO FOR REGISTER EQUATES\nRETURNX........MACRO FOR RETURN\nRJC12K1........USERMOD IN SMP FORMAT\nRTS03A1........USERMOD IN SMP FORMAT\nRTS10A1........USERMOD IN SMP FORMAT\nRTS10Q1........USERMOD IN SMP FORMAT\nRTS10T1........USERMOD IN SMP FORMAT\nRTS10Z1........USERMOD IN SMP FORMAT\nRTU05A1........USERMOD IN SMP FORMAT\nRUA03A1........USERMOD IN SMP FORMAT\nRUA03B1........USERMOD IN SMP FORMAT\nRUA03C1........USERMOD IN SMP FORMAT\nRUA03D1........USERMOD IN SMP FORMAT\nRUA04A1........USERMOD IN SMP FORMAT\nRUA04Q1........USERMOD IN SMP FORMAT\nRUA11A1........USERMOD IN SMP FORMAT\nRUA11B1........USERMOD IN SMP FORMAT\nRUA11C1........USERMOD IN SMP FORMAT\nRUA13A1........USERMOD IN SMP FORMAT\nRUA13M1........USERMOD IN SMP FORMAT\nRUA13Q1........USERMOD IN SMP FORMAT\nSAVEX..........MACRO FOR SAVING\nSEQCOPY........SOURCE FOR SEQUENTIAL COPY UTILITY\nSEQCOPY$.......JCL TO EXECUTE SEQCOPY\nTAPECOP$.......JCL TO EXECUTE TAPECOPY\nTAPEMAP$.......JCL TO EXECUTE TAPEMAP\nTAPESCA$.......JCL TO EXECUTE TAPE SCAN\nTAPESCAN.......SOURCE FOR THE TAPESCAN PROGRAM\nTAPESCUR.......TAPESCAN SECURITY EXIT FOR ACF2 VOL PROTECTION\nTAPESUC@.......DOC FOR TAPESCAN SECURITY PROTECTION\nTSOSUMM........SOURCE FOR TSO FUNCTIONAL ACCOUNTING SUMMARY RPT PGM\nTSOSUMM$.......JCL TO EXECUTE TSOSUMM\nTSO0906@.......DOC FOR THE LIST MEMBER TSO CP\nTSO0910@.......DOC FOR THE LIST USER   TSO CP\nTSO0917@.......DOC FOR THE XSEND       TSO CP\nTTS02A1........USERMOD IN SMP FORMAT\nUEBPDSPT.......SOURCE FOR GENERALIZED PDS LISTER\nUEHSTAMP.......SOURCE FOR OWNERSHIP STAMPER FOR DATA SETS\nUGET...........MACRO\nUHBACT.........MACRO\nUHBADDR........MACRO\nUHBBGEN........MACRO\nUHBBMOD........MACRO\nUHBCOLON.......MACRO\nUHBEGEN........MACRO\nUHBGEN.........MACRO\nUHBGENF........MACRO\nUHBGENV........MACRO\nUHBILDUP.......MACRO\nUHBLKUP........MACRO\nUHBMACS@.......DOC FOR THEIR LOCAL MACROS\nUHBMOD.........MACRO\nUHBMODF........MACRO\nUHBMODV........MACRO\nUHBMOVE........MACRO\nUHBRKDN........MACRO\nUHBRQR.........MACRO\nUHBSTORE.......MACRO\nUHBSUB.........MACRO\nUHBSVC.........MACRO\nUKJUGET........SOURCE FOR EASY-TO-USE PUTGET  INTERFACE ROUTINE\nUKJUPUT........SOURCE FOR EASY-TO-USE PUTLINE INTERFACE ROUTINE\nULT03@.........DOC FOR THE SEQCOPY PROGRAM\nULT07@.........DOC FOR THE DISK UTILITY PROGRAM\nULT11@.........DOC FOR THE TAPESCAN PROGRAM\nULT19@.........DOC FOR THE PROGRAMS TO PRINT AND PUNCH PDS'S\nUPROMPT........MACRO\nUPUT...........MACRO\nXSEND..........SOURCE FOR THE XSEND TSO COMMAND\nXSEND#.........HELP   FOR THE XSEND TSO COMMAND\nXSENDPUT.......SOURCE FOR THE TPUT ROUTINE FOR THE XSEND COMMAND\nXTPUTSVC.......XVC    FOR THE XSEND TSO COMMAND\nXWTO...........MACRO SUBSTITUTE FOR WTO AND WTOR\nXWTO@..........DOC FOR THE XWTO MACRO\nXWTOLKIN.......MACRO FOR THE XWTO MACRO\nXWTOLKUP.......MACRO FOR THE XWTO MACRO\nXWTORD.........MACRO FOR THE XWTO MACRO\nXWTORDM........MACRO FOR THE XWTO MACRO\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$DOC": {"ttr": 519, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "1\n-\n      This is a collection of utilities, macros, TSO commands, usermods, and\n      other stuff from Rice University.  We run MVS/SP 1.1.1 with base-level\n      JES2 (EJE1102),  and all of this is  working at that level.   (We also\n      run UICC's JTIP and ACF2, which are occasionally referenced.  We think\n      we have removed all serious dependencies on these products.)\n0     Some of this is updated/corrected versions  of stuff we originally got\n      from the 1-23-82 version of the mods  tape.   Therefore some of it may\n      have  been superseded  or complicated  by  other changes  to the  same\n      programs since then.\n0     For answers to questions,  further information,  or problem reporting,\n      please contact:\n0               Richard Schafer\n                Rice University, ICSA\n                P.O. Box 1892\n                Houston, Tx 77251\n0               (713) 527-4984\n0     This collection includes:\n0          TAPESCAN, a tape scanning/copying utility especially suited to\n+       \u00ae\n           diagnosis of over-written or otherwise screwed-up tapes.  This\n           version of  TAPESCAN  includes  extensive  support  for  ANSI-\n           labelled  tapes,  and  a lot  of  security support  (including\n           password, expiration date and ACF2 security checking).\n0          DISKUTIL, an IEHPROGM replacement.\n+       \u00ae\n0          SEQCOPY, an IEBGENER replacement.\n+       \u00ae\n0          PRINTPDS,  a utility to print all members of a PDS,  no matter\n+       \u00ae\n           what record format.    It produces a table of  contents and an\n           alias cross-reference.\n0          MAPDISK,  another VTOC mapping utility (unrelated to others of\n+       \u00ae\n           the same name).\n0          A version of dynamic MLPA (or MODREP)  with some horrible bugs\n+       \u00ae\n           fixed.   (Now we know why it stopped working when we installed\n           low-memory protection!)\n0          CLUTSPAR,  a friendlier version of IKJPARS.   Try it,  and you\n+       \u00ae\n           won't want to  go back!   Note that CLUTSPAR  does not support\n           any TSO/E  features such  as the PARSE  interface to  the HELP\n           command,   due  to  lack  of information  on  how  they  work.\n           (CLUTSPAR is a fragment of a project called TSU, which started\n           out as a mechanism for writing TSO command processors in PL/I,\n           and  eventually sprouted  replacements for  major portions  of\n           TSO.   TSU as  a whole has never quite become  clean enough to\n           release, but CLUTSPAR is such an enormous improvement over the\n           competition that we decided to make it an exception.)\n0          The Language Independent  Environment (LIE),  a set  of macros\n+       \u00ae\n           and routines to let you  write assembler subroutines which can\n           take advantage  of services of  the PL/I environment,   plus a\n           pseudo-PL/I  environment manufacturer,   to  provide the  same\n           services in the  absence of PL/I.   CLUTSPAR  is a pseudo-PL/I\n           application in this sense.\n0          The XSEND TSO command, for improved communication with logged-\n+       \u00ae\n           on TSO users.   Now you can send with WAIT and break out of it\n           if you get  tired of waiting!   XSEND includes a  user SVC for\n           controlled use  of TPUT HIGHP (to  send bells/alarm to  tell a\n           NOINTERCOM user someone wants to \"speak\" to him).\n0          LISTM, a nice TSO command to list PDS member names.\n+       \u00ae\n0          LISTU,   a nice  TSO  command to  list  TSO  users (sorted  by\n+       \u00ae\n           userid).\n0          UPUT, UPROMPT and UGET, macros to use as replacements for TPUT\n+       \u00ae\n           and  TGET   that  interface  to  the   PUTLINE/PUTGET  service\n           routines.  They make conversion of old TSO code so it will run\n           under a batch TMP much easier.\n1\n0                                                                     PAGE 2\n0          XWTO,  a macro to allow WTO messages to be built from segments\n+       \u00ae\n           without having to compute all the offsets.\n0          UHB macros,  a set of utility macros to make writing big macro\n+       \u00ae\n           applications (like XWTO turned out to be) much easier.\n0          A JULIAN routine (originally written  to be called from COBOL)\n+       \u00ae\n           to convert dates between Julian  and Gregorian format,  and to\n           determine the day of the week.    This routine is not all that\n           interesting, but it is used by some of the other submissions.\n0          SAVEX and RETURNX macros,  yet  another example of an extended\n+       \u00ae\n           SAVE and RETURN.   Again,  not that interesting,  but used all\n           over by our other code.\n0     The  above  are   (except  for  the  XSEND  SVC   and  CLUTSPAR)   all\n      applications, and require  no SMP work.    We are also  providing SMP-\n      packaged SYSMODS to support:\n0          A modification to the JES2 $DF  command to allow selections of\n+       \u00ae\n           the  types of  data  sets to  be  displayed.    This mod  also\n           introduces  the $XF  command,  which  displays  each job  with\n           output of the specified kind.\n0          A big mod  to JES2 output processing to provide  counts of the\n+       \u00ae\n           actual number of pages printed for a job, based on definitions\n           of  forms and  carriage  tape layouts  contained  in the  JES2\n           initialization parameters.\n0          A mod to  TSO functional accounting (SMF type  32 records)  to\n+       \u00ae\n           record response-time-related  information in place of  some of\n           the more esoteric  present information,  and to  not require a\n           pre-assembled list  of interesting  commands.   Included  is a\n           report program to  summarize the records contained  in a batch\n           of SMF data.\n0          A version of the mod to add  the maximum condition code to the\n+       \u00ae\n           JES2 NOTIFY message.\n0          A  JES2 mod  to  display the  converter  ABEND  code when  the\n+       \u00ae\n           converter crashes.   (Now who would ever  want to know a thing\n           like that?)\n0          A mod  to remove \"CN(00)\"  from NOTIFY messages  (and anything\n+       \u00ae\n           else sent via internal SEND commands).\n0          A mod  to stamp  a new format  1 DSCB with  the userid  of its\n+       \u00ae\n           creator (from the SMF userid field).  With ACF2 (and the right\n           ACF2 options), this will be the ACF2 logonid.\n0     The submission is  divided into data sets according to  data set type,\n      as follows:\n0          ASM: assembler source and macros\n           CNTL: JCL procs and examples\n           DATA: miscellaneous data\n           HELP: TSO help information\n           LIST:  various  pieces of documentation  (formatted for 8.5  x 11\n                forms, 8 lines to the inch)\n           PASCAL: PASCAL source (for PASCAL/VS)\n           PLI: PLI source and macros\n           SMPPTFIN: SMP PTF input\n0     A breakdown of the individual members, their origins and relationships\n      are as follows:\n0     ASM:\n0          ASM...:  Macros for  use with the LIE  pseudo-PL/I environment\n+       \u00ae\n           (author: Alan Beale)\n0          BANNER: An inner macro for SAVEX (origin unknown)\n+       \u00ae\n0          CLUTSPAR: IKJPARS, done right (author: Alan Beale)\n+       \u00ae\n1\n0                                                                     PAGE 3\n0          COPYVTOC: A subroutine of MAPDISK (author: Richard Schafer)\n+       \u00ae\n0          DISKUTIL:   The   DISKUTIL  source  (author:    Steve  Glaser;\n+       \u00ae\n           maintenance:  Richard Schafer)\n0          FORMAT4: A subroutine of MAPDISK (author: Richard Schafer)\n+       \u00ae\n0          IEEMB846: A command list member to use with the TSO functional\n+       \u00ae\n           accounting mod (author: Alan Beale)\n0          IKJEXTEN:  A macro for defining a TSO command operand which is\n+       \u00ae\n           to  be recognized  by  a routine  supplied  by  the caller  of\n           IKJPARS (origin: IBM IKJIDENT macro; adaptor: Alan Beale)\n0          JULIAN:  The source  to the JULIAN subroutine  (authors:  Nick\n+       \u00ae\n           Nichols, Mark Williamson)\n0          LI...:  Macros and subroutines for LIE.  The members LIENVASM,\n+       \u00ae\n           LIENVPLI and  LIERSET are  subroutines,  the  rest are  macros\n           (author:  Alan Beale)\n0          LISTM:   The  source  to  the  LISTM  command  (author:   Mark\n+       \u00ae\n           Williamson; maintenance: Alan Beale)\n0          LISTU: The source to the LISTU command (author: Sara Goodman)\n+       \u00ae\n0          MLPA: The source to the dynamic MLPA (MODREP) routine (origin:\n+       \u00ae\n           CBT mods tape; maintenance: Alan Beale)\n0          PLI...: Macros for use by LIE routines (author: Alan Beale)\n+       \u00ae\n0          RETURNX/SAVEX:  The RETURNX and SAVEX  macros (origins lost in\n+       \u00ae\n           antiquity; maintenance: Farrell Gerbode, Mark Williamson, Alan\n           Beale)\n0          SEQCOPY:   The  SEQCOPY  source (origin:   Baylor  College  of\n+       \u00ae\n           Medicine; maintenance: Alan Beale)\n0          TAPESCAN:  The TAPESCAN source  (origins:  University of North\n+       \u00ae\n           Carolina, CBT mods tape; maintenance: Alan Beale)\n0          TAPESCUR:  A  sample security  exit for  TAPESCAN to  use ACF2\n+       \u00ae\n           volume protection (author: Alan Beale)\n0          UEBPDSPT: The PRINTPDS source (authors:  Farrell Gerbode, Alan\n+       \u00ae\n           Beale)\n0          UEHSTAMP:   The source  to  the  VTOC ownership  stamping  SVC\n+       \u00ae\n           (author: Alan Beale)\n0          UGET/UPROMPT/UPUT:  The macros of the  same name (origin:  IBM\n+       \u00ae\n           TPUT/TGET macros; adaptor: Alan Beale)\n0          UHB...: The UHB macros, inner and outer (author: Alan Beale)\n+       \u00ae\n0          UKJUGET/UKJUPUT:  The UGET/UPRPOMPT/UPUT  subroutines (author:\n+       \u00ae\n           Alan Beale)\n0          XSEND:   The  XSEND  command main  module  (authors:   Farrell\n+       \u00ae\n           Gerbode, Mark Williamson, Alan Beale)\n0          XSENDPUT: The XSEND subtask module (author: Alan Beale)\n+       \u00ae\n0          XTPUTSVC: The XSEND SVC (author: Alan Beale)\n+       \u00ae\n0          XWTO...:  The XWTO  macro and its inner  macros (author:  Alan\n+       \u00ae\n           Beale)\n1\n0                                                                     PAGE 4\n0     CNTL:\n-          DISKUTIL: A cataloged procedure to run DISKUTIL\n+       \u00ae\n0          MAPDISK: A cataloged procedure to run MAPDISK\n+       \u00ae\n0          PRINTPDS: A cataloged procedure to run PRINTPDS\n+       \u00ae\n0          SEQCOPY: A cataloged procedure to run SEQCOPY\n+       \u00ae\n0          TAPECOPY: A cataloged procedure to run TAPESCAN to copy a tape\n+       \u00ae\n0          TAPEMAP: A cataloged procedure to run TAPESCAN to map a tape\n+       \u00ae\n0          TAPESCAN: A cataloged procedure to run TAPESCAN to scan a tape\n+       \u00ae\n0          TSOSUMM: A sample job to run the TSOSUMM program\n+       \u00ae\n0     DATA:\n-          CMDIN:  Sample input data for  the TSOSUMM program (containing\n+       \u00ae\n           TSO command and subcommand alias information)\n0          JES2PARM: A sample JES2 PARMLIB member for forms definition\n+       \u00ae\n0     LIST:\n-          ASM04: A document on the use of SAVEX and RETURNX\n+       \u00ae\n0          COB02: A document on the use of the JULIAN routine\n+       \u00ae\n0          FUNCACCT: A brief description on the TSO functional accounting\n+       \u00ae\n           mod and its usage\n0          INT18: A document on the use of UGET, UPROMPT and UPUT\n+       \u00ae\n0          LIES: A brief document describing the use of the LIE macros\n+       \u00ae\n0          PARSE:    A  document   describing  how   to  write   CLUTSPAR\n+       \u00ae\n           \"recognizers\"\n0          TAPESCUR:   A brief  description of  aspects  of TAPESCAN  not\n+       \u00ae\n           covered in the user documentation\n0          TSO0906: A document on the LISTM command\n+       \u00ae\n0          TSO0910: A document on the LISTU command\n+       \u00ae\n0          TSO0917: A document on the XSEND command\n+       \u00ae\n0          UHBMACS:  A brief description of the UHB macros and how to use\n+       \u00ae\n           them\n0          UTL03: A document on the SEQCOPY utility\n+       \u00ae\n0          UTL07: A document on the DISKUTIL utility\n+       \u00ae\n0          UTL11: A document on the TAPESCAN utility\n+       \u00ae\n0          UTL19: A document on the PRINTPDS utility\n+       \u00ae\n0          XWTO: A brief description of the use of XWTO\n+       \u00ae\n0     PASCAL:\n-          TSOSUMM:  The source  of the TSO functional  accounting report\n+       \u00ae\n           program (author: Alan Beale)\n1\n0                                                                     PAGE 5\n0     PLI:\n-          IECSDSL1:   PL/I  VTOC  mapping macros  (origins:   IBM  PL/S;\n+       \u00ae\n           adaptor:  Richard Schafer)\n0          MAPDISK:   The source  of  the  main MAPDISK  module  (author:\n+       \u00ae\n           Richard Schafer)\n0     SMPPTFIN:\n-          RCB02A1:  A JES2 control block mod required by other JES2 mods\n+       \u00ae\n           (author: Richard Schafer)\n0          RCB05A1:   Another JES2  control block  mod (author:   Richard\n+       \u00ae\n           Schafer)\n0          RCB06A1:  Yet another JES2 control block mod (author:  Richard\n+       \u00ae\n           Schafer)\n0          RCB07A1:  Yet another JES2 control block mod (author:  Richard\n+       \u00ae\n           Schafer)\n0          RDA01U1:  The JES2  mod to diagnose converter  ABENDs (author:\n+       \u00ae\n           Richard Schafer)\n0          RJC12K1:   The JES2  mod  to implement  extended  $DF and  $XF\n+       \u00ae\n           (author:  Richard Schafer)\n0          RTS03A1: The mod to install the XSEND SVC (author: Alan Beale)\n+       \u00ae\n0          RTS10..:   The mods  to  install the  JES2  change which  adds\n+       \u00ae\n           maximum condition code  to NOTIFY messages (origin:   CBT mods\n           tape; maintenance: Richard Schafer)\n0          RTU05A1: The mod to install CLUTSPAR as IKJPARS (author:  Alan\n+       \u00ae\n           Beale)\n0          RUA03..:  The mods to install VTOC ownership stamping (author:\n+       \u00ae\n           Alan Beale)\n0          RUA04..:  The  mods to add  additional fields related  to page\n+       \u00ae\n           counting to the type 6 SMF record (author: Richard Schafer)\n0          RUA11..:  The  mods to install  the TSO  functional accounting\n+       \u00ae\n           changes (author: Alan Beale)\n0          RUA13..:  The mods  to JES2 to implement  output page counting\n+       \u00ae\n           (author: Richard Schafer)\n0          TTS02A1:  The mod to remove CN(00) from the text of internally\n+       \u00ae\n           generated SENDs (author: Alan Beale)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASMDSA": {"ttr": 525, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         ASMDSA\nADSA     DSECT\n         SPACE\n***********************************************************************\n*        THIS DSECT MAPS THE PARTS OF THE DSA WHICH ARE USED BY THE   *\n*        ASSEMBLER VERSION OF THE LANGUAGE-INDEPENDENT ENVIRONMENT.   *\n***********************************************************************\n         SPACE\nADSAFLGS DS    4XL1               PL/1 COMPATIBILITY FLAGS\nADSAON   EQU   X'40'              BLOCK HAS ON CELLS\nADSABLOK EQU   X'08'              GOTO-BLOCKING FLAG\nADSACHN  DS    A                  SAVE-AREA CHAIN FIELD\nADSACHN2 DS    A                  CHAIN-BACK FIELD (ACTUALLY USED)\nADSASAVE DS    14A\n         DS    A\nADSAVDA  DS    A                  1ST VDA POINTER\nADSALEN  DS    A                  LENGTH OF THIS DSA\nADSAGOT  EQU   X'01'              DSA GETMAINED FLAG\nADSAFINL EQU   X'80'+ADSAGOT      FIRST DSA FLAG\nADSAOERX DS    A                  PREVIOUS ERROR EXIT\n         DS    A                  AND ONE TO GROW ON\n         DS    A                  PRESENT ONLY IF ADSAON IS SET\nADSAONCB DS    A                  FIRST STATIC ONCB\n         DS    2A\nADSAOR5  DS    A                  R5 SAVE AREA OVER SIGNAL\nADSAOR14 DS    A                  R14 SAVE AREA OVER SIGNAL\nADSAONCL DS    A                  POINTER TO ONCELLS\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMTCA": {"ttr": 527, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         ASMTCA\nATCA     DSECT\n         SPACE\n***********************************************************************\n*        THIS DSECT MAPS THE PSEUDO-TCA FOR THE ASSEMBLER VERSION     *\n*        OF THE LANGUAGE-INDEPENDENT ENVIRONMENT.                     *\n***********************************************************************\n         SPACE\nATCAFLGS DS    2XL1               FOR PL/I COMPATIBILITY\nATCAFAKE EQU   X'04'                   FAKE ENVIRONMENT FLAG (=TTFC)\nATCAISIZ DS    H                  ISA SIZE\nATCAPRVA DS    A                  ADDR(PSEUDO-REGS)\nATCAR12  DS    F                  CONTENTS OF CALLER'S R12\nATCANAB  DS    A                  NEXT AVAIL. BYTE OF ISA\nATCAEOS  DS    A                  END OF ISA PTR\nATCADSA  DS    A                  TOP DSA ADDRESS\nATCAOPIC DS    A                  CALLER'S PICA\nATCAPICA DS    XL6                OUR PICA\nATCAERRX DS    A                  CURRENT ERROR EXIT\n         SPACE\nATCALEN  EQU   *-ATCA\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMVDA": {"ttr": 529, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         ASMVDA\nAVDA     DSECT\n         SPACE\n***********************************************************************\n*        THIS DSECT MAPS THE VDA-HEADER FOR THE ASSEMBLER VERSION OF  *\n*        THE LANGUAGE-INDEPENDENT ENVIRONMENT.                        *\n***********************************************************************\n         SPACE\nAVDACHN  DS    A                  CHAIN TO NEXT VDA\nAVDALEN  DS    A                  LENGTH & SUBPOOL OF THIS VDA\n         SPACE\nAVDAHLEN EQU   *-AVDA             LENGTH OF THE VDA HEADER\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASM04@": {"ttr": 769, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "1\n-\n0                  INSTITUTE FOR COMPUTER SERVICES AND APPLICATIONS\n0                                  RICE UNIVERSITY\n0                                   10 March 1980\n0                                Document No. ASM004\n0                        SAVEX and RETURNX Macro Instructions\n-\n        The IBM conventions for register saving and save area chaining in\n        assembler language routines require a substantial amount of\n        housekeeping code at the start of a routine and a lesser amount at\n        each exit point.  The IBM SAVE and RETURN macro instructions provide a\n        shorthand for some, but not all, of the necessary code.  ICSA provides\n        the SAVEX and RETURNX macros to allow the generation of all normal\n        entry and exit code with a single macro instruction.  SAVEX and\n        RETURNX are stored in the data set RICE.MACLIB, which is automatically\n        available in batch when any ICSA assembler PROC is used (unless the\n        SYSMAC1 parameter of the EXEC card is specified) and in time-sharing\n        when either of the ICSA assembler prompters is used (unless either the\n        NORICEMAC or LIBFILE keyword is specified).\n-       SAVEX\n0       The SAVEX macro is used to save registers at an entry point of a\n        routine, to establish a new save area, link it to the save area chain,\n        and set up base and parameter registers.  It also can be used to\n        provide internal documentation of the function and version of the\n        routine.\n0       The syntax of SAVEX is as follows:\n0           \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n+                       \u00af           \u00af\n            |           |           |                                |\n            |  LABEL    |  MACRO    |     OPERANDS                   |\n            |           |           |                                |\n            |\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\n+           \u00bf           \u00d7           \u00d7                                ]\n            |           |           |                                |\n            |           |           |     \u00d0                \u00af         |\n            |  \u00ddlabel\u00a8  |  SAVEX    |     | REGS=(r1\u00dd,r2\u00a8) |         |\n            |           |           |     \u00bf                ]         |\n            |           |           |     \u00d0                      \u00af   |\n            |           |           |     | ,LV=length,SP=number |   |\n            |           |           |     | ,SA=address          |   |\n            |           |           |     | ,CHAIN=NO            |   |\n            |           |           |     \u00bf                      ]   |\n            |           |           |     \u00d0                  \u00af       |\n            |           |           |     | ,BASE=(reg-list) |       |\n            |           |           |     \u00bf                  ]       |\n            |           |           |     \u00d0            \u00af             |\n            |           |           |     | ,PARMR=reg |             |\n            |           |           |     \u00bf            ]             |\n            |           |           |     \u00d0           \u00af              |\n            |           |           |     | ,CSECT=NO |              |\n            |           |           |     \u00bf           ]              |\n            |           |           |     \u00d0             \u00af            |\n            |           |           |     | ,REGSTRS=NO |            |\n            |           |           |     \u00bf             ]            |\n            |           |           |     \u00d0          \u00af               |\n            |           |           |     | ,ID=name |               |\n            |           |           |     \u00bf          ]               |\n            |           |           |     \u00d0         \u00af                |\n            |           |           |     | ,TMS=NO |                |\n            |           |           |     \u00bf         ]                |\n            |           |           |     \u00d0               \u00af          |\n            |           |           |     | ,XID='string' |          |\n            |           |           |     \u00bf               ]          |\n            |           |           |     \u00d0           \u00af              |\n            |           |           |     | ,PARM=YES |              |\n            |           |           |     \u00bf           ]              |\n            |           |           |     \u00d0             \u00af            |\n            |           |           |     | ,BANNER=YES |            |\n            |           |           |     \u00bf             ]            |\n            |           |           |                                |\n            \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n+                       \u00bf           \u00bf\n1\n        ASM004                                                          Page 2\n-\n        REGS=(r1\u00dd,r2\u00a8) specifies which registers are to be saved on entry to\n             the routine.  The registers are stored by the instruction\n0                      STM   r1,r2,offset(13)\n0            The registers must be specified as absolute integers (i.e.,\n             symbolic registers are not allowed).  REGS=(14,12) is the\n             default.  Note that if only one register is specified, only that\n             register is saved.\n0       LV=length requests the allocation of a new save area of the indicated\n             length by use of the GETMAIN macro.  GETMAIN is described in the\n             IBM manual, OS/VS2 MVS Supervisor Services and Macro\n+                        ______ ___ __________ ________ ___ _____\n             Instructions.  If none of LV, SA and CHAIN is specified, LV=72 is\n+            ____________\n             assumed by default.\n        SP=number specifies the storage subpool from which a new save area is\n             to be allocated.  The default is SP=0.  For information on the\n             use of subpools, see the IBM manual, OS/VS2 MVS Supervisor\n+                                                 ______ ___ __________\n             Services and Macro Instructions.\n+            ________ ___ _____ ____________\n        SA=address specifies that the storage area indicated is to be used as\n             a new save area.  Alternately, SA=* may be used to specify that a\n             new static save area (of length 72 bytes) should be generated as\n             part of the macro expansion.  If SA is specified, LV and SP will\n             be ignored.  Note: The use of SA causes the containing program to\n             be non-reentrant.\n        CHAIN=NO may be specified to suppress chaining to or allocating a new\n             save area.  If CHAIN=NO is not specified, these functions will be\n             performed.\n0       BASE=(reg-list) specifies one or more registers to be set up as\n             program base registers.  If only one register is supplied, the\n             parentheses may be omitted.  The default is BASE=12.  Note: If an\n             assembler routine is intended for use from PL/I, the BASE keyword\n             should be explicitly supplied, as maintenance of the PL/I\n             environment requires that the contents of register 12 not be\n             modified.\n0       PARMR=reg specifies that the contents of register 1 (usually a\n             parameter address) are to be preserved in the indicated register.\n             The form \"PARMR=\" may also be used to indicate that the contents\n             of register 1 need not be preserved.  Note that registers 13, 14,\n             15 and 0 must not be used for this purpose.  PARMR=1 is the\n             default.\n0       CSECT=NO specifies that a new control section is not to be started.\n             If CSECT=NO is not specified, a new CSECT is generated whose name\n             is the label of the SAVEX macro.\n0       REGSTRS=NO may be specified to suppress the generation of standard\n             symbolic names for the general-purpose and floating-point\n             registers.  If REGSTRS=NO is not coded, the symbols Rn (for n\n             between 0 and 15) and FRn (for even n between 0 and 6) are\n             generated.  Additionally, symbols RA, RB ... RF are generated as\n             an alternate representation for registers 10 through 15.  SAVEX\n             will not generate register names more than once in a single\n             assembly.\n0       ID=name may be used to specify a routine name to appear in the SAVE\n             AREA TRACE portion of a dump taken while the routine is active.\n             If the ID parameter is omitted, the label field of the macro, or\n             the current CSECT name if the macro has no label, is used.\n0       TMS=NO may be used to specify that the time and date of assembly not\n             be included in the SAVE AREA TRACE information.  If TMS=NO is not\n             specified, the time and date of assembly will appear\n             automatically in any dump taken while the routine is active.\n0       XID='string' may be used to insert descriptive text into the SAVE AREA\n             TRACE information.\n0       PARM=YES may be used to insert any SYSPARM value passed to the\n             assembler into the SAVE AREA TRACE information.\n0       BANNER=YES may be specified to produce a heading page for a routine.\n             This page will contain the routine name, time of assembly and\n             date of assembly in block letters.  If TMS=NO was specified, only\n             the routine name is so printed.  Note that the use of this\n             specification may substantially increase the CPU time required\n             for assembly.\n1\n        ASM004                                                          Page 3\n-\n        Example 1:  Begin a routine named CLOCK, using standard linkage\n             conventions, register 12 as a base register, 1 as a parameter\n             register, and a 72 byte dynamic save area.\n0         cc 1        10\n             CLOCK    SAVEX\n-       Example 2:  Begin a routine with two entry points, A and B.  At each\n             entry, save the contents of register 1 in register 3.  Use a\n             static save area with label MYSAVE.\n0         cc 1        10    16\n             A        SAVEX SA=MYSAVE,PARMR=R3\n                      B     JUNCTION\n                      DROP  R12\n                      ENTRY B\n             B        SAVEX SA=MYSAVE,PARMR=R3,CSECT=NO\n             JUNCTION BALR  R12,0\n                      USING *,R12\n-       Example 3:  Begin a routine FREQNCY, which requires a dynamic work and\n             save area of 12K bytes, and 2 base registers.  Provide detailed\n             information to be printed in the SAVE AREA TRACE of a dump.\n0         cc 1        10    16                                         72\n             FREQNCY  SAVEX LV=12288,BASE=(R10,R11),BANNER=YES,        *\n                            XID='FREQUENCY REPORTING SUBROUTINE - VERSI*\n                            ON 6.1'\n-       RETURNX\n0       The RETURNX macro is used to return control to a calling routine,\n        freeing any dynamic save area taken on entry.  The syntax of RETURNX\n        is as follows:\n-            \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n+                        \u00af           \u00af\n             |           |           |                                |\n             |  LABEL    |  MACRO    |    OPERANDS                    |\n             |           |           |                                |\n             |\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\n+            \u00bf           \u00d7           \u00d7                                ]\n             |           |           |                                |\n             |           |           |    \u00d0              \u00af            |\n             |           |  RETURNX  |    | REGS=(r1,r2) |            |\n             |           |           |    \u00bf              ]            |\n             |           |           |    \u00d0                \u00af          |\n             |           |           |    | ,RC=number     |          |\n             |           |           |    | ,RC=(reg-list) |          |\n             |           |           |    \u00bf                ]          |\n             |           |           |                                |\n             \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n+                        \u00bf           \u00bf\n-       REGS=(r1,r2) specifies which registers are to be restored before\n             returning to the calling program.  The registers are loaded by\n             the instruction\n0                      LM    r1,r2,offset(13)\n0            The registers must be specified as absolute integers (i.e.,\n             symbolic registers are not allowed).  REGS=(14,12) is the\n             default.  If only a single register is specified, only that\n             register will be restored.\n0       RC=number specifies a return code which is to be returned to the\n             calling routine in register 15.  The default is RC=0.\n        RC=(reg-list) specifies one or more registers whose contents are to be\n             returned intact to the calling routine.  The register(s) must be\n             specified as absolute integers (i.e., symbolic registers are not\n             permitted).\n-       Example 1:  Return to the calling routine, with a 0 return code in\n             register 15.\n0         cc 1        10\n                      RETURNX\n1\n        ASM004                                                          Page 4\n-\n        Example 2:  Return to the calling routine, preserving the contents of\n             registers 15 and 0.\n0         cc 1        10\n             EXIT     RETURNX RC=(15,0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BANNER": {"ttr": 774, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         BANNER  &WORD\n         LCLA  &M,&N,&C,&K\n         LCLC  &AST(38),&ALFN(40),&LET(39),&P(8)              *RIC76269\n         LCLC  &B,&PEND\n         SPACE 4\n&B       SETC  ' '\n&K       SETA  2\n&AST(01) SETC  ' ****   '\n&AST(02) SETC  '*    *  '\n&AST(03) SETC  '******  '\n&AST(04) SETC  '*****   '\n&AST(05) SETC  ' *****  '\n&AST(06) SETC  '*       '\n&AST(07) SETC  '***     '\n&AST(08) SETC  '*  ***  '\n&AST(09) SETC  '  ***   '\n&AST(10) SETC  '   *    '\n&AST(11) SETC  '*  *    '\n&AST(12) SETC  ' **     '\n&AST(13) SETC  '*   *   '\n&AST(14) SETC  '* *     '\n&AST(15) SETC  '*     * '\n&AST(16) SETC  '**   ** '\n&AST(17) SETC  '* * * * '\n&AST(18) SETC  '*  *  * '\n&AST(19) SETC  '**    * '\n&AST(20) SETC  '* *   * '\n&AST(21) SETC  '*   * * '\n&AST(22) SETC  '*    ** '\n&AST(23) SETC  '*  * *  '\n&AST(24) SETC  '*   **  '\n&AST(25) SETC  ' **** * '\n&AST(26) SETC  '     *  '\n&AST(27) SETC  ' *   *  '\n&AST(28) SETC  '  * *   '\n&AST(29) SETC  ' *  *   '\n&AST(30) SETC  '    *   '\n&AST(31) SETC  '  *     '\n&AST(32) SETC  ' *      '\n&AST(33) SETC  '******* '\n&AST(34) SETC  '****    '\n&AST(35) SETC  '   **   '\n&AST(36) SETC  '      * '                                     *RIC76269\n&AST(37) SETC  '        '                                     *RIC76269\n&AST(38) SETC  '  **    '                                     *RIC76269\n&ALFN(01) SETC '01222221'\n&ALFN(02) SETC '1ACAAAA9'\n&ALFN(03) SETC '212UAVW3'\n&ALFN(04) SETC '34AVAUUY'\n&ALFN(05) SETC '4UZST3UU'\n&ALFN(06) SETC '5466YUUY'\n&ALFN(07) SETC '61264221'\n&ALFN(08) SETC '75QUAVW6'\n&ALFN(09) SETC '81221221'\n&ALFN(10) SETC '91225Q21'\n&ALFN(11) SETC 'A1223222'\n&ALFN(12) SETC 'B4224224'\n&ALFN(13) SETC 'C1266621'\n&ALFN(14) SETC 'D4222224'\n&ALFN(15) SETC 'E4667664'\n&ALFN(16) SETC 'F4667666'\n&ALFN(17) SETC 'G1266821'\n&ALFN(18) SETC 'H2223222'\n&ALFN(19) SETC 'I9AAAAA9'\n&ALFN(20) SETC 'J1AAAABC'\n&ALFN(21) SETC 'KDBE7BD2'\n&ALFN(22) SETC 'L6666664'\n&ALFN(23) SETC 'MFGHIFFF'\n&ALFN(24) SETC 'NFJKILMF'\n&ALFN(25) SETC 'O1222221'\n&ALFN(26) SETC 'P4224666'\n&ALFN(27) SETC 'Q1222NOP'\n&ALFN(28) SETC 'R4224D22'\n&ALFN(29) SETC 'S5661QQ4'\n&ALFN(30) SETC 'T5AAAAAA'\n&ALFN(31) SETC 'U2222221'\n&ALFN(32) SETC 'VFFFFRSA'\n&ALFN(33) SETC 'WFFFIHGF'\n&ALFN(34) SETC 'XFRSASRF'\n&ALFN(35) SETC 'YFRSAAAA'\n&ALFN(36) SETC 'ZXQUAVWX'\n&ALFN(37) SETC '//QUAVW6'                                     *RIC76269\n&ALFN(38) SETC ': .. .. '                                     *RIC76269\n&ALFN(39) SETC '.     ..'                                     *RIC76269\n&ALFN(40) SETC '-  555  '                                     *RIC76269\n&LET(01) SETC  '0'\n&LET(02) SETC  '1'\n&LET(03) SETC  '2'\n&LET(04) SETC  '3'\n&LET(05) SETC  '4'\n&LET(06) SETC  '5'\n&LET(07) SETC  '6'\n&LET(08) SETC  '7'\n&LET(09) SETC  '8'\n&LET(10) SETC  '9'\n&LET(11) SETC  'A'\n&LET(12) SETC  'B'\n&LET(13) SETC  'C'\n&LET(14) SETC  'D'\n&LET(15) SETC  'E'\n&LET(16) SETC  'F'\n&LET(17) SETC  'G'\n&LET(18) SETC  'H'\n&LET(19) SETC  'I'\n&LET(20) SETC  'J'\n&LET(21) SETC  'K'\n&LET(22) SETC  'L'\n&LET(23) SETC  'M'\n&LET(24) SETC  'N'\n&LET(25) SETC  'O'\n&LET(26) SETC  'P'\n&LET(27) SETC  'Q'\n&LET(28) SETC  'R'\n&LET(29) SETC  'S'\n&LET(30) SETC  'T'\n&LET(31) SETC  'U'\n&LET(32) SETC  'V'\n&LET(33) SETC  'W'\n&LET(34) SETC  'X'\n&LET(35) SETC  'Y'\n&LET(36) SETC  'Z'\n&LET(37) SETC  '/'                                            *RIC76269\n&LET(38) SETC  ' '                                            *RIC76269\n&LET(39) SETC  '.'                                            *RIC76269\n.AGAIN   ANOP\n&P(1)    SETC  '        '\n&P(2)    SETC  '        '\n&P(3)    SETC  '        '\n&P(4)    SETC  '        '\n&P(5)    SETC  '        '\n&P(6)    SETC  '        '\n&P(7)    SETC  '        '\n&P(8)    SETC  '        '                                     *RIC76269\n&N       SETA  0\n.BACK    ANOP\n&N       SETA  &N+1\n         AIF   (&N EQ 9).OUT                                  *RIC76269\n&C       SETA  0\n.GO      ANOP\n&C       SETA  &C+1\n         AIF   ('&ALFN(&C)'(1,1) NE '&WORD'(&N,1)).GO\n&M       SETA  1\n.NEXT    ANOP\n&M       SETA  &M+1\n         AIF   ('&ALFN(&C)'(&K,1) NE '&LET(&M)').NEXT\n&P(&N)   SETC  '&AST(&M-1)'\n         AIF   ('&WORD'(1,&N) NE '&WORD').BACK\n.OUT     ANOP\n&K       SETA  &K+1\n&PEND    SETC  '&P(8)'(1,7)                                   *RIC76269\n        MNOTE *,'&B&P(1)&P(2)&P(3)&P(4)&P(5)&P(6)&P(7)&PEND'  *RIC76269\n         AIF   (&K EQ 9).BYE\n         AGO   .AGAIN\n.BYE     ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CLUTSPAR": {"ttr": 778, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         TITLE 'CLUTSPAR -- LOCAL MACRO DEFINITIONS'\n         MACRO\n         TABSET &VAL\n.*       THIS MACRO IS AN AID IN THE GENERATION OF TRANSLATE TABLES\n         GBLA  &TABVAL(256),&TABNUM\n         LCLA  &I,&N\n&I       SETA  2\n.NEXT    AIF   (N'&SYSLIST(&I) EQ 2).RANGE\n         TABHEX &SYSLIST(&I)\n&TABVAL(&TABNUM) SETA &TABVAL(&TABNUM)+&VAL\n         AGO   .LOOP\n.RANGE   TABHEX &SYSLIST(&I,1)\n&N       SETA  &TABNUM\n         TABHEX &SYSLIST(&I,2)\n.RLOOP   ANOP\n&TABVAL(&N) SETA &TABVAL(&N)+&VAL\n&N       SETA  &N+1\n         AIF   (&N LE &TABNUM).RLOOP\n.LOOP    ANOP\n&I       SETA  &I+1\n         AIF   (&I LE N'&SYSLIST).NEXT\n         MEND\n         SPACE 3\n         MACRO\n         TABHEX &HEX\n.*       THIS MACRO CONVERTS HEX TO DECIMAL FOR TABSET\n         GBLA  &TABNUM\n         LCLC  &D(2)\n         LCLA  &I\n&D(1)    SETC  '&HEX'(1,1)\n&D(2)    SETC  '&HEX'(2,1)\n&I       SETA  1\n.HLOOP   AIF   ('&D(&I)' NE 'A').NA\n&D(&I)   SETC  '10'\n         AGO   .AGAIN\n.NA      AIF   ('&D(&I)' NE 'B').NB\n&D(&I)   SETC  '11'\n         AGO   .AGAIN\n.NB      AIF   ('&D(&I)' NE 'C').NC\n&D(&I)   SETC  '12'\n         AGO   .AGAIN\n.NC      AIF   ('&D(&I)' NE 'D').ND\n&D(&I)   SETC  '13'\n         AGO   .AGAIN\n.ND      AIF   ('&D(&I)' NE 'E').NE\n&D(&I)   SETC  '14'\n         AGO   .AGAIN\n.NE      AIF   ('&D(&I)' NE 'F').AGAIN\n&D(&I)   SETC  '15'\n.AGAIN   ANOP\n&I       SETA  &I+1\n         AIF   (&I LE 2).HLOOP\n&TABNUM  SETA  16*&D(1)+&D(2)+1\n         MEND\n         SPACE 3\n         MACRO\n&N       TABGEN\n.*       THIS MACRO GENERATES THE TRANSLATE TABLE DEFINED BY TABSET\n         GBLA  &TABVAL(256)\n         LCLA  &I\n&N       DC    AL1(&TABVAL(1),&TABVAL(2),&TABVAL(3),&TABVAL(4),&TABVAL(*\n               5),&TABVAL(6),&TABVAL(7),&TABVAL(8))\n&I       SETA  9\n.LOOP    ANOP\n         DC    AL1(&TABVAL(&I),&TABVAL(&I+1),&TABVAL(&I+2),&TABVAL(&I+3*\n               ),&TABVAL(&I+4),&TABVAL(&I+5),&TABVAL(&I+6),&TABVAL(&I+7*\n               ))\n&I       SETA  &I+8\n         AIF   (&I LE 256).LOOP\n         MEND\n         SPACE 3\n         MACRO\n         TABRESET\n.*       THIS MACRO RESETS ACCUMULATED TABSET VALUES FOR GENERATION\n.*       OF A NEW TABLE.\n         GBLA  &TABVAL(256)\n         LCLA  &I\n&I       SETA  1\n.LOOP    ANOP\n&TABVAL(&I) SETA 0\n&I       SETA  &I+1\n         AIF   (&I LE 256).LOOP\n         MEND\n         SPACE 3\n         MACRO\n&NAME    SEG   &TEXT,&OFF=0\n.*       THIS MACRO GENERATES A MESSAGE SEGMENT SUITABLE FOR USE\n.*       WITH PUTLINE OR PUTGET.\n&NAME    DC    AL2(L'SEG&SYSNDX+4,&OFF) MESSAGE LENGTH AND OFFSET\nSEG&SYSNDX DC  C&TEXT             TEXT OF MESSAGE SEGMENT\n         SPACE\n         MEND\n         TITLE 'CLUTSPAR -- IKJPARS-LIKE PARSING ROUTINE'\n         GBLC  &OPSYS\n&OPSYS   SETC  'MVS'              OR 'SVS' OR 'MVT'\n         SPACE\n         BANNER CLUTSPAR\n         SPACE\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*        CLUTSPAR (CALLED AS IKJPARS)                                 *\n*                                                                     *\n* FUNCTION -                                                          *\n*        TO PERFORM THE FUNCTION OF THE TSO SERVICE ROUTINE IKJPARS,  *\n*        WHILE PROVIDING AS MUCH FLEXIBILITY AND USER-FRIENDLINESS    *\n*        AS PERMITTED BY ITS FORMAL, INFORMAL AND TRADITIONAL         *\n*        SPECIFICATIONS. VARIOUS USEFUL AND BENIGN EXTENSIONS ARE     *\n*        ALSO PROVIDED.                                               *\n*                                                                     *\n* ENVIRONMENT -                                                       *\n*        PSEUDO-PL/I CREATED ON ENTRY.                                *\n*                                                                     *\n* LINKAGE -                                                           *\n*        LINK FROM A COMMAND PRCESSOR. (IN MVS, THE CALLTSSR MACRO    *\n*        MAY ALSO BE USED.)                                           *\n*                                                                     *\n* PARAMETERS -                                                        *\n*        PARSE PARAMETER LIST, AS MAPPED BY THE IKJPPL MACRO, AND     *\n*        OTHER PARAMETER LISTS ADDRESSED THEREBY, NOTABLY THE OUTPUT  *\n*        OF THE IKJPOSIT, IKJIDENT, IKJKEYWD AND OTHER SYNTAX-        *\n*        DEFINITION MACROS.                                           *\n*                                                                     *\n* RETURN CODES (RETURNED VIA R15) -                                   *\n*         0:   SUCCESSFUL EXECUTION                                   *\n*         4:   UNABLE TO PROMPT FOR CORRECTION OF INVALID PARAMETERS  *\n*         8:   PARSE TERMINATED BY ATTENTION                          *\n*        12:   INVALID PARAMETER LIST OR INTERNAL ERROR IN PARSE      *\n*        16:   CONDITIONAL GETMAIN FAILED (NO MEMORY AVAILABLE)       *\n*        20:   TERMINATION REQUESTED BY CALLER'S VALIDITY CHECK EXIT  *\n*        24:   CONFLICTS FOUND IN COBOL SYNTAX DEFINITIONS (IKJOPER,  *\n*              IKJTERM AND IKJRSVWD)                                  *\n*        28:   TERMINAL DISCONNECTED                                  *\n*                                                                     *\n* MAJOR INCOMPATIBILITIES -                                           *\n*        THE VALIDITY CHECK EXIT FOR A RANGE MAY BE CALLED THREE      *\n*        TIMES, ONCE FOR EACH PART AND ONCE FOR THE ENTIRE RANGE.     *\n*        THIS HAS THE EFFECT THAT THE SECOND PART OF A RANGE MUST     *\n*        ALSO BE A VALID FIRST PART.                                  *\n*                                                                     *\n*        ONLY FIVE LEVELS OF KEYWORD NESTING ARE ALLOWED (SURELY THAT *\n*        IS ENOUGH).                                                  *\n*                                                                     *\n* DEBUGGING NOTE -                                                    *\n*        TO ENABLE A RUN-TIME TRACE BACK ON PROGRAM CHECK, REMOVE     *\n*        THE COMMENT INDICATOR FROM THE LIERRSET MACRO BELOW. THIS    *\n*        CANNOT BE USED WHEN CLUTSPAR IS INSTALLED AS IKJPARS, AS     *\n*        IT ISSUES THE SPIE MACRO, WHICH IS INVALID IN SOME CONTEXTS  *\n*        IN WHICH IKJPARS EXECUTES (E.G., CALLED FROM LOGON).         *\n*                                                                     *\n* COPYRIGHT -                                                         *\n*        1981, 1983 RICE UNIVERSITY                                   *\n***********************************************************************\n         EJECT\nTSUCOPRT CSECT\n         DC    C'TSU COPYRIGHT RICE UNIVERSITY 1981'\n         SPACE\nCLUTSPAR LISECT\nCLUZPAR  LIENTRY BASE=R11,ISASIZE=DSALEN+768,PARM=R2\n         EJECT\n*\n*        THIS ROUTINE IS A REPLACEMENT FOR THE TSO SERVICE ROUTINE\n*        IKJPARS. IT ACCEPTS THE SAME INPUT PARAMETERS AND RETURNS\n*        THE SAME OUTPUT TO ITS CALLER, BUT DIFFERS CONSIDERABLY\n*        IN THE STYLE OF ITS INTERACTION WITH THE TERMINAL USER.\n*        ITS MAIN VIRTUE IS ITS LIBERALITY, ACCEPTING PARAMETER FORMS\n*        NOT ALLOWED BY IKJPARS, AND ALLOWING THE USER TO CORRECT\n*        ERRORS IN MORE CASES.\n*\n         SPACE 3\n*\n*        INITIALIZE\n*\n         LR    R5,RDSA            SET UP PERM. DSA POINTER\n         DROP  RDSA\n         USING DSA,R5\n         LA    R4,4095(,R11)      SET UP SECOND BASE REG\n         USING CLUTSPAR+4095,R4\n         XC    IOPL(256),IOPL     CLEAR DSA\n         XC    IOPL+256(256),IOPL+256\n         XC    IOPL+512(256),IOPL+512\n         XC    IOPL+768(DSALEN-768-88),IOPL+768\n         MVC   IOPL(12),0(R2)     SAVE UPT, ECT & ECB ADDRS\n         MVC   PCL(12),12(R2)     SAVE PCL, ANSWER & CBUF PTRS\n         MVI   PCL,0              CLEAR HIGH ORDER PCL BYTE\n         MVC   UWA(4),24(R2)      SAVE USER WK AREA ADDR\n         LA    R10,SUBWORKS       NO SUBFIELD RECURSION YET\n         USING SUBWORK,R10\n         L     R9,PCL             FIND FIRST KEYWORD ADDR\n         LH    R2,4(,R9)\n         AR    R2,R9\n         ST    R2,KEY1            SAVE FOR LATER\n         L     R2,ANSPTR          FIND ANSWER POINTER\n         XC    0(4,R2),0(R2)      CLEAR OLD CONTENTS\n         LIBEL PARSTERM,ADDR=GIVEUP    ESTABLISH ERROR ESCAPE POINT\n         LH    R1,2(,R9)          GET SIZE OF ANSWER\n         MVC   PDLPTR,NULL        CLEAR PDL POINTER FOR TROUBLE\n         L     R15,=A(CLUZMINT)\n         BALR  R14,R15            CALL MEMORY INITIALIZATION ROUTINE\n         L     R3,PDLPTR          FIND PDL START\n         LA    R2,8(,R3)          CLEAR THE PDL (EXCEPT THE HEADER)\n         SR    R1,R1\n         LA    R14,256\n         LH    R15,2(,R9)\n         SH    R15,=H'9'\nINITCLR  BXH   R1,R14,INITLAST\n         XC    0(256,R2),0(R2)\n         AR    R2,R14\n         B     INITCLR\nINITLAST EX    R15,INITZERO\n         LH    R2,0(,R9)\n         AR    R2,R9              ADDRESS END OF PCL\n         LH    R3,4(,R9)\n         AR    R3,R9              ADDRESS FIRST KEYWORD OR FIELD END\n         LA    R9,6(,R9)          FIND ADDR OF FIRST PARM\n         ST    R9,PARM1           AND SAVE\n         L     R8,CBUF            CLEAR HIGH-ORDER BYTE OF CBUF\n         LA    R8,0(,R8)\n         ST    R8,CBUF\n         ST    R8,CURINP          SAVE AS CURRENT INPUT SOURCE\n         LR    R7,R8\n         AH    R8,2(,R8)          ADJUST SOURCE REG BY OFFSET\n         LA    R8,4(,R8)\n         AH    R7,0(,R7)\n         BCTR  R7,0               FIND END OF STRING\n         LA    R6,1               SET UP R6 & R7 FOR BXLE/BXH\n*        LIERRSET PARSERRX        TRACE & STOP AFTER PGM CHECK\n         SPACE\n*\n*        SCAN THE PCL FOR DSNAMES, USERIDS, OR PRINT BYPASS IDENTS.\n*        IF ANY ARE FOUND, SLASH MUST BE TREATED SPECIALLY.\n*\n         LR    R1,R9              START WITH 1ST PARM\n         MVI   SKIPF,NOSLASH      ASSUME SLASH IS JUST A CHARACTER\nINITSLSH MVC   ALIGN(1),0(R1)\n         NI    ALIGN,X'E0'        ISOLATE PCE TYPE\n         BZ    INITSLEN           BRANCH IF IKJSUBF/ENDP\n         CLI   ALIGN,X'80'        IKJIDENT?\n         BE    INITID             YES, CHECK FOR PTBYPS\n         CLI   ALIGN,X'20'        IKJPOSIT?\n         BNE   INITSLOP           NO.\n         CLI   6(R1),6            IS IT A USERID?\n         BL    INITSLOP           NO.\n         CLI   6(R1),8            MAYBE, CHECK FOR DSNAME OR DSTHING\n         AIF   ('&OPSYS' NE 'MVS').NMVS3B\n         BNH   INITHIDE           SOMETHING WITH A PASSWORD\n         CLI   6(R1),12           IS IT A UID2PSW?\n         BNE   INITSLOP           NO, PASS IT BY\n         AGO   .JMVS3B\n.NMVS3B  BH    INITSLOP           BRANCH IF NOT\n.JMVS3B  ANOP\nINITHIDE NI    SKIPF,255-NOSLASH  SLASH MUST BE SPECIAL\n         B     SYN\nINITID   TM    1(R1),X'04'        IS THIS REALLY AN IKJEXTEN?\n         BNZ   INITSLOP           YES, CAN'T BE BYPASS\n         TM    6(R1),X'20'        IS THIS IDENT BYPASS?\n         BNZ   INITHIDE           YES, SLASH MUST BE FACED\nINITSLOP MVC   ALIGN,2(R1)        FIND NEXT PCE\n         AH    R1,ALIGN\n         B     INITSLSH           AND CONTINUE\n*\n*        THE ACCOUNT COMMAND IS VERY CLEVER AND STICKS END OF FIELD\n*        INDICATORS INTO THE MIDDLE OF A LIST OF IKJPOSIT PCE'S. WE\n*        HAVE TO USE THE FIRST KEYWORD POINTER IN THE IKJPARM/IKJSUBF\n*        EXPANSION TO FIND OUR WAY ONWARD TO THE TRUE FIELD END.\n*\nINITSLEN CR    R1,R3              IS THIS AT OR PAST THE FIRST KEYWORD?\n         BNL   INITNORM           YES, PROCEED NORMALLY\n         LR    R1,R3              NO, SKIP TO FIRST KEYWORD\n         B     INITSLSH           AND PROCEED FROM THERE\nINITNORM AR    R1,R6\n         CR    R1,R2              REACHED THE END?\n         BNL   SYN                YES, GO TO IT\n         MVC   ALIGN,0(R1)        NO, FIND NEXT KEYWORD OFFSET\n         LH    R3,ALIGN\n         A     R3,PARM1           POINT TO IT\n         SH    R3,=H'6'           AFTER ADJUSTMENTS\n         LA    R1,2(,R1)          SKIP INTO SUBFIELD\n         B     INITSLSH\nINITZERO XC    0(0,R2),0(R2)      CLEAR PDL\n         SPACE\n         LTORG\n         TITLE 'CLUTSPAR -- POSITIONAL PARAMETER HANDLING'\n*\n*        THIS CODE IS ENTERED TO PARSE AN ENTIRE COMMAND LINE.\n*        IT IS ALSO CALLED RECURSIVELY TO PROCESS A KEYWORD SUBFIELD\n*        OR VARIABLE SUBSCRIPT.\n*\nSYN      XC    COMMAX,COMMAX      NOTICE A LEADING COMMA\n         SPACE\n*\n*        SCAN THE PCE'S\n*\nSYNLOOP  NI    SKIPF,NOSLASH      CLEAR SKIP FLAGS\n         MVI   LISTF,0            NOT A LIST YET\n         MVC   ALIGN(1),0(R9)     ISOLATE TYPE FLAGS\n         NI    ALIGN,X'E4'\n         BZ    SYNPEND            IF IKJENDP/IKJSUBF FOUND\n         CLI   ALIGN,X'40'\n         BL    SYNPOS             IF IKJPOSIT\n         BE    SYNKEY             IF IKJKEYWD\n         CLI   ALIGN,X'80'        CHECK FOR IKJIDENT\n         BNE   SYNPOS2\n         MVC   PCBYPASS,6(R9)     SET BYPASS FLAG IF NECESSARY\n         NI    PCBYPASS,X'20'\n         B     SYNPOS2            SKIP POSITIONAL CODE\n         SPACE\n*\n*        PROCESS POSITIONAL\n*\nSYNPOS   CLI   6(R9),10           SPACE TYPE?\n         BNE   SYNNSPAC           NO.\n         OI    SKIPF,NOSKIP       YES, INHIBIT FULL SKIP\nSYNDLMIS MVI   DELIM,X'FF'        SET MISSING DELIM JUST IN CASE\n         B     SYNPOS2\nSYNNSPAC CLI   6(R9),2            DELIM OR STRING?\n         BE    SYNTEXT            STRING, DON'T SKIP AT ALL\n         BL    SYNDLMIS           DELIM, SET MISSING IN ADVANCE\n         MVI   DELIM,0            NEITHER, RESET DELIMITER\n         SPACE\n*\n*        SKIP SEPARATORS BEFORE POSITIONAL\n*\nSYNPOS2  L     R15,=A(CLUZSKIP)\n         BALR  R14,R15            SKIP BLANKS, TABS, COMMAS ETC.\n         B     *+4(R15)           ANYTHING AFTER?\n         B     SYNTEXT            YES.\n         TM    COBFLAGS,COBSUB    NO, IN SUBSCRIPT LIST?\n         BNZ   SYNOSUBS           YES.\n         TM    OPERFLGS,OPERACT   NO, IN EXPRESSION MODE?\n         BNZ   EXPROMIT           YES, ESCAPE TO EXPRESSION ROUTINE\n         B     SYNORMIT           NO, HANDLE NORMAL OMISSION\n         SPACE\n*\n*        CALL RECOGNITION ROUTINE\n*\nSYNTEXT  TM    COBFLAGS,COBSUB    SUBSCRIPT PROCESSING?\n         BNZ   SYNNEST            YES, NESTING ALREADY SET\n         TM    OPERFLGS,OPERACT   NO, WITHIN EXPRESSION?\n         BNZ   SYNNEST            YES.\n         MVI   NESTLEVL,LEVITEM   NO, SET ITEM NESTING LEVEL\n         ST    R9,OWNERID         DEFINE PCE AS MEMORY OWNER\nSYNNEST  SR    R2,R2              DETERMINE TYPE AGAIN\n         IC    R2,0(,R9)\n         SRL   R2,5\n         SLL   R2,2\n         B     *+4(R2)\n         BAL   R6,PARSRC12        NOT POSSIBLE HERE\n         B     SYNPOSIT           IKJPOSIT\n         BAL   R6,PARSRC12\n         BAL   R6,PARSRC12\n         B     SYNID              IKJIDENT\n         B     SYNWORD            IKJRSVWD\n         B     SYNTERM            IKJTERM\n         B     SYNOPER            IKJOPER\n         SPACE\nSYNPOSIT SR    R15,R15\n         IC    R15,6(,R9)         GET TYPE OF IKJPOSIT\n         SLL   R15,2\n         L     R15,RECOGS-4(R15)  SELECT RECOGNIZER\n         B     SYNREC             JOIN OTHER CASES\nSYNWORD  L     R15,=A(CLUZWORD)   RESERVED WORD RECOGNIZER\n         B     SYNREC\nSYNOPER  L     R15,=A(CLUZOPER)   OPER START ROUTINE\n         B     SYNREC\nSYNTERM  TM    6(R9),X'08'        IS THIS A SUBSCRIPT TERM?\n         BZ    SYNTNSUB           NO.\n         TM    COBFLAGS,COBSUB    YES, ARE WE IN SUBSCRIPT MODE?\n         BZ    SYNNEXT            NO, JUST SKIP IT\nSYNTNSUB L     R15,=A(CLUZCNST)   ASSUME CONSTANT TERM\n         TM    6(R9),X'20'\n         BNZ   SYNREC             GO ON WHEN WE GET IT RIGHT\n         L     R15,=A(CLUZSTMT)   NEXT TRY STMT\n         TM    6(R9),X'80'\n         BNZ   SYNREC\n         L     R15,=A(CLUZCVAR)   ELSE VAR OR ANY\n         B     SYNREC\nSYNID    TM    1(R9),X'04'        REALLY IKJEXTEN?\n         BNZ   SYNEXTN            YES.\n         L     R15,=A(CLUZIDEN)   IKJIDENT RECOGNIZER\n         B     SYNREC\nSYNEXTN  L     R15,=A(CLUZEXTN)   USER EXTENSION INTERFACE\n         SPACE\nSYNREC   OC    BYPASS,PCBYPASS    FORCE SUPPRESSION OF BYPASS PARM\n         NI    COBFLAGS,COBSUB\n         BNZ   SYNSBPDE           BRANCH IF SUBSCRIPT\n         MVI   COBFLGS1,0\n         MVC   ALIGN,4(R9)        FIND PDL OFFSET\n         LH    R1,ALIGN\n         A     R1,PDLPTR          ADDRESS PDE\n         TM    1(R9),X'80'        LIST POSSIBLE?\n         BO    LIST               YES.\n         MVI   SUBFD1,0           NO, TURN OFF SUBFIELD/LIST SWITCH\n         MVI   RANGEF,0           RESET RANGE FLAGS\n         B     SYNRECG\nSYNSBPDE L     R1,SUBSPDE         FIND PDE FOR THIS SUBSCRIPT\n         SPACE\nSYNRECG  LR    R3,R15             SAVE RECOGNIZER ENTRY\n         ST    R8,PREVPOS         SAVE STARTING POINT FOR SCAN\n         MVI   PASSF,0            TURN OFF PASSWORD FLAGS\n         BALR  R14,R15            CALL RECOGNIZER\n         TM    COBFLAGS,COBSUB    HANDLING SUBSCRIPT?\n         BNZ   SYNRET(R15)        YES, SKIP OPER CHECK\n         TM    OPERFLGS,OPERACT   WITHIN AN EXPRESSION?\n         BNZ   EXPRRET(R15)       YES, ENTER EXPRESSION ROUTINE\n         B     *+4(R15)           WAS THIS PARM FOUND?\nSYNRET   B     SYNOK1             YES.\n         B     SYNOMIT            NO, IT IS MISSING\n         B     SYNINV             YES, BUT IT IS INVALID\n         BAL   R6,PARSRC12        SHOULD NOT OCCUR HERE\n         B     SYNCORCT           PROMPTING FOR TERM SUCCESSFUL\n         B     SYNBAD             PROMPTING FOR TERM UNSUCCESSFUL\n         SPACE\n*\n*        CHECK FOR SUBSCRIPTS IF REQUESTED BY RECOGNIZER\n*\nSYNOK1   TM    COBFLAGS,COBSUBOK  MAY THERE BE A SUBSCRIPT?\n         BZ    SYNNOSUB           NO.\nSYNSUBS  BAL   R14,SUBSIN         YES, CALL SUBSCRIPT ROUTINE TO CHECK\n         SPACE\n*\n*        GET A PASSWORD IF REQUESTED BY RECOGNIZER\n*\nSYNNOSUB TM    PASSF,PASSABLE     MAY THIS PARM HAVE A PASSWORD?\n         BZ    SYNVEX             NO.\n         L     R2,PASSPDE         YES, ADDR PASSWORD PDE PART\n         BAL   R14,PASS           PROCESS PASSWORD\n         SPACE\n*\n*        INTERFACE TO VALIDITY CHECK EXIT\n*\nSYNVEX   BAL   R14,VEX            INTERFACE TO VALIDITY CHECK EXIT\n         B     *+4(R15)           WHAT HAPPENED?\n         B     SYNVAL             EVERYTHING'S OK\n         B     SYNCORCT           REPLACEMENT DATA ENTERED\n         B     SYNMISS            UNABLE TO FIX IT UP\n         LR    R2,R1              SUBSCRIPT REQUIRED, STACK (\n         MVC   ALIGN,=H'1'\n         LA    R1,=C'('\n         OI    INSFLAG,DUMMYSUB   SHOW PUSHING DUMMY SUBSCRIPT\n         L     R15,=A(CLUZPUSH)\n         BALR  R14,R15\n         LR    R1,R2              RESTORE R1\n         OI    COBFLAGS,COBIMMSB  SHOW SUBSCRIPT NEARBY\n         B     SYNSUBS            GO GET SOME SUBSCRIPTS\n         SPACE\nSYNMISS  OI    RANGEF,RANGE1NV    NOTE PROMPT FAILURE\n         SPACE\n*\n*        CHECK FOR & HANDLE THE SECOND PART OF A RANGE\n*\nSYNVAL   TM    1(R9),X'20'        RANGE PERMITTED?\n         BZ    SYNOK              NO.\n         BAL   R14,RANG           YES, LOOK FOR SECOND PART\n         B     *+4(R15)           WHAT HAPPENED?\n         B     SYNOK              ALL IS WELL\n         B     SYNRETRY           REPLACEMENT DATA PROVIDED\n*                                 ELSE PROMPT FAILURE\n         SPACE\n*\n*        SKIP TO NEXT PCE\n*\nSYNOK    XC    OMIT1,OMIT1        CLEAR BACKUP POINT\n         MVI   PCBYPASS,X'00'     RESET PCE BYPASS FLAG\n         MVI   BYPASS,0\n         TM    COBFLAGS,COBSUB    IN SUBSCRIPT MODE?\n         BNZ   SYNOKSUB           YES, SPECIAL CASE\n         TM    DEFTF,DEFTPOS      WAS THIS A DEFAULT VALUE?\n         BNZ   DEFTRET            YES, RETURN TO DEFAULT ROUTINE\nSYNACPT  MVI   NESTLEVL,0         CANCEL ALL NESTING\n         TM    ALCFLAGS,ACPTREQ   IS ACCEPT REQUIRED?\n         BZ    SYNNEXT            NO.\n         L     R15,=A(CLUZACPT)\n         BALR  R14,R15            YES, TELL MEMORY MANAGER TO ACCEPT\nSYNNEXT  BAL   R14,FNXT           FIND THE NEXT PCE\n         LR    R9,R1              COPY TO USUAL REGISTER\n         B     SYNLOOP\n         SPACE\n*\n*        HANDLE OMITTED POSITIONAL\n*\nSYNOMIT  TM    COBFLAGS,COBSUB    IN A SUBSCRIPT LIST?\n         BNZ   SYNOSUBS           YES, HANDLE SUBSCRIPT OMISSION\nSYNORMIT TM    0(R9),X'10'        IS THIS REQUIRED?\n         BNZ   SYNRQR             YES.\n         OC    OMIT1,OMIT1        NO, IS THIS THE FIRST MISSING?\n         BNZ   SYNNEXT            NO.\n         ST    R9,OMIT1           YES, SET BACKUP POINT\n         B     SYNNEXT\n         SPACE\n*\n*        HANDLE PROMPT\n*\nSYNRQR   CR    R8,R7              ANYTHING LEFT TO REJECT?\n         BNH   SYNFINV            YES, REJECT IT\nSYNNOMIT BAL   R14,FDEF           NO, FIND THE PROMPT STRING\n         L     R15,=A(CLUZREQR)\n         BALR  R14,R15            FORCE ENTRY\n         B     *+4(R15)           HOW DID IT GO?\n         B     SYNRETRY           GREAT, TRY AGAIN\n         B     SYNOK              COULDN'T PROMPT, SKIP TO NEXT\n         SPACE\n*\n*        DECIDE WHAT TO REJECT FOR MISSING REQUIRED POSITIONAL\n*\nSYNFINV  CLI   0(R8),C')'         DOES A ) FOLLOW?\n         BNE   SYNITEM            NO, FIND ITEM TO REJECT\n         CLI   SUBFLAG,0          YES, ARE WE IN A SUBFIELD?\n         BNE   SYNNOMIT           YES, NO REJECT, JUST PROMPT\nSYNITEM  L     R15,=A(CLUZITEM)\n         BALR  R14,R15            FIND TEXT TO REJECT\n         C     R3,RECOGS+4        INVALID STRING?\n         BNE   SYNINV             NO.\n         CLI   DELIM,X'FF'        YES, WAS DELIMITER MISSING?\n         BNE   SYNINV             NO.\n         MVI   DELIM,0\n         MVC   VMSG,=A(NODELIM)   YES, GIVE CLARIFYING LEVEL2 MSG\n         SPACE\n*\n*        HANDLE INVALID POSITIONAL\n*\nSYNINV   BAL   R14,INV            GIVE INVALID/REENTER\n         MVI   BYPASS,X'00'       RESET BYPASS FLAG\n         B     *+4(R15)           WAS THE PROMPT OK?\n         B     SYNCORCT           YES, TRY AGAIN\n*                                 NO, JUST FORGET THIS\n         SPACE\n*\n*        IF A PASSWORD OR SUBSCRIPT WAS POSSIBLE FOR AN UNCORRECTED\n*        INVALID PARAMETER, CHECK FOR IT TO AVOID MISTAKING IT FOR\n*        SOMETHING ELSE.\n*\n         TM    PASSF,PASSABLE     PASSWORD PERMITTED?\n         BZ    SYNMISS            NO.\n         TM    PASSF,PASSCAN      YES, ALREADY SCANNED FOR IT?\n         BNZ   SYNMISS            YES.\n         L     R2,PASSPDE         NO, FIND PASSWORD PDE\n         MVI   LEFTOVER,X'FF'     SET PASSWORD FOR INVALID PARM FLAG\n         BAL   R14,PASS           CHECK FOR A PASSWORD\n         B     SYNPAST\nSYNBAD   TM    COBFLAGS,COBSUBOK  SUBSCRIPT POSSIBLE HERE?\n         BZ    SYNMISS            NO.\n         MVI   LEFTOVER,X'FF'     YES, SET LEFTOVERS FLAG\n         BAL   R14,SUBSIN         CHECK FOR DANGLING SUBSCRIPT\nSYNPAST  MVI   LEFTOVER,0         RESET LEFTOVER PASSWORD FLAG\n         B     SYNMISS            NOW TREAT AS MISSING\n         SPACE\nSYNCORCT TM    COBFLAGS,COBSUB    WORKING ON SUBSCRIPT?\n         BNZ   SYNCLSUB           YES.\n         LR    R2,R1              NO, SAVE PDE ADDRESS\n         BAL   R14,SIZE           GET SIZE OF PDE\n         BCTR  R1,0\n         EX    R1,SYNCLR          CLEAR OUT THE PDL\n         B     SYNRETRY\nSYNCLSUB XC    0(19,R1),0(R1)     CLEAR OUT SUBSCRIPT PDE\n         SPACE\nSYNRETRY OC    OMIT1(4),OMIT1     ANY PREVIOUS ADJACENT PARMS OMITTED?\n         BZ    SYNPOS2            NO.\n         L     R9,OMIT1           YES, BACKUP TO 1ST TO RETRY\n         MVC   OPERPART,OMITPART  RESTORE PREVIOUS EXPRESSION PART\n         TM    OPERFLGS,OPERACT+OPEREXPR    HANDLING A LEVEL 88 ITEM?\n         BNM   SYNPOS2            NO, LEAVE OPERFLGS ALONE\n         TM    COBFLAGS,COBSUB    YES, IN A SUBSCRIPT?\n         BNZ   SYNPOS2            YES, JUST PROCEED\n         MVI   OPERFLGS,0         NO, LEAVE EXPRESSION MODE\n         B     SYNPOS2\nSYNCLR   XC    0(0,R2),0(R2)      CLEAR THE PDE FOR BAD PARM\n         SPACE\n*\n*        HANDLE A VALID SUBSCRIPT. IF THIS IS THE THIRD ONE, GO TO\n*        IGNORE ANY FURTHER ONES. IF NOT, GO PROCESS ANOTHER.\n*\nSYNOKSUB SR    R14,R14\n         IC    R14,SUBSNO         GET NUMBER OF SUBSCRIPTS\n         LA    R14,1(,R14)        INCREASE BY 1\n         STC   R14,SUBSNO         STORE BACK\n         CLI   SUBSNO,3           REACHED THE MAX?\n         BE    SYNPEND            YES, EXIT\n         L     R14,SUBSPDE        NO, BUMP THE PDE POINTER\n         LA    R14,20(,R14)       BY 1 SUBSCRIPT\n         ST    R14,SUBSPDE\n         B     SYNPOS2            AND GO AGAIN\n         SPACE\n*\n*        A SUBSCRIPT SEEMS TO BE MISSING. REJECT WHATEVER IS THERE, OR\n*        PROMPT FOR ONE, IF NOTHING IS PRESENT.\n*\nSYNOSUBS CR    R8,R7              ANY TEXT LEFT?\n         BH    SYNSBOUT           NO.\n         CLI   0(R8),C')'         YES, HAVE WE A CLOSE PAREN?\n         BNE   SYNITEM            NO, REJECT WHATEVER WE HAVE\nSYNSBOUT CLI   SUBSNO,0           HAVE WE HAD ANY SUBSCRIPTS?\n         BNE   SUBSOUT            YES, SUBSCRIPTS FINISHED\n         L     R15,=A(CLUZRQSB)\n         BALR  R14,R15            NO, CALL REQUIRE-SUBSCRIPT ROUTINE\n         B     *+4(R15)           WAS IT CORRECTED?\n         B     SYNPOS2            YES, TRY AGAIN\n         B     SYNOKSUB           NO, JUST PUSH ON\n         TITLE 'CLUTSPAR -- COBOL EXPRESSION HANDLING'\n*\n*        THIS CODE CONTROLS THE RECOGNITION AND VALIDATION OF SUBPARTS\n*        OF A COBOL EXPRESSION. IT IS ENTERED UPON RETURN FROM THE\n*        RECOGNIZER FOR A SUBPART, AS PROCESSING IS NORMAL UP TO THAT\n*        POINT.\n*\nEXPRRET  B     EXPROK1            SUBPART RECOGNIZED\n         B     EXPROMIT           SUBPART OMITTED\n         B     EXPRINV            SUBPART INVALID\n         B     SYNPOS2            GO PROCESS 1ST OPER SUBPART\n         B     SYNRETRY           BACK UP & RETRY\n         B     EXPRBAD            RECOGNIZER PROMPTING FAILED\n         SPACE\n*\n*        SEE IF A SUBSCRIPT IS ALLOWED FOR THIS ITEM. IF SO, GO CHECK\n*        FOR ONE.\n*\nEXPROK1  TM    COBFLAGS,COBSUBOK  COULD A SUBSCRIPT APPEAR?\n         BZ    EXPRVEX            NO, GO VALIDATE\nEXPRQSUB BAL   R14,SUBSIN         SEE IF SUBSCRIPT IS THERE\n         SPACE\n*\n*        INTERFACE TO THE USER'S VALIDITY CHECK ROUTINE. IF THE\n*        EXIT INDICATES THAT A SUBSCRIPT IS REQUIRED, IT MAY BE\n*        SUFFICENT TO CALL THE SUBSCRIPT ROUTINE AGAIN, IF AN\n*        AMBIGUOUS PARENTHESIS WAS FOUND NEAR THE VARIABLE.\n*\nEXPRVEX  BAL   R14,VEX            CALL VALIDATION ROUTINE\n         MVI   RANGEF,0           MAKE SURE RANGE2 INDICATOR IS OFF\n         B     *+4(R15)           WHAT HAPPENED?\n         B     EXPROK             NO TROUBLE\n         B     EXPRCRCT           NEW DATA OBTAINED, RE-RECOGNIZE\n         B     EXPRMISS           PROMPT FAILED\n         TM    COBFLAGS,COBSUB88  SUBSCRIPT NEEDED. ONE NEARBY?\n         BNZ   EXPRQSUB           YES, GO GET IT\n         LR    R2,R1\n         MVC   ALIGN,=H'1'        NO, FORCE ONE TO BE ENTERED\n         LA    R1,=C'('\n         OI    INSFLAG,DUMMYSUB   SHOW STACKING DUMMY SUBSCRIPTS\n         L     R15,=A(CLUZPUSH)   BY STACKING AN EMPTY LIST\n         BALR  R14,R15\n         LR    R1,R2\n         OI    COBFLAGS,COBIMMSB  PROMISE IMMEDIATE SATISFACTION\n         B     EXPRQSUB\n         SPACE\n*\n*        IF WE ARE HANDLING A DEFAULT SUBPART, MAKE SURE NO INFO\n*        IS LEFT OVER FROM THE DEFAULT.\n*\nEXPROK   TM    DEFTF,DEFTOPER     DEFAULTING SUBPARTS?\n         BZ    EXPRNORM           NO.\n         L     R15,=A(CLUZSKIP)   YES, SET UP TO SKIP BLANKS\n         BALR  R14,R15\n         LTR   R15,R15            ANYTHING LEFT?\n         BNZ   EXPRPOPD           NO, EVERYTHING'S COOL\n         BAL   R6,PARSRC12        YES, INDICATE PARM LIST ERROR\nEXPRPOPD L     R15,=A(CLUZPOPS)\n         BALR  R14,R15            REMOVE DEFAULT FROM STACK\n         B     EXPRGOON           JOIN NON-DEFAULT CASE\n         SPACE\n*\n*        KEEP TRACK OF THE FIRST AND LAST TOKENS FOUND IN THE\n*        EXPRESSION IN CASE IT IS NEEDED FOR A LATER MESSAGE. THIS\n*        INFORMATION IS STORED AS IF IT APPLIED TO THE SECOND HALF\n*        OF A RANGE.\n*\nEXPRNORM CLI   OPERPART,8         HANDLING THE WHOLE EXPRESSION?\n         BE    EXPRGOON           YES, SKIP THIS\n         OC    COBHEAD2,COBHEAD2  HAD WE ANYTHING BEFORE?\n         BNZ   EXPR2              YES.\n         TM    COBFLGS1,COBOLVAR  NO, IS WHAT WE HAVE A VARIABLE?\n         BZ    EXPR1NVR           NO.\n         MVC   COBHEAD2(8),COBHEAD1    YES, SAVE INFO\n         NI    COBFLGS2,255-COBHBYP    COPY HEAD BYPASS FLAG OVER\n         MVI   ALIGN,COBHBYP\n         NC    ALIGN(1),COBFLGS1\n         OC    COBFLGS2,ALIGN\n         TM    COBFLGS1,COBQVAR   IS THERE A TAIL TO THIS ONE?\n         BZ    EXPRTSUB           NO.\nEXPR2QVR MVC   COBTAIL2(8),COBTAIL1    YES, PRESERVE IT\nEXPRTAIL OI    COBFLGS2,COBQVAR   INDICATE TAIL THERE\n         NI    COBFLGS2,255-COBTBYP    COPY TAIL BYPASS FLAG OVER\n         MVI   ALIGN,COBTBYP\n         NC    ALIGN(1),COBFLGS1\n         OC    COBFLGS2,ALIGN\nEXPRTSUB NI    COBFLGS2,255-COBHASUB   COPY SUBSCRIPT EXISTENCE FLAG\n         MVI   ALIGN,COBHASUB\n         NC    ALIGN(1),COBFLGS1\n         OC    COBFLGS2,ALIGN\n         B     EXPRGOON\nEXPR1NVR MVC   COBHEAD2,PREVPOS   GET START & END FOR NON-VAR\n         ST    R8,COBHEAD2+4\n         CLI   BYPASS,0           WAS IT HIDDEN?\n         BE    EXPRGOON           NO.\n         OI    COBFLGS2,COBHBYP   YES, SET HEAD BYPASS\n         B     EXPRGOON\n         SPACE\nEXPR2    OI    COBFLGS2,COBQVAR   EXPR MUST NOW BE CONSIDERED          *\n                                  QUALIFIED\n         TM    COBFLGS1,COBOLVAR  IS THIS PART A VARIABLE?\n         BZ    EXPR2NVR           NO.\n         TM    COBFLGS1,COBQVAR   YES, QUALIFIED?\n         BNZ   EXPR2QVR           YES, ITS TAIL IS OUR TAIL\n         MVC   COBTAIL2(8),COBHEAD1    NO, ITS HEAD IS OUR TAIL\n         B     EXPRTSUB           GO HANDLE SUBSCRIPTS\nEXPR2NVR MVC   COBTAIL2,PREVPOS   START START & END OF NON-VAR\n         ST    R8,COBTAIL2+4\n         NI    COBFLGS2,255-COBHASUB   RESET SUBSCRIPT INDICATOR\n         CLI   BYPASS,0           SUPPRESSION NEEDED?\n         BE    EXPR2NBY           NO.\n         OI    COBFLGS2,COBTBYP   YES, SET FLAG\n         B     EXPRGOON\nEXPR2NBY NI    COBFLGS2,255-COBTBYP    MAKE SURE TAIL CAN BE SEEN\n         SPACE\n*\n*        FIND THE NEXT SUBPART TO BE PROCESSED.\n*\nEXPRGOON XC    OMIT1,OMIT1        RESET OMISSION STUFF\n         MVI   OMITPART,0\n         MVI   BYPASS,0           FORGET PREVIOUS SUPPRESSION\n         SR    R14,R14\n         TM    DEFTF,DEFTOPER     APPLYING DEFAULTS?\n         BNZ   EXPRNEXT           YES, SET NO PRESENCE FLAG\n         LA    R14,1              CAUSE SUBPART PRESENCE TO SHOW\nEXPRNEXT SR    R15,R15\n         IC    R15,OPERPART       FIND THE PART NUMBER\n         SLL   R14,0(R15)         GET THE BIT TO SET\n         EX    R14,EXPRSET        SET BIT IF PART PRESENT (NOT DEFAULT)\n         SLL   R15,1              FOR BETTER BRANCHING\n         B     *+4(R15)           DECIDE WHAT NOW\nEXPRVEC  B     EXPRATOR           OPERATOR DONE\n         B     EXPRAND1           OPERAND1 DONE\n         B     EXPRAND2           OPERAND2 DONE, LOOK FOR EXTRANIA\n         B     EXPR88             CHAINED TERM DONE\n         B     EXPRFULL           FULL EXPRESSION COMPLETE\n         SPACE\n*\n*        IF THE FIRST OPERAND OR THE OPERATOR IS DONE WITH, JUST\n*        PROCEED TO THE NEXT PART IN LINE.\n*\nEXPRAND1 MVI   OPERPART,0         NUMBER OF OPERATOR\nEXPRCONT TM    DEFTF,DEFTOPER     DEFAULTING NOW?\n         BZ    SYNNEXT            NO, GO ON\n         B     EXPRDNXT           YES, RETURN TO DEFAULTER\n         SPACE\nEXPRATOR MVI   OPERPART,4         SET OPERAND2 PART NO\n         B     EXPRCONT\n         SPACE\n*\n*        A LEVEL 88 ITEM HAS BEEN FINISHED WITH. IF IT WAS INDEED\n*        PRESENT, GO TO VALIDATE IT CONSIDERED AS A FULL EXPRESSION.\n*\nEXPR88   TM    OPERPRES,X'40'     DID USER SUPPLY IT?\n         BZ    EXPRNO88           NO.\nEXPRFIN  NI    DEFTF,255-DEFTOPER YES, MAKE SURE NOT DEFAULTING\n         L     R9,OPERPCE         FIND THE SOURCE\n         OI    COBFLAGS,COBFORM   PREPARE FOR FAILURE\n         MVC   ALIGN,4(R9)        LOCATE ORIGINAL PDE\n         LH    R1,ALIGN\n         A     R1,PDLPTR\n         OI    6(R1),X'80'        INDICATE PRESENCE\n         MVI   OPERPART,8         INDICATE VALIDATING WHOLE THING\n         TM    OPERFLGS,OPERFAIL  PROMPT ALREADY FAILED?\n         BNZ   EXPROK             YES, SKIP VALIDATE\n         OI    RANGEF,RANGE2      USE SECOND PART STUFF IN ERROR MSG\n         MVI   NESTLEVL,LEVRANGE  SET NESTING LEVEL TO \"RANGE\"\n         B     EXPRVEX            VALIDATE THE WHOLE EXPRESSION\n         SPACE\n*\n*        IF AN EXPECTED CHAINED TERM WAS NOT FOUND, DEFAULT IT IF\n*        POSSIBLE. IF NOT, TREAT IT AND THE EXPRESSION AS NORMAL\n*        OMITTED ITEMS.\n*\nEXPRNO88 TM    0(R9),X'08'        DOES IT HAVE A DEFAULT?\n         BNZ   EXPRDEFT           YES, USE IT\n         MVI   OPERFLGS,0         NO, LEAVE OPER MODE\n         L     R9,OMIT1           FIND PCE OF BACKUP POINT\n         B     SYNNEXT            AND BE OFF\n         SPACE\n*\n*        COME HERE TO USE THE DEFAULT VALUE FOR AN IKJOPER SUBPART.\n*\nEXPRDEFT OI    DEFTF,DEFTOPER+DEFTINS  INDICATE OPER DEFAULT MODE\n         BAL   R14,FDEF           FIND THE DEFAULT\n         BAL   R14,INS            STACK IT\n         XC    OMIT1(4),OMIT1     MAKE SURE NO BACKUP\n         B     SYNPOS2            AND GO TRY THE DEFAULT\n         SPACE\n*\n*        THE FULL EXPRESSION HAS BEEN HANDLED. SET UP TO RESUME WITH\n*        THE NEXT PCE NOT WITHIN THE EXPRESSION, AND RETURN TO NORMAL\n*        PROCESSING.\n*\nEXPRFULL TM    DEFTF,DEFTPOS      WAS THE WHOLE EXPR DEFAULTED?\n         BNZ   DEFTRET            YES, RETURN TO DEFAULTER\n         L     R15,OPEROFFS       FIND THE LIST OF OFFSETS\n         XC    ALIGN,ALIGN\n         OC    ALIGN,6(R15)       WAS LEVEL 88 ALLOWED?\n         BNZ   EXPRF88            YES.\n         MVC   ALIGN,4(R15)       NO, OPERAND2 ENDS THE EXPR\nEXPRF88  LH    R9,ALIGN\n         A     R9,PCL             FIND LAST PCE OF EXPRESSION\n         MVI   OPERFLGS,0         LEAVE OPER MODE BEHIND\n         B     SYNACPT            ON TO NEXT REAL ITEM\n         SPACE\n*\n*        AFTER THE SECOND OPERAND HAS BEEN HANDLED, CHECK FOR OMITTED\n*        SUBPARTS WITH DEFAULTS. IF ANY ARE FOUND, APPLY THE DEFAULT\n*        VALUES.\n*\nEXPRAND2 TM    DEFTF,DEFTOPER     WERE WE DEFAULTING?\n         BZ    SYNPEND            NO, LOOK FOR CLOSE PAREN             *\n                                  (AND RETURN TO EXPROVER)\n         OI    OPERFLGS,OPERINV   YES, SET FLAG FOR VALIDATION ERROR\n         CR    R8,R7              IS CLOSE PAREN STILL LEFT?\n         BH    EXPRFIN            NO.\n         OI    OPERFLGS,OPERCLS   YES, ADD PAREN TO MSGS\n         AR    R8,R6              SKIP OVER THE PARENTHESIS\n         B     EXPRFIN            GO TO FINISH WHOLE OPER\nEXPROVER MVI   OPERPART,2         CHECK OPERAND1 FOR DEFAULT\n         OI    DEFTF,DEFTOPER     NOTE DEFAULT PROCESS BEGUN\n         SPACE\n*\n*        HANDLE THE NEXT PART TO BE DEFAULTED.\n*\nEXPRDNXT L     R1,OPEROFFS        FIND THE SUBPART OFFSETS\n         SR    R9,R9\n         IC    R9,OPERPART\n         LA    R14,1\n         SLL   R14,0(R9)          FIND WHICH BIT TO TEST\n         LA    R15,0(R9,R9)       DOUBLE SUBPART NUMBER\n         LH    R9,0(R1,R9)\n         A     R9,PCL             FIND PCE FOR NEXT PART\n         EX    R14,EXPRTEST       WAS THIS PART ENTERED?\n         BNZ   EXPRVEC(R15)       IF PRESENT, PROCEED TO THE NEXT\n         TM    0(R9),X'08'        HAS THIS PART A DEFAULT?\n         BNZ   EXPRDEFT           YES, GO TO TRY IT OUT\n         BAL   R6,PARSRC12        NO, A MIRACLE HAS OCCURRED\n         SPACE\n*\n*        WHEN WE GET HERE, A PART HAS BEEN OMITTED. IF IT HAS A\n*        DEFAULT, ALLOW THE OMISSION FOR NOW. OTHERWISE, PROMPT\n*        FOR THE PART.\n*\nEXPROMIT TM    0(R9),X'08'        HAS THIS PART A DEFAULT?\n         BZ    EXPRNVAL           NO, MUST BE GOTTEN\n         SR    R14,R14            YES, SET NO PRESENCE BIT\n         TM    DEFTF,DEFTOPER     WERE WE DEFAULTING?\n         BZ    EXPROKOM           NO, ALLOW OMISSION\n         BAL   R6,PARSRC12        YES, CALLER HAS BLOWN IT\nEXPROKOM OC    OMIT1,OMIT1        IS THIS THE FIRST OMISSION?\n         BNZ   EXPRNEXT           NO.\n         ST    R9,OMIT1           YES, STORE BACKUP POINT\n         MVC   OMITPART,OPERPART  SAVE PART NUMBER\n         B     EXPRNEXT           AND TRY THE NEXT PART\n         SPACE\n*\n*        THIS PART MUST BE REQUIRED. IF A PROMPT IS SUPPLIED, USE IT.\n*        OTHERWISE, PROMPT FOR IT BY FUNCTION, AS IN\n*        \"ENTER FIRST OPERAND\".\n*\nEXPRNVAL TM    OPERFLGS,OPEREXPR  LEVEL 88 PART MISSING?\n         BNZ   EXPRRQR            NO.\n         TM    0(R9),X'10'        YES, IS IT REQUIRED?\n         BZ    EXPROKOM           NO, JUST LET IT PASS\n         CR    R8,R7              YES, IS ANYTHING LEFT?\n         BNH   EXPRITEM           YES, REJECT SOMETHING\n         B     EXPROMPT           NO, ISSUE FORMAL PROMPT\n         SPACE\nEXPRRQR  CR    R8,R7              ANYTHING LEFT TO REJECT?\n         BNH   EXPRFINV           YES, REJECT IT.\nEXPRFRCE TM    0(R9),X'10'        NO, IS THIS FORMALLY REQUIRED?\n         BZ    EXPRINC            NO, GIVE INCOMPLETE MESSAGE\nEXPROMPT BAL   R14,FDEF           FIND THE PROMPT STRING\n         L     R15,=A(CLUZREQR)\n         BALR  R14,R15            REQUEST NEW DATA\nEXPRQRET B     *+4(R15)           DID WE GET IT?\n         B     SYNRETRY           YES, TRY AGAIN\n         SPACE\n*\n*        IF A SUBSCRIPT IS POSSIBLE FOR A PERMANENTLY INVALID TERM,\n*        CHECK FOR ONE TO AVOID MISTAKING IT FOR SOMETHING ELSE.\n*\nEXPRBAD  TM    COBFLAGS,COBSUBOK  SUBSCRIPT POSSIBLE HERE?\n         BZ    EXPRMISS           NO.\n         MVI   LEFTOVER,X'FF'     YES, SET LEFTOVERS FLAG\n         BAL   R14,SUBSIN         CHECK FOR DANGLING SUBSCRIPT\n         MVI   LEFTOVER,0         RESET LEFTOVER SUBSCRIPT FLAG\nEXPRMISS OI    OPERFLGS,OPERFAIL  NOTE PROMPTING FAILED\n         B     EXPRNORM           AND PROCEED TO NEXT PART\n         SPACE\nEXPRINC  BAL   R14,XINC           GIVE INCOMPLETE EXPR PROMPT\n         B     EXPRQRET(R15)      AND ACT ON RETURN CODE\n         SPACE\nEXPRFINV CLI   0(R8),C')'         DOES THE EXPRESSION CLOSE HERE?\n         BE    EXPRFRCE           YES, TREAT EXPRESSION AS INCOMPLETE\nEXPRITEM L     R15,=A(CLUZITEM)   NO, FIND ITEM TO REJECT\n         BALR  R14,R15\n         SPACE\n*\n*        COME HERE TO REJECT A BAD SUBPART AND GET A REPLACEMENT VALUE.\n*\nEXPRINV  BAL   R14,INV            ISSUE \"INVALID\" PROMPT\n         MVI   BYPASS,0\n         B     *+4(R15)           DID WE GET SOMETHING?\n         B     EXPRCRCT           YES, GO TRY AGAIN\n         B     EXPRMISS           NO, SIGH AND CONTINUE\n         SPACE\nEXPRCRCT LR    R2,R1\n         C     R9,OPERPCE         WHOLE EXPRESSION REJECTED?\n         BE    EXPRCFUL           YES.\n         BAL   R14,SIZE           NO, GET SIZE OF ELEMENT'S PDE\n         B     EXPRCLR\nEXPRCFUL MVI   OPERFLGS,0         ALLOW EXIT FROM OPER MODE\n         MVC   OMIT1,OPEROMIT     RESTORE ORIGINAL BACKUP POINT\n         LH    R1,OPERSIZE        GET SIZE OF ALL OPER PARTS\nEXPRCLR  BCTR  R1,0\n         EX    R1,SYNCLR          WIPE THE PDE CLEAN\n         B     SYNRETRY           NOW GO TRY WITH NEW DATA\n         SPACE\nEXPRSET  OI    OPERPRES,X'00'     SET A SUBPART PRESENCE BIT\nEXPRTEST TM    OPERPRES,X'00'     TEST A SUBPART PRESENCE BIT\n         TITLE 'CLUTSPAR -- POSITIONAL LIST HANDLING'\n*\n*        HANDLE LISTS OF POSITIONALS\n*\nLIST     LR    R0,R1              SAVE REGISTER OVER CALL\n         BAL   R14,SIZE           GET PDE SIZE\n         TM    1(R9),X'20'        RANGE PERMITTED?\n         BZ    LISTNRNG           NO.\n         AR    R1,R1              YES, DOUBLE SIZE\nLISTNRNG STH   R1,LISTSIZE        SAVE FOR REFERENCE\n         LR    R14,R1             RESHUFFLE REGISTERS\n         AR    R14,R0\n         MVC   0(4,R14),NULL      STORE END OF CHAIN\n         CLI   SUBFD1,0           CHECK FOR 1ST ITEM IN SUBFIELD\n         BNE   LISTSUB            YES.\nLISTNSUB LR    R1,R0              RESTORE PDL POINTER\n         CLI   0(R8),C'('         CHECK FOR EXPLICIT PARENTHESIS\n         BNE   SYNRECG            ONLY 1 ITEM GIVEN\n         MVI   SUBLIST,0          TURN OFF ITEM 1 FLAG\n         XC    COMMAX,COMMAX      PREPARE FOR LEADING COMMA\n         AR    R8,R6              SKIP PAST PARENTHESIS\n         B     LISTENT\n         SPACE\n*\n*        ENTRY FOR LONE LIST SUBFIELD\n*\nLISTSUB  MVI   SUBFD1,0           TURN OFF 1ST ITEM FLAG\n         BAL   R14,FNXT           FIND THE NEXT PCE\n         TM    0(R1),X'E0'        SEE IF THERE IS ONE\n         BNZ   LISTNSUB           IF SO, PARENTHESIS IS REQUIRED\n         MVI   SUBLIST,X'FF'      ALLOW MULTIPLE ITEMS W/OUT PAREN\nLISTENT  MVI   LISTF,X'FF'        NOTE WORKING IN LIST\n         LR    R1,R0\n         SPACE\n*\n*        FIND THE FIRST LIST ELEMENT\n*\nLISTGO   LR    R3,R15             SAVE RECOGNIZER ENTRY\n         L     R15,=A(CLUZSKIP)\n         BALR  R14,R15            SKIP DELIMITERS\n         B     *+4(R15)           ANYTHING AFTER?\n         B     LISTTEXT           YES.\n         B     LISTEMT            NO, EMPTY LIST\n         SPACE\nLISTTEXT CLI   0(R8),C')'         LIST ENDED HERE?\n         BE    LISTOMIT           YES.\n         SPACE\n*\n*        RECOGNIZE A LIST ELEMENT\n*\nLISTRECG LR    R15,R3             RESTORE RECOGNIZER ENTRY\n         ST    R8,PREVPOS         SAVE STARTING POINT\n         OC    BYPASS,PCBYPASS    ESTABLISH BYPASS FLAG\n         MVI   PASSF,0            TURN OFF PASSWORD FLAGS\n         BALR  R14,R15            CALL RECOGNIZER\n         B     *+4(R15)           HOW'D IT GO?\n         B     LISTOK1            GOT SOMETHING\n         B     LISTFINV           NOT FOUND\n         B     LISTINV            SOMETHING EVIL FOUND\n         BAL   R6,PARSRC12\n         BAL   R6,PARSRC12        SHOULD NOT OCCUR\n         B     LISTBAD            UNABLE TO PROMPT FOR IKJTERM\n         SPACE\n*\n*        HANDLE SUBCRIPTS IF REQUESTED\n*\nLISTOK1  TM    COBFLAGS,COBSUBOK  MAY A SUBSCRIPT APPEAR?\n         BZ    LISTNSBS           NO.\nLISTSUBS BAL   R14,SUBSIN         YES, CHECK IT OUT\n         SPACE\n*\n*        HANDLE PASSWORD IF REQUESTED\n*\nLISTNSBS TM    PASSF,PASSABLE     MAY A PASSWORD APPEAR?\n         BZ    LISTVEX            NO.\n         L     R2,PASSPDE         YES, ADDRESS PDE PORTION\n         BAL   R14,PASS           HANDLE PASSWORD\n*\n*        CALL VALIDATION EXIT FOR LIST ELEMENT\n*\nLISTVEX  BAL   R14,VEX            CALL USER VALIDATION ROUTINE\n         B     *+4(R15)           WHAT HAPPENED?\n         B     LISTVAL            ALL IS WELL\n         B     LISTCRCT           NEW INFORMATION AVAILABLE\n         B     LISTMISS           UNABLE TO PROMPT\n         LR    R2,R1              SAVE R1 OVER STACK CALL\n         MVC   ALIGN,=H'1'        SUBSCRIPT REQUIRED\n         LA    R1,=C'('           STACK ( TO FORCE ENTRY\n         OI    INSFLAG,DUMMYSUB   SHOW DUMMY SUBSCRIPT\n         L     R15,=A(CLUZPUSH)\n         BALR  R14,R15\n         LR    R1,R2\n         OI    COBFLAGS,COBIMMSB  SHOW SUBSCRIPT RIGHT THERE\n         B     LISTSUBS           GO PROCESS EMPTY SUBSCRIPT LIST\n         SPACE\nLISTMISS OI    RANGEF,RANGE1NV    NOTE PROMPT FAILURE\n         SPACE\n*\n*        CHECK FOR AND HANDLE SECOND PART OF RANGE\n*\nLISTVAL  TM    1(R9),X'20'        IS A RANGE ALLOWED?\n         BZ    LISTOK             NO.\n         BAL   R14,RANG           YES, HANDLE 2ND HALF OF RANGE\n         B     *+4(R15)           HOW'D IT GO?\n         B     LISTOK             NO PROBLEMS\n         B     LISTRTRY           START OVER AGAIN\n*                                 ELSE PROMPT FAILED\n         SPACE\n*\n*        MOVE VALUE TO DYNAMIC AREA FOR ELEMENT>1\n*\nLISTOK   LA    R1,0(,R1)\n         LA    R2,LISTEMP\n         CR    R1,R2              IS THIS THE 1ST ELEMENT?\n         BNE   LISTFRST           YES.\n         LH    R2,LISTSIZE        NO, GET A NEW PDE\n         LA    R1,4(,R2)\n         L     R15,=A(CLUZALOC)\n         BALR  R14,R15\n         L     R1,NEWMEM          GET ADDR OF NEW PDE\n         L     R14,PREVLIST\n         ST    R1,0(R2,R14)       CHAIN TO PREVIOUS ELEMENT\n         LA    R15,0(R2,R1)\n         MVC   0(4,R15),NULL      CLOSE CHAIN AFTER\n         ST    R1,PREVLIST        MAKE THIS THE NEW LAST ELEMENT\n         BCTR  R2,0\n         EX    R2,LISTMOVE        COPY VALUE TO ELEMENT\n         B     LISTNEXT\nLISTFRST ST    R1,PREVLIST        STORE ADDR OF 1ST PDE\n         SPACE\n*\n*        SCAN FOR NEXT LIST ELEMENT\n*\nLISTNEXT LA    R1,LISTEMP         FIND TEMPORARY PDE\n         XC    LISTEMP(76),LISTEMP     CLEAR IT\n         LH    R2,LISTSIZE\n         LA    R2,LISTEMP(R2)\n         MVC   0(4,R2),NULL       STORE NULL IN TEMPORARY CHAIN\n         MVI   BYPASS,0           OFF BYPASS\n         NI    PCBYPASS,X'20'     RESET ALL BYPASS FLAGS BUT PCE'S\nLISTRTRY MVI   COBFLAGS,0         RESET COBOL FLAGS\n         MVI   COBFLGS1,0\n         MVI   COBFLGS2,0\n         L     R15,=A(CLUZSKIP)\n         BALR  R14,R15            SKIP BLANKS ETC\n         B     *+4(R15)           ANYTHING LEFT?\n         B     LISTMORE           YES.\n         LA    R2,LISTEMP         NO, IS THIS THE 1ST ELEMENT\n         CR    R1,R2\n         BNE   LISTOMIT           YES.\n         B     SYNOK              NO, ACCEPT TERMINATION\nLISTMOVE MVC   0(0,R1),LISTEMP    COPY TEMP LIST TO PDE\n         SPACE\nLISTMORE CLI   0(R8),C')'         FOUND CLOSING PAREN?\n         BNE   LISTRECG           NO, RECOGNIZE NEXT ELEMENT\n         SPACE\n*\n*        HANDLE END OF LIST\n*\nLISTEND  LA    R2,LISTEMP         SEE IF THE 1ST ONE IS MISSING\n         CR    R1,R2\n         BNE   LISTEMT            YES.\n         CLI   SUBLIST,X'FF'      NO, IS A CLOSE REQUIRED?\n         BE    SYNOK              NO, LET ) BE\n         AR    R8,R6              YES, BUMP PAST IT\n         B     SYNOK              AND CONTINUE\n         SPACE\n*\n*        HANDLE EMPTY LIST\n*\nLISTEMT  AR    R8,R6              SKIP PARENTHESIS\nLISTOMIT TM    0(R9),X'10'        IS THE LIST REQUIRED?\n         BZ    SYNOK              NO.\n         LR    R2,R1              YES, SAVE R1\n         BAL   R14,FDEF           FIND THE PROMPT INFO\nLISTRQR  L     R15,=A(CLUZREQR)\n         BALR  R14,R15            REQUEST INPUT NOW\n         LR    R1,R2              RESTORE R1\n         B     *+4(R15)           WAS STUFF ENTERED?\n         B     LISTRTRY           YES, TRY IT AGAIN\n         B     SYNOK              NOPE, GIVE UP\n         SPACE\n*\n*        DECIDE WHAT TO REJECT FOR AN UNRECOGNIZED LIST ELEMENT\n*\nLISTFINV L     R15,=A(CLUZITEM)   LOOK FOR SOMETHING TO REJECT\n         BALR  R14,R15\n         SPACE\n*\n*        HANDLE INVALID LIST ELEMENT\n*\nLISTINV  BAL   R14,INV            REQUEST CORRECTION\n         LTR   R15,R15            SUCCESSFUL PROMPT?\n         BNZ   LISTNOFX           NO, MAY BE PASSWORD AFTER\nLISTCRCT LH    R2,LISTSIZE        GET SIZE OF PDL\n         BCTR  R2,0\n         EX    R2,LISTCLR         REINITIALIZE IT\n         B     LISTRTRY           YES, GO TRY AGAIN\nLISTCLR  XC    0(0,R1),0(R1)      CLEAR BAD PDL\n         SPACE\n*\n*        CHECK FOR PASSWORD OR SUBSCRIPT FOR UNCORRECTABLY BAD\n*        ELEMENT\n*\nLISTNOFX TM    PASSF,PASSABLE     PASSWORD PERMITTED?\n         BZ    LISTMISS           NO.\n         TM    PASSF,PASSCAN      YES, ALREADY SCANNED FOR IT?\n         BNZ   LISTMISS           YES.\n         L     R2,PASSPDE         NO, FIND PASSWORD PDE\n         MVI   LEFTOVER,X'FF'     SET PASSWORD FOR INVALID PARM FLAG\n         BAL   R14,PASS           CHECK FOR A PASSWORD\n         B     LISTPAST\nLISTBAD  TM    COBFLAGS,COBSUBOK  SUBSCRIPT POSSIBLE HERE?\n         BZ    LISTMISS           NO.\n         MVI   LEFTOVER,X'FF'     YES, SET LEFTOVERS FLAG\n         BAL   R14,SUBSIN         CHECK FOR DANGLING SUBSCRIPT\nLISTPAST MVI   LEFTOVER,0         RESET INVALID PARM FLAG\n         B     LISTMISS           NOW TREAT AS MISSING\n         TITLE 'CLUTSPAR -- END OF PARAMETERS ROUTINE'\n*\n*        END OF POSITIONALS, NO KEYWORDS. CHECK FOR EXTRA INFO\n*\nSYNPEND  L     R15,=A(CLUZSKIP)\n         BALR  R14,R15            SKIP SPACES ET AL\n         B     *+4(R15)           ANYTHING LEFT\n         B     SYNXTRA            YES, GIVE WARNING\n         B     SYNOMORE           NO, GO DO DEFAULTS\n         SPACE\nSYNXTRA  L     R15,=A(CLUZXTRA)   ROUTINE TO EXTRACT EXTRA INFO\n         CLI   SUBFLAG,0          WITHIN SUBFIELD?\n         BNE   SYNOPEN            YES.\n         TM    COBFLAGS,COBSUB    WITHIN SUBSCRIPT LIST?\n         BNZ   SYNOPEN            YES.\n         TM    OPERFLGS,OPERACT+OPEREXPR    WITHIN COMPLEX EXPRESSION?\n         BNO   SYNNKEY            NO.\nSYNOPEN  CLI   0(R8),C')'         YES, IS THIS A )?\n         BE    SYNOMORE           YES, GO DEFAULT\nSYNNKEY  OC    OMIT1+1(3),OMIT1+1 IS ANYTHING NEARBY OMITTED?\n         BNZ   SYNUNIN            YES, ALLOW REENTRY\n         L     R1,=A(IGNORED)     NO, JUST IGNORE IT\n         BALR  R14,R15\nSYNOMORE TM    COBFLAGS,COBSUB    IN A SUBSCRIPT LIST?\n         BNZ   SUBSOUT            YES, RETURN TO SUBSCRIPTED VAR\n         B     SYNOVER            NO, CHECK FOR OPER MODE\n         SPACE\n*\n*        PROMPT FOR RE-ENTRY OF EXTRA INFORMATION IF CORRECTION\n*        POSSIBLE\n*\nSYNUNIN  L     R1,=A(UNINTELL)    SAY \"UNINTELLIGIBLE INFORMATION\"\n         BALR  R14,R15\n         BAL   R14,REEN           ASK FOR REENTRY\n         B     *+4(R15)           DID WE GET SOMETHING?\n         B     SYNRETRY           YES, TRY THIS OUT\nSYNOVER  TM    OPERFLGS,OPERACT+OPEREXPR    NO, WITHIN AN EXPRESSION?\n         BNO   DEFT               NO, GO HANDLE DEFAULTS\n         B     EXPROVER           YES, GO HANDLE EXPRESSION END\n         TITLE 'CLUTSPAR -- KEYWORD && DEFAULT HANDLING'\n*\n*        PARSE THE SUPPLIED KEYWORDS\n*\nSYNKEY   BAL   R14,KYWD           CALL KEYWORD ROUTINE\n         B     *+4(R15)           WHAT HAPPENED?\n         B     DEFT               NOTHING SPECIAL\n         L     R9,OMIT1           BACKUP & RETRY POSITIONALS\n         B     SYNLOOP\n         SPACE\n*\n*        APPLY THE DEFAULTS FOR ANY PARAMETERS WHICH HAVE NOT YET\n*        BEEN SUPPLIED.\n*\nDEFT     L     R9,PARM1           FIND THE FIRST PARM\n         MVI   DEFTF,0            MAKE SURE OF DEFAULT FLAG\nDEFTLOOP TM    0(R9),X'08'        HAS THIS PARM A DEFAULT?\n         BZ    DEFTNEXT           NO, TRY THE NEXT\n         MVC   ALIGN,4(R9)\n         LH    R2,ALIGN\n         A     R2,PDLPTR          LOCATE THE PDE\n         CLI   0(R9),X'48'        IS THIS A KEYWORD?\n         BE    DEFTKEY            YES.\n         BAL   R14,SIZE           NO, GET SIZE OF PDE\n         LTR   R1,R1              IS IT 0?\n         BZ    DEFTNEXT           YES, SKIP IT\n         BCTR  R1,0\n         EX    R1,DEFTTEST        IS THERE ALREADY A VALUE?\n         BNZ   DEFTNEXT           YES, NOTHING TO DO\n         STM   R1,R2,DFSAVE       SAVE REGS OVER DEFAULT PARSE\n         MVI   DEFTF,DEFTINS+DEFTPOS   SET DEFAULT FLAGS\n         BAL   R14,FDEF           FIND DEFAULT VALUE\n         BAL   R14,INS            INSERT IT\n         XC    OMIT1(4),OMIT1     MAKE SURE NO BACKUP\n         B     SYNLOOP            GO PROCESS THIS POSITIONAL\nDEFTRET  MVI   NESTLEVL,0         RETURN POINT FROM SYN ROUTINE\n         TM    ALCFLAGS,ACPTREQ   STORAGE OWNED BY DEFAULT?\n         BZ    DEFTXTRA           NO, NO ACCEPT REQUIRED\n         L     R15,=A(CLUZACPT)   YES, SHOW STORAGE TO BE KEPT\n         BALR  R14,R15\nDEFTXTRA L     R15,=A(CLUZSKIP)\n         BALR  R14,R15            SEE IF ANY DEFAULT TEXT LEFT\n         LM    R1,R2,DFSAVE       RESTORE REGS\n         LTR   R15,R15\n         BNZ   DEFTPOP            PROCEED IF NOTHING LEFT\n         BAL   R6,PARSRC12        ELSE CALLER ERROR\n         SPACE\nDEFTKEY  OC    0(2,R2),0(R2)      WAS KEYWORD SPECIFIED?\n         BNZ   DEFTNEXT           YES.\n         MVI   DEFTF,DEFTINS      SET DEFAULT FLAGS FOR KEYWORD\n         BAL   R14,FDEF           FIND DEFAULT VALUE\n         BAL   R14,INS            INSERT IT\n         XC    OMIT1(4),OMIT1     MAKE SURE NO BACKUP\n         LR    R3,R9              SAVE PCE POINTER\n         BAL   R14,KYWD           PROCESS KEYWORD DEFAULT\n         LR    R9,R3              RESTORE\n         LA    R1,1               PDE LENGTH IS 2\n         SPACE\nDEFTPOP  L     R15,=A(CLUZPOPS)\n         BALR  R14,R15            POP OFF DEFAULT VALUE\n         EX    R1,DEFTTEST        IS ITEM STILL MISSING?\n         BNZ   DEFTNEXT           NO, PROCEED\n         BAL   R6,PARSRC12        YES, CALLER ERROR\n         SPACE\nDEFTNEXT TM    0(R9),X'E0'        IS THIS AN OPER PCE?\n         BNO   DEFTNOPR           NO.\n         BAL   R14,FDSC           YES, SKIP OVER SUBPART PCE'S\n         MVC   ALIGN,0(R1)        SKIP THE DESCRIPTION\n         AH    R1,ALIGN\n         XC    ALIGN,ALIGN\n         OC    ALIGN,6(R1)        IS THERE A CHAINED TERM?\n         BNZ   DEFTOP88           YES.\n         MVC   ALIGN,4(R1)        NO, FIND OPERAND 2 OFFSET\nDEFTOP88 L     R9,PCL\n         AH    R9,ALIGN           LOCATE PCE FOR END OF EXPRESSION\n         SPACE\nDEFTNOPR MVC   ALIGN,2(R9)        ON TO NEXT PARM\n         AH    R9,ALIGN\n         TM    0(R9),X'E0'        FOUND THE END?\n         BZ    DEFTDONE           YES.\n         B     DEFTLOOP\nDEFTTEST OC    0(0,R2),0(R2)      SEE IF PARM ENTERED\n         SPACE\n*\n*        FOR SUBFIELD PROCESSING, RETURN TO PREVIOUS LEVEL.\n*\nDEFTDONE MVI   DEFTF,0            DEFAULT PROCESSING DONE\n         CLI   SUBFLAG,0          WITHIN SUBFIELD?\n         BE    PARSEND            NO, READY TO RETURN\n         CR    R8,R7              YES, OUT OF TEXT?\n         BH    CURSOUT            YES, FALL BACK A LEVEL\n         SPACE\n*\n*        SKIP PAST CLOSING PARENTHESIS AND RETURN TO PREVIOUS LEVEL\n*\nSYNUP    AR    R8,R6\n         B     CURSOUT            RETURN TO PREVIOUS LEVEL\n         TITLE 'CLUTSPAR -- TERMINATION ROUTINE'\n*\n*        THE PARSE IS FINISHED. IF NO INFORMATION WAS MISSING, UPDATE\n*        THE COMMAND BUFFER OFFSET AND RETURN\n*\nPARSEND  CLI   RC,0               DID ANY PROMPTS FAIL?\n         BNE   PARSABRT           YES, BAD RET CODE\n         L     R2,ANSPTR          NO, FIND THE ANSWER POINTER\n         MVC   0(4,R2),PDLPTR     COPY PDL ADDRESS OVER\n         L     R15,=A(CLUZWRAP)   GO RELEASE UNNEEDED MEMORY\n         BALR  R14,R15\n         L     R1,CBUF            RESET COMMAND OFFSET\n         SR    R8,R1\n         S     R8,=A(4)\n         STH   R8,2(,R1)\n         LIEXIT RC=0              RETURN WITH GOOD NEWS\n         TITLE 'CLUTSPAR -- ABNORMAL TERMINATION ROUTINE'\n*\n*        THIS ROUTINE GETS CONTROL WHEN A BAD RETURN CODE IS TO BE\n*        RETURNED. IT FREES PARSE STORAGE AND RETURNS\n*\nPARSABRT LIBEL PARSTERM           TARGET FOR LIGOTO\n         L     R15,=A(CLUZWRAP)\n         BALR  R14,R15            GIVE BACK ALL MEMORY\n         L     R2,ANSPTR\n         XC    0(4,R2),0(R2)      ZERO THE ANSWER POINTER\n         SR    R15,R15\n         IC    R15,RC             GET THE RETURN CODE\n         LIEXIT RC=(15)           AND RETURN\n         TITLE 'CLUTSPAR -- PASSWORD HANDLING ROUTINE'\n*\n*        THIS ROUTINE IS CALLED TO HANDLE A POSSIBLE PASSWORD\n*        FOLLOWING A POSITIONAL PARAMETER\n*\nPASS     STM   R14,R1,PWSAVE\n         LR    R0,R1              SAVE PROMPT POINTER\n         MVC   ORIGBYP,BYPASS     SAVE BYPASS FLAGS\n         ST    R8,PASSTART        SAVE WHERE PASSWORD SCAN BEGAN\n         MVC   OLDPOS,PREVPOS     AND WHERE DSN/USERID STARTED\nPASSRPT  MVC   SKIPSAVE,SKIPF     AND SKIP FLAGS\n         MVI   SKIPF,NOSLASH      FORCE NO SLASH HANDLING\n         MVI   EXPECT,C'/'        EXPECT TO FIND A SLASH\n         XC    COMMAX,COMMAX      WITH NO COMMAS BEFORE IT\n         L     R15,=A(CLUZSKIP)\n         BALR  R14,R15            SKIP BLANKS\n         B     *+4(R15)           GOT ANYTHING?\n         B     PASSTRY            YES.\n         SPACE\nPASSRET  MVC   SKIPF,SKIPSAVE     RESTORE EVERYTHING\n         MVC   BYPASS,ORIGBYP     RESTORE ORIGINAL BYPASS\n         MVC   PREVPOS,OLDPOS     RESTORE PREVIOUS PARM START\n         MVI   PCBYPASS,0         MAKE SURE PCE BYPASS NOT SET\n         MVI   ORIGBYP,X'00'\n         OI    PASSF,PASSCAN      SHOW PASSWORD SCAN DONE\n         LM    R14,R1,PWSAVE\n         BR    R14                AND RETURN\n         SPACE\nPASSTRY  CLI   0(R8),C'/'         IS A SLASH PRESENT?\n         BNE   PASSRET            NO, RETURN\n         OI    PASSF,PASSEEN      SHOW PASSWORD INDICATOR FOUND\n         NI    SKIPF,255-NOSLASH  YES, RESET SKIP FLAGS\n         MVI   BYPASS,PASSABLE    SET TO BYPASS\n         MVI   PCBYPASS,PASSABLE\n         SPACE\n*\n*        SKIP UP TO THE PASSWORD\n*\nPASSAGN  XC    COMMAX,COMMAX      NO COMMA BEFORE PASSWORD\n         L     R15,=A(CLUZSKIP)\n         BALR  R14,R15            SKIP PAST SLASH\n         B     *+4(R15)           ANYTHING MORE?\n         B     PASSPRES           YES.\n         B     PASSRQR            NO, ASK FOR PASSWORD\n         SPACE\n*\n*        SYNTAX CHECK THE PASSWORD\n*\nPASSPRES ST    R8,PREVPOS         SAVE STARTING POINT\n         MVI   NESTLEVL,LEVSUBS   ASSIGN NEW LEVEL TO PASSWORD\n         LR    R1,R2              R1->PASSWORD PDE PART\n         L     R15,=A(CLUZCHAR)   PASSWORD RECOGNIZER\n         BALR  R14,R15            IS IT A PASSWORD?\n         B     *+4(R15)\n         B     PASSOK             YES.\n         B     PASSRQR            NO, FORCE ONE\n         B     PASSINV            A LOUSY ONE\n         BAL   R6,PARSRC12\n         SPACE\n*\n*        THE PASSWORD IS INVALID. PROMPT & TRY AGAIN\n*\nPASSINV  MVC   MSGAREA(4),=A(INVALID)\n         MVC   MSGAREA+4(4),=A(PASSWORD)\n         AIF   ('&OPSYS' NE 'MVS').NMVS3F\n         TM    PASSF,PASSABLE     PROCESSING NEW PASSWORD?\n         BNZ   PASSOLD            NO.\n         MVC   MSGAREA+4(4),=A(NEWPASS)     YES, CHANGE MSG TEXT\nPASSOLD  EQU   *\n.NMVS3F  LA    R1,MSGAREA+4\n         OI    0(R1),X'02'        SET END OF MSG MARK\n         LA    R1,MSGAREA\n         L     R15,=A(CLUZINFO)\n         BALR  R14,R15            SEND THE MESSAGE\n         BAL   R14,REEN           ASK FOR CORRECTION\n         AIF   ('&OPSYS' NE 'MVS').NMVS10D\n         OI    PASSF,PASSPROM     SHOW PASSWORD PROMPT ISSUED\n.NMVS10D ANOP\n         LTR   R15,R15            DID WE GET IT?\n         BNZ   PASSOK             NO, FORGET IT\n         NI    SKIPF,255-SLASH1   YES, TRY AGAIN\n         B     PASSAGN\n         SPACE\n*\n*        THE PASSWORD IS MISSING. PROMPT FOR IT\n*\nPASSRQR  MVC   BYPASS,ORIGBYP     RESTORE ORIGINAL BYPASS\n         LR    R1,R0              RESTORE PROMPT PTR\n         L     R15,=A(CLUZRQPW)\n         BALR  R14,R15            REQUIRE THE PASSWORD\n         MVC   BYPASS,PCBYPASS    RESTORE BYPASS\n         AIF   ('&OPSYS' NE 'MVS').NMVS10F\n         OI    PASSF,PASSPROM     SHOW PASSWORD PROMPT ISSUED\n.NMVS10F ANOP\n         B     *+4(R15)           DID WE GET A PASSWORD?\n         B     PASSAGN            YES, RETRY\n*                                 NO, GIVE UP\n         SPACE\n         AIF   ('&OPSYS' NE 'MVS').NMVS3A\n*\n*        IF A NEW PASSWORD IS ALLOWED, HANDLE THE NEW PASSWORD.\n*        IF A NEW PASSWORD IS OBTAINED BY PROMPT, CALL CLUZCNFM\n*        TO CONFIRM IT\n*\nPASSOK   TM    PASSF,NWPASSOK     IS A NEW PASSWORD POSSIBLE?\n         BZ    PASSCMIT           NO, THOU SHALT COMMIT\n         TM    PASSF,PASSABLE     YES, HAVE WE PROCESSED IT?\n         BE    PASSCNFM           YES, CONFIRM IT\n         NI    PASSF,255-PASSABLE NO, NOW PROCESS NEW ONE\n         BAL   R14,CMIT           FIRST COMMIT OLD ONE\n         LA    R2,8(,R2)          JUMP TO NEW PASSWORD PDE PART\n         B     PASSRPT            AND DO IT AGAIN\n         SPACE\nPASSCNFM TM    PASSF,PASSPROM     PASSWORD FROM PROMPT RESPONSE?\n         BZ    PASSCMIT           NO, NO CONFIRMATION REQUIRED\n         LR    R1,R2              YES, COPY PDE ADDRESS\n         L     R15,=A(CLUZCNFM)\n         BALR  R14,R15            CALL CONFIRMATION ROUTINE\n         LTR   R15,R15            CONFIRMATION FAILED?\n         BNZ   PASSRQR            YES, ASK AGAIN\nPASSCMIT EQU   *\n         AGO   .JMVS3A\n.NMVS3A  ANOP\nPASSOK   EQU   *\n.JMVS3A  BAL   R14,CMIT           COMMIT TO PASSWORD STORAGE\n         MVI   NESTLEVL,LEVITEM   RETURN TO NORMAL ITEM LEVEL\n         B     PASSRET            RETURN TO CALLER\n         TITLE 'CLUTSPAR -- RANGE HANDLING ROUTINE'\n*\n*        THIS ROUTINE DETECTS AND HANDLES THE SECOND HALF OF A RANGE\n*\nRANG     STM   R14,R3,RSAVE       SAVE REGISTERS\n         LR    R2,R1              SAVE PDE POINTER\n         MVC   RANGEPOS,PREVPOS   SAVE START OF FIRST PART\n         ST    R8,RANGEND         SAVE END OF FIRST PART\n         MVC   RANGBYP,BYPASS     SAVE BYPASS FLAG\n         SPACE\n*\n*        SEE IF THE NEXT CHARACTER IS A COLON\n*\nRANGPOP  CR    R8,R7              ANY TEXT LEFT?\n         BNH   RANGCHEK           YES.\n         L     R15,CURINP         FIND CURRENT INPUT\n         C     R15,CBUF           WORKING ON COMMAND LINE?\n         BE    RANGMISS           YES, NOTHING IS LEFT\n         TM    DEFTINPT,DEFTINS   IS THIS DEFAULT TEXT\n         BNZ   RANGMISS           YES, PROCEED NO FURTHER\n         TM    PREVINS-INPUT(R15),DUMMYSUB  LOOKING AT DUMMY SUBFIELD?\n         BNZ   RANGMISS           YES, DON'T POP IT\n         L     R15,=A(CLUZPOPS)\n         BALR  R14,R15            POP USED TEXT FROM STACK\n         B     RANGPOP            AND CHECK AGAIN\n         SPACE\nRANGCHEK CLI   0(R8),C':'         IS THERE ONE?\n         BNE   RANGMISS           NO, RETURN\n         AR    R8,R6              YES, SKIP IT\n         MVC   BYPASS,PCBYPASS    SET UP BYPASS FOR 2ND HALF\nRANGAIN  XC    COMMAX,COMMAX      NO COMMA AFTER COLON\n         L     R15,=A(CLUZSKIP)\n         BALR  R14,R15            SKIP BLANKS, ETC\n         B     *+4(R15)           ANYTHING LEFT?\n         B     RANGHERE           YES.\nRANGINC  BAL   R14,RINC           ISSUE INCOMPLETE RANGE PROMPT\n         LTR   R15,R15            SOMETHING ENTERED?\n         BZ    RANGAIN            YES, TRY IT AGAIN\nRANGMISS SR    R15,R15            NO, SET \"DO NO MORE\" RETURN\n         SPACE\nRANGRET  ST    R15,RSAVE+4        SET RETURN CODE\n         LM    R14,R3,RSAVE       RESTORE REGS\n         BR    R14                AND RETURN\n         SPACE\n*\n*        CALL RECOGNIZER FOR SECOND HALF\n*\nRANGHERE OI    RANGEF,RANGE2      NOTE WORKING ON PART 2\n         BAL   R14,SIZE           GET PDE SIZE\n         STH   R1,RANGSIZE        SAVE IT\n         BCTR  R1,0\n         EX    R1,RANGSAVE        SAVE THE FIRST VALUE\n         LA    R1,1(R1,R1)\n         EX    R1,RANGCLR         RECLEAR THE PDE\n         SPACE\nRANGO    ST    R8,PREVPOS         STORE STARTING POINT\n         MVI   COBFLGS2,0         RESET COBOL RANGE-END FLAGS\n         NI    COBFLAGS,COBFORM   RESET TRANSITORY COBOL FLAGS\n         MVI   PASSF,0            MAKE SURE PASSWORD FLAGS OK\n         LR    R1,R2\n         LR    R15,R3             RESTORE RECOGNIZER ADDRESS\n         BALR  R14,R15            RECOGNIZE SECOND PART\n         B     *+4(R15)           WHAT HAPPENED?\n         B     RANGOK1            RECOGNITION\n         B     RANGFINV           DREW A BLANK\n         B     RANGINV            RECOGNIZED AS INVALID\n         BAL   R6,PARSRC12        SHOULD NOT OCCUR\n         BAL   R6,PARSRC12        NOR THIS\n         B     RANGBAD            UNABLE TO PROMPT FOR TERM\n         SPACE\nRANGSAVE MVC   RANGTEMP(0),0(R2)  SAVE FIRST PART OF PDE\nRANGCLR  XC    0(0,R2),0(R2)      CLEAR RANGE PDE\n         SPACE\n*\n*        REJECT WHATEVER IS HANDY IF THE SECOND HALF CANNOT BE\n*        RECOGNIZED\n*\nRANGFINV CLI   0(R8),C')'         LOOKING AT CLOSE PAREN?\n         BNE   RANGNPRN           NO.\n         CLI   SUBFLAG,0          YES, IN A SUBFIELD?\n         BNE   RANGLOST           YES, TREAT AS INCOMPLETE RANGE?\n         CLI   LISTF,0            YES, IN A LIST?\n         BNE   RANGLOST           YES, CONSIDER IT INCOMPLETE\nRANGNPRN L     R15,=A(CLUZITEM)\n         BALR  R14,R15            PICK HANDY TEXT TO REJECT\n         SPACE\nRANGINV  BAL   R14,INV            REJECT & ASK FOR MORE\n         B     *+4(R15)           DID WE GET IT?\nRANGITAB B     RANGCRCT           YES, TRY AGAIN\n         B     RANGMISS           NO,  GIVE UP\n         SPACE\nRANGCRCT LH    R15,RANGSIZE       GET SIZE OF ONE PDE\n         BCTR  R15,0\n         EX    R15,RANGCLR        CLEAR OUT BAD DATA\n         SPACE\nRANGRTRY L     R15,=A(CLUZSKIP)\n         BALR  R14,R15            SKIP BLANKS AGAIN\n         B     *+4(R15)           ANYTHING FOUND?\n         B     RANGO              YES, RECOGNIZE AGAIN\nRANGLOST LH    R15,RANGSIZE       RANGE HAS BECOME INCOMPLETE\n         BCTR  R15,0\n         EX    R15,RANGREST       RESTORE 1ST HALF DATA\n         NI    RANGEF,255-RANGE2  OFF PART 2 FLAG\n         B     RANGINC            GO ASK FOR PART 2\n         SPACE\n*\n*        CHECK FOR PASSWORD OR SUBSCRIPT FOR UNCORRECTABLY BAD\n*        ELEMENT\n*\nRANGBAD  TM    COBFLAGS,COBSUBOK  SUBSCRIPT POSSIBLE HERE?\n         BZ    RANGMISS           NO.\n         MVI   LEFTOVER,X'FF'     YES, SET LEFTOVERS FLAG\n         BAL   R14,SUBSIN         CHECK FOR DANGLING SUBSCRIPT\n         MVI   LEFTOVER,0         RESET LEFTOVER SUBSCRIPT FLAG\n         B     RANGMISS\n         SPACE\n*\n*        CHECK FOR FOLLOWING SUBSCRIPTS IF REQUESTED BY THE RECOGNIZER\n*\nRANGOK1  TM    COBFLAGS,COBSUBOK  SUBSCRIPT POSSIBLE?\n         BZ    RANGVEX            NO.\nRANGSUBS BAL   R14,SUBSIN         YES, LOOK FOR THEM\n         SPACE\n*\n*        CALL THE USER EXIT TO VALIDATE THE SECOND PART\n*\nRANGVEX  BAL   R14,VEX            LET CALLER VALIDATE PART 2\n         B     *+4(R15)           OK?\n         B     RANGVEX2           YES.\n         B     RANGCRCT           NO,  TRY REPLACEMENT\n         B     RANGSKIP           COULDN'T PROMPT, CLEAR THE PDE\n         MVC   ALIGN,=H'1'        SUBSCRIPT REQUIRED, FORCE A PROMPT\n         LA    R1,=C'('           BY STACKING AN EMPTY LIST\n         OI    INSFLAG,DUMMYSUB   SHOW WHAT WE'RE DOING\n         L     R15,=A(CLUZPUSH)\n         BALR  R14,R15\n         OI    COBFLAGS,COBIMMSB  SHOW SUBSCRIPT AROUND THE CORNER\n         LR    R1,R2\n         B     RANGSUBS\n         SPACE\n*\n*        VALIDATE BOTH PARTS OF THE RANGE TOGETHER\n*\nRANGVEX2 TM    RANGEF,RANGE1NV    WAS VALUE 1 MISSING?\n         BNZ   RANGSKIP           YES, STOP NOW\n         NI    RANGEF,255-RANGE2  OFF THE PART 2 FLAG\n         MVI   NESTLEVL,LEVRANGE  SET COMBINED STORAGE LEVEL\n         LH    R15,RANGSIZE       GET PDE SIZE\n         LA    R14,0(R2,R15)\n         BCTR  R15,0\n         EX    R15,RANGMOVE       MOVE 2ND VALUE TO 2ND PART\n         EX    R15,RANGREST       RESTORE 1ST PART\n         MVI   RANGEF,RANGERR     SET FLAG FOR REENTER MSG\n         OC    BYPASS,RANGBYP     BYPASS FOR EITHER HALF\n         BAL   R14,VEX            VALIDATE\n         NI    RANGEF,255-RANGERR-RANGE2\n         B     *+4(R15)           HOW'D IT GO?\n         B     RANGRET            FINE\n         B     RANGOUCH           LOUSY, RESCAN FROM  BEGINNING\nRANGSKIP SR    R15,R15            COULDN'T PROMPT, CLEAR & GIVE UP\nRANGOUCH LH    R14,RANGSIZE       GET SIZE AGAIN\n         AR    R14,R14\n         BCTR  R14,0\n         EX    R14,RANGCLR        WIPE OUT PDE CONTENTS\n         B     RANGRET            AND RETURN\nRANGMOVE MVC   0(0,R14),0(R2)     MOVE 2ND VALUE->2ND PDE PART\nRANGREST MVC   0(0,R2),RANGTEMP   RESTORE 1ST VALUE\n         TITLE 'CLUTSPAR -- VALIDITY CHECK EXIT INTERFACE'\n*\n*        THIS ROUTINE INTERFACES TO A USER VALIDITY CHECK EXIT\n*\nVEX      SR    R15,R15            ASSUME ALL IS WELL\n         STM   R14,R3,VSAVE       SAVE REGS\n         TM    0(R9),X'01'        DOES A VALIDCK EXIT EXIST?\n         BZ    VEXCMIT            NO, GO COMMIT MEMORY\n         LR    R2,R9              YES, COPY R9\n         MVC   ALIGN,2(R9)        ALIGN TOTAL PCE LENGTH\n         AH    R2,ALIGN\n         SH    R2,=H'4'           VCEXIT ADDR IS 3 BYTES BACK          *\n                                  (GO 4 TO SUPPORT 4-BYTE ADDRS)\n         SPACE\nVEXNHELP MVC   VRTN(4),0(R2)      SAVE ROUTINE ADDRESS\n         ST    R1,VPDE            STORE PDE ADDR FOR EXIT\n         LA    R1,VPDE            POINT R1->VALIDCK PARMS\n         MVC   VMSG,NULL          NULLIFY LEVEL2 MSG POINTER\n         L     R15,VRTN\n         BALR  R14,R15            CALL USER EXIT\n         B     *+4(R15)           WHAT HAPPENED?\n         B     VEXCMIT            VALUE IS OK\n         B     VEXINV             VALUE IS BAD (TELL THE WORLD)\n         B     VEXREEN            VALUE IS BAD (JUST PROMPT)\n         BAL   R6,PARSRC20        STOP THE WORLD RIGHT NOW\n         B     VEXNOSUB           SUBSCRIPT REQUIRED\n         SPACE\nVEXINV   BAL   R14,INV            PUT OUT INVALID MESSAGE\n         B     VEXFAIL\n         SPACE\nVEXREEN  BAL   R14,INVRENT        PUT OUT REENTER\n         SPACE\n*\n*        CALL THE MEMORY ROLLBACK ROUTINE TO FREE ANY MEMORY ALLOCATED\n*        FOR THE INVALID ITEM\n*\nVEXFAIL  BAL   R14,RLBK           DISCARD STORAGE FOR THIS ITEM\n         LA    R15,4(,R15)        ADD 4 TO RETURN CODE\nVEXRET   ST    R15,VSAVE+4        TO PASS BACK TO CALLER\n         LM    R14,R3,VSAVE\n         BR    R14                RETURN\n         SPACE\n*\n*        THE EXIT CLAIMED THE ITEM SHOULD BE SUBSCRIPTED (VIA THE\n*        UNDOCUMENTED RETURN CODE 16). SEE IF THAT IS POSSIBLE\n*        BEFORE ACCEPTING IT.\n*\nVEXNOSUB TM    COBFLAGS,COBSUBOK  IS A SUBSCRIPT ALLOWED?\n         BZ    VEXOUCH            NO, USER ERROR\n         LA    R15,12             YES, CAUSE RETURN CODE OF 12\n         B     VEXRET             DON'T COMMIT OR ROLLBACK (VEXIT      *\n                                  SHOULD BE CALLED AGAIN)\nVEXOUCH  BAL   R6,PARSRC12\n         SPACE\n*\n*        CALL THE MEMORY MANAGER COMMIT ROUTINE, AS THE MEMORY FOR\n*        ITEM CAN NOW NOT BE FREED EXCEPT BY AN ERROR AT A HIGHER\n*        LEVEL OR BY ERASURE OF THE ENTIRE PARAMETER\n*\nVEXCMIT  BAL   R14,CMIT           ASSOCIATE ITEM WITH HIGHER LEVEL\n         B     VEXRET             AND RETURN HAPPY\n         TITLE 'CLUTSPAR -- KEYWORD AND SUBFIELD HANDLER'\n*\n*        THIS ROUTINE PARSES KEYWORDS\n*\nKYWD     STM   R14,R3,KSAVE       SAVE REGISTERS\n         MVI   PCBYPASS,X'00'     KEYWORDS CAN NOT BE PTBYPS\n         SPACE\n*\n*        SKIP TO THE NEXT KEYWORD IN THE INPUT\n*\nKYWDNEXT MVI   COBFLAGS,0\n         MVI   PASSF,0            RESET PASSWORD FLAGS\n         L     R15,=A(CLUZSKIP)\n         BALR  R14,R15            SKIP BLANKS ETC\n         B     *+4(R15)           ANY TEXT THERE?\n         B     KYWDTEXT           YES.\nKYWDDONE SR    R15,R15            NO, RETURN NORMALLY\nKYWDRET  LM    R0,R3,KSAVE+8\n         L     R14,KSAVE\n         BR    R14\n         SPACE\n*\n*        PICK THE KEYWORD NAME OUT OF THE INPUT\n*\nKYWDTEXT ST    R8,PREVPOS         SAVE STARTING POINT\n         CLI   0(R8),C')'         CLOSING PAREN?\n         BE    KYWDPREN           YES.\n         L     R9,KEY1            ADDRESS FIRST KEYWORD PCE\n         L     R15,=A(CLUZITEM)\n         BALR  R14,R15            GET A KEYWORD CANDIDATE\n         B     *+4(R15)           GOT ONE?\n         B     KYWDFND            YEP.\n         B     KYWDINV            GOT A BAD ONE\n         SPACE\n*\n*        LOOK UP THE KEYWORD NAME\n*\nKYWDFND  L     R15,=A(CLUZKIDN)\n         BALR  R14,R15            IDENTIFY THE KEYWORD\n         B     *+4(R15)           FOUND?\n         B     KYWDOK             YES.\n         B     KYWDUNKN           NO, UNKNOWN\nKYWDAMB  L     R1,=A(AMBIG)       NO, AMBIGUOUS\n         B     KYWDERR\nKYWDUNKN L     R1,=A(UNKNOWN)\n         B     KYWDERR\nKYWDPREN CLI   SUBFLAG,0          ARE WE IN A SUBFIELD?\n         BNE   KYWDDONE           YES, END OF KEYWORDS\n         AR    R8,R6              NO, SKIP PAREN & SAY INVALID\nKYWDINV  L     R1,=A(INVALID)\nKYWDERR  BAL   R14,KERR           SEND KEYWORD ERROR MSG\n         MVI   BYPASS,X'00'       RESET BYPASS FLAG\n         B     *+4(R15)           PROMPT RESULTS?\n         B     KYWDRTRY           GOOD, RETRY\n         B     KYWDNEXT           LOUSY, JUST SKIP\n         SPACE\n*\n*        IF ENDING POSITIONALS WERE OMITTED, ATTEMPT TO MATCH THE\n*        PROMPT RESPONSE AGAINST THEM BEFORE TREATING IT AS KEYWORDS\n*\nKYWDRTRY OC    OMIT1(4),OMIT1     CHECK FOR MISSING PREVIOUS POSITIONAL\n         BZ    KYWDNEXT           NONE, PROCEED\n         LA    R15,4              YES, RETRY NEW DATA AS POSITIONAL\n         B     KYWDRET\n         SPACE\n*\n*        SEE IF THE KEYWORD IS A RESPECIFICATION. IF SO, AND IF THE\n*        KEYWORD IS NOT AN INSERT, SEND A WARNING MESSAGE.\n*\nKYWDOK   XC    OMIT1,OMIT1        CLEAR BACKUP POINT\n         LH    R1,NAME#           GET KEYWORD NUMBER\n         L     R3,NAMEADDR        GET IKJNAME PCE ADDR\n         L     R9,KEYPTR          AND IKJKEYWD ADDR\n         MVC   ALIGN,4(R9)\n         LH    R2,ALIGN\n         A     R2,PDLPTR          FIND PDE ADDR FOR KEYWORD\n         OC    0(2,R2),0(R2)      ALREADY SPECIFIED?\n         BZ    KYWD1ST            NO, FIRST TIME\n         TM    INSFLAG,INSERTED   YES, OVERRIDDEN BY INSERT?\n         BNZ   KYWDOVOK           YES, KEEP QUIET\n         BAL   R14,KOVR           GIVE OVERRIDE WARNING\n         SPACE\n*\n*        ERASE OVERRIDDEN SUBFIELD VALUES\n*\nKYWDOVOK BAL   R14,ERAS           ERASE RESULTS OF OLD SPECIFICATION\n         L     R3,NAMEADDR        RESTORE IKJNAME PTR\n         SPACE\n*\n*        IF A SUBFIELD IS ALLOWED, LOOK FOR THE SUBFIELD START\n*\nKYWD1ST  STH   R1,0(,R2)          STORE NAME NUMBER\n         TM    0(R3),X'04'        IS A SUBFIELD ALLOWED?\n         BZ    KYWDINS            NO.\n         XC    COMMAX,COMMAX      CATCH COMMA BEFORE SUBFIELD\n         MVI   EXPECT,C'('        NOTE OPEN PAREN EXPECTED\n         L     R15,=A(CLUZSKIP)\n         BALR  R14,R15            YES, SKIP SEPARATORS\n         B     *+4(R15)           ANYTHING LEFT?\n         B     KYWDAFT            YES.\n         B     KYWDNSUB           NO, FORCE EMPTY SUBFIELD\n         SPACE\n*\n*        IF A SUBFIELD DOES NOT FOLLOW, INSERT A DUMMY \"(\"\n*\nKYWDAFT  CLI   0(R8),C'('         OPEN PAREN AFTER KEYWORD?\n         BE    KYWDSUB            YES, SUBFIELD PRESENT\nKYWDNSUB MVC   ALIGN,=H'1'        NO, CREATE EMPTY SUBFIELD\n         LA    R1,=C'('\n         OI    INSFLAG,DUMMYSUB   SHOW DUMMY SUBFIELD CREATING\n         L     R15,=A(CLUZPUSH)\n         BALR  R14,R15\n         SPACE\n*\n*        RECURSE TO SYN TO PARSE THE SUBFIELD INFORMATION\n*\nKYWDSUB  AR    R8,R6              SKIP PARENTHESIS\n         MVI   SUBFD1,X'FF'       NOTE STARTING SUBFIELD\n         LA    R15,SYN            WHERE TO RECURSE TO\n         BAL   R14,CURSIN         ENTER SUBFIELD\n         SPACE\n*\n*        PERFORM ANY REQUIRED INSERTION\n*\nKYWDINS  L     R3,NAMEADDR        RESTORE IKJNAME PTR\n         TM    1(R3),X'10'        DOES IT HAVE AN INSERT?\n         BZ    KYWDNEXT           NO.\n         SR    R14,R14\n         IC    R14,4(,R3)\n         LA    R1,6(R14,R3)\n         TM    0(R3),X'04'        IS THERE A SUBFIELD?\n         BZ    KYWDINSB           NO.\n         LA    R1,2(,R1)          YES, SKIP OFFSET\nKYWDINSB BAL   R14,INS            INSERT INSERTION\n         MVI   BYPASS,X'00'       RESET BYPASS\n         B     KYWDNEXT           AND CONTINUE\n         TITLE 'CLUTSPAR -- SUBFIELD ERASURE ROUTINE'\n*\n*        THIS ROUTINE ERASES ANY VALUES ESTABLISHED BY SUBFIELDS OF\n*        AN OVERRIDDEN KEYWORD.\n*\nERAS     STM   R14,R3,ESAVE\n         LR    R2,R9              SAVE CURRENT PCE POINTER\n         SPACE\n*\n*        ERASE A KEYWORD. IF THE KEYWORD HAS A SUBFIELD, RECURSE TO\n*        ERASE THE SUBFIELD\n*\nERASKEY  MVC   ALIGN,4(R9)\n         LH    R15,ALIGN\n         A     R15,PDLPTR         ADDRESS THE KEYWORD NUMBER\n         OC    0(2,R15),0(R15)    IS IT 0?\n         BZ    ERASKNXT           YES, CONTINUE\n         MVC   ALIGN,0(R15)\n         LH    R14,ALIGN          NO, SAVE IT\n         LR    R3,R9\n         SPACE\nERASFIND XC    0(2,R15),0(R15)    WIPE OUT THE KEYWORD NUMBER\n         MVC   ALIGN,2(R3)\n         AH    R3,ALIGN\n         BCT   R14,ERASFIND       FIND THE RIGHT IKJNAME PCE\n         TM    0(R3),X'04'        DOES IT HAVE A SUBFIELD?\n         BZ    ERASKNXT           NO.\n         LR    R0,R9              YES, SAVE CURRENT KEYWORD\n         LA    R15,ERASFLD        AND RECURSE TO ERASE SUBFIELD\n         BAL   R14,CURSIN\nERASKNXT CR    R2,R9              ARE WE BACK TO CALLER'S LEVEL?\n         BE    ERASOUT            YES, ALL DONE\n         SPACE\n*\n*        PROCESS THE NEXT PCE\n*\nERASNEXT MVC   ALIGN,2(R9)\n         AH    R9,ALIGN           FIND NEXT PCE\nERASCONT SR    R14,R14\n         IC    R14,0(,R9)         GET PCE TYPE\n         SRL   R14,5\n         SLL   R14,2\n         B     *+4(R14)\n         B     ERASEND            IKJENDP\n         B     ERASPOS            IKJPOSIT\n         B     ERASKEY            IKJKEYWD\n         B     ERASNEXT           IKJNAME, IGNORE\n         B     ERASPOS            IKJIDENT\n         B     ERASWORD           IKJRSVWD\n         B     ERASPOS            IKJTERM\n         B     ERASPOS            IKJOPER\n         SPACE\nERASFLD  ST    R0,KSAVE           SAVE PREVIOUS LEVEL'S KEYWORD PTR\n         B     ERASCONT           AND ERASE SUBFIELD\n         SPACE\n*\n*        ERASE A POSITIONAL\n*\nERASWORD TM    1(R9),X'80'        IS THIS A CHAINED IKJRSVWD?\n         BNZ   ERASNEXT           YES, IGNORE IT\nERASPOS  LR    R1,R9              USE PCE ADDR AS OWNER ID\n         L     R15,=A(CLUZRLSE)\n         BALR  R14,R15            FREE MEMORY OWNED BY PARM\n         MVC   ALIGN,4(R9)\n         LH    R15,ALIGN\n         A     R15,PDLPTR         FIND PDE ADDRESS\n         BAL   R14,SIZE           GET PDE SIZE\n         LTR   R1,R1              IF ANY\n         BZ    ERASNEXT           IF NOT, SKIP THIS ONE\nERASPOS2 TM    1(R9),X'20'        IS THIS A RANGE?\n         BZ    ERASSING           NO.\n         AR    R1,R1              YES, DOUBLE SIZE\n         SPACE\nERASSING STH   R1,ALIGN           SAVE SIZE\n         BCTR  R1,0\n         EX    R1,ERASCLR         CLEAR THE PDE\n         B     ERASNEXT           AND CONTINUE\nERASCLR  XC    0(0,R15),0(R15)    CLEAR PDE\n         SPACE\nERASEND  L     R9,KSAVE           RESTORE PREVIOUS KEYWORD POINTER\n         B     CURSOUT            AND RETURN FROM RECURSION\n         SPACE\nERASOUT  LM    R14,R3,ESAVE\n         BR    R14                RETURN TO ORIGINAL CALLER\n         TITLE 'CLUTSPAR -- SUBFIELD RECURSION ROUTINES'\n*\n*        THIS ROUTINE PROVIDES FOR RECURSION DURING THE PROCESSING\n*        OF SUBFIELDS\n*\nCURSIN   ST    R14,RECRET         STORE RETURN POINT\n         MVC   MYSUB,CURINP       SAVE SOURCE OF SUBFIELD\n         LA    R10,SUBWLEN(,R10)  ON TO NEXT SUBFIELD WORK AREA\n         LA    R1,SUBWEND\n         CR    R10,R1             TOO MANY LEVELS (>5)?\n         BNH   CURSOK             NO, PROCEED\n         BAL   R6,PARSRC12        YES, PARM LIST ERROR\nCURSOK   XC    0(SUBWLEN,R10),0(R10)   CLEAR THE WORK AREA\n         MVI   SUBFLAG,X'FF'      SET SUBFIELD FLAG\n         SR    R9,R9\n         IC    R9,4(,R3)\n         LA    R9,6(R9,R3)\n         MVC   ALIGN,0(R9)\n         LH    R9,ALIGN\n         A     R9,PCL             FIND SUBFIELD START\n         MVC   ALIGN,0(R9)\n         LH    R3,ALIGN\n         A     R3,PCL             FIND FIRST KEYWORD IN FIELD\n         ST    R3,KEY1\n         LA    R9,2(,R9)          FIND FIRST PARM IN FIELD\n         ST    R9,PARM1\n         BR    R15                GO TO DESIRED ROUTINE\n         SPACE 5\n*\n*        THIS ROUTINE IS ENTERED TO RETURN FROM A RECURSION\n*\nCURSOUT  S     R10,=A(SUBWLEN)    DOWN TO PREVIOUS SUBFIELD AREA\n         LA    R1,SUBWORKS\n         CR    R1,R10             REACHED THE BOTTOM?\n         BNE   CURSTILL           NO.\n         MVI   SUBFLAG,0          YES, TURN OFF SUBFIELD FLAG\nCURSTILL XC    OMIT1,OMIT1        FORGET SUBFIELD BACKUP POINT\n         L     R14,MYSUB          FIND SUBFIELD STARTING INPUT SEG\n         C     R14,CBUF           STARTED FROM CMD BUFFER?\n         BE    CURSNDUM           YES, NOT DUMMY\n         NI    PREVINS-INPUT(R14),255-DUMMYSUB   OFF DUMMY ( FLAG\nCURSNDUM XC    MYSUB,MYSUB        SHOW NO SUBFIELD NOW\n         L     R14,RECRET         LOAD RETURN POINT\n         BR    R14                & GO BACK\n         SPACE 3\nSUBWORK  DSECT ,                  SUBFIELD WORK AREA MAPPING\n         SPACE\nKSAVE    DS    6A                 KYWD'S SAVE AREA\nRECRET   EQU   KSAVE+4            RECURSION RETURN POINT\nNAMEADDR DS    A                  CURRENT IKJNAME PTR\nKEY1     DS    A                  1ST KEYWORD IN SUBFIELD/SYNTAX\nPARM1    DS    A                  1ST PARM IN SUBFIELD/SYNTAX\nMYSUB    DS    A                  SOURCE INPUT FOR SUBFIELD/SUBSCRIPT\nSUBWLEN  EQU   *-SUBWORK          LENGTH OF SUBFIELD WORK AREA\n         SPACE\nCLUTSPAR CSECT ,                  RESUME ORIGINAL CSECT\n         TITLE 'CLUTSPAR -- SUBSCRIPT RECURSION ROUTINES'\n*\n*        THIS ROUTINE IS CALLED WHENEVER A SUBSCRIPT LIST MAY APPEAR.\n*        IF PRESENT, IT SAVES STATUS AND ENTERS THE SYN ROUTINE\n*        RECURSIVELY TO HANDLE THE SUBSCRIPTS.\n*\nSUBSIN   STM   R14,R1,PWSAVE      BORROW A SAVE AREA\n         MVC   MYSUB,CURINP       SAVE INPUT SOURCE OF SUBSCRIPTS\n         L     R1,SUBSAVE         HAVE WE ALREADY GOT A WORK AREA?\n         LTR   R1,R1\n         BNZ   SUBSRUSE           YES, REUSE IT\n         LIFO  LV=SUBSLEN         NO, GET ONE\n         ST    R1,SUBSAVE         SAVE THE ADDRESS\nSUBSRUSE MVC   SUBSREGS-SUBSECT(16,R1),PWSAVE   MOVE REGSTERS\n         STM   R2,R3,SUBSREGS-SUBSECT+16(R1)    SAVE A FEW MORE\n         LR    R3,R1\n         USING SUBSECT,R3\n         ST    R9,SUBSVAR         SAVE ADDR OF SUBSCRIPTED VAR PCE\n         LR    R15,R9\n         MVC   ALIGN,2(R9)        FIND FOLLOWING PCE\n         AH    R15,ALIGN\n         BAL   R14,FDEF           FIND DEFAULT/PROMPT\n         TM    0(R9),X'18'        IF ANY\n         BZ    SUBSNDEF\n         SR    R14,R14\n         IC    R14,0(,R1)\n         LA    R1,2(R14,R1)       SKIP PAST IT\nSUBSNDEF MVC   ALIGN,0(R1)        ALIGN SUBSCRIPT PDE OFFSET\n         LH    R14,ALIGN\n         A     R14,PCL\n         CR    R14,R15            ARE THEY THE SAME?\n         BNE   SUBSFAIL           NO, ILLEGAL USAGE\n         MVC   ALIGN(1),0(R15)    MAKE SURE RIGHT TYPE\n         NI    ALIGN,X'E0'\n         CLI   ALIGN,X'C0'        IS IT A TERM?\n         BNE   SUBSFAIL           NO, EXPLODE\n         TM    1(R15),X'B0'       LIST, RANGE OR SUBSCRIPTED?\n         BNZ   SUBSFAIL           YES, NO FORGIVENESS\n         TM    6(R15),X'80'       STATEMENT NUMBER TYPE?\n         BNZ   SUBSFAIL           YES, EVIL.\n         TM    6(R15),X'08'       IS IT OFFICIALLY A SUBSCRIPT?\n         BZ    SUBSFAIL           NO, ERROR\n         LR    R2,R15             SAVE THE PCE POINTER\n         SPACE\n*\n*        IKJPARS ALLOWS A VALIDITY CHECK EXIT FOR AN IKJTERM CHAINED\n*        FROM AN IKJOPER TO DECIDE WHETHER OR NOT THE TERM SHOULD\n*        BE SUBSCRIPTED. (THIS FEATURE IS OF COURSE UNDOCUMENTED.)\n*        AN OPEN PARENTHESIS IMMEDIATELY FOLLOWING SUCH A TERM IS\n*        ALWAYS TAKEN AS A SUBSCRIPT INDICATOR; IF THERE IS A LATER\n*        PARENTHESIS, IT DOES NOT START A SUBSCRIPT UNLESS THE\n*        EXIT SO INDICATES.\n*\n         TM    COBFLAGS,COBIMMSB  OPEN PAREN RIGHT AFTER VAR?\n         BNZ   SUBSYES            YES, MUST BE SUBSCRIPTED\n         XC    COMMAX,COMMAX      CATCH COMMA BEFORE SUBSCRIPT\n         MVI   EXPECT,C'('        SHOW PAREN EXPECTED\n         L     R15,=A(CLUZSKIP)\n         BALR  R14,R15            SKIP DELIMITERS\n         B     *+4(R15)           ANYTHING AFTER?\n         B     SUBSMAYB           YES.\nSUBSRET  LM    R14,R3,SUBSREGS    NO, RESTORE REGS\n         BR    R14                AND RETURN\n         SPACE\nSUBSMAYB CLI   0(R8),C'('         IS THERE A (?\n         BNE   SUBSRET            NO, NO SUBSCRIPTS\n         TM    OPERFLGS,OPERACT+OPEREXPR    WORKING AT LEVEL 88?\n         BNM   SUBSYES            NO.\n         XI    COBFLAGS,COBSUB88  YES, SET/RESET INDICATOR\n         TM    COBFLAGS,COBSUB88  ARE WE READY FOR IT YET?\n         BNZ   SUBSRET            NO, RETURN TO CALL VEXIT\nSUBSYES  NI    COBFLAGS,255-COBSUBOK   YES, TURN OFF SUBSCRIPT OK FLAG\n         MVC   SUBSWORK(SUBSTLEN),SUBSTAT    SAVE STATUS\n         MVC   SUBSFLGS,SUBSOPTS\n         XC    SUBSTAT(SUBSTLEN),SUBSTAT    RESET EVERYTHING\n         XC    SUBSOPTS(SUBOPLEN),SUBSOPTS\n         OI    COBFLAGS,COBSUB    SET SUBSCRIPT FLAG\n         MVI   NESTLEVL,LEVSUBS   START NEW LEVEL FOR SUBSCRIPTS\n         LR    R9,R2              ESTABLISH NEW PCE\n         AR    R8,R6              SKIP THE PAREN\n         MVI   SUBSNO,0           NO SUBSCRIPTS TO START\n         L     R1,SUBSREGS+12     FIND ORIGINAL PDE\n         LA    R1,20(,R1)         FIND PDE FOR SUBSCRIPT 1\n         ST    R1,SUBSPDE         AND STORE FOR LATER\n         XC    COMMAX,COMMAX      NO COMMA BEFORE FIRST SUBSCRIPT\n         B     SYNPOS2            GO GET THOSE SUBSCRIPTS\n         SPACE\nSUBSFAIL BAL   R6,PARSRC24        GIVE SCREAM OF ANGUISH\n         SPACE 5\n*\n*        THIS ROUTINE IS CALLED TO RETURN FROM A SUBSCRIPT RECURSION\n*\nSUBSOUT  CR    R8,R7              ANY TEXT LEFT?\n         BH    SUBSNPRN           NO.\n         AR    R8,R6              YES, SKIP OVER CLOSE PAREN\nSUBSNPRN L     R3,SUBSAVE         FIND THE SUBSECT\n         MVC   SUBSTAT(SUBSTLEN),SUBSWORK   COPY STATUS BACK\n         MVC   SUBSOPTS(SUBOPLEN),SUBSFLGS\n         L     R9,SUBSVAR         RESTORE OLD PCE\n         L     R1,SUBSREGS+12     FIND VARIABLE'S PDE\n         MVC   18(1,R1),SUBSNO    STORE NUMBER OF SUBSCRIPTS\n         L     R1,MYSUB           FIND SUBSCRIPT SOURCE\n         C     R1,CBUF            SUBSCRIPT FROM CMD BUFFER?\n         BE    SUBSNDUM           YES, NOT DUMMY\n         NI    PREVINS-INPUT(R1),255-DUMMYSUB    OFF DUMMY ( FLAG\nSUBSNDUM XC    MYSUB,MYSUB        KILL SUBSCRIPT START PTR\n         MVI   NESTLEVL,LEVITEM   RETURN TO NON-SUBSCRIPT LEVEL\n         TM    RANGEF,RANGE2      WORKING ON PART2?\n         BNZ   SUBSHAS2           YES.\n         OI    COBFLGS1,COBHASUB  SET HAS SUBSCRIPT FLAG\n         B     SUBSRET            AND RETURN\nSUBSHAS2 OI    COBFLGS2,COBHASUB\n         B     SUBSRET\n         SPACE\n         DROP  R3\n         DROP  R10                NO LONGER GUARANTEED\n         TITLE 'CLUTSPAR -- ABNORMAL EXIT ROUTINES'\n         DROP  R11                NO LONGER GUARANTEED\n         SPACE\n*\n*        THESE ROUTINES PROVIDE FOR EXIT FROM PARSE WITH A BAD\n*        RETURN CODE.\n*\nPARSRC8  MVI   RC,8               SET ATTN RETURN CODE\n         B     PARSEXIT\n         SPACE\nPARSERRX BAL   R6,PARSRC12        ENTERED FROM PGM CHECK EXIT\nPARSRC12 MVI   RC,12              SET USER ERROR RET CODE\nPARSGASP L     R1,IOPL            FIND THE UPT\n         TM    UPTSWS-UPT(R1),UPTMID   USER HAVE PROF MSGID?\n         BZ    PARSEXIT           NO, QUIT QUIETLY\n         L     R15,=A(CLUZGASP)   YES, SEND DEBUGGING HINT\n         BALR  R14,R15\n         B     PARSEXIT           AND THEN STOP\n         SPACE\nPARSRC16 MVI   RC,16              SET NO MEMORY RET CODE\n         B     PARSEXIT\n         SPACE\nPARSRC20 MVI   RC,20              SET FORCED QUIT RET CODE\n         B     PARSEXIT\n         SPACE\nPARSRC24 MVI   RC,24              SET BAD COBOL LINKAGE CODE\n         B     PARSGASP           SAY WHERE ERROR DETECTED\n         SPACE\n         AIF   ('&OPSYS' NE 'MVS').NMVS8A\nPARSRC28 MVI   RC,28              SET DISCONNECT RETURN CODE\n.NMVS8A  ANOP\nPARSEXIT LIGOTO GIVEUP            RETURN TO INITAL LEVEL & QUIT\n         TITLE 'CLUTSPAR -- SUBROUTINE RETURN CODE'\n*\n*        THIS CODE IS CALLED TO RETURN FROM A SUBROUTINE, WITHOUT\n*        RESTORING THE INPUT POINTER REGISTERS (R7 AND R8)\n*\nRETURN   L     R14,4(,RDSA)       FIND PREVIOUS SAVE AREA\n         STM   R7,R8,48(R14)      SAVE BUFFER POSITION REGS\n         LIEXIT RC=(15)           NOW REALLY RETURN\n         TITLE 'CLUTSPAR -- COMMIT/ROLLBACK INTERFACE ROUTINES'\n*\n*        THIS ROUTINE CALLS THE MEMORY COMMITMENT ROUTINE IF MEMORY\n*        MANAGEMENT HAS BEEN INVOKED FOR THIS PARAMETER.\n*\nCMIT     TM    ALCFLAGS,ACPTREQ   IS ACCEPT NEEDED?\n         BCR   8,R14              NO, NOTHING TO COMMIT\n         CLC   NESTLEVL,ALCLEVEL  ALLOCATION AT THAT LEVEL?\n         BCR   2,R14              NO, NOTHING TO DO\n         STM   R14,R15,CSAVE      YES, SAVE SPECIAL REGS\n         L     R15,=A(CLUZCMIT)   FIND FULL COMMIT ROUTINE\n         BALR  R14,R15            AND CALL IT\n         LM    R14,R15,CSAVE      RESTORE REGS\n         BR    R14                AND RETURN\n         SPACE 5\n*\n*        THIS ROUTINE CALLS THE MEMORY ROLLBACK ROUTINE IF MEMORY\n*        MANAGEMENT HAS BEEN INVOKED FOR THIS PARAMETER.\n*\nRLBK     TM    ALCFLAGS,ACPTREQ   IS ACCEPT NEEDED?\n         BCR   8,R14              NO, NOTHING TO ROLLBACK\n         CLC   NESTLEVL,ALCLEVEL  ALLOCATION AT THAT LEVEL?\n         BCR   2,R14              NO, NOTHING TO DO\n         STM   R14,R15,CSAVE      YES, SAVE SPECIAL REGS\n         L     R15,=A(CLUZRLBK)   FIND FULL ROLLBACK ROUTINE\n         BALR  R14,R15            AND CALL IT\n         LM    R14,R15,CSAVE      RESTORE REGS\n         BR    R14                AND RETURN\n         TITLE 'CLUTSPAR -- DETERMINE PDE SIZE ROUTINE'\n*\n*        THIS ROUTINE DETERMINES THE SIZE OF A PDE\n*\nSIZE     LA    R1,8               ASSUME SIZE IS 8\n         MVC   ALIGN(1),0(R9)\n         NI    ALIGN,X'E0'\n         CLI   ALIGN,X'20'\n         BE    SIZPOSIT\n         CLI   ALIGN,X'C0'\n         BE    SIZTERM\n         BR    R14\nSIZPOSIT IC    R1,6(,R9)          NO, LOAD IKJPOSIT TYPE\n         IC    R1,PDESIZES-1(R1)  AND LOAD SIZE FROM TABLE\n         BR    R14\nSIZTERM  LA    R1,80              SIZE OF SUBSCRIPTED IKJTERM\n         TM    1(R9),X'10'        MAY IT BE SUBSCRIPTED?\n         BCR   7,R14              YES, RETURN\n         LA    R1,20              NON-SUBSCRIPTED SIZE\n         TM    6(R9),X'08'        IS THIS A SUBSCRIPT ITSELF?\n         BCR   8,R14              NO, RETURN\n         SR    R1,R1              YES, GIVE 0 SIZE\n         BR    R14\n         TITLE 'CLUTSPAR -- TEXT INSERTION ROUTINE'\n*\n*        THIS ROUTINE INSERTS A DEFAULT OR A KEYWORD INTO THE TEXT\n*        TO BE PARSED\n*\nINS      ST    R14,ISAVE          SAVE RETURN POINT\n         SR    R14,R14\n         IC    R14,0(,R1)         GET LENGTH OF INSERTION\n         LA    R14,1(,R14)\n         STH   R14,ALIGN\n         LA    R1,1(,R1)          POINT TO INSERT TEXT\n         L     R14,ISAVE\n         L     R15,=A(CLUZPUSH)   AND PUSH DOWN ON INPUT STACK\n         BR    R15\n         TITLE 'CLUTSPAR -- \"INCOMPLETE RANGE\" MESSAGE ROUTINE'\n*\n*        THIS ROUTINE WRITES AN \"INCOMPLETE RANGE\" MESSAGE AND PROMPTS\n*        FOR ENTRY OF THE SECOND VALUE\n*\nRINC     STM   R14,R3,MSAVE\n         OI    RANGEF,RANGE0      SET INCOMPLETE FLAG\n         MVC   MSGAREA(4),=A(INCOMPLE) \"INCOMPLETE \"\n         MVC   MSGAREA+4(4),=A(RANGE)  \"RANGE\"\n         MVC   MSGAREA+8(4),ACOLON     :\n         MVI   MSGAREA+12,X'0D'   PUT TEXT AFTER\n         MVC   MSGAREA+16(4),=A(COLON)      :\n         MVI   MSGAREA+16,X'03'   LAST OF MESSAGE\n         LA    R1,MSGAREA\n         L     R15,=A(CLUZINFO)\n         BALR  R14,R15            SEND \"INCOMPLETE RANGE: X:\"\n         NI    RANGEF,255-RANGE0  RESET ERROR BIT\n         L     R14,=A(ENTERID)\n         ST    R14,MSGAREA\n         MVC   MSGID,4(R14)       SAVE PROMPT MSGID\n         MVC   MSGAREA+4(4),=A(ENTER)  \"ENTER \"\n         MVC   MSGAREA+8(4),=A(SECOND) \"SECOND \"\n         BAL   R14,FDSC           FIND DESCRIPTION\n         ST    R1,MSGAREA+12      ADD DESCRIPTION TO MESSAGE\n         OI    MSGAREA+12,X'02'   SET END FLAG\n         SR    R2,R2              ASSUME NO HELP\n         TM    0(R9),X'02'        HOW ABOUT IT?\n         BZ    INVREEN            RIGHT, SEND \"ENTER SECOND DESC -\"\n         B     INVHELP            NO, GO PROMPT WITH HELP\n         TITLE 'CLUTSPAR -- \"INCOMPLETE EXPRESSION\" MESSAGE ROUTINE'\n*\n*        THIS ROUTINE WRITES AN \"INCOMPLETE EXPRESSION\" MESSAGE AND\n*        PROMPTS FOR ENTRY OF AN OPERAND OR OPERATOR.\n*\nXINC     STM   R14,R3,MSAVE       SAVE REGISTERS\n         MVC   MSGAREA(4),=A(INCOMPLE) \"INCOMPLETE \"\n         LR    R2,R9              SAVE CALLER'S R9\n         L     R9,OPERPCE         FIND ORIGINAL IKJOPER\n         BAL   R14,FDSC           FIND ITS DESCRIPTION\n         ST    R1,MSGAREA+4       ADD TO MESSAGE\n         MVC   MSGAREA+8(4),ACOLON     :\n         MVI   MSGAREA+12,X'0F'   ADD PARTIAL EXPRESSION AFTER\n         OI    RANGEF,RANGE2      SET RANGE2 FLAG TO WRITE FULL EXPR\n         OI    OPERFLGS,OPERINV   INDICATE OPER ERROR\n         OI    COBFLAGS,COBFORM   FORCE COBOL MESSAGE FORMAT\n         LA    R1,MSGAREA\n         L     R15,=A(CLUZINFO)\n         BALR  R14,R15            SEND \"INCOMPLETE XXX: (YYY\"\n         MVI   RANGEF,0           RESTORE VARIOUS FLAGS\n         NI    OPERFLGS,255-OPERINV\n         NI    COBFLAGS,255-COBFORM\n         LR    R9,R2              RESTORE ORIGINAL PCE PTR\n         L     R2,=A(ENTERID)\n         ST    R2,MSGAREA\n         MVC   MSGID,4(R2)        SAVE PROMPT'S MSGID\n         MVC   MSGAREA+4(4),=A(ENTER)  \"ENTER \"\n         CLI   OPERPART,2         WHICH PART DO WE NEED?\n         BE    XINC1              1ST OPERAND\n         BH    XINC2              2ND OPERAND\n         MVC   MSGAREA+8(4),=A(OPERATOR)    \"OPERATOR\"\n         MVI   MSGAREA+8,X'02'    INDICATE THE END\n         B     XINCPROM           JOIN OTHER CASES\nXINC1    MVC   MSGAREA+8(4),=A(FIRST)  \"FIRST \"\n         B     XINCAND\nXINC2    MVC   MSGAREA+8(4),=A(SECOND) \"SECOND \"\nXINCAND  MVC   MSGAREA+12(4),=A(OPERAND)     \"OPERAND\"\n         OI    MSGAREA+12,X'02'   INDICATE MSG END\nXINCPROM SR    R2,R2              INDICATE NO LEVEL 2 TEXT\n         B     INVREEN            GO TO REQUEST REENTRY\n         TITLE 'CLUTSPAR -- \"INVALID POSITIONAL\" MESSAGE ROUTINE'\n*\n*        THIS ROUTINE PUTS OUT AN \"INVALID\" MESSAGE FOR AN INVALID\n*        POSITIONAL PARAMETER\n*\nINV      STM   R14,R3,MSAVE       SAVE REGS IN MSG AREA\n         MVC   MSGAREA(4),=A(INVALID)  \"INVALID \"\n         MVC   MSGAREA+4(4),=A(QUALFOR)     \"QUALIFIER FOR \"\n         TM    COBFLAGS,QUALFLG   PROMPTING FOR COBOL QUALIFIER?\n         BNZ   INVQUAL            YES.\n         OI    MSGAREA+4,X'80'    NO, SUPPRESS QUALIFIER\nINVQUAL  BAL   R14,FDSC           FIND DESCRIPTION\n         ST    R1,MSGAREA+8\n         MVC   MSGAREA+12(4),ACOLON    :\n         MVI   MSGAREA+16,X'0F'   REJECTED TEXT\n         LA    R1,MSGAREA\n         L     R15,=A(CLUZINFO)\n         BALR  R14,R15            SEND \"INVALID DESC: X\"\n         SPACE\n*\n*        PROMPT FOR REENTRY\n*\nINVENTRY SR    R2,R2              ASSUME NO HELP\n         L     R14,=A(REENTER)\n         ST    R14,MSGAREA        \"REENTER\"\n         OI    MSGAREA,X'02'\n         MVC   MSGID,4(R14)       SAVE REENTER MSGID\n         TM    0(R9),X'02'        IS THERE HELP?\n         BZ    INVREEN            NO.\nINVHELP  BAL   R14,FDEF           FIND THE PROMPT\n         BAL   R14,FHLP           SKIP TO HELP\n         LA    R2,2(,R1)          SKIP OVER THE HELP LENGTH\nINVREEN  LA    R1,MSGAREA\n         L     R15,=A(CLUZPROM)\n         BALR  R14,R15            ISSUE \"REENTER -\"\n         NI    COBFLAGS,255-QUALFLG\n         ST    R15,MSAVE+4        PASS RET CODE TO CALLER\n         LM    R14,R3,MSAVE\n         BR    R14                AND RETURN\n         SPACE 3\n*\n*        ALTERNATE ENTRY TO INV TO JUST DO THE REENTER PROMPT\n*\nINVRENT  STM   R14,R3,MSAVE\n         TM    RANGEF,RANGERR     ENTRY FOR REJECTED RANGE?\n         BZ    INVENTRY           NO, NORMAL CASE\n         MVI   RANGEF,0           YES, RESET RANGE FLAGS\n         MVC   MSGAREA(4),=A(REENTER)  \"REENTER\"\n         BAL   R14,FDSC           FIND DESCRIPTION\n         MVC   MSGAREA+4(4),=A(BLANK)  ADD A SPACE\n         ST    R1,MSGAREA+8       ADD TO MESSAGE\n         MVC   MSGAREA+12(4),=A(RCOLON)     :\n         ST    R1,MSGAREA+16      ADD AGAIN\n         OI    MSGAREA+16,X'02'   SET END FLAG\n         SR    R2,R2              ASSUME NO HELP\n         TM    0(R9),X'02'        WERE WE RIGHT?\n         BZ    INVREEN            YES.\n         B     INVHELP            GO SEND \"REENTER DESC:DESC -\"\n         TITLE 'CLUTSPAR -- \"EVIL KEYWORD\" MESSAGE ROUTINE'\n*\n*        THIS ROUTINE WRITES A BAD KEYWORD MESSAGE AND PROMPTS FOR\n*        REENTRY\n*\nKERR     STM   R14,R3,MSAVE       SAVE REGS\n         ST    R1,MSGAREA         STORE TYPE-OF-BADNESS IN MESSAGE\n         MVC   MSGAREA+4(4),=A(KEYWORD)     ADD \"KEYWORD\"\n         MVC   MSGAREA+8(4),ACOLON     :\n         MVI   MSGAREA+12,X'0F'   ADD TEXT\n         LA    R1,MSGAREA\n         L     R15,=A(CLUZINFO)\n         BALR  R14,R15            SEND \"WICKED KEYWORD\"\n         B     REENKEY            GO ASK FOR REENTRY\n         TITLE 'CLUTSPAR -- \"REENTER\" MESSAGE ROUTINE'\n*\n*        THIS ROUTINE ISSUES A NON-SPECIFIC \"REENTER\" PROMPT\n*\nREEN     STM   R14,R3,MSAVE       SAVE REGS\nREENKEY  SR    R2,R2              SET NO HELP\n         MVC   MSGAREA(4),=A(REENTER)  \"REENTER\"\n         OI    MSGAREA,X'02'      SET END FLAG\n         LA    R1,MSGAREA\n         L     R15,=A(CLUZPROM)\n         BALR  R14,R15            PROMPT WITH \"REENTER -\"\n         L     R14,MSAVE          PRESERVE RETURN CODE\n         LM    R0,R3,MSAVE+8\n         BR    R14                AND RETURN\n         TITLE 'CLUTSPAR -- \"OVERRIDING KEYWORD\" MESSAGE ROUTINE'\n*\n*        THIS ROUTINE WRITES AN \"OVERRIDING KEYWORD\" WARNING\n*\nKOVR     STM   R14,R1,MSAVE\n         MVC   MSGAREA(4),=A(OVERRIDE)      OVERRIDING KEYWORD ACCEPTED\n         MVC   MSGAREA+4(4),ACOLON     :\n         MVI   MSGAREA+8,X'0F'    ADD TEXT TO MESSAGE\n         LA    R1,MSGAREA\n         L     R15,=A(CLUZINFO)\n         BALR  R14,R15            SEND \"OVERRIDING KEYWORD ACCEPTED: X\"\n         LM    R14,R1,MSAVE\n         BR    R14                AND RETURN\n         TITLE 'CLUTSPAR -- \"CLOSING QUOTE ASSUMED\" MESSAGE ROUTINE'\n*\n*        THIS ROUTINE IS CALLED TO WRITE A \"CLOSING QUOTE ASSUMED\"\n*        MESSAGE FOR A RECOGNIZER\n*\nUNCL     STM   R14,R1,MSAVE       SAVE REGS\n         MVC   MSGAREA(4),=A(ASSUMED)  \"CLOSING QUOTE ASSUMED\"\n         MVC   MSGAREA+4(4),ACOLON      :\n         MVI   MSGAREA+8,X'0F'    ADD TEXT TO MESSAGE\n         LA    R1,MSGAREA\n         L     R15,=A(CLUZINFO)\n         BALR  R14,R15            SEND \"CLOSING QUOTE ASSUMED: 'X\"\n         LM    R14,R1,MSAVE\n         BR    R14                AND RETURN\n         TITLE 'CLUTSPAR -- FIND NEXT UNCHAINED PCE ROUTINE'\n*\n*        THIS ROUTINE IS CALLED TO FIND THE NEXT PCE WHICH IS NOT A\n*        SUBSCRIPT TERM, A CHAINED RESERVED WORD, OR AN IKJNAME.\n*\nFNXT     MVC   ALIGN,2(R9)        GET SIZE OF THIS PCE\n         LR    R1,R9\n         AH    R1,ALIGN           LOOK AT NEXT PCE\nFNXTAGN  MVC   ALIGN(1),0(R1)     WHAT TYPE IS THIS ONE?\n         NI    ALIGN,X'E0'\n         CLI   ALIGN,X'60'        IKJNAME?\n         BE    FNXTLOOP           YES, SKIP IT\n         CLI   ALIGN,X'A0'        IKJRSVWD?\n         BE    FNXTWORD           YES.\n         CLI   ALIGN,X'C0'        IKJTERM?\n         BCR   7,R14              NO, RETURN (R1->PCE)\n         TM    6(R1),X'08'        YES, IS IT A SUBSCRIPT\n         BCR   8,R14              NO, RETURN THIS\n         B     FNXTLOOP           YES, SKIP IT\nFNXTWORD TM    1(R1),X'80'        IS THIS A CHAINED WORD?\n         BCR   8,R14              NO, THIS IS IT\nFNXTLOOP MVC   ALIGN,2(R1)\n         AH    R1,ALIGN           SKIP PAST THIS PCE\n         B     FNXTAGN            AND CONTINUE\n         TITLE 'CLUTSPAR -- FIND PARAMETER DESCRIPTION ROUTINE'\n*\n*        LOCATE THE PARAMETER DESCRIPTOR IN THE PCE (OR FIND IN-LINE\n*        CONSTANT)\n*\nFDSC     MVC   ALIGN(1),0(R9)\n         NI    ALIGN,X'E0'        ISOLATE PARM TYPE\n         CLI   ALIGN,X'C0'\n         BE    FDSCTERM\n         CLI   ALIGN,X'20'\n         BE    FDSCPOS\n         CLI   ALIGN,X'80'\n         BE    FDSCIDEN\n         LA    R1,6(,R9)          LOCATE DESCRIPTION IN PCE\n         BR    R14                AND RETURN\nFDSCIDEN LA    R1,9(,R9)          OFFSET IS 9 FOR IKJIDENT\n         BR    R14\nFDSCTERM LA    R1,7(,R9)          OFFSET IS 7 FOR IKJTERM\n         BR    R14\nFDSCPOS  SR    R1,R1\n         IC    R1,6(,R9)          FIND IKJPOSIT TYPE\n         SLL   R1,2\n         L     R1,POSITID-4(R1)   FIND INLINE DESCRIPTION\n         AIF   ('&OPSYS' NE 'MVS').NMVS6H\n         C     R1,POSITID+24      IS IT DSN-LIKE?\n         BCR   7,R14              NO, RETURN\n         TM    1(R9),X'01'        YES, DDNAME MODIFIED?\n         BCR   8,R14              NO.\n         L     R1,=A(DDNID)       YES, DESCRIBE AS DDNAME\n.NMVS6H  ANOP\n         BR    R14                AND RETURN\n         TITLE 'CLUTSPAR -- FIND HELP INFORMATION ROUTINE'\n*\n*        LOCATE THE HELP INFORMATION IN THE PCE.\n*\nFHLP     TM    0(R9),X'18'        IS THERE A DEFAULT OR PROMPT?\n         BZ    FHLPNDEF           NO.\n         MVI   ALIGN,X'00'        YES, GET ITS LENGTH\n         MVC   ALIGN+1(1),0(R1)\n         AH    R1,ALIGN           AND SKIP PAST IT\n         LA    R1,2(,R1)\nFHLPNDEF MVC   ALIGN(1),0(R9)\n         NI    ALIGN,X'E0'        GET PCE TYPE\n         CLI   ALIGN,X'C0'        IS IT A TERM?\n         BCR   7,R14              NO, RETURN\n         TM    1(R9),X'10'        YES, IS THERE A SUBSCRIPT?\n         BZ    FHLPNSUB           NO.\n         LA    R1,2(,R1)          YES, SKIP PAST OFFSET\nFHLPNSUB TM    1(R9),X'08'        IS THERE A CHAINED WORD?\n         BCR   8,R14              NO, RETURN\n         LA    R1,2(,R1)          YES, SKIP OFFSET\n         BR    R14                AND THEN RETURN\n         TITLE 'CLUTSPAR -- FIND DEFAULT/PROMPT INFORMATION ROUTINE'\n*\n*        LOCATE DEFAULT/PROMPT INFORMATION IN PCE\n*\nFDEF     MVC   ALIGN(1),0(R9)\n         NI    ALIGN,X'E0'        DETERMINE PCE TYPE\n         TM    ALIGN,X'A0'\n         BO    FDEFWORD\n         CLI   ALIGN,X'80'\n         BE    FDEFID\n         CLI   ALIGN,X'40'\n         BE    FDEFKEY\n         CLI   ALIGN,X'C0'\n         BE    FDEFTERM\n         LA    R1,7(,R9)          ELSE OFFSET IS 7\n         BR    R14\n         SPACE\nFDEFID   LA    R1,9(,R9)\n         MVC   ALIGN,9(R9)\n         AH    R1,ALIGN\n         TM    1(R9),X'04'        IS THIS A USER TYPE?\n         BCR   7,R14              YES, RETURN\n         TM    6(R9),X'40'        IS THERE A MAXLNTH?\n         BCR   8,R14              NO, GOT IT\n         LA    R1,1(,R1)          YES, SKIP PAST MAXLNTH\n         BR    R14\n         SPACE\nFDEFWORD LA    R1,6(,R9)          SKIP OVER PARM TYPE\n         MVC   ALIGN,6(R9)\n         AH    R1,ALIGN\n         TM    0(R9),X'40'        IS THIS A RESERVED WORD?\n         BCR   8,R14              YES.\n         LA    R1,8(,R1)          NO, SKIP OVER IKJOPER STUFF\n         BR    R14\n         SPACE\nFDEFKEY  LA    R1,6(,R9)          KEYWORD OFFSET IS 6\n         BR    R14\n         SPACE\nFDEFTERM LA    R1,7(,R9)\n         MVC   ALIGN,7(R9)\n         AH    R1,ALIGN\n         BR    R14\n         TITLE 'CLUTSPAR -- DATA AREAS'\nPGMODEL  PUTGET OUTPUT=(*-*,SINGLE,PROMPT),MF=L  PROMPT PARM LIST\n         SPACE\nRECOGS   DC    A(CLUZDLIM,CLUZSTRG,CLUZVALU,CLUZADDR) RECOGNIZER ADDRS\n         DC    A(CLUZPSTR,CLUZUSID,CLUZDSNM,CLUZDSNM)\n         DC    A(CLUZQSTR,CLUZSPAC)\n         AIF   ('&OPSYS' NE 'MVS').NMVS4A\n         DC    A(CLUZJOBN,CLUZUSID,CLUZADDR)\n.NMVS4A  ANOP\nPOSITID  DC    A(0,STRINGID,VALUEID,ADDRID,STRINGID) POSIT NAME ADDRS\n         DC    A(USERID,DSNID,DSNID,STRINGID,0)\n         AIF   ('&OPSYS' NE 'MVS').NMVS4B\n         DC    A(JOBID,USERID,ADDRID)\n.NMVS4B  ANOP\nPDESIZES DC    AL1(0,8,8,36,8,16,24,24,8,0) POSIT PDE SIZES\n         AIF   ('&OPSYS' NE 'MVS').NMVS4C\n         DC    AL1(16,24,36)\n.NMVS4C  ANOP\n         SPACE\nNULL     DC    0A(0),X'FF000000'  END-OF-LIST INDICATOR\nACOLON   DC    X'01',AL3(COLON)   SUPPRESSIBLE COLON\nBYPSEG   DC    AL2(6,4)           SEGMENT FOR INSERTING BYPASS CHAR\nBYCHAR   DC    X'24'              BYPASS CHARACTER\n         DC    X'15'              FORCE NEW LINE AFTER BYPASS\nRESTCHAR DC    X'14'              RESTORE CHARACTER\nPDOTS    DC    C'(...)'           SUBSCRIPT INDICATOR\n         SPACE 3\n         DS    0H\nPATCH    DC    24CL5'PATCH'       REPAIR AREA\n         SPACE\n         USING DSA,RDSA\n         TITLE 'CLUZSKIP -- SKIP DELIMITERS ROUTINE'\nCLUTSERV LISECT ,                 GENERAL SERVICE ROUTINES\n         SPACE\n*\n*        THIS ROUTINE SKIPS SEPARATORS TO FIND THE NEXT TEXT\n*\nCLUZSKIP LIENTRY DSALEN=88,DSA=*,ENV=R5\n         LH    R3,COMMAS         LOAD LEFT-OVER COMMA COUNT\n         XC    COMMAS,COMMAS     AND RESET TO ZERO\n         SPACE\n*\n*        SEE IF THE CURRENT TEXT SEGMENT IS USED UP\n*\nSKIPSEGS CR    R8,R7              AT END OF CURRENT SEGMENT?\n         BNH   SKIPIN             NO, PROCEED\n         TM    SKIPF,NOSKIP       YES, ARE WE FORBIDDEN TO SKIP?\n         BNZ   SKIPEND            YES, GIVE NO TEXT RETURN CODE\nSKIPPOP  L     R1,CURINP          FIND CURRENT INPUT\n         C     R1,CBUF            ARE WE IN ORIGINAL INPUT?\n         BE    SKIPEND            YES, NO TEXT LEFT\n         TM    DEFTINPT,DEFTINS   ARE WE PROCESSING A DEFAULT?\n         BNZ   SKIPEND            YES, GO NO FURTHER\n         TM    PREVINS-INPUT(R1),DUMMYSUB   IS THIS INPUT A DUMMY      *\n                                            SUBFIELD/SUBSCRIPT?\n         BNZ   SKIPEND            YES, GO NO FURTHER\n         AIF   ('&OPSYS' NE 'MVS').NMVS10B\n         TM    INSFLAG,PSWDCONF   PASSWORD CONFIRMATION ACTIVE?\n         BNZ   SKIPEND            YES, DON'T POP THE STACK\n.NMVS10B L     R15,=A(CLUZPOPS)\n         BALR  R14,R15            NO, POP TEXT FROM STACK\n         AH    R3,COMMAS          ADD COMMAS FROM OLD ELEMENT\n         XC    COMMAS,COMMAS      RESET COUNT TO ZERO\n         B     SKIPSEGS           AND CHECK AGAIN\n         SPACE\n*\n*        INDICATE NO MORE TEXT TO CALLER\n*\nSKIPEND  LA    R2,4               NO TEXT RET CODE\n         LTR   R3,R3              ANY COMMAS ENCOUNTERED?\n         BNZ   SKIPWARN           YES, WARNING REQUIRED\n         B     SKIPAWAY           NO, RETURN\n         SPACE\n*\n*        SEPARATORS ARE BLANK, TAB, COMMA, SEMICOLON AND SLASH\n*\nSKIPIN   TM    SKIPF,NOSKIP       ARE WE FORBIDDEN TO SKIP?\n         BNZ   SKIPTEXT           YES, JUST SAY NOT ENDED\nSKIPLOOP SR    R2,R2\n         IC    R2,0(,R8)          LOAD NEXT CHARACTER\n         LA    R2,SCANTAB(R2)\n         TM    0(R2),X'10'        IS IT A SEPARATOR?\n         BZ    SKIPTEXT           NO, TEXT FOUND\n         CLI   0(R8),C','         YES, IS IT A COMMA?\n         BE    SKIPCOMA           YES, PROCESS\n         CLI   0(R8),C';'         NO, SEMI-COLON?\n         BE    SKIPSEMI           YES.\n         CLI   0(R8),C'/'         TRY SLASH\n         BE    SKIPSLSH           YES.\nSKIPNEXT BXLE  R8,R6,SKIPLOOP     SKIP TO NEXT CHARACTER\n         B     SKIPPOP            POP STACK WHEN END REACHED\n         SPACE\n*\n*        IKJPARS COMPATIBILITY REQUIRES THAT MULTIPLE COMMAS BE\n*        IGNORED. FORCE A WARNING MESSAGE IN THIS CASE, OR ANY\n*        TIME A COMMA IS USED OTHER THAN TO SEPARATE TWO\n*        OPERANDS\n*\nSKIPCOMA TM    SKIPF,NOCOMMA      TREAT COMMA AS BLANK?\n         BNZ   SKIPNEXT           YES, JUST CONTINUE\n         TM    INSFLAG,VIRGINP    NO, COMMA FIRST IN INPUT LINE?\n         BZ    SKIPCNT            NO, MAY BE OK\n         LH    R3,COMMAX          YES, FORCE A WARNING\nSKIPCNT  AR    R3,R6              ADD 1 TO COMMA COUNT\n         B     SKIPNEXT           AND CONTINUE\n         SPACE\n*\n*        A SEMI-COLON, OUTSIDE PARENTHESES, IN ORIGINAL INPUT,\n*        ALWAYS STOPS THE SCAN.\n*\nSKIPSEMI CLI   SUBFLAG,0          IN A SUBFIELD?\n         BNE   SKIPTEXT           YES, DON'T STOP\n         CLI   LISTF,0            IN A LIST?\n         BNE   SKIPTEXT           YES, DON'T STOP\n         CLC   CURINP,CBUF        IN ORIGINAL TEXT?\n         BNE   SKIPTEXT           NO, CONTINUE\n         LR    R7,R8              MAKE SEMICOLON AFTER TEXT END\n         BCT   R7,SKIPEND         AND STOP THE SCAN\n         SPACE\nSKIPSLSH EQU   *\n         AIF   ('&OPSYS' NE 'MVS').NMVS1A\n*\n*        WHEN A SLASH IS FOUND, CHECK FOR /* STARTING A COMMENT\n*\n         CR    R8,R7              ROOM FOR A *?\n         BNL   SKIPNCOM           NO.\n         CLI   1(R8),C'*'         YES, IS IT THERE?\n         BNE   SKIPNCOM           NO, NO COMMENT\n         AR    R8,R6              YES, SKIP IT\n*\n*        LOOK FOR THE END OF COMMENT. END OF TEXT IS TREATED AS\n*        END OF COMMENT\n*\nSKIPSKIM BXH   R8,R6,SKIPPOP      CONTINUE TILL THE END\nSKIPCONT CLI   0(R8),C'*'         * FOUND?\n         BNE   SKIPSKIM           NO, NO END YET\n         BXH   R8,R6,SKIPPOP      YES, MOVE TO NEXT CHAR\n         CLI   0(R8),C'/'         */?\n         BNE   SKIPSKIM           NO.\n         B     SKIPNEXT           YES, RESUME ORIGINAL SEARCH\n         SPACE\nSKIPNCOM EQU   *\n.NMVS1A  ANOP\n*\n*        IF CALLER PERMITS, NOTE PRESENCE OF SLASH AND CONTINUE\n*\n         TM    SKIPF,SLASH1+NOSLASH    DOES SLASH MEAN BYPASS?\n         BNZ   SKIPTEXT           NO.\n         OI    SKIPF,SLASH1       YES, SET FLAG\n         MVI   BYPASS,X'FF'       SET BYPASS FLAG\n         B     SKIPNEXT           AND CONTINUE\n         SPACE\n*\n*        WE HAVE A NON-SEPARATOR. IF IT IS A FUNCTIONAL CLOSE\n*        PARENTHESIS PRECEDED BY A COMMA, FORCE A WARNING\n*\nSKIPTEXT SR    R2,R2              LOAD \"TEXT FOUND\" RETURN CODE\n         LTR   R3,R3              ANY COMMAS ENCOUNTERED?\n         BZ    SKIPAWAY           NO.\n         CLI   0(R8),C')'         YES, CLOSE PAREN HIT?\n         BNE   SKIPEXP            NO.\n         CLI   SUBFLAG,0          YES, IN A SUBFIELD?\n         BNE   SKIPWARN           YES, WARNING REQUIRED\n         CLI   LISTF,0            DOES IT END A LIST?\n         BNE   SKIPWARN           WARN IF SO\n         TM    COBFLAGS,COBSUB    CHECK FOR END OF SUBSCRIPTS\n         BNZ   SKIPWARN\n         TM    OPERFLGS,OPERACT+OPEREXPR    OR END OF EXPRESSION\n         BO    SKIPWARN\n         SPACE\n*\n*        SEE IF OUR CALLER WAS EXPECTING A PARTICULAR CHARACTER.\n*        IF SO, AND IT WAS NOT FOUND, SKIP THE WARNING FOR NOW AND\n*        SAVE THE COMMA COUNT FOR LATER.  THIS LETS THE WARNING\n*        COME OUT AT A MORE NATURAL TIME\n*\nSKIPEXP  CLI   EXPECT,X'00'       EXPECTING SOMETHING PARTICULAR?\n         BE    SKIPANY            NO.\n         CLC   EXPECT,0(R8)       YES, IS THAT WHAT WE HAVE?\n         BE    SKIPANY            YES.\n         STH   R3,COMMAS          NO, SAVE COMMA COUNT FOR NEXT CALL\n         B     SKIPAWAY           AND JUST RETURN\n         SPACE\nSKIPANY  CH    R3,COMMAX          MORE COMMAS THAN ALLLOWED?\n         BNH   SKIPAWAY           NO, NO WARNING NEEDED\nSKIPWARN MVC   MSGAREA(4),=A(EXTRACOM) YES, GIVE WARNING\n         OI    MSGAREA,X'02'\n         LA    R1,MSGAREA\n         L     R15,=A(CLUZINFO)\n         BALR  R14,R15            SEND \"EXTRANEOUS COMMA(S) IGNORED\"\n         SPACE\nSKIPAWAY NI    SKIPF,255-SLASH1   RESET RECENT SLASH FLAG\n         MVI   EXPECT,X'00'       CANCEL ANY EXPECTATIONS\n         STH   R6,COMMAX          ASSIGN DEFAULT MAXIMUM COMMAS\n         NI    INSFLAG,255-VIRGINP     SHOW USE OF INPUT LINE\n         LR    R15,R2             COPY RETURN CODE\n         B     RETURN\n         TITLE 'CLUZPUSH/CLUZPOPS -- INPUT STACK MANAGEMENT ROUTINES'\n*\n*        PUSH TEXT ON THE INPUT STACK\n*\nCLUZPUSH LIENTRY DSALEN=88,DSA=*,ENV=R5,PARM=R3\n         LH    R2,ALIGN           LOAD LENGTH OF STRING\n         LA    R1,INPLEN(,R2)     ADD CHAIN LENGTH\n         OI    ALCFLAGS,COLECTIV  SET COLLECTIVE STORAGE FLAG\n         L     R15,=A(CLUZALOC)\n         BALR  R14,R15            GET MEMORY FOR TEXT\n         L     R1,NEWMEM\n         USING INPUT,R1\n         MVC   INPCHAIN,CURINP    SAVE CHAIN INFORMATION\n         ST    R1,CURINP          SET NEW CURRENT INPUT\n         STM   R7,R8,PREVEND\n         MVC   BYPASS,PCBYPASS    RESET BYPASS FLAG\n         MVC   PREVINS,INSFLAG\n         MVI   INSFLAG,INSERTED   SET INSERTION FLAG\n         MVC   PREVDEFT,DEFTINPT\n         MVC   DEFTINPT,DEFTF     COPY DEFAULT INPUT FLAG\n         NI    DEFTF,255-DEFTINS  AND RESET\n         MVC   PREVCOMS,COMMAS    SAVE COMMA COUNT FROM PREVIOUS\n         XC    COMMAS,COMMAS      AND MAKE NEW COUNT 0\n         DROP  R1\n         LA    R8,INPLEN(,R1)     POINT TO TEXT START\n         LA    R7,0(R8,R2)        POINT TO TEXT END\n         BCTR  R7,0\n         LR    R2,R8              COPY TEXT TO STACK  ELEMENT\n         LA    R14,256\n         LR    R15,R7\n         SR    R15,R14\n         SR    R2,R14\nPUSHLOOP BXH   R2,R14,PUSHLAST\n         MVC   0(256,R2),0(R3)\n         AR    R3,R14\n         B     PUSHLOOP\n         SPACE\nPUSHLAST SR    R15,R2\n         EX    R15,PUSHMOVE\n         B     RETURN             AND THEN RETURN\nPUSHMOVE MVC   0(0,R2),0(R3)      MOVE TEXT TO INPUT STACK\n         EJECT\n*\n*        POP THE INPUT STACK\n*\nCLUZPOPS LIENTRY DSA=*,DSALEN=88,ENV=R5\n         L     R1,CURINP          FIND CURRENT INPUT START\n         USING INPUT,R1\n         LM    R7,R8,PREVEND      RELOAD CURRENT & END POINTERS\n         LH    R3,PREVCOMS        GET PREVIOUS COMMA COUNT\n         AH    R3,COMMAS          ADD TO CURRENT COUNT\n         STH   R3,COMMAS          AND STORE BACK\n         MVC   CURINP,INPCHAIN    RESET CURRENT INPUT PTR\n         MVC   INSFLAG,PREVINS    & INSERT FLAGS\n         MVC   DEFTINPT,PREVDEFT  & DEFAULT FLAGS\n         DROP  R1\n         B     RETURN             THEN RETURN\n         SPACE 3\nINPUT    DSECT ,                  MAPPING OF INPUT CHAIN AREA\n         SPACE\nINPCHAIN DS    A                  CHAIN FIELD\nPREVEND  DS    A                  PREVIOUS END POINT\nPREVIPOS DS    A                  PREVIOUS CURRENT POINT\nPREVCOMS DS    H                  PREVIOUS LEFT-OVER COMMAS\nPREVINS  DS    B                  PREVIOUS INSERT FLAGS\nPREVDEFT DS    B                  PREVIOUS DEFAULT FLAGS\n         DS    0F\nBUFLEN   DS    H                  TEXT SEGMENT LENGTH\nBUFOFF   DS    H                  CURRENT TEXT OFFSET (FOR EXTENS)\nINPLEN   EQU   *-INPUT            LENGTH OF HEADER\nCLUTSERV CSECT ,                  RESUME OUR CSECT\n         TITLE 'CLUZKIDN -- KEYWORD IDENTIFICATION ROUTINE'\n*\n*        THIS ROUTINE SCANS THE PCE'S TO FIND A KEYWORD\n*\nCLUZKIDN LIENTRY  DSALEN=88,DSA=*,ENV=R5\n         SPACE\n         L     R14,4(,R13)        FIND SAVE AREA\n         L     R10,60(,R14)       LOAD SUBWORK POINTER\n         USING SUBWORK,R10\n         L     R2,PREVPOS         FIND KEYWORD START\n         LR    R3,R8\n         SR    R3,R2              GET LENGTH OF KEYWORD\n         BCTR  R3,0               LESS 1 FOR EX\n         XC    NAME#,NAME#        CLEAR NAME & NUMBER\n         XC    NAMEADDR,NAMEADDR\n         L     R9,KEY1            START WITH 1ST KEYWORD\n         LR    R0,R6              R0 COUNTS IKJNAMES\n         MVC   ALIGN,2(R9)\n         LR    R15,R9\n         AH    R15,ALIGN          ADDRESS 1ST IKJNAME\n         MVI   AMBFLAG,0          TURN OFF AMBIGUITY FLAGS\n         SPACE\n*\n*        CHECK AGAINST THE NEXT NAME\n*\nKIDLOOP  EX    R3,KIDCLEN         SAME LENGTH AS THIS NAME?\n         BL    KIDNO              TOO SHORT, NO MATCH\n         BE    KIDLENEQ           YES, MAY MATCH EXACTLY\n         TM    AMBFLAG,X'80'      ALREADY AMBIGUOUS?\n         BO    KIDNO              YES, NO NEED TO COMPARE\n         EX    R3,KIDCNAM         COMPARE FRONT ENDS\n         BNE   KIDNO              NO MATCH\n         OC    NAMEADDR,NAMEADDR  DID SOMETHING ELSE MATCH?\n         BNZ   KIDAMB             YES, AMBIGUITY\n         STH   R0,NAME#           NO, STORE NUMBER\n         ST    R15,NAMEADDR       & NAME\n         ST    R9,KEYPTR          SAVE IKJKEYWD POINTER\n         AIF   ('&OPSYS' NE 'MVS').NMVS2B\n         OI    AMBFLAG,X'40'      SET MATCH FOUND FLAG\n.NMVS2B  B     KIDNO              AND CONTINUE\nKIDCLEN  CLI   4(R15),0           COMPARE LENGTHS-1\nKIDCNAM  CLC   5(0,R15),0(R2)     COMPARE KEYWORD TEXTS\n         SPACE\nKIDAMB   OI    AMBFLAG,X'80'      SET AMBIGUOUS FLAG\n         B     KIDNO              BUT CONTINUE LOOKING FOR EXACT MATCH\n         SPACE\nKIDLENEQ EX    R3,KIDCNAM         COMPARE KEYWORD & NAME\n         BE    KIDFOUND           GOTCHA\n         SPACE\nKIDNO    EQU   *\n         SPACE\n         AIF   ('&OPSYS' NE 'MVS').NMVS2A\n*\n*        CHECK FOR A MATCH WITH AN ALIAS NAME\n*\n         TM    1(R15),X'02'       ARE THERE ALIASES?\n         BZ    KIDNEXT            NO.\n         SR    R1,R1\n         IC    R1,4(,R15)         YES, FIND 1ST ONE\n         LA    R1,6(R1,R15)\n         TM    0(R15),X'04'       IS THERE A SUBFIELD?\n         BZ    KIDNOSUB           NO.\n         LA    R1,2(,R1)          YES, SKIP IT\nKIDNOSUB TM    1(R15),X'10'       IS THERE INSERT?\n         BZ    KIDANINS           NO.\n         IC    R6,0(,R1)          YES, SKIP IT\n         LA    R1,2(R6,R1)\nKIDANINS IC    R6,0(,R1)          GET NUMBER OF ALIASES\n         LA    R1,1(,R1)          SKIP PAST IT\nKIDALOOP LA    R14,1(,R3)         GET TRUE LENGTH OF KEYWORD\n         EX    R14,KIDCALEN       COMPARE ALIAS LENGTH\n         BE    KIDALNEQ           BRANCH IF PERFECT MATCH\n         BL    KIDANEXT           GIVE UP IF TOO SHORT\n         TM    AMBFLAG,X'C0'      MATCHED BY THIS NAME | AMBIG?\n         BNZ   KIDANEXT           YES, SKIP COMPARE\n         EX    R3,KIDCANAM        COMPARE ALIAS & KEYWORD\n         BNE   KIDANEXT           NOT EQUAL, PROCEED\n         OC    NAMEADDR,NAMEADDR  MATCH ALREADY FOUND?\n         BNZ   KIDAMBA            YES, AMBIGUOUS\n         STH   R0,NAME#           NO, STORE NAME & NUMBER\n         ST    R15,NAMEADDR\n         ST    R9,KEYPTR          SAVE KEYWORD POINTER\n         B     KIDANEXT           AND CONTINUE\nKIDCALEN CLI   0(R1),0            COMPARE ALIAS LENGTH-1 TO WORD LEN-1\nKIDCANAM CLC   1(0,R1),0(R2)      COMPARE KEYWORD TO ALIAS\n         SPACE\nKIDAMBA  MVI   AMBFLAG,X'80'      SET AMBIGUOUS FLAG\n         B     KIDANEXT           AND CONTINUE\n         SPACE\nKIDALNEQ EX    R3,KIDCANAM        COMPARE KEYWORD TO ALIAS\n         BE    KIDFOUND           GOT IT\n         SPACE\nKIDANEXT SR    R14,R14\n         BCT   R6,*+8             ANY MORE ALIASES LEFT?\n         B     KIDALNOT           NO.\n         IC    R14,0(,R1)         YES,  TRY THE NEXT\n         LA    R1,1(R1,R14)\n         B     KIDALOOP\n         SPACE\nKIDALNOT LA    R6,1               RESTORE ORIG R6\n.NMVS2A  ANOP\nKIDNEXT  MVC   ALIGN,2(R15)       PROCEED TO NEXT IKJNAME\n         AH    R15,ALIGN\n         AR    R0,R6              INCREASE NAME COUNT\n         AIF   ('&OPSYS' NE 'MVS').NMVS2C\n         NI    AMBFLAG,X'BF'      TURN OFF FOUND-HERE FLAG\n.NMVS2C  TM    0(R15),X'60'       STILL AN IKJNAME?\n         BO    KIDLOOP            YES,  CONTINUE\n         LR    R9,R15             NO, RESET R9\n         LA    R0,0\n         BM    KIDNEXT            CONTINUE IF NEW KEYWORD\n         TM    AMBFLAG,X'80'      WAS THERE AMBIGUITY?\n         BZ    KIDNAMB            NO.\n         LA    R15,8              YES, SET RETURN CODE\n         B     RETURN             AND GO BACK\n         SPACE\nKIDNAMB  OC    NAMEADDR,NAMEADDR  WAS ANYTHING FOUND?\n         BZ    KIDUNOWN           NO, UNKNOWN KEYWORD\nKIDRET   SR    R15,R15            YES, SET GOOD RETURN CODE\n         B     RETURN\n         SPACE\nKIDUNOWN LA    R15,4              SET UNKNOWN RET CODE\n         B     RETURN\n         SPACE\nKIDFOUND STH   R0,NAME#           STORE THE IKJNAME NUMBER\n         ST    R15,NAMEADDR       AND ADDR\n         ST    R9,KEYPTR          SAVE POINTER TO IKJKEYWD\n         B     KIDRET             STORE R9 AND RETURN\n         SPACE\n         DROP  R10                NO LONGER VALID\n         TITLE 'CLUZXTRA -- \"EXTRANEOUS/UNINTELLIGIBLE INFORMATION\" MES*\n               SAGE ROUTINE'\n*\n*        THIS ROUTINE GENERATES AN \"EXTRANEOUS INFORMATION\" MESSAGE\n*\nCLUZXTRA LIENTRY  DSALEN=XTRALEN,DSA=XTRADSA,ENV=R5,                   *\n               PARM=R2\n         XC    XAREA(XTRALEN-88),XAREA CLEAR DSA\n         ST    R2,IOWORK+12       STORE MSG HEADER IN MESSAGE\n         LA    R9,XAREA           START OF COLLECTION AREA\n         ST    R9,IOWORK+8        STORE INTO MSG\n         LA    R9,4(,R9)          SKIP PAST HEADER\n         LA    R10,157            MAXIMUM LENGTH ALLOWED-L''...'\n         LA    R3,1               PAREN COUNTER\n         MVC   HFLAG,BYPASS       INITIALIZE HIDING FLAG\n         MVI   BFLAG,X'FF'        DON'T INSERT LEADING BLANK\n         OI    SKIPF,NOCOMMA      DON'T BOTHER WITH COMMA WARNINGS\n         SPACE\n*\n*        MOVE THE NON-SECRET PARTS OF THE REMAINING TEXT TO XAREA\n*\nXTRALOOP CLI   0(R8),C''''        GOT A QUOTE\n         BE    XTRAQUOT           YES, GO HANDLE\n         CLI   QFLAG,X'00'        WITHIN QUOTED STRING?\n         BNE   XTRAQSTR           YES, SKIP SEMI CHECK\nXTRARSUM CLI   0(R8),C';'         GOT A SEMI-COLON?\n         BE    XTRASEMI           YES.\nXTRAQSTR CLI   HFLAG,X'00'        ARE WE HIDING THIS WORD?\n         BNE   XTRAHIDE           YES.\n         CLI   QFLAG,X'00'        WITHIN A QUOTE?\n         BNE   XTRACOPY           YES, JUST COPY TO OUTPUT\n         CLI   0(R8),C'('         NO, CHECK FOR PARENS\n         BE    XTRAOPEN\n         CLI   0(R8),C')'\n         BE    XTRACLOS\n         SR    R1,R1\n         IC    R1,0(,R8)\n         LA    R1,SCANTAB(R1)\n         TM    0(R1),X'10'        HAVE WE A SEPARATOR?\n         BNZ   XTRASEP\n         SPACE\nXTRACOPY LTR   R9,R9              IS THE OUTPUT AREA FULL?\n         BZ    XTRASKIP           YES.\n         MVC   0(1,R9),0(R8)      NO, MOVE THIS CHARACTER\n         MVI   BFLAG,X'00'        SHOW LAST CHAR NOT BLANK\n         BXH   R8,R6,XTRADONE     ON TO NEXT ONE\nXTRAINCR AR    R9,R6              NEXT OUTPUT CHAR\n         BCT   R10,XTRALOOP       REPEAT IF STILL ROOM\n         MVC   0(3,R9),=C'...'    IF NOT, ADD ELLIPSES\n         MVC   XAREA(2),=H'164'   STORE SEGMENT LENGTH\n         SR    R9,R9              SET BUFFER FULL FLAG\n         B     XTRALOOP           AND CONTINUE\n         SPACE\nXTRASKIP BXLE  R8,R6,XTRALOOP     JUST SKIP THIS HIDDEN CHAR\n         B     XTRADONE           EXIT IF DONE\n         SPACE\nXTRAQUOT CLI   QFLAG,X'00'        ALREADY WITHIN QUOTE?\n         BNE   XTRAQCLO           YES.\n         MVI   QFLAG,X'FF'        NO, SET QUOTE FLAG\n         CLI   HFLAG,X'00'        SUPPRESSING?\n         BE    XTRACOPY           NO, COPY THIS QUOTE\n         B     XTRASKIP           YES, JUST SKIP IT\n         SPACE\nXTRAQCLO CR    R8,R7              ANYTHING AFTER?\n         BE    XTRAQEND           NO, CONSIDER IT CLOSED\n         CLI   1(R8),C''''        YES, IS IT A DOUBLED QUOTE?\n         BNE   XTRAQEND           NO, IT IS CLOSED\n         MVI   QFLAG,X'00'        CLOSE IT MOMENTARILY\n         B     XTRACOPY           AND CONTINUE\n         SPACE\nXTRAQEND MVI   QFLAG,X'00'        CLOSE THE QUOTE\n         CLI   HFLAG,X'00'        PRESENTLY HIDING?\n         MVI   HFLAG,X'00'        STOP HIDING IF SO\n         BNE   XTRASKIP           YES, HIDE LAST QUOTE\n         B     XTRACOPY           NO, COPY IT\n         SPACE\nXTRAOPEN LA    R3,1(,R3)          INCREASE PAREN COUNT\n         MVI   HFLAG,X'00'        STOP HIDING\n         B     XTRACOPY           AND CONTINUE\n         SPACE\nXTRACLOS MVI   HFLAG,X'00'        STOP HIDING\n         BCT   R3,XTRACOPY        CONTINUE IF STILL UNBALANCED\n         CLI   SUBFLAG,0          IN A SUBFIELD?\n         BNE   XTRAEND            YES, THIS IS WHERE WE STOP\n         TM    COBFLAGS,COBSUB    IN A SUBSCRIPT?\n         BNZ   XTRAEND            YES, STOP HERE\n         TM    OPERFLGS,OPERACT+OPEREXPR    IN A COBOL EPRESSION?\n         BO    XTRAEND            YES, STOP NOW\n         B     XTRACOPY           NO, CONTINUE\n         SPACE\n*\n*        WE HAVE A SEPARATOR. CALL THE SKIP ROUTINE TO FIND THE\n*        NEXT NON-SEPARATOR, AND WHETHER FOLLOWING TEXT SHOULD BE\n*        SUPPRESSED.\n*\nXTRASEP  LR    R2,R8              SAVE PRESENT LOCATION\n         MVI   BYPASS,0           ASSUME NO SUPPRESS REQUIRED\n         L     R15,=A(CLUZSKIP)\n         BALR  R14,R15            CALL SKIP TO PROCESS\n         MVC   HFLAG,BYPASS       SAVE BYPASS FLAG\n         LTR   R15,R15            ANYTHING AFTER?\n         BNZ   XTRAEND            NO, STOP\n         CR    R2,R8              YES, DID WE SKIP ANYTHING?\n         BE    XTRACOPY           NO, JUST CONTINUE\n         LTR   R9,R9              IS THERE ROOM FOR MORE OUTPUT?\n         BZ    XTRALOOP           NO, DON'T ADD BLANK\n         CLI   BFLAG,X'00'        YES, WAS LAST CHAR A BLANK?\n         BNE   XTRALOOP           YES, DON'T ADD ANOTHER\n         MVI   BFLAG,X'FF'        NO, SHOW BLANK NOW LAST\n         MVI   0(R9),C' '         REPLACE SEPARATORS WITH BLANK\n         B     XTRAINCR           NOTE ONE MORE CHAR USED\n         SPACE\nXTRAHIDE CLI   QFLAG,X'00'        WITHIN A QUOTE?\n         BNE   XTRASKIP           YES, SKIP THIS CHAR\n         SR    R1,R1\n         IC    R1,0(,R8)          LOAD THIS CHARACTER\n         LA    R1,SCANTAB(R1)\n         TM    0(R1),X'E0'        IS IT ALPHAMERIC?\n         BNZ   XTRASKIP           YES, SKIP THIS CHAR\n         CLI   0(R8),C''''        NO, QUOTE FOUND?\n         BE    XTRAQUOT           YES, HANDLE HIDDEN QUOTATION\n         MVI   HFLAG,X'00'        ELSE THROUGH WITH HIDING\n         B     XTRARSUM           COPY THIS CHAR\n         SPACE\nXTRASEMI CH    R3,=H'1'           WITHIN PARENTHESES?\n         BH    XTRACOPY           YES, IGNORE SEMICOLON\n         CLI   SUBFLAG,0          WITHIN SUBFIELD?\n         BNE   XTRACOPY           YES, IGNORE SEMICOLON\n         CLC   CURINP,CBUF        WITHIN ORIGINAL INPUT?\n         BNE   XTRACOPY           NO, IGNORE IT\n         B     XTRAEND            ELSE TERMINATE PROCESSING\n         SPACE\nXTRADONE AR    R9,R6              SKIP LAST OUTPUT CHAR\nXTRAPOP  CLC   CURINP,CBUF        IN ORIGINAL INPUT?\n         BE    XTRAEND            YES, THE END\n         TM    DEFTINPT,DEFTINS   NO, IN DEFAULT TEXT?\n         BNZ   XTRAEND            YES, GO NO FURTHER\n         L     R15,=A(CLUZPOPS)\n         BALR  R14,R15            POP THIS TEXT AWAY\n         CR    R8,R7              ANY THING LEFT HERE?\n         BH    XTRAPOP            NO, POP THIS TOO\n         LTR   R9,R9              ROOM FOR MORE OUTPUT?\n         BZ    XTRALOOP           NO, JUST TRUCK ON\n         CLI   BFLAG,X'00'        YES, IS LAST CHAR ALREADY BLANK?\n         BNE   XTRALOOP           YES, PROCEED\n         MVI   0(R9),C' '         NO, PUT ONE THERE\n         MVI   BFLAG,X'FF'        SHOW LAST CHAR BLANK\n         B     XTRAINCR           AND PROCEED\n         SPACE\nXTRAEND  NI    SKIPF,255-NOCOMMA  ALLOW COMMA WARNINGS AGAIN\n         LTR   R9,R9              OUTPUT AREA ALREADY FULL?\n         BZ    XTRASEND           YES.\n         LA    R1,XAREA           NO, COMPUTE LENGTH\n         SR    R9,R1\n         STH   R9,XAREA           AND STORE\n         XC    XAREA+2(2),XAREA+2 CLEAR OFFSET\n         SPACE\nXTRASEND MVC   IOWORK+4(4),=A(3)  SAY 3 SEGMENTS\n         MVC   IOWORK+16(4),=A(COLON)  PUT : IN\n         XC    PGPB(12),PGPB      INITIALIZE PUTLINE BLOCK\n         PUTLINE PARM=PGPB,OUTPUT=IOWORK+4,MF=(E,IOPL) SEND IT\n         B     *+4(R15)           INTERPRET RETURN CODES\n         B     RETURN             NORMAL\n         BAL   R6,PARSRC8         ATTENTION\n         BAL   R6,PARSRC12        IMPOSSIBLE\n         BAL   R6,PARSRC12        SOMEONE BLEW IT\n         BAL   R6,PARSRC16        NO MEMORY\n         AIF   ('&OPSYS' NE 'MVS').NMVS8E\n         BAL   R6,PARSRC28        TERMINAL DISCONNECTED\n.NMVS8E  SPACE 3\nXTRADSA  DSECT ,                  CLUZXTRA'S DSA\n         SPACE\n         DS    22F\nXAREA    DS    CL164              EXTRANEOUS INFO COLLECTION AREA\nHFLAG    DS    B                  SUPPRESSION FLAG\nQFLAG    DS    B                  QUOTATION FLAG\nBFLAG    DS    B                  LAST CHAR BLANK FLAG\n         DS    0D\nXTRALEN  EQU   *-XTRADSA          LENGTH OF DSA\n         TITLE 'CLUZINFO -- INFORMATIONAL MESSAGE ROUTINE'\nCLUTSCOM LISECT ,                 USER COMMUNICATION ROUTINES\n*\n*        PUTLINE ROUTINE\n*\nCLUZINFO LIENTRY DSA=*,DSALEN=88,ENV=R5,PARM=R6\n         BAL   R14,BMSG           BUILD MESSAGE SEGMENTS\n         SPACE\n*\n*        SEND THE MESSAGE\n*\n         OC    VMSG+1(3),VMSG+1   IS THERE A LEVEL2 MESSAGE?\n         BNZ   INFOMULT           YES.\n         XC    PGPB(8),PGPB       INITIALIZE PUTLINE PARM BLOCK\n         PUTLINE PARM=PGPB,OUTPUT=(IOWORK+4,TERM,SINGLE),MF=(E,IOPL)   *\n                                  SEND THE MESSAGE\n         B     INFORC             INTERPRET THE RETURN CODE\n         SPACE\n*\n*        ADD SPECIFIED LEVEL 2 MESSAGE\n*\nINFOMULT L     R9,IOWORK+8        FIND MESSAGE TEXT\n         AH    R9,0(,R9)\n         BCTR  R9,0               FIND ITS LAST CHAR\n         CLI   0(R9),C'+'         IS A + ALREADY THERE?\n         BE    INFONPLS           YES.\n         MVC   IOWORK+12(4),IOWORK+8\n         MVC   IOWORK+8,=A(BPLUS)      NO, ADD IT ON\n         MVI   IOWORK+7,2         UPDATE NUMBER OF SEGMENTS\nINFONPLS LA    R3,IOWORK+16       WHERE TO BUILD LEVEL 2 MSG\n         ST    R3,IOWORK\n         XC    0(4,R3),0(R3)      CLEAR ITS CHAIN\n         MVC   4(4,R3),=F'1'      1 SEGMENT FOR LEVEL2\n         MVC   8(4,R3),VMSG       STORE 2ND LEVEL ADDR\n         XC    PGPB(8),PGPB       INIT  PUTLINE PARM BLOCK\n         PUTLINE PARM=PGPB,OUTPUT=(IOWORK,TERM,MULTLVL),MF=(E,IOPL)    *\n                                  SEND THE MESSAGES\n         SPACE\n*\n*        INTERPRET PUTLINE RETURN CODES\n*\nINFORC   B     *+4(R15)           HOW'D IT GO?\n         B     INFORET            WONDERFUL\n         BAL   R6,PARSRC8         ATTENTION\n         BAL   R6,PARSRC12        IMPOSSIBLE CASE\n         BAL   R6,PARSRC12        PUTLINE ERROR->PARM LIST ERROR\n         BAL   R6,PARSRC16        NO MEMORY\n         AIF   ('&OPSYS' NE 'MVS').NMVS8B\n         BAL   R6,PARSRC28        TERMINAL DISCONNECTED\n.NMVS8B  SPACE\nINFORET  XC    VMSG,VMSG          FORGET THE LEVEL 2 MESSAGE\n         B     RETURN             AND RETURN\n         TITLE 'CLUZREQR/CLUZRQPW/CLUZRQSB -- \"ENTER POSITIONAL/PASSWOR*\n               D/SUBSCRIPT\" MESSAGE ROUTINES'\n*\n*        THIS ROUTINE GENERATES A PROMPT FOR AN OMITTED POSITIONAL\n*\nCLUZREQR LIENTRY DSALEN=88,DSA=*,ENV=R5,PARM=R10\n         SPACE\n         L     R1,=A(ENTERID)\n         ST    R1,MSGAREA         STORE MESSAGE ID\n         MVC   MSGID,4(R1)        SAVE FOR USE WITH HELPS\n         MVC   MSGAREA+4(4),=A(ENTER)  \"ENTER \"\n         MVC   MSGAREA+8(4),=A(QUALFOR)     \"QUALIFIER FOR \"\n         TM    COBFLAGS,QUALFLG   IS THIS AN \"ENTER QUALIFIER\"?\n         BNZ   RQRQUAL            YES.\n         OI    MSGAREA+8,X'80'    NO, SUPPRESS THE SEGMENT\nRQRQUAL  ST    R10,MSGAREA+12     STORE PROMPT ADDRESS\n         OI    MSGAREA+12,X'02'   SET END BIT\n         TM    COBFLAGS,QUALFLG   QUALIFIER PROMPT?\n         BNZ   RQRNPCE            YES.\n         OI    MSGAREA+12,X'04'   YES, SET PCE FLAG\nRQRNPCE  LR    R1,R10             SAVE PROMPT POINTER\n         TM    0(R9),X'02'        IS THERE ANY HELP?\n         BZ    RQRNHELP           NO.\n         TM    COBFLAGS,QUALFLG   PROMPTING FOR QUALIFIER?\n         BZ    RQRHNQL            NO.\n         MVC   ALIGN,0(R1)        YES, FIND PROMPT AFTER DESCRIPTION\n         AH    R1,ALIGN\nRQRHNQL  BAL   R14,FHLP           CALL HELP FINDER\n         LA    R2,2(,R1)          SKIP OVER HELP LENGTH\n         B     RQRPROM            GO PROMPT\nRQRNHELP SR    R2,R2              SAY NO  HELP AVAILABLE\n         SPACE\nRQRPROM  LA    R1,MSGAREA\n         L     R15,=A(CLUZPROM)   ISSUE PROMPT\n         BALR  R14,R15\n         B     *+4(R15)           HOW'D IT GO?\n         B     RETURN             WELL\n         SPACE\n*\n*        IF THE PROMPT FAILED, GENERATE A \"MISSING\" MESSAGE\n*\n         TM    COBFLAGS,QUALFLG   WAS THIS AN \"ENTER QUALIFIER\"\n         BNZ   RQRMISS            YES, SKIP \"MISSING\" MESSAGE\n         MVC   MSGAREA(4),=A(MISSID)   PLUG IN MISSING WORDS\n         MVC   MSGAREA+4(4),=A(MISSING)     ADD \"MISSING\"\n         TM    0(R9),X'02'        IS THERE HELP?\n         BZ    RQRMNHLP           BRANCH IF NO HELP\n         NI    MSGAREA+12,X'FD'   TURN OFF END BIT\n         MVC   MSGAREA+16,=A(PLUS)     ADD A +\n         OI    MSGAREA+16,X'02'   SET THE END\n         LA    R6,MSGAREA\n         BAL   R14,BMSG           GO BUILD UP THE MESSAGE\n         LA    R1,IOWORK+12       WHERE TO BUILD HELP\n         ST    R1,IOWORK          CHAIN TO LEVEL 1\n         XC    IOWORK+12(4),IOWORK+12  CLEAR LEVEL 2 CHAIN\n         MVC   IOWORK+16(4),=A(3) 3 LEVEL 2 SEGMENTS\n         MVC   IOWORK+24(8),MSGAREA    COPY MSGID & MISSING\n         LA    R2,1(,R2)          POINT TO 1ST HELP SEG\n         ST    R2,IOWORK+20       STORE IN MSG\n         XC    PGPB(12),PGPB      INIT PUTLINE PARM BLOCK\n         PUTLINE PARM=PGPB,OUTPUT=(IOWORK,TERM,MULTLVL),MF=(E,IOPL)    *\n                                  SEND \"MISSING XXX\"\n         B     RQRPUTRC           INTERPRET RET CODES\n         SPACE\nRQRMNHLP LA    R6,MSGAREA\n         BAL   R14,BMSG           FORMAT THE MESSAGE\n         XC    PGPB(12),PGPB      INIT PUTLINE PARMS\n         PUTLINE PARM=PGPB,OUTPUT=(IOWORK+4,TERM,SINGLE),MF=(E,IOPL)   *\n                                  SEND MISSING MSG\n         SPACE\nRQRPUTRC B     *+4(R15)           INTERPRET PUTLINE RET CODE\n         B     RQRMISS            RETURN MISSING\n         BAL   R6,PARSRC8         ATTENTION\n         BAL   R6,PARSRC12        IMPOSSIBLE\n         BAL   R6,PARSRC12        SOMEONE MADE AN ERROR\n         BAL   R6,PARSRC16        NO MEMORY\n         AIF   ('&OPSYS' NE 'MVS').NMVS8C\n         BAL   R6,PARSRC28        TERMINAL DISCONNECTED\n.NMVS8C  SPACE\nRQRMISS  LA    R15,4              UNABLE TO PROMPT RET CODE\n         B     RETURN\n         SPACE 5\n*\n*        THIS ROUTINE ISSUES A PROMPT FOR A (DATASET OR USERID)\n*        PASSWORD\n*\nCLUZRQPW LIENTRY DSALEN=88,DSA=*,ENV=R5,PARM=R3\n         MVC   MSGAREA+8(4),=A(PASSWORD)    \"PASSWORD\"\n         AIF   ('&OPSYS' NE 'MVS').NMVS3D\n         TM    PASSF,PASSABLE     CHECK FOR NEW PASSWORD\n         BNZ   RQROPASS           NO, OLD\n         MVC   MSGAREA+8,=A(NEWPASS)   CHANGE TO \"NEW PASSWORD\"\nRQROPASS EQU   *\n.NMVS3D  ANOP\n         ST    R3,MSGAREA+16      ADD TEXT TO MESSAGE\n         OI    MSGAREA+16,X'0B'   SUPPRESSIBLE, PDE, END\nRQRFOR   MVC   MSGAREA(4),=A(ENTERID)\n         MVC   MSGAREA+4(4),=A(ENTER)  \"ENTER \"\n         MVC   MSGAREA+12(4),=A(FOR)   \"FOR\"\n         OI    MSGAREA+12,X'01'   SUPPRESSIBLE FOR\n         CLI   LEFTOVER,0         PASSWORD/SUBSCRIPT FOR INVALID PARM?\n         BE    RQRNINV            NO.\n         MVC   MSGAREA+16(4),=A(INVPARM)    YES, SAY \"PASSWORD FOR...  *\n                                            ...INVALID TYPE\"\n         NI    MSGAREA+12,X'FE'   UNSUPPRESS FOR\n         BAL   R14,FDSC           GET INVALID PARM DESCRIPTION\n         ST    R1,MSGAREA+20      AND ADD TO MESSAGE\n         MVI   MSGAREA+20,X'02'   SHOW END OF MESSAGE\nRQRNINV  SR    R2,R2              SAY NO HELP\n         LA    R1,MSGAREA\n         L     R15,=A(CLUZPROM)\n         BALR  R14,R15            ISSUE \"ENTER PASSWORD FOR XXX -\"\n         B     *+4(R15)           WHAT RESULT?\n         B     RQRCREST           NORMAL\n         SPACE\n*\n*        IF THE PROMPT FAILED, PUT OUT A MISSING PASSWORD MESSAGE\n*\n         MVC   MSGAREA(4),=A(MISSID)   CHANGE MSGID\n         MVC   MSGAREA+4(4),=A(MISSING) \"ENTER\"->\"MISSING\"\n         LA    R6,MSGAREA\n         BAL   R14,BMSG           WHIP MSG INTO SHAPE\n         XC    PGPB(12),PGPB      CLEAR PUTLINE PARMS\n         PUTLINE PARM=PGPB,OUTPUT=IOWORK+4,MF=(E,IOPL)                 *\n                                  SEND \"MISSING PASSWORD FOR X\"\n         B     *+4(R15)           INTERPRET RET CODE\n         B     RQRPMISS           PASSWORD MISSING\n         BAL   R6,PARSRC8         ATTENTION\n         BAL   R6,PARSRC12        IMPOSSIBLE\n         BAL   R6,PARSRC12        ERROR\n         BAL   R6,PARSRC16        NO MEMORY\n         AIF   ('&OPSYS' NE 'MVS').NMVS8D\n         BAL   R6,PARSRC28        TERMINAL DISCONNECTED\n.NMVS8D  SPACE\nRQRPMISS LA    R15,4              SHOW PROMPT FAILED\nRQRCREST CLC   MSGAREA+8(4),=A(SUBSCRS)     SUBSCRIPT REQUEST?\n         BNE   RETURN             NO.\n         XC    SUBSTAT(SUBSTLEN),SUBSTAT    YES, RESET EVERYTHING\n         XC    SUBSOPTS(SUBOPLEN),SUBSOPTS\n         OI    COBFLAGS,COBSUB\n         B     RETURN\n         SPACE 5\n*\n*        THIS ROUTINE ISSUES A PROMPT FOR A (COBOL VARIABLE) SUBSCRIPT\n*\nCLUZRQSB LIENTRY DSALEN=88,DSA=*,ENV=R5\n         L     R3,SUBSAVE         FIND SUBSCRIPT SAVE AREA\n         USING SUBSECT,R3\n         MVC   SUBSTAT(SUBSTLEN),SUBSWORK   RESTORE OLD STATUS\n         MVC   SUBSOPTS(SUBOPLEN),SUBSFLGS  FOR MESSAGE\n         L     R9,SUBSVAR         FIND PCE FOR FATHER VARIABLE\n         MVC   MSGAREA+8(4),=A(SUBSCRS)     \"SUBSCRIPT(S) \"\n         MVI   MSGAREA+16,X'0F'   PUT COBOL VAR INTO MSG\n         B     RQRFOR             GO BUILD REST OF MSG\n         DROP  R3\n         TITLE 'CLUZPROM -- TERMINAL PROMPTING ROUTINE'\n*\n*        PROMPT FOR NEW INPUT.\n*\nCLUZPROM LIENTRY DSALEN=PROMLEN,DSA=PROMDSA,ENV=R5,PARM=R6\n         CLI   DEFTF,0            PROCESSING DEFAULT?\n         BE    PROMALOW           NO, PROMPT OK\n         BAL   R6,PARSRC12        YES, CALLER ERROR\nPROMALOW BAL   R14,BMSG           GO TRANSFORM MESSAGE\n         MVI   IOWORK+7,2         INDICATE TWO SEGMENTS\n         MVC   IOWORK+12(4),IOWORK+8   MOVE TEXT PROPER\n         MVC   IOWORK+8(4),=A(MINUS)   INDICATE PROMPT BY -\n         LTR   R2,R2              IS HELP PROVIDED?\n         BZ    PROMNHLP           NO.\n         L     R1,IOWORK+12       YES, FIND END OF MESSAGE\n         AH    R1,0(,R1)\n         BCTR  R1,0\n         CLI   0(R1),C'+'         IS A + ALREADY THERE?\n         BE    PROMNHLP           NO.\n         MVC   IOWORK+8(4),=A(PLMINUS) YES, INSERT A + BEFORE\nPROMNHLP MVC   PGPB(16),PGMODEL   MOVE PUTGET PARMS\n         CLI   PCBYPASS,X'00'     SHOULD WE GET WITH BYPASS?\n         BE    PROMNBY1           NO.\n         SPACE\n*\n*        AT THIS TIME, TSO/VTAM BEHAVES UNREASONABLY IF A 3270 IS\n*        SENT TWO BYPASS CHARACTERS, SEPARATED BY A TGET NOWAIT.\n*        THE FOLLOWING LOGIC CIRCUMVENTS THIS BY ARRANGING TO SEND\n*        ONLY ONE. THIS FORCES A PASSWORD PROMPT TO BE ISSUED IN\n*        ASIS MODE, WHICH IS (TO MY MIND) AN UNFORTUNATE\n*        INCONSISTENCY\n*\n         MVI   IOWORK+7,3         ADD ANOTHER SEGMENT FOR BYPASS\n         MVC   IOWORK+16(4),=A(BYPSEG)\n         OI    PGPB+2,X'01'       FORCE ASIS PROMPT\n         SPACE\nPROMNBY1 LA    R3,IOWORK+4        FIND THE OLD\n         ST    R3,PGPB+4          STORE IN PARM BLOCK\n         SPACE\n*\n*        ISSUE INITIAL PROMPT, BUT DON'T WAIT FOR AN ANSWER\n*\n         PUTGET PARM=PGPB,TERMGET=(NOWAIT),MF=(E,IOPL) PROMPT W/NO WAIT\n         B     *+4(R15)           ACT ON RET CODE\n         BAL   R6,PARSRC12        IMPOSSIBLE\n         BAL   R6,PARSRC12        IMPOSSIBLE\n         BAL   R6,PARSRC8         ATTENTION\n         B     PROMNPRO           NOPROMPT IN EFFECT\n         BAL   R6,PARSRC12        IMPOSSIBLE\n         B     PROMNBY2           PROMPT MODE\n         BAL   R6,PARSRC12        PUTGET ERROR\n         BAL   R6,PARSRC16        NO MEMORY\n         AIF   ('&OPSYS' NE 'MVS').NMVS8G\n         BAL   R6,PARSRC28        TERMINAL DISCONNECTED\n.NMVS8G  SPACE\n*\n*        IN NOPROMPT MODE, SET FLAG AND RC=4\n*\nPROMNPRO MVI   RC,4               SET NOPROMPT RET CODE\n         LA    R15,4\nPROMRET  XC    VMSG,VMSG          CLEAR SECOND LEVEL MSG\n         B     RETURN             AND RETURN\n         SPACE\n*\n*        WAIT FOR A RESPONSE TO THE PROMPT\n*\nPROMGETL CLI   PCBYPASS,X'00'     BYPASS MODE?\n         BE    PROMNBY2           NO.\n         TPUT  BYCHAR,1,CONTROL   YES, SEND OUT A BYPASS\n         SPACE\nPROMNBY2 GETLINE PARM=PGPB+8,INPUT=(TERM),TERMGET=(WAIT),              *\n               MF=(E,IOPL)        NOW GET A RESPONSE\n         LR    R9,R15             SAVE RET CODE\n         CLI   PCBYPASS,X'00'     BYPASSING?\n         BE    PROMNBY3           NO.\n         TPUT  RESTCHAR,1,CONTROL YES, SEND A RESTORE\nPROMNBY3 B     *+4(R9)            THEN ACT ON RET CODE\n         B     PROMGOT            GOT A RESPONSE\n         BAL   R6,PARSRC12        IMPOSSIBLE\n         BAL   R6,PARSRC8         ATTENTION\n         BAL   R6,PARSRC12        IMPOSSIBLE\n         BAL   R6,PARSRC12        IMPOSSIBLE\n         BAL   R6,PARSRC12        GETLINE ERROR\n         BAL   R6,PARSRC16        NO MEMORY\n         AIF   ('&OPSYS' NE 'MVS').NMVS8I\n         BAL   R6,PARSRC28        TERMINAL DISCONNECTED\n.NMVS8I  SPACE 3\n         SPACE\n*\n*        IF THE RESPONSE IS NOT ?, STACK IT AND RETURN\n*\nPROMGOT  L     R9,PGPB+12         ADDRESS RESPONSE\n         CLC   0(2,R9),=H'4'      IS IT EMPTY?\n         BE    PROMFRAN           YES, FREE IT & RETURN\n         CLI   4(R9),C'?'         NO, IS IT ? ?\n         BE    PROMQMRK           YES, HANDLE IT\n         L     R1,IOPL+4          FIND ECT\n         OI    8(R1),X'80'        SET 2ND LEVEL PURGE FLAG\n         LH    R0,0(,R9)          GET LENGTH OF RESPONSE\n         SH    R0,=H'4'           SUBTRACT HEADER LENGTH\n         STH   R0,ALIGN           STORE FOR CLUZPUSH\n         LA    R1,4(,R9)          POINT TO TEXT\n         L     R15,=A(CLUZPUSH)\n         BALR  R14,R15            STACK THE NEW INPUT\n         MVI   INSFLAG,VIRGINP    NOTE INTACT INPUT LINE\n         SPACE\n*\n*        FREE THE PROMPT REPLY AND RETURN\n*\nPROMFRAN LR    R1,R9              PROMPT ADDRESS->R1\n         LH    R0,0(,R9)          LOAD LENGTH\n         A     R0,=X'01000000'    INSERT SUBPOOL 1\n         FREEMAIN R,LV=(0),A=(1)  FREE THE RESPONSE\n         SR    R15,R15            SET GOOD RETURN CODE\n         B     PROMRET            AND RETURN\n         SPACE\n*\n*        IF ? WAS ENTERED, DISPLAY ALL EXISTING HELP INFORMATION\n*\nPROMQMRK LR    R1,R9              FREE THE RESPONSE\n         LH    R0,0(,R9)\n         A     R0,=X'01000000'\n         FREEMAIN R,LV=(0),A=(1)\n         OC    VMSG+1(3),VMSG+1   IS THERE A LEVEL2 MSG?\n         BNZ   PROMVMSG           YES, PUT IT OUT\n         L     R9,IOPL+4          FIND ECT\n         OC    9(3,R9),9(R9)      IS THERE PENDING LEVEL2 TEXT?\n         BNZ   PROMLV2            YES.\n         LTR   R2,R2              NO, IS THERE HELP INFO?\n         BNZ   PROMHELP           YES, SEND IT\n         SPACE\n*\n*        IF THERE IS PUTLINE HELP OUTSTANDING, SPILL IT\n*\nPROMLV2  XC    PGPB(12),PGPB      CLEAR PUTLINE PARM BLOCK\n         PUTLINE PARM=PGPB,OUTPUT=0,MF=(E,IOPL) OUTPUT LEVEL2 TEXT\nPROMPTRC B     *+4(R15)           ACT ON RETURN CODE\n         B     PROMNVMG           NORMAL\n         BAL   R6,PARSRC8         ATTENTION\n         BAL   R6,PARSRC12        IMPOSSIBLE\n         BAL   R6,PARSRC12        BAD PARMS\n         BAL   R6,PARSRC16        NO MEMORY\n         AIF   ('&OPSYS' NE 'MVS').NMVS8F\n         BAL   R6,PARSRC28        TERMINAL DISCONNECTED\n.NMVS8F  SPACE\n*\n*        IF A VALIDATION EXIT MESSAGE EXISTS, PRINT IT\n*\nPROMVMSG XC    PGPB(12),PGPB      INITIALIZE PUTLINE BLOCK\n         MVC   VWORK,=A(1)        BUILD A 1 SEGMENT MSG\n         MVC   VWORK+4(4),VMSG\n         XC    VMSG(4),VMSG       THEN CLEAR THE MSG ADDR\n         PUTLINE PARM=PGPB,OUTPUT=(VWORK),MF=(E,IOPL) SEND EXIT MSG\n         B     PROMPTRC(R15)      ACT ON RETURN CODES\n         SPACE\n*\n*        IF HELP EXISTS, REPROMPT WITH FIRST HELP MESSAGE\n*\nPROMNVMG LTR   R2,R2              ANY HELP OUT?\n         BZ    PROMGETL           NO, JUST REGET\nPROMHELP SR    R9,R9              YES, BUILD FULL MULTI-LEVEL PROMPT\n         IC    R9,0(,R2)          NUMBER OF LEVELS\n         LR    R0,R9\n         MH    R0,=H'32'          NUMBER SEGMENTS/LEVEL\n         LIFO  LV=(0)             GET MEMORY FOR OLDS\n         LR    R6,R1              SAVE ADDR\n         LA    R14,1(,R2)         POINT TO 1ST HELP TEXT\n         SPACE\nPROMHLOP MVC   8(4,R6),=A(MINUS)\n         MVC   MSGID-4(4),=AL2(13,0)   PUT MSGID IN MSG\n         LA    R15,MSGID-4\n         ST    R15,12(,R6)\n         ST    R14,24(,R6)        PUT HELP INFO IN MSG\n         MVC   16(4,R6),=A(ENTER) ADD \"ENTER\"\n         CH    R9,=H'1'           ANY MORE HELP?\n         BE    PROMNPLS           NO.\n         LH    R15,0(,R14)\n         AR    R15,R14\n         BCTR  R15,0\n         CLI   0(R15),C'+'        SEE IF TEXT ENDS WITH +\n         BE    PROMNPLS           YES.\n         MVC   8(4,R6),=A(PLMINUS)     NO, ADD +\nPROMNPLS TM    COBFLAGS,QUALFLG   PROMPTING FOR QUALIFIERS?\n         BZ    PROMNQUL           NO, NORMAL CASE\n         MVC   4(4,R6),=A(5)      YES, SET NUMBER OF SEGMENTS\n         MVC   20(4,R6),=A(QUALFOR)    ADD \"QUALIFICATION FOR\"\n         B     PROMQUAL\nPROMNQUL MVC   20(8,R6),24(R6)    REALIGN SEGMENTS\n         MVC   4(4,R6),=A(4)      STORE NUMBER OF SEGMENTS\nPROMQUAL BCT   R9,*+8             AT BOTTOM LEVEL?\n         B     PROMHEND           YES.\n         LA    R15,28(,R6)        NO, CHAIN TO NEXT LEVEL\n         ST    R15,0(,R6)\n         LR    R6,R15\n         MVC   ALIGN,1(R2)\n         AH    R2,ALIGN\n         LA    R14,1(,R2)         SKIP TO NEXT HELP\n         B     PROMHLOP           AND CONTINUE\n         SPACE\n*\n*        PROMPT AGAIN\n*\nPROMHEND XC    0(4,R6),0(R6)      CLEAR FINAL CHAIN\n         LR    R2,R1              SAVE OLD ADDR\n         MVC   PGPB(16),PGMODEL   MOVE PUTGET PARMS\n         MVI   PGPB,X'05'         MAKE MULTI-LEVEL\n         CLI   PCBYPASS,X'00'     BYPASS NEEDED?\n         BE    PROMNBY4           NO.\n         OI    PGPB+1,X'10'       YES, SET BYPASS BIT\nPROMNBY4 ST    R1,PGPB+4          STORE OLD IN PARMS\n         PUTGET PARM=PGPB,MF=(E,IOPL)  ISSUE LEVEL2 PROMPT\n         B     *+4(R15)           INTERPRET RETURN CODE\n         B     PROMGOT            GOT INPUT\n         BAL   R6,PARSRC12        IMPOSSIBLE\n         BAL   R6,PARSRC8         ATTENTION\n         BAL   R6,PARSRC12        IMPOSSIBLE\n         BAL   R6,PARSRC12        IMPOSSIBLE\n         BAL   R6,PARSRC12        IMPOSSIBLE\n         BAL   R6,PARSRC12        PARM ERROR\n         BAL   R6,PARSRC16        NO MEMORY\n         AIF   ('&OPSYS' NE 'MVS').NMVS8H\n         BAL   R6,PARSRC28        TERMINAL DISCONNECTED\n.NMVS8H  SPACE 3\nPROMDSA  DSECT ,                  PROMPT WORK AREA\n         SPACE\n         DS    22F\nVWORK    DS    2A                 VALIDCK MSG WORK AREA\nPROMLEN  EQU   *-PROMDSA          LENGTH OF CLUZPROM DSA\n         SPACE\nCLUTSCOM CSECT ,                  RESUME CSECT\n         TITLE 'CLUTSCOM -- GENERALIZED MESSAGE BUILDING ROUTINE'\n*\n*        THIS ROUTINE IS CALLED TO BUILD A MESSAGE FROM A LIST OF\n*        MESSAGE SEGMENTS\n*\nBMSG     ST    R2,BSAVE+4\n         SR    R2,R2              CLEAR COUNT REGISTER\n         ST    R14,BSAVE          SAVE RETURN POINT\n         LIFO  LV=264             GET A BUFFER TO PUT THE MESSAGE IN\n         LA    R3,4(,R1)          POINT R3 TO TEXT START LOCATION\n         ST    R1,IOWORK+8        SAVE ADDRESS IN OLD\nBMSGLOOP TM    0(R6),X'80'        SUPPRESS THIS SEGMENT?\n         BNZ   BMSGNEXT           YES.\n         TM    0(R6),X'01'        IS THIS PART SUPPRESSIBLE?\n         BZ    BMSGNSUP           NO.\n         CLI   BYPASS,X'00'       YES, SHOULD IT BE SUPPRESSED?\n         BNE   BMSGNEXT           YES, ON TO NEXT TEXT\n         TM    RANGEF,RANGE2      WHICH RANGE HALF?\n         BNZ   BMSGSUP2           SECOND\n         TM    COBFLGS1,COBHBYP+COBTBYP     CHECK FOR COBOL BYPASS\n         BO    BMSGNEXT           FORGET COBOL IF HEAD & TAIL SECRET\n         TM    RANGEF,RANGERR     BOTH HALVES NEEDED?\n         BZ    BMSGNSUP           NO.\nBMSGSUP2 TM    COBFLGS2,COBHBYP+COBTBYP     CHECK PART 2 FLAGS\n         BO    BMSGNEXT\n         SPACE\nBMSGNSUP NI    0(R6),X'FE'        TURN OFF SUPPRESS FLAG\n         LA    R14,BMSGNEXT       DEFAULT RESUME POINT\n         SR    R15,R15\n         IC    R15,0(,R6)\n         N     R15,=F'-4'         GET SEGMENT TYPE\n         B     *+4(R15)           AND CHOOSE POISON\n         B     BMSGSEG            MSG SEGMENT HANDLER\n         B     BMSGPCE            PCE FORMAT HANDLER\n         B     BMSGPDE            PDE FORMAT HANDLER\n         B     BMSGINPT           INPUT TEXT HANDLER\n         SPACE\n*\n*        HANDLE SEGMENT ALREADY IN PUTLINE FORMAT\n*\nBMSGSEG  L     R1,0(,R6)          FIND THE SEGMENT\n         LH    R15,0(,R1)         LOAD THE LENGTH\n         S     R15,=A(5)          MAKE ACTUAL LENGTH-1\n         LA    R1,4(,R1)          POINT TO TEXT START\n         B     BMSGADD            GO ADD TO BUFFER\n*\n*        HANDLE SEGMENT CONTAINED IN A PCE\n*\nBMSGPCE  L     R1,0(,R6)          POINT TO THE LENGTH BYTE\n         IC    R15,0(,R1)         LENGTH INTO R15\n         LA    R1,1(,R1)          SKIP PAST LENGTH\n         B     BMSGADD            GO ADD TO TEXT\n         SPACE\n*\n*        HANDLE SEGMENT ADDRESSED BY A PDE\n*\nBMSGPDE  L     R1,0(,R6)          LOCATE THE PDE\n         LH    R15,4(,R1)         GET THE LENGTH\n         LTR   R15,R15            IS IT 0?\n         BZ    BMSGMEM            YES, USE MEMBER NAME INSTEAD\n         BCTR  R15,0              NO, ADJUST FOR EX\n         L     R1,0(,R1)          FIND THE DATA\n         B     BMSGADD            GO ADD TO MSG\n         SPACE\n*\n*        HANDLE SEGMENT FOR MEMBER-ONLY DSNAME\n*\nBMSGMEM  SR    R15,R15            LENGTH 0\n         LA    R1,PDOTS           ADD A (\n         BAL   R14,BMSGADD\n         L     R1,0(,R6)          GET BACK PDE ADDR\n         LH    R15,12(,R1)        LENGTH OF MEMBER NAME\n         BCTR  R15,0\n         L     R1,8(,R1)          LOCATION OF MEMBER NAME\n         BAL   R14,BMSGADD        GO ADD IT\n         SR    R15,R15\n         LA    R1,PDOTS+4         ADD A )\n         BAL   R14,BMSGADD\n         B     BMSGNEXT           AND THEN CONTINUE\n         SPACE\n*\n*        HANDLE CURRENT AND/OR PREVIOUS INPUT TEXT SEGMENT\n*\nBMSGINPT TM    COBFLAGS,COBFORM+QUALFLG     FULL COBOL ITEM REJECTED?\n         BNM   BMSGNCOB           NO.\n         TM    OPERFLGS,OPERINV   INVALID EXPRESSION?\n         BZ    BMSGNOPO           NO.\n         LA    R1,PDOTS           YES, INSERT (\n         SR    R15,R15\n         BAL   R14,BMSGADD\n         CLI   OPERPRES,0         HAS ANYTHING APPEARED YET?\n         BE    BMSGNEXT           NO, NOTHING MORE TO SAY\nBMSGNOPO TM    RANGEF,RANGE2      WORKING ON RANGE 2ND PART?\n         BNZ   BMSGCHD2           YES.\n         TM    COBFLGS1,COBOLVAR  IS IT A VARIABLE AT ALL?\n         BZ    BMSGNCOB           NO.\n         TM    COBFLGS1,COBQVAR   IS IT A COMPLEX COBOL VAR?\n         BZ    BMSGSHD1           NO, NO DOTS NEEDED\n         OI    COBFLAGS,COBDOTS   LET DOTS SEPARATE HEAD & TAIL\nBMSGSHD1 L     R1,COBHEAD1        FIND THE FIRST QUALIFIER\n         L     R15,COBHEAD1+4     & ITS END\n         LR    R0,R1              SAVE START FOR LATER\n         TM    COBFLGS1,COBHBYP   WAS THE HEAD HIDDEN?\n         BZ    BMSGCBLN           NO.\n         B     BMSGCDOT           YES.\nBMSGCHD2 TM    COBFLGS2,COBOLVAR  REALLY A VARIABLE?\n         BZ    BMSGNCOB           NO.\n         TM    COBFLGS2,COBQVAR   COMPLEX COBOL VAR?\n         BZ    BMSGSHD2           NO, NO DOTS NEEDED\n         OI    COBFLAGS,COBDOTS\nBMSGSHD2 L     R1,COBHEAD2\n         L     R15,COBHEAD2+4\n         LR    R0,R1              SAVE STARTING POINT\n         TM    COBFLGS2,COBHBYP   FIRST PART SUPPRESSED?\n         BNZ   BMSGCDOT           NO.\nBMSGCBLN SR    R15,R1\n         CH    R15,=H'50'         MUCH TOO LONG?\n         BNH   BMSGNDOT           NO.\n         LA    R15,50             YES, CUT IT SHORT\n         OI    COBFLAGS,COBDOTS   NOTE DOTS NEEDED\n         B     BMSGNDOT           GO JOIN NON-COBOL CODE\n         SPACE\nBMSGNCOB TM    RANGEF,RANGERR+RANGE0   HANDLING RANGE ERRORS?\n         BZ    BMSGSING           NO.\n         L     R1,RANGEPOS        FIND POSITION OF RANGE START\n         L     R15,RANGEND        FIND END OF IT\n         SR    R15,R1             GET LENGTH\n         B     BMSGINP2           AND JOIN OTHER CASE\nBMSGSING LR    R15,R8             MOVE ENDING POSITION\n         TM    PASSF,PASSCAN      SCANNED FOR A PASSWORD?\n         BZ    BMSGNPAS           NO, ENDING POS IS OK\n         L     R15,PASSTART       YES, PARM ENDS WHERE PSWD STARTED\nBMSGNPAS S     R15,PREVPOS        COMPUTE LENGTH\n         L     R1,PREVPOS         FIND START OF TEXT\nBMSGINP2 CH    R15,=H'77'         IS IT VERY LONG?\n         BNH   BMSGNDOT           NO.\n         LA    R15,80             YES, SET LENGTH TO 80\n         SPACE\nBMSGNDOT BCTR  R15,0              GET READY FOR EX\n         BAL   R14,BMSGADD        ADD THE INPUT\n         CH    R15,=H'76'         WAS IT TOO LONG?\n         BNH   BMSGPASS           NO.\n         LA    R1,PDOTS+1         YES, ADD ... AFTER\n         LA    R15,2\n         BAL   R14,BMSGADD\nBMSGPASS TM    PASSF,PASSCAN+PASSEEN   REJECTED PARM INCLUDE PASSWORD?\n         BNO   BMSGCDOT           NO.\n         LA    R15,8              YES, ADD \"/PASSWORD\" TO REJECTED\n         LA    R1,=C'/PASSWORD'   TEXT\n         BAL   R14,BMSGADD\nBMSGCDOT TM    COBFLAGS,COBFORM+QUALFLG     COBOL VAR-TYPE DISPLAY?\n         BNM   BMSGCOLN           NO, SKIP COBOL JUNK\n         TM    COBFLAGS,COBDOTS   ARE COBOL DOTS NEEDED?\n         BZ    BMSGCNDT           NO.\n         LA    R1,PDOTS+1         YES, ADD THEM\n         LA    R15,2\n         BAL   R14,BMSGADD\nBMSGCNDT TM    RANGEF,RANGE2      WORKING ON 2ND PART OF RANGE?\n         BNZ   BMSGCTL2           YES.\n         C     R0,COBHEAD1        HEAD OR TAIL OF VAR?\n         BNE   BMSGATL1           TAIL, CHECK FOR SUBSCRIPT\n         TM    COBFLGS1,COBQVAR   ARE THERE QUALIFIERS?\n         BZ    BMSGATL1           NO, CAN STOP NOW\n         NI    COBFLAGS,255-COBDOTS    TURN OFF DOTS FOR TAIL\n         TM    COBFLGS1,COBTBYP   IS THE TAIL QUALIFIER SECRET?\n         BNZ   BMSGATL1           YES, LEAVE IT OFF\n         L     R1,COBTAIL1        HEAD, NOW ADD THE TAIL\n         L     R15,COBTAIL1+4\n         LR    R0,R1\n         B     BMSGCBLN\nBMSGATL1 TM    COBFLGS1,COBHASUB  DO WE NEED TO ADD A SUBSCRIPT?\n         BNZ   BMSGSDOT           YES.\n         B     BMSGCLOS           NO, CHECK FOR OPER CLOSE\nBMSGCTL2 C     R0,COBHEAD2\n         BNE   BMSGATL2           TAIL ALREADY HANDLED\n         TM    COBFLGS2,COBQVAR   FULLY QUALIFIED?\n         BZ    BMSGATL2           NO.\n         NI    COBFLAGS,255-COBDOTS    YES, FORGET THE DOTS\n         TM    COBFLGS2,COBTBYP   TAIL PART SECRET?\n         BNZ   BMSGATL2           YES, HIDE IT\n         L     R1,COBTAIL2\n         L     R15,COBTAIL2+4\n         LR    R0,R1\n         B     BMSGCBLN           GO DO THE TAIL\nBMSGATL2 TM    COBFLGS2,COBHASUB  NEED SUBSCRIPT INDICATOR?\n         BZ    BMSGCLOS           NO.\nBMSGSDOT LA    R1,PDOTS           YES, ADD (...)\n         LA    R15,4\n         BAL   R14,BMSGADD\nBMSGCLOS TM    OPERFLGS,OPERINV+OPERCLS     NEED TO CLOSE AN EXPR?\n         BNO   BMSGCOLN           NO.\n         LA    R1,PDOTS+4         YES, ADD )\n         SR    R15,R15\n         BAL   R14,BMSGADD\nBMSGCOLN TM    RANGEF,RANGERR     NEED COLON?\n         BZ    BMSGNEXT           NO, CONTINUE\n         SR    R15,R15            YES, ADD COLON\n         LA    R1,=C':'\n         BAL   R14,BMSGADD\n         XI    RANGEF,RANGERR+RANGE2   RESET FLAGS TO ADD VALUE2\n         TM    COBFLGS2,COBFORM+QUALFLG     COBOL VAR-TYPE DISPLAY?\n         BM    BMSGCHD2           YES, GO TO COBOL CODE\n         B     BMSGSING\n         SPACE\n*\n*        PROCEED TO NEXT SEGMENT\n*\nBMSGNEXT TM    0(R6),X'02'        LAST SEGMENT?\n         BO    BMSGLAST           YES.\n         LA    R6,4(,R6)          NO, INCREASE INPUT POINTER\n         B     BMSGLOOP           AND PROCEED\n         SPACE\nBMSGLAST LA    R2,4(,R2)          ADD 4 TO LENGTH FOR PREFIX\n         L     R1,IOWORK+8        FIND THE BUFFER\n         STH   R2,0(,R1)          STORE THE LENGTH\n         XC    2(2,R1),2(R1)      MAKE THE OFFSET 0\n         MVC   IOWORK+4(4),=A(1)  INDICATE 1 SEGMENT\n         L     R14,BSAVE          RESTORE RETURN ADDR\n         L     R2,BSAVE+4\n         BR    R14                AND RETURN\n         SPACE\nBMSGADD  LA    R2,1(R2,R15)       UPDATE LENGTH REG\n         CH    R2,=H'255'         GOTTEN TOO LARGE?\n         BNH   BMSGOK             NO.\n         BAL   R6,PARSRC12        YES, INDICATE ERROR\nBMSGOK   EX    R15,BMSGMV         MOVE IN TEXT\n         LA    R3,1(R3,R15)       UPDATE OUTPUT CURSOR\n         BR    R14                AND RETURN\nBMSGMV   MVC   0(0,R3),0(R1)      MOVE TEXT TO OUTPUT SEGMENT\n         AIF   ('&OPSYS' NE 'MVS').NMVS10C\n         TITLE 'CLUZCNFM -- NEW PASSWORD CONFIRMATION ROUTINE'\n*\n*        THIS ROUTINE PROMPTS TO CONFIRM A NEW PASSWORD, AND RETURNS\n*        TO ITS CALLER WHETHER CONFIRMATION WAS SUCCESSFUL\n*\nCLUZCNFM LIENTRY DSALEN=CNFMDSAL,DSA=CNFMDSA,ENV=R5,PARM=R2\n         MVC   ORIGPASS(6),0(R2)  SAVE CURRENT PDE CONTENTS\n         MVC   PGPB(16),PGMODEL   PREPARE FOR PROMPT\n         PUTGET PARM=PGPB,OUTPUT=(CNFMOLD,SINGLE,PTBYPS),MF=(E,IOPL)   *\n                                  ASK FOR CONFIRMATION\n         B     *+4(R15)           GET A RESPONSE?\n         B     CNFMVERF           YES, CHECK IT OUT\n         BAL   R6,PARSRC12        IMPOSSIBLE\n         BAL   R6,PARSRC8         ATTENTION\n         B     CNFMOK             PROMPT FAILED, TREAT AS CONFIRMED\n         BAL   R6,PARSRC12        IMPOSSIBLE\n         BAL   R6,PARSRC12        IMPOSSIBLE\n         BAL   R6,PARSRC12\n         BAL   R6,PARSRC16        NO MEMORY LEFT\n         BAL   R6,PARSRC28        TERMINAL DISCONNECTED\n         SPACE\nCNFMOK   SR    R15,R15            SHOW PASSWORD CONFIRMED\n         B     RETURN             AND RETURN\n         SPACE\nCNFMVERF L     R3,PGPB+12         GET PROMPT RESPONSE ADDRESS\n         LH    R10,0(,R3)         LENGTH OF RESPONSE\n         SH    R10,=H'4'          ANYTHING SAID?\n         BZ    CNFMFREP           NO, JUST FREE IT\n         STH   R10,ALIGN          STORE LENGTH FOR PUSH ROUTINE\n         LA    R1,4(,R3)          POINT TO \"CONFIRMATION\"\n         L     R15,=A(CLUZPUSH)\n         BALR  R14,R15            PUT RESPONSE ON STACK\n         MVI   INSFLAG,PSWDCONF   LABEL AS PASSWORD CONFIRMATION\n         SPACE\nCNFMFREP LR    R1,R3              GIVE BACK PUTGET RESPONSE\n         LR    R0,R10\n         A     R0,=X'01000004'    FROM SUBPOOL 1\n         FREEMAIN R,LV=(0),A=(1)\n         LTR   R10,R10            DID WE GET ANYTHING?\n         BZ    CNFMFAIL           NO, RETURN UNHAPPY\n         SPACE\n*\n*        SKIP SEPARATORS AND SEE IF WHAT FOLLOWS LOOKS LIKE A\n*        PASSWORD. IF SO, SEE IF IT'S THE SAME ONE\n*\n         L     R15,=A(CLUZSKIP)   LOOK FOR INPUT START\n         BALR  R14,R15\n         LTR   R15,R15            FIND SOMETHING?\n         BNZ   CNFMEXIT           NO, CONFIRM FAILS\n         LR    R1,R2              YES, COPY PDE ADDRESS\n         L     R15,=A(CLUZCHAR)\n         BALR  R14,R15            IS THIS A PASSWORD?\n         LTR   R15,R15\n         BNZ   CNFMEXIT           NO, TOO BAD\n         LH    R15,ORIGPASS+4     YES, LOAD FIRST PASSWORD LENGTH\n         CH    R15,4(,R2)         SAME AS THIS ONE?\n         BNE   CNFMEXIT           NO, TOO BAD\n         LR    R14,R15            YES, COPY TO BETTER PLACE\n         L     R15,ORIGPASS       FIND ORIGINAL PASSWORD TEXT\n         L     R1,0(,R2)          NEW PASSWORD TEXT\n         BCTR  R14,0\n         EX    R14,CNFMCOMP       ANY DIFFERENCE?\n         BNE   CNFMEXIT           YES, WON'T DO\n         SPACE\n*\n*        SEE IF THERE IS ANYTHING IN THE RESPONSE AFTER THE\n*        PASSWORD. IF SO, TREAT IT AS CONFIRMATION FAILURE.\n*\n         L     R15,=A(CLUZSKIP)\n         BALR  R14,R15            SEE IF ANYTHING FOLLOWING\n         LCR   R15,R15\n         LA    R15,4(,R15)        R15=0 IF NOT\n         SPACE\n*\n*        UNSTACK THE PROMPT RESPONSE AND RETURN. IF CONFIRMATION\n*        FAILED, SEND A MESSAGE FIRST\n*\nCNFMEXIT LR    R10,R15            SAVE SUCCESS INDICATION\n         L     R15,=A(CLUZPOPS)\n         BALR  R14,R15            THROW CONFIRMATION AWAY\n         LTR   R15,R10            DID IT CONFIRM?\n         BZ    RETURN             YES, HOORAH\n         SPACE\nCNFMFAIL MVC   MSGAREA(4),=A(CONFAIL)   NO, COMPLAIN\n         OI    MSGAREA,X'02'\n         LA    R1,MSGAREA\n         L     R15,=A(CLUZINFO)\n         BALR  R14,R15\n         LA    R15,4              SET UNHAPPY RETURN CODE\n         XC    0(8,R2),0(R2)      ZERO PASSWORD PDE\n         B     RETURN             AND GO BACK\n         SPACE\nCNFMCOMP CLC   0(0,R15),0(R1)     COMPARE PASSWORD VERSIONS\n         SPACE\nCNFMOLD  DC    A(1,CONFIRM)       OLD FOR CONFIRMATION PROMPT\n         SPACE\nCNFMDSA  DSECT ,                  OUR DSA\n         SPACE\n         DS    22F\nORIGPASS DS    CL6                COPY OF PASSWORD PCE ON ENTRY\n         DS    0D\nCNFMDSAL EQU   *-CNFMDSA          OUR DSA LENGTH\n         SPACE\nCLUTSCOM CSECT ,                  RESTORE OUR CSECT\n.NMVS10C TITLE 'CLUZGASP -- INTERNAL/PARM LIST ERROR MESSAGE ROUTINE'\n*\n*        THIS ROUTINE IS CALLED TO WRITE A MESSAGE TO THE TERMINAL\n*        DESCRIBING WHERE A \"PARM LIST\" ERROR (REALLY ANYTHING WE\n*        DON'T UNDERSTAND) WAS DETECTED. IT IS USED ONLY FOR USERS\n*        WHO HAVE SET PROFILE MSGID TO PROVE THEIR SERIOUS INTEREST\n*        IN OBSCURE AND HARD-TO-USE INFORMATION.\n*\nCLUZGASP LIENTRY DSALEN=GASPLEN,DSA=GASPDSA,ENV=R5\n*\n*        ABNORMAL EXITS FROM PARSE ARE MADE WITH \"BAL  R6,\".\n*        THEREFORE, R6 ADDRESSES THE INSTRUCTION AFTER THE BAL\n*        WHICH NOTES THE ERROR.\n*\n         S     R6,=A(TSUCOPRT+4)  FIND ERROR OFFSET FROM START\n         SLL   R6,4\n         LA    R6,15(,R6)         PREPARE TO UNPACK IT\n         ST    R6,ERROFFH\n         UNPK  ERROFF(4),ERROFFH+1(3)  UNPK TO PSEUDO-HEX\n         TR    ERROFF,GASPHEX-240 MAKE IT REAL HEX\n         MVC   ERRSEG(4),=AL2(8,0)     SET UP MESSAGE SEGMENT\n         MVC   ERROLD(4),=A(2)    AND OLDS\n         MVC   ERROLD+8(4),=A(ERRAT)   \"ERROR DETECTED AT OFFSET\"\n         LA    R1,ERRSEG\n         ST    R1,ERROLD+4        STORE VARIABLE SEGMENT LOCATION\n         XC    PGPB(8),PGPB       PREPARE IOPB\n         PUTLINE PARM=PGPB,OUTPUT=(ERROLD,TERM,SINGLE),MF=(E,IOPL)     *\n                                  TELL USER WHERE ERROR NOTED\n         B     RETURN             AND RETURN (IGNORING RETURN CODES)\n         SPACE\nGASPHEX  DC    C'0123456789ABCDEF'     TABLE FOR HEX TRANSLATION\n         SPACE 3\nGASPDSA  DSECT ,                  A NICE WORK AREA\n         DS    22F\nERROFFH  DS    A                  ERROR OFFSET IN BINARY\nERROLD   DS    3A                 OLD FOR MESSAGE\nERRSEG   DS    2H                 MESSAGE SEGMENT HEADER\nERROFF   DS    CL4                PRINTABLE ERROR OFFSET\n         DS    0D\n         SPACE\nGASPLEN  EQU   *-GASPDSA          LENGTH OF WORK AREA\n         TITLE 'CLUTSMEM -- MEMORY MANAGEMENT ROUTINES'\nCLUTSMEM LISECT ,                 DEFINE MEMORY MANAGEMENT CSECT\n         SPACE\n*\n*        THIS CSECT CONTAINS THE PARSE MEMORY MANAGEMENT ROUTINES.\n*        THEY WERE DESIGNED TO (A) REDUCE THE NUMBER OF GETMAINS\n*        AND FREEMAINS REQUIRED, BOTH DURING EXECUTION AND ON CALL\n*        TO IKJRLSA, AND (B) NOT WASTE MEMORY UNNECESSARILY.\n*\n*        THE HIGH POINTS OF THE MEMORY MANAGEMENT ALGORITHMS ARE:\n*\n* 1.     MEMORY IS ALLOCATED IN BLOCKS, OF PREFERRED SIZE 1K.\n*        THE BLOCKS ARE CHAINED FOR EVENTUAL RELEASE BY IKJRLSA.\n* 2.     THE BLOCKS ARE SUBALLOCATED INTO SEGMENTS. EACH SEGMENT\n*        MAY BE OWNED BY A PARTICULAR PCE, OR COLLECTIVELY.  OWNED\n*        SEGMENTS MAY BE FREED, IN WHICH CASE THEY BECOME AVAILABLE\n*        FOR ALLOCATION OF COLLECTIVE STORAGE. COLLECTIVE SEGMENTS\n*        ARE NEVER FREED.  OWNED STORAGE IS ALLOCATED FROM THE\n*        BOTTOM OF A BLOCK; COLLECTIVE STORAGE IS ALLOCATED FROM\n*        FREED OWNED SEGMENTS, AND THEN FROM THE TOP OF A BLOCK.\n* 3.     AS AN OPERAND IS PROCESSED, ITS OWNED SEGMENT HAS A STACK\n*        STRUCTURE, DIVIDED INTO \"LEVELS\" OF NESTING.  (THE DEFINED\n*        LEVELS ARE LIST, RANGE/EXPRESSION, OPERAND, AND\n*        SUBSCRIPT/PASSWORD.)  WHENEVER PROCESSING AT A LEVEL IS\n*        COMPLETE, THE STORAGE WILL BE \"COMMITTED\" TO A HIGHER\n*        LEVEL IF PROCESSING WAS SUCCESSFUL, OR \"ROLLED BACK\"\n*        IF UNSUCCESSFUL.\n*\n         TITLE 'CLUZMINT -- MEMORY INITIALIZATION ROUTINE'\n*\n*        THIS ROUTINE ALLOCATES THE FIRST BLOCK OF STORAGE FOR\n*        PARSE, AND SUBALLOCATES THE PDL FROM IT\n*\nCLUZMINT LIENTRY DSALEN=MEMLEN,DSA=MEMDSA,ENV=R5,PARM=R2\n         LA    R1,128(,R2)        GET AT LEAST 128 BYTES MORE\n         BAL   R6,GBLK            GO ALLOCATE A BLOCK\n         L     R1,MEMBLOCK        GET ALLOCATED BLOCK ADDRESS\n         ST    R1,PDLPTR          STORE AS PDL ADDRESS\n         LA    R3,8(R2,R1)        FIND BYTE AFTER THE PDL\n         ST    R3,HIGHMARK        STORE AS HIGH-WATER MARK\n         A     R1,BLKLEN          FIND END OF BLOCK\n         ST    R1,LOWMARK         STORE AS LOW-WATER MARK\n         MVI   LOWLEVEL,X'FF'     INIT. EFFECTIVE LEVEL COUNTER\n         B     RETURN             RETURN TO INITIALIZATION\n         TITLE 'CLUZALOC -- PARSE MEMORY ALLOCATION ROUTINE'\n*\n*        THIS ROUTINE ALLOCATES MEMORY, ESTABLISHING A NEW BLOCK\n*        AND/OR SEGMENT IF NECESSARY\n*\nCLUZALOC LIENTRY DSALEN=MEMLEN,DSA=MEMDSA,ENV=R5,PARM=R2\n         LA    R2,3(,R2)          ROUND LENGTH UP TO FULLWORD\n         N     R2,=F'-4'\n         TM    ALCFLAGS,COLECTIV  REQUEST FOR COLLECTIVE MEMORY?\n         BZ    ALCOWNED           NO, GET OWNED MEMORY\n         SPACE\n*\n*        TRY TO GET SPACE FROM A FREED SEGMENT\n*\n         L     R3,FREESEGS        FIND FIRST FREED SEGMENT\n         LA    R9,FREESEGS        SET UP CHAIN-BACK REGISTER\nALCSERCH LTR   R3,R3              REACHED END OF FREE CHAIN?\n         BZ    ALCLOW             YES, ALLOC FROM BLOCK END\n         USING SEGHEAD,R3\n         C     R2,SEGLEN          NO, IS THIS SEGMENT BIG ENOUGH?\n         BNH   ALCAVAIL           YES, SUBALLOCATE\n         LA    R9,SEGCHAIN        NO, CHANGE BACKWARD REGISTER\n         L     R3,SEGCHAIN        TRY NEXT ON CHAIN\n         B     ALCSERCH\n         SPACE\n*\n*        TAKE THE REQUIRED STORAGE FROM THE FREE SEGMENT. IF ANY\n*        IS LEFT, RETURN IT TO THE FREE CHAIN.\n*\nALCAVAIL ST    R3,NEWMEM          RETURN THE SEGMENT ADDRESS\n         NI    ALCFLAGS,255-COLECTIV   KILL COLLECTIVE ALLOCATION FLAG\n         L     R1,SEGLEN          GET SIZE OF THIS SEGMENT\n         SR    R1,R2              GET OVERAGE\n         CH    R1,=H'8'           ENOUGH TO CARE ABOUT?\n         BNL   ALCSHRNK           YES, KEEP REMAINDER FREE\n         MVC   0(4,R9),SEGCHAIN   NO, JUST TAKE SEGMENT OFF CHAIN\n         B     RETURN             AND RETURN\n         SPACE\nALCSHRNK L     R0,SEGCHAIN        GET OLD SEGMENT CHAIN\n         AR    R3,R2              FIND NEXT BYTE OF SEGMENT\n         ST    R1,SEGLEN          STORE NEW LENGTH\n         ST    R0,SEGCHAIN        AND OLD CHAIN FIELD\n         ST    R3,0(,R9)          PUT SMALLER BLOCK ON CHAIN\n         B     RETURN             AND RETURN\n         SPACE\n*\n*        ALLOCATE A NEW COLLECTIVE SEGMENT FROM THE HIGH END OF THE\n*        CURRENT BLOCK\n*\nALCLOW   L     R3,LOWMARK         LOAD CURRENT LOW WATER MARK\n         SR    R3,R2              SUBTRACT LENGTH REQUIRED\n         C     R3,HIGHMARK        ENOUGH SPACE LEFT?\n         BL    ALCLCBLK           NO, NEW BLOCK REQUIRED\n         ST    R3,LOWMARK         YES, STORE NEW LOW MARK\n         ST    R3,NEWMEM          RETURN LOW END OF BLOCK\n         NI    ALCFLAGS,255-COLECTIV   RESET COLLECTIVE FLAG\n         B     RETURN\n         SPACE\n*\n*        ALLOCATE A NEW BLOCK, AND TAKE A NEW SEGMENT FROM THAT\n*\nALCLCBLK LR    R1,R2              PASS GBLK AMOUNT REQUIRED\n         BAL   R6,GBLK            GET A NEW BLOCK\n         B     ALCLOW             AND ALLOCATE FROM IT\n         SPACE\n*\n*        DETERMINE WHETHER THE OWNED STORAGE NESTING LEVEL HAS\n*        INCREASED, AND CREATE A NEW LEVEL IF SO.\n*\nALCOWNED SR    R15,R15            MAKE A ZERO\n         IC    R15,ALCLEVEL       LOAD ALLOCATION LEVEL\n         LA    R10,LEVLSTAK       FIND LEVEL INFORMATION STACK\n         AR    R10,R15            ADDRESS CURRENT LEVEL\n         USING LEVLSECT,R10\n         SR    R1,R1\n         IC    R1,NESTLEVL        GET EXTERNAL NESTING LEVEL\n         CR    R15,R1             AT SAME LEVEL?\n         BL    ALCNULEV           LEVEL INCREASE, PUSH STACK\n         BE    ALCHIGH            SAME LEVEL, JUST ALLOCATE\n         BAL   R6,PARSRC12        DECREASE SHOULD NOT OCCUR\n         SPACE\nALCNULEV LTR   R15,R15            HAS ANY LEVEL BEEN SET?\n         BNZ   ALCOLDSG           YES, PROPOGATE FROM PREVIOUS LEVEL\n         MVC   LEVMARK,HIGHMARK   NO, START THIS LEVEL FROM HWM\n         MVC   LEVSTART,HIGHMARK\n         MVC   SEGSTART,HIGHMARK  SHOW SEGMENT BEGUN\n         B     ALCSTSEG\n         SPACE\nALCOLDSG CLC   SEGSTART,HIGHMARK  SEGMENT HEADER CLAIMED?\n         BNE   ALCPROP            YES.\nALCSTSEG LA    R2,12(,R2)         NO, ADD 12 BYTES TO LENGTH\nALCPROP  LA    R15,8(,R15)        BUMP LEVEL COUNTER\n         MVC   LEVSTART+8,LEVMARK START NEXT LEVEL FROM END OF LAST\n         MVC   LEVMARK+8,LEVMARK\n         LA    R10,8(,R10)        BUMP LEVEL POINTER\n         CR    R15,R1             REACHED RIGHT LEVEL YET?\n         BL    ALCPROP            NO, CONTINUE\n         STC   R1,ALCLEVEL        YES, UPDATE LEVEL POINTER\n         CLI   LOWLEVEL,X'FF'     ANYTHING USEFUL ALLOCATED YET?\n         BNE   ALCHIGH            YES.\n         STC   R1,LOWLEVEL        NO, SHOW LOW ALLOCATION LEVEL\n         SPACE\n*\n*        ALLOCATE OR EXTEND THE OWNED SEGMENT FROM THE TOP OF THE\n*        CURRENT BLOCK\n*\nALCHIGH  L     R3,HIGHMARK        GET HIGH-WATER MARK\n         LA    R9,0(R3,R2)        COMPUTE NEW ONE\n         C     R9,LOWMARK         IS THERE ROOM?\n         BH    ALCOBLK            NO, NEW BLOCK REQUIRED\n         TM    ALCFLAGS,ACPTREQ   YES, HAS SEGMENT BEEN STARTED?\n         BNZ   ALCNOT1            YES.\n         ST    R3,SEGSTART        NO, START SEGMENT NOW\n         MVC   SEGOWNER,OWNERID   SAVE SEGMENT OWNER\n         OI    ALCFLAGS,ACPTREQ   SET SEGMENT BEGUN FLAG\n         LA    R3,12(,R3)         SKIP LENGTH OF SEGMENT HEADER\n         SPACE\nALCNOT1  ST    R3,NEWMEM          STORE NEW MEMORY ADDRESS\n         ST    R9,LEVMARK         STORE NEW END OF LEVEL PTR\n         ST    R9,HIGHMARK        STORE NEW HIGH-WATER MARK\n         B     RETURN\n         SPACE\n*\n*        ALLOCATE A NEW BLOCK, AND TAKE A NEW SEGMENT FROM THAT\n*\nALCOBLK  LR    R1,R2              PASS GBLK AMOUNT REQUIRED\n         BAL   R6,GBLK            GET A NEW BLOCK\n         B     ALCHIGH            AND ALLOCATE FROM IT\n         SPACE\n         DROP  R3,R10\n         TITLE 'CLUZMINT/CLUZALOC -- BLOCK ALLOCATION SUBROUTINE'\n*\n*        THIS SUBROUTINE IS CALLED TO GET A NEW BLOCK OF MEMORY.\n*\nGBLK     STM   R14,R3,12(R13)     SAVE SOME REGISTERS\n         SPACE\n*\n*        ADD PREVIOUS BLOCK (IF ANY) TO THE IKJRLSA CHAIN\n*\n         L     R14,MEMBLOCK       FIND PREVIOUS BLOCK\n         LTR   R14,R14            IF ANY\n         BZ    GBLKSIZE\n         L     R15,BLKCHAIN       IF SO, FIND CHAIN FIELD\n         LTR   R15,R15            IF ANY\n         BZ    GBLK1ST\n         ST    R14,0(,R15)        PUT LAST BLOCK ON CHAIN\nGBLK1ST  ST    R14,BLKCHAIN       & SET NEW CHAIN POINTER\n         SPACE\n*\n*        OUR CALLER HAS PASSED A MINIMUM BLOCK SIZE REQUIRED. WE\n*        ISSUE A VARIABLE GETMAIN FOR AN AMOUNT BETWEEN THE MINIMUM\n*        AND AT LEAST 512 BYTES MORE (ROUNDING UP TO A MULTIPLE\n*        THEREOF). THIS MEANS THAT USUALLY WE GET A 1K BLOCK.\n*\nGBLKSIZE MVC   GETLIST(10),GETMODEL    SET UP L-FORM GETMAIN\n         LA    R1,20(,R1)         ADD SPACE FOR BLOCK & SEGMENT HDRS\n         ST    R1,MEMREQ          STORE MINIMUM AMOUNT\n         LA    R3,1023(,R1)       UP BY 2X512\n         N     R3,=F'-512'        & ROUND DOWN\n         ST    R3,MEMREQ+4        TO GET THE MAXIMUM\n         GETMAIN VC,LA=MEMREQ,A=MEMBLOCK,MF=(E,GETLIST)                *\n                                  ASK FOR BLOCK OF MEMORY\n         LTR   R15,R15            DID WE GET IT?\n         BZ    GBLKOK             YES.\n         BAL   R6,PARSRC16        NO, ABANDON SHIP.\n         SPACE\n*\n*        SEE IF THE PREVIOUS BLOCK CONTAINS AN INCOMPLETE OWNED\n*        SEGMENT. IF SO, IT MUST BE ADDED TO THE \"PENDING\" CHAIN\n*        FOR ITS OWNER, AND A NEW SEGMENT BEGUN IN THE NEW BLOCK\n*\nGBLKOK   L     R3,HIGHMARK        GET OLD BLOCK HIGH-WATER MARK\n         L     R2,LOWMARK         AND LOW MARK\n         SR    R2,R3              COMPUTE AMOUNT BETWEEN\n         L     R1,MEMBLOCK        GET NEW BLOCK ADDR\n         MVC   0(4,R1),NULL       SHOW NOTHING CHAINED AFTER\n         MVI   4(R1),X'01'        SHOW BLOCK FROM SUBPOOL 1\n         MVC   5(3,R1),BLKLEN+1   SAVE LENGTH OF BLOCK\n         LA    R1,8(,R1)          SKIP IKJRLSA HEADER\n         OC    SEGSTART,SEGSTART  HAS A SEGMENT BEEN STARTED?\n         BZ    GBLKMARK           NO, HOW FORTUNATE\n         SR    R15,R15            YES.\n         IC    R15,ALCLEVEL       GET CURRENT ALLOCATION LEVEL\n         LA    R14,LEVLSTAK       FIND LEVEL INFO STACK\n         AR    R15,R14            ADDRESS CURRENT ENTRY\n         USING LEVLSECT,R15\n         LR    R0,R1              COPY BLOCK START ADDRESS\n         TM    ALCFLAGS,ACPTREQ   IS SEGMENT STILL EMPTY?\n         BZ    GBLKNSEG           YES, LET ALOC BUILD HEADER\n         LA    R0,12(,R1)         NO, LEAVE SPACE FOR SEGMENT HEADER\nGBLKNSEG ST    R1,LEVSTART        SET LEVEL START & END TO\n         ST    R0,LEVMARK         START OF NEW BLOCK\n         DROP  R15\n         L     R14,SEGSTART       FIND START OF OLD SEGMENT\n         USING SEGHEAD,R14\n         L     R15,HIGHMARK       FIND HIGH MARK OF OLD BLOCK\n         SR    R15,R14            COMPUTE SIZE OF OLD SEGMENT\n         BZ    GBLKOWN            CHECK FOR NO SEGMENT AT ALL\n         CH    R15,=H'12'         ANYTHING BUT HEADER THERE?\n         BH    GBLKOSEG           YES, PEND IT\n         AR    R2,R15             NO, ADD REMNANT TO AVAIL LENGTH\n         SR    R3,R15             AND PUSH HIGH-WATER MARK BACK\n         B     GBLKOWN\n         SPACE\nGBLKOSEG CH    R2,=H'8'           IS LESS THAN 8 BYTES OF BLOCK UNUSED?\n         BNL   GBLKREM            NO, PROCEED\n         AR    R15,R2             YES, ADD TO CAST-OFF SEGMENT\n         SR    R2,R2              SHOW NOTHING UNUSED\nGBLKREM  ST    R15,SEGLEN         STORE IT BACK\n         MVC   SEGCHAIN,OWNSEGS   CHAIN TO PREVIOUS PENDING SEGMENTS\n         ST    R14,OWNSEGS        NOTE NEW CHAIN HEAD\n         OC    OWNLINK,OWNLINK    IS THIS THE FIRST PENDING SEGMENT?\n         BNZ   GBLKOWN            NO.\n         ST    R14,OWNLINK        YES, WILL STAY THE TAIL\nGBLKOWN  ST    R1,SEGSTART        STORE NEW SEGMENT START\n         MVC   SEGOWNER-SEGHEAD(4,R1),OWNERID    COPY OWNER OVER\n         LR    R1,R0              PUT HIGH WATER MARK AFTER SEGHEAD\n         DROP  R14\n         SPACE\n*\n*        FIX UP THE PREVIOUS BLOCK. IF IT CONTAINS ANY UNUSED\n*        SPACE, IT IS \"FREED\" TO BECOME AVAILABLE FOR COLLECTIVE\n*        STORAGE ALLOCATION\n*\nGBLKMARK ST    R1,HIGHMARK        STORE HIGH MARK IN NEW BLOCK\n         L     R1,MEMBLOCK        GET NEW BLOCK ADDRESS\n         A     R1,BLKLEN          ADD TO BLOCK SIZE\n         ST    R1,LOWMARK         STORE AS LOW MARK\n         ST    R1,BLKTOP          SAVE AS HIGH ADDR IN BLOCK ALSO\n         LTR   R2,R2              IS THERE ANYTHING LEFT IN OLD BLOCK?\n         BNZ   FSEGBGIN           YES, GO TO FREE SEGMENT\n         LM    R14,R3,12(R13)     NO, RELOAD REGISTERS\n         BR    R6                 AND RETURN\n         SPACE\nGETMODEL GETMAIN VC,SP=1,MF=L     MODEL GETMAIN PARM LIST\n         TITLE 'CLUZCMIT -- PARSE MEMORY COMMIT ROUTINE'\n*\n*        THIS ROUTINE IS CALLED TO TRANSFER MEMORY ASSOCIATED WITH\n*        THE CURRENT NESTING LEVEL TO THE PREVIOUS LEVEL.\n*\nCLUZCMIT LIENTRY DSALEN=88,DSA=*,ENV=R5\n         SR    R15,R15\n         IC    R15,NESTLEVL       GET CURRENT NESTING LEVEL\n         SH    R15,=H'8'          BACK UP ONE\n         LR    R2,R15             SAVE LEVEL FOR LATER\n         SR    R14,R14\n         IC    R14,ALCLEVEL       GET ALLOCATION LEVEL\n         LA    R3,LEVLSTAK        FIND LEVEL INFORMATION STACK\n         AR    R15,R3             POINT TO PREVIOUS LEVEL\n         USING LEVLSECT,R15\n         AR    R14,R3             POINT TO CURRENT LEVEL\n         SPACE\n*\n*        SET THE HIGH-WATER MARK FOR THE PREVIOUS LEVEL EQUAL TO THE\n*        HIGH-WATER MARK FOR THIS LEVEL.  IF THE CURRENT LEVEL'S\n*        STARTING POINT IS NOT EQUAL TO THE PREVIOUS LEVEL'S HIGH\n*        POINT, A NEW BLOCK HAS BEEN TAKEN, AND WE ALSO ADJUST THE\n*        PREVIOUS LEVEL'S STARTING POINT.\n*\n         L     R1,LEVSTART-LEVLSECT(,R14)   GET START OF CURRENT LEVEL\n         C     R1,LEVMARK         SAME AS END OF PREVIOUS?\n         BE    CMITNORM           YES.\n         ST    R1,LEVSTART        NO, MAKE OLD LEVEL START THERE TOO\nCMITNORM L     R1,LEVMARK-LEVLSECT(,R14)    GET END OF CURRENT LEVEL\n         ST    R1,LEVMARK         AND COPY BACK\n         CLC   ALCLEVEL,LOWLEVEL  PREVIOUS LEVEL LOWEST ALLOCATED?\n         BNE   CMITNLOW           NO.\n         STC   R2,LOWLEVEL        YES, PUSH IT DOWN\nCMITNLOW STC   R2,ALCLEVEL        RESET ALLOCATION LEVEL\n         B     RETURN             AND RETURN\n         DROP  R15\n         TITLE 'CLUZRLBK -- PARSE MEMORY ROLLBACK ROUTINE'\n*\n*        THIS ROUTINE IS CALLED TO EFFECTIVELY DISCARD ANY MEMORY\n*        ASSOCIATED WITH THE CURRENT NESTING LEVEL OF THE CURRENT\n*        PARAMETER.\n*\nCLUZRLBK LIENTRY DSALEN=88,DSA=*,ENV=R5\n         SR    R15,R15\n         IC    R15,NESTLEVL       GET CURRENT NESTING LEVEL\n         SH    R15,=H'8'          BACK UP ONE\n         LR    R0,R15             SAVE LEVEL FOR LATER\n         SR    R14,R14\n         IC    R14,ALCLEVEL       GET ALLOCATION LEVEL\n         LA    R3,LEVLSTAK        FIND LEVEL INFORMATION STACK\n         AR    R15,R3             POINT TO PREVIOUS LEVEL\n         USING LEVLSECT,R15\n         AR    R14,R3             POINT TO CURRENT LEVEL\n         SPACE\n*\n*        RESET THE GLOBAL HIGH-WATER MARK TO THE HIGH-WATER MARK FOR\n*        THE PREVIOUS LEVEL.  EXCEPTION: IF THE STARTING POINT FOR\n*        THE CURRENT LEVEL IS DIFFERENT FROM THE HIGH POINT OF THE\n*        PREVIOUS LEVEL, A NEW BLOCK HAS BEEN TAKEN.  IN THAT CASE,\n*        THE PREVIOUS LEVEL'S STARTING POINT BECOMES THE NEW HIGH-\n*        WATER MARK, AND ANY STORAGE ASSOCIATED WITH THAT LEVEL IN\n*        THE PREVIOUS BLOCK BECOMES WASTED.\n*\n         L     R1,LEVSTART-LEVLSECT(,R14)   FIND START OF CURRENT LEVEL\n         C     R1,LEVMARK         SAME AS OLD HIGH POINT?\n         BE    RLBKMARK           YES.\n         ST    R1,LEVSTART        NO, CAN ONLY ROLL BACK THAT FAR\n         ST    R1,LEVMARK\nRLBKMARK ST    R1,HIGHMARK        RESET GLOBAL HIGH-WATER MARK\n         CLC   ALCLEVEL,LOWLEVEL  OLD LEVEL LOWEST ALLOCATED?\n         BH    RLBKNLOW           NO.\n         SPACE\n*\n*        IF THERE IS NO USEFUL STORAGE AT ANY HIGHER LEVEL FOR\n*        THIS PARAMETER, AND THERE ARE ANY PENDING SEGMENTS ALLOCATED,\n*        FREE THEM\n*\n         L     R3,OWNSEGS         FIND FIRST PENDING SEGMENT\n         LTR   R3,R3              IS THERE ONE?\n         BZ    RLBKGONE           NO.\n         USING SEGHEAD,R3\nRLBKFREE L     R2,SEGLEN          GET THE SEGMENT LENGTH\n         L     R9,SEGCHAIN        GET THE CHAIN POINTER\n         BAL   R6,FSEG            FREE THIS SEGMENT\n         LTR   R3,R9              ANY MORE LEFT?\n         BNZ   RLBKFREE           YES, FREE IT\n         XC    OWNSEGS(8),OWNSEGS NO MORE PENDING OWNED SEGMENTS\nRLBKGONE MVI   LOWLEVEL,X'FF'     SHOW NO ALLOCATION AT ANY LEVEL\n         DROP  R3\n         SPACE\nRLBKNLOW STC   R0,ALCLEVEL        RESET ALLOCATION LEVEL COUNT\n         B     RETURN\n         DROP  R15\n         TITLE 'CLUZACPT -- PARSE PARAMETER ACCEPTANCE ROUTINE'\n*\n*        THIS ROUTINE IS CALLED WHEN PROCESSING OF AN \"OWNER\"\n*        PARAMETER IS COMPLETE, TO FINALIZE ALLOCATION OF ITS\n*        OWNED MEMORY SEGMENTS.  AFTER ACCEPTANCE, THESE SEGMENTS\n*        CAN BE FREED ONLY BY A CALL TO CLUZRLSE.\n*\nCLUZACPT LIENTRY DSALEN=88,DSA=*,ENV=R5\n*\n*        ADD ANY ACTIVE SEGMENT TO THE CHAIN OF ALLOCATED SEGMENTS\n*\n         L     R9,HIGHMARK        GET HIGH WATER MARK\n         NI    ALCFLAGS,255-ACPTREQ    TURN OFF ACCEPT-REQUIRED FLAG\n         L     R3,SEGSTART        GET WHERE SEGMENT STARTED\n         USING SEGHEAD,R3\n         SR    R9,R3              COMPUTE SEGMENT LENGTH\n         BZ    ACPTEMTY           SPECIAL CASE IF EMPTY\n         MVC   SEGCHAIN,ALCSEGS   CHAIN NEW SEGMENT BEFORE OTHERS\n         ST    R9,SEGLEN          STORE SEGMENT LENGTH\n         SPACE\n*\n*        THERE MAY BE ONE OR MORE ADDITIONAL \"PENDING\" SEGMENTS\n*        ASSOCIATED WITH THIS OWNER IF A NEW BLOCK WAS ALLOCATED\n*        DURING ITS PROCESSING. IF SO, ADD THEM TO THE ALLOCATED\n*        CHAIN AS WELL.\n*\n         L     R9,OWNLINK         FIND PENDING SEGMENT LINK FIELD\n         LTR   R9,R9              ANYTHING PENDING?\n         BZ    ACPTNPND           NAHHH.\n         ST    R3,0(,R9)          YES, CHAIN ACTIVE SEGMENT AFTER\nACPTPEND L     R3,OWNSEGS         FIND THE FIRST PENDING SEGMENT\nACPTNPND ST    R3,ALCSEGS         STORE AS NEW ALLOCATED HEAD\n         SPACE\nACPTEXIT XC    OWNSEGS(8),OWNSEGS CLEAR PENDING POINTERS\n         XC    SEGSTART,SEGSTART  SHOW NO SEGMENT STARTED\n         MVI   ALCLEVEL,0         MAKE SURE ALLOC LEVEL IS 0\n         MVI   LOWLEVEL,X'FF'     RESET LOW ALLOC LEVEL MARK\n         B     RETURN             AND WE ARE THROUGH\n         SPACE\n*\n*        IF THE ACTIVE SEGMENT IS EMPTY, THERE MAY STILL BE PENDING\n*        SEGMENTS ALLOCATED FROM PREVIOUS BLOCKS. WE REQUEUE THESE\n*        TO THE ALLOCATED QUEUE.\n*\nACPTEMTY L     R9,OWNLINK         GET PENDING LINK POINTER\n         LTR   R9,R9              ANYTHING THERE?\n         BZ    ACPTEXIT           NO, GIVE UP\n         MVC   0(4,R9),ALCSEGS    YES, ADD THEM TO ALLOCATED LIST\n         B     ACPTPEND\n         SPACE\n         DROP  R3\n         TITLE 'CLUZRLSE -- PARSE STORAGE RELEASE ROUTINE'\n*\n*        THIS ROUTINE IS CALLED TO RELEASE THE STORAGE OWNED BY A\n*        PCE. ANY SUCH SEGMENTS ARE ADDED TO THE FREE LIST, AND\n*        CAN BE USED BY COLLECTIVE ALLOCATION REQUESTS.\n*\nCLUZRLSE LIENTRY DSALEN=88,DSA=*,ENV=R5,PARM=R10\n*\n*        SEARCH THE ALLOCATED SEGMENT LIST FOR SEGMENTS OWNED BY\n*        THIS PCE\n*\n         L     R3,ALCSEGS         FIND FIRST ALLOCATED SEGMENT\n         USING SEGHEAD,R3\n         LA    R9,ALCSEGS         R9 POINTS TO PREVIOUS CHAIN FIELD\nRLSELOOP LTR   R3,R3              REACHED CHAIN END?\n         BZ    RETURN             YES, NOTHING MORE TO DO\n         C     R10,SEGOWNER       NO, IS THIS SEGMENT OURS?\n         BE    RLSETHIS           YES, TURN IT LOOSE\n         LA    R9,SEGCHAIN        NO.\n         L     R3,SEGCHAIN        CHECK THE NEXT ONE\n         B     RLSELOOP\n         SPACE\n*\n*        ADD THE SEGMENTS ALLOCATED TO THIS OWNER TO THE FREE CHAIN.\n*        THEY SHOULD BE CONTIGUOUS ON THE ALLOCATED CHAIN, SO THERE\n*        IS NO NEED TO CONTINUE SEARCHING AFTER A MATCH IS FOUND\n*\nRLSETHIS L     R2,SEGLEN          GET SEGMENT LENGTH\n         L     R1,SEGCHAIN        SAVE CHAIN FIELD\n         BAL   R6,FSEG            FREE THIS SEGMENT\n         LR    R3,R1              ON TO NEXT SEGMENT\n         C     R10,SEGOWNER       THE RIGHT OWNER?\n         BE    RLSETHIS           YES, FREE IT TOO\n         ST    R3,0(,R9)          NO, RECONNECT ALLOCATED CHAIN\n         B     RETURN             RELEASE IS DONE\n         SPACE\n         DROP  R3\n         TITLE 'CLUZALOC/CLUZRLBK/CLUZRLSE -- FREE MEMORY SEGMENT ROUTI*\n               NE'\n*\n*        THIS ROUTINE IS CALLED TO ADD A SEGMENT TO THE LIST OF FREE\n*        SEGMENTS\n*\nFSEG     STM   R14,R3,12(R13)     SAVE REGISTERS\n         SPACE\n*\n*        THIS ENTRY TO THE FSEG ROUTINE IS USED BY THE GBLK ROUTINE\n*        TO FREE THE UNALLOCATED PART OF THE PREVIOUS BLOCK WHEN\n*        A NEW ONE IS ALLOCATED.\n*\nFSEGBGIN L     R14,FREESEGS       GET HEAD OF FREE SEG LIST\n         LA    R15,FREESEGS       KEEP CHAIN-BACK RECORD\n         LNR   R1,R15             INIT SEGMENT END POINTER\n         SPACE\n*\n*        THE FREE CHAIN IS KEPT SORTED BY BLOCK ADDRESS. FIND THE\n*        PROPER POINT TO INSERT THE NEW ARRIVAL.\n*\nFSEGLOOP LTR   R14,R14            REACHED END OF CHAIN?\n         BZ    FSEGLAST           YES.\n         USING SEGHEAD,R14\n         CR    R3,R14             THIS BLOCK BEFORE THE ONE TO FREE?\n         BL    FSEGINS            NO, THIS IS THE PLACE\n         LA    R15,SEGCHAIN       YES, KEEP LOOKING\n         L     R1,SEGLEN          SAVE LENGTH OF LAST SEGMENT\n         L     R14,SEGCHAIN\n         B     FSEGLOOP\n         SPACE\n*\n*        THIS SEGMENT MUST BE ADDED TO THE END OF THE CHAIN. SEE IF\n*        IT IS ADJACENT TO THE PREVIOUS ONE AND, IF SO, COMBINE THEM.\n*\nFSEGLAST AR    R1,R15             FIND END OF PREVIOUS SEGMENT\n         CR    R1,R3              ADJACENT TO THIS SEGMENT?\n         BE    FSEGJOIN           YES, PUT THEM TOGETHER\n         ST    R3,0(,R15)         NO, JUST CHAIN ON\n         DROP  R14\n         USING SEGHEAD,R3\n         XC    SEGCHAIN,SEGCHAIN  STOP CHAIN HERE\n         ST    R2,SEGLEN          SAVE LENGTH OF FREE ELEMENT\n         SPACE\nFSEGRET  LM    R14,R3,12(R13)     RELOAD REGISTERS\n         BR    R6                 AND RETURN TO CALLER\n         DROP  R3\n         SPACE\n         USING SEGHEAD,R15\nFSEGJOIN A     R2,SEGLEN          ADD TO PREVIOUS SEGMENT LENGTH\n         ST    R2,SEGLEN          AND STORE BACK\n         LTR   R14,R14            ANYTHING AFTER JUST FREED SEG?\n         BZ    FSEGRET            NO.\n         A     R2,SEGLEN          YES, FIND END OF EXPANDED SEGMENT\n         CR    R2,R14             CONTIGUOUS TO ONE AFTER?\n         BNE   FSEGRET            NO, QUIT\n         L     R3,SEGLEN-SEGHEAD(,R2)  YES, GET LENGTH OF THAT ONE\n         A     R3,SEGLEN          ADD TO THIS ONE'S LENGTH\n         ST    R3,SEGLEN\n         MVC   SEGCHAIN,SEGCHAIN-SEGHEAD(R14)    COPY CHAIN OVER\n         B     FSEGRET            AND FREE IS DONE\n         SPACE\nFSEGINS  AR    R1,R15             FIND END OF PREVIOUS SEGMENT\n         CR    R1,R3              CONTIGUOUS TO THIS ONE?\n         BE    FSEGJOIN           YES, MERGE\n         ST    R3,SEGCHAIN        NO, CHAIN TO IT\n         LA    R1,0(R2,R3)        FIND END OF BLOCK BEING FREED\n         CR    R1,R14             ADJACENT TO ONE AFTER?\n         BE    FSEGJAFT           YES, JOIN THEM\n         DROP  R15\n         USING SEGHEAD,R3\n         ST    R14,SEGCHAIN       NO, JUST FINISH CHAINING\n         ST    R2,SEGLEN          STORE SEGMENT LENGTH\n         B     FSEGRET\n         SPACE\nFSEGJAFT MVC   SEGCHAIN,SEGCHAIN-SEGHEAD(R14)    COPY CHAIN FROM       *\n                                                 FOLLOWING SEGMENT\n         L     R15,SEGLEN-SEGHEAD(,R14)     GET ITS LENGTH\n         A     R15,SEGLEN         ADD TO LENGTH OF THIS ONE\n         ST    R15,SEGLEN\n         B     FSEGRET\n         TITLE 'CLUZWRAP -- PARSE MEMORY MANAGEMENT WRAP-UP ROUTINE'\n*\n*        THIS ROUTINE CLEANS UP MEMORY FOR EITHER SUCCESSFUL OR\n*        UNSUCCESSFUL PARSE COMPLETION\n*\nCLUZWRAP LIENTRY DSALEN=88,DSA=*,ENV=R5\n         CLI   RC,0               SUCCESSFUL FINISH?\n         BE    WRAPUP             YES.\n         SPACE\n*\n*        FOR UNSUCCESSFUL PARSE TERMINATION, FREEMAIN THE CURRENT\n*        BLOCK, AND USE IKJRLSA TO RELEASE ANY OTHERS\n*\n         CLC   PDLPTR,NULL        EVER GOTTEN ANY STORAGE?\n         BE    RETURN             NO, NOTHING TO WRAP UP\n         L     R1,MEMBLOCK        LOAD CURRENT BLOCK ADDRESS\n         C     R1,PDLPTR          IS FIRST BLOCK ALSO LAST?\n         BE    WRAPRLSA           YES, DON'T FREE IT SPECIAL\n         L     R0,4(,R1)          NO, LOAD CURRENT BLOCK LENGTH\n         FREEMAIN R,A=(1),LV=(0)  FREE CURRENT BLOCK\nWRAPRLSA IKJRLSA PDLPTR           RELEASE OTHER BLOCKS\n         B     RETURN\n         SPACE\n*\n*        FOR SUCCESSFUL PARSE TERMINATION, FREEMAIN ANY UNUSED PART\n*        OF THE CURRENT BLOCK, AND CHAIN THIS HIGH FRAGMENT TO ANY\n*        OTHER BLOCKS FOR IKJRLSA\n*\nWRAPUP   NC    LOWMARK,=F'-8'     ROUND LOW WATER MARK DOWN\n         L     R3,LOWMARK\n         C     R3,BLKTOP          ANYTHING ALLOCATED AT HIGH END?\n         BE    WRAPTOP            NO, NO HEADER NEEDED\n         SH    R3,=H'8'           GET ROOM FOR IKJRLSA HEADER\n         ST    R3,LOWMARK         AND STORE BACK\nWRAPTOP  LR    R9,R3              SAVE LOWMARK\n         L     R2,HIGHMARK\n         LA    R2,7(,R2)          ROUND HIGH WATER-MARK UP\n         N     R2,=F'-8'\n         ST    R2,HIGHMARK\n         SR    R3,R2              GET AMOUNT UNUSED\n         BNP   WRAPFULL           IF ANY\n         L     R2,HIGHMARK        FREE FROM HIGHMARK->LOWMARK\n         FREEMAIN R,LV=(R3),A=(R2),SP=1\n         L     R15,BLKLEN         GET LENGTH OF LAST BLOCK\n         SR    R15,R3             GET AMOUNT LEFT\n         BZ    WRAPLAST           FIX UP PREV BLOCK IF NOTHING LEFT\n         L     R14,HIGHMARK\n         L     R1,MEMBLOCK\n         SR    R14,R1             COMPUTE SIZE OF LOW FRAGMENT\n         BP    WRAPLOW            CHECK FOR NO LOW FRAGMENT\n         LR    R1,R9              IF SO, TREAT HIGH AS LOW\n         B     WRAPHIGH\nWRAPLOW  ST    R14,4(,R1)         STORE FOR IKJRLSA\n         MVI   4(R1),X'01'        STORE SUBPOOL NUMBER\n         ST    R9,0(,R1)          CHAIN HIGH FRAGMENT TO LOW FRAGMENT\n         SR    R15,R14            GET SIZE OF HIGH FRAGMENT\n         BP    WRAPHIGH           IF ANY\n         MVC   0(4,R1),NULL       IF NONE, KILL CHAIN HERE\n         B     WRAPLINK           AND FINISH\nWRAPHIGH MVC   0(4,R9),NULL       SHUT OFF IKJRLSA CHAIN\n         ST    R15,4(,R9)         STORE FOR IKJRLSA\n         MVI   4(R9),X'01'\n         SPACE\nWRAPLINK L     R3,BLKCHAIN        GET IKJRLSA CHAIN FIELD ADDR\n         LTR   R3,R3              IS THERE A PREVIOUS BLOCK?\n         BZ    RETURN             NO.\n         ST    R1,0(,R3)          YES, CHAIN THESE ON\n         B     RETURN\n         SPACE\n*\n*        THE CURRENT BLOCK IS FULL. JUST ADD IT TO THE CHAIN.\n*\nWRAPFULL L     R1,MEMBLOCK        FIND THE CURRENT BLOCK\n         MVC   0(4,R1),NULL       CHAIN IT NOWHERE\n         MVC   4(4,R1),BLKLEN     SET UP LENGTH FIELD\n         MVI   4(R1),X'01'        STORE SUBPOOL NUMBER\n         B     WRAPLINK           FINISH FINISHING UP\n         SPACE\nWRAPLAST L     R1,NULL            CHAIN PREV BLOCK TO NULL\n         B     WRAPLINK\n         SPACE 5\nMEMDSA   DSECT ,                  DSA FOR CLUZMINT/CLUZALOC\n         DS    22F\nGETLIST  DS    3A                 GETMAIN PARM LIST\nMEMREQ   DS    2F                 MIN & MAX AMOUNTS WANTED\n         SPACE\nMEMLEN   EQU   *-MEMDSA           DSA LENGTH\n         SPACE 3\nSEGHEAD  DSECT ,                  MEMORY SEGMENT HEADER\n         SPACE\nSEGCHAIN DS    A                  ADDR OF NEXT SEGMENT\nSEGLEN   DS    A                  LENGTH OF THIS SEGMENT\nSEGOWNER DS    A                  ADDRESS OF OWNING PCE\n         SPACE 3\nLEVLSECT DSECT ,                  NESTING LEVEL INFO MAP\n         SPACE\nLEVSTART DS    A                  FIRST BYTE ALLOC AT THIS LEVEL\nLEVMARK  DS    A                  HIGH WATER MARK FOR THIS LEVEL\n         TITLE 'CLUZQSTR -- QUOTED STRING RECOGNIZER'\nCLUTSREC LISECT ,                 COMMON RECOGNIZERS\n         SPACE\n*\n*        THIS ROUTINE RECOGNIZES AND RETURNS QUOTED STRING VALUES\n*\nCLUZQSTR LIENTRY DSA=*,DSALEN=88,ENV=R5,PARM=R2\n*\n*        IF THE INPUT TEXT DOES NOT START WITH A QUOTE, IT IS NOT\n*        A QSTRING\n*\nQSTRBEGN L     R0,=X'7FFFFFFF'    INDICATE NO MAXIMUM LENGTH\n         CLI   0(R8),C''''        START WITH QUOTE?\n         BE    QSTRYES            YES.\n         LA    R15,4              NO, QSTRING NOT PRESENT\n         B     RETURN\n         SPACE\n*\n*        DETERMINE THE STRING'S LENGTH, AND THE NUMBER OF IMBEDDED\n*        QUOTES\n*\nQSTRYES  LA    R3,1(,R8)          SAVE START OF STRING\n         SR    R1,R1              INIT INTERNAL QUOTE COUNT\n         L     R14,=V(CLUTSCAP)   UPPER CASE TABLE ADDR\n         BXH   R8,R6,QSTRUNCL     PROCEED (UNLESS SOLITARY QUOTE)\n         SPACE\nQSTRCNT  CLI   0(R8),C''''        HAVE WE A CLOSE QUOTE?\n         BE    QSTRQCNT           YES, MAYBE\n         TM    1(R9),X'40'        NO, IS THIS STRING ASIS?\n         BNZ   QSTRASIS           YES, LEAVE IT ALONE\n         TR    0(1,R8),0(R14)     NO, UPPER CASE IT\nQSTRASIS BXLE  R8,R6,QSTRCNT      AND CONTINUE\n         B     QSTRUNCL           SAY UNCLOSED IF TEXT RUNS OUT\n         SPACE\nQSTRQCNT CR    R8,R7              AT THE END?\n         BE    QSTRCEND           YES, STRING HAS ENDED\n         CLI   1(R8),C''''        NO, IS THIS A DOUBLED QUOTE?\n         BNE   QSTRCEND           NO.\n         AR    R1,R6              YES, ADD TO QUOTE COUNT\n         AR    R8,R6              BUMP CURSOR PAST QUOTE 1\n         B     QSTRASIS           AND CONTINUE\n         SPACE\n*\n*        SEND A \"CLOSING QUOTE ASSUMED\" MESSAGE IF NECESSARY\n*\nQSTRUNCL BAL   R14,UNCL           CALL UNCLOSED ROUTINE\n         SPACE\n*\n*        IF THERE WERE NO IMBEDDED QUOTES, RETURN A POINTER TO THE\n*        ORIGINAL STRING\n*\nQSTRCEND LR    R10,R8\n         SR    R10,R3             COMPUTE LENGTH OF TEXT\n         LTR   R1,R1              ANY QUOTES INSIDE?\n         BNZ   QSTRQUOT           YES.\n         CR    R10,R0             NO, IS IT TOO LONG?\n         BH    QSTRLONG           YES.\n         ST    R3,0(,R2)          NO, SET UP PDE\n         STH   R10,4(,R2)\n         SPACE\nQSTRRET  MVI   6(R2),X'80'\n         SR    R15,R15\nQSTREXIT CR    R8,R7              DID WE PASS THE END?\n         BH    RETURN             YES.\n         CLI   0(R8),C''''        NO, WAS STRING CLOSED?\n         BNE   RETURN             NO.\n         AR    R8,R6              YES, SKIP PAST CLOSE QUOTE\n         B     RETURN\n         SPACE\n*\n*        COPY THE STRING TO DYNAMIC MEMORY, HALVING DOUBLED QUOTES\n*\nQSTRQUOT SR    R10,R1             COMPUTE TRUE STRING LENGTH\n         CR    R10,R0             IS IT TOO MUCH?\n         BH    QSTRLONG           YES.\n         STH   R10,4(,R2)         NO, SET UP PDE LENGTH\n         LR    R1,R10\n         L     R15,=A(CLUZALOC)\n         BALR  R14,R15            ASK FOR MEMORY\n         MVC   0(4,R2),NEWMEM     STORE IN PDE\n         L     R1,NEWMEM\n         SPACE\nQSTRMOVE CLI   0(R3),C''''        MOVE IN COMPRESSED VALUE\n         BE    QSTRQMV\n         MVC   0(1,R1),0(R3)\nQSTRMLOP AR    R1,R6\n         AR    R3,R6\n         BCT   R10,QSTRMOVE\n         B     QSTRRET\n         SPACE\nQSTRQMV  MVI   0(R1),C''''\n         AR    R3,R6\n         B     QSTRMLOP\n         SPACE\nQSTRLONG LA    R15,8              SET EVIL RETURN CODE\n         B     QSTREXIT           AND RETURN\n         TITLE 'CLUZSPAC/CLUZDLIM -- SPACE AND DELIMITER HANDLERS'\n*\n*        THIS ROUTINE HANDLES THE IKJPARS \"SPACE\" SYNTAX BY ADVANCING\n*        THE INPUT POINTER 1 CHARACTER, UNLESS IT ADDRESSES A TAB\n*\nCLUZSPAC LIENTRY DSALEN=88,DSA=*,ENV=R5\n         SR    R1,R1\n         IC    R1,0(,R8)\n         LA    R2,SCANTAB(R1)\n         TM    0(R2),X'10'        IS CHAR A DELIMITER?\n         BZ    SPACRET            NO, TREAT AS DATA\n         CLI   0(R8),X'05'        IS THIS CHAR A TAB?\n         BE    SPACRET            YES, LEAVE IT ALONE\n         CLI   0(R8),C'/'         CHECK FOR SLASH TOO\n         BE    SPACRET            YES, JUST A DATA CHAR\n         AR    R8,R6              NO, SKIP IT\nSPACRET  SR    R15,R15            SET GOOD RETURN CODE\n         MVI   DELIM,0            INDICATE NO DELIMITER\n         B     RETURN             AND RETURN\n         SPACE 5\n*\n*        THIS ROUTINE RECOGNIZES AN EDIT-TYPE STRING DELIMITER.\n*        QUOTE IS HANDLED SPECIALLY BECAUSE IT IS NOT YET KNOWN IF\n*        THE FOLLOWING STRING IS A SQSTRING\n*\nCLUZDLIM LIENTRY DSALEN=88,DSA=*,ENV=R5\n         MVI   DLQFLAG,0          TURN OFF QUOTE-DELIMITER FLAG\n         SR    R1,R1\n         IC    R1,0(,R8)\n         LA    R2,SCANTAB(R1)\n         TM    0(R2),X'48'        IS THIS CHAR NUMERIC OR SPECIAL?\n         BZ    DLIMOK             NO, IT CAN DELIMIT\n         CLI   0(R8),C''''        YES, IS IT A QUOTE?\n         BE    DLIMQUOT           YES, HANDLE SPECIAL CASE\n         MVI   DELIM,X'FF'        NO, INDICATE DELIMITER ABSENT\n         LA    R15,4              SET MISSING RETURN CODE\n         B     RETURN             AND GO BACK\n         SPACE\nDLIMOK   MVC   DELIM,0(R8)        SAVE DELIMITER\n         A     R1,=V(CLUTSCAP)    FIND UPPER CASE VERSION\n         MVC   CAPDELIM,0(R1)     AND SAVE THAT TOO\n         AR    R8,R6              SKIP PAST IT\n         SR    R15,R15\n         B     RETURN             AND RETURN\n         SPACE\nDLIMQUOT MVI   DELIM,C''''        MAKE QUOTE THE DELIMITER\n         MVI   CAPDELIM,C''''\n         MVI   DLQFLAG,X'FF'      SET SPECIAL FLAG\n         SR    R15,R15\n         B     RETURN             AND RETURN\n         TITLE 'CLUZSTRG -- STRING (OPTIONALLY DELIMITED) RECOGNIZER'\n*\n*        THIS ROUTINE RECOGNIZES A STRING. DEPENDING ON CIRCUMSTANCES,\n*        THE STRING MAY BE ENCLOSED IN DELIMITERS OR QUOTED\n*\nCLUZSTRG LIENTRY DSALEN=88,DSA=*,ENV=R5,PARM=R2\n         CLI   DELIM,0            HAS A DELIMITER BEEN FOUND?\n         BE    STRGALL            NO, RECOGNIZE TO THE END\n         CLI   DELIM,X'FF'        DELIMITER FOUND MISSING?\n         BE    STRGMISS           YES, THE STRING IS MISSING TOO\n         CLI   DLQFLAG,0          IS THE DELIMITER A QUOTE?\n         BNE   STRGQDLM           YES.\n         SPACE\nSTRGGO   MVI   DLQFLAG,0          TURN OFF QUOTE DELIM FLAG\n         LR    R3,R8              SAVE STARTING POINT\n         L     R14,=V(CLUTSCAP)   ADDRESS UPPERCASE TAB\n         CR    R8,R7              ANY ROOM FOR A STRING?\n         BH    STRGNDLM           NO, LENGTH 0\nSTRGSCAN CLC   DELIM,0(R8)        SEARCH FOR DELIMITER\n         BE    STRGEDLM\n         TM    1(R9),X'40'        ASIS?\n         BNZ   STRGASIS           YES, NO TRANSLATE\n         CLC   CAPDELIM,0(R8)     NO, SEE IF DELIMITER IN UPPER CASE\n         BE    STRGEDLM           AND STOP IF SO\n         TR    0(1,R8),0(R14)\nSTRGASIS BXLE  R8,R6,STRGSCAN     CONTINUE TILL END\n         SPACE\nSTRGNDLM MVI   DELIM,X'FF'        DELIMITER NOW MISSING\nSTRGEDLM LR    R10,R8\n         SR    R10,R3             COMPUTE STRING LENGTH\n         STH   R10,4(,R2)         STORE INTO PDE\n         ST    R3,0(,R2)\n         MVI   6(R2),X'80'\n         CR    R8,R7              DID WE REACH THE END?\n         BH    STRGRET            YES.\n         AR    R8,R6              NO, SKIP CLOSING DELIMITER\n         SPACE\nSTRGRET  SR    R15,R15\n         B     RETURN\n         SPACE\n*\n*        FOR A SQSTRING WITH QUOTE DELIMITER, CALL CLUZSKIP TO SKIP\n*        SEPARATORS, AND THEN PASS CONTROL TO THE QSTRING ROUTINE\n*\nSTRGQDLM TM    1(R9),X'08'        WAS SQSTRING SPECIFIED?\n         BZ    STRGGO             NO, QUOTE IS JUST A DELIMITER\n         NI    SKIPF,255-NOSKIP   YES, SKIP BLANKS\n         L     R15,=A(CLUZSKIP)\n         BALR  R14,R15\n         B     *+4(R15)\n         B     QSTRBEGN           OFF TO QSTRING HANDLER\nSTRGMISS LA    R15,4              NOTE STRING IS MISSING\n         B     RETURN             AND RETURN\n         SPACE\nSTRGALL  LR    R3,R8              SAVE STARTING POINT\n         LA    R8,1(,R7)          POINT CURRENT AFTER END\n         ST    R3,0(,R2)          SET UP PDE\n         LR    R15,R8\n         SR    R15,R3             DETERMINE LENGTH\n         STH   R15,4(,R2)\n         MVI   6(R2),X'80'\n         BNP   STRGRET            DON'T FOLD 0 LENGTH STRING\n         TM    1(R9),X'40'        ASIS STRING?\n         BNZ   STRGRET            YES, LEAVE IT ALONE\n         SPACE\n*\n*        TRANSLATE THE UNDELIMITED STRING TO UPPER CASE\n*\n         L     R1,=V(CLUTSCAP)    FIND TRANSLATE TABLE\n         LA    R14,256\n         BCTR  R15,0\n         SR    R10,R10\nSTRGFOLD BXH   R10,R14,STRGFLST\n         TR    0(256,R3),0(R1)    TRANSLATE 256 CHARS\n         AR    R3,R14\n         B     STRGFOLD\nSTRGFLST EX    R15,STRGCAPS       TRANSLATE THE STRING END\n         B     STRGRET\nSTRGCAPS TR    0(0,R3),0(R1)\n         TITLE 'CLUZPSTR -- PARENTHESIZED STRING RECOGNIZER'\n*\n*        THIS ROUTINE RECOGNIZES AND RETURNS A PARENTHESIZED STRING\n*\nCLUZPSTR LIENTRY DSA=*,DSALEN=88,ENV=R5,PARM=R2\n         CLI   0(R8),C'('         DOES IT START WITH A PAREN?\n         BE    PSTROK             YES.\n         LA    R15,4              NO, NO PSTRING PRESENT\n         B     RETURN\n         SPACE\n*\n*        SCAN THE INPUT UNTIL A CLOSING PARENTHESIS BALANCING THE\n*        ORIGINAL OPEN PARENTHESIS IS LOCATED\n*\nPSTROK   AR    R8,R6              SKIP THE OPENING PAREN\n         LR    R3,R8              SAVE STARTING POINT\n         ST    R3,0(,R2)          STORE START IN PDE\n         LR    R15,R6             INITIALIZE IMBALANCE COUNT\n         L     R14,=V(CLUTSCAP)   FIND UPPER CASE TAB\nPSTRLOOP CLI   0(R8),C'('         ANOTHER OPEN?\n         BE    PSTROPEN           YES.\n         CLI   0(R8),C')'         A CLOSE?\n         BE    PSTRCLOS           YES.\n         CLI   0(R8),C''''        A QUOTE?\n         BE    PSTRQUOT           YES.\n         AIF   ('&OPSYS' NE 'MVS').NMVS1C\n         CLI   0(R8),C'/'         A SLASH (MAYBE STARTING A COMMENT)?\n         BE    PSTRSLSH           YES.\n.NMVS1C  TM    1(R9),X'40'        IS THIS ASIS?\n         BNZ   PSTRASIS           YES, NO TRANSLATE\n         TR    0(1,R8),0(R14)     NO, UPPER CASE THIS CHAR\nPSTRASIS BXLE  R8,R6,PSTRLOOP     AND CONTINUE\n         B     PSTREND\n         SPACE\n*\n*        IGNORE PARENTHESES CONTAINED WITHIN SINGLE QUOTES\n*\nPSTRQUOT BXH   R8,R6,PSTREND      CHECK FOR THE END\n         CLI   0(R8),C''''        CLOSING QUOTE?\n         BE    PSTRASIS           YES, EXIT TO NORMAL MODE\n         TM    1(R9),X'40'        NO, ASIS?\n         BNZ   PSTRQUOT           YES, CONTINUE\n         TR    0(1,R8),0(R14)     NO, TRANSLATE\n         B     PSTRQUOT\n         SPACE\n         AIF   ('&OPSYS' NE 'MVS').NMVS1D\n*\n*        IGNORE PARENTHESES WITHIN COMMENTS\n*\nPSTRSLSH BXH   R8,R6,PSTREND      EXIT IF OUT OF TEXT\n         CLI   0(R8),C'*'         * AFTER /?\n         BNE   PSTRLOOP           NO, NOT A COMMENT\nPSTRCONT BXH   R8,R6,PSTREND      YES, LOOK FOR */\n         CLI   0(R8),C'*'\n         BNE   PSTRCOM\n         BXH   R8,R6,PSTREND\n         CLI   0(R8),C'/'\n         BE    PSTRASIS           FINALLY BACK TO NORMAL\nPSTRCOM  TM    1(R9),X'40'        UPPERCASE IF ASIS\n         BNZ   PSTRCONT\n         TR    0(1,R8),0(R14)\n         B     PSTRCONT\n.NMVS1D  SPACE\nPSTROPEN AR    R15,R6             INCREASE IMBALANCE COUNT\n         B     PSTRASIS           AND CONTINUE\n         SPACE\nPSTRCLOS BCT   R15,PSTRASIS       DECREASE IMBALANCE COUNT\n         SPACE\nPSTREND  LR    R10,R8\n         SR    R10,R3             COMPUTE STRING LENGTH\n         STH   R10,4(,R2)         AND STORE IN PDE\n         MVI   6(R2),X'80'\n         SR    R15,R15            SET GOOD RETURN CODE\n         MVI   BYPASS,0           PSTRINGS CANNOT BE BYPASS\n         CR    R8,R7              STILL IN BOUNDS?\n         BH    RETURN             NO, ESCAPE\n         AR    R8,R6              YES, SKIP PAST CLOSING PAREN\n         B     RETURN\n         TITLE 'CLUZIDEN -- NON-DELIMITER DEPENDENT (IKJIDENT) RECOGNIZ*\n               ER'\n*\n*        THIS ROUTINE RECOGNIZES NON-DELIMITER DEPENDENT POSITIONAL\n*        PARAMETERS DESCRIBED BY THE IKJIDENT MACRO\n*\nCLUZIDEN LIENTRY DSA=IDENDSA,DSALEN=IDENLEN,PARM=R2,ENV=R5\n*\n*        GET THE MAXIMUM LENGTH ALLOWED, IF ONE WAS SPECIFIED\n*\n         AIF   ('&OPSYS' NE 'MVS').NMVS5A\n         TM    6(R9),X'10'        INTEGER IDENT?\n         BNZ   INTGIDEN           YES, MAXLEN IMPLIED\n         MVI   IDENTYPE,0         NO, START WITH NO TYPE FLAGS\n.NMVS5A  L     R15,=X'7FFFFFFF'   ASSUME NO MAX LEN\n         TM    6(R9),X'40'        WERE WE RIGHT?\n         BZ    IDENBEGN           YES.\n         MVC   ALIGN,9(R9)        NO, FIND MAX LENGTH\n         LH    R15,ALIGN\n         LA    R15,9(R9,R15)\n         SR    R1,R1\n         IC    R1,0(,R15)\n         LR    R15,R1             AND SAVE IN R15\n         SPACE\n*\n*        SEE IF THE FIRST CHARACTER IS THE RIGHT KIND\n*\nIDENBEGN EQU   *\n         AIF   ('&OPSYS' NE 'MVS').NMVS5B\n         TM    6(R9),X'08'        CHAR IDENT?\n         BNZ   CHARIDEN           YES, ESCAPE TO CHAR ROUTINE\n         TM    6(R9),X'04'        HEX IDENT?\n         BNZ   HEXIDEN            YES, ESCAPE TO HEX ROUTINE\n.NMVS5B  ANOP\nIDENSCAN SR    R1,R1\n         IC    R1,0(,R8)\n         LA    R3,SCANTAB(R1)     INSPECT 1ST CHAR\n         CLI   0(R8),C')'         IS IT A )?\n         BE    IDENABS            YES, IDENT NOT PRESENT\n         IC    R1,7(,R9)          NO, LOAD CHAR 1 CODE\n         CLI   7(R9),0            IS ANYTHING OK?\n         BE    IDENHERE           YES.\n         IC    R1,IDENBITS-1(R1)\n         EX    R1,IDENTEST        NO, SEE IF FIRST CHAR OK\n         BNZ   IDENHERE           YES IT IS\n         SPACE\n*\n*        SEE IF ASTERISK IS ALLOWED AND WE HAVE ONE\n*\nIDENMISS TM    6(R9),X'80'        IS ASTERISK SPECIFIED?\n         BZ    IDENABS            NO.\n         CLI   0(R8),C'*'         YES, CHECK FOR *\n         BE    IDENSTAR           OK\nIDENABS  LA    R15,4              NO, MAKE IT MISSING\n         B     RETURN             AND RETURN\n         SPACE\nIDENHERE SR    R10,R10            ZERO PAREN COUNT\n         L     R14,=V(CLUTSCAP)   ADDR UPPER CASE TABLE\n         CLI   0(R8),C'('         STARTING WITH PAREN?\n         BNE   IDENNOPN           NO.\n         LR    R10,R6             YES, SET COUNT TO 1\nIDENNOPN ST    R8,0(,R2)          SAVE START IN PDE\n         LR    R0,R8              SAVE STARTING POINT\n         IC    R1,8(R9)           LOAD TYPE CODE FOR OTHER CHARS\n         LTR   R1,R1              IS IT ALL?\n         BZ    IDENALL            YES.\n         IC    R1,IDENBITS-1(R1)\nIDENALL  MVI   6(R2),X'80'        SET PRESENT FLAG\n         SPACE\n*\n*        IF OTHER\u00ac=ALL, SCAN UNTIL A NON-ALPHANUMERIC/NATIONAL IS FOUND\n*\nIDENOK   TM    1(R9),X'40'        ASIS MODE?\n         BNZ   IDENASIS           YES.\n         TR    0(1,R8),0(R14)     NO, TRANSLATE THIS CHAR\nIDENASIS BXH   R8,R6,IDENEND      ANYTHING LEFT?\n         SR    R3,R3              YES, LOOK AT IT\n         IC    R3,0(,R8)\n         LA    R3,SCANTAB(R3)\n         LTR   R1,R1              TYPE=ALL?\n         BZ    IDENCNT            YES.\n         EX    R1,IDENTEST        NO, CHECK TYPE\n         BNZ   IDENOK             BRANCH IF OK\n         TM    0(R3),X'E0'        IS IT ALPHANUMERIC | NATIONAL?\n         BZ    IDENEND            NO, STOP SCAN NOW\n         B     IDENSKIP           YES, CONTINUE ERROR SCAN\n         SPACE\n*\n*        IF OTHER=ALL, SCAN FOR A SEPARATOR OTHER THAN /\n*\nIDENCNT  TM    0(R3),X'10'        HAVE WE A SEPARATOR?\n         BZ    IDENNSEP           NO.\n         CLI   0(R8),C'/'         YES, ALLOW SLASH\n         BNE   IDENEND            OTHERWISE IDEN IS ENDED\n         B     IDENASIS\nIDENNSEP CLI   0(R8),C'('         HAVE WE AN OPEN?\n         BE    IDENOPEN           YES.\n         CLI   0(R8),C')'         A CLOSE?\n         BNE   IDENOK             NO.\n         SR    R10,R6             DECREASE PAREN COUNT\n         BM    IDENEND            STOP IF COUNT GOES NEGATIVE\n         B     IDENASIS           ELSE CONTINUE\nIDENOPEN AR    R10,R6             ADD 1 TO PAREN COUNT\n         B     IDENASIS           AND CONTINUE\n         SPACE\n*\n*        THIS CODE SKIPS TO THE NEXT NON-ALPHANUMERIC/NATIONAL AFTER\n*        AN ERROR HAS BEEN DETECTED\n*\nIDENSKIP IC    R1,0(,R8)          GET NEXT CHAR\n         LA    R3,SCANTAB(R1)\n         TM    0(R3),X'E0'        IS IT ALPHANUMERIC | NATIONAL?\n         BZ    IDENBAD            NO, TIME TO QUIT\n         BXH   R8,R6,IDENBAD      QUIT WHEN TEXT GONE\n         B     IDENSKIP\n         SPACE\nIDENEND  EQU   *\n         AIF   ('&OPSYS' NE 'MVS').NMVS5C\n         TM    6(R9),X'08'        IS THIS A CHAR IDENT?\n         BNZ   IDENGOOD           YES, UNBALANCED PARENS ARE OK\n.NMVS5C  LTR   R10,R10            WERE PARENTHESES BALANCED?\n         BP    IDENBAD            NO, EVIL IDENT\nIDENGOOD LR    R3,R8              YES, COMPUTE LENGTH\n         SR    R3,R0\n         CR    R3,R15             WAS IT TOO LONG?\n         BH    IDENBAD            YES.\n         STH   R3,4(,R2)          STORE LENGTH IN PDE\n         AIF   ('&OPSYS' NE 'MVS').NMVS5D\n         TM    6(R9),X'10'        INTEGER IDENT?\n         BNZ   INTGEND            YES, RETURN TO INTEGER ROUTINE\n.NMVS5D  B     IDENDONE           IDEN COMPLETED\n         SPACE\n*\n*        THIS CODE REJECTS AN INVALID IDENT\n*\nIDENBEND AR    R8,R6              SKIP CURRENT CHAR\nIDENBAD  LA    R15,8              SET EVIL RET CODE\n         B     RETURN\n         SPACE\n*\n*        THIS CODE HANDLES AN ASTERISK\n*\nIDENSTAR ST    R8,0(,R2)          STORE STAR ADDR\n         AR    R8,R6              SKIP\n         MVC   4(2,R2),=H'1'      LENGTH OF 1\n         SPACE\nIDENDONE MVI   6(R2),X'80'        INDICATE PRESENT\n         AIF   ('&OPSYS' NE 'MVS').NMVS5E\n         OC    6(1,R2),IDENTYPE   TURN ON AMS TYPE FLAGS\n.NMVS5E  SR    R15,R15            RETURN HAPPY\n         B     RETURN\n         SPACE\nIDENTEST TM    0(R3),X'00'        TEST TYPE OF CURRENT CHAR\nIDENBITS DC    X'A040E02060'      IDENT TYPE CODES\n         TITLE 'CLUZIDEN/CLUZCHAR -- CHARACTER/PASSWORD RECOGNITION'\n*\n*        THIS ROUTINE ROUTES CONTROL TO EITHER THE IDENT OR THE QUOTED\n*        STRING RECOGNIZER FOR A PASSWORD\n*\nCLUZCHAR LIENTRY DSA=IDENDSA,DSALEN=IDENLEN,ENV=R5,PARM=R2\n*\n*        SET UP A FAKE PCE FOR THE IDENT ROUTINE\n*\n         AIF   ('&OPSYS' NE 'MVS').NMVS5F\n         MVI   IDENTYPE,0         NO AMS FLAGS FOR PASSWORD\n.NMVS5F  LA    R15,8              MAXIMUM PASSWORD LENGTH\n         MVC   FAKEIDEN,CHARPASS  MOVE IN PSEUDO-PCE\nCHARBEGN NC    FAKEIDEN+1(1),1(R9)     COPY ASIS FLAG\n         LA    R9,FAKEIDEN\n         CLI   0(R8),C''''        DOES IT START WITH A QUOTE?\n         BE    CHARQUOT           YES.\n         B     IDENSCAN           NO, TREAT AS ALPHANUM IDENT\nCHARQUOT LR    R0,R15             MOVE MAX LEN FIELD\n         B     QSTRYES            AND TREAT AS QSTRING\n         SPACE\nCHARPASS DC    X'8040',2H'0',X'400303'   PCE FOR PASSWORD-LIKE IDENT\n         AIF   ('&OPSYS' NE 'MVS').NMVS5G\nCHARPCE  DS    0H\n         DC    X'8040',2H'0',X'080000'   PCE FOR ANY-ANY IDENT\n         SPACE\n*\n*        HANDLE A CHAR-TYPE IDENT. THIS IS TREATED LIKE AN ANY-ANY\n*        IDENT, EXCEPT THAT BALANCED PARENTHESES ARE NOT REQUIRED.\n*\nCHARIDEN MVC   FAKEIDEN,CHARPCE   MOVE IN PSEUDO-PCE\n         OI    IDENTYPE,X'04'     INDICATE CHARACTER VALUE\n         B     CHARBEGN\n         SPACE\n         TITLE 'CLUZIDEN -- INTEGER RECOGNITION'\n*\n*        DETERMINE IF THE INTEGER IS DECIMAL, HEXADECIMAL, BINARY\n*        OR INVALID\n*\nINTGIDEN MVI   IDENTYPE,X'02'     INDICATE NUMERIC VALUE TYPE\n         SR    R1,R1\n         IC    R1,0(,R8)\n         EX    R1,INTGSEEB        IS FIRST CHAR B?\n         BE    BINTG              YES, CHECK FOR B'\n         EX    R1,HEXSEEX         IS FIRST CHAR X?\n         BE    HEXINTG            YES, CHECK FOR X'\n         OI    IDENTYPE,X'10'     INDICATE DECIMAL INPUT\n         MVC   FAKEIDEN,INTGPCE   SET UP ALL NUMERIC PCE FOR IDENT\n         LA    R15,10             MAXLNTH FOR INTEGERS\n         LA    R9,FAKEIDEN\n         B     IDENBEGN           TREAT AS NORMAL IDENT\nINTGSEEB CLI   =C'B',X'40'        LOWER OR UPPER CASE B?\nINTGPCE  DC    X'8000',2H'0',X'500202' IDENT PCE FOR DECIMAL INTEG\n         SPACE 5\n*\n*        SEE IF THE DECIMAL VALUE WILL FIT IN A FULLWORD\n*\nINTGEND  LR    R14,R0             COPY IDENT START POINT\n         CH    R3,=H'9'           <10 DIGITS?\n         BNH   INTGOK             YES, MUST BE IN BOUNDS\n         CLC   0(10,R14),=C'4294967296' IS IT TOO BIG?\n         BNL   IDENBAD            YES.\nINTGOK   BCTR  R3,0\n         EX    R3,INTGPACK        CONVERT TO BINARY\n         CP    DECWORK,=P'2147483648'  WILL HIGH-ORDER BIT BE ON?\n         BL    INTGPOS            NO.\n         SP    DECWORK,=P'4294967296'  YES, MAKE NEGATIVE FOR CVB\nINTGPOS  CVB   R14,DECWORK        MAKE IT BINARY\n         ST    R14,INTWORK        STORE IN WORK AREA\n         SPACE\n*\n*        RETURN THE INTEGER VALUE\n*\nINTGRET  LA    R1,4               LENGTH OF INTEGER VALUE\n         L     R15,=A(CLUZALOC)\n         BALR  R14,R15            GET MEMORY FOR INTEGER\n         L     R14,NEWMEM\n         MVC   0(4,R14),INTWORK   MOVE VALUE IN\n         MVC   4(2,R2),=H'4'      STORE LENGTH\n         ST    R14,0(,R2)         AND LOCATION\n         MVI   6(R2),X'80'        INDICATE INTEGER PRESENT\n         OC    6(1,R2),IDENTYPE   ADD TYPE BITS\n         SR    R15,R15            SET GOOD RETURN CODE\n         B     RETURN\nINTGPACK PACK  DECWORK(8),0(0,R14)     PACK DIGITS\n         TITLE 'CLUZIDEN -- BINARY INTEGER RECOGNITION'\n*\n*        THIS ROUTINE RECOGNIZES INTEGERS IN THE B'...' FORMAT\n*\nBINTG    CR    R7,R8              ANY MORE TEXT LEFT?\n         BNH   IDENABS            NO, INTEGER MISSING\n         CLI   1(R8),C''''        YES, IS THERE A QUOTE AFTER THE B?\n         BNE   IDENABS            NO, IT'S MISSING\n         OI    IDENTYPE,X'08'     YES, INDICATE BINARY INPUT\n         SR    R1,R1\n         LR    R15,R1             SET UP ACCUMULATOR\n         LA    R14,33             NUMBER OF BITS\n         AR    R8,R6              SKIP PAST B\n         SPACE\nBINLOOP  BXH   R8,R6,BINUNCL      GET A BIT\n         CLI   0(R8),C'1'         IS IT 1?\n         BE    BINBIT             YES.\n         CLI   0(R8),C'0'         0?\n         BE    BINBIT             YES.\n         CLI   0(R8),C''''        CLOSING QUOTE?\n         BE    BINEND             YES.\n         IC    R1,0(,R8)\n         LA    R3,SCANTAB(R1)\n         TM    0(R3),X'11'        IS IT A TERMINATOR?\n         BNZ   BINUNCL            YES.\n         B     BINBAD             NO, BAD BINARY\n         SPACE\nBINBIT   SLL   R15,1              SHIFT VALUE ONE\n         CLI   0(R8),C'0'         IS THIS BIT 0?\n         BE    BINNEXT            YES, NO CHANGE\n         ALR   R15,R6             NO, ADJUST AGAIN\nBINNEXT  BCT   R14,BINLOOP        CONTINUE UP TO 32 BITS\n         SPACE\nBINBAD   BXH   R8,R6,IDENBAD\n         CLI   0(R8),C''''        SKIP TO APOSTROPHE\n         BE    IDENBEND\n         IC    R1,0(,R8)\n         LA    R3,SCANTAB(R1)\n         TM    0(R3),X'11'        FOUND A TERMINATOR\n         BNZ   IDENBAD            YES, ESCAPE\n         B     BINBAD             NO, KEEP LOOKING\n         SPACE\nBINEND   AR    R8,R6              SKIP CLOSING QUOTE\n         B     BINDONE            AND RETURN\n         SPACE\nBINUNCL  BAL   R14,UNCL           GIVE UNCLOSED MSG\nBINDONE  MVI   6(R2),X'80'        SET PRESENT FLAG\n         ST    R15,INTWORK        STORE VALUE IN INTWORK\n         B     INTGRET            AND GO TO RETURN VALUE\n         TITLE 'CLUZIDEN -- HEXADECIMAL RECOGNITION'\n*\n*        THIS ROUTINE HANDLES A HEXADECIMAL VALUE OF THE FORM\n*        X'...'\n*\nHEXIDEN  SR    R1,R1\n         IC    R1,0(,R8)\n         EX    R1,HEXSEEX         DOES IT START X?\n         BNE   CHARIDEN           NO, TREAT AS CHAR\n         LA    R3,CHARIDEN\n         B     HEXJOIN            JOIN INTEG CASE\nHEXSEEX  CLI   =C'X',X'40'        SEE IF UPPER OR LOWER CASE X\n         SPACE\nHEXINTG  LA    R15,8              8 DIGITS ALLOWED FOR INTEGER\n         LA    R3,IDENMISS        WHERE TO GO IF MISSING\n         SPACE\n*\n*        FIRST SCAN THE INPUT TO SEE IF IT IS VALID HEX\n*\nHEXJOIN  CR    R8,R7              ANYTHING LEFT?\n         BCR   11,R3              NO, NOT HEX\n         CLI   1(R8),C''''        DOES A QUOTE FOLLOW X?\n         BCR   7,R3               NO, NOT X\n         LA    R8,2(,R8)          YES, SKIP X'\n         LR    R10,R8             SAVE STARTING POINT\n         OI    IDENTYPE,X'01'     INDICATE HEX INPUT\n         TM    6(R9),X'40'        IS THERE A MAXLNTH?\n         BZ    HEXLOOP            NO.\n         AR    R15,R15            YES, TWICE AS MANY DIGITS ALLOWED\n         SPACE\nHEXLOOP  IC    R1,0(,R8)          INSPECT NEXT CHAR\n         LA    R3,SCANTAB(R1)\n         TM    0(R3),X'11'        IS IT A SEPARATOR?\n         BNZ   HEXOVER            YES, END OF PARM\n         TM    0(R3),X'60'        NO, IS IT ALPHAMERIC?\n         BZ    HEXOFF             NO.\n         TM    0(R3),X'80'        YES, IS IT A HEX DIGIT?\n         BNZ   HEXBAD             NO, EVIL\n         BXLE  R8,R6,HEXLOOP      YES, CONTINUE\n         B     HEXOVER            QUIT WHEN NO TEXT LEFT\n         SPACE\nHEXOFF   CLI   0(R8),C''''        CLOSING QUOTE?\n         BE    HEXOVER            YES.\nHEXBAD   BXH   R8,R6,IDENBAD      NO, SEARCH FOR END OF BAD TEXT\n         CLI   0(R8),C''''        STOP AT APOSTROPHE\n         BE    IDENBEND\n         IC    R1,0(,R8)\n         LA    R3,SCANTAB(R1)\n         TM    0(R3),X'11'        OR AT SEPARATOR\n         BNZ   IDENBAD\n         B     HEXBAD\n         SPACE\nHEXOVER  LR    R3,R8\n         SR    R3,R10             COMPUTE LENGTH\n         CR    R3,R15             COMPARE TO MAX\n         BNH   HEXSHORT           ESCAPE IF TOO BIG\n         CLI   0(R8),C''''        DID VALUE END WITH QUOTE?\n         BNE   IDENBAD            NO.\n         AR    R8,R6              YES, REJECT QUOTE TOO\n         B     IDENBAD\n         SPACE\nHEXSHORT CR    R8,R7              DID WE REACH THE END?\n         BH    HEXUNCL            NO, UNCLOSED\n         CLI   0(R8),C''''        YES, DID IT CLOSE PROPERLY?\n         BNE   HEXUNCL            NO.\n         AR    R8,R6              YES, SKIP QUOTE\n         B     HEXCVT             GO TO CONVERT\nHEXUNCL  BAL   R14,UNCL           GIVE UNCLOSED MSG\n         SPACE\n*\n*        CONVERT THE HEX TO INTERNAL BINARY\n*\nHEXCVT   TM    6(R9),X'10'        INTEGER IDENT?\n         BNZ   HEXCVINT           YES, CONVERT TO INTEGER\n         LA    R1,1(,R3)          TAKE FLOOR((LENGTH+1)/2)\n         SRL   R1,1\n         STH   R1,4(,R2)          STORE IN PDE\n         LA    R1,3(,R1)          ROUND TO FULLWORD\n         N     R1,=F'-3'\n         L     R15,=A(CLUZALOC)\n         BALR  R14,R15            GET MEMORY FOR VALUE\n         L     R1,NEWMEM\n         LA    R15,8              DIGITS TO CONVERT AT A TIME\n         LCR   R14,R15\n         LA    R3,7(,R3)          ADJUST FOR FIRST ENTRY\nHEXCLOOP BXLE  R3,R14,HEXCLAST    8 DIGITS LEFT?\n         MVC   DECWORK,0(R10)     YES, MOVE TO WORK AREA\n         NC    DECWORK,=8X'1F'    TURN OFF USELESS BITS\n         TR    DECWORK,HEXCVTAB   CONVERT TO BINARY\n         PACK  HEXWORK(5),DECWORK(9)   PACK INTO FULLWORD\n         MVC   0(4,R1),HEXWORK    MOVE TO OUTPUT BUFFER\n         LA    R1,4(,R1)          BUMP OUTPUT POINTER\n         SR    R10,R14            BUMP INPUT POINTER\n         B     HEXCLOOP           AND CONTINUE\nHEXCLAST XC    DECWORK,DECWORK    EXTRA ZEROES FOR LAST TIME\n         EX    R3,HEXMLAST        MOVE LAST DIGITS IN\n         NC    DECWORK,=8X'1F'    OR OFF BITS\n         TR    DECWORK,HEXCVTAB   TRANSLATE\n         PACK  HEXWORK(5),DECWORK(9)   PACK\n         MVC   0(4,R1),HEXWORK    SAVE THE RESULT\n         TM    6(R9),X'10'        INTEGER?\n         BNZ   HEXINTOK           YES, EXIT\n         L     R1,NEWMEM\n         ST    R1,0(,R2)          NO, SAVE BUFFER ADDRESS IN PDE\n         MVI   6(R2),X'80'        SET PRESENT FLAG\n         OC    6(1,R2),IDENTYPE   SET TYPE BIT(S)\n         SR    R15,R15            AND RETURN HAPPY\n         B     RETURN\nHEXMLAST MVC   DECWORK(0),0(R10)  MOVE LAST DIGITS TO WORK AREA\n         SPACE\nHEXCVINT LA    R6,32\n         SLL   R3,2               CONVERT NUMBER DIGITS TO BITS\n         SR    R6,R3              DETERMINE SCALE FACTOR\n         LA    R1,INTWORK         DESTINATION ADDR\n         LA    R3,7\n         B     HEXCLAST           JOIN HEX CASE\n         SPACE\nHEXINTOK L     R0,INTWORK         LOAD HEX VALUE\n         SRL   R0,0(R6)           COMPENSATE FOR UNENTERED DIGITS\n         ST    R0,INTWORK         STORE\n         MVI   6(R2),X'80'        SET PRESENT\n         B     INTGRET            GO FINISH OFF INTEGER\n         SPACE\nHEXCVTAB DC    X'000A0B0C0D0E0F',9X'00' HEX->BINARY TRANSLATE TABLE\n         DC    X'00010203040506070809'\n.NMVS5G  SPACE 5\nIDENDSA  DSECT ,                  FOR USE BY IDEN & CHAR ROUTINES\n         SPACE\n         DS    22A                SAVE AREA\n         AIF   ('&OPSYS' NE 'MVS').NMVS5H\nDECWORK  DS    D                  DECIMAL WORK AREA\nINTWORK  DS    F                  INTEGER WORK AREA\nHEXWORK  DS    CL5                HEX WORK AREA\nIDENTYPE DS    BL1                AMS INPUT TYPE BITS\n.NMVS5H  ANOP\nFAKEIDEN DS    CL9                FAKE-PCE STORAGE\n         DS    0D\nIDENLEN  EQU   *-IDENDSA          LENGTH OF DSA\n         SPACE\nCLUTSREC CSECT\n         TITLE 'CLUZITEM -- KEYWORD/MISCELLANEOUS RECOGNIZER'\n*\n*        THIS ROUTINE IS USED TO RECOGNIZE KEYWORDS. IT IS ALSO USED\n*        TO GUESS WHAT PART OF THE FOLLOWING INPUT SHOULD BE REJECTED\n*        WHEN UNINTELLIGIBLE INFORMATION MUST BE HANDLED.\n*\nCLUZITEM LIENTRY DSA=*,DSALEN=88,ENV=R5\n         SR    R1,R1\n         SR    R15,R15\n         LR    R3,R8              SAVE STARTING POINT\n         CLI   0(R8),C'/'         SLASH FIRST?\n         BE    ITEMEVIL           YES, INVALID KEYWORD\n         CLI   0(R8),C';'         LOOK FOR MISPLACED SEMICOLON\n         BE    ITEMEVIL           JUST A CHARACTER IF FOUND\n         CLI   0(R8),C'('         PAREN FIRST?\n         BE    ITEMPREN           YES, DON'T REJECT MORE\n         CLI   0(R8),C')'\n         BNE   ITEMMORE\nITEMPREN AR    R8,R6              SKIP PARENTHESIS\nITEMBAD  LA    R15,4              AND SAY BAD ITEM\n         B     RETURN\n         SPACE\n*\n*        SCAN UNTIL A SEPARATOR OR A PARENTHESIS IS FOUND. IF, HOWEVER,\n*        A QUOTE IS FOUND, GIVE UP WHEN THE QUOTE CLOSES.\n*\nITEMNEXT BXH   R8,R6,ITEMEND      ON TO NEXT CHAR\n         CLI   0(R8),C'('         OPEN PAREN?\n         BE    ITEMEND            YES, TIME TO STOP\n         CLI   0(R8),C')'         NO, CLOSE PAREN?\n         BE    ITEMEND            YES, STOP NOW\nITEMMORE CLI   0(R8),C''''        OPEN QUOTE\n         BE    ITEMQUOT           YES, STOP AT CLOSE QUOTE\n         IC    R1,0(,R8)\n         LA    R10,SCANTAB(R1)\n         TM    0(R10),X'10'       IS NEXT CHAR A SEPARATOR?\n         BNZ   ITEMEND            YES, QUIT NOW\n         TM    0(R10),X'A0'       NO, IS IT ALPHA?\n         BNZ   ITEMFOLD           YES.\n         TM    0(R10),X'40'       NUMERIC?\n         BZ    ITEMEVIL           NO, BAD KEYWORD\n         CR    R3,R8              FIRST CHAR OF ITEM?\n         BE    ITEMEVIL           YES, NUMERIC IS INVALID\n         B     ITEMNEXT           NO, CONTINUE\nITEMFOLD TM    1(R9),X'40'        IS PDE ASIS?\n         BNZ   ITEMNEXT           YES.\n         OI    0(R8),X'40'        NO, UPPER CASE LETTER\n         B     ITEMNEXT           AND CONTINUE\nITEMEVIL LA    R15,4              INDICATE BAD RESULT\n         B     ITEMNEXT           AND CONTINUE\n         SPACE\nITEMQUOT LA    R15,4              IF QUOTED, INVALID KEYWORD\nITEMQLOP BXH   R8,R6,ITEMEND      BUT LOOK FOR CLOSE QUOTE\n         CLI   0(R8),C''''\n         BNE   ITEMQLOP\n         BXH   R8,R6,ITEMEND\n         CLI   0(R8),C''''        CHECK FOR DOUBLED QUOTE\n         BE    ITEMQLOP\n         SPACE\nITEMEND  LTR   R15,R15            ANY PROBLEM FOUND?\n         BNZ   RETURN             YES.\n         LR    R10,R8             NO, CHECK KEYWORD LENGTH\n         SR    R10,R3\n         CH    R10,=H'31'         MUST BE <= 31\n         BH    ITEMBAD\n         B     RETURN\n         TITLE 'CLUZDSNM -- DSNAME/DSTHING RECOGNIZER'\n*\n*        THIS ROUTINE RECOGNIZES DSNAMES AND DSTHINGS\n*\nCLUZDSNM LIENTRY DSA=DSNWORK,DSALEN=DSNWLEN,ENV=R5,PARM=R2\n         SR    R14,R14\n         SR    R0,R0\n         SR    R1,R1\n         MVI   DSNFLAG,0          INIT FLAGS\n         MVI   PASSF,PASSABLE     INDICATE PASSWORD MAY FOLLOW\n         LA    R10,16(,R2)        FIND PASSWORD PART OF PDE\n         ST    R10,PASSPDE        AND STORE\n         LR    R10,R8             SAVE STARTING POINT\n         SPACE\n*\n*        SEE IF THE FIRST CHARACTER IS LEGAL. IF NOT, THE DSNAME IS\n*        MISSING\n*\n         CLI   0(R8),C''''        STARTING WITH QUOTE?\n         BE    DSNQUOT            YES.\n         IC    R1,0(,R8)          NO, INSPECT 1ST CHAR\n         LA    R3,SCANTAB(R1)\n         TM    0(R3),X'A0'        IS IT ALPHANATIONAL?\n         BNZ   DSNALPHA           YES.\n         CLI   0(R8),C'('         NO, STARTING PAREN?\n         BE    DSNMEM             YES, MEMBER ONLY\n         CLI   6(R9),8            NO, IS THIS A DSTHING?\n         BNE   DSNNSTAR           NO, * NOT ALLOWED\n         CLI   0(R8),C'*'         YES, DOES IT START *?\n         BE    DSNSTAR            YES.\n         SPACE\nDSNNSTAR EQU   *\n         AIF   ('&OPSYS' NE 'MVS').NMVS6A\n         TM    0(R3),X'40'        IS THIS A DIGIT?\n         BZ    DSNMISS            NO, BAD DSNAME\n         TM    1(R9),X'02'        YES, IS VOLSER SPECIFIED?\n         BNZ   DSNVOL             YES, ALLOW VOLSER\n.NMVS6A  ANOP\nDSNMISS  LA    R15,4              SET MISSING RET CODE\n         NI    PASSF,255-PASSABLE KILL PASSWORD OK FLAG\n         B     RETURN             AND RETURN\n         SPACE\n*\n*        ANALYZE THE DSNAME PROPER. CONSIDER IT TO STOP WHEN A\n*        CHARACTER OTHER THAN A ALPHAMERIC/NATIONAL OR PERIOD IS FOUND.\n*        (* IS ALSO ALLOWED FOR DSTHINGS)\n*\nDSNQUOT  OI    DSNFLAG,DSNQ       SET QUOTED FLAG\n         BXH   R8,R6,DSNERR       ERROR IF NOTHING MORE\n         LR    R10,R8             SAVE STARTING POINT\n         SPACE\nDSNCHAR  IC    R1,0(,R8)\n         LA    R3,SCANTAB(R1)     LOOK AT NEXT CHAR\n         TM    0(R3),X'A0'        IS IT ALPHA-NATIONAL?\n         BNZ   DSNALPHA           YES.\n         TM    0(R3),X'40'        A DIGIT?\n         BNZ   DSNDIGIT           YES.\n         TM    0(R3),X'10'        A SEPARATOR\n         BNZ   DSNOVER            YES, DSN PROPER IS DONE\n         CLI   0(R8),C'.'         A PERIOD?\n         BE    DSNDOT             YES.\n         CLI   6(R9),8            DSTHING ALLOWED?\n         BNE   DSNOOPS            NO, BAD STUFF\n         CLI   0(R8),C'*'         YES, HAVE WE A STAR?\n         BE    DSNSTAR            YES.\nDSNOOPS  EQU   *\n         AIF   ('&OPSYS' NE 'MVS').NMVS6B\n         CLI   0(R8),C'-'         IS THIS A HYPHEN?\n         BE    DSNDIGIT           YES, TRAET AS DIGIT.\n         CLI   0(R8),X'C0'        HOW ABOUT A +0?\n         BE    DSNDIGIT           YES, ALSO PSEUDO-DIGIT\n.NMVS6B  TM    0(R3),X'08'        HAVE WE A NON-DELIMITER (,),',*?\n         BNZ   DSNOVER            YES, DSNAME ENDED\n         B     DSNOUCH            NO, GO FIND END OF BAD DSN\n         SPACE\nDSNALPHA LTR   R0,R0              IS A LETTER ALLOWED?\n         BM    DSNOUCH            NO, PERIOD REQUIRED.\n         AR    R14,R6             YES, INCREASE LEVEL COUNT\n         TM    1(R9),X'40'        ASIS?\n         BNZ   DSNASIS            YES.\n         OI    0(R8),X'40'        NO, UPPERCASE LETTER\nDSNASIS  LR    R0,R6              ALLOW ANYTHING AFTER\n         CH    R14,=H'8'          UNLESS 8 CHARS IN LEVEL\n         BL    DSNNEXT\n         LCR   R0,R0              IN WHICH CASE . IS REQUIRED\n         B     DSNNEXT\n         SPACE\nDSNDIGIT LTR   R0,R0              IS A DIGIT OK?\n         BNP   DSNDIG2            NO.\n         AR    R14,R6             YES, INCREASE LEVEL COUNT\n         B     DSNASIS            AND DECIDE NEXT STATE\n         SPACE\nDSNDOT   LTR   R0,R0              IS A . OK?\n         BZ    DSNOUCH            NOT AFTER ANOTHER .\n         SR    R0,R0              YES, FORCE LETTER NEXT\n         LR    R14,R0             RESET LEVEL COUNT\n         B     DSNNEXT\n         SPACE\nDSNSTAR  LTR   R0,R0              RIGHT AFTER A .?\n         BNZ   DSNOUCH            NO, EVIL\n         LCR   R0,R6              YES, FORCE . AFTER\n         SPACE\nDSNNEXT  BXLE  R8,R6,DSNCHAR      AND CONTINUE\n         SPACE\n*\n*        SEE IF THERE IS A MEMBER NAME AFTER THE DSNAME\n*\nDSNOVER  LTR   R0,R0              WAS LAST CHAR .?\n         BNZ   DSNOKEND           NO.\n         OI    DSNFLAG,DSNERRF    YES, SET ERROR FLAG\nDSNOKEND LR    R0,R8\n         SR    R0,R10             COMPUTE DSN LENGTH\n         SR    R14,R14            INIT. MEMBER LENGTH\nDSNCONT  CR    R8,R7              ANY TEXT LEFT?\n         BH    DSNALL             NO.\nDSNCHMEM CLI   0(R8),C'('         YES, DOES A MEMBER FOLLOW?\n         BE    DSNMEM             YES.\n         B     DSNQCHEK           NO, CHECK FOR CLOSING QUOTE\n         SPACE\n         AIF   ('&OPSYS' EQ 'MVS').MVS6C\nDSNDIG2  EQU   *\n         AGO   .JMVS6C\n.MVS6C   ANOP\n*\n*        A DIGIT HAS BEEN FOUND IN AN INVALID SPOT. SEE IF IT COULD\n*        BE THE FIRST DIGIT OF A VOLSER.\n*\nDSNDIG2  CR    R8,R10             JUST STARTING?\n         BNE   DSNOUCH            NO, ERROR\n         TM    1(R9),X'02'        YES, CAN THIS BE A VOLSER?\n         BZ    DSNOUCH            NO, ERROR\nDSNVOL   LR    R10,R8             SAVE STARTING POINT\nDSNVLOOP BXH   R8,R6,DSNVEND\n         IC    R1,0(,R8)\n         LA    R3,SCANTAB(R1)     CHECK NEXT CHAR\n         TM    0(R3),X'10'        SEPARATOR?\n         BNZ   DSNVEND            YES, END OF VOLSER\n         TM    0(R3),X'E0'        ALPHANUMERIC | NATIONAL?\n         BNZ   DSNVOK             YES.\n         CLI   0(R8),C'-'         HAVE WE A HYPHEN?\n         BE    DSNVOK             YES, THAT'S OK\n         CLI   0(R8),X'C0'\n         BE    DSNVOK             SO IS A +0\n         TM    0(R3),X'08'        NON-DELIMITER?\n         BNZ   DSNVEND            YES, VOLSER FINISHED\n         B     DSNOUCH            NO, BAD DSNAME\nDSNVOK   TM    1(R9),X'40'        ASIS?\n         BNZ   DSNVLOOP           NO, DON'T SHIFT\n         OI    0(R8),X'40'        YES, TO UPPER CASE\n         B     DSNVLOOP\nDSNVEND  LR    R0,R8\n         SR    R0,R10             COMPUTE LENGTH OF VOLSER\n         CH    R0,=H'6'           > 6?\n         BNH   DSNCONT            NO.\n         OI    DSNFLAG,DSNERRF    YES, INDICATE ERROR\n         B     DSNSKMID           AND SKIP REST OF NAME\n.JMVS6C  SPACE\n*\n*        AFTER A SYNTAX ERROR IS DETECTED, CONTINUE SCANNING TO FIND\n*        THE END OF THE NAME\n*\nDSNOUCH  OI    DSNFLAG,DSNERRF     SET ERROR FLAG\nDSNSKIM  BXH   R8,R6,DSNERR        LOOK FOR THE END\n         IC    R1,0(,R8)\n         LA    R3,SCANTAB(R1)\n         TM    0(R3),X'E0'         ALPHANUMERIC | NATIONAL?\n         BNZ   DSNSKIM             YES, CONTINUE\nDSNSKMID CLI   0(R8),C''''         QUOTE?\n         BE    DSNQCHK2            YES, EXIT\n         CLI   0(R8),C'('          PAREN?\n         BE    DSNMEM              YES, EXIT\n         TM    0(R3),X'18'         SEPARATOR | NON-DELIMITER?\n         BNZ   DSNALL              YES, EXIT\n         B     DSNSKIM             CONTINUE LOOKING\n         SPACE\n*\n*        HANDLE THE MEMBER NAME. THE MEMBER SCAN WILL BE STOPPED BY A\n*        SEPARATOR, A CLOSE PARENTHESIS, OR (FOR A QUOTED NAME) A\n*        CLOSING QUOTE\n*\nDSNMEM   TM    DSNFLAG,DSNERRF    HAS AN ERROR BEEN NOTED?\n         BNZ   DSNMSKIM           YES, GO TO ERROR MEMBER SCAN\n         BXH   R8,R6,DSNERR       NO, SKIP PAREN\n         LR    R15,R8             SAVE MEMBER START POINT\n         SPACE\nDSNMLOOP IC    R1,0(,R8)\n         LA    R3,SCANTAB(R1)\n         TM    0(R3),X'A0'        THIS CHAR ALPHA?\n         BNZ   DSNMALPH           YES.\n         LTR   R14,R14            NO, IS THIS THE FIRST CHAR OF MEMBER?\n         BZ    DSNMOUCH           YES, MEMBER ERROR\n         TM    0(R3),X'40'        IS THIS CHAR A DIGIT?\n         BNZ   DSNMNEXT           YES, CONTINUE\n         TM    0(R3),X'10'        IS IT A SEPARATOR\n         BNZ   DSNALL             YES, END OF MEMBER\n         CLI   0(R8),C')'         CLOSING PAREN?\n         BE    DSNMCLOS           YES, END OF MEMBER\n         TM    DSNFLAG,DSNQ       NO, WAS DSN QUOTED?\n         BZ    DSNMOUCH           NO, MUST BE ERROR\n         CLI   0(R8),C''''        YES, HAVE WE A QUOTE?\n         BE    DSNMQEND           YES, END OF DSN\n         B     DSNMOUCH           NO, ERROR\n         SPACE\nDSNMALPH TM    1(R9),X'40'        ASIS DSN?\n         BNZ   DSNMNEXT           YES.\n         OI    0(R8),X'40'        NO, UPPER CASE THE LETTER\nDSNMNEXT AR    R14,R6             INCREASE MEMBER LENGTH\n         BXLE  R8,R6,DSNMLOOP     AND CONTINUE\n         B     DSNALL\n         SPACE\nDSNMCLOS BXH   R8,R6,DSNALL       SKIP CLOSING PAREN\nDSNQCHEK CLI   0(R8),C''''        IS THERE A QUOTE AFTER?\n         BNE   DSNALL             NO.\nDSNQCHK2 TM    DSNFLAG,DSNQ       YES, WAS IT EXPECTED?\n         BZ    DSNALL             NO.\nDSNMQEND OI    DSNFLAG,DSNQEND    YES, SET CLOSING QUOTE FLAG\n         AR    R8,R6              SKIP THE QUOTE\n         B     DSNALL\n         SPACE\n*\n*        SKIM THROUGH THE REST OF AN ERRONEOUS MEMBER\n*\nDSNMOUCH OI    DSNFLAG,DSNERRF    SET ERROR FLAG\nDSNMSKIM BXH   R8,R6,DSNERR\n         IC    R1,0(,R8)\n         LA    R3,SCANTAB(R1)     EXAMINE NEXT CHAR\n         TM    0(R3),X'10'        SEPARATOR?\n         BNZ   DSNERR             YES, SCAN CAN STOP\n         CLI   0(R8),C')'         NO, CLOSE PAREN?\n         BE    DSNMCLOS           YES, MEMBER HAS ENDED\n         TM    DSNFLAG,DSNQ       NO, WAS NAME QUOTED?\n         BZ    DSNMSKIM           NO, CONTINUE SCAN\n         CLI   0(R8),C''''        YES, HAVE WE A QUOTE?\n         BNE   DSNMSKIM           NO, CONTINUE\n         AR    R8,R6              YES, SKIP IT\n         B     DSNERR             AND EXIT\n         SPACE\n*\n*        CHECK THE LENGTHS OF THE DSNAME AND MEMBER. IF THEY ARE\n*        OK, SET UP THE PDE\n*\nDSNALL   TM    DSNFLAG,DSNERRF    WAS AN ERROR FOUND?\n         BNZ   DSNERR             YES, EXIT\n         CH    R0,=H'44'          IS THE DSNAME TOO LONG?\n         BH    DSNERR             YES.\n         CH    R14,=H'8'          IS THE MEMBER TOO LONG?\n         BH    DSNERR             YES.\n         LR    R1,R14             MOVE MEMBER LENGTH\n         AIF   ('&OPSYS' NE 'MVS').NMVS6D\n         TM    1(R9),X'04'        PREFIX TO BE ADDED?\n         BZ    DSNNOPFX           NO.\n         TM    DSNFLAG,DSNQ       YES, IS DSN QUOTED?\n         BNZ   DSNNOPFX           YES, NO PREFIX TO ADD\n         CLI   0(R10),C'*'        DOES NAME START *?\n         BE    DSNNOPFX           YES, NO PREFIX\n         L     R3,IOPL            FIND UPT\n         USING UPT,R3\n         IC    R6,UPTPREFL        FIND PREFIX LENGTH\n         LTR   R6,R6              IS PREFIX NULL?\n         BZ    DSNNOPFX           YES, LENGTH IS OK\n         AR    R6,R0              ADD PREFIX LENGTH\n         CH    R6,=H'44'          IS EXPANDED NAME TOO LONG?\n         BNL   DSNERR             YES.\n         OI    DSNFLAG,DSNUSID    NO, SET PREFIX FLAG\nDSNNOPFX EQU   *\n.NMVS6D  ANOP\n         TM    DSNFLAG,DSNQ+DSNQEND    SEE IF PARTIALLY QUOTED\n         BNM   DSNCLOSD           NO.\n         BAL   R14,UNCL           YES, GIVE UNCLOSED MESSAGE\nDSNCLOSD EQU   *\n         AIF   ('&OPSYS' NE 'MVS').NMVS6E\n         TM    DSNFLAG,DSNUSID    DSN TO BE PREFIXED?\n         BNZ   DSNPFIX            YES.\n.NMVS6E  LTR   R0,R0              ANY DSN PRESENT?\n         BZ    DSNSTMEM           NO, JUST HANDLE MEMBER\n         ST    R10,0(,R2)         YES, STORE LOCATION\n         STH   R0,4(,R2)          AND LENGTH\n         OI    6(R2),X'80'        SET PRESENT FLAG\n         TM    DSNFLAG,DSNQ       WAS IT QUOTED\n         BZ    DSNSTMEM           NO.\n         OI    6(R2),X'40'        YES, SET QUOTED FLAG\nDSNSTMEM LTR   R1,R1              ANY MEMBER GIVEN?\n         BZ    DSNNOMEM           NO.\n         ST    R15,8(,R2)         YES, STORE LOCATION\n         STH   R1,12(,R2)         AND LENGTH\n         OI    14(R2),X'80'       SET MEMBER PRESENT\nDSNNOMEM SR    R15,R15            SET GOOD RETURN CODE\n         B     RETURN\n         SPACE\n         AIF   ('&OPSYS' NE 'MVS').NMVS6F\n*\n*        IF THE \"USID\" OPTION WAS SPECIFIED, APPEND THE USERID\n*\nDSNPFIX  STM   R14,R1,DSNPSAVE    SAVE SYSTEM REGS\n         LA    R1,1(,R6)          GET LENGTH OF NEW DSN\n         L     R15,=A(CLUZALOC)\n         BALR  R14,R15            GET MEMORY FOR IT\n         LM    R14,R1,DSNPSAVE    RESTORE REGS\n         L     R6,NEWMEM          POINT TO NEW MEMORY\n         IC    R1,UPTPREFL        GET PREFIX LENGTH\n         BCTR  R1,0\n         EX    R1,DSNMVPFX        MOVE PREFIX\n         ST    R6,0(,R2)          STORE DSN LOCATION\n         MVI   6(R2),X'80'        SET PRESENT FLAG\n         LTR   R0,R0              IS THERE A DSN PROPER?\n         BNZ   DSNPFIX2           YES.\n         LA    R1,1(,R1)          NO, GET ORIGINAL LENGTH BACK\n         STH   R1,4(,R2)          STORE IN PDE\n         B     DSNPMEM            GO HANDLE MEMBER\nDSNPFIX2 LA    R6,1(R1,R6)        POINT AFTER PREFIX\n         MVI   0(R6),C'.'         PERIOD AFTER PREFIX\n         LR    R1,R0\n         BCTR  R1,0\n         EX    R1,DSNMVNAM        MOVE REST OF DSNAME\n         LA    R6,2(R1,R6)        FIND END OF DSN\n         S     R6,NEWMEM          COMPUTE TOTAL LENGTH\n         STH   R6,4(,R2)          STORE IN PDE\nDSNPMEM  LM    R14,R1,DSNPSAVE    RESTORE REGS FOR MEMBER\n         B     DSNSTMEM           AND GO HANDLE IT\nDSNMVPFX MVC   0(0,R6),UPTPREFX   MOVE PREFIX TO DYNAMIC MEMORY\nDSNMVNAM MVC   1(0,R6),0(R10)     MOVE DSNAME TO DYNAMIC MEMORY\n         SPACE\n         DROP  R3\n.NMVS6F  SPACE\nDSNERR   LA    R15,8              SET ERROR RETURN CODE\n         B     RETURN\n         SPACE 3\nDSNWORK  DSECT ,                  DSN WORK AREA\n         SPACE\n         DS    22A                SAVE AREA\n         AIF   ('&OPSYS' NE 'MVS').NMVS6G\nDSNPSAVE DS    4A                 PREFIXING SAVE AREA\nDSNUSID  EQU   X'01'              USERID/PREFIX BIT\n.NMVS6G  ANOP\nDSNFLAG  DS    B                  FLAGS\nDSNQ     EQU   X'80'              DSNAME QUOTED\nDSNQEND  EQU   X'40'              ENDING QUOTE FOUND\nDSNERRF  EQU   X'20'              ERROR FOUND\n         DS    0D\nDSNWLEN  EQU   *-DSNWORK          LENGTH OF DSA\n         SPACE\nCLUTSREC CSECT\n         TITLE 'CLUZUSID -- USERID RECOGNIZER'\nCLUTSRC2 LISECT ,                 LESS FREQUENTLY USED RECOGNIZERS\n*\n*        THIS ROUTINE RECOGNIZES A USERID, AND INDICATES THAT A\n*        PASSWORD MAY FOLLOW\n*\nCLUZUSID LIENTRY DSA=*,DSALEN=88,ENV=R5,PARM=R2\n         SR    R1,R1\n         IC    R1,0(,R8)          CONSIDER FIRST CHAR\n         LA    R3,SCANTAB(R1)\n         TM    0(R3),X'A0'        IS IT ALPHANATIONAL?\n         BNZ   USIDHERE           YES.\n         LA    R15,4              NO, NO USERID PRESENT\n         B     RETURN\n         SPACE\nUSIDHERE OI    PASSF,PASSABLE     NOTE PASSWORD MAY FOLLOW\n         AIF   ('&OPSYS' NE 'MVS').NMVS3E\n         CLI   6(R9),12           IS THIS A UID2PSW?\n         BNE   USIDNORM           NO.\n         OI    PASSF,NWPASSOK     YES, INDICATE NEW PASSWORD OK\nUSIDNORM EQU   *\n.NMVS3E  LA    R14,8(,R2)         POINT TO PASSWORD PART OF PDE\n         ST    R14,PASSPDE        AND STORE FOR LATER\n         LR    R14,R8             SAVE STARTING POINT\n         AR    R8,R6              SKIP CHAR 1\nUSIDLOOP IC    R1,0(,R8)          CONSIDER NEXT CHAR?\n         LA    R3,SCANTAB(R1)\n         TM    0(R3),X'E0'        ALPHANUMERIC | NATIONAL?\n         BZ    USIDEND            NO, USERID ENDED.\n         BXLE  R8,R6,USIDLOOP     YES, CONTINUE\n         SPACE\n*\n*        IF THE USERID HAS MORE THAN 7 CHARACTERS, REJECT IT\n*\nUSIDEND  LR    R10,R8\n         SR    R10,R14            COMPUTE USERID LENGTH\n         CH    R10,=H'7'          TOO LARGE?\n         BNH   USIDOK             NO.\n         LA    R15,8              YES, BLOW IT OFF\n         B     RETURN\n         SPACE\nUSIDOK   ST    R14,0(,R2)         SET UP PDE\n         STH   R10,4(,R2)\n         MVI   6(R2),X'80'\n         TM    1(R9),X'40'        ASIS?\n         BNZ   USIDASIS           YES, NO TRANSLATE\n         L     R15,=V(CLUTSCAP)   FIND UPPERCASE TABLE\n         BCTR  R10,0\n         EX    R10,USIDCAPS       TRANSLATE THE USERID\nUSIDASIS SR    R15,R15            SAY ALL IS WELL\n         B     RETURN\nUSIDCAPS TR    0(0,R14),0(R15)    TO UPPERCASE USERID\n         TITLE 'CLUZVALU -- VALUE RECOGNIZER'\n*\n*        THIS ROUTINE RECOGNIZES AND RETURNS VALUES SUCH AS THOSE\n*        USED BY THE IBM TEST COMMAND\n*\nCLUZVALU LIENTRY DSA=*,DSALEN=88,ENV=R5,PARM=R2\n         SPACE\n*\n*        IF THE INPUT DOES NOT START WITH AN ALPHA-NATIONAL CHARACTER\n*        AND A QUOTE, IT IS NOT A VALUE\n*\n         SR    R1,R1\n         IC    R1,0(,R8)\n         LA    R3,SCANTAB(R1)\n         TM    0(R3),X'A0'        IS FIRST CHAR ALPHA-NATIONAL?\n         BZ    VALUNO             NO, NO VALUE\n         CR    R8,R7              YES, IS THERE ROOM FOR A QUOTE?\n         BNL   VALUNO             NO.\n         CLI   1(R8),C''''        YES, IS IT THERE?\n         BE    VALUHERE           YES.\nVALUNO   LA    R15,4              NO, VALUE IS MISSING\n         B     RETURN\n         SPACE\nVALUHERE MVC   7(1,R2),0(R8)      MOVE VALUE TYPE TO PDE\n         OI    7(R2),X'40'        UPPER CASE IT\n         LA    R8,2(,R8)          SKIP PAST QUOTE\n         ST    R8,0(,R2)          STORE STARTING POINT\n         MVI   6(R2),X'80'        SET PRESENT FLAG\n         LR    R3,R8              SAVE START POINT\n         L     R14,=V(CLUTSCAP)   POINT TO UPPER CASE TABLE\n         SPACE\n*\n*        SCAN FOR THE CLOSING QUOTE\n*\nVALUSCAN CLI   0(R8),C''''        QUOTE?\n         BE    VALUQUOT           YES, MAY BE THE END\n         TM    1(R9),X'40'        NO, ASIS?\n         BNZ   VALUASIS           YES.\n         TR    0(1,R8),0(R14)     NO, INTO UPPER CASE\nVALUASIS BXLE  R8,R6,VALUSCAN     AND CONTINUE\n         B     VALUUNCL           IF OUT OF TEXT, END OF VALUE\n         SPACE\nVALUQUOT CR    R8,R7              ROOM FOR ANY MORE?\n         BNL   VALUEND            NO.\n         CLI   1(R8),C''''        YES, CHECK FOR DOUBLED QUOTE\n         BNE   VALUEND            NOPE\n         AR    R8,R6              YES, SKIP FIRST QUOTE\n         B     VALUASIS           AND CONTINUE\n         SPACE\nVALUUNCL BAL   R14,UNCL           GIVE UNCLOSED MESSAGE\n         SPACE\nVALUEND  LR    R10,R8\n         SR    R10,R3             COMPUTE LENGTH OF VALUE\n         STH   R10,4(,R2)         STORE IN PDE\n         CR    R8,R7              ANY TEXT LEFT?\n         BH    VALUDONE           NO.\n         AR    R8,R6              SKIP CLOSING QUOTE\n         SPACE\nVALUDONE SR    R15,R15            SET GOOD RETURN CODE\n         B     RETURN\n         TITLE 'CLUZADDR -- TEST ADDRESS RECOGNIZER'\n*\n*        THIS ROUTINE RECOGNIZES ADDRESSES IN THE SYNTAX USED BY THE\n*        TEST COMMAND.\n*\nCLUZADDR LIENTRY DSALEN=@LEN,DSA=@DSA,ENV=R5,PARM=R2\n         SR    R1,R1\n         XC    @PDE(36),@PDE      CLEAR WORK PDE\n         MVC   @PDEXPR,NULL       STORE NULL EXPRESSION PTR\n         CLI   0(R8),C'.'         1ST CHAR A PERIOD?\n         BE    ADDRNTRY           YES, GO HANDLE ENTRY NAME\n         CLI   0(R8),C'+'         1ST CHAR A +?\n         BE    ADDRREL            YES, HANDLE RELATIVE ADDR\n         CLI   0(R8),C'-'         1ST CHAR A -?\n         BE    ADDRREL            YES, HANDLE EXTENDED RELATIVE\n         IC    R1,0(,R8)\n         LA    R3,SCANTAB(R1)\n         TM    0(R3),X'E0'        1ST CHAR ALPHANUMERIC | NATIONAL?\n         BNZ   ADDRSTRT           YES.\n         LA    R15,4              NO, NO ADDRESS PRESENT\n         B     RETURN\n         SPACE\n*\n*        ADDRESS MAY BE SYMBOLIC, ABSOLUTE, LOAD.ENTRY..., OR A\n*        REGISTER.\n*\nADDRSTRT MVC   @TYPE1,0(R3)       SAVE TYPE OF CHAR 1\n         MVC   @TYPES,0(R3)       START CUMULATIVE TYPE BYTE\n         ST    R8,@START          SAVE START POINT\nADDRLOOP TM    1(R9),X'40'        ASIS ADDRESS?\n         BNZ   ADDRAS1            YES.\n         OI    0(R8),X'40'        NO, UPPER CASE THIS CHAR\nADDRAS1  BXH   R8,R6,ADDREND      ON TO NEXT CHAR\n         IC    R1,0(,R8)\n         LA    R3,SCANTAB(R1)     EXAMINE IT\n         TM    0(R3),X'E4'        IS IT ALPHNUMERIC, NATIONAL OR _?\n         BZ    ADDROUT            NO.\n         OC    @TYPES,0(R3)       YES, OR INTO CUM. TYPE\n         B     ADDRLOOP           AND CONTINUE\n         SPACE\nADDROUT  TM    0(R3),X'11'        REACHED A STOPPER?\n         BNZ   ADDREND            YES.\n         TM    0(R3),X'02'        NO, REACHED %, + OR -?\n         BNZ   ADDRSYM            YES, ADDRESS MUST BE SYMBOLIC\n         CLI   0(R8),C'.'         REACHED A DOT?\n         BE    ADDRDOT            YES.\n         SPACE\n*\n*        THE ADDRESS IS BAD. REJECT UP TO THE NEXT SEPARATOR.\n*\nADDRBAD  CR    R8,R7              OUT OF TEXT?\n         BH    ADDREJCT           YES.\nADDRBLOP IC    R1,0(,R8)\n         LA    R3,SCANTAB(R1)\n         TM    0(R3),X'11'         LOOK FOR A STOPPER\n         BNZ   ADDREJCT            AND STOP WHEN FOUND\n         BXLE  R8,R6,ADDRBLOP\nADDREJCT LA    R15,8               INDICATE BAD ADDRESS\n         B     RETURN\n         SPACE\n*\n*        DECIDE WHETHER WE HAVE AN ABSOLUTE ADDRESS OR A LOAD MODULE\n*        NAME.\n*\nADDRDOT  TM    @PDEENTF,X'80'     HAS AN ENTRY ALREADY BEEN FOUND?\n         BNZ   ADDRBAD            YES, CAN'T BE ANOTHER\n         BXH   R8,R6,ADDRABS      NO, SKIP THE DOT\n         IC    R1,0(,R8)\n         LA    R3,SCANTAB(R1)\n         TM    0(R3),X'13'        IS NEXT CHAR A STOPPER OR % + -?\n         BNZ   ADDRABS            YES, ABSOLUTE ADDRESS\n         TM    0(R3),X'A0'        NO, IS IT ALPHANATIONAL?\n         BZ    ADDRBAD            NO, BAD ADDRESS\n         LR    R15,R8\n         S     R15,@START         COMPUTE LENGTH OF LOAD NAME\n         BCTR  R15,0\n         CH    R15,=H'8'          IS IT TOO LONG?\n         BH    ADDRBAD            YES.\n         TM    @TYPES,X'04'       UNDERSCORE IN LOAD NAME?\n         BNZ   ADDRBAD            YES, BAD LOAD NAME\n         TM    @TYPE1,X'40'       FIRST CHAR A DIGIT?\n         BNZ   ADDRBAD            YES, BAD LOAD NAME\n         MVC   @PDELOD,@START     STORE LOAD NAME START\n         STH   R15,@PDELODL       AND LENGTH\n         MVI   @PDELODF,X'80'     INDICATE PRESENT\n         B     ADDRENT            GO HANDLE ENTRY NAME\n         SPACE\n*\n*        HANDLE THE ENTRY NAME AFTER THE LOAD MODULE NAME.\n*\nADDRNTRY BXH   R8,R6,ADDRBAD      SKIP PRECEDING DOT\n         IC    R1,0(,R8)\n         LA    R3,SCANTAB(R1)\n         TM    0(R3),X'A0'        IS FIRST CHAR ALPHANATIONAL?\n         BZ    ADDRBAD            NO, BAD ENTRY\nADDRENT  ST    R8,@START          SAVE ENTRY START\nADDRENTR TM    1(R9),X'40'        ASIS ADDR?\n         BNZ   ADDRAS2            YES.\n         OI    0(R8),X'40'        NO, FOLD THIS CHAR\nADDRAS2  BXH   R8,R6,ADDREEND\n         IC    R1,0(,R8)\n         LA    R3,SCANTAB(R1)\n         TM    0(R3),X'E0'        ALPHANUMERIC | NATIONAL?\n         BNZ   ADDRENTR           YES.\n         TM    0(R3),X'11'        STOPPER?\n         BNZ   ADDREEND           YES.\n         CLI   0(R8),C'.'         DOT?\n         BNE   ADDRBAD            NO, EVIL ENTRY\n         SPACE\nADDREEND LR    R15,R8\n         S     R15,@START         COMPUTE ENTRY LENGTH\n         CH    R15,=H'8'          IS IT TOO LONG?\n         BH    ADDRBAD            YES.\n         MVC   @PDEENT,@START     SAVE ENTRY PART OF ADDRESS\n         STH   R15,@PDEENTL\n         MVI   @PDEENTF,X'80'\n         CR    R8,R7              ANYTHING LEFT?\n         BH    ADDRENDT           NO.\n         TM    0(R3),X'11'        STOPPER AFTER?\n         BNZ   ADDRENDT           YES.\n         BXH   R8,R6,ADDRBAD      SKIP FOLLOWING DOT\n         CLI   0(R8),C'+'         PLUS OR MINUS AFTER?\n         BE    ADDRREL            YES, GO HANDLE RELATIVE PART\n         CLI   0(R8),C'-'\n         BE    ADDRREL\n         IC    R1,0(,R8)\n         LA    R3,SCANTAB(R1)\n         TM    0(R3),X'A0'        IS CHAR AFTER ALPHANATIONAL?\n         BZ    ADDRBAD            NO, ERROR\n         B     ADDRSTRT           YES, DO SYMBOLIC SCAN AGAIN\n         SPACE\n*\n*        THE ADDRESS IS AN UNQUALIFIED ENTRY NAME.\n*\nADDRENDT MVI   @PDETYPE,X'04'     SET JUST-ENTRY FLAG\n         B     ADDRDONE           AND RETURN HAPPY\n         SPACE\n*\n*        VALIDATE AN ABSOLUTE ADDRESS.\n*\nADDRABS  TM    @TYPES,X'84'       ANY NON-HEX CHARS IN ADDRESS?\n         BNZ   ADDRBAD            YES, NO GOOD\n         LR    R15,R8\n         S     R15,@START         COMPUTE LENGTH OF ADDRESS\n         BCTR  R15,0\n         AIF   ('&OPSYS' NE 'MVS').NMVS9A\n         CH    R15,=H'8'          IS IT TOO LONG?\n         BH    ADDRBAD            YES.\n         CLI   6(R9),13           MAYBE, EXTENDED ADDRESS?\n         BE    ADDRAOK            YES, ITS OK\n.NMVS9A  CH    R15,=H'6'          ONLY 6 DIGITS ALLOWED\n         BH    ADDRBAD            ADDR TOO LONG\nADDRAOK  MVC   @PDEADR,@START     SET UP PDE FOR ABS ADDR\n         STH   R15,@PDEADRL\n         MVI   @PDEADRF,X'80'\n         B     ADDRAFT            GO ALLOW FOR INDIRECTION\n         SPACE\n*\n*        THE ADDRESS IS SYMBOLIC OR A REGISTER.\n*\nADDREND  TM    @PDEENTF,X'80'     HAS AN ENTRY BEEN FOUND?\n         BNZ   ADDRSYMB           YES, REGISTER IMPOSSIBLE\n         TM    @TYPE1,X'A0'       WAS 1ST CHAR ALPHA?\n         BNZ   ADDRSYMB           YES, REGISTER IMPOSSIBLE\n         LR    R15,R8\n         BCTR  R15,0\n         MVI   @PDETYPE,X'10'     ASSUME D TYPE REG\n         OI    0(R15),X'40'       FOLD REG TYPE\n         CLI   0(R15),C'D'        D TYPE?\n         BE    ADDRFREG           YES.\n         MVI   @PDETYPE,X'08'     ASSUME E TYPE\n         CLI   0(R15),C'E'        E TYPE?\n         BNE   ADDRGREG           NO.\nADDRFREG S     R15,@START\n         BCT   R15,ADDRBAD        MAKE SURE ONLY 1 DIGIT\n         L     R14,@START\n         TM    0(R14),X'09'       MAKE SURE EVEN REG<8\n         BNZ   ADDRBAD\n         MVC   @PDEADR,@START     SET UP REGISTER PDE\n         MVI   @PDEADRL+1,1\n         MVI   @PDEADRF,X'80'\n         B     ADDRDONE\n         SPACE\nADDRSYM  LR    R15,R8\n         TM    @PDEENTF,X'80'     ENTRY ALREADY FOUND?\n         BNZ   ADDRSYMB           YES, REGISTER IMPOSSIBLE\n         TM    @TYPE1,X'A0'       CHAR 1 ALPHA?\n         BNZ   ADDRSYMB           YES, REGISTER IMPOSSIBLE\n         CLI   0(R8),C'%'         IS REGISTER INDIRECTED?\n         BNE   ADDRBAD            NO, CAN'T DISPLACE FROM NAKED REG\n         BCTR  R15,0              BACK UP 1 CHAR\nADDRGREG OI    0(R15),X'40'       FOLD LAST CHAR\n         CLI   0(R15),C'R'        WAS IT R?\n         BNE   ADDRBAD            NO, NOT A REGISTER\n         S     R15,@START         YES.\n         CH    R15,=H'2'          LENGTH>2\n         BH    ADDRBAD            YES, NO GOOD\n         BL    ADDRGPR            LESS, GOOD REGISTER\n         L     R14,@START\n         CLI   0(R14),C'1'        IS FIRST DIGIT OF REG 1?\n         BNE   ADDRBAD            NO.\n         CLI   1(R14),C'0'        VALIDATE SECOND CHAR\n         BL    ADDRBAD\n         CLI   1(R14),C'6'\n         BNL   ADDRBAD\nADDRGPR  MVI   @PDETYPE,X'20'     SET GPR FLAG\n         MVC   @PDEADR,@START     SET UP PDE\n         STH   R15,@PDEADRL\n         MVI   @PDEADRF,X'80'\n         B     ADDRAFT            GO HANDLE INDIRECTION\n         SPACE\nADDRSYMB IC    R1,0(,R8)\n         LA    R3,SCANTAB(R1)\n         LR    R15,R8\n         S     R15,@START         COMPUTE LENGTH OF ADDRESS NAME\n         CH    R15,=H'31'         TOO LARGE?\n         BH    ADDRBAD            YES.\n         MVC   @PDEADR,@START     STORE IN PDE\n         STH   R15,@PDEADRL\n         MVI   @PDEADRF,X'80'\n         MVI   @PDETYPE,X'80'     SET TYPE TO SYMBOLIC\n         SPACE\n*\n*        HANDLE ANY TRAILING PERCENT SIGNS OR RELATIVE DISPLACEMENTS.\n*\nADDRAFT  LA    R10,@PDEADR\n         USING @XPR,R10\nADDRNEXP CR    R8,R7              ANY TEXT LEFT?\n         BH    ADDRDONE           NO.\n         TM    0(R3),X'11'        YES, REACHED A STOPPER?\n         BNZ   ADDRDONE           YES.\n         LR    R15,R8             SAVE CURRENT PLACE\n         SPACE\nADDRPCNT CLI   0(R8),C'%'         SKIP PERCENTS\n         BNE   ADDRIND\n         BXLE  R8,R6,ADDRPCNT\nADDRIND  SR    R15,R8             COMPUTE NUMBER OF %'S\n         LCR   R15,R15\n         CH    R15,=H'255'        TOO MANY?\n         BH    ADDRFLOP           YES (GASP).\n         STH   R15,@XPRPCNT       STORE IN PDE\n         SPACE\n         CR    R8,R7              ANY MORE TEXT?\n         BH    ADDRDONE           NO.\n         IC    R1,0(,R8)\n         LA    R3,SCANTAB(R1)\n         TM    0(R3),X'11'        REACHED A STOPPER?\n         BNZ   ADDRDONE           YES.\n         CLI   0(R8),C'+'         PLUS OR MINUS AFTER?\n         BE    ADDREXPR\n         CLI   0(R8),C'-'\n         BNE   ADDRFLOP           IF NOT, BAD ADDRESS\n         B     ADDREXPR\n         SPACE\n*\n*        ENTER HERE FOR AN INITIAL RELATIVE ADDRESS.\n*\nADDRREL  MVC   @PDESIGN,0(R8)     SAVE INITIAL SIGN\n         BXH   R8,R6,ADDRBAD      SKIP SIGN\n         LA    R10,@PDEADR        POINT R10->INITIAL PDE PART\n         B     ADDRRELX           JOIN OTHER CASE\n         SPACE\nADDREXPR MVC   @XPRSIGN,0(R8)     SAVE SIGN OF EXPRESSION\n         BXH   R8,R6,ADDRFLOP     SKIP PAST\n         LA    R1,@XPRSIZE        SIZE OF EXPRESSION PDE\n         L     R15,=A(CLUZALOC)\n         BALR  R14,R15            GET MEMORY FOR EXPRESSION PART\n         L     R14,NEWMEM\n         ST    R14,@XPRCHN        STORE IN CHAIN FIELD\n         XC    0(@XPRSIZE-4,R14),0(R14)     CLEAR EXPRESSION\n         LR    R10,R14            LET R10 ADDRESS EXPRESSION\n         MVC   @XPRCHN,NULL       CUT OFF CHAIN\n         SPACE\nADDRRELX ST    R8,@START          SAVE START POINT\n         MVI   @TYPES,0           REINIT TYPE ACCUMULATOR\nADDRXNXT IC    R1,0(R8)\n         LA    R3,SCANTAB(R1)\n         TM    0(R3),X'13'        IS NEXT CHAR A STOPPER, %, + OR -?\n         BNZ   ADDRXEND           YES, END OF EXPRESSION\n         TM    0(R3),X'60'        IS IT ALPHAMERIC?\n         BZ    ADDRFLOP           NO, BAD NEWS\n         TM    0(R3),X'80'        YES, IS IT A HEX DIGIT?\n         BNZ   ADDRXOUT           NO.\n         OC    @TYPES,0(R3)       YES, ACCUMULATE TYPE BITS\n         TM    1(R9),X'40'        ASIS ADDRESS?\n         BNZ   ADDRXAS            YES.\n         OI    0(R8),X'40'        NO, UPPERCASE DIGIT\nADDRXAS  BXLE  R8,R6,ADDRXNXT     AND CONTINUE\n         SPACE\n*\n*        SEEMINGLY, WE HAVE FINISHED A RELATIVE DISPLACEMENT.\n*\nADDRXEND LR    R15,R8\n         S     R15,@START         COMPUTE DISPLACEMENT LENGTH\n         BZ    ADDRFLOP           0 IS EVIL\n         AIF   ('&OPSYS' NE 'MVS').NMVS9B\n         CH    R15,=H'8'          >8 IS VERY EVIL\n         BH    ADDRFLOP\n         CLI   6(R9),13           EXTENDED ADDRESS?\n         BE    ADDRXTND           YES, LENGTH OK\n.NMVS9B  CH    R15,=H'6'          >6 IS ALSO EVIL\n         BH    ADDRFLOP\nADDRXTND TM    @PDEADRF,X'80'     HAS ADDRESS BEEN HANDLED?\n         BZ    ADDRRHEX           NO, RELATIVE ADDRESS\nADDRXHEX MVI   @XPRTYPE,X'02'     SET EXPRESSION TYPE\nADDRXSTO MVC   @XPRADDR,@START    STORE EXPRESSION START ADDR\n         STH   R15,@XPRLEN        AND LENGTH\n         B     ADDRNEXP\n         SPACE\nADDRRHEX CLI   @PDESIGN,C'-'      NEGATIVE DISPLACEMENT\n         BE    ADDRXADD           YES, GO SNEAK IN A +0\n         MVI   @PDETYPE,X'40'     NO, INDICATE RELATIVE ADDRESS\n         MVC   @PDEADR,@START     SET UP PDE\n         STH   R15,@PDEADRL\n         MVI   @PDEADRF,X'80'\n         B     ADDRNEXP\n         SPACE\nADDRXOUT C     R8,@START          DID WE GET ANY TEXT?\n         BE    ADDRFLOP           NO.\n         OI    0(R8),X'40'        YES, FOLD THIS CHAR\n         CLI   0(R8),C'N'         WAS IT AN N?\n         BNE   ADDRFLOP           NO, NO GOOD\n         TM    @TYPES,X'20'       YES, ANY LETTERS IN EXPRESSION?\n         BNZ   ADDRFLOP           YES, NO GOOD\n         OI    @TYPES,X'80'       NO, SET FLAG FOR LATER\n         BXH   R8,R6,ADDRXDEC     SKIP N\n         IC    R1,0(,R8)\n         LA    R3,SCANTAB(R1)\n         TM    0(R3),X'13'        DOES A STOPPER FOLLOW?\n         BZ    ADDRFLOP           NO, ERROR\nADDRXDEC LR    R15,R8\n         S     R15,@START         COMPUTE LENGTH\n         BCTR  R15,0\n         TM    @PDEADRF,X'80'     ADDRESS ALREADY HANDLED?\n         BNZ   ADDRDEC            YES.\n         SPACE\n*\n*        ADD A +0 IN FRONT OF THE EXPRESSION FOR THE EXTENSIONS TO THE\n*        IBM SYNTAX.\n*\nADDRXADD LR    R0,R15             SAVE LENGTH\n         LA    R1,4+@XPRSIZE      MEMORY NEEDED FOR FAKE-OUT\n         L     R15,=A(CLUZALOC)\n         BALR  R14,R15            GET MEMORY\n         L     R10,NEWMEM\n         LA    R15,@XPRSIZE(,R10) FAKE INPUT\n         MVC   0(2,R15),=C'+0'    OF +0\n         LA    R15,1(,R15)\n         ST    R15,@PDEADR\n         MVI   @PDEADRL+1,1\n         MVI   @PDEADRF,X'80'\n         MVI   @PDETYPE,X'40'\n         CLI   @PDESIGN,C'-'\n         BE    ADDRXCHN\n         MVI   @PDESIGN,C'+'      SIGN IS + IF NOT ALREADY -\nADDRXCHN LR    R15,R0             RESTORE R15\n         ST    R10,@PDEXPR        CHAIN NEW MEMORY TO OLD\n         XC    0(@XPRSIZE-4,R10),0(R10)     CLEAR IT\n         MVC   @XPRCHN,NULL       STOP THE CHAIN\n         TM    @TYPES,X'80'       DECIMAL EXPRESSION?\n         BZ    ADDRXHEX           NO, HEX\nADDRDEC  EQU   *\n         AIF   ('&OPSYS' NE 'MVS').NMVS9C\n         CH    R15,=H'10'         TOO MANY DIGITS?\n         BH    ADDRFLOP           MUCH TOO MUCH\n         CLI   6(R9),13           MAYBE, EXTENDED ADDRESS FORMAT?\n         BE    ADDRDOK            YES, ITS GOOD\n.NMVS9C  CH    R15,=H'6'          TOO MANY DIGITS?\n         BH    ADDRFLOP           YES.\nADDRDOK  MVI   @XPRTYPE,X'04'     SET TYPE TO DECIMAL\n         B     ADDRXSTO           GO STORE INTO PDE\n         SPACE\n*\n*        WHEW. RETURN THE PDE.\n*\nADDRDONE MVC   0(36,R2),@PDE      MOVE TO REAL PDE\n         SR    R15,R15            SET GOOD RETURN CODE\n         B     RETURN\n         SPACE\n*\n*        AN ERROR WAS DISCOVERED IN AN EXPRESSION. CALL THE ROLLBACK\n*        ROUTINE TO FREE ANY EXPRESSION PDE'S BEFORE RETURNING.\n*\nADDRFLOP BAL   R14,RLBK           CALL MEMORY ROLLBACK ROUTINE\n         B     ADDRBAD            AND THEN QUIT\n         SPACE\n         DROP  R10\n         SPACE\n@DSA     DSECT ,                  ADDRESS WORK AREA\n         SPACE\n         DS    22A                SAVE AREA\n@START   DS    A                  STARTING ADDRESS\n@PDE     EQU   *                  PDE MAPPING\n@PDELOD  DS    A\n@PDELODL DS    H\n@PDELODF DS    X\n@PDEENT  DS    A\n@PDEENTL DS    H\n@PDEENTF DS    X\n@PDEADR  DS    A\n@PDEADRL DS    H\n@PDEADRF DS    X\n         DS    X\n@PDETYPE DS    X\n@PDESIGN DS    CL1\n@PDEPCNT DS    H\n@PDEXPR  DS    A\n         DS    A\n@TYPE1   DS    X                  TYPE OF FIRST CHAR\n@TYPES   DS    X                  CUMULATIVE TYPE BITS\n         DS    0D\n         SPACE\n@LEN     EQU   *-@DSA             LENGTH OF WORK AREA\n         SPACE\n@XPR     DSECT ,                  EXPRESSION PDE MAPPING\n         SPACE\n@XPRADDR DS    A\n@XPRLEN  DS    H\n         DS    H\n@XPRTYPE DS    X\n@XPRSIGN DS    CL1\n@XPRPCNT DS    H\n@XPRCHN  DS    A\n         SPACE\n@XPRSIZE EQU   *-@XPR\n         SPACE\nCLUTSRC2 CSECT ,                  RESTORE CSECT\n         AIF   ('&OPSYS' NE 'MVS').NMVS7\n         TITLE 'CLUZJOBN -- JOBNAME RECOGNIZER'\n*\n*        THIS ROUTINE RECOGNIZES THE JOBNAME(JOBID) SYNTAX\n*\nCLUZJOBN LIENTRY DSA=*,DSALEN=88,ENV=R5\n         LR    R14,R8             SAVE STARTING POINT\n         SR    R1,R1\n         IC    R1,0(,R8)\n         LA    R3,SCANTAB(R1)     EXAMINE FIRST CHAR\n         TM    0(R3),X'A0'        IS IT ALPHA?\n         BNZ   JOBHERE            YES.\n         LA    R15,4              NO, JOBNAME IS MISSING\n         B     RETURN\n         SPACE\nJOBLOOP  BXH   R8,R6,JOBGOOD      ON TO NEXT CHAR\n         IC    R1,0(,R8)\n         LA    R3,SCANTAB(R1)\n         TM    0(R3),X'E0'        IS IT ALPHANUMERIC | NATIONAL?\n         BZ    JOBEND             NO, END OF JOBNAME\nJOBHERE  TM    1(R9),X'40'        ASIS?\n         BNZ   JOBLOOP            YES, PROCEED\n         OI    0(R8),X'40'        NO, TRANSLATE THIS CHAR\n         B     JOBLOOP            AND CONTINUE\n         SPACE\nJOBEND   TM    0(R3),X'18'        SEPARATOR?\n         BNZ   JOBGOOD            YES, GO STORE IN PDE\n         SPACE\nJOBBAD   BXH   R8,R6,JOBOUCH\n         IC    R1,0(,R8)\n         LA    R3,SCANTAB(R1)\n         CLI   0(R8),C'('         LOOK FOR JOBID START\n         BE    JOBSKPID\n         TM    0(R3),X'18'        HAVE WE A STOP CHAR?\n         BZ    JOBBAD             NO, CONTINUE SEARCH\nJOBOUCH  LA    R15,8              SET BAD RETURN CODE\n         B     RETURN\n         SPACE\nJOBGOOD  LR    R15,R8\n         SR    R15,R14            COMPUTE JOBNAME LENGTH\n         CH    R15,=H'8'          IS IT TOO LONG?\n         BH    JOBBADI            YES.\n         ST    R14,0(,R2)         NO, SET UP PDE\n         STH   R15,4(,R2)\n         CR    R8,R7              ARE WE OUT OF INPUT?\n         BH    JOBRET             YES, RETURN\n         CLI   0(R8),C'('         NO, IS THERE A FOLLOWING JOBID?\n         BE    JOBIDHR            YES, HANDLE IT\nJOBRET   MVI   6(R2),X'80'\n         SR    R15,R15\n         B     RETURN             AND RETURN\n         SPACE\n*\n*        HANDLE THE JOBID PORTION\n*\nJOBIDHR  BXH   R8,R6,JOBOUCH      ERROR IF NOTHING AFTER PAREN\n         LR    R14,R8             SAVE ID START POINT\nJOBILOOP IC    R1,0(,R8)\n         LA    R3,SCANTAB(R1)\n         TM    0(R3),X'E0'        IS NEXT CHAR ALPHANUMERIC | NATIONAL?\n         BZ    JOBIEND            NO, END OF JOB ID\n         TM    1(R9),X'40'        YES, ASIS?\n         BNZ   JOBIASIS           YES.\n         OI    0(R8),X'40'        NO, TRANSLATE IT\nJOBIASIS BXLE  R8,R6,JOBILOOP     AND CONTINUE\n         LR    R15,R8\n         B     JOBIOVER\n         SPACE\nJOBIEND  LR    R15,R8             SAVE ENDING POINT\n         TM    0(R3),X'18'        FOUND A SEPARATOR?\n         BZ    JOBSKPID           NO, JOBID IS EVIL\n         CLI   0(R8),C')'         FOUND A CLOSE PAREN?\n         BNE   JOBIOVER           NO.\n         AR    R8,R6              YES, SKIP IT\nJOBIOVER SR    R15,R14            COMPUTE LENGTH OF JOBID\n         BZ    JOBOUCH            ERROR IF 0\n         CH    R15,=H'8'          ERROR IF > 8\n         BH    JOBOUCH\n         CLI   0(R14),C'0'        IS FIRST CHAR A DIGIT?\n         BNL   JOBNUM             YES, CHANGE JOB NUMBER TO JOB ID\n         ST    R14,8(,R2)         STORE LOCATION & LENGTH OF ID\n         STH   R15,12(,R2)\n         MVI   14(R2),X'80'       NOTE ID PRESENT\n         B     JOBRET             RETURN NORMALLY\n         SPACE\nJOBBADI  CR    R8,R7              ANYTHING MORE LEFT?\n         BH    JOBOUCH            NO, JUST GIVE UP\n         CLI   0(R8),C'('         IS THERE AN ID AFTER BAD JOBNAME?\n         BNE   JOBOUCH            NO, TAKE FAST EXIT\nJOBSKPID BXH   R8,R6,JOBOUCH      LOOK FOR END OF JOBID\nJOBIBAD  IC    R1,0(,R8)\n         LA    R3,SCANTAB(R1)\n         CLI   0(R8),C')'         STOP AT CLOSE PAREN\n         BE    JOBBOVER\n         TM    0(R3),X'18'        STOP AT NON-DELIMITER\n         BZ    JOBSKPID\n         B     JOBOUCH            ELSE KEEP GOING\nJOBBOVER AR    R8,R6              SKIP THE CLOSE PAREN\n         B     JOBOUCH            AND GIVE UP\n         SPACE\n*\n*        IF THE JOB ID BEGINS WITH A NUMERIC CHARACTER, AS AN\n*        EXTENSION WE PREFIX IT WITH THE WORD \"JOB\" AND RETURN\n*        THAT\n*\nJOBNUM   CH    R15,=H'5'          TOO LONG TO ADD \"JOB\"?\n         BH    JOBOUCH            YES, ERROR\n         LR    R3,R14             SAVE JOBID LOCATION\n         LR    R10,R15            AND LENGTH\n         LA    R1,8               GET 8 BYTES FOR CONSTRUCTED JOBID\n         L     R15,=A(CLUZALOC)\n         BALR  R14,R15\n         L     R1,NEWMEM          FIND WHERE WE GOT IT\n         MVC   0(3,R1),=C'JOB'    PUT IN CONSTANT PART\n         BCTR  R10,0\n         EX    R10,JOBMVNUM       MOVE JOB NUMBER AFTER\n         ST    R1,8(,R2)          STORE JOB ID LOCATION\n         LA    R10,4(,R10)        COMPUTE FULL JOB ID LENGTH\n         STH   R10,12(,R2)        STORE\n         MVI   14(R2),X'80'       SHOW JOB ID PRESENT\n         B     JOBRET             AND RETURN\n         SPACE\nJOBMVNUM MVC   3(0,R1),0(R3)      COPY JOB NUMBER TO JOB ID\n.NMVS7   TITLE 'CLUZEXTN -- USER RECOGNIZER INTERFACE'\n*\n*        THIS ROUTINE PROVIDES AN INTERFACE TO A USER-WRITTEN\n*        RECOGNIZER. THE RECOGNIZER IS PASSED THE CURRENT SOURCE\n*        PARAMETER PROVIDED IN THE PCE. IT IS ALSO PASSED THE ADDRESS\n*        OF THE UPPER-CASE TABLE FOR A NON-ASIS PARM, AND THE ADDRESS\n*        OF A ROUTINE TO GET DYNAMIC STORAGE.\n*\nCLUZEXTN LIENTRY DSA=XTNDSA,DSALEN=XTNLEN,ENV=R5,PARM=R2\n         ST    R2,VPDE            STORE PDE POINTER\n         MVC   VMSG,NULL          INITIALIZE 2ND LEVEL MSG\n         L     R14,=V(CLUTSCAP)   FIND UPPER CASE TABLE\n         TM    1(R9),X'40'        IS IT ASIS?\n         BZ    EXTNFOLD           NO.\n         SR    R14,R14            YES, PASS 0 INSTEAD\nEXTNFOLD ST    R14,CAPTAB\n         BAL   R14,FDEF           FIND DEFAULT OR PROMPT\n         BAL   R14,FHLP           FIND ANY HELP\n         TM    0(R9),X'02'        IS THERE ANY?\n         BZ    EXTNNHLP           NO.\n         MVC   ALIGN,0(R1)        YES, SKIP IT\n         AH    R1,ALIGN\nEXTNNHLP ST    R1,RPARM           STORE PCE PARM ADDRESS\n         SPACE\n*\n*        TURN THE CURRENT INPUT INTO A PSEUDO-COMMAND-BUFFER FOR\n*        PROCESSING BY THE USER RECOGNIZER.\n*\n         CLC   CBUF,CURINP        IN ORIGINAL INPUT?\n         BE    EXTNCBUF           YES.\n         L     R1,CURINP          NO, FIND CURRENT INPUT\n         LA    R15,INPLEN-5(,R1)  POINT TO START OF PSEUDO-CBUF\n         LR    R14,R7\n         SR    R14,R15            COMPUTE CBUF LENGTH\n         STH   R14,1(,R15)        STORE IT\n         B     EXTNOFF            GO TO COMPUTE OFFSET\nEXTNCBUF L     R15,CBUF           FIND ORIGINAL COMMAND BUFFER\nEXTNOFF  LR    R14,R8\n         SR    R14,R15            DETERMINE OFFSET\n         S     R14,=A(4)          COMPENSATE FOR HEADER\n         STH   R14,2(,R15)\n         ST    R15,TEXTSEG        STORE PSEUDO-CBUF OFFSET\n         SPACE\n*\n*        BEFORE CALLING THE RECOGNIZER, POINT R13 TO ANOTHER SAVE AREA.\n*        THIS ALLOWS USE OF OUR ORIGINAL DSA IF RE-ENTERED FOR A\n*        STORAGE MANAGEMENT REQUEST.\n*\n         LA    R1,XTNGET          SET UP GET ROUTINE ADDRESS\n         ST    R1,GETRTN\n         MVC   XTNGET(EXTNGLEN),EXTNCODE    COPY GET HEADER CODE\n         LA    R1,VPDE            POINT TO RECOGNIZER PARM LIST\n         ST    R13,XTNCSAVE+4     SET LINKAGE BACK TO OWN DSA\n         STM   R14,R12,XTNCSAVE+12     SAVE REGS IN CASE USER FORGETS\n         LA    R13,XTNCSAVE\n         MVC   VRTN+1(3),6(R9)    MOVE ENTRY POINT\n         L     R15,VRTN\n         BALR  R14,R15            CALL USER RECOGNIZER\n         L     R13,4(,R13)        RESTORE ORIGINAL DSA\n         SPACE\n*\n*        INTERPRET THE RETURN CODE. IF THE ITEM IS NOT MISSING,\n*        COMPUTE THE NEW CURRENT SCAN POINTER BEFORE RETURNING.\n*\n         LTR   R15,R15\n         BNM   EXTNROK            MAKE SURE RETURN CODE DECENT\nEXTNOUCH BAL   R6,PARSRC12\nEXTNROK  CH    R15,=H'8'          MAXIMUM ALLOWED\n         BH    EXTNOUCH\n         BE    EXTNRLBK           ROLLBACK IF ITEM IS INVALID\n         XC    VMSG,VMSG          WIPE OUT LEVEL 2 TEXT OTHERWISE\n         LTR   R15,R15            GOOD INPUT?\n         BZ    EXTNRPOS           YES, REPOSITION\nEXTNRLBK BAL   R14,RLBK           FREE ANY MEMORY GOTTEN BY RECOGNIZER\n         CH    R15,=H'4'          WAS ITEM MISSING?\n         BE    RETURN             YES, NO REPOSITION REQUIRED\n         SPACE\nEXTNRPOS L     R14,TEXTSEG        FIND PSEUDO-BUFFER\n         LA    R8,4(,R14)\n         AH    R8,2(,R14)         COMPUTE NEW POSITION\n         B     RETURN             AND RETURN R15\n         SPACE\n*\n*        THIS CODE IS MOVED TO THE DSA BEFORE THE USER RECOGNIZER IS\n*        CALLED. IT SWITCHES SAVE AREAS (TO RESTORE THIS ROUTINE'S\n*        ORIGINAL DSA), AND THEN BRANCHES BACK TO MAINLINE CODE.\n*\nEXTNCODE EQU   *                  START OF MOVED CODE\n         USING XTNGET,R15         R15->MOVED COP OF CODE\n         STM   R0,R15,XTNLSAVE    SAVE CALLER'S REGS\n         L     R13,XTNCSAVE+4     FIND ORIGINAL DSA\n         LM    R14,R12,XTNCSAVE+12     LOAD ORIGINAL REGS\n         DROP  R15                FORGET TEMPORARY BASE\n         B     EXTNGET            RETURN TO REAL WORLD\nEXTNGLEN EQU   *-EXTNCODE         LENGTH OF MOVED GET CODE\n         SPACE\n*\n*        THIS CODE ACTUALLY CALLS THE GET ROUTINE FOR A USER\n*        RECOGNIZER REQUEST.\n*\nEXTNGET  L     R1,XTNLSAVE+4      FIND OUR PARM\n         LA    R1,7(,R1)          ROUND AMOUNT UP TO DOUBLE WORD\n         N     R1,=F'-8'\n         L     R15,=A(CLUZALOC)\n         BALR  R14,R15            GO GET MEMORY\n         MVC   XTNLSAVE+4(4),NEWMEM    RETURN ADDRESS IN R1\n         LM    R0,R15,XTNLSAVE    RESTORE CALLER'S REGS\n         BR    R14                AND GO BACK TO HIM\n         SPACE 3\nXTNDSA   DSECT ,                  WORK AREA FOR EXTENSION INTERFACE\n         SPACE\n         DS    22A                NORMAL DSA\nXTNGET   DS    CL(EXTNGLEN)       GET ROUTINE HEADER CODE\nXTNCSAVE DS    18A                SAVE AREA FOR RECOGNIZER USE\nXTNLSAVE DS    16A                SAVE AREA FOR GET ROUTINE\n         DS    0D\nXTNLEN   EQU   *-XTNDSA           LENGTH OF DSA\n         TITLE 'CLUZWORD -- RESERVED WORD HANDLER'\nCLUTSCOB LISECT ,                 COBOL RECOGNIZERS\n*\n*        THIS ROUTINE HANDLES RECOGNITION OF RESERVED WORDS\n*\nCLUZWORD LIENTRY DSA=WDSA,DSALEN=WDSALEN,ENV=R5,PARM=R2\n         SR    R1,R1\n         LR    R15,R8             SAVE STARTING POINT\n         SPACE\n*\n*        SCAN TO THE NEXT SEPARATOR\n*\nWORDLOOP IC    R1,0(,R8)\n         LA    R3,COBTAB(R1)      CONSIDER NEXT CHAR\n         TM    0(R3),X'11'        IS IT A SEPARATOR?\n         BNZ   WORDEND            YES, THE END\n         BXLE  R8,R6,WORDLOOP     NO, CONTINUE\n         SPACE\n*\n*        COPY THE WORD TO DYNAMIC MEMORY AND TRANSLATE IT TO UPPER\n*        CASE\n*\nWORDEND  LR    R10,R8\n         SR    R10,R15            GET LENGTH OF WORD\n         BZ    WORDMISS           MISSING IF STARTS WITH SEPARATOR\n         CH    R10,=H'255'        TOO LONG?\n         BH    WORDERR            YES.\n         BCTR  R10,0\n         L     R14,=V(CLUTSCAP)   UPPER CASE TABLE\n         EX    R10,WORDMOVE       MOVE WORD TO WORK AREA\n         EX    R10,WORDFOLD       UPPER CASE IT\n         SR    R14,R14\n         LR    R0,R9              SAVE R9 ELSEWHERE\n         SPACE\nWORDNEXT MVC   ALIGN,2(R9)\n         AH    R9,ALIGN           FIND NEXT IKJNAME PCE\n         AR    R14,R6\n         IC    R1,0(,R9)\n         SRL   R1,5\n         CH    R1,=H'3'           IS IT AN IKJNAME?\n         BNE   WORDMISS           NO, WORD NOT FOUND\n         EX    R10,WORDCLEN       YES, COMPARE LENGTH-1'S\n         BNE   WORDNEXT           NOPE, TRY THE NEXT\n         EX    R10,WORDCOMP       OK, COMPARE THE WORDS\n         BNE   WORDNEXT           NOPE\n         SPACE\nWORDOK   STH   R14,2(,R2)         SAVE WORD NUMBER\n         MVI   6(R2),X'80'        SET PRESENT FLAG\n         EX    R10,WORDREST       PUT THE FOLDED WORD BACK\n         SR    R15,R15\n         B     RETURN\n         SPACE\nWORDERR  LA    R15,8              AND REJECT\n         B     RETURN\n         SPACE\nWORDMISS LR    R8,R15             RESTORE ORIGINAL CHAR POINTER\n         LA    R15,4\n         B     RETURN\n         SPACE\nWORDMOVE MVC   WORDSAVE(0),0(R15) SAVE PUTATIVE WORD\nWORDFOLD TR    WORDSAVE(0),0(R14) FOLD PUTATIVE WORD\nWORDREST MVC   0(0,R15),WORDSAVE  PUT WORD BACK (FOLDED)\nWORDCLEN CLI   4(R9),0            COMPARE LENGTH-1'S\nWORDCOMP CLC   5(0,R9),WORDSAVE   COMPARE WORD & NAME\n         SPACE\nWDSA     DSECT ,                  IKJRSVWD WORK AREA\n         SPACE\n         DS    22F                DSA\nWORDSAVE DS    CL255              FOLDING AREA\n         DS    0D\nWDSALEN  EQU   *-WDSA             LENGTH OF WORK AREA\n         SPACE\nCLUTSCOB CSECT ,                  RESUME CSECT\n         TITLE 'CLUZSTMT -- COBOL STATEMENT NUMBER RECOGNIZER'\n*\n*        THIS ROUTINE RECOGNIZES COBOL STATEMENT NUMBERS.\n*\nCLUZSTMT LIENTRY ENV=R5,PARM=R2,DSA=*,DSALEN=88\n         SR    R1,R1\n         LR    R15,R8             SAVE THE STARTING POINT\n         SR    R14,R14            INDICATE NO ERROR FOUND YET\n         IC    R1,0(,R8)\n         LA    R3,COBTAB(R1)      INSPECT 1ST CHAR\n         TM    0(R3),X'40'        IS IT A DIGIT?\n         BNZ   STMTNXLN           YES.\n         TM    0(R3),X'20'        IS IT A LETTER?\n         BNZ   STMTPGM            YES.\n         LA    R15,4              NO, STATEMENT NUMBER NOT THERE\n         B     RETURN\n         SPACE\nSTMTPGM  L     R10,=V(CLUTSCAP)   TO FOLD THE PROGRAM NAME\nSTMTPLOP TM    1(R9),X'40'        ARE WE ASIS?\n         BNZ   STMTPGAS           YES.\n         TR    0(1,R8),0(R10)     NO, FOLD THE CHARACTER\nSTMTPGAS BXH   R8,R6,STMTERR      CONTINUE ON\n         IC    R1,0(,R8)\n         LA    R3,COBTAB(R1)\n         TM    0(R3),X'08'        FOUND A .?\n         BNZ   STMTPDON           YES, PROGRAM NAME ENDED\n         TM    0(R3),X'60'        FOUND A LETTER OR DIGIT?\n         BNZ   STMTPLOP           YES, MORE PGM NAME\n         TM    0(R3),X'11'        NO, FOUND A TERMINATOR?\n         BNZ   STMTERR            YES, NOT GOOD\n         LA    R14,1              SET ERROR FLAG\n         B     STMTPGM            & CONTINUE PERIOD SEARCH\n         SPACE\nSTMTERR  LA    R15,8              INDICATE ERROR\n         B     RETURN             AND RETURN\n         SPACE\nSTMTPDON BXH   R8,R6,STMTERR      IS THERE ANYTHING AFTER?\n         LR    R0,R8\n         SR    R0,R15\n         BCTR  R0,0               COMPUTE LENGTH OF PROGRAM ID\n         CH    R0,=H'8'           IS IT TOO BIG?\n         BNH   STMTPLEN           NO.\n         LA    R14,1              YES, INDICATE ERROR\n         B     STMTAPGM\nSTMTPLEN STC   R0,0(,R2)          STORE PROGRAM LEN IN PDE\n         ST    R15,8(,R2)         STORE THE STARTING POINT\n         SPACE\nSTMTAPGM LR    R15,R8             SAVE START OF LINE NUMBER\nSTMTLINE IC    R1,0(,R8)\n         LA    R3,COBTAB(R1)\n         TM    0(R3),X'08'        HAVE WE A DOT?\n         BNZ   STMTLDON           YES, FINISH WITH LINE NO\n         TM    0(R3),X'11'        FOUND A TERMINATOR?\n         BNZ   STMTLDON           YES.\n         TM    0(R3),X'40'        NO, GOT A DIGIT?\n         BNZ   STMTNXLN           YES.\n         TM    0(R3),X'20'        NO, A LETTER?\n         BZ    STMTLDON           NO, END OF STMT NUMBER\n         LA    R14,1              YES, SET ERROR FLAG\nSTMTNXLN BXLE  R8,R6,STMTLINE\n         B     STMTLDON           IF ALL THE TEXT RUNS OUT\n         SPACE\nSTMTLDON LTR   R14,R14            ANY TROUBLE SO FAR?\n         BNZ   STMTLAFT           YES, DON'T STORE ANYTHING\n         LR    R0,R8\n         SR    R0,R15             COMPUTE LINE NUMBER LENGTH\n         CH    R0,=H'6'           IS IT TOO LONG?\n         BNH   STMTLNOK           NO.\n         LA    R14,1              YES, INDICATE ERROR\n         B     STMTLAFT\nSTMTLNOK STC   R0,1(,R2)          STORE LENGTH\n         ST    R15,12(,R2)        AND LOCATION\n         SPACE\nSTMTLAFT CR    R8,R7              IS ANYTHING LEFT?\n         BH    STMTRET            NO, WE'RE DONE\n         CLI   0(R8),C'.'         ARE WE LOOKING AT A PERIOD?\n         BNE   STMTRET            NO, THE NUMBER IS ENDED\n         BXH   R8,R6,STMTERR      YES, SKIP PAST IT\n         LR    R15,R8             SAVE THE START\n         IC    R1,0(,R8)\n         LA    R3,COBTAB(R1)\n         TM    0(R3),X'40'        IS IT A DIGIT?\n         BZ    STMTVERR           NO, BAD VERB NUMBER\n         BXH   R8,R6,STMTVOK      OK IF NOTHING AFTER\n         IC    R1,0(,R8)          YES, WHAT FOLLOWS\n         LA    R3,COBTAB(R1)\n         TM    0(R3),X'68'        LETTER DIGIT OR DOT AFTER?\n         BNZ   STMTVERR           YES, BAD VERB NO\nSTMTVOK  MVI   2(R2),1            STORE LENGTH OF 1 FOR VERB\n         ST    R15,16(R2)         STORE WHEREABOUTS OF VERB\n         B     STMTRET\n         SPACE\nSTMTVERR BXH   R8,R6,STMTERR      SCAN LIKELY REST OF TEXT\n         IC    R1,0(,R8)\n         LA    R3,COBTAB(R1)\n         TM    0(R3),X'68'        LOOK FOR NON-ALPHAMERIC OR .\n         BNZ   STMTVERR\n         B     STMTERR\n         SPACE\nSTMTRET  LTR   R14,R14            ANY TROUBLE?\n         BNZ   STMTERR            YES, GIVE RET CODE 8\n         OI    6(R2),X'90'        NO, SET PRESENT & STMT FLAGS\n         SR    R15,R15\n         B     RETURN             AND GO BACK\n         TITLE 'CLUZCNST -- COBOL CONSTANT RECOGNIZER'\n*\n*        THIS ROUTINE RECOGNIZES COBOL CONSTANTS. IT USES THE RESERVED\n*        WORD RECOGNIZER IF FIGURATIVE CONSTANTS ARE ALLOWED. THIS\n*        ROUTINE IS ALSO ENTERED BY THE QUALIFIER RECOGNIZER FOR\n*        A TERM WHICH MAY BE EITHER A CONSTANT OR A VARIABLE.\n*\nCLUZCNST LIENTRY ENV=R5,PARM=R2,DSA=COBDSA,DSALEN=COBLEN\n         SR    R1,R1\n         LR    R15,R8             SAVE STARTING POINT\n         MVI   CUMCHARS,X'00'     INITIALIZE ACCUMULATOR\n         IC    R1,0(,R8)          CONSIDER THE FIRST CHAR\n         LA    R3,COBTAB(R1)\n         TM    0(R3),X'20'        IS IT A LETTER?\n         BNZ   CNSTFIG            YES, CHECK FOR FIGURATIVE\nCNSTLIT  CLI   0(R8),C''''        IS IT A NON-NUMERIC LITERAL?\n         BE    CNSTQUOT           SEEMS TO BE\n         MVC   CUMCHARS,0(R3)     NO, SAVE CHARACTER TYPE\n         TM    0(R3),X'04'        IS IT A MINUS?\n         BNZ   CNSTSIGM           YES.\n         TM    0(R3),X'02'        IS IT A PLUS?\n         BNZ   CNSTSIGP           YES.\n         TM    0(R3),X'08'        IS IT A DOT?\n         BNZ   CNSTDOT            YES.\n         TM    0(R3),X'40'        IS IT A DIGIT?\n         BNZ   CNSTNUM            YES.\n         SPACE\nCNSTMISS LA    R15,4              INDICATE CONSTANT IS MISSING\n         B     RETURN             AND RETURN\n         SPACE\n*\n*        THIS CODE INTERFACES TO CLUZWORD TO FIND A FIGURATIVE\n*        CONSTANT.\n*\nCNSTFIG  TM    1(R9),X'08'        IS A FIGURATIVE ALLOWED?\n         BZ    CNSTMFIG           NOPE.\n         BAL   R14,FDEF           YES, FIND THE DEFAULT\n         LR    R14,R1\n         TM    0(R9),X'18'        IS THERE ANY?\n         BZ    CNSTFNOD           NO.\n         SR    R14,R14\n         IC    R14,0(,R1)         YES, SKIP OVER IT\n         LA    R14,2(R14,R1)\nCNSTFNOD TM    1(R9),X'10'        SUBSCRIPT ALLOWED?\n         BZ    CNSTFNOS           NO.\n         LA    R14,2(,R14)        YES, SKIP SUBSCRIPT OFFSET\nCNSTFNOS MVC   ALIGN,0(R14)       GET OFFSET OF IKJRSVWD\n         LH    R14,ALIGN\n         A     R14,PCL            FIND IT\n         LR    R10,R9             SAVE ORIGINAL PCE ADDRESS\n         LR    R9,R14\n         MVC   ALIGN(1),0(R9)\n         NI    ALIGN,X'E0'\n         CLI   ALIGN,X'A0'        IS IT REALLY A RSVWD?\n         BE    CNSTFOK            YES.\nCNSTFNOK BAL   R6,PARSRC24        NO, GIVE RETURN CODE\nCNSTFOK  TM    1(R9),X'80'        IS IT THE RIGHT KIND OF RSVWD?\n         BZ    CNSTFNOK           NO.\n         LA    R15,CLUZWORD       YES, FIND RESERVED WORD ROUTINE\n         LR    R1,R2\n         BALR  R14,R15            RECOGNIZE RESERVED WORD\n         LR    R9,R10             RESTORE PCE POINTER\n         B     *+4(R15)           ACT ON RETURN CODE\n         B     CNSTYFIG           GOT A WORD\n         B     CNSTMFIG           NOT A WORD\n         B     RETURN             ERROR, JUST PASS IT ON\n         SPACE\nCNSTYFIG MVC   4(2,R2),2(R2)      REFORMAT THE PDE\n         XC    2(2,R2),2(R2)\n         OI    6(R2),X'C2'        SET FIGURATIVE FLAGS\n         SR    R15,R15            AND RETURN HAPPY\n         B     RETURN\n         SPACE\nCNSTMFIG TM    6(R9),X'10'        IS THIS AN ANY?\n         BNZ   QUALNFIG           YES, GO TRY AS VARIABLE\n         B     CNSTMISS           NO, SAY CONSTANT IS MISSING\n         SPACE\n*\n*        THIS CODE RECOGNIZES A QUOTED LITERAL (COBOL STYLE).\n*\nCNSTQUOT BXH   R8,R6,CNSTERR      ERROR IF NOTHING AFTER THE QUOTE\n         LR    R15,R8             SAVE FIRST CHAR ADDR\n         L     R14,=V(CLUTSCAP)\nCNSTQLOP CLI   0(R8),C''''        FOUND THE CLOSE QUOTE?\n         BE    CNSTQEND           YES.\n         TM    1(R9),X'40'        NO, IS THIS ASIS?\n         BNZ   CNSTQAS            YES.\n         TR    0(1,R8),0(R14)     NO, UPPER CASE THE VALUE\nCNSTQAS  BXLE  R8,R6,CNSTQLOP     CONTINUE TILL NOTHING LEFT\n         SR    R14,R14            INDICATE NO QUOTE FOUND\n         B     CNSTQUP\n         SPACE\nCNSTQEND LA    R14,1              INDICATE CLOSE QUOTE FOUND\nCNSTQUP  LR    R0,R8\n         AR    R8,R14\n         SR    R0,R15             COMPUTE STRING LENGTH\n         BZ    CNSTERR            NULL STRING NOT ALLOWED\n         CH    R0,=H'120'         CHECK FOR TOO LONG\n         BH    CNSTERR\n         STC   R0,0(,R2)          SAVE LENGTH OF LITERAL\n         MVI   6(R2),X'C4'        INDICATE NON-NUMERIC\n         ST    R15,8(,R2)         STORE STARTING POINT\n         LTR   R14,R14            WAS THE STRING CLOSED?\n         BNZ   CNSTCLOS           YES.\n         BAL   R14,UNCL           NO, MAKE RUDE COMMENT\nCNSTCLOS SR    R15,R15            THEN SET RETURN CODE\n         B     RETURN             AND GO BACK\n         SPACE\nCNSTERR  LA    R15,8\n         B     RETURN             AND RETURN\n         SPACE\n*\n*        THIS CODE RECOGNIZES (FIXED- AND FLOATING-POINT) NUMERIC\n*        LITERALS\n*\nCNSTSIGM OI    7(R2),X'80'        INDICATE SIGN IS MINUS\nCNSTSIGP BXH   R8,R6,CNSTERR      SKIP PAST THE SIGN\n         LR    R15,R8             SAVE TRUE STARTING POINT\nCNSTNEXT IC    R1,0(,R8)\n         LA    R3,COBTAB(R1)\n         TM    0(R3),X'08'        HAVE WE A DECIMAL POINT?\n         BNZ   CNSTDOT            YES.\n         TM    0(R3),X'40'        NO, GOT A DIGIT?\n         BNZ   CNSTNUM            YES.\n         EX    R1,CNSTSEEE        SEE IF WE HAVE AN E\n         BE    CNSTNDON           YES, PROBABLY DONE WITH NUMBER\n         TM    0(R3),X'24'        NO, GOT A LETTER OR A MINUS?\n         BNZ   CNSTPERR           YES, PROBABLE ERROR\n         TM    0(R3),X'02'        GOT A PLUS?\n         BZ    CNSTNDON           NO, FOUND CONSTANT END\n         B     CNSTNELP           YES, GO SCAN FOR END OF ERROR\nCNSTSEEE CLI   =C'E',X'40'        LOOK FOR UPPER OR LOWER CASE E\n         SPACE\nCNSTNUM  OC    CUMCHARS,0(R3)     KEEP TRACK OF CHARACTER TYPE\n         BXLE  R8,R6,CNSTNEXT     CONTINUE WHILE TEXT LEFT\n         B     CNSTNDON\n         SPACE\nCNSTDOT  TM    7(R2),X'20'        PERIOD ALREADY FOUND?\n         BNZ   CNSTNELP           YES, ONLY ONE PER CNSTOMER\n         ST    R8,16(,R2)         STORE ADDRESS OF POINT\n         OI    7(R2),X'20'        SET DECIMAL POINT FLAG\n         B     CNSTNUM            AND CONTINUE\n         SPACE\nCNSTNDON LR    R0,R8\n         SR    R0,R15             COMPUTE LENGTH OF NUMBER\n         TM    7(R2),X'20'        WAS THERE A POINT?\n         BZ    CNSTNDOT           NO.\n         BCTR  R0,0               YES, ADJUST LENGTH\n         LR    R14,R8\n         BCTR  R14,0              LOOK AT LAST CHAR OF NUMBER\n         C     R14,16(,R2)        SEE IF THE PERIOD WAS THERE\n         BE    CNSTNSTY           EVIL IF SO\nCNSTNDOT CH    R0,=H'18'          IS THE LENGTH OK?\n         BH    CNSTPERR           NO, CAN'T BE A GOOD CONSTANT\n         STC   R0,0(,R2)          YES, STORE IT\n         ST    R15,8(,R2)         STORE START OF DIGITS\n         CR    R8,R7              ANYTHING MORE?\n         BH    CNSTFIX            NO.\n         TM    0(R3),X'20'        YES, HAVE WE AN E?\n         BZ    CNSTFIX            NO.\n         TM    7(R2),X'20'        YES, HAS THERE BEEN A POINT?\n         BZ    CNSTPERR           NO, NOT A CONSTANT\n         CH    R0,=H'16'          TOO MANY DIGITS FOR FLOAT?\n         BH    CNSTNELP           YES, DEFINITE ERROR\n         SPACE\n         BXH   R8,R6,CNSTERR      SKIP OVER THE E\n         IC    R1,0(,R8)\n         LA    R3,COBTAB(R1)      INSPECT NEXT CHAR\n         TM    0(R3),X'06'        IS IT A SIGN?\n         BZ    CNSTEXP            NO.\n         TM    0(R3),X'02'        YES, IS IT +?\n         BNZ   CNSTEPOS           YES.\n         OI    7(R2),X'40'        SET MINUS EXPONENT FLAG\nCNSTEPOS BXH   R8,R6,CNSTERR      SKIP THE SIGN\nCNSTEXP  OI    6(R2),X'01'        SET FLOATING FLAG\n         ST    R8,12(,R2)         STORE START OF EXPONENT\n         SPACE\nCNSTEXLP IC    R1,0(,R8)\n         LA    R3,COBTAB(R1)      EXAMINE NEXT EXPONENT CHAR\n         TM    0(R3),X'40'        NUMERIC?\n         BNZ   CNSTEXNX           YES, GO ON\n         TM    0(R3),X'2E'        NO, SOMETHING CLOSE?\n         BNZ   CNSTNELP           YES, SCAN FOR ERROR END\n         B     CNSTEXDN           NO, CONSTANT IS DONE\nCNSTEXNX BXLE  R8,R6,CNSTEXLP\n         SPACE\nCNSTEXDN LR    R0,R8\n         S     R0,12(,R2)         COMPUTE EXPONENT LENGTH\n         CH    R0,=H'2'           TOO LONG?\n         BH    CNSTERR            YES.\n         STC   R0,1(,R2)          NO, STORE EXPONENT LENGTH\n         OI    6(R2),X'C0'        SET NUMERIC BITS\n         SR    R15,R15\n         B     RETURN             AND RETURN\n         SPACE\nCNSTFIX  OI    6(R2),X'C8'        SET FIXED-POINT CONSTANT\n         SR    R15,R15\n         B     RETURN\n         SPACE\n*\n*        WE CANNOT HAVE A GOOD NUMERIC CONSTANT, BUT WE MIGHT HAVE A\n*        VARIABLE. IF THAT IS ALLOWED, RETURN TO THE CLUZQUAL ROUTINE\n*        TO CHECK IT OUT.\n*\nCNSTPERR TM    6(R9),X'10'        IS THIS AN ANY?\n         BZ    CNSTNSTY           NO, MUST REALLY BE AN ERROR\n         TM    CUMCHARS,X'0A'     YES, ANY PERIODS OR PLUSSES FOUND?\n         BNZ   CNSTNSTY           YES, NASTY CONSTANT\n         TM    7(R2),X'80'        NO, DID IT START WITH A MINUS?\n         BZ    QUALNLIT           NO, IT MIGHT BE A VARIABLE NAME\n         SPACE\nCNSTNSTY CR    R8,R7              IS ANYTHING LEFT?\n         BH    CNSTERR            NO, INDICATE ERROR NOW\nCNSTNERR IC    R1,0(,R8)\n         LA    R3,COBTAB(R1)\n         TM    0(R3),X'6E'        HAVE WE A COBOL KIND OF CHAR?\n         BZ    CNSTERR            NO, MUST BE THE END\nCNSTNELP BXLE  R8,R6,CNSTNERR     YES, KEEP LOOKING\n         B     CNSTERR\n         TITLE 'CLUZQUAL -- COBOL VARIABLE QUALIFIER RECOGNIZER'\n*\n*        THIS ROUTINE RECOGNIZES A COBOL VARIABLE QUALIFIER, POSSIBLY\n*        PRECEDED BY A MODULE-ID. FOR \"ANY\" TYPE PARAMETERS, IT\n*        INTERFACES TO THE CONSTANT RECOGNIZER TO SEE IF A CONSTANT\n*        IS PRESENT BEFORE CHECKING FOR A VARIABLE.\n*\nCLUZQUAL LIENTRY ENV=R5,PARM=R2,DSA=COBDSA,DSALEN=COBLEN\n         SR    R1,R1\n         LR    R15,R8             SAVE STARTING POINT\n         MVI   CUMCHARS,X'00'     INITIALIZE ACCUMULATOR\n         IC    R1,0(,R8)\n         LA    R3,COBTAB(R1)\n         TM    6(R2),X'80'        IS THIS FOR THE 1ST QUALIFIER?\n         BZ    QUAL2              NO.\n         TM    6(R9),X'10'        YES, MIGHT IT BE A CONSTANT?\n         BZ    QUALVAR            NO.\n         TM    0(R3),X'20'        YES, START WITH A LETTER?\n         BZ    CNSTLIT            NO, CHECK FOR LITERAL.\n         B     CNSTFIG            YES, CHECK FOR FIGURATIVE CONSTANT\n         SPACE\n*\n*        CONTROL COMES HERE IF AN POSSIBLE FIGURATIVE CONSTANT TURNS\n*        OUT BAD FOR AN \"ANY\" TERM.\n*\nQUALNFIG SR    R1,R1              GET BACK 1ST CHAR INFO\n         IC    R1,0(,R8)\n         LA    R3,COBTAB(R1)\n         LR    R15,R8             PUT STARTING POINT BACK IN R15\n         SPACE\nQUALVAR  TM    0(R3),X'60'        HAVE WE A LETTER OR DIGIT?\n         BNZ   QUALGO             YES.\n         LA    R15,4              NO, QUALIFIER IS MISSING\n         NI    6(R2),X'7F'        TURN OFF PRESENCE FLAG\n         B     RETURN             AND RETURN\n         SPACE\nQUAL2    TM    0(R3),X'60'        HAVE WE A LETTER OR DIGIT?\n         BZ    QUALBAD            NO, BAD QUALIFIER\n         SPACE\nQUALGO   L     R14,=V(CLUTSCAP)   FIND UPPER CASE TABLE\n         SPACE\nQUALFOLD TM    1(R9),X'40'        IS THIS AN ASIS VAR?\n         BNZ   QUALLOOP           YES.\n         TR    0(1,R8),0(R14)     NO, FOLD THIS CHAR\nQUALLOOP OC    CUMCHARS,0(R3)     SAVE CHARACTER TYPE\n         BXH   R8,R6,QUALEND\nQUALRSUM IC    R1,0(,R8)\n         LA    R3,COBTAB(R1)\nQUALCHAR TM    0(R3),X'64'        ALPHAMERIC OR HYPHEN?\n         BNZ   QUALFOLD           YES.\n         TM    0(R3),X'11'        NO, IS IT A STOPPER?\n         BNZ   QUALFIN            YES.\n         TM    0(R3),X'08'        IS IT A PERIOD?\n         BNZ   QUALDOT            MIGHT BE OK THEN\n         B     QUALBAD            NO, WE HAVE A BAD QUALIFIER\n         SPACE\nQUALFIN  CLI   0(R8),C'('         STOPPED BY OPEN PAREN?\n         BNE   QUALEND            NO.\n         OI    COBFLAGS,COBIMMSB  YES, SHOW FOR SUBSCRIPT HANDLER\nQUALEND  LR    R3,R8\n         BCTR  R3,0\n         CLI   0(R3),C'-'         WAS LAST CHAR A HYPHEN?\n         BE    QUALERR            YES, BAD VARIABLE\n         TM    CUMCHARS,X'20'     WAS A LETTER FOUND?\n         BZ    QUALERR            NO, NOT ALLOWED\n         LR    R0,R8\n         SR    R0,R15             GET LENGTH OF QUALIFIER\n         CH    R0,=H'30'          COMPARE TO MAX\n         BH    QUALERR\n         ST    R15,0(,R2)         STORE START OF QUALIFIER\n         STC   R0,4(,R2)          SAVE THE LENGTH\n         SR    R15,R15            NORMAL RETURN CODE\n         TM    6(R2),X'80'        1ST TIME CALL?\n         BZ    RETURN             NO, RETURN\n         OI    6(R2),X'20'        YES, INDICATE VAR\n         B     RETURN\n         SPACE\nQUALDOT  TM    6(R2),X'80'        IS THIS A 1ST TIME CALL?\n         BZ    QUALBAD            NO, PERIOD NOT ALLOWED\n         CLI   16(R2),0           YES, ONE ALREADY NOTED?\n         BNE   QUALBAD            YES, BAD NEWS\n         LR    R0,R8\n         SR    R0,R15             COMPUTE LENGTH OF PGM ID\n         IC    R1,0(,R15)\n         LA    R3,COBTAB(R1)\n         TM    0(R3),X'20'        MAKE SURE FIRST CHAR ALPHA\n         BZ    QUALBAD            BAD IF NOT\n         TM    CUMCHARS,X'04'     MAKE SURE NO HYPHENS\n         BNZ   QUALBAD\n         CH    R0,=H'8'           MAKE SURE ID LENGTH OK\n         BH    QUALBAD\n         STC   R0,16(,R2)         STORE ID LENGTH\n         ST    R15,12(,R2)        AND START OF IT\n         BXH   R8,R6,QUALERR      SKIP PAST PERIOD\n         LR    R15,R8             SAVE TRUE VAR START\n         IC    R1,0(,R8)\n         LA    R3,COBTAB(R1)\n         TM    0(R3),X'11'        IS IT A TERMINATOR\n         BNZ   QUALERR            OOPS.\n         MVI   CUMCHARS,X'00'     RESET ACCUMULATOR\n         B     QUALCHAR           AND START OVER AGAIN\n         SPACE\n*\n*        CONTROL COMES HERE IF AN APPARENT CONSTANT TURNS OUT BAD FOR\n*        AN \"ANY\" TERM.\n*\nQUALNLIT CR    R8,R7              IS ANYTHING LEFT?\n         BH    QUALEND            NO, CHECK OUT VAR\n         L     R14,=V(CLUTSCAP)\n         B     QUALRSUM           YES, JUST RESUME SCANNING\n         SPACE\nQUALBAD  BXH   R8,R6,QUALERR      SKIP THIS CHAR\n         IC    R1,0(,R8)\n         LA    R3,COBTAB(R1)\n         TM    0(R3),X'11'        LOOK FOR A STOPPER\n         BZ    QUALBAD            CONTINUE UNTIL FOUND\n         SPACE\nQUALERR  LA    R15,8              GIVE ERROR RETURN\n         B     RETURN\n         SPACE 3\nCOBDSA   DSECT ,                  DSA FOR CONSTANT/QUALIFIER\n         SPACE\n         DS    22F\nCUMCHARS DS    BL1                CHARACTER TYPE ACCUMULATOR\n         DS    0D\n         SPACE\nCOBLEN   EQU   *-COBDSA\n         SPACE\nCLUTSCOB CSECT ,                  RESUME PREVIOUS CSECT\n         TITLE 'CLUZCVAR -- COBOL VARIABLE CONTROL ROUTINE'\n*\n*        THIS ROUTINE DIRECTS THE PARSING OF \"VAR\" AND \"ANY\" IKJTERM'S.\n*        IT USES THE CLUZQUAL ROUTINE TO RECOGNIZE INDIVIDUAL\n*        QUALIFIERS, AND USES THE PROMPTING SUBROUTINES DIRECTLY TO\n*        ALLOW FOR CORRECTION OF INVALID SYNTAX.\n*\nCLUZCVAR LIENTRY PARM=R2,ENV=R5,DSA=VARDSA,DSALEN=VARLEN\n         MVI   VARFLAGS,X'00'     INITIALIZE FLAG BYTE\n         MVI   LASTBYP,X'FF'      IN CASE ONLY HIDDEN HEAD ENTERED\n         LR    R3,R2              SAVE PDE ADDR FOR LATER\n         SPACE\nVARESTRT LR    R10,R8\n         ST    R8,PREVPOS         SAVE STARTING POINT\n         XC    0(20,R2),0(R2)     WIPE OUT PREVIOUS CONTENTS\n         OI    6(R2),X'80'        IDENTIFY PDE AS FIRST QUAL\n         MVI   8(R2),X'FF'        SET NULL CHAIN FIELD\n         LR    R1,R2\n         LA    R15,CLUZQUAL\n         BALR  R14,R15            GO GET FIRST QUALIFIER\n         B     *+4(R15)           ACT ON RET CODE\n         B     VARSTART           GOT IT\n         B     VARMISS            NOT THERE\n         B     VARSTERR           1ST QUALIFIER BAD\n         SPACE\nVARMISS  MVI   6(R2),X'00'        TURN OFF PRESENCE FLAG\n         B     RETURN             AND RETURN MISSING\n         SPACE\nVARSTERR BAL   R14,INV            SAY INVALID VARIABLE\n         B     *+4(R15)           ANYTHING BACK?\n         B     VARSTNEW           ANOTHER ATTEMPT\n         OI    VARFLAGS,VMISS     SET MISSING INFO FLAG\n         B     VARHEAD            AND LOOK FOR MORE QUALIFIERS\n         SPACE\nVARSTNEW MVI   BYPASS,0\n         OC    OMIT1(4),OMIT1     ANYTHING OMITTED BEFORE?\n         BZ    VARESKIP           NO, JUST PROCESS RESPONSE\n         CLI   LISTF,0            YES, WITHIN A LIST?\n         BNE   VARESKIP           YES, PROCESS RESPONSE OURSELF\n         TM    RANGEF,RANGE2      HANDLING 2ND PART OF RANGE?\n         BNZ   VARESKIP           YES, DON'T GO BACK\n         LA    R15,16             NO, GIVE RETRY RETURN CODE\n         B     RETURN             AND LET CALLER STRAIGHTEN IT OUT\n         SPACE\nVARESKIP MVI   BYPASS,0\n         L     R15,=A(CLUZSKIP)   SKIP OVER EMPTINESS\n         BALR  R14,R15\n         B     *+4(R15)\n         B     VARESTRT           GO HANDLE NEW INPUT\n         B     VARMISS            RETURN MISSING VALUE\n         SPACE\nVARSTART TM    6(R2),X'40'        DID WE FIND A CONSTANT?\n         BZ    VARHEAD            NO.\nVARDONE  SR    R15,R15            SHOW SUCCESS\nVARSUBCK TM    1(R9),X'10'        MAY THIS TERM HAVE A SUBSCRIPT?\n         BZ    RETURN             NO.\n         TM    6(R2),X'20'        YES, IS IT A VARIABLE?\n         BZ    RETURN             NO, MAY NOT HAVE SUBSCRIPT\n         OI    COBFLAGS,COBSUBOK  YES, SET FLAG\n         B     RETURN\n         SPACE\nVARHEAD  OI    COBFLAGS,COBFORM   SET COBOL MESSAGE STYLE FLAG\n         TM    RANGEF,RANGE2      IS THIS A 2ND RANGE PART?\n         BNZ   VARHEADR           YES.\n         ST    R10,COBHEAD1       NO, STORE START & END OF HEAD\n         ST    R8,COBHEAD1+4\n         OI    COBFLGS1,COBOLVAR  SET TRUE VARIABLE SWITCH\n         B     VARHEADJ\nVARHEADR ST    R10,COBHEAD2\n         ST    R8,COBHEAD2+4\n         OI    COBFLGS2,COBOLVAR  SET TRUE VARIABLE SWITCH\nVARHEADJ CLI   BYPASS,0           WAS THIS QUALIFIER SECRETED?\n         BE    VARCONT            NO.\n         TM    RANGEF,RANGE2      YES, SET BYPASS FLAG\n         BNZ   VARHBYP2\n         OI    COBFLGS1,COBHBYP\n         B     VARCONT\nVARHBYP2 OI    COBFLGS2,COBHBYP\n         SPACE\nVARCONT  MVI   BYPASS,0           RESET BYPASS FLAG\n         MVC   SKIPSAVE,SKIPF     SAVE CLUZSKIP FLAGS\n         OI    SKIPF,NOSLASH      NO SUPPRESSION OF OF OR IN\n         MVI   EXPECT,C' '        EXPECT THE IMPOSSIBLE\n         L     R15,=A(CLUZSKIP)\n         BALR  R14,R15            SKIP OVER DELIMITERS\n         NI    SKIPSAVE,NOSLASH\n         NI    SKIPF,255-NOSLASH\n         OC    SKIPF,SKIPSAVE     RESTORE ORIGINAL SLASH HANDLING\n         B     *+4(R15)           ANYTHING LEFT?\n         B     VARMORE            YES.\n         B     VARFIN             NO, RETURN\n         SPACE\nVARMORE  CR    R8,R7              ROOM FOR OF OR IN?\n         BNL   VARFIN             NO, QUIT\n         MVC   QWORD,0(R8)        YES, GRAB 2 CHARS\n         L     R14,=V(CLUTSCAP)\n         TR    QWORD,0(R14)       UPPER CASE THEM\n         CLC   QWORD,=C'OF'       IS IT OF?\n         BE    VAROF              YES.\n         CLC   QWORD,=C'IN'       IS IT IN?\n         BNE   VAROVER            NO, NO VAR LEFT\nVAROF    LA    R14,2(,R8)         LOOK PAST CONNECTOR\n         CR    R14,R7             ANYTHING THERE?\n         BH    VAROF2             NO.\n         SR    R1,R1\n         IC    R1,0(,R14)         YES, WHAT IS IT?\n         LA    R15,COBTAB(R1)\n         TM    0(R15),X'6C'       ANYTHING PLAUSIBLE?\n         BNZ   VAROVER            YES, ASSUME NOT OF OR IN\nVAROF2   LR    R8,R14             SET NEW CURSOR POSITION\nVAROFT   XC    COMMAX,COMMAX      NO COMMAS AFTER OF/IN\n         L     R15,=A(CLUZSKIP)   SKIP TO NEXT TEXT\n         BALR  R14,R15\n         B     *+4(R15)           IS THERE ANY?\n         B     VARNEXT            YES.\n         B     VARINC             NO, HANDLE INCOMPLETE VAR\n         SPACE\nVARNEXT  SR    R1,R1\n         IC    R1,0(,R8)          LOOK AT NEXT CHARACTER\n         LA    R14,COBTAB(R1)\n         TM    0(R14),X'11'       IS IT A STOPPER?\n         BNZ   VARINC             YES, VARIABLE IS INCOMPLETE\n         CLI   4(R3),X'00'        HAVE WE ALREADY GOT QUAL STORAGE?\n         BE    VARQUAL            YES, DON'T DO IT AGAIN\n         LA    R1,16              GET 16 BYTES FOR QUALIFIER PDE\n         L     R15,=A(CLUZALOC)\n         BALR  R14,R15\n         L     R1,NEWMEM          FIND THE NEW MEMORY\n         XC    0(16,R1),0(R1)     ZERO IT\n         ST    R1,8(,R3)          CHAIN TO PREVIOUS\n         LR    R3,R1\n         MVI   8(R3),X'FF'        SET NULL CHAIN IN NEW ALLOCATION\n         SPACE\nVARQUAL  LR    R1,R3              PASS NEW PDE TO QUAL ROUTINE\n         LR    R10,R8             SAVE CURRENT POSITION\n         LA    R15,CLUZQUAL\n         BALR  R14,R15            ASK FOR ANOTHER QUALIFIER\n         SPACE\n         B     *+4(R15)           ACT ON QUAL RET CODE\n         B     VARADD             OK, ADD THIS QUALIFIER\n         BAL   R6,PARSRC12        SHOULD NEVER OCCUR\n         ST    R10,PREVPOS        BAD QUALIFIER, PREPARE TO PROMPT\n         OI    COBFLAGS,QUALFLG   JUST ASK FOR 1 QUALIFIER\n         BAL   R14,INV\n         B     *+4(R15)           WAS IT CORRECTED?\n         B     VAROFT             YES, TRY AGAIN\n         OI    VARFLAGS,VMISS     NO, SET MISSING FLAG\n         SPACE\nVARADD   MVC   LASTBYP,BYPASS     SAVE THE BYPASS FLAG\n         TM    RANGEF,RANGE2      SET FLAGS FOR RANGE ELEMENT\n         BNZ   VARTL2\n         ST    R10,COBTAIL1       SAVE START & END POINTS\n         ST    R8,COBTAIL1+4\n         OI    COBFLGS1,COBQVAR   SET QUALIFIED VAR FLAG\n         B     VARCOUNT\nVARTL2   ST    R10,COBTAIL2\n         ST    R8,COBTAIL2+4\n         OI    COBFLGS2,COBQVAR   SET QUALIFIED VAR FLAG\n         SPACE\nVARCOUNT SR    R1,R1\n         IC    R1,17(,R2)         LOAD PREVIOUS COUNT\n         LA    R1,1(,R1)          BUMP BY 1\n         STC   R1,17(,R2)\n         CH    R1,=H'255'         REACHED THE LIMIT?\n         BL    VARCONT            NO.\n         B     VARFIN             GOOD GRIEF, JUST GIVE UP NOW\n         SPACE\nVARINC   MVC   MSGAREA(4),=A(INCOMPLE) \"INCOMPLETE \"\n         BAL   R14,FDSC           FIND THE DESCRIPTION\n         ST    R1,MSGAREA+4\n         MVC   MSGAREA+8(4),ACOLON     :\n         MVI   QWORD-1,C' '       ADD BLANK PAD TO OF/IN\n         MVI   QWORD-2,2          STORE LENGTH OF OF/IN-1\n         LA    R0,QWORD-2\n         MVI   MSGAREA+12,X'0D'   ADD VAR TEXT TO MESSAGE\n         ST    R0,MSGAREA+16      ADD OF OR IN\n         MVI   MSGAREA+16,X'07'   SET ENDING & SUPPRESSIBLE BITS\n         LA    R1,MSGAREA\n         L     R15,=A(CLUZINFO)\n         BALR  R14,R15            SEND \"INCOMPLETE XXX: AAA...BBB OF\"\n         OI    COBFLAGS,QUALFLG   ADD \"QUALIFICATION FOR\" TO PROMPT\n         BAL   R14,FDSC           FIND THE VARIABLE DESCRIPTOR\n         L     R15,=A(CLUZREQR)   CALL REQUIRE QUALIFIER ROUTINE\n         BALR  R14,R15\n         NI    COBFLAGS,255-QUALFLG    OFF QUALIFICATION FLAG\n         B     *+4(R15)           ANYTHING COME BACK?\n         B     VAROFT             YES, TRY AGAIN\n         SPACE\nVARFORGT LA    R15,20             NO, GIVE BLOW-IT-OFF RET CODE\n         BAL   R14,RLBK           RELEASE QUALIFIER MEMORY\n         B     VARSUBCK           SEE IF SUBSCRIPTS ARE ALLOWED\n         SPACE\nVAROVER  TM    VARFLAGS,VMISS     WAS THERE EVER ANY TROUBLE?\n         BNZ   VARFORGT           YES, GIVE BACK SHRUG\n         SPACE\nVARFIN   TM    RANGEF,RANGE2      2ND RANGE PART?\n         BNZ   VARFIN2            YES.\n         CLI   LASTBYP,0          WAS THE END BYPASSED?\n         BE    VARDONE            NO.\n         OI    COBFLGS1,COBTBYP   YES, SET TAIL BYPASS BIT\n         B     VARDONE\nVARFIN2  CLI   LASTBYP,0          WAS THE END BYPASSED?\n         BE    VARDONE            NO.\n         OI    COBFLGS2,COBTBYP   YES, SET FLAG\n         B     VARDONE\n         SPACE 3\nVARDSA   DSECT ,                  WORK AREA & DSA\n         SPACE\n         DS    22F\n         DS    CL2\nQWORD    DS    CL2                QUALIFIER CONNECTOR (OF OR IN)\nVARFLAGS DS    BL1                FLAG BYTE\nVMISS    EQU   X'80'              VARIABLE PROMPT FAILED\nLASTBYP  DS    XL1                BYPASS FLAG FOR LAST QUALIFIER\n         DS    0D\n         SPACE\nVARLEN   EQU   *-VARDSA\n         SPACE\nCLUTSCOB CSECT ,              RESUME COBOL CSECT\n         TITLE 'CLUZOPER -- OPERATOR EXPRESSION BEGINNING ROUTINE'\n*\n*        THIS ROUTINE IS CALLED TO BEGIN TO HANDLE AN IKJOPER. IT\n*        CHECKS THE CHAINED PCE'S TO MAKE SURE THEY ARE ALL OF THE\n*        RIGHT TYPE, AND DETERMINES WHETHER AN OPEN PARENTHESIS IS\n*        PRESENT IN THE INPUT. IF SO, RECOGNITION WILL PROCEED WITH\n*        THE FIRST TERM OF THE EXPRESSION. IF NOT, AND A LEVEL 88\n*        TERM IS ALLOWED, RECOGNITION PROCEEDS WITH THAT TERM;\n*        OTHERWISE, THE EXPRESSION IS CONSIDERED MISSING.\n*\nCLUZOPER LIENTRY DSA=*,DSALEN=88,ENV=R5,PARM=R2\n         BAL   R14,FDSC           FIND THE OPER DESCRIPTION\n         LR    R15,R1\n         MVC   ALIGN,0(R15)       SKIP PAST IT\n         AH    R15,ALIGN          TO FIND THE SUBPART OFFSETS\n         MVC   ALIGN,2(R15)       GET OFFSET OF FIRST TERM\n         MVI   OPERPART,2         INDICATE WORKING ON TERM 1\n         L     R0,PCL\n         AH    R0,ALIGN           FIND THE FIRST TERM'S PCE\n         BAL   R14,FNXT           FIND THE PCE AFTER THE OPER\n         CR    R1,R0              IT SHOULD BE THE TERM\n         BNE   OPERBAD            IF NOT, CHAINING ERROR\n         SPACE\nOPERTERM MVC   ALIGN(1),0(R1)     FIND TYPE OF CHAINED TERM\n         NI    ALIGN,X'E0'\n         CLI   ALIGN,X'C0'        IS IT A TERM?\n         BNE   OPERBAD            NO, BLOW UP\n         TM    1(R1),X'A0'        YES, IS IT A LIST OR RANGE?\n         BNZ   OPERBAD            YES, ERROR\n         TM    6(R1),X'08'        IS THIS A SUBSCRIPT?\n         BNZ   OPERBAD            YES, NOT ALLOWED\n         CLI   OPERPART,4         WHICH TERM ARE WE LOOKING AT?\n         BE    OPER88             2ND TERM\n         BH    OPERGOOD           LEVEL88 TERM\n         SPACE\n         LR    R3,R9              SAVE ORIGINAL PCE ADDRESS\n         LR    R9,R1              POINT R1 TO 1ST TERM\n         MVC   ALIGN,0(R15)       FIND OFFSET OF OPERATOR\n         L     R0,PCL\n         AH    R0,ALIGN           FIND OPERATOR'S PCE\n         BAL   R14,FNXT           FIND NEXT PCE AFTER TERM 1\n         CR    R1,R0              SAME AS THE OPERATOR?\n         BNE   OPERBAD            NO, BAD PARMS\n         MVC   ALIGN(1),0(R1)     YES, MAKE SURE ITS A RESERVED WORD\n         NI    ALIGN,X'E0'\n         CLI   ALIGN,X'A0'\n         BNE   OPERBAD            NOPE, ERROR\n         TM    1(R1),X'80'        IS IT CHAINED FROM A TERM?\n         BNZ   OPERBAD            IT SHOULDN'T BE\n         MVC   ALIGN,4(R15)       OFFSET OF TERM2\n         L     R0,PCL\n         AH    R0,ALIGN           POINT TO TERM2 PCE\n         LR    R9,R1\n         BAL   R14,FNXT           FIND PCE AFTER THE OPERATOR\n         CR    R1,R0              SAME AS TERM2?\n         BNE   OPERBAD            GASP, CHOKE\n         MVI   OPERPART,4         INDICATE WORKING ON TERM2\n         B     OPERTERM           MAKE SURE ITS A TERM\n         SPACE\nOPER88   MVC   ALIGN,6(R15)       GET OFFSET OF CHAINED TERM\n         LH    R0,ALIGN\n         LTR   R0,R0              IS ONE ALLOWED?\n         BZ    OPERGOOD           NO, VALIDATION DONE\n         A     R0,PCL             YES, FIND ITS PCE\n         LR    R9,R1\n         BAL   R14,FNXT           FIND NEXT PCE AFTER TERM2\n         CR    R1,R0              IS IT THE SAME?\n         BNE   OPERBAD            NOPE.\n         MVI   OPERPART,6         YES, NOTE LEVEL 88 TERM ACTIVE\n         B     OPERTERM           MAKE SURE ITS A TERM\n         SPACE\nOPERBAD  BAL   R6,PARSRC24        INDICATE CHAINING ERROR\n         SPACE\nOPERGOOD OI    OPERFLGS,OPERACT   SET OPERATOR ACTIVE FLAG\n         ST    R3,OPERPCE         SAVE IKJOPER PCE\n         ST    R15,OPEROFFS       SAVE ADDR OF SUBPART OFFSETS\n         MVC   ALIGN,4(R1)        GET PDL OFFSET FOR FINAL PART\n         LH    R10,ALIGN\n         LR    R9,R1\n         BAL   R14,SIZE           FIND SIZE OF THAT PART\n         AR    R10,R1             GET OFFSET PAST THE END\n         MVC   ALIGN,4(R3)        GET OFFSET FOR OPER ITSELF\n         SH    R10,ALIGN          GET FULL SIZE OF OPER PDE\n         STH   R10,OPERSIZE       SAVE FOR LATER\n         MVI   COBFLGS2,COBOLVAR  INIT OPER'S COBFLGS FOR MSGS\n         XC    COBHEAD2(16),COBHEAD2\n         CLI   0(R8),C'('         IS THERE A ( NEARBY?\n         BNE   OPERALT            NO, MIGHT BE A LEVEL 88 VAR\n         OI    OPERFLGS,OPEREXPR  YES, INDICATE FULL EXPRESSION\n         MVC   OPEROMIT,OMIT1     SAVE PREVIOUS BACKUP POINT\n         XC    OMIT1,OMIT1\n         MVI   COBFLGS2,COBOLVAR  INIT OPER'S COBFLGS FOR MSGS\n         AR    R8,R6              SKIP OVER PAREN\n         MVI   OPERPART,2         START RECOGNITION WITH TERM1\n         MVC   ALIGN,2(R15)\n         LH    R9,ALIGN\n         A     R9,PCL             FIND THE PCE FOR THE FIRST TERM\n         XC    COMMAX,COMMAX      CATCH COMMA BEFORE FIRST TERM\n         SPACE\nOPERRET  LA    R15,12             SET NEW PCE RETURN CODE\nOPERRET2 L     R14,4(,R13)        FIND OLD SAVE AREA\n         ST    R9,56(,R14)        PASS BACK NEW R9\n         B     RETURN             AND RETURN TO CALLER\n         SPACE\nOPERALT  LTR   R0,R0              MAY THERE BE A LEVEL 88 NAME?\n         BZ    OPERMISS           NO, EXPRESSION IS MISSING\n         LR    R9,R0              YES, POINT R9 TO ITS PCE\n         OC    OMIT1,OMIT1        ANYTHING OMITTED BEFORE?\n         BNZ   OPERRET            YES.\n         ST    R3,OMIT1           NO, SAY OPER PROPER FIRST OMITTED\n         B     OPERRET            GO RECOGNIZE IT\n         SPACE\nOPERMISS LA    R15,4              SET MISSING RET CODE\n         MVI   OPERFLGS,0         RESET OPERATOR FLAGS\n         TM    0(R3),X'10'        IS THIS EXPRESSION REQUIRED?\n         BNZ   OPERRQR            YES.\n         LR    R9,R0              NO, CAUSE SKIP PAST END OF EXPR\n         B     OPERRET2\n         SPACE\nOPERRQR  LR    R9,R3              RESTORE ORIGINAL R9\n         B     OPERRET2           FOR PURPOSES OF REQUIREMENT\n         TITLE 'CLUTSCOB -- COBOL-ONLY DATA AREAS'\n*\n*        DEFINE THE TRT TABLE FOR USE BY THE COBOL RECOGNIZERS.\n*\n         SPACE\n         TABSET 64,(F0,F9)        X'40'=DIGITS\n         TABSET 32,(81,89),(91,99),(A2,A9),(C1,C9),(D1,D9),(E2,E9)     *\n                                  X'20'=ALPHA\n         TABSET 16,05,40,5E,61,6B X'10'=SEPARATORS+SLASH\n         TABSET 8,4B              X'08'=PERIOD\n         TABSET 4,60              X'04'=HYPHEN\n         TABSET 2,4E              X'02'=PLUS\n         TABSET 1,4D,5D,7A        X'01'=( | ) | :\n         SPACE\nCOBTAB   TABGEN ,                 GENERATE COBOL TABLE\n         TITLE 'DYNAMIC WORK AREA MAPPING'\nDSA      DSECT ,                  GENERAL WORK AREA\n         SPACE\nSAVEAREA DS    22A\nIOPL     DS    4A                 IOPL FOR SERVICE ROUTINES\nPCL      DS    A                  PCL POINTER\nANSPTR   DS    A                  ANSWER PLACE POINTER\nCBUF     DS    A                  ORIGINAL COMMAND BUFFER PTR\nVPDE     DS    A                  PDE FOR VALIDCK EXIT\nUWA      DS    A                  WORK AREA PTR FOR VALIDCK EXIT\nVMSG     DS    A                  LEVEL 2 MSG PTR\nTEXTSEG  DS    A                  TEXT TO PARSE (FOR USER RECOGNIZER)\nRPARM    DS    A                  USER RECOGNIZER PARM ADDR\nCAPTAB   DS    A                  ADDR(CLUTSCAP) IF NOT ASIS\nGETRTN   DS    A                  USER RECOGNIZER GET ENTRY\nGIVEUP   DS    4A                 LIE SIMULATED LABEL VARIABLE\nNEWMEM   DS    A                  NEWLY GOTTEN MEMORY ADDR\nMEMBLOCK DS    A                  ADDR OF CURRENT MEMORY BLOCK\nBLKLEN   DS    F                  LENGTH OF CURRENT BLOCK\nBLKTOP   DS    A                  HIGH ADDR IN CURRENT BLOCK\nBLKCHAIN DS    A                  BLOCK CHAIN PTR FOR IKJRLSA\nFREESEGS DS    A                  HEAD OF FREE MEMORY SEGMENT CHAIN\nALCSEGS  DS    A                  HEAD OF ALLOCATED SEGMENT CHAIN\nOWNSEGS  DS    A                  HEAD OF PENDING SEGMENT CHAIN\nOWNLINK  DS    A                  LAST LINK IN PENDING SEGMENT CHAIN\nSEGSTART DS    A                  START OF CURRENT OWNED SEGMENT\nHIGHMARK DS    A                  HIGH-WATER MARK IN CURRENT BLOCK\nLOWMARK  DS    A                  LOW-WATER MARK IN CURRENT BLOCK\nOWNERID  DS    A                  PCE OF CURRENT MEMORY OWNER\nLEVLSTAK DS    8A                 NESTING LEVEL INFORMATION STACK\nCURINP   DS    A                  CURRENT INPUT BUFFER\nPREVPOS  DS    A                  TEXT PTR WHERE SCAN STARTED\nPASSTART DS    A                  TEXT PTR WHERE PASSWORD SCAN BEGAN\nOLDPOS   DS    A                  PREVPOS SAVE AREA FOR PASSWORD\nPDLPTR   DS    A                  POINTER TO START OF PDL\nKEYPTR   DS    A                  POINTER TO SELECTED IKJKEYWD\nPASSPDE  DS    A                  PSEUDO-PDE ADDR FOR PASSWORD\nLISTEMP  DS    41A                WORK PDE FOR LISTS\nRANGTEMP DS    20A                WORK PDE FOR RANGES\nPREVLIST DS    A                  ADDR OF PREVIOUS LIST PDE\nSUBSTAT  EQU   *                  START OF AREA SAVED OVER SUBSCRIPT\nRANGEPOS DS    A                  POSITION OF RANGE VALUE 1 START\nRANGEND  DS    A                  RANGE VALUE 1 END\nCOBHEAD1 DS    2A                 START & END FOR HEAD OF VAR\nCOBTAIL1 DS    2A                 START & END FOR TAIL OF VAR\nCOBHEAD2 DS    2A                 START & END FOR HEAD OF VAR #2\nCOBTAIL2 DS    2A                 START & END FOR TAIL OF VAR #2\nOMIT1    DS    A                  PCE ADDR FOR RECENTLY OMITTED PARM\nSUBSTLEN EQU   *-SUBSTAT          LENGTH OF SUBCRIPT-RELATED INFO\nSUBSPDE  DS    A                  PDE FOR CURRENT SUBSCRIPT\nOPERPCE  DS    A                  ADDR OF ACTIVE IKJOPER PCE\nOPEROMIT DS    A                  SAVE AREA FOR OMIT1 OVER EXPRESSION\nOPEROFFS DS    A                  ADDR OF CHAINS IN IKJOPER PCE\nVRTN     DS    A                  VALIDCK ROUTINE ADDRESS\nMSGAREA  DS    7A                 MESSAGE WORK AREA 1\nIOWORK   DS    9A                 MESSAGE WORK AREA 2\nPGPB     DS    4A                 PUTGET (ET AL) PARM BLOCK\nDFSAVE   DS    2A                 SAVE AREA FOR DEFAULT ROUTINE\nPWSAVE   DS    4A                 SAVE AREA FOR PASS\nRSAVE    DS    6A                 SAVE AREA FOR RANG\nVSAVE    DS    6A                 SAVE AREA FOR VEX\nESAVE    DS    6A                 SAVE AREA FOR ERAS\nCSAVE    DS    2A                 SAVE AREA FOR CMIT/RLBK\nISAVE    DS    A                  SAVE AREA FOR INV\nMSAVE    DS    6A                 SAVE AREA FOR MSG ROUTINES\nBSAVE    DS    2A                 SAVE AREA FOR BMSG\nSUBWORKS DS    5CL(SUBWLEN)       SUBFIELD WORK AREAS\nSUBWEND  EQU   *                  END OF SUBFIELD WORK AREAS\nSUBSAVE  DS    A                  ADDR(SUBSCRIPT-WORK-AREA)\n         DS    2H\nMSGID    DS    CL9                MSGID FOR PROMPT\n         DS    0H                 FORCE VS ASSEMBLER TO ALIGN\nALIGN    DS    H\nLISTSIZE DS    H                  PDE SIZE FOR LIST\nRANGSIZE DS    H                  PDE SIZE FOR RANGE\nOPERSIZE DS    H                  PDE SIZE FOR ALL OPER PARTS\nNAME#    DS    H                  NUMBER OF IKJNAME FOR KEYWORD\nCOMMAS   DS    H                  NUMBER OF COMMAS FOUND BY CLUZSKIP\nCOMMAX   DS    H                  MAXIMUM COMMAS PERMITTED\nSKIPF    DS    B                  FLAGS FOR CLUZSKIP\nNOCOMMA  EQU   X'80'              TREAT COMMA AS BLANK\nNOSLASH  EQU   X'40'              DON'T PROCESS SLASH\nSLASH1   EQU   X'20'              1 SLASH ALREADY FOUND\nNOSKIP   EQU   X'10'              DON'T SKIP ANYTHING\nEXPECT   DS    CL1                EXPECTED NEXT CHARACTER\nLISTF    DS    B                  WITHIN-LIST FLAG\nSUBFD1   DS    B                  FIRST PARM IN SUBFIELD FLAG\nSUBFLAG  DS    B                  WITHIN SUBFIELD FLAG\nPASSF    DS    B                  PASSWORD FLAGS\nPASSABLE EQU   X'80'              PASSWORD MAY FOLLOW\nPASSCAN  EQU   X'40'              PASSWORD SCAN COMPLETE\nPASSEEN  EQU   X'20'              PASSWORD DELIMITER (/) SEEN\n         AIF   ('&OPSYS' NE 'MVS').NMVS3C\nPASSPROM EQU   X'02'              PASSWORD FROM PROMPT RESPONSE\nNWPASSOK EQU   X'01'              NEW PASSWORD MAY FOLLOW\n.NMVS3C  ANOP\nLEFTOVER DS    B                  PASSWORD/SUBSCRIPT FOR INVALID ITEM\nSUBSOPTS EQU   *                  START OF FLAGS SAVED OVER SUBSCRIPT\nRANGEF   DS    B                  RANGE FLAGS\nRANGE0   EQU   X'80'              INCOMPLETE RANGE FLAG\nRANGERR  EQU   X'40'              WHOLE RANGE BAD FLAG\nRANGE1NV EQU   X'20'              UNABLE TO REPAIR BAD RANGE PART\nRANGE2   EQU   X'10'              PART 2 IN PROGRESS\nCOBFLAGS DS    B                  COBOL VARIABLE FLAGS\nQUALFLG  EQU   X'80'              PROMPTING FOR QUALIFIER\nCOBFORM  EQU   X'40'              USE COBOL ERROR DISPLAY FORMAT\nCOBDOTS  EQU   X'20'              DOTS NEEDED BETWEEN/AFTER VAR PART\nCOBSUBOK EQU   X'10'              SUBSCRIPT PERMITTED FOR THIS VAR\nCOBSUB   EQU   X'08'              PROCESSING A SUBSCRIPT\nCOBIMMSB EQU   X'04'              OPEN PAREN IMMEDIATELY AFTER VAR\nCOBSUB88 EQU   X'02'              LEVEL 88 SUBSCRIPT NEARBY\nCOBFLGS1 DS    B                  COBOL FLAGS FOR RANGE START\nCOBFLGS2 DS    B                  COBOL FLAGS FOR RANGE END\nCOBQVAR  EQU   X'80'              VARIABLE IS QUALIFIED\nCOBHBYP  EQU   X'40'              HEAD OF VARIABLE IS SECRET\nCOBTBYP  EQU   X'20'              TAIL OF VARIABLE IS SECRET\nCOBOLVAR EQU   X'10'              REALLY A COBOL VARIABLE\nCOBHASUB EQU   X'08'              THIS VARIABLE HAS A SUBSCRIPT\nSUBOPLEN EQU   *-SUBSOPTS         LENGTH OF SUBSCRIPT-RELATED FLAGS\nSUBSNO   DS    FL1                CURRENT SUBSCRIPT NUMBER\nOPERFLGS DS    B                  OPERATOR FLAGS\nOPERFAIL EQU   X'80'              PROMPTING FAILURE FLAG\nOPERACT  EQU   X'40'              IKJOPER ACTIVE\nOPEREXPR EQU   X'20'              WITHIN EXPRESSION FOR OPER\nOPERINV  EQU   X'10'              INVALID OPERATOR EXPRESSION\nOPERCLS  EQU   X'08'              OPERATOR EXPRESSION HAS BEEN CLOSED\nOPERPRES DS    B                  PRESENCE INDICATORS FOR OPER SUBPARTS\nOPERPART DS    FL1                OPER SUBPART NUMBER\nOMITPART DS    FL1                OMITTED IKJOPER SUBPART\nSUBLIST  DS    B                  NO PARENTHESES AROUND LIST FLAG\nDEFTF    DS    B                  DEFAULT FLAGS\nDEFTINS  EQU   X'80'              DEFAULT VALUE INSERTED\nDEFTPOS  EQU   X'40'              DEFAULT POSITIONAL BEING HANDLED\nDEFTOPER EQU   X'20'              DEFAULTING OPER SUBITEMS\nDEFTINPT DS    B                  CURRENT INPUT IS DEFAULT FLAG\nRC       DS    FL1                ULTIMATE RETURN CODE\nBYPASS   DS    B                  PROMPT WITH BYPASS FLAG\nSKIPSAVE DS    B                  SAVE AREA FOR SKIPF\nORIGBYP  DS    B                  SAVE AREA FOR BYPASS\nRANGBYP  DS    B                  SAVE AREA FOR BYPASS WITHIN RANGE\nINSFLAG  DS    B                  CURRENT INPUT INSERTED\nINSERTED EQU   X'80'              INPUT IS INSERTED\nDUMMYSUB EQU   X'40'              INPUT IS DUMMY SUBFIELD/SUBSCRIPT\nVIRGINP  EQU   X'20'              INPUT NOT YET TOUCHED BY CLUZSKIP\n         AIF   ('&OPSYS' NE 'MVS').NMVS10A\nPSWDCONF EQU   X'01'              INPUT IS NEW PASSWORD CONFIRMATION\n.NMVS10A ANOP\nALCFLAGS DS    B                  ALLOCATION FLAGS\nCOLECTIV EQU   X'80'              ALLOCATING COLLECTIVE MEMORY\nACPTREQ  EQU   X'40'              ACCEPT REQUIRED FOR CURRENT OWNER\nNESTLEVL DS    FL1                LEVEL OF PCE NESTING\nALCLEVEL DS    FL1                LEVEL OF ALLOCATION NESTING\nLOWLEVEL DS    FL1                LOWEST LEVEL OWNING MEMORY\nLEVRANGE EQU   8                  RANGE/EXPRESSION LEVEL\nLEVITEM  EQU   16                 NORMAL PARAMETER LEVEL\nLEVSUBS  EQU   24                 SUBSCRIPT/PASSWORD LEVEL\nAMBFLAG  DS    B                  AMBIGUOUS KEYWORD FLAG BYTE\nPCBYPASS DS    B                  BYPASS SPECIFIED BY PCE FLAG\nDELIM    DS    CL1                CURRENT DELIMITER\nCAPDELIM DS    CL1                CURRENT DELIMITER IN UPPER CASE\nDLQFLAG  DS    B                  QUOTE IS DELIMITER\n         DS    0D\nDSALEN   EQU   *-DSA              LENGTH OF WORK AREA\n         SPACE 3\nSUBSECT  DSECT ,                  SUBSCRIPT SAVE AREA\n         SPACE\nSUBSREGS DS    6A                 REGISTER SAVE AREA\nSUBSVAR  DS    A                  SUBSCRIPTED VAR PCE\nSUBSWORK DS    0A,CL(SUBSTLEN)    STATUS POINTERS\nSUBSFLGS DS    XL(SUBOPLEN)       STATUS FLAGS\n         DS    0D\nSUBSLEN  EQU   *-SUBSECT          LENGTH OF SUBSCRIPT SAVE AREA\n         TITLE 'CLUTSPAR -- TSO UPT MAPPING'\n         IKJUPT ,                 GET THE UPT MAPPING\n         TITLE 'CLUTSPAR -- LITERALS'\nCLUTSPAR CSECT ,                  RESTORE 1ST CSECT\n         SPACE\n         LTORG ,                  CAPTURE ALL LITERALS HERE\n         TITLE 'CLUTSPAR -- TRANSLATION TABLES'\n*\n*        GENERATE TRANSLATE TABLES. THEY ARE PUT AT THE END OF THE\n*        CSECT, SINCE ONLY THE FIRST BYTE HAS TO BE ADDRESSIBLE.\n*\n         TABRESET ,               FORGET COBOL TABLE VALUES\n         TABSET 128,5B,7B,7C,(87,89),(91,99),(A2,A9),(C7,C9),(D1,D9),  *\n               (E2,E9)            X'80'=ALPHA+NATIONAL-HEX\n         TABSET 64,(F0,F9)        X'40'=DIGITS\n         TABSET 32,(81,89),(91,99),(A2,A9),(C1,C9),(D1,D9),(E2,E9)     *\n                                  X'20'=ALPHA\n         TABSET 16,05,40,5E,61,6B X'10'=SEPARATORS+SLASH\n         TABSET 8,0D,4D,5C,5D,7D  X'08'=NON-DELIMITERS - DIGITS\n         TABSET 4,6D              X'04'=UNDERSCORE\n         TABSET 2,4E,60,6C        X'02'=% | + | -\n         TABSET 1,4D,5D,7A        X'01'=( | ) | :\n         SPACE\nSCANTAB  TABGEN ,                 GENERATE THE TABLE\n         SPACE 3\nCLUTSCAP CSECT ,                  UPPER CASE TRANSLATE TABLE\n         DC    X'000102030405060708090A0B0C0D0E0F'\n         DC    X'101112131415161718191A1B1C1D1E1F'\n         DC    X'202122232425262728292A2B2C2D2E2F'\n         DC    X'301323333435363738393A3B3C3D3E3F'\n         DC    X'404142434445464748494A4B4C4D4E4F'\n         DC    X'505152535455565758595A5B5C5D5E5F'\n         DC    X'606162636465666768696A6B6C6D6E6F'\n         DC    X'707172737475767778797A7B7C7D7E7F'\n         DC    X'80C1C2C3C4C5C6C7C8C98A8B8C8D8E8F'\n         DC    X'90D1D2D3D4D5D6D7D8D99A9B9C9D9E9F'\n         DC    X'A0A1E2E3E4E5E6E7E8E9AAABACADAEAF'\n         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'\n         DC    X'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'\n         DC    X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'\n         DC    X'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'\n         DC    X'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'\n         TITLE 'CLUTSMSG -- MESSAGE SEGMENTS'\nCLUTSMSG CSECT ,                  HIDE MESSAGES IN SPECIAL CSECT\nINVALID  SEG   'CLUTS001I INVALID '\nREENTER  SEG   'CLUTS002A REENTER'\nENTERID  SEG   'CLUTS003A'\nENTER    SEG   ' ENTER '\nMISSID   SEG   'CLUTS004I'\nMISSING  SEG   ' MISSING '\nINCOMPLE SEG   'CLUTS005I INCOMPLETE '\nUNKNOWN  SEG   'CLUTS006I UNKNOWN '\nAMBIG    SEG   'CLUTS007I AMBIGUOUS '\nIGNORED  SEG   'CLUTS008I EXTRANEOUS INFORMATION IGNORED'\nUNINTELL SEG   'CLUTS009I UNINTELLIGIBLE INFORMATION'\nOVERRIDE SEG   'CLUTS010I OVERRIDING KEYWORD ACCEPTED'\nASSUMED  SEG   'CLUTS011I CLOSING QUOTE ASSUMED'\nNODELIM  SEG   'CLUTS012I STRING NOT PRECEDED BY VALID DELIMITER'\nEXTRACOM SEG   'CLUTS013I EXTRANEOUS COMMA(S) IGNORED'\n         AIF   ('&OPSYS' NE 'MVS').NMVS10E\nCONFIRM  SEG   'CLUTS014A CONFIRM NEW PASSWORD'\nCONFAIL  SEG   'CLUTS015I PASSWORD NOT CONFIRMED'\n.NMVS10E ANOP\nERRAT    SEG   'CLUTS099I IKJPARS ERROR DETECTED AT OFFSET '\nFIRST    SEG   'FIRST '\nSECOND   SEG   'SECOND '\nRANGE    SEG   'RANGE'\nOPERAND  SEG   'OPERAND'\nOPERATOR SEG   'OPERATOR'\nQUALFOR  SEG   'QUALIFIER FOR '\nPASSWORD SEG   'PASSWORD'\nSUBSCRS  SEG   'SUBSCRIPT(S)'\nFOR      SEG   ' FOR '\nKEYWORD  SEG   'KEYWORD'\nINVPARM  SEG   'INVALID '\nSTRINGID SEG   'STRING'\nVALUEID  SEG   'VALUE'\nADDRID   SEG   'ADDRESS'\nUSERID   SEG   'USERID'\nDSNID    SEG   'DSNAME'\n         AIF   ('&OPSYS' NE 'MVS').NMVS4D\nDDNID    SEG   'DDNAME'\nJOBID    SEG   'JOBNAME'\nNEWPASS  SEG   'NEW PASSWORD'\n.NMVS4D  ANOP\nCOLON    SEG   ': '\nRCOLON   SEG   ':'\nBPLUS    SEG   ' +'\nPLUS     SEG   '+'\nPLMINUS  SEG   '+ - '\nMINUS    SEG   ' -  '\nBLANK    SEG   ' '\n         END   CLUZPAR       I CAN'T BELIEVE I WROTE THE WHOLE THING\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CMDIN": {"ttr": 3848, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "XSEND              XS\nWATFIV             WAT       GOFORT\nVSAPL              APL\nVERIFY             VFY\nTSOSORT            TSORT\nTSOMODE            TSO\nTERMINAL           TERM\nSTEPLIB            STEP\nSHOW               SH\nSEND               SE\nSCRIPT             SCR\nSCHEDULE           SCHED     SUBMIT    SUB\nRUN                R\nRESETCAT           RCAT\nRENAME             REN\nQED.WHERE          QWHERE    QW\nQED.VERIFY         QVERIFY   QV\nQED.UP             QUP\nQED.UNNUM          QUNNUM    QUNN\nQED.TOP            QTOP      QT\nQED.TN             QTN\nQED.TABSET         QTABSET   QTAB\nQED.TABCHAR        QTABCHAR  QTABC\nQED.SCRIPT         QSCRIPT   QSCR\nQED.SCHEDULE       QSCHEDUL  QSCHED\nQED.SCAN           QSCAN     QSC\nQED.SAVE           QSAVE     QS\nQED.RLN            QRLN\nQED.REPTEND        QTAEPER\nQED.REPFLD         QREPFLD   QRF\nQED.REPEAT         QREPEAT   QREP\nQED.RENUM          QRENUM    QREN\nQED.RENQED         QRENQED\nQED.MOVE           QMOVE     QMO\nQED.MODIFY         QMODIFY   QMOD\nQED.MEMQED         QMEMQED\nQED.LIST           QLIST     QL\nQED.LINEDIT        QLINEDIT\nQED.INSERT         QINSERT   QIN\nQED.INPUT          QINPUT    QI\nQED.INCLUDE        QINCLUDE  QINC      QMERGE    QM\nQED.IMODE          QIMODE\nQED.FT             QFT\nQED.FIND           QFIND     QF\nQED.FIELD          QFIELD\nQED.END            QEND\nQED.DSN            QDSN\nQED.DOWN           QDOWN\nQED.DELETE         QDELETE   QDEL\nQED.CT             QCT\nQED.COPY           QCOPY     QCO\nQED.CHANGE         QCHANGE   QC\nQED.BOTTOM         QBOTTOM   QB\nQED.ALTER          QALTER    QA\nPROTECT            PROT\nOPERATOR           OPER\nMESSAGE            MSG\nMERGE              M\nLOGONID.UNLOCK     LIDUNLOC  LIDUNLK\nLOGONID.LOCK       LIDLOCK   LIDLK\nLOGONID.LIST       LIDLIST   LIDL\nLOGONID.CHANGE     LIDCHANG  LIDC\nLOGONID.CANCEL     LIDCANCE  LIDCAN    LIDDELET  LIDDEL\nLOGONID.ADD        LIDADD    LIDA\nLOGONID            LID\nLOADGO             LOAD\nLISTRULE           LR\nLISTMEM            LISTM\nLISTJES            LJ\nLISTDS             LISTD\nLISTCRA            LISTR\nLISTCAT            LISTC\nLISTBC             LISTB\nLISTALC            LISTA\nLIST               L\nKEEP               K\nISPF.VTOCUTIL      ISPUVT\nISPF.TUTORIAL      ISPTUTOR\nISPF.TSO           ISPTSO\nISPF.TESTVAR       ISPQTV\nISPF.TESTPAN       ISPDPT\nISPF.TESTMENU      ISPMNT\nISPF.STATUTIL      ISPURS\nISPF.SCRIPT        ISPUSC\nISPF.OPTIONS       ISPOPT\nISPF.HARDCOPY      ISPUHC\nISPF.FOREGRND      ISPFOR\nISPF.EDIT          ISPEDIT\nISPF.DSUTIL        ISPUDA\nISPF.COPYUTIL      ISPUMC\nISPF.CONVERT       ISPQCM\nISPF.CATUTIL       ISPUCA\nISPF.BROWSE        ISPBRO\nISPF.BACKGRND      ISPJOB\nINTERPRT           INTERP\nIMPORTRA           MPRA\nIMPORT             IMP\nIBMPROF            IBMP\nHELP               H\nGRAFT.XFER         GRXFER\nGRAFT.USER         GRUSER\nGRAFT.TAPE         GRTAPE\nGRAFT.SAVE         GRSAVE\nGRAFT.RESTORE      GRRESTOR\nGRAFT.NEWTAPE      GRNEWTAP\nGRAFT.MODIFY       GRMODIFY\nGRAFT.LIST         GRLIST\nGRAFT.KILL         GRKILL\nGRAFT.HELP         GRHELP\nGRAFT.END          GREND\nGRAFT.DIRECTOR     GRDIRECT\nGRAFT.CREATE       GRCREATE\nGRAFT.BACK         GRBACK\nGRAFT.ATTACH       GRATTACH\nFREEALL            FREEA     FA\nFORMAT             FORM\nEXPORTRA           XPRA\nEXPORT             EXP\nEXEC               EX\nEDIT               E\nDUPLICAT           DUP\nDELETE             DEL\nDEFINE             DEF\nCOPY               CO\nCOBOL              COB\nBALANCE            BAL\nATTRIB             ATTR\nASMXF              ASMF\nASMG               ASM\nALLOCATE           ALLOC\nACFNRULE           ACFN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COB02@": {"ttr": 3851, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "1\n-\n0                  INSTITUTE FOR COMPUTER SERVICES AND APPLICATIONS\n0                                  RICE UNIVERSITY\n0                                    12 May 1982\n0                                Document No. COB002\n0                      Julian-Gregorian Date Conversion Routine\n-\n        JULIAN is a subroutine that may be called from COBOL to convert a\n        Julian date (i.e., year, day of year format) to a Gregorian date\n        (i.e., month, day of month, year format) or vice versa.  It can also\n      | be used to obtain the current date in both formats.  Optionally,\n      | JULIAN can return the day of the week of the date converted or\n      | obtained.  JULIAN uses a table lookup method which converts all valid\n        dates from the year 1901 to 2099 correctly.  Note that the only\n        validity check performed on the input date is a range check on the\n        Gregorian month.\n-       USAGE\n0       JULIAN resides in the RICE.COBLIB library.  The ULIBDSN parameter of\n        any ICSA COBOL cataloged procedure with link-edit or load steps may be\n        used to access this library as follows:\n0         cc 1\n             //stepname   EXEC  procname,ULIBDSN='RICE.COBLIB'\n0       Alternatively, the following SYSLIB DD cards may be added to JCL using\n        any COBOL cataloged procedure with link-edit or load steps.\n0         cc 1\n             //step.SYSLIB  DD\n             //             DD  DSN=RICE.COBLIB,DISP=SHR\n0       In the JCL above, \"step\" refers to either LKED or GO depending on the\n        cataloged procedure being used.  See ICSA Document COB001 and COB003\n        for the placement of these cards in the deck and for additional\n        information on the ULIBDSN parameter and the SYSLIB DD card.\n0     | The JULIAN subroutine may be called with two or three arguments.  The\n        first argument must be a five digit numeric field that is used for\n        input/output of the Julian date represented by YYDDD; the second\n        argument must be a six digit numeric field that is used for\n      | input/output of the Gregorian date represented by MMDDYY.  The third\n      | argument is optional; if provided, it must be a one digit numeric\n      | field into which the day of the week will be placed (1=Sunday,\n      | 2=Monday,...7=Saturday,0=don't know).  The arguments must be defined\n        or defaulted as USAGE IS DISPLAY but need not be contiguous fields.\n      | When JULIAN is called, one or both of the first two arguments must be\n        zero (but not blank).  JULIAN converts the input dates as follows:\n0         .  If only the Julian argument (i.e., the first argument) is zero,\n             the Gregorian date in the second argument is converted to Julian\n             format and stored in the first argument.\n          .  If only the Gregorian argument (i.e., the second argument) is\n             zero, the Julian date in the first argument is converted to\n             Gregorian format and stored in the second argument.\n          .  If both arguments are zero, the current date is converted to\n             Julian and Gregorian formats and stored in the first and second\n             arguments, respectively.\n0     | If the day-of-week argument (i.e., the third argument) was specified,\n      | a simplified version of Zeller's Congruence is used to compute the day\n      | of the week.  Note that ridiculous dates will usually return a\n      | \"reasonable\" value (e.g., the 32nd of December will be the day after\n      | the 31st); a zero is returned only if a Gregorian date is supplied\n      | with a month greater than twelve.\n1\n        COB002                                                          Page 2\n-\n        Example 1:  Use JULIAN to convert a date from Gregorian format to\n             Julian format.\n0         cc 1          12\n             /*PASSWORD 020202\n             //DATES    JOB  (BLIND,222NEVER)\n             /*JOBPARM  BIN=1\n             //ASK      EXEC COBUCLG,ULIBDSN='RICE.COBLIB'\n             //COB.SYSIN     DD  *\n                         .\n                          .\n                           .\n                        02 JULIAN-DATE     PIC 9(5).\n                        02 GREGORIAN-DATE  PIC 9(6).\n                         .\n                          .\n                           .\n                        MOVE '022982' TO GREGORIAN-DATE.\n                        MOVE ZEROS TO JULIAN-DATE.\n                        CALL JULIAN USING JULIAN-DATE, GREGORIAN-DATE.\n                         .\n                          .\n                           .\n             //\n-     | Example 2:  Use JULIAN to determine the current date and day of the\n      |      week.\n0     |   cc 1          12\n      |      /*PASSWORD SECRET\n      |      //RAISINS  JOB  (DATES,444FIGS)\n      |      /*JOBPARM  BIN=4\n      |      //CURRENTS EXEC COBUCG,ULIBDSN='RICE.COBLIB'\n      |      //COB.SYSIN  DD *\n      |                  .\n      |                   .\n      |                    .\n      |                 02 JULIAN-DATE      PIC 9(5).\n      |                 02 GREGORIAN-DATE   PIC 9(6).\n      |                 02 DAY-OF-WEEK      PIC 9.\n      |                  .\n      |                   .\n      |                    .\n      |                 MOVE ZEROS TO JULIAN-DATE, GREGORIAN-DATE.\n      |                 CALL JULIAN USING JULIAN-DATE, GREGORIAN-DATE,\n      |                      DAY-OF-WEEK.\n      |                  .\n      |                   .\n      |                    .\n      |      //\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COPYVTOC": {"ttr": 4099, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "COPYVTOC TITLE 'ICSA DISK MAPPER - VTOC COPY ROUTINE'\nCOPYVTOC SAVEX BANNER=YES\n         EJECT\n***********************************************************************\n*                                                                     *\n*        COPYVTOC: COPY VTOC OF VOLUME POINTED TO BY THE FIRST        *\n*                  PARAMETER TO THE SPILL FILE.  PL/I CALLABLE        *\n*                  WITH OPTIONS ASSEM AND RETCODE.  REQUIRES APF      *\n*                  AUTHORIZATION TO ENQ (RESERVE) ON THE VTOC.        *\n*                                                                     *\n*        NOTE:     IF AN I/O ERROR IS ENCOUNTERED READING THE         *\n*                  FORMAT 4 DSCB, THE PROGRAM ABENDS WITH U001.       *\n*                  IF AN I/O ERROR IS ENCOUNTERED READING THE REST    *\n*                  OF THE VTOC, A MESSAGE IS WRITTEN TO THE JOB LOG   *\n*                  INDICATING THAT A TRACK OF THE VTOC WAS SKIPPED    *\n*                  BECAUSE OF AN I/O ERROR AND A RETURN CODE OF 8     *\n*                  IS PASSED BACK TO THE PL/I ROUTINE.                *\n*                                                                     *\n*        PARAMETERS:                                                  *\n*                  1. ADDRESS OF PLI STRUCTURE AS FOLLOWS: (INPUT)    *\n*                     1 VOLUME_ENTRY,                                 *\n*                       2 DDNAME CHAR(8),                             *\n*                       2 VOLSER CHAR(6),                             *\n*                       2 UCB POINTER                                 *\n*                  2. DSCBS_PER_TRACK FIXED BIN(15)        (OUTPUT)   *\n*                  3. VTOC_START FIXED BIN(15)             (OUTPUT)   *\n*                  4. TRACKS_PER_CYLINDER FIXED BIN(15)    (OUTPUT)   *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         XC    RETCODE,RETCODE        ZERO RETURN CODE\n         LR    R11,R1                 SAVE PARM ADDRESS\n         L     R2,0(,R11)\n         L     R2,0(,R2)              R2 -> TABLE ENTRY\n         MVC   VTOCDCB+40(8),0(R2)    MOVE IN DDNAME\n         L     R2,14(,R2)             R2 -> UCB\n         ST    R2,UCBPTR              R2 -> UCB\n         OPEN  (VTOCDCB,INPUT)        OPEN THE VTOC\n         L     R1,VTOCDCB+44          FIND THE DEB\n         SH    R1,=H'15'              LOOK INTO THE PREFIX\n         MVC   IOB+33(7),0(R1)        FIND VTOC SEEK ADDRESS\n         XC    ECB,ECB                CLEAR THE ECB\n         MVC   IOB+16(4),=A(READF4)   POINT TO CCW TO READ FORMAT 4\n         MVI   READKYDA+4,X'00'       MAKE SURE NOT CHAINED\n         EXCP  IOB                    READ THE FORMAT 4\n         WAIT  ECB=ECB                WAIT FOR COMPLETION\n         TM    ECB,X'7F'              DID THE READ GO ALRIGHT?\n         BNO   ABEND                  IF NOT, ABEND U001\n         LA    R3,DSCB                SET UP BASE REGISTER FOR\n         USING FORMAT4,R3             MAPPING THE FORMAT 4\n         LH    R4,DS4VTOCE+2          GET THE FIRST CYLINDER\n         LH    R5,DS4DEVSZ+2          GET DEVICE SIZE (TRKS/CYL)\n         L     R10,12(,R11)           SAVE AS\n         STH   R5,0(,R10)               TRACKS_PER_CYLINDER\n         BCTR  R5,0                   MAKE ZERO ORIGIN\n         STH   R5,TRACKS              SAVE FOR LATER\n         MH    R4,DS4DEVSZ+2          COMPUTE RELATIVE TRACK\n         AH    R4,DS4VTOCE+4            ADDRESS OF BEGINNING OF\n         L     R10,8(,R11)              THE VTOC AND SAVE AS\n         STH   R4,0(,R10)             VTOC_START\n         SR    R5,R5                  CLEAR FOR INSERT\n         IC    R5,DS4DEVDT              OF NUMBER OF DSCBS/TRACK\n         L     R10,4(,R11)            SAVE AS\n         STH   R5,0(,R10)               DSCBS_PER_TRACK\n         LR    R6,R5                  COPY FOR LATER\n         MH    R5,=H'140'             COMPUTE\n         STH   R5,SPILLDCB+62           BLOCKSIZE OF SPILL FILE\n         STH   R5,SPILLDCB+82         SAVE AS LRECL, TOO\n         OPEN  (SPILLDCB,OUTPUT)      OPEN SPILL FILE\n         GETMAIN R,LV=(5)             GET BLOCK BUFFER\n         LR    R10,R1                 SAVE BUFFER ADDRESS\n         LR    R7,R6                  NEED CCW CHAIN OF DSCBS/TRACK\n         LA    R7,3(,R7)                PLUS 3 MORE\n         SLL   R7,3                   MULTIPLY BY 8 TO FIND LENGTH\n         LR    R8,R10                 COPY BUFFER ADDRESS\n         GETMAIN R,LV=(7)             GET SPACE FOR CCW CHAIN\n         LR    R7,R1                  SAVE CCW CHAIN ADDRESS\n         MVC   0(24,R7),READF4        MOVE IN PATTERN CCWS\n         LA    R4,8(,R7)              POINT TO SECOND CCW\n         STCM  R4,B'0111',17(R7)      FIX TIC ADDRESS FOR LOOP\n         LA    R7,24(,R7)             POINT TO READ CHAIN\n         MVI   READKYDA+4,X'40'       SET COMMAND CHAINING BIT\n         LA    R9,CCWBLOOP            SET LOOP ADDRESS\nCCWBLOOP MVC   0(8,R7),READKYDA       FIX UP THE CHAIN\n         STCM  R10,B'0111',1(R7)      STORE ADDRESS FOR READ\n         LA    R10,140(,R10)            AND BUMP TO NEXT DSCB SLOT\n         LA    R7,8(,R7)              BUMP TO NEXT READ CCW\n         BCTR  R6,R9                  AND BUILD ALL THE CCWS\n         S     R7,=F'8'               TURN OFF COMMAND CHAINING\n         MVI   4(R7),X'00'              IN THE LAST CCW\n         ST    R1,IOB+16              SAVE CCW CHAIN POINTERS IN IOB\n         L     R4,0(,R11)             POINT TO THE VOLSER\n         L     R4,0(,R4)                ENTRY IN THE\n         LA    R4,8(,R4)                FIRST PARAMETER STRUCTURE\n         RESERVE (SYSVTOC,(4),E,6,SYSTEMS),UCB=UCBPTR  GRAB THE VTOC\n         LA    R9,RWLOOP              SET LOOP ADDRESS\nRWLOOP   XC    ECB,ECB                CLEAR THE ECB\n         EXCP  IOB                    READ A TRACK OF DSCBS\n         WAIT  ECB=ECB                WAIT FOR COMPLETION\n         TM    ECB,X'7F'              CHECK FOR ALL OK\n         BNO   IOERROR                IF NOT, SEND SKIPPED MESSAGE\n         WRITE SPILL,SF,SPILLDCB,(8),'S'  WRITE A SPILL BLOCK\n         CHECK SPILL                  CHECK FOR COMPLETION\nNXTTRK   LH    R1,IOB+37              POINT TO TRACK ADDRESS\n         CLC   IOB+35(4),DS4VTOCE+6   WAS THIS THE LAST TRACK?\n         BE    QUITREAD               YES, QUIT READING\n         CH    R1,TRACKS              END OF CYLINDER?\n         BE    NEXTCYL                YES, GO TO NEXT CYLINDER\n         LA    R1,1(,R1)              BUMP TO NEXT TRACK\n         STH   R1,IOB+37                AND SAVE IN THE IOB\n         BR    R9                     GO READ NEXT TRACK\n         SPACE 1\nNEXTCYL  XC    IOB+37(2),IOB+37       BUMP TO START OF NEXT CYL\n         LH    R1,IOB+35              UPDATE\n         LA    R1,1(,R1)                CYLINDER COUNTER\n         STH   R1,IOB+35              SAVE IN THE IOB\n         BR    R9                     GO READ NEXT TRACK\n         SPACE 1\nQUITREAD DEQ   (SYSVTOC,(4),6,SYSTEMS)  LET GO OF VTOC\n         CLOSE (VTOCDCB,,SPILLDCB)    CLOSE BOTH FILES\n         L     R15,RETCODE            GET RETURN CODE\n         RETURNX RC=(15)                AND RETURN TO CALLER\n         SPACE 1\nABEND    ABEND 1,DUMP,STEP            COULD NOT READ FORMAT 4\n         SPACE 2\nIOERROR  LH    R1,IOB+35              GET CYLINDER ADDRESS\n         CVD   R1,DOUBLE              CONVERT TO DECIMAL\n         MVC   CYLADDR,PATTERN        MOVE IN EDIT PATTERN\n         ED    CYLADDR,DOUBLE+5         AND EDIT CYL ADDRESS FOR MSG\n         LH    R1,IOB+37              GET TRACK ADDRESS\n         CVD   R1,DOUBLE              CONVERT TO DECIMAL\n         MVC   TRKADDR,PATTERN        MOVE IN EDIT PATTERN\n         ED    TRKADDR,DOUBLE+5         AND EDIT TRK ADDRESS FOR MSG\n         WTO   MF=(E,SKIPMSG)         SEND MESSAGE\n         MVC   RETCODE,=F'8'          SET RETURN CODE TO 8\n         B     NXTTRK                 GO BUMP TRACK POINTER\n         EJECT\n         LTORG\nREADF4   CCW   X'23',SECTOR0,X'40',1  SET SECTOR\n         CCW   X'31',IOB+35,X'40',5   SEARCH ID EQUAL\n         CCW   X'08',READF4+8,0,0     LOOP UNTIL PREV. CCW SUCCEEDS\nREADKYDA CCW   X'0E',DSCB,X'00',140     THEN READ A DSCB\nSECTOR0  DC    X'0'                   USED FOR SET SECTOR\nSYSVTOC  DC    CL8'SYSVTOC'           QNAME FOR VTOC\nECB      DS    A                      ECB FOR EXCP I/O\nIOB      DC    X'42',XL3'0'           IOB\n         DC    A(ECB)                   FOR\n         DC    XL12'0'                    READING\n         DC    A(VTOCDCB)                   THE\n         DC    XL16'0'                        VTOC\nDSCB     DS    CL140                  SPACE FOR THE FORMAT 4\nUCBPTR   DS    A                      POINTER TO THE UCB\nTRACKS   DS    H                      NUMBER OF LAST TRACK ON CYL\nSKIPMSG  WTO   'WARNING: TRACK XXXXXX ON CYLINDER XXXXXX SKIPPED BECAUSX\n               E OF I/O ERROR READING VTOC',                           X\n               ROUTCDE=(11),DESC=(3,7),MF=L\nTRKADDR  EQU   SKIPMSG+19,6           LOCATION FOR TRACK INSERT\nCYLADDR  EQU   SKIPMSG+38,6           LOCATION FOR CYLINDER INSERT\nPATTERN  DC    X'402020202120'        PATTERN FOR EDIT\nDOUBLE   DS    D                      FOR CONVERT TO DECIMAL\nRETCODE  DS    F                      RETURN CODE\n         PUSH  PRINT\n         PRINT NOGEN\nSPILLDCB DCB   DDNAME=SPILL,RECFM=FS,MACRF=(WC),DSORG=PS  SPILL FILE\nVTOCDCB  DCB   MACRF=(E),DSORG=PS,IOBAD=IOB,KEYLEN=44  VTOC TO COPY\n         POP   PRINT\nFORMAT4  DSECT\n         DS    XL44                   KEY\n         IECSDSL1 (4)                 FORMAT 4 DSCB EXPANSION\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DISKUTI$": {"ttr": 4103, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//DISKUTIL PROC  VER=,V=STOREA,U=SYSDA\n//*********************************************************************\n//* DISKUTIL: ICSA DISK UTILITY                                     ***\n//* SEE ICSA DOCUMENT UTL007                                        ***\n//*                                                     8/08/82 ARB ***\n//*********************************************************************\n//UTIL     EXEC  PGM=DISKUTIL,REGION=128K\n//STEPLIB  DD  DSN=RICEPP&VER..LINKLIB,DISP=SHR\n//SYSPRINT DD  SYSOUT=A\n//STOREA   DD  UNIT=SYSDA,VOL=SER=STOREA,DISP=OLD\n//STOREB   DD  UNIT=SYSDA,VOL=SER=STOREB,DISP=OLD\n//STOREC   DD  UNIT=SYSDA,VOL=SER=STOREC,DISP=OLD\n//STORED   DD  UNIT=SYSDA,VOL=SER=STORED,DISP=OLD\n//STOREE   DD  UNIT=SYSDA,VOL=SER=STOREE,DISP=OLD\n//MISC     DD  UNIT=&U,VOL=SER=&V,DISP=OLD\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DISKUTIL": {"ttr": 4105, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "UTIL     TITLE 'ICSA DISK UTILITY -- 28 JUNE 1974'\n*\n*\n*** MACROS ***\n*\n         MACRO\n&L       MSG   &R,&M\n         LCLA  &N\n&N       SETA  K'&M-3\n&L       DC    AL1(&R.,&N),C&M\n         MEND\n*\n         MACRO\n&L       DIAG  &M,&B\n&L       BAL   XRTN,DIAG\n         DC    AL2(&M.-MESSGS,&B.-START)\n         MEND\n*\n         MACRO\n&L       CMD   &M\n         LCLA  &N\n&N       SETA  K'&M-3\n&L       DC    AL1(&N),C&M\n         MEND\n*\n*** REGISTERS ***\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nXRTN     EQU   2\nXLL      EQU   3\nXW1      EQU   4\nXW2      EQU   5\nXW3      EQU   6\nXW4      EQU   7\nXW5      EQU   8\nXW6      EQU   9\nXB1      EQU   10\nXB2      EQU   11\nXB3      EQU   12\nXSV      EQU   13\n*\nSPACE1   EQU   1                           PRINTER CONTROL CHARS\nSPACE2   EQU   2\nPAGE     EQU   4\n         EJECT\n*\n*** STARTUP ROUTINE ***\n*\nUTILITY  CSECT\nSTART    STM   R14,R12,12(R13)\n         LR    XW1,XSV\n         USING START,15\n         LM    XB1,XB3,BASES\n         DROP  15\n         USING START,XB1,XB2,XB3\n         LA    XSV,OSSAVE\n         ST    XSV,8(0,XW1)\n         ST    XW1,4(0,XSV)\n         OPEN  (INDCB,(INPUT),OUTDCB,(OUTPUT))\n         TIME  DEC\n         ST    R1,NUMBUF\n         MVC   PGHDDT(7),=X'4021204B202020'\n         ED    PGHDDT(7),NUMBUF+1\n         ST    R0,NUMBUF\n         MVC   PGHDTM(9),=X'4021207A20207A2020'\n         ED    PGHDTM(9),NUMBUF\n         MVI   PRTBFC,C' '\n         MVC   PRTBFN(LINESZ),PRTBFC\n         MVI   SPACESW,PAGE\n         BAL   XRTN,PRINTA              PRINT THE PAGE HEADER\n         GETMAIN R,LV=100*10      GET SPACE FOR TABLE         *RS79.124\n         ST    R1,UCBTABLE        SAVE LOCATION OF TABLE      *RS79.124\n         LR    R3,R1                                          *RS79.124\n         LA    R6,2(,R3)                                      *RS79.124\n         LR    R4,R3                                          *RS79.124\n         SR    R5,R5                                          *RS79.124\n         L     R2,16              FIND CVT                    *RS79.124\n         L     R2,40(,R2)         FIND UCB TABLE              *RS79.124\nULOOP    LH    R3,0(,R2)          GET UCB ADDRESS             *RS79.124\n         LTR   R3,R3              SKIP ZERO ENTRIES           *RS79.124\n         BZ    EULOOP                                         *RS79.124\n         CLI   18(R3),X'20'       IS THIS A DASD?             *RS79.124\n         BNE   EULOOP             NO, SKIP THIS UCB           *RS79.124\n         LR    R7,R6\n         LTR   R5,R5              IS THIS THE FIRST TIME?     *RS79.124\n         BZ    FIRST              YES, SKIP DUPLICATE LOOK    *RS79.124\n         LR    R8,R5                                          *RS79.124\nOLDLOOP  CLC   0(6,R7),28(R3)     HAVE WE SEEN THIS VOL?      *RS79.124\n         BE    EULOOP             YES, DONT ADD IT AGAIN      *RS79.124\n         LA    R7,10(,R7)                                     *RS79.128\n         BCT   R8,OLDLOOP         LOOK THROUGH WHOLE TABLE    *RS79.124\nFIRST    MVC   6(4,R7),16(R3)     BEFORE INSERTING            *RS79.124\n         MVC   0(6,R7),28(R3)     VOLSER AND UCBTYP           *RS79.124\n         LA    R5,1(,R5)          INCREMENT VOLUME COUNT      *RS79.124\nEULOOP   LA    R2,2(,R2)          NEXT UCB ADDRESS            *RS79.124\n         CLC   0(2,R2),=X'FFFF'   END OF LIST                 *79.124\n         BNE   ULOOP              NO, CONTINUE                *RS79.124\n         STH   R5,0(,R4)          YES, SAVE COUNT             *RS79.124\nSTART1   MVI   DEFSW,X'01'\n         MVC   DEFLEN(2),=AL2(VOLNO*18+3)                     *AB78.129\n         MVC   DEFVOL(VOLNO*12+2),PUBVOL\n         B     CCMNXT\nBASES    DC    A(START,START+4096,START+8192)\nNUMBUF   DS    D\nOSSAVE   DS    18F\nUCBTABLE DS    A         ADDRESS OF VOLSER/UCBTYP TABLE       *RS79.124\nRETCODE  DC    H'0'\nRETCODE1 DC    H'0'\nRETCODE2 DC    H'0'\n*\n*** TERMINATION ROUTINE ***\n*\nSTOP     LH    XW1,RETCODE\n         LTR   XW1,XW1\n         BZ    STOPA\n         MVI   SPACESW,SPACE2              SET TO DOUBLE SPACE FOR MSG\n         MVC   PRTBFN(58),=CL58'*** ERRORS OCCURED IN PROCESSING, HIGHEX\n               ST RETURN CODE WAS'\n         MVC   PRTBFN+59(3),=XL3'202021'   MOVE IN THE EDIT CODE\n         CVD   XW1,NUMBUF          GET THE RETURN CODE IN PACKED DEC\n         ED    PRTBFN+58(4),NUMBUF+6   EDIT THE NUMBER IN\n         BAL   XRTN,PRINTA\nSTOPA    CLOSE (INDCB,,OUTDCB)\n         LR    R15,XW1\n         L     XSV,4(0,XSV)\n         LM    R2,R12,28(XSV)\n         L     R14,12(XSV)\n         BR    R14\n         EJECT\n*\n*** PRINT A LINE ***\n*\nPRINT    AP    LINENO(2),=P'1'\n         MVC   PRTBFN(3),=X'202020'\n         ED    PRTBFC(4),LINENO\nPRINTA   ST    XRTN,PRINTSV\n         L     R2,LINECT\n         CLI   SPACESW,PAGE\n         BE    PRTNPG\n         CLI   SPACESW,SPACE1\n         BNE   PRINTC\n         MVI   PRTBFC,C'0'\nPRINTB   BCT   R2,PRTNSP\n         B     PRTNPG\nPRINTC   CLI   SPACESW,SPACE2\n         BNE   PRTNSP\n         MVI   PRTBFC,C'-'\n         BCT   R2,PRINTB\n         B     PRTNPG\nPRTNSP   BCT   R2,PRTABF\nPRTNPG   MVC   PGHDPG#(3),=X'202021'\n         AP    PAGENO(2),=P'1'\n         ED    PGHDPG#-1(4),PAGENO\n         PUT   OUTDCB,PGHEAD\n         MVI   PRTBFC,C'0'\n         LA    R2,PAGESZ\nPRTABF   ST    R2,LINECT\n         PUT   OUTDCB,PRTBFC\n         MVI   PRTBFC,C' '\n         MVC   PRTBFN(LINESZ),PRTBFC\n         MVI   SPACESW,0\n         L     XRTN,PRINTSV\n         BR    XRTN\n*\n*** PRINT WORKAREA ***\n*\nPRINTSV  DS    A\nPRINTSZ  EQU   121\nPRTBFC   DS    CL1\nPRTBFN   DS    CL5\nPRTBUF   DS    (PRINTSZ-6)C\nPRTBUFE  EQU   *\nLINESZ   EQU   *-PRTBFN\nPGHEAD   DC    C'1ICSA DISK UTILITY',CL30' '\nPGHDDT   DC    X'4021204B202020',CL5' '\nPGHDTM   DC    X'4021207A20207A2020'\nPGHDCNT  EQU   PRINTSZ-8+PGHEAD-*\n         DC    (PGHDCNT)C' '\n         DC    CL5'PAGE '\nPGHDPG#  DC    XL3'000000'\nPGHDSZ   EQU   *-PGHEAD\n*\nPAGENO   DC    PL2'0'\nLINENO   DC    PL2'0'\n*\nLINECT   DC    F'1'\nPAGESZ   EQU   55\nSPACESW  DC    AL1(PAGE)\n         EJECT\n*\n*** DIAG PRINTER ***\n*\nDIAG     STM   R13,R2,DIAGSV\n         MVC   PRTBFN(13),ERRMSG\n         LH    R1,0(0,XRTN)\n         A     R1,=A(MESSGS)\n         MVC   *+7(1),1(R1)\n         MVC   PRTBUF+11(*-*),2(R1)\n         SR    R0,R0               PICK UP NEW RETURN CODE\n         IC    R0,0(R1)\n         LTR   R0,R0                                          *RS79.127\n         BNZ   NOTWARN                                        *RS79.127\n         MVC   PRTBFN(13),WARNMSG                             *RS79.127\nNOTWARN  EQU   *                                              *RS79.127\n         CH    R0,RETCODE          COMPARE WITH OLD ONE\n         BNH   *+8                 BIF NEW SMALLER THAN OLD\n         STH   R0,RETCODE          SET RETURN CODE FOR JOB STEP\n         CH    R0,RETCODE1         COMPARE WITH OLD ONE FOR THIS INST\n         BNH   *+8                 BIF NEW SMALLER THAN OLD\n         STH   R0,RETCODE1         SET RETURN CODE FOT THIS INSTRUCTION\nDIAG1    BAL   XRTN,PRINTA\n         LM    R13,R2,DIAGSV\n         LH    XRTN,2(0,XRTN)\n         B     START(XRTN)\n*\n*** DIAG PRINTER WORKAREA ***\n*\nDIAGSV   DS    6F\nERRMSG   DC    C'*** ERROR ***'\nWARNMSG  DC    C'***WARNING***'\nMESSGS   EQU   *\nCNFMSG   MSG   16,'COMMAND NOT FOUND'\nILSMSG   MSG   16,'ILLEGAL COMMAND SYNTAX'\nINDXMSG1 MSG    4,'NOT CATALOGED: DATA SET NAME IS AN INDEX STRUCTURE' *\n                                                              *KP78.137\nINDXMSG2 MSG    4,'NOT CATALOGED: INDEX STRUCTURE IMPOSSIBLE' *KP78.137\nTCMSG    MSG   12,'TOO MANY CONTINUATION CARDS'\nDEVMSG   MSG   16,'DEVICE TYPE NOT FOUND'\nTVMSG    MSG   12,'TOO MANY VOLUMES SPECIFIED'\nDSNMSG   MSG   16,'DSNAME ILLEGAL SYNTAX'\nMULMSG   MSG   12,'MULTIPLE VOLUME DATA SETS NOT SUPPORTED'\nPIOERR1  MSG   20,'PERMANENT I/O ERROR'\nPROGERR  MSG   20,'PROGRAM ERROR - SEE SYSTEM PROGRAMMER'\nDSNFMSGC MSG   4,'DATA SET NOT FOUND IN CATALOG'\nVNMTMSG  MSG   8,'VOLUME NOT MOUNTED: XXXXXX'\nVNMTMSGA EQU   *-6\nGDGMSG   MSG   8,'BAD GENERATION DATA GROUP NAME'\nCFULMSG  MSG   20,'CATALOG IS FULL'\nCVLMSG   MSG   8,'REQUIRED CONTROL VOLUME NOT MOUNTED'\nPSWDMSG  MSG   8,'INCORRECT PASSWORD SUPPLIED FOR DATASET ON XXXXXX'\nPSWDMSGA EQU   *-6\nEXPMSG   MSG   8,'DATA SET NOT EXPIRED ON XXXXXX'\nEXPMSGA  EQU   *-6\nPIOERR2  MSG   20,'PERMANENT I/O ERROR ON XXXXXX'\nPIOERR2A EQU   *-6\nDSNFMSG  MSG   4,'DATASET NOT FOUND ON ANY VOLUMES SEARCHED'\nNRENMSG  MSG   4,'DATASET NOT RENAMED ON ANY VOLUMES SEARCHED'\nDUPMSG   MSG   8,'NEW DATASET NAME ALREADY EXISTS ON XXXXXX'\nDUPMSGA  EQU   *-6\nDSNIMSG1 MSG   8,'DATASET CURRENTLY IN USE'\nCATUSED  MSG    4,'DSNAME ALREADY CATALOGED ON XXXXXX'     *FD78.045\nASVMSG   MSG   0,'XXXXXX ASSUMED TO BE 3330'                  *RS79.127\n         EJECT\n*\n*** CONTROL COMMAND SCANNER ***\n*\nCCMNXT   LH    XW1,RETCODE         PICK UP RETURN CODE\n         CH    XW1,STOPCODE        COMPARE WITH STOP VALUE\n         BNL   STOP                STOP IF GREATER THAN OR EQUAL\n         MVC   RETCODE2(2),RETCODE1\n         XC    RETCODE1(2),RETCODE1\n         BAL   XRTN,GETCM\n         BAL   XRTN,SKIPB\n         BE    CCMNXT         BIF CARD BLANK\n         LA    XW1,CCMNAM\n         LA    XW2,CCMADDR\n         SR    XW3,XW3\nCCMA     TM    0(XW1),X'80'\n         BO    CCMNOTFD\n         IC    XW3,0(0,XW1)   PICK UP LENGTH\n         STC   XW3,*+5\n         CLC   1(*-*,XW1),0(XLL)\n         BE    CCMB\n         LA    XW1,2(XW3,XW1)\n         LA    XW2,4(0,XW2)\n         B     CCMA\nCCMB     LA    XLL,0(XW3,XLL)\nCCMC     CLI   1(XLL),C' '\n         LA    XLL,1(0,XLL)\n         BNE   CCMC\n         BAL   XRTN,SKIPB\n         L     XW2,0(0,XW2)\n         B     0(0,XW2)\nCCMNOTFD DIAG  CNFMSG,CCMNXT\nCCMILS   DIAG  ILSMSG,CCMNXT\n*\n*** COMMAND TABLES ***\n*\nCCMNAM   EQU   *\n         CMD   'CAT'\n         CMD   'UNC'\n         CMD   'DEL'\n         CMD   'QUA'\n         CMD   'STO'\n         CMD   'REN'\n         CMD   'SEA'\n         CMD   'CVO'\n         CMD   'NOT'                                          *RS79.127\n         DC    X'80'\nCCMADDR  DC    A(CATLG,UNCAT,DELETE,QUALIFY,STOPCMD)\n         DC    A(RENAME,DEFAULT,CVOL,CCMNXT)                  *RS79.127\n*\n*** SKIP BLANKS ***\n*\nSKIPB    CLI   0(XLL),C' '\n         BCR   7,XRTN\n         LA    XLL,1(0,XLL)\n         CL    XLL,=A(CDEND)\n         BNH   SKIPB\n         SR    XLL,XLL\n         BR    XRTN\n*\n*** GET NEXT CHARACTER ***\n*\nNCH      LA    XLL,1(0,XLL)\n         CL    XLL,=A(CDEND)\n         BCR   13,XRTN\n         B     CCMILS                                         *RS79.129\n         EJECT\n*\n*** GET COMMAND CARD ***\n*\nGETCM    STM   R13,R2,GETSV\n         MVI   CDBUF,C' '\n         MVC   CDBUF+1(256),CDBUF\n         MVC   CDBUF+257(256),CDBUF+256\n         GET   INDCB\n         LR    XW6,R1\n         MVC   PRTBUF(80),0(XW6)\n         MVI   SPACESW,SPACE1\n         BAL   XRTN,PRINT\n         LA    XW4,CDBUF\nGETA     SR    XW3,XW3\n         LR    XW1,XW6\n         LA    XW2,72(0,0)\nGETB     CLC   0(3,XW1),=C' - '                               *RS79.127\n         BNE   GETC\n         MVI   GETFLG,X'80'\n         B     GETD\nGETC     LA    XW3,1(0,XW3)\n         LA    XW1,1(0,XW1)\n         BCT   XW2,GETB\n         BCTR  XW3,0\nGETD     LA    XW5,0(XW3,XW4)\n         CL    XW5,=A(CDEND)\n         BH    TOOLONG\n         STC   XW3,*+5\n         MVC   0(*-*,XW4),0(XW6)\n         LR    XW4,XW5\n         TM    GETFLG,X'80'\n         BZ    GETRET\n         GET   INDCB\n         LR    XW6,R1\n         MVC   PRTBUF(80),0(XW6)\n         BAL   XRTN,PRINTA\n         MVI   GETFLG,0\n         B     GETA\nGETRET   LA    XLL,CDBUF\n         SR    R1,R1\n         LM    R13,R2,GETSV\n         BR    XRTN\nTOOLONG  DIAG  TCMSG,CCMNXT\nGETSV    DS    7F\nGETFLG   DC    X'00'\nCDBUF    DS    512C\nCDEND    DS    X\n         EJECT\n*\n*** VOLUME LIST PARSER ***\n*\nVLIST    STM   XSV,XRTN,VLISTSV1\n         STM   XW1,XW6,VLISTSV2\n         BAL   XRTN,SKIPB\n         BE    CCMILS\n         SR    XW1,XW1\n         LA    XW2,VOLIST+2\n         USING VENTRY,XW2\n         CLI   0(XLL),C'('\n         BE    VLISTA\n         BAL   XRTN,DOVOL\nVLOUT    STH   XW1,VOLIST\n         S     XW2,=A(VOLIST+1)                               *AB78.129\n         STH   XW2,VOLEN                                      *AB78.129\n         LM    XSV,XRTN,VLISTSV1\n         LM    XW1,XW6,VLISTSV2\n         BR    XRTN\nVLISTA   BAL   XRTN,NCH\nVLISTB   BAL   XRTN,SKIPB\n         BE    CCMILS\n         BAL   XRTN,DOVOL\n         BAL   XRTN,SKIPB\n         BE    CCMILS\n         CLI   0(XLL),C')'\n         BE    VLOUTA\n         CLI   0(XLL),C','\n         BE    VLISTA\n         B     VLISTB\nVLOUTA   BAL   XRTN,NCH\n         B     VLOUT\nVOLOVER  DIAG  TVMSG,CCMNXT\n*\nVOLNO    EQU   (256-4)/18         MAX NUMBER OF VOLUMES       *AB78.129\nVLISTSV1 DS    6A\nVLISTSV2 DS    6A\nVOLEN    DC    H'0'\nVOLIST   DS    H\n         DS    (VOLNO)XL12\nVOLIMIT  DC    AL2(VOLNO)\n*\n*** VOLUME TABLE ENTRY DSECT ***\n*\nVENTRY   DSECT\nVTYPE    DS    XL4\nVSER     DS    CL6\nVSEQ     DS    XL2\nUTILITY  CSECT\n         EJECT\n*\n*** VOLUME ENTRY PARSER ***\n*\nDOVOL    ST    XRTN,DOVOLSV\n         MVC   VSEQ(2),=H'0'\n         MVC   VSER(6),BLANKS\n         LA    XW3,6(0,0)\n         LA    XW4,VSER\nDOVOLA   CLI   0(XLL),C'@'\n         BE    DOVOLA1\n         CLI   0(XLL),C'#'\n         BE    DOVOLA1\n         CLI   0(XLL),C'$'\n         BE    DOVOLA1\n         CLI   0(XLL),C'A'\n         BL    DOVOLB\nDOVOLA1  MVC   0(1,XW4),0(XLL)\n         BAL   XRTN,NCH\n         LA    XW4,1(0,XW4)\n         BCT   XW3,DOVOLA\nDOVOLB   CLI   0(XLL),C'/'                                    *AB78.128\n         BE    DOVOLD\n         CLC   VSER(6),=C'PUBLIC'\n         BNE   DOVOLB1\n         LH    XW3,PUBVOL               GET NUMBER OF PUBLIC VOLUMES\n         LA    XW4,PUBVOL+2\nDOPUB    MVC   0(12,XW2),0(XW4)\n         LA    XW4,12(0,XW4)\n         LA    XW2,12(0,XW2)\n         LA    XW1,1(0,XW1)\n         CH    XW1,VOLIMIT\n         BH    VOLOVER\n         BCT   XW3,DOPUB\n         L     XRTN,DOVOLSV\n         BR    XRTN\nDOVOLB1  MVC   VTYPE(4),STDVOL\n         L     XW3,UCBTABLE       FIND VOLSER/UCBTYP TABLE    *RS79.124\n         LH    XW4,0(,XW3)        NUMBER OF KNOWN VOLUMES     *RS79.124\n         LA    XW3,2(,XW3)        POINT TO FIRST ENTRY        *RS79.124\nUCBLOOP  CLC   0(6,XW3),VSER      THIS VOLUME?                *RS79.124\n         BNE   NOTUCB             NO, TRY NEXT ENTRY          *RS79.124\n         MVC   VTYPE,6(XW3)       YES, INSERT UCBTYP INFO     *RS79.124\n         B     DOVOLB2            AND CONTINUE                *RS79.124\nNOTUCB   LA    XW3,10(,XW3)       SKIP TO NEXT ENTRY          *RS79.124\n         BCT   XW4,UCBLOOP                                    *RS79.124\n         MVC   ASVMSG+2(6),VSER   INSERT VOLSER               *RS79.124\n         DIAG  ASVMSG,DOVOLB2     ASSUME 3330 WARNING MESSAGE *RS79.124\nDOVOLB2  LA    XW2,12(0,XW2)\n         LA    XW1,1(0,XW1)\n         CH    XW1,VOLIMIT\n         BH    VOLOVER\n         CLI   0(XLL),C' '        CHECK FOR PROPER DELIMITER  *RS79.129\n         BE    VOLRTN             *RS79.129\n         CLI   0(XLL),C','                                    *RS79.129\n         BE    VOLRTN                                         *RS79.129\n         CLI   0(XLL),C')'                                    *RS79.129\n         BNE   CCMILS             ELSE INV. CMD. SYNTAX       *RS79.129\nVOLRTN   L     XRTN,DOVOLSV                                   *RS79.129\n         BR    XRTN\nDOVOLD   BAL   XRTN,NCH\n         LR    XW3,XLL\n         BAL   XRTN,NCH\n         BAL   XRTN,NCH\n         BAL   XRTN,NCH\n         BAL   XRTN,NCH\n         LA    XW4,DOVOLTP\nDOVOLE   CLC   0(4,XW3),0(XW4)\n         BE    DOVOLF\n         LA    XW4,8(0,XW4)\n         CLC   0(4,XW4),=F'0'\n         BNE   DOVOLE\nBADUNIT  DIAG  DEVMSG,CCMNXT\nDOVOLF   TM    4(XW4),X'FF'       IS THIS A POINTER ENTRY?    *RS79.124\n         BO    DOVOLSUB           YES, CHECK SUBTABLES        *RS79.124\nNOVOLSUB MVC   VTYPE,4(XW4)       INSERT UCBTYP FROM TABLE    *RS79.124\n         B     DOVOLB2            AND CONTINUE                *RS79.124\n         SPACE\nDOVOLSUB L     XW4,4(,XW4)        FIND SUBTABLE               *RS79.124\n         CLI   0(XLL),C'-'        MODEL SPECIFIED?            *RS79.124\n         BNE   NOVOLSUB           NO, TAKE DEFAULT            *RS79.124\n         BAL   XRTN,NCH           MOVE OVER ONE               *RS79.124\nNEXTSUB  LH    XW3,0(,XW4)        FIND COMPARE LENGTH         *RS79.127\n         EX    XW3,CHKSUB         COMPARE MODEL NUMBER        *RS79.124\n         BNE   BUMPSUB            IF EQUAL GO MOVE POINTER    *RS79.128\n         LA    XW3,1(,XW3)        CORRECT COUNT               *RS79.128\nENDMODEL BAL   XRTN,NCH           MOVE PAST MODEL CHARS       *RS79.128\n         BCT   XW3,ENDMODEL                                   *RS79.128\n         CLI   0(XLL),C' '        MAKE SURE DELIMITER CORRECT *RS79.129\n         BE    NOVOLSUB                                       *RS79.129\n         CLI   0(XLL),C','                                    *RS79.129\n         BE    NOVOLSUB                                       *RS79.129\n         CLI   0(XLL),C')'                                    *RS79.129\n         BNE   BADUNIT            ELSE INVALID DEVICE TYPE    *RS79.129\n         B     NOVOLSUB           THEN CONTINUE PROCESSING    *RS79.128\nBUMPSUB  LA    XW4,8(,XW4)        ELSE TRY NEXT ENTRY         *RS79.124\n         CLC   0(4,XW4),=F'0'     (IF ANY)                    *RS79.124\n         BNE   NEXTSUB                                        *RS79.127\n         B     BADUNIT            IF NONE, IT'S UNKNOWN       *RS79.124\n         SPACE\nCHKSUB   CLC   2(*-*,XW4),0(XLL)                              *RS79.127\n         DROP  XW2\n*\n*** VOLUME TYPE TABLES ***\n*\nDOVOLSV  DS    A\nDOVOLTP  DC    CL4'2301',X'30402002'\n         DC    CL4'2302',XL4'30002004'\n         DC    CL4'2303',XL4'30002003'\n         DC    CL4'2311',XL4'30002001'\n         DC    CL4'2314',XL4'30C02008'\n         DC    CL4'2321',XL4'30002005'\n         DC    CL4'2305',X'FF',AL3(SUB2305)                   *RS79.124\n         DC    CL4'3330',X'FF',AL3(SUB3330)                   *RS79.127\n         DC    CL4'3350',XL4'3050200B'                        *RS79.124\n         DC    XL4'00000000'\nSTDVOL   DC    XL4'30502009'\n         SPACE\nSUB2305  DC    H'0',C'1 ',X'30502006'                         *RS79.124\n         DC    H'0',C'2 ',X'30502007'                         *RS79.124\n         DC    XL4'0'                                         *RS79.124\nSUB3330  DC    H'0',C'  ',X'30502009'                         *RS79.129\n         DC    H'0',C'1 ',X'3050200D'                         *RS79.129\n         DC    XL4'0'                                         *RS79.124\nBLANKS   DC    CL8' '\n*\n*** DEFAULT PUBLIC VOLUME TABLE ***\n*\nPUBNO    EQU   5                                              *BA82.202\nPUBVOL   DC    AL2(PUBNO)\n         DC    XL4'3050200B',CL6'STOREA',H'0'                 *BA82.202\n         DC    XL4'3050200B',CL6'STOREB',H'0'                 *BA82.202\n         DC    XL4'3050200B',CL6'STOREC',H'0'                 *BA82.202\n         DC    XL4'3050200B',CL6'STORED',H'0'                 *BA82.202\n         DC    XL4'3050200B',CL6'STOREE',H'0'                 *BA82.202\n         DC    XL4'3050200B',CL6'STOREF',H'0'                 *BA82.202\n         DC    (VOLNO-6)XL12'00'   SPACE FOR ZAPPING IN VOLUMES\n         EJECT\n*\n*** DCB ENTRIES ***\n*\nPRTBSZ   EQU   PRINTSZ*6\nOUTDCB   DCB   BFTEK=S,BLKSIZE=PRTBSZ,DDNAME=SYSPRINT,                 X\n               LRECL=PRINTSZ,MACRF=PM,RECFM=FBSA,DSORG=PS\nINDCB    DCB   BFTEK=S,DDNAME=SYSIN,DEVD=DA,DSORG=PS,LRECL=80,         X\n               EODAD=STOP,MACRF=GL\n         EJECT\n*\n*** LIST VOLUMES ROUTINE ***\n*\nLVOL     STM   XRTN,XW3,LVOLSV     SAVE REGISTERS\n         LH    XW1,VOLIST\n         LA    XW2,VOLIST+2\n         USING VENTRY,XW2\nLVOLA    MVC   0(6,XW3),VSER       MOVE IN VOLUME NAME\n         LA    XW2,12(0,XW2)       SKIP TO NEXT VENTRY\n         LA    XW3,7(0,XW3)        SKIP TO NEWT POSITION IN OUTPUT LINE\n         C     XW3,=A(PRTBUFE)     CHECK IF OFF END OF PRINT BUFFER\n         BH    LVOLC               BIF SO\n         BCT   XW1,LVOLA\n         BAL   XRTN,PRINTA\nLVOLB    LM    XRTN,XW3,LVOLSV\n         BR    XRTN\nLVOLC    BAL   XRTN,PRINTA         PRINT THE CURRENT LINE\n         LA    XW3,PRTBUF+10       INDENT 10 SPACES FOR SECOND LINE\n         BCT   XW1,LVOLA           DO NEXT VENTRY\n         B     LVOLB               ELSE EXIT\nLVOLSV   DS    5A\n*\n*** DSNAME LIST ROUTINE ***\n*\nDSNLIST  LH    XW1,DSNLEN          PICK UP DSN LENGTH\n         STC   XW1,*+5             STORE IT IN MOVE INST\n         MVC   PRTBUF(*-*),DSNBUF\n         B     PRINTA              PRINT IT AND RETURN\n*\n*** LIST CONTROL VOLUME ROUTINE ***\n*\nCVOLIST  TM    CVOLSW,X'01'        CHECK FOR COL SPECIFIED\n         BCR   8,XRTN              RETURN IF NOT(CC=0)\n         MVC   PRTBUF+5(6),=C'CVOL ='    MOVE IN MESSAGE\n         MVC   PRTBUF+12(6),CVOLBUF\n         B     PRINTA\n*\n*** SEARCH VOL SER LIST ***\n*\nSVSERL   MVC   PRTBUF(20),=C'SEARCH VOL SER NOS =' MOVE IN MESSAGE\n         LA    XW3,PRTBUF+21       LOAD ADDR OF FIRST VOL IN LIST\n         B     LVOL                LIST VOLUMES\n*\n*** VOL SER LIST ROUTINE ***\n*\nVSERL    MVC   PRTBUF(13),=C'VOL SER NOS =' MOVE IN MESSAGE\n         LA    XW3,PRTBUF+14       LOAD ADDR OF FIRST VOL IN LIST\n         B     LVOL                LIST VOLUMES\n         EJECT\n*\n*** DSNAME PARSER ***\n*\nDSNAM    STM   XSV,XRTN,DSNSV1\n         STM   XW1,XW6,DSNSV2\n         TM    QUALFLG,X'04'\n         BO    DSNA3\n         CLC   0(2,XLL),=C'* '\n         BNE   DSNA2\n         MVC   DSNBUF(46),DSN1\nDSNA1    BAL   XRTN,NCH\n         L     XRTN,DSNSV1+20\n         BR    XRTN\nDSNA2    CLC   0(3,XLL),=C'** '\n         BNE   DSNA3\n         BAL   XRTN,NCH\n         MVC   DSNBUF(46),DSN2\n         B     DSNA1\nDSNA3    MVI   DSNSW,0\n         MVI   DSNBUF,C' '\n         MVC   DSNBUF+1(43),DSNBUF\n         LA    XW1,44(0,0)\n         LA    XW2,DSNBUF\n         CLI   0(XLL),C''''\n         BE    DSND\n         CLI   0(XLL),C'\"'\n         BE    DSND\n         TM    QUALFLG,X'01'\n         BZ    DSNE\n         TM    QUALFLG,X'04'\n         BO    DSNE\n         LH    XW3,QUAL1L\n         SR    XW1,XW3\n         BCTR  XW1,0\n         BCTR  XW1,0\n         LTR   XW1,XW1\n         BNM   DSNC\n         B     DSNBAD\nDSNC     STC   XW3,*+5\n         MVC   DSNBUF(*-*),QUAL1\n         LA    XW2,1(XW3,XW2)\n         MVI   0(XW2),C'.'\n         LA    XW2,1(0,XW2)\n         B     DSNE\nDSND     BAL   XRTN,NCH\nDSNE     LA    XW4,9(0,0)\n         CLI   0(XLL),C'Z'\n         BH    DSNBAD\nDSNF     CLI   0(XLL),C''''\n         BE    DSNJ\n         CLI   0(XLL),C'\"'\n         BE    DSNJ\n         CLI   0(XLL),C' '\n         BE    DSNK\n         CLI   0(XLL),C'/'\n         BE    DSNK\n         CLI   0(XLL),C'('\n         BE    DSNL\n         CLI   0(XLL),C'.'\n         BE    DSNI\n         CLI   0(XLL),C'$'\n         BE    DSNG\n         CLI   0(XLL),C'@'\n         BE    DSNG\n         CLI   0(XLL),C'#'\n         BE    DSNG\n         CLI   0(XLL),C'A'\n         BL    CCMILS\nDSNG     MVC   0(1,XW2),0(XLL)\n         BAL   XRTN,NCH\n         LA    XW2,1(0,XW2)\n         BCT   XW4,DSNH\nDSNBAD   DIAG  DSNMSG,CCMNXT\nDSNH     BCT   XW1,DSNF\n         B     DSNBAD\nDSNI     MVI   0(XW2),C'.'\n         LA    XW2,1(0,XW2)\n         BAL   XRTN,NCH\n         CH    XW4,=H'9'\n         BNL   DSNBAD\n         BCT   XW1,DSNE\n         B     DSNBAD\nDSNJ     BAL   XRTN,NCH\n         B     DSNOUT\nDSNK     TM    QUALFLG,X'02'\n         BZ    DSNOUT\n         CLI   QUAL2,C'('\n         BE    DSNK1\n         MVI   0(XW2),C'.'\n         BCTR  XW1,0\n         LA    XW2,1(0,XW2)\nDSNK1    LH    XW3,QUAL2L\n         SR    XW1,XW3\n         BCTR  XW1,0\n         LTR   XW1,XW1\n         BM    DSNBAD\n         STC   XW3,*+5\n         MVC   0(*-*,XW2),QUAL2\n         LA    XW2,1(XW2,XW3)              SKIP OVER POSTQUALIFIER\nDSNOUT   S     XW2,=A(DSNBUF+1)\n         STH   XW2,DSNLEN\n         TM    QUALFLG,X'04'\n         BO    DSNOUT1\n         MVC   DSN2(46),DSN1\n         MVC   DSN1(46),DSNBUF\nDSNOUT1  LM    XSV,XRTN,DSNSV1\n         LM    XW1,XW6,DSNSV2\n         BR    XRTN\n*\nDSNL     TM    DSNSW,X'01'\n         BO    DSNBAD\n         MVC   GENBUF+1(7),BLANKS\n         MVI   GENBUF,C'('\n         BAL   XRTN,NCH\n         LA    XW5,GENBUF+1\n         LA    XW6,7(0,0)\n         CLI   0(XLL),C')'\n         BE    DSNBAD\n         CLI   0(XLL),C'+'\n         BE    DSNN\n         CLI   0(XLL),C'-'\n         BE    DSNN\nDSNM     CLI   0(XLL),C')'\n         BE    DSNO\n         CLI   0(XLL),C'0'\n         BL    DSNBAD\nDSNN     MVC   0(1,XW5),0(XLL)\n         BAL   XRTN,NCH\n         LA    XW5,1(0,XW5)\n         BCT   XW6,DSNM\n         B     DSNBAD\nDSNO     MVI   0(XW5),C')'\n         BAL   XRTN,NCH\n         MVI   DSNSW,X'01'\n         S     XW5,=A(GENBUF+1)\n         STH   XW5,GENLEN\n         B     DSNF\n*\n*** DSNAME WORKAREAS ***\n*\nDSNSV1   DS    6A\nDSNSV2   DS    6A\nGENLEN   DC    H'0'\nGENBUF   DC    CL8' '\nDSN1     DC    CL44' '\nDSN1L    DC    H'0'\nDSN2     DC    CL44' '\nDSN2L    DC    H'0'\nDSNBUF   DC    CL44' '\nDSNLEN   DC    H'0'\nQUAL1    DC    CL44' '\nQUAL1L   DC    H'0'\nQUAL2    DC    CL44' '\nQUAL2L   DC    H'0'\nQUALFLG  DC    X'00'\nDSNSW    DC    X'00'\n         EJECT\n*\n*** FIX UP GENERATION DATA GROUPS ***\n*\nFIXGEN   STM   XSV,XRTN,DSNSV1\n         STM   XW1,XW6,DSNSV2\n         LH    XW1,DSNLEN\n         A     XW1,=A(DSNBUF+1)\n         LH    XW2,GENLEN\n         STC   XW2,*+5\n         MVC   0(*-*,XW1),GENBUF\n         LOCATE FIXCAM\n         BAL   XRTN,LOCCHK\n         LA    XW1,DSNBUF+43\n         LA    XW2,43(0,0)\nFIXA     CLI   0(XW1),C' '\n         BNE   FIXB\n         BCTR  XW1,0\n         BCT   XW2,FIXA\n         B     DSNBAD\nFIXB     STH   XW2,DSNLEN\n         MVC   DSN1(46),DSNBUF\n         LM    XSV,XRTN,DSNSV1\n         LM    XW1,XW6,DSNSV2\n         BR    XRTN\nFIXCAM   CAMLST NAME,DSNBUF,,LOCAREA\n         DS    0D\nLOCAREA  DS    265X\n         EJECT\n*\n*** DEFAULT PROCESSOR ***\n*\nDEFAULT  BE    START1\n         CLI   0(XLL),C'O'         IS IT ON VOLIST\n         BNE   DEFA                BIF NOT ELSE SKIP TO NEXT BLANK OR (\nDEFX     BAL   XRTN,NCH            SKIP OVER THE O\n         CLI   0(XLL),C' '         IS IT A BLANK?\n         BE    DEFY                BIF YES\n         CLI   0(XLL),C'('         IS IT AN OPEN PAREN?\n         BNE   DEFX                SKIP OVER IT IF NOT\nDEFY     BAL   XRTN,VLIST          GO PARSE THE VOLUME LIST\n         LH    XW1,VOLEN\n         STH   XW1,DEFLEN\n         STC   XW1,*+5\n         MVC   DEFVOL(*-*),VOLIST\n         MVI   DEFSW,X'00'\n         B     CCMNXT\nDEFA     CLI   0(XLL),C'A'\n         BE    START1\n         B     CCMILS\n*\nDEFLEN   DC    H'0'\nDEFVOL   DC    H'0'\n         DC    (VOLNO)XL12'0'\nDEFSW    DC    X'00'\n         EJECT\n*\n*** QUALIFY PROCESSOR ***\n*\nQUALIFY  BNE   QUALA\n         MVI   QUALFLG,X'00'\n         B     CCMNXT\nQUALA    MVI   QUALFLG,X'04'\n         CLI   0(XLL),C'/'\n         BE    QUALB\n         BAL   XRTN,DSNAM\n         TM    DSNSW,X'01'\n         BO    CCMILS\n         MVC   QUAL1(46),DSNBUF\n         OI    QUALFLG,X'01'\n         BAL   XRTN,SKIPB\n         BE    QUALOUT\n         CLI   0(XLL),C'/'\n         BNE   QUALC\nQUALB    BAL   XRTN,NCH\n         BAL   XRTN,SKIPB\nQUALC    BAL   XRTN,DSNAM\n         TM    DSNSW,X'01'\n         BZ    QUALD\n         LH    XW3,DSNLEN\n         LR    XW1,XW3\n         A     XW1,=A(DSNBUF+1)\n         LH    XW2,GENLEN\n         STC   XW2,*+5\n         MVC   0(*-*,XW1),GENBUF\n         AR    XW3,XW2\n         LA    XW3,1(0,XW3)\n         STH   XW3,DSNLEN\nQUALD    MVC   QUAL2(46),DSNBUF\n         OI    QUALFLG,X'02'\nQUALOUT  NI    QUALFLG,X'03'\n         B     CCMNXT\n         EJECT\n*\n*** CATALOG ROUTINE ***\n*\n         SPACE 1\nCATLG    BAL   XRTN,DSNAM\n         TM    DSNSW,X'01'\n         BO    DSNBAD\n         BAL   XRTN,DSNLIST        LIST DSNAME\n         BAL   XRTN,SKIPB\n         BE    CATE\n         CLC   0(2,XLL),=C'AS'\n         BNE   CATC\n         BAL   XRTN,NCH\n         BAL   XRTN,NCH\n         BAL   XRTN,VLIST\n         CLC   VOLIST(2),=H'1'     VOLUME COUNT IS ONE?\n         BNE   NOTMULT             NO MULTIPLE VOLUMES SUPPORTED\n         BAL   XRTN,VSERL          LIST VOL SER NOS\nCATA     BAL   XRTN,CVOLIST        LIST CVOL IF ANY\n         LA    XRTN,CATF           SET RET ADDR FROM CATCHK\n         TM    CVOLSW,X'01'        IS THIS A CVOL CAMLST??\n         BO    CATB\n         LOCATE TRYCAM1            CHECK IF ALREADY CAT    *FD78.045\n         LTR   R15,R15             DID LOCATE FIND ONE?    *FD78.045\n         BNZ   DOCATA              NO, GOT NONZERO RC      *FD78.045\n         MVC   CATUSED+30(6),LOCAREA+6    PUT THE VOLSER   *FD78.045\n         DIAG  CATUSED,CCMNXT      PRINT OUT THE MSG       *FD78.045\nDOCATA   CATALOG CATCAM1           GO AHEAD AND DO IT      *FD78.045\n         B     CATCHK              CHECK IT OUT            *FD78.045\nCATB     LOCATE TRYCAM2            SAME EVEN IF CVOL LST   *FD78.045\n         LTR   R15,R15             WAS THERE ONE?          *FD78.045\n         BNZ   DOCATB              NOPE...DO IT            *FD78.045\n         MVC   CATUSED+30(6),LOCAREA+6    PUT THE VOLSER   *FD78.045\n         DIAG  CATUSED,CCMNXT      PRINT MSG AND BLOW OFF  *FD78.045\nDOCATB   CATALOG CATCAM2           NOW CATALOG IT          *FD78.045\n         B     CATCHK\nCATC     CLI   0(XLL),C'O'         IS IT ON VOLIST?\n         BNE   CCMILS\nCATC1    BAL   XRTN,NCH            SKIP OVER A CHARACTER\n         CLI   0(XLL),C' '         IS IT A BLANK\n         BE    CATC2               BIF YES\n         CLI   0(XLL),C'('         IS IT AN OPEN PAREN?\n         BNE   CATC1               IF NOT SKIP THE CHAR\nCATC2    BAL   XRTN,VLIST          PARSE THE VOLUME LIST\nCATD     BAL   XRTN,SVSERL         LIST SEARCH VOL SER NOS\n         BAL   XRTN,SRCH\n         LH    XW1,VOLIST\n         CH    XW1,=H'1'\n         BE    CATA\nNOTMULT  DIAG  MULMSG,CCMNXT\nCATE     LH    XW1,DEFLEN\n         STC   XW1,*+5\n         MVC   VOLIST(*-*),DEFVOL\n         B     CATD\nCATF     MVC   PRTBUF+5(12),=C'CATALOGED ON' MOVE IN MESSAGE\n         LA    XW3,PRTBUF+18       LOAD PARAMETER REGISTER\n         LA    XRTN,CCMNXT         LOAD RET ADDR FROM PRINT\n         B     LVOL                LIST VOLUMES\nCATCAM1  CAMLST CATBX,DSNBUF,,VOLIST\nCATCAM2  CAMLST CATBX,DSNBUF,CVOLBUF,VOLIST\nTRYCAM1  CAMLST NAME,DSNBUF,,LOCAREA\nTRYCAM2  CAMLST NAME,DSNBUF,CVOLBUF,LOCAREA\n         EJECT\n*\n*** SEARCH ROUTINE ***\n*\n         SPACE 1\nSRCH     STM   XW1,XW6,SRCHSV1\n         ST    XRTN,SRCHSV2\n         LH    XW1,VOLIST\n         LA    XW2,VOLIST+2\n         LR    XW3,XW2\n         LR    XW4,XW1\n         USING VENTRY,XW2\nSRCHA    MVC   VOLSER(6),VSER\n         OBTAIN SRCHCAM\n         B     *+4(R15)\n         B     SRCHOK\n         B     VNMTD\n         B     SRCHBAD\n         B     IOERR\n         B     PERR\n         B     PERR\nIOERR    MVC   PIOERR2A(6),VOLSER\n         DIAG  PIOERR2,CCMNXT\nPERR     DIAG  PROGERR,ABE2000\nVNMTD    MVC   VNMTMSGA(6),VOLSER\n         DIAG  VNMTMSG,SRCHBAD\nSRCHBAD  BCTR  XW1,0\n         B     SRCHD\nSRCHOK   MVC   0(12,XW3),0(XW2)\n         LA    XW3,12(0,XW3)\nSRCHD    LA    XW2,12(0,XW2)\n         BCT   XW4,SRCHA\n         STH   XW1,VOLIST\n         LTR   XW1,XW1\n         LM    XW1,XW6,SRCHSV1\n         L     XRTN,SRCHSV2\n         BCR   7,XRTN\n         DIAG  DSNFMSG,CCMNXT\nSRCHSV1  DS    6A\nSRCHSV2  DS    A\nVOLSER   DC    CL6' '\nSRCHCAM  CAMLST SEARCH,DSNBUF,VOLSER,LOCAREA\n         EJECT\n*\n*** CHECK LOCATE RETURN CODES ***\n*\n         SPACE 1\n*\nLOCCHK   B     *+4(R15)\n         B     0(0,XRTN)\n         B     CVOLNMTD\n         B     DSNNOTFD\n         B     DSNNOTFD\n         B     DSNNOTFD                                       *KP78.137\n         B     DSNBAD                                         *KP78.137\n         B     CIOERR\n         B     PERR\n         B     PERR\n         B     DSNNOTFD            DATASET NOT FOUND\nCVOLNMTD DIAG  CVLMSG,CCMNXT\nDSNNOTFD DIAG  DSNFMSGC,CCMNXT\nCIOERR   DIAG  PIOERR1,CCMNXT\n         SPACE 2\n*\n*** CHECK CATALOG RETURN CODES ***\n*\n         SPACE 1\nCATCHK   B     *+4(R15)\n         B     0(0,XRTN)                                      *FD78.068\n         B     CATCHK3\n         B     CATCHK2\n         B     PERR\n         B     PERR\n         B     CATFULL\n         B     BADGEN\n         B     IOERR\nCATCHK2  B     *+4(R1)                                        *KP78.137\n         B     0(0,XRTN)                                      *KP78.137\n         B     CVOLNMTD                                       *KP78.137\n         B     PERR                                           *KP78.137\n         B     INDXERR1                                       *KP78.137\n         B     INDXERR2                                       *KP78.137\n         B     DSNBAD                                         *KP78.137\n         B     CIOERR                                         *KP78.137\n         B     PERR                                           *KP78.137\n         B     PERR                                           *KP78.137\nINDXERR1 DIAG  INDXMSG1,CCMNXT                                *KP78.137\nINDXERR2 DIAG  INDXMSG2,CCMNXT                                *KP78.137\nCATCHK3  DIAG  CVLMSG,CCMNXT                                  *BA82.202\nCATFULL  DIAG  CFULMSG,ABE1000\nBADGEN   DIAG  GDGMSG,CCMNXT\n*\n*\n   EJECT\n*\n*** FATAL ERRORS ***\n*\n         SPACE 1\nABE1000  BAL   XRTN,PRINTA\n         ABEND 1000,DUMP\nABE2000  BAL   XRTN,PRINTA\n         ABEND 2000,DUMP\n         EJECT\n*\n*** CONTROL VOLUME PROCESSOR ***\n*\n         SPACE 1\nCVOL     BNE   CVOLA\n         MVI   CVOLSW,X'00'\n         B     CCMNXT\nCVOLA    CLC   0(2,XLL),=C'* '\n         BNE   CVOLB\n         MVI   CVOLSW,X'01'\n         MVC   CVOLBUF(6),CVOL1\n         B     CCMNXT\n*\nCVOLB    CLC   0(3,XLL),=C'** '\n         BNE   CVOLC\n         MVC   CVOLBUF(6),CVOL2\n         MVI   CVOLSW,X'01'\n         B     CCMNXT\n*\nCVOLC    LA    XW1,6(0,0)\n         LA    XW2,CVOLBUF\nCVOLD    CLI   0(XLL),C' '\n         BE    CVOLE\n         CLI   0(XLL),C'A'\n         BL    CCMILS\n         MVC   0(1,XW2),0(XLL)\n         BAL   XRTN,NCH\n         LA    XW2,1(0,XW2)\n         BCT   XW1,CVOLD\n         CLI   0(XLL),C' '\n         BNE   CCMILS\nCVOLE    MVC   CVOL2(6),CVOL1\n         MVC   CVOL1(6),CVOLBUF\n         MVI   CVOLSW,X'01'\n         B     CCMNXT\n*\nCVOLSW   DC    X'00'\nCVOLBUF  DC    CL6' '\nCVOL1    DC    CL6' '\nCVOL2    DC    CL6' '\n         EJECT\n*\n*** UNCATALOG PROCESSOR ***\n*\nUNCAT    BAL   XRTN,DSNAM\n         TM    DSNSW,X'01'\n         BZ    *+8\n         BAL   XRTN,FIXGEN\n         BAL   XRTN,DSNLIST        LIST DSNAME\n         BAL   XRTN,CVOLIST        LIST CVLO IF ANY\n         BAL   XRTN,SKIPB\n         BE    UNCAT2\n         CLI   0(XLL),C'L'\n         BNE   CCMILS\n         LA    XRTN,UNCAT4\n         TM    CVOLSW,X'01'\n         BO    UNCAT1\n         CATALOG UNCAM1\n         B     UNCATCK\nUNCAT1   CATALOG UNCAM2\n         B     UNCATCK\nUNCAT2   LA    XRTN,UNCAT4\n         TM    CVOLSW,X'01'\n         BO    UNCAT3\n         CATALOG UNCAM3\n         B     UNCATCK\nUNCAT3   CATALOG UNCAM4\n         B     UNCATCK\nUNCAT4   MVC   PRTBUF+5(11),=C'UNCATALOGED' MOVE IN MESSAGE\n         LA    XRTN,CCMNXT         LOAD RETURN ADDRESS FOR PRINT\n         B     PRINTA              PRINT MESSAGE\n*\nUNCAM1   CAMLST UNCAT,DSNBUF\nUNCAM2   CAMLST UNCAT,DSNBUF,CVOLBUF\nUNCAM3   CAMLST UCATDX,DSNBUF\nUNCAM4   CAMLST UCATDX,DSNBUF,CVOLBUF\n   EJECT\n*\n*  UNCATALOG RETURN CODE CHECK\n*\nUNCATCK  B     *+4(R15)                                       *FD78.068\n         B     0(0,XRTN)                                      *FD78.068\n         B     CATCHK3                                        *FD78.068\n         B     LOCCHK+4(R1)                                   *KP78.171\n         B     PERR                                           *FD78.068\n         B     PERR                                           *FD78.068\n         B     CATFULL                                        *FD78.068\n         B     BADGEN                                         *FD78.068\n         B     IOERR                                          *FD78.068\n         EJECT\n*\n*** DELETE PROCESSOR ***\n*\n         SPACE 1\nDELETE   BAL   XRTN,DSNAM\n         TM    DSNSW,X'01'\n         BZ    *+8\n         BAL   XRTN,FIXGEN\n         MVC   DELSW(1),DEFSW\n         BAL   XRTN,SKIPB\n         BE    DELH\nDELA     CLI   0(XLL),C'U'\n         BNE   DELB\n         OI    DELSW,X'08'\n         NI    DELSW,X'0F'\n         B     DELF\nDELB     CLI   0(XLL),C'N'\n         BNE   DELC\n         OI    DELSW,X'10'\n         NI    DELSW,X'17'\n         B     DELF\nDELC     CLI   0(XLL),C'P'\n         BNE   DELD\n         OI    DELSW,X'04'\n         B     DELF\nDELD     CLI   0(XLL),C'O'         IS IT ON VOLIST?\n         BNE   DELE                BIF NOT\nDELD1    BAL   XRTN,NCH            SKIP OVER A CHARACTER\n         CLI   0(XLL),C' '         IS IT A BLANK?\n         BE    DELD2               BIF YES\n         CLI   0(XLL),C'('         IS IT AN OPEN PAREN?\n         BNE   DELD1               IF NO, SKIP THE CHARACTER\nDELD2    BAL   XRTN,VLIST          PARSE THE VOLIST\n         OI    DELSW,X'02'\n         NI    DELSW,X'1E'\n         B     DELG\nDELE     CLI   0(XLL),C'A'\n         BNE   CCMILS\n         OI    DELSW,X'01'\n         NI    DELSW,X'1D'\nDELF     BAL   XRTN,NCH\n         CLI   0(XLL),C' '\n         BNE   DELF\nDELG     BAL   XRTN,SKIPB\n         BNE   DELA\nDELH     BAL   XRTN,DSNLIST        LIST DSNAMES\n         TM    DELSW,X'03'\n         BNZ   DELI\n         LH    XW1,DEFLEN\n         STH   XW1,VOLEN\n         STC   XW1,*+5\n         MVC   VOLIST(*-*),DEFVOL\n         B     DELJ1\nDELI     TM    DELSW,X'01'\n         BZ    DELJ1\n         TM    CVOLSW,X'01'\n         BO    DELI1\n         LOCATE DELCAM1\n         B     DELI2\nDELI1    LOCATE DELCAM2\nDELI2    BAL   XRTN,LOCCHK\n         LH    XW1,LOCAREA\n         MH    XW1,=H'12'\n         LA    XW1,1(0,XW1)\n         STH   XW1,VOLEN\n         STC   XW1,*+5\n         MVC   VOLIST(*-*),LOCAREA\n         LA    XRTN,DELJ2\n         B     VSERL               LIST VOL SER NOS\nDELJ1    BAL   XRTN,SVSERL         LIST SEARCH VOL SER NOS\nDELJ2    MVC   VOLIST+12(2),=H'7'  MOVE IN ERROR CODE\n         SR    R0,R0               CLEAR R0 FOR SCRATCH MACRO\n         TM    DELSW,X'04'\n         BO    DELK\n         SCRATCH DELCAM3\n         B     DELL\nDELK     SCRATCH DELCAM4\nDELL     BAL   XRTN,SCRCHK\n         TM    DELSW,X'08'\n         BO    DELM\n         TM    DELSW,X'10'\n         BO    CCMNXT\n         TM    DELSW,X'01'\n         BZ    CCMNXT\nDELM     BAL   XRTN,CVOLIST        LIST CVOL IF ANY\n         TM    CVOLSW,X'01'\n         BO    DELN\n         CATALOG UNCAM3\n         B     DELO\nDELN     CATALOG UNCAM4\nDELO     BAL   XRTN,UNCATCK                                   *AB78.128\n         MVC   PRTBUF+5(11),=C'UNCATALOGED'\n         LA    XRTN,CCMNXT         LOAD RET ADDR FOR PRINT\n         B     PRINTA\n*\nDELCAM1  CAMLST NAME,DSNBUF,,LOCAREA\nDELCAM2  CAMLST NAME,DSNBUF,CVOLBUF,LOCAREA\nDELCAM3  CAMLST SCRATCH,DSNBUF,,VOLIST\nDELCAM4  CAMLST SCRATCH,DSNBUF,,VOLIST,,OVRD\nDELSW    DC    X'00'\n         EJECT\n*\n*** CHECK SCRATCH RETURN CODES ***\n*\nSCRCHK   ST    XRTN,SCRSV\n         B     *+4(R15)\n         B     SCRCHK1\n         B     SCRCHK2\n         B     SCRCHK2\n         B     PERR\n*\nSCRCHK1  LH    XW1,VOLIST          LOAD NUMBER OF VOLUMES\n         LA    XW2,VOLIST+2\n         USING   VENTRY,XW2\nSCRCHK1A MVC   PRTBUF+5(10),=C'DELETED ON'\n         MVC   PRTBUF+16(6),VSER   MOVE IN VOLUME SERIAL NUMBER\n         BAL   XRTN,PRINTA         PRINT MESSAGE\n         LA    XW2,12(0,XW2)\n         BCT   XW1,SCRCHK1A\n         B     SCRC\n*\nSCRCHK2  LH    XW1,VOLIST\n         SR    XW4,XW4\n         LA    XW2,VOLIST+2\n         USING   VENTRY,XW2\nSCRA     LH    XW3,VSEQ\n         SLL   XW3,2\n         B     *+4(XW3)\n         B     SCR0                DELETED ON VOLUME\n         B     SCRB                NOT FOUND ON VOLUME\n         B     SCR2                INCORRECT PASSWORD\n         B     SCR3                UNEXPIRED DATASET\n         B     SCR4                PERMANENT I/O ERROR\n         B     SCR56               VOLUME NOT MOUNTED\n         B     SCR56               VOLUME NOT MOUNTED\n         DIAG  DSNIMSG1,CCMNXT     CURRENTLY IN USE           *BA82.202\n*\nSCR0     MVC   PRTBUF+5(10),=C'DELETED ON'\n         MVC   PRTBUF+16(6),VSER\n         LA    XRTN,SCRB1          LOAD RETURN ADDRESS FROM PRINT\n         B     PRINTA              GO PRINT IT\n*\nSCR2     MVC   PSWDMSGA(6),VSER\n         DIAG  PSWDMSG,SCRB        INCORRECT PASSWORD MESSAGE\n*\nSCR3     MVC   EXPMSGA(6),VSER\n         DIAG  EXPMSG,SCRB         UNEXPIRED DATASET\n*\nSCR4     XR    R0,R0\n         LA    R3,DSNBUF\nSCR4B    MVC   PIOERR2A(6),VSER\n         DIAG  PIOERR2,SCRB        PERMANENT I/O ERROR\n*\nSCR56    MVC   VNMTMSGA(6),VSER\n         DIAG  VNMTMSG,SCRB        VOLUME NOT MOUNTED\n*\nSCRB1    LA    XW4,1(0,XW4)\nSCRB     LA    XW2,12(0,XW2)\n         BCT   XW1,SCRA\n         LTR   XW4,XW4             TEST IF DELETED ON ANY VOLUMES\n         BNZ   SCRC                BIF DELETED ON SOME\nSCRC1    DIAG  DSNFMSG,SCRC        NOT SCRATCHED MESSAGE\nSCRC     L     XRTN,SCRSV\n         BR    XRTN\n         DROP  XW2\n*\nSCRSV    DS    A\n         EJECT\n*\n*** RENAME COMMAND ***\n*\n         SPACE 1\nRENAME   BAL   XRTN,DSNAM          GET DSNAMEE1\n         TM    DSNSW,X'01'         SEE IF GENERATION DATA GROUP\n         BZ    *+8                 IF SO FIX IT UP\n         BAL   XRTN,FIXGEN\n         MVC   DSNBUF1(46),DSNBUF  STORE DSNAME\n         BAL   XRTN,SKIPB          SKIP TO SECOND DSNAME\n         BE    CCMILS              BIF OFFEND OF CARD\n*\n         BAL   XRTN,DSNAM          GET DSNAME2\n         TM    DSNSW,X'01'         SEE IF GERERATION DATA GROUP\n         BZ    *+8                 IF SO FIX IT UP\n         BAL   XRTN,FIXGEN\n         MVC   DSNBUF2(46),DSNBUF  STORE DSNAME\n*\n         LH    XW1,DSNBUF1L        LOAD LENGTH OF DSN1\n         STC   XW1,*+5             STORE IT IN MVC INST\n         MVC   PRTBUF(*-*),DSNBUF1 MOVE IN DSN1\n         LA    XW2,PRTBUF+2(XW1)   SKIP PAST DSN1 IN BUFFER\n         MVC   0(2,XW2),=C'->'     MOVE IN ->\n         LH    XW1,DSNBUF2L        LOAD DSN2 LENGTH\n         STC   XW1,*+5             STORE IT IN MVC INST\n         MVC   3(*-*,XW2),DSNBUF2  MOVE IN DSN2\n         BAL   XRTN,PRINTA         PRINT THE LINE\n         MVC   RENSW(1),DEFSW      SET UP DEFAULTS\n         BAL   XRTN,SKIPB          SKIP BLANKS\n         BE    RENH                BIF NOT\n*\nRENA     CLI   0(XLL),C'U'         SEE IF UNCAT SPECIFIED\n         BNE   RENA1               BIF NOT\n         OI    RENSW,X'08'         TURN ON UNCAT\n         NI    RENSW,X'0F'         TURN OFF NOCAT\n         B     RENF                DO REST OF CARD\n*\nRENA1    CLI   0(XLL),C'R'         SEE IF RECAT SPECIFIED\n         BNE   RENB                BIF NOT\n         OI    RENSW,X'0C'         TURN ON UNCAT AND CAT\n         NI    RENSW,X'0F'         TURN OFF NOCAT\n         B     RENF                DO REST OF CARD\n*\nRENB     CLI   0(XLL),C'C'         SEE IF CAT SPECIFIED\n         BNE   RENC                BIF NOT\n         OI    RENSW,X'04'         TURN ON CAT\n         NI    RENSW,X'0F'         TURN OFF NOCAT\n         B     RENF                DO REST OF CARD\n*\nRENC     CLI   0(XLL),C'N'         SEE IF NOCAT SPECIFIED\n         BNE   REND                BIF NOT\n         OI    RENSW,X'10'         TURN ON NOCAT\n         NI    RENSW,X'13'         TURN OFF UNCAT AND CAT\n         B     RENF                DO REST OF CARD\n*\nREND     CLI   0(XLL),C'O'         SEE IF ON VOLIST SPECIFIED\n         BNE   RENE                BIF NOT\nREND1    BAL   XRTN,NCH            SKIP OVER A CHARACTER\n         CLI   0(XLL),C' '         IS IT A BLANK?\n         BE    REND2               BIF YES\n         CLI   0(XLL),C'('         IS IT AN OPEN PAREN?\n         BNE   REND1               IF NOT, SKIP THE CHARACTER\nREND2    BAL   XRTN,VLIST          DO VOLIST\n         OI    RENSW,X'02'         TURN ON VOLIST\n         NI    RENSW,X'1E'         TURN OFF ASCAT\n         B     RENG                DO REST OF CARD\n*\nRENE     CLI   0(XLL),C'A'         SEE IF ASCAT SPECIFIED\n         BNE   CCMILS              IF NOT CARD ILLEGAL SYNTAX\n         OI    RENSW,X'01'         TURN ON ASCAT\n         NI    RENSW,X'1D'         TURN OFF VOLIST\nRENF     BAL   XRTN,NCH            SKIP 1 CHARACTER\n         CLI   0(XLL),C' '         CHECK FOR BLANK\n         BNE   RENF                IF NOT LOOK FOR NEXT BLANK\nRENG     BAL   XRTN,SKIPB          SKIP TO NEXT KEYWORD\n         BNE   RENA                IF NOT OFFEND PARSE KEYWORD\n*\nRENH     MVC   DSNBUF(46),DSNBUF1  SET UP SEARCH FOR DSN1\n         TM    RENSW,X'03'         CHECK WHERE TO LOOK FOR DSN\n         BNZ   RENI                BIF DEFAULT VOLUMES USED\n         OI    RENSW,X'02'         DUMMY IT UP AS IF ON VOLIST GIVEN\n         LH    XW1,DEFLEN          PICK UP LENGTH ON VOLIST\n         STH   XW1,VOLEN           STORE IT\n         STC   XW1,*+5             FIX UP THE MOVE INSTRUCTION\n         MVC   VOLIST(*-*),DEFVOL        MOVE THE VOLUME LIST IN\nRENH1    BAL   XRTN,SVSERL         LIST SEARCH VOL SER NOS\n         BAL   XRTN,SRCH           SEARCH FOR DSN ON VOLUMES\n         CLC   VOLIST(2),=H'1'     CHECK IF MULTIPLE VOLUMES FOUND\n         BE    RENL                BIF NOT\n         B     NOTMULT             IF SO DIAGNOSE IT\n*\nRENI     TM    RENSW,X'01'         CHECK FOR ON SPECIFIED\n         BZ    RENH1               BIF SO\n*\n         TM    CVOLSW,X'01'        CHECK IF CVOL USED\n         BO    RENJ                BIF CVOL USED\n         LOCATE RENCAM1            LOCATE IN CATALOG\n         B     RENK                GO CHECK RETURN CODE\nRENJ     LOCATE RENCAM2            LOCATE IN CATALOG ON CVOL\nRENK     BAL   XRTN,LOCCHK         CHECK RETURN CODE FROM LOCATE\n         LH    XW1,LOCAREA         PICK UP NUMBER OF VOLUMES\n         MH    XW1,=H'12'          MULTIPLY BY LENGTH OF EACH ENTRY\n         LA    XW1,1(0,XW1)        ACCOUNT FOR COUNT FIELD AT FIRST\n         STH   XW1,VOLEN           STORE LENGTH OF VOLUME LIST\n         STC   XW1,*+5             FIX UP MOVE INSTRUCTION\n         MVC   VOLIST(*-*),LOCAREA\n         BAL   XRTN,VSERL          LIST VOL SER NOS\n*\n         SPACE\nRENL     XR    R0,R0\n         LA    R3,DSNBUF\n         TM    RENSW,X'1C'      BIF CAT,NOCAT,UNCAT OR RECAT SPECIFIED\n         BNZ   RENL2\n         TM    RENSW,X'02'         TEST FOR ON SPECIFIED\n         BO    RENL1\n         OI    RENSW,X'0C'         ASCAT -> UNCAT CAT\n         B     RENL2\nRENL1    OI    RENSW,X'10'         ON VOLUME LIST -> NOCAT\n*\nRENL2    TM    RENSW,X'08'         CHECK IF UNCAT SPECIFIED\n         BZ    RENO                BIF NO UNCAT\n         BAL   XRTN,CVOLIST        LIST COLTROL VOLUMES IF ANY\n         TM    CVOLSW,X'01'        CHECK IF CVOL USED\n         BO    RENM\n         CATALOG UNCAM3            UNCATALOG IT\n         B     RENN\nRENM     CATALOG UNCAM4            UNCATALOG IT\nRENN     BAL   XRTN,UNCATCK        CHECK CATALOG RETURN CODES *AB78.128\n         BAL   XRTN,CVOLIST        LIST CONTROL VOLUME IF ANY\n         MVC   PRTBUF+5(11),=C'UNCATALOGED' MOVE MSG INTO BUFFER\n         LH    XW1,DSNBUF1L        LOAD DSN1 LENGTH\n         STC   XW1,*+5             STORE IT IN MOVE INST\n         MVC   PRTBUF+17(*-*),DSNBUF1  MOVE IN DSN1\n         BAL   XRTN,PRINTA         GO PRINT IT\n*\nRENO     MVC   VOLIST+12(2),=H'7'  MOVE IN ERROR CODE\n         SR    R0,R0               CLEAR REGISTER 0 FOR RENAME\n         RENAME RENCAM3            RENAME DATASET\n         BAL   XRTN,RENCHK         CHECK RENAME RETURN CODES\n*\nRENP     TM    RENSW,X'04'         CHECK IF CAT SPECIFIED\n         BZ    CCMNXT              IF NOT GET NEXT COMMAND\n         LH    XW1,VOLIST          LOAD NUMBER OF VOLUMES\n         LA    XW2,VOLIST+2        SET BASE ADDRESS\n         USING VENTRY,XW2\nRENQ     XC    VSEQ(2),VSEQ        CLEAR SEQUENCE NUMBER FIELD\n         LA    XW2,12(0,XW2)       SKIP TO NEXT VOLUME ENTRY\n         BCT   XW1,RENQ            GO CLEAR NEXT SEQ FIELD IF ANY\n*\n         TM    CVOLSW,X'01'        CHECK IF CVOL USED\n         BO    RENR                BIF SO\n         LOCATE TRYCAM4            CHECK IF NEW ALREADY CAT  *FD78.128\n         LTR   R15,R15             DID LOCATE FIND ONE??     *FD78.128\n         BNZ   DOCATR              NO..GO CATALOG IT         *FD78.128\n         MVC   CATUSED+30(6),LOCAREA+6    PUT THE VOLSER     *FD78.128\n         DIAG  CATUSED,CCMNXT      PRINT MSG AND BLOW OFF    *FD78.128\nDOCATR   CATALOG RENCAM4           CATALOG DSN2              *FD78.128\n         B     RENS                SET UP RETURN & CATCHK    *FD78.128\nRENR     LOCATE TRYCAM5            SAME IF CVOL              *FD78.128\n         LTR   R15,R15             CHK RC TO SEE IF WAS ONE  *FD78.128\n         BNZ   DOCATS              NO, GO CAT DSN2           *FD78.128\n         MVC   CATUSED+30(6),LOCAREA+6  PUT IN VOLSER USED   *FD78.128\n         DIAG  CATUSED,CCMNXT      PRINT MSG AND DO NEXT CMD *FD78.128\nDOCATS   CATALOG RENCAM5           CATALOG DSN2 ON CVOL      *FD78.128\nRENS     MVC   DSNBUF,DSNBUF2     COPY DSN FOR MESSAGES       *AB78.130\n         BAL   XRTN,CATCHK         CHECK CATALOG RETURN CODES\n*\n         MVC   PRTBUF+5(9),=C'CATALOGED' MOVE IN MSG\n         LH    XW1,DSNBUF2L        PICK UP DSN2 LENGTH\n         STC   XW1,*+5             STORE LENGTH IN MVC INST\n         MVC   PRTBUF+15(*-*),DSNBUF2\n         LA    XRTN,CCMNXT         LOAD RETURN ADDRESS FOR PRINT\n         B     PRINTA              GO PRINT IT\n   EJECT\n*\n*** RENAME CAMLSTS ***\n*\nRENCAM1  CAMLST NAME,DSNBUF1,,LOCAREA\nRENCAM2  CAMLST NAME,DSNBUF1,CVOLBUF,LOCAREA\nRENCAM3  CAMLST RENAME,DSNBUF1,DSNBUF2,VOLIST\nRENCAM4  CAMLST CATBX,DSNBUF2,,VOLIST\nRENCAM5  CAMLST CATBX,DSNBUF2,CVOLBUF,VOLIST\nTRYCAM4  CAMLST NAME,DSNBUF2,,LOCAREA                        *FD78.128\nTRYCAM5  CAMLST NAME,DSNBUF2,CVOLBUF,LOCAREA                 *FD78.128\n*\n         DS    0H\nDSNBUF1  DS    CL44\nDSNBUF1L DS    H\nDSNBUF2  DS    CL44\nDSNBUF2L DS    H\nRENSW    DS    X\n         EJECT\n*\n*** CHECK RENAME RETURN CODES ***\n*\nRENCHK   ST    XRTN,RENCHSV        STORE RETURN ADDRESS\n         B     *+4(R15)            BRANCH ON RETURN CODE\n         B     RENCHK0             NORMAL RETURN CODE\n         B     RENCHK48            NO VOLUMES MOUNTED\n         B     RENCHK48            UNUSUAL CONDITION ON SOME VOLUMES\n         B     PERR                PROGRAM ERROR\n*\nRENCHK0  LH    XW1,VOLIST          LOAD LENGTH OF VOLIST      *AB78.130\n         LA    XW2,VOLIST+2        GET ADDRESS OF VOLIST\n         USING VENTRY,XW2\nRENCHK0A MVC   PRTBUF+5(10),=C'RENAMED ON'\n         MVC   PRTBUF+16(6),VSER   MOVE IN VOL SER NO\n         BAL   XRTN,PRINTA         PRINT MESSAGE\n         LA    XW2,12(0,XW2)\n         BCT   XW1,RENCHK0         GO DO NEXT VOLUME ENTRY\n         B     RENCC\n*\nRENCHK48 LH    XW1,VOLIST\n         LA    XW2,VOLIST+2\n         USING VENTRY,XW2\n         SR    XW4,XW4\nRENCA    LH    XW3,VSEQ\n         SLL   XW3,2\n         B     *+4(XW3)\n         B     RENC0               RENAMED\n         B     RENCB               NOT FOUND ON VOLUME\n         B     RENC2               INCORRECT PASSWORD\n         B     RENC3               NEW NAME ALREADY EXISTS\n         B     RENC4               PERMANENT I/O ERROR ON VOLUME\n         B     RENC56              VOLUME NOT MOUNTED\n         B     RENC56              VOLUME NOT MOUNTED\n         DIAG  DSNIMSG1,CCMNXT     CURRENTLY IN USE          *BA82.202\n*\nRENC0    MVC   PRTBUF+5(10),=C'RENAMED ON'\n         MVC   PRTBUF+16(6),VSER\n         LA    XRTN,RENCB1\n         B     PRINTA\n*\nRENC2    MVC   PSWDMSGA(6),VSER\n         DIAG  PSWDMSG,RENCB\n*\nRENC3    MVC   DUPMSGA(6),VSER\n         DIAG  DUPMSG,RENCB\n*\nRENC4    MVC   PIOERR2A(6),VSER\n         DIAG  PIOERR2,RENCB\n*\nRENC56   MVC   VNMTMSGA(6),VSER\n         DIAG  VNMTMSG,RENCB\n*\nRENCB1   LA    XW4,1(0,XW4)\nRENCB    LA    XW2,12(0,XW2)\n         BCT   XW1,RENCA\n         LTR   XW4,XW4             SEE IF ANY RENAMES DONE\n         BNZ   RENCC\nRENCC1   DIAG  NRENMSG,CCMNXT      NOT RENAMED MESSAGE\nRENCC    L     XRTN,RENCHSV\n         BR    XRTN\n         DROP  XW2\n*\nRENCHSV  DS    A\n         EJECT\n*\n*** STOP COMMAND ***\n*\n         SPACE 1\nSTOPCMD  BE    STOPCMDA            BIF NULL STOP COMMAND\n         BAL   XRTN,NUMBER         COLLECT A NUMBER\n         STH   XW1,STOPCODE        STORE IT\n         B     CCMNXT              DO NEXT COMMAND\nSTOPCMDA MVC   STOPCODE(2),=X'7FFF'    STOPCODE = INFINITY\n         B     CCMNXT              DO NEXT COMMAND\n*\nSTOPCODE DC    H'8'\n         SPACE 2\n*\n*** NUMBER BUILD ROUTINE ***\n*\n         SPACE 1\nNUMBER   STM   XW2,XW4,NUMBSV1     STORE REGISTERS\n         ST    XRTN,NUMBSV2       STORE RETURN REGISTER\n         LA    XW2,NUMB1\n         LH    XW3,=H'-1'\n         LA    XW4,8(0,0)\nNUMA     CLI   0(XLL),C'0'\n         BL    NUMB\n         CLI   0(XLL),C'9'\n         BH    NUMB\n         MVC   0(1,XW2),0(XLL)\n         LA    XW2,1(0,XW2)\n         LA    XW3,1(0,XW3)\n         BAL   XRTN,NCH\n         BCT   XW4,NUMA\nNUMB     LTR   XW3,XW3\n         BM    CCMILS\n         EX    XW3,PACKINST\n         CVB   XW1,NUMBUF\n         LM    XW2,XW4,NUMBSV1\n         L     XRTN,NUMBSV2\n         BR    XRTN\n*\nNUMBSV1  DS    3A\nNUMBSV2  DS    A\nNUMB1    DS    CL8\nPACKINST PACK  NUMBUF(8),NUMB1(*-*)\n         EJECT\n         LTORG\n         END   START\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FORMAT4": {"ttr": 4865, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "FORMAT4  TITLE 'ICSA DISK MAPPER - TIOT WALKER AND JFCB MODIFIER'\nFORMAT4  SAVEX BANNER=YES\n         EJECT\n*        1. RUN DOWN THE TIOT AND DETERMINE THE NUMBER OF VOLUMEXX DDS\n*        2. ALLOCATE THE DD, VOLSER AND UCB POINTER TABLE.\n*        3. RDJFCB, OPENJ, AND CLOSE EACH DD.\n*        4. RETURN WITH A POINTER TO THE TABLE.\n*        CALLED FROM PL/I AS CALL FORMAT4 (POINTER);\n         SPACE 5\n         LA    R4,DCB             FIND THE GENERAL DCB\n         USING IHADCB,R4\n         LR    R11,R1             SAVE THE PARAMETER ADDRESS\n         L     R5,16              POINT TO THE CVT\n         L     R5,0(,R5)\n         L     R5,0(,R5)          FIND THE TCB\n         L     R5,12(,R5)         FIND THE TIOT\n         LR    R8,R5              SAVE TIOT ADDRESS\n         SR    R6,R6\n         LR    R7,R6\nTIOTLOOP ICM   R6,B'0001',24(R5)  GET LENGTH THIS ENTRY\n         BZ    ENDLOOP1\n         CLC   28(6,R5),=C'VOLUME'     IS THIS A VOLUMEXX DD ENTRY?\n         BNE   LOOPEND1\n         LA    R7,1(,R7)          INCREMENT THE COUNTER\nLOOPEND1 AR    R5,R6              BUMP THE POINTER\n         B     TIOTLOOP           AND TRY NEXT ENTRY\nENDLOOP1 LR    R9,R7              SAVE COUNT FOR LATER\n         MH    R9,=H'18'\n         LA    R9,2(,R9)          COMPUTE TABLE SIZE\n         GETMAIN R,LV=(9)    GET THE TABLE SPACE\n         LR    R10,R1             SAVE TABLE ADDRESS\n         STH   R7,0(,R10)     STORE THE COUNTER\n         LA    R2,2(,R10)         POINT TO DDNAME PORTION\n         SR    R6,R6\nTLOOP    ICM   R6,B'0001',24(R8)\n         BZ    ENDLOOP2\n         CLC   28(6,R8),=C'VOLUME'\n         BNE   LOOPEND2\n         MVC   0(8,R2),28(R8)     SAVE DDNAME\n         L     R1,40(,R8)         FIND THE UCB\n         MVC   8(6,R2),28(R1)     SAVE THE VOLSER\n         ST    R1,14(,R2)         AND THE UCB ADDRESS\n         LA    R2,18(,R2)\n         MVC   DCBDDNAM,28(R8)    MOVE DDNAME INTO THE DCB\n         RDJFCB (DCB)\n         MVC   JFCB(44),=44X'04'  INSERT FORMAT 4 DSNAME\n         OPEN  (DCB),TYPE=J\n         CLOSE (DCB)              REWRITES THE JFCB WITH FORMAT 4 NAME\nLOOPEND2 AR    R8,R6              BUMP POINTER\n         B     TLOOP\nENDLOOP2 L     R1,0(,R11)\n         ST    R10,0(,R1)\n         RETURNX\n         LTORG\n         PRINT NOGEN\n         EJECT\nDCB      DCB   DDNAME=*,EXLST=EXLST,DSORG=PS,MACRF=RC\nEXLST    DCBEXLST JFCB=JFCB\nJFCB     DS    CL176              THE JFCB\n         DCBD  DSORG=BS\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FUNCACC@": {"ttr": 4867, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "1\n-\n      The TSO functional accounting enhancement (the RUA11 family of sysmods\n      and related programs) was developed to obtain better TSO response time\n      information than provided by other products and interfaces.\n0     Note that at least MVS/SE2 is required for functional accounting to be\n      used.   Also  note that  unless you  have the  TSO Command  Package or\n      TSO/E,  no one but  SPF and a few non-IBM products  use the functional\n      accounting  interface.  Thus,   without one  of  these products,   you\n      probably aren't interested, unless everyone runs under SPF,  or unless\n      you are willing to  do some work to add the  interface to vanilla TSO.\n      There are two primary changes made:\n0     (a)  Functional accounting is changed so that it is no longer required\n           to  have a  load  module containing  the  names of  \"interesting\"\n           commands and subcommands.   Instead,  the  first 200 commands and\n           subcommands of any sort are recorded.\n0     (b)  The fields in the  type 32 detail record that are  defined by IBM\n           to contain  SRB time,  number  of TPUTs  and number of  TGETs are\n           replaced by  elapsed time,   \"quick\" elapsed  time,  and  \"quick\"\n           command count respectively.   (A quick  command is defined as one\n           which completes without issuing a  TGET;  the total quick elapsed\n           time  is the  total elapsed  time  for quick  invocations of  the\n           command or subcommand.)\n0     The implementation of  part (a)  above requires  a little elaboration.\n      The IEEMB846 module (which contains the interesting TSO command names)\n      is replaced  by a module which  contains 200 names beginning  with the\n      '0'  (zero)   character.    The module  which  accumulates  functional\n      accounting data  is changed so that,   whenever it finds  a previously\n      unknown command,  it  replaces the first '0' command in  the list with\n      the new command.  Thus, by altering the sample version of this module,\n      you can increase  or decrease the maximum number  recorded,  or insert\n      some commands  at the front  which you want to  be sure to  catch,  no\n      matter how many others may occur first.\n0     The TSOSUMM program is provided to produce a response time report from\n      a batch of SMF data.   It is  written in PASCAL/VS;  if you don't have\n      PASCAL/VS,  it should not be that hard  to convert it to PL/I.   (Why,\n      you ask,  was it written in PASCAL  in the first place?   I'm glad you\n      asked  that  question.)    Sample  JCL for  running  TSOSUMM  is  also\n      provided.\n0     One optional input  to TSOSUMM is a \"CMDIN\" data  set,  which provides\n      information on alias  command names,  and on translation  of the eight\n      character subcommand designators into  command-subcommand pairs.   The\n      data in in free format, each card of the format\n0          command|command.subcmd alias...\n0     The sample  data set is  sorted in  descending order by  command name.\n      This results in a slight efficiency improvement, but is not required.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IECSDSL1": {"ttr": 4869, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " /*      %INCLUDE SYSLIB(IECSDSL1)                                   */\n %IF FORMAT1 \u00ac= 'YES'                   /* IF FORMAT1 = YES, THEN    */\n     %THEN %GOTO F2;                    /* BUILD A FORMAT 1 DSCB     */\n /*                    FORMAT 1 DSCB                                 */\n DCL 1 IECSDSF1 BASED(F1PTR),           /* FORMAT 1 DSCB - DESCRIBED */\n         2 RSV00001    CHAR(140);       /* IN THE FOLLOWING STRUCTURE*/\n DCL 1 IECSDSL1 BASED(ADDR(IECSDSF1))   /* START OF THE FORMAT 1 DSCB*/\n                UNALIGNED,\n         2 DS1DSNAM    CHAR(44),        /* DATA SET NAME             */\n         2 DS1FMTID    CHAR(1),         /* FORMAT IDENTIFIER         */\n         2 DS1DSSN     CHAR(6),         /* DATA SET SERIAL NUMBER    */\n         2 DS1VOLSQ    FIXED BIN(15),   /* VOLUME SEQUENCE NUMBER    */\n         2 DS1CREDT,                    /* CREATION DATE             */\n           3 DS1CRYR   BIT(8) ALIGNED,  /* YEAR                      */\n           3 DS1CRDAY  FIXED BIN(15),   /* DAY                       */\n         2 DS1EXPDT,                    /* EXPIRATION DATE           */\n           3 DS1EXYR   BIT(8) ALIGNED,  /* YEAR                      */\n           3 DS1EXDAY  FIXED BIN(15),   /* DAY                       */\n         2 DS1NOEPV    BIT(8) ALIGNED,  /* NUMBER OF EXTENTS ON\n                                           VOLUME                    */\n         2 DS1NOBDB    BIT(8) ALIGNED,  /* NUMBER OF BYTES USED IN\n                                           LAST DIRECTORY BLOCK      */\n         2 DS1LGNID CHAR(17),           /* LOGONID                   */\n         2 RSV00003    CHAR(4),         /* RESERVED          @G60ASBJ*/\n         2 DS1DSORG    BIT(16) ALIGNED, /* DATA SET ORGANIZATION     */\n         2 DS1RECFM    BIT(8) ALIGNED,  /* RECORD FORMAT             */\n         2 DS1OPTCD    BIT(8) ALIGNED,  /* OPTION CODE               */\n         2 DS1BLKL     FIXED BIN(15),   /* BLOCK LENGTH              */\n         2 DS1LRECL    FIXED BIN(15),   /* RECORD LENGTH             */\n         2 DS1KEYL     BIT(8) ALIGNED,  /* KEY LENGTH                */\n         2 DS1RKP      FIXED BIN(15),   /* RELATIVE KEY POSITION     */\n         2 DS1DSIND BIT(8) ALIGNED,     /* DATA SET INDICATORS       */\n /*       3 DS1IND80    BIT(1),         /* LAST VOLUME ON    @G60ASBJ*/\n /*                                     /* WHICH A DATA SET  @G60ASBJ*/\n /*                                     /* RESIDES.          @G60ASBJ*/\n /*       3 DS1IND40    BIT(1),         /* DATA SET IS RACF  @G60ASBJ*/\n /*                                     /* DEFINED           @G60ASBJ*/\n /*       3 DS1IND20    BIT(1),         /* BLOCK LENGTH IS A @G60ASBJ*/\n /*                                     /* MULTIPLE OF 8 BYTE@G60ASBJ*/\n /*       3 DS1IND10    BIT(1),         /* PASSWORD IS       @G60ASBJ*/\n /*                                     /* REQUIRED TO READ  @G60ASBJ*/\n /*                                     /* OR WRITE OR BOTH- @G60ASBJ*/\n /*                                     /* SEE DS1IND04      @G60ASBJ*/\n /*       3 DS1IND08    BIT(1),         /* RESERVED.         @G60ASBJ*/\n /*       3 DS1IND04    BIT(1),         /* IF DS1IND10 IS 1  @G60ASBJ*/\n /*                                     /* THEN IF DS1IND04  @G60ASBJ*/\n /*                                     /* IS . . .          @G60ASBJ*/\n /*                                     /* 1 - PASSWORD IS   @G60ASBJ*/\n /*                                     /* REQUIRED TO WRITE @G60ASBJ*/\n /*                                     /* BUT NOT TO READ   @G60ASBJ*/\n /*                                     /* 0 - PASSWORD IS   @G60ASBJ*/\n /*                                     /* REQUIRED TO WRITE @G60ASBJ*/\n /*                                     /* AND TO READ       @G60ASBJ*/\n /*       3 DS1IND02,                   /* DATASET HAS BEEN  @G60ASBJ*/\n /*                                     /* OPENED FOR OTHER  @G60ASBJ*/\n /*                                     /* THAN INPUT SINCE  @G60ASBJ*/\n /*                                     /* LAST BACKUP COPY  @G60ASBJ*/\n /*                                     /* WAS MADE.         @G60ASBJ*/\n /*        4 DS1DSCHA   BIT(1),         /* SAME AS DS1IND02  @G60ASBJ*/\n /*       3 DS1IND01    BIT(1),         /* RESERVED          @G60ASBJ*/\n         2 DS1SCALO,                    /* SECONDARY ALLOCATION      */\n           3 DS1STYPE BIT(8) ALIGNED,\n           3 DS1SQUAN BIT(24) ALIGNED,\n         2 DS1LSTAR,                    /* LAST USED TRACK AND LAST\n                                           BLOCK ON TRACK            */\n           3 DS1LRELTR FIXED BIN(15),\n           3 DS1LBLCK BIT(8) ALIGNED,\n         2 DS1TRBAL    FIXED BIN(15),   /* BYTES REMAINING ON LAST\n                                           TRACK USED                */\n         2 RSV00004    CHAR(2),         /* RESERVED                  */\n         2 DS1EXT1,                     /* FIRST EXTENT DESCRIPTION  */\n           3 DS1EX1TYP BIT(8) ALIGNED,  /* FIRST BYTE                */\n                                        /*   EXTENT TYPE INDICATOR   */\n           3 DS1EX1NUM BIT(8) ALIGNED,  /* SECOND BYTE               */\n                                        /*   EXTENT SEQUENCE NUMBER  */\n           3 DS1EX1LOW(2) FIXED BIN(15),/* THIRD - SIXTH BYTES       */\n                                        /*   LOWER LIMIT             */\n           3 DS1EX1HGH(2) FIXED BIN(15),/* SEVENTH - TENTH BYTES     */\n                                        /*   UPPER LIMIT            */\n         2 DS1EXT2,                     /* SECOND EXTENT DESCRIPTION */\n           3 DS1EX2TYP BIT(8) ALIGNED,  /* FIRST BYTE                */\n                                        /*   EXTENT TYPE INDICATOR   */\n           3 DS1EX2NUM BIT(8) ALIGNED,  /* SECOND BYTE               */\n                                        /*   EXTENT SEQUENCE NUMBER  */\n           3 DS1EX2LOW(2) FIXED BIN(15),/* THIRD - SIXTH BYTES       */\n                                        /*   LOWER LIMIT             */\n           3 DS1EX2HGH(2) FIXED BIN(15),/* SEVENTH - TENTH BYTES     */\n                                        /*   UPPER LIMIT            */\n         2 DS1EXT3,                     /* THIRD EXTENT DESCRIPTION  */\n           3 DS1EX3TYP BIT(8) ALIGNED,  /* FIRST BYTE                */\n                                        /*   EXTENT TYPE INDICATOR   */\n           3 DS1EX3NUM BIT(8) ALIGNED,  /* SECOND BYTE               */\n                                        /*   EXTENT SEQUENCE NUMBER  */\n           3 DS1EX3LOW(2) FIXED BIN(15),/* THIRD - SIXTH BYTES       */\n                                        /*   LOWER LIMIT             */\n           3 DS1EX3HGH(2) FIXED BIN(15),/* SEVENTH - TENTH BYTES     */\n                                        /*   UPPER LIMIT            */\n         2 DS1PTRDS,                    /* POSSIBLE PTR TO A FORMAT\n                                           2 OR 3 DSCB               */\n           3 DS1PTRCC FIXED BIN(15),    /* CYLINDER                  */\n           3 DS1PTRHH FIXED BIN(15),    /* HEAD                      */\n           3 DS1PTRR  BIT(8) ALIGNED,   /* RECORD                    */\n         2 DS1END      CHAR(0),         /* END OF THE FORMAT 1 DSCB  */\n       1 DS1REFD BASED(ADDR(DS1LGNID)), /* DATE LAST         @G60ASBJ*/\n         2 RSV10001   CHAR(14),         /*             FILLER        */\n         2 DS1REFYR   BIT(8) ALIGNED,   /* REFERENCED OR ZERO@G60ASBJ*/\n         2 DS1REFDA   FIXED BIN(15);    /* IF NOT MAINTAINED @G60ASBJ*/\n %F2: ;\n %IF FORMAT2 \u00ac= 'YES'                   /* IF FORMAT2 = YES, THEN    */\n     %THEN %GOTO F3;                    /* BUILD A FORMAT 2 DSCB     */\n /*                    FORMAT 2 DSCB                                 */\n DCL 1 IECSDSF2 BASED(F2PTR),           /* FORMAT 2 DSCB - DESCRIBED */\n         2 RSV00005    CHAR(140);       /* IN THE FOLLOWING STRUCTURE*/\n DCL 1 IECSDSL2 BASED(ADDR(IECSDSF2))   /* START OF THE FORMAT 2 DSCB*/\n                UNALIGNED,\n         2 RSV00006    CHAR(1),         /* KEY IDENTIFIER            */\n         2 DS22MIND,                    /* ADDRESS OF 2ND LEVEL\n                                           MASTER INDEX              */\n           3 DS22MM  BIT(8) ALIGNED,    /* M                         */\n           3 DS22MBB FIXED BIN(15),     /* BB                        */\n           3 DS22MCC FIXED BIN(15),     /* CC                        */\n           3 DS22MHH FIXED BIN(15),     /* HH                        */\n         2 DS2L2MEN,                    /* LAST 2ND LEVEL MASTER\n                                           INDEX ENTRY               */\n           3 DS2L2CC FIXED BIN(15),     /* CC                        */\n           3 DS2L2HH FIXED BIN(15),     /* HH                        */\n           3 DS2L2R  BIT(8) ALIGNED,    /* R                         */\n         2 DS23MIND,                    /* ADDRESS OF 3RD LEVEL\n                                           MASTER INDEX              */\n           3 DS22MM  BIT(8) ALIGNED,    /* M                         */\n           3 DS22MBB FIXED BIN(15),     /* BB                        */\n           3 DS22MCC FIXED BIN(15),     /* CC                        */\n           3 DS22MHH FIXED BIN(15),     /* HH                        */\n         2 DS2L3MIN,                    /* LAST 3RD LEVEL MASTER\n                                           INDEX ENTRY               */\n           3 DS2L3CC FIXED BIN(15),     /* CC                        */\n           3 DS2L3HH FIXED BIN(15),     /* HH                        */\n           3 DS2L3R  BIT(8) ALIGNED,    /* R                         */\n         2 RSV00007    CHAR(11),        /* RESERVED                  */\n         2 DS2LPDT     CHAR(8),         /* LAST PRIME TRACK ON THE\n                                           LAST PRIME CYLINDER       */\n         2 DS2FMTID    CHAR(1),         /* FORMAT IDENTIFIER         */\n         2 DS2NOLEV    BIT(8) ALIGNED,  /* NUMBER OF INDEX LEVELS    */\n         2 DS2DVIND    BIT(8) ALIGNED,  /* HIGH LEVEL INDEX\n                                           DEVELOPMENT INDICATOR     */\n         2 DS21RCYL,                    /* FIRST DATA RECORD ON\n                                           EACH CYLINDER             */\n           3 DS21RHH FIXED BIN(15),     /* HH                        */\n           3 DS21RR  BIT(8) ALIGNED,    /* R                         */\n         2 DS2LTCYL    FIXED BIN(15),   /* LAST DATA TRACK ON\n                                           EACH CYLINDER             */\n         2 DS2CYLOV    BIT(8) ALIGNED,  /* NUMBER OF TRACKS FOR\n                                           CYLINDER OVERFLOW         */\n         2 DS2HIRIN    BIT(8) ALIGNED,  /* HIGHEST 'R' ON HIGH-LEVEL\n                                           INDEX TRACK               */\n         2 DS2HIRPR    BIT(8) ALIGNED,  /* HIGHEST 'R' ON PRIME\n                                           DATA TRACKS               */\n         2 DS2HIROV    BIT(8) ALIGNED,  /* HIGHEST 'R' ON OVERFLOW\n                                           DATA TRACKS               */\n         2 DS2RSHTR    BIT(8) ALIGNED,  /* 'R' OF LAST DATA RECORD\n                                           ON A SHARED TRACK         */\n         2 DS2HIRTI    BIT(8) ALIGNED,  /* HIGHEST 'R' ON UNSHARED\n                                           TRACK OF THE TRACK INDEX  */\n         2 DS2HIIOV    BIT(8) ALIGNED,  /* HIGHEST 'R' FOR INDEPENDENT\n                                           OVERFLOW DATA TRACKS      */\n         2 DS2TAGDT    FIXED BIN(15),   /* TAG DELETION COUNT        */\n         2 DS2RORG3    BIT(24) ALIGNED, /* NON-FIRST OVERFLOW\n                                           REFERENCE COUNT           */\n         2 DS2NOBYT    FIXED BIN(15),   /* NUMBER OF BYTES FOR\n                                           HIGHEST-LEVEL INDEX       */\n         2 DS2NOTRK    BIT(8) ALIGNED,  /* NUMBER OF TRACKS FOR\n                                           HIGHEST-LEVEL INDEX       */\n         2 DS2PRCTR    FIXED BIN(31),   /* PRIME RECORD COUNT        */\n         2 DS2STIND    BIT(8) ALIGNED,  /* STATUS INDICATORS         */\n         2 DS2CYLAD,                    /* ADDRESS OF CYLINDER INDEX */\n           3 DS2CYLM BIT(8) ALIGNED,    /* M                         */\n           3 DS2CYLBB FIXED BIN(15),    /* BB                        */\n           3 DS2CYLCC FIXED BIN(15),    /* CC                        */\n           3 DS2CYLHH FIXED BIN(15),    /* HH                        */\n         2 DS2ADLIN,                    /* ADDRESS OF LOWEST LEVEL\n                                           MASTER INDEX              */\n           3 DS2ADLM BIT(8) ALIGNED,    /* M                         */\n           3 DS2ADLBB FIXED BIN(15),    /* BB                        */\n           3 DS2ADLCC FIXED BIN(15),    /* CC                        */\n           3 DS2ADLHH FIXED BIN(15),    /* HH                        */\n         2 DS2ADHIN,                    /* ADDRESS OF HIGHEST LEVEL\n                                           MASTER INDEX              */\n           3 DS2ADHM  BIT(8) ALIGNED,   /* M                         */\n           3 DS2ADHBB FIXED BIN(15),    /* BB                        */\n           3 DS2ADHCC FIXED BIN(15),    /* CC                        */\n           3 DS2ADHHH FIXED BIN(15),    /* HH                        */\n         2 DS2LPRAD,                    /* LAST PRIME DATA RECORD\n                                           ADDRESS                   */\n           3 DS2LPRM  BIT(8) ALIGNED,   /* M                         */\n           3 DS2LPRBB FIXED BIN(15),    /* BB                        */\n           3 DS2LPRCC FIXED BIN(15),    /* CC                        */\n           3 DS2LPRHH FIXED BIN(15),    /* HH                        */\n           3 DS2LPRR  BIT(8) ALIGNED,   /* R                         */\n         2 DS2LTRAD,                    /* LAST TRACK INDEX ENTRY\n                                           ADDRESS                   */\n           3 DS2LTRCC FIXED BIN(15),    /* CC                        */\n           3 DS2LTRHH FIXED BIN(15),    /* HH                        */\n           3 DS2LTRR  BIT(8) ALIGNED,   /* R                         */\n         2 DS2LCYAD,                    /* LAST CYLINDER INDEX\n                                           ENTRY ADDRESS             */\n           3 DS2LCYCC FIXED BIN(15),    /* CC                        */\n           3 DS2LCYHH FIXED BIN(15),    /* HH                        */\n           3 DS2LCYR  BIT(8) ALIGNED,   /* R                         */\n         2 DS2LMSAD,                    /* LAST MASTER INDEX ENTRY\n                                           ADDRESS                   */\n           3 DS2LMSCC FIXED BIN(15),    /* CC                        */\n           3 DS2LMSHH FIXED BIN(15),    /* HH                        */\n           3 DS2LMSR  BIT(8) ALIGNED,   /* R                         */\n         2 DS2LOVAD,                    /* LAST INDEPENDENT OVERFLOW\n                                           RECORD ADDRESS            */\n           3 DS2LOVM  BIT(8) ALIGNED,   /* M                         */\n           3 DS2LOVBB FIXED BIN(15),    /* BB                        */\n           3 DS2LOVCC FIXED BIN(15),    /* CC                        */\n           3 DS2LOVHH FIXED BIN(15),    /* HH                        */\n           3 DS2LOVR  BIT(8) ALIGNED,   /* R                         */\n         2 DS2BYOVL    FIXED BIN(15),   /* BYTES REMAINING ON\n                                           OVERFLOW TRACK            */\n         2 DS2RORG2    FIXED BIN(15),   /* TRACKS REMAINING IN\n                                           INDEPENDENT OVERFLOW AREA */\n         2 DS2OVRCT    FIXED BIN(15),   /* OVERFLOW RECORD COUNT     */\n         2 DS2RORG1    FIXED BIN(15),   /* CYLINDER OVERFLOW AREA\n                                           COUNT                     */\n         2 DS2NIRT,                     /* DUMMY TRACK INDEX ENTRY\n                                           ADDRESS                   */\n           3 DS2NIRHH FIXED BIN(15),    /* HH                        */\n           3 DS2NIRR  BIT(8) ALIGNED,   /* R                         */\n         2 DS2PTRDS,                    /* POSSIBLE POINTER TO A\n                                           FORMAT 3 DSCB             */\n           3 DS2PTRCC FIXED BIN(15),    /* CYLINDER                  */\n           3 DS2PTRHH FIXED BIN(15),    /* HEAD                      */\n           3 DS2PTRR  BIT(8) ALIGNED,   /* RECORD                    */\n         2 DS2END      CHAR(0);         /* END OF THE FORMAT 2 DSCB  */\n %F3: ;\n %IF FORMAT3 \u00ac= 'YES'                   /* IF FORMAT3 = YES, THEN    */\n     %THEN %GOTO F4;                    /* BUILD A FORMAT 3 DSCB     */\n /*                    FORMAT 3 DSCB                                 */\n DCL 1 IECSDSF3 BASED(F3PTR),           /* FORMAT 3 DSCB - DESCRIBED */\n         2 RSV00008    CHAR(140);       /* IN THE FOLLOWING STRUCTURE*/\n DCL 1 IECSDSL3 BASED(ADDR(IECSDSF3))   /* START OF THE FORMAT 3 DSCB*/\n                UNALIGNED,\n         2 RSV00009    CHAR(4),         /* KEY IDENTIFIER            */\n         2 DS3EXTNT(4),                 /* FOUR EXTENT DESCRIPTIONS  */\n           3 DS3EXTTYP BIT(8) ALIGNED,  /* FIRST BYTE                */\n                                        /*   EXTENT TYPE INDICATOR   */\n           3 DS3EXTNUM BIT(8) ALIGNED,  /* SECOND BYTE               */\n                                        /*   EXTENT SEQUENCE NUMBER  */\n           3 DS3EXTLOW(2) FIXED BIN(15),/* THIRD - SIXTH BYTES       */\n                                        /*   LOWER LIMIT             */\n           3 DS3EXTHGH(2) FIXED BIN(15),/* SEVENTH - TENTH BYTES     */\n                                        /*   UPPER LIMIT            */\n         2 DS3FMTID    CHAR(1),         /* FORMAT IDENTIFIER         */\n         2 DS3ADEXT(9),                 /* NINE ADDITIONAL EXTENT\n                                           DESCRIPTIONS              */\n           3 DS3ADTYP BIT(8) ALIGNED,   /* FIRST BYTE                */\n                                        /*   EXTENT TYPE INDICATOR   */\n           3 DS3ADNUM BIT(8) ALIGNED,   /* SECOND BYTE               */\n                                        /*   EXTENT SEQUENCE NUMBER  */\n           3 DS3ADLOW(2) FIXED BIN(15), /* THIRD - SIXTH BYTES       */\n                                        /*   LOWER LIMIT             */\n           3 DS3ADHGH(2) FIXED BIN(15), /* SEVENTH - TENTH BYTES     */\n                                        /*   UPPER LIMIT            */\n         2 DS3PTRDS CHAR(5),            /* RESERVED                  */\n         2 DS3END      CHAR(0);         /* END OF THE FORMAT 3 DSCB  */\n %F4: ;\n %IF FORMAT4 \u00ac= 'YES'                   /* IF FORMAT4 = YES, THEN    */\n     %THEN %GOTO F5;                    /* BUILD A FORMAT 4 DSCB     */\n /*                    FORMAT 4 DSCB                                 */\n DCL 1 IECSDSF4 BASED(F4PTR),           /* FORMAT 4 DSCB - DESCRIBED */\n         2 RSV00010    CHAR(96);        /* IN THE FOLLOWING STRUCTURE*/\n DCL 1 IECSDSL4 BASED(ADDR(IECSDSF4))   /* START OF THE FORMAT 4 DSCB*/\n                UNALIGNED,\n         2 DS4IDFMT    CHAR(1),         /* FORMAT IDENTIFIER         */\n         2 DS4HPCHR,                    /* HIGHEST ADDRESS OF A\n                                           FORMAT 1 DSCB             */\n           3 DS4HPCCC FIXED BIN(15),    /* CC                        */\n           3 DS4HPCHH FIXED BIN(15),    /* HH                        */\n           3 DS4HPCR  BIT(8) ALIGNED,   /* R                         */\n         2 DS4DSREC    FIXED BIN(15),   /* NUMBER OF AVAILABLE DSCB'S*/\n         2 DS4HCCHH,                    /* CCHH OF NEXT AVAILABLE\n                                           ALTERNATE TRACK           */\n           3 DS4HCC   FIXED BIN(15),    /* CC                        */\n           3 DS4HHH   FIXED BIN(15),    /* HH                        */\n         2 DS4NOATK    FIXED BIN(15),   /* NUMBER OF REMAINING\n                                           ALTERNATE TRACKS          */\n         2 DS4VTOCI    BIT(8) ALIGNED,  /* VTOC INDICATORS           */\n         2 DS4NOEXT    BIT(8) ALIGNED,  /* NUMBER OF EXTENTS IN VTOC */\n         2 RSV00011    CHAR(2),         /* RESERVED                  */\n         2 DS4DEVCT,                    /* DEVICE CONSTANTS          */\n          3 DS4DEVSZ,                   /* DEVICE SIZE               */\n            4 DS4DVCYL FIXED BIN(15),   /* NUMBER OF CYLINDERS       */\n            4 DS4DVTRK FIXED BIN(15),   /* NUMBER OF TRACKS/CYLINDER */\n          3 DS4DEVTK    FIXED BIN(15),  /* DEVICE TRACK LENGTH       */\n          3 DS4DEVOV,                   /* KEYED RECORD OVERHEAD     */\n           4 DS4DEVI     BIT(8) ALIGNED, /* - NON-LAST KEYED RECORD\n                                             OVERHEAD                */\n           4 DS4DEVL     BIT(8) ALIGNED, /* - LAST KEYED RECORD\n                                             OVERHEAD                */\n          3 DS4DEVK     BIT(8) ALIGNED, /* NON-KEYED RECORD OVERHEAD\n                                           DIFFERENTIAL              */\n          3 DS4DEVFG    BIT(8) ALIGNED, /* FLAG BYTE                 */\n          3 DS4DEVTL    FIXED BIN(15),  /* DEVICE TOLERANCE          */\n          3 DS4DEVDT    BIT(8) ALIGNED, /* NUMBER OF DSCB'S PER TRACK*/\n          3 DS4DEVDB    BIT(8) ALIGNED, /* NUMBER OF DIRECTORY\n                                           BLOCKS PER TRACK          */\n         2 DS4AMTIM    CHAR(8),         /* VSAM TIME STAMP           */\n         2 DS4AMCAT,                    /* VSAM CATALOG INDICATOR    */\n          3 DS4VSIND,                   /* VSAM INDICATORS           */\n           4 DS4VSREF    BIT(1),        /* A VSAM CATALOG REFERENCES\n                                           THIS VOLUME               */\n           4 DS4VSBAD    BIT(1),        /* VSAM DATA SETS ON VOLUME\n                                           ARE UNUSABLE              */\n           4 RSV40001    BIT(6),        /* RESERVED                  */\n          3 DS4VSCRA   CHAR(16),        /* RELATIVE TRACK LOCATION\n                                           OF THE CRA                */\n         2 DS4R2TIM    CHAR(8),         /* VSAM VOLUME/CATALOG MATCH\n                                           TIME STAMP                */\n         2 RSV00012    CHAR(5),         /* RESERVED                  */\n         2 DS4F6PTR,                    /* POINTER TO FIRST FORMAT\n                                           6 DSCB                    */\n           3 DS4F6CC  FIXED BIN(15),    /* CC                        */\n           3 DS4F6HH  FIXED BIN(15),    /* HH                        */\n           3 DS4F6R   BIT(8) ALIGNED,   /* R                         */\n         2 DS4VTOCE,                    /* VTOC EXTENT DESCRIPTION   */\n           3 DS4VTTYP BIT(8) ALIGNED,   /* FIRST BYTE                */\n                                        /*   EXTENT TYPE INDICATOR   */\n           3 DS4VTNUM BIT(8) ALIGNED,   /* SECOND BYTE               */\n                                        /*   EXTENT SEQUENCE NUMBER  */\n           3 DS4VTLOW(2) FIXED BIN(15), /* THIRD - SIXTH BYTES       */\n                                        /*   LOWER LIMIT             */\n           3 DS4VTHGH(2) FIXED BIN(15), /* SEVENTH - TENTH BYTES     */\n                                        /*   UPPER LIMIT            */\n         2 RSV00013    CHAR(25),        /* RESERVED                  */\n         2 DS4END      CHAR(0);         /* END OF THE FORMAT 4 DSCB  */\n %F5: ;\n %IF FORMAT5 \u00ac= 'YES'                   /* IF FORMAT5 = YES, THEN    */\n     %THEN %GOTO F6;                    /* BUILD A FORMAT 5 DSCB     */\n /*                    FORMAT 5 DSCB                                 */\n DCL 1 IECSDSF5 BASED(F5PTR),           /* FORMAT 5 DSCB - DESCRIBED */\n         2 RSV00014    CHAR(140);       /* IN THE FOLLOWING STRUCTURE*/\n DCL 1 IECSDSL5 BASED(ADDR(IECSDSF5))   /* START OF THE FORMAT 5 DSCB*/\n                UNALIGNED,\n         2 DS5KEYID    CHAR(4),         /* KEY IDENTIFIER            */\n         2 DS5AVEXT,                    /* AVAILABLE EXTENT          */\n           3 DS5AVRTR  FIXED BIN(15),   /* BYTES 1 - 2               */\n                                        /*   RELATIVE TRACK ADDRESS  */\n                                        /*   OF THE FIRST TRACK IN   */\n                                        /*   THE EXTENT              */\n           3 DS5AVCYL  FIXED BIN(15),   /* BYTES 3 - 4               */\n                                        /*   NUMBER OF UNUSED        */\n                                        /*   CYLINDERS IN THE EXTENT */\n           3 DS5AVTRK  FIXED BIN(15),   /* BYTE 5                    */\n                                        /*   NUMBER OF ADDITIONAL    */\n                                        /*   UNUSED TRACKS           */\n         2 DS5EXTAV(7),                 /* SEVEN AVAILABLE EXTENTS   */\n           3 DS5EXRTR  FIXED BIN(15),   /* BYTES 1 - 2               */\n                                        /*   RELATIVE TRACK ADDRESS  */\n                                        /*   OF THE FIRST TRACK IN   */\n                                        /*   THE EXTENT              */\n           3 DS5EXCYL  FIXED BIN(15),   /* BYTES 3 - 4               */\n                                        /*   NUMBER OF UNUSED        */\n                                        /*   CYLINDERS IN THE EXTENT */\n           3 DS5EXTRK  FIXED BIN(15),   /* BYTE 5                    */\n                                        /*   NUMBER OF ADDITIONAL    */\n                                        /*   UNUSED TRACKS           */\n         2 DS5FMTID    CHAR(1),         /* FORMAT IDENTIFIER         */\n         2 DS5MAVET(18),                /* EIGHTEEN AVAILABLE EXTENTS*/\n           3 DS5MARTR  FIXED BIN(15),   /* BYTES 1 - 2               */\n                                        /*   RELATIVE TRACK ADDRESS  */\n                                        /*   OF THE FIRST TRACK IN   */\n                                        /*   THE EXTENT              */\n           3 DS5MACYL  FIXED BIN(15),   /* BYTES 3 - 4               */\n                                        /*   NUMBER OF UNUSED        */\n                                        /*   CYLINDERS IN THE EXTENT */\n           3 DS5MATRK  FIXED BIN(15),   /* BYTE 5                    */\n                                        /*   NUMBER OF ADDITIONAL    */\n                                        /*   UNUSED TRACKS           */\n         2 DS5PTRDS    CHAR(5),         /* POINTER TO NEXT FORMAT 5\n                                           DSCB                      */\n           3 DS5PTRCC FIXED BIN(15),    /* CYLINDER                  */\n           3 DS5PTRHH FIXED BIN(15),    /* HEAD                      */\n           3 DS5PTRR  BIT(8) ALIGNED,   /* RECORD                    */\n         2 DS5END      CHAR(0);         /* END OF THE FORMAT 5 DSCB  */\n %F6: ;\n %IF FORMAT6 \u00ac= 'YES'                   /* IF FORMAT6 = YES, THEN    */\n     %THEN %GOTO MACROEND;              /* BUILD A FORMAT 6 DSCB     */\n /*                    FORMAT 6 DSCB                                 */\n DCL 1 IECSDSF6 BASED(F6PTR),           /* FORMAT 6 DSCB - DESCRIBED */\n         2 RSV00015    CHAR(140);       /* IN THE FOLLOWING STRUCTURE*/\n DCL 1 IECSDSL6 BASED(ADDR(IECSDSF6))   /* START OF THE FORMAT 6 DSCB*/\n                UNALIGNED,\n         2 DS6KEYID    CHAR(4),         /* KEY IDENTIFIER            */\n         2 DS6AVEXT    CHAR(5),         /* SHARED EXTENT DESCRIPTION\n           3 DS6AVRTR  FIXED BIN(15),   /* BYTES 1 - 2               */\n                                        /*   RELATIVE TRACK ADDRESS  */\n                                        /*   OF THE FIRST CYLINDER   */\n           3 DS6AVCYL  FIXED BIN(15),   /* BYTES 3 - 4               */\n                                        /*   NUMBER OF FULL          */\n                                        /*   CYLINDERS BEING SHARED  */\n           3 DS6AVDS   FIXED BIN(15),   /* BYTE 5                    */\n                                        /*   NUMBER OF DATA SETS     */\n                                        /*   SHARING THE EXTENT      */\n         2 DS6EXTAV(7),                 /* SEVEN SHARED EXTENTS      */\n           3 DS6EXRTR  FIXED BIN(15),   /* BYTES 1 - 2               */\n                                        /*   RELATIVE TRACK ADDRESS  */\n                                        /*   OF THE FIRST CYLINDER   */\n           3 DS6EXCYL  FIXED BIN(15),   /* BYTES 3 - 4               */\n                                        /*   NUMBER OF FULL          */\n                                        /*   CYLINDERS BEING SHARED  */\n           3 DS6EXDS   FIXED BIN(15),   /* BYTE 5                    */\n                                        /*   NUMBER OF DATA SETS     */\n                                        /*   SHARING THE EXTENT      */\n         2 DS6FMTID    CHAR(1),         /* FORMAT IDENTIFIER         */\n         2 DS6MAVET(18),                /* EIGHTEEN SHARED EXTENTS   */\n           3 DS6MARTR  FIXED BIN(15),   /* BYTES 1 - 2               */\n                                        /*   RELATIVE TRACK ADDRESS  */\n                                        /*   OF THE FIRST CYLINDER   */\n           3 DS6MACYL  FIXED BIN(15),   /* BYTES 3 - 4               */\n                                        /*   NUMBER OF FULL          */\n                                        /*   CYLINDERS BEING SHARED  */\n           3 DS6MADS   FIXED BIN(15),   /* BYTE 5                    */\n                                        /*   NUMBER OF DATA SETS     */\n                                        /*   SHARING THE EXTENT      */\n         2 DS6PTRDS,                    /* POINTER TO NEXT FORMAT 6\n                                           DSCB                      */\n           3 DS6PTRCC FIXED BIN(15),    /* CYLINDER                  */\n           3 DS6PTRHH FIXED BIN(15),    /* HEAD                      */\n           3 DS6PTRR  BIT(8) ALIGNED,   /* RECORD                    */\n         2 DS6END      CHAR(0);         /* END OF THE FORMAT 6 DSCB  */\n %MACROEND:;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEEMB846": {"ttr": 4877, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         TSOTABLE &N\n         LCLA  &I\nIEEMB846 CSECT\n         DC    AL4(&N)\n         DC    F'0'\n.LOOP    ANOP\n&I       SETA  &I+1\n         DC    CL8'0&I'\n         AIF   (&I LT &N).LOOP\n         MEND\n         TSOTABLE 200\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IKJEXTEN": {"ttr": 5121, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   IKJEXTEN &TYPNAM,&TYPE,&OPTION,&OPTION2,&OPTION3,             *\n               &PROMPT=,&DEFAULT=,&HELP=,&VALIDCK=,&PARM=\n.*       THIS MACRO IS A MODIFIED VERSION OF THE SVS IKJIDENT\n.* RELEASE 20 SUPPORT CODE -- 20035\n.* A 007320,007340,007360,007380,005920,005940,005960,005980      R0301\n.* NOTE: FLAGGING CODES: R=DCRR,A=APAR,F=PTF,M=PTM,S=SUPPORT CODE R0301\n         GBLC  &IKJCSNM,&IKJDSNM\n         GBLB  &CLUXTEN\n         LCLA  &T,&PDESIZE,&END\n         LCLB  &FLIST,&FRANGE,&FASIS,&FPRPT,&FDFLT\n         LCLB  &FHELP,&FVALID,&FENDBIT\n         LCLC  &BADFRST,&QUOTE\n&FENDBIT SETB  0\n         AIF   (N'&SYSLIST LT 6).GOOD\n         MNOTE 8,'NO MORE THAN 5 POSITIONAL PARAMETERS ALLOWED'\n.GOOD    AIF   ('&TYPNAM' EQ 'LIST' OR '&TYPNAM' EQ 'RANGE').BAD\n         AIF   ('&TYPNAM' NE 'UPPERCASE' AND '&TYPNAM' NE 'ASIS'       *\n               AND '&TYPNAM' NE '').GOOD1\n.BAD     MNOTE 8,'PARAMETER TYPE NAME MISSING BUT REQUIRED'\n&FENDBIT SETB  1\n.GOOD1   ANOP\n         AIF   ('&TYPE' NE 'LIST' AND '&TYPE' NE 'RANGE' AND '&TYPE' NE*\n               'ASIS' AND '&TYPE' NE 'UPPERCASE' AND '&TYPE' NE '').BET*\n               TER\n         MNOTE 8,'RECOGNIZER NAME MISSING BUT REQUIRED'\n.BETTER  ANOP\n         AIF   ('&IKJCSNM' NE '').GOOD2\n         MNOTE 8,'CSECT NAME (FROM IKJPARM MACRO LABEL) IS MISSING'\n&FENDBIT SETB  1\n.GOOD2   ANOP\n         AIF   ('&LABEL' NE '').GOOD3\n         MNOTE 8,'STATEMENT LABEL MISSING BUT REQUIRED'\n&FENDBIT SETB  1\n.GOOD3   ANOP\n&FLIST   SETB  ('&OPTION' EQ 'LIST' OR '&OPTION2' EQ 'LIST' OR         *\n               '&OPTION3' EQ 'LIST')\n&FRANGE  SETB  ('&OPTION' EQ 'RANGE' OR '&OPTION2' EQ 'RANGE' OR       *\n               '&OPTION3' EQ 'RANGE')\n&FASIS   SETB  ('&OPTION' EQ 'ASIS' OR '&OPTION2' EQ 'ASIS' OR         *\n               '&OPTION3' EQ 'ASIS')\n         AIF   ('&OPTION' EQ '' OR '&OPTION' EQ 'LIST' OR '&OPTION'    *\n               EQ 'RANGE' OR '&OPTION' EQ 'ASIS' OR '&OPTION'          *\n               EQ 'UPPERCASE').OPT1\n         MNOTE 8,'''&OPTION'' IS AN INVALID POSITIONAL PARAMETER'\n&FENDBIT SETB  1\n.OPT1    AIF   ('&OPTION2' EQ '' OR '&OPTION2' EQ 'LIST' OR '&OPTION2' *\n               EQ 'RANGE' OR '&OPTION2' EQ 'ASIS' OR '&OPTION2' EQ     *\n               'UPPERCASE').OPT2\n         MNOTE 8,'''&OPTION2'' IS AN INVALID POSITIONAL PARAMETER'\n&FENDBIT SETB  1\n.OPT2    AIF   ('&OPTION3' EQ '' OR '&OPTION3' EQ 'LIST' OR '&OPTION3' *\n               EQ 'RANGE' OR '&OPTION3' EQ 'ASIS' OR '&OPTION3' EQ     *\n               'UPPERCASE').OPT3\n         MNOTE 8,'''&OPTION3'' IS AN INVALID POSITIONAL PARAMETER'\n&FENDBIT SETB  1\n.OPT3    AIF   (('&OPTION' EQ 'UPPERCASE' OR '&OPTION2' EQ             *\n               'UPPERCASE' OR '&OPTION3' EQ 'UPPERCASE') AND &FASIS).ER*\n               ROR0\n         AGO   .A0\n.ERROR0  MNOTE 8,'BOTH ''UPPERCASE'' AND ''ASIS'' CANNOT BE SPECIFIED'\n&FENDBIT SETB  1\n.A0      ANOP\n&FPRPT   SETB  ('&PROMPT' NE '')\n&FDFLT   SETB  ('&DEFAULT' NE '')\n&FHELP   SETB  ('&HELP' NE '')\n&FVALID  SETB  ('&VALIDCK' NE '')\n         AIF   (NOT(&FDFLT AND &FPRPT)).GOOD4\n         MNOTE 8,'PARAMETER CANNOT BOTH DEFAULT AND REQUIRE PROMPTING'\n&FENDBIT SETB  1\n.GOOD4   ANOP\n         AIF   (NOT(&FENDBIT)).GEN     IF ERRORS DO NOT GENERATE CODE\n         MEXIT\n.GEN     ANOP\n         AIF   (&CLUXTEN).NONOTE\n         MNOTE 0,'WARNING: THE IKJEXTEN MACRO IS AN EXTENSION TO IBM TS*\n               O'\n&CLUXTEN SETB  (1)\n.NONOTE  ANOP\n&IKJCSNM CSECT ,                       RESUME PCL CSECT\n* FLAGS -    BIT3=PROMPT,  BIT4=DEFAULT,  BIT5=IKJEXTEN,  BIT6=HELP,\n*            BIT7=VALIDCK, BIT8=LIST,     BIT9=ASIS,      BIT10=RANGE\nDENT&SYSNDX EQU *\n         DC    BL2'100&FPRPT&FDFLT.1&FHELP&FVALID&FLIST&FASIS&FRANGE.00*\n               000'                    FLAGS\n         DC    AL2(DEND&SYSNDX-DENT&SYSNDX) LENGTH OF PCE\n         DC    AL2(&LABEL-&IKJDSNM)    OFFSET TO PDE\n         DC    AL3(&TYPE)         USER RECOGNIZER ROUTINE ADDR\n.*\n.* THE FOLLOWING CODE SUPPLIES QUOTES TO &TYPNAM IF THEY ARE MISSING.\n.*\n&QUOTE   SETC  '&TYPNAM'(1,1)\n         AIF   ('&QUOTE' EQ '''').QUOT\n&QUOTE   SETC  ''''\n         DC    AL2(IKJ@&SYSNDX-*),AL2(18),C&QUOTE&TYPNAM&QUOTE PARAMETE*\n               R TYPE MESSAGE SEGMENT\n         AGO   .EQUGEN1\n.QUOT    ANOP\n         DC    AL2(IKJ@&SYSNDX-*),AL2(18),C&TYPNAM PARAMETER TYPE MESSA*\n               GE SEGMENT\n.EQUGEN1 ANOP\nIKJ@&SYSNDX EQU *\n         AIF   (&FPRPT).PRPT           PROMPT SPECIFIED\n         AIF   (NOT &FDFLT).NPRDF\n         DC    AL1(IKJ$&SYSNDX-*-2),C&DEFAULT DEFAULT DATA\n         AGO   .EQUGEN\n.PRPT    DC    AL1(IKJ$&SYSNDX-*-2),C&PROMPT PROMPT DATA\n.EQUGEN  ANOP\nIKJ$&SYSNDX EQU *\n.NPRDF   ANOP\n         AIF   (NOT &FHELP).NOHELP     IS HELP SPECIFIED\n         DC    AL2(IKJA&SYSNDX-*)      LENGTH OF HELP DATA\n&T       SETA  1                       SET &T FOR LOOP CONTROL\n.HELPLP  ANOP\n&T       SETA  &T+1\n         AIF   (&T EQ 10).HELPER\n         AIF   (&T LE N'&HELP).HELPLP\n         AGO   .HELPCT\n.HELPER  MNOTE 4,'ONLY 9 LEVELS OF HELP AVAILABLE. OTHERS IGNORED'\n&T       SETA  &T+1                    PROVIDE FOR DECREMENT\n.HELPCT  ANOP\n&T       SETA  &T-1\n         DC    AL1(&T)                 NUMBER OF HELP MESSAGES\n&END     SETA  &T\n&T       SETA  1\n.HELPLPA ANOP\n         DC    AL2(IKJ&SYSNDX.&T-*),AL2(00),C&HELP(&T) HELP MSG SEGMENT\nIKJ&SYSNDX.&T  EQU *\n&T       SETA  &T+1\n         AIF   (&T LE &END).HELPLPA\nIKJA&SYSNDX EQU *\n.NOHELP  ANOP\n         DC    AL2(IKJ#&SYSNDX-*-2)    LENGTH OF RECOGNIZER PARM\n         AIF   ('&PARM' EQ '').NOPARM\n&QUOTE   SETC  '&PARM'(1,1)\n         AIF   ('&QUOTE' EQ '''').RQUOT\n         DC    C'&PARM'           RECOGNIZER PARAMETER STRING\n         AGO   .NOPARM\n.RQUOT   DC    C&PARM             RECOGNIZER PARAMETER STRING\n.NOPARM        ANOP\nIKJ#&SYSNDX EQU *\n         AIF   (NOT &FVALID).NOVALID   IS VALIDCK SPECIFIED\n         DC    AL3(&VALIDCK)           VALIDCK ROUTINE ADDRESS\n.NOVALID ANOP\nDEND&SYSNDX EQU *\n&IKJDSNM DSECT\n&PDESIZE SETA  5\n         AIF   (&FLIST AND &FRANGE).DSECT IS LIST AND RANGE SPECIFIED\n&PDESIZE SETA  4\n         AIF   (&FRANGE).DSECT\n&PDESIZE SETA  3\n         AIF   (&FLIST).DSECT\n&PDESIZE SETA  2\n.DSECT   ANOP\n&LABEL   DS    &PDESIZE.A              ALLOCATE PDE SPACE\n&SYSECT  CSECT ,                       RESUME USERS CSECT\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INT18@": {"ttr": 5125, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "1\n-\n0                  INSTITUTE FOR COMPUTER SERVICES AND APPLICATIONS\n0                                  RICE UNIVERSITY\n0                                  22 October 1980\n0                                Document No. INT018\n0                      Requirements for Local MVS TSO Commands\n-       The extensions to TSO provided with MVS impose new requirements on\n        local TSO commands.  In particular, some effort is required to write a\n        command processor so that it will behave reasonably within a CLIST and\n        in batch (under a batch TMP).  To satisfy these requirements, it is\n        necessary for a command to (a) use the I/O service routines PUTLINE\n        and PUTGET in place of TPUT and TGET for user communication, (b)\n        establish a meaningful return code upon completion, and (c) flush\n        CLIST and terminal input after a significant error.  These three\n        topics are discussed in detail below.  For more information on the IBM\n        macros and service routines discussed in this document, please see the\n        IBM manual Guide to Writing a TSO Terminal Monitor Program or Command\n+                  _____ __ _______ _ ___ ________ _______ _______ __ _______\n        Processor.\n+       _________\n-       USER COMMUNICATION\n0       The use of TPUT in a command processor for output of messages or data\n        will cause the following problems:\n0            .  All such output will be lost in batch.\n             .  Such output will not be suppressed by the CLIST option NOMSG.\n0       For these reasons, PUTLINE should be used in place of TPUT, except for\n        functions not supported by PUTLINE, such as messages to another user\n        or 3270 full-screen output.  Note that the choice between the DATA and\n        INFOR options of PUTLINE should be considered carefully, as only\n        PUTLINE INFOR messages are suppressed by the NOMSG option.\n0       Because the use of PUTLINE can often be cumbersome, an easy-to-use\n        ICSA-written macro UPUT is available (in RICE.MACLIB) to interface to\n      | the PUTLINE service routine.  This macro calls a reentrant routine\n      | named UKJUPUT, which builds PUTLINE parameters and invokes the service\n        routine.  The UKJUPUT load module may be found in the data set\n        RICE.TSOSERV.LOAD.\n0       The syntax of the UPUT macro is as follows:\n0            \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n+                        \u00af           \u00af\n             |           |           |                                  |\n             |  LABEL    |  MACRO    |    OPERANDS                      |\n             |           |           |                                  |\n             |\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\n+            \u00bf           \u00d7           \u00d7                                  ]\n             |           |           |                                  |\n             |  \u00ddlabel\u00a8  |  UPUT     |    buffer,length                 |\n             |           |           |    .                             |\n             |           |           |    \u00d0               \u00af             |\n             |           |           |    | ,TPUT-options |             |\n             |           |           |    \u00bf               ]             |\n             |           |           |    \u00d0        \u00af                    |\n             |           |           |    | ,INFOR |                    |\n+                                            _____\n             |           |           |    | ,DATA  |                    |\n             |           |           |    \u00bf        ]                    |\n             |           |           |    \u00d0                         \u00af   |\n             |           |           |    | ,HELP=(buffer\u00dd,length\u00a8) |   |\n             |           |           |    \u00bf                         ]   |\n      |      |           |           |    \u00d0                    \u00af        |\n      |      |           |           |    | ,CPPL=CPPL-address |        |\n      |      |           |           |    | ,IOPL=IOPL-address |        |\n      |      |           |           |    \u00bf                    ]        |\n      |      |           |           |    \u00d0                \u00af            |\n      |      |           |           |    | ,MF=macro-form |            |\n      |      |           |           |    \u00bf                ]            |\n             |           |           |                                  |\n             \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n+                        \u00bf           \u00bf\n0       buffer - addresses the message to be output.  For an informational\n1\n        INT018                                                          Page 2\n-\n             message, the text should include a message-id or, if none is\n      |      desired, should begin with a blank.  If MF=L or is omitted, this\n      |      operand must be an A-type address; for the E-form the buffer must\n      |      be addressible.\n0       length - specifies the length of the output line.  The length may be\n             specified as *, in which case L'buffer is used.\n0       TPUT-options - specifies one or more of the keywords EDIT, ASIS,\n             CONTROL, WAIT, NOWAIT, HOLD, NOHOLD, BREAKIN and NOBREAK, with\n             the same meanings and defaults as with the TPUT macro.\n0       INFOR and DATA - identify the output line as being an informational\n             message or a data line, as with the corresponding operands of\n             PUTLINE.\n0       HELP=(buffer\u00dd,length\u00a8) - may be used with an informational message to\n             supply the text of a second-level message.  If no length is\n      |      provided, L'buffer is used.  The same rules apply to the form of\n      |      the HELP buffer address as for the primary message.\n0       CPPL=CPPL-address - specifies the address of the CPPL for the calling\n      |      command processor.\n      | IOPL=IOPL-address - specifies the address of an IOPL (containing the\n      |      addresses of the UPT, ECT and an attention ECB).  IOPL must be\n      |      used in place of CPPL when the calling routine handles attentions\n      |      itself.\n      | Note:  One of CPPL and IOPL is required for the normal or MF=E form of\n      | UPUT; both must be omitted with the MF=L form.  The CPPL and IOPL\n      | operands must specify a valid RX-type address or be given in register\n      | notation.\n0     | MF=macro-form - may be used to generate a parameter list (by\n      |      specifying MF=L) or to modify a parameter list and call the\n      |      UKJUPUT routine (by specifying MF=(E,list-addr).  If MF is\n      |      omitted, a list is generated in-line and the routine is called.\n      |      This form of the macro may generate non-reentrant code.\n-     | Except when MF=L is used, the address and length operands of UPUT may\n      | be specified in register notation, (i.e., \"(n)\" may be used to\n      | indicate that the operand is contained in register n).\n0       The return code from UPUT has the same meanings as the return code\n        from PUTLINE.\n-       The use of TGET for user input leads to the same sort of problem as\n      | the use of TPUT for output, (e.g., failure in batch, and refusal to\n      | respect the CONTROL NOPROMPT CLIST statement).  Wherever possible, the\n      | PUTGET service routine should be used in its place.  This will seldom\n      | be a problem, as terminal input is usually required only to correct\n      | erroneous or incorrect parameters on the command line, in which case\n      | it is performed automatically by the IKJPARS service routine.\n0     | As PUTGET is even more cumbersome to use than PUTLINE, ICSA has\n      | written UGET and UPROMPT macros to aid in interfacing to PUTGET.  A\n      | TPUT-TGET pair performing a prompt can be replaced by a UPROMPT-UGET\n      | pair; a TGET without a preceding TPUT can be replaced by a UGET.  The\n      | UGET macro calls a reentrant routine (also in RICE.TSOSERV.LOAD) named\n      | UKJUGET, which builds PUTGET parameters and invokes the service\n      | routine.  The UPROMPT macro does not, however, generate a call.\n      | Rather, it generates a parameter list which is referenced by the UGET\n      | macro.  This allows a straightforward conversion of TPUT-TGET pairs,\n      | given the fact that the PUTGET routine requires both input and output\n      | parameters as input.\n1\n        INT018                                                          Page 3\n-\n      | The syntaxes of the UPROMPT and UGET macros are as follows:\n0     |      \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n+                        \u00af           \u00af\n      |      |           |           |                                  |\n      |      |  LABEL    |  MACRO    |    OPERANDS                      |\n      |      |           |           |                                  |\n      |      |\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\n+            \u00bf           \u00d7           \u00d7                                  ]\n      |      |           |           |                                  |\n      |      |  \u00ddlabel\u00a8  |  UPROMPT  |    buffer,length                 |\n      |      |           |           |    .                             |\n      |      |           |           |    \u00d0               \u00af             |\n      |      |           |           |    | ,TPUT-options |             |\n      |      |           |           |    \u00bf               ]             |\n      |      |           |           |    \u00d0                         \u00af   |\n      |      |           |           |    | ,HELP=(buffer\u00dd,length\u00a8) |   |\n      |      |           |           |    \u00bf                         ]   |\n      |      |           |           |    \u00d0                \u00af            |\n      |      |           |           |    | ,MF=macro-form |            |\n      |      |           |           |    \u00bf                ]            |\n      |      |           |           |                                  |\n      |      |\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\n+            \u00bf           \u00d7           \u00d7                                  ]\n      |      |           |           |                                  |\n      |      |  \u00ddlabel\u00a8  |  UGET     |    buffer,length,                |\n      |      |           |           |    .                             |\n      |      |           |           |    \u00d0               \u00af             |\n      |      |           |           |    | ,TGET-options |             |\n      |      |           |           |    \u00bf               ]             |\n      |      |           |           |    \u00d0        \u00af                    |\n      |      |           |           |    | ,CLIST |                    |\n      |      |           |           |    | ,TERM  |                    |\n+                                            ____\n      |      |           |           |    \u00bf        ]                    |\n      |      |           |           |    \u00d0                    \u00af        |\n      |      |           |           |    | ,CPPL=CPPL-address |        |\n      |      |           |           |    | ,IOPL=IOPL-address |        |\n      |      |           |           |    \u00bf                    ]        |\n      |      |           |           |    \u00d0                       \u00af     |\n      |      |           |           |    | ,PROMPT=UPROMPT-label |     |\n      |      |           |           |    \u00bf                       ]     |\n      |      |           |           |    \u00d0                \u00af            |\n      |      |           |           |    | ,MF=macro-form |            |\n      |      |           |           |    \u00bf                ]            |\n      |      |           |           |                                  |\n      |      \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n+                        \u00bf           \u00bf\n0     | The UPROMPT parameters have meanings identical to the corresponding\n      | parameters of UPUT.  Note that a prompt message should always include\n      | a message-id or an initial blank.  Also note that if a HELP message is\n      | specified, it will be ignored unless TERM is specified or defaulted on\n      | the corresponding UGET.  The only function of UPROMPT is the\n      | definition or modification (if the E macro-form is used) of parameter\n      | lists, and so no return codes are defined.\n0     | The parameters to UGET have the following meanings:\n0     | buffer - addresses a buffer into which an input line should be placed.\n      |      If MF=L or is omitted, this operand must be an A-type address;\n      |      for the E-form the buffer must be addressible.\n0     | length - specifies the size of the input buffer.  It may be specified\n      |      as *, in which case L'buffer is used.  If the input line is\n      |      longer than the buffer, it is truncated without any error\n      |      indication being produced.\n0     | TGET-options - specifies one or more of the keywords EDIT, ASIS, WAIT\n      |      and NOWAIT, with the same meanings and defaults as with the TGET\n      |      macro.\n0     | CLIST and TERM - indicate whether the input may come from a CLIST, or\n      |      whether it must be read from the terminal.  If CLIST is in\n      |      effect, the MODE option of PUTGET is used; if TERM is in effect,\n      |      the PROMPT option is used if a PROMPT= operand was present, and\n      |      otherwise the TERM option is used.\n1\n        INT018                                                          Page 4\n-\n      | CPPL=CPPL-address - specifies the address of the CPPL for the calling\n      |      command processor.\n      | IOPL=IOPL-address - specifies the address of an IOPL (containing the\n      |      addresses of the UPT, ECT and an attention ECB).  IOPL must be\n      |      used in place of CPPL when the calling routine handles attentions\n      |      itself.\n      | Note:  One of CPPL and IOPL is required for the normal or MF=E form of\n      | UGET; both must be omitted with the MF=L form.  The CPPL and IOPL\n      | operands must specify a valid RX-type address or be given in register\n      | notation.\n0     | PROMPT=UPROMPT-label - specifies the label of a UPROMPT macro (either\n      |      normal or L form) defining the text of a prompt to be written\n      |      preceding the TGET.  If PROMPT is omitted, a null output message\n      |      is passed to PUTGET (which results in a TGET without an\n      |      explanatory message) at the terminal.\n0     | MF=macro-form - may be used to generate a parameter list (by\n      |      specifying MF=L) or to modify a parameter list and call the\n      |      UKJUPUT routine (by specifying MF=(E,list-addr).  If MF is\n      |      omitted, a list is generated in-line and the routine is called.\n      |      This form of the macro may generate non-reentrant code.\n-     | As with UPUT, UGET operand addresses and lengths may be specified in\n      | register notation unless MF=L is used.\n0     | The return code from UGET has the same meaning as the return code from\n      | PUTLINE.  Note that return code 12 will be returned only if the PROMPT\n      | option of PUTGET is issued; the UKJUGET routine handles this return\n      | code itself in other cases, and re-issues the PUTGET.\n-       RETURN CODES\n0       CLIST processing requires that a command which executes successfully\n        return a zero in register 15, and that an unsuccessful command return\n        a non-zero return code.  Failure to observe this rule will prevent\n        proper functioning of CLIST ERROR exits.\n0     | IBM has standardized two particular return codes: 16, meaning \"not\n      | enough virtual memory\", and 12, indicating any other unrecoverable\n        error, particularly an inability to prompt for required information.\n        It is recommended, but not required, that recoverable or unimportant\n        errors (such as \"DATASET x NOT FREED, NOT ALLOCATED\") be assigned\n        return codes of 4 and/or 8, so they can be distinguished in an ERROR\n        exit.  Also, commands which invoke some other processor, such as a\n        compiler, should preserve that processor's return code if no errors\n        within the prompter itself intervene.\n0       After most errors, the STACK DELETE=ALL and TCLEARQ INPUT macros\n        should be issued to resynchronize with the terminal user.  This should\n        not be done after errors of the \"NOT FREED, NOT ALLOCATED\" sort, where\n+       ___\n        successful continuation of a containing CLIST is likely.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JES2PARM": {"ttr": 5130, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "* The following is a copy of the section of the JES2 parm member that\n* deals with forms handling, with some comments added to make function\n* clear.  The cost numbers are expressed in thousandths of cents.\n*\n*\n* Indicate the maximum number of forms, carriage tapes, and print\n* trains supported.\n*\n&MAXFRMS=60                                                    *RS83089\n&MAXCTPS=99                                                    *RS83089\n&MAXTRNS=5                                                     *RS83089\n*\n* Indicate the cost/line\n*\n&LNECST=10                                                     *FG83181\n*\n* Indicate the cost/card\n*\n&PUNCST=380                                                    *RS83118\n*\n* Various setup costs.  These are currently unused at ICSA\n*\n&BSTCST=0      DISPATCHING CHARGE\n&FSTCST=0      FORMS SETUP CHARGE\n&TSTCST=0      PRINT TRAIN SETUP CHARGE\n&CSTCST=0      CARRIAGE TAPE SETUP CHARGE\n*\n* The first entry in the forms, train, and carriage tape tables is\n* used as the default entry whenever nothing was specified by the\n* user or when an unknown form, train, or carriage tape was specified\n* and we are forced to guess.\n*\n* Describe the name of the form, number of lines at 8 and 6 lpi,\n* the cost per page,\n* and whether or not a setup charge applies for the form.\n*\nFORM1 NAME=S0L1,LINES8=68,LINES6=51,COST=0,NOSETUP\nFORM2 NAME=S1U1,LINES8=88,LINES6=66,COST=0,SETUP\nFORM3 NAME=S2U1,LINES8=88,LINES6=66,COST=0,SETUP\nFORM4 NAME=LBL1,LINES8=96,LINES6=72,COST=0,SETUP\nFORM5 NAME=LBL2,LINES8=96,LINES6=72,COST=0,SETUP\nFORM6 NAME=LBL3,LINES8=96,LINES6=72,COST=0,SETUP\nFORM7 NAME=LBL4,LINES8=96,LINES6=72,COST=0,SETUP\nFORM8 NAME=S0L2,LINES8=68,LINES6=51,COST=0,SETUP\nFORM9 NAME=S0L3,LINES8=68,LINES6=51,COST=0,SETUP\nFORM10 NAME=S0L4,LINES8=68,LINES6=51,COST=0,SETUP\nFORM11 NAME=7210,LINES8=68,LINES6=51,COST=0,SETUP\nFORM12 NAME=S1L1,LINES8=88,LINES6=66,COST=0,SETUP\nFORM13 NAME=ADIR,LINES8=112,LINES6=84,COST=0,SETUP\nFORM14 NAME=BROC,LINES8=64,LINES6=48,COST=0,SETUP\nFORM15 NAME=COWN,LINES8=68,LINES6=51,COST=0,SETUP\nFORM16 NAME=SHRN,LINES8=68,LINES6=51,COST=0,SETUP\nFORM17 NAME=DVWK,LINES8=88,LINES6=66,COST=0,SETUP\nFORM18 NAME=DWWK,LINES8=88,LINES6=66,COST=0,SETUP\nFORM19 NAME=FACE,LINES8=29,LINES6=22,COST=0,SETUP\nFORM20 NAME=FA01,LINES8=88,LINES6=66,COST=0,SETUP\nFORM21 NAME=HAIR,LINES8=88,LINES6=66,COST=0,SETUP\nFORM22 NAME=IA01,LINES8=28,LINES6=21,COST=0,SETUP\nFORM23 NAME=IHE1,LINES8=85,LINES6=64,COST=0,SETUP\nFORM24 NAME=IHE2,LINES8=85,LINES6=64,COST=0,SETUP\nFORM25 NAME=INV1,LINES8=88,LINES6=66,COST=0,SETUP\nFORM26 NAME=MSA1,LINES8=88,LINES6=66,COST=0,SETUP\nFORM27 NAME=MSA2,LINES8=88,LINES6=66,COST=0,SETUP\nFORM28 NAME=SXU1,LINES8=88,LINES6=66,COST=0,SETUP\nFORM29 NAME=TCB2,LINES8=68,LINES6=51,COST=0,SETUP\nFORM30 NAME=TCB3,LINES8=48,LINES8=36,COST=0,SETUP\nFORM31 NAME=3231,LINES8=88,LINES6=66,COST=0,SETUP\nFORM32 NAME=3330,LINES8=88,LINES6=66,COST=0,SETUP\nFORM33 NAME=3430,LINES8=88,LINES6=66,COST=0,SETUP\nFORM34 NAME=3510,LINES8=64,LINES6=48,COST=0,SETUP\nFORM35 NAME=3610,LINES8=68,LINES6=51,COST=0,SETUP\nFORM36 NAME=3710,LINES8=88,LINES6=66,COST=0,SETUP\nFORM37 NAME=3820,LINES8=88,LINES6=66,COST=0,SETUP\nFORM38 NAME=3911,LINES8=88,LINES6=66,COST=0,SETUP\nFORM39 NAME=4119,LINES8=28,LINES6=21,COST=0,SETUP\nFORM40 NAME=DON1,LINES8=88,LINES6=66,COST=0,SETUP\nFORM41 NAME=4230,LINES8=88,LINES6=66,COST=0,SETUP\nFORM42 NAME=4410,LINES8=68,LINES6=50,COST=0,SETUP\nFORM43 NAME=5310,LINES8=64,LINES6=48,COST=0,SETUP\nFORM44 NAME=6139,LINES8=88,LINES6=66,COST=0,SETUP\nFORM45 NAME=8110,LINES8=32,LINES6=24,COST=0,SETUP\nFORM46 NAME=8230,LINES8=28,LINES6=21,COST=0,SETUP\nFORM47 NAME=1111,LINES8=96,LINES6=72,COST=0,SETUP\nFORM47 NAME=2012,LINES8=96,LINES6=72,COST=0,SETUP\nFORM47 NAME=2211,LINES8=96,LINES6=72,COST=0,SETUP\nFORM47 NAME=221A,LINES8=96,LINES6=72,COST=0,SETUP\n*\n* Indicate the name of the train (**** is the name used by JES2 when\n* no train is specified), the cost multiplier (in thousandths of cents)\n* for using the train, and whether or not a setup charge applies.\n*\nTRAIN1 NAME=****,COST=1000,NOSETUP                             *RS83181\nTRAIN2 NAME=PN,COST=1000,NOSETUP                               *RS83181\nTRAIN3 NAME=TN,COST=1000,SETUP                                 *RS83181\n*\n* Indicate the name of the carriage tape, whether the printer is\n* set at 6 or 8 lpi, how many lines are in the tape, and whether or\n* not a setup charge applies.  The .LINEn entries indicate that on\n* the designated line, the indicate punch is placed.  E.g., for the\n* following carriage tape, there is a 1 punch on line 5 of the tape.\n*\nCTAPE1 LPI=8,LINES=68,NAME=****,NOSETUP                        *RS83118\nCTP1.LINE5 PUNCH=1                                             *RS83089\nCTP1.LINE10 PUNCH=2                                            *RS83089\nCTP1.LINE15 PUNCH=3                                            *RS83089\nCTP1.LINE20 PUNCH=4                                            *RS83089\nCTP1.LINE25 PUNCH=5                                            *RS83089\nCTP1.LINE30 PUNCH=6                                            *RS83089\nCTP1.LINE35 PUNCH=7                                            *RS83089\nCTP1.LINE40 PUNCH=10                                           *RS83089\nCTP1.LINE45 PUNCH=11                                           *RS83089\nCTP1.LINE65 PUNCH=12                                           *RS83089\nCTP1.LINE67 PUNCH=8                                            *RS83089\nCTP1.LINE68 PUNCH=9                                            *RS83089\nCTAPE2 NAME=10C6,LPI=6,LINES=66,SETUP                          *RS83118\nCTP2.LINE3 PUNCH=1                                             *RS83089\nCTP2.LINE9 PUNCH=2                                             *RS83089\nCTP2.LINE13 PUNCH=3                                            *RS83089\nCTP2.LINE18 PUNCH=4                                            *RS83089\nCTP2.LINE23 PUNCH=5                                            *RS83089\nCTP2.LINE28 PUNCH=6                                            *RS83089\nCTP2.LINE33 PUNCH=7                                            *RS83089\nCTP2.LINE38 PUNCH=10                                           *RS83089\nCTP2.LINE43 PUNCH=11                                           *RS83089\nCTP2.LINE63 PUNCH=12                                           *RS83089\nCTP2.LINE65 PUNCH=8                                            *RS83089\nCTP2.LINE66 PUNCH=9                                            *RS83089\nCTAPE3 LPI=8,LINES=68,NAME=11C8,SETUP                          *RS83118\nCTP3.LINE5 PUNCH=1                                             *RS83089\nCTP3.LINE10 PUNCH=2                                            *RS83089\nCTP3.LINE15 PUNCH=3                                            *RS83089\nCTP3.LINE20 PUNCH=4                                            *RS83089\nCTP3.LINE25 PUNCH=5                                            *RS83089\nCTP3.LINE30 PUNCH=6                                            *RS83089\nCTP3.LINE35 PUNCH=7                                            *RS83089\nCTP3.LINE40 PUNCH=10                                           *RS83089\nCTP3.LINE45 PUNCH=11                                           *RS83089\nCTP3.LINE65 PUNCH=12                                           *RS83089\nCTP3.LINE67 PUNCH=8                                            *RS83089\nCTP3.LINE68 PUNCH=9                                            *RS83089\nCTAPE4 LPI=6,LINES=51,NAME=04C6,SETUP                          *RS83118\nCTP4.LINE3 PUNCH=1                                             *RS83089\nCTP4.LINE8 PUNCH=2                                             *RS83089\nCTP4.LINE13 PUNCH=3                                            *RS83089\nCTP4.LINE18 PUNCH=4                                            *RS83089\nCTP4.LINE23 PUNCH=5                                            *RS83089\nCTP4.LINE25 PUNCH=7                                            *RS83089\nCTP4.LINE28 PUNCH=6                                            *RS83089\nCTP4.LINE33 PUNCH=10                                           *RS83089\nCTP4.LINE38 PUNCH=11                                           *RS83089\nCTP4.LINE48 PUNCH=12                                           *RS83089\nCTP4.LINE50 PUNCH=8                                            *RS83089\nCTP4.LINE51 PUNCH=9                                            *RS83089\nCTAPE5 LPI=8,LINES=88,NAME=16C8,SETUP                          *RS83118\nCTP5.LINE5 PUNCH=1                                             *RS83089\nCTP5.LINE10 PUNCH=2                                            *RS83089\nCTP5.LINE15 PUNCH=3                                            *RS83089\nCTP5.LINE20 PUNCH=4                                            *RS83089\nCTP5.LINE25 PUNCH=5                                            *RS83089\nCTP5.LINE30 PUNCH=6                                            *RS83089\nCTP5.LINE45 PUNCH=7                                            *RS83089\nCTP5.LINE50 PUNCH=10                                           *RS83089\nCTP5.LINE55 PUNCH=11                                           *RS83089\nCTP5.LINE85 PUNCH=12                                           *RS83089\nCTP5.LINE87 PUNCH=8                                            *RS83089\nCTP5.LINE88 PUNCH=9                                            *RS83089\nCTAPE6 LPI=6,LINES=126,NAME=01C6,SETUP                         *RS83136\nCTP6.LINE3  PUNCH=2                                            *RS83136\nCTP6.LINE10 PUNCH=1                                            *RS83136\nCTP6.LINE12 PUNCH=2                                            *RS83136\nCTP6.LINE19 PUNCH=1                                            *RS83136\nCTP6.LINE21 PUNCH=2                                            *RS83136\nCTP6.LINE28 PUNCH=1                                            *RS83136\nCTP6.LINE30 PUNCH=2                                            *RS83136\nCTP6.LINE37 PUNCH=1                                            *RS83136\nCTP6.LINE39 PUNCH=2                                            *RS83136\nCTP6.LINE46 PUNCH=1                                            *RS83136\nCTP6.LINE48 PUNCH=2                                            *RS83136\nCTP6.LINE55 PUNCH=1                                            *RS83136\nCTP6.LINE57 PUNCH=2                                            *RS83136\nCTP6.LINE64 PUNCH=1                                            *RS83136\nCTP6.LINE66 PUNCH=2                                            *RS83136\nCTP6.LINE73 PUNCH=1                                            *RS83136\nCTP6.LINE75 PUNCH=2                                            *RS83136\nCTP6.LINE82 PUNCH=1                                            *RS83136\nCTP6.LINE84 PUNCH=2                                            *RS83136\nCTP6.LINE91 PUNCH=1                                            *RS83136\nCTP6.LINE93 PUNCH=2                                            *RS83136\nCTP6.LINE100 PUNCH=1                                           *RS83136\nCTP6.LINE102 PUNCH=2                                           *RS83136\nCTP6.LINE109 PUNCH=1                                           *RS83136\nCTP6.LINE111 PUNCH=2                                           *RS83136\nCTP6.LINE118 PUNCH=1                                           *RS83136\nCTP6.LINE120 PUNCH=2                                           *RS83136\nCTAPE7 LPI=6,LINES=22,NAME=02C6,SETUP                          *RS83136\nCTP7.LINE1 PUNCH=1                                             *RS83136\nCTP7.LINE4 PUNCH=2                                             *RS83136\nCTP7.LINE16 PUNCH=3                                            *RS83136\nCTAPE8 LPI=6,LINES=12,NAME=03C6,SETUP                          *RS83136\nCTP8.LINE1 PUNCH=1                                             *RS83136\nCTAPE9 LPI=8,LINES=88,NAME=05C8,SETUP                          *RS83136\nCTP9.LINE1 PUNCH=1                                             *RS83136\nCTP9.LINE12 PUNCH=2                                            *RS83136\nCTP9.LINE14 PUNCH=2                                            *RS83136\nCTAPE10 LPI=8,LINES=48,NAME=06C8,SETUP                         *RS83136\nCTP10.LINE1 PUNCH=1                                            *RS83136\nCTAPE11 LPI=6,LINES=21,NAME=07C6,SETUP                         *RS83136\nCTP11.LINE1 PUNCH=1                                            *RS83136\nCTAPE12 LPI=6,LINES=21,NAME=08C6,SETUP                         *RS83136\nCTP12.LINE1 PUNCH=1                                            *RS83136\nCTAPE13 LPI=8,LINES=44,NAME=09C8,SETUP                         *RS83136\nCTP13.LINE1 PUNCH=1                                            *RS83136\nCTAPE14 LPI=6,LINES=66,NAME=12C6,SETUP                         *RS83136\nCTP14.LINE29 PUNCH=2                                           *RS83136\nCTP14.LINE30 PUNCH=3                                           *RS83136\nCTP14.LINE31 PUNCH=5                                           *RS83136\nCTP14.LINE32 PUNCH=6                                           *RS83136\nCTP14.LINE33 PUNCH=7                                           *RS83136\nCTP14.LINE34 PUNCH=8                                           *RS83136\nCTP14.LINE35 PUNCH=9                                           *RS83136\nCTP14.LINE36 PUNCH=10                                          *RS83136\nCTP14.LINE37 PUNCH=11                                          *RS83136\nCTP14.LINE38 PUNCH=12                                          *RS83136\nCTP14.LINE42 PUNCH=4                                           *RS83136\nCTP14.LINE43 PUNCH=1                                           *RS83136\nCTAPE15 LPI=6,LINES=12,NAME=13C6,SETUP                         *RS83136\nCTP15.LINE6 PUNCH=1                                            *RS83136\nCTP15.LINE12 PUNCH=2                                           *RS83136\nCTAPE16 LPI=8,LINES=24,NAME=14C8,SETUP                         *RS83136\nCTP16.LINE1 PUNCH=1                                            *RS83136\nCTAPE17 LPI=6,LINES=66,NAME=15C6,SETUP                         *RS83136\nCTP17.LINE13 PUNCH=1                                           *RS83136\nCTAPE18 LPI=6,LINES=88,NAME=17C6,SETUP                         *RS83136\nCTP18.LINE1 PUNCH=1                                            *RS83136\nCTAPE19 LPI=6,LINES=66,NAME=18C6,SETUP                         *RS83136\nCTP19.LINE2 PUNCH=1                                            *RS83136\nCTP19.LINE6 PUNCH=2                                            *RS83136\nCTP19.LINE16 PUNCH=3                                           *RS83136\nCTP19.LINE27 PUNCH=4                                           *RS83136\nCTAPE20 LPI=6,LINES=28,NAME=19C6,SETUP                         *RS83136\nCTP20.LINE23 PUNCH=1                                           *RS83136\nCTAPE21 LPI=6,LINES=18,NAME=20C6,SETUP                         *RS83136\nCTP21.LINE1 PUNCH=1                                            *RS83136\nCTAPE22 LPI=6,LINES=117,NAME=21C6,SETUP                        *RS83136\nCTP22.LINE1 PUNCH=2                                            *RS83136\nCTP22.LINE22 PUNCH=1                                           *RS83136\nCTP22.LINE41 PUNCH=1                                           *RS83136\nCTP22.LINE61 PUNCH=1                                           *RS83136\nCTP22.LINE80 PUNCH=1                                           *RS83136\nCTP22.LINE100 PUNCH=1                                          *RS83136\nCTAPE23 LPI=6,LINES=84,NAME=22C6,SETUP                         *RS83136\nCTP23.LINE1 PUNCH=1                                            *RS83136\nCTAPE24 LPI=8,LINES=88,NAME=23C8,SETUP                         *RS83136\nCTP24.LINE1 PUNCH=1                                            *RS83136\nCTAPE25 LPI=6,LINES=18,NAME=24C6,SETUP                         *RS83138\nCTP25.LINE1 PUNCH=1                                            *RS83136\nCTAPE26 LPI=6,LINES=132,NAME=25C6,SETUP                        *RS83136\nCTP26.LINE27 PUNCH=1                                           *RS83136\nCTP26.LINE36 PUNCH=12                                          *RS83136\nCTAPE27 LPI=6,LINES=66,NAME=26C6,SETUP                         *RS83136\nCTP27.LINE1  PUNCH=1                                           *RS83136\nCTP27.LINE4  PUNCH=5                                           *RS83136\nCTP27.LINE5  PUNCH=6                                           *RS83136\nCTP27.LINE6  PUNCH=7                                           *RS83136\nCTP27.LINE7  PUNCH=9                                           *RS83136\nCTP27.LINE8  PUNCH=10                                          *RS83136\nCTP27.LINE9  PUNCH=11                                          *RS83136\nCTP27.LINE16 PUNCH=4                                           *RS83136\nCTP27.LINE22 PUNCH=3                                           *RS83136\nCTP27.LINE32 PUNCH=4                                           *RS83136\nCTP27.LINE33 PUNCH=2                                           *RS83136\nCTP27.LINE44 PUNCH=3                                           *RS83136\nCTP27.LINE48 PUNCH=4                                           *RS83136\nCTP27.LINE65 PUNCH=8                                           *RS83136\nCTAPE28 LPI=6,LINES=66,NAME=27C6,SETUP                         *RS83136\nCTP28.LINE1  PUNCH=8                                           *RS83136\nCTP28.LINE3  PUNCH=1                                           *RS83136\nCTP28.LINE4  PUNCH=2                                           *RS83136\nCTP28.LINE5  PUNCH=3                                           *RS83136\nCTP28.LINE6  PUNCH=4                                           *RS83136\nCTP28.LINE7  PUNCH=5                                           *RS83136\nCTP28.LINE8  PUNCH=6                                           *RS83136\nCTP28.LINE9  PUNCH=8                                           *RS83136\nCTP28.LINE10 PUNCH=9                                           *RS83136\nCTP28.LINE11 PUNCH=10                                          *RS83136\nCTP28.LINE12 PUNCH=11                                          *RS83136\nCTP28.LINE13 PUNCH=12                                          *RS83136\nCTAPE29 LPI=6,LINES=22,NAME=29C6,SETUP                         *RS83136\nCTP29.LINE2 PUNCH=1                                            *RS83136\nCTAPE30 LPI=6,LINES=42,NAME=30C6,SETUP                         *RS83136\nCTP30.LINE1 PUNCH=1                                            *RS83136\nCTP30.LINE19 PUNCH=3                                           *RS83136\nCTP30.LINE31 PUNCH=4                                           *RS83136\nCTAPE31 LPI=8,LINES=26,NAME=31C8,SETUP                         *RS83136\nCTP31.LINE1 PUNCH=1                                            *RS83136\nCTAPE32 LPI=6,LINES=66,NAME=32C6,SETUP                         *RS83136\nCTP32.LINE1 PUNCH=1                                            *RS83136\nCTP32.LINE60 PUNCH=9                                           *RS83136\nCTAPE33 LPI=6,LINES=24,NAME=33C6,SETUP                         *RS83136\nCTP33.LINE1 PUNCH=1                                            *RS83136\nCTAPE34 LPI=6,LINES=66,NAME=35C6,SETUP                         *RS83136\nCTP34.LINE1 PUNCH=1                                            *RS83136\nCTP34.LINE10 PUNCH=3                                           *RS83136\nCTAPE35 LPI=8,LINES=8,NAME=40C8,SETUP                          *RS83136\nCTP35.LINE1 PUNCH=1                                            *RS83136\nCTAPE36 LPI=6,LINES=66,NAME=49C6,SETUP                         *RS83136\nCTP36.LINE1 PUNCH=1                                            *RS83136\nCTP36.LINE3 PUNCH=2                                            *RS83136\nCTP36.LINE13 PUNCH=3                                           *RS83136\nCTP36.LINE24 PUNCH=4                                           *RS83136\nCTAPE37 LPI=6,LINES=51,NAME=50C6,SETUP                         *RS83136\nCTP37.LINE5 PUNCH=1                                            *RS83136\nCTAPE38 LPI=6,LINES=84,NAME=51C6,SETUP                         *RS83136\nCTP38.LINE1 PUNCH=1                                            *RS83136\nCTP38.LINE12 PUNCH=2                                           *RS83136\nCTP38.LINE23 PUNCH=3                                           *RS83136\nCTP38.LINE29 PUNCH=4                                           *RS83136\nCTP38.LINE41 PUNCH=5                                           *RS83136\nCTP38.LINE47 PUNCH=6                                           *RS83136\nCTP38.LINE54 PUNCH=7                                           *RS83136\nCTP38.LINE60 PUNCH=8                                           *RS83136\nCTP38.LINE66 PUNCH=9                                           *RS83136\nCTP38.LINE72 PUNCH=10                                          *RS83136\nCTAPE39 LPI=6,LINES=44,NAME=53C6,SETUP                         *RS83136\nCTP39.LINE1 PUNCH=1                                            *RS83136\nCTP39.LINE11 PUNCH=2                                           *RS83136\nCTP39.LINE15 PUNCH=3                                           *RS83136\nCTP39.LINE24 PUNCH=8                                           *RS83136\nCTP39.LINE31 PUNCH=4                                           *RS83136\nCTAPE40 LPI=6,LINES=51,NAME=56C6,SETUP                         *RS83136\nCTP40.LINE1 PUNCH=1                                            *RS83136\nCTP40.LINE26 PUNCH=1                                           *RS83136\nCTAPE41 LPI=8,LINES=88,NAME=41C8,SETUP                         *RS84017\nCTP41.LINE5 PUNCH=1                                            *RS84017\nCTP41.LINE10 PUNCH=2                                           *RS84017\nCTP41.LINE15 PUNCH=3                                           *RS84017\nCTP41.LINE20 PUNCH=4                                           *RS84017\nCTP41.LINE25 PUNCH=5                                           *RS84017\nCTP41.LINE30 PUNCH=6                                           *RS84017\nCTP41.LINE45 PUNCH=7                                           *RS84017\nCTP41.LINE50 PUNCH=10                                          *RS84017\nCTP41.LINE55 PUNCH=11                                          *RS84017\nCTP41.LINE85 PUNCH=12                                          *RS84017\nCTP41.LINE87 PUNCH=8                                           *RS84017\nCTP41.LINE88 PUNCH=9                                           *RS84017\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JULIAN": {"ttr": 5380, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "JULIAN   SAVEX SA=*                SAVE AND EQUATE REGS        *MW82098\n         LM    R2,R3,0(1)\n         SLR   R9,R9               ASSUME ONLY TWO PARMS       *MW82098\n         LTR   R3,R3               SECOND PARM LAST?           *MW82098\n         BM    ONLY2PRM            NO:                         *MW82098\n         L     R9,8(,R1)           --SAVE WEEKDAY ADDRESS      *MW82098\n         MVI   0(R9),C'0'          --FLAG UNKNOWN WEEKDAY      *MW82098\nONLY2PRM DS    0H                  END                         *MW82098\n*\n*   R1 CONTAINS THE ADDRESS OF THE IDENTIFIER LIST.  R2 AND R3 POINT\n*   TO THE BEGINNING OF JDATE AND GDATE, RESPECTIVELY.  JDATE\n*   IS 5 BYTES LONG AND GDATE IS 6 BYTES LONG.\n*\n*   COMPUTE JULIAN DATE FROM GREGORIAN DATE\n*\nJUL      PACK  DMONTH,0(2,R3)\n         CVB   R4,DMONTH\n         SR    R5,R5\n         CR    R4,R5\n         BE     GREG             BRANCH TO GREG IF ZERO MONTH\n         LA    R5,12\n         CR    R4,R5\n         BH    GOBACK2          BRANCH IF MONTH > 12           *MW82098\n         SLL   R4,1               MULTIPLY BY 2 TO INDEX ON HALFWORDS\n         PACK  DDAY,2(2,R3)\n         PACK  DYEAR,4(2,R3)\n         CVB   R5,DDAY\n         DP    DYEAR,FOUR\n         L     R6,DYEAR+4\n         N     R6,MASK1            ELIMINATE SIGN BITS OF REMAINDER\n         BZ    JULLEAP\n         AH    R5,NORM(R4)\n         B     JULANYYR\nJULLEAP  AH    R5,LEAP(R4)\nJULANYYR CVD   R5,JDAY\n         UNPK  2(3,R2),JDAY        JULIAN DATE IS IN YYDDD FORMAT\n         OI    4(R2),X'F0'\n         MVC   0(2,R2),4(R3)\nGOBACK   DS    0H\n*                                                              *MW82098\n*   COMPUTE DAY OF WEEK IF REQUESTED?                          *MW82098\n*                                                              *MW82098\n         LTR   R9,R9               FOURTH PARMS?               *MW82098\n         BZ    NOWEEKDY            YES:                        *MW82098\n         PACK  DYEAR,0(2,R2)       --RECREATE YEAR             *MW82098\n         CVB   R4,DYEAR            --R4 = YY                   *MW82098\n         LR    R5,R4               --R5 = YY                   *MW82098\n         BCTR  R5,0                --R5 = YY-1                 *MW82098\n         SRL   R5,2                --R5 = (YY-1)/2             *MW82098\n         AR    R5,R4               --R5 = YY+(YY-1)/4          *MW82098\n         PACK  JDAY,2(3,R2)        --RECREATE DAYS             *MW82098\n         CVB   R4,JDAY             --R4 = DDD                  *MW82098\n         AR    R5,R4               --R5 = YY+(YY-1)/4+DDD      *MW82098\n         SLR   R4,R4               --PREPARE FOR DIVIDE        *MW82098\n         D     R4,SEVEN            --R4 = (YY+(YY-1)/4+DDD)MOD *MW82098\n         LA    R4,1(,R4)           --UP ONE FOR COBOL          *MW82098\n         STC   R4,0(R9)            --SAVE FOR CALLER           *MW82098\n         OI    0(R9),C'0'          --PRETTY IT UP              *MW82098\nNOWEEKDY DS    0H                  END                         *MW82098\nGOBACK2  RETURNX                                               *MW82098\n*\n*   COMPUTE GREGORIAN DATE FROM JULIAN DATE\n*\nGREG     PACK  JDAY,2(3,R2)\n         CVB   R4,JDAY            R4 CONTAINS BINARY JULIAN DAY\n         CR    R4,R5\n         BE    CURDAT           GET CURRENT DATE IF BOTH DATES ZERO\n         PACK  DYEAR,0(2,R2)\nGREG2    DS    0H\n         LA    R5,24               R5 IS THE 'MONTH' INDEX\n         L     R6,MTWO             INCREMENT BACKWARDS BY HALFWORDS\n         SR    R7,R7                STOP AT ZERO\n         DP    DYEAR,FOUR\n         L     R8,DYEAR+4\n         N     R8,MASK1           ELIMINATE SIGN BITS OF REMAINDER\n         BZ    LEAP2\nLOOP     CH    R4,NORM(R5)\n         BH    BOX4             BRANCH IF JULIAN DAY (R4) HIGH\n         BXH   R5,6,LOOP\nBOX4     SH    R4,NORM(R5)\nBOX5     SRL   R5,1                DIVIDE BY 2 TO GET MONTH\n         CVD   R5,DMONTH\n         CVD   R4,DDAY\n         UNPK  0(2,R3),DMONTH\n         OI    1(R3),X'F0'         REMOVE ZONE SIGNS\n         UNPK  2(2,R3),DDAY\n         OI    3(R3),X'F0'\n         MVC   4(2,R3),0(R2)        YEAR\n         B     GOBACK\nLEAP2    CH    R4,LEAP(R5)\n         BH    BOX6\n         BXH   R5,6,LEAP2\nBOX6     SH    R4,LEAP(R5)\n         B     BOX5\n*\n*   OBTAIN CURRENT DATE\n*\nCURDAT   DS    0H\n         TIME\n         SR    R6,6\n         LR    R5,R1\n         N     R1,MASK2           R1   0000DDDC\n         ST    R6,JDAY\n         ST    R1,JDAY+4\n         SRL   R5,12\n         ST    R6,DYEAR\n         ST    R5,DYEAR+4\n         OI    DYEAR+7,X'0F'       FIX UP SIGN                 *MW82098\n         UNPK  2(3,R2),JDAY        STORE JULIAN CURRENT DATE\n         OI    4(R2),X'F0'\n         UNPK  0(2,R2),DYEAR\n         OI    1(R2),X'F0'\n         CVB   R4,JDAY\n         B     GREG2           OBTAIN GREGORIAN CURRENT DATE\n*\n         DS    0F\nDMONTH   DS    D\nDDAY     DS    D\nDYEAR    DS    D\nJDAY     DS    D\nTWO      DC    F'2'\nMTWO     DC    F'-2'\nSEVEN    DC    F'7'                # DAYS IN WEEK              *MW82098\nMASK1    DC    X'000000F0'\nMASK2    DC    X'0000FFFF'\nFOUR     DC    PL1'4'\nNORM     DS    0F\n         DC    F'0'\n         DC    H'31'\n         DC    H'59'\n         DC    H'90'\n         DC    H'120'\n         DC    H'151'\n         DC    H'181'\n         DC    H'212'\n         DC    H'243'\n         DC    H'273'\n         DC    H'304'\n         DC    H'334'\nLEAP     DS    0F\n         DC    F'0'\n         DC    H'31'\n         DC    H'60'\n         DC    H'91'\n         DC    H'121'\n         DC    H'152'\n         DC    H'182'\n         DC    H'213'\n         DC    H'244'\n         DC    H'274'\n         DC    H'305'\n         DC    H'335'\n         END   JULIAN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LIBEL": {"ttr": 5384, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    LIBEL &LAB,&ADDR=\n.*       THIS MACRO GENERATES CODE TO DEFINE EITHER A LABEL CONSTANT OR\n.*       A LABEL VARIABLE FOR A LANGUAGE INDEPENDENT ENVIRONMENT.\n         GBLC  &LIBASE            THIS ROUTINE'S BASE\n         AIF   ('&ADDR' NE '').STLAB\n         AIF   ('&LIBASE' NE '2' AND '&LIBASE' NE 'R2').NOBASE2\n&LAB     EQU   *                  DEFINE GOTO TARGET\n         AIF   ('&NAME' NE '').ADDNAME\n         MEXIT\n.NOBASE2 B     *+6                BRANCH AROUND GOTO TARGET\n&LAB     LR    &LIBASE,R2         COPY BASE REGISTER\n         AIF   ('&NAME' EQ '').MEND\n.ADDNAME ANOP\n&NAME    EQU   *\n         MEXIT\n.STLAB   ANOP\n&NAME    LA    R14,8+&ADDR        LOCATION OF LABEL VALUE\n         ST    R14,&ADDR          STORE IN LABEL VARIABLE\n         ST    RDSA,4+&ADDR       STORE DSA ADDRESS\n         LA    R14,&LAB           ADDRESS OF TARGET\n         ST    R14,8+&ADDR\n         ST    &LIBASE,12+&ADDR   STORE ROUTINE'S BASE REG\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LIBLOCK": {"ttr": 5386, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    LIBLOCK &OLDSA=\n.*       THIS MACRO GENERATES (POSSIBLY INEFFECTIVE) LANGUAGE-\n.*       INDEPENDENT CODE TO PREVENT GOTO'S OUT OF THE CURRENT\n.*       ROUTINE.\n&NAME    IHBINNRA &OLDSA          OLD DSA ADDR IN R1\n         L     R15,=V(LIEBLK)     BLOCK GOTO ROUTINE\n         BALR  R14,R15            ERECT A BLOCKADE\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LICOND": {"ttr": 5388, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         LICOND &COND=,&NAMES=(ATTN,STOP,FINISH,ERROR),                *\n               &VALUES=(1A00,0D80,0D00,0C00)\n.*       THIS MACRO TRANSLATES CONDITION NAMES INTO PL/I\n.*       \"ERROR CODES\", AND STORES THE RESULT IN THE GLOBAL\n.*       SYMBOL &LICOND.\n.*       NEW CONDITION NAMES AND VALUES CAN BE ADDED TO THE DEFAULTS\n.*       CONTAINED IN THE MACRO PROTOTYPE.\n         GBLC  &LICOND            THE RETURN VALUE\n         LCLA  &I\n&I       SETA  1\n.LOOKUP  AIF   ('&COND' EQ '&NAMES(&I)').GOTCOND\n&I       SETA  &I+1\n         AIF   (&I LE N'&NAMES).LOOKUP\n         MNOTE 8,'***** UNKNOWN CONDITION DESIGNATOR -- &COND *****'\n&LICOND  SETC  '0000'\n         MEXIT\n.GOTCOND ANOP\n&LICOND  SETC  '&VALUES(&I)'\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LIENTRY": {"ttr": 5390, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   LIENTRY &PARM=R2,&DSALEN=DSALEN,&BASE=R11,&ALIAS=*,&ISASIZE=, *\n               &DSA=DSA,&ENV=\n.*       THIS MACRO GENERATES LANGUAGE INDEPENDENT CODE FOR SAVING\n.*       REGISTERS, GETTING A BASE REGISTER, SAVING A PARAMETER\n.*       POINTER, AND GETTING A NEW DYNAMIC SAVE AREA.\n         GBLC  &LISECT            NAME OF CONTAINING CSECT\n         GBLC  &LIBASE            DECLARED BASE REGISTER\n         GBLC  &LIONSCT           NAME OF ONCB CSECT\n         GBLC  &LIDSA             NAME OF DSA\n         GBLB  &LIDSAU            USING ACTIVE FOR DSA\n         LCLA  &K\n         LCLC  &PRMR              TEMP. PARM REG\n&PRMR    SETC  '&PARM'\n         AIF   ('&PRMR' NE '1' AND '&PRMR' NE 'R1' AND '&PRMR' NE '10' *\n               AND '&PRMR' NE 'R10' AND '&PRMR' NE '11' AND            *\n               '&PRMR' NE 'R11').OK\n         AIF   ('&BASE' EQ 'R3').PRMR2\n&PRMR    SETC  'R3'\n         AGO   .OK\n.PRMR2   ANOP\n&PRMR    SETC  'R2'\n.OK      ANOP\n&K       SETA  K'&LABEL\n         CNOP  0,4                ALIGN ON FULLWORD\n         AIF   (&K EQ 8).LEN8\n         DC    (7-&K)C' '\n         AGO   .JLEN\n.LEN8    DC    3C' '\n.JLEN    DC    C'&LABEL'          NAME OF ROUTINE\n         DC    AL1(&K)            LENGTH OF NAME\n         AIF   ('&ENV' NE '').NOENT\n         ENTRY &LABEL\n.NOENT   USING &LABEL,R15\n&LABEL   STM   R14,R12,12(RDSA)   SAVE REGISTERS\n         AIF   ('&ALIAS' EQ '*').NOALI\n         ENTRY &ALIAS             MAKE ALTERNATE NAME AN ENTRY\n&ALIAS   EQU   &LABEL             DEFINE ALIAS NAME\n.NOALI   LR    &PRMR,R1           SAVE PARM POINTER\n         LA    R0,&DSALEN         LENGTH OF SAVE AREA\n         AIF   ('&ISASIZE' EQ '').NISA\n         LA    R1,&ISASIZE        PASS ISASIZE IN R1\n         L     R10,=V(LIEBEGN)    GET ISA CODE ADDRESS\n         AGO   .CALL\n.NISA    L     R10,=V(LIENTER)    GET DSA CODE ADDRESS\n.CALL    BALR  R11,R10            GO GET A DSA\n         DROP  R15\n         USING *,R11\n         AIF   ('&DSA' EQ '*').NODSA\n         USING &DSA,RDSA          ESTABLISH SAVE AREA BASE\n&LIDSAU  SETB  (1)\n         AGO   .JDSA\n.NODSA   AIF   (NOT &LIDSAU).JDSA\n         DROP  RDSA\n&LIDSAU  SETB  (0)\n.JDSA    AIF   ('&LIDSA' NE '').DSAA\n&LIDSA   SETC  '&DSA'\n.DSAA    AIF   ('&LIONSCT' EQ '').NOON\n         MVC   92(4,RDSA),=A(&LIONSCT) SAVE ONCB PTR IN DSA\n         XC    LIONCELS(LIONCELN),LIONCELS  CLEAR ON CELLS\n         MVI   LIONCELS+LIONCELN,X'01' STORE ON CELL END MARK\n         LA    R10,LIONCELS\n         ST    R10,112(,RDSA)     STORE ON CELL PTR IN DSA\n         OI    0(RDSA),X'40'      SET ON-CELLS EXIST FLAG\n.NOON    ANOP\n&LIBASE  SETC  '&BASE'            SAVE BASE REGISTER NAME\n         L     &BASE,=A(&LISECT)  SET UP BASE REGISTER\n         AIF   ('&BASE' EQ 'R11' OR '&BASE' EQ '11').B11\n         DROP  R11\n.B11     USING &LISECT,&BASE      ESTABLISH REAL BASE\n         AIF   ('&PARM' EQ '&PRMR').PARMOK\n         LR    &PARM,&PRMR        SET UP PROPER PARM REGISTER\n.PARMOK  AIF   ('&ENV' EQ '').NOENV\n         AIF   ('&ENV' EQ 'R5' OR '&ENV' EQ '5').ENV5\n         LR    &ENV,R5            SET UP ENVIRONMENT POINTER\n.ENV5    AIF   ('&LIDSA' EQ '*').NOENV\n         USING &LIDSA,&ENV        ADDRESS CONTAINING DSA\n.NOENV   SPACE\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LIENVASM": {"ttr": 5393, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         TITLE 'LIENVASM -- SIMULATED PL/I ENVIRONMENT (LIE) ROUTINES'\n         BANNER LIENVASM\n         SPACE\n***********************************************************************\n*                                                                     *\n* MODULE NAME -                                                       *\n*        LIENVASM                                                     *\n*                                                                     *\n* FUNCTION -                                                          *\n*        TO PROVIDE SOME OF THE SERVICES OF THE PL/I ENVIRONMENT      *\n*        (NOTABLY STORAGE-MANAGEMENT AND BLOCK-STRUCTURING SERVICES)  *\n*        IN AN ASSEMBLER-ONLY LOAD MODULE.                            *\n*                                                                     *\n* ENVIRONMENT -                                                       *\n*        NON-PL/I                                                     *\n*                                                                     *\n* ENTRY POINTS AND FUNCTIONS -                                        *\n*        LIEBEGN: CREATE ENVIRONMENT AND ALLOCATE INITIAL STORAGE AREA*\n*        LIENTER: OBTAIN DYNAMIC SAVE AREA ON ROUTINE ENTRY           *\n*        LIELIFO: OBTAIN VDA (AUTOMATIC STORAGE EXTENSION)            *\n*        LIEXIT:  RETURN FROM ROUTINE, FREEING DSA AND VDA'S          *\n*        LIERETC: RETURN FROM ROUTINE, SETTING A RETURN CODE AND      *\n*                 FREEING DSA AND VDA'S                               *\n*        LIEGET:  OBTAIN NON-LIFO (BASED) STORAGE                     *\n*        LIEFREE: FREE NON-LIFO (BASED) STORAGE                       *\n*        LIESIGN: SIGNAL A PL/I CONDITION (OR ISSUE STOP)             *\n*        LIEGOTO: GOTO A PL/I-LIKE LABEL VARIABLE                     *\n*        LIEBLK:  INTERCEPT GOTO FROM CALLED ROUTINES                 *\n*        LIENSUR: MAKE MEMORY AVAILABLE FOR GETMAIN (NO OP)           *\n*        LIERLSE: ALLOW RECLAMATION OF FREED MEMORY (NO OP)           *\n*                                                                     *\n* NOTE -                                                              *\n*        THE SAME SERVICES AND ENTRY POINTS ARE PROVIDED IN A PL/I    *\n*        ENVIRONMENT BY THE LIENVPLI MODULE, WHICH INTERFACES TO THE  *\n*        PL/I LIBRARY. MODULES WHICH REQUEST PL/I ENVIRONMENTAL       *\n*        SERVICES ONLY THROUGH THESE INTERFACES CAN BE RUN EQUALLY    *\n*        WELL IN THE PSEUDO-PL/I ENVIORNMENT IMPLEMENTED BY THIS      *\n*        MODULE AS IN A TRUE PL/I ENVIRONMENT.                        *\n***********************************************************************\n         EJECT\nLIENVASM CSECT\n         SPACE\n         REGISTER\n         SPACE\n         ENTRY LIEBEGN            ENTRY TO SET UP ENVIRONMENT\n         ENTRY LIENTER,LIELIFO,LIERETC,LIEXIT,LIEGET,LIEFREE,LIESIGN\n         ENTRY LIEGOTO,LIEBLK,LIENSUR,LIERLSE\n         TITLE 'LIEBEGN -- CREATE PSEUDO-PL/I ENVIRONMENT AND INITIAL S*\n               TORAGE AREA'\n         BANNER LIEBEGN\n         SPACE\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*        LIEBEGN                                                      *\n*                                                                     *\n* FUNCTION -                                                          *\n*        TO SET UP THE PSEUDO-PL/I ENVIRONMENT, ALLOCATE THE INITIAL  *\n*        STORAGE AREA, AND CREATE THE DSA FOR THE MAIN PROCEDURE.     *\n*                                                                     *\n* LINKAGE -                                                           *\n*        BALR R11,R10, GENERATED BY THE LIENTRY MACRO, USED AS THE    *\n*        FIRST STATEMENT OF THE MAIN ROUTINE.                         *\n*                                                                     *\n* PARAMETERS -                                                        *\n*        THE SIZE OF THE ISA IS CONTAINED IN REGISTER 1, AND THE SIZE *\n*        OF THE MAIN ROUTINE'S DSA IN REGISTER 0.                     *\n*                                                                     *\n* RETURN INFORMATION -                                                *\n*        THE MAIN ROUTINE'S DSA IS CONTAINED IN REGISTER 13. REGISTER *\n*        12 ADDRESSES THE PSEUDO-TCA.                                 *\n***********************************************************************\n         EJECT\n***********************************************************************\n*        THE ROUTINE LIEBEGN IS CALLED TO INITIALIZE THE ENVIRONMENT, *\n*        BY ALLOCATING THE ISA AND FIRST DSA. THIS ROUTINE ALLOCATES  *\n*        AND INITIALIZES A PSEUDO-REGISTER VECTOR, AND POINTS R12 TO A*\n*        PSEUDO-TCA. THE FIRST TWO FLAG BYTES OF THE TCA AND THE      *\n*        PSEUDO-REGISTER POINTER AT OFFSET 4 ARE USED COMPATIBLY      *\n*        WITH PL/I, FOR THE BENEFIT OF CALLING ROUTINES. (IN          *\n*        PARTICULAR, THIS ALLOWS THE STANDARD TEST FOR A CHECKOUT     *\n*        COMPILER ENVIRONMENT TO BE MADE RELIABLY.)                   *\n***********************************************************************\n         SPACE\n         USING LIEBEGN,R10\nLIEBEGN  STH   R0,8(,R13)         SAVE SIZES\n         STH   R1,10(,R13)\n         LR    R0,R1              MOVE ISA SIZE\n         O     R0,=X'01000000'    TAKE IT FROM SUBPOOL 1\n         GETMAIN R,LV=(0)         GET INITIAL STORAGE AREA\n         USING ATCA,R1\n         ST    R12,ATCAR12        SAVE CALLER'S R12\n         LR    R12,R1             POINT R12 TO PSEUDO-TCA\n         DROP  R1\n         USING ATCA,R12\n         MVI   ATCAFLGS,ATCAFAKE  SET FAKE TCA FLAG (= PL/I CICS FLAG)\n         LH    R0,10(,R13)        GET THE ISA SIZE\n         STH   R0,ATCAISIZ        AND SAVE FOR EXIT\n         LA    R0,ATCALEN(,R12)   START OF PSEUDO-REGS\n         ST    R0,ATCAPRVA\n         AH    R1,10(,R13)        FIND END OF ISA\n         XC    ATCAOPIC(ATCALEN-ATCAOPIC+ATCA),ATCAOPIC\n         ST    R1,ATCAEOS         STORE FOR LATER\n         L     R1,PRLEN           GET LENGTH OF PSEUDO-REGS\n         BCTR  R1,0\n         EX    R1,CLEAR           CLEAR THEM (LENGTH MUST < 256)\n         LA    R1,ATCALEN+1(R1,R12) POINT PAST TCA & PSEUDO-REGS\n         LH    R0,8(,R13)         GET SIZE OF 1ST DSA\n         USING ADSA,R1\n         ST    R0,ADSALEN         SAVE FOR EVENTUAL EXIT\n         MVI   ADSALEN,ADSAFINL   MARK AS FINAL DSA\n         AR    R0,R1\n         ST    R0,ATCANAB         UPDATE NEXT AVAILABLE BYTE\n         B     CHAIN2             GO CHAIN SAVE AREAS\n         SPACE 2\nCLEAR    XC    ATCALEN(0,R12),ATCALEN(R12)  ZERO PSEUDO-REGISTERS\n         SPACE 2\nPRLEN    CXD   ,                  LENGTH OF PSEUDO-REGISTERS\n         TITLE 'LIENTER -- DSA ALLOCATION ROUTINE'\n         BANNER LIENTER\n         SPACE\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*        LIENTER                                                      *\n*                                                                     *\n* FUNCTION -                                                          *\n*        TO OBTAIN A DSA AND AUTOMATIC STORAGE FOR ITS CALLER.        *\n*                                                                     *\n* LINKAGE -                                                           *\n*        BALR R11,R10, GENERATED BY THE LIENTRY MACRO, USED AS THE    *\n*        THE FIRST STATEMENT OF THE CALLING ROUTINE.                  *\n*                                                                     *\n* PARAMETERS -                                                        *\n*        THE SIZE OF THE DSA IS CONTAINED IN REGISTER 0.              *\n*                                                                     *\n* RETURN INFORMATION -                                                *\n*        THE ADDRESS OF THE NEW DSA IS CONTAINED IN REGISTER 13.      *\n***********************************************************************\n         EJECT\n***********************************************************************\n*        LIENTER IS CALLED TO GET A NEW DYNAMIC SAVE AREA FOR         *\n*        ENTRY INTO A NEW ROUTINE. DSA'S ARE ALLOCATED FROM THE ISA   *\n*        IF POSSIBLE; OTHERWISE, THEY ARE OBTAINED BY GETMAIN. NOTE   *\n*        THAT THE FIELDS IN THE DSA RELATING TO GOTO INTERCEPTION,    *\n*        AND TO PL/I CONDITION HANDLING ARE DEFINED COMPATIBLY WITH   *\n*        PL/I, FOR THE BENEFIT OF THOSE ROUTINES WHICH REQUIRE THOSE  *\n*        SERVICES IN AN UNKNOWN ENVIRONMENT.                          *\n***********************************************************************\n         SPACE\n         USING LIENTER,R10\nLIENTER  ST    R0,8(,R13)         STORE REQUESTED SIZE\n         L     R1,ATCANAB         GET NEXT AVAILABLE IN ISA\n         AR    R0,R1              ADD REQUESTED LENGTH\n         C     R0,ATCAEOS         COMPARE TO END OF ISA\n         BH    OVERFLOW           TOO LARGE, MUST USE GETMAIN\n         ST    R0,ATCANAB         STORE NEW NEXT AVAILABLE\n         B     CHAIN              GO CHAIN AREAS\nOVERFLOW MVI   8(R13),X'01'       ADD SUBPOOL TO LENGTH\n         L     R0,8(,R13)\n         GETMAIN R,LV=(0)         GET A DSA FROM THE SYSTEM\n         DROP  R10\n         SPACE\nCHAIN    MVC   ADSALEN,8(R13)     MOVE THE DSA LENGTH\n         SPACE\n***********************************************************************\n*        CONTROL COMES HERE FROM LIEBEGN TO COMPLETE THE ALLOCATION OF*\n*        THE MAIN ROUTINE'S DSA.                                      *\n***********************************************************************\n         SPACE\nCHAIN2   ST    R1,ADSACHN2-ADSA(,R13)  LINK SAVE AREAS\n         ST    R13,ADSACHN\n         XC    ADSAFLGS(4),ADSAFLGS\n         XC    ADSAVDA,ADSAVDA    ZERO VDA POINTER\n         XC    ADSAOERX,ADSAOERX  AND ERROR EXIT POINTER\n         ST    R1,ATCADSA         STORE NEW TOP DSA\n         LR    R13,R1             ESTABLISH NEW SAVE AREA\n         BR    R11                AND RETURN\n         DROP  R1\n         TITLE 'LIELIFO -- GET LIFO STORAGE (VDA) ROUTINE'\n         BANNER LIELIFO\n         SPACE\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*        LIELIFO                                                      *\n*                                                                     *\n* FUNCTION -                                                          *\n*        TO OBTAIN WORK STORAGE WHICH WILL BE FREED ON EXIT FROM      *\n*        THE CALLING ROUTINE.                                         *\n*                                                                     *\n* LINKAGE -                                                           *\n*        CALL, GENERATED BY THE LIFO MACRO.                           *\n*                                                                     *\n* PARAMETERS -                                                        *\n*        THE SIZE OF THE STORAGE REQUIRED IS PASSED IN REGISTER 0.    *\n*                                                                     *\n* RETURN INFORMATION -                                                *\n*        THE ADDRESS OF THE ALLOCATED STORAGE IS RETURNED IN REGISTER *\n*        1.                                                           *\n***********************************************************************\n         EJECT\n***********************************************************************\n*        OBTAIN VDA STORAGE FROM THE ISA IF POSSIBLE, OR OTHERWISE BY *\n*        GETMAIN. THE VDA'S ARE CHAINED FROM THE DSA, SO THEY CAN BE  *\n*        FREED ON BLOCK EXIT.                                         *\n***********************************************************************\n         SPACE\n         USING LIELIFO,R11\n         USING ADSA,R13\nLIELIFO  STM   R14,R11,ADSASAVE\n         LR    R11,R15            SET UP BASE REG\n         LR    R8,R0              MOVE REQUESTED LENGTH\n         LA    R8,AVDAHLEN(,R8)   ADD SPACE FOR HEADER\n         L     R1,ATCANAB         FIND NEXT AVAILABLE\n         AR    R8,R1              ADD IN LENGTH NEEDED\n         C     R8,ATCAEOS         IS THERE ENOUGH LEFT?\n         BH    OVERLIFO           NO, MUST GETMAIN\n         ST    R8,ATCANAB         YES, STORE NEW AVAILABLE POINTER\n         SR    R8,R1              GET LENGTH BACK IN R8\n         B     GOTLIFO\n         SPACE\nOVERLIFO SR    R8,R1              GET BACK AMOUNT NEEDED\n         O     R8,=X'01000000'    GET FROM SUBPOOL 1\n         GETMAIN R,LV=(R8)        GET A VDA\nGOTLIFO  L     R9,ADSAVDA         GET VDA POINTER FROM DSA\n         ST    R1,ADSAVDA         ADD TO CHAIN\n         USING AVDA,R1\n         ST    R9,AVDACHN\n         ST    R8,AVDALEN         ADD LENGTH TO HEADER\n         LA    R1,AVDAHLEN(,R1)   PART AVAILABLE TO CALLER\n         ST    R1,24(,R13)        RETURN IN R1\n         LM    R14,R11,12(R13)\n         BR    R14                RETURN TO CALLER\n         SPACE\n         DROP  R11,R1\n         TITLE 'LIERETC/LIEXIT -- PROCEDURE EXIT ROUTINES'\n         BANNER LIEXIT\n         SPACE\n         BANNER LIERETC\n         SPACE\n***********************************************************************\n*                                                                     *\n* ROUTINE NAMES -                                                     *\n*        LIEXIT AND LIERETC                                           *\n*                                                                     *\n* FUNCTION -                                                          *\n*        TO RETURN TO OUR CALLER'S CALLER, AFTER FREEING THE DSA AND  *\n*        ANY VDA'S.                                                   *\n*                                                                     *\n* LINKAGE -                                                           *\n*        ENTERED BY BR R14, GENERATED BY THE LIEXIT MACRO.            *\n*                                                                     *\n* PARAMETERS -                                                        *\n*        FOR LIEXIT, NONE. FOR LIERETC, THE RETURN CODE IS PASSED IN  *\n*        REGISTER 15.                                                 *\n*                                                                     *\n* RETURN INFORMATION -                                                *\n*        RETURN IS NOT MADE TO THE CALLING ROUTINE, BUT TO ITS CALLER.*\n*        LIERETC DOES RETURN THE REQUESTED RETURN CODE IN REGISTER 15.*\n***********************************************************************\n         EJECT\n***********************************************************************\n*        LIERETC AND LIEXIT EXECUTE A STANDARD RETURN SEQUENCE AFTER  *\n*        FREEING THE DSA AND ANY VDA'S. FOR STORAGE TAKEN FROM THE    *\n*        ISA, THIS MERELY INVOLVES MOVING THE NAB (NEXT AVAILABLE     *\n*        BYTE POINTER). AREAS TAKEN OUTSIDE THE ISA MUST BE           *\n*        INDIVIDUALLY FREEMAINED.                                     *\n***********************************************************************\n         SPACE\n         USING LIERETC,R14\nLIERETC  L     R7,ADSACHN         PREVIOUS SAVE AREA\n         ST    R15,16(,R7)        STORE RETURN CODE\n         BAL   R11,FREEUP         JOIN WITH LIEXIT\n         DROP  R14\n         SPACE\n         USING LIEXIT,R11\nLIEXIT   LR    R11,R14            SET UP BASE\n         L     R7,4(,R13)         LOCATE PREVIOUS SAVE AREA\n         SPACE\n***********************************************************************\n*        THE PSEUDO-PL/I ENVIRONMENT SUPPORTS A DEBUGGING FACILITY,   *\n*        IMPLEMENTED BY THE LIERRSET ROUTINE (Q.V.). UPON EXIT FROM   *\n*        A ROUTINE, WE SEE IF THAT ROUTINE ESTABLISHED A SPIE EXIT    *\n*        THROUGH LIERRSET AND, IF SO, ISSUE SPIE TO RESTORE THE       *\n*        PREVIOUS ENVIRONMENT.                                        *\n***********************************************************************\n         SPACE\nFREEUP   CLI   ADSAOERX,0         NEED TO RESET SPIE?\n         BZ    NOUNSPIE           NO.\n         L     R1,ATCAOPIC        YES, GET ORIGINAL\n         SPIE  MF=(E,0(R1))\n         XC    ATCAOPIC,ATCAOPIC  REMOVE POINTER FROM TCA\nNOUNSPIE OC    ADSAOERX,ADSAOERX  NEED TO RESET EXIT POINT?\n         BZ    NOERRX             NO.\n         MVC   ATCAERRX+1(3),ADSAOERX+1 YES,RESET\n         SPACE\nNOERRX   L     R8,ADSAVDA         LOCATE FIRST VDA\nFREELIFO LTR   R9,R8              IS THERE ANY MORE?\n         USING AVDA,R9\n         BZ    FREESAVE           NO.\n         L     R8,AVDACHN         YES, GET THE CHAIN\n         CLI   AVDALEN,ADSAGOT    WAS IT GETMAINED?\n         BNE   POPLIFO            NO.\n         L     R0,AVDALEN         YES, LOAD LENGTH & SUBPOOL\n         FREEMAIN R,LV=(0),A=(R9) GIVE IT BACK\n         B     FREELIFO           AND CONTINUE\nPOPLIFO  ST    R9,ATCANAB         MAKE VDA AVAILABLE\n         B     FREELIFO\n         DROP  R9\n         SPACE\nFREESAVE TM    ADSALEN,ADSAFINL   CHECK FOR 1ST/GETMAINED DSA\n         BO    ALLDONE            IF THE VERY FIRST\n         BZ    POPSAVE            IF NOT GETMAINED\n         L     R0,ADSALEN         GET SIZE OF DSA\n         FREEMAIN R,LV=(0),A=(R13)     RETURN DSA TO SYSTEM\n         B     RETURN             AND RETURN TO CALLER'S CALLER\nPOPSAVE  ST    R13,ATCANAB        DSA NOW HEADS AVAILABLE\nRETURN   ST    R7,ATCADSA         UPDATE TOP DSA POINTER\nRETURN2  LR    R13,R7             OLD DSA TO R13\n         LM    R14,R11,ADSASAVE\n         BR    R14                RETURN\n         SPACE\n***********************************************************************\n*        IF WE ARE ABOUT TO FREE THE FIRST DSA, WE MUST DESTROY THE   *\n*        PSEUDO-PL/I ENVIRONMENT. WE DEALLOCATE THE INITIAL STORAGE   *\n*        AREA, AND RESTORE THE CONTENTS OF REGISTER 12 WHEN THE       *\n*        ENVIRONMENT WAS ORIGINALLY CREATED.                          *\n***********************************************************************\n         SPACE\nALLDONE  LH    R0,ATCAISIZ        GET ORIGINAL ISA SIZE\n         O     R0,=X'01000000'\n         LR    R1,R12\n         L     R12,ATCAR12        RESTORE CALLER'S R12\n         FREEMAIN R,LV=(0),A=(1)  GIVE BACK THE ISA\n         B     RETURN2            AND RETURN TO CALLER\n         SPACE\n         DROP  R11,R13\n         TITLE 'LIEGET/LIEFREE -- NON-LIFO STORAGE GET AND FREE ROUTINE*\n               S'\n         BANNER LIEGET\n         SPACE\n         BANNER LIEFREE\n         SPACE\n***********************************************************************\n*                                                                     *\n* ROUTINE NAMES -                                                     *\n*        LIEGET AND LIEFREE                                           *\n*                                                                     *\n* FUNCTION -                                                          *\n*        TO ALLOCATE AND FREE (RESPECTIVELY) NON-LIFO STORAGE, I.E.,  *\n*        STORAGE WHOSE LIFETIME IS NOT THE SAME AS THAT OF THE        *\n*        CALLING ROUTINE.                                             *\n*                                                                     *\n* LINKAGE -                                                           *\n*        CALL, GENERATED BY THE LIGET AND LIFREE MACROS, RESPECTIVELY.*\n*                                                                     *\n* PARAMETERS -                                                        *\n*        R0 CONTAINS THE AMOUNT OF STORAGE TO ALLOCATE OR FREE. FOR   *\n*        LIEFREE, R1 CONTAINS THE AREA TO FREE.                       *\n*                                                                     *\n* RETURN INFORMATION -                                                *\n*        FOR LIEGET, R1 WILL CONTAIN THE ADDRESS OF THE ALLOCATED     *\n*        MEMORY. NO INFORMATION IS RETURNED FROM LIEFREE.             *\n***********************************************************************\n         EJECT\n***********************************************************************\n*        LIEGET AND LIEFREE MERELY ISSUE GETMAIN AND FREEMAIN (FROM   *\n*        SUBPOOL 1) TO PERFORM THEIR FUNCTION.                        *\n***********************************************************************\n         SPACE\n         USING LIEGET,R15\nLIEGET   ST    R14,12(,R13)       SAVE RETURN POINT\n         O     R0,=X'01000000'    GET FROM SUBPOOL 1\n         GETMAIN R,LV=(0)         GIMME SOME\n         L     R14,12(,R13)       RESTORE RETURN POINT\n         BR    R14                AND RETURN\n         SPACE 10\n         USING LIEFREE,R15\nLIEFREE  ST    R14,12(,R13)       SAVE RETURN POINT\n         O     R0,=X'01000000'    STORAGE IS SUBPOOL 1\n         FREEMAIN R,LV=(0),A=(1)  RECYCLE CORE\n         L     R14,12(,R13)       RESTORE RETURN POINT\n         BR    R14\n         SPACE\n         DROP  R15\n         TITLE 'LIESIGN -- SIGNAL PL/I CONDITION ROUTINE'\n         BANNER LIESIGN\n         SPACE\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*        LIESIGN                                                      *\n*                                                                     *\n* FUNCTION -                                                          *\n*        TO SIGNAL A PL/I CONDITION (OR ISSUE A PL/I STOP, WHICH IS   *\n*        REALLY A PECULIAR WAY OF SIGNALLING FINISH).                 *\n*                                                                     *\n* LINKAGE -                                                           *\n*        CALL, GENERATED BY THE LISIGNAL MACRO.                       *\n*                                                                     *\n* PARAMETERS -                                                        *\n*        REGISTER 1 ADDRESS A PL/I CONDITION WORD, WHICH DEFINES      *\n*        THE CONDITION TO BE SIGNALLED.                               *\n*                                                                     *\n* RETURN INFORMATION -                                                *\n*        NONE                                                         *\n***********************************************************************\n         EJECT\n***********************************************************************\n*        LIESIGN IS CALLED TO SIGNAL A CONDITION, ROUTING CONTROL TO  *\n*        AN \"ON-UNIT\" ESTABLISHED BY THE LION MACRO (WHICH GENERATES  *\n*        CODE SIMILAR TO THAT GENERATED BY THE PL/I ON STATEMENT,     *\n*        INVOLVING MANIPULATION OF \"ON-CELLS\" IN THE DSA). \"ON-UNITS\" *\n*        MAY BE OF EITHER \"CALL\" TYPE, IN WHICH CASE CONTROL IS TO    *\n*        RETURN TO THE SIGNALLER AFTER EXECUTION OF THE UNIT, OR OF   *\n*        \"GOTO\" TYPE. IF NO \"ON-UNIT\" FOR THE CONDITION IS OUTSTANDING*\n*        THE SIGNAL IS TREATED AS A NO-OP, UNLESS THE SIGNAL WAS A    *\n*        \"STOP\" REQUEST (IN WHICH CASE EXIT IS MADE TO THE CALLER OF  *\n*        THE CREATOR OF THE ENVIRONMENT WITH A RETURN CODE OF 1000),  *\n*        OR AN \"ERROR\" REQUEST (WHICH IS LIKE STOP WITH CODE 2000).   *\n*                                                                     *\n*        NOTE: SEE THE PL/I OPTIMIZER EXECUTION LOGIC MANUAL FOR MORE *\n*        INFORMATION ON THE IMPLEMENTATION OF \"ON-CELLS\".             *\n***********************************************************************\n         SPACE\n         USING LIESIGN,R15\nLIESIGN  STM   R14,R5,12(R13)     SAVE SOME REGISTERS\n         LR    R5,R13             COPY THE DSA POINTER\n         USING ADSA,R5\nONSRCH   TM    ADSAFLGS,ADSAON    THIS BLOCK HAVE ON UNITS?\n         BZ    ONUP               NO, TRY PREVIOUS\n         L     R14,ADSAONCL       YES, FIND FIRST ON CELL\nCONDLKUP CLC   0(1,R1),0(R14)     THIS CELL FOR THIS CONDITION?\n         BE    CALLUNIT           YES.\n         LA    R14,1(,R14)        NO, CONTINUE\n         CLI   0(R14),X'01'       UNTIL END CELL FOUND\n         BNE   CONDLKUP\nONUP     TM    ADSALEN,ADSAFINL   REACHED THE FIRST DSA?\n         BO    IGNORE             YES, IGNORE THE CONDITION\n         L     R5,ADSACHN         NO, TRY PREVIOUS BLOCK\n         B     ONSRCH\n         SPACE\nCALLUNIT S     R14,ADSAONCL       COMPUTE OFFSET OF ON CELL\n         SLL   R14,3              MULTIPLY BY ONCB SIZE\n         A     R14,ADSAONCB       FIND THE RIGHT ONCB\n         USING ONCB,R14\n         TM    LSFG,LSF2          IS THIS A GOTO UNIT?\n         BNZ   ONGOTO             YES, DO SO\n         MVC   ADSAOR14,12(R13)   NO, SAVE R14 & R5\n         MVC   ADSAOR5,40(R13)    PERMANENTLY\n         L     R15,LSTR           LOCATE ON UNIT ENTRY\n         BALR  R14,R15            AND CALL IT\n         L     R14,ADSAOR14       RESTORE R14\n         L     R5,ADSAOR5         AND R5\n         SPACE\nIGNORE   BALR  R15,0              GET A NEW BASE REG\n         USING *,R15\n         CLC   0(2,R1),=X'0D80'   IS THIS A STOP?\n         BE    STOP               YES, DO SO\n         CLI   0(R1),X'0C'        IS THIS SIGNAL ERROR?\n         BE    SIGNERR            YES, STOP\n         BR    R14                NO, RETURN\n         SPACE\n         USING LIESIGN,R15        RESTORE ENTRY BASE REG\nONGOTO   L     R14,LSTR           FIND THE LABEL VAR OFFSET\n         AR    R5,R14             FIND THE LABEL VAR\n         LIGOTO 0(R5)             AND GO TO IT\n         DROP  R5,R14\n         SPACE\n***********************************************************************\n*        A STOP REQUIRES THE TERMINATION OF ALL ACTIVE PROCEDURES, AND*\n*        CAN THEREFORE BE REGARDED AS THE ULTIMATE NON-LOCAL GOTO. IT *\n*        IS IMPLEMENTED THROUGH THE GOTO HANDLER, WITH THE TARGET DSA *\n*        PARAMETER REGISTER SET TO 0 TO INDICATE THAT A FULL EXIT IS  *\n*        REQUIRED.                                                    *\n***********************************************************************\n         SPACE\nSTOP     SR    R1,R1              TELL GOTO TO GO ALL THE WAY\n         B     GETOUT\nSIGNERR  LA    R1,1               MAKE R1 NEGATIVE FOR SIGNAL ERROR\n         LNR   R1,R1\nGETOUT   BALR  R14,0              AND USE GOTO TO STOP\n         DROP  R15\n         TITLE 'LIEGOTO -- GOTO LABEL VARIABLE ROUTINE'\n         BANNER LIEGOTO\n         SPACE\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*        LIEGOTO                                                      *\n*                                                                     *\n* FUNCTION -                                                          *\n*        TO GO TO A PSEUDO-PL/I LABEL IN A CALLING ROUTINE,           *\n*        TERMINATING INTERVENING BLOCKS.                              *\n*                                                                     *\n* LINKAGE -                                                           *\n*        BR 14, GENERATED BY THE LIGOTO MACRO.                        *\n*                                                                     *\n* PARAMETERS -                                                        *\n*        REGISTER 0 ADDRESSES THE TARGET ADDRESS AND REGISTER 1       *\n*        CONTAINS THE DSA OF THE ROUTINE TO WHICH CONTROL IS TO BE    *\n*        RETURNED.                                                    *\n*                                                                     *\n* RETURN INFORMATION -                                                *\n*        NONE (CONTROL NEVER RETURNS)                                 *\n***********************************************************************\n         EJECT\n***********************************************************************\n*        LIEGOTO IS CALLED TO TRANSFER TO A PSEUDO-PL/I LABEL IN      *\n*        ANOTHER ROUTINE, GENERATED BY THE LIBEL MACRO. (THE LABEL    *\n*        IN FACT CONTAINS THE SAME INFORMATION AS A PL/I LABEL        *\n*        VARIABLE.) DSA'S FOR ROUTINES BETWEEN THE CALLER AND THE     *\n*        DESTINATION ARE FREED BEFORE THE GOTO IS COMPLETED. ALSO,    *\n*        IF ANY OF THE ROUTINES TO BE TERMINATED HAVE REQUESTED       *\n*        GOTO INTERCEPTION, THEY ARE GIVEN CONTROL TO ALLOW THEM TO   *\n*        CLEAN UP BEFORE THE GOTO COMPLETES.                          *\n***********************************************************************\n         SPACE\n         USING LIEGOTO,R14\n         USING ADSA,R13\nLIEGOTO  CR    R1,R13             FOUND THE RIGHT DSA?\n         BNE   LOWER              NO.\n         SPACE\n***********************************************************************\n*        THE LABEL VALUE CONSISTS OF TWO WORDS. THE FIRST IS THE      *\n*        ADDRESS TO WHICH CONTROL SHOULD BE TRANSFERRED, AND THE      *\n*        SECOND IS THE BASE ADDRESS OF THE ROUTINE, WHICH IS TO BE    *\n*        LOADED INTO REGISTER 2 (THE NORMAL PL/I BASE REGISTER)       *\n*        BEFORE EXECUTING THE BRANCH.                                 *\n***********************************************************************\n         SPACE\n         LR    R2,R0              YES, LOCATE LABEL CONSTANT\n         LM    R1,R2,0(R2)        LOAD ADDR & BASE VALUE\n         BR    R1                 GO TO THE LABEL\n         SPACE\nLOWER    TM    ADSAFLGS+1,ADSABLOK     ARE GOTO'S INTERCEPTED?\n         L     R2,ADSACHN         FIND PREVIOUS DSA\n         BZ    NOBLOCK            NO, EXIT THIS LEVEL\n         L     R2,ADSACHN-ADSA(,R2)    YES, FIND THE ONE BEFORE THAT\n         NI    ADSAFLGS+1,255-ADSABLOK TURN OFF BLOCKING FLAG\n         SPACE\n***********************************************************************\n*        IF THE DSA TO GOTO IS NOT FOUND, AND THIS IS NOT A \"STOP\"    *\n*        REQUEST, ISSUE A MESSAGE AND ABEND, AS THIS SHOULD NOT OCCUR.*\n*        IF IT IS A STOP REQUEST, ISSUE LIEXIT TO DESTROY THE         *\n*        ENVIRONMENT AND PASS A RETURN CODE OF 1000 TO OUR ULTIMATE   *\n*        CALLER.                                                      *\n***********************************************************************\n         SPACE\nNOBLOCK  TM    ADSALEN,ADSAFINL   HAVE WE HIT BOTTOM?\n         BNO   CONTINUE           NO.\n         LTR   R1,R1              YES, EXECUTING STOP?\n         BNZ   NOSTOP             NO.\n         LIEXIT RC=1000           YES, EXIT WITH RC 1000\nNOSTOP   BALR  R2,0\n         USING *,R2\n         LTR   R1,R1              IS THIS SIGNAL ERROR?\n         BM    ERREND             YES, SKIP WTP\n         WTO   'LIE001T LOGIC ERROR -- INVALID USE OF GOTO',           *\n               DESC=7,ROUTCDE=11  TRY TO SEND A MESSAGE\nERREND   ABEND 2000,DUMP          AND DIE AFTER ERROR\n         DROP  R2\n         SPACE\n***********************************************************************\n*        IF THE FATHER OF THE ACTIVE ROUTINE IS INTERCEPTING GOTO'S,  *\n*        RETURN CONTROL THERE, AFTER MODIFYING HIS SAVE AREA SO HE    *\n*        WILL REENTER LIEGOTO WHEN HE RETURNS. ELSE, MODIFY THE       *\n*        ACTIVE ROUTINE'S SAVE AREA SIMILARLY, AND ISSUE LIEXIT TO    *\n*        FREE THAT ROUTINE'S DSA AND VDA'S. LIEXIT WILL THEN RETURN   *\n*        CONTROL TO LIEGOTO (WITH THE SAME PARAMETERS) TO ALLOW THE   *\n*        GOTO TO PROCEED.                                             *\n***********************************************************************\n         SPACE\nCONTINUE STM   R14,R1,12(R2)      CAUSE \"RETURN\" TO LIEGOTO\n         C     R2,ADSACHN         INTERCEPTION IN PROGRESS?\n         BNE   BLOCKRET           YES.\n         LIEXIT ,                 NO, EXIT THIS LEVEL\nBLOCKRET L     R13,ADSACHN        IF INTERCEPTED, RETURN DIRECTLY\n         LM    R14,R11,ADSASAVE\n         BR    R14\n         TITLE 'LIEBLK -- GOTO INTERCEPTION ROUTINE'\n         BANNER LIEBLK\n         SPACE\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*        LIEBLK                                                       *\n*                                                                     *\n* FUNCTION -                                                          *\n*        TO REQUEST INTERCEPTION OF ANY ATTEMPT TO EXIT THE CALLING   *\n*        ROUTINE VIA GOTO. IF SUCH A GOTO OCCURS, CONTROL RETURNS     *\n*        TEMPORARILY TO THE CALLER OF OUR CALLER; ON RETURN THEREFROM,*\n*        THE GOTO IS ALLOWED TO COMPLETE.                             *\n*                                                                     *\n* LINKAGE -                                                           *\n*        CALL, GENERATED BY THE LIBLOCK MACRO.                        *\n*                                                                     *\n* PARAMETERS -                                                        *\n*        REGISTER 1 MUST CONTAIN THE DSA OF THE INTERCEPTING ROUTINE  *\n*        (I.E., OUR CALLER'S CALLER).                                 *\n*                                                                     *\n* RETURN INFORMATION -                                                *\n*        NONE                                                         *\n*                                                                     *\n* NOTE -                                                              *\n*        BYTE 1 OF THE CALLER'S DSA MUST BE SET IN ADVANCE TO X'08'.  *\n*        IF A GOTO IS INTERCEPTED, THE BIT IS TURNED OFF TO INDICATE  *\n*        THIS TO THE INTERCEPTING ROUTINE.                            *\n***********************************************************************\n         EJECT\n***********************************************************************\n*        LIEBLK IS CALLED TO PREVENT GOTO'S OUT OF A ROUTINE. THIS    *\n*        ROUTINE ONLY NEEDS TO CHAIN DSA'S TOGETHER, AS ONLY THE      *\n*        SETTING OF A BIT IN THE DSA IS NECESSARY TO INHIBIT GOTO     *\n*        OUT OF BLOCK (AND THIS MUST BE PERFORMED BY OUR CALLER, AS   *\n*        THAT IS HOW IT IS DONE IN PL/I).                             *\n***********************************************************************\n         SPACE\nLIEBLK   ST    R1,4(,R13)         CHAIN DSA'S TOGETHER\n         BR    R14                AND THEN RETURN\n         TITLE 'LIENSUR/LIERLSE -- GETMAIN ASSURANCE/FREEMAIN RECOVERY *\n               ROUTINES'\n         BANNER LIENSUR\n         SPACE\n         BANNER LIERLSE\n         SPACE\n***********************************************************************\n*                                                                     *\n* ROUTINE NAMES -                                                     *\n*        LIENSUR AND LIERLSE                                          *\n*                                                                     *\n* FUNCTION -                                                          *\n*        TO RESPECTIVELY ENSURE THAT A GETMAIN WILL BE SUCCESSFUL AND *\n*        TO ALLOW THE RECLAMATION OF FREEMAINED MEMORY. THESE ROUTINES*\n*        PERFORM NO FUNCTION IN THE PSEUDO-PL/I ENVIRONMENT; THEY     *\n*        ARE PRESENT FOR RESOLUTION OF REFERENCES BY ROUTINES WHICH   *\n*        REQUIRE THESE SERVICES IN A PL/I CHECKOUT COMPILER           *\n*        ENVIRONMENT.                                                 *\n*                                                                     *\n* LINKAGE -                                                           *\n*        CALL, GENERATED BY THE LINSURE AND LIRLSE MACROS,            *\n*        RESPECTIVELY.                                                *\n*                                                                     *\n* PARAMETERS -                                                        *\n*        FOR LIENSUR, REGISTER 0 CONTAINS THE AMOUNT OF MEMORY        *\n*        TO BE MADE AVAILABLE. NO PARAMETERS ARE PASSED TO LIERLSE.   *\n*                                                                     *\n* RETURN INFORMATION -                                                *\n*        NONE                                                         *\n***********************************************************************\n         EJECT\nLIENSUR  BR    R14                INSURANCE NOT AVAILABLE\n         SPACE 5\nLIERLSE  BR    R14\n         SPACE 3\n         LTORG\n         TITLE 'LIENVASM -- PSEUDO-PL/I CONTROL BLOCK MAPPINGS'\n         ASMTCA\n         SPACE 5\n         ASMDSA\n         EJECT\n         ASMVDA\n         SPACE 5\n         PLIONCB ,                MAP PL/I STATIC ONCB\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LIENVPLI": {"ttr": 5642, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         TITLE 'LIENVPLI -- PL/I ENVIRONMENT INTERFACE ROUTINES'\n         BANNER LIENVPLI\n         SPACE\n***********************************************************************\n*                                                                     *\n* MODULE NAME -                                                       *\n*        LIENVPLI                                                     *\n*                                                                     *\n* FUNCTION -                                                          *\n*        TO SERVE AS AN INTERFACE TO SERVICES OF THE PL/I ENVIRONMENT,*\n*        WITH AS LITTLE DEPENDENCY AS PRACTICAL ON THE IMPLEMENTATION *\n*        OF THAT ENVIRONMENT.                                         *\n*                                                                     *\n* ENVIRONMENT -                                                       *\n*        PL/I (OPTIMIZER OR CHECKOUT)                                 *\n*                                                                     *\n* ENTRY POINTS AND FUNCTIONS -                                        *\n*        LIENTER: OBTAIN DSA ON ROUTINE ENTRY                         *\n*        LIELIFO: OBTAIN VDA (AUTOMATIC STORAGE EXTENSION)            *\n*        LIEXIT:  RETURN FROM ROUTINE, FREEING DSA AND VDA'S          *\n*        LIERETC: RETURN FROM ROUTINE, SETTING A RETURN CODE AND      *\n*                 FREEING DSA AND VDA'S                               *\n*        LIEGET:  OBTAIN NON-LIFO (BASED) STORAGE                     *\n*        LIEFREE: FREE NON-LIFO (BASED) STORAGE                       *\n*        LIENSUR: MAKE MEMORY AVAILABLE FOR GETMAIN                   *\n*        LIERLSE: ALLOW RECLAMATION OF FREED MEMORY                   *\n*        LIESIGN: SIGNAL A PL/I CONDITION (OR ISSUE STOP)             *\n*        LIEGOTO: GOTO A PL/I LABEL VARIABLE                          *\n*        LIEBLK:  INTERCEPT GOTO FROM CALLED ROUTINES                 *\n*                                                                     *\n* NOTE -                                                              *\n*        THE SAME SERVICES AND ENTRY POINTS ARE PROVIDED IN AN        *\n*        ASSEMBLER ENVIRONMENT BY THE LIENVASM MODULE. ROUTINES       *\n*        WHICH REQUEST PL/I ENVIRONMENTAL SERVICES ONLY THROUGH       *\n*        THESE INTERFACES CAN RUN EQUALLY WELL IN THE PSEUDO-PL/I     *\n*        ENVIRONMENT IMPLEMENTED BY THAT MODULE.                      *\n***********************************************************************\n         EJECT\nLIENVPLI CSECT\n         SPACE\n         REGISTER\n         SPACE\nRTCA     EQU   R12                PL/I TCA POINTER\nRDSA     EQU   R13                PL/I DSA POINTER\n         SPACE\n         USING TCA,RTCA\n         SPACE\n         ENTRY LIENTER,LIELIFO,LIERETC,LIEXIT,LIEGET,LIEFREE\n         ENTRY LIENSUR,LIERLSE,LIESIGN,LIEGOTO,LIEBLK\n         TITLE 'LIENTER -- DSA ALLOCATION ROUTINE'\n         BANNER LIENTER\n         SPACE\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*        LIENTER                                                      *\n*                                                                     *\n* FUNCTION -                                                          *\n*        TO OBTAIN A DSA AND AUTOMATIC STORAGE FOR ITS CALLER.        *\n*                                                                     *\n* LINKAGE -                                                           *\n*        BALR R11,R10, GENERATED BY THE LIENTRY MACRO, USED AS THE    *\n*        THE FIRST STATEMENT OF THE CALLING ROUTINE.                  *\n*                                                                     *\n* PARAMETERS -                                                        *\n*        THE SIZE OF THE DSA IS CONTAINED IN REGISTER 0.              *\n*                                                                     *\n* RETURN INFORMATION -                                                *\n*        THE ADDRESS OF THE NEW DSA IS CONTAINED IN REGISTER 13.      *\n***********************************************************************\n         EJECT\n         SPACE\n***********************************************************************\n*        USE THE STANDARD PL/I BLOCK ENTRY CODE TO ALLOCATE A DSA.    *\n***********************************************************************\n         SPACE\n         USING LIENTER,R10\nLIENTER  L     R1,OFNB(,RDSA)     NEXT AVAILABLE BYTE\n         ALR   R0,R1              NEXT AVAIL. AFTER DSA\n         CL    R0,TEOS            IS THERE ENOUGH?\n         BNH   ENOUGH             YES.\n         L     R15,TOVF           NO, CALL OVERFLOW ROUTINE\n         BALR  R14,R15\nENOUGH   ST    R0,OFNB(,R1)       STORE NEW NEXT AVAIL.\n         ST    RDSA,4(,R1)        CHAIN TOGETHER DSA'S\n         MVC   OFLW(4,R1),OFLW(RDSA)   A(LIBRARY WORKSPACE)\n         LA    RDSA,0(,R1)        RDSA-> NEW DSA (CLEAR HIGH-ORDER     *\n                                  BYTE FOR GOTO-OUT-OF-BLOCK)\n         MVC   OFF0(2,RDSA),=AL1(CDSA,0)    ESTABLISH BLOCK TYPE\n         MVC   86(2,RDSA),=X'91C0'     ALLOW PLI ERROR HANDLING\n         BR    R11                BACK TO THE CALLER\n         SPACE\n         DROP  R10\n         TITLE 'LIELIFO -- GET LIFO STORAGE (VDA) ROUTINE'\n         BANNER LIELIFO\n         SPACE\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*        LIELIFO                                                      *\n*                                                                     *\n* FUNCTION -                                                          *\n*        TO OBTAIN WORK STORAGE WHICH WILL BE FREED ON EXIT FROM      *\n*        THE CALLING ROUTINE.                                         *\n*                                                                     *\n* LINKAGE -                                                           *\n*        CALL, GENERATED BY THE LIFO MACRO.                           *\n*                                                                     *\n* PARAMETERS -                                                        *\n*        THE SIZE OF THE STORAGE REQUIRED IS PASSED IN REGISTER 0.    *\n*                                                                     *\n* RETURN INFORMATION -                                                *\n*        THE ADDRESS OF THE ALLOCATED STORAGE IS RETURNED IN REGISTER *\n*        1.                                                           *\n***********************************************************************\n         EJECT\n***********************************************************************\n*        USE THE STANDARD PL/I GET VDA CODE TO ALLOCATE LIFO STORAGE  *\n*        (GOING TO A LIBRARY ROUTINE IF NO STORAGE IS AVAILABLE IN    *\n*        THE ISA).                                                    *\n***********************************************************************\n         SPACE\n         USING LIELIFO,R15\nLIELIFO  L     R1,OFNB(,RDSA)     NEXT AVAILABLE BYTE\n         ALR   R0,R1              END OF NEW AREA\n         CL    R0,TEOS            WILL IT FIT?\n         BNH   YESVDA             YES.\n         ST    R14,OFNB(,RDSA)    SAVE RETURN ADDRESS\n         L     R15,TOVV           GET VDA ROUTINE\n         BALR  R14,R15            GO GET A VDA\n         DROP  R15                OUR BASE IS GONE\n         L     R14,OFNB(,RDSA)    RESTORE RETURN ADDR\nYESVDA   ST    R0,OFNB(,RDSA)     UPDATE AVAIL. POINTER\n         BR    R14                AND RETURN (ADDR. IN R1)\n         TITLE 'LIERETC/LIEXIT -- PROCEDURE EXIT ROUTINES'\n         BANNER LIEXIT\n         SPACE\n         BANNER LIERETC\n         SPACE\n***********************************************************************\n*                                                                     *\n* ROUTINE NAMES -                                                     *\n*        LIEXIT AND LIERETC                                           *\n*                                                                     *\n* FUNCTION -                                                          *\n*        TO RETURN TO OUR CALLER'S CALLER, AFTER FREEING THE DSA AND  *\n*        ANY VDA'S.                                                   *\n*                                                                     *\n* LINKAGE -                                                           *\n*        ENTERED BY BR R14, GENERATED BY THE LIEXIT MACRO.            *\n*                                                                     *\n* PARAMETERS -                                                        *\n*        FOR LIEXIT, NONE. FOR LIERETC, THE RETURN CODE IS PASSED IN  *\n*        REGISTER 15.                                                 *\n*                                                                     *\n* RETURN INFORMATION -                                                *\n*        RETURN IS NOT MADE TO THE CALLING ROUTINE, BUT TO ITS CALLER.*\n*        LIERETC DOES RETURN THE REQUESTED RETURN CODE IN REGISTER 15.*\n***********************************************************************\n         EJECT\n***********************************************************************\n*        LIERETC AND LIEXIT MERELY EXECUTE A STANDARD RETURN SEQUENCE.*\n*        THE DSA AND VDA'S ARE FREED LATER BY THE PL/I LIBRARY WHEN   *\n*        MORE STORAGE IS REQUIRED.                                    *\n***********************************************************************\n         SPACE\n         USING LIERETC,R14\nLIERETC  L     RDSA,4(,RDSA)      FIND PREVIOUS DSA\n         ST    R15,16(,RDSA)      STORE RETURN CODE\n         B     GOHOME\n         DROP  R14\n         SPACE\nLIEXIT   L     RDSA,4(,RDSA)      FIND PREVIOUS DSA\nGOHOME   LM    R14,R11,12(RDSA)   RESTORE THE REGS\n         BR    R14                AND RETURN\n         TITLE 'LIEGET/LIEFREE -- NON-LIFO STORAGE GET AND FREE ROUTINE*\n               S'\n         BANNER LIEGET\n         SPACE\n         BANNER LIEFREE\n         SPACE\n***********************************************************************\n*                                                                     *\n* ROUTINE NAMES -                                                     *\n*        LIEGET AND LIEFREE                                           *\n*                                                                     *\n* FUNCTION -                                                          *\n*        TO ALLOCATE AND FREE (RESPECTIVELY) NON-LIFO STORAGE, I.E.,  *\n*        STORAGE WHOSE LIFETIME IS NOT THE SAME AS THAT OF THE        *\n*        CALLING ROUTINE.                                             *\n*                                                                     *\n* LINKAGE -                                                           *\n*        CALL, GENERATED BY THE LIGET AND LIFREE MACROS, RESPECTIVELY.*\n*                                                                     *\n* PARAMETERS -                                                        *\n*        R0 CONTAINS THE AMOUNT OF STORAGE TO ALLOCATE OR FREE. FOR   *\n*        LIEFREE, R1 CONTAINS THE AREA TO FREE.                       *\n*                                                                     *\n* RETURN INFORMATION -                                                *\n*        FOR LIEGET, R1 WILL CONTAIN THE ADDRESS OF THE ALLOCATED     *\n*        MEMORY. NO INFORMATION IS RETURNED FROM LIEFREE.             *\n***********************************************************************\n         EJECT\n***********************************************************************\n*        LIEGET AND LIEFREE MERELY PASS THEIR PARAMETERS ON TO THE    *\n*        PL/I LIBRARY, WHICH DOES ALL THE WORK.                       *\n***********************************************************************\n         SPACE\nLIEGET   L     R15,TGET           NON-LIFO GET ROUTINE\n         BR    R15                CALL, RETURN VIA R14\n         SPACE 10\nLIEFREE  L     R15,TFRE           NON-LIFO FREE ROUTINE\n         BR    R15                CALL, RETURN VIA R14\n         TITLE 'LIENSUR/LIERLSE -- GETMAIN ASSURANCE/FREEMAIN RECOVERY *\n               ROUTINES'\n         BANNER LIENSUR\n         SPACE\n         BANNER LIERLSE\n         SPACE\n***********************************************************************\n*                                                                     *\n* ROUTINE NAMES -                                                     *\n*        LIENSUR AND LIERLSE                                          *\n*                                                                     *\n* FUNCTION -                                                          *\n*        TO RESECTIVELY ENSURE THAT A GETMAIN WILL BE SUCCESSFUL AND  *\n*        TO ALLOW THE RECLAMATION OF FREEMAINED MEMORY. THESE ROUTINES*\n*        ARE EFFECTIVE ONLY IN A CHECKOUT COMPILER ENVIRONMENT.       *\n*                                                                     *\n* LINKAGE -                                                           *\n*        CALL, GENERATED BY THE LINSURE AND LIRLSE MACROS,            *\n*        RESPECTIVELY.                                                *\n*                                                                     *\n* PARAMETERS -                                                        *\n*        FOR LIENSUR, REGISTER 0 CONTAINS THE AMOUNT OF MEMORY        *\n*        TO BE MADE AVAILABLE. NO PARAMETERS ARE PASSED TO LIERLSE.   *\n*                                                                     *\n* RETURN INFORMATION -                                                *\n*        NONE                                                         *\n***********************************************************************\n         EJECT\n***********************************************************************\n*        IN A CHECKOUT COMPILER ENVIRONMENT, CALL THE GETMAIN         *\n*        ASSURANCE OR FREEMAIN RECOVERY ROUTINE. OTHERWISE, DO        *\n*        NOTHING.                                                     *\n***********************************************************************\n         SPACE\nLIENSUR  TM    TFB0,TTCK           CHECKOUT ENVIRONMENT?\n         BCR   8,R14               NO, DO NOTHING\n         L     R15,TGAR            YES, CALL GETMAIN ASSURANCE\n         BR    R15                 RETURN VIA R14\n         SPACE 10\nLIERLSE  TM    TFB0,TTCK           CHECKER ACTIVE?\n         BCR   8,R14               NO.\n         L     R15,TFRR            YES, CALL FREEMAIN RECOVERY\n         BR    R15                 AND RETURN VIA R14\n         TITLE 'LIESIGN -- SIGNAL PL/I CONDITION ROUTINE'\n         BANNER LIESIGN\n         SPACE\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*        LIESIGN                                                      *\n*                                                                     *\n* FUNCTION -                                                          *\n*        TO SIGNAL A PL/I CONDITION (OR ISSUE A PL/I STOP, WHICH IS   *\n*        REALLY A PECULIAR WAY OF SIGNALLING FINISH).                 *\n*                                                                     *\n* LINKAGE -                                                           *\n*        CALL, GENERATED BY THE LISIGNAL MACRO.                       *\n*                                                                     *\n* PARAMETERS -                                                        *\n*        REGISTER 1 ADDRESS A PL/I CONDITION WORD, WHICH DEFINES      *\n*        THE CONDITION TO BE SIGNALLED.                               *\n*                                                                     *\n* RETURN INFORMATION -                                                *\n*        NONE                                                         *\n***********************************************************************\n         EJECT\n***********************************************************************\n*        THE SIGNAL IS PERFORMED BY PASSING CONTROL TO THE PL/I       *\n*        ERROR HANDLER.                                               *\n***********************************************************************\n         SPACE\nLIESIGN  L     R15,TERR           ERROR HANDLER ADDRESS\n         BR    R15                CALL, RETURN VIA R14\n         TITLE 'LIEGOTO -- GOTO LABEL VARIABLE ROUTINE'\n         BANNER LIEGOTO\n         SPACE\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*        LIEGOTO                                                      *\n*                                                                     *\n* FUNCTION -                                                          *\n*        TO GO TO A PL/I LABEL IN A CALLING ROUTINE, TERMINATING      *\n*        INTERVENING BLOCKS.                                          *\n*                                                                     *\n* LINKAGE -                                                           *\n*        BR 14, GENERATED BY THE LIGOTO MACRO.                        *\n*                                                                     *\n* PARAMETERS -                                                        *\n*        REGISTER 0 ADDRESSES THE TARGET ADDRESS AND REGISTER 1       *\n*        CONTAINS THE DSA OF THE ROUTINE TO WHICH CONTROL IS TO BE    *\n*        RETURNED.                                                    *\n*                                                                     *\n* RETURN INFORMATION -                                                *\n*        NONE (CONTROL NEVER RETURNS)                                 *\n***********************************************************************\n         EJECT\n***********************************************************************\n*        CONTROL IS PASSED IMMEDIATELY TO THE PL/I NON-LOCAL GOTO     *\n*        CODE IN THE TCA, AFTER COPYING THE PARANETERS TO THE PL/I    *\n*        LIBRARY'S PREFERRED REGISTERS.                               *\n***********************************************************************\n         SPACE\nLIEGOTO  LR    R14,R0             COPY PARMS TO PL/I REGS\n         LR    R15,R1\n         BAL   R1,TGTC            GO TO GOOB CODE IN TCA\n         TITLE 'LIEBLK -- GOTO INTERCEPTION ROUTINE'\n         BANNER LIEBLK\n         SPACE\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*        LIEBLK                                                       *\n*                                                                     *\n* FUNCTION -                                                          *\n*        TO REQUEST INTERCEPTION OF ANY ATTEMPT TO EXIT THE CALLING   *\n*        ROUTINE VIA GOTO. IF SUCH A GOTO OCCURS, CONTROL RETURNS     *\n*        TEMPORARILY TO THE CALLER OF OUR CALLER; ON RETURN THEREFROM,*\n*        THE GOTO IS ALLOWED TO COMPLETE.                             *\n*                                                                     *\n* LINKAGE -                                                           *\n*        CALL, GENERATED BY THE LIBLOCK MACRO.                        *\n*                                                                     *\n* PARAMETERS -                                                        *\n*        REGISTER 1 MUST CONTAIN THE DSA OF THE INTERCEPTING ROUTINE  *\n*        (I.E., OUR CALLER'S CALLER).                                 *\n*                                                                     *\n* RETURN INFORMATION -                                                *\n*        NONE                                                         *\n*                                                                     *\n* NOTE -                                                              *\n*        BYTE 1 OF THE CALLER'S DSA MUST BE SET IN ADVANCE TO X'08'.  *\n*        IF A GOTO IS INTERCEPTED, THE BIT IS TURNED OFF TO INDICATE  *\n*        THIS TO THE INTERCEPTING ROUTINE.                            *\n***********************************************************************\n         EJECT\n***********************************************************************\n*        LIEBLK IS CALLED TO BLOCK GOTO'S OUT OF A ROUTINE WHICH      *\n*        MUST HAVE CONTROL BACK BEFORE IT IS TERMINATED (SUCH AS      *\n*        AN EXIT ROUTINE). THE BLOCKAGE IS ACCOMPLISHED BY ALTERING   *\n*        DSA'S SO THAT THE INTERCEPTOR APPEARS TO BE THE PL/I SORT    *\n*        INTERFACE, WHICH NEEDS TO CATCH NON-LOCAL GOTO'S IN ORDER TO *\n*        TERMINATE THE SORT.                                          *\n***********************************************************************\n         SPACE\n         USING LIEBLK,R15\nLIEBLK   ST    R1,4(,RDSA)        CHAIN DSA'S TOGETHER\n         MVI   OFF0(RDSA),CDSA+CONB    PRETEND TO BE LIBRARY ROUTINE\n         MVC   86(2,RDSA),=X'91C0'\n         MVC   OFLW(8,RDSA),OFLW(R1)   COPY LWS INFO\n         MVI   OFXQ(RDSA),2       FOR GOTO RECOVERY\n         OI    TFB1,TGFS          SET SORT-EXIT-ACTIVE\n         BR    R14                AND RETURN\n         DROP  R15\n         SPACE 5\n         LTORG\n         TITLE 'LIENVPLI -- PL/I CONTROL BLOCK MAPPINGS'\n         PLIDSA ,                 DEFINE DSA OFFSETS\n         SPACE\n         PLITCA ,                 DEFINE USEFUL TCA FIELDS\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LIERRSET": {"ttr": 5895, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&L       LIERRSET &EXIT\n.*       THIS MACRO GENERATES CODE TO ESTABLISH A PROGRAM-CHECK\n.*       EXIT IN THE ASSEMBLER VERSION OF THE LANGUAGE-INDEPENDENT\n.*       ENVIRONMENT.\n&L       IHBINNRA &EXIT\n         L     R15,=V(LIERSET)\n         BALR  R14,R15            ESTABLISH PGM CHECK EXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LIERSET": {"ttr": 5897, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         TITLE 'LIERSET -- ASSEMBLER ENVIRONMENT ERROR TRACE ROUTINE'\n         BANNER LIERSET\n         SPACE\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*        LIERSET                                                      *\n*                                                                     *\n* FUNCTION -                                                          *\n*        TO ESTABLISH HELPFUL PROGRAM-CHECK HANDLING IN A PSEUDO-PL/I *\n*        (LIE) ENVIRONMENT. THE HANDLING IS CANCELLED AUTOMATICALLY   *\n*        BY LIEXIT ON EXIT FROM THE CALLING PROCEDURE.                *\n*                                                                     *\n* ENVIRONMENT -                                                       *\n*        PSEUDO-PL/I                                                  *\n*                                                                     *\n* LINKAGE -                                                           *\n*        CALL, GENERATED BY THE LIERRSET MACRO.                       *\n*                                                                     *\n* PARAMETERS -                                                        *\n*        REGISTER 1 CONTAINS THE ADDRESS TO WHICH CONTROL IS TO BE    *\n*        TRANSFERRED AFTER A PROGRAM CHECK. AS THE CONTENTS OF THE    *\n*        REGISTERS AT THIS TIME (PARTICULARLY THE DSA REGISTER) ARE   *\n*        UNPREDICTABLE, IT IS ASSUMED THIS WILL ADDRESS A LIGOTO      *\n*        MACRO, WHICH WILL RESTORE A PREDICTABLE ENVIRONMENT.         *\n*                                                                     *\n* RETURN INFORMATION -                                                *\n*        NONE                                                         *\n***********************************************************************\n         EJECT\nLIERRASM LISECT\n         SPACE\nLIERSET  LIENTRY PARM=R2,DSALEN=88,DSA=*\n         EJECT\n***********************************************************************\n*        THIS ROUTINE IS CALLED TO ESTABLISH AN ERROR EXIT POINT FOR  *\n*        THE DURATION OF THE CALLING PROCEDURE. IT ISSUES A SPIE MACRO*\n*        AND STORES INFORMATION IN THE DSA AND PSEUDO-TCA FOR USE BY  *\n*        LIEXIT ON TERMINATION OF THE CALLING PROCEDURE.              *\n***********************************************************************\n         SPACE\n         USING ATCA,R12\n         USING ADSA,R3\n         SPACE\n         L     R3,ADSACHN-ADSA(,R13)   FIND CALLER'S SAVE AREA\n         CLI   ATCAOPIC,0         HAS A SPIE BEEN ISSUED?\n         BNE   ALREADY            YES.\n         MVC   ATCAPICA(6),PICA   NO, DO IT NOW\n         SPIE  MF=(E,ATCAPICA)    ALL BUT SIGNIF & FIXOFL\n         ST    R1,ATCAOPIC        SAVE OLD PICA ADDR\n         MVI   ATCAOPIC,X'FF'     NOTE SPIE ACTIVE\n         MVI   ADSAOERX,X'FF'     NOTE SPIE ISSUED HERE\n         B     SAVEOLD\n         SPACE\nALREADY  OC    ADSAOERX,ADSAOERX  IS THIS A REPEAT CALL?\n         BNZ   REPEAT             YES, DON'T CHANGE OLD\nSAVEOLD  MVC   ADSAOERX+1(3),ATCAERRX  NO, SAVE PREVIOUS EXIT POINT\nREPEAT   ST    R2,ATCAERRX        SAVE NEW EXIT POINT\n         SPACE\n         LIEXIT ,                 RETURN TO CALLER\n         SPACE\nPICA     SPIE  LIERROR,((1,7),(9,13),15),MF=L\n         SPACE\n         DROP  R3\n         TITLE 'LIERROR -- PSEUDO-PL/I ENVIRONMENT PROGRAM CHECK EXIT'\n         BANNER LIERRROR\n         SPACE\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*        LIERROR                                                      *\n*                                                                     *\n* FUNCTION -                                                          *\n*        TO SERVE AS A SPIE EXIT IN A PSEUDO-PL/I ENVIRONMENT. IT     *\n*        ARRANGES FOR CONTROL TO PASS TO THE LIESNAP ROUTINE, AS IF   *\n*        IT HAD BEEN CALLED NORMALLY, SO THAT PROGRAM CHECKS DURING   *\n*        ITS EXECUTION CAN ALSO BE RECOVERED.                         *\n*                                                                     *\n* ENVIRONMENT -                                                       *\n*        PSEUDO-PL/I. THIS CODE RUNS AS AN OS SPIE EXIT               *\n*                                                                     *\n* LINKAGE -                                                           *\n*        CALL FROM THE OPERATING SYSTEM PROGRAM CHECK HANDLER (AS A   *\n*        SPIE EXIT).                                                  *\n*                                                                     *\n* PARAMETERS -                                                        *\n*        REGISTER 1 CONTAINS THE ADDRESS OF THE PROGRAM INTERRUPTION  *\n*        ELEMENT (PIE).                                               *\n*                                                                     *\n* RETURN INFORMATION -                                                *\n*        THE ADDRESS TO RESUME AT (THE LIESNAP ROUTINE) IS RETURNED   *\n*        IN THE PIE.                                                  *\n*                                                                     *\n* NOTE -                                                              *\n*        IF A PROGRAM CHECK OCCURS IN CODE WHICH DOES NOT RUN IN THE  *\n*        PSEUDO-PL/I ENVIRONMENT (AN EXIT ROUTINE), OR AFTER THE      *\n*        ENVIRONMENT HAS BEEN CORRUPTED, THIS ROUTINE WILL ALMOST     *\n*        CERTAINLY PROGRAM CHECK AGAIN, DUE TO THE DEPENDENCE OF      *\n*        THE LIENTER ROUTINE ON THE CONTENTS OF REGISTERS 12 AND 13.  *\n***********************************************************************\n         EJECT\n***********************************************************************\n*        THIS ROUTINE IS ENTERED AS A SPIE EXIT AFTER A PROGRAM CHECK.*\n*        IT USES LIENTRY TO CREATE AND CHAIN A SAVE AREA (WHICH       *\n*        ASSUMES, INCIDENTALLY, THAT REGISTER 13 PRESENTLY ADDRESSES  *\n*        A LIE DSA). WHEN CONTROL IS PASSED (THROUGH THE MARVELS OF   *\n*        THE PROGRAM CHECK HANDLER) TO LIESNAP, IT WILL HAVE THE USE  *\n*        OF THAT SAVE AREA.                                           *\n***********************************************************************\n         SPACE\nLIERROR  LIENTRY PARM=R9          OBTAIN & CHAIN NEW DSA\n         L     R8,ADSACHN-ADSA(,R13)   FIND R13 AT TIME OF ERROR\n         USING ADSA,R8\n         L     R7,ADSASAVE        LOAD SYSTEM RETURN POINT\n         MVC   ADSASAVE(20),12(R9)     COPY PIE REGS TO DSA\n         MVC   DSAPIE(12),0(R9)   SAVE INTERRUPT INFO\n         LR    R14,R7\n         MVC   9(3,R9),=AL3(LIESNAP)   SET RETURN POINT FROM SYSTEM\n         BR    R14\n         TITLE 'LIESNAP -- PSEUDO-PL/I DIAGNOSTIC TRACE ROUTINE'\n         BANNER LIESNAP\n         SPACE\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*        LIESNAP                                                      *\n*                                                                     *\n* FUNCTION -                                                          *\n*        TO USE WTP TO WRITE A TRACE OF ACTIVE ROUTINE NAMES AND      *\n*        OFFSETS FOR DIAGNOSTIC PURPOSES, AND THEN RETURN CONTROL TO  *\n*        THE EXIT POINT REQUESTED BY THE MOST RECENT USE OF LIERSET.  *\n*                                                                     *\n* ENVIRONMENT -                                                       *\n*        PSEUDO-PL/I                                                  *\n*                                                                     *\n* LINKAGE -                                                           *\n*        ENTERED FROM THE SUPERVISOR AS A SPIE \"RETRY\" ROUTINE.       *\n*                                                                     *\n* PARAMETERS -                                                        *\n*        THE PIE FOR THE ORIGINAL PROGRAM CHECK HAS BEEN STORED IN    *\n*        THE CURRENT DSA.                                             *\n*                                                                     *\n* RETURN INFORMATION -                                                *\n*        NONE                                                         *\n*                                                                     *\n* NOTE -                                                              *\n*        THIS ROUTINE RETURNS VIA INTENTIONAL PROGRAM CHECK, SO THAT  *\n*        RETURN CAN BE EFFECTED WITH THE REGISTERS AT THE TIME OF     *\n*        ERROR INTACT, A FEAT THAT CAN ONLY BE ACCOMPLISHED BY A      *\n*        DELIBERATE PROGRAM CHECK AND A COOPERATIVE SPIE ROUTINE.     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*        THIS ROUTINE TRAVERSES THE SAVE AREA CHAIN AND WRITES (USING *\n*        WTP) A TRACEBACK FROM THE POINT OF ERROR. IF A PROGRAM CHECK *\n*        OCCURS DURING THIS PROCESS, THE ATTEMPT IS ABANDONED.        *\n***********************************************************************\n         SPACE\n         ENTRY LIESNAP\n         SPACE\nLIESNAP  MVC   ATCAPICA+1(3),=AL3(LIERCUR)  PROTECT FROM RECURSION\n         LA    R3,15\n         N     R3,DSAPIE+4        ISOLATE PGM CHECK NUMBER\n         LA    R3,HEX(R3)\n         XWTO  'LIE100L PROGRAM CHECK ',                               *\n               (CODE,(R3),1),' AT',DESC=7,ROUTCDE=11,                  *\n               MF=(G,DSAMSG,MSGLEN1)   HEADING MESSAGE\n         SPACE\n         XWTO  '  ',(NAME,8' '),'    ',(ADDR,7' '),'  ',               *\n               (FROM,'FROM'),DESC=7,ROUTCDE=11,                        *\n               MF=(L,DSAMSG,MSGLEN2)   BUILD BASIC TRACE MSG\n         L     R5,DSAPIE+8        START WITH INTERRUPT POINT\n         L     R4,ADSACHN         LOCATE 1 EARLIER SAVE AREA\n         SPACE\n***********************************************************************\n*        THIS CODE ASSUMES THAT ALL ACTIVE ROUTINES OBEY PL/I         *\n*        CONVENTIONS FOR LOCATION OF THE ROUTINE NAME (HONORED BY     *\n*        THE LIENTRY MACRO).                                          *\n***********************************************************************\n         SPACE\nTRACE    L     R7,ADSASAVE+4-ADSA(R4)       FIND ENTRY TO THIS PROC\n         LA    R3,0(,R7)          SAVE IT\n         BCTR  R7,0\n         CLI   0(R7),0            LOOK AT NAME LENGTH\n         BE    STARNAME           MAKE SURE 1-8 CHARS\n         CLI   0(R7),8\n         BH    STARNAME           IF NOT, NAME IS UNKNOWN\n         SR    R6,R6\n         IC    R6,0(,R7)\n         SR    R7,R6              R7->PROC NAME\n         MVC   DSANAME,=CL8' '\n         BCTR  R6,0\n         EX    R6,COPYNAME\n         TM    ADSALEN,ADSAFINL   IS THIS THE MAIN PROC?\n         BNO   NOTMAIN            NO.\n         XWTO  (FROM,'MAIN'),MF=(M,DSAMSG)  YES, UPDATE MSG\n         SPACE\n***********************************************************************\n*        ADDRESSES ARE PRINTED AS RELATIVE ADDRESSES IF REASONABLE,   *\n*        OR AS ABSOLUTE ADDRESSES IF NOT.                             *\n***********************************************************************\n         SPACE\nNOTMAIN  LA    R1,0(,R5)\n         SR    R1,R3              DETERMINE OFFSET\n         LPR   R0,R1              SEE IF MAGNITUDE REASONABLE\n         C     R0,=F'16384'\n         BH    ABSADDR            NO, TREAT AS ABSOLUTE ADDR\n         STH   R0,DSAHWK          YES, CONVERT OFFSET TO HEX\n         MVI   DSAHWK+2,X'04'\n         UNPK  DSAABUF+1(5),DSAHWK(3)\n         TR    DSAABUF+1(4),HEX-240\n         MVI   DSAABUF+6,C' '\n         MVI   DSAABUF,C'+'       ASSUME POSITIVE OFFSET\n         LTR   R1,R1\n         BNM   SENDTRAC\n         MVI   DSAABUF,C'-'       NOPE, CHANGE TEXT\n         B     SENDTRAC\n         SPACE\nSTARNAME MVC   DSANAME,=C'*UNKNOWN'\nABSADDR  ST    R5,DSAHWK          CONVERT ADDR TO HEX\n         MVI   DSAHWK+4,X'B4'     ->'.' ON UNPK\n         UNPK  DSAABUF(7),DSAHWK+1(4)\n         TR    DSAABUF(6),HEX-240\n         SPACE\nSENDTRAC XWTO  (NAME,DSANAME),(ADDR,DSAABUF),MF=(E,DSAMSG)             *\n                                  SEND TRACE LINE\n         SPACE\n         TM    ADSALEN,ADSAFINL   REACHED THE END?\n         BO    TRACED             YES, TRACE DONE\n         LR    R8,R4              NO, CONTINUE\n         L     R5,ADSASAVE        LOCATE POINT OF CALL\n         L     R4,ADSACHN         LOCATE PREVIOUS AREA\n         B     TRACE              AND CONTINUE\n         SPACE\n***********************************************************************\n*        TO GET TO THE EXIT POINT, WE FORCE A PROGRAM CHECK SO WE     *\n*        CAN RESUME AT THE EXIT POINT WITH THE ORIGINAL REGS.         *\n***********************************************************************\n         SPACE\nTRACED   MVC   ATCAPICA+1(3),=AL3(LIERRET)  ESTABLISH RETURN POINT\n         DC    H'0'               AND FALL INTO IT\nHEX      DC    C'0123456789ABCDEF'\nCOPYNAME MVC   DSANAME(0),0(R7)   MOVE PROC NAME TO DSA\n         TITLE 'LIERRET -- ROUTINE TO EXIT TO USER ERROR LABEL'\n         BANNER LIERRET\n         SPACE\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*        LIERRET                                                      *\n*                                                                     *\n* FUNCTION -                                                          *\n*        TO ROUTE CONTROL TO A PREVIOUSLY SPECIFIED ADDRESS AFTER A   *\n*        PROGRAM CHECK.                                               *\n*                                                                     *\n* ENVIRONMENT -                                                       *\n*        PSEUDO-PL/I. THIS CODE EXECUTES AS AN OS SPIE EXIT.          *\n*                                                                     *\n* LINKAGE -                                                           *\n*        CALL FROM THE OPERATING SYSTEM PROGRAM CHECK HANDLER (AS A   *\n*        SPIE EXIT).                                                  *\n*                                                                     *\n* PARAMETERS -                                                        *\n*        REGISTER 1 CONTAINS THE ADDRESS OF THE PROGRAM INTERRUPTION  *\n*        ELEMENT (PIE).                                               *\n*                                                                     *\n* RETURN INFORMATION -                                                *\n*        THE ADDRESS TO RESUME AT (THE USER'S LABEL) IS RETURNED      *\n*        IN THE PIE.                                                  *\n***********************************************************************\n         EJECT\n***********************************************************************\n*        THIS ROUTINE MODIFIES ITS DSA (OBTAINED BY LIERROR) TO       *\n*        RETURN TO THE SPIE EXIT RETURN ADDRESS PASSED IN REGISTER    *\n*        14. IT THEN ESTABLISHES THE USER'S LABEL AS THE SPIE RETRY   *\n*        POINT AND ISSUES LIEXIT. LIEXIT WILL FREE THE DSA AND RETURN *\n*        TO THE SYSTEM, WHICH WILL ROUTE CONTROL BACK TO THE SPECIFIED*\n*        ADDRESS.                                                     *\n***********************************************************************\n         SPACE\n         ENTRY LIERRET\n         SPACE\nLIERRET  MVC   ATCAPICA+1(3),=AL3(LIERROR)  RESTORE NORMAL ERREXIT\n         L     R8,ADSACHN-ADSA(,R13)   FIND USER'S DSA\n         MVC   12(20,R1),ADSASAVE RESTORE ORIGINAL 14-2\n         ST    R14,ADSASAVE       SAVE SYSTEM RETURN FOR LIEXIT\n         MVC   9(3,R1),ATCAERRX+1 RETURN TO USER EXIT\n         LIEXIT ,                 RETURN & RELEASE DSA\n         TITLE 'LIERCUR -- LIE PROGRAM CHECK RECURSION ROUTINE'\n         BANNER LIERCUR\n         SPACE\n***********************************************************************\n*                                                                     *\n* ROUTINE NAME -                                                      *\n*       LIERCUR                                                       *\n*                                                                     *\n* FUNCTION -                                                          *\n*        TO RECOVER FROM A PROGRAM CHECK DURING THE LIESNAP TRACE     *\n*        OUTPUT ROUTINE.                                              *\n*                                                                     *\n* ENVIRONMENT -                                                       *\n*        PSEUDO-PL/I. THIS ROUTINE IS ENTERED AS AN OS SPIE EXIT.     *\n*                                                                     *\n* LINKAGE -                                                           *\n*        CALL FROM THE OPERATING SYSTEM PROGRAM CHECK HANDLER (AS A   *\n*        SPIE EXIT).                                                  *\n*                                                                     *\n* PARAMETERS -                                                        *\n*        REGISTER 1 CONTAINS THE ADDRESS OF THE PROGRAM INTERRUPTION  *\n*        ELEMENT (PIE).                                               *\n*                                                                     *\n* RETURN INFORMATION -                                                *\n*        THE ADDRESS TO RESUME AT (THE USER'S LABEL) IS RETURNED      *\n*        IN THE PIE.                                                  *\n***********************************************************************\n         EJECT\n         ENTRY LIERCUR\n         SPACE\n***********************************************************************\n*        THIS ROUTINE IS ENTERED IF A PROGRAM CHECK OCCURS DURING THE *\n*        WRITING OF THE TRACEBACK. IT WRITES A DESPARATE MESSAGE AND  *\n*        EXITS TO THE USER'S ERROR EXIT LABEL.                        *\n***********************************************************************\n         SPACE\nLIERCUR  LR    R2,R14             SAVE THE RETURN ADDRESS\n         LR    R3,R1\n         XWTO  'LIE101L TRACEBACK TERMINATED. ERROR IN SAVE AREA CHAIN'*\n               ,DESC=7,ROUTCDE=11\n         LR    R14,R2             RESTORE RETURN ADDRESS\n         LR    R1,R3\n         B     LIERRET            GO RETURN TO USER LABEL\n         SPACE\n         LTORG\n         TITLE 'LIERSET -- DATA AREAS'\nDSA      DSECT ,                  DSA FOR LIERROR & FRIENDS\n         DS    22A\nDSAPIE   DS    3A                 SAVE AREA FOR PIE INFO\nDSAHWK   DS    2A                 HEX WORK AREA\nDSAMSG   DS    CL(MSGLEN1)        WTO AREA\n         ORG   DSAMSG\n         DS    CL(MSGLEN2)\n         ORG   ,                  MAKE ROOM FOR BOTH MESSAGES\nDSANAME  DS    CL8                PROC NAME AREA\nDSAABUF  DS    CL7                ADDRESS WORK AREA\n         DS    0D\n         SPACE\nDSALEN   EQU   *-DSA              LENGTH OF OUR DSA\n         EJECT\n         ASMTCA\n         SPACE 5\n         ASMDSA\n         SPACE\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LIES@": {"ttr": 6148, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "1\n-\n      The Language Independent  Environment (LIE)  is two  different things.\n      It  is a  mechanism by  which assembler  subroutines can  make use  of\n      services of the  PL/I Optimizer/Checker environment.   It  can also be\n      used to  provide PL/I-like services  in a pure  assembler environment;\n      these  services include  simulation of  AUTOMATIC storage  management,\n      block structure, ON-units, SIGNAL and GOTO out-of-block.\n0     The LIE services are requested via macro  calls.   In a few cases,  it\n      may be necessary to set or test bits in the PL/I TCA or DSA,  mappings\n      for which  may be obtained using  the PLITCA and PLIDSA  macros.   The\n      functional LIE macros and what they do are as follows:\n0          LIBEL -- Define a label for use later as a target of LIGOTO.\n           LIBLOCK -- Request temporary interception of LIGOTO.\n           LIENTRY -- Define an internal or external \"procedure\".\n           LIERRSET  --  Define  program check  handling  in  a  pseudo-PL/I\n                environment.\n           LIEXIT -- Return from a \"procedure\" to its caller.\n           LIFO -- Obtain LIFO (block-related) storage.\n           LIFREE -- Free non-LIFO storage.\n           LIGET -- Get non-LIFO storage.\n           LIGOTO -- GOTO a PL/I label variable  or a label defined by LIBEL\n                in another \"procedure\".\n           LINSURE -- In  a Checkout compiler environment,   invoke \"GETMAIN\n                assurance\".\n           LION -- Define an \"ON-unit\".\n           LIONCB -- Generate space  for ON control blocks in the  DSA for a\n                \"procedure\".\n           LIREVERT -- Cancel an \"ON-unit\".\n           LIRLSE -- In  a Checkout compiler environment,   invoke \"FREEMAIN\n                recovery\".\n           LISECT -- Define a CSECT containing  one or more procedures using\n                LIENTRY.\n           LISIGNAL -- Signal a PL/I condition or simulate a STOP statement.\n-     Now, in a more pedagogical order, here is how the macros are used:\n-     LISECT is used  to define a CSECT  which contains one or  more uses of\n      LIENTRY.  Its syntax is:\n0          &LABEL   LISECT &ON=NO\n0     &LABEL defines the  CSECT name,  and &ON specifies whether  on not the\n      LION macro will be used.   It is strongly recommended that K'&LABEL be\n      8;  for PL/I compatibility,  I suggest that  &LABEL be the name of the\n      first entry point, followed by a '1'.\n-     LIENTRY  is  used  to  define  a   procedure.    Three  forms  can  be\n      distinguished:  external procedures (callable from outside),  internal\n      procedures,   and  main  procedures (which  initialize  a  pseudo-PL/I\n      environment on entry).  The syntax of LIENTRY is:\n0          &LABEL   LIENTRY &DSA=DSA,&DSALEN=DSALEN,&BASE=R11,&PARM=R2,\n                          &ISASIZE=,&ENV=\n0     &LABEL defines the  procedure name.   For an  external procedure,  the\n      name must be shorter than 8 characters;  by convention, internal names\n      are exactly  eight characters  long.   &DSA  defines the  name of  the\n      procedure's DSA,   and &DSALEN  defines its  length (which  must be  a\n      multiple of 8).   When LIENTRY is used normally,  a DSECT named DSA is\n      defined to include  AUTOMATIC storage as well as a  PL/I register save\n      area,  and DSALEN is  equated to the length of the  DSECT (forced to a\n      doubleword multiple).   DSA=*,DSALEN=88  can be specified when  you do\n      not need to define a DSA DSECT for  your own data.   (Note that if you\n      use the LION  macro,  an explicit DSA definition  is mandatory.   Also\n      note that the first  88 bytes of the DSA (116 when  LION is used)  are\n      reserved for  use by  the environment,  and  so must  not be  used for\n      anything else.)   &BASE specifies the base register for the procedure,\n      and &PARM specifies  a register to which  the contents of R1  at entry\n      are to be copied.\n0     If  &ISASIZE  is  specified,   the procedure  is  defined  as  a  main\n      procedure,  and the value of &ISASIZE  defines the size of its initial\n      storage area.    The LIENTRY code in  this case will call  the LIEBEGN\n      routine to setup a pseudo-PL/I environment.\n1\n0                                                                     PAGE 2\n0     If  &ENV  is specified,   the  procedure  is  defined as  an  internal\n      procedure.    &ENV in  this case  defines  a register  into which  the\n      contents of R5 on entry should be copied.  It is expected that R5 will\n      point to the DSA of the  containing external procedure;  it is easiest\n      (if you have  registers to spare)  to just  set up R5 this  way at the\n      start and not worry about it thereafter.\n-     LIEXIT is used to return from a procedure.  Its syntax is:\n0          &LABEL   LIEXIT &RC=\n0     &RC may be used to specify a code  which is to be returned in R15;  if\n      &RC is omitted, the contents of R15 on entry are restored.\n-     The LIFO macro  is used to obtain  LIFO storage,  which will  be freed\n      when LIEXIT is used to return.   (In PL/I terms, it gets a VDA.)   Its\n      syntax is:\n0          &LABEL   LIFO  &LV=\n0     &LV is the  amount of storage to obtain  (in bytes).   If it  is not a\n      multiple of eight, terrible things will happen.\n-     The LIGET macro is  used just like LIFO,  except that  it obtains non-\n      LIFO storage which must be explicitly freed with LIFREE.  In a pseudo-\n      PL/I environment,   storage allocated  by LIGET  is not  automatically\n      freed when the main procedure is LIEXITed.\n-     The LIFREE  macro is used  to free  storage allocated by  LIGET.   Its\n      syntax is:\n0          &LABEL   LIFREE &A=,&LV=\n0     &A defines the  location of the area  to free,  and &LV  its length (a\n      multiple of 8).\n-     The LINSURE macro  is used to attempt  to assure that,  in  a Checkout\n      compiler environment,  a  later use of GETMAIN will not  fail.   (In a\n      non-Checkout environment, it has no effect.)  Its syntax is:\n0          &LABEL   LINSURE &LV=\n0     &LV is the amount  of storage which will soon be  required;  it may be\n      expressed as an integer constant followed by the letter K.\n-     The LIRLSE  macro is  used,  in a  Checkout compiler  environment,  to\n      inform the  compiler that  it may now  reclaim storage  freed up  by a\n      previous use  of LINSURE.   (In a  non-Checkout environment it  has no\n      effect.)  LIRLSE has no parameters.\n-     The LIBEL  macro is  used to  define a label  which can  be used  as a\n      target of LIGOTO.   LIBEL has two forms,   a static form and a dynamic\n      form.   Both  of these  forms must  be used  to successfully  define a\n      label.  The syntax of LIBEL is as follows:\n0          &NAME    LIBEL &LABEL,&ADDR=\n0     If &ADDR= is not specified to LIBEL,   this is a \"static\" call,  which\n      defines the position of the label in the code.  &LABEL in this case is\n      the LIE name of the label;  the name field of the macro can be used to\n      define a standard assembler name.   Note  that the addresses of &LABEL\n      and &NAME will  usually not be the  same.   &NAME can be  branched to,\n      while &LABEL should be referenced only  in the dynamic LIBEL macro for\n      the same label.\n1\n0                                                                     PAGE 3\n0     When &ADDR= is  specified by LIBEL,  we have a  \"dynamic\" call,  which\n      sets up a PL/I  label variable in the DSA of  its caller.   This macro\n      should be positioned so that it will be executed before any attempt to\n      LIGOTO the label.  The &LABEL parameter is used to define the point to\n      which LIGOTO should transfer control;   it should be defined somewhere\n      in the  calling routine by a  static LIBEL).   The &ADDR  value should\n      specify the  location of the \"label  variable\".   The name field  of a\n      dynamic LIBEL has its normal meaning.\n-     The LIGOTO macro is used to transfer control to a PL/I label variable,\n      or to a label in a procedure which called the one issuing LIGOTO.  Its\n      syntax is:\n0          &NAME    LIGOTO &LABEL\n0     &LABEL must specify the address of a  PL/I label variable,  or the LIE\n      equivalent (which must  have been previously initialized  by a dynamic\n      LIBEL macro).\n-     The  LIBLOCK  macro  is  used to  allow  a  procedure  to  temporarily\n      intercept \"GOTO out-of-block\",   so it can perform  cleanup before the\n      GOTO completes.   The corresponding PL/I  facility was defined for the\n      use of PLISORT, so that a GOTO out of a sort exit could be trapped for\n      long enough to terminate the sort program.  Usage of LIBLOCK is rather\n      complex; the following steps must be performed:\n0     1.  The calling  procedure must have  an internal subroutine  to issue\n          LIBLOCK;  this subroutine  must use the LIBLOCK  macro rather than\n          LIENTRY.  The subroutine must be entered with a \"BAL R14\".\n0     2.  The calling procedure's DSA  must end with an area of  88 bytes or\n          larger,  to  be used as  a DSA  by the internal  subroutine.   The\n          internal subroutine should  save registers and load  R13 with this\n          secondary DSA address before issuing LIBLOCK.\n0     3.  Before calling the internal subroutine,  the mainline should clear\n          the secondary DSA, set the CGTO flag in its second byte,  and save\n          the contents of TFB1 (a flag byte of the TCA) somewhere handy.\n0     4.  Before returning, the mainline should restore TFB1.\n0     Now, when the internal subroutine, or one of its descendants, attempts\n      to do  a GOTO  which would terminate  the calling  procedure,  control\n      returns  to the  instruction after  the  \"BAL R14\"  which invoked  the\n      internal subroutine.    The CGTO flag in  the secondary DSA  will have\n      been turned  off,  which  allows the mainline  to determine  whether a\n      normal return  or a GOTO  has taken place.    The mainline can  now do\n      whatever cleanup is required; when it returns, the GOTO will magically\n      continue, due to some arcane manipulation of save areas.\n0     The syntax of LIBLOCK is:\n0          &LABEL   LIBLOCK &OLDSA=(1)\n0     &OLDSA  should be  specified  in the  form (reg),   where  \"reg\" is  a\n      register addressing the DSA for the mainline routine.\n1\n0                                                                     PAGE 4\n0     Here is  a sample code  fragment using LIBLOCK  to show how  it should\n      work:\n0     ************** MAINLINE CODE\n               XC    DSASAVE2,DSASAVE2    CLEAR SECONDARY DSA\n               OI    DSASAVE2+1,CGTO      SET GOTO INTERCEPT FLAG\n               MVC   DSATCASV,TFB1        SAVE TCA FLAG BYTE\n               BAL   R14,INTERNAL         CALL INTERNAL SUBRTN\n               TM    DSASAVE2+1,CGTO      ABNORMAL GOTO CAUGHT?\n               BNZ   NOGOTO               NO, NORMAL RETURN\n0     ************** EXIT CODE\n               MVC   TFB1,DSATCASV        RESTORE TCA FLAGS\n               LIEXIT ,                   AND RETURN\n0     ************** INTERNAL SUBROUTINE\n      INTERNAL STM   R14,R11,12(R13)      SAVE REGISTERS\n               LR    R2,R13               SAVE MAINLINE DSA ADDRESS\n               USING DSA,R2\n               LA    R13,DSASAVE2         SET UP NEW DSA REGISTER\n               LIBLOCK OLDSA=(R2)         FINISH INTERCEPTION OF GOTOS\n0     ************** EXIT FROM INTERNAL SUBROUTINE\n               LR    R13,R2\n               LM    R14,R11,12(R13)\n               BR    R14\n0     ************** DSA DEFINITION\n      DSA      DSECT\n               DS    22F                  STANDARD PL/I DSA\n      ************** OTHER DSA FIELDS\n      DSATCASV DS    XL1                  TCA BYTE SAVE AREA\n               DS    0D                   DOUBLEWORD ALIGN\n      DSASAVE2 DS    22F                  DSA FOR INTERNAL ROUTINE\n      DSALEN   EQU   *-DSA\n-     The LISIGNAL macro is used to signal a PL/I condition.  Its syntax is:\n0          &LABEL   LISIGNAL &WK,&COND=\n0     &WK addresses a fullword  in the DSA which can be used  as a work area\n      by the macro expansion.  &COND specifies the name of a PL/I condition.\n      Presently,  the conditions ATTN,  ERROR,  FINISH and STOP are handled.\n      (More could  be added  by updating  the LICOND  macro,  which  defines\n      them.)  LISIGNAL of the \"STOP\" condition is equivalent to execution of\n      a PL/I STOP statement.\n-     The LION macro establishes an ON-unit for a PL/I condition.   Only the\n      equivalents of \"ON  cond GOTO x\" and  \"ON cond CALL x\"  are supported.\n      The syntax of LION is:\n0          &LABEL   LION  &COND,&GOTO=,&CALL=\n0     The &COND parameter  names the condition to be handled.    Only one of\n      &GOTO and &CALL may  be specified;  if &GOTO is used,   it must name a\n      \"label variable\" suitable as a target for LIGOTO; if &CALL is used, it\n      must point to an LIENTRY-defined internal procedure.\n-     The LIREVERT macro performs the equivalent of a PL/I REVERT statement.\n      Its syntax is:\n0          &LABEL   LIREVERT &COND\n0     &COND is the PL/I condition name which  should no longer be handled by\n      this procedure.\n-     The LIONCB macro is used to generate PL/I  \"ON cells\" in the DSA for a\n      routine which uses  the LION macro.   It should  be placed immediately\n      after the definition of the PL/I part of the DSA (which,  when LION is\n      used, should consist of 29 fullwords).  LIONCB has no operands.\n1\n0                                                                     PAGE 5\n0     The LIERRSET  macro is  used in  a pseudo-PL/I  environment to  define\n      program-check  handling.    It  can  only be  used  in  a  pseudo-PL/I\n      environment;  in a  real PL/I environment it will  do horrible things.\n      The syntax of LIERRSET is:\n0          &LABEL   LIERRSET &EXIT\n0     After the execution of LIERRSET, if a program check occurs, it will be\n      intercepted by a  LIE SPIE routine,  which will print  out a procedure\n      traceback (using  WTP),  and  then branch to  the &EXIT  label.   When\n      control reaches the &EXIT point,  the registers will be the same as at\n      the  point of  interrupt,  so  the &EXIT  code  should set  up a  base\n      register and execute  LIGOTO or LISIGNAL to get to  a known procedure.\n      Note that if a program check occurs  and R12 has been altered from its\n      standard LIE contents (a pointer to  a pseudo-TCA),  the LIE SPIE will\n      program check and the program will ABEND.  Also note that the LIE SPIE\n      exit is cancelled  when the procedure which issued  the first LIERRSET\n      returns.\n-     When LIE  is used,  with a  few exceptions references to  PL/I control\n      blocks should not be necessary.  The pseudo-PL/I implementation of LIE\n      does maintain a little bit of the start of the TCA (addressed via R12)\n      compatibly with  PL/I.   Notably,  you  can test whether  the Checkout\n      compiler is active by \"TM TFB0,TTCK\"; similarly, you can check for the\n      pseudo-PL/I environment by \"TM TFB0,TTFC\".  (This flag is used by PL/I\n      to indicate the  CICS environment;  we have not used  LIE ourselves in\n      any context where  this could cause any confusion.)    Also,  the TPRV\n      word  can be  trusted  to contain  a  pointer  to the  pseudo-register\n      vector,  which,  in a pseudo-PL/I environment,  will be initialized to\n      zeroes).   Other fields in the TCA,   DSA etc.,  should not be trusted\n      unless you test TTFC to verify a true PL/I environment.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LIEXIT": {"ttr": 6153, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    LIEXIT &RC=\n.*       THIS MACRO GENERATES LANGUAGE-INDEPENDENT CODE TO RETURN FROM\n.*       A ROUTINE.\n         AIF   ('&RC' NE '').YRC\n&NAME    L     R14,=V(LIEXIT)     ADDR. OF EXIT ROUTINE\n         AGO   .JRC\n.YRC     AIF   ('&NAME' EQ '').NONAME\n&NAME    DS    0H\n.NONAME  IHBINNRB SF=(E,&RC)      GET RC IN R15\n         L     R14,=V(LIERETC)    ADDR. OF EXIT ROUTINE\n.JRC     BR    R14                RETURN (THE HARD WAY)\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LIFO": {"ttr": 6155, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    LIFO  &LV=\n.*       THIS MACRO GENERATES LANGUAGE INDEPENDENT CODE TO GET A\n.*       LIFO STORAGE AREA.\n&NAME    IHBINNRA (1),&LV         LENGTH IN R0\n         L     R15,=V(LIELIFO)    GET LIFO ROUTINE\n         BALR  R14,R15            GO GRAB SOME STORAGE\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LIFREE": {"ttr": 6157, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    LIFREE &A=,&LV=\n.*       THIS MACRO GENERATES LANGUAGE-INDEPENDENT CODE TO FREE A\n.*       NON-LIFO STORAGE AREA.\n&NAME    IHBINNRA &A,&LV          ADDR IN R1, LENGTH IN R0\n         L     R15,=V(LIEFREE)    NON-LIFO FREE ROUTINE\n         BALR  R14,R15            GIVE STORAGE BACK\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LIGET": {"ttr": 6159, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    LIGET &LV=\n.*       THIS MACRO GENERATES LANGUAGE-INDEPENDENT CODE TO GET A\n.*       NON-LIFO STORAGE AREA.\n&NAME    IHBINNRA (1),&LV         AREA LENGTH IN R0\n         L     R15,=V(LIEGET)     NON-LIFO GET ROUTINE\n         BALR  R14,R15            GO GET SOME STORAGE\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LIGOTO": {"ttr": 6161, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    LIGOTO &LAB\n.*       THIS MACRO GENERATES CODE TO GOTO A VARIABLE LOCATION IN A\n.*       LANGUAGE INDEPENDENT ENVIRONMENT.\n&NAME    LM    R0,R1,&LAB         LOAD TARGET & DSA ADDRESS\n         L     R14,=V(LIEGOTO)\n         BR    R14                CALL GOTO CODE\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LINSURE": {"ttr": 6163, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    LINSURE &LV=\n         LCLC  &LVK\n         LCLA  &KLV\n&KLV     SETA  K'&LV\n         AIF   ('&LV'(&KLV,1) EQ 'K').LVK SEE IF LENGTH IN K\n&NAME    IHBINNRA (1),&LV\n         AGO   .JOIN\n.LVK     ANOP\n&LVK     SETC  '&LV'(1,&KLV-1)\n&NAME    LA    0,&LVK             GET NUMBER K TO ENSURE\n         SLL   0,10               CONVERT TO BYTES\n.JOIN    L     15,=V(LIENSUR)\n         BALR  14,15              BUY INSURANCE\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LION": {"ttr": 6165, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   LION  &COND,&GOTO=,&CALL=\n.*       THIS MACRO ESTABLISHES A PSEUDO ON-UNIT FOR A PL/I\n.*       CONDITION. THE ON-UNIT MAY EITHER DO A GOTO OR CALL AN\n.*       INTERNAL ROUTINE.\n         GBLC  &LICOND            PL/I CONDITION CODE VALUE\n         GBLC  &LIONSCT           NAME OF ONCB CSECT\n         GBLC  &LIDSA             NAME OF CURRENT DSA\n         GBLA  &LION#             NAME OF ON UNITS SO FAR\n         LCLC  &CD\n         LICOND COND=&COND        LOOK UP CONDITION NAME\n&CD      SETC  '&LICOND'(1,2)\n&LABEL   MVI   LIONCELS+&LION#,X'&CD'  ESTABLISH ON UNIT\n         LIREVERT &COND,UPTO=&LION#,CODE=&CD     CANCEL OTHERS\n&LION#   SETA  &LION#+1           BUMP ON UNIT COUNTER\n&LIONSCT CSECT ,                  SWITCH TO ONCB CSECT\n         DC    X'&CD'             IDENTIFY CONDITION\n         AIF   ('&GOTO' EQ '').NOGOTO\n         DC    X'360000'          INDICATE GOTO UNIT\n         DC    A(&GOTO-&LIDSA)    DSA OFFSET OF DEST. LABEL\n         AGO   .JGOTO\n.NOGOTO  DC    X'160000'          INDICATE CALL UNIT\n         DC    A(&CALL)           ADDR OF INTERNAL ENTRY\n.JGOTO   ANOP\n&SYSECT  CSECT ,                  RESTORE ORIGINAL CSECT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LIONCB": {"ttr": 6167, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         LIONCB\n.*       THIS MACRO IS USED TO DEFINE THE ON CELLS IN THE DSA\n.*       FOR LANGUAGE-INDEPENDENT CONDITION HANDLING.\n         GBLA  &LION#             NUMBER OF LION UNITS\nLIONCELS DS    (&LION#+1)XL1      ON CELLS\nLIONCELN EQU   &LION#             NUMBER OF CELLS (EXCEPT THE END)\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LIREVERT": {"ttr": 6169, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   LIREVERT &COND,&UPTO=LIONCELN,&CODE=\n.*       THIS MACRO GENERATES CODE TO PERFORM A \"REVERT\" IN A PL/I\n.*       OR PSEUDO-PL/I ENVIRONMENT. IT IS ALSO USED AS AN INNER\n.*       MACRO BY LION TO CANCEL PREVIOUS ON-UNITS FOR A CONDITION.\n         GBLC  &LICOND            PL/I CONDITION CODE\n         LCLC  &CD\n         LCLC  &S\n&CD      SETC  '&CODE'            SEE IF CODE PASSED BY LION\n         AIF   ('&CD' NE '').CODE\n         LICOND COND=&COND        IF NOT, LOOK UP CONDITION\n&CD      SETC  '&LICOND'(1,2)\n.CODE    AIF   ('&LICOND'(3,2) EQ '00').OKCOND\n         MNOTE 8,'***** INVALID CONDITION FOR LION/LIREVERT -- &COND ***\n               ***'               ERROR IF NOT PURE CONDITION\n.OKCOND  AIF   ('&UPTO' EQ '0').MEND   DON'T REVERT FOR 1ST ON\n&LABEL   LA    R1,LIONCELS-1\n         LA    R0,1\n         LNR   R0,R0\n         LA    R15,LIONCELS+&UPTO-1\n&S       SETC  '&SYSNDX'\nLIRV&S   CLI   0(R15),X'&CD'      THIS CELL FOR THIS CONDITION?\n         BNE   LIRL&S             NO.\n         MVI   0(R15),0           YES, CANCEL IT\nLIRL&S   BXH   R15,R0,LIRV&SYSNDX\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LIRLSE": {"ttr": 6171, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    LIRLSE\n&NAME    L     15,=V(LIERLSE)\n         BALR  14,15              ALLOW MEMORY RECLAMATION\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LISECT": {"ttr": 6401, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    LISECT &ON=NO\n.*       THIS MACRO ESTABLISHES THE CSECT NAME FOR THE OTHER\n.*       LANGUAGE INDEPENDENT MACROS.\n         GBLC  &LISECT\n         GBLC  &LIONSCT           NAME FOR ONCB CSECT\n         GBLA  &LION#             NUMBER OF ON-UNITS PRESENT\n         LCLC  &FINAL\n         LCLA  &I\n&NAME    CSECT ,                  LANGUAGE INDEPENDENT CSECT\n         AIF   ('&LISECT' NE '').NOREGS\n         SPACE\n.RLOOP   ANOP\nR&I      EQU   &I\n&I       SETA  &I+1\n         AIF   (&I LE 15).RLOOP\nRTCA     EQU   R12                PL/I TCA POINTER\nRDSA     EQU   R13                SAVE AREA POINTER\n.NOREGS  SPACE\n&LISECT  SETC  '&NAME'\n         AIF   ('&ON' EQ 'NO').NOON\n         AIF   (K'&NAME EQ 8).CNTRACT\n&LIONSCT SETC  '&NAME.######'(1,7)     GENERATE ON SECT NAME\n         AGO   .APPEND2\n.CNTRACT ANOP\n&LIONSCT SETC  '&NAME'(1,6)\n&FINAL   SETC  '&NAME'(8,8)\n&LIONSCT SETC  '&LIONSCT&FINAL'\n.APPEND2 ANOP\n&LIONSCT SETC  '&LIONSCT.2'\n&LION#   SETA  0                  REINIT ON UNIT COUNTER\n.NOON    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LISIGNAL": {"ttr": 6403, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    LISIGNAL &WK,&COND=\n.*       THIS MACRO GENERATES (POSSIBLY INEFFECTIVE) LANGUAGE-\n.*       INDEPENDENT CODE TO \"SIGNAL\" A \"CONDITION\".\n         GBLC  &LICOND            PL/I CONDITION CODE\n&NAME    IHBINNRA &WK             WK AREA ADDR IN R1\n         LICOND COND=&COND        TRANSLATE CONDITION NAME\n         MVC   0(4,R1),=X'&LICOND.0000'     SORE CONDITION ID\n         L     R15,=V(LIESIGN)    SIGNAL ROUTINE ADDRESS\n         BALR  R14,R15            GO DO A SIGNAL\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTM": {"ttr": 6405, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    MOVEP &FR,&TO\n&NAME    LA    R1,FILEP&FR\n         LA    R15,&TO\n         BAL   R14,MOVEP\n         MEND\n         MACRO\n&NAME    ERROR &TEXT,&EXIT,&RC=12\n&NAME    UPUT  ERR&SYSNDX,*,CPPL=CPPL                          *AB79238\n         OI    RETC+1,&RC         SET BAD RETURN CODE          *AB79238\n         B     &EXIT\nERR&SYSNDX DC C&TEXT\n         MEND\nLSTM     TITLE 'LISTM -- LIST MEMBERS COMMAND'\n         PRINT NOGEN\nLISTM    SAVEX LV=1024\n         PRINT GEN\n         SPACE 3\n*        REGISTER USAGE\n*        R0    WORK REGISTER\n*        R1    WORK REGISTER\n*        R2    WORK REGISTER\n*        R3-R4 UNUSED\n*BUF     R5    -> NEXT PLACE IN TPUT BUFFER       (PRINT)\n*LINK    R6    RETURN REG FROM CPUT\n*MEM     R7    -> ELEMENT IN MEMBER LIST\n*ALI     R8    -> ELEMENT IN ALIAS LIST\n*        R9    -> FIRST CHAR OF NEXT DIR ENTRY    (BUILD)\n*LALI    R9    -> LAST ALIAS NAME                 (PRINT)\n*        R10   =12 (MIN DIR ENTRY LEN)            (BUILD)\n*        R11   -> LAST CHAR IN DIRECTORY BLOCK    (BUILD)\n*PDSNPDE R11   -> DATA SET PARSE DESCRIPTOR       (PARSE)\n*        R12   BASE REG FOR CODE\n*        R13   -> OS SAVE AREA\n*        R14   RETURN ADDRESS\n*        R15   LINKAGE REGISTER/RETURN CODE\n         SPACE 3\nON       EQU   X'FF'\nOFF      EQU   X'00'\n         SPACE 3\nBUF      EQU   R5\nLINK     EQU   R6\nMEM      EQU   R7\nALI      EQU   R8\nLALI     EQU   R9\nPDSNPDE  EQU   R11\n         EJECT\n         USING WORKAREA,R13        DECLARE BASE FOR WORK AREA\n         LM    R1,R4,0(R1)         LOAD PARAMETERS\n         STM   R1,R4,CPPL          STORE IN LOCAL COPIES\n         ST    R1,PPLCBUF          STORE CBUF POINTER IN PPL\n         ST    R2,PPLUPT           STORE UPT POINTER IN PPL...\n         ST    R2,DAPLUPT          ...AND DAPS\n         ST   R2,DFPLUPT          ...AND DFPL                  *AB79238\n         ST    R3,DAPLPSCB         STORE PSCB POINTER IN DAPL\n         ST   R3,DFPBPSCB         ...AND DFPB                  *AB79238\n         ST    R4,PPLECT           STORE ECT POINTER IN PPL...\n         ST    R4,DAPLECT          ...AND DAPL\n         ST   R4,DFPLECT          ...AND DFPL                  *AB79238\n         XC    ECB,ECB             CLEAR EVENT CONTROL BLOCK\n         LA    R1,ECB              POINT TO ECB\n         ST    R1,PPLECB           STORE POINTER TO ECB IN PPL...\n         ST    R1,DAPLECB          ...AND DAPL\n         ST   R1,DFPLECB          ...AND DFPL                  *AB79238\n         XC    RETC,RETC          SET UP ORIGINAL 0 RETCODE    *AB79238\n         L     R1,=A(PCL)          POINT TO PARSE CONTROL BLOCK\n         ST    R1,PPLPCL           STORE PCL POINTER IN PPL\n         LA    R1,ANS              POINT TO PDL LOCATION HOLDER\n         ST    R1,PPLANS           STORE POINTER IN PPL\n         LA    R1,PPL              POINT TO PARSE PARM LIST\n         LINK  EP=IKJPARS          CALL UP PARSE SERVICE ROUTINE\n         LTR   R15,R15             DID IT GO OK?\n         BNZ   PARSFAIL            NO, ERROR\n         MVI   OPTIONS,0           CLEAR OPTIONS BYTE\n         L     R1,ANS              GET PDL ASDRESS\n         USING PDL,R1              DECLARE BASE FOR PDL\n         CLI   TYPE+1,2            WAS \"ALPHA\" REQUESTED?\n         BNE   *+8                 NO, SKIP:\n         OI    OPTIONS,OPTALPHA    --FLAG \"ALPHA ORDER\"\n         CLI   COLUMN+1,2          WAS \"COLUMN\" REQUESTED?\n         BNE   *+8                 NO, SKIP:\n         OI    OPTIONS,OPTCOLUM    --FLAG \"COLUMNAR FORMAT\"\n         LA    PDSNPDE,FILES       POINT TO DSN ELEMENT\n         DROP  R1                  DROP PDL ADDRESSABILITY\n         USING FILE,PDSNPDE        DECLARE FILE BASE\nALLOCATE DS    0H\n         ST    PDSNPDE,PDSNSAVE    STORE POINTER FOR LOOP\n         MVI   DSNBUF-1,C' '       CLEAR DSNAME BUFFER...\n         MVC   DSNBUF,DSNBUF-1     ...BY CLASSIC METHOD\n         XC    DAPB08(DAPB08L),DAPB08 CLEAR DAIR PARM BLOCK\n         MVI   DA08CD+1,X'08'      MOVE IN TYPE CODE\n         LA    R1,DSNLEN           POINT TO DSNAME BUFFER...\n         ST    R1,DA08PDSN         ...FROM DAPB08\n         MVC   DA08DDN(24),DSNBUF  CLEAR DDNAME, UNIT, SERIAL\n         MVC   DA08MNM(16),DA08DDN CLEAR MEMBER, PASSWORD\n         MVC   DA08DSP,=X'080808'  INSERT \"(SHR,KEEP,KEEP)\"\n         MOVEP DSN,DSNBUF          MOVE IN DATA SET NAME\n         MVC   DSNLEN,FILELDSN     INSERT DSNAME LENGTH\n         TM    FILEFDSN,X'40'      ARE THERE QUOTES?\n         BO    QUOTSEND            YES, JUST SEND BODY\n         LA   R1,DFPB             POINT DFPL TO DFPB           *AB79238\n         ST   R1,DFPLDFPB                                      *AB79238\n         MVI  DFPBDSN,X'04'       REQUEST QUALIFIER            *AB79238\n         LA   R1,DSNLEN           SET UP DSN POINTER           *AB79238\n         STCM R1,7,DFPBDSN+1      FOR IKJEHDEF                 *AB79238\n         MVI  DFPBPSCB,X'21'      SET CONTROL CODES            *AB79238\n         LA   R1,DFPL                                          *AB79238\n         LINK EP=IKJEHDEF         CALL DEFAULT SERVICE RTN     *AB79238\n         LTR  R15,R15                                          *AB79238\n         BNZ  DEFFAIL             STOP IF DEFAULT ERROR        *AB79238\n         LH    R15,DSNLEN          LOAD LENGTH OF BODY\n         BCTR  R15,0               MAKE IT MVC FORM\n         EX    R15,MVCDSN          MOVE IN BODY OF DSNAME\n         LA    R1,TPUTBUF          LOAD START ADDRESS\n         LA    R0,1(,R15)         COMPUTE LENGTH               *AB79238\n         UPUT  (1),(0),DATA,CPPL=CPPL  SEND OUT LINE           *AB79238\n         B     PASTSEND            SKIP OVER QUOTE CODE\nMVCDSN   MVC   TPUTBUF(0),DSNBUF   MOVE IN BODY OF DSNAME      *AB79238\nQUOTSEND DS    0H\n         LA    R1,DSNBUF           POINT TO BUFFER\n         UPUT  (1),44,DATA,CPPL=CPPL   SEND IT TO USER         *AB79238\nPASTSEND DS    0H\n         MOVEP PWD,DA08PSWD        MOVE IN PASSWORD\n         TM    FILEFMEM,X'80'      WAS A MEMBER GIVEN?\n         BNZ   MEMERR              YES, ERROR\nMEMIGN   DS    0H\n         LA    R1,DAPB08           POINT TO TYPE 08 DASB\n         ST    R1,DAPLDAPB         ...IN DAPB\n         LA    R1,DAPL             POINT TO DAPL\n         LINK  EP=IKJEFD00         LINK TO DAIR\n         LTR   R15,R15             DID IT GO OK?\n         BNZ   DAIRFAIL            NO, ERROR\nFAILOK   DS    0H\n         TM    DA08DSO,X'02'       IS IT DSORG=PO?\n         BZ    NOTPO               NO, ERROR\n         MVC   BSAM,BSAMEX         MOVE IN BLANK DCB\n         MVC   BSAM+40(8),DA08DDN  INSERT DDNAME\n         DROP  PDSNPDE             DROP FILE ADDRESSABILITY\n         LA    R1,BSAM             CONSTRUCT...\n         ST    R1,ABSAM            ...LIST-FORM...\n         MVI   ABSAM,X'80'         ...OPEN/CLOSE\n         LA    R1,ABSAM            POINT TO IT\n         OPEN  MF=(E,(1))          USE IT TO OPEN BSAM DCB\n         TM    BSAM+48,X'10'       DID IT OPEN OK?\n         BZ    OPENFAIL            NO, ERROR\n         LA    MEM,MHEAD           POINT TO MEMBER LIST HEAD\n         LA    ALI,AHEAD           POINT TO ALIAS LIST HEAD\n         XC    MHEAD(8),MHEAD      CLEAR CHAIN HEADERS\n         LA    R1,TPUTBUF          INITIALIZE\n         ST    R1,TPBSTART           BUFFER START\n         LA    R1,L'TPUTBUF-1(R1)      AND\n         ST    R1,TPBEND                 STOP POINTERS\n*                                  GET LINE SIZE FOR...        *MW74183\n         GTSIZE\n         LTR   R0,R0              IS THIS A SCREEN?            *AB79238\n         BZ    GOTSIZE            NO.                          *AB79238\n         BCTR  R1,0               YES, CORRECT BY 1            *AB79238\nGOTSIZE  LA    R1,TPUTBUF(R1)      ...INITIALIZE BUFFER...     *MW74177\n         ST    R1,TPBSTOP          ...STOP POINTER\n         MVI   PASSSW,OFF          CLEAR PASS SWITCH\n         MVC   BSAMDECB,DECBEX     MOVE IN LIST-FORM DECB\n         LA    R1,BSAM             POINT TO DCB...\n         ST    R1,DECBDCB          ...IN DECB\n         LA    R1,DIRBLOCK        POINT TO INPUT AREA...\n         ST    R1,DECBAREA         ...IN DECB\n         MVI   TPUTBUF,C' '        CLEAR TPUT BUFFER BY...\n         MVC   TPUTBUF+1(L'TPUTBUF-1),TPUTBUF ...CLASSIC METHOD\n         EJECT\nREADBSAM DS    0H\n         READ  BSAMDECB,SF,MF=E    READ A DIRECTORY BLOCK\nCHCKBSAM CHECK BSAMDECB            WAIT FOR GOOD END\n         LA    R10,12              SET\n         LA    R11,DIRBLOCK-1       UP\n         LA    R9,DIRBLOCK+2         FOR\n         AH    R11,DIRBLOCK           BXLE\n         USING MEMBERDS,R9         DECLARE BASE REG\nNEXTMEM  DS    0H\n         CLI   MEMBNAME,X'FF'      TEST FOR END O. DIRECTORY\n         BE    LASTMEM             IF THERE, END LOOP\n         GETMAIN R,LV=16           GET SPACE FOR LIST ELEMENT\n         MVC   4(12,R1),MEMBNAME   MOVE IN NAME, TTR\n         TM    OPTIONS,OPTALPHA    WAS \"ALPHA\" REQUESTED?\n         BO    ALPHAADD            YES, ADD TO MEMBER LIST\n         TM    MEMBFLGS,X'80'      IS THIS AN ALIAS?\n         BO    ISALIAS             YES, GO ADD TO ALIAS LIST\nALPHAADD DS    0H\n         ST    R1,0(MEM)           CHAIN ONTO END OF MEMBER LIST\n         LR    MEM,R1              USE AS NEW END\n         B     ADDED               CONTINUE WITH NEXT MEMBER\nISALIAS  DS    0H\n         ST    R1,0(ALI)           CHAIN ONTO END OF ALIAS LIST\n         LR    ALI,R1              USE AS NEW END\nADDED    DS    0H\n         NI    MEMBFLGS,X'1F'      CLEAR ALIAS, TTRN COUNT\n         SLR   R1,R1               CLEAR FOR...\n         IC    R1,MEMBFLGS         ...LOAD NO. OF USER 1/2-WDS\n         SLL   R1,1                DOUBLE TO GET LENGTH\n         AR    R9,R1               ADD TO POINTER\n         BXLE  R9,R10,NEXTMEM      LOOP IF MORE IN BLOCK\n         B     READBSAM            OTHERWISE, READ NEXT BLOCK\nLASTMEM  DS    0H\n         LA    BUF,TPUTBUF         POINT TO START OF BUFFER\n         SLR   R0,R0               CLEAR FOR:\n         ST    R0,0(MEM)           --GROUND END OF MEMBER...\n         ST    R0,0(ALI)           --...AND ALIAS LISTS\n         L     MEM,MHEAD           POINT TO FIRST MEMBER ELEMENT\n         LTR   MEM,MEM             WERE THERE ANY MEMBERS?     *MW74183\n         BNZ   MLOOP               YES, SKIP:                  *MW74183\n         MVC   TPUTBUF(L'NOMEM),NOMEM --INSERT TEXT            *MW74183\n         LA    BUF,L'NOMEM(,BUF)   --POINT PAST IT             *MW74183\n         B     ATEST               --GO TEST FOR ALIASES       *MW74183\nMLOOP    DS    0H\n         CLI   PASSSW,ON           IS THIS PASS TWO?\n         BNE   PASS1               NO, SKIP:\n         MVI   1(BUF),C'?'         --FLAG \"PRIMARY UNKNOWN\"\n         MVC   2(8,BUF),4(MEM)     --INSERT FIRST ALIAS NAME\n         BAL   LINK,CPUT           --PUT IF OVERFLOW\n         LR    ALI,MEM             --START SEARCH HERE\n         B     ALOOP               --GO SEARCH FOR OTHER ALIASES\nPASS1    DS    0H\n         TM    15(MEM),X'80'       IS THIS AN ALIAS? (\"ALPHA\")\n         BZ    NOTALIAS            NO, SKIP:\n         MVI   1(BUF),C'*'         --FLAG WITH STAR\n         MVC   2(8,BUF),4(MEM)     --INSERT MEMBER NAME\n         BAL   LINK,CPUT           --PUT IF OVERFLOW\n         B     ENDALI              --FORGET ALIAS SEARCH\nNOTALIAS DS    0H\n         MVC   1(8,BUF),4(MEM)     INSERT MEMBER NAME\n         BAL   LINK,CPUT           PUT IF OVERFLOW\n         LA    ALI,AHEAD           POINT TO ALIAS LIST HEAD\nALOOP    DS    0H\n         LR    LALI,ALI            SAVE LAST ADDRESS\n         L     ALI,0(ALI)          GET NEXT ADDRESS\nALOOPT   DS    0H\n         LTR   ALI,ALI             IS THERE ONE?\n         BZ    ENDALI              NO, EXIT\n         CLC   12(3,MEM),12(ALI)   SAME TTR?\n         BNE   ALOOP               NO, LOOP FOR ANOTHER\n         MVI   1(BUF),C'='         FLAG AS ALIAS\n         MVC   2(8,BUF),4(ALI)     INSERT ALIAS NAME\n         BAL   LINK,CPUT           PUT IF OVERFLOW\n         LR    R1,ALI              SAVE ALIAS ENTRY ADDRESS\n         L     ALI,0(ALI)          FIND NEXT ENTRY\n         ST    ALI,0(LALI)         CHAIN TO LAST ENTRY\n         FREEMAIN R,LV=16,A=(1)    FREE USED ENTRY\n         B     ALOOPT              GO TEST NEXT\nENDALI   DS    0H\n         LR    R1,MEM              SAVE ENTRY ADDRESS\n         L     MEM,0(MEM)          FIND NEXT ENTRY\n         FREEMAIN R,LV=16,A=(1)    FREE USED ENTRY\n         LTR   MEM,MEM             IS THERE ONE?\n         BNZ   MLOOP               YES, LOOP\nATEST    DS    0H                                              *MW74183\n         L     MEM,AHEAD           GET FIRST ALIAS ADDRESS\n         LTR   MEM,MEM             ARE THERE ANY EXTRA?\n         BZ    ENDMEM              NO, SKIP:\n         MVI   PASSSW,ON           --SET TO PASS TWO\n         XC    AHEAD,AHEAD         --CLEAR OUT ALIAS HEADER\n         B     MLOOP               --GO LIST EXTRAS\nENDMEM   DS    0H\n         LA    R1,TPUTBUF          POINT TO BUFFER\n         UPUT  (1),L'TPUTBUF,DATA,CPPL=CPPL OUTPUT REST OF LINE*AB79238\nCLOSE    DS    0H\n         LA    R1,ABSAM            POINT TO LIST-FORM OPEN/CLOSE\n         CLOSE MF=(E,(1))          USE IT TO CLOSE BSAM DCB\nDEALLOC  DS    0H\n         L     PDSNPDE,PDSNSAVE    RE-LOAD POINTER\n         USING FILE,PDSNPDE        DECLARE BASE\n         XC    DAPB18(DAPB18L),DAPB18 CLEAR TYPE 18 DAPB\n         MVI   DA18CD+1,X'18'      INSERT TYPE CODE\n         MVC   DA18DDN(18),DA08DDN INSERT DDNAME, CLEAR -MNM, -SCLS\n         MVI   DA18DSP,X'08'       FLAG \"KEEP\"\n         MVC   DA18JBNM,DA08MNM    CLEAR SYSOUT JOBCLASS\n         LA    R1,DAPB18           POINT TO TYPE 18 DAPB...\n         ST    R1,DAPLDAPB         ...IN DAPL\n         LA    R1,DAPL             POINT TO DAPL\n         LINK  EP=IKJEFD00         LINK TO DAIR\n         LTR   R15,R15             DID IT GO OK?\n         BNZ   FREEFAIL            NO, ERROR\nNEXTFILE DS    0H\n         L     PDSNPDE,FILEPFIL    CHAIN TO NEXT FILE PDE\n         LTR   PDSNPDE,PDSNPDE     IS THERE ONE?\n         BP    ALLOCATE            YES, LOOP TO DO IT\n         DROP  PDSNPDE             FORGET BASE\nRLSA     IKJRLSA ANS               RELEASE SPACE FOR PDE\n         LH    R2,RETC            LOAD RETURN CODE TO BE       *AB79238\n         CH    R2,=H'12'          IS IT NOT TOO BAD?           *AB79238\n         BL    GOHOME             NO.                          *AB79238\n         STACK PARM=FLUSH,MF=(E,PPL)   YES, FLUSH STACK        *AB79238\n         TCLEARQ INPUT            AND CLEAR TERM QUEUE         *AB79238\nGOHOME   LR    R15,R2             RETURN CODE TO R15           *AB79238\n         RETURNX RC=(15)          RETURN TO CALLER             *AB79238\nCPUT     DS    0H\n         TM    OPTIONS,OPTCOLUM    WAS \"COLUMN\" REQUESTED?\n         BZ    *+12                NO, SKIP:\n         LA    R2,10(BUF)          --SPACE OVER 10 COLUMNS\n         B     CPUTPET             --GO TEST FOR PAST END\n         LR    R2,BUF              POINT TO FIRST ADDED CHAR\nCPUTL    LA    R2,1(R2)            STEP TO NEXT CHAR\n         CLI   0(R2),C' '          IS IT BLANK?\n         BNE   CPUTL               NO, LOOP FOR BLANK\nCPUTPET  DS    0H\n         C     R2,TPBSTOP          PAST END?\n         BH    *+8                 YES, SKIP:\n         LR    BUF,R2              --POINT TO NEW END\n         BR    LINK                --RETURN\n         LR    R0,BUF              DECREMENT END ADDRESS BY...\n         S     R0,TPBSTART         ...START TO GET LENGTH\n         LA    R1,TPUTBUF                                      *AB79238\n         UPUT  (1),(0),DATA,CPPL=CPPL   SEND 1ST PART          *AB79238\n         SR    R2,BUF              COMPUTE ADDED LENGTH\n         MVC   TPUTBUF,0(BUF)      MOVE ADDED DATA TO START\n         LA    BUF,TPUTBUF(R2)     POINT PAST IT\n         L     R0,TPBEND           GET LENGTH OF...\n         SR    R0,BUF              ...REST OF LINE\n         MVI   0(BUF),C' '         CLEAR...\n         STC   R0,*+5              ...THAT MANY...\n         MVC   1(0,BUF),0(BUF)     ..CHARACTERS\n         BR    LINK                RETURN\nPARSFAIL MVI   RETC+1,12          SET BAD RETURN CODE          *AB79238\n         CH    R15,=H'12'         SEE IF MSG NEEDED            *AB79238\n         BL    RLSA               NO, JUST DIE                 *AB79238\n         ERROR ' PARSE FAILURE',RLSA\nDAIRFAIL DS    0H\n         MVI   WHATFAIL,OFF       FALG \"ALLOCATE FAILED\"\n         OI    RETC+1,12          SET ERROR FLAG               *AB79238\nHNDLFAIL DS    0H\n         DAIRFAIL DAPL=DAPL,MF=(E,FAILPL)   INVOKE DAIRFAIL    *AB79238\n         CLI   WHATFAIL,ON         WAS IT A FREE FAILURE?\n         BE    NEXTFILE            YES, GO TRY NEXT FILE\n         TM    DA08FLG,X'80'       WAS IT ALLOCATED ANYWAY?\n         BO    FAILOK              YES, GO TRY TO OPEN\n         B     NEXTFILE            NO, TRY NEXT FILE\nDEFFAIL  MVI   RETC+1,12                                       *AB79238\n         CH    R15,=H'8'          WHAT RETURN CODE?            *AB79238\n         BL    NEXTFILE           PROBABLY COULDN'T PROMPT     *AB79238\n         BE    TOOLONG            NAME WAS TOO LONG            *AB79238\n         CH    R15,=H'16'         CHECK FOR DAIR-TYPE ERROR    *AB79238\n         BE    DAIRMSG            IF SO, CALL DAIR ANYWAY      *AB79238\n         CH    R15,=H'20'                                      *AB79238\n         BE    DAIRMSG                                         *AB79238\n         CVD   R15,DECWORK        GET RETURN CODE INTO MSG     *AB79238\n         UNPK  DEFCODE(2),DECWORK                              *AB79238\n         OI    DEFCODE+1,X'F0'                                 *AB79238\n         UPUT  DEFMSG1,*,HELP=(DEFMSG2),CPPL=CPPL SEND MSG     *AB79238\n         MVI   RETC+1,12          SET ERROR CODE               *AB79238\n         B     NEXTFILE           TRY NEXT DSN                 *AB79238\nDAIRMSG  OI    DA08CTL,X'20'      ASK DAIR TO ADD PREFIX       *AB79238\n         B     PASTSEND           CALL DAIR TO GET GOOD MSG    *AB79238\nTOOLONG  ERROR ' DSNAME TOO LONG',NEXTFILE                     *AB79238\nOPENFAIL ERROR ' OPEN FAILURE',CLOSE\nMEMERR   ERROR ' MEMBER NAME IGNORED',MEMIGN,RC=4\nFREEFAIL DS    0H\n         MVI   WHATFAIL,ON         FLAG \"FREE FAILED\"\n         OI    RETC+1,4           INDICATE MINOR ERROR         *AB79238\n         B     HNDLFAIL            JOIN COMMON CODE\nNOTPO    ERROR ' NOT PARTITIONED',DEALLOC\nMOVEP    DS    0H\n         TM    6(R1),X'80'         IS IT PRESENT\n         BCR   8,R14               NO, RETURN\n         LH    R2,4(,R1)           PICK UP LENGTH\n         BCTR  R2,0                MAKE IT MVC FORM\n         L     R1,0(,R1)           PICK UP ADDRESS\n         EX    R2,MOVEPMVC         MOVE IT IN\n         BR    R14                 RETURN\nMOVEPMVC MVC   0(0,R15),0(R1)\n         EJECT\nFLUSH    STACK DELETE=ALL,MF=L    TO FLUSH STACK               *AB79238\nNOMEM    DC    C' (DATA SET HAS NO MAIN MEMBERS) '             *MW74183\nDEFMSG1  DC    C' DEFAULT ERROR+'                              *AB79238\nDEFMSG2  DC    C' RETURN CODE XX'                              *AB79238\nDEFCODE  EQU   *-2                POINTER TO RET CODE          *AB79238\n         PRINT NOGEN\nBSAMEX   DCB   DSORG=PS,MACRF=R,KEYLEN=0,EODAD=LASTMEM,                *\n               LRECL=256,RECFM=F,BLKSIZE=256\nBSAMEXL  EQU   *-BSAMEX\n         READ  DECBEX,SF,,,256,MF=L\nDECBEXL  EQU   *-DECBEX\n         LTORG\nPCL      IKJPARM DSECT=PDL\nFILES    IKJPOSIT DSNAME,LIST,PROMPT='DATA SET NAME(S)'                *\n               HELP=('NAME(S) OF DATA SET(S) FOR WHICH MEMBER LIST IS D*\n               ESIRED')\nTYPE     IKJKEYWD DEFAULT='MATCH'\n         IKJNAME 'MATCH'\n         IKJNAME 'ALPHA'\nCOLUMN   IKJKEYWD DEFAULT='FREE'\n         IKJNAME 'FREE'\n         IKJNAME 'COLUMN'\n         IKJENDP\n         SPACE 2\nMEMBERDS DSECT MAPS ONE ENTRY IN PDS DIRECTORY\nMEMBNAME DS    CL8                 NAME OF MEMBER\nMEMBTTR  DS    XL3                 LOCATION OF MEMBER\nMEMBFLGS DS    BL1                 ALIAS,#(TTRN'S),#(1/2-WDS)\nMEMBDATA DS    CL62 (MAX)          USER DATA (INCL. TTRN-S)\n         SPACE 2\nFILE     DSECT MAPS ONE DATA SET PARSE DESCRIPTOR\nFILEPDSN DS    A                   -> DATA SET NAME\nFILELDSN DS    H                   LENGTH OF NAME\nFILEFDSN DS    2X                  FLAGS\nFILEPMEM DS    A                   -> MEMBER NAME\nFILELMEM DS    H                   LENGTH OF NAME\nFILEFMEM DS    2X                  FLAGS\nFILEPPWD DS    A                   -> PASSWORD\nFILELPWD DS    H                   LENGTH\nFILEFPWD DS    2X                  FLAGS\nFILEPFIL DS    A                   -> NEXT DATA SET DESCRIPTOR\n         SPACE 2\nWORKAREA DSECT\n         DS    18F                 O/S SAVE AREA\nABSAM    DS    A                   OPEN/CLOSE PARM LIST\nBSAM     DS    CL(BSAMEXL)         PLACE FOR BSAM DCB\nDIRBLOCK DS    CL256               DIRECTORY BLOCK BUFFER\nBSAMDECB DS    CL(DECBEXL)         SPACE FOR DECB\nDECBDCB  EQU   BSAMDECB+8          -> DATA CONTROL BLOCK\nDECBAREA EQU   BSAMDECB+12         -> INPUT AREA (DIRBLOCK)\nMHEAD    DS    A                   HEAD OF MEMBER LIST\nAHEAD    DS    A                   HEAD OF ALIAS LIST\nTPBSTART DS    A                   -> START OF TPUT BUFFER\nTPBSTOP  DS    A                   -> LAST USABLE CHAR OF TPUT BUFFER\nTPBEND   DS    A                   -> END OF TPUT BUFFER\nTPUTBUF  DS    CL152               TPUT BUFFER\nPASSSW   DS    X                   PASS SWITCH 00=1,FF=S\nOPTIONS  DS    X                   OPTION BYTE\n*        VALUE FOR \"OPTIONS\" BYTE\nOPTALPHA EQU   X'80'               ALPHA ORDER, NO ALIAS MATCHING\nOPTCOLUM EQU   X'40'               LIST IN COLUMNAR FORMAT\n*        END OF VALUES FOR \"OPTIONS\"\nDSNLEN   DS    H                   LENGTH OF DATA IN:\nDSNBUF   DS    CL44                  DATA SET NAME BUFFER FOR DAIR\nECB      DS    F                   EVENT CONTROL BLOCK FOR ATTN\nANS      DS    A                   -> PDL FROM PARSE\nPDSNSAVE DS    A                   SAVE AREA FOR PDL POINTER\n         SPACE 2\nCPPL     DS    0CL16               COMMAND PROCESSOR PARAMETER LIST\nCPPLCBUF DS    A                   -> COMMAND BUFFER\nCPPLUPT  DS    A                   -> USER PROFILE TABLE\nCPPLPSCB DS    A                   -> PROTECTED STEP CONTROL BLOCK\nCPPLECT  DS    A                   -> ENVIRONMENT CONTROL TABLE\n         SPACE 2\nPPL      DS    0CL28               PARSE PARAMETER LIST\nPPLUPT   DS    A                   -> USER PROFILE TABLE\nPPLECT   DS    A                   -> ENVIRONMENT CONTROL TABLE\nPPLECB   DS    A                   -> ATTN EVENT CONTROL BLOCK\nPPLPCL   DS    A                   -> PARSE CONTROL LIST\nPPLANS   DS    A                   -> LOC -> PARSE DESCRIPTOR LIST\nPPLCBUF  DS    A                   -> COMMAND BUFFER\nPPLUWA   DS    A                   -> USER WORK AREA\n         SPACE 2\nDAPL     DS    0CL20               DYNAMIC ALLOCATION PARAMETER LIST\nDAPLUPT  DS    A                   -> USER PROFILE TABLE\nDAPLECT  DS    A                   -> ENVIRONMENT CONTROL TABLE\nDAPLECB  DS    A                   -> ATSN EVENT CONTROL BLOCK\nDAPLPSCB DS    A                   -> PROTECTED STEP CONTROL BLOCK\nDAPLDAPB DS    A                   -> DYNAMIC ALLOCATION PARAMETER BLCK\n         SPACE 2\nDAPB08   DS    0C                  DYN. ALLOC. PARAM. BLOCK TYPE 08\n*                                  (ALLOCATE BY DSNAME)\nDA08CD   DS    XL2                 IN: TYPE CODE (X'0008')\nDA08FLG  DS    XL2                 OUT: FLAGS\nDA08DARC DS    XL2                 OUT: DYN. ALLOC. RETURN CODE\nDA08CTRC DS    XL2                 OUT: CATALOG RETURN CODE\nDA08PDSN DS    A                   IN: -> DSNAME BUFFER\nDA08DDN  DS    CL8                 IN: SPACES; OUT:DDNAME\nDA08UNIT DS    CL8                 IN: SPACES\nDA08SER  DS    CL8                 IN: SPACES\nDA08XXXX DS    CL16                IN: ZEROS (SPACE PARMS)\nDA08MNM  DS    CL8                 IN: SPACES (MEMBER NAME)\nDA08PSWD DS    CL8                 IN: SPACES OR PASSWORD\nDA08DSP  DS    XL3                 IN: X'080808' => (SHR,KEEP,KEEP)\nDA08CTL  DS    X,XL3               IN: X'00' OR X'20' FOR PREFIX USERID\nDA08DSO  DS    X                   OUT: X'02' => \"PO\", X'01' => \"U\"\nDA08ALN  DS    CL8                 IN: IGNORED\nDAPB08L  EQU   *-DAPB08            LENGTH OF TYPE 08 DAPB\n         SPACE 2\nDAPB18   DS    0C                  DYN. ALLOC. PARAM. BLOCK TYPE 18\n*                                  (FREE A DATA SET)\nDA18CD   DS    XL2                 IN: TYPE CODE (X'0018')\nDA18FLG  DS    XL2                 OUT: FLAGS\nDA18DARC DS    XL2                 OUT: DYN. ALLOC. RETURN CODE\nDA18CTRC DS    XL2                 CATALOG RETURN CODE\nDA18PDSN DS    A                   IN: -> DSNAME BUFFER\nDA18DDN  DS    CL8                 IN: DDNAME\nDA18MNM  DS    CL8                 IN: SPACES (MEMBER NAME)\nDA18SCLS DS    CL2                 IN: SPACES (SYSOUT CLASS)\nDA18DSP  DS    X                   IN: X'08' (KEEP)\nDA18CTL  DS    X                   IN: X'00' OR X'20' FOR PREFIX USERID\nDA18JBNM DS    CL8                 IN: SPACES (SYSOUT JOBNAME)\nDAPB18L  EQU   *-DAPB18            LENGTH OF TYPE 18 DAPB\n         SPACE 2\nDFPL     DS    0CL16              DEFAULT PARM LIST            *AB79238\nDFPLUPT  DS    A                  ->UPT                        *AB79238\nDFPLECT  DS    A                  ->ECT                        *AB79238\nDFPLECB  DS    A                  ->ECB                        *AB79238\nDFPLDFPB DS    A                  ->DEFAULT PARM BLOCK         *AB79238\nDFPB     DS    0CL12              DEFAULT PARM BLOCK           *AB79238\nDFPBDSN  DS    A                  ->DSN TO BE QUALIFIED        *AB79238\nDFPBPSCB DS    A                  ->PSCB                       *AB79238\nDFPBQUAL DS    A                  ->RETURN QUALIFIER (UNUSED)  *AB79238\nDECWORK  DS    D                  DECIMAL WORK AREA            *AB79238\nFAILPL   DAIRFAIL MF=L            DAIRFAIL PARM LIST           *AB79238\nRETC     DS    H              ULTIMATE RETURN CODE             *AB79238\nWHATFAIL DS    C                   WHAT FAILED SWITCH\n         END   LISTM\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTM#": {"ttr": 6414, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": ")F FUNCTION -\n  The LISTMEM command is used to list the names of the members in\n  one or more partitioned data sets.\n)X SYNTAX -\n         LISTMEM  ('dslist')  MATCH/ALPHABETIC  FREE/COLUMN\n  REQUIRED - 'dslist'\n  DEFAULTS - MATCH  FREE\n  ALIAS    - LISTM\n  NOTES    - If only one data set is specified in 'dslist',\n             the parentheses are optional.\n)O OPERANDS -\n  'dslist' - Specifies the names of the data sets to be processed.\n))MATCH    - Requests that aliases be matched with main members\n             and flagged with an '=' sign.\n))ALPHABETIC -\n             Requests that aliases be placed in collating sequence\n             with main members and flagged with an '*'.\n))FREE     - Requests that unnecessary spaces be deleted from output.\n))COLUMN   - Requests that member names be printed in columnar\n             format.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTU": {"ttr": 6657, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "LISTU     SAVEX LV=WORKLEN\n          SPACE 2\n          USING WORKAREA,R13\n          ST    R1,CPPLADDR          SAVE PARAMETER LIST ADDRESS\n          EJECT\n          SPACE 2\n*  THIS PROGRAM RETURNS THE USERIDS OF ALL ACTIVE TSO USERS\n*    PLUS COUNTS OF ACTIVE USERS AND USERS LOGGING ON.\n*    USERIDS ARE LISTED ALPHABETICALLY ACROSS THE FULL\n*    OUTPUT LINE FOR ANY TERMINAL.\n          SPACE 4\n          BAL   R2,INIT\n          SPACE 1\nLISTU3    NOP   LISTUX\n          BAL   R2,GETUID         GET AN ACTIVE USERID\n          CLC   UIDEXIST,YES      DOES THE LAST CONTROL BLOCK\n*                                   POINT TO AN ACTIVE USERID?\n          BNE   LISTU5            BRANCH ON NO\n          BAL   R2,SORT           SORT WITH PREVIOUSLY RETRIEVED UIDS\n          CLC   EOUSERS,YES       HAS LAST CONTROL BLOCK BEEN CHECKED?\n          BNE   LISTU3            BRANCH ON NO\n          SPACE 1\nLISTU5    NOP   LISTUX\n          BAL   R2,INITOUT\nLISTU7    NOP   LISTUX\n          CLC   USERCTR,BIN0      ARE THERE ANY ACTIVE TSO USERS?\n          BE    LISTU8            BRANCH ON NO\n          BAL   R2,GETSRTU        GET A SORTED USERID\n          BAL   R2,PUTUSER        POSITION THE USERID FOR OUTPUT,\n*                                   WRITE A FULL LINE\n          CLC   LASTUSER,YES      IS THIS THE LAST SORTED USERID?\n          BNE   LISTU7            BRANCH ON NO\nLISTU8    NOP   LISTUX\n          BAL   R2,PUTTOTL        WRITE TOTAL LINE\n          BAL   R2,CLOSE\nLISTUX    BR    R14\n          EJECT\nINIT      NOP   INITX\n          MVC   EOUSERS,NO        LAST CONTROL BLOCK INDICATOR\n          MVC   UIDEXIST,NO       ACTIVE USER INDICATOR\n          MVC   TESTINDX,BIN0     INITIALIZE POINTER\n          SPACE 1\n*  INITIALIZE THE ORIGINAL SORT POINTERS\n          XC    POINTERS(PTRLEN),POINTERS   ZERO THE POINTERS\n          SPACE 1\n          L     R3,16               -> CVT\n          USING CVT,R3\n          L     R4,CVTASVT          -> ASVT\n          USING ASVT,R4\n          L     R5,ASVTMAXU         ASID COUNTER\n          LA    R6,ASVTFRST         -> FIRST ASID\n          DROP  R3\n          DROP  R4\n          SPACE 1\n          SR    R3,R3              TSO USERS COUNTER\n          SR    R4,R4              TSO USERS LOGGING ON COUNTER\nINITX     BR    R2\n          EJECT\n*  SEARCH FOR ACTIVE TSO USERS AND USERS LOGGING ON.\n*    INCREMENT APPROPRIATE COUNTERS.\n*    LEAVE THE ROUTINE WITH AN ACTIVE TSO USERID\n*      OR WHEN ALL CONTROL BLOCKS HAVE BEEN SEARCHED.\n          SPACE 4\nGETUID    NOP   GETUIDX\n          MVC   UIDEXIST,NO        WE DO NOT HAVE A TSO USER\n          SPACE 1\n          TM    0(R6),X'80'        UNUSED?\n          BO    GETUID2            YES, GET NEXT\n          SPACE 1\n          L     R7,0(0,R6)         -> ASCB\n          USING ASCB,R7\n          L     R8,ASCBTSB         -> TSB\n          LTR   R8,R8              TSO SESSION?\n          BZ    GETUID2            BRANCH ON \"NO\"\n          SPACE 1\n          L     R9,ASCBJBNS        -> TSO USERID\n          LTR   R9,R9              USER LOGGING ON?\n          BNZ   GETUID6            BRANCH ON \"NO\"\n          A     R4,BIN1            INCREMENT USER LOGGING ON COUNTER\n          SPACE 1\nGETUID2   NOP   GETUIDX\n          A     R6,BIN4            ADVANCE TO NEXT ASID\n          BCT   R5,GETUID          REDUCE TOTAL ASID COUNT,\n*                                    BRANCH IF MORE ASIDS AVAILABLE\n          B     GETUID8            BRANCH ON LAST ASID\n          SPACE 1\nGETUID6   NOP   GETUIDX\n          MVC   USERSAVE,0(R9)     STORE TSO USERID\n          MVC   UIDEXIST,YES       WE FOUND A TSO USER\n          A     R3,BIN1            INCREMENT ACTIVE USERS COUNTER\n          A     R6,BIN4            ADVANCE TO NEXT ASID\n          BCT   R5,GETUIDX         REDUCE TOTAL ASID COUNT,\n*                                    BRANCH IF MORE ASIDS AVAILABLE\n          SPACE 1\nGETUID8   NOP   GETUIDX\n          MVC   EOUSERS,YES        NO MORE ASID'S,\n*                                    END OF USERID SEARCH\n          ST    R4,LOGONCTR        STORE USERS LOGGING ON COUNT\n          ST    R3,USERCTR         STORE ACTIVE USERS COUNT\nGETUIDX   BR    R2\n          EJECT\n          SPACE 2\n*  PLACE A TSO USERID IN ALPHABETICAL SEQUENCE.\n*    THERE ARE 30 POINTERS, ONE FOR EACH OF $, #, AND @,\n*    ONE FOR EACH LETTER AND ONE MORE AT THE END.\n*    A POINTER VALUE OF BIN ZERO INDICATES AN\n*    EMPTY STACK.  OTHERWISE THE POINTER POINTS TO THE FIRST\n*    ENTRY IN THE STACK.  A STACK ENTRY CONSISTS OF A POINTER\n*    AND A PREVIOUSLY STORED USERID.  AN ENTRY POINTER VALUE\n*    OF BIN ZERO INDICATES THE LAST ENTRY IN THE STACK.\n*    OTHERWISE THE POINTER POINTS TO THE NEXT ENTRY.\n          SPACE 4\nSORT      NOP   SORTX\n          LA    R7,POINTERS        ADDRESS OF FIRST POINTER\n          SPACE 1\nSORT1     NOP   SORTX\n          MVC   TESTUID(1),USERSAVE  MOVE THE FIRST LETTER OF\n*                                    THE USERID TO TEST\n          TR    TESTUID,TABLE      TRANSLATE LETTER TO DISPLACEMENT\n          A     R7,TESTINDX        POINT TO STACK\n          USING LIST,R7\n*  WE HAVE SELECTED A STACK\n          SPACE 1\nSORT3     NOP   SORTX\n          CLC   NEXTPTR,BIN0      IS THIS AN EMPTY STACK OR\n*                                   THE LAST ENTRY IN THIS STACK?\n          BE    SORT5             BRANCH ON YES\n          ST    R7,LOWPTR         STORE CURRENT POINTER\n          L     R7,NEXTPTR        POINT THE CURRENT POINTER TO THE NEXT\n*                                   ENTRY IN THE STACK\n          CLC   USERID,USERSAVE   COMPARE THE STACK USERID TO THE\n*                                   USERID BEING SORTED\n          BL    SORT3             BRANCH IF THE STACK USERID IS LOW\n          L     R7,LOWPTR         THE STACK USERID IS HIGH,\n*                                   POINT CURRENT POINTER TO PREVIOUS\n*                                   ENTRY IN STACK (BACK UP ONE ENTRY)\n          SPACE 1\nSORT5     NOP   SORTX\n          GETMAIN  R,LV=LISTLEN   GET STORAGE TO ADD TO STACK\n          SPACE 1\n          USING NEWLIST,R1\n*  PLACE NEW STORAGE INTO STACK\n          MVC   NEWPTR,NEXTPTR    MOVE THE STACK NEXT ENTRY ADDRESS\n*                                   TO THE NEXT ENTRY ADDRESS IN THE\n*                                   NEW STORAGE\n          ST    R1,NEXTPTR        STORE THE ADDRESS OF THE NEW STORAGE\n*                                   IN THE STACK NEXT ENTRY ADDRESS\n*  NOW THE NEW STORAGE IS PART OF THE STACK\n          SPACE 1\n          MVC   NEWUSER,USERSAVE  MOVE THE SORTED USERID INTO THE\n*                                   NEW ENTRY IN THE STACK\n          DROP  R1\n          DROP  R7\nSORTX     BR    R2\n          EJECT\nINITOUT   NOP   INITOUTX\n          ST    R2,R2SAVE\n*  GET TERMINAL LINESIZE\n          GTSIZE\n          ST    R1,DATALEN      STORE TERMINAL LINESIZE\n          CLC   DATALEN,BIN8    COMPARE LINESIZE TO USERID LENGTH\n          BNL   INITOUT2        BRANCH ON ADEQUATE LINESIZE\n          MVC   DATALEN,BIN8    INCREASE LINESIZE TO USERID LENGTH\nINITOUT2  NOP   INITOUTX\n          L     R0,DATALEN LOAD TERMINAL LINESIZE\n          GETMAIN  R,LV=(0)     GET STORAGE FOR TERMINAL OUTPUT\n          ST    R1,DATAADDR     STORE ADDRESS OF OUTPUT LINE\n          BAL   R2,CLEARLN      MOVE SPACES TO OUTPUT LINE\n          SR    R8,R8\n          L     R9,DATALEN      LOAD TERMINAL LINESIZE\n          D     R8,BIN8         DIVIDE BY 7 (USERID) + 1 (SPACE)\n          ST    R9,MAXUOUT      STORE MAXIMUM USERS PER OUTPUT LINE\n          SR    R10,R10\n          MVC   BLANK,BLANKS    BLANK 1 POSITION TO RIGHT OF USERID\n          MVC   LASTUSER,NO     THIS IS NOT THE LAST USERID\n          SR    R4,R4\n          LA    R5,POINTERS     LOAD ADDRESS OF FIRST POINTER (STACK A)\n          LA    R7,POINTERS      \"      \"    \"    \"      \"       \"   \"\n          L     R8,DATAADDR     LOAD ADDRESS OF OUTPUT LINE\n          L     R2,R2SAVE\nINITOUTX  BR    R2\n          EJECT\n          SPACE 2\n*  GET A SORTED USERID FOR OUTPUT.  START WITH STACK A.\n*    LOOK FOR AN ENTRY IN THE STACK.  IF THERE IS NO ENTRY,\n*    MOVE TO THE NEXT STACK.  WHEN AN ENTRY IS FOUND, MOVE\n*    THE USERID TO HOLD AND LEAVE THE ROUTINE.\n*  NOW, EACH TIME THE ROUTINE IS ENTERED, THE SEARCH WILL\n*    BEGIN AT THE ENTRY LOCATED ON THE PREVIOUS PASS.\n          SPACE 4\nGETSRTU   NOP   GETSRTUX\n          CLC   0(4,R7),BIN0       IS STACK EMPTY OR HAS LAST ENTRY\n*                                    IN STACK BEEN PROCESSED?\n          BNE   GETSRTU3           BRANCH ON NO\n          A     R5,BIN4            MOVE TO NEXT STACK\n          LR    R7,R5\n          B     GETSRTU\nGETSRTU3  NOP   GETSRTUX\n          L     R7,0(R7)           MOVE TO NEXT ENTRY IN STACK\n          MVC   USEROUT1,4(R7)     MOVE USERID TO HOLD\n          A     R4,BIN1            COUNT USERIDS OUTPUT\n          C     R4,USERCTR         DO WE HAVE ALL SORTED USERIDS?\n          BNE   GETSRTUX           BRANCH ON NO\n          MVC   LASTUSER,YES       THIS IS THE LAST SORTED USERID\nGETSRTUX  BR    R2\n          EJECT\n          SPACE 2\n*  POSITION A USERID ON THE OUTPUT LINE.  WHEN THE LINE IS FULL\n*    OR AFTER LAST USERID IS POSITIONED, BRANCH TO WRITE THE LINE.\n          SPACE 4\nPUTUSER   NOP   PUTUSERX\n          ST    R2,R2SAVE\n          A     R10,BIN1           INCREMENT OUTPUT LINE USER COUNTER\n          C     R10,MAXUOUT        IS OUTPUT LINE FULL?\n          BNH   PUTUSER3           BRANCH ON YES\n          BAL   R2,WRITE           WRITE AN OUTPUT LINE\n          BAL   R2,CLEARLN         CLEAR THE OUTPUT LINE\n          L     R10,BIN1           REINITIALIZE COUNTER\n          L     R8,DATAADDR        LOAD ADDRESS OF OUTPUT LINE\nPUTUSER3  NOP   PUTUSERX\n          MVC   0(8,R8),USEROUT    MOVE USERID TO OUTPUT\n          A     R8,BIN8            POINT TO NEXT AVAILABLE POSITION'\n*                                    ON THE OUTPUT LINE\n          CLC   LASTUSER,NO        IS THIS THE LAST USERID FOR OUTPUT?\n          BE    PUTUSER6           BRANCH ON NO\n          BAL   R2,WRITE           WRITE THE LINE\nPUTUSER6  NOP   PUTUSERX\n          L     R2,R2SAVE\nPUTUSERX  BR    R2\n          EJECT\n          SPACE 2\n*  WRITE AN OUTPUT LINE\n          SPACE 4\nWRITE     NOP   SORTX\n          L     R1,DATAADDR       LOAD OUTPUT LINE ADDRESS\n          L     R3,DATALEN        LOAD OUTPUT LINE LENGTH\n          L     R9,CPPLADDR       LOAD PARAMETER LIST ADDRESS\n          UPUT  (1),(3),CPPL=(9),DATA\nWRITEX    BR    R2\n          EJECT\n          SPACE 2\n*  BLANK THE OUTPUT LINE.\n          SPACE 4\nCLEARLN   NOP   CLEARLNX\n          L     R1,DATAADDR      LOAD OUTPUT LINE ADDRESS\n          MVC   0(1,R1),BLANKS   BLANK FIRST BYTE OF OUTPUT LINE\n          L     R9,DATALEN       LOAD OUTPUT LINE LENGTH\n          S     R9,BIN2          SUBTRACT 1 FROM LENGTH\n          EX    R9,CLEARLNZ      LOAD SPACES\nCLEARLNX  BR    R2\n          SPACE 4\nCLEARLNZ  MVC   1(0,R1),0(R1)\n          EJECT\n          SPACE 2\n*  SET UP TOTALS LINE.  BRANCH TO WRITE.\n          SPACE 4\nPUTTOTL   NOP   PUTTOTLX\n          ST    R2,R2SAVE\n          CLC   DATALEN,TMSGLEN  IS OUTPUT LINE LENGTH LONG\n*                                  ENOUGH FOR TOTALS MESSAGE\n          BH    PUTTOTL2         BRANCH ON YES\n          MVC   DATALEN,TMSGLEN  STORE TOTALS LINE LENGTH\n          L     R0,DATALEN       LOAD    \"     \"     \"\n          GETMAIN R,LV=(0)       GET STORAGE FOR TOTALS LINE\n          SPACE 1\n          ST    R1,DATAADDR      STORE ADDRESS OF NEW STORAGE\n          SPACE 1\nPUTTOTL2  NOP   PUTTOTLX\n          BAL   R2,CLEARLN       BLANK OUTPUT LINE\n          L     R5,DATAADDR      LOAD OUTPUT LINE ADDRESS\n          MVC   WORKCTR,USERCTR  MOVE USERID COUNTER TO WORK AREA\n          BAL   R2,USERMSG       MOVE \"NNN USER(S)\" TO OUTPUT LINE\n          MVC   0(6,R5),LOGGED   MOVE \"LOGGED\" TO OUTPUT\n          LA    R5,7(,R5)\n          MVC   0(2,R5),ON       MOVE \"ON\" TO OUTPUT\n          LA    R5,3(,R5)\n          MVC   0(3,R5),AND      MOVE \"AND\" TO OUTPUT\n          LA    R5,4(,R5)\n          MVC   WORKCTR,LOGONCTR MOVE LOGGING ON COUNTER TO WORK AREA\n          BAL   R2,USERMSG       MOVE \"NNN USER(S) TO OUTPUT LINE\"\n          MVC   0(7,R5),LOGGING  MOVE \"LOGGING\" TO OUTPUT\n          LA    R5,8(,R5)\n          MVC   0(2,R5),ON       MOVE \"ON\" TO OUTPUT\n          BAL   R2,WRITE         BRANCH TO WRITE LINE\n          L     R2,R2SAVE\nPUTTOTLX  BR    R2\n          EJECT\n          SPACE 2\n*  POSITION \"NNN USER(S)\" ON OUTPUT LINE\n          SPACE 4\nUSERMSG   NOP   USERMSGX\n          ST    R2,R2SAVE2\n          L     R3,WORKCTR           LOAD COUNTER\n          C     R3,BIN0              DOES COUNT EQUAL ZERO\n          BE    USERMSG2             BRANCH ON YES\n          CVD   R3,DOUBLCTR          CONVERT COUNT TO DECIMAL\n          MVC   0(4,R5),MASK         MOVE EDIT MASK TO OUTPUT\n          ED    0(4,R5),DOUBLCTR+6   MOVE COUNT TO OUTPUT\n          B     USERMSG4\nUSERMSG2  NOP   USERMSGX\n          MVC   0(4,R5),NO2          MOVE \"NO\" TO OUTPUT\nUSERMSG4  NOP   USERMSGX\n          BAL   R2,MOVE              REMOVE SPACES TO LEFT OF COUNT\n*                                      OR WORD \"NO\"\n          MVC   0(4,R5),USER         MOVE \"USER\" TO OUTPUT\n          LA    R5,4(,R5)\n          C     R3,BIN1              DOES COUNT EQUAL 1?\n          BE    USERMSG8             BRANCH ON YES\n          MVC   0(1,R5),S            MOVE \"S\" TO OUTPUT\n          LA    R5,1(,R5)\nUSERMSG8  NOP   USERMSGX\n          LA    R5,1(,R5)\n          L     R2,R2SAVE2\nUSERMSGX  BR    R2\n          EJECT\n          SPACE 2\n*  REMOVE SPACES TO LEFT OF COUNT OR WORD \"NO\" ON OUTPUT LINE\n          SPACE 1\n*  UPON ENTRY, REGISTER 5 POINTS TO THE POSITION ON THE OUTPUT\n*    LINE WHERE REMOVAL OF LEADING BLANKS WILL BEGIN.\n*    ON LEAVING ROUTINE, REGISTER 5 POINTS TO THE NEXT\n*    AVAILABLE POSITION ON THE OUTPUT LINE.\n          SPACE 4\n*  USE REGISTER 6 TO FIND RIGHTMOST BYTE ON THE OUTPUT LINE.\n*  REGISTER 7 BEGINS AT THE POSITION IN REGISTER 5\n*    AND MOVES ALONG THE OUTPUT LINE FROM LEFT TO RIGHT,\n*    STOPPING AT THE FIRST NON-BLANK OR AT THE LAST POSITION\n*    ON THE OUTPUT LINE.\n          SPACE 1\nMOVE      NOP   MOVEX\n          L     R6,DATAADDR      LOAD ADDRESS OF OUTPUT LINE\n          A     R6,DATALEN       ADD LENGTH OF OUTPUT LINE\n          S     R6,BIN1          DECREASE BY 1 TO GET LAST POSITION\n          ST    R6,LASTPOS       STORE LAST POSITION\n          ST    R5,STARTPOS      STORE STARTING POSITION\n          L     R7,STARTPOS      LOAD STARTING POSITION\n*  LOCATE FIRST NON-BLANK\nMOVE2     NOP   MOVEX\n          ST    R7,CURRPOS       STORE TEST POINTER\n          CLC   0(1,R7),BLANKS   IS THIS BYTE BLANK?\n          BNE   MOVE4            BRANCH ON NO\n          LA    R7,1(,R7)        MOVE 1 BYTE TO RIGHT\n          CR    R7,R6            IS THIS THE BYTE TO THE RIGHT\n*                                  OF THE OUTPUT LINE?\n          BNH   MOVE2            BRANCH ON NO\n          B     MOVEX            THERE ARE ONLY BLANKS FROM STARTING\n*                                  POSITION THROUGH END OF LINE\nMOVE4     NOP   MOVEX\n          CLC   CURRPOS,STARTPOS WE ARE POINTING TO THE FIRST NON-\n*                                  BLANK.  IS THIS ALSO THE\n*                                  STARTING POSITION?\n          BE    MOVE6            BRANCH ON YES\n          SPACE 1\n*  MOVE DATA FROM RIGHT TO LEFT ELIMINATING BLANKS\n*    USE REGISTER 8 TO CALCULATE THE LENGTH OF THE MOVE.\n*    LOAD REGISTER 8 WITH THE ADDRESS OF THE LAST POSITION ON\n*    THE OUTPUT LINE.  SUBTRACT THE ADDRESS OF THE FIRST NON-BLANK,\n*    LEAVING THE NUMBER OF CHARACTERS TO SHIFT RIGHT.\n          L     R8,LASTPOS       LOAD LAST POSITION\n          S     R8,CURRPOS       SUBTRACT ADDRESS OF FIRST NON-BLANK\n          EX    R8,MOVEY         REMOVE BLANKS BY SHIFTING MESSAGE\n*                                  RIGHT TO LEFT\n          SPACE 1\n*  FILL IN END OF LINE WITH BLANKS\n*    USE REGISTER 8 TO CALCULATE THE LENGTH OF THE MOVE.\n*    LOAD REGISTER 8 WITH THE ADDRESS OF THE FIRST NON-BLANK\n*    BEFORE THE SHIFT RIGHT.  SUBTRACT THE ADDRESS OF THE\n*    FIRST POSITION ON THE LINE AND ONE MORE, LEAVING\n*    THE NUMBER OF POSITIONS TO BLANK FILL ON THE LEFT END\n*    OF THE OUTPUT LINE.\n          L     R8,CURRPOS       LOAD ADDRESS OF FIRST NON-BLANK\n*                                  BEFORE MESSAGE SHIFT\n          S     R8,STARTPOS      SUBTRACT ADDRESS OF STARTING POSITION\n          S     R8,BIN1          SUBTRACT 1 TO GET LENGTH FOR EX MOVE\n          L     R9,LASTPOS       LOAD LAST POSITION\n          SR    R9,R8            CALCULATE FIRST POS TO BE BLANKED\n          EX    R8,MOVEZ         MOVE BLANKS TO END OF LINE\n          SPACE 1\n*  LOOP TO FIND FIRST BLANK AND MOVE POINTER ONE BYTE TO ITS RIGHT\n*    THIS IS THE NEXT AVAILABLE POSITION ON THE OUTPUT LINE.\nMOVE6     NOP   MOVEX\n          CLC   0(1,R5),BLANKS\n          LA    R5,1(,R5)\n          BNE   MOVE6\nMOVEX     BR    R2\n          SPACE 4\nMOVEY     MVC   0(0,R5),0(R7)\nMOVEZ     MVC   0(0,R9),BLANKS\n          EJECT\nCLOSE     NOP   CLOSEX\n          RETURNX\nCLOSEX    BR    R2\n          EJECT\nBIN0      DC    F'0'\nBIN1      DC    F'1'\nBIN2      DC    F'2'\nBIN4      DC    F'4'\nBIN8      DC    F'8'\nMASK      DC    XL4'40202120'\n          SPACE 4\n          DS    0F\nBLANKS    DC    CL50' '\n          SPACE 4\nNO        DC    CL1'N'\nYES       DC    CL1'Y'\n          SPACE 4\nAND       DC    CL3'AND'\nLOGGED    DC    CL6'LOGGED'\nLOGGING   DC    CL7'LOGGING'\nNO2       DC    CL4'  NO'\nON        DC    CL2'ON'\nUSER      DC    CL4'USER'\nS         DC    CL1'S'\n          SPACE 4\nTMSG      DC    0C'NNNN USERS LOGGED ON AND NNNN USERS LOGGING ON'\nTMSGLEN   DC    AL4(L'TMSG)\n          SPACE 4\n*  THE COLLATING SEQUENCE IS  $, #, @, A, ..., Z.\n*    ANY CHANGE TO THE COLLATING SEQUENCE WILL REQUIRE\n*    A CORRESPONDING CHANGE TO THE TABLE.\n*  $ IS 5B;  # IS 7B;  @ IS 7C;\n*  A - I IS C1 - C9;\n*  J - R IS D1 - D9;\n*  S - Z IS E2 - E9;\n          SPACE 1\nTABLE     DC    256X'74'\n          ORG   TABLE+C'$'\n          DC    X'00'\n          ORG   TABLE+C'#'\n          DC    X'0408'\n          ORG   TABLE+C'A'\n          DC    X'0C1014181C2024282C'\n          ORG   TABLE+C'J'\n          DC    X'3034383C4044484C50'\n          ORG   TABLE+C'S'\n          DC    X'54585C6064686C70'\n          ORG   ,\n          SPACE 4\nLIST      DS    0F\nNEXTPTR   DS    A\nUSERID    DS    CL7\nLISTLEN   EQU   *-LIST\n          SPACE 4\nNEWLIST   DS    0F\nNEWPTR    DS    A\nNEWUSER   DS    CL7\nNEWLLEN   EQU   *-NEWLIST\n          SPACE 4\nWORKAREA  DSECT\n          DS    18A\nEOUSERS   DS    CL1\nLASTUSER  DS    CL1\nUIDEXIST  DS    CL1\nUSERSAVE  DS    CL7\nTESTINDX  DS    0F\nTESTIND1  DS    CL3\nTESTUID   DS    CL1\nUSEROUT   DS    0F\nUSEROUT1  DS    CL7\nBLANK     DS    CL1\nUSERCTR   DS    A\nLOGONCTR  DS    A\nWORKCTR   DS    A\nDOUBLCTR  DS    D\nMAXUOUT   DS    A\nLOWPTR    DS    A\nCPPLADDR  DS    A\nDATAADDR  DS    A\nDATALEN   DS    A\nSTARTPOS  DS    A\nCURRPOS   DS    A\nLASTPOS   DS    A\nR2SAVE    DS    A\nR2SAVE2   DS    A\nPOINTERS  DS    0F\nPTR$      DS    A\nPTR#      DS    A\nPTR@      DS    A\nAPTR      DS    A\nBPTR      DS    A\nCPTR      DS    A\nDPTR      DS    A\nEPTR      DS    A\nFPTR      DS    A\nGPTR      DS    A\nHPTR      DS    A\nIPTR      DS    A\nJPTR      DS    A\nKPTR      DS    A\nLPTR      DS    A\nMPTR      DS    A\nNPTR      DS    A\nOPTR      DS    A\nPPTR      DS    A\nQPTR      DS    A\nRPTR      DS    A\nSPTR      DS    A\nTPTR      DS    A\nUPTR      DS    A\nVPTR      DS    A\nWPTR      DS    A\nXPTR      DS    A\nYPTR      DS    A\nZPTR      DS    A\nSPACEP    DS    A\nENDPTR    EQU   *-4\nPTRLEN    EQU   *-POINTERS\nWORKLEN   EQU   *-WORKAREA\n          EJECT\n          PRINT NOGEN\n          CVT   DSECT=YES\n          EJECT\n          IHAASVT\n          EJECT\n          IHAASCB\n          SPACE 4\n          END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTU#": {"ttr": 6666, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": ")F FUNCTION -\n  The LISTU command lists the users currently logged on to TSO.\n)X SYNTAX -\n         LISTU\n  ALIAS    - None\n)O OPERANDS -\n  There are no operands.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MAPDISK": {"ttr": 6668, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " /* ICSA Disk Mapper - MAPDISK.  Main Routine.  Richard Schafer 4/79  */\n MAPDISK:\n   PROC(PARM) OPTIONS(MAIN) REORDER;\n0/*********************************************************************/\n /*                                                                   */\n /* MAPDISK: ICSA Disk Mapper                                         */\n /*          This program reads a standard disk VTOC, and produces a  */\n /*          listing sorted by data set name of the contents of the   */\n /*          disk.  Two report forms are available, a short form      */\n /*          which produces one line per data set giving basic data   */\n /*          regarding the data set, and a long form which produces   */\n /*          several lines per data set giving complete VTOC          */\n /*          information.  Multiple volumes may be mapped in one      */\n /*          execution; the volumes to be mapped are identified by    */\n /*          DD names beginning with VOLUME.                          */\n /*                                                                   */\n /* Author:  Richard A. Schafer                                       */\n /*                                                                   */\n /* Date  :  April 1979                                               */\n /*                                                                   */\n /* Macros:  IECSDSL1 - PL/I version of the DSCB mapping macros       */\n /*                                                                   */\n /* Files :  SYSPRINT - Report output.                                */\n /*          VOLUMEnn - Volume pointers.                              */\n /*          SPILL    - Work file for VTOC copy.                      */\n /*          SORTWKnn - Sort work files.                              */\n /*                                                                   */\n /* External Routines:                                                */\n /*          FORMAT4  - Assembler routine which reads the TIOT to     */\n /*                     build a table indicating the number of        */\n /*                     volumes to be mapped, and the DDname, volser, */\n /*                     and UCB address of each volume.               */\n /*          COPYVTOC - Called once for each volume to copy the       */\n /*                     VTOC to a work file.                          */\n /*          UCFRETRV - ICSA routine to interpret the contents of     */\n /*                     the data set creator stamp field in the VTOC  */\n /*                     entry.                                        */\n /*          System sort                                              */\n /*                                                                   */\n /* Parameters: One parameter is used to indicate which report type   */\n /*             is to be produced:                                    */\n /*                SHORT - produce one line per data set report       */\n /*                LONG  - produce full information report            */\n /*                                                                   */\n /* Authorization :                                                   */\n /*          YES - COPYVTOC does a RESERVE on the VTOC to ensure      */\n /*                that no interference occurs while reading it.      */\n /*                                                                   */\n /*********************************************************************/\n0  DCL\n      PLIXOPT CHAR(13) VAR INIT('NOSPIE,NOSTAE') STATIC EXTERNAL,\n      COPYVTOC EXTERNAL ENTRY(POINTER, FIXED BIN(15),\n                              FIXED BIN(15),FIXED BIN(15))\n               OPTIONS(ASSEMBLER INTER RETCODE),\n      FORMAT4 EXTERNAL ENTRY(POINTER) OPTIONS(ASSEMBLER,INTER),\n      UCFRETRV ENTRY OPTIONS(ASSEMBLER,RETCODE,INTER);\n   DCL\n      PARM CHAR(100) VAR,\n      TIMEX CHAR(9),\n      DATEX CHAR(6),\n      (HOUR,\n      MINUTE,\n      SECOND,\n      YEAR,\n      MONTH,\n      DAY) CHAR(2),\n      DSCBS(*) CHAR(140) CONTROLLED,\n      1 TABLE BASED(TABLE_POINTER),    /* DDNAME VOLSER UCB TABLE */\n         2 # FIXED BIN(15),            /* NUMBER OF VOLUMEXX DD CARDS */\n         2 VOLUME_ENTRY(#_DDS REFER(#)) UNALIGNED,\n            3 DDNAME CHAR(8),\n            3 VOLSER CHAR(6),\n            3 UCB POINTER,\n      #_DDS FIXED BIN(15),\n      MAPDISK_RETURN_CODE FIXED BIN(31) INIT(0),\n      RETURN_CODE FIXED BIN(31),\n      (PLIRETC,\n      PLIRETV,\n      ADDR,\n      PLISRTD,\n      TIME,\n      DATE,\n      VERIFY,\n      INDEX,\n      SUBSTR) BUILTIN,\n      (VTOC_START,\n      DSCBS_PER_TRACK,\n      TRACKS_PER_CYLINDER,\n      TOTAL_ALLOCATED,\n      TOTAL_USED,\n      I,\n      J,\n      L) FIXED BIN(15),\n      PAGE_NUMBER FIXED DEC(3) INIT(1),\n      TABLE_POINTER POINTER,\n      REQUEST_CODE BIT(32)\n         INIT('11000000100000000000000000000000'B),\n      MSG_BUFFER CHAR(128),   /* UNUSED */\n      REASON_CODE FIXED BIN(31),\n      SYSPRINT FILE PRINT,\n      SPILL FILE RECORD ENV(REGIONAL(1),F),\n      VTOC FILE RECORD SEQUENTIAL KEYED INPUT\n         ENV(REGIONAL(2),F,BLKSIZE(96),KEYLENGTH(44));\n      ON ENDPAGE(SYSPRINT)\n         CALL HEADING;\n      OPEN FILE(SYSPRINT)LINESIZE(132);\n      CALL FORMAT4(TABLE_POINTER);\n      DO I=1 TO #;\n         TIMEX=TIME;\n         DATEX=DATE;\n         HOUR=SUBSTR(TIMEX,1,2);\n         MINUTE=SUBSTR(TIMEX,3,2);\n         SECOND=SUBSTR(TIMEX,5,2);\n         YEAR=SUBSTR(DATE,1,2);\n         MONTH=SUBSTR(DATE,3,2);\n         DAY=SUBSTR(DATE,5,2);\n         CALL\n         COPYVTOC(ADDR(VOLUME_ENTRY(I)),DSCBS_PER_TRACK,\n                  VTOC_START,TRACKS_PER_CYLINDER);\n         OPEN FILE(SPILL) SEQUENTIAL INPUT;\n         IF I=1 THEN\n            SIGNAL ENDPAGE(SYSPRINT);\n         IF PLIRETV \u00ac= 0 THEN\n            DO;\n               PUT SKIP(3)\n                   EDIT('I/O ERRORS READING VTOC - SEE JOB LOG')(A);\n               PUT SKIP(3);\n               MAPDISK_RETURN_CODE = PLIRETV;\n            END;\n         ALLOCATE DSCBS(DSCBS_PER_TRACK);\n         READ FILE(SPILL) INTO(DSCBS);\n         TOTAL_ALLOCATED,TOTAL_USED=0;\n         CALL\n         PLISRTD(' SORT FIELDS=(1,44,CH,A) ',\n                 ' RECORD TYPE=F,LENGTH=(140) ',\n                 0,\n                 RETURN_CODE,\n                 DISKMAP_E15,\n                 DISKMAP_E35,\n                 '',\n                 'CC');\n         IF RETURN_CODE=16 THEN\n            DO;\n               PUT SKIP EDIT('SORT FAILED FOR VOLUME=', VOLSER(I))\n                        (A,A);\n               MAPDISK_RETURN_CODE = 16;\n            END;\n         PUT SKIP(2) EDIT('TOTAL TRACKS ALLOCATED= ',TOTAL_ALLOCATED)\n                     (COL(10),A,F(5))\n                     ('TOTAL TRACKS USED= ',TOTAL_USED)\n                     (COL(50),A,F(5));\n         FREE DSCBS;\n         CLOSE FILE(SPILL);\n         PAGE_NUMBER=1;\n         PUT LINE(60);\n      END;\n      CALL PLIRETC(MAPDISK_RETURN_CODE);\n DISKMAP_E15:\n   PROC RETURNS(CHAR(140)) REORDER;\n   DCL\n      DSCB_NUMBER FIXED BIN(15) STATIC INIT(1),\n      SPILL_EOF BIT(1) INIT('0'B);\n      ON ENDFILE(SPILL)\n         SPILL_EOF='1'B;\n /* DSCBS HAS BEEN PRELOADED PRIOR TO CALLING SORT */\n      DO UNTIL(SPILL_EOF);\n         DO DSCB_NUMBER=DSCB_NUMBER REPEAT(DSCB_NUMBER+1)\n         WHILE(DSCB_NUMBER <= DSCBS_PER_TRACK);\n            IF SUBSTR(DSCBS(DSCB_NUMBER),45,1)='1' THEN\n               DO;\n                  CALL PLIRETC(12);    /* CONTINUE THE SORT */\n                  DSCB_NUMBER=DSCB_NUMBER+1;\n                  RETURN(DSCBS(DSCB_NUMBER-1));\n               END;\n         END;\n         DSCB_NUMBER=1;\n         READ FILE(SPILL) INTO(DSCBS);\n      END;\n      CLOSE FILE(SPILL);\n      OPEN FILE(SPILL) DIRECT INPUT;\n      CALL PLIRETC(8);                 /* TERMINATE THE SORT */\n   END DISKMAP_E15;\n DISKMAP_E35:\n   PROC(DSCB) REORDER;\n   DCL\n      DSCB CHAR(140),\n      COPTCD CHAR(8) VAR INIT(''),\n      K FIXED BIN(15),\n      J FIXED BIN(15),\n      (MIN,\n       TRUNC,\n       LINENO) BUILTIN,\n      1 LAST STATIC,\n         2 TRACK FIXED BIN(15),\n         2 BLOCK FIXED BIN(15),\n      FORMAT CHAR(4) VARYING STATIC,\n      1 DSN_ENTRY STATIC,              /* ALL THE RELEVANT INFO ABOUT\n                                       A DATA SET */\n         2 DSNAME CHAR(44),\n         2 CREATED_BY,\n            3 ACCOUNT CHAR(10),\n            3 USERID CHAR(7),\n         2 CREATE_DATE FIXED BIN(31),\n         2 EXPIRE_DATE FIXED BIN(31),\n         2 LAST_REFERENCE,\n           3 YEAR FIXED BIN(15),\n           3 DAY  FIXED BIN(15),\n         2 PROTECTION CHAR(10),\n         2 DSORG CHAR(2),\n         2 NOMOVE CHAR(1),\n         2 RECFM CHAR(5),\n         2 LRECL FIXED BIN(15),\n         2 BLKSIZE FIXED BIN(15),\n         2 OPTCD BIT(8) ALIGNED,\n         2 KEYLEN FIXED BIN(15),\n         2 REL_KEY_POS FIXED BIN(15),\n         2 ALLOCATION_UNIT CHAR(9),    /* ABSTR, CYL, TRK, BLK */\n         2 SECONDARY FIXED BIN(15),\n         2 ALLOCATED FIXED BIN(15),    /* SPACE ALLOCATED IN TRACKS */\n         2 EMPTY FIXED BIN(15),        /* EMPTY SPACE */\n         2 #_EXTENTS FIXED BIN(15),\n         2 EXTENTS(16),                /* ALLOW FOR MAXIMUM */\n            3 LOW(2) FIXED BIN(15),\n            3 HIGH(2) FIXED BIN(15),\n      (F1PTR,\n      F2PTR,\n      F3PTR) POINTER DEF(DSCB_POINTER),\n      DSCB_POINTER POINTER;\n      %DCL (FORMAT1,FORMAT2,FORMAT3,FORMAT4,FORMAT5,FORMAT6) CHAR;\n      %FORMAT1='YES';\n      %FORMAT2='YES';\n      %FORMAT3='YES';\n      %FORMAT4='NO';\n      %FORMAT5='NO';\n      %FORMAT6='NO';\n %NOPRINT;\n      %INCLUDE SYSLIB(IECSDSL1);       /* INCLUDE DSCB MAPPING MACROS */\n %PRINT;\n      DSCB_POINTER=ADDR(DSCB);\n      DSNAME=DS1DSNAM;\n      /* Find the userid and account of the creator (Jackson Roykirk) */\n      IF INDEX('0123456789',SUBSTR(DS1LGNID,1,1)) \u00ac= 0 THEN\n         DO;\n            CREATED_BY.ACCOUNT=SUBSTR(DS1LGNID,1,10);\n            CREATED_BY.USERID=SUBSTR(DS1LGNID,11,7);\n         END;\n      ELSE IF SUBSTR(DS1LGNID,1,1) = ' ' THEN\n         DO;\n            CREATED_BY.ACCOUNT=' ';\n            CREATED_BY.USERID=' ';\n         END;\n      ELSE\n         DO;\n            FETCH UCFRETRV;\n            CALL UCFRETRV(REQUEST_CODE,MSG_BUFFER,REASON_CODE,\n                          CREATED_BY.USERID,CREATED_BY.ACCOUNT,\n                          DS1LGNID);\n            /* FOR THE TIME BEING, IGNORE UCFRETRV RETURN CODE */\n         END;\n      CREATE_DATE=1000*DS1CRYR+DS1CRDAY;\n      EXPIRE_DATE=1000*DS1EXYR+DS1EXDAY;\n      LAST_REFERENCE.YEAR = DS1REFYR;\n      LAST_REFERENCE.DAY  = DS1REFDA;\n      SELECT (DS1DSIND&'00010100'B);\n         WHEN('00000000'B)\n            PROTECTION='  NONE';\n         WHEN('00010000'B)\n            PROTECTION='READ/WRITE';\n         WHEN('00010100'B)\n            PROTECTION='  WRITE';\n         OTHERWISE\n            ;\n      END;\n      IF SUBSTR(DS1DSORG,8,1) THEN\n /* UNMOVABLE */\n         DO;\n            NOMOVE='U';\n            SUBSTR(DS1DSORG,8,1)='0'B;\n         END;\n      ELSE\n         NOMOVE=' ';\n      SELECT (DS1DSORG);\n         WHEN('1000000000000000'B)\n            DSORG='IS';\n         WHEN('0100000000000000'B)\n            DSORG='PS';\n         WHEN('0010000000000000'B)\n            DSORG='DA';\n         WHEN('0000001000000000'B)\n            DSORG='PO';\n         WHEN('0000000000100000'B)\n            DSORG='TQ';\n         WHEN('0000000000001000'B)\n            DSORG='AM';\n         OTHERWISE\n            DSORG='**';\n      END;\n      FORMAT='';\n      IF DS1RECFM&'00010000'B THEN\n         FORMAT=FORMAT||'B';\n      IF DS1RECFM&'00001000'B THEN\n         FORMAT=FORMAT||'S';\n      IF DS1RECFM&'00000100'B THEN\n         FORMAT=FORMAT||'A';\n      ELSE\n         IF DS1RECFM&'000000010'B THEN\n            FORMAT=FORMAT||'M';\n      IF DS1RECFM&'00100000'B THEN\n         FORMAT=FORMAT||'T';\n      SELECT (DS1RECFM&'11000000'B);\n         WHEN('10000000'B)\n            RECFM='F'||FORMAT;\n         WHEN('01000000'B)\n            RECFM='V'||FORMAT;\n         WHEN('11000000'B)\n            RECFM='U'||FORMAT;\n         OTHERWISE\n            RECFM='*****';\n      END;\n      LRECL=DS1LRECL;\n      BLKSIZE=DS1BLKL;\n      OPTCD=DS1OPTCD;\n      KEYLEN=DS1KEYL;\n      REL_KEY_POS=DS1RKP;\n      SELECT (DS1STYPE&'11000000'B);\n         WHEN('00000000'B)\n            ALLOCATION_UNIT='ABSTR';\n         WHEN('01000000'B)\n            ALLOCATION_UNIT='BLOCKS';\n         WHEN('10000000'B)\n            ALLOCATION_UNIT='TRACKS';\n         WHEN('11000000'B)\n            ALLOCATION_UNIT='CYLINDERS';\n         OTHERWISE\n            ;\n      END;\n      SECONDARY=DS1SQUAN;\n      #_EXTENTS=DS1NOEPV;\n      LAST.TRACK=DS1LRELTR;\n      LAST.BLOCK=DS1LBLCK;\n      EXTENTS.LOW,EXTENTS.HIGH=0;\n      EXTENTS(1).LOW(*)=DS1EX1LOW;\n      EXTENTS(1).HIGH(*)=DS1EX1HGH;\n      IF #_EXTENTS>1 THEN\n         DO;\n            EXTENTS(2).LOW(*)=DS1EX2LOW;\n            EXTENTS(2).HIGH(*)=DS1EX2HGH;\n            IF #_EXTENTS>2 THEN\n               DO;\n                  EXTENTS(3).LOW(*)=DS1EX3LOW;\n                  EXTENTS(3).HIGH(*)=DS1EX3HGH;\n                  IF #_EXTENTS>3 THEN\n                     DO;\n                        CALL GET_DSCB(DS1PTRDS);\n                        IF DSORG='IS' THEN\n                           CALL GET_DSCB(DS2PTRDS);\n                        DSCB_POINTER=ADDR(DSCB);\n                        DO K=1 TO 4 WHILE(K+3<=#_EXTENTS);\n                           EXTENTS(K+3).LOW(*)= DS3EXTNT(K).\n                           DS3EXTLOW(*);\n                           EXTENTS(K+3).HIGH(*)= DS3EXTNT(K).\n                           DS3EXTHGH(*);\n                        END;\n                        IF #_EXTENTS>7 THEN\n                           DO K=1 TO 9 WHILE(K+7<=#_EXTENTS);\n                              EXTENTS(K+7).LOW(*)= DS3ADEXT(K).\n                              DS3ADLOW(*);\n                              EXTENTS(K+7).HIGH(*)= DS3ADEXT(K).\n                              DS3ADHGH(*);\n                           END;\n                     END;\n               END;\n         END;\n      ALLOCATED=0;\n      DO K=1 TO #_EXTENTS;\n         ALLOCATED=ALLOCATED+\n         (EXTENTS(K).HIGH(1)* TRACKS_PER_CYLINDER+ EXTENTS(K).HIGH(2))-\n         (EXTENTS(K).LOW(1)*TRACKS_PER_CYLINDER+ EXTENTS(K).LOW(2))+1;\n      END;\n      IF DSORG='PS' | DSORG='PO' THEN\n         DO;\n            IF LAST.TRACK=0 THEN\n               IF LAST.BLOCK=0 THEN\n                  EMPTY=ALLOCATED;\n               ELSE\n                  EMPTY=ALLOCATED-1;\n            ELSE\n            EMPTY=ALLOCATED-LAST.TRACK-1;\n         END;\n      ELSE\n         EMPTY=0;\n      TOTAL_ALLOCATED=TOTAL_ALLOCATED+ALLOCATED;\n      TOTAL_USED=TOTAL_USED+ALLOCATED-EMPTY;\n      IF PARM \u00ac= 'SHORT' THEN\n         DO;\n            IF LINENO(SYSPRINT) > 51-TRUNC(#_EXTENTS/4) THEN\n               PUT LINE(60);\n            PUT SKIP EDIT('CREATED BY')(COL(50),A)\n                         ('CREATED')(COL(65),A)\n                         ('EXPIRES')(COL(74),A)\n                         ('LAST REF')(COL(83),A)\n                         ('PROTECTION')(COL(92),A)\n                         ('DSORG')(COL(104),A)\n                         ('RECFM')(COL(111),A)\n                         ('LRECL')(COL(118),A)\n                         ('BLKSIZE')(COL(125),A);\n            PUT SKIP EDIT(DSNAME)(COL(1),A);\n            IF VERIFY(SUBSTR(ACCOUNT,1,1),'0123456789')=0 THEN\n               PUT EDIT(ACCOUNT,'-',USERID)(COL(46),A,A,A);\n            PUT EDIT(CREATE_DATE)(COL(65),F(5))\n                    (EXPIRE_DATE)(COL(74),F(5));\n            IF LAST_REFERENCE.YEAR < 70 | LAST_REFERENCE.YEAR > 99 THEN\n               PUT EDIT('*****')(COL(83),A);\n            ELSE\n               PUT EDIT(1000*LAST_REFERENCE.YEAR+LAST_REFERENCE.DAY)\n                        (COL(83),F(5));\n            PUT EDIT(PROTECTION)(COL(92),A)\n                    (DSORG,NOMOVE)(COL(104),A,A)\n                    (RECFM)(COL(111),A);\n            IF LRECL=-32768 THEN\n               PUT EDIT('X')(COL(119),A);\n            ELSE\n               PUT EDIT(LRECL)(COL(118),F(5));\n            PUT EDIT(BLKSIZE)(COL(126),F(5));\n            PUT SKIP(2) EDIT('OPTCD')(COL(47),A)\n                            ('KEYLEN')(COL(55),A)\n                            ('RKP')(COL(66),A)\n                            ('ALLOCATION')(COL(72),A)\n                            ('SECONDARY')(COL(84),A)\n                            ('TRKS ALLOCATED')(COL(95),A)\n                            ('TRKS USED')(COL(111),A);\n             IF DSORG\u00ac= 'IS' THEN\n                PUT SKIP EDIT(OPTCD)(COL(46),B);\n             ELSE\n                DO;\n                   IF OPTCD&'10000000'B THEN\n                      COPTCD='W';\n                   IF OPTCD&'01000000'B THEN\n                      COPTCD=COPTCD||'U';\n                   IF OPTCD&'00100000'B THEN\n                      COPTCD=COPTCD||'M';\n                   IF OPTCD&'00010000'B THEN\n                      COPTCD=COPTCD||'I';\n                   IF OPTCD&'00001000'B THEN\n                      COPTCD=COPTCD||'Y';\n                   IF OPTCD&'00000010'B THEN\n                      COPTCD=COPTCD||'L';\n                   IF OPTCD&'00000100'B THEN\n                      COPTCD=COPTCD||'R';\n                   IF COPTCD='' THEN\n                      COPTCD='NONE';\n                   PUT SKIP EDIT(COPTCD)(COL(46),A);\n                END;\n                 PUT EDIT(KEYLEN)(COL(56),F(3))\n                         (REL_KEY_POS)(COL(64),F(5))\n                         (ALLOCATION_UNIT)(COL(72),A)\n                         (SECONDARY)(COL(86),F(4))\n                         (ALLOCATED)(COL(99),F(5))\n                         (ALLOCATED-EMPTY)(COL(113),F(5));\n            IF #_EXTENTS=0 THEN\n               PUT SKIP(2) EDIT('DATA SET HAS NO EXTENTS')(COL(45),A);\n            ELSE\n               DO;\n                  PUT SKIP(2) EDIT('EXTENTS OF DATA SET:')(COL(45),A);\n                  PUT SKIP EDIT((' #    LOW    HIGH   '\n                                 DO K=1 TO MIN(4,#_EXTENTS)))\n                               (COL(45),(MIN(4,#_EXTENTS))(A));\n                  PUT SKIP EDIT((K,EXTENTS(K).LOW(1),'-',\n                                 EXTENTS(K).LOW(2),EXTENTS(K).HIGH(1),\n                                 '-',EXTENTS(K).HIGH(2)\n                                   DO K=1 TO #_EXTENTS))\n                                (COL(45),(MIN(4,#_EXTENTS))\n                                 (P'99',2 (X(2),P'999',A,P'99'),X(2)));\n                  PUT SKIP;\n               END;\n         END;\n      ELSE\n         DO;\n            PUT SKIP EDIT(DSNAME)(A);\n            IF VERIFY(SUBSTR(ACCOUNT,1,1),'0123456789')=0 THEN\n               PUT EDIT(ACCOUNT,'-',USERID)(COL(46),A,A,A);\n            IF LAST_REFERENCE.YEAR < 70 | LAST_REFERENCE.YEAR > 99 THEN\n               PUT EDIT('*****')(COL(65),A);\n            ELSE\n               PUT EDIT(1000*LAST_REFERENCE.YEAR+LAST_REFERENCE.DAY)\n                       (COL(65),F(5));\n            PUT EDIT(PROTECTION,DSORG,NOMOVE,ALLOCATED,\n                     (ALLOCATED-EMPTY),SECONDARY)\n                    (COL(74),A,COL(87),A,A,\n                    COL(93),F(5),COL(104),F(5),\n                    COL(113),F(4));\n            IF ALLOCATION_UNIT = 'BLOCKS' THEN\n               PUT EDIT(' (',BLKSIZE,')') (A,F(5),A);\n            ELSE\n               IF ALLOCATION_UNIT= 'ABSTR' THEN\n                  PUT EDIT(' CYLINDERS') (A);\n               ELSE\n                  PUT EDIT(' ',ALLOCATION_UNIT) (A,A);\n         END;\n      CALL PLIRETC(4);/* TELL SORT GO AHEAD */\n GET_DSCB:\n   PROC(PTRDS) REORDER;\n   DCL\n      1 PTRDS UNALIGNED,\n         2 CYL FIXED BIN(15),\n         2 TRK FIXED BIN(15),\n         2 REC BIT(8) ALIGNED;\n      READ FILE(SPILL) INTO(DSCBS)\n                       KEY((CYL*TRACKS_PER_CYLINDER+TRK)-VTOC_START);\n      DSCB=DSCBS(REC);\n   END GET_DSCB;\n   END DISKMAP_E35;\n HEADING:\n   PROC REORDER;\n      PUT LINE(1)\n      EDIT('CONTENTS OF VOLUME=',VOLSER(I),' AT ',HOUR,':',MINUTE, ':',\n          SECOND,' ON ', MONTH,'/',DAY,'/',YEAR,'PAGE ',PAGE_NUMBER)\n          (A,A,A,A,A,A,A,A,A,A,A,A,A,A,COL(120),A,F(3));\n      IF PARM='SHORT' THEN\n         DO;\n            PUT SKIP EDIT('TRACKS')(COL(88),A);\n            PUT SKIP EDIT('DSNAME')(COL(1),A)\n                            ('CREATED BY')(COL(50),A)\n                            ('LAST REF')(COL(65),A)\n                            ('PROTECTION')(COL(74),A)\n                            ('DSORG')(COL(86),A)\n                            ('ALLOCATED  USED')(COL(93),A)\n                            ('SECONDARY')(COL(111),A);\n         END;\n      IF PAGE_NUMBER=1 THEN\n         PUT SKIP;\n      ELSE\n         PUT SKIP(2);\n      PAGE_NUMBER=PAGE_NUMBER+1;\n   END HEADING;\n   END MAPDISK;\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MAPDISK$": {"ttr": 6921, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//MAPDISK  PROC\n//*  *****************************************************************\n//*  *     ICSA MAPDISK PROCEDURE TO MAP STANDARD DISKS     FEG      *\n//*  *****************************************************************\n//MAPDISK EXEC PGM=MAPDISK,PARM='/SHORT'\n//STEPLIB DD DSN=RICE.UTILITY,DISP=SHR\n//VOLUME1 DD UNIT=SYSDA,VOL=SER=STOREA,DISP=OLD\n//VOLUME2 DD UNIT=SYSDA,VOL=SER=STOREB,DISP=OLD\n//VOLUME3 DD UNIT=SYSDA,VOL=SER=STOREC,DISP=OLD\n//VOLUME4 DD UNIT=3330,VOL=SER=PAGEP1,DISP=OLD\n//VOLUME5 DD UNIT=3330,VOL=SER=PAGEL1,DISP=OLD\n//VOLUME6 DD UNIT=3330,VOL=SER=MVSCAT,DISP=OLD\n//VOLUME7 DD UNIT=3330,VOL=SER=SPOOL1,DISP=OLD\n//VOLUME8 DD UNIT=SYSDA,VOL=SER=PUBL01,DISP=OLD\n//VOLUME9 DD UNIT=3330,VOL=SER=APPLIB,DISP=OLD\n//VOLUME10 DD UNIT=3330,VOL=SER=MVSI81,DISP=OLD\n//SYSPRINT DD SYSOUT=A\n//SPILL   DD UNIT=SYSDA,SPACE=(TRK,(200))\n//SORTWK01 DD UNIT=REALDA,SPACE=(TRK,(20,20))\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MLPA": {"ttr": 6923, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    CONVERT  &REG\n***            CONVERT HEX CHARACTERS TO PRINTABLE FORMAT   PMCF.\n***            CONVERT (TO,FROM,LENGTH)\n&NAME    DS    0H                      ALIGN ON HALF-WORD\n         LA    14,*+56                 LOAD RETURN ADDRESS\n         MVO   0(2,&REG(1)),0(1,&REG(2)) ADJUST OFFSET\n         MVN   1(1,&REG(1)),0(&REG(2)) SET NUMERIC CHAR.\n         NI    1(&REG(1)),X'0F'        FLIP UNWANTED BITS OFF\n         TR    0(2,&REG(1)),*+20       TRANSLATE THE BYTE\n         LA    &REG(1),2(0,&REG(1))    BUMP UP REGISTER\n         LA    &REG(2),1(0,&REG(2))    BUMP UP REGISTER\n         BCT   &REG(3),*-30            CONVERT AGAIN IF REG. NZERO\n         BCR   15,14                   BRANCH TO EXECUTABLE INST.\n         DC    C'0123456789ABCDEF'     CHARACTER STRING FOR TR INST.\n         MEND\nMODREP   CSECT             \"NO NEED TO IPL\"\n         SPACE 3\n*        ALTERATIONS 2/13/79 BY JSA, YCC                       *YCC JSA\n*        MODREP ALTERED TO USE STOP (P) AND MODIFY (F) CMDS    *YCC JSA\n*        INSTEAD OF WTOR AS COMMUNICATION VEHICLE.  MODREP     *YCC JSA\n*        ALWAYS BE STARTED VIA START (S) COMMAND SUPPLYING AN  *YCC JSA\n*        ID TO MAINTAIN UNIQUE COMMUNICATION PATHS TO DIFFERENT*YCC JSA\n*        MODREPS.  EXAMPLE:                                    *YCC JSA\n*        S  MODREP.JSAMODS,LIB=LPALIB                          *YCC JSA\n*        THEN:                                                 *YCC JSA\n*        F  JSAMODS,IGC0003D  (FOR EXAMPLE)                    *YCC JSA\n*        THE ABOVE REPLACES THE OLD SYNTAX                     *YCC JSA\n*        R NN,IGC0003D                                         *YCC JSA\n*        ALL STRINGS WHICH WERE LEGAL REPLIES BEFORE ARE       *YCC JSA\n*        LEGAL ARGUMENTS TO MODIFY.                            *YCC JSA\n*        P  IDENTIFIER                                         *YCC JSA\n*        IS EQUIVALENT TO                                      *YCC JSA\n*        F  IDENTIFIER,DELETE                                  *YCC JSA\n         SPACE 3                                                YCC JSA\n*********************************************************************\n*  MODREP-LPA/SVC REAL TIME LOADER AND REPLACEMENT AND PERFORMANCE  *\n*         TOOL                                                      *\n*                                                                   *\n*  MODULE CONCEPTS:   \"REAL TIME\" MLPA SIMULATION, SVC REPLACEMENT  *\n*                     AND MODULE \"FIXING\" (FOR PERFORMANCE AND      *\n*                     EASE OF IN-CORE ZAP)                          *\n*                     THIS MODULE IS PAGEABLE.                      *\n*                     LOADED MODULES AND SVCS ARE PLACED IN FIXED   *\n*                     CSA MEMORY.                                   *\n*                     WHY IN FIXED MEMORY?                          *\n*                     1) TYPE 1 AND 2 SVC'S MUST BE RESIDENT IN THE *\n*                        NUCLEUS (OR AT LEAST APPEAR TO BE SO)      *\n*                     2) AS THIS IS A \"TEST TOOL\" THE ASSUMPTION    *\n*                        IS THAT IN-CORE ZAPS MAY BECOME NECESSARY  *\n*                        AND YOU ARE ASSURED THE MODULE WILL BE IN  *\n*                        CORE AT ALL TIMES (NOT PAGED OUT)          *\n*                     3) FOR PERFORMANCE TESTING, A DUPLICATE COPY  *\n*                        OF A CURRENTLY PAGEABLE MODULE MAY BE      *\n*                        RE-LOADED AND YOU WILL BE ABLE TO EXAMINE  *\n*                        THE PERFORMANCE GAINS THAT WOULD RESULT    *\n*                        IN THE PERMANENT FIXING OF THE MODULE VIA  *\n*                        IEAFIXXX                                   *\n*                                                                   *\n*  MEMORY UTILIZATION:                                              *\n*  FOR MODULES:       48 BYTES OF SQA (SP 245)-FOR CDE/XTLST        *\n*  FOR SVCS:          0 BYTES-SVC TABLE UPDATED IN PLACE            *\n*  FOR MODULES/SVCS:  XX BYTES OF CSA (SP 228)-FETCH WILL LOAD AND  *\n*                     RELOCATE YOUR MODULE BASED UPON MODULE SIZE   *\n*                                                                   *\n*  LOCKS OBTAINED:    SALLOC: GETMAIN,FREEMAIN COMMON AREAS         *\n*                     CMS :   LOCK ON CDE CHAIN                     *\n*                     THE USE OF THE LOCKING MECHANISM WILL NOT     *\n*                     AFFECT THE OPERATION OF THIS MODULE IN A U.P. *\n*                     ENVIRONMENT (EXCEPT FOR LOCKING OVERHEAD)     *\n*                                                                   *\n*  LINK ATTR:         AUTH,NORENT,NOREUS                            *\n*                     MUST BE IN APF AUTHORIZED LIBRARY             *\n*                                                                   *\n*  SAMPLE JCL:                                                      *\n*                     //MODREP    PROC  LIB='SYS1.MVSLMOD'          *\n*                     //MODREP    EXEC  PGM=MODREP,TIME=1440        *\n*                     //STEPLIB   DD    DSN=SYS1.MVSLMOD,DISP=SHR   *\n*                     //MODREP    DD    DISP=SHR,DSN=&LIB.          *\n*                     //SYSUDUMP  DD    SYSOUT=A                    *\n*                                                                   *\n*                     NOTES:                                        *\n*                            TIME PARM-IF THIS PROGRAM IS CANCELLED *\n*                            FOR WAIT TIME, MODS BECOME RESIDENT    *\n*                            UNTIL THE NEXT IPL, UNLESS OVERRIDDEN  *\n*                            BY ANOTHER STARTUP OF THIS PROGRAM.    *\n*                            DD MODREP-IS WHERE THE MODULES THAT    *\n*                            YOU WILL BE LOADING ON A REAL TIME     *\n*                            BASIS EXIST.                           *\n*                            DD STEPLIB-LIBRARY MUST BE NAMED IN    *\n*                            IEAAPFXX MEMBER OF PARMLIB, ELSE USE   *\n*                            A LINKLIST DATASET WITH NO STEPLIB     *\n*                            SYSUDUMP IS NOT NECESSARY (AS THIS     *\n*                            CODE IS TOTALLY INFALLIBLE)...SORT OF  *\n*                            IT IS POSSIBLE TO HAVE AS MANY COPIES  *\n*                            OF THIS PROGRAM RUNNING AT ONCE AS IS  *\n*                            NECESSARY (IE. 1 PER PDS LIBRARY BEING *\n*                            ACCESSED).                             *\n*                                                                   *\n*  WTOR:               OUTSTANDING WTOR FOR LIFE OF TASK            *\n*                      \"MODREP READY\"                               *\n*                                                                   *\n*  REPONSES:           \"DISPLAY\" - DISPLAY ALL MODULES/SVCS         *\n*                                  CURRENTLY LOADED AND THEIR EPA'S *\n*                      \"DI\"      - SHORT FORM OF ABOVE              *\n*                      \"DELETE\"  - REMOVE (DELETE) ALL MODULES      *\n*                                  LOADED, THEN GO AWAY             *\n*                      \"DE\"      - SHORT FORM OF ABOVE              *\n*                      \"KEEP\"    - LEAVE (KEEP) ALL MODULES LOADED, *\n*                                  THEN GO AWAY                     *\n*                      \"KE\"      - SHORT FORM OF ABOVE              *\n*                      \"XXXXXXXX\"- XXXXXXXX IS THE NAME OF THE      *\n*                                  MODULE/SVC TO BE LOADED          *\n*                                                                   *\n*  INFORMATION ON ALIASES:    ----------WARNING----------           *\n*                                                                   *\n*        ALIAS SHOULD BE LOADED AFTER LOADING THE TRUE NAME VIA     *\n*        MODREP. THIS SHOULD BE DONE TO ASSURE THAT THE MEMORY      *\n*        USED BY THE ALIAS ENTRY(S) WILL BE FREED WHEN NECESSARY.   *\n*        IF YOU FORGET TO LOAD THE TRUE NAME, THE ONLY DAMAGE IS    *\n*        THAT THE MEMORY USED CANNOT BE FREED VIA \"DE\" OR \"DELETE\"; *\n*        NEVERTHELESS, \"DE\" OR \"DELETE\" WILL CAUSE THE CESSATION    *\n*        OF USE OF ALL ALIASES. BE AWARE THAT IT IS ONLY NECESSARY  *\n*        TO LOAD A SINGLE TRUE NAME AND A SINGLE ALIAS FOR THE      *\n*        ROUTINE ENTRY POINT THAT YOU WANT TO TEST; IT IS NOT       *\n*        NECESSARY TO LOAD EVERY SINGLE ALIAS FOR A MODULE FOR      *\n*        MODREP TESTING PURPOSES. ALSO, BE AWARE THAT AN ALIAS      *\n*        ONLY COSTS 48 BYTES FOR THE CDE/XTLST, AND NO MEMORY FOR   *\n*        FOR THE MODULE, AND THE ENTIRE MODULE IS LOADED UNDER THE  *\n*        TRUE NAME.                                                 *\n*                                                                   *\n*  INFORMATIONAL MESSAGES:                                          *\n*                                                                   *\n*        MESSAGE FORMAT-                                            *\n*        WTO   'MODREP-XXXXX XXXXX XXXXX',ROUTCDE=(2)               *\n*               XXXXX REPRESENTS TEXTS FOUND BELOW ENCLOSED IN      *\n*               DOUBLE PARENS.                                      *\n*                                                                   *\n*                      \"LPA REP SUCCESSFUL\"                         *\n*                      ---THE REQUESTED MODULE HAS BEEN PLACED IN   *\n*                         THE LXA (LINK PACK EXTENSION AREA) AND THE*\n*                         ACTIVE LPA CHAIN UPDATED WITH THE NEWLY   *\n*                         BUILT CDE/XTLST, SO THAT SUBSEQUENT USES  *\n*                         OF THE MODULE WILL BE USING THIS          *\n*                         REPLACEMENT COPY                          *\n*                                                                   *\n*                      \"SVC REP SUCCESSFUL\"                         *\n*                      ---THE REQUESTED MODULE HAS BEEN PLACED IN   *\n*                         THE NXA (NUCLEUS EXTENSION AREA) IF A     *\n*                         TYPE 1 OR TYPE 2 SVC, OR PLACED IN THE    *\n*                         LXA (LINK PACK EXTENSION AREA) IF A TYPE  *\n*                         3 OR 4 SVC, AND THE SVC TABLE UPDATED     *\n*                         SO THAT SUBSEQUENT USES OF THE SVC WILL BE*\n*                         USING THIS REPLACEMENT COPY               *\n*                                                                   *\n*                      NOTE: THE DETERMINATION OF WHETHER OR NOT    *\n*                            YOUR MODULE GOES IN THE NXA OR LXA     *\n*                            IS BASED ON THE MODULE NAME. IGCXXX    *\n*                            IS CONSIDERED A TYPE 1/2 SVC IF XXX    *\n*                            IS BETWEEN 0-255 (THESE MODULES GO IN  *\n*                            THE NXA). IGC00XXX IS CONSIDERED A TYPE*\n*                            3/4 SVC IF XXX IS BEWTEEN 0-255 (THESE *\n*                            MODULES GO IN THE LXA). ANY OTHER NAME *\n*                            IS CONSIDERED A STANDARD LPA NAME (OR  *\n*                            A STANDARD SVC SECOND, THIRD, ETC. LOAD*\n*                            AND IS THUS PLACED IN THE LXA). THE    *\n*                            NXA AND LXA ARE CONCEPTUAL ONLY, IN    *\n*                            REALITY BOTH EXIST IN SP 228.          *\n*                                                                   *\n*                      \"SVCTABLE TYPE INVALID, CHANGED TO TYPE 3\"   *\n*                      ---YOU HAVE REQUESTED A TYPE 3/4 SVC BE      *\n*                         REPLACED IN THE LXA (BASED ON THE NAME YOU*\n*                         SUPPLIED (SEE NOTE ABOVE)), BUT THE       *\n*                         SVC ENTRY TYPE INDICATES A NON-TYPE 3/4   *\n*                         SVC (IE. 1,2,5,6). THEREFORE, THE SVCTABLE*\n*                         IS TEMPORARILY UPDATED TO INDICATE THAT   *\n*                         THIS SVC IS A TYPE 3. BEFORE FINAL SVC    *\n*                         INSTALLATION, BE SURE TO ZAP THE SVCTABLE,*\n*                         OR DO ANOTHER I/O GEN SPECIFYING THE      *\n*                         CORRECT TYPE OF SVC.                      *\n*                                                                   *\n*                      \"SVCTABLE TYPE INVALID, REQUEST REJECTED\"    *\n*                      ---YOU HAVE REQUESTED A TYPE 1/2 SVC BE      *\n*                         REPLACED IN THE NXA (BASED ON THE NAME YOU*\n*                         SUPPLIED (SEE NOTE ABOVE)), BUT THE       *\n*                         SVC ENTRY TYPE INDICATES A NON-TYPE 1/2   *\n*                         SVC (IE. 3,4,5,6). THEREFORE, THE REQUEST *\n*                         IS REJECTED, AS IT IS UNKNOWN WHETHER YOU *\n*                         INTENDED A TYPE 1 OR A TYPE 2 (THIS IS    *\n*                         VIRTUALLY MEANINGLESS FOR THE ABOVE CASE  *\n*                         OF TYPE 3/4 AS THEY ARE ENTERED WITH THE  *\n*                         SAME ATTRIBUTES, THEREFORE 3/4 IN THAT    *\n*                         CASE WILL SUFFICE). TO CORRECT THIS       *\n*                         PROBLEM ON A TEMPORARY BASIS, IN-CORE ZAP *\n*                         THE SVCTABLE TYPE TO INDICATE THE TYPE OF *\n*                         SVC YOU REQUIRE, THEN RE-ISSUE YOUR       *\n*                         COMMAND. BEFORE FINAL SVC INSTALLATION, BE*\n*                         SURE TO ZAP THE SVCTABLE, OR DO ANOTHER   *\n*                         I/O GEN SPECIFYING THE CORRECT TYPE OF SVC*\n*                         (NOTE: THIS WILL MOST LIKELY HAPPEN IN THE*\n*                         CASE OF AN UNDEFINED OR TYPE 5 SVC).      *\n*                                                                   *\n*                      NOTE: SVC'S THAT ARE CURRENTLY DEFINED AS    *\n*                            TYPE 5'S, OR CURRENTLY UNDEFINED MAY   *\n*                            BE REPLACED IN THE ABOVE MANNER, IT    *\n*                            IS NOT NECESSARY TO DO AN I/O GEN PRIOR*\n*                            TO TESTING THE SVC(S), BUT IF ANY LOCKS*\n*                            ARE NECESSARY THAT ARE NOT ALREADY ON  *\n*                            IN THE SVCTABLE ENTRY, THEY MUST BE    *\n*                            ZAPPED ON PRIOR TO THE LOADING OF THE  *\n*                            SVC BY MODREP, OR THE SVC WILL BE      *\n*                            ENTERED WITH INCORRECT LOCK ATTRIBUTES.*\n*                                                                   *\n*                      \"LPA/SVC DELETE(S) SUCCESSFUL\"               *\n*                      ---IN RESPONSE TO YOUR \"DELETE\" OR \"DE\"      *\n*                         REQUEST, ALL MODULES AND SVCS CURRENTLY   *\n*                         UNDER CONTROL OF MODREP (THIS MODULE) HAVE*\n*                         BEEN SUCCESSFULLY REMOVED FROM THE SYSTEM.*\n*                         IN THE CASE OF SVC'S, THE SVCTABLE IS     *\n*                         PLACED BACK IN IT'S PRE-MODREP (ORIGINAL) *\n*                         STATE (INCLUDING SVC TYPE), AND THE NXA   *\n*                         MEMORY IS FREED. IN THE CASE OF LPA       *\n*                         MODULES, THE CDE/XTLST THAT WERE BUILT    *\n*                         FOR THIS MODULE ARE DE-CHAINED, AND THE   *\n*                         MEMORY FOR THE CDE/XTLST (SQA) AND LXA    *\n*                         MEMORY IS FREED. THE NET RESULT IS THAT   *\n*                         EVERYTHING IS AS IT WAS PRIOR TO THE      *\n*                         INVOKATION OF MODREP.                     *\n*                                                                   *\n*                      \"ALL LPA/SVC MODS REMAIN RESIDENT\"           *\n*                      ---IN RESPONSE TO YOUR \"KEEP\" OR \"KE\"        *\n*                         REQUEST, ALL MODULES AND SVCS CURRENTLY   *\n*                         UNDER CONTROL OF MODREP (THIS MODULE) ARE *\n*                         RELEASED TO THE SYSTEM FOR PERMANENT USE  *\n*                         UNTIL THE NEXT IPL. ONCE THIS HAS TAKEN   *\n*                         PLACE, THE ONLY WAY TO GET RID OF THE MOD *\n*                         IS TO START ANOTHER COPY OF MODREP AND    *\n*                         PLACE A \"NEWER\" COPY OF THE MOD IN THE    *\n*                         SYSTEM. YOU CAN NEVER DELETE ANY MODULE   *\n*                         THAT WAS PLACED IN THE SYSTEM WITH A PRIOR*\n*                         INVOKATION OF MODREP. THIS CONSIDERATION  *\n*                         IS ONLY IMPORTANT IN THE FACT THAT A      *\n*                         SUBSEQUENT USE OF THIS MODULE WILL        *\n*                         SUCCESSFULLY DO WHAT YOU WANT, BUT THE    *\n*                         PREVIOUS INVOKATION'S MEMORY FOR THE      *\n*                         CDE/XTLST AND MODULE (NXA,LXA) ARE FIXED, *\n*                         AND THUS BECOME WASTED \"REAL FRAMES\" OF   *\n*                         MEMORY. ALSO A CONSIDERATION FOR SVC'S    *\n*                         IS THAT MODREP CAN ONLY PLACE THE SVCTABLE*\n*                         BACK IN THE STATE IT WAS WHEN MODREP BEGAN*\n*                         (ASSUMING YOU ENTER \"KEEP\" OR \"KE\"),      *\n*                         THEREFORE, THE SVCTABLE CAN NEVER BE      *\n*                         PLACED BACK IN IT'S ORIGINAL (AS OF IPL)  *\n*                         STATE WITHOUT AN IPL (OR IN-CORE ZAP IF   *\n*                         YOU RECORDED THE EPA BEFORE USING MODREP).*\n*                         IF IT IS NOT OBVIOUS BY NOW, THE          *\n*                         IMPLICATIONS ARE SUCH THAT IF YOU REPLY   *\n*                         \"KEEP\" OR \"KE\", YOU HAD BETTER MEAN IT!!! *\n*                                                                   *\n*                      NOTE: THE FAILURE OF THIS MODULE (ABEND) IS  *\n*                            AN IMPLIED \"KEEP\" OR \"KE\". THERE IS    *\n*                            CURRENTLY NO ESTAE ENVIRONMENT, AND IT *\n*                            HAS NOT YET PROVEN NECESSARY. THE MOST *\n*                            COMMON LOSS OF THE MODULE WILL BE A    *\n*                            B23 ABEND DUE THE COMTASK FAILING,     *\n*                            THUS THIS TASK'S WTOR CAUSING IT'S     *\n*                            FAILURE. SHOULD THIS HAPPEN, YOU HAVE  *\n*                            MORE TO WORRY ABOUT THAN MODREP. YOU   *\n*                            MAY START A SUBSEQUENT COPY AS         *\n*                            EXPLAINED ABOVE, SHOULD THE COMTASK    *\n*                            FAILURE (OR ANY OTHER FAILURE) NOT BE  *\n*                            PERMANENT.                             *\n*                                                                   *\n*                      \"MODULE UNLOCATABLE\"                         *\n*                      ---IN RESPONSE TO YOUR \"XXXXXXXX\" REQUEST,   *\n*                         A BLDL TO THE CURRENT PDS (SPECIFIED BY   *\n*                         THE //MODREP DD STATEMENT) INDICATES THAT *\n*                         THE REQUESTED MODULE DOES NOT EXIST, AND  *\n*                         THEREFORE CANNOT BE LOADED. CHECK THAT YOU*\n*                         HAVE SPECIFIED THE CORRECT NAME, OR THE   *\n*                         CORRECT LIBRARY (SEE \"LIB\" ON PROC        *\n*                         STATEMENT FOR POSSIBLE OVERRIDE)          *\n*                                                                   *\n*                      \"LOCK FAILURE\"                               *\n*                      ---DURING PROCESSING, A FAILURE TO OBTAIN    *\n*                         OR RELEASE A REQUIRED LOCK HAS OCCURRED.  *\n*                         ALTHOUGH THIS IS MOST LIKELY A SYSTEM     *\n*                         ORIENTED PROBLEM (OR CODE HAS BEEN ADDED  *\n*                         INCORRECTLY), THE LAST COMMAND ISSUED MAY *\n*                         BE RE-ISSUED TO CHECK THE VALIDITY OF THE *\n*                         MESSAGE WITH NO HARM. IF THE MESSAGE      *\n*                         PERSISTS TAKE TWO ASPIRIN AND LIE DOWN,   *\n*                         OR CHECK TO SEE WHO IS THE CURRENT HOLDER *\n*                         OF THE SALLOC OR DISP LOCK, AND FIND OUT  *\n*                         WHY HE WILL NOT RELEASE IT (YOU HAVE      *\n*                         NOW DEFINITELY UNCOVERED A SYSTEM BUG).   *\n*                                                                   *\n*                      \"SVC REP SUCCESSFUL\"                         *\n*                      \"SQA CRITICAL, REQUEST ABORTED\"              *\n*                      ---DURING PROCESSING, A CONDITIONAL REQUEST  *\n*                         FOR SQA (FOR CDE/XTLST, OR FETCH          *\n*                         PRE-PROCESSING CODE) HAS RETURNED A       *\n*                         NON-ZERO RETURN CODE, INDICATING THAT SQA *\n*                         IS NOT CURRENTLY AVAILABLE. THE LAST      *\n*                         COMMAND ISSUED MAY BE RE-ISSUED TO CHECK  *\n*                         THE VALIDITY OF THE MESSAGE WITH NO HARM. *\n*                         IF THE MESSAGE PERSISTS, CHECK THE CURRENT*\n*                         SQA LEVEL, DETERMINE WHO IS USING IT AND  *\n*                         WHY, AND WAIT UNTIL IT IS RELEASED, OR IF *\n*                         NECESSARY, RE-IPL SPECIFYING MORE SQA     *\n*                         (OR CSA FOR EXPANSION).                   *\n*                                                                   *\n*                      \"RESPONSE LOST-REENTER\"                      *\n*                      ---DURING PROCESSING, A FREEMAIN REQUEST FOR *\n*                         CSA OBTAINED BY THIS MODULE HAS FAILED.   *\n*                         RE-ENTER THE LAST COMMAND, AND THE        *\n*                         FREEMAIN WILL BE RE-ATTEMPTED. IF THE     *\n*                         CONDITION PERSISTS, REPLY \"DISPLAY\" OR    *\n*                         \"DI\" TO FIND WHICH MODULES ARE STILL UNDER*\n*                         MODREP'S CONTROL. THE MODULES LISTED ARE  *\n*                         THOSE THAT CANNOT BE FREED. ENTER \"KEEP\"  *\n*                         OR \"KE\" TO ALLOW MODREP TO SHUTDOWN       *\n*                         NORMALLY, THEN IF THOSE MODULES LISTED    *\n*                         SHOULD HAVE BEEN REPLACED BY THE ORIGINALS*\n*                         IT WILL BE NECESSARY TO START MODREP AGAIN*\n*                         RUNNING AGAINST THE LIBRARY WHERE THE     *\n*                         ORIGINAL MOUDLES ARE, AND USING MODREP TO *\n*                         RE-LOAD THE ORIGINALS. THIS CONDITION     *\n*                         SHOULD NEVER PERSIST FOR MORE THAN THREE  *\n*                         ATTEMPTS, IF IT DOES USE DRISTAN NASAL    *\n*                         DECONGESTIVE, THEN LOOK AT THE PROGRAM    *\n*                         LOGIC.                                    *\n*                                                                   *\n*                                                                   *\n*                      \"ALREADY LOADED, IGNORED\"                    *\n*                      ---YOU HAVE REQUESTED THAT MODREP LOAD A     *\n*                         MODULE WHICH HAS ALREADY BEEN LOADED BY   *\n*                         MODREP DURING THIS SESSION. THE REQUEST   *\n*                         IS IGNORED. IF YOU MUST LOAD ANOTHER COPY *\n*                         EITHER USE MODREP TO DELETE THE CURRENT   *\n*                         ONE, OR IF YOU HAVE MULTILPLE MODULES     *\n*                         UNDER MODREPS CONTROL AND YOU DO NOT WISH *\n*                         TO DELETE ALL THE MODULES (WHICH \"DELETE\" *\n*                         OR \"DE\" DOES), START ANOTHER COPY OF      *\n*                         MODREP, AND LOAD YOUR MODULE USING THE    *\n*                         NEW COPY.                                 *\n*                                                                   *\n*                      \"SLOT TABLE OVERFLOW\"                        *\n*                      ---AFTER LOADING THE REQUESTED MODULE, MODREP*\n*                         FOUND NO SPACE IN HIS \"SLOT TABLE\" TO     *\n*                         RECORD NECESSARY INFORMATION FOR LATER    *\n*                         DELETEION. THE MODULE JUST LOADED CANNOT  *\n*                         BE DELETED. FOR A TEMPORARY SOLUTION (IF  *\n*                         THE MODULE MUST BE DELETED, USE THE       *\n*                         PROCEDURE DEFINED IN THE SECTION ABOVE    *\n*                         FOR THE \"RE-LOADING\" OF THE ORIGINAL COPY.*\n*                         AS A FINAL SOLUTION, QUIT BEING A TURKEY  *\n*                         AND DON'T LOAD OVER 20 MODULES AT A TIME  *\n*                         WITH MODREP. OR...IF YOU MUST PERSIST IN  *\n*                         BEING A TURKEY, INCREASE THE MULTIPLIER   *\n*                         AT CONSTANT NAMTABLE TO THE MAXIMUM AMOUNT*\n*                         OF LOADS REQUIRED.                        *\n*                                                                   *\n*                      \"PDS OPEN FAILED\"                            *\n*                      ---MODREP WAS UNABLE TO OPEN THE PDS NAMED   *\n*                         IN THE //MODREP DD STATEMENT IN YOUR      *\n*                         PROC.  START MODREP AGAIN, IF THE FAILURE *\n*                         PERSISTS, CHECK TO BE SURE THE DATA SET   *\n*                         IS INTACT. FOR A TEMPORARY SOLUTION, MOVE *\n*                         THE NECESSARY MODULES TO ANOTHER LIBRARY. *\n*                                                                   *\n*                      \"INTERNAL CDE CHAIN ERROR\"                   *\n*                      ---INTERNAL PROCESSING HAS FOUND A GLITCH    *\n*                         IN THE SYSTEM BUILT CDE AS A RESULT OF    *\n*                         AN INTERNAL LOAD. ALL MODULES CURRENTY    *\n*                         LOADED ARE KEPT, AND MODREP DUMPS WITH    *\n*                         A USER 100.                               *\n*                                                                   *\n*                      \"INTERNAL LLE CHAIN ERROR\"                   *\n*                      ---INTERNAL PROCESSING HAS FOUND A GLITCH    *\n*                         IN THE SYSTEM BUILT LLE AS A RESULT OF    *\n*                         AN INTERNAL LOAD. ALL MODULES CURRENTY    *\n*                         LOADED ARE KEPT, AND MODREP DUMPS WITH    *\n*                         A USER 200.                               *\n*                                                                   *\n*                      \"XXXXXXXX EP YYYYYY\"                         *\n*                      ---IN RESPONSE TO YOUR \"DISPLAY\" OR \"DI\"     *\n*                         COMMAND, THE MODULE NAMED XXXXXXXX HAS    *\n*                         AN EP OF YYYYYY.  ALL MODULES CURRENTY    *\n*                         LOADED ARE LISTED.                        *\n*                                                                   *\n*                      \"NO MODS IN USE\"                             *\n*                      ---IN RESPONSE TO YOUR \"DISPLAY\" OR \"DI\"     *\n*                         COMMAND, MODREP HAS DETERMINED THAT       *\n*                         NO MODULES ARE CURRENTLY UNDER HIS        *\n*                         CONTROL.                                  *\n*                                                                   *\n*                                                                   *\n*                                                                   *\n*********************************************************************\n         EJECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n         TITLE  'MODREP INITIALIZATION SECTION'\nMODREP   CSECT                            INITIALIZATION\n         SPACE 3\n         STM   R14,R12,12(R13)            SAVE CALLER'S REGS\n         LR    R12,R15                    ZERO BASE\n         USING MODREP,R12                 TELL ASSEMBLER THE NEWS\n         LA    R11,SAVE                   SAVE\n         ST    R11,8(R13)                 AREA\n         ST    R13,4(R11)                 CHAIN\n         LR    R13,R11                    CONVENTIONS\n         MODESET KEY=ZERO,MODE=SUP        FOR LOCK\n         SETLOCK OBTAIN,TYPE=SALLOC,MODE=UNCOND,REGS=SAVE,             X\n               RELATED=('REL0')\n         LTR   R15,R15                    GET IT?\n         BNZ   LOCKFAIL                   NO.\n         LA    R1,LENGTH                  FETCH PATCH LENGTH\n         GETMAIN RC,LV=(R1),SP=245,BRANCH=(YES,GLOBAL)\n         LTR   R15,R15                    GET IT?\n         BNZ   SQAFAIL                    NO. YUK.\n         ST    R1,SAVESQA                 YES.\n         SPACE 3\nREL0     DS    0H                         FREE AP/MP FOR SQA\n         SPACE 3\n         SETLOCK RELEASE,TYPE=SALLOC,REGS=SAVE,RELATED=('SET1')\n         LTR   R15,R15                    REL IT?\n         BNZ   LOCKFAIL                   NO.\n         L     R2,X'10'                   CVT\n         LA    R1,X'2D0'(,R2)             CVTFETCH\n         ST    R1,AFETCHEP                SAVE\n         L     R1,X'2D0'(,R2)             CVTFETCH EP\n         ST    R1,RFETCHEP                SAVE\n         L     R2,SAVESQA                 GOTTEN PATCH\n         ST    R2,MFETCHEP                SAVE\n         MVC   0(LENGTH,R2),FETCHPAT      RELOCATE PATCH\n         SPACE 3\nPATCHTIO DS    0H                         DUMMY UP TIOT\n         SPACE 3\n         L     R2,X'10'                   THIS IS TO\n         L     R2,0(,R2)                  BE ABSOLUTELY\n         L     R2,4(,R2)                  SURE THAT THIS\n         L     R2,12(,R2)                 MODULE DOES NOT\n         MVC   0(16,R2),TIOT              GET LOADED TO CSA\n         MODESET KEY=NZERO\n*****  DELETED                                                  YCC JSA\n*         B     OPEN\n*****  DELETED                                                  YCC JSA\n         SPACE 3                                                YCC JSA\n*        PREPARE OPERATOR COMMUNICATIONS INTERFACE              YCC JSA\n         SPACE 1                                                YCC JSA\n         EXTRACT COMM,FIELDS=COMM  GET COM AREA ADDRESS         YCC JSA\n         L     R1,COMM             R1--> COM AREA               YCC JSA\n         L     R2,4(,R1)           R2--> POSSIBLE CIB FOR START YCC JSA\n         LA    R3,4(,R1)           R3--> --> CIB                YCC JSA\n         USING CIB,R2                                           YCC JSA\n         LTR   R2,R2               ANY START COMMAND?           YCC JSA\n         BZ    NOSTART             NO, NO FREE NEEDED           YCC JSA\n         CLI   CIBVERB,CIBSTART    START COMMAND?               YCC JSA\n         BNE   NOSTART             NO, BETTER NOT FREE IT NOW   YCC JSA\n         QEDIT ORIGIN=(3),BLOCK=(2) YES, FREE IT, DON'T NEED    YCC JSA\nNOSTART  QEDIT ORIGIN=(3),CIBCTR=5 PREPARE FOR 'MODIFY' CMDS    YCC JSA\n         B     OPEN                DONE HERE                    YCC JSA\n         DROP  R2                  RELEASE CIB BASE             YCC JSA\n         EJECT\n         TITLE  'MODREP OPEN LIBRARY SECTION'\n         SPACE 3\nOPEN     DS    0H                         OPEN MODREP LIB\n         SPACE 3\n         OPEN  DCB\n         LA    R1,DCB                     IS\n         USING IHADCB,1                   OPEN\n         TM    DCBOFLGS,DCBOFOPN          GOOD?\n         BZ    OPENFAIL                   NO.\n         B     WTOR                       YES.\n         EJECT\n         TITLE  'MODREP WTOR RESPONSE HANDLING SECTION'\n         SPACE 3\n*        NOTE, IN THIS VERSION, WTOR HAS BEEN REPLACED BY       YCC JSA\n*        STOP/MODIFY TYPE COMMUNICATION                         YCC JSA\n         SPACE 1                                                YCC JSA\nWTOR     DS    0H\n         SPACE 3\n*****  DELETED                                                  YCC JSA\n*         XC    REPLY(8),REPLY             CLEAR REPLY AREA\n*         XC    ECBAD(4),ECBAD             AND ASSOCIATED ECB\n*         WTOR  'MODREP READY',REPLY,8,ECBAD,ROUTCDE=(2)\n*         WAIT  ECB=ECBAD                  DO THE \"HO-HUM\"\n*         OC    REPLY,=CL8' '              UPPER CASE\n*****  DELETED                                                  YCC JSA\n         L     R1,COMM             --> COM AREA                 YCC JSA\n         L     R1,0(R1)            --> ECB                      YCC JSA\n         WAIT  ECB=(1)             WAIT FOR COMMAND             YCC JSA\n         L     R1,COMM             --> COM AREA                 YCC JSA\n         L     R2,4(,R1)           --> CIB                      YCC JSA\n         USING CIB,R2\n         LA    R3,4(,R1)           --> --> CIB                  YCC JSA\n         CLI   CIBVERB,CIBSTOP     IS IT STOP COMMAND?          YCC JSA\n         BNE   NODEL               NO, SKIP STOP CODE             *ARB*\n         MVC   REPLY(6),=C'DELETE' YES, TREAT AS DELETE RESPONSE  *ARB*\n         B     FREECIB                                            *ARB*\nNODEL    MVC   REPLY,=CL8' '       BLANK REPLY AREA               *ARB*\n         LH    R1,CIBDATLN         GET LENGTH                   YCC JSA\n         CH    R1,=H'8'            COMPARE TO MAX               YCC JSA\n         BNH   OKMAX                                            YCC JSA\n         LA    R1,8                IMPOSE MAX                   YCC JSA\nOKMAX    LTR   R1,R1               IMPOSE MIN                   YCC JSA\n         BNP   FREECIB                                          YCC JSA\n         BCTR  R1,0                FOR EXECUTE                  YCC JSA\n         OC    REPLY(0),CIBDATA    (EXECUTED)                   YCC JSA\n         EX    R1,*-6              MOVE DATA                    YCC JSA\nFREECIB  QEDIT ORIGIN=(3),BLOCK=(2) FREE CIB                    YCC JSA\n         CLC   =C'DISPLAY',REPLY          DISPLAY STATUS?\n         BE    DISPLAY                    YES.\n         CLC   =C'DI',REPLY               DISPLAY STATUS?\n         BE    DISPLAY                    YES.\n         CLC   =C'DELETE',REPLY           DELETE MODS?\n         BE    DELETE                     YES.\n         CLC   =C'DE',REPLY               DELETE MODS?\n         BE    DELETE                     YES.\n         CLC   =C'KEEP',REPLY             KEEP MODS?\n         BE    KEEP                       YES.\n         CLC   =C'KE',REPLY               KEEP MODS?\n         BE    KEEP                       YES.\n         MVC   MEMNAME(8),REPLY           SAVE MOD NAME\n         CLI   MEMNAME+7,C'+'             LAST CHAR A +?          *ARB*\n         BNE   GETMOD                     NO.                     *ARB*\n         MVI   MEMNAME+7,X'C0'            YES, CHANGE TO +0       *ARB*\n         B     GETMOD                     GO FOR IT!!!!\n         EJECT\n         TITLE  'MODREP ADD MODULE SECTION'\nGETMOD   DS    0H\n         SPACE 3\n         L     R1,=A(NAMTABLE)       LOADED NAME TABLE           *ARB*\n         SPACE 3\nPRECHECK DS    0H\n         SPACE 3\n         CLI   0(R1),X'FF'           EOT?\n         BE    BLDL                  YES. VERIFY GOOD\n         CLC   0(8,R1),MEMNAME       NO. DUPLICATE?\n         BE    DUPFAIL               YES. NO GO YO-YO\n         LA    R1,32(,R1)            NO.\n         B     PRECHECK              NEXT\n         SPACE 3\nBLDL     DS    0H\n         SPACE 3\n         BLDL  DCB,BLDLIST           MEMBER IN MODREP LIB?\n         B     *+4(15)\n         B     LOAD                  YES.\n         B     MODUFAIL              NO.\n         SPACE 3\nLOAD     DS     0H\n         SPACE 3\n         MODESET KEY=ZERO            BEGIN ORBIT\n         L      R1,AFETCHEP          CVTFETCH\n         L      R2,MFETCHEP          CVTPATCH EPA\n         ST     R2,0(R1)             DUMMY FETCH EPA\n         LA     R1,MEMNAME           HI THERE, CODE READERS\n         LOAD   DE=(R1),DCB=DCB      LOAD\n         L      R1,AFETCHEP          CVTFETCH\n         L      R2,RFETCHEP          FETCH EPA\n         ST     R2,0(R1)             REAL FETCH EPA\n         MODESET KEY=NZERO           RETURN TO EARTH\n         SPACE 3\nLOADLIST DS     0H\n         SPACE 3\n         L     R2,X'10'              CVT\n         L     R2,0(R2)              N/O\n         L     R2,4(R2)              TCB\n         SLR   R9,R9                 ZIP\n         ICM   R9,7,X'25'(R2)        LLE?\n         BZ    LLEERROR              NO.\n         SLR   R2,R2                 ZIP\n         SPACE 3\nCDECHAIN DS    0H\n         SPACE 3\n         ICM   R2,7,5(R9)            CDE?\n         BZ    CDEERROR              NO.\n         CLC   8(8,R2),MEMNAME       YES. RIGHT ONE?\n         BE    CDESAVE               YES.\n         ICM   R9,7,1(R9)            NO. LLE?\n         BZ    LLEERROR              NO.\n         B     CDECHAIN              YES.\n         SPACE 3\nCDESAVE  DS    0H\n         SPACE 3\n         ST    R2,SAVECDE            SAVE CDE\n         TM    X'1C'(R2),X'04'       ALIAS (MINOR CDE)?\n         BNO   NOTALIAS              NO. CONTINUE\n         L      R2,X'14'(,R2)        GET MAJOR CDE\n         SPACE 3\nNOTALIAS DS    0H\n         SPACE 3\n         L     R2,X'14'(,R2)         GET A MAJOR CDE XTLST\n         ST    R2,SAVEXTL            FOR LATER\n         CLC   =C'IGC',MEMNAME       MAYBE SVC?\n         BNE   SET1                  NO.\n         BAL   R14,SVCUPDAT          YES.\n         SPACE 3\nSET1     DS    0H                    HERE EVEN IF SVC             *ARB*\n         SPACE 3\n         MODESET KEY=ZERO,MODE=SUP   FOR LOCK\n         SETLOCK OBTAIN,TYPE=SALLOC,MODE=UNCOND,REGS=SAVE,             X\n               RELATED=('REL1')\n         LTR   R15,R15               GET IT?\n         BNZ   LOCKFAIL              NO.\n         GETMAIN RC,LV=48,SP=245,BRANCH=(YES,GLOBAL)\n         LTR   R15,R15               GET IT?\n         BNZ   SQAFAIL               NO.\n         ST    R1,SAVEGET            YES.\n         SPACE 3\nREL1     DS    0H                    FREE AP/MP FOR CSA\n         SPACE 3\n         SETLOCK RELEASE,TYPE=SALLOC,REGS=SAVE,RELATED=('SET1')\n         LTR   R15,R15               REL IT?\n         BNZ   LOCKFAIL              NO.\n         SPACE 3\nUPDATCDE DS    0H                    FOR MODULES ONLY - NOT SVCS\n         SPACE 3\nGL1      SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=SAVE,              *\n               RELATED=('RL1')       GET LOCAL & CMS LOCKS        *ARB*\n         LTR   R15,R15               GET IT?                      *ARB*\n         BNZ   LOCKFAIL              NO.                          *ARB*\nGC1      SETLOCK OBTAIN,TYPE=CMS,MODE=UNCOND,REGS=SAVE,                *\n               RELATED=('RC1')                                    *ARB*\n         LTR   R15,R15               GET IT?\n         BNZ   LOCKFAIL              NO.\n         L     R2,X'10'              CVT\n         L     R2,X'0BC'(,R2)        CVTQLPQA\n         L     R1,SAVEGET            GOTTEN SQA\n         L     R8,SAVECDE            REP MOD'S CDE\n         MVC   0(32,R1),0(R8)        MOVE CDE TO SQA\n         TM    X'1C'(R1),X'04'       ALIAS (MINOR CDE)?\n         BNO   NOTALI                NO. CONTINUE\n         L     R8,X'14'(,R1)         GET MAJOR CDE\n         MVC   X'18'(8,R1),X'18'(R8) ASSIMILATE MAJOR CDE USE/ATTR\n         SPACE 3\nNOTALI   DS    0H\n         SPACE 3\n         LA    R8,32(,R1)            GET XTLST LOCATION\n         ST    R8,X'14'(R1)          UPDATE CDE APPROPRIATELY\n         L     R8,0(R2)              GET CURRENT CHAIN BEGINNING\n         ST    R8,0(R1)              CHAIN MYSELF TO REAL FIRST CDE\n         L     R8,SAVEXTL            GET REP MOD'S XTLST\n         MVC   32(16,R1),0(R8)       MOVE XTLST IN BEHIND IT\n         OI    X'1C'(R1),X'B3'       SIMULATE NIP/JPAQ THUMBPRINT\n         ST    R1,0(R2)              CHAIN MYSELF INTO ACT CDE'S\nRC1      SETLOCK RELEASE,TYPE=CMS,REGS=SAVE,RELATED=('GC1')       *ARB*\n         LTR   R15,R15               REL IT?\n         BNZ   LOCKFAIL              NO.\nRL1      SETLOCK RELEASE,TYPE=LOCAL,REGS=SAVE,RELATED=('GL1')     *ARB*\n         LTR   R15,R15               REL IT?                      *ARB*\n         BNZ   LOCKFAIL              NO.                          *ARB*\n         MODESET KEY=NZERO,MODE=PROB\n         WTO   'MODREP-LPA REP SUCCESSFUL',ROUTCDE=(2)\n         L     R1,=A(NAMTABLE)       LOADED NAME TABLE            *ARB*\n         SPACE 3\nFINDSLOT DS    0H                    RECORD THE EVENT\n         SPACE 3\n         CLC   0(8,R1),=BL8'0'       OPEN SLOT?\n         BE    STORE                 YES.\n         LA    R1,32(,R1)            NO. BUMP\n         CLI   0(R1),X'FF'           EOT?\n         BE    SLOTERR               YES. USER IS A TURKEY\n         B     FINDSLOT              LOOP\n         SPACE 3\nSTORE    DS    0H                    UPDATE SLOT TABLE\n         SPACE 3\n         MVC   0(8,R1),MEMNAME       SAVE MOD NAME\n         L     R8,SAVECDE            GET REP MOD'S CDE\n         L     R8,X'10'(R8)          & IT'S EPA\n         ST    R8,20(R1)             SAVE\n         L     R8,SAVECDE            GET REP MOD'S CDE\n         MVI   8(R1),C' '            MARK ENTRY AS NON-SVC        *ARB*\n         TM    X'1C'(R8),X'04'       ALIAS (MINOR CDE)?\n         BNO   WTOR                  NO. GO WAIT\n         MVC   8(8,R1),=C'ALIAS   '  NEED TO KNOW FOR LATER\n         B     WTOR                  GO WAIT\n         SPACE 3\nSVCUPDAT DS    0H                    TYPE 1/2 IGCXXX-3/4 IGC00XXX\n         SPACE 3\n         MVC   SVCNAME,MEMNAME       SAVE SVCNAME\n         CLC   MEMNAME+6(2),=C'  '   TYPE 1/2 MAYBE?\n         BE    SVCNUC                YES. CAN\"T BE 3/4\n         CLC   =C'00',MEMNAME+3      POSSIBLE FIRST LOAD TYPE 3/4\n         BNER  R14                   NO. NOT TYPE 3/4\n*        CLC   =C'00',MEMNAME+3      POSSIBLE FIRST LOAD TYPE 3/4?\n*        BNE   SVCNUC                NO. MIGHT BE NUCLEUS SVC\n         CLI   MEMNAME+5,X'F0'       AT LEAST SVC 1XX?\n         BLR   R14                   NO. NOT TYPE 3/4\n         CLI   MEMNAME+5,X'F2'       AT MOST SVC 2XX?\n         BHR   R14                   NO. NOT TYPE 3/4\n         CLI   MEMNAME+6,X'F0'       AT LEAST SVC X0X?\n         BLR   R14                   NO. NOT TYPE 3/4\n         CLI   MEMNAME+6,X'F9'       AT MOST SVC X9X?\n         BHR   R14                   NO. NOT TYPE 3/4\n         CLI   MEMNAME+7,X'C0'       AT LEAST SVC XXA?\n         BLR   R14                   NO. NOT TYPE 3/4\n*****  DELETED (OY VEY)                                         YCC JSA\n*         CLI   MEMNAME+7,X'C7'       BETWEEN XXA-XXF?\n*****  DELETED                                                  YCC JSA\n         CLI   MEMNAME+7,X'CA'     BETWEEN XXA-XXI?             YCC JSA\n         BL    SVCLOAD               YES. VALID TYPE 3/4\n         CLI   MEMNAME+7,X'F0'       AT LEAST SVC XX0?\n         BLR   R14                   NO. NOT TYPE 3/4\n         CLI   MEMNAME+7,X'F9'       AT MOST SVC XXF?\n         BHR   R14                   NO. NOT TYPE 3/4\n         SPACE 3\nSVCLOAD  DS    0H\n*****                                                             *ARB*\n* LOGIC CHANGE - ALSO ADD SVCS TO CDE CHAIN                       *ARB*\n*****                                                             *ARB*\n         LR    R6,R14                SAVE RETURN ADDR             *ARB*\n         SPACE 3\n         L     15,X'10'              CVT\n         L     15,X'C8'(15)          SCVT\n         L     15,X'84'(15)          SVC TABLE ORIGIN\n         MVC   SVCNAME(5),=5C'0'     ZERO FIRST 5 BYTES OF NAME\n         PACK  DWORD(8),SVCNAME+4(4) SVC NUMBER\n         MP    DWORD(8),SVCENLEN     * LENGTH OF SVC ENTRY\n         CVB   14,DWORD              + SVC ORIGIN =\n         AR    R14,R15               SVC ENTRY\n         TM    4(R14),X'C0'          TYPE 3/4 SVC?\n         BO    TYPE34                YES. GROOVY\n         CLI   MEMNAME+6,C' '        TYPE 1/2?\n         BE    CONTINU               YES. NOT 3/4, ASSUME OK\n         WTO   'MODREP-SVCTABLE TYPE INVALID, CHANGED TO TYPE 3'       X\n               ROUTCDE=(2)\n         SPACE 3\nTYPE34   DS    0H\n         SPACE 3\n         CLI   MEMNAME+6,C' '        TYPE 1/2?\n         BNE   CONTINU               NO. REALLY IS TYPE 3/4\n         WTO   'MODREP-SVCTABLE TYPE INVALID, REQUEST REJECTED',       X\n               ROUTCDE=(2)\n         LR    R14,R6                RESTORE RETURN REGISTER      *ARB*\n         BR    R14                   NOW ADD TO LPA CHAINS        *ARB*\n         SPACE 3\nCONTINU  DS    0H\n         SPACE 3\n         L     R1,=A(NAMTABLE)       LOADED NAME TABLE            *ARB*\n         B     FINDSVCS              FIND SLOT TO RECORD EVENT\n         SPACE 3\nFINDSVCS DS    0H\n         SPACE 3\n         CLC   0(8,R1),=BL8'0'       AVAILABLE ENTRY?\n         BE    STORESVC              YES. SAVE SVC NAME\n         LA    R1,32(,R1)            NO. BUMP\n         CLI   0(R1),X'FF'           EOT?\n         BE    SLOTERR               YES. WHAT A TURKEY\n         B     FINDSVCS              FIND OPEN SLOT FOR SVC ENTRY\n         SPACE 3\nSTORESVC DS    0H\n         SPACE 3\n         MVC   0(8,R1),MEMNAME       SAVE SVC NAME\n         MVC   8(8,R1),0(R14)        SAVE SVC ENTRY FROM SVC TABLE\n         ST    R14,16(R1)            SAVE SVC TABLE ENTRY ADDRESS\n         L     R8,SAVEXTL            GET REP MOD'S XTLST\n         L     R8,8(,R8)             GET LENGTH\n         ST    R8,28(R1)             SAVE IT\n         L     R8,SAVEXTL            GET REP MOD'S XTLST\n         L     R8,12(,R8)            GET MSBA\n         ST    R8,24(R1)             SAVE IT\n         L     R8,SAVECDE            GET REP MOD'S CDE            *ARB*\n         L     R8,X'10'(R8)          GET IT'S EPA                 *ARB*\n         ST    R8,20(R1)             SAVE IT'S EPA                *ARB*\n         MODESET KEY=ZERO\n         CLI   MEMNAME+6,C' '        TYPE 1/2?\n         BE    SKIPTHRE              YES. SKIP TYPE 3 GUARANTEE\n         OI    4(R14),X'C0'          GUARANTEE TYPE 3/4 SVC       *ARB*\n         SPACE 3\nSKIPTHRE DS    0H\n         SPACE 3\n         ST    R8,0(R14)             UPDATE SVC TABLE\n         MODESET KEY=NZERO\n         WTO   'MODREP-SVC REP SUCCESSFUL'\n         LR    R14,R6                RESTORE RETURN REG           *ARB*\n         BR    R14                   GO ADD TO LPA                *ARB*\n         SPACE 3\nSVCNUC   DS    0H                    CHECK FOR TYPE 1/2 SVC\n         SPACE 3\n         CLC   MEMNAME+6(2),=C'  '   IGCXXX (WITH 2 BLANKS ON BACK)?\n         BNER  R14                   NO. NOT TYPE 1/2 SVC\n         MVC   SVCNAME+5(3),MEMNAME+3    DUMMY SVC NAME FOR CONVERT\n         CLI   SVCNAME+5,X'F0'       AT LEAST SVC 1XX?\n         BLR   R14                   NO. NOT TYPE 1/2\n         CLI   SVCNAME+5,X'F2'       AT MOST SVC 2XX?\n         BHR   R14                   NO. NOT TYPE 1/2\n         CLI   SVCNAME+6,X'F0'       AT LEAST SVC X0X?\n         BLR   R14                   NO. NOT TYPE 1/2\n         CLI   SVCNAME+6,X'F9'       AT MOST SVC X9X?\n         BHR   R14                   NO. NOT TYPE 1/2\n         CLI   SVCNAME+7,X'C0'       AT LEAST SVC XXA?\n         BLR   R14                   NO. NOT TYPE 1/2\n         CLI   SVCNAME+7,X'C7'       BETWEEN XXA-XXF?\n         BL    SVCLOAD               YES. VALID TYPE 1/2\n         CLI   SVCNAME+7,X'F0'       AT LEAST SVC XX0?\n         BLR   R14                   NO. NOT TYPE 1/2\n         CLI   SVCNAME+7,X'F9'       AT MOST SVC XXF?\n         BHR   R14                   NO. NOT TYPE 1/2\n         B     SVCLOAD               YES. TYPE 1/2, IGCXXX\n         EJECT\n         TITLE  'MODREP DELETE MODULE SECTION'\nDELETE   DS    0H\n*****                                                             *ARB*\n* LOGIC CHANGE - FIX UP SVCS FIRST, THEN CDES                     *ARB*\n*****                                                             *ARB*\n         MODESET KEY=ZERO,MODE=SUP   LOCK UP EVERYTHING           *ARB*\n         B     SVCTABCK              REMOVE INSERTED SVCS         *ARB*\n         SPACE 3\nRIPLECDE DS    0H                    RUN THE CDE CHAIN\n         SPACE 3\nGL2      SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=SAVE,              *\n               RELATED=('RL2')                                    *ARB*\n         LTR   R15,R15               GET IT?\n         BNZ   LOCKFAIL              NO.\nGC2      SETLOCK OBTAIN,TYPE=CMS,MODE=UNCOND,REGS=SAVE,                *\n               RELATED=('RC2')                                    *ARB*\n         LTR   R15,R15               GET IT?                      *ARB*\n         BNZ   LOCKFAIL              NO.                          *ARB*\n         SPACE 3\nCONTONLY DS    0H                    SCANNING AND HAVE LOCK ALREADY\n         SPACE 3\n         L     R10,X'10'             CVT\n         L     R10,X'0BC'(,R10)      CVTQLPAQ\n         SPACE 3\nSEARCH   DS    0H\n         SPACE 3\n*********************************************************************\n*        RE-CHAIN CDE'S REMOVING MY CDE'S FROM THE CHAIN            *\n*********************************************************************\n         SPACE 3\n         LR    R11,R10               PREV CDE FOR CHAIN RECONFIGURE\n         ICM   R10,15,0(R10)         LAST CDE?\n         BZ    CLEAR                 YES. CLEAR TO LAND.         *ARB*\n         TM    X'1C'(R10),X'02'      MY THUMBPRINT HERE???\n         BNO   SEARCH                NO.\n         TM    X'1C'(R10),X'80'      MLPA/FLPA? (DOUBLE CHECK)\n         BNO   SEARCH                NO.\n         L     R1,=A(NAMTABLE)       YES. LOADED NAME TABLE       *ARB*\n         SPACE 3\nTABLECHK DS    0H\n         SPACE 3\n         CLI   0(R1),X'FF'           EOT?                         *ARB*\n         BE    TABEND                YES.                         *ARB*\n         CLC   0(8,R1),8(R10)        WAS IT LOADED THIS TIME AROUND?\n         BE    DELETEM               YES. DELETE IT\n         B     TABNEXT                                            *ARB*\nTABEND   NI    X'1C'(R10),X'FD'      YES. REMOVE PRINT (PREV RUN) *ARB*\n         B     CONTONLY              CONT CDE SCAN, LOCK INTACT\n         SPACE 3\nTABNEXT  DS    0H\n         SPACE 3\n         LA    R1,32(,R1)            NEXT ENTRY\n         B     TABLECHK              CHECK IT\n         SPACE 3\nDELETEM  DS    0H\n         SPACE 3\n         CLI   8(R1),0               IS THIS AN SVC ENTRY?        *ARB*\n         BE    TABNEXT               YES, SKIP THIS ENTRY         *ARB*\n         LR    R8,R1                 SAVE CURR TABLE ENTRY\n         XC    0(8,R1),0(R1)         INDICATE MODULE DELETED\n         L     R1,0(R10)             GET CHAIN TO NEXT CDE\n         ST    R1,0(R11)             RECHAIN PREV CDE TO NEXT CDE\nRC2      SETLOCK RELEASE,TYPE=CMS,REGS=SAVE,RELATED=('GC2')       *ARB*\n         LTR   R15,R15               GET IT?\n         BNZ   LOCKFAIL              NO.\nRL2      SETLOCK RELEASE,TYPE=LOCAL,REGS=SAVE,RELATED=('GL2')     *ARB*\n         LTR   R15,R15               GET IT?                      *ARB*\n         BNZ   LOCKFAIL              NO.                          *ARB*\n         SPACE 3\nSET2     DS    0H                    LOCK AP/MP OUT OF CSA\n         SPACE 3\n         SETLOCK OBTAIN,TYPE=SALLOC,MODE=UNCOND,REGS=SAVE,             X\n               RELATED=('REL2')\n         LTR   R15,R15               GET IT?\n         BNZ   LOCKFAIL              NO.\n         CLC   =C'ALIAS',8(R8)       ALIAS (MINOR CDE)?\n         BE    BYPALIAS              YES. MOD FREED VIA TURE NAME\n*        TM    X'1C'(R10),X'04'      ALIAS (MINOR CDE)?\n*        BO    BYPALIAS              YES. MOD FREED VIA TRUE NAME\n         L     R15,X'14'(R10)        GET CDE XTLST ADDR\n         SLR   R4,R4                 ZIP\n         SLR   R7,R7                 ZIP\n         ICM   R7,7,9(R15)           GET LENGTH OF MODULE\n         ICM   R4,7,13(R15)          GET MODULE MSBA\n         FREEMAIN RC,LV=(R7),A=(R4),SP=228,BRANCH=(YES,GLOBAL)\n         LTR   R15,R15               MODULE FREED?\n         BNZ   CSAFAIL               NO.\n         SPACE 3\nBYPALIAS DS    0H\n         SPACE 3\n         FREEMAIN RC,LV=48,A=(R10),SP=245,BRANCH=(YES,GLOBAL)\n         LTR   R15,R15               CDE/XTLST FREED?\n         BNZ   SQAFAIL               NO.\n         SPACE 3\nZAPOFF   DS    0H                    RELEASE CODE ONLY ONE TIME\n         SPACE 3\n         NOP   REL2                  RELEASE CODE ONLY ONE TIME\n         LA    R15,LENGTH            ADDR OF FETCH SQA PATCH CODE\n         L     R1,SAVESQA\n         FREEMAIN RC,LV=(R15),A=(R1),SP=245,BRANCH=(YES,GLOBAL)\n         LTR   R15,R15               CDE/XTLST FREED?\n         BNZ   SQAFAIL               NO.\n         MVI   ZAPOFF+1,X'F0'        YES. DON\"T FREE SQA AGAIN\n         SPACE 3\nREL2     DS    0H                    FREE AP/MP FOR CSA\n         SPACE 3\n         SETLOCK RELEASE,TYPE=SALLOC,REGS=SAVE,RELATED=('SET2')\n         LTR   R15,R15               REL IT?\n         BNZ   LOCKFAIL              NO. OH POOP\n         B     RIPLECDE              YES, SCAN CDE'S\n         SPACE 3\nSVCTABCK DS    0H                    RE-ESTABLISH SVC ENTRIES\n         L     R11,=A(NAMTABLE)      ADDRESS NAME TABLE           *ARB*\n         SPACE 3\n*********************************************************************\n*        RESTORE SVC TABLE ENTRIES TO ORIGINAL STATE                *\n*********************************************************************\n         SPACE 3\nTABSVCCK DS    0H\n         SPACE 3\n         CLI   0(R11),X'00'          NULL ENTRY?\n         BE    TABNXSVC              YES. SKIP\n         CLI   0(R11),X'FF'          EOT?\n         BE    RIPLECDE              YES. GO CLEAN OUT LINK PACK. *ARB*\n         CLI   8(R11),X'00'       IS THIS AN SVC ENTRY?           *ARB*\n         BNE   TABNXSVC           NO, SKIP IT                     *ARB*\n         ICM   R15,7,17(R11)         SVCTAB POINTER\n         MVC   0(8,R15),8(R11)       REP OLD SVC ENTRY\n         SPACE 3\n*****                                                             *ARB*\n* LOGIC CHANGE - FREEMAIN BYPASSED (DONE WHEN REMOVED FROM LPA)   *ARB*\n*****                                                             *ARB*\n         B     TABNXSVC              SKIP AROUND FREEMAIN         *ARB*\n         SPACE 1                                                  *ARB*\nSET3     DS    0H                    LOCK AP/MP OUT OF CSA\n         SPACE 3\n         SETLOCK OBTAIN,TYPE=SALLOC,MODE=UNCOND,REGS=SAVE,             X\n               RELATED=('REL3')\n         LTR   R15,R15               GET IT?\n         BNZ   LOCKFAIL              NO.\n         SLR   R4,R4                 CLEAR\n         SLR   R7,R7                 HI-BYTES\n         ICM   R7,7,29(R11)          SVC LENGTH\n         ICM   R4,7,25(R11)          SVC MSBA\n         FREEMAIN RC,LV=(R7),A=(R4),SP=228,BRANCH=(YES,GLOBAL)\n         LTR   R15,R15               MODULE FREED?\n         BNZ   CSAFAIL               NO.\n         XC    0(32,R11),0(R11)      CLEAR ENTRY\n         SPACE 3\nREL3     DS    0H                    FREE AP/MP FOR CSA\n         SPACE 3\n         SETLOCK RELEASE,TYPE=SALLOC,REGS=SAVE,RELATED=('SET3')\n         LTR   R15,R15               REL IT?\n         BNZ   LOCKFAIL              NO.\n         SPACE 3\nTABNXSVC DS    0H\n         SPACE 3\n         LA    R11,32(,R11)          NEXT ENTRY\n         B     TABSVCCK              CHECK IT\n         SPACE 3\nCLEAR    DS    0H\n         SPACE 3\nRC3      SETLOCK RELEASE,TYPE=CMS,REGS=SAVE,RELATED=('GC2')       *ARB*\n         LTR   R15,R15               GET IT?                      *ARB*\n         BNZ   LOCKFAIL              NO.                          *ARB*\nRL3      SETLOCK RELEASE,TYPE=LOCAL,REGS=SAVE,RELATED=('GL2')     *ARB*\n         LTR   R15,R15               GET IT?                      *ARB*\n         BNZ   LOCKFAIL              NO.                          *ARB*\n         SPACE 3\n         MODESET KEY=NZERO,MODE=PROB RETURN TO EARTH\n         WTO   'MODREP-LPA/SVC DELETE(S) SUCCESSFUL',ROUTCDE=(2)\n         B     BYEBYE                ALL DONE\n         SPACE 3\nKEEP     DS    0H\n         SPACE 3\n         WTO   'MODREP-ALL LPA/SVC MODS REMAIN RESIDENT',ROUTCDE=(2)\n         SPACE 3\nBYEBYE   DS    0H\n         SPACE 3\n         CLOSE DCB                   CLOSE MODREP LIB\n         SLR   15,15                 WAKE UP!!!\n         SVC   3                     THE NIGHTMARE IS OVER\n         SPACE 3\n         EJECT\n         TITLE  'MODREP ERROR HANDLING/DISPLAY SECTION'\nMODUFAIL DS    0H\n         SPACE 3\n         WTO   'MODREP-MODULE UNLOCATABLE',ROUTCDE=(2)\n         B     WTOR                  GO WAIT\n         SPACE 3\nLOCKFAIL DS    0H\n         SETLOCK RELEASE,TYPE=ALL,REGS=USE,RELATED=('GL1')        *ARB*\n         SPACE 3\n         WTO   'MODREP-LOCK FAILURE',ROUTCDE=(2)\n         B     WTOR                  GO WAIT\n         SPACE 3\nSQAFAIL DS     0H\n         SPACE 3\n         SETLOCK RELEASE,TYPE=SALLOC,REGS=USE,RELATED=('SET2')\n         LTR   R15,R15               REL IT?\n         BNZ   LOCKFAIL              NO.\n         WTO   'MODREP-SQA CRITICAL, REQUEST ABORTED',ROUTCDE=(2)\n         B     WTOR                  GO WAIT\n         SPACE 3\nCSAFAIL DS     0H\n         SPACE 3\n         SETLOCK RELEASE,TYPE=SALLOC,REGS=USE,RELATED=('SET2')\n         LTR   R15,R15               REL IT?\n         BNZ   LOCKFAIL              NO.\n         WTO   'MODREP-RESPONSE LOST-REENTER',ROUTCDE=(2)\n         B     WTOR                  GO WAIT\n         SPACE 3\nDUPFAIL DS     0H\n         SPACE 3\n         WTO   'MODREP-ALREADY LOADED, IGNORED',ROUTCDE=(2)\n         B     WTOR                  GO WAIT\n         SPACE 3\nSLOTERR  DS    0H\n         SPACE 3\n         WTO   'MODREP-SLOT TABLE OVERFLOW',ROUTCDE=(2)\n         B     WTOR                  GO WAIT\n         SPACE 3\nOPENFAIL DS    0H\n         SPACE 3\n         WTO   'MODREP-PDS OPEN FAILED',ROUTCDE=(2)\n         B     KEEP                  JUST QUIT\n         SPACE 3\nCDEERROR DS    0H\n         SPACE 3\n         WTO   'MODREP-INTERNAL CDE CHAIN ERROR',ROUTCDE=(2)\n         ABEND 100,DUMP              SHOW IT\n         SPACE 3\nLLEERROR DS    0H\n         SPACE 3\n         WTO   'MODREP-INTERNAL LLE CHAIN ERROR',ROUTCDE=(2)\n         ABEND 200,DUMP              SHOW IT\n         SPACE 3\nDISPLAY  DS    0H                    DISPLAY MODULES I'M CONTROLLING\n         SPACE 3\n         MVI   ENTRIES,X'00'         ASSUME NOTHING LOADED\n         L     R2,=A(NAMTABLE)       LOADED NAME TABLE            *ARB*\n         SPACE 3\nDLOOP    DS    0H\n         SPACE 3\n         CLI   0(R2),X'00'           SLOT IN USE?\n         BNE   DOWTO                 YES.\n         LA    R2,32(,R2)            NO. BUMP\n         CLI   0(R2),X'FF'           EOT?\n         BNE   DLOOP                 NO.\n         CLI   ENTRIES,X'FF'         ANYTHING DISPLAYED?\n         BE    WTOR                  YES. GO WAIT\n         WTO   'MODREP-NO MODS IN USE',ROUTCDE=(2)\n         B     WTOR                  NO. NOW GO WAIT\n         SPACE 3\nDOWTO    DS    0H\n         SPACE 3\n         OI    ENTRIES,X'FF'         AT LEAST ONE LOADED MOD\n         MVC   EPWTO+15(8),0(R2)     NAME OF MOD\n         LA     7,DWORD              TO\n         LA     8,20(R2)             FROM\n         LA     9,L'FWORD            LENGTH OF FROM\n         CONVERT (7,8,9)             HEX TO EBCDIC\n         MVC   EPWTO+27(6),DWORD+2   EPA\nEPWTO    WTO   'MODREP-XXXXXXXX EP XXXXXX',ROUTCDE=(2)\n         LA    R2,32(,R2)            NEXT ENTRY\n         B     DLOOP                 KEEP LOOKING\n         EJECT\n         TITLE  'MODREP CONSTANTS/DSECTS SECTION'\n*********************************************************************\n*      CONSTANTS, VARIABLES, PATCH AREA, ETC.                       *\n*********************************************************************\n         SPACE 3\nSAVE     DS    19F                     SAVE\nCOMM     DS    A                                                YCC JSA\n         SPACE 3\nDCB      DCB   DDNAME=MODREP,DSORG=PO,MACRF=(R)\n         SPACE 3\n         DS   0D                       , ALIGNMENT\nBLDLIST  DC   H'1'                     ONE ENTRY\nLISTLEN  DC   H'58'                    OF 58 BYTES\nMEMNAME  DC   C'????????'              REQUESTED MEMBER NAME\nDEINFO   DC   BL58'0'                  FOR LOAD DE\nSAVECDE  DS   F                        SAVE REP MOD'S CDE\nSAVEXTL  DS   F                        SAVE REP MOD'S XTLST\nSAVEGET  DS   F                        SAVE GETMAIN FOR CDE/XTLST\nSAVESQA  DS   F                        SQA AREA OF ALTERNAME FETCH EPA\nECBAD    DC   F'0'                     WTOR ECB\nWORK     DC   F'0'                     SCRATCH PAD\nFWORD    DC   F'0'                     SCRATCH PAD\nDWORD    DC   D'0'                     SCRATCH PAD\nREPLY    DC   CL8' '                   WTOR REPLY\nSVCNAME  DC   CL8' '                   SCRATCH PAD\nSVCENLEN DC   PL1'8'                   SVC TABLE ENTRY LENGTH\nENTRIES  DC   X'00'                    X'FF'=A MOD IS LOADED\n         EJECT\n         DS   0F                       , FOR STORE/LOAD\n         SPACE 2\n*********************************************************************\n*        BYTES 0-7   = NAME OF MODULE OR SVC THAT IS LOADED         *\n*        BYTES 8-15  = ORIGINAL SVC TABLE ENTRY IF SVC, ZEROS IF    *\n*                      TRUE NAME OF A MODULE, ELSE EBCDIC WORD      *\n*                      \"ALIAS   \" IF ALIAS OF A TRUE NAME           *\n*        BYTES 16-19 = ORIGINAL SVC TABLE ENTRY ADDRESS IF SVC,     *\n*                      ELSE ZEROS                                   *\n*        BYTES 20-23 = MODULE/SVC EPA                               *\n*        BYTES 24-27 = MSBA FROM XTLST IF SVC, ELSE ZEROS           *\n*        BYTES 28-31 = XLEN FROM XTLST IF SVC, ELSE ZEROS           *\n*********************************************************************\n         EJECT\n*********************************************************************\n*        ALTERNATE FETCH EPA, RELOCATABLE, DUAL ADDRESSABILITY      *\n*********************************************************************\n         SPACE 3\n         DS    0F                         , ALIGN\n         USING *,R15\n         SPACE 3\nFETCHPAT L    R1,X'10'                    CVT\n         L    R1,0(R1)                    N/O\n         L    R1,4(,R1)                   TCB\n         LTR  R1,R1                       SRB?\n         BZ   BYPASS                      NO.\n         L    R1,12(R1)                   TIOT\n         LTR  R1,R1                       ANY?\n         BZ   BYPASS                      NO.\n         CLC  0(16,R1),TIOT               MY TIOT?\n         BNE  BYPASS                      NO.\n         LA   R10,228                     YES. SP228\n         SPACE 3\nBYPASS   DS   0H\n         SPACE 3\n         L    R15,RFETCHEP                FETCH EP\n         BR   R15                         HIDE\n         SPACE 3\nTIOT     DC    C'MODREP  ',X'FF',CL7'NORM'   SELF-ALTERED JOB/STEP\nMFETCHEP DC    F'0'                       FETCH ALTERED EP S.A.\nRFETCHEP DC    F'0'                       FETCH UNALTERED EP S.A.\nAFETCHEP DC    F'0'                       FETCH B.E. POINTER CVT\n         DC    F'0'                       RESERVED\nLENGTH   EQU   *-FETCHPAT                 LENGTH OF PATCH\n         DROP  R15                        , DROP PATCH ADDRESSABILITY\n         EJECT\n         SPACE 3\n         LTORG\nNAMTABLE DC   99BL32'0',XL1'FF'        ALLOW NINETY-NINE LOADS    *ARB*\n         EJECT\n*********************************************************************\n*DSECT MAPPING MACROS FOR USE BY SETLOCK AND BRANCH ENTRY TO GETMAIN*\n*********************************************************************\n         SPACE 3\n         PRINT NOGEN                                            YCC JSA\n         IHAWSAVT     DSECT=YES,CLASS=GLOBAL\n         IHAPSA       DSECT=YES\n         CVT          DSECT=YES\n         SPACE 3\n         PRINT NOGEN\n         DCBD  DSORG=PO,DEVD=DA\n         SPACE 3\nCIB      DSECT ,                                                YCC JSA\n         IEZCIB ,                                               YCC JSA\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PARSE@": {"ttr": 7433, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "1\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n0     TSU System Aids Reference Manual                              Page 1.1\n      Assembler Language Interfaces\n1\n0     IKJPARS EXTENSIONS\n+     IKJPARS EXTENSIONS\n+     _______ __________\n0     The TSU System  Aids completely replaces the  IKJPARS service routine.\n      The TSU  routine is friendlier,  and  implements all the  functions of\n      this routine as documented in the hilariously named Guide to Writing a\n+                                                         _____ __ _______ _\n      TMP (as well as a number of undocumented ones).\n+     ___\n0     One  improvement which  has  been found  to  be a  problem  for a  few\n      commands is as follows:  IKJPARS permits an operand to be defined as a\n      range (e.g.,   the subfield of the  COL keyword of the  LIST command).\n      The standard  IKJPARS calls the validity  check exit once for  such an\n      item,  regardless of  whether it is a  single item or a  range.   This\n      means that if either element of a range is invalid,  the terminal user\n      is forced to reenter both parts.    The TSU IKJPARS calls the validity\n      check exit three times for a range,  once for each part,  and once for\n      the entire  range,  allowing the  exit to reject  only that part  of a\n      range which is invalid.  This can cause problems if different criteria\n      apply to  the two parts  of a range.   Also,   if the exit  counts the\n      number of  times it is  called to determine the  number of items  in a\n      list,  the results  will be incorrect.   This procedure  is not appro-\n      priate even when the IBM IKJPARS is  used,  since it will also compute\n      an incorrect number  of elements for a  list which is a  subfield of a\n      keyword which appears twice on the command line.\n0     The TSU version of IKJPARS provides  a major new function which allows\n      a caller to define  new types of operands.   To use  this facility,  a\n      command with  one or more  operands with  unusual syntax can  take the\n      following steps:\n0        \u00ae Use the TSU  IKJEXTEN macro to describe each  such operand.   The\n           macro will  include the address  of a caller-supplied  routine to\n           recognize and validate the operand.\n0        \u00ae Write a recognizer routine for  each special operand type (analo-\n           gous  to  writing  a  PL/I   recognizer  routine  using  the  TSU\n           Programmer Aids).   This routine can inspect an input value,  and\n           determine whether the value is  correct or incorrect,  or whether\n           the operand is missing;  if a valid value is present,  the recog-\n           nizer should also store information about  the parameter in a PDE\n           (passed by  IKJPARS)  to  be used  by the  calling command  after\n           parsing is complete.    Note that IKJPARS handles  the issuing of\n           any required diagnostic messages or prompts,  but that the recog-\n           nizer may supply a second-level message to be associated with the\n           standard IKJPARS \"invalid operand\" message.\n-\n      The IKJEXTEN Macro\n+     The IKJEXTEN Macro\n+     ___ ________ _____\n0     The IKJEXTEN macro  is used to describe a positional  parameter with a\n+         IKJEXTEN\n      programmer-defined syntax.  The syntax of IKJEXTEN is as follows:\n-\n-\n-\n-\n-\n-\n-\n-\n-     June 23, 1984                                                Chapter 1\n-\n-\n      TSU System Aids Reference Manual                              Page 1.2\n      Assembler Language Interfaces\n1\n0          \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n           |  IKJEXTEN  |\n           |\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n+          \u00bf            \u00bf               \u00af\n           |                            |                             |\n           |  OPERANDS                  |    NOTES                    |\n           |                            |                             |\n           |\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\n+          \u00bf                            \u00bf                             ]\n           |                                                          |\n           |  \u00d0\u00d0\u00d7                                                     |\n           |      'parameter type',                                   |\n+             ||\n           |  \u00bf\u00bf\u00d7                                                     |\n           |                                                          |\n           |  \u00d0\u00d0\u00d7                                                     |\n           |      recognizer                                          |\n+             ||\n           |  \u00bf\u00bf\u00d7                                                     |\n           |                                                          |\n           |   \u00d0\u00d7                                                     |\n           |      ,LIST                                               |\n+              |\n           |   \u00bf\u00d7                                                     |\n           |                                                          |\n           |   \u00d0\u00d7                                                     |\n           |      ,RANGE                                              |\n+              |\n           |   \u00bf\u00d7                                                     |\n           |                                                          |\n           |   \u00d0\u00d7                                                     |\n           |      ,UPPERCASE                                          |\n+                  _________\n+              |\n           |      ,ASIS                                               |\n+              |\n           |   \u00bf\u00d7                                                     |\n           |                                                          |\n           |   \u00d0\u00d7                                                     |\n           |      ,PROMPT='prompt-data'                               |\n+              |\n           |      ,DEFAULT='default-data'                             |\n+              |\n           |   \u00bf\u00d7                                                     |\n           |                                                          |\n           |   \u00d0\u00d7                                                     |\n           |      ,VALIDCK=exit-address                               |\n+              |\n           |   \u00bf\u00d7                                                     |\n           |                                                          |\n           |   \u00d0\u00d7                                                     |\n           |      ,HELP=('help-data',...). . . . .at most 9 elements  |\n+              |\n           |   \u00bf\u00d7                                                     |\n           |                                                          |\n           |   \u00d0\u00d7                                                     |\n           |      ,PARM='parameter-data'                              |\n+              |\n           |   \u00bf\u00d7                                                     |\n           |                                                          |\n           \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n0     Note that  the IKJEXTEN  macro requires a  label,  which  is generated\n      within the  PDL DSECT  as the  symbolic address  of the  PDE for  this\n      parameter.\n0     The operands of IKJEXTEN are used as follows:\n0     'parameter-type' - specifies a brief  description of the parameter for\n           use in the IKJPARS \"invalid operand\"  message (which has the form\n           \"INVALID type: data\").\n0     recognizer - specifies the label of  the first statement of the recog-\n           nizer  routine  for  this  parameter.   If  the  routine  is  not\n           contained in the  same assembly as the IKJEXTEN  macro,  an EXTRN\n           statement must be used to define it as external.\n0     LIST - specifies that a parenthesized list  of operands may be entered\n+     LIST\n           for this parameter.   The recognizer will be called once for each\n           list element.\n0     RANGE - specifies that the parameter value may be specified as a range\n+     RANGE\n           (i.e., as two values separated by a colon).   The recognizer will\n           be called once for each part of a range.   If both LIST and RANGE\n           are specified,   each element in the  LIST may be specified  as a\n           range.\n0     UPPERCASE - specifies that the input  parameter is to be translated to\n+     UPPERCASE\n           upper case.\n      ASIS - specifies that the input parameter is not to be translated.\n+     ASIS\n0     June 23, 1984                                                Chapter 1\n-\n-\n      TSU System Aids Reference Manual                              Page 1.3\n      Assembler Language Interfaces\n1\n0     PROMPT='prompt-data' - specifies  that the parameter is  required,  as\n+     PROMPT\n           well as  a description to  be used  when IKJPARS prompts  for it.\n           The message  generated is  of the  form \"ENTER  prompt-data\",  or\n           \"MISSING prompt-data\" if prompting is not permitted.\n      DEFAULT='default-data' - specifies  a default value for  the parameter\n+     DEFAULT\n           if no value is specified by the user.\n0     VALIDCK=exit-address  -  specifies  the address  of  a  validity-check\n+     VALIDCK\n           routine to be called after the  recognizer has accepted the input\n           parameter.\n0     HELP=('help-data',...)  - specifies up to nine \"second-level\" descrip-\n+     HELP\n           tions of the defined parameter.    These descriptions are used to\n           build messages in the  same way as the PROMPT text  when a \"?\" is\n           entered in response to an IKJPARS prompt.\n0     PARM='parameter-data' - specifies  a character string to  be passed to\n+     PARM\n           the recognizer  routine to further  define the  parameter syntax.\n           If no PARM is specified, a zero-length string is passed.\n-\n      Example 1.1:   Define a required parameter  whose syntax is defined by\n           the recognizer  routine RSPACE.    (This recognizer  is shown  in\n           Example 1.2.)\n0          SPACEVAL IKJEXTEN 'SPACE VALUE',RSPACE,                         *\n                          PROMPT='COMPILER SPACE VALUE',                   *\n                          HELP='THE AMOUNT OF SPACE THE COMPILER MAY USE', *\n                          PARM='6'\n-\n      IKJPARS Recognizer Routines\n+     IKJPARS Recognizer Routines\n+     _______ __________ ________\n0     A recognizer routine is called from IKJPARS using standard IBM linkage\n      conventions,  with a pointer to a  parameter list in register 1.   The\n      parameter list consists of seven fullwords, defined as follows:\n0          Word 1 -  Addresses the  eight-byte PDE  in which  data is  to be\n                returned for a correct input parameter.   By convention, the\n                first four bytes contain the address of the parameter value,\n                the next two contain the parameter length,  and the last two\n                contain flags.   However,  the PDE may be used by the recog-\n                nizer in any other manner desired,   save that bit 1 (X'80')\n                of the seventh byte of the PDE must be turned on if a param-\n                eter has been recognized.  The PDE is zeroed before entry to\n                a recognizer.\n0          Word 2 - Contains the \"user  work area\" pointer originally passed\n                to IKJPARS in word 7 of the PPL.\n0          Word 3 - A word which may be  changed to address an error message\n                to be used  as a second-level message  to IKJPARS's standard\n                \"invalid parameter\" message.   The message should be defined\n                in standard PUTLINE format.\n0          Word 4  -  Addresses a  buffer  which  includes  the text  to  be\n                processed by the recognizer.  This buffer is not necessarily\n                the original command  buffer.   The first two  bytes contain\n                the buffer length and the next  two bytes contain the offset\n                of the text to be analyzed,  starting from the fifth byte of\n                the buffer.   If the addressed text is accepted, or rejected\n                as invalid for the parameter,  the offset in the buffer must\n                be  updated  to address  the  point  after the  accepted  or\n                rejected  value.   If  the  parameter  is to  be  considered\n                missing (e.g.,  if the first character of the value is inap-\n                propriate), the offset should not be changed.   Note that it\n                is  permissible to  translate text  in the  buffer to  upper\n                case, but that other modifications should be avoided.\n0          Word 5 - Addresses  the string specified by  the programmer using\n                the PARM keyword of the IKJEXTEN macro.  The first two bytes\n                contain the number of characters in the string.\n-\n      June 23, 1984                                                Chapter 1\n-\n-\n      TSU System Aids Reference Manual                              Page 1.4\n      Assembler Language Interfaces\n1\n0          Word 6 - If UPPERCASE was specified  or defaulted on the IKJEXTEN\n                macro,  this word points to  an uppercase translation table.\n                If ASIS was specified, this word contains zero.\n0          Word 7 - Addresses  a routine to get storage  for return informa-\n                tion.   This storage is linked  with other storage allocated\n                by IKJPARS,   so that it will  be freed when  the programmer\n                issues IKJRLSA.   When the get routine is called, register 1\n                should contain  the number  of bytes  required;  on  return,\n                register 1 will address the allocated storage.  Note that if\n                storage  is unavailable  when  the  get routine  is  called,\n                IKJPARS will terminate with return code 16 without returning\n                to the recognizer.   Also note that this routine ignores the\n                contents of register 13,  so it is not necessary to define a\n                new save area before a call.\n0          After determining whether the input  parameter value is valid,  a\n           recognizer should  return to IKJPARS,   passing a return  code in\n           register 15.  Valid return codes are as follows:\n0           0:  Indicates  successful  recognition.    When   this  code  is\n+           0:\n                returned, the recognizer should have stored parameter infor-\n                mation into the PDE,  updated the text offset in the buffer,\n                and possibly translated the parameter value to upper case.\n0           4:  Indicates that  the text was  not recognized,  and  that the\n+           4:\n                parameter value should be regarded as missing.  This code is\n                normally returned when  the first character of  the value is\n                inappropriate.   When this code is returned, neither the PDE\n                nor the text buffer should be changed.\n0           8:  Indicates that the text was  not recognized,  and that PARSE\n+           8:\n                should  issue an  error  message and  prompt  for a  correct\n                value.   When this code is  returned,  the recognizer should\n                have updated  the text  offset and  may have  translated the\n                parameter value to  upper case and/or stored  a second-level\n                message address.   It  should not have stored  into the PDE,\n                nor issued a message itself.\n0     Any other return code is invalid,  and will cause IKJPARS to terminate\n      with return code 12.\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n      June 23, 1984                                                Chapter 1\n-\n-\n      TSU System Aids Reference Manual                              Page 1.5\n      Assembler Language Interfaces\n1\n0     Example  1.2:   The  following is  a complete  recognizer designed  to\n           recognize a compiler space parameter,  that is,  an item with the\n           syntax \u00dd-\u00a8n...\u00ddK\u00a8.   The  PARM passed from the  IKJEXTEN macro is\n           assumed to  be a  single character giving  the maximum  number of\n           digits allowed (8 if omitted).  If the input value does not begin\n           with a minus sign or digit, the parameter is regarded as missing.\n           If recognition is successful,  the  returned PDE will contain the\n           following:\n0               Bytes 0-3:   The address of a  string of digits (without a K\n                     or minus sign).   If the  original input contained a K,\n                     the K will be removed and replaced by 000.\n                Bytes 4-5:  The length of the string addresses by bytes 0-3.\n                Byte 6:  A  flag byte.    The X'80'  bit indicates  that the\n                     parameter was present, and the X'40' bit indicates that\n                     a minus sign was present.\u00a3\n0          *        REGISTER USAGE FOR THE EXAMPLE IS:\n           *              R14-R2        WORK REGISTERS\n           *              R3            INPUT BUFFER END ADDRESS\n           *              R4            CURRENT TEXT CHARACTER POINTER\n           *              R5            INPUT BUFFER POINTER\n           *              R6            MAXIMUM VALUE LENGTH\n           *              R7            PDE ADDRESS\n           *              R8            ADDRESS OF GETMAIN ROUTINE\n           *                            (ALSO WORK REGISTER)\n           *              R9            WORK LENGTH REGISTER\n           *              R10           WORK PARM END POINTER\n           *              R11           PARM LIST POINTER\n           *              R12           BASE REGISTER\n           *\n           RSPACE   STM   R14,R12,12(R13)    SAVE REGISTERS\n                    LR    R12,R15            SET UP BASE REG\n                    USING RSPACE,R12\n                    LR    R11,R1             SAVE PARM PTR\n                    LM    R2,R8,0(R1)        LOAD PARM ADDRESSES\n                    LR    R7,R2              SAVE PDE ADDR OVER TRT'S\n                    LA    R4,4(,R5)          SKIP OVER BUFFER HEADER\n                    AH    R4,2(,R5)          POINT TO FIRST TEXT CHAR\n                    CLI   0(R4),C'-'         START WITH MINUS?\n                    BE    MINUS\n                    CLI   0(R4),C'0'         START WITH DIGIT?\n                    BL    MISSING            NO, PARM IS MISSING\n                    CLI   0(R4),C'9'\n                    BNH   TRYSPACE\n0          MISSING  LM    R14,R12,12(R13)    RESTORE REGS\n                    LA    R15,4              SAY NO SPACE VALUE THERE\n                    BR    R14\n0          MINUS    OI    6(R7),X'40'        SET PDE MINUS FLAG\n                    LA    R4,1(,R4)          SKIP OVER MINUS SIGN\n0          TRYSPACE LR    R3,R5              FIND END OF INPUT BUFFER\n                    AH    R3,0(,R3)\n                    CLC   0(2,R6),=H'0'      DID IKJEXTEN SPECIFY PARM?\n                    BE    DEFLEN             NO, USE DEFAULT OF 8\n                    IC    R6,2(,R6)          YES, LOAD DIGIT\n                    N     R6,=F'15'          TURN OFF WORTHLESS BITS\n                    B     SCANIT\n0          DEFLEN   LA    R6,8               LOAD DEFAULT MAX LENGTH\n-\n-\n      \u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\n-     \u00a3 This is not a good design for  this recognizer.   It would be better\n        to have another bit defined to mean  \"K present\",  or to convert the\n        entire  value to  binary  and  store that  in  place  of the  string\n        address.   The above design was chosen  to allow illustration of the\n        use of the IKJPARS get routine.\n0     June 23, 1984                                                Chapter 1\n-\n-\n      TSU System Aids Reference Manual                              Page 1.6\n      Assembler Language Interfaces\n1\n0          SCANIT   LR    R9,R3\n                    SR    R9,R4              COMPUTE REMAINING TEXT LENGTH\n                    BCTR  R9,0               -1 FOR EX\n                    CH    R9,=H'255'         REMAINDER VERY LONG?\n                    BNH   SHORTEXT           NO.\n                    LA    R9,255             YES, LOOK AT ONLY 256 CHARS\n           SHORTEXT LA    R1,1(R4,R9)        PRELOAD END OF TEXT ADDR IN R1\n                    EX    R9,FINDEND         LOOK FOR A NON-ALPHMERIC CHAR\n                    BCTR  R1,0               POINT TO LAST ALPHAMERIC\n                    LR    R10,R1             SAVE POINTER IN R10\n                    LR    R9,R1\n                    SR    R9,R4              GET VALUE LENGTH IN R9\n                    BZ    LASTDIG            BR IF ONLY ONE DIGIT\n                    BM    INVALID            ERROR IF LONELY MINUS\n                    BCTR  R9,0               -1 FOR EX\n                    EX    R9,CHEKDIG         MAKE SURE ALL CHARS BUT LAST\n                    BNZ   INVALID            ARE DIGITS\n                    LA    R9,1(,R9)          GET BACK LENGTH-1\n                    CLI   0(R10),C'K'        IS LAST CHAR A K?\n                    BE    GOTK\n                    CLI   0(R10),C'k'        ALSO ALLOW LOWER CASE K\n                    BE    GOTK\n0          LASTDIG  CLI   0(R10),C'0'        MAKE SURE LAST (OR ONLY) CHAR\n                    BL    INVALID            IS A DIGIT\n                    CLI   0(R10),C'9'\n                    BH    INVALID\n                    LA    R9,1(,R9)          GET BACK LENGTH IN R9\n                    CR    R9,R6              COMPARE TO MAX\n                    BNH   GOODSPEC           BR IF NOT TOO LONG\n0          TOOBIG   MVC   8(4,R11),=A(BIGMSG) STORE 2ND LEVEL MSG ADDR\n0          INVALID  XC    0(8,R7),0(R7)      RESTORE PDE TO ZEROES\n                    LA    R4,3(,R5)          FIND TEXT START-1\n                    SR    R10,R4             COMPUTE NEW OFFSET\n                    STH   R10,2(,R5)         STORE NEW OFFSET\n                    LM    R14,R12,12(R13)    RESTORE REGS\n                    LA    R15,8              INDICATE INVALID PARM\n                    BR    R14                AND RETURN\n0          GOODSPC  ST    R4,0(,R7)          STORE STRING ADDR IN PDE\n                    STH   R9,4(,R7)          STORE NUMBER OF DIGITS\n           RETSPC   OI    6(R7),X'80'        SET PDE PRESENCE BIT\n                    LA    R4,3(,R5)          COMPUTE NEW OFFSET\n                    SR    R10,R4\n                    STH   R10,2(,R5)         STORE BACK IN BUFFER\n                    LM    R14,R12,12(R13)    RESTORE REGS\n                    SR    R15,R15            SET GOOD RET CODE\n                    BR    R14                AND RETURN\n0          GOTK     LR    R3,R9              SAVE VALUE LENGTH-1\n                    LA    R9,3(,R9)          COMPUTE LENGTH TO RETURN\n                    CR    R9,R6              IS THAT TOO BIG?\n                    BH    TOOBIG             YES.\n                    LR    R1,R9              NO, GET SOME MEMORY FOR\n                    LR    R15,R8             AN EXPANDED VALUE\n                    BALR  R14,R15            BY CALLING IKJPARS GET ROUTINE\n                    LR    R8,R1              SAVE STORAGE ADDRESS\n                    BCTR  R3,0               DON'T COPY THE K\n                    EX    R3,MVSPC           MOVE DIGITS TO NEW STORAGE\n                    LA    R3,1(R3,R8)        POINT TO NEXT BYTE\n                    MVC   0(3,R3),=C'000'    PUT THREE ZEROES AFTER\n                    ST    R8,0(,R7)          RETURN VALUE PTR IN PDE\n                    STH   R9,4(,R7)          RETURN NEW LENGTH\n                    B     RETSPC             AND RETURN HAPPILY\n-\n-\n-\n-     June 23, 1984                                                Chapter 1\n-\n-\n      TSU System Aids Reference Manual                              Page 1.7\n      Assembler Language Interfaces\n1\n0          *              EXECUTED INSTRUCTIONS\n           FINDEND  TRT   0(0,R4),ANUMTAB    SCAN THRU ALPHAMERICS\n           CHEKDIG  TRT   0(0,R4),NUMTAB     SCAN THRU NUMERICS\n           MVSPC    MVC   0(0,R8),0(R4)      MOVE DIGITS TO NEW STORAGE\n0                   LTORG\n0          BIGMSG   DC    AL2(BIGEND-BIGMSG,0)\n                    DC    C' VALUE HAS TOO MANY DIGITS'\n           BIGEND   EQU   *\n0          NUMTAB   DC    240X'01',10X'00',6X'01' NUMERIC TRT TABLE\n0          ANUMTAB  DC    129X'01',9X'00',7X'01' ALPHANUMERIC TRT TABLE\n                    DC    9X'00',8X'01',8X'00',23X'01'\n                    DC    9X'00',7X'01',9X'00',8X'01'\n                    DC    8X'00',6X'01',10X'00',6X'01'\n                    END\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-     June 23, 1984                                                Chapter 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PLIDSA": {"ttr": 7688, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         PLIDSA\nOFF0     EQU   0        OFFSET OF FIRST DSA FLAG BYTE\nCDSA     EQU   X'80'    DSA FLAG\nCONB     EQU   X'08'    LIBRARY DSA FLAG\nOFF1     EQU   1        OFFSET OF SECOND DSA FLAG BYTE\nCGTO     EQU   X'08'    EXIT DSA (INTERCEPT GO TO)\nOFLW     EQU   72       LIBRARY WORK SPACE POINTER\nOFNB     EQU   76       NEXT AVAILABLE BYTE POINTER\nOFXQ     EQU   81       EXIT DSA NUMBER\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PLIONCB": {"ttr": 7690, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         PLIONCB\nONCB     DSECT ,                  PL/I ONCB MAPPING\n         SPACE\nLSCD     DS    XL1                PL/I CONDITION ID\nLSFG     DS    XL1                PL/I ON UNIT FLAGS\nLSF2     EQU   X'20'              ON UNIT IS A GOTO\n         DS    XL2\nLSTR     DS    A                  ADDR OF ON-UNIT OR LABEL\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PLITCA": {"ttr": 7692, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         PLITCA\nTCA      DSECT ,        PL/I TCA (ADDRESSED BY R12)\n         SPACE\nTFB0     EQU   TCA      FIRST FLAG BYTE\nTTCK     EQU   X'20'    CHECKOUT COMPILER ENVIRONMENT\nTTFC     EQU   X'04'    CICS ENVIRONMENT (USED BY LIE TO INDICATE      *\n                        ASSEMBLER PSEUDO-PL/I ENVIRONMENT)\nTFB1     EQU   TCA+1    SECOND FLAG BYTE\nTGFS     EQU   X'10'    PLISORT ACTIVE (INHIBIT GOTO OUT OF BLOCK)\nTPRV     EQU   TCA+4    PSEUDO-REGISTER VECTOR POINTER\nTEOS     EQU   TCA+12   END OF CURRENT STORAGE SEGMENT\nTOVV     EQU   TCA+72   VDA STORAGE OVERFLOW ROUTINE\nTGET     EQU   TCA+108  NON-LIFO STORAGE GET ROUTINE\nTFRE     EQU   TCA+112  NON-LIFO STORAGE FREE ROUTINE\nTOVF     EQU   TCA+116  DSA STORAGE OVERFLOW ROUTINE\nTERR     EQU   TCA+120  PL/I ERROR HANDLER ADDRESS\nTGTC     EQU   TCA+128  GOTO OUT OF BLOCK CODE\nTUSR     EQU   TCA+X'11C'    TCA USER FIELD\nTATP     EQU   TCA+X'120'    OPTIMIZER ATTN POLL ROUTINE ADDR\nTGAR     EQU   TCA+X'190'    CHECKER GETMAIN ASSURANCE ROUTINE\nTFRR     EQU   TCA+X'194'    CHECKER FREEMAIN RECOVERY ROUTINE\nZCTLB1   EQU   TCA+X'AD6'    CHECKER FLAGS\nZATTN    EQU   X'10'    CHECKER ATTN PENDING\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PRINTPD$": {"ttr": 7694, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//PRINTPDS PROC DSN=NULLFILE,FORMS=,TRAIN=,CTAPE=,LINECT=,VER=\n//*********************************************************************\n//* PRINTPDS: PROC FOR PRINTING PARTITIONED DATA SETS               ***\n//* SEE ICSA DOCUMENT UTL019                                        ***\n//*                                                   10/23/80 ARB  ***\n//*********************************************************************\n//PRINT    EXEC  PGM=UEBPDSPT,REGION=192K,PARM='&LINECT'\n//STEPLIB  DD  DSN=RICEPP&VER..LINKLIB,DISP=SHR\n//SYSPRINT DD  SYSOUT=A\n//SYSLIB   DD  DSN=&DSN,DISP=SHR\n//SYSTOC   DD  SYSOUT=(A,,&FORMS),UCS=&TRAIN,FCB=&CTAPE\n//SYSOUT   DD  SYSOUT=(A,,&FORMS),UCS=&TRAIN,FCB=&CTAPE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCB02A1": {"ttr": 7696, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "++USERMOD (RCB02A1)\n  /* ICSA RESERVED SPACE IN THE $HCT MACRO        */.\n++VER (Z038) FMID(EJE1102).\n++MACUPD ($HCT) PREFIX(HASP) ASSEM(JTIPSVC,VERFYQEL).\n./ CHANGE NAME=$HCT\nHCTICSA  DS    XL32          ICSA RESERVED SPACE                RCB02A1 DT468000\n#IHCTEND EQU   *             END OF ICSA SECTION                RCB02A1 DT468010\n         COPY  #ICSAHCT      GET ICSA HCT UPDATES               RCB02A1 DT468020\n++MAC (#ICSAHCT) PREFIX(HASP) ASSEM(JTIPSVC,VERFYQEL)\n                DISTLIB(RICEHSRC).\n         ORG   HCTICSA                 START AT BEGINNING       RCB02A1\n         DS    0CL(1+#IHCTEND-*)       LENGTH CHECK             RCB02A1\n         ORG   #IHCTEND                FIX LOCATION             RCB02A1\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCB05A1": {"ttr": 7698, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "++USERMOD (RCB05A1)\n  /* ICSA RESERVED SPACE IN THE $COMWORK MACRO    */.\n++VER (Z038) FMID(EJE1102).\n++MACUPD ($COMWORK) ASSEM(HASPCOMM,HASPDOC).\n./ CHANGE NAME=$COMWORK\nCOMICSA  DS    CL16          ICSA RESERVED SPACE                RCB05A1 B1161010\n#ICOMEND EQU   *             END OF ICSA SECTION                RCB05A1 B1161020\n         COPY  #ICSACOM      COPY ICSA UPDATES                  RCB05A1 B1161030\n++MAC (#ICSACOM) ASSEM(HASPCOMM,HASPDOC)\n                 DISTLIB(RICEHSRC).\n         ORG   COMICSA             START AT BEGINNING           RCB05A1\n         DS    0CL(1+#ICOMEND-*)   LENGTH CHECK                 RCB05A1\n         ORG   #ICOMEND            FIX LOCATION                 RCB05A1\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCB06A1": {"ttr": 7700, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "++USERMOD (RCB06A1)\n  /* ICSA RESERVED SPACE IN THE $SJB MACRO    */.\n++VER (Z038) FMID(EJE1102).\n++MACUPD ($SJB) PREFIX(HASP) .\n./ CHANGE NAME=$SJB\nSJBICSA  DS    CL128         ICSA RESERVED SPACE                RCB06A1 G9239000\n#ISJBEND EQU   *             END OF ICSA SECTION                RCB06A1 G9239010\n         COPY  #ICSASJB      COPY ICSA UPDATES                  RCB06A1 G9239020\n++MAC (#ICSASJB) PREFIX(HASP)\n                 DISTLIB(RICEHSRC).\n         ORG   SJBICSA            START AT BEGINNING            RCB06A1\n         DS    0CL(1+#ISJBEND-*)  LENGTH CHECK                  RCB06A1\n         ORG   #ISJBEND           FIX LOCATION                  RCB06A1\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCB07A1": {"ttr": 7702, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "++USERMOD (RCB07A1)\n   /* ICSA RESERVED SPACE IN PPPWORK */.\n++VER (Z038) FMID(EJE1102).\n++MACUPD ($PPPWORK) ASSEM(HASPPRPU,HASPDOC).\n./ CHANGE NAME=$PPPWORK\nPPPWICSA DS    CL64          ICSA RESERVED SPACE                RCB07A1 FZ245500\n#IPPWEND EQU   *             END OF ICSA SECTION                RCB07A1 FZ245510\n         COPY  #ICSAPPW      GET ICSA PPWORK UPDATES            RCB07A1 FZ245520\n++MAC (#ICSAPPW) ASSEM(HASPPRPU,HASPDOC) DISTLIB(RICEHSRC).\n         ORG   PPPWICSA      START AT BEGINNING                 RCB07A1\n         DS    0CL(1+#IPPWEND-*)  LENGTH CHECK                  RCB07A1\n         ORG   #IPPWEND      FIX LOCATION                       RCB07A1\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RDA01U1": {"ttr": 7704, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "++USERMOD(RDA01U1)\n   /* ICSA HASPXEQ MODIFICATION TO RESPOND ADD ABEND\n      CODE TO CONVERTER ABEND MESSAGE.  ASSUMES ONLY\n      SYSTEM ABEND CODES PRODUCED.                           */.\n++VER(Z038) FMID(EJE1102)\n             PRE(AZ36864,AZ29021                            /* IBM  */).\n++SRCUPD(HASPXEQ).\n./ CHANGE NAME=HASPXEQ\n         L     XL1,=A(XJSSNAME)    MOVE SUBSYSTEM NAME TO DSNAMERDA01U1 U1602000\n         MVC   0(4,XL1),$SVSSNM    (ADDRESSABILITY CHANGE)      RDA01U1 U1602100\n         STCM  R1,B'0110',XABNDCDE SAVE POSSIBLE ABEND CODE     RDA01U1 U2067610\n         BE    XCNVNSDW            DON'T USE SDWS FIELDS        RDA01U1 U2068000\n         MVC   XABNDCDE,SDWAABCC+1-SDWA(R1)   GET SYSTM ABND CDERDA01U1 U2068010\nXCNVNSDW LR    R4,LINK             SAVE ESTAE RETURN ADDRESS    RDA01U1 U2068400\n         OI    XABNDCDE+1,X'0F'    CONVERT                      RDA01U1 U2068610\n         UNPK  XABNDWRK(3),XABNDCDE(2) INTO                     RDA01U1 U2068620\n         TR    XABNDWRK(3),$HEXTRAN      HEX                    RDA01U1 U2068630\n         MVC   XABNDMSG+XABNDMSL-7(3),XABNDWRK  MOVE IN MESSAGE RDA01U1 U2068640\nXABNDMSG WTO   '&MID.CONVERSION SUB-TASK ABENDED  - SXXX',      RDA01U1XU2072000\nXABNDCDE DS    XL2                 SPACE FOR SYSTEM ABEND CODE  RDA01U1 U2075010\nXABNDWRK DS    XL3                 WORKAREA FOR HEX CONVERSION  RDA01U1 U2075020\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REGISTER": {"ttr": 7706, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO                                                          0000000\n         REGISTER                                                       0000000\n         LCLA  &N                                                       0000000\n         SPACE                                                          0000000\n*****    REGISTER EQUATES                                               0000000\n         SPACE                                                          0000000\n&N       SETA  0                                                        0000000\n.LOOP    ANOP                                                           0000000\nR&N      EQU   &N                                                       0000000\n         AIF   (&N EQ 15).OUT                                           0000000\n&N       SETA  &N+1                                                     0000000\n         AGO   .LOOP                                                    0000000\n.OUT     ANOP                                                           0000000\n         SPACE                                                          0000000\n         MEND                                                           0000000\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RETURNX": {"ttr": 7938, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   RETURNX &REGS=(14,12),&RC=0\n         GBLC  &SVXSIZE\n         GBLC  &SVXSP\n         LCLA  &A,&I,&M,&N,&BEGIN,&END\n         LCLB  &B,&RG(16)\n&B       SETB  1\n         AIF   (N'&REGS GE 3).RETURNA\n         AIF   ('&REGS' EQ '').RETURNB\n         AIF   (T'&REGS(1) EQ 'N').RETURNB\n.RETURNA ANOP\n&B       SETB  0\n         MNOTE 4,'*** INVALID REGS PARAMETER ***'\n.RETURNB ANOP\n         AIF   (&B).RETURND\n         MEXIT\n.RETURND ANOP\n         AIF   ('&RC'(1,1) NE '(').ENDL1\n&N       SETA  N'&RC\n&I       SETA  1\n.LOOP1   AIF   (&I GT &N).ENDL1\n         AIF   (T'&RC(&I) NE 'N').RCERROR\n         AIF   ('&RC(&I)' EQ '13').RCERROR\n&A       SETA  &RC(&I)\n&RG(&A+1) SETB 1\n.K4      ANOP\n&I       SETA  &I+1\n         AGO   .LOOP1\n.RCERROR MNOTE 4,'*** INVALID RC ELEMENT - IGNORED ***'\n         AGO   .K4\n.ENDL1   ANOP\n&LABEL   DS    0H\n         AIF   ('&SVXSIZE' EQ '-1').K1\n         AIF   ('&SVXSIZE' EQ '0').K2\n         LR    14,13                                           *AB81125\n.K2      L     13,4(,13)\n.K1      ANOP\n.* HANDLE RC STORES INTO OLD SAVE AREA *.\n&I       SETA  15\n&N       SETA  16\n&BEGIN   SETA  0-1\n&END     SETA  0-1\n.LOOP2   AIF   (&I GT &N).ENDL2A\n&M       SETA  &I-1\n         AIF   (&RG(&I)).ADDR1\n.GENR1   AIF   (&BEGIN EQ 0-1).NEXTL2\n.K12     AIF   (&BEGIN EQ &END).GENR2\n.GENR3   ANOP\n         STM   &BEGIN,&END,&A.(13) .      STORE RETURN CODES INTO SA\n         AGO   .GENR4\n.GENR2   ANOP\n         ST    &BEGIN,&A.(,13) .          STORE RETURN CODE INTO SA\n.GENR4   ANOP\n&BEGIN   SETA  0-1\n&END     SETA  0-1\n         AGO   .NEXTL2\n.ADDR1   AIF   (&BEGIN NE 0-1).ADDR2\n&BEGIN   SETA  &M\n&END     SETA  &M\n&A       SETA  &M*4+20\n         AIF   (&A LE 75).NEXTL2\n&A       SETA  &A-64\n         AGO   .NEXTL2\n.ADDR2   ANOP\n&END     SETA  &M\n.NEXTL2  ANOP\n&I       SETA  &I+1\n         AGO   .LOOP2\n.ENDL2A  AIF   (&I LT 16).ENDL2B\n&I       SETA  1\n&N       SETA  12\n         AGO   .LOOP2\n.ENDL2B  AIF   (&BEGIN NE 0-1).K12\n         AIF   ('&SVXSIZE' EQ '-1').K3\n         AIF   ('&SVXSIZE' EQ '0').K3\n         FREEMAIN R,LV=&SVXSIZE,A=(14),SP=&SVXSP               *AB81125\n.K3      ANOP\n         AIF   ('&REGS' EQ '').RETURNL\n&A       SETA  &REGS(1)*4+20\n         AIF   (&A LE 75).RETURNG\n&A       SETA  &A-64\n.RETURNG ANOP\n         AIF   (N'&REGS EQ 1).RETURNK\n         AIF   (&RG(16)).RETURNZ\n         AGO   .RETURNJ\n.RETURNZ AIF   (&REGS(1) NE 14).RETURNH\n         AIF   (&REGS(2) NE 14).RETURNJ\n         LM    14,15,12(13) .            RESTORE REGS AND RC\n         AGO   .RETURNL\n.RETURNH AIF   (&REGS(1) EQ 15).RETURNJ\n         AIF   (&REGS(1) NE 0).RETURNI\n         LM    15,&REGS(2),16(13) .      RESTORE REGS AND RC\n         AGO   .RETURNL\n.RETURNI ANOP\n         L     15,16(,13) .              RESTORE RC\n.RETURNJ ANOP\n         LM    &REGS(1),&REGS(2),&A.(13) . RESTORE REGISTERS\n         AGO   .RETURNL\n.RETURNK ANOP\n         L     &REGS(1),&A.(,13) .       RESTORE REGISTER\n.RETURNL ANOP\n         MVI   12(13),X'FF' .  SET RETURN INDICATOR\n         AIF   ('&RC' EQ '').RETURNN\n         AIF   ('&RC'(1,1) EQ '(').RETURNN\n         AIF   (&RC EQ 0).RETURNM\n         LA    15,&RC .                  GET RETURN CODE\n         AGO   .RETURNN\n.RETURNM ANOP\n         SLR   15,15 .                   GET RETURN CODE\n.RETURNN ANOP\n         BR    14 .                      RETURN TO CALLER\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RJC12K1": {"ttr": 7941, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "++USERMOD (RJC12K1)\n   /* ICSA MODIFICATION TO HASPCOMM TO ADD TOTAL RECORD COUNTS TO\n      THE $DF COMMAND; ADD $XF FORM TO PROVIDE PSEUDO-$DJ OUTPUT\n      LINES AS WELL FOR EVERY JOB COUNTED IN THE RECORD COUNT, USING\n      ONLY THE RECORDS COUNTED FOR THAT FORM; BREAK THE OUTPUT LINES\n      SO THAT ONLY 1 OUTPUT CLASS IS USED ON A LINE; AND OMIT THE\n      WTR NAME OF (NONE) IF SO.\n\n      LINES K2334750 TO K2334780 CONTAIN CODE WHICH CAN BE USED\n      IF THE JTIP MOD FROM UICC IS ON YOUR SYSTEM.  THIS RECOGNIZES\n      AN ADDITIONAL \"FETCH\" QUEUE.  REMOVE THE COMMENT SYMBOL IF\n      YOU HAVE JTIP.                                           */.\n++VER (Z038) FMID(EJE1102)\n             PRE(AZ29819                                    /* IBM  */\n                 RCB05A1                                    /* ICSA */).\n++MACUPD (#ICSACOM) ASSEM(HASPCOMM,HASPDOC).\n./ CHANGE NAME=#ICSACOM\nCOMIFLG1 DS    BL1                    ICSA COM FLAGS            RJC12K1\n         SPACE 1                                                RJC12K1\nCOMI1X   EQU   B'10000000'            $X( ) COMMAND             RJC12K1\n         SPACE 1                                                RJC12K1\n++SRCUPD (HASPCOMM).\n./ CHANGE NAME=HASPCOMM\n         $COMTAB XF,HASPCJ1A,REDIR=$DF   EXTENDED $DF           RJC12K1 K1721215\nHASPCJ1A $COMGRUP XF,DF,OQ,PQ       MORE JOB QUEUE COMMANDS     RJC12K1 K2209700\n****************************************************************RJC12K1 K2209900\n*                                                              *RJC12K1 K2209905\n*        $ X F - EXTENDED DISPLAY $ D F                        *RJC12K1 K2209910\n*                                                              *RJC12K1 K2209915\n****************************************************************RJC12K1 K2209920\nCXF      OI    COMIFLG1,COMI1X      SET EXTENDED DISPLAY FLAG   RJC12K1 K2209925\n         MVI   COMVERB,C'D'         RESET COMMAND VERB          RJC12K1 K2209930\n*        GET SPACE FOR 100 PARTIAL JQE ENTRIES+RECORD COUNTS    RJC12K1 K2209935\n*        NUMBER OF ENTRIES BASED ON DF MAXIMUM 100 ENTRY LIMIT  RJC12K1 K2209940\nCXFGET   GETMAIN RU,LV=1602,RELATED=(CXFREE,'XF JQE TABLE')     RJC12K1 K2209945\n         ST    R1,CXFJQTBL          SAVE ADDRESS OF TABLE       RJC12K1 K2209950\n         MVI   COMPNTER,CDFRELJ+CDFHOLD MAKE DEFAULT ALL JOBS   RJC12K1 K2214500\n         MVI   CDFIFLG1,0           RESET CHECKLIST FLAGS       RJC12K1 K2216100\n         MVI   CDFSSTUP,C' '        BLANK OUT CHECKLIST AREA    RJC12K1 K2216200\n         MVC   CDFSSTUP+1(L'CDFSSTUP-1),CDFSSTUP                RJC12K1 K2216300\n         L     R0,4(,WD)            POINT TO NEXT OPERAND       RJC12K1 K2218100\n         SR    R0,R1                GET SIZE+1                  RJC12K1 K2218200\n         SH    R0,=H'4'             GET TEXT MACHINE COUNT      RJC12K1 K2218300\n         BM    CDFINVO              INVALID IF NEGATIVE         RJC12K1 K2218400\n         $CFSEL (B,CDFB),(C,CDFC),(D,CDFHA),(F,CDFF),(J,CDFJ),(O,CDFO),XK2218500\n               (Q,CDFQ),(R,CDFR),(T,CDFT),(W,CDFW) SELECT OPRND RJC12K1 K2218600\n         CLI   2(R1),C'R'           THIS DISPLAY RELEASED ONLY? RJC12K1 K2221100\n         BE    CDFNSPEC             EQUIVALENT TO DEFAULT       RJC12K1 K2221200\nCDFB     OI    CDFIFLG1,CDFI1B      SET TO CHECK BURST          RJC12K1 K2235010\n         CH    R0,=H'1'             ONLY Y OR N ALLOWED         RJC12K1 K2235012\n         BNL   CDFINVO              IF LONGER, INVALID          RJC12K1 K2235014\n         CLI   2(R1),C'Y'           WAS 'Y' SPECIFIED?          RJC12K1 K2235020\n         BNE   CDFSETN              NO, TRY FOR 'N'             RJC12K1 K2235030\n         MVI   CDFSB,C'Y'           YES, INSERT INTO CHECKLIST  RJC12K1 K2235040\n         B     CDFNSPEC             AND PROCEED TO NEXT OPERAND RJC12K1 K2235050\nCDFSETN  CLI   2(R1),C'N'           WAS 'N' SPECIFIED?          RJC12K1 K2235060\n         BNE   CDFINVO              NO, INVALID OPERAND         RJC12K1 K2235070\n         MVI   CDFSB,C'N'           YES, INSERT INTO CHECKLIST  RJC12K1 K2235080\n         B     CDFNSPEC             AND PROCEED TO NEXT OPERAND RJC12K1 K2235090\nCDFF     OI    CDFIFLG1,CDFI1F      SET TO CHECK FORMS          RJC12K1 K2235100\n         CH    R0,=H'4'             NAMES ARE 4 CHARS OR LESS   RJC12K1 K2235110\n         BNL   CDFINVO              IF LONGER, INVALID          RJC12K1 K2235120\n         LR    R15,R0               FOR EXECUTE PURPOSES        RJC12K1 K2235125\n         EX    R15,CDFXF            MOVE INTO CHECKLIST         RJC12K1 K2235130\n         B     CDFNSPEC             PROCEED TO NEXT OPERAND     RJC12K1 K2235140\nCDFXF    MVC   CDFSF(*-*),2(R1)     **** EXECUTE ONLY ****      RJC12K1 K2235150\nCDFC     OI    CDFIFLG1,CDFI1C      SET TO CHECK CARRIAGE TAPE  RJC12K1 K2235160\n         CH    R0,=H'4'             NAMES ARE 4 CHARS OR LESS   RJC12K1 K2235170\n         BNL   CDFINVO              IF LONGER, INVALID          RJC12K1 K2235180\n         LR    R15,R0               FOR EXECUTE PURPOSES        RJC12K1 K2235185\n         EX    R15,CDFXC            MOVE INTO CHECKLIST         RJC12K1 K2235190\n         B     CDFNSPEC             PROCEED TO NEXT OPERAND     RJC12K1 K2235200\nCDFXC    MVC   CDFSC(*-*),2(R1)     **** EXECUTE ONLY ****      RJC12K1 K2235210\nCDFT     OI    CDFIFLG1,CDFI1T      SET TO CHECK TRAIN          RJC12K1 K2235220\n         CH    R0,=H'4'             NAMES ARE 4 CHARS OR LESS   RJC12K1 K2235230\n         BNL   CDFINVO              IF LONGER, INVALID          RJC12K1 K2235240\n         LR    R15,R0               FOR EXECUTE PURPOSES        RJC12K1 K2235245\n         EX    R15,CDFXT            MOVE INTO CHECKLIST         RJC12K1 K2235250\n         B     CDFNSPEC             PROCEED TO NEXT OPERAND     RJC12K1 K2235260\nCDFXT    MVC   CDFST(*-*),2(R1)     **** EXECUTE ONLY ****      RJC12K1 K2235270\nCDFW     OI    CDFIFLG1,CDFI1W      SET TO CHECK WRITER NAME    RJC12K1 K2235280\n         CH    R0,=H'8'             NAMES ARE 8 CHARS OR LESS   RJC12K1 K2235290\n         BNL   CDFINVO              IF LONGER, INVALID          RJC12K1 K2235300\n         LR    R15,R0               FOR EXECUTE PURPOSES        RJC12K1 K2235305\n         EX    R15,CDFXW            MOVE INTO CHECKLIST         RJC12K1 K2235310\n         B     CDFNSPEC             PROCEED TO NEXT OPERAND     RJC12K1 K2235320\nCDFXW    MVC   CDFSW(*-*),2(R1)     **** EXECUTE ONLY ****      RJC12K1 K2235330\nCDFO     OI    CDFIFLG1,CDFI1O      SET TO CHECK FLASH OVERLAY  RJC12K1 K2235340\n         CH    R0,=H'4'             NAMES ARE 4 CHARS OR LESS   RJC12K1 K2235350\n         BNL   CDFINVO              IF LONGER, INVALID          RJC12K1 K2235360\n         LR    R15,R0               FOR EXECUTE PURPOSES        RJC12K1 K2235365\n         EX    R15,CDFXO            MOVE INTO CHECKLIST         RJC12K1 K2235370\n         B     CDFNSPEC             PROCEED TO NEXT OPERAND     RJC12K1 K2235380\nCDFXO    MVC   CDFSO(*-*),2(R1)     **** EXECUTE ONLY ****      RJC12K1 K2235390\nCDFQ     OI    CDFIFLG1,CDFI1Q      SET TO USE ONLY THIS CLASS  RJC12K1 K2235400\n         CH    R0,=H'1'             ONLY 1 CLASS ALLOWED        RJC12K1 K2235410\n         BNL   CDFINVO              IF MORE, INVALID            RJC12K1 K2235420\n         L     R14,=A(CLJHLDTB)     CHECK FOR VALID CLASS       RJC12K1 K2235430\n         LA    R15,36               THERE ARE 36 CLASSES        RJC12K1 K2235440\nCDFQLP   CLC   0(1,R14),2(R1)       TRY                         RJC12K1 K2235450\n         BE    CDFXQ                  TO                        RJC12K1 K2235460\n         LA    R14,1(,R14)              FIND                    RJC12K1 K2235470\n         BCT   R15,CDFQLP                 CLASS IN VALID TABLE  RJC12K1 K2235480\n         B     CDFINVO              IF NOT THERE, INVALID       RJC12K1 K2235482\nCDFXQ    LA    R14,36               FIND                        RJC12K1 K2235484\n         SR    R14,R15                OFFSET                    RJC12K1 K2235486\n         SLL   R14,1                    INTO                    RJC12K1 K2235488\n         STC   R14,CDFSQ                  TABLE                 RJC12K1 K2235490\n         B     CDFNSPEC             PROCEED TO NEXT OPERAND     RJC12K1 K2235492\n         TM    CDFIFLG1,X'FF'       ARE WE LIMITING SETUPS?     RJC12K1 K2249510\n         BZ    CDFCCHOK             NO, USE ALL OF THEM         RJC12K1 K2249520\n         TM    CDFIFLG1,CDFI1B      CHECK BURST?                RJC12K1 K2249530\n         BZ    CDFCF                NO, TRY FORMS               RJC12K1 K2249540\n         TM    CDFCFLAG,$JOEBRST    BURST=YES?                  RJC12K1 K2249550\n         BZ    CDFCBN               NO, CHECK FOR NO            RJC12K1 K2249560\n         CLI   CDFSB,C'Y'           WAS 'Y' ASKED FOR?          RJC12K1 K2249570\n         BNE   CDFEJOA              NO, SKIP THIS ONE           RJC12K1 K2249580\n         B     CDFCF                YES, TRY FORMS              RJC12K1 K2249590\nCDFCBN   CLI   CDFSB,C'N'           WAS 'N' ASKED FOR?          RJC12K1 K2249600\n         BNE   CDFEJOA              NO, SKIP THIS ONE           RJC12K1 K2249610\nCDFCF    TM    CDFIFLG1,CDFI1F      ARE WE LIMITING FORMS?      RJC12K1 K2249620\n         BZ    CDFCC                NO, TRY CARRIAGE TAPE       RJC12K1 K2249630\n         CLC   CDFORMS,CDFSF        YES, CHECK FORMS SPEC.      RJC12K1 K2249640\n         BNE   CDFEJOA              SKIP IF NO MATCH            RJC12K1 K2249650\nCDFCC    TM    CDFIFLG1,CDFI1C      ARE WE LIMITING CARR. TAPE? RJC12K1 K2249660\n         BZ    CDFCT                NO, TRY PRINT TRAIN         RJC12K1 K2249670\n         CLC   CDFFCB,CDFSC         YES, CHECK CARR. TAPE SPEC. RJC12K1 K2249680\n         BNE   CDFEJOA              SKIP IF NO MATCH            RJC12K1 K2249690\nCDFCT    TM    CDFIFLG1,CDFI1T      ARE WE LIMITING TRAINS?     RJC12K1 K2249700\n         BZ    CDFCW                NO, TRY WRITERS             RJC12K1 K2249710\n         CLC   CDFUCS,CDFST         YES, CHECK TRAIN SPEC.      RJC12K1 K2249720\n         BNE   CDFEJOA              SKIP IF NO MATCH            RJC12K1 K2249730\nCDFCW    TM    CDFIFLG1,CDFI1W      ARE WE LIMITING WRITERS?    RJC12K1 K2249740\n         BZ    CDFCO                NO, TRY FLASH               RJC12K1 K2249750\n         CLC   CDFWTR,CDFSW         YES, CHECK WRITER NAME      RJC12K1 K2249760\n         BNE   CDFEJOA              SKIP IF NO MATCH            RJC12K1 K2249770\nCDFCO    TM    CDFIFLG1,CDFI1O      ARE WE LIMITING FLASH?      RJC12K1 K2249780\n         BZ    CDFCCHOK             NO, USE THIS ONE            RJC12K1 K2249790\n         CLC   CDFLASH,CDFSO        YES, CHECK FLASH SPEC.      RJC12K1 K2249800\n         BNE   CDFEJOA              SKIP IF NO MATCH            RJC12K1 K2249810\nCDFCCHOK NULL  ,                    REJOIN NORMAL CODE          RJC12K1 K2249820\n         MVC   CDFMB,=C'F=XXXX C=XXXX T=XXXX L=XXXXX ' BASE MSG RJC12K1 K2252000\n         SR    WD,WD                CLEAR LENGTH REGISTER       RJC12K1 K2253600\n         MVC   CDFMBW-2(2),=C'W='   INSERT WTR INDICATOR        RJC12K1 K2254600\n         LA    WD,L'CDFWTR+2        BUMP LENGTH POINTER         RJC12K1 K2254700\nSKIP120  LA    WD,CDFMB+L'CDFMB(WD) POINT TO NEXT MSG AREA      RJC12K1 K2255500\n         MVC   CXFMBSV,CDFMID       SAVE SETUP CHARACTERISTICS  RJC12K1 K2261100\n         TM    CDFIFLG1,CDFI1Q      ARE WE LIMITING TO ONE CLASSRJC12K1 K2282100\n         BZ    CDFCNQ               NO, PROCEED AS USUAL        RJC12K1 K2282200\n         IC    WB,CDFSQ             YES, SET THE CLASS OFFSET   RJC12K1 K2282300\n         B     CDFACLS              PROCESS CLASS               RJC12K1 K2282400\nCDFCNQ   NULL  ,                    REJOIN COMMON CODE          RJC12K1 K2282500\n         TM    CDFIFLG1,CDFI1Q      LIMITING TO ONE CLASS?      RJC12K1 K2283600\n         BO    CDFEJOE              YES, SKIP THE REST OF THEM  RJC12K1 K2283700\n         TM    COMIFLG1,COMI1X      EXTENDED FORM?              RJC12K1 K2293100\n         BZ    CXFCJQX              NO, DON'T CLEAR TABLE       RJC12K1 K2293200\n         L     R1,CXFJQTBL          GET ADDRESS OF TABLE        RJC12K1 K2293300\n         STH   R0,0(,R1)            SET ENTRY COUNTER TO ZERO   RJC12K1 K2293400\nCXFCJQX  XC    CDFRECCT,CDFRECCT    CLEAR RECORD COUNT          RJC12K1 K2293500\n         MVC   CDFMID(L'CXFMBSV),CXFMBSV REFRESH PRINT LINE     RJC12K1 K2293600\n         LR    WE,R14               SAVE FOR LATER USE          RJC12K1 K2300100\n         BL    CDFRECSM             GO COUNT AND INSERT IN TABLERJC12K1 K2321000\n         L     R0,CDFRECCT          GET TOTAL RECORDS           RJC12K1 K2332100\n         CVD   R0,COMDWORK          CONVERT TO DECIMAL          RJC12K1 K2332110\n         MVC   COMDWORK-4(8),=X'4020202020202120' EDIT MASK     RJC12K1 K2332120\n         ED    COMDWORK-4(8),COMDWORK+4  MAKE PRINTABLE         RJC12K1 K2332130\n         MVC   CDFMBL,COMDWORK-1    MOVE INTO PRINT LINE        RJC12K1 K2332140\n         C     R0,=F'99999'         100K OR MORE?               RJC12K1 K2332150\n         BNH   CXFNKCNT             NO, FINISHED HERE           RJC12K1 K2332160\n         MVC   CDFMBL(4),COMDWORK-3 YES, MOVE IN K LINES        RJC12K1 K2332170\n         MVI   CDFMBL+4,C'K'        FILL IN \"K\"                 RJC12K1 K2332180\nCXFNKCNT NULL  ,                    REJOIN NORMAL CODE          RJC12K1 K2332190\n*        THIS LINE DELETED BY ICSA                              RJC12K1 K2333000\n*        THIS LINE DELETED BY ICSA                              RJC12K1 K2333500\n         S     WD,=F'5'             BACK UP TO CLASS SLOT       RJC12K1 K2334500\n         TM    COMIFLG1,COMI1X      EXTENDED DISPLAY?           RJC12K1 K2334510\n         BZ    CXFPJQX              NO, REJOIN NORMAL CODE      RJC12K1 K2334520\n         L     WE,CXFJQTBL          GET ADDRESS OF TABLE        RJC12K1 K2334530\n         LH    WC,0(,WE)            GET NUMBER OF ENTRIES       RJC12K1 K2334540\n         LA    WE,2(,WE)            BUMP TO FIRST ENTRY         RJC12K1 K2334570\n         LTR   WC,WC                ARE THERE ANY ENTRIES       RJC12K1 K2334572\n         BNP   CXFPJQX              IF NONE, QUIT               RJC12K1 K2334574\nCXFPJQLP MVI   COMMAND,C' '         BLANK OUT                   RJC12K1 K2334580\n         MVC   COMMAND+1(35),COMMAND   IN USUAL MANNER          RJC12K1 K2334590\n         LH    R0,0(,WE)            GET JOBID                   RJC12K1 K2334600\n         CH    R0,=H'10000'         IS IT A JOB?                RJC12K1 K2334610\n         BNL   CXFPJQT              IF NOT TRY TSU OR STC       RJC12K1 K2334620\n         MVC   COMMAND(3),=C'JOB'   INSERT TYPE                 RJC12K1 K2334630\n         B     CXFPJQJ              AND CONTINUE                RJC12K1 K2334640\nCXFPJQT  SH    R0,=H'20000'         IS IT A TSU?                RJC12K1 K2334650\n         BL    CXFPJQS              NO, A STC                   RJC12K1 K2334660\n         MVC   COMMAND(3),=C'TSU'   YES, INSERT TYPE            RJC12K1 K2334670\n         B     CXFPJQJ                AND CONTINUE              RJC12K1 K2334680\nCXFPJQS  MVC   COMMAND(3),=C'STC'   MUST BE STC                 RJC12K1 K2334690\n         AH    R0,=H'10000'         READJUST BASE               RJC12K1 K2334700\nCXFPJQJ  $CFCVE ,                   CONVERT TO EBCDIC           RJC12K1 K2334710\n         MVC   COMMAND+3(5),COMDWORK  INSERT NUMBER             RJC12K1 K2334720\n         MVC   COMMAND+9(8),2(WE)   INSERT JOBNAME              RJC12K1 K2334730\n         MVC   COMMAND+18(5),=C'Q=PPU'  PRIME WITH QUEUE        RJC12K1 K2334740\n*        CLI   14(WE),$FETCH        IS IT IN FETCH QUEUE?       RJC12K1 K2334750\n*        BNE   CXFPJQO              NO, SOME OUTPUT QUEUE       RJC12K1 K2334760\n*        MVC   COMMAND+20(3),=C'FET'  ADJUST QUEUE TYPE         RJC12K1 K2334770\n*        B     CXFPJQL              AND GO INSERT LINES         RJC12K1 K2334780\nCXFPJQO  CLI   14(WE),$HARDCPY      IS IT IN PPU QUEUE?         RJC12K1 K2334790\n         BE    CXFPJQL              YES, THEN GO ADD LINE       RJC12K1 K2334800\n         MVC   COMMAND+20(3),=C'OUT' ADJUST QUEUE TYPE          RJC12K1 K2334810\nCXFPJQL  MVC   COMMAND+24(2),=C'L=' ADD LINES KEYWORD           RJC12K1 K2334820\n         L     R0,10(,WE)           GET RECORD COUNT            RJC12K1 K2334830\n         CVD   R0,COMDWORK          CONVERT TO DECIMAL          RJC12K1 K2334840\n         MVC   COMDWORK-4(8),=X'4020202020202120' EDIT MASK     RJC12K1 K2334850\n         ED    COMDWORK-4(8),COMDWORK+4  EDIT TO PRINTABLE      RJC12K1 K2334860\n         MVC   COMMAND+26(5),COMDWORK-1  MOVE TO PRINT LINE     RJC12K1 K2334870\n         C     R0,=F'99999'         100K OR MORE?               RJC12K1 K2334880\n         BNH   CXFPKCNT             NO, LEAVE ASIS              RJC12K1 K2334890\n         MVC   COMMAND+26(4),COMDWORK-3  MOVE THOUSANDS         RJC12K1 K2334900\n         MVI   COMMAND+30,C'K'        AND ADD \"K\"               RJC12K1 K2334910\nCXFPKCNT TM    15(WE),QUEHOLDA+QUEHOLD1  JOB HELD?              RJC12K1 K2334920\n         BZ    CXFPJQR              IF NOT, RELEASED            RJC12K1 K2334930\n         MVC   COMMAND+32(4),=C'HOLD'  ELSE INSERT FLAG         RJC12K1 K2334940\nCXFPJQR  $CWTO L=36                 SEND THE LINE               RJC12K1 K2334950\n         LA    WE,16(,WE)           BUMP TO NEXT ENTRY          RJC12K1 K2334960\n         BCT   WC,CXFPJQLP          END TRY NEXT ENTRY, IF ANY  RJC12K1 K2334970\nCXFPJQX  NULL  ,                    REJOIN IBM CODE             RJC12K1 K2334980\n*        THIS LINE DELETED BY ICSA                              RJC12K1 K2335000\nCDFNOJOP TM    COMIFLG1,COMI1X      EXTENDED DISPLAY?           RJC12K1 K2349600\n         BZ    CXFXJQX              NO, REJOIN NORMAL CODE      RJC12K1 K2349700\n         L     WF,CXFJQTBL          POINT TO TABLE              RJC12K1 K2349800\nCXFREE   FREEMAIN R,LV=1602,A=(WF),RELATED=(CXFGET,'XF JQE TABLE') 12K1 K2349900\nCXFXJQX  TM    CDFFLAGS,CDFJOEOK    DID WE FIND ANY?            RJC12K1 K2350000\nCDFRECSM L     R15,CDFRECCT         UPDATE                      RJC12K1 K2357510\n         A     R15,JOERECCT           CURRENT                   RJC12K1 K2357520\n         ST    R15,CDFRECCT             RECORD TOTAL            RJC12K1 K2357530\n         TM    COMIFLG1,COMI1X      EXTENDED DISPLAY?           RJC12K1 K2357540\n         BZ    CDFNXTJO             IF NOT, GET NEXT JOE        RJC12K1 K2357550\n         LR    R14,WE               RETRIEVE JQE POINTER        RJC12K1 K2357560\n         L     WE,CXFJQTBL          GET TABLE ADDRESS           RJC12K1 K2357570\n         LH    WC,0(,WE)              AND CURRENT ENTRY COUNT   RJC12K1 K2357580\n         LA    WE,2(,WE)            BUMP TO FIRST ENTRY         RJC12K1 K2357590\n         LTR   WC,WC                IS TABLE EMPTY?             RJC12K1 K2357592\n         BZ    CXFJQIF              YES, JUST INSERT ENTRY      RJC12K1 K2357594\nCXFJQILP CLC   0(2,WE),QUEJOBNO(R14)  IS JOB IN TABLE?          RJC12K1 K2357600\n         BNE   CXFNXTJQ             SKIP ENTRY IF NOT           RJC12K1 K2357610\n         L     R15,10(,WE)          UPDATE CURRENT              RJC12K1 K2357620\n         A     R15,JOERECCT           LINE COUNT                RJC12K1 K2357630\n         ST    R15,10(,WE)              AND STORE NEW COUNT     RJC12K1 K2357640\n         B     CDFNXTJO             THEN REJOIN NORMAL CODE     RJC12K1 K2357650\nCXFNXTJQ LA    WE,16(,WE)           BUMP TO NEXT ENTRY          RJC12K1 K2357660\n         BCT   WC,CXFJQILP          AND TRY AGAIN               RJC12K1 K2357670\nCXFJQIF  MVC   0(2,WE),QUEJOBNO(R14)  NEW ENTRY: INSERT JOBID   RJC12K1 K2357680\n         MVC   2(8,WE),QUEJNAME(R14) JOBNAME                    RJC12K1 K2357690\n         MVC   10(4,WE),JOERECCT     RECORD COUNT               RJC12K1 K2357700\n         MVC   14(1,WE),QUETYPE(R14) QUEUE TYPE                 RJC12K1 K2357710\n         MVC   15(1,WE),QUEFLAGS(R14) AND HOLD FLAGS            RJC12K1 K2357720\n         L     WE,CXFJQTBL          FIND BEGINNING AGAIN        RJC12K1 K2357730\n         LH    WC,0(,WE)            UPDATE                      RJC12K1 K2357740\n         LA    WC,1(,WC)              ENTRY                     RJC12K1 K2357750\n         STH   WC,0(,WE)                COUNT                   RJC12K1 K2357760\n         B     CDFNXTJO             REJOIN NORMAL CODE          RJC12K1 K2357770\nCDFMB    EQU   CDFMR1+10,29         BASE TEXT                   RJC12K1 K2399500\nCDFMBL   EQU   CDFMBT+7,5           RECORD COUNT                RJC12K1 K2401100\nCDFMBW   EQU   CDFMBL+8,8           WRITER NAME                 RJC12K1 K2401500\nCDFICSA  EQU   COMMAND+103          ICSA AREA IN COMMAND BUFFER RJC12K1 K2402600\nCDFIFLG1 EQU   CDFICSA,1            ICSA FLAGS FOR $ DF         RJC12K1 K2402650\nCDFI1B   EQU   B'10000000'          LIMIT BURST                 RJC12K1 K2402700\nCDFI1F   EQU   B'01000000'                FORMS                 RJC12K1 K2402750\nCDFI1C   EQU   B'00100000'                CARRIAGE TAPE         RJC12K1 K2402800\nCDFI1T   EQU   B'00010000'                PRINT TRAIN           RJC12K1 K2402850\nCDFI1W   EQU   B'00001000'                WRITER                RJC12K1 K2402900\nCDFI1O   EQU   B'00000100'                FLASH                 RJC12K1 K2403000\nCDFI1Q   EQU   B'00000001'                CLASS                 RJC12K1 K2403150\nCDFSSTUP EQU   CDFIFLG1+1,26        LIMIT CHECKLIST AREA        RJC12K1 K2403200\nCDFSB    EQU   CDFSSTUP,1           DESIRED BURST               RJC12K1 K2403250\nCDFSF    EQU   CDFSB+1,4                    FORMS               RJC12K1 K2403300\nCDFSC    EQU   CDFSF+4,4                    CARRIAGE TAPE       RJC12K1 K2403350\nCDFST    EQU   CDFSC+4,4                    TRAIN               RJC12K1 K2403400\nCDFSW    EQU   CDFST+4,8                    WRITER              RJC12K1 K2403450\nCDFSO    EQU   CDFSW+8,4                    FLASH               RJC12K1 K2403500\nCDFSQ    EQU   CDFSO+4,1                    CLASS               RJC12K1 K2403550\nCDFRECCT EQU   CDFSSTUP+26,4        CURRENT RECORD COUNT TOTAL  RJC12K1 K2403600\nCXFJQTBL EQU   CDFRECCT+4,4         ADDRESS OF JQE TABLE        RJC12K1 K2403650\nCXFMBSV  EQU   CXFJQTBL+4,36        REFRESH BUFFER FOR PRINTLINERJC12K1 K2403700\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RTS03A1": {"ttr": 7947, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "++USERMOD (RTS03A1) /* EXTENDED TPUT SVC FOR TSO XSEND */.\n++VER (Z038) FMID(EBB1102) /*\n  THIS USER MOD ADDS AN SVC TO THE SYSTEM WHICH IS USED BY\n  THE XSEND COMMAND TO SEND BELLS/ALARM TO A ASCII/3270 TERMINAL,\n  OPTIONALLY AT HIGH PRIORITY. */.\n++MOD (XTPUTSVC) TXLIB(RICEOBJ).\n++JCLIN TXLIB(RICEJCL).\n++ZAP (IEASVC00) /* ADD SVC 238 TO SVC TABLE */.\n NAME SVCTABLE\n REP 0774 C0000000\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RTS10A1": {"ttr": 7949, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "++USERMOD (RTS10A1)\n   /* THIS MODIFICATION TO THE SJB STORES THE ADDRESS OF THE\n      OS LINKAGE CONTROL TABLE (LCT) AT JOB SELECT TIME IN THE SJB\n      FOR USE AT JOB DELETE TIME TO FIND THE OS JOB CONTROL TABLE */.\n++VER (Z038) FMID(EJE1102)\n             PRE(RCB06A1                                    /* ICSA */).\n++MACUPD (#ICSASJB).\n./ CHANGE NAME=#ICSASJB\n#SJBLCT  DS    A                  ADDRESS OF OS LCT             RTS10A1\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RTS10Q1": {"ttr": 7951, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "++USERMOD (RTS10Q1)\n  /* MODIFIED VERSION OF A JES MOD FROM GTE LABORATORIES\n     TO NOTIFY TSO USERS OF THE MAX CONDITION CODE OR ABEND CODE\n     THIS CODE ACTUALLY TAKES THE SAVED RETURN CODE AND PLACES IT\n     INTO THE NOTIFY MESSAGE.\n\n     OBTAINED FROM THE CBT MODS TAPE, VERSION 187, FILE 232.\n\n     MODIFIED BY ICSA TO PLACE INTO SMP4 FORMAT  MARCH 1982       */.\n++VER (Z038) FMID(EJE1102)\n              REQ(RTS10A1,RTS10T1                           /* ICSA */).\n++SRCUPD (HASPPRPU).\n./ CHANGE NAME=HASPPRPU\n         COPY  RTS10Q1A        ADD CC/ABEND CODE TO MSG         RTS10Q1 Q0557050\n++MAC (RTS10Q1A) DISTLIB(RICEHSRC) ASSEM(HASPPRPU).\n         CLI   JCTCNVRC,X'77'  IS IT OURS ?                     RTS10Q1\n         BNE   #RTS10#1        NO SKIP                          RTS10Q1\n         CLI   JCTJTFLG,JCTJTJF IS IT OURS ?                    RTS10Q1\n         BE    #RTS10#1          NO SKIP                        RTS10Q1\n         TM    JCTJTFLG,JCTJTABD ABENDED?                       RTS10Q1\n         BZ    #RTS10#2        NO ABEND                         RTS10Q1\n         MVC   0(22,R1),=C'- ABENDED  SYSTEM XXX '              RTS10Q1\n         L     R2,JCTCNVRC     GET CODE                         RTS10Q1\n         LA    R2,0(R2)        CLEAR HIGH ORDER                 RTS10Q1\n         SRL   R2,12           GET SYSTEM CODE IN               RTS10Q1\n         LTR   R2,R2           TEST SYSTEM CODE                 RTS10Q1\n         BZ    #RTS10#3        USER CODE                        RTS10Q1\n         SRDL  R2,12           CONVERT IT TO HEX                RTS10Q1\n         SR    R2,R2                   \"                        RTS10Q1\n         SLDL  R2,4                    \"                        RTS10Q1\n         IC    R2,$HEXTRAN+240(R2)     \"                        RTS10Q1\n         STC   R2,18(R1)               \"                        RTS10Q1\n         SR    R2,R2                   \"                        RTS10Q1\n         SLDL  R2,4                    \"                        RTS10Q1\n         IC    R2,$HEXTRAN+240(R2)     \"                        RTS10Q1\n         STC   R2,19(R1)               \"                        RTS10Q1\n         SR    R2,R2                   \"                        RTS10Q1\n         SLDL  R2,4                    \"                        RTS10Q1\n         IC    R2,$HEXTRAN+240(R2)     \"                        RTS10Q1\n         STC   R2,20(R1)               \"                        RTS10Q1\n         B     #RTS10#4        GO INCREMENT LINE LENGTH         RTS10Q1\n#RTS10#2 MVC   0(22,R1),=C'- MAX COND CODE XXXX  '              RTS10Q1\n         B     #RTS10#5        GO CONVERT TO DEC/PRINTABLE      RTS10Q1\n#RTS10#3 MVC   0(22,R1),=C'- ABENDED  USER XXXX  '              RTS10Q1\n#RTS10#5 LH    R2,JCTCNVRC+2   GET MAX COND/USER ABEND          RTS10Q1\n         CVD   R2,16(R1)       CONVERT TO DECIMAL               RTS10Q1\n         UNPK  16(4,R1),16(8,R1) UNPK FOUR LOW DIGITS           RTS10Q1\n         OI    19(R1),X'F0'    SET ZONE                         RTS10Q1\n         MVI   20(R1),X'40'    CLEAR NEXT TO LAST BYTE          RTS10Q1\n         MVI   21(R1),X'40'    CLEAR LAST BYTE                  RTS10Q1\n#RTS10#4 LA    R1,22(R1)       INCREMENT LENGTH                 RTS10Q1\n         B     OPLOUSM2        RETURN TO NORMAL PROCESSING      RTS10Q1\n#RTS10#1 NULL  ,               BE SURE OF ALLIGNMENT            RTS10Q1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RTS10T1": {"ttr": 7953, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "++USERMOD (RTS10T1)\n  /* MODIFIED VERSION OF A JES MOD FROM GTE LABORATORIES\n     TO NOTIFY TSO USERS OF THE MAX CONDITION CODE OR ABEND CODE\n     THIS CODE COMPUTES THE HIGHEST RC/ABEND CODE AND STORES IT\n\n     OBTAINED FROM THE CBT MODS TAPE, VERSION 187, FILE 232.\n\n     MODIFIED BY ICSA TO PLACE INTO SMP4 FORMAT  MARCH 1982       */.\n++VER (Z038) FMID(EJE1102)\n              PRE(UZ37498                                   /* IBM  */)\n              REQ(RTS10A1,RTS10Q1                           /* ICSA */).\n++SRCUPD (HASPSSSM).\n./ CHANGE NAME=HASPSSSM\n         $OSJCT LIST=&LIST      GENERATE PARTIAL OS JCT DSECT   RTS10T1 T0076100\n         $SCT  LIST=&LIST       GENERATE OS SCT DSECT           RTS10T1 T0076200\n         ST    R1,#SJBLCT       SAVE LCT ADDRESS FOR JOB DELETE RTS10T1 T2048100\n         COPY  RTS10T1A         COPY CODE TO SET COND/ABEND CODERTS10T1 T2269950\n++MAC (RTS10T1A) ASSEM(HASPSSSM) DISTLIB(RICEHSRC).\n         SR    R0,R0            ZERO REGISTER                   RTS10T1\n         L     R1,#SJBLCT       GET LCT ADDRESS                 RTS10T1\n         L     R1,LCTJCTAD-LCTDSECT(,R1) GET ADDRESS OF JCT(OS) RTS10T1\n         USING INJMJCT,R1       TELL ASSEMBLER                  RTS10T1\n         TM    JCTJSTAT,JCTABEND WAS JOB ABENDED                RTS10T1\n         BNO   #HJE1            NO                              RTS10T1\n         L     R0,JCTACODE      GET ABEND CODE                  RTS10T1\n         B     #HJE3            GO TO FINISH                    RTS10T1\n#HJE1    L     R1,JCTSDKAD      FIRST SCT ADDRESS               RTS10T1\n         USING INSMSCT-16,R1    TELL ASSEMBLER                  RTS10T1\n#HJE4    SRL   R1,8             GET ADDRESS IN PROPER FORM      RTS10T1\n         LTR   R1,R1            TEST FOR ZERO (END)             RTS10T1\n         BZ    #HJE3            GO TO FINISH                    RTS10T1\n         CH    R0,SCTSEXEC      TEST FOR NEW MAX                RTS10T1\n         BNL   #HJE5              NO                            RTS10T1\n         LH    R0,SCTSEXEC        YES SAVE NEW MAX              RTS10T1\n#HJE5    L     R1,SCTANSCT      GET NEXT SCT                    RTS10T1\n         B     #HJE4            LOOP                            RTS10T1\n#HJE3    ST    R0,JCTCNVRC      SAVE IT                         RTS10T1\n         MVI   JCTCNVRC,X'77'   MARK IT AS OURS                 RTS10T1\n         DROP  R1                                               RTS10T1\n++MAC ($OSJCT) DISTLIB(RICEHSRC) ASSEM(HASPSSSM).\n         MACRO                                                  RTS10T1\n         $OSJCT &LIST=NO,&DOC=NO                                RTS10T1\n         AIF   ('&DOC' NE 'YES').A                              RTS10T1\n.A       TITLE 'OS JOB CONTROL TABLE (JCT) DSECT'               RTS10T1\n*        THIS IS A PARTIAL EXPANSION BECAUSE OF NAME CONFLICTS  RTS10T1\n*        WITH THE JES2 JCT MACRO.  PREREQ PTF SUPPLIED MOST     RTS10T1\n*        RECENT COPY OF THE MACRO FROM WHICH OFFSETS ARE TAKEN. RTS10T1\nJCTDSCT  DSECT                                                  RTS10T1\nINJMJCT  EQU   *             BEGINNING OF OS JCT                RTS10T1\n         ORG   JCTDSCT+5     GET OFFSET RIGHT                   RTS10T1\nJCTJSTAT DS    BL8           JOB STATUS INDICATORS              RTS10T1\nJCTABEND EQU   X'08'         ABEND BIT                          RTS10T1\n         ORG   JCTDSCT+32    GET OFFSET RIGHT                   RTS10T1\nJCTSDKAD DS    AL3           DISK ADDR. OF FIRST SCT            RTS10T1\n         ORG   JCTDSCT+168   GET OFFSET RIGHT                   RTS10T1\nJCTACODE DS    XL4           ABEND CODE FIELD                   RTS10T1\n&SYSECT  CSECT               END OF OS JCT DSECT                RTS10T1\n         MEND                                                   RTS10T1\n++MAC ($SCT) DISTLIB(RICEHSRC) ASSEM(HASPSSSM).\n         MACRO                                                  RTS10T1\n         $SCT  &LIST=NO,&DOC=NO                                 RTS10T1\n         AIF   ('&DOC' NE 'YES').A                              RTS10T1\n.A       TITLE 'OS STEP CONTROL TABLE (SCT) DSECT'              RTS10T1\nSCTDSCT  DSECT                                                  RTS10T1\n         IEFASCTB                                               RTS10T1\n&SYSECT  CSECT               END OF OS SCT DSECT                RTS10T1\n         MEND                                                   RTS10T1\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RTS10Z1": {"ttr": 7955, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "++USERMOD (RTS10Z1)\n   /* THIS ZAP ZEROS THE SCTSEXEC FIELD FOR STEPS THAT ARE FLUSHED\n      BECAUSE OF JCL ERRORS OR WHATEVER.  (UNTIL A STEP EXECUTES, THE\n      FIELD CONTAINS THE LENGTH OF THE PARM FIELD ON THE EXEC CARD.)\n      THIS CODE USES TCTHWM BEING ZERO TO INDICATE THAT THE STEP WAS\n      NOT EXECUTED (SAME METHOD AS USED FOR SMF).*/.\n++VER (Z038) FMID(JBB1126)\n              PRE(UZ37453                                   /* IBM  */)\n              REQ(RTS10A1,RTS10T1,RTS10Q1                   /* ICSA */).\n++ZAP (IEFTB722).\nNAME IEFTB722\nVER 028C 4780,C2A8\nVER 0D9A 0000,0000,0000,0000,0000,0000,0000\nREP 028C 4780,CD76\nREP 0D9A 58A0,6014,D701,A008,A008,47F0,C2A8\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RTU05A1": {"ttr": 8193, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "++USERMOD (RTU05A1) /* TSU IKJPARS REPLACEMENT */.\n++VER (Z038) FMID(EBB1102) /*\n  THIS USER MOD REPLACES THE IBM LOAD MODULE IKJPARS WITH THE\n  TSU LOAD MODULE CLUTSPAR, TO SUPPORT A FRIENDLIER TSO ENVIRONMENT\n  BY IMPROVED ERROR DETECTION, REPORTING AND CORRECTION.\n      NOTE: UCLIN IS REQUIRED FOR THIS USERMOD TO DELETE THE\n  LOAD MODULES IKJPARS AND IKJPARS2 FRON THE CDS. MANUAL ACTION IS\n  REQUIRED TO RENAME THE IBM MODULES TO OKJPARS AND OKJPARS2. */.\n++MOD (CLUTSPAR) DISTLIB(RICEDLIB) LEPARM(RENT,REUS)\n                LKLIB(RICELOAD).\n++JCLIN.\n//RTU05A1 JOB (),'JCLIN FOR RTU05A1'\n//OKJPARS EXEC LINKS,NAME=LINKLIB,PARM='RENT,REUS'\n//SYSLIN DD *\n INCLUDE AOST4(IKJEFP00,IKJEFP03,IKJEFP10,IKJEFP20)\n ENTRY IKJPARS\n NAME OKJPARS(R)\n INCLUDE AOST4(IKJEFP60)\n ENTRY IKJPARS2\n NAME OKJPARS2(R)\n/*\n//CLUTSPAR EXEC LINKS,NAME=LPALIB,PARM='RENT,REUS,NCAL'\n//SYSLIN DD *\n INCLUDE RICEDLIB(CLUTSPAR)\n ALIAS IKJPARS\n ENTRY CLUZPAR\n NAME CLUTSPAR(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RUA03A1": {"ttr": 8195, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "++USERMOD (RUA03A1) /* DATASET OWNERSHIP STAMPING SVC */.\n++VER (Z038) PRE(ACF3100) FMID(EDM1102)\n             REQ(RUA03B1,RUA03C1,RUA03D1) /*\n  THIS USER MOD ADDS A USER SVC TO THE SYSTEM TO STORE THE ACF2\n  LOGONID INTO A FORMAT 1 DSCB.  REQUISITE USERMODS MODIFY\n  THOSE DADSM MODULES WHICH CREATE FORMAT 1 DSCBS TO ISSUE THIS\n  SVC TO MODIFY THE DSCB BEFORE IT IS WRITTEN. */.\n++MOD (UEHSTAMP) TXLIB(RICEOBJ).\n++JCLIN TXLIB(RICEJCL).\n++ZAP (IEASVC00) /* ADD SVC 237 TO SVC TABLE */.\n NAME SVCTABLE\n REP 076C C8000000           STAMPING SVC IS AUTHORIZED\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RUA03B1": {"ttr": 8197, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "++USERMOD (RUA03B1) /* DSCB STAMPING SUPPORT FOR NON-ISAM ALLOC */.\n++VER (Z038) FMID(EDM1102)\n             REQ(RUA03A1,RUA03C1,RUA03D1) /*\n  THIS USER MOD MODIFIES IGG0325E (A DADSM NON-ISAM ALLOCATE\n  MODULE) TO ISSUE SVC 237 TO STORE THE ACF2 LOGONID INTO THE\n  FORMAT 1 DSCB FOR A NEW DATASET. */.\n++ZAP (IGG0325E).\n NAME IGG0325E\n VER 0230 4590,C302\n VER 03F8 0000,0000\n REP 03F8 4110,D0C0          PUT DSCB ADDR IN R1\n REP 03FC 5800,D1F8          PUT UCB ADDR IN R0\n REP 0400 0AED               ISSUE STAMPING SVC\n REP 0402 47F0,C302          RETURN FROM PATCH\n REP 0230 4590,C3F6\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RUA03C1": {"ttr": 8199, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "++USERMOD (RUA03C1) /* DSCB STAMPING SUPPORT FOR ISAM ALLOC */.\n++VER (Z038) FMID(EDM1102)\n             REQ(RUA03A1,RUA03B1,RUA03D1) /*\n  THIS USER MOD MODIFIES IGG032I3 (A DADSM ISAM ALLOCATE\n  MODULE) TO ISSUE SVC 237 TO STORE THE ACF2 LOGONID INTO THE\n  FORMAT 1 DSCB FOR A NEW DATASET. */.\n++ZAP (IGG032I3).\n NAME IGG032I3\n VER 0108 D601,D2A4,D2A4\n VER 0488 0000,0000\n REP 0488 4110,D0C0          PASS DSCB ADDR IN R1\n REP 048C 5800,D1F8          UCB ADDR IN R0\n REP 0490 0AED               ISSUE STAMPING SVC\n REP 0492 D601,D2A4,D2A4\n REP 0498 47F0,C10C          RETURN FROM PATCH\n REP 0108 47F0,C486\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RUA03D1": {"ttr": 8201, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "++USERMOD (RUA03D1) /* DSCB STAMPING SUPPORT FOR EOV EXTEND */.\n++VER (Z038) FMID(EDM1102)\n             REQ(RUA03A1,RUA03B1,RUA03C1) /*\n  THIS USER MOD MODIFIES IGG0553C (A DADSM NON-ISAM EXTEND\n  MODULE) TO ISSUE SVC 237 TO STORE THE ACF2 LOGONID INTO THE\n  FORMAT 1 DSCB FOR A DATA SET WHICH HAS BEEN EXTENDED TO A NEW VOLUME.\n */.\n++ZAP (IGG0553C).\n NAME IGG0553C\n VER 0420 47F0,3120\n VER 04B8 0000,0000\n REP 04B8 4110,B060          PASS DSCB ADDR IN R1\n REP 04BC 5800,415C          UCB ADDR IN R0\n REP 04C0 0AED               ISSUE STAMPING SVC\n REP 04C2 47F0,3120          RETURN FROM PATCH\n REP 0420 47F0,34B6\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RUA04A1": {"ttr": 8203, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "++USERMOD (RUA04A1)\n   /* ICSA MODIFICATIONS TO SMF RECORDS TO SUPPORT ICSA\n      ACCOUNTING POLICIES                                  */.\n++VER (Z038) FMID(EJE1102).\n++MACUPD ($SMF) ASSEM(HASPMISC,HASPPRPU,HASPACCT,HASPDOC).\n./ CHANGE NAME=$SMF\n         SPACE 2                                                RUA04A1 HB129000\nSMF6IEXD DSECT                     ICSA EXTENSION SECTION       RUA04A1 HB129005\nSMF6$LN1 DC    Y(SMF6$EN1-*)       LENGTH OF ICSA SECTION       RUA04A1 HB129010\nSMF6$TYP DC    X'01'               TYPE CODE -- 1 = JES2 ORIGINARUA04A1 HB129020\nSMF6$EN1 DS    0C                  END OF ICSA SECTION          RUA04A1 HB129030\nSMFDSECT DSECT                     RESUME HASP SMF DSECT DEFINITRUA04A1 HB129055\n         SPACE 2                                                RUA04A1 HB129056\n         ORG   *+(SMF6$EN1-SMF6$LN1)                            RUA04A1 HB129057\n         SPACE 2                                                RUA04A1 HB129060\nSMF6IEXT EQU   B'00001000'         ICSA SECTION EXISTS          RUA04A1 HB609000\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RUA04Q1": {"ttr": 8205, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "++USERMOD (RUA04Q1)\n   /* ICSA MODIFICATION TO HASPPRPU TO INSERT THE ICSA FIELDS\n      IN THE TYPE 6 (SYSOUT) RECORD                          */.\n++VER (Z038) FMID(EJE1102)\n             REQ(RUA04A1                                    /* ICSA */).\n++MAC (#ICSATY6) ASSEM(HASPPRPU) DISTLIB(RICEHSRC).\n         SPACE 1                                                RUA04Q1\n****************************************************************RUA04Q1\n*                                                              *RUA04Q1\n*      ADD ICSA SECTION                                        *RUA04Q1\n*                                                              *RUA04Q1\n****************************************************************RUA04Q1\n         SPACE 1                                                RUA04Q1\n         LA    PC1,SMFRDW(LINK)      FIND END OF RECORD         RUA04Q1\n         USING SMF6IEXD,PC1          SECTION ADDRESSABILITY     RUA04Q1\n         MVC   SMF6$LN1,=Y(SMF6$EN1-SMF6$LN1) SET SECTION LENGTHRUA04Q1\n         MVI   SMF6$TYP,X'01'         SET TYPE CODE             RUA04Q1\n         OI    SMF6IND,SMF6IEXT       INDICATE ICSA SECTION HERERUA04Q1\n         LA    LINK,SMF6$EN1-SMF6$LN1(,LINK) UPDATE LENGTH      RUA04Q1\n++SRCUPD (HASPPRPU).\n./ CHANGE NAME=HASPPRPU\n         COPY  #ICSATY6               INSERT ICSA SECTION       RUA04Q1 Q5262100\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RUA11A1": {"ttr": 8207, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "++USERMOD (RUA11A1) /* SMF TYPE 32 RECORD IMPROVEMENTS */.\n++VER (Z038) FMID(JBB1126) REQ(RUA11B1,RUA11C1) /*\n  THIS USER MOD IMPLEMENTS SEVERAL IMPROVEMENTS IN TSO\n  FUNCTIONAL ACCOUNTING.  IT ALLOWS ALL COMMANDS AND\n  SUBCOMMANDS TO BE RECORDED WITHOUT HAVING TO BE INCLUDED IN\n  THE IEEMB846 LIST, AND RECORDS (IN PLACE OF SRB TIME, TPUTS\n  AND TGETS) THE TOTAL ELAPSED TIME, AS WELL AS THE NUMBER OF\n  COMMANDS WHICH ISSUED NO TGETS, PLUS THE ELAPSED TIME\n  FOR THESE. THIS PROVIDES MORE ACCURATE RESPONSE-TIME\n  STATISTICS THAN AVAILABLE FROM OTHER SOURCES IN THE\n  SYSTEM (E.G., CMF). */.\n++ZAP (IGX00025).\n NAME IGX00025\n*                            ORG   SRBTIME       COMPUTE ELAPSED TIME INSTEAD\nVER 0100 D207,80EC,20C8      MVC   SRBT(8,8),X'C8'(2)\n*                            ORG   SRBDONE       END OF SRB CALCULATION\nVER 014E 4110,8100           LA    1,X'100'(,8)\n*                            ORG   FIRSTEST      CHECK FOR FIRST CALL\nVER 0226 9120,700A           TM    NOTFIRST(7),B'00100000'\nVER 022A 4770,9230           BNZ   @RF00146\n*                            ORG   TPUTACCM      TPUT/TGET ACCUMULATION\nVER 040A 5810,5018           L     1,SMF32TPT(,5)\nVER 040E 5E10,2010           AL    1,SIGTPUT(,2)\nVER 0412 5010,5018           ST    1,SMF32TPT(,5)\nVER 0416 5840,5014           L     4,SMF32TGT(,5)\nVER 041A 5E40,2014           AL    4,SIGTGET(,2)\nVER 041E 5040,5014           ST    4,SMF32TGT(,5)\n*                   ENDTPUT  EQU   *\n*                            ORG   NOTFOUND\n*\nVER 04EA 4770,94CA           BNE   @RF00241      IF CMD NAME NOT MATCHED\nVER 04EE 4130,0001           LA    3,1           SET FOUND FLAG\n*                            ORG   PATCH\nVER 0570 0000,0000,0000,0000 DC    (X'38')X'00'\nVER 0578 0000,0000,0000,0000\nVER 0580 0000,0000,0000,0000\nVER 0588 0000,0000,0000,0000\nVER 0590 0000,0000,0000,0000\nVER 0598 0000,0000,0000,0000\nVER 05A0 0000,0000,0000,0000\n*                            ORG   SRBTIME       REPLACE SRB WITH TOD\nREP 0100 B205,80EC           STCK  SRBT(8)       STORE THE TOD\nREP 0104 D203,80EC,80ED      MVC   SRBT(4,8),SRBT+1(8) STORE IN 4.096 SEC/1000S\nREP 010A D203,80F0,80EC      MVC   SRBT+4(4,8),SRBT(8) IN SRB TIME SLOT\nREP 0110 47F0,9124           B     SRBDONE\n*                            ORG   FIRSTEST+4\nREP 022A 4700,9230           NOP   @RF00146\n*                            ORG   TPUTACCM\nREP 040A 47F0,9558           B     PACHACCM\n*                            ORG   NOTFOUND\nREP 04EA 47F0,9546           B     STEAL\n*                            ORG   PATCH\n*                   STEAL    EQU   *\nREP 0570 95F0,2000           CLI   0(2),C'0'     IS THIS TABLE ENTRY A DUMMY?\n*                            (COMMAND NAME STARTING '0')\nREP 0574 4770,94CA           BNE   @RF00241      NO, CONTINUE SEARCH\nREP 0578 D207,2000,7000      MVC   0(8,2),0(7)   YES, STEAL FOR THIS COMMAND\nREP 057E 47F0,94C4           B     NOTFOUND+4\n*                   PACHACCM EQU   *\nREP 0582 D603,2014,2014      OC    SIGTGET(4,2),SIGTGET(2) DID THIS CMD TGET?\nREP 0588 4770,93F8           BNZ   ENDTPUT       YES, SKIP NO-TGET CODE\nREP 058C 4110,0001           LA    1,1           NO, ADD 1 TO NO-TGET\nREP 0590 5E10,5018           AL    1,SMF32TPT(,5) CMD COUNT\nREP 0594 5010,5018           ST    1,SMF32TPT(,5)\nREP 0598 5840,5014           L     4,SMF32TGT(,5) ADD ELAPSED TIME TO\nREP 059C 5E40,200C           AL    4,SIGSRB(,2)  NO-TGET ELAPSED TOTAL\nREP 05A0 5040,5014           ST    4,SMF32TGT(,5)\nREP 05A4 47F0,93F8           B     ENDTPUT\n* DECK PRODUCED BY THE ASMTOZAP UTILITY 82/06/16 145736\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RUA11B1": {"ttr": 8209, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "++USERMOD (RUA11B1) /* TSU FUNCTIONAL ACCOUNTING IMPROVEMENT */.\n++VER (Z038) FMID(JBB1126) REQ(RUA11A1,RUA11C1) /*\n  THIS USERMOD UPDATES IEBTB727 (THE SMF TYPE 32 RECORD WRITER)\n  TO COPY THE COMMAND NAMES FROM THE INCREMENT RECORD TO THE\n  STEP RECORD. THIS SUPPORTS STORING THE COMMAND NAMES AT RUN-\n  TIME, INSTEAD OF BEING LIMITED TO AN ASSEMBLED LIST. */.\n++ZAP (IEFTB727).\n NAME IEFTB727\n VER 0188 47D0A0D2        END OF CMD LOOP CHECK\n VER 02D0 00000000\n REP 0188 47D0A2AC\n REP 02D0 D20740003000    COPY OVER THE COMMAND NAME\n REP 02D6 47F0A0D2\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RUA11C1": {"ttr": 8211, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "++USERMOD (RUA11C1) /* TSO FUNC. ACCTING COMMAND LIST REPLACEMENT */.\n++VER (Z038) FMID(JBB1126) REQ(RUA11A1,RUA11B1) /*\n  THIS USERMOD REPLACES THE TSO COMMAND LIST MODULE IEEMB846\n  WITH A LIST CONTAINING ENTRIES FOR THE NUMBERS 01 TO 0200.\n  THESE ENTRIES ARE REPLACED BY THE TSO COMMAND NAMES ACTUALLY\n  USED AS A RESULT OF THE REQUISITE USERMOD RUA11A1. */.\n++MOD (IEEMB846) TXLIB(RICEOBJ).\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RUA13A1": {"ttr": 8213, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "++USERMOD (RUA13A1)\n   /* THIS MODIFICATION ADDS INFORMATION TO JES2 CONTROL BLOCKS\n      REGARDING FORMS, TRAINS, AND CARRIAGE TAPES.              */.\n++VER (Z038) FMID(EJE1102)\n              PRE(RCB02A1,RCB07A1                           /* ICSA */)\n              REQ(RUA13M1,RUA13Q1                           /* ICSA */).\n++MACUPD (#ICSAHCT).\n./ CHANGE NAME=#ICSAHCT\n         SPACE 1                                                RUA13A1\n*                            OUTPUT ACCOUNTING FIELDS           RUA13A1\n         SPACE 1                                                RUA13A1\n$FORMTBL DC    A(*-*)        POINTER TO FORMS TABLE             RUA13A1\n$CTAPTBL DC    A(*-*)        POINTER TO CTAPE TABLE             RUA13A1\n$TRAINS  DC    A(*-*)        POINTER TO TRAIN TABLE             RUA13A1\n$LNECST  DC    F'0'          COST/LINE IN 1000THS/CENT          RUA13A1\n$PUNCST  DC    F'0'          COST/CARD IN 1000THS/CENT          RUA13A1\n$FSTCST  DC    F'0'          FORMS SETUP CHARGE                 RUA13A1\n$CSTCST  DC    F'0'          CTAPE SETUP CHARGE                 RUA13A1\n$TSTCST  DC    F'0'          TRAIN SETUP CHARGE                 RUA13A1\n$BSTCST  DC    F'0'          BASE SETUP CHARGE                  RUA13A1\n$MAXFRMS DC    H'0'          MAXIMUM NUMBER OF FORMS            RUA13A1\n$MAXCTPS DC    H'0'          MAXIMUM NUMBER OF CTAPES           RUA13A1\n$MAXTRNS DC    H'0'          MAXIMUM NUMBER OF TRAINS           RUA13A1\n++MACUPD (#ICSAPPW).\n./ CHANGE NAME=#ICSAPPW\n         SPACE 1                                                RUA13A1\n*                             OUTPUT ACCOUNTING FIELDS          RUA13A1\n         SPACE 1                                                RUA13A1\nPPFRMLEN DS    H              # OF LINES/PAGE                   RUA13A1\nPPCTPLEN DS    H              # OF LINES/CTAPE                  RUA13A1\nPPFRMCST DS    F              COST/PAGE IN 1000THS OF CENTS     RUA13A1\nPPCTPLIN DS    H              LINE ON CARRIAGE TAPE             RUA13A1\nPPFRMLIN DS    H              LINE ON FORM PAGE                 RUA13A1\nPPTRNCST DS    F              TRAIN MULTIPLIER 1000THS OF CENTS RUA13A1\nPBSETCST DS    F              BASE SETUP (DISPATCHING) COST     RUA13A1\nPFSETCST DS    F              FORM SETUP COST                   RUA13A1\nPCSETCST DS    F              CTAPE SETUP COST                  RUA13A1\nPTSETCST DS    F              TRAIN SETUP COST                  RUA13A1\nPLINECST DS    F              COST PER LINE                     RUA13A1\nPPNCHCST DS    F              COST PER CARD                     RUA13A1\nPPCTPMAP DS    A              POINTER TO PUNCH MAP              RUA13A1\nPPIFLG1  DS    X              ICSA FLAGS                        RUA13A1\nPPIFLG2  DS    X                                                RUA13A1\n         DS    XL2            RESERVED                          RUA13A1\n         SPACE 1                                                RUA13A1\nPPI1FDEF EQU   X'80'          UNKNOWN FORM: DEFAULT USED        RUA13A1\nPPI1TDEF EQU   X'40'          UNKNOWN TRAIN: DEFAULT USED       RUA13A1\nPPI1CDEF EQU   X'20'          UNKNOWN CTAPE: DEFAULT USED       RUA13A1\nPPI18LPI EQU   X'10'          8 LPI                             RUA13A1\nPPI1PAGE EQU   X'08'          NEW PAGE REQUIRED                 RUA13A1\nPPI1LOCL EQU   X'04'          LOCALLY PRINTED: CHARGE FOR IT    RUA13A1\nPPI1TSTR EQU   X'02'          NO TRAIN SPECIFIED                RUA13A1\nPPI1CSTR EQU   X'01'          NO CTAPE SPECIFIED                RUA13A1\n         SPACE 1                                                RUA13A1\nPPI2FSET EQU   X'80'          FORMS SETUP CHARGE REQUIRED       RUA13A1\nPPI2CSET EQU   X'40'          CTAPE SETUP CHARGE REQUIRED       RUA13A1\nPPI2TSET EQU   X'20'          TRAIN SETUP CHARGE REQUIRED       RUA13A1\n++MAC (#FORMTBL) ASSEM(HASPPRPU) DISTLIB(RICEHSRC).\n         MACRO                                                  RUA13A1\n         #FORMTBL &DOC=NO                                       RUA13A1\n         AIF   ('&DOC' NE 'YES').A                              RUA13A1\n.A       TITLE 'HASP FORMS TABLE'                               RUA13A1\n#FORMTBL DSECT                                                  RUA13A1\n#FORMEYE DC    CL8'#FORMTBL'  EYECATCHER                        RUA13A1\n#FRM#ENT DS    F              NUMBER OF ENTRIES                 RUA13A1\n#FRMENT1 EQU   *              BEGINNING OF FORMS ENTRIES        RUA13A1\n&SYSECT  CSECT ,                                                RUA13A1\n         MEND                                                   RUA13A1\n++MAC (#FORMENT) ASSEM(HASPPRPU) DISTLIB(RICEHSRC).\n         MACRO                                                  RUA13A1\n         #FORMENT &DOC=NO                                       RUA13A1\n         AIF   ('&DOC' NE 'YES').A                              RUA13A1\n.A       TITLE 'HASP FORMS TABLE ENTRY'                         RUA13A1\n#FORMENT DSECT                                                  RUA13A1\n#FRMNAME DS    CL4            FORM NAME                         RUA13A1\n#FRM6LPI DS    H              # OF LINES AT 6 LPI               RUA13A1\n#FRM8LPI DS    H              # OF LINES AT 8 LPI               RUA13A1\n#FRMCST  DS    F              COST/PAGE IN 1000THS OF CENTS     RUA13A1\n#FRMFLGS DS    X              FLAGS                             RUA13A1\n#FRM$SET EQU   X'80'          SETUP CHARGE REQUIRED             RUA13A1\n#FRMELEN EQU   *-#FRMNAME     FORM ENTRY LENGTH                 RUA13A1\n&SYSECT  CSECT ,                                                RUA13A1\n         MEND                                                   RUA13A1\n++MAC (#CTAPTBL) ASSEM(HASPPRPU) DISTLIB(RICEHSRC).\n         MACRO                                                  RUA13A1\n         #CTAPTBL &DOC=NO                                       RUA13A1\n         AIF   ('&DOC' NE 'YES').A                              RUA13A1\n.A       TITLE 'HASP CARRIAGE TAPE TABLE'                       RUA13A1\n#CTAPTBL DSECT                                                  RUA13A1\n#CTAPEYE DC    CL8'#CTAPTBL'  EYECATCHER                        RUA13A1\n#CTP#ENT DS    F              # OF CTAPES IN TABLE              RUA13A1\n#CTPENT1 EQU   *              BEGINNING OF ENTRIES              RUA13A1\n&SYSECT  CSECT ,                                                RUA13A1\n         MEND                                                   RUA13A1\n++MAC (#CTAPENT) ASSEM(HASPPRPU) DISTLIB(RICEHSRC).\n         MACRO                                                  RUA13A1\n         #CTAPENT &DOC=NO                                       RUA13A1\n         AIF   ('&DOC' NE 'YES').A                              RUA13A1\n.A       TITLE 'HASP CTAPE TABLE ENTRY DSECT'                   RUA13A1\n         SPACE 5                                                RUA13A1\n#CTAPENT DSECT                                                  RUA13A1\n#CTAPNAM DS    CL4            CARRIAGE TAPE NAME                RUA13A1\n#CTAPLPI DS    H              (6 OR 8) LPI                      RUA13A1\n#CTAPLEN DS    H              # OF LINES ON CTAPE               RUA13A1\n#CTAPFLG DS    XL1            FLAGS                             RUA13A1\n#CTP$SET EQU   X'80'          SETUP CHARGE REQUIRED             RUA13A1\n*                             THE PUNCH MAP HAS X'00' FOR EVERY RUA13A1\n*                             LINE WITH NO PUNCH, X'01'-X'0C'   RUA13A1\n*                             FOR EVERY LINE WITH A 1-12 PUNCH  RUA13A1\n#CTAPMAP DS    XL256          PUNCH MAP                         RUA13A1\n#CTPELEN EQU   *-#CTAPLPI     LENGTH OF CTAPE ENTRY             RUA13A1\n&SYSECT  CSECT ,                                                RUA13A1\n         MEND                                                   RUA13A1\n++MAC (#TRAINS) ASSEM(HASPPRPU) DISTLIB(RICEHSRC).\n         MACRO                                                  RUA13A1\n         #TRAINS &DOC=NO                                        RUA13A1\n         AIF   ('&DOC' NE 'YES').A                              RUA13A1\n.A       TITLE 'HASP TRAINS TABLE'                              RUA13A1\n#TRAINS  DSECT                                                  RUA13A1\n#TRANEYE DC    CL8'#TRAINS'   EYECATCHER                        RUA13A1\n#TRN#ENT DS    F              # OF TRAINS                       RUA13A1\n#TRNENT1 EQU   *              FIRST ENTRY                       RUA13A1\n&SYSECT  CSECT ,                                                RUA13A1\n         MEND                                                   RUA13A1\n++MAC (#TRANENT) ASSEM(HASPPRPU) DISTLIB(RICEHSRC).\n         MACRO                                                  RUA13A1\n         #TRANENT &DOC=NO                                       RUA13A1\n         AIF   ('&DOC' NE 'YES').A                              RUA13A1\n.A       TITLE 'HASP PRINT TRAIN TABLE ENTRY'                   RUA13A1\n#TRANENT DSECT                                                  RUA13A1\n#TRANAME DS    CL4            TRAIN NAME                        RUA13A1\n#TRNCST  DS    F              COST MULTIPLIER 1000THS OF CENTS  RUA13A1\n#TRANFLG DS    X              FLAGS                             RUA13A1\n#TRN$SET EQU   X'80'          SETUP CHARGE REQUIRED             RUA13A1\n#TRNELEN EQU   *-#TRANAME     LENGTH OF TRAIN ENTRY             RUA13A1\n&SYSECT  CSECT ,                                                RUA13A1\n         MEND                                                   RUA13A1\n++MACUPD ($SMF).\n./ CHANGE NAME=$SMF\n         COPY  #UA13A11       COPY NEW FIELDS                   RUA13A1 HB129042\n++MAC (#UA13A11)  ASSEM(HASPPRPU,HASPDOC) DISTLIB(RICEHSRC).\nSMF6$PNM DS    CL20           PROGRAMMER NAME FIELD             RUA13A1\n         SPACE 1                                                RUA13A1\n*        COST FIELDS                                            RUA13A1\n         SPACE 1                                                RUA13A1\nSMF6COST DS    0F             START OF COST FIELDS              RUA13A1\nSMF6TOT$ DS    F              TOTAL COST FOR THIS PRINT/PUNCH   RUA13A1\nSMF6FCST DS    F              FORMS COST (1000THS OF CENTS)     RUA13A1\nSMF6LCST DS    F              LINE COST (1000THS OF CENTS)      RUA13A1\nSMF6SCST DS    F              TOTAL SETUP COST                  RUA13A1\n         DS    F              RESERVED COST FIELD               RUA13A1\nSMF6CSTL EQU   *-SMF6COST     LENGTH OF COST FIELDS             RUA13A1\n         SPACE 1                                                RUA13A1\n*        RATE FIELDS                                            RUA13A1\n         SPACE 1                                                RUA13A1\nSMF6RATE DS    0F             START OF RATE FIELDS              RUA13A1\nSMF6FMUL DS    F              COST/FORM USED                    RUA13A1\nSMF6TMUL DS    F              TRAIN MULTIPLIER USED             RUA13A1\nSMF6LRAT DS    F              COST/LINE USED                    RUA13A1\nSMF6FSET DS    F              FORMS SETUP CHARGES               RUA13A1\nSMF6CSET DS    F              CTAPE SETUP CHARGES               RUA13A1\nSMF6TSET DS    F              TRAIN SETUP CHARGES               RUA13A1\nSMF6BSET DS    F              BASE SETUP CHARGE                 RUA13A1\n         DS    F              RESERVED RATE FIELD               RUA13A1\nSMF6RATL EQU   *-SMF6RATE     LENGTH OF RATE FIELDS             RUA13A1\n         SPACE 1                                                RUA13A1\n*        VARIOUS FLAGS                                          RUA13A1\n         SPACE 1                                                RUA13A1\nSMF6SFLG DS    X              COPY OF PPIFLG1                   RUA13A1\nSMF6UNKF EQU   X'80'          UNKNOWN FORM                      RUA13A1\nSMF6UNKT EQU   X'40'          UNKNOWN TRAIN                     RUA13A1\nSMF6UNKC EQU   X'20'          UNKNOWN CARRIAGE TAPE             RUA13A1\nSMF6LPI8 EQU   X'10'          8 LPI                             RUA13A1\n*        EQU   X'08'          (INTERNAL FLAG BIT)               RUA13A1\nSMF6$ABL EQU   X'04'          CHARGEABLE DEVICE (LCL ROUTE)     RUA13A1\nSMF6ANYT EQU   X'02'          NO TRAIN SPECIFIED                RUA13A1\nSMF6ANYC EQU   X'01'          NO CARRIAGE TAPE SPECIFIED        RUA13A1\n         SPACE 1                                                RUA13A1\nSMF6IFLG DS    X              MORE FLAGS                        RUA13A1\nSMF6OPRF EQU   X'80'          OPERATOR OVERRODE FORM            RUA13A1\nSMF6OPRC EQU   X'40'          OPERATOR OVERRODE CARRIAGE TAPE   RUA13A1\nSMF6OPRT EQU   X'20'          OPERATOR OVERRODE TRAIN           RUA13A1\nSMF6IPCH EQU   X'10'          PUNCH DATA SET                    RUA13A1\nSMF6IFST EQU   X'08'          FORMS SETUP CHARGED               RUA13A1\nSMF6ICST EQU   X'04'          CTAPE SETUP CHARGED               RUA13A1\nSMF6ITST EQU   X'02'          TRAIN SETUP CHARGED               RUA13A1\nSMF6IBST EQU   X'01'          BASE SETUP CHARGED                RUA13A1\n         DS    XL2            RESERVED                          RUA13A1\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RUA13M1": {"ttr": 8217, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "++USERMOD (RUA13M1)\n   /* THIS MODIFICATION TO HASPINIT INTRODUCES THE NEW PARMETER\n      STATEMENTS REQUIRED FOR BUILDING THE FORMS, CTAPE, AND TRAIN\n      TABLES USED BY HASPPRPU FOR PAGE COUNTING.                  */.\n++VER (Z038) FMID(EJE1102)\n              REQ(RUA13A1,RUA13Q1                           /* ICSA */).\n++MAC (#UA13M11) ASSEM(HASPINIT) DISTLIB(RICEHSRC).\n         TITLE 'HASP INITIALIZATION -- MAXFORM/TAPE/TRAN ROUTN' RUA13M1\nNPLFRMGT NULL  ,                                                RUA13M1\n         BAL   WC,NPLNUMBR        EXTRACT AND CHECK NUMBER      RUA13M1\n         LR    WC,R1              SAVE THE NUMBER FOR LATER     RUA13M1\n         MH    R1,=AL2(#FRMELEN)  COMPUTE                       RUA13M1\n         LA    R1,#FRMENT1-#FORMTBL(,R1) SIZE                   RUA13M1\n         LR    R0,R1                  OF TABLE                  RUA13M1\n         GETMAIN R,LV=(0)         OBTAIN SPACE FOR TABLE        RUA13M1\n         ST    R1,$FORMTBL        SAVE POINTER                  RUA13M1\n         USING #FORMTBL,R1                                      RUA13M1\n         MVC   #FORMEYE,=CL8'#FORMTBL' COPY IN EYECATCHER       RUA13M1\n         XC    #FRM#ENT,#FRM#ENT  CLEAR ENTRY COUNTER           RUA13M1\n         DROP  R1                                               RUA13M1\n         LR    R1,WC              RE-OBTAIN NUMBER              RUA13M1\n         B     NPLSTORE             AND GO STORE VALUE          RUA13M1\n         SPACE 3                                                RUA13M1\nNPLTAPGT NULL  ,                                                RUA13M1\n         BAL   WC,NPLNUMBR        EXTRACT AND CHECK NUMBER      RUA13M1\n         LR    WC,R1              SAVE THE NUMBER FOR LATER     RUA13M1\n         MH    R1,=AL2(#CTPELEN)  COMPUTE                       RUA13M1\n         LA    R1,#CTPENT1-#CTAPTBL(,R1) SIZE                   RUA13M1\n         LR    R0,R1                  OF TABLE                  RUA13M1\n         GETMAIN R,LV=(0)         OBTAIN SPACE FOR TABLE        RUA13M1\n         ST    R1,$CTAPTBL        SAVE POINTER                  RUA13M1\n         USING #CTAPTBL,R1                                      RUA13M1\n         MVC   #CTAPEYE,=CL8'#CTAPTBL' COPY IN EYECATCHER       RUA13M1\n         XC    #CTP#ENT,#CTP#ENT  CLEAR ENTRY COUNTER           RUA13M1\n         DROP  R1                                               RUA13M1\n         LR    R1,WC              RE-OBTAIN NUMBER              RUA13M1\n         B     NPLSTORE             AND GO STORE VALUE          RUA13M1\n         SPACE 3                                                RUA13M1\nNPLTRNGT NULL  ,                                                RUA13M1\n         BAL   WC,NPLNUMBR        EXTRACT AND CHECK NUMBER      RUA13M1\n         LR    WC,R1              SAVE THE NUMBER FOR LATER     RUA13M1\n         MH    R1,=AL2(#TRNELEN)  COMPUTE                       RUA13M1\n         LA    R1,#TRNENT1-#TRAINS(,R1) SIZE                    RUA13M1\n         LR    R0,R1                  OF TABLE                  RUA13M1\n         GETMAIN R,LV=(0)         OBTAIN SPACE FOR TABLE        RUA13M1\n         ST    R1,$TRAINS         SAVE POINTER                  RUA13M1\n         USING #TRAINS,R1                                       RUA13M1\n         MVC   #TRANEYE,=CL8'#TRAINS'  COPY IN EYECATCHER       RUA13M1\n         XC    #TRN#ENT,#TRN#ENT  CLEAR ENTRY COUNTER           RUA13M1\n         DROP  R1                                               RUA13M1\n         LR    R1,WC              RE-OBTAIN NUMBER              RUA13M1\n         B     NPLSTORE             AND GO STORE VALUE          RUA13M1\n         SPACE 3                                                RUA13M1\n         TITLE 'HASP INITIALIZATION -- FORM PARM PROCESSING'    RUA13M1\nNPLFRMNN NULL  ,                                                RUA13M1\n         LA    WA,3(,WA)          POINT TO THE \"M\" IN FORM      RUA13M1\n         BXH   WA,R14,NPLSSERR    GET NEXT CHARACTER            RUA13M1\n         CLI   0(WA),X'F0'        TEST                          RUA13M1\n         BL    NPLSSERR           INVALID IF NOT NUMERIC        RUA13M1\n         BAL   WE,NPLDCONV        GET FORM NUMBER               RUA13M1\n         B     NPLFMERR           BR IF ILLEGAL NUMBER      +0  RUA13M1\n         CLI   0(WA),C' '         TEST TERMINATOR CHARACTER +4  RUA13M1\n         BNE   NPLFMERR           INVALID IF NOT BLANK          RUA13M1\n         LTR   R0,R1              TEST FORM NUMBER              RUA13M1\n         BZ    NPLFMERR           INVALID IF ZERO               RUA13M1\n         CH    R0,$MAXFRMS          OR GREATER                  RUA13M1\n         BH    NPLFMERR               THAN MAX                  RUA13M1\n         L     R1,$FORMTBL        POINT TO TABLE                RUA13M1\n         L     WE,#FRM#ENT-#FORMTBL(,R1) INCREMENT ENTRY COUNT  RUA13M1\n         LA    WE,1(,WE)                                        RUA13M1\n         ST    WE,#FRM#ENT-#FORMTBL(,R1) SAVE NEW COUNT         RUA13M1\n         LA    R1,#FRMENT1-#FORMTBL(,R1) AND FIRST ENTRY        RUA13M1\n         BCTR  WE,0               COMPUTE OFFSET                RUA13M1\n         MH    WE,=AL2(#FRMELEN)    INTO TABLE                  RUA13M1\n         AR    R1,WE              POINT TO APPROPRIATE ENTRY    RUA13M1\n         L     R0,=A(NPLFRMST)    GET ADDRESS OF SCAN TABLE     RUA13M1\n         BAL   WE,NPLSSCAN        SCAN SUB-PARAMETERS           RUA13M1\n         B     NPLCOMNT           PROCESS AS COMMEND STATEMENT  RUA13M1\n         SPACE 3                                                RUA13M1\nNPLFMERR NULL  ,                  INVALID FORM NUMBER           RUA13M1\n         L     R1,=A(NPLFMERM)    POINT TO INVALID FORM MSG     RUA13M1\n         B     NPLERMSG             AND BR TO ISSUE DIAGNOSTIC  RUA13M1\n         TITLE 'HASP INITIALIZATION -- TRAIN PARM PROCESSING'   RUA13M1\nNPLTRNNN NULL  ,                                                RUA13M1\n         LA    WA,4(,WA)          POINT TO THE \"N\" IN TRAIN     RUA13M1\n         BXH   WA,R14,NPLSSERR    GET NEXT CHARACTER            RUA13M1\n         CLI   0(WA),X'F0'        TEST                          RUA13M1\n         BL    NPLSSERR           INVALID IF NOT NUMERIC        RUA13M1\n         BAL   WE,NPLDCONV        GET FORM NUMBER               RUA13M1\n         B     NPLTRERR           BR IF ILLEGAL NUMBER      +0  RUA13M1\n         CLI   0(WA),C' '         TEST TERMINATOR CHARACTER +4  RUA13M1\n         BNE   NPLTRERR           INVALID IF NOT BLANK          RUA13M1\n         LTR   R0,R1              TEST TRAIN NUMBER             RUA13M1\n         BZ    NPLTRERR           INVALID IF ZERO               RUA13M1\n         CH    R0,$MAXTRNS          OR GREATER                  RUA13M1\n         BH    NPLTRERR               THAN MAX                  RUA13M1\n         L     R1,$TRAINS         POINT TO TABLE                RUA13M1\n         L     WE,#TRN#ENT-#TRAINS(,R1) INCREMENT ENTRY COUNT   RUA13M1\n         LA    WE,1(,WE)                                        RUA13M1\n         ST    WE,#TRN#ENT-#TRAINS(,R1) SAVE NEW COUNT          RUA13M1\n         LA    R1,#TRNENT1-#TRAINS(,R1) POINT TO FIRST ENTRY    RUA13M1\n         BCTR  WE,0               COMPUTE OFFSET                RUA13M1\n         MH    WE,=AL2(#TRNELEN)    INTO TABLE                  RUA13M1\n         AR    R1,WE              POINT TO APPROPRIATE ENTRY    RUA13M1\n         L     R0,=A(NPLTRNST)    GET ADDRESS OF SCAN TABLE     RUA13M1\n         BAL   WE,NPLSSCAN        SCAN SUB-PARAMETERS           RUA13M1\n         B     NPLCOMNT           PROCESS AS COMMEND STATEMENT  RUA13M1\n         SPACE 3                                                RUA13M1\nNPLTRERR NULL  ,                  INVALID TRAIN NUMBER          RUA13M1\n         L     R1,=A(NPLTRERM)    POINT TO INVALID TRAIN MSG    RUA13M1\n         B     NPLERMSG             AND BR TO ISSUE DIAGNOSTIC  RUA13M1\n         TITLE 'HASP INITIALIZATION -- CTAPE PARM PROCESSING'   RUA13M1\nNPLCTPNN NULL  ,                                                RUA13M1\n         LA    WA,4(,WA)          POINT TO THE \"E\" IN CTAPE     RUA13M1\n         BXH   WA,R14,NPLSSERR    GET NEXT CHARACTER            RUA13M1\n         CLI   0(WA),X'F0'        TEST                          RUA13M1\n         BL    NPLSSERR           INVALID IF NOT NUMERIC        RUA13M1\n         BAL   WE,NPLDCONV        GET FORM NUMBER               RUA13M1\n         B     NPLTPERR           BR IF ILLEGAL NUMBER      +0  RUA13M1\n         CLI   0(WA),C' '         TEST TERMINATOR CHARACTER +4  RUA13M1\n         BNE   NPLTPERR           INVALID IF NOT BLANK          RUA13M1\n         LTR   R0,R1              TEST CTAPE NUMBER             RUA13M1\n         BZ    NPLTPERR           INVALID IF ZERO               RUA13M1\n         CH    R0,$MAXCTPS          OR GREATER                  RUA13M1\n         BH    NPLTPERR               THAN MAX                  RUA13M1\n         L     R1,$CTAPTBL        POINT TO TABLE                RUA13M1\n         L     WE,#CTP#ENT-#CTAPTBL(,R1) INCREMENT ENTRY COUNT  RUA13M1\n         LA    WE,1(,WE)                                        RUA13M1\n         ST    WE,#CTP#ENT-#CTAPTBL(,R1) SAVE NEW COUNT         RUA13M1\n         LA    R1,#CTPENT1-#CTAPTBL(,R1) POINT TO FIRST ENTRY   RUA13M1\n         BCTR  WE,0               COMPUTE OFFSET                RUA13M1\n         MH    WE,=AL2(#CTPELEN)    INTO TABLE                  RUA13M1\n         AR    R1,WE              POINT TO APPROPRIATE ENTRY    RUA13M1\n         L     R0,=A(NPLCTPST)    GET ADDRESS OF SCAN TABLE     RUA13M1\n         BAL   WE,NPLSSCAN        SCAN SUB-PARAMETERS           RUA13M1\n         B     NPLCOMNT           PROCESS AS COMMEND STATEMENT  RUA13M1\n         SPACE 3                                                RUA13M1\nNPLTPERR NULL  ,                  INVALID CTAPE NUMBER          RUA13M1\n         L     R1,=A(NPLTPERM)    POINT TO INVALID CTAPE MSG    RUA13M1\n         B     NPLERMSG             AND BR TO ISSUE DIAGNOSTIC  RUA13M1\n         TITLE 'HASP INITIALIZATION -- PUNCH PARM PROCESSING'   RUA13M1\nNPLCNLM  NULL  ,                                                RUA13M1\n         LA    WA,2(,WA)          POINT TO THE \"P\" IN CTP       RUA13M1\n         BXH   WA,R14,NPLSSERR    GET NEXT CHARACTER            RUA13M1\n         CLI   0(WA),X'F0'        TEST                          RUA13M1\n         BL    NPLSSERR           INVALID IF NOT NUMERIC        RUA13M1\n         BAL   WE,NPLDCONV        GET FORM NUMBER               RUA13M1\n         B     NPLTPERR           BR IF ILLEGAL NUMBER      +0  RUA13M1\n         CLI   0(WA),C'.'         TEST TERMINATOR CHARACTER +4  RUA13M1\n         BNE   NPLSSERR           INVALID IF NOT BLANK          RUA13M1\n         LTR   R0,R1              TEST CTAPE NUMBER             RUA13M1\n         BZ    NPLTPERR           INVALID IF ZERO               RUA13M1\n         CH    R0,$MAXCTPS          OR GREATER                  RUA13M1\n         BH    NPLTPERR               THAN MAX                  RUA13M1\n         L     R1,$CTAPTBL        POINT TO TABLE                RUA13M1\n         C     R0,#CTP#ENT-#CTAPTBL(,R1) ILLEGAL IF PAST LAST   RUA13M1\n         BH    NPLTPERR             CARRIAGE TAPE SEEN          RUA13M1\n         LA    R1,#CTPENT1-#CTAPTBL(,R1) POINT TO FIRST ENTRY   RUA13M1\n         BCTR  R0,0               COMPUTE OFFSET                RUA13M1\n         MH    R0,=AL2(#CTPELEN)    INTO TABLE                  RUA13M1\n         AR    R1,R0              POINT TO APPROPRIATE ENTRY    RUA13M1\n         LR    WC,R1              SAVE ENTRY POINTER            RUA13M1\n         CLC   1(4,WA),=CL4'LINE' CHECK REST OF NAME            RUA13M1\n         BNE   NPLTLERR           INVALID IF NOT LINENNN        RUA13M1\n         LA    WA,5(,WA)          BUMP PAST \"LINE\" IF OK        RUA13M1\n         BAL   WE,NPLDCONV        GET CTAPE LINE NUMBER         RUA13M1\n         B     NPLTLERR           BR IF ILLEGAL NUMBER      +0  RUA13M1\n         CLI   0(WA),C' '         TEST TERMINATOR CHARACTER +4  RUA13M1\n         BNE   NPLSSERR           INVALID IF NOT BLANK          RUA13M1\n         LTR   R0,R1              TEST LINE NUMBER              RUA13M1\n         BZ    NPLTLERR           INVALID IF ZERO               RUA13M1\n         CH    R0,#CTAPLEN-#CTAPENT(,WC) OR GREATER             RUA13M1\n         BH    NPLTLERR              THAN MAX                   RUA13M1\n         LA    R1,#CTAPMAP-#CTAPENT(,WC) POINT TO PUNCH MAP     RUA13M1\n         BCTR  R0,0               COMPUTE PUNCH POSITION        RUA13M1\n         AR    R1,0                                             RUA13M1\n         L     R0,=A(NPLPUNST)    GET ADDRESS OF SCAN TABLE     RUA13M1\n         BAL   WE,NPLSSCAN        SCAN SUB-PARAMETERS           RUA13M1\n         B     NPLCOMNT           PROCESS AS COMMENT STATEMENT  RUA13M1\n         SPACE 3                                                RUA13M1\nNPLTLERR NULL  ,                  INVALID CTAPE LINE NUMBER     RUA13M1\n         L     R1,=A(NPLTLERM)    POINT TO INVALID LINE MSG     RUA13M1\n         B     NPLERMSG             AND BR TO ISSUE DIAGNOSTIC  RUA13M1\n++MAC (#UA13M12) ASSEM(HASPINIT) DISTLIB(RICEHSRC).\nNPLFRMST $SCNTBL #FORMENT         FORM SCAN TABLE               RUA13M1\n         PUSH  PRINT                                            RUA13M1\n         PRINT NOGEN                                            RUA13M1\n         $SCNTBL NAME,L'#FRMNAME,#FRMNAME,NSCFLEFT+NSCFLBLK     RUA13M1\n         $SCNTBL LINES8,L'#FRM8LPI,#FRM8LPI,NSCFLBIN            RUA13M1\n         $SCNTBL LINES6,L'#FRM6LPI,#FRM6LPI,NSCFLBIN            RUA13M1\n         $SCNTBL COST,L'#FRMCST,#FRMCST,NSCFLBIN                RUA13M1\n         $SCNTBL (SETUP,NOSETUP),#FRM$SET,#FRMFLGS              RUA13M1\n         $SCNTBL                  END OF SCAN TABLE             RUA13M1\n         POP   PRINT                                            RUA13M1\n         SPACE 3                                                RUA13M1\nNPLCTPST $SCNTBL #CTAPENT         CTAP SCAN TABLE               RUA13M1\n         PUSH  PRINT                                            RUA13M1\n         PRINT NOGEN                                            RUA13M1\n         $SCNTBL NAME,L'#CTAPNAM,#CTAPNAM,NSCFLEFT+NSCFLBLK     RUA13M1\n         $SCNTBL LPI,L'#CTAPLPI,#CTAPLPI,NSCFLBIN               RUA13M1\n         $SCNTBL LINES,L'#CTAPLEN,#CTAPLEN,NSCFLBIN             RUA13M1\n         $SCNTBL (SETUP,NOSETUP),#CTP$SET,#CTAPFLG              RUA13M1\n         $SCNTBL                  END OF SCAN TABLE             RUA13M1\n         POP   PRINT                                            RUA13M1\n         SPACE 3                                                RUA13M1\nNPLPUNST $SCNTBL 0                PUNCH SCAN TABLE              RUA13M1\n         PUSH  PRINT                                            RUA13M1\n         PRINT NOGEN                                            RUA13M1\n         $SCNTBL PUNCH,1,0,NSCFLBIN                             RUA13M1\n         $SCNTBL                  END OF SCAN TABLE             RUA13M1\n         POP   PRINT                                            RUA13M1\n         SPACE 3                                                RUA13M1\nNPLTRNST $SCNTBL #TRANENT         TRAIN SCAN TABLE              RUA13M1\n         PUSH  PRINT                                            RUA13M1\n         PRINT NOGEN                                            RUA13M1\n         $SCNTBL NAME,L'#TRANAME,#TRANAME,NSCFLEFT+NSCFLBLK     RUA13M1\n         $SCNTBL COST,L'#TRNCST,#TRNCST,NSCFLBIN                RUA13M1\n         $SCNTBL (SETUP,NOSETUP),#TRN$SET,#TRANFLG              RUA13M1\n         $SCNTBL                  END OF SCAN TABLE             RUA13M1\n         POP   PRINT                                            RUA13M1\n         SPACE 3                                                RUA13M1\n++MAC (#UA13M13) ASSEM(HASPINIT) DISTLIB(RICEHSRC).\nNPLFMERM DC    CL38'*****    INVALID FORM NUMBER     *****'     RUA13M1\nNPLTPERM DC    CL38'*****    INVALID CTAPE NUMBER    *****'     RUA13M1\nNPLTRERM DC    CL38'*****    INVALID TRAIN NUMBER    *****'     RUA13M1\nNPLTLERM DC    CL38'***** INVALID CTAPE LINE NUMBER  *****'     RUA13M1\n++MAC (#UA13M14) ASSEM(HASPINIT) DISTLIB(RICEHSRC).\n****************************************************************RUA13M1\n*                                                               RUA13M1\n*        CREATE FORMS/TRAINS/CTAPES DEFAULTS IF NONE SPECIFIED  RUA13M1\n*                                                               RUA13M1\n****************************************************************RUA13M1\n         SPACE 1                                                RUA13M1\n         ICM   R15,15,$MAXFRMS       SEE IF TABLE EXISTS        RUA13M1\n         BZ    #UA13M41              NO, LEAVE AS IS            RUA13M1\n         L     R15,$FORMTBL          POINT TO TABLE             RUA13M1\n         USING #FORMTBL,R15                                     RUA13M1\n         ICM   R14,15,#FRM#ENT       SEE IF ANY ENTRIES         RUA13M1\n         BNZ   #UA13M41              YES, LEAVE AS IS           RUA13M1\n         LA    R14,1                 NO.  CREATE ONE            RUA13M1\n         ST    R14,#FRM#ENT          INDICATE 1 ENTRY           RUA13M1\n         DROP  R15                                              RUA13M1\n#UA13M41 NULL  ,                                                RUA13M1\n         ICM   R15,15,$MAXTRNS       SEE IF TABLE EXISTS        RUA13M1\n         BZ    #UA13M42              NO, LEAVE AS IS            RUA13M1\n         L     R15,$TRAINS           POINT TO TABLE             RUA13M1\n         USING #TRAINS,R15                                      RUA13M1\n         ICM   R14,15,#TRN#ENT       SEE IF ANY ENTRIES         RUA13M1\n         BNZ   #UA13M42              YES, LEAVE AS IS           RUA13M1\n         LA    R14,1                 NO.  CREATE ONE            RUA13M1\n         ST    R14,#TRN#ENT          INDICATE 1 ENTRY           RUA13M1\n         DROP  R15                                              RUA13M1\n#UA13M42 NULL  ,                                                RUA13M1\n         ICM   R15,15,$MAXCTPS       SEE IF TABLE EXISTS        RUA13M1\n         BZ    #UA13M43              NO, LEAVE AS IS            RUA13M1\n         L     R15,$CTAPTBL          POINT TO TABLE             RUA13M1\n         USING #CTAPTBL,R15                                     RUA13M1\n         ICM   R14,15,#CTP#ENT       SEE IF ANY ENTRIES         RUA13M1\n         BNZ   #UA13M43              YES, LEAVE AS IS           RUA13M1\n         LA    R14,1                 NO.  CREATE ONE            RUA13M1\n         ST    R14,#CTP#ENT          INDICATE 1 ENTRY           RUA13M1\n         LA    R15,#CTPENT1          POINT TO FIRST ENTRY       RUA13M1\n         USING #CTAPENT,R15                                     RUA13M1\n         LA    R14,2                                            RUA13M1\n         STH   R14,#CTAPLEN          INDICATE 2 LINE CTAPE      RUA13M1\n         XC    #CTAPMAP,#CTAPMAP     CLEAR PUNCH MAP            RUA13M1\n         DROP  R15                                              RUA13M1\n#UA13M43 NULL  ,                                                RUA13M1\n         SPACE 1                                                RUA13M1\n++SRCUPD (HASPINIT).\n./ CHANGE NAME=HASPINIT\n         #FORMTBL                  GENERATE HASP FORMTBL DSECT  RUA13M1 M0112510\n         #CTAPTBL                  GENERATE HASP CTAPTBL DSECT  RUA13M1 M0112520\n         #TRAINS                   GENERATE HASP TRAINS DSECT   RUA13M1 M0112530\n         #FORMENT                  GENERATE HASP FORMENT DSECT  RUA13M1 M0112540\n         #CTAPENT                  GENERATE HASP CTAPENT DSECT  RUA13M1 M0112550\n         #TRANENT                  GENERATE HASP TRANENT DSECT  RUA13M1 M0112560\n         COPY  #UA13M11           COPY NEW PROCESSING ROUTINES  RUA13M1 M1248000\n         MVI   C'*'(R1),1         DISALLOW ASTERISK IN KEYWORD  RUA13M1 M1696210\n         MVI   C'*'(R1),0         ALLOW ASTERISK AS VALUE       RUA13M1 M1711100\n         COPY  #UA13M12           COPY NEW SCAN TABLES          RUA13M1 M1978100\n         COPY  #UA13M13           COPY NEW ERROR MESSAGES       RUA13M1 M1987000\n         $PTENT ,&&MAXFRMS,NPLFRMGT,,,,(1,999)                  RUA13M1 M2063700\n         $PTENT ,&&MAXCTPS,NPLTAPGT,,,,(1,99)                   RUA13M1 M2063710\n         $PTENT ,&&MAXTRNS,NPLTRNGT,,,,(1,20)                   RUA13M1 M2063720\n         $PTENT ,&&LNECST,,,,,(1,99999999)                      RUA13M1 M2063730\n         $PTENT ,&&PUNCST,,,,,(1,99999999)                      RUA13M1 M2063740\n         $PTENT ,&&FSTCST,,,,,(1,99999999)                      RUA13M1 M2063750\n         $PTENT ,&&CSTCST,,,,,(1,99999999)                      RUA13M1 M2063760\n         $PTENT ,&&TSTCST,,,,,(1,99999999)                      RUA13M1 M2063770\n         $PTENT ,&&BSTCST,,,,,(1,99999999)                      RUA13M1 M2063780\n         $PTENT 5,CTAPE,NPLCTPNN                     CTAPENN    RUA13M1 M2076600\n         $PTENT 5,TRAIN,NPTTRNNN                     TRAINNN    RUA13M1 M2076610\n         $PTENT 4,FORM,NPLFRMNN                      FORMNN     RUA13M1 M2078100\n         $PTENT 3,CTP,NPLCNLM                    CTPNN.LINENNN  RUA13M1 M2078600\n         COPY  #UA13M14                                         RUA13M1 M2113000\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RUA13Q1": {"ttr": 8454, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "++USERMOD (RUA13Q1)\n   /* ICSA HASPPRPU MODIFICATIONS TO SUPPORT PAGE COUNTING.\n      THE PAGE COUNT FOR SMF TYPE 6 RECORDS IS COMPUTED\n      IN A DIFFERENT MANNER IN ORDER TO BE ACCURATE          */.\n++VER (Z038) FMID(EJE1102)\n              PRE(RUA04A1,RUA04Q1                           /* ICSA */)\n              REQ(RUA13A1,RUA13M1                           /* ICSA */).\n++MACUPD (#ICSATY6).\n./ CHANGE NAME=#ICSATY6\n         MVC   SMF6$PNM,JCTPNAME    INSERT PROGRAMMER NAME FIELDRUA13Q1\n         XC    SMF6COST(SMF6CSTL),SMF6COST ZERO COST FIELDS     RUA13A1\n         MVC   SMF6BSET,PBSETCST    COPY BASE SETUP CHARGE      RUA13Q1\n         MVC   SMF6FSET,PFSETCST    COPY SETUP COST             RUA13Q1\n         MVC   SMF6CSET,PCSETCST    COPY SETUP COST             RUA13Q1\n         MVC   SMF6TSET,PTSETCST    COPY SETUP COST             RUA13Q1\n         MVC   SMF6SFLG,PPIFLG1     COPY FLAGS                  RUA13Q1\n         XC    SMF6IFLG,SMF6IFLG    CLEAR EXTRA FLAGS           RUA13Q1\n         STM   PC1,PC2,$DOUBLE      SAVE REGISTERS              RUA13Q1\n         L     PC2,PCEDCT           FIND THE DCT                RUA13Q1\n         L     PL,PCHJOE              AND THE CHAR-JOE          RUA13Q1\n         USING DCTDSECT,PC2                                     RUA13Q1\n         USING JOEDSECT,PL                                      RUA13Q1\n         CLC   DCTFORMS,JOEFORM     FORMS THE SAME?             RUA13Q1\n         BE    #T6NFOVR             YES                         RUA13Q1\n         OI    SMF6IFLG,SMF6OPRF    NO, INDICATE FORMS OVERRIDE RUA13Q1\n#T6NFOVR TM    PPIFLG1,PPI1CSTR     CTAPE SPECIFIED?            RUA13Q1\n         BO    #T6NCOVR             NO, SKIP COMPARISON         RUA13Q1\n         CLC   DCTFCB,JOEFCB        CTAPE THE SAME?             RUA13Q1\n         BE    #T6NCOVR             YES                         RUA13Q1\n         OI    SMF6IFLG,SMF6OPRC    NO, INDICATE CTAPE OVERRIDE RUA13Q1\n#T6NCOVR TM    PPIFLG1,PPI1TSTR     TRAIN SPECIFIED?            RUA13Q1\n         BO    #T6NTOVR             NO, SKIP COMPARISON         RUA13Q1\n         CLC   DCTUCS,JOEUCS        TRAIN THE SAME?             RUA13Q1\n         BE    #T6NTOVR             YES                         RUA13Q1\n         OI    SMF6IFLG,SMF6OPRT    NO, INDICATE TRAIN OVERRIDE RUA13Q1\n         DROP  PC2,PL                                           RUA13Q1\n#T6NTOVR TM    PPIFLG1,PPI1LOCL     DO WE CHARGE?               RUA13Q1\n         BNO   #T6REMOT             NO                          RUA13Q1\n         L     PL,PCEDCT            FIND DCT                    RUA13Q1\n         USING DCTDSECT,PL                                      RUA13Q1\n         TM    DCTDEVTP,DCTPRPU     IS IT A LOCAL PRT/PUN?      RUA13Q1\n         BO    #T6REMOT             YES, DON'T CHARGE           RUA13Q1\n         DROP  PL                                               RUA13Q1\n         MVC   SMF6TOT$,SMF6BSET    INITIALIZE TOTAL COST       RUA13Q1\n         MVC   SMF6SCST,SMF6BSET      AND SETUP COST            RUA13Q1\n         OI    SMF6IFLG,SMF6IBST    INDICATE BASE SETUP CHARGED RUA13Q1\n         TM    PPIFLG2,PPI2FSET     FORMS SETUP?                RUA13Q1\n         BNO   #T6NOFST             NO                          RUA13Q1\n         OI    SMF6IFLG,SMF6IFST    YES, INDICATE               RUA13Q1\n         L     PC2,PFSETCST         UPDATE                      RUA13Q1\n         AL    PC2,SMF6TOT$           TOTAL                     RUA13Q1\n         ST    PC2,SMF6TOT$             COST                    RUA13Q1\n         L     PC2,SMF6FSET         UPDATE TOTAL                RUA13Q1\n         AL    PC2,SMF6SCST           SETUP COST                RUA13Q1\n         ST    PC2,SMF6SCST                                     RUA13Q1\n#T6NOFST TM    PPIFLG2,PPI2CSET     CTAPE SETUP?                RUA13Q1\n         BNO   #T6NOCST             NO                          RUA13Q1\n         OI    SMF6IFLG,SMF6ICST    YES, INDICATE               RUA13Q1\n         L     PC2,PCSETCST         UPDATE                      RUA13Q1\n         AL    PC2,SMF6TOT$           TOTAL                     RUA13Q1\n         ST    PC2,SMF6TOT$             COST                    RUA13Q1\n         L     PC2,SMF6CSET         UPDATE TOTAL                RUA13Q1\n         AL    PC2,SMF6SCST           SETUP COST                RUA13Q1\n         ST    PC2,SMF6SCST                                     RUA13Q1\n#T6NOCST TM    PPIFLG2,PPI2TSET     TRAIN SETUP?                RUA13Q1\n         BNO   #T6NOTST             NO                          RUA13Q1\n         OI    SMF6IFLG,SMF6ITST    YES, INDICATE               RUA13Q1\n         L     PC2,PTSETCST         UPDATE                      RUA13Q1\n         AL    PC2,SMF6TOT$           TOTAL                     RUA13Q1\n         ST    PC2,SMF6TOT$             COST                    RUA13Q1\n         L     PC2,SMF6TSET         UPDATE TOTAL                RUA13Q1\n         AL    PC2,SMF6SCST           SETUP COST                RUA13Q1\n         ST    PC2,SMF6SCST                                     RUA13Q1\n#T6NOTST L     PC2,PRPAGECT         COMPUTE PAGE COST           RUA13Q1\n         SLR   PC1,PC1                                          RUA13Q1\n         M     PC1,PPFRMCST                                     RUA13Q1\n         L     PC1,$DOUBLE          RESTORE BASE REGISTER       RUA13Q1\n         ST    PC2,SMF6FCST         SAVE FOR FORMS              RUA13Q1\n         AL    PC2,SMF6TOT$           AND TOTAL                 RUA13Q1\n         ST    PC2,SMF6TOT$             COST                    RUA13Q1\n         L     PC2,PPLNCDCT         GET LINE COUNT              RUA13Q1\n         TM    PCEID,PCEPRSID       PRINTER?                    RUA13Q1\n         BO    #T6PRNT1             YES, USE LINE & TRAIN COST  RUA13Q1\n         OI    SMF6IFLG,SMF6IPCH    INDICATE A PUNCH            RUA13Q1\n         SLR   PC1,PC1              COMPUTE LINE COST           RUA13Q1\n         M     PC1,PPNCHCST         NO, USE PUNCH COST          RUA13Q1\n         B     #T6PRNT2                                         RUA13Q1\n         SPACE 1                                                RUA13Q1\n#T6PRNT1 NULL  ,                                                RUA13Q1\n         SLR   PC1,PC1              COMPUTE LINE COST           RUA13Q1\n         M     PC1,PLINECST                                     RUA13Q1\n         M     PC1,PPTRNCST         INCLUDING TRAIN MULTIPLIER  RUA13Q1\n         D     PC1,=F'1000'           FIX UNIT                  RUA13Q1\n#T6PRNT2 NULL  ,                                                RUA13Q1\n         L     PC1,$DOUBLE          RESTORE BASE REGISTER       RUA13Q1\n         ST    PC2,SMF6LCST         SAVE FOR LINE               RUA13Q1\n         AL    PC2,SMF6TOT$           AND TOTAL                 RUA13Q1\n         ST    PC2,SMF6TOT$             COST                    RUA13Q1\n         TM    PCEID,PCEPRSID       PRINTER?                    RUA13Q1\n         BO    #T6PRNT3             YES, USE LINE COST          RUA13Q1\n         MVC   SMF6LRAT,PPNCHCST    NO, USE CARD COST           RUA13Q1\n         LA    PC2,1000             MAKE TRAIN MULTIPLIER       RUA13Q1\n         ST    PC2,SMF6TMUL           WORK                      RUA13Q1\n         B     #T6REMOT                                         RUA13Q1\n         SPACE 1                                                RUA13Q1\n#T6PRNT3 MVC   SMF6FMUL,PPFRMCST    SAVE COST MULTIPLIERS       RUA13Q1\n         MVC   SMF6TMUL,PPTRNCST      AS WELL                   RUA13Q1\n         MVC   SMF6LRAT,PLINECST    COPY LINE COST              RUA13Q1\n         SPACE 1                                                RUA13Q1\n#T6REMOT EQU   *                                                RUA13Q1\n         LM    PC1,PC2,$DOUBLE      RESTORE THOSE REGISTERS     RUA13Q1\n++SRCUPD (HASPPRPU).\n./ CHANGE NAME=HASPPRPU\n         #FORMTBL                  GENERATE HASP FORMTBL DSECT  RUA13Q1 Q0198600\n         #CTAPTBL                  GENERATE HASP CTAPTBL DSECT  RUA13Q1 Q0198610\n         #TRAINS                   GENERATE HASP TRAINS DSECT   RUA13Q1 Q0198620\n         #FORMENT                  GENERATE HASP FORMENT DSECT  RUA13Q1 Q0198630\n         #CTAPENT                  GENERATE HASP CTAPENT DSECT  RUA13Q1 Q0198640\n         #TRANENT                  GENERATE HASP TRANENT DSECT  RUA13Q1 Q0198650\n         L     R15,=A(#PAGESET)     GET PAGE                    RUA13Q1 Q2057210\n         BALR  R14,R15                SETUP INFORMATION         RUA13Q1 Q2057220\n         XC    PPCTPLIN,PPCTPLIN    SET INDICATORS TO           RUA13Q1 Q2207210\n         XC    PPFRMLIN,PPFRMLIN      START A                   RUA13Q1 Q2207212\n         MVI   PCCWORK,X'89'            NEW PAGE                RUA13Q1 Q2207214\nPRNPGCT  L     R15,=A(#CHANSK)      FIND THE                    RUA13Q1 Q2207216\n         BALR  R14,R15                 TOP OF PAGE              RUA13Q1 Q2207218\n         NI    PPIFLG1,X'FF'-PPI1PAGE TURN OFF NEW PAGE FLAG    RUA13Q1 Q2207220\nPRNPGCT  L     R15,=A(#CHANSK)      HANDLE                      RUA13Q1 Q2509000\n         BALR  R14,R15                 CHANNEL SKIPPING         RUA13Q1 Q2509010\n         L     PW,PDDBPGCT         INCREMENT                    RUA13Q1 Q2509020\n         TM    PPIFLG1,PPI1PAGE     NEW PAGE?                   RUA13Q1 Q2559700\n         BNO   PPCKPGS              NO, DON'T INCREMENT COUNTER RUA13Q1 Q2559710\n         NI    PPIFLG1,X'FF'-PPI1PAGE YES, TURN OFF INDICATOR   RUA13Q1 Q2559720\n         L     R15,=A(#LINESP)      HANDLE                      RUA13Q1 Q2564910\n         BALR  R14,R15                 LINE SPACING             RUA13Q1 Q2564920\n         TM    PCEID,PCEPRSID       TEST PROCESSOR TYPE         RUA13Q1 Q2943100\n         BNO   #UA13SK1             SKIP IF NOT PRINT           RUA13Q1 Q2943110\n         MVI   PCCWORK,X'89'        TELL COUNTING               RUA13Q1 Q2943120\n         L     R15,=A(#CHANSK)        WE ARE                    RUA13Q1 Q2943130\n         BALR  R14,R15                  SKIPPING TO CHANNEL 1   RUA13Q1 Q2943140\n         TM    PPIFLG1,PPI1PAGE     REALLY NEED A NEW PAGE      RUA13Q1 Q2943150\n         BNO   #UA13SK1             SKIP IF NOT                 RUA13Q1 Q2943160\n         SLR   PL,PL                CLEAR FOR INSERT            RUA13Q1 Q2943170\n         IC    PL,PREVCPYN          UPDATE PAGE COUNT           RUA13Q1 Q2943180\n         AL    PL,PRPAGECT            WITH NUMBER OF COPIES     RUA13Q1 Q2943190\n         ST    PL,PRPAGECT              THIS TRANSMISSION       RUA13Q1 Q2943200\n#UA13SK1 NULL  ,                                                RUA13Q1 Q2943210\n         TITLE 'HASP PRINT/PUNCH SERVICE -- SETUP INFO LOAD'    RUA13Q1 Q4808100\n         COPY  #UA13Q11             GET SETUP INFORMATION       RUA13Q1 Q4808110\n         TITLE 'HASP PRINT/PUNCH SERVICE -- LINE SPACING'       RUA13Q1 Q4808120\n         COPY  #UA13Q12             HANDLE LINE SPACING         RUA13Q1 Q4808130\n         TITLE 'HASP PRINT/PUNCH SERVICE -- CHANNEL SKIPPING'   RUA13Q1 Q4808140\n         COPY  #UA13Q13             HANDLE SKIPS                RUA13Q1 Q4808150\n         COPY  #UA13Q15             COPY COUNTING CODE          RUA13Q1 Q4870100\n         COPY  #UA13Q14             HANDLE COMMENT SPACING      RUA13Q1 Q5081600\n         LTORG ,                                                RUA13Q1 Q5101100\n         TM    PCEID,PCEPRSID       PRINTER?                    RUA13Q1 Q5248300\n         BO    #PSMF6#1             YES                         RUA13Q1 Q5248310\n         XC    PRPAGECT,PRPAGECT    NO, ZERO PAGE COUNT         RUA13Q1 Q5248320\n#PSMF6#1 NULL  ,                                                RUA13Q1 Q5248330\n++MAC (#UA13Q11) ASSEM(HASPPRPU) DISTLIB(RICEHSRC).\n****************************************************************RUA13Q1\n*        LOCATE THE CURRENT FORM, CTAPE, AND TRAIN IN THE GLOBALRUA13Q1\n*        TABLES AND STORE THE NECESSARY INFORMATION IN PPPWORK  RUA13Q1\n****************************************************************RUA13Q1\n         SPACE 1                                                RUA13Q1\n         PUSH  USING                                            RUA13Q1\n         USING #PAGESET,BASE2     PROVIDE LOCAL ADDRESSABILITY  RUA13Q1\n         USING PDBDSECT,PC2       PROVIDE PDDB ADDRESSABILITY   RUA13Q1\n         SPACE 1                                                RUA13Q1\n#PAGESET ST    BASE2,PPSAVE1      SAVE PREVIOUS BASE REG        RUA13Q1\n         ST    R14,PPSAVE1+4        AND LINK REGISTER           RUA13Q1\n         LR    BASE2,R15          LOAD BASE REGISTER            RUA13Q1\n         SPACE 1                                                RUA13Q1\n****************************************************************RUA13Q1\n*        FIND THE CTAPE INFORMATION                             RUA13Q1\n****************************************************************RUA13Q1\n         SPACE 1                                                RUA13Q1\n         ICM   PC1,15,$CTAPTBL    POINT TO CTAPE TABLE          RUA13Q1\n         BZ    FORMSGET           SKIP IF NONE                  RUA13Q1\n         USING #CTAPTBL,PC1                                     RUA13Q1\n         L     R15,#CTP#ENT       GET NUMBER OF ENTRIES         RUA13Q1\n         LA    PC1,#CTPENT1       POINT TO FIRST ENTRY          RUA13Q1\n         NI    PPIFLG1,X'FF'-(PPI1CDEF+PPI1CSTR) TURN OFF FLAGS RUA13Q1\n         CLC   PDBFCB,=CL4'****'  ANY VALUE SPECIFIED?          RUA13Q1\n         BNE   CTAPFIND           YES, PROCEED                  RUA13Q1\n         OI    PPIFLG1,PPI1CSTR   NO, INDICATE AS SUCH          RUA13Q1\n         USING #CTAPENT,PC1       MAP A CTAPE ENTRY             RUA13Q1\nCTAPFIND CLC   #CTAPNAM,PDBFCB    MATCH?                        RUA13Q1\n         BE    CTAPFOUN           YES, GO FILL IN THE BLANKS    RUA13Q1\n         LA    PC1,#CTPELEN(PC1)  NO, TRY NEXT ENTRY            RUA13Q1\n         BCT   R15,CTAPFIND         AND TRY AGAIN               RUA13Q1\n         SPACE 1                                                RUA13Q1\n         OI    PPIFLG1,PPI1CDEF   NOT FOUND.  MARK DEFAULT USED RUA13Q1\n         L     PC1,$CTAPTBL       AND POINT BACK TO FIRST ENTRY RUA13Q1\n         USING #CTAPTBL,PC1                                     RUA13Q1\n         LA    PC1,#CTPENT1                                     RUA13Q1\n         USING #CTAPENT,PC1                                     RUA13Q1\n         OI    PPIFLG2,PPI2CSET   FORCE SETUP CHARGES           RUA13Q1\n         SPACE 1                                                RUA13Q1\nCTAPFOUN NI    PPIFLG1,X'FF'-PPI18LPI TURN OFF 8 LPI FLAG       RUA13Q1\n         CLI   #CTAPLPI+1,X'08'   8 OR 6 LPI?                   RUA13Q1\n         BNE   CTAP6LPI           6 LPI                         RUA13Q1\n         OI    PPIFLG1,PPI18LPI   INDICATE 8 LPI                RUA13Q1\nCTAP6LPI EQU   *                                                RUA13Q1\n         TM    PPIFLG1,PPI1CDEF   UNKNOWN CTAPE?                RUA13Q1\n         BO    CTAPNSET           LEAVE SETUP FLAG ON IF SO     RUA13Q1\n         NI    PPIFLG2,X'FF'-PPI2CSET TURN OFF CTAPE SETUP FLAG RUA13Q1\n         TM    #CTAPFLG,#CTP$SET  SETUP CHARGE REQUIRED?        RUA13Q1\n         BNO   CTAPNSET           NO                            RUA13Q1\n         OI    PPIFLG2,PPI2CSET   YES, INDICATE SO              RUA13Q1\nCTAPNSET MVC   PPCTPLEN,#CTAPLEN  COPY LENGTH OF CARRIAGE TAPE  RUA13Q1\n         LA    PL,#CTAPMAP        POINT TO PUNCH MAP            RUA13Q1\n         ST    PL,PPCTPMAP        SAVE POINTER                  RUA13Q1\n         DROP  PC1                THROW AWAY CTAPE ENTRY POINTERRUA13Q1\n         SPACE 2                                                RUA13Q1\n****************************************************************RUA13Q1\n*        NOW FIND THE FORMS INFORMATION                         RUA13Q1\n****************************************************************RUA13Q1\n         SPACE 1                                                RUA13Q1\nFORMSGET ICM   PC1,15,$FORMTBL    POINT TO FORMS TABLE          RUA13Q1\n         BZ    TRANSTAT           SKIP IF NONE                  RUA13Q1\n         USING #FORMTBL,PC1                                     RUA13Q1\n         L     R15,#FRM#ENT       GET NUMBER OF ENTRIES         RUA13Q1\n         LA    PC1,#FRMENT1       POINT TO FIRST ENTRY          RUA13Q1\n         NI    PPIFLG1,X'FF'-PPI1FDEF TURN OFF DEFAULT FLAG     RUA13Q1\n         USING #FORMENT,PC1       MAP A FORM ENTRY              RUA13Q1\nFORMFIND CLC   #FRMNAME,PDBFORMS  MATCH?                        RUA13Q1\n         BE    FORMFOUN           YES, GO FILL IN THE BLANKS    RUA13Q1\n         LA    PC1,#FRMELEN(PC1)  NO, TRY NEXT ENTRY            RUA13Q1\n         BCT   R15,FORMFIND         AND TRY AGAIN               RUA13Q1\n         SPACE 1                                                RUA13Q1\n         OI    PPIFLG1,PPI1FDEF   NOT FOUND.  MARK DEFAULT USED RUA13Q1\n         L     PC1,$FORMTBL       AND POINT BACK TO FIRST ENTRY RUA13Q1\n         USING #FORMTBL,PC1                                     RUA13Q1\n         LA    PC1,#FRMENT1                                     RUA13Q1\n         USING #FORMENT,PC1                                     RUA13Q1\n         OI    PPIFLG2,PPI2FSET   FORCE ON SETUP CHARGE FLAG    RUA13Q1\n         B     FORMNSET                                         RUA13Q1\n         SPACE 1                                                RUA13Q1\nFORMFOUN EQU   *                                                RUA13Q1\n         NI    PPIFLG2,X'FF'-PPI2FSET TURN OFF FORMS SETUP FLAG RUA13Q1\n         TM    #FRMFLGS,#FRM$SET  SETUP CHARGE REQUIRED?        RUA13Q1\n         BNO   FORMNSET           NO                            RUA13Q1\n         OI    PPIFLG2,PPI2FSET   YES, INDICATE SO              RUA13Q1\nFORMNSET NULL  ,                                                RUA13Q1\n         MVC   PPFRMCST,#FRMCST   COPY FORM COST                RUA13Q1\n         TM    PPIFLG1,PPI18LPI   8 LPI?                        RUA13Q1\n         BO    FORM8LPI           YES, USE PROPER LENGTH        RUA13Q1\n         MVC   PPFRMLEN,#FRM6LPI  NO, USE 6 LPI LENGTH          RUA13Q1\n         B     TRANSTAT           GO TO TRAIN STATION           RUA13Q1\n         SPACE 1                                                RUA13Q1\nFORM8LPI EQU   *                                                RUA13Q1\n         MVC   PPFRMLEN,#FRM8LPI  COPY 8 LPI LENGTH             RUA13Q1\n         SPACE 2                                                RUA13Q1\n****************************************************************RUA13Q1\n*        NOW FIND THE TRAIN INFORMATION                         RUA13Q1\n****************************************************************RUA13Q1\n         SPACE 1                                                RUA13Q1\nTRANSTAT EQU   *                                                RUA13Q1\n         ICM   PC1,R15,$TRAINS    POINT TO GLOBAL TABLE         RUA13Q1\n         BZ    #ROUTCHK           SKIP IF NONE                  RUA13Q1\n         USING #TRAINS,PC1                                      RUA13Q1\n         L     R15,#TRN#ENT       GET NUMBER OF TRAINS          RUA13Q1\n         LA    PC1,#TRNENT1       POINT TO FIRST ENTRY          RUA13Q1\n         NI    PPIFLG1,X'FF'-(PPI1TDEF+PPI1TSTR) TURN OFF FLAGS RUA13Q1\n         CLC   PDBUCS,=CL4'****'  ANY VALUE SPECIFIED?          RUA13Q1\n         BNE   TRANFIND           YES, PROCEED                  RUA13Q1\n         OI    PPIFLG1,PPI1TSTR   NO, INDICATE AS SUCH          RUA13Q1\n         USING #TRANENT,PC1                                     RUA13Q1\nTRANFIND CLC   #TRANAME,PDBUCS    MATCH?                        RUA13Q1\n         BE    TRANFOUN           YES, GO COPY DATA             RUA13Q1\n         LA    PC1,#TRNELEN(PC1)  NO, TRY NEXT ONE              RUA13Q1\n         BCT   R15,TRANFIND                                     RUA13Q1\n         OI    PPIFLG1,PPI1TDEF   INDICATE DEFAULT TRAIN USED   RUA13Q1\n         L     PC1,$TRAINS        POINT TO GLOBAL TABLE         RUA13Q1\n         USING #TRAINS,PC1                                      RUA13Q1\n         LA    PC1,#TRNENT1       POINT TO FIRST ENTRY          RUA13Q1\n         USING #TRANENT,PC1                                     RUA13Q1\n         OI    PPIFLG2,PPI2TSET   FORCE ON TRAIN SETUP FLAG     RUA13Q1\n         B     TRANNSET                                         RUA13Q1\n         SPACE 1                                                RUA13Q1\nTRANFOUN EQU   *                                                RUA13Q1\n         NI    PPIFLG2,X'FF'-PPI2TSET TURN OFF TRAIN SETUP FLAG RUA13Q1\n         TM    #TRANFLG,#TRN$SET  SETUP CHARGE REQUIRED?        RUA13Q1\n         BNO   TRANNSET           NO                            RUA13Q1\n         OI    PPIFLG2,PPI2TSET   YES, INDICATE SO              RUA13Q1\nTRANNSET NULL  ,                                                RUA13Q1\n         MVC   PPTRNCST,#TRNCST   COPY MULTIPLIER               RUA13Q1\n         DROP  PC1                                              RUA13Q1\n         SPACE 1                                                RUA13Q1\n****************************************************************RUA13Q1\n*        DETERMINE WHETHER OR NOT THIS PRINTER IS PRINTING      RUA13Q1\n*        ON A DEVICE WHERE WE CHARGE FOR FORMS/LINES            RUA13Q1\n****************************************************************RUA13Q1\n         SPACE 1                                                RUA13Q1\n#ROUTCHK OI    PPIFLG1,PPI1LOCL   TURN ON LOCAL FLAG            RUA13Q1\n         TM    PCEID,PCELCLID     IS IT LOCAL?                  RUA13Q1\n         BO    #UA13Q11           YES, LEAVE FLAG SET           RUA13Q1\n         L     PC1,PCEDCT         FIND THE DCT                  RUA13Q1\n         USING DCTDSECT,PC1                                     RUA13Q1\n         CLI   DCTNO,X'00'        REMOTE WITH LOCAL ROUTE?      RUA13Q1\n         DROP  PC1                                              RUA13Q1\n         BE    #UA13Q11           YES, KEEP CHARGING            RUA13Q1\n         NI    PPIFLG1,X'FF'-PPI1LOCL NO, TURN OFF FOR REMOTES  RUA13Q1\n#UA13Q11 EQU   *                                                RUA13Q1\n         SPACE 1                                                RUA13Q1\n****************************************************************RUA13Q1\n*        PICK UP APPROPRIATE GLOBAL NUMBERS                     RUA13Q1\n****************************************************************RUA13Q1\n         SPACE 1                                                RUA13Q1\n         MVC   PBSETCST,$BSTCST   COPY GLOBAL NUMBERS           RUA13Q1\n         MVC   PFSETCST,$FSTCST                                 RUA13Q1\n         MVC   PCSETCST,$CSTCST                                 RUA13Q1\n         MVC   PTSETCST,$TSTCST                                 RUA13Q1\n         MVC   PLINECST,$LNECST                                 RUA13Q1\n         MVC   PPNCHCST,$PUNCST                                 RUA13Q1\n         SPACE 1                                                RUA13Q1\n         L     BASE2,PPSAVE1      RELOAD USUAL BASE REGISTER    RUA13Q1\n         L     R14,PPSAVE1+4        AND LINK REGISTER           RUA13Q1\n         BR    R14                RETURN                        RUA13Q1\n         SPACE 2                                                RUA13Q1\n         LTORG ,                                                RUA13Q1\n         POP   USING                                            RUA13Q1\n++MAC (#UA13Q12) ASSEM(HASPPRPU) DISTLIB(RICEHSRC).\n         SPACE 1                                                RUA13Q1\n****************************************************************RUA13Q1\n*        CHECK MOVEMENT AGAINST CARRIAGE TAPE AND FORMS LENGTH, RUA13Q1\n*        UPDATING BOTH POSITIONS.  IF A NEW FORM IS REQUIRED,   RUA13Q1\n*        INCREMENT THE CHARGABLE FORMS PAGE COUNT (PRPAGECT).   RUA13Q1\n****************************************************************RUA13Q1\n         SPACE 1                                                RUA13Q1\n         PUSH  USING                                            RUA13Q1\n         USING #LINESP,BASE2      PROVIDE LOCAL ADDRESSABILITY  RUA13Q1\n         SPACE 1                                                RUA13Q1\n#LINESP  ST    BASE2,PPSAVE1      SAVE PREVIOUS BASE REGISTER   RUA13Q1\n         ST    R14,PPSAVE1+4        AND LINK REGISTER           RUA13Q1\n         LR    BASE2,R15          LOAD BASE REGISTER            RUA13Q1\n         SPACE 1                                                RUA13Q1\n         SLR   PL,PL              CLEAR FOR INSERT              RUA13Q1\n         IC    PL,PCCWORK           OF SPACING COUNT            RUA13Q1\n         SRL   PL,3               ISOLATE SPACING BITS          RUA13Q1\n         AH    PL,PPCTPLIN        INCREMENT CTAPE LINE          RUA13Q1\n         CH    PL,PPCTPLEN        WRAP AROUND                   RUA13Q1\n         BNH   #UA13Q21             IF                          RUA13Q1\n         SH    PL,PPCTPLEN            NECESSARY                 RUA13Q1\n#UA13Q21 EQU   *                                                RUA13Q1\n         STH   PL,PPCTPLIN        SAVE NEW POSITION             RUA13Q1\n         SLR   PL,PL              NOW DO IT AGAIN FOR FORMS     RUA13Q1\n         IC    PL,PCCWORK                                       RUA13Q1\n         SRL   PL,3               COMPUTE MOVEMENT AMOUNT       RUA13Q1\n         AH    PL,PPFRMLIN        INCREMENT FORMS LINE          RUA13Q1\n         STH   PL,PPFRMLIN        SAVE NEW POSITION ON PAGE     RUA13Q1\n         CH    PL,PPFRMLEN        WRAP AROUND TO                RUA13Q1\n         BNH   #UA13Q22             NEXT PAGE                   RUA13Q1\n         SH    PL,PPFRMLEN            IF NECESSARY              RUA13Q1\n         STH   PL,PPFRMLIN        SAVE NEW POSITION ON PAGE     RUA13Q1\n         CLC   PDDBSKIP,PDDBPGCT  ARE WE REPOSITIONING?         RUA13Q1\n         BH    #UA13Q22           YES, LEAVE PAGE COUNT ALONE   RUA13Q1\n         SLR   PL,PL              NO, INCREMENT CHARGABLE PAGE  RUA13Q1\n         IC    PL,PREVCPYN        ADD NUMBER OF PAGES           RUA13Q1\n         AL    PL,PRPAGECT          THIS TRANSMISSION           RUA13Q1\n         ST    PL,PRPAGECT                                      RUA13Q1\n         SPACE 1                                                RUA13Q1\n#UA13Q22 EQU   *                                                RUA13Q1\n         L     BASE2,PPSAVE1      RESTORE PREVIOUS BASE REGISTERRUA13Q1\n         L     R14,PPSAVE1+4        AND LINK REGISTER           RUA13Q1\n         BR    R14                RETURN                        RUA13Q1\n         SPACE 1                                                RUA13Q1\n         LTORG ,                                                RUA13Q1\n         POP   USING                                            RUA13Q1\n++MAC (#UA13Q13) ASSEM(HASPPRPU) DISTLIB(RICEHSRC).\n****************************************************************RUA13Q1\n*        COMPUTE NEW POSITION AFTER A SKIP-TO-CHANNEL.  IF A NEWRUA13Q1\n*        FORM IS REQUIRED, INDICATE SO.                         RUA13Q1\n****************************************************************RUA13Q1\n         SPACE 1                                                RUA13Q1\n         PUSH  USING                                            RUA13Q1\n         USING #CHANSK,BASE2      PROVIDE LOCAL ADDRESSABILITY  RUA13Q1\n         SPACE 1                                                RUA13Q1\n#CHANSK  ST    BASE2,PPSAVE1      SAVE PREVIOUS BASE REGISTER   RUA13Q1\n         ST    R14,PPSAVE1+4        AND LINK REGISTER           RUA13Q1\n         LR    BASE2,R15          GET NEW BASE REGISTER         RUA13Q1\n         SPACE 1                                                RUA13Q1\n         SLR   PL,PL              GET SKIP-TO NUMBER            RUA13Q1\n         IC    PL,PCCWORK                                       RUA13Q1\n         SLL   PL,25                                            RUA13Q1\n         SRL   PL,28              ISOLATE SKIP BITS             RUA13Q1\n         XC    PMESSAGE(13),PMESSAGE CLEAR WORK AREA            RUA13Q1\n         STC   PL,PMESSAGE(PL)    INSERT SKIP BYTE              RUA13Q1\n         L     R15,PPCTPMAP       POINT TO PUNCH MAP            RUA13Q1\n         LH    PL,PPCTPLEN        FIND OUT HOW MANY LINES       RUA13Q1\n         SH    PL,PPCTPLIN          ARE LEFT ON THE CTAPE       RUA13Q1\n         BNZ   #UA13Q31           SOME LEFT                     RUA13Q1\n         LH    PL,PPCTPLEN        NONE, GET LENGTH OF CTAPE     RUA13Q1\n         BCTR  PL,0               FIX FOR EXECUTE               RUA13Q1\n         EX    PL,#UA13Q3A        FIND THE PUNCH                RUA13Q1\n         BZ    #UA13Q32           NONE ON THE TAPE AT ALL       RUA13Q1\n         SR    R1,R15             FOUND WHERE?                  RUA13Q1\n         LA    R1,1(,R1)          CORRECT VALUE                 RUA13Q1\n         STH   R1,$DOUBLE         SAVE MOTION                   RUA13Q1\n         STH   R1,PPCTPLIN        SAVE IT FOR LATER             RUA13Q1\n         B     #UA13Q33             AND CONTINUE                RUA13Q1\n         SPACE 1                                                RUA13Q1\n#UA13Q3A TRT   0(*-*,R15),PMESSAGE ***** EXECUTED ONLY *****    RUA13Q1\n         SPACE 1                                                RUA13Q1\n#UA13Q32 EQU   *                                                RUA13Q1\n****************************************************************RUA13Q1\n*        THIS CASE IS REALLY A DISASTER SINCE THIS MEANS THAT   RUA13Q1\n*        USER IS SKIPPING TO A PUNCH NOT ON THE CARRIAGE TAPE ATRUA13Q1\n*        ALL.  THIS CAUSES AN INFINITE PAGE EJECT.  ANY VALUE WERUA13Q1\n*        USE FOR THE MOTION HERE IS AS GOOD AS ANYTHING.        RUA13Q1\n****************************************************************RUA13Q1\n         SPACE 1                                                RUA13Q1\n         LH    PL,PPFRMLEN        SET MOTION TO FORMS LENGTH    RUA13Q1\n         STH   PL,$DOUBLE         SAVE IN WORK AREA             RUA13Q1\n         LA    PL,1               SET CTAPE POSITION TO         RUA13Q1\n         STH   PL,PPCTPLIN          FIRST LINE                  RUA13Q1\n         B     #UA13Q33           AND CONTINUE THIS FANTASY     RUA13Q1\n         SPACE 2                                                RUA13Q1\n****************************************************************RUA13Q1\n*        THIS CASE MEANS THAT WE NEED TO LOOK FOR THE PUNCH     RUA13Q1\n*        ON THIS GO-ROUND OF THE CARRIAGE TAPE.                 RUA13Q1\n****************************************************************RUA13Q1\n         SPACE 1                                                RUA13Q1\n#UA13Q31 EQU   *                                                RUA13Q1\n         AH    R15,PPCTPLIN       POINT TO RIGHT PLACE ON CTAPE RUA13Q1\n         BCTR  PL,0               FIX FOR EXECUTE               RUA13Q1\n         EX    PL,#UA13Q3A        FIND PUNCH ON REST OF CTAPE   RUA13Q1\n         BZ    #UA13Q34           NOT FOUND, LOOK FROM START    RUA13Q1\n         SPACE 1                                                RUA13Q1\n****************************************************************RUA13Q1\n*        THIS CASE MEANS THAT WE FOUND THE PUNCH BEFORE THE END RUA13Q1\n*        OF THIS GO-ROUND OF THE CARRIAGE TAPE.  WE MAY HAVE    RUA13Q1\n*        GONE TO A NEW FORM PAGE, HOWEVER.                      RUA13Q1\n****************************************************************RUA13Q1\n         SPACE 1                                                RUA13Q1\n         SR    R1,R15             FOUND WHERE?                  RUA13Q1\n         LA    R1,1(,R1)          CORRECT VALUE                 RUA13Q1\n         STH   R1,$DOUBLE         SAVE MOTION                   RUA13Q1\n         LH    PL,PPCTPLIN          AND UPDATE CTAPE POSITION   RUA13Q1\n         AR    PL,R1                                            RUA13Q1\n         STH   PL,PPCTPLIN        SAVE NEW CTAPE POSITION       RUA13Q1\n         B     #UA13Q33           AND CONTINUE                  RUA13Q1\n         SPACE 1                                                RUA13Q1\n****************************************************************RUA13Q1\n*        THIS CASE MEANS THAT WE HAD TO WRAP AROUND THE END     RUA13Q1\n*        OF THE CARRIAGE TAPE TO FIND THE PUNCH.  WE MAY HAVE   RUA13Q1\n*        GONE TO A NEW FORM PAGE (AND WE MAY NOT FIND THE PUNCH RUA13Q1\n*        AT ALL).                                               RUA13Q1\n****************************************************************RUA13Q1\n         SPACE 1                                                RUA13Q1\n#UA13Q34 EQU   *                                                RUA13Q1\n         LA    PL,1(,PL)          SAVE REST OF TAPE MOTION      RUA13Q1\n         STH   PL,$DOUBLE           FOR LATER USE               RUA13Q1\n         LH    PL,PPCTPLEN        GET FULL LENGTH OF CTAPE      RUA13Q1\n         BCTR  PL,0               FIX FOR EXECUTE               RUA13Q1\n         L     R15,PPCTPMAP       POINT BACK AT BEGINNING       RUA13Q1\n         EX    PL,#UA13Q3A        FIND PUNCH ON CTAPE           RUA13Q1\n         BZ    #UA13Q32           NOT THERE AT ALL              RUA13Q1\n         SR    R1,R15             FOUND WHERE?                  RUA13Q1\n         LA    R1,1(,R1)          CORRECT VALUE                 RUA13Q1\n         STH   R1,PPCTPLIN        SAVE NEW CTAPE POSITION       RUA13Q1\n         AH    R1,$DOUBLE         INCLUDE PREVIOUS MOTION       RUA13Q1\n         STH   R1,$DOUBLE         AND SAVE FOR LATER            RUA13Q1\n         SPACE 2                                                RUA13Q1\n****************************************************************RUA13Q1\n*        NOW $DOUBLE CONTAINS THE AMOUNT OF MOTION NECESSARY TO RUA13Q1\n*        FIND THE SKIP-TO PUNCH.  SEE IF WE HAVE GONE TO A      RUA13Q1\n*        NEW FORM PAGE.                                         RUA13Q1\n****************************************************************RUA13Q1\n         SPACE 1                                                RUA13Q1\n#UA13Q33 EQU   *                                                RUA13Q1\n         LH    PL,PPFRMLIN        UPDATE POSITION ON FORM       RUA13Q1\n         AH    PL,$DOUBLE                                       RUA13Q1\n         STH   PL,PPFRMLIN        SAVE NEW POSITION             RUA13Q1\n         NI    PPIFLG1,X'FF'-PPI1PAGE   TURN OFF NEWPAGE FLAG   RUA13Q1\n         CH    PL,PPFRMLEN        NEW PAGE REQUIRED?            RUA13Q1\n         BNH   #UA13Q35           NO, JUST CONTINUE             RUA13Q1\n         SH    PL,PPFRMLEN        YES, SET TO NEW POSITION      RUA13Q1\n         STH   PL,PPFRMLIN                                      RUA13Q1\n         OI    PPIFLG1,PPI1PAGE   INDICATE NEW PAGE REQUIRED    RUA13Q1\n         SPACE 1                                                RUA13Q1\n#UA13Q35 EQU   *                                                RUA13Q1\n         SPACE 1                                                RUA13Q1\n         L     BASE2,PPSAVE1      RESTORE PREVIOUS BASE REGISTERRUA13Q1\n         L     R14,PPSAVE1+4        AND LINK REGISTER           RUA13Q1\n         BR    R14                RETURN                        RUA13Q1\n         SPACE 1                                                RUA13Q1\n         LTORG ,                                                RUA13Q1\n         POP   USING                                            RUA13Q1\n++MAC (#UA13Q14) ASSEM(HASPPRPU) DISTLIB(RICEHSRC).\n         LH    PW,PPCTPLIN          INCREMENT                   RUA13Q1\n         LA    PW,4(,PW)              CTAPE POSITION            RUA13Q1\n         CH    PW,PPCTPLEN          WRAP                        RUA13Q1\n         BNH   #UA13Q41               AROUND IF                 RUA13Q1\n         SH    PW,PPCTPLEN              NECESSARY               RUA13Q1\n#UA13Q41 STH   PW,PPCTPLIN          STORE NEW POSITION          RUA13Q1\n         LH    PW,PPFRMLIN          INCREMENT                   RUA13Q1\n         LA    PW,4(,PW)              FORM POSITION             RUA13Q1\n         CH    PW,PPFRMLEN          WRAP                        RUA13Q1\n         BNH   #UA13Q42               AROUND IF                 RUA13Q1\n         SH    PW,PPFRMLEN              NECESSARY               RUA13Q1\n         SLR   PL,PL                INCREMENT                   RUA13Q1\n         IC    PL,PREVCPYN            CHARGABLE                 RUA13Q1\n         AL    PL,PRPAGECT              PAGE COUNT              RUA13Q1\n         ST    PL,PRPAGECT                IF SO                 RUA13Q1\n#UA13Q42 STH   PW,PPFRMLIN          STORE NEW FORM POSITION     RUA13Q1\n++MAC (#UA13Q15) ASSEM(HASPPRPU) DISTLIB(RICEHSRC).\n         XC    $DOUBLE,$DOUBLE    CLEAR COST ACCUMULATOR        RUA13Q1\n         L     PL,PCEFORM         FIND PAGE TYPE                RUA13Q1\n         CLI   1(PL),C'E'         IS THIS AN END PAGE?          RUA13Q1\n         BNE   #UA13Q51           NO, SKIP COUNTING CODE        RUA13Q1\n#UA13Q50 ST    R1,PLNDISPL        SAVE LINE DISPLACEMENT        RUA13Q1\n         LA    PC1,0(R1,PBUF)     GET NEW LINE BUFFER ADDRESS   RUA13Q1\n         MVI   0(PC1),C' '        BLANK OUT                     RUA13Q1\n         MVC   1(131,PC1),0(PC1)    THE LINE                    RUA13Q1\n         MVC   0(7,PC1),=C'SERVICE' SET HEADER LINE             RUA13Q1\n         MVC   17(6,PC1),=C'AMOUNT'                             RUA13Q1\n         MVC   29(4,PC1),=C'COST'                               RUA13Q1\n         AL    PC1,PRCCWID        CONSTRUCT                     RUA13Q1\n         L     PC2,PRCCWID+4        PRINT CCW                   RUA13Q1\n         BAL   PL,PPPUT           ADD CCW TO CHAIN              RUA13Q1\n         TM    PCEID,PCELCLID     A TRUE LOCAL DEVICE?          RUA13Q1\n         BNO   #UA13Q52           SKIP DISPATCHING LINE IF NOT  RUA13Q1\n         L     R1,PLNDISPL        FIND NEW                      RUA13Q1\n         LA    R1,132(,R1)          LINE DISPLACEMENT           RUA13Q1\n         LA    R4,132(,R1)        CHECK FOR ROOM                RUA13Q1\n         CH    R4,$BUFLENG          IN BUFFER                   RUA13Q1\n         BNH   #UA13Q53           BR IF YES                     RUA13Q1\n         BAL   PL,PPWRITE         FORCE WRITE                   RUA13Q1\n         BAL   PL,PPCHECK         CHECK WRITE                   RUA13Q1\n         LA    R1,BUFSTART-BUFDSECT SET STARTING LINE DISPLACEMENT 13Q1\n#UA13Q53 ST    R1,PLNDISPL        STORE NEW DISPLACEMENT        RUA13Q1\n         LA    PC1,0(R1,PBUF)     GET NEW LINE BUFFER ADDRESS   RUA13Q1\n         MVI   0(PC1),C' '        BLANK OUT                     RUA13Q1\n         MVC   1(131,PC1),0(PC1)    THE LINE                    RUA13Q1\n         MVC   0(11,PC1),=C'DISPATCHING' DISPATCHING LINE       RUA13Q1\n         MVC   22(11,PC1),=C'1      ----' ASSUME NO CHARGE      RUA13Q1\n         ICM   PL,15,PBSETCST     CHECK RATE FOR ZERO           RUA13Q1\n         BZ    #UA13Q54           SKIP IF IT IS                 RUA13Q1\n         AL    PL,$DOUBLE                                       RUA13Q1\n         ST    PL,$DOUBLE         INCREMENT TOTAL COST          RUA13Q1\n         L     R15,PBSETCST       GET BASE COST BACK AGAIN      RUA13Q1\n         SLR   R14,R14                                          RUA13Q1\n         D     R14,=F'1000'       GET NUMBER IN CENTS           RUA13Q1\n         MVC   24(10,PC1),=X'4020202021204B2020'                RUA13Q1\n         LA    R1,29(,PC1)        POINT TO FORCE SIGNIF DIGIT   RUA13Q1\n         CVD   R15,PMESSAGE                                     RUA13Q1\n         EDMK  24(10,PC1),PMESSAGE+4                            RUA13Q1\n         BCTR  R1,0                                             RUA13Q1\n         MVI   0(R1),C'$'         INSERT DOLLAR SIGN            RUA13Q1\n#UA13Q54 AL    PC1,PRCCWID        CONSTRUCT                     RUA13Q1\n         L     PC2,PRCCWID+4        PRINT CCW                   RUA13Q1\n         BAL   PL,PPPUT           ADD CCW TO CHAIN              RUA13Q1\n#UA13Q52 L     R1,PLNDISPL        FIND NEW                      RUA13Q1\n         LA    R1,132(,R1)          LINE DISPLACEMENT           RUA13Q1\n         LA    R4,132(,R1)        CHECK FOR ROOM                RUA13Q1\n         CH    R4,$BUFLENG          IN BUFFER                   RUA13Q1\n         BNH   #UA13Q55           BR IF YES                     RUA13Q1\n         BAL   PL,PPWRITE         FORCE WRITE                   RUA13Q1\n         BAL   PL,PPCHECK         CHECK WRITE                   RUA13Q1\n         LA    R1,BUFSTART-BUFDSECT SET STARTING LINE DISPLACEMENT 13Q1\n#UA13Q55 ST    R1,PLNDISPL        STORE NEW DISPLACEMENT        RUA13Q1\n         LA    PC1,0(R1,PBUF)     GET NEW LINE BUFFER ADDRESS   RUA13Q1\n         MVI   0(PC1),C' '        BLANK OUT                     RUA13Q1\n         MVC   1(131,PC1),0(PC1)    THE LINE                    RUA13Q1\n         L     PL,PCEDCT          FIND THE DCT                  RUA13Q1\n         USING DCTDSECT,PL        ADDRESS IT                    RUA13Q1\n         MVC   0(4,PC1),=C'FORM'  INSERT FORM                   RUA13Q1\n         MVC   6(4,PC1),DCTFORMS                                RUA13Q1\n         MVC   11(5,PC1),=C'SETUP'                              RUA13Q1\n         MVC   22(11,PC1),=C'-      ----' ASSUME NO CHARGE      RUA13Q1\n         DROP  PL                                               RUA13Q1\n         TM    PPIFLG2,PPI2FSET   SETUP CHARGE FOR THIS FORM?   RUA13Q1\n         BNO   #UA13Q56           SKIP IF NOT                   RUA13Q1\n         TM    PPIFLG1,PPI1LOCL   \"LOCAL\" DEVICE?               RUA13Q1\n         BNO   #UA13Q56           SKIP SETUP COST IF NOT        RUA13Q1\n         MVI   22(PC1),C'1'       INDICATE SINGLE CHARGE        RUA13Q1\n         ICM   PL,15,PFSETCST     SEE IF ANY SETUP COST         RUA13Q1\n         BZ    #UA13Q56           SKIP SETUP COST IF SO         RUA13Q1\n         AL    PL,$DOUBLE                                       RUA13Q1\n         ST    PL,$DOUBLE         INCREMENT TOTAL COST          RUA13Q1\n         L     R15,PFSETCST       GET FORMS SETUP COST BACK     RUA13Q1\n         SLR   R14,R14                                          RUA13Q1\n         D     R14,=F'1000'       GET NUMBER IN CENTS           RUA13Q1\n         MVC   24(10,PC1),=X'4020202021204B2020'                RUA13Q1\n         LA    R1,29(,PC1)        POINT TO FORCE SIGNIF DIGIT   RUA13Q1\n         CVD   R15,PMESSAGE                                     RUA13Q1\n         EDMK  24(10,PC1),PMESSAGE+4                            RUA13Q1\n         BCTR  R1,0                                             RUA13Q1\n         MVI   0(R1),C'$'         INSERT DOLLAR SIGN            RUA13Q1\n#UA13Q56 TM    PPIFLG1,PPI1FDEF   UNKNOWN FORM?                 RUA13Q1\n         BNO   #UA13Q57           NO, SKIP THIS                 RUA13Q1\n         MVC   35(40,PC1),=C'UNKNOWN FORM - DEFAULT PAGE SIZE ASSUMED'\n#UA13Q57 AL    PC1,PRCCWID        CONSTRUCT                     RUA13Q1\n         L     PC2,PRCCWID+4        PRINT CCW                   RUA13Q1\n         BAL   PL,PPPUT           ADD CCW TO CHAIN              RUA13Q1\n         L     R1,PLNDISPL        FIND NEW                      RUA13Q1\n         LA    R1,132(,R1)          LINE DISPLACEMENT           RUA13Q1\n         LA    R4,132(,R1)        CHECK FOR ROOM                RUA13Q1\n         CH    R4,$BUFLENG          IN BUFFER                   RUA13Q1\n         BNH   #UA13Q58           BR IF YES                     RUA13Q1\n         BAL   PL,PPWRITE         FORCE WRITE                   RUA13Q1\n         BAL   PL,PPCHECK         CHECK WRITE                   RUA13Q1\n         LA    R1,BUFSTART-BUFDSECT SET STARTING LINE DISPLACEMENT 13Q1\n#UA13Q58 ST    R1,PLNDISPL        STORE NEW DISPLACEMENT        RUA13Q1\n         LA    PC1,0(R1,PBUF)     GET NEW LINE BUFFER ADDRESS   RUA13Q1\n         MVI   0(PC1),C' '        BLANK OUT                     RUA13Q1\n         MVC   1(131,PC1),0(PC1)    THE LINE                    RUA13Q1\n         L     PL,PCEDCT          FIND THE DCT                  RUA13Q1\n         USING DCTDSECT,PL        ADDRESS IT                    RUA13Q1\n         MVC   0(5,PC1),=C'CTAPE' INSERT CTAPE                  RUA13Q1\n         MVC   6(4,PC1),DCTFCB                                  RUA13Q1\n         MVC   11(5,PC1),=C'SETUP'                              RUA13Q1\n         MVC   22(11,PC1),=C'-      ----' ASSUME NO CHARGE      RUA13Q1\n         DROP  PL                                               RUA13Q1\n         TM    PPIFLG2,PPI2CSET   SETUP CHARGE FOR THIS CTAPE?  RUA13Q1\n         BNO   #UA13Q59           SKIP IF NOT                   RUA13Q1\n         TM    PPIFLG1,PPI1LOCL   \"LOCAL\" DEVICE?               RUA13Q1\n         BNO   #UA13Q59           SKIP SETUP COST IF NOT        RUA13Q1\n         MVI   22(PC1),C'1'       INDICATE SINGLE CHARGE        RUA13Q1\n         ICM   PL,15,PCSETCST     SEE IF ANY SETUP COST         RUA13Q1\n         BZ    #UA13Q59           SKIP SETUP COST IF SO         RUA13Q1\n         AL    PL,$DOUBLE                                       RUA13Q1\n         ST    PL,$DOUBLE         INCREMENT TOTAL COST          RUA13Q1\n         L     R15,PCSETCST       GET SETUP COST BACK           RUA13Q1\n         SLR   R14,R14                                          RUA13Q1\n         D     R14,=F'1000'       GET NUMBER IN CENTS           RUA13Q1\n         MVC   24(10,PC1),=X'4020202021204B2020'                RUA13Q1\n         LA    R1,29(,PC1)        POINT TO FORCE SIGNIF DIGIT   RUA13Q1\n         CVD   R15,PMESSAGE                                     RUA13Q1\n         EDMK  24(10,PC1),PMESSAGE+4                            RUA13Q1\n         BCTR  R1,0                                             RUA13Q1\n         MVI   0(R1),C'$'         INSERT DOLLAR SIGN            RUA13Q1\n#UA13Q59 TM    PPIFLG1,PPI1CDEF   UNKNOWN CTAPE?                RUA13Q1\n         BNO   #UA13Q5A           NO, SKIP THIS                 RUA13Q1\n         MVC   35(38,PC1),=C'UNKNOWN CTAPE - DEFAULT LAYOUT ASSUMED'\n#UA13Q5A AL    PC1,PRCCWID        CONSTRUCT                     RUA13Q1\n         L     PC2,PRCCWID+4        PRINT CCW                   RUA13Q1\n         BAL   PL,PPPUT           ADD CCW TO CHAIN              RUA13Q1\n         L     R1,PLNDISPL        FIND NEW                      RUA13Q1\n         LA    R1,132(,R1)          LINE DISPLACEMENT           RUA13Q1\n         LA    R4,132(,R1)        CHECK FOR ROOM                RUA13Q1\n         CH    R4,$BUFLENG          IN BUFFER                   RUA13Q1\n         BNH   #UA13Q5B           BR IF YES                     RUA13Q1\n         BAL   PL,PPWRITE         FORCE WRITE                   RUA13Q1\n         BAL   PL,PPCHECK         CHECK WRITE                   RUA13Q1\n         LA    R1,BUFSTART-BUFDSECT SET STARTING LINE DISPLACEMENT 13Q1\n#UA13Q5B ST    R1,PLNDISPL        STORE NEW DISPLACEMENT        RUA13Q1\n         LA    PC1,0(R1,PBUF)     GET NEW LINE BUFFER ADDRESS   RUA13Q1\n         MVI   0(PC1),C' '        BLANK OUT                     RUA13Q1\n         MVC   1(131,PC1),0(PC1)    THE LINE                    RUA13Q1\n         L     PL,PCEDCT          FIND THE DCT                  RUA13Q1\n         USING DCTDSECT,PL        ADDRESS IT                    RUA13Q1\n         MVC   0(5,PC1),=C'TRAIN' INSERT TRAIN                  RUA13Q1\n         MVC   6(4,PC1),DCTUCS                                  RUA13Q1\n         MVC   11(5,PC1),=C'SETUP'                              RUA13Q1\n         MVC   22(11,PC1),=C'-      ----' ASSUME NO CHARGE      RUA13Q1\n         DROP  PL                                               RUA13Q1\n         TM    PPIFLG2,PPI2TSET   SETUP CHARGE FOR THIS TRAIN?  RUA13Q1\n         BNO   #UA13Q5C           SKIP IF NOT                   RUA13Q1\n         TM    PPIFLG1,PPI1LOCL   \"LOCAL\" DEVICE?               RUA13Q1\n         BNO   #UA13Q5C           SKIP SETUP COST IF NOT        RUA13Q1\n         MVI   22(PC1),C'1'       INDICATE SINGLE CHARGE        RUA13Q1\n         ICM   PL,15,PTSETCST     SEE IF ANY SETUP COST         RUA13Q1\n         BZ    #UA13Q5C           SKIP SETUP COST IF SO         RUA13Q1\n         AL    PL,$DOUBLE                                       RUA13Q1\n         ST    PL,$DOUBLE         INCREMENT TOTAL COST          RUA13Q1\n         L     R15,PTSETCST       GET SETUP COST BACK           RUA13Q1\n         SLR   R14,R14                                          RUA13Q1\n         D     R14,=F'1000'       GET NUMBER IN CENTS           RUA13Q1\n         MVC   24(10,PC1),=X'4020202021204B2020'                RUA13Q1\n         LA    R1,29(,PC1)        POINT TO FORCE SIGNIF DIGIT   RUA13Q1\n         CVD   R15,PMESSAGE                                     RUA13Q1\n         EDMK  24(10,PC1),PMESSAGE+4                            RUA13Q1\n         BCTR  R1,0                                             RUA13Q1\n         MVI   0(R1),C'$'         INSERT DOLLAR SIGN            RUA13Q1\n#UA13Q5C AL    PC1,PRCCWID        CONSTRUCT                     RUA13Q1\n         L     PC2,PRCCWID+4        PRINT CCW                   RUA13Q1\n         BAL   PL,PPPUT           ADD CCW TO CHAIN              RUA13Q1\n         L     R1,PLNDISPL        FIND NEW                      RUA13Q1\n         LA    R1,132(,R1)          LINE DISPLACEMENT           RUA13Q1\n         LA    R4,132(,R1)        CHECK FOR ROOM                RUA13Q1\n         CH    R4,$BUFLENG          IN BUFFER                   RUA13Q1\n         BNH   #UA13Q5D           BR IF YES                     RUA13Q1\n         BAL   PL,PPWRITE         FORCE WRITE                   RUA13Q1\n         BAL   PL,PPCHECK         CHECK WRITE                   RUA13Q1\n         LA    R1,BUFSTART-BUFDSECT SET STARTING LINE DISPLACEMENT 13Q1\n#UA13Q5D ST    R1,PLNDISPL        STORE NEW DISPLACEMENT        RUA13Q1\n         LA    PC1,0(R1,PBUF)     GET NEW LINE BUFFER ADDRESS   RUA13Q1\n         MVI   0(PC1),C' '        BLANK OUT                     RUA13Q1\n         MVC   1(131,PC1),0(PC1)    THE LINE                    RUA13Q1\n         MVC   0(13,PC1),=C'LINES PRINTED'                      RUA13Q1\n         MVC   29(4,PC1),=C'----' ASSUME NO CHARGE              RUA13Q1\n         L     R1,PPLNCDCT        GET LINE COUNT                RUA13Q1\n         CVD   R1,PMESSAGE        CONVERT TO DECIMAL            RUA13Q1\n         MVC   15(8,PC1),=X'4020202020202020'                   RUA13Q1\n         ED    15(8,PC1),PMESSAGE+4 MAKE PRINTABLE              RUA13Q1\n         TM    PPIFLG1,PPI1LOCL   CHARGE FOR LINES?             RUA13Q1\n         BNO   #UA13Q5E           NO, SKIP THIS                 RUA13Q1\n         L     R15,PPLNCDCT       GET LINE COUNT AGAIN          RUA13Q1\n         SLR   R14,R14                                          RUA13Q1\n         M     R14,PLINECST       MULTIPLY BY LINE COST         RUA13Q1\n         M     R14,PPTRNCST         AND TRAIN MULTIPLIER        RUA13Q1\n         D     R14,=F'1000'       MAKE UNITS RIGHT              RUA13Q1\n         SLR   R14,R14                                          RUA13Q1\n         LR    PL,R15                                           RUA13Q1\n         AL    PL,$DOUBLE                                       RUA13Q1\n         ST    PL,$DOUBLE         INCREMENT TOTAL COST          RUA13Q1\n         D     R14,=F'1000'       GET NUMBER IN CENTS           RUA13Q1\n         LR    R14,R15                                          RUA13Q1\n         CVD   R15,PMESSAGE       CONVERT TO DECIMAL            RUA13Q1\n         MVC   24(9,PC1),=X'4020202021204B2020'                 RUA13Q1\n         LA    R1,29(,PC1)        POINT TO FORCE SIGNIF DIGIT   RUA13Q1\n         EDMK  24(9,PC1),PMESSAGE+4                             RUA13Q1\n         BCTR  R1,0                                             RUA13Q1\n         MVI   0(R1),C'$'         INSERT DOLLAR SIGN            RUA13Q1\n         MVC   35(2,PC1),=CL2'AT' INSERT RATE                   RUA13Q1\n         L     R14,PLINECST       GET LINE COST AGAIN           RUA13Q1\n         CVD   R14,PMESSAGE                                     RUA13Q1\n         MVC   38(7,PC1),=X'402021204B2020'                     RUA13Q1\n         MVC   45(5,PC1),=C'/1000'                              RUA13Q1\n         LA    R1,41(,PC1)        POINT TO FORCE SIGNIF DIGIT   RUA13Q1\n         EDMK  38(7,PC1),PMESSAGE+5                             RUA13Q1\n         BCTR  R1,0                                             RUA13Q1\n         MVI   0(R1),C'$'         INSERT DOLLAR SIGN            RUA13Q1\n         L     R14,PPTRNCST       GET TRAIN COST AGAIN          RUA13Q1\n         CL    R14,=F'1000'       TRAIN MULTIPLIER > 1?         RUA13Q1\n         BNH   #UA13Q5E           SKIP IF NOT                   RUA13Q1\n         MVI   51(PC1),C'*'       INSERT MULTIPLICATION SYMBOL  RUA13Q1\n         MVC   52(7,PC1),=X'4021204B202020'                     RUA13Q1\n         CVD   R14,PMESSAGE       CONVERT TO DECIMAL            RUA13Q1\n         ED    52(7,PC1),PMESSAGE+5                             RUA13Q1\n         MVC   60(12,PC1),=C'TRAIN FACTOR'                      RUA13Q1\n#UA13Q5E AL    PC1,PRCCWID        CONSTRUCT                     RUA13Q1\n         L     PC2,PRCCWID+4        PRINT CCW                   RUA13Q1\n         BAL   PL,PPPUT           ADD CCW TO CHAIN              RUA13Q1\n         L     R1,PLNDISPL        FIND NEW                      RUA13Q1\n         LA    R1,132(,R1)          LINE DISPLACEMENT           RUA13Q1\n         LA    R4,132(,R1)        CHECK FOR ROOM                RUA13Q1\n         CH    R4,$BUFLENG          IN BUFFER                   RUA13Q1\n         BNH   #UA13Q5F           BR IF YES                     RUA13Q1\n         BAL   PL,PPWRITE         FORCE WRITE                   RUA13Q1\n         BAL   PL,PPCHECK         CHECK WRITE                   RUA13Q1\n         LA    R1,BUFSTART-BUFDSECT SET STARTING LINE DISPLACEMENT 13Q1\n#UA13Q5F ST    R1,PLNDISPL        STORE NEW DISPLACEMENT        RUA13Q1\n         LA    PC1,0(R1,PBUF)     GET NEW LINE BUFFER ADDRESS   RUA13Q1\n         MVI   0(PC1),C' '        BLANK OUT                     RUA13Q1\n         MVC   1(131,PC1),0(PC1)    THE LINE                    RUA13Q1\n         MVC   0(13,PC1),=C'PAGES PRINTED'                      RUA13Q1\n         L     R1,PRPAGECT        GET PAGE COUNT                RUA13Q1\n         CVD   R1,PMESSAGE        CONVERT TO DECIMAL            RUA13Q1\n         MVC   15(8,PC1),=X'4020202020202020'                   RUA13Q1\n         ED    15(8,PC1),PMESSAGE+4 MAKE PRINTABLE              RUA13Q1\n         MVC   29(4,PC1),=C'----' ASSUME NO CHARGE              RUA13Q1\n         TM    PPIFLG1,PPI1LOCL   CHARGE FOR PAGES?             RUA13Q1\n         BNO   #UA13Q5G           NO, SKIP THIS                 RUA13Q1\n         ICM   R15,15,PPFRMCST    CHECK FOR NO PAGE COST        RUA13Q1\n         BZ    #UA13Q5G           SKIP IF ZERO COST             RUA13Q1\n         L     R15,PRPAGECT       GET PAGE COUNT AGAIN          RUA13Q1\n         SLR   R14,R14                                          RUA13Q1\n         M     R14,PPFRMCST       MULTIPLY BY FORM COST         RUA13Q1\n         LR    PL,R15             SAVE COST                     RUA13Q1\n         D     R14,=F'1000'       GET NUMBER IN CENTS           RUA13Q1\n         CVD   R15,PMESSAGE       CONVERT TO DECIMAL            RUA13Q1\n         AL    PL,$DOUBLE                                       RUA13Q1\n         ST    PL,$DOUBLE         INCREMENT TOTAL COST          RUA13Q1\n         MVC   24(9,PC1),=X'4020202021204B2020'                 RUA13Q1\n         LA    R1,29(,PC1)        POINT TO FORCE SIGNIF DIGIT   RUA13Q1\n         EDMK  24(9,PC1),PMESSAGE+4                             RUA13Q1\n         BCTR  R1,0                                             RUA13Q1\n         MVI   0(R1),C'$'         INSERT DOLLAR SIGN            RUA13Q1\n         MVC   35(2,PC1),=CL2'AT' INSERT RATE                   RUA13Q1\n         L     R15,PPFRMCST       GET PAGE COST AGAIN           RUA13Q1\n         CVD   R15,PMESSAGE                                     RUA13Q1\n         MVC   38(7,PC1),=X'402021204B2020'                     RUA13Q1\n         MVC   45(5,PC1),=C'/1000'                              RUA13Q1\n         LA    R1,41(,PC1)        POINT TO FORCE SIGNIF DIGIT   RUA13Q1\n         EDMK  38(7,PC1),PMESSAGE+5                             RUA13Q1\n         BCTR  R1,0                                             RUA13Q1\n         MVI   0(R1),C'$'         INSERT DOLLAR SIGN            RUA13Q1\n#UA13Q5G TM    PPIFLG1,PPI1CDEF+PPI1FDEF UNKNOWN FORMS/CTAPE?   RUA13Q1\n         BZ    #UA13Q5H           NO, ALL IS KNOWN              RUA13Q1\n         MVC   51(42,PC1),=CL42'- PAGE COUNT ESTIMATED - SEE NOTE(S) ABX\n               OVE'                                             RUA13Q1\n#UA13Q5H AL    PC1,PRCCWID        CONSTRUCT                     RUA13Q1\n         L     PC2,PRCCWID+4        PRINT CCW                   RUA13Q1\n         BAL   PL,PPPUT           ADD CCW TO CHAIN              RUA13Q1\n         L     R1,PLNDISPL        FIND NEW LINE DISPLACEMENT    RUA13Q1\n         LA    R1,132(,R1)          LINE DISPLACEMENT           RUA13Q1\n         LA    R4,132(,R1)        CHECK FOR ROOM                RUA13Q1\n         CH    R4,$BUFLENG          IN BUFFER                   RUA13Q1\n         BNH   #UA13Q5I           BR IF YES                     RUA13Q1\n         BAL   PL,PPWRITE         FORCE WRITE                   RUA13Q1\n         BAL   PL,PPCHECK         CHECK WRITE                   RUA13Q1\n         LA    R1,BUFSTART-BUFDSECT SET STARTING LINE DISPLACEMENT 13Q1\n#UA13Q5I ST    R1,PLNDISPL        STORE NEW DISPLACEMENT        RUA13Q1\n         LA    PC1,0(R1,PBUF)     GET NEW LINE BUFFER ADDRESS   RUA13Q1\n         MVI   0(PC1),C' '        BLANK OUT                     RUA13Q1\n         MVC   1(131,PC1),0(PC1)    THE LINE                    RUA13Q1\n         MVC   0(16,PC1),=C'TOTAL PRINT COST'                   RUA13Q1\n         MVC   29(4,PC1),=C'----' ASSUME NO CHARGE              RUA13Q1\n         L     R15,$DOUBLE                                      RUA13Q1\n         SLR   R14,R14                                          RUA13Q1\n         D     R14,=F'1000'       GET NUMBER IN CENTS           RUA13Q1\n         CVD   R15,PMESSAGE                                     RUA13Q1\n         MVC   24(10,PC1),=X'4020202021204B2020'                RUA13Q1\n         LA    R1,29(,PC1)        POINT TO FORCE SIGNIF DIGIT   RUA13Q1\n         CVD   R15,PMESSAGE                                     RUA13Q1\n         EDMK  24(10,PC1),PMESSAGE+4                            RUA13Q1\n         BCTR  R1,0                                             RUA13Q1\n         MVI   0(R1),C'$'         INSERT DOLLAR SIGN            RUA13Q1\n         AL    PC1,PRCCWID        CONSTRUCT                     RUA13Q1\n         L     PC2,PRCCWID+4        PRINT CCW                   RUA13Q1\n         BAL   PL,PPPUT           ADD CCW TO CHAIN              RUA13Q1\n         L     R1,PLNDISPL        GET NEW LINE DISPLACEMENT     RUA13Q1\n         LA    R1,132(,R1)          LINE DISPLACEMENT           RUA13Q1\n         LA    R4,132(,R1)        CHECK FOR ROOM                RUA13Q1\n         CH    R4,$BUFLENG          IN BUFFER                   RUA13Q1\n         BNH   #UA13Q5J           BR IF YES                     RUA13Q1\n         BAL   PL,PPWRITE         FORCE WRITE                   RUA13Q1\n         BAL   PL,PPCHECK         CHECK WRITE                   RUA13Q1\n         LA    R1,BUFSTART-BUFDSECT SET STARTING LINE DISPLACEMENT 13Q1\n#UA13Q5J ST    R1,PLNDISPL        STORE NEW DISPLACEMENT        RUA13Q1\n         LA    PC1,0(R1,PBUF)     GET NEW LINE BUFFER ADDRESS   RUA13Q1\n         MVI   0(PC1),C' '        BLANK OUT                     RUA13Q1\n         MVC   1(131,PC1),0(PC1)    THE LINE                    RUA13Q1\n         AL    PC1,PRCCWID        CONSTRUCT                     RUA13Q1\n         L     PC2,PRCCWID+4        PRINT CCW                   RUA13Q1\n         BAL   PL,PPPUT           ADD CCW TO CHAIN              RUA13Q1\n         L     R1,PLNDISPL        FIND NEW                      RUA13Q1\n         LA    R1,132(,R1)          LINE DISPLACEMENT           RUA13Q1\n         LA    R4,132(,R1)        CHECK FOR ROOM                RUA13Q1\n         CH    R4,$BUFLENG          IN BUFFER                   RUA13Q1\n         BNH   #UA13Q5K           BR IF YES                     RUA13Q1\n         BAL   PL,PPWRITE         FORCE WRITE                   RUA13Q1\n         BAL   PL,PPCHECK         CHECK WRITE                   RUA13Q1\n         LA    R1,BUFSTART-BUFDSECT SET STARTING LINE DISPLACEMENT 13Q1\n#UA13Q5K ST    R1,PLNDISPL        STORE NEW DISPLACEMENT        RUA13Q1\n#UA13Q51 NULL  ,                  REJOIN IBM CODE               RUA13Q1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SAVEX": {"ttr": 8714, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   SAVEX &BASE=12,&REGS=(14,12),&ID=*,&LV=72,&CSECT=YES,         X\n               &SP=,                                           *MW73011X\n               &PARM=NO,&TMS=YES,&XID=,                        *FG75189X\n               &BANNER=,                                       *FG76267X\n               &PARMR=1,                                       *AB76329X\n               &CHAIN=YES,&REGSTRS=YES,&SA=\n.* 1) ADDED SP= OPERAND TO ALLOW SUB-POOL TO BE SPECIFIED      *MW73011\n.*    FOR GETMAIN                                              *MW73011\n.* 2) ADDED SA=* TO ALLOW INTERNAL SAVE AREA                   *MW73011\n.* 3) ADDED TMS (TIMESTAMP), PARM (SYSPARM), XID FOR           *FG75188\n.*    IMPROVED MODULE DOCUMENTATION.                           *FG75188\n.* 4) ADDED PARMR FOR SAVING PARM IN REGISTER OTHER THAN 1.    *AB76329\n         GBLC  &SVXSIZE                                        *MW74138\n         GBLC  &SVXSP                                          *MW74138\n         GBLB  &SVXREG\n         LCLA  &A,&B,&C,&D,&E,&F,&G,&H,&I,&J,&K,&Z             *FG75189\n         LCLC  &TTIME,&TDATE,&ATIME                            *FG76267\n         LCLC  &L(5)                 /* MOVED */               *FG76267\n         LCLB  &AB                   /* MOVED */               *FG76267\n         LCLC  &PR                                             *AB76329\n         LCLC  &TB                                             *AB78004\n&TDATE   SETC  '&SYSDATE'                                      *FG76267\n&TTIME   SETC  '&SYSTIME'                                      *FG76267\n&ATIME   SETC  '&TTIME'\n         AIF   ('&BANNER' NE 'YES').SAVEWAZ    @               *FG76267\n         AIF   ('&LABEL' EQ '').SAVEWAA                        *FG76267\n         BANNER &LABEL                  ,                      *FG76267\n.SAVEWAA AIF   ('&TMS' NE 'YES').SAVEWAB                       *FG76267\n         BANNER &TDATE                  ,                      *FG76267\n         BANNER &ATIME                                     ,   *FG76267\n.SAVEWAB ANOP                                                  *FG76267\n         EJECT                                                 *FG76267\n.SAVEWAZ ANOP                                                  *FG76267\n&AB      SETB  1\n         AIF   ('&SA' EQ '').SAVEXAA\n&SVXSIZE SETC  '0'                                             *MW74138\n         AGO   .SAVEXBA\n.SAVEXAA ANOP\n&SVXSIZE SETC  '&LV'                                           *MW74138\n.SAVEXBA ANOP\n         AIF   (N'&REGS GT 2 OR '&REGS' EQ '').SAVEXCA\n         AIF   (T'&REGS(1) EQ 'N').SAVEXDA\n.SAVEXCA ANOP\n&AB      SETB  0\n         MNOTE 4,'*** INVALID REGS PARAMETER ***'\n.SAVEXDA ANOP\n         AIF   ('&LV' NE '' OR '&SA' NE '').SAVEXEA\n&AB      SETB  0\n         MNOTE 4,'*** EITHER LV OR SA PARAMETER MUST BE SPECIFIED ***'\n.SAVEXEA ANOP\n         AIF   ('&ID' NE '' OR '&LABEL' NE '' OR '&SYSECT' NE '').SAVEXX\n               FA\n&AB      SETB  0\n         MNOTE 4,'*** INVALID ID PARAMETER ***'\n.SAVEXFA ANOP\n         AIF   ('&CSECT'(1,1) EQ 'N' OR '&LABEL' NE '').SAVEXGA\n&AB      SETB  0\n         MNOTE 4,'*** LABEL MUST BE SUPPLIED IF CSECT WANTED ***'\n.SAVEXGA ANOP\n         AIF   (&AB).SAVEXHA\n&SVXSIZE SETC  '0'                                             *MW74138\n         MEXIT\n.SAVEXHA ANOP\n&A       SETA  4*(N'&BASE-1)\n         AIF   (&A GE 0).SAVEXIA\n&A       SETA  0\n.SAVEXIA ANOP\n         AIF   ('&ID' EQ '').SAVEXMA\n         AIF   ('&ID' EQ '*').SAVEXJA\n&B       SETA  K'&ID\n         AGO   .SAVEXNA\n.SAVEXJA ANOP\n         AIF   ('&LABEL' EQ '').SAVEXKA\n&B       SETA  K'&LABEL\n         AGO   .SAVEXNA\n.SAVEXKA ANOP\n&B       SETA  0\n.SAVEXLA ANOP\n&B       SETA  &B+1\n         AIF   ('&SYSECT'(1,&B) NE '&SYSECT').SAVEXLA\n         AGO   .SAVEXNA\n.SAVEXMA ANOP\n&B       SETA  0\n.SAVEXNA ANOP\n         AIF   (&B EQ 0).SAVEXND                               *FG75188\n         AIF   ('&TMS'(1,1) NE 'Y').SAVEXNB                    *FG75188\n&B       SETA  &B+2+K'&TDATE+K'&TTIME                          *FG75188\n.SAVEXNB AIF   ('&XID' EQ '').SAVEXNC                          *FG75188\n&B       SETA  &B+K'&XID+1                                     *FG75188\n         AIF   ('&XID'(1,1) NE '''').SAVEXNC                   *FG75189\n&B       SETA  &B-2                                            *FG75189\n.SAVEXNC AIF   ('&PARM'(1,1) NE 'Y').SAVEXND                   *FG75189\n&B       SETA  &B+K'&SYSPARM+1                                 *FG75189\n.SAVEXND AIF   (&A EQ 0 AND &B EQ 0).SAVEXPA                   *FG75190\n         AIF   (&A EQ 0).SAVEXOA\n&C       SETA  (&B+4)/4*4-&B-1\n         AGO   .SAVEXQA\n.SAVEXOA ANOP\n&C       SETA  (&B+2)/2*2-&B-1\n         AGO   .SAVEXQA\n.SAVEXPA ANOP\n&C       SETA  0\n&D       SETA  0\n&E       SETA  0\n         AGO   .SAVEXRA\n.SAVEXQA ANOP\n&D       SETA  &B                                              *AB78305\n&E       SETA  &A+&D+&C+5                                      *AB78305\n.SAVEXRA ANOP\n         AIF   ('&CSECT'(1,1) NE 'N').SAVEXSA\n         CNOP  0,4                SAVEX STARTS ON A FULLWORD BOUNDARY\n         AIF   ('&LABEL' EQ '').SAVEXTA\n&LABEL   DS    0F                 DEFINE LABEL\n         AGO   .SAVEXTA\n.SAVEXSA ANOP\n&LABEL   CSECT                    ESTABLISH CONTROL SECTION\n.SAVEXTA ANOP\n         USING *,15               REGISTER 15 IS BASE AT ENTRY\n         AIF   (&E EQ 0).SAVEXYA\n         B     *+&E               BRANCH AROUND CONSTANTS\n         DC    AL1(&D)            LENGTH OF CONSTANTS\n         AIF   (&B EQ 0).SAVEXWA\n         AIF   ('&ID' NE '*').SAVEXVA\n         AIF   ('&LABEL' EQ '').SAVEXUA\n         DC    C'&LABEL' IDENTIFIER\n         AGO   .SAVEXWA\n.SAVEXUA ANOP\n         DC    C'&SYSECT' IDENTIFIER\n         AGO   .SAVEXWA\n.SAVEXVA ANOP\n         DC    C'&ID' IDENTIFIER\n.SAVEXWA AIF   ('&TMS'(1,1) NE 'Y').SAVEXWB                    *FG75189\n         DC    C'-&TDATE.-&TTIME' TIME AND DATE OF ASSEMBLY\n.SAVEXWB AIF   ('&XID' EQ '').SAVEXWC                          *FG75189\n         DC    C'-'\n         AIF   ('&XID'(1,1) EQ '''').SAVEXWZ                   *FG75189\n         DC    C'&XID' EXTENDED IDENTIFIER\n         AGO   .SAVEXWC                                        *FG75189\n.SAVEXWZ DC    C&XID EXTENDED IDENTIFIER\n.SAVEXWC AIF   ('&PARM'(1,1) NE 'Y').SAVEXWD                   *FG75189\n         DC    C'-&SYSPARM' SYSPARM SUPPLIED TO ASSEMBLER\n.SAVEXWD AIF   (&A EQ 0).SAVEXYA                               *FG75189\n&F       SETA  0-(&B+&C+1)\n&G       SETA  N'&BASE\n&H       SETA  2\n.SAVEXXA ANOP\n&F       SETA  &F+4092\n         DC    A(*+&F) BASE ADDRESS CONSTANT\n&H       SETA  &H+1\n         AIF   (&H LE &G).SAVEXXA\n.SAVEXYA ANOP\n&H       SETA  &REGS(1)*4+20\n         AIF   (&H LE 75).SAVEXZA\n&H       SETA  &H-64\n.SAVEXZA ANOP\n         AIF   (N'&REGS NE 2).SAVEX0A\n         STM   &REGS(1),&REGS(2),&H.(13)       SAVE REGISTERS\n         AGO   .SAVEX1A\n.SAVEX0A ANOP\n         ST    &REGS(1),&H.(,13)         SAVE REGISTER\n.SAVEX1A ANOP\n         AIF   ('&BASE' EQ '').SAVEX9A\n         AIF   ('&BASE(1)' EQ '15' AND &A EQ 0).SAVEX9A        *AB78004\n         DROP  15\n&K       SETA  &E+4\n         AIF   (&A NE 0).SAVEX2A\n         USING *-&K,&BASE(1)            ESTABLISH BASE REGISTER\n         LR    &BASE(1),15\n         AGO   .SAVEX9A\n.SAVEX2A ANOP\n&H       SETA  2\n&I       SETA  K'&BASE-2\n&J       SETA  1\n.SAVEX3A ANOP\n         AIF   (&I LT 8).SAVEX4A\n&L(&J)   SETC  '&BASE'(&H,8)\n&H       SETA  &H+8\n&I       SETA  &I-8\n&J       SETA  &J+1\n         AGO   .SAVEX3A\n.SAVEX4A ANOP\n         AIF   (&I EQ 0).SAVEX5A\n&L(&J)   SETC  '&BASE'(&H,&I)\n.SAVEX5A ANOP\n         USING *-&K,&L(1).&L(2).&L(3).&L(4).&L(5) ESTABLISH BASE REGISTX\n               ERS\n         AIF   ('&BASE(1)' EQ '15').SAVEX5B                    *AB78004\n         LR    &BASE(1),15\n.SAVEX5B ANOP\n&H       SETA  2\n&I       SETA  N'&BASE\n&H       SETA  &A+4                                            *AB78004\n         AIF   ('&BASE(1)' EQ '15').SAVEX5C                    *AB78004\n&H       SETA  &A+6                                            *AB78004\n.SAVEX5C ANOP  ,                                               *AB78004\n&J       SETA  2\n         AIF   (&I EQ 2).SAVEX7A                               *AB78199\n&TB      SETC  T'&BASE(2)                                      *AB78004\n         AIF   ('&TB' NE 'N').SAVEX7A                          *AB78004\n.SAVEX6A ANOP\n&G       SETA  &J                                              *AB78004\n.SAVEX6C ANOP  ,                                               *AB78004\n         AIF   (&J GE &I).SAVEX8A                              *AB78004\n&TB      SETC  T'&BASE(&J+1)                                   *AB78004\n         AIF   ('&TB' NE 'N').SAVEX8A                          *AB78004\n         AIF   (&BASE(&J+1) NE &BASE(&J)+1).SAVEX8A            *AB78004\n&J       SETA  &J+1                                            *AB78004\n         AGO   .SAVEX6C                                        *AB78004\n.SAVEX7A ANOP\n         L     &BASE(&J),*-&H                                  *AB78004\n&J       SETA  &J+1                                            *AB78004\n         AIF   (&J GT &I).SAVEX9A                              *AB78004\n&TB      SETC  T'&BASE(&J)                                     *AB78004\n         AIF   ('&TB' NE 'N').SAVEX7A                          *AB78004\n         AGO   .SAVEX6A                                        *AB78004\n.SAVEX8A ANOP\n         AIF   (&G EQ &J).SAVEX7A                              *AB78004\n         LM    &BASE(&G),&BASE(&J),*-&H                        *AB78004\n&H       SETA  &H-(&J-&G)*4                                    *AB78004\n&J       SETA  &J+1                                            *AB78004\n         AIF   (&J LE &I).SAVEX6A                              *AB78004\n.SAVEX9A ANOP\n         AIF   ('&CHAIN'(1,1) NE 'N').SAVEXZZ\n&SVXSIZE SETC  '-1'                                            *MW74138\n         AIF   ('&PARMR' EQ '' OR  '&PARMR' EQ '1').SAVEXZY    *AB76329\n.SAVEXZZ ANOP\n         AIF   ('&PARMR' EQ '').SAVEXP0                        *AB76329\n&PR      SETC  '2'                                             *AB76329\n         AIF   ('&PARMR' EQ '1').SAVEXP1                       *AB76329\n&PR      SETC  '&PARMR'                                        *AB76329\n.SAVEXP1 LR    &PR,1              SAVE PARAMETER REGISTER      *AB76329\n         AIF   ('&CHAIN'(1,1) EQ 'N').SAVEXZY                  *AB76329\n.SAVEXP0 ANOP  ,                                               *AB76329\n         AIF   ('&SA' EQ '').SAVEXYZ\n.* CHECK FOR INTERNAL SAVE AREA                                *MW73011\n         AIF   ('&SA' NE '*').SAVEXYY                          *MW73011\n         CNOP  0,4 .                                           *MW73011\n         BAL   1,*+76 .                                        *MW73011\n         DS    18F .                                           *MW73011\n         AGO   .SAVEXXZ                                        *MW73011\n.SAVEXYY ANOP                                                  *MW73011\n         LA    1,&SA          GET L(SAVE AREA)\n         AGO   .SAVEXXZ\n.SAVEXYZ ANOP\n&SVXSP   SETC  '0'                                             *MW74138\n         AIF   ('&SP' EQ '').SAVEXXX                           *MW73011\n&SVXSP   SETC  '&SP'                                           *MW74138\n         GETMAIN R,LV=&LV,SP=&SP .                             *MW73011\n         AGO   .SAVEXXZ                                        *MW73011\n.SAVEXXX ANOP                                                  *MW73011\n         GETMAIN R,LV=&LV\n.SAVEXXZ ANOP\n         ST    1,8(,13)           SATISFY STANDARD LINKAGE CONVENTIONS\n         ST    13,4(,1)             BY CHAINING SAVE AREAS BOTH\n         LR    13,1                 BACKWARD AND FOREWARD\n         AIF   ('&PARMR' NE '1').SAVEXZY                       *AB76329\n         LR    1,&PR              RESTORE PARM ADDR TO REG 1   *AB76329\n.SAVEXZY ANOP\n         AIF   ('&REGSTRS'(1,1) EQ 'N').SAVEX9B\n         AIF   (&SVXREG).SAVEX9B\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nRA       EQU   10\nRB       EQU   11\nRC       EQU   12\nRD       EQU   13\nRE       EQU   14\nRF       EQU   15\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nFR0      EQU   0\nFR2      EQU   2\nFR4      EQU   4\nFR6      EQU   6\n.SAVEX9B ANOP\n&SVXREG  SETB  1\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SEQCOPY": {"ttr": 8966, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "SCOP     TITLE 'SEQUENTIAL COPY UTILITY'\n         MACRO\n&N       PRT   &M,&EN,&MF=I\n         LCLA  &J,&K\n&K       SETA  K'&M\n         AIF   ('&MF' EQ 'L').L1\n&N       LA    R0,MS&SYSNDX\n         BAL   R14,PRINT\nPRTEXT   CSECT\nMS&SYSNDX DC   AL2(3+&K),X'8000'\n.L2      ANOP\n&EN      DC    C'0',C&M\n         DC    X'00000020'\n&SYSECT  CSECT\n         MEXIT\n.L1      ANOP\nPRTEXT   CSECT\n&J       SETA  &K+5\n&N       DS    0CL&J\n         DC    AL2(3+&K),X'8000'\n         AGO   .L2\n         MEND\n         MACRO\n         JUMP  &I,&O\n         BAL   LR,&I\n         BAL   LR,&O\n         MEND\n         MACRO\n         USEI\n         GBLC  &DBASE\n         AIF   ('&DBASE' EQ 'IR').GOTBASE\n         AIF   ('&DBASE' EQ '').NODROP\n         DROP  &DBASE\n.NODROP  USING IHADCB,IR\n&DBASE   SETC  'IR'\n.GOTBASE MEND\n         MACRO\n         USEO\n         GBLC  &DBASE\n         AIF   ('&DBASE' EQ 'OR').GOTBASE\n         AIF   ('&DBASE' EQ '').NODROP\n         DROP  &DBASE\n.NODROP  USING IHADCB,OR\n&DBASE   SETC  'OR'\n.GOTBASE MEND\n         MACRO\n         USEP\n         GBLC  &DBASE\n         AIF   ('&DBASE' EQ 'PR').GOTBASE\n         AIF   ('&DBASE' EQ '').NODROP\n         DROP  &DBASE\n.NODROP  USING IHADCB,PR\n&DBASE   SETC  'PR'\n.GOTBASE MEND\n         MACRO\n         USES\n         GBLC  &DBASE\n         AIF   ('&DBASE' EQ 'SR').GOTBASE\n         AIF   ('&DBASE' EQ '').NODROP\n         DROP  &DBASE\n.NODROP  USING IHADCB,SR\n&DBASE   SETC  'SR'\n.GOTBASE MEND\n         MACRO\n         REGS\n         LCLA  &I\n.NXT     AIF   (&I EQ 16).END\nR&I      EQU   &I\n&I       SETA  &I+1\n         AGO   .NXT\n.END     MEND\n         EJECT\n***********************************************************************\n*     THIS PROGRAM COPIES ONE SEQUENTIAL DATASET TO ANOTHER USING\n*   QSAM (THUS THE DATASETS MUST NOT CONTAIN KEYED RECORDS),\n*   MAKING THE FOLLOWING TYPES OF FORMAT CHANGES -\n*\n*        BLOCKED TO UNBLOCKED OR VICE VERSA\n*        RECORD FORMAT CHANGES WHERE POSSIBLE\n*        REBLOCKING\n*\n*           THE FOLLOWING TABLE SHOWS ACCEPTABLE SOURCE AND TARGET\n*        RECORD FORMATS -\n*\n*                 S O U R C E\n* TARGET *  F  *  FB  *  V  *  VB  *  U  *\n*        *-----*------*-----*------*-----*\n*   F    *     *      * T/F * T/F  * T/F *\n*        *     *      *     *      *     *\n*   FB   *     *      * T/F * T/F  * T/F *\n*        *     *      *     *      *     *\n*   V    *     *      *     *      *     *\n*        *     *      *     *      *     *\n*   VB   *     *      *     *      *     *\n*        *     *      *     *      *     *\n*   U    *     *      *     *      *     *\n*        *-----*------*-----*------*-----*\n*\n*           THE EMPTY CELLS SHOWN ABOVE INDICATE THAT NO DATA IS LOST\n*        AND THAT THE COPY AND OPTIONAL TRANSFORMATION OCCUR AS\n*        IMPLICITLY SPECIFIED.  WHEN FORMAT V, VB, OR U ARE\n*        CONVERTED TO FORMAT F OR FB, TRUNCATION OR RIGHT BLANK FILL\n*        OCCURS AS NECESSARY.\n*\n*           AN EARLIER VERSION OF THIS PROGRAM OFFERED THE OPTION TO\n*        BE INVOKED VIA LINK, ATTACH, OR XCTL AND THE OPTION TO CHANGE\n*        THE DEFAULT DDNAMES.  THIS VERSION WILL SIMPLY ALWAYS USE THE\n*        DEFAULT DDNAMES -\n*\n*        SYSPRINT  MESSAGE DATA SET\n*        SYSUT1    INPUT DATA SET\n*        SYSUT2    OUTPUT DATA SET\n*\n*   MODIFICATION ITEMS\n* 1) WHEN OUTPUT DATA SET IS A UNIT RECORD DEVICE, FORCE THE\n*    RECORD FORMAT TO BE UNBLOCKED AND\n*    THE BLOCKSIZE TO BE THE SAME AS THE LRECL.\n* 2) REMOVE EXTRA LEADING BLANK FROM HEADER MESSAGE.\n*    DOUBLE SPACE ALL OTHER MESSAGES.\n* 3) SUPPORT SPANNED RECORDS.\n* 4) SUPPORT RECFM=D\n*\n***********************************************************************\n         EJECT\nSEQCOPY  START\n         PRINT NOGEN\n         REGS\nBR       EQU   R2                 BASE REGISTER\nIR       EQU   R3                 INPUT DCB ADDRESS\nOR       EQU   R4                 OUTPUT DCB ADDRESS\nPR       EQU   R5                 PRINT DCB ADDRESS\nSR       EQU   R6                 SCRATCH\nWR       EQU   R7                 SCRATCH\nPDR      EQU   R8                 ERROR MESSAGE TEMPLATE DSECT BASE\nLR       EQU   R9                 LINK REGISTER\nIRECPT   EQU   R10                INPUT ADDRESS (EVEN FOR MVCL)\nILRECL   EQU   R11                INPUT LENGTH (ODD FOR MVCL)\n         EJECT\n         SAVE  (14,12),,*\n         USING SEQCOPY,BR\n         LR    BR,R15             ESTABLISH BASE REGISTER\n         ST    R13,SAVE+4\n         LA    R13,SAVE\n         LA    IR,IN              INPUT DCB ADDRESS\n         LA    OR,OUT             OUTPUT DCB ADDRESS\n         LA    PR,PRINTDCB        PRINT DCB ADDRESS\n         OPEN  (IN,,OUT,(OUTPUT),PRINTDCB,(OUTPUT))\n         USEP\n         TM    DCBOFLGS,X'10'     Q.DID SYSPRINT OPEN\n         BO    PRTOPEN            YES.\n         OI    POPEN+1,X'F0'      FORCE MESSAGES TO JOB LOG\n         WTO   'OPEN FAILED FOR SYSPRINT',ROUTCDE=11\n         USING PRTEXT,PDR\nPRTOPEN  L     PDR,=A(PRTEXT)\n         LA    R0,HEADING\n         BAL   R14,PRINT          PRINT OPENING LINE\n         B     OM0I               GO PRINT OPEN EXIT MESSAGES\nTSYS1OP  NI    OMX+1,X'0F'        FORCE TO NO-OP\n         USEI\n         TM    DCBOFLGS,X'10'     Q.DID SYSUT1 OPEN\n         BO    SYS1OP             YES.\n         PRT   'SEQ001 UNABLE TO OPEN SYSUT1 - EOJ'\n         B     BADRET\n         USEO\nSYS1OP   TM    DCBOFLGS,X'10'     Q.DID SYSUT2 OPEN\n         BO    SYS2OP             YES.\n         PRT   'SEQ002 UNABLE TO OPEN SYSUT2 - EOJ'\n         B     BADRET\n         SPACE 2\nIOERR1   LR    R0,R1              A(SYNAD MESSAGE BUFFER) TO R0\n         BAL   R14,PRINT          PRINT I/O ERROR MESSAGE\nIOERR2   SYNADRLS\n         L     R14,ERRRET         GET ERROR RETURN\n         USES\n         TM    DCBEROPT,X'C0'     Q.SKIP OR ACCEPT ERROR\n         BCR   7,R14              YES, RETURN\nBADRET   MVI   RC+3,16            SET COND CODE = 16\n         B     CLOSE\n         SPACE 2\n*   INPUT DATA SET END OF DATA ROUTINE\nEOF      MVC   NUM+8(9),=X'202020202020202120'\n         ED    NUM+7(10),RECCOUNT\n         PRT   'SEQ009 XXXXXXXXX LOGICAL RECORDS WERE COPIED',NUM\n         PRT   'SEQ010 END OF JOB - SEQUENTIAL COPY UTILITY'\n         SPACE 2\nCLOSE    CLOSE (PRINTDCB,,OUT,,IN)  CLOSE ALL DATA SETS\n         L     R15,RC\n         L     R13,4(0,R13)\n         RETURN (14,12),RC=(15)\n         EJECT\n***********************************************************************\n*           SELECT INPUT AND OUTPUT ROUTINES TO USE BASED ON THE\n*        INPUT AND OUTPUT RECORD FORMATS -\n*\n*   INPUT RECFM     F    0\n*                   V    8\n*                   U   16\n*\n*  OUTPUT RECFM     F    0\n*                   V   24\n*                   U   48\n*\n*           THUS WE HAVE THE FOLLOWING CASE SELECTION -\n*\n*        RECFM         ROUTINE       CODE\n*    INPUT  OUTPUT  INPUT  OUTPUT    VALUE\n*      F      F     INPUT1 OUT1        0\n*      V      F     INPUT2 OUT1        8\n*      U      F     INPUT1 OUT1       16\n*    -----------------------------------\n*      F      V     INPUT1 OUT2       24\n*      V      V     INPUT1 OUT1       32\n*      U      V     INPUT1 OUT2       40\n*    -----------------------------------\n*      F      U     INPUT1 OUT1       48\n*      V      U     INPUT1 OUT1       56\n*      U      U     INPUT2 OUT1       64\n*\n***********************************************************************\n         EJECT\n*   PRINT OUT ANY MESSAGES SET BY THE OPEN EXITS\nOM0I     B     OM0O\n         OI    OM0I+1,X'F0'\n         USEI\n         TM    DCBDEVT,X'20'      INPUT ON DA DEVICE?\n         BZ    OM0O               NO, NO ERROR\nOM0E     PRT   'SEQ006 KEYED RECORDS NOT SUPPORTED'\n         MVI   RC+3,16\n         B     CLOSE\nOM0O     B     OM1\n         OI    OM0O+1,X'F0'\n         USEO\n         TM    DCBDEVT,X'20'      OUTPUT ON DA DEVICE?\n         BNZ   OM0E               YES, ERROR\nOM1      B     OM2\n         OI    OM1+1,X'F0'        CLOSE GATE\n         PRT   'SEQ003 INPUT RECFM MISSING - FB ASSUMED'\nOM2      B     OM3\n         OI    OM2+1,X'F0'        CLOSE GATE\n         PRT   'SEQ004 INPUT BLKSIZE MISSING - SET TO 80'\nOM3      EQU   *\nOMX      B     TSYS1OP            ONE-SHOT BRANCH\n         SPACE 2\n         USEI                     PROCESS I/P RECFM\nSYS2OP   B     RECFMTS            ONLY ONE MESSAGE FOR OUTPUT FILE\n         OI    SYS2OP+1,X'F0'     CLOSE GATE SINCE IT WAS OPEN\n         PRT   'SEQ005 OUTPUT TO UNIT RECORD, UNBLOCKING FORCED'\nRECFMTS  TM    INRECFM,X'C0'      Q.RECFM=U\n         BO    INISU              YES.\n         SR    WR,WR              CODE FOR RECFM F\n         TM    INRECFM,X'80'      Q.RECFM=F\n         BO    INISF              YES.\n         LA    WR,8               ELSE DEFAULT TO V\n         B     INISF\nINISU    LA    WR,16              CODE FOR RECFM U\n         USEO                     PROCESS O/P RECFM\nINISF    TM    OUTRECFM,X'C0'     Q.RECFM=U\n         BO    OUTISU             YES.\n         TM    OUTRECFM,X'80'     Q.RECFM=F\n         BO    OUTISF             YES.\n         LA    WR,24(0,WR)        ADD 24 IF RECFM V\n         B     OUTISF\nOUTISU   LA    WR,48(0,WR)        ADD 48 IF RECFM U\n         SPACE 2\n*\n*        BEGIN COPY FROM SYSUT1 TO SYSUT2\n*\nOUTISF   STC   WR,CASE            INDICATE I/O CASE\n         LA    WR,RTTAB(WR)       INDEX TO BRANCH PAIR\n         MVC   INROUTE,0(WR)      PLANT INPUT GATE\n         MVC   OUTROUTE,4(WR)     PLANT OUTPUT GATE\n         NI    TRAP+1,X'0F'       OPEN UNLIKE CONCATENATION GATE\nINROUTE  BAL   LR,*-*             INPUT GATE\nTRAP     NOP   OM0I               B IF UNLIKE CONCATENATION\n         AP    RECCOUNT,=P'1'     ADD ONE TO RECORD COUNTER\nOUTROUTE BAL   LR,*-*             OUTPUT GATE\n         B     INROUTE            CLOSE LOOP\n         EJECT\n***********************************************************************\n*        INPUT ROUTINE #1\n***********************************************************************\nINPUT1   GET   (IR)               GET LOCATE MODE\n         USEI\n         LR    IRECPT,R1          COPY RECORD ADDRESS\n         LH    ILRECL,DCBLRECL    AND ITS LENGTH\n         BR    LR\n         SPACE 3\n***********************************************************************\n*        INPUT ROUTINE #2\n***********************************************************************\nINPUT2   GET   (IR)               GET LOCATE MODE\n         USEI\n         LA    IRECPT,4(0,R1)     POINT AT DATA\n         LH    ILRECL,DCBLRECL    GET LENGTH OF DATA AND PREFIX\n         S     ILRECL,=F'4'       TRIM TO OMIT HEADER\n         BR    LR\n         EJECT\n***********************************************************************\n*        OUTPUT ROUTINE #1\n***********************************************************************\nOUTPUT1  CLI   CASE,24            Q.IS OUTPUT FORMAT F\n         BL    FIXOUT             YES, DCB LRECL IS FIXED\n         USEO\n         STH   ILRECL,DCBLRECL    STORE OUTPUT LRECL\nFIXOUT   PUT   (OR)               LOCATE BUFFER FOR OUTPUT\n         LH    R15,DCBLRECL       GET OUTPUT AREA LENGTH\n*\n*        IRECPT        = ADDRESS OF INPUT AREA\n*        ILRECL        = LENGTH OF INPUT AREA AND PAD BYTE\n*        R14           = ADDRESS OF OUTPUT AREA\n*        R15           = LENGTH OF OUTPUT AREA\n*\nMOVE     LR    R14,R1             COPY OUTPUT AREA ADDRESS\n         ICM   ILRECL,8,=C' '     USE BLANK PAD CHARACTER\n         MVCL  R14,IRECPT         COPY FROM INPUT TO OUTPUT\n         BR    LR                 AND EXIT OUTPUT STAGE\n         SPACE 3\n***********************************************************************\n*        OUTPUT ROUTINE #2\n***********************************************************************\n         USEO\nOUTPUT2  LA    WR,4(0,ILRECL)     GET INPUT LENGTH PLUS 4\n         STH   WR,DCBLRECL        STORE IN OUTPUT DCB\n         PUT   (OR)               TAKE AN OUTPUT AREA\n         STH   WR,0(0,R1)         PLANT LL\n         SR    R0,R0\n         STH   R0,2(0,R1)         PLANT 00\n         LA    R1,4(0,R1)         POINT AT RECORD AREA\n         LR    R15,ILRECL         LOAD OUTPUT LENGTH FOR MOVE\n         B     MOVE               TRANSFER DATA PORTION\n         EJECT\nRTTAB    DS    0F\n         JUMP  INPUT1,OUTPUT1     F TO F\n         JUMP  INPUT2,OUTPUT1     V TO F\n         JUMP  INPUT1,OUTPUT1     U TO F\n*\n         JUMP  INPUT1,OUTPUT2     F TO V\n         JUMP  INPUT1,OUTPUT1     V TO V\n         JUMP  INPUT1,OUTPUT2     U TO V\n*\n         JUMP  INPUT1,OUTPUT1     F TO U\n         JUMP  INPUT2,OUTPUT1     V TO U\n         JUMP  INPUT1,OUTPUT1     U TO U\n*\n         EJECT\n*   PRINTER DCB OPEN EXIT ROUTINE\n         USEP\nPRNTEXIT NI    DCBRECFM,X'39'     CLEAR EXTRANEOUS BITS\n         OI    DCBRECFM,X'44'     SET TO FORMAT VA\n         LH    WR,DCBLRECL\n         LTR   WR,WR              Q.LRECL SPECIFIED\n         BNZ   PRBLKSI            YES, GO CHECK BLOCKSIZE\nPRDEFLR  LA    WR,137\n         STH   WR,DCBLRECL        INSERT DEFAULT LRECL\nPRBLKSI  LH    SR,DCBBLKSI\n         LTR   SR,SR              Q.BLOCKSIZE SPECIFIED\n         BNZ   PRLRECK            YES.\n         LA    SR,141\n         STH   SR,DCBBLKSI        INSERT DEFAULT BLOCKSIZE\nPRLRECK  CH    WR,=Y(125)         Q.LRECL LESS THAN MINIMUM\n         BL    PRDEFLR            YES, USE DEFAULT\n         LA    WR,4(0,WR)         COMPUTE MIN BLOCKSIZE\n         CR    SR,WR              Q.IS BLOCKSIZE LARGE ENOUGH\n         BNL   PRBLKOK            YES.\n         LR    SR,WR              ELSE USE MINIMUM\nPRBLKOK  STH   SR,DCBBLKSI\n         BR    R14\n         SPACE 3\n*   SYSPRINT OUTPUT SUBROUTINE\nPRINT    ST    R14,WORK           SAVE RETURN ADDRESS\nPOPEN    NOP   PRWTP\n         PUT   (PR),(0)\n         L     R14,WORK           RELOAD RETURN ADDRESS\n         BR    R14\nPRWTP    LR    R1,R0              COPY FOR WTO\n         MVI   4(R1),C' '         BLANK OUT ASA CONTROL CHARACTER\n         WTO   MF=(E,(1))\n         L     R14,WORK\n         BR    R14\n*   SYSPRINT SYNAD ROUTINE\nPRINTERR LR    SR,PR              SAVE DCB PTR\n         ST    R14,ERRRET         SAVE SYNAD RETURN\n         SYNADAF ACSMETH=QSAM\n         MVC   5(L'SQM4-5,R1),SQM4+5  INSERT OUR HEADER INTO MESSAGE\n         WTO   MF=(E,(1))         DISPLAY THE MESSAGE\n         B     IOERR2\nSQM4     PRT   'SEQ011 I/O ERROR ON SYSPRINT - EOJ',MF=L\n         EJECT\n*   INPUT DCB OPEN EXIT\n         USEI\nINEXIT   CLI   DCBKEYLE,0         IS KEYLEN = 0?\n         BE    INKEYL\n         NI    OM0I+1,X'0F'       KEYS NOT SUPPORTED\nINKEYL   CLI   DCBBUFNO,0         Q.BUFFER COUNT EXPLICIT\n         BNZ   IBUFNO             YES.\n         MVI   DCBBUFNO,4         NO, GIVE IT 4 BUFFERS\nIBUFNO   TM    DCBRECFM,X'C0'     Q.RECFM SPECIFIED\n         BNZ   IRECFM             YES.\n         TM    DCBOPTCD,X'08'     CHECK FOR ASCII TAPE (OPTCD Q)\n         BZ    IRECFB             IF NOT, DEFAULT RECFM TO FB\n         TM    DCBRECFM,X'20'     IS THE RECFM=D?\n         BZ    IRECFB             NO, DEFAULT IT\n         MVC   INRECFM,DCBRECFM   YES, SAVE IT AS V\n         XI    INRECFM,X'60'\n         B     IRECFMD            SKIP FB CODE\nIRECFB   OI    DCBRECFM,X'90'     NO, DEFAULT TO FB\n         NI    OM1+1,X'0F'        ACTIVATE MESSAGE 1\nIRECFM   MVC   INRECFM,DCBRECFM   SAVE INPUT RECORD FORMAT\nIRECFMD  OC    DCBBLKSI,DCBBLKSI  Q.BLOCKSIZE GIVEN\n         BNZ   IBLKSI             YES.\n         MVI   DCBBLKSI+1,80      NO, DEFAULT TO 80\n         NI    OM2+1,X'0F'        ACTIVATE MESSAGE 2\nIBLKSI   TM    DCBRECFM,X'48'     IS INPUT VS?\n         BNO   ISPAND             NO.\n         OI    DCBBFTEK,X'60'     YES, FORCE BFTEK=A TO GET RECORDS\nISPAND   NOP   SETSW              ONE TIME SWITCH\n         OI    ISPAND+1,X'F0'     CLOSE GATE BEHIND US\n         OI    DCBOFLGS,X'08'     SHOW WE ALLOW UNLIKE CONCATENATION\n         BR    R14\nSETSW    OI    TRAP+1,X'F0'       TURN ON RE-INITIALIZE TRAP\n         BR    R14\n         SPACE 5\n*   INPUT DCB SYNAD ROUTINE\nINERR    LR    SR,IR              COPY DCB ADDRESS\n         ST    R14,ERRRET         SAVE RETURN ADDRESS\n         SYNADAF ACSMETH=QSAM\n         MVC   5(L'SQM5-5,R1),SQM5+5  INSERT OUR HEADER INTO MESSAGE\n         B     IOERR1\nSQM5     PRT   'SEQ012 I/O ERROR ON INPUT DATA SET',MF=L\n         EJECT\n*   OUTPUT DCB OPEN EXIT ROUTINE\n         USEO\nOUTEXIT  CLI   DCBKEYLE,0         IS KEYLEN = 0?\n         BE    OUTKEYL\n         NI    OM0O+1,X'0F'       KEYS NOT SUPPORTED\n         BR    R14                SKIP REST OF EXIT\nOUTKEYL  CLI   DCBBUFNO,0         Q.BUFFER COUNT EXPLICIT\n         BNZ   OX1                YES.\n         MVI   DCBBUFNO,4         NO, GIVE IT 4 BUFFERS\nOX1      TM    DCBRECFM,X'C0'     Q.RECFM SPECIFIED\n         BNZ   OX2                YES.\n         TM    DCBOPTCD,X'08'     ASCII OUTPUT TAPE (OPTCD=Q)?\n         BZ    OX1D               NO, COPY RECFM FROM INPUT\n         TM    DCBRECFM,X'20'     YES, OUTPUT RECFM=D?\n         BZ    OX1AD              NO, DEFAULT FROM INPUT\n         MVC   OUTRECFM,DCBRECFM  YES, SAVE AS V FOR PROCESSING\n         XI    OUTRECFM,X'60'\n         B     OX1B               GO PROCESS BUFOFF\nOX1AD    MVC   DCBRECFM(1),INRECFM     COPY OUTPUT RECFM FROM INPUT\n         MVC   OUTRECFM,INRECFM\n         TM    INRECFM,X'80'      IS INPUT V OR D?\n         BNZ   OX2A               NO, CONTINUE\n         XI    DCBRECFM,X'60'     YES, MAKE OUTPUT D\nOX1B     CLI   DCBBUFOF,4         IS THE BUFOFF=4?\n         BNE   OX2A               NO.\n         OI    DCBUSASI,X'40'     YES, SET BUFOFF=L\n         B     OX2A               AND SKIP NON-ASCII CODE\nOX1D     MVC   DCBRECFM(1),INRECFM              ELSE COPY FROM INPUT\nOX2      MVC   OUTRECFM,DCBRECFM  SAVE OUTPUT RECORD FORMAT\nOX2A     OC    DCBBLKSI,DCBBLKSI  Q.BLOCK SIZE SPECIFIED\n         BNZ   OX3                YES.\n         MVC   DCBBLKSI,DCBBLKSI-IHADCB(IR)  ELSE COPY FROM INPUT\nOX3      OC    DCBLRECL,DCBLRECL  Q.LRECL SPECIFIED\n         BNZ   OX4                YES.\n         OC    DCBLRECL,DCBLRECL-IHADCB(IR)  ELSE COPY FROM INPUT\n         BZ    OX5                DON'T BLOCK IF LRECL=0\nOX4      TM    DCBRECFM,X'40'     RECFM F?\n         BNZ   OX5                NO, DON'T SET BLOCKING\n         CLC   DCBLRECL,DCBBLKSI  LRECL \u00ac= BLKSIZE?\n         BE    OX5                NO.\n         OI    DCBRECFM,X'10'     YES, MAKE SURE RECFM=B\nOX5      TM    DCBDEVT,X'40'      Q.UNIT RECORD DEVICE\n         BZ    OX7                NO, CHECK FOR SPANNING\n         TM    DCBRECFM,X'10'     Q.RECORDS BLOCKED\n         BCR   8,R14              NO, ALREADY UNBLOCKED\n         NI    DCBRECFM,X'EF'     REMOVE BLOCKING\n         LH    WR,DCBLRECL        LOAD SPECIFIED LRECL\n         TM    DCBRECFM,X'80'     FIXED FORMAT?\n         BNZ   OX6                YES, USE LRECL AS BLKSIZE\n         LA    WR,4(,WR)          ADD 4 FOR V FORMAT\nOX6      ST    WR,DCBBLKSI        FORCE UNBLOCKED\n         NI    SYS2OP+1,X'0F'     SHOW UNBLOCKING FORCED\n         BR    R14                RETURN TO OPEN\nOX7      TM    DCBRECFM,X'48'     VS TYPE RECORDS?\n         BCR   14,R14             NO.\n         OI    DCBBFTEK,X'60'     YES, FORCE LOGICAL RECORD INTERFACE\n         BR    R14                AND RETURN\n         SPACE 3\n*   OUTPUT DCB SYNAD ROUTINE\nOUTERR   LR    SR,OR              COPY DCB ADDRESS\n         ST    R14,ERRRET         SAVE RETURN ADDRESS\n         SYNADAF ACSMETH=QSAM\n         MVC   5(L'SQM6-5,R1),SQM6+5  INSERT OUR HEADER INTO MESSAGE\n         B     IOERR1\nSQM6     PRT   'SEQ013 I/O ERROR ON OUTPUT DATA SET - EOJ',MF=L\n         EJECT\nIN       DCB   DSORG=PS,MACRF=GL,DDNAME=SYSUT1,                        X\n               SYNAD=INERR,EXLST=INEX,EODAD=EOF\nOUT      DCB   DSORG=PS,MACRF=PL,DDNAME=SYSUT2,                        X\n               SYNAD=OUTERR,EXLST=OTEX\nPRINTDCB DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,                      X\n               SYNAD=PRINTERR,EXLST=PREX\nWORD     DS    D\nINEX     DC    X'85',AL3(INEXIT)\nOTEX     DC    X'85',AL3(OUTEXIT)\nPREX     DC    X'85',AL3(PRNTEXIT)\nCASE     DC    F'0'               JUMP CASE IN HIGH BYTE\nSAVE     DS    18F\nWORK     DS    F\nERRRET   DS    A\nRC       DC    A(0)\nINRECFM  DS    XL1                INPUT RECORD FORMAT\nOUTRECFM DS    XL1                OUTPUT RECORD FORMAT\n         LTORG\nRECCOUNT DC    P'+000000000'\nHEADING  DC    AL2(EH-HEADING,0)\n         DC    C'1SEQ000 SEQUENTIAL DATA SET COPY UTILITY'\nEH       EQU   *\n         DS    0D\n         DCBD  DSORG=QS,DEVD=DA\n         END   SEQCOPY\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SEQCOPY$": {"ttr": 9221, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//SEQCOPY  PROC\n//*********************************************************************\n//* SEQCOPY: SEQUENTIAL COPY UTILITY                                ***\n//* SEE ICSA DOCUMENT UTL003                                        ***\n//*                                                   09/26/80 ARB  ***\n//*********************************************************************\n//COPY     EXEC PGM=SEQCOPY,REGION=192K\n//SYSPRINT DD  SYSOUT=A\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TAPECOP$": {"ttr": 9223, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//TAPECOPY PROC ISER=CANCEL,IFILE=,ILABTYP=NL,IUNIT=TAPE9,IDEN=,\n//         ITRTCH=,OSER=CANCEL,OFILE=,OLABTYP=NL,OUNIT=TAPE9,ODEN=,\n//         OTRTCH=,VER=,OPTIONS=COUNT\n//********************************************************************\n//* TAPESCAN: TAPE SCANNING, ANALYSIS AND COPYING PROGRAM          ***\n//* SEE ICSA DOCUMENT UTL011                                       ***\n//*                                                    8/2/82 ARB  ***\n//********************************************************************\n//TAPECOPY EXEC PGM=TAPESCAN,REGION=128K,\n//             PARM='COPY,&OPTIONS'\n//STEPLIB  DD  DSN=SYS1.RICEPP&VER..LINKLIB,DISP=SHR\n//SYSPRINT DD  SYSOUT=A\n//INPUT    DD  UNIT=&IUNIT,VOL=SER=&ISER,LABEL=(&IFILE,&ILABTYP),\n//             DISP=(OLD,PASS),DCB=(DEN=&IDEN,TRTCH=&ITRTCH),\n//             DSN=TAPESCAN.INPUT.V&ISER\n//OUTPUT   DD  UNIT=&OUNIT,VOL=SER=&OSER,DISP=(OLD,PASS),\n//             LABEL=(&OFILE,&OLABTYP),DCB=(DEN=&ODEN,TRTCH=&OTRTCH),\n//             DSN=TAPESCAN.OUTPUT.V&OSER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TAPEMAP$": {"ttr": 9225, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//TAPEMAP  PROC ISER=CANCEL,IFILE=,ILABTYP=NL,IUNIT=TAPE9,IDEN=,\n//         ITRTCH=,VER=,OPTIONS=NOLIST\n//********************************************************************\n//* TAPESCAN: TAPE SCANNING, ANALYSIS AND COPYING PROGRAM          ***\n//* SEE ICSA DOCUMENT UTL011                                       ***\n//*                                                    8/2/82 ARB  ***\n//********************************************************************\n//TAPEMAP  EXEC PGM=TAPESCAN,REGION=128K,\n//             PARM='MAPONLY,&OPTIONS'\n//STEPLIB  DD  DSN=SYS1.RICEPP&VER..LINKLIB,DISP=SHR\n//SYSPRINT DD  SYSOUT=A\n//INPUT    DD  UNIT=&IUNIT,VOL=SER=&ISER,LABEL=(&IFILE,&ILABTYP),\n//             DISP=(OLD,PASS),DCB=(DEN=&IDEN,TRTCH=&ITRTCH),\n//             DSN=TAPESCAN.INPUT.V&ISER\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TAPESCA$": {"ttr": 9227, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//TAPESCAN PROC ISER=CANCEL,IFILE=,ILABTYP=NL,IUNIT=TAPE9,IDEN=,\n//         ITRTCH=,OSER=LLFILE,OFILE=,OLABTYP=NL,OUNIT=TAPE9,ODEN=,\n//         OTRTCH=,VER=,OPTIONS=\n//********************************************************************\n//* TAPESCAN: TAPE SCANNING, ANALYSIS AND COPYING PROGRAM          ***\n//* SEE ICSA DOCUMENT UTL011                                       ***\n//*                                                    8/2/82 ARB  ***\n//********************************************************************\n//TAPESCAN EXEC PGM=TAPESCAN,REGION=128K,\n//             PARM='&OPTIONS'\n//STEPLIB  DD  DSN=SYS1.RICEPP&VER..LINKLIB,DISP=SHR\n//SYSPRINT DD  SYSOUT=A\n//INPUT    DD  UNIT=&IUNIT,VOL=SER=&ISER,LABEL=(&IFILE,&ILABTYP),\n//             DISP=(OLD,PASS),DCB=(DEN=&IDEN,TRTCH=&ITRTCH),\n//             DSN=TAPESCAN.INPUT.V&ISER\n//OUTPUT   DD  DSN=NU&OSER,UNIT=&OUNIT,VOL=SER=&OSER,DISP=(OLD,PASS),\n//             LABEL=(&OFILE,&OLABTYP),DCB=(DEN=&ODEN,TRTCH=&OTRTCH)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TAPESCAN": {"ttr": 9229, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " TITLE 'TAPESCAN  -  IRSS/GTEDS/ICSA TAPE SCANNING, ANALYSIS, AND COPYI*\n               NG UTILITY - VERSION 5.1'\n***********************************************************************\n* COPYRIGHT   1982  BY RICE UNIVERSITY                                *\n*                                                                     *\n* PERMISSION TO MAKE PRIVATE COPIES OF THIS PROGRAM AND TO USE IT     *\n* FREELY IS HEREBY GRANTED BY RICE UNIVERSITY. THIS PROGRAM MAY NOT   *\n* BE SOLD, NOR MAY ANY SECTION OF IT BE INCORPORATED INTO ANY WORK    *\n* FOR SALE WITHOUT PERMISSION OF RICE UNIVERSITY. THIS STATEMENT      *\n* DOES NOT OVERRIDE OR OTHERWISE MODIFY ANY PREVIOUSLY EXISTING       *\n* RIGHTS OF ANY OTHER PERSONS OR ORGANIZATIONS RELATING TO THIER      *\n* CONTRIBUTIONS TO THIS PROGRAM.                                      *\n***********************************************************************\n         SPACE 5\nTAPESCAN CSECT ,\n         SPACE 2\nCOPYRITE CSECT ,                  COPYRIGHT THE LOAD MODULE TOO\n         DC    C'TAPESCAN V5.1 COPYRIGHT RICE UNIVERSITY 1982'\n         EJECT\n*     V E R S I O N  5.1\n* THIS VERSION OF TAPESCAN IS THE SAME AS VERSION 5.0 WITH A NUMBER\n* OF USABILITY ENHANCEMENTS, NOTABLY IN THE AREA OF THE VTOC\n* LISTING. HIGHLIGHTS ARE:\n*\n*        VTOC LISTING FOR NL TAPES.\n*        IMPROVED DISTINCTION BETWEEN LABEL FILES AND DATA FILES\n*             CONTAINING LABELS.\n*        DIFFERENT VTOC FORMATS FOR THE COUNT AND NOCOUNT OPTIONS.\n*        MAPONLY OPTION ADDED FOR VTOC LISTING ONLY.\n*        DIAGNOSTIC NOTES ADDED TO VTOC LISTING.\n*        PROTECTION STATUS ADDED TO LABEL SUMMARY (NOT VTOC).\n*        ADDED LISTING OF USER LABELS AND UNSUPPORTED ANS\n*              LABELS.\n*        ASCII->ASCII COPY MADE WITHOUT PASSING THROUGH EBCDIC\n*              (FOR WIERDOS WITH ANS LABELLED TAPES CONTAINING\n*               BINARY DATA).\n*        SUPPORT FOR INSTALLATION SECURITY EXIT (CAN BE USED\n*              AS AN ACF2 INTERFACE).\n*        SENSE EXCP FROM SYNAD EXIT REMOVED, DUE TO USELESSNESS.\n*        SPECIFIC MESSAGE FOR FILE PROTECTED OUTPUT TAPE ADDED.\n*\n* PLACEMENT OF PROGRAM SECTIONS: INIT CODE, INIT VARS, COMMON\n* ROUTINES, COMMON VARS, MAIN CODE, MAIN VARS, TERM CODE,\n* TERM VARS, SAVE AREA, LITERAL POOL.\n*\n*        FOR ASSISTANCE, CONTACT:\n*              ALAN BEALE\n*              RICE UNIVERSITY, ICSA\n*              P.O. BOX 1892\n*              HOUSTON, TX 77251\n*              (713) 527-4985\n         EJECT\n*     V E R S I O N  5.0\n* THIS VERSION OF TAPESCAN WAS FORMED BY MERGING VERSION 4.0 WITH\n* \"VERSION 3.5\", AS CONTAINED ON THE MVS CBT MODS TAPE. UPDATE\n* COMMENTS FROM THIS VERSION ARE:\n         SPACE\n* VERSION 3.1 INCLUDES EXPIRATION DATE, AVERAGE BLOCK SIZES, AND VTOC\n* LISTING AND WAS PRODUCED BY C. WRANDLE BARTH, GODDARD SPACE FLIGHT\n* CENTER, JANUARY 1975.\n*\n* THIS PROGRAM WAS MODIFIED FOR MVS, JUNE 1978 BY:\n*  STEVE R. HAGGERTY\n*  GTE DATA SERVICES\n*  MARINA DEL REY, CA 90291\n*  (213) 821-0511 EXT. 285\n*\n*  INSTALLED AT UNIONBANC COMPUTER CORPORATION ON 08/25/78\n*  BY HOWARD DEAN (TECHNICAL SERVICES). IF ANY PROBLEMS WITH\n*  THIS PROGRAM ARE ENCOUNTERED, PLEASE CONTACT:\n*\n*   HOWARD M. DEAN\n*   UNION BANK COMPUTER CORPORATION\n*   TECHNICAL SERVICES (8TH FLOOR)\n*   605 W. OLYMPIC BLVD.\n*   LOS ANGELES, CA. 90015\n*   PHONE - (213) 687-5719\n*\n* VERSION 3.2 CORRECTED VARIOUS BUGS.\n* VERSION 3.3 CHANGED OUTPUT TAPE HANDLING TO USE ONLY EXCP.\n* VERSION 3.4 CORRECTED FOR USE UNDER MVS REL. 3.7F *GTEDS LA*SRH*\n* VERSION 3.5 CORRECT BUGS AND ADD LINECNT PARAMETER *GTEDS LA*HMD*\n         SPACE\n* NOTE THAT ALL MODIFICATIONS REFERRED TO ABOVE MAY NOT HAVE BEEN\n* CARRIED OVER TO VERSION 5.0.\n         EJECT\n*     V E R S I O N  4.0\n* THIS VERSION OF TAPESCAN WAS PRODUCED BY ALAN BEALE AT ICSA,\n* RICE UNIVERSITY, USING IRSS VERSION 3.5 AS A STARTING POINT.\n* MOST OF THE CODE OF THE PROGRAM HAS BEEN MODIFIED IN SOME WAY.\n*\n* SIGNIFICANT NEW FEATURES AND ENHANCEMENTS FOR THIS VERSION ARE:\n*        ASCII TAPE HANDLING (INCLUDING ASCII->EBCDIC AND\n*              EBCDIC->ASCII),\n*        RESPECT FOR EXPIRATION DATE & PASSWORD PROTECTION,\n*        7-TRACK LABELED TAPE HANDLING,\n*        INPUT TAPE POSITIONING VIA LABEL JCL PARM,\n*        COMPLETE OUTPUT TAPE LABEL CHECKING (NO BLP),\n*        SUPPORT FOR 6250 BPI.\n*\n* CHANGES TO PREVIOUSLY SUPPORTED FUNCTIONS INCLUDE:\n*\n*        \"STANDARD\" PARAMETER SPECIFICATION (OPTION=VALUE),\n*        IMPROVED OUTPUT FORMATTING,\n*        FULLSUM OPTION REQUIRED FOR EXACT LABEL LIST,\n*        MAXTM/MAXEOV CHANGED TO STOPTM/STOPEOV,\n*        TM AND EOV PARMS MADE INDEPENDENT (NOT CUMULATIVE),\n*        NOVOLSER MADE DEFAULT, OPPOSITE NAMED UNLABEL,\n*        DEFAULT HEX CHANGED TO NOHEX,\n*        COPIED LABELS MODIFIED FOR GREATER ACCURACY,\n*        SCAN STATISTICS NOW GIVEN AFTER I/O ERROR.\n*\n*        THIS VERSION OF TAPESCAN REQUIRES THE 370 INSTRUCTION SET,\n*        A VS OPERATING SYSTEM, AND AUTHORIZATION (LINK-EDIT PARM AC=1)\n*\n* CORRECTION MADE 7/3/80:\n*\n*        IMPROVED SEQUENCING OF OUTPUT LABELS DURING COPY       -ARB80-\n         EJECT\n*     V E R S I O N  3.5\n* THIS PROGRAM, CALLED TAPESCAN, WAS WRITTEN BY WILL DALAND, SOCIAL\n* SCIENCE STATISTICAL LABORATORY, INSTITUTE FOR RESEARCH IN SOCIAL\n* SCIENCE, UNIVERSITY OF NORTH CAROLINA AT CHAPEL HILL, MARCH 1974.\n* SEE IRSS MEMO SSSL-7-3 FOR FURTHER DOCUMENTATION.\n*\n* SINCE THE PROGRAMMING FOR TAPESCAN WAS PUBLICLY FUNDED PERMISSION\n* IS GRANTED TO ANYONE TO USE THIS PROGRAM IN WHOLE OR IN PART.  IT IS\n* REQUESTED THAT WHEN DOING SO YOU GIVE CREDIT (PREFERABLY BOTH IN\n* SOURCE AND DOCUMENTATION) TO:\n* WILL DALAND, INST. FOR RES. IN SOC. SCI., AND UNC AT CHAPEL HILL.\n*\n* PLACEMENT OF PROGRAM SECTIONS: INIT CODE, INIT SUBS, INIT VARS,\n* INIT LITS, COMMON ROUTINES, COMMON VARS, COMMON LITS, MAIN CODE,\n* MAIN SUBS, MAIN VARS, MAIN LITS.\n*\n* OPT1=MENTION EVERY (EVERY) TAPEMARK IN JOB CONSOLE LOG\n* OPT8=DO NOT ATTEMPT TO REWIND TO LOAD POINT AT START OF RUN\n* OPT64=TERMINATE ON ANY EXCP ERROR\n* OP65536 =CONSIDER RECORDS STARTING WITH 'TAPEMARK' AS TAPEMARKS\n* OPT268435456=IGNORE DOUBLE TAPEMARKS ON OUTPUT TAPE UNTIL NL LABEL\n*              POSITION NUMBER IS REACHED.\n*   ABOVE OPTION MADE DEFAULT.                                  -ARB79-\n         EJECT\nMSECT    DSECT\nTRT1     DS    32D\nBLANKBUF DS    CL136              BLANKS FOR BLANKING MSGBUF FAST\nTRT2     DS    32D\nMSGBUF   DS    CL136\nPARMBUF  DS    CL120              PARM STRING COPY BUFFER       -ARB82-\nASCBUF   DS    CL120              RECORD COPY (ORIGINAL CODE)   -ARB79-\nRECBUF   DS    CL120              MINIMUM ALLOC, MAX ALLOC=32K  -ARB79-\n         SPACE 5\nTAPESCAN CSECT\nR0       EQU   0   WORK REG + SYSTEM USES\nR1       EQU   1   WORK REG + SYSTEM USES\nR2       EQU   2   MOSTLY FOR LINKAGE TO PUTLINE & GETNUM\nR3       EQU   3   USED IN PARM SCANNER + VTOC ENTRY POINTER.     -CWB-\nR4       EQU   4   BELOW LABEL 'PROCESS' COUNTS BLKS READ FOLLOWING A  *\n                   TAPEMARK OR THE LOAD POINT.\nR5       EQU   5   WORK, INTERNAL SUBROUTINE LINKAGE\nR6       EQU   6   WORK REG\nR7       EQU   7   WORK REG + LENGTH OF LAST BLK READ\nR8       EQU   8   PARM FIELD LENGTH CTR, TOTAL BYTES ON TAPE CTR\nR9       EQU   9   BASE REG FOR DSECT MSECT\nR10      EQU   10  MAIN LOOP CONTROL REGISTER                   -ARB82-\nR11      EQU   11  PERMANENT BASE REG\nR12      EQU   12  SEMIPERMANENT INITIALIZATION/TERMINATION/EXTENSION  *\n                   BASE REG.\nR13      EQU   13  SAVE AREA POINTER + LITERALS                 -ARB79-\nR14      EQU   14  WORK REG + SYSTEM USES\nR15      EQU   15  WORK REG + SYSTEM USES\nDCBTRTCH EQU   16\nDCBDEN   EQU   18\nDCBEODAD EQU   32\nDCBTIOT  EQU   40                                               -ARB79-\nDCBDEBAD EQU   44\nDCBOFLGS EQU   48\nDCBSYNAD EQU   56                                               -ARB82-\nDCBBLKSI EQU   62\nDCBIOBA  EQU   68  PTR TO BSAM'S IOB PREFIX\nIOBSENS0 EQU   2                                                -ARB79-\nIOBSENS1 EQU   3                                                -ARB79-\nIOBECBPT EQU   4\nIOBSTART EQU   16\nIOBCSW   EQU   9   LAST SEVEN BYTES OF CSW\nIOBDCBPT EQU   20\nDEBSDVM  EQU   32                                               -ARB79-\nDEBUCBAD EQU   32\nJFCBLTYP EQU   66                 LABEL TYPE (AL, LTM, ETC.)\nJFCBFLSQ EQU   68                 FILE SEQUENCE NUMBER, 0 OR 1 =1ST\nJFCTRTCH EQU   93                                               -ARB79-\nJFCOPTCD EQU   101                                              -ARB79-\nJFCBVOLS EQU   118                1ST BYTE OF JFCB VOLUME LIST\nTCBTIO   EQU   12                 TCB TIOT ADDR OFFSET          -ARB79-\nTIOCNJOB EQU   0                                                -ARB79-\nTIOCSTEP EQU   8                                                -ARB79-\nTIOEFSRT EQU   16                                               -ARB79-\nUCBNAME  EQU   13                                               -ARB79-\n         SPACE 5\n         PRINT NOGEN\n         USING *,R12              BASE FOR INITIALIZATION ONLY\n         STM   14,12,12(13)\n         LR    R12,R15            R12 = TEMP BASE FOR INITIALIZATION\n         L     R9,ASAVE           SET UP SAVE AREA/LIT PTR      -ARB79-\n         ST    R9,8(R13)\n         ST    13,4(R9)                                         -ARB79-\n         LR    R13,R9\n         USING SAVE,R13                                         -ARB79-\n         L     R11,=A(EXIT)       PERM BASE FOR MAIN & COMMON   -ARB82-\n         USING EXIT,R11                                         -ARB82-\n         L     R1,0(R1)           GET PTR TO PARM FIELD\n         LH    R8,0(R1)           LOAD PARM FIELD LENGTH\n         LA    R3,2(R1)           SET PTR TO PARM FIELD CHAR STRING\n         LA    R9,SRCHPRM         LOAD TEMPORARY BASE FOR MSECT DSECT\n         USING MSECT,R9           TEMPORARY DECLARATION FOR MSECT BASE\n         OPEN  (SYSPRINT,OUTPUT)\n         TM    SYSPRINT+DCBOFLGS,X'10'\n         BZ    EXITRC16           IF OPEN FAILED EXIT RC=16     -ARB79-\n         GETMAIN VU,LA=GMCTRL,A=GMLOCS\n         L     R9,GMLOCS          THERE IS AT LEAST THE MINIMUM CORE\n*              ABOVE STMT SETS UP PERMANENT BASE FOR MSECT DSECT\n         LR    R6,R9              START CLEARING GOTTEN MAIN TO        *\n                                  SHORTEN POSSIBLE DUMPS.\n         L     R4,GMLOCS+4        ACTUAL LENGTH OF GOTTEN MAIN\n         LA    R5,256             OFT-USED CONSTANT FOR CLEARING MAIN\nCLOOP    CR    R4,R5              R5 CONTAINS F'256'\n         BNH   LE256              BIF ONLY 256 OR FEWER BYTES LEFT\n         XC    0(256,R6),0(R6)    CLEAR 256 BYTES\n         SR    R4,R5              R5 CONTAINS F'256'\n         AR    R6,R5              R5 CONTAINS F'256'\n         B     CLOOP\nLE256    BCTR  R4,0               SET TO MACHINE LENGTH\n         EX    R4,XCLEAR          CLEAR LAST 1 TO 256 BYTES\nXCLEAR   XC    0(0,R6),0(R6)      EXECUTED IN STMT ABOVE\n         MVI   BLANKBUF,C' '      PREPARE TO CREATE SOME BLANKS\n         MVC   BLANKBUF+1(135),BLANKBUF      CREATE SOME BLANKS\n         MVC   PARMBUF,BLANKBUF   COPY PARM STRING SINCE PARM   -ARB82-\n         BCTR  R8,0               SCAN GOES PAST STRING END     -ARB82-\n         EX    R8,MVPARM                                        -ARB82-\n         LA    R8,1(,R8)                                        -ARB82-\n         LA    R3,PARMBUF                                       -ARB82-\n         LA    R1,MSGBUF+58       FOR ADCON IN DYNAMIC          -ARB79-\n         ST    R1,AMSGBP58        STORAGE.                      -ARB79-\n         LA    R1,MSGBUF+86                                     -ARB79-\n         ST    R1,AMSGBP86                                      -ARB79-\n         LA    R15,RECBUF         POINT THE WRITE\n         O     R15,WRTCMND        CCW TO DYNAMICALLY\n         ST    R15,WRTCMND        ALLOCATED RECORD BUFFER.\n         LA    R15,RECBUF         SET FILE SEARCH CCW TO\n         O     R15,READ81CM       POINT TO\n         ST    R15,READ81CM       RECBUF.\n         LA    R5,TRT1            START SETTING UP THE FIRST\n         LA    R6,16              HEX TRANSLATE\n         LA    R7,CTABLE          TABLE.\nSETUPTR1 MVC   0(1,5),0(7)        MOVE SEED CHAR INTO TRT1\n         MVC   1(15,5),0(5)       AND PROPAGATE IT\n         LA    5,16(5)\n         LA    7,1(7)\n         BCT   6,SETUPTR1\n         MVC   TRT2(16),CTABLE    MOVE 16 CHAR SEED INTO TRT2\n         MVC   TRT2+16(240),TRT2  AND PROPAGATE IT 15 TIMES\n         TIME  DEC                GET DATE IN R1 IN FORM 00YYJJJF\n         ST    R0,BADLNGTH        SAVE TIME WHILE YOU'RE AT IT\n         ED    TIMERSLT,BADLNGTH  EDIT INTO PAGE HEADER LINE BUFFER\n         ST    R1,BADLNGTH+4      CONVERT JULIAN DATE           -ARB79-\n         UNPK  TODAY(5),BADLNGTH+5(3)   TO ZONED                -ARB79-\n         MVC   DATERSLT+2(6),=C'000000'                         -ARB79-\n         MVC   WORK(8),=A(TODAY,DATERSLT+2)   JULIAN PARMS      -ARB79-\n         MVI   WORK+4,X'80'       SET END OF LIST BIT           -ARB82-\n         LA    R1,WORK                                          -ARB79-\n         L     R15,=V(JULIAN)     CALL ICSA JULIAN DATE ROUTINE -ARB79-\n         BALR  R14,R15            CONVERT TO GREGORIAN          -ARB79-\n         MVC   DATERSLT(2),DATERSLT+2  INSERT SLASHES           -ARB79-\n         MVC   DATERSLT+3(2),DATERSLT+4 TO IMPROVE THE FORMAT   -ARB79-\n         MVI   DATERSLT+2,C'/'                                  -ARB79-\n         MVI   DATERSLT+5,C'/'                                  -ARB79-\n         DEVTYPE INPUT+40,DTYPE   CHECK TO SEE IF TAPE DEVICE     -HMD-\n         LTR   R15,R15            DID WE FIND DD STATEMENT?       -HMD-\n         BNZ   NOINPUT            NOPE                            -HMD-\n         CLI   DTYPE+2,X'80'      IS THIS A TAPE DEVICE?          -HMD-\n         BNE   NOTTAPEI           NOPE                            -HMD-\n         RDJFCB (INPUT)           READ INPUT TAPE'S JFCB\n         CLI   JFCBIN,X'00'       CHECK IF 1ST BYTE OF JFCB MODIFIED\n         BE    NOINPUT            RDJFCB DIDN'T WORK IF JFCBIN STILL =0\n         MVC   DDVOL,JFCBIN+JFCBVOLS  PUT VOL INTO PAGE HEAD.     -CWB-\n         MVC   JFCLTSV,JFCBIN+JFCBLTYP SAVE INPUT TAPE'S LABEL TYPE\n         NI    JFCLTSV,X'F7'      TURN OFF USER LABEL BIT       -ARB79-\n         LH    R2,JFCBIN+JFCBFLSQ GET FILE SEQUENCE NUMBER      -ARB79-\n         STH   R2,INFLPOS         SAVE FOR VTOC                 -ARB82-\n         LTR   R2,R2              UNSPECIFIED?                  -ARB79-\n         BZ    *+6                YES, DON'T DECREMENT          -ARB79-\n         BCTR  R2,0                                             -ARB79-\n         NI    JFCOPTCD+JFCBIN,X'F7'   CANCEL OPTCD=Q           -ARB79-\n         TM    JFCLTSV,X'42'      ARE THERE LABELS?             -ARB79-\n         BZ    NLIN                                             -ARB79-\n         MH    R2,=H'3'           CONVERT TO BLP FILE NO        -ARB79-\nNLIN     LTR   R2,R2              STARTING AT THE BEGINNING?    -ARB82-\n         BZ    LABEL1             YES.                          -ARB82-\n         MVI   POSFLG,C'Y'        NO, SET POSITIONING FLAG      -ARB79-\nLABEL1   ST    R2,SKIPFLNO        STORE AS SKIPTM VALUE         -ARB82-\n         MVI   JFCBIN+JFCBLTYP,X'10'  SET TO BLP                -ARB79-\n         MVC   JFCBIN+JFCBFLSQ(2),=H'1' SET FILE SEQ. NO. TO = 1\n         OPEN  (INPUT),TYPE=J\n         TM    INPUT+DCBOFLGS,X'10'\n         BZ    NOINPUT            TERMINAL ERROR\n         MVC   ITRTCH(1),DCBTRTCH+INPUT     SAVE INPUT TRTCH    -ARB79-\n         CLI   ITRTCH,0           TRTCH= (NULL)?                -ARB82-\n         BNE   *+8                NO.                           -ARB82-\n         MVI   ITRTCH,X'33'       YES, CHANGE FOR SFM LATER     -ARB82-\n         L     R1,GMCTRL+4        LOAD MAXIMUM REQUESTED GETMAIN LENGTH\n         S     R1,GMLOCS+4        SUBTRACT LENGTH ACTUALLY GOTTEN\n         BZ    SRCHPRM            BIF GOT ALL CORE REQUESTED\n         CVD   R1,BADLNGTH        CONVERT DIFERENCE TO PACKED DECIMAL\n         UNPK  MORECORE+33(5),BADLNGTH\n         OI    MORECORE+37,C'0'\n         LH    R2,INPUT+DCBBLKSI  TO PREVENT DATA 'OVERRUNS'\n         SR    R2,R1              SUBTRACT DIFFERENCE OF MORE CORE\n         STH   R2,INPUT+DCBBLKSI  AND PUT BACK IN DCB\n         BAL   R2,PUTLINE\n         MVC   MSGBUF(L'MORECORE),MORECORE\n         EJECT\nSRCHPRM  LTR   R8,R8              LOAD AND TEST REMAINING PARM LENGTH\n         BNH   ENDPARMS\n         SR    R5,R5              ZERO CURRENT PARM LENGTH COUNTER\n         LR    R4,R3              SAVE PTR TO START OF PARM\n         MVC   THISPARM,BLANKBUF  BLANK OUT PARM COPY AREA      -ARB82-\n         LA    R6,THISPARM                                      -ARB82-\nSRCHCOMA CLI   0(R3),C','\n         MVC   0(1,R6),0(R3)      SAVE PARM FOR DIAGNOSTIC      -ARB82-\n         LA    R6,1(,R6)                                        -ARB82-\n         LA    R3,1(R3)           BUMP PTR TO NEXT CHAR\n         BE    GOTCOMMA\n         LA    5,1(5)             COUNTS LENGTH OF CURRENT PARM\n         BCT   R8,SRCHCOMA\nGOTCOMMA CLC   0(6,R4),=C'NOLIST' GET HERE IF COMMA OR END OF PARM LIST\n         BE    NOLIST\n         CLC   0(5,4),=C'LIST='                                 -ARB79-\n         BE    LIST\n         CLC   0(7,4),=C'STOPTM=' INITIALLY 32767               -ARB79-\n         BE    STOPTM                                           -ARB79-\n         CLC   0(7,4),=C'SKIPTM='                               -ARB79-\n         BE    SKIPTM\n         CLC   0(3,4),=C'HEX'                                   -ARB79-\n         BE    HEX                                              -ARB79-\n         CLC   0(8,4),=C'STOPEOV='                              -ARB79-\n         BE    STOPEOV                                          -ARB79-\n         CLC   0(8,4),=C'SKIPEOV='                              -ARB79-\n         BE    SKIPEOV\n         CLC   0(5,4),=C'NOSUM'                                 -ARB79-\n         BE    NOSUMARY\n         CLC   0(7,4),=C'FULLSUM'                               -ARB79-\n         BE    FULLSUM                                          -ARB79-\n         CLC   0(5,4),=C'COUNT'\n         BE    COUNT\n         CLC   0(7,4),=C'NOCOUNT'\n         BE    NOCOUNT\n         CLC   0(7,4),=C'ERRLIM='                               -ARB79-\n         BE    ERRLIM\n         CLC   0(4,4),=C'COPY'\n         BE    COPY               TAPE COPYING OPTION\n         CLC   0(6,4),=C'EOVMOD'  MOD OPTION IMPLIES COPY & COUNT OPTNS\n         BE    EOVMOD\n         CLC   0(7,4),=C'UNLABEL'                               -ARB79-\n         BE    UNLABEL                                          -ARB79-\n         CLC   0(8,4),=C'ASCII=IN'                              -ARB79-\n         BE    TRANSIN                                          -ARB79-\n         CLC   0(9,4),=C'ASCII=OUT'                             -ARB79-\n         BE    TRANSOUT                                         -ARB79-\n         CLC   0(4,4),=C'OPT='                                  -ARB79-\n         BE    OPT                MISCELLANEOUS OPTIONS\n         CLC   0(5,4),=C'LINE='   LINE COUNT OPTION             -ARB82-\n         BE    LINE                                        *HMD 04/79*\n         CLC   0(7,R4),=C'MAPONLY'                              -ARB82-\n         BE    MAPONLY                                          -ARB82-\n         CLC   0(3,R4),=C'MAPONLY'     MAP IS ALIAS OF MAPONLY  -ARB82-\n         BE    MAPABBR                                          -ARB82-\nPRLENERR EQU   *                                                -ARB82-\nUNRECOG  BAL   R2,PUTLINE\n         MVC   MSGBUF(33),=C'0ERROR - UNRECOGNIZABLE PARAMETER'\nDIAGPARM BAL   2,PUTLINE                                        -ARB82-\n         MVC   MSGBUF(L'PARMIGN+100),PARMIGN                    -ARB82-*\n                                  REPEAT IGNORED PARM           -ARB82-\nSRCHPARM BCTR  R8,0\n         B     SRCHPRM\nGETNUM   DS    0H                 CHAR STRNG INTGR TO BIN INTGR CONV SB\n         SR    6,6                CLEAR ACCUMULATOR\n         CLI   0(4),C'9'          * R4=PTR TO 1ST CHAR OF NUM         *\n         BH    NUMERR             * R5=ACTUAL LENGTH OF NUM           *\n         CLI   0(4),C'0'          * RESULT RETURNED IN R6             *\n         BL    NUMERR             * R2,R4,R5,R6, AND R7 MODIFIED BY   *\n         MH    R6,=H'10'          * USING GETNUM SUBROUTINE.          *\n         IC    R7,0(4)            PICK UP DECIMAL CHARACTER\n         SLL   7,28               CHOP OFF LEFT 4 BITS\n         SRL   7,28               AND SHIFT BACK\n         AR    6,7                ADD DIGIT INTO RESULT\n         LA    4,1(4)             BUMP PTR TO NEXT CHAR\n         BCT   5,GETNUM+2         GO TO TOP OF LOOP\n         BR    2                  RETURN FROM GETNUM SUBROUTINE\nNUMERR   BAL   R2,PUTLINE         ERROR DESCRIPTOR SUBROUTINE\n         MVC   MSGBUF(40),=C'0ERROR - INVALID NUMERIC PARAMETER VALUE' *\n                                  INVALID COMPONENT INDEED      -ARB82-\n         B     PRLENERR\nNOCOUNT  CH    R5,=H'7'\n         BNE   PRLENERR           *** WARNING *** MODIFIED IN COPY/MOD *\n                                                  OPTION ROUTINES.\n         MVI   COUNTFLG,C'N'\n         B     SRCHPARM\nCOUNT    CH    R5,=H'5'           FINAL PROCESSING OF COUNT OPTION\n         BNE   UNRECOG\n         MVI   COUNTFLG,C'Y'\n         B     SRCHPARM\nUNLABEL  CH    R5,=H'7'                                         -ARB79-\n         BNE   UNRECOG\n         MVI   SVOUTFLG,C'N'      SET 'COPY VOLSER' FLAG        -ARB79-\n         OI    COPYFLG,X'04'      OR IN 'UNLABEL' BIT           -ARB82-\n         B     SRCHPARM\nCOPY     CH    R5,=H'4'\n         BNE   UNRECOG\n         OI    COPYFLG,X'01'      INDICATE COPY OPTION SPECIFIED\n         OI    WRTFLG,X'01'       INDICATE COPY   REQUESTED (THAT BIT)\n         OI    NOCOUNT+5,X'F0'    NOP OUT NOCOUNT & SET FOR WARN MSG\n         B     COUNT+8            COPY OPTION INVOKES COUNT AUTOMATICLY\nEOVMOD   CH    R5,=H'6'           ADD DATASETS ONTO EOV\n         BNE   UNRECOG\n         OI    COPYFLG,X'03'      BITS = 'COPY OPT + MOD OPT REQUESTED'\n         B     COPY+8             MOD OPTION IMPLIES COPY OPTION\nOPT      CH    R5,=H'4'                                         -ARB79-\n         BNH   PRLENERR\n         LA    R4,4(R4)                                         -ARB79-\n         SH    R5,=H'4'                                         -ARB79-\n         BAL   R2,GETNUM\n         O     R6,OPTNO           OR PREVIOUS OPTIONS INTO NEW OPTIONS\n         ST    R6,OPTNO\n         B     SRCHPARM\nERRLIM   CH    R5,=H'7'           CHANGE ERROR COUNT LIMIT      -ARB79-\n         BNH   PRLENERR\n         LA    R4,7(R4)                                         -ARB79-\n         SH    R5,=H'7'                                         -ARB79-\n         BAL   R2,GETNUM\n         ST    R6,SYNADNO\n         B     SRCHPARM\nNOLIST   CH    R5,=H'6'           FINAL PROCESSING OF NOLIST PARM\n         BNE   UNRECOG\n         SR    R0,R0\n         ST    R0,LISTNO\n         B     SRCHPARM\nLIST     CH    R5,=H'5'                                         -ARB79-\n         BNH   PRLENERR\n         LA    R4,5(R4)                                         -ARB79-\n         SH    R5,=H'5'           GET LENGTH OF PRESUMED NUMBER -ARB79-\n         BAL   R2,GETNUM          GET PRESUMED NUMBER INTO BINARY FORM\n         ST    R6,LISTNO          STORE NONNEGATIVE BINARY INTEGER\n         B     SRCHPARM\nHEX      CH    R5,=H'3'                                         -ARB79-\n         BNE   UNRECOG\n         MVI   HEXFLG,C'Y'                                      -ARB79-\n         B     SRCHPARM\nMAPONLY  CH    R5,=H'7'                                         -ARB82-\n         BNE   UNRECOG                                          -ARB82-\nSETMAP   MVI   MAPFLG,C'Y'        SHOW MAP SELECTED             -ARB82-\n         B     SRCHPARM                                         -ARB82-\nMAPABBR  CH    R5,=H'3'                                         -ARB82-\n         BNE   UNRECOG                                          -ARB82-\n         B     SETMAP                                           -ARB82-\nTRANSIN  CH    R5,=H'8'                                         -ARB79-\n         BNE   UNRECOG                                          -ARB79-\n         MVI   ASCIIN,C'Y'        SET ASCII INPUT FLAG          -ARB79-\n         B     SRCHPARM                                         -ARB79-\nTRANSOUT CH    R5,=H'9'                                         -ARB79-\n         BNE   UNRECOG                                          -ARB79-\n         MVI   ASCIOUT,C'Y'       SET ASCII OUTPUT FLAG         -ARB79-\n         B     SRCHPARM                                         -ARB79-\nNOSUMARY CH    R5,=H'5'                                         -ARB79-\n         BNE   UNRECOG\n         MVI   SUMFLG,C'N'        SET SUMMARY FLAG TO 'NOSUMMARY'\n         B     SRCHPARM\nFULLSUM  CH    R5,=H'7'                                         -ARB79-\n         BNE   UNRECOG                                          -ARB79-\n         MVI   SUMFLG,C'F'        SET SUMMARY FLAG TO FULL      -ARB79-\n         B     SRCHPARM                                         -ARB79-\nSKIPTM   CH    R5,=H'7'                                         -ARB79-\n         BNH   PRLENERR\n         LA    R4,7(R4)                                         -ARB79-\n         SH    R5,=H'7'                                         -ARB79-\n         BAL   R2,GETNUM\n         ST    R6,SKIPTMNO\n         ST    R6,SKIPTMVL                                      -ARB82-\n         LTR   R6,R6              SKIPTM=0?                     -ARB79-\n         BZ    SRCHPARM           YES.                          -ARB79-\n         MVI   POSFLG,C'Y'        NO, SET POSITIONING NEEDED    -ARB79-\n         B     SRCHPARM\nLINE     CH    R5,=H'5'            IS THIS PARM 'LINE'?         -ARB82-\n         BNH   PRLENERR            NOPE, LENGTH ERROR      *HMD 04/79*\n         LA    R4,5(R4)            BUMP POINTER                 -ARB82-\n         SH    R5,=H'5'            DECREMENT COUNTER            -ARB82-\n         BAL   R2,GETNUM           GET NUMERIC VALUE       *HMD 04/79*\n         CH    R6,=H'30'           TOO LOW?                *HMD 04/79*\n         BL    NUMERR              YES, FORGET IT          *HMD 04/79*\n         CH    R6,=H'99'           TOO HIGH?               *HMD 04/79*\n         BH    NUMERR              YES, FORGET IT          *HMD 04/79*\n         ST    R6,LINECNT          SAVE LINE COUNT PARM    *HMD 04/79*\n         B     SRCHPARM            GET SOME MORE PARMS     *HMD 04/79*\nSTOPTM   CH    R5,=H'7'                                         -ARB79-\n         BNH   PRLENERR\n         LA    R4,7(4)                                          -ARB79-\n         SH    R5,=H'7'                                         -ARB79-\n         BAL   R2,GETNUM\n         LTR   R6,R6              MAKE SURE MAXTM IS NOT =0\n         BZ    NUMERR             ERROR - INVALID NUMERICAL PARM\n         ST    R6,MAXTMNO\n         ST    R6,STOPTMNO        STORE FOR TERMINATION         -ARB82-\n         B     SRCHPARM\nSKIPEOV  CH    R5,=H'8'                                         -ARB79-\n         BNH   PRLENERR\n         LA    R4,8(R4)                                         -ARB79-\n         SH    R5,=H'8'                                         -ARB79-\n         BAL   R2,GETNUM\n         ST    R6,SKPEOVNO\n         LTR   R6,R6              SKIPEOV=0?                    -ARB79-\n         BZ    SRCHPARM           YES.                          -ARB79-\n         MVI   POSFLG,C'Y'        NO, INDICATE POSITIONING      -ARB79-\n         B     SRCHPARM\nSTOPEOV  CH    R5,=H'8'           CHECK LENGTH OF PARM          -ARB79-\n         BNH   PRLENERR           LENGTH MUST BE GREATER THAN 7\n         LA    R4,8(R4)           BUMP PTR TO START OF NUMBER   -ARB79-\n         SH    R5,=H'8'           GET LENGTH OF PRESUMED NUMBER -ARB79-\n         BAL   R2,GETNUM          CONVERT NUMBER FOLLOWING 'MAXEOV' PRM\n         LTR   R6,R6              MAKE SURE MAXEOV IS NOT=0\n         BZ    NUMERR             INVALID NUMERICAL COMPONENT\n         ST    R6,MAXEOVNO        STORE RESULT\n         ST    R6,STPEOVNO        STORE FOR END OF VTOC         -ARB82-\n         B     SRCHPARM\nENDPARMS DS    0H\n         TM    COPYFLG,X'01'      COPYING?                      -ARB82-\n         BZ    COPYSUM            NO.                           -ARB82-\n         CLI   SUMFLG,C'N'        YES, NOSUM ALSO               -ARB82-\n         BNE   COPYSUM            NO.                           -ARB82-\n         MVI   SUMFLG,C'Y'        YES, FORCE SUMMARY INSTEAD    -ARB82-\nCOPYSUM  CLI   MAPFLG,C'Y'        MAPONLY SELECTED?             -ARB82-\n         BNE   NOMAPO             NO.                           -ARB82-\n         ICM   R1,15,LISTNO       LIST=N SPECIFIED?             -ARB82-\n         BP    NOMAPO             YES, IGNORE MAPONLY           -ARB82-\n         CLI   SUMFLG,C'Y'        NOSUM OR FULLSUM SELECTED?    -ARB82-\n         BNE   NOMAPO             YES, IGNORE MAPONLY           -ARB82-\n         MVC   LISTNO,=F'0'       NO, FORCE NOLIST              -ARB82-\n         B     POSIT              GO DO POSITIONING             -ARB82-\nNOMAPO   MVI   MAPFLG,C'N'        MAKE SURE MAPONLY IS OFF      -ARB82-\n         CLI   COUNTFLG,C' '      COUNT STILL UNSET?            -ARB82-\n         BNE   DEFLIST            NO.                           -ARB82-\n         MVI   COUNTFLG,C'Y'      YES, DEFAULT TO YES           -ARB82-\nDEFLIST  CLC   LISTNO,=F'-1'      LIST STILL UNSET?             -ARB82-\n         BNE   POSIT              NO.                           -ARB82-\n         MVC   LISTNO,=F'4'       YES, DEFAULT TO LIST=4        -ARB82-\n         EJECT\nPOSIT    BALR  R12,0              SET UP BASE REG AGAIN         -ARB82-\n         USING *,R12              (ADDRESS THE WORLD)           -ARB82-\n         LA    R1,=AL3(SENSCMND)  SET UP PTR FOR EXECEXCP CALL  -ARB82-\n         LA    R2,INPUT           PTR TO DCB  FOR EXCP CALL\n         BAL   R4,EXECEXCP        CALL EXCP SUBROUTINE\n         MVC   ITRACKS,SENSBYTS+1 SAVE SENSE FOR 7/9 TEST       -ARB79-\n         MVC   CTRACKS,ITRACKS                                  -ARB79-\n         TM    SENSBYTS+1,X'08'   SEE IF LOAD POINT SENSED\n         BO    SENSTYP            BIF LOAD POINT SENSED         -ARB82-\n         TM    OPTNO+3,X'08'      SEE IF 'DO NOT ATTEMPT REWIND' SPEC'D\n         BO    COPYMOD            SKIP REWIND ATTEMPT IF SO SPECIFIED\n         LA    R1,=AL3(RWNDCMND)  REWIND AND RE-SENSE COMMAND CHAIN\n         LA    R2,INPUT           PTR TO DCB  FOR EXCP CALL\n         BAL   R4,EXECEXCP\n         TM    SENSBYTS+1,X'08'   SEE IF NOW AT LOAD POINT\n         BO    SENSTYP            BIF AT LOAD POINT             -ARB82-\nLDPTERR  BAL   R2,PUTLINE         PRINT ERROR MESSAGE             -HMD-\n         MVC   MSGBUF(66),=C'0UNABLE TO REWIND INPUT TAPE TO LOAD POINT*\n                - TERMINATING EXECUTION'\n         B     EXITRC16                                         -ARB79-\nSENSTYP  TM    SENSBYTS+1,X'10'   SEE IF 7-TRK                  -ARB82-\n         BO    DEN7TRK            BIF 7-TRK(DEN NOT APPLICABLE) -ARB82-\n         MVC   DENMSG+10(8),=C'PHYSICAL' CHANGE MSG FOR 9TRACK  -ARB82-\n         LA    R1,HDEOD           FAKE EOD ADDRESS                -HMD-\n         ST    R1,DCBEODAD+INPUT  SAVE EOD ADDRESS IN DCB       -ARB82-\n         LA    R1,SYNCONTU        IGNORE READ ERRORS            -ARB82-\n         ST    R1,DCBSYNAD+INPUT                                -ARB82-\n         LA    R2,RECBUF                                        -ARB82-\n         READ  SENSER,SF,INPUT,(R2),'S' READ TO GET SENSE INFO  -ARB82-\n         CHECK SENSER               WAIT FOR I/O                -ARB82-\nHDEOD    LA    R1,=AL3(SENSCMND)  NOW GET THE SENSE BYTES         -HMD-\n         LA    R2,INPUT           POINT TO INPUT DCB              -HMD-\n         XC    SENSBYTS(24),SENSBYTS                              -HMD-\n         BAL   R4,EXECEXCP        ISSUE EXCP                      -HMD-\nRESTREOD L     R1,=A(EODS)        NORMAL EOD ADDRESS            -ARB82-\n         ST    R1,INPUT+DCBEODAD  PUT IT BACK AS IT WAS         -ARB82-\n         LA    R1,SYNERR          RESTORE USUAL SYNAD           -ARB82-\n         ST    R1,INPUT+DCBSYNAD                                -ARB82-\n         TM    SENSBYTS+3,X'04'   BIT=1=PE MODE=1600 BPI=DEN=3  -ARB82-\n         BO    DEN1600       SKIP IF DENSITY SENSED=1600 BPI    -ARB82-\n         TM    SENSBYTS+5,X'C0'   SEE IF 3400 TYPE              -ARB82-\n         BZ    HDEND                                            -ARB82-\n         TM    SENSBYTS+6,X'08'   6250 FEATURE?                 -ARB82-\n         BZ    HDEND              NO, SKIP 6250 MOVE            -ARB82-\n         MVC   DENMSG+1(4),=C'6250'                             -ARB82-\n         B     HDEND              REWIND TAPE TO LOAD POINT     -ARB82-\nDEN1600  MVC   DENMSG+1(4),=CL4'1600' REPLACE  800 WITH 1600    -ARB82-\nHDEND    DS    0H                 ENOUGH OF ALL THIS NONSENSE     -HMD-\n         LA    R1,=AL3(RWNDCMND)  REWIND TO LOAD POINT            -HMD-\n         LA    R2,INPUT           GET INPUT ADDRESS               -HMD-\n         BAL   R4,EXECEXCP        GO DO IT                        -HMD-\n         TM    SENSBYTS+1,X'08'   ARE WE AT LOAD POINT NOW?       -HMD-\n         BZ    LDPTERR            NO, INDICATE LOAD ERROR         -HMD-\nDENOUT   BAL   R2,PUTLINE                                       -ARB82-\n         MVC   MSGBUF(40),DENMSG                                -ARB82-\n         B     COPYMOD                                          -ARB82-\nDEN7TRK  CLI   DCBDEN+INPUT,X'43' GET DENSITY FROM 7TRK DCB     -ARB82-\n         BL    DEN200                                           -ARB82-\n         BH    DENOUT                                           -ARB82-\nTRY556   DS    0H ANYONE STILL USING THESE TURKEYS? DO YOUR OWN THING\n* I AM, AND WHOSE CALLING THEM TURKEYS, SUCKER                   -HMD-\n         MVC   DENMSG+1(4),=C' 556'                             -ARB82-\n         B     DENOUT             GO WRITE DENSITY ASSUMED MSG  -ARB82-\nDEN200   MVC   DENMSG+1(4),=C' 200'                             -ARB82-\n         B     DENOUT             WRITE DENSITY ASSUMED MSG     -ARB82-\nCOPYMOD  DS    0H\n         TM    COPYFLG,X'01'      SEE IF COPY AND/OR EOVMOD SPECIFIED\n         BZ    NOTBOTH            BIF COPY OPTION NOT SPECIFIED\n         DEVTYPE OUTPUT+40,DTYPE  CHECK FOR MAG TAPE DEVICE       -HMD-\n         LTR   R15,R15            IS DD STMT THERE?               -HMD-\n         BNZ   NOOUTPUT           NOPE                            -HMD-\n         CLI   DTYPE+2,X'80'      IS THIS A TAPE DEVICE?          -HMD-\n         BNE   NOTTAPEO           NOPE                            -HMD-\n         RDJFCB (OUTPUT)          ELSE PROCESS COPY AND/OR EOVMOD OPTNS\n         CLI   JFCBOUT,X'00'      SEE IF JFCBOUT STILL = ZERO\n         BE    NOOUTPUT           ERROR IF RDJFCB LEFT JFCBOUT STILL =0\n         MVC   OUTLTYP,JFCBOUT+JFCBLTYP SAVE LABEL TYPE FOR OUTPUT TAPE\n         NI    OUTLTYP,X'F7'      OFF USER LABEL BIT            -ARB79-\n         TM    OUTLTYP,X'01'      SEE IF LABEL IS NL OR LTM\n         BO    *+8                BIF YES - IT IS NL OR LTM\n         MVI   JFCBOUT+JFCBLTYP,X'10' ELSE SET TO BLP\n         NI    JFCBOUT+JFCOPTCD,X'F7'  MAKE SURE OPTCD NOT Q    -ARB79-\n         TM    OUTLTYP,X'02'      SL OUTPUT?                    -ARB79-\n         BZ    NOUTSL                                           -ARB79-\n         MVC   OTRTCH,JFCTRTCH+JFCBOUT SAVE TRTCH FROM JFCB     -ARB79-\n         CLI   OTRTCH,0           TRTCH= (NULL)?                -ARB82-\n         BNE   *+8                NO.                           -ARB82-\n         MVI   OTRTCH,X'33'       YES, CHANGE FOR SFM LATER     -ARB82-\n         MVI   JFCTRTCH+JFCBOUT,X'2B'  SET TRTCH=ET FOR LABEL   -ARB79-\nNOUTSL   LA    R0,1                                             -ARB79-\n         LH    R2,JOUTFLSQ        SAVE ORIGINAL FILE SEQ. NO. IN R2\n         LTR   R2,R2              BUT IF IT'S\n         BNZ   NZOUT              EQUAL TO ZERO THEN            -ARB80-\n         LR    R2,R0              SET IT TO = 1.\n         MVI   OUTZERO,X'FF'      NOTE OUT FILE = 0             -ARB80-\nNZOUT    STH   R0,JOUTFLSQ        TEMPORARILY SET FLSQ = 1      -ARB80-\n         OPEN  (OUTPUT,(INOUT)),TYPE=J                          -ARB79-\n         TM    OUTPUT+DCBOFLGS,X'10' CHECK IF OPENED SUCCESSFULLY\n         BZ    NOOUTPUT\n         MVC   SECVOL,JFCBOUT+JFCBVOLS COPY VOLSER FOR EXIT     -ARB82-\n         MVC   SECDCB,=A(OUTPUT)  STORE DCB ADDR FOR EXIT       -ARB82-\n         STH   R2,JOUTFLSQ        RESTORE ORIGINAL FLSQ IN JFCB\n         TM    OUTLTYP,X'42'      SEE IF AL, AUL, SL, OR SUL\n         BZ    CHKOPOS            BIF NOT ONE OF ABOVE          -ARB82-\n         MH    R2,=H'3'           CONVERT FILE NO TO TM NO      -ARB79-\n         SH    R2,=H'2'                                         -ARB79-\n         STH   R2,JOUTFLSQ                                      -ARB79-\nCHKOPOS  CLC   JOUTFLSQ,=H'1'     OUTPUT FILE=1?                -ARB82-\n         BH    SKIPVOL1           NO, DON'T COPY VOL1           -ARB82-\n         TM    COPYFLG,X'02'      YES, WRITING TO END?          -ARB82-\n         BZ    LABELCK            NO, LEAVE UNLABEL AS SET      -ARB82-\nSKIPVOL1 NI    COPYFLG,X'FB'      MAKE SURE VOL1 NOT COPIED     -ARB82-\nLABELCK  MVC   RECBUF(136),BLANKBUF BLANK PART OF RECBUF FAST\n         MVI   ERRLAST,0          TURN OFF PREVIOUS ERR FLAG    -ARB79-\n         LA    R2,RECBUF          PREPARE TO READ PRESUMED VOL LABEL\n         READ  TAPEIO,SF,OUTPUT,(R2),'S' READ PRESUMED VOL LABEL\n         CHECK TAPEIO             SYNAD=SYNERR,EODAD=EOLABEL\n         L     R6,TAPEIO+16       START TO COMPUTE LENGTH OF BLK READ\n         LH    R7,OUTPUT+DCBBLKSI\n         SH    R7,14(R6)          COMPUTE BLOCK LENGTH\n         BAL   R2,LENCK           CHECK FOR NEGATIVE LENGTH     -ARB79-\n         TM    OUTLTYP,X'40'      SEE IF SL OR SUL, OR AL OR AUL\n         BZ    COPYSL             BIF S(U)L                     -ARB79-\n         MVI   SECLABEL,C'A'      SET AL FOR SECURITY           -ARB82-\n         CLC   RECBUF(4),ASCIVOL1 SEE IF ANSI  'VOL1'           -ARB79-\n         BNE   BADOUTVL           AL OR AUL IN JCL, BUT LABEL NOT ANSI\n         MVI   ASCIOUT,C'Y'       NOTE OUTPUT ASCII             -ARB79-\n         C     R7,=F'80'\n         BL    BADOUTVL\n         XLATE RECBUF,80,TO=E     GET LABEL INTO EBCDIC         -ARB79-\n         CLI   RECBUF+10,C' '     ASCII VOLUME ACCESIBLE?       -ARB79-\n         BE    CKVOLSER           YES.                          -ARB79-\n         BAL   R2,PUTLINE         NO, STOP HERE                 -ARB79-\n         MVC   MSGBUF(L'ASCURITY),ASCURITY                      -ARB79-\n         B     EXITRC16                                         -ARB79-\nCOPYSL   TM    OUTLTYP,X'02'      SEE IF NO SL OR AL            -ARB79-\n         BZ    COPYNL             MAKE SURE TAPE NOT LABELLED   -ARB79-\n         MVI   SECLABEL,C'S'      TELL EXIT TAPE IS SL          -ARB82-\n         C     R7,=F'80'          SEE IF PRESUMED IBM SL IS 80 BYTES\n         BNE   BADOUTVL           BIF PRESUMED IBM LABEL NOT 80 BYTES\n         MVI   ASCIOUT,C'N'       MAKE SURE ASCII\u00ac=OUT          -ARB79-\n         CLC   RECBUF(4),=C'VOL1'\n         BNE   BADOUTVL\nCKVOLSER CLC   JFCBOUT+JFCBVOLS(6),RECBUF+4 COMPARE VOL SERS    -ARB82-\n         BNE   INCOROUT           ERROR IF NO MATCH             -ARB82-\n         MVI   ERRLAST,0          FORGET PREVIOUS ERROR         -ARB79-\n         MVC   DCBEODAD+OUTPUT(4),=A(MISNGHDR) DON'T BE UPSET BY EOF   *\n                                                                -ARB79-\nFINDHDR1 LA    R2,RECBUF                                        -ARB82-\n         READ  TAPEIO2,SF,OUTPUT,(R2),'S' TRY TO READ HDR       -ARB79-\n         CHECK TAPEIO2                                          -ARB79-\n         OI    COPYFLG,X'80'      INDICATE MAY NEED TO BSP      -ARB79-\n         L     R6,TAPEIO2+16      DETERMINE SIZE RECORD READ    -ARB79-\n         LH    R7,OUTPUT+DCBBLKSI                               -ARB79-\n         SH    R7,14(,R6)                                       -ARB79-\n         BAL   R2,LENCK           CHECK FOR NEGATIVE LENGTH     -ARB79-\n         C     R7,=F'80'          LABEL SIZED RECORD?           -ARB79-\n         BL    SCUROUT            NO, NO HEADER LABEL           -ARB82-\n         TM    OUTLTYP,X'02'      SL OR AL TAPE?                -ARB79-\n         BZ    AHDR1              BRANCH IF AL                  -ARB79-\n         C     R7,=F'80'          EXACTLY 80 CHARS?             -ARB79-\n         BNE   SCUROUT            NO, NOT A LABEL               -ARB82-\n         B     OUTSEQ                                           -ARB79-\nAHDR1    XLATE RECBUF,(R7),TO=E   TRANSLATE TO EBCDIC           -ARB79-\nOUTSEQ   CLC   RECBUF(4),=C'HDR1' IS IT REALLY A HDR LABEL?     -ARB79-\n         BE    OUTHDR             YES.                          -ARB82-\n         TM    OUTLTYP,X'02'      AL OUTPUT?                    -ARB82-\n         BNZ   SCUROUT            NO.                           -ARB82-\n         CLC   RECBUF(3),=C'UVL'  YES, USER VOLUME LABEL NEXT?  -ARB82-\n         BE    FINDHDR1           YES, SKIP TO NEXT LABEL       -ARB82-\nOUTHDR   CLI   RECBUF+53,C'1'     PROTECTED DATA SET?           -ARB82-\n         BE    RQROUTPW           YES, ASK FOR PASSWORD         -ARB79-\n         CLI   RECBUF+53,C'3'                                   -ARB79-\n         BE    RQROUTPW                                         -ARB79-\n         CLI   ASCIOUT,C'Y'       OUTPUT TAPE ASCII?            -ARB79-\n         BNE   NOUTPW             NO, UNPROTECTED               -ARB79-\n         CLI   RECBUF+53,C' '     YES, IS IT UNPROTECTED?       -ARB79-\n         BE    NOUTPW                                           -ARB79-\n         BAL   R2,PUTLINE         NO, DATASET CANNOT BE USED    -ARB79-\n         MVC   MSGBUF(71),=C'0PROTECTED ASCII TAPE FILE MAY NOT BE OVER*\n               WRITTEN - TAPESCAN TERMINATED'                   -ARB79-\n         B     EXITRC16                                         -ARB79-\nRQROUTPW L     R5,16              BUILD PASSWORD MESSAGE        -ARB79-\n         L     R5,0(,R5)                                        -ARB79-\n         L     R5,4(,R5)                                        -ARB79-\n         L     R5,TCBTIO(,R5)     FIND TIOT FOR JOB & STEP NAME -ARB79-\n         MVC   SMSGJOB,TIOCNJOB(R5)                             -ARB79-\n         MVC   SMSGSTEP,TIOCSTEP(R5)                            -ARB79-\n         MVC   SMSGDD,=CL8'OUTPUT'     INSERT DDNAME            -ARB79-\n         MVI   PSWDSW,0           INDICATE FIRST PASSWORD TRY   -ARB79-\nASKOUTPW LA    R2,SMSG            IEC301 MSG ADDR               -ARB79-\n         BAL   R5,SYSWTOR         ASK FOR PASSWORD              -ARB79-\n         OC    PSWDREPL,BLANKBUF  UPPER CASE REPLY              -ARB79-\n         LA    R2,JFCBOUT         POINT TO SUPPLIED DSN         -ARB79-\n         BAL   R5,CHKPASS         SEE IF PASSWORD FOUND         -ARB79-\n         LTR   R15,R15            WAS PASSWORD FOUND?           -ARB79-\n         BZ    GOTOUTPW                                         -ARB79-\nWROUTPW  CLI   PSWDSW,0           WAS THIS THE SECOND TRY?      -ARB79-\n         BNE   BADOUTPW           YES, LAST CHANCE FAILED       -ARB79-\n         MVI   PSWDSW,X'FF'       NO, SET SECOND TRY FLAG       -ARB79-\n         B     ASKOUTPW           AND TRY AGAIN                 -ARB79-\nBADOUTPW BAL   R2,PUTLINE         EXPLAIN TERMINATION           -ARB79-\n         MVC   MSGBUF(62),=C'0OUTPUT PASSWORD NOT CORRECTLY SPECIFIED -*\n                TAPESCAN TERMINATED'                            -ARB79-\n         B     EXITRC16                                         -ARB79-\nGOTOUTPW TM    PSWDBUF+2,X'01'    IS THIS A WRITE PASSWORD?     -ARB79-\n         BZ    WROUTPW            NO, NOT GOOD ENOUGH           -ARB79-\n         B     EXPIRED            YES, NO DATE CHECK AFTER PSWD -ARB79-\nNOUTPW   TM    COPYFLG,X'02'      ADDING TO TAPE END            -ARB79-\n         BNZ   EXPIRED            YES, NO DATE CHECK REQUIRED   -ARB79-\n         CLC   RECBUF+48(5),TODAY HAS THE EXPIRATION DATE PAST? -ARB79-\n         BNH   EXPIRED            YES, OK TO WRITE THIS TAPE    -ARB79-\n         MVC   EXPDSN(17),RECBUF+4     NO, BUILD OPERATOR MSG   -ARB79-\n         MVC   EXPVOL,JFCBOUT+JFCBVOLS PUT VOLSER INTO MSG      -ARB79-\n         LH    R2,OUTPUT+DCBTIOT  FIND TIOT OFFSET FOR OUTPUT   -ARB79-\n         L     R5,16              FIND TIOT THRU TCB            -ARB79-\n         L     R5,0(,R5)                                        -ARB79-\n         L     R5,4(,R5)                                        -ARB79-\n         L     R5,TCBTIO(,R5)                                   -ARB79-\n         MVC   EXPJOB(8),TIOCNJOB(R5)  PUT JOB & STEP NAME      -ARB79-\n         MVC   EXPSTEP(8),TIOCSTEP(R5) INTO MSG                 -ARB79-\n         AR    R2,R5              FIND OUTPUT TIOT ENTRY        -ARB79-\n         L     R2,TIOEFSRT(R2)    FIND OUTPUT'S UCB             -ARB79-\n         MVC   EXPUNIT,UCBNAME(R2)     GET TAPE UNIT FROM UCB   -ARB79-\nEMSG     LA    R2,EXPMSG                                        -ARB79-\n         BAL   R5,SYSWTOR         ASK FOR PERMISSION TO WRITE   -ARB79-\n         OI    EXPREPLY,X'40'     UPPER CASE REPLY              -ARB79-\n         CLI   EXPREPLY,C'U'      IS IT OK?                     -ARB79-\n         BE    EXPIRED            YES, GO ON                    -ARB79-\n         CLI   EXPREPLY,C'M'      WAS IT FORBIDDEN?             -ARB79-\n         BNE   EMSG               NO, ASK AGAIN                 -ARB79-\n         BAL   R2,PUTLINE         INDICATE COPY IMPOSSIBLE      -ARB79-\n         MVC   MSGBUF(61),=C'0OUTPUT TAPE CANNOT BE USED - EXPIRATION D*\n               ATE NOT YET REACHED'                             -ARB79-\n         B     EXITRC16           AND THEN GIVE UP              -ARB79-\nEXPIRED  MVC   SECDSN,RECBUF+4    COPY DSNAME FROM LABEL        -ARB82-\nSCUROUT  BAL   R14,SCUREXIT       SEE IF INSTALLATION APPROVES  -ARB82-\n         LTR   R15,R15            IS IT OK?                     -ARB82-\n         BZ    SCUROK             YES.                          -ARB82-\n         BAL   R2,PUTLINE         NO, SAY SO                    -ARB82-\n         MVC   MSGBUF(65),=C'0TAPESCAN TERMINATED - YOU ARE UNAUTHORIZE*\n               D TO WRITE ON THIS TAPE'                         -ARB82-\n         B     EXITRC16           GIVE UP                       -ARB82-\nSCUROK   CLI   SECLABEL,C'N'      NL OUTPUT?                    -ARB82-\n         BE    REWNDCK2           YES, REJOIN NL FLOW           -ARB82-\n         TM    COPYFLG,X'02'      COPYING TO END?               -ARB79-\n         BNZ   SEQATEND           YES, GET FIRST FILE SEQ       -ARB79-\n         CLI   POSFLG,C'Y'        INPUT TAPE FILE=1?            -ARB79-\n         BNE   INPUTF1            IF SO, MAY USE INPUT FILE SEQ -ARB79-\n         ZAP   FIRSTSEQ,=P'1'     SET OUTPUT SEQ TO 1           -ARB79-\nINPUTF1  CLC   JOUTFLSQ(2),=H'1'  WRITING TO FILE>1?            -ARB79-\n         BNE   GOUTSEQ                                          -ARB80-\n         CLI   OUTZERO,X'FF'      OUTPUT FILE OMITTED?          -ARB80-\n         BE    REWINDCK           YES.                          -ARB80-\n         ZAP   FIRSTSEQ,=P'1'     NO, FORCE OUTPUT SEQ TO 1     -ARB80-\n         B     REWINDCK                                         -ARB80-\nSEQATEND CLC   RECBUF+31(4),=C'000000' IEHINITT HDR ONLY?       -ARB79-\n         BNE   GOUTSEQ            NO, SAVE FIRST FILE SEQUENCE  -ARB79-\n         NI    COPYFLG,X'FD'      YES, FORGET EOVMOD            -ARB79-\n         ZAP   FIRSTSEQ,=P'1'     AND USE OUTPUT SEQ 1          -ARB79-\n         B     REWINDCK                                         -ARB79-\nGOUTSEQ  PACK  FIRSTSEQ,RECBUF+31(4)   SAVE FIRST FILE SEQ      -ARB79-\n         B     REWINDCK                                         -ARB79-\nCOPYNL   C     R7,=F'80'          WAS AN 80-BYTE BLK READ?      -ARB79-\n         BL    OUTNL              NO, TAPE IS NL                -ARB79-\n         CLC   RECBUF(4),ASCIVOL1 CHECK FOR ASCII LABEL         -ARB79-\n         BE    BADOUTNL           DON'T ALLOW IF FOUND          -ARB79-\n         C     R7,=F'80'          IS LENGTH EXACTLY 80?         -ARB79-\n         BNE   OUTNL              NO, SL IMPOSSIBLE             -ARB79-\n         CLC   RECBUF(4),=C'VOL1' CHECK FOR S LABEL             -ARB79-\n         BE    BADOUTNL                                         -ARB79-\nOUTNL    TM    JFCLTSV,X'BD'      NL INPUT?                     -ARB82-\n         BNZ   SCUROUT            YES, PROCEED                  -ARB82-\n         CLI   SVOUTFLG,C'N'      NO, WAS LABEL CHANGE ALLOWED? -ARB82-\n         BE    SCUROUT            YES, LET IT GO                -ARB82-\n         BAL   R2,PUTLINE                                       -ARB83-\n         MVC   MSGBUF(53),=C'0COPY OF LABELLED TAPE TO UNLABELLED TAPE *\n               NOT ALLOWED'                                     -ARB82-\n         B     LABELMX2           COMPLETE THE MSG              -ARB82-\nMISNGHDR LA    R2,OUTPUT          BACKSPACE PAST SURPRISE       -ARB79-\n         LA    R1,=AL3(BSFCMND)   TAPE MARK                     -ARB79-\n         BAL   R4,EXECEXCP                                      -ARB79-\n         MVC   RECBUF+31(4),=C'0001'   SIMULATE FILE SEQ OF 1   -ARB82-\n         B     SCUROUT            GO MAKE SECURITY CHECK        -ARB82-\nREWINDCK CLI   SVOUTFLG,C'Y'      CHECK FOR UNLABEL             -ARB79-\n         BE    COPYOUT            NO REWIND IF NOT              -ARB79-\nREWNDCK2 NI    COPYFLG,X'7F'      INDICATE NO BSP NEEDED        -ARB82-\n         MVC   OUTLTYP,JFCLTSV    IF SO, MAKE OLABEL=ILABEL     -ARB79-\n         CLC   JOUTFLSQ(2),=H'1' DO NOT REWIND IF SEQ. NO. > 1  -ARB82-\n         BH    LABELSOK           NO REWIND IF FILE SEQ. NO. >1 -ARB79-\n         TM    COPYFLG,X'02'      DO NOT REWIND IF EOVMOD SPECIFIED\n         BO    LABELSOK           NO REWIND IF EOVMOD SPECIFIED -ARB79-\nREWINDER LA    R1,=AL3(RWNDCMND)  REWIND CMD CHAINED TO SENSE   -ARB79-\n         LA    R2,OUTPUT          OUTPUT DCB\n         BAL   R4,EXECEXCP        REWIND AND SENSE\n         MVC   OTRACKS,SENSBYTS+1 SAVE SENSE FOR 7/9 TEST       -ARB79-\n         OC    CTRACKS,OTRACKS    SET ANY 7-TRACK BIT           -ARB79-\n         TM    SENSBYTS+1,X'08'   SEE IF LOAD POINT SENSED\n         BO    COPYOUT2           BIF SENSED LOADPOINT          -ARB79-\n         BAL   R2,PUTLINE\n         MVC   MSGBUF(67),=C'0UNABLE TO REWIND OUTPUT TAPE TO LOAD POIN*\n               T - TERMINATING EXECUTION'\n         B     EXITRC16                                         -ARB79-\nBADOUTVL BAL   R2,PUTLINE\n         MVC   MSGBUF(32),=C'0OUTPUT VOLUME LABEL IS INVALID:'\n         BAL   R5,LISTON\n         B     EXITRC16                                         -ARB79-\nINCOROUT MVC   TRUESER,RECBUF+4   COPY ACTUAL VOLSER TO MSG     -ARB82-\n         BAL   R2,PUTLINE         WRITE ERROR MSG               -ARB82-\n         MVC   MSGBUF(INCORLEN),INCORMSG                        -ARB82-\n         B     EXITRC16           GIVE UP WITH PREJUDICE        -ARB82-\nLABELMIX BAL   R2,PUTLINE         SEND ERROR MSG                -ARB79-\n         MVC   MSGBUF(72),=C'0COPY OF UNLABELED TAPE TO LABELED TAPE MA*\n               Y DESTROY OUTPUT TAPE VALIDITY'                  -ARB79-\nLABELMX2 BAL   R2,PUTLINE                                       -ARB82-\n         MVC   MSGBUF(56),=C' SPECIFY THE ''UNLABEL'' OPTION IF THIS IS*\n                TO BE PERMITTED'                                -ARB82-\n         B     EXITRC16                                         -ARB79-\nBADOUTNL BAL   R2,PUTLINE         STOP NOW IF LABEL WRONG       -ARB79-\n         MVC   MSGBUF(73),=C'0LABEL FOUND ON OUTPUT TAPE DESCRIBED AS U*\n               NLABELED - EXECUTION TERMINATED'                 -ARB79-\n         B     EXITRC16                                         -ARB79-\nCOPYOUT  TM    OUTLTYP,X'42'      LABELLED OUTPUT?              -ARB79-\n         BZ    COPYOUT2           NO, GO POSITION OUTPUT TAPE   -ARB82-\n         TM    COPYFLG,X'80'      NEED TO BACKSPACE TO VOL1     -ARB82-\n         BZ    NOBSP                                            -ARB79-\n         CLC   JOUTFLSQ(2),=H'1'  WRITING TO FILE 1?            -ARB79-\n         BNE   NOBSP              NO, NO BSP NEEDED             -ARB79-\n         TM    COPYFLG,X'02'      WRITING TO END?               -ARB79-\n         BNZ   NOBSP              YES, DON'T BOTHER BSPING      -ARB79-\n         CNTRL OUTPUT,BSR         YES, SKIP BACK                -ARB79-\nNOBSP    CLC   OUTLTYP,JFCLTSV    TAPES LABELLED SIMILARLY?     -ARB79-\n         BE    LABELSOK           GREAT IF SO                   -ARB79-\n         TM    JFCLTSV,X'BD'      NO, IS INPUT UNLABELLED?      -ARB79-\n         BNZ   LABELMIX           YES, FORBID IT                -ARB79-\nLABELSOK LA    R1,=AL3(SENSCMND)  ISSUE SENSE TO GET UNIT TYPE  -ARB79-\n         LA    R2,OUTPUT                                        -ARB79-\n         BAL   R4,EXECEXCP                                      -ARB79-\n         MVC   OTRACKS,SENSBYTS+1      SAVE SENSE BITS          -ARB79-\n         OC    CTRACKS,OTRACKS                                  -ARB79-\nCOPYOUT2 DS    0H                 EOVMOD PROCESSING DONE HERE   -ARB79-\n         LA    R0,EODADOUT        ADDRESS OF NEW OUTPUT TAPE EODAD RTN\n         ST    R0,OUTPUT+DCBEODAD AND SET IT UP IN DCB.\nFILELOOP TM    COPYFLG,X'02'      SEE IF EOVMOD SPECIFIED       -ARB79-\n         BO    FILEFSM            IF SO THEN DO SRCH FWRD FOR TPMK\n         CLC   COUTFILE,JOUTFLSQ  ARE WE IN RIGHT FILE YET?\n         BNL   FILEMSG            BIF YES\nFILEFSM  LA    R1,=AL3(FSMCMND)   FWRD SPACE JUST PAST NEXT TAPEMARK\n         LA    R2,OUTPUT\n         BAL   R4,EXECEXCP\n         LA    R5,1               MAINTAIN                      -ARB79-\n         AH    R5,COUTFILE        CURRENT FILE                  -ARB79-\n         STH   R5,COUTFILE        NUMBER.                       -ARB79-\n         CH    R5,JOUTFLSQ        BIF NOT YET UP TO SPEC FILE   -ARB79-\n         BL    FILEMKCK           BIF NOT YET UP TO SPECIFIED FILE\n         TM    COPYFLG,X'02'      SEE IF EOVMOD SPECIFIED\n         BZ    FILEMSG            BIF EOVMOD NOT SPECIFIED\nFILEMKCK TM    OTRACKS,X'10'      7 TRACK OUTPUT?               -ARB79-\n         BZ    PASTMARK           NO, SKIP MODE SET             -ARB79-\n         TM    OUTLTYP,X'42'      SL OR AL OUTPUT?              -ARB79-\n         BZ    PASTMARK           NO, NO SET MODE NEEDED        -ARB79-\n         SR    R4,R4                                            -ARB79-\n         D     R4,=F'3'           DETERMINE IF LABELS OR DATA   -ARB79-\n         LA    R2,X'2B'           SET MODE=ET FOR LABELS        -ARB79-\n         CH    R4,=H'2'                                         -ARB79-\n         BNE   SETMODE                                          -ARB79-\n         IC    R2,OTRTCH          SET USER MODE FOR DATA        -ARB79-\nSETMODE  MODESET KEY=ZERO         OBTAIN WRITE ACCESS TO DEB    -ARB79-\n         O     R2,DCBDEN+OUTPUT-3 ADD DENSITY TO OP CODE        -ARB79-\n         L     R15,DCBDEBAD+OUTPUT     FIND OUTPUT DEB          -ARB79-\n         STC   R2,DEBSDVM(R15)    SET NEW TRTCH                 -ARB79-\n         MODESET KEY=NZERO        ABDICATE                      -ARB79-\nPASTMARK LA    R2,RECBUF          READ WHAT IMMEDIATELY FOLLOWS -ARB79-\n         READ  TPMKCHK,SF,OUTPUT,(R2),'S'  TAPEMARK TO CHECK FOR EOV'S.\n         CHECK TPMKCHK            EXIT TO EODADOUT, NOT EOLABEL  ON EOF\n         B     FILELOOP           CONTINUE SKIPPING             -ARB79-\nFILEPOS  DS    0H                 BACKSPACE PAST 2ND TAPEMARK OF EOV\n         LA    R2,OUTPUT          PTR TO OUTPUT TAPE'S DCB\n         LA    R1,=AL3(BSFCMND)   BACKSPACE PAST ONE TAPEMARK\n         BAL   R4,EXECEXCP\n         LH    R0,COUTFILE        AND\n         BCTR  R0,0               REDUCE CURRENT FILE NO. APPROPRIATELY\n         STH   R0,COUTFILE\nFILEMSG  DS    0H                 PRINT INITIAL OUTPUT POSITION MSG\n         LH    R1,COUTFILE\n         TM    OUTLTYP,X'42'      LABELLED OUTPUT TAPE?         -ARB79-\n         BZ    NLPOS              NO.                           -ARB79-\n         SR    R0,R0              YES, CONVERT POSITION BACK    -ARB79-\n         D     R0,=F'3'           TO LABELLED FILE  NO          -ARB79-\n         LA    R1,1(,R1)                                        -ARB79-\n         MVC   POSMSG+54(1),SECLABEL  PUT LABEL TYPE IN MSG     -ARB82-\nNLPOS    CVD   R1,BADLNGTH                                      -ARB79-\n         OI    BADLNGTH+7,X'0F'\n         UNPK  POSMSG+31(4),BADLNGTH TELL WHERE 1ST FILE OUTPUT GOES\n         MVC   POSMSG+49(4),POSMSG+31 MOVE INTO EXPLANATORY COMMENT\n         BAL   R2,PUTLINE\n         MVC   MSGBUF(L'POSMSG),POSMSG\n         TM    OUTLTYP,X'42'      OUTPUT LABELLED?              -ARB79-\n         BZ    NOTBOTH                                          -ARB79-\n         CLI   FIRSTSEQ,C'N'      YES, GETTING SEQ FROM OUTPUT? -ARB79-\n         BE    NOTBOTH            NO.                           -ARB79-\n         AP    FIRSTSEQ,BADLNGTH  YES, UPDATE FOR POSITIONING   -ARB79-\n         SP    FIRSTSEQ,=P'1'                                   -ARB79-\n         B     NOTBOTH\nEODADOUT LA    R5,1               COUNT                         -ARB79-\n         AH    R5,COUTFILE        THIS TAPEMARK                 -ARB79-\n         STH   R5,COUTFILE        (THE 2ND ONE OF AN EOV).      -ARB79-\n         CH    R5,JOUTFLSQ        SEE IF UP TO SPECIFIED TM     -ARB79-\n         BL    FILELOOP           BIF NOT UP TO SPECIFIED TM    -ARB79-\n         TM    COPYFLG,X'02'      SEE IF EOVMOD SPECIFIED\n         BZ    FILELOOP           BIF NOT EOVMOD                -ARB79-\n         CH    R5,JOUTFLSQ        SEE WHETHER COUTFILE GT OR JUST      *\n                                  MERELY EQ JOUTFLSQ.           -ARB79-\n         BE    FILEMKCK           BIF TO CONTINUE TO NEXT EOV IF EQ\n         BL    FILELOOP           IGNORE OUTPUT DOUBLE TM       -ARB82-\n         TM    OUTLTYP,X'42'      LABELLED OUTPUT?              -ARB82-\n         BZ    FILEPOS            NO, WE'VE FOUND THE SPOT      -ARB82-\n         SR    R4,R4              SEE IF EOV IS EMPTY DATA FILE -ARB82-\n         D     R4,=F'3'                                         -ARB82-\n         LTR   R4,R4                                            -ARB82-\n         BZ    FILELOOP           IF SO ,CONTINUE               -ARB82-\n         B     FILEPOS            ELSE THIS EOV IS THE ONE      -ARB82-\nNOTTAPEO MVC   IDNTAPE+1(6),=C'OUTPUT'   MOVE 'OUTPUT' TO MSG     -HMD-\nNOTTAPEI BAL   R2,PUTLINE         PUT OUT LINE.                   -HMD-\n         MVC   MSGBUF(L'IDNTAPE),IDNTAPE MOVE MSG TO BUFFER       -HMD-\n         B     EXITRC16           RETURN WITH BAD CODE          -ARB82-\nEOLABEL  TM    OUTLTYP,X'42'      EOF SEEKING LABEL             -ARB79-\n         BZ    OUTNL              OK IF NL EXPECTED             -ARB79-\n         BAL   R2,PUTLINE\n         MVC   MSGBUF(69),=C'0OUTPUT TAPE DESCRIBED AS LABELED HAS NO L*\n               ABELS - TAPESCAN TERMINATED'                     -ARB79-\n         B     EXITRC16                                         -ARB79-\nNOTBOTH  DS    0H\n         L     R12,=A(EXIT+4096)  LOAD 2ND BASE REG FOR MAIN CODE\n         DROP  R12                DROP R12 FOR COMMON STUFF, ONLY R11\n         MVI   GOSW,C'Y'          INDICATE INITIALIZATION DONE  -ARB79-\n         B     SKIPTMPR           INITIALIZATION ENDS HERE      -ARB79-\n         USING TAPESCAN,R12\nNOOUTPUT MVC   BADINPUT+1(6),=C'OUTPUT'\nNOINPUT  BAL   R2,PUTLINE         BAD OR MISSING DD ROUTINE\n         MVC   MSGBUF(L'BADINPUT),BADINPUT\n         B     EXITRC16                                         -ARB79-\n         DROP  R12\n         EJECT\nBSFCMND  CCW   X'2F',0,X'70',1    BSF, CC,SLI,SKIP\n         CCW   X'04',SENSBYTS,X'20',24 SENSE SLI UP TO 24 BYTES\nREAD81CM CCW   2,0,X'60',81       SET TO POINT TO RECBUF DYNAMICALLY\n         CCW   4,SENSBYTS,X'20',24 AND SENSE FOR DEBUG\nEXLSTOUT DC    0F'0',X'87',AL3(JFCBOUT)\nGMCTRL   DC    A(RECBUF+124-TRT1)  MINIMUM LEN FOR THE GETMAIN  -ARB79-\n         DC    A(RECBUF-TRT1+32768) MAXIMUM LENGTH FOR THE GETMAIN\nGMLOCS   DC    2F'0'\nDTYPE    DC    2F'0'              TO HOLD DEVTYPE INFO            -HMD-\nASAVE    DC    A(SAVE)            FOR SETTING UP R13            -ARB79-\nEXITLIST DS    0F                 INPUT DCB EXIT LIST FOR RDJFCB\n         DC    X'87'              LAST ENTRY AND RDJFCB\n         DC    AL3(JFCBIN)        BUFFER FOR INPUT TAPE'S JFCB\nEXPECB   DC    A(0)               EXPDT MSG ECB                 -ARB79-\nEXPMSG   XWTO  'IEC107D E ',(EXPUNIT,3),',',(EXPVOL,6),',',            *\n               (EXPJOB,8),',',(EXPSTEP,8),',',(EXPDSN,17),             *\n               REPLY=(EXPREPLY,1,EXPECB),ROUTCDE=(1,3),DESC=2,MF=L     *\n                                                                -ARB79-\nMVPARM   MVC   PARMBUF(0),0(R3)   COPY PARM STR TO WK AREA      -ARB82-\nEXPREPLY DS    CL1                EXPDT REPLY AREA              -ARB79-\nBADINPUT DC    C'0INPUT  DD STATEMENT MISSING OR INVALID'\nIDNTAPE  DC    C'0OUTPUT DEVICE IS NOT MAGNETIC TAPE - EXECUTION TERMIN*\n               ATED'                                            -ARB82-\nINCORMSG DC    C'0INCORRECT OUTPUT VOLUME MOUNTED - VOLSER = '  -ARB82-\nTRUESER  DC    CL6' '                                           -ARB82-\nINCORLEN EQU   *-INCORMSG                                       -ARB82-\nPOSMSG   DC    C'0FIRST OUTPUT FILE IS FILE NO. 0000 . . . LABEL=(XXXX,*\n               NL)'\nMORECORE DC    C'0WARNING:  TAPESCAN SHOULD HAVE 00000 MORE BYTES OF CO*\n               RE FOR RELIABLE OPERATION; PROCESSING WILL BE ATTEMPTED *\n               ANYWAY.'\nTODAY    DS    CL5                TODAY'S JULIAN DATE           -ARB82-\nCTABLE   DC    C'0123456789ABCDEF'                              -ARB82-\nOUTZERO  DC    X'00'              LABEL=(,XX) FLAG FOR OUTPUT   -ARB82-\nPARMIGN  DC    C' INVALID PARM IGNORED: '                       -ARB82-\nTHISPARM DC    CL100' '           PARM BEING IGNORED            -ARB82-\nPSWDBUF  EQU   THISPARM           REUSE SPACE FOR PROTECT WORK  -ARB82-\n         EJECT\n* COMMON ROUTINES FOR BOTH INITIALIZATION AND MAIN ARE HERE.\nEXIT     MVC   RCODE,OKCODE       NORMAL END, SET RET CODE      -ARB79-\n         CLI   RCODE+3,12         I/O ERROR TERMINATION?        -ARB82-\n         BE    EXITRC16           YES, ALLOW TAPE MARK WRITE    -ARB82-\n         NI    OUTPUT+DCBOFLGS,X'7F'   SUPPRESS FINAL TAPE MARK -ARB79-\nEXITRC16 CLOSE (INPUT,REWIND,OUTPUT,REWIND)                     -ARB82-\nDOEXIT   L     R13,SAVE+4         MAY BYPASS SYNADRLS           -ARB79-\n         MVC   16(4,13),RCODE     GET FINAL RC INTO 15          -ARB79-\n         LM    14,12,12(13)\n         BR    R14                FINAL EXIT FROM TAPESCAN IN ALL CASES\n         SPACE 5\nPUTLINE  DS    0H                 GENERAL PRINTING SUBROUTINE, ENTRY 1\n         MVC   MSGBUF,BLANKBUF    CLEAR BUFFER FAST\nPUTLINE2 EX    0,0(R2)            GENERAL PRINTING SUBROUTINE, ENTRY 2\nPUTLINE3 CLI   SUPOUT,C'Y'        SUPPRESSING PRINTOUT?         -ARB82-\n         BE    6(R2)              YES, DON'T PRINT              -ARB82-\n         CLI   MSGBUF,C' '   GENERAL PRINTING ROUTINE, ENTRY 3  -ARB82-\n         BE    LNCOUNT-4          BIF CARR. CTRL  CHAR IS A BLANK\n         CLI   MSGBUF,C'0'        SEE IF CARRIAGE CONTROL CHAR IS ZERO\n         BE    C0                 BIF IS A ZERO\n         LA    R0,3               NO BLANK OR ZERO, MUST BE A MINUS\n         B     LNCOUNT\nC0       LA    R0,2               COUNT TWO LINES\n         B     LNCOUNT\n         LA    R0,1               COUNT ONE LINE\nLNCOUNT  A     R0,LINENO\n         ST    R0,LINENO\n         C     R0,LINECNT         COMPARE WITH MAX LINES          -HMD-\n         BNH   SAMEPAGE\n         MVC   PAGECHAR,=X'40202120' EDIT PATTERN\n         AP    PAGEPACK,=P'1'\n         ED    PAGECHAR,PAGEPACK\n         MVI   LINENO+3,4                                       -ARB79-\n         PUT   SYSPRINT,PAGEHDR\n         MVI   MSGBUF,C' '        CANCEL REQUESTED CARR CTL     -ARB79-\n         PUT   SYSPRINT,BLANKBUF  LEAVE SOME SPACE              -ARB79-\n         CLI   VTOCOUT,C'Y'       LISTING THE VTOC?             -ARB82-\n         BNE   SAMEPAGE           NO.                           -ARB82-\n         PUT   SYSPRINT,VTOCHED2  YES, ADD SUBTITLE             -ARB82-\n         PUT   SYSPRINT,BLANKBUF                                -ARB82-\n         MVI   LINENO+3,7         ADJUST LINE NO FOR SUBTITLE   -ARB82-\nSAMEPAGE PUT   SYSPRINT,MSGBUF\n         B     6(R2)              RETURN FROM PUTLINE SUBROUTINE\nPAGECHK  DS    0H                 LINE RESERVATION SUBROUTINE\n         CLI   SUPOUT,C'Y'        OUTPUT SUPPRESSION ACTIVE?    -ARB82-\n         BER   R2                 YES, RESERVE NOTHING          -ARB82-\n         A     R0,LINENO          ADD LINES TO BE RESERVED TO LINE NO\n         C     R0,LINECNT         COMPARE TO MAXIMUM LINE  NUMBER -HMD-\n         BCR   13,R2              RETURN IF CURRENT PAGE HAS ENUF ROOM\n         ST    R0,LINENO          ELSE FORCE NEW PAGE NEXT LINE -ARB82-\n         BR    R2\n         SPACE 5\nLENCK    BHR   R2                 RETURN IF LENGTH OK           -ARB79-\n         BNE   NEGREC             DEFINITE ERROR IF LEN<0       -ARB79-\n         CLI   ERRLAST,0          0 LENGTH AFTER ERROR?         -ARB79-\n         BNER  R2                 YES, ALLOW IT                 -ARB79-\nNEGREC   TM    OPTNO+3,X'01'      CHECK WTL OPTION              -ARB79-\n         BZ    NOERRLOG                                         -ARB79-\n         WTL   'BAD (0) BLOCK SIZE' USUALLY MEANS TAPE OFF END OF REEL\nNOERRLOG BAL   R2,PUTLINE                                       -ARB79-\n         MVC   MSGBUF(61),=C'0LOGIC OR HARDWARE ERROR - ZERO OR NEGATIV*\n               E LENGTH BLOCK READ'                             -ARB82-\n         B     EXITRC12           FINISH UP & TERMINATE         -ARB82-\n         SPACE 5\n         DROP  R13                                              -ARB79-\nSYNERR   SYNADAF ACSMETH=BSAM\n         MVI   ERRLAST,X'FF'      SET RECENT ERROR FLAG         -ARB79-\nSYNERR2  ST    R14,SVR14\n         STM   R1,R6,SVR1R6       SAVE REGS 1 THRU 6 FOR SYNAD USE\n         L     R6,132(R1)         RETRIEVE R1 FROM BEFORE SYNADAF MACRO\n         L     R3,4(,R13)         FIND OLD R13                  -ARB79-\n         USING SAVE,R3                                          -ARB79-\n         LH    R14,12(R1)         LOAD NO. OF BYTES READ        -ARB79-\n         MVC   8(12,R1),=C'0I/O ERROR -'    MESSAGE PREFIX      -ARB79-\n         CH    R0,=H'4'           CHECK SYNADAF'S RETURN CODE\n         BNE   DIRECT\n         CVD   R14,BADLNGTH\n         OI    BADLNGTH+7,X'0F'\n         UNPK  32(5,R1),BADLNGTH\n         MVC   20(12,R1),=C' BYTES READ='                       -ARB79-\nDIRECT   MVC   38(5,R1),=C'FILE=' ADD FILE NUMBER TO TEXT       -ARB82-\n         L     R2,CTPMKNO         GET INPUT TM NUMBER           -ARB82-\n         LA    R2,1(,R2)                                        -ARB82-\n         CLI   75(R1),C'I'        INPUT ERROR?                  -ARB82-\n         BE    INPERR             YES.                          -ARB82-\n         LH    R2,COUTFILE        NO, GET OUTPUT FILE NUMBER    -ARB82-\nINPERR   CVD   R2,BADLNGTH        CONVERT FILE NO TO DECIMAL    -ARB82-\n         UNPK  43(4,R1),BADLNGTH                                -ARB82-\n         OI    46(R1),X'F0'                                     -ARB82-\n         L     R2,BLKNO           GET BLOCK NUMBER &            -ARB82-\n         LA    R2,1(,R2)                                        -ARB82-\n         CVD   R2,BADLNGTH                                      -ARB82-\n         UNPK  107(7,R1),BADLNGTH REPLACE FALSE ONE IN          -ARB82-\n         OI    113(R1),X'F0'      THE SYNADAF MESSAGE           -ARB82-\n         MVC   MSGBUF(120),8(R1)  PRINT SYNAD ERROR MESSAGE     -ARB82-\n         MVC   MSGBUF+120(13),BLANKBUF                          -ARB79-\n         SYNADRLS ,               RETURN SYNADAF MSG            -ARB79-\n         DROP  R3                                               -ARB79-\n         USING SAVE,R13           OLD R13 IS RESTORED           -ARB79-\n         MVC   SAVE2(72),SAVE     SAVE SAVE AREA CONTENTS       -ARB79-\n         MVC   OLDSUP,SUPOUT      SAVE OUTPUT SUPPRESS FLAG     -ARB82-\n         MVI   SUPOUT,C'N'        MAKE SURE OUR MSGS GET OUT    -ARB82-\n         LA    R0,4               RESERVE 4 LINES FOR MSGS      -ARB79-\n         BAL   R2,PAGECHK                                       -ARB79-\n         LA    R2,*+2                                           -ARB79-\n         B     PUTLINE3           GO PRINT THE MESSAGE          -ARB79-\n         LR    R1,R6              RETRIEVE R1 FROM BEFORE SYNADAF MACRO\n         TM    EXCPAGIN,X'02'     SEE IF EXCP RATHER THAN BSAM\n         BO    *+12               BIF WAS EXCP, R1 POINTED TO IOB\n         L     R1,DCBIOBA(R1)     IT WAS BSAM, R1 POINTED TO DCB\n         B     *+8                R1 NOW POINTS TO BSAM IOB PREFIX\n         SH    R1,=H'8'           SUBTRACT 8 TO GET PTR TO IOB PREFIX\n         LR    R6,R1              SAVE PTR TO IOB BSAM PREFIX\n         TM    IOBSENS1+8(R1),X'01'    NOT CAPABLE ERR?         -ARB79-\n         BNZ   INCAP              YES, TERMINATE                -ARB79-\n         TM    IOBSENS0+8(R1),X'10'   CHECK FOR EQUIP CHECK     -ARB79-\n         BNZ   EQPCHECK           TERMINATE IF SO               -ARB79-\n         TM    IOBCSW+3+8(R1),X'01'    UNIT EXCEPTION?          -ARB79-\n         BNZ   OUTEOV             YES, GIVE OUTPUT EOV MSG      -ARB79-\n         TM    IOBSENS0+8(R1),X'80'     COMMAND REJECT?         -ARB82-\n         BO    NORING             YES, GIVE FILE PROTECT MSG    -ARB82-\n         LM    R1,R6,SVR1R6       RESTORE REGS 1 THRU 6         -ARB79-\n         LA    R14,1\n         A     R14,ERRCOUNT       INCREMENT ERROR COUNT\n         ST    R14,ERRCOUNT\n         C     R14,SYNADNO        COMPARE ERROR COUNT WITH ERROR LIMIT\n         BH    TOOMANY            PRINT MSG & EXIT IF ERR LIM EXCEEDED\n         MVC   SUPOUT,OLDSUP      RESTORE OUTPUT SUPPRESS FLAG  -ARB82-\n         MVC   SAVE(72),SAVE2     RESTORE FOR SYNAD RETURN      -ARB79-\n         L     R14,SVR14\nSYNCONTU BR    R14                                              -ARB82-\nTOOMANY  BAL   R2,PUTLINE         YOU SHOULD PROBABLY SET ERRLIM TO 0 -\n         MVC   MSGBUF(55),=C'0TAPESCAN TERMINATING DUE TO EXCESSIVE I/O*\n                ERROR COUNT.'\n         B     EXITRC12           FOR TAPE COPYING OPERATIONS.  -ARB82-\nINCAP    BAL   R2,PUTLINE         DEFINE NOT CAPABLE            -ARB79-\n         MVC   MSGBUF(75),=C'0THIS TAPE CANNOT BE READ ON THIS TYPE OF *\n               TAPE UNIT - TERMINATING EXECUTION'               -ARB79-\n         B     EXITRC16                                         -ARB79-\nEQPCHECK LM    R1,R6,SVR1R6       RESTORE REGISTERS             -ARB79-\n         BAL   R2,PUTLINE         SEND EXPLANATION              -ARB79-\n         MVC   MSGBUF(48),=C'0EQUIPMENT CHECK - OFTEN MEANS TAPE RAN OF*\n               F REEL'                                          -ARB79-\n         B     EXITRC12           TRY TO TERMINATE CLEANLY      -ARB82-\nNORING   LM    R1,R6,SVR1R6       RESTORE SYNAD REGS            -ARB82-\n         BAL   R2,PUTLINE         SEND EXPLANATION              -ARB82-\n         MVC   MSGBUF(54),=C'0OUTPUT TAPE IS FILE PROTECTED - TERMINATI*\n               NG EXECUTION'                                    -ARB82-\n         B     EXITRC16           QUIT HARD                     -ARB82-\nOUTEOV   LM    R1,R6,SVR1R6       RESTORE SYNAD REGS            -ARB79-\n         BAL   R2,PUTLINE                                       -ARB79-\n         MVC   MSGBUF(54),=C'0OUTPUT TAPE CAPACITY EXCEEDED - TERMINATI*\n               NG EXECUTION'                                    -ARB79-\nEXITRC12 DS    0H                 TERMINATE RUN WITH RC=12, BUT        *\n                                  GIVE STATISTICS FIRST         -ARB82-\n         CLI   GOSW,C'Y'          PAST INITIALIZATION?          -ARB79-\n         BNE   EXITRC16           NO, JUST TERMINATE            -ARB79-\n         USING EXIT+4096,R12      ELSE R12 IS SET UP            -ARB79-\n         MVI   OKCODE+3,12        SET LESS THAN PERFECT RC      -ARB82-\n         MVI   GOSW,C'N'          PREVENT RECURSION             -ARB79-\n         MVC   TPMKMSG+1(17),=CL17'PROCESSING ENDED'            -ARB79-\n         TM    EXCPAGIN,X'02'     EXCP ERROR?                   -ARB84-\n         BZ    TPMKLOGD           NO.                           -ARB84-\n         L     R4,SVR4            YES, RESTORE REG 4            -ARB84-\n         B     TPMKLOGD           GO FINISH CLEANLY             -ARB79-\n         DROP  R12                                              -ARB79-\n         EJECT\nEXECEXCP DS    0H                 EXCP SUBROUTINE, R2=PTR TO DCB, AND  *\n                                  R1=PTR TO 3-BYTE ADCON WHICH POINTS  *\n                                  TO CHANNEL PROGRAM.\n         L     R2,DCBIOBA(R2)     GET PTR TO A BSAM IOB PREFIX\n         MVC   STARTSAV(3),IOBSTART+9(R2) SAVE PTR TO BSAM'S CCW\n         MVC   IOBSTART+9(3,R2),0(R1) MOVE IN PTR TO CHAN PROG\n         LA    R1,4(R2)           LOAD PTR TO ECB IN PREFIX\n         ST    R1,IOBECBPT+8(R2)  STORE PTR TO ECB\n         XC    0(4,R1),0(R1)      CLEAR ECB IN IOB PREFIX\n         EXCP  8(R2)              EXCP USING BSAM'S IOB AND ECB\n         WAIT  ECB=4(R2)\n         MVC   IOBSTART+9(3,R2),STARTSAV RESTORE PTR TO BSAM'S CCW\n         CLI   4(R2),X'7F'        SEE IF EXCP WORKED PERFECTLY\n         BCR   8,R4               RETURN IF IT DID\n         LA    R1,8(R2)           GET PTR TO IOB FOR SYNADAF MACRO\n         OI    EXCPAGIN,X'02'     INDICATE EXCP, NOT BSAM, IN SYNAD\n         SYNADAF ACSMETH=EXCP     WORKS OK EVEN THO IOBSTART RESTORED\n         BAL   R14,SYNERR2        NOW DO REST OF ANALYSIS WITH SYNERR\n         TM    OPTNO+3,X'40'      BIT=1=STOP FOR ANY EXCP ERROR\n         BCR   8,R4               BRANCH TO NOT TERMINATE\n         BAL   R2,PUTLINE         PRINT ERR MSG BEFORE STOP\n         MVI   SUPOUT,C'N'        MAKE SURE MSG PRINTS          -ARB82-\n         MVC   MSGBUF(34),=C'0EXCP ERROR TERMINATION THRU OPT64'\n         B     EXITRC16                                         -ARB79-\n         SPACE 5\nLISTBLK  CLI   SUPOUT,C'Y'        SUPPRESSING LISTING?          -ARB82-\n         BER   R5                 YES, DON'T TRY                -ARB82-\n         MVC   MSGBUF+1(11),BLOCKNO   ADD BLOCK NO TO LISTING   -ARB82-\n         MVI   HEXOFF+1,11        PUT TEXT AFTER BLOCKNO        -ARB79-\n         LTR   R7,R7              IS THE LENGTH 0?              -ARB79-\n         BZR   R5                 YES, DON'T LIST               -ARB79-\nLISTON   MVI   MSGBUF,C'0'\n         LA    R0,4               PREPARE TO RESERVE 4 LINES\n         BAL   R2,PAGECHK         RESERVE 4 LINES\n         LA    R6,MSGBUF+1                                      -ARB79-\n         AH    R6,HEXOFF          FIND WHERE TO PUT TEXT        -ARB79-\n         BAL   R2,PUTLINE2        LIST THE FIRST PART OF THE BLOCK\n         MVC   0(120,R6),RECBUF   MOVE RECORD TO OUTPUT LINE    -ARB79-\nHEXON    CLI   HEXFLG,C'N'        SEE IF HEXLIST SPECIFIED\n         BCR   8,R5               BER R5 RETURN IF HEXLIST NOT SPECIFID\n         MVC   MSGBUF,BLANKBUF    BLANK OUT BUFFER              -ARB79-\n         LA    R6,MSGBUF+1                                      -ARB79-\n         AH    R6,HEXOFF          COMPUTE WHERE TO PUT TEXT     -ARB79-\n         MVC   0(120,R6),ASCBUF   MOVE IT IN                    -ARB79-\n         MVC   TRINT1+1(1),LINESIZE+3 DEFAULT TRANSLATE LEN=120 -ARB79-\n         MVC   TRINT2+1(1),LINESIZE+3 DEFAULT TRANSLATE LEN=120 -ARB79-\n         C     R7,LINESIZE        SEE IF LENGTH EXCEEDS 1 LINE  -ARB79-\n         BH    TRINT1             BIF BLOCK LENGTH GT 120 CHARS\n         LR    R2,R7              DON'T CHANGE R7 ITSELF        -ARB79-\n         BCTR  R2,0               DECREMENT BLK  LENGTH         -ARB79-\n         STC   R2,TRINT1+1        AND STORE IN 1ST TR INSTR     -ARB79-\n         STC   R2,TRINT2+1        AND IN THE SECOND ONE         -ARB79-\nTRINT1   TR    0(120,R6),TRT1     MODIFIED INSTRUCTION (LENGTH) -ARB79-\n         MVI   MSGBUF,C' '        SET CARRIAGE CONTROL\n         BAL   R2,PUTLINE3        PRINT FIRST LINE OF HEX\n         DC    C'TRT111'\n         MVC   0(120,R6),ASCBUF                                 -ARB79-\nTRINT2   TR    0(120,R6),TRT2     MODIFIED INSTRUCTION (LENGTH) -ARB79-\n         BAL   R2,PUTLINE3        PRINT SECOND LINE OF HEX\n         DC    C'TRT222'          FILLER\n         MVI   LINESIZE+3,119     RESTORE DEFAULT HEX LENGTH    -ARB79-\n         BR    R5                 RETURN FROM LISTON OR HEXON SUBR\n         SPACE 5\nJULDATE  DS    0H                 DATE VALIDATION FRONT-END TO JULIAN  *\n                                                                -ARB82-\n         LM    R15,R0,0(R1)       LOAD JULIAN PARM REGS         -ARB82-\n         CLC   0(5,R15),=C'000000'     INPUT DATE ZERO?         -ARB82-\n         BER   R14                YES, RETURN ZEROES            -ARB82-\n         TRT   0(5,R15),NUBTABL   NO, IS DATE NUMERIC?          -ARB82-\n         BNZ   BADDATE            NO, RETURN \"INVALID\"          -ARB82-\n         L     R15,=V(JULIAN)     YES, CALL CONVERTER           -ARB82-\n         BR    R15                                              -ARB82-\nBADDATE  LR    R1,R0              COPY RETURN VALUE PTR         -ARB82-\n         MVC   0(7,R1),=C'INVALID'     NOTE IT WAS BAD          -ARB82-\n         BR    R14                AND RETURN                    -ARB82-\n         SPACE 5\nGETVTOC  DS    0H                 ROUTINE TO GET VTOC BLOCK     -ARB82-\n         LTR   R3,R3              HAVE A PREVIOUS VTOC ENTRY?   -ARB82-\n         BZ    NOVSTATS           NO.                           -ARB82-\n         USING VTOC,R3                                          -ARB82-\n         MVC   VTOCSTAT(12),FILESTAT   COPY ERROR FLAGS TO VTOC -ARB82-\n         XC    FILESTAT(12),FILESTAT   AND RESET TO ZERO        -ARB82-\n         SR    R14,R14            COUNT NUMBER OF NOTES         -ARB82-\n         LA    R15,12                                           -ARB82-\n         LA    R1,VTOCSTAT                                      -ARB82-\nSTATCNT  CLI   0(R1),0            IS THIS ERROR FLAGGED?        -ARB82-\n         BE    *+8                                              -ARB82-\n         LA    R14,1(,R14)        YES, INCREASE COUNT           -ARB82-\n         LA    R1,1(,R1)                                        -ARB82-\n         BCT   R15,STATCNT                                      -ARB82-\n         STH   R14,VTOCMSG#       SAVE NUMBER OF NOTES          -ARB82-\n         CLI   VNOMORE,C'Y'       GET ANY MORE ENTRIES?         -ARB82-\n         BER   R2                 NO, RETURN                    -ARB82-\nNOVSTATS L     R5,CURRVTOC        POINT TO CURRENT VTOC BLOCK.  -ARB82-\n         CLI   0(R5),VTOCEPB      IS THIS BLOCK FULL?             -CWB-\n         BL    NXTENTRY           IF NOT, BRANCH.                 -CWB-\n         GETMAIN  R,LV=VTOCBLSZ   ELSE, GET CORE FOR ANOTHER BLOCK-CWB-\n         ST    R1,0(R5)           SAVE FOREWARD POINTER.          -CWB-\n         MVI   0(R5),VTOCEPB      REINSERT THE ENTRY COUNT.       -CWB-\n         LR    R5,R1              MAKE NEW BLOCK CURRENT.         -CWB-\n         ST    R1,CURRVTOC                                        -CWB-\n         LA    R3,8(R5)           STEP OVER INITIAL DOUBLEWORD.   -CWB-\n*                                      R3 POINTS AT CURRENT ENTRY.-CWB-\n         SR    R0,R0              CLEAR ENTRY COUNT AND FORWARD   -CWB-\n         ST    R0,0(R5)                POINTER IN NEW BLOCK.      -CWB-\n         MVI   0(R5),1            CHANGE ENTRY COUNT TO 1.        -CWB-\n         B     CLEARVEN           GO CLEAR THE FIRST ENTRY.       -CWB-\nNXTENTRY LA    R3,VTOCSIZE(R3)    ADVANCE TO NEXT VTOC ENTRY.     -CWB-\n         SR    R1,R1              INCREMENT ENTRY COUNT.          -CWB-\n         IC    R1,0(R5)                                           -CWB-\n         LA    R1,1(R1)                                           -CWB-\n         STC   R1,0(R5)                                           -CWB-\nCLEARVEN MVC   VTOC(VTOCCSIZ),BLANKBUF  CLEAR OUT VTOC ENTRY.   -ARB82-\n         XC    VTOC2(VTOCBSIZ),VTOC2    ZERO BINARY PART        -ARB82-\n         DROP  R3                                               -ARB82-\n         BR    R2                 RETURN TO CALLER              -ARB82-\n         EJECT\nSYSWTOR  DS    0H                 ROUTINE TO ISSUE A SUPERVISORY WTOR  *\n                                                                -ARB79-\n         MODESET KEY=ZERO         TO PUT * BEFORE MESSAGE       -ARB79-\n         XWTO  MF=(E,(R2))        SEND MSG & GET REPLY          -ARB79-\n         L     R2,4(,R2)          FIND REPLY ECB                -ARB79-\n         WAIT  ECB=(R2)           AWAIT THE REPLY               -ARB79-\n         MODESET KEY=NZERO        GIVE UP PRIVILEGE             -ARB79-\n         XC    0(4,R2),0(R2)      RESET THE ECB                 -ARB79-\n         BR    R5                 AND RETURN TO CALLER          -ARB79-\n         SPACE 5\nCHKPASS  DS    0H                 ROUTINE TO LOOK UP DATASET PASSWORD  *\n                                                                -ARB79-\n         LA    R1,43(,R2)         LOOK FOR END OF JFCB DSN      -ARB79-\nDSNSCAN  CLI   0(R1),C' '                                       -ARB79-\n         BNE   DSNEND                                           -ARB79-\n         BCT   R1,DSNSCAN                                       -ARB79-\nDSNEND   LA    R0,1(,R1)                                        -ARB79-\n         SR    R0,R2              COMPUTE DSN LENGTH            -ARB79-\n         STC   R0,PSWDPARM+4      STORE LENGTH FOR PROTECT      -ARB79-\n         CH    R0,=H'17'          IS DSN TOO BIG FOR LABEL?     -ARB79-\n         BNH   SHORTDSN           NO.                           -ARB79-\n         SH    R1,=H'16'          YES, POINT TO LAST 17 CHARS   -ARB79-\n         B     TESTDSN                                          -ARB79-\nSHORTDSN LR    R1,R2                                            -ARB79-\nTESTDSN  CLC   0(17,R1),RECBUF+4  COMPARE JFCB DSN TO LABEL     -ARB79-\n         BE    FULLDSN            A MATCH, LOOK UP BY JFCB DSN  -ARB79-\n         LA    R2,RECBUF+4        ELSE USE DSN FROM LABEL       -ARB79-\n         MVI   PSWDPARM+4,17      SET LABEL DSN LENGTH          -ARB79-\nFULLDSN  STCM  R2,7,PSWDPARM+5    PUT DSN ADDR IN PARM LIST     -ARB79-\n         PROTECT PSWDPARM         LOOK UP DSN-PASSWORD PAIR     -ARB79-\n         BR    R5                 & RETURN TO CALLER            -ARB79-\n         SPACE 5\nSCUREXIT DS    0H                 ROUTINE TO CALL SECURITY EXIT -ARB82-\n         WXTRN TAPESCUR           ALLOW EXIT TO BE ABSENT       -ARB82-\n         L     R15,=V(TAPESCUR)   FIND ENTRY TO EXIT            -ARB82-\n         LTR   R15,R15            IS THERE ONE?                 -ARB82-\n         BZR   R14                NO, ANYTHING GOES             -ARB82-\n         LA    R1,SCURPARM        YES, LOAD PARM LIST ADDR      -ARB82-\n         BR    R15                AND CALL EXIT ROUTINE         -ARB82-\n         EJECT\n*        NEXT 3 CCW'S MOVED FOR ADDRESSABILITY                  -ARB79-\nWRTCMND  CCW   1,0,X'20',0        PTR TO RECBUF UPDATED AFTER GETMAIN\nWTMCMND  CCW   X'1F',0,X'60',1    WRITE TAPEMARK, SLI, CC TO SENSE\n         CCW   X'04',SENSBYTS,X'20',1 SENSE CHAINED FOR DEVICE END INFO\nFSMCMND  CCW   X'3F',0,X'30',1    FWRD SPACE FILE, SKIP/SLI\nRWNDCMND CCW   7,0,X'60',1        REWIND TAPE, CHAIN CMND, SLI\nSENSCMND CCW   4,SENSBYTS,X'20',24 SENSE UP TO 24 BYTES, SLI\nSENSBYTS DC    3CL8'SENSBYTS'     BUFFER FOR SENSE BYTES\nBADLNGTH DC    D'0'\nPSWDECB  DC    F'0'               ECB FOR PASSWORD WTOR         -ARB79-\nPSWDREPL DS    CL8                PASSWORD REPLY BUFFER         -ARB79-\nSVR1R6   DS    6F                 FOR SAVING REGISTERS 1 THRU 6\nSVR14    DC    F'0'               TO SAVE R14 TEMPORARILY       -ARB79-\nWORK     DS    2A                 FOR DATE CONVERT WKAREA    *FD78.130\nAMSGBP58 DC    A(0)               A(MSGBUF+58) SET DURING INIT  -ARB79-\nAMSGBP86 DC    A(0)               A(MSGBUF+86)                  -ARB79-\nCURRVTOC DC    A(FRSTVTOC)        CURRENT VTOC BLOCK.           -ARB82-\nERRCOUNT DC    F'0'               NUMBER OF SYNAD EXITS TAKEN (I/O ERRS\nOPTNO    DC    F'0'               BIT ORIENTED OPTIONS - MISC/DEBUG\nLINENO   DC    F'70'\nLINESIZE DC    F'119'             MAX NUMBER CHARS/LINE-1       -ARB79-\nLISTNO   DC    F'-1'         NUMBER OF BLKS TO LIST PER DATASET -ARB82-\nSKIPTMNO DC    F'0'\nSKIPTMVL DC    F'0'               SKIPTM PARM VALUE             -ARB82-\nSKIPFLNO DC    F'0'               NUMBER FILES TO BE SKIPPED    -ARB79-\nMAXTMNO  DC    F'32767'\nSTOPTMNO DC    F'32767'           STOPTM PARM (CONSTANT)        -ARB82-\nSTPEOVNO DC    F'1'               STOPEOV PARM (CONSTANT)       -ARB82-\nSKPEOVNO DC    F'0'\nMAXEOVNO DC    F'1'\nSYNADNO  DC    F'5'          MAX SYNAD EXITS BEFORE TERMINATION -ARB79-\nLINECNT  DC    F'59'              LINES/PAGE                    -ARB82-\nRCODE    DC    F'16'              EXPECTED BAD RETURN CODE      -ARB79-\nOKCODE   DC    F'0'               EXPECTED GOOD RETURN CODE     -ARB79-\nBLKNO    DC    F'0'               BLOCK NO READ BY READER       -ARB82-\nCOUTFILE DC    H'1'               CURRENT OUTPUT FILE SEQ. NO.\nINFLPOS  DC    H'1'               INPUT LABEL NUMBER            -ARB82-\nCTPMKNO  DC    F'0'          # OF INPUT TAPEMARKS ENCOUNTERED   -ARB82-\nHEXOFF   DC    H'0'               TEXT OFFSET FOR HEX RTN       -ARB79-\nFIRSTSEQ DS    0PL3               SEQ OF FIRST INPUT FILE       -ARB79-\n         DC    CL3'N'             INDICATE NOT YET SET          -ARB79-\nPAGEPACK DC    PL2'0'             COUNTS PAGES\nEXCPAGIN DC    X'00'              EXCP 'REENTRY' FLAG, X'01'= REENTRY, *\n                                  X'02' BIT=EXCP TYPE ERROR NOT BSAM\nERRLAST  DC    X'00'              LAST READ HAD ERROR FLAG      -ARB79-\nPHFLSTAT DC    XL12'00'           ERROR FLAGS FOR PHYISCAL FILE -ARB82-\nFILESTAT DC    XL12'00'           ERROR FLAGS FOR LOGICAL FILE  -ARB82-\nASCURITY DC    C'0ASCII VOLUME SECURITY PROTECTED - TAPESCAN TERMINATED*\n               '                                                -ARB79-\nDENMSG   DC    CL40'0 800 BPI= ASSUMED DENSITY OF INPUT TAPE'   -ARB82-\nASCIVOL1 DC    X'564F4C31'        ASCII VOL1                    -ARB79-\nBLOCKNO  DC    C'BLOCK NNN: '                                   -ARB79-\nPAGEHDR  DC    CL71'1TAPESCAN  -  IRSS/GTEDS/ICSA TAPE ANALYSIS AND COP*\n               YING PROGRAM  V5.1  '                            -ARB82-\nDATERSLT DC    CL8'MM/DD/YY'      DATE WILL BE PLACED HERE\n         DC    CL2'  '\nTIMERSLT DC    XL11'4021207A20207A20204B20'\n         DC    CL17'    INPUT VOLSER='                          -ARB82-\nDDVOL    DC    CL6'VVVVVV'                                        -CWB-\n         DC    CL8'    PAGE'                                    -ARB82-\nPAGECHAR DC    X'40202120'        EXAMPLE EDIT PATTERN FOR PAGE NUMBER\n         DC    CL12'           '  PAGE TRAILING BLANKS\nVTOCHED2 DC    CL133' '                                         -ARB82-\n         ORG   VTOCHED2           OVERLAY TEXT ON TITLE         -ARB82-\n         DC    C'0SEQ.  DATA SET NAME     LABEL RECFM  LRECL  BLKSIZE E*\n               XPIRES  BLK COUNT  '                             -ARB82-\nVTOCHEDE EQU   *                                                -ARB82-\n         ORG   ,                                                -ARB82-\nVTOCOUT  DC    C'N'               VTOC LISTING IN PROGRESS      -ARB82-\nJFCLTSV  DC    X'FF'              FOR SAVING JFCBLTYP BYTE\nOUTLTYP  DC    C'0'               TO SAVE OUTPUT LABEL TYPE     -ARB79-\nITRTCH   DS    X                  INPUT TRTCH BITS              -ARB79-\nOTRTCH   DS    X                  OUTPUT TRTCH BITS             -ARB79-\nITRACKS  DC    X'00'              X'10' BIT->7 TRACK            -ARB79-\nOTRACKS  DC    X'00'              X'10' BIT->7 TRACK            -ARB79-\nCTRACKS  DC    X'00'              OTRACKS .OR. ITRACKS          -ARB79-\nSTARTSAV DC    C'SAV'             FOR SAVING BSAM'S IOBSTART FIELD\nCOPYFLG  DC    X'00'              COPY AND MOD OPTION BITS      -ARB82-*\n               X'01'=COPY,X'02'=EOVMOD,X'04'=UNLABEL,           -ARB82-*\n               X'80'=BACKSPACE BEFORE COPY                      -ARB82-\nWRTFLG   DC    X'00'              TWO BIT COPY FLAG, X'03'=WRITE BLOCK\nSKIPFLG  DC    X'00'              TAPE POSITIONING FLAG         -ARB79-\nPOSFLG   DC    C'N'               LABEL INPUT POSITIONING FLAG  -ARB82-\nCOUNTFLG DC    C' '               COUNT OPTION FLAG (DEFAULT VARIES)   *\n                                                                -ARB82-\nHEXFLG   DC    C'N'                                             -ARB79-\nSUMFLG   DC    C'Y'\n*              THE NEXT TWO FIELDS MUST BE KEPT TOGETHER        -ARB82-\nASCIIN   DC    C'N'               TRANSLATE INPUT FROM ASCII    -ARB79-\nASCIOUT  DC    C'N'               TRANSLATE OUTPUT TO ASCII     -ARB79-\nSVOUTFLG DC    C'Y'          C'N' = CHANGE OUTPUT VOL LABEL     -ARB82-\nMAPFLG   DC    C'N'               MAPONLY OPTION FLAG           -ARB82-\nSUPOUT   DC    C'N'               SUPPRESS LISTING FLAG         -ARB82-\nOLDSUP   DS    CL1                SUPOUT COPY FOR SYNAD RTN     -ARB82-\nGOSW     DC    C'N'               INITALIZATION DONE SWITCH     -ARB79-\nVNOMORE  DC    C'N'               STOP GETVTOC SWITCH           -ARB82-\nPSWDSW   DC    X'00'              FIRST/SECOND PASSWORD SWITCH  -ARB79-\nSCURPARM DS    0A                 PARM LIST FOR SECURITY EXIT   -ARB82-\nSECDCB   DS    A                  POINTER TO TAPE DCB           -ARB82-\nSECIOTYP DC    C'O'               I=INPUT,O=OUTPUT              -ARB82-\nSECLABEL DC    C'N'               N=NL, A=AL, S=SL              -ARB82-\nSECDSN   DC    CL17' '            FROM HDR1 LABEL OR BLANK      -ARB82-\nSECVOL   DC    CL6' '             VOLSER FROM LABEL OR JCL      -ARB82-\nPSWDPARM DC    0A(0),X'04',AL3(PSWDBUF)     PROTECT PARM LIST   -ARB79-\n         DS    A                  TO PERFORM LISTPW FUNCTION    -ARB79-\n         DC    A(PSWDREPL)                                      -ARB79-\nSMSG     XWTO  'IEC301A S JOB ',(SMSGJOB,8),', STEP ',(SMSGSTEP,8),    *\n               ', DDNAME ',(SMSGDD,8),REPLY=(PSWDREPL,8,PSWDECB),      *\n               ROUTCDE=9,DESC=2,MF=L                            -ARB79-\n         EJECT\n* MAIN LOOP AND MAIN LINE CODE STARTS HERE\nSKIPEOVP DS    0H                 SKIPEOV OPTION CONTROL ROUTINE\n         USING EXIT+4096,R12\n         CLC   CEOVNO,SKPEOVNO\n         BL    SKIPTMEV           DO SKIPEOV IF NEEDED          -ARB79-\nEOVDONE  L     R2,CTPMKNO         FIND WHERE TO SKIPTM TO       -ARB79-\n         A     R2,SKIPTMNO        SKIPTM IS RELATIVE TO SKIPEOV -ARB79-\n         ST    R2,SKIPFLNO                                      -ARB79-\n         L     R2,CEOVNO          COMPUTE MAXEOV FROM STOPEOV   -ARB79-\n         A     R2,MAXEOVNO                                      -ARB79-\n         ST    R2,MAXEOVNO        STORE FINAL EOV NUMBER        -ARB79-\n         B     SKIPTMPR           GO SKIP ANY TM'S REQUESTED    -ARB79-\nSKIPTMEV SR    R4,R4              ZERO TO GET GOOD BLK CNT EVEN IF     *\n                                  SKIPTM OR SKIPEOV USED.\n         SR    R8,R8              (RE)-ZERO BYTE COUNTER\n         ST    R8,BLKCNT          (RE)-ZERO BLKCNT\n         BAL   R5,READER          CHECK FOR DOUBLE TAPEMARK\n         C     R7,=F'80'          SEE IF BLKSIZE=80 (LIKE ALL LABELS)\n         BL    CONTROL            BIF BLKLNGTH LT 80 (I.E., IT'S NOT A *\n                                                    LABEL).     -ARB79-\n* ARE THE NEXT TWO INSTRUCTIONS NECESSARY?\n         C     R4,=F'1'           SEE IF THIS IS THE 1ST BLK AFTER A   *\n                                  TAPEMARK OR THE LOAD POINT.\n         BNE   CONTROL            BIF IT ISN'T THE FIRST\n         CLI   VERVOL,C'Y'        NEED TO VERIFY THE VOLUME?    -ARB79-\n         BE    CHKVOL1            YES, CHECK FOR VOLUME LABEL   -ARB79-\nNOHDRS   CLI   ASCIIN,C'Y'        ASCII INPUT?                  -ARB79-\n         BE    EOVCK              YES, LONG LABEL POSSIBLE      -ARB79-\n         C     R7,=F'80'          NO, IS LENGTH EXACTLY 80      -ARB79-\n         BNE   DOCTL              NO, LABEL IMPOSSIBLE          -ARB79-\nEOVCK    CLC   RECBUF(4),=C'EOV1'                               -ARB79-\n         BNE   CONTROL\n         OI    EOV1FLG,X'01'      INDICATE EOV1 TYPE OF EOV PENDING\n         B     CONTROL            POSITION PAST TAPEMARK AND GOTO EODS\nENDVOLVR CLI   VERVOL,C'H'        NEED TO CHECK FOR PROTECTION? -ARB82-\n         BNE   CONTROL            NO, SKIP TO NEXT FILE         -ARB82-\nLOCHDR   BAL   R5,READER          YES, GET NEXT RECORD          -ARB82-\n         C     R7,=F'80'          80 BYTE BLOCK?                -ARB82-\n         BL    NOHDR1             NO, NOT A LABEL               -ARB82-\n         B     CHKHDR1            YES (OR MORE), SEE IF HDR1    -ARB82-\nSKIPTMPR DS    0H                 SKIPTM ROUTINE. ENTERED ONCE TO      *\n                                  POSITION FOR LABEL PARM, AGAIN FOR   *\n                                  SKIPTM PROCESSING.            -ARB79-\n         SR    R3,R3              CLEAR R3 TILL WE GET A VTOC     -CWB-\n*                                      BLOCK ENTRY.               -CWB-\n         CLC   CTPMKNO,SKIPFLNO   TAPEMARKS SKIPPED YET?        -ARB79-\n         BL    SKIPTMEV           BRANCH IF SKIPPING ANOTHER TAPEMARK\nTMDONE   XI    SKIPFLG,X'80'      REVERSE POSITIONING FLAG      -ARB79-\n         BNZ   SKIPEOVP           DO SKIPEOV AFTER LABEL PARM   -ARB79-\n         MVI   SKIPFLG,X'FF'      INDICATE THRU ALL SKIPPING    -ARB79-\n         L     R2,CTPMKNO         CONVERT STOPTM VALUE          -ARB79-\n         A     R2,MAXTMNO         TO MAXTM VALUE (I.E., FINAL   -ARB79-\n         ST    R2,MAXTMNO         TAPE MARK NUMBER)             -ARB79-\n         MVC   SKIPTMNO,CTPMKNO   SAVE NUMBER TM'S SKIPPED      -ARB79-\n         SR    R8,R8              CLEAR CTR FOR TOTAL BYTES ON TAPE\n         ST    R8,BLKCNT          (RE)-ZERO BLKCNT\n         OI    WRTFLG,X'02'       OR IN  'ALL TM & EOV SKIPPING DONE'\n         SR    R3,R3              CLEAR R3 TILL WE GET A VTOC     -CWB-\n*                                      BLOCK ENTRY.               -CWB-\nPROCESS  DS    0H                 TOP OF OUTER MAIN LOOP\n         SR    R4,R4              ZERO BLK COUNTER\n         ST    R4,MAX             RESET MAX BLKSIZE WATCHER\n         MVC   MIN,=F'32767'      RESET MIN BLKSIZE WATCHER\n         MVC   PREVLAB,LABELID    SAVE PREV LABEL INDICATION    -ARB82-\n         MVC   LABELID,=C'NN'     ASSUME THIS IS NO LABEL       -ARB82-\n         MVI   GOODLAB,C'N'       ASSUME THIS FILE NOT LABELS   -ARB82-\n         BAL   R10,READIN         ESTABLISH LOOP RETURN POINT   -ARB82-\nNEXTIN   DS    0H                 TOP OF MAIN INNER LOOP        -ARB79-\n         CLI   SUMFLG,C'N'        NOSUM OPERATION?              -ARB82-\n         BNE   YESSUM             YES, READ FOR SUMMARY         -ARB82-\n         CLI   VERVOL,C'H'        NO, NEED TO VERIFY HEADER?    -ARB82-\n         BNE   OTHRCHKS           NO, CHECK FOR LIST            -ARB82-\n         B     READIN             YES, READ FOR HEADER          -ARB82-\nYESSUM   CLI   LABELIKE,C'Y'      ARE WE READING LABELS?        -ARB82-\n         BNE   OTHRCHKS           NO, SEE IF LIST OR COUNT      -ARB82-\nREADIN   BAL   R5,READON     READ BLK, CALC LENGTH, MIN/MAX     -ARB82-\n         C     R7,=F'80'          SEE IF BLKSIZE=80 (LIKE ALL LABELS)\n         BL    NOLABEL            BIF BLKLNGTH LT 80 (I.E., IT'S NOT A *\n                                                    LABEL).     -ARB79-\n         CLI   VERVOL,C'Y'        VOLUME VERIFY TIME?           -ARB79-\n         BE    CHKVOL1            YES, CHECK FOR VOL1           -ARB79-\n         CLI   VERVOL,C'H'        HEADER VERIFY TIME?           -ARB79-\n         BE    CHKHDR1            YES, DO IT                    -ARB79-\nNOHDRP   CLI   ASCIIN,C'Y'        ASCII INPUT?                  -ARB79-\n         BE    LONGCK             YES, LONG LABELS POSSIBLE     -ARB79-\n         C     R7,=F'80'          NO, LABELS MUST BE 80         -ARB79-\n         BNE   NOLABEL                                          -ARB79-\nLONGCK   C     R4,=F'1'           SEE IF THIS IS THE 1ST BLK AFTER A   *\n                                  TAPEMARK OR THE LOAD POINT.   -ARB79-\n         BNE   *+18               BIF IT ISN'T THE FIRST\n         CLC   RECBUF(4),=C'EOV1'\n         BNE   *+8\n         OI    EOV1FLG,X'01'      INDICATE EOV1 TYPE OF EOV PENDING\n         CLI   SUMFLG,C'N'        NOSUM OPTION?                 -ARB82-\n         BE    TRYLIST            YES, SKIP LABEL CHECKS        -ARB82-\n         B     CHKLABEL           GO SEE IF WE HAVE A LABEL     -ARB79-\nNOLABEL  CLI   VERVOL,C'Y'        FIRST RECORD EVER READ?       -ARB79-\n         BE    NOVOL1             NO, LABEL NOT FOUND           -ARB79-\n         MVI   VERVOL,C'N'        VOLUME VERIFICATION NOW DONE  -ARB79-\n         CLI   GOODLAB,C'N'       MIGHT THIS FILE BE LABELS?    -ARB82-\n         BE    TRYLIST            NO, DON'T INDICATE ERROR      -ARB82-\n         MVI   PHFLSTAT+#DATA,X'FF'    NO, SHOW DATA IN LABELS  -ARB82-\nTRYLIST  C     R4,LISTNO                                        -ARB79-\n         BH    PRECOUNT           IF LIST NUMBER EXCEEDED       -ARB82-\n         BAL   R10,LISTER         BRANCH TO LIST BLOCK          -ARB82-\nOTHRCHKS BALR  R10,0              TOP OF LIST LOOP              -ARB82-\n         C     R4,LISTNO                                        -ARB79-\n         BNL   CHKCNT             BRANCH IF EVERYTHING ALREADY LISTED\n         BAL   R5,READON\nLISTER   CVD   R4,BADLNGTH                                      -ARB79-\n         MVC   BLOCKNO+5(4),=X'40202120'                        -ARB79-\n         ED    BLOCKNO+5(4),BADLNGTH+6 PUT BLK NO IN LIST       -ARB79-\n         BAL   R5,LISTBLK                                       -ARB79-\nPROCESS3 CLI   WRTFLG,X'03'       NEED TO DO OUTPUT?            -ARB82-\n         BNER  R10                NO.                           -ARB82-\nCOPYIT   CLI   ASCIOUT,C'Y'       TRANSLATE OUTPUT TO ASCII?    -ARB82-\n         BNE   NOUTRAN                                          -ARB79-\n         CLI   ASCIIN,C'Y'        WAS IT ORIGINALLY ASCII?      -ARB82-\n         BNE   OUTRAN             NO, TRANSLATE FROM EBCDIC     -ARB82-\n         MVC   RECBUF(120),ASCBUF YES, RESTORE ORIGINAL FORM    -ARB82-\n         B     NOUTRAN                                          -ARB82-\nOUTRAN   XLATE RECBUF,(R7),TO=A   YES, DO SO                    -ARB82-\nNOUTRAN  LA    R1,=AL3(WRTCMND)                                 -ARB79-\n         LA    R2,OUTPUT                                        -ARB79-\n         ST    R4,SVR4            SAVE R4 (CURRENT FILE BLKCNT) -ARB84-\n         OI    OUTPUT+DCBOFLGS,X'80'   SET DCB OUTPUT FLAG      -ARB79-\n         BAL   R4,EXECEXCP                                      -ARB79-\n         L     R4,SVR4            RESTORE R4                    -ARB84-\n         BR    R10                END OF VARIOUS INPUT LOOPS    -ARB82-\nPRECOUNT BAL   R10,PROCESS3       PROCESS THIS RECORD, ONLY            *\n                                  COUNT THEREAFTER              -ARB82-\nCHKCNT   CLI   COUNTFLG,C'N'\n         BE    CONTROL\n         BALR  R10,0              ESTABLISH COUNT LOOP TOP      -ARB82-\n         BAL   R5,READER          TOP    OF MAIN COUNTBLK OPTION LOOP\n         B     PROCESS3           SEE IF NEEDS TO BE WRITTEN    -ARB82-\nCONTROL  CLI   VERVOL,C'Y'        VOLUME VERIFICATION?          -ARB79-\n         BE    NOVOL1             YES, NOTE NO LABEL            -ARB79-\nDOCTL    LA    R2,INPUT           SKIP JUST PAST NEXT TAPEMARK  -ARB79-\n         LA    R1,=AL3(FSMCMND)   SKIP JUST PAST NEXT TAPEMARK\n         XC    SVR4,SVR4                                        -ARB84-\n         BAL   R4,EXECEXCP        SKIP JUST PAST NEXT TAPEMARK\n         SR    R4,R4              RE-ZERO CURRENT BLK COUNT\n         ST    R4,MAX             ZERO MAX TO INHIBIT BLK COUNT MSG\n         SR    R8,R8              IS THIS NECESSARY?\n         LR    R7,R8              MAKE LENGTH NEGATIVE FOR EODS -ARB82-\n         BCTR  R7,0                                             -ARB82-\n         B     EODS               SIMULATE TAPEMARK READ\nNOVOL1   MVI   VERVOL,C'N'                                      -ARB79-\n         MVC   VSNSAVE,DDVOL      SAVE VOLSER FOR VTOC          -ARB82-\n         TM    JFCLTSV,X'42'      SHOULD IT BE LABELLED?        -ARB79-\n         BZ    SCURNL             NO, MAKE NO COMMENT           -ARB82-\n         BAL   R2,PUTLINE         YES, GIVE WARNING             -ARB79-\n         MVC   MSGBUF(60),=C'0WARNING - TAPE SPECIFIED AS LABELED IN TH*\n               E JCL HAS NO LABEL'                              -ARB82-\n         TM    WRTFLG,X'01'       ARE WE COPYING?               -ARB82-\n         BZ    NASCWRN1           NO.                           -ARB82-\n         CLI   SVOUTFLG,C'N'      YES, IS IT UNLABEL?           -ARB82-\n         BE    SCURNL             YES, LET IT GO ON             -ARB82-\n         BAL   R2,PUTLINE         NO, DON'T ALLOW COPY          -ARB82-\n         MVC   MSGBUF(38),=C' COPY TERMINATED DUE TO LABEL MISMATCH'   *\n                                                                -ARB82-\n         B     EXITRC16                                         -ARB82-\nSCURNL   CLI   COUNTFLG,C'Y'      COUNT OPTION?                 -ARB82-\n         BE    SCURIN             YES, VERIFY SECURITY          -ARB82-\n         OC    LISTNO,LISTNO      NO, LIST OPTION?              -ARB82-\n         BNZ   SCURIN             YES, VERIFY SECURITY          -ARB82-\nNLVER    TM    WRTFLG,X'01'       COPY OPERATION?               -ARB79-\n         BZ    NASCWRN1           NO, NO NEED FOR WARNING       -ARB79-\nASCK1    CLC   ASCIIN,ASCIOUT     CHANGE IN CODE OCCURING?      -ARB82-\n         BE    NASCWRN1           NO.                           -ARB79-\n         BAL   R2,PUTLINE         YES, SEND WARNING             -ARB79-\n         MVC   MSGBUF(L'ASCWARN),ASCWARN                        -ARB79-\nNASCWRN1 CLI   COUNTFLG,C' '      COUNT OPTION SET YET?         -ARB82-\n         BNE   COUNTSET           YES.                          -ARB82-\n         MVI   COUNTFLG,C'Y'      NO, DEFAULT IS COUNT FOR NL   -ARB82-\nCOUNTSET MVC   SUPOUT,MAPFLG      SUPPRESS LISTING IF MAPONLY   -ARB82-\n         LTR   R7,R7              IS LENGTH<0?                  -ARB82-\n         BM    EONLVER            IF SO, RETURN TO EODS         -ARB82-\n         TM    WRTFLG,X'02'       JUST SKIPPING NOW?            -ARB82-\n         BZ    DOCTL              YES, BACK TO CONTROL RTN      -ARB79-\n         B     TRYLIST                                          -ARB79-\n         SPACE 5\nREADON   DS    0H\n         MVC   RECBUF,BLANKBUF    CLEAR FIRST PART OF BUFFER FAST\nREADER   CLI   MARK,X'00'         JUST AFTER A TAPE MARK?       -ARB79-\n         BE    NO7TRACK                                         -ARB79-\n         TM    JFCLTSV,X'42'      YES, IS INPUT LABELLED?       -ARB79-\n         BZ    NO7TRACK                                         -ARB79-\n         ZAP   FILENO(4),MARKNO   SEE IF READING LABEL OR DATA  -ARB79-\n         DP    FILENO(4),=P'3'                                  -ARB79-\n         TM    CTRACKS,X'10'      IS INPUT | OUTPUT 7 TRACK?    -ARB79-\n         BZ    NO7TRACK                                         -ARB79-\n         CP    FILENO+3(1),=P'1'  IS IT DATA?                   -ARB79-\n         BE    USERTCH            YES, SER USER TRTCH           -ARB79-\n         LA    R2,X'2B'           LABELS, SET TRTCH=ET          -ARB79-\n         LR    R6,R2                                            -ARB79-\n         B     SETRTCH                                          -ARB79-\nUSERTCH  IC    R2,ITRTCH          RESET TRTCH FOR LABEL         -ARB79-\n         IC    R6,OTRTCH                                        -ARB79-\nSETRTCH  MODESET KEY=ZERO         IN ORDER TO STORE INTO DEB           *\n                                  (REQUIRES AUTHORIZATION)      -ARB79-\n         TM    ITRACKS,X'10'      IS INPUT 7 TRACK?             -ARB79-\n         BZ    NO7IN                                            -ARB79-\n         O     R2,DCBDEN+INPUT-3  YES, DETERMINE SETMODE OP     -ARB79-\n         L     R15,DCBDEBAD+INPUT                               -ARB79-\n         STC   R2,DEBSDVM(R15)    AND STORE INTO DEB            -ARB79-\nNO7IN    TM    OTRACKS,X'10'      7 TRACK SL OUTPUT?            -ARB79-\n         BZ    NO7OUT                                           -ARB79-\n         TM    OUTLTYP,X'02'                                    -ARB79-\n         BZ    NO7OUT                                           -ARB79-\n         O     R6,DCBDEN+OUTPUT-3 CREATE SET MODE OP CODE       -ARB79-\n         L     R15,DCBDEBAD+OUTPUT                              -ARB79-\n         STC   R6,DEBSDVM(R15)    AND STORE INTO DEB            -ARB79-\nNO7OUT   MODESET KEY=NZERO        GIVE UP PRIVILEGES            -ARB79-\nNO7TRACK XC    TAPE(4),TAPE       CLEAR ECB\n         MVI   ERRLAST,0          RESET RECENT ERROR FLAG\n         NI    WRTFLG,X'03'       RESET DON'T COPY FLAG         -ARB82-\n         ST    R4,BLKNO           STORE BLOCK NUMBER FOR SYNAD  -ARB82-\n         LA    R2,RECBUF\n         LA    R7,1               SET UP NEGATIVE LENGTH        -ARB82-\n         LNR   R7,R7              FOR EODAD                     -ARB82-\n         READ  TAPE,SF,INPUT,(R2),'S' READ A BLK OR TAPEMARK (WE HOPE)\n         CHECK TAPE               EODAD=EODS\n         TM    OPTNO+1,X'01'      *** DEBUG OPTION FOR DISK TAPE SIM **\n         BZ    *+14               BIF TAPE SIM OPTION NOT SPECIFIED\n         CLC   RECBUF(8),=C'TAPEMARK'  SEE IF TAPEMARK TO BE SIMULATED\n         BE    EODS               BIF YES, SIMULATE A TAPEMARK\n         MVI   MARK,X'00'         EODS SETS TO X'FF' WHEN TAPEMARK READ\n         NI    EOV1FLG,X'FD'      TURN OFF INITT EOV FLAG       -ARB82-\n         LA    R4,1(R4)           COUNT THE BLK JUST READ FOR DATASET\n         OC    PHFLSTAT+#IO(1),ERRLAST  NOTE IF IOERR OCCURRED  -ARB82-\n         L     R6,TAPE+16         GET PTR TO IOB\n         LH    R7,INPUT+DCBBLKSI\n         SH    R7,14(R6)\n         BAL   R2,LENCK           CHECK FOR LENGTH ATROCITY     -ARB79-\n         L     R1,FILEBYTS        ADD BLOCK LENGTH TO TOTAL       -CWB-\n         AR    R1,R7                   BYTE COUNT FOR THIS        -CWB-\n         ST    R1,FILEBYTS             FILE.                      -CWB-\n         AR    R8,R7              COUNT ALL BYTES READ DURING RUN\n         C     R7,MAX             COMPARE CURRENT BLK'S SIZE WITH MAX\n         BNH   *+8                SKIP IF OLD MAX IS BIGGER\n         ST    R7,MAX             STORE NEW MAX BLK LENGTH\n         C     R7,MIN             COMPARE BLK'S SIZE WITH PREVIOUS MIN\n         BNL   *+8                SKIP IF OLD MIN IS SMALLER\n         ST    R7,MIN             STORE NEW MINIMUM BLOCK LENGTH\n         MVC   ASCBUF,RECBUF      COPY RECORD TO 2ND BUFFER     -ARB79-\n         CLI   ASCIIN,C'Y'        TRANSLATE FROM ASCII?         -ARB79-\n         BNE   NOINTRAN                                         -ARB79-\n         CLI   ASCIOUT,C'Y'       YES, COPYING TO ASCII?        -ARB82-\n         BNE   INTRAN             NO, TRANSLATE ENTIRE BLOCK    -ARB82-\n         CH    R7,=H'120'         LESS THAN 120 BYTES READ?     -ARB82-\n         BL    INTRAN             YES, JUST XLATE WHAT'S READ   -ARB82-\n         XLATE RECBUF,120,TO=E    YES, TRANSLATE PRINTING PART  -ARB82-\n         B     NOINTRAN                                         -ARB82-\nINTRAN   XLATE RECBUF,(R7),TO=E   MAKE WHOLE LINE EBCDIC        -ARB82-\nNOINTRAN CLI   WRTFLG,X'03'       SEE IF WILL BE WRITING        -ARB79-\n         BNER  R5                                               -ARB79-\n         STH   R7,WRTCMND+6       STORE BLK LENGTH IN WRITE CCW\n         BR    R5                 RETURN FROM READON SUBROUTINE\n         SPACE 5\nCHKVOL1  CLC   ASCBUF(4),ASCIVOL1 SEE IF ANS VOL LABEL          -ARB79-\n         BE    ANSVOL1                                          -ARB79-\n         C     R7,=F'80'          IS THIS RECORD LENGTH 80?     -ARB79-\n         BNE   NOVOL1             NO, NOT AN IBM LABEL          -ARB79-\n         CLC   ASCBUF(4),=C'VOL1' SEE IF IBM VOL LABEL          -ARB79-\n         BE    IBMVOL1                                          -ARB79-\n         B     NOVOL1             ELSE VOLUME  LABEL NOT FOUND  -ARB79-\n         SPACE\nCHKHDR1  CLC   RECBUF(4),=C'HDR1' IS THIS A HDR1 LABEL?         -ARB79-\n         BE    FIRSTHDR           YES, CHECK FOR PROTECTION     -ARB79-\n         MVC   SECDSN,BLANKBUF    START DSN AS BLANKS           -ARB82-\n         CLI   ASCIIN,C'Y'        NO, ANS TAPE?                 -ARB82-\n         BNE   NOHDR1             NO, MAKE SECURITY CHECK       -ARB82-\n         CLC   RECBUF(3),=C'UVL'  YES, USER VOLUME LABEL?       -ARB82-\n         BE    DEFERHDR           YES, HEADER MAY STILL APPEAR  -ARB82-\nNOHDR1   MVI   GOODLAB,C'N'       LABELS BAD IF HDR1 NOT FOUND  -ARB82-\n         MVI   PHFLSTAT+#LBSQ,X'FF'    SAY LABEL SEQUENCE ERR   -ARB82-\n         MVC   SECLABEL,VOLLAB    COPY LABEL TYPE FOR SCUR EXIT -ARB82-\n         MVC   VOLLAB,=C'BLP'     SET LABEL TYPE TO BLP         -ARB82-\n         B     SCURINB            GO MAKE SECURITY CHECK        -ARB82-\nHDRET    MVI   VERVOL,C'N'        VOLUME-START PROCESS DONE     -ARB82-\n         MVC   SUPOUT,MAPFLG      KILL LISTING IF MAPONLY       -ARB82-\n         LTR   R7,R7              REACHED END OF FILE?          -ARB82-\n         BM    EONLVER            YES, RETURN TO EODS           -ARB82-\nDEFERHDR TM    WRTFLG,X'02'       STILL SKIPPING?               -ARB82-\n         BNZ   NOHDRP             NO, RESUME NORMAL PROCESSING  -ARB82-\n         CLI   VERVOL,C'H'        STILL EXPECTING A HEADER?     -ARB82-\n         BE    LOCHDR             YES, KEEP LOOKING             -ARB82-\n         B     NOHDRS             NO, KEEP SKIPPING             -ARB82-\nCHKLABEL DS    0H\n         MVI   LABELIKE,C'Y'      ASSUME LABEL HERE             -ARB82-\n         CLC   RECBUF(4),=C'HDR1'\n         BE    HDR1\n         CLC   RECBUF(4),=C'EOF1'\n         BE    EOF1EOV1\n         CLC   RECBUF(4),=C'HDR2'\n         BE    HDR2\n         CLC   RECBUF(4),=C'EOF2'\n         BE    EOF2EOV2\n         CLC   RECBUF(4),=C'VOL1'\n         BE    VOL1\n         CLC   RECBUF(4),=C'EOV1'\n         BE    EOF1EOV1\n         CLC   RECBUF(4),=C'EOV2'\n         BE    EOF2EOV2\n         CLC   RECBUF(3),=C'UHL'  USER HEADER?                  -ARB82-\n         BE    USERLABL                                         -ARB82-\n         CLC   RECBUF(3),=C'UTL'  USER TRAILER?                 -ARB82-\n         BE    USERLABL                                         -ARB82-\n         CLI   ASCIIN,C'Y'        CHECK FOR ODD ASCII LABELS?   -ARB82-\n         BNE   UNLABLIK           NO, WE HAVE NO LABEL          -ARB82-\n         CLC   RECBUF(3),=C'EOF1' ASCII EOFX LABEL?             -ARB82-\n         BE    ANSXLAB                                          -ARB82-\n         CLC   RECBUF(3),=C'EOV1'                               -ARB82-\n         BE    ANSXLAB                                          -ARB82-\n         CLC   RECBUF(3),=C'HDR1'                               -ARB82-\n         BE    ANSXLAB                                          -ARB82-\n         CLC   RECBUF(3),=C'UVL'  ASCII USER VOL LABEL?         -ARB82-\n         BE    ANSUVL                                           -ARB82-\nUNLABLIK MVI   LABELIKE,C'N'      RESET LABEL INDICATION        -ARB82-\n         B     NOLABEL            IT'S NOT A LABEL AFTER ALL\n         SPACE\nPROCESS2 CLI   GOODLAB,C'Y'       IN A GOOD LABEL FILE?         -ARB82-\n         BE    LABSIZCK           YES, PROCEED                  -ARB82-\n         OI    PHFLSTAT+#LBSQ,X'FF'    NO, NOTE FOR VTOC        -ARB82-\n         B     PROCESS3           AND CONTINUE                  -ARB82-\nLABSIZCK CLI   WRTFLG,X'03'       COPYING THIS LABEL?           -ARB82-\n         BNE   PROCESS3           NO.                           -ARB82-\n         C     R7,=F'80'          YES, OVERSIZE LABEL?          -ARB82-\n         BE    PROCESS3           NO.                           -ARB82-\n         CLC   ASCIIN,ASCIOUT     YES, CHANGING TO EBCDIC?      -ARB82-\n         BE    PROCESS3           NO, ALL IS WELL               -ARB82-\n         MVC   WRTCMND+6(2),=H'80'     YES, TRUNCATE TO 80      -ARB82-\n         MVI   PHFLSTAT+#TRNC,X'FF'    NOTE TRUNCATION IN VTOC  -ARB82-\n         B     PROCESS3           AND CONTINUE                  -ARB82-\n         SPACE\nFIRSTHDR MVC   SECDSN,RECBUF+4    COPY DSNAME FROM HDR1         -ARB82-\n         CLI   RECBUF+53,C'1'     IS DATASET1 READ PROTECTED?   -ARB82-\n         BE    RQRINPW            YES.                          -ARB79-\n         CLI   ASCIIN,C'Y'        IS INPUT ASCII?               -ARB79-\n         BNE   SCURIN             NO, CHECK LOCAL SECURITY      -ARB82-\n         CLI   RECBUF+53,C' '     YES, CHECK FOR VALID ACCESSIBILITY   *\n                                                                -ARB79-\n         BE    SCURIN             OK IF UNPROTECTED             -ARB79-\n         CLI   RECBUF+53,C'3'                                   -ARB79-\n         BE    SCURIN             OK IF WRITE-PROTECTED         -ARB82-\n         BAL   R2,PUTLINE                                       -ARB79-\n         MVC   MSGBUF(64),=C'0PROTECTED ASCII TAPE FILE MAY NOT BE READ*\n                - TAPESCAN TERMINATED'                          -ARB79-\n         B     EXITRC16                                         -ARB79-\nRQRINPW  CLI   COUNTFLG,C'Y'      COUNT OPTION?                 -ARB79-\n         BE    PWSETUP            YES, DATA MUST BE READ        -ARB79-\n         OC    LISTNO,LISTNO      LIST OPTION?                  -ARB79-\n         BZ    SCURIN             NO, IGNORE PASSWORD           -ARB82-\nPWSETUP  L     R5,16              FIND JOB & STEP NAME          -ARB79-\n         L     R5,0(,R5)          FOR CONSOLE PASSWORD WTOR     -ARB79-\n         L     R5,4(,R5)                                        -ARB79-\n         L     R5,TCBTIO(R5)                                    -ARB79-\n         MVC   SMSGJOB,TIOCNJOB(R5)    PUT JOB & STEP NAME IN   -ARB79-\n         MVC   SMSGSTEP,TIOCSTEP(R5)                            -ARB79-\n         MVC   SMSGDD,=CL8'INPUT' INSERT DDNAME                 -ARB79-\n         MVI   PSWDSW,0           INDICATE FIRST TRY            -ARB79-\nASKINPW  LA    R2,SMSG                                          -ARB79-\n         BAL   R5,SYSWTOR         ASK OPERATOR FOR PASSWORD     -ARB79-\n         OC    PSWDREPL,BLANKBUF  UPPER CASE REPLY              -ARB79-\n         LA    R2,JFCBIN                                        -ARB79-\n         BAL   R5,CHKPASS         SEE IF PASSWORD GOOD FOR DSN  -ARB79-\n         LTR   R15,R15            PASSWORD FOUND?               -ARB79-\n         BZ    SCURIN             YES, MAKE LOCAL CHECK         -ARB82-\n         CLI   PSWDSW,0           WAS THAT THE FIRST TRY        -ARB79-\n         BNE   BADINPW            NO, NO MORE ALLOWED           -ARB79-\n         MVI   PSWDSW,X'FF'       YES, TRY ONCE MORE            -ARB79-\n         B     ASKINPW                                          -ARB79-\nSCURIN   MVC   SECLABEL,VOLLAB    STORE VOL1 OR JCL LABEL       -ARB82-\nSCURINB  MVI   SECIOTYP,C'I'      NOTE INPUT                    -ARB82-\n         MVC   SECVOL,DDVOL       COPY OVER VOLSER              -ARB82-\n         MVC   SECDCB,=A(INPUT)   STORE INPUT DCB ADDR          -ARB82-\n         BAL   R14,SCUREXIT       ASK INSTALLATION FOR OK       -ARB82-\n         LTR   R15,R15            WELL?                         -ARB82-\n         BZ    SCURRET            OK, CONTINUE                  -ARB82-\n         MVC   MSGBUF(42),=C'0YOU ARE UNAUTHORIZED TO READ THIS TAPE - *\n               '                  START UNAUTH MSGS             -ARB82-\n         B     UNAUTH             GO COMPLETE IT                -ARB82-\nBADINPW  MVC   MSGBUF(42),=C'0INPUT PASSWORD NOT CORRECTLY SPECIFIED - *\n               '                  START OF SECURITY MSG         -ARB82-\nUNAUTH   MVC   MSGBUF+42(91),BLANKBUF  CLEAR REST OF PRINT BUF  -ARB83-\n         TM    WRTFLG,X'01'       COPY REQUESTED?               -ARB83-\n         BZ    FORBIDRD           NO, WE CAN PROCEED            -ARB79-\n         BAL   R2,PUTLINE2        YES, CANNOT BE DONE           -ARB82-\n         MVC   MSGBUF+42(19),=C'TAPESCAN TERMINATED'            -ARB82-\n         B     EXITRC16                                         -ARB79-\nFORBIDRD BAL   R2,PUTLINE2        ANNOUNCE RESTRICTIONS         -ARB79-\n         MVC   MSGBUF+42(29),=C'NOLIST AND NOCOUNT ARE FORCED'  -ARB82-\n         XC    LISTNO,LISTNO      TURN OFF LIST OPTION          -ARB79-\n         MVI   COUNTFLG,C'N'      TURN OFF COUNT OPTION         -ARB79-\nSCURRET  CLI   VOLLAB,C'N'        INPUT VOL UNLABELLED?         -ARB82-\n         BE    NLVER              YES, RESUME NL PROCESS        -ARB82-\n         B     HDRET              NO, RESUME HDR PROCESS        -ARB82-\n         SPACE\nHDR1     LA    R0,7               PREPARE TO RESERVE 7  LINES   -ARB79-\n         BAL   R2,PAGECHK         RESERVE THE 7  LINES\n         MVC   MSGBUF+1(132),BLANKBUF  CLEAR PRINT BUFFER       -ARB82-\n         CLC   POSTHEAD,=H'3'     TOO SOON FOR NEW HEADER?      -ARB82-\n         BL    HDROOP             YES.                          -ARB82-\n         BH    HREAL              NO, THIS ONE IS GOOD          -ARB82-\n         MVC   VOLLAB,=C'BLP'     YES, A TRAILER WAS DROPPED    -ARB82-\nHREAL    LR    R2,R4              COPY BLOCK NO OF FILE         -ARB82-\n         SH    R2,VOL1NO          COMPENSATE FOR PRIOR VOL1     -ARB82-\n         CH    R2,=H'1'           FIRST RECORD OF FILE?         -ARB82-\n         BNE   HDROOP             NO, HDR OUT OF PLACE          -ARB82-\n         MVC   POSTHEAD,=H'1'     NO, INDICATE HEADER FOUND     -ARB80-\n         MVI   GOODLAB,C'Y'       SET GOOD LABEL FLAG           -ARB80-\n         MVC   LABELID,=C'HH'     SHOW HEADER FILE              -ARB82-\n         AP    HEADNO,=P'1'       INCREASE HEADER COUNT         -ARB80-\n         MVC   DATASEQ,RECBUF+31  SAVE HEADER SEQ NO            -ARB79-\n         SR    R2,R2              CLEAR FOR COMPARISON          -ARB82-\n         C     R2,CTPMKNO         SEE IF T/MS ALREADY READ = 0  -ARB82-\n         BNE   NOTHREAL           BIF NOT BEFORE FIRST TAPEMARK -ARB82-\n         MVI   MSGBUF,C'0'                                      -ARB82-\n         MVC   MSGBUF+1(75),MSGBUF   CLEAR TO 76CL1'0'          -ARB82-\n         CLC   RECBUF+4(76),MSGBUF   FOR COMPARISON             -ARB82-\n         BNE   NOTHREAL            SKIP IF THEY ARE UNEQUAL     -ARB82-\n         OI    EOV1FLG,X'02'      ELSE SET IEHINITT EOV PENDING -ARB82-\n         B     NOTHREAL                                         -ARB82-\nHDROOP   CLI   GOODLAB,C'Y'       LABELS SUPPOSED TO BE GOOD?   -ARB82-\n         BNE   NOTHREAL           NO, PROBLEM ALREADY FOUND     -ARB82-\n         MVI   GOODLAB,C'?'       YES, NOTE TURNED BAD          -ARB82-\nNOTHREAL MVC   MSGBUF+1(132),BLANKBUF  RECLEAR MSG BUF          -ARB82-\n         CLI   WRTFLG,X'03'       COPYING?                      -ARB80-\n         BNE   HDR1SUM            BR IF NOT                     -ARB79-\n         TM    OUTLTYP,X'42'      LABELED OUTPUT TAPE?          -ARB79-\n         BZ    HDR1SUM            SKIP FILESEQ STUFF IF NOT     -ARB79-\n         CLC   POSTHEAD,=H'1'     REAL HEADER?                  -ARB80-\n         BNE   HDR1SUM            NO, DON'T CHANGE SEQ.         -ARB80-\n         CLI   FIRSTSEQ,C'N'      FIRST HDR FOUND?              -ARB79-\n         BNE   NOTH1                                            -ARB79-\n         PACK  FIRSTSEQ,DATASEQ   YES, SAVE SEQ NO AGAIN        -ARB79-\nNOTH1    CLI   HDRFOUND,C'Y'      HAS OUTPUT SEQ BEEN FIXED?    -ARB79-\n         BE    HDR1SUM            YES, DON'T DO IT AGAIN        -ARB79-\n         AP    HEADNO(3),FIRSTSEQ COMPUTE OUTPUT LABEL NO       -ARB80-\n         MVI   HDRFOUND,C'Y'                                    -ARB79-\nHDR1SUM  CLI   GOODLAB,C'Y'       IS THIS REALLY A LABEL FILE?  -ARB82-\n         BNE   NOH1VTOC           NO, LEAVE OUT OF VTOC         -ARB82-\n         CLI   SUMFLG,C'N'        NOSUM OPTION?                 -ARB82-\n         BE    LBL1OUT            YES, SKIP VTOC                -ARB82-\n         BAL   R2,GETVTOC         GET A NEW VTOC ENTRY          -ARB82-\n         USING VTOC,R3            R3 WILL ALWAYS POINT TO ENTRY   -CWB-\n         MVI   PHFLSTAT+#NTRL,X'FF'     SET TRAILER NOT FOUND   -ARB82-\n         MVC   VTOCLTYP,VOLLAB    SAVE LABEL TYPE FOR VTOC      -ARB82-\n         CLC   VOLLAB(2),=C'NL'   PREVIOUS FILES NL?            -ARB82-\n         BNE   SLABOK             NO.                           -ARB82-\n         MVC   VOLLAB(3),=C'BLP'  YES, SWITCH TO BLP            -ARB82-\n         MVI   PHFLSTAT+#BLP,X'FF'     FORCE NOTE IN VTOC       -ARB82-\nSLABOK   MVC   VTOCSEQN,DATASEQ   COPY SEQ # FROM LABEL         -ARB82-\n         MVC   VTOCRECF(2),=C'??' NOTE RECFM/LRECL/BLKSIZE      -ARB82-\n         MVC   VTOCLREC,=C'   ??' UNKNOWN IN CASE HDR2 IS       -ARB82-\n         MVC   VTOCBLKS,=C'   ??' MISSING                       -ARB82-\nNOH1VTOC CLI   SUMFLG,C'F'        FULL SUMMARY?                 -ARB79-\n         BE    HDR1LIST           YES, PRINT THE LABEL          -ARB79-\n         MVC   MSGBUF+6(3),LABTYPE                              -ARB79-\n         MVC   MSGBUF+10(12),=C'HEADER LABEL'                   -ARB79-\n         MVI   MSGBUF+23,C'1'     IDENTIFY LABEL NO             -ARB79-\n         MVC   MSGBUF+25(11),=C'(FILE NNNN)'                    -ARB79-\n         MVC   MSGBUF+31(4),RECBUF+31  ADD THE FILE SEQ NO      -ARB79-\n         LA    R2,*+2                                           -ARB79-\n         B     PUTLINE3           PRINT LABEL ID LINE           -ARB79-\n         MVI   MSGBUF,C' '        RESET CARRIAGE CNTL           -ARB79-\n         B     LBL1               SKIP FULLSUM OUTPUT           -ARB79-\nHDR1LIST MVC   MSGBUF+4(16),=C' HEADER LABEL  :'                -ARB79-\n         MVC   MSGBUF+1(3),LABTYPE     STORE LABEL TYPE         -ARB79-\n         MVI   MSGBUF+18,C'1'                                   -ARB79-\n         MVC   MSGBUF+23(90),RECBUF    PUT LABEL INTO BUFFER    -ARB82-\n         MVI   MSGBUF,C'0'        CCTRL FOR 1 BLANK LINE, THEN  -ARB79-\n         MVC   MSGBUF+116(9),=C'FILE SEQ='                      -ARB82-\n         MVC   MSGBUF+125(4),RECBUF+31 ADD FILE SEQ TO LINE     -ARB82-\n         BAL   R2,PUTLINE3     PRINT\n         DC    C'HDR111'\n         MVI   HEXOFF+1,22        SET OFFSET FOR HEX            -ARB79-\n         MVI   LINESIZE+3,89      PRINT ONLY 90 HEX CHARS       -ARB79-\n         BAL   R5,HEXON           PRINT HEX IF OPTION IS YES\n         MVI   MSGBUF,C'0'                                      -ARB79-\nLBL1     C     R7,=F'80'          IS LABEL NORMAL SIZE?         -ARB79-\n         BE    LBL180             YES, NO COMMENT               -ARB79-\n         BAL   R2,PUTLINE         NO, MAKE NOTE                 -ARB79-\n         MVC   MSGBUF(L'LABLSIZE),LABLSIZE                      -ARB79-\nLBL180   MVC   MSGBUF+1(132),BLANKBUF                           -ARB79-\n         MVC   MSGBUF+11(7),=C'DSNAME='\n         MVC   MSGBUF+18(17),RECBUF+4\n*        CLI   RECBUF+4,C'T'                                    -DEBUG-\n*        BNE   *+8                                              -DEBUG-\n*        MVI   PHFLSTAT+#DBUG,X'FF'                             -DEBUG-\n         CLI   RECBUF,C'H'        IS THIS A TRAILER?            -ARB79-\n         BE    VDSN               NO, SAVE DSN IN VTOC          -ARB82-\n         CLI   HDRMISS,C'Y'       YES, HEADER MISSING?          -ARB82-\n         BNE   LBL1PROT           NO, SKIP DSN STORE            -ARB82-\nVDSN     CLI   GOODLAB,C'Y'       TRUSTWORTHY LABEL?            -ARB82-\n         BNE   NOVDSN             IF NOT, DON'T SAVE DSN        -ARB82-\n         MVC   VTOCDSN,RECBUF+4   SAVE DSN FOR VTOC.              -CWB-\n         TM    EOV1FLG,X'02'      IEHINITT LABEL ACTIVE?        -ARB82-\n         BZ    NOVDSN             NO.                           -ARB82-\n         MVC   VTOCDSN,=CL17'  *IEHINITT*' YES, SAY SO          -ARB82-\nNOVDSN   CLI   RECBUF,C'H'        WORKING FOR TRAILER?          -ARB82-\n         BNE   LBL1PROT           YES, SKIP CREATE DATE         -ARB82-\n         MVC   MSGBUF+72(14),=C'CREATION DATE='                 -ARB82-\n         LA    R1,RECBUF+42        SET UP PARMLST               -ARB79-\n         ST    R1,WORK             FIRST PARM IS FROM FIELD  *FD78.130\n         L     R1,AMSGBP86         AGAIN FOR SECOND PARM        -ARB79-\n         ST    R1,WORK+4           SECOND ONE IS \"TO\" FIELD  *FD78.130\n         MVI   WORK+4,X'80'       SET VL BIT                    -ARB82-\n         MVC   0(6,R1),=C'000000'  ZERO OUT THE \"TO\" FIELD   *FD78.130\n         LA    R1,WORK             SET PARMLST PTR           *FD78.130\n         BAL   R14,JULDATE        CONVERT DATE TO JULIAN        -ARB82-\n         CLI   GOODLAB,C'Y'       IS THIS A TRUE LABEL?         -ARB82-\n         BNE   *+10               IF NOT, SKIP SAVE             -ARB82-\n         MVC   VTOCCREA,MSGBUF+86 SAVE DATE FOR VTOC.           -ARB82-\nLBL1PROT CLI   RECBUF+54,C'1'     PROTECTED DS?                 -ARB82-\n         BE    RWPROT             YES.                          -ARB82-\n         CLI   RECBUF+54,C'3'                                   -ARB82-\n         BNE   LBL1XPDT           NO, DON'T MENTION IT          -ARB82-\n         MVC   MSGBUF+111(5),=C'WRITE' YES, WRITE PROTECTED     -ARB82-\n         B     PROTMSG                                          -ARB82-\nRWPROT   MVC   MSGBUF+111(3),=C'R/W'                            -ARB82-\nPROTMSG  MVC   MSGBUF+100(11),=C'PROTECTION='                   -ARB82-\n         CLI   RECBUF,C'H'        HAVE WE A HEADER?             -ARB82-\n         BE    LBL1XPDT           YES.                          -ARB82-\n         MVC   MSGBUF+72(16),MSGBUF+100     NO, COMPACT LINE    -ARB82-\n         MVC   MSGBUF+100(16),BLANKBUF                          -ARB82-\nLBL1XPDT MVC   MSGBUF+42(20),=C'EXPIRATION DATE=NONE'           -ARB79-\n         CLC   RECBUF+48(5),=C'000000' IS THERE AN EXPDT?       -ARB79-\n         BE    NOEXPDT            NO, LEAVE \"NONE\"              -ARB79-\n         LA    R1,RECBUF+48       SET UP TO CONVERT TO GREG     -ARB79-\n         ST    R1,WORK                                          -ARB79-\n         L     R1,AMSGBP58                                      -ARB79-\n         ST    R1,WORK+4                                        -ARB79-\n         MVI   WORK+4,X'80'       SET VL BIT                    -ARB82-\n         MVC   0(6,R1),=C'000000'                               -ARB79-\n         LA    R1,WORK                                          -ARB79-\n         BAL   R14,JULDATE        PUT EXPDT IN HUMAN FORM       -ARB82-\nNOEXPDT  BAL   R2,PUTLINE3                                      -ARB79-\n         DC    CL6'LBL111'\n         CLI   GOODLAB,C'Y'       IS THIS A TRUE LABEL?         -ARB82-\n         BNE   *+10               IF NOT, SKIP SAVE.            -ARB82-\n         MVC   VTOCEXPR,MSGBUF+58 SAVE EXP DATE FOR VTOC.       -ARB82-\n         CLI   SUMFLG,C'F'        FULLSUM OPTION?               -ARB79-\n         BE    DOBLKCNT           YES, OUTPUT BLKCNT            -ARB79-\n         CLI   RECBUF,C'H'        NO, PROCESSING TRAILERS?      -ARB82-\n         BNE   DOBLKCNT           YES, OUTPUT BLKCNT            -ARB82-\nLBL1OUT  CLI   WRTFLG,X'03'       ARE WE COPYING?               -ARB79-\n         BNE   LBL1SUMD                                         -ARB82-\n         TM    OUTLTYP,X'42'      YES, LABELLED OUTPUT?         -ARB79-\n         BZ    LBL1SUMD                                         -ARB82-\n         CLI   GOODLAB,C'Y'       IS THIS REALLY A LABEL?       -ARB80-\n         BNE   LBL1SUMD           NO, DON'T MODIFY IT           -ARB82-\n         UNPK  RECBUF+31(4),HEADNO(3)  PUT TRUE SEQ INTO LABEL  -ARB80-\n         OI    RECBUF+34,C'0'                                   -ARB79-\n         CLC   ASCIIN(2),=C'YY'   ASCII->ASCII COPY?            -ARB82-\n         BNE   NOSEQTRN           NO.                           -ARB82-\n         MVC   ASCBUF+31(4),=X'3F3F3F3F'    YES,                -ARB82-\n         NC    ASCBUF+31(4),RECBUF+31  CHANGE ASCII LABEL COPY  -ARB82-\nNOSEQTRN MVC   MSGBUF+1(132),BLANKBUF                           -ARB82-\n         MVC   MSGBUF+6(19),=C'OUTPUT FILE NUMBER '             -ARB80-\n         MVC   MSGBUF+25(4),RECBUF+31  PUT NEW FILE NO IN MSG   -ARB80-\n         LA    R2,*+2                                           -ARB80-\n         B     PUTLINE3           INFORM OF OUTPUT FILE NO      -ARB80-\n         CLC   VOLLAB,=C'BLP'     HAVE LABELS GONE BAD?         -ARB82-\n         BE    NOOUSEQ            YES, DON'T STORE OUTPUT SEQ   -ARB82-\n         MVC   VTOCOUSQ,MSGBUF+25 COPY OUTPUT FILE SEQ FOR VTOC -ARB82-\nNOOUSEQ  CLC   ASCIIN,ASCIOUT     ASCII TRANSLATION?            -ARB82-\n         BE    LBL1SUMD           NO.                           -ARB82-\n         TM    RECBUF+53,X'03'    YES, IS THIS FILE PROTECTED?  -ARB79-\n         BNZ   LBL1SUMD           YES, NO CONVERSION NEEDED     -ARB82-\n         XI    RECBUF+53,X'B0'    YES, SWITCH ' ' AND '0'       -ARB79-\nLBL1SUMD MVC   MSGBUF(1),SUMFLG   SAVE SIGN OF SUMMARY OUTPUT   -ARB82-\n         B     PROCESS2\nEOF1EOV1 DS    0H\n         CH    R4,=H'1'           FIRST BLOCK OF FILE?          -ARB82-\n         BNE   FALSEOF            NO, NOT REALLY A LABEL        -ARB82-\n         CLC   POSTHEAD,=H'3'     IS THIS TRAILER DATA?         -ARB82-\n         BL    FALSEOF            YES, SKIP SEQ CHECK           -ARB82-\n         MVI   HDRMISS,C'Y'       ASSUME UNMATCHED TRAILER      -ARB82-\n         BE    NORMLTRL           NO, NORMAL TRAILER LABEL      -ARB82-\n         CLC   POSTHEAD,=X'FFFE'  HEADER FOR THIS TRAILER?      -ARB80-\n         BNL   CHEKPREV           NO.                           -ARB82-\n         MVC   POSTHEAD,=X'FFFE'  YES, RESET AWAITING TRAILER   -ARB82-\nCHEKPREV CLI   PREVLAB,C'E'       WAS PREVIOUS FILE TRAILERS?   -ARB82-\n         BE    FALSEOF            YES, TREAT THIS AS DATA       -ARB82-\n         B     ACCEPTRL                                         -ARB82-\nNORMLTRL MVC   POSTHEAD,=X'FFFE'  YES, NOTE TRAILER PASSED      -ARB82-\n         CLI   FILESTAT+#NTRL,X'FF'     SEEN HEADER ALREADY?    -ARB82-\n         BNE   ACCEPTRL      SKIP ERR MSG IF NO PREVIOUS HDR1   -ARB82-\n         MVI   HDRMISS,C'N'       NOTE MATCHING HEADER FOUND    -ARB82-\n         CLC   DATASEQ,RECBUF+31  COMPARE OLD DATASET SEQ. NO. TO THE  *\n                                  CURRENT ONE.\n         BE    ACCEPTRL           SKIP ERROR MSG IF EQUAL       -ARB82-\n         MVI   PHFLSTAT+#NCON,X'FF'    NOTE INCONSISTENCY       -ARB82-\n         BAL   R2,PUTLINE                                       -ARB79-\n         MVC   MSGBUF(099),=C'0ERROR - THE DATASET SEQ. NO. ON THE FOLL*\n               OWING LABEL DOES NOT MATCH THAT ON THE PREVIOUS HDR1 LAB*\n               EL'                                              -ARB79-\nACCEPTRL MVI   GOODLAB,C'Y'       NOTE LABEL IS OK              -ARB82-\n         MVC   LABELID,=C'ET'     SHOW TRAILER FILE             -ARB82-\n         MVI   DATASEQ,C'N'       FORGET THAT HEADER            -ARB82-\n         B     TRUEOF             SKIP BAD LABEL CODE           -ARB82-\nFALSEOF  CLI   GOODLAB,C'Y'       DO WE THINK WE HAVE LABELS?   -ARB82-\n         BNE   TRUEOF             NO, NO ILLUSIONS              -ARB82-\n         MVI   GOODLAB,C'?'       YES, WAKE UP                  -ARB82-\nTRUEOF   CLI   SUMFLG,C'N'        SUMMARY WANTED?               -ARB82-\n         BE    LBL1OUT                                          -ARB79-\n         LA    R0,7               PREPARE TO RESERVE 7 LINES    -ARB79-\n         BAL   R2,PAGECHK                                       -ARB79-\n         MVC   MSGBUF,BLANKBUF                                  -ARB82-\n         CLI   SUMFLG,C'F'        FULL SUMMARY?                 -ARB79-\n         BE    TRL1LIST           YES, SKIP NORMAL SUM LINE     -ARB79-\n         MVI   MSGBUF,C'0'                                      -ARB79-\n         MVC   MSGBUF+6(3),LABTYPE                              -ARB79-\n         MVC   MSGBUF+10(13),=C'TRAILER LABEL'                  -ARB79-\n         MVI   MSGBUF+24,C'1'     IDENTIFY LABEL NO             -ARB79-\n         MVC   MSGBUF+26(11),=C'(FILE NNNN)'                    -ARB79-\n         MVC   MSGBUF+32(4),RECBUF+31  ADD THE FILE SEQ NO      -ARB79-\n         LA    R2,TRL1WARN-6                                    -ARB79-\n         B     PUTLINE3           IDENTIFY TRAILER LABEL        -ARB79-\nTRL1LIST MVC   MSGBUF+4(17),=C' TRAILER LABEL  :'               -ARB79-\n         MVC   MSGBUF+1(3),LABTYPE     ADD LABEL TYPE           -ARB79-\n         MVI   MSGBUF+19,C'1'                                   -ARB79-\n         MVC   MSGBUF+23(90),RECBUF    PUT LABEL INTO BUFFER    -ARB82-\n         MVC   MSGBUF+116(9),=C'FILE SEQ='                      -ARB82-\n         MVC   MSGBUF+125(4),RECBUF+31 STORE SEQ NO FROM LABEL  -ARB82-\n         MVI   MSGBUF,C'0'        SKIP 1 LINE FOR LIST          -ARB79-\n         BAL   R2,PUTLINE3\n         DC    C'EOF1EV'\n         MVI   HEXOFF+1,22        FOR HEX ROUTINE               -ARB82-\n         MVI   LINESIZE+3,89                                    -ARB79-\n         BAL   R5,HEXON\n         MVI   MSGBUF,C'0'        DOUBLE SPACE EXPANSION        -ARB79-\nTRL1WARN C     R7,=F'80'          USUAL LABEL SIZE?             -ARB79-\n         BE    TRL180             YES, SAY NOTHING              -ARB79-\n         BAL   R2,PUTLINE         NO, MAKE IT CLEAR             -ARB79-\n         MVC   MSGBUF(L'LABLSIZE),LABLSIZE                      -ARB79-\nTRL180   CLI   SUMFLG,C'F'        FULLY SUMMARIZING?            -ARB79-\n         BE    LBL180             YES, PRINT HEADER-TYPE FIELDS -ARB79-\n         MVI   MSGBUF,C' '        NO, SINGLE SPACE SUMMARY      -ARB82-\n         CLI   HDRMISS,C'Y'       EVER SEEN MATCHING HEADER?    -ARB82-\n         BE    LBL180             NO, PRINT OUT ALL             -ARB82-\nDOBLKCNT MVC   MSGBUF,BLANKBUF                                  -ARB79-\n         CLI   RECBUF,C'H'        IS THIS A HEADER?             -ARB79-\n         BE    HDR1BLK            YES, SKIP MOD DATE            -ARB79-\n         MVC   MSGBUF+40(18),=C'MODIFICATION DATE='             -ARB79-\n         LA    R1,RECBUF+42        SET UP PARMLST               -ARB79-\n         ST    R1,WORK             FIRST PARM IS FROM FIELD     -ARB79-\n         L     R1,AMSGBP58         AGAIN FOR SECOND PARM        -ARB79-\n         ST    R1,WORK+4           SECOND ONE IS \"TO\" FIELD     -ARB79-\n         MVI   WORK+4,X'80'       SET VL BIT                    -ARB82-\n         MVC   0(6,R1),=C'000000'  ZERO OUT THE \"TO\" FIELD      -ARB79-\n         LA    R1,WORK             SET PARMLST PTR              -ARB79-\n         BAL   R14,JULDATE        CONVERT DATE TO JULIAN        -ARB82-\nHDR1BLK  MVC   MSGBUF+11(12),=C'BLOCK COUNT='                   -ARB79-\n         MVC   MSGBUF+23(6),RECBUF+54                           -ARB79-\n         CLI   GOODLAB,C'Y'       REALLY A LABEL FILE?          -ARB82-\n         BNE   BLKPRT             IF NOT, LEAVE VTOC ALONE      -ARB82-\n         CLI   RECBUF,C'H'        HDR LABEL?                    -ARB82-\n         BE    BLKPRT             YES, AVOID VTOC               -ARB82-\n         CLI   HDRMISS,C'Y'       LONELY TRAILER LABEL?         -ARB82-\n         BNE   MATCHK             NO, CHECK OUT DSN             -ARB82-\n         MVC   VTOCCREA(7),MSGBUF+58   YES, SAVE MOD DATE       -ARB82-\nMATCHK   CLI   FILESTAT+#NTRL,X'FF'     HAS HEADER BEEN SEEN?   -ARB82-\n         BE    MATCHD             YES.                          -ARB82-\n         MVI   PHFLSTAT+#NHDR,X'FF'     NO, DIAGNOSE NO HDRS    -ARB82-\n         CLC   VTOCLTYP,=C'BLP'   ALREADY BLP FOR VTOC?         -ARB82-\n         BNE   SLBLP              NO, BECOME SO                 -ARB82-\n         MVI   FILESTAT+#BLP,0    YES, CANCEL BLP NOTE (MORE ACCURATE  *\n                                  EXPLANATION AVAILABLE)        -ARB82-\n         B     SAMEDSN                                          -ARB82-\nSLBLP    MVC   VTOCLTYP,=C'BLP'   SET VTOC TYPE TO BLP          -ARB82-\n         MVC   VOLLAB,=C'BLP'     FORCE BLP HEREAFTER           -ARB82-\n         B     SAMEDSN            SKIP DSNAME CHECK             -ARB82-\nMATCHD   CLC   VTOCDSN,RECBUF+4   IS DSN SAME AS HEADER?        -ARB82-\n         BE    SAMEDSN            YES, NO PROBLEM               -ARB82-\n         OI    PHFLSTAT+#NCON,X'FF'    NO, GIVE WARNING         -ARB82-\nSAMEDSN  MVI   FILESTAT+#NTRL,X'00'    TURN OFF NO TRAILERS     -ARB82-\n         CLI   VTOCOUNT,C' '      HAS THE TRUE BLOCK COUNT BEEN -ARB82-\n         BE    BLKFILL            FILLED IN?  IF NOT, BRANCH    -ARB82-\n         CLC   VTOCOUNT,RECBUF+54 LABEL AGREE WITH COUNT?       -ARB82-\n         BE    BLKPRT             YES.                          -ARB82-\nCOUNTERR MVI   PHFLSTAT+#COUN,X'FF'    NO, DIAGNOSE             -ARB82-\n         B     BLKPRT                                           -ARB82-\nBLKFILL  MVC   VTOCOUNT,RECBUF+54 FILL IT IN FROM THE LABEL.    -ARB82-\n         CLI   COUNTFLG,C'N'      IS ANYONE COUNTING?           -ARB82-\n         BE    BLKPRT             NO, CAN'T CHECK               -ARB82-\n         CLC   VTOCOUNT,=C'000000'     ELSE MUST BE ZERO        -ARB82-\n         BNE   COUNTERR           ERROR IF NOT                  -ARB82-\nBLKPRT   LA    R2,LBL1OUT-6  RETURN TO LBL1OUT AFTER PRINTING   -ARB82-\n         B     PUTLINE3           GO PRINT THE BLOCK COUNT      -ARB79-\n         SPACE\nEOF2EOV2 CLI   SUMFLG,C'N'        SUMMARY WANTED?               -ARB79-\n         BE    LBL2OUT                                          -ARB79-\n         MVC   MSGBUF+1(132),BLANKBUF                           -ARB82-\n         LA    R0,7               RESERVE 7 LINES               -ARB79-\n         BAL   R2,PAGECHK                                       -ARB79-\n         CLI   SUMFLG,C'F'        FULL SUMMARY?                 -ARB79-\n         BE    TRL2LIST           YES, GIVE FULL LIST           -ARB79-\n         MVC   MSGBUF+6(3),LABTYPE                              -ARB79-\n         MVC   MSGBUF+10(13),=C'TRAILER LABEL'                  -ARB79-\n         MVI   MSGBUF+24,C'2'     IDENTIFY LABEL NO             -ARB79-\n         CLI   MSGBUF,C'Y'        MOST RECENT OUTPUT SUMMARY?   -ARB82-\n         BNE   SPACEOF2           NO, DOUBLE SPACE              -ARB82-\n         MVI   MSGBUF,C' '        YES, SINGLE SPACE             -ARB82-\n         B     SUMEOF2                                          -ARB82-\nSPACEOF2 MVI   MSGBUF,C'0'        FORCE DOUBLE SPACE            -ARB82-\nSUMEOF2  LA    R2,LBL2NLST-6                                    -ARB82-\n         B     PUTLINE3           IDENTIFY THE LABEL            -ARB79-\nTRL2LIST MVC   MSGBUF+4(17),=C' TRAILER LABEL  :'               -ARB79-\n         MVC   MSGBUF+1(3),LABTYPE     DETERMINE LABEL TYPE     -ARB79-\n         MVI   MSGBUF+19,C'2'                                   -ARB79-\n         MVC   MSGBUF+23(90),RECBUF                             -ARB82-\n         MVI   MSGBUF,C'0'        DOUBLE SPACE IT               -ARB79-\n         MVI   HEXOFF+1,22        FOR HEX LISTING               -ARB82-\n         MVI   LINESIZE+3,89                                    -ARB79-\n         B     LBL2LIST                                         -ARB79-\nHDR2     DS    0H\n         CLI   SUMFLG,C'N'        SUMMARIZE LABELS?             -ARB79-\n         BE    LBL2OUT            NO, SKIP IT                   -ARB79-\n         MVC   MSGBUF+1(132),BLANKBUF                           -ARB82-\n         LA    R0,7               RESERVE 7 LINES FOR PRINT     -ARB79-\n         BAL   R2,PAGECHK                                       -ARB79-\n         CLI   SUMFLG,C'F'        FULL SUMMARY OPTION?          -ARB79-\n         BE    HDR2LIST                                         -ARB79-\n         MVC   MSGBUF+6(3),LABTYPE                              -ARB79-\n         MVC   MSGBUF+10(12),=C'HEADER LABEL'                   -ARB79-\n         MVI   MSGBUF+23,C'2'     INDICATE LABEL 2              -ARB79-\n         CLI   MSGBUF,C'Y'        MOST RECENT OUTPUT SUMMARY?   -ARB82-\n         BNE   SPACHDR2           NO, DOUBLE SPACE              -ARB82-\n         MVI   MSGBUF,C' '        YES, SINGLE SPACE             -ARB82-\n         B     SUMHDR2                                          -ARB82-\nSPACHDR2 MVI   MSGBUF,C'0'        FORCE DOUBLE SPACE            -ARB82-\nSUMHDR2  LA    R2,LBL2NLST-6                                    -ARB82-\n         B     PUTLINE3           IDENTIFY LABEL                -ARB79-\nHDR2LIST MVC   MSGBUF+4(16),=C' HEADER LABEL  :'                -ARB79-\n         MVC   MSGBUF+1(3),LABTYPE     ADD LABEL TYPE TO LINE   -ARB79-\n         MVI   MSGBUF+18,C'2'     INDICATE LABEL 2              -ARB79-\n         MVC   MSGBUF+23(90),RECBUF                             -ARB82-\n         MVI   MSGBUF,C'0'        FORCE DOUBLE SPACING          -ARB79-\n         MVI   HEXOFF+1,22                                      -ARB82-\n         MVI   LINESIZE+3,89                                    -ARB79-\nLBL2LIST BAL   R2,PUTLINE3                                      -ARB79-\n         DC    C'HDR222'\n         BAL   R5,HEXON\n         MVI   LBL2MSG,C'0'       FORCE SKIP AFTER              -ARB79-\nLBL2NLST C     R7,=F'80'          ORDINARY LABEL?               -ARB79-\n         BE    LBL280                                           -ARB79-\n         BAL   R2,PUTLINE         NOT QUITE, SEND WARNING       -ARB79-\n         MVC   MSGBUF(L'LABLSIZE),LABLSIZE                      -ARB79-\nLBL280   CLI   GOODLAB,C'N'       IN A LABEL FILE?              -ARB82-\n         BE    TRUELBL2           NO, SKIP PLAUSIBILITY CHECKS  -ARB82-\n         LR    R2,R4              GET OUR BLOCK NUMBER          -ARB82-\n         SH    R2,VOL1NO          COMPENSATE FOR PRIOR VOL1     -ARB82-\n         CH    R2,=H'2'           WHERE A 2 LABEL SHOULD BE?    -ARB82-\n         BNE   BADLBL2            NO.                           -ARB82-\n         CLC   LABELID(1),RECBUF  YES, SAME TYPE AS PREVIOUS?   -ARB82-\n         BE    TRUELBL2           YES.                          -ARB82-\nBADLBL2  MVI   GOODLAB,C'?'       NO, NOT TRUE LABEL            -ARB82-\nTRUELBL2 CLI   SUMFLG,C'F'        GIVING FULL SUMMARY?          -ARB82-\n         BE    LBL2SUMM           YES, DO IT                    -ARB79-\n         CLI   RECBUF,C'H'        TRAILER LABEL?                -ARB79-\n         BE    LBL2NSKP           NO, CONTINUE                  -ARB82-\n         CLI   HDRMISS,C'Y'       WAS HEADER MISSING?           -ARB82-\n         BNE   LBL2OUT            NO, SKIP DCB FORMATTING       -ARB82-\nLBL2NSKP MVI   LBL2MSG,C' '                                     -ARB82-\nLBL2SUMM MVC   BLKSIZE(5),RECBUF+5                              -ARB79-\n         MVC   LRECL(5),RECBUF+10\n         MVC   RECFM(1),RECBUF+4  MOVE F, U, OR V PART OF RECFM DESC.\n         SR    R1,R1\n         CLI   RECBUF+38,C'R'     SEE IF BLOCKING ATTRIBUTE IS 'BS'\n         BNE   *+18               BIF NOT BS (BS AS IN 'VBS')\n         LA    R1,2\n         MVC   RECFM+1(2),=C'BS'\n         B     CTRLCHAR\n         CLI   RECBUF+38,C' '     SEE IF BLOCKING ATTRIBUTE IS UNBLKED\n         BE    CTRLCHAR           BIF UNBLOCKED\n         MVC   RECFM+1(1),RECBUF+38   MOVE B OR S BLOCK ATTRIBUTE CHAR\n         LA    R1,1               BUMP PTR PAST THE B OR S\nCTRLCHAR LA    R1,RECFM+1(R1)\n         MVC   0(1,R1),RECBUF+36\n         MVC   TRTCH(2),RECBUF+34\n         CLC   TRTCH(2),LBL2MSG+1 SEE IF IT'S 2 BLANKS\n         BNE   *+10\n         MVC   TRTCH(8),=C'STANDARD' 9-TRK OR 7-TRK\n         MVC   BUFOFFSP(16),BLANKBUF   BLANK OUT BUFOFF LINE    -ARB79-\n         CLC   RECBUF+50(2),BLANKBUF   IS THERE A BUFOFF?       -ARB79-\n         BE    NOBUFOFF                                         -ARB79-\n         MVC   BUFOFFSP,=C'BUFFER OFFSET='                      -ARB79-\n         MVC   BUFOFF,RECBUF+50   YES, ADD TO LINE              -ARB79-\nNOBUFOFF BAL   R2,PUTLINE                                       -ARB79-\n         MVC   MSGBUF(CRMSG-LBL2MSG),LBL2MSG                    -ARB79-\n         CLI   GOODLAB,C'Y'       REALLY A LABEL FILE HERE?     -ARB82-\n         BNE   NOVSTUFF           IF NOT, LET VTOC BE           -ARB82-\n         CLI   RECBUF,C'H'        SEE IF IT IS 'HDR2'\n         BE    HDR2DCB            SAVE DCB POOP IF SO           -ARB82-\n         CLI   HDRMISS,C'Y'       TRAILER WITHOUT HEADER?       -ARB82-\n         BNE   NOVSTUFF           NO, DON'T STORE DCB           -ARB82-\nHDR2DCB  MVC   VTOCRECF,RECFM     COPY DATA FOR VTOC.             -CWB-\n         MVC   VTOCLREC,LRECL                                     -CWB-\n         MVC   VTOCBLKS,BLKSIZE                                   -CWB-\n         MVC   VTOCJOBN,RECBUF+17                                 -CWB-\n         MVC   VTOCSTEP,RECBUF+26                                 -CWB-\nNOVSTUFF CLI   SUMFLG,C'F'        FULL SUMMARY?                 -ARB82-\n         BE    LBL2CRBY           YES, PUT OUT CREATED-BY       -ARB79-\n         CLI   RECBUF,C'H'        SEE IF IT IS 'HDR2'\n         BE    LBL2CRBY           WRITE 'CREATED BY' IF SO      -ARB82-\n         CLI   HDRMISS,C'Y'       NO, HAVE WE SEEN THE HEADER?  -ARB82-\n         BNE   LBL2OUT            YES, SKIP \"CREATED BY\"        -ARB82-\nLBL2CRBY MVC   MSGBUF,BLANKBUF    CLEAR MSGBUF                  -ARB79-\n         MVC   CRMSG+15(8),RECBUF+17\n         MVC   CRMSG+32(8),RECBUF+26\n         BAL   R2,PUTLINE2\n         MVC   MSGBUF+11(L'CRMSG),CRMSG                         -ARB79-\nLBL2OUT  CLI   WRTFLG,X'03'       COPY OPERATION?               -ARB79-\n         BNE   PROCESS2           NO, SKIP LABEL ADJUST         -ARB79-\n         TM    OUTLTYP,X'42'      OUTPUT TAPE LABELLED?         -ARB79-\n         BZ    PROCESS2                                         -ARB79-\n         CLI   GOODLAB,C'Y'       IS THIS A TRUE LABEL?         -ARB80-\n         BNE   PROCESS2           NO, COPY IT AS IS             -ARB80-\n         TM    OUTLTYP,X'40'      ANSI OUTPUT?                  -ARB79-\n         BZ    FIXDEN             NO.                           -ARB82-\n         CLC   RECBUF+50(2),BLANKBUF   YES, IS BUFOFF SET?      -ARB79-\n         BNE   BUFOFFOK                                         -ARB79-\n         MVC   RECBUF+50(2),=C'000000' DEFAULT BUFOFF TO 0      -ARB79-\n         CLI   ASCIIN,C'Y'        INPUT ASCII ALSO?             -ARB82-\n         BNE   BUFOFFOK           NO.                           -ARB82-\n         MVC   ASCBUF+50(2),=X'3030'  YES, STORE ASCII 0'S      -ARB82-\nBUFOFFOK SR    R2,R2              SEE IF THE DEN IS ACCURATE    -ARB82-\n         IC    R2,DCBDEN+INPUT    IN THE INPUT LABEL            -ARB82-\n         SRL   R2,6               AND DON'T MODIFY THE OUTPUT   -ARB82-\n         EX    R2,TESTDEN         LABEL IF NOT                  -ARB82-\n         BNE   LBL2NTCH           ELSE STORE NEW DEN IN LABEL   -ARB82-\nFIXDEN   CLI   DCBDEN+OUTPUT,X'D3'     6250 BPI?                -ARB82-\n         BE    LBL26250                                         -ARB79-\n         SR    R2,R2              NO, COMPUTE DENSITY NUMBER    -ARB79-\n         IC    R2,DCBDEN+OUTPUT                                 -ARB79-\n         SRL   R2,6                                             -ARB79-\n         EX    R2,STOREDEN        PUT OUTPUT DENSITY IN LABEL   -ARB79-\n         B     LBL2ADEN                                         -ARB82-\nLBL26250 MVI   RECBUF+15,C'4'     SET DEN=4 FOR 6250            -ARB79-\nLBL2ADEN CLC   ASCIIN(2),=C'YY'   ASCII->ASCII COPY?            -ARB82-\n         BNE   LBL2TCH            NO.                           -ARB82-\n         MVC   ASCBUF+15(1),RECBUF+15 YES, DUPLEX CHANGE        -ARB82-\n         NI    ASCBUF+15,X'3F'    TO ASCII LABEL COPY           -ARB82-\n         MVC   ASCBUF+34(2),=X'2020'   BLANK TRTCH              -ARB82-\n         B     LBL2NTCH           CHANGE EBCDIC COPY            -ARB82-\nLBL2TCH  CLI   OTRTCH,0           IS OUTPUT TRTCH GIVEN?        -ARB79-\n         BE    LBL2NTCH           NO, SET TO BLANK              -ARB79-\n         CLI   OTRTCH,X'33'       ALT FORM OF TRTCH=NULL?       -ARB82-\n         BE    LBL2NTCH                                         -ARB82-\n         IC    R2,OTRTCH          YES, CONVERT TO CHAR          -ARB79-\n         SRL   R2,2                                             -ARB79-\n         N     R2,=F'6'                                         -ARB79-\n         LA    R2,TRTCHS(R2)      FIND STRING IN VECTOR         -ARB79-\n         MVC   RECBUF+34(2),0(R2) PUT TRTCH CODE IN LABEL       -ARB79-\n         B     PROCESS2                                         -ARB79-\nLBL2NTCH MVC   RECBUF+34(2),BLANKBUF   SET BLANK TRTCH          -ARB79-\n         B     PROCESS2                                         -ARB79-\n         SPACE\nUSERLABL CLI   SUMFLG,C'N'        NOSUM OPTION?                 -ARB82-\n         BE    PROCESS2           YES, DON'T LIST LABEL         -ARB82-\n         MVC   MSGBUF,BLANKBUF    NO, LIST USER LABEL           -ARB82-\n         MVC   MSGBUF+1(4),=C'USER' SHOW AS USER LABEL          -ARB82-\n         CLI   RECBUF+1,C'H'      USER HEADER?                  -ARB82-\n         BNE   UTL                NO, TRAILER                   -ARB82-\n         MVC   MSGBUF+5(16),=C' HEADER LABEL  :'                -ARB82-\n         MVC   MSGBUF+19(1),RECBUF+3   SAVE LABEL NO.           -ARB82-\n         B     LISTULAB                                         -ARB82-\nUTL      MVC   MSGBUF+5(17),=C' TRAILER LABEL  :'               -ARB82-\n         MVC   MSGBUF+20(1),RECBUF+3                            -ARB82-\nLISTULAB MVC   MSGBUF+23(90),RECBUF    COPY IN LABEL            -ARB82-\n         MVI   MSGBUF,C'0'        FORCE DOUBLE SPACE            -ARB82-\n         BAL   R2,PUTLINE3        LIST THE LABEL                -ARB82-\n         DC    C'UXL111'                                        -ARB82-\n         MVI   HEXOFF+1,22        LIST IN HEX IF HEX OPTION     -ARB82-\n         MVI   LINESIZE+3,89                                    -ARB82-\n         BAL   R5,HEXON           LIST IN HEX IF WANTED         -ARB82-\n         LR    R2,R4              LOOK AT BLOCK NUMBER          -ARB82-\n         SH    R2,VOL1NO                                        -ARB82-\n         CH    R2,=H'1'           SHOULD HDR1/EOF1 BE HERE?     -ARB82-\n         BE    LABSQERR           NO, ERROR                     -ARB82-\n         CLC   LABELID+1(1),RECBUF+1   YES, MATCH STD LABEL?    -ARB82-\n         BNE   LABSQERR           NO, FLAG ERROR                -ARB82-\n         CLI   GOODLAB,C'Y'       LABELS STILL LOOK GOOD?       -ARB82-\n         BNE   PROCESS2           NO, SKIP LAB TYPE CHANGE      -ARB82-\n         CLI   VOLLAB+2,C'P'      YES, HAS TAPE BECOME BLP?     -ARB82-\n         BE    PROCESS2           YES, LEAVE IT ALONE           -ARB82-\n         MVC   VOLLAB+1(2),=C'UL' NO, ADD USER LABEL FLAG       -ARB82-\n         MVC   VTOCLTYP+1(2),=C'UL'    FOR VTOC                 -ARB82-\n         B     PROCESS2           AND CONTINUE                  -ARB82-\nLABSQERR CLI   GOODLAB,C'Y'       PREVIOUS LABELS GOOD?         -ARB82-\n         BNE   PROCESS2           NO, NOTHING TO ADD            -ARB82-\n         MVI   GOODLAB,C'?'       YES, SET LABEL NO GOOD FLAG   -ARB82-\n         B     PROCESS2           AND REJOIN MAINLINE           -ARB82-\n         SPACE\nANSXLAB  CLI   SUMFLG,C'N'        NOSUM OPTION?                 -ARB82-\n         BE    PROCESS2           YES, DON'T LIST LABEL         -ARB82-\n         MVC   MSGBUF,BLANKBUF    NO, LIST ODD LABEL            -ARB82-\n         MVC   MSGBUF+1(3),=C'ANS'                              -ARB82-\n         CLI   RECBUF,C'H'        HEADER LABEL?                 -ARB82-\n         BNE   ANSEOX                                           -ARB82-\n         MVC   MSGBUF+4(16),=C' HEADER LABEL  :'                -ARB82-\n         MVC   MSGBUF+18(1),RECBUF+3   SAVE LABEL NO.           -ARB82-\n         B     LISTXLAB                                         -ARB82-\nANSEOX   MVC   MSGBUF+4(17),=C' TRAILER LABEL  :'               -ARB82-\n         MVC   MSGBUF+19(1),RECBUF+3   SAVE LABEL NO.           -ARB82-\nLISTXLAB MVC   MSGBUF+23(90),RECBUF    COPY IN LABEL            -ARB82-\n         MVI   MSGBUF,C'0'        FORCE DOUBLE SPACE            -ARB82-\n         BAL   R2,PUTLINE3        LIST THE LABEL                -ARB82-\n         DC    C'AXL111'                                        -ARB82-\n         MVI   HEXOFF+1,22        LIST IN HEX IF HEX OPTION     -ARB82-\n         MVI   LINESIZE+3,89                                    -ARB82-\n         BAL   R5,HEXON           LIST IN HEX IF WANTED         -ARB82-\n         LR    R2,R4              LOOK AT BLOCK NUMBER          -ARB82-\n         SH    R2,VOL1NO                                        -ARB82-\n         CH    R2,=H'1'           SHOULD HDR1/EOF1 BE HERE?     -ARB82-\n         BE    ANSSQERR           NO, ERROR                     -ARB82-\n         CLC   LABELID(1),RECBUF  YES, SAME TYPE AS 1ST LABEL?  -ARB82-\n         BE    ANSXWARN           YES, NO PROBLEM               -ARB82-\nANSSQERR CLI   GOODLAB,C'Y'       PREVIOUS LABELS OK?           -ARB82-\n         BNE   ANSXWARN           NO, NO FURTHER COMMENT        -ARB82-\n         MVI   GOODLAB,C'?'       YES, SET LABEL NO GOOD FLAG   -ARB82-\nANSXWARN BAL   R2,PUTLINE         WARN OF NON-SUPPORTED LABEL   -ARB82-\n         MVC   MSGBUF(50),=C'0WARNING - THIS LABEL TYPE IS NOT SUPPORTE*\n               D BY IBM'                                        -ARB82-\n         CLI   GOODLAB,C'Y'       LABELS STILL LOOK GOOD?       -ARB82-\n         BNE   PROCESS2           NO, LET THEM PASS             -ARB82-\n         CLI   WRTFLG,X'03'       YES, BEING COPIED?            -ARB82-\n         BNE   PROCESS2           NO.                           -ARB82-\n         CLI   RECBUF+1,C'V'      IS THIS A VOLUME LABEL?       -ARB82-\n         BNE   NOUVLCPY           NO.                           -ARB82-\n         TM    COPYFLG,X'04'      VOLUME LABELS TO BE COPIED?   -ARB82-\n         BZ    SUPVCOPY           NO, SUPPRESS COPY             -ARB82-\nNOUVLCPY CLC   ASCIIN,ASCIOUT     CONVERTING TO EBCDIC?         -ARB82-\n         BE    PROCESS2           NO.                           -ARB82-\n         MVI   PHFLSTAT+#AXLB,X'FF'    YES, GENERATE NOTE       -ARB82-\nSUPVCOPY OI    WRTFLG,X'04'       DON'T COPY THIS RECORD        -ARB82-\n         B     PROCESS2           REJOIN MAINLINE               -ARB82-\n         SPACE\nANSUVL   CLI   SUMFLG,C'N'        NOSUM OPTION?                 -ARB82-\n         BE    COUNTVLS           YES, DON'T LIST LABEL         -ARB82-\n         MVC   MSGBUF,BLANKBUF    NO, LIST ODD LABEL            -ARB82-\n         MVC   MSGBUF+1(4),=C'USER'                             -ARB82-\n         MVC   MSGBUF+5(13),=C' VOLUME LABEL:'                  -ARB82-\n         MVC   MSGBUF+19(1),RECBUF+3   SAVE LABEL NO.           -ARB82-\n         MVI   MSGBUF+20,C':'     PUT COLON AFTER               -ARB82-\n         MVC   MSGBUF+23(90),RECBUF    COPY IN LABEL            -ARB82-\n         MVI   MSGBUF,C'0'        FORCE DOUBLE SPACE            -ARB82-\n         BAL   R2,PUTLINE3        LIST THE LABEL                -ARB82-\n         DC    C'UVL111'                                        -ARB82-\n         MVI   HEXOFF+1,22        LIST IN HEX IF HEX OPTION     -ARB82-\n         MVI   LINESIZE+3,89                                    -ARB82-\n         BAL   R5,HEXON           LIST IN HEX IF WANTED         -ARB82-\nCOUNTVLS CLC   VOL1NO,=H'1'       SEEN A VOL1 THIS FILE?        -ARB82-\n         BL    ANSSQERR           NO, SEQUENCE ERROR            -ARB82-\n         LR    R2,R4              LOOK AT BLOCK NUMBER          -ARB82-\n         SH    R2,VOL1NO                                        -ARB82-\n         CH    R2,=H'1'           SHOULD UVL LABEL BE HERE?     -ARB82-\n         BNE   ANSSQERR           NO, ERROR                     -ARB82-\n         STH   R4,VOL1NO          ELSE UPDATE NO. OF VOL LABELS -ARB82-\n         B     ANSXWARN           GO WARN OF NON-STD LABEL      -ARB82-\n         SPACE\nANSVOL1  CLI   ASCIIN,C'Y'        TRANSLATION BY PARM?          -ARB79-\n         BE    NORETRAN           YES, DON'T TRANSLATE AGAIN    -ARB79-\n         MVI   ASCIIN,C'Y'        REQUEST INPUT TRANSLATION     -ARB79-\n         XLATE RECBUF,80,TO=E     TRANSLATE THE LABEL ITSELF    -ARB79-\nNORETRAN CLI   RECBUF+10,C' '     CHECK FOR VOLUME SECURITY     -ARB79-\n         BE    AVOLOK                                           -ARB79-\n         BAL   R2,PUTLINE                                       -ARB79-\n         MVC   MSGBUF(L'ASCURITY),ASCURITY                      -ARB79-\n         B     EXITRC16                                         -ARB79-\nAVOLOK   MVC   LABTYPE,=C'ANS'    INDICATE ANS LABELS           -ARB79-\n         MVI   VOLLAB,C'A'                                      -ARB82-\n         B     FIRSTVOL                                         -ARB79-\nIBMVOL1  MVI   ASCIIN,C'N'        CANCEL ASCII TRANSLATION      -ARB79-\n         MVI   VOLLAB,C'S'                                      -ARB82-\n         MVC   RECBUF,ASCBUF      MAKE SURE RECBUF IN EBCDIC    -ARB79-\nFIRSTVOL MVC   MSGBUF,BLANKBUF                                  -ARB79-\n         MVC   MSGBUF(37),=C'0INPUT VOLUME HAS WHO STANDARD LABELS'    *\n                                                                -ARB79-\n         MVC   MSGBUF+18(3),LABTYPE                             -ARB79-\n         LA    R2,*+2                                           -ARB79-\n         B     PUTLINE3           IDENTIFY LABEL TYPE           -ARB79-\nVOL1     DS    0H\n         MVC   MSGBUF,BLANKBUF                                  -ARB79-\n         LA    R0,6      PREPARE TO RESERVE 6 LINES OF PRINT\n         CLI   SUMFLG,C'F'        FULL SUMMARY?                 -ARB79-\n         BNE   VOL1NLST                                         -ARB79-\n         BAL   R2,PAGECHK         AND RESERVE THEM\n         MVC   MSGBUF+4(14),=C' VOLUME LABEL:'                  -ARB79-\n         MVC   MSGBUF+1(3),LABTYPE     SAY WHOSE LABEL          -ARB79-\n         MVC   MSGBUF+22(90),RECBUF                             -ARB79-\n         MVI   MSGBUF,C'0'\n         BAL   R2,PUTLINE3\n         DC    C'VOL111'\n         MVI   HEXOFF+1,21        PUT HEX IN RIGHT PLACE        -ARB79-\n         MVI   LINESIZE+3,89      AND FOR RIGHT LENGTH          -ARB79-\n         BAL   R5,HEXON\nVOL1NLST C     R7,=F'80'          NORMAL LENGTH LABEL?          -ARB79-\n         BE    VOL180                                           -ARB79-\n         BAL   R2,PUTLINE         IF NOT, SAY SOMETHING         -ARB79-\n         MVC   MSGBUF(L'LABLSIZE),LABLSIZE                      -ARB79-\nVOL180   MVC   MSGBUF+1(132),BLANKBUF                           -ARB79-\n         MVI   MSGBUF,C'0'                                      -ARB79-\n         MVC   MSGBUF+6(21),=C'VOLUME SERIAL NUMBER='\n         MVC   MSGBUF+27(6),RECBUF+4\n         MVC   MSGBUF+40(19),=C'OWNER INFORMATION='''\n         CLI   LABTYPE,C'A'       IS THIS AN ANS LABEL?         -ARB79-\n         BE    ANSOWNER           YES, OWNER ID IS LONGER       -ARB79-\n         MVC   MSGBUF+59(10),RECBUF+41\n         MVC   OWNERSAV(10),RECBUF+41  SAVE OWNER FOR VTOC      -ARB82-\n         MVI   MSGBUF+69,C''''\n         B     PUTVOL1                                          -ARB79-\nANSOWNER MVC   MSGBUF+59(14),RECBUF+37                          -ARB79-\n         MVC   OWNERSAV(14),RECBUF+41  SAVE OWNER FOR VTOC      -ARB82-\n         MVI   MSGBUF+73,C''''                                  -ARB79-\nPUTVOL1  BAL   R2,PUTLINE3                                      -ARB79-\n         DC    C'VOL222'\n         CLI   VERVOL,C'Y'        IS THIS THE FIRST RECORD?     -ARB82-\n         BNE   NOTVER             NO, OUT OF PLACE VOL1         -ARB82-\n         MVC   VSNSAVE,RECBUF+4   SAVE VSN FOR USE IN VTOC LISTING-CWB-\n         MVC   DDVOL,VSNSAVE      MAKE TITLE VOLSER CORRECT     -ARB82-\n         MVI   VERVOL,C'H'        YES, EXPECT HDR1 NEXT         -ARB82-\n         TM    JFCLTSV,X'42'      DID WE EXPECT LABELLED INPUT? -ARB82-\n         BNZ   NOMIX              YES.                          -ARB82-\n         TM    WRTFLG,X'01'       NO, ARE WE COPYING?           -ARB82-\n         BZ    NOMIX              NO, NO ONE CARES              -ARB82-\n         CLI   SVOUTFLG,C'N'      YES, ARE WE UNLABELLING?      -ARB83-\n         BE    NOMIX              YES, LET IT GO                -ARB82-\n         BAL   R2,PUTLINE         NO, STOP IT NOW               -ARB82-\n         MVC   MSGBUF(53),=C'0COPY OF LABELLED TAPE TO UNLABELLED TAPE *\n               NOT ALLOWED'                                     -ARB82-\n         BAL   R2,PUTLINE                                       -ARB82-\n         MVC   MSGBUF(59),=C' SPECIFY THE ''UNLABEL'' PARAMETER IF THIS*\n                IS TO BE PERMITTED'                             -ARB82-\n         B     EXITRC16           NOW GIVE UP                   -ARB82-\nNOMIX    CLI   COUNTFLG,C' '      IS COUNT OPTION SET YET?      -ARB82-\n         BNE   SERCHK             YES.                          -ARB82-\n         MVI   COUNTFLG,C'N'      NO, DEFAULT NOCOUNT FOR SL/AL -ARB82-\nSERCHK   CLC   JFCBIN+JFCBVOLS(6),RECBUF+4 SEE IF VOLSER IN JCL -ARB82-\n         BE    SAMESER            BIF SAME                      -ARB82-\n         BAL   R2,PUTLINE                                       -ARB82-\n         MVC   MSGBUF(098),=C'0WARNING - VOLUME SERIAL NUMBER IN ABOVE *\n               LABEL DOES NOT MATCH THAT SPECIFIED ON INPUT DD STATEMEN*\n               T'                                               -ARB82-\nSAMESER  MVC   VOL1NO,=H'1'       NOTE VOL1 IN RIGHT PLACE      -ARB82-\n         MVI   GOODLAB,C'Y'       NOTE WE HAVE A KOSHER LABEL   -ARB82-\n         TM    WRTFLG,X'01'       OUTPUT TO OCCUR?              -ARB82-\n         BZ    NOTVER             NO, SAY NOTHING               -ARB82-\n         CLC   ASCIIN,ASCIOUT     DIFFERENT INPUT & OUTPUT?     -ARB79-\n         BE    NASCWRN2                                         -ARB79-\n         BAL   R2,PUTLINE         YES, GIVE WARNING             -ARB79-\n         MVC   MSGBUF(L'ASCWARN),ASCWARN                        -ARB79-\nNASCWRN2 TM    COPYFLG,X'04'      SHOULD VOL1 BE COPIED?        -ARB82-\n         BNZ   COPYVOL1           YES (UNLABEL AND OFILE=1)     -ARB82-\n         OI    WRTFLG,X'04'       NO, SUPPRESS THE COPY         -ARB82-\n         B     NOTVER                                           -ARB82-\nCOPYVOL1 TM    OUTLTYP,X'42'      OUTPUT PREVIOUSLY LABELLED?   -ARB83-\n         BNZ   NOLABCH            YES.                          -ARB83-\n         MVI   OUTLTYP,X'02'      NO, MARK IT SL                -ARB83-\n         CLI   ASCIOUT,C'Y'       IS OUTPUT ASCII?              -ARB83-\n         BNE   NOLABCH            NO.                           -ARB83-\n         MVI   OUTLTYP,X'40'      IF SO, MAKE THAT AL           -ARB83-\nNOLABCH  TM    WRTFLG,X'02'       SKIPPING? (IFILE > 1)?        -ARB82-\n         BNZ   PROCESS2           NO, JUST GO COPY              -ARB82-\n         LA    R10,ENDVOLVR       YES, COPY VOL1 TO OUTPUT      -ARB82-\n         STH   R7,WRTCMND+6       STORE LENGTH FOR WRITE        -ARB82-\n         B     COPYIT             ANYWAY (SINCE UNLABEL)        -ARB82-\nNOTVER   TM    WRTFLG,X'02'       ARE WE STILL SKIPPING?        -ARB82-\n         BNZ   PROCESS2           NO, RETURN TO MAIN LOOP       -ARB79-\n         B     ENDVOLVR           YES, SKIP SOME MORE           -ARB82-\n         SPACE 5\nEODS     DS    0H\n         CLI   VERVOL,C'Y'        TM INSTEAD OF VOL LABEL?      -ARB82-\n         BE    NOVOL1             YES, KNOW TAPE IS NL          -ARB82-\n         CLI   VERVOL,C'H'        HDR1 EXPECTED?                -ARB82-\n         BE    NOHDR1             YES, NOTE NOT FOUND           -ARB82-\n         MVI   VERVOL,C'N'        NO VOLUME VERIFY AFTER TM     -ARB82-\nEONLVER  XC    VOL1NO,VOL1NO      NO GOOD VOL1'S AFTER TM       -ARB82-\n         AP    MARKNO,=P'1'       COUNT THE TAPEMARK\n         UNPK  MARKNUM,MARKNO\n         OI    MARKNUM+3,X'F0'\n         CLC   POSTHEAD,=X'FFFE'  FOUND HDR BUT NO TRLR?        -ARB80-\n         BNL   NOCTHEAD           NO, DON'T COUNT               -ARB80-\n         LA    R1,1               YES, ADD 1 TO COUNT           -ARB80-\n         AH    R1,POSTHEAD                                      -ARB80-\n         STH   R1,POSTHEAD                                      -ARB80-\nNOCTHEAD LA    R1,1                                             -ARB80-\n         A     R1,CTPMKNO         CURRENT NUMBER OF TAPEMARKS PASSED\n         ST    R1,CTPMKNO         IS NOW UPDATED TO ACTUAL VALUE\n         TM    OPTNO+3,X'01'      SEE IF TAPEMARK LOGGING SPECIFIED\n         BZ    TPMKLOGD           BIF TAPEMARK LOGGING NOT SPECIFIED\n         MVC   TPMKLOG+17(4),MARKNUM\nTPMKLOG  WTL   'TAPEMARK XXXX ENCOUNTERED'\nTPMKLOGD DS    0H\n         L     R1,BLKCNT          BLKS IN PREVIOUS DATASETS\n         AR    R1,R4              ADD NO. OF BLKS IN DATASET JUST READ\n         ST    R1,BLKCNT          TO GET TOTAL BLKS READ SO FAR (EXCEPT*\n                                  FOR SKIPPING - SKIPEOV OR SKIPTM).\n         CLI   WRTFLG,X'03'       SEE IF COPY BEING DONE NOW\n         BNE   SKIPWTM            SKIP WRITING TAPEMARK IF NOT  -ARB82-\n         CLI   OKCODE+3,12        I/O ERR TERMINATION?          -ARB82-\n         BE    BUMPOUTM           YES, LET CLOSE WRITE TM       -ARB82-\n         LA    R1,=AL3(WTMCMND)   PTR TO PTR TO WTM CCW FOR OUTPUT TAPE\n         LA    R2,OUTPUT          DCB FOR WTM EXCP OUTPUT\n         ST    R4,SVR4            SAVE R4 FOR EXEC EXCP CALL\n         BAL   R4,EXECEXCP        CALL SUBROUTINE TO ISSUE EXCP\n         L     R4,SVR4            RESTORE R4\nBUMPOUTM LH    R1,COUTFILE        LOAD OUTPUT TM NUMBER         -ARB82-\n         LA    R1,1(,R1)          BUMP FOR NEXT FILE            -ARB82-\n         STH   R1,COUTFILE        AND STORE                     -ARB82-\nSKIPWTM  CLI   PREVLAB,C'H'       PREVIOUS FILE A HEADER?       -ARB82-\n         BE    SLFILE             YES.                          -ARB82-\n         LTR   R4,R4              ANY RECORDS READ?             -ARB82-\n         BNZ   NOTLTM             YES, NOT LEADING TAPE MARK    -ARB82-\n         CLI   MARK,X'FF'         IS THIS AN EOV?               -ARB82-\n         BE    NONLFILE           YES, SKIP VTOC FOR NOW        -ARB82-\nNOTLTM   CLI   GOODLAB,C'N'       NO, IS THIS FILE LABELS?      -ARB82-\n         BNE   NONLFILE           YES, NO VTOC ENTRY            -ARB82-\n         CLI   SKIPFLG,X'FF'      STILL BUSY SKIPPING?          -ARB82-\n         BNE   NONLFILE           YES, DON'T START A VTOC       -ARB82-\n         CLI   SUMFLG,C'N'        NOSUM OPTION?                 -ARB82-\n         BE    NONLFILE           YES, NO VTOC EITHER           -ARB82-\n         BAL   R2,GETVTOC         NO, GET A VTOC BLOCK          -ARB82-\n         CLC   VOLLAB(3),=C'BLP'  BLP ALREADY SET?              -ARB82-\n         BE    NONLBLP            YES.                          -ARB82-\n         CLC   VOLLAB(2),=C'NL'   NO, SHOULD THIS BE NL?        -ARB82-\n         BE    NONLBLP            YES.                          -ARB82-\n         MVC   VOLLAB,=C'BLP'     NO, MAKE IT BLP               -ARB82-\n         MVI   PHFLSTAT+#BLP,X'FF'     FORCE VTOC NOTE          -ARB82-\nNONLBLP  MVC   VTOCLTYP,VOLLAB    SHOW LABEL TYPE               -ARB82-\n         MVC   VTOCDSN(12),=C'  *NO LABEL*' EYE-CATCHING DSN    -ARB82-\n         CLI   COUNTFLG,C'N'      NOCOUNT OPERATION?            -ARB82-\n         BE    VTOCTMNO           YES, CAN'T DISTINGUISH T/M    -ARB82-\n         LTR   R4,R4              IS THIS JUST A TAPE MARK?     -ARB82-\n         BNZ   VTOCTMNO           YES.                          -ARB82-\n         MVC   VTOCDSN+3(8),=C'TAPEMARK'   YES, RELABEL         -ARB82-\n         B     VTOCTMNO                                         -ARB82-\nSLFILE   CLC   VOLLAB,=C'BLP'     ARE LABELS PERVERSE?          -ARB82-\n         BNE   NONLFILE           NO, CONTINUE                  -ARB82-\n*                                 ELSE REPLACE FILE SEQ. WITH          *\n                                  TAPE MARK NUMBER              -ARB82-\nVTOCTMNO CLI   OKCODE+3,12        STOPPING FOR I/O ERRORS?      -ARB82-\n         BE    NOVTOCTM           YES, NO TAPE MARK NUMBER      -ARB82-\n         MVC   VTOCSEQN,MARKNUM   TM NUMBER AS FILE NUMBER      -ARB82-\nNOVTOCTM TM    WRTFLG,X'01'       WAS IT COPIED?                -ARB82-\n         BZ    NONLFILE           NO.                           -ARB82-\n         LH    R1,COUTFILE        GET OUTPUT FILE NUMBER        -ARB82-\n         BCTR  R1,0               CORRECT FOR INCREMENT         -ARB82-\n         CVD   R1,BADLNGTH                                      -ARB82-\n         OI    BADLNGTH+7,X'0F'                                 -ARB82-\n         UNPK  VTOCOUSQ,BADLNGTH       FORMAT INTO VTOC         -ARB82-\nNONLFILE OC    FILESTAT(12),PHFLSTAT   PICK UP ERRORS FOR ENDED FILE   *\n                                                                -ARB82-\n         XC    PHFLSTAT(12),PHFLSTAT                            -ARB82-\n         CLI   COUNTFLG,C'N'\n         BE    SIMPLETM           BIF COUNT OPTION NOT SPECIFIED\n         L     R0,MAX\n         LTR   R0,R0\n         BZ    SIMPLETM           BIF NO COUNTING WORK HAS BEEN DONE\n         LTR   R4,R4              BYPASS MAX/MIN/AVG IF           -CWB-\n         BZ    SIMPLETM                NO RECORDS.                -CWB-\n         L     R1,MIN\n         CVD   R1,BADLNGTH\n         OI    BADLNGTH+7,X'0F'\n         UNPK  MINMSG,BADLNGTH\n         L     R1,MAX\n         CVD   R1,BADLNGTH\n         OI    BADLNGTH+7,X'0F'\n         UNPK  MAXMSG,BADLNGTH\n         LR    R1,R4              COPY COUNT OF RECORDS AND DIVIDE-CWB-\n         SRA   R1,1                    BY 2 TO ROUND THE AVERAGE. -CWB-\n         A     R1,FILEBYTS        ADD NUMBER OF BYTES IN FILE.    -CWB-\n         SR    R0,R0              CLEAR R0 FOR DIVIDE.            -CWB-\n         ST    R0,FILEBYTS        ALSO CLEAR FILEBYTS FOR NEXT    -CWB-\n*                                      FILE.                      -CWB-\n         DR    R0,R4              DIVIDE FOR AVERAGE BLOCK SIZE.  -CWB-\n         CVD   R1,BADLNGTH        MAKE AVERAGE SIZE PRINTABLE.    -CWB-\n         OI    BADLNGTH+7,X'0F'                                   -CWB-\n         UNPK  AVGMSG,BADLNGTH                                    -CWB-\n         CVD   R4,BADLNGTH\n         OI    BADLNGTH+7,X'0F'\n         UNPK  COUNTMSG,BADLNGTH\n         LTR   R3,R3              DO WE HAVE A VTOC ENTRY?        -CWB-\n         BZ    NOSAVE             IF NOT, BRANCH.                 -CWB-\n         CLI   GOODLAB,C'N'       IS THIS A LABEL FILE?         -ARB82-\n         BNE   NOSAVE             IF SO, DON'T SAVE STAT'S.     -ARB82-\n         MVC   VTOCMINB,MINMSG    SAVE MIN, MAX, AVG, AND COUNT   -CWB-\n         MVC   VTOCMAXB,MAXMSG         FOR VTOC LISTING.          -CWB-\n         MVC   VTOCAVGB,AVGMSG                                    -CWB-\n         MVC   VTOCOUNT,COUNTMSG                                  -CWB-\nNOSAVE   EQU   *                                                  -CWB-\n         MVI   EOVM+1,CNTSEND-TPMKMSG-1  SET LENGTH FOR MVC.      -CWB-\n         MVC   MSGBUF,BLANKBUF    CLEAR BUFFER COMPLETELY.        -CWB-\n         MVC   MSGBUF+18(CNTSEND-EOVNUM-3),EOVNUM+3 COPY MESG.    -CWB-\n         LA    R5,PUTLINE2        SPECIFY LONG TAPEMARK MSG\n         CLI   OKCODE+3,12        I/O ERROR TERMINATION?        -ARB79-\n         BE    LINEOR2            YES, GO PUT OUT COUNTS        -ARB79-\n         B     TMSGDONE\nSIMPLETM CLI   OKCODE+3,12        FINISHING AFTER ERROR?        -ARB79-\n         BE    PRENDMSG           YES, NO MESSAGE NEEDED        -ARB79-\n         MVI   EOVM+1,33          SET LENGTH FOR POSSIBLE SHORT EOV MSG\n         LA    R5,PUTLINE         SPECIFY SHORT TPMK FOUND MSG IF ANY\nTMSGDONE TM    EOV1FLG,X'03'      SEE IF ANY EOV'S PENDING      -ARB82-\n         BNZ   EOVPROC            BIF ANY EOV'S PENDING         -ARB82-\n         CLI   MARK,X'FF'         TWO CONSECUTIVE MARKS?          -CWB-\n         BNE   SKPCHK             IF NOT, BRANCH                  -CWB-\n         CLI   PREVLAB,C'H'       PREV FILE A HDR1 LABEL?       -ARB82-\n         BNE   EOVPROC            IF NOT, GO DO EOV.            -ARB82-\nSKPCHK   MVI   MARK,X'FF'         NOTE THIS MARK FOUND.           -CWB-\n         CLC   CEOVNO,SKPEOVNO    SKIP SKIPTM PROCESSING IF\n         BL    SKIPTMEV           SKIPEOV IS BEING DONE.        -ARB79-\n         CLC   CTPMKNO,SKIPFLNO   COMPARE CTPMKNO WITH SKIPFLNO -ARB79-\n         BL    SKIPTMPR           BRANCH TO DO POSSIBLE SKIPTM PROCESS\n         BH    LINEOR2            BIF NOT JUST DONE SKIPPING    -ARB79-\n         TM    SKIPFLG,X'80'      DOING LABEL POSITIONING?      -ARB79-\n         BNZ   LINEOR2            NO, REALLY THRU               -ARB79-\n         OC    SKIPTMNO,SKIPTMNO  YES, SKIPTM ALSO PRESENT?     -ARB79-\n         BNZ   TMDONE             YES, DON'T PRINT TM NOTICE    -ARB79-\n         OC    SKPEOVNO,SKPEOVNO  ANY EOVS TO BE SKIPPED?       -ARB79-\n         BNZ   TMDONE             YES, NO MESSAGE NOW           -ARB79-\nLINEOR2  BALR  R2,R5              TO PUTLINE OR PUTLINE2\n         MVC   MSGBUF(18),TPMKMSG\n         CLI   OKCODE+3,12        FORCED END FOR I/O ERR?       -ARB79-\n         BE    TPMKLIM            YES, ALLOW NO ESCAPE          -ARB82-\n         CLC   CTPMKNO,SKIPFLNO   JUST FINISHED SKIPPING?       -ARB79-\n         BE    TMDONE             YES, AVOID MAX CHECK          -ARB79-\n         CLC   CTPMKNO,MAXTMNO\n         BL    PROCESS\nFORCEND  CLI   WRTFLG,X'03'       CHECK IF COPY BEING DONE      -ARB79-\n         BNE   *+16               SKIP IF IT'S NOT BEING DONE\n         LA    R1,=AL3(WTMCMND)   OTHERWISE WRITE AN EXTRA TAPEMARK,\n         LA    R2,OUTPUT          JUST TO MAKE SURE.  THIS COULD\n         ST    R4,SVR4            SAVE R4 OVER CALL             -ARB84-\n         BAL   R4,EXECEXCP        RESULT  IN 3 TAPEMARKS IN LAST EOV.\n         L     R4,SVR4            RESTORE R4                    -ARB84-\n         B     TPMKLIM                                          -ARB82-\n         SPACE 5\nEOVPROC  DS    0H                 HANDLES END-OF-VOLUME INDICATIONS\n         MVI   MARK,X'00'         RESET 1 TPMK INDICATOR        -ARB79-\n         MVC   EOV1FLG+1(1),EOV1FLG SAVE FOR POSSIBLE DECISION ON      *\n                                  HDR1000 . . . TERMINATION MSG.\n         NI    EOV1FLG,X'FC'      CLEAR 'EOV PENDING' FLAG(S) IF ANY\n         AP    EOVNO,=P'1'        COUNT EOV'S\n         UNPK  EOVNUM,EOVNO\n         OI    EOVNUM+2,X'F0'\n         TM    OPTNO+3,X'01'      WTL OPTION?                   -ARB79-\n         BZ    SKIPLOG                                          -ARB79-\n         MVC   WRITELOG+11(3),EOVNUM\nWRITELOG WTL   'EOV000 ENCOUNTERED'\nSKIPLOG  MVC   OLDSUP,SUPOUT      SAVE SUPPRESS FLAG            -ARB82-\n         MVI   SUPOUT,C'N'        FORCE OUT EOV MESSAGES        -ARB82-\n         BAL   R2,PUTLINE                                       -ARB82-\nEOVM     MVC   MSGBUF(00),TPMKMSG LENGTH SPECIFIED IN EODS EXIT\n         MVC   SUPOUT,OLDSUP      RESTORE SUPPRESS LIST FLAG    -ARB82-\n         TM    SKIPFLG,X'80'      DOING LABEL POSITIONING?      -ARB79-\n         BZ    SKIPTMPR           DON'T COUNT EOVS IF SO        -ARB79-\n         LA    R1,1\n         A     R1,CEOVNO          COUNTS EOV INDICATIONS, INITIALLY=0\n         ST    R1,CEOVNO\n         C     R1,SKPEOVNO        SEE IF EOV SKIPPING           -ARB79-\n         BL    SKIPTMEV                                         -ARB79-\n         BE    EOVDONE                                          -ARB79-\n         C     R1,MAXEOVNO        SEE IF MAXEOV'S REACHED\n         BNL   PRENDMSG           EXIT IF MAX EOV'S REACHED\n         TM    WRTFLG,X'02'       ALL SKIPPING DONE?            -ARB79-\n         BZ    SKIPTMPR           NO MAX CHECK IF NOT           -ARB79-\n         CLC   CTPMKNO,MAXTMNO    CHECK MAX TPMKS JUST IN CASE\n         BNL   TPMKLIM            QUIT IF REACHED MAX           -ARB82-\n         CLI   SUMFLG,C'N'        NOSUM REQUESTED? (WHY?)       -ARB82-\n         MVI   LABELID,C'N'       FORGET LAST LABELS            -ARB82-\n         MVC   POSTHEAD,=X'FFFE'  FORGET PREVIOUS HEADER        -ARB83-\n         BE    PROCESS            SKIP VTOC IF SO               -ARB82-\n         BAL   R2,GETVTOC         GET VTOC ENTRY FOR EOV        -ARB82-\n         MVC   VTOCSEQN,=C'----'  INDICATE SPECIAL LINE         -ARB82-\n         MVC   VTOCDSN(13),=C'END OF VOLUME'                    -ARB82-\n         MVC   VTOCDSN+14(3),EOVNUM   STORE EOV NUMBER          -ARB82-\n         CLC   VOLLAB(2),=C'NL'   TAPE GOOD NL?                 -ARB82-\n         BE    PROCESS            YES.                          -ARB82-\n         MVC   VOLLAB,=C'BLP'     NO, MAKE IT BLP AFTER EOV     -ARB82-\n         B     PROCESS            CONTINUE IF MORE TM'S TO COME -ARB82-\nTPMKLIM  MVI   TMQUIT,X'FF'       NOTE STOPTM CUTOFF            -ARB82-\n         SPACE 5\nPRENDMSG DS    0H\n         BALR  R12,0              SET UP FINALE BASE REG        -ARB82-\n         USING *,R12              FOR BETTER ADDRESSABILITY     -ARB82-\n         B     FINALE             SKIP TO FINAL PROCESSING      -ARB82-\n         EJECT\nCEOVNO   DC    F'0'               # OF DOUBLE TAPEMARKS PASSED\nSVR4     DC    F'0'               FOR SAVING R4 TEMPORARILY\nBLKCNT   DC    F'0'               KEEPS TRACK OF TOTAL BLKS READ ON TAPE\n                                  EXCLUDING THOSE READ DURING SKIPPING.\nMAX      DC    F'0'               KEEPS TRACK OF MAXIMUM BLK LENGTH\nMIN      DC    F'32767'           KEEPS TRACK OF MINIMUM BLK LENGTH\nVOL1NO   DC    H'0'               NO. OF VOL1'S IN THIS FILE    -ARB82-\nTESTDEN  CLI   RECBUF+15,C'0'     EX'D TO TEST LABEL DENSITY    -ARB82-\nSTOREDEN MVI   RECBUF+15,C'0'     EX'D TO PUT DENSITY IN LABEL  -ARB79-\nPOSTHEAD DC    X'FFFF'            NUMBER OF FILES AFTER HDR            *\n                                  FFFF = NO HDR FOUND YET              *\n                                  FFFE = HDR MATCHED BY TRLR    -ARB80-\nMARKNO   DC    PL3'0'\nFILENO   DS    PL4                                              -ARB79-\nHEADNO   DC    PL3'-1'            HEADER LABEL COUNTER          -ARB80-\nEOVNO    DC    PL2'0'\nTPMKMSG  DC    C'0TAPEMARK NO. '\nMARKNUM  DC    C'    '\n         DC    C' -- EOV NO. '\nEOVNUM   DC    CL3'000'\n         DC    C'    BLOCK LENGTHS:  MINIMUM='                  -ARB82-\nMINMSG   DC    C'00000'\n         DC    C'  MAXIMUM='                                    -ARB82-\nMAXMSG   DC    C'00000'\n         DC    C'  AVERAGE='                                    -ARB82-\nAVGMSG   DC    C'00000'                                           -CWB-\n         DC    C'    NUMBER OF BLOCKS='\nCOUNTMSG DC    C'000000'\nCNTSEND  EQU   *                                                  -CWB-\nDATASEQ  DC    CL4'NONE'\nLBL2MSG  DC    C'           RECFM='                             -ARB79-\nRECFM    DC    CL18'          BLKSIZE='\nBLKSIZE  DC    CL18'XXXXX       LRECL='\nLRECL    DC    CL20'XXXXX       TRTCH='                         -ARB79-\nTRTCH    DC    CL16' '\nBUFOFFSP DC    CL14' '                                          -ARB79-\nBUFOFF   DC    CL2'  '                                          -ARB79-\nCRMSG    DC    C'CREATED BY JOB          IN STEP         '\nTRTCHS   DC    C'E ETC T '        TRTCH CODE VECTOR             -ARB79-\nLABTYPE  DC    C'IBM'             OR ANS IF TRANSLATING         -ARB79-\nVERVOL   DC    C'Y'               VOLUME VERIFICATION SWITCH    -ARB79-\nHDRFOUND DC    C'N'               HDR SEQ NO PROCESSED          -ARB79-\nGOODLAB  DC    C'N'               LABEL DATA/TRUE LABEL FLAG           *\n                                  Y=VALID LABEL FILE, N=DATA FILE      *\n                                  ?=PERVERSE LABEL FILE         -ARB82-\nMARK     DC    X'F0'              'TAPEMARK JUST READ' FLAG (00 = NOT)\nTMQUIT   DC    X'00'              MAXTM TERMINATION FLAG        -ARB82-\nEOV1FLG  DC    XL2'0000'          X'00'=EOV NOT PENDING, X'01'=EOV1    *\n                                  TYPE OF EOV PENDING, X'02' BIT=      *\n                                  'HDR10000 . . . ' IN 1ST FILE TYPE.\n*                                 AND HDR2 RECORD DOES NOT FOLLOW IT.\nLABELIKE DC    C'Y'               ALL RECORDS OF THIS FILE             *\n                                  LOOK LIKE LABELS              -ARB82-\nLABELID  DC    CL2'E?'            LABEL ID CHARS (HH OR ET)     -ARB82-\n*                                      PROCESSING A LABEL FILE.   -CWB-\nPREVLAB  DC    C'N'               PREVIOUS LABEL FLAG CHARACTER        *\n                                  N=NOT, H=HEADER, E=TRAILER    -ARB82-\nHDRMISS  DC    C'N'               'Y' IF NO HDR FOR TRLR        -ARB82-\n         DS    0A                                               -ARB82-\nFRSTVTOC DC    AL1(VTOCEPB),AL3(0)  ADDRESS OF FIRST VTOC BLOCK;  -CWB-\n*                                      HIGH-ORDER BYTE SET TO     -CWB-\n*                                      FORCE FIRST GETMAIN.       -CWB-\nFILEBYTS DC    F'0'               NUMBER OF BYTES IN THIS FILE.   -CWB-\nVTOCHEAD DC    C'0VOLUME TABLE OF CONTENTS FOR '                -ARB82-\nVSNSAVE  DC    C'VSNVSN',C'    '                                  -CWB-\nSAVETRK  DC    C'9 TRACK    '                                     -CWB-\nOWNERSAV DC    CL14'          '                                 -ARB82-\n         DC    C'   DENSITY='                                   -ARB82-\nVTOCDEN  DC    C' 800 BPI, TRTCH='                              -ARB82-\nVTOCTRTC DC    CL3' '                                           -ARB82-\n         DC    C'   LABEL='                                     -ARB82-\nVOLLAB   DC    C'NL '                                           -ARB82-\nVHEADLEN EQU   *-VTOCHEAD                                         -CWB-\n         EJECT\nFINALE   MVI   SUPOUT,C'N'        ALWAYS PRINT FINAL MSGS       -ARB82-\n         LTR   R3,R3              HAVE WE A VTOC?               -ARB82-\n         BZ    NOFINVTC           NO.                           -ARB82-\n         MVI   VNOMORE,C'Y'       PREVENT ADDITIONS TO VTOC     -ARB82-\n         BAL   R2,GETVTOC         CALL VTOC ROUTINE TO UPDATE STATUS   *\n                                  FOR LAST FILE                 -ARB82-\nNOFINVTC TM    EOV1FLG+1,X'02'                                  -ARB82-\n         BZ    *+14               SKIP IF NO 'HDR1000 . . . ' EOV\n         BAL   R2,PUTLINE\n         MVC   MSGBUF(114),=C'0TAPESCAN TERMINATING BECAUSE TAPE APPARE*\n               NTLY ONLY INITIALIZED, NOT USED.  TO SCAN FURTHER USE OP*\n               TIONS=''STOPEOV=2'''                             -ARB82-\n         CLI   COUNTFLG,C'N'\n         BE    SHORT              SKIP TO NOT PRINT COUNTS\n         LA    R0,6               PREPARE TO RESERVE 6 LINES FOR PRINT\n         BAL   R2,PAGECHK         RESERVE THEM\n         LA    R1,=AL3(SENSCMND)  RE-SENSE AT END OF PROCESSING -ARB82-\n         LA    R2,INPUT           PTR TO DCB FOR EXCP CALL      -ARB82-\n         ST    R4,SVR4            SAVE R4 OVER CALL             -ARB84-\n         BAL   R4,EXECEXCP                                      -ARB82-\n         L     R4,SVR4            RESTORE R4                    -ARB84-\n         TM    SENSBYTS+1,X'10'   CHECK IF 7-TRK, 1 BIT = 7-TRK\n         BO    SEVENTRK\n         MVI   INDEX+3,4          SINCE 9-TRK, LOAD OFFSET FOR NO CONV\n         TM    SENSBYTS+3,X'04'   CHECK IF PE, 1 = PE = 1600 BPI\n         BNO   EIGHTBPI           BIF 800 BPI 9-TRK\n         MVI   DCBDEN+INPUT,X'C3' SET DEN=1600 BPI INDICATOR\n         B     ADDDEN\nEIGHTBPI DS    0H\n         TM    SENSBYTS+5,X'C0'   6250 POSSIBLE?                -ARB79-\n         BZ    NOT62              NO.                           -ARB79-\n         TM    SENSBYTS+6,X'08'                                 -ARB79-\n         BNZ   YES62                                            -ARB79-\nNOT62    MVI   INPUT+DCBDEN,X'83' SET DEN=800 BPI INDICATOR     -ARB79-\n         B     ADDDEN\nYES62    MVI   INPUT+DCBDEN,X'D3' INDICATE 6250                 -ARB79-\n         LA    R2,4                                             -ARB79-\n         B     ADDDEN2                                          -ARB79-\nSEVENTRK DS    0H\n         MVI   INDEX+3,40         LOAD OFFSET FOR 7-TRK         -ARB79-\n         LA    R0,3900            LOAD TAPEMARK LENGTH FOR 7-TRK\n         STH   R0,TMLENGTH\n         MVC   LNGTHEST+62(14),=C'C (CONVERSION)'\n         CLI   INPUT+DCBTRTCH,X'13' SEE IF CONVERSION SPECIFIED\n         BE    ADDDEN             BIF IT IS, OFFSET=0 FOR CONV\n         MVI   INDEX+3,44         SET OFFSET FOR 7-TRK, NO CONV -ARB79-\n         MVC   LNGTHEST+62(19),=C'7-TRK NO CONVERSION'\nADDDEN   DS    0H\n         SR    R2,R2\n         IC    R2,INPUT+DCBDEN\n         SRL   R2,6               SHIFT INTO RIGHT-HAND 2 BITS\n         LTR   R2,R2              SEE IF DEN=0 SPECIFIED\n         BNE   ADDDEN2            BIF DEN=0 NOT SPECIFIED\n         L     R2,DCBDEBAD+INPUT  GET PTR TO DEB\n         L     R2,DEBUCBAD(R2)    GET PTR TO UCB\n         TM    19(R2),X'03'       SEE IF IT'S A 3400 SERIES OR THE LIKE\n         LA    R2,0               CLEAR R2 WITHOUT RESETTING CC\n         BNO   ADDDEN2            BIF IT ISN'T, IT'S OK\n         LA    R2,1               SET DENSITY USED FOR LENGTH ESTIMATE *\n                                  TO 556 BPI BECAUSE 3400 SERIES       *\n                                  DOESN'T SUPPORT 200 BPI (EXCEPT 3410)\nADDDEN2  DS    0H\n         LA    R0,X'F0'           LOAD C'0' FOR OR OPERATION\n         OR    R0,R2              GET PRINTABLE DENSITY CHARACTER\n         STC   R0,LNGTHEST+50     STORE PRINTABLE DENSITY MSG\n         SLL   R2,3               MULTIPLY BY 8 TO GET DEN OFFSET\n         A     R2,INDEX           ADD PREVIOUS OFFSETS\n         ST    R2,INDEX           STORE COMPLETED OFFSET FOR BPIBGTBL\n* FORMULA FOR LENGTH IN INCHES FOLLOWS:\n* INCHES=R8/BPI+(IBG*BLKCNT+MAX(0,CTPMKNO-SKIPTMNO)*TMLENGTH)/1000\n         L     R15,CTPMKNO        LOAD NUMBER OF TAPEMARKS READ\n         S     R15,SKIPTMNO       SUBTRACT NUMBER OF TAPEMARKS SKIPPED\n         BP    *+6                CHANGE POSSIBLE NEGATIVES TO ZERO\n         SR    R15,R15            CHANGE POSSIBLE NEGATIVES TO ZERO\n         MH    R15,TMLENGTH       MULTIPLY BY (TAPEMARK LENGTH*1000)\n         L     R2,INDEX           LOAD INDEX INTO BPI/IBG TABLE\n         L     R1,BLKCNT          LOAD BLOCK COUNT\n         MH    R1,BPIBGTBL-20(R2) MULTIPLY TO GET TOTAL GAP LENGTH*1000\n         AR    R1,R15             GET TOTAL GAP + TAPEMARK LENGTH*1000\n         SR    R0,R0\n         D     R0,=F'1000'        GET TOTAL TAPEMARK+ GAP LENGTH INCHES\n         LR    R15,R1             SAVE THIS FOR LATER\n         LH    R2,BPIBGTBL-18(R2) LOAD PHYSICAL BPI (NOT LOGICAL BPI)\n         LR    R1,R8              LOAD TOTAL BYTE COUNT\n         SR    R0,R0\n         DR    R0,R2              DIVIDE BYTE COUNT BY PHYSICAL BPI\n         AR    R1,R15             GET TOTAL LENGTH IN INCHES\n         SR    R0,R0\n         D     R0,=F'12'          GET FEET IN R1, INCHES IN R0\n         CVD   R1,BADLNGTH\n         OI    BADLNGTH+7,X'0F'\n         UNPK  LNGTHEST+17(4),BADLNGTH\n         CVD   R0,BADLNGTH\n         OI    BADLNGTH+7,X'0F'\n         UNPK  LNGTHEST+27(2),BADLNGTH\n         BAL   R2,PUTLINE\n         MVC   MSGBUF(81),LNGTHEST\n         BAL   R2,PUTLINE\n         MVC   MSGBUF(106),LNGTHACC\n         MVI   SHORTNOW+1,102     LENGTH OF LONG MSG FOR COUNTS -ARB79-\n         CVD   R8,BADLNGTH        TOTAL BYTES READ (FOR COUNT OPT ONLY)\n         OI    BADLNGTH+7,X'0F'   SET SIGN NIBBLE\n         UNPK  BYTES,BADLNGTH\n         L     R8,BLKCNT          TOTAL BLKS READ ON TAPE, EXCLUDING   *\n                                  THOSE READ DURING SKIP PROCESSING.\n         CVD   R8,BADLNGTH\n         OI    BADLNGTH+7,X'0F'\n         UNPK  NBLKS,BADLNGTH\nSHORT    BAL   R2,PUTLINE         PRINT 'SUCCESSFUL END' MSG\nSHORTNOW MVC   MSGBUF(L'ENDMSG),ENDMSG (LENGTH MODIFIED FOR COUNTBLKS)\n         L     R2,ERRCOUNT        COUNT OF SYNAD EXITS TAKEN\n         LTR   R2,R2              SEE IF ZERO\n         BZ    LISTVTOC           GO DO VTOC IF SO.               -CWB-\n         CVD   R2,BADLNGTH        ELSE PRINT ERROR COUNT\n         OI    BADLNGTH+7,X'0F'\n         UNPK  ERRSUMSG+22(5),BADLNGTH\n         BAL   R2,PUTLINE\n         MVC   MSGBUF(L'ERRSUMSG),ERRSUMSG\n         SPACE 3\nLISTVTOC CLC   FRSTVTOC+1(3),=AL3(0)  DID WE MAKE A VTOC?         -CWB-\n         BE    EXIT               IF NOT, SKIP IT.                -CWB-\n         LA    R0,100             RESERVE 100 LINES (FORCE EJECT).-CWB-\n         BAL   R2,PAGECHK                                         -CWB-\n         MVC   VTOCDEN(4),DENMSG+1 COPY DENSITY TO VTOC HEAD    -ARB82-\n         MVC   VTOCTRTC,=C'STD'   ASSUME STANDARD TRTCH         -ARB82-\n         CLI   ITRTCH,0           IS THAT SO?                   -ARB82-\n         BE    STDTRTCH           YES.                          -ARB82-\n         CLI   ITRTCH,X'33'       CHECK 7 TRACK TRTCH=NULL      -ARB82-\n         BE    STDTRTCH\n         IC    R2,ITRTCH          ELSE CONVERT TO LETTER        -ARB82-\n         SRL   R2,2                                             -ARB82-\n         N     R2,=F'6'                                         -ARB82-\n         LA    R2,TRTCHS(R2)      FIND STRING FORM OF TRTCH     -ARB82-\n         MVC   VTOCTRTC(2),0(R2)  ADD TO HEADING                -ARB82-\n         MVI   VTOCTRTC+2,C' '    REMOVE THIRD CHARACTER        -ARB82-\nSTDTRTCH BAL   R2,PUTLINE         OUTPUT VTOC HEADING.            -CWB-\n         MVC   MSGBUF(VHEADLEN),VTOCHEAD                          -CWB-\n         CLI   COUNTFLG,C'Y'      COUNTING BLOCKS?              -ARB82-\n         BE    COUNTHED           YES, SET UP HEADINGS          -ARB82-\n         MVC   VTOCHEDE(L'VTOCHEDH),VTOCHEDH                    -ARB82-\n         B     PUTVTOCH                                         -ARB82-\nCOUNTHED MVC   VTOCHEDE(L'VTOCHEDC),VTOCHEDC                    -ARB82-\nPUTVTOCH BAL   R2,PUTLINE         OUTPUT COLUMN HEADINGS.       -ARB82-\n         MVC   MSGBUF(L'VTOCHED2),VTOCHED2                        -CWB-\n         MVI   VTOCOUT,C'Y'       NOTE VTOC BEING WRITTEN       -ARB82-\n         MVI   MSGBUF,C'0'        FORCE SPACE OF FIRST LINE     -ARB82-\n         CLI   POSFLG,C'Y'        DID WE START AT THE FRONT?    -ARB82-\n         BNE   NOPOSLIN           YES, NO \"MAP STARTED\" LINE    -ARB82-\n         MVC   MSGBUF+1(132),BLANKBUF                           -ARB82-\n         MVC   MSGBUF+1(8),=23C'-'     MSG LINE INDICATOR       -ARB82-\n         MVC   MSGBUF+9(12),=C'MAP STARTS -'                    -ARB82-\n         LA    R2,MSGBUF+22       MSG INSERTION POINT           -ARB82-\n         CLC   INFLPOS,=H'1'      LABEL=1?                      -ARB82-\n         BNH   NOPFILE            YES.                          -ARB82-\n         MVC   0(6,R2),=C'LABEL='                               -ARB82-\n         LH    R1,INFLPOS         CONVERT LABEL # TO DECIMAL    -ARB82-\n         CVD   R1,BADLNGTH                                      -ARB82-\n         OI    BADLNGTH+7,X'0F'                                 -ARB82-\n         UNPK  6(4,R2),BADLNGTH                                 -ARB82-\n         MVI   11(R2),C'+'        SEPARATE FROM OTHER WORDS     -ARB82-\n         LA    R2,13(,R2)                                       -ARB82-\nNOPFILE  CLC   SKPEOVNO,=F'0'     ANY EOVS SKIPPED?             -ARB82-\n         BE    NOPEOV             NO.                           -ARB82-\n         MVC   0(8,R2),=C'SKIPEOV='                             -ARB82-\n         L     R1,SKPEOVNO        CONVERT EOVNUMB TO DECIMAL    -ARB82-\n         CVD   R1,BADLNGTH                                      -ARB82-\n         OI    BADLNGTH+7,X'0F'                                 -ARB82-\n         UNPK  8(3,R2),BADLNGTH                                 -ARB82-\n         MVI   12(R2),C'+'        SEPARATE FROM OTHER WORDS     -ARB82-\n         LA    R2,14(,R2)                                       -ARB82-\nNOPEOV   CLC   SKIPTMVL,=F'0'     ANY TAPE MARKS SKIPPED?       -ARB82-\n         BE    NOPTM              NO.                           -ARB82-\n         MVC   0(7,R2),=C'SKIPTM='                              -ARB82-\n         L     R1,SKIPTMVL        CONVERT TM NUMB TO DECIMAL    -ARB82-\n         CVD   R1,BADLNGTH                                      -ARB82-\n         OI    BADLNGTH+7,X'0F'                                 -ARB82-\n         UNPK  7(4,R2),BADLNGTH                                 -ARB82-\n         B     PUTPOS             GO WRITE START LINE           -ARB82-\nNOPTM    S     R2,=F'2'           BACK UP OVER +                -ARB82-\n         MVI   0(R2),C' '         AND COVER IT UP               -ARB82-\nPUTPOS   BAL   R2,PUTLINE3                                      -ARB82-\n         DC    C'VSTART'                                        -ARB82-\n         MVI   MSGBUF,C' '        REMOVE CARRIAGE CONTROL       -ARB82-\nNOPOSLIN MVI   VTOCPAGE,X'FF'     SHOW FIRST ENTRY OF PAGE      -ARB82-\n         L     R4,FRSTVTOC        GET ADDRESS OF FIRST VTOC BLOCK.-CWB-\n         SR    R8,R8              CLEAR R8 FOR 1-BYTE COUNTS.     -CWB-\n         LA    R3,8(R4)           LOAD 1ST ENTRY &              -ARB82-\n         IC    R8,0(R4)           NUMBER OF ENTRIES             -ARB82-\n         STM   R3,R4,PAGESTRT     STORE FOR NOTE OUTPUT         -ARB82-\n         ST    R8,PAGESTRT+8                                    -ARB82-\n         B     NEXTLINE                                         -ARB82-\nNEXTVBLK LA    R3,8(R4)           GET ADDRESS OF FIRST ENTRY IN   -CWB-\n*                                      THE VTOC BLOCK.            -CWB-\n         IC    R8,0(R4)           GET THE NUMBER OF ENTRIES IN    -CWB-\n*                                      THIS VTOC BLOCK.           -CWB-\nNEXTLINE LH    R2,VTOCMSG#        GET # OF NOTES FOR THIS ENTRY -ARB82-\n         LTR   R2,R2              ARE THERE ANY?                -ARB82-\n         BZ    *+8                                              -ARB82-\n         LA    R2,1(,R2)          IF SO, RESERVE SEPARATION     -ARB82-\n         AR    R2,R2              COMPUTE NOTE SPACE            -ARB82-\n         AH    R2,QLINE#          COMPUTE TOTAL RESERVED SPACE  -ARB82-\n         STH   R2,QLINE#                                        -ARB82-\n         CLI   VTOCPAGE,X'FF'     FIRST ENTRY OF PAGE           -ARB82-\n         BE    VTOCENT            YES, LET IT OVERFLOW          -ARB82-\n         LA    R2,2(,R2)          ALLOW A LITTLE EXTRA          -ARB82-\n         A     R2,LINENO          NO, SEE IF NOTES WILL FIT     -ARB82-\n         C     R2,LINECNT                                       -ARB82-\n         BH    PAGEFULL           IF NOT, SPILL QUEUED NOTES    -ARB82-\nVTOCENT  MVI   VTOCPAGE,X'00'     RESET FIRST LINE FLAG         -ARB82-\n         MVC   MSGBUF+1(132),BLANKBUF  BUILD VTOC ENTRY LINE:   -ARB82-\n         MVC   MSGBUF+1(4),VTOCSEQN    DATA SET SEQUENCE NUMBER.  -CWB-\n         CLI   MSGBUF+1,C'-'      SPECIAL VTOC LINE?            -ARB82-\n         BNE   NOEOVLIN           NO.                           -ARB82-\n         MVC   MSGBUF+5(4),=23C'-'     YES, PAD WITH HYPHENS    -ARB82-\n         MVC   MSGBUF+9(17),VTOCDSN    LINE ID STORED AS DSN    -ARB82-\n         MVC   MSGBUF+26(8),=23C'-'     ADD MORE AFTER          -ARB82-\n         B     VTOCNONO           NO OTHER INFO ON LINE         -ARB82-\nNOEOVLIN MVC   MSGBUF+7(17),VTOCDSN    DATA SET NAME.           -ARB82-\n         MVC   MSGBUF+26(3),VTOCLTYP   LABEL TYPE.              -ARB82-\n         MVC   MSGBUF+32(4),VTOCRECF   RECFM.                   -ARB82-\n         MVC   MSGBUF+38(5),VTOCLREC   LRECL.                   -ARB82-\n         MVC   MSGBUF+46(5),VTOCBLKS   BLKSIZE.                 -ARB82-\n         MVC   MSGBUF+54(7),VTOCEXPR   EXPIRATION DATE.         -ARB82-\n         MVC   MSGBUF+63(6),VTOCOUNT   NUMBER OF BLOCKS.        -ARB82-\n         CLI   COUNTFLG,C'Y'      IN COUNT MODE?                -ARB82-\n         BNE   VTOCHIST           NO, GIVE HISTORY INSTEAD      -ARB82-\n         MVC   MSGBUF+74(5),VTOCMAXB   MAXIMUM BLOCK SIZE.      -ARB82-\n         MVC   MSGBUF+83(5),VTOCMINB   MINIMUM BLOCK SIZE.      -ARB82-\n         MVC   MSGBUF+92(5),VTOCAVGB   AVERAGE BLOCK SIZE.      -ARB82-\n         B     PUTVTOC                                          -ARB82-\nVTOCHIST MVC   MSGBUF+73(8),VTOCJOBN   JOB NAME.                -ARB82-\n         MVC   MSGBUF+83(8),VTOCSTEP   STEP NAME.               -ARB82-\n         MVC   MSGBUF+93(7),VTOCCREA   CREATION DATE.           -ARB82-\nPUTVTOC  TM    WRTFLG,X'01'       WAS THIS A COPY OPERATION?    -ARB82-\n         BZ    NOVCOPY            NO.                           -ARB82-\n         MVC   MSGBUF+101(5),=C'COPY=' YES, ADD OUTPUT SEQ      -ARB82-\n         MVC   MSGBUF+106(4),VTOCOUSQ   OR TM NUMBER            -ARB82-\nNOVCOPY  CLC   VTOCMSG#,=H'0'     ANY NOTES FOR THIS ENTRY?     -ARB82-\n         BE    VTOCNONO           NO.                           -ARB82-\n         MVC   MSGBUF+115(16),=C'-->SEE NOTE A<--' YES,         -ARB82-\n         LH    R2,NOTENUM         INSERT EYE CATCHER            -ARB82-\n         IC    R2,NOTELETS-1(R2)  ADD NOTE LETTER               -ARB82-\n         STC   R2,MSGBUF+127                                    -ARB82-\n         LH    R2,NOTENUM         INCREASE NOTE NUMBER          -ARB82-\n         LA    R2,1(,R2)                                        -ARB82-\n         STH   R2,NOTENUM                                       -ARB82-\nVTOCNONO BAL   R2,PUTLINE3        OUTPUT THE LINE.              -ARB82-\n         DC    CL6'VTOC--'        REQUIRED DEAD SPACE.            -CWB-\n         MVI   MSGBUF,C' '        SINGLE SPACE NEXT LINE        -ARB82-\n         LA    R3,VTOCSIZE(R3)    ADVANCE TO NEXT ENTRY.          -CWB-\n         BCT   R8,NEXTLINE        LOOP IF MORE IN THIS BLOCK.     -CWB-\n         L     R4,0(R4)           GET ADDRESS OF NEXT BLOCK.      -CWB-\n         LA    R4,0(R4)           CLEAR HIGH-ORDER BYTE.          -CWB-\n         LTR   R4,R4              IS FOREWARD POINTER ZERO?       -CWB-\n         BNZ   NEXTVBLK           IF NOT, GO DO NEXT BLOCK.     -ARB82-\n         MVC   MSGBUF+1(132),BLANKBUF                           -ARB82-\n         MVC   MSGBUF+1(8),=23C'-'     BUILD STOP LINE          -ARB82-\n         MVC   MSGBUF+9(9),=C'MAP ENDED'   WHICH MAY NOT GO OUT -ARB82-\n         CLI   OKCODE+3,12        I/O ERROR TERMINATION?        -ARB82-\n         BNE   NORMSTOP           NO.                           -ARB82-\n         MVC   MSGBUF+19(17),=C'DUE TO I/O ERRORS'              -ARB82-\n         B     PUTSTOP            GO WRITE KISSOFF LINE         -ARB82-\nNORMSTOP CLI   TMQUIT,X'FF'       MAXTM STOP?                   -ARB82-\n         BNE   EOVQUIT            NO, STOPEOV REACHED           -ARB82-\n         MVC   MSGBUF+19(9),=C'- STOPTM='  YES, SAY WHY         -ARB82-\n         L     R1,STOPTMNO        CONVERT TM NO TO DECIMAL      -ARB82-\n         LA    R2,MSGBUF+28       WHERE TO PUT NUMBER           -ARB82-\n         B     STOPLINE                                         -ARB82-\nEOVQUIT  L     R1,STPEOVNO        IS STOPEOV 1?                 -ARB82-\n         CH    R1,=H'1'                                         -ARB82-\n         BNH   PAGEFULL           NO COMMENT IF SO              -ARB82-\n         MVC   MSGBUF+19(10),=C'- STOPEOV='                     -ARB82-\n         LA    R2,MSGBUF+29                                     -ARB82-\nSTOPLINE CVD   R1,BADLNGTH                                      -ARB82-\n         OI    BADLNGTH+7,X'0F'                                 -ARB82-\n         UNPK  0(4,R2),BADLNGTH   INSERT NUMBER                 -ARB82-\nPUTSTOP  BAL   R2,PUTLINE3        GO WRITE FINAL LINE           -ARB82-\n         DC    C'VSTOP-'                                        -ARB82-\nPAGEFULL CLC   QLINE#,=H'2'       ARE ANY NOTES PENDING?        -ARB82-\n         BE    VEJECT             NO, JUMP TO NEXT PAGE         -ARB82-\n         OI    OKCODE+3,8         SET RC=8 FOR NOTES ISSUED     -ARB82-\n         MVC   NOTENUM,=H'1'      YES, RESET NOTE COUNTER       -ARB82-\n         LM    R14,R0,PAGESTRT    RELOAD NOTE STARTING POINT    -ARB82-\n         STM   R3,R4,PAGESTRT     STORE NEW ONES FOR NEXT PAGE  -ARB82-\n         ST    R8,PAGESTRT+8                                    -ARB82-\n         LR    R3,R14             COPY OVER TO STANDARD REGS    -ARB82-\n         LR    R4,R15                                           -ARB82-\n         LR    R8,R0                                            -ARB82-\n         MVC   MSGBUF,BLANKBUF    BLANK OUTPUT LINE             -ARB82-\n         MVI   MSGBUF,C'0'        ADD CARRIAGE CNTL             -ARB82-\n         BAL   R2,PUTLINE2        ADD SEPARATOR LINE            -ARB82-\n         MVC   MSGBUF+30(13),=C'*** NOTES ***'                  -ARB82-\nNEXTNOTS CLC   VTOCMSG#,=H'0'     ANY NOTES FOR THIS ENTRY?     -ARB82-\n         BE    NOTESKIP           NO.                           -ARB82-\n         CLC   NOTENUM,=H'1'      YES, FIRST ON THE PAGE?       -ARB82-\n         BE    NOTE1              YES.                          -ARB82-\n         MVC   MSGBUF,BLANKBUF    NO, SEPARATE FROM PREVIOUS    -ARB82-\n         MVI   MSGBUF,C'0'                                      -ARB82-\n         BAL   R2,PUTLINE2                                      -ARB82-\n         MVC   MSGBUF+25(23),=23C'-'                            -ARB82-\nNOTE1    LA    R6,VTOCSTAT        POINT TO STATUS BYTES         -ARB82-\n         LH    R7,VTOCMSG#        NUMBER OF NOTES TO EXPECT     -ARB82-\n         MVC   MSGBUF,BLANKBUF                                  -ARB82-\n         MVC   MSGBUF+2(3),=C'(A)'     ADD NOTE SET ID          -ARB82-\n         LH    R2,NOTENUM                                       -ARB82-\n         IC    R1,NOTELETS-1(R2)  FROM THE ALPHABET             -ARB82-\n         STC   R1,MSGBUF+3                                      -ARB82-\n         LA    R2,1(,R2)          BUMP NOTE COUNTER             -ARB82-\n         STH   R2,NOTENUM                                       -ARB82-\nNEXTNOTE MVI   MSGBUF,C'0'        DOUBLE SPACE ALL NOTES        -ARB82-\nFINDNOTE CLI   0(R6),0            IS THIS NOTE WANTED?          -ARB82-\n         BNE   NOTETHIS           YES.                          -ARB82-\n         LA    R6,1(,R6)          NO, KEEP LOOKING              -ARB82-\n         B     FINDNOTE                                         -ARB82-\nNOTETHIS LR    R1,R6                                            -ARB82-\n         LA    R0,VTOCSTAT        COMPUTE NUMBER OF NOTE        -ARB82-\n         SR    R1,R0                                            -ARB82-\n         SLL   R1,2                                             -ARB82-\n         L     R2,NOTES(R1)       PICK UP LOCATION &            -ARB82-\n         IC    R1,NOTES(R1)       LENGTH OF MESSAGE             -ARB82-\n         EX    R1,MVNOTE          MOVE INTO MESSAGE BUFFER      -ARB82-\n         BAL   R2,PUTLINE3        GO WRITE OUT THE NOTE         -ARB82-\n         DC    C'NOTE--'                                        -ARB82-\n         MVC   MSGBUF,BLANKBUF    CLEAR MSG BUFFER AGAIN        -ARB82-\n         LA    R6,1(,R6)                                        -ARB82-\n         BCT   R7,NEXTNOTE                                      -ARB82-\nNOTESKIP LA    R3,VTOCSIZE(R3)    LOCATE NEXT ENTRY             -ARB82-\n         C     R3,PAGESTRT        THRU WITH THIS PAGE?          -ARB82-\n         BE    NOTESOUT           YES.                          -ARB82-\n         BCT   R8,NEXTNOTS                                      -ARB82-\n         L     R4,0(,R4)          PROCEEDING TO NEXT BLOCK      -ARB82-\n         LTR   R4,R4              IF NECESSARY & POSSIBLE       -ARB82-\n         BZ    EXIT               IF NOT, WE'RE DONE            -ARB82-\n         LA    R3,8(R4)                                         -ARB82-\n         IC    R8,0(R4)                                         -ARB82-\n         C     R3,PAGESTRT        DONE WITH THIS PAGE?          -ARB82-\n         BNE   NEXTNOTS           NO, CONTINUE                  -ARB82-\nNOTESOUT MVC   NOTENUM,=H'1'      RESET NOTE COUNTER TO 1       -ARB82-\n         MVC   QLINE#,=H'2'                                     -ARB82-\n         LM    R3,R4,PAGESTRT     RESTORE VTOC SCAN REGS        -ARB82-\n         L     R8,PAGESTRT+8                                    -ARB82-\nVEJECT   LTR   R4,R4              ANYTHING LEFT TO WRITE?       -ARB82-\n         BZ    EXIT               NO, TERMINATE                 -ARB82-\n         LA    R0,100             YES, FORCE NEW PAGE           -ARB82-\n         BAL   R2,PAGECHK                                       -ARB82-\n         MVI   VTOCPAGE,X'FF'     SET TOP OF PAGE FLAG          -ARB82-\n         B     NEXTLINE           GO RESUME VTOC LISTING        -ARB82-\n         SPACE 3\nMVNOTE   MVC   MSGBUF+8(0),0(R2)  MOVE NOTE TO MSGBUF           -ARB82-\nNOTES    DC    12A(0)             SPACE FOR NOTE POINTERS       -ARB82-\n         ORG   NOTES                                            -ARB82-\n         DC    AL1(L'NOTEIO-1),AL3(NOTEIO)                      -ARB82-\n         DC    AL1(L'NOTENHDR-1),AL3(NOTENHDR)                  -ARB82-\n         DC    AL1(L'NOTENTRL-1),AL3(NOTENTRL)                  -ARB82-\n         DC    AL1(L'NOTELBSQ-1),AL3(NOTELBSQ)                  -ARB82-\n         DC    AL1(L'NOTEBLP-1),AL3(NOTEBLP)                    -ARB82-\n         DC    AL1(L'NOTENCON-1),AL3(NOTENCON)                  -ARB82-\n         DC    AL1(L'NOTEDATA-1),AL3(NOTEDATA)                  -ARB82-\n         DC    AL1(L'NOTECOUN-1),AL3(NOTECOUN)                  -ARB82-\n         DC    AL1(L'NOTETRNC-1),AL3(NOTETRNC)                  -ARB82-\n         DC    AL1(L'NOTEAXLB-1),AL3(NOTEAXLB)                  -ARB82-\n*        ORG   NOTES+44                                         -DEBUG-\n*        DC    AL1(L'NOTEDBUG-1),AL3(NOTEDBUG)                  -DEBUG-\n         ORG   ,                                                -ARB82-\nPAGESTRT DS    3A                 VTOC ADDRS FOR PAGE START     -ARB82-\nINDEX    DC    F'0'               NOCONV=+4, 7-TRK=+32, +DEN*8\n*TBLORG EQU BPIBGTBL-20           THEORETICAL ORIGIN OF BPIBGTBL\n*                                 WHICH IS LIKE A 3-D ARRAY:\n*                                 7-TRK=+40,  NOCONV=+4, +DEN*8 -ARB79-\nBPIBGTBL DC    H'601,800'   800 BPI NOCONV 9-TRK\n         DC    H'1,1'      1600 BPI CONV   9-TRK (NOT USED)\n         DC    H'651,1600' 1600 BPI NOCONV 9-TRK\n         DC    H'1,1'      6250 BPI CONV   9-TRK (NOT USED)     -ARB79-\n         DC    H'300,6250' 6250 BPI NOCONV 9-TRK                -ARB79-\n         DC    H'752,150'   200 BPI CONV   7-TRK\n         DC    H'752,200'   200 BPI NOCONV 7-TRK\n         DC    H'751,417'   556 BPI CONV   7-TRK\n         DC    H'751,556'   556 BPI NOCONV 7-TRK\n         DC    H'751,600'   800 BPI CONV   7-TRK\n         DC    H'751,800'   800 BPI NOCONV 7-TRK\nTMLENGTH DC    H'3750'  DEFAULT TAPEMARK LENGTH*1000 (9-TRK)    -ARB82-\nENDMSG   DC    C'0PROCESSING OF THIS TAPE COMPLETED'            -ARB79-\n         DC    C':    TOTAL BYTES READ='\nBYTES    DC    C'XXXXXXXXXX'                                    -ARB79-\n         DC    C'    NUMBER OF DATA BLOCKS READ='\nNBLKS    DC    C'XXXXXX'\nERRSUMSG DC    C'0NUMBER OF I/O ERRORS=XXXXX'                   -ARB82-\nLNGTHEST DC    C'0LENGTH ESTIMATE=XXXX FEET YY INCHES ASSUMING DEN=X AN*\n               D TRTCH=STANDARD           '\nLNGTHACC DC    C'0(LENGTH ESTIMATE USUALLY ACCURATE WITHIN PLUS OR MINU*\n               S TEN PERCENT;  ALMOST ALWAYS WITHIN TWENTY PERCENT)'\nNOTENUM  DC    H'1'               CURRENT NOTE NUMBER           -ARB82-\nQLINE#   DC    H'2'               QUEUED NOTE LINES             -ARB82-\nNOTELETS DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ' NOTE LABELS        -ARB82-\nVTOCPAGE DC    X'FF'              FIRST VTOC ENTRY OF PAGE FLAG -ARB82-\nVTOCHEDH DC    C'JOB NAME  STEP      CREATED'                   -ARB82-\nVTOCHEDC DC    C'MAX BLK  MIN BLK  AVG BLK'                     -ARB82-\n#IO      EQU   0                  I/O ERROR FLAG NUMBER         -ARB82-\nNOTEIO   DC    C'ONE OR MORE I/O ERRORS OCCURRED PROCESSING THIS DATA S*\n               ET'                                              -ARB82-\n#NHDR    EQU   1                  HEADERS MISSING NUMBER        -ARB82-\nNOTENHDR DC    C'NO VALID HEADER LABELS PRESENT FOR THIS DATA SET'     *\n                                                                -ARB82-\n#NTRL    EQU   2                  TRAILERS MISSING NUMBER       -ARB82-\nNOTENTRL DC    C'NO VALID TRAILER LABELS PRESENT FOR THIS DATA SET'    *\n                                                                -ARB82-\n#LBSQ    EQU   3                  LABEL SEQUENCE ERROR NUMBER   -ARB82-\nNOTELBSQ DC    C'DATA FILE CONTAINS LABELS OR LABELS OUT OF SEQUENCE'  *\n                                                                -ARB82-\n#BLP     EQU   4                  LABEL TYPE CHANGE NUMBER      -ARB82-\nNOTEBLP  DC    C'LABEL TYPE SET TO BLP DUE TO INCONSISTENCY WITH PREVIO*\n               US DATA SETS'                                    -ARB82-\n#NCON    EQU   5                  LABELS INCONSISTENT NUMBER    -ARB82-\nNOTENCON DC    C'HEADER AND TRAILER LABELS INCONSISTENT FOR THIS DATA S*\n               ET'                                              -ARB82-\n#DATA    EQU   6                  DATA IN LABEL FILE NUMBER     -ARB82-\nNOTEDATA DC    C'DATA RECORDS FOUND IN LABEL FILE'              -ARB82-\n#COUN    EQU   7                  COUNT CONFLICT NUMBER         -ARB82-\nNOTECOUN DC    C'THE BLOCK COUNT IN THE TRAILER LABEL IS INCORRECT'    *\n                                                                -ARB82-\n#TRNC    EQU   8                  LABEL TRUNCATION NUMBER       -ARB82-\nNOTETRNC DC    C'LABELS TRUNCATED TO 80 BYTES DURING COPY'      -ARB82-\n#AXLB    EQU   9                  NON-STD LABEL NUMBER          -ARB82-\nNOTEAXLB DC    C'UNSUPPORTED ANS LABELS FOR THIS FILE NOT COPIED'      *\n                                                                -ARB82-\n*#DBUG    EQU  11                                               -DEBUG-\n*NOTEDBUG DC   C'DSNAME FOR THIS FILE BEGINS WITH THE LETTER T' -DEBUG-\n         EJECT\nSAVE     DS    9D                 SAVE AREA FOR TAPESCAN        -ARB79-\nSAVE2    DS    9D                 DUPLICATE SAVE AREA FOR SYNAD -ARB79-\n         LTORG\nASCWARN  DC    C'0ASCII TRANSLATION TO BE PERFORMED - RECFM V OR D DATA*\n               SETS MAY NOT REMAIN VALID'                       -ARB84-\nLABLSIZE DC    C'0WARNING - ABOVE LABEL LONGER THAN 80 CHARACTERS'     *\n                                                                -ARB84-\nJFCBIN   DC    22D'0'             176 BYTES FOR INPUT JFCB      -ARB82-\nJFCBOUT  DC    22D'0'             OUTPUT DD'S JFCB              -ARB82-\nJOUTFLSQ EQU   JFCBOUT+JFCBFLSQ                                 -ARB82-\nSYSPRINT DCB   DDNAME=SYSPRINT,MACRF=PM,DSORG=PS,RECFM=FA,             *\n               BLKSIZE=133,LRECL=133                            -ARB82-\nINPUT    DCB   DDNAME=INPUT,MACRF=RC,DSORG=PS,RECFM=U,NCP=1,           *\n               BLKSIZE=32760,EODAD=EODS,SYNAD=SYNERR,EXLST=EXITLIST    *\n                                                                -ARB82-\nOUTPUT   DCB   DDNAME=OUTPUT,MACRF=(RC,WC),DSORG=PS,RECFM=U,NCP=1,     *\n               BLKSIZE=32760,EODAD=EOLABEL,SYNAD=SYNERR,EXLST=EXLSTOUT *\n                                                                -ARB82-\nNUBTABL  DS    0C                 NUMERIC CHECK TABLE             -HMD-\n         DC    256XL1'FD'                                         -HMD-\n         ORG   NUBTABL+C'0'       NUMBERS ONLY                    -HMD-\n         DC    10X'00'                                            -HMD-\n         ORG   ,                  BACK TO REALITY                 -HMD-\n         SPACE 5\nVTOC     DSECT\nVTOCSEQN DS    CL4                SEQUENCE NUMBER                 -CWB-\nVTOCDSN  DS    CL17               DATA SET NAME.                  -CWB-\nVTOCLTYP DS    CL3                LABEL TYPE.                   -ARB82-\nVTOCRECF DS    CL4                RECFM.                          -CWB-\nVTOCLREC DS    CL5                LRECL.                          -CWB-\nVTOCBLKS DS    CL5                BLKSIZE.                        -CWB-\nVTOCMAXB DS    CL5                MAXIMUM BLOCK SIZE.             -CWB-\nVTOCMINB DS    CL5                MINIMUM BLOCK SIZE.             -CWB-\nVTOCAVGB DS    CL5                AVERAGE BLOCK SIZE.             -CWB-\nVTOCOUNT DS    CL6                BLOCK COUNT.                    -CWB-\nVTOCCREA DS    CL8                CREATION DATE.                  -CWB-\nVTOCJOBN DS    CL8                JOB NAME.                       -CWB-\nVTOCSTEP DS    CL8                STEP NAME.                      -CWB-\nVTOCEXPR DS    CL8                EXPIRATION DATE.                -CWB-\nVTOCOUSQ DS    CL4                OUTPUT SEQUENCE NUMBER        -ARB82-\nVTOCCSIZ EQU   *-VTOC             SIZE OF CHAR PART OF ENTRY    -ARB82-\nVTOC2    DS    0H                 BINARY PART OF VTOC ENTRY     -ARB82-\nVTOCMSG# DS    H                  NUMBER OF NOTES FOR ENTRY     -ARB82-\nVTOCSTAT DS    XL12               FLAGS FOR POSSIBLE ERRORS     -ARB82-\nVTOCBSIZ EQU   *-VTOC2            SIZE OF BINARY VTOC           -ARB82-\n         DS    0D                 ADVANCE TO DOUBLE WORD BNDRY.   -CWB-\nVTOCSIZE EQU   *-VTOC             SIZE OF VTOC ENTRY.             -CWB-\nVTOCEPB  EQU   10                 NUMBER OF ENTRIES PER BLOCK.    -CWB-\nVTOCBLSZ EQU   VTOCEPB*VTOCSIZE+8 SIZE OF VTOC BLOCK.             -CWB-\n         END   TAPESCAN                                         -ARB82-\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TAPESCUR": {"ttr": 10506, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         TITLE 'TAPESCUR -- TAPESCAN SECURITY EXIT FOR ACF2 (VOLUME PRO*\n               TECTION ONLY)'\nTAPESCUR CSECT\n         SPACE\n         REGISTER\n         SPACE\n         SAVE  (14,12),,*\n         LR    R12,R15            COPY BASE REG\n         USING TAPESCUR,R12\n         LR    R11,R13            COPY SAVE AREA POINTER\n         CNOP  0,4                GET FULLWORD ALIGNMENT\n         BAL   R13,PASTSA         SET UP NEW SAVE AREA\nSAVEAREA DC    18A(0)\nPASTSA   ST    R11,4(,R13)        CHAIN SAVE AREAS\n         ST    R13,8(,R11)\n         LR    R11,R1             COPY PARM POINTER\n         USING SCURPARM,R11\n         XC    ACDSV(ACFSPRML),ACDSV   CLEAR ACF2 PARM LIST\n         MVI   ACFSPREQ,ACFSPRVL  VALIDATE BY VOLSER\n         MVI   ACFSPID1,ACFSPIUR  THIS IS A \"USER CALL\"\n         MVI   ACFSPAC1,ACFSPAIN  ASSUME INPUT VALIDATION\n         MVC   DDNAME,=CL8'INPUT'\n         CLI   SECIOTYP,C'I'      IS IT?\n         BE    INCHECK            YES.\n         MVI   ACFSPAC1,ACFSPAIO  NO, VALIDATE FOR INOUT\n         MVC   DDNAME,=CL8'OUTPUT'\nINCHECK  MVC   ACFSPDDN,=A(DDNAME)     SET UP DDNAME PTR\n         MVC   DSNAME(17),SECDSN  COPY DSNAME TO PARM LIST\n         MVC   ACFSPDSN,=A(DSNAME)     EVEN THO WE WILL NOT USE IT\n         LA    R2,SECVOL          STORE VOL PTR FOR ACF2\n         ST    R2,ACFSPVOL\n         L     R2,SECDCB          FIND THE DCB ADDRESS\n         LH    R2,40(,R2)         FIND THE TIOT OFFSET\n         L     R5,16              FIND OUR TCB\n         L     R5,0(,R5)\n         L     R5,4(,R5)\n         L     R5,12(,R5)         FIND THE TIOT\n         AR    R2,R5              FIND THE TIOT ENTRY\n         MVC   ACFSPUCB,16(R2)    COPY OVER UCB ADDR FOR ACF2\n         ACFSVC ACDSV,TYPE=S,NONE=ALLOW,CVT=FIND ASK ACF2\n         LTR   R15,R15            IS IT OK?\n         BZ    ALLOW              YES.\n         LA    R15,4              SET NO RETURN CODE\n         B     RETURN\nALLOW    DS    0H                 ACF2 SAYS OK OR IS NOT RUNNING\nRETURN   L     R13,4(,R13)        RESTORE PREV SAVE AREA\n         RETURN (14,12),RC=(15)   AND RETURN\n         SPACE\n         LTORG\n         SPACE\nDSNAME   DC    CL44' '            DSNAME BUFFER\nDDNAME   DC    CL8' '             DDNAME BUFFER\n         ACDSV DSECT=NO\n         SPACE\nSCURPARM DSECT ,                  TAPESCAN PARM LIST FORMAT\nSECDCB   DS    A                  ADDR OF TAPE DCB\nSECIOTYP DS    CL1                I=INPUT, O=OUTPUT\nSECLABEL DS    CL1                A=AL,N=NL,S=SL\nSECDSN   DS    CL17               DSN OF FIRST FILE ON TAPE\nSECVOL   DS    CL6                TAPE VOLSER (FROM LABEL OR JCL)\n         SPACE\n         PRINT NOGEN\n         ACCVT DSECT=YES\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TAPESUC@": {"ttr": 10753, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "1\n-\n      This  document discusses  some  of the  TAPESCAN  features related  to\n      security/safety.\n0     TAPESCAN must  be installed  as an authorized  program to  function at\n      all, as it uses OPEN J to force LABEL=BLP.   TAPESCAN also assumes key\n      0 for a brief time in two cases:  when beginning to process a new file\n      of  a 7-track  SL  tape,  and  when  sending expiration  date/password\n      messages to the operator.  In the former case, key 0 is used to modify\n      the  DEB to  change  the  file mask  (since  labels  are written  with\n      TRTCH=ET regardless of  the data TRTCH).   In the latter  case,  key 0\n      causes the operator prompts to be written  with a \"*\" flag rather than\n      a \"@\" flag.  If your operators are on their toes, they ought to refuse\n      to enter a password in response to  an @-flagged message,  since it is\n      likely to be a counterfeit.\n0     To avoid damaging  an innocent tape,  TAPESCAN  provides the following\n      safety feature:   It  insists that the labelling of an  output tape be\n      accurately described in the JCL.   If the tape is SL or AL, the output\n      volser  must be  correct.    This minimizes  the  possibility than  an\n      incorrect output  tape will be mounted  and destroyed.   By  using the\n      UNLABEL option,   you can  ask TAPESCAN  to change  the label  type or\n      volser of a tape;  however,  the JCL must accurately describe the tape\n      as it exists before TAPESCAN writes to it.\n0     TAPESCAN provides  a number of  security-oriented features  to prevent\n      its  use  to perform  operations  which  the underlying  system  would\n      properly prevent.   These features,  in general,  are only invoked for\n      the first file  of a tape,  since the operating  system cannot enforce\n      security on a tape unless all files are protected similarly.\n0     When writing an output tape,   TAPESCAN simulates OPEN expiration date\n      processing (for the first file).\n0     For both  input and  output tapes,   TAPESCAN simulates  OPEN password\n      processing (for the  first file).   If a tape is  read-protected and a\n      valid  password  is  not  given,   TAPESCAN  will  still  print  label\n      information,  but will not read or print anything from its data files.\n      The password  check is ordinarily  done using the  17-character dsname\n      from the data set label;  however,  if a longer dsname is given in the\n      JCL which truncates  to the name on  the label,  that name  is checked\n      instead.\n0     There are \"accessibility\" flags in ANS  volume and header labels which\n      will inhibit  any access other than  via BLP.   TAPESCAN  honors these\n      flags and refuses to read or overwrite such a tape.\n0     TAPESCAN supports an installation security exit, which is called after\n      the volume label and first header label have been read for each of the\n      input and output tape.  The exit (named TAPESCUR) is located by WXTRN,\n      and need not be  provided if its function is not  required.   The exit\n      may allow or prevent access to the  tape.   A sample exit which issues\n      an ACF2 user call to determine whether the tape is volume protected is\n      provided as an example.\n0     The linkage conventions for TAPESCUR are:\n0     On entry, register 1 addresses the following parm list:\n0     SECDCB    DS    A        address of the open tape DCB\n      SECIOTYP  DS    CL1      'I'=input tape, 'O'=output tape\n      SECLABEL  DS    CL1      'N'=NL, 'A'=AL, 'S'=SL\n      SECDSN    DS    CL17     dsname from label for SL/AL tape\n      SECVOL    DS    CL6      volser of tape (from label if SL/AL)\n0     On exit, TAPESCUR should put 0 in register 15 to allow access, or some\n      other value to deny access.  To improve communication of the problem\n      to the user, it is recommended that TAPESCUR not issue an ABEND.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSOSUMM": {"ttr": 10755, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "% title TSO functional accounting summary report program;\n(**********************************************************************)\n(*                                                                    *)\n(* Program TSOSUMM - to analyze SMF type 32 records (TSO functional   *)\n(*                   accounting), and produce a summary report. The   *)\n(*                   records are assumed to be in the \"DETAILS\"       *)\n(*                   format, as modified by the Rice RUA11 usermods.  *)\n(*                                                                    *)\n(*                   In addition to the SMF records (read from file   *)\n(*                   SMFIN), TSOSUMM also reads the file CMDIN, which *)\n(*                   should contain the definitions of interesting    *)\n(*                   command, subcommands, and their aliases.         *)\n(*                   Commands which are not mentioned here will still *)\n(*                   be reported, but aliases and subcommands for     *)\n(*                   these will not be recognized.                    *)\n(**********************************************************************)\n% skip 3;\nprogram TSOSUMM(SMFIN,CMDIN,OUTPUT);   (* TSO summary MAIN program    *)\n% skip 2;\nconst PAGESIZE=55;                     (* my preferred page size      *)\n      PAGESIZE_1=PAGESIZE-1;           (* one less than PAGESIZE      *)\n% skip 2;\n(**********************************************************************)\n(* The TSOSUMM command/subcommand data is organized into two data     *)\n(* bases, the input data base and the statistical data base. Each     *)\n(* data base is organized as a collection of linked lists of elements *)\n(* of type CMDENT, using variants for those fields which are common   *)\n(* to only one data base. One type is used rather than two to allow   *)\n(* the same housekeeping procedure to be used for both data bases.    *)\n(**********************************************************************)\n% skip 2;\ntype CMDTYPE = (STAT,INPUT);           (* Data base type designator   *)\n     CMDPTR  = @CMDENT;                (* Command entry pointer       *)\n     CMDENT  = record                  (* command data base element   *)\n                 NEXTCMD: CMDPTR;      (* next element in list        *)\n                 NAME:    ALFA;        (* name of command/subcmd      *)\n            case CTYPE: CMDTYPE of\n                 INPUT:                (* these fields belong to      *)\n                                       (* INPUT elements              *)\n                     (TRUENAME,SUBNAME: ALFA;\n                                       (* true command and subcommand *)\n                                       (* name for input name         *)\n                      TRUECMD, SUBCMD : CMDPTR);\n                                       (* pointer to STAT element for *)\n                                       (* true command & subcommand   *)\n                 STAT:                 (* these fields belong to      *)\n                                       (* STAT elements               *)\n                     (SUBCMDHD: CMDPTR;\n                                       (* pointer to element for the  *)\n                                       (* first subcommand            *)\n                      SUBCOUNT: INTEGER;\n                                       (* number of subcommands issued*)\n                      COUNT,           (* count of commands issued    *)\n                      QCOUNT,          (* count of \"quick\" commands   *)\n                                       (* issued, i.e., which ended   *)\n                                       (* without reading from the    *)\n                                       (* terminal                    *)\n                      CPU,             (* CPU time accumulator        *)\n                                       (* in seconds/100              *)\n                      ELAPS,           (* elapsed time accumulator    *)\n                                       (* in seconds*4.096E-3         *)\n                      QELAPS,          (* elapsed time total for      *)\n                                       (* \"quick\" commands            *)\n                      XCOUNT,          (* SRM transaction count       *)\n                                       (* accumulator                 *)\n                      IOCOUNT:  INTEGER)\n                                       (* EXCP accumulator            *)\n               end;\n     HASHVAL = 0..66;                  (* INPUT HASH function result  *)\n% skip 1;\n(**********************************************************************)\n(* The INPUT data base is organized into 67 linked-lists, selected by *)\n(* a hash of the input name. The STAT data base is organized into     *)\n(* linked-lists of commands, selected by first character of the name. *)\n(* The subcommands are chained from the corresponding command.        *)\n(**********************************************************************)\n% skip 1;\nvar  CMDHEAD: array(. HASHVAL .) of CMDPTR;\n                                       (* heads of the INPUT command  *)\n                                       (* lists                       *)\n     STATHEAD: array(. '$'..'Z' .) of CMDPTR;\n                                       (* heads of the INPUT command  *)\n                                       (* lists                       *)\n% skip 1;\n     SMFIN,CMDIN: TEXT;                (* SMF and command info files  *)\n% skip 1;\n     LINENO,PAGENO: INTEGER;           (* report line and page number *)\n% page;\nfunction SEARCH                        (* linked list serach function *)\n     (HEAD:    CMDPTR;                 (* head of the chain to search *)\n      COMMAND: ALFA;                   (* the name to search for      *)\n  var CURCMD:  CMDPTR):                (* pointer to command element  *)\n                                       (* if found, or insertion point*)\n                                       (* if not found                *)\n                        BOOLEAN;       (* TRUE if search successful   *)\n% skip 2;\n(**********************************************************************)\n(*                                                                    *)\n(* function SEARCH - to search a linked list of command elements, and *)\n(*                   return the desired element address if found.     *)\n(*                   If the element is not found, the address of the  *)\n(*                   element after which the desired element ought to *)\n(*                   have been found is returned instead.             *)\n(*                                                                    *)\n(* Note: This function relies on short-circuit evaluation of BOOLEAN  *)\n(*       operators.                                                   *)\n(**********************************************************************)\n% skip 2;\nvar  THISCMD:    CMDPTR;               (* working command pointer     *)\n     FOUND:      BOOLEAN;              (* search successful flag      *)\n% skip 1;\nbegin\n     CURCMD:=nil;                      (* return nil if element not   *)\n                                       (* found                       *)\n     if HEAD=nil then                  (* nothing to find in an empty *)\n       SEARCH:=FALSE                   (* list                        *)\n% skip 1;\n     else\n       begin\n         THISCMD:=HEAD;                (* start search at top of list *)\n         while (THISCMD<>nil) and (THISCMD@.NAME<COMMAND) do\n                                       (* while commands earlier in   *)\n                                       (* aplhabetical order are found*)\n           begin\n             CURCMD:=THISCMD;          (* save most recent one as     *)\n                                       (* possible insert point       *)\n             THISCMD:=THISCMD@.NEXTCMD (* and then skip it            *)\n           end (* of search loop *);\n         FOUND:=(THISCMD<>nil) and (THISCMD@.NAME=COMMAND);\n                                       (* See if the element was      *)\n                                       (* actually found              *)\n         if FOUND then                 (* if so,                      *)\n           CURCMD:=THISCMD;            (* return its address          *)\n         SEARCH:=FOUND                 (* return FOUND indicator      *)\n       end (* of list not empty *)\nend (* of SEARCH function *);\n% page;\nfunction HASH                          (* command name hash function  *)\n     (NAME: ALFA) :                    (* the name to be hashed       *)\n                    HASHVAL;\n% skip 1\n(**********************************************************************)\n(* function HASH - to convert an eight-character name conveniently    *)\n(*                 to a number between 0 and 66 (which value has      *)\n(*                 only numerilogical significance).                  *)\n(**********************************************************************)\n% skip 1;\nvar  SUM: HASHVAL;                     (* hash value accumulator      *)\n     I:   0..8;                        (* character counter           *)\n% skip 1;\nbegin\n     SUM:=0;                           (* start out with nothing      *)\n     for i:=1 to 8 do                  (* a character at a time       *)\n       SUM:=(SUM*256+ORD(NAME(.I.))) mod 67;\n                                       (* compute the name mod 67     *)\n     HASH:=SUM                         (* return the result           *)\nend (* of command HASH routine *);\n% skip 3\nprocedure ADDINP                       (* procedure to add a command  *)\n                                       (* to the INPUT data base      *)\n     (INPNAME: ALFA;                   (* INPUT command name          *)\n  var INPTR:   CMDPTR;                 (* return variable for command *)\n                                       (* element                     *)\n      CURCMD,                          (* corresponding STAT command  *)\n      CURSUB:  CMDPTR);                (* and subcommand elements     *)\n% skip 2\n(**********************************************************************)\n(*                                                                    *)\n(* procedure ADDINP - to add an input command name to the INPUT data  *)\n(*                    base, and initialize the created element.       *)\n(**********************************************************************)\n% skip 2\nvar  I:      HASHVAL;                  (* number of chosen INPUT list *)\n     NEWCMD: CMDPTR;                   (* new INPUT entry pointer     *)\n% skip 2;\nbegin\n     I:=HASH(INPNAME);                 (* hash the command name       *)\n     if not SEARCH(CMDHEAD(.I.),INPNAME,INPTR) then\n                                       (* See if name already in list *)\n       begin                           (* If not...                   *)\n         NEW(NEWCMD,INPUT);            (* allocate a new INPUT element*)\n         if INPTR<>nil then            (* if the proper insertion     *)\n                                       (* point is not the head of    *)\n           begin                       (* the list                    *)\n             NEWCMD@.NEXTCMD:=INPTR@.NEXTCMD;\n                                       (* insert it there             *)\n             INPTR@.NEXTCMD:=NEWCMD\n           end (* of insertion in middle (or at end) of list *)\n         else                          (* if need to insert at start  *)\n           begin                       (* of list                     *)\n             NEWCMD@.NEXTCMD:=CMDHEAD(.I.);\n             CMDHEAD(.I.):=NEWCMD      (* do so                       *)\n           end (* of insert at start of list *);\n         INPTR:=NEWCMD;                (* store new element addr      *)\n         with INPTR@ do                (* initialize new element      *)\n           begin\n             CTYPE:=INPUT;             (* This is an INPUT element    *)\n             TRUECMD:=CURCMD;          (* store STAT command and      *)\n             SUBCMD:=CURSUB;           (* subcommand pointers         *)\n             TRUENAME:=TRUECMD@.NAME;  (* save their names            *)\n             if SUBCMD<>nil then       (* if there is a subcommand    *)\n               SUBNAME:=SUBCMD@.NAME   (* save it                     *)\n             else\n               SUBNAME:='        ';    (* else make it blank          *)\n             NAME:=INPNAME             (* save the input name         *)\n           end (* of initialization of INPUT element *)\n       end (* of name not already in INPUT data base *)\nend (* of ADDINP procedure *);\n% skip 3;\nprocedure CREATESTAT                   (* STAT element creation proc  *)\n     (COMMAND: ALFA;                   (* name of new element         *)\n  var CURCMD:  CMDPTR;                 (* pointer to the created      *)\n                                       (* element                     *)\n  var HEAD:    CMDPTR);                (* pointer to the head of list *)\n                                       (* on which to put the element *)\n% skip 2;\n(**********************************************************************)\n(*                                                                    *)\n(* procedure CREATESTAT - to add a command or subcommand name to the  *)\n(*                        STAT database, initializing the created     *)\n(*                        element, and placing it on the appropriate  *)\n(*                        list.                                       *)\n(**********************************************************************)\n% skip 2;\nvar  NEWCMD: CMDPTR;                   (* new element address         *)\n%skip\nbegin\n     if not SEARCH(HEAD,COMMAND,CURCMD) then\n       begin                           (* if no such element already  *)\n                                       (* in the list                 *)\n         NEW(NEWCMD,STAT);             (* allocate a STAT element     *)\n         if CURCMD<>nil then           (* if this element doesn't     *)\n           begin                       (* belong at the list head     *)\n             NEWCMD@.NEXTCMD:=CURCMD@.NEXTCMD;\n             CURCMD@.NEXTCMD:=NEWCMD   (* chain it in                 *)\n           end (* of insertion within (or at end of) list *)\n         else                          (* if need to insert at head   *)\n           begin\n             NEWCMD@.NEXTCMD:=HEAD;    (* do so                       *)\n             HEAD:=NEWCMD\n           end (* of insertion at head of list *);\n         CURCMD:=NEWCMD;               (* return element addr to      *)\n                                       (* caller                      *)\n         with CURCMD@ do               (* initialize STAT element     *)\n           begin\n             CTYPE:=STAT;              (* establish variant           *)\n             SUBCMDHD:=nil;            (* no subcommands yet          *)\n             COUNT:=0; QCOUNT:=0;      (* zero accumulators           *)\n             CPU:=0; ELAPS:=0; QELAPS:=0;\n             XCOUNT:=0; IOCOUNT:=0; SUBCOUNT:=0;\n             NAME:=COMMAND             (* establish STAT name         *)\n           end (* of STAT element initialization *)\n       end (* of element not found in list *)\nend (* of CREATESTAT procedure *);\n% page;\nprocedure ADDSTAT                      (* procedure to add STAT       *)\n                     (* commands and subcommands                      *)\n     (COMMAND,SUBCMD: ALFA;            (* name of command and subcmd  *)\n                                       (* SUBCMD is blank for command *)\n                                       (* only                        *)\n  var CURCMD,CURSUB:  CMDPTR);         (* address of command and      *)\n                                       (* subcmd STAT elements        *)\n% skip 2;\n(**********************************************************************)\n(*                                                                    *)\n(* procedure ADDSTAT - add a command and/or subcommand to the STAT    *)\n(*                     data base.                                     *)\n(**********************************************************************)\n% skip 2;\nvar  INITIAL: '$'..'Z';                (* first char of the command   *)\n                                       (* name                        *)\n% skip 1;\nbegin\n     INITIAL:=COMMAND(.1.);            (* get command initial         *)\n     CREATESTAT(COMMAND,CURCMD,STATHEAD(.INITIAL.));\n                                       (* create command element and  *)\n                                       (* add to initial chain        *)\n     if SUBCMD<>'        ' then        (* if we also have a subcmd    *)\n       CREATESTAT(SUBCMD,CURSUB,CURCMD@.SUBCMDHD)\n                                       (* add it to the command's     *)\n                                       (* subcommand list             *)\n     else\n       CURSUB:=nil                     (* else show no subcmd         *)\nend (* of ADDSTAT procedure *);\n% page;\nprocedure GETWORD                      (* get next word of input      *)\n     (var WORD: STRING);               (* to return the next word     *)\n% skip 1;\n(**********************************************************************)\n(*                                                                    *)\n(* procedure GETWORD - to return the next word of input from TEXT     *)\n(*                     file CMDIN. Upon return, the buffer pointer    *)\n(*                     should point to a non-blank character or the   *)\n(*                     end of line.                                   *)\n(*                                                                    *)\n(* Note: This procedure uses the PASCAL/VS STRING data type.          *)\n(**********************************************************************)\n% skip 1;\nbegin\n     WORD:='';                         (* start word out empty        *)\n     while CMDIN@<>' ' do              (* get non-blank characters    *)\n       begin\n         WORD:=WORD||STR(CMDIN@);      (* add accumulate them in WORD *)\n         GET(CMDIN)\n       end (* of non-blank input loop *);\n     while (CMDIN@=' ') and not EOLN(CMDIN) do\n                                       (* now skip trailing blanks    *)\n       GET(CMDIN)                      (* until end of line           *)\nend (* of GETWORD procedure *);\n% skip 3;\nprocedure GETCMDS;                     (* CMDIN input routine         *)\n% skip 2;\n(**********************************************************************)\n(*                                                                    *)\n(* procedure GETCMDS - to read the CMDIN input file, building the     *)\n(*                     INPUT and STAT data bases.                     *)\n(*                                                                    *)\n(* Each record of CMDIN defines a STAT command or command-subcommand  *)\n(* pair, together with one or more input command names which          *)\n(* represent that (sub)command.  The (sub) command name comes first,  *)\n(* followed in free format by one or more input names. A subcommand   *)\n(* is represented in the input stream as \"cmdname.subname\".           *)\n(*                                                                    *)\n(* Note: This procedure uses the PASCAL/VS STRING data type and       *)\n(*       associated functions.                                        *)\n(**********************************************************************)\n% skip 2;\nvar  COMMAND,SUBCMD: ALFA;             (* name of current cmd/subcmd  *)\n     CURCMD,CURSUB:  CMDPTR;           (* STAT elements for cmd/subcmd*)\n     ALTCMD:         CMDPTR;           (* INPUT element for cmd/subcmd*)\n     MAINNAME:       STRING(17);       (* cmd.subcmd name string      *)\n     ALTNAME:        STRING(8);        (* equivalent INPUT name       *)\n     INPNAME:        ALFA;\n     INITIAL:        '$'..'Z';         (* work var for initialization *)\n     I:              HASHVAL;          (* work var for initialization *)\n% skip 1;\nbegin\n     for I:=0 to 66 do                 (* make all lists start out    *)\n       CMDHEAD(.I.):=nil;              (* empty                       *)\n     for INITIAL:='$' to 'Z' do\n       STATHEAD(.INITIAL.):=nil;\n% skip 1;\n     while not EOF(CMDIN) do           (* read until end of file      *)\n       begin\n         GETWORD(MAINNAME);            (* get a cmd.subcmd            *)\n         I:=INDEX(MAINNAME,'.');       (* Is it a pair of names?      *)\n         if I=0 then                   (* if not                      *)\n           begin\n             COMMAND:=TRIM(MAINNAME);  (* Cut it down to size         *)\n             SUBCMD:='        '        (* No subcommand name          *)\n           end (* of command name only *)\n         else                          (* if cmd.subcmd pair          *)\n           begin\n             COMMAND:=SUBSTR(MAINNAME,1,I-1);\n                                       (* separate the name at the    *)\n                                       (* period                      *)\n             SUBCMD:=SUBSTR(MAINNAME,I+1,LENGTH(MAINNAME)-I)\n           end (* of command.subcmd pair *);\n         ADDSTAT(COMMAND,SUBCMD,CURCMD,CURSUB);\n                                       (* add it to STAT data base    *)\n         repeat                        (* get equivalent INPUT names  *)\n             GETWORD(ALTNAME);\n             INPNAME:=ALTNAME;         (* pad to 8 characters         *)\n             ADDINP(INPNAME,ALTCMD,CURCMD,CURSUB)\n                                       (* and add them to the INPUT   *)\n                                       (* data base                   *)\n         until EOLN(CMDIN);            (* until end of line           *)\n         READLN(CMDIN)                 (* get the next record         *)\n       end (* of CMDIN input loop *)\nend (* of GETCMDS procedure *);\n% page;\nprocedure FINDCMD                      (* procedure to locate STAT    *)\n     (INPNAME: ALFA;                   (* input command name          *)\n  var COMMAND,                         (* found STAT element for cmd  *)\n      SUBCMD:  CMDPTR);                (* and subcmd                  *)\n% skip 2;\n(**********************************************************************)\n(*                                                                    *)\n(* procedure FINDCMD - to locate (or create) the STAT elements for    *)\n(*                     the command and subcommand represented by an   *)\n(*                     input command name.                            *)\n(**********************************************************************)\n% skip 2;\nvar  INPTR: CMDPTR;                    (* INPUT element pointer for   *)\n                                       (* command name                *)\n     I:     HASHVAL;                   (* INPUT list number for name  *)\n% skip 1;\nbegin\n     I:=HASH(INPNAME);                 (* hash the input name         *)\n     if not SEARCH(CMDHEAD(.I.),INPNAME,INPTR) then\n                                       (* if the name is not known    *)\n       begin                           (* add to both INPUT and STAT  *)\n         ADDSTAT(INPNAME,'        ',COMMAND,SUBCMD);\n                                       (* as a command                *)\n         ADDINP(INPNAME,INPTR,COMMAND,SUBCMD)\n       end (* of previously unknown input command *)\n     else                              (* if command previously seen  *)\n       begin\n         COMMAND:=INPTR@.TRUECMD;      (* find STAT entries from INPUT*)\n                                       (* entries                     *)\n         SUBCMD:=INPTR@.SUBCMD;\n       end (* of known input command name *)\nend (* of FINDCMD procedure *);\n% page;\nfunction GETINT                        (* function to read an         *)\n                                       (* unformatted integer from    *)\n                                       (* SMFIN                       *)\n     (LEN: INTEGER):                   (* the number of bytes to read *)\n                    INTEGER;           (* the integer which was read  *)\n% skip 1;\n(**********************************************************************)\n(*                                                                    *)\n(* function GETINT - to read an integer (in internal form) from the   *)\n(*                   current position on file SMFIN.                  *)\n(*                                                                    *)\n(* Note: This function uses the PASCAL/VS integer shift (<<) operator.*)\n(**********************************************************************)\n% skip 1;\nvar  BYTE:   CHAR;                     (* character input variable    *)\n     RESULT: INTEGER;                  (* the value to return         *)\n     I:      1..4;                     (* for loop control variable   *)\n% skip 1\nbegin\n     RESULT:=0;\n     for I:=1 to LEN do                (* a byte at a time            *)\n       begin\n         READ(SMFIN,BYTE);             (* bite off a byte             *)\n         RESULT:=(RESULT<<8)+ORD(BYTE) (* append to previous bytes    *)\n       end (* of integer assembly *);\n     GETINT:=RESULT                    (* pass it back                *)\nend (* of GETINT function *);\n% skip 3;\nprocedure ACCUM                        (* STAT accumulation procedure *)\n     (CURCMD,SUBCMD: CMDPTR);          (* name of command/subcmd to   *)\n                                       (* accumulate                  *)\n% skip 2;\n(**********************************************************************)\n(*                                                                    *)\n(* procedure ACCUM - to add statistics from the current SMF record    *)\n(*                    to the STAT entries for the current command     *)\n(*                    and subcommand.                                 *)\n(**********************************************************************)\n% skip 2;\nvar  INCR:    INTEGER;                 (* the amount to add to a count*)\n     THISCMD: CMDPTR;                  (* the entry to add to         *)\n% skip 1;\nbegin\n     if SUBCMD=nil then                (* if this is a command        *)\n       THISCMD:=CURCMD                 (* add to command entry        *)\n     else\n       THISCMD:=SUBCMD;                (* else add to subcmd entry    *)\n     INCR:=GETINT(4);                  (* get number of times issued  *)\n     THISCMD@.COUNT:=THISCMD@.COUNT+INCR;\n                                       (* add to entry                *)\n     if SUBCMD<>nil then               (* if count for subcmd         *)\n       CURCMD@.SUBCOUNT:=CURCMD@.SUBCOUNT+INCR;\n                                       (* add to subcmd count for cmd *)\n     INCR:=GETINT(4);                  (* get CPU time                *)\n     THISCMD@.CPU:=THISCMD@.CPU+INCR;  (* et cetera                   *)\n     INCR:=GETINT(4);                  (* get elapsed time            *)\n     THISCMD@.ELAPS:=THISCMD@.ELAPS+INCR;\n     INCR:=GETINT(4);                  (* get quick elapsed time      *)\n     THISCMD@.QELAPS:=THISCMD@.QELAPS+INCR;\n     INCR:=GETINT(4);                  (* get quick command count     *)\n     THISCMD@.QCOUNT:=THISCMD@.QCOUNT+INCR;\n     INCR:=GETINT(4);                  (* get SRM transaction count   *)\n     THISCMD@.XCOUNT:=THISCMD@.XCOUNT+INCR;\n     INCR:=GETINT(4);                  (* get EXCP count              *)\n     THISCMD@.IOCOUNT:=THISCMD@.IOCOUNT+INCR;\nend (* of ACCUM procedure *);\n% page;\nprocedure GETSMF;                      (* SMFIN input routine         *)\n% skip 2;\n(**********************************************************************)\n(*                                                                    *)\n(* procedure GETSMF - to read SMF type 32 records from the SMFIN      *)\n(*                    file and accumulate TSO command statistics.     *)\n(*                                                                    *)\n(* For information in addition to that given below on the type 32     *)\n(* record format, see the IBM SMF manual. Note that the RUA11 usermods*)\n(* have changed the SRB time, TPUT and TGET accumulators to elapsed   *)\n(* time, quick elapsed time and quick command count respectively.     *)\n(*                                                                    *)\n(* Note: This procedure uses PASCAL/VS notation for hexadecimal       *)\n(*       strings.                                                     *)\n(**********************************************************************)\n% skip 2;\nvar  RECTYPE:        CHAR;             (* SMF record type             *)\n     PRODUCT_OFFSET: INTEGER;          (* offset to record \"product   *)\n                                       (* section\"                    *)\n     CMD_OFFSET:     INTEGER;          (* offset to record \"command   *)\n                                       (* section\"                    *)\n     CMDNO:          INTEGER;          (* number of commands in record*)\n     INPNAME:        ALFA;             (* input command name          *)\n     INITIAL:        CHAR;             (* first char of INPNAME       *)\n     CURCMD,SUBCMD:  CMDPTR;           (* cmd and subcmd STAT entry   *)\n                                       (* pointers                    *)\n     I:              INTEGER;          (* for loop index              *)\n     FILLER:         CHAR;             (* dummy input variable        *)\n% skip 1;\nbegin\n     while not EOF(SMFIN) do           (* until the data runs out     *)\n       begin\n         READ(SMFIN,FILLER,            (* skip 1 character,           *)\n              RECTYPE);                (* read record type            *)\n                                       (* SMF32RTY offset = 1         *)\n         if RECTYPE='20'XC then        (* if we have a type 32        *)\n           begin\n             READ(SMFIN,FILLER:18);    (* SMF32POF offset = 20        *)\n             PRODUCT_OFFSET:=GETINT(4);(* get \"product section\" offset*)\n             READ(SMFIN,FILLER:12);    (* SMF32COF offset = 36        *)\n             CMD_OFFSET:=GETINT(4);    (* get \"command section\" offset*)\n             READ(SMFIN,FILLER:2);     (* SMF32CON offset = 42        *)\n             CMDNO:=GETINT(2);         (* get number of commands      *)\n%skip 1;\n             READ(SMFIN,FILLER:PRODUCT_OFFSET-47);\n                                       (* skip to the product section *)\n             READ(SMFIN,FILLER);       (* read the record subtype     *)\n             if FILLER='04'XC then (* if this is a session end *)\n               begin                   (* detail record, collect it   *)\n                 READ(SMFIN,FILLER:CMD_OFFSET-PRODUCT_OFFSET-2);\n                                       (* skip to the command section *)\n                                       (**** this assumes that the ****)\n                                       (**** the command section   ****)\n                                       (**** follows the product   ****)\n                                       (**** section (it better)   ****)\n                 for I:=1 to CMDNO do  (* process each entry          *)\n                   begin\n                     READ(SMFIN,INPNAME);\n                                       (* get the command name        *)\n                     INITIAL:=INPNAME(.1.);\n                                       (* extract its initial         *)\n                     if not (INITIAL in (.'$','@','#','A'..'J','K'..'R',\n                                         'S'..'Z'.)) then\n                                       (* if the command name gets    *)\n                                       (* off to a bad start          *)\n                       INPNAME:='*INVALID';\n                                       (* accumulate specially        *)\n                     FINDCMD(INPNAME,CURCMD,SUBCMD);\n                                       (* find STAT entries for this  *)\n                                       (* command                     *)\n                     ACCUM(CURCMD,SUBCMD);\n                                       (* accumulate statistics       *)\n                   end (* of command entry loop *)\n               end (* of session end detail processing *)\n           end (* of record type 32 processing *);\n         READLN(SMFIN)                 (* skip to next SMF record     *)\n       end (* of SMFIN input loop *)\nend (* of GETSMF procedure *);\n% page;\nfunction AVGFORM                       (* function to format average  *)\n                                       (* values                      *)\n     (TOTAL,COUNT: INTEGER):           (* total value and number of   *)\n                                       (* observations                *)\n                             STRING(6);(* the formatted result        *)\n% skip 1\n(**********************************************************************)\n(*                                                                    *)\n(* function AVGFORM - to produce a character representation of an     *)\n(*                    average of a set of integers. If the value      *)\n(*                    is greater than 10,000, it is formatted in \"K\"  *)\n(*                    notation. If the number of observations is      *)\n(*                    zero, it is formatted as \"---\".                 *)\n(*                                                                    *)\n(* Note: This procedure uses the PASCALVS STRING data type and the    *)\n(*       WRITESTR procedure.                                          *)\n(**********************************************************************)\n% skip 1;\nvar  AVG:  REAL;                       (* the average value           *)\n     AVGF: STRING(6);                  (* working string varaible     *)\n% skip 1;\nbegin\n     if COUNT=0 then                   (* if no data to average       *)\n       AVGFORM:='---'                  (* so indicate                 *)\n     else\n       begin\n         AVG:=FLOAT(TOTAL)/FLOAT(COUNT);\n                                       (* compute real average        *)\n         if AVG<9999.95 then           (* fewer than 5 digits rounded?*)\n           WRITESTR(AVGF,AVG:6:1)      (* if so, format normally      *)\n         else\n           begin\n             WRITESTR(AVGF,AVG/1000.0:6:0);\n                                       (* format the number of K      *)\n                                       (* as an integer               *)\n             AVGF:=SUBSTR(AVGF,1,5)||'K'\n                                       (* replace point with K        *)\n           end (* of large value to format *);\n         AVGFORM:=AVGF;                (* return result to caller     *)\n       end (* of at least one observation *)\nend (* of AVGFORM function *);\n% skip 2;\nfunction TIMEFORM                      (* average time formatter      *)\n     (TIME, COUNT: INTEGER;            (* total time and number of    *)\n                                       (* observations                *)\n      UNITS:       REAL):              (* time unit in seconds        *)\n                          STRING(5);   (* the formatted result        *)\n% skip 1;\n(**********************************************************************)\n(*                                                                    *)\n(* function TIMEFORM - to format an average time value as \"nn.nU\",    *)\n(*                     where U is \"S\", \"M\" or \"H\", for seconds,       *)\n(*                     minutes or hours. if there are no observations,*)\n(*                     \"---\" in returned instead.                     *)\n(*                                                                    *)\n(* Note: This procedure uses the PASCALVS STRING data type and the    *)\n(*       WRITESTR procedure.                                          *)\n(**********************************************************************)\n% skip 1;\nvar  AVG:   REAL;                      (* average time in seconds     *)\n     TIMEF: STRING(7);                 (* the formatted time value    *)\n% skip 1;\nbegin\n     if COUNT=0 then                   (* if no meaningful data       *)\n       TIMEFORM:='---'                 (* so indicate                 *)\n     else\n       begin\n         AVG:=UNITS*FLOAT(TIME)/FLOAT(COUNT);\n                                       (* compute average time in     *)\n                                       (* seconds                     *)\n         if AVG<59.95 then             (* if small enough for seconds *)\n           WRITESTR(TIMEF,AVG:4:1,'S') (* make it nn.nS               *)\n         else\n           if AVG/60.0<59.95 then      (* if small enough for minutes *)\n             WRITESTR(TIMEF,AVG/60.0:4:1,'M')\n                                       (* make it nn.nM               *)\n           else                        (* make in nn.nH               *)\n             WRITESTR(TIMEF,AVG/3600.0:4:1,'H');\n         TIMEFORM:=TIMEF               (* give result to caller       *)\n       end (* of non-zero count of times *)\nend (*of TIMEFORM function *);\n% page;\nprocedure REPORTLINE                   (* report line writer proc     *)\n     (CURCMD,SUBCMD: CMDPTR;           (* command and subcmd elements *)\n                                       (* for the output line         *)\n      NEWPAGE:       BOOLEAN);         (* will this line be the first *)\n                                       (* on the page?                *)\n% skip 2\n(**********************************************************************)\n(*                                                                    *)\n(* procedure REPORTLINE - To write the statistics report line for a   *)\n(*                        single command or subcommand.               *)\n(*                                                                    *)\n(* Note: This procedure requires several PASCAL/VS string-handling    *)\n(*       function and the COLS file-handling function.                *)\n(**********************************************************************)\n% skip 2;\nvar  SUBOUT: BOOLEAN;                  (* line is for subcmd flag     *)\n% skip 1;\nbegin\n     SUBOUT:=SUBCMD<>nil;              (* see whether subcmd output   *)\n     if not SUBOUT and not NEWPAGE then\n       begin                           (* if command and not new page *)\n         WRITELN;                      (* double space                *)\n         LINENO:=LINENO+1              (* bump line counter           *)\n       end (* of command not at page top *);\n     if not SUBOUT then                (* if command line             *)\n       WRITE(CURCMD@.NAME)             (* label with command name     *)\n     else                              (* if a subcommand             *)\n       if NEWPAGE then                 (* if starting new page        *)\n         WRITE(TRIM(STR(CURCMD@.NAME)),'.',SUBCMD@.NAME)\n                                       (* mention command name again  *)\n       else                            (* if subcmd on old page       *)\n         WRITE(SUBSTR('........',1,LENGTH(TRIM(STR(CURCMD@.NAME)))),'.',\n               SUBCMD@.NAME);          (* replace command name with   *)\n                                       (* dots (\"....subcmd\")         *)\n% skip;\n     WRITE(' ':21-COLS(OUTPUT));       (* tab to col 21               *)\n     if SUBOUT then                    (* if this is a subcmd,        *)\n       CURCMD:=SUBCMD;                 (* treat it as command now     *)\n     with CURCMD@ do                   (* write out stats             *)\n       begin\n         WRITE(COUNT:6,' ':3,QCOUNT:6,' ':3);\n                                       (* write number of commands    *)\n                                       (* (both quick and dead)       *)\n         if not SUBOUT then            (* if this is a command        *)\n           WRITE(SUBCOUNT:7,' ':3)     (* write no of subcmds         *)\n         else\n           WRITE('---':7,' ':3);       (* else say not meaningful     *)\n         WRITE(TIMEFORM(CPU,COUNT,0.01):5,' ':3,\n               TIMEFORM(ELAPS,COUNT,4.096E-3):5,' ':3,\n               TIMEFORM(QELAPS,QCOUNT,4.096E-3):5,' ':3);\n                                       (* write CPU and elapsed times *)\n         WRITE(AVGFORM(XCOUNT,COUNT):6,' ':3,\n               AVGFORM(IOCOUNT,COUNT):6,' ':3);\n                                       (* write SRM transaction and   *)\n                                       (* EXCP count averages         *)\n         WRITELN;                      (* end of that line            *)\n         LINENO:=LINENO+1              (* bump the line counter       *)\n       end (* of with statement *)\nend (* of REPORTLINE procedure *);\n% page;\nprocedure TITLE;                       (* report page heading proc    *)\n% skip 1;\n(**********************************************************************)\n(*                                                                    *)\n(* procedure TITLE - To write a page heading line and two lines of    *)\n(*                   column headings for the summary report.          *)\n(*                                                                    *)\n(* Note: This procedure relies on the PASCAL/VS interpretation of     *)\n(*       negative field width in the WRITE function call (i.e., left  *)\n(*       justification), and on the DATETIME function to retrieve the *)\n(*       current time and date.                                       *)\n(**********************************************************************)\n% skip 1\nvar  NOW,TODAY: ALFA;                  (* current time and date       *)\n% skip 1;\nbegin\n     DATETIME(TODAY,NOW);              (* find out when it is         *)\n     PAGENO:=PAGENO+1;                 (* bump page counter           *)\n     if PAGENO<>1 then                 (* except for page 1           *)\n       PAGE(OUTPUT);                   (* throw a page                *)\n     WRITELN('TSO COMMAND SUMMARY',' ':60,TODAY,' ':7,NOW,' ':7,\n             'PAGE ',PAGENO:4);        (* write main heading          *)\n     WRITELN;                          (* skip a line after           *)\n     WRITELN('CMD.SUBCMD':-17,'EXEC':9 ,'SHORT':9,'SUBCMD':10,\n                 'CPU':8,'ELAPSED AVG':15,' ':1,'AVG SRM':9,'EXCP':9);\n     WRITELN('NAME':-17,      'COUNT':9,'COUNT':9,'COUNT':10,\n                 'AVG':8,'(ALL) (SHORT)':16,      'TRANS':9,'AVG':9);\n                                       (* write out column headings   *)\n     WRITELN;                          (* skip a line after headings  *)\n     LINENO:=5;                        (* set starting line number    *)\nend (* of title procedure *);\n% page;\nprocedure CMDRPT                       (* report on command routine   *)\n     (CURCMD: CMDPTR;                  (* STAT element for command    *)\n      SUBCMD: CMDPTR);                 (* STAT element for subcommand *)\n% skip 1;\n(**********************************************************************)\n(*                                                                    *)\n(* procedure CMDRPT - to write the output for a single command or     *)\n(*                    subcommand. For a command, it calls itself      *)\n(*                    recursively to write the subcommand lines.      *)\n(**********************************************************************)\n% skip 1;\nvar  NEWPAGE: BOOLEAN;                 (* new page required flag      *)\n     SUBPTR:  CMDPTR;                  (* subcommand work pointer     *)\n     NOUSE:   BOOLEAN;                 (* don't write line flag       *)\n% skip 1;\nbegin\n     if SUBCMD=nil then                (* see if any use to mention   *)\n       NOUSE:=CURCMD@.COUNT=0\n     else\n       NOUSE:=SUBCMD@.COUNT=0;\n     if not NOUSE then                 (* if any use to speak of      *)\n       begin                           (* write the report line       *)\n         NEWPAGE:=FALSE;               (* assume new page not needed  *)\n         if (LINENO=PAGESIZE) or\n            ((LINENO=PAGESIZE_1) and (SUBCMD=nil)) then\n           begin                       (* if page has no room for next*)\n                                       (* line                        *)\n             TITLE;                    (* skip to next page           *)\n             NEWPAGE:=TRUE             (* note for REPORTLINE         *)\n           end (* of new page required *);\n         REPORTLINE(CURCMD,SUBCMD,NEWPAGE);\n                                       (* write line for this (sub)cmd*)\n         if (SUBCMD=nil) and (CURCMD@.SUBCOUNT>0) then\n                                       (* if this command has subcmds *)\n           begin\n             SUBPTR:=CURCMD@.SUBCMDHD; (* get first subcmd entry      *)\n             while SUBPTR<>nil do\n               begin\n                 CMDRPT(CURCMD,SUBPTR);(* write line for each subcmd  *)\n                 SUBPTR:=SUBPTR@.NEXTCMD    (* until all are done     *)\n               end (* of subcommand output loop *)\n           end (* of command with subcommands *)\n       end (* of command with non-zero use *)\nend (* of CMDRPT procedure *);\n% skip 3;\nprocedure REPORT;                      (* report-writing procedure    *)\n% skip 2\n(**********************************************************************)\n(*                                                                    *)\n(* procedure REPORT - to write the accumulated statistics report to   *)\n(*                    OUTPUT.                                         *)\n(**********************************************************************)\n% skip 2;\nvar  INITIAL: '$'..'Z';                (* command initial variable    *)\n     CURCMD:  CMDPTR;                  (* work command pointer        *)\n% skip 1;\nbegin\n     LINENO:=PAGESIZE;                 (* force page start            *)\n     PAGENO:=0;                        (* and page number 1           *)\n     for INITIAL:='$' to 'Z' do        (* handle each chain of STAT   *)\n       begin                           (* elements                    *)\n         CURCMD:=STATHEAD(.INITIAL.);  (* start at head of chain      *)\n         while CURCMD<>nil do          (* while there are cmds left   *)\n           begin\n             CMDRPT(CURCMD,nil);       (* write stats for this command*)\n             CURCMD:=CURCMD@.NEXTCMD   (* get the next one            *)\n           end (* of command chain loop *)\n       end (* of loop over first letter *)\nend (* of REPORT procedure *);\n% page\n(**********************************************************************)\n(*                                                                    *)\n(* This is the body of TSOSUMM. (I bet you thought I'd forgotten it.) *)\n(**********************************************************************)\n% skip 1;\nbegin\n     REWRITE(OUTPUT,'DDNAME=SYSPRINT,RECFM=VA,LRECL=125,BLKSIZE=129');\n                                       (* use DDname SYSPRINT for     *)\n                                       (* OUTPUT                      *)\n     RESET(CMDIN); RESET(SMFIN);       (* open input files            *)\n% skip 1;\n     GETCMDS;                          (* read the command input      *)\n     GETSMF;                           (* read the SMF input          *)\n     REPORT;                           (* write out the report        *)\n% skip 1;\nend (* of TSOSUMM program *).\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSOSUMM$": {"ttr": 11014, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//REPRT32S JOB (),'REPORT TYPE 32S',TIME=2\n/*JOBPARM  I,L=9,Q=F\n//DUMP EXEC PGM=IFASMFDP\n//SYSPRINT DD SYSOUT=A\n//I DD DSN=SYS1.MANE,DISP=SHR\n//O DD DSN=&&SMF32S,DISP=(NEW,PASS),UNIT=SYSDA\n//SYSIN DD *\n INDD(I,OPTIONS(DUMP))\n OUTDD(O,TYPE(32))\n// EXEC PGM=TSOSUMM\n//SYSPRINT DD SYSOUT=A\n//STEPLIB DD DSN=ALAN.SMF.LOAD,DISP=SHR\n//CMDIN DD DSN=ALAN.CMDIN.DATA,DISP=SHR\n//SMFIN DD DSN=&&SMF32S,DISP=(OLD,PASS)\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TSO0906@": {"ttr": 11016, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "1\n-\n        Rice University - ICSA                                          Page 1\n        15 September 1977\n        TSO009.006\n                                                         \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n                                                         |          |\n                                                         | LISTMEM  |\n                                                         | LISTM    |\n                                                         |          |\n                                                         \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n0       The LISTM command is used to list the members of a partitioned data\n        set.\n-            \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n+                           \u00af\n             |              |                                       |\n             |  COMMAND     |           OPERANDS                    |\n             |              |                                       |\n             |\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\n+            \u00bf              \u00d7                                       ]\n             |              |                                       |\n             |  LISTMEM     |           (dslist)                    |\n      #      |  LISTM       |                                       |\n      #      |              |           \u00d0       \u00af                   |\n      #      |              |           | MATCH |                   |\n+                                         _____\n      #      |              |           | ALPHA |                   |\n      #      |              |           \u00bf       ]                   |\n      #      |              |           \u00d0        \u00af                  |\n      #      |              |           | COLUMN |                  |\n      #      |              |           | FREE   |                  |\n+                                         ____\n      #      |              |           \u00bf        ]                  |\n             |              |                                       |\n             \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n+                           \u00bf\n0       dslist is a list of names of the data sets for which a list of members\n             is desired. They must be partitioned data sets.  If the list\n             contains only one name, the enclosing parentheses may be omitted.\n0       MATCH requests that aliases be matched with main members and flagged\n             with an equal sign (=). Main members will be in collating\n             sequence. Unmatched aliases will be \"matched\" to a dummy main\n             member called '?'. This is the default.\n      # ALPHA requests that aliases be placed in collating sequence with main\n             members. Aliases will be flagged with an asterisk (\"*\").\n0       FREE requests that the list of members be as compact as possible, with\n             only one space between names; no names will be split across\n             lines.  This is the default.\n      # COLUMN requests that the list of members be in 10-space columns (eight\n      |      spaces for member names padded on the right with two blanks, one\n      |      for alias flag (\"*\" or \"=\") and one blank to separate names).\n-       EXAMPLE:\n0       Operation:  List the members of a data set using all the defaults.\n0     | Command: LISTMEM WEATHER.DATA\n0       Response:\n      |      userid.WEATHER.DATA\n0     |      HAIL RAIN SNOW SUNNY =FAIR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSO0910@": {"ttr": 11018, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "1\n-\n        Rice University - ICSA                                          Page 1\n        15 September 1977\n        TSO009.010\n                                                         \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n                                                         |          |\n                                                         |  LISTU   |\n                                                         |          |\n                                                         \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n0       The LISTU command will return a list of all users currently logged\n        onto TSO.\n-            \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n+                           \u00af\n             |              |                                       |\n             |  COMMAND     |           OPERANDS                    |\n             |              |                                       |\n             |\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\n+            \u00bf              \u00d7                                       ]\n             |              |                                       |\n             |  LISTU       |           none                        |\n             |              |                                       |\n             \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n+                           \u00bf\n-       EXAMPLE:\n0       Command: LISTU\n0     # Response:  TOM DICK HARRY\n      #              3 USERS LOGGED ON  AND   NO USERS LOGGING ON\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TSO0917@": {"ttr": 11020, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "1\n-\n        Rice University - ICSA                                          Page 1\n        25 August 1980\n        TSO009.017\n                                                         \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n                                                         |          |\n                                                         |  XSEND   |\n                                                         |  XS      |\n                                                         |          |\n                                                         \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n0       The XSEND command is an enhanced version of the SEND command. This\n      | command only supports messages from one logged-on user to another,\n      | i.e., messages to the operator or to users who are not logged on must\n      | still be sent via the SEND command.\n-            \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n+                           \u00af\n             |              |                                       |\n             |  COMMAND     |           OPERANDS                    |\n             |              |                                       |\n             |\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\n+            \u00bf              \u00d7                                       ]\n             |              |                                       |\n             |  XSEND       |           message                     |\n             |  XS          |                                       |\n      |      |              |           USER(useridlist)            |\n      |      |              |                                       |\n      |      |              |           \u00d0       \u00af                   |\n      |      |              |           | BELL  |                   |\n      |      |              |           | FLASH |                   |\n      |      |              |           \u00bf       ]                   |\n      |      |              |           \u00d0                  \u00af        |\n      |      |              |           | WAIT\u00dd(interval)\u00a8 |        |\n      |      |              |           | NOWAIT           |        |\n+                                         ______\n      |      |              |           \u00bf                  ]        |\n      |      |              |           \u00d0             \u00af             |\n      |      |              |           | INTERRUPT   |             |\n      |      |              |           | NOINTERRUPT |             |\n+                                         ___________\n      |      |              |           \u00bf             ]             |\n             |              |                                       |\n             \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n+                           \u00bf\n0     | 'message' is the message text enclosed in quotes.  The message may be\n      |      at most 235 characters.\n0       USER(useridlist) is the list of recipients of the message. This is\n             required.\n0     | BELL indicates the bell on an ASCII terminal is to be sounded when the\n      |      message is received and the prefix '*ATTN*' is to be typed on the\n      |      terminal prior to typing the message. For EBCDIC terminals, for\n      |      which no bell exists, only the prefix '*ATTN*' is sent.  ATTN is\n      |      a synonym for BELL.\n      | FLASH indicates that the bell is to be sounded on an ASCII terminal\n      |      even if the user is not receiving messages (i.e., has set PROFILE\n      |      NOINTERCOM).  For such a user, only the bell is sent; neither the\n      |      message text nor the '*ATTN*' prefix will be received.  Users on\n      |      EBCDIC terminals will not receive any indication of the attempt\n      |      to send a message.\n      | Note: If neither BELL nor FLASH is specified, these attention-getters\n      | will not be sent.\n0     | WAIT\u00dd(interval)\u00a8 indicates that the message is to be sent to every\n      |      user in the list before the issuing user may proceed.  The\n      |      subparameter \"interval\" may be used to specify the number of\n      |      seconds (up to 99) the issuer is willing to wait for the message\n      |      to be sent; if no interval is specified, there is no limit on the\n      |      length of the wait.  Note that the WAIT may be cancelled at any\n      |      time by use of the attention key (in which case any users who are\n      |      still busy will not receive the message).\n      | NOWAIT indicates that the message is to be cancelled for any busy user\n      |      so that the issuing user does not have to wait to continue.  This\n      |      is the default.\n0     | INTERRUPT specifies that if a receiving user is entering input when\n      |      the message is sent, he should be interrupted so it can be\n      |      written immediately.  This specification will be ignored for some\n      |      kinds of terminals (e.g., IBM 2741 terminals when the user has\n      |      not issued TERM BREAK).\n      | NOINTERRUPT specifies that a user active in input is not to be\n      |      interrupted.  This is the default.\n1\n-\n        TSO009.017                                                      Page 2\n-       EXAMPLE 1:\n0       Operation: Send a message from userid USERD to three users A, B, and\n             C.  User A is not logged on, and user B is busy.\n0       Command:  XSEND 'PLEASE FREE CLASS DATA SET' U(A B C) BELL\n0       Response:\n             No message is sent to users A and B.\n             On user C's terminal -\n0     |      +*ATTN* PLEASE FREE CLASS DATA SET--USERD\n0            On USERD's terminal (the issuer) -\n0            USER(S) NOT LOGGED ON, MESSAGE CANCELLED-\n             A\n             USER(S) BUSY, MESSAGE CANCELLED-\n             B\n             READY\n-     | EXAMPLE 2:\n0     | Operation: Send a message from userid ARTHUR to MORDRED and GAWAIN,\n      | waiting until the messages are sent.  MORDRED is not receiving messages.\n0     | Command:  XSEND 'ARE YOU GOING TO THE TOURNAMENT?' U(MORDRED,GAWAIN) -\n      |           WAIT FLASH\n0     |      Response:\n      |      On GAWAIN's terminal -\n0     |      +*ATTN* ARE YOU GOING TO THE TOURNAMENT?--ARTHUR\n0     |      No message is sent to MORDRED's terminal, but the bell is sounded\n      |      to indicate that an attempt was made to send a message.\n      |      On ARTHUR's terminal -\n      |      USER(S) NOT ACCEPTING MESSAGES-\n      |      MORDRED\n      |      READY\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TTS02A1": {"ttr": 11023, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "++USERMOD (TTS02A1) /* SEND COMMAND IMPROVEMENT */.\n++VER (Z038) FMID(EBB1102) /*\n  THIS USER MOD FIXES THE SEND OPERATOR COMMAND TO NOT APPEND\n  CN(00) TO THE MESSAGE WHEN SEND IS ISSUED BY A SYSTEM TASK.\n  THIS IMPROVES THE APPEARANCE OF JES2 NOTIFY MESSAGES. */.\n++ZAP (IEEVSND6).\n NAME IEEVSND6\n VER 0078 4350,A01D\n VER 058C 0000,0000\n REP 0078 47F0,B586\n REP 058C BF51,A01D,4770,B076\n REP 0594 D205,C16D,C16C,47F0,B098\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UEBPDSPT": {"ttr": 11025, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         TITLE 'PDSPRINT -- GENERALIZED PDS LISTER -- OCTOBER, 1980'\n         MACRO\n         DCBEQU &PRE,&DCB,&NAMES\n         LCLA  &I\n&I       SETA  1\n.LOOP    ANOP\n&PRE&NAMES(&I) EQU DCB&NAMES(&I)-IHADCB+&DCB\n&I       SETA  &I+1\n         AIF   (&I LE N'&NAMES).LOOP\n         MEND\nPDSPRINT SAVEX SA=SAVEAREA,PARMR=R11,XID='PDS LISTER WITH DIRECTORY'\n         SPACE\n         USING SAVEAREA,R13       USE 13 AS BASE FOR DATA\n         EJECT\n***********************************************************************\n*        THIS ROUTINE IS A GENERALIZED PDS LISTER, CAPABLE OF HANDLING*\n*        ALL INPUT RECORD FORMATS (INCLUDING SPANNED). PROVIDED WITH  *\n*        THE LISTING IS A TALE OF CONTENTS, INDICATING THE PAGE(S)    *\n*        WHERE EACH MEMBER IS TO BE FOUND, AND PROVIDING AN ALIAS-    *\n*        TO-MAIN-MEMBER CROSS-REFERENCE.                              *\n*        THIS PROGRAM WAS WRITTEN BY ALAN BEALE, BASED ON AN EARLIER  *\n*        PROGRAM WRITTEN BY FARRELL GERBODE.                          *\n***********************************************************************\n         SPACE 3\n***********************************************************************\n*        BEGIN BY VALIDATING AND INTERPETING ANY PARAMETER. IF        *\n*        SUPPLIED, THE PARAMETER MUST BE AN INTEGER, SPECIFYING THE   *\n*        NUMBER OF LINES PER PAGE. IF NO PARM IS PROVIDED, THERE WILL *\n*        BE 55 LINES PER PAGE.                                        *\n***********************************************************************\n         SPACE\n         LTR   R11,R11            ANY PARM PASSED?\n         BZ    NOPARM             NO.\n         L     R11,0(,R11)        YES, FIND CHAR STRING\n         CLC   0(2,R11),=H'0'     WAS A PARM PASSED?\n         BE    NOPARM             NO.\n         CLC   0(2,R11),=H'2'     YES, AT LEAST 2 CHARS?\n         BL    BADPARM            NO, BAD LINECT\n         CLC   0(2,R11),=H'4'     LINECT TOO BIG?\n         BNL   BADPARM\n         LH    R14,0(,R11)        LOAD THE LENGTH\n         BCTR  R14,0\n         EX    R14,TESTPARM       MOVE PARM FOR NUMERIC TEST\n         CLC   NUMERIC,=C'000'    IS THE PARM NUMERIC?\n         BNE   BADPARM            NO.\n         EX    R14,PACKPARM       YES, GET IT TO BINARY\n         CVB   R14,DECWORK\n         CH    R14,=H'10'         IS THE LINECT TOO SMALL?\n         BL    BADPARM            YES.\n         STH   R14,LINEMAX        NO, SAVE IT FOR LATER\n         B     NOPARM\n         SPACE\nBADPARM  LH    R14,0(,R11)\n         CH    R14,=H'10'         ROOM IN MSG FOR 1ST 10 ONLY\n         BNH   NOTRUNC\n         LA    R14,10\n         MVC   DOTROOM,=C'...'\nNOTRUNC  BCTR  R14,0\n         EX    R14,PARMSGMV       MOVE PARM TO MESSAGE\n         LA    R2,PARMSG\n         BAL   R11,ERRMSG         SEND WARNING MESSAGE\n         MVI   RETC+1,4           SET EVENTUAL RETURN CODE\n         EJECT\n***********************************************************************\n*        THIS SECTION READS THE PDS DIRECTORY AND BUILDS TABLES       *\n*        CONTAINING MEMBER AND ALIAS INFORMATION. THREE TABLES ARE    *\n*        DEFINED, A MEMBER TABLE (ONE ENTRY PER MEMBER), A FIRST-ALIAS*\n*        TABLE (ONE ENTRY PER DISTINCT ALIAS TTR), AND AN OTHER ALIAS *\n*        TABLE (ONE ENTRY PER DUPLICATE ALIAS).                       *\n***********************************************************************\n         SPACE\nNOPARM   RDJFCB QSAMDCB           GET SYSLIB DSNAME THRU JFCB\n         LTR   R15,R15            CHECK FOR DD CARD\n         BZ    DDOK\n         LA    R2,NOSYSLIB        SEND ERROR MSG\n         BAL   R11,ERRMSG\n         LA    R15,16\n         B     ABORT              AND TERMINATE\n         SPACE\nDDOK     OI    JFCB+52,X'08'      INHIBIT REWRITE\n         OPEN  (QSAMDCB,(INPUT)),TYPE=J  OPEN THE DIRECTORY\n         LTR   R15,R15            OPEN SUCCESSFUL?\n         BZ    QSAMREAD           YES.\n         LA    R2,LIBNOP          NO, SEND MESSAGE\n         BAL   R11,ERRMSG\n         LA    R15,16\n         B     ABORT              TERMINATE PROGRAM\n         SPACE\n***********************************************************************\n*        READ THE NEXT DIRECTORY BLOCK.                               *\n***********************************************************************\n         SPACE\nQSAMREAD GET   QSAMDCB,DIRBLK     GET NEXT DIRECTORY BLOCK\n         LA    R9,DIRBLK+2        POINT TO 1ST ENTRY\n         LH    R8,DIRBLK          LOAD DATA COUNT\n         LA    R8,DIRBLK(R8)      ADDR END OF BLOCK\n         SPACE\n***********************************************************************\n*        GET THE LOCATION OF THE NEXT MEMBER FROM THE DIRECTORY.      *\n***********************************************************************\n         SPACE\nSAMEDIR  CR    R9,R8              REACHED END OF BLOCK?\n         BNL   QSAMREAD           YES, READ AGAIN\n         CLC   0(8,R9),=8X'FF'    IS THIS THE END OF DIRECTORY MARK?\n         BE    ENDDIR             YES, CLOSE UP DIRECTORY\n         LA    R2,MEMBLK          NO, GET A NEW MEMBER TABLE ENTRY\n         BAL   R11,GETENT\n         LR    R5,R2              SAVE ENTRY ADDR IN R5\n         USING MEMBER,R5\n         MVC   MEMNAME,0(R9)      COPY MEMBER NAME\n         MVC   MEMTTR,8(R9)       AND TTR FROM DIRECTORY\n         TM    11(R9),X'80'       IS THIS AN ALIAS?\n         BZ    NEXTENT            NO, SKIP ALIAS PROCESSING\n         MVI   MEMFLAGS,$ALIAS    YES, SET ALIAS FLAG\n         SPACE\n***********************************************************************\n*        SEE IF ANOTHER ALIAS WITH THIS TTR HAS BEEN SEEN. IF SO, ADD *\n*        THIS ONE TO THE CHAIN FOR THIS TTR; IF NOT, START A NEW      *\n*        CHAIN. THE ALIASES ARE ADDRESSED VIA 2 TABLES, THE FIRST     *\n*        INDEXED BY THE FIRST 3 NYBBLES OF THE TT, THE OTHER INDEXED  *\n*        BY THE REST. THE SECOND TABLE ENTRY ADDRESSES THE HEAD OF A  *\n*        CHAIN OF FIRST-ALIASES, ORDERED BY R. (THE OTHER ALIASES     *\n*        ARE CHAINED FROM THE FIRST.)                                 *\n***********************************************************************\n         SPACE\n         L     R6,TTTAB1          LOCATE THE FIRST TT TABLE\n         LTR   R6,R6              HAS IT BEEN CREATED?\n         BNZ   GOTTTAB            YES.\n         GETMAIN R,LV=16384       NO, CREATE IT NOW\n         LR    R6,R1              SAVE ITS ADDR\n         ST    R6,TTTAB1\n         LR    R0,R1              CLEAR IT OUT\n         L     R1,=F'16384'\n         SR    R15,R15            WITH X'00'S\n         MVCL  R0,R14\n         SPACE\nGOTTTAB  SR    R14,R14\n         ICM   R14,B'0011',MEMTTR LOAD THE TT\n         SRDL  R14,4              ISOLATE TT MOD 16\n         SRL   R15,26             * 4\n         SLL   R14,2              FLOOR(TT/16) * 4\n         AR    R14,R6             LOCATE THE TABLE ENTRY\n         ICM   R1,B'1111',0(R14)  LOCATE LEVEL 2 TABLE\n         BZ    NEWTT1             IF NONE, GET NEW LEVEL 2 TABLE\n         LA    R14,0(R15,R1)      FIND LEVEL 2 ENTRY FOR THIS TT\n         ICM   R6,B'1111',0(R14)  FIND HEAD OF CHAIN FOR TT\n         BZ    NEWTT2             IF NONE, GO START CHAIN\n         SPACE\n***********************************************************************\n*        SEARCH THE ALIAS CHAIN FOR THIS TT TO SEE IF ANOTHER ALIAS   *\n*        FOR THIS TTR IS KNOWN. IF SO, ADD THIS ALIAS TO THE \"OTHER-  *\n*        ALIAS\" CHAIN FOR THIS TTR.                                   *\n***********************************************************************\n         SPACE\n         USING ALIAS1,R6\nALIASRCH L     R15,AL1MEMB        FIND MEMBER ENTRY FOR CHAIN ENTRY\n         CLC   MEMTTR+2(1),MEMTTR-MEMBER+2(R15)  COMPARE R'S\n         BE    ADDALIAS           IF THE SAME, ADD TO OTHER TABLE\n         BL    NEWALIAS           IF CHAIN ENTRY BIGGER, ADD HERE\n         LR    R14,R6             SAVE THIS ENTRY\n         ICM   R6,B'1111',AL1CHAIN     GET NEXT ON CHAIN\n         BNZ   ALIASRCH           IF ANY\n         SPACE\n***********************************************************************\n*        GET A NEW \"FIRST-ALIAS\" ENTRY FOR THIS ALIAS, AND INSERT IT  *\n*        INTO THE CHAIN FOR THIS TT (ORDERED BY R).                   *\n***********************************************************************\n         SPACE\nNEWALIAS LR    R6,R14             RESTORE PRIOR POINTER\n         LA    R2,AL1BLK\n         BAL   R11,GETENT         GET A FIRST-ALIAS ENTRY\n         MVC   AL1CHAIN-ALIAS1(,R2),AL1CHAIN\n         ST    R2,AL1CHAIN        INSERT INTO CHAIN\n         LR    R6,R2\n         ST    R5,AL1MEMB         LINK TO MEMBER ENTRY\n         ST    R6,MEMALIAS\n         OI    MEMFLAGS,$PSMAIN   INDICATE MIGHT END UP MAIN\n         B     NEXTENT            PROCEED TO NEXT ENTRY\n         SPACE\n***********************************************************************\n*        ADD THIS ALIAS TO THE OTHER-ALIAS CHAIN FOR THIS TTR. THIS   *\n*        CHAIN IS ORDERED ALPHABETICALLY BY MEMBER NAME.              *\n***********************************************************************\n         SPACE\nADDALIAS ST    R6,MEMALIAS        POINT MEMBER TO FIRST-ALIAS\n         LA    R2,AL2BLK          GET AN \"OTHER\" ENTRY\n         BAL   R11,GETENT\n         USING ALIAS2,R2\n         ST    R5,AL2MEMB         POINT OTHER ENTRY TO MEMBER ENTRY\n         ICM   R15,B'1111',AL1LAST     GET PREVIOUS LAST ALIAS FOR TTR\n         ST    R2,AL1LAST\n         BZ    FIRSTOTH           BRANCH IF FIRST OTHER\n         ST    R2,AL2CHAIN-ALIAS2(,R15)     ADD TO END OF CHAIN\n         B     NEXTENT\nFIRSTOTH ST    R2,AL1FIRST        ELSE MAKE FIRST\n         DROP  R2\n         B     NEXTENT            GET NEXT MEMBER FROM DIRECTORY\n         SPACE\n***********************************************************************\n*        THIS TT FRAGMENT WAS NOT PREVIOUSLY KNOWN. GET A LEVEL 2     *\n*        TABLE, AND PUT ITS ADDRESS IN THE LEVEL 1 TABLE.             *\n***********************************************************************\n         SPACE\nNEWTT1   LR    R6,R14             SAVE LEVEL 1 ENTRY PTR\n         LR    R10,R15            SAVE TT MOD 16 * 4\n         LA    R2,TT2BLK          ASK FOR A LEVEL 2 TABLE\n         BAL   R11,GETENT\n         ST    R2,0(,R6)          STORE INTO LEVEL 1 TABLE\n         LA    R14,0(R10,R2)      ADDRESS LEVEL 2 ENTRY\n         SPACE\n***********************************************************************\n*        GET A NEW \"FIRST-ALIAS\" ENTRY AND ADD ITS ADDRESS TO THE     *\n*        LEVEL 2 TABLE.                                               *\n***********************************************************************\n         SPACE\nNEWTT2   LR    R6,R14             SAVE TABLE ENTRY ADDR\n         LA    R2,AL1BLK          ASK FOR A FIRST-ALIAS ENTRY\n         BAL   R11,GETENT\n         ST    R2,0(,R6)          STORE ENTRY ADDR IN TABLE\n         LR    R6,R2\n         ST    R5,AL1MEMB         LINK TO MEMBER ENTRY\n         ST    R6,MEMALIAS\n         OI    MEMFLAGS,$PSMAIN   INDICATE MAY BECOME MAIN\n         DROP  R5,R6\n         SPACE\n***********************************************************************\n*        PROCEED TO THE NEXT DIRECTORY ENTRY.                         *\n***********************************************************************\n         SPACE\nNEXTENT  SR    R2,R2\n         IC    R2,11(,R9)         GET DIRECTORY HALFWORD COUNT\n         SLL   R2,27              CLEAR ALIAS & TTRN COUNT\n         SRL   R2,26              MULTIPLY BY 2\n         LA    R9,12(R2,R9)       ON TO THE NEXT ONE\n         B     SAMEDIR\n         EJECT\n***********************************************************************\n*        CHECK EACH NON-ALIAS MEMBER FOR A MATCHING ALIAS, AND LINK   *\n*        THE FIRST ALIAS TO ITS MAIN MEMBER IF SO. ALSO, TURN OFF THE *\n*        PSEUDO-MAIN FLAG IN THE MEMBER ENTRY FOR EACH LINKED ALIAS.  *\n*        THEN, AT COMPLETION OF THIS PROCESSING, ONLY THOSE ALIASES   *\n*        WITHOUT A CORRESPONDING NON-ALIAS WILL HAVE THIS FLAG SET.   *\n***********************************************************************\n         SPACE\nENDDIR   L     R2,TTTAB1          LOAD LEVEL 1 TABLE ADDR\n         LTR   R2,R2              WAS ONE EVER MADE?\n         BZ    CLOSEDIR           NO, NO ALIASES EXIST\n         L     R8,MEMBLK          YES, FIND FIRST MEMBER TABLE BLOCK\n         LA    R5,BLKDATA(,R8)    FIND FIRST ENTRY IN BLOCK\n         USING MEMBER,R5\nCONNLOOP TM    MEMFLAGS,$ALIAS    IS THIS AN ALIAS?\n         BNZ   NEXTCONN           YES, SKIP CONNECTION\n         SR    R14,R14            NO, CHECK FOR ALIAS\n         ICM   R14,B'0011',MEMTTR LOAD THE TT\n         SRDL  R14,4              SPLIT OFF LAST NYBBLE\n         SRL   R15,26\n         SLL   R14,2              TO GET TABLE INDICES\n         AR    R14,R2             FIND LEVEL 1 ENTRY\n         ICM   R6,B'1111',0(R14)  ANYTHING AT LEVEL 2?\n         BZ    NEXTCONN           NO, NO ALIASES\n         AR    R6,R15             YES, FIND LEVEL 2 ENTRY\n         ICM   R6,B'1111',0(R6)   DOES IT LEAD ANYWHERE?\n         BZ    NEXTCONN           NO.\n         SPACE\n         USING ALIAS1,R6\nALISRCH2 L     R14,AL1MEMB        FIND MEMBER ENTRY FOR ALIAS\n         CLC   MEMTTR+2(1),MEMTTR+2-MEMBER(R14)  SAME R?\n         BE    CONNECT            YES, LINK ALIAS TO MAIN\n         BL    NEXTCONN           TOO HIGH, NO ALIAS EXISTS\n         ICM   R6,B'1111',AL1CHAIN     TOO LOW, LOOK AT NEXT\n         BNZ   ALISRCH2           IF ANY MORE TO LOOK AT\n         B     NEXTCONN           IF NOT, TRY NEXT MEMBER\n         SPACE\nCONNECT  ST    R6,MEMALIAS        CONNECT ALIAS TO MEMBER\n         ST    R5,AL1MAIN         AND MEMBER TO ALIAS\n         L     R6,AL1MEMB         LOCATE MEMBER ENTRY FOR ALIAS\n         NI    MEMFLAGS-MEMBER(R6),255-$PSMAIN  INDICATE NOT MAIN\n         SPACE\nNEXTCONN LA    R5,MEMBLEN(,R5)    TO NEXT MEMBER ENTRY\n         C     R5,BLKNEXT(,R8)    REACHED END OF USED BLOCK?\n         BNH   CONNLOOP           NO, CONTINUE\n         C     R8,MEMBLK+4        YES, COMPARE TO FINAL BLOCK\n         BE    FREETTAB           READY TO PRINT IF SO\n         L     R8,BLKCHAIN(,R8)   IF NOT, FIND NEXT BLOCK\n         LA    R5,BLKDATA(,R8)    ADDRESS END OF BLOCK\n         B     CONNLOOP           AND CONTINUE CONNECTION\n         DROP  R5\n         SPACE\nFREETTAB FREEMAIN R,A=(R2),LV=16384   RETURN LEVEL 1 TABLE\n         SPACE\nCLOSEDIR CLOSE (QSAMDCB)          CLOSE UP THE DIRECTORY\n         FREEPOOL QSAMDCB         AND RETURN ITS BUFFERS\n         SPACE\n         DROP  R6\n         EJECT\n         SPACE\n***********************************************************************\n*        OPEN FILES, AND GATHER RECORD FORMAT INFORMATION FOR LATER   *\n*        USE.                                                         *\n***********************************************************************\n         SPACE\n         OPEN  (BPAMDCB,(INPUT))  OPEN PDS AS PDS\n         LTR   R15,R15            GOOD OPEN?\n         BZ    PDSOK              YEAH.\n         LA    R2,LIBNOP          NO, SEND MESSAGE\n         BAL   R11,ERRMSG\n         LA    R15,16\n         B     ABORT              GO TERMINATE PROGRAM\n         SPACE\nPDSOK    MVC   DSNAME,JFCB        PUT DSNAME INTO TITLES\n         MVC   TDSNAME,JFCB\n         TM    BPMRECFM,X'80'     IS THIS V FORMAT?\n         BNZ   NOTVFORM\n         MVI   VARFORM,X'FF'      YES, SET FLAG\n         TM    BPMRECFM,X'08'     YES, IS IT SPANNED?\n         BZ    NOTVFORM\n         MVI   SPANNED,X'FF'      YES, SET FLAG\nNOTVFORM LH    R3,BPMLRECL        GET PDS RECLEN\n         CLI   VARFORM,X'FF'      V FORMAT?\n         BE    MINUS4             YES.\n         TM    BPMRECFM,X'C0'     NO, IS IT U FORMAT?\n         BNO   JLRECL             NO.\n         LH    R3,BPMBLKSI        YES, BLKSIZE IS MAX RECLEN\n         B     JLRECL\nMINUS4   SH    R3,=H'4'           COMPENSATE FOR DESCRIPTOR WORD\nJLRECL   CL    R3,=F'132'         MAY THERE BE MORE THAN A LINE?\n         BL    ONELINE\n         MVI   LINELEN+1,131      YES, RESERVE LAST COLUMN FOR +\n         SPACE\nONELINE  OPEN  (SYSTOC,(OUTPUT),SYSOUT,(OUTPUT)) OPEN LISTINGS\n         LTR   R15,R15            ANY TROUBLE?\n         BZ    OUTOK              NO.\n         LA    R2,NOUTPUT         YES, SEND ERROR MSG\n         BAL   R11,ERRMSG\n         LA    R15,16\n         B     ABORT              AND GIVE UP\n         SPACE\n***********************************************************************\n*        GET THE TIME AND DATE, AND ADD THEM TO THE PAGE HEADINGS.    *\n***********************************************************************\n         SPACE\nOUTOK    TIME  DEC                GET DATE & TIME\n         ST    R0,DECWORK+4\n         OI    DECWORK+7,X'0F'\n         ED    TTIME(9),DECWORK+4 EDIT TIME INTO TITLE\n         ST    R1,DECWORK\n         UNPK  JDATE,DECWORK(4)\n         OI    JDATE+4,X'F0'\n         CALL  JULIAN,(JDATE,GDATE),VL CALL JULIAN->GREGORIAN ROUTINE\n         MVC   TDATE(2),GDATE     FORMAT INTO TITLE\n         MVC   TDATE+3(2),GDATE+2\n         MVC   TDATE+6(2),GDATE+4\n         SPACE\n         MVC   CDATE,TDATE        PUT DATE & TIME IN TOC TITLES TOO\n         MVC   CTIME,TTIME+1\n         BAL   R11,TOCEJECT       1ST TITLES ON SYSTOC\n         SR    R10,R10            SET PAGE NUM TO 0\n         EJECT\n***********************************************************************\n*        NOW READ EACH MEMBER OF THE PDS, LISTING ITS CONTENTS. SAVE  *\n*        THE STARTING AND ENDING PAGE NUMBER FOR EACH MEMBER FOR      *\n*        INCLUSION IN THE TABLE OF CONTENTS.                          *\n***********************************************************************\n         SPACE\n         L     R8,MEMBLK          FIND FIRST MEMBER TABLE BLOCK\n         LA    R9,BLKDATA(,R8)    ADDR 1ST ENTRY IN BLOCK\n         SPACE\n***********************************************************************\n*        POSITION TO THE START OF THE NEXT MEMBER, AND START A NEW    *\n*        LISTING PAGE.                                                *\n***********************************************************************\n         SPACE\n         USING MEMBER,R9\nNEXTMBLK TM    MEMFLAGS,$ALIAS+$PSMAIN IS THIS (PSEUDO-)MAIN?\n         BM    NEXTMEM            NO, DON'T PRINT\n         MVC   TTRZ(3),MEMTTR     YES, EXTRACT TTR FOR MEMBER\n         MVI   TTRZ+3,0\n         POINT BPAMDCB,TTRZ       POSITION TO THAT MEMBER\n         MVC   TITLMEM,MEMNAME    MOVE MEMBER NAME TO TITLE\n         MVC   STARTOF,=C'START OF'    FOR 1ST PAGE\n         BAL   R2,EJECT           START A NEW PAGE\n         MVI   PAGE1,X'F0'        NOTE EJECT FOR PAGE 1 OF MEMBER\n         MVC   STARTOF,BLANKS     REMOVE START OF\n         MVC   MEMPAGE1,PAGENUM+1 SAVE START PAGE IN MEMBER ENTRY\n         STM   R8,R9,MBLKSAVE     SAVE MEMBER INFO TO FREE REGS\n         SPACE\n***********************************************************************\n*        START THE READ FOR THE FIRST BLOCK OF THIS MEMBER.           *\n***********************************************************************\n         SPACE\n         GETBUF BPAMDCB,R5        GET BUFFER FOR 1ST READ\n         ST    R5,PREVBUF\n         READ  DECB,SF,,(R5),MF=E BEGIN TO READ BLOCK 1\n         LR    R6,R5              FORCE CHECK BY NEXTSEG\n         LA    R8,BUFFER+1        START OF PRINT BUFFER\n         LH    R9,LINELEN         AVAILABLE PRINT POSITIONS\n         XC    CURBUF,CURBUF\n         SPACE\n***********************************************************************\n*        READ BLOCKS AND PRINT BLOCKS UNTIL THE MEMBER IS CONSUMED.   *\n***********************************************************************\n         SPACE\nPRINLOOP BAL   R11,NEXTSEG        GET THE NEXT RECORD SEGMENT\n         BAL   R11,PRINTSEG       PRINT IT\n         B     PRINLOOP           CONTINUE FOREVER\n         SPACE\n***********************************************************************\n*        WE GET HERE AFTER END-OF-DATA FOR THE CURRENT MEMBER.        *\n***********************************************************************\n         SPACE\nBPAMEOD  LM    R8,R9,MBLKSAVE     RESTORE MEMBER ENTRY PTRS\n         MVC   MEMPAGEN,PAGENUM+1 SAVE FINAL PAGE NUMBER\n         CLI   ERRFLAG,X'FF'      DID AN I/O ERROR OCCUR\n         BNE   NOERROR            NO.\n         OI    MEMFLAGS,$ERROR    YES, SET FLAG FOR CONTENTS\n         MVI   ERRFLAG,X'00'      RESET FLAG FOR NEXT MEMBER\nNOERROR  ICM   R5,B'1111',CURBUF     LOCATE CURRENT BUFFER\n         BZ    SKIPFRE1\n         FREEBUF BPAMDCB,R5       GIVE BACK TO THE POOL\nSKIPFRE1 L     R5,PREVBUF         FREE THE OTHER BUFFER\n         FREEBUF BPAMDCB,R5\n         SPACE\n***********************************************************************\n*        PROCEED TO THE NEXT MEMBER.                                  *\n***********************************************************************\n         SPACE\nNEXTMEM  LA    R9,MEMBLEN(,R9)    FIND NEXT ENTRY IN BLOCK\n         C     R9,BLKNEXT(,R8)    REACHED THE LAST USED?\n         BNH   NEXTMBLK           NO, CONTINUE\n         ICM   R8,B'1111',BLKCHAIN(R8) YES, GET NEXT BLOCK\n         BZ    ENDLIST            IF IT EXISTS\n         LA    R9,BLKDATA(,R8)    ADDRESS 1ST ENTRY\n         B     NEXTMBLK           AND PROCEED\n         EJECT\n***********************************************************************\n*        NOW THAT THE PAGE NUMBERS ARE ALL KNOWN, WRITE THE TABLE     *\n*        OF CONTENTS. THE ENTRY FOR EACH MAIN MEMBER WILL INCLUDE     *\n*        ALL ITS ALIASES; THE ENTRY FOR EACH ALIAS WILL INCLUDE THE   *\n*        CORRESPONDING MAIN MEMBER.                                   *\n***********************************************************************\n         SPACE\nENDLIST  L     R8,MEMBLK          FIND FIRST MEMBER BLOCK\n         LA    R10,BLKDATA(,R8)   FIND FIRST MEMBER IN BLOCK\n         SPACE\nNEXTTOC  LR    R9,R10             SAVE CURRENT MEMBER PTR\n         MVC   TMEMBER,MEMNAME    PUT MEMBER NAME IN LINE\n         MVC   ERRSIGN,=CL3' '    BLANK OUT ERROR FLAG\n         TM    MEMFLAGS,$ALIAS+$PSMAIN TREAT AS MAIN?\n         BNM   TOCMAIN            YES.\n         L     R15,MEMALIAS       NO, FIND MAIN MEMBER ENTRY\n         ICM   R9,B'1111',AL1MAIN-ALIAS1(R15)\n         BNZ   TOCMAIN            IF THERE IS ONE\n         L     R9,AL1MEMB-ALIAS1(,R15) ELSE USE PSEUDO-MAIN MEMBER\nTOCMAIN  MVC   TSTART,MEMPAGE1    ADD PAGE NUMBERS TO LINE\n         MVC   TEND,MEMPAGEN\n         TM    MEMFLAGS,$ERROR    I/O ERROR ON THIS MEMBER?\n         BZ    NOTERR             NO.\n         MVC   ERRSIGN,=C'***'    YES, FLAG LINE\n         SPACE\nNOTERR   CR    R9,R10             IS THIS AN ALIAS?\n         BNE   ADDMAIN            YES, ADD THE MAIN NAME\n         ICM   R5,B'1111',MEMALIAS     NO, FIND THE 1ST ALIAS\n         BZ    SPILLTOC           IF ANY\n         USING ALIAS1,R5\n         MVI   TALSIGN,C' '       MAKE SURE NO '='\n         LA    R6,TALIAS1         R6->1ST ALIAS POSITION\n         LA    R7,90(,R6)         R7->PAST LAST ALIAS COLUMN\n         TM    MEMFLAGS,$PSMAIN   IS THIS PSEUDO-MAIN\n         BNZ   OTHA1              YES, SKIP FIRST ALIAS\n         L     R9,AL1MEMB         FIND MEMBER FOR 1ST ALIAS\n         MVC   0(8,R6),MEMNAME    PUT NAME INTO LINE\n         LA    R6,10(,R6)         BUMP COLUMN POINTER\nOTHA1    ICM   R5,B'1111',AL1FIRST     FIND FIRST OTHER ALIAS\n         BZ    SPILLTOC           IF ANY\n         SPACE\n         USING ALIAS2,R5\nOTHALOOP CR    R6,R7              REACHED END OF LINE?\n         BL    ADDOTHAL           NO, ADD TO LINE\n         BAL   R11,BUMPTOC        YES, BUMP LINE COUNTER\n         PUT   SYSTOC,TOCLINE     PUT OUT LAST LINE\n         MVI   TMEMBER,C' '       BLANK OUT TOC BUFFER\n         MVC   TMEMBER+1(TOCLEN-5),TMEMBER  COMPLETELY\n         LA    R6,TALIAS1         START OVER WITH FIRST ALIAS POS\nADDOTHAL L     R9,AL2MEMB         FIND MEMBER ENTRY FOR ALIAS\n         MVC   0(8,R6),MEMNAME    ADD NAME TO LINE\n         LA    R6,10(,R6)         ADVANCE OUTPUT POINTER\n         ICM   R5,B'1111',AL2CHAIN     FIND NEXT ALIAS\n         BNZ   OTHALOOP           CONTINUE IF ANY\n         B     SPILLTOC           ELSE PRINT FINAL LINE\n         SPACE\nADDMAIN  MVI   TALSIGN,C'='       INDICATE THIS IS ALIAS\n         MVC   TALIAS1(8),MEMNAME STORE NAME OF MAIN MEMBER\n         SPACE\nSPILLTOC BAL   R11,BUMPTOC        ADD TO TOC LINE CTR\n         PUT   SYSTOC,TOCLINE     WRITE THE LINE\n         MVI   TMEMBER,C' '       BLANK OUT TOC BUFFER\n         MVC   TMEMBER+1(TOCLEN-5),TMEMBER  COMPLETELY\n         LA    R10,MEMBLEN(,R10)  FIND NEXT MEMBER IN BLOCK\n         C     R10,BLKNEXT(,R8)   COMPARE TO LAST ENTRY USED\n         BNH   NEXTTOC            PROCEED IF STILL IN BLOCK\n         ICM   R8,B'1111',BLKCHAIN(R8) ELSE FIND NEXT BLOCK\n         BZ    ENDPGM             IF ANY\n         LA    R10,BLKDATA(,R8)   FIND START OF DATA\n         B     NEXTTOC            AND CONTINUE\n         EJECT\n***********************************************************************\n*        COME HERE TO TERMINATE, NORMALLY OR ABNORMALLY.              *\n***********************************************************************\n         SPACE\nABORT    STH   R15,RETC           SAVE ABNORMAL RETURN CODE\n         SPACE\nENDPGM   CLOSE (BPAMDCB,,QSAMDCB,,SYSOUT,,SYSTOC,,MSGDCB) CLOSE UP\n         LH    R15,RETC           LOAD THE RETURN CODE\n         RETURNX RC=(15)          AND RETURN\n         EJECT\n***********************************************************************\n*        THIS SUBROUTINE GETS A NEW ENTRY FROM A BLOCK OF DATA AND,   *\n*        IF NO ENTRIES EXIST, ALLOCATES A NEW BLOCK. THIS IS USED     *\n*        FOR MANAGEMENT OF THE MEMBER AND ALIAS TABLES.               *\n***********************************************************************\n         SPACE\nGETENT   ICM   R1,B'1111',4(R2)   FIND THE CURRENT BLOCK\n         BNZ   HAVEBLK            IF THERE IS ONE\n         GETMAIN R,LV=4096        IF NOT, GET ONE\n         ST    R1,0(,R2)          SAVE AS FIRST BLOCK\n         SPACE\nNEWBLK   ST    R1,4(,R2)          SAVE AS CURRENT BLOCK\n         LA    R14,4095(,R1)      FIND END OF BLOCK\n         S     R14,8(,R2)         BACK UP BY ENTRY LENGTH\n         ST    R14,BLKEND(,R1)    STORE IN BLOCK HEADER\n         LA    R14,BLKDATA(,R1)   POINT TO START OF DATA AREA\n         S     R14,8(,R2)         BACK UP BY LENGTH\n         ST    R14,BLKNEXT(,R1)   STORE IN NEXT PTR\n         XC    BLKCHAIN(,R1),BLKCHAIN(R1)   ZERO THE CHAIN PTR\n         SPACE\nHAVEBLK  LM    R14,R15,BLKNEXT(R1)     LOAD NEXT & END\n         L     R0,8(,R2)          LOAD ENTRY LENGTH\n         BXLE  R0,R14,CLRENT      BRANCH IF SPACE LEFT\n         GETMAIN R,LV=4096        ELSE GET ANOTHER BLOCK\n         L     R14,4(,R2)         CHAIN TO PREVIOUS BLOCK\n         ST    R1,BLKCHAIN(,R14)\n         B     NEWBLK             AND GET FIRST ENTRY\n         SPACE\nCLRENT   ST    R0,BLKNEXT(,R1)    STORE NEW NEXT POINTER\n         L     R1,8(,R2)          LOAD ENTRY LENGTH\n         LR    R2,R0              SAVE NEW BLOCK PTR\n         SR    R15,R15\n         MVCL  R0,R14             CLEAR NEW ENTRY\n         BR    R11                AND RETURN\n         EJECT\n***********************************************************************\n*        THIS SUBROUTINE CHECKS FOR A FULL OUTPUT PAGE.               *\n***********************************************************************\n         SPACE\nBUMPLINE TM    BPMRECFM,X'06'     IS THIS A PRINT PDS?\n         BNZ   PAGECK             YES, DON'T COUNT LINES\n         LA    R7,1(,R7)          INCREASE LINE NUMBER\n         CH    R7,LINEMAX         REACHED THE MAX?\n         BLR   R2                 NO, RETURN\n         B     EJECT\nPAGECK   CLI   BUFFER,C'1'        DOES THIS LINE WANT EJECT?\n         BNE   RESETPG1           NO, JUST PROCEED\n         TM    PAGE1,X'0F'        YES, IS THIS FIRST LINE OF MEMBER?\n         BZ    POSTEJEC           YES, DON'T EJECT AGAIN\n         SPACE\n***********************************************************************\n*        THIS SUBROUTINE STARTS A NEW LISTING PAGE.                   *\n***********************************************************************\n         SPACE\nEJECT    LA    R10,1(,R10)        INCREASE PAGE NUMBER\n         CVD   R10,DECWORK        CONVERT TO PRINTABLE\n         MVC   PAGENUM+1(5),=X'2020202120'\n         ED    PAGENUM(6),DECWORK+5\n         PUT   SYSOUT,HEADER\n         TM    BPMRECFM,X'06'     PRINT FORMAT PDS?\n         BNZ   ASAHEAD            YES, CHANGE TITLE FORMAT\n         PUT   SYSOUT,BLANKMSG    SKIP AFTER HEADING\n         LA    R7,2               RESET LINE NUMBER\n         BR    R2                 AND RETURN\n         SPACE\nASAHEAD  MVC   UNDRSCOR,=120C'_'\n         PUT   SYSOUT,UNDERMSG    UNDERLINE OUR TITLE\nPOSTEJEC MVI   BUFFER,C'0'        DOUBLE SPACE FOR HIS TITLE\nRESETPG1 MVI   PAGE1,X'FF'\n         BR    R2                 AND RETURN\n         EJECT\n***********************************************************************\n*        THIS SUBROUTINE CHECKS FOR A FULL DIRECTORY PAGE.            *\n***********************************************************************\n         SPACE\nBUMPTOC  LA    R2,1\n         AH    R2,TOCLNCT         COMPUTE NEW LINE NUMBER\n         STH   R2,TOCLNCT\n         CH    R2,LINEMAX         IS THE PAGE FULL?\n         BLR   R11                NO, PROCEED\n         SPACE\n***********************************************************************\n*        THIS SUBROUTINE STARTS A NEW CONTENTS PAGE.                  *\n***********************************************************************\n         SPACE\nTOCEJECT LA    R2,1\n         AH    R2,TOCPAGE         COMPUTE NEW PAGE NUMBER\n         STH   R2,TOCPAGE\n         CVD   R2,DECWORK\n         MVC   CPAGE+1(5),=X'2020202120'\n         ED    CPAGE(6),DECWORK+5 EDIT INTO TITLE LINE\n         PUT   SYSTOC,THEADER1    PUT OUT TOP TITLE\n         PUT   SYSTOC,THEADER2    AND COLUMN HEADINGS\n         PUT   SYSTOC,BLANKMSG    SKIP AFTERWARDS\n         MVC   TOCLNCT,=H'4'      RESET LINE NUMBER\n         BR    R11                AND RETURN\n         EJECT\n***********************************************************************\n*        THIS ROUTINE GETS THE NEXT RECORD OR RECORD SEGMENT, ISSUING *\n*        A READ IF NO DATA REMAINS IN THE CURRENT BLOCK.              *\n***********************************************************************\n         SPACE\nNEXTSEG  MVI   SEGTYPE,0          ASSUME UNSPANNED RECORD\n         TM    BPMRECFM,X'10'     IS THE PDS BLOCKED?\n         BZ    READSEG            NO, LOOK AT NEXT BLOCK\n         CR    R5,R6              YES, IS THE BLOCK USED UP?\n         BNL   READSEG            YES, TRY THE NEXT\n         CLI   VARFORM,X'FF'      NO, IS IT VB?\n         BNE   FIXDSEG            NO.\n         SPACE\nVARSEG   LH    R4,0(,R5)          LOAD LENGTH OF THIS RECORD\n         LA    R3,4(,R5)          SKIP TO DATA\n         CLI   SPANNED,X'FF'      SPANNED FORMAT?\n         BNE   NOTSPAND           NO.\n         MVC   SEGTYPE,2(R5)      COPY SEGMENTATION FLAGS\nNOTSPAND AR    R5,R4              POINT R5 TO NEXT RECORD\n         SH    R4,=H'4'           GET DATA LENGTH IN R4\n         B     CTLCHECK           GO CHECK FOR CTL CHARS\n         SPACE\nFIXDSEG  TM    BPMRECFM,X'40'     IS THIS F OR U FORMAT?\n         BNZ   UFORM              U.\n         LH    R4,BPMLRECL        F, LOAD RECORD LENGTH\nUFORM    LR    R3,R5              POINT R3 TO DATA\n         AR    R5,R4              POINT R5 TO NEXT RECORD OF BLOCK\n         SPACE\n***********************************************************************\n*        FOR A OR M FORMAT DATA SETS, SPECIAL PROCESSING IS REQUIRED. *\n*        FOR AN ASA DATA SET, WE JUST STORE THE CONTROL CHARACTER IN  *\n*        THE OUTPUT BUFFER, EXCEPT THAT SKIP TO CHANNEL N>1 IS        *\n*        REPLACED BY A DOUBLE SPACE. FOR A M TYPE DATA SET, WE        *\n*        TRANSLATE THE CHARACTER TO THE CORRESPONDING ASA CHARACTER.  *\n*        IF THE OPERATION IS A PRINT & CONTROL, WE SAVE THE ASA       *\n*        CHARACTER FOR THE NEXT LINE. IF IT IS JUST A CONTROL, WE     *\n*        SIMULATE AN EMPTY INPUT RECORD TO GET THE CONTROL CHAR SENT. *\n***********************************************************************\n         SPACE\nCTLCHECK TM    SEGTYPE,X'02'      IS THIS A STARTING SEGMENT?\n         BZ    STARTING           YES.\n         CLI   THROWAY,X'FF'      SHOULD SEGMENT BE THROWN AWAY\n         BE    NEXTSEG            YES, TRY AGAIN\n         BR    R11                ELSE RETURN\nSTARTING MVI   THROWAY,0          STOP THROWING AWAY\n         TM    BPMRECFM,X'06'     PRINT TYPE PDS?\n         BZR   R11                NO, JUST RETURN\n         TM    BPMRECFM,X'02'     YES, MACHINE CHARS?\n         BNZ   MACHCTL            YES (GAG)\n         MVC   BUFFER(1),0(R3)    NO, MOVE ASA CHAR TO BUFFER\n         CLI   BUFFER,C'1'        IS IT A SKIP TO SPECIAL CHANNEL?\n         BNH   CTLDONE            NO.\n         MVI   BUFFER,C'0'        YES, CHANGE TO DOUBLE SPACE\nCTLDONE  LA    R3,1(,R3)          POINT PAST CTL CHAR\n         BCTR  R4,0               FIX UP LENGTH\n         BR    R11                AND RETURN\n         SPACE\nMACHCTL  CLI   0(R3),X'8B'        IS THIS A SKIP TO SPECIAL CHAN?\n         BNH   NOCHAN             NO.\n         MVI   NEXTCARR,C'0'      YES, MAKE DOUBLE SPACE\n         B     MACHDONE\nNOCHAN   LA    R15,=C'1'          ASSUME PAGE THROW\n         TM    0(R3),X'80'        WERE WE RIGHT?\n         BNZ   TRANCTL            YES.\n         SR    R15,R15\n         IC    R15,0(,R3)\n         SRL   R15,3\n         LA    R15,ASATAB(R15)    YES, TRANSLATE TO ASA\nTRANCTL  MVC   NEXTCARR,0(R15)    BUFFER FOR LATER\nMACHDONE TM    0(R3),X'02'        IS THIS AN IMMEDIATE SKIP?\n         BZ    CTLDONE            NO, PROCEED\n         XI    PAGE1,X'F0'        STARTING NEW MEMBER?\n         BNZ   NOTTOP             NO, PROCEED\n         MVC   BUFFER(1),NEXTCARR YES, COPY OVER CTL CHAR\n         B     NEXTSEG            AND PROCEED TO NEXT INPUT\nNOTTOP   MVI   SEGTYPE,0          PRETEND ONLY SEGMENT\n         MVI   THROWAY,X'FF'      THROW OUT FURTHER SEGMENTS\n         SR    R4,R4              CLAIM 0 LENGTH LINE\n         BR    R11                RETURN TO SEND CTL CHAR\n         EJECT\n***********************************************************************\n*        WE GET HERE WHEN WE NEED THE NEXT INPUT BLOCK, FOR WHICH A   *\n*        READ WAS PREVIOUSLY ISSUED. WE CHECK THIS READ, AND          *\n*        ANTICIPATE THE NEXT BLOCK, SWITCHING TO THE OTHER BUFFER     *\n*        FIRST.                                                       *\n***********************************************************************\n         SPACE\nREADSEG  ICM   R5,B'1111',CURBUF  FIND USED-UP BUFFER\n         BZ    NOFREEB            IF ANY\n         FREEBUF BPAMDCB,R5       PUT BACK IN POOL\n         SPACE\nNOFREEB  CHECK DECB               WAIT FOR INPUT TO WORK\n         CLI   ERRFLAG,X'FF'      WAS THE SYNAD ENTERED?\n         BE    BPAMERR            YES, GO TO ABORT MEMBER\n         L     R5,PREVBUF         NO, FIND THE INPUT BUFFER\n         ST    R5,CURBUF\n         GETBUF BPAMDCB,R2        GET THE OTHER ONE FOR ANTICIPATION\n         L     R6,DECB+16         FIND CSW RESIDUAL COUNT\n         LH    R6,14(,R6)         BEFORE REUSING DECB\n         READ  DECB,SF,,(R2),MF=E READ THE NEXT BLOCK\n         ST    R2,PREVBUF         SAVE NEW INPUT BUFFER ADDR\n         CLI   VARFORM,X'FF'      V TYPE FILE?\n         BNE   FIXED              NO, F OR U\n         LH    R6,0(,R5)\n         AR    R6,R5              FIND THE END OF BLOCK\n         LA    R5,4(,R5)          POINT R5 TO 1ST RECORD\n         B     VARSEG             GO TO USE 1ST RECORD\n         SPACE\nFIXED    LH    R4,BPMBLKSI\n         SR    R4,R6              COMPUTE AMOUNT READ\n         LA    R6,0(R5,R4)        POINT TO BLOCK END\n         B     FIXDSEG            GO HANDLE 1ST RECORD\n         EJECT\n***********************************************************************\n*        THIS CODE IS ENTERED AFTER THE SYNAD EXIT DETECTS AN ERROR.  *\n*        IT PRINTS A DIAGNOSTIC MESSAGE AND ABORTS THE PRINTING       *\n*        OF THE CURRENT MEMBER.                                       *\n***********************************************************************\n         SPACE\nBPAMERR  MVC   MEMBERR,TITLMEM    PUT MEMBER NAME INTO MSG\n         LA    R2,IOMSG\n         BAL   R11,ERRMSG         GO WRITE AN ERROR MSG\n         MVI   RETC+1,8           SET NOTABLE RETURN CODE\n         B     BPAMEOD            TERMINATE THIS MEMBER\n         EJECT\n***********************************************************************\n*        THIS ROUTINE IS CALLED TO PRINT A LOGICAL RECORD OR RECORD   *\n*        SEGMENT.  IF THE TEXT IS LONGER THAN A PRINT LINE, MULTIPLE  *\n*        LINES ARE PRINTED, WITH EACH CONTINUED LINE HAVING A \"+\" IN  *\n*        COLUMN 132 TO INDICATE CONTINUATION.  IF THE TEXT TO BE      *\n*        PRINTED IS AN INTERNAL SEGMENT OF A SPANNED RECORD, THE FINAL*\n*        LINE IS NOT PRINTED, AS ADDITIONAL TEXT CAN BE APPENDED FOR  *\n*        THE FOLLOWING SEGMENT(S).                                    *\n***********************************************************************\n         SPACE\nPRINTSEG LTR   R1,R4              ASSUME WHOLE RECORD TO PRINT\n         BZ    SEGEND             HANDLE EMPTY LINE\n         CR    R4,R9              IS THERE ROOM FOR ALL?\n         BNH   SHORTSEG           YES.\n         LTR   R1,R9              NO, JUST PRINT WHAT WILL FIT\n         BZ    SPILLSEG           SPILL BUFFER IF NOTHING TO MOVE\nSHORTSEG BCTR  R1,0\n         EX    R1,MVSEG           MOVE TEXT TO PRINT LINE\n         LA    R1,1(,R1)          RESTORE FULL LENGTH\n         AR    R3,R1              BUMP INPUT POINTER\n         AR    R8,R1              BUMP OUTPUT POINTER\n         SR    R4,R1              COMPUTE LENGTH LEFT\n         BZ    SEGEND             IF NO MORE INPUT LEFT\nSPILLSEG MVI   BUFFER+132,C'+'    INDICATE CONTINUATION\n         MVC   BUFLEN,=H'137'     SET RECORD LENGTH\n         BAL   R2,BUMPLINE        CHECK FOR PAGE END\n         PUT   SYSOUT,BUFLEN      NOW PRINT THE LINE\n         LA    R8,BUFFER+1        RESET THE OUTPUT POINTER\n         LH    R9,LINELEN         READY TO START NEW LINE\n         MVI   BUFFER,C' '        SET CONTINUATION CONTROL CHAR\n         B     PRINTSEG           CONTINUE WITH INPUT TEXT\n         SPACE\nSEGEND   TM    SEGTYPE,X'01'      IS THIS A FINAL SEGMENT?\n         BNZ   NOTYET             NO.\n         LH    R15,LINELEN\n         SR    R15,R9\n         LA    R1,5(R1,R15)       COMPUTE LENGTH OF PRINT LINE\n         STH   R1,BUFLEN\n         BAL   R2,BUMPLINE        BUMP THE LINE COUNTER\n         PUT   SYSOUT,BUFLEN      PRINT THE LINE\n         LA    R8,BUFFER+1        RESET OUTPUT POINTER\n         LH    R9,LINELEN         AND LINE LENGTH\n         TM    BPMRECFM,X'02'     MACHINE CTL DATA SET?\n         BZR   R11                NO, RETURN\n         MVC   BUFFER(1),NEXTCARR YES, INSERT BUFFERED CTL CHAR\n         BR    R11                AND THEN RETURN\n         SPACE\nNOTYET   LA    R1,1(,R1)\n         SR    R9,R1              ADJUST THE LENGTH LEFT IN LINE\n         BR    R11                RETURN TO GET NEXT SEGMENT\n         EJECT\n***********************************************************************\n*        THIS ROUTINE IS CALLED TO PRINT A DIAGNOSTIC MESSAGE. IT     *\n*        ATTEMPTS TO WRITE THE MESSAGE TO SYSPRINT. IF SYSPRINT       *\n*        CANNOT BE OPENED, IT USES WTP TO SEND THE MESSAGE INSTEAD.   *\n***********************************************************************\n         SPACE\nERRMSG   CLI   MSGOPEN,0          OPEN OF SYSPRINT ATTEMPTED?\n         BNE   ALREADY            YES.\n         OPEN  (MSGDCB,(OUTPUT))  NO, TRY IT NOW\nALREADY  TM    MSGOFLGS,X'10'     DID IT OPEN?\n         BNZ   ERROPEN            YES.\n         XWTO  MF=(E,(R2))        NO, SEND BY WTO\n         BR    R11                AND RETURN TO CALLER\n         SPACE\nERROPEN  MVI   2(R2),0            MAKE SURE V PREFIX OK\n         PUT   MSGDCB,(R2)        PRINT THE MESSAGE\n         BR    R11                AND RETURN\n         EJECT\n***********************************************************************\n*        THIS ROUTINE IS A SYNAD EXIT FOR SYSLIB.  IF THE ERROR WAS   *\n*        A LENGTH ERROR, A MESSAGE IS PRINTED AND THE RUN IS          *\n*        TERMINATED. OTHERWISE, A FLAG IS SET AND RETURN IS MADE      *\n*        TO THE SYSTEM. THIS WILL CAUSE TERMINATION OF PROCESSING     *\n*        OF THE CURRENT MEMBER.                                       *\n***********************************************************************\n         SPACE\nBPAMSYN  LR    R1,R0              MOVE DECB ADDR TO USABLE REG\n         L     R1,16(,R1)         FIND THE IOB\n         TM    12(R1),X'02'       UNIT CHECK?\n         BNZ   ACCERR             YES, ALLOW CONTINUATION\n         TM    13(R1),X'40'       NO, IS THIS A WRONG-LENGTH ERROR?\n         BNZ   LENERR             YES, GO NO FURTHER\nACCERR   MVI   ERRFLAG,X'FF'      SET TROUBLE FLAG\n         BR    R14                AND RETURN TO BPAM\n         SPACE\nLENERR   LA    R2,WRONGLEN\n         BAL   R11,ERRMSG         SEND WRONG-LENGTH MSG\n         LA    R15,16             TERMINAL ERROR\n         B     ABORT              END THE PROGRAM\n         SPACE 3\n***********************************************************************\n*        THIS ROUTINE IS A SYNAD EXIT FOR THE SYSLIB DIRECTORY.       *\n*        IT PUTS OUT AN ERROR MESSAGE AND ABORTS THE JOB.             *\n***********************************************************************\n         SPACE\nQSAMSYN  LA    R2,DIRERR\n         BAL   R11,ERRMSG         SEND DIRECTORY ERROR MSG\n         LA    R15,16             INDICATE HORRIBLE CONCLUSION\n         B     ABORT\n         SPACE 3\n***********************************************************************\n*        THIS ROUTINE ESTABLISHES A DEFAULT BLOCKSIZE FOR A PRINT DATA*\n*        SET IF NONE IS SUPPLIED BY THE USER.                         *\n***********************************************************************\n         SPACE\n         USING IHADCB,R1\nOUTEX    LH    R0,DCBBLKSI        GET BLOCKSIZE FROM DCB\n         LTR   R0,R0              IS IT THERE?\n         BNZR  R14                YES, RETURN\n         LA    R0,4               NO, USE LRECL+4\n         AH    R0,DCBLRECL\n         STH   R0,DCBBLKSI\n         BR    R14                AND THEN RETURN\n         EJECT\nPACKPARM PACK  DECWORK(8),2(0,R11)     PACK THE PARM VALUE\nTESTPARM NC    NUMERIC(0),2(R11)  AND THE PARM WITH 3C'0'\nPARMSGMV MVC   PARMNAME(0),2(R11) PUT PARM VALUE INTO MSG\nMVSEG    MVC   0(0,R8),0(R3)      MOVE TEXT TO PRINT LINE\n         SPACE\nSAVEAREA DC    18A(0)\nJFCB     DS    CL176              SPACE FOR SYSLIB JFCB\nDECWORK  DS    D                  DECIMAL WORK AREA\nTTRZ     DC    F'0'               FOR POINT MACRO\nMBLKSAVE DS    2A                 REGISTER SAVE AREA FOR DIRECTORY\nQSAMXLST DCBEXLST JFCB=JFCB\nOUTXLST  DCBEXLST DCBEXIT=OUTEX\n         READ  DECB,SF,BPAMDCB,,'S',MF=L\nBPAMDCB  DCB   DDNAME=SYSLIB,DSORG=PO,DEVD=DA,MACRF=(R),               *\n               EODAD=BPAMEOD,BUFNO=2,SYNAD=BPAMSYN\nQSAMDCB  DCB   DDNAME=SYSLIB,DSORG=PS,DEVD=DA,MACRF=(GM),              *\n               EODAD=ENDDIR,BLKSIZE=256,LRECL=256,RECFM=F,             *\n               SYNAD=QSAMSYN,EXLST=QSAMXLST\nMSGDCB   DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=(PM),                    *\n               LRECL=125,RECFM=VBA,EXLST=OUTXLST\nSYSOUT   DCB   DDNAME=SYSOUT,DSORG=PS,MACRF=(PM),                      *\n               LRECL=137,RECFM=VBA,EXLST=OUTXLST\nSYSTOC   DCB   DDNAME=SYSTOC,DSORG=PS,MACRF=(PM),                      *\n               LRECL=137,RECFM=VBA,EXLST=OUTXLST\nPREVBUF  DC    A(0)               ADDR OF BUSY BUFFER\nCURBUF   DC    A(0)               ADDR OF BUFFER IN USE\nTTTAB1   DC    A(0)               FIRST-LEVEL TTR TABLE ADDR\nLINEMAX  DC    H'55'              DEFAULT LINES PER PAGE\nRETC     DC    H'0'               ULTIMATE RETURN CODE\nLINELEN  DC    H'132'             DEFAULT LINE LENGTH\nTOCPAGE  DC    H'0'               TABLE OF CONTENTS PAGE NUMBER\nTOCLNCT  DS    H                  TABLE OF CONTENTS LINE NUMBER\nBUFLEN   DC    2H'0'              LENGTH PART OF PRINT BUFFER\nBUFFER   DC    CL133' '           DATA TO PRINT\nDIRBLK   DS    CL256              DIRECTORY BLOCK AREA\nNUMERIC  DC    C'000'             USED IN PARM VALIDATION\nVARFORM  DC    X'00'              V FORMAT FLAG\nSPANNED  DC    X'00'              SPANNED FORMAT FLAG\nJDATE    DS    CL5                JULIAN DATE\nGDATE    DC    CL6'000000'        GREGORIAN DATE\nSEGTYPE  DC    X'00'              SPANNED SEGMENT TYPE\nMSGOPEN  DC    X'00'              SYSPRINT OPEN ATTEMPT MADE FLAG\nERRFLAG  DC    X'00'              INPUT ERROR FLAG\nASATAB   DC    C'+ 0-'            RECFM M ASA EQUIVALENTS\nNEXTCARR DC    C' '               NEXT LINE'S CTL CHAR\nPAGE1    DC    X'00'              1ST PAGE FOR MEMBER FLAG\nTHROWAY  DC    X'00'              THROW AWAY REST OF LRECL FLAG\n         PRINT NOGEN\nTHEADER1 XWTO  '1DIRECTORY OF DSN=',(TDSNAME,44' '),5' ',(CDATE,8),    *\n               6' ',(CTIME,8),'     PAGE',(CPAGE,6' '),MF=L\nTHEADER2 XWTO  '0MEMBER    BEGIN PAGE    END PAGE   ERR   ALIAS NAMES',*\n               MF=L\nBLANKMSG XWTO  (BLANKS,16' '),MF=L\nTOCLINE  XWTO  ' ',(TMEMBER,8),5' ',(TSTART,5),7' ',(TEND,5),          *\n               5' ',(ERRSIGN,3' '),2' ',(TALSIGN,' '),(TALIAS1,90' '), *\n               MF=L\nTOCLEN   EQU   *-TOCLINE          LENGTH OF TOC LINE\nHEADER   XWTO  '1',(STARTOF,8' '),' MEMBER ',(TITLMEM,8),'   DSN=',    *\n               (DSNAME,44' '),5' ',(TDATE,'  /  /  '),5' ',            *\n               (TTIME,X'4021204B20204B2020'),'     PAGE',              *\n               (PAGENUM,6' '),MF=L\nUNDERMSG XWTO  '+',(UNDRSCOR,120' '),MF=L\nNOSYSLIB XWTO  ' UEB460T SYSLIB DD STATEMENT MISSING.  RUN TERMINATED',*\n               ROUTCDE=11,DESC=7,MF=L\nLIBNOP   XWTO  ' UEB461T UNABLE TO OPEN SYSLIB.  RUN TERMINATED',      *\n               ROUTCDE=11,DESC=7,MF=L\nPARMSG   XWTO  ' UEB462W INVALID PARM IGNORED: ',(PARMNAME,10' '),     *\n               (DOTROOM,3' '),ROUTCDE=11,DESC=7,MF=L\nNOUTPUT  XWTO  ' UEB463T UNABLE TO OPEN SYSTOC AND/OR SYSOUT.  RUN TERM*\n               INATED',ROUTCDE=11,DESC=7,MF=L\nIOMSG    XWTO  ' UEB464E INPUT ERROR.  LISTING OF MEMBER ',            *\n               (MEMBERR,8),' TERMINATED',ROUTCDE=11,DESC=7,MF=L\nWRONGLEN XWTO  ' UEB465T WRONG LENGTH RECORD.  THE SYSLIB DCB IS PROBAB*\n               LY INCORRECT',ROUTCDE=11,DESC=7,MF=L\nDIRERR   XWTO  ' UEB466T ERROR READING SYSLIB DIRECTORY.  RUN TERMINATE*\n               D',ROUTCDE=11,DESC=7,MF=L\n         EJECT\nMEMBER   DSECT ,                  MAPPING FOR MEMBER TABLE ENTRY\n         SPACE\nMEMNAME  DS    CL8                NAME OF MEMBER\nMEMTTR   DS    XL3                TTR FOR MEMBER\nMEMFLAGS DS    BL1                PROCESSING FLAGS\n         SPACE\n$ALIAS   EQU   X'80'              MEMBER IS AN ALIAS\n$PSMAIN  EQU   X'40'              ALIAS HAS NO MAIN MEMBER\n$ERROR   EQU   X'20'              I/O ERROR IN MEMBER\n         SPACE\nMEMALIAS DS    A                  ADDR OF FIRST ALIAS FOR MEMBER\nMEMPAGE1 DS    CL5                FIRST PAGE NUMBER\nMEMPAGEN DS    CL5                FINAL PAGE NUMBER\n         DS    0A                 FOR ALIGNMENT\nMEMBLEN  EQU   *-MEMBER           LENGTH OF MEMBER ENTRY\n         SPACE\nALIAS1   DSECT ,                  FIRST ALIAS ENTRY MAPPING\n         SPACE\nAL1CHAIN DS    A                  POINTER TO NEXT FOR THIS TTR\nAL1MEMB  DS    A                  MEMBER ENTRY FOR THIS ALIAS\nAL1MAIN  DS    A                  MAIN MEMBER FOR THIS ALIAS\nAL1FIRST DS    A                  FIRST OTHER ALIAS\nAL1LAST  DS    A                  LAST OTHER ALIAS\nAL1LEN   EQU   *-ALIAS1           LENGTH OF FIRST ALIAS ENTRY\n         SPACE\nALIAS2   DSECT ,                  OTHER ALIAS ENTRY MAPPING\n         SPACE\nAL2CHAIN DS    A                  POINTER TO NEXT OTHER ALIAS\nAL2MEMB  DS    A                  MEMBER ENTRY FOR THIS ALIAS\nAL2LEN   EQU   *-ALIAS2           LENGTH OF OTHER ALIAS ENTRY\n         SPACE\nPDSPRINT CSECT ,                  RESUME MAIN CSECT\n         SPACE\nMEMBLK   DC    A(0,0,MEMBLEN)     DESCRIPTOR FOR MEMBER ENTRIES\nAL1BLK   DC    A(0,0,AL1LEN)      DESC. FOR FIRST ALIAS ENTRIES\nAL2BLK   DC    A(0,0,AL2LEN)      DESC. FOR OTHER ALIAS ENTRIES\nTT2BLK   DC    A(0,0,64)          DESC. FOR LEVEL 2 TTR TABLES\n         SPACE\nBLKCHAIN EQU   0                  OFFSET OF CHAIN FIELD IN BLK HDR\nBLKNEXT  EQU   4                  OFFSET OF CURRENT ENTRY IN BLOCK\nBLKEND   EQU   8                  OFFSET OF LAST ENTRY IN BLOCK\nBLKDATA  EQU   12                 OFFSET OF DATA FROM BLOCK START\n         EJECT\n         DCBD  DSORG=(PO)\n         SPACE\n         PRINT GEN\n         DCBEQU BPM,BPAMDCB,(RECFM,LRECL,BLKSI)\n         DCBEQU MSG,MSGDCB,OFLGS\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UEHSTAMP": {"ttr": 11526, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         TITLE 'UEHSTAMP -- PRIMITIVE OWNERSHIP STAMPER FOR DATA SETS'\nUEHSTAMP CSECT\n         SPACE\n***********************************************************************\n*        THIS ROUTINE IS INVOKED BY A SVC 237 INSTRUCTION INSERTED    *\n*        INTO EACH SVC  32 MODULE WHICH WRITES A NEW FORMAT 1 DSCB.   *\n*        ITS FUNCTION IS TO STORE THE ACF2 LOGONID UNDER WHICH        *\n*        THE DATASET WAS CREATED, IN ORDER TO ENHANCE DATA SET        *\n*        ACCOUNTING. PARAMETERS TO THIS SVC ARE: THE ADDRESS OF THE   *\n*        DSCB TO BE WRITTEN IN REG 1, AND THE UCB ADDRESS IN REG 0.   *\n*        (IN THE ABSENCE OF ACF2, THIS PICKS UP THE SMF USERID        *\n*        FIELD, WHICH YOU MAY HAVE ARRANGED TO ACTUALLY BE A USERID,  *\n*        OR SOMETHING ELSE USEFUL.)                                   *\n***********************************************************************\n         SPACE\n         DC    C'IGC0023G -- SVC 237'  FOR IDENTIFICATION\n         REGISTER\n         ENTRY IGC237             SVC ENTRY POINT\n         USING TCB,R4             STANDARD REGS FOR SVC\n         USING RBSECT,R5\n         USING IGC237,R6          SET UP BY SLIH\n         SPACE\nIGC237   L     R7,RBLINK          LOOK AT CALLER'S RB\n         TM    RBOPSW+1-RBSECT(R7),X'81'    KEY<8, SUPER STATE?\n         BNZR  R14                NO, IGNORE CALL\n         LR    R8,R0              COPY UCB ADDR FOR CONVENIENCE\n         USING UCB,R8\n         USING DSCBF1,R1\n*        TM    UCBSTAB,UCBBSTR    STORAGE VOLUME?\n*        BZR   R14                NO, DO NOTHING\n         MVC   DS1LGNID(14),=CL14' '   CLEAR LOGONID IN ADVANCE\n         MVC   DS1REFD,DS1CREDT   COPY CREATION DATE TO REF DATE\n         MVI   DS1OFLGS,0         CLEAR FLAG BYTE\n         L     R2,TCBTCT          FIND THE TCT\n         LA    R2,0(,R2)\n         LTR   R2,R2\n         BZR   R14                LEAVE USERID BLANK IF NONE\n         L     R2,TCTJMR-SMFTCT(R2)    FIND JOB MANAGEMENT RECORD\n         LTR   R2,R2              ALIAS CPA\n         BZR   R14                NO USERID IF NO CPA\n         MVC   DS1LGNID,CPAUSRID-CPA(R2)    STORE LOGONID IN DSCB\n         BR    R14                AND RETURN TO DADSM\n         SPACE\n         LTORG\n         SPACE\nDSCBF1   DSECT\n         IECSDSL1 (1)             MAP FORMAT 1 DSCB\n         ORG   DS1SYSCD-1         OVERLAY RSVD & SYSTEM CODE\nDS1LGNID DS    CL7                CREATOR'S ACF2 LOGONID\n         DS    CL7                RESERVED FOR ANOTHER LOGONID\n         DS    CL3                DATE LAST REFERENCED (THANKS, IBM)\nDS1OFLGS DS    BL1                OWNERSHIP FLAGS (TO BE DEFINED)\n         EJECT\n         PRINT NOGEN\n         IKJTCB\n         SPACE\n         IKJRB\n         SPACE\nUCB      DSECT\n         IEFUCBOB\n         SPACE\n         IEFTCT\n         SPACE\n         CPA\n         SPACE\n         END   IGC237\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UGET": {"ttr": 11528, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    UGET  &BFF,&SIZE,&EDIT,&WAIT,&CLIST,&CPPL=,&IOPL=,&MF=I,      *\n               &PROMPT=                                        RTS02A1\n         LCLA  &OPT,&GOPT                                      RTS02A1\n         LCLA  &RET\n         LCLB  &E,&W,&G\n         LCLC  &PARM,&S,&L,&CPIOPL\n&S       SETC  '&SYSNDX'                                       RTS02A1\n&L       SETC  'L'''                                           RTS02A1\n         AIF   ('&MF' EQ 'L').MFL                              RTS02A1\n         AIF   ('&MF(1)' EQ 'E').MFE                           RTS02A1\n         AIF   ('&MF(1)' EQ 'I' OR '&MF' EQ '').MFI            RTS02A1\n         IHBERMAC 35,0,&MF                                     RTS02A1\n         MEXIT                                                 RTS02A1\n.MFI     ANOP                                                  RTS02A1\n         AIF   ('&BFF' EQ '*' OR '&BFF' EQ '').ERROR1\n         AIF   ('&BFF'(1,1) EQ '(' AND ('&SIZE' EQ '' OR '&SIZE' EQ '*'*\n               )).ERROR1                                       RTS02A1\n.MFE     AIF   ('&CPPL' EQ '' AND '&IOPL' EQ '').ERROR1        RTS02A1\n         AIF   ('&CPPL' NE '' AND '&IOPL' NE '').ERROR2        RTS02A1\n&CPIOPL  SETC  '&CPPL&IOPL'                                    RTS02A1\n&PARM    SETC  '&EDIT'\n.CKPARM  ANOP\n&RET     SETA  &RET+1\n         AIF   ('&PARM' EQ '').RET           NULL, TRY NEXT\n         AIF   ('&PARM' EQ 'EDIT').EDI       SET EDIT\n         AIF   ('&PARM' EQ 'ASIS').ASI       SET ASIS\n         AIF   ('&PARM' EQ 'WAIT').WAI       SET WAIT\n         AIF   ('&PARM' EQ 'NOWAIT').NOW     SET NOWAIT\n         AIF   ('&PARM' EQ 'TERM').TERM                        RTS02A1\n         AIF   ('&PARM' EQ 'CLIST').CLIST                      RTS02A1\n         AGO   .ERROR3\n.*\n.*  CHECK REGISTER NOTATION IS USED\n.*\n.CHKREG  SPACE 1\n         AIF   ('&MF' EQ 'L').GENLIST                          RTS02A1\n         AIF   ('&MF' NE 'I' AND '&MF' NE '').GENE             RTS02A1\n.EXPAND  CNOP  0,4\n         AIF   ('&NAME' EQ '').NONAME\n&NAME    EQU   *                                               RTS02A1\n.NONAME  AIF   ('&SIZE' EQ '' OR '&SIZE' EQ '*').NOSIZER       RTS02A1\n         AIF   ('&SIZE'(1,1) NE '(').NOSIZER                   RTS02A1\n         STH   &SIZE(1),UGT&S+2   STORE MESSAGE LENGTH         RTS02A1\n.NOSIZER AIF   ('&BFF'(1,1) NE '(').NOBFFR                     RTS02A1\n         STCM  &BFF(1),7,UGT&S+5  STORE BUFFER ADDRESS         RTS02A1\n.NOBFFR  ANOP                                                  RTS02A1\n         AIF   ('&PROMPT' EQ '').NOPRMP                        RTS02A1\n         AIF   ('&MF' EQ 'I' OR '&MF' EQ '').NOPRMP            RTS02A1\n         AIF   ('&PROMPT'(1,1) EQ '(').NOPRMP                  RTS02A1\n         LA    14,4&PROMPT   ADDR TRUE START OF PROMPT PARMS   RTS02A1\n         ST    14,UGT&S+8         STORE PROMPT LIST ADDR       RTS02A1\n.NOPRMP  ANOP                                                  RTS02A1\n         BAL   1,UGE&S            BRANCH AROUND CONSTANTS      RTS02A1\nUGT&S    EQU   *                                               RTS02A1\n         AGO   .GENI                                           RTS02A1\n.GENLIST ANOP                                                  RTS02A1\n&NAME    DS    0A                                              RTS02A1\n.GENI    DC    AL2(&GOPT)               GETLINE OPTIONS        RTS02A1\n         AIF   ('&BFF' EQ '' OR '&BFF' EQ '*').DUMSIZE         RTS02A1\n         AIF   ('&SIZE' NE '' AND '&SIZE' NE '*').GOTSIZE      RTS02A1\n         DC    AL2(&L&BFF)        BUFFER LENGTH                RTS02A1\n         AGO   .JSIZE                                          RTS02A1\n.GOTSIZE AIF   ('&SIZE'(1,1) NE '(').OKSIZE                    RTS02A1\n.DUMSIZE DC    AL2(0)             BUFFER SIZE                  RTS02A1\n         AGO   .JSIZE                                          RTS02A1\n.OKSIZE  ANOP                                                  RTS02A1\n         DC    AL2(&SIZE)               BUFFER SIZE\n.JSIZE   DC    AL1(&OPT+X'80')          OPTIONS                RTS02A1\n         AIF   ('&BFF' EQ '' OR '&BFF' EQ '*').DUMBFF          RTS02A1\n         AIF   ('&BFF'(1,1) NE '(').OKBFF                      RTS02A1\n.DUMBFF  DC    AL3(0)             BUFFER ADDR                  RTS02A1\n         AGO   .JBFF                                           RTS02A1\n.OKBFF   ANOP                                                  RTS02A1\n         DC    AL3(&BFF)                BUFFER ADDR\n.JBFF    AIF   ('&PROMPT' EQ '').DUMPRMT                       RTS02A1\n         AIF   ('&PROMPT'(1,1) EQ '(').DUMPRMT                 RTS02A1\n         DC    AL4(4+&PROMPT)     ADDR OF PROMPT PARMS         RTS02A1\n         AGO   .JPRMPT                                         RTS02A1\n.DUMPRMT DC    AL4(0)             PROMPT PARM LIST             RTS02A1\n.JPRMPT  ANOP                                                  RTS02A1\n         AIF   ('&MF' EQ 'L').GEND                             RTS02A1\nUGE&S    EQU   *                                               RTS02A1\n.LDCPPL  AIF   ('&CPIOPL' EQ '(0)').CPPL0                      RTS02A1\n         AIF   ('&CPIOPL'(1,1) EQ '(').CPPLR                   RTS02A1\n         LA    0,&CPIOPL        LOAD CPPL/IOPL ADDRESS         RTS02A1\n         AGO   .CPPL0                                          RTS02A1\n.CPPLR   LA    0,0&CPIOPL     LOAD CPPL/IOPL ADDRESS           RTS02A1\n         AIF   ('&IOPL' NE '').IOPLFF                          RTS02A1\n         AGO   .CPPLO                                          RTS02A1\n.CPPL0   AIF   ('&IOPL' NE '').IOPLFF                          RTS02A1\n         ICM   0,8,=X'00'         INDICATE CPPL PASSED         RTS02A1\n         AGO   .CPPLO                                          RTS02A1\n.IOPLFF  ICM   0,8,=X'FF'         INDICATE IOPL PASSED         RTS02A1\n.CPPLO   ANOP                                                  RTS02A1\n         L     15,=V(UKJUGET)                                  RTS02A1\n         BALR  14,15              CALL UGET ROUTINE            RTS02A1\n.GEND    SPACE 1\n         MEXIT\n.EDI     ANOP\n         AIF   (&E).ERROR2              DUP OPTION\n&E       SETB  1                        EDIT OPTION SPECFIED\n         AGO   .RET\n.ASI     ANOP\n         AIF   (&E).ERROR2              DUP OPTION\n&E       SETB  1                        EDIT OPTION SPECFIED\n         MNOTE 0,'UGET001 WARNING -- EFFECTS OF ASIS OPTION ARE DEVICE *\n               DEPENDENT'                                      RTS02A1\n&OPT     SETA  &OPT+1                   SET EDIT=ASIS\n         AGO   .RET\n.WAI     ANOP\n         AIF   (&W).ERROR2              DUP OPTION\n&W       SETB  1                        WAIT OPTION SPECIFIED\n         AGO   .RET\n.NOW     ANOP\n         AIF   (&W).ERROR2              DUP OPTION\n&W       SETB  1                        WAIT OPTION SPECIFIED\n&OPT     SETA  &OPT+X'10'               SET WAIT=NOWAIT\n         AGO   .RET\n.CLIST   ANOP                                                  RTS02A1\n         AIF   (&G).ERROR2              DUP OPTION             RTS02A1\n&G       SETB  1                  GETLINE OPTION SPECIFIED     RTS02A1\n&GOPT    SETA  X'0080'            SET CLIST INPUT              RTS02A1\n         AGO   .RET\n.TERM    ANOP                                                  RTS02A1\n         AIF   (&G).ERROR2              DUP OPTION             RTS02A1\n&G       SETB  1                  GETLINE OPTION SPECIFIED     RTS02A1\n&GOPT    SETA  X'1000'            SET TERMINAL INPUT           RTS02A1\n.RET     ANOP\n&PARM    SETC  '&WAIT'\n         AIF   ('&RET' EQ '1').CKPARM   CHECK WAIT\n&PARM    SETC  '&CLIST'\n         AIF   ('&RET' EQ '2').CKPARM   CHECK CLIST            RTS02A1\n         AGO   .CHKREG                  DONE WITH OPTIONS\n.MFL     ANOP                                                  RTS02A1\n         AIF   ('&BFF' EQ '').BFFOK                            RTS02A1\n         AIF   ('&BFF'(1,1) EQ '(').LREG                       RTS02A1\n.BFFOK   AIF   ('&SIZE' EQ '').SIZEOK                          RTS02A1\n         AIF   ('&SIZE'(1,1) EQ '(').LREG                      RTS02A1\n.SIZEOK  AIF   ('&PROMPT' EQ '').PRMPTOK                       RTS02A1\n         AIF   ('&PROMPT'(1,1) NE '(').PRMPTOK                 RTS02A1\n.LREG    IHBERMAC 69                                           RTS02A1\n         MEXIT                                                 RTS02A1\n.PRMPTOK AIF   ('&CPPL' EQ '' AND '&IOPL' EQ '').NOCPPL        RTS02A1\n         MNOTE 4,'UGET002 CPPL/IOPL OPERAND IGNORED WHEN MF=L' RTS02A1\n.NOCPPL  ANOP                                                  RTS02A1\n&PARM    SETC  '&EDIT'                                         RTS02A1\n         AGO   .CKPARM                                         RTS02A1\n.GENE    ANOP                                                  RTS02A1\n&NAME    DS    0H                                              RTS02A1\n         AIF   ('&BFF' NE '(1)').NER1                          RTS02A1\n         LR    15,1               COPY MSG ADDR TO 15          RTS02A1\n.NER1    IHBINNRA &MF(2)                                       RTS02A1\n.JEX     AIF   (&GOPT EQ 0).ENOGOPT                            RTS02A1\n         LH    14,=AL2(&GOPT)     LOAD GETLINE OPTIONS         RTS02A1\n         STH   14,0(1)            STORE GETLINE OPTIONS        RTS02A1\n.ENOGOPT AIF   ('&SIZE' EQ '').ENOSIZ                          RTS02A1\n         AIF   ('&SIZE' EQ '*').STARSIZ                        RTS02A1\n         AIF   ('&SIZE'(1,1) EQ '(').RSIZ                      RTS02A1\n         LA    14,&SIZE                                        RTS02A1\n         STH   14,2(1)            STORE MSG LENGTH IN PARM LIST RTS02A1\n         AGO   .ENOSIZ                                         RTS02A1\n.RSIZ    STH   &SIZE(1),2(1)      STORE MSG LENGTH IN PARM LIST RTS02A1\n         AGO   .ENOSIZ                                         RTS02A1\n.STARSIZ AIF   ('&BFF' EQ '*' OR '&BFF' EQ '').ENOSIZ          RTS02A1\n         AIF   ('&BFF'(1,1) EQ '(').ENOSIZ                     RTS02A1\n         LA    14,&L&BFF          GET LENGTH OF MESSAGE        RTS02A1\n         STH   14,2(1)            STORE IN PARM LIST           RTS02A1\n.ENOSIZ  AIF   (NOT (&E OR &W)).ENOPT                          RTS02A1\n         MVI   4(1),&OPT+X'80'    STORE TGET OPTIONS           RTS02A1\n.ENOPT   AIF   ('&BFF' EQ '' OR '&BFF' EQ '*').ENOBFF          RTS02A1\n         AIF   ('&BFF'(1,1) EQ '(').ERBFF                      RTS02A1\n         LA    14,&BFF                                         RTS02A1\n         STCM  14,7,5(1)     STORE BUFFER ADDR IN PARM LIST    RTS02A1\n         AGO   .ENOBFF                                         RTS02A1\n.ERBFF   AIF   ('&BFF' NE '(1)').ERN1                          RTS02A1\n         STCM  15,7,5(1)     STORE MSG ADDRESS IN PARM LIST    RTS02A1\n         AGO   .ENOBFF                                         RTS02A1\n.ERN1    STCM  &BFF(1),7,5(1)   STORE MSG ADDRESS IN PARM LIST RTS02A1\n.ENOBFF  AIF   ('&PROMPT' EQ '').LDCPPL                        RTS02A1\n         AIF   ('&PROMPT'(1,1) EQ '(').ERPRMT                  RTS02A1\n         LA    14,4+&PROMPT       ADDRESS PROMPT PARMS         RTS02A1\n         ST    14,8(1)            STORE IN GET PARMS           RTS02A1\n         AGO   .LDCPPL                                         RTS02A1\n.ERPRMT  LA    14,4&PROMPT        ADDRESS PROMPT PARM LIST     RTS02A1\n         ST    14,8(1)            STORE IN GET PARMS           RTS02A1\n.RERR    IHBERMAC 192\n         MEXIT\n.ERROR1  IHBERMAC 24\n         MEXIT\n.ERROR2  IHBERMAC 54,,,\n         MEXIT\n.ERROR3  IHBERMAC 49,,&PARM\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UHBACT": {"ttr": 11532, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         UHBACT &MF=\n.*       THIS MACRO SETS THE GLOBAL SWITCH &UHBA IF THE GENERATION OF\n.*       ACTION CODE IS REQUESTED BY THE MF.\n         GBLB  &UHBA,&UHBM1,&UHBIM\n         GBLC  &UHBML\n         AIF   (&UHBIM).MEND\n&UHBA    SETB  ('&MF(1)' NE 'L' AND '&MF(1)' NE 'M')\n         AIF   ('&MF(1)' EQ 'G' OR '&MF(1)' EQ 'L').MEND\n         AIF   (NOT &UHBM1).MEND\n&UHBM1   SETB  (0)\n         AIF   ('&UHBML' EQ '').MEND\n&UHBML   DS    0H\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UHBADDR": {"ttr": 11534, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   UHBADDR &REG,&ADDR,&LEN=4,&COM=,&MF=G\n.*       THIS MACRO IS CALLED TO LOAD A VALUE (FULLWORD OR HALFWORD)\n.*       INTO A REGISTER.\n         LCLC  &S,&T,&R\n&S       SETC  ' .      '         COMMENT SEPARATOR\n         AIF   ('&ADDR'(1,1) EQ '(').RFORM\n         AIF   (K'&ADDR LT 3).NORML\n         AIF   ('&ADDR'(2,1) NE ':').NORML\n         UHBCOLON &ADDR,&LEN,S,MF=&MF\n&T       SETC  '&ADDR'(1,1)\n         AIF   ('&T' EQ 'S').SFORM\n         AIF   ('&T' EQ '*').STFORM\n         AIF   ('&T' NE 'A').MEND\n&LABEL   UHBILDUP L,'&REG,=A(',')',&COM\n         MEXIT\n.SFORM   ANOP\n&LABEL   UHBILDUP LA,'&REG,','',&COM\n         MEXIT\n.STFORM  AIF   ('&LEN' EQ '2').STFORM2\n&LABEL   UHBILDUP L,'&REG,','',&COM\n         MEXIT\n.STFORM2 ANOP\n&LABEL   UHBILDUP LH,'&REG,','',&COM\n         MEXIT\n.NORML   ANOP\n&LABEL   LA    &REG,&ADDR&S&COM\n         MEXIT\n.RFORM   ANOP\n&R       SETC  '&ADDR'(2,K'&ADDR-2)\n         AIF   ('&R' EQ '&REG').GLABEL\n&LABEL   LR    &REG,&R&S&COM\n         MEXIT\n.GLABEL  AIF   ('&LABEL' EQ '').MEND\n&LABEL   DS    0H\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UHBBGEN": {"ttr": 11777, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&L       UHBBGEN &ALIGN=4,&COM=PARM.LIST,&MF=\n.*       THIS MACRO GENERATES THE NECESSARY PRELUDE BEFORE THE\n.*       GENERATION OF AN INLINE CONTROL BLOCK.\n         GBLA  &UHBSF\n         GBLB  &UHBG,&UHBM\n         GBLB  &UHBIM,&UHBG1\n         GBLB  &UHBSM(5)\n         GBLC  &UHBGL,&UHBOGL,&UHBML\n         GBLC  &UHBSL(5)\n         LCLA  &MM\n         LCLA  &I\n         LCLC  &S\n&S       SETC  ' .      '\n&UHBIM   SETB  (0)\n&UHBM    SETB  (0)\n&UHBSF   SETA  0\n&I       SETA  1\n.ILOOP   ANOP\n&UHBSL(&I) SETC ''\n&UHBSM(&I) SETB 0\n&I       SETA  &I+1\n         AIF   (&I LE 5).ILOOP\n         AIF   ('&MF(1)' EQ 'I').MFI\n         AIF   ('&MF(1)' EQ 'L').MFL\n         AIF   ('&MF(1)' EQ 'G').MFG\n         AIF   ('&MF(1)' EQ 'M' OR '&MF(1)' EQ 'E').MFM\n         MNOTE 12,'UHB003 INVALID MF=&MF SPECIFIED'\n&UHBIM   SETB  (1)\n         MEXIT\n.MFI     AIF   ('&ALIGN' LT '4').NOIAL\n         AIF   ('&ALIGN' NE '4').IAL8\n         CNOP  0,4                ALIGN TO FULLWORD\n         AGO   .NOIAL\n.IAL8    CNOP  4,8                FORCE DOUBLEWORD ALIGNMENT\n.NOIAL   ANOP\n&UHBML   SETC  'UHB&SYSNDX.M'\n&L       BAL   1,&UHBML&S.BRANCH.AROUND.&COM\n&MM      SETA  2\n&UHBGL   SETC  '&MF(2)'\n         AGO   .JMFG\n.MFL     AIF   ('&MF(2)' NE '').MFG\n         AIF   ('&ALIGN' EQ '1').NOLAL\n         AIF   ('&ALIGN' NE '2').LAL4\n         DS    0H                 ALIGN TO HALFWORD\n         AGO   .NOLAL\n.LAL4    AIF   ('&ALIGN' NE '4').LAL8\n         DS    0F                 ALIGN TO FULLWORD\n         AGO   .NOLAL\n.LAL8    DS    0D                 ALIGN TO DOUBLEWORD\n.NOLAL   AIF   ('&L' NE '').LOK\n         MNOTE 4,'UHB004 LABEL REQUIRED WHEN MF=L'\n.LOK     ANOP\n&UHBGL   SETC  '&L'\n&MM      SETA  3\n         AGO   .JMFG\n.MFG     ANOP\n&UHBML   SETC  '&L'\n         AIF   ('&L' NE '').GLAB\n&UHBML   SETC  'UHB&SYSNDX.M'\n.GLAB    B     &UHBML&S.BRANCH.AROUND.&COM\n         AIF   ('&ALIGN' LT '4').NOGAL\n         AIF   ('&ALIGN' NE '4').GAL8\n         CNOP  0,4                ALIGN TO FULLWORD\n         AGO   .NOGAL\n.GAL8    CNOP  0,8                ALIGN TO DOUBLEWORD\n.NOGAL   ANOP\n&UHBGL   SETC  'UHB&SYSNDX.G'\n&MM      SETA  3\n.JMFG    ANOP\n&UHBOGL  SETC  '&UHBGL'\n&UHBG    SETB  (1)\n&UHBG1   SETB  (1)\n         AGO   .JMF\n.MFM     ANOP\n&UHBG    SETB  (0)\n&UHBM    SETB  (1)\n&UHBML   SETC  '&L'\n&MM      SETA  2\n.JMF     AIF   (N'&MF LE &MM).MEND\n         MNOTE 4,'UHB005 EXCESS MF PARAMETERS IGNORED'\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UHBBMOD": {"ttr": 11780, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         UHBBMOD &COM=PARM.LIST,&MF=\n.*       THIS MACRO GENERATES ANY INTERLUDE CODE REQUIRED BETWEEN THE\n.*       GENERATED FORM OF A CONTROL BLOCK AND THE CODE TO MODIFY\n.*       IT OR A COPY THEREOF.\n         GBLB  &UHBM,&UHBIM,&UHBM1\n         GBLC  &UHBOGL,&UHBML\n         GBLC  &UHBLN\n         LCLC  &LL\n         LCLC  &S\n         AIF   (&UHBIM).MEND\n&S       SETC  ' .      '\n         AIF   ('&MF(1)' EQ 'I').MFI\n         AIF   ('&MF(1)' EQ 'M' OR '&MF(1)' EQ 'E').MFM\n         AIF   ('&MF(1)' EQ 'L' AND '&MF(2)' EQ '').MEND\n&UHBML   UHBADDR 1,&MF(2),COM=ADDRESS.REMOTE.&COM\n         MVC   0(&UHBLN,1),&UHBOGL&S.COPY.INLINE.&COM\n.MDONE   ANOP\n&UHBM1   SETB  (0)\n         MEXIT\n.MFI     ANOP\n&UHBM1   SETB  (1)\n         MEXIT\n.MFM     ANOP\n&UHBML   UHBADDR 1,&MF(2),COM=ADDRESS.REMOTE.&COM\n         AGO   .MDONE\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UHBCOLON": {"ttr": 11782, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         UHBCOLON &VAL,&LEN,&C,&MF=\n.*       UTILITY MACRO TO DIAGNOSE INCORRECT USE OF COLON NOTATION.\n         LCLA  &I\n         LCLC  &T\n&T       SETC  '&VAL'(1,1)\n&I       SETA  K'&VAL-2\n         AIF   ('&T' EQ 'A').AFORM\n         AIF   ('&T' EQ 'S').SFORM\n         AIF   ('&T' EQ '*').STFORM\n         MNOTE 8,'UHB006 COLON USAGE INVALID IN &VAL'\n         MEXIT\n.AFORM   AIF   (&LEN GT 2 OR ('&MF(1)' NE 'E' AND '&MF(1)' NE 'M' AND  *\n               '&C' NE 'G')).COOK\n.ABS     MNOTE 4,'UHB007 ILLEGAL USE OF &T: FOR ABSOLUTE QUANTITY'\n         AGO   .COOK\n.SFORM   AIF   ('&MF(1)' NE 'L' OR '&MF(2)' NE '').AFORM\n.BADL    MNOTE 8,'UHB008 COLON NOTATION ILLEGAL WITH MF=L'\n         MEXIT\n.STFORM  AIF   ('&MF(1)' EQ 'L' AND '&MF(2)' EQ '').BADL\n.COOK    UHBRKDN &VAL,3,&I\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UHBEGEN": {"ttr": 11784, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         UHBEGEN &COM=PARM.LIST,&MF=\n.*       THIS MACRO GENERATES AN EQUATE TO THE LENGTH OF A GENERATED\n.*       PARAMETER LIST, IF APPROPRIATE.\n         GBLC  &UHBLN,&UHBOGL\n         GBLB  &UHBIM\n         LCLC  &S\n&S       SETC  ' .      '\n         AIF   (&UHBIM OR '&MF(1)' EQ 'M' OR '&MF(1)' EQ 'E' OR '&MF(1)*\n               ' EQ 'I').MEND\n&UHBLN   SETC  '&MF(3)'\n         AIF   ('&UHBLN' NE '').LOK\n         AIF   ('&MF(1)' EQ 'L' AND '&MF(2)' EQ '').MEND\n&UHBLN   SETC  'UHB&SYSNDX.L'\n.LOK     ANOP\n&UHBLN   EQU   *-&UHBOGL&S.LENGTH.OF.&COM\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UHBGEN": {"ttr": 11786, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   UHBGEN &VAL,&LEN,&COM=,&RQR=,&NAME=,&SUB=,&SUBID=,&DEF=,&MF=\n.*       THIS MACRO IS CALLED WITH A VALUE, A LENGTH, AND A MACRO FORM\n.*       TO GENERATE A VALUE, OR SPACE FOR A VALUE, IN A PARAMETER LIST\n         GBLA  &UHBSF\n         GBLB  &UHBG1,&UHBIM,&UHBM\n         GBLB  &UHBSM(5)\n         GBLC  &UHBGL\n         GBLC  &UHBSL(5)\n         LCLC  &L\n         LCLC  &S,&POST\n&S       SETC  ' .      '\n         AIF   (&UHBIM OR '&MF(1)' EQ 'E' OR '&MF(1)' EQ 'M').MEND\n         AIF   (&LEN LE 2).NOPOST\n&POST    SETC  '.ADDRESS'\n.NOPOST  AIF   ('&RQR' NE 'Y').NORQR\n         UHBRQR &VAL,&NAME,MF=&MF\n.NORQR   ANOP\n&L       SETC  '&LABEL'\n         AIF   (NOT &UHBG1).L0\n&UHBG1   SETB  (0)\n         AIF   ('&L' NE '').L2\n&L       SETC  '&UHBGL'\n         AGO   .L0\n.L2      ANOP\n&UHBGL   EQU   *\n.L0      AIF   (&UHBSF EQ 0).NOSUBF\n         AIF   ('&UHBSL(&UHBSF)' EQ '').MEND\n.NOSUBF  AIF   ('&VAL' EQ '').NOVAL\n         AIF   ('&VAL' EQ '*').STARVAL\n         AIF   ('&VAL'(1,1) EQ '(').RFORM\n         AIF   (K'&VAL LT 3).NFORM\n         AIF   ('&VAL'(2,1) EQ ':').CFORM\n.NFORM   ANOP\n&L       DC    AL&LEN.(&VAL)&S&COM&POST\n         MEXIT\n.RFORM   AIF   ('&MF(1)' NE 'L' OR '&MF(2)' NE '').MFORM\n         MNOTE 8,'UHB001 REGISTER NOTATION ILLEGAL WITH MF=L'\n         AGO   .MFORM\n.CFORM   UHBCOLON &VAL,&LEN,G,MF=&MF\n         AIF   ('&VAL'(1,1) NE 'A').MFORM\n&L       UHBILDUP DC,'AL&LEN.(',')',&COM&POST\n         MEXIT\n.MFORM   AIF   (&UHBSF EQ 0).NOMSUB\n&UHBSM(&UHBSF) SETB (1)\n.NOMSUB  ANOP\n&UHBM    SETB  (1)\n&L       DC    AL&LEN.(*-*)&S.DUMMY.&COM&POST\n         MEXIT\n.STARVAL AIF   ('&SUB' EQ '').NOVAL\n&UHBSL(&SUB) SETC '&SUBID'\n         AIF   ('&SUBID' NE '').SUBIDOK\n&UHBSL(&SUB) SETC 'UHB&SYSNDX.S'\n.SUBIDOK AIF   ('&MF(1)' NE 'I' AND ('&MF(1)' NE 'L' OR '&MF(2)' NE '')*\n               ).MFORM\n&L       DC    AL&LEN.(&UHBSL(&SUB))&S&COM&POST\n         MEXIT\n.NOVAL   AIF   ('&DEF' NE '').DEF\n&L       DC    AL&LEN.(0)\n         MEXIT\n.DEF     ANOP\n&L       DC    AL&LEN.(&DEF)&S.DEFAULT.&COM&POST\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UHBGENF": {"ttr": 11788, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   UHBGENF &ON=0,&OFF=0,&COM=OPTIONS,&MF=\n         LCLB  &B(8)\n         LCLA  &I,&N,&Y\n&Y       SETA  &ON\n&N       SETA  &OFF\n&I       SETA  8\n.LOOP    ANOP\n&B(&I)   SETB  ((&Y/2)*2 NE &Y AND (&N/2)*2 EQ &N)\n&Y       SETA  &Y/2\n&N       SETA  &N/2\n&I       SETA  &I-1\n         AIF   (&I GT 0).LOOP\n&LABEL   UHBGENV B'&B(1)&B(2)&B(3)&B(4)&B(5)&B(6)&B(7)&B(8)',,         *\n               COM=&COM,MF=&MF\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UHBGENV": {"ttr": 11790, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   UHBGENV &VAL,&LEN,&COM=VALUE,&TYPE=,&RQR=,&NAME=,&DEF=,&MF=\n.*       THIS MACRO IS CALLED WITH A VALUE, A LENGTH, A MACRO FORM, AND\n.*       AN OPTIONAL TYPE, TO GENERATE A DATA VALUE, OR THE SPACE FOR\n.*       ONE, IN A PARAMETER LIST.\n         GBLA  &UHBSF\n         GBLB  &UHBM,&UHBG1,&UHBIM\n         GBLB  &UHBSM(5)\n         GBLC  &UHBGL\n         LCLA  &W\n         LCLC  &S,&T,&L,&P\n         AIF   (&UHBIM OR '&MF(1)' EQ 'E' OR '&MF(1)' EQ 'M').MEND\n&S       SETC  ' .      '\n         AIF   ('&RQR' NE 'Y').NORQR\n         UHBRQR &VAL,&NAME,MF=&MF\n.NORQR   ANOP\n&L       SETC  '&LABEL'\n         AIF   (NOT &UHBG1).L0\n&UHBG1   SETB  (0)\n         AIF   ('&UHBGL' EQ '').L0\n&L       SETC  '&UHBGL'\n.L0      AIF   ('&VAL' EQ '').NVAL\n         AIF   ('&VAL'(1,1) EQ '''').TLIT\n         AIF   (K'&VAL LE 2).NLIT\n         AIF   ('&TYPE' EQ '' AND '&VAL'(K'&VAL,1) EQ '''').YLIT\n.NLIT    AIF   ('&MF(1)' NE 'L' OR '&MF(2)' NE '').YVAL\n         MNOTE 8,'UHB009 NON-LITERAL DATA &VAL NOT ALLOWED WITH MF=L'\n         AGO   .NVAL\n.YVAL    AIF   (&UHBSF NE 0).MSUB\n&UHBM    SETB  (1)\n         AGO   .NVAL\n.MSUB    ANOP\n&UHBSM(&UHBSF) SETB (1)\n.NVAL    AIF   ('&DEF' NE '').DEF\n&T       SETC  '&TYPE'\n         AIF   ('&T' NE '').TYPOK\n&T       SETC  'C'\n.TYPOK   AIF   ('&T' EQ 'C' OR '&T' EQ 'X' OR '&T' EQ 'B').NALIGN\n         AIF   ('&T' EQ 'Z' OR '&T' EQ 'P').DALIGN\n&W       SETA  2\n         AIF   ('&T' EQ 'H').ALIGN\n&W       SETA  4\n         AIF   ('&T' EQ 'F' OR '&T' EQ 'E').ALIGN\n&W       SETA  8\n         AIF   ('&T' EQ 'D').ALIGN\n&W       SETA  16\n.ALIGN   ANOP\n&L       DS    ((&LEN+&W-1)/&W)&T&S.SPACE.FOR.&COM\n         AGO   .L2\n.NALIGN  ANOP\n&L       DS    &T.L&LEN&S.SPACE.FOR.&COM\n         AGO   .L2\n.DALIGN  ANOP\n&L       DS    &LEN&T&S.SPACE.FOR.&COM\n         AGO   .L2\n.TLIT    ANOP\n&T       SETC  '&TYPE'\n         AIF   ('&T' NE '').YLIT\n&T       SETC  'C'\n.YLIT    AIF   ('&LEN' EQ '').NOLEN\n         AIF   ('&L' NE '').YLAB\n&L       SETC  'UHB&SYSNDX.V'\n.YLAB    ANOP\n&L       DC    &T&VAL&S&COM\n         AIF   (T'&LEN EQ 'N').NLEN\n&LEN     EQU   *-&L&S.LENGTH.OF.&COM\n         AGO   .L2\n.NOLEN   ANOP\n&L       DC    &T&VAL&S&COM\n         AGO   .L2\n.NLEN    AIF   ('&T' EQ 'C' OR '&VAL'(1,1) EQ 'C').CPAD\n         DC    (&LEN+&L-*)X'00'   PAD TO FULL LENGTH\n         AGO   .L2\n.CPAD    DC    (&LEN+&L-*)C' '    PAD TO FULL LENGTH\n.L2      AIF   ('&LABEL' EQ '' OR '&LABEL' EQ '&L').MEND\n&LABEL   EQU   &L\n         MEXIT\n.DEF     AIF   ('&DEF'(1,1) EQ '''').QDEF\n&L       DC    &DEF&S.DEFAULT.&COM\n         MEXIT\n.QDEF    AIF   ('&TYPE' NE '').TDEF\n&L       DC    C&DEF&S.DEFAULT.&COM\n         MEXIT\n.TDEF    ANOP\n&L       DC    &TYPE&DEF&S.DEFAULT.&COM\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UHBILDUP": {"ttr": 11793, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&L       UHBILDUP &OP,&BEF,&AFT,&COM\n.*       UTILITY MACRO TO BUILD INSTRUCTIONS USING A GENERALIZED\n.*       SUBSTRING CREATED BY UHBRKDN.\n         GBLC  &UHBC(8)\n         LCLC  &S,&B(5),&A\n         LCLA  &N\n&S       SETC  ' .      '\n         AIF   (K'&BEF LE 2).NB\n&B(1)    SETC  '&BEF'(2,K'&BEF-2)\n&N       SETA  2+K'&B(1)\n         AIF   (&N EQ K'&BEF).NB\n&B(2)    SETC  '&BEF'(&N,K'&BEF-&N)\n&N       SETA  &N+K'&B(2)\n         AIF   (&N EQ K'&BEF).NB\n&B(3)    SETC  '&BEF'(&N,K'&BEF-&N)\n&N       SETA  &N+K'&B(3)\n         AIF   (&N EQ K'&BEF).NB\n&B(4)    SETC  '&BEF'(&N,K'&BEF-&N)\n&N       SETA  &N+K'&B(4)\n         AIF   (&N EQ K'&BEF).NB\n&B(5)    SETC  '&BEF'(&N,K'&BEF-&N)\n.NB      AIF   (K'&AFT LE 2).NA\n&A       SETC  '&AFT'(2,K'&AFT-2)\n.NA      ANOP\n&L       &OP   &B(1)&B(2)&B(3)&B(4)&B(5)&UHBC(1)&UHBC(2)&UHBC(3)&UHBC(4*\n               )&UHBC(5)&UHBC(6)&UHBC(7)&UHBC(8)&A&S&COM\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UHBLKUP": {"ttr": 11795, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         UHBLKUP &X,&VAL=,&OUT=,&NAME=\n         GBLC  &UHBL\n         LCLA  &I\n&I       SETA  1\n.LOOP    AIF   ('&X' EQ '&VAL(&I)').OK\n&I       SETA  &I+1\n         AIF   (&I LE N'&VAL).LOOP\n&UHBL    SETC  ''\n         AIF   ('&NAME' EQ '').MEND\n         MNOTE 8,'UHB010 INVALID &NAME SPECIFIED: &X'\n         MEXIT\n.OK      AIF   ('&OUT' NE '').TR\n&UHBL    SETC  '&I'\n         MEXIT\n.TR      ANOP\n&UHBL    SETC  '&OUT(&I)'\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UHBMACS@": {"ttr": 11797, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "1\n-\n      The  UHB macros  are a  set of  macros  to make  writing other  macros\n      easier.    They were  designed to  support the  writing of  high-class\n      macros like the VSAM  macros,  which support myriads  of useful macro-\n      forms (MFs)  and  addressing modes.   XWTO is an example  of a UHBMACS\n      application,  and might not have been practical in its full generality\n      without them.\n0     The  UHB macros  will  work with  both Assembler  G  and Assembler  XF\n      (without a special LSETC requirement for Assembler G).\n0     In  the simplest  case,  to  define  a macro  which builds/modifies  a\n      control  block and  issues  a user  SVC,   all you  need  to write  is\n      something like:\n0                   MACRO\n           &LABEL   MYMACRO &OP1=,&OP2=,...&MF=I\n           &LABEL   UHBBGEN MF=&MF\n                    UHBGEN &OP1,op1-length,COM=op1-name,MF=&MF\n                    UHBGEN &OP2,op2-length,COM=op2-name,MF=&MF\n                       .\n                       .\n                       .\n                    UHBEGEN MF=&MF\n                    UHBBMOD MF=&MF\n                    UHBMOD 0(1),&OP1,op1-length,MF=&MF\n                    UHBMOD op1-length(1),&OP2,op2-length,MF=&MF\n                       .\n                       .\n                       .\n                    UHBSVC svcnumb,NAME=svc-name,MF=&MF\n                    MEND\n0     (It can be  more complicated than that upon occasion,   but many times\n      you will find that the above is about all you need to do.)\n0     Now,  to thrill you even more,  let me mention the notations supported\n      by the above:\n0          MF=I - Generates an inline parm list  and issues an SVC (or tells\n                you  via a  global switch  to  take your  own action,   like\n                calling a routine)\n0          MF=L - Generates an inline parm list.\n           MF=(L,,length)  - Generates  an inline parm list  and equates the\n                \"length\" symbol to the list of the parm list.\n           MF=(L,area,length)   - Generates  a  parm  list at  the  location\n                specified by \"area\".   If a length is present, it is equated\n                to the parm list length.\n0          MF=(G,area,length)   - Generates  a  parm  list at  the  location\n                specified by \"area\",  and issues the SVC (or sets the action\n                flag).   If a length is present,   it is equated to the parm\n                list length.\n0          MF=(M,area)  -  Modifies the  parm list  present at  the location\n                specified by \"area\".\n0          MF=(E,area)  -  Modifies the  parm list  present at  the location\n                specified by \"area\",  and issues the SVC (or sets the action\n                flag).\n0     Where  sensible,   operands  may  be  specified  using  the  following\n      notations:\n0          (xx) - indicates the data or address in register xx\n           A:xx -  indicates the  address  of location  xx,   which must  be\n                accessed via an A-type constant (i.e.,  may not be addressed\n                via a register)\n           S:xx -  indicates the  address  of location  xx,   which must  be\n                accessed via a base register (i.e., may not be addressed via\n                an address constant)\n           *:xx - indicates  the data or  address referenced by  location xx\n                via indirect addressing.\n1\n0                                                                     PAGE 2\n0     Not counting the inner macros which  you shouldn't want to issue,  the\n      UHB macros can be divided into structural macros,  data/action macros,\n      and a few utility macros.  The structural macros are:\n0          UHBBGEN - begin generation (always first)\n+       \u00ae\n0          UHBSUB -  define a  dependent subblock  (ignore subblocks  for\n+       \u00ae\n           now; I'll get to them)\n0          UHBEGEN - end generation (appears  after the UHBGEN macros for\n+       \u00ae\n           all operands)\n0          UHBBMOD - begin modification (appears after the UHBEGEN macro)\n+       \u00ae\n0          UHBACT -  decide whether  or not  action is  required (appears\n+       \u00ae\n           after the UHBMOD  operands for all operands;   not required if\n           you use UHBSVC to conditionally generate an SVC)\n0     The data/action macros are as follows:\n0          UHBGEN  -  generate  a control  block  item  (appears  between\n+       \u00ae\n           UHBBGEN and UHBEGEN).    The value is assumed  to be a 1  to 4\n           byte address\n0          UHBGENF - generate  a control block flag  byte (same placement\n+       \u00ae\n           as UHBGEN)\n0          UHBGENV  - generate  a value  of some  non-address type  (same\n+       \u00ae\n           placement as UHBGEN)\n0          UHBMOD - modify a control  block item (appears between UHBBMOD\n+       \u00ae\n           and UHBACT/UHBSVC).   The value is assumed to be a 1 to 4 byte\n           address\n0          UHBMODF - modify a control block  flag byte (same placement as\n+       \u00ae\n           UHBMOD)\n0          UHBMODV  -  modify a  value  of  some non-address  type  (same\n+       \u00ae\n           placement as UHBMOD)\n0          UHBSVC  - issue  an SVC  if the  MF shows  action is  required\n+       \u00ae\n           (appears after the UHBMOD macros for all operands)\n0     The utility macros are:\n0          UHBLKUP - look  an operand up in a list  of possible (reserved\n+       \u00ae\n           word)  values,   and return an  indication of which  value was\n           found\n0          UHBADDR - load  an address (specified in any  of the wonderful\n+       \u00ae\n           formats introduced earlier) into a register\n0     Now,  here is a macro-by-macro description of how to use them and what\n      to expect.    (I'll leave sub-blocks out  for now;  after  you've seen\n      them, you'll understand why.)\n0     The syntax of UHBBGEN is:\n0          &LABEL   UHBBGEN &ALIGN=4,&COM=PARM.LIST,&MF=\n0     The ALIGN parameter is set to 4 (the default)  for fullword alignment,\n      8 for double word  alignment,  2 for halfword alignment,  or  1 for no\n      alignment at all.   The COM parameter is  used in comments to say what\n      is being generated.  The MF parameter should, of course, be the MF you\n      were passed.    The UHBBGEN macro generates  the start of  the control\n      block, and any necessary prelude code.\n0     The syntax of UHBEGEN is:\n0                   UHBEGEN &COM=PARM.LIST,&MF=\n0     The  COM and  MF  parmeters are  the same  as  for UHBBGEN.    UHBEGEN\n      generates an equate  for the length of  the control block,  if  one is\n      required.\n1\n0                                                                     PAGE 3\n0     The syntax of UHBBMOD is:\n0                   UHBBMOD &COM=PARM.LIST,&MF=\n0     The  COM and  MF  parmeters are  the same  as  for UHBBGEN.    UHBBMOD\n      generates  interlude code  if required  to  set up  for control  block\n      modification.   For macros other than  static MF=L,  after UHBBMOD has\n      been executed, R1 contains the relevant control block address.\n0     The syntax of UHBACT is:\n0                   UHBACT &MF=\n0     MF has its usual meaning here.   UHBACT generates no code; it sets the\n      global switch &UHBA to (1)  if the  MF indicates that action should be\n      taken (i.e., MF was I, G or E).\n0     The syntax of UHBGEN is:\n0                   UHBGEN &VAL,&LEN,&COM=,&RQR=,&NAME=,&DEF=0,&MF=\n0     &VAL  is the  address to  be generated  (usually taken  right from  an\n      operand).   It  may be  specified as empty  or as  '*' to  indicate an\n      omitted operand.  &LEN is the length (1-4) of the control block field.\n      &COM is the name of the field (for comments).  &RQR should be set to Y\n      for a required operand (required for MF=I and G,  that is;  the others\n      are  impossible to  check).   &NAME  should  be set,   for a  required\n      operand,  to the operand name for use  in the resulting MNOTE.   For a\n      non-required operand,   &DEF can be used  to specify a  default value.\n      And, of course, &MF is the usual.\n0     The syntax of UHBGENF is:\n0                   UHBGENF &ON=0,&OFF=0,&COM=OPTIONS,&MF=\n0     &ON and &OFF  specify the bits to be  turned on and turned  off in the\n      generated  option  byte.    They are  specified  as  integers,   e.g.,\n      ON=240,OFF=128.   (That's not as odd as it looks; it's the natural way\n      of computing bit values from the results of UHBLKUP.)  Any unmentioned\n      bits are  left off,  as  are any which  are specified in  both places.\n      (This means that B'01110000' is generated by the above.)   &COM is the\n      description of the byte for comments, and by now you know what &MF is.\n0     The syntax of UHBGENV is:\n0                   UHBGENV &VAL,&LEN,&COM=VALUE,&TYPE=,&RQR=,\n                          &NAME=,&DEF=,&MF=\n0     &VAL is the  value to go into  the control block (usually  taken right\n      from an operand).   It may be a  quoted string,  a typed string (e.g.,\n      X'1234'),  or something  else.   (\"Something else\" is  handled only by\n      UHBMODV, however.)  &LEN is the length of the field.  You can leave it\n      out if  you want  to have the  length implied by  a literal,   but you\n      usually won't.   &COM is a field description for the comments.   &TYPE\n      is the type  of field (e.g.,  E for  single precision floating-point).\n      You can leave it  out if it's implied by a  typed quoted value.   &RQR\n      and &NAME are the same as for UHBGEN.  &DEF is a default value; if you\n      don't provide one, a DS is generated (since for some types there is no\n      convenient zero-like value).\n0     The syntax of UHBMOD is:\n0                   UHBMOD &TO,&FROM,&LEN,&REG=14,&COM=OPERAND,&MF=\n0     Here,  &TO is where  to find the control block field  to modify (e.g.,\n      8(1)).   Remember, UHBMOD should only appear after UHBBMOD, which sets\n      up R1 nicely for you.   &FROM is the value to move in (generally taken\n      right from an operand),  and &LEN is the length of the field (1 to 4).\n      &REG is a register to use as  a work register if necessary.   &COM and\n      &MF you should know by now.\n0     The syntax of UHBMODF is:\n0                   UHBMODF &TO,&ON=0,&OFF=0,&COM=OPTIONS,&MF=\n0     Here, &TO is where to modify the bits, like for UHBMOD.  The remaining\n      keywords are just  like for UHBGENF.   Note that  UHBMODF generates no\n      code unless the MF is M or E; for the rest, it is assumed that UHBGENF\n      has taken care of things.   UHBMODF does not modify bits which are not\n1\n0                                                                     PAGE 4\n0     mentioned in either &ON or &OFF.\n1\n0                                                                     PAGE 5\n0     The syntax of UHBMODV is:\n0                   UHBMODV &TO,&FROM,&LEN,&COM=VALUE,&MF=\n0     &TO and &FROM are basically like  for UHBMOD.   &FROM may be specified\n      as a  quoted string or  a typed string;   in this case,   UHBMODV will\n      generate no code except for MF=M or  MF=M.   &LEN is the length of the\n      field;  it may be specified as '*' to  use a length implied by the &TO\n      field.\n0     The syntax of UHBSVC is:\n0                   UHBSVC &SVC,&NAME=,&MF=\n0     &SVC is the number of the SVC to  generate.   &NAME is the name of the\n      SVC to  put in a  comment.   The SVC  is generated  only if the  MF is\n      appropriate.\n0     The syntax of UHBLKUP is:\n0                   UHBLKUP &ARG,&VAL=(value-list),&OUT=(out-list),\n                          &NAME=name\n0     &ARG is the value  to look up.   &VAL is a  list of permissible values\n      (e.g.,  reserved  words).   &OUT is  an optional parameter  giving the\n      value which should be returned for each value in the list;  if &OUT is\n      omitted,  the value returned is the  ordinal number in the list (e.g.,\n      the value '2' is returned for the second value).  &NAME is an optional\n      name for the value to be looked up.  If &NAME is present and the value\n      is not found, a diagnostic is generated; otherwise, UHBLKUP is silent.\n      In either case it returns a blank value.   (And, if you were wondering\n      just HOW it returns a value,  well,  I'm getting to that.   The answer\n      is...)  The global SETC symbol &UHBL is used to return the findings of\n      UHBLKUP.\n0     The syntax of UHBADDR is:\n0          &LABEL   UHBADDR &REG,&ADDR,&LEN=4,&COM=\n0     UHBADDR is  used to  get an  address into  a register.    &REG is  the\n      register to load, &ADDR is the address to load, &LEN gives the address\n      length  (1-4),   and  &COM  is  a comment  to  put  on  the  generated\n      instruction.\n-     To aid more advanced applications of the UHB macros (i.e., those where\n      you have to do a little work yourself), the macros support some global\n      SET symbols,  to let you avoid generating  code where it is not needed\n      or does not belong.  Symbols of interest are:\n0          &UHBIM -- This SETB symbol is set to (1)  by UHBBGEN if the MF\n+       \u00ae\n           value  is invalid.    It  is reasonable  to  check this  after\n           UHBBGEN and MEXIT if it is set.  Even though none of the other\n           macros will produce any code in  this case,  you can save them\n           some work.\n0          &UHBG -- This SETB symbol is set  to (1)  by UHBBGEN if the MF\n+       \u00ae\n           value requires generation  (as opposed to modification)   of a\n           control block definition.   If it is off, you can avoid any of\n           your own code having to do with generation.\n0          &UHBM -- This SETB symbol is set to (1) after UHBBMOD has been\n+       \u00ae\n           called if  either the MF  value or previous  generation macros\n           have detected a necessity for control block modification.   If\n           it is off, you can skip modification and go directly to action\n           code.\n0          &UHBA -- This SETB  symbol is set to (1)  by  UHBACT if the MF\n+       \u00ae\n           value requires the generation of action code.\n0          &UHBGL -- This  SETC symbol is set  by UHBBGEN to the  name of\n+       \u00ae\n           any generated control block.  If MF=I, this is not the same as\n           the label on the UHBBGEN macro call.\n0          &UHBL -- This  SETC symbol is used to  return information from\n+       \u00ae\n           the UHBLKUP macro.\n1\n0                                                                     PAGE 6\n0     Now,  I suppose,  I'd better write about sub-blocks.   Sub-blocks were\n      invented for  cases where  one control block  contains the  address of\n      another,  which you'd  like to generate separately,  or  at least only\n      when required.   This  implementation of the sub-block  concept is not\n      altogether successful, but it was adequate for our original needs,  so\n      maybe it will  be for yours too.   To  give you an idea  what it's all\n      about,  I'll  expand the  original simple example  above to  contain a\n      single, unconditional sub-block.\n0                   MACRO\n           &LABEL   MYMACRO &OP1=,&OP2=,...&MF=I\n           &LABEL   UHBBGEN MF=&MF\n                    UHBGEN &OP1,op1-length,COM=op1-name,MF=&MF\n                    UHBGEN &OP2,op2-length,COM=op2-name,MF=&MF\n                    UHBGEN *,subptr-length,SUB=1,MF=&MF\n                       .\n                       .\n                       .\n                    UHBSUB 1,MF=&MF\n                    UHBGEN &SUBOP1,subop1-length,COM=subop1-name,MF=&MF\n                    UHBGEN &SUBOP2,subop2-length,COM=subop2-name,MF=&MF\n                       .\n                       .\n                       .\n                    UHBEGEN MF=&MF\n                    UHBBMOD MF=&MF\n                    UHBMOD 0(1),&OP1,op1-length,MF=&MF\n                    UHBMOD op1-length(1),&OP2,op2-length,MF=&MF\n                    UHBMOD later(1),*,subptr-length,SUB=1,REG=14,MF=&MF\n                    UHBMOD 0(14),&SUBOP1,subop1-length,REG=0,MF=&MF\n                       .\n                       .\n                       .\n                    UHBSVC svcnumb,NAME=svc-name,MF=&MF\n                    MEND\n0     The changes that were made above are as follows:\n0          A UHBGEN macro was inserted for  the pointer to the sub-block.\n+       \u00ae\n           Its address is  specified as *;  additionally,  it  is given a\n           sub-block number  (1 to 5).    If you  want,  you can  use the\n           parameter &SUBID to assign a name to the label put on the sub-\n           block when it is finally generated.  SUB and SUBID are ignored\n           if the first postional parameter is not \"*\".\n0          A UHBSUB macro is placed after the last mainline UHBGEN macro,\n+       \u00ae\n           to indicate the start of a sub-block (giving the number of the\n           sub-block,  of course).   If that sub-block is not wanted this\n           time  (i.e.,  SUB=n  never  appeared on  any  UHBGEN *  macro,\n           nothing is generated).\n0          UHBGEN macros appear for the items in the sub-block.   If that\n+       \u00ae\n           sub-block was not defined this time, nothing is generated.\n0          A UHBMOD  macro is  inserted at an  appropriate point  for the\n+       \u00ae\n           sub-block  pointer,   specifiying   SUB=sub-block-number,   an\n           address of \"*\",   and,  most important,  a register  to use to\n           address the sub-block.   UHBMOD will  expand into code to load\n           the register with the sub-block pointer, either from the block\n           generated earlier by  UHBSUB,  or from the  destination block,\n           for MF=M or MF=E.   Again, if the address is not \"*\",  the SUB\n           specification is ignored.\n0          UHBMOD macros are added to modify sub-block fields.   Here, if\n+       \u00ae\n           you have conditional sub-blocks,  you must be careful.   These\n           UHBMOD macros are  unconditional,  so you will  have to branch\n           around  them   if  they  might  contain   non-null,   non-star\n           specifications,  but the sub-block is not present.   Note that\n           these macros use  the REG from the  UHBMOD macro for  the sub-\n           block pointer to address the area  to be modified.   They also\n           specify REG  themselves to  keep the  sub-block register  from\n           being reused.\n1\n0                                                                     PAGE 7\n0     One final warning:  If you have a complicated application, let the UHB\n      macros generate everything for you,  even if it's just as easy to emit\n      a plain old  \"DC\".   There are certain cases where  the generated code\n      won't work  right if  you go  generating your  own instructions,   for\n      instance,  if you gen something before the point where they decides to\n      emit a label.   It's not that much more trouble to code a UHBGENV, and\n      you can  save yourself  (and the end  users of your  macro)  a  lot of\n      grief.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UHBMOD": {"ttr": 12037, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   UHBMOD &TO,&FROM,&LEN,&REG=14,&COM=OPERAND,&SUB=,&MF=\n.*       THIS MACRO IS CALLED WITH A SOURCE ADDRESS, A DESTINATION\n.*       ADDRESS, A LENGTH AND A MACRO FORM TO GENERATE CODE TO STORE\n.*       A VALUE INTO A PARAMETER LIST.\n         GBLB  &UHBM1,&UHBIM\n         GBLB  &UHBSM(5)\n         GBLC  &UHBML\n         GBLC  &UHBOGL,&UHBSL(5)\n         LCLC  &R,&L,&P,&S,&XCOM\n&S       SETC  ' .      '\n         AIF   (&UHBIM OR ('&MF(1)' EQ 'L' AND '&MF(2)' EQ '')).MEND\n         AIF   (&LEN LE 2).NADDR\n&XCOM    SETC  '.ADDRESS'\n.NADDR ANOP\n&L       SETC  '&LABEL'\n         AIF   ('&FROM' EQ '').EXIT\n         AIF   ('&FROM' EQ '*' AND '&SUB' EQ '').EXIT\n         AIF   (NOT &UHBM1).L0\n&UHBM1   SETB  (0)\n         AIF   ('&UHBML' EQ '').L0\n         AIF   ('&L' NE '').L2\n&L       SETC  '&UHBML'\n         AGO   .L0\n.L2      ANOP\n&UHBML   DS    0H\n.L0      AIF   ('&FROM' EQ '*').STAR\n         AIF   ('&FROM'(1,1) EQ '(').RFORM\n         AIF   (K'&FROM LT 3).NORML\n         AIF   ('&FROM'(2,1) NE ':').NORML\n         AIF   ('&FROM'(1,1) EQ '*').STFORM\n         AIF   ('&FROM'(1,1) EQ 'A' AND ('&MF(1)' NE 'M' AND '&MF(1)'  *\n               NE 'E')).EXIT\n&L       UHBADDR  &REG,&FROM,COM=LOAD.&COM&XCOM,MF=&MF\n         AGO   .NRFORM\n.NORML   AIF   ('&MF(1)' NE 'M' AND '&MF(1)' NE 'E').EXIT\n         AIF   ('&LEN' EQ '1').MVI\n&L       LA    &REG,&FROM&S.LOAD.&COM&XCOM\n.NRFORM  ANOP\n&L       SETC  ''\n&R       SETC  '&REG'\n         AGO   .STORE\n.RFORM   ANOP\n&R       SETC  '&FROM'(2,K'&FROM-2)\n.STORE   AIF   ('&LEN' EQ '1').STC\n         AIF   ('&LEN' EQ '2').STH\n         AIF   ('&LEN' EQ '3').STCM\n&L       ST    &R,&TO&S.STORE.&COM&XCOM\n         MEXIT\n.STCM    ANOP\n&L       STCM  &R,B'0111',&TO&S.STORE.&COM&XCOM\n         MEXIT\n.STH     ANOP\n&L       STH   &R,&TO&S.STORE.&COM\n         MEXIT\n.STC     ANOP\n&L       STC   &R,&TO&S.STORE.&COM\n         MEXIT\n.MVI     ANOP\n&L       MVI   &TO,&FROM&S.INSERT.&COM\n         MEXIT\n.STFORM  UHBCOLON &FROM,&LEN,S,MF=&MF\n         AIF   (&LEN NE 3).OKLEN\n&P       SETC  '1+'\n.OKLEN   ANOP\n&L       UHBMOVE &TO,&P,&LEN,COPY.&COM&XCOM\n         MEXIT\n.STAR    AIF   ('&MF(1)' EQ 'L' OR '&MF(1)' EQ 'G').SUBMV\n         AIF   ('&MF(1)' NE 'I').SUBLD\n         AIF   (NOT &UHBSM(&SUB)).EXIT\n&L       UHBADDR &REG,&UHBSL(&SUB),COM=ADDRESS.&COM\n         AGO   .MEND\n.SUBLD   AIF   ('&LEN' EQ '3').ICM\n&L       L     &REG,&TO&S.LOAD.&COM..ADDRESS\n         MEXIT\n.ICM     ANOP\n&L       ICM   &REG,B'0111',&TO&S.LOAD.&COM..ADDRESS\n         MEXIT\n.SUBMV   ANOP\n&L       UHBADDR &REG,&UHBSL(&SUB)-&UHBOGL.(1),COM=ADDRESS.&COM..COPY\n         AGO   .NRFORM\n.EXIT    AIF   ('&LABEL' NE '').GLAB\n         AIF   ('&L' EQ '').MEND\n&UHBM1   SETB  (1)\n         MEXIT\n.GLAB    ANOP\n&LABEL   DS    0H\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UHBMODF": {"ttr": 12040, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   UHBMODF &TO,&ON=0,&OFF=0,&COM=OPTIONS,&MF=\n         GBLB  &UHBIM,&UHBM1\n         GBLC  &UHBML\n         LCLC  &L,&S\n&S       SETC  ' .      '\n         AIF   (&UHBIM OR ('&MF(1)' EQ 'L' AND '&MF(2)' EQ '')).MEND\n         AIF   ('&MF(1)' NE 'E' AND '&MF(1)' NE 'M').EXIT\n         AIF   (&ON EQ 0 AND &OFF EQ 0).EXIT\n&L       SETC  '&LABEL'\n         AIF   (NOT &UHBM1).L0\n&UHBM1   SETB  (0)\n         AIF   ('&UHBML' EQ '').L0\n         AIF   ('&L' NE '').L2\n&L       SETC  '&UHBML'\n         AGO   .L0\n.L2      ANOP\n&UHBML   DS    0H\n.L0      AIF   (&ON EQ 0).OFF\n&L       OI    &TO,&ON&S.SET.&COM\n&L       SETC  ''\n.OFF     AIF   (&OFF EQ 0).MEND\n&L       NI    &TO,255-&OFF&S.RESET.&COM\n         AGO   .MEND\n.EXIT    AIF   ('&LABEL' EQ '').MEND\n&LABEL   DS    0H\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UHBMODV": {"ttr": 12042, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   UHBMODV &TO,&FROM,&LEN,&COM=VALUE,&MF=\n.*       THIS MACRO IS CALLED TO STORE A DATA VALUE INTO A PARM LIST\n         GBLB  &UHBM1,&UHBIM\n         GBLC  &UHBML\n         LCLC  &L,&S,&R,&RL,&T\n&S       SETC  ' .      '\n         AIF   (&UHBIM OR ('&MF(1)' EQ 'L' AND '&MF(2)' EQ '')).MEND\n         AIF   ('&FROM' EQ '').EXIT\n&L       SETC  '&LABEL'\n         AIF   (NOT &UHBM1).L0\n&UHBM1   SETB  (0)\n         AIF   ('&UHBML' EQ '').L0\n         AIF   ('&L' NE '').L2\n&L       SETC  '&UHBML'\n         AGO   .L0\n.L2      ANOP\n&UHBML   DS    0H\n.L0      AIF   ('&FROM'(1,1) EQ '''').LIT\n         AIF   (K'&FROM LE 2).NLIT\n         AIF   ('&FROM'(K'&FROM,1) EQ '''').LIT\n.NLIT    ANOP\n&R       SETC  '14'\n&RL      SETC  '15'\n         AIF   (T'&LEN EQ 'N').SNVLEN\n         AIF   ('&LEN' EQ '' OR '&LEN' EQ '*').SNVLEN\n         AIF   (K'&LEN LE 2).SNVLEN\n         AIF   ('&LEN'(2,1) NE ':').SNVLEN\n         UHBCOLON &LEN,2,S,MF=E\n&L       UHBILDUP LH,'15,',,LOAD.LENGTH.OF.&COM\n&L       SETC  ''\n.SNVLEN  ANOP\n         AIF   ('&FROM'(1,1) EQ '(').SRFROM\n         AIF   (K'&FROM LE 2).SNFROM\n         AIF   ('&FROM'(1,2) EQ 'S:').SSFROM\n         AIF   ('&FROM'(2,1) NE ':').SNFROM\n.SCFROM  ANOP\n&L       UHBADDR 14,&FROM,ADDRESS.&COM\n&L       SETC  ''\n         AGO   .SDOMOVE\n.SRFROM  ANOP\n&R       SETC  '&FROM'(2,K'&FROM-2)\n         AGO   .SDOMOVE\n.SSFROM  UHBCOLON &FROM,4,S,MF=E\n         AGO   .SDOMOVE\n.SNFROM  UHBRKDN &FROM\n.SDOMOVE AIF   (T'&LEN NE 'N').SNCMOVE\n         AIF   ('&LEN'(1,1) EQ '(').SVREG\n.SNCMOVE AIF   ('&LEN' EQ '' OR '&LEN' EQ '*').SCMOVE\n         AIF   (K'&LEN LE 2).SCMOVE\n         AIF   ('&LEN'(1,1) EQ '(').SVREG\n         AIF   ('&LEN'(2,1) EQ ':').SVNOR\n.SCMOVE  AIF   ('&FROM'(1,1) EQ '(').SCRMOVE\n         AIF   (K'&FROM LE 2).SCDMOVE\n         AIF   ('&FROM'(2,1) NE ':' OR '&FROM'(1,2) EQ 'S:').SCDMOVE\n.SCRMOVE UHBRKDN 0(&R)\n.SCDMOVE ANOP\n&L       UHBMOVE &TO,,&LEN,COPY.&COM\n         MEXIT\n.SVREG   ANOP\n&RL      SETC  '&LEN'(2,K'&LEN-2)\n.SVNOR   ANOP\n&L       BCT   &RL,*+10            DECREMENT LENGTH FOR EXECUTE\n&L       SETC  ''\n         AIF   ('&FROM'(1,1) EQ '(').SVRMOVE\n         AIF   (K'&FROM LE 2).SVDMOVE\n         AIF   ('&FROM'(2,1) EQ 'S:').SVDMOVE\n         AIF   ('&FROM'(2,1) NE ':').SVDMOVE\n.SVRMOVE UHBRKDN 0(&R)\n.SVDMOVE UHBMOVE &TO,,*-*,TO.BE.EXECUTED\n         EX    &RL,*-6&S.COPY.&COM\n         MEXIT\n.LIT     AIF   ('&MF(1)' NE 'E' AND '&MF(1)' NE 'M').MEND\n         AIF   ('&FROM'(1,1) NE '''').LTY\n&T       SETC  'C'\n.LTY     UHBRKDN =&T&FROM\n         AGO   .SCDMOVE\n.EXIT    AIF   ('&LABEL' EQ '').MEND\n&LABEL   DS    0H\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UHBMOVE": {"ttr": 12045, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&L       UHBMOVE &TO,&OFF,&LEN,&COM\n.*       UTILITY MACRO TO MOVE ONE FIELD TO ANOTHER.\n         LCLA  &I,&N\n         LCLC  &R,&B(3)\n         ACTR  300\n         AIF   ('&TO'(K'&TO,1) EQ ')').RFORM\n         AIF   ('&LEN' EQ '').NOLEN\n&L       UHBILDUP MVC,'&TO.(&LEN),&OFF','',&COM\n         MEXIT\n.NOLEN   ANOP\n&L       UHBILDUP MVC,'&TO,&OFF','',&COM\n         MEXIT\n.RFORM   ANOP\n&I       SETA  K'&TO-1\n.OLOOP   ANOP\n&I       SETA  &I-1\n         AIF   ('&TO'(&I,1) EQ '(').GOTREG\n         AGO   .OLOOP\n.GOTREG  ANOP\n&R       SETC  '&TO'(&I+1,K'&TO-&I-1)\n&B(1)    SETC  '&TO'(1,&I-1)\n&N       SETA  K'&B(1)+1\n         AIF   (&N EQ &I).BALL\n&B(2)    SETC  '&TO'(&N,&I-&N)\n&N       SETA  &N+K'&B(2)\n         AIF   (&N EQ &I).BALL\n&B(3)    SETC  '&TO'(&N,&I-&N)\n.BALL    ANOP\n&L       UHBILDUP MVC,'&B(1)&B(2)&B(3).(&LEN,&R),&OFF','',&COM\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UHBRKDN": {"ttr": 12047, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         UHBRKDN &OP,&LOC,&LEN\n.*       UTILITY MACRO TO TAKE LONG SUBSTRINGS IN AN ASSEMBLER-\n.*       INDEPENDENT MANNER. UP TO 64 CHARACTERS ARE SUPPORTED.\n         GBLC  &UHBC(8)\n         LCLA  &I,&J,&K\n         LCLA  &LC,&LN\n.BLOOP   ANOP\n&I       SETA  &I+1\n         AIF   ('&UHBC(&I)' EQ '').SUB1\n&UHBC(&I) SETC ''\n         AIF   (&I LT 8).BLOOP\n.SUB1    ANOP\n&LC      SETA  1\n         AIF   ('&LOC' EQ '').DEFLOC\n&LC      SETA  &LOC\n.DEFLOC  ANOP\n&LN      SETA  K'&OP+1-&LC\n         AIF   ('&LEN' EQ '').DEFLEN\n&LN      SETA  &LEN\n.DEFLEN  ANOP\n&UHBC(1) SETC  '&OP'(&LC,&LN)\n         AIF   (K'&UHBC(1) EQ &LN).MEND\n&I       SETA  &LC+K'&UHBC(1)\n&K       SETA  2\n.MLOOP   ANOP\n&J       SETA  &LN+&LC-&I\n&UHBC(&K) SETC '&OP'(&I,&J)\n         AIF   (K'&UHBC(&K) EQ &J).MEND\n&I       SETA  &I+K'&UHBC(&K)\n&K       SETA  &K+1\n         AGO   .MLOOP\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UHBRQR": {"ttr": 12049, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         UHBRQR &PARM,&NAME,&MF=\n.*       THIS MACRO IS CALLED TO GENERATE AN MNOTE IF A REQUIRED MACRO\n.*       OPERAND HAS ITS VALUE OMITTED.\n         AIF   ('&PARM' NE '' OR ('&MF(1)' NE 'I' AND '&MF(1)' NE 'G'))*\n               .MEND\n         MNOTE 12,'UHB002 REQUIRED &NAME PARAMETER IS MISSING'\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UHBSTORE": {"ttr": 12051, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   UHBSTORE &TO,&FROM,&LEN,&REG=14,&COM=OPERAND,&MF=\n.*       THIS MACRO IS CALLED WITH A SOURCE ADDRESS, A DESTINATION\n.*       ADDRESS, A LENGTH AND A MACRO FORM TO GENERATE CODE TO STORE\n.*       A VALUE INTO A PARAMETER LIST.\n         LCLC  &R,&L,&T,&P,&S,&XCOM\n&S       SETC  ' .      '\n         AIF   ('&FROM' EQ '' OR '&FROM' EQ '*').EXIT\n         AIF   (&LEN LE 2).NADDR\n&XCOM    SETC  '.ADDRESS'\n.NADDR   ANOP\n         AIF   ('&FROM'(1,1) EQ '(').RFORM\n         AIF   (K'&FROM LT 3).NORML\n         AIF   ('&FROM'(2,1) NE ':').NORML\n         UHBCOLON &FROM,&LEN,S,MF=&MF\n&T       SETC  '&FROM'(1,1)\n         AIF   ('&T' EQ 'S').SFORM\n         AIF   ('&T' EQ '*').STFORM\n         AIF   ('&T' NE 'A' OR ('&MF(1)' NE 'E' AND '&MF(1)' NE 'M')).M*\n               END\n&LABEL   UHBILDUP L,'&REG,=A(',')',LOAD.&COM&XCOM\n         AGO   .NRFORM\n.SFORM   ANOP\n&LABEL   UHBILDUP LA,'&REG,','',LOAD.&COM&XCOM\n         AGO   .NRFORM\n.NORML   AIF   ('&MF(1)' NE 'M' AND '&MF(1)' NE 'E').EXIT\n         AIF   ('&LEN' EQ '1').MVI\n&LABEL   LA    &REG,&FROM&S.LOAD.&COM&XCOM\n.NRFORM  ANOP\n&L       SETC  ''\n&R       SETC  '&REG'\n         AGO   .STORE\n.RFORM   ANOP\n&R       SETC  '&FROM(1)'\n&L       SETC  '&LABEL'\n.STORE   AIF   ('&LEN' EQ '1').STC\n         AIF   ('&LEN' EQ '2').STH\n         AIF   ('&LEN' EQ '3').STCM\n&L       ST    &R,&TO&S.STORE.&COM&XCOM\n         MEXIT\n.STCM    ANOP\n&L       STCM  &R,B'0111',&TO&S.STORE.&COM&XCOM\n         MEXIT\n.STH     ANOP\n&L       STH   &R,&TO&S.STORE.&COM\n         MEXIT\n.STC     ANOP\n&L       STC   &R,&TO&S.STORE.&COM\n         MEXIT\n.MVI     ANOP\n&LABEL   MVI   &TO,&FROM&S.INSERT.&COM\n         MEXIT\n.STFORM  ANOP\n         AIF   (&LEN NE 3).OKLEN\n&P       SETC  '1+'\n.OKLEN   ANOP\n&LABEL   UHBMOVE &TO,&P,&LEN,COPY.&COM&XCOM\n         MEXIT\n.EXIT    AIF   ('&LABEL' EQ '').MEND\n&LABEL   DS    0H\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UHBSUB": {"ttr": 12053, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         UHBSUB &SUB,&MF=\n.*       THIS MACRO DEFINES A SUBPARAMETER-LIST, TO BE ADDRESSED BY A\n.*       MAIN PARAMETER LIST.\n         GBLC  &UHBSL(5)\n         GBLC  &UHBGL\n         GBLB  &UHBIM,&UHBG1\n         GBLA  &UHBSF\n         AIF   (&UHBIM).MEND\n&UHBG1   SETB  (1)\n&UHBGL   SETC  '&UHBSL(&SUB)'\n&UHBSF   SETA  &SUB\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UHBSVC": {"ttr": 12290, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   UHBSVC &SVC,&NAME=,&MF=\n.*       THIS MACRO GENERATES AN SVC INSTRUCTION IF THE MF PARAMETER\n.*       INDICATES THAT ACTION IS REQUIRED.\n         GBLB  &UHBM1,&UHBIM\n         GBLC  &UHBML\n         LCLC  &L,&S\n&S       SETC  ' .      '\n&L       SETC  '&LABEL'\n         AIF   (&UHBIM).MEND\n         AIF   ('&MF(1)' EQ 'L').MEND\n         AIF   (NOT &UHBM1).L0\n&UHBM1   SETB  (0)\n         AIF   ('&UHBML' EQ '').L0\n         AIF   ('&L' NE '').L2\n&L       SETC  '&UHBML'\n         AGO   .L0\n.L2      ANOP\n&UHBML   DS    0H\n.L0      AIF   ('&MF(1)' NE 'M').NOM\n         AIF   ('&L' EQ '').MEND\n&L       DS    0H\n         MEXIT\n.NOM     ANOP\n&L       SVC   &SVC&S.ISSUE.&NAME..SVC\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UKJUGET": {"ttr": 12292, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         TITLE 'UKJUGET -- EASY-TO-USE PUTGET INTERFACE ROUTINE'\nUKJUGET  SAVEX LV=WKLEN,PARMR=R2\n*\n*        THIS ROUTINE IS A SIMPLE-TO-USE PUTGET INTERFACE, INVOKED\n*        BY THE UGET MACRO.  ON ENTRY, R0 ADDRESSES A CPPL OR IOPL\n*        (IF NEGATIVE) AND R1 ADDRESSES THE FOLLOWING PARM LIST:\n*        +0    GETLINE CONTROL BITS\n*        +1    PUTGET CONTROL BITS\n*        +2    INPUT MESSAGE LENGTH\n*        +4    TGET OPTION BITS\n*        +5    INPUT BUFFER ADDRESS\n*        +8    ADDR OF OUTPUT PARAMETERS (OR 0 IF INPUT ONLY)\n*\n*        THE OUTPUT PARM LIST IS MAPPED AS FOLLOWS:\n*        +0    0\n*        +1    PUTLINE CONTROL BITS\n*        +2    MESSAGE LENGTH\n*        +4    TPUT OPTION BITS\n*        +5    MESSAGE ADDRESS\n*        +8    SECOND-LEVEL MESSAGE LENGTH (IF PRESENT)\n*        +12   SECOND-LEVEL MESSAGE ADDR (IF PRESENT)\n*\n         USING DSA,R13\n         L     R3,4(,R13)\n         L     R3,20(,R3)         GET CPPL FROM REG 0 SAVE SLOT\n         LTR   R3,R3              IS IT AN IOPL INSTEAD?\n         BP    BLDIOPL            NO, BUILD ONE\n         MVC   IOPL(12),0(R3)     YES, COPY OVER ADDRESSES\n         B     IOPLBLT\nBLDIOPL  MVC   IOPL(4),4(R3)      PUT UPT ADDR\n         MVC   IOPL+4(4),12(R3)   AND ECT ADDR INTO IOPL\n         XC    DUMECB,DUMECB      CLEAR DUMMY ATTN ECB\n         LA    R4,DUMECB\n         ST    R4,IOPL+8          STORE ITS ADDR IN IOPL\nIOPLBLT  L     R9,8(R2)           FIND OUTPUT PARM LIST\n         XC    PGPB(16),PGPB\n         LTR   R9,R9              OUTPUT MSG GIVEN?\n         BZ    INPTONLY           YES, HANDLE SPECIAL CASE\n         MVC   PGPB(1),1(R9)      COPY PUTLINE CONTROL FLAGS\n         MVC   PGPB+1(1),1(R2)    COPY 2ND FLAG BYTE\n         TM    1(R2),X'80'        IS THIS A MODE MSG?\n         BNZ   MODEMSG            YES.\n         OI    PGPB,X'01'         NO, SET PROMPT BIT\nMODEMSG  MVC   PGPB+2(1),4(R9)    COPY TPUT OPTIONS\n         LH    R4,2(,R9)          GET MESSAGE LENGTH\n         L     R6,4(,R9)          LOCATE MESSAGE TEXT\n         LA    R5,BUFPRE+4        BUFFER FOR OUTPUT MESSAGE\n         BCTR  R4,0\n         EX    R4,MOVETEXT        COPY OVER TEXT\n         LA    R4,5(,R4)          GET LENGTH + 4\n         SLL   R4,16              ADD A ZERO OFFSET\n         ST    R4,BUFPRE          STORE FOR PUTGET\nINFOMSG  MVC   SINGOLD,=A(1)      INDICATE 1 SEGMENT MSG\n         TM    PGPB,X'04'         IS THIS MULTI-LEVEL?\n         BNZ   TWOMSGS            YES.\n         LA    R7,BUFPRE\n         ST    R7,SINGOLD+4       STORE MSG PTR IN OLD\n         LA    R7,SINGOLD\n         ST    R7,PGPB+4          NO, SET UP FOR 1 LEVEL\n         B     GETIT\n         SPACE\nTWOMSGS  LH    R4,10(,R9)         FIND LENGTH OF HELP\n         L     R6,12(,R9)         FIND HELP MSG\n         LA    R5,BUFPRE2+4\n         BCTR  R4,0\n         EX    R4,MOVETEXT        MOVE HELP INTO BUFFER\n         LA    R4,5(,R4)          GET L'HELP+4\n         SLL   R4,16\n         ST    R4,BUFPRE2         SAVE FOR PUTLINE\n         LA    R7,DUBLOLD\n         ST    R7,PGPB+4\n         LA    R7,OLD2\n         ST    R7,DUBLOLD         LINK THE OLD'S TOGETHER\n         XC    OLD2(8),OLD2\n         MVI   OLD2+7,1           MAKE HELP MSG Q SEGMENT ALSO\n         B     GETIT\n         SPACE\nINPTONLY MVI   PGPB+1,X'80'       INDICATE MODE MSG\n         MVI   PGPB,X'10'\n         SPACE\nGETIT    MVC   PGPB+8(1),0(R2)    MOVE IN GETLINE FLAGS\n         MVC   PGPB+10(1),4(R2)   AND TGET FLAGS\n         SPACE\nPUTIT    PUTGET PARM=PGPB,MF=(E,IOPL)  SEND THE MSG\n         CH    R15,=H'12'         NOPAUSE RETURN CODE?\n         BE    NOPAUSE            YES.\n         BH    RETURN             NO, SOMETHING WORSE\n         CH    R15,=H'8'          NO, WAS IT ATTN?\n         BE    RETURN             YES, PASS IT BACK\n         LH    R5,2(,R2)          NO, GET REQUESTED LENGTH\n         L     R4,4(,R2)          AND BUFFER ADDRESS\n         L     R6,PGPB+12         FIND RETURNED TEXT\n         LH    R7,0(,R6)          GET LENGTH RETURNED\n         SH    R7,=H'4'           ADJUST\n         LA    R6,4(,R6)\n         TM    4(R2),X'01'        TGET ASIS?\n         BZ    TGETEDIT           NO.\n         CR    R5,R7              YES, MSG LONGER THAN BUFFER?\n         BNH   TGETEDIT           YES, THAT'S OK\n         LR    R5,R7              NO, JUST COPY OVER ACTUAL MSG\nTGETEDIT ICM   R7,8,=X'40'        PAD WITH BLANKS\n         MVCL  R4,R6              COPY TEXT TO USER AREA\n         LR    R8,R15             SAVE PUTGET RETURN CODE\n         L     R1,PGPB+12         FREEMAIN THE MSG\n         LH    R0,0(,R1)\n         ICM   R0,8,=X'01'        FROM SUBPOOL 1\n         FREEMAIN R,A=(1),LV=(0)\n         LR    R15,R8             RESTORE THE RETURN CODE\n         B     RETURN\n         SPACE\nNOPAUSE  TM    0(R2),X'10'        WAS THIS A PROMPT?\n         BNZ   RETURN             YES, PASS 12 BACK TO CALLER\n         L     R8,IOPL+4          NO, FIND THE ECT ADDR\n         OI    8(R8),X'80'        SAY 2ND-LEVEL MSGS TO BE THROWN OUT\n         B     PUTIT              AND TRY AGAIN\n         SPACE\nRETURN   RETURNX RC=(15)\n         SPACE\nMOVETEXT MVC   0(0,R5),0(R6)  MOVE MESSAGE TO BUFFER\n         SPACE\nDSA      DSECT ,                  SAVE & WORK AREA\n         DS    18A\nDUBLOLD  DC    A(OLD2-DSA)        FIRST OLD FOR MULTI-LEVEL\nSINGOLD  DC    A(1)               OLD FOR SINGLE-LEVEL\n         DC    A(BUFPRE-DSA)\nBUFPRE   DC    A(0)\n         DS    CL256              MESSAGE WILL BE INSERTED HERE\n         SPACE\nOLD2     DC    A(0)               OLD FOR LEVEL 2\n         DC    A(1)\n         DC    A(BUFPRE2-DSA)\nBUFPRE2  DC    A(0)\n         DS    CL256              HELP WILL BE INSERTED HERE\n         SPACE\nIOPL     DC    2A(0)\n         DC    A(DUMECB-DSA)      DUMMY ATTN ECB ADDR\n         DC    A(PGPB-DSA)\nPGPB     DC    4A(0)              PUTGET PARM BLOCK\nDUMECB   DC    A(0)               DUMMY ATTN ECB\n         SPACE\nWKLEN    EQU   *-DSA              LENGTH OF WORK AREA\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UKJUPUT": {"ttr": 12296, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         TITLE 'UKJUPUT -- EASY-TO-USE PUTLINE INTERFACE ROUTINE'\nUKJUPUT  SAVEX LV=WKLEN,PARMR=R2\n*\n*        THIS ROUTINE IS A SIMPLE TO USE PUTLINE INTERFACE, INVOKED\n*        BY THE UPUT MACRO.  ON ENTRY, R0 ADDRESSES A CPPL OR IOPL\n*        (IF NEGATIVE) AND R1 ADDRESSES THE FOLLOWING PARM LIST:\n*        +0    0\n*        +1    PUTLINE CONTROL BITS\n*        +2    MESSAGE LENGTH\n*        +4    TPUT OPTION BITS\n*        +5    MESSAGE ADDRESS\n*        +8    SECOND-LEVEL MESSAGE LENGTH (IF PRESENT)\n*        +12   SECOND-LEVEL MESSAGE ADDR (IF PRESENT)\n*\n         USING DSA,R13\n         L     R3,4(,R13)\n         L     R3,20(,R3)         GET CPPL/IOPL FROM REG 0 SAVE SLOT\n         LTR   R3,R3              IS IT AN IOPL ADDR?\n         BP    BLDIOPL            NO, BUILD FROM CPPL\n         MVC   IOPL(12),0(R3)     YES, COPY TO OURS\n         B     IOPLBLT\nBLDIOPL  MVC   IOPL(4),4(R3)      PUT UPT ADDR\n         MVC   IOPL+4(4),12(R3)   AND ECT ADDR INTO IOPL\n         XC    DUMECB,DUMECB      CLEAR DUMMY ECB\n         LA    R4,DUMECB\n         ST    R4,IOPL+8          AND STORE IN IOPL\nIOPLBLT  XC    PTPB(4),PTPB\n         MVC   PTPB(1),1(R2)      COPY PUTLINE CONTROL FLAGS\n         MVC   PTPB+2(1),4(R2)    COPY TPUT OPTIONS\n         LH    R4,2(,R2)          GET MESSAGE LENGTH\n         L     R6,4(,R2)          LOCATE MESSAGE TEXT\n         LA    R5,BUFPRE+4        BUFFER FOR OUTPUT MESSAGE\n         BCTR  R4,0\n         EX    R4,MOVETEXT        COPY OVER TEXT\n         LA    R4,5(,R4)          GET LENGTH + 4\n         SLL   R4,16              ADD A ZERO OFFSET\n         ST    R4,BUFPRE          STORE FOR PUTLINE\n         TM    PTPB,X'20'         IS THIS PUTLINE DATA?\n         BZ    INFOMSG            NO, HANDLE INFORMATIONAL MSG\n         LA    R7,BUFPRE\n         ST    R7,PTPB+4          STORE OUTPUT BUFFER ADDR\nPUTIT    PUTLINE PARM=PTPB,MF=(E,IOPL) SEND THE MSG\n         RETURNX RC=(15)\n         SPACE\nINFOMSG  MVC   SINGOLD,=A(1)      INDICATE 1 SEGMENT MSG\n         TM    PTPB,X'04'         IS THIS MULTI-LEVEL?\n         BNZ   TWOMSGS            YES.\n         LA    R7,BUFPRE\n         ST    R7,SINGOLD+4       STORE MSG PTR IN OLD\n         LA    R7,SINGOLD\n         ST    R7,PTPB+4          NO, SET UP FOR 1 LEVEL\n         B     PUTIT\n         SPACE\nTWOMSGS  LH    R4,10(,R2)         FIND LENGTH OF HELP\n         L     R6,12(,R2)         FIND HELP MSG\n         LA    R5,BUFPRE2+4\n         BCTR  R4,0\n         EX    R4,MOVETEXT        MOVE HELP INTO BUFFER\n         LA    R4,5(,R4)          GET L'HELP+4\n         SLL   R4,16\n         ST    R4,BUFPRE2         SAVE FOR PUTLINE\n         LA    R7,DUBLOLD\n         ST    R7,PTPB+4\n         LA    R7,OLD2\n         ST    R7,DUBLOLD         LINK THE OLD'S TOGETHER\n         XC    OLD2(8),OLD2\n         MVI   OLD2+7,1           MAKE HELP MSG 1 SEGMENT ALSO\n         B     PUTIT              GO SEND MESSAGE\n         SPACE\nMOVETEXT MVC   0(0,R5),0(R6)  MOVE MESSAGE TO BUFFER\n         SPACE\nDSA      DSECT ,                  SAVE & WORK AREA\n         DS    18A\nDUBLOLD  DC    A(OLD2-DSA)        FIRST OLD FOR MULTI-LEVEL\nSINGOLD  DC    A(1)               OLD FOR SINGLE-LEVEL\n         DC    A(BUFPRE-DSA)\nBUFPRE   DC    A(0)\n         DS    CL256              MESSAGE WILL BE INSERTED HERE\n         SPACE\nOLD2     DC    A(0)               OLD FOR LEVEL 2\n         DC    A(1)\n         DC    A(BUFPRE2-DSA)\nBUFPRE2  DC    A(0)\n         DS    CL256              HELP WILL BE INSERTED HERE\n         SPACE\nIOPL     DC    2A(0)\n         DC    A(DUMECB-DSA)      DUMMY ATTN ECB ADDR\n         DC    A(PTPB-DSA)\nPTPB     DC    2A(0)              PUTLINE PARM BLOCK\nDUMECB   DC    A(0)               DUMMY ATTN ECB\n         SPACE\nWKLEN    EQU   *-DSA              LENGTH OF WORK AREA\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ULT03@": {"ttr": 12299, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "1\n-\n0                  INSTITUTE FOR COMPUTER SERVICES AND APPLICATIONS\n0                                  RICE UNIVERSITY\n0                                  14 October 1980\n0                                Document No. UTL003\n0                         Sequential Copy Utility (SEQCOPY)\n-\n        SEQCOPY is a utility program designed to quickly copy one sequential\n        data set (or PDS member) to another.  This program offers the\n        following advantages over IEBGENER, the IBM utility designed to\n        perform the same function:\n0         .  SEQCOPY uses 40 to 60 % less CPU time than IEBGENER.\n0         .  SEQCOPY can be used to change the record format or record length\n             of a data set.  (Records are truncated or padded with blanks as\n             necessary.)\n0         .  SEQCOPY prints the number of records copied so that correct\n             operation can be verified easily.\n0         .  SEQCOPY allows recovery from input errors by use of the EROPT\n             suboperand of the DCB operand.\n0         .  SEQCOPY accepts concatenated data sets on different device types\n             (such as cards and disk) as input.\n0       The following features of IEBGENER are not supported by SEQCOPY:\n+                                              ___\n0         .  Partitioned output, input editing, and other functions requested\n             by IEBGENER control statements.\n0         .  Copying keyed data sets.\n0         .  Copying LRECL=X data sets.\n0       Note that neither IEBGENER nor SEQCOPY may be used to copy load\n        modules.\n0       SEQCOPY was developed at Baylor College of Medicine and is supported\n        as class C1 software (i.e., consulting is available but no maintenance\n        is provided).  See ICSA Document UTL013.002 for further information on\n        IEBGENER.\n-       USAGE\n0       The cataloged procedure named SEQCOPY may be used to run the\n        sequential copy utility.  A listing of this procedure is available for\n        reference in the User Clinic.  The Job Control Language (JCL)\n        available at ICSA is described in ICSA Document GEN001.  The JCL below\n        shows all the DD cards that the user might need to include when using\n        SEQCOPY.  When these cards are included, they must be in the same\n        order as shown.\n0         cc 1          12\n             /*PASSWORD password                                  required\n             //jobname  JOB   (standard JOB card format)          required\n             /*JOBPARM                                            required\n             /*SETUP    unit,SER=volserno,SLOT=slotno,status\n             //stepname EXEC  SEQCOPY                             required\n             //SYSUT1   DD                                        required\n             //SYSUT2   DD                                        required\n             //\n0       A SETUP card is required for each tape or off-line disk volume used.\n                  See ICSA Document GEN001 for the format of this card.\n0       The SYSUT1 DD card must be provided to define the input file.  The DCB\n                  suboperands RECFM, LRECL and BLKSIZE must be provided on the\n                  DD statement for an input data set on an unlabeled tape.\n0       The SYSUT2 DD card must be provided to define the output file.  If DCB\n                  suboperands are not available from the label of an existing\n                  data set, and are not provided on the DD card, they will be\n1\n        UTL003                                                          Page 2\n-\n                  copied from the input file parameters.\n-       EXAMPLES\n0       Example 1:  Copy a disk data set to the second file of a labeled tape.\n0         cc 1          12\n             /*PASSWORD 888888\n             //BACKUP   JOB   (USERX,275HAPPY)\n             /*JOBPARM  BIN=8\n             /*SETUP    TAPE9,SER=BKTAPE,SLOT=U08888,NP\n             //         EXEC  SEQCOPY\n             //SYSUT1   DD    DSN=USERX.VALUABLE.DATA,DISP=SHR\n             //SYSUT2   DD    UNIT=TAPE9,LABEL=(2,SL),DISP=NEW,\n             //         VOL=SER=BKTAPE,DSN=SAVE.VALUABLE.DATA\n             //\n-       Example 2:  Print a file from an unlabeled tape, skipping any blocks\n             containing I/O errors.\n0         cc 1          12\n             /*PASSWORD 505050\n             //PRINTAPE JOB   (ANYONE,999ANY)\n             /*JOBPARM  BIN=5,LINES=10\n             /*SETUP    TAPE9,SER=TAPE14,SLOT=ONEDAY,P\n             //         EXEC  SEQCOPY\n             //SYSUT1   DD    VOL=SER=TAPE14,UNIT=TAPE9,LABEL=(1,NL),\n             //         DCB=(RECFM=FB,LRECL=120,BLKSIZE=6000,EROPT=SKP),\n             //         DISP=OLD\n             //SYSUT2   DD    SYSOUT=A\n             //\n-       Example 3:  Create a disk data set with VB record format; use a disk\n             data set and cards as input.\n0         cc 1          12\n             /*PASSWORD 790000\n             //SEVERAL  JOB   (EASY,275EASY)\n             /*JOBPARM  BIN=7\n             //CONCAT   EXEC  SEQCOPY\n             //SYSUT1   DD    DSN=EASY.PROG1.PLI,DISP=SHR\n             //         DD    *\n0                 card deck\n0            //SYSUT2   DD    DSN=EASY.PROG1VB.PLI,DISP=(NEW,CATLG),\n             //         UNIT=SYSDA,SPACE=(6080,(12,12),RLSE),\n             //         DCB=(RECFM=VB,LRECL=84,BLKSIZE=6080)\n             //\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ULT07@": {"ttr": 12302, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "1\n-\n0                  INSTITUTE FOR COMPUTER SERVICES AND APPLICATIONS\n0                                  RICE UNIVERSITY\n0                                    2 July 1979\n0                                Document No. UTL007\n0                                    Disk Utility\n-\n        The ICSA disk utility allows users to catalog, uncatalog, delete and\n        rename disk data sets through the batch stream.  It is useful in\n        cataloging data sets loaded to disk from tape via IEHMOVE and deleting\n        multiple copies of a data set.\n-\n        USAGE\n0       The cataloged procedure named DISKUTIL is used to execute the disk\n        utility.  A listing of this procedure is available for reference in\n        the User Clinic.  The Job Control Language (JCL) at ICSA is described\n        in ICSA Document GEN001.  The basic JCL for using the DISKUTIL\n        procedure is outlined below.\n0         cc 1          12\n             /*PASSWORD password\n             //jobname  JOB  (standard JOB card format)\n             /*JOBPARM  BIN=bin\n             /*SETUP    UNIT=unit,SER=volser,SLOT=slot,SHARE\n             //stepname EXEC DISKUTIL\n             //SYSIN    DD\n             //\n0       A SETUP card is required for each private disk pack used in any job.\n                  See ICSA Document GEN001 for a complete description of this\n                  card.\n0       The EXEC card may include symbolic parameters.  Note that when the\n                  value of a symbolic parameter contains characters other than\n                  the alphabetic (A to Z), the numeric (0 to 9), and the\n                  national ($, #, @) characters, the value must be enclosed in\n                  single quotes.\n0                 U=unit - indicates the type of disk drive to be used for a\n                       private volume specified with the V parameter.  The\n                       value coded should be a valid value for the UNIT\n                       operand on a DD statement and be identical to the UNIT=\n                       operand on the SETUP card.  The default value is\n                       U=SYSDA.\n0                 V=volser - indicates the volume serial number of a private\n                       volume to be used by the disk utility.  The value coded\n                       must be identical to the SER= operand on the SETUP\n                       card.\n0       The SYSIN DD card describes the file that contains the disk utility\n                  control cards.  It may be a DD * followed by the control\n                  cards or it can reference a card image data set on disk or\n                  tape.\n-\n        COMMAND SYNTAX\n0       Commands are free format delimited by spaces.  Commands may be placed\n        anywhere within columns 1 thru 72.  Columns 73 thru 80 are ignored and\n        may be used for sequence numbers if desired.  Only the first three\n        characters of command names are significant (e.g., CATALOG may be\n        spelled CAT, CATLG, or CATZ).  Continuation cards are specified by\n        placing a hyphen or minus sign surrounded by blanks in the command.\n        All characters following the hyphen are taken as comments.  The first\n        character on the next card will logically follow the character\n        preceding the \"blank,hyphen,blank\" characters.\n1\n        UTL007                                                          Page 2\n-\n        Examples:\n             CATALOG  USERID.A.B.C.D.E.LOAD  -  COMMENTS\n                   ON STOREA\n               CAT  USERID.X.Y.Z.LOAD\n-\n        EXTENDED DATA SET NAME SYNTAX\n0       All data set names are kept in a two element queue.  A single asterisk\n        (*) as a data set name specifies that the previous data set name is to\n        be used.  Two asterisks (**) refer to the data set name specified\n        before the data set referred to by *.  The use of the asterisk\n        notation does not disturb the queue, (i.e. the * form may be used\n        multiple times to refer to the same data set, so long as no other data\n        set name is used between *-form references).\n0       Examples:\n             USER1.LAB1.PLI\n             USER1.LAB2.OBJ\n             *                (refers to USER1.LAB2.OBJ)\n             **               (refers to USER1.LAB2.PLI)\n             *                (refers to USER1.LAB2.OBJ)\n0       In some cases a series of similar data set names may be used (i.e.,\n        data sets that begin with the same userid or end with the same data\n        set type).  A facility is provided to allow the automatic appending of\n        qualifiers to the beginning (prequalification) or to the end\n        (postqualification) of data set names.  The qualifiers to be so\n        appended are established with the QUALIFY command.  See the QUALIFY\n        command below for additional information.\n-\n        VOLUME LISTS\n0       A volume list is a list of volume entries enclosed in parentheses and\n        separated by spaces or commas.  If only one volume entry is present,\n        the parentheses are optional.\n0       A volume entry is either the word PUBLIC or a volume serial number\n        optionally followed by its unit type.  The word PUBLIC represents the\n        standard online public volumes.  A volume serial number is from 1 to 6\n        alphabetic or numeric characters.  A unit type is specified by a slash\n        (/) followed by a code representing the type of disk; see the table\n        below for supported unit types.  If the unit type is not specified,\n        but a volume with the given volume serial number is currently mounted\n        on a direct-access device, the unit type of that device is assumed; if\n        no volume with the given serial number is currently mounted, the unit\n        type 3330 is assumed.  Note that a unit type cannot be specified with\n        the word PUBLIC, and non-direct-access unit types cannot be specified.\n0          UNIT TYPE CODE            UNIT TYPE\n                2305                 2305 Model 1 Drum\n                2305-1               2305 Model 1 Drum\n                2305-2               2305 Model 2 Drum\n                2314                 2314 Disk\n                3330                 3330 Disk\n                3330-1               3330 Model 11 Disk\n                3340                 3340 Disk\n                3350                 3350 Disk\n0       Examples:\n             PUBLIC\n             (STOREA ABCDEF STOREB 000001)\n             (X 00000 PUBLIC Y 13)\n             (XYZ/2314 PUBLIC Z3350/3350)\n             (OLDEST/2305-1 NEWEST/3350)\n1\n        UTL007                                                          Page 3\n-\n        INDEX OF COMMANDS\n0                             Command               Page\n+                             _______               ____\n0                             CATALOG. . . . . . . . . 3\n0                             DELETE . . . . . . . . . 5\n0                             NOTE . . . . . . . . . . 8\n0                             QUALIFY. . . . . . . . . 6\n0                             RENAME . . . . . . . . . 4\n0                             SEARCH . . . . . . . . . 6\n0                             STOP . . . . . . . . . . 7\n0                             UNCATALOG. . . . . . . . 4\n-       \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n        |                 |\n        | CATALOG Command |\n        |                 |\n        \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n0       The catalog command causes an entry to be added to the system catalog\n        for the given data set.\n0            \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n+                           \u00af\n             |              |                                       |\n             |  COMMAND     |   OPERANDS                            |\n             |              |                                       |\n             |\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\n+            \u00bf              \u00d7                                       ]\n             |              |                                       |\n             |  CATALOG     |   dsname                              |\n             |              |                                       |\n             |              |   \u00d0                \u00af                  |\n             |              |   | ON volume-list |                  |\n             |              |   | AS volume      |                  |\n             |              |   \u00bf                ]                  |\n             |              |                                       |\n             \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n+                           \u00bf\n0       dsname is the data set name.  See EXTENDED DATA SET NAME SYNTAX.\n0       ON volume-list specifies the volume on which the search for the data\n             set is to be made.  All volumes in the list are searched and a\n             catalog entry pointing to the corresponding volume is created if\n             and only if the data set is found on only one of the volumes\n             listed.  If the data set is found on more than one volume or is\n             not found on any volume, a message is printed and no catalog\n             entry is created.  If the volume on which the data set resides is\n             not permanently mounted, a SETUP card must be included for the\n             volume and the volume must have been specified using the U and V\n             symbolic parameters of the JCL EXEC card.\n        AS volume specifies the volume on which the data set is assumed to\n             reside.  No check is made to ensure that it actually does reside\n             there.  It is not necessary for the volume to be mounted.\n0       Defaults\n             If neither ON nor AS is specified, the current search table is\n             used as an ON volume-list.  If the current search table is ASCAT,\n             PUBLIC is used instead.  See the SEARCH command for information\n             on the search table.\n0       Examples:\n             CAT     USER1.COPY2.FORT     ON  PUBLIC\n             CATALOG USER1.JULY1.DATA     ON  (PUBLIC XYZVOL)\n             CATLG   USER1.TESTFIL.TEST\n             CAT     USER1.PRIVATE.DATA  AS MYPACK\n-       \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n        |                   |\n        | UNCATALOG Command |\n        |                   |\n        \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n1\n        UTL007                                                          Page 4\n-\n        The uncatalog command causes the entry for a given data set to be\n        removed from the catalog.\n0            \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n+                           \u00af\n             |              |                                       |\n             |  COMMAND     |   OPERANDS                            |\n             |              |                                       |\n             |\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\n+            \u00bf              \u00d7                                       ]\n             |              |                                       |\n             |  UNCATALOG   |   dsname                              |\n             |              |                                       |\n             \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n+                           \u00bf\n0       dsname is the data set name.  See EXTENDED DATA SET NAME SYNTAX.\n0       Examples:\n             UNCATALOG USER2.COPY1.PLI\n             UNC       USER2.PROG.FORT\n-       \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n        |                |\n        | RENAME Command |\n        |                |\n        \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n0       The RENAME command is used to rename a data set and optionally update\n        the catalog to reflect the new name.  If the volume on which the data\n        set resides is not permanently mounted, a SETUP card must be included\n        for the volume and the volume must have been specified using the U and\n        V symbolic parameters of the JCL EXEC card.\n0            \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n+                           \u00af\n             |              |                                       |\n             |  COMMAND     |   OPERANDS                            |\n             |              |                                       |\n             |\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\n+            \u00bf              \u00d7                                       ]\n             |              |                                       |\n             |  RENAME      |   dsname1 dsname2                     |\n             |              |                                       |\n             |              |   \u00d0                \u00af                  |\n             |              |   | ON volume-list |                  |\n             |              |   | ASCAT          |                  |\n             |              |   \u00bf                ]                  |\n             |              |   \u00d0       \u00af                           |\n             |              |   | NOCAT |                           |\n             |              |   | RECAT |                           |\n             |              |   | UNCAT |                           |\n             |              |   | CAT   |                           |\n             |              |   \u00bf       ]                           |\n             |              |                                       |\n             \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n+                           \u00bf\n0       dsname1 is the old data set name.  See EXTENDED DATA SET NAME SYNTAX.\n0       dsname2 is the new data set name.  See EXTENDED DATA SET NAME SYNTAX.\n0       ON volume-list specifies the list of volumes to be searched for the\n             old data set.  All volumes listed are searched and the rename is\n             done if and only if the data set is found on only one of the\n             volumes listed.\n        ASCAT specifies that the catalog is to be used to locate the volume on\n             which the rename is to be done.\n0       NOCAT specifies that the catalog is not to be updated.  This should be\n             used when renaming data sets that are not cataloged.\n        RECAT specifies that the catalog is to be updated to reflect the new\n             data set name.  This involves removing the old catalog entry and\n             adding the new one.\n        UNCAT specifies that the old data set name is to be removed.  Either\n             the RECAT or UNCAT operands should be specified if the old data\n             set is cataloged to prevent extraneous catalog entries.\n        CAT specifies that the new data set is to be added to the catalog.\n0       NOTE:  Only one of NOCAT, RECAT, UNCAT or CAT should be specified.\n0       Defaults\n             If neither ON volume-list nor ASCAT is specified, the value is\n             taken from the current search table (see SEARCH command).  If\n             NOCAT, RECAT, UNCAT, and CAT are all omitted, then if ASCAT is in\n1\n        UTL007                                                          Page 5\n-\n             effect, RECAT in assumed; but if ON volume-list is in effect,\n             NOCAT is assumed.\n0       Examples:\n             RENAME USER3.XYZFILE.DATA USER3.ABCFILE.DATA\n             REN    USER3.ABCFILE.PLI  USER3.TESTR.PLI\n-       \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n        |                |\n        | DELETE Command |\n        |                |\n        \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n0       The DELETE command causes a data set to be deleted and optionally its\n        catalog entry removed.  If the volume on which the data set resides in\n        not permanently mounted, a SETUP card must be included for the volume\n        and the volume must have been specified using the U and V symbolic\n        parameters of the JCL EXEC card.\n0            \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n+                           \u00af\n             |              |                                       |\n             |  COMMAND     |   OPERANDS                            |\n             |              |                                       |\n             |\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\n+            \u00bf              \u00d7                                       ]\n             |              |                                       |\n             |  DELETE      |   dsname                              |\n             |              |                                       |\n             |              |   \u00d0                \u00af                  |\n             |              |   | ON volume-list |                  |\n             |              |   | ASCAT          |                  |\n             |              |   \u00bf                ]                  |\n             |              |   \u00d0       \u00af                           |\n             |              |   | UNCAT |                           |\n             |              |   | NOCAT |                           |\n             |              |   \u00bf       ]                           |\n             |              |   \u00d0       \u00af                           |\n             |              |   | PURGE |                           |\n             |              |   \u00bf       ]                           |\n             |              |                                       |\n             \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n+                           \u00bf\n0       dsname is the data set name.  See EXTENDED DATA SET NAME SYNTAX.\n0       ON volume-list specifies the volumes from which the data set is to be\n             deleted.  The data set is deleted from all volumes in the volume-\n             list.\n        ASCAT specifies that the catalog is to be used to determine the volume\n             from which the data set is to be deleted.\n0       NOCAT specifies that the catalog is not to be altered.  The NOCAT\n             operand should only be used when a cataloged data set with the\n             same name exists on another volume.\n        UNCAT specifies that the catalog entry for this data set name is to be\n             removed.  Any catalog entry for this data set name will be\n             removed.  The data sets does not have to exist on the volume\n             pointed to by the catalog.  The volume pointed to by the catalog\n             volume does not have to be mounted.\n0       PURGE specifies that the data set is to be deleted even if the\n             expiration date stored in the data set label has not passed.\n0       Defaults\n             If neither  ON volume-list nor ASCAT is specified, the value is\n             taken from the current search table (see SEARCH command).  If\n             neither UNCAT nor NOCAT is specified then, if ASCAT is in effect,\n             UNCAT is assumed; but if ON volume-list is in effect, NOCAT is\n             assumed.\n0       Examples:\n             DELETE USER4.A.B\n             DEL    USER4.X.Y PURGE\n             DELXYZ USER4.XYZ ON(PUBLIC MYVOL) UNCAT PURGE\n-       \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n        |                |\n        | SEARCH Command |\n        |                |\n        \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n1\n        UTL007                                                          Page 6\n-\n        The search command is used to specify the search table.  This table is\n        used to fill in the default volumes to be searched for the CATALOG,\n        RENAME, and DELETE commands.\n0            \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n+                           \u00af\n             |              |                                       |\n             |  COMMAND     |   OPERANDS                            |\n             |              |                                       |\n             |\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\n+            \u00bf              \u00d7                                       ]\n             |              |                                       |\n             |              |   \u00d0                \u00af                  |\n             |  SEARCH      |   | ON volume-list |                  |\n             |              |   | ASCAT          |                  |\n+                                 _____\n             |              |   \u00bf                ]                  |\n             |              |                                       |\n             \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n+                           \u00bf\n0       ON volume-list specifies the list of volumes to be searched for data\n             sets unless overridden in the command or by a later SEARCH\n             command.\n        ASCAT specifies that the catalog will be used to determine the volumes\n             to be searched for data sets.\n0       Defaults\n             ASCAT is used if nothing is specified.\n0       Examples:\n             SEARCH ON(PUBLIC MYVOL)\n             SEARCH ASCAT\n             SEARCH ON(MYVOL)\n-       \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n        |                 |\n        | QUALIFY Command |\n        |                 |\n        \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n0       The QUALIFY command is used to set the sequence of qualifiers to be\n        appended to the beginning and end of data set names.  No qualification\n        is performed until a QUALIFY command is used.\n0            \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n+                           \u00af\n             |              |                                       |\n             |  COMMAND     |   OPERANDS                            |\n             |              |                                       |\n             |\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\n+            \u00bf              \u00d7                                       ]\n             |              |                                       |\n             |              |   \u00d0              \u00af                    |\n             |  QUALIFY     |   | prequalifier |                    |\n             |              |   \u00bf              ]                    |\n             |              |   \u00d0                \u00af                  |\n             |              |   | /postqualifier |                  |\n             |              |   \u00bf                ]                  |\n             |              |                                       |\n             \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n+                           \u00bf\n0       prequalifier specifies the sequence of qualifiers that will be\n             appended to the beginning of all data set names unless suspended\n             by the use of quotes or respecified by another QUALIFY command.\n             If this operand is omitted, a null prequalifier is used.  If this\n             operand is included it must precede the /postqualifier operand.\n        /postqualifier specifies the sequence of qualifiers that are to be\n             appended to the end of all data set names unless suspended by the\n             use of quotes or respecified by another QUALIFY command.  If this\n             operand is omitted, a null postqualifier is used.  If this\n             operand is specified, the slash is required.\n0       NOTE: Either a single (') or double (\") quote may be used to suppress\n        qualification of a data set name.  A single or double quote placed at\n        the beginning of the data set name will suppress the prequalifier; a\n        single or double quote placed at the end of the data set name will\n        suppress the postqualifier.\n0       Examples:\n             The qualification was set by the command:\n0              QUALIFY USERA/FORT\n0            Name specified               Name after qualification\n1\n        UTL007                                                          Page 7\n-\n               QXW                          USERA.QXW.FORT\n               \"LOGA                        LOGA.FORT\n               XYZ.LOGA'                    USERA.XYZ.LOGA\n               'USERB.AY\"                   USERB.AY\n-       \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n        |              |\n        | STOP Command |\n        |              |\n        \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n0       The STOP command is used to specify the minimum return code that will\n        stop execution.\n0       A return code is set by each command upon completion of the command.\n        Each return code is an integer between 0 and 4095.  In general, the\n        larger the number, the more severe the error that was encountered in\n        the command.  A return code of zero indicates no errors.  Return codes\n        for the various errors are listed in Appendix A.\n0            \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n+                           \u00af\n             |              |                                       |\n             |  COMMAND     |   OPERANDS                            |\n             |              |                                       |\n             |\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\n+            \u00bf              \u00d7                                       ]\n             |              |                                       |\n             |  STOP        |   number                              |\n             |              |                                       |\n             \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n+                           \u00bf\n0       number specifies the lowest return code that will abort processing.\n             If the number is omitted, a value of plus infinity is assumed.\n             If a STOP command is not included, the default is STOP 8.\n0       Example:\n             STOP 5\n-       \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n        |              |\n        | NOTE Command |\n        |              |\n        \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n0       The NOTE command is used for placing comments in the output listing.\n0            \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n+                           \u00af\n             |              |                                       |\n             |  COMMAND     |   OPERANDS                            |\n             |              |                                       |\n             |\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\n+            \u00bf              \u00d7                                       ]\n             |              |                                       |\n             |  NOTE        |   comment                             |\n             |              |                                       |\n             \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n+                           \u00bf\n0       comment is any information to be used as a comment.\n1\n        UTL007                                                          Page 8\n-\n        EXAMPLES\n0       Example 1: Two copies of data set USERA.B.C reside on public volumes\n             STOREA and STOREB because a job was rerun with DISP=(NEW,CATLG).\n             The first data set was cataloged on STOREA and the second data\n             set was created on STOREB but not cataloged (IEF287I .... NOT\n             CATALOGED 2 message appeared in the JCL).  Since the second data\n             set is the good one, the first one must be deleted and its\n             catalog entry removed and then the second one cataloged.\n0         cc 1          12\n             /*PASSWORD 12345\n             //FIXCAT  JOB  (USERA,476321XA)\n             /*JOBPARM  BIN=8\n             //STEP EXEC DISKUTIL\n             //SYSIN    DD   *\n             DELETE USERA.B.C\n             CATALOG *\n             //\n-       Example 2: Avoid the situation described in example 1 by including the\n             following JCL as the first step in the job.\n0         cc 1          12\n             /*PASSWORD 12345\n             //GOODWAY JOB (USERA,476321XA)\n             /*JOBPARM  BIN=8\n             //STEP1 EXEC DISKUTIL\n             //SYSIN DD   *\n             DELETE USERA.B.C ON PUBLIC UNCAT\n             //\n0            This causes all occurences of the data set USERA.B.C on any\n             public volume to be scratched.  Any catalog entry for USERA.B.C\n             is also removed regardless of whether the catalog points to one\n             of the public volumes.  The volume pointed to by the catalog need\n             not be mounted.\n-       Example 3: Three data sets containing FORTRAN source are to be renamed\n             to facilitate editing from TSO.  The data set names currently are\n             USERID.PROGA, USERID.PROGB and USERID.PROGC.  The data sets are\n             to be renamed adding the postqualifier FORT.\n0         cc 1          12\n             /*PASSWORD 54321\n             //FORTSO JOB (USERID,720240XB)\n             /*JOBPARM  BIN=9\n             //   EXEC DISKUTIL\n             //SYSIN DD *\n             RENAME  USERID.PROGA  USERID.PROGA.FORT\n             RENAME  USERID.PROGB  USERID.PROGB.FORT\n             RENAME  USERID.PROGC  USERID.PROGC.FORT\n             //\n0            The QUALIFY command can be used to perform the same job and\n             reduce the amount of typing required.\n0         cc 1          12\n             /*PASSWORD 54321\n             //FORTSO JOB (USERID,720240XB)\n             /*JOBPARM  BIN=9\n             //   EXEC DISKUTIL\n             //SYSIN DD *\n             QUA  USERID/FORT\n             REN  PROGA\"  PROGA\n             REN  PROGB\"  PROGB\n             REN  PROGC\"  PROGC\n             //\n1\n        UTL007                                                          Page 9\n-\n        Example 4: Catalog a data set loaded to a public disk from an\n             uncataloged tape data set by IEHMOVE.\n0         cc 1          12\n             /*PASSWORD FCARY\n             //MOVEKLUG JOB (IBMUSER,999IBMCORP),'ARMONK'\n             /*JOBPARM  BIN=0\n             /*SETUP    UNIT=TAPE9,SER=R99999,SL=R99999,PROTECT\n             //STEP1 EXEC MOVE,U=TAPE9,V=R99999\n             //SYSIN DD *\n               COPY PDS=IBMUSER.PROGRAMS.LOAD,FROM=TAPE9=R99999,TO=SYSDA=STOREA\n             //STEP2 EXEC DISKUTIL\n             //SYSIN DD *\n             CATALOG IBMUSER.PROGRAMS.LOAD ON PUBLIC\n             //\n1\n        UTL007 - Appendix A - 2 July 1979                              Page A1\n-\n                      ERROR MESSAGES AND ASSOCIATED RETURN CODES\n-       RETURN CODE   MESSAGE\n0             0       vvvvvv ASSUMED TO BE 3330\n              4       DATA SET NOT FOUND IN CATALOG\n              4       DATA SET NOT FOUND ON ANY VOLUMES SEARCHED\n              4       DATA SET NOT RENAMED ON ANY VOLUMES SEARCHED\n              8       INCORRECT PASSWORD SUPPLIED FOR DATA SET ON vvvvvv\n              8       VOLUME NOT MOUNTED: vvvvvv\n              8       BAD GENERATION DATA GROUP NAME\n              8       REQUIRED CONTROL VOLUME NOT MOUNTED\n              8       DSNAME ILLEGAL FOR USER\n              8       DATA SET ALREADY EXISTS ON vvvvvv\n              8       DATA SET NOT EXPIRED ON vvvvvv\n              8       DATA SET ALREADY IN CATALOG\n             12       TOO MANY CONTINUATION CARDS\n             12       TOO MANY VOLUMES SPECIFIED\n             12       MULTIPLE VOLUME DATA SETS NOT SUPPORTED\n             16       COMMAND NOT FOUND\n             16       INVALID COMMAND SYNTAX\n             16       DSNAME ILLEGAL SYNTAX\n             20       PERMANENT I/O ERROR IN CATALOG\n             20       PERMANENT I/O ERROR ON vvvvvv\n             20       PROGRAM ERROR - SEE SYSTEM PROGRAMMER\n                      (IN USER CLINIC)\n             20       CATALOG IS FULL\n-       NOTE -- vvvvvv represents an inserted volume serial number.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ULT11@": {"ttr": 12552, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "1\n-\n0                  INSTITUTE FOR COMPUTER SERVICES AND APPLICATIONS\n0                                  RICE UNIVERSITY\n0                                 17 September 1982\n0                                Document No. UTL011\n0                                      TAPESCAN\n-\n        TAPESCAN is a utility program which can be used to print information\n        about the contents of labeled or unlabeled tapes.  It may also be used\n        to copy files from one tape to another.  When TAPESCAN is used to\n        \"scan\" a tape, the following functions may be requested:\n0     |   \u00ae  A \"volume table of contents\" (VTOC) listing may be produced\n      |      including, for labeled tapes, the name and DCB attributes of\n      |      each file.\n0     |   \u00ae  The number of blocks and the minimum, maximum and average\n             block length may be printed for each file.  This information\n             is used to compute an estimate of the length of the used\n             portion of the tape.\n0         \u00ae  A specified number of blocks from each file may be listed in\n             character form.  Optionally, they may also be listed in\n             hexadecimal.  Only the first 120 characters of each block are\n             listed.\n0         \u00ae  Program operation may begin at any file of the input tape.\n0         \u00ae  Operation may continue past one or more end-of-volume\n             indications.  This feature may allow the retrieval of some\n             data from tape files which have been partially overwritten.\n0       When TAPESCAN is used to copy, the following functions may be\n        requested:\n0         \u00ae  All or part of one tape may be copied to another.  Output may\n             start at any file of the output tape.\n0         \u00ae  All or part of an input tape may be copied onto the end of an\n             output tape.\n0         \u00ae  When a labeled output tape is used, the output volume serial\n             normally remains unchanged.  The user may request, however,\n             that the output tape's label is to be copied from the input\n             tape or is to be destroyed.\n0       The following restrictions exist on the use of TAPESCAN.\n0         \u00ae  Files from an unlabeled tape may not be copied to a labeled\n             tape unless the label is to be destroyed.\n0         \u00ae  Only a single volume may be used for input or output.\n0         \u00ae  TAPESCAN cannot copy to a completely blank output tape.  To\n             use TAPESCAN to copy to such a tape, the user must first\n             request initialization of the tape, as described in ICSA\n             Document GEN008.\n0         \u00ae  All data files of a 7-track input tape must be written at the\n             same density and using the same recording technique (TRTCH).\n             These DCB parameters must be specified correctly in the JCL.\n0       TAPESCAN was written by the Institute for Research in Social Sciences\n        at the University of North Carolina at Chapel Hill, and has been\n      | extensively modified by ICSA and other SHARE members.  TAPESCAN is\n      | supported as class A1 software (i.e., consulting and maintenance are\n      | available from ICSA).\n1\n        UTL011                                                          Page 2\n-\n        \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n        |       |\n        | USAGE |\n        |       |\n        \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n-     | Three cataloged procedures are available to run TAPESCAN:  TAPESCAN,\n      | TAPEMAP and TAPECOPY.  The function of each procedure is as follows:\n0     |      TAPESCAN -- To scan a tape, producing a fairly verbose summary of\n      |           the tape contents.  This PROC is recommended for unknown or\n      |           possibly invalid tapes, or when a listing of data records is\n      |           required.\n0     |      TAPEMAP  -- To scan a tape, producing only a volume table of\n      |           contents and diagnostic messages.  The omission of the label\n      |           summary and listing of data records makes the output easier\n      |           to read (and the run less expensive), but some details about\n      |           \"problem tapes\" may be lost.  (See Appendix B for detailed\n      |           information on the interpretation of the volume table of\n      |           contents.)\n0     |      TAPECOPY -- To copy one tape to another.\n0       A listing of these procedures is available for reference in the User\n        Clinic.  The Job Control Language (JCL) available at ICSA is described\n      | in ICSA Document GEN001.  The JCL used with these procedures is\n      | outlined below.\n0         cc 1          12\n             /*PASSWORD password                                 required\n             //jobname  JOB     (standard JOB card format)       required\n             /*JOBPARM  BIN=bin                                  required\n             /*SETUP    unit,SER=volser,SLOT=slotno              required\n      |      //stepname EXEC    procname,parameters              required\n             //                                                  required\n-\n        A SETUP card is required for each tape to be read or written.  See\n                  ICSA Document GEN001 for the format of this card.\n0       The EXEC card may include the following symbolic parameters and\n                  keyword operands:\n0     |           OPTIONS='option-list' - may be used to specify execution\n      |                options.  The options available are described in the\n                       section labeled \"OPTIONS SUMMARY\" below.\n0                 ISER=input-volser - specifies the volume serial number of\n                       the input tape volume.  This parameter is required and\n                       must correspond to the volume serial specified on the\n                       SETUP card for this tape.\n0                 IUNIT=input-unit - indicates the type of tape drive to be\n                       used for the input tape.  The value coded should be a\n                       valid value for the UNIT keyword on the DD statement\n                       and correspond to the UNIT specified on the SETUP card.\n                       Valid values include TAPE9 for a 9-track 1600/6250 bpi\n                       drive, 'T8/16' for a 9-track 800/1600 bpi drive, and\n                       TAPE7 for a 7-track 200/556/800 bpi drive.  See the\n                       discussion of the DD card in ICSA Document GEN001 for a\n                       complete list of the valid unit names for tape drives\n                       at ICSA.  The default is IUNIT=TAPE9.\n0                 ILABTYP=label-type - may be used to specify the type of\n                       label (i.e., SL, AL or NL) the input tape is believed\n                       to possess.  In most cases, a tape can be scanned or\n                       mapped successfully even if the label type is specified\n                       incorrectly.  If no label-type is specified, the input\n                       tape is assumed to be unlabeled.\n0                 IFILE=fileno - may be used to indicate the number of the\n                       first tape file to be scanned or copied.  The default\n                       is IFILE=1.\n0     | The following keywords apply only to the TAPECOPY PROC.\n0                 OSER=output-volser - specifies the volume serial number of\n1\n        UTL011                                                          Page 3\n-\n                       the output tape volume.  This parameter is required for\n                       a copy operation and must correspond to that coded on\n                       the SETUP card for the output tape.  For a labeled\n                       output tape, the output-volser must be the same as that\n                       specified in the tape label itself.\n0                 OUNIT=output-unit - indicates the type of tape drive to be\n                       used for the output tape.  The values allowed for this\n                       keyword are the same as for the IUNIT keyword, as\n                       described above.  The default is OUNIT=TAPE9.\n0                 OLABTYP=label-type - must be used to specify the label type\n      |                for an output tape (SL, AL or NL).  This must specify\n      |                the way the tape is labeled before the copy; if OLABTYP\n      |                is not specified correctly, the tape will not be used\n      |                for output.  Note:  To copy an unlabeled tape onto a\n      |                previously labeled tape, or vice versa, the UNLABEL\n      |                option (described below in the \"OPTIONS SUMMARY\"\n      |                section) must be specified.\n0                 OFILE=fileno - may be used to indicate the number of the\n                       first output file If OFILE is not specified, output\n                       begins at the first file of the tape, unless the option\n                       EOVMOD (described below in the \"OPTIONS SUMMARY\"\n                       section) is used.\n0                 ODEN=output-density - specifies the recording density for\n      |                the output tape. The valid values for this keyword are\n      |                0, 1, 2, 3 and 4, for 200, 556, 800, 1600 and 6250 bpi\n      |                respectively.  For 9-track tapes, ODEN is ignored\n      |                except in cases where the first block of the tape is\n      |                rewritten (i.e., it is ignored when the OFILE parameter\n      |                is greater than 1, or when the output tape is labeled\n      |                and the UNLABEL option is not specified).  For 7-track\n      |                tapes, ODEN must specify the density at which the\n      |                output tape is currently recorded.  The default ODEN is\n      |                the highest density supported by the tape drive (i.e.,\n      |                4 if OUNIT=TAPE9, 3 if OUNIT='T8/16', and 2 if\n      |                OUNIT=TAPE7).\n0     | The following parameters are meaningful only for seven-track tapes.\n      | They are ignored for nine-track tapes.\n0                 IDEN=input-density - specifies the recording density for the\n                       input tape.  This parameter is required for 7-track\n                       tapes not recorded at the default density of 800 bpi.\n                       Valid values are 0, 1, and 2 corresponding to 200, 556,\n                       and 800 bpi respectively.\n0                 ITRTCH=input-recording-technique - specifies the recording\n                       technique for a 7-track input tape.  This corresponds\n                       to the DCB subparameter TRTCH on the DD statement\n                       described in the MVS JCL Manual.  Valid values are E,\n+                                       ___ ___\n                       ET, T, and C.  If omitted, odd parity, no translation,\n                       and no code conversion are assumed.  See the IBM\n                       manual, OS/VS Tape Labels, for more information.\n+                              _____ ____ ______\n0                 OTRTCH=output-recording-technique - specifies the recording\n      |                technique for a 7-track output tape (used with the\n      |                TAPECOPY PROC only).  The valid values for this keyword\n                       are the same as for the ITRTCH keyword, as described\n                       above.  If OTRTCH is omitted, odd parity, no\n                       translation and no code conversion are assumed.\n1\n        UTL011                                                          Page 4\n-\n      | \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n      | |                 |\n      | | OPTIONS SUMMARY |\n      | |                 |\n      | \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n-     | The following is a list of the TAPESCAN options and a brief\n      | description of their function.  The options are described in more\n      | detail in Appendix A.\n0     |      NOSUM      - suppresses label summary information and table of\n      |                   contents (VTOC).\n      |      FULLSUM    - provides a more detailed label summary.\n      |      MAPONLY    - produces only a table of contents and global\n      |                   statistics.\n0     |      COUNT      - requests record count and size information.\n      |      NOCOUNT    - suppresses record counting.\n0     |      LIST=n     - requests the listing of the first \"n\" blocks of each\n      |                   file.\n      |      NOLIST     - suppresses data listing.\n0     |      HEX        - requests that data blocks be listed in hexadecimal.\n0     |      LINE=nn    - requests \"nn\" lines per page of output.\n0     |      SKIPTM=n   - requests that \"n\" tape marks (or physical files) be\n      |                   skipped before beginning processing.\n0     |      STOPTM=n   - requests termination after \"n\" tape marks (or\n      |                   physical files) have been processed.\n0     |      ERRLIM=n   - requests termination after \"n\" I/O errors.\n0     |      EOVMOD     - copies the input tape after the last file of the\n      |                   output tape.\n0     |      UNLABEL    - allows the labels of the output tape to be changed\n      |                   or destroyed.\n0     |      ASCII=IN   - specifies that the input tape is in ASCII.\n0     |      ASCII=OUT  - specifies that the output tape is in ASCII.\n-     | The options which are permissible with each cataloged procedure are as\n      | follows:\n0     |      TAPESCAN --\n      |           NOSUM     COUNT     LIST=n    HEX       SKIPTM=n  ERRLIM=n\n      |           FULLSUM   NOCOUNT   NOLIST    LINE=nn   STOPTM=n  ASCII=IN\n0     |      TAPEMAP  --\n      |           COUNT     LINE=nn   STOPTM=n  ASCII=IN\n      |           NOCOUNT   SKIPTM=n  ERRLIM=n\n0     |      TAPECOPY --\n      |           FULLSUM   NOLIST    LINE=nn   STOPTM=n  EOVMOD    ASCII=IN\n      |           MAPONLY   HEX       SKIPTM=n  ERRLIM=n  UNLABEL   ASCII=OUT\n      |           LIST=n\n1\n        UTL011                                                          Page 5\n-\n      | \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n      | |                       |\n      | | TAPESCAN RETURN CODES |\n      | |                       |\n      | \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n-     | TAPESCAN issues an OS return code to indicate its success or failure.\n      | These are as follows:\n0     |      0  -- No problems were detected.\n0     |      8  -- One or more VTOC footnotes were generated, possibly\n      |            indicating serious problems with the input tape.\n0     |      12 -- TAPESCAN terminated due to the severity or frequency of I/O\n      |            errors.\n0     |      16 -- TAPESCAN was unable to perform its function due to\n      |            unrecoverable errors (e.g., the label type of the output\n      |            tape was not correctly specified).\n-\n        \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n        |          |\n        | EXAMPLES |\n        |          |\n        \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n-       The following table is a guide to the examples below.\n0       \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n+                  \u00af                                               \u00af\n        |          |                                               |         |\n        |  PROC    |  DESCRIPTION                                  |  NUMBER |\n        |          |                                               |         |\n        |\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7|\n+       \u00bf          \u00d7                                               \u00d7         ]\n        |          |                                               |         |\n        | TAPEMAP  |  Standard labeled tape, VTOC listing only     |    1    |\n        |          |                                               |         |\n        | TAPESCAN |  Unlabeled tape, normal output                |    2    |\n        |          |                                               |         |\n        | TAPESCAN |  7-track tape, full label information         |    3    |\n        |          |                                               |         |\n        | TAPESCAN |  Unlabeled ASCII tape, 800 bpi                |    4    |\n        |          |                                               |         |\n        | TAPECOPY |  Standard labeled tapes, simple copy          |    5    |\n        |          |                                               |         |\n        | TAPECOPY |  Standard labeled tapes, copy 9 track to      |    6    |\n        |          |  7 track                                      |         |\n        |          |                                               |         |\n        | TAPECOPY |  Standard labeled tape, copy selected files   |    7    |\n        |          |                                               |         |\n        | TAPECOPY |  Standard labeled tapes, change output        |    8    |\n        |          |  volser, print VTOC listing only              |         |\n        |          |                                               |         |\n        | TAPECOPY |  Copy standard labeled tape to end of ANSI    |    9    |\n        |          |  labeled tape                                 |         |\n        |          |                                               |         |\n        \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n+                  \u00bf                                               \u00bf\n-     | Example 1: Scan a 9-track tape with IBM standard labels, producing a\n      |      VTOC listing only.\n0         cc 1          12\n             /*PASSWORD 555555\n             //LABELED  JOB   (CURIOUS,898YELLOW)\n             /*JOBPARM  BIN=9\n             /*SETUP    TAPE9,SER=USRTAP,SLOT=U01000,P\n      |      //         EXEC  TAPEMAP,ISER=USRTAP,ILABTYP=SL\n             //\n1\n        UTL011                                                          Page 6\n-\n        Example 2: Scan a 9-track unlabeled tape.  No special options are\n             required.\n0         cc 1          12\n             /*PASSWORD 123123\n             //SIMPLE   JOB   (SIMON,275SAYS)\n             /*JOBPARM  BIN=5\n             /*SETUP    TAPE9,SER=ZZ1111,SLOT=ONEDAY,P\n             //SCAN     EXEC  TAPESCAN,ISER=ZZ1111\n             //\n-       Example 3: Scan a 7-track tape with IBM standard labels, listing as\n             much label information as possible.  Records are to be listed in\n             hexadecimal as well as in character form.  The tape is written at\n             556 bpi, using the data conversion feature.\n0         cc 1           12\n             /*PASSWORD 765432\n             //DETAILS  JOB   (USER10,275ANYACCT)\n             /*JOBPARM  BIN=3\n             /*SETUP    TAPE7,SER=R70777,PROTECT\n             //LOOKATIT EXEC  TAPESCAN,ISER=R70777,ILABTYP=SL,\n             //         IUNIT=TAPE7,IDEN=1,ITRTCH=C,\n      |      //         OPTIONS='FULLSUM,COUNT,HEX'\n             //\n-       Example 4: Scan a 9-track, unlabeled tape written in ASCII at 800 bpi.\n             Print the first 120 characters of the first 20 data records of\n             each file.\n0         cc 1          12\n             /*PASSWORD 424242\n             //ASCII    JOB   (SOMEONE,999ACCT)\n             /*JOBPARM  BIN=0\n             /*SETUP    T8/16,SER=ASCII9,SLOT=ONEDAY,P\n             //         EXEC  TAPESCAN,ISER=ASCII9,IUNIT='T8/16',\n      |      //         OPTIONS='LIST=20,ASCII=IN'\n             //\n-     | Example 5: Copy a 9-track, standard labeled tape to another.\n0     |   cc 1          12\n      |      /*PASSWORD 523523\n      |      //COPYLABL JOB   (FULL,555EMPTY)\n      |      /*JOBPARM  BIN=5\n      |      /*SETUP    TAPE9,SER=R92323,P\n      |      /*SETUP    TAPE9,SER=R91132,NP\n      |      //         EXEC  TAPECOPY,ISER=R92323,ILABTYP=SL,\n      |      //         OSER=R91132,OLABTYP=SL\n      |      //\n-     | Example 6: Copy a 9-track 6250 bpi input tape (standard labeled) to a\n      |      7-track 800 bpi output tape, translating from EBCDIC to BCD.\n             Note that the data must all fit on a single volume at the lower\n             density.\n0         cc 1          12\n             /*PASSWORD 002020\n             //COPYTAPE JOB   (COPY,999CAT)\n             /*JOBPARM  BIN=8\n             /*SETUP    TAPE9,SER=R91000,P\n      |      /*SETUP    TAPE7,SER=R75555,NP\n      |      //COPY     EXEC  TAPECOPY,ISER=R91000,ILABTYP=SL,\n      |      //         OSER=R75555,ODEN=2,OUNIT='TAPE7',OLABTYP=SL,\n      |      //         OTRTCH=T\n             //\n1\n        UTL011                                                          Page 7\n-\n        Example 7: Copy data files 2 and 3 of a 9-track labeled tape (plus\n             their associated labels) to files 4 and 5 of another 9-track\n             labeled tape.  Suppress the listing of data records from the\n             tape.  Because the tapes are labeled, the STOPTM option specifies\n             three times the number of data files to be copied.\n0         cc 1           12\n             /*PASSWORD 000999\n             //COPYSOME JOB   (PARTIAL,275DERIV)\n             /*JOBPARM  BIN=8\n             /*SETUP    TAPE9,SER=ALPHA,SLOT=ONEDAY,P\n             /*SETUP    TAPE9,SER=OMEGA,SLOT=ONEDAY,NP\n      |      //         EXEC  TAPECOPY,ISER=ALPHA,OSER=OMEGA,ILABTYP=SL,\n             //         OLABTYP=SL,IFILE=2,OFILE=4,\n      |      //         OPTIONS='NOLIST,STOPTM=6'\n             //\n-       Example 8:  Copy a 9-track tape with IBM standard labels to another\n      |      volume, suppressing the listing of data records and label\n      |      summary.  Change the volume serial number of the output tape to\n             be the same as that of the input tape.\n0         cc 1          12\n             /*PASSWORD 444444\n             //XACTCOPY JOB   (USER44,898BUSY)\n             /*JOBPARM  BIN=4\n             /*SETUP    TAPE9,SER=367123,SLOT=U00444,P\n             /*SETUP    TAPE9,SER=367800,SLOT=ONEDAY,NP\n      |      //         EXEC  TAPECOPY,ISER=367123,OSER=367800,\n             //         ILABTYP=SL,OLABTYP=SL,\n      |      //         OPTIONS='MAPONLY,UNLABEL'\n             //\n-       Example 9: Copy a 9-track tape with IBM standard labels to an 800 bpi\n             9-track tape with ANSI labels,  adding the new data set(s) to the\n             end of the output tape.  Suppress the listing of data records\n      |      from the tape.  Note that the output tape must already be\n      |      recorded at 800 bpi.\n0         cc 1          12\n             /*PASSWORD 222222\n             //TRANSLAT JOB   (ANSUSER,275ASCII)\n             /*JOBPARM  BIN=3\n             /*SETUP    TAPE9,SER=IBMTAP,SLOT=U00101,P\n             /*SETUP    T8/16,SER=ANSTAP,SLOT=ONEDAY,NP\n      |      //ADDTOEND EXEC  TAPECOPY,ISER=IBMTAP,OSER=ANSTAP,ILABTYP=SL,\n             //         OLABTYP=AL,OUNIT='T8/16',ODEN=2,\n      |      //         OPTIONS='EOVMOD,NOLIST'\n             //\n1\n        UTL011 - Appendix A - 17 September 1982                        Page A1\n-\n                                   TAPESCAN OPTIONS\n-     | TAPESCAN options are specified through the OPTIONS parameter of the\n      | EXEC statement.  Options are provided to specify the amount and type\n        of output, the number and position of tape files to be processed, and\n      | whether or not tape copying or ASCII translation is to be performed.\n      | The valid TAPESCAN options are described below.  Each option is\n      | followed by an indication, within parentheses, of the PROCs for which\n      | it is valid (where S indicates the TAPESCAN PROC, M the TAPEMAP PROC\n      | and C the TAPECOPY PROC).\n0     | NOSUM (S) - specifies that a summary of label information (for a\n      |      labeled input tape) is not wanted.  This also suppresses the\n      |      volume table of contents.\n      | FULLSUM (S,C) - specifies that each input tape label is to be listed\n      |      in addition to the normal summary information.\n      | MAPONLY (C) - specifies that only a volume table of contents is wanted\n      |      (i.e., that the normal, more verbose label summary is to be\n      |      suppressed).  Note that MAPONLY is ignored if the LIST option is\n      |      specified.  MAPONLY is implied when the TAPEMAP procedure is\n      |      used, and should not be specified explicitly with this PROC.\n      |      MAPONLY may be abbreviated as MAP.\n0     | Note: If none of NOSUM, FULLSUM, or MAPONLY is specified (for the\n      | TAPESCAN and TAPECOPY PROCs), a detailed summary of information from\n      | the labels is printed for each file of a labeled tape, in addition to\n      | the normal VTOC listing described below.  Information printed includes\n        the file sequence number, data set name, creation date, date of last\n      | modification, expiration date, number of blocks in the file (BLOCK\n      | COUNT), protection status, and the name of the job and job step which\n        created the file.  The DCB parameters RECFM, LRECL, BLKSIZE, TRTCH and\n        (for an ASCII tape only) BUFOFF are also printed.  See the IBM manual,\n        OS/VS Tape Labels, for further information on the interpretation of\n+       _____ ____ ______\n        the contents of tape labels.\n0     | COUNT (S,M) - specifies that the number of blocks on each tape file is\n      |      to be determined, together with the maximum, minimum and average\n      |      block length.  This is normally the default.\n        NOCOUNT (S,M) - specifies that block count and length information are\n             not to be determined.  This option reduces the number of I/O\n             operations required to process a tape.  NOCOUNT is recommended\n      |      only for use with labeled tapes.  NOCOUNT is the default when the\n      |      TAPEMAP PROC is used with a labeled tape.\n0     | LIST=n (S,C) - specifies that the first 120 characters of the first n\n      |      records of each input file are to be printed.  The default is\n      |      LIST=4 except when MAPONLY is specified (or defaulted by the\n      |      TAPEMAP PROC).\n      | NOLIST (S,C) - specifies that input data records are not to be listed.\n      |      If MAPONLY is specified, NOLIST is the default.\n0     | HEX (S,C) - specifies that listed data records and/or labels are to be\n      |      printed in hexadecimal as well as in character form.\n0     | LINE=nn (S,M,C) - specifies the number of lines to be printed per\n      |      page.  The default is 59.\n0     | SKIPTM=n (S,M,C) - specifies the number of tape marks (which separate\n      |      physical tape files) to be skipped on the input tape before\n             beginning processing.  Note that before the tape marks are\n             skipped, the tape is positioned as specified by the IFILE\n             parameter of the EXEC card.  SKIPTM will not cause a tape to be\n+                                                     ___\n             positioned beyond an end-of-volume indication, unless special\n             action is taken, as described in Appendix C.  Note that on a\n             labeled tape there will be three tapemarks for each data file.\n0     | STOPTM=n (S,M,C) - specifies the maximum number of physical input tape\n      |      files to be processed.  Files skipped as a result of the IFILE\n             parameter of the EXEC statement or the SKIPTM option are not\n             included in this count.  STOPTM will not cause a tape to be\n+                                                 ___\n             processed beyond an end-of-volume indication, except by use of\n             the options described in Appendix C.  If STOPTM is not specified,\n             processing will terminate upon reaching an end-of-volume\n             indication.  Note that, for a labeled tape, three physical files\n             exist for each data file on the tape.\n0     | ERRLIM=n (S,M,C) - specifies the maximum acceptable number of I/O\n      |      errors.  The default is ERRLIM=5.  Until the I/O error limit is\n             reached, program operation will continue, without regard to any\n1\n        UTL011 - Appendix A - 17 September 1982                        Page A2\n-\n             error indications.  When an input error occurs, data will be used\n             exactly as received.  This may cause incorrect information and/or\n             incorrect-length blocks to be written to an output tape.\n0     | EOVMOD (C) - specifies that the input tape is to be copied onto the\n      |      end of the output tape (i.e., after the output tape's current\n             last file).  If a file number is specified in the JCL OFILE\n             parameter, the point at which to begin output is determined by\n             locating the first end-of-volume indication after the specified\n             file of the output tape.  When the number of the last file on a\n      |      tape is known, ICSA recommends the use of the OFILE JCL parameter\n      |      in place of EOVMOD, to be sure that output begins at the right\n             file of the tape.\n0     | UNLABEL (C) - specifies that the copy operation is allowed to destroy\n      |      the output volume label, change the output volume serial number,\n      |      or write labels on a previously unlabeled tape.  If UNLABEL is\n             not specified, the output volume serial will not be changed.\n             Note that UNLABEL should NEVER be used if either the input or\n             output tape is an ICSA R7 or R9 series tape.\n0     | ASCII=IN (S,M,C) - specifies that the input tape contains information\n      |      coded in ASCII.  This parameter need not be specified if the\n             input tape has ANSI standard labels; it will be ignored if the\n             input tape has IBM standard labels.  Note that TAPESCAN cannot\n             successfully convert ASCII data sets with record format D to\n             EBCDIC.\n0     | ASCII=OUT (C) - specifies that the output tape is to contain\n      |      information coded in ASCII.  This parameter need not be specified\n             if the output tape has ANSI standard labels; it will be ignored\n             if the output tape has IBM standard labels.  Note that TAPESCAN\n             cannot successfully convert EBCDIC data sets with record format V\n             to ASCII.  Warning: TAPESCAN may be used to produce ASCII tapes\n             containing data sets with a block size less than 18 or greater\n             than 2048; such data sets are in violation of the ANS standards\n             for tape labeling and may cause problems in later use.\n1\n        UTL011 - Appendix B - 17 September 1982                        Page B1\n-\n                         READING THE VOLUME TABLE OF CONTENTS\n-     | The TAPESCAN VTOC listing is printed in a columnar format, with\n      | occasional footnotes if any unusual conditions are detected.  An\n      | initial heading line gives the volume serial number, owner\n      | identification, density, recording technique and label type of the\n      | tape.  (If labels are malformed or inconsistent, the label type is\n      | shown as \"BLP\".)  A sample VTOC listing for a standard labeled tape\n      | (scanned with the COUNT option) is as follows:\n0     | \u00d0\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\n      | |\n      | |  SEQ. DATA SET NAME   LABEL RECFM LRECL BLKSIZE EXPIRES  BLK COUNT . .\n      | |\n      | |  0001 MONDAY.DATA      SL    FB   00080  06080   NONE     000104   . .\n      | |  0002 TUESDAY.LOAD     SL    VS   13026  13030   NONE     000206   . .\n      | |\n      | \u00bf\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\n0     |     \u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n      |                                                                      |\n      | . . . MAX BLK  MIN BLK  AVG BLK                                      |\n      |                                                                      |\n      | . . .  06080    00320    06025   COPY\u00d70001                           |\n      | . . .  13030    00085    11405   COPY\u00d70002   -->SEE NOTE A<--        |\n      |                                                                      |\n      |     \u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n0     | Individual columns in the table of contents are as follows:\n0     |    SEQ - the sequence number of the file.  For a labeled file, this is\n      |         taken from the label; for an unlabeled file, it is the\n      |         physical file number on the tape.\n0     |    DATA SET NAME - the data set name.  For an unlabeled file, the\n      |         constant \"*NO LABEL*\" appears.  Other special cases are\n      |         \"*TAPEMARK*\", for an empty, unlabeled data set, and\n      |         \"*IEHINITT*\", for the first file of an initialized, unused\n      |         tape.\n0     |    LABEL - the label type of the data set.  If this file has a\n      |         different label type than any previous file, or some other\n      |         condition would prevent access to it using normal JCL, a label\n      |         type of \"BLP\" is substituted.  In most cases, a footnote will\n      |         be generated for the first file with a label type of \"BLP\".\n0     |    RECFM - the file's DCB record format.  This column is empty for an\n      |         unlabeled file; if labels are present, but do not contain DCB\n      |         information, the record format will be printed as \"??\".\n0     |    LRECL - the file's DCB logical record length.  This column is empty\n      |         for an unlabeled file; if labels are present, but do not\n      |         contain DCB information, the record length will be printed as\n      |         \"??\".\n0     |    BLKSIZE - the file's DCB block size.  This column is empty for an\n      |         unlabeled file; if labels are present, but do not contain DCB\n      |         information, the block size will be printed as \"??\".\n0     |    EXPIRES - the data set's expiration date.  This column is empty for\n      |         an unlabeled file; it may be written as \"NONE\", if there is no\n      |         expiration date, or as \"INVALID\", if the date is invalid.\n0     |    BLK COUNT - the number of blocks in the data set.  If the COUNT\n      |         option is specified, this is the actual number of data blocks;\n      |         if NOCOUNT is in effect, this is obtained from the labels for\n      |         a labeled data set, or omitted for an unlabeled data set.\n0     |    MAX BLK - the maximum block size for the file.  This column appears\n      |         only if the COUNT option was specified or defaulted.\n0     |    MIN BLK - the minimum block size for the file.  This column appears\n      |         only if the COUNT option was specified or defaulted.\n0     |    AVG BLK - the average block size for the file.  This column appears\n      |         only if the COUNT option was specified or defaulted.\n1\n        UTL011 - Appendix B - 17 September 1982                        Page B2\n-\n      | The remaining two columns have no headings, and will be present only\n      | if required.\n0     |   \u00ae  The sequence number of the output tape file when a COPY is\n      |      performed.  For a labeled tape file, this is the sequence\n      |      number contained in the output labels; for an unlabeled file,\n      |      it is the physical output file number.\n0     |   \u00ae  A footnote reference if any unusual conditions were detected\n      |      for this file.  The footnotes are collected at the bottom of\n      |      each page of the VTOC listing.  It is recommended that any\n      |      footnotes be investigated thoroughly, as they may indicate\n      |      conditions making a tape partially or completely unusable.\n      |      (For labeled tapes, rescanning the tape with the FULLSUM\n      |      option may produce further information.)\n-     | If the NOCOUNT option is specified or defaulted, the \"MAX BLK\", \"MIN\n      | BLK\", and \"AVG BLK\" columns are replaced as follows:\n0     |     \u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00af\n      |                                                                      |\n      | . . . JOB NAME  STEP     CREATED                                     |\n      |                                                                      |\n      | . . . MONDAY    GO       082082                                      |\n      | . . . TUESDAY   COPY     082082               -->SEE NOTE A<--       |\n      |                                                                      |\n      |     \u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7\u00d7]\n0     |    JOB NAME - the name of the job which created the data set.  This\n      |         appears only when NOCOUNT was specified or defaulted, and only\n      |         for a labeled tape.\n0     |    STEP - the name of the job step which created the data set.  This\n      |         appears only when NOCOUNT was specified or defaulted, and only\n      |         for a labeled tape.\n0     |    CREATED - the date the data set was created.  This appears only\n      |         when NOCOUNT was specified or defaulted, and only for a\n      |         labeled tape.\n1\n        UTL011 - Appendix C - 17 September 1982                        Page C1\n-\n                        ACCESSING DATA BEYOND \"END OF VOLUME\"\n-       Occasionally, there is need to access data recorded on a tape beyond\n        an end-of-volume indication (two consecutive tapemarks).  There are\n        two possible reasons for such access.  First, if a tape file contains\n        no data, a double tapemark will occur, even though more files may\n        physically follow on the tape.  Second, when a tape is overwritten, an\n        end-of-volume indication is automatically written at the conclusion of\n        output.  Any previously written information beyond this indication\n        will remain recorded on the tape, and all but the first block thereof\n        can usually be read without error.  Thus, when a tape has been\n        erroneously overwritten, some of the previously recorded information\n        may be accessible beyond the end-of-volume indication.\n0       TAPESCAN provides two additional options to allow the reading of\n        information beyond an end-of-volume indication, as follows:\n0       SKIPEOV=n - specifies the number of end-of-volume indications to be\n             skipped on the input tape before beginning processing.  SKIPEOV\n             processing is performed after the input tape is positioned to the\n             file indicated in the IFILE JCL parameter.  If SKIPTM and SKIPEOV\n             are specified together, the SKIPTM processing is performed after\n             the SKIPEOV processing is complete.  The default for this option\n             is SKIPEOV=0, specifying that processing is to begin at the start\n             of the tape.\n0       STOPEOV=n - specifies the number of end-of-volume indications to be\n             processed before processing is terminated.  The default is\n             STOPEOV=1, which indicates that processing is stopped the first\n             time end of volume is indicated.  If both STOPTM and STOPEOV are\n             specified, processing will terminate when either the indicated\n             number of tape marks or the indicated number of end-of-volume\n             indications are encountered.\n0       Note that when SKIPEOV and/or STOPEOV are used with a tape which has\n        been overwritten, an I/O error should be expected on the first block\n        following the end-of-volume indication.\n0       Even with the options described above, attempting to retrieve data\n        recorded beyond an end-of-volume indication can be frustrating and\n        time-consuming.  For this reason, ICSA strongly recommends that users\n        who need to use the SKIPEOV and/or STOPEOV options see the consultant\n        in the User Clinic before attempting their use, especially with a tape\n        which has been overwritten.\n-       Example 1: Scan a 9-track tape whose label type is unknown, getting\n             information about the maximum and minimum length of each block.\n             List the first 120 characters of 10 records from each data file.\n             Continue past the first end-of-volume indication until a second\n             end-of-volume indication is located.\n0         cc 1          12\n             /*PASSWORD 800000\n             //AFTEREOV JOB   (MYNAME,275MYACCT)\n             /*JOBPARM  BIN=HOLD\n             /*SETUP    TAPE9,SER=MYSTRY,SLOT=U99999,P\n             //         EXEC  TAPESCAN,ISER=MYSTRY,\n      |      //         OPTIONS='COUNT,LIST=10,STOPEOV=2'\n             //\n1\n        UTL011 - Appendix C - 17 September 1982                        Page C2\n-\n        Example 2: Copy information after the first end-of-volume indicator on\n             an overwritten tape to an unlabeled tape.  Terminate the copy if\n             more than one I/O error occurs.  Note that an overwritten input\n             tape should be described in the JCL as unlabeled, even if labels\n             are present, or were present before the overwriting.  This\n             misrepresentation may be necessary because any tape labels still\n             present beyond the end-of-volume indication are unlikely to\n             correctly describe the remaining data.\n0         cc 1          12\n             /*PASSWORD 004376\n             //RECOVER  JOB   (PLEASE,275HOPEFUL)\n             /*JOBPARM  BIN=9\n             /*SETUP    TAPE9,SER=BADTAP,SLOT=U04300,P\n             /*SETUP    TAPE9,SER=RCOVER,SLOT=U01055,NP\n      |      //PASTEOV  EXEC  TAPECOPY,ISER=BADTAP,OSER=RCOVER,ILABTYP=NL,\n      |      //         OLABTYP=NL,OPTIONS='SKIPEOV=1,ERRLIM=2'\n             //\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ULT19@": {"ttr": 12809, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "1\n-\n0                  INSTITUTE FOR COMPUTER SERVICES AND APPLICATIONS\n0                                  RICE UNIVERSITY\n0                                   24 April 1979\n0                                Document No. UTL019\n0                    Printing and Punching Partitioned Data Sets\n-\n        PRINTPDS and PUNCHPDS are ICSA-written utility programs which may be\n        used to print or punch all members of a partitioned data set (PDS).\n        PRINTPDS may be used to list a PDS of any record format and record\n        length.  The listing includes a table of contents to allow a\n        particular member to be quickly found in the listing.  PUNCHPDS may be\n        used to punch any card-image PDS.  The format of the output allows the\n        PDS to be recreated by the use of the IBM utility IEBUPDTE.\n0       PRINTPDS and PUNCHPDS are supported as class A1 software (i.e.,\n        program maintenance and consulting are supplied by ICSA).\n-       USAGE\n0       The JCL to run PRINTPDS or PUNCHPDS is outlined below.\n0         cc 1          12\n             /*PASSWORD password                                   required\n             //jobname  JOB   (standard JOB card format)           required\n             /*SETUP\n             /*JOBPARM                                             required\n             //stepname EXEC  procname                             required\n             //\n0       A SETUP card is required if a PDS on an off-line private disk volume\n                  is to be printed or punched.  See ICSA Document GEN001 for\n                  the format of this card.\n0       A JOBPARM is required to specify the BIN number of the output.  It is\n                  also used for the following cases:\n0                 If the PDS is to be punched, the CARDS parameter must be\n                  used to specify the maximum number of cards to be punched.\n0                 If the PDS to be printed is a print file (i.e., the record\n                  format contains an A or M, indicating that the record\n                  contains ASA or machine control characters), the LINECT=0\n                  parameter must be specified to prevented unwanted page\n                  ejects.\n0                 See ICSA Document GEN001 for further information about the\n                  JOBPARM card.\n0       The EXEC card should specify either PRINTPDS or PUNCHPDS as\n                  \"procname\".  The following symbolic parameter is supported\n                  on the EXEC card for both procedures:\n0                 DSN='dsname' - specifies the name of the PDS to be printed\n                       or punched.  This parameter is required.\n0                 The following symbolic parameters are supported only for\n                  PRINTPDS:\n0                 FORMS=formno - specifies the form number to be used when\n                       printing the PDS listing.  If this parameter is\n                       omitted, the listing is produced on standard forms.\n                       See ICSA Document GEN009 for a list of the special\n                       forms available at ICSA.\n0                 TRAIN=train - specifies the print train to be used when\n                       printing the PDS.  If omitted, the PN train is used.\n                       For further information on print trains, see ICSA\n                       Document GEN009.\n0                 CTAPE=ctape - specifies the carriage tape to be used when\n                       printing the PDS.  If omitted, the default carriage\n                       tape is used.  For further information on carriage\n                       tapes, see ICSA Document GEN009.\n1\n        UTL019                                                          Page 2\n-\n                  LINECT=lines-per-page - specifies the number of lines to be\n                       printed on each page of the PDS listing.  The default\n                       value is 55.  If LINECT is set larger than 61, the\n                       LINECT parameter of the JOBPARM card must also be\n                       specified.  The LINECT parameter is ignored when a\n                       RECFM A or M data set is printed.\n-       EXAMPLES\n0       Example 1: Produce a reference listing of the current public TSO CLIST\n             library.\n0         cc 1          12\n             /*PASSWORD 444444\n             //PROCLIB  JOB   (MYSELF,275ME)\n             /*JOBPARM  LINES=9,BIN=1\n             //PRINTIT  EXEC  PRINTPDS,DSN='RICE.CLISTLIB'\n             //\n-       Example 2: Produce a listing of a TEXT data set (containing upper- and\n             lower-case characters) on special forms with the TN print train.\n0         cc 1          12\n             /*PASSWORD 123456\n             //PRINTEXT JOB   (ANYUSER,275ANYACCT)\n             /*JOBPARM  LINES=5,LINECT=80,BIN=HOLD\n             //         EXEC PRINTPDS,DSN='ANYUSER.MANUALS.TEXT',\n             //         FORMS=S2U1,TRAIN=TN,CTAPE=16C8,LINECT=80\n             //\n-       Example 3: Punch a card-image PDS.\n0         cc 1          12\n             /*PASSWORD 000000\n             //PUNCHOUT JOB   (WHOAMI,999AMNESIA)\n             /*JOBPARM  CARDS=1500,BIN=2\n             //         EXEC  PUNCHPDS,DSN='WHOAMI.PROJECT.PLI'\n             //\n0            The original data set could be recreated later by use of the\n             UPDTE proc, as follows:\n0         cc 1          12\n             /*PASSWORD 000000\n             //REMEMBER JOB   (WHOAMI,999AMNESIA)\n             /*JOBPARM  BIN=2\n             //         EXEC  UPDTE,PARM=NEW\n             //SYSUT2   DD    DSN=WHOAMI.PROJECT.PLI,DISP=(NEW,CATLG),\n             //         UNIT=SYSDA,SPACE=(6080,(20,10,5),RLSE),\n             //         DCB=BLKSIZE=6080\n             //SYSIN    DD    *\n                PDSPUNCH output deck\n             //\n0            For further information on UPDTE, see ICSA Document UTL013.007.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UPROMPT": {"ttr": 12812, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    UPROMPT &BFF,&SIZE,&EDIT,&WAIT,&HOLD,&BRKI,&HELP=,&MF=I\n&NAME    UPUT  &BFF,&SIZE,&EDIT,&WAIT,&HOLD,&BRKI,HELP=&HELP,          *\n               MF=&MF,@ENTRY=UPROMPT                           RTS02A1\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UPUT": {"ttr": 13057, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    UPUT  &BFF,&SIZE,&EDIT,&WAIT,&HOLD,&BRKI,&INFOR,&HELP=,&CPPL=,*\n               &IOPL=,&MF=I,&@ENTRY=UPUT                       RTS02A1\n         LCLA  &OPT,&POPT                                      RTS02A1\n         LCLA  &RET\n         LCLB  &E,&W,&H,&B,&P\n         LCLC  &PARM,&S,&L,&CPIOPL                             RTS02A1\n&S       SETC  '&SYSNDX'                                       RTS02A1\n&L       SETC  'L'''                                           RTS02A1\n         AIF   ('&MF' EQ 'L').MFL                              RTS02A1\n         AIF   ('&MF(1)' EQ 'E').MFE                           RTS02A1\n         AIF   ('&MF(1)' EQ 'I' OR '&MF' EQ '').MFI            RTS02A1\n         IHBERMAC 35,0,&MF                                     RTS02A1\n         MEXIT                                                 RTS02A1\n.MFI     ANOP                                                  RTS02A1\n         AIF   ('&BFF' EQ '*' OR '&BFF' EQ '').ERROR1\n         AIF   ('&BFF'(1,1) EQ '(' AND ('&SIZE' EQ '' OR '&SIZE' EQ '*'*\n               )).ERROR1                                       RTS02A1\n.MFE     AIF   ('&CPPL' EQ '' AND '&IOPL' EQ '' AND '&@ENTRY' EQ 'UPUT'*\n               ).ERROR1                                        RTS02A1\n         AIF   ('&CPPL' NE '' AND '&IOPL' NE '').ERROR2        RTS02A1\n&CPIOPL  SETC  '&CPPL&IOPL'                                    RTS02A1\n&PARM    SETC  '&EDIT'\n.CKPARM  ANOP\n&RET     SETA  &RET+1\n         AIF   ('&PARM' EQ '').RET           NULL, TRY NEXT\n         AIF   ('&PARM' EQ 'EDIT').EDI       SET EDIT\n         AIF   ('&PARM' EQ 'ASIS').ASI       SET ASIS\n         AIF   ('&PARM' EQ 'CONTROL').CON    SET CONTROL\n         AIF   ('&PARM' EQ 'WAIT').WAI       SET WAIT\n         AIF   ('&PARM' EQ 'NOWAIT').NOW     SET NOWAIT\n         AIF   ('&PARM' EQ 'HOLD').HOL       SET HOLD\n         AIF   ('&PARM' EQ 'NOHOLD').NOH     SET NOHOLD\n         AIF   ('&PARM' EQ 'NOBREAK').NOB    SET NOBREAK\n         AIF   ('&PARM' EQ 'BREAKIN').BRE    SET BREAKIN\n         AIF   ('&@ENTRY' NE 'UPUT').ERROR3                    RTS02A1\n         AIF   ('&PARM' EQ 'DATA').DATA                        RTS02A1\n         AIF   ('&PARM' EQ 'INFOR').INFOR                      RTS02A1\n         AGO   .ERROR3\n.*\n.*  CHECK REGISTER NOTATION IS USED\n.*\n.CHKREG  SPACE 1\n         AIF   ('&MF' EQ 'L').GENLIST                          RTS02A1\n         AIF   ('&MF' NE 'I' AND '&MF' NE '').GENE             RTS02A1\n.EXPAND  CNOP  0,4\n         AIF   ('&@ENTRY' EQ 'UPUT').PUTNAME                   RTS02A1\n&NAME    B     UPR&S              BRANCH AROUND PROMPT PARMS   RTS02A1\n         AGO   .GENI                                           RTS02A1\n.PUTNAME ANOP                                                  RTS02A1\n         AIF   ('&NAME' EQ '').NONAME                          RTS02A1\n&NAME    EQU   *                                               RTS02A1\n.NONAME  AIF   ('&SIZE' EQ '' OR '&SIZE' EQ '*').NOSIZER       RTS02A1\n         AIF   ('&SIZE'(1,1) NE '(').NOSIZER                   RTS02A1\n         STH   &SIZE(1),UPT&S+2   STORE MESSAGE LENGTH         RTS02A1\n.NOSIZER AIF   ('&BFF'(1,1) NE '(').NOBFFR                     RTS02A1\n         STCM  &BFF(1),7,UPT&S+5  STORE BUFFER ADDRESS         RTS02A1\n.NOBFFR  ANOP                                                  RTS02A1\n         AIF   (&POPT NE X'06' AND &POPT NE X'04').NOH2R       RTS02A1\n         AIF   ('&HELP(1)'(1,1) NE '(').NOH1R                  RTS02A1\n         ST    &HELP(1),UPT&S+12  STORE HELP ADDRESS           RTS02A1\n.NOH1R   AIF   ('&HELP(2)' EQ '').NOH2R                        RTS02A1\n         AIF   ('&HELP(2)'(1,1) NE '(').NOH2R                  RTS02A1\n         ST    &HELP(2),UPT&S+8   STORE HELP LENGTH            RTS02A1\n.NOH2R   AIF   ('&@ENTRY' NE 'UPUT').GEND                      RTS02A1\n         BAL   1,UPU&S            BRANCH AROUND CONSTANTS      RTS02A1\nUPT&S    EQU   *                                               RTS02A1\n         AGO   .GENI                                           RTS02A1\n.GENLIST AIF   ('&@ENTRY' EQ 'UPUT').PUTLIST                   RTS02A1\n         DS    0A                 ALIGN TO FULLWORD            RTS02A1\n&NAME    EQU   *-4                PROMPT LIST HAS ORIGIN 4     RTS02A1\n         AGO   .GENI                                           RTS02A1\n.PUTLIST ANOP                                                  RTS02A1\n&NAME    DS    0A                                              RTS02A1\n.GENI    DC    AL2(&POPT)               PUTLINE OPTIONS        RTS02A1\n         AIF   ('&BFF' EQ '' OR '&BFF' EQ '*').DUMSIZE         RTS02A1\n         AIF   ('&SIZE' NE '' AND '&SIZE' NE '*').GOTSIZE      RTS02A1\n         DC    AL2(&L&BFF)        BUFFER LENGTH                RTS02A1\n         AGO   .JSIZE                                          RTS02A1\n.GOTSIZE AIF   ('&SIZE'(1,1) NE '(').OKSIZE                    RTS02A1\n.DUMSIZE DC    AL2(0)             BUFFER SIZE                  RTS02A1\n         AGO   .JSIZE                                          RTS02A1\n.OKSIZE  ANOP                                                  RTS02A1\n         DC    AL2(&SIZE)               BUFFER SIZE\n.JSIZE   DC    AL1(&OPT)                OPTIONS\n         AIF   ('&BFF' EQ '' OR '&BFF' EQ '*').DUMBFF          RTS02A1\n         AIF   ('&BFF'(1,1) NE '(').OKBFF                      RTS02A1\n.DUMBFF  DC    AL3(0)             BUFFER ADDR                  RTS02A1\n         AGO   .JBFF                                           RTS02A1\n.OKBFF   ANOP                                                  RTS02A1\n         DC    AL3(&BFF)                BUFFER ADDR\n.JBFF    AIF   ('&HELP' EQ '' AND ('&MF' EQ 'I' OR '&MF' EQ '')).SKPHEL*\n               P                                               RTS02A1\n         AIF   ('&HELP' EQ '').RHNOLEN                         RTS02A1\n         AIF   ('&HELP(1)'(1,1) EQ '(').RHMSG                  RTS02A1\n         AIF   ('&HELP(2)' EQ '').HGLEN                        RTS02A1\n         AIF   ('&HELP(2)'(1,1) EQ '(').HNOLEN                 RTS02A1\n         DC    AL4(&HELP(2))      LENGTH OF HELP MESSAGE       RTS02A1\n         AGO   .JHLEN                                          RTS02A1\n.HGLEN  DC    AL4(&L&HELP(1))    LENGTH OF HELP MESSAGE        RTS02A1\n         AGO   .JHLEN                                          RTS02A1\n.HNOLEN DC    AL4(0)             LENGTH OF HELP MESSAGE        RTS02A1\n.JHLEN   DC    AL4(&HELP(1))      HELP MESSAGE ADDR            RTS02A1\n         AGO   .SKPHELP                                        RTS02A1\n.RHMSG   AIF   ('&HELP(2)'(1,1) EQ '(').RHNOLEN                RTS02A1\n         DC    AL4(&HELP(2))      LENGTH OF HELP MESSAGE       RTS02A1\n         AGO   .JRHLEN                                         RTS02A1\n.RHNOLEN DC    AL4(0)             LENGTH OF HELP MESSAGE       RTS02A1\n.JRHLEN  DC    AL4(0)             ADDRESS OF HELP MESSAGE      RTS02A1\n.SKPHELP ANOP                                                  RTS02A1\n         AIF   ('&MF' EQ 'L').GEND                             RTS02A1\n         AIF   ('&@ENTRY' EQ 'UPUT').PUTCPPL                   RTS02A1\nUPR&S    EQU   *                                               RTS02A1\n         AGO   .NONAME                                         RTS02A1\n.PUTCPPL ANOP                                                  RTS02A1\nUPU&S    EQU   *                                               RTS02A1\n.LDCPPL  AIF   ('&CPIOPL' EQ '(0)').CPPL0                      RTS02A1\n         AIF   ('&CPIOPL'(1,1) EQ '(').CPPLR                   RTS02A1\n         LA    0,&CPIOPL        LOAD CPPL ADDRESS              RTS02A1\n         AGO   .CPPL0                                          RTS02A1\n.CPPLR   LA    0,0&CPIOPL     LOAD CPPL ADDRESS                RTS02A1\n         AIF   ('&IOPL' NE '').IOPLFF                          RTS02A1\n         AGO   .CPPLO                                          RTS02A1\n.CPPL0   AIF   ('&IOPL' NE '').IOPLFF                          RTS02A1\n         ICM   0,8,=X'00'         INDICATE CPPL PASSED         RTS02A1\n         AGO   .CPPLO                                          RTS02A1\n.IOPLFF  ICM   0,8,=X'FF'         INDICATE IOPL PASSED         RTS02A1\n.CPPLO   ANOP                                                  RTS02A1\n         L     15,=V(UKJUPUT)                                  RTS02A1\n         BALR  14,15              CALL UPUT ROUTINE            RTS02A1\n.GEND    SPACE 1\n         MEXIT\n.EDI     ANOP\n         AIF   (&E).ERROR2              DUP OPTION\n&E       SETB  1                        EDIT OPTION SPECFIED\n         AGO   .RET\n.ASI     ANOP\n         AIF   (&E).ERROR2              DUP OPTION\n&E       SETB  1                        EDIT OPTION SPECFIED\n&OPT     SETA  &OPT+1                   SET EDIT=ASIS\n         AGO   .RET\n.CON     ANOP\n         AIF   (&E).ERROR2              DUP OPTION\n&E       SETB  1                        EDIT OPTION SPECFIED\n         MNOTE 0,'UPUT001 WARNING -- EFFECTS OF CONTROL OPTION ARE DEVI*\n               CE DEPENDENT'\n&OPT     SETA  &OPT+2                   SET EDIT=CONTROL\n         AGO   .RET\n.WAI     ANOP\n         AIF   (&W).ERROR2              DUP OPTION\n&W       SETB  1                        WAIT OPTION SPECIFIED\n         AGO   .RET\n.NOW     ANOP\n         AIF   (&W).ERROR2              DUP OPTION\n&W       SETB  1                        WAIT OPTION SPECIFIED\n&OPT     SETA  &OPT+X'10'               SET WAIT=NOWAIT\n         AGO   .RET\n.HOL     ANOP\n         AIF   (&H).ERROR2              DUP OPTION\n&H       SETB  1                        HOLD OPTION SPECIFIED\n&OPT     SETA  &OPT+X'08'               SET HOLD=HOLD\n         AGO   .RET\n.NOH     ANOP\n         AIF   (&H).ERROR2              DUP OPTION\n&H       SETB  1                        HOLD OPTION SPECIFIED\n         AGO   .RET\n.BRE     ANOP\n         AIF   (&B).ERROR2              DUP OPTION\n&B       SETB  1                        BREAK OPTION SPECIFIED\n&OPT     SETA  &OPT+X'04'               SET BREAKIN\n         AGO   .RET\n.NOB     ANOP\n         AIF   (&B).ERROR2              DUP OPTION\n&B       SETB  1                        BREAK OPTION SPECIFIED\n         AGO   .RET\n.INFOR   ANOP                                                  RTS02A1\n         AIF   (&P).ERROR2              DUP OPTION             RTS02A1\n&P       SETB  1                   PUTLINE OPTION SPECIFIED    RTS02A1\n         AGO   .RET\n.DATA    ANOP                                                  RTS02A1\n         AIF   (&P).ERROR2              DUP OPTION             RTS02A1\n&P       SETB  1                  PUTLINE OPTION SPECIFIED     RTS02A1\n&POPT    SETA  X'30'              SET SINGLE DATA LINE         RTS02A1\n.RET     ANOP\n&PARM    SETC  '&WAIT'\n         AIF   ('&RET' EQ '1').CKPARM   CHECK WAIT\n&PARM    SETC  '&HOLD'\n         AIF   ('&RET' EQ '2').CKPARM   CHECK HOLD\n&PARM    SETC  '&BRKI'\n         AIF   ('&RET' EQ '3').CKPARM   CHECK BRKI\n&PARM    SETC  '&INFOR'                                        RTS02A1\n         AIF   ('&RET' EQ '4').CKPARM   CHECK INFOR/DATA       RTS02A1\n         AIF   (&POPT NE 0).NOHELP                             RTS02A1\n         AIF   ('&HELP' EQ '').ONELEV                          RTS02A1\n&POPT    SETA  X'04'                                           RTS02A1\n         AIF   ('&@ENTRY' NE 'UPUT').CHKREG                    RTS02A1\n&POPT    SETA  &POPT+X'02'                                     RTS02A1\n         AGO   .CHKREG                                         RTS02A1\n.ONELEV  AIF   (NOT &P AND '&MF(1)' EQ 'E').NOHELP             RTS02A1\n&POPT    SETA  X'10'                                           RTS02A1\n         AIF   ('&@ENTRY' NE 'UPUT').CHKREG                    RTS02A1\n&POPT    SETA  &POPT+X'02'                                     RTS02A1\n         AGO   .CHKREG                                         RTS02A1\n.NOHELP  AIF   ('&HELP' EQ '').CHKREG                          RTS02A1\n         MNOTE 4,'HELP IGNORED WHEN DATA OPTION USED'          RTS02A1\n         AGO   .CHKREG                  DONE WITH OPTIONS\n.MFL     ANOP                                                  RTS02A1\n         AIF   ('&BFF' EQ '').BFFOK                            RTS02A1\n         AIF   ('&BFF'(1,1) EQ '(').LREG                       RTS02A1\n.BFFOK   AIF   ('&SIZE' EQ '').SIZEOK                          RTS02A1\n         AIF   ('&SIZE'(1,1) EQ '(').LREG                      RTS02A1\n.SIZEOK  AIF   ('&HELP' EQ '').HELPOK                          RTS02A1\n         AIF   ('&HELP(1)' EQ '').HELP1OK                      RTS02A1\n         AIF   ('&HELP(1)'(1,1) EQ '(').LREG                   RTS02A1\n.HELP1OK AIF   ('&HELP(2)' EQ '').HELPOK                       RTS02A1\n         AIF   ('&HELP(2)'(1,1) NE '(').HELPOK                 RTS02A1\n.LREG    IHBERMAC 69                                           RTS02A1\n         MEXIT                                                 RTS02A1\n.HELPOK  AIF   ('&CPPL' EQ '' AND '&IOPL' EQ '').NOCPPL        RTS02A1\n         MNOTE 4,'UPUT002 CPPL/IOPL OPERAND IGNORED WHEN MF=L' RTS02A1\n.NOCPPL  ANOP                                                  RTS02A1\n&PARM    SETC  '&EDIT'                                         RTS02A1\n         AGO   .CKPARM                                         RTS02A1\n.GENE    ANOP                                                  RTS02A1\n&NAME    DS    0H                                              RTS02A1\n         AIF   ('&@ENTRY' EQ 'UPUT').PUTEX                     RTS02A1\n         AIF   ('&MF(2)'(1,1) EQ '(').PRER                     RTS02A1\n         LA    1,4+&MF(2)         ADDR PROMPT PARM LIST        RTS02A1\n         AGO   .JEX                                            RTS02A1\n.PRER    LA    1,4&MF(2)          ADDR PROMPT PARM LIST        RTS02A1\n         AGO   .JEX                                            RTS02A1\n.PUTEX   ANOP                                                  RTS02A1\n         AIF   ('&BFF' NE '(1)').NER1                          RTS02A1\n         LR    15,1               COPY MSG ADDR TO 15          RTS02A1\n.NER1    IHBINNRA &MF(2)                                       RTS02A1\n.JEX     AIF   (&POPT EQ 0).ENOPOPT                            RTS02A1\n         MVI   1(1),&POPT         STORE PUTLINE OPTIONS        RTS02A1\n.ENOPOPT AIF   ('&SIZE' EQ '').ENOSIZ                          RTS02A1\n         AIF   ('&SIZE' EQ '*').STARSIZ                        RTS02A1\n         AIF   ('&SIZE'(1,1) EQ '(').RSIZ                      RTS02A1\n         LA    14,&SIZE                                        RTS02A1\n         STH   14,2(1)           STORE MSG LENGTH IN PARM LIST RTS02A1\n         AGO   .ENOSIZ                                         RTS02A1\n.RSIZ    STH   &SIZE(1),2(1)     STORE MSG LENGTH IN PARM LIST RTS02A1\n         AGO   .ENOSIZ                                         RTS02A1\n.STARSIZ AIF   ('&BFF' EQ '*' OR '&BFF' EQ '').ENOSIZ          RTS02A1\n         AIF   ('&BFF'(1,1) EQ '(').ENOSIZ                     RTS02A1\n         LA    14,&L&BFF          GET LENGTH OF MESSAGE        RTS02A1\n         STH   14,2(1)            STORE IN PARM LIST           RTS02A1\n.ENOSIZ  AIF   (NOT (&E OR &W OR &H OR &B)).ENOPT              RTS02A1\n         MVI   4(1),&OPT          STORE TPUT OPTIONS           RTS02A1\n.ENOPT   AIF   ('&BFF' EQ '' OR '&BFF' EQ '*').ENOBFF          RTS02A1\n         AIF   ('&BFF'(1,1) EQ '(').ERBFF                      RTS02A1\n         LA    14,&BFF                                         RTS02A1\n         STCM  14,7,5(1)        STORE BUFFER ADDR IN PARM LIST RTS02A1\n         AGO   .ENOBFF                                         RTS02A1\n.ERBFF   AIF   ('&BFF' NE '(1)').ERN1                          RTS02A1\n         STCM  15,7,5(1)        STORE MSG ADDRESS IN PARM LIST RTS02A1\n         AGO   .ENOBFF                                         RTS02A1\n.ERN1    STCM  &BFF(1),7,5(1)   STORE MSG ADDRESS IN PARM LIST RTS02A1\n.ENOBFF  AIF   ('&HELP' EQ '').ENOHELP                         RTS02A1\n         AIF   ('&HELP(1)' EQ '').EGHELP                       RTS02A1\n         AIF   ('&HELP(1)'(1,1) EQ '(').ERH1                   RTS02A1\n         LA    14,&HELP(1)                                     RTS02A1\n.EGHELP  ST    14,12(1)           STORE HELP MSG ADDR          RTS02A1\n         AGO   .EHELP2                                         RTS02A1\n.ERH1    ST    &HELP(1),12(1)     STORE HELP MSG ADDR          RTS02A1\n.EHELP2  AIF   ('&HELP(2)' EQ '').EDH2                         RTS02A1\n         AIF   ('&HELP(2)'(1,1) EQ '(').ERH2                   RTS02A1\n         LA    14,&HELP(2)                                     RTS02A1\n         ST    14,8(1)            STORE HELP MSG LENGTH        RTS02A1\n         AGO   .ENOHELP                                        RTS02A1\n.ERH2    ST    &HELP(2),8(1)      STORE HELP MSG LENGTH        RTS02A1\n         AGO   .ENOHELP                                        RTS02A1\n.EDH2    AIF   ('&HELP(1)' EQ '').ENOHELP                      RTS02A1\n         AIF   ('&HELP(1)'(1,1) EQ '(').ENOHELP                RTS02A1\n         LA    14,&L&HELP(1)                                   RTS02A1\n         ST    14,8(1)            STORE HELP MSG LENGTH        RTS02A1\n.ENOHELP AIF   ('&@ENTRY' NE 'UPUT').GEND                      RTS02A1\n         AGO   .LDCPPL                                         RTS02A1\n.RERR    IHBERMAC 192\n         MEXIT\n.ERROR1  IHBERMAC 24\n         MEXIT\n.ERROR2  IHBERMAC 54,,,\n         MEXIT\n.ERROR3  IHBERMAC 49,,&PARM\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XSEND": {"ttr": 13063, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    ERROR &TEXT,&EXIT\n&NAME    UPUT  ERR&SYSNDX-1,L'ERR&SYSNDX+1,INFOR,CPPL=$CPPL       MVS\n         MVI   RCODE+1,12         INDICATE ERROR TO CALLER        MVS\n         B     &EXIT\n         DC    C' '                                               MVS\nERR&SYSNDX DC C&TEXT\n         MEND\nXSND     TITLE 'XSEND -- EXTENDED \"SEND\" COMMAND'\nXSEND    SAVEX LV=WORKLEN                                         MVS\n         SPACE 3\nON       EQU   X'FF'\nOFF      EQU   X'00'\nHIGHP    EQU   X'20'                                              MVS\nNOWAIT   EQU   X'10'                                              MVS\nBREAKIN  EQU   X'04'                                              MVS\n$1       EQU   R4\n$2       EQU   R5\nTEXTADDR EQU   R6\nECBLIST  EQU   R6                                                 MVS\nTEXTLEN  EQU   R7\nBUSY     EQU   R7                                                 MVS\nECB      EQU   R7                                                 MVS\nTABLPNTR EQU   R8\nTABLLEN  EQU   R9\nTABLBASE EQU   R10\n         EJECT\n***********************************************************************\n*        THIS IS THE ICSA XSEND COMMAND. NOTEWORTHY FEATURES:         *\n*              (A) THE ABILITY TO INFORM A NOINTERCOM USER OF AN      *\n*        ATTEMPT TO COMMUNICATE THROUGH USE OF AN SVC (XTPUT)         *\n*        TO SEND \"BELLS\" AT HIGH PRIORITY.                            *\n*              (B) THE ABILITY TO REQUEST EXIT FROM A \"WAIT\" SEND     *\n*        OPERATION, EITHER AT THE END OF A SPECIFIED NUMBER OF        *\n*        SECONDS OR UPON RECEIPT OF AN ATTENTION.                     *\n***********************************************************************\n         SPACE\n         USING WORKAREA,R13        DECLARE BASE FOR WORK AREA\n         MVI   TPUTPARM,NOWAIT    DEFAULT TPUT PARMS              MVS\n         LM    R1,R4,0(R1)         LOAD PARAMETERS\n         STM   R1,R4,$CPPL         STORE IN LOCAL COPIES\n         LA    R5,$CPPL           SET UP ADDRESSABILITY           MVS\n         LA    R6,$PPL                                            MVS\n         USING CPPL,R5                                            MVS\n         USING PPL,R6                                             MVS\n         ST    R1,PPLCBUF          STORE CBUF POINTER IN PPL\n         ST    R2,PPLUPT           STORE UPT POINTER IN PPL\n         ST    R4,PPLECT           STORE ECT POINTER IN PPL\n         XC    PECB,PECB           CLEAR EVENT CONTROL BLOCK      MVS\n         LA    R1,PECB             POINT TO ECB                   MVS\n         ST    R1,PPLECB           STORE POINTER TO ECB IN PPL\n         L     R1,=A(PCL)          POINT TO PARSE CONTROL BLOCK\n         ST    R1,PPLPCL           STORE PCL POINTER IN PPL\n         LA    R1,ANS              POINT TO PDL LOCATION HOLDER\n         ST    R1,PPLANS           STORE POINTER IN PPL\n         LA    R1,PPL              POINT TO PARSE PARM LIST\n         DROP  R5,R6                                              MVS\n         CALLTSSR EP=IKJPARS      CALL UP TSO PARSE               MVS\n         LTR   R15,R15             DID IT GO OK?\n         BNZ   PARSFAIL            NO, ERROR\n         L     R1,CVTPTR           -> CVT                         MVS\n         L     R1,CVTASVT-CVTMAP(R1)   ->ASVT                     MVS\n         USING ASVT,R1                                            MVS\n         MVC   $ASCBNUM,ASVTMAXU+2     SAVE MAX # OF ADDR SPACES  MVS\n         LA    R1,ASVTFRST                                        MVS\n         ST    R1,$ASCB1          SAVE ADDR OF 1ST ENTRY          MVS\n         DROP  R1                                                 MVS\n         L     R11,ANS             PICK UP PDL ADDRESS\n         USING PDL,R11             DECLARE BASE FOR IT\n         CLI   $BELL+1,2          FLASH?                          MVS\n         BNE   NOFLASH            NO.                             MVS\n         OI    TPUTPARM,HIGHP     YES, ADD HIGHP TO FLAGS         MVS\nNOFLASH  CLI   $INTRUPT+1,1       INTERRUPT?                      MVS\n         BNE   NOIRUPT            NO                              MVS\n         OI    TPUTPARM,BREAKIN   YES, SET TPUT FLAG              MVS\nNOIRUPT  DS    0H                                                 MVS\n         L     TEXTADDR,$WHAT      LOAD TEXT POINTER\n         LH    TEXTLEN,$WHAT+4     LOAD TEXT LENGTH\n         LH    R1,$WHICH           GET SEND TYPE\n         SLL   R1,2                *4 FOR TABLE OFFSET\n         B     *(R1)               BRANCH INTO TABLE\n         B     $USER               GO TO USER-LIST SUB.\n         B     $ALL                GO TO ALL-USERS SUB.\n         B     $OPER               GO TO WTO SUBR.\n         SPACE\n***********************************************************************\n*        ALLOCATE AN INFORMATION TABLE WITH AN ENTRY FOR EACH         *\n*        DESTINATION USERID. DETERMINE THE USER'S ASID AND STORE IT IN*\n*        THE TABLE ENTRY.                                             *\n***********************************************************************\n         SPACE\n$USER    DS    0H\n         LA    TABLLEN,16          LOAD MIN LENGTH TABLE          MVS\n         L     R1,$WHO+8           LOAD CHAIN TO SECOND USERID    MVS\n$UL1     DS    0H\n         LTR   R1,R1               END OF CHAIN?\n         BM    $UX1                YES, EXIT LOOP1\n         LA    TABLLEN,16(,TABLLEN) INCERMENT TABLE LENGTH        MVS\n         L     R1,8(,R1)           STEP TO NEXT ENTRY             MVS\n         B     $UL1                LOOP FOR NEXT USERID\n$UX1     DS    0H\n         ST    TABLLEN,$LENGTH     SAVE LENGTH FOR FREEMAIN       MVS\n         GETMAIN R,LV=(TABLLEN)    GET ENOUGH CORE                MVS\n         ST    R1,$ADDRESS         SAVE ADDRESS FOR FREEMAIN\n         LR    TABLBASE,R1         POINT TO FIRST ENTRY\n         LA    $1,$WHO             POINT TO FIRST ENTRY\n         LR    $2,TABLBASE         POINT TO FIRST ENTRY\n$UL2     DS    0H\n         USING TABLSECT,$2                                        MVS\n         MVC   TABLUSER,=CL7' '     CLEAR USERID                  MVS\n         L     R1,0($1)            LOAD USERID POINTER\n         LH    R0,4($1)            LOAD USERID LENGTH\n         BCTR  R0,0                MAKE IT MVC-FORM\n         STC   R0,*+5              INSERT INTO:\n         MVC   TABLUSER(0),0(R1)       MOVE IN USERID             MVS\n         L     R1,$ASCB1           LOAD POINTER TO ASCB TABLE     MVS\n         LH    R0,$ASCBNUM         LOAD NUMBER OF ENTRIES         MVS\n$UL3     DS    0H\n         TM    0(R1),X'80'        THIS ASID EXIST?                MVS\n         BNZ   $UA3                                               MVS\n         L     R14,0(,R1)         YES, FIND ASCB                  MVS\n         USING ASCB,R14                                           MVS\n         CLC   ASCBTSB,=F'0'      TSO ADDR SPACE?                 MVS\n         BE    $UA3               NO.                             MVS\n         L     R15,ASCBJBNS       YES, FIND JOBNAME=USERID        MVS\n         CLC   TABLUSER,0(R15)    THE ONE WANTED?                 MVS\n         BE    $UX3               YES                             MVS\n$UA3     DS    0H                                                 MVS\n         LA    R1,4(,R1)          SKIP TO NEXT ASVT ENTRY         MVS\n         BCT   R0,$UL3                                            MVS\n         MVI   TABLSTAT,X'14'     FLAG 'NOT ON TSO'               MVS\n         B     $UP3               USERID NOT FOUND                MVS\n$UX3     DS    0H\n         MVI   TABLSTAT,X'04'     INIT FLAGS TO \"BUSY\"            MVS\n         MVC   TABLASID,ASCBASID  SAVE THE USER'S ASID            MVS\n$UP3     DS    0H\n         LA    $2,16(,$2)          STEP TO NEXT TABLE ENTRY       MVS\n         L     $1,8(,$1)           STEP TO NEXT USERID            MVS\n         LTR   $1,$1               IS THERE ONE?\n         BP    $UL2                YES, LOOP FOR IT\n         B     $GO                 GO TO FEG'S CODE\n         DROP  $2\n         SPACE\n***********************************************************************\n*        ALLOCATE AN INFORMATION TABLE WITH AN ENTRY FOR EACH POSSIBLE*\n*        TSO USER. FIND THE USERIDS AND ASID'S FOR CURRENT USERS      *\n*        AND STORE THEM IN THE TABLE ENTRIES.                         *\n***********************************************************************\n         SPACE\n$ALL     DS    0H\n         LH    R0,$ASCBNUM         PICK UP MAX NUM. OF ASIDS      MVS\n         MH    R0,=H'16'           TIMES ENTRY LENGTH             MVS\n         ST    R0,$LENGTH          SAVE LENGTH FOR FRREMAIN\n         GETMAIN R,LV=(0)          GET ENOUGH CORE FOR ALL USERS\n         ST    R1,$ADDRESS         SAVE ADDRESS FOR FREEMAIN\n         LR    TABLBASE,R1         POINT TO FIRST ENTRY\n         SLR   TABLLEN,TABLLEN     ZERO TABLE LENGTH\n         L     $1,$ASCB1          POINT TO FIRST ASVT ENTRY       MVS\n         LH    R15,$ASCBNUM        LOAD NUMBER OF ASID'S          MVS\n$AL1     DS    0H\n         USING TABLSECT,R1                                        MVS\n         TM    0($1),X'80'        THIS ASID ACTIVE?               MVS\n         BNZ   $AP1                NO, SKIP THIS ONE              MVS\n         L     R14,0(,$1)         YES, FIND ASCB                  MVS\n         USING ASCB,R14                                           MVS\n         CLC   ASCBTSB,=F'0'      TSO ADDR SPACE?                 MVS\n         BE    $AP1               NO.                             MVS\n         L     $2,ASCBJBNS        YES, FIND JOBNAME=USERID        MVS\n         LTR   $2,$2              IS JOBNAME 0?                   MVS\n         BZ    $AP1               YES, SKIP IT                    MVS\n         MVC   TABLUSER,0($2)      INSERT USERID                  MVS\n         MVI   TABLSTAT,X'04'     SET STAT TO \"BUSY\"              MVS\n         MVC   TABLASID,ASCBASID   INSERT ASID                    MVS\n         DROP  R14                                                MVS\n         LA    R1,16(,R1)          STEP TO NEXT TABLE ENTRY       MVS\n         LA    TABLLEN,16(,TABLLEN) INCREMENT TABLE LENGTH        MVS\n         DROP  R1                                                 MVS\n$AP1     DS    0H\n         LA    $1,4(,$1)          STEP TO NEXT ASVT ENTRY         MVS\n         BCT   R15,$AL1            LOOP IF MORE ASID'S            MVS\n         B     $GO                 GO TO FEG'S CODE\n$OPER    ERROR '\"OPER\" OPERAND NOT YET IMPLEMENTED',RLSA\n         SPACE\n***********************************************************************\n*        BUILD THE MESSAGE TO BE SENT. THE SENDING USERID IS APPENDED *\n*        TO THE END OF THE MESSAGE. IF BELL OR FLASH IS SPECIFIED,    *\n*        ADD *ATTN* TO THE FRONT OF THE MESSAGE FOR TERMINALS WHERE   *\n*        BELLS/ALARMS ARE NOT SUPPORTED.                              *\n***********************************************************************\n         SPACE\n$GO      DS    0H\n         USING TABLSECT,TABLBASE .      *ESTABLISH BASE REGISTER\n         SLR   TABLPNTR,TABLPNTR .      *DO I=0 TO TABLLEN\n         LA    R3,TPBUFFER        WHERE TO BUILD MESSAGE          MVS\n         CLI   $BELL+1,0          BELL/FLASH?                     MVS\n         BE    NOATTN             NO.                             MVS\n         MVC   0(7,R3),=C'*ATTN* '     YES, ADD ATTN FOR NON-TWX  MVS\n         LA    R3,7(,R3)          PUT MSG TEXT AFTER              MVS\nNOATTN   DS    0H                                                 MVS\n         C     TEXTLEN,=F'235' .        *MAX LENGTH IS 235 BYTES  MVS\n         BNH   NOTRUNC                                            MVS\n         UPUT  TRUNC235,L'TRUNC235,INFOR,CPPL=$CPPL               MVS\n         MVI   RCODE+1,4          SET WARNING INDICATOR           MVS\n         LA    TEXTLEN,235        PUT MAX IN TEXTLEN              MVS\nNOTRUNC  DS    0H                                                 MVS\n         BCTR  TEXTLEN,0                                          MVS\n         EX    TEXTLEN,TXTMOVE .        *MOVE MSG TEXT TO BUFFER\n         LA    R2,1(TEXTLEN,R3)     . *LOAD ADDRESS FOR USERID    MVS\n         MVC   0(2,R2),=C'--'     SEPARATE USERID FROM TEXT       MVS\n         L     R3,CPPLPSCB-CPPL+$CPPL   *GET PSCB ADDRESS....     MVS\n         MVC   2(7,R2),0(R3) . *...AND INSERT USERID IN MSG       MVS\n         LA    TEXTADDR,TPBUFFER . *...AND POINTER TEXTADDR TO BUFFER\n         LA    TEXTLEN,8(,R2)     COMPUTE FULL MSG LEN            MVS\nTRIM     CLI   0(TEXTLEN),C' '    IGNORING TRAILING BLANKS        MVS\n         BNE   TRIMD                                              MVS\n         BCT   TEXTLEN,TRIM       SO XTPUT WILL SEE USERID        MVS\nTRIMD    LA    TEXTLEN,1(,TEXTLEN)     POINT PAST MSG END         MVS\n         SR    TEXTLEN,TEXTADDR                                   MVS\n         B     MSGLOOP0 .               *AND CONTINUE PROCESSING  MVS\nTXTMOVE  MVC   0(0,R3),0(TEXTADDR)     . *MVC TO VAR MOVE         MVS\n         SPACE\n***********************************************************************\n*        ATTEMPT TO SEND THE MESSAGE TO EACH USER NOWAIT, EVEN IF     *\n*        THE WAIT KEYWORD WAS SPECIFIED. THIS LETS US GO THROUGH THE  *\n*        OVERHEAD OF OUR WAIT PROCESSING FOR AS FEW USERS AS POSSIBLE.*\n*        IF NOWAIT WAS SPECIFIED, WE MAKE A SECOND TRY TO SEND TO ANY *\n*        \"BUSY\" USER BEFORE GIVING UP.                                *\n***********************************************************************\n         SPACE\nMSGLOOP0 DS    0H                                                 MVS\n         ST    TEXTLEN,PUTPLIST   SAVE TPUT LENGTH                MVS\n         MVC   PUTPLIST(1),$BELL+1     SAVE BELL FLAG             MVS\n         STAX  IGNORE,DEFER=YES   DON'T LET ATTN INTERFERE        MVS\n         LOAD  EP=XSENDPUT        LOAD TPUT ROUTINE               MVS\n         ST    R0,PUTADDR         STORE ENTRY POINT ADDR          MVS\n         SR    BUSY,BUSY          ZERO COUNT OF BUSY USERS        MVS\nMSGLOOP1 CR    TABLPNTR,TABLLEN .       *\n         BNL   TRYWAIT  .               *                         MVS\n         LA    R3,TABLSTAT(TABLPNTR) .  *CHECK ASID STATUS        MVS\n         CLI   0(R3),X'14' .            *IS THIS USER ON?         MVS\n         BE    MSGLOOP2 .               *NO,...CONTINUE           MVS\n         LA    R2,TABLASID(TABLPNTR) .  *GET ADDRESS OF ASID      MVS\n         LA    R1,PUTPLIST        POINT R1-TPUT PARMS             MVS\n         L     R15,PUTADDR        CALL TPUT ROUTINE               MVS\n         BALR  R14,R15                                            MVS\n         CH    R15,=H'4'          WAS IT NOWAIT?                  MVS\n         BNE   MSGLOOP2           NO, PROCEED                     MVS\n         LA    BUSY,1(,BUSY)      YES, INCREASE BUSY COUNT        MVS\n         CLI   $HOW+1,2           XSEND WAIT?                     MVS\n         BE    MSGLOOP2           YES, CONTINUE NOWAIT            MVS\n         LA    R1,PUTPLIST        NO, RELOAD TPUT PARMS           MVS\n         L     R15,PUTADDR        TRY TO SEND MSG AGAIN           MVS\n         BALR  R14,R15                                            MVS\nMSGLOOP2 LA    TABLPNTR,16(,TABLPNTR) . *GO TO NEXT ASID          MVS\n         B     MSGLOOP1 .               *...AND CONINUE\n         SPACE\n***********************************************************************\n*        IF WAIT WAS SPECIFIED, AND ONE OR MORE USERS WERE BUSY, WE   *\n*        NOW TRY AGAIN SPECIFYING WAIT. TO PERMIT THE TPUT'S TO       *\n*        PROCEED INDEPENDENTLY, WE ATTACH A SEPARATE TASK TO SEND     *\n*        TO EACH REMAINING USER. TO ALLOW TIME-OUT OR ATTN-OUT        *\n*        OF THE WAIT, WE ESTABLISH A TIMER EXIT TO CHECK FOR          *\n*        ATTENTION OR TOO MUCH WAIT TIME. IN EITHER CASE, THE         *\n*        TIMER EXIT WILL DETACH ANY INCOMPLETE SUBTASKS SO WE         *\n*        CAN TERMINATE.                                               *\n***********************************************************************\n         SPACE\nTRYWAIT  DS    0H                                                 MVS\n         CLI   $HOW+1,2           WILLING TO WAIT?                MVS\n         BNE   PRNTRSLT           NO, STOP NOW                    MVS\n         LTR   BUSY,BUSY          YES, ANYONE TO WAIT FOR         MVS\n         BZ    PRNTRSLT           NO, GIVE REPORT                 MVS\n         NI    TPUTPARM,255-NOWAIT     YES, OFF NOWAIT FLAG       MVS\n         TM    $HOWLONG+6,X'80'   WAIT INTERVAL PRESENT?          MVS\n         BZ    NOINT              NO, INDEFINITE WAIT ALLOWED     MVS\n         L     R2,$HOWLONG        YES, FIND DIGITS                MVS\n         CLI   $HOWLONG+5,1       1 DIGIT?                        MVS\n         BE    SHORTINT           YES.                            MVS\n         PACK  DWORK,0(2,R2)      NO, CONVERT 2                   MVS\n         B     CONVERT                                            MVS\nSHORTINT PACK  DWORK,0(1,R2)                                      MVS\nCONVERT  CVB   R2,DWORK           GET SECONDS IN BINARY           MVS\n         SRA   R2,1               DIVIDE BY 2 SEC.                MVS\n         BNZ   *+8                CHECK FOR 0                     MVS\n         LA    R2,1               REPLACE BY 1 IF SO              MVS\n         STH   R2,INTERVAL        STORE FOR EXIT                  MVS\nNOINT    DS    0H                                                 MVS\n         LA    R0,1(,BUSY)        GET AN ECB LIST                 MVS\n         SLL   R0,2               COMPUTE SIZE                    MVS\n         GETMAIN R,LV=(0)                                         MVS\n         ST    BUSY,0(,R1)        STORE NUMBER OF ENTRIES         MVS\n         LR    ECB,R1             SAVE LIST ADDR                  MVS\n         LR    ECBLIST,R1         TWICE                           MVS\n         SLR   TABLPNTR,TABLPNTR  DO TABLPNTR=0 TO TABLLEN        MVS\nWTLOOP1  DS    0H                                                 MVS\n         LA    R2,TABLSTAT(TABLPNTR)   THIS USER RESOLVED?        MVS\n         CLI   0(R2),X'04'                                        MVS\n         BNE   WTLOOP2            YES.                            MVS\n         LA    R2,TABLASID(TABLPNTR)   NO, FIND ASID              MVS\n         LA    R3,TABLSTAT(TABLPNTR)   POINT R3 TO RCODE SLOT     MVS\n         LA    R5,TABLECB(TABLPNTR)    FIND HIS ECB               MVS\n         XC    0(4,R5),0(R5)      CLEAR IT                        MVS\n         LA    R1,PUTPLIST        ADDR XSENDPUT PARMS             MVS\n         ATTACH EP=XSENDPUT,ECB=(R5),ETXR=DETACHER    CREATE SUBTASK   *\n                                  TO WAIT FOR TPUT                MVS\n         ST    R5,4(,ECB)         STORE ECB ADDR IN LIST          MVS\n         LA    ECB,4(,ECB)        BUMP ECB POINTER                MVS\nWTLOOP2  DS    0H                                                 MVS\n         CR    TABLPNTR,TABLLEN   LOOKED AT ALL USERS?            MVS\n         BNL   WAITER             YES, NOW WAIT                   MVS\n         LA    TABLPNTR,16(TABLPNTR)   NO, CONTINUE               MVS\n         B     WTLOOP1                                            MVS\nWAITER   DS    0H                                                 MVS\n         OI    0(ECB),X'80'       SET ECBLIST END BIT             MVS\n         STIMER REAL,ATTNCHK,BINTVL=TWOSEC  START 2 SECOND TIMER  MVS\n         L     R0,0(,ECBLIST)     LOAD NUMBER OF ECBS             MVS\n         LA    R1,4(,ECBLIST)     POINT TO START OF LIST          MVS\n         WAIT  (0),ECBLIST=(1)    WAIT FOR TASKS TO END           MVS\n         TTIMER CANCEL            CANCEL OUTSTANDING INTERVAL     MVS\n         LR    R1,ECBLIST         RETURN ECB LIST MEMORY          MVS\n         LA    R0,1                                               MVS\n         A     R0,0(,ECBLIST)                                     MVS\n         SLL   R0,2                                               MVS\n         FREEMAIN R,LV=(0),A=(1)                                  MVS\n         SPACE\n***********************************************************************\n*        REPORT ON THE RESULTS, GIVING FOR EACH ABNORMAL TPUT         *\n*        RESULT THE LIST OF USERIDS AFFECTED. AFTER THE REPORT IS     *\n*        COMPLETE, ALLOW ATTENTIONS AND RETURN.                       *\n***********************************************************************\n         SPACE\nPRNTRSLT DS    0H .                     *MESSAGE PRINTER\n         SLR   R3,R3 .                  *CLEAR RETC COUNTER\n         SLR   R4,R4 .                  *THIS IS A WORK REGISTER\nERRLOOP1 LA    R2,TPBUFFER .            *GET ADDRESS OF TPUT BUFFER\n         LA    R3,4(,R3) .              *GO TO NEXT TPUT RC\n         C     R3,=X'00000014' .       *HAVE WE REACCH ED END\n         BH    SCMMDEND .               *IF YES,...TERMINATE CP\n         MVI   0(R2),X'40'              *BLANK OUT THE BUFFER\n         MVC   1(63,R2),0(R2)           *CLEAR BUFFER\n         MVI   INHIBIT,X'00'           *CLEAR INHIBIT FLAGS       MVS\n         SLR   TABLPNTR,TABLPNTR .      *DO FOR ALL ASIDS         MVS\nERRLOOP4 CR    TABLPNTR,TABLLEN .             *\n         BNL   ERRLOOP2 .               *IF WE EXCEEDED TABLE...\n         IC    R4,TABLSTAT(TABLPNTR) .  *GET TJID STATUS\n         CR    R3,R4 .                  *IS THIS AN INSTANCE OF ERRCD\n         BNE   ERRLOOP3                 *NO,...SKIP IT\n         CLI   INHIBIT,X'FF'           *INHIBIT?                  MVS\n         BE    ERRLOOP6                 *YES,...SKIP PRINT\n         L     R1,TPADDR(R3)            *LOAD TEXT ADDRESS\n         UPUT  (1),42,INFOR,CPPL=$CPPL PRINT MESSAGE              MVS\n         MVI   INHIBIT,X'FF'           *INHIBIT MESSAGE           MVS\n         MVI   RCODE+1,8          SET TROUBLE RET CODE            MVS\nERRLOOP6 C     R2,=A(TPBUFFER+64)         *IS THE MESSAGE FULL?\n         BL    ERRLOOP5                   *NO,...CONTINUE\n         UPUT  TPBUFFER,64,INFOR,CPPL=$CPPL PRINT MESSAGE         MVS\n         LA    R2,TPBUFFER                *REINITIALIZE POINTER\n         MVI   0(R2),X'40'                *BLANK OUT BUFFER\n         MVC   1(63,R2),0(R2)             *\nERRLOOP5 LA    R5,TABLUSER(TABLPNTR)    *POINT TO USERID\n         MVC   1(7,R2),0(R5)            *INSERT USER IN BUFFER    MVS\n         MVI   0(R2),X'40' .            *INSERT LEADING BLANK     MVS\n         LA    R2,8(,R2) .              *...AND INCREMENT POINTER\nERRLOOP3 LA    TABLPNTR,16(,TABLPNTR) . *TRY NEXT ASID-USER PAIR  MVS\n         B     ERRLOOP4  .              *...AND CONTINUE INNER LOOP\nERRLOOP2 S     R2,=A(TPBUFFER) .        *COMPUTE LENGTH OF FAILING\n         BZ    ERRLOOP1 .               *YES...CONTINUE\n         UPUT  TPBUFFER,(R2),INFOR,CPPL=$CPPL    WRITE TO SENDER  MVS\n         B     ERRLOOP1 .               *...AND CONTINUE\n         DROP  TABLBASE .               *FREE BASE REGISTER\nSCMMDEND DS    0H                       .TERMINATE CP\n         STAX  DEFER=NO           LET ATTENTION TAKE EFFECT       MVS\n$FREE    DS    0H\n         L     R1,$ADDRESS         LOAD ADDRESS OF CORE TABLE\n         L     R0,$LENGTH          LOAD LENGTHS OF CORE TABLE\n         FREEMAIN R,LV=(0),A=(1)   FREE CORE TABLE\nRLSA     IKJRLSA ANS               RELEASE SPACE FOR PDE\n         LH    R15,RCODE          LOAD RETURN CODE                MVS\n         RETURNX RC=(15)                                          MVS\nPARSFAIL MVI   RCODE+1,12         SET WORST RETURN CODE           MVS\n         CH    R15,=H'4'          PROMPT ERROR?                   MVS\n         BE    FLUSH              YES, NO MSG NEEDED              MVS\n         ERROR 'PARSE FAILURE',FLUSH                              MVS\nFLUSH    STACK PARM=DELALL,MF=(E,$PPL) FLUSH TSO STACK            MVS\n         B     RLSA                                               MVS\n         EJECT\nIGNORE   BR    R14                DUMMY ROUTINE TO IGNORE ATTN    MVS\n         SPACE 3\nDETACHER DS    0H                 ETXR ROUTINE TO DETACH TASK     MVS\n         DROP  ,                                                  MVS\n         STM   R14,R12,12(R13)    SAVE REGS                       MVS\n         LA    R1,24(,R13)        POINT TO R1 SAVE SLOT           MVS\n         DETACH (1)               DETACH ENDED TASK               MVS\n         LM    R14,R12,12(R13)    RESTORE REGS                    MVS\n         BR    R14                AND RETURN                      MVS\n         SPACE 3\nATTNCHK  DS    0H                 TIMER EXIT TO CHECK ATTN        MVS\n         STM   R14,R12,12(R13)    SAVE REGS                       MVS\n         LR    R12,R15                                            MVS\n         USING ATTNCHK,R12                                        MVS\n         USING PSA,R0                                             MVS\n         L     R3,PSATOLD         FIND OUR TCB                    MVS\n         USING TCB,R3                                             MVS\n         ICM   R3,15,TCBLTC       FIND A SUBTASK                  MVS\n         BZ    TIMERET            IF NONE, CAN TERMINATE          MVS\n         CLI   TCBSTPCT,0         HAS IT BEEN STOPPED?            MVS\n         BNE   DETECTED           YES, ASSUME ATTN                MVS\n         LH    R4,INTERVAL        NO, IS WAIT TIME UP?            MVS\n         BCT   R4,*+8                                             MVS\n         B     DETECTED           YES, END IT                     MVS\n         STH   R4,INTERVAL        UPDATE TIME LEFT                MVS\n         STIMER REAL,ATTNCHK,BINTVL=TWOSEC  NO, WAIT 2 SECS MORE  MVS\nTIMERET  LM    R14,R12,12(R13)                                    MVS\n         BR    R14                RETURN TO SYSTEM                MVS\nDETECTED ST    R3,DETWORK         SAVE SUBTASK TCB ADDR           MVS\n         L     R3,TCBNTC          FIND NEXT SUBTASK TCB           MVS\n         DETACH DETWORK           KILL ORIGINAL TASK              MVS\n         LTR   R3,R3              ANY MORE SUBTASKS?              MVS\n         BNZ   DETECTED           YES, CONTINUE                   MVS\n         B     TIMERET            NO, LEAVE EXIT                  MVS\nDETWORK  DS    A                  DETACH WORK AREA                MVS\n         EJECT\nPUTPLIST DS    A                  TPUT REG 0 DATA                 MVS\nTPUTPARM DS    XL1     .                 *TPUT OPTION BITS        MVS\n         DC    AL3(TPBUFFER)      TPUT MESSAGE ADDR               MVS\nPUTADDR  DS    A                  ADDR OF TPUT ROUTINE            MVS\nTWOSEC   DC    F'200'             2 SECOND TIMER INTERVAL         MVS\nINTERVAL DS    H                  WAIT TIME ALLOWED               MVS\nINHIBIT  DS    XL1                      WORK FLAG FOR MSG PRINTER MVS\nRCODE    DC    H'0'               EVENTUAL RET CODE               MVS\nTPADDR   DC    A(0)                     *LIST OF TP MESSAGES\n         DC    A(TPBUSY) .              *TPUT RC 04\n         DC    A(TPSTAX) .              *STAX DURING TP\n         DC    A(TPNOIN) .              *PROFILE NOINTERCOM\n         DC    A(TPINVA) .              *INVALID TPUT PARAMETERS\n         DC    A(TPNOTON) .             *TJID NOT ON\nDELALL   STACK DELETE=ALL,MF=L    STACK FLUSH PARMS               MVS\nTPBUSY   DC    CL42' USER(S) BUSY, MESSAGE CANCELLED-'            MVS\nTPSTAX   DC    CL42' USER(S) CANCELLED MESSAGE-'                  MVS\nTPNOIN   DC    CL42' USER(S) NOT ACCEPTING MESSAGES-'             MVS\nTPINVA   DC    CL42' USER(S) FOULED UP-'                          MVS\nTPNOTON  DC    CL42' USER(S) NOT LOGGED ON, MESSAGE CANCELLED-'   MVS\nTRUNC235 DC    C' MESSAGE TRUNCATED TO 235 CHARACTERS.'           MVS\nTPBUFFER DC    CL256' '                 *TP BUFFER\n         LTORG\n         PRINT NOGEN\nPCL      IKJPARM DSECT=PDL\n$WHAT    IKJPOSIT QSTRING,ASIS,PROMPT='MESSAGE IN QUOTES'\n$HOW     IKJKEYWD DEFAULT='NOWAIT'\n         IKJNAME 'NOWAIT'\n         IKJNAME 'WAIT',SUBFLD=$WAITSF                            MVS\n$BELL    IKJKEYWD\n         IKJNAME 'BELL',ALIAS='ATTN'                              MVS\n         IKJNAME 'FLASH'                                          MVS\n$INTRUPT IKJKEYWD DEFAULT='NOINTERRUPT'                           MVS\n         IKJNAME 'INTERRUPT'                                      MVS\n         IKJNAME 'NOINTERRUPT'                                    MVS\n$WHICH   IKJKEYWD DEFAULT='USER'                                  MVS\n         IKJNAME 'USER',SUBFLD=$WHOSF\n         IKJNAME 'ALL'\n         IKJNAME 'OPER'\n$WHOSF   IKJSUBF\n$WHO     IKJIDENT 'USERID',LIST,FIRST=ALPHA,OTHER=ALPHANUM,MAXLNTH=7,  *\n               PROMPT='USERID(S) TO RECEIVE MESSAGE'              MVS\n$WAITSF  IKJSUBF\n$HOWLONG IKJIDENT 'WAIT INTERVAL',FIRST=NUMERIC,OTHER=NUMERIC,MAXLNTH=2*\n                                                                  MVS\n         IKJENDP\nTABLSECT DSECT\nTABLUSER DS    CL7                      *USERID ENTRY\nTABLSTAT DS    CL1                      *USERID - MESSAGE STATUS\nTABLECB  DS    A                  END OF SUBTASK ECB              MVS\nTABLASID DS    1H                       *ASID FOR THIS USERID     MVS\nWORKAREA DSECT\n         DS    18F                 O/S SAVE AREA\nDWORK    DS    D                                                  MVS\n$ADDRESS DS    A                   -> CORE TABLE\n$LENGTH  DS    A                   LENGTH OF CORE TABLE\n$ASCB1   DS    A                   -> FIRST ASVT ENTRY            MVS\n$ASCBNUM DS    H                   NUMBER OF ASIDS ALLOWED        MVS\nPECB     DS    F                   EVENT CONTROL BLOCK FOR ATTN   MVS\nANS      DS    A                   -> PDL FROM PARSE\n$CPPL    DS    4A                 SPACE FOR CPPL COPY             MVS\n$PPL     DS    7A                 SPACE FOR PPL COPY              MVS\nWORKLEN  EQU   *-WORKAREA                                         MVS\n         EJECT\n         IKJCPPL ,                                                MVS\n         SPACE\n         IKJPPL ,                                                 MVS\n         SPACE\n         PRINT NOGEN                                              MVS\n         CVT   DSECT=YES                                          MVS\n         SPACE\n         IHAPSA ,                                                 MVS\n         SPACE\n         IKJTCB ,                                                 MVS\n         SPACE\n         IHAASVT ,                                                MVS\n         SPACE\n         IHAASCB ,                                                MVS\n         SPACE 2\n         END   XSEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XSEND#": {"ttr": 13318, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": ")F FUNCTION -\n  The XSEND command is an enhanced version of the SEND command. It\n  can be used to ring the bell on an ASCII terminal.\n)X SYNTAX -\n         XSEND  ''text''  BELL/FLASH  WAIT\u00dd(interval)\u00a8/NOWAIT\n          USER(useridlist)  INTERRUPT/NOINTERRUPT\n  REQUIRED - ''text''  USER('useridlist')\n  DEFAULTS - NOWAIT, NOINTERRUPT\n  ALIAS    - XS\n)O OPERANDS -\n  ''text'' - Specifies the message to be sent.\n))BELL     - Indicates that the bell on an ASCII terminal is to be\n             rung.\n))FLASH    - Indicates that the bell on an ASCII terminal is to be\n             rung even if the user is receiving no messages. In such\n             a case only the bell is transmitted.\n))WAIT\u00dd(interval)\u00a8 -\n             Indicates that the message is to be sent to every\n             user on the USER list before the issuer may proceed.\n             One may specify the maximum interval he is willing to\n             wait (in seconds up to 99) with the \"interval\" operand.\n))NOWAIT   - Indicates that the message is to be cancelled for any\n             userid that is busy.\n))USER('useridlist') -\n             Specifies the userids of the recipients of the message.\n))INTERRUPT -\n             Specifies that if a target user is entering input\n             when the message is sent, he should be interrupted\n             so it can be written immediately.\n))NOINTERRUPT -\n             Specifies that a user active in input is not to be\n             interrupted. This is the default.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XSENDPUT": {"ttr": 13320, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "XSPT     TITLE 'XSENDPUT -- TPUT ROUTINE FOR XSEND COMMAND'\n***********************************************************************\n*        THIS ROUTINE IS CALLED BY THE XSEND COMMAND TO SEND A MESSAGE*\n*        TO ANOTHER USER. IT MAY BE CALLED AS A SUBROUTINE OR A       *\n*        SUBTASK. ON ENTRY, R1 ADDRESSES THE TPUT R0 AND R1 VALUES,   *\n*        R2 POINTS TO A HALFWORD TJID, AND R3 ADDRESSES A BYTE WHEREIN*\n*        THE TPUT RETURN CODE IS TO BE STORED. THIS CODE IS ALSO      *\n*        RETURNED IN R15. THE HIGH ORDER BYTE OF THE R0 VALUE         *\n*        CONTAINS A FLAG BYTE WHICH INDICATES WHETHER THE BELL OR     *\n*        FLASH OPERAND OF XSEND WAS SPECIFIED. IF NOT, TPUT IS USED;  *\n*        OTHERWISE, THE XTPUT SVC (WHICH SENDS BELLS AT HIGH PRIORITY *\n*        FOR FLASH) IS USED.                                          *\n***********************************************************************\n         SPACE\nXSENDPUT SAVEX LV=72,PARMR=R4\n         LM    R0,R1,0(R4)        LOAD TPUT REGS\n         ICM   R0,12,0(R2)        GET ASID INTO R0\n         CLI   0(R4),0            CHECK BELL FLAG\n         BE    TPUT               IF NO BELL OPERAND, USE TPUT SVC\n         SVC   238                ELSE USE XTPUT SVC\n         B     TPUTDONE\nTPUT     TPUT  (1),(0),R          SEND WITH TPUT IF NO BELLS\nTPUTDONE STC   R15,0(,R3)         STORE TPUT RETURN CODE\n         RETURNX RC=(15)          AND RETURN TO CALLER\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XTPUTSVC": {"ttr": 13322, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         TITLE 'SVC 238 -- EXTENDED TPUT FOR XSEND COMMAND'    RTS03A1\n***********************************************************************\n*        THIS SVC IS ISSUED BY THE XSEND COMMAND TO SEND MESSAGES     *\n*        PUNCTUATED BY BELL CHARACTERS (ON AN ASCII TERMINAL) OR THE  *\n*        SOUNDING OF A 3270 ALARM. IT IS A CALLER SPECIFIABLE OPTION  *\n*        WHETHER THE BELLS/ALARM SHOULD BE SENT AT HIGH-PRIORITY      *\n*        (THOUGH THE MESSAGE TEXT PROPER WILL NEVER BE SO SENT).      *\n*                                                                     *\n*        INPUT: TPUT PARAMETERS IN REGISTERS 0 & 1. ONLY A TPUT TO    *\n*               ASID IS ACCEPTABLE. FOR THE TPUT OF BELLS/ALARM, HOLD *\n*               AND BREAKIN ARE IGNORED. FOR THE TEXT TPUT, HIGHP     *\n*               AND HOLD ARE IGNORED, AND CONTROL IS CHANGED TO ASIS. *\n*                                                                     *\n*        OUTPUT: SAME AS TPUT RETURN CODE.                            *\n***********************************************************************\n         SPACE\nIGC238   CSECT ,                                               RTS03A1\n         SPACE\n         REGISTER ,                                            RTS03A1\n         USING IGC238,R6          STANDARD SVC BASE REGISTER   RTS03A1\n         USING CVTMAP,R3                                       RTS03A1\n         LR    R5,R14             SAVE THE RETURN ADDRESS      RTS03A1\n         LR    R9,R0              COPY THE LENGTH & ASID       RTS03A1\n         LTR   R11,R1             COPY BUFFER ADDR & OPTIONS   RTS03A1\n         BM    ERROR              ERROR IF TGET BIT SET        RTS03A1\n         SR    R8,R8              GET ASID TO R8               RTS03A1\n         SLDL  R8,16                                           RTS03A1\n         LR    R9,R0              RESTORE R9 FROM R0           RTS03A1\n         SR    R10,R10                                         RTS03A1\n         SLDL  R10,8              ISOLATE OPTION BITS          RTS03A1\n         LR    R11,R1             RESTORE ORIGINAL R11         RTS03A1\n         N     R11,=X'D7FFFFFF'   TURN OFF HIGHP & HOLD        RTS03A1\n         N     R10,=X'000000F0'   OFF HOLD/BREAK/EDIT FOR BELL RTS03A1\n         L     R7,CVTASVT         FIND THE ASVT                RTS03A1\n         USING ASVT,R7                                         RTS03A1\n         LTR   R1,R8              PRESERVE ASID                RTS03A1\n         BZ    ERROR              ASID=0 NOT ALLOWED           RTS03A1\n         CL    R1,ASVTMAXU        IS IT TOO LARGE?             RTS03A1\n         BH    ERROR              YES, GO NO FURTHER           RTS03A1\n         SLL   R1,2               GET INDEX INTO ASVT          RTS03A1\n         LA    R2,ASVTFRST(R1)    FIND THE ASCB                RTS03A1\n         TM    0(R2),X'80'        IS IT ACTIVE?                RTS03A1\n         BNZ   ERROR              NO, ERROR                    RTS03A1\n         L     R7,0(,R2)          YES, LOAD ASCB POINTER       RTS03A1\n         USING ASCB,R7                                         RTS03A1\n         ICM   R7,7,ASCBTSB+1     FIND THE TSB                 RTS03A1\n         BZ    ERROR              ERROR IF NONE                RTS03A1\n         USING TSB,R7                                          RTS03A1\n         SPACE\n***********************************************************************\n*        IF THE CALLER IS NOT AUTHORIZED, VERIFY THAT THE TEXT ENDS   *\n*        WITH THE REQUESTOR'S USERID.                                 *\n***********************************************************************\n         SPACE\n         TESTAUTH FCTN=1,STATE=YES,KEY=YES,RBLEVEL=2           RTS03A1\n         LTR   R15,R15            ALL-POWERFUL CALLER?         RTS03A1\n         BZ    NOUIDCHK           YES, HE CAN SEND ANYTHING    RTS03A1\n         ICM   R10,8,=X'80'       NO, SET UNAUTH FLAG          RTS03A1\n         USING TCB,R4                                          RTS03A1\n         L     R15,TCBJSCB        FIND THE PSCB FROM TCB       RTS03A1\n         USING IEZJSCB,R15                                     RTS03A1\n         ICM   R15,15,JSCBPSCB                                 RTS03A1\n         BZ    ERROR              PSCB MUST EXIST              RTS03A1\n         USING PSCB,R15                                        RTS03A1\n         CLI   PSCBUSRL,0         CALLER MUST HAVE USERID      RTS03A1\n         BE    ERROR                                           RTS03A1\n         LR    R14,R9             GET LENGTH OF TEXT           RTS03A1\n         N     R14,=X'0000FFFF'                                RTS03A1\n         SR    R1,R1                                           RTS03A1\n         ICM   R1,1,PSCBUSRL      GET USERID LENGTH            RTS03A1\n         CR    R1,R14             IS THERE ROOM FOR USERID?    RTS03A1\n         BNL   ERROR              NO, DON'T ALLOW              RTS03A1\n         AR    R14,R11            POINT TO MSG END             RTS03A1\n         SR    R14,R1             BACK UP BY ID LENGTH         RTS03A1\n         MODESET EXTKEY=TCB,WORKREG=2  GET USER KEY FOR CLC    RTS03A1\n         BCTR  R1,0                                            RTS03A1\n         EX    R1,COMPUSID        IS THE ID AT THE END?        RTS03A1\n         BE    AUTH               YES, PROCEED                 RTS03A1\n         LR    R15,R9             INDICATE UNAUTH              RTS03A1\nAUTH     MODESET EXTKEY=ZERO      GET BACK SUPER KEY           RTS03A1\n         CR    R1,R9              CAN WE PROCEED?              RTS03A1\n         BE    ERROR              NO, SAY PARM LIST ERROR      RTS03A1\n         SPACE\nNOUIDCHK LR    R0,R8              GET DESTINATION ASID         RTS03A1\n         SLL   R0,16              MOVE TO RIGHT HALF OF REG    RTS03A1\n         LR    R1,R10             GET OPTION FLAGS IN R1       RTS03A1\n         SLL   R1,24              ALIGN IN REGISTER            RTS03A1\n         TM    TSBTERM2,TSBCTWX   IS IT AN ASCII TERMINAL?     RTS03A1\n         BZ    NOTASCII           NO, CHECK FOR 3270           RTS03A1\n         O     R1,BEEPADDR        PUT BELL ADDR+CNTL IN R1     RTS03A1\n         ICM   R0,3,=H'16'        LENGTH OF BELL TEXT          RTS03A1\n         B     BELLTPUT           JOIN 3270 CASE               RTS03A1\nNOTASCII TM    TSBSTAT,TSB3270    IS THIS A 3270?              RTS03A1\n         BZ    NOBELLS            NO, FORGET BELLS             RTS03A1\n         O     R1,ALARMADR        PUT ALARM ADDR+ASIS IN R1    RTS03A1\n         ICM   R0,3,=H'5'         LENGTH OF ALARM TEXT         RTS03A1\nBELLTPUT TPUT  (1),(0),R          SEND IT OUT                  RTS03A1\n         LTR   R15,R15            ANY PROBLEMS?                RTS03A1\n         BNZ   GOHOME             YES, RETURN                  RTS03A1\n         SPACE\n***********************************************************************\n*        IF OUR CALLER WAS NOT AUTHORIZED, SYNCH TO DO THE TPUT OF THE*\n*        MESSAGE TEXT, SO THAT NORMAL BUFFER VALIDATION, AND THE      *\n*        PREFIXING OF THE TEXT WITH A + WILL OCCUR.                   *\n***********************************************************************\n         SPACE\nNOBELLS  LTR   R10,R10            IS CALLER AUTHORIZED?        RTS03A1\n         BM    SYNCHER            NO, SYNCH TO DO TPUT         RTS03A1\n         LR    R1,R11             COPY TPUT PARMS              RTS03A1\n         LR    R0,R9                                           RTS03A1\n         TPUT  (1),(0),R          SEND MESSAGE TEXT            RTS03A1\n         B     GOHOME             RETURN TO ISSUER             RTS03A1\n         SPACE\nSYNCHER  SYNCH NORMTPUT           SYNCH TO TPUT IF UNAUTH      RTS03A1\n         LR    R15,R2             COPY TPUT RETURN CODE        RTS03A1\nGOHOME   LR    R14,R5             COPY RETURN ADDRESS          RTS03A1\n         BR    R14                EXIT FROM SVC                RTS03A1\n         SPACE\nNORMTPUT LR    R2,R14             SAVE SYNCH RETURN ADDR       RTS03A1\n         LR    R0,R9              COPY ASID & LENGTH           RTS03A1\n         L     R1,=X'03000000'    CHECK FOR NON-EDIT TPUT      RTS03A1\n         NR    R1,R11                                          RTS03A1\n         BZ    EDITPUT            BRANCH EDIT                  RTS03A1\n         O     R11,=X'01000000'   ELSE FORCE TO ASIS           RTS03A1\n         N     R11,=X'FDFFFFFF'                                RTS03A1\nEDITPUT  LR    R1,R11             COPY BUFFER+OPTIONS TO R1    RTS03A1\n         TPUT  (1),(0),R          SEND MSG IN USER KEY/STATE   RTS03A1\n         LR    R14,R2             RESTORE SYNCH RETURN ADDR    RTS03A1\n         LR    R2,R15             SAVE TPUT RET CODE           RTS03A1\n         BR    R14                AND RETURN TO SVC            RTS03A1\n         SPACE\nERROR    LA    R15,16             SET BAD PARMS CODE           RTS03A1\n         B     GOHOME                                          RTS03A1\n         SPACE\nCOMPUSID CLC   0(0,R14),PSCBUSER  CHECK FOR USERID IN MSG      RTS03A1\n         DC    0A(0)                                           RTS03A1\nBEEPADDR DC    X'02',AL3(BEEP)    TO SEND BELLS CONTROL        RTS03A1\nALARMADR DC    X'01',AL3(ALARM)   TO SEND ALARM ASIS           RTS03A1\nBEEP     DC    16X'2F'            16 BELL RINGS                RTS03A1\nALARM    DC    X'27F1C41D40'      TO SOUND 3270 ALARM          RTS03A1\n         SPACE\n         LTORG ,                                               RTS03A1\n         SPACE\n         PRINT NOGEN                                           RTS03A1\n         CVT   DSECT=YES                                       RTS03A1\n         SPACE\n         IHAASCB ,                                             RTS03A1\n         SPACE\n         IHAASVT ,                                             RTS03A1\n         SPACE\n         IKJTSB ,                                              RTS03A1\n         SPACE\n         IKJTCB ,                                              RTS03A1\n         SPACE\n         IEZJSCB ,                                             RTS03A1\n         SPACE\n         IKJPSCB ,                                             RTS03A1\n         END   ,                                               RTS03A1\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XWTO": {"ttr": 13326, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   XWTO  &REPLY=*,&ROUTCDE=,&DESC=,&MSGTYP=,&MCSFLAG=,&ECB=,&MF=I\n.**********************************************************************\n.*       THIS MACRO IS A SUBSTITUTE FOR WTO AND WTOR THAT PROVIDES    *\n.*       GREATER CONVENIENCE WHEN IT IS NECESSARY TO ASSEMBLE MESSAGES*\n.*       FROM VARIABLE PIECES. PARAMETER DETAILS ARE:                 *\n.*             REPLY=(AREA,LEN,ECB) SHOULD BE GIVEN FOR WTOR,         *\n.*             DESC & ROUTCDE ARE AS FOR WTO,                         *\n.*             MF HAS THE FOLLOWING FORMS (OPTIONAL PARMS BRACKETED): *\n.*             MF=<I,<LISTNAME>>                                      *\n.*                      (GENS AND USES INLINE <NAMED> PARMS)          *\n.*             MF=(L,<LISTADDR>,<LEN>)                                *\n.*                      (GENS PARM INLINE <OR AT ADDR> <AND SETS LEN>)*\n.*             MF=(G,LISTADDR,<LEN>)                                  *\n.*                      (GENS AND USES PARMS AT ADDR <AND SETS LEN>)  *\n.*             MF=(M,LISTADDR)                                        *\n.*                      (MODIFIES PARM LIST AT ADDR)                  *\n.*             MF=(E,LISTADDR)                                        *\n.*                      (MODIFIES AND USES PARM LIST AT ADDR)         *\n.*                                                                    *\n.*       THE MESSAGE TEXT IS PROVIDED IN 1 TO N POSITIONAL MESSAGE    *\n.*       SEGMENTS. A SEGEMENT MAY SIMPLY BE A CHARACTER STRING (FOR A *\n.*       CONSTANT PART OF A MESSAGE), OR MAY BE OF THE FORM           *\n.*             (LABEL,VALUE,<LENGTH>)                                 *\n.*       THE LABEL NAMES THE NEW SEGMENT IN THE I, L AND G FORMS, AND *\n.*       SPECIFIES THE SEGMENT TO BE CHANGED IN THE M AND E FORMS.    *\n.*       THE VALUE MAY BE ONE OF THE FOLLOWING (N REPRESENTING A      *\n.*       DIGIT, AND X A LETTER):                                      *\n.*             'TEXT'        (A CHARACTER LITERAL),                   *\n.*             NN'TEXT'      (A CHARACTER LITERAL WITH LENGTH),       *\n.*             X<LNN>'TEXT'  (A CONSTANT WITH OPTIONAL LENGTH),       *\n.*             NN            (UNDEFINED VALUE WITH LENGTH)            *\n.*                           (NOT ALLOWED IF MF=I, G, M OR E),        *\n.*             XXXX          (VARIABLE TO BE STORED IN MESSAGE)       *\n.*                           (NOT ALLOWED IF MF=(L,,<LEN>)),          *\n.*             (XX)          (REGISTER FORM OF VARIABLE)              *\n.*                           (NOT ALLOWED IF MF=(L,,<LEN>)),          *\n.*             C:XXXX        (COLON FORM OF VARIABLE, C=A, S OR *)    *\n.*                           (A INDICATES ACCESS BY ADCON REQUIRED)   *\n.*                           (S INDICATES ACCESS BY S-CON REQUIRED)   *\n.*                           (* INDICATES INDIRECT ADDRESSING)        *\n.*                           (NOT ALLOWED IF MF=(L,,<LEN>)).          *\n.*                                                                    *\n.*       THE LENGTH MAY BE SPECIFIED IN ASSOCIATION WITH A <C:>XXXX   *\n.*       OR (XX) VALUE, TO INDICATE THE LENGTH TO BE MOVED. IN THE    *\n.*       I, G AND L FORMS OF THE MACRO, THE LENGTH IS REQUIRED IN THIS*\n.*       CASE. THE LENGTH MAY BE AN ABSOLUTE EXPRESSION OR, FOR THE   *\n.*       M AND E FORMS, MAY BE (XX) OR *:XX, INDICATING THAT THE      *\n.*       LENGTH IS IN A REGISTER OR A HALFWORD STORAGE LOCATION.      *\n.*                                                                    *\n.*       THE ROUTCDE, DESC, MSGTYP AND MCSFLAG KEYWORDS OF THE IBM WTO*\n.*       MACRO ARE SUPPORTED, AND MAY BE SUPPLIED IN THE M-FORM AND   *\n.*       E-FORM OF THE MACRO.                                         *\n.*       HERE ARE SOME SAMPLE MACRO CALLS:                            *\n.*                                                                    *\n.*       XWTO 'FILE ',(DDNAME,'SYSPRINT'),' NOT OPENED.',MF=(I,NOPEN) *\n.*       XWTO  (DDNAME,8'SYSIN'),MF=(E,NOPEN)                         *\n.*       GETMAIN R,LV=PLEN                                            *\n.*       XWTO  'DATA SET ',(DSNAME,44' '),' DELETED.',MF=(L,(1),PLEN) *\n.*       XWTO  (DSNAME,MYDSN,(LENREG)),MF=(E,(1))                     *\n.*                                                                    *\n.*             MACRO WRITTEN BY ARB, 11/12/76                         *\n.*             MACRO REVISED BY ARB, 8/24/78                          *\n.*             MACRO REVISED BY ARB, 1/11/79                          *\n.**********************************************************************\n         GBLC  &XWTOFLD(200)      MESSAGE SEGMENT NAMES\n         GBLC  &XWTOID(200)       CONTAINING PARM LIST NAMES\n         GBLC  &XWTOAL            RETURN VALUE FROM XWTOLKUP MACRO\n         GBLA  &XWTOIX            NUMBER OF USED TABLE ELEMENTS\n         GBLA  &XWTOLK            TABLE SUBSCRIPT FOUND BY XWTOLKUP\n         GBLB  &UHBG,&UHBM        GENERATE & MODIFY SWITCHES\n         GBLC  &UHBGL             UHBMACS GENERATED LABEL\n         GBLC  &UHBL              UHBLKUP RETURN VALUE\n.*\n         LCLC  &S,&ID,&L,&ND,&R\n         LCLB  &B(16)\n         LCLA  &I,&J,&K\n&S       SETC  '&SYSNDX'          SAVE UNIQUE NUMBER\n.*\n.*       DETERMINE PARM LIST LABEL AND GENERATE PRELUDE CODE.\n.*\n         AIF   ('&MF(1)' EQ 'I').IPRE  FORCE LABEL FOR I-FORM\n&LABEL   UHBBGEN MF=&MF\n&ID      SETC  '&UHBGL'           SAVE PARM LIST LABEL\n         AGO   .DOGEN\n.IPRE    ANOP\n&ID      SETC  'UHB&S.P'          GENERATED PARM LIST NAME\n&LABEL   UHBBGEN MF=(I,&ID)\n.DOGEN   AIF   (NOT &UHBG).DOMOD  POSSIBLY SKIP GENERATION\n.*\n.*       HANDLE THE REPLY OPERAND (IN-LINE LIST).\n.*\n         AIF   ('&REPLY&ECB' EQ '*').INOR  IF REPLY NOT PASSED\n         UHBGEN &REPLY(2),1,COM=REPLY.LENGTH,RQR=Y,MF=&MF\n         UHBGEN &REPLY(1),3,COM=REPLY.AREA,RQR=Y,MF=&MF\n         UHBGEN &REPLY(3)&ECB,4,COM=ECB,RQR=Y,MF=&MF\n.*\n.*       GENERATE THE IN-LINE MESSAGE SEGMENTS.\n.*\n.INOR    AIF   (N'&SYSLIST NE 0).GOTMSG\n         MNOTE 8,'XWTO02 NO MESSAGE SEGMENTS SPECIFIED.'\n         AGO   .IDONE\n.GOTMSG  ANOP\n&B(1)    SETB  ('&ROUTCDE' NE '' OR '&DESC' NE '' OR '&MSGTYP' NE '' OR*\n                '&MCSFLAG' NE '')\n.*             &B(1)=1 IF ANY MCS STUFF WAS PASSED\n&B(4)    SETB  ('&MSGTYP' NE '' AND '&MSGTYP' NE 'N')\n.*             &B(4)=1 IF MSGTYP (TO BE) SUPPLIED\n         AIF   ('&MCSFLAG' EQ '').INOMCS    TRANSLATE MCS CODES TO BITS\n&I       SETA  1\n.IMCSLKP UHBLKUP &MCSFLAG(&I),VAL=(REG0,RESP,REPLY,BRDCST,HRDCPY,      *\n               QREG0,NOTIME,NOCPY),OUT=(2,3,5,6,7,8,9,14),             *\n               NAME=MCSFLAG\n         AIF   ('&UHBL' EQ '').INXMCS  ALLOW FOR ERROR\n&B(&UHBL) SETB (1)\n.INXMCS  ANOP\n&I       SETA  &I+1\n         AIF   (&I LE N'&MCSFLAG).IMCSLKP\n.INOMCS  ANOP\n&ND      SETC  'UHB&S.T'          END OF MESSAGE LABEL\n         UHBGEN &ND-*,2,COM=MESSAGE.LENGTH,MF=&MF\n         UHBGENV B'&B(1)&B(2)&B(3)&B(4)&B(5)&B(6)&B(7)&B(8)&B(9)0000&B(*\n               14)00',COM=MCS.FLAGS,MF=&MF     GENERATE MCS FLAGS\n&I       SETA  1                  &SYSLIST INDEX\n.ILOOP   AIF   ('&SYSLIST(&I)' NE '').ILOK DIAGNOSE EMPTY SEGMENT\n         MNOTE 4,'XWTO03 EMPTY MESSAGE SEGMENT IGNORED.'\n         AGO   .INEXT\n.ILOK    AIF   (N'&SYSLIST(&I) GT 1).IMULT\n         AIF   ('&SYSLIST(&I)'(K'&SYSLIST(&I),1) EQ '''').ITEXT\n         MNOTE 8,'XWTO04 INVALID TEXT SEGMENT: &SYSLIST(&I)'\n         AGO   .INEXT\n.ITEXT   AIF   ('&SYSLIST(&I)'(1,1) EQ '''').ILIT\n         AIF   ('&SYSLIST(&I)'(1,1) GE '0' AND '&SYSLIST(&I)'(1,1)     *\n               LE '9').ILEN\n         UHBGENV &SYSLIST(&I),COM=CONSTANT.TEXT,MF=&MF\n         AGO   .INEXT\n.ILIT    UHBGENV C&SYSLIST(&I),COM=CONSTANT.TEXT,MF=&MF\n         AGO   .INEXT\n.ILEN    UHBGENV CL&SYSLIST(&I),COM=CONSTANT.TEXT,MF=&MF\n         AGO   .INEXT\n.IMULT   AIF   (N'&SYSLIST(&I) EQ 2).IM2\n         AIF   ('&MF(1)' NE 'L' OR '&MF(2)' NE '').IM3\n         MNOTE 8,'XWTO05 SEGMENT LENGTH INVALID FOR MF=L.'\n         MEXIT\n.IM3     AIF   ('&SYSLIST(&I,3)'(1,1) NE '(').IM2\n         MNOTE 8,'XWTO06 REGISTER SEGMENT LENGTH NOT ALLOWED FOR MF=&MF*\n               (1)..'\n         MEXIT\n.IM2     ANOP\n&L       SETC  '&SYSLIST(&I,1)'   NAME OF SEGMENT TO GEN\n.*\n.*       LOOK THE SEGMENT LABEL UP TO SEE IF AN ALIAS LABEL HAS\n.*       ALREADY BEEN GENERATED FOR THE START OF THE PARM LIST (BY THE\n.*       PREVIOUS USE OF THE NAME IN A M OR E FORM MACRO).\n.*       ADD THE LABEL TO THE TABLE IF NOT THERE ALREADY.\n.*\n         XWTOLKIN &L,&ID          LOOK UP AND POSSIBLY INSERT IN TABLE\n         AIF   (&XWTOLK EQ 0).INEW     BRANCH IF NEW SYMBOL, OR        *\n                                  IF INDIRECTLY DEFINED.\n&XWTOAL  EQU   &ID                DEFINE PREVIOUSLY USED LIST NAME\n.INEW    AIF   (N'&SYSLIST(&I) GT 2).IM3LEN\n         AIF   ('&SYSLIST(&I,2)'(1,1) EQ '''').IMLIT\n         AIF   ('&SYSLIST(&I,2)'(1,1) GE '0' AND '&SYSLIST(&I,2)'(1,1) *\n               LE '9').IMLEN\n&L       UHBGENV &SYSLIST(&I,2),COM=VARIABLE.TEXT,MF=&MF\n         AGO   .INEXT\n.IMLIT   ANOP\n&L       UHBGENV &SYSLIST(&I,2),COM=VARIABLE.TEXT,MF=&MF\n         AGO   .INEXT\n.IMLEN   ANOP\n&J       SETA  K'&SYSLIST(&I,2)\n         AIF   ('&SYSLIST(&I,2)'(&J,1) EQ '''').IMLLIT IF ENDS IN QUOTE\n&L       UHBGENV ,&SYSLIST(&I,2),COM=VARIABLE.TEXT,TYPE=C,RQR=Y,       *\n               NAME=MESSAGE-TEXT,MF=&MF\n         AGO   .INEXT\n.IMLLIT  ANOP\n&L       UHBGENV CL&SYSLIST(&I,2),COM=VARIABLE.TEXT,MF=&MF\n         AGO   .INEXT\n.IM3LEN  ANOP\n&J       SETA  K'&SYSLIST(&I,2)\n         AIF   ('&SYSLIST(&I,2)'(&J,1) EQ '''').IM3ERR\n&L       UHBGENV &SYSLIST(&I,2),(&SYSLIST(&I,3)),COM=VARIABLE.TEXT,    *\n               TYPE=C,MF=&MF\n         AGO   .INEXT\n.IM3ERR  MNOTE 8,'XWTO09 VARIABLE LENGTH NOT ALLOWED WITH LITERAL MESSA*\n               GE SEGMENT.'\n.INEXT   ANOP\n&I       SETA  &I+1               ON TO NEXT SEGMENT\n         AIF   (&I LE N'&SYSLIST).ILOOP\n.IDONE   AIF   (&B(1)).IRD\n&ND      EQU   *                  END OF MESSAGE TEXT\n         AGO   .DOMOD\n.IRD     ANOP\n&ND      XWTORD &DESC,0000,DESCRIPTOR  GENERATE DESC. CODES\n         AIF   ('&MCSFLAG' NE '' AND (&B(2) OR &B(8))).NORT\n         XWTORD &ROUTCDE,4000,ROUTE    GENERATE ROUTE CODES\n         AGO   .JRT\n.NORT    XWTORD &ROUTCDE,0000,ROUTE\n.JRT      AIF   ('&MSGTYP' EQ 'N' OR '&MSGTYP' EQ '').DOMOD\n&I       SETA  1\n&B(1)    SETB  (0)\n&B(2)    SETB  (0)\n&B(3)    SETB  (0)\n&B(6)    SETB  (0)\n         AIF   ('&MSGTYP' EQ 'Y').IMSGT\n&I       SETA  1\n.IMSGLKP UHBLKUP &MSGTYP(&I),VAL=(JOBNAMES,STATUS,ACTIVE,SESS),        *\n               OUT=(1,2,3,6),NAME=MSGTYP    LOOK UP MSGTYP NAMES\n         AIF   ('&UHBL' EQ '').INXMSGT\n&B(&UHBL) SETB (1)\n.INXMSGT ANOP\n&I       SETA  &I+1\n         AIF   (&I LE N'&MSGTYP).IMSGLKP\n.IMSGT   UHBGENV B'&B(1)&B(2)&B(3)00&B(6)0000000000',COM=MSGTYPE.FLAGS,*\n               MF=&MF\n.*\n.*       GENERATE INTERLUDE CODE\n.*\n.DOMOD   UHBEGEN MF=&MF\n         UHBBMOD MF=&MF\n         AIF   (NOT &UHBM).DOSVC  IF NO MODIFY NEEDED\n.*\n.*       HANDLE MODIFICATION OF REPLY PARAMETERS.\n.*\n         AIF   ('&REPLY&ECB' EQ '*').ONOR\n         UHBMOD 0(1),&REPLY(2),1,COM=REPLY.LENGTH,MF=&MF\n         UHBMOD 1(1),&REPLY(1),3,COM=REPLY.AREA,MF=&MF\n         UHBMOD 4(1),&REPLY(3)&ECB,4,COM=ECB,MF=&MF\n.ONOR    ANOP\n.*\n.*       NOW HANDLE MODIFICATION OF MESSAGE SEGMENTS.\n.*\n&I       SETA  1                  &SYSLIST INDEX\n&R       SETC  'UHB&S.A'          PROVISIONAL ALIAS NAME\n         AIF   (N'&SYSLIST EQ 0).ODONE\n.OLOOP   AIF   (N'&SYSLIST(&I) GT 1).OMULT\n         AIF   ('&MF(1)' NE 'E' AND '&MF(1)' NE 'M').ONEXT\n         MNOTE 8,'XWTO07 UNLABELLED MESSAGE SEGMENT IGNORED.'\n         AGO   .ONEXT\n.OMULT   ANOP\n&L       SETC  '&SYSLIST(&I,1)'   NAME OF DESTINATION SEGMENT\n         AIF   ('&MF(1)' NE 'E' AND '&MF(1)' NE 'M').ONLKUP\n.*\n.*       LOOK THE DESTINATION LABEL UP TO SEE IF A NAME IS KNOWN OR\n.*       HAS BEEN GENERATED FOR THE START OF THE CONTAINING LIST. IF\n.*       NOT YET KNOWN, WE MAKE A NEW NAME AND INSERT IT IN THE TABLE.\n.*\n         XWTOLKIN &L,&R,I         FIND ALIAS LABEL, OR GENERATE NEW ONE\n&ID      SETC  '&XWTOAL'          SAVE LIST START LABEL\n&R       SETC  '0&XWTOLK'         SAVE ENTRY NUMBER FOR CHAINING\n.ONLKUP  ANOP\n&J       SETA  K'&SYSLIST(&I,2)\n         AIF   ('&SYSLIST(&I,2)'(&J,1) EQ '''').OLIT IF LITERAL SEGMENT\n.ONLIT   UHBMODV &L-&ID.(1),&SYSLIST(&I,2),&SYSLIST(&I,3),             *\n               COM=MESSAGE.SEGMENT,MF=&MF\n         AGO   .ONEXT\n.OLIT    AIF   ('&SYSLIST(&I,2)'(1,1) LT '0').ONLIT BR UNLESS LIT W LEN\n         UHBMODV &L-&ID.(1),CL&SYSLIST(&I,2),&SYSLIST(&I,3),           *\n               COM=MESSAGE.SEGMENT,MF=&MF\n.ONEXT   ANOP\n&I       SETA  &I+1\n         AIF   (&I LE N'&SYSLIST).OLOOP\n.ODONE   AIF   ('&MF(1)' NE 'M' AND '&MF(1)' NE 'E').DOSVC\n         AIF   ('&ROUTCDE' EQ '' AND '&DESC' EQ '' AND '&MCSFLAG' EQ ''*\n                AND '&MSGTYP' EQ '').DOSVC\n         AIF   ('&REPLY&ECB' EQ '*').ORDNREP\n         LA    14,8(,1)           ADDRESS MESSAGE LENGTH\n         AGO   .ORD\n.ORDNREP LR    14,1\n.ORD     AIF   ('&MCSFLAG' EQ '').ONOMCS\n&I       SETA  1\n.OMCSLKP UHBLKUP &MCSFLAG(&I),VAL=(REG0,RESP,REPLY,BRDCST,HRDCPY,      *\n               QREG0,NOTIME,NOCPY),OUT=(4096,2048,512,256,128,64,32,1),*\n               NAME=MCSFLAG\n         AIF   ('&UHBL' EQ '').ONXMCS\n&J       SETA  &J+&UHBL\n.ONXMCS  ANOP\n&I       SETA  &I+1\n         AIF   (&I LE N'&MCSFLAG).OMCSLKP\n&K       SETA  &J/64              BITS FOR 1ST BYTE\n         UHBMODF 2(14),ON=&K,COM=MCS.FLAGS,MF=E\n&K       SETA  (&J-&K*64)*4\n         UHBMODF 3(14),ON=&K,COM=MCS.FLAGS,MF=E\n.ONOMCS  AIF   ('&ROUTCDE' EQ '' AND '&DESC' EQ '' AND                 *\n               '&MSGTYP' EQ '').DOSVC\n         AH    14,0(,14)          ADDRESS DESCRIPTOR CODES\n         XWTORDM &DESC,0(14),DESCRIPTOR\n         XWTORDM &ROUTCDE,2(14),ROUTE\n&I       SETA  1\n&J       SETA  0\n         AIF   ('&MSGTYP' EQ '').DOSVC\n.OMSGLKP UHBLKUP &MSGTYP(&I),VAL=(JOBNAMES,STATUS,ACTIVE,SESS),        *\n               OUT=(128,64,32,4),NAME=MSGTYP\n         AIF   ('&UHBL' EQ '').ONXMSGT\n&J       SETA  &J+&UHBL\n.ONXMSGT ANOP\n&I       SETA  &I+1\n         AIF   (&I LE N'&MSGTYP).OMSGLKP\n         UHBMODF 4(14),ON=&J,COM=MSGTYPE.FLAGS,MF=E  MODIFY MSGTYP\n.*\n.*       GENERATE POSTLUDE CODE.\n.*\n.DOSVC   UHBSVC 35,NAME=WTO(R),MF=&MF CALL SVC IF NEEDFUL\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XWTO@": {"ttr": 13573, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "1\n-\n      XWTO is  a macro to  generate and  modify WTO parameter  lists without\n      having to compute the offsets of message segments.   With it,  you can\n      write code like:\n0              XWTO  (DDNAME,'SYSPRINT'),MF=(E,NOTOPEND)\n                     ...\n      NOTOPEND XWTO  'DDNAME ',(DDNAME,8),' FAILED TO OPEN',MF=L\n0     to send a \"DDNAME insert FAILED TO OPEN\" message.\n0     The basic syntax is:\n0     label     XWTO  segment-list,\n                      REPLY=(area,length),\n                      ECB=ecbaddr,\n                      ROUTCDE=routing-codes,\n                      DESC=descriptor-codes,\n                      MSGTYP=msgtype-codes,\n                      MCSFLAG=mcsflag-codes,\n                      MF=(mf,area,length)\n0     The REPLY, ECB, ROUTCDE,  DESC,  MSGTYP and MCSFLAG parameters are the\n      same as for the IBM WTO(R); however, ROUTCDE, DESC, MSGTYP and MCSFLAG\n      can also be supplied on the E-form macro.\n0     MF supports the following forms:\n0          MF=I - Generates  an inline  parm list  and issues  the SVC  (the\n                default).\n0          MF=L - Generates an inline parm list.\n           MF=(L,,length)  - Generates  an inline parm list  and equates the\n                \"length\" symbol to the list of the parm list.\n           MF=(L,area,length)   - Generates  a  parm  list at  the  location\n                specified by \"area\".   If a length is present, it is equated\n                to the parm list length.\n0          MF=(G,area,length)   - Generates  a  parm  list at  the  location\n                specified by \"area\",   and issues the SVC.   If  a length is\n                present, it is equated to the parm list length.\n0          MF=(M,area)  -  Modifies the  parm list  present at  the location\n                specified by \"area\".\n0          MF=(E,area)  -  Modifies the  parm list  present at  the location\n                specified by \"area\", and issues the SVC.\n0     Where  sensible,  addresses  and lengths  may be  specified using  the\n      following notations:\n0          (xx) - indicates the data or address in register xx\n           A:xx -  indicates the  address  of location  xx,   which must  be\n                accessed via an A-type constant (i.e.,  may not be addressed\n                via a register)\n           S:xx -  indicates the  address  of location  xx,   which must  be\n                accessed via a base register (i.e., may not be addressed via\n                an address constant)\n           *:xx - indicates  the data or  address referenced by  location xx\n                via indirect addressing.   When this  notation is used for a\n                segment length, the length should be stored as a halfword.\n0     Message  segments may  be either  constant or  variable (the  constant\n      forms are  allowed only  in macro  forms that  generate a  parm list).\n      Constant segements are merely quoted strings.   Variable segments have\n      the form (label,value)  or (label,value,length).   The label serves to\n      name a  segment,  when  generating a  parm list,   or to  identify the\n      segment to be modified, when modifying a parm list.   The length field\n      is used in rather special situations, and is discussed later.\n1\n0                                                                     PAGE 2\n0     The forms which \"value\" may assume are:\n0          'xxx' - to indicate a literal character string,\n           nn'xxx' - to indicate a character string of length nn\n           t'xx' - to indicate a constant  of some non-character type (e.g.,\n                an EDIT pattern),\n           tLnn'xx' - to indicate a non-character constant of length nn,\n           nn - to indicate an undefined value of length nn,\n           addr - to  indicate the  address of  data to  be copied  into the\n                segment.   This  form can be in  any of the  address formats\n                described above.\n0     If the  value is given  as an address,  a  length may be  specified to\n      indicate the amount of data to be copied (in normal, register, or \"*:\"\n      notation).   The  length can be  omitted only when  modifiying another\n      parameter list;  in this case,  the  length with which the segment was\n      generated when defined is used.\n0     Note that a segement may always be  modified before it is used,  i.e.,\n      an E or M form may appear before the I, L or G form which defined it.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XWTOLKIN": {"ttr": 13576, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         XWTOLKIN &L,&ID,&IN\n.**********************************************************************\n.*       THIS MACRO IS USED AS IN INNER MACRO BY XWTO TO DO A TABLE   *\n.*       LOOKUP FOR A SYMBOL (THE LABEL OF A MESSAGE SEGMENT), AND    *\n.*       TO RETURN THE INDEX NUMBER, AND THE CORRESPONDING ELEMENT OF *\n.*       ANOTHER TABLE (THE TABLE OF PARAMETER LIST NAMES). IF THE    *\n.*       LABEL IS NOT IN THE LIST, IT IS INSERTED, AND AN ALIAS NAME  *\n.*       IS INSERTED IN THE CORRESPONDING ELEMENT OF THE OTHER TABLE. *\n.*       SOME ENTRIES IN THE SECOND TABLE MAY BE REFERENCES TO OTHER  *\n.*       TABLE ELEMENTS; IN THIS CASE, THE RESULT MAY BE GIVEN AS     *\n.*       \"NOT FOUND\", OR AS THE INDIRECTLY REFERENCED ELEMENT,        *\n.*       AS CHOSEN BY THE CALLER.                                     *\n.**********************************************************************\n         GBLC  &XWTOFLD(200)      THE TABLE OF SEGEMENT NAMES\n         GBLC  &XWTOID(200)       THE TABLE OF PARM LIST NAMES\n         GBLC  &XWTOAL            THE RETURNED RESULT\n         GBLA  &XWTOIX            CURRENT TABLE SIZE\n         GBLA  &XWTOLK            INDEX FOR THE LABEL (0 IF NOT FOUND)\n.*\n.*       SEE IF THE LABEL IS ALREADY IN THE LIST.\n.*\n         XWTOLKUP &L              GET LABEL INDEX NUMBER\n         AIF   (&XWTOLK NE 0).IND LABEL WAS FOUND\n&XWTOIX  SETA  &XWTOIX+1          INCREASE SIZE\n&XWTOFLD(&XWTOIX) SETC '&L'       STORE NEW LABEL\n&XWTOID(&XWTOIX) SETC '&ID'       STORE CORRESPONDING LIST\n&XWTOAL  SETC  '&ID'              STORE IN RETURN VALUE\n         AIF   ('&IN' NE 'I').MEND IF NOT INDIRECTING, RETURN LK=0\n         AIF   ('&XWTOAL'(1,1) NE '0').INDN1\n&XWTOLK  SETA  &XWTOAL\n&XWTOAL  SETC  '&XWTOID(&XWTOLK)'\n         AGO   .MEND\n.INDN1   ANOP\n&XWTOLK  SETA  &XWTOIX            ELSE RETURN NUMBER OF NEW ENTRY\n         AGO   .MEND\n.IND     AIF   ('&IN' EQ 'I').MEND NO MORE IF INDIRECTING\n         AIF   ('&XWTOAL' EQ '&XWTOID(&XWTOLK)').MEND RESULT OK IF     *\n                                  RESULT NOT INDIRECT\n&XWTOLK  SETA  0                  ELSE SAY NOT FOUND\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XWTOLKUP": {"ttr": 13578, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         XWTOLKUP &L\n.**********************************************************************\n.*       THIS MACRO IS USED AS IN INNER MACRO BY XWTO TO DO A TABLE   *\n.*       LOOKUP FOR A SYMBOL (THE LABEL OF A MESSAGE SEGMENT), AND    *\n.*       TO RETURN THE INDEX NUMBER, AND THE CORRESPONDING ELEMENT OF *\n.*       ANOTHER TABLE (THE TABLE OF PARAMETER LIST NAMES). THE       *\n.*       CORRESPONDING ELEMENT MAY BE AN INDIRECT REFERNCE TO ANOTHER *\n.*       TABLE ELEMENT. IN THIS CASE, THE CORRECT INDEX IS RETURNED,  *\n.*       BUT THE LOOKUP RESULT IS THE MEMBER OF THE PARMLIST TABLE    *\n.*       IDENTIFIED BY THE INDIRECT REFERENCE.                        *\n.**********************************************************************\n         GBLC  &XWTOFLD(200)      THE MESSAGE SEGMENT TABLE\n         GBLC  &XWTOID(200)       THE PARM LIST TABLE\n         GBLC  &XWTOAL            THE RETURNED RESULT\n         GBLA  &XWTOIX            THE CURRENT TABLE SIZE\n         GBLA  &XWTOLK            THE RETURNED INDEX (0 IF NOT FOUND)\n         LCLA  &I\n&I       SETA  1\n.LOOP    AIF   (&I GT &XWTOIX).NO\n         AIF   ('&XWTOFLD(&I)' EQ '&L').YES\n&I       SETA  &I+1\n         AGO   .LOOP\n.NO      ANOP\n&XWTOLK  SETA  0                  NEGATORY, GOOD BUDDY\n         MEXIT\n.YES     ANOP\n&XWTOLK  SETA  &I                 RETURNED INDEX\n&XWTOAL  SETC  '&XWTOID(&I)'      CORRESPONDING PARM LIST\n         AIF   ('&XWTOAL'(1,1) NE '0').MEND   IF NOT INDIRECT\n&I       SETA  &XWTOAL            CONVERT INDIRECT REF TO NUMERIC\n&XWTOAL  SETC  '&XWTOID(&I)'      AND RETURN THAT ONE INSTEAD\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XWTORD": {"ttr": 13580, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   XWTORD &L,&D,&TEXT\n.**********************************************************************\n.*       THIS MACRO IS CALLED AS AN INNER MACRO BY XWTO TO GENERATE   *\n.*       ROUTE AND DESCRIPTOR CODE LISTS.                             *\n.**********************************************************************\n         LCLB  &B(16)             BITS FOR EACH CODE VALUE\n         LCLA  &I,&J,&N\n         AIF   ('&L' EQ '').DEF\n&I       SETA  1\n.LOOP    AIF   (K'&L(&I) LE 2).OK\n.ERR     MNOTE 4,'XWTO01 &L(&I) IS AN INVALID ROUTE OR DESCRIPTOR CODE,*\n                IGNORED.'\n         AGO   .NEXT\n.OK      AIF   (K'&L(&I) EQ 2).L2\n         AIF   ('&L(&I)' LE '0' OR '&L(&I)' GT '9').ERR\n         AGO   .GOOD\n.L2      AIF   ('&L(&I)' LT '10' OR '&L(&I)' GT '16').ERR\n.GOOD    ANOP\n&N       SETA  &N+1\n&J       SETA  &L(&I)\n&B(&J)   SETB  (1)                TURN ON CORRESPONDING BIT\n.NEXT    ANOP\n&I       SETA  &I+1\n         AIF   (&I LE N'&L).LOOP\n         AIF   (&N EQ 0).DEF      IF NO GOOD PARMS\n&LABEL   UHBGENV B'&B(1)&B(2)&B(3)&B(4)&B(5)&B(6)&B(7)&B(8)&B(9)&B(10)&*\n               B(11)&B(12)&B(13)&B(14)&B(15)&B(16)',COM=&TEXT..CODES,  *\n               MF=I\n         MEXIT\n.DEF     ANOP\n&LABEL   UHBGENV ,COM=&TEXT..CODES,TYPE=X,DEF='&D',MF=I\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XWTORDM": {"ttr": 13582, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   XWTORDM &L,&D,&TEXT\n.**********************************************************************\n.*       THIS MACRO IS CALLED AS AN INNER MACRO BY XWTO TO MODIFY     *\n.*       ROUTE AND DESCRIPTOR CODE LISTS.                             *\n.**********************************************************************\n         LCLB  &B\n         LCLA  &I,&J,&K,&N,&M(2)\n         AIF   ('&L' EQ '').MEND\n&I       SETA  1\n.LOOP    AIF   (K'&L(&I) LE 2).OK\n.ERR     MNOTE 4,'XWTO01 &L(&I) IS AN INVALID ROUTE OR DESCRIPTOR CODE,*\n                IGNORED.'\n         AGO   .NEXT\n.OK      AIF   (K'&L(&I) EQ 2).L2\n         AIF   ('&L(&I)' LE '0' OR '&L(&I)' GT '9').ERR\n&B       SETB  ('&L(&I)' EQ '9')\n         AGO   .GOOD\n.L2      AIF   ('&L(&I)' LT '10' OR '&L(&I)' GT '16').ERR\n&B       SETB  (1)\n.GOOD    ANOP\n&J       SETA  1\n&K       SETA  &B+1\n&N       SETA  8-&L(&I)+8*&B\n         AIF   (&N LE 4).NO4\n&J       SETA  &J*16\n&N       SETA  &N-4\n.NO4     AIF   (&N LE 2).NO2\n&J       SETA  &J*4\n&N       SETA  &N-2\n.NO2     AIF   (&N LE 1).NO1\n&J       SETA  &J*2\n.NO1     ANOP\n&M(&K)   SETA  &M(&K)+&J\n.NEXT    ANOP\n&I       SETA  &I+1\n         AIF   (&I LE N'&L).LOOP\n&LABEL   UHBMODF &D,ON=&M(1),COM=&TEXT..CODES,MF=M\n         UHBMODF 1+&D,ON=&M(2),COM=&TEXT..CODES,MF=M\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT336/FILE336.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT336", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}