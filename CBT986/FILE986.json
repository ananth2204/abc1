{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013708000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 117572, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE986.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE986.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x03\\x0b'", "DS1TRBAL": "b'Wd'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\n|\\x00\\t\\n|\\x00\\x0c\\x00\\x04'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04a\\x00S\\x01\\x19\\x10\\x7f\\x01\\x19\\x10\\x7f\\x11 \\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf7@@@'", "ispf": {"version": "04.97", "flags": 0, "createdate": "2019-04-17T00:00:00", "modifydate": "2019-04-17T11:20:53", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-497"}, "text": "REGULAR CBT TAPE - VERSION 497    FILE:  986\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT497.FILE986\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 12 MEMBERS COUNTED; CUMULATIVE SIZE IS 832 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   04/17/19    11:20:53    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$README": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00Y\\x01\\x19\\x00O\\x01\\x19\\x10\\x7f\\x11\\x13\\x00\\x13\\x00\\x07\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2019-01-04T00:00:00", "modifydate": "2019-04-17T11:13:59", "lines": 19, "newlines": 7, "modlines": 0, "user": "DVL"}, "text": "TSOPUTLN macro - TSO putline not needing setup.\n\nInstallation\n\n  Copy members $LA, #MODULE and TSOPARM to your MACLIB.\n  Update and run member TSOPUTL$.\n  Documentation in member TSOPUTL@\n\nMember list\n\n  $$README    this member\n  $LA         asm support macro\n  #MODULE     asm support macro\n  RXINSTRM    Procedure for running in-stream REXX\n  RXINSTRX    Program for running in-stream REXX\n  TSOPARM     asm support macro\n  TSOPUTL$    Install and sample JCL\n  TSOPUTL@    Documentation\n  TSOPUTLN    asm macro\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$LA": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00U\\x01\\x17\\x08_\\x01\\x183/\\x16\\x02\\x00\\x88\\x00t\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2017-03-26T00:00:00", "modifydate": "2018-11-28T16:02:55", "lines": 136, "newlines": 116, "modlines": 0, "user": "DVL"}, "text": "         Macro\n.*-\n.* $LA - build LA instruction (inner macro)\n.*\n.* Returns length in a global variable, length either defined by the\n.* 2rd operand, or computed from the 2nd operand.\n.* Syntax:\n.*   $la  r1,label      -> la    r1,label\n.*   $la  r1,,label     -> la    r1,label\n.*   $la  r1,number     -> lgfi  r1,nnn\n.*   $la  r1,4(,r3)     -> la    r1,4(,r3)                -> length=0\n.*   $la  r1,(r2)       -> lr    r1,r2                    -> length=0\n.*   $la  r1,'kilroy'   -> la    r1,=c'kilroy'\n.*   $la  r1,0          -> slr   r1,r1                    -> length=0\n.*   $la  r1,x.label    -> lx    r1,label  (x: B, F or H) -> length=0\n.* The length is returned in global variable $lalen, the type in\n.* global variable $latype.\n.*\n.* updates\n.* 2017-14-03  numeric value now different from label\n.* 2018-06-16  2rd operand is now alternate src, not global length\n.*-\n&mlbl    $la   &reg,&psrc,&pasrc,&pasrc2,&glen=,&src2=\n         lcla  &n,&l\n         lclc  &s,&c,&r,&srct,&srcl,&src\n         gbla  &$lalen\n         gblc  &$lalitlenc\n&$lalitlenc setc ''\n         gblc  &$latype\n&$lalen  seta  0\n.* select source\n         aif   (k'&psrc   gt 0).setsrc1\n         aif   (k'&pasrc  gt 0).setsrc2\n         aif   (k'&pasrc2 gt 0).setsrc3\n         aif   (k'&src2   gt 0).setsrc4\n         mnote  8,'** $LA mising source'\n.setsrc1 anop\n&src     setc  '&psrc'\n         ago   .setsrcn\n.setsrc2 anop\n&src     setc  '&pasrc'\n         ago   .setsrcn\n.setsrc3 anop\n&src     setc  '&pasrc2'\n         ago   .setsrcn\n.setsrc4 anop\n&src     setc  '&src2'\n.setsrcn anop\n.*\n&s       setc  Upper('&src')\n         aif   ('&s   '(1,3) eq 'L''''').litlen\n&srct    setc  t'&src\n&srcl    setc  Lower('&src')\n.* mnote *,'type &srct'\n.*-\n.* what kind of 1st operand do we have?\n.*-\n         aif   (k'&src gt 0).cp1\n         mnote 8,'src operand missing'\n         mexit\n.cp1     aif   ('&src '(2,1) eq '.').load\n         aif   ('&src' eq '0').clr          clear register\n         aif   ('&src'(1,1) eq '(').reg     register\n         aif   ('&src'(1,1) eq '''').txt    text\n         aif   ('&srct' eq 'N').num        number\n         ago   .lbl\n.*- src is 0, means clear reg\n.clr     anop  ,\n&$latype setc  'CLR'\n&mlbl    slr   &reg,&reg\n         mexit\n.*- src is a number\n.num     anop  ,\n&$latype setc  'NUM'\n&mlbl    lgfi  &reg,&src\n&$lalen  seta  &src\n         mexit\n.*- src is a label or address\n.lbl     anop  ,                           label\n&$latype setc  'LBL'\n&mlbl    la    &reg,&src\n&c       setc  t'&src\n         aif   ('&c' ne 'A').setl0\n&n       seta  l'&src\n&$lalen  seta  &n\n         mexit\n.*- src is a register\n.reg     anop  ,                           register\n&$latype setc  'REG'\n&n       seta  (k'&src)-2\n&s       setc  '&src'(2,&n)\n&mlbl    lr    &reg,&s\n&$lalen  seta  1                            default\n         mexit\n.*- src is text\n.txt     anop  ,\n&$latype setc  'TXT'\n&s       setc  '=c&src'\n&mlbl    la    &reg,&s\n&n       seta  (k'&src)-2\n&$lalen  seta  &n\n&$lalitlenc setc  '&n'\n         mexit\n.*- load from storage\n.load    anop  ,\n.* mnote *,'load'\n&c       setc  Upper('&srcl'(1,1))\n&n       seta  (k'&src)-2\n&s       setc  '&src'(3,&n)\n&$latype setc  'LFS'\n&$lalen  seta  0\n         aif   ('&c' eq 'F' or '&c' eq 'A').loadf\n         aif   ('&c' eq 'H').loadh\n         aif   ('&c' eq 'B').loadb\n         mnote 8,*** invalid load parm &c'\n         mexit\n.loadf   anop  ,\n&mlbl    l     &reg,&s                     load from fullword\n         mexit\n.loadh   anop  ,\n&mlbl    lh    &reg,&s                     load from halfword\n         mexit\n.loadb   anop  ,\n&mlbl    sr    &reg,&reg\n         ic    &reg,&s                     load from byte\n         mexit\n*-\n.litlen  anop\n&n       seta  (k'&src)-4\n&$lalen  seta  &n\n         la    &reg,&n                     length of literal\n         mexit\n*-\n.setl0   anop\n&$lalen  seta  0\n.x       Mend\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#MODULE": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x018\\x003\\x00\\x98\\x12\\x7f\\x01\\x183/\\x15S\\x00\\xc6\\x00\\xa9\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.56", "flags": 0, "createdate": "1998-05-07T00:00:00", "modifydate": "2018-11-28T15:53:33", "lines": 198, "newlines": 169, "modlines": 0, "user": "DVL"}, "text": "         Macro\n.*\n.* Setup module start - basereg, working storage etc.\n.*\n.* base=(reg1\u00dd,reg2\u00dd,reg3\u00a8\u00a8)      setup up to 3 baseregs\n.* work=(length,label,reg)        acquire dynamic storage\n.* work24=(length,label,reg)      acquire dynamic 24-bit storage\n.* sa=label | *\u00ddn\u00a8                save area label or inline\n.* prolog=address                 address of prolog subroutine\n.* epilog=address                 address of epilog subroutine\n.* end\u00dd,rc=value\u00a8                 return via epilog\n.* return\u00dd,rc=value\u00a8              return via epilog\n.*\n.* Changelog\n.* 2018-10-27  rc value for end can be syslist(2) i.e #module end,123\n.* 2018-11-26  4th parm of work/work24 can be set to 'C' => clear stg\n.*\n.*\n&mlbl    #MODULE &p1,&amode=31,&rmode=ANY,&text=,&rc=,&date=E,         c\n               &base=r12,&sa=,&work=,&work24=,&sp=*future*,            c\n               &prolog=,&epilog=,&xprolog=,&xepilog=\n.*-\n         gblb  &#modequ\n         gbla  &iezbits\n         gblc  &#modname,&#modrmod,&#modamod\n         lcla  &n,&m\n         lclc  &s,&l,&base1,&base2,&base3,&d,&d1,&d2,&d3\n         lclc  &worksz,&workrg,&worklb,&workloc,&workclr\n&l        setc  '#M&sysndx'\n          aif   (k'&p1 eq 0).nop1\n&s        setc  Upper('&p1')\n          aif   ('&s' eq 'END' or '&s' eq 'RETURN'                     c\n               or '&s' eq 'EXIT').end\n          mnote 8,'*** Invalid p1'\n          mexit\n.nop1     anop\n          aif   (k'&mlbl gt 0).lblok\n          mnote 8,'*** Missing label'\n          mexit\n.lblok    anop\n&#modname setc  '&mlbl'\n&#modamod setc  '&amode'\n&#modrmod setc  '&rmode'\n&base1    setc  '&base(1)'\n&base2    setc  '&base(3)'\n&base3    setc  '&base(4)'\n&worksz   setc  '&work(1)&work24(1)'\n&worklb   setc  '&work(2)&work24(2)'\n&workrg   setc  '&work(3)&work24(3)'\n&workclr  setc  Upper('&work(4)&work24(4)')\n&workloc  setc  '&amode'\n          aif   (n'&work24 eq 0).worklocn\n&workloc  setc  '24'\n.worklocn anop\n.*-\n.* Equate regs and bits\n.*-\n         push  print\n         print off\n&n       seta  0\n         aif   (&#modequ).equregn  bits allready set\n&#modequ setb  1\n.equreg  anop\nr&n      equ   &n\n&n       seta  &n+1\n         aif   (&n le 16).equreg\n.equregn anop\n         aif   (&iezbits ne 0).equbitn  bits allready set\n         IEZBITS\n.equbitn anop\n         pop   print\n*-\n* Module start\n*-\n&mlbl    amode &amode\n&mlbl    rmode &rmode\n&mlbl    Csect\n         bakr  14,0\n         sam&amode\n*setup base register(s)\n         lr    &base1,r15\n         using &mlbl,&base1\n         aif   (n'&base eq 1).basen\n         lr    &base(2),&base(1)\n         alfi  &base(2),4096\n         using &mlbl.+4096,&base(2)\n         aif   (n'&base eq 2).basen\n         lr    &base(3),&base(2)\n         alfi  &base(3),4096\n         using &mlbl.+8192,&base(3)\n.basen   anop\n         j     &l.idn\n&d       setc  '&sysdate'\n&d1      setc  '&d'(1,2)\n&d2      setc  '&d'(4,2)\n&d3      setc  '&d'(7,2)\n         aif   ('&date' eq 'E').datee\n         ago   .daten\n.datee   anop\n&d       setc  '20&d3-&d1-&d2'\n.daten   anop\n         aif   (k'&text eq 0).id\n&n       seta  k'&text\n&s       setc  '&text'(2,&n-2)\n&mlbl._id dc    c'&mlbl &d &systime &s'\n         ago   .idl\n.id      anop\n&mlbl._id dc    c'&mlbl &d &systime'\n.idl     anop\n&mlbl._idl equ   *-&mlbl._id\n&l.idn   ds    0a\n.*-\n.* get working storage\n.*-\n         aif   ('&worksz' eq '').workn\n         mnote *,'obtain storage, length=&worksz,loc=&workloc'\n         Storage OBTAIN,length=&worksz,loc=&workloc\n         aif   (k'&workrg eq 0).workn\n         lr    &workrg,r1\n.* clear storage\n         aif   ('&workclr' ne 'C').clrstrn\n         lr    r0,r1                   target\n         lgfi  r1,&worksz              target length\n         la    r14,=al1(0)             source\n         la    r15,1                   source length\n         mvcl  r0,r14                  clear storage\n.clrstrn anop\n.*\n         aif   (k'&worklb eq 0).workn\n         using &worklb,&workrg\n.workn   anop\n.*-\n.* setup save area\n.*-\n         aif   (k'&sa eq 0).saven\n*setup save area\n         aif   ('&sa '(1,1) eq '*').saveint\n         la    r13,&sa\n         ago  .saven\n.saveint cnop  0,4\n&s       setc  '1'\n&n       seta  k'&sa\n         aif   (&n eq 1).savein2\n&s       setc  '&sa'(2,&n-1)\n.savein2 bas   r13,*+(&s*72)+4         address internal save area\n         ds    (&s*18)a                internal save area\n.saven   anop\n.*-\n.* setup prolog\n.*-\n         aif   (k'&prolog ne 0).prologl\n         aif   (k'&xprolog ne 0).prologv\n         ago   .prologn\n.prologl larl  r15,&prolog             prolog address\n         ago   .prologc\n.prologv l     r15,=v(&xprolog)        prolog address\n.prologc basr  r14,r15                 call prolog\n.prologn anop\n         j     &l.X\n.*-\n.* setup termination\n.*-\n* module termination\n&mlbl._X cnop  0,4\n.*-\n.* setup epilog\n.*-\n         aif   (k'&epilog eq 0 and k'&xepilog eq 0).epilogn\n         lr    r2,r15                  copy rc\n         aif   (k'&epilog ne 0).epilogl\n         aif   (k'&epilog ne 0).epilogl\n         aif   (k'&xepilog ne 0).epilogv\n         ago   .epilogn\n.epilogl larl  r15,&epilog             epilog address\n         ago   .epilogc\n.epilogv l     r15,=v(&xepilog)        epilog address\n.epilogc basr  r14,r15                 call epilog\n.epilogn anop\n         aif   ('&worksz' eq '').xworkn\n         mnote *,'release storage, length=&worksz,addr=&workrg'\n         lr    r2,r15\n         Storage RELEASE,length=&worksz,addr=(&workrg)\n         lr    r15,r2\n.xworkn  pr    ,\n* end of termination\n&l.X     ereg  0,1                     reload regs 0 and 1\n*-\n* End of module start\n*-\n         Mexit\n.*-\n.* return\n.*-\n.end     anop\n&s       setc  '&syslist(2)'\n&mlbl    $la   r15,&rc,&s,0\n         j     &#modname._X\n         Mend\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE986": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04a\\x00A\\x01\\x19\\x10\\x7f\\x01\\x19\\x10\\x7f\\x11 \\x00\\t\\x00\\t\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf7@@@'", "ispf": {"version": "04.97", "flags": 0, "createdate": "2019-04-17T00:00:00", "modifydate": "2019-04-17T11:20:41", "lines": 9, "newlines": 9, "modlines": 0, "user": "CBT-497"}, "text": "//***FILE 986 is from Willy Jensen, and contains programs to make   *   FILE 986\n//*           the TSO PUTLINE interface easier to program.  If you  *   FILE 986\n//*           are using the TSO PUTLINE interface for output from   *   FILE 986\n//*           TSO commands (instead of the TPUT interface), then    *   FILE 986\n//*           you can capture the output (and optionally display    *   FILE 986\n//*           it fullscreen.                                        *   FILE 986\n//*                                                                 *   FILE 986\n//*           email:  Willy Jensen<willy.h.jensen@outlook.com>      *   FILE 986\n//*                                                                 *   FILE 986\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXINSTRM": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00P\\x01\\t\\x10_\\x01\\x19\\x00O\\x17\\t\\x00\\n\\x00\\n\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2009-04-15T00:00:00", "modifydate": "2019-01-04T17:09:50", "lines": 10, "newlines": 10, "modlines": 0, "user": "DVL"}, "text": "//RXINSTRM PROC EXEC1='Z.PP.TSOPUTLN.LIB',EXEC2='Z.PP.TSOPUTLN.LIB',\n//             REXXDD='REXX',P='',DNBR=500,PGMN=IKJEFT1B\n//R        EXEC PGM=&PGMN,\n//         PARM='RXINSTRX REXXDD=&REXXDD &P',DYNAMNBR=&DNBR\n//SYSEXEC  DD DISP=SHR,DSN=&EXEC1\n//         DD DISP=SHR,DSN=&EXEC2\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//REXX     DD DDNAME=SYSIN\n//         PEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RXINSTRX": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00!\\x01\\x05\\x14\\x1f\\x01\\x19\\x00O\\x16\\x02\\x00A\\x00N\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2005-05-21T00:00:00", "modifydate": "2019-01-04T16:02:21", "lines": 65, "newlines": 78, "modlines": 0, "user": "DVL"}, "text": "/* ------------------------------------------------------------ REXX\n\n name  : RXINSTRX\n desc  : Allow a REXX program to be supplied instream, instead of\n         having to be a pds member.\n parms :\n input : Libref REXX contains the REXX program.\n sample JCL\n  //GO       EXEC PGM=IKJEFT1B,PARM=RXINSTRX\n  //SYSEXEC  DD  DISP=SHR,DSN=your.exec.lib\n  //         DD  DISP=SHR,DSN=rxinstrm.exec.lib\n  //SYSTSPRT DD  SYSOUT=*\n  //SYSTSIN  DD  DUMMY\n  //REXX     DD  *\n    say 'hello world'\n\n history:\n 2019-01-04  rename to RXINSTRM->RXINSTRX so it can be shipped in the\n             same lib as the procedure RXINSTRM.\n 2016-10-16  add parm REXDD=ddname\n 2014-03-30  major rewrite\n\n ------------------------------------------------------------------ */\n\n parse arg prm\n rxdd='REXX'\n if left(translate(prm),7)='REXXDD=' then do\n   parse var prm . '=' rxdd prm\n end\n Address TSO\n\n /*-------------------------------------------------------------------\n                            allocate temp pds\n --------------------------------------------------------------------*/\n tempname='zzz'right(time('s'),5,0)\n cc=bpxwdyn('alloc new rtddn(rxinddn) rtdsn(rxindsn)',\n             'da(&&rxinstrm('rxinname')',\n             'lrecl(80) recfm(f,b) blksize(0)',\n             'tracks space(8,8) dir(8) dsorg(po) unit(vio)')\n if cc<>0 then call close 8  \"Alloc temppds failed\" cc\n\n /*-------------------------------------------------------------------\n                write inline REXX to temp pds and run it\n --------------------------------------------------------------------*/\n \"Execio * diskr\" rxdd \"(stem data. finis)\"\n if rc<>0 then call close 8  \"Read data failed\" rc\n if pos('REXX',translate(data.1))=0 then,      /* add REXX if not     */\n   data.1=left(strip(data.1,'t'),72)'/*rexx*/' /* already there       */\n parse value 1+data.0 1+data.0 ' Exit 0' with n data.0 data.n\n \"execio\" data.0 \"diskw\" rxinddn \"(stem data. finis)\"   /* save */\n if rc<>0 then call close 8  \"write temp failed\" rc\n\n \"ex '\"rxindsn\"(\"rxinname\")' '\"prm\"'\"\n if datatype(rc)='NUM' then if rc<>0 then call close rc\n call close 0\n\n /*-------------------------------------------------------------------\n                                terminate\n --------------------------------------------------------------------*/\nClose:\n cc=BpxWdyn(\"free dd(\"rxinddn\")\")\n parse arg _rc _msg\n if _msg<>'' then say _msg\n _rc=word(_rc 0,1)\n Exit _rc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSOPARM": {"ttr": 533, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00I\\x01\\x182O\\x01\\x182_\\x16\\x06\\x00\\x1e\\x00\\x1d\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-11-20T00:00:00", "modifydate": "2018-11-21T16:06:49", "lines": 30, "newlines": 29, "modlines": 0, "user": "DVL"}, "text": "         Macro\n.*   r1% -> command buffer\n.*   Command buffer layout:\n.*    al2(length of buffer incl prefix)\n.*    al2(offset = lmodname +1 -> text from call)\n.*    clx lmodname\n.*    cl1 blank\n.*    clx text from call\n&mlbl    TsoParm &a,&l\n         lclc  &lbl\n&lbl     setc  'tp&sysndx'\n&mlbl    sr    r15,r15\n         icm   r1,15,0(r1)             -> cmdbfr\n         jz    &lbl.x\n         lh    r15,0(,r1)              buffer length\n         clfi  r15,5\n         jl    &lbl.x\n         sh    r15,2(r1)               minus offset to text\n         ahi   r15,-4                  minus prefix length\n         ah    r1,2(r1)                lmod length\n         aif   (k'&l eq 0).b           don't check length\n         clfi  r15,&l                  check length\n         jnh   *+8\n         lgfi  r15,&l\n.b       bctr  r15,0                   mch length\n         mvc   &a.(*-*),4(r1)          copy text\n         ex    r15,*-6\n         la    r15,1(,r15)             reinstate text length\n&lbl.x   equ   *\n         Mend\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TSOPUTL$": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00W\\x01\\x19\\x00?\\x01\\x19\\x00O\\x11\\x19\\x00[\\x00e\\x00\\x00\\xe6\\xd1`\\xc9\\xe5\\xd7@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2019-01-03T00:00:00", "modifydate": "2019-01-04T11:19:57", "lines": 91, "newlines": 101, "modlines": 0, "user": "WJ-IVP"}, "text": "//WJTSOPUT JOB (1),'WJENSEN',CLASS=A,MSGLEVEL=(1,1),MSGCLASS=T,\n//       REGION=64M,COND=(0,LT)\n//*\n//       SET ME=WJENSEN\n//       JCLLIB ORDER=WJENSEN.LIB.CNTL\n//*\n//*\n//* Test the TSOPUTLN macro\n//*\n//ASM    EXEC ASMACL,PARM.C='TERM'\n//C.SYSLIB   DD DSN=WJENSEN.TSOPUTLN.LIB,DISP=SHR\n//           DD DSN=SYS1.MACLIB,DISP=SHR\n//           DD DSN=SYS1.MODGEN,DISP=SHR\n//C.SYSTERM  DD SYSOUT=*\n//C.SYSIN    DD *\n**asma syslib WJENSEN.TSOPUTLN.LIB\n**asma opt    term\n*-\n*\n*    Test TSO putline - put pgm parameter\n*\n*-\n         print nogen\nTSOPUTL$ #Module rmode=24\n         TSOParm msg\n         ltr   r5,r15                  r15 = text length\n         jnz   b\n         #module exit,rc=1\nb        ds    0h\n         print gen\n\n*- put parm\n         TsoPutln msg,(r5)\n         ltr   r15,r15\n         jnz   err\n\n*- put literal 1\n         TsoPutln 'literal text 1'\n         ltr   r15,r15\n         jnz   err\n\n*- put literal 2\n         TsoPutln =c'literal text 2'\n         ltr   r15,r15\n         jnz   err\n\n*- put label\n         TsoPutln text\n         ltr   r15,r15\n         jnz   err\n*\n         print nogen\nok       #module exit\nerr      abend 111\ntext     dc    c'kilroy was here'\nmsg      ds    cl256\n         ltorg\n         END\n//L.SYSLMOD  DD DSN=&&LOADLIB(TSOPUTL$)\n//*\n//IVP1     EXEC RXINSTRM\n//STEPLIB  DD DISP=SHR,DSN=&&LOADLIB\n//SYSPRINT DD SYSOUT=*\n//REXX     DD *\n\n text = 'testing TSO call'\n say 'TSO call with text \"'text'\"'\n zz=outtrap('ls1.')\n \"TSOPUTL$\" text\n zz=outtrap('off')\n say 'rc='rc\n if rc<>0 then exit xmsg('**** Bad rc ******',20)\n do n=0 to ls1.0\n   say 'ls1.'n '-> \"'ls1.n'\"'\n end\n if ls1.1<>text then exit xmsg('**** Bad list ******',20)\n drop ls1.\n\n say ''\n say 'TSO call with null'\n zz=outtrap('ls2.')\n \"TSOPUTL$\"\n zz=outtrap('off')\n say 'rc='rc\n do n=0 to ls2.0\n   say 'ls2.'n '-> \"'ls2.n'\"'\n end\n drop ls2.\n exit 0\n\nXMsg: if arg(1)<>'' then say arg(1);return word(arg(2) 0,1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSOPUTL#": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00T\\x01\\x19\\x00?\\x01\\x19\\x00O\\x15\\x03\\x00\\\\\\x00e\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2019-01-03T00:00:00", "modifydate": "2019-01-04T15:03:54", "lines": 92, "newlines": 101, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBM JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//*\n//       SET ME=SBGOLOB\n//       JCLLIB ORDER=SBGOLOB.CBT497.FILE986\n//*\n//*\n//* Test the TSOPUTLN macro\n//*\n//ASM    EXEC ASMACL,PARM.C='TERM'\n//C.SYSLIB   DD DSN=SBGOLOB.CBT497.FILE986,DISP=SHR\n//           DD DSN=SYS1.MACLIB,DISP=SHR\n//           DD DSN=SYS1.MODGEN,DISP=SHR\n//C.SYSTERM  DD SYSOUT=*\n//C.SYSIN    DD *\n**asma syslib SBGOLOB.CBT497.FILE986\n**asma opt    term\n*-\n*\n*    Test TSO putline - put pgm parameter\n*\n*-\n         print gen\nTSOPUTL$ #Module rmode=24\n         TSOParm msg\n         ltr   r5,r15                  r15 = text length\n         jnz   b\n         #module exit,rc=1\nb        ds    0h\n         print gen\n\n*- put parm\n         TsoPutln msg,(r5)\n         ltr   r15,r15\n         jnz   err\n\n*- put literal 1\n         TsoPutln 'literal text 1'\n         ltr   r15,r15\n         jnz   err\n\n*- put literal 2\n         TsoPutln =c'literal text 2'\n         ltr   r15,r15\n         jnz   err\n\n*- put label\n         TsoPutln text\n         ltr   r15,r15\n         jnz   err\n*\n         print nogen\nok       #module exit\nerr      abend 111\ntext     dc    c'kilroy was here'\nmsg      ds    cl256\n         ltorg\n         END\n//L.SYSLMOD  DD DSN=&&LOADLIB(TSOPUTL$)\n//*\n//IVP1     EXEC RXINSTRM\n//STEPLIB  DD DISP=SHR,DSN=&&LOADLIB\n//SYSPRINT DD SYSOUT=*\n//REXX     DD *\n\n text = 'testing TSO call'\n say 'TSO call with text \"'text'\"'\n zz=outtrap('ls1.')\n \"TSOPUTL$\" text\n zz=outtrap('off')\n say 'rc='rc\n if rc<>0 then exit xmsg('**** Bad rc ******',20)\n do n=0 to ls1.0\n   say 'ls1.'n '-> \"'ls1.n'\"'\n end\n if ls1.1<>text then exit xmsg('**** Bad list ******',20)\n drop ls1.\n\n say ''\n say 'TSO call with null'\n zz=outtrap('ls2.')\n \"TSOPUTL$\"\n zz=outtrap('off')\n say 'rc='rc\n do n=0 to ls2.0\n   say 'ls2.'n '-> \"'ls2.n'\"'\n end\n drop ls2.\n exit 0\n\nXMsg: if arg(1)<>'' then say arg(1);return word(arg(2) 0,1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSOPUTL@": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00Y\\x01\\x19\\x00O\\x01\\x19\\x00O\\x17\\x07\\x00(\\x00\\x03\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2019-01-04T00:00:00", "modifydate": "2019-01-04T17:07:59", "lines": 40, "newlines": 3, "modlines": 0, "user": "DVL"}, "text": ")F ASM  TSOPUTLN macro - TSO putline not needing setup.\n\nThe  macro is  self-contained in  that it  does not  need an  external\nsubroutine, the subroutine is generated  internally at the first macro\nexpansion.\n\nThe  macro  works even  if  used  in a  mdule  started  with the  BAKR\ninsteuction, because the generated subroutine uses EXTRACT and LOCASCB\nto get the  neccessary runtime info, it does not  rely on tracing back\nthrough save areas.\n\nIt  may cause  a slight  performance  degradation as  the module  must\nformat the message string, so GETMAINs and FREEMAINs a work area. This\nhas the  added benefit  of making the  subroutine fully  reentrant and\nresuable.\n\nSyntax\n\n TSOPUTLN address,length\n          address     Address of text. Label or (reg). Required.\n          length      Length of text. Number or (reg). Default is\n                      length of 'address'.\n\nSamples\n\n           la    r5,120\n           TsoPutln msg,(r5)\n\n           TsoPutln text\n\n           TsoPutln 'Just another fine day'\n\n  msg      ds    cl256\n  text     dc    c'kilroy was here'\n\nNote\n\nTSOPUTLN does not work when used in a REXX function, i.e. n=PGM()\n)X\n)O\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TSOPUTLN": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x19\\x00O\\x01\\x19\\x00O\\x16D\\x00\\x82\\x00\\x82\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2019-01-04T00:00:00", "modifydate": "2019-01-04T16:44:00", "lines": 130, "newlines": 130, "modlines": 0, "user": "DVL"}, "text": "         Macro\n.*-\n.* TSO PUTLINE frontend\n.* This version contains the TPUTLN module internally, it is\n.* expanded at the first occurrence of the TPUTLN macro.\n.* It may cause a slight performance degradation as the module\n.* is fully reentrant and thus GETMAINs a work area.\n.*\n.* Syntax   TSOPUTLN address,length\n.*  address     address of text\n.*  length      length of text\n.*\n&mlbl    TSoPutLn &print=nogen,&dsects=YES\n         lcla  &n\n         lclc  &q,&l,&sect\n         gblb  @@tsoputln\n&l       setc  'tp&sysndx'\n&sect    setc  '&sysect'\n&mlbl    $la   r1,&syslist(1)\n         aif   (n'&syslist eq 1 and '&syslist(1)'(1,1) eq '''').litl\n         $la   r0,&syslist(2),l'&syslist(1)\n         ago   .call\n.litl    anop\n&n       seta  k'&syslist(1)-2\n         la    r0,&n\n.call    l     r15,=v(TSOPUTLN)\n         basr  r14,r15\n         aif   (&@@tsoputln eq 0).module\n         mexit\n.*-\n.* module\n.*-\n.module  anop\n&@@tsoputln setb 1\n         j     &l.n\n         ltorg\n&l.n     ds    0a\n         push  using\n         push  print\n         print &print\n*-\n* TSOPUTLN module\n*-\nTSOPUTLN Csect\n         save  (14,12)\n         lr    r12,r15\n         Using TSOPUTLN,r12\n         Using @tputblk,r10\n         lr    r2,r1                   copy text/buffer address\n         lr    r3,r0                   copy text length\n*- get storage\n         la    r9,@tputblkl+4(r3)      blk+text length\n         Getmain R,lv=(r9),loc=31\n         lr    r10,r1\n         lr    r0,r10\n         la    r1,@tputblkl\n         la    r14,=al1(0)\n         la    r15,1\n         mvcl  r0,r14\n         st    r10,8(,r13)             chain\n         st    r13,4(,r10)               save\n         lr    r13,r10                     areas\n*- copy data\n         la    r1,4(,r3)               set length\n         sll   r1,16                   to upper halfword\n         st    r1,@tputlen             store as prefix\n         la    r14,@tputtext           target address\n         lr    r15,r3                  copy length\n         mvcl  r14,r2                  copy text\n*- obtain address of the upt through the extract facility\n         la    r0,@tputiopl\n         EXTRACT (0),'S',FIELDS=(PSB,ASID),MF=(E,@tputextr)\n         l     r1,@tputiopl\n         mvc   @tputupta,pscbupt-pscb(r1)\n*- obtain address of the ect from the lwa control block\n         l     r1,@tputiopl+4          asid\n         LOCASCB ASID=(1)\n         l     r1,ascbasxb-ascb(,r1)   -> asxb\n         l     r1,asxblwa-asxb(,r1)    -> lwa\n         mvc   @tputecta,lwapect-lwa(r1) get ect address\n*- do putline\n         xc    @tputecb,@tputecb\n         xc    @tputiopl(16),@tputiopl\n         l     r14,@tputupta\n         l     r15,@tputecta\n         PUTLINE PARM=@tputmfl,UPT=(r14),ECT=(r15),ECB=@tputecb,       c\n               OUTPUT=(@tputlen,TERM,SINGLE,DATA),MF=(E,@tputiopl)\n         lr    r5,r15\n*- release storage\n         l     r13,4(,r13)             <- callers save area\n         Freemain R,lv=(r9),a=(r10)\n*- back\n         lr    r15,r5                  set return code\n         lm    r2,r12,28(r13)          reload gregs\n         l     r14,12(,r13)            return address\n         br    r14                     and return\n         ltorg\n         drop  r10,r12\n*-\n* TSOPUTLN local dsects\n*-\n@tputblk  dsect\n@tputsa1  ds    18a\n@tputextr EXTRACT MF=L\n*         org   @tputextr\n@tputecb  ds    a\n@tputecta ds    a\n@tputupta ds    a\n*         org\n@tputiopl ds    4a\n@tputmfl  PUTLINE MF=L\n@tputmsgl ds    a\n@tputmsg  ds    cl255\n@tputlen  ds    a\n@tputtext ds    0c\n@tputblkl equ   *-@tputblk\n         aif   ('&dsects' ne 'YES').dsctn\n*-\n* TSOPUTLN IBM dsect expansions (if requested)\n*-\n         IKJPSCB\n         IHAASCB\n         IHAASXB\n         IKJEFLWA\n.dsctn   anop\n         pop   print\n.* rejoin csect\n&sect    Csect\n         pop  using\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT986/FILE986.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT986", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}