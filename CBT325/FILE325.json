{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011753000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 2410226, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 10, "INMDSNAM": "CBT.V500.FILE325.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 2410226, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 2410226, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE325.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00&\\x05'", "DS1TRBAL": "b'\\xab2'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b\"X\\xf4\\xfd\\xd0\\x00\\x00\\x02v\\x00\\x01\\x02x\\x00\\t\\x00'\"", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04W\\x007\\x01\\x13\"o\\x01\\x13\"o\\x14 \\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf7@@@'", "ispf": {"version": "04.87", "flags": 0, "createdate": "2013-08-14T00:00:00", "modifydate": "2013-08-14T14:20:37", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-487"}, "text": "REGULAR CBT TAPE - VERSION 487    FILE:  325\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT487.FILE325\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 23 MEMBERS COUNTED; CUMULATIVE SIZE IS 22,236 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   08/14/13    14:20:36    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$CONTENT": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87(\\x7f\\x00\\x87(\\x7f\\x12\\x00\\x00\\xbd\\x00\\xbd\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-10-14T00:00:00", "modifydate": "1987-10-14T12:00:00", "lines": 189, "newlines": 189, "modlines": 0, "user": "FILE325"}, "text": "WELLS FARGO BANK Programs and TSO commands donated to SHARE CBT tape.\n                 This is a COMPLETE REPLACEMENT of the previous file.\n                 All items current as of September 1986, MVS/XA 2.1.5.\n\n           T H I S   D A T A S E T   I S   N O T   N U M B E R E D .\n\n           T H E R E   I S   D A T A   I N   C O L U M N S   73  TO  80.\n\n$CONTENT - You are looking at it.\n (mm/yy)   <=== Date of last update is shown below member name.\n\nDARTH    - The 'Dump Activity Reporter / Tape Handler' utility that\n (06/86)   processes SYS1.DUMP datasets. DARTH runs as a started task\n           that wakes up every 15 minutes to check all defined dump\n           datasets. When a dump is present, a tape is dynamically\n           allocated, the dump is offloaded, and the dataset is reset.\n           Then a control dataset is updated to record the system id,\n           date, and time where the dump occurred, the tape volume\n           idetification, and the actual title from the dump.\n\nIEFUTL   - Wells Fargo's version of the SMF User Time Limit exit.\n (02/87)   You will NOT be able to use this code as distributed because\n           some installation dependent, proprietary code is not shipped.\n             This is an example of how to DISCONNECT A TSO USER rather\n           than cancel when wait time is exceeded. The user then has\n           however much time you allow in your RECONLIM= parameter to\n           LOGON RECONNECT before VTAM automatically cancels the address\n           space. The terminal becomes immediately available for use by\n           other ids, and the disconnected id remains swapped out.\n             See the code that refers to VTAM command: V NET,TERM, ...\n           NOTE ===> This performs the same function through operator\n             command that any user can invoke through keyboard action.\n             If you are not familiar with CONDITIONAL LOGOFF, read\n             \"Invoking Unformatted System Service Type(COND) To Force a\n             Reconnect Environment\" in the TSO Terminal User's Guide.\n\nINMXZ01  - TSO/E TRANSMIT Initialization exit to prevent transmission\n (08/85)   to non-existant TSO userids on same node as sender (JES2\n           EXIT 13 handles NJE transmissions from other nodes) and\n           thereby keep unreceivable data off JES2 spool.\n             The exit searches the address list for a local node, then\n           calls ACF2 to verify existence of user. If not valid, the\n           userid is removed from the address list and an error message\n           is issued to the sender.\n           NOTE:  REQUIRES PTF UZ39974 (OR EQUIVALENT) BE INSTALLED\n                  FOR CORRECT FUNTIONING OF \"UNCHAINING\" INVALID USERID.\n\nINMXZ02  - TSO/E TRANSMIT Termination exit to issue equivalent of\n (01/85)   \"$HASP549 MAIL FROM\" message to notify receiving users of\n           local node transmission. (Local transmissions do not pass\n           through JES2 EXIT 13).\n             The exit searches the address list for a local node, then\n           verifies the output target is JES SYSOUT and transmission has\n           successfully completed. \"SEND '$HASP549...',USER=(),LOGON\" is\n           issued via SVC34.\n\nJESLOGON - A program to allow a TSO user to logon to any SECONDARY\n (03/84)   subsystem. It acts as a one-time front end for the standard\n           TMP, and is intended to be executed by the logon procedure.\n           Job submissions and PSO (process sysout) requests are also\n           handled by the secondary JES.\n\nJESMAXCC - A pair of JES2 (SP2.1.5) exits that add text to the $HASP165\n (06/86)   message generated by NOTIFY= on the job card or by the JES2\n           /*NOTIFY control card. If the job does not abend, the maximum\n           condition code of all executed steps is added. If the job\n           abends, the system or user abend code is added:\n             $HASP165 yourjob ENDED AT node - MAX COND CODE 0000\n             $HASP165 yourjob ENDED AT node - ABENDED USER xxx\n             $HASP165 yourjob ENDED AT node - CANCELLED SYSTEM 222\n\nNOTE     - Two CLISTs, one ISPF panel, and a help entry that provide a\n (01/86)   facility to deliver PROFS NOTEs from a TSO session:\n             NOTE     - the driving CLIST, invokes WFBNOTE and NOTEIMAC\n             NOTEIMAC - PDF EDIT initial macro for special formatting\n             WFBNOTE  - ISPF panel to collect data for NOTE CLIST\n             NOTEHELP - help entry for NOTE CLIST (rename to ==> NOTE)\n\n           The NOTE command procedure (CLIST) uses the ISPF/PDF\n           editor to build and format mail \"notes\", then sends them\n           to PROFS or TSO users.  NOTE uses ISPF Dialog Services to\n           collect information by displaying panels, therefore NOTE\n           must be executed while ISPF is active.\n\n           This facility was originally written to use the TSO TRANSMIT\n           command for data transmission, but because PROFS can not\n           decipher TRANSMIT control tags, NOTE now uses a specially\n           modified version of the PRINTOFF command. This PRINTOFF,\n           which allows DEST(node.user), is provided in this package.\n\nOPCON    - OPerator CONsole monitor      MODIFIED FOR WFB 12/83\n (09/87)                                 TAKEN FROM CBT FILE338\n                   S   P   Y             (NAME CHANGED TO \"OPCON\" IN\n                                         THE CODE, BUT COMMENTS STILL\n                                         REFER TO \"SPY\")\n\n           This program displays the contents of all active GRAPHIC\n           operator's consoles on a TSO CRT. The operator's screen can\n           be either a 327X or a 370-168 integrated console. The TSO\n           user can use any 327X terminal.\n\n    V3.3.2 - CORRECT support for 327X Model 2 and Model 3 console.\n\n    V3.3.1 - CHANGE CONSOLE ASID to 7 due to CATALOG ASID w/ DFP V2.\n\n      V3.3 - ADD support for viewing consoles that have 3270 extended\n             field attributes (e.g. 3179, 3180, 3279-3B, etc.).\n           - MAKE OPCON non-swapable.\n           - CHANGE CONSOLE ASID TO 6 for XA (S/370 CONASID is 5).\n\n      V3.2 - ELIMINATE special character required to precede OS cmd\n           - ELIMINATE secret auth SVC, restore MODESET and SVC34\n           - CORRECT buffer address problem with line 1 of display\n           - CORRECT loop count for UCM build routine\n           - ADD subcommand A.. (AUTO W.. AFTER command entry)\n           - ADD check at initialization for TSO OPER authority\n           - MAKE command entry area non-display until passwd given\n           - MAKE \"oper redisplay\" area modifiable for reentry\n           - FILL both entry areas with nulls to allow char insert\n           - REDISPLAY last cmd entered by user (instead of oper)\n           - MOVE console status table to separate CSECT\n           - RESTRUCTURE the help screen and use upper/lower case\n           - PROVIDE TSO HELP entry as comments at end of source\n\nPRINTOFF - The widely modified IPO supplied TSO command to print a\n (01/87)   dataset, with yet more functions added. After researching\n           all versions on the CBT tape, Wells Fargo created this\n           version from source from four separate files. We believe this\n           contains all features currently available from all sources.\n\n           R3 - * CORRECT ERROR, 'NOHEAD' miscounted 4 lines on page 1\n                * ADD ASA keyword to accept CC when RECFM not ..A\n                * ADD NOCC keyword alias of SINGLESPACE\n                * ADD UDKFONT(...) keyword for XEROX 2700/3700 fonts\n                * DELETE old lines marked *DELETED or 'DELETED CODE'\n\n           R2 - * CORRECT ERROR, 'NOHEAD' caused blank first page.\n                * CORRECT ERRORS in length of TEXTG through TEXTJ.\n                * INCREASE input record limit to 32,760.\n                * CHANGE DSNAME POSIT to DSTHING to allow for DDN().\n                * CHANGE DEST keyword to accept 8 character value.\n                * CHANGE DEST keyword to accept NODE and USERID.\n                * ADD DDNAME(...) keyword to allow temp or VIO datasets.\n                * ADD UNIT(...) keyword for use with VOLUME(...).\n                * ADD 'VOLUME: volser' to heading when specified.\n     +--------> * ADD Time and 'Monthname Day, Year' to DSN heading.\n     :          * ADD NOMSGS keyword to stop non-error msgs to terminal.\n     :          * ADD DSECT=YES to CVT macro for clean XA assembly.\n     :          * MOVE all PUTLINE text to separate messages CSECT.\n     :            --- (Following changes are WFB specific) ---\n     :          * MAKE WFB default FORM($TST) in PARSE macro.\n     :\n     +-- NOTE ==> The Time-Date routine IKJEFLPA normally resides\n                  ONLY in SYS1.AOST4. This library MUST be included\n                  in the linkedit SYSLIB for proper resolution.\n\nROOM     - (This version is updated to JES2 SP2.1.5 level.)\n (05/86)   A TSO command to allow a user to change the \"room number\"\n           field in the JES JCT for the TSO session. This command is\n           necessary because the room number field is not supported by\n           UADS (and the field is overlayed by Wells Fargo accounting\n           information during logon). ROOM makes it easy for the user\n           to specify delivery information (printed on JES header and\n           trailer pages) for all SYSOUT created during the session,\n           including spun datasets.\n\n           This code can serve as a model for allowing a TSO user to\n           change through authorized means any otherwise protected\n           information in the JES JCT or similar control blocks.\n\nVTAMCHK  - This program is intended to be started automatically after\n (03/84)   an IPL (by COMMNDxx). It is used to start VTAM applications\n           or issue other commands in an orderly sequence after VTAM\n           is up and running.\n\n           VTAMCHK has the option to delay between issuing each command\n           because some environments themselves have time dependencies,\n           such as $SLOGON1   (wait for initialization)\n                   $SN,A=xx\n           The source has a sample of the procedure and some commands.\n\nVTOCLIST - A corrected version of the GTE VTOCLIST program taken from\n (07/86)   the CBT tape. Corrections include:\n           - Provide support for 3380 Model E devices.\n           - Provide support for DF/EF VSAM files which are allowed to\n             have more than 16 extents.\n           - Two corrections to print extent numbers greater than 99.\n           - A correction to print the \"last ref data\" and \"use count\".\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$PRINTOF": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00!\\x01\\x13!O\\x01\\x13\"o\\x14\\x17\\x00O\\x00*\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2013-08-02T00:00:00", "modifydate": "2013-08-14T14:17:21", "lines": 79, "newlines": 42, "modlines": 0, "user": "SBGOLOB"}, "text": "Notes about the PRINTOFF TSO command   (for z/OS)\n----- ----- --- -------- --- -------\n\nThe PRINTOFF TSO command, which prints a dataset to SYSOUT, has been\na favorite of programmers for years.  PRINTOFF was originally an IBM\n\"unsupported\" program distributed with the IPO and CBIPO distribution\nfor new MVS systems.  Officially, it has now been replaced by IBM's\nPRINTDS TSO command, which has slightly different syntax:\n\nPRINTOFF  'dataset.name'\n\nPRINTDS   DSN('dataset.name')\n\nHELP for this version of PRINTOFF is included in the source code,\nand is skipped over during assembly, via conditional assembly\ninstructions.  So you should copy the HELP stuff to your SYSHELP\nlibrary from within the source code.\n\nThis version of PRINTOFF, which was last (significantly) modified by\nSam Lepore of Wells Fargo Bank in 1986, produces the date and time in\nits report and has similar bells and whistles to IBM's current PRINTDS\nprogram, which of course, came out later.\n\nI ran PRINTOFF recently.  The date came out as 1913.  (This is bad.)\n\nTherefore..........\n\nThe PRINTOFF program was fixed in two ways.  (Second one is better.)\n\n   Member PRINTOFF represents the second fix. (Use this one.)\n   Member PRINTOFX represents the first fix.\n\n   1.  I fixed it first.  See all the notes below.  The time stamp\n       was dependent on two IBM modules, IKJEFLPA and IKJEFLPB.\n       These have since been updated by IBM and are (to my\n       knowledge) incompatible with PRINTOFF as it existed in 1986\n       or so.  Therefore, I did two things.  First, if you have an\n       existing load module, you can zap the first byte of module\n       IKJEFLPB from X'19' and change it to X'20'.  See member\n       PROF$ZAP which does this.  To fix the source code so you\n       can reassemble it, I disassembled the two modules (old\n       versions) and included them in the source code here, after\n       (of course) changing the aforesaid X'19' to X'20'.\n\n   2.  Bill Godfrey's old routine called JULSUB supplies the same\n       date information that the IBM modules IKJEFLPA and IKJEFLPB\n       supply.  The JULSUB routine is public-domain.  Therefore,\n       the second fix was to substitute a call to JULSUB for the\n       call to IKJEFLPA.  This is the preferred fix, and the source\n       member PRINTOFF reflects this fix.\n\nSam Golob   2013/08/14   sbgolob@cbttape.org\n\n---------------------------------------------------------------------\n\nAll the following notes apply to the first fix, above.\n\nUpon some investigation, I found how and where the date is created.\nIt is created by IBM module IKJEFLPA, which calls IBM module IKJEFLPB,\nwhose first byte has a hard-coded X'19' that has to be zapped to a\nhard-coded X'20'.  Now that I found the problem, I got a second\nproblem.  The new version of IKJEFLPA (and IKJEFLPB) which IBM NOW\ndistributes, is not compatible with this program's CALL.  So the\nPRINTOFF module, as (formerly) presented here, is not reassemblable on\ncurrent systems, with their new IKJEFLPA and IKJEFLPB.\n\nTherefore I disassembled the old versions of IKJEFLPA and IKJEFLPB\nwhich ARE compatible with PRINTOFF, included the zap for the 20xx\ndates, and presented the entire package as one pds member to submit\nfor assembly and linkedit.  That is the PRINTOFX member that you see\nhere.  Just make the changes for your own installation, and assemble.\nThe HELP member is also part of this member, and is skipped over, in\nthe assembly, using conditional assembly instructions.  So you can\njust copy the HELP part to your own SYSHELP library as member\nPRINTOFF with all its aliases, and then you're set.\n\nSam Golob   2013/08/02   sbgolob@cbttape.org\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE325": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04W\\x000\\x01\\x13\"o\\x01\\x13\"o\\x14 \\x01\\x19\\x01\\x19\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf7@@@'", "ispf": {"version": "04.87", "flags": 0, "createdate": "2013-08-14T00:00:00", "modifydate": "2013-08-14T14:20:30", "lines": 281, "newlines": 281, "modlines": 0, "user": "CBT-487"}, "text": "//***FILE 325 IF FROM WELLS FARGO BANK AND CONTAINS THE FOLLOWING   *   FILE 325\n//*           PROGRAMS AND TSO COMMANDS.  ALL CODE IS CURRENT AS OF *   FILE 325\n//*           SEP 1986,  MVS / XA 2.1.5.                            *   FILE 325\n//*           THIS FILE IS IN IEBUPDTE SYSIN FORMAT.                *   FILE 325\n//*           SEE THE MEMBER CALLED $$DOC FOR ADDITIONAL            *   FILE 325\n//*           INFORMATION.                                          *   FILE 325\n//*                                                                 *   FILE 325\n//*           (Note:  PRINTOFF was fixed for z/OS.)                 *   FILE 325\n//*                                                                 *   FILE 325\n//*         DARTH    - THE 'DUMP ACTIVITY REPORTER / TAPE HANDLER'  *   FILE 325\n//*                    UTILITY THAT PROCESSES SYS1.DUMP DATASETS.   *   FILE 325\n//*                    DARTH RUNS AS A STARTED TASK THAT WAKES UP   *   FILE 325\n//*                    EVERY 15 MINUTES TO CHECK ALL DEFINED DUMP   *   FILE 325\n//*                    DATASETS.  WHEN A DUMP IS PRESENT, A TAPE    *   FILE 325\n//*                    IS DYNAMICALLY ALLOCATED, THE DUMP IS        *   FILE 325\n//*                    OFFLOADED, AND THE DATASET IS RESET.  THEN   *   FILE 325\n//*                    A CONTROL DATASET IS UPDATED TO RECORD THE   *   FILE 325\n//*                    SYSTEM ID, DATE, AND TIME WHERE THE DUMP     *   FILE 325\n//*                    OCCURRED, THE TAPE VOLUME IDETIFICATION,     *   FILE 325\n//*                    AND THE ACTUAL TITLE FROM THE DUMP.          *   FILE 325\n//*                                                                 *   FILE 325\n//*         IEFUTL   - WELLS FARGO'S VERSION OF THE SMF USER TIME   *   FILE 325\n//*                    LIMIT EXIT.  YOU WILL NOT BE ABLE TO USE     *   FILE 325\n//*                    THIS CODE AS IT STANDS BECAUSE OF SOME       *   FILE 325\n//*                    INSTALLATION DEPENDENCIES THAT ARE NOT       *   FILE 325\n//*                    SHIPPED.                                     *   FILE 325\n//*                                                                 *   FILE 325\n//*                      THIS IS AN EXAMPLE OF HOW TO DISCONNECT A  *   FILE 325\n//*                    TSO USER RATHER THAN CANCEL WHEN WAIT TIME   *   FILE 325\n//*                    IS EXCEEDED.  THE USER THEN HAS HOWEVER      *   FILE 325\n//*                    MUCH TIME AS YOU ALLOW IN YOUR RECONLIM=     *   FILE 325\n//*                    PARAMETER TO LOGON RECONNECT BEFORE VTAM     *   FILE 325\n//*                    AUTOMATICALLY CANCELS THE ADDRESS SPACE.     *   FILE 325\n//*                    THE TERMINAL BECOMES IMMEDIATELY AVAILABLE   *   FILE 325\n//*                    FOR USE BY OTHER IDS, AND THE DISCONNECTED   *   FILE 325\n//*                    ID REMAINS SWAPPED OUT.                      *   FILE 325\n//*                                                                 *   FILE 325\n//*                      SEE THE CODE THAT REFERS TO VTAM COMMAND:  *   FILE 325\n//*                      V NET,TERM, ...                            *   FILE 325\n//*                                                                 *   FILE 325\n//*                    NOTE ===> THIS PERFORMS THE SAME FUNCTION    *   FILE 325\n//*                      THROUGH OPERATOR COMMAND THAT ANY USER     *   FILE 325\n//*                      CAN INVOKE THROUGH KEYBOARD ACTION.  IF    *   FILE 325\n//*                      YOU ARE NOT FAMILIAR WITH CONDITIONAL      *   FILE 325\n//*                      LOGOFF, READ \"INVOKING UNFORMATTED SYSTEM  *   FILE 325\n//*                      SERVICE TYPE(COND) TO FORCE A RECONNECT    *   FILE 325\n//*                      ENVIRONMENT\" IN THE TSO TERMINAL USER'S    *   FILE 325\n//*                      GUIDE.                                     *   FILE 325\n//*                                                                 *   FILE 325\n//*         INMXZ01  - TSO/E TRANSMIT INITIALIZATION EXIT TO        *   FILE 325\n//*                    PREVENT TRANSMISSION TO NON-EXISTENT TSO     *   FILE 325\n//*                    USERIDS ON SAME NODE AS SENDER (JES2 EXIT 13 *   FILE 325\n//*                    HANDLES NJE TRANSMISSIONS FROM OTHER NODES)  *   FILE 325\n//*                    AND THEREBY KEEP UNRECEIVABLE DATA OFF JES2  *   FILE 325\n//*                    SPOOL.                                       *   FILE 325\n//*                                                                 *   FILE 325\n//*                      THE EXIT SEARCHES THE ADDRESS              *   FILE 325\n//*                    LIST FOR A LOCAL NODE, THEN CALLS            *   FILE 325\n//*                    ACF2 TO VERIFY EXISTENCE OF USER.            *   FILE 325\n//*                    IF NOT VALID, THE USERID IS                  *   FILE 325\n//*                    REMOVED FROM THE ADDRESS LIST AND            *   FILE 325\n//*                    AN ERROR MESSAGE IS ISSUED TO THE            *   FILE 325\n//*                    SENDER.                                      *   FILE 325\n//*                    NOTE:  REQUIRES PTF UZ39974 (OR EQUIVALENT)  *   FILE 325\n//*                           BE INSTALLED FOR CORRECT FUNTIONING   *   FILE 325\n//*                           OF \"UNCHAINING\" INVALID USERID.       *   FILE 325\n//*                                                                 *   FILE 325\n//*         INMXZ02  - TSO/E TRANSMIT TERMINATION EXIT TO ISSUE     *   FILE 325\n//*                    EQUIVALENT OF \"$HASP549 MAIL FROM\" MESSAGE   *   FILE 325\n//*                    TO NOTIFY RECEIVING USERS OF LOCAL NODE      *   FILE 325\n//*                    TRANSMISSION.  (LOCAL TRANSMISSIONS DO NOT   *   FILE 325\n//*                    PASS THROUGH JES2 EXIT 13).                  *   FILE 325\n//*                                                                 *   FILE 325\n//*                      THE EXIT SEARCHES THE ADDRESS LIST FOR A   *   FILE 325\n//*                    LOCAL NODE, THEN VERIFIES THE OUTPUT TARGET  *   FILE 325\n//*                    IS JES SYSOUT AND TRANSMISSION HAS           *   FILE 325\n//*                    SUCCESSFULLY COMPLETED.  \"SEND               *   FILE 325\n//*                    '$HASP549...',USER=(),LOGON\" IS ISSUED VIA   *   FILE 325\n//*                    SVC34.                                       *   FILE 325\n//*                                                                 *   FILE 325\n//*         JESLOGON - A PROGRAM TO ALLOW A TSO USER TO LOGON TO    *   FILE 325\n//*                    ANY SECONDARY SUBSYSTEM.  IT ACTS AS A       *   FILE 325\n//*                    ONE-TIME FRONT END FOR THE STANDARD TMP,     *   FILE 325\n//*                    AND IS INTENDED TO BE EXECUTED BY THE        *   FILE 325\n//*                    LOGON PROCEDURE.  JOB SUBMISSIONS AND PSO    *   FILE 325\n//*                    (PROCESS SYSOUT) REQUESTS ARE ALSO HANDLED   *   FILE 325\n//*                    BY THE SECONDARY JES.                        *   FILE 325\n//*                                                                 *   FILE 325\n//*         JESMAXCC - A PAIR OF JES2 (SP2.1.5) EXITS THAT ADD TEXT *   FILE 325\n//*                    TO THE $HASP165 MESSAGE GENERATED BY NOTIFY= *   FILE 325\n//*                    ON THE JOB CARD OR BY THE JES2 /*NOTIFY      *   FILE 325\n//*                    CONTROL CARD.  IF THE JOB DOES NOT ABEND,    *   FILE 325\n//*                    THE MAXIMUM CONDITION CODE OF ALL EXECUTED   *   FILE 325\n//*                    STEPS IS ADDED.  IF THE JOB ABENDS, THE      *   FILE 325\n//*                    SYSTEM OR USER ABEND CODE IS ADDED:          *   FILE 325\n//*                      $HASP165 YOURJOB ENDED AT NODE - MAX COND  *   FILE 325\n//*                      CODE 0000                                  *   FILE 325\n//*                      $HASP165 YOURJOB ENDED AT NODE - ABENDED   *   FILE 325\n//*                      USER XXX                                   *   FILE 325\n//*                      $HASP165 YOURJOB ENDED AT NODE - CANCELLED *   FILE 325\n//*                      SYSTEM 222                                 *   FILE 325\n//*                                                                 *   FILE 325\n//*         NOTE     - TWO CLISTS, ONE ISPF PANEL, AND A HELP ENTRY *   FILE 325\n//*                    THAT PROVIDE A FACILITY TO DELIVER PROFS     *   FILE 325\n//*                    NOTES FROM A TSO SESSION:                    *   FILE 325\n//*                      NOTE     - THE DRIVING CLIST, INVOKES      *   FILE 325\n//*                                 WFBNOTE AND NOTEIMAC            *   FILE 325\n//*                      NOTEIMAC - PDF EDIT INITIAL MACRO FOR      *   FILE 325\n//*                                 SPECIAL FORMATTING              *   FILE 325\n//*                      WFBNOTE  - ISPF PANEL TO COLLECT DATA FOR  *   FILE 325\n//*                                 NOTE CLIST                      *   FILE 325\n//*                      NOTEHELP - HELP ENTRY FOR NOTE CLIST       *   FILE 325\n//*                                 (RENAME TO ==> NOTE)            *   FILE 325\n//*                    THE NOTE COMMAND PROCEDURE (CLIST) USES THE  *   FILE 325\n//*                    ISPF/PDF EDITOR TO BUILD AND FORMAT MAIL     *   FILE 325\n//*                    \"NOTES\", THEN SENDS THEM TO PROFS OR TSO     *   FILE 325\n//*                    USERS.  NOTE USES ISPF DIALOG SERVICES TO    *   FILE 325\n//*                    COLLECT INFORMATION BY DISPLAYING PANELS,    *   FILE 325\n//*                    THEREFORE NOTE MUST BE EXECUTED WHILE ISPF   *   FILE 325\n//*                    IS ACTIVE.                                   *   FILE 325\n//*                    THIS FACILITY WAS ORIGINALLY WRITTEN TO USE  *   FILE 325\n//*                    THE TSO TRANSMIT COMMAND FOR DATA            *   FILE 325\n//*                    TRANSMISSION, BUT BECAUSE PROFS CAN NOT      *   FILE 325\n//*                    DECIPHER TRANSMIT CONTROL TAGS, NOTE NOW     *   FILE 325\n//*                    USES A SPECIALLY MODIFIED VERSION OF THE     *   FILE 325\n//*                    PRINTOFF COMMAND.  THIS PRINTOFF, WHICH      *   FILE 325\n//*                    ALLOWS DEST(NODE.USER), IS PROVIDED IN THIS  *   FILE 325\n//*                    PACKAGE.                                     *   FILE 325\n//*                                                                 *   FILE 325\n//*                    (Fixed for z/OS in two ways.  See member     *   FILE 325\n//*                     called $PRINTOF.)                           *   FILE 325\n//*                                                                 *   FILE 325\n//*         OPCON    - OPERATOR CONSOLE MONITOR MODIFIED FOR WFB    *   FILE 325\n//*                                                                 *   FILE 325\n//*                    S   P   Y   (NAME CHANGED TO \"OPCON\" IN      *   FILE 325\n//*                                THE CODE, BUT COMMENTS STILL     *   FILE 325\n//*                                REFER TO \"SPY\")                  *   FILE 325\n//*                                                                 *   FILE 325\n//*                    THIS PROGRAM DISPLAYS THE CONTENTS OF ALL    *   FILE 325\n//*                    ACTIVE GRAPHIC OPERATOR'S CONSOLES ON A TSO  *   FILE 325\n//*                    CRT.  THE OPERATOR'S SCREEN CAN BE EITHER A  *   FILE 325\n//*                    327X OR A 370-168 INTEGRATED CONSOLE.  THE   *   FILE 325\n//*                    TSO USER CAN USE ANY 327X TERMINAL.          *   FILE 325\n//*                                                                 *   FILE 325\n//*             V3.3.2 - CORRECT SUPPORT FOR 327X MODEL 3 CONSOLE.  *   FILE 325\n//*             V3.3.1 - CHANGE CONSOLE ASID TO 7 DUE TO CATALOG    *   FILE 325\n//*                      ASID W/ DFP V2.                            *   FILE 325\n//*               V3.3 - ADD SUPPORT FOR VIEWING CONSOLES THAT HAVE *   FILE 325\n//*                      3270 EXTENDED FIELD ATTRIBUTES (E.G. 3179, *   FILE 325\n//*                      3180, 3279-3B, ETC.).                      *   FILE 325\n//*                    - MAKE OPCON NON-SWAPPABLE.                  *   FILE 325\n//*                    - CHANGE CONSOLE ASID TO 6 FOR XA (S/370     *   FILE 325\n//*                      CONASID IS 5).                             *   FILE 325\n//*               V3.2 - ELIMINATE SPECIAL CHARACTER REQUIRED TO    *   FILE 325\n//*                      PRECEDE OS CMD                             *   FILE 325\n//*                    - ELIMINATE SECRET AUTH SVC, RESTORE MODESET *   FILE 325\n//*                      AND SVC34                                  *   FILE 325\n//*                    - CORRECT BUFFER ADDRESS PROBLEM WITH LINE 1 *   FILE 325\n//*                      OF DISPLAY                                 *   FILE 325\n//*                    - CORRECT LOOP COUNT FOR UCM BUILD ROUTINE   *   FILE 325\n//*                    - ADD SUBCOMMAND A.. (AUTO W.. AFTER COMMAND *   FILE 325\n//*                      ENTRY)                                     *   FILE 325\n//*                    - ADD CHECK AT INITIALIZATION FOR TSO OPER   *   FILE 325\n//*                      AUTHORITY                                  *   FILE 325\n//*                    - MAKE COMMAND ENTRY AREA NON-DISPLAY UNTIL  *   FILE 325\n//*                      PASSWD GIVEN                               *   FILE 325\n//*                    - MAKE \"OPER REDISPLAY\" AREA MODIFIABLE FOR  *   FILE 325\n//*                      REENTRY                                    *   FILE 325\n//*                    - FILL BOTH ENTRY AREAS WITH NULLS TO ALLOW  *   FILE 325\n//*                      CHAR INSERT                                *   FILE 325\n//*                    - REDISPLAY LAST CMD ENTERED BY USER         *   FILE 325\n//*                      (INSTEAD OF OPER)                          *   FILE 325\n//*                    - MOVE CONSOLE STATUS TABLE TO SEPARATE      *   FILE 325\n//*                      CSECT                                      *   FILE 325\n//*                    - RESTRUCTURE THE HELP SCREEN AND USE        *   FILE 325\n//*                      UPPER/LOWER CASE                           *   FILE 325\n//*                    - PROVIDE TSO HELP ENTRY AS COMMENTS AT END  *   FILE 325\n//*                      OF SOURCE                                  *   FILE 325\n//*                                                                 *   FILE 325\n//*         PRINTOFF - THE WIDELY MODIFIED IPO SUPPLIED TSO         *   FILE 325\n//*                    COMMAND TO PRINT A DATASET, WITH YET MORE    *   FILE 325\n//*                    FUNCTIONS ADDED.  AFTER RESEARCHING ALL      *   FILE 325\n//*                    VERSIONS ON THE CBT TAPE, WELLS FARGO        *   FILE 325\n//*                    CREATED THIS VERSION FROM SOURCE FROM FOUR   *   FILE 325\n//*                    SEPARATE FILES.  WE BELIEVE THIS CONTAINS    *   FILE 325\n//*                    ALL FEATURES EXCEPT ONE WHICH WILL BE        *   FILE 325\n//*                    ADDED WITH OUR NEXT UPDATE (HONOR EXISTING   *   FILE 325\n//*                    CC EVEN IF DCB SAYS \"NO CC\").                *   FILE 325\n//*                                                                 *   FILE 325\n//*                    FIXED FOR Y2K BY SAM GOLOB.                  *   FILE 325\n//*                                                                 *   FILE 325\n//*                    FOLLOWING FIXES WERE FROM SAM LEPORE.        *   FILE 325\n//*                                                                 *   FILE 325\n//*                    R2 - * CORRECT ERROR, 'NOHEAD' CAUSED BLANK  *   FILE 325\n//*                           FIRST PAGE.                           *   FILE 325\n//*                         * CORRECT ERRORS IN LENGTH OF TEXTG     *   FILE 325\n//*                           THROUGH TEXTJ.                        *   FILE 325\n//*                         * INCREASE INPUT RECORD LIMIT TO        *   FILE 325\n//*                           32,760.                               *   FILE 325\n//*                         * CHANGE DSNAME POSIT TO DSTHING TO     *   FILE 325\n//*                           ALLOW FOR DDN().                      *   FILE 325\n//*                         * CHANGE DEST KEYWORD TO ACCEPT 8       *   FILE 325\n//*                           CHARACTER VALUE.                      *   FILE 325\n//*                         * CHANGE DEST KEYWORD TO ACCEPT NODE    *   FILE 325\n//*                           AND USERID.                           *   FILE 325\n//*                         * ADD DDNAME(...) KEYWORD TO ALLOW TEMP *   FILE 325\n//*                           OR VIO DATASETS.                      *   FILE 325\n//*                         * ADD UNIT(...) KEYWORD FOR USE WITH    *   FILE 325\n//*                           VOLUME(...).                          *   FILE 325\n//*                         * ADD 'VOLUME: VOLSER' TO HEADING WHEN  *   FILE 325\n//*                           SPECIFIED.                            *   FILE 325\n//*              +--------> * ADD TIME AND 'MONTHNAME DAY, YEAR' TO *   FILE 325\n//*              :            DSN HEADING.                          *   FILE 325\n//*              :          * ADD NOMSGS KEYWORD TO STOP NON-ERROR  *   FILE 325\n//*              :            MSGS TO TERMINAL.                     *   FILE 325\n//*              :          * ADD DSECT=YES TO CVT MACRO FOR CLEAN  *   FILE 325\n//*              :            XA ASSEMBLY.                          *   FILE 325\n//*              :          * MOVE ALL PUTLINE TEXT TO SEPARATE     *   FILE 325\n//*              :            MESSAGES CSECT.                       *   FILE 325\n//*              :            --- (FOLLOWING CHANGES ARE WFB        *   FILE 325\n//*              :                SPECIFIC) ---                     *   FILE 325\n//*              :          * MAKE WFB DEFAULT FORM($TST) IN PARSE  *   FILE 325\n//*              :            MACRO.                                *   FILE 325\n//*              :                                                  *   FILE 325\n//*            +-- NOTE ==> THE TIME-DATE ROUTINE IKJEFLPA          *   FILE 325\n//*            (SEE BELOW)  NORMALLY RESIDES ONLY IN SYS1.AOST4.    *   FILE 325\n//*                         THIS LIBRARY MUST BE INCLUDED IN THE    *   FILE 325\n//*                         LINKEDIT SYSLIB FOR PROPER              *   FILE 325\n//*                         RESOLUTION.                             *   FILE 325\n//*                                                                 *   FILE 325\n//*            +-- NOTE ==> (SBG - NO MORE. IKJEFLPA FROM IBM IS    *   FILE 325\n//*                          NOW INCOMPATIBLE, SO WE DISASSEMBLED   *   FILE 325\n//*                          THE OLD ONE, FIXED THE \"CENTURY\"       *   FILE 325\n//*                          PROBLEM, AND WE ARE INCLUDING ITS      *   FILE 325\n//*                          SOURCE HERE. ALSO IKJEFLPB.)           *   FILE 325\n//*                                                                 *   FILE 325\n//*         ROOM     - (THIS VERSION IS UPDATED TO JES2 SP2.1.5     *   FILE 325\n//*                    LEVEL.)  A TSO COMMAND TO ALLOW A USER TO    *   FILE 325\n//*                    CHANGE THE \"ROOM NUMBER\" FIELD IN THE JES    *   FILE 325\n//*                    JCT FOR THE TSO SESSION.  THIS COMMAND IS    *   FILE 325\n//*                    NECESSARY BECAUSE THE ROOM NUMBER FIELD IS   *   FILE 325\n//*                    NOT SUPPORTED BY UADS (AND THE FIELD IS      *   FILE 325\n//*                    OVERLAYED BY WELLS FARGO ACCOUNTING          *   FILE 325\n//*                    INFORMATION DURING LOGON).  ROOM MAKES IT    *   FILE 325\n//*                    EASY FOR THE USER TO SPECIFY DELIVERY        *   FILE 325\n//*                    INFORMATION (PRINTED ON JES HEADER AND       *   FILE 325\n//*                    TRAILER PAGES) FOR ALL SYSOUT CREATED DURING *   FILE 325\n//*                    THE SESSION, INCLUDING SPUN DATASETS.        *   FILE 325\n//*                                                                 *   FILE 325\n//*                    THIS CODE CAN SERVE AS A MODEL FOR ALLOWING  *   FILE 325\n//*                    A TSO USER TO CHANGE THROUGH AUTHORIZED      *   FILE 325\n//*                    MEANS ANY OTHERWISE PROTECTED INFORMATION IN *   FILE 325\n//*                    THE JES JCT OR SIMILAR CONTROL BLOCKS.       *   FILE 325\n//*                                                                 *   FILE 325\n//*         VTAMCHK  - THIS PROGRAM IS INTENDED TO BE STARTED       *   FILE 325\n//*                    AUTOMATICALLY AFTER AN IPL (BY COMMNDXX).    *   FILE 325\n//*                    IT IS USED TO START VTAM APPLICATIONS OR     *   FILE 325\n//*                    ISSUE OTHER COMMANDS IN AN ORDERLY SEQUENCE  *   FILE 325\n//*                    AFTER VTAM IS UP AND RUNNING.  VTAMCHK HAS   *   FILE 325\n//*                    THE OPTION TO DELAY BETWEEN ISSUING EACH     *   FILE 325\n//*                    COMMAND BECAUSE SOME ENVIRONMENTS            *   FILE 325\n//*                    THEMSELVES HAVE TIME DEPENDENCIES, SUCH AS   *   FILE 325\n//*                    $SLOGON1   (WAIT FOR INITIALIZATION)         *   FILE 325\n//*                                                                 *   FILE 325\n//*                            $SN,A=XX                             *   FILE 325\n//*                                                                 *   FILE 325\n//*                    THE SOURCE HAS A SAMPLE OF THE PROCEDURE     *   FILE 325\n//*                    AND SOME COMMANDS.                           *   FILE 325\n//*                                                                 *   FILE 325\n//*         VTOCLIST - A CORRECTED VERSION OF THE GTE VTOCLIST      *   FILE 325\n//*                    PROGRAM TAKEN FROM THE CBT TAPE.             *   FILE 325\n//*                    CORRECTIONS INCLUDE:                         *   FILE 325\n//*                                                                 *   FILE 325\n//*                    - PROVIDE SUPPORT FOR 3380 MODEL E DEVICES.  *   FILE 325\n//*                    - PROVIDE SUPPORT FOR DF/EF VSAM FILES WHICH *   FILE 325\n//*                      ARE ALLOWED TO HAVE MORE THAN 16 EXTENTS.  *   FILE 325\n//*                    - TWO CORRECTIONS TO PRINT EXTENT NUMBERS    *   FILE 325\n//*                      GREATER THAN 99.                           *   FILE 325\n//*                    - A CORRECTION TO PRINT THE \"LAST REF DATA\"  *   FILE 325\n//*                      AND \"USE COUNT\".                           *   FILE 325\n//*                                                                 *   FILE 325\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DARTH": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87(\\x7f\\x00\\x87(\\x7f\\x12\\x00\\x04\\xfe\\x04\\xfe\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-10-14T00:00:00", "modifydate": "1987-10-14T12:00:00", "lines": 1278, "newlines": 1278, "modlines": 0, "user": "FILE325"}, "text": "*   DARTH IS  A UTILITY PROGRAM THAT OFFLOADS SYS1.DUMP DATA SETS TO\n* TAPE.  IT IS STARTED AS A STARTED TASK BUT CAN RUN AS A BATCH JOB.\n* AT WFB IT IS STARTED AS 'S DARTH.VADER'  BY AN OPERATOR COMMAND.\n*\n*   UPON INITIATION DARTH CHECKS EACH FILE ASSOCIATED WITH THE DDNAME:\n* //DARDMP__ (WHERE __ WILL BE DISCUSSED LATER) FOR THE PRESENCE OF A\n* DUMP.  WHEN PRESENT, A TAPE FILE AND A CONTROL PDS ARE DYNAMICALLY\n* ALLOCATED AND OPENED.    THE TIME STAMP AND DUMP TITLE ARE READ FROM\n* THE DUMP AND PLACED IN A NEWLY CREATED MEMBER IN THE CONTROL PDS\n* ALONG WITH THE  VOL ID OF THE TAPE HOLDING THE DUMP. THE DUMP IS THEN\n* OFFLOADED TO TAPE AND RESET TO EMPTY STATUS.  WHEN ALL DEFINED DUMPS\n* HAVE BEEN OFFLOADED, DARTH DEALLOCATES THE TAPE AND CONTROL DATA SETS\n* AND DROPS INTO A WAIT STATE FOR 15 MINUTES.   UPON 'WAKING UP, IT\n* STARTS THE CHECKING/OFFLOADING CYCLE AGAIN.\n*\n*   DARTH CAN BE AWAKENED FROM ITS 'SLEEP' BY A OPERATOR MODIFY COMMAND\n* AS FOLLOWS:\n*\n*                     F DARTH,X\n*\n* WHERE X IS ANY CHARACTER. THE CHECK/DUMP CYCLE IS IMMEDIATELY STARTED\n* AFTER WHICH DARTH DROPS INTO ANOTHER 15 MINUTE 'SLEEP' CYCLE.\n*\n*   THE DUMP DATA SETS ARE DUMPED IN THE ORDER IN WHICH THEY ARE\n* DEFINED IN THE JCL.  DUMP DATA SETS MUST APPEAR ON DD STATEMENTS\n* BEGINING WITH THE CHARACTERS 'DARDMP' IN A 8 CHARACTER DDNAME.\n* CHARACTERS 7 AND 8 CAN BE ANYTHING BUT HAVE A DESIGNATED USE AT WFB.\n* CHARACTER 7 IS USED TO IDENTIFY THE SYSTEM THAT ISSUED THE DUMP (AN\n* 'A' FOR THE 'A' SYSTEM, A 'B' FOR THE 'B' SYSTEM, ETC). CHARACTER 8\n* IS USED TO  IDENTIFY A PARTICULAR DUMP DATA SET  (A '3' FOR DUMP DATA\n* SET 'SYS1.DUMP03').  THUS DDNAME //DARDMPB2 SHOULD DEFINE\n* 'SYS1.DUMP02' DUMP DATA SET FOR SYSTEM 'B'.\n*\n* CHARACTERS 7 AND 8 ARE ALSO USED TO BUILD INFORMATION IN THE CONTROL\n* DATA SET.   CHARACTER 7 IS USED AS THE FIRST LETTER OF THE MEMBER\n* NAME.  THE MEMBER NAME HAS THE FOLLOWING FORMAT:\n*\n*                   SDDDHHMM\n*\n* WHERE           S    = SYSTEM IDENTIFIER  ('A' FOR SYSTEM, ETC )\n*                 DDD  = JULIAN DAY THE CPU CREATED THE DUMP\n*                                   (TAKEN FROM THE DUMP TIME STAMP)\n*                 HHMM = HOUR AND MINUTE THE DUMP OCCURRED\n*                                   (TAKEN FROM THE TIME STAMP IN THE\n*                                   DUMP).\n*\n* IF THE SAME  MEMBER NAME ALREADY EXISTS IN THE CONTROL DATA SET WHEN\n* DARTH ATTEMPTS TO STOW A NEW MEMBER, A '1' IS ADDED TO  THE\n* NUMERICAL VALUE OF THE MINUTES FIELD IN THE NEW NAME UNTIL THAT NAME\n* IS UNIQUE TO THE DIRECTORY.\n*\n* AT PRESENT, OLD MEMBERS MUST BE MANUALLY PURGED FROM THE PDS. IF THE\n* DIRECTORY IS FULL WHEN DARTH ATTEMPTS TO STOW ANOTHER MEMBER, STOW\n* ERROR MESSAGE (IN DECIMAL) ARE DISPLAYED ON THE OPERATOR CONSOLE AND\n* THE STOW PROCESS IS BYPASSED. DARTH STILL OFFLOADS THE DUMP TO TAPE\n* AND CLEARS THE SYS1.DUMP DATA SET.  WHEN THIS PROBLEM IS DISCOVERED,\n* THE USER SHOULD PURGE OLD MEMBERS AND COMPRESS THE DATA SET.\n*\n* IF THE FIRST RECORD IN THE DUMP DOES NOT START WITH X'FE' IN BYTE 1\n* (XA DUMP INDICATOR), DARTH ASSUMES THAT THE DUMP IS TRASHED AND WILL\n* USE THE CURRENT TIME AND DATE FROM THE CPU WHERE IT IS RUNNING TO\n* BUILD DDDHHMM PORTION OF THE MEMBER NAME.\n*\n*\n*    THE CONTROL PDS MEMBER CONTAINS 2 80 BYTE RECORDS WHOSE CONTENTS\n* APPEAR AS FOLLOWS:\n*\n*\n* 023456 A2160650 CPUID=SYSAD1 |<---  FIRST 50 BYTES OF DUMP TITLE -->|\n* TIME:  06.50.50 DATE: 86.216 |<--- SECOND 50 BYTES OF DUMP TITLE -->|\n*\n*\n* WHERE: 023456   IS THE TAPE VOLID CONTAINING THE OFFLOADED DUMP.\n*                 THIS HAS ALWAYS BEEN JUST ONE VOLUME. AT WFB, TAPE\n*                 VOL IDS THAT START WITH 0 ARE 3480 TYPE. A T OR 8\n*                 ARE 3420 TYPE TAPES. IF TWO VOLUMES WERE PRODUCED,\n*                 ONLY THE FIRST VOLUME WOULD BE RECORDED HERE.   THE\n*                 TAPE HAS A RETENTION PERIOD OF 7 DAYS. THE DAY THAT\n*                 THE TAPE WAS CREATED IS CONSIDERED DAY 1 BY TMS.\n*\n*        A2160650 IS THE MEMBER NAME OF THIS MEMBER.\n*\n*        CPUID=   THE 'AD1' IN '=SYSAD1' REPRESENT THE SYSTEM THAT\n*                 PRODUCED THE DUMP AND THE DUMP DATA SET TO WHERE IT\n*                 WROTE IT.  THE 'A' AND THE '1' WERE EXTRATCED FROM\n*                 POSITIONS 7 AND 8 RESPECTIVELY OF THE DDNAME THAT\n*                 DEFINED THE DUMP DATA SET.    IN THIS EXAMPLE,  'A'\n*                 IN THIS EXAMPLE, 'A' IS SYSTEM 'A' AND 'D1' DUMP\n*                 DATA 'SYS1.DUMP01'\n*\n*        TIME & DATE ARE FROM THE DUMP TIME STAMP, OR THE OFFLOADING\n*                 TIME AND DATE AS DISCUSSED ABOVE.\n*\n*\n*  SOME FUTURE REQUIREMENTS CURRENTLY UNDER CONSIDERATION:\n*\n*    1.  ADD A F DARTH,SUSPEND COMMAND THAT WILL SUSPEND DARTH MORE\n*        THAN 15 MINUTES SO THAT A USER CAN 'GRAB' A DUMP FROM DISK\n*        BEFORE DARTH DOES.\n*\n*    2.  ADD A F DARTH,RESUME COMMAND TO REVERSE THE 'SUSPEND'\n*        COMMAND.\n*\n*    3.  ADD CODE THAT WILL AUTOMATICALLY PURGE OBSOLETE MEMBERS.\n*        USERS NOW HAVE TO EXAMINE THE HARD COPY LOG TO ASCERTAIN THE\n*        VOLID OF THE OFFLOADED TAPE WHEN DARTH CANNOT ADD NEW MEMBERS\n*        BECAUSE THE DIRECTORY IS FULL. USER HAS TO 'REMEMBER' TO\n*        MANUALLY CLEAN-UP THE DIRECTORY PERIODICALLY.\n*\n*    4.  ADD CODE TO READ JCL EXECUTE PARM FIELD VALUES.   USER MUST\n*        UPDATE THE CODE WHEN VARIABLES LIKE DATA SET NAMES AND TAPE\n*        DRIVE TECHNOLOGY CHANGE.\n         EJECT\nUTDARTH  CSECT\n         TITLE 'DARTH - DAMAGE ASSESMENT ROUTINE TAPE HANDLER'\n         PRINT ON\n*                  - PROGRAM ABSTRACT -\n*          DARTH OFFLOADS TO TAPE SVC DUMPS WRITTEN TO SYS1.DUMP__ DATA\n*        SETS. CALLS ARE MADE TO PGMS 'DARGETDD' TO EXTRACT DD NAME\n*        INFORMATION, 'DARBLDCB' TO BUILD DCBS FOR THE SYS1.DUMP__\n*        DATA SETS AND 'DARCONVRT' TO CONVERT THE TIME-OF-DAY CLOCK TO\n*        A LEGIBLE DATE AND TIME.  THESE ROUTINES MUST BE LINKED INTO\n*        'UTDARTH'. FOR EXAMPLE:\n*\n*        //        JOBCARD\n*        //         EXEC PGM=IEWL, PARM=('IEWL,LIST,XREF,LET')\n*        //         DD\n*        //         DD\n*        //         DD\n*        //OLDLMOD  DD\n*        //SYSLMOD  DD\n*        //SYSLIN   DD  *\n*          INCLUDE OLDLMOD(UTDARTH)\n*          INCLUDE OLDLMOD(DARCNVRT)\n*          INCLUDE OLDLMOD(DARGETDD)\n*          INCLUDE OLDLMOD(DARBLDCB)\n*          ENTRY UTDARTH\n*          NAME UTDARTH(R)\n*        /*\n*\n*          THE OUTPUT TAPE FILE AND A PDS CONTROL DATA SET ARE  DYNA-\n*        MICALLY ALLOCATED. THE CONTROL DATA SET CONTAINS THE VOL ID\n*        TO WHICH THE SVC DUMP WAS OFFLOAD, THE CPU ID THAT ISSUED THE\n*        DUMP, THE DATE AND TIME THAT THE DUMP OCCURED AND THE DUMP\n*        TITLE.  THE MEMBER NAMES OF THE PDS HAVE THE FORMAT SDDDHHMM\n*        WHERE 'S' IS THE CPU ID THAT GENERATED THE DUMP AND 'DDD' AND\n*        'HHMM' ARE THE JULIAN  DAY AND TIME THAT THE DUMP WAS ISSUED.\n*\n*           USER ABEND CODES FOR THIS CSECT ARE AS FOLLOWS:\n*        600   FREEING OF START CIB FAILED.\n*        605   CIB NOT A START, MODIFY OR STOP CIB.\n*        610   FREEING OF MODIFY CIB FAILED.\n*        620   NO RECORDS IN PDS DIRECTORY.\n*        670   UNABLE TO DETERMINE WHICH ECB IN A LIST WAS POSTED.\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6                  BASE REG FOR COMMUNICATION DSECT.\nR7       EQU   7\nR8       EQU   8                  BASE REG FOR CIB DSECT.\nR9       EQU   9                  POINTS TO DCB BEING PROCESSED\nR10      EQU   10\nR11      EQU   11                 HOLDS RETRN ADDRSS FRM BAL INSTRCNS\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         USING UTDARTH,15\nENTRY    B     STORE\n         DC    AL1(L'ID)\nID       DC    C'VERSION 5 OF UTDARTH/DARTH-&SYSDATE &SYSTIME'\nSTORE    STM   14,12,12(13)\n         DROP  15\n         USING UTDARTH,12,7\n         LR    12,15                 SET UP BASE REG\n         ST    13,SAVE+4             SAVE SAVEAREA POINTER\n         LR    11,13                 SAVE REG 13 FOR STORE\n         LA    13,SAVE               GET NEW SAVEAREA ADDRESS\n         ST    13,8(11)              STORE NEW SAVEAREA ADDR\n         LA    7,4095(12)            SETUP SECOND BASE\n         LA    7,1(7)\n*\n*\n*\n*        OBTAIN POINTERS TO COMMUNICATON CONTROL BLOCKS AND\n*        PROCESS ANY START COMMAND PARAMETERS.  GET EXCLUSIVE\n*        CONTROL (ENQUEUE) OF DUMP HISTORY DATA SET.\n*\n         EXTRACT COMAPTR,'S',FIELDS=(COMM) GET COMMUN AREA ADDR.\n         L     R6,COMAPTR             GET PTR TO COMMUNICATION AREA.\n         USING COMMAP,R6              ESTBLSH DSECT ADDRSSIBLTY.\n         MVC   TWOECBS,COMAECB        PUT COM ECB PTR IN ECB LIST.\n         L     R8,COMACIB             LOAD ADDRESS OF CIB POINTER.\n         USING CIBMAP,R8              ESTBLSH ADDRSBLTY OF CIB DSECT.\n         LA    R8,0(0,R8)             CLEAR FIRST BYTE OF REGISTER.\n         LTR   R8,R8                  IF   COMACIB ADDRESS = ZERO\n         BZ    CMDLIMIT               THEN BATCHJOB, GO SET CMD LIMIT.\n         CLI   CIBVERB,CIBSTART       IF NOT START CIB,\n         BNE   CMDLIMIT               THEN GO SET MODIFY CMD LIMITS.\n         LH    R10,CIBDATLN           ELSE GET LENGTH OF CIB DATA.\n         LTR   R10,R10                IF NO PARMS IN START COMMAND,\n         BZ    CIBFREE0               THEN GO FREE THIS CIB.\n         BCTR  R10,0                  ELSE DECREMENT VALUE BY ONE.\n         EX    R10,CIBMDATA           MOVE DATA TO WORK FIELD.\n         LA    R11,CIBFREE0           GET RETRN ADRES AFTR CMD PROCSSNG\n         B     CIBBEGIN               GO PROCESS STRT CMDS.\nCIBFREE0 DS   0H\n         QEDIT BLOCK=(8),ORIGIN=COMACIB  RLSE STRT CIB AND RESET ECB.\n         LTR   R15,R15                CHECK RETURN CODE FROM QEDIT.\n         BZ    CMDLIMIT               IF RC = 0, THEN SET MODFY LIMTS.\n         ABEND 600,DUMP               SOMETHING WRONG, KILL PGM.\nCMDLIMIT DS    0H\n         QEDIT ORIGIN=COMACIB,CIBCTR=1 SETY MODFY CMD LIMITS TO 1\nENQUEUE  DS    0H\n         MVC   $ENQ(16),$ENQL         MOVE ENQ LIST        V 1.4\n         ENQ   MF=(E,$ENQ)            ENQ THE DEATHSTAR.\n         LTR   15,15                  WAS ENQ SUCESSFUL ?  V 1.4\n         BNZ   $ERRENQ                NO...END.....        V 1.4\n*\n*\n*        INITIALIZE PROGRAM PARAMETERS.\n*\n         MVC   ORRETN+6,RETENPD       ESTBLSH OUTPUT TAPE RETN PERIOD.\n         MVC   CONTNAME+6(L'CONTDSN),CONTDSN GET CNTL DATA SET NAME.\n*        LA    R1,PDSMNLST            GET PARM LIST FOR PDS MAINTNANCE.\n*        CALL  DARPDSMN               INVOKE PDS MAINTENANCE ROUTINE.\n*\n*        BUILD  DDNAME TABLE AND EXTRACT SELECTED DDNAMES FROM\n*        TIOT  CONTROL BLOCK.\n*\n         GETMAIN R,LV=816             GET MEMRY FOR DDNAME TBLE.\n         CALL  DARGETDD               GET DDNAMES. R1= DD NAME TBL.\nDDTBLPFX DSECT\nNUMBRDD  DS    XL4                    NUMBER OF DD'S PRESENT\nDCBADDRS DS    XL4                    PTR TO TABLE OF DCB ADDRESS.\nDCBTBL   DS    XL4                    PTR TO TABLE OF DCB'S.\nDCBMODL  DS    XL4                    POINTS TO A MODEL DCB.\nDDNAMES  DS    XL800                  TABLE OF VALID DDNAMES.\nUTDARTH  CSECT\n*\n*\n*        BUILD  DCB LIST AND DATA CONTROL BLOCK (DCB) TABLES.\n*\nDCBREG   EQU   9                      USE TO REFERENCE DUMP DCBS.\n         LR    R2,R1                  SAVE PTR TO DDNAME TBLE PRFIX.\n         USING DDTBLPFX,R2            ESTBLSH DSECT  ADDRSSIBLTY.\n         LA    R5,MODELDCB            GET ADDRESS OF MODL DCB.\n         ST    R5,DCBMODL             SAVE THIS ADDRESS.\n         L     R0,NUMBRDD             GET NUMBR OF DCBS TO CREATE.\n         MH    R0,=H'100'             COMPUTE NMBR OF BYTS FOR DCBS.\n         GETMAIN R,LV=(0)             GET AREA IN SUBPOOL 0, USING R0.\n         ST    R1,DCBTBL              GET POINTER TO DCB TABLE.\n         LR    DCBREG,R1              GET COPY FOR WORKING USE.\n         USING DCBWORK,DCBREG         SETUP DCB DSECT ADDRSIBLTY.\n         LA    R4,DCBLIST             GET PTR TO TBLE OF DCB ADDRESSES\n         ST    R4,DCBADDRS            SAV THIS POINTER.\n         LR    R1,R2                  R1 = PTR TO DDNAME TABLE PREFIX.\n         DROP  R2\n         CALL  DARBLDCB               BUILD DCBS. R1 = DD NAME TBL.\n*\n*\n*        OPEN  ALL DARTH DUMP DATA SETS AND RELEASE DDNAME TABLE.\n*\n         LA    1,DCBLIST              GET OPEN DCB LIST POINTER\n         SVC   19                     OPEN ALL DUMP DCBS.\n         LR    R1,R2                  SETUP FOR FREEMAIN\n         FREEMAIN R,LV=816,A=(1)      RLSE DDNAME TABLE.\n         WTO   'IJBDARTH  DUMP DATASET MANAGER ACTIVE',ROUTCDE=2\n         SPACE 2\n***************************************************************\n* READ EACH DAR DATA SET TO FIND OUT IF IT HAS BEEN USED.\n* IF IT  HAS, DUMP IT TO TAPE AND CLEAR THE DATA SET,\n*             CHECK FOR OPERATOR SERVICE REQUEST VIA MODIFY CMD.\n* ELSE,       CHECK FOR OPERATOR REQUEST FOR SERVICE\n*\n* GO BACK TO SENTENCE 1 ABOVE.\n***************************************************************\n         SPACE 2\nSTRTCYCL DS    0H\n         WTO   'IJBDARTH  CHECKING DUMP DATASETS',ROUTCDE=2 V 1.3\n         LA    4,DCBLIST      GET ADDRESS OF START OF DCB LIST\n         L     DCBREG,0(4)    GET DCB ADDRESS\nOPSERVCE DS    0H\n         LA    R11,READ               GET RETURN ADDRESS.\n         L     R3,COMAECB             GET PTR TO COMMUNICATION ECB.\n         TM    0(R3),B'01000000'      WAS COMMUNICATION ECB POSTED?\n         BO    TESTMODF               YES, FIND OUT THE SRVCE DESIRED.\nREAD     READ  RDAR0,SF,(DCBREG),IOAREA READ RECORD FROM DAR DATASET\n         CHECK RDAR0          CHECK READ\n*                             IF DATASET EMPTY, CHECK WILL BRNCH TO\n*                             LABEL 'POINT0', EODAD PROCESSING.\n*                             OTHERWISE PROCESSING WILL CONTINUE BELOW.\n         BAL   11,PROCDUMP             GO PROCESS DUMP\n*\nPOINT0   EQU   *\n         POINT (DCBREG),START         RESET DCB TO START OF DATASET\n         LA    4,4(4)                 GET NEXT DCB POINTER.\n         L     DCBREG,0(4)            GET NEXT DCB.\n         CLI   0(4),X'FF'             IF NOT AT END OF DCB TBL,\n         BNE   OPSERVCE               THEN CHCK FOR REQST FRM OPER.\nTIMER    STIMER REAL,ASYNXIT,DINTVL=TIMELIMT  SET TIME AND WAIT ON\n         WAIT  1,ECBLIST=TWOECBS,LONG=YES     CLOCK OR MODFY ECB.\n         TTIMER CANCEL,TU             CANCEL UNUSED WAIT TIME\n         TM    TIMERECB,B'01000000'   IF  TIMER ECB POSTED?\n         BO    TIME0800               THEN GO DO SOME WORK.\n         LA    R11,TIME0850           GET RETURN ADDRESS\n         L     R3,COMAECB             GET PTR TO COMMUNICATION ECB.\n         TM    0(R3),B'01000000'      IF OPER REQUEST SERVICE,\n         BO    TESTMODF               THEN FIND OUT WHICH SERVICE.\n         ABEND 670,DUMP               SOMETHING WRONG, KILL PGM.\nTIME0800 MVC   TIMERECB,FRESHECB      REFRESH TIMER ECB.\nTIME0850 B     STRTCYCL               GO DO SOME WRK (START THE CYCLE).\n*\nASYNXIT  DS    0H\n*\n*        ASYNCHRONOUS EXIT ENTERED FROM A STIMER POP. IT POST AN\n*        ECB COMPLETE INDICATING THAT A TIME PERIOD HAS ELAPSED.\n*        ADDRESSABLITY OF DATA REFERENCE IN THE EXIT IS ESTABLISHED\n*        BY USING ALL BASE REGISTERS EMPLOYED IN THE MAIN CSECT\n*        RATHER THAN ESTABLISHING NEW ONES WITH A USING STATEMENT.\n*        THIS  IS ACCOMPLISHED IN THE  FIRST THREE INSTRUCIONS AND\n*        THE USE OF AN ADCON\n*\n*              R15 POINTS TO FIRST INTRUCTION IN THIS EXIT.\n*              R15+16 POINTS TO ADCON THAT CONTAINS MAIN CSECT\n*                     START LOCATION.\n*              R11 POINTS TO RETRN POINT OF CALLING MODULE.\n*\n*\n         SAVE  (14,12)                SAVE REGISTERS\n         L     R12,16(R15)            GET MAIN BASE REG ADDRESS.\n         LA    R7,4095(0,R12)         GET SECOND BASE ADDRESS.\n         B     ASYN0050\n         DC    A(UTDARTH)             ADDRESS OF MAIN CSECT.\nASYN0050 DS    0H\n         POST  TIMERECB\n         RETURN (14,12)               RESTOR REGISTERS AND RETURN.\n*\n*        END-OF-ASYNCHRONOUS-EXIT\n*\n*\nCIBEND   DS    0H\n         WTO    'IJBDARTH - STOP COMMAND ACCEPTED',ROUTCDE=2 V 1.3\n         DEQ    RET=NONE,MF=(E,$ENQL)   DEQUEUE DEATH STAR   V 1.4\n         L      13,SAVE+4             READY TO GET OUT\n         RETURN (14,12),RC=0          LEAVE THE SYSTEM NOW.\nCIBBEGIN DS    0H\n         WTO   'IJBDARTH START PARAMETERS NOT SUPPORTED.'\n         BR    R11                    RETURN TO CALLING SOURCE.\nTESTMODF DS    0H\n         L     R8,COMACIB             GET ADDRESS OF CIB.\n         USING CIBMAP,R8              ESTABLSH CIB ADDRESSIBILTY.\n         CLI   CIBVERB,CIBSTOP        IF STOP COMMAND ISSUED,\n         BE    CIBEND                 THEN GO TO END ROUTINE.\n         ST    R11,TEST0900           SAVE RETURN ADDRESS\n         LA    R11,TEST0050           GET NEW RETURN ADDRESS.\n         CLI   CIBVERB,CIBMODFY       IF OPER WANTS SERVICE,\n         BE    CIBCHNGE               THEN PROCESS THE SERVICE.\n         ABEND 605,DUMP               SOMETHING WRONG, KILL PGM.\nTEST0050 DS    0H\n         L     R11,TEST0900           RESTOR OLD RETRN ADDRESS.\n         BR    R11                    RETURN TO CALLING SOURCE.\nTEST0900 DS    F                      SAVE AREA, OLD RETRN ADDRESS.\n*\nCIBCHNGE DS    0H\n         WTO   'IJBDARTH MODIFY COMMANDS NOT SUPPORTED.'\n         L     R3,COMACIB\n         QEDIT BLOCK=(3),ORIGIN=COMACIB  RLSE CIB AND RESET ECB.\n         LTR   R15,R15                CHECK RETURN CODE FROM QEDIT.\n         BZ    CIBCHN50               IF RC = 0, THEN EXIT\n         ABEND 610,DUMP               SOMETHING WRONG, KILL PGM.\nCIBCHN50 BR    R11                    RETURN TO CALLING SOURCE.\nCOMAPTR  DC     F'0'                  PTR TO COMMUNICATION AREA.\nCOMMAP   DSECT                        COMMUNICATION AREA DSECT.\nCOMAECB  DS    A                      COMMUNICATION ECB ADDRESS.\nCOMACIB  DS    A                      COMMUNICATION CIB ADDRESS.\n         DS    F                      TOKEN FOR INTRNL STRT COMMNDS.\nCIBMAP   DSECT                        COMM INPUT BUFER DSECT, BASE=R8,\n         IEZCIB                       IBM SUPPLIED.\nUTDARTH  CSECT                        END OF DSECT, RESUME CSECT.\nTWOECBS  DS    0F\n         DS    A                      CONTAINS COMMUNICATION ECB PTR.\n         DC    X'80'                  LAST-ECB-IN-LIST FLAG.\n         DC    AL3(TIMERECB)          CONTAINS STIMER ECB PTR.\nTIMERECB DC    F'0'                   X'80' =PENDING, X'40'=POSTED\nFRESHECB DC    F'0'                   USED TO RE-FRESH ECB.\nCIBMDATA MVC  CIBWDATA(0),CIBDATA     XTRCT CIB DATA FOR EDITING.\nCIBWDATA DC   4F'0'                   WRK FLD FOR CIB DATA.\n         EJECT\nPROCDUMP DS    0H\n*******************************************************************\n* PROCESS DUMP: ALLOCATE AN OUTPUT TAPE FOR THE DUMP.             *\n*               ALLOCATE  THE PDS CONTROL DATA SET.               *\n*               OPEN THE TAPE OUTPUT DATA SET.                    *\n*               OPEN THE CONTROL DATA SET.                        *\n*               BUILD CONTRL RECORD AND PDS MEMBER NAME.          *\n*               WRITE  CONTROL RECORDS.                           *\n*               STOW MEMBER NAME.\n*               CLOSE THE CONTROL PDS.                            *\n*               OFFLOAD THE DUMP DATA SET TO TAPE.                *\n*               RESET THE DUMPED DATA SET.                        *\n*               CLOSE DUMP DATA SET.                              *\n*               RETURN TO CALLING ROUTINE.\n* IF THE TIME AND DATE ARE NOT ABVAILABLE FROM THE DUMP DATA SET, *\n* THEN THE CURRENT CPU TIME AND DATE ARE USED TO STORE IN THE     *\n* MEMBER AND ITS NAME.                                            *\n*******************************************************************\n         ST    R11,PROC0050           SAVE RETURN ADDRESS.\n         BAL   R11,DYALTAPE           DYNAMIC ALLOCATE A TAPE DRVE.\n         BAL   R11,DYALCONT           DYNAMIC ALLOCATE CTL PDS.\n         OPEN  (DARTAPE,(OUTPUT))     OPEN OUTPUT TAPE DATA SET.\n         RDJFCB DARTAPE\n*\n*        EXTRACT TIME AND DATE FROM  SVC DUMP\n*\n         CLI   HDRID,X'FF'         TEST FOR GOOD HEADER RECORD\n         BE    CONVTOD             IF GOOD, GOTO CONVERT TOD ROUTNE.\n         TIME  DEC                 ELSE GET  CURRNT CPU TIME N DATE.\n         SRL   0,4                 REMOVE HUND SEC.\n         IC    0,ZONE              FORCE GOOD ZONE\n         ST    0,TIMEDAY           STORE TIME AND DATE\n         ST    1,DATE\n         B     EDITTIME            GO EDIT TIME AND DATE\nCONVTOD  LA    1,CONVPARM          GET ADDRESS OF TOD CONVERT LIST\n         CALL  DARCNVRT\nEDITTIME MVC   EDITFD1,PATTERN1    MOVE EDIT PATTERN\n         ED    EDITFD1,TIMEDAY     EDIT TIME TO RECORD\n         MVC   EDITFD2,PATTERN2    MOVE EDIT PATTERN\n         ED    EDITFD2,DATE        EDIT DATE TO RECORD\n*\n*        BUILD PDS MEMBER NAME IN FOLLOWING FORMAT: SDDDHHMM\n*        WHERE        S   = SYSTEM  ID\n*                     DDD = JULIAN DATE\n*                     HH  = HOUR\n*                     MM  = MINUTE\n*\n         MVC   DARID(1),91(R9)        MOV SYSTM ID TO MEMBR NAME.\n         MVC   DARID+1(3),EDITFD2+6   MOV JUILAN DAY TO MEMBR NAME\n         MVC   DARID+4(2),EDITFD1+2   MOV HH TO MEMBR NAME.\n         MVC   DARID+6(2),EDITFD1+5   MOV MM TO MEMBER  NAME\n*\n*        BUILD FIRST RECORD OF PDS MEMBER.\n*\n         CLI   HDRID,X'FF'            TEST FOR VALID HEADER RECORD\n         BE    GOODHDR                BRANCH IF YES\n         SR    15,15                     CLEAR R15\n         IC    15,KEY1            GET STOR PROTECT KEY FOR THIS RECRD\n         SLL   15,4                      MAKE ROOM FOR ZONE\n         O     15,ZONECHAR               ADD ZONE CHARACTER\n         ST    15,UNPKWORK               STORE VALUE INTO UNPKWORK\n         UNPK  TITLKEY,UNPKWORK+2(2)     UNPACK KEY TO TITLE AREA\n         SR    15,15                     CLEAR R15\n         LH    15,ASID                   GET STOR ASID FOR THIS RECRD\n         SLL   15,4                      MAKE ROOM FOR ZONE\n         O     15,ZONECHAR               ADD ZONE CHARACTER\n         ST    15,UNPKWORK               STORE VALUE INTO UNPKWORK\n         UNPK  TITLASID,UNPKWORK+2(2)    UNPACK ASID TO TITLE AREA\n         SR    15,15                     CLEAR R15\n         L     15,ADDR                   GET STOR ADDR FOR THIS RECRD\n         SLL   15,4                      MAKE ROOM FOR ZONE\n         O     15,ZONECHAR               ADD ZONE CHARACTER\n         ST    15,UNPKWORK               STORE VALUE INTO UNPKWORK\n         UNPK  TITLADDR,UNPKWORK         UNPACK ADDR TO TITLE AREA\n         MVC   TITLE,TITLE2              MOVE NEW TITLE TO TITLE AREA\n         B     TITLETR                   GO TO TITLE TRANSLATE\nGOODHDR  MVC   TITLE,DUMPTITL            SAV TITLE FRM DAR DMP DAT SET\nTITLETR  TR    TITLE,TRTABLE\n         MVC   TAPEID,JFCBVOL            GET VOL LABL OF OUTPUT TAPE\n*\n*        GET   CURRENT MEMBER 'DARNUMBS'\n*\nGETDAR#  MVC   CPUID,CPUPT        PUT CPUID INTO 1ST RECRD FRM WRK DCB\n*        FIND  CONT1,MEMBER,D  LOCATE DARNUMBS MEMBER IN CONTROL\n*        LA    2,CONTDECB      GET ADDRESS FOR READ\n*        READ  (2),SF,MF=E     READ IN CURRENT DAR NUMBER RECORD\n*        CHECK (2)             CHECK READ\n*        CLC   CONTNUM(3),=CL3'NEW'   1ST ENTRY \"DARNUMBS\" ?\n*        BNE   $NOPE                  NOPE.\n*        PACK  CONTNUM(3),$FIRST\n*        WTO   'IJBDARTH - MEMBER \"DARNUMBS\" INITIALIZED',ROUTCDE=2\n*        B     $ZERO        ZERO THE BASE NUMBER\n*$FIRST  DC    CL2'01'      FOR BASE NUMBER (CONSTANT)\n*$NOPE   NOP   *\n*        UNPK  DAR#,CONTNUM(3) ADD CURRENT DAR NUMBER TO CONTROL RECORD\n*        CLC   DAR#,=C'09999' TEST FOR MAX NUMBER\n*        BNE   ADDDAR#        BRANCH IF NO\n*$ZERO   ZAP   CONTNUM(3),=P'0'   RESET DAR NUMBER TO ZERO\n*\n*        ADD 1  TO CURRENT DAR NUMBER\n*\n*ADDDAR# AP    CONTNUM(3),=PL1'1' UPDATE DAR NUMBER CONTROL\n*        OI    CONTNUM+2,X'0F'    FORCE GOOD ZONE\n*        WRITE (2),SF,MF=E     WRITE DARNUMBS CONTROL RECORD BACK\n*        CHECK (2)             CHECK WRITE  UPDATE\n*\n*        THIS  ROUTINE WRITES THE NEW MEMBER AND UPDATES THE DIRECTRY.\n*        IF MEMBR NAME EXIST, 1 IS ADDED TO NAME UNITL IT IS UNIQUE.\n*\nOPNCONT1 DS    0H\n         OPEN  (CONT1,(OUTPUT))       OPEN DAR CNTL DATA SET AS MOD.\n         NOTE  CONT1                  GET EOF TTR POINTER.\n         ST    1,PDSLIST              SAVE TTR POINTER FOR STOW\n         OI    PDSLIST+3,X'0F'        INDICATE 15 HLF WRDS OF USR DATA\n*\nTESTNAME MVC   TESTMEMN,DARID         MOVE DAR NAME TO BLDL LIST\n         BLDL  CONT1,TESTMEMB         SEE IF MEMBER EXIST ALREADY.\n         LTR   15,15                  IF CC = 0, MEMBR ALREADY EXITS,\n         BZ    ADJUSTNO               THEN CHANGE MEMBER NAME.\n         B     WRITEREC               ELSE WRITE MEMBER RECOREDS.\nWRKFLD01 DS    PL2                    WORK FLD FOR MEMBR NAME ADJSMNT\nWRKUNPCK DS    CL3                    SAME AS ABOVE\nADJUSTNO DS    0H\n         PACK  WRKFLD01,DARID+6(2)    GET MINUTES FLD OF MEMBR NAME.\n         AP    WRKFLD01,=PL1'1'       ADD ONE TO THIS FIELD.\n         OI    WRKFLD01+1,X'0F'       ADJUST THE ZONE.\n         UNPK  WRKUNPCK,WRKFLD01      CONVERT TO CHARACTER.\n         MVC   DARID+6(2),WRKUNPCK+1  MOV BACK TO MEMBER NAME.\n         MVI   DARID+8,C'*'           MOVE IN 'ADJUSTMENT-MADE' FLAG.\n         B     TESTNAME               TEST AGAIN.\n*\nWRITEREC WRITE CONTWRIT,SF,CONT1,TAPEID WRITE FIRST RECORD\n         CHECK CONTWRIT               CHECK WRITE.\n         WRITE CONTWRT2,SF,CONT1,REC2 WRITE SECOND RECORD\n         CHECK CONTWRT2               CHECK WRITE\n         MVI   DARID+8,C' '           CLEAR  'ADJUSTMENT-MADE' FLAG.\n         MVC   PDSTABLE,DARID         MOV DARID TO MEMBR NAME FOR STOW\n         MVC   VOLID,TAPEID           PUT DUMP TAPE ID INTO USR DATA.\n         MVC   DUMPNUM,CPUID+4        GET DUMP ID NUMBER\n         STOW  CONT1,PDSTABLE         ADD MEMBR TO DAR CONTRL DATASET\n         LTR   15,15                  WAS STOW SUCCESSFUL ?\n         BZ    CLOSEFLE               YES\n         B     GETRC                 NO, GET RETURN AND REASON CODES.\n* MSG LENGTH    12345678901234567890123456789012345678\nWTOLIST  WTO   'IJBDARTH - STOW FAILED, RC=NN, RS=NN ',ROUTCDE=2,MF=L\nWKPACK   DS    0D\n         DC    PL8'99'\nWKUNPACK DC    3C'N'\nGETRC    DS    0H\n*        GET RETURN CODE.\n         CVD   15,WKPACK\n         UNPK  WKUNPACK,WKPACK+6(2)              GET LAST TWO BYTS\n         OI    WKUNPACK+L'WKUNPACK-1,X'F0'       ADJST SIGN.\n         MVC   WTOLIST+(L'WTOLIST-1+28)(2),WKUNPACK+1\n*        GET REASON CODE.\n         CVD   R0,WKPACK                         GET REASN COD FRM R0\n         UNPK  WKUNPACK,WKPACK+6(2)              GET LAST TWO BYTS\n         OI    WKUNPACK+L'WKUNPACK-1,X'F0'       ADJST SIGN.\n         MVC   WTOLIST+(L'WTOLIST-1+35)(2),WKUNPACK+1\n         WTO   MF=(E,WTOLIST)\nCLOSEFLE CLOSE (CONT1,FREE)    CLOSE AND FREE DAR CONTROL DATASET\n*\n*        THIS  CODE WAS TO SAVE THE DUMP TITLE CARD FOR INPUT TO\n*        AMPRDMP BUT WAS NEVER IMPLMENTED.\n*\n*        OPEN  (DARSYSIN,(OUTPUT)) OPEN DARSYSIN\n*        MVI   TITLECD+71,C' ' CLEAR COL 72 OF TITLE CARD\n*        PUT   DARSYSIN,TITLECD WRITE AMDPRDMP TITLE CARD TO SYSIN\n*        CLOSE DARSYSIN        CLOSE DARSYSIN\n*\n         L     10,32(DCBREG)   SAVE DCB END OF DATA ADDRESS(EODAD)\n         LA    1,COPYCOMP      GET COPY COMPLETE EODAD\n         STCM  1,7,33(DCBREG)  STORE INTO DAR DCB\n         SPACE 3\n*\n*        THIS  ROUTINE ACTUALLY WRITES THE DUMP DATASET TO TAPE.\n*\nDARCOPY  PUT   DARTAPE,IOAREA  WRITE DAR DUMP RECORD TO TAPE\n         READ  RDARC,SF,(DCBREG),IOAREA READ NEXT RECORD FROM DAR\n         CHECK RDARC           CHECK READ - AT EODAD GO TO COPYCOMP\n         B     DARCOPY         GO WRITE RECORD\n         SPACE 3\nCOPYCOMP CLOSE (DARTAPE,FREE)  CLOSE AND FREE OUTPUT TAPE\nCLOSEDAR EQU   *\n         CLOSE ((DCBREG))      CLOSE DAR DCB\n         OPEN  ((DCBREG),(OUTPUT)) RESET DAR DATASET BY HAVING CLOSE\n*                                  WRITE END-OF-FILE AT BEGINING\n*                                  OF DAR DATA SET JUST PROCESS.\n         CLOSE ((DCBREG))\n         OPEN  ((DCBREG),(INPUT))  REOPEN DAR DATASET\n         ST    10,32(DCBREG)  RESTORE EODAD POINTER IN DCB\n         L     R11,PROC0050   LOAD RETURN ADDRS OF CALLING MODULE\n         BR    11             RETURN.\nPROC0050 DC    F'0'           SAVE ADDRESS OF CALLING MODULE.\n         EJECT\nDYALTAPE DS    0H\n********************************************************************\n*                                                                  *\n*        DYNAMICALLY ALLOCATE A DUMP  TAPE DRIVE.           /V 1.4 *\n*                                                                  *\n********************************************************************\n         LA    1,DARALLOC             GET A TAPE DRIVE\n         DYNALLOC\n         LTR   15,15          TEST FOR GOOD ALLOCATE\n         BZ    TAPEXIT        BRANCH IF OK\n         CLC   DARERROR(2),=X'0210' TEST FOR DSN ENQ PROBLEMS\n         BE    $DARWAIT       ISSUE MESSAGE AN WAIT A MIN.. V 1.3\n         CLC   DARERROR(2),=X'0484'  DID OPERATOR FAIL REQUEST? V 1.3\n         BE    OPERFAIL       YES...NOTIFY AND TRY AGAIN  V 1.3\n         CLC   DARERROR(2),=X'0214'  UNITS NOT AVAIL ?    V 1.3\n         BNE   DARFAIL        BRANCH IF NO                V 1.3\n         WTO   'IJBDARTH-UNIT NOT AVAILABLE FOR DUMP TAPE, WILL RETRY I*\n               N 5 MINUTES',ROUTCDE=(2,11)                V 1.3\n         B     $TURETRY                                   V 1.3\nOPERFAIL WTO   'IJBDARTH-OPERATOR REPLIED TO TAPE ALLOCATION WITH \"NO\" X\n               *RETRY* ',ROUTCDE=(2,11)                   V 1.3\n$TURETRY MVC   DARERROR(2),=X'0000'  CLEAR ERROR INDICATOR   V 1.3\n         SR    15,15                 CLEAR REG15             V 1.3\n         STIMER WAIT,DINTVL=TIME5    WAIT BEFORE RETRY       V 1.3\n         B     DYALTAPE              TRY TAPE ALLOCATION AGAIN V 1.3\n$DARWAIT WTO   'IJBDARTH WAITING FOR SYS1.DARDUMP DATASET',            X\n               ROUTCDE=(2,11)         V 1.3\n         STIMER WAIT,DINTVL=TIME2     WAIT TWO MINUTES.\n         B     DYALTAPE               GO TRY TO ALLOCATE\nDARFAIL  WTO   'IJBDARTH - ALLOCATE FAILED FOR DDN=DARTAPE',ROUTCDE=2\n         L     13,SAVE+4             GET SAVE AREA POINTER.\n         RETURN (14,12),RC=30\nTAPEXIT  DS    0H\n         BR    R11                    RETURN TO CALLING SOURCE.\n         EJECT\nDYALCONT DS    0H\n*******************************************************************\n*                                                                 *\n*         DYNAMICALLY ALLOCATE THE DARTH CONTROL PDS.             *\n*                                                                 *\n*******************************************************************\n         LA    1,CT1ALLOC             GET POINTER TO SVC99 PRAMLIST.\n         DYNALLOC                     ALLOCATE DAR CONTROL DATASET\n         LTR   15,15                  TEST FOR GOOD ALLOCATE\n         BZ    CONTEXIT               BRANCH IF OK\n         CLC   CT1ERROR(2),=X'0210'   TEST FOR DSN ENQ PROBLEMS\n         BNE   CT1FAIL                BRANCH IF NO\n  WTO   'IJBDARTH WAITING FOR SYS3.DARCNTRL            ',ROUTCDE=2 WFB4\n         STIMER WAIT,DINTVL=TIME2\n         B      DYALCONT              GO TRY AGAIN TO ALLOCATE\nCT1FAIL  WTO   'IJBDARTH - ALLOCATE FAILED FOR DDN=CONT1',ROUTCDE=2\n         L     13,SAVE+4              GET SAVEAREA POINTER\n         RETURN (14,12),RC=34\nCONTEXIT BR    R11                    RETURN TO CALLING SOURCE.\n         EJECT\n$ERRENQ  EQU   *              VERSION 1.4\n********************************************************************\n*  ENQUEUE PROTECTION TO ALLOW ONLY 1 DARTH ACTIVE IN SYSTEM/V 1.4 *\n********************************************************************\nMLWTOMSG WTO   ('IJBDARTH-ENQUEUE FAILED                 ',D),         *\n               ('        -MAJOR:SYSVADER, MINOR:DEATHSTR ',D),         *\n               ('        -RETURN CODE=12    *DARTH*      ',D),         *\n               ('        -ONLY ONE COPY OF THE DARTH IS  ',D),         *\n               ('        -ALLOWED TO BE ACTIVE AT ONE    ',D),         *\n               ('        -TIME. ENQUEUE NAME IN USE !    ',DE),        *\n               ROUTCDE=2,DESC=7,MCSFLAG=NOCPY           V 1.4\n         L    13,SAVE+4                                 V 1.4\n         RETURN (14,12),RC=12                           V 1.4\n         TITLE 'DARTEST - DATA AREAS'\n         SPACE 2\n********************************************************************\n* DCBS FOR DARTEST\n********************************************************************\n         DC    CL8'MODELDCB'\nMODELDCB DCB   DDNAME=DUMMMMMY,DSORG=PS,RECFM=F,MACRF=(RP,W),          C\n               BLKSIZE=4104,EODAD=POINT0,EXLST=EXITLIST\n         DC    CL8'DARTAPE'\nDARTAPE  DCB   DDNAME=DARTAPE,DSORG=PS,RECFM=F,MACRF=(PM),             C\n               BLKSIZE=4104,EXLST=EXITLIST\n*        DC    CL8'DARSYSIN'\n*ARSYSIN DCB   DDNAME=DARSYSIN,DSORG=PS,RECFM=FB,MACRF=(PM)\n         DC    CL8'CONT1DCB'\nCONT1    DCB   DDNAME=CONT1,DSORG=PO,MACRF=(R,W),EODAD=ABEND\n         SPACE 2\nABEND    ABEND 620,DUMP               EODAD FOR DD 'CONT1'\n********************************************************************\n* GENERAL DATA CONSTANTS\n********************************************************************\n         DC    C'REG SAVEAREA'\nSAVE     DC    18F'0'\nTIME5    DS    0D\n         DC    C'00050000'           ALLC RECOVRY WAIT TIME.\n*                HHMMSSTT\nTIMELIMT DS    0D\n         DC    C'00150000'           WAIT TIME LIMIT:DARTH SLEEP TIME.\n*                HHMMSSTH\nTIME2    DS    0D                    WAIT FOR DATA SET TIME LIMIT.\n         DC    C'00020000'\n*                HHMMSSTH\nSTART    DC    A(1)                  RELTV BLK ADDRS FOR POINT MACRO.\n         SPACE 2\n********************************************************************\n* ALLOCATE LIST FOR DDNAME=DARTAPE (FOR DARTEST)\n********************************************************************\n         DS    0D\n         DC    CL8'DARALLOC'\nDARALLOC DC    AL1(128),AL3(ORBLK)\n         DS    0F\nORBLK    DC    X'14'                  LENGTH OF REQUEST BLOCK\n         DC    X'01'                  VERB CODE, X'01'= DSN ALLOCATN.\n         DC    X'4000'                FLAGS1,DO NOT USE EXSTING ALLOC.\nDARERROR DC    CL4' '                 ERROR CODE AND REASON.\n         DC    A(ORTXT)               TEXT POINTERS\n         DC    A(0)                   RESERVED.\n         DC    X'000000'              FLAGS2, FOR AUTHRZED PGMS ONLY.\nORTXT    DC    A(DARDD)               START OF TEXT POINTERS.\n         DC    A(ORDISP)\n         DC    A(ORRETN)                                          WFB1\n         DC    A(ORNEW)\n         DC    A(ORDEV)\n         DC    A(ORDSN)\n         DC    AL1(128),AL3(ORUNALC)\n*\n*              KEY     # OF PRM  LEN     PARM VALUE\nDARDD    DC    X'0001',X'0001',X'0007',C'DARTAPE'   DDNAME\nORDEV    DC    X'0015',X'0001',X'0004',C'TAPE    '  UNIT TYPE\nORDSN    DC    X'0002',X'0001',X'000C',C'SYS1.DARDUMP'\nORNEW    DC    X'0004',X'0001',X'0001',X'04'        DISP=NEW\nORDISP   DC    X'0005',X'0001',X'0001',X'08'        DISP=KEEP\nORRETN   DC    X'0023',X'0001',X'0002',X'0001'   SEE RETENPRD\nORUNALC  DC    X'001C',X'0000'        FREE DATA SET AFTR CLOSE.\n*\nRETENPD  DC    X'0007'                7 DAY RETENTION PERIOD\nPDSMNLST DS    0F                     POINTER LIST. POINTER TO :\n         DC    A(RETENPD)             PTR TO TAPE RETENTION PERIOD.\n         DC    A(CONTDSN)             PTR TO CNTRL DATA SET NAME.\n         SPACE 2\n********************************************************************\n* ALLOCATE LIST FOR DAR CONTROL DATASET (FOR DARTEST)\n********************************************************************\n         DS    0D\n         DC    CL8'CT1ALLOC'\nCT1ALLOC DC    AL1(128),AL3(CTBLK)\n         DS    0F\nCTBLK    DC    X'14'\n         DC    X'01'          ALLOCATION\n         DC    X'4000'\nCT1ERROR DC    CL4' ' ERROR AND REASON\n         DC    A(CTTXT)\n         DC    A(0)\n         DC    X'000000'\nCTTXT    DC    A(CT1DD)\n         DC    A(DISPMD)\n         DC    AL1(128),AL3(CONTNAME)\n*\n*              KEY     # OF PRM  LEN     PARM VALUE\nCT1DD    DC    X'0001',X'0001',X'0005',C'CONT1'\nDISPMD   DC    X'0004',X'0001',X'0001',X'02' DISP=MOD\nCONTNAME DC    X'0002',X'0001',X'002C'\n         DC    C'SYS3.DARCNTRL                               ' WFB4\nCONTDSN  DC    C'SYS3.DARCNTRL                               '\n         SPACE 2\n********************************************************************\n* DCB EXIT LIST PARMS\n********************************************************************\n         DS    0F\nEXITLIST DC    AL1(128+7),AL3(JFCB)\n         DS    0D\nJFCB     DC    CL200' '\nJFCBVOL  EQU   JFCB+118\n         SPACE 2\n********************************************************************\n* CONSTANTS FOR TITLE CARD AND CONTROL RECORD\n********************************************************************\nTITLECD  DC    C' TITLE  ''TAPE#'\nTAPEID   DC    C'T00000'\n         DC    C' '\nDARID    DC    C'DAR'\nDAR#     DC    C'00000'               IF A '*' FOLLOWS THIS FLD, A TIME\n         DC    C' CPUID='             ADJSMNT WAS TO PDS MEMBER NAME.\nCPUID    DC    CL6' '                 CONTAINS SYSTEM ID (SYSAD0,ETC)\n         DC    C' '\nTITLE    DC    CL50' '\n         DC    C'  '''\n         DC    CL40' '\n         SPACE  2\nTITLE2   DC    CL50' '\n         ORG   TITLE2\n         DC    C'STORAGE KEY='\nTITLKEY  DC    CL3' ',C' ASID='\nTITLASID DC    CL3' ',C' STORAGE ADDR='\nTITLADDR DC    CL7' '\n         ORG   TITLE2+50\n         SPACE 2\n********************************************************************\n* GENERAL DATA CONSTANTS\n********************************************************************\nMEMBER   DC    CL8'DARNUMBS'\nTESTMEMB DC    H'1',H'58'\nTESTMEMN DC    CL8' ',CL50' '\n         DS    0F\nPDSTABLE DC    CL8' '                 DIRECTORY ENTRY, MEMBERNAME\nPDSLIST  DC    F'0'                   TTR AND NBR OF BYTS IN USR DAT\nUSERDATA DS    0CL30                  USER DATA FIELD IN ISPF FORMAT.\n         DC    XL2'0501'              VERSION AND MOD NUMBER.\n         DC    XL2'0000'              RESERVED FOR FUTURE USE.\n         DC    2XL4'0000000F'         CREATE AND LST MODIFIED DATE\n         DC    XL2'0000'              TIME MODIFIED.\n         DC    2XL2'0002'             CURRENT AND INITAL SIZE.\n         DC    XL2'0000'              MOD.\nVOLID    DS    CL6                    TAPE VOL ON WHICH DUMP RESIDES.\nDUMPNUM  DS    CL2                    SYS1 DUMP DATA SET NUMBR.\n         DC    CL2'  '                TWO BYTE FILLER TO COMPLETE FLD.\nZONE     DC    X'0C'\nUNPKWORK DC    F'0'\nZONECHAR DC    F'15'\nCONVPARM DC    A(DUMPTIME),A(DATE)    A(INPUT), A(OUTPUT)\nDATE     DC    F'0'                   OUTPUT FROM CONVERT ROUTINE\nTIMEDAY  DC    F'0'                   OUTPUT FROM CONVERT ROUTINE\nREC2     DS    0CL80\n         DC    C' TIME:'\nEDITFD1  DC    C' 017.30.00'\n         DC    C' DATE:'\nEDITFD2  DC    C'   77.300'\n         DC    CL51' '\nPATTERN1 DC    X'402120204B20204B2020'\nPATTERN2 DC    X'40202120204B202020'\n         READ  CONTDECB,SF,CONT1,CONTIO,MF=L\nCONTIO   DC    CL80' '\nCONTNUM  EQU   CONTIO\n         LTORG\nDSN      EQU   X'80'\nSYSID    EQU   X'81'\n$ENQ     DC    CL16' '                                V 1.4\n$ENQL    ENQ   (CP30,R2D2,E,,SYSTEM),RET=USE,MF=L     V 1.4\nCP30     DC    CL8'SYSVADER'                          V 1.4\nR2D2     DC    CL8'DEATHSTR'                          V 1.4\n*        IEFZB4D0                     MACRO  TO LIST SV99 STUFF\n*        IEFZB4D2                     ''        ''          ''\nDCBWORK  DSECT                        DCB MASK.\nDCBLNGTH DS    0XL100                 DCB WORK AREA LENGTH.\nRDCB     DS    XL88                   DCB SYSTEM DATA.\nCPUPT    DS    CL6                    DCB USER DATA.\n         DS    XL(L'DCBLNGTH-(*-DCBLNGTH)) RESERVED FOR FUTURE USE.\nUTDARTH  CSECT                        END OF DSECT.\nDCBLIST  DC    99F'0'\nTRTABLE  DC    CL193' ',C'ABCDEFGHI       JKLMNOPQR        STUVWXYZ'\n         DC    C'      0123456789ABCDEF'\n         ORG   TRTABLE+97\n         DC    C'/'\n         ORG   TRTABLE+126\n         DC    C'='\n         ORG   TRTABLE+256\n**********************************************************************\n*\n*  THIS CODE DEFINES THE DUMP HEADER AND TITLE RECORD (FROM AMDSADMP)\n*  'IOAREA'  IS ORG'ED OVER THIS AREA CAUSING THE CONSTANTS TO BE\n*  LOST  AFTER  THE FIRST READ OF A DUMP DATA SET.\n*\n**********************************************************************\nDUMPRCD  DS    0F\nHDRID    DC    XL1'FF'   HEADER ID    HEADER ID\nRECID    DC    XL1'FF'   RECORD ID    RECORD ID\nASID     DC    XL2'0000'              ASID BEING DUMPED\nDUMPNAME DC    CL8'AMDSADMP'          NAME OF DUMP PROGRAM\nDUMPTIME DC    F'0'                   TITEL OF DUMP\nDUMPDATE DC    F'0'                   DATE OF DUMP\nDUMPTITL DC    25CL4' '               TITLE OF DUMP\nDUMPCSW  DC    2F'0'                  CSW AT TIME OF DUMP\nDUMPCAW  DC    F'0'                   CAW AT TIME OF DUMP\n*\nKEY1     EQU   HDRID                  STORAGE\nKEY2     EQU   RECID                  STORAGE\nADDR     EQU   DUMPNAME               ADDRESS BEING DUMPED.\nSTAFLAGS EQU   ASID                   RECORD FLAGS\nRESERVD  EQU   ASID+1                 RSVD FIELD\nCPUADDR  EQU   DUMPNAME+2             CPU BEING DUMPED\nHEADLNGH EQU   DUMPTITL+68         SET UP FOR DUMP TITLE LENGTH\n**********************************************************************\n         ORG   DUMPRCD\nIOAREA   DC    42XL100'00'\n         END\nTITLE    TITLE 'DARTH BUILD DCB ENTRIES '\n*\n*        THIS ROUTINE IS LINKED INTO PROGRAM 'UTDARTH'. ITS FUNCTION\n*        IS TO BUILD A TABLE OF DCBS FROM A TABLE OF DDNAMES PASSED TO\n*        IT FROM THE CALLING PROGRAM AND CONTROL INFORMATION USED BY\n*        'UTDARTH'\n*\n*\n*        R1    POINTS TO DDNAME TABLE PREFIX OR DD NAME  ENTRY.\n*        R2    POINTS TO  BYTE 7 IN   DDAME.\n*        R4    POINTS TO TABL OF DCB  ADDRESSES.\n*        R5    POINTS TO A MODEL DCB  USED TO BUILD WRKING DCBS.\n*        R8    LOOP COUNTER (# OF VAL ID DCBS).\n*        R9    POINTS TO CURRENT DCB  IN DCB TABLE\n*        R10   WORK REG, COPY OF R1.\n*        R12   PGM BASE REGISTER.\n*        R13   PTR TO THIS MODULS SAVE ADDRESS.\n*\n*\n*\n*\n*\n*\nDARBLDCB CSECT\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*\n         PRINT ON\n         STM   14,12,12(13)\n         LR    12,15                  SET UP BASE REG\n         USING DARBLDCB,12            ESTABLISH ADDRSIBLITY\n         ST    13,SAVE+4              SAVE SAVEAREA POINTER\n         LR    11,13                  SAVE REG 13 FOR STORE\n         LA    13,SAVE                GET THIS CSECT'S SAVEAREA ADDR\n         ST    13,8(11)               STORE NEW SAVEAREA ADDR\n*\nDDTBLPFX DSECT\nNUMBRDD  DS    XL4                    NUMBR OF DDS PRESENT\nDCBADDRS DS    XL4                    PTR TO TABLE  OF DCB ADDRSSES.\nDCBTBL   DS    XL4                    PTR TO DCB TABLE.\nDCBMODL  DS    XL4                    POINTS TO A MODEL DCB.\nDDNAMES  DS    XL800                  TABLE OF DD NAMES.\nDARBLDCB CSECT\n         LR    R10,R1                 SAV POINTR TO DD NAME TBL PRFIX.\n         USING DDTBLPFX,R1            ESTABLSH DSECT ADDRSIBLTY\n         L     R8,NUMBRDD             GET NUMBR OF DCBS FOR LOOP\n         L     R4,DCBADDRS            GET PTR TO DCB ADDRESS TABLE.\n         L     R9,DCBTBL              GET POINTR TO DCB TABLE\n         L     R5,DCBMODL             GET POINTR TO MODEL DCB.\n         DROP  R1                     FINISH WITH DSECT\n*\nWORKDCB  DSECT\nDCBAREA  DS    XL88                   ACTUAL DCB USED IN OPN/CLSE ETC.\nDUMPTYPE DS    CL5                    DUMP IDENTIFER; SYSG,SYSA, ETC.\nDUMPNMBR DS    CL1                    DUMP NUMBER, 0, 1, 2, ETC.\nDARBLDCB CSECT\n*\n         USING WORKDCB,R9             ESTBLSH ADDRBLTY FOR DCB.\n         LA    R1,16(0,R1)            POINT TO FIRST DDNAME.\nBUILDDCB DS    0H\n         ST    R9,0(4)                SAVE PTR TO THIS DCB FOR OPEN.\n         MVI   0(4),X'00'             INDICATE 'OPEN,INPUT' DCB\n         MVC   DCBAREA,0(R5)          SET UP WORKING DCB.\n         MVC   DCBAREA+X'28'(8),0(R1) MOVE DDNAME TO WORKING DCB.\n         LR    R2,R1                  WORKING POINTR TO DD NAME ENTRY\n         LA    R2,6(0,R1)             POINT TO 7 BYTE IN DDNAME\n         CLC   0(1,R2),=C'$'          IF NOT A CICS INDICATOR\n         BNE   NOTCICS                THEN GO TO NXT ROUTINE\n         MVC   DUMPTYPE,=C'CIC$D'     ELSE MOV IN DUMP IDENTIFIER\n         MVC   DUMPNMBR,1(R2)         AND DUMP NMBR, BYT 8 IN DDNAME.\n         B     BUILDXIT               EXIT TO LOOP THRU AGAIN.\nNOTCICS  DS    0H\n         MVC   DUMPTYPE(3),=C'SYS'    MOV IN DUMP IDENTIFIER\n         MVC   DUMPTYPE+3(1),0(R2)    MOV IN CPU  IDENTIFIER\n         MVC   DUMPTYPE+4,=C'D'       MOV IN 'DUMP' INDICATOR\n         MVC   DUMPNMBR,1(R2)         MOVE IN DUMP NUMBER.\nBUILDXIT DS    0H\n         LA    R1,8(0,R1)             POINT TO NXT DD NAME IN TBL\n         LA    R4,4(0,R4)             POINT TO NXT DCB TBL ADDRESS.\n         LA    R9,100(0,R9)           POINT TO NXT WRK DCB IN TBL.\n         BCT   R8,BUILDDCB            REDUCE LOOP BY 1.\n         MVI   0(4),X'FF'             SET END OF DCB LIST FLAG.\n         S     R4,FOUR                BACK UP PTR TO LAST DCB POINTER.\n         OI    0(R4),X'80'            INDICATE LAST DCB FOR OPEN SVC.\n         L     R13,SAVE+4             RESTOR CALLR'S SAVE ADDR.\n         RETURN (14,12)               RETURN TO CALLER.\n*\nSAVE     DC    18F'0'\nFOUR     DC    01F'4'\n         END\nDARCNVRT CSECT\n*        THIS MODULE RECEIVES CONTROL FROM A    CALLING MODULE THAT\n*        PASSES IT A POINTER VALUE IN REGISTER ONE. THE VALUE POINTS\n*        TO A FIELD OF TWO WORDS, EACH OF WHICH CONTAINS A POINTER\n*        VALUE TO A DATA FIELD.   THE FIRST DATA FIELD IS A DOUBLE-\n*        WORD  AND IS INPUT TO THIS PROGRAM. THIS DOUBLE WORD\n*        CONTAINS THE  TOD CLOCK EXTRACTED FROM THE DUMP HEADER OF AN\n*        SVC OR STANDALONE DUMP.\n*                THE SECOND DATA FIELD IS A DOUBLEWORD IN WHICH THE\n*        FIRST WORD WILL CONTAIN A DATE CONVERTED FROM THE TOD CLOCK.\n*        THE SECOND DATA FIELD WILL CONTAIN THE TIME ALSO CONVERTED\n*        FROM  THE TOD CLOCK.\n*\n         USING DARCNVRT,15\n         B     STORE\n         DC    AL1(L'ID)\nID       DC    C'TOD CONVERT - JACK JACKSON - 4/20/77'\n         DROP  15\n         USING DARCNVRT,12\nSTORE    STM   14,12,12(13)   SAVE CALLING REGS\n         LR    12,15          SETUP BASE REG\n         ST    13,SAVE+4      SAVE CALLING SAVEAREA POINTER\n         LA    13,SAVE        SETUP NEW SAVE AREA\n         LM    2,3,0(1)       SET BASE FOR TOD VALUE AND DATE AND TIME\n         USING TODPARM,2\n         USING DATETIME,3\n         L     1,TOD+4        GET LO32 BITS INTO REG1\n         LM    14,15,TOD      GET TOD VALUE TO CONVERT\n         SRDL  14,25\n         D     14,DAYSFACT\n         AL    15,LOGONE\n         SLL   15,2           MULTI DAYS BY 4\n         LR    0,14           SAVE NUMBER OF SECS SINCE MIDNIGHT\n         SR    14,14          ZERO 14 FOR DIV.\n         D     14,DAYS4YRS\n         SRL   14,2\n         LTR   15,15          TEST FOR YEAR 1900\n         BZ    YEAR1900       BRANCH IF YES\n         AL    14,LOGONE\n         LR    7,15\n         MH    7,K1000\n         LR    15,7\nYEAR1900 ALR   15,14\n         CVD   15,CVDWORK     DATE\n         OI    CVDWORK,X'0F'\n         MVC   DATE,CVDWORK+4 MOVE DATE TO DATE RETURN AREA\n**** GET TIME\n         SLL   1,7\n         SRDL  0,19\n         D     0,MICSSEC\n         SR    0,0\n         D     0,SECSMIN\n         LR    14,0\n         SR    0,0\n         D     0,MINSHOUR\n         LR    7,0\n         MH    7,K100\n         ALR   7,14\n         LR    6,1\n         MH    6,K10000\n         ALR   7,6\n         CVD   7,CVDWORK     DATE\n         OI    CVDWORK+7,X'0F'\n         MVC   TIME,CVDWORK+4\n         L     13,SAVE+4\n         LM    14,12,12(13)\n         SR    15,15\n         BR    14\nCVDWORK  DC    D'0'\nSAVE     DC    18F'0'\nLOGONE   DC    F'1'\nDAYSFACT DC    F'10546875'\nDAYS4YRS DC    F'1461'\nMICSSEC  DC    F'1000000'\nSECSMIN  DC    F'60'\nMINSHOUR DC    F'60'\nK10000   DC    H'10000'\nK1000    DC    H'1000'\nK100     DC    H'100'\nTODPARM  DSECT\nTOD      DC    D'0'\nDATETIME DSECT\nDATE     DC    PL4'0'\nTIME     DC    PL4'0'\n         END\nTITLE    TITLE 'DARTH GET DDNAMES'\nDARGETDD START\n*\n*        THIS ROUTINE IS LINKED WITH PROGRAM 'UTDARTH'  AND IS USED\n*        TO BUILD A TABLE OF VALID DDNAMES. EACH DDNAME IS ASSOCIATED\n*        WITH A SYS1.DUMP DATA SET DEFINED IN THE JOBS JCL.\n*\n*        THE ROUTINE  CAN BREAK WITH  A USER CODE FOR THE FOLLOWING\n*        REASONS;\n*\n*               USER 004, NO DD'S FOUND THAT START WITH //DARDMP\n*               USER 008, DUPLICATE '//DARDMP' DD'S ENCOUNTERED.\n*               USER 012, //DARDMP  DD NOT 8 CHARACTRS LONG.\n*               USER 016, OVER 99 '//DARDMPNN'  DD'S FOUND.\n*\n*\n*\n*\n*\nR0       EQU   0\nR1       EQU   1                      POINTS TO DDNAME TABLE  PREFIX\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11                     RETRN ADDRSS FRM BAL INSTRCTNS.\nR12      EQU   12                     PGM BASE REGISTER\nR13      EQU   13                     POINTER TO THIS PGMS'S SAVE AREA\nR14      EQU   14\nR15      EQU   15\n*\n         PRINT ON\n         STM   14,12,12(13)\n         LR    12,15                  SET UP BASE REG.\n         USING DARGETDD,12            ESTABLISH ADDRSIBLITY.\n         ST    13,SAVE+4              SAVE SAVEAREA POINTER.\n         LR    11,13                  SAVE REG 13 FOR STORE.\n         LA    13,SAVE                GET THIS CSECT'S SAVEAREA ADDR.\n         ST    13,8(11)               STORE NEW SAVEAREA ADDR.\n         BAL   R11,GETDDNME           R1 = FRST DD TABL ENTRY.\n         BAL   R11,VALDDNME           VALIDATE DDNAMES EXTRACTED.\n*        BAL   R11,WTOCONT1           FOR TESTING. WTO THE CNT OF DD'S\n         L     R13,SAVE+4             RESTOR CALLR'S SAVE ADDR.\n         RETURN (14,12)               RETURN TO CALLER.\n*\nGETDDNME DS    0H\n*\n* R1           EQUALS  1              POINTS TO DDNAME TBL PRFIX.\n* R3           EQUALS  3              POINTS TO A DD NAME TBL ENTRY.\n* R4           EQUALS  4              LOOP COUNTER TO STEP THRU TIOT\n* R5           EQUALS  5              BASE REG FOR TIOT DSECT.\n* R6           EQUALS  6              CONTAIN # OF DD'S EXTRACTED\n* R11          EQUALS 11              CALLING MODULS RETURN ADDRESS\n* R12          EQUALS 12              PGM BASE REGISTER\n*\nTIOTDD   DSECT\nTIOTLNGH DS    1X,3X\nTIOEDDNM DS    CL8\nDARGETDD CSECT\n*\n         LA    R4,1635                SET R4 TO # OF LOOPS TO EXECUTE.\n         XR    R6,R6                  SET R6 TO ZERO\n         LR    R2,R1                  SAVE R1 CONTENTS FOR BACKUP.\n         LA    R3,16(0,R1)            POINT TO FIRST DDNAME TBL ENTRY.\n         EXTRACT TIOTPTR,'S',FIELDS=(TIOT) GET PTR TO TIOT (USES R1).\n         LR    R1,R2                  RESTORE R1.\n         L     R5,TIOTPTR             GET ADDRESS OF TIOT\n         LA    R5,24(0,R5)            POINT TO 1ST TIOT DD ENTRY.\n         USING TIOTDD,R5              ESTBLISH DSECT ADDRSIBLTY\nTESTIOT  DS    0H\n         CLI   TIOTLNGH,X'00'         IF END OF TIOT\n         BE    TIOTEND                THEN EXIT LOOP\n         CLC   TIOEDDNM(6),=C'DARDMP' ELSE TEST FOR DDNAME PREFIX.\n         BNE   GETNXTDD               IF NOT EQUAL THEN SKIP AROUND.\n         MVC   0(8,R3),TIOEDDNM       ELSE XTRACT DDNAME FROM TIOT,\n         LA    R3,8(0,R3)                  ADJST PTR TO NXT TBL ENTRY,\n         LA    R6,1(0,R6)                  INCRMNT NUM OF DD'S XTRCTD,\nGETNXTDD LA    R5,20(0,R5)            ADJST DSECT PTR TO NXT ENTRY.\n         BCT   R4,TESTIOT             REPEAT CYCLE\n         DROP  R5\nTIOTEND  LTR   R6,R6                  IF # OF DD'S XTRACTED IS ZERO\n         BZ    TIOERROR               THEN THERE IS AN ERROR\n         ST    R6,0(0,R1)             STOR NUM OF DD'S XTRCTD,\n         BR    R11                    AND  RETURN TO CALLING MODULE.\nTIOERROR WTO   'IBJDARTH NO ''//DARDMP__'' DD''S FOUND, ABENDING'\n         ABEND 004,DUMP,,USER\nTIOTPTR  DC    F'0'\n         EJECT\nVALDDNME DS    0H\n*\n*        THIS  CODE CHECKS FOR DUPLICATION OF DDNAMES\n*\n*    DDNAME ENTRIES IN THE DDNAME TABEL  ARE COMPARED AGAINST EACH\n*    OTHER FOR DUPLICATION.   ASSUME THAT  THE FOLLOWING 4 DDNAMES\n*    EXIST IN THE TABLE: A, B, C AND D. THE COMPARSION PROCEDES AS\n*    FOLLOWS; A IS COMPARED AGAINST B, THEN C AND FINALLY D.  B IS\n*    THEN COMPARED AGAINST C, THEN D.   C  IS  COMPARED AGAINST D.\n*    THE FIRST DUPLICATION CAUSES THE PROGRAM TO ABEND WITH A USER\n*    008.\n*\n*\n*  R1          EQUALS  1              POINTS TO DDNME TBLE PRFEX.\n*  R2          EQUALS  2              LIMIT CTL VARIABL FOR OUTR LOOP\n*  R3          EQUALS  3              LIMIT CTL VARIABL FOR INNR LOOP.\n*  R4          EQUALS  4              POINTS TO DDNAME ENTRY TBL(I).\n*  R5          EQUALS  5              POINTS TO DDNAME ENTRY TBL(I+8).\n*  R6          EQUALS  6              CONTAIN # OF DD'S EXTRACTED.\n*  R7          EQUALS  7              2ND BASE REGISTER.\n*  R11         EQUALS 11              RETURN ADDRESS.\n*  R12         EQUALS 12              PGM BASE REGISTER.\n*\n*\n*\n         LA    R1,16(0,R1)            POINT FORWD TO FRST DDNAME,\n         C     R6,=F'1'               IF ONLY 1 DDNAME IN TABLE,\n         BE    VALDLNGH               THEN GO TO NXT VALIDATN ROUTN.\n         C     R6,=F'99'              IF OVER 99 DD'S IN TABLE,\n         BH    VALMAXER               THEN GO TO MAX ERR ROUTINE\n         LR    R2,R6                  ELSE GET WRK COPY OF # OF DD'S\n         BCTR  R2,0                   FOR OUTR LOOP AND REDUCES BY 1.\n         LR    R3,R2                  GET INNER LOOP COUNTER.\n         LR    R4,R1                  GET PTR TO DDNME TBL ENTRY.\n         LR    R5,R1                  GET PTR TO DDNME TBL AND ADJST\n         LA    R5,8(0,R5)             TO NXT ENTRY.\nVALOOP1  EQU   *\n         CLC   0(8,R4),0(R5)          IF DD NAMES ARE EQUAL\n         BE    VALDUPER               THEN DUPLICATION ERROR EXIST.\n         LA    R5,8(0,R5)             ELSE POINT TO NXT DD ENTRY.\n         BCT   R3,VALOOP1             REDUCE INNR LOOP CONT AND RETEST\n         LR    R3,R2                  WHEN DONE, RESET INNR LOOP COUNT\n         LA    R4,8(0,R4)             ADJST OUTR LOOP DD ENTRY PTR.\n         LR    R5,R4                  RESET INNR LOOP DD ENTRY PTR.\n         LA    R5,8(0,R5)             ADJST INNR DD PTR TO NXT ENTRY.\n         BCT   R2,VALOOP1             REDUCE OUTR LOOP CONT & REPEAT\n         B     VALDLNGH               WHEN DONE, GO TO NXT VALDATN RTN\nVALDUPER DS    0H\n         MVC   VALEMSG8+(L'VALEMSG8-1+11)(8),0(R5) MV IN BAD DD TO MSG.\n         WTO   MF=(E,VALEMSG8)\n         ABEND 008,DUMP,,USER\nVALEMSG8 WTO   'IJBDARTH ''DDDDDDDD'' IS A DUPLICATE DD, ABENDING',ROUTX\n               CDE=2,MF=L\n*\nVALMAXER DS    0H\n         WTO   'IJBDARTH OVER 99 DUMP DATA SETS PRESENT, ABENDING',ROUTX\n               CDE=2\n         ABEND 016,DUMP,,USER\n         EJECT\n*\n*\n*        THIS  CODE CHECKS FOR 8 CHARACTER DDNAMES AND ABENDS WITH A\n*        USER  012 ABEND CODE WHEN THE FIRST NON 8 CHAR DD IS FOUND.\n*\n*\n*\n*  R1          EQUALS  1              BASE POINTR TO TBL OF DDNAMES.\n*  R2          EQUALS  2              POINTS TO 7TH BYTE OF DDNAME.\n*  R3          EQUALS  3              CAN POINT TO BYT 7 OR 8 OF DDNME\n*  R4          EQUALS  4              CONTAINS LIMIT OF INNR LOOP.\n*  R5          EQUALS  5              CONATINS LIMIT OF OUTR LOOP.\n*  R6          EQUALS  6              CONTAIN # OF DD'S EXTRACTED.\n*  R7          EQUALS  7              2ND BASE REGISTER.\n*  R11         EQUALS 11              RETURN ADDRESS.\n*  R12         EQUALS 12              PGM BASE REGISTER.\n*\n*\n*\nVALDLNGH DS    0H\n         LR    R2,R1                  GET POINTER TO DD NAME TABLE\n         LA    R2,6(0,R2)             THEN POINT TO THE 7TH BYTE.\n         LR    R3,R2                  GET A COPY OF THIS ADDR.\n         LA    R4,2(0,0)              SET INNER LOOP CTL VARIBLE LMIT.\n         LR    R5,R6                  SET OUTER LOOP CTL VARIBLE LMIT.\nVALOOP2  DS    0H\n         CLC   0(1,R3),=X'40'         IF BYTE 7 OR 8 BLANK,\n         BE    VALNGHER               THEN THER IS AN ERR, EXIT.\n         LA    R3,1(0,R3)             ELSE POINT TO NEXT BYTE.\n         BCT   R4,VALOOP2             DECRMNT CONTR AND TEST NXT BYT\n         LA    R2,8(0,R2)             POINT TO BYTE 7 OF NXT DDNAME.\n         LR    R3,R2                  GET A COPY OF THIS ADDR.\n         LA    R4,2(0,0)              RESET INNER LOOP LIMIT.\n         BCT   R5,VALOOP2             DECRMNT OUTR LOOP VARIABLE.\n         S     R1,=F'8'               POINT BCK TO DDNAME TBL PREFIX.\n         ST    R6,0(R1)               SAVE # OF DDNAMES EXTRACTED.\n         BR    11                     RETURN.\nVALNGHER DS    0H\n         S     R2,=F'6'               SET PTR TO STRT OF DD IN ERROR.\n         MVC   VALEMSGC+(L'VALEMSGC-1+11)(8),0(R2) MV DDNAME TO MGS.\n         WTO   MF=(E,VALEMSGC)\n         ABEND 012,DUMP,,USER         ABEND.\n*               1234567890 1\nVALEMSGC WTO   'IJBDARTH ''D       '' DD IS NOT 8 CHARACTERS LONG, ABENX\n               DING',ROUTCDE=2,MF=L\n         EJECT\nWTOCONT1 DS    0H\n*\n*        THE FOLLOWING INSTRUCTIONS ARE USED FOR TEST PURPOSES TO\n*        DISPLAY HOW MANY DD'S  WERE EXTRACTED. PGM CONTROL IS DIRECTD\n*        HERE THROUGH A BAL INSTRUCTION WHICH IS NOW COMMENTED OUT.\n*        R11 CONTAINS THE RETURN ADDRESS.\n*\n         CVD   R6,PACKED\n         UNPK  UNPACKED,PACKED+5(L'UNPACKED)\n         OI    UNPACKED+(L'UNPACKED-1),X'F0'\n         MVC   WTOLIST1+(L'WTOLIST1-1+10)(L'UNPACKED),UNPACKED\n         WTO   MF=(E,WTOLIST1)\n         BR    R11                    RETURN TO CALLER.\nWTOLIST1 WTO   'IJBDARTH NNN DD''S EXTRACTED',MF=L (L' OF WTOLIST1=4)\nPACKED   DC    D'0'\nUNPACKED DC    CL3'999'\n*\nSAVE     DC    18F'0'\n*\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IEFUTL": {"ttr": 1284, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87(\\x7f\\x00\\x87(\\x7f\\x12\\x00\\x01\\xf1\\x01\\xf1\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-10-14T00:00:00", "modifydate": "1987-10-14T12:00:00", "lines": 497, "newlines": 497, "modlines": 0, "user": "FILE325"}, "text": "*\n*        This version queries an installation defined field in the ACF2\n*        logonid record to find the wait time for each user: TSOIDLE\n*\n*        It also resolves two logic problems encountered previously:\n*        1) The LU name was taken from the ACF2 in-storage record.\n*           Now the LU name is taken from the Terminal Status Block.\n*           ACF2 does not update the in-storage record during reconnect\n*           so some users were avoiding the disconnect by intentionally\n*           disconnecting and reconnecting from a different LU. Whoever\n*           happened to be on the original LU got disconnected when the\n*           wise-guy timed out.\n*        2) This code now calculates continuous elapsed time instead of\n*           only elapsed time occurances. Because SMF does not drive\n*           the exit when a wait time period ends before the time limit\n*           (user enters something), we were carrying the cumulative\n*           total instead of the current total. Now, if time of current\n*           entry minus time of last entry is greater than time limit\n*           (wait was not continuous), we reset the internal counter.\n*\nIEFUTL   TITLE 'WELLS FARGO BANK SMF TIME LIMIT EXIT'\n***********************************************************************\n         PRINT NOGEN                                                  *\n*             MODULE NAME:  IEFUTL                                    *\n*                                                                     *\n*             DESCRIPTIVE NAME:  WELLS FARGO BANK SMF TIME LIMIT EXIT *\n*                                                                     *\n*             STATUS:  MVS RELEASE XA2.1.5                            *\n*                                                                     *\n*             FUNCTION:                                               *\n*                                                                     *\n*              . VALIDATE ACF2 AUTHORIZATION (VIA LOGON RECORD)       *\n*                TO DIFFERENTIATE NORMAL TEST JOBS & USERS            *\n*                FROM 'PRIVILEGED' (I.E. SUBMITTOR HAS OPER AUTH.     *\n*                (TP01 LEVEL MODIFICATION)                            *\n*              . ALLOW TEST (Z) JOBS TO BE CANCELLED IF THE CPU       *\n*                TIME LIMIT IS EXCEEDED (UNLESS PRIVILEGED USER).     *\n*              . ALLOW TSO SESSIONS TO BE EXTENDED INDEFINETELY       *\n*                IF THE CPU TIME LIMIT IS EXCEEDED.                   *\n*              . ALLOW PRODUCTION & PRIVILEGED JOBS TO BE EXTENDED    *\n*                5 MINUTES 6 TIMES IF THE CPU TIME LIMIT              *\n*                IS EXCEEDED (I.E. 30  MINUTES)                       *\n*              . ALLOW TSO SESSIONS TO BE CANCELLED IF THE WAIT       *\n*                TIME LIMIT IS EXCEEDED. TOTAL AMOUNT OF WAIT TIME    *\n*                TAKEN FROM ACF2 RECORD (CN02 LEVEL MODIFICATION)     *\n*              . ALLOW TEST (Z) JOBS TO BE CANCELLED IF THE WAIT      *\n*                TIME LIMIT IS EXCEEDED (UNLESS PRIVILEGED USER).     *\n*              . ALLOW PRODUCTION & PRIEVLEDGED JOBS TO BE EXTENDED   *\n*                5 MINUTES UP TO 6 TIMES IF THE WAIT TIME LIMIT       *\n*                IS EXCEEDED (I.E. 3.5 HOURS).                        *\n*                                                                     *\n*             OPERATION:                                              *\n*              . ANALYZE SMF COMMON EXIT PARAMETER AREA.              *\n*              . CANCEL JOB IF WFB SMF PARAMETER LIST IS MISSING.     *\n*              . IF CPU TIME IS EXPIRED:                              *\n*                   EXTEND TIME BY 5 MINUTES IF TSO SESSION.          *\n*                   CANCEL JOB IMMEDIATELY IF Z JOB (NON-PRIVILEGED)  *\n*                   EXTEND TIME BY 5 MINUTES UP TO 6 TIMES FOR A      *\n*                      PRODUCTION OR PRIVILEGED Z JOB.                *\n*              . IF WAIT TIME IS EXPIRED:                             *\n*                   CONDITIONALLY TERMINATE SESSION IF NON-PRIVILEGED *\n*                   (I.E. NO OPER AUTHORITY) USER.                    *\n*                   EXTEND TIME BY SMF JWT UP TO ACF2 SPECIFIED       *\n*                   TIME, CONDITIONALLY TERMINATE IF WAIT PERSISTS.   *\n*                ** CONDITIONAL TERMINATION ALLOWS LOGON RECONNECT    *\n*                   CANCEL IF TEST (Z) JOB SUBMITTED BY NON-PRIVILEGED*\n*                   USER.                                             *\n*                   EXTEND TIME BY 30 MINUTES UP TO 6 TIMES IF A      *\n*                      PRODUCTION OR PRIVILEGED JOB.                  *\n*              . NUMBER OF TIMES IEFUTL IS ENTERED FOR WAIT AND CPU   *\n*                TIME IS LOGGED IN THE WFB SMF PARAMETER LIST. IT     *\n*                IS POINTED TO BY SMFUSER IN THE COMMON SMF PARAMETER *\n*                LIST (THE JMR - JOB MANAGEMENT RECORD).              *\n*                                                                     *\n*             DEPENDENCIES:  CHARACTER SET IS EBCDIC.  REASSEMBLE     *\n*                IF A DIFFERENT CHARACTER SET IS NEEDED.              *\n*                                                                     *\n*             RESTRICTIONS:  NONE                                     *\n*                                                                     *\n*             REGISTER CONVENTIONS:  STANDARD CONVENTIONS.            *\n*                   R0  - PARM/WORK REGISTER                          *\n*                   R1  - PARM/WORK REGISTER                          *\n*                   R2  - IEFUTL ENTRY TYPE INDICATOR                 *\n*                       - TEMP RETURN CODE REGISTER                   *\n*                   R3  - TEMP TIME EXTENSION IN SECONDS              *\n*                   R4  - ACF2 ACCVT & SVC34 AREA                     *\n*                   R5  - ACF2 ACUCB & LIDREC, & AUTHORIZATION CODE   *\n*                   R6  - R7  WORK REGS                               *\n*                   R8  - POINTER TO SVC34 MESSAGE AREA               *\n*                   R9  - POINTER TO WFB SMFLIST                      *\n*                   R10 - POINTER TO GETMAINED WTO AREA               *\n*                   R11 - POINTER TO COMMON EXIT PARAMETER AREA       *\n*                   R12 - BASE REGISTER                               *\n*                   R13 - UNUSED (REMAINS CALLERS SAVE AREA PTR)      *\n*                   R14 - RETURN REGISTER                             *\n*                   R15 - RETURN CODE REGISTER                        *\n*                                                                     *\n*             PATCH LABEL: NO PATCH AREA PROVIDED                     *\n*                                                                     *\n*             MODULE TYPE:  PROCEDURE                                 *\n*                                                                     *\n*                PROCESSOR:  ASM                                      *\n*                                                                     *\n*                MODULE SIZE:  600 BYTES                              *\n*                                                                     *\n*                ATTRIBUTES:  SCHEDULER KEY 0, REENTRANT,             *\n*                   SUPERVISOR STATE, ENABLED                         *\n*                                                                     *\n*             ENTRY POINTS:  IEFUTL (ONLY ENTRY POINT)                *\n*                                                                     *\n*             LINKAGE:  FROM INITIATOR VIA MODULE IEATLEXT            *\n*                                                                     *\n*             INPUT:  REGISTER 0 HAS REASON FOR ENTRY CODE            *\n*                       0 - JOB CPU TIME EXCEEDED                     *\n*                       4 - STEP CPU TIME EXCEEDED                    *\n*                       8 - JOB WAIT TIME EXCEEDED                    *\n*                     REGISTER 1 POINTS TO A LIST OF FULL WORDS       *\n*                     THE FIRST OF WHICH POINTS TO THE SMF COMMON     *\n*                     EXIT PARAMETER AREA MAPPED BY SMFCEPA DSECT     *\n*                                                                     *\n*             EXIT - NORMAL:  AT PROGRAM END VIA BRANCH REGISTER 14   *\n*                                                                     *\n*             OUTPUT: REGISTER 1 TIME LIMIT EXTENSION IN SECS (IF ANY)*\n*                     REGISTER 15 HAS EXIT CODE                       *\n*                       0 - CANCEL JOB                                *\n*                       8 - EXTEND TIME BY VALUE IN REGISTER 1        *\n*                     WFB SMFLIST HAS UPDATED EXTENTION COUNT         *\n*                                                                     *\n*             EXIT - ERROR:  NONE                                     *\n*                                                                     *\n*             EXTERNAL REFERENCES:  NONE                              *\n*                                                                     *\n*             CONTROL BLOCKS: NONE                                    *\n*                                                                     *\n*             TABLES:  NONE                                           *\n*                                                                     *\n*             MACROS & SVC'S: SAVE, GETMAIN, FREEMAIN, TPUT, WTO      *\n*                                                                     *\n*             CHANGE ACTIVITY:                                        *\n*             12/01/86 NIELSEN  OBTAIN LU FROM TSB AND TIME LIMIT FROM*\n*                               ACF2 RECORD                    (CN01) *\n*             02/11/87 NIELSEN  ADD TIME STAMP TO DISCONNECT MSG(CN02)*\n*                                                                     *\n*             MESSAGES: SEE CONSTANTS AREA                            *\n*                                                                     *\n*             ABEND CODES:  NONE                                      *\n*                                                                     *\n***********************************************************************\n         EJECT\n*\n*   E  Q  U  A  T  E  S\n*\nD0       EQU   0              USED FOR OFFSET OF ZERO\nD12      EQU   12             USED FOR OFFSET OF TWELVE\nD28      EQU   28             USED FOR OFFSET OF TWENTY EIGHT\nWTOSVC   EQU   35             WRITE TO OPERATOR SVC\nWTOAREAL EQU   144            LENGTH OF GETMAIN FOR WTO WORK AREA\n*\n*  R  E  G  I  S  T  E  R     E  Q  U  A  T  E  S\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\nIEFUTL   CSECT\n         SAVE  (14,12),,IEFUTL.MVS.&SYSTIME_&SYSDATE SAVE REGISTERS\n         LR    R12,R15                 LOAD REGISTER 12 FROM 15\n         USING IEFUTL,R12              ESTABLISH ADDRESSABILITY\n         LR    R2,R0                   SAVE ENTRY TYPE INDICATOR\n         L     R11,D0(R1)              LOAD POINTER TO PARAMETER AREA\n         USING SMFEPLA,R11             ESTABLISH ADDRESSABILITY TO SMF\n*                                      PARAMETER AREA DSECT\n*\n*  GET AREA FOR MESSAGES FOR REENTRANTABILITY\n*\n         GETMAIN R,LV=WTOAREAL,SP=241  GET STORAGE FOR WTO WORK AREA\n         LR    R10,R1                  SAVE ADDRESS OF WTO WORK AREA\n         GETMAIN R,LV=SVC34GM,SP=241   GET SVC34 BUFFER AREA      TP01\n         LR    R8,R1                   USE R8 FOR SVC34 WORKAREA  TP01\n         USING SVC34,R8                MAP SVC34 PARM AREA      TP01\n         XC    SVC34L(4),SVC34L        CLEAR LENGTH AREA        CN02\n         LA    R1,SVC34GM              SET UP SVC34 PARM LIST     TP01\n         STH   R1,SVC34L               PLUG IN MESSAGE LENGTH     TP01\n         MVC   SVC34M,TERMMSG          COPY VTAM TERM MSG TO LIST TP01\n*\n*  INSURE WFB SMFLIST IS PRESENT\n*\n         L     R9,SMFUSER              GET WFB SMFLIST ADDR\n         LA    R9,0(R9)                CLEAR HIGH ORDER BYTE\n         LTR   R9,R9                   IS THERE AN ADDR?\n         BP    WFBSMFOK                YES - CONTINUE\n         USING SMFLIST,R9              ADDR WFB SMFLIST\n         MVC   0(ERRMSGL,R10),ERRMSG   MOVE ERROR MESSAGE TO WORK AREA\n         LR    R1,R10                  POINT TO MESSAGE\n         SVC   WTOSVC                  LET THE OPERATOR KNOW\n         B     CANCEL                  DO NOT CONTINUE\n         EJECT\nWFBSMFOK DS    0H\n         TIME  STCK,SMFWORKD           GET TOD CLOCK READING      CN02\n         L     R6,SMFWORKD             LOAD INTO WORK REG         CN02\n         SLL   R6,1                    STRIP SIGN                 CN02\n         SRL   R6,1                    REALIGN STAMP              CN02\n         L     R3,16                   POINT TO CVT               CN02\n         L     R7,196(R3)              POINT TO SMCA              CN02\n         L     R3,8(R7)                LOAD JWT FROM SMF BLOCK    CN02\n         ST    R3,SMFWTIME             SAVE IN WORK AREA          CN02\n         SPACE 2\n*--------------------------------------------------------------------*\n*        VALIDATE SUBMITTORS ACF2 AUTHORITY.  OBTAIN LOGON ID RECORD *\n*              VIA ACF2 CONTROL BLOCK CHASE AND SET REGISTER 5 TO    *\n*              1 IF SUBMITTOR HAS OPER  AUTHORITY, 0 IF NOT.         *\n*                                                                    *\n*--------------------------------------------------------------------*\n         USING ACCVT,R4                REQUIRED FOR CB CHASE    TP01\n         LA    R5,1                    SET AUTH IN CASE NO ACF2 TP01\n         ACFGACVT R4,                  GET ACCVT ADDR IN R4     TP01   X\n               NONE=NOTAUTH             ACF2 ISN'T UP...        TP01\n         XR    R5,R5                   RESET TO NOT AUTH IF ACF2TP01\n         ACFGUCB R4,                   GET ACF2 UCB ADDR IN R4  TP01   X\n               NONE=NOTAUTH,           DEFAULT TO NO OPER       TP01   X\n               INLINE=YES,             NO EXTERNAL CALL         TP01   X\n               SYS=AOS2                GENERATE MVS CODE ONLY   TP01\n         DROP  R4                                               TP01\n         USING ACUCB,R4                MAP THE ACF2 UCB         TP01\n         L     R3,X'224'               POINT TO ASCB            CN02\n         L     R7,X'3C'(R3)            POINT TO TSB             CN02\n         USING TSB,R7                  ESTABLISH ADDRESSABILITY CN02\n         MVC   SVC34LU,TSBTRMID        VTAM LU NAME INTO SVC34  CN02\n         DROP  R7                                               CN02\n         L     R4,ACULRECP             POINT TO LOGON ID RECORD TP01\n         DROP  R4                                               TP01\n         USING LIDREC,R4               MAP THE LOGON ID RECORD  TP01\n         MVC   SMFWORKH(1),LIDTSIDL    HOLD WAIT TIME ALLOWANCE CN02\n         TM    LIDTFLG3,LIDT3OPR       SUBMITTOR HAVE ACF OPER ?TP01\n         BNO   NOTAUTH                   NOPE                   TP01\n         LA    R5,1                      ELSE SET AUTHORIZED FLGTP01\n         DROP  R4\nNOTAUTH  DS    0H\n         SPACE 2\n*\n*  EVALUATE REGISTER 0 = 0 - JOB CPU TIME EXCEEDED\n*                      = 4 - STEP CPU TIME EXCEEDED\n*                      = 8 - JOB WAIT TIME EXCEEDED\n*\n         C     R2,FULL4                SEE IF JOB/STEP TIME EXCEEDED\n         BH    WAITTIME                NO.....GO DO ANALYSIS FOR WAIT\n         EJECT\n*\n*  PROCESS CPU TIME LIMIT EXCEEDED\n*\n         MVC   0(TIMEMSGL,R10),TIMEMSG MOVE MESSAGE LIST TO WORK AREA\n         TM    SMFOPT,SMFTSO           SEE IF TSO SESSION\n         BNO   PCPU                    NO.....MUST BE BACKGROUND JOB\n         LTR   R5,R5                   AUTHORIZED USER ?          TP01\n         BNZ   CPUEXTND                 YES, EXTEND W/O TPUT      TP01\n         TPUT  TSOMSG1,L'TSOMSG1       PUT OUT MESSAGE TO USER    TP01\n         B     CPUEXTND                 SKIP THE WTO              TP01\nPCPU     DS    0H\n         MVC   TIMENAME(8,R10),SMFJOBN MOVE JOBNAME TO MESSAGE\n         MVC   TIMETYPE(4,R10),=C' CPU' INDICATE CPU TIME EXCEEDED\n         LR    R1,R10                  POINT TO MESSAGE\n         SVC   WTOSVC                  LET THE OPERATOR KNOW\n         CLI   SMFJOBN,C'Z'   IS THIS A TEST JOB?\n         BNE   NOCANCEL                NO, DON'T CANCEL IT.       TP01\n         LTR   R5,R5                   AUTHORIZED USER (R5 =1 )?  TP01\n         BZ    CANCEL                   NOT AUTH, SO CANCEL JOB   TP01\nNOCANCEL DS    0H                                                 TP01\n         SLR   R1,R1          CLEAR WORK REGISTER\n         IC    R1,SMFCPUE     GET CURRENT NUMBER OF CPU EXTENSIONS.\n         LA    R1,1(R1)       UPDATE NUMBER OF CPU TIME EXTENSIONS.\n         STC   R1,SMFCPUE     SAVE IN WFB SMF PARMLIST.\n         C     R1,SIX         HAVE WE EXTENDED THIS JOB 6 TIMES?\n         BH    CANCEL         YES - GO CANCEL IT.\nCPUEXTND DS    0H\n         LA    R2,8           SET RETURN CODE TO 8.\n         LA    R3,60*5        EXTEND CPU TIME FOR 5 MINUTES\n         B     RETURN         GO RETURN TO CALLER\n         EJECT\n*\n*  PROCESS WAIT TIME LIMIT EXCEEDED\n*\nWAITTIME DS    0H\n         SLR   R3,R3          CLEAR THE TIME EXTENSION REGISTER\n         MVC   0(TIMEMSGL,R10),TIMEMSG MOVE MESSAGE TO WORK AREA\n         TM    SMFOPT,SMFTSO  IS THIS A TIME SHARING USER\n         BNO   PWAIT          NO - GO PROCESS BACKGROUND JOBS\n         CLC   SMFLSTMP(4),F0 PREVIOUS TIME STAMP IN RECORD?      CN02\n         BE    WCLEAR         NO, FIRST TIME OUT                  CN02\n         L     R3,SMFWTIME    GET SMF JWT                         CN02\n         LA    R3,240(R3)     BUMP BY 4 MINUTES FOR COMPARE       CN02\n         SR    R3,R6          SUBTRACT TIME STAMP                 CN02\n         A     R3,SMFLSTMP    ADD PREVIOUS TIME STAMP             CN02\n         BP    TSMOVE         YES, CONTINUOUS TIMEOUT             CN02\nWCLEAR   MVI   SMFWAITE,X'00' NO, NEW TIMEOUT, CLR XTNSION COUNT  CN02\nTSMOVE   EQU    *                                                 CN02\n         ST    R6,SMFLSTMP    STORE CURRENT TIME STAMP            CN02\n         XR    R3,R3          CLEAR WORK REG                      CN02\n         L     R6,SMFWTIME    MULTIPLY BY SMF TIME LIMIT          CN02\n         SRDA  R6,32          SHIFT FOR MULTIPLY                  CN02\n**********************************************************************\n*  THE SMF WAIT TIME VALUE IS STORED IN UNITS OF 2**20 MICROSECONDS  *\n*  OR 1.048576 SECONDS. IN ORDER TO CONVERT THE VALUE TO SECONDS FOR *\n*  TIME LIMIT COMPARISONS AND WAIT TIME EXTENSIONS THE SMF VALUE IS  *\n*  MULTIPLIED BY 1.05. FOR EXAMPLE 15 MINUTES (900 SECONDS) WOULD BE *\n*  STORED AS 858 IN THE SMF JWT FIELD. MULTIPLYING 858 BY 1.05       *\n*  CONVERTS THIS VALUE BACK TO AN AMOUNT CLOSELY AND USUALLY EXACTLY *\n*  MATCHING THE NUMBER OF SECONDS (IN THIS CASE 900).                *\n**********************************************************************\n         M     R6,F105        MULTIPLY BY 105                     CN02\n         D     R6,F100        DIVIDE BY 100 TO CONVERT TO SECONDS CN02\n         ST    R7,SMFWTIME    STORE VALUE FOR NEXT INCREMENT IF NEEDED\n         IC    R3,SMFWAITE    INSERT EXTENSION COUNTER            CN02\n         LA    R3,1(R3)       ADD 1 FOR CALCULATIONS              CN02\n         STC   R3,SMFWAITE    STORE INCREMENTED COUNTER           CN02\n         MR    R6,R3          CALCULATE ELAPSED TIME              CN02\n         ST    R7,SMFELAP     STORE TOTAL                         CN02\n         XR    R6,R6          CLEAR WORK REG                      CN02\n         CLI   SMFWORKH,X'5A' GREATER THAN 90 MINUTE JWT          CN02\n         BNH   ICREG          NO, DO REGULAR INSERT CHAR          CN02\n         LA    R6,90          YES, LIMIT JWT TO 90 MINUTES        CN02\n         B     SHIFT          BRANCH AROUND IC                    CN02\nICREG    IC    R6,SMFWORKH    INSERT ACF WAIT TIME INTO REG       CN02\nSHIFT    SRDA  R6,32          SHIFT FOR MULTIPLY                  CN02\n         M     R6,F60         CONVERT TO SECONDS                  CN02\n         C     R7,SMFELAP     ACF VALUE > ELAPSED TIME            CN02\n         BH    WTEXTND        YES, GRANT EXTENSION                CN02\n         MVC   0(65,R10),TSOMSG3    MOVE TPUT MSG TO WORK AREA    CN02\n         TIME  DEC                                                CN02\n         SRL   R0,4           SHIFT OFF HUNDRETHS DIGIT           CN02\n         ST    R0,SMFWORKD    STORE TIME                          CN02\n         OI    SMFWORKD+3,X'0F' REPLACE TENTHS DIGIT WITH SIGN    CN02\n*                               THUS CREATING PACKE FORMAT        CN02\n         MVC   55(10,R10),TMSK      MOVE EDIT MASK TO TPUT AREA   CN02\n         ED    55(10,R10),SMFWORKD      EDIT TIME INTO TPUT AREA  CN02\n         TPUT  (R10),L'TSOMSG3 TELL USER WHAT'S HAPPENING         CN02\n         B     CANCEL         NO, CANCEL                          CN02\nPWAIT    DS    0H\n         CLI   SMFJOBN,C'Z'            IS THIS A TEST JOB ?      TP01\n         BNE   JOBWAIT                 NO, DON'T CANCEL          TP01\n         LTR   R5,R5                   AUTHORIZED SUBMITTOR ?    TP01\n         BZ    CANCEL                    NOT A CHANCE, WASTE IT. TP01\n*        B     JOBWAIT                 PRIVILEDED BATCH JOB      TP01\nJOBWAIT  DS    0H\n         SLR   R1,R1          CLEAR WORK REGISTER\n         IC    R1,SMFWAITE    GET SMFWAITE COUNT\n         LA    R1,1(R1)       UP COUNT BY 1\n         STC   R1,SMFWAITE    SAVE IN WFB'S SMF RECORD\n         C     R1,SIX         HAVE WE EXTENDED THIS JOB 6 TIMES?\n         BH    CANCEL         YES - GO CANCEL IT.\nWTEXTND  DS    0H\n         LA    R2,8           SET THE RETURN CODE TO 8 (EXTEND JOB)\n         L     R3,SMFWTIME    EXTEND WAIT TIME BY 1 INCREMENT     CN02\n         B     RETURN         AND RETURN TO CALLER\n         EJECT\n*\n*  PROCESSING FOR JOB CANCELLATION\n*\nCANCEL   DS    0H\n         TM    SMFOPT,SMFTSO  IS THIS A TIME SHARING USER\n         BNO   NOTTSU         NO - CONTINUE\n         MVC   0(DISCMSGL,R10),DISCMSG     COPY DISCONNECT MSG    TP01\n         MVC   DISCNAME(8,R10),SMFJOBN     PLUG IN USERID         TP01\n         LR    R1,R10                      POINT TO MSG.          TP01\n         SVC   WTOSVC                      ISSUE SVC              TP01\n         LTR   R9,R9                   IS SMFLIST PRESENT ?       TP01\n         BNP   NOTTSU                  NO, ALLOW CANCEL TO STAND  TP01\n         XR    R0,R0                   CLEAR R0 (SET CONSOLE ID)  TP01\n         LR    R1,R8                   POINT TO SVC34 PARM LIST   TP01\n         SVC   34\n         LA    R2,8                    SET EXTEND RETURN CODE     TP01\n         L     R3,SMFWTIME              & EXTEND FOR JWT          CN02\n         LA    R3,60(R3)                + 1 MINUTE                CN02\n         B     RETURN                   (I.E. RESET JWT FOR AFTER TP01\n*                                       LOGON REONNECT).          TP01\nNOTTSU   DS    0H\n         MVC   0(CANMSGL,R10),CANMSG  MOVE MESSAGE TO WORK AREA\n         MVC   CANNAME(8,R10),SMFJOBN INDICATE JOBNAME\n         LR    R1,R10         POINT TO MESSAGE\n         SVC   WTOSVC         TELL THE OPERATOR\n         SLR   R2,R2          0 INDICATES CANCEL JOB/TSU\n*\n*        NORMAL END PROCESSING\n*\nRETURN   DS    0H\n         FREEMAIN R,LV=WTOAREAL,A=(R10),SP=241\n         FREEMAIN R,LV=SVC34GM,A=(R8),SP=241\n         L     R14,D12(,R13)           LOAD ADDRESS FOR RETURN\n         LR    R15,R2                  SET THE RETURN CODE\n         LR    R1,R3                   SET THE EXTENSION (IF ANY)\n         LM    R2,R12,D28(R13)         RESTORE REGISTERS 2 TO 12\n         BR    R14                     RETURN TO CALLER\n         EJECT\n*\n*  C O N S T A N T S   A N D   M E S S A G E S\n*\nFULL4    DC    F'4'\nSIX      DC    F'6'\nF0       DC    F'0'\nF60      DC    F'60'\nF100     DC    F'100'\nF105     DC    F'105'\n         SPACE 2\nTMSK     DC    XL10'402120204B20204B2020'\nTSOMSG1  DC    C'IEFUTL - CPU TIME EXPIRED, TSO SESSION EXTENDED'\nTSOMSG2  DC    C'IEFUTL - WAIT TIME EXPIRED, TSO SESSION EXTENDED'\nTSOMSG3  DC    C'IEFUTL - WAIT TIME EXPIRED, TSO SESSION DISCONNECTED AX\n               T  HH.MM.SS'\nTERMMSG  DC    C'V NET,TERM,NOTIFY=NO,TYPE=COND,SLU=XXXXXXXX'\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*        ROUTCDE=2 WAS USED SO THAT ENQ RET=TEST WAS UNNECESSARY      *\n*        ENQ RET=TEST IS NECESSARY FOR ROUTCDE=11 (WTP) WHETHER       *\n*           OR NOT THAT ROUTING OCCURS BY DEFAULT                     *\n*        WTP CAUSES AN ENQ OF THE FOLLOWING FORM:                     *\n*           MAJORNAME: SYSSJWTP                                       *\n*           MINORNAME: RPL + ASID (LENGTH OF 6)                       *\n*              RPL IS THE 4 BYTE REQUEST PARAMETER LIST POINTER       *\n*                 LOCATED AT OFFSET JSCBSMLR (X'128') IN THE JSCB     *\n*              ASID IS THE 2 BYTE ADDRESS SPACE IDENTIFIER            *\n*                 LOCATED AT OFFSET ASCBASID (X'24') IN THE ASCB      *\n*                                                                     *\n***********************************************************************\n         SPACE\nERRMSG   WTO   'IEFUTL - WFB SMFLIST MISSING',ROUTCDE=(2,9),DESC=6,MF=L\nERRMSGL  EQU   *-ERRMSG\n         SPACE\nTIMEMSG  WTO   'IEFUTL - JOB JOBNAMEX WAIT TIME EXPIRED',              X\n               ROUTCDE=(2,9),DESC=(6),MF=L\nTIMEJOB  EQU   13              OFFSET TO JOB/TSU FIELD\nTIMENAME EQU   17              OFFSET TO JOBNAME FIELD\nTIMETYPE EQU   26              OFFSET TO WAIT/CPU FIELD\nTIMEMSGL EQU   *-TIMEMSG\n         SPACE\nCANMSG   WTO   'IEFUTL - JOB JOBNAMEX CANCELLED',                      X\n               ROUTCDE=(2,9),DESC=(6),MF=L\nCANJOB   EQU   13              OFFSET TO JOB/TSU FIELD\nCANNAME  EQU   17              OFFSET TO JOBNAME FIELD\nCANMSGL  EQU   *-CANMSG\n         SPACE\nDISCMSG  WTO   'IEFUTL - TSU JOBNAMEX DISCONNECTED AT HH.MM.SS',       X\n               ROUTCDE=(2,9),DESC=(6),MF=L\nDISCNAME EQU   17              OFFSET TO JOBNAME FIELD\nDISCMSGL EQU   *-DISCMSG\n         SPACE\n         LTORG\n         EJECT\n*\n*  D S E C T S   (M A P P I N G   M A C R O S)\n*\nSMFEPLA  DSECT\nSMFJOBN  DS    CL8\nSMFTIME  DS    CL4\nSMFDATE  DS    CL4\nSMFSID   DS    CL4\nSMFUSID  DS    CL8\nSMFSTEP  DS    CL1\nSMFOPT   DS    CL1\nSMFTSO   EQU   X'01'\nSMFVS1   DS    CL1\nSMFRESV  DS    CL1\nSMFUSER  DS    CL4\n         ORG   SMFUSER\nSMFUSERC DS    CL1\nSMFUSERW DS    CL1\n         ORG\n         SPACE 3\nSMFDSECT SMFLIST\n         SPACE 3\nSVC34    DSECT                         PARM LIST FOR SVC34\nSVC34L   DS    F                       LENGTH (INCLUDING LLBB)\nSVC34M   DS    C'V NET,TERM,NOTIFY=NO,TYPE=COND,SLU=XXXXXXXX'\n         ORG   *-8\nSVC34LU  DS    CL8                     TARGET LU NAME\nSVC34GM  EQU   *-SVC34\n         SPACE 3\n         ACCVT                         ACF2 CVT MAP\n         ACFASVT                       ACF2 SUBSYSTEM VECTOR TABLE\n         IHAPSA                        MVS: PREFIX AREA\n         IHAASCB                       MVS: ASCB\n         IKJTSB                        VTAM: TSB\n         ACUCB                         ACF2 USER CONTROL BLOCK\n         LIDREC                        ACF2 LOGON ID RECORD\n         END   IEFUTL\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INMXZ01": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87(\\x7f\\x00\\x87(\\x7f\\x12\\x00\\x01\\x01\\x01\\x01\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-10-14T00:00:00", "modifydate": "1987-10-14T12:00:00", "lines": 257, "newlines": 257, "modlines": 0, "user": "FILE325"}, "text": "***********************************************************************\n*                                                                     *\n*   MODULE NAME:  INMXZ01                                             *\n*                                                                     *\n*   DESCRIPTION:  WELLS FARGO BANK TSO/E TRANSMIT INITIALIZATION EXIT *\n*                                                                     *\n*        STATUS:  TSO/E XA RELEASE 2.1                                *\n*                                                                     *\n*      FUNCTION:  PREVENT TRANSMISSION TO NON-EXISTENT TSO USERIDS    *\n*                 ON SAME NODE AS SENDER (JES2 EXIT 13 HANDLES NJE)   *\n*                 AND THEREBY KEEP UNRECEIVABLE DATA OFF JES2 SPOOL.  *\n*                                                                     *\n*     OPERATION:  -  SEARCH ADDRESS LIST FOR LOCAL NODE.              *\n*                 -  IF FOUND, CALL ACF2 TO VERIFY EXISTENCE OF USER. *\n*                 -  IF NOT VALID, REMOVE USERID FROM ADDRESS LIST    *\n*                      AND ISSUE ERROR MESSAGE TO TRANSMITTING USER.  *\n*                 -  ALWAYS RETURN CONDITION ZERO (CONTINUE TRANSMIT).*\n*                                                                     *\n*  DEPENDENCIES:  MUST BE LINK-EDITED WITH INCLUDE FOR ACF$GCVT,      *\n*                 OR BE ALLOWED TO RESOLVE EXTERNAL REFERENCE TO      *\n*                 $ACFGCVT LOCATED IN SYS3.ACF2.V###.ACFMOD(ACF$GCVT).*\n*                                                                     *\n*                 REQUIRES PTF UZ39974 (OR EQUIVALENT) BE INSTALLED   *\n*                 FOR CORRECT FUNTIONING OF \"UNCHAINING\".             *\n*                                                                     *\n*     REGISTERS:  R0  -  PARM/WORK REGISTER                           *\n*                 R1  -  PARM/WORK REGISTER                           *\n*                 R2  -  WORK REGISTER (ALSO USED TO PASS RC TO R15)  *\n*                 R3  -  POINTER TO FROM-NODE NAME                    *\n*                 R4  -  MACHINE LENGTH OF FROM-NODE NAME             *\n*                 R5  -  POINTER TO CURRENT TO-USER DATA              *\n*                 R6  -  POINTER TO PREVIOUS TO-USER DATA             *\n*                 R10 -  TEMPORARY BASE FOR TSO CPPL                  *\n*                 R11 -  POINTER TO INPUT PARAMETER LIST              *\n*                 R12 -  BASE REGISTER                                *\n*                 R13 -  BASE REGISTER FOR WORKAREA                   *\n*                 R14 -  RETURN REGISTER                              *\n*                 R15 -  RETURN CODE REGISTER                         *\n*                                                                     *\n*    ATTRIBUTES:  KEY 8, PROBLEM STATE, APF ON, REENTRANT             *\n*                                                                     *\n*         INPUT:  R1, POINTER TO PARAMETER LIST, SEE PL@LIST          *\n*                                                                     *\n*        OUTPUT:  ADDRESS LIST RECHAINED TO REMOVE INVALID USERIDS    *\n*                                                                     *\n*          EXIT:  ALWAYS CONDITION CODE ZERO - CONTINUE TRANSMIT      *\n*                                                                     *\n* EX REFERENCES:  ACF$GCVT (AKA $ACFGCVT)                             *\n*                                                                     *\n*  CONTROL BLKS:  ACF CONTROL BLOCKS:  ACCVT AND ACALT                *\n*                                                                     *\n* MACROS & SVCS:  ACFREGS, ACFSVC, FREEMAIN, GETMAIN, IKJCPPL,        *\n*                 PUTLINE, RETURN, SAVE                               *\n*                                                                     *\n*   ABEND CODES:  NONE                                                *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n*    CHANGE LOG:  SAM LEPORE     JANUARY 1985                         *\n*                   ORIGINAL VERSION                                  *\n*                                                                     *\n*                 SAM LEPORE     AUGUST 1985                          *\n*                   TEXT EDITED FOR XA COMPATIBILITY                  *\n*                                                                     *\n***********************************************************************\n         EJECT\n*\n***********************************************************************\n*        INITIALIZATION                                               *\n***********************************************************************\n*\nINMXZ01  CSECT\n         SAVE  (14,12),,INMXZ01_V1.0_&SYSDATE_&SYSTIME\n         LR    R12,R15                 SAVE ENTRY POINT\n         USING INMXZ01,R12             SET UP BASE REGISTER\n         LR    R11,R1                  COPY PARM LIST ADDRESS\n         USING PL@LIST,R11             ESTABLISH ADDRESSABILITY\n         GETMAIN RU,LV=WORKLEN         OBTAIN STORAGE\n         ST    R13,4(,R1)              CHAIN SAVE AREAS\n         ST    R1,8(,R13)\n         LR    R13,R1                  NEW SAVEAREA\n         USING WORKAREA,R13            ESTABLISH ADDRESSABILITY\n*\n***********************************************************************\n*        SET UP ACF VERIFICATION CALL PARAMETER LIST (ACALT)          *\n***********************************************************************\n*\n         XC    ACALT(ACALTLEN),ACALT   CLEAR PARAMETER LIST\n         MVI   ACAFCN,2                SET REQUEST TYPE = ACALT\n         MVI   ACASFCN,ACASIRT         SET FUNCTION = INFO RETURN\n         MVC   ACAUCB,=X'FFFFFFFF'     INDICATE ACF2 \"SUPERCALL\"\n         LA    R1,MSGAREA              POINT T ERROR MSG AREA\n         ST    R1,ACAMSG               STORE IN ACF PARMS\n         LA    R1,RETBUFF              ADDRESS INFO RETURN BUFFER\n         ST    R1,ACARETB              STORE IN ACF PARMS\n         LA    R1,L'RETBUFF            GET LENGTH OF RETURN BUFFER\n         ST    R1,ACARETL              STORE IN ACF PARMS\n         EJECT\n*\n***********************************************************************\n*        ONE OF THE ENRTY PARAMETERS POINTS TO A TWO TEXT UNIT LIST   *\n*        THAT DESCRIBES THE TRANSMITTING USER:                        *\n*        PARM  ==> +0 POINTER ==> USERID TEXT UNIT                    *\n*                  +4 POINTER ==> NODE TEXT UNIT                      *\n*                                                                     *\n*        NOTE: EVERY TEXT UNIT (T/U) IS OF THE FOLLOWING FORMAT       *\n*      +0  KEY   DS  XL2    TYPE OF T/U               (EG. X'1011'  ) *\n*      +2  NUM   DS  XL2    NUMBER OF LEN+PARM PAIRS  (    X'0001'  ) *\n*      +4  LEN   DS  XL2    LENGTH OF PARM VALUE      (    X'0006'  ) *\n*      +6  PARM  DS  ....   ACTUAL PARAMETER          (    C'SFTEST') *\n*                                                                     *\n***********************************************************************\n*\n         L     R2,PLFUTXTU             ADDRESS \"FROM\" T/U POINTER LIST\n         L     R3,4(,R2)               ADDRESS SECOND T/U\n         LH    R4,4(,R3)               GET LENGTH OF FROM-NODE\n         BCTR  R4,0                    DECREMENT FOR EXECUTE\n         LA    R3,6(,R3)               POINT TO FROM-NODE NAME\n*\n***********************************************************************\n*        SEARCH ADDRESS LIST FOR LOCAL NODE                           *\n***********************************************************************\n*\n         LA    R5,PLTULIST             POINT TO ADDRESS OF DATA CHAIN\n         USING AL@LIST,R5\nNEXTUSER EQU   *\n         LR    R6,R5                   SAVE CURRENT AS PREV FOR RECHAIN\nNEWCHAIN EQU   *\n         ICM   R5,B'1111',ALNEXT       ADDRESS NEXT TO-USER DATA\n         BZ    RETURN0                 END OF CHAIN\n         EX    R4,CLCNODE              COMPARE FROM/TO NODE NAMES\n         BNE   NEXTUSER                NOT EQUAL, RECV JES2 WILL VERIFY\n*\n***********************************************************************\n*        ISSUE ACF2 USERID VERIFICATION CALL                          *\n***********************************************************************\n*\n         XC    MSGAREA,MSGAREA         CLEAR ERROR MSG AREA\n         XC    RETBUFF,RETBUFF         CLEAR INFO RETURN BUFFER\n         MVC   ACALID,ALUSER           MOVE RECEIVER ID FOR VERIFY\n*\n*        NOTE: ACFSVC MODIFIES REGISTERS R0, R1, R2, R14, R15\n*\n         ACFSVC ACALT,NONE=RETURN0     CALL ACF TO VERIFY USERID EXISTS\n         LTR   R15,R15                 IS IT GOOD ?\n         BZ    NEXTUSER                YES, CHECK NEXT USERID\n*\n***********************************************************************\n*        ISSUE \"USERID NOT FOUND\", UNCHAIN USERID FROM ADDRESS LIST   *\n***********************************************************************\n*\n         MVC   MSGAREA(UIDNFLEN),UIDNFMSG  PREPARE ERROR MESSAGE\n         MVC   MSGAREA+(UIDNFUID-UIDNFMSG)(L'ALUSER),ALUSER MOVE IN UID\n         LH    R1,ALUSERL              GET LENGTH OF USERID\n         LA    R1,MSGAREA+(UIDNFUID-UIDNFMSG)(R1)  POINT TO NEXT BYTE\n         MVI   0(R1),C'.'              ADD PERIOD FOR PUNCTUATION\n         XC    PUTLECB,PUTLECB         CLEAR THE ECB\n         L     R10,PLTSCPPL            ADDRESS TSO CMD PROCSR PARM LIST\n         USING CPPL,R10\n         PUTLINE PARM=PUTLPARM,UPT=CPPLUPT,ECT=CPPLECT,ECB=PUTLECB,    X\n               OUTPUT=(MSGAREA,DATA),MF=(E,PUTLIOPL)\n         DROP  R10\n         MVC   ALNEXT-AL@LIST(L'ALNEXT,R6),ALNEXT  POINT PREV TO NEXT\n         B     NEWCHAIN                GO NEXT, DON'T MOVE PREV POINTER\n*\n***********************************************************************\n*        SET ZERO RETURN CODE                                         *\n***********************************************************************\n*\nRETURN0  EQU   *\n         SR    R2,R2                   ZERO RETURN CODE\n*\n***********************************************************************\n*        RETURN ROUTINE                                               *\n***********************************************************************\n*\nRETURN   EQU   *\n         LR    R1,R13                  SAVE POINTER OF STORAGE\n         L     R13,4(,R13)             GET OLD SAVEAREA ADDRESS\n         FREEMAIN RU,LV=WORKLEN,A=(1)  FREE STORAGE\n         LR    R15,R2                  PASS RETURN CODE TO R15\n         RETURN (14,12),RC=(15)        AND RETURN\n         SPACE 3\n*\n***********************************************************************\n*        LITERALS AND CONSTANTS                                       *\n***********************************************************************\n*\nCLCNODE  CLC   0(0,R3),ALNODE          (EXECUTED) COMPARE FROM/TO NODE\nUIDNFMSG DC    Y(UIDNFLEN)             \"USERID NOT FOUND\" MESSAGE\n         DC    H'0'\n         DC    C'TRANSMIT will not be done to '\nUIDNFUID DC    CL8' '\n         DC    C'  The userid does not exist at this node.'\nUIDNFLEN EQU   *-UIDNFMSG              LENGTH OF MSG+HEADER FOR PUTLINE\n         LTORG\n*\n***********************************************************************\n*        DSECTS AND MAPPING MACROES                                   *\n***********************************************************************\n*\nWORKAREA DSECT\nSAVEAREA DS    9D                      STANDARD REGISTER SAVEAREA\nACALT    ACALT DSECT=NO                ACF2 LOGONID DATABASE CALL PARMS\nACALTLEN EQU   *-ACALT\nMSGAREA  DS    CL128                   ACF2 ERROR MESSAGE AREA\nRETBUFF  DS    CL52                    LOGONID INFO RETURN BUFFER\nPUTLPARM PUTLINE MF=L                  PUTLINE PARAMETER LIST\nPUTLIOPL DS    4F                      PUTLINE I/O PARAMETER LIST\nPUTLECB  DS    F                       PUTLINE ECB\nWORKLEN  EQU   *-WORKAREA\n         ACFREGS\n*\n***********************************************************************\n*        LOCAL MAPPING FOR INMZX01 ENTRY PARAMETER LIST               *\n***********************************************************************\n*\nPL@LIST  DSECT                         ENTRY PARAMETER LIST\nPLUSERWD DS    A                       ADDR OF A USER WORD\nPLXMKWDP DS    A                       ADDR OF KEYWORD PARM('STRING')\nPLACTFLG DS    A                       ADDR OF 1 BYTE ACTION FLAGS\nPLTSCPPL DS    A                       ADDR OF TSO CMD PROCSR PARM LIST\nPLXMEMSG DS    A                       ADDR OF ERR MSG XMIT TO ISSUE\nPLSTAFLG DS    A                       ADDR OF 1 BYTE STATUS FLAGS\nPLFUTXTU DS    A                       ADDR OF FROM-USER TEXT UNITS\nPLFDTXTU DS    A                       ADDR OF FROM-DATASET TEXT UNITS\nPLTULIST DS    A                       ADDR OF TO-USER DATA CHAIN\nPLXMDDNM DS    A                       ADDR OF DDNAME TO REPLACE DSN\nPLRXPSTG DS    A                       ADDR OF STRING FOR RECV EXITS\nPLRXNSTG DS    A                       ADDR OF NOTIFY MSG FOR RECV EXIT\n*\n***********************************************************************\n*        LOCAL MAPPING FOR ADDRESS LIST DATA CHAIN OF TO-USERS        *\n***********************************************************************\n*\nAL@LIST  DSECT                         ADDRESS LIST CHAIN OF TO-USERS\nALNEXT   DS    A                       ADDR OF NEXT ENTRY, OR ZERO\nALNODEL  DS    H                       LENGTH OF TARGET NODE NAME\nALNODE   DS    CL8                     TARGET NODE NAME\nALUSERL  DS    H                       LENGTH OF TARGET USERID\nALUSER   DS    CL8                     TARGET USERID\nALNICKL  DS    H                       LENGTH OF NICKNAME, OR ZERO\nALNICK   DS    CL8                     NICKNAME OF USERID\nALNAMEL  DS    H                       LENGTH OF NAME TAG, OR ZERO\nALNAME   DS    CL30                    NAME TAG OF USERID\nALFLAG   DS    X                       FLAG BYTE\nALNOTIFY EQU   X'80'                     REQUEST NOTIFY FOR THIS USERID\nALXMITOK EQU   X'20'                     XMIT SUCCESFULLY COMPLETED\n         DS    X                       (RESERVED)\nALPARML  DS    H                       LENGTH OF PARM TAG, OR ZERO\nALPARM   DS    CL30                    PARM TAG OF USERID\n*\n         IKJCPPL\n         PRINT NOGEN\n         ACCVT\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INMXZ02": {"ttr": 1542, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87(\\x7f\\x00\\x87(\\x7f\\x12\\x00\\x01\\x12\\x01\\x12\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-10-14T00:00:00", "modifydate": "1987-10-14T12:00:00", "lines": 274, "newlines": 274, "modlines": 0, "user": "FILE325"}, "text": "***********************************************************************\n*                                                                     *\n*   MODULE NAME:  INMXZ02                                             *\n*                                                                     *\n*   DESCRIPTION:  WELLS FARGO BANK TSO/E TRANSMIT TERMINATION EXIT    *\n*                                                                     *\n*        STATUS:  TSO/E RELEASE 2.0                                   *\n*                                                                     *\n*      FUNCTION:  ISSUE EQUIVALENT OF \"$HASP549 MAIL FROM\" MESSAGE    *\n*                 TO NOTIFY RECEIVING USERS OF LOCAL NODE TRANSMIT.   *\n*                 (LOCAL TRANSMIT DOES NOT PASS THROUGH JES EXIT 13). *\n*                                                                     *\n*     OPERATION:  -  SEARCH ADDRESS LIST FOR LOCAL NODE.              *\n*                 -  IF FOUND, VERIFY OUTPUT TARGET IS JES SYSOUT     *\n*                      AND TRANSMISSION SUCCESSFULLY COMPLETED.       *\n*                 -  ISSUE \"SE '$HASP549...',USER=(),LOGON\" VIA SVC34 *\n*                 -  ALWAYS RETURN CONDITION ZERO (CONTINUE TRANSMIT).*\n*                                                                     *\n*     REGISTERS:  R0  -  PARM/WORK REGISTER                           *\n*                 R1  -  PARM/WORK REGISTER                           *\n*                 R2  -  WORK REGISTER (ALSO USED TO PASS RC TO R15)  *\n*                 R3  -  POINTER TO FROM-NODE NAME                    *\n*                 R4  -  MACHINE LENGTH OF FROM-NODE NAME             *\n*                 R5  -  POINTER TO CURRENT TO-USER DATA              *\n*                 R6  -  POINTER TO FROM-USER ID                      *\n*                 R7  -  MACHINE LENGTH OF FROM-USER ID               *\n*                 R8  -  MACHINE LENGTH OF NUMBER OF RECORDS XMITED   *\n*                 R11 -  POINTER TO INPUT PARAMETER LIST              *\n*                 R12 -  BASE REGISTER                                *\n*                 R13 -  BASE REGISTER FOR WORKAREA                   *\n*                 R14 -  RETURN REGISTER                              *\n*                 R15 -  RETURN CODE REGISTER                         *\n*                                                                     *\n*    ATTRIBUTES:  KEY 8, PROBLEM STATE, APF ON, REENTRANT             *\n*                                                                     *\n*         INPUT:  R1, POINTER TO PARAMETER LIST, SEE PL@LIST          *\n*                                                                     *\n*        OUTPUT:  TSO MAIL MESSAGE ISSUED VIA OPERATOR SEND COMMAND   *\n*                                                                     *\n*          EXIT:  ALWAYS CONDITION CODE ZERO - CONTINUE TRANSMIT      *\n*                                                                     *\n*  CONTROL BLKS:  NONE (SVC 34 PARAMETER LIST BUILT DYNAMICALLY)      *\n*                                                                     *\n* MACROS & SVCS:  FREEMAIN, GETMAIN, RETURN, SAVE, SVC 34             *\n*                                                                     *\n*   ABEND CODES:  NONE                                                *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n*    CHANGE LOG:  SAM LEPORE     JANUARY 1985                         *\n*                   ORIGINAL VERSION                                  *\n*                                                                     *\n***********************************************************************\n         EJECT\n*\n***********************************************************************\n*        INITIALIZATION                                               *\n***********************************************************************\n*\nINMXZ02  CSECT\n         SAVE  (14,12),,INMXZ02_V1.0_&SYSDATE_&SYSTIME\n         LR    R12,R15                 SAVE ENTRY POINT\n         USING INMXZ02,R12             SET UP BASE REGISTER\n         LR    R11,R1                  COPY PARM LIST ADDRESS\n         USING PL@LIST,R11             ESTABLISH ADDRESSABILITY\n         GETMAIN RU,LV=WORKLEN         OBTAIN STORAGE\n         ST    R13,4(,R1)              CHAIN SAVE AREAS\n         ST    R1,8(,R13)\n         LR    R13,R1                  NEW SAVEAREA\n         USING WORKAREA,R13            ESTABLISH ADDRESSABILITY\n*\n***********************************************************************\n*        VERIFY DATA WAS SENT TO SYSOUT (NOT TO DATASET OR DDNAME)    *\n***********************************************************************\n*\n         L     R2,PLSTAFLG             ADDRESS 1 BYTE STATUS FLAGS\n         TM    0(R2),PLNOTJES          DID OUTPUT GO NON-JES ?\n         BO    RETURN0                 YES, DONE (NOTHING REALLY XMITD)\n*\n***********************************************************************\n*        ONE OF THE ENRTY PARAMETERS POINTS TO A TWO TEXT UNIT LIST   *\n*        THAT DESCRIBES THE TRANSMITTING USER:                        *\n*        PARM  ==> +0 POINTER ==> USERID TEXT UNIT                    *\n*                  +4 POINTER ==> NODE TEXT UNIT                      *\n*                                                                     *\n*        NOTE: EVERY TEXT UNIT (T/U) IS OF THE FOLLOWING FORMAT       *\n*      +0  KEY   DS  XL2    TYPE OF T/U               (EG. X'1011'  ) *\n*      +2  NUM   DS  XL2    NUMBER OF LEN+PARM PAIRS  (    X'0001'  ) *\n*      +4  LEN   DS  XL2    LENGTH OF PARM VALUE      (    X'0006'  ) *\n*      +6  PARM  DS  ....   ACTUAL PARAMETER          (    C'SFTEST') *\n*                                                                     *\n***********************************************************************\n*\n         L     R2,PLFUTXTU             ADDRESS \"FROM\" T/U POINTER LIST\n         L     R3,4(,R2)               ADDRESS SECOND T/U\n         LH    R4,4(,R3)               GET LENGTH OF FROM-NODE\n         BCTR  R4,0                    DECREMENT FOR EXECUTE\n         LA    R3,6(,R3)               POINT TO FROM-NODE NAME\n*\n         L     R6,0(,R2)               ADDRESS FIRST T/U\n         LH    R7,4(,R6)               GET LENGTH OF FROM-USER\n         BCTR  R7,0                    DECREMENT FOR EXECUTE\n         LA    R6,6(,R6)               POINT TO FROM-USER ID\n*\n         L     R2,PLNUMREC             ADDRESS NUMBER RECORDS XMITED\n         L     R2,0(,R2)               GET NUMBER\n         CVD   R2,DBLWORD              CONVERT TO PACKED DECIMAL FORMAT\n         MVC   RECSXMIT,RECXMASK       MOVE IN PATTERN MASK\n         LA    R1,RECSXMIT+7           DEFAULT TO LAST DIGIT AS SIGNIF\n         LR    R8,R1                   SAVE FOR LENGTH COMPUTATION\n         EDMK  RECSXMIT,DBLWORD+4      CONVERT TO PRINTABLE\n         MVC   RECSXMIT(7),0(R1)       SLIDE RESULT LEFT (MAX 7 CHARS)\n         SR    R8,R1                   GET MACHINE LENGTH OF RESULT\n*\n***********************************************************************\n*        SEARCH ADDRESS LIST FOR LOCAL NODE                           *\n***********************************************************************\n*\n         LA    R5,PLTULIST             POINT TO ADDRESS OF DATA CHAIN\n         USING AL@LIST,R5\nNEXTUSER EQU   *\n         ICM   R5,B'1111',ALNEXT       ADDRESS NEXT TO-USER DATA\n         BZ    RETURN0                 END OF CHAIN\n         EX    R4,CLCNODE              COMPARE FROM/TO NODE NAMES\n         BNE   NEXTUSER                NOT EQUAL, RECV JES2 WILL VERIFY\n*\n***********************************************************************\n*        VERIFY TRANSMISSION WAS SUCCESSFULLY COMPLETED               *\n***********************************************************************\n*\n         TM    ALFLAG,ALXMITOK         TRANSMIT SUCCESSFUL ?\n         BNO   NEXTUSER                NO, IGNORE\n*\n***********************************************************************\n*        ISSUE: $HASP549 MAIL FROM(NODENAME/USERID ) RECORDS(NNNNNNN) *\n*           BY: SE '$HASP549 ...',LOGON,USER=(USERID)                 *\n*        USING: SVC 34 TO GENERATE AN \"INTERNAL CONSOLE COMMAND\"      *\n***********************************************************************\n*\n         MVC   MSGAREA(SE549LEN),SE549HDR  MOVE \"SE '$HASP549 \" HEADER\n         LA    R1,MSGAREA+SE549LEN     POINT TO NEXT BYTE FOR NODENAME\n         EX    R4,MVCNODE              MOVE IN FROM-NODE\n         LA    R1,1(R4,R1)             POINT TO BYTE AFTER NODENAME\n         MVI   0(R1),C'/'              MOVE IN SEPARATOR SLASH\n         EX    R7,MVCFUID              MOVE IN FROM-USER ID\n         LA    R1,2(R7,R1)             POINT TO BYTE AFTER FROM-USER ID\n         MVC   0(L'SE549REC,R1),SE549REC  MOVE IN ') RECORDS(' LITERAL\n         EX    R8,MVCRECX              MOVE IN NUMBER RECORDS XMITED\n         LA    R1,L'SE549REC+1(R8,R1)  POINT TO BYTE AFTER NUM REC XMIT\n         MVC   0(L'SE549LGN,R1),SE549LGN  MOVE IN 'LOGON,USER=' LITERAL\n         LH    R2,ALUSERL              GET LENGTH OF TO-USER ID\n         BCTR  R2,0                    DECREMENT FOR MACHINE LENGTH\n         EX    R2,MVCTUID              MOVE IN TO-USER ID\n         LA    R1,L'SE549LGN+1(R2,R1)  POINT TO BYTE AFTER TO-USER ID\n         MVI   0(R1),C')'              MOVE IN FINAL RIGHT PARENTHESIS\n         LA    R2,MSGAREA-1            POINT TO BEGINNING (MINUS 1)\n         SR    R1,R2                   GET REAL LENGTH OF COMPLETE MSG\n         STH   R1,MSGAREA              STORE IN FIRST HALFWORD FOR SVC\n         MODESET KEY=ZERO\n         SR    R0,R0                   NO CONSOLE NUMBER\n         LA    R1,MSGAREA              POINT TO PARAMETER\n         SVC   34                      ISSUE COMMAND\n         MODESET KEY=NZERO\n         B     NEXTUSER                GO CHECK THE NEXT TO-USER\n*\n***********************************************************************\n*        SET ZERO RETURN CODE                                         *\n***********************************************************************\n*\nRETURN0  EQU   *\n         SR    R2,R2                   ZERO RETURN CODE\n*\n***********************************************************************\n*        RETURN ROUTINE                                               *\n***********************************************************************\n*\nRETURN   EQU   *\n         LR    R1,R13                  SAVE POINTER OF STORAGE\n         L     R13,4(,R13)             GET OLD SAVEAREA ADDRESS\n         FREEMAIN RU,LV=WORKLEN,A=(1)  FREE STORAGE\n         LR    R15,R2                  PASS RETURN CODE TO R15\n         RETURN (14,12),RC=(15)        AND RETURN\n         SPACE 3\n*\n***********************************************************************\n*        LITERALS AND CONSTANTS                                       *\n***********************************************************************\n*\nCLCNODE  CLC   0(0,R3),ALNODE          (EXECUTED) COMPARE FROM/TO NODE\nMVCNODE  MVC   0(0,R1),0(R3)           (EXECUTED) MOVE FROM-NODE TO MSG\nMVCFUID  MVC   1(0,R1),0(R6)           (EXECUTED) MOVE FROM-USER TO MSG\nMVCRECX  MVC   L'SE549REC(0,R1),RECSXMIT (EXECUTED) MOVE NUM RECS XMITD\nMVCTUID  MVC   L'SE549LGN(0,R1),ALUSER   (EXECUTED) MOVE TO-USER TO MSG\nRECXMASK DC    X'4020202020202120'     PATTERN MASK TO EDITMARK REC NUM\n*\nSE549HDR DS    0F                      SVC34 PARMS MUST BE WORD BOUNDRY\n         DC    H'0'                    LENGTH INCLUDING PREFIX\n         DC    H'0'                    FILLER REQUIRED BY SVC34\n         DC    C'SE ''$HASP549 MAIL FROM('\nSE549LEN EQU   *-SE549HDR              LENGTH OF HEADER\nSE549REC DC    C') RECORDS('\nSE549LGN DC    C')'',LOGON,USER=('\n*\n         LTORG\n         SPACE 3\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*\n***********************************************************************\n*        DSECTS AND MAPPING MACROES                                   *\n***********************************************************************\n*\nWORKAREA DSECT\nSAVEAREA DS    9D                      STANDARD REGISTER SAVEAREA\nDBLWORD  DS    D                       DOUBLE WORD FOR CONVERT-PRINT\nRECSXMIT DS    XL8                     RECORDS TRANSMITTED (PRINTABLE)\nMSGAREA  DS    0F,CL128                MSG CREATION AREA (ON FULLWORD!)\nWORKLEN  EQU   *-WORKAREA\n*\n***********************************************************************\n*        LOCAL MAPPING FOR INMZX02 ENTRY PARAMETER LIST               *\n***********************************************************************\n*\nPL@LIST  DSECT                         ENTRY PARAMETER LIST\nPLUSERWD DS    A                       ADDR OF A USER WORD\nPLXMKWDP DS    A                       ADDR OF KEYWORD PARM('STRING')\nPLACTFLG DS    A                       ADDR OF 1 BYTE ACTION FLAGS\nPLTSCPPL DS    A                       ADDR OF TSO CMD PROCSR PARM LIST\nPLXMEMSG DS    A                       ADDR OF ERR MSG XMIT TO ISSUE\nPLSTAFLG DS    A                       ADDR OF 1 BYTE STATUS FLAGS\nPLNOTJES EQU   X'80'                     OUTPUT NOT JES (IS DSN OR DD)\nPLFUTXTU DS    A                       ADDR OF FROM-USER TEXT UNITS\nPLFDTXTU DS    A                       ADDR OF FROM-DATASET TEXT UNITS\nPLTULIST DS    A                       ADDR OF TO-USER DATA CHAIN\nPLNUMREC DS    A                       ADDR OF WORD, NUM RECORDS XMITED\nPLXMITRC DS    A                       ADDR OF WORD, TRANSMIT CMD RETCD\n*\n***********************************************************************\n*        LOCAL MAPPING FOR ADDRESS LIST DATA CHAIN OF TO-USERS        *\n***********************************************************************\n*\nAL@LIST  DSECT                         ADDRESS LIST CHAIN OF TO-USERS\nALNEXT   DS    A                       ADDR OF NEXT ENTRY, OR ZERO\nALNODEL  DS    H                       LENGTH OF TARGET NODE NAME\nALNODE   DS    CL8                     TARGET NODE NAME\nALUSERL  DS    H                       LENGTH OF TARGET USERID\nALUSER   DS    CL8                     TARGET USERID\nALNICKL  DS    H                       LENGTH OF NICKNAME, OR ZERO\nALNICK   DS    CL8                     NICKNAME OF USERID\nALNAMEL  DS    H                       LENGTH OF NAME TAG, OR ZERO\nALNAME   DS    CL30                    NAME TAG OF USERID\nALFLAG   DS    X                       FLAG BYTE\nALNOTIFY EQU   X'80'                     REQUEST NOTIFY FOR THIS USERID\nALXMITOK EQU   X'20'                     XMIT SUCCESFULLY COMPLETED\n         DS    X                       (RESERVED)\nALPARML  DS    H                       LENGTH OF PARM TAG, OR ZERO\nALPARM   DS    CL30                    PARM TAG OF USERID\n*\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JESLOGON": {"ttr": 1547, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87(\\x7f\\x00\\x87(\\x7f\\x12\\x00\\x01?\\x01?\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-10-14T00:00:00", "modifydate": "1987-10-14T12:00:00", "lines": 319, "newlines": 319, "modlines": 0, "user": "FILE325"}, "text": "JESLOGON CSECT\n*\n***********************************************************************\n*                                                                     *\n*                       J E S L O G O N                               *\n*                                                                     *\n* FUNCTION -                                                          *\n*    THIS MODULE IS DESIGNED TO BE THE PROGRAM EXECUTED BY THE TSO    *\n*    LOGON PROCESSOR. IT WILL CHANGE THE TSO USER FROM EXECUTION      *\n*    UNDER THE PRIMARY SUBSYSTEM TO EXECUTION UNDER ANY OF THE ACTIVE *\n*    SUBSYSTEMS.                                                      *\n*                                                                     *\n* INPUT -                                                             *\n*    THE TSO USER IS PROMPTED FOR THE NAME OF THE SUBSYSTEM DESIRED.  *\n*    PARAMETERS PASSED BY THE LOGON PROC ARE PASSED ON TO THE TMP     *\n*    UNALTERED.                                                       *\n*                                                                     *\n* OPERATION -                                                         *\n*    1) THE TSO USER IS PROMPTED FOR THE SUBSYSTEM NAME THAT HE       *\n*       WISHES TO LOG ON TO.                                          *\n*    2) IF THE USER SPECIFIED A NULL LINE OR THE NAME OF THE PRIMARY  *\n*       SUBSYSTEM, THE TMP IS ATTACHED IMMEDIATELY (IE. GOTO STEP 6). *\n*    3) AN SSIB IS BUILT TO INTERFACE TO THE DESIRED SUBSYSTEM.       *\n*    4) A SUBSYSTEM REQUEST IS ISSUED FOR \"REQUEST JOB ID\" FROM THE   *\n*       DESIRED SUBSYSTEM TO SET UP THE SJB, ETC.                     *\n*    5) THE SSIB POINTER IN THE JSCB IS CHANGED TO POINT TO THE NEW   *\n*       SSIB, AND THE ORIGINAL SSIB POINTER IS SAVED.                 *\n*    6) IF THE PARAMETERS PASSED TO THE TMP INDICATE THAT THE SESSION *\n*       MANAGER IS BEING INVOKED, MODULE ADFMDF03 IS ATTACHED; ELSE   *\n*       WE ATTACH IKJEFT01. THIS MODULE THEN WAITS FOR COMPLETION OF  *\n*       THE REAL TMP.                                                 *\n*    7) WHEN THE TMP TERMINATES, WE RESTORE THE SSIB POINTER IN THE   *\n*       JSCB AND ALL THAT STUFF IN THE REVERSE ORDER FROM OUR ENTRY   *\n*       CODE.                                                         *\n*    8) THE RETURN CODE FROM THE TMP IS PASSED BACK TO THE CALLER AND *\n*       JESLOGON TERMINATES.                                          *\n*                                                                     *\n* RESTRICTIONS -                                                      *\n*    1) NO SYSOUT DD CARDS CAN BE INCLUDED IN THE JESLOGON PROC       *\n*       BECAUSE ALLOCATIONS WILL BE DONE AGAINST THE PRIMARY          *\n*       SUBSYSTEM AND WILL THEREFORE PRODUCE AN 013 ABEND IF AN       *\n*       ATTEMPT IS MADE TO ACCESS THEM FROM A SECONDARY.              *\n*    2) THE JOBNAME IN THE SECONDARY SUBSYSTEM WILL BE \"SYSLOG\" DUE   *\n*       TO THE WAY IN WHICH \"REQUEST JOB ID\" SUPPORT FUNCTIONS.       *\n*                                                                     *\n* NOTES -                                                             *\n*    1) ORIGINAL IDEA FOR THIS MODULE WAS SUPPLIED BY JIM VINSON,     *\n*       IBM CORP (MANASSAS AT THE TIME). UPDATE AND DEBUG DONE BY     *\n*       GEORGE DELANO AND MIKE SHANNON, IBM BURLINGTON (8-) 446-3033. *\n*                                                                     *\n*       AT SHARE 62 (ANAHEIM 3/84) WE MET MIKE SHANNON AND         WFB*\n*       EXPLAINED THAT WE ACQUIRED THIS PROGRAM \"IN THE PUBLIC     WFB*\n*       DOMAIN\". HE IS NOT AWARE OF ANY LEGAL RESTRICTION AGAINST  WFB*\n*       REDRISTRIBUTION NOR DOES HE OBJECT TO IT, BUT (AS ALWAYS)  WFB*\n*       * * *   U S E   A T   Y O U R   O W N   R I S K   * * *    WFB*\n*       THERE IS A SIMILAR PROGRAM DISTRIBUTED WITH THE IBM FDP    WFB*\n*       TSO/JES2 BATCH DISPLAY FACILITY. THIS IS NOT THE SAME.     WFB*\n*                                                                     *\n*    2) LINKAGE EDITOR PARAMETERS AND CONTROL CARDS:                  *\n*         PARM.LKED='MAP,LET,LIST,NCAL'                               *\n*           ENTRY    JESLOGON                                         *\n*           SETCODE  AC(1)                                            *\n*           NAME     JESLOGON(R)                                      *\n*                                                                     *\n*    3) JESLOGON MUST (OBVIOUSLY) BE LINKEDITED INTO AN AUTHORIZED    *\n*       SYSTEM LIBRARY ACCESSABLE VIA THE TSO LOGON PROCEDURE.        *\n*           SAMPLE:  //TSOPROC PROC                                   *\n*                    //TSOPROC EXEC PGM=JESLOGON,DYNAMNBR=...         *\n*                                                                     *\n*    4) DATE OF LAST UPDATE: 3/13/78 BY GD.                           *\n*                                                                     *\n***********************************************************************\n         EJECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nSSOBR    EQU   8\nSSIBR    EQU   9\nBASEREG  EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n         USING *,BASEREG\n         SAVE  (14,12),,JESLOGON.&SYSDATE\n         SPACE\n         LR    BASEREG,R15\n         LR    R11,R1                  SAVE PARM\n         SPACE\n         LA    R0,DSALEN\n         GETMAIN R,LV=(0)\n         ST    R13,4(R1)               SAVE HIGHER LEVEL SAVE AREA\n         ST    R1,8(R13)               CHAIN OUR SAVE AREA TO IT\n         LR    R13,R1\n         USING DSA,R13\n         SPACE\n         MVI   DSAFLG,0                INIT FLAG\n         EJECT\n*        GET CORE FOR AND BUILD SSIB\n         SPACE\n         MODESET MODE=SUP\n         SPACE\n         GETMAIN R,LV=SSIBSIZE,SP=255  GET NEW SSIB\n         LR    SSIBR,R1\n         USING SSIB,SSIBR\n         SPACE\n         MODESET EXTKEY=ZERO,SAVEKEY=(2),WORKREG=2\n         XC    SSIB(SSIBSIZE),SSIB     CLEAR SSIB\n         MVC   SSIBID,=C'SSIB'\n         MVI   SSIBLEN+1,SSIBSIZE\n         MODESET KEYADDR=(2)           RESTORE KEY\n         EJECT\n*        BUILD SSOB\n         SPACE\n         LA    SSOBR,DSASSOB           PLACE TO BUILD SSOB\n         USING SSOB,SSOBR\n         XC    SSOB(SSOBLENE),SSOB     CLEAR SSOB\n         MVC   SSOBID,=C'SSOB'         IDENTIFY IT\n         MVI   SSOBLEN+1,SSOBHSIZ      SET HEADER LENGTH\n         MVI   SSOBFUNC+1,SSOBRQST     SET TO REQUEST JOB ID\n         ST    SSIBR,SSOBSSIB          SET SSIB ADDRESS\n         SPACE\n         LA    R1,SSRRLEN              ADDRESS OF EXTENSION\n         ST    R1,SSOBINDV             SET IN SSOB HEADER\n         MVI   SSRRLEN+1,SSRRSIZE      SET EXTENSION SIZE\n         SPACE\n         LA    R1,DMYECB               DUMMY ECB\n         XC    DMYECB,DMYECB           CLEAR DUMMY ECB\n         ST    R1,SSRRSECB             SET AS STOP ECB\n         SPACE\n         ST    SSOBR,SSREQPRM          SAVE AS PARM\n         SPACE\n         MVI   SSREQPRM,X'80'          END OF PARM LIST\n         EJECT\nENTERIT  TPUT  MSG1,L'MSG1\n         SPACE\n         LTR   R15,R15\n         BNZ   ERR1\n         SPACE\n         LA    R1,JESNAME\n         TGET  (R1),L'JESNAME\n         SPACE\n         LTR   R15,R15\n         BZ    GOODTGET\n         C     R15,=F'12'              REPLY TOO LONG?\n         BE    BADTGET                 ADMONISH USER IF SO,\n         B     ERR1                    ELSE ERROR\n         SPACE\nGOODTGET LTR   R1,R1                   WAS REPLY NULL?\n         BZ    NOCHNG                  IF SO, DEFAULT TO PRIMARY\n         SPACE\n         OC    JESNAME,=CL4' '         CHANGE TO UPPER CASE\n         C     R1,=F'4'                WAS REPLY LENGTH 4?\n         BNE   BADTGET                 SLAP USERS HANDS ONE TIME\n         SPACE\n         L     R1,16                   CVTP\n         L     R1,0(R1)                TCB/TCBP\n         L     R1,4(R1)                TCBP\n         L     R1,124(R1)              JSTCB\n         L     R1,X'B4'(R1)            PT TO JSCB\n         L     R1,X'13C'(R1)           GET OLD SSIBPTR\n         CLC   JESNAME,SSIBSSNM-SSIB(R1) USER PICK PRIMARY SUBSYSTEM?\n         BE    NOCHNG                  YES, LOGON TO PRIMARY\n         EJECT\n         MODESET EXTKEY=ZERO,SAVEKEY=(2),WORKREG=2\n         MVC   SSIBSSNM,JESNAME        COPY SUBSYSTEM NAME TO SSIB\n         MODESET KEYADDR=(2)           RESTORE KEY\n         SPACE\n         LA    R1,SSREQPRM             SET UP FOR IEFSSREQ\n         IEFSSREQ\n         SPACE\n         C     R15,=A(SSRTNTUP)        CHECK FOR NOT UP\n         BE    BADTGET1                IGNORE IF NOT UP\n         SPACE\n         C     R15,=A(SSRTNOSS)        CHECK FOR INVALID NAME\n         BE    BADTGET2                IGNORE IF SUBSYS DOES NOT EXIST\n         SPACE\n         C     R15,=A(SSRTOK)          CHECK FOR OK\n         BNE   ERR1                    B IF NOT\n         SPACE\n         CLI   SSOBRETN+3,SSRROK       REQUEST OK?\n         BNE   ERR1                    B IF NOT\n         EJECT\n*        NOW CHANGE JSCBSSIB TO POINT TO THE NEW SSIB\n         SPACE\n         L     R3,16                   CVTP\n         L     R3,0(R3)                TCB/TCBP\n         L     R3,4(R3)                TCBP\n         L     R3,124(R3)              JSTCB\n         L     R5,X'B4'(R3)            PT TO JSCB\n         L     R3,X'13C'(R5)           GET OLD SSIBPTR\n         SPACE\n         MODESET EXTKEY=ZERO,SAVEKEY=(2),WORKREG=2\n         ST    SSIBR,X'13C'(R5)        SET NEW SSIBPTR\n         OI    DSAFLG,SETSSIBP         FLAG THIS FACT\n         MODESET KEYADDR=(2)\n         SPACE\n         ST    R3,SAVESSIB             SAVE SSIBPTR FOR RESTORE\n         ST    R5,JSCBPTR              SAVE ADDRESS OF JSCB\n         EJECT\n*        NOW ATTACH THE NORMAL TERMINAL MONITOR PGM\n         SPACE\nNOCHNG   LA    R2,=CL8'IKJEFT01'       ASSUME NORMAL TMP\n         LR    R1,R11                  RESTORE PARM ADDRESS\n         L     R14,0(R1)               GET PTR TO INPUT PARAMETERS\n         LH    R0,0(R14)               GET PARAMETER LENGTH\n         LTR   R0,R0                   WAS THERE A PARAMETER?\n         BZ    ATTACHIT                ATTACH NORMAL TMP IF NOT\n         CLC   =C'SM(',2(R14)          TEST FOR SESSION MANAGER\n         BNE   ATTACHIT                ATTACH NORMAL TMP IF NOT\n         LA    R2,=CL8'ADFMDF03'       CHANGE ATTACH TO SESSION MGR.\nATTACHIT LA    R3,DMYECB               POINT TO ECB\n         MVC   ATTACH(ATTACHLL),ATTACHL  COPY ATTACH CONTROL LIST\n         ATTACH EPLOC=(R2),ECB=(R3),SF=(E,ATTACH)\n         SPACE\n         ST    R1,TCBADDR              SAVE TCB ADDRESS\n         SPACE\n         XC    DMYECB,DMYECB           CLEAR ECB\n         WAIT  1,ECB=DMYECB            WAIT FOR RETURN\n         SPACE\n         LA    R1,TCBADDR              GET TCB ADDRESS\n         DETACH (1)                    DETACH TMP\n         EJECT\n         TM    DSAFLG,SETSSIBP         DID WE CHANGE SSIBPTR\n         BNO   DNCHNG\n         SPACE\n         MODESET EXTKEY=ZERO,SAVEKEY=(2),WORKREG=2\n         L     R5,JSCBPTR\n         MVC   X'13C'(4,R5),SAVESSIB   RESET SSIB\n         MODESET KEYADDR=(2)\n         SPACE\n         MVI   SSOBFUNC+1,SSOBRTRN     SET TO RETURN JOB ID\n         LA    R1,SSREQPRM             SET UP FOR IEFSSREQ\n         IEFSSREQ\n         EJECT\nDNCHNG   FREEMAIN R,LV=SSIBSIZE,SP=255,A=(SSIBR)  FREE THE SSIB\n         SPACE\n         LA    R0,DSALEN               SIZE OF CORE TO FREE\n         LR    R1,R13                  ADDR OF CORE TO FREE\n         L     R4,DMYECB               GET RETURN CODE\n         L     R13,4(R13)              GET CALLERS R13\n         FREEMAIN R,LV=(0),A=(1)\n         SPACE\n         MODESET MODE=PROB\n         SPACE\n         LA    R15,0(R4)               SET RETURN CODE\n         RETURN (14,12),RC=(15)        RETURN TO CALLER\n         EJECT\nBADTGET1 TPUT  MSG3,L'MSG3\n         SPACE\n         LTR   R15,R15\n         BNZ   ERR1\n         SPACE\n         B     ENTERIT\n         SPACE\nBADTGET2 TPUT  MSG4,L'MSG4\n         SPACE\n         LTR   R15,R15\n         BNZ   ERR1\n         SPACE\n         B     ENTERIT\n         SPACE\nBADTGET  TPUT  MSG2,L'MSG2\n         SPACE\n         LTR   R15,R15\n         BNZ   ERR1\n         SPACE\n         B     ENTERIT\n         SPACE\nERR1     STM   R14,R1,ERRREGS          SAVE R14 THRU R1 FROM ABEND\n         ABEND 1,DUMP,STEP\n         EJECT\nMSG1     DC    C'ENTER SUBSYSTEM NAME OR NULL LINE'\nMSG2     DC    C'SUBSYSTEM NAME MUST BE FOUR CHARACTERS...'\nMSG3     DC    C'SUBSYSTEM NAME VALID BUT NOT ACTIVE'\nMSG4     DC    C'SUBSYSTEM DOES NOT EXIST'\n         SPACE 2\nATTACHL  ATTACH RSAPF=YES,SF=L\nATTACHLL EQU   *-ATTACHL\n         SPACE 2\n         LTORG\n         EJECT\nDSA      DSECT\n         DS    18F\nERRREGS  DS    4F                      STM R14,R1 PRIOR TO ABEND\nSAVESSIB DS    A\nJSCBPTR  DS    A\nTCBADDR  DS    F                       ATTACHED TASK TCB ADDRESS\nJESNAME  DS    CL4                     SUBSYSTEM NAME\nDMYECB   DS    F'0'                    ECB FOR WAIT AFTER ATTACH\nSSREQPRM DS    A\nDSAFLG   DC    X'00'\nSETSSIBP EQU   X'80'                   ON MEANS CHANGED SSIB IN JSCB\n         DS    0F\nATTACH   ATTACH RSAPF=YES,SF=L\n         DS    0D\nDSASSOB  DS    XL(SSOBLENE)\nDSAEND   DS    0D\nDSALEN   EQU   *-DSA\n         EJECT\n         IEFJSSIB\n         EJECT\n         IEFJSSOB RR,CONTIG=YES\n         SPACE 2\n         PRINT NOGEN\n         CVT\n         IEFJESCT\n         END\n         PUNCH ' ENTRY JESLOGON'\n         PUNCH ' SETCODE AC(1)'\n         PUNCH ' NAME JESLOGON(R)'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JESMAXCC": {"ttr": 1798, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87(\\x7f\\x00\\x87(\\x7f\\x12\\x00\\x01\\xb8\\x01\\xb8\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-10-14T00:00:00", "modifydate": "1987-10-14T12:00:00", "lines": 440, "newlines": 440, "modlines": 0, "user": "FILE325"}, "text": "EXIT016  TITLE 'WFB - EXIT 016 - MAX COND CODE/ABEND CODE SUPPORT'\n***********************************************************************\n*                                                                     *\n* MODULE NAME: EXIT016                                                *\n*                                                                     *\n* DESCRIPTIVE NAME: JES2 EXIT 016 - MAX COND CODE/ABEND CODE SUPPORT  *\n*                                                                     *\n* AUTHOR: VIC COZZOLI                                                 *\n*         WELLS FARGO BANK, N.A. (WFB)                                *\n*         525 MARKET STREET, A.U. 8513                                *\n*         SAN FRANCISCO, CALIFORNIA  94163                            *\n*                                                                     *\n*         PHONE: (415) 396-6376                                       *\n*                                                                     *\n*                                                                     *\n* DATE WRITTEN: NOVEMBER 1983                                         *\n*                                                                     *\n* FMID: HJE2329 (MVS/SP-JES2 1.3.3)                                   *\n*                                                                     *\n* PURPOSE: THIS EXIT MODIFIES THE $HASP165 MESSAGE BY ADDING EITHER   *\n*          THE MAXIMUM CONDITON CODE OF ALL THE STEPS IN A JOB OR     *\n*          THE ABEND CODE OF THE JOB.                                 *\n*                                                                     *\n* ENTRY POINT: UEXIT016                                               *\n*                                                                     *\n* REGISTERS ON INPUT:                                                 *\n*     R0: 0                                                           *\n*     R1: ADDRESS OF 3-WORD PARMETER LIST WITH THE FOLLOWING LAYOUT:  *\n*         WORD 1 (+0) ADDRESS OF THE MESSAGE TO BE SEND               *\n*         WORD 2 (+4) ADDRESS OF THE $WTO PARAMETER LIST              *\n*         WORD 3 (+8) ADDRESS OF THE JCT                              *\n*     R2-R10: N/A                                                     *\n*     R11: ADDRESS OF THE HCT                                         *\n*     R12: N/A                                                        *\n*     R13: ADDRESS OF THE OUTPUT PROCESSOR PCE                        *\n*     R14: RETURN ADDRESS                                             *\n*     R15: ENTRY ADDRESS                                              *\n*                                                                     *\n* REGISTERS ON RETURN:                                                *\n*     R0: N/A                                                         *\n*     R1: ADDRESS OF THE 3-WORD PARAMETER LIST                        *\n*     R15: A RETURN CODE:                                             *\n*          =0, CONTINUE NORMAL EXIT OR JES2 PROCESSING                *\n*          =4, IGNORE ANY OTHER EXITS AND CONTINUE WITH NORMAL        *\n*              PROCESSING                                             *\n*          =8, TELLS JES2 NOT TO ISSUE THE NOTIFY $WTO                *\n*                                                                     *\n* JES2 MACROS USED:                                                   *\n*     $ENTRY, $SAVE, $RETURN, $MODEND                                 *\n*                                                                     *\n* LAST UPDATE: BY TOM LITNEY FOR JES2 2.1.5, CHANGES ARE IDENTIFIED   *\n*              BY 'TL' ON LINE                                        *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         EJECT\n         COPY $HASPGBL                 COPY HASP GLOBALS\n         EJECT\nJ2XIT016 $MODULE                                                       C\n               $BUFFER,                REQ'D BY JCT                    C\n               $CAT,                   REQ'D BY HCT                    C\n               $CMB,                   REQ'D TO MAP $WTO PARM LIST     C\n               $HASPEQU,               REQ'D FOR REG CONVENTIONS       C\n               $HCT,                   REQ'D BY $SAVE, $RETURN, ETC.   C\n               $JCT,                   REQ'D TO GET JOBNAME, ETC.      C\n               $JQE,                   REQ'D BY HCT                    C\n               $MIT,                   REQ'D BY $MODEND, HCT           C\n               $PCE                    REQ'D TO GET PROCESSOR INFO\n*              IEFSSJT ,               REQ'D TO GET JCTJFLG EQUATES  TL\n*              IEFJSSOB CS ,           REQ'D FOR IEFSSJT             TL\n         TITLE 'WFB - EXIT 016 - MAX COND CODE/ABEND CODE SUPPORT'\n***********************************************************************\n*                                                                     *\n*  INITIALIZATION                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE  1\nUEXIT016 $ENTRY BASE=R12               EXIT ROUTINE ENTRY POINT\n         SPACE  2\n        $SAVE                          SAVE CALLER'S REGISTERS\n         LR    R12,R15                 LOAD LOCAL BASE REGISTER\n         L     R10,8(R1)               LOAD JCT ADDRESS\n         USING JCT,R10                 ESTABLISH ADDRESSABILITY\n         SLR   R15,R15                 SET DEFAULT RETURN CODE\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*  CHECK TO SEE IF JOB'S ABEND CODE OR MAXIMUM CONDITION CODE HAS     *\n*  BEEN SAVED.  IF NOT, RETURN.                                       *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         CLI   JCTUSER1,X'80'          IS JOB'S ABEND/MAX CC SAVED?\n         BNE   RETURN                  NO, RETURN\n*        CLI   JCTJTFLG,SSJTJFAL       IS MESSAGE TO BE ALTERED?   TL\n         CLI   JCTJTFLG,JOBFAIL        IS MESSAGE TO BE ALTERED?   TL\n         BE    RETURN                  NO, SKIP\n         EJECT\n***********************************************************************\n*                                                                     *\n*  PREPARE TO ALTER THE NOTIFY MESSAGE.                               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         L     R4,4(R1)                GET ADDRESS OF $WTO PARM LIST\n         USING CMBWTOPL,R4             ESTABLISH $CMD ADDRESSABILITY\n         SLR   R5,R5                   ZERO WORK REGISTER\n         IC    R5,CMBML                GET MESSAGE LENGTH\n         CH    R5,=H'68'               MSG TOO LONG TO UPDATE IN PLACE?\n         BH    RETURN                  YES, RETURN (SHOULDN'T HAPPEN)\n         L     R6,0(R1)                GET ADDRESS IF MESSAGE TEXT\n         AR    R6,R5                   POINT PAST EXISTING MESSAGE TEXT\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*  CHECK TO SEE IF THE JOB ABENDED.  IF IT DID, GET THE ABEND CODE.   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n*        TM    JCTJTFLG,SSJTABND       DID JOB ABEND?               TL\n         TM    JCTJTFLG,JOBABND        DID JOB ABEND?               TL\n         BZ    MAXCONDC                NO, GO GET MAXIMUM COND CODE\n         SPACE 1\n         L     R2,JCTUSER1             GET ABEND CODE\n         LA    R2,0(R2)                CLEAR HIGH ORDER BYTE\n         SRL   R2,12                   OBTAIN SYSTEM CODE\n         LTR   R2,R2                   WAS IT A SYSTEM CODE ABEND?\n         BZ    USRABEND                NO, GO PROCESS USER CODE ABEND\n         EJECT\n***********************************************************************\n*                                                                     *\n*  IF THE JOB ABENDED WITH A SYSTEM ABEND CODE, COME HERE TO ALTER    *\n*  THE NOTIFY MESSAGE TO INCLUDE THE SYSTEM ABEND CODE.               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nSYSABEND DS    0H\n         LA    R5,10(R5)               INCR. MSG LENGTH\n         MVC   0(10,R6),=C'SYSTEM XXX' ADD SYSTEM ABEND CODE TO MSG\n         SRDL  R2,12                   CONVERT IT TO HEX\n         SR    R2,R2                          \"\n         SLDL  R2,4                           \"\n         IC    R2,CONVTABL(R2)                \"\n         STC   R2,7(R6)                       \"\n         SR    R2,R2                          \"\n         SLDL  R2,4                           \"\n         IC    R2,CONVTABL(R2)                \"\n         STC   R2,8(R6)                       \"\n         SR    R2,R2                          \"\n         SLDL  R2,4                           \"\n         IC    R2,CONVTABL(R2)                \"\n         STC   R2,9(R6)                       \"\n         B     STORELEN                GO CHECK NEW MESSAGE LENGTH\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*  IF THE JOB ABENDED WITH A USER ABEND CODE, COME HERE TO ALTER THE  *\n*  NOTIFY MESSAGE TO INCLUDE THE USER ABEND CODE.                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nUSRABEND DS    0H\n         LA    R5,9(R5)                INCR. MSG LENGTH\n         MVC   0(9,R6),=C'USER XXXX'   ADD USER ABEND CODE TO MSG\n         LH    R2,JCTUSER1+2           GET USER ABEND CODE\n         CVD   R2,5(R6)                CONVERT TO DECIMAL\n         UNPK  5(4,R6),5(8,R6)         UNPK FOUR LOW DIGITS\n         OI    8(R6),X'F0'             SET ZONE\n         MVC   9(2,R6),=C'  '          CLEAR TWO  BYTES\n         B     STORELEN                GO CONVERT TO DEC/PRINTABLE\n         EJECT\n***********************************************************************\n*                                                                     *\n*  IF THE JOB ENDED NORMALLY, COME HERE TO ALTER THE NOTIFY MESSAGE   *\n*  TO INCLUDE THE MAXIMUM CONDITION CODE FOR ANY STEP IN THE JOB.     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nMAXCONDC DS    0H\n         MVC   0(20,R6),=C'- MAX COND CODE XXXX'  ADD MAXCC TO MSG\n         LA    R5,20(R5)               INCR. MESSAGE LENGTH\n         LH    R2,JCTUSER1+2           GET MAX CONDITION CODE\n         CVD   R2,16(R6)               CONVERT TO DECIMAL\n         UNPK  16(4,R6),16(8,R6)       UNPK FOUR LOW DIGITS\n         OI    19(R6),X'F0'            SET ZONE\n         MVC   20(2,R6),=C'  '         CLEAR TWO  BYTES\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*  STORE NEW MESSAGE LENGTH IN CMB PARM LIST.                         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nSTORELEN DS    0H\n         STC   R5,CMBML                STORE MSG LEN IN CMB PARM LIST\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*  GO BYE-BYE.                                                        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nRETURN   DS    0H\n        $RETURN RC=(R15)               RETURN TO CALLER\n         EJECT\nCONVTABL DC    CL16'0123456789ABCDEF'  CONVERSION TABLE\nJOBFAIL  EQU   X'80'                                                TL\nJOBABND  EQU   X'20'                                                TL\n         LTORG\n        $MODEND\n         END\nEXIT252  TITLE 'WFB - EXIT 252 - MAX COND CODE/ABEND CODE SUPPORT'\n***********************************************************************\n*                                                                     *\n* MODULE NAME: EXIT252                                                *\n*                                                                     *\n* DESCRIPTIVE NAME: JES2 EXIT 252 - MAX COND CODE/ABEND CODE SUPPORT  *\n*                                                                     *\n* AUTHOR: VIC COZZOLI                                                 *\n*         WELLS FARGO BANK, N.A. (WFB)                                *\n*         525 MARKET STREET, A.U. 8513                                *\n*         SAN FRANCISCO, CALIFORNIA  94163                            *\n*                                                                     *\n*         PHONE: (415) 396-6376                                       *\n*                                                                     *\n*                                                                     *\n* DATE WRITTEN: NOVEMBER 1983                                         *\n*                                                                     *\n* FMID: HJE2329 (MVS/SP-JES2 1.3.3)                                   *\n*                                                                     *\n* PURPOSE: THIS EXIT PLACES OBTAINS AND STORES IN THE JCT EITHER      *\n*          THE MAXIMUM CONDITON CODE OF ALL THE STEPS IN A JOB OR     *\n*          THE ABEND CODE OF THE JOB.                                 *\n*                                                                     *\n* INVOCATION POINT: EXIT008                                           *\n*                                                                     *\n* ENTRY POINT: UEXIT252                                               *\n*                                                                     *\n* REGISTERS ON INPUT:                                                 *\n*     R0: CODE PASSED BY JES2                                         *\n*         =0, INDICATES THAT THE JCT HAS BEEN READ FROM SPOOL         *\n*         =4, INDICATES THAT THE JCT WILL BE WRITTEN TO SPOOL         *\n*     R1: ADDRESS OF THE JCT                                          *\n*     R2-R10: N/A                                                     *\n*     R11: ADDRESS OF THE SSVT                                        *\n*     R12: N/A                                                        *\n*     R13: ADDRESS OF AN OS-STYLE SAVE AREA                           *\n*     R14: RETURN ADDRESS                                             *\n*     R15: ENTRY ADDRESS                                              *\n*                                                                     *\n* REGISTERS ON RETURN:                                                *\n*     R0-R1: N/A                                                      *\n*     R15: A RETURN CODE:                                             *\n*          =0, CONTINUE NORMAL EXIT OR JES2 PROCESSING                *\n*          =4, IGNORE ANY OTHER EXITS AND CONTINUE WITH NORMAL        *\n*              PROCESSING                                             *\n*                                                                     *\n* JES2 MACROS USED:                                                   *\n*     $ENTRY, $MODEND                                                 *\n*                                                                     *\n***********************************************************************\n         EJECT\n         COPY $HASPGBL                 COPY HASP GLOBALS\n         EJECT\nJ2XIT252 $MODULE ENVIRON=USER,                                         C\n               SSOB,                   REQ'D TO DETERMINE INVOKER      C\n               $BUFFER,                REQ'D BY JCT                    C\n               $HASPEQU,               REQ'D FOR REG CONVENTIONS       C\n               $JCT,                   REQ'D TO SAVE ABEND/COND CODE   C\n               $MIT,                   REQ'D BY $MODEND, HCT           C\n               $SCAT,                  REQ'D BY $SVT                   C\n               $SJB,                   REQ'D TO DETERMINE INVOKER      C\n               $SVT,                   REQ'D TO DETERMINE INVOKER      C\n               $XECB                   REQ'D BY $SVT\n         TITLE 'WFB - EXIT 252 - MAX COND CODE/ABEND CODE SUPPORT'\n***********************************************************************\n*                                                                     *\n*  INITIALIZATION                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nUEXIT252 $ENTRY BASE=R12               EXIT ROUTINE ENTRY POINT\n         SPACE 3\n         STM   R14,R12,12(R13)         SAVE CALLER'S REGISTERS\n         LR    R12,R15                 LOAD LOCAL BASE REGISTER\n         LR    R10,R1                  GET ADDRESS OF JCT\n         SLR   R15,R15                 SET DEFAULT RETURN CODE\n         EJECT\n***********************************************************************\n*                                                                     *\n*  CHECK TO SEE IF THERE IS A JCT , IF IT IS FOR A BATCH JOB AND      *\n*  IF NOTIFY WAS REQUESTED.  IF NOT, RETURN.                          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         LTR   R0,R0                   IS JCT BEING READ?\n         BZ    RETURN                  YES, RETURN\n         SPACE 1\n         CLI   JCTJOBID,C'J'           IS THIS A BATCH JOB?\n         BNE   RETURN                  NO, RETURN\n         SPACE 1\n         CLI   JCTTSUID,C' '           WAS NOTIFY REQUESTED?\n         BE    RETURN                  NO, RETURN\n         SPACE 1\n         TM    JCTJBOPT,JCTXBACH       IS THIS AN EXECUTION BATCH      C\n                                         MONITOR?\n         BO    RETURN                  YES, RETURN\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*  FIND THE SJB ON THE JOBS EXECUTING BY CLASS QUEUE THAT BELONGS TO  *\n*  THIS JOB'S JCT.  IF THE SJB INDICATES THE JOB IS NOT IN            *\n*  TERMINATION, THEN RETURN.                                          *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         USING $SVDSECT,R11            PROVIDE SSVT ADDRESSABILITY\n         SPACE 1\n         L     R2,$SVJXCLS             GET EXECUTING SJB'S QUEUE\n         USING SJBDSECT,R2             PROVIDE SJB ADDRESSABILITY\nGETSJB   DS    0H\n         LTR   R2,R2                   TEST FOR END OF QUEUE\n         BZ    RETURN                  RETURN IF NO MATCH\n         CLC   JCTJOBID(8),SJBJOBID    IS THIS THE SJB FOR THIS JCT?\n         BE    FOUNDSJB                YES, PROCESS IT\n         L     R2,SJBXQCHN             GET POINTER TO NEXT SJB\n         B     GETSJB                  LOOP BACK THRU\n         SPACE 1\nFOUNDSJB DS    0H\n         CLI   SJBXQFN1+1,SSOBTERM     WAS EXIT INVOKED BY JOB         C\n                                         TERMINATION (HOSTERM)?\n         BNE   RETURN                  NO, RETURN\n         EJECT\n***********************************************************************\n*                                                                     *\n*  FIND THE OS JCT FOR THIS JOB AND CHECK TO SEE IF THE JOB ABENDED.  *\n*  IF IT DID ABEND, GET THE ABEND CODE.                               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nGETCVT   EQU   *\n         L     R2,CVTPTR               LOAD ADDR OF CVT POINTER\n         L     R2,0(R2)                LOAD ADDR OF NEXT/CURR TCB'S\n         L     R2,OURTCB(R2)           LOAD ADDR OF OUR TCB\n         L     R2,TCBJSCB(R2)          LOAD ADDR OF JSCB\n         L     R2,JSCBACT(R2)          LOAD ADDR OF ACTIVE JSCB\n         L     R2,JSCBJCT(R2)          LOAD ADDR OF OS JCT\n         USING INJMJCT-16,R2           ESTABLISH OS JCT ADDRESSABILITY\n         SPACE 1\n         TM    JCTJSTAT,JCTABEND       DID JOB ABEND?\n         BNO   GETMAXCC                NO, GET MAXIMUM CONDITION CODE\n         L     R3,JCTACODE             YES, GET ABEND CODE\n         B     SAVECODE                GO TO SAVE IT\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*  IF THE JOB DID NOT ABEND, THEN SCAN THE SCT'S FOR THE JOB AND      *\n*  FIND THE MAXIMUM CONDITION CODE OUT OF ALL THE JOB'S STEPS.        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nGETMAXCC DS    0H\n         L     R2,JCTSDKAD             GET FIRST SCT ADDRESS\n         USING INSMSCT-16,R2           ESTABLISH SCT ADDRESSABILITY\n         SPACE 1\n         SLR   R3,R3                   ZERO OUT WORK REGISTER\n         SPACE 1\nSCTLOOP  DS    0H\n         SRL   R2,8                    GET ADDRESS IN PROPER FORM\n         LTR   R2,R2                   ARE THERE ANY MORE SCT'S?\n         BZ    SAVECODE                NO, GO TO FINISH\n         TM    SCTSTEND,SCTSTRUN       DID STEP RUN?\n         BNO   NEXTSCT                 NO, GET NEXT SCT\n         CH    R3,SCTSEXEC             IS THIS STEP'S CONDITION CODE   C\n                                         GREATER THAN THE MAXIMUM?\n         BNL   NEXTSCT                 NO, GET NEXT SCT\n         LH    R3,SCTSEXEC             YES, SAVE NEW MAX COND CODE\nNEXTSCT  DS    0H\n         L     R2,SCTANSCT             GET NEXT SCT\n         B     SCTLOOP                 LOOP TO CHECK NEXT SCT\n         EJECT\n***********************************************************************\n*                                                                     *\n*  SAVE EITHER THE ABEND CODE OR THE MAXIMUM CONDITION CODE FOR       *\n*  ANY STEP OF THE JOB IN A JCT USER FIELD.  THIS INFORMATION WILL    *\n*  BE USED LATER IN EXIT016 - TSO NOTIFY.                             *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nSAVECODE DS    0H\n         ST    R3,JCTUSER1             SAVE ABEND/MAX COND CODE\n         MVI   JCTUSER1,X'80'          MARK IT AS PROCESSED\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*  GO BYE-BYE.                                                        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nRETURN   DS    0H\n         L     R14,12(R13)             LOAD RETURN ADDRESS\n         LM    R0,R12,20(R13)          RESTORE REGISTERS\n         BR    R14                     RETURN\n         EJECT\nPATCH    DS    CL200\n         DC    CL8'ENDPATCH'\nCVTPTR   EQU   X'10'         ADDRESS OF CVT POINTER\nOURTCB   EQU   X'04'         OFFSET INTO TCB LIST OF OUR TCB ADDRESS\nTCBJSCB  EQU   X'B4'         OFFSET INTO TCB OF JSCB ADDRESS\nJSCBACT  EQU   X'15C'        OFFSET INTO JSCB OF ACTIVE JSCB ADDRESS\nJSCBJCT  EQU   X'104'        OFFSET INTO ACTIVE JSCB OF OS JCT ADDRESS\n         SPACE 3\nJCTDSCT  DSECT\n*        THIS CONTROL BLOCK IS A COPY OF OS JCT DEFINING\n*        ONLY THOSE FIELDS USED BY THIS MOD.  THE OS JCT,\n*        IEFAJCTB, CONTAINS DUPLICATE FIELD NAMES OF THOSE\n*        USED BY THE JES2 JCT (JCTID, JCTJNAM, AND JCTJMR)\n*        AND CAUSES ASSEMBLY ERRORS IF IT USED.\nINJMJCT  EQU    *\n         DS     CL5                    FILLER\nJCTJSTAT DS     1C                     JOB STATUS INDICATORS\nJCTABEND EQU    8                      BIT 4 - JCT ABEND BIT\n         DS     CL26                   FILLER\nJCTSDKAD DS     CL4                    DISK ADDRESS OF FIRST SCT\n         DS     CL132                  FILLER\nJCTACODE DS     CL4                    ABEND CODE FIELD\n         EJECT\n         PUSH   PRINT\n         PRINT  NOGEN\nSCTDSCT  DSECT\n         IEFASCTB\nSCTSTEND EQU    INSMSCT+X'AC'          BITS AND PIECES\nSCTSTRUN EQU    X'C0'                  STEP STARTED/ENDED BIT\n         POP    PRINT\nJ2XIT252 CSECT\n         SPACE  3\n         LTORG\n        $MODEND\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MVSVARS": {"ttr": 2052, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00E\\x01\\x13\"o\\x01\\x13\"o\\x175\\x00%\\x00%\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-08-14T00:00:00", "modifydate": "2013-08-14T17:35:45", "lines": 37, "newlines": 37, "modlines": 0, "user": "SBGOLOB"}, "text": "In a message dated 11/14/2007 8:34:48 AM US Mountain Standard\nTime, gilmap@unix.stortek.com writes:\n\n(Wouldn't it be nice if ...  the BPXWDYN interface converted JCL\nsymbols to environment variables.)\n\nSubject:  Re: Ref. : Re: \u00ddMVS-OE\u00a8 Visibility of DDNAMES to BPXBATCH\nFrom:     Robert Zenuk <Robzenuk@aol.com>\nDate:     11/15/2007 12:54 PM\n\nThe only symbols available to JCL are the System Symbols\n(IEASYMxx) and unless it is an STC, the list is very limited for\ntrue batch.  PROC symbolics do not seem to apply here.  However,\nyou could do this little trick to seed your environment variables\nwith the symbol names and values.\n\nMVSVARS.REX\n\n/* rexx */\narg  var\nsay  mvsvar(var)\n\nVARS.SH\n\n#!/bin/sh\nSYSNAME='mvsvars.rex SYSNAME'\nexport  SYSNAME\nSYSCLONE='mvsvars.rex SYSCLONE'\nexport  SYSCLONE\nSYSPLEX='mvsvars.rex SYSPLEX'\nexport  SYSPLEX\n\nBy \"dotting in\" the VARS.SH script in your .profile or wherever\nnecessary, you can seed these values in your environment.\n\nRob\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NOTE": {"ttr": 2054, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87(\\x7f\\x00\\x87(\\x7f\\x12\\x00\\x01\\xdc\\x01\\xdc\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-10-14T00:00:00", "modifydate": "1987-10-14T12:00:00", "lines": 476, "newlines": 476, "modlines": 0, "user": "FILE325"}, "text": "PROC 0 PROLOG(YES) EPILOG(YES) COPYLIST(YES) PROFNODE(EMINFO) DEBUG\n/*--------------------------------------------------------------------*/\n/*  WRITTEN BY: Sam Lepore, Wells Fargo Bank, San Francisco CA  1/86  */\n/*--------------------------------------------------------------------*/\nIF &DEBUG = DEBUG THEN +\n  CONTROL SYMLIST CONLIST LIST      /* Turn on debugging\nCONTROL NOCAPS                      /* Allow lower case messages\nSET &MAXNICK = 15                   /* Panel defines 15 nicknames\nSET &COUNT = 0\nDO WHILE &COUNT < &MAXNICK          /* Loop through all entries\n  SET &COUNT = &COUNT + 1\n  SET &NICK&COUNT = &STR()          /* Initialize to null\n  END\nSET &SUBJECT = NO SUBJECT           /* Default to NO SUBJECT\nSET &OPTION = E                     /* First option is to edit message\nISPEXEC DISPLAY PANEL(WFBNOTE)\nSET &CC = &LASTCC                   /* Save CC for error messages\nIF &CC > 8 THEN DO                  /* 0 = enter, 4 = end/return pressed\n  WRITE =====> ERROR: Reurun code from ISPEXEC DISPLAY PANEL is &CC\n  EXIT\n  END\nIF &OPTION = C THEN +\n  EXIT                              /* Cancel requested\n/*--------------------------------------------------------------------*/\n/*  Allocate and open VIO dataset for message.                        */\n/*--------------------------------------------------------------------*/\nALLOC DD(PDFTEMP&SCREEN) REUSE UNIT(VIO) TRACK SPACE(1) +\n                  DSORG(PS) RECFM(F B) LRECL(80) BLKSIZE(9040)\nCONTROL NOFLUSH                     /* Protect ERROR routine from flush\nOPENFILE PDFTEMP&SCREEN OUTPUT      /* Open the message file\nSET &NAMETEXT = NOTALLOC            /* NAMES.TEXT not (yet) allocated\n/*--------------------------------------------------------------------*/\n/*  Process PROLOG from NAMES.TEXT dataset.                           */\n/*--------------------------------------------------------------------*/\nIF &SUBSTR(1,&PROLOG ) = Y THEN DO  /* PROLOG processing requested\n  SET &PROLOG = NONE                /* Default in case none found\n  ALLOC DD(NAMETEXT) REUSE DSN(NAMES.TEXT) SHR\n  IF &LASTCC \u00ac= 0 THEN DO\n    WRITE Dataset NAMES.TEXT could not be allocated +\n          to process PROLOG/EPILOG.\n    WRITE ===> WARNING: Nicknames are also resolved using NAMES.TEXT.\n    WRITE               To avoid errors, specify only node.userid +\n                        on \"to\" panel.\n    SET &EPILOG = NONE              /* Prevent EPILOG processing\n    GOTO PUTSUB                     /* Go put subject into message\n    END\n  SET &SYSOUTTRAP = 10              /* Trap enough to catch LISTD info\n  LISTD NAMES.TEXT\n  SET &SYSOUTTRAP = 0               /* Turn off trapping\n  SET &RECFM = &SUBSTR(3,&SYSOUTLINE3   )  /* Save record format\n  IF &RECFM = R THEN +\n    SET &RECFM = &SUBSTR(3,&SYSOUTLINE4   )  /* Use line 4 if LIST is on\n  ERROR DO\n    CLOSFILE NAMETEXT               /* Error 400 is normal end of file\n    SET &NAMETEXT = CLOSED          /* Show NAMES.TEXT is allocated\n    GOTO PUTSUB                     /* Go put subject into message\n    END\n  OPENFILE NAMETEXT\n  GETFILE NAMETEXT\n  SET &TEXTLEN = &LENGTH(&NRSTR(&NAMETEXT))  /* Maximum length for loop\n  SET &FIRSTCOL = 1                 /* Default to column 1\n  IF &RECFM = V AND &DATATYPE(&SUBSTR(1:8,&NRSTR(&NAMETEXT)        )) +\n   = NUM THEN +\n    SET &FIRSTCOL = 9               /* V, NUM - First data column is 9\n  SET &ADJUST = 0                   /* Default to no adjustment\n  IF &RECFM = F +\n   AND &DATATYPE(&SUBSTR(&TEXTLEN-7:&TEXTLEN,&NRSTR(&NAMETEXT))) +\n   = NUM THEN +\n      SET &ADJUST = 8               /* F, NUM - Last data col is max-8\n  GOTO PROLOOP                      /* Enter PROLOG loop\n  GETPRO: GETFILE NAMETEXT\n  SET &TEXTLEN = &LENGTH(&NRSTR(&NAMETEXT))  /* Maximum length for loop\n  PROLOOP: SET &LASTCOL = &TEXTLEN - &ADJUST  /* Refigure in case REC V\n  IF &STR(&SYSCAPS(&SUBSTR(&FIRSTCOL:&FIRSTCOL+5,+\n   &NRSTR(&NAMETEXT)              ))) = :NICK. THEN DO\n    CLOSFILE NAMETEXT               /* 1st nickname ends control section\n    SET &NAMETEXT = CLOSED          /* Show NAMES.TEXT is allocated\n    GOTO PUTSUB                     /* Go put subject into message\n    END\n  IF &LASTCOL - &FIRSTCOL < 7 THEN +\n    GOTO GETPRO                     /* Ignore short records\n  IF &STR(&SYSCAPS(&SUBSTR(&FIRSTCOL:&FIRSTCOL+7,+\n   &NRSTR(&NAMETEXT)                ))) = :PROLOG. THEN DO\n    SET &PROLOG = DONE              /* Show DONE on panel option\n    IF &LASTCOL = &FIRSTCOL + 7 THEN +\n      SET &PDFTEMP&SCREEN = &STR( ) /* Put blank line in message\n    ELSE +\n      SET &PDFTEMP&SCREEN = &SUBSTR(&FIRSTCOL+8:&LASTCOL,+\n                                    &NRSTR(&NAMETEXT))\n    PUTFILE PDFTEMP&SCREEN\n    GOTO GETPRO                     /* See if more :PROFILE. lines\n    END\n  GOTO GETPRO                       /* See if more :PROFILE. lines\n  END\n/*--------------------------------------------------------------------*/\n/*  Add SUBJECT to edit dataset.                                      */\n/*--------------------------------------------------------------------*/\nPUTSUB: ERROR OFF\nSET &PDFTEMP&SCREEN = SUBJECT: &NRSTR(&SUBJECT)\nPUTFILE PDFTEMP&SCREEN\nSET &PDFTEMP&SCREEN = &STR( )       /* Put blank line following subject\nPUTFILE PDFTEMP&SCREEN\n/*--------------------------------------------------------------------*/\n/*  Process EPILOG from NAMES.TEXT dataset.                           */\n/*--------------------------------------------------------------------*/\nIF &SUBSTR(1,&EPILOG ) = Y THEN DO  /* EPILOG processing requested\n  SET &EPILOG = NONE                /* Default in case none found\n  IF &NAMETEXT = NOTALLOC THEN DO\n    ALLOC DD(NAMETEXT) REUSE DSN(NAMES.TEXT) SHR\n    IF &LASTCC \u00ac= 0 THEN DO\n      WRITE Dataset NAMES.TEXT could not be allocated to process EPILOG.\n      WRITE ===> WARNING: Nicknames are also resolved using NAMES.TEXT.\n      WRITE               To avoid errors, specify only node.userid +\n                          on \"to\" panel.\n      GOTO EDITNOTE                 /* Go edit the message\n      END\n    END\n  IF &FIRSTCOL > 0 THEN +\n    GOTO EPIOPEN                    /* Use previously calculated value\n  SET &SYSOUTTRAP = 10              /* Trap enough to catch LISTD info\n  LISTD NAMES.TEXT\n  SET &SYSOUTTRAP = 0               /* Turn off trapping\n  SET &RECFM = &SUBSTR(3,&SYSOUTLINE3   )  /* Save record format\n  IF &RECFM = R THEN +\n    SET &RECFM = &SUBSTR(3,&SYSOUTLINE4   )  /* Use line 4 if LIST is on\n  ERROR DO\n    CLOSFILE NAMETEXT               /* Error 400 is normal end of file\n    SET &NAMETEXT = CLOSED          /* Show NAMES.TEXT is allocated\n    GOTO EDITNOTE                   /* Go edit the message\n    END\n  OPENFILE NAMETEXT\n  GETFILE NAMETEXT\n  SET &TEXTLEN = &LENGTH(&NRSTR(&NAMETEXT))  /* Maximum length for loop\n  SET &FIRSTCOL = 1                 /* Default to column 1\n  IF &RECFM = V AND &DATATYPE(&SUBSTR(1:8,&NRSTR(&NAMETEXT)        )) +\n   = NUM THEN +\n    SET &FIRSTCOL = 9               /* V, NUM - First data column is 9\n  SET &ADJUST = 0                   /* Default to no adjustment\n  IF &RECFM = F AND &DATATYPE(&SUBSTR(&TEXTLEN-7:&TEXTLEN,+\n   &NRSTR(&NAMETEXT))) = NUM THEN +\n      SET &ADJUST = 8               /* F, NUM - Last data col is max-8\n  GOTO EPILOOP                      /* Enter EPILOG loop\n  EPIOPEN: ERROR DO\n    CLOSFILE NAMETEXT               /* Error 400 is normal end of file\n    SET &NAMETEXT = CLOSED          /* Show NAMES.TEXT is allocated\n    GOTO EDITNOTE                   /* Go edit the message\n    END\n  OPENFILE NAMETEXT\n  GETEPI: GETFILE NAMETEXT\n  SET &TEXTLEN = &LENGTH(&NRSTR(&NAMETEXT))  /* Maximum length for loop\n  EPILOOP: SET &LASTCOL = &TEXTLEN - &ADJUST  /* Refigure in case REC V\n  IF &STR(&SYSCAPS(&SUBSTR(&FIRSTCOL:&FIRSTCOL+5,+\n   &NRSTR(&NAMETEXT)              ))) = :NICK. THEN DO\n    CLOSFILE NAMETEXT               /* 1st nickname ends control section\n    SET &NAMETEXT = CLOSED          /* Show NAMES.TEXT is allocated\n    GOTO EDITNOTE                   /* Go edit the message\n    END\n  IF &LASTCOL - &FIRSTCOL < 7 THEN +\n    GOTO GETEPI                     /* Ignore short records\n  IF &STR(&SYSCAPS(&SUBSTR(&FIRSTCOL:&FIRSTCOL+7,\n   &NRSTR(&NAMETEXT)                ))) = :EPILOG. THEN DO\n    SET &EPILOG = DONE              /* Show DONE on panel option\n    IF &LASTCOL = &FIRSTCOL + 7 THEN +\n      SET &PDFTEMP&SCREEN = &STR( ) /* Put blank line in message\n    ELSE +\n      SET &PDFTEMP&SCREEN = &SUBSTR(&FIRSTCOL+8:&LASTCOL,+\n                                    &NRSTR(&NAMETEXT))\n    PUTFILE PDFTEMP&SCREEN\n    GOTO GETEPI                     /* See if more :PROFILE. lines\n    END\n  GOTO GETEPI                       /* See if more :PROFILE. lines\n  END\n/*--------------------------------------------------------------------*/\n/*  Initialize for PDF EDIT, call with edit macro to insert lines.    */\n/*--------------------------------------------------------------------*/\nEDITNOTE: ERROR OFF                 /* Turn off NAMETEXT error routine\nCLOSFILE PDFTEMP&SCREEN             /* Close message file before edit\nISPEXEC LMINIT DATAID(DATAID) DDNAME(PDFTEMP&SCREEN)  /* Initialize ISPF\nIF &LASTCC \u00ac= 0 THEN DO\n  WRITE =====> ERROR: Unable to establish PDF interface.\n  EXIT\n  END\nSET &TYPECALL = INITIALIZE          /* Set for edit macro initialization\nVPUTTYPE: ISPEXEC VPUT TYPECALL     /* Save variable in ISPF shared pool\nISPEXEC EDIT DATAID(&DATAID) MACRO(NOTEIMAC) PROFILE(NOTE)\n/*--------------------------------------------------------------------*/\n/*  Redisplay options panel to allow for add/change of userids.       */\n/*--------------------------------------------------------------------*/\nSET &SUBMSG = Note: Any change to the subject will cause EDIT +\n              to be reinvoked.\nSET &OLDSUB = &NRSTR(&SUBJECT)      /* Save subject for later compare\nSET &OPTION = M                     /* Set option to mail the message\nSET &MAILMSG = &STR( M to mail,)    /* Explain M option on panel\nISPEXEC DISPLAY PANEL(WFBNOTE)\nSET &CC = &LASTCC                   /* Save CC for error messages\nIF &CC > 8 THEN DO                  /* 0 = enter, 4 = end/return pressed\n  WRITE =====> ERROR: Reurun code from ISPEXEC DISPLAY PANEL is &CC\n  GOTO LMFREE                       /* Go free ISPF resources\n  END\nIF &OPTION = E THEN DO\n  SET &TYPECALL = REEDIT            /* Set for re-edit of message\n  GOTO VPUTTYPE                     /* Save variable in ISPF shared pool\n  END\nIF &NRSTR(&OLDSUB) \u00ac= &NRSTR(&SUBJECT) THEN DO\n  ISPEXEC VPUT SUBJECT              /* Save variable in ISPF shared pool\n  SET &TYPECALL = SUBCHANGE         /* Set for change subject and reedit\n  GOTO VPUTTYPE                     /* Go reinvoke edit\n  END\nIF &OPTION = C THEN +\n  GOTO LMFREE                       /* Go free ISPF resources\n/*--------------------------------------------------------------------*/\n/*  Resolve nicknames into node.userid. Identify nickname, open file. */\n/*--------------------------------------------------------------------*/\nSET &NICK = &STR(&&NICK)  /* Required for double symbolic substitution.\nSET &COUNT = 0\nSET &LIST = &MAXNICK + 1            /* Start saving lists at max + 1\nDO WHILE &COUNT < &MAXNICK          /* Loop through all entries\n  SET &COUNT = &COUNT + 1\n  SET &NICKLEN = &LENGTH(&NICK&COUNT)  /* Length of entry is 1-17 chars\n  IF &NICK&COUNT = &STR() OR &NICKLEN > 8 THEN +\n    GOTO NEXTNICK                   /* Max for true nickname is 1-8\n  SET &COL = 1                      /* Start col 2, min node.user is a.b\n  DO WHILE &COL < &NICKLEN          /* Look for period in node.user\n    SET &COL = &COL + 1\n    IF &SUBSTR(&COL,&NICK&COUNT) = &STR(.) THEN +\n      GOTO NEXTNICK                 /* Found, so entry is not nickname\n    END\n  IF &NAMETEXT \u00ac= CLOSED THEN DO    /* No period, so entry is nickname\n    IF &NAMETEXT = NOTEXIST THEN DO\n      SET &NICK&COUNT = &STR()      /* Null nickname to prevent error\n      GOTO NEXTNICK                 /* Go process next nickname\n      END\n    ALLOC DD(NAMETEXT) REUSE DSN(NAMES.TEXT) SHR\n    IF &LASTCC \u00ac= 0 THEN DO\n      WRITE Dataset NAMES.TEXT could not be allocated +\n            to process nickname &NICK&COUNT\n      WRITE Node.userid entries will be processed, +\n            but other nicknames will be ignored.\n      SET &NAMETEXT = NOTEXIST      /* Prevent future allocation attempt\n      SET &NICK&COUNT = &STR()      /* Null nickname to prevent error\n      GOTO NEXTNICK                 /* Go process next nickname\n      END\n    END\n  IF &FIRSTCOL > 0 THEN +\n    GOTO NICKOPEN                   /* Use previously calculated value\n  SET &SYSOUTTRAP = 10              /* Trap enough to catch LISTD info\n  LISTD NAMES.TEXT\n  SET &SYSOUTTRAP = 0               /* Turn off trapping\n  SET &RECFM = &SUBSTR(3,&SYSOUTLINE3   )  /* Save record format\n  IF &RECFM = R THEN +\n    SET &RECFM = &SUBSTR(3,&SYSOUTLINE4   )  /* Use line 4 if LIST is on\n  ERROR DO\n    CLOSFILE NAMETEXT               /* Error 400 is normal end of file\n    SET &NAMETEXT = CLOSED          /* Show NAMES.TEXT is allocated\n    WRITE ===> WARNING: Nickname &NICK&COUNT not found in NAMES.TEXT .\n    WRITENR ???? Enter another nickname, or just press enter to ignore:\n    READ\n    DO WHILE &NRSTR(&SYSDVAL) \u00ac= &STR() AND &LENGTH(&NRSTR(&SYSDVAL)) +\n     > 8\n      WRITENR ???? Maximum length for nickname is 8 characters, reenter:\n      READ\n      END\n    IF &NRSTR(&SYSDVAL) = &STR() THEN DO\n      SET &NICK&COUNT = &STR()      /* Null nickname to prevent error\n      GOTO NEXTNICK                 /* Go process next nickname\n      END\n    SET &NICK&COUNT = &STR(&SYSCAPS(&NRSTR(&SYSDVAL)))  /* New nickname\n    GOTO NICKOPEN                   /* Try new nickname\n    END\n  OPENFILE NAMETEXT\n  GETFILE NAMETEXT\n  SET &TEXTLEN = &LENGTH(&NRSTR(&NAMETEXT))  /* Maximum length for loop\n  SET &FIRSTCOL = 1                 /* Default to column 1\n  IF &RECFM = V AND &DATATYPE(&SUBSTR(1:8,&NRSTR(&NAMETEXT)        )) +\n   = NUM THEN +\n    SET &FIRSTCOL = 9               /* V, NUM - First data column is 9\n  SET &ADJUST = 0                   /* Default to no adjustment\n  IF &RECFM = F +\n   AND &DATATYPE(&SUBSTR(&TEXTLEN-7:&TEXTLEN,&NRSTR(&NAMETEXT))) +\n   = NUM THEN +\n      SET &ADJUST = 8               /* F, NUM - Last data col is max-8\n  GOTO NICKLOOP                     /* Enter nickname loop\n  NICKOPEN: ERROR DO\n    CLOSFILE NAMETEXT               /* Error 400 is normal end of file\n    SET &NAMETEXT = CLOSED          /* Show NAMES.TEXT is allocated\n    WRITE ===> WARNING: Nickname &NICK&COUNT not found in NAMES.TEXT .\n    WRITENR ???? Enter another nickname, or just press enter to ignore:\n    READ\n    DO WHILE &NRSTR(&SYSDVAL) \u00ac= &STR() AND &LENGTH(&NRSTR(&SYSDVAL)) +\n     > 8\n      WRITENR ???? Maximum length for nickname is 8 characters, reenter:\n      READ\n      END\n    IF &NRSTR(&SYSDVAL) = &STR() THEN DO\n      SET &NICK&COUNT = &STR()      /* Null nickname to prevent error\n      GOTO NEXTNICK                 /* Go process next nickname\n      END\n    SET &NICK&COUNT = &STR(&SYSCAPS(&NRSTR(&SYSDVAL)))  /* New nickname\n    GOTO NICKOPEN                   /* Try new nickname\n    END\n  OPENFILE NAMETEXT\n/*--------------------------------------------------------------------*/\n/*  Resolve nicknames into node.userid. Read :NICK, find :NODE :USER. */\n/*--------------------------------------------------------------------*/\n  GETNICK: GETFILE NAMETEXT\n  SET &TEXTLEN = &LENGTH(&NRSTR(&NAMETEXT))  /* Maximum length for loop\n  NICKLOOP: SET &LASTCOL = &TEXTLEN - &ADJUST  /* Refigure in case REC V\n  SET &COL = &FIRSTCOL + 5 + &NICKLEN  /* Start at col after :NICK.xxx\n  IF &STR(&SYSCAPS(&SUBSTR(&FIRSTCOL:&COL+1,+\n   &NRSTR(&NAMETEXT)                       ))) +\n   \u00ac= &STR(:NICK.&NICK&COUNT ) THEN +\n    GOTO GETNICK\n  SET &COL = &COL + 1               /* Skip blank after nickname\n  SET &NODE = NOTFOUND              /* Start with no node\n  SET &USERID = NOTFOUND            /* Start with no userid\n  DO WHILE LOOP = LOOP              /* (endless) Loop looking for tags\n    DO WHILE &SUBSTR(&COL,&NRSTR(&NAMETEXT) ) \u00ac= &STR(:)\n      IF &COL < &LASTCOL THEN +\n        SET &COL = &COL + 1         /* Look for colon that begins tag\n      ELSE DO\n        GETFILE NAMETEXT            /* Continue scan with next record\n        SET &TEXTLEN = &LENGTH(&NRSTR(&NAMETEXT))  /* Maximum length\n        SET &LASTCOL = &TEXTLEN - &ADJUST  /* Refigure in case REC V\n        SET &COL = &FIRSTCOL        /* Start at first col\n        END\n      END\n    IF &STR(&SYSCAPS(&SUBSTR(&COL:&COL+5,&NRSTR(&NAMETEXT)     ))) +\n     = :NICK. THEN +\n      GOTO ENDNICK                  /* Start of new is end of this nick\n    IF &STR(&SYSCAPS(&SUBSTR(&COL:&COL+5,&NRSTR(&NAMETEXT)     ))) +\n     = :NODE. THEN DO\n      SET &BEGINCOL = &COL + 6      /* Point past period in tag\n      DO WHILE &SUBSTR(&BEGINCOL,&NRSTR(&NAMETEXT):) = &STR( )\n        SET &BEGINCOL = &BEGINCOL + 1  /* Look for non-blank\n        END\n      SET &ENDCOL = &BEGINCOL + 1   /* Point to next character\n      DO WHILE &ENDCOL < &LASTCOL AND &SUBSTR(&ENDCOL,+\n       &NRSTR(&NAMETEXT) ) \u00ac= &STR( )\n        SET &ENDCOL = &ENDCOL + 1   /* Look for end of tag\n        END\n      SET &NODE = &SYSCAPS(&SUBSTR(&BEGINCOL:&ENDCOL,+\n                  &NRSTR(&NAMETEXT) ))\n      SET &COL = &ENDCOL            /* Reset loop to skip tag\n      GOTO NEXTTAG                  /* Go look for another tag\n      END\n    IF &STR(&SYSCAPS(&SUBSTR(&COL:&COL+7,&NRSTR(&NAMETEXT)       ))) +\n     = :USERID. THEN DO\n      SET &BEGINCOL = &COL + 8      /* Point past period in tag\n      DO WHILE &SUBSTR(&BEGINCOL,&NRSTR(&NAMETEXT):) = &STR( )\n        SET &BEGINCOL = &BEGINCOL + 1  /* Look for non-blank\n        END\n      SET &ENDCOL = &BEGINCOL + 1   /* Point to next character\n      DO WHILE &ENDCOL < &LASTCOL AND &SUBSTR(&ENDCOL,+\n       &NRSTR(&NAMETEXT) ) \u00ac= &STR( )\n        SET &ENDCOL = &ENDCOL + 1   /* Look for end of tag\n        END\n      SET &USERID = &SYSCAPS(&SUBSTR(&BEGINCOL:&ENDCOL,+\n                    &NRSTR(&NAMETEXT) ))\n      SET &COL = &ENDCOL            /* Reset loop to skip tag\n      GOTO NEXTTAG                  /* Go look for another tag\n      END\n/*--------------------------------------------------------------------*/\n/*  Resolve nicknames into node.userid. Save :NAME, decode :LIST/:CC. */\n/*--------------------------------------------------------------------*/\n    IF &STR(&SYSCAPS(&SUBSTR(&COL:&COL+5,&NRSTR(&NAMETEXT)     ))) +\n     = :NAME. THEN DO\n      SET &BEGINCOL = &COL + 6      /* Point past period in tag\n      DO WHILE &SUBSTR(&BEGINCOL,&NRSTR(&NAMETEXT):) = &STR( )\n        SET &BEGINCOL = &BEGINCOL + 1  /* Look for non-blank\n        END\n      SET &ENDCOL = &BEGINCOL + 1   /* Point to next character\n      DO WHILE &ENDCOL < &LASTCOL AND &SUBSTR(&ENDCOL,+\n       &NRSTR(&NAMETEXT):) \u00ac= &STR(:)\n        SET &ENDCOL = &ENDCOL + 1   /* Look for end of tag\n        END\n      SET &NAME = &SUBSTR(&BEGINCOL:&ENDCOL-1,&NRSTR(&NAMETEXT) )\n      SET &COL = &ENDCOL            /* Reset loop to skip tag\n      GOTO NEXTTAG                  /* Go look for another tag\n      END\n    IF &STR(&SYSCAPS(&SUBSTR(&COL:&COL+5,&NRSTR(&NAMETEXT)     ))) +\n     = :LIST. +\n     OR &STR(&SYSCAPS(&SUBSTR(&COL:&COL+3,&NRSTR(&NAMETEXT)   ))) +\n     = :CC. THEN DO\n      IF &STR(&SYSCAPS(&SUBSTR(&COL:&COL+5,&NRSTR(&NAMETEXT)     ))) +\n       = :LIST. THEN +\n        SET &BEGINCOL = &COL + 6    /* Point past period in tag\n      ELSE +\n        SET &BEGINCOL = &COL + 4    /* Point past period in tag\n      DO WHILE &SUBSTR(&BEGINCOL,&NRSTR(&NAMETEXT):) \u00ac= &STR(:)\n        DO WHILE &SUBSTR(&BEGINCOL,&NRSTR(&NAMETEXT):) = &STR( )\n          SET &BEGINCOL = &BEGINCOL + 1  /* Look for non-blank\n          END\n        SET &ENDCOL = &BEGINCOL + 1 /* Point to next character\n        NEWENT: DO WHILE &ENDCOL < &LASTCOL AND &SUBSTR(&ENDCOL,+\n         &NRSTR(&NAMETEXT) ) \u00ac= &STR( )\n          SET &ENDCOL = &ENDCOL + 1 /* Look for end of list entry\n          END\n        SET &NICK&LIST = &STR(&SYSCAPS(&SUBSTR(&BEGINCOL:&ENDCOL,+\n                              &NRSTR(&NAMETEXT) )))\n        SET &LIST = &LIST + 1       /* Point to next LIST nickname slot\n        SET &MAXNICK = &MAXNICK + 1 /* Increase maximum loop limit\n        SET &BEGINCOL = &ENDCOL + 1 /* Point past current entry\n        END\n      SET &NICK&COUNT = &STR()      /* Eliminate name of list\n      GOTO CLOSNICK\n      END\n    DO WHILE &SUBSTR(&COL+1,&NRSTR(&NAMETEXT):) \u00ac= &STR(:)\n      SET &COL = &COL + 1           /* Look for colon beginning next tag\n      END\n    NEXTTAG: END\n  ENDNICK: IF &NODE = NOTFOUND OR &USERID = NOTFOUND THEN DO\n    WRITE ===> WARNING: Nickname &NICK&COUNT not resolved +\n               in NAMES.TEXT, ignored.\n    SET &NICK&COUNT = &STR()        /* Null nickname to prevent error\n    GOTO CLOSNICK  /* This is an error, but other nicknames may be ok.\n    END\n  SET &NICK&COUNT = &NODE..&USERID  /* Change nickname to node.userid\n  SET &NICK&COUNT = &SUBSTR(1:17,&NICK&COUNT                 )   +\n                    &SUBSTR(1:15,&NRSTR(&NAME)               )     +\n                    &USERID        X\n  CLOSNICK: CLOSFILE NAMETEXT\n  SET &NAMETEXT = CLOSED            /* Show NAMES.TEXT is allocated\n  NEXTNICK: END\nERROR OFF                           /* Turn off NAMETEXT error routine\n/*--------------------------------------------------------------------*/\n/*  Add \"To: node.userid   name\" lines.                               */\n/*--------------------------------------------------------------------*/\nIF &SUBSTR(1,&COPYLIST ) = Y THEN DO  /* COPYLIST processing requested\n  SET &COUNT = 0\n  DO WHILE &COUNT < &MAXNICK        /* Loop through all nicknames\n    SET &COUNT = &COUNT + 1\n    IF &STR(&NICK&COUNT) \u00ac= &STR() THEN +\n      SET &TOLINES = &TOLINES.&SUBSTR(1:8,NICK&COUNT    )  /* Build VPUT\n    END\n  SET &TYPECALL = ADDTOLINES        /* Set to add \"To: xxx\" lines\n  ISPEXEC VPUT (TYPECALL TOLINES &TOLINES)  /* Save in ISPF shared pool\n  ISPEXEC EDIT DATAID(&DATAID) MACRO(NOTEIMAC) PROFILE(NOTE)\n  END\n/*--------------------------------------------------------------------*/\n/*  Mail the note. First send to non-PROFS destinations.              */\n/*--------------------------------------------------------------------*/\nSET &COUNT = 0\nDO WHILE &COUNT < &MAXNICK          /* Loop through all nicknames\n  SET &COUNT = &COUNT + 1\n  IF &STR(&NICK&COUNT) \u00ac= &STR() THEN +\n    IF &SUBSTR(1:&LENGTH(&PROFNODE),&NICK&COUNT        ) +\n     = &PROFNODE THEN +\n      SET &PROFMAIL = YES           /* Must add PROFS head/trail later\n    ELSE DO\n      PRINTOFF * DD(PDFTEMP&SCREEN) DEST(&SUBSTR(1:17,+\n          &NICK&COUNT                 )) CLASS(B) NOHEADING NOMSG\n      END\n  END\n/*--------------------------------------------------------------------*/\n/*  Add PROFS header/trailer, then mail to PROFS destinations.        */\n/*--------------------------------------------------------------------*/\nIF &PROFMAIL \u00ac= YES THEN +\n  GOTO LMFREE                       /* Go free ISPF resources\nSET &TYPECALL = PROFSFORMAT         /* Set to add PROFS header/trailer\nISPEXEC VPUT (TYPECALL PROFNODE SUBJECT)  /* Save in ISPF shared pool\nISPEXEC EDIT DATAID(&DATAID) MACRO(NOTEIMAC) PROFILE(NOTE)\nSET &COUNT = 0\nDO WHILE &COUNT < &MAXNICK          /* Loop through all nicknames\n  SET &COUNT = &COUNT + 1\n  IF &SUBSTR(1:&LENGTH(&PROFNODE),&NICK&COUNT        ) +\n   = &PROFNODE THEN +\n    PRINTOFF * DD(PDFTEMP&SCREEN) DEST(&SUBSTR(1:17,+\n        &NICK&COUNT                 )) CLASS(B) NOHEADING NOMSG\n  END\n/*--------------------------------------------------------------------*/\n/*  Terminate ISPF environment and free temporary edit dataset.       */\n/*--------------------------------------------------------------------*/\nLMFREE: ISPEXEC LMFREE DATAID(&DATAID)\nCONTROL NOMSG                       /* Prevent NOT FREED - NOT ALLOC msg\nFREE DD(PDFTEMP&SCREEN NAMETEXT)\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NOTEHELP": {"ttr": 2305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87(\\x7f\\x00\\x87(\\x7f\\x12\\x00\\x00\\x1f\\x00\\x1f\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-10-14T00:00:00", "modifydate": "1987-10-14T12:00:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "FILE325"}, "text": ")F Function -\n   The NOTE command procedure (CLIST) uses the ISPF/PDF editor to build\n   and format mail \"notes\", then sends them to PROFS or TSO users.\n   NOTE uses ISPF Dialog Services to collect information by displaying\n   panels, therefore NOTE must be executed while ISPF is active.\n)X Syntax -\n   NOTE     PROLOG(YES/NO)  EPILOG(YES/NO)  COPYLIST(YES/NO)\n            PROFNODE(node-name)\n   Required - none\n   Defaults - PROLOG(YES), EPILOG(YES), COPYLIST(YES), PROFNODE(EMINFO)\n\n            NOTE can be executed from PDF 6 by enetring: %NOTE\n            or from any 'COMMAND ===>' line by enetring: TSO %NOTE\n)O Operands -\n))PROLOG  - specifies whether :PROLOG. tags from your NAMES.TEXT\n            dataset are to be inserted at the top of the message.\n            ===> TSO TRANSMIT does not allow a colon in the text of a\n                 tag, but PROFS requires a colon to recognize FROM:.\n                 If your first prolog is  :PROLOG.From- name...\n                 NOTE will change the dash to colon for mail destined\n                 for PROFS. (This allows you to use the same NAMES.TEXT\n                 dataset for TRANSMIT and NOTE.)\n))EPILOG  - specifies whether :EPILOG. tags from your NAMES.TEXT\n            dataset are to be inserted at the bottom of the message.\n))COPYLIST - specifies whether a list of recipients is to be added as\n            part of the message before it is distributed. If requested,\n            the copylist is inserted at the top of the message before\n            the prolog information.\n))PROFNODE(node-name) - the name of the network node where PROFS is\n            is running. This name is used to determine which recipients\n            require PROFS header and trailer records added to the note.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NOTEIMAC": {"ttr": 2307, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87(\\x7f\\x00\\x87(\\x7f\\x12\\x00\\x00U\\x00U\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-10-14T00:00:00", "modifydate": "1987-10-14T12:00:00", "lines": 85, "newlines": 85, "modlines": 0, "user": "FILE325"}, "text": "ISREDIT MACRO\n/*--------------------------------------------------------------------*/\n/* NOTEIMAC is a PDF EDIT initialization macro called by \"NOTE\" CLIST */\n/* WRITTEN BY: Sam Lepore, Wells Fargo Bank, San Francisco CA    1/86 */\n/*--------------------------------------------------------------------*/\nCONTROL NOCAPS                      /* Allow lower case messages\nISPEXEC VGET TYPECALL\n/*--------------------------------------------------------------------*/\n/*  Set common profile parms for INITIALIZE, REEDIT, SUBCHANGE calls. */\n/*--------------------------------------------------------------------*/\nIF &TYPECALL = INITIALIZE OR &TYPECALL = REEDIT +\n OR &TYPECALL = SUBCHANGE THEN DO\n  ISREDIT BOUNDS 1 79\n  ISREDIT CAPS OFF\n  ISREDIT NULLS ON\n  ISREDIT NUMBER OFF\n  ISREDIT TABSLINE = <80 '*'>\n  ISREDIT TABS ON ALL\n  SET &ZEDSMSG = &STR(Special format! Hit PF 1)  /* Maximum length is 24\n  SET &ZEDLMSG = &STR(Mail data is specially formatted. Do not RENUM +\n                 or NUM. Data in col 80 is lost.)  /* Maximum len is 78.\n  ISPEXEC SETMSG MSG(ISRZ000)       /* Use ISPF defined dynamic message\n  IF &TYPECALL = REEDIT THEN +\n    EXIT\n/*--------------------------------------------------------------------*/\n/*  Seek subject line for insert (INITIALIZE) or update (SUBCHANGE).  */\n/*--------------------------------------------------------------------*/\n  ISREDIT SEEK SUBJECT: FIRST WORD 1\n  IF &LASTCC = 0 THEN +\n    IF &TYPECALL = INITIALIZE THEN DO\n      ISREDIT (LINE) = CURSOR\n      ISREDIT INSERT &EVAL(&LINE+1) 5  /* Skip blank line after subject.\n      ISREDIT CURSOR = &EVAL(&LINE+1) 3  /* Put cursor on blank line.\n      END\n    ELSE +\n      ISREDIT LINE .ZCSR = 'SUBJECT: ' + <10 (SUBJECT)>\n  EXIT\n  END\n/*--------------------------------------------------------------------*/\n/*  Add \"To: node.userid   name\" lines.                               */\n/*--------------------------------------------------------------------*/\nIF &TYPECALL = ADDTOLINES THEN DO\n  SET &COUNT = 1\n  SET &LINE = 0                     /* Start at ** TOP OF DATA **\n  SET &FIRST4 = &STR(To: )          /* Put \"To:\" on first line only\n  ISREDIT CAPS OFF                  /* Allow lower case in names\n  ISPEXEC VGET TOLINES              /* Get the names of passed variables\n  DO WHILE &SUBSTR(&COUNT:&COUNT+7,&TOLINES.ENDLINES) \u00ac= ENDLINES\n    SET &LEFT = &SUBSTR(&COUNT:&COUNT+7,&TOLINES)\n    IF &SUBSTR(&COUNT+8:&COUNT+15,&TOLINES.ENDLINES) \u00ac= ENDLINES THEN DO\n      SET &RIGHT = &SUBSTR(&COUNT+8:&COUNT+15,&TOLINES)\n      SET &COUNT = &COUNT + 8       /* Point to next nickname variable\n      END\n    ELSE DO\n      SET &SPACE35 = &STR(                                   )\n      SET &RIGHT = SPACE35          /* Use variable set to blanks\n      END\n    ISREDIT LINE_AFTER &LINE = <1 (FIRST4) 6 (&LEFT) 46 (&RIGHT)>\n    SET &COUNT = &COUNT + 8         /* Point to next nickname variable\n    SET &LINE = &LINE + 1           /* Increment current line counter\n    SET &FIRST4 = &STR(    )        /* Blank columns 1 through 4\n    END\n  ISREDIT LINE_AFTER &LINE = ' '    /* Add blank line after \"to\" lines\n  ISREDIT END\n  EXIT\n  END\n/*--------------------------------------------------------------------*/\n/*  Add PROFS header and trailer. These lines use hex chars FD FE FF. */\n/*--------------------------------------------------------------------*/\nIF &TYPECALL = PROFSFORMAT THEN DO\n  ISREDIT BOUNDS                    /* Turn BOUNDS off\n  ISREDIT CHANGE 'From-' 'From:' FIRST WORD 1  /* Change dash to colon\n  SET &LINE = 0\n  ISREDIT (LAST) = LINENUM .ZLAST   /* Get line number of last line\n  DO WHILE &LINE < &LAST\n    SET &LINE = &LINE + 1\n    ISREDIT SHIFT ) &LINE 1         /* Shift line right, blank column 1\n    END\n  ISPEXEC VGET PROFNODE\n  ISREDIT LINE_BEFORE .ZFIRST = '\u00daMSG:FROM: &SYSUID' + <20 '--TSO' +\n          31 'TO: PROFS   --&PROFNODE' 63 '&SYSDATE' 72 '&SYSTIME'>\n  ISREDIT LINE_AFTER .ZLAST = '\u009f\u009f    ' + <7 (SUBJECT) 78 '\u00d9\u00d9\u00d9'>\n  ISREDIT CHANGE X'FDFDFD' X'000000' .ZLAST .ZLAST 78 80\n  ISREDIT END\n  END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OPCON": {"ttr": 2310, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87(\\x7f\\x00\\x87(\\x7f\\x12\\x00\\x06\\x88\\x06\\x88\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-10-14T00:00:00", "modifydate": "1987-10-14T12:00:00", "lines": 1672, "newlines": 1672, "modlines": 0, "user": "FILE325"}, "text": "//*\n//*  TO ASSEMBLE FOR SAN FRANCISCO, 'AGO .ELMONTE' MUST BE COMMENTED\n//*  TO ASSEMBLE FOR ELMONTE, REMOVE THE COMMENT ASTERISK FROM COL 1\n//*  TO CHANGE PASSWORD MODIFY VIPWORD FIELD\n//*\n//ASM.SYSIN    DD *\n         TITLE 'S P Y --  MVS CONSOLE SPY PROGRAM  --  VERSION 3.3'\nOPCON    CSECT\n***********************************************************************\n*                                                                     *\n*                                 S P Y                               *\n*                                                                     *\n*                               02/26/82                              *\n*                                                                     *\n*                       OPERATOR CONSOLE MONITOR                      *\n*                                                                     *\n*                                      FIX FOR MOD-2 CNS09/87 V3.3.2CN*\n*                                                                     *\n*                                      MODIFIED FOR WFB 07/87 V3.3.1CN*\n*                                                                     *\n*                                      MODIFIED FOR WFB 05/86 V3.3.1VC*\n*                                                                     *\n*                                      MODIFIED FOR WFB 04/86 V3.3  VC*\n*                                                                     *\n*                                      MODIFIED FOR WFB 12/83       SL*\n*                                      TAKEN FROM CBT FILE338       SL*\n*                                      (NAME CHANGED TO \"OPCON\" IN  SL*\n*                                      THE CODE, BUT COMMENTS STILL SL*\n*                                      REFER TO \"SPY\")              SL*\n*                                                                   SL*\n*                                                                   SL*\n*     C A U T I O N   * * *   BE CAREFUL IN EDITING ... THERE IS    SL*\n*                             lower case TEXT IN THE LITERALS USED  SL*\n*                             FOR THE BUILT IN HELP SCREEN, AND IN  SL*\n*                             THE HELP ENTRY AT END OF THE SOURCE.  SL*\n*                                                                   SL*\n*   V3.3.2 - FIX SUPPORT FOR 3278-3 USER TERMINAL                   VC*\n*                                                                   SL*\n*   V3.3.1 - CHANGE CONSOLE ASID TO 7 DUE TO CATALOG ASID W/ DFP V2.VC*\n*                                                                   SL*\n*     V3.3 - ADD SUPPORT FOR CONSOLES THAT HAVE EXTENDED FIELD      VC*\n*            ATTRIBUTES (E.G. 3179, 3180, 3279-3B, ETC.).  THIS IS  VC*\n*            NECESSARY BECAUSE THE EXTENDED FIELD ATTRIBUTES ADD    VC*\n*            SIX CHARACTERS TO THE LENGTH OF EACH CONSOLE DISPLAY   VC*\n*            LINE AND OPCON COULD NOT SUPPORT THEM.  THIS VERSION   VC*\n*            CAPTURES THE ORIGINAL EXTENDED MODE SCREEN IMAGE AND   VC*\n*            THEN REFORMATS IT INTO A NON-EXTENDED FORMAT SO THAT   VC*\n*            IT CAN BE DISPLAYED ON ANY TYPE OF TERMINAL DEVICE.    VC*\n*(NOT DONE)- ADD SUPPORT TO PROCESS A PARM SPECIFIED ON ENTRY THAT  VC*\n*(NOT DONE)  INDICATES WHICH CONSOLE SHOULD BE INITIALLY DISPLAYED  VC*\n*(NOT DONE)  (DEFAULT IS MASTER CONSOLE).                           VC*\n*          - MAKE OPCON NON-SWAPPABLE                               VC*\n*          - UPDATE CONSOLE ID TABLE                                VC*\n*          - SET CONASID TO 6 FOR XA (S/370 CONASID IS 5)           VC*\n*                                                                   VC*\n*     V3.2 - ELIMINATE SPECIAL CHARACTER REQUIRED TO PRECEDE OS CMD SL*\n*          - ELIMINATE SECRET AUTH SVC, RESTORE MODESET AND SVC34   SL*\n*          - CORRECT BUFFER ADDRESS PROBLEM WITH LINE 1 OF DISPLAY  SL*\n*          - CORRECT LOOP COUNT FOR UCM BUILD                       SL*\n*          - ADD SUBCOMMAND A.. (AUTO W.. AFTER COMMAND ENTRY)      SL*\n*          - ADD CHECK AT INITIALIZATION FOR TSO OPER AUTHORITY     SL*\n*          - MAKE COMMAND ENTRY AREA NON-DISPLAY UNTIL PASSWD GIVEN SL*\n*          - MAKE \"OPER REDISPLAY\" AREA MODIFIABLE FOR REENTRY      SL*\n*          - FILL BOTH ENTRY AREAS WITH NULLS TO ALLOW CHAR INSERT  SL*\n*          - REDISPLAY LAST CMD ENTERED BY USER (INSTEAD OF OPER)   SL*\n*          - MOVE CONSOLE STATUS TABLE TO SEPARATE CSECT            SL*\n*          - RESTRUCTURE THE HELP SCREEN AND USE UPPER/LOWER CASE   SL*\n*          - PROVIDE TSO HELP ENTRY AS COMMENTS AT END OF SOURCE    SL*\n*                                                                   SL*\n*     THIS PROGRAM DISPLAYS THE CONTENTS OF ALL ACTIVE GRAPHIC        *\n*     OPERATOR'S CONSOLES ON A TSO CRT. THE OPERATOR'S SCREEN CAN BE  *\n*     EITHER A 327X OR A 370-168 INTEGRATED CONSOLE WITH 35 LINES.    *\n*     THE TSO USER CAN USE ANY 327X TERMINAL.                         *\n*                                                                     *\n*     SPY MUST, ALAS, BE APF AUTHORIZED. THE OPERATOR CONSOLE BUFFERS *\n*     AND CONTROL BLOCKS ARE NOW IN FETCH PROTECTED STORAGE. BE       *\n*     SURE TO PLACE THE 'SPY' COMMAND IN IKJEFTE2 AND/OR IKJEFTE8     *\n*     SO THAT IT WILL RETAIN APF AUTHORIZATION FROM TSO.              *\n*                                                                     *\n*     SPY GIVES A TSO USER THE CAPABILITY TO ENTER ANY                *\n*     CONSOLE OPERATOR COMMAND. THIS FACILITY IN PROTECTED BY A       *\n*     SIMPLE 3 CHARACTER PASSWORD (IN VIPWORD) TO PREVENT YOU         *\n*     FROM ENTERING AN OPERATOR COMMAND BY ACCIDENT.                  *\n*                                                                     *\n*     THE INPUT AREA IS SET TO NON-DISPLAY UNTIL THE PASSWORD IS    SL*\n*     ENTERED. TYPING THE 3-LETTER PASSWORD 'TOGGLES' THE VIP FLAG  SL*\n*     ON/OFF AND THE INPUT AREA DISPLAY/NON-DISPLAY. WHEN THE VIP   SL*\n*     FLAG IS ON (INDICATED BY AN * BETWEEN THE \"MODE\" AND \"PAGE\"   SL*\n*     FIELDS ON THE INFO LINE) ANYTHING YOU ENTER IN THE INPUT AREA SL*\n*     IS PASSED TO THE SYSTEM AS A COMMAND IF:                      SL*\n*         FIRST CHARACTER IS $         ASSUMED TO BE JES COMMAND    SL*\n*         FIRST CHARACTER IS NUMERIC   ASSUMED TO BE OS REPLY       SL*\n*         INPUT IS MORE THAN 3 CHARS   ALL SPY CMDS ARE 3 OR LESS   SL*\n*                                                                     *\n*     THE OPERATOR INPUT LINE (USED BY MCS TO RESPOND TO PA1) IS    SL*\n*     DISPLAYED ABOVE YOUR INPUT AREA BECAUSE PA1 AT YOUR TERMINAL  SL*\n*     IS PROCESSED BY TSO AS ATTENTION INTERRUPT. BOTH INPUT LINES  SL*\n*     CAN BE USED FOR ENTRY, BUT ONLY 79 CHARACTERS ARE READ - THE  SL*\n*     REST (IF ANY) IS JUST IGNORED.                                SL*\n*                                                                     *\n*         =====================>   NOTE THAT THE RESPONSE TO THE      *\n*     COMMAND APPEARS ONLY ON THE SCREEN YOU ARE WATCHING AT THE      *\n*     TIME. ALSO, YOUR COMMANDS HAVE THE SAME CONSOLE AUTHORITY       *\n*     AS THE SCREEN YOU ARE WATCHING, INCLUDING THE MASTER CONSOLE!   *\n*     THE MORAL BEING DON'T WATCH THE MASTER CONSOLE AND ACCIDENTALLY *\n*     ENTER '/Q' OR SOMETHING LIKE THAT...                            *\n*                                                                     *\n*     THIS PROGRAM WILL PROBABLY REQUIRE BOTH THE SYS1.AMODGEN AND    *\n*     SYS1.APVTMACS MACRO LIBRARIES TO ASSEMBLE PROPERLY.             *\n*     SPY WAS DEVELOPED ON A 370/168 MVS RELEASE 3.7; THIS VERSION    *\n*     WILL ONLY RUN ON MVS/SP1.3                                      *\n*                                                                     *\n*                        STEVE LANGLEY           ===> AS OF 2/84    SL*\n*                        SOUTHERN CALIF. EDISON       HE NO LONGER  SL*\n*                        ROSEMEAD, CALIF   91770      WORKS THERE.  SL*\n*                        213-572-3435                 WHERE ???     SL*\n*                                                                     *\n*                                                                     *\n*     PROGRAMMERS NOTE: ALTHOUGH THERE IS NO SUPPORT FOR EXTERNALLY SL*\n*     SETTING \"TESTFLAG\" TO NON-ZERO, DOING THIS (VIA ZAP ?) WILL   SL*\n*     CAUSE SKIP AROUND CROSS MEMORY, KEY ZERO, AND SUPERVISOR CODE SL*\n*                                                                   SL*\n*                                                                   SL*\n***********************************************************************\n      EJECT\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*  COMMAND     DESCRIPTION                                            *\n*                                                                     *\n*     B        (BYE) END SPY                                          *\n*     C        SWITCH MONITOR TO CONSOLE 1                            *\n*     CXX      SWITCH MONITOR TO CONSOLE XX                           *\n*     DXX      SET DELAY TO XX TENTHS SECONDS (SCREEN REFRESH RATE)   *\n*     E        END SPY                                                *\n*     F        FREEZE DISPLAY ON CURRENT PAGE (VALID FOR 3066 ONLY) SL*\n*     L        LINK TO SWAP PROGRAM (IF AVAILABLE)                    *\n*                      ---- -------    NOT AVAILABLE, \"L\" WILL BE   SL*\n*                                      INTERPRETED AS \"LEAVE\"       SL*\n*     R        RELEASE DISPLAY                (VALID FOR 3066 ONLY) SL*\n*     S        STATUS OF ALL CONSOLES                                 *\n*     W        START TIMER MODE FOR 30 TIMES OF DXX, THEN PAUSE       *\n*     WXX      START TIMER MODE FOR XX TIMES OF DXX, THEN PAUSE       *\n*     W0       START TIMER MODE UNTIL INTERRUPT                       *\n*     ?        DISPLAY THIS PAGE                                      *\n*     1        DISPLAY MODE 1                                         *\n*     2        DISPLAY MODE 2                                         *\n*                                                                     *\n*  HITTING INTERRUPT WILL STOP THE WAIT TIMER                         *\n*                                                                     *\n*     DISPLAY MODES 1 AND 2 ARE ONLY USEFUL WHEN WATCHING A LARGE     *\n*     35-LINE 3066 370-168 INTEGRATED CONSOLE FROM A 24-LINE 327X-2   *\n*     TSO TERMINAL. THESE MODES ARE:                                  *\n*                                                                     *\n*     DISPLAY MODE 1 - PAGE 1 = TOP 22 LINES                          *\n*                      PAGE 2 = BOTTOM 12 LINES                       *\n*     DISPLAY MODE 2 - PAGE 1 = TOP 22 LINES                          *\n*                      PAGE 2 = BOTTOM 22 LINES                       *\n*                                                                     *\n***********************************************************************\n         SPACE 4\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n         B     116(R15)           BRANCH AROUND SAVE AREAS          VC\n         DC    CL9'OPCON'         IDENTIFIER\n         DC    CL9'&SYSDATE'\n         DC    CL7'&SYSTIME'\n         DC    CL13'VERSION 3.3.2'     FROM CBT VERSION 3.1         VC\nSAVE     DC    18F'0'             SAVE AREA\n         STM   R14,R12,12(R13)    SAVE REGISTERS\n         LR    R12,R15            R12 = ADDR OF ENTRY POINT\n         USING OPCON,R12,R11      ADDRESABILITY TO CSECT\n         LA    R11,SAVE           R11 = ADDR OF OUR SAVE AREA\n         ST    R13,SAVE+4         SAVE POINTER TO CALLERS SAVE AREA\n         ST    R11,8(R13)         SAVE PTR TO OUR SAVE AREA IN CALLER'S\n         LR    R13,R11            R13 = ADDR OF OUR SAVE AREA\n         LA    R11,4095(R12)      R11 WILL BE\n         LA    R11,1(R11)         SECOND BASE REGISTER\n         EJECT\n***********************************************************************\n*                                                                     *\n*                       PROGRAM INITIALIZATION                        *\n*                                                                     *\n***********************************************************************\n         BAL   R14,INITSCAN       INITIALIZE IKJSCAN PARMLIST\n         GTSIZE ,                 GET SCREEN SIZE\n         LTR   R0,R0              R0 = NUMBER OF LINES PER SCREEN\n         BZ    HARDCOPY           IF NONZERO ASSUME A CRT IS IN USE\n***********************************************************************\n*                                                                     *\n*                       THIS TERMINAL IS A CRT                        *\n*                                                                     *\n***********************************************************************\nCRT      STH   R0,LPSCREEN        R0 = LINES PER SCREEN\n         STH   R1,CPLINE          R1 = CHARACTERS PER LINE\n         CH    R0,=H'24'          IS USER ON A 3277?\n         BE    FLSCREEN           YES, JUST CONTINUE\n         CH    R0,=H'32'          IS USER ON A 3278-3?               VC\n         BNE   MOD4USER           NO, ASSUME MOD4                    VC\n         MVI   MOD3FLG,X'FF'      SET 3278-3 FLAG ON                 VC\n         MVC   CMDCTRL(3),R30C1   ROW 30, COL 1                      VC\n         MVC   PHEADING(3),R31C1  ROW 31, COL 1                      VC\n         MVC   R24C1(3),R32C1     ROW 32, COL 1                      VC\n         B     FLSCREEN           CONTINUE                           VC\nMOD4USER MVI   MOD4FLG,X'FF'      SET 3278-4 FLAG ON\n         MVC   CMDCTRL(3),R41C1   ROW 41, COL 1\n         MVC   PHEADING(3),R42C1  ROW 42, COL 1\n         MVC   R24C1(3),R43C1     ROW 43, COL 1\nFLSCREEN CLI   TESTFLAG,X'00'\n         BNE   SKPTST1\n         STFSMODE ON,INITIAL=YES  TURN ON VTAM FULL SCREEN MODE\n         LA    R3,STAXLIST        R3 = ADDRESS OF STAX LIST MACRO\n         STAX  ATTNEXIT,MF=(E,(3)) ATTN EXIT TRAP\nSKPTST1  EQU   *\n         B     BLDUCMS\n***********************************************************************\n*                                                                     *\n*                    THIS TERMINAL IS A HARDCOPY                      *\n*                                                                     *\n***********************************************************************\nHARDCOPY STSIZE SIZE=80           OTHERWISE, HARDCOPY; SET LSIZE=80\n         MVI   CRTFLAG,X'00'      WE ARE USING A HARDCOPY\n         MVC   CMDCTRL(6),BLANKS  ZAP OUT 327X CNTRL CHARS\n         MVC   PHEADING(6),BLANKS ZAP OUT 327X CNTRL CHARS\n         MVC   HELP(14),BLANKS    ZAP OUT 327X CNTRL CHARS\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*          BUILD A TABLE OF UCM ADDRESSES (ONE PER CONSOLE)           *\n*                                                                     *\n***********************************************************************\nBLDUCMS  L     R4,CVTPTR          R4 = ADDR OF CVT\n         USING CVT,R4\n         L     R4,CVTCUCB         R4 = ADDR OF 'CUCB' (UCM BASE)\n         DROP  R4\n         USING UCM,R4\n         LR    R2,R4              R2 = R4\n         S     R2,=F'4'           R2 = ADDR OF ADDR OF UCM PREFIX\n         L     R2,0(R2)           R2 = ADDR OF UCM PREFIX\n         USING UCMPRFX,R2\n         L     R5,UCMVEA          R5 = ADDR OF FIRST UCM ENTRY\n         L     R6,UCMVEZ          R6 = LENGTH OF EACH UCM ENTRY\n         L     R7,UCMVEL          R7 = ADDR OF LAST UCM ENTRY\n         L     R8,@UCMTAB         R8 = ADDR OF UCMTAB (TABLE CSECT) SL\n         LA    R8,16(,R8)         R8 = ADDR OF FIRST CONSOLE ENTRY  SL\n         L     R9,UCMTABE         R9 = ADDR OF END OF UCMTAB\n         XR    R10,R10            R10 = 0 (NUMBER OF VALID UCMS)\n         MVC   CONSOLE(4),=F'1'   MAKE DEFAULT CONSOLE = 1          SL\nUCMLOOP  ST    R5,0(R8)           SAVE UCM ADDRESS IN UCMTAB\n         LA    R10,1(R10)         R10 = R10 + 1  (ONE MORE UCM)\n         C     R5,UCMMCENT        IS THIS UCM THE MASTER CONSOLE UCM?\n         BNE   UCMNEXT            NO;  GO LOOK AT NEXT UCM ENTRY\n         ST    R10,CONSOLE        YES; LOOK AT THIS ONE FIRST\nUCMNEXT  LA    R8,16(R8)          R8 = ADDR OF NEXT UCMTAB ENTRY\n         CR    R8,R9              DOES R8 POINT PAST END OF UCMTAB?\n         BNL   UCMFULL            YES; LEAVE LOOP\n         AR    R5,R6              R5 = ADDR OF NEXT UCM ENTRY\n         CR    R5,R7              DOES R5 POINT PAST UCM ENTRIES?\n         BNH   UCMLOOP            NO; KEEP GOING    (FIXED: WAS BL) SL\n         B     UCMDONE            YES; TABLE COMPLETE\nUCMFULL  MVC   ERROR(26),ERRMSG5  UCM TABLE TOO SMALL\nUCMDONE  STH   R10,NUMUCMS        SAVE NUMBER OF UCMS FOUND\n         DROP  R2,R4\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*         HERE WE GO... USE MODESET TO PUT US IN KEY 0                *\n*                                                                     *\n***********************************************************************\nSETAUTH  DS    0H                                                  SP3\n         CLI   TESTFLAG,X'00'\n         BNE   SKPTST2\n*                                                              AEI SP3\n*        UHBAPF AUTH=ON             MAKE SPY AUTHORIZED        AEI SP3\n*                                                              AEI SP3\n*                                      UHBAPF NOT AVAILABLE,        SL\n*                                      OPCON WILL BE LINKED AC=1    SL\n         MODESET MODE=SUP                                          SP3\n         ESAR  R5                   GET SEC ASID                   SP3\n         ST    R5,SASID             KEEP IT                        SP3\n         AXSET AX=ONE               SET AX TO ALLOW SSAR           SP3\n         SPACE 2                                                    VC\n         SYSEVENT TRANSWAP          SET OPCON NON-SWAPPABLE         VC\n         SPACE 2                                                    VC\n         GETMAIN R,LV=820           GETMAIN AREA FOR TDCM          SP3\n         ST    R1,LOCDCM            SAVE THE ADDRESS               SP3\n         SPACE 2                                                    VC\n         GETMAIN R,LV=3870          GETMAIN AREA FOR TEMP BUFFER    VC\n         ST    R1,LOCTBUF           SAVE THE ADDRESS                VC\nSKPTST2  EQU   *\n         EJECT\n***********************************************************************\n*                                                                     *\n*                            TOP OF LOOP                              *\n*              LOCATE SCREEN BUFFER AND PREPARE TO TPUT               *\n*                                                                     *\n***********************************************************************\nNEXTPAGE CLI   ATTNFLG,X'00'      WAS ATTN HIT?\n         BE    NOATTN             NO\n*                                 ATTENTION KEY HIT; PROCESS IT\n         MVI   ATTNFLG,X'00'      YES, RESET FLAG\n         MVC   TIME(3),BLANKS     BLANK OUT TIMER FIELD\n         MVI   WAITFLG,X'00'      TURN OFF WAIT FLAG\n         XC    TIMER,TIMER        SET TIMER TO 0\nNOATTN   EQU   *\n         L     R5,@UCMTAB         R5 = ADDR OF UCMTAB (TABLE CSECT) SL\n         L     R4,CONSOLE         R4 = CONSOLE TO BE DISPLAYED\n         CH    R4,NUMUCMS         IS NUMBER TOO HIGH?\n         BNH   GETUCM             NO, CONTINUE\nRESETCN  MVC   ERROR(26),ERRMSG1  CONSOLE UNDEFINED\nRESETCN1 L     R4,OLDCONS         RESET TO OLD CONSOLE\n         ST    R4,CONSOLE         AND SAVE IT\nGETUCM   SLL   R4,4               MULTIPLY BY 16\n         LA    R5,0(R5,R4)        R5 = ADDR OF ADDR OF UCM\n         LR    R1,R5              R1 = ADDR OF UCMTAB ENTRY\n         L     R5,0(R5)           R5 = ADDR OF UCM\n         USING UCMLIST,R5\n         ST    R5,@UCM            SAVE UCM ADDRESS                  VC\n         L     R6,UCMXB           R6 = ADDR OF RDCM\n         USING DCMTSRT,R6\n         LTR   R6,R6              IS THIS A GRAPHICS CONSOLE?\n         BP    GRAPHICS           YES\n***********************************************************************\n*                                                                     *\n*       THIS IS NOT AN OPERATOR GRAPHIC CONSOLE - GIVE ERRMSG4        *\n*                                                                     *\n***********************************************************************\n         L     R5,@UCMTAB         R5 = ADDR OF UCMTAB (TABLE CSECT) SL\n         MVC   ERROR(26),ERRMSG4  NON-GRAPHIC CONSOLE\n         B     RESETCN1           RESET THE CONSOLE NUMBER\nGRAPHICS EQU   *\n********************************************************************VC*\n*                                                                   VC*\n*       IF THIS OPERATOR CONSOLE IS INACTIVE - GIVE ERRMSG10        VC*\n*                                                                   VC*\n********************************************************************VC*\n         TM    UCMATR,UCMUF       IS THIS CONSOLE ACTIVE?           VC\n         BO    GRAPHIC2           YES, CONTINUE                     VC\n         MVC   ERROR(26),ERRMSG10 CONSOLE INACTIVE MESSAGE          VC\n         L     R5,@UCMTAB         R5 = ADDR OF UCMTAB (TABLE CSECT) VC\n         B     RESETCN1           RESET THE CONSOLE NUMBER          VC\n         SPACE 1                                                    VC\n***********************************************************************\n*                                                                     *\n*   THIS IS A GRAPHIC CONSOLE - BUILD TRAILER LINE WITH CONSDATA      *\n*                                                                     *\n***********************************************************************\nGRAPHIC2 BAL   R14,CONSDATA       CALL CONSDATA RTN                 VC\n         SPACE\n         CLI   TESTFLAG,X'00'                                       SL\n         BNE   SKPTST3                                              SL\n*       SETUP TO COPY PAGEABLE DCM TO OUR ADDRESS SPACE            SP3\n         L     R5,DCMADTRN        ADDR OF TDCM - 'FROM' FOR MVCP   SP3\n         LA    R7,CONASID         GET 'CONSOLE' ASID               SP3\n         SSAR  R7                 SET CONSOLE AS SECONDARY         SP3\n         L     R7,LOCDCM          'TO' ADDR FOR MVCP               SP3\n         LA    R3,820             LENGTH TO MOVE                   SP3\n         SR    R15,R15            'FROM' KEY                       SP3\nMOVEDCM  MVCP  0(R3,R7),0(R5),R15  MOVE IT                         SP3\n         BZ    DCMMOVED                                            SP3\n         LA    R5,256(R5)         BUMP 'FROM' ADDR                 SP3\n         LA    R7,256(R7)         BUMP 'TO' ADDR                   SP3\n         SH    R3,=H'256'         DECREMENT TRUE LENGTH            SP3\n         B     MOVEDCM            GO GET THE REST                  SP3\n         SPACE\nDCMMOVED L     R5,SASID           RESTORE PREVIOUS SECONDARY -     SP3\n         SSAR  R5                 SHOULD BE SAME AS PRIMARY        SP3\n         L     R7,LOCDCM          ADDR OF OUR COPY                 SP3\n         USING DCMSTRT,R7\n         SPACE\nSKPTST3  EQU   *                                                    SL\n***********************************************************************\n*                                                                     *\n*    FILLIN OPERATORS COMMAND INPUT BUFFER AND SET VIP FLAG INDICATOR *\n*                                                                     *\n***********************************************************************\n         MVC   LASTLINE(79),DCMINPUT MOVE IN INPUT BUFFER LINE\n         LH    R1,DCMINLGN             GET LENGTH OF TEXT           SL\n         CLI   LASTLFLG,X'FF'          RESHOW LAST COMMAND WE DID ? SL\n         BNE   FILLNULL                NO, LEAVE ASIS               SL\n         MVC   LASTLINE(79),OPERCMD    YES, DISPLAY TO ALLOW REDO   SL\n         LH    R1,OPERCMDL             GET LENGTH OF TEXT           SL\nFILLNULL EQU   *                                                    SL\n         S     R1,=F'4'                DROP THE WTO HEADER          SL\n         BNP   FILLDONE                SHOULD BE ERROR, BUT IGNORE  SL\n         LA    R2,78                   MAXIMUM NULLS TO MOVE        SL\n         SR    R2,R1                   ACTUAL NULLS TO MOVE         SL\n         BNP   FILLDONE                ZERO OR NEGATIVE, LEAVE ASIS SL\n         LA    R1,LASTLINE(R1)         POINT TO LAST CHARACTER      SL\nFILLMOVE MVC   0(0,R1),NULLS           ** EXECUTED **               SL\n         EX    R2,FILLMOVE                                          SL\nFILLDONE EQU   *                                                    SL\n         MVI   MODE+1,C' '        BLANK OUT VIP INDICATOR\n         CLI   VIPFLG,X'FF'       IS THE VIP FLAG ON?\n         BNE   CHKINTEG           NOPE\n         MVI   MODE+1,C'*'        TURN ON VIP INDICATOR\n***********************************************************************\n*                                                                     *\n*                         CHECK CONSOLE TYPE                          *\n*                                                                     *\n***********************************************************************\nCHKINTEG MVI   INTEGFLG,X'FF'     TURN ON LARGE CONSOLE FLAG        VC\n         CLC   DCMMSGAL(2),=H'28' IS CONSOLE LARGER THAN A MOD2?    VC\n         BNL   CHKMODEL           YES-CHK IF IT WILL FIT OUR TERM   VC\n         MVI   INTEGFLG,X'00'     NO; TURN OFF 3066 CONSOLE FLAG\n***      CLC   DCMMSGAL(2),=H'20' IS THIS 327X-2 TYPE CONSOLE?     AEI\n***      BNE   NOTSUPRT           NO;  NOT SUPPORTED, SO ABEND     AEI\n         MVI   FREEZE,C'F'        YES; FREEZE DISPLAY\n         MVI   PAGE,C'1'               ON PAGE 1 OF USER'S CRT\n         MVC   TPUTLEN(4),MOD2TPUT SET TPUT LENGTH FOR SHORT SCREEN\n         B     MOD2               AND TREAT USER AS MOD2 FOR NOW\n***********************************************************************\n*                                                                     *\n*        THIS OPERATOR'S CONSOLE IS NEITHER A 24-LINE 327X-2 NOR      *\n*        A LARGER MOD3 OR MOD4 INTEGRATED CONSOLE, SO ABEND.        VC*\n*                                                                     *\n***********************************************************************\nNOTSUPRT LA    R1,ERRMSG6         R1 = ADDR OF STRING TO TPUT\n         LA    R0,26              R0 = LENGTH OF TPUT\n         BAL   R14,TERMPUT        DO A TPUT\n         ABEND 999\n***********************************************************************\n*                                                                     *\n*     THIS IS A MOD3 OR MOD4 OPERATORS CONSOLE. IF THE USER HAS A   VC*\n*     43-LINE 3278-4 THERE IS NO PROBLEM, THE WHOLE THING CAN BE      *\n*     DISPLAYED AT ONCE. HOWEVER, IF THE USER HAS A 24-LINE 327X-2    *\n*     WE WILL HAVE TO BREAK THE DISPLAY INTO 2 PAGES SO IT WILL FIT.  *\n*                                                                     *\n***********************************************************************\nCHKMODEL EQU   *                                                     CN\n***********************************************************************\n*                                                                     *\n*                  USER HAS A 43-LINE 3278-4 CRT                      *\n*                                                                     *\n*        WE CAN JUST FREEZE HIS DISPLAY ON 'PAGE 1' AND CONTINUE      *\n*                                                                     *\n***********************************************************************\n         MVI   FREEZE,C'F'        FREEZE DISPLAY\n         MVI   PAGE,C'1'          ON PAGE 1 INITIALLY\n         MVC   TPUTLEN(4),MOD4TPUT SET LENGTH FOR FULL 3278-4 SCREEN\n         L     R8,DCMASCRN        R8 = ADDR OF SCREEN BUFFER + 6\n         L     R4,LOCTBUF         R4 = ADDR OF OUTPUT BUFFER         VC\n         LA    R5,M4BUFLEN        R5 = 3278-4 BUFFER LEN (35 LINES)\n         LA    R9,M4BUFLEN        R9 = 3278-4 BUFFER LEN (35 LINES)\n         MVC   TLEN,H35           STORE TERM LENGTH FOR MOD 4        CN\n*********************************************************************VC\n*                                                                    VC\n*        IF THIS TERMINAL IS A MOD 2 OR 3, ADJUST THE TPUT LENGTH    CN\n*        AND MOVE THE TRAILER UP.  GET AS MANY LINE ON THE SCREEN    CN\n*        AS WILL FIT AND TRUNCATE THE REST.                          CN\n*                                                                    VC\n*********************************************************************VC\n         CLI   MOD4FLG,X'FF'      IS TERMINAL A MOD 4?               CN\n         BNE   MOD3CHK            NO, GO CHECK FOR MOD3              CN\n         CLC   DCMMSGAL(2),H28    MOD 3 CONSOLE                      CN\n         BNE   MOVEBUFF           NO, GO MOVE BUFFER                 CN\n         B     MOD3SET            YES, GO SET UP FOR MOD 3           CN\nMOD3CHK  CLI   MOD3FLG,X'FF'      IS TERMINAL A MOD 3?               CN\n         BNE   MOD2SET            NO, GO DO SETUP FOR MOD 2          CN\n         LA    R5,M3BUFLEN        R5 = 3278-3 BUFFER LEN (35 LINES)  CN\n         LA    R9,M3BUFLEN        R9 = 3278-3 BUFFER LEN (35 LINES)  CN\n         MVC   TLEN,H28           STORE TERM LENGTH FOR MOD 3        CN\nMOD3SET  MVC   TPUTLEN(4),MOD3TPUT SET LENGTH FOR FULL MOD3 SCREEN   VC\n         MVC   ENDMOD3(TRAILEN),CMDCTRL MOVE IN TRAILER              VC\n         B     MOVEBUFF\nMOD2SET  MVC   TPUTLEN(4),MOD2TPUT SET LENGTH FOR FULL MOD2 SCREEN   CN\n         MVC   ENDMOD2(TRAILEN),CMDCTRL MOVE IN TRAILER              CN\n         LA    R5,M2BUFLEN        R5 = LENGTH OF OUTPUT BUF(21 LINES)CN\n         LA    R9,M2BUFLEN        R9 = CONSOLE BUFFER LEN  (21 LINES)CN\n         MVC   TLEN,H20           STORE TERM LENGTH FOR MOD 2        CN\n         B     MOVEBUFF                                              CN\n***********************************************************************\n*                                                                     *\n*                  USER HAS A 24-LINE 327X-2 CRT                      *\n*                                                                     *\n*        THIS OPER CONSOLE WILL HAVE TO BE DISPLAYED IN TWO SEGMENTS  *\n*        OR 'PAGES' SINCE 35 LINES WON'T FIT IN THIS 24 LINE TUBE.    *\n*                                                                     *\n*  NOTE: SUPPORT FOR TWO SEGMENTS DOESN'T WORK PROPERLY.  A LARGE   VC*\n*        CONSOLE CONSOLE (MOD3 OR MOD4) CANNOT BE DISPLAYED ON A    VC*\n*        SMALLER (MOD3 OR MOD2, REPECTIVELY) USER TERMINAL.  I DO   VC*\n*        NOT HAVE THE INCENTIVE TO FIX IT RIGHT NOW.  SO JUST       VC*\n*        DISPLAY AN ERROR AND RESET TO DISPLAY THE CONSOLE THAT WAS VC*\n*        SELECTED PREVIOUSLY.                                       VC*\n*                                                                     *\n***********************************************************************\nWONTFIT  MVC   ERROR(26),ERRMSG12 MOD3 WON'T FIT ON A MOD2 MESSAGE  VC\n         L     R5,@UCMTAB         R5 = ADDR OF UCMTAB (TABLE CSECT) VC\n         B     RESETCN1           RESET CONSOLE ID AND CONTINUE     VC\nMOD2     CLI   PAGE,C'1'          ARE WE ON PAGE 1?\n         BNE   ONTWO              NO, SO WE MUST BE ON 2\n         CLI   FREEZE,C'F'        ARE WE FROZEN ON PAGE 1?\n         BNE   PAGE2              NO, SO DISPLAY PAGE 2\n         B     PAGE1              YES, SO DISPLAY PAGE 1\nONTWO    CLI   FREEZE,C'F'        ARE WE FROZEN ON PAGE 2?\n         BE    PAGE2              YES, SO DISPLAY PAGE 2\nPAGE1    MVI   PAGE,C'1'          PAGE = 1\n         L     R8,DCMASCRN        R8 = ADDR OF SCREEN IMAGE BUFFER + 6\n         L     R4,LOCTBUF         R4 = ADDR OF OUTPUT BUFFER         VC\n         LA    R5,M2BUFLEN        R5 = LENGTH OF OUTPUT BUF (21 LINES)\n         LA    R9,M2BUFLEN        R9 = CONSOLE BUFFER LEN   (21 LINES)\n         MVC   TLEN,H20           STORE TERM LENGTH FOR MOD 2        CN\n         B     MVETRAIL           GO MOVE THE BUFFER\nPAGE2    MVI   PAGE,C'2'          PAGE = 2\n         L     R8,DCMASCRN        R8 = ADDR OF SCREEN IMAGE BUFFER + 6\n         CLI   MODE,C'2'          ARE WE IN DISPLAY MODE 2?\n         BE    DMODE2             YES, BRANCH TO DMODE2\nDMODE1   LA    R8,LEN22(R8)       MOVE POINTER DOWN 23 LINES\n         LA    R9,LEN13           R9 = LENGTH OF LAST 12 LINES\n         B     CONTINUE           JUMP AROUND MODE 2 DISPLAY\nDMODE2   LA    R8,LEN9(R8)        MOVE POINTER DOWN 9 LINES\n         LA    R9,LEN21           R9 = LENGTH OF SOURCE BUFFER\nCONTINUE L     R4,LOCTBUF         R4 = ADDR OF OUTPUT BUFFER         VC\n         LA    R5,M2BUFLEN        R5 = LENGTH OF OUTPUT BUFFER\nMVETRAIL MVC   ENDMOD2(TRAILEN),CMDCTRL MOVE IN TRAILER\n         SPACE\n***********************************************************************\n*                                                                     *\n*               MOVE THE SCREEN IMAGE BUFFER INTO BUF                 *\n*                                                                     *\n***********************************************************************\nMOVEBUFF STM   R4,R9,MOVEBSAV     KEEP REGS                        SP3\n*        SETUP TO COPY CONSOLE BUFFER TO OUR ADDRESS SPACE.        SP3\n*        FIRST FILL AREA WITH SPACES                               SP3\n         L     R9,=X'40000000'    MAKE BLANK THE PAD, LENGTH =0    SP3\n         LA    R8,*               NOT THAT IT REALLY MATTERS       SP3\n         MVCL  R4,R8              PAD WITH SPACES                  SP3\n         SPACE\n         CLI   TESTFLAG,X'00'                                       SL\n         BNE   SKPTST4                                              SL\n         LA    R4,CONASID         GET 'CONSOLE' ASID               SP3\n         SSAR  R4                 SET 'CONSOLE' AS SECONDARY       SP3\n         LM    R4,R9,MOVEBSAV     GET BACK ADDRESSES, LENGTHS      SP3\n         SR    R15,R15            'FROM' KEY                       SP3\n********************************************************************SL*\n*                                                                   SL*\n*        FOR ARCANE AND HISTORICAL REASONS, DMASCRN (IN R8)         SL*\n*        ACTUALLY POINTS TO SCREEN BUFFER + 6 OR 12 (BEGINNING OF   VC*\n*        MESSAGE TEXT). WITH THE ADVENT OF 3279 COLOR SUPPORT       SL*\n*        THE SBA-ATTR COMBO PRECEEDING THE FIRST TEXT BECOMES       SL*\n*        IMPORTANT. WE WILL THEREFORE \"BACK UP\" 12 BYTES TO INSURE  VC*\n*        THAT WE PICK UP ALL SBA-ATTR BYTES THAT COULD BE PRESENT.  VC*\n*                                                                     *\n********************************************************************SL*\n         SH    R8,=H'12'          POINT AT OR BEFORE 1ST SBA-ATTR   VC\nMOVEBFR  MVCP  0(R9,R4),0(R8),R15 MOVE IT                          SP3\n         BZ    BFRMOVED           GET OUT WHEN ALL MOVED           SP3\n         LA    R8,256(R8)         BUMP FROM ADDR                   SP3\n         LA    R4,256(R4)         BUMP TO ADDR                     SP3\n         SH    R9,=H'256'         DECREMENT TRUE LENGTH            SP3\n         B     MOVEBFR            GET THE REST                     SP3\n         SPACE\nBFRMOVED L     R4,SASID           RESTORE PREVIOUS SECONDARY -     SP3\n         SSAR  R4                 SHOULD BE SAME AS PRIMARY.       SP3\n         EJECT\nSKPTST4  EQU   *                                                    SL\n********************************************************************VC*\n*                                                                   VC*\n*        CONSOLE BUFFER CAN COME IN TWO FORMATS: STANDARD FORMAT    VC*\n*        (SBA+ATTR+DATA: TOTAL LENGTH 84 BYTES) OR EXTENDED DATA    VC*\n*        STREAM FORMAT (SBA+ATTR PAIRS+DATA: TOTAL LENGTH 90 BYTES).VC*\n*        IN ORDER TO DEAL WITH THE RESTRICTIONS IN THIS PROGRAM     VC*\n*        WITH REGARDS TO BUFFER SIZES, WE MUST DETERMINE WHICH      VC*\n*        FORMAT IS PRESENT AND IF NCESSARY REFORMAT THE EXTENDED    VC*\n*        FORMAT INTO A STANDARD FORMAT.  SOMEDAY, THIS CODE WILL    VC*\n*        BE ENHANCED TO ACCEPT THE EXTENDED FORMAT EASILY.          VC*\n*                                                                   VC*\n********************************************************************VC*\n         L     R5,@UCM            R5 = ADDR OF CONSOLE UCM          VC\n         USING UCMLIST,R5                                           VC\n         LA    R4,BUF             R4 = ADDR OF OUTPUT BUFFER        VC\n         L     R8,LOCTBUF         R8 = ADDR OF TEMPORARY BUFFER     VC\n         LH    R6,TLEN            NUMBER OF LINES ON TERMINAL       CN\n         CLC   TLEN(2),DCMMSGAL   TERMINAL SMALLER THAN CONSOLE?    CN\n         BL    KEEPTERM           YES, KEEP TERMINAL SIZE           CN\n         LH    R6,DCMMSGAL        NUMBER OF LINES FOR THE CONSOLE   VC\nKEEPTERM LA    R6,1(R6)           ADD 1 LINE FOR THE IEE152I MESSAGEVC\n         CLI   UCMEDEVX,X'10'     DEVICE TYPE = 3279-2A?            VC\n         BL    MVBFRNON           NO;  GO MOVE NON-EXTENDED FORMAT  VC\n         BE    MVBFREXT           YES; GO MOVE EXTENDED DS FORMAT   VC\n         CLI   UCMEDEVX,X'12'     DEVICE TYPE = 3279-3B OR EQUIV?   VC\n         BE    MVBFREXT           YES; GO MOVE EXTENDED DS FORMAT   VC\n         CLI   UCMEDEVX,X'16'     DOES DEVICE SUPPORT EXTENDED DS?  VC\n         BNL   MVBFREXT           YES; GO MOVE EXTENDED DS FORMAT   VC\nMVBFRNON LA    R8,6(R8)           POINT TO 1ST SBA-ATTR             VC\n         CLI   0(R8),X'11'        VERIFY THIS IS AN SBA ORDER       VC\n         BNE   UNKNOWN            ERROR IF NOT                      VC\nLOOPNON  MVC   0(84,R4),0(R8)     MOVE CONSOLE LINE (SBA+ATTR+DATA) VC\n         LA    R4,84(R4)          BUMP TO NEXT LINE IN TEMP BUFFER  VC\n         LA    R8,84(R8)          BUMP TO NEXT LINE IN OUTPUT BUFFERVC\n         BCT   R6,LOOPNON         DO IT A LINE AT A TIME            VC\n         B     TESTCRT            CONTINUE WHEN DONE                VC\nMVBFREXT CLI   0(R8),X'11'        VERIFY THIS IS AN SBA ORDER       VC\n         BNE   UNKNOWN            ERROR IF NOT                      VC\nLOOPEXT  MVC   0(1,R4),0(R8)      MOVE SBA ORDER                    VC\n         BAL   R14,CONVSBA        CONVERT 14-BIT SBA CODE TO 12-BIT VC\n         MVI   3(R4),X'1D'        MOVE ATTRIBUTE BYTE ORDER         VC\n         MVC   4(1,R4),6(R8)      MOVE ATTRIBUTE BYTE VALUE         VC\n         MVC   5(79,R4),11(R8)    MOVE CONSOLE DATA                 VC\n         LA    R4,84(R4)          BUMP TO NEXT LINE IN TEMP BUFFER  VC\n         LA    R8,90(R8)          BUMP TO NEXT LINE IN OUTPUT BUFFERVC\n         BCT   R6,LOOPEXT         DO IT A LINE AT A TIME            VC\n         B     TESTCRT            CONTINUE WHEN DONE                VC\nUNKNOWN  LA    R1,ERRMSG9         R1 = ADDR OF STRING TO TPUT       VC\n         LA    R0,26              R0 = LENGTH OF TPUT               VC\n         BAL   R14,TERMPUT        DO A TPUT                         VC\n         ABEND 999                                                  VC\n         SPACE 2                                                    VC\nCONVSBA  LA    R3,SBATABLE        GET SBA CONVERSION TABLE          VC\nLOOPSBA  CLC   1(2,R8),0(R3)      IS 14-BIT SBA IN THE TABLE?       VC\n         BE    MOVESBA            YES; GO MOVE 12-BIT SBA INTO BUF  VC\n         LA    R3,4(R3)           BUMP TO NEXT TABLE ENTRY          VC\n         CLI   0(R3),X'FF'        END OF SBA TABLE?                 VC\n         BE    ERRORSBA           YES; SBA NOT FOUND - ERROR        VC\n         B     LOOPSBA            TRY NEXT ENTRY                    VC\nMOVESBA  MVC   1(2,R4),2(R3)      MOVE 12-BIT SBA INTO OUTPUT BUFFERVC\n         BR    R14                RETURN                            VC\nERRORSBA LA    R1,ERRMSG11        R1 = ADDR OF STRING TO TPUT       VC\n         LA    R0,26              R0 = LENGTH OF TPUT               VC\n         BAL   R14,TERMPUT        DO A TPUT                         VC\n         ABEND 999                                                  VC\n         DROP  R5,R6,R7\n         SPACE 2\nTESTCRT  CLI   CRTFLAG,X'FF'      IS THIS A CRT?\n         BE    TPUTCRT            YES\n         EJECT\n***********************************************************************\n*                                                                     *\n*             USER HAS A LINE-AT-A-TIME HARDCOPY TERMINAL             *\n*                                                                     *\n***********************************************************************\n         XR    R8,R8              R8 = COUNTER = 0\n         LA    R1,BUF             SET POINTER TO FIRST LINE OF BUFFER\n         ICM   R1,8,EDITFLG       EDIT MODE\n         L     R0,=F'78'          R0 LENGTH OF OUTPUT LINE\nNEXTL    LR    R3,R1              SAVE R1 SINCE TPUT ZAPS IT\n         BAL   R14,TERMPUT        PRINT ONE LINE ON HARDCOPY\n         LA    R8,1(R8)           ADD 1 TO COUNTER\n         C     R8,=F'21'          HAVE WE PRINTED LAST LINE?\n         BE    DOLAST2            YES, CONTINUE\n         LA    R1,80(R3)          NOPE, POINT TO NEXT LINE\n         CLI   INTEGFLG,X'FF'     IS THIS AN INTEGRATED CONSOLE?\n         BE    NOT3270            YES\n         MVC   0(5,R1),BLANKS     BLANK OUT 3270 CTRL CHARS\n         LA    R1,4(R1)           ADD 4 EXTRA BYTES TO SKIP CTRL CHARS\nNOT3270  L     R0,=F'78'          LOAD LENGTH OF LINE\n         ICM   R1,8,EDITFLG       EDIT MODE\n         B     NEXTL              PRINT NEXT LINE\nDOLAST2  LA    R1,LASTLINE        R1 = ADDR OF STRING TO TPUT\n         LA    R0,79              R0 = LENGTH OF TPUT\n         BAL   R14,TERMPUT        DO A TPUT\n         LA    R1,HEADING         R1 = ADDR OF STRING TO TPUT\n         LA    R0,79              R0 = LENGTH OF TPUT\n         BAL   R14,TERMPUT        DO A TPUT\n         LA    R1,USERLINE        R1 = ADDR OF STRING TO TPUT\n         LA    R0,79              R0 = LENGTH OF TPUT\n         BAL   R14,TERMPUT        DO A TPUT\n         B     CHKWAIT            GO CHECK THE WAIT TIMER\n         EJECT\n***********************************************************************\n*                                                                     *\n*               DISPLAY THE OPERATOR'S SCREEN ON A 327X               *\n*                                                                     *\n***********************************************************************\nTPUTCRT  LA    R1,CLEAR           R1 = ADDR OF OUTPUT STREAM\n         L     R0,TPUTLEN         R0 = LENGTH OF TPUT\n         ICM   R1,8,FULLSCR       SET ASIS TYPE FOR TPUT\n         BAL   R14,TERMPUT        DO A TPUT; DISPLAY ENTIRE SCREEN\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*      IF WE ARE IN WAIT MODE DO A STIMER FOR THE NECESSARY LENGTH    *\n*      OF TIME, THEN CALCULATE AND DISPLAY THE NEW TIMER COUNT.       *\n*      IF COUNT HAS HIT ZERO, TURN OFF WAIT FLAG.                     *\n*                                                                     *\n***********************************************************************\nCHKWAIT  MVC   ERROR(66),NULLS    BLANK OUT ERROR FIELD    (NULLS)  SL\n         CLI   WAITFLG,X'FF'      IS THE WAIT FLAG ON?\n         BNE   READCHAR           NO, SO GO GET A COMMAND\n         STIMER WAIT,BINTVL=DELAY WAIT FOR DELAY * .01 SECONDS\n         L     R2,TIMER           R2 = CURRENT VALUE OF TIMER\n         BCTR  R2,0               TIMER = TIMER - 1\n         ST    R2,TIMER           STORE NEW VALUE OF TIMER\n         CVD   R2,WORK            CONVERT TO DECIMAL.\n         MVC   SCRATCH(4),PATTERN MOVE IN EDIT PATTERN\n         ED    SCRATCH(4),WORK+6  EDIT IN CONSOLE NUMBER\n         MVC   TIME(3),SCRATCH+1  MOVE TIME LEFT INTO PLACE\n         LTR   R2,R2              HAS TIMER HIT ZERO?\n         BNZ   NEXTPAGE           NO, CONTINUE TO COUNT\n         MVC   TIME(3),BLANKS     CLEAR COUNTER FIELD\n         XI    WAITFLG,X'FF'      TOGGLE WAIT FLAG OFF\n         B     NEXTPAGE           AND GO ON AS IF NOTHING HAPPENED..\n         EJECT\n***********************************************************************\n*                                                                     *\n*                       READ COMMAND FROM USER                        *\n*                                                                     *\n***********************************************************************\nREADCHAR MVC   REPLY(80),BLANKS   BLANK OUT REPLY FIELD\n         TGET  REPLY,79           GET 79 CHARACTERS FROM TERMINAL\n         CLI   REPLY,X'6E'        RESHOW CODE?\n         BE    READCHAR           YES; IGNORE IT\n         LTR   R1,R1                   ZERO LENGTH RETURNED ?       SL\n         BZ    NEXTPAGE                YES, GO REFRESH              SL\n         CH    R1,=H'80'               LENGTH OVER 80 ?             SL\n         BNH   LENOKAY                 NO, OKAY                     SL\n         MVC   ERROR(26),ERRMSG8       YES, SAY IT IS TOO LONG      SL\n         MVI   LASTLFLG,X'FF'          SET TO REDISPLAY BAD INPUT   SL\n         B     NEXTPAGE                GO REFRESH                   SL\nLENOKAY  STH   R1,OPERCMDL             SAVE THE INPUT LENGTH        SL\n***********************************************************************\n*                                                                     *\n*               CHECK FOR SYSTEM OPERATOR COMMANDS                    *\n*                                                                     *\n***********************************************************************\n         CLI   VIPFLG,X'FF'       ARE WE IN VIP MODE?\n         BNE   PARSECMD           NO, SO CONTINUE\n         CLI   REPLY,C'$'              IS THIS A JES COMMAND ?      SL\n         BE    CMDOKAY                 YES, DO IT                   SL\n         CH    R1,=H'3'                SUBCMDS ARE 3 CHAR OR LESS   SL\n         BH    CMDOKAY                 GREATER, PROCESS AS COMMAND  SL\n         BL    CWAIT                   LESS, ASSUME IS OUR SUBCMD   SL\n         CLI   REPLY+1,C' '            (=3) IS SECOND CHAR BLANK ?  SL\n         BNE   CWAIT                   NO, ASSUME IS OUR SUBCMD     SL\nCMDOKAY  MVC   OPERCMD(80),REPLY  MOVE CMD IN FROM REPLY FIELD\n         LH    R3,OPERCMDL             GET SAVED LENGTH OF COMMAND  SL\n         LA    R3,4(,R3)               ADD SVC34 PREFIX             SL\n         STH   R3,OPERCMDL        SAVE CMD LENGTH\n         L     R3,SAVEUPT         R3 = ADDR OF UPT\n         USING UPT,R3\n         NI    UPTSWS,X'FF'-UPTWTP TURN OFF 'WTP'\n         MODESET KEY=ZERO                                           SL\n         L     R0,CONSOLE              CONSOLE ID FOR SVC34         SL\n         LA    R1,OPERPRM              POINT TO SVC34 PARMLIST      SL\n         SVC   34                                                   SL\n         MODESET KEY=NZERO                                          SL\n         OI    UPTSWS,UPTWTP      TURN ON  'WTP'\n         MVI   LASTLFLG,X'FF'          SET TO REDISPLAY THE COMMAND SL\n         CLI   AFTERFLG,X'FF'          AUTOMATIC WXX AFTER CMD ?    SL\n         BNE   NEXTPAGE                NO, CONTINUE                 SL\n         MVC   REPLY(3),AWAITCMD       YES, RESTORE SAVED VALUE     SL\n         B     AWAIT                   GO DO THE WAIT               SL\n***********************************************************************\n*                                                                     *\n*          CONVERT COMMAND TO UPPER CASE AND CALL IKJSCAN             *\n*                                                                     *\n*    THIS CALL TO IKJSCAN IS COMPLETELY UNNECESSARY TO THE OPERATION  *\n*    OF SPY. IT IS INCLUDED SOLELY TO ALLOW THE 'X' FEATURE OF        *\n*    PCF2 TO OPERATE. IF YOU DO NOT HAVE PCF2, THIS COULD BE REMOVED. *\n*                                                                     *\n***********************************************************************\nPARSECMD OC    REPLY(79),BLANKS   CONVERT CHARS TO UPPER CASE\n         XC    CBUF+2(2),CBUF+2   CLEAR OFFSET\n         MVC   CSPLBLOK(24),CSPLSAVE  COPY IN CSPL BLOK\n         XC    CSOABLOK(8),CSOABLOK\n***      L     R2,SAVEJSCB        R2 = ADDR OF OUR JSCB        AEI SP3\n***      USING IEZJSCB,R2                                      AEI SP3\n***      NI    JSCBOPTS,X'FF'-JSCBAUTH TAPF OFF FOR PCFSCAN    AEI SP3\n         LA    R1,CSPLBLOK        R1 = ADDR OF CMD SCAN PARM LIST\n         L     R15,ADDRSCAN       R15 = ADDR OF IKJSCAN\n         BALR  R14,R15            INVOKE IKJSCAN\n***      OI    JSCBOPTS,JSCBAUTH  TURN ON APF BIT AGAIN        AEI SP3\n***      DROP  R2                                              AEI SP3\n         LA    R1,CSOABLOK        R1 = ADDR OF CMD SCAN OUTPUT AREA\n         USING CSOA,R1\n         TM    CSOAFLG,CSOANOC    IS THE BUFFER EMPTY?\n         BO    NEXTPAGE           YES; JUST GO REFRESH\n         DROP  R1\n***********************************************************************\n*                                                                     *\n*                       W  --  ENTER WAIT MODE                        *\n*                                                                     *\n***********************************************************************\nCWAIT    OC    REPLY(3),BLANKS         MAKE SURE OUR CMD IS UPCASE  SL\n         MVI   LASTLFLG,X'00'          DO NOT REDISPLAY THE COMMAND SL\n         CLI   REPLY,C'W'         DO WE SHIFT TO WAIT MODE?\n         BNE   CDELAY             NO, SO CONTINUE\nAWAIT    EQU   *                       (ENTER HERE FOR AXX CMD)     SL\n         XI    WAITFLG,X'FF'      TURN ON WAIT FLAG\n         LA    R2,30              SET DEFAULT VALUE = 30\n         LA    R15,CONVBIN        BRANCH TO CONVERSION RTN\n         BALR  R14,R15            EBCDIC TO BINARY\n         MVC   SCRATCH(4),PATTERN MOVE IN EDIT PATTERN\n         ED    SCRATCH(4),WORK+6  EDIT IN CONSOLE NUMBER\n         MVC   TIME(3),SCRATCH+1  MOVE TIME LEFT INTO PLACE\n         ST    R2,TIMER           STORE STARTING TIMER VALUE\n         B     NEXTPAGE           ALL SET - GO DISPLAY NEXT PAGE\n***********************************************************************\n*                                                                     *\n*            D  --  SET TIMER DELAY IN TENTHS OF A SECOND             *\n*                                                                     *\n***********************************************************************\nCDELAY   CLI   REPLY,C'D'         ARE WE CHANGING THE TIME DELAY?\n         BNE   CCONSOLE           NO, SO CONTINUE\n         LA    R2,10              SET DEFAULT VALUE = 10 TENTHS SECOND\n         LA    R15,CONVBIN        BRANCH TO CONVERSION RTN\n         BALR  R14,R15            EBCDIC TO BINARY\n         MVC   SCRATCH(5),DPATTRN MOVE IN EDIT PATTERN\n         ED    SCRATCH(5),WORK+6  EDIT IN DELAY TIME\n         MVC   PAUSE(3),SCRATCH+2 MOVE TIME LEFT INTO PLACE\n         MH    R2,=H'10'          CONVERT TO 100THS OF A SECOND\n         ST    R2,DELAY           STORE WAIT DELAY VALUE\n         B     NEXTPAGE           ALL SET - GO DISPLAY NEXT PAGE\n***********************************************************************\n*                                                                     *\n*                    C  --  SET CONSOLE NUMBER                        *\n*                                                                     *\n***********************************************************************\nCCONSOLE CLI   REPLY,C'C'         DO WE CHANGE CONSOLES?\n         BNE   CAFTER             NO, SO CONTINUE                   SL\n         L     R2,CONSOLE         SET DEFAULT CONSOLE\n         ST    R2,OLDCONS         SAVE OLD CONSOLE #\n         LA    R15,CONVBIN        BRANCH TO\n         BALR  R14,R15            EBCDIC->BINARY CONVERTOR\n         ST    R2,CONSOLE         STORE R2 AWAY AS CONSOLE NUMBER\n         BAL   R14,CLRBUF         CLEAR BUFFER                      VC\n         B     NEXTPAGE           CONTINUE\n********************************************************************SL*\n*                                                                   SL*\n*                    A  --  SET WAIT AFTER COMMAND                  SL*\n*                                                                   SL*\n********************************************************************SL*\nCAFTER   CLI   REPLY,C'A'              SET 'WAIT AFTER COMMAND' ?   SL\n         BNE   BYE                     NO, CONTINUE                 SL\n         MVI   AFTERFLG,X'00'          ASSUME TURN OFF AFTERFLAG    SL\n         CLI   REPLY+1,C' '            VALUE BLANK ?                SL\n         BE    NEXTPAGE                YES, LEAVE FLAG OFF, DONE    SL\n         CLI   REPLY+1,C'0'            FIRST DIGIT VALID ?          SL\n         BL    CAERROR                 NO, ERROR                    SL\n         CLI   REPLY+2,C' '            SECOND DIGIT BLANK ?         SL\n         BE    CASAVE                  YES, SAVE THE VALUE          SL\n         CLI   REPLY+2,C'0'            SECOND DIGIT VALID ?         SL\n         BL    CAERROR                 NO, ERROR                    SL\nCASAVE   MVC   AWAITCMD(3),REPLY       YES, SAVE THE VALUE          SL\n         MVI   AFTERFLG,X'FF'          TURN ON AFTERFLAG            SL\n         B     NEXTPAGE                                             SL\nCAERROR  MVC   ERROR(26),ERRMSG2       TELL VALUE NOT NUMERIC       SL\n         B     NEXTPAGE                                             SL\n***********************************************************************\n*                                                                     *\n*                        B  --  TERMINATE SPY                         *\n*                                                                     *\n***********************************************************************\nBYE      CLI   REPLY,C'B'         IS IT A 'B'?\n         BE    DONE               YES, SO QUIT\n***********************************************************************\n*                                                                     *\n*                        E  --  TERMINATE SPY                         *\n*                                                                     *\n***********************************************************************\nEND      CLI   REPLY,C'E'         IS IT AN 'E'?\n         BE    DONE               YES, SO QUIT\n***********************************************************************\n*                                                                     *\n*               F  --  FREEZE DISPLAY ON CURRENT PAGE                 *\n*                                                                     *\n***********************************************************************\nF        CLI   REPLY,C'F'         IS IT AN 'F'?\n         BNE   R                  NO, SO CONTINUE ON\n         MVI   FREEZE,C'F'        TURN ON FREEZE INDICATOR\n         B     NEXTPAGE           CONTINUE\n***********************************************************************\n*                                                                     *\n*           R  --  RELEASE FREEZE ON CURRENT PAGE DISPLAY             *\n*                                                                     *\n***********************************************************************\nR        CLI   REPLY,C'R'         IS IT AN 'R'?\n         BNE   MODE1              NO, SO CONTINUE ON\n         MVI   FREEZE,C'R'        TURN OFF FREEZE INDICATOR\n         B     NEXTPAGE           CONTINUE\n***********************************************************************\n*                                                                     *\n*                1  --  SHIFT TO MODE 1 TYPE DISPLAY                  *\n*                                                                     *\n***********************************************************************\nMODE1    CLI   REPLY,C'1'         DO WE SHIFT TO MODE 1 DISPLAY?\n         BNE   MODE2              NO, SO CONTINUE\n         CLI   REPLY+1,C' '            BE SURE IS NOT REPLY, EG: 1U SL\n         BNE   BADCMD                  NOT BLANK - NOT OURS         SL\n         MVI   MODE,C'1'          SET MODE INDICATOR\n         B     NEXTPAGE\n***********************************************************************\n*                                                                     *\n*                2  --  SHIFT TO MODE 2 TYPE DISPLAY                  *\n*                                                                     *\n***********************************************************************\nMODE2    CLI   REPLY,C'2'         DO WE SHIFT TO MODE 2 DISPLAY?\n         BNE   GETHELP            NO, SO CONTINUE\n         CLI   REPLY+1,C' '            BE SURE IS NOT REPLY, EG: 2U SL\n         BNE   BADCMD                  NOT BLANK - NOT OURS         SL\n         MVI   MODE,C'2'          SET MODE INDICATOR\n         B     NEXTPAGE\n***********************************************************************\n*                                                                     *\n*           ?  --  LIST HELP FOR SPY COMMANDS ON TERMINAL             *\n*                                                                     *\n***********************************************************************\nGETHELP  CLI   REPLY,C'?'         IS HE ASKING FOR HELP?\n         BNE   GETSTAT            NO,SO CONTINUE\n         LA    R1,HELP            R1 = ADDR OF HELP PAGE\n         LA    R0,HLENGTH         R0 = LENGTH OF HELP PAGE\n         ICM   R1,8,FULLSCR       INSERT ASIS CNTL CHARS\n         BAL   R14,TERMPUT        DO A TPUT; DISPLAY HELP\n         B     READCHAR\n***********************************************************************\n*                                                                     *\n*           S  --  LIST STATUS PAGE FOR ALL DEFINED CONSOLES          *\n*                                                                     *\n***********************************************************************\nGETSTAT  CLI   REPLY,C'S'         IS HE ASKING FOR STATUS REPORT?\n         BNE   SWAPLINK           NO; CONTINUE\n         BAL   R14,CLRBUF         CLEAR BUFFER\n         LH    R10,NUMUCMS        R10 = NUMBER OF CONSOLES\n         L     R2,@UCMTAB         R2 = ADDR OF UCMTAB (TABLE CSECT) SL\n         LA    R2,16(,R2)         R2 = ADDR OF FIRST CONSOLE ENTRY  SL\n         XR    R4,R4              CLEAR R4\n         LA    R4,BUF             R4 = ADDR OF TPUT BUFFER\n         LA    R3,23              R3 = NUMBER OF LINES ON SCREEN\nSTLOOP   LR    R1,R2              R1 = ADDR OF UCMTAB ENTRY\n         BAL   R14,CONSDATA       CALL CONSOLE DATA ROUTINE\n         MVC   0(45,R4),CONNUM    SAVE RESULTS IN BUFFER\n         LA    R4,80(R4)          R4 = ADDR OF NEXT LINE IN BUFFER\n         LA    R2,16(R2)          R2 = ADDR OF NEXT UCMTAB ENTRY\n         BCT   R3,NOTFULL         BRANCH IF THE SCREEN NOT FULL\nFULL     LA    R1,HEADER          R1 = ADDR OF TPUT BUF\n         LA    R0,STATLEN         R0 = LENGTH OF TPUT BUF\n         ICM   R1,8,FULLSCR       INSERT ASIS CNTL CHARS\n         BAL   R14,TERMPUT        DO A TPUT; DISPLAY STATUS PAGE\n         BAL   R14,CLRBUF         CLEAR BUFFER\n         LA    R4,BUF             R4 = ADDR OF TPUT BUFFER\n         LA    R3,23              R3 = NUMBER OF LINES ON SCREEN\n         BCT   R10,MORE           MORE ENTRIES?\n         B     NEXTPAGE           NO; CONTINUE\nMORE     TGET  REPLY,1            PAUSE FOR ENTER\n         B     STLOOP             AND LOOP\nNOTFULL  BCT   R10,STLOOP         LOOP IF MORE\n         LA    R1,HEADER          R1 = ADDR OF TPUT BUF\n         LA    R0,STATLEN         R0 = LENGTH OF TPUT BUF\n         ICM   R1,8,FULLSCR       INSERT ASIS CNTL CHARS\n         BAL   R14,TERMPUT        DO A TPUT; DISPLAY STATUS PAGE\n         TGET  REPLY,1            PAUSE FOR ENTER\n         B     NEXTPAGE\n***********************************************************************\n*                                                                     *\n*                    L  --  LINK TO SWAP PROGRAM                      *\n*                                                                     *\n***********************************************************************\nSWAPLINK CLI   REPLY,C'L'         SHOULD WE XCTL TO SWAP?\n         BNE   VIP                NO, SO CONTINUE\n         BE    DONE                                                 SL\n*                                      SWAP PROGRAM NOT AVAILABLE,  SL\n*                                      \"L\" INTERPRETED AS \"LEAVE\"   SL\n*        CLI   TESTFLAG,X'00'                                       SL\n*        BNE   SKPTST5                                              SL\n*        MODESET MODE=PROB        DON'T NEED SUP STATE ANYMORE      SL\n*SKPTST5 EQU   *                                                    SL\n*        L     R13,SAVE+4         CALLERS SAVE AREA POINTER.        SL\n*        XCTL  (2,12),EP=SWAP     XCTL TO SWAP                      SL\n***********************************************************************\n*                                                                     *\n*                       CHECK FOR VIP PASSWORD                        *\n*                                                                     *\n***********************************************************************\nVIP      CLC   REPLY(3),VIPWORD   WAS VIP PASSWORD ENTERED?\n         BNE   BADCMD             NO, CONTINUE\n         XI    VIPFLG,X'FF'       TOGGLE VIP FLAG\n         XI    INPUTATR+1,X'0C'        TOGGLE INPUT DISPLAY/NON-DSP SL\n         B     NEXTPAGE\n***********************************************************************\n*                                                                     *\n*                      COMMAND WAS INVALID                            *\n*                                                                     *\n***********************************************************************\nBADCMD   CLI   VIPFLG,X'FF'            (NOT OURS) COMMANDS ALLOWED? SL\n         BE    CMDOKAY                 YES, PROCESS AS A COMMAND    SL\n         MVC   ERROR(26),ERRMSG3  COMMAND WAS INVALID\n         MVC   ERROR+26(40),REPLY PUT BAD CMD IN DISPLAY LINE\n         B     NEXTPAGE\n         EJECT\n***********************************************************************\n*                                                                     *\n*                     ALL DONE - PREPARE TO END                       *\n*                                                                     *\n***********************************************************************\nDONE     DS    0H\n         CLI   CRTFLAG,X'00'      IS THIS A HARDCOPY?\n         BE    ALLDONE            YES\n         TPUT  CLR,CLRLEN,FULLSCR NO, LETS CLEAR THE SCREEN FIRST\n         CLI   TESTFLAG,X'00'\n         BNE   SKPTST6\n         STFSMODE OFF             AND TURN OFF FULLSCREEN MODE\nSKPTST6  EQU   *\nALLDONE  EQU   *\n         CLI   TESTFLAG,X'00'\n         BNE   SKPTST7\n         L     R1,LOCDCM          PREPARE TO FREEMAIN TDCM AREA    SP3\n         FREEMAIN R,LV=820,A=(1)  DO IT                            SP3\n         L     R1,LOCTBUF         PREPARE TO FREEMAIN TEMP BUFFER   VC\n         FREEMAIN R,LV=3870,A=(1) DO IT                             VC\n         AXSET AX=ZERO            AUTH INDEX BACK TO 0             SP3\n         MODESET MODE=PROB        GO BACK TO PROBLEM STATE         SP3\n*                                                              AEI SP3\n*        UHBAPF AUTH=OFF          MAKE SPY UN-AUTHORIZED       AEI SP3\n*                                                              AEI SP3\n*                                      UHBAPF NOT AVAILABLE,        SL\n*                                      OPCON WILL BE LINKED AC=1    SL\n         SPACE 2                                                    VC\n         SYSEVENT OKSWAP          SET OPCON SWAPPABLE               VC\n         SPACE 2                                                    VC\nSKPTST7  EQU   *\n         L     R13,SAVE+4         RESTORE POINTER TO CALLER'S SAVE AREA\n         LM    R14,R12,12(R13)    RESTORE REGISTERS\n         LA    R15,0              SET RC = 0\n         BR    R14                RETURN TO SYSTEM\n         EJECT\n***********************************************************************\n*                                                                     *\n*            CONVERT EBCDIC NUMBERS FROM USER INTO BINARY             *\n*                                                                     *\n***********************************************************************\nCONVBIN  CVD   R2,WORK            CONVERT TO DECIMAL.\n         CLI   REPLY+1,C' '       DID HE ENTER A NUMBER?\n         BE    RTRN               NO, USE THE DEFAULT\n         CLI   REPLY+1,C'0'       IS THE HEX CODE < 'F0' ?\n         BL    BADCHAR            YES, ERROR\n         CLI   REPLY+1,C'9'       IS THE HEX CODE > 'F9' ?\n         BH    BADCHAR            YES, ERROR\n         PACK  WORK(8),REPLY+1(1) PACK EBCDIC (ASSUME 1 DIGIT)\n         CLI   REPLY+2,C' '       DID HE ENTER 2 DIGITS?\n         BE    CVB                NO, DONT DO THE 2 DIGIT PACK\n         CLI   REPLY+2,C'0'       IS THE HEX CODE < 'F0' ?\n         BL    BADCHAR            YES, ERROR\n         CLI   REPLY+2,C'9'       IS THE HEX CODE > 'F9' ?\n         BH    BADCHAR            YES, ERROR\n         PACK  WORK(8),REPLY+1(2) PACK AGAIN, WITH 2 DIGITS THIS TIME\nCVB      CVB   R2,WORK            GET BINARY\nRTRN     BR    R14                RETURN TO MAINLINE\nBADCHAR  MVC   ERROR(26),ERRMSG2  CONSOLE NUMBER ERROR\n         B     RTRN\n         SPACE\n***********************************************************************\n*                                                                     *\n*                            C L R B U F                              *\n*                                                                     *\n*               CLEAR THE ENTIRE BUF AREA TO HEX ZEROS                *\n*                                                                     *\n***********************************************************************\nCLRBUF   STM   R2,R5,SAVE25       SAVE REGS 2 - 5\n         LA    R2,BUF             R2 = ADDR OF BUFFER\n         LA    R3,M4BUFLEN        R3 = LENGTH OF BUFFER (35 LINES)\n         LA    R4,BLANKS          R4 = ADDR OF BLANKS\n         LA    R5,1               R5 = LENGTH OF BLANK\n         ICM   R5,8,BLANKS        SETUP PAD CHAR = X'40'\n         MVCL  R2,R4\n         LM    R2,R5,SAVE25       RESTORE REGS\n         BR    R14                RETURN TO CALLER\nSAVE25   DS    4F\n         SPACE\n***********************************************************************\n*                                                                     *\n*                         T E R M P U T                               *\n*                                                                     *\n*          DO A TPUT TO THE TERMINAL; R0 AND R1 HOLD PARMS            *\n*                                                                     *\n***********************************************************************\nTERMPUT  TPUT  (1),(0),R          PRINT ONE LINE ON HARDCOPY\n         BR    R14                RETURN TO CALLER\n         EJECT\n***********************************************************************\n*                                                                     *\n*          SETUP AND INITIALIZE PARAMETER LIST FOR IKJSCAN            *\n*                                                                     *\n***********************************************************************\nINITSCAN STM   R15,R4,SAVE154     SAVE REGS\n         L     R3,CVTPTR          R3 = ADDR OF CVT\n         L     R3,0(R3)           R3 = ADDR OF ADDR OF TCB\n         L     R3,4(R3)           R3 = ADDR OF TCB\n         USING TCB,R3\n         ICM   R3,7,TCBJSCBB      R3 = ADDR OF JSCB\n         ST    R3,SAVEJSCB        SAVE ADDR OF JSCB\n         DROP  R3\n         USING IEZJSCB,R3\n         L     R4,JSCBPSCB        R4 = ADDR OF PSCB\n         DROP  R3\n         USING PSCB,R4\n         TM    PSCBATR1,PSCBCTRL       DOES USER HAVE OPER PRIV ?   SL\n         BNO   NOTSUPRT                NO, ISSUE MESSAGE AND ABEND  SL\n         L     R3,PSCBUPT         R3 = ADDR OF UPT\n         ST    R3,SAVEUPT         SAVE ADDR OF UPT\n         LA    R2,CSPLSAVE        R2 = ADDR OF CMD SCAN PARM LIST\n         USING CSPL,R2\n         ST    R3,CSPLUPT         SAVE UPT ADDR\n         L     R3,PSCBRLGB        R3 = ADDR OF RELOGON BUFFER\n         L     R3,256(R3)         R3 = ADDR OF ECT\n         ST    R3,CSPLECT         SAVE ECT ADDR\n         LA    R3,CPECB           R3 = ADDR OF FAKE ECB FOR THIS CP\n         ST    R3,CSPLECB         SAVE ECB ADDR\n         LA    R3,FLAGWORD        R3 = ADDR OF CSPL FLAG WORD\n         ST    R3,CSPLFLG         SAVE FLAG ADDR\n         LA    R3,CSOABLOK        R3 = ADDR OF CMD SCAN OUTPUT AREA\n         ST    R3,CSPLOA          SAVE OUTPUT AREA ADDR\n         LA    R3,CBUF            R3 = ADDR OF 'CMD BUFFER'\n         ST    R3,CSPLCBUF        SAVE CBUF ADDR\n         DROP  R2,R4\n         LOAD  EP=IKJSCAN\n         ST    R0,ADDRSCAN\n         LM    R15,R4,SAVE154     RESTORE REGS 15 - 4\n         BR    R14\n         SPACE 2\n         DS    0F\nSAVE154  DS    6F\n         SPACE 1\nSAVEUPT  DS    F                   SAVE ADDR OF UPT\nSAVEJSCB DS    F                   SAVE ADDR OF JSCB\nCSPLBLOK DS    6F                  CMD SCAN PARAMETER LIST\nCSPLSAVE DS    6F\nCPECB    DC    F'0'                FAKE ECB FOR THIS CP\nFLAGWORD DC    F'0'\nCSOABLOK DS    2F                  CMD SCAN OUTPUT AREA\nCBUF     DC    AL2(84),AL2(0)\nREPLY    DC    CL80' '             USER'S COMMAND INPUT BUFFER\nADDRSCAN DS    A\n         EJECT\n***********************************************************************\n*                                                                     *\n*                          C O N S D A T A                            *\n*                                                                     *\n*         FILLIN THE DATA LINE FOR A GIVEN CONSOLE                    *\n*                                                                     *\n***********************************************************************\nCONSDATA STM   R0,R15,SAVECDAT    SAVE REGS\n         L     R5,0(R1)           R5 = ADDR OF UCM\n         USING UCMLIST,R5\n         L     R6,UCMXB           R6 = ADDR OF RDCM\n         USING DCMTSRT,R6\n         MVC   CONNUM(48),BLANKS   BLANK OUT CONSOLE TYPE FIELD\n         XR    R3,R3              CLEAR R3\n         ICM   R3,1,UCMID         LOAD THE CONSOLE NUMBER\n         CVD   R3,WORK            CONVERT TO DECIMAL IN WORK\n         MVC   SCRATCH(4),PATTERN    MOVE IN EDIT PATTERN\n         ED    SCRATCH(4),WORK+6     EDIT IN CONSOLE NUMBER\n         MVC   CONNUM(2),SCRATCH+2   MOVE CONSOLE NUMBER INTO PLACE\n         MVC   LOCATION(12),4(R1) MOVE IN CONSOLE LOCATION DESCRIPTION\n         MVI   SLASH,C'/'\n         MVC   STATUS(6),=CL6'INACTV' SET DEFAULT = 'INACTV'\n         TM    UCMATR,UCMUF       IS THIS DEVICE ACTIVE?\n         BNO   NOTACT             NO\n         MVC   STATUS(6),=CL6'ACTIVE' SET STATUS = 'ACTIVE'\nNOTACT   EQU   *\n         TM    UCMDISP1,UCMDISPA  IS THIS A MASTER CONSOLE?\n         BNO   AUTH               NO\n         MVC   STATUS(6),=CL6'MASTER' YES\nAUTH     TM    UCMAUTHA,UCMAUTH1  IS THIS CONSOLE SYSTEM AUTHORIZED?\n         BNO   AUTH1              NO\n         MVC   SYS(3),=CL3'SYS '  YES\nAUTH1    TM    UCMAUTHA,UCMAUTH2  IS IT I/O AUTHOZRIZED?\n         BNO   AUTH2              NO\n         MVC   IO(3),=CL3'I/O'    YES\nAUTH2    TM    UCMAUTHA,UCMAUTH3  IS IT CONS AUTHORIZED?\n         BNO   AUTHDONE           NO\n         MVC   CONS(3),=CL3'CON'  YES\nAUTHDONE EQU   *\n         LTR   R6,R6              IS THIS A GRAPHICS CONSOLE?\n         BP    NOTHARD            YES\n         MVC   STATUS(6),=CL6'HRDCPY'\nNOTHARD  EQU   *\n         L     R7,UCMUCB          R7 = ADDR OF UCB\n         MVC   UNIT(3),13(R7)     MOVE UNIT ADDR INTO LINE\n         L     R5,UCMALTEN        R5 = ADDR OF ALTERNATE UCM\n         L     R7,UCMUCB          R7 = ADDR OF UCB\n         MVC   ALTUNIT(3),13(R7)  MOVE UNIT ADDR INTO LINE\n         LM    R0,R15,SAVECDAT    RESTORE REGS\n         BR    R14\n         DROP  R5,R6\nSAVECDAT DS    16F\n         SPACE 2\n         DROP  12\n         EJECT\n***********************************************************************\n*                                                                     *\n*                          A T T N E X I T                            *\n*                                                                     *\n*         TRAP USERS ATTENTION INTERRUPTS AND FLAG FOR RESET          *\n*                                                                     *\n***********************************************************************\nATTNEXIT LR    R7,R15             ESTABLISH\n         USING ATTNEXIT,R7        ADDRESSABILITY.\n         MVI   ATTNFLG,X'FF'      SET ATTN FLAG\n         BR    R14                RETURN TO CALLER\n         DROP  R7\n         EJECT\n***********************************************************************\n*                                                                     *\n*                         C O N S T A N T S                           *\n*                                                                     *\n***********************************************************************\n************   NO EXECUTABLE CODE BEYOND THIS POINT   **************SL*\n********************************************************************SL*\n         DS    0D\nWORK     DS    D                   WORK AREA FOR PACKS\nSCRATCH  DS    D                   SCRATCH AREA FOR CHAR. MANIP\nOLDCONS  DC    F'1'                PREVIOUS CONSOLE NUMBER\nCONSOLE  DC    F'1'                CONSOLE TO BE LOOKED AT\nTPUTLEN  DC    A(MOD2LEN)          LENGTH OF MOD 2 TPUT\nMOD4TPUT DC    A(MOD4LEN)          LENGTH OF MOD4 TPUT\nMOD3TPUT DC    A(MOD3LEN)          LENGTH OF MOD3 TPUT               VC\nMOD2TPUT DC    A(MOD2LEN)          LENGTH OF MOD2 TPUT\nLPSCREEN DC    H'0'                LINES PER SCREEN\nCPLINE   DC    H'0'                CHARACTERS PER LINE\nTIMER    DC    F'30'               SECONDS LEFT ON TIMER\nDELAY    DC    F'100'              DELAY FOR 100 HUNDREDTHS OF A SECOND\n*\nMOD3FLG  DC    X'00'               X'FF' INDICATES 3278-3 IN USE     VC\nMOD4FLG  DC    X'00'               X'FF' INDICATES 3278-4 IN USE\nATTNFLG  DC    X'00'               X'FF' INDICATES ATTN WAS TRAPPED\nTESTFLAG DC    X'00'               X'FF' INDICATES TEST MODE\nCRTFLAG  DC    X'FF'               X'FF' INDICATES CRT IN USE\nWAITFLG  DC    X'00'               X'00' INDICATES NOT IN WAIT MODE\nVIPFLG   DC    X'00'               X'FF' INDICATES VIP MODE\nINTEGFLG DC    X'00'               X'FF' INDICATES 35-LINE 3066 CONSOLE\nLASTLFLG DC    X'00'               X'FF' CAUSES REDISPLAY OF INPUT  SL\nAFTERFLG DC    X'00'               X'FF' CAUSES WXX AFTER EACH CMD  SL\n*\nFULLSCR  DC    X'03'               TPUT FULSCREEN FLAG\nEDITFLG  DC    X'00'               TPUT EDIT FLAG\nVIPWORD  DC    C'---'              VIP PASSWORD\nAWAITCMD DC    C'   '              VALUE FOR WXX AFTER EACH COMMAND SL\nNULLS    DC    80X'00'             JUST NULLS\nR30C1    DC    X'11E450'           3278-3  --  ROW 30, COL 1        VC\nR31C1    DC    X'11E560'           3278-3  --  ROW 31, COL 1        VC\nR32C1    DC    X'11E6F0'           3278-3  --  ROW 32, COL 1        VC\nR41C1    DC    X'11F240'           3278-4  --  ROW 41, COL 1\nR42C1    DC    X'11F350'           3278-4  --  ROW 42, COL 1\nR43C1    DC    X'11F460'           3278-4  --  ROW 43, COL 1\nPATTERN  DC    X'40202020'         EDIT PATTERN FIELD\nDPATTRN  DC    X'4021204B20'       EDIT PATTERN FIELD\nPAD      DC    C' '                PAD CHARACTER FOR MOVEBUFF MVC\nSTAXLIST STAX  ATTNEXIT,MF=L       PARM LIST FOR ATTENTION TRAP\nBLANKS   DC    CL80' '\n@UCMTAB  DC    A(UCMTAB)               ADDRESS OF UCMTAB CSECT      SL\n@UCM     DS    F                       ADDRESS OF CONSOLE UCM       VC\nUCMTABE  DC    A(TABEND)               (MOVED WHEN CSECT ADDED)     SL\nNUMUCMS  DC    H'0'                    (MOVED WHEN CESCT ADDED)     SL\n         SPACE 1\nOPERPRM  DS    0F                      SVC34 PARAMETER LIST         SL\nOPERCMDL DC    H'0'                    WILL BE PROVIDED EACH TIME   SL\n         DC    H'0'                    WORD FILLER (FOR SVC34)      SL\nOPERCMD  DC    CL80' '                 ACTUAL COMMAND PROVIDED HERE SL\n         EJECT                                                      SL\n***********************************************************************\n*                                                                     *\n*               327X SCREEN CLEAR CONTROL CHARACTERS                  *\n*                                                                     *\n***********************************************************************\nCLR      DC    X'C1'              WCC - CLEAR SCREEN\n         DC    X'115D7E'          SBA TO ROW 24, COL 79 (FSE 5.0)\n         DC    X'114040'          SBA TO ROW 1, COL 1\n         DC    X'3C404000'        FILL SCREEN WITH NULLS\n         DC    X'114040'          SBA TO ROW 1, COL 1\n         DC    X'13'              INSERT CURSOR\nCLRLEN   EQU   *-CLR\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*                  DISPLAY SCREEN - HEADER SECTION                    *\n*                                                                     *\n***********************************************************************\nHEADER   EQU   *\nCLEAR    DC    X'C1'              WCC\n         DC    X'115D7F'          SBA TO ROW 24, COL 80 (FSE 5.0)\n         DC    X'114040'          SBA TO ROW 1, COL 1\n         DC    X'3C404000'        FILL SCREEN WITH NULLS\n         DC    X'114040'          SBA TO ROW 1, COL 1 JUST IN CASE\n         DC    X'1D60'            ATTR BYTE - PROTECTED FIELD\n***********************************************************************\n*                                                                     *\n*                 DISPLAY SCREEN IMAGE BUFFER SECTION                 *\n*                                                                     *\n***********************************************************************\nBUF      DC    21CL84' '          OPERATORS SCREEN BUFFER\n         DC    22CL84' '          PLUS EXTRA FOR 3278-4\n***********************************************************************\n*                                                                     *\n*               DISPLAY SCREEN - TRAILER SECTION                      *\n*                                                                     *\n***********************************************************************\nTRAILER  EQU   *\nCMDCTRL  DC    X'115A50'          SBA TO ROW 22, COL 1\n         DC    X'1DC8'      ATTR BYTE - UNPROTECTED, HIGH INTENSITY SL\n* WAS==> DC    X'1DE8'            ATTR BYTE - PROTECTED, HIGH INTENSITY\nLASTLINE DC    CL79' '            OPERATORS COMMAND INPUT LINE\nPHEADING DC    X'115B60'          SBA TO ROW 23, COL 1\n         DC    X'1DE8'            ATTR BYTE - PROTECTED, HIGH INTENSITY\nHEADING  DC    CL8'CONSOLE '\nCONNUM   DC    CL2' 1'            CONSOLE NUMBER\n         DC    CL1' '\nLOCATION DC    CL12' '\n         DC    CL2' '\nUNIT     DC    CL3' '\nSLASH    DC    CL1'/'\nALTUNIT  DC    CL3' '\n         DC    CL2' '\nSTATUS   DC    CL6' '             MASTER CONSOLE\n         DC    CL2' '\nSYS      DC    CL4' '             SYS  AUTHORIZATION\nIO       DC    CL4' '             I/O  AUTHORIZATION\nCONS     DC    CL3' '             CONS AUTHORIZATION\n         DC    CL3' '\nTIME     DC    CL3' '             SECONDS REMAINING ON TIMER\n         DC    CL1'/'\nPAUSE    DC    CL3'1.0'           DELAY IN SECONDS\n         DC    CL2' '\nHEADING2 DC    CL5'MODE:'\nFREEZE   DC    C'F'               FREEZE/RELEASE MODE (FOR 3066 ONLY)\nMODE     DC    CL1'2'             DISPLAY MODE 2/1\n         DC    CL1' '\n         DC    CL5'PAGE '\nPAGE     DC    CL1'2'             PAGE NUMBER\nR24C1    DC    X'115CF0'          SBA TO ROW 24, COL 1\nINPUTATR DC    X'1D4C'      ATTR BYTE -- UNPROTECTED, NON DISPLAY   SL\n*                1D40 <==== CHANGED TO - UNPROTECTED, LOW INTENSITY SL\n*                                        AFTER PASSWORD IS ENTERED  SL\n* WAS==> DC    X'1D40'            ATTR BYTE - UNPROTECTED, LOW INTENS.\n         DC    X'13'              INSERT CURSOR\nUSERLINE DC    13X'00'            USERS COMMAND INPUT LINE  (NULLS) SL\nERROR    DC    66X'00'            ERROR MSG FIELD           (NULLS) SL\nENDTRAIL EQU   *\n         SPACE 5\nSASID    DS    F                  STORE FOR PREVIOUS SEC ASID      SP3\nLOCDCM   DS    F                  ADDR OF GETMAINED AREA FOR TDCM  SP3\nLOCTBUF  DS    F                  ADDR OF GETMAINED TEMPORARY BUF   VC\nONE      DC    H'1'               TO SET AX 1                      SP3\nZERO     DC    H'0'               TO SET AX 0                      SP3\nCONASID  EQU   7                  'CONSOLE' ASID - SP 2.1.3/DFP V2  VC\nMOVEBSAV DS    6F                 REG SAVE AREA - R4:R9            SP3\nTLEN     DS    H                  TERMINAL SIZE                     CN\nH20      DC    H'20'                                                CN\nH28      DC    H'28'                                                CN\nH35      DC    H'35'                                                CN\n         EJECT\nSBATABLE DS    0H                                                   VC\n******************************************************************* VC\n*                                                                 * VC\n*                  SBA CONVERSION TABLE                           * VC\n*                                                                 * VC\n*        THE SBA CONVERIONS TABLE IS USED TO CONVERT 14-BIT SBA   * VC\n*        (SET BUFFER ADDRESS) ORDERS USED ONLY WITH EXTENDED DATA * VC\n*        STREAM DEVICES TO A 12-BIT SBA ORDER THAT CAN BE USED    * VC\n*        WITH ANY DEVICE.                                         * VC\n*                                                                 * VC\n******************************************************************* VC\n         DC    X'0000',X'4040'    ROW  1, COLUMN 1                  VC\n         DC    X'0050',X'C150'    ROW  2, COLUMN 1                  VC\n         DC    X'00A0',X'C260'    ROW  3, COLUMN 1                  VC\n         DC    X'00F0',X'C3F0'    ROW  4, COLUMN 1                  VC\n         DC    X'0140',X'C540'    ROW  5, COLUMN 1                  VC\n         DC    X'0190',X'C650'    ROW  6, COLUMN 1                  VC\n         DC    X'01E0',X'C760'    ROW  7, COLUMN 1                  VC\n         DC    X'0230',X'C8F0'    ROW  8, COLUMN 1                  VC\n         DC    X'0280',X'4A40'    ROW  9, COLUMN 1                  VC\n         DC    X'02D0',X'4B50'    ROW  0, COLUMN 1                  VC\n         DC    X'0320',X'4C60'    ROW 11, COLUMN 1                  VC\n         DC    X'0370',X'4DF0'    ROW 12, COLUMN 1                  VC\n         DC    X'03C0',X'4F40'    ROW 13, COLUMN 1                  VC\n         DC    X'0410',X'5050'    ROW 14, COLUMN 1                  VC\n         DC    X'0460',X'D160'    ROW 15, COLUMN 1                  VC\n         DC    X'04B0',X'D2F0'    ROW 16, COLUMN 1                  VC\n         DC    X'0500',X'D440'    ROW 17, COLUMN 1                  VC\n         DC    X'0550',X'D550'    ROW 18, COLUMN 1                  VC\n         DC    X'05A0',X'D660'    ROW 19, COLUMN 1                  VC\n         DC    X'05F0',X'D7F0'    ROW 20, COLUMN 1                  VC\n         DC    X'0640',X'D940'    ROW 21, COLUMN 1                  VC\n         DC    X'0690',X'5A50'    ROW 22, COLUMN 1                  VC\n         DC    X'06E0',X'5B60'    ROW 23, COLUMN 1                  VC\n         DC    X'0730',X'5CF0'    ROW 24, COLUMN 1                  VC\n         DC    X'0780',X'5E40'    ROW 25, COLUMN 1                  VC\n         DC    X'07D0',X'5F50'    ROW 26, COLUMN 1                  VC\n         DC    X'0820',X'6060'    ROW 27, COLUMN 1                  VC\n         DC    X'0870',X'61F0'    ROW 28, COLUMN 1                  VC\n         DC    X'08C0',X'E340'    ROW 29, COLUMN 1                  VC\n         DC    X'0910',X'E450'    ROW 30, COLUMN 1                  VC\n         DC    X'0960',X'F560'    ROW 31, COLUMN 1                  VC\n         DC    X'09B0',X'E6F0'    ROW 32, COLUMN 1                  VC\n         DC    X'0A00',X'E840'    ROW 33, COLUMN 1                  VC\n         DC    X'0A50',X'E950'    ROW 34, COLUMN 1                  VC\n         DC    X'0AA0',X'6A60'    ROW 35, COLUMN 1                  VC\n         DC    X'0AF0',X'6BF0'    ROW 36, COLUMN 1                  VC\n         DC    X'0B40',X'6D40'    ROW 37, COLUMN 1                  VC\n         DC    X'0B90',X'6E50'    ROW 38, COLUMN 1                  VC\n         DC    X'0BE0',X'6F60'    ROW 39, COLUMN 1                  VC\n         DC    X'0C30',X'F0F0'    ROW 40, COLUMN 1                  VC\n         DC    X'0C80',X'F240'    ROW 41, COLUMN 1                  VC\n         DC    X'0CD0',X'F350'    ROW 42, COLUMN 1                  VC\n         DC    X'0D20',X'F460'    ROW 43, COLUMN 1                  VC\n         DC    X'FF'              END OF SBA TABLE                  VC\n         LTORG\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*                     ERROR AND WARNING MESSAGES                      *\n*                                                                     *\n***********************************************************************\nERRMSG1  DC    CL26'ERROR - CONSOLE UNDEFINED '\nERRMSG2  DC    CL26'ERROR - NON-NUMERIC VALUE '\nERRMSG3  DC    CL26'ERROR - INVALID COMMAND   '\nERRMSG4  DC    CL26'ERROR - NON-CRT CONSOLE   '\nERRMSG5  DC    CL26'WARNING - UCM TABLE FULL  '\nERRMSG6  DC    CL26'ERROR - TERMINAL INVALID  '\nERRMSG7  DC    CL26'ERROR - COMMAND RESTRICTED'\nERRMSG8  DC    CL26'ERROR - COMMAND TOO LONG  '\nERRMSG9  DC    CL26'ERROR - UNKNOWN FORMAT    '                     VC\nERRMSG10 DC    CL26'ERROR - CONSOLE INACTIVE  '                     VC\nERRMSG11 DC    CL26'ERROR - SBA NOT IN TABLE  '                     VC\nERRMSG12 DC    CL26'ERROR - CONSOLE IS A MOD-3'                     VC\n         EJECT\n***********************************************************************\n*                                                                     *\n*                           USER HELP PAGE                            *\n*                                                                     *\n***********************************************************************\nHELP     DC    X'C1'               WCC\n         DC    X'115D7F'           SBA TO ROW 24, COL 80 (FSE 5.0)\n         DC    X'114040'           SBA TO ROW 1, COL 1\n         DC    X'3C404000'         FILL SCREEN WITH NULLS\n         DC    X'114040',X'1DE8',C'S P Y   (OPCON) ---   VERSION 3.3'\n         DC    X'11C260',C'COMMAND  Description                '    SL\n         DC              C'COMMAND  Description'                    SL\n         DC    X'11C3F0'                                            SL\n         DC    X'11C540',C'  A    stop Auto Wxx after cmds     '    SL\n         DC              C'  End  End OPCON'                        SL\n         DC    X'11C650',C'  Axx  Automatic Wxx after cmds     '    SL\n         DC              C'  S    Status of all consoles'           SL\n         DC    X'11C760',C'  Bye  end OPCON                    '    SL\n         DC              C'  W    start Watch for 30 times Dxx'     SL\n         DC    X'11C8F0',C'  C    switch to master Console     '    SL\n         DC              C'  Wxx  start Watch for xx times Dxx'     SL\n         DC    X'114A40',C'  Cxx  switch to Console xx         '    SL\n         DC              C'  W0   start Watch until interrupt'      SL\n         DC    X'114B50',C'  Dxx  set Delay to xx tenths sec   '    SL\n         DC              C'  ?    display subcommands help'         SL\n         DC    X'114C60'                                            SL\n         DC    X'114DF0'                                            SL\n         DC    X'114F40',C'         PRESS: PA1 or ATTN (interru'    SL\n         DC              C'pt) to STOP THE WATCH TIMER.'            SL\n         DC    X'115050'                                            SL\n         DC    X'11D160',C'              Following are valid ON'    SL\n         DC              C'LY if the TSO terminal'                  SL\n         DC    X'11D2F0',C'              in use is smaller than'    SL\n         DC              C' console being watched'                  SL\n         DC    X'11D440'                                            SL\n         DC    X'11D550',C'  F    Freeze display on page x     '    SL\n         DC              C'  1    display page 1 (top portion)'     SL\n         DC    X'11D660',C'  R    Release frozen display       '    SL\n         DC              C'  2    display page 2 (bottom portion)'  SL\n         DC    X'11D7F0'                                            SL\n         DC    X'11D940'                                            SL\n         DC    X'115A50'                                            SL\n         DC    X'115B60'                                            SL\n         DC    X'115CF0'        ROW 24, COL 1\n         DC    C'Hit ENTER to continue'\n         DC    X'115DC6'        ROW 24, COL 23\n         DC    X'1D40'\n         DC    X'1340'\n         DC    X'1DE8'\nMARKER1  EQU   *\nHLENGTH  EQU   MARKER1-HELP     LENGTH OF HELP TPUT\n         EJECT\n***********************************************************************\n*                                                                     *\n*                           E Q U A T E S                             *\n*                                                                     *\n*     NOTE THAT A 'LINE' IS DEFINED AS 84 BYTES; THIS IS BECAUSE      *\n*     DIDOCS BUILDS THE OPERATOR SCREEN BUFFER LINES AS 79 BYTES OF   *\n*     TEXT + 5 CONTROL BYTES. THIS CONSISTS OF AN SBA (X'11XXYY')     *\n*     AND AN ATTRIBUTE BYTE (X'1DXX').                                *\n*                                                                     *\n***********************************************************************\nLEN9     EQU   9*84               NUMBER OF BYTES IN  9 LINES\nLEN13    EQU   13*84              NUMBER OF BYTES IN 13 LINES\nLEN14    EQU   14*84              NUMBER OF BYTES IN 14 LINES        VC\nLEN21    EQU   21*84              NUMBER OF BYTES IN 21 LINES\nLEN22    EQU   22*84              NUMBER OF BYTES IN 22 LINES\nLEN29    EQU   29*84              NUMBER OF BYTES IN 29 LINES        VC\nM2BUFLEN EQU   21*90              LENGTH OF LARGEST 3278-2 BUFFER    VC\nM3BUFLEN EQU   29*90              LENGTH OF LARGEST 3278-3 BUFFER    CN\nM4BUFLEN EQU   35*90              LENGTH OF LARGEST 3278-4 BUFFER    VC\nSTATLEN  EQU   BUF-CLEAR+80*23    LENGTH OF 'STATUS' PAGE BUFFER\nHEADLEN  EQU   BUF-HEADER         LENGTH OF HEADER\nTRAILEN  EQU   ENDTRAIL-TRAILER   LENGTH OF TRAILER\nMOD4LEN  EQU   ENDTRAIL-HEADER    LENGTH OF TPUT FOR MOD4\nMOD2LEN  EQU   MOD4LEN-LEN22      LENGTH OF TPUT FOR MOD2\nMOD3LEN  EQU   MOD4LEN-LEN14      LENGTH OF TPUT FOR MOD3            VC\nENDMOD2  EQU   BUF+LEN21          ADDR OF TRAILER FOR 3278-2\nENDMOD3  EQU   BUF+LEN29          ADDR OF TRAILER FOR MOD3           VC\n         EJECT\n*        AGO   .ELMONTE           ,    \"UN-COMMENT\" FOR EM CONSOLES SL\nUCMTAB   CSECT                    ,    BEGIN SAN FRANCISCO CONSOLES SL\n***********************************************************************\n*                                                                     *\n*                            U C M T A B                              *\n*                                                                     *\n*        THE UCMTAB TABLE IS BUILT AT SPY INITIALIZATION TIME.        *\n*        ONE ENTRY IS FILLED IN FOR EACH CONSOLE THAT HAS BEEN        *\n*        IOGENED INTO THE SYSTEM. THE 12 BYTE DESCRIPTION FIELD       *\n*        ALLOWS YOU TO TAG EACH CONSOLE WITH SOME MNEMONIC THAT       *\n*        IS EASIER TO REMEMBER THAN CONSOLE NUMBERS. IF UCMTAB IS     *\n*        NOT DEFINED LARGE ENOUGH TO HOLD ALL THE CONSOLES, A         *\n*        WARNING IS ISSUED BUT SPY CONTINUES ANYWAY.                  *\n*                                                                     *\n***********************************************************************\n         DC    A(0),CL12' '            (THIS ENTRY IGNORED IN LOOP) SL\n         DC    A(0),CL12'OPS 2ND FLR '    CONSOLE 1    A60          VC\n         DC    A(0),CL12'OPS 2ND FLR '    CONSOLE 2    560          VC\n         DC    A(0),CL12'TAPE LIBRARY'    CONSOLE 3    561          VC\n         DC    A(0),CL12'PRINT AREA 5'    CONSOLE 4    562          VC\n         DC    A(0),CL12'PRINT AREA 3'    CONSOLE 5    563          VC\n         DC    A(0),CL12'WILL CALL   '    CONSOLE 6    564          VC\n         DC    A(0),CL12'KOM SHOP    '    CONSOLE 7    565          VC\n         DC    A(0),CL12'POD 3RD FLR '    CONSOLE 8    566          VC\n         DC    A(0),CL12'** FUTURE **'    CONSOLE 9    567          VC\n         DC    A(0),CL12'** FUTURE **'    CONSOLE 10   568          VC\n         DC    A(0),CL12'TAPE POOL   '    CONSOLE 11   A61          VC\n         DC    A(0),CL12'PRINT AREA 1'    CONSOLE 12   A62          VC\n         DC    A(0),CL12'PRINT AREA 2'    CONSOLE 13   A63          VC\n         DC    A(0),CL12'PRINT AREA 5'    CONSOLE 14   A64          VC\n         DC    A(0),CL12'KOM SHOP    '    CONSOLE 15   A65          VC\n         DC    A(0),CL12'POD 3RD FLR '    CONSOLE 16   A66          VC\n         DC    A(0),CL12'** FUTURE **'    CONSOLE 17   A67          VC\n         DC    A(0),CL12'** FUTURE **'    CONSOLE 18   A68          VC\n         DC    A(0),CL12'HARDCOPY LOG'    CONSOLE 19   A6A          VC\n         DC    A(0),CL12'TELEGENIX   '    CONSOLE 20   A6D          VC\n         DC    A(0),CL12'OPER-AIDER  '    CONSOLE 21   JES   OPRA   VC\n         DC    A(0),CL12'OPER-AIDER  '    CONSOLE 22   JES   OPRA   VC\n         DC    A(0),CL12'OPER-AIDER  '    CONSOLE 23   JES   OPRA   VC\n         DC    A(0),CL12'OPER-AIDER  '    CONSOLE 24   JES   OPRA   SL\n         DC    A(0),CL12'----OPEN----'                              SL\nTABEND   EQU   *\n         AGO   .ENDELMO           ,    END SF CONSOLES, SKIP ELMONT SL\n.ELMONTE ANOP                     ,    COME HERE IF ASSEMBLE ELMONT SL\nUCMTAB   CSECT                    ,    BEGIN EL MONTE CONSOLES      SL\n***********************************************************************\n*                                                                     *\n*                            U C M T A B                              *\n*                                                                     *\n*        THE UCMTAB TABLE IS BUILT AT SPY INITIALIZATION TIME.        *\n*        ONE ENTRY IS FILLED IN FOR EACH CONSOLE THAT HAS BEEN        *\n*        IOGENED INTO THE SYSTEM. THE 12 BYTE DESCRIPTION FIELD       *\n*        ALLOWS YOU TO TAG EACH CONSOLE WITH SOME MNEMONIC THAT       *\n*        IS EASIER TO REMEMBER THAN CONSOLE NUMBERS. IF UCMTAB IS     *\n*        NOT DEFINED LARGE ENOUGH TO HOLD ALL THE CONSOLES, A         *\n*        WARNING IS ISSUED BUT SPY CONTINUES ANYWAY.                  *\n*                                                                     *\n***********************************************************************\n         DC    A(0),CL12' '            (THIS ENTRY IGNORED IN LOOP) SL\n         DC    A(0),CL12'3033 CPU PRI'    CONSOLE 1    012   3036   SL\n         DC    A(0),CL12'3033 CPU ALT'    CONSOLE 2    010   3036   SL\n         DC    A(0),CL12'MASTER (OPS)'    CONSOLE 3    490   3279   SL\n         DC    A(0),CL12'OPS ALT  4TH'    CONSOLE 4    491   3279   SL\n         DC    A(0),CL12'OPS TAPE 4TH'    CONSOLE 5    492   3279   SL\n         DC    A(0),CL12'3800 PRT 1ST'    CONSOLE 6    493   3279   SL\n         DC    A(0),CL12'KOMSTAR  1ST'    CONSOLE 7    494   3279   SL\n         DC    A(0),CL12'--OPEN-- 1ST'    CONSOLE 8    495          SL\n         DC    A(0),CL12'NCC      4TH'    CONSOLE 9    496   3279   SL\n         DC    A(0),CL12'POD CATP 3RD'    CONSOLE 10   497   3279   SL\n         DC    A(0),CL12'HARDCOPY 4TH'    CONSOLE 11 O-498   3287   SL\nTABEND   EQU   *\n.ENDELMO ANOP                     ,    END EL MONTE CONSOLES        SL\n         PRINT NOGEN\n         EJECT\n***********************************************************************\n*                                                                     *\n*                SYSTEM CONTROL BLOCK MAPPING DSECTS                  *\n*                                                                     *\n*     ALL MACROS EXCEPT FOR IEERDCM AND IEETDCM CAN BE FOUND IN       *\n*     EITHER 'SYS1.MACLIB' OR 'SYS1.AMODGEN'. THE TWO EXCEPTIONS      *\n*     ARE IN 'SYS1.APVTMACS'; THEY ARE ALSO DISTRIBUTED WITH THE      *\n*     SOURCE TO 'SPY'.                 ---- ----------- OH YEAH ?   SL*\n*                                                                     *\n***********************************************************************\n         CVT   DSECT=YES          COMMUNICATIONS VECTOR TABLE\n         SPACE 2\n         IEECUCM FORMAT=NEW,DSECT=YES,LIST=YES\n         SPACE 2\n         IEERDCM ,                RESIDENT DISPLAY CONTROL MODULE\n         SPACE 2\n         IEETDCM ,                PAGEABLE DISPLAY CONTROL MODULE\n         SPACE 2\n         SPACE 2\n         IEZJSCB ,                JOB STEP CONTROL BLOCK\n         SPACE 2\n         IKJCSOA ,                COMMAND SCAN OUTPUT AREA\n         SPACE 2\n         IKJCSPL ,                COMMAND SCAN PARAMETER LIST\n         SPACE 2\n         IKJPSCB ,                PROTECTED STEP CONTROL BLOCK\n         SPACE 2\n         IKJTCB  ,                TASK CONTROL BLOCK\n         SPACE 2\n         IKJUPT  ,                USER PROFILE TABLE\n         SPACE 2\n         AGO   .ENDHELP                SKIP AROUND HELP ENTRY       SL\n********************************************************************SL*\n*                                                                   SL*\n*        TSO HELP ENTRY FOR OPCON FOLLOWS.                          SL*\n*                                                                   SL*\n********************************************************************SL*\n)F FUNCTION -\n  OPCON displays the contents of any active graphics operator's console\n  on a TSO terminal. The console can be either a 327X or 370/168. The\n  TSO terminal can be any 327X.\n    OPCON also gives a TSO user the capability to enter any console\n  operator command. This facility is protected by a password to prevent\n  accidental entry of a command.\n)X SYNTAX -\n         OPCON\n\n  REQUIRED - None   (OPER authority is required.)\n  DEFAULTS - None\n  NOTE     - All options of OPCON are subcommands.\n             One help screen is available within OPCON, enter: ?\n)S SUBCOMMANDS -\n  A    stop Auto Wxx after cmds    E    End OPCON\n  Axx  Automatic Wxx after cmds    S    Status of all consoles\n  Bye  end OPCON                   W    start Watch for 30 times Dxx\n  C    switch to master Console    Wxx  start Watch for xx times Dxx\n  Cxx  switch to Console xx        W0   start Watch until interrupt\n  Dxx  set Delay to xx tenths sec  ?    display subcommands help\n\n         Press: PA1 or ATTN (interrupt) to stop the Watch timer.\n\n              Following are valid only if the TSO terminal\n              in use is smaller than console being watched\n  F    Freeze display on page x    1    display page 1 (top portion)\n  R    Release frozen display      2    display page 2 (bottom portion)\n)O\n  A password is required to engage the operator command facility.\n  Typing the password 'toggles' the command flag on/off. When the flag\n  is off, the input area is set non-display to protect entry of the\n  password. When the flag is on (indicated by an * between the MODE\n  and PAGE fields on the info line) the input area is set to display.\n  Anything you enter in the input area is passed to the system if:\n       FIRST CHARACTER IS $           assumed to be JES command\n       INPUT IS MORE THAN 3 CHARS     all OPCON subcmds are 3 or less\n       INPUT IS NOT A VALID SUBCMD    eg: 3U (reply) or D A (imbed blk)\n\n  Note - The operator input line (used by MCS to respond to PA1) is\n         displayed above your input line (because PA1 at your terminal\n         is processed by TSO as attention interrupt). Both input lines\n         can be used for entry, but only 79 characters are read - the\n         rest (if any) is just ignored.\n\n  Note - The response to any command you enter appears only on the\n         screen you are watching. Also, your commands have the same\n         console authority as the screen you are watching, including\n         the master console ! Be careful, there are no second chances.\n.ENDHELP ANOP                          ,                            SL\n         END                           , TERMINATE ASSEMBLY         SL\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PRINTOF$": {"ttr": 2826, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x004\\x00\\x99\\x12?\\x01\\x13\"o\\x14\\x06\\x00\\x1d\\x00\\x1b\\x00\\x00\\xc1\\xe2\\xd4\\xd1\\xc3\\xd3@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1999-05-03T00:00:00", "modifydate": "2013-08-14T14:06:34", "lines": 29, "newlines": 27, "modlines": 0, "user": "ASMJCL"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SBGOLOB.B.ASM\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(PRINTOFF)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETSSI  CB487325\n ALIAS   PRINTO,PROFF,PO\n NAME    PRINTOFF(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PRINTOFF": {"ttr": 3073, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x00\\x01\\x13\"_\\x01\\x13\"o\\x135\\r\\x1a\\x0be\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2013-08-13T00:00:00", "modifydate": "2013-08-14T13:35:00", "lines": 3354, "newlines": 2917, "modlines": 0, "user": "UPDATED"}, "text": "*\n*  NOTE TO FUTURE ASSEMBLERS ... PRINTOFF NORMALLY RESIDES IN\n*  A LINKLIB WITH  A L I A S E S  PRINTO AND PO.\n*  THE HELP ENTRY SHOULD BE ASSIGNED THE SAME ALIASES.\n*\nPRINTOFF TITLE 'IPO-SUPPLIED PRINT COMMAND - MODIFIED BY GTEL, ARAMCO, C\n               WFB      '                                           WFB\n***********************************************************************\n*                                                                     *\n*             MODULE NAME = PRINTOFF                                  *\n*                                                                     *\n*             DESCRIPTIVE NAME =  IPO SUPPLIED PRINT COMMAND FOR      *\n*                TSO FOREGROUND EXECUTION                             *\n*                                                                     *\n*             COPYRIGHT = NONE                                        *\n*                                                                     *\n*             STATUS = RELEASE 01.0 OF IPO                            *\n*                                                                     *\n*             FUNCTION =                                              *\n*                PRINTS A DATASET(S) WHICH IS SEQUENTIAL OR PARTIONED *\n*                ALLOWING THE USER TO SPECIFY OUTPUT CLASS, COPIES,   *\n*                DESTINATION AND HOLD/NOHOLD.  ALSO ALLOWS THE USER   *\n*                TO SPECIFY LIST/NOLIST, PRINT/NOPRINT, VOLUME,       *\n*                FOLD/NOFOLD, DS/SS, LINELENGTH AND PAGELENGTH     GTEL\n*                LIST IF PDS MEMBER NAMES ARE ONLY TO BE LISTED.      *\n*                PRINT IF PDS MEMBERS ARE ONLY TO BE PRINTED.         *\n*                SEE 'CHANGE ACTIVITY' FOR ADDITIONAL OPTIONS.      WFB\n*                                                                     *\n*                OPERATION =                                          *\n*                   BUILD PARS, DAIR, AND PUTLINE PARAMETER LISTS.    *\n*                   CALL PARS TO PARSE COMMAND BUFFER.                *\n*                   ALLOCATE DATASET AND DETERMINE IF PDS OR          *\n*                      SEQUENTIAL.                                    *\n*                   DETERMINE WHAT FUNCTIONS WERE TO BE PERFORMED     *\n*                      FOR THIS DATASET IF PDS.                       *\n*                   ALLOCATE SYSOUT DATASETS WHEN SOMETHING IS        *\n*                      FOUND TO BE PRINTED.                           *\n*                   PROCESS NEXT DATASET IN LIST.                     *\n*                   AT END OF LIST CLOSE DATASETS AND FREE ANY        *\n*                      SYSOUT DATASETS AND INPUT DATASETS.         GTEL\n*                   DATSETS WILL BE PRINTED AS EITHER VBA OR VBM.     *\n*                                                                     *\n*              NOTES =                                                *\n*                                                                     *\n*                 DEPENDENCIES = CHARACTER SET IS EBCDIC.  REASSEMBLE *\n*                    IF A DIFFERENT CHARACTER SET IS NEEDED.          *\n*                                                                     *\n*                                                                     *\n*                 RESTRICTIONS = DATASETS MUST HAVE LRECL NOT       WFB\n*                    GREATER THAN 32,760 AND MUST NOT               WFB\n*                    CONTAIN SPANNED RECORDS.  IN ADDITION,        GTEL\n*                    IF PAGELEN, DS, OR SS IS SPECIFIED, ALL       GTEL\n*                    OTHER CARRIAGE CONTROL WILL BE IGNORED.       GTEL\n*                                                                     *\n*                 REGISTER CONVENTIONS = STANDARD CONVENTIONS.        *\n*                    REGISTERS 0 TO 10 = WORK REGISTERS               *\n*                    REGISTERS 11,12   = ADDRESSIBILITY TO         GTEL\n*                                        PRINTOFF CSECT            GTEL\n*                    REGISTER  13      = SAVE AREA REGISTER AND       *\n*                                        ADDRESSABILITY TO GETMAINED  *\n*                                        WORK AREA                    *\n*                    REGISTERS 14,15   = WORK REGISTERS               *\n*                                                                     *\n*                PATCH LABEL = PATCH, UNUSED AND INTIALIZED TO        *\n*                   DC 20S(*)                                      WFB*\n*                                                                     *\n*                TSO COMMAND SYNTAX                                 WFB\n* PRINTOFF (DSLIST)/*  DDNAME(DDNAME)/FILE(DDNAME)                    *\n*          UNIT(UNIT-TYPE)  VOLUME(VOLSER)     NOMESSAGES/NOMSGS      *\n*          CLASS(CLASS)     DEST(DESTINATION)  COPIES(NNN)            *\n*          HOLD/NOHOLD      LIST/NOLIST        PRINT/NOPRINT          *\n*          FORMS(FORM)      FCB(FCB)           TRAIN(IMAGE)/UCS(IMAGE)*\n*          HEADING/NOHEADING                   CAPS/ASIS/FOLD/NOFOLD  *\n*          NOCC/SINGLESPACE/SS/DOUBLESPACE/DS  ASA                    *\n*          LINELENGTH(NNN)/LL(NNN)             PAGELENGTH(NNN)/PL(NNN)*\n*          BURST/NOBURST    FLASH(FLASH-NAME)  CHARS(CHARSET-NAME(S)) *\n*          PROG(PROGNAME)   UDKFONT(FONT-NAME)                        *\n* REQUIRED -- DSLIST OR * IF DDNAME(...)                              *\n* ALIASES  -- PRINTO, PO                                              *\n* DEFAULTS -- CLASS(A), COPIES(1), NOHOLD, LIST, PRINT, FORM($TST),   *\n*             HEADING, ASIS, LINELENGTH(132), PAGELENGTH(60), NOBURST,*\n*             SINGLESPACE IF PAGELENGTH(...) OR IF INPUT RECFM NOT A/M*\n*                                                                     *\n*             MODULE TYPE = PROCEDURE                                 *\n*                                                                     *\n*                PROCESSOR = ASM                                      *\n*                                                                     *\n*                MODULE SIZE = 13K BYTES                              *\n*                                                                     *\n*                ATTRIBUTES = SCHEDULER KEY 8, REENTRANT,             *\n*                   PROBLEM PROGRAM STATE                             *\n*                                                                     *\n*             ENTRY POINTS = PRINTOFF (ONLY ENTRY POINT)              *\n*                                                                     *\n*                LINKAGE =                                            *\n*                   FROM TERMINAL MONITOR PROGRAM AS A COMMAND        *\n*                                                                     *\n*             INPUT = REGISTER 1 POINTS TO COMMAND PROCESSOR          *\n*                PARAMETER LIST MAPPED BY IKJCPPL MACRO               *\n*                                                                     *\n*             OUTPUT = NONE                                           *\n*                                                                     *\n*             EXIT - NORMAL = AT PROGRAM END VIA BRANCH REGISTER 14   *\n*                                                                     *\n*                OUTPUT = NONE                                        *\n*                                                                     *\n*                RETURN CODE = ZERO                                   *\n*                                                                     *\n*             EXIT - ERROR = NONE - PROGRAM WILL DISPLAY DECIMAL      *\n*                RETURN CODE AND RETURN VIA BRANCH REGISTER 14        *\n*                                                                     *\n*                OUTPUT = NONE                                        *\n*                                                                     *\n*                RETURN CODE = ZERO                                   *\n*                                                                     *\n*             EXTERNAL REFERENCES =                                   *\n*                                                                     *\n*                ROUTINES = IKJPARS, DAIRFAIL, GNRLFAIL, PUTLINE      *\n*                   IKJEFLPA  (SEE NOTE IN 'CHANGE ACTIVITY')       WFB\n*                                                                     *\n*                DATA AREAS = NONE                                    *\n*                                                                     *\n*                CONTROL BLOCKS = CPPL, PPL, DAPL, DCB, DAPB, CVT,    *\n*                   S99RBP, S99RB, S99TUPL, S99TUNIT, S99TUFLD,       *\n*                   GFPARMS, DFPARMS, IOPL, IOPB                      *\n*                                                                     *\n*             TABLES = DATA AREA TO BE GETMAINED.  MAPPED BY DSECT    *\n*                BEGINNING AT LABEL WORKAREA                        WFB\n*                                                                     *\n*             MACROS = SAVE, GETMAIN, CALLTSSR, LINK, TPUT, FREEMAIN, *\n*                   OPEN, PUT, GET, CLOSE, RDJFCB, IKJRLSA, DYNALLOC, *\n*                   DCB, IKJPARM, IKJPOSIT, IKJKEYWD, IKJNAME,        *\n*                   IKJSUBF, IKJIDENT, IKJENDP, IKJDAP08, IKJDAP18,   *\n*                   IKJDAPL, IKJCPPL, IKJPPL, CVT, IEFZB4D0, IKJIOPL, *\n*                   IEFZB4D2, DCBD, IKJEFFGF, IKJEFFDF, PUTLINE       *\n*                                                                     *\n*             CHANGE ACTIVITY = 3800 SUPPORT ADDED VIA SETPRT   ARAMCO*\n*                               MAY 1981                        ARAMCO*\n*                                                                     *\n*             MODIFIED BY SAM LEPORE, WFB: 01/86                    WFB\n*               * CORRECT ERROR, 'NOHEAD' CAUSED BLANK FIRST PAGE   WFB\n*               * CORRECT ERRORS IN LENGTH OF TEXTG THROUGH TEXTJ   WFB\n*               * INCREASE INPUT RECORD LIMIT TO 32,760             WFB\n*               * CHANGE DSNAME POSIT TO DSTHING TO ALLOW FOR DDN() WFB\n*               * CHANGE DEST KEYWORD TO ACCEPT 8 CHAR VALUE        WFB\n*               * CHANGE DEST KEYWORD TO ACCEPT NODE AND USERID     WFB\n*               * ADD DDNAME(...) KEYWORD TO ALLOW TEMP OR VIO DSNS WFB\n*               * ADD UNIT(...) KEYWORD FOR USE WITH VOLUME(...)    WFB\n*               * ADD 'VOLUME: VOLSER' TO HEADING WHEN SPECIFIED    WFB\n*    +--------> * ADD TIME AND 'MONTHNAME DAY, YEAR' TO DSN HEADING WFB\n*    :          * ADD NOMSGS KEYWORD TO STOP NON-ERROR MSGS TO TERM WFB\n*    :          * ADD DSECT=YES TO CVT MACRO FOR CLEAN XA ASSEMBLY  WFB\n*    :          * MOVE ALL PUTLINE TEXT TO SEPARATE MESSAGES CSECT  WFB\n*    :                (FOLLOWING CHANGES ARE WFB SPECIFIC)          WFB\n*    :          * MAKE WFB DEFAULT FORM($TST)                       WFB\n*    :                                                              WFB\n*    +-- NOTE ==> THE TIME-DATE ROUTINE IKJEFLPA NORMALLY RESIDES   WFB\n*                 ONLY IN SYS1.AOST4. THIS LIBRARY MUST BE INCLUDED WFB\n*                 IN THE LINKEDIT SYSLIB FOR PROPER RESOLUTION.     WFB\n*                                                                     *\n*    +-- NOTE ==> (SBG - NO MORE. IKJEFLPA FROM IBM IS NOW            *\n*                        INCOMPATIBLE, SO WE DISASSEMBLED THE         *\n*                        OLD ONE, FIXED THE \"CENTURY\" PROBLEM,        *\n*                        AND WE ARE INCLUDING ITS SOURCE HERE.)       *\n*                                                                   WFB\n*             MODIFIED BY SAM LEPORE, WFB: 01/87                    WFB\n*                                                                   WFB\n*               * CORRECT ERROR, 'NOHEAD' OFFSET LINE COUNT PAGE 1  WFB\n*               * ADD ASA KEYWORD TO ACCEPT CC WHEN RECFM NOT ..A   WFB\n*               * ADD NOCC KEYWORD ALIAS OF SINGLESPACE             WFB\n*               * ADD UDKFONT(...) KEYWORD FOR XEROX 2700/3700 FONT WFB\n*               * DELETE OLD LINES MARKED *DELETED OR 'DELETED CODE'WFB\n*                                                                     *\n*             MODIFIED BY SAM GOLOB    08/13    Z/OS 1.13             *\n*                                                                     *\n*               * NEW VERSION OF IKJEFLPA IS INCOMPATIBLE WITH THIS   *\n*                 ASSEMBLY. DISASSEMBLED THE OLD VERSION AND FIXED    *\n*                 MODULE IKJEFLPB SO DATES READ 20XX AND NOT 19XX.    *\n*                 (THIS MODULE IS ONLY INCLUDED TO FIND DATE AND      *\n*                 TIME OF THE PRINTOFF RUN. IT WORKS, SO WE DIDN'T    *\n*                 CHANGE IT, EXCEPT FOR THE \"CENTURY ZAP\" - FIRST     *\n*                 BYTE OF IKJEFLPB. X'19' TO X'20'.)                  *\n*               * ADJUSTED OLD \"SAVE\" MACRO SO IT ASSEMBLES PROPERLY  *\n*                 AND &SYSTIME IS NOW INCLUDED FOR CLARITY.           *\n*               * ASSEMBLY JOB NOW INCLUDES IKJEFLPA AND IKJEFLPB.    *\n*                                                                     *\n*             MODIFIED TO CALL JULSUB NOT IKJEFLPA  08/13  Z/OS 1.13  *\n*                                                                     *\n*             MESSAGES =                                              *\n*                                                                     *\n*                BOTH THE DAIRFAIL AND GNRLFAIL SERVICE ROUTINES ARE  *\n*                USED TO ISSUE MESSAGES.                              *\n*                THOSE ISSUED BY THE COMMAND ARE FOUND FOLLOWING THE  *\n*                LABEL GNRLERR AND ARE ISSUED USING PUTLINE.          *\n*                                                                     *\n*             ABEND CODES = NONE                                      *\n*                                                                     *\n***********************************************************************\n*\nPRINTOFF CSECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         B     BEGINN-*(,R15)          FAKE IPO VERSION'S SAVE MACRO\n         DC    AL1(31)\n         DC    C'HARDCOPY.IPO.'\n         DC    CL8'&SYSDATE'\n         DC    C' '\n         DC    CL8'&SYSTIME'           ADD TIME FOR REFERENCE\nBEGINN   DS    0H\n         STM   14,12,12(13)\n         LR    R12,R15                 LOAD REGISTER 12 WITH ENTRY\n*                                      ADDRESS\n         USING PRINTOFF,R12            ESTABLISH ADDRESSABILITY TO\n*                                      PROGRAM CSECT\n         LA    R11,4095(R12)           LOAD REGISTER 11 WITH ENTRY\n*                                      ADDRESS 4095\n         USING PRINTOFF+4095,R11       ESTABLISH ADDRESSABILITY TO THE\n*                                      REST OF THE PROGRAM CSECT\n         LR    R8,R1                   LOAD REGISTER 8 TO PRESERVE\n*                                      POINTER TO COMMAND PROCESSOR\n*                                      PARAMETER LIST\n         GETMAIN R,LV=LDYNAMIC         GETMAIN DYNAMIC WORKAREA\n         LR    R10,R1                  LOAD REGISTER 10 TO PRESERVE\n*                                      POINTER TO WORKAREA\n         ST    R13,4(R10)              STORE ADDRESS OF PREVIOUS\n*                                      SAVEAREA\n         ST    R10,8(,R13)             STORE ADDRESS OF CURRENT\n*                                      SAVEAREA IN PREVIOUS SAVEAREA\n         LR    R13,R10                 LOAD REGISTER 13 WITH ADDRESS OF\n*                                      CURRENT SAVEAREA\n         USING WORKAREA,R13            ESTABLISH ADDRESSABILITY TO\n*                                      DYNAMIC WORKAREA\n         GETMAIN R,LV=RECSIZE          GETMAIN RECORD AREA          WFB\n         ST    R1,ALNDSECT             SAVE ADDRESS OF RECORD      GTEL\n*\n***********************************************************************\n*                                                                     *\n*        BUILD PARSE AND DAIR PARAMETER LISTS USING COMMAND           *\n*           PROCESSOR PARAMETER LIST                                  *\n*        INITIALIZE OUTPUT DATA CONTROL BLOCKS IN WORKAREA            *\n*                                                                     *\n***********************************************************************\n*\n         USING CPPL,R8                 ESTABLISH ADDRESSABILITY TO CPPL\n         LA    R4,PPLSECT              LOAD ADDRESS OF PARSE PARAMETER\n*                                      LIST\n         USING PPL,R4                  ESTABLISH ADDRESSABILITY TO PPL\n         LA    R6,DAPLSECT             LOAD ADDRESS OF DAIR PARAMETER\n*                                      LIST\n         USING DAPL,R6                 ESTABLISH ADDRESSABILITY TO DAPL\n         LA    R5,IOPLSECT             LOAD ADDRESS OF PUTLINE\n*                                      PARAMETER LIST\n         USING IOPL,R5                 ESTABLISH ADDRESSABILITY TO IOPL\n         L     R1,CPPLUPT              LOAD POINTER TO USER PROFILE\n*                                      TABLE FROM CPPL\n         L     R2,CPPLECT              LOAD POINTER TO ENVIRONMENT\n*                                      CONTROL TABLE FROM CPPL\n         SLR   R3,R3                   ZERO REGISTER 3\n         ST    R3,ECB                  STORE REGISTER AS ECB FOR PPL\n         LA    R3,ECB                  LOAD ADDRESS OF ECB\n         STM   R1,R3,DFPLSECT          STOR UPT,ECT,ECB IN DFPL    GTEL\n         STM   R1,R3,PPLSECT           STORE ADDRESS OF UPT, ECT, AND\n*                                      ECB IN PPL\n         STM   R1,R3,DAPLSECT          STORE ADDRESS OF UPT, ECT, AND\n*                                      ECB IN DAPL\n         STM   R1,R3,IOPLSECT          STORE ADDRESS OF UPT, ECT, AND\n*                                      ECB IN IOPL\n         LA    R3,IOPB                 LOAD ADDRESS OF PUTLINE\n*                                      PARAMETER BLOCK\n         ST    R3,IOPLIOPB             STORE IOPB ADDRESS IN IOPL\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** START OF GTEL MOD ************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*   INITIALIZE DFPL AND DFPB SO REST OF NAME CAN BE DETERMINED\n         LA    R3,DFPBSECT             GET ADDRESS OF DFPB\n         ST    R3,DFPLSECT+12          PUT IT IN THE CNTL BLK\n         USING  DFPB,R3                TELL ASSEMBLER\n         LA     R2,DFPBDSL             GET ADDRESS OF DSN LENGTH\n         ST     R2,DFPBDSN             SAVE IT\n         LA     R2,DFPBQUA             GET ADDRESS OF QUAL\n         ST     R2,DFPBQUAL            STORE IT\n         MVI    DFPBCODE,DFPB04        MOVE IN TYPE\n         MVC    DFPBPSCB,CPPLPSCB      MOVE IN PSCB ADDRESS\n         MVI    DFPBCNTL,DFPBRET       MOVE IN DFPBRET\n         XC     DFPBCAT(8),DFPBCAT     CLEAR AREA\n         DROP    R3\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** END OF GTEL MOD **************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         MVC   PPLPCL,PCLADDR          MOVE POINTER TO PARAMETER\n*                                      CONTROL LIST INTO PPL\n         LA    R2,PARSBACK             LOAD ADDRESS OF FULLWORD TO\n*                                      CONTAIN ADDRESS OF PDE RETURNED\n*                                      BY PARS\n         ST    R2,PPLANS               STORE POINTER TO RETURN ADDRESS\n         MVC   PPLCBUF,CPPLCBUF        MOVE POINTER TO COMMAND BUFFER\n*                                      INTO PPL\n*DELETED LA    R2,PPLUWA               LOAD ADDR OF USER WORK AREA  WFB\n*DELETED ST    R2,PPLUWA               STORE ADDRESS IN PPL         WFB\n         ST    R13,PPLUWA              PASS THE DYNAMIC WORK AREA   WFB\n*                                      TO PARSE VALIDITY CHECK RTNE WFB\n         MVC   DAPLPSCB,CPPLPSCB       MOVE POINTER TO PSCB INTO DAPL\n         DROP  R4,R5,R6,R8             DROP ADDRESSABILITY TO CPPL,\n*                                      IOPL, DAPL, AND PPL\n         MVC   OUTPUTA(OUTPUTAL),OUTPUTAC  MOVE ASA DCB CONSTANT INTO\n*                                      ASA DCB IN WORKAREA\n         MVC   OUTPUTM(OUTPUTML),OUTPUTMC  MOVE MACHINE DCB CONSTANT\n*                                      INTO MACHINE DCB IN WORKAREA\n*\n***********************************************************************\n*                                                                     *\n*        CALLTSSR TO PARSE (ENTRY NAME IKJPARS)                       *\n*        ON RETURN PARSBACK -> PDL                                    *\n*        HANDLE ALL ERROR CODES RETURNED BY PARS                      *\n*        IF NECESSARY CALL GENERAL FAIL SERVICE ROUTINE               *\n*                                                                     *\n***********************************************************************\n*\n         CALLTSSR  EP=IKJPARS,MF=(E,PPLSECT)\n*                                      CALL PARS TO PARSE COMMAND\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO\n         BZ    GOODPARS                YES....GO TO GOOD PARS ROUTINE\n         C     R15,FULL4               SEE IF RETURN CODE IS FOUR\n         BE    RETURN                  YES....PARS ISSUED ERROR\n*                                      MESSAGE.  GO CLEANUP AND RETURN\n         C     R15,FULL20              SEE IF RETURN CODE IS TWENTY\n         BE    RETURN                  YES....VALIDITY CHECKING\n*                                      ROUTINE ISSUED ERROR MESSAGE.\n*                                      GO CLEANUP AND RETURN\n         XC    GFPARMS(GFLENGF),GFPARMS  INITIALIZE PARMLIST FOR\n*                                      GENERAL FAIL TO ZEROS\n         LA    R1,GFPARMS              LOAD ADDRESS OF PARMLIST\n         ST    R1,GFPARMP              STORE ADDRESS AS POINTER TO\n*                                      PARMLIST\n         ST    R15,GFRCODE             STORE RETURN CODE IN PARMLIST\n         LA    R1,GFPARSE              LOAD CALLER ID FOR PARS\n         STH   R1,GFCALLID             STORE CALLER ID IN PARMLIST\n         L     R1,SAVEAREA+4           LOAD ADDRESS OF PEVIOUS\n*                                      SAVEAREA\n         L     R1,24(R1)               LOAD POINTER TO CPPL\n         ST    R1,GFCPPLP              STORE POINTER TO CPPL IN\n*                                      PARMLIST\n         LA    R1,ECB                  LOAD ADDRESS OF OPTIONAL ECB\n         ST    R1,GFECBP               STORE POINTER TO ECB IN\n*                                      PARMLIST\n         SLR   R1,R1                   ZERO REGISTER 1\n         ST    R1,ECB                  SET OPTIONAL ECB TO ZERO\n         LINK  EP=IKJEFF19,MF=(E,GFPARMP)  LINK TO GENERAL FAIL SERVICE\n*                                      ROUTINE TO HANDLE RETURN CODE\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO\n         BZ    RETURN                  YES....GO CLEANUP AND RETURN\n         LR    R8,R15                  LOAD REGISTER 8 WITH RETURN\n*                                      CODE\n         BAL   R14,SETCODE             GO CONVERT CODE TO DECIMAL\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(GNRLERR,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      GENERAL FAIL ERROR MESSAGE\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(RETNCD,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DECIMAL RETURN CODE\n         DROP  R15                                                  WFB\n         B     RETURN                  GO CLEANUP AND RETURN\n*\n***********************************************************************\n*                                                                     *\n*        SET UP ADDRESSABILITY TO PDL                                 *\n*           AND LOAD REGISTER 6 WITH ADDRESS OF DSNAME PDE            *\n*                                                                     *\n***********************************************************************\n*\nGOODPARS DS    0H\n         L     R9,PARSBACK             LOAD POINTER TO PARS ANSWER\n         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY TO PDL\n         LA    R6,DSNAMES              LOAD POINTER TO DSNAME LIST\n         MVI   VOLBIT,BLANK            BLANK OUT THE VOLUME WORK AREA\n         MVC   VOLUME,VOLBIT           CONTINUE BLANKING THE VOLUME\n         MVC   VOLHEAD,BLANKS          BLANK OUT THE HEADING CONST  WFB\n         MVC   VOLNAME,BLANKS          BLANK OUT THE HEADING VOLUME WFB\n         MVC   UNIT,BLANKS             BLANK OUT THE UNIT WORK AREA WFB\n         CLC   PNOMSG(2),HALF1         SEE IF NOMSG SPECIFIED       WFB\n         BNE   CHKDSN                  NO, GO SEE IF DSNAME GIVEN   WFB\n         OI    VOLBIT,NOMSG            YES, TURN ON FLAG FOR LATER  WFB\nCHKDSN   DS    0H                                                   WFB\n         L     R1,0(,R6)               GET ADDRESS OF DSNAME        WFB\n         CLI   0(R1),C'*'              SEE IF DSNAME IS ASTERISK    WFB\n         BNE   CHKVSER                 NO, GO SEE IF VOLUME GIVEN   WFB\n         CLC   PDDNAME(2),HALF1        SEE IF DDNAME SPECIFIED      WFB\n         BE    CHKFOLD                 YES, SKIP UNIT VOL, CHK FOLD WFB\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(NODSNDD,SINGLE,DATA),MF=(E,IOPLSECT)       WFB\n*                                      NO DSN OR DD GIVEN MESSAGE   WFB\n         DROP  R15                                                  WFB\n         B     RETURN                                               WFB\nCHKVSER  DS    0H                                                   WFB\n         CLC   PVOL(2),HALF1           SEE IF VOLUME SPECIFIED\n         BNE   CHKFOLD                 NO.....GO SEE IF FOLD IS DESIRED\n         L     R7,SVOL                 LOAD POINTER TO VOLUME\n         LH    R8,SVOL+4               LOAD LENGTH OF VOLUME\n         BCTR  R8,0                    DECREMENT LENGTH FOR EXECUTE OF\n*                                      MOVE\n         EX    R8,MOVEVOL              MOVE VOLUME INTO WORK AREA\n         OI    VOLBIT,HIGH             INDICATE VOLUME PRESENT\n         MVC   VOLHEAD,VOLCONST        MOVE '   VOLUME: ' TO HEAD   WFB\n         MVC   VOLNAME,VOLUME          MOVE VOLUME SER TO HEADING   WFB\n         CLC   PUNIT(2),HALF1          SEE IF UNIT SPECIFIED        WFB\n*                                 ===> O N L Y  IF VOLUME SPECIFIED WFB\n         BNE   CHKFOLD                 NO,GO SEE IF FOLD IS DESIRED WFB\n         L     R7,SUNIT                LOAD POINTER TO UNIT         WFB\n         LH    R8,SUNIT+4              LOAD LENGTH OF UNIT          WFB\n         BCTR  R8,0                    DECREMENT LENGTH FOR EXECUTE WFB\n         EX    R8,MOVEUNIT             MOVE UNIT INTO WORK AREA     WFB\n         OI    VOLBIT,MID1             INDICATE UNIT PRESENT        WFB\nCHKFOLD  DS    0H\n         CLC   PFOLD(2),HALF1          SEE IF FOLD SPECIFIED\n         BNE   CHKHEAD                 NO.....GO LOOP THROUGH DSNS GTEL\n         OI    VOLBIT,LOW              INDICATE FOLD PRESENT\nCHKHEAD  DS    0H\n         CLC   PHEAD(2),HALF1          SEE IF NOHEAD SPECIFIED\n         BNE   NEXT                    NO.....GO LOOP THROUGH DSNAMES\n         OI    VOLBIT,MID2             INDICATE NOHEAD PRESENT     GTEL\n         DROP  R9                      DROP ADDRESSABILITY TO PDL\n*\n***********************************************************************\n*                                                                     *\n*        LOOP THROUGH DSNAME LIST RETURNED BY PARS                    *\n*                                                                     *\n***********************************************************************\n*\nNEXT     DS    0H\n         LA    R1,PRINTI               LOAD POINTER TO DDNAME TO BE\n*                                      FREED\n         BAL   R2,FREEDD               BRANCH TO FREE ROUTINE\n         LTR   R8,R8                   SEE IF RETURN CODE FROM FREE IS\n*                                      ZERO\n         BNZ   CLOSDCBS                NO.....GO CLOSE DCBS AND RETURN\n         L     R5,0(R6)                LOAD POINTER TO DSNAME\n         CLI   0(R5),C'*'              SEE IF DSNAME IS ASTERISK    WFB\n         BE    ALLOCDDN                YES, GO PROCESS DDNAME       WFB\n         LH    R4,4(R6)                LOAD LENGTH OF DSNAME\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** START OF GTEL MOD ************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*   DETERMINE THE FULL DATASET NAME GIVEN\n         STH   R4,DFPBDSL              STORE LENGTH OF DSN\n         TM    6(R6),X'40'             IN QUOTES\n         BO    GTENOQ                  YES, SKIP\n         BCTR  R4,0                    DECREMENT COUNT\n         MVC   DFPBNAME,BLANKS         MOVE IN BLANKS\n         EX    R4,DFPBMVE              MOVE IN DSN GIVEN\n         LA    R4,1(R4)                BUMP COUNT                ARAMCO\n         LA    R1,DFPLSECT             GET ADDRESS OF ECT\n         MVC   DFPBQUA,BLANKS          BLANK QUALIFIER\n         CALLTSSR  EP=IKJEHDEF         GO TO DEFAULT ROUTINE\nGTEDEF   LTR    R15,R15                TEST RETURN CODE\n         BNZ    GTENOQ                 NON ZERO SKIP\nGTEOK    LA     R5,DFPBNAME            RESTORE REGS\n         LH     R4,DFPBDSL             GET NEW LENGTH\nGTENOQ   DS    0H\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** END OF GTEL MOD **************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         STCM  R4,3,DSNLEN             STORE LENGTH OF DSNAME\n         BCTR  R4,0                    DECREMENT LENGTH FOR EXECUTE OF\n*                                      MOVE\n         LA    R8,DAP08                LOAD ADDRESS OF DAPB FOR 08\n         USING DAPB08,R8               ESTABLISH ADDRESSABILITY TO DAPB\n         MVC   DAPB08(DAPB08L),DAPB08C MOVE CONSTANTS INTO DAPB\n         LA    R1,DSNLEN               LOAD POINTER TO DSN BUFFER\n         ST    R1,DA08PDSN             STORE POINTER TO DSN BUFFER IN\n*                                      DAPB\n         MVI   DSNBUF,BLANK            BLANK OUT THE DSNAME BUFFER\n         MVC   DSNBUF+1(43),DSNBUF     FINISH BLANKING OUT THE BUFFER\n         EX    R4,MOVEDSN              MOVE IN THE DSNAME\n         TM    14(R6),HIGH             SEE IF MEMBER NAME IS PRESENT\n         BNO   CHKPASS                 NO.....GO CHECK IF THERE IS A\n*                                      PASSWORD\n         L     R5,8(R6)                LOAD POINTER TO THE MEMBER NAME\n         LH    R4,12(R6)               LOAD LENGTH OF MEMBER NAME\n         BCTR  R4,0                    DECREMENT LENGTH FOR EXECUTE OF\n*                                      MOVE\n         EX    R4,MOVEMEM              MOVE IN THE MEMBER NAME\nCHKPASS  DS    0H\n         MVC   MEMNAME,DA08MNM         MOVE MEMBER NAME INTO HEADER 2\n         TM    22(R6),HIGH             SEE IF PASSWORD IS PRESENT\n         BNO   CHKVOL                  NO.....GO SEE IF VOLUME PRESENT\n         L     R5,16(R6)               LOAD POINTER TO THE PASSWORD\n         LH    R4,20(R6)               LOAD LENGTH OF PASSWORD\n         BCTR  R4,0                    DECREMENT LENGTH FOR EXECUTE OF\n*                                      MOVE\n         EX    R4,MOVEPASS             MOVE IN THE PASSWORD\nCHKVOL   DS    0H\n         TM    VOLBIT,HIGH             SEE IF VOLUME IS PRESENT\n         BNO   ALLOCDD                 NO.....GO ALLOCATE DATA SET\n         MVC   DA08SER,VOLUME          MOVE IN THE VOLUME SERIAL\n         TM    VOLBIT,MID1             SEE IF UNIT IS PRESENT       WFB\n*                                 ===> O N L Y  IF VOLUME SPECIFIED WFB\n         BNO   ALLOCDD                 NO.....GO ALLOCATE DATA SET  WFB\n         MVC   DA08UNIT,UNIT           MOVE IN THE UNIT TYPE        WFB\nALLOCDD  DS    0H\n         SLR   R4,R4                   ZERO REGISTER 4\n         ST    R4,ECB                  STORE REGISTER 4 AS ECB\n         LA    R1,DAPLSECT             LOAD ADDRESS OF DAPL\n         USING DAPL,R1                 ESTABLISH ADDRESSABILITY TO DAPL\n         ST    R8,DAPLDAPB             STORE ADDRESS OF DAPB IN DAPL\n         DROP  R1                      DROP ADDRESSABILITY TO DAPL\n         CALLTSSR EP=IKJDAIR           CALL DAIR TO ALLOCATE DATASET\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO\n         BZ    OUTPUT                  YES....GO PRINT DATASET\n         MVI   DFID+1,DFDAIR           SET DAIRFAIL ID TO INDICATE DAIR\n         BAL   R2,DAIRFAIL             GO TO DAIRFAIL ROUTINE TO HAVE\n*                                      ERROR MESSAGE PUT OUT\nNOTPMESS DS    0H\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(DSNNOTP,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATASET NOT PRINTED MESSAGE\n         DROP  R15                                                  WFB\n         B     EXITMSG                 GO PUT OUT DATASET AND MEMBER\n*                                      NAMES\n*\n***********************************************************************\n*                                                                     *\n*        DETERMINE DATASET TYPE AND CALL PRINT ROUTINE                *\n*                                                                     *\n***********************************************************************\n*\nOUTPUT   DS    0H\n         TM    DA08DSO,DSOPS           X'40' PHYSICAL SEQUENTIAL\n         BO    PRINTIT                 YES....GO PRINT DATASET\n         CLC   DA08MNM,BLANKS          SEE IF MEMBER NAME IS BLANK\n         BNE   PRINTIT                 NO.....GO TREAT AS SEQUENTIAL\n         TM    DA08DSO,DSOPO           X'02' PARTITIONED\n         BO    SCROLLIT                YES....GO SCROLL DIRECTORY\n         DROP  R8                      DROP ADDRESSABILITY TO DAPB\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(NOTPSPO,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      NOT PARTITIONED OR SEQUENTIAL\n*                                      MESSAGE\n         DROP  R15                                                  WFB\n         B     NOTPMESS                GO PUT NOT PRINTED MESSAGE\n*                                                                   WFB\nALLOCDDN DS    0H                                                   WFB\n         L     R1,24(,R6)              LOAD POINTER TO NEXT DSN     WFB\n         C     R1,ENDCHAIN             IS DSN=* LAST OR ONLY NAME ? WFB\n         BE    CHKINFO                 YES, GO GET DSN, DSORG INFO  WFB\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(NOTLAST,SINGLE,DATA),MF=(E,IOPLSECT)  PUT  WFB\n*                                      DSN=* IS NOT LAST OR ONLY    WFB\n*                                      MESSAGE                      WFB\n         DROP  R15                                                  WFB\n         B     NOTPMESS                GO PUT NOT PRINTED MESSAGE   WFB\nCHKINFO  DS    0H                                                   WFB\n         LA    R8,REQBLK               GET POINTER TO REQUEST BLOCK WFB\n         ST    R8,RBPTR                INITIALIZE REQUEST BLOCK PTR WFB\n         MVI   RBPTR,S99RBPND          INDICATE END OF PARM LIST    WFB\n         USING S99RB,R8                ESTABLISH ADDRESSABILITY TO  WFB\n*                                      REQUEST BLOCK                WFB\n         MVC   S99RBLN(RBLEN),REQBLKC  INITALIZE RB                 WFB\n         MVI   S99VERB,S99VRBIN        SET VERB TO INFO RETRIEVAL   WFB\n         LA    R1,TEXTPTRS             GET POINTER TO TEXT POINTERS WFB\n         ST    R1,S99TXTPP             STORE POINTER IN RB          WFB\n         DROP  R8                      DROP ADDRESSABILITY TO RB    WFB\n         USING S99TUPL,R1              ESTABLISH ADDRESSABILITY TO  WFB\n*                                      TEXT UNIT POINTER LIST       WFB\n         LA    R2,TEXTL                ADDRESS PREALLOC DDNAME TEXT WFB\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL        WFB\n         USING S99TUNIT,R2             ESTABLISH ADDRESSABILITY TO  WFB\n*                                      TEXT UNIT                    WFB\n         MVC   S99TUKEY(TEXTLLEN),TEXTLC  INITIALIZE TEXT UNIT L    WFB\n         L     R9,PARSBACK             LOAD POINTER TO PARS ANSWER  WFB\n         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY     WFB\n         L     R5,SDDNAME              GET ADDRESS OF DDNAME        WFB\n         LH    R4,SDDNAME+4            GET LENGTH OF DDNAME         WFB\n         DROP  R9                                                   WFB\n         BCTR  R4,0                    DECREMENT FOR EXECUTE        WFB\n         EX    R4,MOVEDDN              MOVE DDNAME INTO TEXT UNIT   WFB\n         MVC   PREALDDN,S99TUPAR       SAVE PREALLOC DDN FOR LATER  WFB\n         LA    R1,4(,R1)               POINT TO NEXT TEXT UNIT PTR  WFB\n         LA    R2,TEXTM                ADDRESS RETURN DSNAME TEXT U WFB\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL        WFB\n         MVC   S99TUKEY(TEXTMLEN),TEXTMC  INITIALIZE TEXT UNIT M    WFB\n         LA    R1,4(,R1)               POINT TO NEXT TEXT UNIT PTR  WFB\n         LA    R2,TEXTN                ADDRESS RETURN MEMBER TEXT U WFB\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL        WFB\n         MVC   S99TUKEY(TEXTNLEN),TEXTNC  INITIALIZE TEXT UNIT N    WFB\n         LA    R1,4(,R1)               POINT TO NEXT TEXT UNIT PTR  WFB\n         LA    R2,TEXTO                ADDRESS RETURN DSORG TEXT U  WFB\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL        WFB\n         MVC   S99TUKEY(TEXTOLEN),TEXTOC  INITIALIZE TEXT UNIT O    WFB\n         MVI   S99TUPTR,S99TUPLN       INDICATE END TEXT UNIT PTRS  WFB\n         DROP  R1,R2                   DROP ADDRESSABILITY          WFB\n         LA    R1,RBPTR                ADDRESS SVC99 REQUEST BLOCK  WFB\n         DYNALLOC                      ISSUE DYNAMIC ALLOCATION SVC WFB\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO   WFB\n         BZ    CHKDDORG                YES....GO CHECK DSORG TYPE   WFB\n         LA    R1,REQBLK               ADDRESS SVC99 REQUEST BLOCK  WFB\n         MVI   DFID+1,DFSVC99          SET DAIRFAIL ID = DYNALLOC   WFB\n         BAL   R2,DAIRFAIL             GO TO DAIRFAIL ROUTINE TO    WFB\n         B     NOTPMESS                GO PUT NOT PRINTED MESSAGE   WFB\nCHKDDORG DS    0H                                                   WFB\n         LA    R1,TEXTM                ADDRESS RETURNED DSNAME TEXT WFB\n         USING S99TUNIT,R1             ESTABLISH ADDRESSABILITY     WFB\n         MVC   DFPBDSL,S99TULNG        SAVE DSN LEN WHERE EXPECTED  WFB\n         MVC   DSNAME,S99TUPAR         MOVE RETURN DSN INTO HEADER  WFB\n         LA    R1,TEXTN                ADDRESS RETURNED MEMBER TEXT WFB\n         MVC   MEMNAME,S99TUPAR        MOVE RETURN MEM INTO HEADER  WFB\n         MVC   VOLHEAD,DDNCONST        MOVE '   DDNAME: ' TO HEADER WFB\n         MVC   VOLNAME,PREALDDN        MOVE DDNAME TO HEADING       WFB\n         LA    R1,TEXTO                ADDRESS RETURNED DSORG TEXT  WFB\n         TM    S99TUPAR,DSOPS          X'40' PHYSICAL SEQUENTIAL    WFB\n         BO    PRINTIT                 YES....GO PRINT DATASET      WFB\n         CLI   MEMNAME,BLANK           SEE IF MEMBER NAME IS BLANK  WFB\n         BNE   PRINTIT                 NO.....GO TREAT AS SEQUENTIALWFB\n         TM    S99TUPAR,DSOPO          X'02' PARTITIONED            WFB\n         BO    SCROLLIT                YES....GO SCROLL DIRECTORY   WFB\n         DROP  R1                      DROP ADDRESSABILITY TO S99TU WFB\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(NOTPSPO,SINGLE,DATA),MF=(E,IOPLSECT)  PUT  WFB\n*                                      NOT PARTITIONED OR SEQUENTIALWFB\n*                                      MESSAGE                      WFB\n         DROP  R15                                                  WFB\n         B     NOTPMESS                GO PUT NOT PRINTED MESSAGE   WFB\n*\n***********************************************************************\n*                                                                     *\n*        READS RECORDS USING GET MOVE                                 *\n*           AND ATTRIBUTES OF GIVEN DATASET                           *\n*        WRITES THESE SAME RECORDS USING PUT MOVE                     *\n*           AND THE INPUT DATASET ATTRIBUTES                          *\n*                                                                     *\n***********************************************************************\n*\nPRINTIT  DS    0H\n         LA    R8,INPUT                LOAD POINTER TO INPUT DCB\n         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB\n         MVC   INPUT(INPUTL),INPUTC    MOVE INPUT DCB CONSTANT INTO\n*                                      INPUT DCB IN WORKAREA\n         L     R1,0(,R6)               GET ADDRESS OF DSNAME        WFB\n         CLI   0(R1),C'*'              SEE IF DSNAME IS ASTERISK    WFB\n         BNE   OPENINP                 NO, GO OPEN INPUT            WFB\n         MVC   DCBDDNAM,PREALDDN       YES, USE PREALLOCATED DDN(.) WFB\nOPENINP  DS    0H                                                   WFB\n         MVC   OPENLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO OPEN LIST IN WORKAREA\n         OPEN  ((R8),INPUT),MF=(E,OPENLST)  OPEN INPUT DCB\nPRINTS   DS    0H                      BRANCH ADDRESS FOR PRINTING\n*                                      MEMBERS\n         TM    DCBOFLGS,DCBOFOPN       SEE IF DCB OPENED SUCCESSFULLY\n         BNO   NOTPMESS                NO.....GO PUT OUT NOT PRINTED\n*                                      MESSAGE\nCHKCNTRL DS    0H\n         MVC   HEADER,HEADERC          MOVE HEADER INTO DATA AREA\n         TM    DCBRECFM,DCBRECCM       SEE IF CONTROL IS MACHINE\n         BNO   USEA                    NO.....GO TO USE ASA CONTROL\n         LA    R5,OUTPUTM              LOAD ADDRESS OF OUTPUT DCB FOR\n*                                      MACHINE CODE\n         LA    R4,EJECTM               LOAD ADDRESS OF EJECT DATA\n         MVI   HDRCNTL,SKIPM           MOVE INTO HEADER MACHINE CODE\n*                                      FOR SPACE\n         TM    48(R5),DCBOFOPN         SEE IF DCB IS ALREADY OPEN\n         BO    PUTDSN                  YES....GO PUT OUT HEADERS\n         LA    R3,PRINTM               LOAD POINTER TO PRINTM\n         LA    R14,PUTDSN              LOAD ADDRESS FROM RETURN FROM\n*                                      SYSOUT ALLOCATION\n         B     ALLOCOUT                GO TO ALLOCATE SYSOUT\nUSEA     DS    0H\n         LA    R5,OUTPUTA              LOAD ADDRESS OF OUTPUT DCB FOR\n*                                      ASA CODE\n         LA    R4,EJECTA               LOAD ADDRESS OF EJECT DATA\n         TM    48(R5),DCBOFOPN         SEE IF DCB IS ALREADY OPEN\n         BO    PUTDSN                  YES....GO PUT OUT HEADERS\n         LA    R3,PRINTA               LOAD POINTER TO PRINTA\n         BAL   R14,ALLOCOUT            LOAD ADDRESS FOR RETURN AND GO\n*                                      DO SYSOUT ALLOCATION\nPUTDSN   DS    0H\n         TM    VOLBIT,UDKDONE          UDKS WRITTEN ALREADY ?       WFB\n         BO    NOUDK                   YES, SKIP                    WFB\n         L     R9,PARSBACK             LOAD POINTER TO PARS ANSWER  WFB\n         USING IKJPARMD,R9             ESTABLISH ADDRESABILITY      WFB\n         CLC   PUDKFONT(2),HALF1       IS UDK FONT SPECIFIED ?      WFB\n         BNE   NOUDK                   NO, SKIP                     WFB\n         PUT   (R5),UDKRESET           PUT OUT UDK RESET TEXT       WFB\n         PUT   (R5),UDKSET             PUT OUT UDK SET TEXT         WFB\n         L     R15,ALNDSECT            POINT TO RECORD WORK AREA    WFB\n         USING LINDSECT,R15            ESTABLISH ADDRESSABILITY     WFB\n         MVC   RECORD(8),UDKFHEAD      MOVE UDK FONT NAME HEADER    WFB\n         L     R14,SUDKFONT            POINT TO UDK FONT NAME       WFB\n         LH    R1,SUDKFONT+4           GET LENGTH OF UDK FONT NAME  WFB\n         BCTR  R1,0                    DECREMENT FOR EXECUTE        WFB\n         EX    R1,MOVEUDK              MOVE UDK FONT NAME TO RECORD WFB\n         LA    R1,9(,R1)               ADD HEADER LEN TO ACTUAL LEN WFB\n         STH   R1,RECLEN               SAVE IN OUTPUT RECORD        WFB\n         PUT   (R5),(R15)              PUT OUT UDK FONT NAME        WFB\n         DROP  R9,R15                                               WFB\n         PUT   (R5),UDKFSEL            PUT OUT UDK FONT SELECT TEXT WFB\n         OI    VOLBIT,UDKDONE          INDICATE UDKS WRITTEN        WFB\nNOUDK    DS    0H                                                   WFB\n         TM    VOLBIT,MID2             TEST FOR NOHEAD             GTEL\n         BO    NOHEAD                  YES                         GTEL\n         PUT   (R5),(R4)               PUT OUT PAGE EJECT           WFB\n         MVC   HDRTIME(HDRTDLEN),BLANKS  BLANK OUT TIME DATE AREAS  WFB\n         MVC   JS1,=F'0'               INPUT DATE, ZERO FOR CURRENT JUL\n         MVC   JS2,=F'1'               INPUT DATE IS BINARY         JUL\n         MVC   JS4,=A(16+512)          WANT MONTH DY, YEAR HH.MM.SS JUL\n         CALL  JULSUB,(JS1,JS2,JS3,JS4,JS5),VL,MF=(E,CALLMFJ)       JUL\n         MVI   JS3+22,C':'             REPLACE DOT WITH SEMICOLON   JUL\n         MVI   JS3+25,C':'             REPLACE DOT WITH SEMICOLON   JUL\n         MVC   HDRTIME+4(8),JS3+20     HH:MM:SS                     JUL\n         MVC   HDRDATE+4(18),JS3       SEPTEMBER 30, 2012           JUL\n*        CALL  IKJEFLPA,(HDRTIME,HDRDATE),VL,MF=(E,CALLMFL)         WFB\n*        MVC   HDRTIME(4),BLANKS       BLANK OUT BUFFER PREFIX      WFB\n*        MVC   HDRDATE(4),BLANKS       BLANK OUT BUFFER PREFIX      WFB\n         PUT   (R5),HEADER             PUT OUT PAGE 1 HEADER\n         MVC   HEADER2,LDSNAME         MOVE LENGTH AND 'DSNAME=' INTO\n*                                      INTO SECOND HEADER\n         MVC   HEADER2+4(1),HDRCNTL    MOVE IN CONTROL BYTE\n         CLI   MEMNAME,BLANK           SEE IF MEMBER NAME IS BLANK\n         BE    NOMEM                   YES....NO NEED TO PUT IN PARENS\n         MVI   OPENPRN,C'('            MOVE OPEN PAREN INTO DSNAME\n         MVI   CLOSEPRN,C')'           MOVE CLOSE PAREN INTO DSNAME\n         B     PUTHDR2                 GO PUT OUT HEADER 2\nNOMEM    DS    0H\n         MVI   OPENPRN,BLANK           MOVE BLANK INSTEAD OF OPEN AND\n         MVI   CLOSEPRN,BLANK          CLOSE PARENS\nPUTHDR2  DS    0H\n         PUT   (R5),HEADER2            PUT OUT PAGE 1 HEADER 2\n         MVC   HEADER2(4),SPACE        CHANGE HEADER 2 FOR PUT OF BLANK\n*                                      LINE\n         PUT   (R5),HEADER2            PUT OUT BLANK LINE\nNOHEAD   STM   R9,R10,SAVMR9           SAVE REGS 9 AND 10\n         STM   R6,R7,SAVMR6            SAVE REGS 6 AND 7\n         STM   R2,R3,SAVMR2            SAVE REGS 2 AND 3\n         L     R9,ALNDSECT             SET UP RECORD ADDRESS.\n         USING LINDSECT,R9             *\n         SLR   R10,R10                 ZERO OUT R10\n         LH    R7,PAGELEN              MOVE IN PAGELEN\n         TM    VOLBIT,MID2             NOHEAD SPECIFIED ?           WFB\n         BO    NOSUB4                  YES, SKIP SUBTRACTION        WFB\n         SH    R7,HALF4                SUBTRACT FOR HEADER       ARAMCO\nNOSUB4   DS    0H                                                   WFB\n         MVC   RECCC,HDRCNTL           MOVE IN SPACE AS CONTROL\n*                                      CHARACTER\n         TM    DCBRECFM,DCBRECU        SEE IF RECFM U\n         BO    COPYU                   YES....GO HANDLE RECFM U\n         TM    DCBRECFM,DCBRECV        SEE IF RECFM V\n         BO    COPYV                   YES....GO HANDLE RECFM V\nCOPYF    DS    0H\n         TM    DCBRECFM,DCBRECCC       CONTROL CHARACTER?\n         BNZ   COPYFCC                 YES...\n         TM    CCBIT,FORCEASA          USER SAYS CC IN DATA ?       WFB\n         BO    COPYFCC                 YES, PROCESS AS SO           WFB\nCOPYFNC  OI    CCBIT,LOW               TURN ON NOCC BIT\n         LH    R4,DCBLRECL             GET LRECL\n         A     R4,FULL5                ADD LENGTH FOR VB HEADER\n         STH   R4,RECLEN               PUT INTO RECORD HEADER\n         GET   INPUT,RECDATA           GET INPUT\n         BAL   R10,PUTLL               PUT OUT LINE\n         L     R9,ALNDSECT             RELOAD DSECT POINTER\n         B     COPYFNC                 GET NEXT RECORD\nCOPYFCC  LH    R4,DCBLRECL             GET LRECL\n         A     R4,FULL4                ADD LENGTH FOR VB HEADER\n         STH   R4,RECLEN               PUT INTO RECORD HEADER\n         GET   INPUT,RECCC             GET INPUT\n         BAL   R10,PUTLL               PUT INTO RECORD HEADER\n         L     R9,ALNDSECT             RELOAD DSECT POINTER\n         B     COPYFCC                 GET NEXT RECORD\nCOPYV    DS    0H\n         TM    DCBRECFM,DCBRECCC       CONTROL CHARACTER?\n         BNZ   COPYVCC                 IF YES...\n         TM    CCBIT,FORCEASA          USER SAYS CC IN DATA ?       WFB\n         BO    COPYVCC                 YES, PROCESS AS SO           WFB\nCOPYVNC  GET   INPUT,RECLEN+1          GET INPUT\n         OI    CCBIT,LOW               TURN ON NOCC BIT\n         SLR   R15,R15                 ZERO R15\n         ICM   R15,7,RECLEN+1          GET LENGTH\n         A     R15,FULL256             ADD ONE FOR CC\n         STCM  R15,7,RECLEN            REPLACE LENGTH OVER 1\n         MVC   RECCC,HDRCNTL           ADD HDRCNTL\n         BAL   R10,PUTLL               PUT OUT RECORD\n         L     R9,ALNDSECT             RESTORE DSECT ADDRESS\n         B     COPYVNC                 GET NEXT RECORD\nCOPYVCC  GET   INPUT,RECLEN            GET INPUT\n         BAL   R10,PUTLL               PUT OUT RECORD\n         L     R9,ALNDSECT             RESTORE DSECT ADDRESS\n         B     COPYVCC                 GET NEXT RECORD\nCOPYU    DS    0H                      PROCESS RECFM=U\n         TM    DCBRECFM,DCBRECCC       CONTROL CHARACTER?\n         BNZ   COPYUCC                 YES...\n         TM    CCBIT,FORCEASA          USER SAYS CC IN DATA ?       WFB\n         BO    COPYUCC                 YES, PROCESS AS SO           WFB\nCOPYUNC  GET   INPUT,RECDATA           GET RECORD\n         OI    CCBIT,LOW               TURN ON NOCC BIT\n         LH    R4,DCBLRECL             GET LRECL\n         A     R4,FULL5                ADD VB HEADER LENGTH\n         STH   R4,RECLEN               PUT INTO RECORD HEADER\n         BAL   R10,PUTLL               PUT OUT LINE\n         L     R9,ALNDSECT             RELOAD DSECT POINTER\n         B     COPYUNC                 GET NEXT RECORD\nCOPYUCC  GET   INPUT,RECCC             GET INPUT\n         LH    R4,DCBLRECL             GET LRECL\n         A     R4,FULL4                ADD VB HEADER LENGTH\n         STH   R4,RECLEN               STORE INTO RECORD HEADER\n         BAL   R10,PUTLL               PUT INTO RECORD HEADER\n         L     R9,ALNDSECT             RELOAD DSECT POINTER\n         B     COPYUCC                 GET NEXT RECORD\nPUTLL    DS    0H\n         TM    CCBIT,X'99'             NOCC, DS, SS, OR PAGELEN ON?\n         BZ    NOSKIP                  NO, IGNORE LINE-COUNTING\n         LTR   R7,R7                   ANY LINES LEFT ON PAGE?\n         BNZ   LINECT                  YES, DON'T PUT IN PAGE SKIP CC\n         MVI   4(R9),HEXF1             MOVE IN PAGE SKIP CC\n         LH    R7,PAGELEN              RESET LINE COUNT\n         B     NOSKIP                  CONTINUE WITH PUT\nLINECT   TM    CCBIT,MID2              WAS DOUBLE SPACE SPECIFIED?\n         BO    LINEDS                  YES, CHECK LINES LEFT     ARAMCO\n         MVI   4(R9),BLANK             PUT IN SINGLE SPACE CONTROL CHAR\n         B     NOSKIP                  YES, DON'T SKIP TO NEXT PAGE\nLINEDS   BCTR  R7,0                    DECREMENT ONE MORE FOR DS\n         MVI   4(R9),HEXF0             PUT IN DOUBLE SPACE CONTROL CHAR\n         SLR   R2,R2                   EMPTY R2 FOR DIVIDE\n         SLR   R3,R3                   EMPTY R3 FOR DIVIDE\n         SLR   R15,R15                 EMPTY R15 FOR DIVIDE\n         LH    R15,LINELEN             LOAD LINELEN INTO R15\n         LH    R3,RECLEN               PUT REC LENGTH IN R2\n         SH    R3,HALF5                SUBTRACT VB HEADER LENGTH\n         DR    R2,R15                  DIVIDE BY LINELEN\n         CR    R3,R7                   GREATER THAN LINES LEFT ON PAGE?\n         BNH   NOSKIP                  IF NOT....DON'T START NEW PAGE\n         MVI   4(R9),HEXF1             MOVE IN PAGE SKIP CC\n         LH    R7,PAGELEN              RESET LINE COUNT\nNOSKIP   LH    R4,RECLEN               PUT REC LENGTH IN R4\n         TM    VOLBIT,LOW              SEE IF FOLD IS REQUESTED\n         BO    FOLDLOOP                YES....GO FOLD OUTPUT\nPUTLOOP  CH    R4,VBLEN                COMPARE WITH LL\n         BNH   PUTLAST                 WRITE LAST RECORD\n         MVC   0(2,R9),VBLEN           INSERT LENGTH FOR PUT\n         PUT   (R5),(R9)               PUT OUT OUTPUT LINE\n         SH    R4,LINELEN              DECREMENT FOR COMPARE\n         AH    R9,LINELEN              INCREMENT RECORD LOCATN\n         MVI   4(R9),BLANK             MOVE IN NEXT LINE CC\n         TM    CCBIT,X'99'             NOCC, PAGELEN, DS, OR SS SPEC?\n         BZ    PUTLOOP                 NO, DON'T COUNT LINES\n         BCT   R7,PUTLOOP              END OF PAGE?\n         MVI   4(R9),HEXF1             YES, START NEW PAGE\n         LH    R7,PAGELEN              RELOAD PAGELEN\n         B     PUTLOOP                 WRITE NEXT LINE\nFOLDLOOP CH    R4,VBLEN                COMPARE WITH LL\n         BNH   FOLDLAST                WRITE LAST RECORD\n         LH    R15,LINELEN             LOAD LINE LENGTH\n         SH    R15,HALF1               DECREMENT FOR EXECUTE\n         EX    R15,FOLDLINE            EXECUTE FOLD OF LINE\n         MVC   0(2,R9),VBLEN           INSERT LENGTH FOR PUT\n         PUT   (R5),(R9)               PUT OUT OUTPUT LINE\n         SH    R4,LINELEN              DECREMENT FOR COMPARE\n         AH    R9,LINELEN              INCREMENT RECORD LOCATION\n         MVI   4(R9),BLANK             MOVE IN NEXT LINE CC\n         TM    CCBIT,X'99'             NOCC, PAGELEN, DS, OR SS SPEC?\n         BZ    FOLDLOOP                NO, DON'T COUNT LINES\n         BCT   R7,FOLDLOOP             END OF PAGE?\n         MVI   4(R9),HEXF1             YES, START NEW PAGE\n         LH    R7,PAGELEN              RELOAD PAGELEN\n         B     FOLDLOOP                WRITE NEXT LINE\nFOLDLAST LR    R15,R4                  LOAD REMAINING LINE LENGTH\n         SH    R15,HALF6               DECREMENT FOR EXECUTE\n         EX    R15,FOLDLINE            EXECUTE FOLD OF LINE\nPUTLAST  STH   R4,0(R9)                INSERT LENGTH FOR PUT\n         PUT   (R5),(R9)               PUT OUT OUTPUT LINE\n         BCTR  R7,0                    DECREMENT PAGELEN\n         BR    R10                     GO GET NEXT RECORD\nEXITI    DS    0H\n         DROP  R9\n         LM    R9,R10,SAVMR9           RESTORE R9 AND R10\n         LM    R6,R7,SAVMR6            RESTORE R6 AND R7\n         LM    R2,R3,SAVMR2            RESTORE R2 AND R3\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** END OF GTEL MOD **************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nEXIT     DS    0H\n         TM    DCBOFLGS,DCBOFOPN       SEE IF INPUT DCB IS OPEN\n         BNO   EXITMSG                 NO....GO PUT OUT DATASET AND\n*                                      MEMBER NAMES\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST IN WORKAREA\n         CLOSE ((R8),),MF=(E,CLOSLST)  CLOSE INPUT DCB\nEXITMSG  DS    0H\n         L     R1,0(,R6)               GET ADDRESS OF DSNAME        WFB\n         CLI   0(R1),C'*'              SEE IF DSNAME IS ASTERISK    WFB\n         BE    EXNOFREE                YES, DO NOT FREE DDN(...)    WFB\n         LA    R1,PRINTI               FREE INPUT DATASET          GTEL\n         BAL   R2,FREEDD               FREE INPUT DATASET          GTEL\nEXNOFREE DS    0H                                                   WFB\n         TM    VOLBIT,NOMSG            IS NOMSG SPECIFIED ?         WFB\n         BO    CONTINUE                YES, CONTINUE WITH NEXT DSN  WFB\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(DSNMSG,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATA SET NAME MESSAGE\n         DROP  R15                                                  WFB\n         LH    R4,DFPBDSL              LOAD LENGTH OF DSNAME       GTEL\n         A     R4,FULL4                INCREMENT LENGTH FOR PUTLINE\n         SLL   R4,16                   SHIFT LENGTH TO HIGH ORDER BYTES\n         STCM  R4,15,DSNLENP           STORE LENGTH OF PUTLINE\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(DSNLENP,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATA SET NAME MESSAGE\n         DROP  R15                                                  WFB\n         CLI   MEMNAME,BLANK           MEMBER NAME BLANK ?          WFB\n         BE    CONTINUE                YES, SKIP MEMBER MESSAGE     WFB\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(MEMMSG,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATA SET NAME MESSAGE\n         DROP  R15                                                  WFB\n         MVC   MEMNAMEL(2),HALF12      FORCE MEMNAME LENGTH 8 (+4)  WFB\n         MVC   MEMNAMEL+2(2),HALF0     (REQUIRED ZERO FOR PUTLINE)  WFB\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(MEMNAMEL,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      MEMBER NAME\n         DROP  R15                                                  WFB\n         B     CONTINUE                GO CONTINUE WITH NEXT DATASET\n         DROP  R8                      DROP ADDRESSABILITY TO INPUT DCB\nERRI     DS    0H\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(SYNADI,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATASET NOT PRINTED DUE TO SYNAD\n*                                      ERROR ON INPUT DATASET MESSAGE\n         DROP  R15                                                  WFB\n         B     EXIT                    GO SEE IF INPUT DCB IS OPEN\nERRO     DS    0H\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(SYNADO,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATASET NOT PRINTED DUE TO\n*                                      SYNAD ERROR MESSAGE          WFB\n         DROP  R15                                                  WFB\n         B     CLOSDCBS                GO CLOSE OPEN DCBS AND RETURN\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        READ THE DIRECTORY OF A PDS                                  *\n*           THEN EITHER LIST MEMBER NAMES,                            *\n*           PRINT MEMBERS,                                            *\n*           OR LIST MEMBER NAMES AND PRINT MEMBERS                    *\n*                                                                     *\n***********************************************************************\n*\nSCROLLIT DS    0H\n         ST    R6,SAVER6               SAVE REGISTER 6\n         L     R9,PARSBACK             LOAD ADDRESS PARS ANSWER\n         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY TO PDL\n         CLC   PLIST,HALF2             SEE IF NOLIST SPECIFIED\n         BL    CONTSCR                 LOW....CONTINUE WITH SCROLL\n         CLC   PPRINT,HALF2            SEE IF NOPRINT SPECIFIED\n         BE    CONTINUE                YES....SKIP SCROLL\n         DROP  R9                      DROP ADDRESSABILITY TO PDL\nCONTSCR  DS    0H\n         LA    R8,DIRECT               LOAD POINTER TO DIRECTORY DCB\n         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB\n         MVC   DIRECT(DIRECTL),DIRECTC MOVE DIRECTORY DCB CONSTANT INTO\n*                                      DIRECTORY DCB IN WORKAREA\n         L     R1,0(,R6)               GET ADDRESS OF DSNAME        WFB\n         CLI   0(R1),C'*'              SEE IF DSNAME IS ASTERISK    WFB\n         BNE   OPENDIR                 NO, GO OPEN INPUT DIRECTORY  WFB\n         MVC   DCBDDNAM,PREALDDN       YES, USE PREALLOCATED DDN(.) WFB\nOPENDIR  DS    0H                                                   WFB\n         MVC   OPENLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO OPEN LIST IN WORKAREA\n         OPEN  ((R8),INPUT),MF=(E,OPENLST)  OPEN DIRECTORY DCB\n         TM    DCBOFLGS,DCBOFOPN       SEE IF DCB OPENED SUCCESSFULLY\n         BNO   NOTPMESS                NO.....GO PUT OUT NOT PRINTED\n*                                      MESSAGE\n         DROP  R8                      DROP ADDRESSABILITY TO DCB\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        GETMAIN MEMBER TABLE FOR STORAGE OF DIRECTORY NAMES, ETC.    *\n*           INITIALIZE TABLE                                          *\n*                                                                     *\n***********************************************************************\n*\n         L     R0,MEMDATL              LOAD LENGTH OF GETMAIN FOR\n*                                      MEMBER TABLE\n         LR    R2,R0                   SAVE IN REGISTER 2\n         GETMAIN R,LV=(0)              GETMAIN MEMBER TABLE STORAGE\n         ST    R1,MEMTABLE             SAVE ADDRESS OF MEMBER TABLE\n         ST    R1,PRESENT              ALSO SAVE ADDRESS AS TABLE\n*                                      IN USE\n         LA    R3,0(R2,R1)             LOAD ADDRESS OF END OF TABLE\n         ST    R3,ENDTABLE             STORE ADDRESS OF TABLE END\n         SLR   R4,R4                   ZERO REGISTER 4\n         ST    R4,0(R1)                STORE AS FIRST WORD OF MEMBER\n*                                      TABLE\n         LA    R4,8(R1)                LOAD REGISTER 4 AS POINTER TO\n*                                      THE FIRST ENTRY\n         USING MEMDSECT,R4             ESTABLISH ADDRESSABILITY TO\n*                                      MEMBER TABLE DSECT\n         SLR   R5,R5                   INITIALIZE MEMBER COUNT TO ZERO\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        READ DIRECTORY AND BUILD MEMBER TABLE                        *\n*                                                                     *\n***********************************************************************\n*\nGETDIR   EQU   *\n         GET   (R8),DATA               GET A DIRECTORY BLOCK\n         CLC   DATA,HALF12             SEE IF BLOCK IS UNUSED\n         BL    FREEBLK                 YES....GO HANDLE DIRECTORY END\n         LA    R9,DATA+2               LOAD POINTER TO FIRST DIRECTORY\n*                                      ENTRY\n         SLR   R7,R7                   ZERO REGISTER 7 FOR INSERT\n         ICM   R7,3,DATA               INSERT LENGTH USED OF THIS BLOCK\n         LA    R7,DATA-1(R7)           LOAD LAST USED BYTE OF BLOCK\nUNBLOCK  DS    0H\n         MVC   MEMNTTR,0(R9)           PUT NAME AND TTR IN TABLE\n         MVC   CFIELD,11(R9)           PUT C FIELD IN TABLE\n         CLI   MEMBER,HEXFF            SEE IF LAST MEMBER\n         BE    FREEBLK                 YES....GO HANDLE DIRECTORY END\n         IC    R6,CFIELD               INSERT CFIELD INTO REGISTER 6\n         SLL   R6,27                   SHIFT OUT HIGH ORDER BITS\n         SRL   R6,26                   SHIFT RIGHT TO GET LENGTH OF\n*                                      USER DATA\n         LA    R6,12(R6)               ADD STANDARD ENTRY LENGTH\n         LA    R4,MEMSECTN             LOAD PINTER TO NEXT TABLE ENTRY\n         LA    R5,1(R5)                INCREMENT NUMBER OF MEMBERS IN\n*                                      TABLE\n         C     R4,ENDTABLE             SEE IF END OF TABLE\n         BL    NEXTNTRY                LOW.....GO PROCESS NEXT ENTRY\n         LR    R0,R2                   LOAD LENGTH OF TABLE FOR GETMAIN\n         GETMAIN R,LV=(0)              GET NEXT TABLE\n         L     R14,PRESENT             LOAD REGISTER 14 WITH ADDRESS OF\n*                                      LAST TABLE\n         ST    R1,0(R14)               CHAIN MEMBER TABLES TOGETHER\n         ST    R1,PRESENT              ALSO SAVE ADDRESS AS TABLE\n*                                      IN USE\n         LA    R3,0(R2,R1)             LOAD ADDRESS OF TABLE END\n         ST    R3,ENDTABLE             STORE ADDRESS OF TABLE END\n         SLR   R4,R4                   ZERO REGISTER 4\n         ST    R4,0(R1)                STORE AS FIRST WORD OF MEMBER\n*                                      TABLE\n         LA    R4,8(R1)                LOAD REGISTER 4 AS POINTER TO\n*                                      THE FIRST ENTRY\n         STH   R5,4(R14)               STORE MEMBER COUNT IN OLD TABLE\n         SLR   R5,R5                   INITIALIZE MEMBER COUNT TO ZERO\nNEXTNTRY DS    0H\n         BXLE  R9,R6,UNBLOCK           INCREMENT REGISTER 9 WITH\n*                                      REGISTER 6 AND BRANCH\n*                                      LESS THAN OR EQUAL TO\n*                                      REGISTER 7 TO UNBLOCK\n         B     GETDIR                  NO.....GO GET NEXT DIRECTORY\n*                                      BLOCK\n         DROP  R4                      DROP ADDRESSABILITY TO TABLE\n*\n***********************************************************************\n*                                                                     *\n*        LIST MEMBERS IF:                                             *\n*           LIST SPECIFIED OR                                         *\n*           BOTH PRINT AND NOLIST WERE NOT SPECIFIED                  *\n*                                                                     *\n***********************************************************************\n*\nFREEBLK  DS    0H\n         MVC   OPENLST,OPENCLOS        MOVE CONSTANT INTO CLOSE LIST\n         CLOSE ((R8),),MF=(E,OPENLST)  CLOSE DIRECTORY DCB\n         L     R2,PRESENT              LOAD POINTER TO LAST TABLE\n         STH   R5,4(R2)                STORE COUNT OF MEMBERS\n         L     R4,MEMTABLE             LOAD POINTER TO FIRST TABLE\n         CLC   4(2,R4),HALF0           SEE IF THERE WERE ANY MEMBERS\n         BE    ENDMEMB                 ZERO...GO FREE MEMBER TABLE\n         LA    R8,INPUT                LOAD POINTER TO INPUT DCB\n         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB\n         MVC   INPUT(INPUTL),INPUTC    MOVE INPUT DCB CONSTANT INTO\n*                                      INPUT DCB IN WORKAREA\n         L     R1,SAVER6               GET SAVED ADDRESS OF DSN PDE WFB\n         L     R1,0(,R1)               GET ADDRESS OF DSNAME        WFB\n         CLI   0(R1),C'*'              SEE IF DSNAME IS ASTERISK    WFB\n         BNE   OPENMEM                 NO, GO OPEN AGAIN FOR MEMBER WFB\n         MVC   DCBDDNAM,PREALDDN       MOVE DDNAME INTO INPUT DCB   WFB\nOPENMEM  DS    0H                                                   WFB\n         MVC   OPENLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO OPEN LIST IN WORKAREA\n         LA    R1,XLIST                LOAD ADDRESS OF EXIT LIST\n         ST    R1,DCBEXLST             STORE ADDRESS OF EXIT LIST IN\n*                                      DCB\n         LA    R1,SEXIT                LOAD ADDRESS OF EODAD EXIT\n         ST    R1,DCBEODAD             STORE ADDRESS EODAD IN DCB\n         LA    R2,JFCBAREA             LOAD ADDRESS OF JFCBAREA\n         ST    R2,XLIST                STORE ADDRESS IN EXIT LIST\n         MVI   XLIST,X'87'             SET END OF LIST AND JFCB BYTE\n         MVC   RDJL,OPENCLOS           MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO READJFCB LIST IN\n*                                      WORKAREA\n         RDJFCB (INPUT,),MF=(E,RDJL)   READ JFCB INTO JFCBAREA\n         MVC   JFCBELNM,8(R4)          MOVE MEMBER NAME INTO JFCB\n         OI    JFCBIND1,JFCPDS         SET JFCB TO INDICATE PDS MEMBER\n         MVI   JFCDSRG1,HEX00          SET JFCB TO REMOVE OTHER DSORG\n*                                      INDICATORS\n         OPEN  ((R8),INPUT),TYPE=J,MF=(E,OPENLST)  OPEN INPUT DCB\n         L     R9,PARSBACK             LOAD ADDRESS PARS ANSWER\n         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY TO PDL\n         CLC   PLIST,HALF2             SEE IF NOLIST SPECIFIED\n         BE    NOLIST                  YES....SKIP LISTING\n         CLC   PLIST,HALF1             SEE IF LIST SPECIFIED\n         BE    LISTIT                  YES....GO LISTIT\n         CLC   PPRINT,HALF1            SEE IF PRINT SPECIFIED\n         BE    NOLIST                  YES....SKIP LISTING\n         DROP  R9                      DROP ADDRESSABILITY TO PDL\nLISTIT   DS    0H\n         MVC   HEADER,HEADERM          MOVE HEADER INTO DATA AREA\n         TM    DCBRECFM,DCBRECCM       SEE IF CONTROL IS MACHINE\n         DROP  R8                      DROP ADDRESSABILITY TO DCB\n         BNO   SUSEA                   NO.....GO TO USE ASA CONTROL\n         LA    R5,OUTPUTM              LOAD ADDRESS OF OUTPUT DCB FOR\n*                                      MACHINE CODE\n         LA    R4,EJECTM               LOAD ADDRESS OF EJECT DATA\n         MVI   HDRCNTL,SKIPM           MOVE INTO HEADER MACHINE CODE\n*                                      FOR SPACE\n         TM    48(R5),DCBOFOPN         SEE IF DCB IS ALREADY OPEN\n         BO    SPUTDSN                 YES....GO PUT OUT HEADERS\n         LA    R3,PRINTM               LOAD POINTER TO PRINTM\n         LA    R14,SPUTDSN             LOAD ADDRESS FOR RETURN FROM\n*                                      SYSOUT ALLOCATION\n         B     ALLOCOUT                GO TO ALLOCATE SYSOUT\nSUSEA    DS    0H\n         LA    R5,OUTPUTA              LOAD ADDRESS OF OUTPUT DCB FOR\n*                                      ASA CODE\n         LA    R4,EJECTA               LOAD ADDRESS OF EJECT DATA\n         TM    48(R5),DCBOFOPN         SEE IF DCB IS ALREADY OPEN\n         BO    SPUTDSN                 YES....GO PUT OUT HEADERS\n         LA    R3,PRINTA               LOAD POINTER TO PRINTA\n         BAL   R14,ALLOCOUT            LOAD ADDRESS FOR RETURN AND GO\n*                                      DO SYSOUT ALLOCATION\nSPUTDSN  DS    0H\n         PUT   (R5),(R4)               PUT OUT PAGE EJECT\n         PUT   (R5),HEADER             PUT OUT PAGE 1 HEADER\n         MVC   HEADER2,LDSNAME         MOVE LENGTH AND 'DSNAME=' INTO\n*                                      INTO SECOND HEADER\n         MVC   HEADER2+4(1),HDRCNTL    MOVE IN CONTROL BYTE\n         MVI   OPENPRN,BLANK           BLANK OUT MEMBER NAME\n         MVC   MEMNAME(9),OPENPRN      FINISH BLANKING OUT MEMBER NAME\n         PUT   (R5),HEADER2            PUT OUT PAGE 1 HEADER 2\n         L     R2,MEMTABLE             LOAD ADDRESS OF FIRST TABLE\n         MVC   LENGTH,HALF85           SET LENGTH TO 85 BYTES\n         MVC   LENGTH+2,HALF0          ZERO RESERVED BYTES\n         MVC   CNTLBYTE,HDRCNTL        MOVE IN HEADER CONTROL BYTE\n*\n***********************************************************************\n*                                                                     *\n*        LIST MEMBER NAMES                                            *\n*                                                                     *\n***********************************************************************\n*\nSCROLLER DS    0H\n         LA    R10,50                  LOAD LINE COUNT\n         ST    R2,PRESENT              SAVE ADDRESS OF CURRENT TABLE\n         LH    R7,4(R2)                LOAD NUMBER OF MEMBERS IN TABLE\n         LTR   R7,R7                   SEE IF THERE ARE ENTRIES\n         BZ    NOLIST                  NO.....GO PRINT MEMBERS\n         LA    R2,8(R2)                LOAD ADDRESS OF FIRST MEMBER\n         USING MEMDSECT,R2             ESTABLISH ADDRESSABILITY TO\n*                                      MEMBER TABLE ENTRY\nLOOP1    DS    0H\n         LA    R6,DATA                 LOAD ADDRESS OF OUTPUT BUFFER\n         MVI   DATA,BLANK              BLANK OUT OUTPUT BUFFER\n         MVC   DATA+1(79),DATA         FINISH BLANKING BUFFER\n         TM    CFIELD,HIGH             SEE IF THIS IS AN ALIAS\n         BZ    NOTALIAS                NO.....CONTINUE WITH MAIN NAME\n         BAL   R14,LOOKLOOP            GO LOOK FOR MAIN NAME\nNOTALIAS DS    0H\n         MVC   2(8,R6),MEMBER          PUT MEMBER NAME IN OUTPUT BUFFER\n         ST    R2,SAVER2               SAVE REGISTER 2\n         LA    R3,2                    LOAD NUMBER OF COLUMNS LEFT\n         LA    R8,1                    LOAD ENTRY NUMBER\nLOOP2    LA    R8,50(R8)               LOAD POINTER TO NEXT COLUMN\n*                                      ENTRY\n         CR    R8,R7                   SEE IF VALID ENTRY\n         BH    END2                    NO.....GO PRINT LINE\n         LA    R2,600(R2)              LOAD POINTER TO MEMBER NAME\n         LA    R6,30(R6)               LOAD POINTER TO NEXT OUTPUT\n*                                      BUFFER LOCATION\n         TM    CFIELD,HIGH             SEE IF THIS IS AN ALIAS\n         BZ    NOTAL2                  NO.....CONTINUE WITH MAIN NAME\n         BAL   R14,LOOKLOOP            GO LOOK FOR MAIN NAME\nNOTAL2   DS    0H\n         MVC   2(8,R6),MEMBER          PUT MEMBER NAME IN OUTPUT BUFFER\n         BCT   R3,LOOP2                DECREMENT COLUMN COUNT\nEND2     DS    0H\n         PUT   (R5),LINE               PUT OUT OUTPUT LINE\n         L     R2,SAVER2               RELOAD REGISTER 2\n         LA    R2,MEMSECTN             LOAD POINTER TO NEXT MEMBER NAME\n         BCT   R10,MOREROW             DECREMENT ROW COUNT\n         PUT   (R5),(R4)               PUT OUT PAGE EJECT WHEN ZERO\n         B     LOOP3                   RESET COUNTERS\nMOREROW  DS    0H\n         BCT   R7,LOOP1                DECREMENT MEMBER COUNT FOR\n*                                      CURRENT TABLE\nLOOP3    L     R2,PRESENT              LOAD POINTER TO CURRENT TABLE\n         L     R2,0(R2)                LOAD POINTER TO NEXT TABLE\n         LTR   R2,R2                   SEE IF IT WAS THE LAST TABLE\n         BNZ   SCROLLER                NO.....GO LIST OUT NEXT TABLE\n*\n***********************************************************************\n*                                                                     *\n*        PRINT MEMBERS IF:                                            *\n*           PRINT SPECIFIED OR                                        *\n*           BOTH LIST AND NOPRINT WERE NOT SPECIFIED                  *\n*                                                                     *\n***********************************************************************\n*\nNOLIST   DS    0H\n         L     R9,PARSBACK             LOAD ADDRESS PARS ANSWER\n         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY TO PDL\n         CLC   PPRINT,HALF2            SEE IF NOPRINT SPECIFIED\n         BE    ENDMEMB                 YES....GO SKIP PRINT\n         CLC   PPRINT,HALF1            SEE IF PRINT SPECIFIED\n         BE    CONTPRT                 YES....GO PRINT MEMBERS\n         CLC   PLIST,HALF1             SEE IF LIST SPECIFIED\n         BE    ENDMEMB                 YES....GO SKIP PRINT\n         DROP  R9                      DROP ADDRESSABILITY TO PDL\nCONTPRT  DS    0H\n         L     R6,SAVER6               RESTORE REGISTER 6\n         LA    R8,INPUT                LOAD ADDRESS OF INPUT DCB\n         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST IN WORKAREA\n         CLOSE ((R8),),MF=(E,CLOSLST)  CLOSE INPUT DCB\n         DROP  R8                      DROP ADDRESSABILITY TO INPUT DCB\n         TM    VOLBIT,NOMSG            IS NOMSG SPECIFIED ?         WFB\n         BO    NOMEMMSG                YES, SKIP MEMBER MESSAGE     WFB\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(PRTMSG,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATASET PRINT MESSAGE\n         DROP  R15                                                  WFB\n         LH    R4,DFPBDSL              LOAD LENGTH OF DSNAME       GTEL\n         A     R4,FULL4                INCREMENT LENGTH FOR PUTLINE\n         SLL   R4,16                   SHIFT LENGTH TO HIGH ORDER BYTES\n         STCM  R4,15,DSNLENP           STORE LENGTH OF PUTLINE\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(DSNLENP,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATA SET NAME MESSAGE\n         DROP  R15                                                  WFB\nNOMEMMSG DS    0H                                                   WFB\n         L     R2,MEMTABLE             LOAD ADDRESS OF FIRST MEMBER\n*                                      TABLE\n         LH    R3,4(R2)                LOAD NUMBER OF MEMBERS IN TABLE\n         LTR   R3,R3                   SEE IF THERE ARE ANY MEMBERS\n         BZ    ENDMEMB                 NO.....GO TO END OF SCROLLER\n         ST    R2,PRESENT              SAVE ADDRESS OF CURRENT TABLE\n         LA    R2,8(R2)                LOAD POINTER TO MEMBER NAME\nNEXTMEMB DS    0H\n         TM    CFIELD,HIGH             SEE IF THIS IS AN ALIAS ENTRY\n         BO    AGAIN                   YES....DO NOT PRINT IT\nPRINTMEM DS    0H\n         MVC   MEMNAME,MEMBER          MOVE MEMBER NAME INTO HEADER\n         MVC   JFCBELNM,MEMBER         MOVE MEMBER NAME INTO JFCBAREA\n         MVC   OPENLST,OPENCLOS        MOVE CONSTANT INTO OPEN LIST\n         OPEN  ((R8),INPUT),TYPE=J,MF=(E,OPENLST)\n*                                      OPEN INPUT DCB\n         STM   R2,R3,SAVER2            SAVE REGISTERS 2 AND 3\n         B     PRINTS                  GO PRINT MEMBER\nSEXIT    DS    0H\n         LM    R2,R3,SAVER2            RESTORE REGISTERS 2 AND 3\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST IN WORKAREA\n         CLOSE ((R8),),MF=(E,CLOSLST)  CLOSE INPUT DCB\nAGAIN    DS    0H\n         LA    R2,MEMSECTN             LOAD ADDRESS OF NEXT MEMBER\n         BCT   R3,NEXTMEMB             BRANCH TO HANDLE NEXT MEMBER\n         L     R14,PRESENT             ZERO...LOAD CURRENT TABLE\n*                                      ADDRESS\n         L     R2,0(R14)               LOAD ADDRESS OF NEXT TABLE\n         LTR   R2,R2                   SEE IF ZERO, LAST TABLE\n         BZ    ENDMEMB                 NO.....GO HANDLE END OF MEMBERS\n         ST    R2,PRESENT              SAVE ADDRESS OF CURRENT TABLE\n         LH    R3,4(R2)                LOAD NUMBER OF MEMBERS IN NEXT\n*                                      TABLE\n         LTR   R3,R3                   SEE IF ANY MEMBERS IN TABLE\n         BZ    ENDMEMB                 NO.....GO HANDLE END OF MEMBERS\n         LA    R2,8(R2)                LOAD POINTER TO MEMBER NAME\n         B     NEXTMEMB                GO GET NEXT MEMBER\nENDMEMB  DS    0H\n         L     R2,MEMTABLE             LOAD POINTER TO FIRST TABLE\nFREETABS DS    0H\n         LR    R1,R2                   LOAD AREA TO BE FREED\n         L     R2,0(R2)                LOAD POINTER TO NEXT TABLE\n         L     R0,MEMDATL              LOAD SIZE OF AREA TO BE FREED\n         FREEMAIN R,LV=(0),A=(1)       FREE STORAGE GETMAINED FOR TABLE\n         LTR   R2,R2                   SEE IF THERE WAS ANOTHER TABLE\n         BNZ   FREETABS                YES....GO FREE NEXT TABLE\n         L     R6,SAVER6               RESTORE REGISTER 6\n         LA    R8,INPUT                LOAD POINTER TO INPUT DCB\n         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB\n         TM    DCBOFLGS,DCBOFOPN       SEE IF INPUT DCB IS STILL OPEN\n         BNO   EXITMSG                 NO.....GO HANDLE NEXT DATASET\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST IN WORKAREA\n         CLOSE ((R8),),MF=(E,CLOSLST)  CLOSE INPUT DCB\n         DROP  R8                      DROP ADDRESSABILITY TO DCB\n         B     EXITMSG                 GO HANDLE NEXT DATASET\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        PUT OUT SYNAD ERROR MESSAGE,                                 *\n*           GO FREE MEMBER TABLES, AND                                *\n*           CONTINUE WITH NEXT DATASET                                *\n*                                                                     *\n***********************************************************************\n*\nSERRI    DS    0H\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(SYNADI,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATASET NOT PRINTED DUE TO SYNAD\n*                                      ERROR ON INPUT DATASET MESSAGE\n         DROP  R15                                                  WFB\n         B     ENDMEMB                 GO FREE MEMBER TABLES\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        SEARCH FOR MAIN NAME,                                        *\n*           SAME TTR AND NOT AN ALIAS                                 *\n*                                                                     *\n***********************************************************************\n*\nLOOKLOOP DS    0H\n         STM   R3,R4,SAVER3            SAVE REGISTERS 3 AND 4\n         L     R3,MEMTABLE             LOAD ADDRESS OF FIRST TABLE\n         DROP  R2\n         USING MEMDSECT,R3             ESTABLISH ADDRESSABILITY TO\n*                                      MEMBER ENTRY\nLOOP4    DS    0H\n         ST    R3,CURRENT              SAVE ADDRESS OF PRESENT TABLE\n         LH    R4,4(R3)                LOAD NUMBER OF ELEMENTS IN TABLE\n         LTR   R4,R4                   SEE IF THERE ARE ZERO ELEMENTS\n         BZ    NOMAIN                  YES....GO HANDLE MAIN NOT FOUND\n         LA    R3,8(R3)                LOAD ADDRESS OF FIRST MEMBER\nLOOP5    DS    0H\n         CLC   MEMTTR,8(R2)            SEE IF TTRS ARE THE SAME\n         BE    SAMETTR                 YES....GO SEE IF IT IS AN ALIAS\nENDLP5   DS    0H\n         LA    R3,MEMSECTN             LOAD ADDRESS OF NEXT MEMBER\n         BCT   R4,LOOP5                DECREMENT MEMBER COUNT\n         L     R3,CURRENT              LOAD ADDRESS OF THIS TABLE\n         L     R3,0(R3)                LOAD ADDRESS OF NEXT TABLE\n         LTR   R3,R3                   SEE IF IT WAS THE LAST TABLE\n         BNZ   LOOP4                   NO.....GO CHECK NEXT TABLE\n         B     NOMAIN                  GO HANDLE MAIN NOT FOUND\nSAMETTR  DS    0H\n         TM    CFIELD,HIGH             SEE IF THIS IS ALSO AN ALIAS\n         BO    ENDLP5                  YES....GO LOOK FOR ANOTHER TTR\n         MVC   11(8,R6),MEMBER         MOVE MEMBER NAME INTO OUTPUT\n         B     ENDLOOK                 GO TO RETURN TO CALLER\nNOMAIN   DS    0H\n         MVC   11(8,R6),ALIAS          INDICATE THIS IS AN ALIAS\nENDLOOK  DS    0H\n         LM    R3,R4,SAVER3            RESTORE REGISTERS 3 AND 4\n         BR    R14                     RETURN TO CALLER\n         DROP  R3                      DROP ADDRESSABILITY TO TABLE\n*\nCONTINUE DS    0H\n         L     R1,0(,R6)               GET ADDRESS OF DSNAME        WFB\n         CLI   0(R1),C'*'              SEE IF DSNAME IS ASTERISK    WFB\n         BE    CLOSDCBS                YES, DO NOT FOLLOW CHAIN     WFB\n         L     R6,24(R6)               LOAD POINTER TO NEXT DSNAME ON\n*                                      CHAIN\n         C     R6,ENDCHAIN             SEE IF END OF CHAIN IS REACHED\n         BNE   NEXT                    NO.....GO DO NEXT DATASET NAME\nCLOSDCBS DS    0H\n         TM    INPUT+48,DCBOFOPN       SEE IF INPUT DCB IS STILL OPEN\n         BNO   CHKOUTA                 NO.....GO CHECK DCB FOR ASA CODE\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST WORKAREA\n         LA    R5,INPUT                LOAD POINTER TO INPUT DCB\n         CLOSE ((R5),),MF=(E,CLOSLST)  CLOSE INPUT DCB\n         L     R1,0(,R6)               GET ADDRESS OF DSNAME        WFB\n         CLI   0(R1),C'*'              SEE IF DSNAME IS ASTERISK    WFB\n         BE    CHKOUTA                 YES, DO NOT FREE DDN(...)    WFB\n         LA    R1,PRINTI               FREE INPUT DATASET          GTEL\n         BAL   R2,FREEDD               FREE INPUT DATASET          GTEL\nCHKOUTA  DS    0H\n         TM    OUTPUTA+48,DCBOFOPN     SEE IF OUTPUT DCB FOR ASA WAS\n*                                      OPENED\n         BNO   CHKOUTM                 NO.....GO CHECK DCB FOR MACHINE\n*                                      CODE\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST WORKAREA\n         LA    R5,OUTPUTA              LOAD POINTER TO ASA CODE DCB\n         TM    VOLBIT,UDKDONE          WERE UDKS WRITTEN ?          WFB\n         BZ    CLOSEA                  NO, GO CLOSE                 WFB\n         PUT   (R5),UDKRESET           PUT OUT UDK RESET TEXT       WFB\n         NI    VOLBIT,UDKDONE          TURN OFF UDK WRITTEN FLAG    WFB\nCLOSEA   DS    0H                                                   WFB\n         CLOSE ((R5),),MF=(E,CLOSLST)  CLOSE ASA CODE OUTPUT DCB\n         LA    R1,PRINTA               LOAD ADDRESS OF PRINT DDNAME\n         BAL   R2,FREEDD               GO FREE ASA CODE OUTPUT DDNAME\nCHKOUTM  DS    0H\n         TM    OUTPUTM+48,DCBOFOPN     SEE IF OUTPUT DCB FOR MACHINE\n*                                      CODE WAS OPENED\n         BNO   RETURN                  NO.....GO FREE GETMAINED AREAS\n*                                      AND RETURN\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST WORKAREA\n         LA    R5,OUTPUTM              LOAD POINTER TO MACHINE CODE DCB\n         TM    VOLBIT,UDKDONE          WERE UDKS WRITTEN ?          WFB\n         BZ    CLOSEM                  NO, GO CLOSE                 WFB\n         PUT   (R5),UDKRESET           PUT OUT UDK RESET TEXT       WFB\n         NI    VOLBIT,UDKDONE          TURN OFF UDK WRITTEN FLAG    WFB\nCLOSEM   DS    0H                                                   WFB\n         CLOSE ((R5),),MF=(E,CLOSLST)  CLOSE MACHINE CODE OUTPUT DCB\n         LA    R1,PRINTM               LOAD ADDRESS OF PRINT DDNAME\n         BAL   R2,FREEDD               GO FREE MACHINE CODE OUTPUT\n*                                      DDNAME\n*\n***********************************************************************\n*                                                                     *\n*        CLEANUP AREAS GETMAINED BY PARS,                             *\n*           SET RETURN CODE, RESTORE REGISTERS AND                    *\n*           RETURN TO CALLER                                          *\n*                                                                     *\n***********************************************************************\n*\nRETURN   DS    0H\n         IKJRLSA PARSBACK              RELEASE AREAS GETMAINED BY PARS\n         L     R1,ALNDSECT\n         FREEMAIN R,LV=RECSIZE,A=(1)                                WFB\n         LR    R1,R13                  LOAD ADDRESS OF GETMAINED AREA\n         L     R13,4(,R13)             RELOAD ADDRESS OF PREVIOUS SAVE\n*                                      AREA\n         LA    R0,LDYNAMIC             LOAD LENGTH OF GETMAINED AREA\n         FREEMAIN R,LV=(0),A=(1)       FREE GETMAINED AREA\n         SLR   R15,R15                 ZERO REGISTER 15.  RETURN CODE\n*                                      CODE WILL ALWAYS BE ZERO\n         L     R14,12(,R13)            LOAD REGISTER 14 WITH RETURN\n*                                      ADDRESS\n         LM    R0,R12,20(R13)          RESTORE REGISTERS\n         BR    R14                     RETURN\n*\n***********************************************************************\n*                                                                     *\n*        ROUTINE TO CONVERT NONZERO RETURN CODES TO DECIMAL           *\n*           FOR DISPLAY                                               *\n*                                                                     *\n***********************************************************************\n*\nSETCODE  DS    0H\n         CVD   R8,DEC                  CONVERT RETURN CODE TO DECIMAL\n         UNPK  CONV(8),DEC(8)          UNPACK RETURN CODE\n         MVZ   CONV+1(7),CONV          MOVE ZONES IN CONVERTED RETURN\n*                                      CODE\n         MVC   RETNCD(2),HALF12        MOVE LENGTH OF DATA FOR PUTLINE\n         MVC   RETNCD+2(2),HALF0       MOVE IN ZEROES FOR PUTLINE\n         BR    R14                     RETURN\n*\n***********************************************************************\n*                                                                     *\n*        FREE AND REALOCATE PRINTX FILE AS SYSOUT                     *\n*                                                                     *\n***********************************************************************\n*\nALLOCOUT DS    0H\n         STM   14,9,ALCSAVE            SAVE WORK REGISTERS\n*---------------------------------------------------------------------*\n*------------------------- START OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\n         MVC   SETPRTE(SETPRTEL),SETPRTL MOVE SETPRT LIST\n         MVI   SETFLAG,X'00'             AND CLEAR FLAG\n*---------------------------------------------------------------------*\n*--------------------------- END OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\n         LR    R1,R3                   LOAD POINTER TO DDNAME\n         BAL   R2,FREEDD               BRANCH TO FREE ROUTINE\n         LTR   R8,R8                   SEE IF RETURN CODE FROM FREE IS\n*                                      ZERO\n         BNZ   OPENFAIL                NO.....GO PUT OUT OPEN FAILED\n         LA    R8,REQBLK               LOAD POINTER TO REQUEST BLOCK\n         ST    R8,RBPTR                INITIALIZE REQUEST BLOCK POINTER\n         MVI   RBPTR,S99RBPND          INDICATE END OF PARAMETER LIST\n         USING S99RB,R8                ESTABLISH ADDRESSABILITY TO\n*                                      REQUEST BLOCK\n         MVC   S99RBLN(RBLEN),REQBLKC  INITALIZE RB\n         LA    R1,TEXTPTRS             LOAD POINTER TO TEXT POINTERS\n         ST    R1,S99TXTPP             STORE POINTER IN RB\n         DROP  R8                      DROP ADDRESSABILITY TO RB\n         USING S99TUPL,R1              ESTABLISH ADDRESSABILITY TO\n*                                      TEXT UNIT POINTER LIST\n         LA    R2,TEXTA                LOAD POINTER TO FIRST TEXT UNIT\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\n         USING S99TUNIT,R2             ESTABLISH ADDRESSABILITY TO\n*                                      TEXT UNIT\n         MVC   S99TUKEY(TEXTALEN),TEXTAC  INITIALIZE TEXT UNIT A\n         MVC   S99TUPAR(8),0(R3)       MOVE IN PARAMETER (DDNAME)\n         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT\n*                                      POINTER\n         LA    R2,TEXTB                LOAD POINTER TO TEXT UNIT B\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\n         MVC   S99TUKEY(TEXTBLEN),TEXTBC  INITIALIZE TEXT UNIT B\n*\n***********************************************************************\n*                                                                     *\n*        SET UP ADDRESSABILITY TO PDL                                 *\n*           AND SEE IF SYSOUT CLASS/DEST ARE PRESENT                  *\n*           ALSO FORMS/TRAIN/FCB/PROG.                             GTEL\n***********************************************************************\n*\n         L     R9,PARSBACK             LOAD ADDRESS PARS ANSWER\n         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY TO PDL\n         CLC   PCLASS(2),HALF1         SEE IF CLASS SPECIFIED\n         BNE   NOCLASS                 NO.....GO CHECK FOR DESTINATION\n         L     R7,SCLASS               LOAD POINTER TO SYSOUT CLASS\n         MVC   S99TUPAR,0(R7)          MOVE CLASS INTO TEXT UNIT B\nNOCLASS  DS    0H\n         CLC   PDEST(2),HALF1          SEE IF DEST SPECIFIED\n         BNE   NODEST                  NO.....GO CHECK FOR HOLD\n         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT\n*                                      POINTER\n         LA    R2,TEXTC                LOAD POINTER TO TEXT UNIT C\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\n         MVC   S99TUKEY(TEXTCLEN),TEXTCC  INITIALIZE TEXT UNIT C\n         L     R7,SDEST                LOAD POINTER TO DESTINATION\n         CLI   NODELEN+1,0             IS NODE.USERID SPECIFIED ?   WFB\n         BZ    NONODE                  NO, USE TOTAL LENGTH         WFB\n         LH    R6,NODELEN              YES, USE NODE LENGTH         WFB\n         STH   R6,S99TULNG             STORE LENGTH OF DEST IN TU   WFB\n         BCTR  R6,0                    DECREMENT LENGTH FOR EXECUTE WFB\n         EX    R6,MOVEDEST             MOVE NODE INTO TEXT UNIT     WFB\n         LA    R1,4(,R1)               POINT NEXT TEXT UNIT POINTER WFB\n         LA    R2,TEXTK                ADDRESS TEXT UNIT K - USERID WFB\n         ST    R2,S99TUPTR             STORE ADDRESS IN TUPL        WFB\n         MVC   S99TUKEY(TEXTKLEN),TEXTKC  INITIALIZE TEXT UNIT K    WFB\n         LA    R7,2(R6,R7)             POINT PAST 'NODE.' TO USERID WFB\n         LH    R6,SDEST+4              GET TOTAL LENGTH             WFB\n         SH    R6,NODELEN              MINUS NODE LENGTH            WFB\n         SH    R6,HALF2                MINUS 1 FOR DOT, 1 EXECUTE   WFB\n         EX    R6,MOVEDEST             MOVE USERID INTO TEXT UNIT   WFB\n         B     NODEST                                               WFB\nNONODE   DS    0H                                                   WFB\n         LH    R6,SDEST+4              LOAD LENGTH OF DESTINATION ID\n         STH   R6,S99TULNG             STORE LENGTH OF DEST IN TU\n         BCTR  R6,0                    DECREMENT LENGTH FOR EXECUTE OF\n*                                      MOVE\n         EX    R6,MOVEDEST             MOVE DEST INTO TU\nMOVEDEST MVC   S99TUPAR,0(R7)          MOVE TO BE EXECUTED\n*\nNODEST   DS    0H\n         CLC   PHOLD(2),HALF1          SEE IF HOLD SPECIFIED\n         BNE   NOHOLD                  NO.....GO CHECK FOR COPIES\n         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT\n*                                      POINTER\n         LA    R2,TEXTDC               LOAD POINTER TO TEXT UNIT C\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\nNOHOLD   DS    0H\n         CLC   PCOPIES(2),HALF1        SEE IF COPY SPECIFIED\n         BNE   NOCOPY                  NO.....GO ZERO ECB\n         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT\n*                                      POINTER\n         LA    R2,TEXTE                LOAD POINTER TO TEXT UNIT E\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\n         MVC   S99TUKEY(TEXTELEN),TEXTEC  INITIALIZE TEXT UNIT E\n         L     R7,SCOPIES              LOAD POINTER TO COPY FIELD\n         LH    R6,SCOPIES+4            LOAD LENGTH OF COPY FIELD\n         BCTR  R6,0                    DECREMENT REGISTER 6 FOR EXECUTE\n*                                      OF PACK INSTRUCTION\n         EX    R6,PACKCOPY             EXECUTE PACK TO CONVERT COPIES\n*                                      TO ZONED DECIMAL\n         CVB   R6,DEC                  CONVERT ZONED TO BINARY\n         STCM  R6,1,S99TUPAR           STORE NUMBER OF COPIES IN TU\nNOCOPY   DS    0H\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** START OF GTEL MOD ************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         CLC   PFORMS(2),HALF1         SEE IF FORMS SPECIFIED\n         BNE   NOFORMS                 NO.....GO CHECK TRAIN\n         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT\n*                                      POINTER\n         LA    R2,TEXTI                LOAD POINTER TO TEXT UNIT I\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\n         MVC   S99TUKEY(TEXTILEN),TEXTIC  INITIALIZE TEXT UNIT I\n         L     R7,RFORMS               LOAD POINTER TO FORMS FIELD\n         LH    R6,RFORMS+4             LOAD LENGTH OF FORMS FIELD\n         STH   R6,S99TULNG             STORE LENGTH IN TUE\n         BCTR  R6,0                    DECREMENT LENGTH\n         EX    R6,MOVEDEST             MOVE FORMS INTO FIELD\nNOFORMS  DS    0H\n         CLC   PTRAIN(2),HALF1         SEE IF TRAIN SPECIFIED\n         BNE   NOTRAIN                 NO.....GO CHECK FCB\n         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT\n*                                      POINTER\n         LA    R2,TEXTH                LOAD POINTER TO TEXT UNIT G\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\n         MVC   S99TUKEY(TEXTHLEN),TEXTHC  INITIALIZE TEXT UNIT H\n         L     R7,RTRAIN               LOAD POINTER TO TRAIN FIELD\n         LH    R6,RTRAIN+4             LOAD LENGTH OF TRAIN FIELD\n         STH   R6,S99TULNG             SAVE LENGTH OF FCBE\n         BCTR  R6,0                    DECREMENT FOR EX\n         EX    R6,MOVEDEST             MOVE FCB INTO TU\nNOTRAIN  DS    0H\n         CLC   PFCB(2),HALF1           SEE IF FCB  SPECIFIED\n         BNE   NOFCB                   NO.....GO ZERO ECB\n         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT\n*                                      POINTER\n         LA    R2,TEXTG                LOAD POINTER TO TEXT UNIT G\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\n         MVC   S99TUKEY(TEXTGLEN),TEXTGC  INITIALIZE TEXT UNIT G\n         L     R7,RFCB                 LOAD POINTER TO FCB FIELD\n         LH    R6,RFCB+4               LOAD LENGTH OF FCB FIELD\n         STH   R6,S99TULNG             SAVE LENGTH OF FCB IN TUE\n         BCTR  R6,0                    DECREMENT\n         EX    R6,MOVEDEST             MOVE FCB TO TU\nNOFCB    DS    0H\n         CLC   PPROG(2),HALF1          SEE IF PROG SPECIFIED\n         BNE   NOPROG                  NO.....GO ZERO ECB\n         CLI   NODELEN+1,0             IS DEST(NODE.USERID) GIVEN ? WFB\n         BH    NOPROG                  YES, IGNORE PROG             WFB\n*                                      DYNALLOC TEXT UNITS FOR USER WFB\n*                                      AND PROG ARE MUTUAL EXCLUSIV WFB\n         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT\n*                                      POINTER\n         LA    R2,TEXTJ                LOAD POINTER TO TEXT UNIT J\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\n         MVC   S99TUKEY(TEXTJLEN),TEXTJC  INITIALIZE TEXT UNIT J\n         L     R7,RPROG                LOAD POINTER TO PROG FIELD\n         LH    R6,RPROG+4              LOAD LENGTH OF PROG FIELD\n         STH   R6,S99TULNG             SAVE LENGTH OF PROG IN TUE\n         BCTR  R6,0                    DECREMENT FOR MOVE\n         EX    R6,MOVEDEST             MOVE PROG TO TU\nNOPROG   DS    0H\n         CLC   PLINELEN(2),HALF1       SEE IF LL SPECIFIED\n         BNE   LLDEF                   NO...\n         L     R7,RLINELEN             LOAD POINTER TO LL FIELD\n         LH    R6,RLINELEN+4           LOAD LENGTH OF LL FIELD\n         BCTR  R6,0                    DECREMENT FOR PACK\n         EX    R6,ZEROTEST             LINELENGTH 0 ENTERED?\n         BE    LLDEF                   IF YES, USE DEFAULT\n         EX    R6,PACKLEN              CONVERT INTO PACKED DECIMAL\n         CVB   R6,DEC                  CONVERT INTO FIXED BINARY\n         CH    R6,HALF1                LESS THAN ONE?\n         BNL   NOLLDEF                 IF YES, USE DEFAULT\n         CH    R6,HALF208              GREATER THAN 208?\n         BNH   NOLLDEF                 IF YES, USE DEFAULT\nLLDEF    LH    R6,HALF132              PLACE 132 IN R6\nNOLLDEF  STH   R6,LINELEN              STORE INTO LINELEN\n         A     R6,FULL5                ADD LENGTH FOR VB OUTPUT\n         STH   R6,VBLEN                STORE INTO VBLEN1\n         MVI   CCBIT,BLANK             INITIALIZE CCBIT WITH BLANK\n         CLC   PPAGELEN(2),HALF1       SEE IF PL SPECIFIED\n         BNE   PLDEF                   NO...\n         OI    CCBIT,HIGH              YES, SET BIT FOR PAGE LEN\n         L     R7,RPAGELEN             LOAD POINTER TO PL FIELD\n         LH    R6,RPAGELEN+4           LOAD LENGTH OF PL FIELD\n         BCTR  R6,0                    DECREMENT FOR PACK\n         EX    R6,ZEROTEST             PAGELENGTH 0 SPECIFIED?\n         BE    PLDEF                   IF YES, USE DEFAULT\n         EX    R6,PACKPAG              CONVERT INTO PACKED DECIMAL\n         CVB   R6,DEC                  CONVERT INTO FIXED BINARY\n         CH    R6,HALF5                LESS THAN 5?\n         BNL   NOPLDEF                 IF YES, USE DEFAULT\n         CH    R6,HALF120              GREATER THAN 120?         ARAMCO\n         BNH   NOPLDEF                 IF YES, USE DEFAULT\nPLDEF    LH    R6,HALF60               LOAD DEFAULT INTO R6      ARAMCO\nNOPLDEF  STH   R6,PAGELEN              STORE INTO PAGELEN\n         CLC   PSPACE(2),HALF1         SEE IF SINGLE SPACE FORMAT\n         BE    SETSS                   YES...\n         CLC   PSPACE(2),HALF2         SEE IF DOUBLE SPACE FORMAT\n         BE    SETDS                   GO ON\n         CLC   PASA(2),HALF1           USER SAYS ASA IS IN DATA ?   WFB\n         BNE   CCSET                   NO, CONTINUE                 WFB\n         OI    CCBIT,FORCEASA          YES, SET FORCE BIT           WFB\n         B     CCSET                   CONTINUE IF NEITHER SS OR DS\nSETSS    OI    CCBIT,MID1              FOR SINGLE SPACE CC\n         B     CCSET\nSETDS    OI    CCBIT,MID2              FOR DOUBLE SPACE CC\n         LH    R6,PAGELEN              DECREMENT PAGE LENGTH     ARAMCO\n         BCTR  R6,0                                              ARAMCO\n         STH   R6,PAGELEN              BY 1 FOR DS LISTINGS.     ARAMCO\nCCSET    DS    0H\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** END OF GTEL MOD **************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*---------------------------------------------------------------------*\n*------------------------- START OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\n         CLC   PBURST(2),HALF1         WAS BURST PARM \"BURST\"?\n         BNE   NOBURST                 NO, CHECK FLASH\n         OI    SETFLAG,SETBURST        YES, TURN ON FLAG\n         OI    SETPRTE+16,X'80'        AND SET SETPRT BIT\nNOBURST  DS    0H\n         CLC   PFLASH(2),HALF1         ANY FLASH PARM ?\n         BNE   NOFLASH                 NO, CHECK CHARS\n         L     R7,RFLASH               YES, POINT AT PARM\n         LH    R6,RFLASH+4             AND GET LENGTH\n         BCTR  R6,0                    DECREMENT FOR MOVE\n         MVC   SETFLASH(4),BLANKS      BLANK IT OUT\n         MVC   SETFLASH(1),0(R7)\n         EX    R6,*-6                  AND MOVE PARM TO SETPRT\n         OI    SETFLAG,SETFLSH\nNOFLASH  DS    0H\n         CLC   PCHARS(2),HALF1         ANY CHARS PARM ?\n         BNE   CHAREND                 NO, END OF ARAMCO\n         OI    SETFLAG,SETCHAR\n         CLI   RCHARS+8,X'FF'          MORE THAN ONE CHAR SET?\n         BE    CHARSET                 NO, BRANCH\n         USING IHADCB,R15\n         LA    R15,OUTPUTA\n         OI    DCBOPTCD,DCBOPTJ        YES, SET OPTCD=J\n         LA    R15,OUTPUTM AND ON VBM DCB TOO\n         OI    DCBOPTCD,DCBOPTJ\n         DROP  R15\nCHARSET  LA    R15,4                   SET LOOP LIMIT\n         LA    R14,RCHARS              POINT AT FIRST CHARS PDE\n         LA    R2,SETCHARS             AND AT SETPRT CHARS PARM\nCHARLOOP L     R7,0(R14)               POINT TO INPUT CHARS PARM\n         LH    R6,4(R14)               AND GET LENGTH\n         BCTR  R6,0                    DECREMENT FOR MOVE\n         MVC   0(4,R2),BLANKS          BLANK IT OUT\n         MVC   0(0,R2),0(R7)\n         EX    R6,*-6                  AND MOVE PARM TO SETPRT\n         CLI   8(R14),X'FF'            END OF LIST?\n         BE    CHAREND                 YES, EXIT LOOP\n         L     R14,8(R14)              NO, BUMP LOOP\n         LA    R2,4(R2)                POINTERS AND KEEP GOING\n         BCT   R15,CHARLOOP            MAX OF 4 CHARS PARMS\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(CHARMSG,SINGLE,DATA),MF=(E,IOPLSECT)\n         DROP  R15                                                  WFB\n*DELETED B     CHAREND                                              WFB\n*                                      CHARMSG MOVED TO MSG CSECT   WFB\nCHAREND  DS    0H\n*---------------------------------------------------------------------*\n*--------------------------- END OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\n         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT\n*                                      POINTER\n         LA    R2,TEXTFC               LOAD POINTER TO TEXT UNIT F\n*                                      PERMANENTLY ALLOCATED\n*                                      ATTRIBUTE\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\n         MVI   S99TUPTR,S99TUPLN       INDICATE END OF TEXT UNIT\n*                                      POINTER LIST\n         DROP  R1,R2,R9                DROP ADDRESSABILITY TO DSECTS\n         LA    R1,RBPTR                LOAD ADDRESS OF REQUEST BLOCK\n*                                      POINTER\n         DYNALLOC                      ISSUE DYNAMIC ALLOCATION SVC\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO\n         BNZ   ALCFAIL                 NO.....GO AND CALL DAIR FAIL\n         MVC   OPENLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO WORKAREA\n         OPEN  ((R5),(OUTPUT)),MF=(E,OPENLST)\n*                                      OPEN OUTPUT DCB\n         TM    48(R5),DCBOFOPN         SEE IF DCB OPENED SUCCESSFULLY\n         BNO   OPENFAIL                NO.....GO PUT OUT OUTPUT DCB\n*---------------------------------------------------------------------*\n*------------------------- START OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\nCKSETPRT CLI   SETFLAG,X'00'           NEED SETPRT ?\n         BE    NOSETPRT                NO, SKIP IT\n         L     R6,DAPLSECT             ADDRESS UPT\n         USING UPT,R6\n         MVC   SAVEUPT(1),UPTSWS       SAVE UPT SWITCHES\n         NI    UPTSWS,X'FF'-UPTWTP     GET RID OF MSG IEF288I\n         SETPRT (R5),MF=(E,SETPRTE)\n         MVC   UPTSWS(1),SAVEUPT       RESTORE UPT SWITCHES\n         DROP R6\nNOSETPRT DS    0H\n*---------------------------------------------------------------------*\n*--------------------------- END OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\n*                                      NOT OPENED MESSAGE\n         LM    14,9,ALCSAVE            RESTORE REGISTERS\n         BR    R14                     RETURN TO CALLER\nALCFAIL  DS    0H\n         LA    R1,REQBLK               LOAD ADDRESS OF REQUEST\n*                                      BLOCK\n         MVI   DFID+1,DFSVC99          SET DAIR FAIL FOR SVC 99 ERROR\n         BAL   R2,DAIRFAIL             LOAD ADDRESS OF OPEN FAIL AND\n*                                      BRANCH TO DAIRFAIL ROUTINE\nOPENFAIL DS    0H\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(OPENMSG,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      OUTPUT DCB NOT OPEND MESSAGE\n         DROP  R15                                                  WFB\n         S     R3,FULL4                GET POINTER TO PUTLINE DDNAME\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=((R3),SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DDNAME\n         DROP  R15                                                  WFB\n         B     CLOSDCBS                GO CLOSE DCBS AND RETURN\n*\n***********************************************************************\n*                                                                     *\n*        INVOKE DAIR TO FREE FILENAME VIA CALLTSSR                    *\n*           AND CHECK FOR ZERO RETURN CODE                            *\n*                                                                     *\n***********************************************************************\n*\nFREEDD   DS    0H\n         SLR   R8,R8                   INITIALIZE REGISTER 8 TO ZERO\n*                                      RETURN CODE\n         MVC   DAP18(DAPB18L),DAPB18C  INITIALIZE DAIR PARAMETER BLOCK\n*                                      18 (FREE BY DATASET)\n         LA    R4,DAP18                LOAD ADDRESS OF DAPB\n         USING DAPB18,R4               ESTABLISH ADDRESSABILITY TO\n*                                      DAPB\n         MVC   DA18DDN,0(R1)           MOVE DDNAME INTO DAPB\n         SLR   R7,R7                   ZERO REGISTER 7\n         ST    R7,ECB                  STORE REGISTER 7 AS DUMMY ECB\n         LA    R1,DAPLSECT             LOAD ADDRESS OF DAPL\n         USING DAPL,R1                 ESTABLISH ADDRESSABILITY TO DAPL\n         ST    R4,DAPLDAPB             STORE ADDRESS OF DAPB IN DAPL\n         DROP  R1,R4                   DROP ADDRESSABILITY TO DAPL AND\n*                                      DAPB\n         CALLTSSR EP=IKJDAIR           CALL DAIR TO FREE DDNAME\n         C     R15,FULL28              SEE IF RETURN CODE IS 28\n*                                      (DDNAME NOT ALLOCATED)\n         BER   R2                      YES....GO CONTINUE PROCESSING\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO\n         BZR   R2                      YES....GO CONTINUE PROCESSING\n         MVI   DFID+1,DFDAIR           SET DAIRFAIL ID TO INDICATE DAIR\n*\n***********************************************************************\n*                                                                     *\n*        INVOKE DAIRFAIL TO DISPLAY AN ERROR MESSAGE                  *\n*                                                                     *\n***********************************************************************\n*\nDAIRFAIL XC    DFPARMS(DFLEN),DFPARMS  INITIALIZE PARMLIST FOR DAIR\n*                                      FAIL TO ZEROS\n         ST    R1,DFDAPLP              STORE POINTER TO DAPL/RB IN\n*                                      PARAMETER LIST\n         ST    R15,RETCODE             STORE RETURN CODE\n         LA    R1,RETCODE              LOAD ADDRESS OF RETURN CODE\n         ST    R1,DFRCP                STORE POINTER TO RETURN CODE IN\n*                                      PARAMETER LIST\n         LA    R1,FULL0                LOAD ADDRESS OF FULLWORD OF\n*                                      ZEROS\n         ST    R1,DFJEFF02             STORE DUMMY POINTER TO IKJEFF02\n*                                      IN PARMLIST\n         LA    R1,DFID                 LOAD ADDRESS OF DAIR FAIL ID\n*                                      FIELD\n         ST    R1,DFIDP                STORE POINTER TO DFID IN\n*                                      PARMLIST\n         MVI   DFID,NOWTP              SET FOR NO WRITE TO PROGRAMMER\n         L     R1,SAVEAREA+4           LOAD ADDRESS OF PEVIOUS\n*                                      SAVEAREA\n         L     R1,24(R1)               LOAD POINTER TO CPPL\n         ST    R1,DFCPPLP              STORE POINTER TO CPPL IN\n*                                      PARMLIST\n         LINK  EP=IKJEFF18,MF=(E,DFPARMS)  LINK TO DAIR FAIL SERVICE\n*                                      ROUTINE TO HANDLE RETURN\n*                                      CODE\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO\n         BZR   R2                      YES....GO RETURN TO CALLER\n         LR    R8,R15                  LOAD REGISTER 8 WITH RETURN CODE\n         BAL   R14,SETCODE             GO CONVERT CODE TO DECIMAL\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(DRFLERR,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DAIR FAIL ERROR MESSAGE\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(RETNCD,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DECIMAL RETURN CODE\n         DROP  R15                                                  WFB\n         BR    R2                      GO RETURN TO CALLER\n*\n******************** INSTRUCTIONS TO BE EXECUTED **********************\n*\nFOLDLINE OC    5(0,R9),BLANKS                                      GTEL\nMOVEDSN  MVC   DSNBUF(0),0(R5)\nMOVEVOL  MVC   VOLUME(0),0(R7)\nMOVEUNIT MVC   UNIT(0),0(R7)                                        WFB\nPACKLEN  PACK  DEC(8),0(0,R7)                                      GTEL\nPACKPAG  PACK  DEC(8),0(0,R7)                                      GTEL\nPACKCOPY PACK  DEC(8),0(0,R7)\nZEROTEST CLC   0(0,R7),ZEROS\n         USING S99TUNIT,R2             ADDRESSABILITY TO S99 TEXT   WFB\nMOVEDDN  MVC   S99TUPAR(0),0(R5)       MOVE DDNAME INTO S99 TEXT    WFB\n         DROP  R2                                                   WFB\n         USING LINDSECT,R15            ADDRESSABILITY TO OUTPUT REC WFB\nMOVEUDK  MVC   RECDATA+3(0),0(R14)     MOVE UDK FONT NAME TO OUTPUT WFB\n         DROP  R15                                                  WFB\n         USING DAPB08,R8\nMOVEMEM  MVC   DA08MNM(0),0(R5)\nMOVEPASS MVC   DA08PSWD(0),0(R5)\n         DROP  R8\nDFPBMVE  MVC   DFPBNAME(0),0(R5)                                   GTEL\n*\n***************************** CONSTANTS *******************************\n*\n******************** DAIR CONTROL BLOCK CONSTANTS *********************\nDAPB08C  DS    0F\n         DC    X'0008'                 DA08CD\n         DC    H'0'                    DA08FLG\n         DC    H'0'                    DA08DARC\n         DC    H'0'                    DA08CTRC\n         DC    A(0)                    DA08PDSN\n         DC    CL8'PRINTI  '           DA08DDN\n         DC    CL8' '                  DA08UNIT\n         DC    CL8' '                  DA08SER\n         DC    F'0'                    DA08BLK\n         DC    F'0'                    DA08PQTY\n         DC    F'0'                    DA08SQTY\n         DC    F'0'                    DA08DQTY\n         DC    CL8' '                  DA08MNM\n         DC    CL8' '                  DA08PSWD\n         DC    X'08'                   DA08DSP1      SHR\n         DC    X'08'                   DA08DSP2      KEEP\n         DC    X'08'                   DA08DSP3      KEEP\n         DC    X'08'                   DA08CTL       PERM\n         DC    F'0'                    DA08DSO\n         DC    CL8' '                  DA08ALN\nDAPB08L  EQU   *-DAPB08C               LENGTH\n         SPACE 2\nDAPB18C  DS    0F\n         DC    X'0018'                 DA18CD\n         DC    X'0000'                 DA18FLG\n         DC    H'0'                    DA18DARC\n         DC    H'0'                    DA18CTRC\n         DC    F'0'                    DA18PDSN\n         DC    CL8'PRINTI'             DA18DDN\n         DC    CL8' '                  DA18MNM\n         DC    CL2' '                  DA18SCLS\n         DC    X'08'                   DA18DPS2\n         DC    X'10'                   DA18CTL\n         DC    CL8' '                  DA18JBNM\nDAPB18L  EQU   *-DAPB18C               LENGTH\n         SPACE 2\nINPUTC   DCB   DSORG=PS,MACRF=(GM),EODAD=EXITI,SYNAD=ERRI,DDNAME=PRINTI\nINPUTL   EQU   *-INPUTC\n*\nOUTPUTAC DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=PRINTA,RECFM=VBA, X\n               LRECL=256,BLKSIZE=3120\nOUTPUTAL EQU   *-OUTPUTAC\n*\nOUTPUTMC DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=PRINTM,RECFM=VBM, X\n               LRECL=256,BLKSIZE=3120\nOUTPUTML EQU   *-OUTPUTMC\n*\nDIRECTC  DCB   DDNAME=PRINTI,DSORG=PS,MACRF=(GM),RECFM=U,BLKSIZE=256,  X\n               SYNAD=SERRI,EODAD=FREEBLK\nDIRECTL  EQU   *-DIRECTC\n*\nOPENCLOS OPEN  (,),MF=L\n         SPACE 2\n*---------------------------------------------------------------------*\n*------------------------- START OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\nSETPRTL  SETPRT OUTPUTAC,,MF=L\n*---------------------------------------------------------------------*\n*--------------------------- END OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\nHEADERC  DS    0F\n         DC    H'75'                   (WAS 49 BEFORE DATE)  ARAMCO WFB\n         DC    H'0'\nHDRCNTLC DC    C' '\n         DC    CL34' **** TSO FOREGROUND HARDCOPY ****'      ARAMCO WFB\n         DC    CL36'      HH:MM:SS    MONTHNAME DY, YEAR'           WFB\nHEADERM  DS    0F\n         DC    H'49'                                             ARAMCO\n         DC    H'0'\n         DC    C' '\n         DC    CL44' *** TSO FOREGROUND MEMBER LIST ***'         ARAMCO\n         DS    0H                                                ARAMCO\nLDSNAME  DS    0CL12\n         ORG   LDSNAME\n         DC    H'86'                                             ARAMCO\n         DC    H'0'\n         DC    CL9'  DSNAME='                                    ARAMCO\nVOLCONST DC    CL11'   VOLUME: '       FOR HEADING WHEN VOL(...)    WFB\nDDNCONST DC    CL11'   DDNAME: '       FOR HEADING WHEN DDN(...)    WFB\nEJECTM   DS    0F\n         DC    H'5'\n         DC    H'0'\n         DC    X'8B'\nEJECTA   DS    0F\n         DC    H'5'\n         DC    H'0'\n         DC    C'1'\nSPACE    EQU   EJECTA\n         SPACE 2\nFULL0    DC    F'0'\nFULL1    DC    F'1'\nFULL4    DC    F'4'\nFULL5    DC    F'5'\nFULL20   DC    F'20'\nFULL28   DC    F'28'\nFULL61   DC    F'61'                                               GTEL\nFULL132  DC    F'132'                                              GTEL\nFULL256  DC    F'256'\nPRINTILN DC    H'12',H'0'\nPRINTI   DC    CL8'PRINTI'\nPRINTALN DC    H'12',H'0'\nPRINTA   DC    CL8'PRINTA'\nPRINTMLN DC    H'12',H'0'\nPRINTM   DC    CL8'PRINTM'\nBLANKS   DC    256CL1' '\nZEROS    DC    4CL1'0'\nALIAS    DC    CL8' *ALIAS*'\nENDCHAIN DS    0F\n         DC    X'FF000000'\nMEMDATL  DC    X'00'                   SUBPOOL NUMBER\n         DC    AL3(1808)\nHALF0    DC    H'0'\nHALF1    DC    H'1'\nHALF2    DC    H'2'\nHALF4    DC    H'4'                                              ARAMCO\nHALF5    DC    H'5'\nHALF6    DC    H'6'\nHALF12   DC    H'12'\nHALF85   DC    H'85'\nHALF256  DC    H'256'\nHALF132  DC    H'132'                                              GTEL\nHALF208  DC    H'208'                                            ARAMCO\nHALF60   DC    H'60'                                             ARAMCO\nHALF120  DC    H'120'                                            ARAMCO\nPATCH    DC    C'PATCH AREA',20S(*)                                 WFB\nMSGCSECT DC    A(MESSAGES)             ADDRESS OF MESSAGE CSECT     WFB\nUDKRESET DC    H'14',H'0',CL10' =UDK={{+X'  DEFINE UDK THEN RESET   WFB\nUDKSET   DC    H'11',H'0',CL7' =UDK={'      DEFINE UDK              WFB\nUDKFHEAD DC    H'0',H'0',CL4' {+2'          SET FONT NAME #2        WFB\nUDKFSEL  DC    H'7',H'0',CL3' {2'           SELECT FONT #2          WFB\nNOMSG    EQU   X'04'                   FLAG IN BYTE VOLBIT          WFB\nUDKDONE  EQU   X'02'                   FLAG IN BYTE VOLBIT          WFB\nFORCEASA EQU   X'04'                   FLAG IN BYTE CCBIT           WFB\nHEXFF    EQU   X'FF'\nHIGH     EQU   X'80'\nLOW      EQU   X'01'\nMID1     EQU   X'10'                                               GTEL\nMID2     EQU   X'08'                                               GTEL\nJFCPDS   EQU   X'01'\nBLANK    EQU   X'40'\nHEX00    EQU   X'00'\nHEXF0    EQU   X'F0'\nHEXF1    EQU   X'F1'\nSCLSA    EQU   C'A'\nSKIPM    EQU   X'09'\nDSOPS    EQU   X'40'\nDSOPO    EQU   X'02'\nNOWTP    EQU   X'00'\n         SPACE 2\n****************** POINTER TO PARS PARAMETER CSECT ********************\nPCLADDR  DC    A(PARMTAB)\n         SPACE 2\n************************ PARS PARAMETER LIST **************************\nPARMTAB  IKJPARM  DSECT=IKJPARMD\nDSNAMES  IKJPOSIT  DSTHING,LIST,USID,                                  X\n               PROMPT='DSNAME, (LIST OF DSNAMES), OR * IF DDNAME(...) IX\n               S SPECIFIED',                                        WFBX\n               HELP=('THE NAME OF THE DATASET TO BE PRINTED, OR AN ASTEX\n               RISK IF A PREALLOCATED DDNAME IS TO BE USED.')       WFB\nPCLASS   IKJKEYWD\n         IKJNAME 'CLASS',SUBFLD=CLASSUB\nPDEST    IKJKEYWD\n         IKJNAME 'DEST',SUBFLD=DESTSUB\nPHOLD    IKJKEYWD\n         IKJNAME 'HOLD'\n         IKJNAME 'NOHOLD'\nPCOPIES  IKJKEYWD\n         IKJNAME 'COPIES',SUBFLD=COPYSUB\nPPRINT   IKJKEYWD\n         IKJNAME 'PRINT'\n         IKJNAME 'NOPRINT'\nPLIST    IKJKEYWD\n         IKJNAME 'LIST'\n         IKJNAME 'NOLIST'\nPHEAD    IKJKEYWD\n         IKJNAME 'NOHEADING'                                       GTEL\n         IKJNAME 'HEADING'                                         GTEL\nPVOL     IKJKEYWD\n         IKJNAME 'VOLUME',SUBFLD=VOLSUB\nPFOLD    IKJKEYWD\n         IKJNAME 'FOLD',ALIAS=('CAPS')\n         IKJNAME 'NOFOLD',ALIAS=('ASIS')\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** START OF GTEL MOD ************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nPSPACE   IKJKEYWD\n         IKJNAME 'SINGLESPACE',ALIAS=('SS','NOCC')                  WFB\n         IKJNAME 'DOUBLESPACE',ALIAS=('DS')                         WFB\nPFORMS   IKJKEYWD\n         IKJNAME  'FORMS',SUBFLD=SFORMS\nPTRAIN   IKJKEYWD\n         IKJNAME  'TRAIN',SUBFLD=STRAIN,ALIAS=('UCS')\nPFCB     IKJKEYWD\n         IKJNAME    'FCB',SUBFLD=SFCB\nPPROG    IKJKEYWD\n         IKJNAME    'PROG',SUBFLD=SPROG\nPTEXT    IKJKEYWD\n         IKJNAME    'TEXT',INSERT='UCS(TN) ASIS'\nPLINELEN IKJKEYWD\n         IKJNAME 'LINELENGTH',SUBFLD=SLINELEN,ALIAS=('LL')\nPPAGELEN IKJKEYWD\n         IKJNAME 'PAGELENGTH',SUBFLD=SPAGELEN,ALIAS=('PL')\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** END OF GTEL MOD **************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*---------------------------------------------------------------------*\n*------------------------- START OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\nPBURST   IKJKEYWD\n         IKJNAME  'BURST'\n         IKJNAME  'NOBURST'\nPFLASH   IKJKEYWD\n         IKJNAME  'FLASH',SUBFLD=SFLASH\nPCHARS   IKJKEYWD\n         IKJNAME  'CHARS',SUBFLD=SCHARS\n*---------------------------------------------------------------------*\n*--------------------------- END OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\nPUNIT    IKJKEYWD ,                                                 WFB\n         IKJNAME 'UNIT',SUBFLD=UNITSUB                              WFB\nPNOMSG   IKJKEYWD ,                                                 WFB\n         IKJNAME 'NOMSGS',ALIAS=('NOMESSAGES')                      WFB\nPDDNAME  IKJKEYWD ,                                                 WFB\n         IKJNAME 'DDNAME',ALIAS=('FILE'),SUBFLD=DDNSUB              WFB\nPASA     IKJKEYWD ,                                                 WFB\n         IKJNAME 'ASA'                                              WFB\nPUDKFONT IKJKEYWD ,                                                 WFB\n         IKJNAME 'UDKFONT',SUBFLD=UDKSUB                            WFB\n*\n*        B E G I N   S U B F I E L D S\nCLASSUB  IKJSUBF\nSCLASS   IKJIDENT 'CLASSNAME',LIST,FIRST=NONATNUM,MAXLNTH=1,           X\n               PROMPT='CLASS NAME'\nDESTSUB  IKJSUBF\nSDEST    IKJIDENT 'DESTINATION',MAXLNTH=17,                         WFBX\n               FIRST=ALPHANUM,OTHER=ANY,VALIDCK=VALDEST,            WFBX\n               PROMPT='DESTINATION FOR OUTPUT',                     WFBX\n               HELP=('WHERE TO PRINT OUTPUT. DESTINATION CAN BE: REMOTEX\n                LINE NUMBER, JES PRINTER NAME, OR NETWORK NODE AND USERX\n               ID')                                                 WFB\nCOPYSUB  IKJSUBF\nSCOPIES  IKJIDENT 'COPIES',MAXLNTH=3,                                  X\n               FIRST=NUMERIC,OTHER=NUMERIC,                            X\n               PROMPT='1-3 DIGITS - NUMBER OF COPIES OF OUTPUT',       X\n               HELP=('NUMBER OF COPIES OF PRINTOUT DESIRED')\nVOLSUB   IKJSUBF\nSVOL     IKJIDENT 'VOLUME',MAXLNTH=8,                                  X\n               FIRST=ALPHANUM,OTHER=ALPHANUM,                          X\n               PROMPT='VOLUME SERIAL FOR DATA SETS TO BE PRINTED',     X\n               HELP=('VOLUME SERIAL TO BE USED FOR ALL DATA SETS')\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** START OF GTEL MOD ************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nSFORMS   IKJSUBF\nRFORMS   IKJIDENT 'FORMS',MAXLNTH=4,FIRST=ALPHANUM,                    X\n               OTHER=ALPHANUM,                                         X\n               DEFAULT='$TST',                                      WFBX\n               HELP=('AN ALPANUMERIC STRING TO SPECIFY THE FORM')\nSTRAIN   IKJSUBF\nRTRAIN   IKJIDENT   'UCS',MAXLNTH=4,FIRST=ALPHANUM,                    X\n               OTHER=ALPHANUM,                                         X\n               PROMPT='UCS   DESIGNATION FOR PRINTED OUTPUT',          X\n               HELP=('AN ALPANUMERIC STRING TO SPECIFY THE TRAIN')\nSFCB     IKJSUBF\nRFCB     IKJIDENT 'FCB',MAXLNTH=4,FIRST=ALPHANUM,                      X\n               OTHER=ALPHANUM,                                         X\n               PROMPT='FCB DESIGNATION FOR PRINTED OUTPUT',            X\n               HELP=('AN ALPANUMERIC STRING TO SPECIFY THE FCB')\nSPROG    IKJSUBF\nRPROG    IKJIDENT 'PROG',MAXLNTH=8,FIRST=ALPHA,                        X\n               OTHER=ALPHANUM,                                         X\n               PROMPT='PROG DESIGNATION FOR PRINTED OUTPUT',           X\n               HELP=('AN ALPANUMERIC STRING TO SPECIFY THE PROG')\nSLINELEN IKJSUBF\nRLINELEN IKJIDENT 'LINELENGTH',MAXLNTH=3,FIRST=NUMERIC,                X\n               OTHER=NUMERIC,                                          X\n               PROMPT='LINESIZE, DEFAULT=132',                         X\n               HELP=('A LENGTH UP TO 208 FOR MAXIMUM PRINT WIDTH')\nSPAGELEN IKJSUBF\nRPAGELEN IKJIDENT 'PAGELENGTH',MAXLNTH=3,FIRST=NUMERIC,                X\n               OTHER=NUMERIC,                                          X\n               PROMPT='PAGELENGTH, DEFAULT=60',                        X\n               HELP=('A LENGTH UP TO 120 FOR PRINTER PAGE LENGTH')\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** END OF GTEL MOD **************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*---------------------------------------------------------------------*\n*------------------------- START OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\nSFLASH   IKJSUBF\nRFLASH   IKJIDENT 'FLASH',MAXLNTH=4,FIRST=ALPHANUM,                    X\n               OTHER=ALPHANUM,                                         X\n               PROMPT='FLASH DESIGNATION FOR PRINTED OUTPUT',          X\n               HELP=('FORMS OVERLAY FLASH NAME -- VALID FOR 3800 ONLY')\nSCHARS   IKJSUBF\nRCHARS   IKJIDENT 'CHARS',LIST,MAXLNTH=4,FIRST=ALPHA,                  X\n               OTHER=ANY,                                              X\n               PROMPT='CHARS DESIGNATION FOR PRINTED OUTPUT',          X\n               HELP=('A LIST OF 1 TO 4 CHARACTER SET NAMES -- VALID FORX\n                3800 ONLY')\n*---------------------------------------------------------------------*\n*--------------------------- END OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\nUNITSUB  IKJSUBF ,                                                  WFB\nSUNIT    IKJIDENT 'UNIT',MAXLNTH=8,                                 WFBX\n               FIRST=ALPHANUM,OTHER=ALPHANUM,                       WFBX\n               PROMPT='UNIT TYPE OF SPECIFIED VOLUME',              WFBX\n               HELP=('UNIT TYPE WHICH IS REQUIRED IF THE SPECIFIED VOLUX\n               ME IS NOT ACCESSIBLE THROUGH YOUR DEFAULT TSO UNIT VALUEX\n               ')                                                   WFB\nDDNSUB   IKJSUBF ,                                                  WFB\nSDDNAME  IKJIDENT 'DDNAME',MAXLNTH=8,                               WFBX\n               FIRST=ALPHA,OTHER=ALPHANUM,                          WFBX\n               PROMPT='DD NAME OF PREVIOUSLY ALLOCATED DATASET',    WFBX\n               HELP=('A FILE THAT WAS ALLOCATED EARLIER IN YOUR TSO SESX\n               SION','DDNAME IS IGNORED IF THE LAST OR ONLY DSNAME IS NX\n               OT AN ASTERISK')                                     WFB\nUDKSUB   IKJSUBF ,                                                  WFB\nSUDKFONT IKJIDENT 'UDK FONT NAME',ASIS,MAXLNTH=20,                  WFBX\n               FIRST=ALPHANUM,OTHER=ANY,                            WFBX\n               PROMPT='UDK FONT NAME',                              WFBX\n               HELP=('A FONT NAME FOR PRINTING ON A XEROX 2700 OR 3700'X\n               ,'THE NAME MUST BE ENTERED EXACTLY IN UPPER/LOWER CASE AX\n               S THE PRINTER EXPECTS IT')                           WFB\n         IKJENDP\n         SPACE 2\nMESSAGES CSECT ,                                                    WFB\n****************************** MESSAGES *******************************\nGNRLERR  DC    AL2(GNRLERRL),AL2(0)\n         DC    C'AN ERROR WAS ENCOUNTERED IN THE GENERAL FAIL SERVICE RX\n               OUTINE.  THE RETURN CODE FROM GNRLFAIL IS: '\nGNRLERRL EQU   *-GNRLERR\n*\nDRFLERR  DC    AL2(DRFLERRL),AL2(0)\n         DC    C'AN ERROR WAS ENCOUNTERED IN THE DAIR FAIL SERVICE ROUTX\n               INE.  THE RETURN CODE FROM DAIR FAIL IS: '\nDRFLERRL EQU   *-DRFLERR\n*\nOPENMSG  DC    AL2(OPENMSGL),AL2(0)\n         DC    C'OUPUT PROCESSING IS BEING TERMINATED.  AN ERROR WAS ENX\n               COUNTERED ATTEMPTING TO OPEN THE OUTPUT DATASET ASSOCIATX\n               ED WITH DDNAME: '\nOPENMSGL EQU   *-OPENMSG\n*\nDSNNOTP  DC    AL2(DSNNOTPL),AL2(0)\n         DC    C'AN ERROR OCCURRED AND YOUR DATASET WAS NOT PRINTED'\nDSNNOTPL EQU   *-DSNNOTP\n*\nDSNMSG   DC    AL2(DSNMSGL),AL2(0)\n         DC    C'PROCESSING HAS BEEN COMPLETED FOR DATASET: '\nDSNMSGL  EQU   *-DSNMSG\n*\nMEMMSG   DC    AL2(MEMMSGL),AL2(0)\n         DC    C' MEMBER: '\nMEMMSGL  EQU   *-MEMMSG\n*\nPRTMSG   DC    AL2(PRTMSGL),AL2(0)\n         DC    C'MEMBERS WILL NOW BE PRINTED FOR DATASET: '\nPRTMSGL  EQU   *-PRTMSG\n*\nNOTPSPO  DC    AL2(NOTPSPOL),AL2(0)\n         DC    C'DATASET IS NOT SEQUENTIAL OR PARTITIONED AND WAS NOT PX\n               RINTED.'\nNOTPSPOL EQU   *-NOTPSPO\n*\nSYNADI   DC    AL2(SYNADIL),AL2(0)\n         DC    C'A SYNAD ERROR OCURRED READING YOU INPUT DATASET AND ONX\n               LY PART OF YOUR DATASET MAY HAVE BEEN PRINTED.'\nSYNADIL  EQU   *-SYNADI\n*\nSYNADO   DC    AL2(SYNADOL),AL2(0)\n         DC    C'A SYNAD ERROR OCURRED WRITING THE OUTPUT DATASET AND NX\n               O MORE DATASETS WILL BE PRINTED.'\nSYNADOL  EQU   *-SYNADO\n*\n*DSNISU  DC    AL2(DSNISUL),AL2(0)\n*        DC    C'DATASET HAS UNDEFINED RECORD LENGTH AND WILL NOT BE PRX\n               INTED.'\n*DSNISUL EQU   *-DSNISU\n*\n*DSNISL  DC    AL2(DSNISLL),AL2(0)\n*        DC    C'DATASET HAS RECORD LENGTH GREATER THAN 256.'\n*DSNISLL EQU   *-DSNISL\n*                                                                ARAMCO\nCHARMSG  DC    AL2(CHARMSGL),AL2(0)                              ARAMCO\n         DC    C'MAX OF 4 CHAR SETS ALLOWED, REMAINDER IGNORED'  ARAMCO\nCHARMSGL EQU   *-CHARMSG                                         ARAMCO\n*                                                                   WFB\nNODSNDD  DC    AL2(NODSNDDL),AL2(0)                                 WFB\n         DC    C'NO INPUT SPECIFIED: AN ASTERISK DSNAME IMPLIES A DDNAMX\n               E WILL BE USED FOR INPUT, BUT NO DDNAME WAS GIVEN.'  WFB\nNODSNDDL EQU   *-NODSNDD                                            WFB\nNOTLAST  DC    AL2(NOTLASTL),AL2(0)                                 WFB\n         DC    C'AN ASTERISK DSNAME MUST BE THE LAST OR ONLY DSNAME SPEX\n               CIFIED FOR DDNAME TO BE PROCESSED.'                  WFB\nNOTLASTL EQU   *-NOTLAST                                            WFB\n         SPACE 2\n************************ DSECTS (MAPPING MACROS) **********************\nMEMDSECT DSECT\nMEMNTTR  DS    CL11\n         ORG   MEMNTTR\nMEMBER   DS    CL8\nMEMTTR   DS    CL3\nCFIELD   DS    CL1\nMEMSECTN EQU   *\n         IKJDAP08\nDAP08LEN EQU   *-DAPB08\n         IKJDAP18\nDAP18LEN EQU   *-DAPB18\n         IKJDAPL\nDAPLLEN  EQU   *-DAPL\n         IKJCPPL\nCPPLLEN  EQU   *-CPPL\n         IKJPPL\nPPLLEN   EQU   *-PPL\n         IKJIOPL\nIOPLLEN  EQU   *-IOPL\n         IHADSAB\nTIOEDDNM EQU   4           X'1C'(OFFSET) - X'18'(JOB STEP)\n         CVT   DSECT=YES                                            WFB\n         IEFZB4D0\n         IEFZB4D2\n         IKJDFPL                                                   GTEL\n         IKJDFPB                                                   GTEL\n         IKJUPT                                                  ARAMCO\nRBLEN    EQU   S99RBEND-S99RB\n         PRINT NOGEN\n         DCBD  DSORG=(PS,PO)\n         PRINT GEN\n         EJECT\n******************** CONSTANTS FOR DYNAMIC ALLOCATION *****************\nPRINTOFF CSECT\nREQBLKC  DC    AL1(S99RBEND-S99RB),AL1(S99VRBAL),18AL1(0)\nTEXTAC   DC    AL2(DALDDNAM),AL2(1),AL2(8),CL8'PRINT'  DDNAME\nTEXTALEN EQU   *-TEXTAC\nTEXTBC   DC    AL2(DALSYSOU),AL2(1),AL2(1),C'A'        SYSOUT CLASS\nTEXTBLEN EQU   *-TEXTBC\nTEXTCC   DC    AL2(DALSUSER),AL2(1),AL2(8),CL8'LOCAL'  DESTINATION\nTEXTCLEN EQU   *-TEXTCC\nTEXTDC   DC    AL2(DALSHOLD),AL2(0)                    SYSOUT HOLD\nTEXTDLEN EQU   *-TEXTDC\nTEXTEC   DC    AL2(DALCOPYS),AL2(1),AL2(1),AL2(1)      SYSOUT COPIES\nTEXTELEN EQU   *-TEXTEC\nTEXTFC   DC    AL2(DALPERMA),AL2(0)              PERM ALLOCATION\nTEXTFLEN EQU   *-TEXTFC\nTEXTGC   DC    AL2(DALFCBIM),AL2(1),AL2(4),CL4'STD.'  FCB          GTEL\nTEXTGLEN EQU   *-TEXTGC                                        GTEL WFB\nTEXTHC   DC    AL2(DALUCS),AL2(1),AL2(2),CL4'PN'      UCS          GTEL\nTEXTHLEN EQU   *-TEXTHC                                        GTEL WFB\nTEXTIC   DC    AL2(DALSFMNO),AL2(1),AL2(2),CL4'STD.'  FORMS        GTEL\nTEXTILEN EQU   *-TEXTIC                                        GTEL WFB\nTEXTJC   DC    AL2(DALSPGNM),AL2(1),AL2(8),CL8'PROG'  PROG         GTEL\nTEXTJLEN EQU   *-TEXTJC                                        GTEL WFB\nTEXTKC   DC    AL2(DALUSRID),AL2(1),AL2(8),CL8'USER'  USERID        WFB\nTEXTKLEN EQU   *-TEXTKC                                             WFB\nTEXTLC   DC    AL2(DINDDNAM),AL2(1),AL2(8),CL8' '   PREALLOC DDNAME WFB\nTEXTLLEN EQU   *-TEXTLC                                             WFB\nTEXTMC   DC    AL2(DINRTDSN),AL2(1),AL2(44),CL44' ' RETURNED DSNAME WFB\nTEXTMLEN EQU   *-TEXTMC                                             WFB\nTEXTNC   DC    AL2(DINRTMEM),AL2(1),AL2(8),CL8' '   RETURNED MEMBER WFB\nTEXTNLEN EQU   *-TEXTNC                                             WFB\nTEXTOC   DC    AL2(DINRTORG),AL2(1),AL2(2),XL2'0000' RETURNED DSORG WFB\nTEXTOLEN EQU   *-TEXTOC                                             WFB\n*                                                                   WFB\n**       VALIDITY CHECK ROUTINE FOR DESTINATION                     WFB\n***                                                                 WFB\n****     MAXIMUM LENGTH IS 17 CHARACTERS (ENFORCED BY PARSE)        WFB\n*****    DEST(NODE.USERID) MUST HAVE 1 PERIOD, EACH NAME 1-8 CHARS  WFB\n******   DEST(NAME) IF NO PERIOD, MAXIMUM LENGTH IS 8 CHARACTERS    WFB\n******                                                              WFB\n*****    AT ENTRY, REG 1 POINTS TO A THREE WORD LIST:               WFB\n****     +0  A(SDEST)   ADDRESS OF THE PDE BUILT BY PARSE           WFB\n***      +4  A(WORKAREA) ADDRESS OF USER WORK AREA FROM IKJPPL      WFB\n**       +8  A(VALMSG)  =F'0', ADDRESS OF USER SUPPLIED 2ND LVL MSG WFB\n*                                                                   WFB\nVALDEST  CSECT ,                                                    WFB\n         PUSH  USING                                                WFB\n         STM   R14,R12,12(13)          SAVE PARSE REGISTERS         WFB\n         LR    R12,R15                 USE REG 12 AS BASE           WFB\n         USING VALDEST,R12             ESTABLISH ADDRESSABILITY     WFB\n         LM    R8,R10,0(R1)            LOAD INPUT LIST VALUES       WFB\n         SR    R15,R15                 ASSUME ZERO RETURN CODE      WFB\n         STH   R15,NODELEN-WORKAREA(,R9)  ASSUME NOT NODE.USERID    WFB\n         L     R1,0(,R8)               GET ADDRESS OF DEST          WFB\n         LH    R3,4(,R8)               GET TOTAL LENGTH OF DEST     WFB\n         BCTR  R3,0                    DECREMENT LENGTH FOR TRT     WFB\n         EX    R3,VALTRT               LOOK FOR PERIOD OR INVALID   WFB\n         BZ    VALNODOT           CC=0 NOTHING FOUND, GO CHECK LEN  WFB\n         BM    VALCHECK           CC=1 FOUND IN MIDDLE, GO CHECK    WFB\n         B     VALRET4            CC=2 FOUND IN LAST BYTE - INVALID WFB\nVALNODOT CLI   5(R8),X'08'             NO PERIOD, LEN MUST BE 1-8   WFB\n         BNH   VALRETRN                YES, OK                      WFB\n         B     VALRET4                 NO, INVALID LENGTH           WFB\nVALCHECK CLI   0(R1),C'.'              PERIOD FOUND ?               WFB\n         BNE   VALRET4                 NO, INVALID CHARACTER        WFB\n         LA    R4,0(,R1)               GET ADDRESS OF PERIOD        WFB\n         SL    R4,0(,R8)               MINUS BEGIN DEST = LEN NODE  WFB\n         LA    R1,1(,R1)               POINT PAST PERIOD            WFB\n         SLR   R3,R4                   GET REMAINING LEN OF '.USER' WFB\n         BCTR  R3,0                    DECREMENT FOR PERIOD         WFB\n         EX    R3,VALTRT               LOOK FOR MORE PERIOD/INVALID WFB\n         BNZ   VALRET4                 FOUND, INVALID SPECIFICATION WFB\n         STH   R4,NODELEN-WORKAREA(,R9)  SAVE NODE LEN IN WORKAREA  WFB\n         B     VALRETRN                DONE                         WFB\nVALRET4  LA    R15,4                   SET RC 4 - INVALID DEST      WFB\nVALRETRN LM    R0,R12,20(R13)          RESTORE PARSE REGISTERS      WFB\n         L     R14,12(,R13)            RESTORE RETURN ADDRESS       WFB\n         BR    R14                     RETURN TO PARSE              WFB\n*                                                                   WFB\nVALTRT   TRT   0(0,R1),VALTABLE        ** EXECUTED **               WFB\nVALTABLE DC    256AL1(*-VALTABLE)      TABLE OF VALID CHARACTERS    WFB\n         ORG   VALTABLE+C'$'                                        WFB\n         DC    X'00'                   ALLOW $                      WFB\n         ORG   VALTABLE+C'#'                                        WFB\n         DC    2X'00'                  ALLOW # @                    WFB\n         ORG   VALTABLE+C'A'                                        WFB\n         DC    9X'00'                  ALLOW A B C D E F G H I      WFB\n         ORG   VALTABLE+C'J'                                        WFB\n         DC    9X'00'                  ALLOW J K L M N O P Q R      WFB\n         ORG   VALTABLE+C'S'                                        WFB\n         DC    8X'00'                  ALLOW S T U V W X Y Z        WFB\n         ORG   VALTABLE+C'0'                                        WFB\n         DC    10X'00'                 ALLOW 0 1 2 3 4 5 6 7 8 9    WFB\n         ORG   ,                                                    WFB\n         DROP  R12                                                  WFB\n         POP   USING                                                WFB\n*********************** DSECT FOR DYNAMIC WORKAREA ********************\nWORKAREA DSECT\nSAVEAREA DS    18F\nALCSAVE  DS    12F\n         DS    0D\nDEC      DS    2F\nRETNCD   DS    F\nCONV     DS    2F\nIOPB     PUTLINE MF=L\nDAP08    DS    0F\n         ORG   DAP08+DAP08LEN\nDAP18    DS    0F\n         ORG   DAP18+DAP18LEN\nDAPLSECT DS    0F\n         ORG   DAPLSECT+DAPLLEN\nPPLSECT  DS    0F\n         ORG   PPLSECT+PPLLEN\nIOPLSECT DS    0F\n         ORG   IOPLSECT+IOPLLEN\nDFPLSECT DS    4F                   SPACE FOR DFPL                 GTEL\nDFPBSECT DS    5F                   SPACE FOR DFPB                 GTEL\n         DS    H                    TO GET ALLIGNMENT              GTEL\nDFPBDSL  DS    H                    DSNAME LENGTH                  GTEL\nDFPBNAME DS    CL44                 DSNAME                         GTEL\nDFPBQUA  DS    CL8\nECB      DS    F\nPARSBACK DS    F\nLINE     DS    0H\nLENGTH   DS    H\n         DS    H\nCNTLBYTE DS    CL1\nDATA     DS    CL256\nHEADER2  DS    CL13                                              ARAMCO\nDSNAME   DS    CL44\nOPENPRN  DS    CL1\nMEMNAME  DS    CL8\nCLOSEPRN DS    CL1\nVOLHEAD  DS    CL11                 C'   VOLUME: ' ON HEADING       WFB\nVOLNAME  DS    CL8                                                  WFB\n         ORG   DSNAME-4\nDSNLENP  DS    CL2\nDSNLEN   DS    CL2\nDSNBUF   DS    CL44\n         ORG   MEMNAME-4\nMEMNAMEL DS    CL2\n         ORG\nHEADER   DS    CL75                 (WAS 49 BEFORE DATE)     ARAMCO WFB\n         ORG   HEADER+4\nHDRCNTL  DS    CL1\n         ORG   HEADER+41                                            WFB\nHDRTIME  DS    CL12                 4 BYTE PREFIX, HH:MM:SS         WFB\nHDRDATE  DS    CL22                 4 BYTE PREFIX, MONTHNAME DY, YR WFB\nHDRTDLEN EQU   *-HDRTIME                                            WFB\nDFID     DS    CL2\n         ORG\nVOLBIT   DS    CL1\nVOLUME   DS    CL8\nUNIT     DS    CL8                  UNIT() VALID ONLY WITH VOL()    WFB\nPREALDDN DS    CL8                  PREALLOCATED DDNAME(...)        WFB\nNODELEN  DS    H                    LEN OF NODE IN DEST(NODE.USER)  WFB\n*ALLMFL  CALL  ,(,),MF=L            LIST FORM FOR CALL IKJEFLPA     WFB\nCALLMFJ  CALL  ,(,,,,),MF=L         LIST FORM FOR CALL JULSUB       JUL\nJS1      DS    F                                                    JUL\nJS2      DS    F                                                    JUL\nJS4      DS    F                                                    JUL\nJS3      DS    7F OR CL28                                           JUL\nJS5      DS    0D,XL256                                             JUL\nMEMTABLE DS    F\nENDTABLE DS    F\nCURRENT  DS    F\nPRESENT  DS    F\nCOLUMN   DS    F\nXLIST    DS    F\nLINELEN  DS    H                                                   GTEL\nVBLEN    DS    H                                                   GTEL\nPAGELEN  DS    H                                                   GTEL\nCCBIT    DS    CL1                                                 GTEL\nALNDSECT DS    F                                                   GTEL\nRDJL     RDJFCB (,),MF=L\nJFCBAREA DS    44F\n         ORG   JFCBAREA+44\nJFCBELNM DS    CL8\n         ORG   JFCBAREA+86\nJFCBIND1 DS    CL1\n         ORG   JFCBAREA+98\nJFCDSRG1 DS    CL1\n         ORG\nSAVER6   DS    F\nSAVER2   DS    2F\nSAVER3   DS    2F\nSAVMR2   DS    2F                                                  GTEL\nSAVMR6   DS    2F                                                  GTEL\nSAVMR9   DS    2F                                                  GTEL\n*\n         PRINT NOGEN\n*\nINPUT    DCB   DSORG=PS,MACRF=(GM),EODAD=EXITI,SYNAD=ERRI,DDNAME=PRINTI\n*\nOUTPUTA  DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=PRINTA,RECFM=VBA, X\n               LRECL=256,BLKSIZE=3120\n*\nOUTPUTM  DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=PRINTM,RECFM=VBM, X\n               LRECL=256,BLKSIZE=3120\n*\nDIRECT   DCB   DDNAME=PRINTI,DSORG=PS,MACRF=(GM),RECFM=U,BLKSIZE=256,  X\n               SYNAD=SERRI,EODAD=FREEBLK\n*\nOPENLST  OPEN  (,),MF=L\n*\nCLOSLST  CLOSE (,),MF=L\n*\n*\n         PRINT GEN\n*\nRETCODE  DS    F\nGFPARMP  DS    F\n         IKJEFFGF\n         IKJEFFDF\nRBPTR    DS    F\nREQBLK   DS    10F                                                 GTEL\nTEXTPTRS DS    16F                                             GTEL WFB\nTEXTA    DS    0F                                   DDNAME\n         ORG   TEXTA+TEXTALEN\nTEXTB    DS    0F                                   SYSOUT CLASS\n         ORG   TEXTB+TEXTBLEN\nTEXTC    DS    0F                                   DESTINATION\n         ORG   TEXTC+TEXTCLEN\nTEXTE    DS    0F                                   SYSOUT COPIES\n         ORG   TEXTE+TEXTELEN\nTEXTG    DS    0F                                   FCB            GTEL\n         ORG   TEXTG+TEXTGLEN                                      GTEL\nTEXTH    DS    0F                                   UCB            GTEL\n         ORG   TEXTH+TEXTHLEN                                      GTEL\nTEXTI    DS    0F                                   FORMS          GTEL\n         ORG   TEXTI+TEXTILEN                                      GTEL\nTEXTJ    DS    0F                                   PROG           GTEL\n         ORG   TEXTJ+TEXTJLEN                                      GTEL\nTEXTK    DS    0F                                   USERID          WFB\n         ORG   TEXTK+TEXTKLEN                                       WFB\nTEXTL    DS    0F                                   PREALLOC DDNAME WFB\n         ORG   TEXTL+TEXTLLEN                                       WFB\nTEXTM    DS    0F                                   RETURNED DSNAME WFB\n         ORG   TEXTM+TEXTMLEN                                       WFB\nTEXTN    DS    0F                                   RETURNED MEMBER WFB\n         ORG   TEXTN+TEXTNLEN                                       WFB\nTEXTO    DS    0F                                   RETURNED DSORG  WFB\n         ORG   TEXTO+TEXTOLEN                                       WFB\n*---------------------------------------------------------------------*\n*------------------------- START OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\nSETFLAG  DS    X\nSETBURST EQU   1\nSETFLSH  EQU   2\nSETCHAR  EQU   4\nSETPRTE  SETPRT OUTPUTA,,MF=L\nSETFLASH EQU   SETPRTE+28\nSETCHARS EQU   SETPRTE+32\nSETPRTEL EQU   *-SETPRTE\nSAVEUPT  DS    X\n*---------------------------------------------------------------------*\n*--------------------------- END OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\nLDYNAMIC EQU   *-WORKAREA\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*********************** DSECT FOR RECORD MAPPING **********************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nLINDSECT DSECT\nRECORD   DS    0F\nRECLEN   DS    H\n         DS    H\nRECCC    DS    CL1\nRECDATA  DS    CL32760                                              WFB\nRECSIZE  EQU   *-RECORD                                             WFB\n*********************** END OF RECORD MAPPING DSECT *******************\n         AGO   .ENDHELP                SKIP AROUND HELP ENTRY      WFB\n)F Function -\n   The PRINTOFF command creates a printed copy of data sets through\n   foreground copying to SYSOUT.  The command prints datasets which\n   are sequential or partitioned, blocked or unblocked, with fixed,\n   variable, or undefined length records of any length up to 32,760.\n)X Syntax -\n   PRINTOFF (dslist)/*  DDNAME(ddname)/FILE(ddname)\n            UNIT(unit-type)  VOLUME(volser)     NOMESSAGES/NOMSGS\n            CLASS(class)     DEST(destination)  COPIES(nnn)\n            HOLD/NOHOLD      LIST/NOLIST        PRINT/NOPRINT\n            FORMS(form)      FCB(fcb)           TRAIN(image)/UCS(image)\n            HEADING/NOHEADING                   CAPS/ASIS/FOLD/NOFOLD\n            NOCC/SINGLESPACE/SS/DOUBLESPACE/DS  ASA\n            LINELENGTH(nnn)/LL(nnn)             PAGELENGTH(nnn)/PL(nnn)\n            BURST/NOBURST    FLASH(flash-name)  CHARS(charset-name(s))\n            PROG(progname)   UDKFONT(font-name)\n   Required -- dslist or * if DDNAME(...)\n   Aliases  -- PRINTO, PO\n   Defaults -- CLASS(A), COPIES(1), NOHOLD, LIST, PRINT, FORM($TST),\n               HEADING, ASIS, LINELENGTH(132), PAGELENGTH(60), NOBURST,\n               SINGLESPACE if PAGELENGTH(...) or if input RECFM not A/M\n)O Operands -\n)P DSLIST - Data set list contains the names of data sets to be printed\n            or punched.  The names should follow TSO convention, in\n            quotes if the primary index differs from your profile\n            prefix, or without quotes and with the primary index\n            omitted if it is the same as your profile prefix.\n            Enclosing parenthesis are required if there is more than\n            one name in the list.\n              If DDNAME(...) is specified, the dslist must end with an\n            asterisk (or contain only an asterisk) as a place holder.\n))ASA     - Output is to be printed using input data column 1 as ASA\n            carriage control characters even though the DCB record\n            format does not specify RECFM=..A\n))ASIS    - Output is not to be converted to upper case prior to\n            printing. (It is left as it is.)\n            NOFOLD is an alias for ASIS.\n))BURST   - Output is to be trimmed and burst. ===> VALID FOR 3800 ONLY\n))NOBURST - Output will be printed on continuous forms.\n))CAPS    - Output is to be converted to upper case prior to\n            printing. FOLD is an alias for CAPS.\n))CHARS(charset-name(s)) - Character set(s) to be used to print the\n            output. (1-4 names, each name 1-4 characters.)  If more\n            than one character set name is given, the input data should\n            have the character set id specified in the second character\n            of each line. OPTCD=J is assumed. See the JCL reference\n            manual for more information. ===> VALID FOR 3800 ONLY\n))CLASS(class) - SYSOUT class in which output is to be printed.\n            Default is A.\n))COPIES(nnn) - Number of copies to be printed.  Default is 1.\n))DEST(destination) - The destination to where SYSOUT is to be routed.\n            Destination can be a JES remote line, a JES local or remote\n            printer, or a network node and userid. Local and remote\n            names are 1-8 characters. Network names are 3-17 characters\n            (node.userid) with the period required as a separator.\n            DEST(node.userid) is mutually exclusive with\n            PROG(progname).\n))DDNAME(ddname) - DD name of a previously allocated dataset. If DDNAME\n            is specified, the last (or only) dataset name in dslist\n            must be an asterisk. The DD will not be freed after being\n            printed. FILE is an alias for DDNAME.\n))FCB(fcb) - Forms Control Buffer to be used when the data set is\n            printed.  (1-4 character FCB name)\n))FLASH(flashname) - The name of the forms flash overlay which is to be\n            flashed on all output. ===> VALID FOR 3800 ONLY\n))FORMS(form) - Form to be used when the data set is printed.\n            Default is $TST. (1-4 character form name)\n))HEADING - Output is to have a heading containing the data set name.\n))NOHEADING - Output is not to have heading information.\n))HOLD    - Output is to be placed on a hold queue upon deallocation.\n))NOHOLD  - Output is not to be placed on a hold queue upon\n            deallocation.\n))LINELENGTH(nnn) - Number of characters on each line of printed\n            output. (1-208 characters with a default of 132.)  Input\n            lines longer than specified linelength will be printed on\n            multiple lines.  LL(...) is an alias for LINELENGTH(...).\n))LIST    - A separate listing of member names processed is to be\n            created and printed with the data set output.\n))NOLIST  - No list of member names is to be created.\n))NOMESSAGES - Non-error messages are not to be written to the TSO\n            terminal. NOMSGS is an alias of NOMESSAGES. The default is\n            to write informational messages to the terminal before and\n            after printing.\n))PAGELENGTH(nnn) - Number of lines per page.  (1-120 lines with a\n            default of 60.)  Carriage control in input records is\n            ignored (even if ASA is specified) and SINGLESPACE is used.\n            PL(...) is an alias for PAGELENGTH(...).\n))PRINT   - Members are to be printed. (Whether they are also listed\n            is controlled by LIST/NOLIST.)\n))NOPRINT - Members are not to be printed. (Whether they are to be\n            listed is controlled by LIST/NOLIST.)\n))PROG(progname) - The name of the special 'external writer' program\n            that is to process the output. PROG(progname) is mutually\n            exclusive with DEST(node.userid).\n))TRAIN(image) - Print image to be used when the data set is printed.\n            UCS is an alias for TRAIN. (1-4 character print image name)\n))UCS(image) - Print image to be used when the data set is printed.\n            UCS is an alias for TRAIN. (1-4 character print image name)\n))SINGLESPACE - Output is to be single spaced.  Carriage control in\n            input data is ignored even if ASA is specified.\n            NOCC and SS are aliases for SINGLESPACE.\n))DOUBLESPACE - Output is to be double spaced between lines.  Carriage\n            control in input data is ignored even if ASA is specified.\n            DS is an alias for DOUBLESPACE.  (Multiple line records\n            will not be split between pages.)\n))UNIT(unit-type) - Unit type of the specified VOLUME(volser). UNIT is\n            ignored if VOLUME is not also specified. UNIT is required\n            only when the dataset is not cataloged, or when the dataset\n            is cataloged to a different volume than the specified\n            VOLUME and the volume cannot be accessed through your TSO\n            default unit type.\n))VOLUME(volser) - Volume serial of volume on which data sets to be\n            printed are found.  This volume serial will be used for all\n            data sets specified in the data set list.\n))UDKFONT(font-name) - Output is intended to be printed on a XEROX 2700\n            or 3700.  PRINTOFF will insert Xerox User Defined Key (UDK)\n            statements in the output to select the specified font.  No\n            validation is performed on the font name before it is sent\n            to the printer, so the full font name must be specified in\n            upper/lower case exactly as expected by the XEROX printer.\n            (PRINTOFF uses the left brace character, {, hex C0, as the\n            UDK.  Input data containing this character will be\n            interpreted by the printer as a Xerox command, and may\n            produce undesired results.)\n.ENDHELP ANOP                          ,                            SL\n         END\n         TITLE '   J U L S U B   '\n*--------------------------------------------------------------------*\n*\n*        'JULSUB'\n*\n*\n*        WRITTEN BY. BILL GODFREY,  PLANNING RESEARCH CORPORATION.\n*        INSTALLATION. PRC COMPUTER CENTER INC, MCLEAN VA.\n*        DATE WRITTEN. JUNE 4 1976.\n*        DATE UPDATED. APRIL 23 1980.\n*         25JUN98 - CLEANED CODE AND IS NOW Y2K.                 JDM2\n*        ATTRIBUTES. RE-ENTRANT.\n*        REMARKS.\n*            THIS SUBPROGRAM CONVERTS A DATE FROM ONE FORMAT\n*            TO ANOTHER. THE DIFFERENT FORMATS ARE:\n*\n*            INPUT\n*               1   JULIAN       BINARY    F'YYYYDDD'\n*               2   STANDARD     BINARY    F'YYYYMMDD'\n*               3   JULIAN       PACKED    PL4'YYYYDDDF'\n*\n*            OUTPUT\n*               1   JULIAN       BINARY    F'YYYYDDD'\n*               2   STANDARD     BINARY    F'YYYYMMDD'\n*               4   STANDARD     8-CHAR    CL8'MM/DD/YY'\n*               8   ALPHA        8-CHAR    CL8'03JUN76 '\n*              16   PROSE        20-CHAR   CL20'JUNE 3 1976'\n*              32   FRSTLAST     BINARY    F'0' 1 - FIRST OF MONTH\n*                                               2 - LAST OF MONTH\n*              64   WEEKDAYCODE  BINARY    F'0' (SATURDAY)\n*             128   WEEKDAY      12-CHAR   CL12'SATURDAY'\n*             256   TIME         BINARY    F'100THS SEC SINCE MIDNITE'\n*             512   TIME         8-CHAR    CL8'HH:MM:SS'\n*\n*            INPUT MUST BE EITHER JULIAN OR STANDARD.\n*\n*            PASS THE FOLLOWING PARAMETERS VIA A LIST OF ADDRESSES\n*            POINTED TO BY REGISTER 1\n*               1   THE INPUT DATE\n*               2   A FULLWORD CONTAINING THE NUMERIC CODE\n*                   WHICH DEFINES THE INPUT FORMAT\n*               3   THE RECEIVING FIELD FOR OUTPUT\n*               4   A FULLWORD CONTAINING THE NUMERIC CODE\n*                   WHICH DEFINES THE OUTPUT FORMAT\n*               5   A 256 BYTE WORKAREA (ON DOUBLEWORD BOUNDARY)\n*            NOTES.\n*--------------------------------------------------------------------*\n         SPACE 1\nINP001   EQU   1\nINP002   EQU   2\nINP003   EQU   3\nOUT001   EQU   1\nOUT002   EQU   2\nOUT004   EQU   4\nOUT008   EQU   8\nOUT016   EQU   16\nOUT032   EQU   32\nOUT064   EQU   64\nOUT128   EQU   128\nOUT256   EQU   1\nOUT512   EQU   2\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nJULSUB   AMODE 24\nJULSUB   RMODE 24\nJULSUB   CSECT\n         SAVE  (14,12),,JULSUB_&SYSDATE._&SYSTIME\n         LR    R12,15\n         USING JULSUB,R12\n         LR    R2,R1\n*        GETMAIN R,LV=@DATAL       GET SAVEAREA ADDRESS\n         L     R1,16(,R1)          GET 5TH WORD ADDR OF 256 BYTE WORK\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         LR    R1,R2\n         USING @DATA,R13\n         SPACE 1\n*--------------------------------------------------------------------*\n*        R2 - ADDRESS OF INPUT DATE\n*        R3 - ADDRESS OF FULL WORD WITH OPTION CHOICE 1/2/3\n*        R4 - ADDRESS OF RECEIVING FIELD\n*        R5 - FULL WORD OF CODE DEFINING OUTPUT FORMAT.\n*--------------------------------------------------------------------*\n         SPACE 1\n         LM    R2,R3,0(R1)         GET INPUT AND DESCRIPTOR\n         LM    R4,R5,8(R1)         GET OUTPUT AND DESCRIPTOR\n         MVC   INPUT(4),0(R2)      COPY INPUT\n         XC    DOUBLE,DOUBLE\n         SLR   R14,R14             ZERO R14\n         ST    R14,FRSTLAST        INIT VALUE TO ZERO\n         ST    R14,TIMEB           INIT VALUE TO ZERO\n         CLI   3(R3),INP003        TEST FOR OPT 3, PACKED?\n         BNE   INP01               NO - BRANCH\n         SPACE 1\n*--------------------------------------------------------------------*\n*        PROCESS JULIAN PACKED INPUT\n*--------------------------------------------------------------------*\n         SPACE 1\n         ST    R14,DOUBLE          INIT VALUE TO ZERO            Y2K\n         MVC   DOUBLE+4(4),INPUT   GET FULL INPUT FIELD\n         CVB   R1,DOUBLE\n         ST    R1,JB\nJULCOMM  EQU   *\n         L     R14,DOUBLE+4        SAVE YYYYDDDF                 Y2K\n         LH    R1,DOUBLE+4         GET YYYY                      Y2K\n         SLL   R1,16               GET YYYY0000                  Y2K\n         SRL   R1,12               GET 000YYYY0                  Y2K\n         ST    R1,DOUBLE+4         STORE BACK 000YYYY0           Y2K\n         OI    DOUBLE+7,X'0F'      SET SIGN                      Y2K\n         CVB   R1,DOUBLE\n         ST    R1,YYYYB\n*        CH    R1,=H'99'                                         Y2K\n*        BH    *+8                                               Y2K\n*        AH    R1,=H'1900'                                       Y2K\n         ST    R1,CENTB\n         UNPK  YYYYC,DOUBLE+5(3)   SAVE YYYY CHAR\n         MVC   YYC,YYYYC+2\n         SPACE 1\n         ST    R14,DOUBLE+4        RESTORE 00YYDDDF\n         XC    DOUBLE(6),DOUBLE    00YYDDDF TO 0000DDDF\n         OI    DOUBLE+7,X'0F'      SET SIGN\n         UNPK  DDDC,DOUBLE+4(4)    SAVE DDD CHAR\n         CVB   R1,DOUBLE           CONVERT DDD TO BINARY\n         ST    R1,DDDB             SAVE DDD BINARY\n         SPACE 1\n         BAL   R9,TODD\n         BAL   R9,TOSB\n         BAL   R9,TOMON\n         BAL   R9,TOPROSE\n         BAL   R9,TOWEEK\n         BAL   R9,TOTIME\n         BAL   R9,OUTPUT\n         B     EXIT0\n         SPACE 1\nINP01    EQU   *\n         CLI   3(R3),INP001        INPUT JULIAN BINARY?\n         BNE   INP02               NO - BRANCH\n         L     R1,INPUT            GET BINARY YYYYDDD\n         LTR   R1,R1               ZERO?\n         BNZ   INP01A              NO - BRANCH\n         TIME  BIN\n         ST    R0,TIMEB            SAVE TIME\n         SLR   R0,R0\n         STM   R0,R1,DOUBLE\n         AP    DOUBLE+4(4),=PL4'1900000'                         Y2K\n         CVB   R1,DOUBLE\n         B     INP01B\n         SPACE 1\nINP01A   CVD   R1,DOUBLE           TO DECIMAL\nINP01B   ST    R1,JB\n         B     JULCOMM             PROCEED AS IF INP003\n         SPACE 1\n*--------------------------------------------------------------------*\n*        CONVERT JULIAN DATE TO MONTH-DAY-YEAR\n*\n*            INPUT  - YYYYB AND DDDB   (ALSO YYC)\n*\n*            OUTPUT - MMB AND DDB, MMC AND DDC, FRSTLAST\n*--------------------------------------------------------------------*\n         SPACE 1\nTODD     EQU   *\n         MVC   DPM(26),DAYSPMON\n         TM    YYYYB+3,B'00000011' IS YEAR A MULTIPLE OF 4?\n         BNZ   DPM365              NO - BRANCH\n         CLC   YYC,=C'00'          DIVISIBLE BY 100?\n         BNE   DPM366              NO - BRANCH\n         L     R15,CENTB\n         SLR   R14,R14\n         D     R14,=F'400'\n         LTR   R14,R14             EVENLY DIVISIBLE BY 400?\n         BNZ   DPM365              NO - NOT A LEAP YEAR\nDPM366   EQU   *\n         MVI   DPM+3,29            CHANGE FEB TO 29 DAYS\nDPM365   EQU   *\n         LA    R14,2               INDEX FOR DPM\n         LR    R0,R14              INDEX INCREMENT\n         L     R1,DDDB             DAY OF YEAR\nDPMLOOP  EQU   *\n         CH    R1,DPM-2(R14)       DAY LESS THAN OR EQ ENTRY?\n         BE    DPMEND              EQUAL - BRANCH\n         BL    DPMWIN              LESS - BRANCH\n         SH    R1,DPM-2(R14)       NO, SUBTRACT ENTRY FROM DAY\n         ALR   R14,R0              ADD 2 TO INDEX\n         B     DPMLOOP             LOOP\n         SPACE 1\nDPMEND   EQU   *\n         MVI   FRSTLAST+3,2        LAST DAY OF MONTH\n         B     DPMCOMM\n         SPACE 1\nDPMWIN   EQU   *\n         CH    R1,=H'1'            FIRST OF MONTH?\n         BNE   DPMCOMM             NO - BRANCH\n         MVI   FRSTLAST+3,1        FIRST DAY OF MONTH\nDPMCOMM  EQU   *\n         SRL   R14,1               HALVE INDEX TO GET MM\n         ST    R1,DDB              SAVE DD BINARY\n         CVD   R1,DOUBLE           CONVERT TO PACKED\n         OI    DOUBLE+7,X'0F'      SET SIGN\n         UNPK  DDC,DOUBLE+6(2)     SAVE DD CHAR\n         ST    R14,MMB             SAVE MM BINARY\n         CVD   R14,DOUBLE          CONVERT TO PACKED\n         OI    DOUBLE+7,X'0F'      SET SIGN\n         UNPK  MMC,DOUBLE+6(2)     SAVE MM CHAR\n         MVI   SLASH1,C'/'\n         MVI   SLASH2,C'/'\n         BR    R9\n         SPACE 1\n*--------------------------------------------------------------------*\n*        CONVERT MONTH NUMBER TO MONTH NAME\n*\n*           INPUT  - MMB     (ALSO DDC AND YYC FOR MOVE)\n*\n*           OUTPUT - MONTH AND ALPHA\n*--------------------------------------------------------------------*\n         SPACE 1\nTOMON    EQU   *\n         L     R15,MMB\n         MH    R15,=H'9'           MULT BY 9\n         LA    R15,ALPHAMON-9(R15) ADDRESS OF ENTRY\n         MVC   MONTH,0(R15)        SAVE PROSE MONTH\n         MVC   ALPHA+2(3),0(R15)   SAVE ALPHA MONTH\n         MVC   ALPHA(2),DDC\n         MVC   ALPHA+5(2),YYC\n         MVI   ALPHA+7,C' '\n         BR    R9\n         SPACE 1\n*--------------------------------------------------------------------*\n*        BUILD PROSE DATE\n*\n*           INPUT  - MONTH, DDC, YYYYC\n*--------------------------------------------------------------------*\n         SPACE 1\nTOPROSE  EQU   *\n         TM    3(R5),OUT016\n         BZR   R9\n         MVI   PROSE,C' '\n         MVC   PROSE+1(L'PROSE-1),PROSE\n         MVC   PROSE(9),MONTH\n         LA    R1,PROSE+9\nPROSE01  EQU   *\n         CLI   0(R1),C' '          BLANK?\n         BNE   PROSE02             NO - FOUND LAST LETTER\n         BCT   R1,PROSE01          BACK UP AND BRANCH\nPROSE02  EQU   *\n         MVC   2(2,R1),DDC\n         CLI   2(R1),C'0'          LEADING ZERO?\n         BNE   PROSE03             NO - BRANCH\n         MVC   2(1,R1),3(R1)       YES - SHIFT\n         MVI   3(R1),C' '\n         BCTR  R1,0\nPROSE03  EQU   *\n         MVI   4(R1),C','          COMMA AFTER DAY\n         LA    R1,1(,R1)           ADD 1 FOR COMMA\n         MVC   5(4,R1),YYYYC\n*        CLC   5(2,R1),=C'00'                                    Y2K\n*        BNE   *+10                                              Y2K\n*        MVC   5(2,R1),=C'19'                                    Y2K\n         BR    R9\n         SPACE 1\n*--------------------------------------------------------------------*\n*        INPUT IS YYYY/MM/DD BINARY\n*--------------------------------------------------------------------*\n         SPACE 1\nINP02    EQU   *\n         L     R1,INPUT\n         CVD   R1,DOUBLE           GET 0000000Y YYYMMDDF\n         LM    R14,R15,DOUBLE\n         NC    DOUBLE,=X'0000000000000FFF' ISOLATE 00000DDF\n         CVB   R1,DOUBLE\n         ST    R1,DDB\n         OI    DOUBLE+7,X'0F'\n         UNPK  DDC,DOUBLE+6(2)\n*\n         STM   R14,R15,DOUBLE\n         NC    DOUBLE,=X'00000000000FF00F' ISOLATE 000MM00F\n         L     R1,DOUBLE+4\n         SRL   R1,8\n         ST    R1,DOUBLE+4\n         OI    DOUBLE+7,X'0F'\n         CVB   R1,DOUBLE\n         CH    R1,=H'12'\n         BNH   *+8\n         LA    R1,13               SET ALL BAD MONTHS TO 13\n         ST    R1,MMB\n         UNPK  MMC,DOUBLE+6(2)\n*\n         SRDL  R14,4               GET YYYYMMDD\n         SLR   R14,R14             GET 00000000 IN R14\n         SRL   R15,12              GET 000YYYYM IN R15\n         STM   R14,R15,DOUBLE\n         OI    DOUBLE+7,X'0F'\n         CVB   R1,DOUBLE\n         ST    R1,YYYYB\n*        CH    R1,=H'99'                                         Y2K\n*        BH    *+8                                               Y2K\n*        AH    R1,=H'1900'                                       Y2K\n         ST    R1,CENTB\n         UNPK  YYYYC,DOUBLE+5(3)\n         MVC   YYC,YYYYC+2\n         MVI   SLASH1,C'/'\n         MVI   SLASH2,C'/'\n*\n         BAL   R9,TOSB\n         BAL   R9,TOJUL\n         BAL   R9,TOMON\n         BAL   R9,TOPROSE\n         BAL   R9,TOWEEK\n         BAL   R9,TOTIME\n         BAL   R9,OUTPUT\n         B     EXIT0\n         SPACE 1\n*--------------------------------------------------------------------*\n*        CONVERT M/D/Y TO JULIAN\n*\n*           INPUT  - MMB, DDB, YYYYB\n*\n*           OUTPUT - DDDB, DDDC, JB\n*--------------------------------------------------------------------*\n         SPACE 1\nTOJUL    EQU   *\n         MVC   DPM(26),DAYSPMON\n         TM    YYYYB+3,B'00000011' IS YEAR A MULTIPLE OF 4?\n         BNZ   JUL365              NO - BRANCH\n         CLC   YYC,=C'00'          DIVISIBLE BY 100?\n         BNE   JUL366              NO - BRANCH\n         L     R15,CENTB\n         SLR   R14,R14\n         D     R14,=F'400'\n         LTR   R14,R14             EVENLY DIVISIBLE BY 400?\n         BNZ   JUL365              NO - NOT A LEAP YEAR\nJUL366   EQU   *\n         MVI   DPM+3,29             CHANGE FEB TO 29 DAYS\nJUL365   EQU   *\n         L     R15,DDB              GET DAYS IN CURRENT MONTH\n         LR    R0,R15               SAVE IT TO COMPARE FOR LAST DAY\n         L     R14,MMB              GET CURRENT MONTH\n         BCTR  R14,0                GET NO. OF COMPLETED MONTHS\n         LA    R1,DPM\n         LTR   R14,R14              JANUARY?\n         BNP   JULEND               YES - BRANCH\n         B     *+8\nJULOOP   EQU   *\n         LA    R1,2(,R1)            POINT TO NEXT MONTH\n         AH    R15,0(,R1)           ADD DAYS IN MONTH TO TOTAL\n         BCT   R14,JULOOP\nJULEND   EQU   *\n         CH    R0,0(,R1)            LAST DAY OF MONTH?\n         BNE   *+8                  NO\n         MVI   FRSTLAST+3,2         YES\n         CH    R0,=H'1'             FIRST DAY OF MONTH?\n         BNE   *+8                  NO\n         MVI   FRSTLAST+3,1         YES\n         ST    R15,DDDB             SAVE DDD\n         CVD   R15,DOUBLE\n         OI    DOUBLE+7,X'0F'       SET SIGN\n         UNPK  DDDC,DOUBLE+4(4)     SAVE DDD CHAR\n         MVC   JC(4),YYYYC                                       Y2K\n         PACK  DOUBLE,JC                                         Y2K\n         CVB   R1,DOUBLE\n         ST    R1,JB\n         BR    R9\n         SPACE 1\n*\n*\n*\n         SPACE 1\nTOSB     EQU   *\n         MVC   WORK(4),YYYYC\n         MVC   WORK+4(2),MMC\n         MVC   WORK+6(2),DDC\n         PACK  DOUBLE,WORK(8)\n         CVB   R1,DOUBLE\n         ST    R1,SB\n         BR    R9\n         SPACE 1\n*--------------------------------------------------------------------*\n*        GET DAY OF WEEK\n*\n*            INPUT  - MMB, DDB, YYYYB\n*\n*            OUTPUT - WEEKB, WEEKC\n*\n*            N = D + 2M + 3(M+1)/5 + Y + Y/4 - Y/100 + Y/400 + 2\n*\n*               WHERE M = 3-14 (JAN,FEB ARE 13,14 OF Y-1)\n*\n*               N/7 LEAVES REMAINDER 0-6, 0 INDICATING SATURDAY\n*--------------------------------------------------------------------*\n         SPACE 1\nTOWEEK   EQU   *\n         TM    3(R5),OUT064+OUT128\n         BZR   R9\n         L     R1,DDB              SET N = D\n         L     R15,CENTB\n         L     R14,MMB\n         CH    R14,=H'2'           JAN OR FEB?\n         BH    WEEKMMOK\n         BE    WEEKFEB\n         LA    R14,13              SET M=13\n         B     WEEKYMIN\n         SPACE 1\nWEEKFEB  EQU   *\n         LA    R14,14              SET M=14\nWEEKYMIN EQU   *\n         BCTR  R15,0               SET Y = Y-1\nWEEKMMOK EQU   *\n         LR    R0,R14              COPY M\n         ALR   R0,R0               GET 2M\n         ALR   R1,R0               SET N = N + 2M\n         LR    R0,R15              SAVE REDEFINED Y\n         SPACE 1\n         LA    R14,1(,R14)         GET M+1\n         MH    R14,=H'3'           GET 3(M+1)\n         SRDL  R14,32              SHIFT INTO R15, ZERO R14\n         D     R14,=F'5'           GET 3(M+1)/5 IN R15\n         ALR   R1,R15              SET N = N + 3(M+1)/5\n         SPACE 1\n         LR    R15,R0              GET Y\n         ALR   R1,R15              SET N = N + Y\n         SLR   R14,R14             ZERO R14\n         D     R14,=F'4'           GET Y/4\n         ALR   R1,R15              SET N = N + Y/4\n         SPACE 1\n         LR    R15,R0              GET Y\n         SLR   R14,R14             ZERO R14\n         D     R14,=F'100'         GET Y/100\n         SLR   R1,R15              SET N = N - Y/100\n         SPACE 1\n         LR    R15,R0              GET Y\n         SLR   R14,R14             ZERO R14\n         D     R14,=F'400'         GET Y/400\n         ALR   R1,R15              SET N = N + Y/400\n         LA    R15,2               GET 2\n         ALR   R1,R15              SET N = N + 2\n         SLR   R0,R0               ZERO R0\n         D     R0,=F'7'            SET N = N/7\n         ST    R0,WEEKB            SAVE REMAINDER\n         LR    R1,R0\n         MH    R1,=H'9'\n         LA    R14,WEEKDAYS(R1)    POINT TO NAME\n         MVC   WEEKC(9),0(R14)     MOVE NAME\n         MVC   WEEKC+9(3),WEEKBLNK PLUS 3 BLANKS\n         BR    R9\n         SPACE 1\n*--------------------------------------------------------------------*\n*        CONVERT TIMEB TO TIMEC\n*\n*           DIVIDE BY 10,10,10,6,10,6,10,6\n*--------------------------------------------------------------------*\n         SPACE 1\nTOTIME   EQU   *\n         TM    2(R5),OUT512\n         BNOR  R9\n         L     R15,TIMEB\n         LA    R6,10               INITIAL DIVISOR\n         LA    R7,12               SET DIVISOR MASK\n         LA    R8,32               SHIFT COUNT\nDECLOOP  EQU   *\n         SR    R14,R14\n         DR    R14,R6\n         LR    R0,R14              SAVE REMAINDER\n         SRDL  R0,4                SHIFT INTO R1\n         SH    R8,=H'4'            DECREMENT SHIFT COUNT\n         LTR   R15,R15             QUOTIENT ZERO?\n         BZ    TOTIMX              YES - BRANCH\n         CL    R8,=F'24'           IF COUNT LT 24\n         BNL   DECLOOP             NO - BRANCH\n         XR    R6,R7               10 TO 6 TO 10 ETC\n         B     DECLOOP\n         SPACE 1\nTOTIMX   EQU   *\n         SRL   R1,0(R8)            SHIFT REMAINING BITS\n         SRL   R1,4                GET 0HHMMSST\n         ST    R1,DOUBLE\n         OI    DOUBLE+3,X'0F'\n         MVC   DOUBLE+6(10),=X'402120204B20204B2020'\n         ED    DOUBLE+6(10),DOUBLE\n         MVC   TIMEC,DOUBLE+8\n         BR    R9\n         SPACE 1\n*---------------------------------------------------------------------*\n*        FORMAT THE OUTPUT AREA BASED UPON 4TH WORD IN PARM LIST.\n*---------------------------------------------------------------------*\n         SPACE 1\nOUTPUT   EQU   *\n         LR    R1,R4               GET THE NUMBER\n         TM    3(R5),OUT001        IS IT 1 - JULIAN BINARY F\"YYYYDDD\"\n         BZ    *+14\n         MVC   0(4,R1),JB          4 CHARACTERS LONG\n         LA    R1,4(,R1)\n         TM    3(R5),OUT002        IS IT 2 - STD BINARY F\"YYYYMMDDD\"\n         BZ    *+14\n         MVC   0(4,R1),SB          4 CHARACTERS LONG\n         LA    R1,4(,R1)\n         TM    3(R5),OUT004        IS IT 4 - STD CHAR \"MM/DD/YY\"\n         BZ    *+14\n         MVC   0(8,R1),SC          8 CHARACTERS LONG\n         LA    R1,8(,R1)\n         TM    3(R5),OUT008        IS IT 8 - ALPHA \"03JUN76 \"\n         BZ    *+14\n         MVC   0(8,R1),ALPHA       8 CHARACTERS LONG\n         LA    R1,8(,R1)\n         TM    3(R5),OUT016        IS IT 16 - 20CHAR \"JUNE 3 1976  \"\n         BZ    *+14\n         MVC   0(L'PROSE,R1),PROSE\n         LA    R1,L'PROSE(,R1)\n         TM    3(R5),OUT032        IS IT 32 - FIRST/LAST  ( 0 / 1 )\n         BZ    *+14\n         MVC   0(4,R1),FRSTLAST    4 BYTES\n         LA    R1,4(,R1)\n         TM    3(R5),OUT064        IS IT 64 - WEEKDAY CODE 0-SAT/6-FRI\n         BZ    *+14\n         MVC   0(4,R1),WEEKB       4 BYTES\n         LA    R1,4(,R1)\n         TM    3(R5),OUT128        IS IT 128 - WEEKDAY NAME\n         BZ    *+14\n         MVC   0(12,R1),WEEKC      12 BYTES\n         LA    R1,12(,R1)\n         TM    2(R5),OUT256        IS IT 256 - TIME BINARY\n         BZ    *+14\n         MVC   0(4,R1),TIMEB       4 BYTES\n         LA    R1,4(,R1)\n         TM    2(R5),OUT512        IS IT 512 - TIME 8 CHAR HH:MM:SS\n         BZ    *+14\n         MVC   0(8,R1),TIMEC       8 BYTES\n         LA    R1,8(,R1)\n         BR    R9\n         SPACE 1\nEXIT0    SR    R15,R15\nEXIT     LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)\n*        FREEMAIN R,A=(1),LV=@DATAL  (COMMENT)\n         LM    R14,R12,12(R13)\n         BR    R14\n         SPACE 1\n*--------------------------------------------------------------------*\n*        CONSTANTS\n*--------------------------------------------------------------------*\n         SPACE 1\nDAYSPMON DC    H'31,28,31,30,31,30,31,31,30,31,30,31,999'\nALPHAMON DC    CL36'JANUARY  FEBRUARY MARCH    APRIL    '\n         DC    CL36'MAY      JUNE     JULY     AUGUST   '\n         DC    CL36'SEPTEMBEROCTOBER  NOVEMBER DECEMBER '\n         DC    CL09'UNKNOWN  '\nWEEKDAYS DC    CL36'SATURDAY SUNDAY   MONDAY   TUESDAY  '\n         DC    CL27'WEDNESDAYTHURSDAY FRIDAY   '\nWEEKBLNK EQU   WEEKDAYS+15         3 BLANKS\n         LTORG\n         SPACE 1\n*--------------------------------------------------------------------*\n*        DSECTS\n*--------------------------------------------------------------------*\n         SPACE 1\n@DATA    DSECT\n         DS    18F\nINPUT    DS    CL8\nDOUBLE   DS    D\nWORK     DS    8C\nSC       DS    0CL8\nMMC      DS    CL2\nSLASH1   DS    C\nDDC      DS    CL2\nSLASH2   DS    C\nYYC      DS    CL2\nYYYYC    DS    CL4\nDDB      DS    F\nMMB      DS    F\nYYYYB    DS    F\nCENTB    DS    F\nDDDB     DS    F\nJB       DS    F\nSB       DS    F\nWEEKB    DS    F\nFRSTLAST DS    F\nTIMEB    DS    F\nTIMEC    DS    CL8\nJC       DS    0CL7                                              Y2K\n         DS    CL4                                               Y2K\nDDDC     DS    CL3\nMONTH    DS    CL9\nALPHA    DS    0CL8\n         DS    CL2\nMON      DS    CL3\n         DS    CL2\n         DS    CL1                 BLANK FILLER LAST BYTE OF ALPHA\nWEEKC    DS    CL12\nPROSE    DS    CL20\nDPM      DS    13H\n@DATAL   EQU   *-@DATA\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PRINTOFX": {"ttr": 4357, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x14\\x01\\x13!O\\x01\\x13!O\\x13U\\x0be\\x00\\x9e\\x00\\x00\\xd5\\xc5\\xe6`\\xe8\\xf2\\xd2@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2013-08-02T00:00:00", "modifydate": "2013-08-02T13:55:14", "lines": 2917, "newlines": 158, "modlines": 0, "user": "NEW-Y2K"}, "text": "//SBGOLOBU JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//* ----------------------------------------------------------------- *\n//*                   P  R  I  N  T  O  F  F                          *\n//* ----------------------------------------------------------------- *\n//* REASSEMBLABLE VERSION WITH OLD VERSION OF IKJEFLPA AND IKJEFLPB   *\n//* DISASSEMBLED, AND FIRST BYTE OF IKJEFLPB ZAPPED FROM '19' TO '20' *\n//* SO THE DATES COME OUT WITH 20XX INSTEAD OF 19XX.                  *\n//* ----------------------------------------------------------------- *\n//*    THIS VERSION COMES FROM WELLS FARGO FILE, CBT TAPE FILE 325.   *\n//* ----------------------------------------------------------------- *\n//REASMLNK PROC\n//ASM    EXEC  PGM=ASMA90,REGION=2048K,\n//   PARM=(DECK,NOOBJECT,NORLD,RENT,TERM,'XREF(SHORT)',FLAG(5))\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(CYL,(10,5))\n//SYSUT2   DD  UNIT=SYSDA,SPACE=(CYL,(10,5))\n//SYSUT3   DD  UNIT=SYSDA,SPACE=(CYL,(10,5))\n//SYSPUNCH DD  UNIT=SYSDA,SPACE=(TRK,(5,5)),DISP=(MOD,PASS),DSN=&&X,\n//             DCB=BLKSIZE=3120\n//SYSPRINT DD  SYSOUT=*\n//SYSTERM  DD  SYSOUT=*\n//SYSLIB   DD  DSN=SYS1.MODGEN,DISP=SHR\n//         DD  DSN=SYS1.MACLIB,DISP=SHR\n//LKED   EXEC  PGM=IEWL,PARM='MAP,RENT,REUS,REFR,LET,NCAL',COND=(0,LT)\n//SYSPRINT DD  SYSOUT=*\n//SYSLIBX  DD  DSN=&&X,DISP=(OLD,DELETE)\n//SYSLMOD  DD  DISP=SHR,DSN=&OUTPUT\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(TRK,(5,5))\n//       PEND\n//*\n//PRINTOFF  EXEC REASMLNK,OUTPUT='SBGOLOB.LOAD',          <=== CHANGE\n//  PARM.LKED='NCAL,MAP,LIST,LET'\n//ASM.SYSIN   DD *\n*\n*  NOTE TO FUTURE ASSEMBLERS ... PRINTOFF NORMALLY RESIDES IN\n*  A LINKLIB WITH  A L I A S E S  PRINTO AND PO.\n*  THE HELP ENTRY SHOULD BE ASSIGNED THE SAME ALIASES.\n*\nPRINTOFF TITLE 'IPO-SUPPLIED PRINT COMMAND - MODIFIED BY GTEL, ARAMCO, C\n               WFB      '                                           WFB\n***********************************************************************\n*                                                                     *\n*             MODULE NAME = PRINTOFF                                  *\n*                                                                     *\n*             DESCRIPTIVE NAME =  IPO SUPPLIED PRINT COMMAND FOR      *\n*                TSO FOREGROUND EXECUTION                             *\n*                                                                     *\n*             COPYRIGHT = NONE                                        *\n*                                                                     *\n*             STATUS = RELEASE 01.0 OF IPO                            *\n*                                                                     *\n*             FUNCTION =                                              *\n*                PRINTS A DATASET(S) WHICH IS SEQUENTIAL OR PARTIONED *\n*                ALLOWING THE USER TO SPECIFY OUTPUT CLASS, COPIES,   *\n*                DESTINATION AND HOLD/NOHOLD.  ALSO ALLOWS THE USER   *\n*                TO SPECIFY LIST/NOLIST, PRINT/NOPRINT, VOLUME,       *\n*                FOLD/NOFOLD, DS/SS, LINELENGTH AND PAGELENGTH     GTEL\n*                LIST IF PDS MEMBER NAMES ARE ONLY TO BE LISTED.      *\n*                PRINT IF PDS MEMBERS ARE ONLY TO BE PRINTED.         *\n*                SEE 'CHANGE ACTIVITY' FOR ADDITIONAL OPTIONS.      WFB\n*                                                                     *\n*                OPERATION =                                          *\n*                   BUILD PARS, DAIR, AND PUTLINE PARAMETER LISTS.    *\n*                   CALL PARS TO PARSE COMMAND BUFFER.                *\n*                   ALLOCATE DATASET AND DETERMINE IF PDS OR          *\n*                      SEQUENTIAL.                                    *\n*                   DETERMINE WHAT FUNCTIONS WERE TO BE PERFORMED     *\n*                      FOR THIS DATASET IF PDS.                       *\n*                   ALLOCATE SYSOUT DATASETS WHEN SOMETHING IS        *\n*                      FOUND TO BE PRINTED.                           *\n*                   PROCESS NEXT DATASET IN LIST.                     *\n*                   AT END OF LIST CLOSE DATASETS AND FREE ANY        *\n*                      SYSOUT DATASETS AND INPUT DATASETS.         GTEL\n*                   DATSETS WILL BE PRINTED AS EITHER VBA OR VBM.     *\n*                                                                     *\n*              NOTES =                                                *\n*                                                                     *\n*                 DEPENDENCIES = CHARACTER SET IS EBCDIC.  REASSEMBLE *\n*                    IF A DIFFERENT CHARACTER SET IS NEEDED.          *\n*                                                                     *\n*                                                                     *\n*                 RESTRICTIONS = DATASETS MUST HAVE LRECL NOT       WFB\n*                    GREATER THAN 32,760 AND MUST NOT               WFB\n*                    CONTAIN SPANNED RECORDS.  IN ADDITION,        GTEL\n*                    IF PAGELEN, DS, OR SS IS SPECIFIED, ALL       GTEL\n*                    OTHER CARRIAGE CONTROL WILL BE IGNORED.       GTEL\n*                                                                     *\n*                 REGISTER CONVENTIONS = STANDARD CONVENTIONS.        *\n*                    REGISTERS 0 TO 10 = WORK REGISTERS               *\n*                    REGISTERS 11,12   = ADDRESSIBILITY TO         GTEL\n*                                        PRINTOFF CSECT            GTEL\n*                    REGISTER  13      = SAVE AREA REGISTER AND       *\n*                                        ADDRESSABILITY TO GETMAINED  *\n*                                        WORK AREA                    *\n*                    REGISTERS 14,15   = WORK REGISTERS               *\n*                                                                     *\n*                PATCH LABEL = PATCH, UNUSED AND INTIALIZED TO        *\n*                   DC 20S(*)                                      WFB*\n*                                                                     *\n*                TSO COMMAND SYNTAX                                 WFB\n* PRINTOFF (DSLIST)/*  DDNAME(DDNAME)/FILE(DDNAME)                    *\n*          UNIT(UNIT-TYPE)  VOLUME(VOLSER)     NOMESSAGES/NOMSGS      *\n*          CLASS(CLASS)     DEST(DESTINATION)  COPIES(NNN)            *\n*          HOLD/NOHOLD      LIST/NOLIST        PRINT/NOPRINT          *\n*          FORMS(FORM)      FCB(FCB)           TRAIN(IMAGE)/UCS(IMAGE)*\n*          HEADING/NOHEADING                   CAPS/ASIS/FOLD/NOFOLD  *\n*          NOCC/SINGLESPACE/SS/DOUBLESPACE/DS  ASA                    *\n*          LINELENGTH(NNN)/LL(NNN)             PAGELENGTH(NNN)/PL(NNN)*\n*          BURST/NOBURST    FLASH(FLASH-NAME)  CHARS(CHARSET-NAME(S)) *\n*          PROG(PROGNAME)   UDKFONT(FONT-NAME)                        *\n* REQUIRED -- DSLIST OR * IF DDNAME(...)                              *\n* ALIASES  -- PRINTO, PO                                              *\n* DEFAULTS -- CLASS(A), COPIES(1), NOHOLD, LIST, PRINT, FORM($TST),   *\n*             HEADING, ASIS, LINELENGTH(132), PAGELENGTH(60), NOBURST,*\n*             SINGLESPACE IF PAGELENGTH(...) OR IF INPUT RECFM NOT A/M*\n*                                                                     *\n*             MODULE TYPE = PROCEDURE                                 *\n*                                                                     *\n*                PROCESSOR = ASM                                      *\n*                                                                     *\n*                MODULE SIZE = 13K BYTES                              *\n*                                                                     *\n*                ATTRIBUTES = SCHEDULER KEY 8, REENTRANT,             *\n*                   PROBLEM PROGRAM STATE                             *\n*                                                                     *\n*             ENTRY POINTS = PRINTOFF (ONLY ENTRY POINT)              *\n*                                                                     *\n*                LINKAGE =                                            *\n*                   FROM TERMINAL MONITOR PROGRAM AS A COMMAND        *\n*                                                                     *\n*             INPUT = REGISTER 1 POINTS TO COMMAND PROCESSOR          *\n*                PARAMETER LIST MAPPED BY IKJCPPL MACRO               *\n*                                                                     *\n*             OUTPUT = NONE                                           *\n*                                                                     *\n*             EXIT - NORMAL = AT PROGRAM END VIA BRANCH REGISTER 14   *\n*                                                                     *\n*                OUTPUT = NONE                                        *\n*                                                                     *\n*                RETURN CODE = ZERO                                   *\n*                                                                     *\n*             EXIT - ERROR = NONE - PROGRAM WILL DISPLAY DECIMAL      *\n*                RETURN CODE AND RETURN VIA BRANCH REGISTER 14        *\n*                                                                     *\n*                OUTPUT = NONE                                        *\n*                                                                     *\n*                RETURN CODE = ZERO                                   *\n*                                                                     *\n*             EXTERNAL REFERENCES =                                   *\n*                                                                     *\n*                ROUTINES = IKJPARS, DAIRFAIL, GNRLFAIL, PUTLINE      *\n*                   IKJEFLPA  (SEE NOTE IN 'CHANGE ACTIVITY')       WFB\n*                                                                     *\n*                DATA AREAS = NONE                                    *\n*                                                                     *\n*                CONTROL BLOCKS = CPPL, PPL, DAPL, DCB, DAPB, CVT,    *\n*                   S99RBP, S99RB, S99TUPL, S99TUNIT, S99TUFLD,       *\n*                   GFPARMS, DFPARMS, IOPL, IOPB                      *\n*                                                                     *\n*             TABLES = DATA AREA TO BE GETMAINED.  MAPPED BY DSECT    *\n*                BEGINNING AT LABEL WORKAREA                        WFB\n*                                                                     *\n*             MACROS = SAVE, GETMAIN, CALLTSSR, LINK, TPUT, FREEMAIN, *\n*                   OPEN, PUT, GET, CLOSE, RDJFCB, IKJRLSA, DYNALLOC, *\n*                   DCB, IKJPARM, IKJPOSIT, IKJKEYWD, IKJNAME,        *\n*                   IKJSUBF, IKJIDENT, IKJENDP, IKJDAP08, IKJDAP18,   *\n*                   IKJDAPL, IKJCPPL, IKJPPL, CVT, IEFZB4D0, IKJIOPL, *\n*                   IEFZB4D2, DCBD, IKJEFFGF, IKJEFFDF, PUTLINE       *\n*                                                                     *\n*             CHANGE ACTIVITY = 3800 SUPPORT ADDED VIA SETPRT   ARAMCO*\n*                               MAY 1981                        ARAMCO*\n*                                                                     *\n*             MODIFIED BY SAM LEPORE, WFB: 01/86                    WFB\n*               * CORRECT ERROR, 'NOHEAD' CAUSED BLANK FIRST PAGE   WFB\n*               * CORRECT ERRORS IN LENGTH OF TEXTG THROUGH TEXTJ   WFB\n*               * INCREASE INPUT RECORD LIMIT TO 32,760             WFB\n*               * CHANGE DSNAME POSIT TO DSTHING TO ALLOW FOR DDN() WFB\n*               * CHANGE DEST KEYWORD TO ACCEPT 8 CHAR VALUE        WFB\n*               * CHANGE DEST KEYWORD TO ACCEPT NODE AND USERID     WFB\n*               * ADD DDNAME(...) KEYWORD TO ALLOW TEMP OR VIO DSNS WFB\n*               * ADD UNIT(...) KEYWORD FOR USE WITH VOLUME(...)    WFB\n*               * ADD 'VOLUME: VOLSER' TO HEADING WHEN SPECIFIED    WFB\n*    +--------> * ADD TIME AND 'MONTHNAME DAY, YEAR' TO DSN HEADING WFB\n*    :          * ADD NOMSGS KEYWORD TO STOP NON-ERROR MSGS TO TERM WFB\n*    :          * ADD DSECT=YES TO CVT MACRO FOR CLEAN XA ASSEMBLY  WFB\n*    :          * MOVE ALL PUTLINE TEXT TO SEPARATE MESSAGES CSECT  WFB\n*    :                (FOLLOWING CHANGES ARE WFB SPECIFIC)          WFB\n*    :          * MAKE WFB DEFAULT FORM($TST)                       WFB\n*    :                                                              WFB\n*    +-- NOTE ==> THE TIME-DATE ROUTINE IKJEFLPA NORMALLY RESIDES   WFB\n*                 ONLY IN SYS1.AOST4. THIS LIBRARY MUST BE INCLUDED WFB\n*                 IN THE LINKEDIT SYSLIB FOR PROPER RESOLUTION.     WFB\n*                                                                     *\n*    +-- NOTE ==> (SBG - NO MORE. IKJEFLPA FROM IBM IS NOW            *\n*                        INCOMPATIBLE, SO WE DISASSEMBLED THE         *\n*                        OLD ONE, FIXED THE \"CENTURY\" PROBLEM,        *\n*                        AND WE ARE INCLUDING ITS SOURCE HERE.)       *\n*                                                                   WFB\n*             MODIFIED BY SAM LEPORE, WFB: 01/87                    WFB\n*                                                                   WFB\n*               * CORRECT ERROR, 'NOHEAD' OFFSET LINE COUNT PAGE 1  WFB\n*               * ADD ASA KEYWORD TO ACCEPT CC WHEN RECFM NOT ..A   WFB\n*               * ADD NOCC KEYWORD ALIAS OF SINGLESPACE             WFB\n*               * ADD UDKFONT(...) KEYWORD FOR XEROX 2700/3700 FONT WFB\n*               * DELETE OLD LINES MARKED *DELETED OR 'DELETED CODE'WFB\n*                                                                     *\n*             MODIFIED BY SAM GOLOB    08/13    Z/OS 1.13             *\n*                                                                     *\n*               * NEW VERSION OF IKJEFLPA IS INCOMPATIBLE WITH THIS   *\n*                 ASSEMBLY. DISASSEMBLED THE OLD VERSION AND FIXED    *\n*                 MODULE IKJEFLPB SO DATES READ 20XX AND NOT 19XX.    *\n*                 (THIS MODULE IS ONLY INCLUDED TO FIND DATE AND      *\n*                 TIME OF THE PRINTOFF RUN. IT WORKS, SO WE DIDN'T    *\n*                 CHANGE IT, EXCEPT FOR THE \"CENTURY ZAP\" - FIRST     *\n*                 BYTE OF IKJEFLPB. X'19' TO X'20'.)                  *\n*               * ADJUSTED OLD \"SAVE\" MACRO SO IT ASSEMBLES PROPERLY  *\n*                 AND &SYSTIME IS NOW INCLUDED FOR CLARITY.           *\n*               * ASSEMBLY JOB NOW INCLUDES IKJEFLPA AND IKJEFLPB.    *\n*                                                                     *\n*                                                                     *\n*             MESSAGES =                                              *\n*                                                                     *\n*                BOTH THE DAIRFAIL AND GNRLFAIL SERVICE ROUTINES ARE  *\n*                USED TO ISSUE MESSAGES.                              *\n*                THOSE ISSUED BY THE COMMAND ARE FOUND FOLLOWING THE  *\n*                LABEL GNRLERR AND ARE ISSUED USING PUTLINE.          *\n*                                                                     *\n*             ABEND CODES = NONE                                      *\n*                                                                     *\n***********************************************************************\n*\nPRINTOFF CSECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         B     BEGINN-*(,R15)          FAKE IPO VERSION'S SAVE MACRO\n         DC    AL1(31)\n         DC    C'HARDCOPY.IPO.'\n         DC    CL8'&SYSDATE'\n         DC    C' '\n         DC    CL8'&SYSTIME'           ADD TIME FOR REFERENCE\nBEGINN   DS    0H\n         STM   14,12,12(13)\n         LR    R12,R15                 LOAD REGISTER 12 WITH ENTRY\n*                                      ADDRESS\n         USING PRINTOFF,R12            ESTABLISH ADDRESSABILITY TO\n*                                      PROGRAM CSECT\n         LA    R11,4095(R12)           LOAD REGISTER 11 WITH ENTRY\n*                                      ADDRESS 4095\n         USING PRINTOFF+4095,R11       ESTABLISH ADDRESSABILITY TO THE\n*                                      REST OF THE PROGRAM CSECT\n         LR    R8,R1                   LOAD REGISTER 8 TO PRESERVE\n*                                      POINTER TO COMMAND PROCESSOR\n*                                      PARAMETER LIST\n         GETMAIN R,LV=LDYNAMIC         GETMAIN DYNAMIC WORKAREA\n         LR    R10,R1                  LOAD REGISTER 10 TO PRESERVE\n*                                      POINTER TO WORKAREA\n         ST    R13,4(R10)              STORE ADDRESS OF PREVIOUS\n*                                      SAVEAREA\n         ST    R10,8(,R13)             STORE ADDRESS OF CURRENT\n*                                      SAVEAREA IN PREVIOUS SAVEAREA\n         LR    R13,R10                 LOAD REGISTER 13 WITH ADDRESS OF\n*                                      CURRENT SAVEAREA\n         USING WORKAREA,R13            ESTABLISH ADDRESSABILITY TO\n*                                      DYNAMIC WORKAREA\n         GETMAIN R,LV=RECSIZE          GETMAIN RECORD AREA          WFB\n         ST    R1,ALNDSECT             SAVE ADDRESS OF RECORD      GTEL\n*\n***********************************************************************\n*                                                                     *\n*        BUILD PARSE AND DAIR PARAMETER LISTS USING COMMAND           *\n*           PROCESSOR PARAMETER LIST                                  *\n*        INITIALIZE OUTPUT DATA CONTROL BLOCKS IN WORKAREA            *\n*                                                                     *\n***********************************************************************\n*\n         USING CPPL,R8                 ESTABLISH ADDRESSABILITY TO CPPL\n         LA    R4,PPLSECT              LOAD ADDRESS OF PARSE PARAMETER\n*                                      LIST\n         USING PPL,R4                  ESTABLISH ADDRESSABILITY TO PPL\n         LA    R6,DAPLSECT             LOAD ADDRESS OF DAIR PARAMETER\n*                                      LIST\n         USING DAPL,R6                 ESTABLISH ADDRESSABILITY TO DAPL\n         LA    R5,IOPLSECT             LOAD ADDRESS OF PUTLINE\n*                                      PARAMETER LIST\n         USING IOPL,R5                 ESTABLISH ADDRESSABILITY TO IOPL\n         L     R1,CPPLUPT              LOAD POINTER TO USER PROFILE\n*                                      TABLE FROM CPPL\n         L     R2,CPPLECT              LOAD POINTER TO ENVIRONMENT\n*                                      CONTROL TABLE FROM CPPL\n         SLR   R3,R3                   ZERO REGISTER 3\n         ST    R3,ECB                  STORE REGISTER AS ECB FOR PPL\n         LA    R3,ECB                  LOAD ADDRESS OF ECB\n         STM   R1,R3,DFPLSECT          STOR UPT,ECT,ECB IN DFPL    GTEL\n         STM   R1,R3,PPLSECT           STORE ADDRESS OF UPT, ECT, AND\n*                                      ECB IN PPL\n         STM   R1,R3,DAPLSECT          STORE ADDRESS OF UPT, ECT, AND\n*                                      ECB IN DAPL\n         STM   R1,R3,IOPLSECT          STORE ADDRESS OF UPT, ECT, AND\n*                                      ECB IN IOPL\n         LA    R3,IOPB                 LOAD ADDRESS OF PUTLINE\n*                                      PARAMETER BLOCK\n         ST    R3,IOPLIOPB             STORE IOPB ADDRESS IN IOPL\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** START OF GTEL MOD ************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*   INITIALIZE DFPL AND DFPB SO REST OF NAME CAN BE DETERMINED\n         LA    R3,DFPBSECT             GET ADDRESS OF DFPB\n         ST    R3,DFPLSECT+12          PUT IT IN THE CNTL BLK\n         USING  DFPB,R3                TELL ASSEMBLER\n         LA     R2,DFPBDSL             GET ADDRESS OF DSN LENGTH\n         ST     R2,DFPBDSN             SAVE IT\n         LA     R2,DFPBQUA             GET ADDRESS OF QUAL\n         ST     R2,DFPBQUAL            STORE IT\n         MVI    DFPBCODE,DFPB04        MOVE IN TYPE\n         MVC    DFPBPSCB,CPPLPSCB      MOVE IN PSCB ADDRESS\n         MVI    DFPBCNTL,DFPBRET       MOVE IN DFPBRET\n         XC     DFPBCAT(8),DFPBCAT     CLEAR AREA\n         DROP    R3\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** END OF GTEL MOD **************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         MVC   PPLPCL,PCLADDR          MOVE POINTER TO PARAMETER\n*                                      CONTROL LIST INTO PPL\n         LA    R2,PARSBACK             LOAD ADDRESS OF FULLWORD TO\n*                                      CONTAIN ADDRESS OF PDE RETURNED\n*                                      BY PARS\n         ST    R2,PPLANS               STORE POINTER TO RETURN ADDRESS\n         MVC   PPLCBUF,CPPLCBUF        MOVE POINTER TO COMMAND BUFFER\n*                                      INTO PPL\n*DELETED LA    R2,PPLUWA               LOAD ADDR OF USER WORK AREA  WFB\n*DELETED ST    R2,PPLUWA               STORE ADDRESS IN PPL         WFB\n         ST    R13,PPLUWA              PASS THE DYNAMIC WORK AREA   WFB\n*                                      TO PARSE VALIDITY CHECK RTNE WFB\n         MVC   DAPLPSCB,CPPLPSCB       MOVE POINTER TO PSCB INTO DAPL\n         DROP  R4,R5,R6,R8             DROP ADDRESSABILITY TO CPPL,\n*                                      IOPL, DAPL, AND PPL\n         MVC   OUTPUTA(OUTPUTAL),OUTPUTAC  MOVE ASA DCB CONSTANT INTO\n*                                      ASA DCB IN WORKAREA\n         MVC   OUTPUTM(OUTPUTML),OUTPUTMC  MOVE MACHINE DCB CONSTANT\n*                                      INTO MACHINE DCB IN WORKAREA\n*\n***********************************************************************\n*                                                                     *\n*        CALLTSSR TO PARSE (ENTRY NAME IKJPARS)                       *\n*        ON RETURN PARSBACK -> PDL                                    *\n*        HANDLE ALL ERROR CODES RETURNED BY PARS                      *\n*        IF NECESSARY CALL GENERAL FAIL SERVICE ROUTINE               *\n*                                                                     *\n***********************************************************************\n*\n         CALLTSSR  EP=IKJPARS,MF=(E,PPLSECT)\n*                                      CALL PARS TO PARSE COMMAND\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO\n         BZ    GOODPARS                YES....GO TO GOOD PARS ROUTINE\n         C     R15,FULL4               SEE IF RETURN CODE IS FOUR\n         BE    RETURN                  YES....PARS ISSUED ERROR\n*                                      MESSAGE.  GO CLEANUP AND RETURN\n         C     R15,FULL20              SEE IF RETURN CODE IS TWENTY\n         BE    RETURN                  YES....VALIDITY CHECKING\n*                                      ROUTINE ISSUED ERROR MESSAGE.\n*                                      GO CLEANUP AND RETURN\n         XC    GFPARMS(GFLENGF),GFPARMS  INITIALIZE PARMLIST FOR\n*                                      GENERAL FAIL TO ZEROS\n         LA    R1,GFPARMS              LOAD ADDRESS OF PARMLIST\n         ST    R1,GFPARMP              STORE ADDRESS AS POINTER TO\n*                                      PARMLIST\n         ST    R15,GFRCODE             STORE RETURN CODE IN PARMLIST\n         LA    R1,GFPARSE              LOAD CALLER ID FOR PARS\n         STH   R1,GFCALLID             STORE CALLER ID IN PARMLIST\n         L     R1,SAVEAREA+4           LOAD ADDRESS OF PEVIOUS\n*                                      SAVEAREA\n         L     R1,24(R1)               LOAD POINTER TO CPPL\n         ST    R1,GFCPPLP              STORE POINTER TO CPPL IN\n*                                      PARMLIST\n         LA    R1,ECB                  LOAD ADDRESS OF OPTIONAL ECB\n         ST    R1,GFECBP               STORE POINTER TO ECB IN\n*                                      PARMLIST\n         SLR   R1,R1                   ZERO REGISTER 1\n         ST    R1,ECB                  SET OPTIONAL ECB TO ZERO\n         LINK  EP=IKJEFF19,MF=(E,GFPARMP)  LINK TO GENERAL FAIL SERVICE\n*                                      ROUTINE TO HANDLE RETURN CODE\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO\n         BZ    RETURN                  YES....GO CLEANUP AND RETURN\n         LR    R8,R15                  LOAD REGISTER 8 WITH RETURN\n*                                      CODE\n         BAL   R14,SETCODE             GO CONVERT CODE TO DECIMAL\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(GNRLERR,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      GENERAL FAIL ERROR MESSAGE\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(RETNCD,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DECIMAL RETURN CODE\n         DROP  R15                                                  WFB\n         B     RETURN                  GO CLEANUP AND RETURN\n*\n***********************************************************************\n*                                                                     *\n*        SET UP ADDRESSABILITY TO PDL                                 *\n*           AND LOAD REGISTER 6 WITH ADDRESS OF DSNAME PDE            *\n*                                                                     *\n***********************************************************************\n*\nGOODPARS DS    0H\n         L     R9,PARSBACK             LOAD POINTER TO PARS ANSWER\n         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY TO PDL\n         LA    R6,DSNAMES              LOAD POINTER TO DSNAME LIST\n         MVI   VOLBIT,BLANK            BLANK OUT THE VOLUME WORK AREA\n         MVC   VOLUME,VOLBIT           CONTINUE BLANKING THE VOLUME\n         MVC   VOLHEAD,BLANKS          BLANK OUT THE HEADING CONST  WFB\n         MVC   VOLNAME,BLANKS          BLANK OUT THE HEADING VOLUME WFB\n         MVC   UNIT,BLANKS             BLANK OUT THE UNIT WORK AREA WFB\n         CLC   PNOMSG(2),HALF1         SEE IF NOMSG SPECIFIED       WFB\n         BNE   CHKDSN                  NO, GO SEE IF DSNAME GIVEN   WFB\n         OI    VOLBIT,NOMSG            YES, TURN ON FLAG FOR LATER  WFB\nCHKDSN   DS    0H                                                   WFB\n         L     R1,0(,R6)               GET ADDRESS OF DSNAME        WFB\n         CLI   0(R1),C'*'              SEE IF DSNAME IS ASTERISK    WFB\n         BNE   CHKVSER                 NO, GO SEE IF VOLUME GIVEN   WFB\n         CLC   PDDNAME(2),HALF1        SEE IF DDNAME SPECIFIED      WFB\n         BE    CHKFOLD                 YES, SKIP UNIT VOL, CHK FOLD WFB\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(NODSNDD,SINGLE,DATA),MF=(E,IOPLSECT)       WFB\n*                                      NO DSN OR DD GIVEN MESSAGE   WFB\n         DROP  R15                                                  WFB\n         B     RETURN                                               WFB\nCHKVSER  DS    0H                                                   WFB\n         CLC   PVOL(2),HALF1           SEE IF VOLUME SPECIFIED\n         BNE   CHKFOLD                 NO.....GO SEE IF FOLD IS DESIRED\n         L     R7,SVOL                 LOAD POINTER TO VOLUME\n         LH    R8,SVOL+4               LOAD LENGTH OF VOLUME\n         BCTR  R8,0                    DECREMENT LENGTH FOR EXECUTE OF\n*                                      MOVE\n         EX    R8,MOVEVOL              MOVE VOLUME INTO WORK AREA\n         OI    VOLBIT,HIGH             INDICATE VOLUME PRESENT\n         MVC   VOLHEAD,VOLCONST        MOVE '   VOLUME: ' TO HEAD   WFB\n         MVC   VOLNAME,VOLUME          MOVE VOLUME SER TO HEADING   WFB\n         CLC   PUNIT(2),HALF1          SEE IF UNIT SPECIFIED        WFB\n*                                 ===> O N L Y  IF VOLUME SPECIFIED WFB\n         BNE   CHKFOLD                 NO,GO SEE IF FOLD IS DESIRED WFB\n         L     R7,SUNIT                LOAD POINTER TO UNIT         WFB\n         LH    R8,SUNIT+4              LOAD LENGTH OF UNIT          WFB\n         BCTR  R8,0                    DECREMENT LENGTH FOR EXECUTE WFB\n         EX    R8,MOVEUNIT             MOVE UNIT INTO WORK AREA     WFB\n         OI    VOLBIT,MID1             INDICATE UNIT PRESENT        WFB\nCHKFOLD  DS    0H\n         CLC   PFOLD(2),HALF1          SEE IF FOLD SPECIFIED\n         BNE   CHKHEAD                 NO.....GO LOOP THROUGH DSNS GTEL\n         OI    VOLBIT,LOW              INDICATE FOLD PRESENT\nCHKHEAD  DS    0H\n         CLC   PHEAD(2),HALF1          SEE IF NOHEAD SPECIFIED\n         BNE   NEXT                    NO.....GO LOOP THROUGH DSNAMES\n         OI    VOLBIT,MID2             INDICATE NOHEAD PRESENT     GTEL\n         DROP  R9                      DROP ADDRESSABILITY TO PDL\n*\n***********************************************************************\n*                                                                     *\n*        LOOP THROUGH DSNAME LIST RETURNED BY PARS                    *\n*                                                                     *\n***********************************************************************\n*\nNEXT     DS    0H\n         LA    R1,PRINTI               LOAD POINTER TO DDNAME TO BE\n*                                      FREED\n         BAL   R2,FREEDD               BRANCH TO FREE ROUTINE\n         LTR   R8,R8                   SEE IF RETURN CODE FROM FREE IS\n*                                      ZERO\n         BNZ   CLOSDCBS                NO.....GO CLOSE DCBS AND RETURN\n         L     R5,0(R6)                LOAD POINTER TO DSNAME\n         CLI   0(R5),C'*'              SEE IF DSNAME IS ASTERISK    WFB\n         BE    ALLOCDDN                YES, GO PROCESS DDNAME       WFB\n         LH    R4,4(R6)                LOAD LENGTH OF DSNAME\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** START OF GTEL MOD ************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*   DETERMINE THE FULL DATASET NAME GIVEN\n         STH   R4,DFPBDSL              STORE LENGTH OF DSN\n         TM    6(R6),X'40'             IN QUOTES\n         BO    GTENOQ                  YES, SKIP\n         BCTR  R4,0                    DECREMENT COUNT\n         MVC   DFPBNAME,BLANKS         MOVE IN BLANKS\n         EX    R4,DFPBMVE              MOVE IN DSN GIVEN\n         LA    R4,1(R4)                BUMP COUNT                ARAMCO\n         LA    R1,DFPLSECT             GET ADDRESS OF ECT\n         MVC   DFPBQUA,BLANKS          BLANK QUALIFIER\n         CALLTSSR  EP=IKJEHDEF         GO TO DEFAULT ROUTINE\nGTEDEF   LTR    R15,R15                TEST RETURN CODE\n         BNZ    GTENOQ                 NON ZERO SKIP\nGTEOK    LA     R5,DFPBNAME            RESTORE REGS\n         LH     R4,DFPBDSL             GET NEW LENGTH\nGTENOQ   DS    0H\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** END OF GTEL MOD **************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         STCM  R4,3,DSNLEN             STORE LENGTH OF DSNAME\n         BCTR  R4,0                    DECREMENT LENGTH FOR EXECUTE OF\n*                                      MOVE\n         LA    R8,DAP08                LOAD ADDRESS OF DAPB FOR 08\n         USING DAPB08,R8               ESTABLISH ADDRESSABILITY TO DAPB\n         MVC   DAPB08(DAPB08L),DAPB08C MOVE CONSTANTS INTO DAPB\n         LA    R1,DSNLEN               LOAD POINTER TO DSN BUFFER\n         ST    R1,DA08PDSN             STORE POINTER TO DSN BUFFER IN\n*                                      DAPB\n         MVI   DSNBUF,BLANK            BLANK OUT THE DSNAME BUFFER\n         MVC   DSNBUF+1(43),DSNBUF     FINISH BLANKING OUT THE BUFFER\n         EX    R4,MOVEDSN              MOVE IN THE DSNAME\n         TM    14(R6),HIGH             SEE IF MEMBER NAME IS PRESENT\n         BNO   CHKPASS                 NO.....GO CHECK IF THERE IS A\n*                                      PASSWORD\n         L     R5,8(R6)                LOAD POINTER TO THE MEMBER NAME\n         LH    R4,12(R6)               LOAD LENGTH OF MEMBER NAME\n         BCTR  R4,0                    DECREMENT LENGTH FOR EXECUTE OF\n*                                      MOVE\n         EX    R4,MOVEMEM              MOVE IN THE MEMBER NAME\nCHKPASS  DS    0H\n         MVC   MEMNAME,DA08MNM         MOVE MEMBER NAME INTO HEADER 2\n         TM    22(R6),HIGH             SEE IF PASSWORD IS PRESENT\n         BNO   CHKVOL                  NO.....GO SEE IF VOLUME PRESENT\n         L     R5,16(R6)               LOAD POINTER TO THE PASSWORD\n         LH    R4,20(R6)               LOAD LENGTH OF PASSWORD\n         BCTR  R4,0                    DECREMENT LENGTH FOR EXECUTE OF\n*                                      MOVE\n         EX    R4,MOVEPASS             MOVE IN THE PASSWORD\nCHKVOL   DS    0H\n         TM    VOLBIT,HIGH             SEE IF VOLUME IS PRESENT\n         BNO   ALLOCDD                 NO.....GO ALLOCATE DATA SET\n         MVC   DA08SER,VOLUME          MOVE IN THE VOLUME SERIAL\n         TM    VOLBIT,MID1             SEE IF UNIT IS PRESENT       WFB\n*                                 ===> O N L Y  IF VOLUME SPECIFIED WFB\n         BNO   ALLOCDD                 NO.....GO ALLOCATE DATA SET  WFB\n         MVC   DA08UNIT,UNIT           MOVE IN THE UNIT TYPE        WFB\nALLOCDD  DS    0H\n         SLR   R4,R4                   ZERO REGISTER 4\n         ST    R4,ECB                  STORE REGISTER 4 AS ECB\n         LA    R1,DAPLSECT             LOAD ADDRESS OF DAPL\n         USING DAPL,R1                 ESTABLISH ADDRESSABILITY TO DAPL\n         ST    R8,DAPLDAPB             STORE ADDRESS OF DAPB IN DAPL\n         DROP  R1                      DROP ADDRESSABILITY TO DAPL\n         CALLTSSR EP=IKJDAIR           CALL DAIR TO ALLOCATE DATASET\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO\n         BZ    OUTPUT                  YES....GO PRINT DATASET\n         MVI   DFID+1,DFDAIR           SET DAIRFAIL ID TO INDICATE DAIR\n         BAL   R2,DAIRFAIL             GO TO DAIRFAIL ROUTINE TO HAVE\n*                                      ERROR MESSAGE PUT OUT\nNOTPMESS DS    0H\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(DSNNOTP,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATASET NOT PRINTED MESSAGE\n         DROP  R15                                                  WFB\n         B     EXITMSG                 GO PUT OUT DATASET AND MEMBER\n*                                      NAMES\n*\n***********************************************************************\n*                                                                     *\n*        DETERMINE DATASET TYPE AND CALL PRINT ROUTINE                *\n*                                                                     *\n***********************************************************************\n*\nOUTPUT   DS    0H\n         TM    DA08DSO,DSOPS           X'40' PHYSICAL SEQUENTIAL\n         BO    PRINTIT                 YES....GO PRINT DATASET\n         CLC   DA08MNM,BLANKS          SEE IF MEMBER NAME IS BLANK\n         BNE   PRINTIT                 NO.....GO TREAT AS SEQUENTIAL\n         TM    DA08DSO,DSOPO           X'02' PARTITIONED\n         BO    SCROLLIT                YES....GO SCROLL DIRECTORY\n         DROP  R8                      DROP ADDRESSABILITY TO DAPB\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(NOTPSPO,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      NOT PARTITIONED OR SEQUENTIAL\n*                                      MESSAGE\n         DROP  R15                                                  WFB\n         B     NOTPMESS                GO PUT NOT PRINTED MESSAGE\n*                                                                   WFB\nALLOCDDN DS    0H                                                   WFB\n         L     R1,24(,R6)              LOAD POINTER TO NEXT DSN     WFB\n         C     R1,ENDCHAIN             IS DSN=* LAST OR ONLY NAME ? WFB\n         BE    CHKINFO                 YES, GO GET DSN, DSORG INFO  WFB\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(NOTLAST,SINGLE,DATA),MF=(E,IOPLSECT)  PUT  WFB\n*                                      DSN=* IS NOT LAST OR ONLY    WFB\n*                                      MESSAGE                      WFB\n         DROP  R15                                                  WFB\n         B     NOTPMESS                GO PUT NOT PRINTED MESSAGE   WFB\nCHKINFO  DS    0H                                                   WFB\n         LA    R8,REQBLK               GET POINTER TO REQUEST BLOCK WFB\n         ST    R8,RBPTR                INITIALIZE REQUEST BLOCK PTR WFB\n         MVI   RBPTR,S99RBPND          INDICATE END OF PARM LIST    WFB\n         USING S99RB,R8                ESTABLISH ADDRESSABILITY TO  WFB\n*                                      REQUEST BLOCK                WFB\n         MVC   S99RBLN(RBLEN),REQBLKC  INITALIZE RB                 WFB\n         MVI   S99VERB,S99VRBIN        SET VERB TO INFO RETRIEVAL   WFB\n         LA    R1,TEXTPTRS             GET POINTER TO TEXT POINTERS WFB\n         ST    R1,S99TXTPP             STORE POINTER IN RB          WFB\n         DROP  R8                      DROP ADDRESSABILITY TO RB    WFB\n         USING S99TUPL,R1              ESTABLISH ADDRESSABILITY TO  WFB\n*                                      TEXT UNIT POINTER LIST       WFB\n         LA    R2,TEXTL                ADDRESS PREALLOC DDNAME TEXT WFB\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL        WFB\n         USING S99TUNIT,R2             ESTABLISH ADDRESSABILITY TO  WFB\n*                                      TEXT UNIT                    WFB\n         MVC   S99TUKEY(TEXTLLEN),TEXTLC  INITIALIZE TEXT UNIT L    WFB\n         L     R9,PARSBACK             LOAD POINTER TO PARS ANSWER  WFB\n         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY     WFB\n         L     R5,SDDNAME              GET ADDRESS OF DDNAME        WFB\n         LH    R4,SDDNAME+4            GET LENGTH OF DDNAME         WFB\n         DROP  R9                                                   WFB\n         BCTR  R4,0                    DECREMENT FOR EXECUTE        WFB\n         EX    R4,MOVEDDN              MOVE DDNAME INTO TEXT UNIT   WFB\n         MVC   PREALDDN,S99TUPAR       SAVE PREALLOC DDN FOR LATER  WFB\n         LA    R1,4(,R1)               POINT TO NEXT TEXT UNIT PTR  WFB\n         LA    R2,TEXTM                ADDRESS RETURN DSNAME TEXT U WFB\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL        WFB\n         MVC   S99TUKEY(TEXTMLEN),TEXTMC  INITIALIZE TEXT UNIT M    WFB\n         LA    R1,4(,R1)               POINT TO NEXT TEXT UNIT PTR  WFB\n         LA    R2,TEXTN                ADDRESS RETURN MEMBER TEXT U WFB\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL        WFB\n         MVC   S99TUKEY(TEXTNLEN),TEXTNC  INITIALIZE TEXT UNIT N    WFB\n         LA    R1,4(,R1)               POINT TO NEXT TEXT UNIT PTR  WFB\n         LA    R2,TEXTO                ADDRESS RETURN DSORG TEXT U  WFB\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL        WFB\n         MVC   S99TUKEY(TEXTOLEN),TEXTOC  INITIALIZE TEXT UNIT O    WFB\n         MVI   S99TUPTR,S99TUPLN       INDICATE END TEXT UNIT PTRS  WFB\n         DROP  R1,R2                   DROP ADDRESSABILITY          WFB\n         LA    R1,RBPTR                ADDRESS SVC99 REQUEST BLOCK  WFB\n         DYNALLOC                      ISSUE DYNAMIC ALLOCATION SVC WFB\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO   WFB\n         BZ    CHKDDORG                YES....GO CHECK DSORG TYPE   WFB\n         LA    R1,REQBLK               ADDRESS SVC99 REQUEST BLOCK  WFB\n         MVI   DFID+1,DFSVC99          SET DAIRFAIL ID = DYNALLOC   WFB\n         BAL   R2,DAIRFAIL             GO TO DAIRFAIL ROUTINE TO    WFB\n         B     NOTPMESS                GO PUT NOT PRINTED MESSAGE   WFB\nCHKDDORG DS    0H                                                   WFB\n         LA    R1,TEXTM                ADDRESS RETURNED DSNAME TEXT WFB\n         USING S99TUNIT,R1             ESTABLISH ADDRESSABILITY     WFB\n         MVC   DFPBDSL,S99TULNG        SAVE DSN LEN WHERE EXPECTED  WFB\n         MVC   DSNAME,S99TUPAR         MOVE RETURN DSN INTO HEADER  WFB\n         LA    R1,TEXTN                ADDRESS RETURNED MEMBER TEXT WFB\n         MVC   MEMNAME,S99TUPAR        MOVE RETURN MEM INTO HEADER  WFB\n         MVC   VOLHEAD,DDNCONST        MOVE '   DDNAME: ' TO HEADER WFB\n         MVC   VOLNAME,PREALDDN        MOVE DDNAME TO HEADING       WFB\n         LA    R1,TEXTO                ADDRESS RETURNED DSORG TEXT  WFB\n         TM    S99TUPAR,DSOPS          X'40' PHYSICAL SEQUENTIAL    WFB\n         BO    PRINTIT                 YES....GO PRINT DATASET      WFB\n         CLI   MEMNAME,BLANK           SEE IF MEMBER NAME IS BLANK  WFB\n         BNE   PRINTIT                 NO.....GO TREAT AS SEQUENTIALWFB\n         TM    S99TUPAR,DSOPO          X'02' PARTITIONED            WFB\n         BO    SCROLLIT                YES....GO SCROLL DIRECTORY   WFB\n         DROP  R1                      DROP ADDRESSABILITY TO S99TU WFB\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(NOTPSPO,SINGLE,DATA),MF=(E,IOPLSECT)  PUT  WFB\n*                                      NOT PARTITIONED OR SEQUENTIALWFB\n*                                      MESSAGE                      WFB\n         DROP  R15                                                  WFB\n         B     NOTPMESS                GO PUT NOT PRINTED MESSAGE   WFB\n*\n***********************************************************************\n*                                                                     *\n*        READS RECORDS USING GET MOVE                                 *\n*           AND ATTRIBUTES OF GIVEN DATASET                           *\n*        WRITES THESE SAME RECORDS USING PUT MOVE                     *\n*           AND THE INPUT DATASET ATTRIBUTES                          *\n*                                                                     *\n***********************************************************************\n*\nPRINTIT  DS    0H\n         LA    R8,INPUT                LOAD POINTER TO INPUT DCB\n         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB\n         MVC   INPUT(INPUTL),INPUTC    MOVE INPUT DCB CONSTANT INTO\n*                                      INPUT DCB IN WORKAREA\n         L     R1,0(,R6)               GET ADDRESS OF DSNAME        WFB\n         CLI   0(R1),C'*'              SEE IF DSNAME IS ASTERISK    WFB\n         BNE   OPENINP                 NO, GO OPEN INPUT            WFB\n         MVC   DCBDDNAM,PREALDDN       YES, USE PREALLOCATED DDN(.) WFB\nOPENINP  DS    0H                                                   WFB\n         MVC   OPENLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO OPEN LIST IN WORKAREA\n         OPEN  ((R8),INPUT),MF=(E,OPENLST)  OPEN INPUT DCB\nPRINTS   DS    0H                      BRANCH ADDRESS FOR PRINTING\n*                                      MEMBERS\n         TM    DCBOFLGS,DCBOFOPN       SEE IF DCB OPENED SUCCESSFULLY\n         BNO   NOTPMESS                NO.....GO PUT OUT NOT PRINTED\n*                                      MESSAGE\nCHKCNTRL DS    0H\n         MVC   HEADER,HEADERC          MOVE HEADER INTO DATA AREA\n         TM    DCBRECFM,DCBRECCM       SEE IF CONTROL IS MACHINE\n         BNO   USEA                    NO.....GO TO USE ASA CONTROL\n         LA    R5,OUTPUTM              LOAD ADDRESS OF OUTPUT DCB FOR\n*                                      MACHINE CODE\n         LA    R4,EJECTM               LOAD ADDRESS OF EJECT DATA\n         MVI   HDRCNTL,SKIPM           MOVE INTO HEADER MACHINE CODE\n*                                      FOR SPACE\n         TM    48(R5),DCBOFOPN         SEE IF DCB IS ALREADY OPEN\n         BO    PUTDSN                  YES....GO PUT OUT HEADERS\n         LA    R3,PRINTM               LOAD POINTER TO PRINTM\n         LA    R14,PUTDSN              LOAD ADDRESS FROM RETURN FROM\n*                                      SYSOUT ALLOCATION\n         B     ALLOCOUT                GO TO ALLOCATE SYSOUT\nUSEA     DS    0H\n         LA    R5,OUTPUTA              LOAD ADDRESS OF OUTPUT DCB FOR\n*                                      ASA CODE\n         LA    R4,EJECTA               LOAD ADDRESS OF EJECT DATA\n         TM    48(R5),DCBOFOPN         SEE IF DCB IS ALREADY OPEN\n         BO    PUTDSN                  YES....GO PUT OUT HEADERS\n         LA    R3,PRINTA               LOAD POINTER TO PRINTA\n         BAL   R14,ALLOCOUT            LOAD ADDRESS FOR RETURN AND GO\n*                                      DO SYSOUT ALLOCATION\nPUTDSN   DS    0H\n         TM    VOLBIT,UDKDONE          UDKS WRITTEN ALREADY ?       WFB\n         BO    NOUDK                   YES, SKIP                    WFB\n         L     R9,PARSBACK             LOAD POINTER TO PARS ANSWER  WFB\n         USING IKJPARMD,R9             ESTABLISH ADDRESABILITY      WFB\n         CLC   PUDKFONT(2),HALF1       IS UDK FONT SPECIFIED ?      WFB\n         BNE   NOUDK                   NO, SKIP                     WFB\n         PUT   (R5),UDKRESET           PUT OUT UDK RESET TEXT       WFB\n         PUT   (R5),UDKSET             PUT OUT UDK SET TEXT         WFB\n         L     R15,ALNDSECT            POINT TO RECORD WORK AREA    WFB\n         USING LINDSECT,R15            ESTABLISH ADDRESSABILITY     WFB\n         MVC   RECORD(8),UDKFHEAD      MOVE UDK FONT NAME HEADER    WFB\n         L     R14,SUDKFONT            POINT TO UDK FONT NAME       WFB\n         LH    R1,SUDKFONT+4           GET LENGTH OF UDK FONT NAME  WFB\n         BCTR  R1,0                    DECREMENT FOR EXECUTE        WFB\n         EX    R1,MOVEUDK              MOVE UDK FONT NAME TO RECORD WFB\n         LA    R1,9(,R1)               ADD HEADER LEN TO ACTUAL LEN WFB\n         STH   R1,RECLEN               SAVE IN OUTPUT RECORD        WFB\n         PUT   (R5),(R15)              PUT OUT UDK FONT NAME        WFB\n         DROP  R9,R15                                               WFB\n         PUT   (R5),UDKFSEL            PUT OUT UDK FONT SELECT TEXT WFB\n         OI    VOLBIT,UDKDONE          INDICATE UDKS WRITTEN        WFB\nNOUDK    DS    0H                                                   WFB\n         TM    VOLBIT,MID2             TEST FOR NOHEAD             GTEL\n         BO    NOHEAD                  YES                         GTEL\n         PUT   (R5),(R4)               PUT OUT PAGE EJECT           WFB\n         MVC   HDRTIME(HDRTDLEN),BLANKS  BLANK OUT TIME DATE AREAS  WFB\n         CALL  IKJEFLPA,(HDRTIME,HDRDATE),VL,MF=(E,CALLMFL)         WFB\n         MVC   HDRTIME(4),BLANKS       BLANK OUT BUFFER PREFIX      WFB\n         MVC   HDRDATE(4),BLANKS       BLANK OUT BUFFER PREFIX      WFB\n         PUT   (R5),HEADER             PUT OUT PAGE 1 HEADER\n         MVC   HEADER2,LDSNAME         MOVE LENGTH AND 'DSNAME=' INTO\n*                                      INTO SECOND HEADER\n         MVC   HEADER2+4(1),HDRCNTL    MOVE IN CONTROL BYTE\n         CLI   MEMNAME,BLANK           SEE IF MEMBER NAME IS BLANK\n         BE    NOMEM                   YES....NO NEED TO PUT IN PARENS\n         MVI   OPENPRN,C'('            MOVE OPEN PAREN INTO DSNAME\n         MVI   CLOSEPRN,C')'           MOVE CLOSE PAREN INTO DSNAME\n         B     PUTHDR2                 GO PUT OUT HEADER 2\nNOMEM    DS    0H\n         MVI   OPENPRN,BLANK           MOVE BLANK INSTEAD OF OPEN AND\n         MVI   CLOSEPRN,BLANK          CLOSE PARENS\nPUTHDR2  DS    0H\n         PUT   (R5),HEADER2            PUT OUT PAGE 1 HEADER 2\n         MVC   HEADER2(4),SPACE        CHANGE HEADER 2 FOR PUT OF BLANK\n*                                      LINE\n         PUT   (R5),HEADER2            PUT OUT BLANK LINE\nNOHEAD   STM   R9,R10,SAVMR9           SAVE REGS 9 AND 10\n         STM   R6,R7,SAVMR6            SAVE REGS 6 AND 7\n         STM   R2,R3,SAVMR2            SAVE REGS 2 AND 3\n         L     R9,ALNDSECT             SET UP RECORD ADDRESS.\n         USING LINDSECT,R9             *\n         SLR   R10,R10                 ZERO OUT R10\n         LH    R7,PAGELEN              MOVE IN PAGELEN\n         TM    VOLBIT,MID2             NOHEAD SPECIFIED ?           WFB\n         BO    NOSUB4                  YES, SKIP SUBTRACTION        WFB\n         SH    R7,HALF4                SUBTRACT FOR HEADER       ARAMCO\nNOSUB4   DS    0H                                                   WFB\n         MVC   RECCC,HDRCNTL           MOVE IN SPACE AS CONTROL\n*                                      CHARACTER\n         TM    DCBRECFM,DCBRECU        SEE IF RECFM U\n         BO    COPYU                   YES....GO HANDLE RECFM U\n         TM    DCBRECFM,DCBRECV        SEE IF RECFM V\n         BO    COPYV                   YES....GO HANDLE RECFM V\nCOPYF    DS    0H\n         TM    DCBRECFM,DCBRECCC       CONTROL CHARACTER?\n         BNZ   COPYFCC                 YES...\n         TM    CCBIT,FORCEASA          USER SAYS CC IN DATA ?       WFB\n         BO    COPYFCC                 YES, PROCESS AS SO           WFB\nCOPYFNC  OI    CCBIT,LOW               TURN ON NOCC BIT\n         LH    R4,DCBLRECL             GET LRECL\n         A     R4,FULL5                ADD LENGTH FOR VB HEADER\n         STH   R4,RECLEN               PUT INTO RECORD HEADER\n         GET   INPUT,RECDATA           GET INPUT\n         BAL   R10,PUTLL               PUT OUT LINE\n         L     R9,ALNDSECT             RELOAD DSECT POINTER\n         B     COPYFNC                 GET NEXT RECORD\nCOPYFCC  LH    R4,DCBLRECL             GET LRECL\n         A     R4,FULL4                ADD LENGTH FOR VB HEADER\n         STH   R4,RECLEN               PUT INTO RECORD HEADER\n         GET   INPUT,RECCC             GET INPUT\n         BAL   R10,PUTLL               PUT INTO RECORD HEADER\n         L     R9,ALNDSECT             RELOAD DSECT POINTER\n         B     COPYFCC                 GET NEXT RECORD\nCOPYV    DS    0H\n         TM    DCBRECFM,DCBRECCC       CONTROL CHARACTER?\n         BNZ   COPYVCC                 IF YES...\n         TM    CCBIT,FORCEASA          USER SAYS CC IN DATA ?       WFB\n         BO    COPYVCC                 YES, PROCESS AS SO           WFB\nCOPYVNC  GET   INPUT,RECLEN+1          GET INPUT\n         OI    CCBIT,LOW               TURN ON NOCC BIT\n         SLR   R15,R15                 ZERO R15\n         ICM   R15,7,RECLEN+1          GET LENGTH\n         A     R15,FULL256             ADD ONE FOR CC\n         STCM  R15,7,RECLEN            REPLACE LENGTH OVER 1\n         MVC   RECCC,HDRCNTL           ADD HDRCNTL\n         BAL   R10,PUTLL               PUT OUT RECORD\n         L     R9,ALNDSECT             RESTORE DSECT ADDRESS\n         B     COPYVNC                 GET NEXT RECORD\nCOPYVCC  GET   INPUT,RECLEN            GET INPUT\n         BAL   R10,PUTLL               PUT OUT RECORD\n         L     R9,ALNDSECT             RESTORE DSECT ADDRESS\n         B     COPYVCC                 GET NEXT RECORD\nCOPYU    DS    0H                      PROCESS RECFM=U\n         TM    DCBRECFM,DCBRECCC       CONTROL CHARACTER?\n         BNZ   COPYUCC                 YES...\n         TM    CCBIT,FORCEASA          USER SAYS CC IN DATA ?       WFB\n         BO    COPYUCC                 YES, PROCESS AS SO           WFB\nCOPYUNC  GET   INPUT,RECDATA           GET RECORD\n         OI    CCBIT,LOW               TURN ON NOCC BIT\n         LH    R4,DCBLRECL             GET LRECL\n         A     R4,FULL5                ADD VB HEADER LENGTH\n         STH   R4,RECLEN               PUT INTO RECORD HEADER\n         BAL   R10,PUTLL               PUT OUT LINE\n         L     R9,ALNDSECT             RELOAD DSECT POINTER\n         B     COPYUNC                 GET NEXT RECORD\nCOPYUCC  GET   INPUT,RECCC             GET INPUT\n         LH    R4,DCBLRECL             GET LRECL\n         A     R4,FULL4                ADD VB HEADER LENGTH\n         STH   R4,RECLEN               STORE INTO RECORD HEADER\n         BAL   R10,PUTLL               PUT INTO RECORD HEADER\n         L     R9,ALNDSECT             RELOAD DSECT POINTER\n         B     COPYUCC                 GET NEXT RECORD\nPUTLL    DS    0H\n         TM    CCBIT,X'99'             NOCC, DS, SS, OR PAGELEN ON?\n         BZ    NOSKIP                  NO, IGNORE LINE-COUNTING\n         LTR   R7,R7                   ANY LINES LEFT ON PAGE?\n         BNZ   LINECT                  YES, DON'T PUT IN PAGE SKIP CC\n         MVI   4(R9),HEXF1             MOVE IN PAGE SKIP CC\n         LH    R7,PAGELEN              RESET LINE COUNT\n         B     NOSKIP                  CONTINUE WITH PUT\nLINECT   TM    CCBIT,MID2              WAS DOUBLE SPACE SPECIFIED?\n         BO    LINEDS                  YES, CHECK LINES LEFT     ARAMCO\n         MVI   4(R9),BLANK             PUT IN SINGLE SPACE CONTROL CHAR\n         B     NOSKIP                  YES, DON'T SKIP TO NEXT PAGE\nLINEDS   BCTR  R7,0                    DECREMENT ONE MORE FOR DS\n         MVI   4(R9),HEXF0             PUT IN DOUBLE SPACE CONTROL CHAR\n         SLR   R2,R2                   EMPTY R2 FOR DIVIDE\n         SLR   R3,R3                   EMPTY R3 FOR DIVIDE\n         SLR   R15,R15                 EMPTY R15 FOR DIVIDE\n         LH    R15,LINELEN             LOAD LINELEN INTO R15\n         LH    R3,RECLEN               PUT REC LENGTH IN R2\n         SH    R3,HALF5                SUBTRACT VB HEADER LENGTH\n         DR    R2,R15                  DIVIDE BY LINELEN\n         CR    R3,R7                   GREATER THAN LINES LEFT ON PAGE?\n         BNH   NOSKIP                  IF NOT....DON'T START NEW PAGE\n         MVI   4(R9),HEXF1             MOVE IN PAGE SKIP CC\n         LH    R7,PAGELEN              RESET LINE COUNT\nNOSKIP   LH    R4,RECLEN               PUT REC LENGTH IN R4\n         TM    VOLBIT,LOW              SEE IF FOLD IS REQUESTED\n         BO    FOLDLOOP                YES....GO FOLD OUTPUT\nPUTLOOP  CH    R4,VBLEN                COMPARE WITH LL\n         BNH   PUTLAST                 WRITE LAST RECORD\n         MVC   0(2,R9),VBLEN           INSERT LENGTH FOR PUT\n         PUT   (R5),(R9)               PUT OUT OUTPUT LINE\n         SH    R4,LINELEN              DECREMENT FOR COMPARE\n         AH    R9,LINELEN              INCREMENT RECORD LOCATN\n         MVI   4(R9),BLANK             MOVE IN NEXT LINE CC\n         TM    CCBIT,X'99'             NOCC, PAGELEN, DS, OR SS SPEC?\n         BZ    PUTLOOP                 NO, DON'T COUNT LINES\n         BCT   R7,PUTLOOP              END OF PAGE?\n         MVI   4(R9),HEXF1             YES, START NEW PAGE\n         LH    R7,PAGELEN              RELOAD PAGELEN\n         B     PUTLOOP                 WRITE NEXT LINE\nFOLDLOOP CH    R4,VBLEN                COMPARE WITH LL\n         BNH   FOLDLAST                WRITE LAST RECORD\n         LH    R15,LINELEN             LOAD LINE LENGTH\n         SH    R15,HALF1               DECREMENT FOR EXECUTE\n         EX    R15,FOLDLINE            EXECUTE FOLD OF LINE\n         MVC   0(2,R9),VBLEN           INSERT LENGTH FOR PUT\n         PUT   (R5),(R9)               PUT OUT OUTPUT LINE\n         SH    R4,LINELEN              DECREMENT FOR COMPARE\n         AH    R9,LINELEN              INCREMENT RECORD LOCATION\n         MVI   4(R9),BLANK             MOVE IN NEXT LINE CC\n         TM    CCBIT,X'99'             NOCC, PAGELEN, DS, OR SS SPEC?\n         BZ    FOLDLOOP                NO, DON'T COUNT LINES\n         BCT   R7,FOLDLOOP             END OF PAGE?\n         MVI   4(R9),HEXF1             YES, START NEW PAGE\n         LH    R7,PAGELEN              RELOAD PAGELEN\n         B     FOLDLOOP                WRITE NEXT LINE\nFOLDLAST LR    R15,R4                  LOAD REMAINING LINE LENGTH\n         SH    R15,HALF6               DECREMENT FOR EXECUTE\n         EX    R15,FOLDLINE            EXECUTE FOLD OF LINE\nPUTLAST  STH   R4,0(R9)                INSERT LENGTH FOR PUT\n         PUT   (R5),(R9)               PUT OUT OUTPUT LINE\n         BCTR  R7,0                    DECREMENT PAGELEN\n         BR    R10                     GO GET NEXT RECORD\nEXITI    DS    0H\n         DROP  R9\n         LM    R9,R10,SAVMR9           RESTORE R9 AND R10\n         LM    R6,R7,SAVMR6            RESTORE R6 AND R7\n         LM    R2,R3,SAVMR2            RESTORE R2 AND R3\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** END OF GTEL MOD **************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nEXIT     DS    0H\n         TM    DCBOFLGS,DCBOFOPN       SEE IF INPUT DCB IS OPEN\n         BNO   EXITMSG                 NO....GO PUT OUT DATASET AND\n*                                      MEMBER NAMES\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST IN WORKAREA\n         CLOSE ((R8),),MF=(E,CLOSLST)  CLOSE INPUT DCB\nEXITMSG  DS    0H\n         L     R1,0(,R6)               GET ADDRESS OF DSNAME        WFB\n         CLI   0(R1),C'*'              SEE IF DSNAME IS ASTERISK    WFB\n         BE    EXNOFREE                YES, DO NOT FREE DDN(...)    WFB\n         LA    R1,PRINTI               FREE INPUT DATASET          GTEL\n         BAL   R2,FREEDD               FREE INPUT DATASET          GTEL\nEXNOFREE DS    0H                                                   WFB\n         TM    VOLBIT,NOMSG            IS NOMSG SPECIFIED ?         WFB\n         BO    CONTINUE                YES, CONTINUE WITH NEXT DSN  WFB\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(DSNMSG,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATA SET NAME MESSAGE\n         DROP  R15                                                  WFB\n         LH    R4,DFPBDSL              LOAD LENGTH OF DSNAME       GTEL\n         A     R4,FULL4                INCREMENT LENGTH FOR PUTLINE\n         SLL   R4,16                   SHIFT LENGTH TO HIGH ORDER BYTES\n         STCM  R4,15,DSNLENP           STORE LENGTH OF PUTLINE\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(DSNLENP,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATA SET NAME MESSAGE\n         DROP  R15                                                  WFB\n         CLI   MEMNAME,BLANK           MEMBER NAME BLANK ?          WFB\n         BE    CONTINUE                YES, SKIP MEMBER MESSAGE     WFB\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(MEMMSG,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATA SET NAME MESSAGE\n         DROP  R15                                                  WFB\n         MVC   MEMNAMEL(2),HALF12      FORCE MEMNAME LENGTH 8 (+4)  WFB\n         MVC   MEMNAMEL+2(2),HALF0     (REQUIRED ZERO FOR PUTLINE)  WFB\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(MEMNAMEL,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      MEMBER NAME\n         DROP  R15                                                  WFB\n         B     CONTINUE                GO CONTINUE WITH NEXT DATASET\n         DROP  R8                      DROP ADDRESSABILITY TO INPUT DCB\nERRI     DS    0H\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(SYNADI,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATASET NOT PRINTED DUE TO SYNAD\n*                                      ERROR ON INPUT DATASET MESSAGE\n         DROP  R15                                                  WFB\n         B     EXIT                    GO SEE IF INPUT DCB IS OPEN\nERRO     DS    0H\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(SYNADO,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATASET NOT PRINTED DUE TO\n*                                      SYNAD ERROR MESSAGE          WFB\n         DROP  R15                                                  WFB\n         B     CLOSDCBS                GO CLOSE OPEN DCBS AND RETURN\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        READ THE DIRECTORY OF A PDS                                  *\n*           THEN EITHER LIST MEMBER NAMES,                            *\n*           PRINT MEMBERS,                                            *\n*           OR LIST MEMBER NAMES AND PRINT MEMBERS                    *\n*                                                                     *\n***********************************************************************\n*\nSCROLLIT DS    0H\n         ST    R6,SAVER6               SAVE REGISTER 6\n         L     R9,PARSBACK             LOAD ADDRESS PARS ANSWER\n         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY TO PDL\n         CLC   PLIST,HALF2             SEE IF NOLIST SPECIFIED\n         BL    CONTSCR                 LOW....CONTINUE WITH SCROLL\n         CLC   PPRINT,HALF2            SEE IF NOPRINT SPECIFIED\n         BE    CONTINUE                YES....SKIP SCROLL\n         DROP  R9                      DROP ADDRESSABILITY TO PDL\nCONTSCR  DS    0H\n         LA    R8,DIRECT               LOAD POINTER TO DIRECTORY DCB\n         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB\n         MVC   DIRECT(DIRECTL),DIRECTC MOVE DIRECTORY DCB CONSTANT INTO\n*                                      DIRECTORY DCB IN WORKAREA\n         L     R1,0(,R6)               GET ADDRESS OF DSNAME        WFB\n         CLI   0(R1),C'*'              SEE IF DSNAME IS ASTERISK    WFB\n         BNE   OPENDIR                 NO, GO OPEN INPUT DIRECTORY  WFB\n         MVC   DCBDDNAM,PREALDDN       YES, USE PREALLOCATED DDN(.) WFB\nOPENDIR  DS    0H                                                   WFB\n         MVC   OPENLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO OPEN LIST IN WORKAREA\n         OPEN  ((R8),INPUT),MF=(E,OPENLST)  OPEN DIRECTORY DCB\n         TM    DCBOFLGS,DCBOFOPN       SEE IF DCB OPENED SUCCESSFULLY\n         BNO   NOTPMESS                NO.....GO PUT OUT NOT PRINTED\n*                                      MESSAGE\n         DROP  R8                      DROP ADDRESSABILITY TO DCB\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        GETMAIN MEMBER TABLE FOR STORAGE OF DIRECTORY NAMES, ETC.    *\n*           INITIALIZE TABLE                                          *\n*                                                                     *\n***********************************************************************\n*\n         L     R0,MEMDATL              LOAD LENGTH OF GETMAIN FOR\n*                                      MEMBER TABLE\n         LR    R2,R0                   SAVE IN REGISTER 2\n         GETMAIN R,LV=(0)              GETMAIN MEMBER TABLE STORAGE\n         ST    R1,MEMTABLE             SAVE ADDRESS OF MEMBER TABLE\n         ST    R1,PRESENT              ALSO SAVE ADDRESS AS TABLE\n*                                      IN USE\n         LA    R3,0(R2,R1)             LOAD ADDRESS OF END OF TABLE\n         ST    R3,ENDTABLE             STORE ADDRESS OF TABLE END\n         SLR   R4,R4                   ZERO REGISTER 4\n         ST    R4,0(R1)                STORE AS FIRST WORD OF MEMBER\n*                                      TABLE\n         LA    R4,8(R1)                LOAD REGISTER 4 AS POINTER TO\n*                                      THE FIRST ENTRY\n         USING MEMDSECT,R4             ESTABLISH ADDRESSABILITY TO\n*                                      MEMBER TABLE DSECT\n         SLR   R5,R5                   INITIALIZE MEMBER COUNT TO ZERO\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        READ DIRECTORY AND BUILD MEMBER TABLE                        *\n*                                                                     *\n***********************************************************************\n*\nGETDIR   EQU   *\n         GET   (R8),DATA               GET A DIRECTORY BLOCK\n         CLC   DATA,HALF12             SEE IF BLOCK IS UNUSED\n         BL    FREEBLK                 YES....GO HANDLE DIRECTORY END\n         LA    R9,DATA+2               LOAD POINTER TO FIRST DIRECTORY\n*                                      ENTRY\n         SLR   R7,R7                   ZERO REGISTER 7 FOR INSERT\n         ICM   R7,3,DATA               INSERT LENGTH USED OF THIS BLOCK\n         LA    R7,DATA-1(R7)           LOAD LAST USED BYTE OF BLOCK\nUNBLOCK  DS    0H\n         MVC   MEMNTTR,0(R9)           PUT NAME AND TTR IN TABLE\n         MVC   CFIELD,11(R9)           PUT C FIELD IN TABLE\n         CLI   MEMBER,HEXFF            SEE IF LAST MEMBER\n         BE    FREEBLK                 YES....GO HANDLE DIRECTORY END\n         IC    R6,CFIELD               INSERT CFIELD INTO REGISTER 6\n         SLL   R6,27                   SHIFT OUT HIGH ORDER BITS\n         SRL   R6,26                   SHIFT RIGHT TO GET LENGTH OF\n*                                      USER DATA\n         LA    R6,12(R6)               ADD STANDARD ENTRY LENGTH\n         LA    R4,MEMSECTN             LOAD PINTER TO NEXT TABLE ENTRY\n         LA    R5,1(R5)                INCREMENT NUMBER OF MEMBERS IN\n*                                      TABLE\n         C     R4,ENDTABLE             SEE IF END OF TABLE\n         BL    NEXTNTRY                LOW.....GO PROCESS NEXT ENTRY\n         LR    R0,R2                   LOAD LENGTH OF TABLE FOR GETMAIN\n         GETMAIN R,LV=(0)              GET NEXT TABLE\n         L     R14,PRESENT             LOAD REGISTER 14 WITH ADDRESS OF\n*                                      LAST TABLE\n         ST    R1,0(R14)               CHAIN MEMBER TABLES TOGETHER\n         ST    R1,PRESENT              ALSO SAVE ADDRESS AS TABLE\n*                                      IN USE\n         LA    R3,0(R2,R1)             LOAD ADDRESS OF TABLE END\n         ST    R3,ENDTABLE             STORE ADDRESS OF TABLE END\n         SLR   R4,R4                   ZERO REGISTER 4\n         ST    R4,0(R1)                STORE AS FIRST WORD OF MEMBER\n*                                      TABLE\n         LA    R4,8(R1)                LOAD REGISTER 4 AS POINTER TO\n*                                      THE FIRST ENTRY\n         STH   R5,4(R14)               STORE MEMBER COUNT IN OLD TABLE\n         SLR   R5,R5                   INITIALIZE MEMBER COUNT TO ZERO\nNEXTNTRY DS    0H\n         BXLE  R9,R6,UNBLOCK           INCREMENT REGISTER 9 WITH\n*                                      REGISTER 6 AND BRANCH\n*                                      LESS THAN OR EQUAL TO\n*                                      REGISTER 7 TO UNBLOCK\n         B     GETDIR                  NO.....GO GET NEXT DIRECTORY\n*                                      BLOCK\n         DROP  R4                      DROP ADDRESSABILITY TO TABLE\n*\n***********************************************************************\n*                                                                     *\n*        LIST MEMBERS IF:                                             *\n*           LIST SPECIFIED OR                                         *\n*           BOTH PRINT AND NOLIST WERE NOT SPECIFIED                  *\n*                                                                     *\n***********************************************************************\n*\nFREEBLK  DS    0H\n         MVC   OPENLST,OPENCLOS        MOVE CONSTANT INTO CLOSE LIST\n         CLOSE ((R8),),MF=(E,OPENLST)  CLOSE DIRECTORY DCB\n         L     R2,PRESENT              LOAD POINTER TO LAST TABLE\n         STH   R5,4(R2)                STORE COUNT OF MEMBERS\n         L     R4,MEMTABLE             LOAD POINTER TO FIRST TABLE\n         CLC   4(2,R4),HALF0           SEE IF THERE WERE ANY MEMBERS\n         BE    ENDMEMB                 ZERO...GO FREE MEMBER TABLE\n         LA    R8,INPUT                LOAD POINTER TO INPUT DCB\n         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB\n         MVC   INPUT(INPUTL),INPUTC    MOVE INPUT DCB CONSTANT INTO\n*                                      INPUT DCB IN WORKAREA\n         L     R1,SAVER6               GET SAVED ADDRESS OF DSN PDE WFB\n         L     R1,0(,R1)               GET ADDRESS OF DSNAME        WFB\n         CLI   0(R1),C'*'              SEE IF DSNAME IS ASTERISK    WFB\n         BNE   OPENMEM                 NO, GO OPEN AGAIN FOR MEMBER WFB\n         MVC   DCBDDNAM,PREALDDN       MOVE DDNAME INTO INPUT DCB   WFB\nOPENMEM  DS    0H                                                   WFB\n         MVC   OPENLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO OPEN LIST IN WORKAREA\n         LA    R1,XLIST                LOAD ADDRESS OF EXIT LIST\n         ST    R1,DCBEXLST             STORE ADDRESS OF EXIT LIST IN\n*                                      DCB\n         LA    R1,SEXIT                LOAD ADDRESS OF EODAD EXIT\n         ST    R1,DCBEODAD             STORE ADDRESS EODAD IN DCB\n         LA    R2,JFCBAREA             LOAD ADDRESS OF JFCBAREA\n         ST    R2,XLIST                STORE ADDRESS IN EXIT LIST\n         MVI   XLIST,X'87'             SET END OF LIST AND JFCB BYTE\n         MVC   RDJL,OPENCLOS           MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO READJFCB LIST IN\n*                                      WORKAREA\n         RDJFCB (INPUT,),MF=(E,RDJL)   READ JFCB INTO JFCBAREA\n         MVC   JFCBELNM,8(R4)          MOVE MEMBER NAME INTO JFCB\n         OI    JFCBIND1,JFCPDS         SET JFCB TO INDICATE PDS MEMBER\n         MVI   JFCDSRG1,HEX00          SET JFCB TO REMOVE OTHER DSORG\n*                                      INDICATORS\n         OPEN  ((R8),INPUT),TYPE=J,MF=(E,OPENLST)  OPEN INPUT DCB\n         L     R9,PARSBACK             LOAD ADDRESS PARS ANSWER\n         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY TO PDL\n         CLC   PLIST,HALF2             SEE IF NOLIST SPECIFIED\n         BE    NOLIST                  YES....SKIP LISTING\n         CLC   PLIST,HALF1             SEE IF LIST SPECIFIED\n         BE    LISTIT                  YES....GO LISTIT\n         CLC   PPRINT,HALF1            SEE IF PRINT SPECIFIED\n         BE    NOLIST                  YES....SKIP LISTING\n         DROP  R9                      DROP ADDRESSABILITY TO PDL\nLISTIT   DS    0H\n         MVC   HEADER,HEADERM          MOVE HEADER INTO DATA AREA\n         TM    DCBRECFM,DCBRECCM       SEE IF CONTROL IS MACHINE\n         DROP  R8                      DROP ADDRESSABILITY TO DCB\n         BNO   SUSEA                   NO.....GO TO USE ASA CONTROL\n         LA    R5,OUTPUTM              LOAD ADDRESS OF OUTPUT DCB FOR\n*                                      MACHINE CODE\n         LA    R4,EJECTM               LOAD ADDRESS OF EJECT DATA\n         MVI   HDRCNTL,SKIPM           MOVE INTO HEADER MACHINE CODE\n*                                      FOR SPACE\n         TM    48(R5),DCBOFOPN         SEE IF DCB IS ALREADY OPEN\n         BO    SPUTDSN                 YES....GO PUT OUT HEADERS\n         LA    R3,PRINTM               LOAD POINTER TO PRINTM\n         LA    R14,SPUTDSN             LOAD ADDRESS FOR RETURN FROM\n*                                      SYSOUT ALLOCATION\n         B     ALLOCOUT                GO TO ALLOCATE SYSOUT\nSUSEA    DS    0H\n         LA    R5,OUTPUTA              LOAD ADDRESS OF OUTPUT DCB FOR\n*                                      ASA CODE\n         LA    R4,EJECTA               LOAD ADDRESS OF EJECT DATA\n         TM    48(R5),DCBOFOPN         SEE IF DCB IS ALREADY OPEN\n         BO    SPUTDSN                 YES....GO PUT OUT HEADERS\n         LA    R3,PRINTA               LOAD POINTER TO PRINTA\n         BAL   R14,ALLOCOUT            LOAD ADDRESS FOR RETURN AND GO\n*                                      DO SYSOUT ALLOCATION\nSPUTDSN  DS    0H\n         PUT   (R5),(R4)               PUT OUT PAGE EJECT\n         PUT   (R5),HEADER             PUT OUT PAGE 1 HEADER\n         MVC   HEADER2,LDSNAME         MOVE LENGTH AND 'DSNAME=' INTO\n*                                      INTO SECOND HEADER\n         MVC   HEADER2+4(1),HDRCNTL    MOVE IN CONTROL BYTE\n         MVI   OPENPRN,BLANK           BLANK OUT MEMBER NAME\n         MVC   MEMNAME(9),OPENPRN      FINISH BLANKING OUT MEMBER NAME\n         PUT   (R5),HEADER2            PUT OUT PAGE 1 HEADER 2\n         L     R2,MEMTABLE             LOAD ADDRESS OF FIRST TABLE\n         MVC   LENGTH,HALF85           SET LENGTH TO 85 BYTES\n         MVC   LENGTH+2,HALF0          ZERO RESERVED BYTES\n         MVC   CNTLBYTE,HDRCNTL        MOVE IN HEADER CONTROL BYTE\n*\n***********************************************************************\n*                                                                     *\n*        LIST MEMBER NAMES                                            *\n*                                                                     *\n***********************************************************************\n*\nSCROLLER DS    0H\n         LA    R10,50                  LOAD LINE COUNT\n         ST    R2,PRESENT              SAVE ADDRESS OF CURRENT TABLE\n         LH    R7,4(R2)                LOAD NUMBER OF MEMBERS IN TABLE\n         LTR   R7,R7                   SEE IF THERE ARE ENTRIES\n         BZ    NOLIST                  NO.....GO PRINT MEMBERS\n         LA    R2,8(R2)                LOAD ADDRESS OF FIRST MEMBER\n         USING MEMDSECT,R2             ESTABLISH ADDRESSABILITY TO\n*                                      MEMBER TABLE ENTRY\nLOOP1    DS    0H\n         LA    R6,DATA                 LOAD ADDRESS OF OUTPUT BUFFER\n         MVI   DATA,BLANK              BLANK OUT OUTPUT BUFFER\n         MVC   DATA+1(79),DATA         FINISH BLANKING BUFFER\n         TM    CFIELD,HIGH             SEE IF THIS IS AN ALIAS\n         BZ    NOTALIAS                NO.....CONTINUE WITH MAIN NAME\n         BAL   R14,LOOKLOOP            GO LOOK FOR MAIN NAME\nNOTALIAS DS    0H\n         MVC   2(8,R6),MEMBER          PUT MEMBER NAME IN OUTPUT BUFFER\n         ST    R2,SAVER2               SAVE REGISTER 2\n         LA    R3,2                    LOAD NUMBER OF COLUMNS LEFT\n         LA    R8,1                    LOAD ENTRY NUMBER\nLOOP2    LA    R8,50(R8)               LOAD POINTER TO NEXT COLUMN\n*                                      ENTRY\n         CR    R8,R7                   SEE IF VALID ENTRY\n         BH    END2                    NO.....GO PRINT LINE\n         LA    R2,600(R2)              LOAD POINTER TO MEMBER NAME\n         LA    R6,30(R6)               LOAD POINTER TO NEXT OUTPUT\n*                                      BUFFER LOCATION\n         TM    CFIELD,HIGH             SEE IF THIS IS AN ALIAS\n         BZ    NOTAL2                  NO.....CONTINUE WITH MAIN NAME\n         BAL   R14,LOOKLOOP            GO LOOK FOR MAIN NAME\nNOTAL2   DS    0H\n         MVC   2(8,R6),MEMBER          PUT MEMBER NAME IN OUTPUT BUFFER\n         BCT   R3,LOOP2                DECREMENT COLUMN COUNT\nEND2     DS    0H\n         PUT   (R5),LINE               PUT OUT OUTPUT LINE\n         L     R2,SAVER2               RELOAD REGISTER 2\n         LA    R2,MEMSECTN             LOAD POINTER TO NEXT MEMBER NAME\n         BCT   R10,MOREROW             DECREMENT ROW COUNT\n         PUT   (R5),(R4)               PUT OUT PAGE EJECT WHEN ZERO\n         B     LOOP3                   RESET COUNTERS\nMOREROW  DS    0H\n         BCT   R7,LOOP1                DECREMENT MEMBER COUNT FOR\n*                                      CURRENT TABLE\nLOOP3    L     R2,PRESENT              LOAD POINTER TO CURRENT TABLE\n         L     R2,0(R2)                LOAD POINTER TO NEXT TABLE\n         LTR   R2,R2                   SEE IF IT WAS THE LAST TABLE\n         BNZ   SCROLLER                NO.....GO LIST OUT NEXT TABLE\n*\n***********************************************************************\n*                                                                     *\n*        PRINT MEMBERS IF:                                            *\n*           PRINT SPECIFIED OR                                        *\n*           BOTH LIST AND NOPRINT WERE NOT SPECIFIED                  *\n*                                                                     *\n***********************************************************************\n*\nNOLIST   DS    0H\n         L     R9,PARSBACK             LOAD ADDRESS PARS ANSWER\n         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY TO PDL\n         CLC   PPRINT,HALF2            SEE IF NOPRINT SPECIFIED\n         BE    ENDMEMB                 YES....GO SKIP PRINT\n         CLC   PPRINT,HALF1            SEE IF PRINT SPECIFIED\n         BE    CONTPRT                 YES....GO PRINT MEMBERS\n         CLC   PLIST,HALF1             SEE IF LIST SPECIFIED\n         BE    ENDMEMB                 YES....GO SKIP PRINT\n         DROP  R9                      DROP ADDRESSABILITY TO PDL\nCONTPRT  DS    0H\n         L     R6,SAVER6               RESTORE REGISTER 6\n         LA    R8,INPUT                LOAD ADDRESS OF INPUT DCB\n         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST IN WORKAREA\n         CLOSE ((R8),),MF=(E,CLOSLST)  CLOSE INPUT DCB\n         DROP  R8                      DROP ADDRESSABILITY TO INPUT DCB\n         TM    VOLBIT,NOMSG            IS NOMSG SPECIFIED ?         WFB\n         BO    NOMEMMSG                YES, SKIP MEMBER MESSAGE     WFB\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(PRTMSG,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATASET PRINT MESSAGE\n         DROP  R15                                                  WFB\n         LH    R4,DFPBDSL              LOAD LENGTH OF DSNAME       GTEL\n         A     R4,FULL4                INCREMENT LENGTH FOR PUTLINE\n         SLL   R4,16                   SHIFT LENGTH TO HIGH ORDER BYTES\n         STCM  R4,15,DSNLENP           STORE LENGTH OF PUTLINE\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(DSNLENP,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATA SET NAME MESSAGE\n         DROP  R15                                                  WFB\nNOMEMMSG DS    0H                                                   WFB\n         L     R2,MEMTABLE             LOAD ADDRESS OF FIRST MEMBER\n*                                      TABLE\n         LH    R3,4(R2)                LOAD NUMBER OF MEMBERS IN TABLE\n         LTR   R3,R3                   SEE IF THERE ARE ANY MEMBERS\n         BZ    ENDMEMB                 NO.....GO TO END OF SCROLLER\n         ST    R2,PRESENT              SAVE ADDRESS OF CURRENT TABLE\n         LA    R2,8(R2)                LOAD POINTER TO MEMBER NAME\nNEXTMEMB DS    0H\n         TM    CFIELD,HIGH             SEE IF THIS IS AN ALIAS ENTRY\n         BO    AGAIN                   YES....DO NOT PRINT IT\nPRINTMEM DS    0H\n         MVC   MEMNAME,MEMBER          MOVE MEMBER NAME INTO HEADER\n         MVC   JFCBELNM,MEMBER         MOVE MEMBER NAME INTO JFCBAREA\n         MVC   OPENLST,OPENCLOS        MOVE CONSTANT INTO OPEN LIST\n         OPEN  ((R8),INPUT),TYPE=J,MF=(E,OPENLST)\n*                                      OPEN INPUT DCB\n         STM   R2,R3,SAVER2            SAVE REGISTERS 2 AND 3\n         B     PRINTS                  GO PRINT MEMBER\nSEXIT    DS    0H\n         LM    R2,R3,SAVER2            RESTORE REGISTERS 2 AND 3\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST IN WORKAREA\n         CLOSE ((R8),),MF=(E,CLOSLST)  CLOSE INPUT DCB\nAGAIN    DS    0H\n         LA    R2,MEMSECTN             LOAD ADDRESS OF NEXT MEMBER\n         BCT   R3,NEXTMEMB             BRANCH TO HANDLE NEXT MEMBER\n         L     R14,PRESENT             ZERO...LOAD CURRENT TABLE\n*                                      ADDRESS\n         L     R2,0(R14)               LOAD ADDRESS OF NEXT TABLE\n         LTR   R2,R2                   SEE IF ZERO, LAST TABLE\n         BZ    ENDMEMB                 NO.....GO HANDLE END OF MEMBERS\n         ST    R2,PRESENT              SAVE ADDRESS OF CURRENT TABLE\n         LH    R3,4(R2)                LOAD NUMBER OF MEMBERS IN NEXT\n*                                      TABLE\n         LTR   R3,R3                   SEE IF ANY MEMBERS IN TABLE\n         BZ    ENDMEMB                 NO.....GO HANDLE END OF MEMBERS\n         LA    R2,8(R2)                LOAD POINTER TO MEMBER NAME\n         B     NEXTMEMB                GO GET NEXT MEMBER\nENDMEMB  DS    0H\n         L     R2,MEMTABLE             LOAD POINTER TO FIRST TABLE\nFREETABS DS    0H\n         LR    R1,R2                   LOAD AREA TO BE FREED\n         L     R2,0(R2)                LOAD POINTER TO NEXT TABLE\n         L     R0,MEMDATL              LOAD SIZE OF AREA TO BE FREED\n         FREEMAIN R,LV=(0),A=(1)       FREE STORAGE GETMAINED FOR TABLE\n         LTR   R2,R2                   SEE IF THERE WAS ANOTHER TABLE\n         BNZ   FREETABS                YES....GO FREE NEXT TABLE\n         L     R6,SAVER6               RESTORE REGISTER 6\n         LA    R8,INPUT                LOAD POINTER TO INPUT DCB\n         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB\n         TM    DCBOFLGS,DCBOFOPN       SEE IF INPUT DCB IS STILL OPEN\n         BNO   EXITMSG                 NO.....GO HANDLE NEXT DATASET\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST IN WORKAREA\n         CLOSE ((R8),),MF=(E,CLOSLST)  CLOSE INPUT DCB\n         DROP  R8                      DROP ADDRESSABILITY TO DCB\n         B     EXITMSG                 GO HANDLE NEXT DATASET\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        PUT OUT SYNAD ERROR MESSAGE,                                 *\n*           GO FREE MEMBER TABLES, AND                                *\n*           CONTINUE WITH NEXT DATASET                                *\n*                                                                     *\n***********************************************************************\n*\nSERRI    DS    0H\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(SYNADI,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATASET NOT PRINTED DUE TO SYNAD\n*                                      ERROR ON INPUT DATASET MESSAGE\n         DROP  R15                                                  WFB\n         B     ENDMEMB                 GO FREE MEMBER TABLES\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        SEARCH FOR MAIN NAME,                                        *\n*           SAME TTR AND NOT AN ALIAS                                 *\n*                                                                     *\n***********************************************************************\n*\nLOOKLOOP DS    0H\n         STM   R3,R4,SAVER3            SAVE REGISTERS 3 AND 4\n         L     R3,MEMTABLE             LOAD ADDRESS OF FIRST TABLE\n         USING MEMDSECT,R3             ESTABLISH ADDRESSABILITY TO\n*                                      MEMBER ENTRY\nLOOP4    DS    0H\n         ST    R3,CURRENT              SAVE ADDRESS OF PRESENT TABLE\n         LH    R4,4(R3)                LOAD NUMBER OF ELEMENTS IN TABLE\n         LTR   R4,R4                   SEE IF THERE ARE ZERO ELEMENTS\n         BZ    NOMAIN                  YES....GO HANDLE MAIN NOT FOUND\n         LA    R3,8(R3)                LOAD ADDRESS OF FIRST MEMBER\nLOOP5    DS    0H\n         CLC   MEMTTR,8(R2)            SEE IF TTRS ARE THE SAME\n         BE    SAMETTR                 YES....GO SEE IF IT IS AN ALIAS\nENDLP5   DS    0H\n         LA    R3,MEMSECTN             LOAD ADDRESS OF NEXT MEMBER\n         BCT   R4,LOOP5                DECREMENT MEMBER COUNT\n         L     R3,CURRENT              LOAD ADDRESS OF THIS TABLE\n         L     R3,0(R3)                LOAD ADDRESS OF NEXT TABLE\n         LTR   R3,R3                   SEE IF IT WAS THE LAST TABLE\n         BNZ   LOOP4                   NO.....GO CHECK NEXT TABLE\n         B     NOMAIN                  GO HANDLE MAIN NOT FOUND\nSAMETTR  DS    0H\n         TM    CFIELD,HIGH             SEE IF THIS IS ALSO AN ALIAS\n         BO    ENDLP5                  YES....GO LOOK FOR ANOTHER TTR\n         MVC   11(8,R6),MEMBER         MOVE MEMBER NAME INTO OUTPUT\n         B     ENDLOOK                 GO TO RETURN TO CALLER\nNOMAIN   DS    0H\n         MVC   11(8,R6),ALIAS          INDICATE THIS IS AN ALIAS\nENDLOOK  DS    0H\n         LM    R3,R4,SAVER3            RESTORE REGISTERS 3 AND 4\n         BR    R14                     RETURN TO CALLER\n         DROP  R3                      DROP ADDRESSABILITY TO TABLE\n*\nCONTINUE DS    0H\n         L     R1,0(,R6)               GET ADDRESS OF DSNAME        WFB\n         CLI   0(R1),C'*'              SEE IF DSNAME IS ASTERISK    WFB\n         BE    CLOSDCBS                YES, DO NOT FOLLOW CHAIN     WFB\n         L     R6,24(R6)               LOAD POINTER TO NEXT DSNAME ON\n*                                      CHAIN\n         C     R6,ENDCHAIN             SEE IF END OF CHAIN IS REACHED\n         BNE   NEXT                    NO.....GO DO NEXT DATASET NAME\nCLOSDCBS DS    0H\n         TM    INPUT+48,DCBOFOPN       SEE IF INPUT DCB IS STILL OPEN\n         BNO   CHKOUTA                 NO.....GO CHECK DCB FOR ASA CODE\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST WORKAREA\n         LA    R5,INPUT                LOAD POINTER TO INPUT DCB\n         CLOSE ((R5),),MF=(E,CLOSLST)  CLOSE INPUT DCB\n         L     R1,0(,R6)               GET ADDRESS OF DSNAME        WFB\n         CLI   0(R1),C'*'              SEE IF DSNAME IS ASTERISK    WFB\n         BE    CHKOUTA                 YES, DO NOT FREE DDN(...)    WFB\n         LA    R1,PRINTI               FREE INPUT DATASET          GTEL\n         BAL   R2,FREEDD               FREE INPUT DATASET          GTEL\nCHKOUTA  DS    0H\n         TM    OUTPUTA+48,DCBOFOPN     SEE IF OUTPUT DCB FOR ASA WAS\n*                                      OPENED\n         BNO   CHKOUTM                 NO.....GO CHECK DCB FOR MACHINE\n*                                      CODE\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST WORKAREA\n         LA    R5,OUTPUTA              LOAD POINTER TO ASA CODE DCB\n         TM    VOLBIT,UDKDONE          WERE UDKS WRITTEN ?          WFB\n         BZ    CLOSEA                  NO, GO CLOSE                 WFB\n         PUT   (R5),UDKRESET           PUT OUT UDK RESET TEXT       WFB\n         NI    VOLBIT,UDKDONE          TURN OFF UDK WRITTEN FLAG    WFB\nCLOSEA   DS    0H                                                   WFB\n         CLOSE ((R5),),MF=(E,CLOSLST)  CLOSE ASA CODE OUTPUT DCB\n         LA    R1,PRINTA               LOAD ADDRESS OF PRINT DDNAME\n         BAL   R2,FREEDD               GO FREE ASA CODE OUTPUT DDNAME\nCHKOUTM  DS    0H\n         TM    OUTPUTM+48,DCBOFOPN     SEE IF OUTPUT DCB FOR MACHINE\n*                                      CODE WAS OPENED\n         BNO   RETURN                  NO.....GO FREE GETMAINED AREAS\n*                                      AND RETURN\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST WORKAREA\n         LA    R5,OUTPUTM              LOAD POINTER TO MACHINE CODE DCB\n         TM    VOLBIT,UDKDONE          WERE UDKS WRITTEN ?          WFB\n         BZ    CLOSEM                  NO, GO CLOSE                 WFB\n         PUT   (R5),UDKRESET           PUT OUT UDK RESET TEXT       WFB\n         NI    VOLBIT,UDKDONE          TURN OFF UDK WRITTEN FLAG    WFB\nCLOSEM   DS    0H                                                   WFB\n         CLOSE ((R5),),MF=(E,CLOSLST)  CLOSE MACHINE CODE OUTPUT DCB\n         LA    R1,PRINTM               LOAD ADDRESS OF PRINT DDNAME\n         BAL   R2,FREEDD               GO FREE MACHINE CODE OUTPUT\n*                                      DDNAME\n*\n***********************************************************************\n*                                                                     *\n*        CLEANUP AREAS GETMAINED BY PARS,                             *\n*           SET RETURN CODE, RESTORE REGISTERS AND                    *\n*           RETURN TO CALLER                                          *\n*                                                                     *\n***********************************************************************\n*\nRETURN   DS    0H\n         IKJRLSA PARSBACK              RELEASE AREAS GETMAINED BY PARS\n         L     R1,ALNDSECT\n         FREEMAIN R,LV=RECSIZE,A=(1)                                WFB\n         LR    R1,R13                  LOAD ADDRESS OF GETMAINED AREA\n         L     R13,4(,R13)             RELOAD ADDRESS OF PREVIOUS SAVE\n*                                      AREA\n         LA    R0,LDYNAMIC             LOAD LENGTH OF GETMAINED AREA\n         FREEMAIN R,LV=(0),A=(1)       FREE GETMAINED AREA\n         SLR   R15,R15                 ZERO REGISTER 15.  RETURN CODE\n*                                      CODE WILL ALWAYS BE ZERO\n         L     R14,12(,R13)            LOAD REGISTER 14 WITH RETURN\n*                                      ADDRESS\n         LM    R0,R12,20(R13)          RESTORE REGISTERS\n         BR    R14                     RETURN\n*\n***********************************************************************\n*                                                                     *\n*        ROUTINE TO CONVERT NONZERO RETURN CODES TO DECIMAL           *\n*           FOR DISPLAY                                               *\n*                                                                     *\n***********************************************************************\n*\nSETCODE  DS    0H\n         CVD   R8,DEC                  CONVERT RETURN CODE TO DECIMAL\n         UNPK  CONV(8),DEC(8)          UNPACK RETURN CODE\n         MVZ   CONV+1(7),CONV          MOVE ZONES IN CONVERTED RETURN\n*                                      CODE\n         MVC   RETNCD(2),HALF12        MOVE LENGTH OF DATA FOR PUTLINE\n         MVC   RETNCD+2(2),HALF0       MOVE IN ZEROES FOR PUTLINE\n         BR    R14                     RETURN\n*\n***********************************************************************\n*                                                                     *\n*        FREE AND REALOCATE PRINTX FILE AS SYSOUT                     *\n*                                                                     *\n***********************************************************************\n*\nALLOCOUT DS    0H\n         STM   14,9,ALCSAVE            SAVE WORK REGISTERS\n*---------------------------------------------------------------------*\n*------------------------- START OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\n         MVC   SETPRTE(SETPRTEL),SETPRTL MOVE SETPRT LIST\n         MVI   SETFLAG,X'00'             AND CLEAR FLAG\n*---------------------------------------------------------------------*\n*--------------------------- END OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\n         LR    R1,R3                   LOAD POINTER TO DDNAME\n         BAL   R2,FREEDD               BRANCH TO FREE ROUTINE\n         LTR   R8,R8                   SEE IF RETURN CODE FROM FREE IS\n*                                      ZERO\n         BNZ   OPENFAIL                NO.....GO PUT OUT OPEN FAILED\n         LA    R8,REQBLK               LOAD POINTER TO REQUEST BLOCK\n         ST    R8,RBPTR                INITIALIZE REQUEST BLOCK POINTER\n         MVI   RBPTR,S99RBPND          INDICATE END OF PARAMETER LIST\n         USING S99RB,R8                ESTABLISH ADDRESSABILITY TO\n*                                      REQUEST BLOCK\n         MVC   S99RBLN(RBLEN),REQBLKC  INITALIZE RB\n         LA    R1,TEXTPTRS             LOAD POINTER TO TEXT POINTERS\n         ST    R1,S99TXTPP             STORE POINTER IN RB\n         DROP  R8                      DROP ADDRESSABILITY TO RB\n         USING S99TUPL,R1              ESTABLISH ADDRESSABILITY TO\n*                                      TEXT UNIT POINTER LIST\n         LA    R2,TEXTA                LOAD POINTER TO FIRST TEXT UNIT\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\n         USING S99TUNIT,R2             ESTABLISH ADDRESSABILITY TO\n*                                      TEXT UNIT\n         MVC   S99TUKEY(TEXTALEN),TEXTAC  INITIALIZE TEXT UNIT A\n         MVC   S99TUPAR(8),0(R3)       MOVE IN PARAMETER (DDNAME)\n         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT\n*                                      POINTER\n         LA    R2,TEXTB                LOAD POINTER TO TEXT UNIT B\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\n         MVC   S99TUKEY(TEXTBLEN),TEXTBC  INITIALIZE TEXT UNIT B\n*\n***********************************************************************\n*                                                                     *\n*        SET UP ADDRESSABILITY TO PDL                                 *\n*           AND SEE IF SYSOUT CLASS/DEST ARE PRESENT                  *\n*           ALSO FORMS/TRAIN/FCB/PROG.                             GTEL\n***********************************************************************\n*\n         L     R9,PARSBACK             LOAD ADDRESS PARS ANSWER\n         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY TO PDL\n         CLC   PCLASS(2),HALF1         SEE IF CLASS SPECIFIED\n         BNE   NOCLASS                 NO.....GO CHECK FOR DESTINATION\n         L     R7,SCLASS               LOAD POINTER TO SYSOUT CLASS\n         MVC   S99TUPAR,0(R7)          MOVE CLASS INTO TEXT UNIT B\nNOCLASS  DS    0H\n         CLC   PDEST(2),HALF1          SEE IF DEST SPECIFIED\n         BNE   NODEST                  NO.....GO CHECK FOR HOLD\n         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT\n*                                      POINTER\n         LA    R2,TEXTC                LOAD POINTER TO TEXT UNIT C\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\n         MVC   S99TUKEY(TEXTCLEN),TEXTCC  INITIALIZE TEXT UNIT C\n         L     R7,SDEST                LOAD POINTER TO DESTINATION\n         CLI   NODELEN+1,0             IS NODE.USERID SPECIFIED ?   WFB\n         BZ    NONODE                  NO, USE TOTAL LENGTH         WFB\n         LH    R6,NODELEN              YES, USE NODE LENGTH         WFB\n         STH   R6,S99TULNG             STORE LENGTH OF DEST IN TU   WFB\n         BCTR  R6,0                    DECREMENT LENGTH FOR EXECUTE WFB\n         EX    R6,MOVEDEST             MOVE NODE INTO TEXT UNIT     WFB\n         LA    R1,4(,R1)               POINT NEXT TEXT UNIT POINTER WFB\n         LA    R2,TEXTK                ADDRESS TEXT UNIT K - USERID WFB\n         ST    R2,S99TUPTR             STORE ADDRESS IN TUPL        WFB\n         MVC   S99TUKEY(TEXTKLEN),TEXTKC  INITIALIZE TEXT UNIT K    WFB\n         LA    R7,2(R6,R7)             POINT PAST 'NODE.' TO USERID WFB\n         LH    R6,SDEST+4              GET TOTAL LENGTH             WFB\n         SH    R6,NODELEN              MINUS NODE LENGTH            WFB\n         SH    R6,HALF2                MINUS 1 FOR DOT, 1 EXECUTE   WFB\n         EX    R6,MOVEDEST             MOVE USERID INTO TEXT UNIT   WFB\n         B     NODEST                                               WFB\nNONODE   DS    0H                                                   WFB\n         LH    R6,SDEST+4              LOAD LENGTH OF DESTINATION ID\n         STH   R6,S99TULNG             STORE LENGTH OF DEST IN TU\n         BCTR  R6,0                    DECREMENT LENGTH FOR EXECUTE OF\n*                                      MOVE\n         EX    R6,MOVEDEST             MOVE DEST INTO TU\nMOVEDEST MVC   S99TUPAR,0(R7)          MOVE TO BE EXECUTED\n*\nNODEST   DS    0H\n         CLC   PHOLD(2),HALF1          SEE IF HOLD SPECIFIED\n         BNE   NOHOLD                  NO.....GO CHECK FOR COPIES\n         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT\n*                                      POINTER\n         LA    R2,TEXTDC               LOAD POINTER TO TEXT UNIT C\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\nNOHOLD   DS    0H\n         CLC   PCOPIES(2),HALF1        SEE IF COPY SPECIFIED\n         BNE   NOCOPY                  NO.....GO ZERO ECB\n         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT\n*                                      POINTER\n         LA    R2,TEXTE                LOAD POINTER TO TEXT UNIT E\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\n         MVC   S99TUKEY(TEXTELEN),TEXTEC  INITIALIZE TEXT UNIT E\n         L     R7,SCOPIES              LOAD POINTER TO COPY FIELD\n         LH    R6,SCOPIES+4            LOAD LENGTH OF COPY FIELD\n         BCTR  R6,0                    DECREMENT REGISTER 6 FOR EXECUTE\n*                                      OF PACK INSTRUCTION\n         EX    R6,PACKCOPY             EXECUTE PACK TO CONVERT COPIES\n*                                      TO ZONED DECIMAL\n         CVB   R6,DEC                  CONVERT ZONED TO BINARY\n         STCM  R6,1,S99TUPAR           STORE NUMBER OF COPIES IN TU\nNOCOPY   DS    0H\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** START OF GTEL MOD ************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         CLC   PFORMS(2),HALF1         SEE IF FORMS SPECIFIED\n         BNE   NOFORMS                 NO.....GO CHECK TRAIN\n         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT\n*                                      POINTER\n         LA    R2,TEXTI                LOAD POINTER TO TEXT UNIT I\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\n         MVC   S99TUKEY(TEXTILEN),TEXTIC  INITIALIZE TEXT UNIT I\n         L     R7,RFORMS               LOAD POINTER TO FORMS FIELD\n         LH    R6,RFORMS+4             LOAD LENGTH OF FORMS FIELD\n         STH   R6,S99TULNG             STORE LENGTH IN TUE\n         BCTR  R6,0                    DECREMENT LENGTH\n         EX    R6,MOVEDEST             MOVE FORMS INTO FIELD\nNOFORMS  DS    0H\n         CLC   PTRAIN(2),HALF1         SEE IF TRAIN SPECIFIED\n         BNE   NOTRAIN                 NO.....GO CHECK FCB\n         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT\n*                                      POINTER\n         LA    R2,TEXTH                LOAD POINTER TO TEXT UNIT G\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\n         MVC   S99TUKEY(TEXTHLEN),TEXTHC  INITIALIZE TEXT UNIT H\n         L     R7,RTRAIN               LOAD POINTER TO TRAIN FIELD\n         LH    R6,RTRAIN+4             LOAD LENGTH OF TRAIN FIELD\n         STH   R6,S99TULNG             SAVE LENGTH OF FCBE\n         BCTR  R6,0                    DECREMENT FOR EX\n         EX    R6,MOVEDEST             MOVE FCB INTO TU\nNOTRAIN  DS    0H\n         CLC   PFCB(2),HALF1           SEE IF FCB  SPECIFIED\n         BNE   NOFCB                   NO.....GO ZERO ECB\n         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT\n*                                      POINTER\n         LA    R2,TEXTG                LOAD POINTER TO TEXT UNIT G\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\n         MVC   S99TUKEY(TEXTGLEN),TEXTGC  INITIALIZE TEXT UNIT G\n         L     R7,RFCB                 LOAD POINTER TO FCB FIELD\n         LH    R6,RFCB+4               LOAD LENGTH OF FCB FIELD\n         STH   R6,S99TULNG             SAVE LENGTH OF FCB IN TUE\n         BCTR  R6,0                    DECREMENT\n         EX    R6,MOVEDEST             MOVE FCB TO TU\nNOFCB    DS    0H\n         CLC   PPROG(2),HALF1          SEE IF PROG SPECIFIED\n         BNE   NOPROG                  NO.....GO ZERO ECB\n         CLI   NODELEN+1,0             IS DEST(NODE.USERID) GIVEN ? WFB\n         BH    NOPROG                  YES, IGNORE PROG             WFB\n*                                      DYNALLOC TEXT UNITS FOR USER WFB\n*                                      AND PROG ARE MUTUAL EXCLUSIV WFB\n         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT\n*                                      POINTER\n         LA    R2,TEXTJ                LOAD POINTER TO TEXT UNIT J\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\n         MVC   S99TUKEY(TEXTJLEN),TEXTJC  INITIALIZE TEXT UNIT J\n         L     R7,RPROG                LOAD POINTER TO PROG FIELD\n         LH    R6,RPROG+4              LOAD LENGTH OF PROG FIELD\n         STH   R6,S99TULNG             SAVE LENGTH OF PROG IN TUE\n         BCTR  R6,0                    DECREMENT FOR MOVE\n         EX    R6,MOVEDEST             MOVE PROG TO TU\nNOPROG   DS    0H\n         CLC   PLINELEN(2),HALF1       SEE IF LL SPECIFIED\n         BNE   LLDEF                   NO...\n         L     R7,RLINELEN             LOAD POINTER TO LL FIELD\n         LH    R6,RLINELEN+4           LOAD LENGTH OF LL FIELD\n         BCTR  R6,0                    DECREMENT FOR PACK\n         EX    R6,ZEROTEST             LINELENGTH 0 ENTERED?\n         BE    LLDEF                   IF YES, USE DEFAULT\n         EX    R6,PACKLEN              CONVERT INTO PACKED DECIMAL\n         CVB   R6,DEC                  CONVERT INTO FIXED BINARY\n         CH    R6,HALF1                LESS THAN ONE?\n         BNL   NOLLDEF                 IF YES, USE DEFAULT\n         CH    R6,HALF208              GREATER THAN 208?\n         BNH   NOLLDEF                 IF YES, USE DEFAULT\nLLDEF    LH    R6,HALF132              PLACE 132 IN R6\nNOLLDEF  STH   R6,LINELEN              STORE INTO LINELEN\n         A     R6,FULL5                ADD LENGTH FOR VB OUTPUT\n         STH   R6,VBLEN                STORE INTO VBLEN1\n         MVI   CCBIT,BLANK             INITIALIZE CCBIT WITH BLANK\n         CLC   PPAGELEN(2),HALF1       SEE IF PL SPECIFIED\n         BNE   PLDEF                   NO...\n         OI    CCBIT,HIGH              YES, SET BIT FOR PAGE LEN\n         L     R7,RPAGELEN             LOAD POINTER TO PL FIELD\n         LH    R6,RPAGELEN+4           LOAD LENGTH OF PL FIELD\n         BCTR  R6,0                    DECREMENT FOR PACK\n         EX    R6,ZEROTEST             PAGELENGTH 0 SPECIFIED?\n         BE    PLDEF                   IF YES, USE DEFAULT\n         EX    R6,PACKPAG              CONVERT INTO PACKED DECIMAL\n         CVB   R6,DEC                  CONVERT INTO FIXED BINARY\n         CH    R6,HALF5                LESS THAN 5?\n         BNL   NOPLDEF                 IF YES, USE DEFAULT\n         CH    R6,HALF120              GREATER THAN 120?         ARAMCO\n         BNH   NOPLDEF                 IF YES, USE DEFAULT\nPLDEF    LH    R6,HALF60               LOAD DEFAULT INTO R6      ARAMCO\nNOPLDEF  STH   R6,PAGELEN              STORE INTO PAGELEN\n         CLC   PSPACE(2),HALF1         SEE IF SINGLE SPACE FORMAT\n         BE    SETSS                   YES...\n         CLC   PSPACE(2),HALF2         SEE IF DOUBLE SPACE FORMAT\n         BE    SETDS                   GO ON\n         CLC   PASA(2),HALF1           USER SAYS ASA IS IN DATA ?   WFB\n         BNE   CCSET                   NO, CONTINUE                 WFB\n         OI    CCBIT,FORCEASA          YES, SET FORCE BIT           WFB\n         B     CCSET                   CONTINUE IF NEITHER SS OR DS\nSETSS    OI    CCBIT,MID1              FOR SINGLE SPACE CC\n         B     CCSET\nSETDS    OI    CCBIT,MID2              FOR DOUBLE SPACE CC\n         LH    R6,PAGELEN              DECREMENT PAGE LENGTH     ARAMCO\n         BCTR  R6,0                                              ARAMCO\n         STH   R6,PAGELEN              BY 1 FOR DS LISTINGS.     ARAMCO\nCCSET    DS    0H\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** END OF GTEL MOD **************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*---------------------------------------------------------------------*\n*------------------------- START OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\n         CLC   PBURST(2),HALF1         WAS BURST PARM \"BURST\"?\n         BNE   NOBURST                 NO, CHECK FLASH\n         OI    SETFLAG,SETBURST        YES, TURN ON FLAG\n         OI    SETPRTE+16,X'80'        AND SET SETPRT BIT\nNOBURST  DS    0H\n         CLC   PFLASH(2),HALF1         ANY FLASH PARM ?\n         BNE   NOFLASH                 NO, CHECK CHARS\n         L     R7,RFLASH               YES, POINT AT PARM\n         LH    R6,RFLASH+4             AND GET LENGTH\n         BCTR  R6,0                    DECREMENT FOR MOVE\n         MVC   SETFLASH(4),BLANKS      BLANK IT OUT\n         MVC   SETFLASH(1),0(R7)\n         EX    R6,*-6                  AND MOVE PARM TO SETPRT\n         OI    SETFLAG,SETFLSH\nNOFLASH  DS    0H\n         CLC   PCHARS(2),HALF1         ANY CHARS PARM ?\n         BNE   CHAREND                 NO, END OF ARAMCO\n         OI    SETFLAG,SETCHAR\n         CLI   RCHARS+8,X'FF'          MORE THAN ONE CHAR SET?\n         BE    CHARSET                 NO, BRANCH\n         USING IHADCB,R15\n         LA    R15,OUTPUTA\n         OI    DCBOPTCD,DCBOPTJ        YES, SET OPTCD=J\n         LA    R15,OUTPUTM AND ON VBM DCB TOO\n         OI    DCBOPTCD,DCBOPTJ\n         DROP  R15\nCHARSET  LA    R15,4                   SET LOOP LIMIT\n         LA    R14,RCHARS              POINT AT FIRST CHARS PDE\n         LA    R2,SETCHARS             AND AT SETPRT CHARS PARM\nCHARLOOP L     R7,0(R14)               POINT TO INPUT CHARS PARM\n         LH    R6,4(R14)               AND GET LENGTH\n         BCTR  R6,0                    DECREMENT FOR MOVE\n         MVC   0(4,R2),BLANKS          BLANK IT OUT\n         MVC   0(0,R2),0(R7)\n         EX    R6,*-6                  AND MOVE PARM TO SETPRT\n         CLI   8(R14),X'FF'            END OF LIST?\n         BE    CHAREND                 YES, EXIT LOOP\n         L     R14,8(R14)              NO, BUMP LOOP\n         LA    R2,4(R2)                POINTERS AND KEEP GOING\n         BCT   R15,CHARLOOP            MAX OF 4 CHARS PARMS\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(CHARMSG,SINGLE,DATA),MF=(E,IOPLSECT)\n         DROP  R15                                                  WFB\n*DELETED B     CHAREND                                              WFB\n*                                      CHARMSG MOVED TO MSG CSECT   WFB\nCHAREND  DS    0H\n*---------------------------------------------------------------------*\n*--------------------------- END OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\n         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT\n*                                      POINTER\n         LA    R2,TEXTFC               LOAD POINTER TO TEXT UNIT F\n*                                      PERMANENTLY ALLOCATED\n*                                      ATTRIBUTE\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\n         MVI   S99TUPTR,S99TUPLN       INDICATE END OF TEXT UNIT\n*                                      POINTER LIST\n         DROP  R1,R2,R9                DROP ADDRESSABILITY TO DSECTS\n         LA    R1,RBPTR                LOAD ADDRESS OF REQUEST BLOCK\n*                                      POINTER\n         DYNALLOC                      ISSUE DYNAMIC ALLOCATION SVC\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO\n         BNZ   ALCFAIL                 NO.....GO AND CALL DAIR FAIL\n         MVC   OPENLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO WORKAREA\n         OPEN  ((R5),(OUTPUT)),MF=(E,OPENLST)\n*                                      OPEN OUTPUT DCB\n         TM    48(R5),DCBOFOPN         SEE IF DCB OPENED SUCCESSFULLY\n         BNO   OPENFAIL                NO.....GO PUT OUT OUTPUT DCB\n*---------------------------------------------------------------------*\n*------------------------- START OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\nCKSETPRT CLI   SETFLAG,X'00'           NEED SETPRT ?\n         BE    NOSETPRT                NO, SKIP IT\n         L     R6,DAPLSECT             ADDRESS UPT\n         USING UPT,R6\n         MVC   SAVEUPT(1),UPTSWS       SAVE UPT SWITCHES\n         NI    UPTSWS,X'FF'-UPTWTP     GET RID OF MSG IEF288I\n         SETPRT (R5),MF=(E,SETPRTE)\n         MVC   UPTSWS(1),SAVEUPT       RESTORE UPT SWITCHES\n         DROP R6\nNOSETPRT DS    0H\n*---------------------------------------------------------------------*\n*--------------------------- END OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\n*                                      NOT OPENED MESSAGE\n         LM    14,9,ALCSAVE            RESTORE REGISTERS\n         BR    R14                     RETURN TO CALLER\nALCFAIL  DS    0H\n         LA    R1,REQBLK               LOAD ADDRESS OF REQUEST\n*                                      BLOCK\n         MVI   DFID+1,DFSVC99          SET DAIR FAIL FOR SVC 99 ERROR\n         BAL   R2,DAIRFAIL             LOAD ADDRESS OF OPEN FAIL AND\n*                                      BRANCH TO DAIRFAIL ROUTINE\nOPENFAIL DS    0H\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(OPENMSG,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      OUTPUT DCB NOT OPEND MESSAGE\n         DROP  R15                                                  WFB\n         S     R3,FULL4                GET POINTER TO PUTLINE DDNAME\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=((R3),SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DDNAME\n         DROP  R15                                                  WFB\n         B     CLOSDCBS                GO CLOSE DCBS AND RETURN\n*\n***********************************************************************\n*                                                                     *\n*        INVOKE DAIR TO FREE FILENAME VIA CALLTSSR                    *\n*           AND CHECK FOR ZERO RETURN CODE                            *\n*                                                                     *\n***********************************************************************\n*\nFREEDD   DS    0H\n         SLR   R8,R8                   INITIALIZE REGISTER 8 TO ZERO\n*                                      RETURN CODE\n         MVC   DAP18(DAPB18L),DAPB18C  INITIALIZE DAIR PARAMETER BLOCK\n*                                      18 (FREE BY DATASET)\n         LA    R4,DAP18                LOAD ADDRESS OF DAPB\n         USING DAPB18,R4               ESTABLISH ADDRESSABILITY TO\n*                                      DAPB\n         MVC   DA18DDN,0(R1)           MOVE DDNAME INTO DAPB\n         SLR   R7,R7                   ZERO REGISTER 7\n         ST    R7,ECB                  STORE REGISTER 7 AS DUMMY ECB\n         LA    R1,DAPLSECT             LOAD ADDRESS OF DAPL\n         USING DAPL,R1                 ESTABLISH ADDRESSABILITY TO DAPL\n         ST    R4,DAPLDAPB             STORE ADDRESS OF DAPB IN DAPL\n         DROP  R1,R4                   DROP ADDRESSABILITY TO DAPL AND\n*                                      DAPB\n         CALLTSSR EP=IKJDAIR           CALL DAIR TO FREE DDNAME\n         C     R15,FULL28              SEE IF RETURN CODE IS 28\n*                                      (DDNAME NOT ALLOCATED)\n         BER   R2                      YES....GO CONTINUE PROCESSING\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO\n         BZR   R2                      YES....GO CONTINUE PROCESSING\n         MVI   DFID+1,DFDAIR           SET DAIRFAIL ID TO INDICATE DAIR\n*\n***********************************************************************\n*                                                                     *\n*        INVOKE DAIRFAIL TO DISPLAY AN ERROR MESSAGE                  *\n*                                                                     *\n***********************************************************************\n*\nDAIRFAIL XC    DFPARMS(DFLEN),DFPARMS  INITIALIZE PARMLIST FOR DAIR\n*                                      FAIL TO ZEROS\n         ST    R1,DFDAPLP              STORE POINTER TO DAPL/RB IN\n*                                      PARAMETER LIST\n         ST    R15,RETCODE             STORE RETURN CODE\n         LA    R1,RETCODE              LOAD ADDRESS OF RETURN CODE\n         ST    R1,DFRCP                STORE POINTER TO RETURN CODE IN\n*                                      PARAMETER LIST\n         LA    R1,FULL0                LOAD ADDRESS OF FULLWORD OF\n*                                      ZEROS\n         ST    R1,DFJEFF02             STORE DUMMY POINTER TO IKJEFF02\n*                                      IN PARMLIST\n         LA    R1,DFID                 LOAD ADDRESS OF DAIR FAIL ID\n*                                      FIELD\n         ST    R1,DFIDP                STORE POINTER TO DFID IN\n*                                      PARMLIST\n         MVI   DFID,NOWTP              SET FOR NO WRITE TO PROGRAMMER\n         L     R1,SAVEAREA+4           LOAD ADDRESS OF PEVIOUS\n*                                      SAVEAREA\n         L     R1,24(R1)               LOAD POINTER TO CPPL\n         ST    R1,DFCPPLP              STORE POINTER TO CPPL IN\n*                                      PARMLIST\n         LINK  EP=IKJEFF18,MF=(E,DFPARMS)  LINK TO DAIR FAIL SERVICE\n*                                      ROUTINE TO HANDLE RETURN\n*                                      CODE\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO\n         BZR   R2                      YES....GO RETURN TO CALLER\n         LR    R8,R15                  LOAD REGISTER 8 WITH RETURN CODE\n         BAL   R14,SETCODE             GO CONVERT CODE TO DECIMAL\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(DRFLERR,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DAIR FAIL ERROR MESSAGE\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(RETNCD,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DECIMAL RETURN CODE\n         DROP  R15                                                  WFB\n         BR    R2                      GO RETURN TO CALLER\n*\n******************** INSTRUCTIONS TO BE EXECUTED **********************\n*\nFOLDLINE OC    5(0,R9),BLANKS                                      GTEL\nMOVEDSN  MVC   DSNBUF(0),0(R5)\nMOVEVOL  MVC   VOLUME(0),0(R7)\nMOVEUNIT MVC   UNIT(0),0(R7)                                        WFB\nPACKLEN  PACK  DEC(8),0(0,R7)                                      GTEL\nPACKPAG  PACK  DEC(8),0(0,R7)                                      GTEL\nPACKCOPY PACK  DEC(8),0(0,R7)\nZEROTEST CLC   0(0,R7),ZEROS\n         USING S99TUNIT,R2             ADDRESSABILITY TO S99 TEXT   WFB\nMOVEDDN  MVC   S99TUPAR(0),0(R5)       MOVE DDNAME INTO S99 TEXT    WFB\n         DROP  R2                                                   WFB\n         USING LINDSECT,R15            ADDRESSABILITY TO OUTPUT REC WFB\nMOVEUDK  MVC   RECDATA+3(0),0(R14)     MOVE UDK FONT NAME TO OUTPUT WFB\n         DROP  R15                                                  WFB\n         USING DAPB08,R8\nMOVEMEM  MVC   DA08MNM(0),0(R5)\nMOVEPASS MVC   DA08PSWD(0),0(R5)\n         DROP  R8\nDFPBMVE  MVC   DFPBNAME(0),0(R5)                                   GTEL\n*\n***************************** CONSTANTS *******************************\n*\n******************** DAIR CONTROL BLOCK CONSTANTS *********************\nDAPB08C  DS    0F\n         DC    X'0008'                 DA08CD\n         DC    H'0'                    DA08FLG\n         DC    H'0'                    DA08DARC\n         DC    H'0'                    DA08CTRC\n         DC    A(0)                    DA08PDSN\n         DC    CL8'PRINTI  '           DA08DDN\n         DC    CL8' '                  DA08UNIT\n         DC    CL8' '                  DA08SER\n         DC    F'0'                    DA08BLK\n         DC    F'0'                    DA08PQTY\n         DC    F'0'                    DA08SQTY\n         DC    F'0'                    DA08DQTY\n         DC    CL8' '                  DA08MNM\n         DC    CL8' '                  DA08PSWD\n         DC    X'08'                   DA08DSP1      SHR\n         DC    X'08'                   DA08DSP2      KEEP\n         DC    X'08'                   DA08DSP3      KEEP\n         DC    X'08'                   DA08CTL       PERM\n         DC    F'0'                    DA08DSO\n         DC    CL8' '                  DA08ALN\nDAPB08L  EQU   *-DAPB08C               LENGTH\n         SPACE 2\nDAPB18C  DS    0F\n         DC    X'0018'                 DA18CD\n         DC    X'0000'                 DA18FLG\n         DC    H'0'                    DA18DARC\n         DC    H'0'                    DA18CTRC\n         DC    F'0'                    DA18PDSN\n         DC    CL8'PRINTI'             DA18DDN\n         DC    CL8' '                  DA18MNM\n         DC    CL2' '                  DA18SCLS\n         DC    X'08'                   DA18DPS2\n         DC    X'10'                   DA18CTL\n         DC    CL8' '                  DA18JBNM\nDAPB18L  EQU   *-DAPB18C               LENGTH\n         SPACE 2\nINPUTC   DCB   DSORG=PS,MACRF=(GM),EODAD=EXITI,SYNAD=ERRI,DDNAME=PRINTI\nINPUTL   EQU   *-INPUTC\n*\nOUTPUTAC DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=PRINTA,RECFM=VBA, X\n               LRECL=256,BLKSIZE=3120\nOUTPUTAL EQU   *-OUTPUTAC\n*\nOUTPUTMC DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=PRINTM,RECFM=VBM, X\n               LRECL=256,BLKSIZE=3120\nOUTPUTML EQU   *-OUTPUTMC\n*\nDIRECTC  DCB   DDNAME=PRINTI,DSORG=PS,MACRF=(GM),RECFM=U,BLKSIZE=256,  X\n               SYNAD=SERRI,EODAD=FREEBLK\nDIRECTL  EQU   *-DIRECTC\n*\nOPENCLOS OPEN  (,),MF=L\n         SPACE 2\n*---------------------------------------------------------------------*\n*------------------------- START OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\nSETPRTL  SETPRT OUTPUTAC,,MF=L\n*---------------------------------------------------------------------*\n*--------------------------- END OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\nHEADERC  DS    0F\n         DC    H'75'                   (WAS 49 BEFORE DATE)  ARAMCO WFB\n         DC    H'0'\nHDRCNTLC DC    C' '\n         DC    CL34' **** TSO FOREGROUND HARDCOPY ****'      ARAMCO WFB\n         DC    CL36'      HH:MM:SS    MONTHNAME DY, YEAR'           WFB\nHEADERM  DS    0F\n         DC    H'49'                                             ARAMCO\n         DC    H'0'\n         DC    C' '\n         DC    CL44' *** TSO FOREGROUND MEMBER LIST ***'         ARAMCO\n         DS    0H                                                ARAMCO\nLDSNAME  DS    0CL12\n         ORG   LDSNAME\n         DC    H'86'                                             ARAMCO\n         DC    H'0'\n         DC    CL9'  DSNAME='                                    ARAMCO\nVOLCONST DC    CL11'   VOLUME: '       FOR HEADING WHEN VOL(...)    WFB\nDDNCONST DC    CL11'   DDNAME: '       FOR HEADING WHEN DDN(...)    WFB\nEJECTM   DS    0F\n         DC    H'5'\n         DC    H'0'\n         DC    X'8B'\nEJECTA   DS    0F\n         DC    H'5'\n         DC    H'0'\n         DC    C'1'\nSPACE    EQU   EJECTA\n         SPACE 2\nFULL0    DC    F'0'\nFULL1    DC    F'1'\nFULL4    DC    F'4'\nFULL5    DC    F'5'\nFULL20   DC    F'20'\nFULL28   DC    F'28'\nFULL61   DC    F'61'                                               GTEL\nFULL132  DC    F'132'                                              GTEL\nFULL256  DC    F'256'\nPRINTILN DC    H'12',H'0'\nPRINTI   DC    CL8'PRINTI'\nPRINTALN DC    H'12',H'0'\nPRINTA   DC    CL8'PRINTA'\nPRINTMLN DC    H'12',H'0'\nPRINTM   DC    CL8'PRINTM'\nBLANKS   DC    256CL1' '\nZEROS    DC    4CL1'0'\nALIAS    DC    CL8' *ALIAS*'\nENDCHAIN DS    0F\n         DC    X'FF000000'\nMEMDATL  DC    X'00'                   SUBPOOL NUMBER\n         DC    AL3(1808)\nHALF0    DC    H'0'\nHALF1    DC    H'1'\nHALF2    DC    H'2'\nHALF4    DC    H'4'                                              ARAMCO\nHALF5    DC    H'5'\nHALF6    DC    H'6'\nHALF12   DC    H'12'\nHALF85   DC    H'85'\nHALF256  DC    H'256'\nHALF132  DC    H'132'                                              GTEL\nHALF208  DC    H'208'                                            ARAMCO\nHALF60   DC    H'60'                                             ARAMCO\nHALF120  DC    H'120'                                            ARAMCO\nPATCH    DC    C'PATCH AREA',20S(*)                                 WFB\nMSGCSECT DC    A(MESSAGES)             ADDRESS OF MESSAGE CSECT     WFB\nUDKRESET DC    H'14',H'0',CL10' =UDK={{+X'  DEFINE UDK THEN RESET   WFB\nUDKSET   DC    H'11',H'0',CL7' =UDK={'      DEFINE UDK              WFB\nUDKFHEAD DC    H'0',H'0',CL4' {+2'          SET FONT NAME #2        WFB\nUDKFSEL  DC    H'7',H'0',CL3' {2'           SELECT FONT #2          WFB\nNOMSG    EQU   X'04'                   FLAG IN BYTE VOLBIT          WFB\nUDKDONE  EQU   X'02'                   FLAG IN BYTE VOLBIT          WFB\nFORCEASA EQU   X'04'                   FLAG IN BYTE CCBIT           WFB\nHEXFF    EQU   X'FF'\nHIGH     EQU   X'80'\nLOW      EQU   X'01'\nMID1     EQU   X'10'                                               GTEL\nMID2     EQU   X'08'                                               GTEL\nJFCPDS   EQU   X'01'\nBLANK    EQU   X'40'\nHEX00    EQU   X'00'\nHEXF0    EQU   X'F0'\nHEXF1    EQU   X'F1'\nSCLSA    EQU   C'A'\nSKIPM    EQU   X'09'\nDSOPS    EQU   X'40'\nDSOPO    EQU   X'02'\nNOWTP    EQU   X'00'\n         SPACE 2\n****************** POINTER TO PARS PARAMETER CSECT ********************\nPCLADDR  DC    A(PARMTAB)\n         SPACE 2\n************************ PARS PARAMETER LIST **************************\nPARMTAB  IKJPARM  DSECT=IKJPARMD\nDSNAMES  IKJPOSIT  DSTHING,LIST,USID,                                  X\n               PROMPT='DSNAME, (LIST OF DSNAMES), OR * IF DDNAME(...) IX\n               S SPECIFIED',                                        WFBX\n               HELP=('THE NAME OF THE DATASET TO BE PRINTED, OR AN ASTEX\n               RISK IF A PREALLOCATED DDNAME IS TO BE USED.')       WFB\nPCLASS   IKJKEYWD\n         IKJNAME 'CLASS',SUBFLD=CLASSUB\nPDEST    IKJKEYWD\n         IKJNAME 'DEST',SUBFLD=DESTSUB\nPHOLD    IKJKEYWD\n         IKJNAME 'HOLD'\n         IKJNAME 'NOHOLD'\nPCOPIES  IKJKEYWD\n         IKJNAME 'COPIES',SUBFLD=COPYSUB\nPPRINT   IKJKEYWD\n         IKJNAME 'PRINT'\n         IKJNAME 'NOPRINT'\nPLIST    IKJKEYWD\n         IKJNAME 'LIST'\n         IKJNAME 'NOLIST'\nPHEAD    IKJKEYWD\n         IKJNAME 'NOHEADING'                                       GTEL\n         IKJNAME 'HEADING'                                         GTEL\nPVOL     IKJKEYWD\n         IKJNAME 'VOLUME',SUBFLD=VOLSUB\nPFOLD    IKJKEYWD\n         IKJNAME 'FOLD',ALIAS=('CAPS')\n         IKJNAME 'NOFOLD',ALIAS=('ASIS')\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** START OF GTEL MOD ************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nPSPACE   IKJKEYWD\n         IKJNAME 'SINGLESPACE',ALIAS=('SS','NOCC')                  WFB\n         IKJNAME 'DOUBLESPACE',ALIAS=('DS')                         WFB\nPFORMS   IKJKEYWD\n         IKJNAME  'FORMS',SUBFLD=SFORMS\nPTRAIN   IKJKEYWD\n         IKJNAME  'TRAIN',SUBFLD=STRAIN,ALIAS=('UCS')\nPFCB     IKJKEYWD\n         IKJNAME    'FCB',SUBFLD=SFCB\nPPROG    IKJKEYWD\n         IKJNAME    'PROG',SUBFLD=SPROG\nPTEXT    IKJKEYWD\n         IKJNAME    'TEXT',INSERT='UCS(TN) ASIS'\nPLINELEN IKJKEYWD\n         IKJNAME 'LINELENGTH',SUBFLD=SLINELEN,ALIAS=('LL')\nPPAGELEN IKJKEYWD\n         IKJNAME 'PAGELENGTH',SUBFLD=SPAGELEN,ALIAS=('PL')\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** END OF GTEL MOD **************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*---------------------------------------------------------------------*\n*------------------------- START OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\nPBURST   IKJKEYWD\n         IKJNAME  'BURST'\n         IKJNAME  'NOBURST'\nPFLASH   IKJKEYWD\n         IKJNAME  'FLASH',SUBFLD=SFLASH\nPCHARS   IKJKEYWD\n         IKJNAME  'CHARS',SUBFLD=SCHARS\n*---------------------------------------------------------------------*\n*--------------------------- END OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\nPUNIT    IKJKEYWD ,                                                 WFB\n         IKJNAME 'UNIT',SUBFLD=UNITSUB                              WFB\nPNOMSG   IKJKEYWD ,                                                 WFB\n         IKJNAME 'NOMSGS',ALIAS=('NOMESSAGES')                      WFB\nPDDNAME  IKJKEYWD ,                                                 WFB\n         IKJNAME 'DDNAME',ALIAS=('FILE'),SUBFLD=DDNSUB              WFB\nPASA     IKJKEYWD ,                                                 WFB\n         IKJNAME 'ASA'                                              WFB\nPUDKFONT IKJKEYWD ,                                                 WFB\n         IKJNAME 'UDKFONT',SUBFLD=UDKSUB                            WFB\n*\n*        B E G I N   S U B F I E L D S\nCLASSUB  IKJSUBF\nSCLASS   IKJIDENT 'CLASSNAME',LIST,FIRST=NONATNUM,MAXLNTH=1,           X\n               PROMPT='CLASS NAME'\nDESTSUB  IKJSUBF\nSDEST    IKJIDENT 'DESTINATION',MAXLNTH=17,                         WFBX\n               FIRST=ALPHANUM,OTHER=ANY,VALIDCK=VALDEST,            WFBX\n               PROMPT='DESTINATION FOR OUTPUT',                     WFBX\n               HELP=('WHERE TO PRINT OUTPUT. DESTINATION CAN BE: REMOTEX\n                LINE NUMBER, JES PRINTER NAME, OR NETWORK NODE AND USERX\n               ID')                                                 WFB\nCOPYSUB  IKJSUBF\nSCOPIES  IKJIDENT 'COPIES',MAXLNTH=3,                                  X\n               FIRST=NUMERIC,OTHER=NUMERIC,                            X\n               PROMPT='1-3 DIGITS - NUMBER OF COPIES OF OUTPUT',       X\n               HELP=('NUMBER OF COPIES OF PRINTOUT DESIRED')\nVOLSUB   IKJSUBF\nSVOL     IKJIDENT 'VOLUME',MAXLNTH=8,                                  X\n               FIRST=ALPHANUM,OTHER=ALPHANUM,                          X\n               PROMPT='VOLUME SERIAL FOR DATA SETS TO BE PRINTED',     X\n               HELP=('VOLUME SERIAL TO BE USED FOR ALL DATA SETS')\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** START OF GTEL MOD ************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nSFORMS   IKJSUBF\nRFORMS   IKJIDENT 'FORMS',MAXLNTH=4,FIRST=ALPHANUM,                    X\n               OTHER=ALPHANUM,                                         X\n               DEFAULT='$TST',                                      WFBX\n               HELP=('AN ALPANUMERIC STRING TO SPECIFY THE FORM')\nSTRAIN   IKJSUBF\nRTRAIN   IKJIDENT   'UCS',MAXLNTH=4,FIRST=ALPHANUM,                    X\n               OTHER=ALPHANUM,                                         X\n               PROMPT='UCS   DESIGNATION FOR PRINTED OUTPUT',          X\n               HELP=('AN ALPANUMERIC STRING TO SPECIFY THE TRAIN')\nSFCB     IKJSUBF\nRFCB     IKJIDENT 'FCB',MAXLNTH=4,FIRST=ALPHANUM,                      X\n               OTHER=ALPHANUM,                                         X\n               PROMPT='FCB DESIGNATION FOR PRINTED OUTPUT',            X\n               HELP=('AN ALPANUMERIC STRING TO SPECIFY THE FCB')\nSPROG    IKJSUBF\nRPROG    IKJIDENT 'PROG',MAXLNTH=8,FIRST=ALPHA,                        X\n               OTHER=ALPHANUM,                                         X\n               PROMPT='PROG DESIGNATION FOR PRINTED OUTPUT',           X\n               HELP=('AN ALPANUMERIC STRING TO SPECIFY THE PROG')\nSLINELEN IKJSUBF\nRLINELEN IKJIDENT 'LINELENGTH',MAXLNTH=3,FIRST=NUMERIC,                X\n               OTHER=NUMERIC,                                          X\n               PROMPT='LINESIZE, DEFAULT=132',                         X\n               HELP=('A LENGTH UP TO 208 FOR MAXIMUM PRINT WIDTH')\nSPAGELEN IKJSUBF\nRPAGELEN IKJIDENT 'PAGELENGTH',MAXLNTH=3,FIRST=NUMERIC,                X\n               OTHER=NUMERIC,                                          X\n               PROMPT='PAGELENGTH, DEFAULT=60',                        X\n               HELP=('A LENGTH UP TO 120 FOR PRINTER PAGE LENGTH')\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** END OF GTEL MOD **************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*---------------------------------------------------------------------*\n*------------------------- START OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\nSFLASH   IKJSUBF\nRFLASH   IKJIDENT 'FLASH',MAXLNTH=4,FIRST=ALPHANUM,                    X\n               OTHER=ALPHANUM,                                         X\n               PROMPT='FLASH DESIGNATION FOR PRINTED OUTPUT',          X\n               HELP=('FORMS OVERLAY FLASH NAME -- VALID FOR 3800 ONLY')\nSCHARS   IKJSUBF\nRCHARS   IKJIDENT 'CHARS',LIST,MAXLNTH=4,FIRST=ALPHA,                  X\n               OTHER=ANY,                                              X\n               PROMPT='CHARS DESIGNATION FOR PRINTED OUTPUT',          X\n               HELP=('A LIST OF 1 TO 4 CHARACTER SET NAMES -- VALID FORX\n                3800 ONLY')\n*---------------------------------------------------------------------*\n*--------------------------- END OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\nUNITSUB  IKJSUBF ,                                                  WFB\nSUNIT    IKJIDENT 'UNIT',MAXLNTH=8,                                 WFBX\n               FIRST=ALPHANUM,OTHER=ALPHANUM,                       WFBX\n               PROMPT='UNIT TYPE OF SPECIFIED VOLUME',              WFBX\n               HELP=('UNIT TYPE WHICH IS REQUIRED IF THE SPECIFIED VOLUX\n               ME IS NOT ACCESSIBLE THROUGH YOUR DEFAULT TSO UNIT VALUEX\n               ')                                                   WFB\nDDNSUB   IKJSUBF ,                                                  WFB\nSDDNAME  IKJIDENT 'DDNAME',MAXLNTH=8,                               WFBX\n               FIRST=ALPHA,OTHER=ALPHANUM,                          WFBX\n               PROMPT='DD NAME OF PREVIOUSLY ALLOCATED DATASET',    WFBX\n               HELP=('A FILE THAT WAS ALLOCATED EARLIER IN YOUR TSO SESX\n               SION','DDNAME IS IGNORED IF THE LAST OR ONLY DSNAME IS NX\n               OT AN ASTERISK')                                     WFB\nUDKSUB   IKJSUBF ,                                                  WFB\nSUDKFONT IKJIDENT 'UDK FONT NAME',ASIS,MAXLNTH=20,                  WFBX\n               FIRST=ALPHANUM,OTHER=ANY,                            WFBX\n               PROMPT='UDK FONT NAME',                              WFBX\n               HELP=('A FONT NAME FOR PRINTING ON A XEROX 2700 OR 3700'X\n               ,'THE NAME MUST BE ENTERED EXACTLY IN UPPER/LOWER CASE AX\n               S THE PRINTER EXPECTS IT')                           WFB\n         IKJENDP\n         SPACE 2\nMESSAGES CSECT ,                                                    WFB\n****************************** MESSAGES *******************************\nGNRLERR  DC    AL2(GNRLERRL),AL2(0)\n         DC    C'AN ERROR WAS ENCOUNTERED IN THE GENERAL FAIL SERVICE RX\n               OUTINE.  THE RETURN CODE FROM GNRLFAIL IS: '\nGNRLERRL EQU   *-GNRLERR\n*\nDRFLERR  DC    AL2(DRFLERRL),AL2(0)\n         DC    C'AN ERROR WAS ENCOUNTERED IN THE DAIR FAIL SERVICE ROUTX\n               INE.  THE RETURN CODE FROM DAIR FAIL IS: '\nDRFLERRL EQU   *-DRFLERR\n*\nOPENMSG  DC    AL2(OPENMSGL),AL2(0)\n         DC    C'OUPUT PROCESSING IS BEING TERMINATED.  AN ERROR WAS ENX\n               COUNTERED ATTEMPTING TO OPEN THE OUTPUT DATASET ASSOCIATX\n               ED WITH DDNAME: '\nOPENMSGL EQU   *-OPENMSG\n*\nDSNNOTP  DC    AL2(DSNNOTPL),AL2(0)\n         DC    C'AN ERROR OCCURRED AND YOUR DATASET WAS NOT PRINTED'\nDSNNOTPL EQU   *-DSNNOTP\n*\nDSNMSG   DC    AL2(DSNMSGL),AL2(0)\n         DC    C'PROCESSING HAS BEEN COMPLETED FOR DATASET: '\nDSNMSGL  EQU   *-DSNMSG\n*\nMEMMSG   DC    AL2(MEMMSGL),AL2(0)\n         DC    C' MEMBER: '\nMEMMSGL  EQU   *-MEMMSG\n*\nPRTMSG   DC    AL2(PRTMSGL),AL2(0)\n         DC    C'MEMBERS WILL NOW BE PRINTED FOR DATASET: '\nPRTMSGL  EQU   *-PRTMSG\n*\nNOTPSPO  DC    AL2(NOTPSPOL),AL2(0)\n         DC    C'DATASET IS NOT SEQUENTIAL OR PARTITIONED AND WAS NOT PX\n               RINTED.'\nNOTPSPOL EQU   *-NOTPSPO\n*\nSYNADI   DC    AL2(SYNADIL),AL2(0)\n         DC    C'A SYNAD ERROR OCURRED READING YOU INPUT DATASET AND ONX\n               LY PART OF YOUR DATASET MAY HAVE BEEN PRINTED.'\nSYNADIL  EQU   *-SYNADI\n*\nSYNADO   DC    AL2(SYNADOL),AL2(0)\n         DC    C'A SYNAD ERROR OCURRED WRITING THE OUTPUT DATASET AND NX\n               O MORE DATASETS WILL BE PRINTED.'\nSYNADOL  EQU   *-SYNADO\n*\n*DSNISU  DC    AL2(DSNISUL),AL2(0)\n*        DC    C'DATASET HAS UNDEFINED RECORD LENGTH AND WILL NOT BE PRX\n               INTED.'\n*DSNISUL EQU   *-DSNISU\n*\n*DSNISL  DC    AL2(DSNISLL),AL2(0)\n*        DC    C'DATASET HAS RECORD LENGTH GREATER THAN 256.'\n*DSNISLL EQU   *-DSNISL\n*                                                                ARAMCO\nCHARMSG  DC    AL2(CHARMSGL),AL2(0)                              ARAMCO\n         DC    C'MAX OF 4 CHAR SETS ALLOWED, REMAINDER IGNORED'  ARAMCO\nCHARMSGL EQU   *-CHARMSG                                         ARAMCO\n*                                                                   WFB\nNODSNDD  DC    AL2(NODSNDDL),AL2(0)                                 WFB\n         DC    C'NO INPUT SPECIFIED: AN ASTERISK DSNAME IMPLIES A DDNAMX\n               E WILL BE USED FOR INPUT, BUT NO DDNAME WAS GIVEN.'  WFB\nNODSNDDL EQU   *-NODSNDD                                            WFB\nNOTLAST  DC    AL2(NOTLASTL),AL2(0)                                 WFB\n         DC    C'AN ASTERISK DSNAME MUST BE THE LAST OR ONLY DSNAME SPEX\n               CIFIED FOR DDNAME TO BE PROCESSED.'                  WFB\nNOTLASTL EQU   *-NOTLAST                                            WFB\n         SPACE 2\n************************ DSECTS (MAPPING MACROS) **********************\nMEMDSECT DSECT\nMEMNTTR  DS    CL11\n         ORG   MEMNTTR\nMEMBER   DS    CL8\nMEMTTR   DS    CL3\nCFIELD   DS    CL1\nMEMSECTN EQU   *\n         IKJDAP08\nDAP08LEN EQU   *-DAPB08\n         IKJDAP18\nDAP18LEN EQU   *-DAPB18\n         IKJDAPL\nDAPLLEN  EQU   *-DAPL\n         IKJCPPL\nCPPLLEN  EQU   *-CPPL\n         IKJPPL\nPPLLEN   EQU   *-PPL\n         IKJIOPL\nIOPLLEN  EQU   *-IOPL\n         IHADSAB\nTIOEDDNM EQU   4           X'1C'(OFFSET) - X'18'(JOB STEP)\n         CVT   DSECT=YES                                            WFB\n         IEFZB4D0\n         IEFZB4D2\n         IKJDFPL                                                   GTEL\n         IKJDFPB                                                   GTEL\n         IKJUPT                                                  ARAMCO\nRBLEN    EQU   S99RBEND-S99RB\n         PRINT NOGEN\n         DCBD  DSORG=(PS,PO)\n         PRINT GEN\n         EJECT\n******************** CONSTANTS FOR DYNAMIC ALLOCATION *****************\nPRINTOFF CSECT\nREQBLKC  DC    AL1(S99RBEND-S99RB),AL1(S99VRBAL),18AL1(0)\nTEXTAC   DC    AL2(DALDDNAM),AL2(1),AL2(8),CL8'PRINT'  DDNAME\nTEXTALEN EQU   *-TEXTAC\nTEXTBC   DC    AL2(DALSYSOU),AL2(1),AL2(1),C'A'        SYSOUT CLASS\nTEXTBLEN EQU   *-TEXTBC\nTEXTCC   DC    AL2(DALSUSER),AL2(1),AL2(8),CL8'LOCAL'  DESTINATION\nTEXTCLEN EQU   *-TEXTCC\nTEXTDC   DC    AL2(DALSHOLD),AL2(0)                    SYSOUT HOLD\nTEXTDLEN EQU   *-TEXTDC\nTEXTEC   DC    AL2(DALCOPYS),AL2(1),AL2(1),AL2(1)      SYSOUT COPIES\nTEXTELEN EQU   *-TEXTEC\nTEXTFC   DC    AL2(DALPERMA),AL2(0)              PERM ALLOCATION\nTEXTFLEN EQU   *-TEXTFC\nTEXTGC   DC    AL2(DALFCBIM),AL2(1),AL2(4),CL4'STD.'  FCB          GTEL\nTEXTGLEN EQU   *-TEXTGC                                        GTEL WFB\nTEXTHC   DC    AL2(DALUCS),AL2(1),AL2(2),CL4'PN'      UCS          GTEL\nTEXTHLEN EQU   *-TEXTHC                                        GTEL WFB\nTEXTIC   DC    AL2(DALSFMNO),AL2(1),AL2(2),CL4'STD.'  FORMS        GTEL\nTEXTILEN EQU   *-TEXTIC                                        GTEL WFB\nTEXTJC   DC    AL2(DALSPGNM),AL2(1),AL2(8),CL8'PROG'  PROG         GTEL\nTEXTJLEN EQU   *-TEXTJC                                        GTEL WFB\nTEXTKC   DC    AL2(DALUSRID),AL2(1),AL2(8),CL8'USER'  USERID        WFB\nTEXTKLEN EQU   *-TEXTKC                                             WFB\nTEXTLC   DC    AL2(DINDDNAM),AL2(1),AL2(8),CL8' '   PREALLOC DDNAME WFB\nTEXTLLEN EQU   *-TEXTLC                                             WFB\nTEXTMC   DC    AL2(DINRTDSN),AL2(1),AL2(44),CL44' ' RETURNED DSNAME WFB\nTEXTMLEN EQU   *-TEXTMC                                             WFB\nTEXTNC   DC    AL2(DINRTMEM),AL2(1),AL2(8),CL8' '   RETURNED MEMBER WFB\nTEXTNLEN EQU   *-TEXTNC                                             WFB\nTEXTOC   DC    AL2(DINRTORG),AL2(1),AL2(2),XL2'0000' RETURNED DSORG WFB\nTEXTOLEN EQU   *-TEXTOC                                             WFB\n*                                                                   WFB\n**       VALIDITY CHECK ROUTINE FOR DESTINATION                     WFB\n***                                                                 WFB\n****     MAXIMUM LENGTH IS 17 CHARACTERS (ENFORCED BY PARSE)        WFB\n*****    DEST(NODE.USERID) MUST HAVE 1 PERIOD, EACH NAME 1-8 CHARS  WFB\n******   DEST(NAME) IF NO PERIOD, MAXIMUM LENGTH IS 8 CHARACTERS    WFB\n******                                                              WFB\n*****    AT ENTRY, REG 1 POINTS TO A THREE WORD LIST:               WFB\n****     +0  A(SDEST)   ADDRESS OF THE PDE BUILT BY PARSE           WFB\n***      +4  A(WORKAREA) ADDRESS OF USER WORK AREA FROM IKJPPL      WFB\n**       +8  A(VALMSG)  =F'0', ADDRESS OF USER SUPPLIED 2ND LVL MSG WFB\n*                                                                   WFB\nVALDEST  CSECT ,                                                    WFB\n         PUSH  USING                                                WFB\n         STM   R14,R12,12(13)          SAVE PARSE REGISTERS         WFB\n         LR    R12,R15                 USE REG 12 AS BASE           WFB\n         USING VALDEST,R12             ESTABLISH ADDRESSABILITY     WFB\n         LM    R8,R10,0(R1)            LOAD INPUT LIST VALUES       WFB\n         SR    R15,R15                 ASSUME ZERO RETURN CODE      WFB\n         STH   R15,NODELEN-WORKAREA(,R9)  ASSUME NOT NODE.USERID    WFB\n         L     R1,0(,R8)               GET ADDRESS OF DEST          WFB\n         LH    R3,4(,R8)               GET TOTAL LENGTH OF DEST     WFB\n         BCTR  R3,0                    DECREMENT LENGTH FOR TRT     WFB\n         EX    R3,VALTRT               LOOK FOR PERIOD OR INVALID   WFB\n         BZ    VALNODOT           CC=0 NOTHING FOUND, GO CHECK LEN  WFB\n         BM    VALCHECK           CC=1 FOUND IN MIDDLE, GO CHECK    WFB\n         B     VALRET4            CC=2 FOUND IN LAST BYTE - INVALID WFB\nVALNODOT CLI   5(R8),X'08'             NO PERIOD, LEN MUST BE 1-8   WFB\n         BNH   VALRETRN                YES, OK                      WFB\n         B     VALRET4                 NO, INVALID LENGTH           WFB\nVALCHECK CLI   0(R1),C'.'              PERIOD FOUND ?               WFB\n         BNE   VALRET4                 NO, INVALID CHARACTER        WFB\n         LA    R4,0(,R1)               GET ADDRESS OF PERIOD        WFB\n         SL    R4,0(,R8)               MINUS BEGIN DEST = LEN NODE  WFB\n         LA    R1,1(,R1)               POINT PAST PERIOD            WFB\n         SLR   R3,R4                   GET REMAINING LEN OF '.USER' WFB\n         BCTR  R3,0                    DECREMENT FOR PERIOD         WFB\n         EX    R3,VALTRT               LOOK FOR MORE PERIOD/INVALID WFB\n         BNZ   VALRET4                 FOUND, INVALID SPECIFICATION WFB\n         STH   R4,NODELEN-WORKAREA(,R9)  SAVE NODE LEN IN WORKAREA  WFB\n         B     VALRETRN                DONE                         WFB\nVALRET4  LA    R15,4                   SET RC 4 - INVALID DEST      WFB\nVALRETRN LM    R0,R12,20(R13)          RESTORE PARSE REGISTERS      WFB\n         L     R14,12(,R13)            RESTORE RETURN ADDRESS       WFB\n         BR    R14                     RETURN TO PARSE              WFB\n*                                                                   WFB\nVALTRT   TRT   0(0,R1),VALTABLE        ** EXECUTED **               WFB\nVALTABLE DC    256AL1(*-VALTABLE)      TABLE OF VALID CHARACTERS    WFB\n         ORG   VALTABLE+C'$'                                        WFB\n         DC    X'00'                   ALLOW $                      WFB\n         ORG   VALTABLE+C'#'                                        WFB\n         DC    2X'00'                  ALLOW # @                    WFB\n         ORG   VALTABLE+C'A'                                        WFB\n         DC    9X'00'                  ALLOW A B C D E F G H I      WFB\n         ORG   VALTABLE+C'J'                                        WFB\n         DC    9X'00'                  ALLOW J K L M N O P Q R      WFB\n         ORG   VALTABLE+C'S'                                        WFB\n         DC    8X'00'                  ALLOW S T U V W X Y Z        WFB\n         ORG   VALTABLE+C'0'                                        WFB\n         DC    10X'00'                 ALLOW 0 1 2 3 4 5 6 7 8 9    WFB\n         ORG   ,                                                    WFB\n         DROP  R12                                                  WFB\n         POP   USING                                                WFB\n*********************** DSECT FOR DYNAMIC WORKAREA ********************\nWORKAREA DSECT\nSAVEAREA DS    18F\nALCSAVE  DS    12F\n         DS    0D\nDEC      DS    2F\nRETNCD   DS    F\nCONV     DS    2F\nIOPB     PUTLINE MF=L\nDAP08    DS    0F\n         ORG   DAP08+DAP08LEN\nDAP18    DS    0F\n         ORG   DAP18+DAP18LEN\nDAPLSECT DS    0F\n         ORG   DAPLSECT+DAPLLEN\nPPLSECT  DS    0F\n         ORG   PPLSECT+PPLLEN\nIOPLSECT DS    0F\n         ORG   IOPLSECT+IOPLLEN\nDFPLSECT DS    4F                   SPACE FOR DFPL                 GTEL\nDFPBSECT DS    5F                   SPACE FOR DFPB                 GTEL\n         DS    H                    TO GET ALLIGNMENT              GTEL\nDFPBDSL  DS    H                    DSNAME LENGTH                  GTEL\nDFPBNAME DS    CL44                 DSNAME                         GTEL\nDFPBQUA  DS    CL8\nECB      DS    F\nPARSBACK DS    F\nLINE     DS    0H\nLENGTH   DS    H\n         DS    H\nCNTLBYTE DS    CL1\nDATA     DS    CL256\nHEADER2  DS    CL13                                              ARAMCO\nDSNAME   DS    CL44\nOPENPRN  DS    CL1\nMEMNAME  DS    CL8\nCLOSEPRN DS    CL1\nVOLHEAD  DS    CL11                 C'   VOLUME: ' ON HEADING       WFB\nVOLNAME  DS    CL8                                                  WFB\n         ORG   DSNAME-4\nDSNLENP  DS    CL2\nDSNLEN   DS    CL2\nDSNBUF   DS    CL44\n         ORG   MEMNAME-4\nMEMNAMEL DS    CL2\n         ORG\nHEADER   DS    CL75                 (WAS 49 BEFORE DATE)     ARAMCO WFB\n         ORG   HEADER+4\nHDRCNTL  DS    CL1\n         ORG   HEADER+41                                            WFB\nHDRTIME  DS    CL12                 4 BYTE PREFIX, HH:MM:SS         WFB\nHDRDATE  DS    CL22                 4 BYTE PREFIX, MONTHNAME DY, YR WFB\nHDRTDLEN EQU   *-HDRTIME                                            WFB\nDFID     DS    CL2\n         ORG\nVOLBIT   DS    CL1\nVOLUME   DS    CL8\nUNIT     DS    CL8                  UNIT() VALID ONLY WITH VOL()    WFB\nPREALDDN DS    CL8                  PREALLOCATED DDNAME(...)        WFB\nNODELEN  DS    H                    LEN OF NODE IN DEST(NODE.USER)  WFB\nCALLMFL  CALL  ,(,),MF=L            LIST FORM FOR CALL IKJEFLPA     WFB\nMEMTABLE DS    F\nENDTABLE DS    F\nCURRENT  DS    F\nPRESENT  DS    F\nCOLUMN   DS    F\nXLIST    DS    F\nLINELEN  DS    H                                                   GTEL\nVBLEN    DS    H                                                   GTEL\nPAGELEN  DS    H                                                   GTEL\nCCBIT    DS    CL1                                                 GTEL\nALNDSECT DS    F                                                   GTEL\nRDJL     RDJFCB (,),MF=L\nJFCBAREA DS    44F\n         ORG   JFCBAREA+44\nJFCBELNM DS    CL8\n         ORG   JFCBAREA+86\nJFCBIND1 DS    CL1\n         ORG   JFCBAREA+98\nJFCDSRG1 DS    CL1\n         ORG\nSAVER6   DS    F\nSAVER2   DS    2F\nSAVER3   DS    2F\nSAVMR2   DS    2F                                                  GTEL\nSAVMR6   DS    2F                                                  GTEL\nSAVMR9   DS    2F                                                  GTEL\n*\n         PRINT NOGEN\n*\nINPUT    DCB   DSORG=PS,MACRF=(GM),EODAD=EXITI,SYNAD=ERRI,DDNAME=PRINTI\n*\nOUTPUTA  DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=PRINTA,RECFM=VBA, X\n               LRECL=256,BLKSIZE=3120\n*\nOUTPUTM  DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=PRINTM,RECFM=VBM, X\n               LRECL=256,BLKSIZE=3120\n*\nDIRECT   DCB   DDNAME=PRINTI,DSORG=PS,MACRF=(GM),RECFM=U,BLKSIZE=256,  X\n               SYNAD=SERRI,EODAD=FREEBLK\n*\nOPENLST  OPEN  (,),MF=L\n*\nCLOSLST  CLOSE (,),MF=L\n*\n*\n         PRINT GEN\n*\nRETCODE  DS    F\nGFPARMP  DS    F\n         IKJEFFGF\n         IKJEFFDF\nRBPTR    DS    F\nREQBLK   DS    10F                                                 GTEL\nTEXTPTRS DS    16F                                             GTEL WFB\nTEXTA    DS    0F                                   DDNAME\n         ORG   TEXTA+TEXTALEN\nTEXTB    DS    0F                                   SYSOUT CLASS\n         ORG   TEXTB+TEXTBLEN\nTEXTC    DS    0F                                   DESTINATION\n         ORG   TEXTC+TEXTCLEN\nTEXTE    DS    0F                                   SYSOUT COPIES\n         ORG   TEXTE+TEXTELEN\nTEXTG    DS    0F                                   FCB            GTEL\n         ORG   TEXTG+TEXTGLEN                                      GTEL\nTEXTH    DS    0F                                   UCB            GTEL\n         ORG   TEXTH+TEXTHLEN                                      GTEL\nTEXTI    DS    0F                                   FORMS          GTEL\n         ORG   TEXTI+TEXTILEN                                      GTEL\nTEXTJ    DS    0F                                   PROG           GTEL\n         ORG   TEXTJ+TEXTJLEN                                      GTEL\nTEXTK    DS    0F                                   USERID          WFB\n         ORG   TEXTK+TEXTKLEN                                       WFB\nTEXTL    DS    0F                                   PREALLOC DDNAME WFB\n         ORG   TEXTL+TEXTLLEN                                       WFB\nTEXTM    DS    0F                                   RETURNED DSNAME WFB\n         ORG   TEXTM+TEXTMLEN                                       WFB\nTEXTN    DS    0F                                   RETURNED MEMBER WFB\n         ORG   TEXTN+TEXTNLEN                                       WFB\nTEXTO    DS    0F                                   RETURNED DSORG  WFB\n         ORG   TEXTO+TEXTOLEN                                       WFB\n*---------------------------------------------------------------------*\n*------------------------- START OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\nSETFLAG  DS    X\nSETBURST EQU   1\nSETFLSH  EQU   2\nSETCHAR  EQU   4\nSETPRTE  SETPRT OUTPUTA,,MF=L\nSETFLASH EQU   SETPRTE+28\nSETCHARS EQU   SETPRTE+32\nSETPRTEL EQU   *-SETPRTE\nSAVEUPT  DS    X\n*---------------------------------------------------------------------*\n*--------------------------- END OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\nLDYNAMIC EQU   *-WORKAREA\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*********************** DSECT FOR RECORD MAPPING **********************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nLINDSECT DSECT\nRECORD   DS    0F\nRECLEN   DS    H\n         DS    H\nRECCC    DS    CL1\nRECDATA  DS    CL32760                                              WFB\nRECSIZE  EQU   *-RECORD                                             WFB\n*********************** END OF RECORD MAPPING DSECT *******************\n         AGO   .ENDHELP                SKIP AROUND HELP ENTRY      WFB\n)F Function -\n   The PRINTOFF command creates a printed copy of data sets through\n   foreground copying to SYSOUT.  The command prints datasets which\n   are sequential or partitioned, blocked or unblocked, with fixed,\n   variable, or undefined length records of any length up to 32,760.\n)X Syntax -\n   PRINTOFF (dslist)/*  DDNAME(ddname)/FILE(ddname)\n            UNIT(unit-type)  VOLUME(volser)     NOMESSAGES/NOMSGS\n            CLASS(class)     DEST(destination)  COPIES(nnn)\n            HOLD/NOHOLD      LIST/NOLIST        PRINT/NOPRINT\n            FORMS(form)      FCB(fcb)           TRAIN(image)/UCS(image)\n            HEADING/NOHEADING                   CAPS/ASIS/FOLD/NOFOLD\n            NOCC/SINGLESPACE/SS/DOUBLESPACE/DS  ASA\n            LINELENGTH(nnn)/LL(nnn)             PAGELENGTH(nnn)/PL(nnn)\n            BURST/NOBURST    FLASH(flash-name)  CHARS(charset-name(s))\n            PROG(progname)   UDKFONT(font-name)\n   Required -- dslist or * if DDNAME(...)\n   Aliases  -- PRINTO, PO\n   Defaults -- CLASS(A), COPIES(1), NOHOLD, LIST, PRINT, FORM($TST),\n               HEADING, ASIS, LINELENGTH(132), PAGELENGTH(60), NOBURST,\n               SINGLESPACE if PAGELENGTH(...) or if input RECFM not A/M\n)O Operands -\n)P DSLIST - Data set list contains the names of data sets to be printed\n            or punched.  The names should follow TSO convention, in\n            quotes if the primary index differs from your profile\n            prefix, or without quotes and with the primary index\n            omitted if it is the same as your profile prefix.\n            Enclosing parenthesis are required if there is more than\n            one name in the list.\n              If DDNAME(...) is specified, the dslist must end with an\n            asterisk (or contain only an asterisk) as a place holder.\n))ASA     - Output is to be printed using input data column 1 as ASA\n            carriage control characters even though the DCB record\n            format does not specify RECFM=..A\n))ASIS    - Output is not to be converted to upper case prior to\n            printing. (It is left as it is.)\n            NOFOLD is an alias for ASIS.\n))BURST   - Output is to be trimmed and burst. ===> VALID FOR 3800 ONLY\n))NOBURST - Output will be printed on continuous forms.\n))CAPS    - Output is to be converted to upper case prior to\n            printing. FOLD is an alias for CAPS.\n))CHARS(charset-name(s)) - Character set(s) to be used to print the\n            output. (1-4 names, each name 1-4 characters.)  If more\n            than one character set name is given, the input data should\n            have the character set id specified in the second character\n            of each line. OPTCD=J is assumed. See the JCL reference\n            manual for more information. ===> VALID FOR 3800 ONLY\n))CLASS(class) - SYSOUT class in which output is to be printed.\n            Default is A.\n))COPIES(nnn) - Number of copies to be printed.  Default is 1.\n))DEST(destination) - The destination to where SYSOUT is to be routed.\n            Destination can be a JES remote line, a JES local or remote\n            printer, or a network node and userid. Local and remote\n            names are 1-8 characters. Network names are 3-17 characters\n            (node.userid) with the period required as a separator.\n            DEST(node.userid) is mutually exclusive with\n            PROG(progname).\n))DDNAME(ddname) - DD name of a previously allocated dataset. If DDNAME\n            is specified, the last (or only) dataset name in dslist\n            must be an asterisk. The DD will not be freed after being\n            printed. FILE is an alias for DDNAME.\n))FCB(fcb) - Forms Control Buffer to be used when the data set is\n            printed.  (1-4 character FCB name)\n))FLASH(flashname) - The name of the forms flash overlay which is to be\n            flashed on all output. ===> VALID FOR 3800 ONLY\n))FORMS(form) - Form to be used when the data set is printed.\n            Default is $TST. (1-4 character form name)\n))HEADING - Output is to have a heading containing the data set name.\n))NOHEADING - Output is not to have heading information.\n))HOLD    - Output is to be placed on a hold queue upon deallocation.\n))NOHOLD  - Output is not to be placed on a hold queue upon\n            deallocation.\n))LINELENGTH(nnn) - Number of characters on each line of printed\n            output. (1-208 characters with a default of 132.)  Input\n            lines longer than specified linelength will be printed on\n            multiple lines.  LL(...) is an alias for LINELENGTH(...).\n))LIST    - A separate listing of member names processed is to be\n            created and printed with the data set output.\n))NOLIST  - No list of member names is to be created.\n))NOMESSAGES - Non-error messages are not to be written to the TSO\n            terminal. NOMSGS is an alias of NOMESSAGES. The default is\n            to write informational messages to the terminal before and\n            after printing.\n))PAGELENGTH(nnn) - Number of lines per page.  (1-120 lines with a\n            default of 60.)  Carriage control in input records is\n            ignored (even if ASA is specified) and SINGLESPACE is used.\n            PL(...) is an alias for PAGELENGTH(...).\n))PRINT   - Members are to be printed. (Whether they are also listed\n            is controlled by LIST/NOLIST.)\n))NOPRINT - Members are not to be printed. (Whether they are to be\n            listed is controlled by LIST/NOLIST.)\n))PROG(progname) - The name of the special 'external writer' program\n            that is to process the output. PROG(progname) is mutually\n            exclusive with DEST(node.userid).\n))TRAIN(image) - Print image to be used when the data set is printed.\n            UCS is an alias for TRAIN. (1-4 character print image name)\n))UCS(image) - Print image to be used when the data set is printed.\n            UCS is an alias for TRAIN. (1-4 character print image name)\n))SINGLESPACE - Output is to be single spaced.  Carriage control in\n            input data is ignored even if ASA is specified.\n            NOCC and SS are aliases for SINGLESPACE.\n))DOUBLESPACE - Output is to be double spaced between lines.  Carriage\n            control in input data is ignored even if ASA is specified.\n            DS is an alias for DOUBLESPACE.  (Multiple line records\n            will not be split between pages.)\n))UNIT(unit-type) - Unit type of the specified VOLUME(volser). UNIT is\n            ignored if VOLUME is not also specified. UNIT is required\n            only when the dataset is not cataloged, or when the dataset\n            is cataloged to a different volume than the specified\n            VOLUME and the volume cannot be accessed through your TSO\n            default unit type.\n))VOLUME(volser) - Volume serial of volume on which data sets to be\n            printed are found.  This volume serial will be used for all\n            data sets specified in the data set list.\n))UDKFONT(font-name) - Output is intended to be printed on a XEROX 2700\n            or 3700.  PRINTOFF will insert Xerox User Defined Key (UDK)\n            statements in the output to select the specified font.  No\n            validation is performed on the font name before it is sent\n            to the printer, so the full font name must be specified in\n            upper/lower case exactly as expected by the XEROX printer.\n            (PRINTOFF uses the left brace character, {, hex C0, as the\n            UDK.  Input data containing this character will be\n            interpreted by the printer as a Xerox command, and may\n            produce undesired results.)\n.ENDHELP ANOP                          ,                            SL\n         END\nIKJEFLPA CSECT                                                          00000 00\n         B     18(,R15)                47F0 F012         *.00.*         00000 00\n         DC    X'0D',C'I'              0DC9              *.I*           00004 00\n         DC    C'KJEFLPA7'             D2D1C5C6D3D7C1F7  *KJEFLPA7*     00006 00\n         DC    C'0166'                 F0F1F6F6          *0166*         0000E 00\n         STM   R14,R12,12(R13)         90EC D00C         *..}.*         00012 00\n         BALR  R11,R0                  05B0              *..*           00016 00\n         L     R0,424(,R11)            5800 B1A8         *...y*         00018 00\n         BAL   R1,8(,R11)              4510 B008         *....*         0001C 00\n         SVC   10      GETMAIN         0A0A              *..*           00020 00\n         LR    R12,R1                  18C1              *.A*           00022 00\n         LM    R0,R1,20(R13)           9801 D014         *q.}.*         00024 00\n         XC    84(1,R12),84(R12)       D700 C054 C054    *P.{.{.*       00028 00\n         ST    R13,4(,R12)             50D0 C004         *&}{.*         0002E 00\n         LA    R15,0(,R12)             41F0 C000         *.0{.*         00032 00\n         ST    R15,8(,R13)             50F0 D008         *&0}.*         00036 00\n         LR    R13,R15                 18DF              *..*           0003A 00\n         LA    R1,2                    4110 0002         *....*         0003C 00\n         SVC   11      TIME            0A0B              *..*           00040 00\n         ST    R0,80(,R12)             5000 C050         *&.{&*         00042 00\n         L     R8,4(,R13)              5880 D004         *..}.*         00046 00\n         L     R8,24(,R8)              5880 8018         *....*         0004A 00\n         L     R2,0(,R8)               5820 8000         *....*         0004E 00\n         L     R9,420(,R11)            5890 B1A4         *...u*         00052 00\n         LR    R3,R9                   1839              *..*           00056 00\n         MVO   72(4,R12),80(3,R12)     F132 C048 C050    *1.{.{&*       00058 00\n         UNPK  6(6,R2),72(4,R12)       F353 2006 C048    *3...{.*       0005E 00\n         MVZ   11(1,R2),6(R2)          D300 200B 2006    *L.....*       00064 00\n         MVC   0(2,R2),404(R11)        D201 2000 B194    *K....m*       0006A 00\n         MVC   4(2,R2),6(R2)           D201 2004 2006    *K.....*       00070 00\n         MVC   6(1,R2),1(R3)           D200 2006 3001    *K.....*       00076 00\n         MVC   7(2,R2),8(R2)           D201 2007 2008    *K.....*       0007C 00\n         MVC   9(1,R2),1(R3)           D200 2009 3001    *K.....*       00082 00\n         ST    R1,80(,R12)             5010 C050         *&.{&*         00088 00\n         L     R2,4(,R8)               5820 8004         *....*         0008C 00\n         XC    72(6,R12),72(R12)       D705 C048 C048    *P.{.{.*       00090 00\n         MVC   78(2,R12),82(R12)       D201 C04E C052    *K.{+{.*       00096 00\n         CVB   R4,72(,R12)             4F40 C048         *| {.*         0009C 00\n         MVO   78(2,R12),81(1,R12)     F110 C04E C051    *1.{+{.*       000A0 00\n         CVB   R5,72(,R12)             4F50 C048         *|&{.*         000A6 00\n         LA    R7,1                    4170 0001         *....*         000AA 00\n         CH    R4,12(,R3)              4940 300C         *. ..*         000AE 00\n         BC    12,238(,R11)            47C0 B0EE         *.{..*         000B2 00\n         LR    R14,R5                  18E5              *.V*           000B6 00\n         SRDA  R14,32                  8EE0 0020         *.\\..*         000B8 00\n         LA    R0,4                    4100 0004         *....*         000BC 00\n         DR    R14,R0                  1DE0              *.\\*           000C0 00\n         LR    R5,R14                  185E              *.;*           000C2 00\n         LTR   R5,R5                   1255              *..*           000C4 00\n         BNZ   180(,R11)               4770 B0B4         *....*         000C6 00\n         BCTR  R4,R0                   0640              *. *           000CA 00\n         AH    R7,406(,R11)            4A70 B196         *\u00a2..o*         000CC 00\n         CH    R7,408(,R11)            4970 B198         *...q*         000D0 00\n         BH    224(,R11)               4720 B0E0         *...\\*         000D4 00\n         LR    R1,R7                   1817              *..*           000D8 00\n         MH    R1,410(,R11)            4C10 B19A         *<...*         000DA 00\n         CH    R4,6(R1,R3)             4941 3006         *....*         000DE 00\n         BH    180(,R11)               4720 B0B4         *....*         000E2 00\n         CH    R7,412(,R11)            4970 B19C         *....*         000E6 00\n         BNE   224(,R11)               4770 B0E0         *...\\*         000EA 00\n         LTR   R5,R5                   1255              *..*           000EE 00\n         BNZ   224(,R11)               4770 B0E0         *...\\*         000F0 00\n         AH    R4,406(,R11)            4A40 B196         *\u00a2 .o*         000F4 00\n         LR    R1,R7                   1817              *..*           000F8 00\n         MH    R1,410(,R11)            4C10 B19A         *<...*         000FA 00\n         LH    R15,0(R1,R3)            48F1 3000         *.1..*         000FE 00\n         LCR   R15,R15                 13FF              *..*           00102 00\n         AR    R4,R15                  1A4F              *.|*           00104 00\n         LR    R1,R7                   1817              *..*           00106 00\n         MH    R1,410(,R11)            4C10 B19A         *<...*         00108 00\n         LH    R5,8(R1,R3)             4851 3008         *....*         0010C 00\n         LH    R15,10(R1,R3)           48F1 300A         *.1..*         00110 00\n         LA    R0,0(,R3)               4100 3000         *....*         00114 00\n         AR    R15,R0                  1AF0              *.0*           00118 00\n         LR    R6,R15                  186F              *.?*           0011A 00\n         LR    R14,R6                  18E6              *.W*           0011C 00\n         LR    R7,R5                   1875              *..*           0011E 00\n         BCTR  R7,R0                   0670              *..*           00120 00\n         LA    R10,4(,R2)              41A0 2004         *....*         00122 00\n         EX    R7,414(,R11)            4470 B19E         *....*         00126 00\n         LA    R7,1                    4170 0001         *....*         0012A 00\n         AR    R7,R5                   1A75              *..*           0012E 00\n         LA    R6,3(R7,R2)             4167 2003         *....*         00130 00\n         MVC   0(1,R6),3(R3)           D200 6000 3003    *K.-...*       00134 00\n         CVD   R4,72(,R12)             4E40 C048         *+ {.*         0013A 00\n         MVC   75(2,R12),78(R12)       D201 C04B C04E    *K.{.{+*       0013E 00\n         MVO   78(2,R12),81(1,R12)     F110 C04E C051    *1.{+{.*       00144 00\n         MVO   77(2,R12),0(1,R3)       F110 C04D 3000    *1.{(..*       0014A 00\n         CLI   75(R12),X'00'           9500 C04B         *n.{.*         00150 00\n         BNE   348(,R11)               4770 B15C         *...**         00154 00\n         UNPK  1(7,R6),76(4,R12)       F363 6001 C04C    *3.-.{<*       00158 00\n         LA    R15,12                  41F0 000C         *.0..*         0015E 00\n         AR    R15,R5                  1AF5              *.5*           00162 00\n         ST    R15,84(,R12)            50F0 C054         *&0{.*         00164 00\n         MVC   0(2,R2),86(R12)         D201 2000 C056    *K...{.*       00168 00\n         BCTR  R6,R0                   0660              *.-*           0016E 00\n         B     370(,R11)               47F0 B172         *.0..*         00170 00\n         UNPK  1(8,R6),75(5,R12)       F374 6001 C04B    *3.-.{.*       00174 00\n         LA    R15,13                  41F0 000D         *.0..*         0017A 00\n         AR    R15,R5                  1AF5              *.5*           0017E 00\n         ST    R15,84(,R12)            50F0 C054         *&0{.*         00180 00\n         MVC   0(2,R2),86(R12)         D201 2000 C056    *K...{.*       00184 00\n         MVC   3(2,R6),2(R3)           D201 6003 3002    *K.-...*       0018A 00\n         MVZ   8(1,R6),2(R6)           D300 6008 6002    *L.-.-.*       00190 00\n         L     R13,4(,R13)             58D0 D004         *.}}.*         00196 00\n         LR    R1,R12                  181C              *..*           0019A 00\n         L     R0,424(,R11)            5800 B1A8         *...y*         0019C 00\n         LA    R1,0(R1)                4111 0000         *....*         001A0 00\n         SVC   10      FREEMAIN        0A0A              *..*           001A4 00\n         LM    R14,R12,12(R13)         98EC D00C         *q.}.*         001A6 00\n         BR    R14                     07FE              *..*           001AA 00\n         DC    X'000C0001000B0006'     000C0001000B0006  *........*     001AC 00\n         DC    X'0002'                 0002              *..*           001B4 00\n         DC    C'K',X'00'              D200              *K.*           001B6 00\n         DC    X'A000E000'             A000E000          *..\\.*         001B8 00\n         DC    VL4(IKJEFLPB)           00003060          *...-*         001BC 00\n         DC    X'0100005870145810'     0100005870145810  *........*     001C0 00\n         YREGS\n         END\nIKJEFLPB CSECT                                                          00000 00\n         DC    X'20',C':'              207A              *.:*           00000 00\n         DC    C', '                   6B40              *, *           00002 00\n         LPR   R3,R4                   1034              *..*           00004 00\n         ST    R15,144(,R13)           50F0 D090         *&0}.*         00006 00\n         LA    R15,31                  41F0 001F         *.0..*         0000A 00\n         DC    X'00070054003B0008'     00070054003B0008  *........*     0000E 00\n         DC    X'005B005A00050063'     005B005A00050063  *.$.!....*     00016 00\n         DC    X'0078000500680097'     0078000500680097  *.......p*     0001E 00\n         DC    X'0003006D00B50004'     0003006D00B50004  *..._....*     00026 00\n         DC    X'007000D400040074'     007000D400040074  *...M....*     0002E 00\n         DC    X'00F3000600780111'     00F3000600780111  *.3......*     00036 00\n         DC    X'0009007E01300007'     0009007E01300007  *...=....*     0003E 00\n         DC    X'0087014E0008008E'     0087014E0008008E  *.g.+....*     00046 00\n         DC    X'016D00080096'         016D00080096      *._...o*       0004E 00\n         DC    C'JANUARYF'             D1C1D5E4C1D9E8C6  *JANUARYF*     00054 00\n         DC    C'EBRUARYM'             C5C2D9E4C1D9E8D4  *EBRUARYM*     0005C 00\n         DC    C'ARCHAPRI'             C1D9C3C8C1D7D9C9  *ARCHAPRI*     00064 00\n         DC    C'LMAYJUNE'             D3D4C1E8D1E4D5C5  *LMAYJUNE*     0006C 00\n         DC    C'JULYAUGU'             D1E4D3E8C1E4C7E4  *JULYAUGU*     00074 00\n         DC    C'STSEPTEM'             E2E3E2C5D7E3C5D4  *STSEPTEM*     0007C 00\n         DC    C'BEROCTOB'             C2C5D9D6C3E3D6C2  *BEROCTOB*     00084 00\n         DC    C'ERNOVEMB'             C5D9D5D6E5C5D4C2  *ERNOVEMB*     0008C 00\n         DC    C'ERDECEMB'             C5D9C4C5C3C5D4C2  *ERDECEMB*     00094 00\n         DC    C'ER'                   C5D9              *ER*           0009C 00\n         YREGS\n         END\n//LKED.SYSLIN  DD *\n INCLUDE SYSLIBX\n ORDER   PRINTOFF,PARMTAB,MESSAGES,VALDEST,IKJEFLPA,IKJEFLPB\n SETSSI  CB487325\n MODE    RMODE(24),AMODE(24)\n SETCODE AC(1)\n ENTRY   PRINTOFF\n ALIAS   PO,PRINTO,PRINTOFF\n NAME    PROFF(R)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PRINTOLD": {"ttr": 5633, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87(\\x7f\\x00\\x87(\\x7f\\x12\\x00\\n\\x90\\n\\x90\\x00\\x00\\xd6\\xd3\\xc4\\xe5\\xc5\\xd9\\xe2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-10-14T00:00:00", "modifydate": "1987-10-14T12:00:00", "lines": 2704, "newlines": 2704, "modlines": 0, "user": "OLDVERS"}, "text": "*\n*  NOTE TO FUTURE ASSEMBLERS ... PRINTOFF NORMALLY RESIDES IN\n*  A LINKLIB WITH  A L I A S E S  PRINTO AND PO.\n*  THE HELP ENTRY SHOULD BE ASSIGNED THE SAME ALIASES.\n*\nPRINTOFF TITLE 'IPO-SUPPLIED PRINT COMMAND - MODIFIED BY GTEL, ARAMCO, C\n               WFB      '                                           WFB\n***********************************************************************\n*                                                                     *\n*             MODULE NAME = PRINTOFF                                  *\n*                                                                     *\n*             DESCRIPTIVE NAME =  IPO SUPPLIED PRINT COMMAND FOR      *\n*                TSO FOREGROUND EXECUTION                             *\n*                                                                     *\n*             COPYRIGHT = NONE                                        *\n*                                                                     *\n*             STATUS = RELEASE 01.0 OF IPO                            *\n*                                                                     *\n*             FUNCTION =                                              *\n*                PRINTS A DATASET(S) WHICH IS SEQUENTIAL OR PARTIONED *\n*                ALLOWING THE USER TO SPECIFY OUTPUT CLASS, COPIES,   *\n*                DESTINATION AND HOLD/NOHOLD.  ALSO ALLOWS THE USER   *\n*                TO SPECIFY LIST/NOLIST, PRINT/NOPRINT, VOLUME,       *\n*                FOLD/NOFOLD, DS/SS, LINELENGTH AND PAGELENGTH     GTEL\n*                LIST IF PDS MEMBER NAMES ARE ONLY TO BE LISTED.      *\n*                PRINT IF PDS MEMBERS ARE ONLY TO BE PRINTED.         *\n*                SEE 'CHANGE ACTIVITY' FOR ADDITIONAL OPTIONS.      WFB\n*                                                                     *\n*                OPERATION =                                          *\n*                   BUILD PARS, DAIR, AND PUTLINE PARAMETER LISTS.    *\n*                   CALL PARS TO PARSE COMMAND BUFFER.                *\n*                   ALLOCATE DATASET AND DETERMINE IF PDS OR          *\n*                      SEQUENTIAL.                                    *\n*                   DETERMINE WHAT FUNCTIONS WERE TO BE PERFORMED     *\n*                      FOR THIS DATASET IF PDS.                       *\n*                   ALLOCATE SYSOUT DATASETS WHEN SOMETHING IS        *\n*                      FOUND TO BE PRINTED.                           *\n*                   PROCESS NEXT DATASET IN LIST.                     *\n*                   AT END OF LIST CLOSE DATASETS AND FREE ANY        *\n*                      SYSOUT DATASETS AND INPUT DATASETS.         GTEL\n*                   DATSETS WILL BE PRINTED AS EITHER VBA OR VBM.     *\n*                                                                     *\n*              NOTES =                                                *\n*                                                                     *\n*                 DEPENDENCIES = CHARACTER SET IS EBCDIC.  REASSEMBLE *\n*                    IF A DIFFERENT CHARACTER SET IS NEEDED.          *\n*                                                                     *\n*                                                                     *\n*                 RESTRICTIONS = DATASETS MUST HAVE LRECL NOT       WFB\n*                    GREATER THAN 32,760 AND MUST NOT               WFB\n*                    CONTAIN SPANNED RECORDS.  IN ADDITION,        GTEL\n*                    IF PAGELEN, DS, OR SS IS SPECIFIED, ALL       GTEL\n*                    OTHER CARRIAGE CONTROL WILL BE IGNORED.       GTEL\n*                                                                     *\n*                 REGISTER CONVENTIONS = STANDARD CONVENTIONS.        *\n*                    REGISTERS 0 TO 10 = WORK REGISTERS               *\n*                    REGISTERS 11,12   = ADDRESSIBILITY TO         GTEL\n*                                        PRINTOFF CSECT            GTEL\n*                    REGISTER  13      = SAVE AREA REGISTER AND       *\n*                                        ADDRESSABILITY TO GETMAINED  *\n*                                        WORK AREA                    *\n*                    REGISTERS 14,15   = WORK REGISTERS               *\n*                                                                     *\n*                PATCH LABEL = PATCH, UNUSED AND INTIALIZED TO        *\n*                   DC 20S(*)                                      WFB*\n*                                                                     *\n*                TSO COMMAND SYNTAX                                 WFB\n* PRINTOFF (DSLIST)/*  DDNAME(DDNAME)/FILE(DDNAME)                    *\n*          UNIT(UNIT-TYPE)  VOLUME(VOLSER)     NOMESSAGES/NOMSGS      *\n*          CLASS(CLASS)     DEST(DESTINATION)  COPIES(NNN)            *\n*          HOLD/NOHOLD      LIST/NOLIST        PRINT/NOPRINT          *\n*          FORMS(FORM)      FCB(FCB)           TRAIN(IMAGE)/UCS(IMAGE)*\n*          HEADING/NOHEADING                   CAPS/ASIS/FOLD/NOFOLD  *\n*          NOCC/SINGLESPACE/SS/DOUBLESPACE/DS  ASA                    *\n*          LINELENGTH(NNN)/LL(NNN)             PAGELENGTH(NNN)/PL(NNN)*\n*          BURST/NOBURST    FLASH(FLASH-NAME)  CHARS(CHARSET-NAME(S)) *\n*          PROG(PROGNAME)   UDKFONT(FONT-NAME)                        *\n* REQUIRED -- DSLIST OR * IF DDNAME(...)                              *\n* ALIASES  -- PRINTO, PO                                              *\n* DEFAULTS -- CLASS(A), COPIES(1), NOHOLD, LIST, PRINT, FORM($TST),   *\n*             HEADING, ASIS, LINELENGTH(132), PAGELENGTH(60), NOBURST,*\n*             SINGLESPACE IF PAGELENGTH(...) OR IF INPUT RECFM NOT A/M*\n*                                                                     *\n*             MODULE TYPE = PROCEDURE                                 *\n*                                                                     *\n*                PROCESSOR = ASM                                      *\n*                                                                     *\n*                MODULE SIZE = 13K BYTES                              *\n*                                                                     *\n*                ATTRIBUTES = SCHEDULER KEY 8, REENTRANT,             *\n*                   PROBLEM PROGRAM STATE                             *\n*                                                                     *\n*             ENTRY POINTS = PRINTOFF (ONLY ENTRY POINT)              *\n*                                                                     *\n*                LINKAGE =                                            *\n*                   FROM TERMINAL MONITOR PROGRAM AS A COMMAND        *\n*                                                                     *\n*             INPUT = REGISTER 1 POINTS TO COMMAND PROCESSOR          *\n*                PARAMETER LIST MAPPED BY IKJCPPL MACRO               *\n*                                                                     *\n*             OUTPUT = NONE                                           *\n*                                                                     *\n*             EXIT - NORMAL = AT PROGRAM END VIA BRANCH REGISTER 14   *\n*                                                                     *\n*                OUTPUT = NONE                                        *\n*                                                                     *\n*                RETURN CODE = ZERO                                   *\n*                                                                     *\n*             EXIT - ERROR = NONE - PROGRAM WILL DISPLAY DECIMAL      *\n*                RETURN CODE AND RETURN VIA BRANCH REGISTER 14        *\n*                                                                     *\n*                OUTPUT = NONE                                        *\n*                                                                     *\n*                RETURN CODE = ZERO                                   *\n*                                                                     *\n*             EXTERNAL REFERENCES =                                   *\n*                                                                     *\n*                ROUTINES = IKJPARS, DAIRFAIL, GNRLFAIL, PUTLINE      *\n*                   IKJEFLPA  (SEE NOTE IN 'CHANGE ACTIVITY')       WFB\n*                                                                     *\n*                DATA AREAS = NONE                                    *\n*                                                                     *\n*                CONTROL BLOCKS = CPPL, PPL, DAPL, DCB, DAPB, CVT,    *\n*                   S99RBP, S99RB, S99TUPL, S99TUNIT, S99TUFLD,       *\n*                   GFPARMS, DFPARMS, IOPL, IOPB                      *\n*                                                                     *\n*             TABLES = DATA AREA TO BE GETMAINED.  MAPPED BY DSECT    *\n*                BEGINNING AT LABEL WORKAREA                        WFB\n*                                                                     *\n*             MACROS = SAVE, GETMAIN, CALLTSSR, LINK, TPUT, FREEMAIN, *\n*                   OPEN, PUT, GET, CLOSE, RDJFCB, IKJRLSA, DYNALLOC, *\n*                   DCB, IKJPARM, IKJPOSIT, IKJKEYWD, IKJNAME,        *\n*                   IKJSUBF, IKJIDENT, IKJENDP, IKJDAP08, IKJDAP18,   *\n*                   IKJDAPL, IKJCPPL, IKJPPL, CVT, IEFZB4D0, IKJIOPL, *\n*                   IEFZB4D2, DCBD, IKJEFFGF, IKJEFFDF, PUTLINE       *\n*                                                                     *\n*             CHANGE ACTIVITY = 3800 SUPPORT ADDED VIA SETPRT   ARAMCO*\n*                               MAY 1981                        ARAMCO*\n*                                                                     *\n*             MODIFIED BY SAM LEPORE, WFB: 01/86                    WFB\n*               * CORRECT ERROR, 'NOHEAD' CAUSED BLANK FIRST PAGE   WFB\n*               * CORRECT ERRORS IN LENGTH OF TEXTG THROUGH TEXTJ   WFB\n*               * INCREASE INPUT RECORD LIMIT TO 32,760             WFB\n*               * CHANGE DSNAME POSIT TO DSTHING TO ALLOW FOR DDN() WFB\n*               * CHANGE DEST KEYWORD TO ACCEPT 8 CHAR VALUE        WFB\n*               * CHANGE DEST KEYWORD TO ACCEPT NODE AND USERID     WFB\n*               * ADD DDNAME(...) KEYWORD TO ALLOW TEMP OR VIO DSNS WFB\n*               * ADD UNIT(...) KEYWORD FOR USE WITH VOLUME(...)    WFB\n*               * ADD 'VOLUME: VOLSER' TO HEADING WHEN SPECIFIED    WFB\n*    +--------> * ADD TIME AND 'MONTHNAME DAY, YEAR' TO DSN HEADING WFB\n*    :          * ADD NOMSGS KEYWORD TO STOP NON-ERROR MSGS TO TERM WFB\n*    :          * ADD DSECT=YES TO CVT MACRO FOR CLEAN XA ASSEMBLY  WFB\n*    :          * MOVE ALL PUTLINE TEXT TO SEPARATE MESSAGES CSECT  WFB\n*    :                (FOLLOWING CHANGES ARE WFB SPECIFIC)          WFB\n*    :          * MAKE WFB DEFAULT FORM($TST)                       WFB\n*    :                                                              WFB\n*    +-- NOTE ==> THE TIME-DATE ROUTINE IKJEFLPA NORMALLY RESIDES   WFB\n*                 ONLY IN SYS1.AOST4. THIS LIBRARY MUST BE INCLUDED WFB\n*                 IN THE LINKEDIT SYSLIB FOR PROPER RESOLUTION.     WFB\n*                                                                   WFB\n*             MODIFIED BY SAM LEPORE, WFB: 01/87                    WFB\n*                                                                   WFB\n*               * CORRECT ERROR, 'NOHEAD' OFFSET LINE COUNT PAGE 1  WFB\n*               * ADD ASA KEYWORD TO ACCEPT CC WHEN RECFM NOT ..A   WFB\n*               * ADD NOCC KEYWORD ALIAS OF SINGLESPACE             WFB\n*               * ADD UDKFONT(...) KEYWORD FOR XEROX 2700/3700 FONT WFB\n*               * DELETE OLD LINES MARKED *DELETED OR 'DELETED CODE'WFB\n*                                                                     *\n*                                                                     *\n*             MESSAGES =                                              *\n*                                                                     *\n*                BOTH THE DARIFAIL AND GNRLFAIL SERVICE ROUTINES ARE  *\n*                USED TO ISSUE MESSAGES.                              *\n*                THOSE ISSUED BY THE COMMAND ARE FOUND FOLLOWING THE  *\n*                LABEL GNRLERR AND ARE ISSUED USING PUTLINE.          *\n*                                                                     *\n*             ABEND CODES = NONE                                      *\n*                                                                     *\n***********************************************************************\n*\nPRINTOFF CSECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SAVE  (14,12),,HARDCOPY.IPO.&SYSTIME_&SYSDATE SAVE REGISTERS\n         LR    R12,R15                 LOAD REGISTER 12 WITH ENTRY\n*                                      ADDRESS\n         USING PRINTOFF,R12            ESTABLISH ADDRESSABILITY TO\n*                                      PROGRAM CSECT\n         LA    R11,4095(R12)           LOAD REGISTER 11 WITH ENTRY\n*                                      ADDRESS 4095\n         USING PRINTOFF+4095,R11       ESTABLISH ADDRESSABILITY TO THE\n*                                      REST OF THE PROGRAM CSECT\n         LR    R8,R1                   LOAD REGISTER 8 TO PRESERVE\n*                                      POINTER TO COMMAND PROCESSOR\n*                                      PARAMETER LIST\n         GETMAIN R,LV=LDYNAMIC         GETMAIN DYNAMIC WORKAREA\n         LR    R10,R1                  LOAD REGISTER 10 TO PRESERVE\n*                                      POINTER TO WORKAREA\n         ST    R13,4(R10)              STORE ADDRESS OF PREVIOUS\n*                                      SAVEAREA\n         ST    R10,8(,R13)             STORE ADDRESS OF CURRENT\n*                                      SAVEAREA IN PREVIOUS SAVEAREA\n         LR    R13,R10                 LOAD REGISTER 13 WITH ADDRESS OF\n*                                      CURRENT SAVEAREA\n         USING WORKAREA,R13            ESTABLISH ADDRESSABILITY TO\n*                                      DYNAMIC WORKAREA\n         GETMAIN R,LV=RECSIZE          GETMAIN RECORD AREA          WFB\n         ST    R1,ALNDSECT             SAVE ADDRESS OF RECORD      GTEL\n*\n***********************************************************************\n*                                                                     *\n*        BUILD PARSE AND DAIR PARAMETER LISTS USING COMMAND           *\n*           PROCESSOR PARAMETER LIST                                  *\n*        INITIALIZE OUTPUT DATA CONTROL BLOCKS IN WORKAREA            *\n*                                                                     *\n***********************************************************************\n*\n         USING CPPL,R8                 ESTABLISH ADDRESSABILITY TO CPPL\n         LA    R4,PPLSECT              LOAD ADDRESS OF PARSE PARAMETER\n*                                      LIST\n         USING PPL,R4                  ESTABLISH ADDRESSABILITY TO PPL\n         LA    R6,DAPLSECT             LOAD ADDRESS OF DAIR PARAMETER\n*                                      LIST\n         USING DAPL,R6                 ESTABLISH ADDRESSABILITY TO DAPL\n         LA    R5,IOPLSECT             LOAD ADDRESS OF PUTLINE\n*                                      PARAMETER LIST\n         USING IOPL,R5                 ESTABLISH ADDRESSABILITY TO IOPL\n         L     R1,CPPLUPT              LOAD POINTER TO USER PROFILE\n*                                      TABLE FROM CPPL\n         L     R2,CPPLECT              LOAD POINTER TO ENVIRONMENT\n*                                      CONTROL TABLE FROM CPPL\n         SLR   R3,R3                   ZERO REGISTER 3\n         ST    R3,ECB                  STORE REGISTER AS ECB FOR PPL\n         LA    R3,ECB                  LOAD ADDRESS OF ECB\n         STM   R1,R3,DFPLSECT          STOR UPT,ECT,ECB IN DFPL    GTEL\n         STM   R1,R3,PPLSECT           STORE ADDRESS OF UPT, ECT, AND\n*                                      ECB IN PPL\n         STM   R1,R3,DAPLSECT          STORE ADDRESS OF UPT, ECT, AND\n*                                      ECB IN DAPL\n         STM   R1,R3,IOPLSECT          STORE ADDRESS OF UPT, ECT, AND\n*                                      ECB IN IOPL\n         LA    R3,IOPB                 LOAD ADDRESS OF PUTLINE\n*                                      PARAMETER BLOCK\n         ST    R3,IOPLIOPB             STORE IOPB ADDRESS IN IOPL\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** START OF GTEL MOD ************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*   INITIALIZE DFPL AND DFPB SO REST OF NAME CAN BE DETERMINED\n         LA    R3,DFPBSECT             GET ADDRESS OF DFPB\n         ST    R3,DFPLSECT+12          PUT IT IN THE CNTL BLK\n         USING  DFPB,R3                TELL ASSEMBLER\n         LA     R2,DFPBDSL             GET ADDRESS OF DSN LENGTH\n         ST     R2,DFPBDSN             SAVE IT\n         LA     R2,DFPBQUA             GET ADDRESS OF QUAL\n         ST     R2,DFPBQUAL            STORE IT\n         MVI    DFPBCODE,DFPB04        MOVE IN TYPE\n         MVC    DFPBPSCB,CPPLPSCB      MOVE IN PSCB ADDRESS\n         MVI    DFPBCNTL,DFPBRET       MOVE IN DFPBRET\n         XC     DFPBCAT(8),DFPBCAT     CLEAR AREA\n         DROP    R3\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** END OF GTEL MOD **************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         MVC   PPLPCL,PCLADDR          MOVE POINTER TO PARAMETER\n*                                      CONTROL LIST INTO PPL\n         LA    R2,PARSBACK             LOAD ADDRESS OF FULLWORD TO\n*                                      CONTAIN ADDRESS OF PDE RETURNED\n*                                      BY PARS\n         ST    R2,PPLANS               STORE POINTER TO RETURN ADDRESS\n         MVC   PPLCBUF,CPPLCBUF        MOVE POINTER TO COMMAND BUFFER\n*                                      INTO PPL\n*DELETED LA    R2,PPLUWA               LOAD ADDR OF USER WORK AREA  WFB\n*DELETED ST    R2,PPLUWA               STORE ADDRESS IN PPL         WFB\n         ST    R13,PPLUWA              PASS THE DYNAMIC WORK AREA   WFB\n*                                      TO PARSE VALIDITY CHECK RTNE WFB\n         MVC   DAPLPSCB,CPPLPSCB       MOVE POINTER TO PSCB INTO DAPL\n         DROP  R4,R5,R6,R8             DROP ADDRESSABILITY TO CPPL,\n*                                      IOPL, DAPL, AND PPL\n         MVC   OUTPUTA(OUTPUTAL),OUTPUTAC  MOVE ASA DCB CONSTANT INTO\n*                                      ASA DCB IN WORKAREA\n         MVC   OUTPUTM(OUTPUTML),OUTPUTMC  MOVE MACHINE DCB CONSTANT\n*                                      INTO MACHINE DCB IN WORKAREA\n*\n***********************************************************************\n*                                                                     *\n*        CALLTSSR TO PARSE (ENTRY NAME IKJPARS)                       *\n*        ON RETURN PARSBACK -> PDL                                    *\n*        HANDLE ALL ERROR CODES RETURNED BY PARS                      *\n*        IF NECESSARY CALL GENERAL FAIL SERVICE ROUTINE               *\n*                                                                     *\n***********************************************************************\n*\n         CALLTSSR  EP=IKJPARS,MF=(E,PPLSECT)\n*                                      CALL PARS TO PARSE COMMAND\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO\n         BZ    GOODPARS                YES....GO TO GOOD PARS ROUTINE\n         C     R15,FULL4               SEE IF RETURN CODE IS FOUR\n         BE    RETURN                  YES....PARS ISSUED ERROR\n*                                      MESSAGE.  GO CLEANUP AND RETURN\n         C     R15,FULL20              SEE IF RETURN CODE IS TWENTY\n         BE    RETURN                  YES....VALIDITY CHECKING\n*                                      ROUTINE ISSUED ERROR MESSAGE.\n*                                      GO CLEANUP AND RETURN\n         XC    GFPARMS(GFLENGF),GFPARMS  INITIALIZE PARMLIST FOR\n*                                      GENERAL FAIL TO ZEROS\n         LA    R1,GFPARMS              LOAD ADDRESS OF PARMLIST\n         ST    R1,GFPARMP              STORE ADDRESS AS POINTER TO\n*                                      PARMLIST\n         ST    R15,GFRCODE             STORE RETURN CODE IN PARMLIST\n         LA    R1,GFPARSE              LOAD CALLER ID FOR PARS\n         STH   R1,GFCALLID             STORE CALLER ID IN PARMLIST\n         L     R1,SAVEAREA+4           LOAD ADDRESS OF PEVIOUS\n*                                      SAVEAREA\n         L     R1,24(R1)               LOAD POINTER TO CPPL\n         ST    R1,GFCPPLP              STORE POINTER TO CPPL IN\n*                                      PARMLIST\n         LA    R1,ECB                  LOAD ADDRESS OF OPTIONAL ECB\n         ST    R1,GFECBP               STORE POINTER TO ECB IN\n*                                      PARMLIST\n         SLR   R1,R1                   ZERO REGISTER 1\n         ST    R1,ECB                  SET OPTIONAL ECB TO ZERO\n         LINK  EP=IKJEFF19,MF=(E,GFPARMP)  LINK TO GENERAL FAIL SERVICE\n*                                      ROUTINE TO HANDLE RETURN CODE\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO\n         BZ    RETURN                  YES....GO CLEANUP AND RETURN\n         LR    R8,R15                  LOAD REGISTER 8 WITH RETURN\n*                                      CODE\n         BAL   R14,SETCODE             GO CONVERT CODE TO DECIMAL\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(GNRLERR,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      GENERAL FAIL ERROR MESSAGE\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(RETNCD,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DECIMAL RETURN CODE\n         DROP  R15                                                  WFB\n         B     RETURN                  GO CLEANUP AND RETURN\n*\n***********************************************************************\n*                                                                     *\n*        SET UP ADDRESSABILITY TO PDL                                 *\n*           AND LOAD REGISTER 6 WITH ADDRESS OF DSNAME PDE            *\n*                                                                     *\n***********************************************************************\n*\nGOODPARS DS    0H\n         L     R9,PARSBACK             LOAD POINTER TO PARS ANSWER\n         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY TO PDL\n         LA    R6,DSNAMES              LOAD POINTER TO DSNAME LIST\n         MVI   VOLBIT,BLANK            BLANK OUT THE VOLUME WORK AREA\n         MVC   VOLUME,VOLBIT           CONTINUE BLANKING THE VOLUME\n         MVC   VOLHEAD,BLANKS          BLANK OUT THE HEADING CONST  WFB\n         MVC   VOLNAME,BLANKS          BLANK OUT THE HEADING VOLUME WFB\n         MVC   UNIT,BLANKS             BLANK OUT THE UNIT WORK AREA WFB\n         CLC   PNOMSG(2),HALF1         SEE IF NOMSG SPECIFIED       WFB\n         BNE   CHKDSN                  NO, GO SEE IF DSNAME GIVEN   WFB\n         OI    VOLBIT,NOMSG            YES, TURN ON FLAG FOR LATER  WFB\nCHKDSN   DS    0H                                                   WFB\n         L     R1,0(,R6)               GET ADDRESS OF DSNAME        WFB\n         CLI   0(R1),C'*'              SEE IF DSNAME IS ASTERISK    WFB\n         BNE   CHKVSER                 NO, GO SEE IF VOLUME GIVEN   WFB\n         CLC   PDDNAME(2),HALF1        SEE IF DDNAME SPECIFIED      WFB\n         BE    CHKFOLD                 YES, SKIP UNIT VOL, CHK FOLD WFB\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(NODSNDD,SINGLE,DATA),MF=(E,IOPLSECT)       WFB\n*                                      NO DSN OR DD GIVEN MESSAGE   WFB\n         DROP  R15                                                  WFB\n         B     RETURN                                               WFB\nCHKVSER  DS    0H                                                   WFB\n         CLC   PVOL(2),HALF1           SEE IF VOLUME SPECIFIED\n         BNE   CHKFOLD                 NO.....GO SEE IF FOLD IS DESIRED\n         L     R7,SVOL                 LOAD POINTER TO VOLUME\n         LH    R8,SVOL+4               LOAD LENGTH OF VOLUME\n         BCTR  R8,0                    DECREMENT LENGTH FOR EXECUTE OF\n*                                      MOVE\n         EX    R8,MOVEVOL              MOVE VOLUME INTO WORK AREA\n         OI    VOLBIT,HIGH             INDICATE VOLUME PRESENT\n         MVC   VOLHEAD,VOLCONST        MOVE '   VOLUME: ' TO HEAD   WFB\n         MVC   VOLNAME,VOLUME          MOVE VOLUME SER TO HEADING   WFB\n         CLC   PUNIT(2),HALF1          SEE IF UNIT SPECIFIED        WFB\n*                                 ===> O N L Y  IF VOLUME SPECIFIED WFB\n         BNE   CHKFOLD                 NO,GO SEE IF FOLD IS DESIRED WFB\n         L     R7,SUNIT                LOAD POINTER TO UNIT         WFB\n         LH    R8,SUNIT+4              LOAD LENGTH OF UNIT          WFB\n         BCTR  R8,0                    DECREMENT LENGTH FOR EXECUTE WFB\n         EX    R8,MOVEUNIT             MOVE UNIT INTO WORK AREA     WFB\n         OI    VOLBIT,MID1             INDICATE UNIT PRESENT        WFB\nCHKFOLD  DS    0H\n         CLC   PFOLD(2),HALF1          SEE IF FOLD SPECIFIED\n         BNE   CHKHEAD                 NO.....GO LOOP THROUGH DSNS GTEL\n         OI    VOLBIT,LOW              INDICATE FOLD PRESENT\nCHKHEAD  DS    0H\n         CLC   PHEAD(2),HALF1          SEE IF NOHEAD SPECIFIED\n         BNE   NEXT                    NO.....GO LOOP THROUGH DSNAMES\n         OI    VOLBIT,MID2             INDICATE NOHEAD PRESENT     GTEL\n         DROP  R9                      DROP ADDRESSABILITY TO PDL\n*\n***********************************************************************\n*                                                                     *\n*        LOOP THROUGH DSNAME LIST RETURNED BY PARS                    *\n*                                                                     *\n***********************************************************************\n*\nNEXT     DS    0H\n         LA    R1,PRINTI               LOAD POINTER TO DDNAME TO BE\n*                                      FREED\n         BAL   R2,FREEDD               BRANCH TO FREE ROUTINE\n         LTR   R8,R8                   SEE IF RETURN CODE FROM FREE IS\n*                                      ZERO\n         BNZ   CLOSDCBS                NO.....GO CLOSE DCBS AND RETURN\n         L     R5,0(R6)                LOAD POINTER TO DSNAME\n         CLI   0(R5),C'*'              SEE IF DSNAME IS ASTERISK    WFB\n         BE    ALLOCDDN                YES, GO PROCESS DDNAME       WFB\n         LH    R4,4(R6)                LOAD LENGTH OF DSNAME\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** START OF GTEL MOD ************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*   DETERMINE THE FULL DATASET NAME GIVEN\n         STH   R4,DFPBDSL              STORE LENGTH OF DSN\n         TM    6(R6),X'40'             IN QUOTES\n         BO    GTENOQ                  YES, SKIP\n         BCTR  R4,0                    DECREMENT COUNT\n         MVC   DFPBNAME,BLANKS         MOVE IN BLANKS\n         EX    R4,DFPBMVE              MOVE IN DSN GIVEN\n         LA    R4,1(R4)                BUMP COUNT                ARAMCO\n         LA    R1,DFPLSECT             GET ADDRESS OF ECT\n         MVC   DFPBQUA,BLANKS          BLANK QUALIFIER\n         CALLTSSR  EP=IKJEHDEF         GO TO DEFAULT ROUTINE\nGTEDEF   LTR    R15,R15                TEST RETURN CODE\n         BNZ    GTENOQ                 NON ZERO SKIP\nGTEOK    LA     R5,DFPBNAME            RESTORE REGS\n         LH     R4,DFPBDSL             GET NEW LENGTH\nGTENOQ   DS    0H\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** END OF GTEL MOD **************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         STCM  R4,3,DSNLEN             STORE LENGTH OF DSNAME\n         BCTR  R4,0                    DECREMENT LENGTH FOR EXECUTE OF\n*                                      MOVE\n         LA    R8,DAP08                LOAD ADDRESS OF DAPB FOR 08\n         USING DAPB08,R8               ESTABLISH ADDRESSABILITY TO DAPB\n         MVC   DAPB08(DAPB08L),DAPB08C MOVE CONSTANTS INTO DAPB\n         LA    R1,DSNLEN               LOAD POINTER TO DSN BUFFER\n         ST    R1,DA08PDSN             STORE POINTER TO DSN BUFFER IN\n*                                      DAPB\n         MVI   DSNBUF,BLANK            BLANK OUT THE DSNAME BUFFER\n         MVC   DSNBUF+1(43),DSNBUF     FINISH BLANKING OUT THE BUFFER\n         EX    R4,MOVEDSN              MOVE IN THE DSNAME\n         TM    14(R6),HIGH             SEE IF MEMBER NAME IS PRESENT\n         BNO   CHKPASS                 NO.....GO CHECK IF THERE IS A\n*                                      PASSWORD\n         L     R5,8(R6)                LOAD POINTER TO THE MEMBER NAME\n         LH    R4,12(R6)               LOAD LENGTH OF MEMBER NAME\n         BCTR  R4,0                    DECREMENT LENGTH FOR EXECUTE OF\n*                                      MOVE\n         EX    R4,MOVEMEM              MOVE IN THE MEMBER NAME\nCHKPASS  DS    0H\n         MVC   MEMNAME,DA08MNM         MOVE MEMBER NAME INTO HEADER 2\n         TM    22(R6),HIGH             SEE IF PASSWORD IS PRESENT\n         BNO   CHKVOL                  NO.....GO SEE IF VOLUME PRESENT\n         L     R5,16(R6)               LOAD POINTER TO THE PASSWORD\n         LH    R4,20(R6)               LOAD LENGTH OF PASSWORD\n         BCTR  R4,0                    DECREMENT LENGTH FOR EXECUTE OF\n*                                      MOVE\n         EX    R4,MOVEPASS             MOVE IN THE PASSWORD\nCHKVOL   DS    0H\n         TM    VOLBIT,HIGH             SEE IF VOLUME IS PRESENT\n         BNO   ALLOCDD                 NO.....GO ALLOCATE DATA SET\n         MVC   DA08SER,VOLUME          MOVE IN THE VOLUME SERIAL\n         TM    VOLBIT,MID1             SEE IF UNIT IS PRESENT       WFB\n*                                 ===> O N L Y  IF VOLUME SPECIFIED WFB\n         BNO   ALLOCDD                 NO.....GO ALLOCATE DATA SET  WFB\n         MVC   DA08UNIT,UNIT           MOVE IN THE UNIT TYPE        WFB\nALLOCDD  DS    0H\n         SLR   R4,R4                   ZERO REGISTER 4\n         ST    R4,ECB                  STORE REGISTER 4 AS ECB\n         LA    R1,DAPLSECT             LOAD ADDRESS OF DAPL\n         USING DAPL,R1                 ESTABLISH ADDRESSABILITY TO DAPL\n         ST    R8,DAPLDAPB             STORE ADDRESS OF DAPB IN DAPL\n         DROP  R1                      DROP ADDRESSABILITY TO DAPL\n         CALLTSSR EP=IKJDAIR           CALL DAIR TO ALLOCATE DATASET\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO\n         BZ    OUTPUT                  YES....GO PRINT DATASET\n         MVI   DFID+1,DFDAIR           SET DAIRFAIL ID TO INDICATE DAIR\n         BAL   R2,DAIRFAIL             GO TO DAIRFAIL ROUTINE TO HAVE\n*                                      ERROR MESSAGE PUT OUT\nNOTPMESS DS    0H\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(DSNNOTP,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATASET NOT PRINTED MESSAGE\n         DROP  R15                                                  WFB\n         B     EXITMSG                 GO PUT OUT DATASET AND MEMBER\n*                                      NAMES\n*\n***********************************************************************\n*                                                                     *\n*        DETERMINE DATASET TYPE AND CALL PRINT ROUTINE                *\n*                                                                     *\n***********************************************************************\n*\nOUTPUT   DS    0H\n         TM    DA08DSO,DSOPS           X'40' PHYSICAL SEQUENTIAL\n         BO    PRINTIT                 YES....GO PRINT DATASET\n         CLC   DA08MNM,BLANKS          SEE IF MEMBER NAME IS BLANK\n         BNE   PRINTIT                 NO.....GO TREAT AS SEQUENTIAL\n         TM    DA08DSO,DSOPO           X'02' PARTITIONED\n         BO    SCROLLIT                YES....GO SCROLL DIRECTORY\n         DROP  R8                      DROP ADDRESSABILITY TO DAPB\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(NOTPSPO,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      NOT PARTITIONED OR SEQUENTIAL\n*                                      MESSAGE\n         DROP  R15                                                  WFB\n         B     NOTPMESS                GO PUT NOT PRINTED MESSAGE\n*                                                                   WFB\nALLOCDDN DS    0H                                                   WFB\n         L     R1,24(,R6)              LOAD POINTER TO NEXT DSN     WFB\n         C     R1,ENDCHAIN             IS DSN=* LAST OR ONLY NAME ? WFB\n         BE    CHKINFO                 YES, GO GET DSN, DSORG INFO  WFB\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(NOTLAST,SINGLE,DATA),MF=(E,IOPLSECT)  PUT  WFB\n*                                      DSN=* IS NOT LAST OR ONLY    WFB\n*                                      MESSAGE                      WFB\n         DROP  R15                                                  WFB\n         B     NOTPMESS                GO PUT NOT PRINTED MESSAGE   WFB\nCHKINFO  DS    0H                                                   WFB\n         LA    R8,REQBLK               GET POINTER TO REQUEST BLOCK WFB\n         ST    R8,RBPTR                INITIALIZE REQUEST BLOCK PTR WFB\n         MVI   RBPTR,S99RBPND          INDICATE END OF PARM LIST    WFB\n         USING S99RB,R8                ESTABLISH ADDRESSABILITY TO  WFB\n*                                      REQUEST BLOCK                WFB\n         MVC   S99RBLN(RBLEN),REQBLKC  INITALIZE RB                 WFB\n         MVI   S99VERB,S99VRBIN        SET VERB TO INFO RETRIEVAL   WFB\n         LA    R1,TEXTPTRS             GET POINTER TO TEXT POINTERS WFB\n         ST    R1,S99TXTPP             STORE POINTER IN RB          WFB\n         DROP  R8                      DROP ADDRESSABILITY TO RB    WFB\n         USING S99TUPL,R1              ESTABLISH ADDRESSABILITY TO  WFB\n*                                      TEXT UNIT POINTER LIST       WFB\n         LA    R2,TEXTL                ADDRESS PREALLOC DDNAME TEXT WFB\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL        WFB\n         USING S99TUNIT,R2             ESTABLISH ADDRESSABILITY TO  WFB\n*                                      TEXT UNIT                    WFB\n         MVC   S99TUKEY(TEXTLLEN),TEXTLC  INITIALIZE TEXT UNIT L    WFB\n         L     R9,PARSBACK             LOAD POINTER TO PARS ANSWER  WFB\n         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY     WFB\n         L     R5,SDDNAME              GET ADDRESS OF DDNAME        WFB\n         LH    R4,SDDNAME+4            GET LENGTH OF DDNAME         WFB\n         DROP  R9                                                   WFB\n         BCTR  R4,0                    DECREMENT FOR EXECUTE        WFB\n         EX    R4,MOVEDDN              MOVE DDNAME INTO TEXT UNIT   WFB\n         MVC   PREALDDN,S99TUPAR       SAVE PREALLOC DDN FOR LATER  WFB\n         LA    R1,4(,R1)               POINT TO NEXT TEXT UNIT PTR  WFB\n         LA    R2,TEXTM                ADDRESS RETURN DSNAME TEXT U WFB\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL        WFB\n         MVC   S99TUKEY(TEXTMLEN),TEXTMC  INITIALIZE TEXT UNIT M    WFB\n         LA    R1,4(,R1)               POINT TO NEXT TEXT UNIT PTR  WFB\n         LA    R2,TEXTN                ADDRESS RETURN MEMBER TEXT U WFB\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL        WFB\n         MVC   S99TUKEY(TEXTNLEN),TEXTNC  INITIALIZE TEXT UNIT N    WFB\n         LA    R1,4(,R1)               POINT TO NEXT TEXT UNIT PTR  WFB\n         LA    R2,TEXTO                ADDRESS RETURN DSORG TEXT U  WFB\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL        WFB\n         MVC   S99TUKEY(TEXTOLEN),TEXTOC  INITIALIZE TEXT UNIT O    WFB\n         MVI   S99TUPTR,S99TUPLN       INDICATE END TEXT UNIT PTRS  WFB\n         DROP  R1,R2                   DROP ADDRESSABILITY          WFB\n         LA    R1,RBPTR                ADDRESS SVC99 REQUEST BLOCK  WFB\n         DYNALLOC                      ISSUE DYNAMIC ALLOCATION SVC WFB\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO   WFB\n         BZ    CHKDDORG                YES....GO CHECK DSORG TYPE   WFB\n         LA    R1,REQBLK               ADDRESS SVC99 REQUEST BLOCK  WFB\n         MVI   DFID+1,DFSVC99          SET DAIRFAIL ID = DYNALLOC   WFB\n         BAL   R2,DAIRFAIL             GO TO DAIRFAIL ROUTINE TO    WFB\n         B     NOTPMESS                GO PUT NOT PRINTED MESSAGE   WFB\nCHKDDORG DS    0H                                                   WFB\n         LA    R1,TEXTM                ADDRESS RETURNED DSNAME TEXT WFB\n         USING S99TUNIT,R1             ESTABLISH ADDRESSABILITY     WFB\n         MVC   DFPBDSL,S99TULNG        SAVE DSN LEN WHERE EXPECTED  WFB\n         MVC   DSNAME,S99TUPAR         MOVE RETURN DSN INTO HEADER  WFB\n         LA    R1,TEXTN                ADDRESS RETURNED MEMBER TEXT WFB\n         MVC   MEMNAME,S99TUPAR        MOVE RETURN MEM INTO HEADER  WFB\n         MVC   VOLHEAD,DDNCONST        MOVE '   DDNAME: ' TO HEADER WFB\n         MVC   VOLNAME,PREALDDN        MOVE DDNAME TO HEADING       WFB\n         LA    R1,TEXTO                ADDRESS RETURNED DSORG TEXT  WFB\n         TM    S99TUPAR,DSOPS          X'40' PHYSICAL SEQUENTIAL    WFB\n         BO    PRINTIT                 YES....GO PRINT DATASET      WFB\n         CLI   MEMNAME,BLANK           SEE IF MEMBER NAME IS BLANK  WFB\n         BNE   PRINTIT                 NO.....GO TREAT AS SEQUENTIALWFB\n         TM    S99TUPAR,DSOPO          X'02' PARTITIONED            WFB\n         BO    SCROLLIT                YES....GO SCROLL DIRECTORY   WFB\n         DROP  R1                      DROP ADDRESSABILITY TO S99TU WFB\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(NOTPSPO,SINGLE,DATA),MF=(E,IOPLSECT)  PUT  WFB\n*                                      NOT PARTITIONED OR SEQUENTIALWFB\n*                                      MESSAGE                      WFB\n         DROP  R15                                                  WFB\n         B     NOTPMESS                GO PUT NOT PRINTED MESSAGE   WFB\n*\n***********************************************************************\n*                                                                     *\n*        READS RECORDS USING GET MOVE                                 *\n*           AND ATTRIBUTES OF GIVEN DATASET                           *\n*        WRITES THESE SAME RECORDS USING PUT MOVE                     *\n*           AND THE INPUT DATASET ATTRIBUTES                          *\n*                                                                     *\n***********************************************************************\n*\nPRINTIT  DS    0H\n         LA    R8,INPUT                LOAD POINTER TO INPUT DCB\n         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB\n         MVC   INPUT(INPUTL),INPUTC    MOVE INPUT DCB CONSTANT INTO\n*                                      INPUT DCB IN WORKAREA\n         L     R1,0(,R6)               GET ADDRESS OF DSNAME        WFB\n         CLI   0(R1),C'*'              SEE IF DSNAME IS ASTERISK    WFB\n         BNE   OPENINP                 NO, GO OPEN INPUT            WFB\n         MVC   DCBDDNAM,PREALDDN       YES, USE PREALLOCATED DDN(.) WFB\nOPENINP  DS    0H                                                   WFB\n         MVC   OPENLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO OPEN LIST IN WORKAREA\n         OPEN  ((R8),INPUT),MF=(E,OPENLST)  OPEN INPUT DCB\nPRINTS   DS    0H                      BRANCH ADDRESS FOR PRINTING\n*                                      MEMBERS\n         TM    DCBOFLGS,DCBOFOPN       SEE IF DCB OPENED SUCCESSFULLY\n         BNO   NOTPMESS                NO.....GO PUT OUT NOT PRINTED\n*                                      MESSAGE\nCHKCNTRL DS    0H\n         MVC   HEADER,HEADERC          MOVE HEADER INTO DATA AREA\n         TM    DCBRECFM,DCBRECCM       SEE IF CONTROL IS MACHINE\n         BNO   USEA                    NO.....GO TO USE ASA CONTROL\n         LA    R5,OUTPUTM              LOAD ADDRESS OF OUTPUT DCB FOR\n*                                      MACHINE CODE\n         LA    R4,EJECTM               LOAD ADDRESS OF EJECT DATA\n         MVI   HDRCNTL,SKIPM           MOVE INTO HEADER MACHINE CODE\n*                                      FOR SPACE\n         TM    48(R5),DCBOFOPN         SEE IF DCB IS ALREADY OPEN\n         BO    PUTDSN                  YES....GO PUT OUT HEADERS\n         LA    R3,PRINTM               LOAD POINTER TO PRINTM\n         LA    R14,PUTDSN              LOAD ADDRESS FROM RETURN FROM\n*                                      SYSOUT ALLOCATION\n         B     ALLOCOUT                GO TO ALLOCATE SYSOUT\nUSEA     DS    0H\n         LA    R5,OUTPUTA              LOAD ADDRESS OF OUTPUT DCB FOR\n*                                      ASA CODE\n         LA    R4,EJECTA               LOAD ADDRESS OF EJECT DATA\n         TM    48(R5),DCBOFOPN         SEE IF DCB IS ALREADY OPEN\n         BO    PUTDSN                  YES....GO PUT OUT HEADERS\n         LA    R3,PRINTA               LOAD POINTER TO PRINTA\n         BAL   R14,ALLOCOUT            LOAD ADDRESS FOR RETURN AND GO\n*                                      DO SYSOUT ALLOCATION\nPUTDSN   DS    0H\n         TM    VOLBIT,UDKDONE          UDKS WRITTEN ALREADY ?       WFB\n         BO    NOUDK                   YES, SKIP                    WFB\n         L     R9,PARSBACK             LOAD POINTER TO PARS ANSWER  WFB\n         USING IKJPARMD,R9             ESTABLISH ADDRESABILITY      WFB\n         CLC   PUDKFONT(2),HALF1       IS UDK FONT SPECIFIED ?      WFB\n         BNE   NOUDK                   NO, SKIP                     WFB\n         PUT   (R5),UDKRESET           PUT OUT UDK RESET TEXT       WFB\n         PUT   (R5),UDKSET             PUT OUT UDK SET TEXT         WFB\n         L     R15,ALNDSECT            POINT TO RECORD WORK AREA    WFB\n         USING LINDSECT,R15            ESTABLISH ADDRESSABILITY     WFB\n         MVC   RECORD(8),UDKFHEAD      MOVE UDK FONT NAME HEADER    WFB\n         L     R14,SUDKFONT            POINT TO UDK FONT NAME       WFB\n         LH    R1,SUDKFONT+4           GET LENGTH OF UDK FONT NAME  WFB\n         BCTR  R1,0                    DECREMENT FOR EXECUTE        WFB\n         EX    R1,MOVEUDK              MOVE UDK FONT NAME TO RECORD WFB\n         LA    R1,9(,R1)               ADD HEADER LEN TO ACTUAL LEN WFB\n         STH   R1,RECLEN               SAVE IN OUTPUT RECORD        WFB\n         PUT   (R5),(R15)              PUT OUT UDK FONT NAME        WFB\n         DROP  R9,R15                                               WFB\n         PUT   (R5),UDKFSEL            PUT OUT UDK FONT SELECT TEXT WFB\n         OI    VOLBIT,UDKDONE          INDICATE UDKS WRITTEN        WFB\nNOUDK    DS    0H                                                   WFB\n         TM    VOLBIT,MID2             TEST FOR NOHEAD             GTEL\n         BO    NOHEAD                  YES                         GTEL\n         PUT   (R5),(R4)               PUT OUT PAGE EJECT           WFB\n         MVC   HDRTIME(HDRTDLEN),BLANKS  BLANK OUT TIME DATE AREAS  WFB\n         CALL  IKJEFLPA,(HDRTIME,HDRDATE),VL,MF=(E,CALLMFL)         WFB\n         MVC   HDRTIME(4),BLANKS       BLANK OUT BUFFER PREFIX      WFB\n         MVC   HDRDATE(4),BLANKS       BLANK OUT BUFFER PREFIX      WFB\n         PUT   (R5),HEADER             PUT OUT PAGE 1 HEADER\n         MVC   HEADER2,LDSNAME         MOVE LENGTH AND 'DSNAME=' INTO\n*                                      INTO SECOND HEADER\n         MVC   HEADER2+4(1),HDRCNTL    MOVE IN CONTROL BYTE\n         CLI   MEMNAME,BLANK           SEE IF MEMBER NAME IS BLANK\n         BE    NOMEM                   YES....NO NEED TO PUT IN PARENS\n         MVI   OPENPRN,C'('            MOVE OPEN PAREN INTO DSNAME\n         MVI   CLOSEPRN,C')'           MOVE CLOSE PAREN INTO DSNAME\n         B     PUTHDR2                 GO PUT OUT HEADER 2\nNOMEM    DS    0H\n         MVI   OPENPRN,BLANK           MOVE BLANK INSTEAD OF OPEN AND\n         MVI   CLOSEPRN,BLANK          CLOSE PARENS\nPUTHDR2  DS    0H\n         PUT   (R5),HEADER2            PUT OUT PAGE 1 HEADER 2\n         MVC   HEADER2(4),SPACE        CHANGE HEADER 2 FOR PUT OF BLANK\n*                                      LINE\n         PUT   (R5),HEADER2            PUT OUT BLANK LINE\nNOHEAD   STM   R9,R10,SAVMR9           SAVE REGS 9 AND 10\n         STM   R6,R7,SAVMR6            SAVE REGS 6 AND 7\n         STM   R2,R3,SAVMR2            SAVE REGS 2 AND 3\n         L     R9,ALNDSECT             SET UP RECORD ADDRESS.\n         USING LINDSECT,R9             *\n         SLR   R10,R10                 ZERO OUT R10\n         LH    R7,PAGELEN              MOVE IN PAGELEN\n         TM    VOLBIT,MID2             NOHEAD SPECIFIED ?           WFB\n         BO    NOSUB4                  YES, SKIP SUBTRACTION        WFB\n         SH    R7,HALF4                SUBTRACT FOR HEADER       ARAMCO\nNOSUB4   DS    0H                                                   WFB\n         MVC   RECCC,HDRCNTL           MOVE IN SPACE AS CONTROL\n*                                      CHARACTER\n         TM    DCBRECFM,DCBRECU        SEE IF RECFM U\n         BO    COPYU                   YES....GO HANDLE RECFM U\n         TM    DCBRECFM,DCBRECV        SEE IF RECFM V\n         BO    COPYV                   YES....GO HANDLE RECFM V\nCOPYF    DS    0H\n         TM    DCBRECFM,DCBRECCC       CONTROL CHARACTER?\n         BNZ   COPYFCC                 YES...\n         TM    CCBIT,FORCEASA          USER SAYS CC IN DATA ?       WFB\n         BO    COPYFCC                 YES, PROCESS AS SO           WFB\nCOPYFNC  OI    CCBIT,LOW               TURN ON NOCC BIT\n         LH    R4,DCBLRECL             GET LRECL\n         A     R4,FULL5                ADD LENGTH FOR VB HEADER\n         STH   R4,RECLEN               PUT INTO RECORD HEADER\n         GET   INPUT,RECDATA           GET INPUT\n         BAL   R10,PUTLL               PUT OUT LINE\n         L     R9,ALNDSECT             RELOAD DSECT POINTER\n         B     COPYFNC                 GET NEXT RECORD\nCOPYFCC  LH    R4,DCBLRECL             GET LRECL\n         A     R4,FULL4                ADD LENGTH FOR VB HEADER\n         STH   R4,RECLEN               PUT INTO RECORD HEADER\n         GET   INPUT,RECCC             GET INPUT\n         BAL   R10,PUTLL               PUT INTO RECORD HEADER\n         L     R9,ALNDSECT             RELOAD DSECT POINTER\n         B     COPYFCC                 GET NEXT RECORD\nCOPYV    DS    0H\n         TM    DCBRECFM,DCBRECCC       CONTROL CHARACTER?\n         BNZ   COPYVCC                 IF YES...\n         TM    CCBIT,FORCEASA          USER SAYS CC IN DATA ?       WFB\n         BO    COPYVCC                 YES, PROCESS AS SO           WFB\nCOPYVNC  GET   INPUT,RECLEN+1          GET INPUT\n         OI    CCBIT,LOW               TURN ON NOCC BIT\n         SLR   R15,R15                 ZERO R15\n         ICM   R15,7,RECLEN+1          GET LENGTH\n         A     R15,FULL256             ADD ONE FOR CC\n         STCM  R15,7,RECLEN            REPLACE LENGTH OVER 1\n         MVC   RECCC,HDRCNTL           ADD HDRCNTL\n         BAL   R10,PUTLL               PUT OUT RECORD\n         L     R9,ALNDSECT             RESTORE DSECT ADDRESS\n         B     COPYVNC                 GET NEXT RECORD\nCOPYVCC  GET   INPUT,RECLEN            GET INPUT\n         BAL   R10,PUTLL               PUT OUT RECORD\n         L     R9,ALNDSECT             RESTORE DSECT ADDRESS\n         B     COPYVCC                 GET NEXT RECORD\nCOPYU    DS    0H                      PROCESS RECFM=U\n         TM    DCBRECFM,DCBRECCC       CONTROL CHARACTER?\n         BNZ   COPYUCC                 YES...\n         TM    CCBIT,FORCEASA          USER SAYS CC IN DATA ?       WFB\n         BO    COPYUCC                 YES, PROCESS AS SO           WFB\nCOPYUNC  GET   INPUT,RECDATA           GET RECORD\n         OI    CCBIT,LOW               TURN ON NOCC BIT\n         LH    R4,DCBLRECL             GET LRECL\n         A     R4,FULL5                ADD VB HEADER LENGTH\n         STH   R4,RECLEN               PUT INTO RECORD HEADER\n         BAL   R10,PUTLL               PUT OUT LINE\n         L     R9,ALNDSECT             RELOAD DSECT POINTER\n         B     COPYUNC                 GET NEXT RECORD\nCOPYUCC  GET   INPUT,RECCC             GET INPUT\n         LH    R4,DCBLRECL             GET LRECL\n         A     R4,FULL4                ADD VB HEADER LENGTH\n         STH   R4,RECLEN               STORE INTO RECORD HEADER\n         BAL   R10,PUTLL               PUT INTO RECORD HEADER\n         L     R9,ALNDSECT             RELOAD DSECT POINTER\n         B     COPYUCC                 GET NEXT RECORD\nPUTLL    DS    0H\n         TM    CCBIT,X'99'             NOCC, DS, SS, OR PAGELEN ON?\n         BZ    NOSKIP                  NO, IGNORE LINE-COUNTING\n         LTR   R7,R7                   ANY LINES LEFT ON PAGE?\n         BNZ   LINECT                  YES, DON'T PUT IN PAGE SKIP CC\n         MVI   4(R9),HEXF1             MOVE IN PAGE SKIP CC\n         LH    R7,PAGELEN              RESET LINE COUNT\n         B     NOSKIP                  CONTINUE WITH PUT\nLINECT   TM    CCBIT,MID2              WAS DOUBLE SPACE SPECIFIED?\n         BO    LINEDS                  YES, CHECK LINES LEFT     ARAMCO\n         MVI   4(R9),BLANK             PUT IN SINGLE SPACE CONTROL CHAR\n         B     NOSKIP                  YES, DON'T SKIP TO NEXT PAGE\nLINEDS   BCTR  R7,0                    DECREMENT ONE MORE FOR DS\n         MVI   4(R9),HEXF0             PUT IN DOUBLE SPACE CONTROL CHAR\n         SLR   R2,R2                   EMPTY R2 FOR DIVIDE\n         SLR   R3,R3                   EMPTY R3 FOR DIVIDE\n         SLR   R15,R15                 EMPTY R15 FOR DIVIDE\n         LH    R15,LINELEN             LOAD LINELEN INTO R15\n         LH    R3,RECLEN               PUT REC LENGTH IN R2\n         SH    R3,HALF5                SUBTRACT VB HEADER LENGTH\n         DR    R2,R15                  DIVIDE BY LINELEN\n         CR    R3,R7                   GREATER THAN LINES LEFT ON PAGE?\n         BNH   NOSKIP                  IF NOT....DON'T START NEW PAGE\n         MVI   4(R9),HEXF1             MOVE IN PAGE SKIP CC\n         LH    R7,PAGELEN              RESET LINE COUNT\nNOSKIP   LH    R4,RECLEN               PUT REC LENGTH IN R4\n         TM    VOLBIT,LOW              SEE IF FOLD IS REQUESTED\n         BO    FOLDLOOP                YES....GO FOLD OUTPUT\nPUTLOOP  CH    R4,VBLEN                COMPARE WITH LL\n         BNH   PUTLAST                 WRITE LAST RECORD\n         MVC   0(2,R9),VBLEN           INSERT LENGTH FOR PUT\n         PUT   (R5),(R9)               PUT OUT OUTPUT LINE\n         SH    R4,LINELEN              DECREMENT FOR COMPARE\n         AH    R9,LINELEN              INCREMENT RECORD LOCATN\n         MVI   4(R9),BLANK             MOVE IN NEXT LINE CC\n         TM    CCBIT,X'99'             NOCC, PAGELEN, DS, OR SS SPEC?\n         BZ    PUTLOOP                 NO, DON'T COUNT LINES\n         BCT   R7,PUTLOOP              END OF PAGE?\n         MVI   4(R9),HEXF1             YES, START NEW PAGE\n         LH    R7,PAGELEN              RELOAD PAGELEN\n         B     PUTLOOP                 WRITE NEXT LINE\nFOLDLOOP CH    R4,VBLEN                COMPARE WITH LL\n         BNH   FOLDLAST                WRITE LAST RECORD\n         LH    R15,LINELEN             LOAD LINE LENGTH\n         SH    R15,HALF1               DECREMENT FOR EXECUTE\n         EX    R15,FOLDLINE            EXECUTE FOLD OF LINE\n         MVC   0(2,R9),VBLEN           INSERT LENGTH FOR PUT\n         PUT   (R5),(R9)               PUT OUT OUTPUT LINE\n         SH    R4,LINELEN              DECREMENT FOR COMPARE\n         AH    R9,LINELEN              INCREMENT RECORD LOCATION\n         MVI   4(R9),BLANK             MOVE IN NEXT LINE CC\n         TM    CCBIT,X'99'             NOCC, PAGELEN, DS, OR SS SPEC?\n         BZ    FOLDLOOP                NO, DON'T COUNT LINES\n         BCT   R7,FOLDLOOP             END OF PAGE?\n         MVI   4(R9),HEXF1             YES, START NEW PAGE\n         LH    R7,PAGELEN              RELOAD PAGELEN\n         B     FOLDLOOP                WRITE NEXT LINE\nFOLDLAST LR    R15,R4                  LOAD REMAINING LINE LENGTH\n         SH    R15,HALF6               DECREMENT FOR EXECUTE\n         EX    R15,FOLDLINE            EXECUTE FOLD OF LINE\nPUTLAST  STH   R4,0(R9)                INSERT LENGTH FOR PUT\n         PUT   (R5),(R9)               PUT OUT OUTPUT LINE\n         BCTR  R7,0                    DECREMENT PAGELEN\n         BR    R10                     GO GET NEXT RECORD\nEXITI    DS    0H\n         DROP  R9\n         LM    R9,R10,SAVMR9           RESTORE R9 AND R10\n         LM    R6,R7,SAVMR6            RESTORE R6 AND R7\n         LM    R2,R3,SAVMR2            RESTORE R2 AND R3\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** END OF GTEL MOD **************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nEXIT     DS    0H\n         TM    DCBOFLGS,DCBOFOPN       SEE IF INPUT DCB IS OPEN\n         BNO   EXITMSG                 NO....GO PUT OUT DATASET AND\n*                                      MEMBER NAMES\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST IN WORKAREA\n         CLOSE ((R8),),MF=(E,CLOSLST)  CLOSE INPUT DCB\nEXITMSG  DS    0H\n         L     R1,0(,R6)               GET ADDRESS OF DSNAME        WFB\n         CLI   0(R1),C'*'              SEE IF DSNAME IS ASTERISK    WFB\n         BE    EXNOFREE                YES, DO NOT FREE DDN(...)    WFB\n         LA    R1,PRINTI               FREE INPUT DATASET          GTEL\n         BAL   R2,FREEDD               FREE INPUT DATASET          GTEL\nEXNOFREE DS    0H                                                   WFB\n         TM    VOLBIT,NOMSG            IS NOMSG SPECIFIED ?         WFB\n         BO    CONTINUE                YES, CONTINUE WITH NEXT DSN  WFB\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(DSNMSG,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATA SET NAME MESSAGE\n         DROP  R15                                                  WFB\n         LH    R4,DFPBDSL              LOAD LENGTH OF DSNAME       GTEL\n         A     R4,FULL4                INCREMENT LENGTH FOR PUTLINE\n         SLL   R4,16                   SHIFT LENGTH TO HIGH ORDER BYTES\n         STCM  R4,15,DSNLENP           STORE LENGTH OF PUTLINE\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(DSNLENP,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATA SET NAME MESSAGE\n         DROP  R15                                                  WFB\n         CLI   MEMNAME,BLANK           MEMBER NAME BLANK ?          WFB\n         BE    CONTINUE                YES, SKIP MEMBER MESSAGE     WFB\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(MEMMSG,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATA SET NAME MESSAGE\n         DROP  R15                                                  WFB\n         MVC   MEMNAMEL(2),HALF12      FORCE MEMNAME LENGTH 8 (+4)  WFB\n         MVC   MEMNAMEL+2(2),HALF0     (REQUIRED ZERO FOR PUTLINE)  WFB\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(MEMNAMEL,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      MEMBER NAME\n         DROP  R15                                                  WFB\n         B     CONTINUE                GO CONTINUE WITH NEXT DATASET\n         DROP  R8                      DROP ADDRESSABILITY TO INPUT DCB\nERRI     DS    0H\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(SYNADI,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATASET NOT PRINTED DUE TO SYNAD\n*                                      ERROR ON INPUT DATASET MESSAGE\n         DROP  R15                                                  WFB\n         B     EXIT                    GO SEE IF INPUT DCB IS OPEN\nERRO     DS    0H\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(SYNADO,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATASET NOT PRINTED DUE TO\n*                                      SYNAD ERROR MESSAGE          WFB\n         DROP  R15                                                  WFB\n         B     CLOSDCBS                GO CLOSE OPEN DCBS AND RETURN\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        READ THE DIRECTORY OF A PDS                                  *\n*           THEN EITHER LIST MEMBER NAMES,                            *\n*           PRINT MEMBERS,                                            *\n*           OR LIST MEMBER NAMES AND PRINT MEMBERS                    *\n*                                                                     *\n***********************************************************************\n*\nSCROLLIT DS    0H\n         ST    R6,SAVER6               SAVE REGISTER 6\n         L     R9,PARSBACK             LOAD ADDRESS PARS ANSWER\n         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY TO PDL\n         CLC   PLIST,HALF2             SEE IF NOLIST SPECIFIED\n         BL    CONTSCR                 LOW....CONTINUE WITH SCROLL\n         CLC   PPRINT,HALF2            SEE IF NOPRINT SPECIFIED\n         BE    CONTINUE                YES....SKIP SCROLL\n         DROP  R9                      DROP ADDRESSABILITY TO PDL\nCONTSCR  DS    0H\n         LA    R8,DIRECT               LOAD POINTER TO DIRECTORY DCB\n         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB\n         MVC   DIRECT(DIRECTL),DIRECTC MOVE DIRECTORY DCB CONSTANT INTO\n*                                      DIRECTORY DCB IN WORKAREA\n         L     R1,0(,R6)               GET ADDRESS OF DSNAME        WFB\n         CLI   0(R1),C'*'              SEE IF DSNAME IS ASTERISK    WFB\n         BNE   OPENDIR                 NO, GO OPEN INPUT DIRECTORY  WFB\n         MVC   DCBDDNAM,PREALDDN       YES, USE PREALLOCATED DDN(.) WFB\nOPENDIR  DS    0H                                                   WFB\n         MVC   OPENLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO OPEN LIST IN WORKAREA\n         OPEN  ((R8),INPUT),MF=(E,OPENLST)  OPEN DIRECTORY DCB\n         TM    DCBOFLGS,DCBOFOPN       SEE IF DCB OPENED SUCCESSFULLY\n         BNO   NOTPMESS                NO.....GO PUT OUT NOT PRINTED\n*                                      MESSAGE\n         DROP  R8                      DROP ADDRESSABILITY TO DCB\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        GETMAIN MEMBER TABLE FOR STORAGE OF DIRECTORY NAMES, ETC.    *\n*           INITIALIZE TABLE                                          *\n*                                                                     *\n***********************************************************************\n*\n         L     R0,MEMDATL              LOAD LENGTH OF GETMAIN FOR\n*                                      MEMBER TABLE\n         LR    R2,R0                   SAVE IN REGISTER 2\n         GETMAIN R,LV=(0)              GETMAIN MEMBER TABLE STORAGE\n         ST    R1,MEMTABLE             SAVE ADDRESS OF MEMBER TABLE\n         ST    R1,PRESENT              ALSO SAVE ADDRESS AS TABLE\n*                                      IN USE\n         LA    R3,0(R2,R1)             LOAD ADDRESS OF END OF TABLE\n         ST    R3,ENDTABLE             STORE ADDRESS OF TABLE END\n         SLR   R4,R4                   ZERO REGISTER 4\n         ST    R4,0(R1)                STORE AS FIRST WORD OF MEMBER\n*                                      TABLE\n         LA    R4,8(R1)                LOAD REGISTER 4 AS POINTER TO\n*                                      THE FIRST ENTRY\n         USING MEMDSECT,R4             ESTABLISH ADDRESSABILITY TO\n*                                      MEMBER TABLE DSECT\n         SLR   R5,R5                   INITIALIZE MEMBER COUNT TO ZERO\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        READ DIRECTORY AND BUILD MEMBER TABLE                        *\n*                                                                     *\n***********************************************************************\n*\nGETDIR   EQU   *\n         GET   (R8),DATA               GET A DIRECTORY BLOCK\n         CLC   DATA,HALF12             SEE IF BLOCK IS UNUSED\n         BL    FREEBLK                 YES....GO HANDLE DIRECTORY END\n         LA    R9,DATA+2               LOAD POINTER TO FIRST DIRECTORY\n*                                      ENTRY\n         SLR   R7,R7                   ZERO REGISTER 7 FOR INSERT\n         ICM   R7,3,DATA               INSERT LENGTH USED OF THIS BLOCK\n         LA    R7,DATA-1(R7)           LOAD LAST USED BYTE OF BLOCK\nUNBLOCK  DS    0H\n         MVC   MEMNTTR,0(R9)           PUT NAME AND TTR IN TABLE\n         MVC   CFIELD,11(R9)           PUT C FIELD IN TABLE\n         CLI   MEMBER,HEXFF            SEE IF LAST MEMBER\n         BE    FREEBLK                 YES....GO HANDLE DIRECTORY END\n         IC    R6,CFIELD               INSERT CFIELD INTO REGISTER 6\n         SLL   R6,27                   SHIFT OUT HIGH ORDER BITS\n         SRL   R6,26                   SHIFT RIGHT TO GET LENGTH OF\n*                                      USER DATA\n         LA    R6,12(R6)               ADD STANDARD ENTRY LENGTH\n         LA    R4,MEMSECTN             LOAD PINTER TO NEXT TABLE ENTRY\n         LA    R5,1(R5)                INCREMENT NUMBER OF MEMBERS IN\n*                                      TABLE\n         C     R4,ENDTABLE             SEE IF END OF TABLE\n         BL    NEXTNTRY                LOW.....GO PROCESS NEXT ENTRY\n         LR    R0,R2                   LOAD LENGTH OF TABLE FOR GETMAIN\n         GETMAIN R,LV=(0)              GET NEXT TABLE\n         L     R14,PRESENT             LOAD REGISTER 14 WITH ADDRESS OF\n*                                      LAST TABLE\n         ST    R1,0(R14)               CHAIN MEMBER TABLES TOGETHER\n         ST    R1,PRESENT              ALSO SAVE ADDRESS AS TABLE\n*                                      IN USE\n         LA    R3,0(R2,R1)             LOAD ADDRESS OF TABLE END\n         ST    R3,ENDTABLE             STORE ADDRESS OF TABLE END\n         SLR   R4,R4                   ZERO REGISTER 4\n         ST    R4,0(R1)                STORE AS FIRST WORD OF MEMBER\n*                                      TABLE\n         LA    R4,8(R1)                LOAD REGISTER 4 AS POINTER TO\n*                                      THE FIRST ENTRY\n         STH   R5,4(R14)               STORE MEMBER COUNT IN OLD TABLE\n         SLR   R5,R5                   INITIALIZE MEMBER COUNT TO ZERO\nNEXTNTRY DS    0H\n         BXLE  R9,R6,UNBLOCK           INCREMENT REGISTER 9 WITH\n*                                      REGISTER 6 AND BRANCH\n*                                      LESS THAN OR EQUAL TO\n*                                      REGISTER 7 TO UNBLOCK\n         B     GETDIR                  NO.....GO GET NEXT DIRECTORY\n*                                      BLOCK\n         DROP  R4                      DROP ADDRESSABILITY TO TABLE\n*\n***********************************************************************\n*                                                                     *\n*        LIST MEMBERS IF:                                             *\n*           LIST SPECIFIED OR                                         *\n*           BOTH PRINT AND NOLIST WERE NOT SPECIFIED                  *\n*                                                                     *\n***********************************************************************\n*\nFREEBLK  DS    0H\n         MVC   OPENLST,OPENCLOS        MOVE CONSTANT INTO CLOSE LIST\n         CLOSE ((R8),),MF=(E,OPENLST)  CLOSE DIRECTORY DCB\n         L     R2,PRESENT              LOAD POINTER TO LAST TABLE\n         STH   R5,4(R2)                STORE COUNT OF MEMBERS\n         L     R4,MEMTABLE             LOAD POINTER TO FIRST TABLE\n         CLC   4(2,R4),HALF0           SEE IF THERE WERE ANY MEMBERS\n         BE    ENDMEMB                 ZERO...GO FREE MEMBER TABLE\n         LA    R8,INPUT                LOAD POINTER TO INPUT DCB\n         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB\n         MVC   INPUT(INPUTL),INPUTC    MOVE INPUT DCB CONSTANT INTO\n*                                      INPUT DCB IN WORKAREA\n         L     R1,SAVER6               GET SAVED ADDRESS OF DSN PDE WFB\n         L     R1,0(,R1)               GET ADDRESS OF DSNAME        WFB\n         CLI   0(R1),C'*'              SEE IF DSNAME IS ASTERISK    WFB\n         BNE   OPENMEM                 NO, GO OPEN AGAIN FOR MEMBER WFB\n         MVC   DCBDDNAM,PREALDDN       MOVE DDNAME INTO INPUT DCB   WFB\nOPENMEM  DS    0H                                                   WFB\n         MVC   OPENLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO OPEN LIST IN WORKAREA\n         LA    R1,XLIST                LOAD ADDRESS OF EXIT LIST\n         ST    R1,DCBEXLST             STORE ADDRESS OF EXIT LIST IN\n*                                      DCB\n         LA    R1,SEXIT                LOAD ADDRESS OF EODAD EXIT\n         ST    R1,DCBEODAD             STORE ADDRESS EODAD IN DCB\n         LA    R2,JFCBAREA             LOAD ADDRESS OF JFCBAREA\n         ST    R2,XLIST                STORE ADDRESS IN EXIT LIST\n         MVI   XLIST,X'87'             SET END OF LIST AND JFCB BYTE\n         MVC   RDJL,OPENCLOS           MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO READJFCB LIST IN\n*                                      WORKAREA\n         RDJFCB (INPUT,),MF=(E,RDJL)   READ JFCB INTO JFCBAREA\n         MVC   JFCBELNM,8(R4)          MOVE MEMBER NAME INTO JFCB\n         OI    JFCBIND1,JFCPDS         SET JFCB TO INDICATE PDS MEMBER\n         MVI   JFCDSRG1,HEX00          SET JFCB TO REMOVE OTHER DSORG\n*                                      INDICATORS\n         OPEN  ((R8),INPUT),TYPE=J,MF=(E,OPENLST)  OPEN INPUT DCB\n         L     R9,PARSBACK             LOAD ADDRESS PARS ANSWER\n         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY TO PDL\n         CLC   PLIST,HALF2             SEE IF NOLIST SPECIFIED\n         BE    NOLIST                  YES....SKIP LISTING\n         CLC   PLIST,HALF1             SEE IF LIST SPECIFIED\n         BE    LISTIT                  YES....GO LISTIT\n         CLC   PPRINT,HALF1            SEE IF PRINT SPECIFIED\n         BE    NOLIST                  YES....SKIP LISTING\n         DROP  R9                      DROP ADDRESSABILITY TO PDL\nLISTIT   DS    0H\n         MVC   HEADER,HEADERM          MOVE HEADER INTO DATA AREA\n         TM    DCBRECFM,DCBRECCM       SEE IF CONTROL IS MACHINE\n         DROP  R8                      DROP ADDRESSABILITY TO DCB\n         BNO   SUSEA                   NO.....GO TO USE ASA CONTROL\n         LA    R5,OUTPUTM              LOAD ADDRESS OF OUTPUT DCB FOR\n*                                      MACHINE CODE\n         LA    R4,EJECTM               LOAD ADDRESS OF EJECT DATA\n         MVI   HDRCNTL,SKIPM           MOVE INTO HEADER MACHINE CODE\n*                                      FOR SPACE\n         TM    48(R5),DCBOFOPN         SEE IF DCB IS ALREADY OPEN\n         BO    SPUTDSN                 YES....GO PUT OUT HEADERS\n         LA    R3,PRINTM               LOAD POINTER TO PRINTM\n         LA    R14,SPUTDSN             LOAD ADDRESS FOR RETURN FROM\n*                                      SYSOUT ALLOCATION\n         B     ALLOCOUT                GO TO ALLOCATE SYSOUT\nSUSEA    DS    0H\n         LA    R5,OUTPUTA              LOAD ADDRESS OF OUTPUT DCB FOR\n*                                      ASA CODE\n         LA    R4,EJECTA               LOAD ADDRESS OF EJECT DATA\n         TM    48(R5),DCBOFOPN         SEE IF DCB IS ALREADY OPEN\n         BO    SPUTDSN                 YES....GO PUT OUT HEADERS\n         LA    R3,PRINTA               LOAD POINTER TO PRINTA\n         BAL   R14,ALLOCOUT            LOAD ADDRESS FOR RETURN AND GO\n*                                      DO SYSOUT ALLOCATION\nSPUTDSN  DS    0H\n         PUT   (R5),(R4)               PUT OUT PAGE EJECT\n         PUT   (R5),HEADER             PUT OUT PAGE 1 HEADER\n         MVC   HEADER2,LDSNAME         MOVE LENGTH AND 'DSNAME=' INTO\n*                                      INTO SECOND HEADER\n         MVC   HEADER2+4(1),HDRCNTL    MOVE IN CONTROL BYTE\n         MVI   OPENPRN,BLANK           BLANK OUT MEMBER NAME\n         MVC   MEMNAME(9),OPENPRN      FINISH BLANKING OUT MEMBER NAME\n         PUT   (R5),HEADER2            PUT OUT PAGE 1 HEADER 2\n         L     R2,MEMTABLE             LOAD ADDRESS OF FIRST TABLE\n         MVC   LENGTH,HALF85           SET LENGTH TO 85 BYTES\n         MVC   LENGTH+2,HALF0          ZERO RESERVED BYTES\n         MVC   CNTLBYTE,HDRCNTL        MOVE IN HEADER CONTROL BYTE\n*\n***********************************************************************\n*                                                                     *\n*        LIST MEMBER NAMES                                            *\n*                                                                     *\n***********************************************************************\n*\nSCROLLER DS    0H\n         LA    R10,50                  LOAD LINE COUNT\n         ST    R2,PRESENT              SAVE ADDRESS OF CURRENT TABLE\n         LH    R7,4(R2)                LOAD NUMBER OF MEMBERS IN TABLE\n         LTR   R7,R7                   SEE IF THERE ARE ENTRIES\n         BZ    NOLIST                  NO.....GO PRINT MEMBERS\n         LA    R2,8(R2)                LOAD ADDRESS OF FIRST MEMBER\n         USING MEMDSECT,R2             ESTABLISH ADDRESSABILITY TO\n*                                      MEMBER TABLE ENTRY\nLOOP1    DS    0H\n         LA    R6,DATA                 LOAD ADDRESS OF OUTPUT BUFFER\n         MVI   DATA,BLANK              BLANK OUT OUTPUT BUFFER\n         MVC   DATA+1(79),DATA         FINISH BLANKING BUFFER\n         TM    CFIELD,HIGH             SEE IF THIS IS AN ALIAS\n         BZ    NOTALIAS                NO.....CONTINUE WITH MAIN NAME\n         BAL   R14,LOOKLOOP            GO LOOK FOR MAIN NAME\nNOTALIAS DS    0H\n         MVC   2(8,R6),MEMBER          PUT MEMBER NAME IN OUTPUT BUFFER\n         ST    R2,SAVER2               SAVE REGISTER 2\n         LA    R3,2                    LOAD NUMBER OF COLUMNS LEFT\n         LA    R8,1                    LOAD ENTRY NUMBER\nLOOP2    LA    R8,50(R8)               LOAD POINTER TO NEXT COLUMN\n*                                      ENTRY\n         CR    R8,R7                   SEE IF VALID ENTRY\n         BH    END2                    NO.....GO PRINT LINE\n         LA    R2,600(R2)              LOAD POINTER TO MEMBER NAME\n         LA    R6,30(R6)               LOAD POINTER TO NEXT OUTPUT\n*                                      BUFFER LOCATION\n         TM    CFIELD,HIGH             SEE IF THIS IS AN ALIAS\n         BZ    NOTAL2                  NO.....CONTINUE WITH MAIN NAME\n         BAL   R14,LOOKLOOP            GO LOOK FOR MAIN NAME\nNOTAL2   DS    0H\n         MVC   2(8,R6),MEMBER          PUT MEMBER NAME IN OUTPUT BUFFER\n         BCT   R3,LOOP2                DECREMENT COLUMN COUNT\nEND2     DS    0H\n         PUT   (R5),LINE               PUT OUT OUTPUT LINE\n         L     R2,SAVER2               RELOAD REGISTER 2\n         LA    R2,MEMSECTN             LOAD POINTER TO NEXT MEMBER NAME\n         BCT   R10,MOREROW             DECREMENT ROW COUNT\n         PUT   (R5),(R4)               PUT OUT PAGE EJECT WHEN ZERO\n         B     LOOP3                   RESET COUNTERS\nMOREROW  DS    0H\n         BCT   R7,LOOP1                DECREMENT MEMBER COUNT FOR\n*                                      CURRENT TABLE\nLOOP3    L     R2,PRESENT              LOAD POINTER TO CURRENT TABLE\n         L     R2,0(R2)                LOAD POINTER TO NEXT TABLE\n         LTR   R2,R2                   SEE IF IT WAS THE LAST TABLE\n         BNZ   SCROLLER                NO.....GO LIST OUT NEXT TABLE\n*\n***********************************************************************\n*                                                                     *\n*        PRINT MEMBERS IF:                                            *\n*           PRINT SPECIFIED OR                                        *\n*           BOTH LIST AND NOPRINT WERE NOT SPECIFIED                  *\n*                                                                     *\n***********************************************************************\n*\nNOLIST   DS    0H\n         L     R9,PARSBACK             LOAD ADDRESS PARS ANSWER\n         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY TO PDL\n         CLC   PPRINT,HALF2            SEE IF NOPRINT SPECIFIED\n         BE    ENDMEMB                 YES....GO SKIP PRINT\n         CLC   PPRINT,HALF1            SEE IF PRINT SPECIFIED\n         BE    CONTPRT                 YES....GO PRINT MEMBERS\n         CLC   PLIST,HALF1             SEE IF LIST SPECIFIED\n         BE    ENDMEMB                 YES....GO SKIP PRINT\n         DROP  R9                      DROP ADDRESSABILITY TO PDL\nCONTPRT  DS    0H\n         L     R6,SAVER6               RESTORE REGISTER 6\n         LA    R8,INPUT                LOAD ADDRESS OF INPUT DCB\n         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST IN WORKAREA\n         CLOSE ((R8),),MF=(E,CLOSLST)  CLOSE INPUT DCB\n         DROP  R8                      DROP ADDRESSABILITY TO INPUT DCB\n         TM    VOLBIT,NOMSG            IS NOMSG SPECIFIED ?         WFB\n         BO    NOMEMMSG                YES, SKIP MEMBER MESSAGE     WFB\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(PRTMSG,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATASET PRINT MESSAGE\n         DROP  R15                                                  WFB\n         LH    R4,DFPBDSL              LOAD LENGTH OF DSNAME       GTEL\n         A     R4,FULL4                INCREMENT LENGTH FOR PUTLINE\n         SLL   R4,16                   SHIFT LENGTH TO HIGH ORDER BYTES\n         STCM  R4,15,DSNLENP           STORE LENGTH OF PUTLINE\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(DSNLENP,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATA SET NAME MESSAGE\n         DROP  R15                                                  WFB\nNOMEMMSG DS    0H                                                   WFB\n         L     R2,MEMTABLE             LOAD ADDRESS OF FIRST MEMBER\n*                                      TABLE\n         LH    R3,4(R2)                LOAD NUMBER OF MEMBERS IN TABLE\n         LTR   R3,R3                   SEE IF THERE ARE ANY MEMBERS\n         BZ    ENDMEMB                 NO.....GO TO END OF SCROLLER\n         ST    R2,PRESENT              SAVE ADDRESS OF CURRENT TABLE\n         LA    R2,8(R2)                LOAD POINTER TO MEMBER NAME\nNEXTMEMB DS    0H\n         TM    CFIELD,HIGH             SEE IF THIS IS AN ALIAS ENTRY\n         BO    AGAIN                   YES....DO NOT PRINT IT\nPRINTMEM DS    0H\n         MVC   MEMNAME,MEMBER          MOVE MEMBER NAME INTO HEADER\n         MVC   JFCBELNM,MEMBER         MOVE MEMBER NAME INTO JFCBAREA\n         MVC   OPENLST,OPENCLOS        MOVE CONSTANT INTO OPEN LIST\n         OPEN  ((R8),INPUT),TYPE=J,MF=(E,OPENLST)\n*                                      OPEN INPUT DCB\n         STM   R2,R3,SAVER2            SAVE REGISTERS 2 AND 3\n         B     PRINTS                  GO PRINT MEMBER\nSEXIT    DS    0H\n         LM    R2,R3,SAVER2            RESTORE REGISTERS 2 AND 3\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST IN WORKAREA\n         CLOSE ((R8),),MF=(E,CLOSLST)  CLOSE INPUT DCB\nAGAIN    DS    0H\n         LA    R2,MEMSECTN             LOAD ADDRESS OF NEXT MEMBER\n         BCT   R3,NEXTMEMB             BRANCH TO HANDLE NEXT MEMBER\n         L     R14,PRESENT             ZERO...LOAD CURRENT TABLE\n*                                      ADDRESS\n         L     R2,0(R14)               LOAD ADDRESS OF NEXT TABLE\n         LTR   R2,R2                   SEE IF ZERO, LAST TABLE\n         BZ    ENDMEMB                 NO.....GO HANDLE END OF MEMBERS\n         ST    R2,PRESENT              SAVE ADDRESS OF CURRENT TABLE\n         LH    R3,4(R2)                LOAD NUMBER OF MEMBERS IN NEXT\n*                                      TABLE\n         LTR   R3,R3                   SEE IF ANY MEMBERS IN TABLE\n         BZ    ENDMEMB                 NO.....GO HANDLE END OF MEMBERS\n         LA    R2,8(R2)                LOAD POINTER TO MEMBER NAME\n         B     NEXTMEMB                GO GET NEXT MEMBER\nENDMEMB  DS    0H\n         L     R2,MEMTABLE             LOAD POINTER TO FIRST TABLE\nFREETABS DS    0H\n         LR    R1,R2                   LOAD AREA TO BE FREED\n         L     R2,0(R2)                LOAD POINTER TO NEXT TABLE\n         L     R0,MEMDATL              LOAD SIZE OF AREA TO BE FREED\n         FREEMAIN R,LV=(0),A=(1)       FREE STORAGE GETMAINED FOR TABLE\n         LTR   R2,R2                   SEE IF THERE WAS ANOTHER TABLE\n         BNZ   FREETABS                YES....GO FREE NEXT TABLE\n         L     R6,SAVER6               RESTORE REGISTER 6\n         LA    R8,INPUT                LOAD POINTER TO INPUT DCB\n         USING IHADCB,R8               ESTABLISH ADDRESSABILITY TO DCB\n         TM    DCBOFLGS,DCBOFOPN       SEE IF INPUT DCB IS STILL OPEN\n         BNO   EXITMSG                 NO.....GO HANDLE NEXT DATASET\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST IN WORKAREA\n         CLOSE ((R8),),MF=(E,CLOSLST)  CLOSE INPUT DCB\n         DROP  R8                      DROP ADDRESSABILITY TO DCB\n         B     EXITMSG                 GO HANDLE NEXT DATASET\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        PUT OUT SYNAD ERROR MESSAGE,                                 *\n*           GO FREE MEMBER TABLES, AND                                *\n*           CONTINUE WITH NEXT DATASET                                *\n*                                                                     *\n***********************************************************************\n*\nSERRI    DS    0H\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(SYNADI,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DATASET NOT PRINTED DUE TO SYNAD\n*                                      ERROR ON INPUT DATASET MESSAGE\n         DROP  R15                                                  WFB\n         B     ENDMEMB                 GO FREE MEMBER TABLES\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        SEARCH FOR MAIN NAME,                                        *\n*           SAME TTR AND NOT AN ALIAS                                 *\n*                                                                     *\n***********************************************************************\n*\nLOOKLOOP DS    0H\n         STM   R3,R4,SAVER3            SAVE REGISTERS 3 AND 4\n         L     R3,MEMTABLE             LOAD ADDRESS OF FIRST TABLE\n         USING MEMDSECT,R3             ESTABLISH ADDRESSABILITY TO\n*                                      MEMBER ENTRY\nLOOP4    DS    0H\n         ST    R3,CURRENT              SAVE ADDRESS OF PRESENT TABLE\n         LH    R4,4(R3)                LOAD NUMBER OF ELEMENTS IN TABLE\n         LTR   R4,R4                   SEE IF THERE ARE ZERO ELEMENTS\n         BZ    NOMAIN                  YES....GO HANDLE MAIN NOT FOUND\n         LA    R3,8(R3)                LOAD ADDRESS OF FIRST MEMBER\nLOOP5    DS    0H\n         CLC   MEMTTR,8(R2)            SEE IF TTRS ARE THE SAME\n         BE    SAMETTR                 YES....GO SEE IF IT IS AN ALIAS\nENDLP5   DS    0H\n         LA    R3,MEMSECTN             LOAD ADDRESS OF NEXT MEMBER\n         BCT   R4,LOOP5                DECREMENT MEMBER COUNT\n         L     R3,CURRENT              LOAD ADDRESS OF THIS TABLE\n         L     R3,0(R3)                LOAD ADDRESS OF NEXT TABLE\n         LTR   R3,R3                   SEE IF IT WAS THE LAST TABLE\n         BNZ   LOOP4                   NO.....GO CHECK NEXT TABLE\n         B     NOMAIN                  GO HANDLE MAIN NOT FOUND\nSAMETTR  DS    0H\n         TM    CFIELD,HIGH             SEE IF THIS IS ALSO AN ALIAS\n         BO    ENDLP5                  YES....GO LOOK FOR ANOTHER TTR\n         MVC   11(8,R6),MEMBER         MOVE MEMBER NAME INTO OUTPUT\n         B     ENDLOOK                 GO TO RETURN TO CALLER\nNOMAIN   DS    0H\n         MVC   11(8,R6),ALIAS          INDICATE THIS IS AN ALIAS\nENDLOOK  DS    0H\n         LM    R3,R4,SAVER3            RESTORE REGISTERS 3 AND 4\n         BR    R14                     RETURN TO CALLER\n         DROP  R3                      DROP ADDRESSABILITY TO TABLE\n*\nCONTINUE DS    0H\n         L     R1,0(,R6)               GET ADDRESS OF DSNAME        WFB\n         CLI   0(R1),C'*'              SEE IF DSNAME IS ASTERISK    WFB\n         BE    CLOSDCBS                YES, DO NOT FOLLOW CHAIN     WFB\n         L     R6,24(R6)               LOAD POINTER TO NEXT DSNAME ON\n*                                      CHAIN\n         C     R6,ENDCHAIN             SEE IF END OF CHAIN IS REACHED\n         BNE   NEXT                    NO.....GO DO NEXT DATASET NAME\nCLOSDCBS DS    0H\n         TM    INPUT+48,DCBOFOPN       SEE IF INPUT DCB IS STILL OPEN\n         BNO   CHKOUTA                 NO.....GO CHECK DCB FOR ASA CODE\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST WORKAREA\n         LA    R5,INPUT                LOAD POINTER TO INPUT DCB\n         CLOSE ((R5),),MF=(E,CLOSLST)  CLOSE INPUT DCB\n         L     R1,0(,R6)               GET ADDRESS OF DSNAME        WFB\n         CLI   0(R1),C'*'              SEE IF DSNAME IS ASTERISK    WFB\n         BE    CHKOUTA                 YES, DO NOT FREE DDN(...)    WFB\n         LA    R1,PRINTI               FREE INPUT DATASET          GTEL\n         BAL   R2,FREEDD               FREE INPUT DATASET          GTEL\nCHKOUTA  DS    0H\n         TM    OUTPUTA+48,DCBOFOPN     SEE IF OUTPUT DCB FOR ASA WAS\n*                                      OPENED\n         BNO   CHKOUTM                 NO.....GO CHECK DCB FOR MACHINE\n*                                      CODE\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST WORKAREA\n         LA    R5,OUTPUTA              LOAD POINTER TO ASA CODE DCB\n         TM    VOLBIT,UDKDONE          WERE UDKS WRITTEN ?          WFB\n         BZ    CLOSEA                  NO, GO CLOSE                 WFB\n         PUT   (R5),UDKRESET           PUT OUT UDK RESET TEXT       WFB\n         NI    VOLBIT,UDKDONE          TURN OFF UDK WRITTEN FLAG    WFB\nCLOSEA   DS    0H                                                   WFB\n         CLOSE ((R5),),MF=(E,CLOSLST)  CLOSE ASA CODE OUTPUT DCB\n         LA    R1,PRINTA               LOAD ADDRESS OF PRINT DDNAME\n         BAL   R2,FREEDD               GO FREE ASA CODE OUTPUT DDNAME\nCHKOUTM  DS    0H\n         TM    OUTPUTM+48,DCBOFOPN     SEE IF OUTPUT DCB FOR MACHINE\n*                                      CODE WAS OPENED\n         BNO   RETURN                  NO.....GO FREE GETMAINED AREAS\n*                                      AND RETURN\n         MVC   CLOSLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO CLOSE LIST WORKAREA\n         LA    R5,OUTPUTM              LOAD POINTER TO MACHINE CODE DCB\n         TM    VOLBIT,UDKDONE          WERE UDKS WRITTEN ?          WFB\n         BZ    CLOSEM                  NO, GO CLOSE                 WFB\n         PUT   (R5),UDKRESET           PUT OUT UDK RESET TEXT       WFB\n         NI    VOLBIT,UDKDONE          TURN OFF UDK WRITTEN FLAG    WFB\nCLOSEM   DS    0H                                                   WFB\n         CLOSE ((R5),),MF=(E,CLOSLST)  CLOSE MACHINE CODE OUTPUT DCB\n         LA    R1,PRINTM               LOAD ADDRESS OF PRINT DDNAME\n         BAL   R2,FREEDD               GO FREE MACHINE CODE OUTPUT\n*                                      DDNAME\n*\n***********************************************************************\n*                                                                     *\n*        CLEANUP AREAS GETMAINED BY PARS,                             *\n*           SET RETURN CODE, RESTORE REGISTERS AND                    *\n*           RETURN TO CALLER                                          *\n*                                                                     *\n***********************************************************************\n*\nRETURN   DS    0H\n         IKJRLSA PARSBACK              RELEASE AREAS GETMAINED BY PARS\n         L     R1,ALNDSECT\n         FREEMAIN R,LV=RECSIZE,A=(1)                                WFB\n         LR    R1,R13                  LOAD ADDRESS OF GETMAINED AREA\n         L     R13,4(,R13)             RELOAD ADDRESS OF PREVIOUS SAVE\n*                                      AREA\n         LA    R0,LDYNAMIC             LOAD LENGTH OF GETMAINED AREA\n         FREEMAIN R,LV=(0),A=(1)       FREE GETMAINED AREA\n         SLR   R15,R15                 ZERO REGISTER 15.  RETURN CODE\n*                                      CODE WILL ALWAYS BE ZERO\n         L     R14,12(,R13)            LOAD REGISTER 14 WITH RETURN\n*                                      ADDRESS\n         LM    R0,R12,20(R13)          RESTORE REGISTERS\n         BR    R14                     RETURN\n*\n***********************************************************************\n*                                                                     *\n*        ROUTINE TO CONVERT NONZERO RETURN CODES TO DECIMAL           *\n*           FOR DISPLAY                                               *\n*                                                                     *\n***********************************************************************\n*\nSETCODE  DS    0H\n         CVD   R8,DEC                  CONVERT RETURN CODE TO DECIMAL\n         UNPK  CONV(8),DEC(8)          UNPACK RETURN CODE\n         MVZ   CONV+1(7),CONV          MOVE ZONES IN CONVERTED RETURN\n*                                      CODE\n         MVC   RETNCD(2),HALF12        MOVE LENGTH OF DATA FOR PUTLINE\n         MVC   RETNCD+2(2),HALF0       MOVE IN ZEROES FOR PUTLINE\n         BR    R14                     RETURN\n*\n***********************************************************************\n*                                                                     *\n*        FREE AND REALOCATE PRINTX FILE AS SYSOUT                     *\n*                                                                     *\n***********************************************************************\n*\nALLOCOUT DS    0H\n         STM   14,9,ALCSAVE            SAVE WORK REGISTERS\n*---------------------------------------------------------------------*\n*------------------------- START OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\n         MVC   SETPRTE(SETPRTEL),SETPRTL MOVE SETPRT LIST\n         MVI   SETFLAG,X'00'             AND CLEAR FLAG\n*---------------------------------------------------------------------*\n*--------------------------- END OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\n         LR    R1,R3                   LOAD POINTER TO DDNAME\n         BAL   R2,FREEDD               BRANCH TO FREE ROUTINE\n         LTR   R8,R8                   SEE IF RETURN CODE FROM FREE IS\n*                                      ZERO\n         BNZ   OPENFAIL                NO.....GO PUT OUT OPEN FAILED\n         LA    R8,REQBLK               LOAD POINTER TO REQUEST BLOCK\n         ST    R8,RBPTR                INITIALIZE REQUEST BLOCK POINTER\n         MVI   RBPTR,S99RBPND          INDICATE END OF PARAMETER LIST\n         USING S99RB,R8                ESTABLISH ADDRESSABILITY TO\n*                                      REQUEST BLOCK\n         MVC   S99RBLN(RBLEN),REQBLKC  INITALIZE RB\n         LA    R1,TEXTPTRS             LOAD POINTER TO TEXT POINTERS\n         ST    R1,S99TXTPP             STORE POINTER IN RB\n         DROP  R8                      DROP ADDRESSABILITY TO RB\n         USING S99TUPL,R1              ESTABLISH ADDRESSABILITY TO\n*                                      TEXT UNIT POINTER LIST\n         LA    R2,TEXTA                LOAD POINTER TO FIRST TEXT UNIT\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\n         USING S99TUNIT,R2             ESTABLISH ADDRESSABILITY TO\n*                                      TEXT UNIT\n         MVC   S99TUKEY(TEXTALEN),TEXTAC  INITIALIZE TEXT UNIT A\n         MVC   S99TUPAR(8),0(R3)       MOVE IN PARAMETER (DDNAME)\n         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT\n*                                      POINTER\n         LA    R2,TEXTB                LOAD POINTER TO TEXT UNIT B\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\n         MVC   S99TUKEY(TEXTBLEN),TEXTBC  INITIALIZE TEXT UNIT B\n*\n***********************************************************************\n*                                                                     *\n*        SET UP ADDRESSABILITY TO PDL                                 *\n*           AND SEE IF SYSOUT CLASS/DEST ARE PRESENT                  *\n*           ALSO FORMS/TRAIN/FCB/PROG.                             GTEL\n***********************************************************************\n*\n         L     R9,PARSBACK             LOAD ADDRESS PARS ANSWER\n         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY TO PDL\n         CLC   PCLASS(2),HALF1         SEE IF CLASS SPECIFIED\n         BNE   NOCLASS                 NO.....GO CHECK FOR DESTINATION\n         L     R7,SCLASS               LOAD POINTER TO SYSOUT CLASS\n         MVC   S99TUPAR,0(R7)          MOVE CLASS INTO TEXT UNIT B\nNOCLASS  DS    0H\n         CLC   PDEST(2),HALF1          SEE IF DEST SPECIFIED\n         BNE   NODEST                  NO.....GO CHECK FOR HOLD\n         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT\n*                                      POINTER\n         LA    R2,TEXTC                LOAD POINTER TO TEXT UNIT C\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\n         MVC   S99TUKEY(TEXTCLEN),TEXTCC  INITIALIZE TEXT UNIT C\n         L     R7,SDEST                LOAD POINTER TO DESTINATION\n         CLI   NODELEN+1,0             IS NODE.USERID SPECIFIED ?   WFB\n         BZ    NONODE                  NO, USE TOTAL LENGTH         WFB\n         LH    R6,NODELEN              YES, USE NODE LENGTH         WFB\n         STH   R6,S99TULNG             STORE LENGTH OF DEST IN TU   WFB\n         BCTR  R6,0                    DECREMENT LENGTH FOR EXECUTE WFB\n         EX    R6,MOVEDEST             MOVE NODE INTO TEXT UNIT     WFB\n         LA    R1,4(,R1)               POINT NEXT TEXT UNIT POINTER WFB\n         LA    R2,TEXTK                ADDRESS TEXT UNIT K - USERID WFB\n         ST    R2,S99TUPTR             STORE ADDRESS IN TUPL        WFB\n         MVC   S99TUKEY(TEXTKLEN),TEXTKC  INITIALIZE TEXT UNIT K    WFB\n         LA    R7,2(R6,R7)             POINT PAST 'NODE.' TO USERID WFB\n         LH    R6,SDEST+4              GET TOTAL LENGTH             WFB\n         SH    R6,NODELEN              MINUS NODE LENGTH            WFB\n         SH    R6,HALF2                MINUS 1 FOR DOT, 1 EXECUTE   WFB\n         EX    R6,MOVEDEST             MOVE USERID INTO TEXT UNIT   WFB\n         B     NODEST                                               WFB\nNONODE   DS    0H                                                   WFB\n         LH    R6,SDEST+4              LOAD LENGTH OF DESTINATION ID\n         STH   R6,S99TULNG             STORE LENGTH OF DEST IN TU\n         BCTR  R6,0                    DECREMENT LENGTH FOR EXECUTE OF\n*                                      MOVE\n         EX    R6,MOVEDEST             MOVE DEST INTO TU\nMOVEDEST MVC   S99TUPAR,0(R7)          MOVE TO BE EXECUTED\n*\nNODEST   DS    0H\n         CLC   PHOLD(2),HALF1          SEE IF HOLD SPECIFIED\n         BNE   NOHOLD                  NO.....GO CHECK FOR COPIES\n         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT\n*                                      POINTER\n         LA    R2,TEXTDC               LOAD POINTER TO TEXT UNIT C\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\nNOHOLD   DS    0H\n         CLC   PCOPIES(2),HALF1        SEE IF COPY SPECIFIED\n         BNE   NOCOPY                  NO.....GO ZERO ECB\n         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT\n*                                      POINTER\n         LA    R2,TEXTE                LOAD POINTER TO TEXT UNIT E\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\n         MVC   S99TUKEY(TEXTELEN),TEXTEC  INITIALIZE TEXT UNIT E\n         L     R7,SCOPIES              LOAD POINTER TO COPY FIELD\n         LH    R6,SCOPIES+4            LOAD LENGTH OF COPY FIELD\n         BCTR  R6,0                    DECREMENT REGISTER 6 FOR EXECUTE\n*                                      OF PACK INSTRUCTION\n         EX    R6,PACKCOPY             EXECUTE PACK TO CONVERT COPIES\n*                                      TO ZONED DECIMAL\n         CVB   R6,DEC                  CONVERT ZONED TO BINARY\n         STCM  R6,1,S99TUPAR           STORE NUMBER OF COPIES IN TU\nNOCOPY   DS    0H\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** START OF GTEL MOD ************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         CLC   PFORMS(2),HALF1         SEE IF FORMS SPECIFIED\n         BNE   NOFORMS                 NO.....GO CHECK TRAIN\n         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT\n*                                      POINTER\n         LA    R2,TEXTI                LOAD POINTER TO TEXT UNIT I\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\n         MVC   S99TUKEY(TEXTILEN),TEXTIC  INITIALIZE TEXT UNIT I\n         L     R7,RFORMS               LOAD POINTER TO FORMS FIELD\n         LH    R6,RFORMS+4             LOAD LENGTH OF FORMS FIELD\n         STH   R6,S99TULNG             STORE LENGTH IN TUE\n         BCTR  R6,0                    DECREMENT LENGTH\n         EX    R6,MOVEDEST             MOVE FORMS INTO FIELD\nNOFORMS  DS    0H\n         CLC   PTRAIN(2),HALF1         SEE IF TRAIN SPECIFIED\n         BNE   NOTRAIN                 NO.....GO CHECK FCB\n         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT\n*                                      POINTER\n         LA    R2,TEXTH                LOAD POINTER TO TEXT UNIT G\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\n         MVC   S99TUKEY(TEXTHLEN),TEXTHC  INITIALIZE TEXT UNIT H\n         L     R7,RTRAIN               LOAD POINTER TO TRAIN FIELD\n         LH    R6,RTRAIN+4             LOAD LENGTH OF TRAIN FIELD\n         STH   R6,S99TULNG             SAVE LENGTH OF FCBE\n         BCTR  R6,0                    DECREMENT FOR EX\n         EX    R6,MOVEDEST             MOVE FCB INTO TU\nNOTRAIN  DS    0H\n         CLC   PFCB(2),HALF1           SEE IF FCB  SPECIFIED\n         BNE   NOFCB                   NO.....GO ZERO ECB\n         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT\n*                                      POINTER\n         LA    R2,TEXTG                LOAD POINTER TO TEXT UNIT G\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\n         MVC   S99TUKEY(TEXTGLEN),TEXTGC  INITIALIZE TEXT UNIT G\n         L     R7,RFCB                 LOAD POINTER TO FCB FIELD\n         LH    R6,RFCB+4               LOAD LENGTH OF FCB FIELD\n         STH   R6,S99TULNG             SAVE LENGTH OF FCB IN TUE\n         BCTR  R6,0                    DECREMENT\n         EX    R6,MOVEDEST             MOVE FCB TO TU\nNOFCB    DS    0H\n         CLC   PPROG(2),HALF1          SEE IF PROG SPECIFIED\n         BNE   NOPROG                  NO.....GO ZERO ECB\n         CLI   NODELEN+1,0             IS DEST(NODE.USERID) GIVEN ? WFB\n         BH    NOPROG                  YES, IGNORE PROG             WFB\n*                                      DYNALLOC TEXT UNITS FOR USER WFB\n*                                      AND PROG ARE MUTUAL EXCLUSIV WFB\n         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT\n*                                      POINTER\n         LA    R2,TEXTJ                LOAD POINTER TO TEXT UNIT J\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\n         MVC   S99TUKEY(TEXTJLEN),TEXTJC  INITIALIZE TEXT UNIT J\n         L     R7,RPROG                LOAD POINTER TO PROG FIELD\n         LH    R6,RPROG+4              LOAD LENGTH OF PROG FIELD\n         STH   R6,S99TULNG             SAVE LENGTH OF PROG IN TUE\n         BCTR  R6,0                    DECREMENT FOR MOVE\n         EX    R6,MOVEDEST             MOVE PROG TO TU\nNOPROG   DS    0H\n         CLC   PLINELEN(2),HALF1       SEE IF LL SPECIFIED\n         BNE   LLDEF                   NO...\n         L     R7,RLINELEN             LOAD POINTER TO LL FIELD\n         LH    R6,RLINELEN+4           LOAD LENGTH OF LL FIELD\n         BCTR  R6,0                    DECREMENT FOR PACK\n         EX    R6,ZEROTEST             LINELENGTH 0 ENTERED?\n         BE    LLDEF                   IF YES, USE DEFAULT\n         EX    R6,PACKLEN              CONVERT INTO PACKED DECIMAL\n         CVB   R6,DEC                  CONVERT INTO FIXED BINARY\n         CH    R6,HALF1                LESS THAN ONE?\n         BNL   NOLLDEF                 IF YES, USE DEFAULT\n         CH    R6,HALF208              GREATER THAN 208?\n         BNH   NOLLDEF                 IF YES, USE DEFAULT\nLLDEF    LH    R6,HALF132              PLACE 132 IN R6\nNOLLDEF  STH   R6,LINELEN              STORE INTO LINELEN\n         A     R6,FULL5                ADD LENGTH FOR VB OUTPUT\n         STH   R6,VBLEN                STORE INTO VBLEN1\n         MVI   CCBIT,BLANK             INITIALIZE CCBIT WITH BLANK\n         CLC   PPAGELEN(2),HALF1       SEE IF PL SPECIFIED\n         BNE   PLDEF                   NO...\n         OI    CCBIT,HIGH              YES, SET BIT FOR PAGE LEN\n         L     R7,RPAGELEN             LOAD POINTER TO PL FIELD\n         LH    R6,RPAGELEN+4           LOAD LENGTH OF PL FIELD\n         BCTR  R6,0                    DECREMENT FOR PACK\n         EX    R6,ZEROTEST             PAGELENGTH 0 SPECIFIED?\n         BE    PLDEF                   IF YES, USE DEFAULT\n         EX    R6,PACKPAG              CONVERT INTO PACKED DECIMAL\n         CVB   R6,DEC                  CONVERT INTO FIXED BINARY\n         CH    R6,HALF5                LESS THAN 5?\n         BNL   NOPLDEF                 IF YES, USE DEFAULT\n         CH    R6,HALF120              GREATER THAN 120?         ARAMCO\n         BNH   NOPLDEF                 IF YES, USE DEFAULT\nPLDEF    LH    R6,HALF60               LOAD DEFAULT INTO R6      ARAMCO\nNOPLDEF  STH   R6,PAGELEN              STORE INTO PAGELEN\n         CLC   PSPACE(2),HALF1         SEE IF SINGLE SPACE FORMAT\n         BE    SETSS                   YES...\n         CLC   PSPACE(2),HALF2         SEE IF DOUBLE SPACE FORMAT\n         BE    SETDS                   GO ON\n         CLC   PASA(2),HALF1           USER SAYS ASA IS IN DATA ?   WFB\n         BNE   CCSET                   NO, CONTINUE                 WFB\n         OI    CCBIT,FORCEASA          YES, SET FORCE BIT           WFB\n         B     CCSET                   CONTINUE IF NEITHER SS OR DS\nSETSS    OI    CCBIT,MID1              FOR SINGLE SPACE CC\n         B     CCSET\nSETDS    OI    CCBIT,MID2              FOR DOUBLE SPACE CC\n         LH    R6,PAGELEN              DECREMENT PAGE LENGTH     ARAMCO\n         BCTR  R6,0                                              ARAMCO\n         STH   R6,PAGELEN              BY 1 FOR DS LISTINGS.     ARAMCO\nCCSET    DS    0H\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** END OF GTEL MOD **************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*---------------------------------------------------------------------*\n*------------------------- START OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\n         CLC   PBURST(2),HALF1         WAS BURST PARM \"BURST\"?\n         BNE   NOBURST                 NO, CHECK FLASH\n         OI    SETFLAG,SETBURST        YES, TURN ON FLAG\n         OI    SETPRTE+16,X'80'        AND SET SETPRT BIT\nNOBURST  DS    0H\n         CLC   PFLASH(2),HALF1         ANY FLASH PARM ?\n         BNE   NOFLASH                 NO, CHECK CHARS\n         L     R7,RFLASH               YES, POINT AT PARM\n         LH    R6,RFLASH+4             AND GET LENGTH\n         BCTR  R6,0                    DECREMENT FOR MOVE\n         MVC   SETFLASH(4),BLANKS      BLANK IT OUT\n         MVC   SETFLASH(1),0(R7)\n         EX    R6,*-6                  AND MOVE PARM TO SETPRT\n         OI    SETFLAG,SETFLSH\nNOFLASH  DS    0H\n         CLC   PCHARS(2),HALF1         ANY CHARS PARM ?\n         BNE   CHAREND                 NO, END OF ARAMCO\n         OI    SETFLAG,SETCHAR\n         CLI   RCHARS+8,X'FF'          MORE THAN ONE CHAR SET?\n         BE    CHARSET                 NO, BRANCH\n         USING IHADCB,R15\n         LA    R15,OUTPUTA\n         OI    DCBOPTCD,DCBOPTJ        YES, SET OPTCD=J\n         LA    R15,OUTPUTM AND ON VBM DCB TOO\n         OI    DCBOPTCD,DCBOPTJ\n         DROP  R15\nCHARSET  LA    R15,4                   SET LOOP LIMIT\n         LA    R14,RCHARS              POINT AT FIRST CHARS PDE\n         LA    R2,SETCHARS             AND AT SETPRT CHARS PARM\nCHARLOOP L     R7,0(R14)               POINT TO INPUT CHARS PARM\n         LH    R6,4(R14)               AND GET LENGTH\n         BCTR  R6,0                    DECREMENT FOR MOVE\n         MVC   0(4,R2),BLANKS          BLANK IT OUT\n         MVC   0(0,R2),0(R7)\n         EX    R6,*-6                  AND MOVE PARM TO SETPRT\n         CLI   8(R14),X'FF'            END OF LIST?\n         BE    CHAREND                 YES, EXIT LOOP\n         L     R14,8(R14)              NO, BUMP LOOP\n         LA    R2,4(R2)                POINTERS AND KEEP GOING\n         BCT   R15,CHARLOOP            MAX OF 4 CHARS PARMS\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(CHARMSG,SINGLE,DATA),MF=(E,IOPLSECT)\n         DROP  R15                                                  WFB\n*DELETED B     CHAREND                                              WFB\n*                                      CHARMSG MOVED TO MSG CSECT   WFB\nCHAREND  DS    0H\n*---------------------------------------------------------------------*\n*--------------------------- END OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\n         LA    R1,4(R1)                LOAD POINTER TO NEXT TEXT UNIT\n*                                      POINTER\n         LA    R2,TEXTFC               LOAD POINTER TO TEXT UNIT F\n*                                      PERMANENTLY ALLOCATED\n*                                      ATTRIBUTE\n         ST    R2,S99TUPTR             STORE POINTER IN TUPL\n         MVI   S99TUPTR,S99TUPLN       INDICATE END OF TEXT UNIT\n*                                      POINTER LIST\n         DROP  R1,R2,R9                DROP ADDRESSABILITY TO DSECTS\n         LA    R1,RBPTR                LOAD ADDRESS OF REQUEST BLOCK\n*                                      POINTER\n         DYNALLOC                      ISSUE DYNAMIC ALLOCATION SVC\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO\n         BNZ   ALCFAIL                 NO.....GO AND CALL DAIR FAIL\n         MVC   OPENLST,OPENCLOS        MOVE OPEN(CLOSE) LIST CONSTANT\n*                                      INTO WORKAREA\n         OPEN  ((R5),(OUTPUT)),MF=(E,OPENLST)\n*                                      OPEN OUTPUT DCB\n         TM    48(R5),DCBOFOPN         SEE IF DCB OPENED SUCCESSFULLY\n         BNO   OPENFAIL                NO.....GO PUT OUT OUTPUT DCB\n*---------------------------------------------------------------------*\n*------------------------- START OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\nCKSETPRT CLI   SETFLAG,X'00'           NEED SETPRT ?\n         BE    NOSETPRT                NO, SKIP IT\n         L     R6,DAPLSECT             ADDRESS UPT\n         USING UPT,R6\n         MVC   SAVEUPT(1),UPTSWS       SAVE UPT SWITCHES\n         NI    UPTSWS,X'FF'-UPTWTP     GET RID OF MSG IEF288I\n         SETPRT (R5),MF=(E,SETPRTE)\n         MVC   UPTSWS(1),SAVEUPT       RESTORE UPT SWITCHES\n         DROP R6\nNOSETPRT DS    0H\n*---------------------------------------------------------------------*\n*--------------------------- END OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\n*                                      NOT OPENED MESSAGE\n         LM    14,9,ALCSAVE            RESTORE REGISTERS\n         BR    R14                     RETURN TO CALLER\nALCFAIL  DS    0H\n         LA    R1,REQBLK               LOAD ADDRESS OF REQUEST\n*                                      BLOCK\n         MVI   DFID+1,DFSVC99          SET DAIR FAIL FOR SVC 99 ERROR\n         BAL   R2,DAIRFAIL             LOAD ADDRESS OF OPEN FAIL AND\n*                                      BRANCH TO DAIRFAIL ROUTINE\nOPENFAIL DS    0H\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(OPENMSG,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      OUTPUT DCB NOT OPEND MESSAGE\n         DROP  R15                                                  WFB\n         S     R3,FULL4                GET POINTER TO PUTLINE DDNAME\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=((R3),SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DDNAME\n         DROP  R15                                                  WFB\n         B     CLOSDCBS                GO CLOSE DCBS AND RETURN\n*\n***********************************************************************\n*                                                                     *\n*        INVOKE DAIR TO FREE FILENAME VIA CALLTSSR                    *\n*           AND CHECK FOR ZERO RETURN CODE                            *\n*                                                                     *\n***********************************************************************\n*\nFREEDD   DS    0H\n         SLR   R8,R8                   INITIALIZE REGISTER 8 TO ZERO\n*                                      RETURN CODE\n         MVC   DAP18(DAPB18L),DAPB18C  INITIALIZE DAIR PARAMETER BLOCK\n*                                      18 (FREE BY DATASET)\n         LA    R4,DAP18                LOAD ADDRESS OF DAPB\n         USING DAPB18,R4               ESTABLISH ADDRESSABILITY TO\n*                                      DAPB\n         MVC   DA18DDN,0(R1)           MOVE DDNAME INTO DAPB\n         SLR   R7,R7                   ZERO REGISTER 7\n         ST    R7,ECB                  STORE REGISTER 7 AS DUMMY ECB\n         LA    R1,DAPLSECT             LOAD ADDRESS OF DAPL\n         USING DAPL,R1                 ESTABLISH ADDRESSABILITY TO DAPL\n         ST    R4,DAPLDAPB             STORE ADDRESS OF DAPB IN DAPL\n         DROP  R1,R4                   DROP ADDRESSABILITY TO DAPL AND\n*                                      DAPB\n         CALLTSSR EP=IKJDAIR           CALL DAIR TO FREE DDNAME\n         C     R15,FULL28              SEE IF RETURN CODE IS 28\n*                                      (DDNAME NOT ALLOCATED)\n         BER   R2                      YES....GO CONTINUE PROCESSING\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO\n         BZR   R2                      YES....GO CONTINUE PROCESSING\n         MVI   DFID+1,DFDAIR           SET DAIRFAIL ID TO INDICATE DAIR\n*\n***********************************************************************\n*                                                                     *\n*        INVOKE DAIRFAIL TO DISPLAY AN ERROR MESSAGE                  *\n*                                                                     *\n***********************************************************************\n*\nDAIRFAIL XC    DFPARMS(DFLEN),DFPARMS  INITIALIZE PARMLIST FOR DAIR\n*                                      FAIL TO ZEROS\n         ST    R1,DFDAPLP              STORE POINTER TO DAPL/RB IN\n*                                      PARAMETER LIST\n         ST    R15,RETCODE             STORE RETURN CODE\n         LA    R1,RETCODE              LOAD ADDRESS OF RETURN CODE\n         ST    R1,DFRCP                STORE POINTER TO RETURN CODE IN\n*                                      PARAMETER LIST\n         LA    R1,FULL0                LOAD ADDRESS OF FULLWORD OF\n*                                      ZEROS\n         ST    R1,DFJEFF02             STORE DUMMY POINTER TO IKJEFF02\n*                                      IN PARMLIST\n         LA    R1,DFID                 LOAD ADDRESS OF DAIR FAIL ID\n*                                      FIELD\n         ST    R1,DFIDP                STORE POINTER TO DFID IN\n*                                      PARMLIST\n         MVI   DFID,NOWTP              SET FOR NO WRITE TO PROGRAMMER\n         L     R1,SAVEAREA+4           LOAD ADDRESS OF PEVIOUS\n*                                      SAVEAREA\n         L     R1,24(R1)               LOAD POINTER TO CPPL\n         ST    R1,DFCPPLP              STORE POINTER TO CPPL IN\n*                                      PARMLIST\n         LINK  EP=IKJEFF18,MF=(E,DFPARMS)  LINK TO DAIR FAIL SERVICE\n*                                      ROUTINE TO HANDLE RETURN\n*                                      CODE\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO\n         BZR   R2                      YES....GO RETURN TO CALLER\n         LR    R8,R15                  LOAD REGISTER 8 WITH RETURN CODE\n         BAL   R14,SETCODE             GO CONVERT CODE TO DECIMAL\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(DRFLERR,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DAIR FAIL ERROR MESSAGE\n         L     R15,MSGCSECT            GET ADDRESS OF MESSAGE CSECT WFB\n         USING MESSAGES,R15            ESTABLISH ADDRESSABILITY     WFB\n         PUTLINE OUTPUT=(RETNCD,SINGLE,DATA),MF=(E,IOPLSECT)  PUT OUT\n*                                      DECIMAL RETURN CODE\n         DROP  R15                                                  WFB\n         BR    R2                      GO RETURN TO CALLER\n*\n******************** INSTRUCTIONS TO BE EXECUTED **********************\n*\nFOLDLINE OC    5(0,R9),BLANKS                                      GTEL\nMOVEDSN  MVC   DSNBUF(0),0(R5)\nMOVEVOL  MVC   VOLUME(0),0(R7)\nMOVEUNIT MVC   UNIT(0),0(R7)                                        WFB\nPACKLEN  PACK  DEC(8),0(0,R7)                                      GTEL\nPACKPAG  PACK  DEC(8),0(0,R7)                                      GTEL\nPACKCOPY PACK  DEC(8),0(0,R7)\nZEROTEST CLC   0(0,R7),ZEROS\n         USING S99TUNIT,R2             ADDRESSABILITY TO S99 TEXT   WFB\nMOVEDDN  MVC   S99TUPAR(0),0(R5)       MOVE DDNAME INTO S99 TEXT    WFB\n         DROP  R2                                                   WFB\n         USING LINDSECT,R15            ADDRESSABILITY TO OUTPUT REC WFB\nMOVEUDK  MVC   RECDATA+3(0),0(R14)     MOVE UDK FONT NAME TO OUTPUT WFB\n         DROP  R15                                                  WFB\n         USING DAPB08,R8\nMOVEMEM  MVC   DA08MNM(0),0(R5)\nMOVEPASS MVC   DA08PSWD(0),0(R5)\n         DROP  R8\nDFPBMVE  MVC   DFPBNAME(0),0(R5)                                   GTEL\n*\n***************************** CONSTANTS *******************************\n*\n******************** DAIR CONTROL BLOCK CONSTANTS *********************\nDAPB08C  DS    0F\n         DC    X'0008'                 DA08CD\n         DC    H'0'                    DA08FLG\n         DC    H'0'                    DA08DARC\n         DC    H'0'                    DA08CTRC\n         DC    A(0)                    DA08PDSN\n         DC    CL8'PRINTI  '           DA08DDN\n         DC    CL8' '                  DA08UNIT\n         DC    CL8' '                  DA08SER\n         DC    F'0'                    DA08BLK\n         DC    F'0'                    DA08PQTY\n         DC    F'0'                    DA08SQTY\n         DC    F'0'                    DA08DQTY\n         DC    CL8' '                  DA08MNM\n         DC    CL8' '                  DA08PSWD\n         DC    X'08'                   DA08DSP1      SHR\n         DC    X'08'                   DA08DSP2      KEEP\n         DC    X'08'                   DA08DSP3      KEEP\n         DC    X'08'                   DA08CTL       PERM\n         DC    F'0'                    DA08DSO\n         DC    CL8' '                  DA08ALN\nDAPB08L  EQU   *-DAPB08C               LENGTH\n         SPACE 2\nDAPB18C  DS    0F\n         DC    X'0018'                 DA18CD\n         DC    X'0000'                 DA18FLG\n         DC    H'0'                    DA18DARC\n         DC    H'0'                    DA18CTRC\n         DC    F'0'                    DA18PDSN\n         DC    CL8'PRINTI'             DA18DDN\n         DC    CL8' '                  DA18MNM\n         DC    CL2' '                  DA18SCLS\n         DC    X'08'                   DA18DPS2\n         DC    X'10'                   DA18CTL\n         DC    CL8' '                  DA18JBNM\nDAPB18L  EQU   *-DAPB18C               LENGTH\n         SPACE 2\nINPUTC   DCB   DSORG=PS,MACRF=(GM),EODAD=EXITI,SYNAD=ERRI,DDNAME=PRINTI\nINPUTL   EQU   *-INPUTC\n*\nOUTPUTAC DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=PRINTA,RECFM=VBA, X\n               LRECL=256,BLKSIZE=3120\nOUTPUTAL EQU   *-OUTPUTAC\n*\nOUTPUTMC DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=PRINTM,RECFM=VBM, X\n               LRECL=256,BLKSIZE=3120\nOUTPUTML EQU   *-OUTPUTMC\n*\nDIRECTC  DCB   DDNAME=PRINTI,DSORG=PS,MACRF=(GM),RECFM=U,BLKSIZE=256,  X\n               SYNAD=SERRI,EODAD=FREEBLK\nDIRECTL  EQU   *-DIRECTC\n*\nOPENCLOS OPEN  (,),MF=L\n         SPACE 2\n*---------------------------------------------------------------------*\n*------------------------- START OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\nSETPRTL  SETPRT OUTPUTAC,,MF=L\n*---------------------------------------------------------------------*\n*--------------------------- END OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\nHEADERC  DS    0F\n         DC    H'75'                   (WAS 49 BEFORE DATE)  ARAMCO WFB\n         DC    H'0'\nHDRCNTLC DC    C' '\n         DC    CL34' **** TSO FOREGROUND HARDCOPY ****'      ARAMCO WFB\n         DC    CL36'      HH:MM:SS    MONTHNAME DY, YEAR'           WFB\nHEADERM  DS    0F\n         DC    H'49'                                             ARAMCO\n         DC    H'0'\n         DC    C' '\n         DC    CL44' *** TSO FOREGROUND MEMBER LIST ***'         ARAMCO\n         DS    0H                                                ARAMCO\nLDSNAME  DS    0CL12\n         ORG   LDSNAME\n         DC    H'86'                                             ARAMCO\n         DC    H'0'\n         DC    CL9'  DSNAME='                                    ARAMCO\nVOLCONST DC    CL11'   VOLUME: '       FOR HEADING WHEN VOL(...)    WFB\nDDNCONST DC    CL11'   DDNAME: '       FOR HEADING WHEN DDN(...)    WFB\nEJECTM   DS    0F\n         DC    H'5'\n         DC    H'0'\n         DC    X'8B'\nEJECTA   DS    0F\n         DC    H'5'\n         DC    H'0'\n         DC    C'1'\nSPACE    EQU   EJECTA\n         SPACE 2\nFULL0    DC    F'0'\nFULL1    DC    F'1'\nFULL4    DC    F'4'\nFULL5    DC    F'5'\nFULL20   DC    F'20'\nFULL28   DC    F'28'\nFULL61   DC    F'61'                                               GTEL\nFULL132  DC    F'132'                                              GTEL\nFULL256  DC    F'256'\nPRINTILN DC    H'12',H'0'\nPRINTI   DC    CL8'PRINTI'\nPRINTALN DC    H'12',H'0'\nPRINTA   DC    CL8'PRINTA'\nPRINTMLN DC    H'12',H'0'\nPRINTM   DC    CL8'PRINTM'\nBLANKS   DC    256CL1' '\nZEROS    DC    4CL1'0'\nALIAS    DC    CL8' *ALIAS*'\nENDCHAIN DS    0F\n         DC    X'FF000000'\nMEMDATL  DC    X'00'                   SUBPOOL NUMBER\n         DC    AL3(1808)\nHALF0    DC    H'0'\nHALF1    DC    H'1'\nHALF2    DC    H'2'\nHALF4    DC    H'4'                                              ARAMCO\nHALF5    DC    H'5'\nHALF6    DC    H'6'\nHALF12   DC    H'12'\nHALF85   DC    H'85'\nHALF256  DC    H'256'\nHALF132  DC    H'132'                                              GTEL\nHALF208  DC    H'208'                                            ARAMCO\nHALF60   DC    H'60'                                             ARAMCO\nHALF120  DC    H'120'                                            ARAMCO\nPATCH    DC    C'PATCH AREA',20S(*)                                 WFB\nMSGCSECT DC    A(MESSAGES)             ADDRESS OF MESSAGE CSECT     WFB\nUDKRESET DC    H'14',H'0',CL10' =UDK={{+X'  DEFINE UDK THEN RESET   WFB\nUDKSET   DC    H'11',H'0',CL7' =UDK={'      DEFINE UDK              WFB\nUDKFHEAD DC    H'0',H'0',CL4' {+2'          SET FONT NAME #2        WFB\nUDKFSEL  DC    H'7',H'0',CL3' {2'           SELECT FONT #2          WFB\nNOMSG    EQU   X'04'                   FLAG IN BYTE VOLBIT          WFB\nUDKDONE  EQU   X'02'                   FLAG IN BYTE VOLBIT          WFB\nFORCEASA EQU   X'04'                   FLAG IN BYTE CCBIT           WFB\nHEXFF    EQU   X'FF'\nHIGH     EQU   X'80'\nLOW      EQU   X'01'\nMID1     EQU   X'10'                                               GTEL\nMID2     EQU   X'08'                                               GTEL\nJFCPDS   EQU   X'01'\nBLANK    EQU   X'40'\nHEX00    EQU   X'00'\nHEXF0    EQU   X'F0'\nHEXF1    EQU   X'F1'\nSCLSA    EQU   C'A'\nSKIPM    EQU   X'09'\nDSOPS    EQU   X'40'\nDSOPO    EQU   X'02'\nNOWTP    EQU   X'00'\n         SPACE 2\n****************** POINTER TO PARS PARAMETER CSECT ********************\nPCLADDR  DC    A(PARMTAB)\n         SPACE 2\n************************ PARS PARAMETER LIST **************************\nPARMTAB  IKJPARM  DSECT=IKJPARMD\nDSNAMES  IKJPOSIT  DSTHING,LIST,USID,                                  X\n               PROMPT='DSNAME, (LIST OF DSNAMES), OR * IF DDNAME(...) IX\n               S SPECIFIED',                                        WFBX\n               HELP=('THE NAME OF THE DATASET TO BE PRINTED, OR AN ASTEX\n               RISK IF A PREALLOCATED DDNAME IS TO BE USED.')       WFB\nPCLASS   IKJKEYWD\n         IKJNAME 'CLASS',SUBFLD=CLASSUB\nPDEST    IKJKEYWD\n         IKJNAME 'DEST',SUBFLD=DESTSUB\nPHOLD    IKJKEYWD\n         IKJNAME 'HOLD'\n         IKJNAME 'NOHOLD'\nPCOPIES  IKJKEYWD\n         IKJNAME 'COPIES',SUBFLD=COPYSUB\nPPRINT   IKJKEYWD\n         IKJNAME 'PRINT'\n         IKJNAME 'NOPRINT'\nPLIST    IKJKEYWD\n         IKJNAME 'LIST'\n         IKJNAME 'NOLIST'\nPHEAD    IKJKEYWD\n         IKJNAME 'NOHEADING'                                       GTEL\n         IKJNAME 'HEADING'                                         GTEL\nPVOL     IKJKEYWD\n         IKJNAME 'VOLUME',SUBFLD=VOLSUB\nPFOLD    IKJKEYWD\n         IKJNAME 'FOLD',ALIAS=('CAPS')\n         IKJNAME 'NOFOLD',ALIAS=('ASIS')\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** START OF GTEL MOD ************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nPSPACE   IKJKEYWD\n         IKJNAME 'SINGLESPACE',ALIAS=('SS','NOCC')                  WFB\n         IKJNAME 'DOUBLESPACE',ALIAS=('DS')                         WFB\nPFORMS   IKJKEYWD\n         IKJNAME  'FORMS',SUBFLD=SFORMS\nPTRAIN   IKJKEYWD\n         IKJNAME  'TRAIN',SUBFLD=STRAIN,ALIAS=('UCS')\nPFCB     IKJKEYWD\n         IKJNAME    'FCB',SUBFLD=SFCB\nPPROG    IKJKEYWD\n         IKJNAME    'PROG',SUBFLD=SPROG\nPTEXT    IKJKEYWD\n         IKJNAME    'TEXT',INSERT='UCS(TN) ASIS'\nPLINELEN IKJKEYWD\n         IKJNAME 'LINELENGTH',SUBFLD=SLINELEN,ALIAS=('LL')\nPPAGELEN IKJKEYWD\n         IKJNAME 'PAGELENGTH',SUBFLD=SPAGELEN,ALIAS=('PL')\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** END OF GTEL MOD **************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*---------------------------------------------------------------------*\n*------------------------- START OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\nPBURST   IKJKEYWD\n         IKJNAME  'BURST'\n         IKJNAME  'NOBURST'\nPFLASH   IKJKEYWD\n         IKJNAME  'FLASH',SUBFLD=SFLASH\nPCHARS   IKJKEYWD\n         IKJNAME  'CHARS',SUBFLD=SCHARS\n*---------------------------------------------------------------------*\n*--------------------------- END OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\nPUNIT    IKJKEYWD ,                                                 WFB\n         IKJNAME 'UNIT',SUBFLD=UNITSUB                              WFB\nPNOMSG   IKJKEYWD ,                                                 WFB\n         IKJNAME 'NOMSGS',ALIAS=('NOMESSAGES')                      WFB\nPDDNAME  IKJKEYWD ,                                                 WFB\n         IKJNAME 'DDNAME',ALIAS=('FILE'),SUBFLD=DDNSUB              WFB\nPASA     IKJKEYWD ,                                                 WFB\n         IKJNAME 'ASA'                                              WFB\nPUDKFONT IKJKEYWD ,                                                 WFB\n         IKJNAME 'UDKFONT',SUBFLD=UDKSUB                            WFB\n*\n*        B E G I N   S U B F I E L D S\nCLASSUB  IKJSUBF\nSCLASS   IKJIDENT 'CLASSNAME',LIST,FIRST=NONATNUM,MAXLNTH=1,           X\n               PROMPT='CLASS NAME'\nDESTSUB  IKJSUBF\nSDEST    IKJIDENT 'DESTINATION',MAXLNTH=17,                         WFBX\n               FIRST=ALPHANUM,OTHER=ANY,VALIDCK=VALDEST,            WFBX\n               PROMPT='DESTINATION FOR OUTPUT',                     WFBX\n               HELP=('WHERE TO PRINT OUTPUT. DESTINATION CAN BE: REMOTEX\n                LINE NUMBER, JES PRINTER NAME, OR NETWORK NODE AND USERX\n               ID')                                                 WFB\nCOPYSUB  IKJSUBF\nSCOPIES  IKJIDENT 'COPIES',MAXLNTH=3,                                  X\n               FIRST=NUMERIC,OTHER=NUMERIC,                            X\n               PROMPT='1-3 DIGITS - NUMBER OF COPIES OF OUTPUT',       X\n               HELP=('NUMBER OF COPIES OF PRINTOUT DESIRED')\nVOLSUB   IKJSUBF\nSVOL     IKJIDENT 'VOLUME',MAXLNTH=8,                                  X\n               FIRST=ALPHANUM,OTHER=ALPHANUM,                          X\n               PROMPT='VOLUME SERIAL FOR DATA SETS TO BE PRINTED',     X\n               HELP=('VOLUME SERIAL TO BE USED FOR ALL DATA SETS')\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** START OF GTEL MOD ************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nSFORMS   IKJSUBF\nRFORMS   IKJIDENT 'FORMS',MAXLNTH=4,FIRST=ALPHANUM,                    X\n               OTHER=ALPHANUM,                                         X\n               DEFAULT='$TST',                                      WFBX\n               HELP=('AN ALPANUMERIC STRING TO SPECIFY THE FORM')\nSTRAIN   IKJSUBF\nRTRAIN   IKJIDENT   'UCS',MAXLNTH=4,FIRST=ALPHANUM,                    X\n               OTHER=ALPHANUM,                                         X\n               PROMPT='UCS   DESIGNATION FOR PRINTED OUTPUT',          X\n               HELP=('AN ALPANUMERIC STRING TO SPECIFY THE TRAIN')\nSFCB     IKJSUBF\nRFCB     IKJIDENT 'FCB',MAXLNTH=4,FIRST=ALPHANUM,                      X\n               OTHER=ALPHANUM,                                         X\n               PROMPT='FCB DESIGNATION FOR PRINTED OUTPUT',            X\n               HELP=('AN ALPANUMERIC STRING TO SPECIFY THE FCB')\nSPROG    IKJSUBF\nRPROG    IKJIDENT 'PROG',MAXLNTH=8,FIRST=ALPHA,                        X\n               OTHER=ALPHANUM,                                         X\n               PROMPT='PROG DESIGNATION FOR PRINTED OUTPUT',           X\n               HELP=('AN ALPANUMERIC STRING TO SPECIFY THE PROG')\nSLINELEN IKJSUBF\nRLINELEN IKJIDENT 'LINELENGTH',MAXLNTH=3,FIRST=NUMERIC,                X\n               OTHER=NUMERIC,                                          X\n               PROMPT='LINESIZE, DEFAULT=132',                         X\n               HELP=('A LENGTH UP TO 208 FOR MAXIMUM PRINT WIDTH')\nSPAGELEN IKJSUBF\nRPAGELEN IKJIDENT 'PAGELENGTH',MAXLNTH=3,FIRST=NUMERIC,                X\n               OTHER=NUMERIC,                                          X\n               PROMPT='PAGELENGTH, DEFAULT=60',                        X\n               HELP=('A LENGTH UP TO 120 FOR PRINTER PAGE LENGTH')\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n**************************** END OF GTEL MOD **************************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*---------------------------------------------------------------------*\n*------------------------- START OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\nSFLASH   IKJSUBF\nRFLASH   IKJIDENT 'FLASH',MAXLNTH=4,FIRST=ALPHANUM,                    X\n               OTHER=ALPHANUM,                                         X\n               PROMPT='FLASH DESIGNATION FOR PRINTED OUTPUT',          X\n               HELP=('FORMS OVERLAY FLASH NAME -- VALID FOR 3800 ONLY')\nSCHARS   IKJSUBF\nRCHARS   IKJIDENT 'CHARS',LIST,MAXLNTH=4,FIRST=ALPHA,                  X\n               OTHER=ANY,                                              X\n               PROMPT='CHARS DESIGNATION FOR PRINTED OUTPUT',          X\n               HELP=('A LIST OF 1 TO 4 CHARACTER SET NAMES -- VALID FORX\n                3800 ONLY')\n*---------------------------------------------------------------------*\n*--------------------------- END OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\nUNITSUB  IKJSUBF ,                                                  WFB\nSUNIT    IKJIDENT 'UNIT',MAXLNTH=8,                                 WFBX\n               FIRST=ALPHANUM,OTHER=ALPHANUM,                       WFBX\n               PROMPT='UNIT TYPE OF SPECIFIED VOLUME',              WFBX\n               HELP=('UNIT TYPE WHICH IS REQUIRED IF THE SPECIFIED VOLUX\n               ME IS NOT ACCESSIBLE THROUGH YOUR DEFAULT TSO UNIT VALUEX\n               ')                                                   WFB\nDDNSUB   IKJSUBF ,                                                  WFB\nSDDNAME  IKJIDENT 'DDNAME',MAXLNTH=8,                               WFBX\n               FIRST=ALPHA,OTHER=ALPHANUM,                          WFBX\n               PROMPT='DD NAME OF PREVIOUSLY ALLOCATED DATASET',    WFBX\n               HELP=('A FILE THAT WAS ALLOCATED EARLIER IN YOUR TSO SESX\n               SION','DDNAME IS IGNORED IF THE LAST OR ONLY DSNAME IS NX\n               OT AN ASTERISK')                                     WFB\nUDKSUB   IKJSUBF ,                                                  WFB\nSUDKFONT IKJIDENT 'UDK FONT NAME',ASIS,MAXLNTH=20,                  WFBX\n               FIRST=ALPHANUM,OTHER=ANY,                            WFBX\n               PROMPT='UDK FONT NAME',                              WFBX\n               HELP=('A FONT NAME FOR PRINTING ON A XEROX 2700 OR 3700'X\n               ,'THE NAME MUST BE ENTERED EXACTLY IN UPPER/LOWER CASE AX\n               S THE PRINTER EXPECTS IT')                           WFB\n         IKJENDP\n         SPACE 2\nMESSAGES CSECT ,                                                    WFB\n****************************** MESSAGES *******************************\nGNRLERR  DC    AL2(GNRLERRL),AL2(0)\n         DC    C'AN ERROR WAS ENCOUNTERED IN THE GENERAL FAIL SERVICE RX\n               OUTINE.  THE RETURN CODE FROM GNRLFAIL IS: '\nGNRLERRL EQU   *-GNRLERR\n*\nDRFLERR  DC    AL2(DRFLERRL),AL2(0)\n         DC    C'AN ERROR WAS ENCOUNTERED IN THE DAIR FAIL SERVICE ROUTX\n               INE.  THE RETURN CODE FROM DAIR FAIL IS: '\nDRFLERRL EQU   *-DRFLERR\n*\nOPENMSG  DC    AL2(OPENMSGL),AL2(0)\n         DC    C'OUPUT PROCESSING IS BEING TERMINATED.  AN ERROR WAS ENX\n               COUNTERED ATTEMPTING TO OPEN THE OUTPUT DATASET ASSOCIATX\n               ED WITH DDNAME: '\nOPENMSGL EQU   *-OPENMSG\n*\nDSNNOTP  DC    AL2(DSNNOTPL),AL2(0)\n         DC    C'AN ERROR OCCURRED AND YOUR DATASET WAS NOT PRINTED'\nDSNNOTPL EQU   *-DSNNOTP\n*\nDSNMSG   DC    AL2(DSNMSGL),AL2(0)\n         DC    C'PROCESSING HAS BEEN COMPLETED FOR DATASET: '\nDSNMSGL  EQU   *-DSNMSG\n*\nMEMMSG   DC    AL2(MEMMSGL),AL2(0)\n         DC    C' MEMBER: '\nMEMMSGL  EQU   *-MEMMSG\n*\nPRTMSG   DC    AL2(PRTMSGL),AL2(0)\n         DC    C'MEMBERS WILL NOW BE PRINTED FOR DATASET: '\nPRTMSGL  EQU   *-PRTMSG\n*\nNOTPSPO  DC    AL2(NOTPSPOL),AL2(0)\n         DC    C'DATASET IS NOT SEQUENTIAL OR PARTITIONED AND WAS NOT PX\n               RINTED.'\nNOTPSPOL EQU   *-NOTPSPO\n*\nSYNADI   DC    AL2(SYNADIL),AL2(0)\n         DC    C'A SYNAD ERROR OCURRED READING YOU INPUT DATASET AND ONX\n               LY PART OF YOUR DATASET MAY HAVE BEEN PRINTED.'\nSYNADIL  EQU   *-SYNADI\n*\nSYNADO   DC    AL2(SYNADOL),AL2(0)\n         DC    C'A SYNAD ERROR OCURRED WRITING THE OUTPUT DATASET AND NX\n               O MORE DATASETS WILL BE PRINTED.'\nSYNADOL  EQU   *-SYNADO\n*\n*DSNISU  DC    AL2(DSNISUL),AL2(0)\n*        DC    C'DATASET HAS UNDEFINED RECORD LENGTH AND WILL NOT BE PRX\n               INTED.'\n*DSNISUL EQU   *-DSNISU\n*\n*DSNISL  DC    AL2(DSNISLL),AL2(0)\n*        DC    C'DATASET HAS RECORD LENGTH GREATER THAN 256.'\n*DSNISLL EQU   *-DSNISL\n*                                                                ARAMCO\nCHARMSG  DC    AL2(CHARMSGL),AL2(0)                              ARAMCO\n         DC    C'MAX OF 4 CHAR SETS ALLOWED, REMAINDER IGNORED'  ARAMCO\nCHARMSGL EQU   *-CHARMSG                                         ARAMCO\n*                                                                   WFB\nNODSNDD  DC    AL2(NODSNDDL),AL2(0)                                 WFB\n         DC    C'NO INPUT SPECIFIED: AN ASTERISK DSNAME IMPLIES A DDNAMX\n               E WILL BE USED FOR INPUT, BUT NO DDNAME WAS GIVEN.'  WFB\nNODSNDDL EQU   *-NODSNDD                                            WFB\nNOTLAST  DC    AL2(NOTLASTL),AL2(0)                                 WFB\n         DC    C'AN ASTERISK DSNAME MUST BE THE LAST OR ONLY DSNAME SPEX\n               CIFIED FOR DDNAME TO BE PROCESSED.'                  WFB\nNOTLASTL EQU   *-NOTLAST                                            WFB\n         SPACE 2\n************************ DSECTS (MAPPING MACROS) **********************\nMEMDSECT DSECT\nMEMNTTR  DS    CL11\n         ORG   MEMNTTR\nMEMBER   DS    CL8\nMEMTTR   DS    CL3\nCFIELD   DS    CL1\nMEMSECTN EQU   *\n         IKJDAP08\nDAP08LEN EQU   *-DAPB08\n         IKJDAP18\nDAP18LEN EQU   *-DAPB18\n         IKJDAPL\nDAPLLEN  EQU   *-DAPL\n         IKJCPPL\nCPPLLEN  EQU   *-CPPL\n         IKJPPL\nPPLLEN   EQU   *-PPL\n         IKJIOPL\nIOPLLEN  EQU   *-IOPL\n         IHADSAB\nTIOEDDNM EQU   4           X'1C'(OFFSET) - X'18'(JOB STEP)\n         CVT   DSECT=YES                                            WFB\n         IEFZB4D0\n         IEFZB4D2\n         IKJDFPL                                                   GTEL\n         IKJDFPB                                                   GTEL\n         IKJUPT                                                  ARAMCO\nRBLEN    EQU   S99RBEND-S99RB\n         PRINT NOGEN\n         DCBD  DSORG=(PS,PO)\n         PRINT GEN\n         EJECT\n******************** CONSTANTS FOR DYNAMIC ALLOCATION *****************\nPRINTOFF CSECT\nREQBLKC  DC    AL1(S99RBEND-S99RB),AL1(S99VRBAL),18AL1(0)\nTEXTAC   DC    AL2(DALDDNAM),AL2(1),AL2(8),CL8'PRINT'  DDNAME\nTEXTALEN EQU   *-TEXTAC\nTEXTBC   DC    AL2(DALSYSOU),AL2(1),AL2(1),C'A'        SYSOUT CLASS\nTEXTBLEN EQU   *-TEXTBC\nTEXTCC   DC    AL2(DALSUSER),AL2(1),AL2(8),CL8'LOCAL'  DESTINATION\nTEXTCLEN EQU   *-TEXTCC\nTEXTDC   DC    AL2(DALSHOLD),AL2(0)                    SYSOUT HOLD\nTEXTDLEN EQU   *-TEXTDC\nTEXTEC   DC    AL2(DALCOPYS),AL2(1),AL2(1),AL2(1)      SYSOUT COPIES\nTEXTELEN EQU   *-TEXTEC\nTEXTFC   DC    AL2(DALPERMA),AL2(0)              PERM ALLOCATION\nTEXTFLEN EQU   *-TEXTFC\nTEXTGC   DC    AL2(DALFCBIM),AL2(1),AL2(4),CL4'STD.'  FCB          GTEL\nTEXTGLEN EQU   *-TEXTGC                                        GTEL WFB\nTEXTHC   DC    AL2(DALUCS),AL2(1),AL2(2),CL4'PN'      UCS          GTEL\nTEXTHLEN EQU   *-TEXTHC                                        GTEL WFB\nTEXTIC   DC    AL2(DALSFMNO),AL2(1),AL2(2),CL4'STD.'  FORMS        GTEL\nTEXTILEN EQU   *-TEXTIC                                        GTEL WFB\nTEXTJC   DC    AL2(DALSPGNM),AL2(1),AL2(8),CL8'PROG'  PROG         GTEL\nTEXTJLEN EQU   *-TEXTJC                                        GTEL WFB\nTEXTKC   DC    AL2(DALUSRID),AL2(1),AL2(8),CL8'USER'  USERID        WFB\nTEXTKLEN EQU   *-TEXTKC                                             WFB\nTEXTLC   DC    AL2(DINDDNAM),AL2(1),AL2(8),CL8' '   PREALLOC DDNAME WFB\nTEXTLLEN EQU   *-TEXTLC                                             WFB\nTEXTMC   DC    AL2(DINRTDSN),AL2(1),AL2(44),CL44' ' RETURNED DSNAME WFB\nTEXTMLEN EQU   *-TEXTMC                                             WFB\nTEXTNC   DC    AL2(DINRTMEM),AL2(1),AL2(8),CL8' '   RETURNED MEMBER WFB\nTEXTNLEN EQU   *-TEXTNC                                             WFB\nTEXTOC   DC    AL2(DINRTORG),AL2(1),AL2(2),XL2'0000' RETURNED DSORG WFB\nTEXTOLEN EQU   *-TEXTOC                                             WFB\n*                                                                   WFB\n**       VALIDITY CHECK ROUTINE FOR DESTINATION                     WFB\n***                                                                 WFB\n****     MAXIMUM LENGTH IS 17 CHARACTERS (ENFORCED BY PARSE)        WFB\n*****    DEST(NODE.USERID) MUST HAVE 1 PERIOD, EACH NAME 1-8 CHARS  WFB\n******   DEST(NAME) IF NO PERIOD, MAXIMUM LENGTH IS 8 CHARACTERS    WFB\n******                                                              WFB\n*****    AT ENTRY, REG 1 POINTS TO A THREE WORD LIST:               WFB\n****     +0  A(SDEST)   ADDRESS OF THE PDE BUILT BY PARSE           WFB\n***      +4  A(WORKAREA) ADDRESS OF USER WORK AREA FROM IKJPPL      WFB\n**       +8  A(VALMSG)  =F'0', ADDRESS OF USER SUPPLIED 2ND LVL MSG WFB\n*                                                                   WFB\nVALDEST  CSECT ,                                                    WFB\n         PUSH  USING                                                WFB\n         STM   R14,R12,12(13)          SAVE PARSE REGISTERS         WFB\n         LR    R12,R15                 USE REG 12 AS BASE           WFB\n         USING VALDEST,R12             ESTABLISH ADDRESSABILITY     WFB\n         LM    R8,R10,0(R1)            LOAD INPUT LIST VALUES       WFB\n         SR    R15,R15                 ASSUME ZERO RETURN CODE      WFB\n         STH   R15,NODELEN-WORKAREA(,R9)  ASSUME NOT NODE.USERID    WFB\n         L     R1,0(,R8)               GET ADDRESS OF DEST          WFB\n         LH    R3,4(,R8)               GET TOTAL LENGTH OF DEST     WFB\n         BCTR  R3,0                    DECREMENT LENGTH FOR TRT     WFB\n         EX    R3,VALTRT               LOOK FOR PERIOD OR INVALID   WFB\n         BZ    VALNODOT           CC=0 NOTHING FOUND, GO CHECK LEN  WFB\n         BM    VALCHECK           CC=1 FOUND IN MIDDLE, GO CHECK    WFB\n         B     VALRET4            CC=2 FOUND IN LAST BYTE - INVALID WFB\nVALNODOT CLI   5(R8),X'08'             NO PERIOD, LEN MUST BE 1-8   WFB\n         BNH   VALRETRN                YES, OK                      WFB\n         B     VALRET4                 NO, INVALID LENGTH           WFB\nVALCHECK CLI   0(R1),C'.'              PERIOD FOUND ?               WFB\n         BNE   VALRET4                 NO, INVALID CHARACTER        WFB\n         LA    R4,0(,R1)               GET ADDRESS OF PERIOD        WFB\n         SL    R4,0(,R8)               MINUS BEGIN DEST = LEN NODE  WFB\n         LA    R1,1(,R1)               POINT PAST PERIOD            WFB\n         SLR   R3,R4                   GET REMAINING LEN OF '.USER' WFB\n         BCTR  R3,0                    DECREMENT FOR PERIOD         WFB\n         EX    R3,VALTRT               LOOK FOR MORE PERIOD/INVALID WFB\n         BNZ   VALRET4                 FOUND, INVALID SPECIFICATION WFB\n         STH   R4,NODELEN-WORKAREA(,R9)  SAVE NODE LEN IN WORKAREA  WFB\n         B     VALRETRN                DONE                         WFB\nVALRET4  LA    R15,4                   SET RC 4 - INVALID DEST      WFB\nVALRETRN LM    R0,R12,20(R13)          RESTORE PARSE REGISTERS      WFB\n         L     R14,12(,R13)            RESTORE RETURN ADDRESS       WFB\n         BR    R14                     RETURN TO PARSE              WFB\n*                                                                   WFB\nVALTRT   TRT   0(0,R1),VALTABLE        ** EXECUTED **               WFB\nVALTABLE DC    256AL1(*-VALTABLE)      TABLE OF VALID CHARACTERS    WFB\n         ORG   VALTABLE+C'$'                                        WFB\n         DC    X'00'                   ALLOW $                      WFB\n         ORG   VALTABLE+C'#'                                        WFB\n         DC    2X'00'                  ALLOW # @                    WFB\n         ORG   VALTABLE+C'A'                                        WFB\n         DC    9X'00'                  ALLOW A B C D E F G H I      WFB\n         ORG   VALTABLE+C'J'                                        WFB\n         DC    9X'00'                  ALLOW J K L M N O P Q R      WFB\n         ORG   VALTABLE+C'S'                                        WFB\n         DC    8X'00'                  ALLOW S T U V W X Y Z        WFB\n         ORG   VALTABLE+C'0'                                        WFB\n         DC    10X'00'                 ALLOW 0 1 2 3 4 5 6 7 8 9    WFB\n         ORG   ,                                                    WFB\n         DROP  R12                                                  WFB\n         POP   USING                                                WFB\n*********************** DSECT FOR DYNAMIC WORKAREA ********************\nWORKAREA DSECT\nSAVEAREA DS    18F\nALCSAVE  DS    12F\n         DS    0D\nDEC      DS    2F\nRETNCD   DS    F\nCONV     DS    2F\nIOPB     PUTLINE MF=L\nDAP08    DS    0F\n         ORG   DAP08+DAP08LEN\nDAP18    DS    0F\n         ORG   DAP18+DAP18LEN\nDAPLSECT DS    0F\n         ORG   DAPLSECT+DAPLLEN\nPPLSECT  DS    0F\n         ORG   PPLSECT+PPLLEN\nIOPLSECT DS    0F\n         ORG   IOPLSECT+IOPLLEN\nDFPLSECT DS    4F                   SPACE FOR DFPL                 GTEL\nDFPBSECT DS    5F                   SPACE FOR DFPB                 GTEL\n         DS    H                    TO GET ALLIGNMENT              GTEL\nDFPBDSL  DS    H                    DSNAME LENGTH                  GTEL\nDFPBNAME DS    CL44                 DSNAME                         GTEL\nDFPBQUA  DS    CL8\nECB      DS    F\nPARSBACK DS    F\nLINE     DS    0H\nLENGTH   DS    H\n         DS    H\nCNTLBYTE DS    CL1\nDATA     DS    CL256\nHEADER2  DS    CL13                                              ARAMCO\nDSNAME   DS    CL44\nOPENPRN  DS    CL1\nMEMNAME  DS    CL8\nCLOSEPRN DS    CL1\nVOLHEAD  DS    CL11                 C'   VOLUME: ' ON HEADING       WFB\nVOLNAME  DS    CL8                                                  WFB\n         ORG   DSNAME-4\nDSNLENP  DS    CL2\nDSNLEN   DS    CL2\nDSNBUF   DS    CL44\n         ORG   MEMNAME-4\nMEMNAMEL DS    CL2\n         ORG\nHEADER   DS    CL75                 (WAS 49 BEFORE DATE)     ARAMCO WFB\n         ORG   HEADER+4\nHDRCNTL  DS    CL1\n         ORG   HEADER+41                                            WFB\nHDRTIME  DS    CL12                 4 BYTE PREFIX, HH:MM:SS         WFB\nHDRDATE  DS    CL22                 4 BYTE PREFIX, MONTHNAME DY, YR WFB\nHDRTDLEN EQU   *-HDRTIME                                            WFB\nDFID     DS    CL2\n         ORG\nVOLBIT   DS    CL1\nVOLUME   DS    CL8\nUNIT     DS    CL8                  UNIT() VALID ONLY WITH VOL()    WFB\nPREALDDN DS    CL8                  PREALLOCATED DDNAME(...)        WFB\nNODELEN  DS    H                    LEN OF NODE IN DEST(NODE.USER)  WFB\nCALLMFL  CALL  ,(,),MF=L            LIST FORM FOR CALL IKJEFLPA     WFB\nMEMTABLE DS    F\nENDTABLE DS    F\nCURRENT  DS    F\nPRESENT  DS    F\nCOLUMN   DS    F\nXLIST    DS    F\nLINELEN  DS    H                                                   GTEL\nVBLEN    DS    H                                                   GTEL\nPAGELEN  DS    H                                                   GTEL\nCCBIT    DS    CL1                                                 GTEL\nALNDSECT DS    F                                                   GTEL\nRDJL     RDJFCB (,),MF=L\nJFCBAREA DS    44F\n         ORG   JFCBAREA+44\nJFCBELNM DS    CL8\n         ORG   JFCBAREA+86\nJFCBIND1 DS    CL1\n         ORG   JFCBAREA+98\nJFCDSRG1 DS    CL1\n         ORG\nSAVER6   DS    F\nSAVER2   DS    2F\nSAVER3   DS    2F\nSAVMR2   DS    2F                                                  GTEL\nSAVMR6   DS    2F                                                  GTEL\nSAVMR9   DS    2F                                                  GTEL\n*\n         PRINT NOGEN\n*\nINPUT    DCB   DSORG=PS,MACRF=(GM),EODAD=EXITI,SYNAD=ERRI,DDNAME=PRINTI\n*\nOUTPUTA  DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=PRINTA,RECFM=VBA, X\n               LRECL=256,BLKSIZE=3120\n*\nOUTPUTM  DCB   DSORG=PS,MACRF=(PM),SYNAD=ERRO,DDNAME=PRINTM,RECFM=VBM, X\n               LRECL=256,BLKSIZE=3120\n*\nDIRECT   DCB   DDNAME=PRINTI,DSORG=PS,MACRF=(GM),RECFM=U,BLKSIZE=256,  X\n               SYNAD=SERRI,EODAD=FREEBLK\n*\nOPENLST  OPEN  (,),MF=L\n*\nCLOSLST  CLOSE (,),MF=L\n*\n*\n         PRINT GEN\n*\nRETCODE  DS    F\nGFPARMP  DS    F\n         IKJEFFGF\n         IKJEFFDF\nRBPTR    DS    F\nREQBLK   DS    10F                                                 GTEL\nTEXTPTRS DS    16F                                             GTEL WFB\nTEXTA    DS    0F                                   DDNAME\n         ORG   TEXTA+TEXTALEN\nTEXTB    DS    0F                                   SYSOUT CLASS\n         ORG   TEXTB+TEXTBLEN\nTEXTC    DS    0F                                   DESTINATION\n         ORG   TEXTC+TEXTCLEN\nTEXTE    DS    0F                                   SYSOUT COPIES\n         ORG   TEXTE+TEXTELEN\nTEXTG    DS    0F                                   FCB            GTEL\n         ORG   TEXTG+TEXTGLEN                                      GTEL\nTEXTH    DS    0F                                   UCB            GTEL\n         ORG   TEXTH+TEXTHLEN                                      GTEL\nTEXTI    DS    0F                                   FORMS          GTEL\n         ORG   TEXTI+TEXTILEN                                      GTEL\nTEXTJ    DS    0F                                   PROG           GTEL\n         ORG   TEXTJ+TEXTJLEN                                      GTEL\nTEXTK    DS    0F                                   USERID          WFB\n         ORG   TEXTK+TEXTKLEN                                       WFB\nTEXTL    DS    0F                                   PREALLOC DDNAME WFB\n         ORG   TEXTL+TEXTLLEN                                       WFB\nTEXTM    DS    0F                                   RETURNED DSNAME WFB\n         ORG   TEXTM+TEXTMLEN                                       WFB\nTEXTN    DS    0F                                   RETURNED MEMBER WFB\n         ORG   TEXTN+TEXTNLEN                                       WFB\nTEXTO    DS    0F                                   RETURNED DSORG  WFB\n         ORG   TEXTO+TEXTOLEN                                       WFB\n*---------------------------------------------------------------------*\n*------------------------- START OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\nSETFLAG  DS    X\nSETBURST EQU   1\nSETFLSH  EQU   2\nSETCHAR  EQU   4\nSETPRTE  SETPRT OUTPUTA,,MF=L\nSETFLASH EQU   SETPRTE+28\nSETCHARS EQU   SETPRTE+32\nSETPRTEL EQU   *-SETPRTE\nSAVEUPT  DS    X\n*---------------------------------------------------------------------*\n*--------------------------- END OF ARAMCO MOD -----------------------*\n*---------------------------------------------------------------------*\nLDYNAMIC EQU   *-WORKAREA\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*********************** DSECT FOR RECORD MAPPING **********************\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nLINDSECT DSECT\nRECORD   DS    0F\nRECLEN   DS    H\n         DS    H\nRECCC    DS    CL1\nRECDATA  DS    CL32760                                              WFB\nRECSIZE  EQU   *-RECORD                                             WFB\n*********************** END OF RECORD MAPPING DSECT *******************\n         AGO   .ENDHELP                SKIP AROUND HELP ENTRY      WFB\n)F Function -\n   The PRINTOFF command creates a printed copy of data sets through\n   foreground copying to SYSOUT.  The command prints datasets which\n   are sequential or partitioned, blocked or unblocked, with fixed,\n   variable, or undefined length records of any length up to 32,760.\n)X Syntax -\n   PRINTOFF (dslist)/*  DDNAME(ddname)/FILE(ddname)\n            UNIT(unit-type)  VOLUME(volser)     NOMESSAGES/NOMSGS\n            CLASS(class)     DEST(destination)  COPIES(nnn)\n            HOLD/NOHOLD      LIST/NOLIST        PRINT/NOPRINT\n            FORMS(form)      FCB(fcb)           TRAIN(image)/UCS(image)\n            HEADING/NOHEADING                   CAPS/ASIS/FOLD/NOFOLD\n            NOCC/SINGLESPACE/SS/DOUBLESPACE/DS  ASA\n            LINELENGTH(nnn)/LL(nnn)             PAGELENGTH(nnn)/PL(nnn)\n            BURST/NOBURST    FLASH(flash-name)  CHARS(charset-name(s))\n            PROG(progname)   UDKFONT(font-name)\n   Required -- dslist or * if DDNAME(...)\n   Aliases  -- PRINTO, PO\n   Defaults -- CLASS(A), COPIES(1), NOHOLD, LIST, PRINT, FORM($TST),\n               HEADING, ASIS, LINELENGTH(132), PAGELENGTH(60), NOBURST,\n               SINGLESPACE if PAGELENGTH(...) or if input RECFM not A/M\n)O Operands -\n)P DSLIST - Data set list contains the names of data sets to be printed\n            or punched.  The names should follow TSO convention, in\n            quotes if the primary index differs from your profile\n            prefix, or without quotes and with the primary index\n            omitted if it is the same as your profile prefix.\n            Enclosing parenthesis are required if there is more than\n            one name in the list.\n              If DDNAME(...) is specified, the dslist must end with an\n            asterisk (or contain only an asterisk) as a place holder.\n))ASA     - Output is to be printed using input data column 1 as ASA\n            carriage control characters even though the DCB record\n            format does not specify RECFM=..A\n))ASIS    - Output is not to be converted to upper case prior to\n            printing. (It is left as it is.)\n            NOFOLD is an alias for ASIS.\n))BURST   - Output is to be trimmed and burst. ===> VALID FOR 3800 ONLY\n))NOBURST - Output will be printed on continuous forms.\n))CAPS    - Output is to be converted to upper case prior to\n            printing. FOLD is an alias for CAPS.\n))CHARS(charset-name(s)) - Character set(s) to be used to print the\n            output. (1-4 names, each name 1-4 characters.)  If more\n            than one character set name is given, the input data should\n            have the character set id specified in the second character\n            of each line. OPTCD=J is assumed. See the JCL reference\n            manual for more information. ===> VALID FOR 3800 ONLY\n))CLASS(class) - SYSOUT class in which output is to be printed.\n            Default is A.\n))COPIES(nnn) - Number of copies to be printed.  Default is 1.\n))DEST(destination) - The destination to where SYSOUT is to be routed.\n            Destination can be a JES remote line, a JES local or remote\n            printer, or a network node and userid. Local and remote\n            names are 1-8 characters. Network names are 3-17 characters\n            (node.userid) with the period required as a separator.\n            DEST(node.userid) is mutually exclusive with\n            PROG(progname).\n))DDNAME(ddname) - DD name of a previously allocated dataset. If DDNAME\n            is specified, the last (or only) dataset name in dslist\n            must be an asterisk. The DD will not be freed after being\n            printed. FILE is an alias for DDNAME.\n))FCB(fcb) - Forms Control Buffer to be used when the data set is\n            printed.  (1-4 character FCB name)\n))FLASH(flashname) - The name of the forms flash overlay which is to be\n            flashed on all output. ===> VALID FOR 3800 ONLY\n))FORMS(form) - Form to be used when the data set is printed.\n            Default is $TST. (1-4 character form name)\n))HEADING - Output is to have a heading containing the data set name.\n))NOHEADING - Output is not to have heading information.\n))HOLD    - Output is to be placed on a hold queue upon deallocation.\n))NOHOLD  - Output is not to be placed on a hold queue upon\n            deallocation.\n))LINELENGTH(nnn) - Number of characters on each line of printed\n            output. (1-208 characters with a default of 132.)  Input\n            lines longer than specified linelength will be printed on\n            multiple lines.  LL(...) is an alias for LINELENGTH(...).\n))LIST    - A separate listing of member names processed is to be\n            created and printed with the data set output.\n))NOLIST  - No list of member names is to be created.\n))NOMESSAGES - Non-error messages are not to be written to the TSO\n            terminal. NOMSGS is an alias of NOMESSAGES. The default is\n            to write informational messages to the terminal before and\n            after printing.\n))PAGELENGTH(nnn) - Number of lines per page.  (1-120 lines with a\n            default of 60.)  Carriage control in input records is\n            ignored (even if ASA is specified) and SINGLESPACE is used.\n            PL(...) is an alias for PAGELENGTH(...).\n))PRINT   - Members are to be printed. (Whether they are also listed\n            is controlled by LIST/NOLIST.)\n))NOPRINT - Members are not to be printed. (Whether they are to be\n            listed is controlled by LIST/NOLIST.)\n))PROG(progname) - The name of the special 'external writer' program\n            that is to process the output. PROG(progname) is mutually\n            exclusive with DEST(node.userid).\n))TRAIN(image) - Print image to be used when the data set is printed.\n            UCS is an alias for TRAIN. (1-4 character print image name)\n))UCS(image) - Print image to be used when the data set is printed.\n            UCS is an alias for TRAIN. (1-4 character print image name)\n))SINGLESPACE - Output is to be single spaced.  Carriage control in\n            input data is ignored even if ASA is specified.\n            NOCC and SS are aliases for SINGLESPACE.\n))DOUBLESPACE - Output is to be double spaced between lines.  Carriage\n            control in input data is ignored even if ASA is specified.\n            DS is an alias for DOUBLESPACE.  (Multiple line records\n            will not be split between pages.)\n))UNIT(unit-type) - Unit type of the specified VOLUME(volser). UNIT is\n            ignored if VOLUME is not also specified. UNIT is required\n            only when the dataset is not cataloged, or when the dataset\n            is cataloged to a different volume than the specified\n            VOLUME and the volume cannot be accessed through your TSO\n            default unit type.\n))VOLUME(volser) - Volume serial of volume on which data sets to be\n            printed are found.  This volume serial will be used for all\n            data sets specified in the data set list.\n))UDKFONT(font-name) - Output is intended to be printed on a XEROX 2700\n            or 3700.  PRINTOFF will insert Xerox User Defined Key (UDK)\n            statements in the output to select the specified font.  No\n            validation is performed on the font name before it is sent\n            to the printer, so the full font name must be specified in\n            upper/lower case exactly as expected by the XEROX printer.\n            (PRINTOFF uses the left brace character, {, hex C0, as the\n            UDK.  Input data containing this character will be\n            interpreted by the printer as a Xerox command, and may\n            produce undesired results.)\n.ENDHELP ANOP                          ,                            SL\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROF$ZAP": {"ttr": 6661, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00)\\x00\\x856_\\x01\\x13!o\\x024\\x00\\x11\\x00\\x0b\\x00\\x00\\xe9\\xc1\\xd7\\xd3\\xd4\\xd6\\xc4@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "1985-12-31T00:00:00", "modifydate": "2013-08-04T02:34:29", "lines": 17, "newlines": 11, "modlines": 0, "user": "ZAPLMOD"}, "text": "//SBGOLOBZ JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//* ---------------------------------------------------------------- *\n//*   If you have a working version of PRINTOFF that prints 19xx     *\n//*   instead of 20xx as the year in the date on its heading, you    *\n//*   can apply this zap to fix the problem.  But it is better to    *\n//*   reassemble with the supplied PRINTOFF member in this pds.      *\n//* ---------------------------------------------------------------- *\n//ZAPNOTE EXEC PGM=AMASPZAP\n//SYSUDUMP DD  SYSOUT=*,HOLD=YES\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DSN=SYS1.W$$.LINKLIB,DISP=SHR\n//SYSIN    DD  *\n NAME  PRINTOFF IKJEFLPB\n VER   0000   19     PLUG 19 INTO 2-DIGIT YEAR\n REP   0000   20     PLUG 20 INTO 2-DIGIT YEAR\n/*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ROOM": {"ttr": 6663, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87(\\x7f\\x00\\x87(\\x7f\\x12\\x00\\x01\\xeb\\x01\\xeb\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-10-14T00:00:00", "modifydate": "1987-10-14T12:00:00", "lines": 491, "newlines": 491, "modlines": 0, "user": "FILE325"}, "text": "         TITLE 'WELLS FARGO BANK ROOM COMMAND'\nROOM     CSECT\n         SPACE 2\n*** MODULE NAME *******************************************************\n*                                                                     *\n*   R O O M  -  WELLS FARGO BANK ROOM COMMAND FOR TSO FOREGROUND      *\n*               EXECUTION                                             *\n*                                                                     *\n*                        (WRITTEN BY VIC COZZOLI, FEBRUARY 1983)      *\n*                                                                     *\n*** FUNCTION **********************************************************\n*                                                                     *\n*   THIS COMMAND EITHER LISTS OR MODIFIES THE ROOM NUMBER FIELD IN    *\n*   THE JES2 JCT (JCTROOMN) FOR THE ISSUERS LOGON TASK.  THE ROOM     *\n*   NUMBER FIELD IS LISTED IF NO OPERAND IS ENTERED WITH THE COMMAND; *\n*   AND IT IS UPDATED WITH THE OPERAND ENTERED WHEN THE OPERAND IS    *\n*   PRESENT.                                                          *\n*                                                                     *\n*** PURPOSE ***********************************************************\n*                                                                     *\n*   THIS COMMAND IS NECESSARY IN ORDER TO ALLOW TSO USERS THE         *\n*   ABILITY TO MAINTAIN THE ROOM NUMBER FIELD DURING THEIR LOGON      *\n*   SESSION.  THE ROOM NUMBER FIELD IS OVERLAYED BY WELLS FARGO       *\n*   ACCOUNTING INFORMATION AT LOGON TIME. THEREFORE, IT IS NORMALLY   *\n*   UNUSABLE FOR SYSOUT DELIVERY INFORMATION WHEN PRESENT ON THE      *\n*   SYSOUT HEADER AND TRAILER PAGES.  THIS COMMAND ALLOWS THE TSO     *\n*   USER THE ABILITY TO RESTORE THE ROOM NUMBER SO THAT IT CAN BE     *\n*   USED FOR SYSOUT DELIVERY INFORMATION WHEN PRESENT ON THE SYSOUT   *\n*   HEADER AND TRAILER PAGES.                                         *\n*                                                                     *\n*** OPERATION *********************************************************\n*                                                                     *\n*   HOUSEKEEPING:                                                     *\n*      - SAVE CALLER'S REGISTERS                                      *\n*      - GETMAIN DYNAMIC WORKAREA                                     *\n*      - CHAIN SAVEAREAS                                              *\n*      - INITIALIZE GENERAL FAIL PARAMETER LIST TO BINARY ZEROS       *\n*      - DISABLE ATTENTION INTERRUPTS                                 *\n*                                                                     *\n*   MAIN PROCESS:                                                     *\n*      - BUILD PARS AND PUTLINE PARAMETER LISTS                       *\n*      - CALL IKJPARS (VIA CALLTSSR) TO PARSE THE COMMAND             *\n*      - GET THE JES2 JCT ADDRESS                                     *\n*      - IF THE COMMAND WAS ENTERED WITHOUT OPERAND,                  *\n*            THEN LIST THE CURRENT ROOM NUMBER                        *\n*      - IF THE COMMAND WAS ENTERED WITH AN OPERAND,                  *\n*            THEN UPDATE THE ROOM NUMBER WITH THE ONE SPECIFIED       *\n*                 IN THE COMMAND OPERAND FIELD                        *\n*                                                                     *\n*   RETURN:                                                           *\n*      - FREE DYANMIC WORKAREA                                        *\n*      - ENABLE ATTENTION INTERRUPTS                                  *\n*      - RESTORE CALLER'S REGISTERS                                   *\n*      - RETURN TO CALLER                                             *\n*                                                                     *\n         EJECT\n*** NOTES *************************************************************\n*                                                                     *\n*   REGISTER CONVENTIONS:                                             *\n*       REGISTER 0 TO 3   - WORK REGISTERS                            *\n*       REGISTER 4        - PTR TO PARSE PARAMETER LIST (PPL)         *\n*       REGISTER 5        - PTR TO I/O SERVICE ROUTINE PARAMETER LIST *\n*                           (IOPL)                                    *\n*       REGISTER 6        - PTR TO PARAMETER DESCRIPTOR LIST (PDL)    *\n*       REGISTER 7        - PTR TO JES2 JCT                           *\n*       REGISTER 8        - PTR TO COMMAND PROCESSOR PARAMETER LIST   *\n*                           (CPPL)                                    *\n*       REGISTER 9        - CONTAINS RETURN POINT FROM SUBROUTINE CALL*\n*       REGISTER 10 TO 11 - NOT USED                                  *\n*       REGISTER 12       - BASE REGISTER                             *\n*       REGISTER 13 TO 15 - WORK REGISTERS                            *\n*                                                                     *\n*** TSO COMMAND SYNTAX ************************************************\n*                                                                     *\n*   ROOM <OPERAND>                                                    *\n*                                                                     *\n*** ENVIRONMENT *******************************************************\n*                                                                     *\n*   MODULE TYPE: PROCEDURE                                            *\n*   PROCESSOR:   ASM                                                  *\n*   MODULE SIZE: .3K                                                  *\n*   ATTRIBUTES:  REENTRANT, PROBLEM PROGRAM STATE, AND                *\n*                SCHEDULER KEY 8 (EXCEPT DURING UPDATE OF JES2 JCT    *\n*                WHEN SCHEDULER KEY 0)                                *\n*                                                                     *\n*   ENTRY POINT: ROOM (ONLY ENTRY POINT)                              *\n*   LINKAGE:     FROM TERMINAL MONITOR PROGRAM (TMP) AS A COMMAND     *\n*                                                                     *\n*** INPUT *************************************************************\n*                                                                     *\n*   REGISTER 1 POINTS TO THE COMMAND PROCESSOR PARAMETER LIST (CPPL)  *\n*   MAPPED BY IKJCPPL MACRO                                           *\n*                                                                     *\n*** OUTPUT ************************************************************\n*                                                                     *\n*   NONE                                                              *\n*                                                                     *\n*** EXIT **************************************************************\n*                                                                     *\n*   NORMAL:                                                           *\n*      - AT PROGRAM END VIA BRANCH REGISTER 14                        *\n*      - RETURN CODE IN REGISTER 15 IS ZERO (0)                       *\n*                                                                     *\n*   ERROR:                                                            *\n*      - PROGRAM WILL DISPLAY ERROR MESSAGE AND DECIMAL RETURN CODE   *\n*      - AND RETURN VIA BRANCH REGISTER 14                            *\n*      - RETURN CODE IN REGISTER 15 IS TWELVE (12)                    *\n*                                                                     *\n         EJECT\n*** EXTERNAL REFERENCES ***********************************************\n*                                                                     *\n*   ROUTINES:       IKJPARS, GNRLFAIL (IKJEFF19), PUTLINE (IKJPUTL)   *\n*   DATA AREAS:     NONE                                              *\n*   CONTROL BLOCKS: CPPL, PPL, GFPARMS, IOPL, IOPB,                   *\n*                   CVT, TCB, JSCB, SSIB, $SJB, $JCT                  *\n*   MACROS:         SAVE, GETMAIN, FREEMAIN, STAX, CALLTSSR, MODESET, *\n*                   LINK, TPUT, IKJPARM, IKJIDENT, IKJENDP, IKJCPPL,  *\n*                   IKJPPL, IKJIOPL, PUTLINE                          *\n*                                                                     *\n*** CHANGE ACTIVITY ***************************************************\n*                                                                     *\n*                                                                     *\n*     DATE  |     BY     | REASON                                     *\n*   --------|------------|--------------------------------------------*\n*   05/29/84|VIC COZZOLI | REMOVE HARD CODED DISPLACEMENTS           @1\n*                                                                     *\n*** MESSAGES **********************************************************\n*                                                                     *\n*   THE GNRLFAIL SERVICE ROUTINE IS USED TO ISSUE SOME MESSAGES.      *\n*   THOSE MESSAGES ISSUED BY THE COMMAND ARE FOUND FOLLOWING THE      *\n*   LABEL GNRLERR AND ARE ISSUED BY TPUT AND PUTLINE RESPECTIVELY.    *\n*                                                                     *\n*** ABEND CODES *******************************************************\n*                                                                     *\n*   NONE                                                              *\n*                                                                     *\n***********************************************************************\n         EJECT\n*** HOUSEKEEPING ******************************************************\n*                                                                     *\n*   -SAVE CALLER'S REGISTERS                                          *\n*   -GETMAIN DYNAMIC WORKAREA                                         *\n*   -CHAIN SAVEAREAS                                                  *\n*   -INITIALIZE GENERAL FAIL PARAMETER LIST TO BINARY ZEROS           *\n*   -DISABLE ATTENTION INTERRUPTS                                     *\n*                                                                     *\n***********************************************************************\n*\nHSEKPING DS    0H\n         SAVE  (14,12),,ROOM.&SYSTIME_&SYSDATE SAVE REGISTERS\n         LR    R12,R15                 LOAD R12 WITH ENTRY POINT\n         USING ROOM,R12                ESTABLISH ADDRESSABILITY\n         LR    R8,R1                   SAVE PTR TO CPPL\n         SPACE\n         GETMAIN R,LV=LDYNAMIC         GETMAIN DYNAMIC WORKAREA\n         SPACE\n         LR    R10,R1                  SAVE PTR TO GETMAINED AREA\n         ST    R13,4(R10)              SAVE PTR TO PREVIOUS SAVEAREA\n         ST    R10,8(,R13)             SAVE CURRENT SAVEARE IN PREVIOUS\n         LR    R13,R10                 LOAD R13 W/ PTR TO CUR. SAVEAREA\n         USING WORKAREA,R13            ESTABLISH ADDRESSABILITY\n         SPACE\n         XC    GFPARMS(GFLENGF),GFPARMS INITIALIZE GNRLFAIL PARMLIST\n         SPACE\n         STAX  DEFER=YES               DISABLE ATTENTION INTERRUPTS\n         EJECT\n*** MAIN PROCESS ******************************************************\n*                                                                     *\n*   - BUILD PARS AND PUTLINE PARAMETER LISTS                          *\n*   - CALL IKJPARS (VIA CALLTSSR) TO PARSE THE COMMAND                *\n*   - GET THE JES2 JCT ADDRESS                                        *\n*   - IF THE COMMAND WAS ENTERED WITHOUT OPERAND,                     *\n*         THEN LIST THE CURRENT ROOM NUMBER                           *\n*   - IF THE COMMAND WAS ENTERED WITH AN OPERAND,                     *\n*         THEN UPDATE THE ROOM NUMBER WITH THE ONE SPECIFIED          *\n*              IN THE COMMAND OPERAND FIELD                           *\n*                                                                     *\n***********************************************************************\n*\nMAINPROC DS    0H\n         BAL   R9,PROCESS              BRANCH AND LINK TO MAIN PROCESS\n*                                      ROUTINES\n         SPACE 2\n*** RETURN ************************************************************\n*                                                                     *\n*   - FREE DYANMIC WORKAREA                                           *\n*   - ENABLE ATTENTION INTERRUPTS                                     *\n*   - RESTORE CALLER'S REGISTERS                                      *\n*   - RETURN TO CALLER                                                *\n*                                                                     *\n***********************************************************************\n*\nRETURN   DS    0H\n         LR    R1,R13                  LOAD ADDRESS OF GETMAINED AREA\n         LA    R0,LDYNAMIC             LOAD LENGTH OF GETMAINED AREA\n         SPACE\n         FREEMAIN R,LV=(0),A=(1)       FREE GETMAINED AREA\n         SPACE\n         STAX  DEFER=NO                ALLOW ATTENTION INTERRUPTS AGAIN\n         SPACE\n         L     R13,4(,R13)             RELOAD ADDR OF PREVIOUS SAVEAREA\n         L     R14,12(,R13)            LOAD R14 WITH RETURN ADDRESS\n         LM    R0,R12,20(R13)          RESTORE REGISTERS\n         BR    R14                     RETURN TO CALLER\n         EJECT\n*** PROCESS - (INVOKED AT LABEL MAINPROC) *****************************\n*                                                                     *\n*   -BUILD PARSE PARAMETER LIST USING COMMAND PROCESSOR PARAMETER     *\n*        LIST (CPPL)                                                  *\n*   -BUILD PUTLINE PARAMETER LIST USING I/O SERVICE ROUTINE PARAMETER *\n*        LIST (IOPL)                                                  *\n*                                                                     *\n***********************************************************************\n*\nPROCESS  DS    0H\n         USING CPPL,R8                 ESTABLISH ADDRESSABILITY TO CPPL\n         LA    R4,PPLSECT              LOAD ADDRESS OF PPL\n         USING PPL,R4                  ESTABLISH ADDRESSABILITY TO PPL\n         LA    R5,IOPLSECT             LOAD ADDRESS OF IOPL\n         USING IOPL,R5                 ESTABLISH ADDRESSABILITY TO IOPL\n         L     R1,CPPLUPT              LOAD PTR TO USER PROF FROM CPPL\n         L     R2,CPPLECT              LOAD POINTER TO ECT FROM CPPL\n         SLR   R3,R3                   ZERO REGISTER 3\n         ST    R3,ECB                  STORE REGISTER AS ECB FOR PPL\n         LA    R3,ECB                  LOAD ADDRESS OF ECB\n         STM   R1,R3,PPLSECT           STORE ADDRESS OF UPT, ECT, AND\n*                                      ECB IN PPL\n         STM   R1,R3,IOPLSECT          STORE ADDRESS OF UPT, ECT, AND\n*                                      ECB IN IOPL\n         LA    R3,PTPB                 LOAD ADDR. OF PUTLINE PARM BLOCK\n         ST    R3,IOPLIOPB             STORE PTPB ADDRESS IN IOPL\n         MVC   PPLPCL,PCLADDR          MOVE PTR TO PCL INTO PPL\n         LA    R2,PARSBACK             LOAD ADDR OF FULLWORD TO CONTAIN\n*                                      ADDRESS OF PDE RETURNED BY PARS\n         ST    R2,PPLANS               STORE POINTER TO RETURN ADDRESS\n         MVC   PPLCBUF,CPPLCBUF        MOVE PTR TO CMD BUFFER INTO PPL\n         LA    R2,PPLUWA               LOAD ADDRESS OF USER WORK AREA\n         ST    R2,PPLUWA               STORE ADDRESS IN PPL\n         DROP  R4,R5,R8                DROP ADDRESSABILITY TO CPPL,\n*                                      IOPL, AND PPL\n         EJECT\n*** CALL PARSE ********************************************************\n*                                                                     *\n*   -CALL IKJPARS (VIA CALLTSSR) TO PARSE THE COMMAND                 *\n*        ON RETURN: - PARSBACK CONTAINS POINTER TO PDL                *\n*                   - REGISTER 15 CONTAINS PARSE RETURN CODE          *\n*                                                                     *\n***********************************************************************\n*\n         CALLTSSR  EP=IKJPARS,MF=(E,PPLSECT) CALL PARS TO PARSE COMMAND\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO\n         BZ    GOODPARS                YES....GO TO GOOD PARS ROUTINE\n         C     R15,=F'04'              DID PARS ISSUE ERROR MESSAGE?\n         BE    BADPARS                 YES....CLEANUP AND RETURN\n         C     R15,=F'20'             DID VALIDITY CHECK RTN ISSUE MSG?\n         BE    BADPARS                 YES....CLEANUP AND RETURN\n         LA    R1,GFPARSE              LOAD CALLER ID FOR PARS\n         STH   R1,GFCALLID             STORE CALLER ID IN PARMLIST\n         B     GNRLFAIL                GO TO GENERAL FAIL ROUTINE\nBADPARS  L     R15,=F'12'              TELL TMP WE HAD A PROBLEM\n         BR    R9                      RETURN TO MAINLINE\n         EJECT\n*** GOOD COMMAND PARSE ************************************************\n*                                                                     *\n*   -SET UP ADDRESSABILITY TO JES2 JCT                                *\n*                                                                     *\n***********************************************************************\n*\nGOODPARS DS    0H\n         L     R7,CVTPTR               LOAD ADDR OF CVT POINTER\n         L     R7,CVTTCBP-CVTMAP(R7)   LOAD ADDR OF NEXT/CURR TCB'S @1\n         L     R7,4(R7)                LOAD ADDR OF CURRENT TCB @1\n         L     R7,TCBJSCB-TCB(R7)      LOAD ADDR OF JSCB @1\n         L     R7,JSCBACT-IEZJSCB(R7)  LOAD ADDR OF ACTIVE JSCB @1\n         L     R7,JSCBSSIB-IEZJSCB(R7) LOAD ADDR OF LIFE-OF-JOB SSIB @1\n         L     R7,SSIBSUSE-SSIB(R7)    LOAD ADDR OF JES2 SJB @1\n         L     R7,SJBJCT-SJB(R7)       LOAD ADDR OF JES2 JCT @1\n         SPACE 2\n*** OPERAND CHECK *****************************************************\n*                                                                     *\n*   SEE IF OPERAND WAS SPECIFIED WITH COMMAND                         *\n*      - IF SO, UPDATE CURRENT ROOM NUMBER WITH THE ONE ENTERED       *\n*        IF NOT, JUST LIST THE CURRENT ROOM NUMBER                    *\n*                                                                     *\n***********************************************************************\n*\n         L     R6,PARSBACK             LOAD ADDR OF PDL\n         USING IKJPARMD,R6             ESTABLISH ADDRESSABILITY\n         TM    ROOMNO+6,X'80'          DID PARS FIND AN OPERAND?\n         BO    UPDATE                  YES....GO UPDATE ROOM NUMBER\n         SPACE 2\n*** LIST ROOM NUMBER **************************************************\n*                                                                     *\n*   -INITIALIZE THE PUTLINE OLD (OUTPUT LINE DESCRIPTOR)              *\n*   -IF CURRENT ROOM NUMBER IS VALID (I.E. NOT BINARY ZEROS)          *\n*         THEN -LIST THE CURRENT ROOM NUMBER                          *\n*         ELSE -TELL THE USER IT ISN'T SPECIFIED                      *\n*   -USE PUTLINE TO TELL THE USER                                     *\n*        ON RETURN: - REGISTER 15 CONTAINS PUTLINE RETURN CODE        *\n*                                                                     *\n***********************************************************************\nLIST     DS    0H\n         L     R2,=F'2'                GET NO. OF PUTLINE MSG SEGMENTS\n         ST    R2,MSG1OLD              STORE NUMBER OF SEGS IN O.L.D.\n         LA    R2,MSG1SEG1             GET ADDRESS OF PRIMARY SEGEMENT\n         ST    R2,MSG1OLDP             STORE IT IN O.L.D. PRIMARY ADDR\n         CLI   JCTROOMN-JCT(R7),X'00'  ROOM SPECIFIED BEFORE?   @1\n         BE    NOTSMSG                 NO, THEN WRITE 'NOT SPECIFIED'\nROOMNMSG DS    0H\n         LA    R2,MSG1SEG2             GET ADDRESS OF 2ND SEGMENT\n         ST    R2,MSG1OLDS             STORE IN 2NDARY ADDRESS OF OLD\n         LA    R2,MSG1SG2L             LOAD LENGTH OF SECOND SEGMENT\n         STH   R2,MSG1SEG2             STORE IN 2ND SEGMENT'S HEADER\n         LA    R2,MSG1TX1L             LOAD LENGTH OF PRIMARY TEXT\n         STH   R2,MSG1SEG2+2           STORE IN 2ND SEGMENT'S HEADER\n         MVC   MSG1ROOM-2(2),=C': '    MOVE PUNCTUATION TO MESSAGE\n         MVC   MSG1ROOM(4),JCTROOMN-JCT(R7) MOVE ROOM NO TO MSG @1\n         B     PUTLMSG                 GO PUTLINE THE MESSAGE\n         SPACE\nNOTSMSG  DS    0H\n         LA    R2,MSG1SEG3             GET ADDRESS OF 2ND SEGMENT\n         ST    R2,MSG1OLDS             STORE IN 2NDARY ADDRESS OF OLD\n         SPACE\nPUTLMSG  DS    0H\n         PUTLINE OUTPUT=(MSG1OLD),MF=(E,IOPLSECT)\n         SPACE\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO\n         BZR   R9                      YES...RETURN TO MAINLINE\n*                                      NO....GNRLFAIL WILL HANDLE ERROR\n         LA    R1,GFPUTL               LOAD CALLER ID FOR PUTLINE\n         STH   R1,GFCALLID             STORE CALLER ID IN PARMLIST\n         B     GNRLFAIL                GO TO GENERAL FAIL ROUTINE\n         SPACE 2\n*** UPDATE ROOM NUMBER ************************************************\n*                                                                     *\n*   -UPDATE THE ROOM NUMBER WITH THE OPERAND SPECIFIED                *\n*        (USE MODESET TO OBTAIN SCHEDULER KEY 0 IN ORDER TO           *\n*         MODIFY JES2 JCT)                                            *\n*                                                                     *\n***********************************************************************\nUPDATE   DS    0H\n         L     R2,ROOMNO               GET ADDRESS OF OPERAND\n         MODESET KEY=ZERO              SET KEY FOR ZERO (TO MODIFY JCT)\n         MVC   JCTROOMN-JCT(4,R7),0(R2)  MOVE ROOM FROM OPERAND @1\n         MODESET KEY=NZERO             RESTORE KEY BACK TO WHAT IT WAS\n         SR    R15,R15                 TELL TMP EVERYTHING WENT A-OK.\n         BR    R9                      RETURN TO MAINLINE\n         EJECT\n*** GNRLFAIL **********************************************************\n*                                                                     *\n*   GENERAL FAIL SERVICE ROUTINE HANDLES ALL ERRORS RETURNED BY       *\n*       IKJPARS AND PUTLINE.                                          *\n*   BUILD THE GF PARMLIST AND LINK TO THE GENERAL FAIL SERVICE ROUTINE*\n*                                                                     *\n***********************************************************************\nGNRLFAIL DS    0H\n         LA    R1,GFPARMS              LOAD ADDRESS OF PARMLIST\n         ST    R1,GFPARMP              STORE ADDRESS AS PTR TO PARMLIST\n         ST    R15,GFRCODE             STORE RETURN CODE IN PARMLIST\n         L     R1,SAVEAREA+4           LOAD ADDR OF PREVIOUS SAVEAREA\n         L     R1,24(R1)               LOAD POINTER TO CPPL\n         ST    R1,GFCPPLP              STORE PTR TO CPPL IN PARMLIST\n         LA    R1,ECB                  LOAD ADDRESS OF OPTIONAL ECB\n         ST    R1,GFECBP               STORE PTR TO ECB IN PARMLIST\n         SLR   R1,R1                   ZERO REGISTER 1\n         ST    R1,ECB                  SET OPTIONAL ECB TO ZERO\n         LINK  EP=IKJEFF19,MF=(E,GFPARMP)  LINK TO GNRLFAIL TO PROCESS\n*\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO\n         BZR   R9                      YES....RETURN TO MAINLINE\n         CVD   R15,WORKDEC             CONVERT RETURN CODE TO DECIMAL\n         UNPK  RETURNCD(8),WORKDEC(8)  UNPACK RETURN CODE\n         MVZ   RETURNCD+1(7),RETURNCD  MOVE ZONES IN CONVERTED RC\n         SPACE\n         TPUT  GNRLERR,GNRLERRL        TPUT GNRLFAIL FAILED MESSAGE\n         SPACE\n         TPUT  RETURNCD,8              TPUT RETURN CODE OF FAILURE\n         SPACE\n         L     R15,=F'12'              TELL THE TMP WE HAD A PROBLEM\n         BR    R9                      RETURN TO MAINLINE\n         EJECT\n*************************** EQUATES ***********************************\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n****************** POINTER TO PARS PARAMETER CSECT ********************\nPCLADDR  DC    A(PARMTAB)\n         SPACE 2\n************************ PARS PARAMETER LIST **************************\nPARMTAB  IKJPARM  DSECT=IKJPARMD\n         SPACE\nROOMNO   IKJIDENT 'ROOM NUMBER',MAXLNTH=4,                             X\n               FIRST=ALPHANUM,OTHER=ALPHANUM\n         SPACE\n         IKJENDP\n         EJECT\n*************************  TPUT MESSAGE  ******************************\nGNRLERR  DC    C'AN ERROR WAS ENCOUNTERED IN THE GENERAL FAIL SERVICE RX\n               OUTINE.  THE RETURN CODE FROM GNRLFAIL IS: '\n*        THE ACTUAL RETURN CODE FOR THIS MESSAGE IS STORED IN THE\n*        GETMAINED WORKAREA AS SYMBOL 'RETURNCD' IN ORDER TO PRESERVE\n*        PROGRAM REENTRANCY AND REUSABILITY.\nGNRLERRL EQU   *-GNRLERR\n         SPACE 2\n***********************  PUTLINE MESSAGE  *****************************\n*   THE PUTLINE MESSAGE DISPLAYED COMES IN TWO FORMATS; ONE WITH THE\n*   ACTUAL ROOM NUMBER LISTED AND ONE THAT SAYS THE ROOM NUMBER IS\n*   NOT SPECIFIED.  THE PUTLINE TEXT INSERTION FUNCTION IS USED TO\n*   CREATE THE PROPER MESSAGE.\n*   THE CONSTANT MESSAGE SEGMENTS ARE LISTED FOLLOWING THIS COMMENT.\n*   THE VARIABLE MESSAGE SEGEMENT IS LISTED IN THE DYNAMIC WORKAREA\n*   AT LABEL 'MSG1SEG2'.\n*   THE PUTLINE OUTPUT LINE DESCRIPTOR (OLD) IS ALSO IN THE DYNAMIC\n*   WORKAREA AND IS AT LABEL 'MSG1OLD'.\n***********************************************************************\n*\nMSG1SEG1 DC    H'19'                   LENGTH OF PRIMARY SEGMENT\n         DC    H'0'                    OFFSET (ALWAYS 0 IN 1ST SEGMENT)\nMSG1TXT  DS    0H\n         DC    CL15' ROOM NUMBER IS'   PRIMARY SEGMENT TEXT\nMSG1TX1L EQU   *-MSG1TXT               PRIMARY SEGMENT TEXT LENGTH\n         SPACE\nMSG1SEG3 DC    H'18'                   LENGTH OF  SEGMENT\n         DC    AL2(MSG1TX1L)           OFFSET INTO PRIMARY SEGMENT\n         DC    CL14' NOT SPECIFIED'    SEGMENT TEXT\n         SPACE 2\n*********************** DSECTS (MAPPING MACROS) ***********************\n         IKJCPPL\nCPPLLEN  EQU   *-CPPL\n         IKJPPL\nPPLLEN   EQU   *-PPL\n         IKJIOPL\nIOPLLEN  EQU   *-IOPL\n         EJECT\n*        PRINT NOGEN\n         PRINT GEN\n         $MODULE\n         $TQE\n         CVT\n         IKJTCB ,                                                    @1\n         IEZJSCB ,                                                   @1\n         IEFJSSIB ,                                                  @1\n         $BUFFER ,                                                   @1\n         $SJB ,                                                      @1\n         $JCT ,                                                      @1\n         EJECT\n*********************** DSECT FOR DYNAMIC WORKAREA ********************\nWORKAREA DSECT\nSAVEAREA DS    18F                     REGISTER SAVE AREA\n         SPACE 2\n*                                      MSG1'S OUTPUT LINE DESCRIPTOR\nMSG1OLD  DS    F                       NUMBER OF SEGMENTS IN MESSAGE\nMSG1OLDP DS    A                       ADDRESS OF PRIMARY SEGMENT\nMSG1OLDS DS    A                       ADDRESS OF SECONDARY SEGMENT\n         SPACE\nMSG1SEG2 DS    H                       LENGTH OF SEGMENT\n         DS    H                       OFFSET INTO PRIMARY SEGMENT\n         DS    CL2                     SEGMENT TEXT (: )\nMSG1ROOM DS    CL4                     SEGMENT TEXT (ROOM NUMBER)\nMSG1SG2L EQU   *-MSG1SEG2              SECOND SEGMENT LENGTH\n         SPACE 2\nPTPB     PUTLINE MF=L                  INPUT/OUTPUT PARAMTER BLOCK\nPPLSECT  DS    0F                      PARSE PARAMETER LIST AREA\n         ORG   PPLSECT+PPLLEN\nIOPLSECT DS    0F                      INPUT/OUTPUT PARAMETER LIST AREA\n         ORG   IOPLSECT+IOPLLEN\n         SPACE 2\nRETURNCD DS    D                       DECIMAL RETURN CD FROM IKJEFF19\nWORKDEC  DS    2F                      DECIMAL WORK AREA\nECB      DS    F                       ECB FOR PARS AND PUTLINE\nPARSBACK DS    F                       PTR TO PDL AFTER GOOD PARSE\nGFPARMP  DS    F                       PTR TO GNRLFAIL PARAMETER LIST\n         EJECT\n         IKJEFFGF\n         SPACE 2\nLDYNAMIC EQU   *-WORKAREA\n         END   ROOM\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTAMCHK": {"ttr": 6917, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87(\\x7f\\x00\\x87(\\x7f\\x12\\x00\\x03-\\x03-\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-10-14T00:00:00", "modifydate": "1987-10-14T12:00:00", "lines": 813, "newlines": 813, "modlines": 0, "user": "FILE325"}, "text": "*********************************************************************SL\n*                                                                    SL\n*        VTAMCHK IS A PROGRAM RUN IN A PROCEDURE THAT IS STARTED     SL\n*        BY AN 'AUTOMATIC COMMAND' IN PARMLIB(COMMNDXX): S VTAMCHK   SL\n*                                                                    SL\n*        VTAMCHK FIRST CHECKS THAT VTAM IS UP AND RUNNING, THEN      SL\n*        ISSUES ALL THE COMMANDS IN THE FILE DEFINED BY //SYSIN .    SL\n*        THESE COMMANDS ARE INTENDED TO START VTAM APPLIDS.          SL\n*                                                                    SL\n*        THE FOLLOWING OPTIONS ARE AVAILABLE AS PARM='... , ...'     SL\n*          DELAY=XX  TENTH-SECONDS TO WAIT BETWEEN COMMANDS, 10=1SEC SL\n*          COL=XX    COLUMN THAT BEGINS COMMENTS ON COMMANDS         SL\n*        AN EXAMPLE OF THE PROCEDURE FOLLOWS:                        SL\n*                                                                    SL\n*   //VTAMCHK  PROC  MEMBER=VTAMCHKA,DELAY=20                        SL\n*   //* REFER:  SYS1.PROCLIB(VTAMCHK)                                SL\n*   //* COMPID: OPER                                                 SL\n*   //* DOC:    THIS PROCEDURE IS USED TO ACTIVATE VTAM APPLICATIONS SL\n*   //*         AFTER INSURING THAT VTAM IS ACTIVE. IT IS STARTED ON SL\n*   //*         EACH SYSTEM AT IPL BY SYS1.PARMLIB(COMMND00).        SL\n*   //IEFPROC  EXEC  PGM=VTAMCHK,PARM='DELAY=&DELAY',REGION=200K     SL\n*   //SYSIN     DD DSN=SYS3.PARMLIB(&MEMBER),DISP=SHR                SL\n*   //ABNLIGNR  DD DUMMY       *** BYPASS ABEND-AID ***              SL\n*   //SYSUDUMP  DD SYSOUT=A                                          SL\n*                                                                    SL\n*        COMMANDS IN THE SYSIN STREAM ARE ISSUED EXACTLY AS SEEN.    SL\n*        A SEMICOLON (;) FOLLOWING THE COMMAND INDICATES SPECIAL     SL\n*        OPTIONS TO VTAMCHK. TO HAVE A SEMICOLON PASSED AS PART OF   SL\n*        THE COMMAND, CODE TWO CONSECUTIVE SEMICOLONS (;;).          SL\n*        THE FOLLOWING OPTIONS ARE AVAILABLE:                        SL\n*          ;DELAY=XX  TENTH-SECONDS TO WAIT BEFORE NEXT COMMAND      SL\n*          ;COL=XX    COLUMN THAT BEGINS COMMENTS ON FOLLOWING CMDS  SL\n*        AN EXAMPLE OF THE INPUT FOLLOWS:                            SL\n*                                                                    SL\n*   S TSO                                                            SL\n*   S NCCF.NCCF;DELAY=50                                             SL\n*   S CICS,REG=T1;COL=25                                             SL\n*   $SLOGON1                 START THE JES/SNA SESSION               SL\n*                                                                    SL\n*********************************************************************SL\n         EJECT                                                       SL\n         PRINT OFF                                                   SL\n         MACRO\n&NAME    BEGIN &ID,&E=,&R=8,&B=,&S=,&G=,&T=,&C=,&X=0,&BASE=11,&M=,     X\n               &TITLE=\n         GBLB  &VIREGSZ\n         GBLB  &BEGINSW\n         LCLA  &A,&AA\n         LCLA  &L,&L1\n         LCLA  &MA,&MB,&MC\n         LCLA  &MD\n         LCLA  &GETL\n         LCLC  &NAMT\n         LCLC  &BB\n         LCLC  &LBL,&D,&I,&I1,&NAM\n         LCLC  &SS\n         LCLC  &BASEX\n.*  NAME = CSECT NAME\n.*  ID = TITLE\n.*  E = N FOR NO EQUATES\n.*  R = NUMBER OF DBLE WDS FOR REPAREA (DEFAULT = 8)\n.*  B = EXTRA BASE REGS\n.*  S = SAVEAREA NAME\n.*  G = GO TO ADDR AFTER BEGIN ADDR (DEFAULT IS NSI)\n.*  T = RENT IF RENT\n.*  C = NO IS NO CSECT TO BE GENERATED\n.*  X = EXTENDED SAVEAREA LENGTH IN DBL WDS IF RENT\n.*  BASE = BASE REG IF T=RENT.  (DEFAULT = 11)\n.*  M = MULTIPLE ENTRY POINTS\n.*      FORM IS M=(B1,C1,B2,C2,...)\n.*                 BX = ENTRY NAME\n.*                 CX = GO TO NAME\n.*  INNER MACROS = GREG,FREG,GETMAIN\n.*  72.255\n         AIF   ('&S' EQ '').A020\n&SS      SETC  '&S'\n         AGO   .A040\n.A020    ANOP\n&SS      SETC  'WDC'.'&SYSNDX'.'1'\n.A040    ANOP\n         AIF   ('&ID' EQ '').A\n&I       SETC  '&ID'(1,1)\n&I1      SETC  '&ID'\n&L1      SETA  (K'&I1)\n.A       ANOP\n         AIF   ('&I' NE '''').AAAAAAA\n&I1      SETC  '&I1'(2,&L1-2) GET RID OF THE DAMN QUOTES\n.AAAAAAA ANOP\n&LBL     SETC  'WDC'.'&SYSNDX'\n         AIF   ('&NAME' EQ '').NNA\n&NAM     SETC  '&NAME'.'       '\n         AGO   .NNB\n.NNA     ANOP\n&NAM     SETC  '&LBL'\n.NNB     ANOP\n         AIF   (&BEGINSW).NNBX\n&NAMT    SETC  '&NAM'(1,4)\n.NNBX    ANOP\n         AIF   ('&ID' NE '').CCC\n         AIF   ('&NAME' NE '').CB\n&D       SETC  '&LBL'\n         AGO   .CD\n.CB      ANOP\n&D       SETC  '&NAME'\n         AIF   ('&TITLE' EQ 'N').CE\n         AGO   .CD\n.CCC     ANOP\n&NAMT    TITLE '&NAME &I1'\n         AGO   .CE\n.CD      ANOP\n&NAMT    TITLE '&D'\n.CE      AIF   ('&NAME' NE '').CF\n         AIF   ('&C' NE '').CG\n&LBL     CSECT\n         AGO   .CG\n.CF      ANOP\n         AIF   ('&C' EQ '').CF2\n&NAME    DS    0H\n         AGO   .CG\n.CF2     ANOP\n&NAME    CSECT\n.CG      AIF   ('&M' NE '').MENT\n.CGB     BALR  15,0\n         USING *,15\n         B     &LBL.A\n         AIF   ('&ID' NE '').CH\n         DC    AL1(8)\n         DC    CL8'&D'\n         AGO   .CI\n.MENT    ANOP\n&MA      SETA  N'&M\n&MB      SETA  &MA/2*2\n         AIF   (&MA EQ &MB).MENTA\n         MNOTE 8,'BEGIN--ODD NUMBER OF M PARMS'\n.MENTA   ANOP\n         AIF   (&MB EQ 0).CGB\n&MC      SETA  &MC+1\n         ENTRY &M(&MC)\n&MD      SETA  &MC/2+1\n&M(&MC)  LA    0,4*&MD\n         AIF   (&MB EQ 2).CGB\n&MD      SETA  4*&MB-4\n         B     &MD.(15)\n&MB      SETA  &MB-2\n&MC      SETA  &MC+1\n         AGO   .MENTA\n.CH      ANOP\n&L       SETA  K'&I1\n&L       SETA  &L+9\n         DC    AL1(&L)\n         DC    CL9'&NAM'\n         DC    C'&I1'\n.CI      DS    0F\n&LBL.A   STM   14,12,12(13)\n         AIF   ('&T' EQ 'RENT').G3\n         ST    13,&LBL.B+4\n         LR    12,13\n         LR    3,1\n         BAL   13,&LBL.Q\n         DROP  15\n         USING *,13\n&SS      DS    0F\n&LBL.B   DC    9C'SAVEAREA'\n         AGO   .G5\n.G3      ANOP\n         LR    12,13\n         LR    3,1\n&GETL    SETA  &X*8+72\n         GETMAIN R,LV=&GETL\n         ST    13,4(1)\n         LR    13,1\n&BASEX   SETC  '&BASE'\n         AIF   ('&BASEX' EQ '15').G5\n         AIF   ('&BASEX' EQ 'RF').G5\n         AIF   ('&BASEX' EQ 'R15').G5\n         BAL   &BASEX,&LBL.Q\n         DROP  15\n         USING *,&BASEX\n.G5      ANOP\n         AIF   ('&R' EQ '0').NOREPX\n         DC    &R.CL8'REPAREA'\n.NOREPX  ANOP\n&LBL.Q   ST    13,8(12)\n         AIF   (&BEGINSW).CC\n&BEGINSW SETB  1\n         AIF   ('&E' EQ 'N').EJECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nRA       EQU   10\nR10      EQU   10\nRB       EQU   11\nR11      EQU   11\nRC       EQU   12\nR12      EQU   12\nRD       EQU   13\nR13      EQU   13\nRE       EQU   14\nR14      EQU   14\nRF       EQU   15\nR15      EQU   15\n.EJECT   ANOP\n.CC      ANOP\n         GREG\n         FREG\n         AIF   ('&T' EQ 'RENT').END\n         AIF  ('&B' EQ '').END\n&A       SETA  0\n&BB      SETC  'R13'\n.C       ANOP\n&A       SETA  &A+1\n         LA    &B(&A),4095(&BB)\n         LA    &B(&A),1(&B(&A))\n&BB      SETC  '&B(&A)'\n         GREG  &B(&A)\n&AA      SETA  &AA+4096\n         USING &SS+&AA,&BB\n         AIF   (&A NE N'&B).C\n.END     AIF   ('&G' EQ '').MEND\n         AIF   ('&T' EQ '').A050\n         B     &G\n         AGO   .MEND\n.A050    ANOP\n         BAL   R15,*+8\n         DC    A(&G)\n         L     R15,0(R15)\n         BR    R15\n.MEND    AIF   ('&M' EQ '').EJECTX\n&MA      SETA  0\n&MB      SETA  N'&M\n&MC      SETA  &MB/2*2\n         AIF   (&MC EQ 0).EJECTX\n         CNOP  0,4\n         LR    15,0\n         L     15,*+2(15)\n         BR    15\n.MENTB   ANOP\n         AIF   (&MC EQ 0).EJECTX\n&MA      SETA  &MA+2\n         DC    A(&M(&MA))\n&MC      SETA  &MC-2\n         AGO   .MENTB\n.EJECTX  EJECT\n         MEND\n         MACRO\n&L       ENDIT &C\n         LCLA  &A,&B\n         LCLC  &LBL,&CD\n         AIF   ('&C' EQ '').AAA\n&CD      SETC  '&C'(1,1)\n.AAA     ANOP\n&LBL     SETC  'WFB'.'&SYSNDX'\n         AIF   ('&L' EQ '').A\n&L       EQU   *\n.A       AIF   ('&C' NE '').CC\n         SR    15,15\n.CA      L     13,4(13)\n         L     14,12(13)\n         LM    0,12,20(13)\n         BR    14\n         AIF   (&A LT 1).CAC\n         AIF   (&A EQ 1).CAA\n&LBL     DC    D'0'\n         MEXIT\n.CAA     ANOP\n&C       DC    H'0'\n.CAC     ANOP\n         MEXIT\n.CB      ANOP\n         LA    15,&C\n         AGO   .CA\n.CC      AIF   ('&CD' NE '(').CD\n         AIF   ('&SYSLIST(1)' EQ '(15)').CA\n         AIF   ('&SYSLIST(1)' EQ '(RF)').CA\n         AIF   ('&SYSLIST(1)' EQ '(R15)').CA\n         LR    15,&C(1)\n         AGO   .CA\n.CD      AIF  ('&CD' GT 'Z').CB\n         AIF   (T'&C NE 'U').CE\n.CDD     LH    15,&C\n&A       SETA  1\n         AGO   .CA\n.CE      AIF   (T'&C NE 'J').CF\n         L     13,4(13)\n         LM    14,12,12(13)\n         BR    14\n         MEXIT\n.CF      AIF   (T'&C EQ 'N').CB\n         AIF   (T'&C EQ 'H').CG\n         AIF   (T'&C EQ 'S').CG\n         AIF   (T'&C EQ 'Y').CH\n.CG      LH    15,&C\n         AGO   .CA\n.CH      AIF   (T'&C EQ 'D').CI\n         AIF   (T'&C NE 'W').CJ\n.CI      L     15,&C+4\n         AGO   .CA\n.CJ      AIF   (T'&C EQ 'A' OR T'&C EQ 'V').CK\n         AIF   (T'&C NE 'Q').CL\n.CK      L     15,&C\n         AGO   .CA\n.CL      AIF   (T'&C EQ 'P').CN\n         AIF   (T'&C EQ 'C').CM\n         AIF   (T'&C NE 'Z').CP\n.CM      PACK  &LBL,&C\n         AGO   .CO\n.CN      ZAP   &LBL,&C\n.CO      CVB   15,&LBL\n&A       SETA  2\n         AGO   .CA\n.CP      ANOP\n&A       SETA  L'&C\n&B       SETA  L'&C-4\n         AIF   ('&B' GT '0').CQ\n&B       SETA  0\n.CQ      ANOP\n&A       SETA  &A-&B\n         AIF   ('&L' EQ '').CPP\n&L       EQU   *\n.CPP     AIF   ('&A' GT '3').CR\n         SR    15,15\n.CR      IC    15,&C+&B\n&B       SETA  &B+1\n&A       SETA  &A+1\n         AIF   ('&A' LT '1').CA\n         SLL   15,8\n         AGO   .CR\n         MEND\n         MACRO\n&LABEL   GREG\n         GBLB  &VIREGSZ\n         GBLA  &VIREGSA(256)\n         GBLA  &VIREGS(16)\n         GBLC  &VIREGSE(256)\n         LCLA  &A,&B,&C,&D,&E\n         AIF   (&VIREGSZ).X22\n         AGO   .XXX\n.X22     ANOP\n**********************************************************************\n         DUMPR\n**********************************************************************\n.XXX     ANOP\n         AIF   ('&VIREGSE(1)' EQ 'R0').START\n.FL      ANOP\n&A       SETA  &A+1\n&B       SETA  &A-1\n&VIREGSE(&A) SETC 'R'.'&B'\n&VIREGSA(&A) SETA &A\n         AIF   (&A NE 16).FL\n&VIREGS(1) SETA 1\n&VIREGS(2) SETA 2\n&VIREGS(3) SETA 3\n&VIREGS(4) SETA 4\n&VIREGS(14) SETA 14\n&VIREGS(15) SETA 15\n&VIREGS(16) SETA 16\n&VIREGSE(17) SETC 'RA'\n&VIREGSE(18) SETC 'RB'\n&VIREGSE(19) SETC 'RC'\n&VIREGSE(20) SETC 'RD'\n&VIREGSE(21) SETC 'RE'\n&VIREGSE(22) SETC 'RF'\n&VIREGSA(17) SETA 11\n&VIREGSA(18) SETA 12\n&VIREGSA(19) SETA 13\n&VIREGSA(20) SETA 14\n&VIREGSA(21) SETA 15\n&VIREGSA(22) SETA 16\n&A       SETA  0\n&B       SETA  0\n.START   AIF   ('&LABEL' EQ '').LOOPX\n&LABEL   DS    0H\n.LOOPX   ANOP\n         AIF   (N'&SYSLIST NE 0).LOOP\n.LX      ANOP\n&A       SETA  &A+1\n&VIREGS(&A) SETA &A\n         AIF   (&A NE 16).LX\n         AGO   .END\n.LOOP    ANOP\n&C       SETA  0\n&A       SETA  &A+1\n&D       SETA  N'&SYSLIST(&A)\n         AIF   ('&SYSLIST(&A)' EQ '').END\n         AIF   (T'&SYSLIST(&A) EQ 'N').SELFDEF\n         AIF   ('&SYSLIST(&A)'(1,1) GE '0').SELFDEF\n         AIF   (N'&SYSLIST(&A) GT 1).ALIGN\n.L3      AIF   (&C EQ 16).NOREG\n&C       SETA  &C+1\n         AIF   (&VIREGS(&C) NE 0).L3\n         AGO   .L25\n.ALIGN   AIF   (&C EQ 16).NOREG\n&C       SETA  &C+1\n         AIF   (&VIREGS(&C) NE 0).ALIGN\n&B       SETA  &C/2\n&B       SETA  &B+&B\n         AIF   (&C EQ &B).ALIGN\n.AA      ANOP\n&D       SETA  &D-1\n         AIF   (&D EQ 0).GOTTEM\n&C       SETA  &C+1\n         AIF   (&C GT 16).NOREG\n         AIF   (&VIREGS(&C) NE 0).ALIGN\n         AGO   .AA\n.GOTTEM  ANOP\n&C       SETA  &B+1\n.L25     ANOP\n&D       SETA  1\n.B0      ANOP\n         AIF   ('&SYSLIST(&A,&D)'(1,1) GE '0').BADMID\n         AIF   (T'&SYSLIST(&A,&D) EQ 'N').BADMID\n&B       SETA  0\n.L2      ANOP\n&B       SETA  &B+1\n         AIF   (&B GT 256).NOMORE\n         AIF   ('&SYSLIST(&A,&D)' EQ '&VIREGSE(&B)').WARNA\n         AIF   ('&VIREGSE(&B)' NE '').L2\n&VIREGSE(&B) SETC '&SYSLIST(&A,&D)'\n&VIREGSA(&B) SETA &C\n&VIREGS(&C) SETA &B\n&C       SETA  &C-1\n&SYSLIST(&A,&D) EQU R&C\n&C       SETA  &C+2\n.B4      AIF   (&D EQ N'&SYSLIST(&A)).LOOP\n&D       SETA  &D+1\n         AGO   .B0\n.NOREG   MNOTE 8,'NO REGISTERS AVAILABLE FOR &SYSLIST(&A)'\n         AGO   .LOOP\n.NOMORE  MNOTE 8,'NO VIRTUAL REG AVAILABLE FOR &SYSLIST(&A,&D)'\n         AGO   .B4\n.WARNA   ANOP\n&E       SETA  &VIREGSA(&B)-1\n         AIF   (&VIREGS(&VIREGSA(&B)) EQ &B).BX\n         AIF   (&VIREGS(&VIREGSA(&B)) EQ 0).BY\n&E       SETA  &E+1\n MNOTE 8,'&SYSLIST(&A,&D) R&E IS NOW ASSIGNED TO &VIREGSE(&VIREGS(&E))'\n         AGO   .B4\n.BX      ANOP\n         MNOTE 0,'&SYSLIST(&A,&D) ALREADY ASSIGNED TO R&VIREGSA(&E)'\n         AGO   .B4\n.BY      ANOP\n&VIREGS(&VIREGSA(&B))  SETA &B\n         AGO   .B4\n.SELFDEF ANOP\n&C       SETA  &SYSLIST(&A)\n         AIF   (&C GT 15).NGSLF\n&C       SETA  &C+1\n         AIF   (&VIREGS(&C) EQ 0).OK\n&E       SETA  &VIREGS(&C)\n         MNOTE 8,'REG &SYSLIST(&A) IS ASSIGNED TO &VIREGSE(&E)'\n         AGO   .LOOP\n.OK      ANOP\n&VIREGS(&C) SETA &SYSLIST(&A)+1\n         AGO   .LOOP\n.NGSLF   MNOTE 8,'&SYSLIST(&A) IS AN INVALID REGISTER'\n         AGO   .LOOP\n.BADMID  MNOTE 8,'SELF DEFINING REG NOT PERMITTED IN ALIGNMENT'\n&B       SETA  0\n         AGO   .L2\n.END     MEND\n         MACRO\n&LABEL   FREG\n         GBLB  &VIREGSZ\n         GBLA  &VIREGSA(256),&VIREGS(16)\n         GBLC  &VIREGSE(256)\n         LCLA  &A,&B,&C\n         AIF   (&VIREGSZ).X22\n         AGO   .XXX\n.X22     ANOP\n**********************************************************************\n         DUMPR\n**********************************************************************\n.XXX     ANOP\n         AIF   ('&LABEL' EQ '').NOL\n&LABEL   DS    0H\n.NOL     AIF   ('&VIREGSE(16)' EQ 'R15').STARTX\n         MNOTE 0,'FREG AND SREG  MAY NOT PRECEED GREG, LREG OR PBEG'\n         MEXIT\n.STARTX  AIF   (N'&SYSLIST NE 0).START\n&A       SETA  4\n.SX      ANOP\n&A       SETA  &A+1\n&VIREGS(&A) SETA 0\n         AIF   (&A NE 13).SX\n         AGO   .END\n.START   ANOP\n&A       SETA  0\n.LOOP    ANOP\n&B       SETA  0\n&A       SETA  &A+1\n         AIF   ('&SYSLIST(&A)' EQ '').END\n         AIF   (T'&SYSLIST(&A) NE 'N').FIND\n&B       SETA  &SYSLIST(&A)\n         AIF   (&B LT 16).DD\n         MNOTE 0,'&SYSLIST(&A) IS AN INVALID REGISTER'\n         AGO   .LOOP\n.DD      ANOP\n&B       SETA  &B+1\n         AIF   (&VIREGS(&B) EQ 0).NOU\n&VIREGS(&B) SETA 0\n         AGO   .LOOP\n.NOU     MNOTE 0,'&SYSLIST(&A) IS NOT CURRENTLY USED'\n         AGO   .LOOP\n.FIND    ANOP\n&B       SETA  &B+1\n         AIF   ('&VIREGSE(&B)' EQ '').NOR\n         AIF   ('&VIREGSE(&B)' NE '&SYSLIST(&A)').FIND\n         AIF   (&VIREGS(&VIREGSA(&B)) EQ 0).UNUSED\n         AIF   (&VIREGS(&VIREGSA(&B)) EQ &B).FOK\n&C       SETA  &VIREGSA(&B)-1\n MNOTE '&SYSLIST(&A) = R&C ASSIGNED TO &VIREGSE(&VIREGS(&VIREGSA(&B)))'\n         AGO   .LOOP\n.FOK     ANOP\n&VIREGS(&VIREGSA(&B)) SETA 0\n         AGO   .LOOP\n.NOR     MNOTE 0,'&SYSLIST(&A) NOT ASSIGNED'\n         AGO   .LOOP\n.UNUSED  ANOP\n&B       SETA  &VIREGSA(&B)\n&B       SETA  &B-1\n         MNOTE 0,'&SYSLIST(&A) = R&B IS NOT CURRENTLY USED'\n         AGO   .LOOP\n.END     MEND\n         PRINT ON                                                    SL\nVTAMCHK  BEGIN 'START VTAM APPLS AFTER VTAM INIT VER 1.1 &SYSDATE ',R=0\n         LA    R12,SYSIN          GET DCB ADDRESS FOR ADDRESABILITY\n         USING IHADCB,R12         USE SYMBOLIC REFS FOR DCB\n         MODESET KEY=ZERO         GET PROTECT KEY ZERO FOR SVC 34\n         L     R1,16              POINTER TO CVT\n         L     R1,0(R1)           POINTER TO NEXT/CURRENT TCB\n         L     R1,4(R1)           POINTER TO OUR TCB\n         L     R1,12(R1)          POINTER TO TIOT\n         LA    R1,24(R1)          POINT TO FIRST DD ENTRY\n         SLR   R0,R0              CLEAR ENTRY LENGTH REGISTER\nA00100   DS    0H\n         ALR   R1,R0              POINT TO NEXT DD ENTRY\n         IC    R0,0(R1)           GET LENGTH OF THIS ENTRY\n         LTR   R0,R0              IS THIS END OF TIOT\n         BNP   A00200             YES - SYSIN DD CARD IS NOT PRESENT\n         CLC   DCBDDNAM,4(R1)     IS IT ENTRY FOR SYSIN\n         BNE   A00100             NO - CONTINUE SCAN OF TIOT\n         OPEN  (SYSIN,(INPUT))    OPEN SYSIN FILE\n         TM    DCBOFLGS,DCBOFOPN  WAS OPEN SUCCESSFUL\n         BO    A00140             YES - CONTINUE\n         WTO   'VTAMCHK01I - OPEN FAILED FOR DDNAME SYSIN'\n         MVI   RCODE+1,12         SET RETURN CODE TO TWELVE\n         B     A02000             DO NOT CONTINUE\nA00140   DS    0H\n         TM    FLAG1,BADRECFM     IS RECFM OK\n         BZ    A00160             YES, CONTINUE\n         WTO   'VTAMCHK03I - SYSIN RECFM MUST BE FIXED OR FIXED BLOCK'\n         MVI   RCODE+1,12         SET RETURN CODE TO TWELVE\n         B     A02000             DO NOT CONTINUE\nA00160   DS    0H\n         TM    FLAG1,BADLRECL     IS LRECL OK\n         BZ    A00180             YES, CONTINUE\n         WTO   'VTAMCHK04I - SYSIN LRECL SIZE MUST BE 140 OR LESS'\n         MVI   RCODE+1,12         SET RETURN CODE TO TWELVE\n         B     A02000             DO NOT CONTINUE\nA00180   DS    0H\n         LH    R15,DCBLRECL       GET THE LRECL LENGTH\n         SH    R15,HNINE          SUBTRACT 9 FOR ASSUMED SEQ NUMS\n         STH   R15,CMDCOLS        SET DEFAULT COMMAND COLUMN LENGTH\n         LA    R4,36              36 X ACBWAIT (5 SEC) = 3 MIN TOTAL\nA00184   DS    0H\n         OPEN  VTAMACB            ISSUE OPEN ACB TO SEE IF VTAM ACTIVE\n         LTR   R15,R15            IS OPEN ACB GOOD (VTAM IS ACTIVE)\n         BZ    A00196             YES, GO ISSUE SPECIFIED COMMANDS\n         CH    R15,HEIGHT         IS RETURN CODE GREATER THAN 8\n         BE    A00186             NO, CHECK ACB FOR ERROR CONDITIONS\n         WTO   'VTAMCHK20I - DISASTEROUS OPEN ACB FAILURE'\n         ABEND 100,DUMP\nA00186   DS    0H\n         SHOWCB ACB=VTAMACB,FIELDS=ERROR,AREA=ACBERROR,LENGTH=4,AM=VTAM\n         CLI   ACBERROR+3,92      IS VTAM INACTIVE\n         BE    A00190             YES, GO WAIT THEN TRY AGAIN\n         CLI   ACBERROR+3,90      IS APPLID INACTIVE\n         BE    A00188             YES, GO WAIT THEN TRY AGAIN\n         CLI   ACBERROR+3,20      IS THERE A TEMPORARY STORAGE SHORTAGE\n         BE    A00190             YES, GO WAIT THEN TRY AGAIN\n         CLI   ACBERROR+3,82      IS VTAM STOPPING\n         BE    A00190             YES, GO WAIT THEN TRY AGAIN\n         CLI   ACBERROR+3,88      IS VTAMCHK ACB ALREADY OPEN\n         BE    A00190             YES, GO WAIT THEN TRY AGAIN\n         CLI   ACBERROR+3,188     IS VTAMCHK ACB OPENING/CLOSING\n         BE    A00190             YES, GO WAIT THEN TRY AGAIN\nA00187   DS    0H\n         SLR   R1,R1              CLEAR REGISTER 1 FOR INSERT\n         IC    R1,ACBERROR+3      INSERT FOR CONVERSION\n         CVD   R1,DOUBLE          CONVERT ERROR FIELD TO PACKED DECIMAL\n         UNPK  MSG21ERR,DOUBLE+6(2) UNPACK ERROR FOR MESSAGE\n         OI    MSG21ERR+2,X'F0'   FIX THE SIGN BYTE\n         LA    R1,MSG21           POINT TO MESSAGE\n         WTO   MF=(E,(R1))        ISSUE THE MESSAGE\n         ABEND 200                TERMINATE PROCESSING\nA00188   DS    0H\n         BCT   R5,A00190          CONTINUE IF COUNT ALLOWS\n         B     A00187             DON'T WAIT ANY MORE\nA00190   DS    0H\n         STIMER WAIT,BINTVL=ACBWAIT  WAIT FOR SPECIFIED TIME\n         B     A00184             TRY TO OPEN THE ACB AGAIN\nA00196   DS    0H\n         CLOSE (VTAMACB)          FINISHED WITH VTAM\nA00200   DS    0H\n         L     R1,0(R3)           GET POINTER TO COMMAND LIST\n         LH    R0,0(R1)           GET LENGTH OF COMMAND LIST\n         LTR   R0,R0              ARE THERE ANY MORE COMMANDS IN LIST\n         BNP   A01800             NO - GO CHECK FOR MORE SYSIN CARDS\n         MVI   CMDSTART,C' '      INITIALIZE TO BLANK\n         MVC   CMDAREA,CMDSTART   CLEAR THE COMMAND WORK AREA\n         SLR   R4,R4              CLEAR THE COMMAND LENGTH REGISTER\n         LA    R5,2(R1)           POINT TO START OF COMMAND\nA00300   DS    0H\n         CLI   0(R5),C';'         IS IT SEMICOLON (COMMAND SEPERATOR)\n         BNE   A00400             NO - GO CHECK NEXT CHARACTER\n         LA    R5,1(R5)           POINT PAST THE SEMICOLON\n         BCTR  R0,0               SUBTRACT LENGTH OF SEMICOLON\n         CLI   0(R5),C';'         SECOND SEMICOLON MEANS NON CMD SEP\n         BNE   A00500             IF NOT, GO TERMINATE THIS COMMAND\n         LA    R4,1(R4)           ADD ONE TO LENGTH FOR PREVIOUS SEMI\n         LR    R15,R0             GET TOTAL LENGTH OF STRING\n         SR    R15,R4             SUBTRACT LENGTH SO FAR\n         LTR   R15,R15            IS ANYTHING LEFT TO MOVE\n         BNP   A00500             NO, GO ISSUE THIS COMMAND\n         BCTR  R15,R0             GET LENGTH CODE FOR MOVE\n         EX    R15,MOVESEMI       REMOVE SECOND SEMICOLON\n         B     A00300             CONTINUE SCAN\nA00400   DS    0H\n         LA    R4,1(R4)           ADD ONE TO LENGTH OF THIS COMMAND\n         LA    R5,1(R5)           POINT TO NEXT CHARACTER IN LIST\n         CLR   R0,R4              WAS THAT LAST CHARACTER IN LIST\n         BH    A00300             NO - CONTINUE SCAN FOR SEMICOLON\nA00500   DS    0H\n         SLR   R0,R4              SUBTRACT COMMAND LENGTH FROM TOTAL\n         STH   R0,0(R1)           SAVE NEW TOTAL BACK IN PARM LIST\n         LTR   R4,R4              IS COMMAND LENGTH GREATER THAN ZERO\n         BNP   A00600             NO - DO NOT TRY TO MOVE IT\n         CH    R4,H130            IS LENGTH GREATER THAN MAX\n         BNH   A00550             NO, GO MOVE IT TO CMD ISSUE AREA\n         WTO   'VTAMCHK05I - COMMAND NOT ISSUED, LENGTH >130'\n         MVI   RCODE+1,4          SET RETURN CODE TO 4\n         SLR   R4,R4              SET COMMAND LENGTH TO ZERO\n         B     A00600             GO ISSUE NULL COMMAND\nA00550   DS    0H\n         BCTR  R4,0               DECREMENT TO GET LENGTH CODE\n         EX    R4,MOVECMD         MOVE COMMAND FROM LIST TO WORK AREA\nA00600   DS    0H\n         LA    R4,6(R4)           SET TOTAL LENGTH OF COMMAND\n         STH   R4,CMDLEN          SAVE IN LENGTH WORK AREA\n         LTR   R4,R0              ARE THERE ANY MORE COMMANDS IN LIST\n         BNP   A00700             NO - DO NOT TRY TO MOVE IT\n         BCTR  R4,0               DECREMENT TO GET LENGTH CODE\n         EX    R4,MOVELIST        SHIFT REMAINING COMMAND(S) IN LIST\nA00700   DS    0H\n         CLC   CMDAREA(6),DELAY   IS A COMMAND DELAY TIME SPECIFIED\n         BNE   A01200             NO, GO ISSUE OPERATOR COMMAND\n         SLR   R4,R4              CLEAR LENGTH COUNTER\n         LA    R5,CMDAREA+6       POINT TO START OF DELAY OPERAND\n         LA    R6,4               SET FOR LOOP CNTL - MAX OF 3 DIGITS\nA00800   DS    0H\n         TM    0(R5),X'F0'        IS IT A NUMERIC DIGIT\n         BO    A01000             YES, CONTINUE\n         CLI   0(R5),C' '         ARE WE AT END\n         BE    A01100             YES, GET OUT OF LOOP\nA00900   DS    0H\n         WTO   'VTAMCHK02I - INVALID DELAY OPERAND SPECIFIED'\n         MVI   RCODE+1,8          SET BAD RETURN CODE\n         TM    DCBOFLGS,DCBOFOPN  IS SYSIN FILE OPEN\n         BO    A01900             YES, GO CLOSE IT\n         B     A02000             NO, DO NOT CLOSE IT\nA01000   DS    0H\n         LA    R4,1(R4)           INCREMENT LENGTH COUNTER\n         LA    R5,1(R5)           BUMP OPERAND POINTER\n         BCT   R6,A00800          CONTINUE CHECK FOR 3 DIGITS\n         B     A00900               - THEN INVALID OPERAND\nA01100   DS    0H\n         LTR   R4,R4              IS LENGTH COUNTER ZERO\n         BZ    A00900             YES, OPERAND IS INVALID\n         BCTR  R4,R0              DECREMENT TO GET LENGTH CODE\n         EX    R4,PKDELAY         PACK THE DELAY TIME\n         CVB   R6,DOUBLE          CONVERT DELAY TIME TO BINARY\n         MH    R6,HTEN            CONVERT 10THS TO 100THS OF SECONDS\n         ST    R6,DELAYTM         SAVE DELAY TIME FOR STIMER\n         OI    FLAG1,DELAYSW      INDICATE WE HAVE A DELAY TIME\n         B     A00200             GO CHECK FOR MORE COMMANDS\nA01200   DS    0H\n         CLC   CMDAREA(4),COL     IS A CARD COLUMN FOR CMDS SPECIFIED\n         BNE   A01700             NO, GO ISSUE OPERATOR COMMAND\n         SLR   R4,R4              CLEAR LENGTH COUNTER\n         LA    R5,CMDAREA+4       POINT TO START OF COLUMN OPERAND\n         LA    R6,4               SET FOR LOOP CNTL - MAX OF 3 DIGITS\nA01300   DS    0H\n         TM    0(R5),X'F0'        IS IT A NUMERIC DIGIT\n         BO    A01500             YES, CONTINUE\n         CLI   0(R5),C' '         ARE WE AT END\n         BE    A01600             YES, GET OUT OF LOOP\nA01400   DS    0H\n         WTO   'VTAMCHK02I - INVALID COL OPERAND SPECIFIED'\n         MVI   RCODE+1,8          SET BAD RETURN CODE\n         TM    DCBOFLGS,DCBOFOPN  IS SYSIN FILE OPEN\n         BO    A01900             YES, GO CLOSE IT\n         B     A02000             NO, DO NOT CLOSE IT\nA01500   DS    0H\n         LA    R4,1(R4)           INCREMENT LENGTH COUNTER\n         LA    R5,1(R5)           BUMP OPERAND POINTER\n         BCT   R6,A01300          CONTINUE CHECK FOR 3 DIGITS\n         B     A01400               - THEN INVALID OPERAND\nA01600   DS    0H\n         LTR   R4,R4              IS LENGTH COUNTER ZERO\n         BZ    A01400             YES, OPERAND IS INVALID\n         BCTR  R4,R0              DECREMENT TO GET LENGTH CODE\n         EX    R4,PKCOL           PACK THE COLUMN VALUE\n         CVB   R6,DOUBLE          CONVERT COLUMNS TO BINARY\n         CH    R6,DCBLRECL        IS COL VALUE MORE THAN LRECL LENGTH\n         BH    A01400             YES, DO NOT USE IT\n         STH   R6,CMDCOLS         SAVE COLLUMNS FOR SYSIN PROCESSING\n         B     A00200             GO CHECK FOR MORE COMMANDS\nA01700   DS    0H\n         SLR   R0,R0              CLEAR MCS REGISTER\n         LA    R1,CMDLEN          POINT TO COMMAND\n         SVC   34                 ISSUE OPERATOR COMMAND\n         TM    FLAG1,DELAYSW      IS A DELAY TIME WANTED BETWEEN CMDS\n         BZ    A00200             NO, GO PROCESS THE NEXT COMMAND\n         STIMER WAIT,BINTVL=DELAYTM  WAIT FOR APPROPRIATE INTERVAL\n         B     A00200             GO SEE IF MORE COMMANDS IN LIST\nA01800   DS    0H\n         TM    DCBOFLGS,DCBOFOPN  IS SYSIN FILE OPEN\n         BZ    A02000             NO - WE ARE ALL DONE\n         GET   SYSIN,CARD         READ ANOTHER COMMAND CARD\n         MVC   CARDLEN,CMDCOLS    SET THE CARD LIST LENGTH\n         LA    R3,CARDPTR         POINT TO CARD PARAMETER LIST\n         B     A00200             GO DO IT\nA01900   DS    0H\n         CLOSE (SYSIN)            CLOSE SYSIN FILE\nA02000   DS    0H\n         MODESET KEY=NZERO        GET ORIGINAL PROTECT KEY FOR RETURN\n         ENDIT RCODE\n         EJECT\n* OPEN EXIT TO CHECK SYSIN DCB CHARACTERISTICS\n*\nO00100   DS    0H\n         CLI   DCBRECFM,0         IS RECFM=0\n         BNE   O00200             NO, GO SEE IF IT IS FIXED LENGTH\n         MVI   DCBRECFM,DCBRECF   SET RECFM=F IF NONE SPECIFIED\nO00200   DS    0H\n         TM    DCBRECFM,DCBRECF   IS RECFM=F\n         BO    O00300             YES, CONTINUE\n         OI    FLAG1,BADRECFM     SET FLAG TO NOT PROCESS SYSIN\n         BR    R14                RETURN FROM OPEN EXIT\nO00300   DS    0H\n         CLC   DCBLRECL,HZERO     IS LRECL=0\n         BNE   O00400             NO, GO SEE IF IT IS TOO LARGE\n         MVI   DCBLRECL+1,80      SET DEFAULT LRECL=80\nO00400   DS    0H\n         CLC   DCBLRECL,H140      IS LRECL GREATER THAN MAX\n         BNH   O00500             NO, GO CHECK BLKSIZE\n         OI    FLAG1,BADLRECL     SET FLAG TO NOT PROCESS SYSIN\n         BR    R14                RETURN FROM OPEN EXIT\nO00500   DS    0H\n         CLC   DCBBLKSI,HZERO     IS BLKSIZE=0\n         BNE   O00600             NO, GO RETURN FROM OPEN EXIT\n         MVC   DCBBLKSI,DCBLRECL  SET BLKSIZE=LRECL\nO00600   DS    0H\n         BR    R14                RETURN FROM OPEN EXIT\n         EJECT\n*  E X E C E C U T E D   I N S T R U C T I O N S\n         SPACE\nMOVECMD  MVC   CMDAREA(0),2(R1)   MOVE COMMAND FROM LIST TO WORK AREA\nMOVELIST MVC   2(0,R1),0(R5)      SHIFT COMMAND(S) LEFT IN LIST\nMOVESEMI MVC   0(0,R5),1(R5)      SHIFT STRING TO DELETE SEMICOLON\nPKDELAY  PACK  DOUBLE,CMDAREA+6(0)  PACK DELAY TIME INTO DOUBLE WORD\nPKCOL    PACK  DOUBLE,CMDAREA+4(0)  PACK CMD COLUMNS INTO DOUBLE WORD\n         EJECT\n         PRINT NOGEN\nDOUBLE   DC    D'0'               DOUBLE WORD WORK AREA\nVTAMACB  ACB   AM=VTAM,APPLID=APPLID\nSYSIN    DCB   DSORG=PS,MACRF=GM,DDNAME=SYSIN,EODAD=A01900,            X\n               EXLST=OPENEXIT\nOPENEXIT DC    0F'0',X'85',AL3(O00100)\nACBWAIT  DC    A(100*5)           WAIT TIME FOR OPEN ACB STIMER (5 SEC)\nDELAYTM  DC    F'0'               WAIT TIME FOR COMMAND STIMER\nACBERROR DC    F'0'               SPECIFIC ERROR CODE FOR OPEN ACB FAIL\nCMDLEN   DC    AL2(0,0)           COMMAND LENGTH FOR SVC\nCMDSTART DC    C' '               START OF COMMAND MUST BE BLANK\nCMDAREA  DC    CL131' '           ACTUAL START OF COMMAND\nCMDCOLS  DC    H'71'              DEFAULT LENGTH OF SYSIN CARD LIST\nHZERO    DC    H'0'               HALFWORD OF ZERO\nHEIGHT   DC    H'8'               HALFWORD OF EIGHT\nHNINE    DC    H'9'               HALFWORD OF NINE\nHTEN     DC    H'10'              HALFWORD OF TEN\nH130     DC    H'130'             HALFWORD OF ONE HUNDRED THIRTY\nH140     DC    H'140'             HALFWORD OF ONE HUNDRED FOURTY\nCARDPTR  DC    A(CARDLEN)         POINTER TO SYSIN CARD PARAMETER LIST\nCARDLEN  DC    H'0'               LENGTH OF SYSIN CARD LIST\nCARD     DC    CL140' '           SYSIN CARD WORK AREA\nCOL      DC    C'COL='            COL PARM COMPARATOR\nDELAY    DC    C'DELAY='          DELAY PARM COMPARATOR\nAPPLID   DC    AL1(8),CL8'VTAMCHK' VTAM APPLICATION ID\nFLAG1    DC    X'00'              GENERAL PURPOSE SWITCHES\nDELAYSW  EQU   X'80'              DELAY TIME WANTED BETWEEN COMMANDS\nBADRECFM EQU   X'40'              SYSIN RECFM IS NOT F OR FB\nBADLRECL EQU   X'20'              SYSIN LRECL IS GREATER THAN 140\nMSG21    WTO   'VTAMCHK21I - OPEN ACB FAILURE ERROR CODE: XXX ',MF=L\nMSG21ERR EQU   MSG21+46,3\n         DCBD  DSORG=PS\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTOCLIST": {"ttr": 7176, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87(\\x7f\\x00\\x87(\\x7f\\x12\\x00\\x17b\\x17b\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-10-14T00:00:00", "modifydate": "1987-10-14T12:00:00", "lines": 5986, "newlines": 5986, "modlines": 0, "user": "FILE325"}, "text": "*\n* N   N  OOO  TTTTT EEEEE        THIS IS INTENDED TO BE ASSEMBLED BY\n* NN  N O   O   T   E      **\n* N N N O   O   T   EEE                 A S S E M B L E R   H\n* N  NN O   O   T   E      **\n* N   N  OOO    T   EEEEE        IF YOU DO NOT HAVE ASMH, BREAK EACH\n*                                CSECT INTO A SEPARATE ASSEMLBY STEP,\n*                                THEN LINK ALL 4 CSECTS TOGETHER.\n         MACRO\n&SYMBOL  XPROPEN  &WA,&MAXLINE=0,&PAGENO=0,&PAGEWID=0,&PAGELEN=0,      X\n               &TIME=0,&DATE=0,&DDNAME=SYSPRINT,&IHBPARM=56\n.* MACRO TO EXECUTE AN 'OPEN' OR 'MODIFY' CALL TO 'XPRNTSUB'.\n         LCLC  &TAG\n&TAG     SETC  'IHB&SYSNDX'\n         AIF   ('&SYMBOL' EQ '').T1\n&SYMBOL  DS    0H\n.T1      AIF   ('&MAXLINE'(1,1) NE '(').T2\n         ST    &MAXLINE(1),&TAG.A      STORE IN PARM LIST\n.T2      AIF   ('&PAGENO'(1,1) NE '(').T3\n         STH   &PAGENO(1),&TAG.A+4     STORE IN PARM LIST\n.T3      AIF   ('&PAGEWID'(1,1) NE '(').T4\n         STC   &PAGEWID(1),&TAG.A+6    STORE IN PARM LIST\n.T4      AIF   ('&PAGELEN'(1,1) NE '(').T5\n         STC   &PAGELEN(1),&TAG.A+7    STORE IN PARM LIST\n.T5      AIF   ('&TIME'(1,1) NE '(').T6\n         ST    &TIME(1),&TAG.A+8       STORE IN PARM LIST\n.T6      AIF   ('&DATE'(1,1) NE '(').T7\n         ST    &DATE(1),&TAG.A+12      STORE IN PARM LIST\n.T7      AIF   ('&DDNAME'(1,1) NE '(').CNOP\n         MVC   &TAG.A+16(8),0(&DDNAME(1))  STORE IN PARM LIST\n.CNOP    CNOP  0,4\n         BAL   1,&TAG.L        LOAD PARM LIST ADDRESS\n.P1      AIF   ('&MAXLINE'(1,1) EQ '(').PR1\n&TAG.A   DC    A(&MAXLINE)             PRINT OUTPUT LIMIT\n         AGO   .P2\n.PR1     ANOP\n&TAG.A   DC    A(0)                    PRINT OUTPUT LIMIT\n.P2      AIF   ('&PAGENO'(1,1) EQ '(').PR2\n         DC    AL2(&PAGENO)            PAGE NUMBER\n         AGO   .P3\n.PR2     DC    AL2(0)                  PAGE NUMBER\n.P3      AIF   ('&PAGEWID'(1,1) EQ '(').PR3\n         DC    AL1(&PAGEWID)           PAGE WIDTH\n         AGO   .P4\n.PR3     DC    AL1(0)                  PAGE WIDTH\n.P4      AIF   ('&PAGELEN'(1,1) EQ '(').PR4\n         DC    AL1(&PAGELEN)           PAGE LENGTH\n         AGO   .P5\n.PR4     DC    AL1(0)                  PAGE LENGTH\n.P5      AIF   ('&TIME'(1,1) EQ '(').PR5\n         DC    A(&TIME)                ADDRESS OF TIME\n         AGO   .P6\n.PR5     DC    A(0)                    ADDRESS OF TIME\n.P6      AIF   ('&DATE'(1,1) EQ '(').PR6\n         DC    A(&DATE)                ADDRESS OF DATE\n         AGO   .P7\n.PR6     DC    A(0)                    ADDRESS OF DATE\n.P7      AIF   ('&IHBPARM' NE '56').VCON\n         AIF   ('&DDNAME'(1,1) EQ '(').PR7\n         DC    CL8'&DDNAME'            DDNAME FOR DATA SET\n         AGO   .VCON\n.PR7     DC    CL8' '                  DDNAME FOR DATA SET\n.VCON    ANOP\n&TAG.L   XPRINNRA  &WA,&IHBPARM\n         MEND\n         MACRO\n&SYMBOL  XPRSPACE  &WA,&LINES=1,&COND=\n.* MACRO TO EXECUTE A SPACE CALL TO 'XPRNTSUB'.\n         LCLA  &N,&B6,&B7\n         LCLC  &TAG,&SYM\n&SYM     SETC  '&SYMBOL'\n&TAG     SETC  'IHB&SYSNDX'\n.LOOP    ANOP\n&N       SETA  &N+1\n         AIF   (&N GT N'&COND).LDONE\n.TST1    AIF   ('&COND(&N)' NE 'NOEJ').TST2\n&B6      SETA  1\n         AGO   .LOOP\n.TST2    AIF   ('&COND(&N)' NE 'ATHOF').TST3\n&B7      SETA  1\n         AGO   .LOOP\n.TST3    MNOTE 4,'OPERAND &COND(&N) AFTER KEYWORD COND IS ILLEGAL'\n         AGO   .LOOP\n.LDONE   CNOP  2,4\n         AIF   ('&LINES'(1,1) NE '(').NOTREG1\n&SYM     STC   &LINES(1),&TAG.A+1      STORE INTO PARM LIST\n&SYM     SETC  ''\n.NOTREG1 ANOP\n&SYM     BAL   1,&TAG.L                LOAD PARM LIST ADDRESS\n&TAG.A   DC    B'000000&B6&B7'         OPTION BITS\n         AIF   ('&LINES'(1,1) NE '(').NOTREG2\n         DC    X'00'                   SPACING AMOUNT\n         AGO   .VCON\n.NOTREG2 DC    AL1(&LINES)             SPACING AMOUNT\n.VCON    ANOP\n&TAG.L   XPRINNRA  &WA,44\n         MEND\n         MACRO\n&SYMBOL  XPRCLOSE  &WA\n.* MACRO TO EXECUTE A CLOSE CALL TO 'XPRNTSUB'.\n         CNOP  0,4\n&SYMBOL  B     *+8                     BRANCH AROUND ADDRESS\n         XPRINNRA  &WA,68\n         MEND\n         MACRO\n&SYMBOL  XPRDCB  &DDNAME=SYSPRINT,&BLKSIZE=0\n         LCLC  &TAG\n.* MACRO TO GENERATE A WORK AREA FOR A PRINTER DATA SET, CONTAINING\n.* A SAVE AREA, THE DCB, OPEN AND CLOSE PARAMETER LISTS, AND VARIOUS\n.* CELLS AND SWITCHES.\n&TAG     SETC  '&SYMBOL'\n         AIF   (T'&SYMBOL NE 'O').TOK  TEST IF NAME SUPPLIED\n&TAG     SETC  'XPRDCB01'              SUPPLY STANDARD PRDCB NAME\n.TOK     ANOP\n&TAG     DS    0D                      ALIGN ON DOUBLE-WORD BOUNDARY\n         DS    18F                     STANDARD SAVE AREA\n         SPACE\n*        DCB   DDNAME=&DDNAME,DSORG=PS,RECFM=VBM,LRECL=137,           X\n*              BLKSIZE=&BLKSIZE,MACRF=PL,BFTEK=S,BUFNO=2\nIHB&SYSNDX DCB DDNAME=&DDNAME,DSORG=PS,RECFM=VBM,LRECL=137,            X\n               BLKSIZE=&BLKSIZE,MACRF=PL,BFTEK=S,BUFNO=2\n         SPACE\n* PARAMETER LISTS FOR OPEN AND CLOSE:\n         SPACE\n         OPEN  (IHB&SYSNDX,(OUTPUT,LEAVE)),MF=L  PARM LIST FOR OPEN\n         SPACE\n         CLOSE (IHB&SYSNDX,LEAVE),MF=L PARM LIST FOR CLOSE\n         SPACE\n* WORK CELLS AND VARIABLE STORAGE:\n         SPACE\n         DS    1D                      WORK CELL\n         DS    3F                      WORK CELLS\n         DS    1A                      PAGE HEADING PARM LIST ADDRESS\n         DS    1F                      MAXIMUM NUMBER OF OUTPUT LINES\n         DS    1H                      PAGE WIDTH\n         DS    1H                      PAGE LENGTH\n         DS    1H                      PAGE NUMBER\n         DS    1H                      PAGE BALANCE\n         DS    1X                      SWITCHES\n         DS    CL24                    DATE & TIME FOR PAGE HEADING\n         SPACE 2\n         MEND\n         MACRO\n&SYMBOL  XPREJECT  &WA,&COND=\n.* MACRO TO EXECUTE AN EJECT CALL TO 'XPRNTSUB'.\n         LCLC  &TAG,&SYM,&OPT,&R\n         LCLA  &K\n&SYM     SETC  '&SYMBOL'\n&TAG     SETC  'IHB&SYSNDX'\n         CNOP  2,4\n.TST1    AIF   ('&COND' NE '').TST2\n&OPT     SETC  'F000'\n         AGO   .SIMPLE\n.TST2    AIF   ('&COND' NE 'ATHOF').TSTC\n&OPT     SETC  'F100'\n.SIMPLE  ANOP\n&SYM     BAL   1,&TAG.L                LOAD PARM ADDRESS\n         DC    XL2'&OPT'               OPTION BITS\n         AGO   .VCON\n.TSTC    AIF   ('&COND(1)' NE 'EQ').NE\n&OPT     SETC  '80'\n.NE      AIF   ('&COND(1)' NE 'NE').LT\n&OPT     SETC  '70'\n.LT      AIF   ('&COND(1)' NE 'LT').GT\n&OPT     SETC  '40'\n.GT      AIF   ('&COND(1)' NE 'GT').LE\n&OPT     SETC  '20'\n.LE      AIF   ('&COND(1)' NE 'LE').GE\n&OPT     SETC  'C0'\n.GE      AIF   ('&COND(1)' NE 'GE').NOT\n&OPT     SETC  'A0'\n.NOT     AIF   ('&OPT' NE '').COK\n         MNOTE 4,'COND OPERAND &COND(1) ILLEGAL'\n.COK     AIF   ('&COND(2)' NE '').C2OK\n         MNOTE 4,'COND TEST QUANTITY MISSING'\n         AGO   .NOTREG\n.C2OK    AIF   ('&COND(2)'(1,1) NE '(').NOTREG\n&K       SETA  K'&COND(2)-2\n&R       SETC  '&COND(2)'(2,&K)\n&SYM     STC   &R,&TAG.A               STORE INTO PARM LIST\n&SYM     SETC  ''\n.NOTREG  ANOP\n&SYM     BAL   1,&TAG.L                LOAD PARM ADDRESS\n         DC    XL1'&OPT'               CONDITION MASK\n         AIF   ('&COND(2)' EQ '').NOTREG2\n         AIF   ('&COND(2)'(1,1) NE '(').NOTREG2\n&TAG.A   DC    AL1(0)                  TEST QUANTITY\n         AGO   .VCON\n.NOTREG2 DC    AL1(&COND(2))           TEST QUANTITY\n.VCON    ANOP\n&TAG.L   XPRINNRA  &WA,92\n         MEND\n         MACRO\n&SYMBOL  XPRHEAD  &WA,&LIST=\n.* MACRO TO PRESENT A LIST OF PRINT LINE DESCRIPTORS FOR PAGE HEADINGS\n.* TO 'XPRNTSUB'.\n&SYMBOL  XPRLIST  &WA,LIST=&LIST,IHBPARM=80\n         MEND\n         MACRO\n&TAG     XPRINNRA  &WA,&IHBPARM\n.* INNER MACRO USED IN CALLS TO 'XPRNTSUB'\n         DC    V(XPRNTSUB)             PRINTING SUBROUTINE ADDRESS\n&TAG     L     15,*-4                  LOAD ENTRY POINT\n         AIF   ('&WA' NE '').WOK\n         LA    0,XPRDCB01              LOAD STANDARD WORK AREA ADDRESS\n         AGO   .BAL\n.WOK     AIF   ('&WA' EQ '(0)').BAL\n         AIF   ('&WA'(1,1) EQ '(').REG\n         LA    0,&WA                   LOAD WORK AREA ADDRESS\n         AGO   .BAL\n.REG     LR    0,&WA(1)                LOAD WORK AREA ADDRESS\n.BAL     BAL   14,&IHBPARM.(15)        CALL PRINT SUBROUTINE\n         MEND\n         MACRO\n&SYMBOL  XPRLDEF  &TEXT=,&LENGTH=132,&OFFSET=0,&SPA=1,&SPB=0\n.* MACRO TO DEFINE PRINT LINE DESCRIPTOR BLOCKS (\"PLD\" BLOCKS) FOR\n.* THE PRINTING SUBROUTINE \"XPRNTSUB\".\n         LCLA  &N\n         LCLC  &B3,&B6,&B7\n         ACTR  25                      JUST IN CASE\n&B3      SETC  '0'\n&B6      SETC  '0'\n&B7      SETC  '0'\n.* PROCESS OPTIONS IN SPA OPERAND:\n.TSTA1   AIF   ('&SPA(2)' EQ '').TSTB1\n         AIF   ('&SPA(2)' NE 'NOEJ').TSTA2\n&B3      SETC  '1'\n         AGO   .TSTB1\n.TSTA2   MNOTE 4,'OPERAND &SPA(2) AFTER KEYWORD SPA IS ILLEGAL'\n.* PROCESS OPTIONS IN SPB OPERAND:\n.TSTB1   ANOP\n&N       SETA  2\n.TSTB5   AIF   ('&SPB(&N)' NE 'NOEJ').TSTB2\n&B7      SETC  '1'\n         AGO   .TSTB4\n.TSTB2   AIF   ('&SPB(&N)' NE 'ATHOF').TSTB3\n&B6      SETC  '1'\n         AGO   .TSTB4\n.TSTB3   AIF   ('&SPB(&N)' EQ '').TSTB4\n         MNOTE 4,'OPERAND &SPB(&N) AFTER KEYWORD SPB IS ILLEGAL'\n.TSTB4   ANOP\n&N       SETA  &N+1\n         AIF   (&N LE 3).TSTB5\n.IFTEXT  AIF   ('&TEXT' NE '').TOK\n         MNOTE 4,'TEXT ADDRESS MISSING'\n.TOK     ANOP\n&SYMBOL  DS    0F                      ALIGN ON FULL-WORD BOUNDARY\n         DC    BL1'000&B3.00&B6&B7'    OPTION BITS\n         DC    AL3(&TEXT)              TEXT ADDRESS\n         DC    AL1(&LENGTH)            TEXT LENGTH\n         DC    AL1(&OFFSET)            MARGIN OFFSET\n.TESTB   AIF   ('&SPB(1)' EQ 'EJECT').BSKIP\n         AIF   ('&SPB(1)' EQ 'SKIP').BSKIP\n         DC    AL1(&SPB(1))            PRE-SPACING\n         AGO   .TESTA\n.BSKIP   ANOP\n         DC    AL1(255)                EJECT BEFORE PRINTING\n.TESTA   AIF   ('&SPA(1)' EQ 'EJECT').ASKIP\n         AIF   ('&SPA(1)' EQ 'SKIP').ASKIP\n         DC    AL1(&SPA(1))            POST-SPACING\n         MEXIT\n.ASKIP   ANOP\n         DC    AL1(255)                EJECT AFTER PRINTING\n         MEND\n         MACRO\n&SYMBOL  XPRLIST  &WA,&LIST=,&IHBPARM=32\n.* MACRO TO DELIVER A LIST OF PRINT LINE DESCRIPTORS TO 'XPRNTSUB'.\n         LCLA  &N,&K,&D\n         LCLC  &TAG,&SYM,&R\n         ACTR  100\n&SYM     SETC  '&SYMBOL'\n&TAG     SETC  'IHB&SYSNDX'\n         AIF   ('&LIST' NE '').LOK\n         MNOTE 8,'LIST OPERAND MUST BE SUPPLIED'\n         MEXIT\n.LOK     CNOP  0,4\n         AIF   ('&LIST' NE '(1)').STLOOP\n&SYMBOL  B     &TAG.L                  BRANCH AROUND ADDRESS\n         AGO   .VCON\n.STLOOP  ANOP\n&N       SETA  &N+1\n         AIF   (&N GT N'&LIST).STDONE\n         AIF   ('&LIST(&N)'(1,1) NE '(').STLOOP\n&K       SETA  K'&LIST(&N)-2\n&R       SETC  '&LIST(&N)'(2,&K)\n&D       SETA  4*(&N-1)\n&SYM     ST    &R,&TAG.A+&D            STORE INTO PARM LIST\n&SYM     SETC  ''\n         AIF   (&N NE N'&LIST).STLOOP\n         OI    &TAG.A+&D,X'80'         SET END-OF-LIST BIT\n.STDONE  ANOP\n&SYM     BAL   1,&TAG.L                LOAD PARM LIST ADDRESS\n&SYM     SETC  '&TAG.A'\n&N       SETA  0\n.LOOP    ANOP\n&N       SETA  &N+1\n         AIF   (&N GT N'&LIST).VCON\n         AIF   ('&LIST(&N)'(1,1) NE '(').NOTREG\n&SYM     DC    A(0)\n&SYM     SETC  ''\n         AGO   .LOOP\n.NOTREG  AIF   (&N EQ N'&LIST).LAST\n&SYM     DC    A(&LIST(&N))\n&SYM     SETC  ''\n         AGO   .LOOP\n.LAST    ANOP\n&SYM     DC    X'80'                   END-OF-LIST BIT\n         DC    AL3(&LIST(&N))\n.VCON    ANOP\n&TAG.L   XPRINNRA  &WA,&IHBPARM\n         MEND\n         MACRO\n&SYMBOL  XPRMOD  &WA,&MAXLINE=0,&PAGENO=0,&PAGEWID=0,&PAGELEN=0,       X\n               &TIME=0,&DATE=0\n.* MACRO TO EXECUTE A MODIFY CALL TO 'XPRINTSUB'.\n&SYMBOL  XPROPEN  &WA,MAXLINE=&MAXLINE,PAGENO=&PAGENO,PAGEWID=&PAGEWID,X\n               PAGELEN=&PAGELEN,TIME=&TIME,DATE=&DATE,IHBPARM=104\n         MEND\n         MACRO\n&SYMBOL  XPRNTLIN  &WA,&TEXT=00,&LENGTH=132,&OFFSET=0,&SPB=0,&SPA=1\n         LCLA  &N\n         LCLC  &B3,&B6,&B7,&T,&R\n         ACTR  25\n&T       SETC  'IHB&SYSNDX'\n&B3      SETC  '0'\n&B6      SETC  '0'\n&B7      SETC  '0'\n.* PROCESS OPTIONS IN SPA OPERAND:\n.TSTA1   AIF   ('&SPA(2)' EQ '').TSTB1\n         AIF   ('&SPA(2)' NE 'NOEJ').TSTA2\n&B3      SETC  '1'\n         AGO   .TSTB1\n.TSTA2   MNOTE 4,'OPERAND &SPA(2) AFTER KEYWORD SPA IS ILLEGAL'\n.* PROCESS OPTIONS IN SPB OPERAND:\n.TSTB1   ANOP\n&N       SETA  2\n.TSTB5   AIF   ('&SPB(&N)' NE 'NOEJ').TSTB2\n&B7      SETC  '1'\n         AGO   .TSTB4\n.TSTB2   AIF   ('&SPB(&N)' NE 'ATHOF').TSTB3\n&B6      SETC  '1'\n         AGO   .TSTB4\n.TSTB3   AIF   ('&SPB(&N)' EQ '').TSTB4\n         MNOTE 4,'OPERAND &SPB(&N) AFTER KEYWORD SPB IS ILLEGAL'\n.TSTB4   ANOP\n&N       SETA  &N+1\n         AIF   (&N LE 3).TSTB5\n.* GENERATE STORE INSTRUCTIONS IF REGISTER NOTATION IS USED:\n         CNOP  0,4\n         AIF   ('&SYMBOL' EQ '').IFR1\n&SYMBOL  DS    0H\n.IFR1    AIF   ('&TEXT' NE '00').TXTOK\n         MNOTE 4,'TEXT ADDRESS MUST BE SUPPLIED'\n.TXTOK   AIF   ('&TEXT'(1,1) NE '(').IFR2\n         ST    &TEXT(1),&T.A           STORE TEXT ADDRESS\n         MVI   &T.A,B'000&B3.00&B6&B7' INSERT OPTION BITS\n.IFR2    AIF   ('&LENGTH'(1,1) NE '(').IFR3\n         STC   &LENGTH(1),&T.A+4       STORE TEXT LENGTH\n.IFR3    AIF   ('&OFFSET'(1,1) NE '(').IFR4\n         STC   &OFFSET(1),&T.A+5       STORE MARGIN OFFSET\n.IFR4    AIF   ('&SPB(1)'(1,1) NE '(').IFR5\n&N       SETA  K'&SPB(1)-2\n&R       SETC  '&SPB(1)'(2,&N)\n         STC   &R,&T.A+6               STORE PRE-SPACING\n.IFR5    AIF   ('&SPA(1)'(1,1) NE '(').LOAD1\n&N       SETA  K'&SPA(1)-2\n&R       SETC  '&SPA(1)'(2,&N)\n         STC   &R,&T.A+7               STORE POST-SPACING\n.* LOAD REG 1 AND GENERATE PLD LIST ADDRESS:\n.LOAD1   BAL   1,&T.L                  LOAD PARM ADDRESS\n         DC    X'80'                   MARK END OF ADDRESS LIST\n         DC    AL3(&T.A)               ADDRESS OF PLD\n.* GENREATE PLD PARAMETERS TO DESCRIBE THE PRINT LINE:\n.IFR11   AIF   ('&TEXT'(1,1) NE '(').NOTR11\n&T.A     DC    A(0)                    TEXT ADDRESS & OPTION BITS\n         AGO   .IFR12\n.NOTR11  ANOP\n&T.A     DC    B'000&B3.00&B6&B7'      OPTION BITS\n         DC    AL3(&TEXT)              TEXT ADDRESS\n.IFR12   AIF   ('&LENGTH'(1,1) NE '(').NOTR12\n         DC    AL1(0)                  TEXT LENGTH\n         AGO   .IFR13\n.NOTR12  DC    AL1(&LENGTH)            TEXT LENGTH\n.IFR13   AIF   ('&OFFSET'(1,1) NE '(').NOTR13\n         DC    AL1(0)                  MARGIN OFFSET\n         AGO   .IFR14\n.NOTR13  DC    AL1(&OFFSET)            MARGIN OFFSET\n.IFR14   AIF   ('&SPB(1)'(1,1) NE '(').NOTR14\n         DC    AL1(0)                  PRE-SPACING\n         AGO   .IFR15\n.NOTR14  AIF   ('&SPB(1)' EQ 'EJECT').BSKIP\n         AIF   ('&SPB(1)' EQ 'SKIP').BSKIP\n         DC    AL1(&SPB(1))            PRE-SPACING\n         AGO   .IFR15\n.BSKIP   DC    AL1(255)                SKIP BEFOR PRINTING\n.IFR15   AIF   ('&SPA(1)'(1,1) NE '(').NOTR15\n         DC    AL1(0)                  POST-SPACING\n         AGO   .VCON\n.NOTR15  AIF   ('&SPA(1)' EQ 'EJECT').ASKIP\n         AIF   ('&SPA(1)' EQ 'SKIP').ASKIP\n         DC    AL1(&SPA(1))            POST-SPACING\n         AGO   .VCON\n.ASKIP   DC    AL1(255)                SKIP AFTER PRINTING\n.VCON    ANOP\n&T.L    XPRINNRA  &WA,32\n         MEND\n          PRINT NOGEN\nVLST     TITLE 'DIRECT-ACCESS VOLUME DIRECTORY LISTER'\n* AUTHOR:  R. F. MORSE, MIT INSTRUMENTATION LABORATORY\n* UPDATED:  FEB. 21, 1972 TO REL 20.6 AND 370 BY H. R. HOWIE\n*          OCT 29,1974 J.AIELLO GTE LABS TO INCLUDE 3330 MOD-11\n*          AUG,1977 W. GRIFFIN TO INCLUDE 3350 SUPPORT\n*                                           WTOR FOR CORE PROB\n*                               DECIMAL CONVERSON FOR TRACK MAP\n*          MAR,1981 J. SCHLAM  +INDEXED VTOC MODS\n*                           -->+UPDATE FOR 3380 DEVICES - NEED DETAILS\n*                              +CORRECTION OF LAST REFERENCED DATE\n*          JUL,1984 S. LEPORE - ADD SUPPORT FOR DF/EF VSAM WITH  WFB SL\n*                                 MORE THAN 16 EXTENTS           WFB SL\n*                             - CORRECT EDIT OF LAST USE COUNT   WFB SL\n*          JUL,1986 S. NGWAI  - ADD SUPPORT FOR 3380-E           WFB SN\n*\n         SPACE\n* FUNCTION/OPERATION:  READS AND EDITS THE VOLUME TABLE OF CONTENTS\n*        (VTOC) FROM ONE OR MORE DIRECT ACCESS VOLUMES AND PRINTS\n*        INFORMATION ABOUT THE DATA SETS ON IT AND A TRACK USAGE MAP.\n*        OPTIONALLY, IT LISTS THE DIRECTORY OF EACH PARTITIONED DATA\n*        SET ON THE VOLUME.\n         SPACE\n* ENTRY POINTS:  ENTER AT 'GENESIS' WITH A BALR 14,15 AND REGISTER 13\n*        SET TO A STANDARD SAVE AREA.  REGISTER 1 POINTS TO A FULL WORD\n*        WHICH POINTS TO A PARAMETER FIELD.\n         SPACE\n* INPUT:  THE PARAMETER FIELD REFERENCED BY R1 BEGINS WITH A HALF-WORD\n*        CONTAINING THE BINARY LENGTH OF THE BYTE STRING WHICH FOLLOWS\n*        IT.  THE STRING CONSISTS OF A SERIES OF PARAMETER WORDS\n*        SEPARATED BY COMMAS.  LEGAL WORDS ARE:\n*              DUMP    CAUSES THE DSCB'S TO BE LISTED IN HEX FOLLOWING\n*                      THEIR FORMATTED LISTINGS.\n*              PDS     CAUSES THE DIRECTORY OF EACH PDS TO BE LISTED.\n*              MAP     CAUSES THE TRACK USAGE MAP TO BE PRINTED.\n*         <DDNAME>     CAUSES ONE SPECIFIC DDNAME TO BE PROCESSED.\n         SPACE\n* OUTPUT:  A PRINTED LISTING DESCRIBING THE DATA SETS AND TRACK USAGE\n*        FOR EACH VOLUME.\n         SPACE\n* DATA SETS:  PRINTED OUTPUT IS DELIVERED TO A DATA SET DESCRIBED ON A\n*        DD CARD WITH DDNAME 'SYSPRINT'.  EACH VOLUME TO BE LISTED MUST\n*        HAVE A DD CARD SPECIFYING VOL=SER AND UNIT.  THE DDNAMES CAN\n*        BE ANY EXCEPT JOBLIB, STEPLIB, SYSPRINT, SYSABEND, SYSUDUMP,\n*        SYSIN, OR VTOCLIST UNLESS A SPECIFIC DDNAME WAS SPECIFIED IN\n*        THE PARM FIELD.  IF A DSNAME IS SPECIFIED ON A DD CARD, AND IF\n*        THAT DATA SET IS A PDS, THEN ONLY THAT DATA SET WILL BE\n*        PROCESSED AND ALL ITS DIRECTORY ENTRIES WILL BE LISTED.\n         SPACE\n* EXTERNAL ROUTINES:  CALLS 'XDATEDIT' TO FORMAT DATES.\n*        CALLS 'XVTCREAD' TO READ VTOC FROM DIRECT-ACCESS DEVICES.\n*        CALLS 'XPRNTSUB' TO DO PRINTING AND PAGINATION.\n         SPACE\n* EXITS-NORMAL:  RETURNS VIA REG 14 WITH RETURN CODE 0.\n         SPACE\n* EXITS-ERROR:  RETURNS VIA REG 14 WITH RETURN CODES AS FOLLOWS:\n*        4 - MISSING DD CARD;\n*        8 - BAD FORMAT IN A DSCB;\n*        12 - PERMANENT I/O ERROR IN A VTOC OR PDS DIRECTORY;\n*        16 - ERROR RETURN FROM AN INDEXED VTOC MACRO;          JBSIX\n*        20 - UNABLE TO OPEN 'SYSPRINT' DATA SET.\n         SPACE\n* TABLES/WORK AREAS:  USES SYSTEM MACROS 'IEFJFCBN' AND 'IECSDSL1' TO\n*        DEFINE A JOB FILE CONTROL BLOCK AND VARIOUS DATA SET CONTROL\n*        BLOCK FORMATS.  USES MACRO 'IEFTIOT1' TO DEFINE TASK IO TABLE.\n         SPACE\n* ATTRIBUTES:  SERIALLY REUSABLE.\n         EJECT\n* MACHINE REQUIREMENTS:  USES A PRINTER WITH 132-CHARACTER PRINT LINE\n*        AND A 60-CHARACTER PRINT TRAIN (PN OR QN ARRANGEMENT).  USES\n*        ONLY THE STANDARD INSTRUCTION SET, EXCEPT FOR A FEW 'EDIT'\n*        INSTRUCTIONS.  CORE REQUIREMENT VARIES WITH THE SIZE OF THE\n*        VTOC BEING LISTED.  A 160-BLOCK VTOC REQUIRES ABOUT 30K.\n         SPACE\n* NOTES:  THE INPUT PARAMETER LIST STRUCTURE IS THAT USED TO PASS\n*        INFORMATION FROM THE 'PARM' FIELD OF AN 'EXEC' CARD.\n         SPACE\n*        HAS BEEN TESTED WITH 2301, 2311, 2314, AND 2321.  NO TROUBLE\n*        ANTICIPATED WITH 2303.  DON'T KNOW ABOUT 2302.\n         SPACE\n*        CURRENTLY IGNORES FORMAT 2 DSCB'S FOR ISAM AND\n*        FORMAT 6 DSCB'S FOR SPLIT-CYLINDER ALLOCATION.\n         SPACE   2\nVTOCLIST START\n         SPACE 2\n* REGISTER ASSIGNMENTS:\n         SPACE\nR0       EQU   0\nR1       EQU   1\nRPARM    EQU   1\nR2       EQU   2\nRWK1     EQU   2\nR3       EQU   3\nRWK2     EQU   3\nRWK3     EQU   4\nRWK4     EQU   5\nRBASE3   EQU   7                                 GTEL\nRPDS     EQU   8\nRDS1     EQU   9\nRDS4     EQU   9\nRMB      EQU   9\nRDS3     EQU   10\nRDS5     EQU   10\nRDCB     EQU   10\nRBASE1   EQU   11\nRBASE2   EQU   12\nRSAVE    EQU   13\nRRET     EQU   14\nR15      EQU   15\nRGO      EQU   15\n         EJECT\n* PARAMETERS AND ASSIGNS:\n         SPACE\nGETSIZE  EQU   2048            BLOCK SIZE FOR GETMAIN REQUESTS\nPGLENGTH EQU   57              LINES PER PAGE\nTOPMARGN EQU   3               LINES TO SKIP BEFORE PAGE HEADING\nALIASMSK EQU   X'80'           PDS DIRECTORY ENTRY IS AN ALIAS\n         SPACE\nDADEVICE EQU   X'20'           CLASS FOR DIRECT ACCESS DEVICES\nDEV2301  EQU   X'02'           UNIT TYPE FOR 2301 DRUM\nDEV2302  EQU   X'04'           UNIT TYPE FOR 2302 DISK FILE\nDEV2303  EQU   X'03'           UNIT TYPE FOR 2303 DRUM\nDEV23051 EQU   X'06'           UNIT TYPE FOR 2305-1 DRUM\nDEV23052 EQU   X'07'           UNIT TYPE FOR 2305-2 DRUM\nDEV2311  EQU   X'01'           UNIT TYPE FOR 2311 DISK PACK\nDEV2314  EQU   X'08'           UNIT TYPE FOR 2314 DISK PACK\nDEV2321  EQU   X'05'           UNIT TYPE FOR 2321 DATA CELL\nDEV3330  EQU   X'09'           UNIT TYPE FOR 3330 DISK PACK\nDEV33301 EQU   X'0D'           UNIT TYPE FOR 3330 MOD-11        GTEL\nDEV3340  EQU   X'FF'           UNIT TYPE FOR 3340               JBS??\nDEV3350  EQU   X'0B'           UNIT TYPE FOR 3350               GTEL\nDEV3375  EQU   X'0C'           UNIT TYPE FOR 3375               GTEL\nDEV3380  EQU   X'0E'           UNIT TYPE FOR 3380 + 3380-E      WFB SN\n* ?? ENTER CORRECT VALUE FOR 3340 DRIVES WHEN AVAILABLE         JBS\n         SPACE\nDUMPMASK EQU   X'01'           OPTION TO DUMP DSCB'S IN HEX\nPDSLMASK EQU   X'02'           OPTION TO LIST PDS DIRECTORIES\nPDSSMASK EQU   X'04'           OPTION TO LIST A SPECIFIC PDS\nMAPMASK  EQU   X'08'           OPTION TO LIST TRACK USAGE\n         SPACE\nISDSORG  EQU   X'80'           INDEXED SEQUENTIAL ORGANIZATION\nPSDSORG  EQU   X'40'           PHYSICAL SEQUENTIAL ORGANIZATION\nDADSORG  EQU   X'20'           DIRECT-ACCESS ORGANIZATION\nPODSORG  EQU   X'02'           PARTITIONED ORGANIZATION\n         SPACE\nPRSP0    EQU   X'00'           PSEUDO CONTROL CHARACTERS FOR PRINTER\nPRSP1    EQU   X'01'\nPRSP2    EQU   X'02'\nPRSP3    EQU   X'03'\n         SPACE\nOPENBIT  EQU   X'10'           DCB IS OPEN (IN 'DCBOFLGS')\n         SPACE\n* TYPE   B/TRK T/C  CYL B/TRK* T/C*  CYL*\n* 2301   20483   8   25  20483  200     1\n* 2302    4984  46  246   4984   46   250\n* 2303    4892  10   80   4892   10    80\n* 2305-1 14136   8   48  14120    8    48\n* 2305-2 14660   8   96  14660    8    96\n* 2311    3625  10  200   3625   10   203\n* 2314    7294  20  200   7294   20   203\n* 2321    2000  20  980   2000 1300  5130\n* 3330   13030  19  404  13030   19   411\n* 3350   19069  30  555  19254   30   560   47 DSCB/T  36 PDS/T  WFB SL\n* 3380   47476  15  885  47968   15   886   53 DSCB/T  46 PDS/T  WFB SL\n* 3380-E 47476  15 1770  47968   15  1771   53 DSCB/T  46 PDS/T  WFB SN\n* 3380 + 3380-E ARE THE SAME TABLE ENTRY, ABOVE FOR DOCUMENTATION ONLY.\n* COLUMNS WITH '*' ARE FROM DEVTYPE MACRO\n* OTHERS ARE FROM SUP & DM SERVICES OR COMPONENT DESCRIPTION\n         EJECT\n*************************\n* ENTRANCE AND PROLOGUE *\n*************************\n         SPACE\n* ENTER HERE TO PERFORM STANDARD SAVE OPERATIONS AND ESTABLISH TWO BASE\n* REGISTERS WITH A CONTINUOUS RANGE OF 8K BYTES.\n         SPACE\n         STM   14,12,12(13)\n         SPACE\n         LR    RBASE1,R15              SET UP BASE REGISTER\n         USING VTOCLIST,RBASE1,RBASE2,RBASE3                   GTEL\n         LA    RBASE2,4095(RBASE1)     LOAD SECOND BASE 4096 BYTES\n         LA    RBASE2,1(RBASE2)          HIGHER\n         LA    RBASE3,4095(RBASE2)                             GTEL\n         LA    RBASE3,1(RBASE3)                                GTEL\n         B     GO\n         DC    C'VTOCLIST 11 JUL 86'\n         SPACE\nGO       LR    RWK1,RSAVE\n         LA    RSAVE,SAVEAREA          LOCAL SAVE AREA, 18 WORDS\n         ST    RWK1,SAVEAREA+4         FORWARD CHAIN\n         ST    RSAVE,8(RWK1)           BACKWARD CHAIN\n         SPACE\n         SR    R1,R1                   GENERATE ZERO PROGRAM MASK\n         SPM   R1                      MASK OVERFLOW INTERRUPTS\n         SPACE 3\n* CALL PRINTING SUBROUTINE TO OPEN THE SYSPRINT DATA SET.  SET INITIAL\n* PAGE DIMENSIONS AND HEADING, AND SKIP TO HEAD OF FORM.\n         SPACE\n         XPROPEN  PWA,PAGELEN=PGLENGTH,DDNAME=SYSPRINT\n         LTR   R15,R15                 TEST FOR SUCCESSFUL OPEN\n         BNZ   PROPBAD                 ERROR IF UNABLE TO PRINT\n         SPACE\n         XPRHEAD  PWA,LIST=INITHEAD\n         SPACE\n         XPRNTLIN  PWA,TEXT=REVMSG,LENGTH=61,SPB=SKIP,         GTEL   XX\n               SPA=3,OFFSET=9\n         SPACE 3\n* INITIALIZE OTHER MISCELLANEOUS THINGS.\n         SPACE\n         SR    R0,R0                   GENERATE USEFUL ZERO\n         ST    R0,RETCODE              ZERO RETURN CODE REGISTER\n         STC   R0,MODESW               LISTING OPTION SWITCH\n         SPACE\n* LOCATE THE TIOT AND SAVE THE JOB NAME.\n         SPACE\n         EXTRACT  TIOTLOC,FIELDS=TIOT  OBTAIN TIOT ADDRESS FROM TCB\n         SPACE\n         L     R1,TIOTLOC\n         USING TIOT1,R1\n         MVC   JOBNAME(8),TIOCNJOB     SAVE JOB ANME\n         LA    R1,TIOENTRY             LOAD ADDR OF FIRST TABLE ENTRY\n         DROP  R1\n         ST    R1,TIOTLOC              SAVE TIOT ENTRY ADDRESS\n         EJECT\n******************************\n* INPUT PARAMETER PROCESSING *\n******************************\n         SPACE\n* RETRIEVE AND PRINT THE PARAMETER FIELD.  SCAN IT FOR WORDS AND SET\n* LISTING MODE SWITCHES AND VOLUME COUNT ACCORDINGLY.\n         SPACE 2\nPARMGET  L     R1,SAVEAREA+4           SAVE AREA WHERE R1 STORED\n         L     R1,24(R1)               R1 WHICH WAS PASSED TO US\n         L     RWK1,0(R1)              ADDRESS OF PARM FIELD\n         LH    RWK2,0(RWK1)            LENGTH OF PARM FIELD\n         LA    RWK1,2(RWK1)            SET RWK1 TO FIRST BYTE\n         SPACE\n* PRINT FIELD, OR COMPLAIN IF IT IS TOO LONG.\n         SPACE\n         MVC   PL+10(21),=C'EXEC PARAMETER FIELD:'\n         CH    RWK2,=H'99'             TEST FIELD LENGTH\n         BL    PLNGOK\n         MVC   PL+30(29),=C'  IS TOO LONG AND WAS IGNORED'\n         SR    RWK2,RWK2               SET LENGTH TO 0\n         B     PARMPR\n         SPACE\nPLNGOK   LTR   R1,RWK2                 FIX UP LENGTH FOR MOVE\n         BZ    PARMPR                  SKIP MOVE IF LENGTH ZERO\n         BCTR  R1,0                    SUBTRACT 1 FOR MVC\n         STC   R1,PARMOVE+1\nPARMOVE  MVC   PL+33(0),0(RWK1)        MOVE PARM FIELD TO PRINT LINE\nPARMPR   MVI   PL,PRSP3                PRINT AND SPACE 3\n         BAL   RRET,PRINTSUB\n         SPACE\n* LOOP TO GET PARAMETER WORDS AND SET SWITCHES.\n         SPACE\n         MVI   PARMSW,0\nPARMLOOP BAL   RRET,SCAN               GET A WORD\n         CLI   SCANWORD,C' '           BLANK WORD MEANS END OF STRING\n         BE    PARMDONE\n         SPACE\nPVOLS    CLC   SCANWORD(4),=C'VOLS'    FOR COMPATIBILITY WITH OLDER\n         BE    PARMLOOP                   VERSIONS\n         SPACE\nPDUMP    CLC   SCANWORD(5),=C'DUMP '\n         BNE   PPDS\n         OI    MODESW,DUMPMASK\n         B     PARMLOOP\n         SPACE\nPPDS     CLC   SCANWORD(4),=C'PDS '\n         BNE   PMAP\n         OI    MODESW,PDSLMASK\n         B     PARMLOOP\n         SPACE\nPMAP     CLC   SCANWORD(4),=C'MAP '\n         BNE   PARMVOL            MUST BE A SPECIFIC DDNAME REQUEST\n         OI    MODESW,MAPMASK\n         B     PARMLOOP\nPARMVOL  CLI   PARMSW,1           SPECIFIC VOLUME INDICATED ?\n         BE    BADPARM            CAN ONLY SPECIFY ONE\n         MVC   PL+10(26),=CL26'\"        \" DDNAME ASSUMED'\n         MVC   PL+11(8),SCANWORD\n         MVI   PL,PRSP3\n         BAL   RRET,PRINTSUB\n         L     RWK4,TIOTLOC       A(FIRST ENTRY IN TIOT)\n         USING TIOENTRY,RWK4\nDDNLOOP1 CLC   TIOEDDNM(8),SCANWORD  DDNAME MATCH PARM ENTRY ?\n         BNE   DDNLOOP2              LOOP TO NEXT TIOT ENTRY\n         MVC   DDNAME(8),TIOEDDNM    SAVE DDNAME\n         MVI   PARMSW,1              INDICATE ONE SPECIFIC VOLUME\n         B     PARMLOOP              AND CONTINUE PARM FIELD SCAN\nDDNLOOP2 SR    R1,R1\n         IC    R1,TIOELNGH        LENGTH OF THIS ENTRY\n         AR    RWK4,R1            A(NEXT ENTRY IN TIOT)\n         CLI   TIOELNGH,0         END OF TIOT ?\n         BE    BADPARM            UNRECOGNIZED DD NAME\n         ST    RWK4,TIOTLOC       SAVE A(ENTRY IN TIOT)\n         B     DDNLOOP1           LOOP TO TEST FOR MATCH\n         DROP  RWK4\n         SPACE\n* PRINT ERROR MESSAGE FOR UNRECOGNIZED PARAMETERS.\n         SPACE\nBADPARM  MVC   PL+10(50),=C'\"        \" IS AN ILLEGAL PARAMETER AND WAS X\n               IGNORED'\n         MVC   PL+11(8),SCANWORD\n         MVI   PL,PRSP3\n         BAL   RRET,PRINTSUB\n         B     PARMLOOP\n         SPACE\n* ALL PARAMETERS HAVE BEEN PROCESSED.  LOAD TIOT POINTER TO PROCESS\n* FIRST VOLUME.\n         SPACE\nPARMDONE DS    0H\n         CLI   PARMSW,1           WAS ONE SPECIFIC VOLUME SPECIFIED  ?\n         BE    VOLJOIN2           GO PROCESS THAT VOLUME IF YES\n         L     RWK1,TIOTLOC       OTHERWISE LOAD TIOT ADDRESS\n         B     VOLJOIN                 AND SEARCH\n         EJECT\n**********************\n* BEGIN A NEW VOLUME *\n**********************\n         SPACE\n* SEARCH TIOT FOR NEXT ELIGIBLE DDNAME.\n         SPACE\nNEWVOL   DS    0H\n         L     RWK1,TIOTLOC            LOAD TIOT ADDRESS\n         USING TIOENTRY,RWK1\n         SR    R1,R1\n         IC    R1,TIOELNGH             GET LENGTH OF CURRENT ENTRY\n         AR    RWK1,R1                 ADVANCE TO NEXT ENTRY\n         ST    RWK1,TIOTLOC            SAVE UPDATED TIOT ADDRESS\nVOLJOIN  CLI   TIOELNGH,X'00'          TEST IF ZERO-LENGTH ENTRY\n         BE    EXODUS                  END OF VOLUMES IF SO\n         CLC   TIOEDDNM(8),=CL8' '\n         BE    NEWVOL\n         CLC   TIOEDDNM(3),=CL3'SYS'        * BYPASS DYN ALLOC\n         BE    NEWVOL\n         CLC   TIOEDDNM(8),=CL8'JOBLIB'\n         BE    NEWVOL\n         CLC   TIOEDDNM(8),=CL8'STEPLIB'\n         BE    NEWVOL\n         CLC   TIOEDDNM(8),=CL8'SYSPRINT'\n         BE    NEWVOL\n         CLC   TIOEDDNM(8),=CL8'SYSABEND'\n         BE    NEWVOL\n         CLC   TIOEDDNM(8),=CL8'SYSUDUMP'\n         BE    NEWVOL\n         CLC   TIOEDDNM(8),=CL8'SYSIN'\n         BE    NEWVOL\n         CLC   TIOEDDNM(8),=CL8'VTOCLIST'\n         BE    NEWVOL\n         MVC   DDNAME(8),TIOEDDNM      SAVE DDNAME\n         DROP  RWK1\n         SPACE\nVOLJOIN2 DS    0H\n* RESET PAGE NUMBER AND SKIP TO A FRESH PAGE.\n         SPACE\n         XPRMOD  PWA,PAGENO=1          RESET PAGE NUMBER TO 1\n         SPACE\n         XPREJECT  PWA                 SKIP TO A FRESH PAGE\n         SPACE\n         XPRHEAD  PWA,LIST=F1HD3       SET PAGE HEADING LINE\n         SPACE\n* RESET VARIOUS POINTERS AND COUNTERS FOR A NEW VOLUME.\n         SPACE\n         LA    R1,LASTFMT1             RESET FORMAT 1 CHAIN POINTER\n         ST    R1,FMT1ADDR\n         SPACE\n         LA    R1,MBBASE               RESET TRACK MAP CHAIN POINTER\n         ST    R1,MBBASE\n         SPACE\n         SR    R0,R0                   GENERATE USEFUL ZERO\n         STH   R0,FREECYLS             ZERO FREE CYLINDER COUNT\n         STH   R0,FREETRKS               AND FREE TRACK COUNT\n         STH   R0,F5EXTNTS               AND FREE EXTENTS COUNT\n         STH   R0,DSCOUNT                AND DATA SET COUNT\n         SPACE\n* INSERT DDNAME IN DCB FOR PDS DIRECTORY READING.\n         SPACE\n         USING IHADCB,RDCB\n         LA    RDCB,PDSDCB             FIX DCB FOR PDS LISTING\n         MVC   DCBDDNAM(8),DDNAME\n         DROP  RDCB\n         SPACE\n* GET DEVICE TYPE AND VERIFY THAT IT IS DIRECT ACCESS.\n         SPACE\n         DEVTYPE  DDNAME,DEVCHAR,DEVTAB,RPS     GET DEVICE CHARACTERIS\n         SPACE\n         LTR   RGO,RGO                 TEST R15 IF DDNAME FOUND\n         BNZ   NODDCARD                ERROR,DDNAME NOT FOUND\n         CLI   DEVCHAR+2,DADEVICE      TEST FOR DIRECT-ACCESS DEVICE\n         BNE   NOTDACC                 ERROR, NOT DIRECT ACCESS DEVICE\n         SPACE\n* LOOK UP DEVICE NUMBER IN TABLE AND SET UP TRACK ADDRESS CONVERSION\n* PARAMETERS.\n         SPACE\n         MVC   DEVNAMOB(1),UNITTYPE    PUT UNIT TYPE AT END OF TABLE\n         LA    RWK1,DEVNAMES           ADDRESS TABLE BEGINNING\nDEVNAMLP CLC   DEVNAMOB(1),0(RWK1)     TEST FOR MATCH ON DEVICE TYPE\n         BE    DEVNAMF                 BRANCH WHEN FOUND\n         LA    RWK1,DEVNAMSZ(RWK1)     STEP THROUGH TABLE\n         B     DEVNAMLP\n         SPACE\nDEVNAMF  CLC   1(7,RWK1),UNKNOWN       TEST IF DEVICE KNOWN TO US\n         BE    UNKNDEV                 BRANCH IF NOT\n         ST    RWK1,DEVNAMAD           SAVE ADDRESS OF TABLE ENTRY\n         MVC   FC1(12),16(RWK1)        MOVE IN CONVERSION FACTORS\n         SPACE\n* READ JFCB AND EXTRACT VOLUME SERIAL NUMBER.\n         SPACE\n         RDJFCB  (PDSDCB)              READ JOB FILE CONTROL BLOCK\n         SPACE\n         L     R1,JFCBADR              SET UP JFCB BASE REG\n         USING JFDUMMY,R1\n         MVC   VOLUME(6),JFCBVOLS      SAVE VOLUME SERIAL NUMBER\n         DROP  R1\n         SPACE\n         MVC   F1HSER1(6),VOLUME       PUT VOLUME SERIAL IN HEADING\n         MVC   F1HSER2(6),VOLUME\n         SPACE\n* CALL VTOC READING ROUTINE TO OPEN VTOC.\n         SPACE\n         LA    R0,1                    CALL MODE 1 FOR OPEN\n         LA    R1,DDNAME               ADDRESS OF DDNAME\n         L     RGO,VTOCREAD            ADDRESS OF SUBROUTINE\n         BALR  RRET,RGO                CALL XVTCREAD\n         B     *+4(R15)                BRANCH ON RETURN CODE\n         B     VOPENED                 0, SUCCESS\n         B     CANTOPEN                4, UNABLE TO OPEN\n         B     NOTDACC                 8, NOT DIRECT ACCESS\nVOPENED  DS    0H\n         SPACE\n* MAKE UP A TRACK MAP ENTRY FOR THE VOLUME LABEL ON TRACK 0.\n         SPACE\n         MVC   FB+4(20),TRK0MAP        INSERT DUMMY ENTRY\n         LA    RWK1,FB\n         BAL   RRET,FILEMAP            GO INSERT IN MAP\n         EJECT\n* READ VTOC INTO CORE\n         SPACE\n* READ THE FIRST DSCB, WHICH SHOULD BE TYPE 4, DESCRIBING THE VOLUME\n* AND VTOC CHARACTERISTICS.\n         SPACE\n         USING DS4,RDS4\nREADFMT4 LA    RWK3,DS4SIZE            SIZE OF CORE BLOCK\n         BAL   RRET,GETBLOCK           GET CORE AREA\n         ST    RWK2,FMT4ADDR           SAVE ADDRESS\n         LR    RDS4,RWK2               SET BASE REG FOR FORMAT 4\n         BAL   RRET,READSEQ            READ FIRST BLOCK\n         BAL   RRET,DISASTER           END OF DATA RETURN\n         CLI   DS4IDFMT,X'F4'          CHECK TYPE\n         BNE   FRSTNOT4                ERROR, FIRST BLOCK NOT TYPE 4\n         SPACE\n* PUT VTOC EXTENT INTO THE TRACK MAP.\n         SPACE\n         MVC   FB+FBCCHH1(8),DS4VTOCE+2\n         LA    RWK1,DS4VTOCE\n         BAL   RRET,F13CNVT    GET EXTENT SIZE IN R0\n         STH   R0,FB+FBNTRKS\n         STH   R0,VTOCSIZE             SAVE N TRACKS IN VTOC\n         MVC   FB+FBTTREL1(4),RELTT1   PUT TTREL IN TRACK MAP ENTRY\n         MVC   FB+FBEXT(1),DS4VTOCE+1  EXTENT NUMBER\n         MVC   FB+FBNAME(4),=A(VTOCNAME)  INSERT ADDR OF NAME FOR VTOC\n         LA    RWK1,FB\n         BAL   RRET,FILEMAP            PUT ENTRY IN TRACK MAP\n         DROP  RDS4\n         SPACE 2\n*                                                               JBSIX\n* CHECK FOR INDEXED VTOC                                        JBSIX\n*                                                               JBSIX\n         L     RWK1,TIOTLOC           GET ADDR OF CURRENT TIOT  JBSIX\n*                                     TABLE ENTRY               JBSIX\n         USING TIOT1,RWK1                                       JBSIX\n         LA    RWK2,16(RWK1)          GET LOCATION OF UCB ADDR  JBSIX\n         L     RWK2,0(0,RWK2)                                   JBSIX\n         LA    RWK2,0(0,RWK2)                                   JBSIX\n         ST    RWK2,INUCB             SAVE UCB ADDR             JBSIX\n         DROP  RWK1                                             JBSIX\n         CVAFTST UCB=(RWK2)           INDEXED VTOC IN USE?      JBSIX\n         B     *+4(R15)                                         JBSIX\n*                                                               JBSIX\n         B     JBS0000                RC=0, DF/DS NOT ON SYSTEM JBSIX\n         B     JBS0000                RC=4, NOT AN INDEXED VTOC JBSIX\n         B     IXVT000                RC=8, INDEXED VTOC        JBSIX\n         B     IXER000                RC=12,ERROR               JBSIX\n         B     IXER000                RC=16,ERROR               JBSIX\n*                                                               JBSIX\nIXER000  B     IXER100                GO HANDLE ERROR           JBSIX\nIXER100  MVC   PL+1(35),=C'*** ERROR RETURN FROM INDEXED VTOC'  JBSIX\n         BAL   RRET,PRINTSUB                                    JBSIX\n         LA    R0,16                  SET RC TO 16              JBSIX\n         B     EXODUS                 EXIT                      JBSIX\n*                                                               JBSIX\n* SAVE AN INDICATOR THAT AN INDEXED VTOC IS IN USE              JBSIX\n*                                                               JBSIX\nIXVT000  ST    R15,IXVTFLAG                                     JBSIX\n         STM   RWK1,RWK4,IXRSAVE2      SAVE REGS                JBSIX\n*                                                               JBSIX\n         L     RWK1,IXDCBADR           GET ADDR OF VTOC'S DCB   JBSIX\n         USING IHADCB,RWK1                                      JBSIX\n         L     RWK3,DCBDEBAD           GET ADDR OF VTOC'S DEB   JBSIX\n         ST    RWK3,IXDEBADR                                    JBSIX\n         DROP  RWK1                                             JBSIX\n*                                                               JBSIX\n         XC    EXT1(2),EXT1            SET TO READ FROM RTA'00' JBSIX\n         MVI   FETWA+3,26              SET TO READ 26 F-E       JBSIX\n*                                      DESCRIPTORS              JBSIX\nIXVT010  CVAFDSM DEB=(RWK3),           READ 26 F-E DESCRIPTORS  JBSIX  +\n               MF=(E,CVPL)                                      JBSIX\n         CH    R15,=H'4'               26 F-E DESCRIPTORS FOUND?JBSIX\n         BL    IXVT020                 YES: PROCESS THEM        JBSIX\n         BH    IXER110                      ERROR READING F-E'S JBSIX\n         CLI   CVSTAT,STAT032          END OF F-E D'S REACHED?  JBSIX\n         BE    IXVT020                 YES: PROCESS F-E D'S     JBSIX\nIXER110  MVC   PL+1(32),=C'*** ERROR READING VTOC SPACE MAP'    JBSIX\n         BAL   RRET,PRINTSUB                                    JBSIX\n         LA    R0,16                   SET RC TO 16             JBSIX\n         B     EXODUS                  EXIT                     JBSIX\nIXVT020  LA    RWK1,FETWA+4            GET ADDR OF FIRST F-E-D  JBSIX\n         LA    RWK2,26                 SET COUNTER              JBSIX\n         BAL   RRET,IXSPANAL           ANALYZE SPACE            JBSIX\n*                                                               JBSIX\n         CLI   CVSTAT,STAT032          LAST F-E-D READ?         JBSIX\n         BE    IXVT999                 YES:FINISHED WITH FMT 5  JBSIX\n         MVC   EXT1(2),EXT26           SET TO READ NEXT 26 F-ES JBSIX\n         B     IXVT010                 GO READ NEXT 26 F-E-DS   JBSIX\n*                                                               JBSIX\nIXVT999  LM    RWK1,RWK4,IXRSAVE2      RESTORE REGISTERS        JBSIX\n         B     F1RDLOOP                ALL DONE                 JBSIX\n*                                                               JBSIX\n****************************************                        JBSIX\n* FORMAT 5 INDEXED VTOC SPACE ANALYSIS *                        JBSIX\n****************************************                        JBSIX\n*                                                               JBSIX\nIXSPANAL ST    RRET,IXSPAXIT           SAVE RETURN ADDRESS      JBSIX\nIXSPLUP1 BAL   RRET,F5EXANAL           ANALYZE INDIVIDUAL EXTENTJBSIX\n*                                                               JBSIX\n* TEST FOR LAST F-E DESCRIPTOR PROCESSED                        JBSIX\n         CLC   0(5,RWK1),=XL5'00'      LAST F-E DESCRIPTOR?     JBSIX\n         BE    IXVT039                 YES:GO CLEANUP           JBSIX\n         LA    RWK1,5(RWK1)            INDEX TO NEXT ONE        JBSIX\n         BCT   RWK2,IXSPLUP1                                    JBSIX\n*                                                               JBSIX\nIXVT039  L     RRET,IXSPAXIT                                    JBSIX\n         BR    RRET                                             JBSIX\n*                                                               JBSIX\n* MISC DATA AREAS FOR USE BY INDEXED VTOC HANDLING CODE         JBSIX\n*                                                               JBSIX\n         PRINT ON                                               JBSIX\nCVPL     CVAFDSM ACCESS=MAPDATA, CVAF PARAMETER LIST            JBSIX  +\n               MAP=VOLUME,                                      JBSIX  +\n               EXTENTS=FETWA+3,                                 JBSIX  +\n               COUNT=NO,                                        JBSIX  +\n               BRANCH=NO,                                       JBSIX  +\n               MF=L                                             JBSIX\nCVPLEND  EQU   *                                                JBSIX\n         PRINT OFF                                              JBSIX\n         ORG   CVPL                    OVERLAY CVPL WITH MAP    JBSIX\nCVPLMAP  ICVAFPL DSECT=NO                                       JBSIX\n         ORG   CVPLEND                                          JBSIX\n         PRINT ON                                               JBSIX\nFETWA    DC    9XL16'0'                F-E TABLE WORK AREA      JBSIX\n         ORG   FETWA+3                                          JBSIX\nEXTCNT   DC    AL1(26)                 SET TO READ 26           JBSIX\n*                                      FREE-EXTENT RECORDS      JBSIX\n*                                      FROM VTOC INDEX          JBSIX\nEXTTAB   DC    26XL5'0'                EXTENT TABLE             JBSIX\n         ORG   EXTTAB                                           JBSIX\nEXT1     DC    XL5'0'                  1ST FREE-EXTENT DESCRIPT JBSIX\n         ORG   EXTTAB+25*5                                      JBSIX\nEXT26    DC    XL5'0'                  26TH F-E DESCRIPTOR      JBSIX\nIXSPAXIT DC    F'0'                                             JBSIX\nIXRSAVE1 DC    2F'0'                   REGISTER SAVE AREA       JBSIX\nIXRSAVE2 DC    4F'0'                   REGISTER SAVE AREA       JBSIX\nIXVTFLAG DC    F'0'                    =0, INDX VTOC NOT USED   JBSIX\n*                                      =8, INDEXED VTOC USED    JBSIX\nIXDCBADR DC    V(VTOCDCB)              ADDR OF VTOC'S DCB       JBSIX\nIXDEBADR DC    A(0)                    ADDR OF VTOC'S DEB       JBSIX\nINUCB    DC    A(0)                    ADDR OF VTOC'S UCB       JBSIX\n*                                                               JBSIX\n* END OF INDEXED MOD                                            JBSIX\n*                                                               JBSIX\n         EJECT                                                  JBSIX\n* READ FORMAT 5 DSCB'S INTO CORE, CHAINING THEM TOGETHER.  THE FIRST\n* ONE FOLLOWS THE FORMAT 4 BLOCK; THE OTHERS ARE EACH ADDRESSED FROM\n* THE PRECEDING ONE.\n         SPACE\n         USING DS5,RDS5\nJBS0000  LA    RWK3,DS5SIZE            SIZE OF BLOCK REQUIRED\n         BAL   RRET,GETBLOCK\n         ST    RWK2,FMT5ADDR           SAVE ADDR OF FIRST FMT 5 BLOCK\n         LR    RDS5,RWK2               SET FORMAT 5 BASE REG\n         BAL   RRET,READSEQ            READ FIRST FMT 5 BLOCK\n         BAL   RRET,DISASTER           END FILE NOT EXPECTED HERE\n         B     DS5JOIN\n         SPACE\nDS5LOOP  LA    RWK3,DS5SIZE\n         BAL   RRET,GETBLOCK\n         ST    RWK2,DS5CHAIN           CHAIN FROM CURRENT TO NEW\n         LA    RWK1,DS5PTRDS           ADDR OF DISK ADDRESS\n         LR    RDS5,RWK2               UPDATE BASE REG TO NEW BLOCK\n         BAL   RRET,READDIR            READ NEW BLOCK\nDS5JOIN  CLI   DS5FMTID,X'F5'          MUST BE FORMAT 5, OR ELSE.....\n         BNE   BADFMT5                 ERROR, NOT FORMAT 5 BLOCK\n         SPACE\n         BAL   RRET,F5SPANAL           GO ANALYZE FREE SPACE EXTENTS\n         SPACE\n         CLC   DS5PTRDS(5),=5X'00'     IS THERE ANOTHER BLOCK TO FOLLOW\n         BNE   DS5LOOP                 BRANCH IF YES\n         SR    R0,R0                   IF NOT, SET CHAIN OF LAST\n         ST    R0,DS5CHAIN               BLOCK TO ZERO\n         DROP  RDS5\n         SPACE 2\n* READ ALL THE FORMAT 1 DSCB'S AND CHAIN THEM IN COLLATING SEQUENCE BY\n* DATA SET NAME.  IF THERE ARE FORMAT 3 DSCB'S, THEY ARE READ AND\n* CHAINED TO THE FORMAT 1 BLOCK.\n         SPACE\n         USING DS1,RDS1\nF1RDLOOP LA    RWK3,DS1SIZE            LOAD SIZE OF BLOCK REQUIRED\n         BAL   RRET,GETBLOCK\n         LR    RDS1,RWK2               LOAD BASE REG\nF1RDNEXT BAL   RRET,READSEQ            READ NEXT SEQUENTIAL BLOCK\n         B     VTRDDONE                EXIT AT END OF FILE\n         CLI   DS1FMTID,X'F1'          TEST FOR FORMAT 1\n         BNE   F1RDNEXT                IGNORE IF NOT FORMAT 1\n         SPACE\n         TM    DS1DSORG,PODSORG   IS THIS A PDS  ?\n         BNO   F1COUNT\n         L     R1,JFCBADR         A(JFCB)\n         USING JFDUMMY,R1\n         CLC   JFCBDSNM(44),DS1DSNAM SAME DSN AS DDCARD  ?\n         BNE   F1COUNT               SKIP IF NOT\n         DROP  R1\n         OI    MODESW,PDSSMASK    ONE SPECIFIC PDSLIST REQUESTED\n         MVI   DS1PDSS,PDSSMASK   INDICATE THIS PDS SPECIFIED\n         SPACE\nF1COUNT  LH    R1,DSCOUNT         COUNT DATA SETS\n         LA    R1,1(R1)\n         STH   R1,DSCOUNT\n         SPACE\n         L     RWK1,FMT1ADDR           LOAD BEGINNING OF CHAIN\n         L     RWK2,=A(FMT1ADDR-FM1NXTF1)  LOAD CHAIN HISTORY REG\nF1SORT   CLC   DS1DSNAM(44),FM1DSNAM(RWK1)  SORT INTO SEQUENCE\n         BL    F1THREAD                BRANCH WHEN PLACE IS FOUND\n         LR    RWK2,RWK1               UPDATE HISTORY REG\n         L     RWK1,FM1NXTF1(RWK1)     FOLLOW CHAIN TO NEXT\n         B     F1SORT\n         SPACE\nF1THREAD ST    RWK1,DS1NXTF1           CHAIN TO FOLLOWING BLOCK\n         ST    RDS1,FM1NXTF1(RWK2)     CHAIN FROM PRECEDING BLOCK\n         SR    R0,R0                   ZERO CHAIN TO POSSIBLE FORMAT 3\n         ST    R0,DS1CHAIN               BLOCK\n         SPACE\n         CLC   DS1PTRDS,=5X'00'        TEST FOR FORMAT 3 ADDRESS\n         BE    F1RDLOOP                BRANCH IF NO\n         LA    RWK3,DS3SIZE            LENGTH OF BLOCK FOR FORMAT 3\n         BAL   RRET,GETBLOCK\n         LR    RDS3,RWK2               BASE REG FOR FMT 3\n         USING DS3,RDS3\n         LA    RWK1,DS1PTRDS           ADDRESS OF DISK ADDRESS\nF3RD     BAL   RRET,READDIR            READ BLOCK\n         CLI   DS3FMTID,X'F3'          TEST FOR FORMAT 3\n         BE    F3GOT                   BRANCH IF FOUND\n         CLC   DS3PTRDS,=5X'00'        IF NOT 3, TRY FOR ANOTHER\n         BE    F1RDLOOP                BRANCH IF NO MORE\n         LA    RWK1,DS3PTRDS           ADDRESS OF DISK ADDRESS\n         B     F3RD                    TRY AGAIN\nF3GOT    ST    RDS3,DS1CHAIN           CHAIN FROM FMT 1 BLOCK\n*                                                                WFB SL\n*              FOLLOWING 'WFB' CODE ADDED TO SUPPORT DF/EF VSAM  WFB SL\n*              DATASETS WITH MORE THAN 16 EXTENTS.               WFB SL\n*                                                                WFB SL\nF3TEST   CLC   DS3PTRDS,=5X'00'        END OF F3 CHAIN ?         WFB SL\n         BE    F1RDLOOP                YES, GO FOR NEXT F1       WFB SL\n         MVC   DS3POINT,DS3PTRDS       TEMP SAVE F3 DISK ADDRESS WFB SL\n         LA    RWK3,DS3SIZE            SIZE OF CORE NEEDED       WFB SL\n         BAL   RRET,GETBLOCK           GO GET SPACE              WFB SL\n         ST    RWK2,DS3CHAIN           SAVE SPACE CHAIN          WFB SL\n         LR    RDS3,RWK2               POINT TO NEW F3           WFB SL\n*        USING DS3,RDS3                  (NOW MAPPING NEW F3)    WFB SL\n         XC    DS3CHAIN,DS3CHAIN       CLEAR THE NEW CHAIN WORD  WFB SL\n         LA    RWK1,DS3POINT           GET NEW (SAVED) DISK ADDR WFB SL\n         BAL   RRET,READDIR            READ NEW F3               WFB SL\n         CLI   DS3FMTID,X'F3'          IS IT REALLY A F3 ?       WFB SL\n         BE    F3TEST                  YES, LOOP                 WFB SL\n         BAL   RRET,DISASTER           NO, ERROR                 WFB SL\n*                                                                WFB SL\n*              END OF DF/EF VSAM EXTENT SUPPORT                  WFB SL\n*              (FOLLOWING 1 BRANCH COMMENTED - NOW NEVER DONE)   WFB SL\n*                                                                WFB SL\n*        B     F1RDLOOP                GO GET NEXT FORMAT 1 BLOCK\n         DROP  RDS1,RDS3\n         SPACE 3\n* VTOC IS COMPLETELY READ.  CLOSE READING SUBROUTINE.\n         SPACE\nVTRDDONE LA    R0,2                    CALL MODE 2 FOR CLOSE\n         L     RGO,VTOCREAD            ADDRESS OF XVTCREAD\n         BALR  RRET,RGO                BRANCH TO ROUTINE\n         EJECT\n* EDIT FIRST LINE FROM FORMAT 4 DSCB, DESCRIBING DEVICE PARAMETERS.\n         SPACE\n         USING DS4,RDS4\n         L     RDS4,FMT4ADDR\n         SPACE\n         MVC   V1+1(19),=C'DEVICE DESCRIPTION:'\n         SPACE\n         MVC   V1TYPE(5),=C'TYPE='\n         L     RWK1,DEVNAMAD           LOAD ADDRESS OF TABLE FOR DEVICE\n         MVC   V1TYPE+5(15),1(RWK1)    INSERT DEVICE NAME IN PRINT LINE\n         SPACE\n         MVC   V1NOCYL(7),=C'NOCYLS='  NUMBER OF LOGICAL CYLINDERS\n         LA    RWK1,DS4DEVSZ\n         BAL   RRET,BINALF2\n         MVC   V1NOCYL+7(5),BTAALFJ\n         SPACE\n         CLI   DEVNAMOB,X'0E'          IS THIS A 3380 DEVICE    WFB SN\n         BNE   NOT3380                 NO                       WFB SN\n         SPACE\n         CP    BTADWD,=P'886'          IS THIS A 3380-E DEVICE  WFB SN\n         BNH   NOT3380E                NO                       WFB SN\n         SPACE\n         MVC   V1TYPE+5(15),DEV3380E   INSERT DEVICE NAME       WFB SN\n         SPACE\n         B     NOT3380                                          WFB SN\n         SPACE\nNOT3380E DS    0H                                               WFB SN\n         MVC   FMAXTT,FM3380E          SET MAX NUM OF TRKS 3380 WFB SN\n         SPACE\nNOT3380  DS    0H                                               WFB SN\n         MVC   V1TRCYL(9),=C'TRKS/CYL='\n         LA    RWK1,DS4DEVSZ+2         TRACKS PER CYLINDER\n         BAL   RRET,BINALF2\n         MVC   V1TRCYL+9(4),BTAALFJ\n         SPACE\n         MVC   V1DEVTK(8),=C'TRKSIZE=' LENGTH OF TRACK\n         LA    RWK1,DS4DEVTK\n         BAL   RRET,BINALF2\n         MVC   V1DEVTK+8(5),BTAALFJ\n         SPACE\n         MVC   V1DEVDT(9),=C'DSCB/TRK='  DSCB'S PER TRACK\n         LA    RWK1,DS4DEVDT\n         BAL   RRET,BINALF1\n         MVC   V1DEVDT+9(3),BTAALFJ\n         SPACE\n         MVC   V1DEVDB(8),=C'PDS/TRK=' PDS DIRECTORY BLOCKS PER TRACK\n         LA    RWK1,DS4DEVDB\n         BAL   RRET,BINALF1\n         MVC   V1DEVDB+8(3),BTAALFJ\n         SPACE\n         MVI   V1,PRSP2                PRINT AND SPACE 2\n         BAL   RRET,PRINTSUB\n         SPACE 3\n* EDIT THE SECOND LINE FROM THE FORMAT 4 DSCB, DESCRIBING THE VTOC\n* DATA SET.\n         SPACE\n         MVC   V2+1(17),=C'VTOC DESCRIPTION:'\n         SPACE\n         MVC   V2DSCBCT(10),=C'NUM DSCBS='  NUMBER OF DSCBS\n         SR    R0,R0\n         IC    R0,DS4DEVDT             INSERT DSCB'S PER TRACK\n         MH    R0,VTOCSIZE             TIMES NUMBER OF VTOC TRACKS\n         BAL   RRET,BINALFR\n         MVC   V2DSCBCT+10(5),BTAALFJ\n         SPACE\n         MVC   V2DSCBAV(12),=C'AVAIL DSCBS='  NUM UNUSED DSCB'S\n         LA    RWK1,DS4DSREC\n         BAL   RRET,BINALF2\n         MVC   V2DSCBAV+12(5),BTAALFJ\n         SPACE\n         MVC   V2VTEXT(12),=C'VTOC EXTENT='  VTOC TRACK ADDRESSES\n         MVI   V2VTEXT+16,C'.'\n         MVI   V2VTEXT+21,C'-'\n         MVI   V2VTEXT+26,C'.'\n         UNPK  HEXWORK(15),DS4VTOCE+2(8)\n         TR    HEXWORK(15),HEXEDTAB\n         MVC   V2VTEXT+12(4),HEXWORK\n         MVC   V2VTEXT+17(4),HEXWORK+4\n         UNPK  HEXWORK(15),DS4VTOCE+6(8)\n         TR    HEXWORK(15),HEXEDTAB\n         MVC   V2VTEXT+22(4),HEXWORK\n         MVC   V2VTEXT+27(4),HEXWORK+4\n         SPACE\n         MVC   V2NUMALT(7),=C'NUMALT=' NUMBER OF ALTERNATE TRACKS\n         LA    RWK1,DS4NOATK\n         BAL   RRET,BINALF2\n         MVC   V2NUMALT+7(5),BTAALFJ\n         SPACE\n         MVC   V2NXTALT(13),=C'NEXTALT=    .'  ADDRESS OF NEXT ALT TRK\n         UNPK  HEXWORK(15),DS4HCCHH(8)\n         TR    HEXWORK(15),HEXEDTAB\n         MVC   V2NXTALT+8(4),HEXWORK\n         MVC   V2NXTALT+13(4),HEXWORK+4\n         SPACE\n         MVI   V2,PRSP2                PRINT AND SPACE 2\n         BAL   RRET,PRINTSUB\n         SPACE 3\n* PRINT A LINE SUMMARIZING THE AVAILABLE SPACE DESCRIBED IN FORMAT\n* 5 DSCB'S.\n         SPACE\n         MVC   V3+1(16),=C'AVAILABLE SPACE:'\n         SPACE\n         LH    R0,FREETRKS             TOTAL NUMBER OF FREE TRACKS\n         BAL   RRET,BINALFR\n         MVC   V3FRTRKS(5),BTAALF+7\n         MVC   V3FRTRKS+6(9),=C'TRACKS IN'\n         SPACE\n         LH    R0,F5EXTNTS             NUMBER OF FREE EXTENTS\n         BAL   RRET,BINALFR\n         MVC   V3FREXTS(4),BTAALF+8\n         MVC   V3FREXTS+5(18),=C'EXTENTS, INCLUDING'\n         SPACE\n         LH    R0,FREECYLS             NUMBER OF FREE FULL CYLINDERS\n         BAL   RRET,BINALFR\n         MVC   V3FRCYLS(4),BTAALF+8\n         MVC   V3FRCYLS+5(15),=C'FULL CYLINDERS.'\n         SPACE\n         MVI   V3,PRSP2                PRINT AND SPACE 2\n         BAL   RRET,PRINTSUB\n         SPACE 3\n* IF DOS CONTAMINATION FLAG IS ON, WARN USER, AND FORCE TRACK MAP LIST.\n         SPACE\n         TM    DS4VTOCI,X'80'          TEST IF DOS BIT IS ON\n         BZ    DS5OK                   BRANCH IF NOT\n         TM    IXVTFLAG,X'08'          INDEXED VTOC IN USE?     JBSIX\n         BNZ   JBS0100                 BRANCH IF NOT            JBSIX\n         XPRNTLIN  PWA,TEXT=IXVINUSE,LENGTH=L'IXVINUSE,SPA=2    JBSIX\n         B     DS5OK                                            JBSIX\nJBS0100  OI    MODESW,MAPMASK          FORCE TRACK MAP LISTING  JBSIX\n         XPRNTLIN  PWA,TEXT=DS5WARN,LENGTH=L'DS5WARN,SPA=2\nDS5OK    DS    0H\n         SPACE\n* IF THE DUMP SWITCH IS ON, EDIT THE FORMAT 4 AND 5 BLOCKS IN HEX.\n         TM    MODESW,DUMPMASK\n         BZ    F5DONE\n         TM    MODESW,PDSSMASK         ONE SPECIFIC PDSLIST  ?\n         BO    F5DONE                  SKIP DUMP IF YES\n         LR    RWK1,RDS4               ADDRESS OF FORMAT 4 BLOCK\n         LA    RWK2,DS4FDAD              AND ITS DISK ADDRESS\n         BAL   RRET,DUMPDSCB\n         SPACE\n         USING DS5,RDS5\n         L     RDS5,FMT5ADDR           ADDRESS OF FIRST BLOCK\nDUMP5LUP LTR   RDS5,RDS5               TEST FOR END OF CHAIN\n         BZ    DUMP5DON\n         LR    RWK1,RDS5               ADDRESS OF DSCB\n         LA    RWK2,DS5FDAD              AND ITS DISK ADDRESS\n         BAL   RRET,DUMPDSCB           GO TO PRINT IN HEX\n         L     RDS5,DS5CHAIN           FOLLOW CHAIN TO NEXT BLOCK\n         B     DUMP5LUP\n         SPACE\nDUMP5DON XPRSPACE  PWA,LINES=2         SPACE UP TWO LINES\n         SPACE\nF5DONE   DS    0H\n         DROP  RDS4,RDS5\n         EJECT\n*************************\n* FORMAT 1 EDITING LOOP *\n*************************\n         SPACE\n* NOW ALL FORMAT 1 DSCB'S ARE IN CORE WITH THEIR OPTIONAL FORMAT 3\n* BLOCKS ATTACHED.  EDIT ONE LINE FOR EACH, THEN DUMP THE BLOCKS IN\n* HEX IF THE DUMP SWITCH IS ON.\n         SPACE 2\n         USING DS1,RDS1\n         USING DS3,RDS3\nF1EDIT   L     RDS1,=A(FMT1ADDR-FM1NXTF1)  LOAD CHAIN BEGINNING\n         SPACE\n* PRINT SUB-HEADING LINES ON PAGE FOLLOWING FORMAT 4 AND 5 INFO, AND\n* SET UP PRINTING ROUTINE TO PRINT SUB-HEAD ON SUBSEQUENT PAGES.\n         SPACE\n         XPRLIST  PWA,LIST=(F1SA,F1SB) PRINT SUB-HEADING LINES\n         SPACE\n         XPRHEAD  PWA,LIST=(F1HD2,F1SA,F1SB)  SET UP FULL HEADING\n         EJECT\n* BEGIN EACH NEW DATA SET HERE:\n         SPACE\nF1EDLOOP L     RDS1,DS1NXTF1           FOLLOW CHAIN TO NEXT BLOCK\n         CLC   DS1DSNAM(44),LASTFMT1   CHECK FOR CHAIN TERMINATOR\n         BE    ENDF1                   BRANCH AT END\n         TM    MODESW,PDSSMASK         ONE SPECIFIC PDSLIST REQUESTED ?\n         BNO   *+12                    LIST ALL DSCB'S IF NOT\n         TM    DS1PDSS,PDSSMASK        IS THIS THE PDS SPECIFIED  ?\n         BNO   F1EDLOOP                SKIP IF NOT\n         L     RDS3,DS1CHAIN           LOAD FORMAT 3 ADDRESS\n         SPACE\n         BAL   RRET,F1SPANAL           ANALYZE SPACE OCCUPIED\n         SPACE\n* TEST PAGE BALANCE TO BE SURE ALL OUTPUT FOR A DATA SET WILL APPEAR\n* ON THE SAME PAGE.\n         SPACE\n         LA    RWK1,1                  AT LEAST 1 LINE ALWAYS NEEDED\n         TM    MODESW,DUMPMASK         TEST FOR DUMP\n         BZ    F1TEST                  BRANCH IF ONLY 1 LINE\n         AH    RWK1,=H'4'              ADD 4 FOR FORMAT 1 BLOCK DUMP\n         LTR   RDS3,RDS3               TEST FOR PRESENCE OF FORMAT 3\n         BZ    F1TEST\n         AH    RWK1,=H'4'              ADD 4 FOR FORMAT 3 BLOCK\nF1CHK1F3 ICM   RDS3,B'1111',DS3CHAIN   TEST FOR CHAINED FORMAT 3 WFB SL\n         BZ    F1RST1F3                NONE, DONE                WFB SL\n         AH    RWK1,=H'4'              ADD 4 FOR FORMAT 3 BLOCK  WFB SL\n         B     F1CHK1F3                LOOP TO COUNT ALL F3S     WFB SL\nF1RST1F3 L     RDS3,DS1CHAIN           RESTORE FIRST F3 POINTER  WFB SL\nF1TEST   BAL   RRET,PAGECHEK\n         SPACE\n* PRINT ONE LINE OF INFORMATION FROM A FORMAT 1 DSCB.\n         SPACE\n         MVC   F1DSNAM(44),DS1DSNAM    DATA SET NAME\n         SPACE\n*        MVC   F1DSSN(6),DS1DSSN       VOLUME SERIAL\n*        CLI   DS1DSSN,X'52'        -->GOOD TILL YEAR 1982      JBSJX\n*        BNL   NODATE\n*                                                                WFB SL\n*        ABOVE 2 LINES COMMENTED OUT. INSTEAD, CHECK DS1REFD.    WFB SL\n*        IF NEVER ACCESSED, SKIP EDIT OF DATE AND USE-COUNT.     WFB SL\n*        (ALSO MOVED LABEL \"NODATE\" TO OTHER SIDE OF USE-COUNT)  WFB SL\n*                                                                WFB SL\n         CLI   DS1REFD,X'00'           ANY LAST REFERENCE DATE ? WFB SL\n         BE    NODATE                  NO, SKIP DATE AND USE-CNT WFB SL\n         LA    RWK1,DS1REFD            LAST REFERENCED DATE     JBSJX\n         LA    RWK2,F1DSSN             PTS TO OUT AREA\n         BAL   RRET,VTDATED            FORMATS THE DATE\n         SPACE\n*        LA    RWK1,DS1VOLSQ           ADDRESS OF VOLUME SEQUENCE\n*                                                                WFB SL\n*        IF PRESENT, THE USE COUNT IS KEPT IN THE FIRST 3 BYTES  WFB SL\n*        OF THE DS1DSSN (SERIAL NUMBER) FIELD. IF NOT PRESENT,   WFB SL\n*        DS1DSSN CONTAINS THE PRINTABLE SERIAL OF THE VOLUME ON  WFB SL\n*        WHICH THE DSCB WAS ORIGINALLY CREATED. THEREFORE ANY    WFB SL\n*        PRINTABLE CHARACTER IN POSITION 1 SHOULD CAUSE A SKIP.  WFB SL\n*                                                                WFB SL\n         CLI   DS1DSSN,C' '            PRINTABLE (VOL SERIAL) ?  WFB SL\n         BNL   NODATE                  YES, SKIP USE-COUNT       WFB SL\n         LA    RWK1,DS1DSSN            GET USE COUNT(FROM ASM-2)JBSJX\n         BAL   RRET,BINALF3\n         MVC   F1VOLSQ(6),BTAALF+6\n         SPACE\nNODATE   EQU    *\n         LA    RWK1,DS1CREDT           ADDRESS OF CREATION DATE\n         LA    RWK2,F1CREDT\n         BAL   RRET,VTDATED\n         SPACE\n         LA    RWK1,DS1EXPDT           ADDRESS OF EXPIRATION DATE\n         LA    RWK2,F1EXPDT\n         BAL   RRET,VTDATED\n         SPACE\n         LA    RWK1,F1DSORG            ADDR OF DSORG FIELD\n         TM    DS1DSORG,ISDSORG        TEST INDEXED SEQUENTIAL\n         BZ    NOTIS\n         MVC   0(2,RWK1),=C'IS'\n         LA    RWK1,2(RWK1)\nNOTIS    TM    DS1DSORG,PSDSORG        TEST PHYSICAL SEQUENTIAL\n         BZ    NOTPS\n         MVC   0(2,RWK1),=C'PS'\n         LA    RWK1,2(RWK1)\nNOTPS    TM    DS1DSORG,DADSORG        TEST DIRECT ACCESS\n         BZ    NOTDA\n         MVC   0(2,RWK1),=C'DA'\n         LA    RWK1,2(RWK1)\nNOTDA    TM    DS1DSORG,PODSORG        TEST PARTITIONED\n         BZ    NOTPO\n         MVC   0(2,RWK1),=C'PO'\n         LA    RWK1,2(RWK1)\nNOTPO    TM    DS1DSORG,X'01'          TEST UNMOVEABLE\n         BZ    NOTU\n         MVI   0(RWK1),C'U'\nNOTU     DS    0H\n         SPACE\n         UNPK  HEXWORK(15),DS1OPTCD(8) OPTION CODE, IN HEX\n         TR    HEXWORK(15),HEXEDTAB\n         MVC   F1OPTCD(2),HEXWORK\n         SPACE\n         LA    RWK1,F1RECFM            ADDR OF RECORD FORMAT FIELD\n         TM    DS1RECFM,X'C0'\n         BZ    RECFMUP                 ZEROS NOT DEFINED\n         MVI   0(RWK1),C'U'\n         BO    RECFMUP                 11 IS FORMAT 'U'\n         TM    DS1RECFM,X'80'          WE NOW KNOW IT'S MIXED\n         MVI   0(RWK1),C'F'            10 IS FORMAT 'F'\n         BO    RECFMUP\n         MVI   0(RWK1),C'V'            01 IS FORMAT 'V'\nRECFMUP  LA    RWK1,1(RWK1)\n         TM    DS1RECFM,X'20'          TEST TRACK OVERFLOW\n         BZ    RECFMB\n         MVI   0(RWK1),C'T'\n         LA    RWK1,1(RWK1)\nRECFMB   TM    DS1RECFM,X'10'          TEST FOR BLOCKED\n         BZ    RECFMS\n         MVI   0(RWK1),C'B'\n         LA    RWK1,1(RWK1)\nRECFMS   TM    DS1RECFM,X'08'          TEST FOR STANDARD BLOCKS\n         BZ    RECFMAM\n         MVI   0(RWK1),C'S'\n         LA    RWK1,1(RWK1)\nRECFMAM  TM    DS1RECFM,X'06'          TEST CONTROL CHAR TYPE\n         BC    11,RECFME               BRANCH IF NOT MIXED\n         TM    DS1RECFM,X'04'\n         MVI   0(RWK1),C'A'\n         BO    RECFME\n         MVI   0(RWK1),C'M'\nRECFME   DS    0H\n         SPACE\n         LA    RWK1,DS1BLKL            BLOCK SIZE\n         BAL   RRET,BINALF2\n         MVC   F1BLKL(5),BTAALF+7\n         SPACE\n         LA    RWK1,DS1LRECL           LOGICAL RECORD LENGTH\n         BAL   RRET,BINALF2\n         MVC   F1LRECL(5),BTAALF+7\n         SPACE\n         LA    RWK1,DS1KEYL            KEY LENGTH\n         BAL   RRET,BINALF1\n         MVC   F1KEYL(3),BTAALF+9\n         SPACE\n         L     R0,F1TRCNT              ALLOCATION SIZE IN TRACKS\n         BAL   RRET,BINALFR\n         MVC   F1TRALOC(5),BTAALF+7\n         SPACE\n         CLC   DS1LSTAR(3),=XL3'00'\n         BE    NONEUSED\n         NC    F1TRCNT(4),F1TRCNT      SEE IF ANY TRACKS ASSIGNED\n         BZ    NONEUSED                NO; THEN NONE CAN BE USED\n         LH    R0,DS1LSTAR             TRACKS ACTUALLY USED\n         AH    R0,=H'1'\n         BAL   RRET,BINALFR\n         MVC   F1TRUSE(5),BTAALF+7\nNONEUSED DS    0H\n         SPACE\n         LA    RWK1,DS1NOEPV           NUMBER OF EXTENTS\n         BAL   RRET,BINALF1\n         MVC   F1NOEPV(2),BTAALF+10\n         CLI   BTAALF+9,C' '           MORE THAN 100 EXTENTS ?   WFB SL\n         BE    LESS100X                NO, CONTINUE          XX  WFB SL\n         MVC   F1NOEPV(3),BTAALF+9     YES, READJUST INTO => XXX WFB SL\nLESS100X EQU   *                                             XX  WFB SL\n         SPACE\n         LA    RWK1,DS1SCALO+1         SECONDARY QUANTITY SIZE\n         BAL   RRET,BINALF3\n         MVC   F1SCALO(5),BTAALF+7\n         SPACE\n         TM    DS1SCALO,X'C0'          TYPE OF SPACE ALLOCATION\n         BC    14,NOTCYL               BR IF NOT ONES\n         MVI   F1ALCTYP,C'C'           CYLINDER\n         B     SCALDONE\nNOTCYL   BC    7,NOTABSTR              BR IF NOT ZEROS\n         MVI   F1ALCTYP,C'A'           ABSOLUTE TRACK\n         B     SCALDONE\nNOTABSTR TM    DS1SCALO,X'80'          NOW KNOW IT IS MIXED\n         BO    TRKALO\n         MVI   F1ALCTYP,C'B'           BLOCK\n         B     SCALDONE\nTRKALO   MVI   F1ALCTYP,C'T'           TRACK\nSCALDONE DS    0H\n         EJECT\n* EACH DATA SET LINE IS SINGLE-SPACED, UNLESS FOLLOWED BY A DUMP OR\n* PDS DIRECTORY LISTING.\n         SPACE\n         MVI   F1A,PRSP1\n         TM    MODESW,DUMPMASK         TEST IF DUMP FOLLOWS\n         BO    F1PRINT2                YES, DOUBLE SPACE\n         TM    MODESW,PDSLMASK+PDSSMASK   PDS LISTING  ?\n         BZ    F1PRINT1                NO, SINGLE SPACE\n         TM    DS1DSORG,PODSORG        TEST IF THIS DS PARTITIONED\n         BZ    F1PRINT1                NO, SINGLE SPACE\nF1PRINT2 MVI   F1A,PRSP2               DOUBLE SPACE\nF1PRINT1 BAL   RRET,PRINTSUB           PRINT THE LINE\n         SPACE\n* IF DUMP SWITCH IS SET, EDIT THE DSCB'S IN HEX.\n         SPACE\n         TM    MODESW,DUMPMASK\n         BZ    F1DMPDON                BRANCH IF NO DUMP\n         TM    MODESW,PDSSMASK         ONE SPECIFIC PDSLIST  ?\n         BO    F1DMPDON                SKIP DUMP IF YES\n         SPACE\n         LA    RWK1,DS1                DUMP FORMAT 1 DSCB\n         LA    RWK2,DS1FDAD\n         BAL   RRET,DUMPDSCB\n         SPACE\n         LTR   RDS3,RDS3               TEST FOR FORMAT 3 BLOCK\n         BZ    F1DMPDON\n         LA    RWK1,DS3\n         LA    RWK2,DS3FDAD\n         BAL   RRET,DUMPDSCB\nF1CHK2F3 ICM   RDS3,B'1111',DS3CHAIN   TEST FOR CHAINED FORMAT 3 WFB SL\n         BZ    F1RST2F3                NONE, DONE                WFB SL\n         LA    RWK1,DS3                                          WFB SL\n         LA    RWK2,DS3FDAD                                      WFB SL\n         BAL   RRET,DUMPDSCB                                     WFB SL\n         B     F1CHK2F3                LOOP TO DUMP ALL F3S      WFB SL\nF1RST2F3 L     RDS3,DS1CHAIN           RESTORE FIRST F3 POINTER  WFB SL\n         SPACE\nF1DMPDON DS    0H\n         SPACE\n* IF THE PDS SWITCH IS SET AND THIS IS A PDS, EDIT ITS DIRECTORY.\n         SPACE\n         TM    MODESW,PDSLMASK+PDSSMASK   PDS LISTING  ?\n         BZ    F1PDSDON                SKIP IF NEITHER\n         TM    DS1DSORG,PODSORG        TEST IF PARTITIONED\n         BZ    F1PDSDON\n         LA    RWK1,DS1DSNAM\n         SPACE\n         BAL   RRET,PDSLIST            CALL LISTING SUBROUTINE\n         SPACE\nF1PDSDON DS    0H\n         B     F1EDLOOP\n         EJECT\n* END DATA SET LISTING.  PRINT A LINE GIVING THE NUMBER OF DATA SETS.\n         SPACE\nENDF1    DS    0H\n         MVC   PL+49(14),=C'<<<<< END VTOC'\n         LH    R0,DSCOUNT\n         BAL   RRET,BINALFR\n         MVC   PL+64(4),BTAALF+8\n         MVC   PL+69(15),=C'DATA SETS >>>>>'\n         SPACE\n         XPRNTLIN  PWA,TEXT=PL+1,LENGTH=132,SPB=1,SPA=0\n         SPACE\nENDF1X   MVI   PL+1,C' '               BLANK PRINT LINE\n         MVC   PL+2(131),PL+1\n         SPACE 3\n         DROP  RDS1,RDS3\n         EJECT\n**********************\n* TRACK MAP PRINTING *\n**********************\n         SPACE\n* START A FRESH PAGE AND PRINT THE TRACK MAP FROM CORE, ONE LINE\n* PER ENTRY.\n         SPACE 2\n         USING MB,RMB\nMAPEDIT  TM    MODESW,MAPMASK          TEST IF MAP WANTED\n         BZ    ENDVOL                  BRANCH IF NOT\n         TM    MODESW,PDSSMASK         ONE SPECIFIC PDSLIST  ?\n         BO    ENDVOL                  SKIP MAP IF YES\n         SPACE\n         XPREJECT  PWA                 SKIP TO FRESH PAGE\n         SPACE\n         MVC   TMHSER1(6),VOLUME       PUT VOLUME SERIAL IN HEADING\n         MVC   TMHSER2(6),VOLUME\n         XPRHEAD  PWA,LIST=(TMHEAD,TMSA,TMSB)  SET UP HEADING LINES\n         SPACE\n         L     RMB,MBBASE              BEGINNING OF ENTRY CHAIN\n         L     RWK3,=F'-1'             CLEAR HIGHEST TTREL FOUND\n         SR    RWK4,RWK4               CLEAR TRACK COUNTER\n         SPACE\nMAPELOOP CLC   MBCCHH1(4),MBTERM       TEST FOR END OF CHAIN\n         BE    ENDMAPED\n         SPACE\n* CHECK EACH EXTENT FOR POSSIBLE ERRORS.  BEGIN BY SEEING THAT THE\n* HIGHER RELATIVE TRACK NUMBER DOES NOT EXCEED THE NUMBER OF TRACKS IN\n* THE VOLUME, AND THAT THE LOWER TTREL DOES NOT EXCEED THE HIGHER ONE.\n         SPACE\nTESTEX   CLC   MBTTREL2(2),FMAXTT      TEST 2ND FOR MAX\n         BNL   EXINVAL                 EXTENT INVALID IF HIGH\n         CLC   MBTTREL1(2),MBTTREL2    TEST IF LOWER NOT > HIGHER\n         BH    EXINVAL                 INVALID IF SO\n         SPACE\n* TEST THAT LOWER TTREL IS ONE GREATER THAN THE PREVIOUS HIGHEST TTREL.\n         SPACE\n         LH    R0,MBTTREL1             GET CURRENT LOWER TTREL\n         SR    R0,RWK3                 SUBTRACT HIGHEST TTREL TO DATE\n         S     R0,=F'1'\n         BZ    EXOK                    OK IF EQUAL\n         BP    TMISSING                POSITIVE MEANS MISSING TRACKS\n         SPACE\n* A NEGATIVE DIFFERENCE INDICATES AN OVERLAP WITH A PREVIOUS EXTENT.\n* FLAG THE CURRENT EXTENT, AND SET THE HIGH WATER MARK FROM IT ONLY IF\n* LARGER THAN THE CURRENT VALUE.\n         SPACE\n         MVC   TMERROR-7(7),=C'OVERLAP'\n         CH    RWK3,MBTTREL2           TEST AGAINST PREVIOUS MARK\n         BNL   BYPWK3                  BRANCH IF SMALLER\n         SPACE\n* UPDATE THE HIGH-WATER MARK AND ACCUMULATE THE NUMBER OF TRACKS WHICH\n* HAVE BEEN ACCOUNTED FOR.\n         SPACE\nEXOK     LH    RWK3,MBTTREL2           UPDATE HIGHEST TRACK YET\nBYPWK3   LH    R0,MBNTRKS              LOAD N TRACKS IN EXTENT\n         AR    RWK4,R0                 ACCUMULATE\n         BAL   RRET,BINALFR            CONVERT N TO ALPHA FOR PRINTING\n         MVC   TMEXTSIZ(5),BTAALF+7    PUT IN PRINT LINE\n         B     EDITCCHH                CONTINUE WITH EDITING\n         SPACE\n* FLAG INVALID EXTENTS AND BYPASS HIGHEST TRACK AND COUNT UPDATING.\n         SPACE\nEXINVAL  MVC   TMERROR-14(14),=C'INVALID EXTENT'\n         B     EDITCCHH\n         SPACE\n* WHEN TRACKS ARE MISSING, INDICATE HOW MANY BEFORE PRINTING THE\n* NEXT EXTENT NORMALLY.\n         SPACE\nTMISSING BAL   RRET,BINALFR            EDIT N MISSING TRACKS TO ALF\n         MVC   TMERROR-14(14),=C'TRACKS MISSING'\n         MVC   TMERROR-20(5),BTAALF+7  INSERT N MISSING IN PRINT LINE\n         MVI   TM1,PRSP1\n         BAL   RRET,PRINTSUB           PRINT ERROR MESSAGE\n         B     EXOK\n         SPACE\n* INSERT LOWER AND UPPER ADDRESSES IN CCHH FORM, AND ADD DATA SET NAME.\n         SPACE\nEDITCCHH UNPK  HEXWORK(15),MBCCHH1(8)  FIRST TRACK ADDRESS\n         TR    HEXWORK(15),HEXEDTAB\n         MVC   TMCCHH1(4),HEXWORK\n         MVI   TMCCHH1+4,C'.'\n         MVC   TMCCHH1+5(4),HEXWORK+4\n         MVC   HOLDJA+2(2),MBCCHH1\n         L     R0,HOLDJA                                       GTEL\n         CVD   R0,HOLDJA                                       GTEL\n         OI    HOLDJA+7,X'0F'                                  GTEL\n         UNPK  HEXWORK(4),HOLDJA+5(3)                          WFB SN\n         MVC   TMDECCH1(4),HEXWORK                             WFB SN\n         MVI   TMDECCH1+4,C'.'                                 GTEL\n         MVC   HOLDJA(4),=F'00'                                GTEL\n         MVC   HOLDJA+2(2),MBCCHH1+2                           GTEL\n         L     R0,HOLDJA                                       GTEL\n         CVD   R0,HOLDJA                                       GTEL\n         OI    HOLDJA+7,X'0F'                                  GTEL\n         UNPK  TMDECCH1+5(4),HOLDJA+6(2)                       GTEL\n         MVC   HOLDJA(4),=F'00'                                GTEL\n         SPACE\n         UNPK  HEXWORK(15),MBCCHH2(8)  ADDR OF LAST TRACK\n         TR    HEXWORK(15),HEXEDTAB\n         MVC   TMCCHH2(4),HEXWORK\n         MVI   TMCCHH2+4,C'.'\n         MVC   TMCCHH2+5(4),HEXWORK+4\n         MVC   HOLDJA+2(2),MBCCHH2                             GTEL\n         L     R0,HOLDJA                                       GTEL\n         CVD   R0,HOLDJA                                       GTEL\n         OI    HOLDJA+7,X'0F'                                  GTEL\n         UNPK  HEXWORK(4),HOLDJA+5(3)                          WFB SN\n         MVC   TMDECCH2(4),HEXWORK                             WFB SN\n         MVI   TMDECCH2+4,C'.'                                 GTEL\n         MVC   HOLDJA(4),=F'00'                                GTEL\n         MVC   HOLDJA+2(2),MBCCHH2+2                           GTEL\n         L     R0,HOLDJA                                       GTEL\n         CVD   R0,HOLDJA                                       GTEL\n         OI    HOLDJA+7,X'0F'                                  GTEL\n         UNPK  TMDECCH2+5(4),HOLDJA+6(2)                       GTEL\n         MVC   HOLDJA(4),=F'00'                                GTEL\n         SPACE\n         TM    MBEXT,X'FF'             TEST IF NO EXTENT NUMBER\n         BO    TMBLEXT\n         SR    R0,R0\n         IC    R0,MBEXT\n         AH    R0,=H'1'\n         BAL   RRET,BINALFR\n*        MVC   TMEXTNO(2),BTAALF+10                  (REPLACED)  WFB SL\n         MVC   TMEXTNO-1(3),BTAALF+9                (REPLACMENT) WFB SL\n*                                                                WFB SL\n*        BECAUSE 'MBEXT' HOLDS THE VALUE 'EXTENT NUMBER - 1'     WFB SL\n*        THIS CODE WILL NOT REPORT THE 255TH EXTENT, BUT THEN ...WFB SL\n*                                                                WFB SL\nTMBLEXT  DS    0H\n         SPACE\n         L     R1,MBNAME               ADDRESS OF DSNAME\n         MVC   TMDSNAM(44),0(R1)\n         SPACE\n         MVI   TM1,PRSP1               PRINT AND SPACE 1\n         BAL   RRET,PRINTSUB\n         L     RMB,MBCHAIN             FOLLOW CHAIN TO NEXT BLOCK\n         B     MAPELOOP\n         SPACE 2\n* END OF MAP.  CHECK THAT THE LAST ENTRY BROUGHT US TO THE LAST\n* PRIMARY TRACK.\n         SPACE\nENDMAPED LH    R0,FMAXTT               LOAD LAST TRK +1\n         SR    R0,RWK3                 TEST AGAINST HIGHEST FOUND\n         S     R0,=F'1'\n         BNP   ENDMAPPR                BRANCH IF ALL FOUND\n         SPACE\n* SOME TRACKS ARE MISSING, SO PRINT A WARNING.\n         SPACE\n         BAL   RRET,BINALFR            EDIT NUMBER MISSING\n         MVC   TMERROR-14(14),=C'TRACKS MISSING'\n         MVC   TMERROR-20(5),BTAALF+7\n         MVI   TM1,PRSP1\n         BAL   RRET,PRINTSUB           PRINT ERROR MESSAGE\n         SPACE\nENDMAPPR DS    0H\n         LR    R0,RWK4                 LOAD TRACK COUNT\n         BAL   RRET,BINALFR            EDIT TO ALPHA\n         MVC   TMEXTSIZ(5),BTAALF+7\n         MVC   TMEXTSIZ+7(20),=C'TRACKS ACCOUNTED FOR'\n         SPACE\n         XPRNTLIN  PWA,TEXT=PL+1,LENGTH=132,SPB=1,SPA=2\n         SPACE\n         MVI   PL+1,C' '\n         MVC   PL+2(131),PL+1\n         SPACE\n         MVC   PL+52(28),=C'<<<<< END OF TRACK MAP >>>>>'\n         MVI   PL,PRSP0\n         BAL   RRET,PRINTSUB\n         SPACE\n         DROP  RMB\n         SPACE 6\n* END OF VOLUME LISTINGS\n         SPACE\nENDVOL   DS    0H\n         BAL   RRET,GBRESET            RELEASE DSCB CORE\nENDVOL2  CLI   PARMSW,1                ONE SPECIFIC DDNAME REQUESTED ?\n         BE    EXODUS                  SKIP OUT IF YES\n         NI    MODESW,X'FF'-PDSSMASK   TURN OFF SPECIFIC PDSLIST\n         SPACE\n         B     NEWVOL             GET ANOTHER VOLUME\n         EJECT\n**************************\n* ERROR MESSAGE PRINTING *\n**************************\n         SPACE\n* ERRORS WHILE TRYING TO OPEN THE VTOC:\n         SPACE\nNODDCARD MVC   PL+41(19),=C'CANNOT FIND DD CARD'\n         B     PRERR1\nNOTDACC  MVC   PL+41(27),=C'DEVICE IS NOT DIRECT ACCESS'\n         B     PRERR1\nUNKNDEV  MVC   PL+41(19),=C'UNKNOWN DEVICE TYPE'\n         B     PRERR1\nCANTOPEN MVC   PL+41(27),=C'ATTEMPT TO OPEN VTOC FAILED'\n         B     PRERR1\nPRERR1   MVC   PL+10(28),=C'ERROR CONCERNING \"VOLUME01\":'\n         MVC   PL+28(8),DDNAME\n         MVI   PL,PRSP3\n         BAL   RRET,PRINTSUB\n         LA    R0,4                    SET RETURN CODE OF 4\n         C     R0,RETCODE\n         BL    *+8\n         ST    R0,RETCODE\n         B     ENDVOL2\n         SPACE 2\n* ERRORS IN DSCB FORMAT:\n         SPACE\nFRSTNOT4 MVC   PL+41(21),=C'FIRST DSCB NOT TYPE 4'\n         LR    RWK1,RDS4               ADDRESS OF BAD BLOCK\n         B     PRERR2\nBADFMT5  MVC   PL+41(33),=C'BAD DSCB, SHOULD HAVE BEEN TYPE 5'\n         LR    RWK1,RDS5               ADDRESS OF BAD BLOCK\n         B     PRERR2\n* PRINT ERROR MESSAGE AND DUMP BAD BLOCK.\n         SPACE\nPRERR2   MVC   PL+10(28),=C'ERROR CONCERNING \"VOLUME01\":'\n         MVC   PL+28(8),DDNAME\n         MVI   PL,PRSP3\n         BAL   RRET,PRINTSUB\n         LA    RWK2,140(RWK1)          ADDR OF FULL DISK ADDRESS\n         BAL   RRET,DUMPDSCB           DUMP BAD BLOCK IN HEX\n         SPACE\n* CLOSE THIS VTOC, SET RETURN CODE, AND GO ON TO NEXT VOLUME.\n         SPACE\n         LA    R0,2                    CALL MODE 2 FOR CLOSE\n         L     RGO,VTOCREAD            ADDRESS OF ROUTINE\n         BALR  RRET,RGO                BRANCH TO XVTCREAD\n         SPACE\n         LA    R0,8                    SET RETURN CODE OF 8\n         C     R0,RETCODE\n         BL    *+8\n         ST    R0,RETCODE\n         B     ENDVOL2\n         EJECT\n*******************************************\n* PARTITIONED DATA SET DIRECTORY PRINTING *\n*******************************************\n         SPACE\n* ENTER THIS ROUTINE WITH THE NAME OF A PARTITIONED DATA SET AT (RWK1).\n* THE DDNAME REFERRING TO THE PROPER VOLUME IS ALREADY SET UP IN THE\n* DCB.  LIST THE MEMBER ENTRYS FROM THE DIRECTORY, AND PRINT THE\n* NUMBER OF MEMBERS, THE NUMBER OF BLOCKS, AND THE NUMBER OF BLOCKS\n* ACTUALLY USED.\n         SPACE 2\nPDSLIST  ST    RRET,PDSEXIT            SAVE RETURN ADDRESS\n         STM   RWK1,RWK4,PDSSAVE         AND WORK REGISTERS\n         SPACE\n* THE JFCB FOR THIS VOLUME IS ALREADY IN CORE, HAVING BEEN READ WHEN\n* THE VTOC WAS OPENED.\n         SPACE\n         L     R1,JFCBADR              SET UP JFCB BASE REG\n         USING JFDUMMY,R1\n         MVC   JFCBDSNM(44),0(RWK1)    INSERT DATA SET NAME\n         DROP  R1\n         SPACE\n         LM    R2,R3,=CL8'NOUSAGE '    PREVENT SETTING DATA SET USAGE\n         OPEN  (PDSDCB,(INPUT)),TYPE=J\n         SPACE\n         SR    R0,R0                   RESET VARIOUS COUNTERS\n         STH   R0,PDSBAL\n         STH   R0,PDSDIRCT             DIRECTORY BLOCK COUNT\n         STH   R0,PDSDIRUS             BLOCKS USED\n         STH   R0,PDSMEMCT             MEMBER COUNT\n         STH   R0,PDSALCT              ALIAS COUNT\n         NI    PDSGETB+1,X'0F'         SET TO NOP  (PROCESS ALL BLOCKS)\n         SPACE\n* GET A MEMBER FROM THE DIRECTORY, SETTING REGISTER 'RPDS' TO IT.\n         SPACE\nGETPDS   LH    R0,PDSBAL               LOAD BALANCE IN CURRENT BLOCK\n         LTR   R0,R0                   TEST FOR ZERO\n         BP    PDSBALOK                BR IF BLOCK NOT EMPTY\n         SPACE\nGETPDSX  READ  PDSECB,SF,PDSDCB,PDSBUF    READ A DIRECTORY BLOCK\n         SPACE\n         CHECK PDSECB\n         SPACE\n         L     RWK1,=A(PDSBUF)\n         USING PDSBUF,RWK1\n         LH    R1,PDSDIRCT             COUNT DIRECTORY BLOCKS\n         LA    R1,1(R1)\n         STH   R1,PDSDIRCT\nPDSGETB  NOP   GETPDSX                 SET TO BRANCH IF COUNT ONLY\n         LH    R0,PDSLRECL             SET BLOCK BALANCE FROM LOGICAL\n         SH    R0,=H'2'                  BLOCK LENGTH FIELD\n         STH   R0,PDSBAL\n         LA    R1,PDSDATA              SET PDSCLC TO BEGINNING OF BLOCK\n         ST    R1,PDSCLC\n         B     GETPDS                  TEST BALANCE....\n         DROP  RWK1\n         SPACE 2\n         USING DIRBLOCK,RPDS\nPDSBALOK L     RPDS,PDSCLC             LOAD ADDRESS OF DIRECTORY ENTRY\n         IC    RWK1,DIRC               GET USER DATA LENGTH\n         N     RWK1,=F'31'\n         SLL   RWK1,1\n         LR    R1,RPDS                 UPDATE BLOCK CLC\n         AR    R1,RWK1\n         LA    R1,12(R1)\n         ST    R1,PDSCLC\n         LH    R1,PDSBAL               DECREMENT BLOCK BALANCE\n         SR    R1,RWK1\n         SH    R1,=H'12'\n         STH   R1,PDSBAL\n         SPACE\n         CLC   DIRNAME(8),=8X'FF'      TEST FOR LAST NAME\n         BNE   EDITMEMB\n         OI    PDSGETB+1,X'F0'         SET TO COUNT ONLY REST OF DIR\n         MVC   PDSDIRUS(2),PDSDIRCT    SAVE COUNT OF BLOCKS USED\n         B     GETPDS                  READ ALL BLOCKS TO GET COUNT\n         SPACE\n* EDIT A LINE FOR THE MEMBER.  IF THE USER DATA WAS MORE THAN 44 BYTES,\n* A SECOND LINE IS REQUIRED.\n         SPACE\nEDITMEMB MVC   PDSMEMB(8),DIRNAME      MEMBER OR ALIAS NAME TO PRINTLIN\n         TM    DIRC,ALIASMSK           TEST IF ALIAS\n         BZ    NOTALIAS                BRANCH IF NOT ALIAS\n         SPACE\n         LH    R1,PDSALCT              COUNT ALIASES\n         LA    R1,1(R1)\n         STH   R1,PDSALCT\n         MVI   PDSALIAS,C'A'           MARK ALIAS IN PRINT LINE\n         B     PDSTTRED\n         SPACE\nNOTALIAS LH    R1,PDSMEMCT             COUNT MEMBER NAMES\n         LA    R1,1(R1)\n         STH   R1,PDSMEMCT\n         SPACE\nPDSTTRED DS    0H\n         UNPK  HEXWORK(7),DIRTTR(4)   EDIT RELATIVE TRACK ADDRESS\n         TR    HEXWORK(7),HEXEDTAB\n         MVC   PDSTTR(4),HEXWORK\n         MVI   PDSTTR+4,C'.'\n         MVC   PDSTTR+5(2),HEXWORK+4\n         SPACE\n         IC    R0,DIRC                 EDIT NUMBER OF TTR'S\n         SRL   R0,5\n         N     R0,=F'3'\n         STC   R0,PDSNTT\n         OI    PDSNTT,X'F0'\n         SPACE\n         LR    RWK4,RWK1               LENGTH OF USER DATA\n         CH    RWK1,=H'44'             TEST IF MORE THAN ONE LINE\n         BNH   PDS1LINE                BR IF ONE LINE\n         SPACE\n         LA    RWK1,2                  ENSURE BOTH LINES ON SAME PAGE\n         BAL   RRET,PAGECHEK\n         LR    RWK1,RWK4               RESTORE RWK1\n         LA    RWK4,44                 LENGTH FOR FIRST LINE\n         SPACE\nPDS1LINE LA    RWK2,DIRUDATA           ADDRESS OF USER DATA\n         LA    RWK3,PDSHEX             PRINT LINE OUTPUT AREA\n         BAL   RRET,DUMPEDIT           EDIT DATA INTO HEX\n         MVI   PDS1,PRSP1              PRINT AND SPACE 1\n         BAL   RRET,PRINTSUB\n         SPACE\n         CH    RWK1,=H'44'             TEST IF SECOND LINE REQUIRED\n         BNH   GETPDS                  BR IF NOT\n         LR    RWK4,RWK1               COMPUTE REMAINING DATA LENGTH\n         SH    RWK4,=H'44'\n         LA    RWK2,DIRUDATA+44\n         LA    RWK3,PDSHEX\n         BAL   RRET,DUMPEDIT\n         MVI   PDS1,PRSP1\n         BAL   RRET,PRINTSUB\n         SPACE\n         B     GETPDS\n         DROP  RPDS\n         EJECT\n* WHEN THE END OF THE DIRECTORY IS REACHED, CLOSE THE DATA SET AND\n* PRINT A SUMMARY LINE WITH THE ACCUMULATED TOTALS.\n         SPACE\nPDSEODAD DS    0H\n         SPACE\n         LH    R0,PDSMEMCT             COUNT OF MEMBERS\n         BAL   RRET,BINALFR\n         MVC   PDSSUMMC(4),BTAALF+8\n         LH    R0,PDSALCT              COUNT OF ALIASES\n         BAL   RRET,BINALFR\n         MVC   PDSSUMAC(4),BTAALF+8\n         LH    R0,PDSDIRUS             DIRECTORY BLOCK USED\n         BAL   RRET,BINALFR\n         MVC   PDSSUMUC(4),BTAALF+8\n         LH    R0,PDSDIRCT             NUMBER OF BLOCKS ALLOCATED\n         BAL   RRET,BINALFR\n         MVC   PDSSUMDC(4),BTAALF+8\n         SPACE\n         XPRNTLIN  PWA,TEXT=PDSSUM,LENGTH=PDSSUMSZ,OFFSET=16,SPA=3\n         SPACE\nPDSCLOSE CLOSE (PDSDCB)\n         SPACE\n         SPACE\n         LM    RWK1,RWK4,PDSSAVE\n         L     RRET,PDSEXIT\n         BR    RRET\n         EJECT\n* PDS SUMMARY LINE:\n         SPACE\nPDSSUM   DC    C'DIRECTORY CONTAINS '\nPDSSUMMC DC    C'0000 MEMBERS AND '\nPDSSUMAC DC    C'0000 ALIASES, AND USES '\nPDSSUMUC DC    C'0000 OF THE '\nPDSSUMDC DC    C'0000 DIRECTORY BLOCKS ALLOCATED'\nPDSSUMSZ EQU   *-PDSSUM\n         SPACE 2\nPDSEXIT  DC    F'0'\nPDSSAVE  DC    4F'0'\nPDSCLC   DC    A(0)\nPDSBAL   DC    H'0'\nPDSDIRCT DC    H'0'\nPDSDIRUS DC    H'0'\nPDSMEMCT DC    H'0'\nPDSALCT  DC    H'0'\n         SPACE 3\n* SYNAD ROUTINE FOR PDS DIRECTORY.  GET ERROR MESSAGE AND LOAD INTO\n* PRINT LINE.  BRANCH TO CLOSE DCB.\n         SPACE\nPDSSYNAD SYNADAF  ACSMETH=BSAM         GET ERROR MESSAGE FROM OS\n         SPACE\n         MVC   PL+1(30),=C'*******PDS DIRECTORY I/O ERROR'\n         MVC   PL+31(79),49(R1)        ADD TEXT FROM SYNADAF\n         SPACE\n         SYNADRLS                      FREE OS MESSAGE BUFFER\n         SPACE\n         MVI   PL,PRSP3                SET TO SPACE 3\n         BAL   RRET,PRINTSUB           PRINT ERROR MESSAGE\n         NI    PDSDCB+DCBIFLGS-IHADCB,X'3F'  RESET DCB ERROR FLAGS\n         MVI   RETCODE+3,12            SET RETURN CODE OF 12\n         B     PDSCLOSE                CLOSE DCB\n         EJECT\n*********************\n* VTOC READ ROUTINE *\n*********************\n         SPACE\n* ROUTINE 'READSEQ' READS THE NEXT DSCB IN SEQUENCE INTO THE\n* 140-BYTE AREA ADDRESSED BY 'RWK2'.  IT CALLS ROUTINE 'XVTCREAD' TO DO\n* THE DIRTY WORK.  NORMAL RETURN IS TO THE ADDRESS IN\n* RRET+4.  IF END-OF-DATA IS ENCOUNTERED, RETURN IS TO RRET.\n* THE FULL DISK ADDRESS (MBBCCHHR) IS SAVED IN THE 8 BYTES FOLLOWING\n* THE BUFFER.\n         SPACE 2\nREADSEQ  ST    RRET,RDSEQXT            SAVE RETURN ADDRESS\n         SPACE\n         SR    R0,R0                   CALL MODE 0 FOR READ\n         L     RGO,VTOCREAD            ADDRESS OF XVTCREAD ROUTINE\n         BALR  RRET,RGO                BRANCH TO ROUTINE\n         CH    R15,=H'4'               TEST FOR END OF FILE\n         BE    RDEODAD                 BRANCH IF SO\n         MVC   0(140,RWK2),8(R1)       MOVE KEY AND DATA\n         XC    140(3,RWK2),0(RWK2)     ZERO 'MBB' PART OF ADDRESS\n         MVC   143(5,RWK2),0(R1)       INSERT 'CCHHR' PART OF ADDRESS\n         SPACE\n         L     RRET,RDSEQXT\n         LA    RRET,4(RRET)            INCREMENT FOR NORMAL RETURN\n         BR    RRET\n         SPACE 2\nRDEODAD  L     RRET,RDSEQXT            RETURN AT END OF DATA\n         BR    RRET\n         SPACE 3\nRDSEQXT  DC    F'0'\n         EJECT\n* ROUTINE 'READDIR' IS USED TO READ THE DSCB SPECIFIED BY THE 5-BYTE\n* 'CCHHR' FIELD POINTED TO BY RWK1 INTO THE 140-BYTE BUFFER AT RWK2.\n* THE FULL DISK ADDRESS 'MBBCCHHR' IS INSERTED IN THE 8 BYTES FOLLOW-\n* ING THE 140-BYTE BLOCK.\n         SPACE 2\nREADDIR  ST    RRET,RDDIRXT            SAVE EXIT ADDRESS\n         MVC   OBCCHHR(5),0(RWK1)      GET ADDRESS FROM CALLER\n         SPACE\n         OBTAIN  OBCAMLST              READ SPECIFIED BLOCK\n         SPACE\n         LTR   R15,R15                 TEST RETURN CODE\n         BZ    *+8                     BRANCH IF ZERO\n         BAL   RRET,DISASTER           NO ERROR CONDITIONS TOLERATED\n         L     R1,=A(OBWORK)           ADDRESS WORK AREA\n         MVC   0(140,RWK2),0(R1)       MOVE DSCB TO USER'S AREA\n         XC    140(3,RWK2),0(RWK2)     ZERO 'MBB' PART OF ADDRESS\n         MVC   143(5,RWK2),0(RWK1)     INSERT CCHHR FROM ORIGINAL CALL\n         L     RRET,RDDIRXT\n         BR    RRET                    RETURN TO CALLER\n         SPACE 3\nOBCAMLST CAMLST  SEEK,OBCCHHR,VOLUME,OBWORK\n         SPACE\nOBCCHHR  DC    5X'00'\nRDDIRXT  DC    F'0'\n         EJECT\n************************************\n* COMPUTE DATA SET ALLOCATION SIZE *\n************************************\n         SPACE\n* ENTER HERE TO COMPUTE THE NUMBER OF TRACKS ASSIGNED TO A DATA SET AND\n* PUT THE RESULT IN 'F1TRCNT'.  THE FORMAT 1 DSCB IS ASSUMED\n* TO BE IN AREA 'DS1', AND, IF THE NUMBER OF EXTENTS EXCEEDS 3,\n* THE FORMAT 3 DSCB IS ASSUMED TO BE IN AREA 'DS3'.\n* EACH EXTENT IS FILED IN THE TRACK MAP.\n         SPACE\n         USING DS1,RDS1\n         USING DS3,RDS3\n         SPACE\nF1SPANAL ST    RRET,F1SPAXT            SAVE RETURN ADDRESS\n         SR    RWK4,RWK4\n         ST    RWK4,F1TRCNT            ZERO SIZE RESULT FIELD\n         IC    RWK4,DS1NOEPV           INSERT NUMBER OF EXTENTS\n         LTR   RWK4,RWK4               TEST FOR ZERO EXTENTS\n         BCR   8,RRET                  EXIT IF ZERO\n         SR    RWK2,RWK2               ZERO EXTENT INDEX\n         SR    RWK3,RWK3               TRACK COUNT ACCUMULATOR\n         SPACE\nEXTLOOP  EX    0,EXTLIST(RWK2)         LOAD AN EXTENT ADDRESS IN RWK1\n         BAL   RRET,F13CNVT            GET NUM TRKS IN EXTENT\n         AR    RWK3,R0                 ADD TO TOTAL\n         SPACE\n         MVC   FB+FBCCHH1(8),2(RWK1)   MAKE UP TRACK MAP ENTRY\n         STH   R0,FB+FBNTRKS           SIZE OF EXTENT\n         MVC   FB+FBEXT(1),1(RWK1)     EXTENT NUMBER (-1)\n         MVC   FB+FBTTREL1(4),RELTT1   INSERT REL TRACK LIMITS\n         LA    R0,DS1DSNAM             ADDRESS OF DATA SET NAME\n         ST    R0,FB+FBNAME\n         LA    RWK1,FB\n         BAL   RRET,FILEMAP            FILE IN TRACK MAP\n         SPACE\n         LA    RWK2,4(RWK2)            INDEX TO NEXT EXTENT\n         CH    RWK2,=H'64'             END F3 ? (\"17TH EXTENT\")  WFB SL\n         BL    F1SPCONT                NO, CONTINUE              WFB SL\n         ICM   RDS3,B'1111',DS3CHAIN   CHAIN TO NEXT F3          WFB SL\n         BZ    F1SPDONE                END OF CHAIN, DONE        WFB SL\n         LA    RWK2,EXTLSTF3-EXTLIST   ADJUST TO BEGINNING OF F3 WFB SL\nF1SPCONT EQU   *                                                 WFB SL\n         BCT   RWK4,EXTLOOP            LOOP THROUGH ALL EXTENTS\n         SPACE\nF1SPDONE EQU   *                                                 WFB SL\n         L     RDS3,DS1CHAIN           RESTORE FIRST F3 POINTER  WFB SL\n         ST    RWK3,F1TRCNT            STORE RESULT\n         L     RRET,F1SPAXT            LOAD RETURN ADDRESS\n         BR    RRET\n         SPACE 3\nF1SPAXT  DC    F'0'\nF1TRCNT  DC    F'0'\n         EJECT\n* EXECUTED INSTRUCTIONS TO LOAD EXTENT ADDRESSES:\n         SPACE\nEXTLIST  LA    RWK1,DS1EXT1\n         LA    RWK1,DS1EXT2\n         LA    RWK1,DS1EXT3\nEXTLSTF3 EQU   *                                                 WFB SL\n         LA    RWK1,DS3EXTNT\n         LA    RWK1,DS3EXTNT+10\n         LA    RWK1,DS3EXTNT+20\n         LA    RWK1,DS3EXTNT+30\n         LA    RWK1,DS3ADEXT\n         LA    RWK1,DS3ADEXT+10\n         LA    RWK1,DS3ADEXT+20\n         LA    RWK1,DS3ADEXT+30\n         LA    RWK1,DS3ADEXT+40\n         LA    RWK1,DS3ADEXT+50\n         LA    RWK1,DS3ADEXT+60\n         LA    RWK1,DS3ADEXT+70\n         LA    RWK1,DS3ADEXT+80\n         SPACE\n         DROP  RDS1,RDS3\n         EJECT\n***********************************\n* FORMAT 1 AND 3 EXTENT CONVERTER *\n***********************************\n         SPACE\n* ENTER WITH THE ADDRESS OF A TEN-BYTE EXTENT DISCRIPTION IN RWK1.\n* RETURN WITH RELATIVE TRACK NUMBERS OF FIRST AND LAST TRACKS IN\n* 'TTREL1' AND 'TTREL2', AND NUMBER OF TRACKS IN R0.\n         SPACE 2\nF13CNVT  CLI   0(RWK1),X'00'           TEST IF THIS IS AN ACTIVE EXTENT\n         BCR   8,RRET                  EXIT IF ZERO\n         LA    RWK1,2(RWK1)            ADDR OF STARTING CCHH\n         BAL   RGO,CCHHCNVT            GET REL TRACK\n         STH   R0,RELTT1\n         LA    RWK1,4(RWK1)            ADDR OF ENDING CCHH\n         BAL   RGO,CCHHCNVT            CONVERT TO TTREL\n         STH   R0,RELTT2\n         LH    R1,RELTT1\n         SR    R0,R1                   COMPUTE NUMBER OF TRACKS\n         AH    R0,=H'1'\n         S     RWK1,=F'6'              RESTORE RWK1 TO CALLER'S VALUE\n         BR    RRET                    RETURN TO CALLER\n         SPACE\n* CONVERT ADDRESS FROM 'CCHH' TO RELATIVE TRACK NUMBER.\n         SPACE\nCCHHCNVT SR    R0,R0                   RESULT WILL BE IN R0\n         IC    R0,0(RWK1)              BYTE C1\n         MH    R0,FC1\n         SR    R1,R1\n         IC    R1,1(RWK1)\n         MH    R1,FC2\n         AR    R0,R1\n         SR    R1,R1\n         IC    R1,2(RWK1)\n         MH    R1,FH1\n         AR    R0,R1\n         SR    R1,R1\n         IC    R1,3(RWK1)\n         MH    R1,FH2\n         AR    R0,R1\n         BR    RGO\n         SPACE 2\n*THESE MUST BE TOGETHER IN THE ORDER SHOWN:\n         SPACE\nRELTT1   DC    H'0'\nRELTT2   DC    H'0'\n         EJECT\n***************************\n* FORMAT 5 SPACE ANALYSIS *\n***************************\n         SPACE\n* ROUTINE TO ANALYZE THE FREE SPACE EXTENTS DESCRIBED IN A FORMAT 5\n* DSCB.  ENTER WITH 'RDS5' SET TO A DSCB.  COMPUTE THE NUMBER OF FREE\n* TRACKS, FREE CYLINDERS, AND EXTENTS.  FILE AN ENTRY IN THE TRACK MAP\n* FOR EACH EXTENT.\n         SPACE 2\n         USING DS5,RDS5\nF5SPANAL ST    RRET,F5SPAXIT           SAVE RETURN ADDRESS\n         SPACE\n         LA    RWK1,DS5AVEXT           ADDR OF 1ST GROUP OF 8 EXTENTS\n         LA    RWK2,8                  COUNTER\nF5SPLUP1 BAL   RRET,F5EXANAL           ANALYZE INDIVIDUAL EXTENT\n         LA    RWK1,5(RWK1)            INDEX TO NEXT ONE\n         BCT   RWK2,F5SPLUP1\n         SPACE\n         LA    RWK1,DS5MAVET           ADDR OF 2ND GROUP OF 18 EXTENTS\n         LA    RWK2,18\nF5SPLUP2 BAL   RRET,F5EXANAL\n         LA    RWK1,5(RWK1)\n         BCT   RWK2,F5SPLUP2\n         SPACE\n         L     RRET,F5SPAXIT\n         BR    RRET\n         DROP  RDS5\n         SPACE 3\n* ANALYZE AN INDIVIDUAL FREE SPACE EXTENT.  IF ALL FIVE BYTES ARE\n* ZERO, NO EXTENT IS DESCRIBED.\n         SPACE\nF5EXANAL ST    RRET,F5EXAXT            SAVE RETURN ADDRESS\n         STM   RWK1,RWK4,F5EXASAV        AND OTHER REGISTERS\n         CLC   0(5,RWK1),=XL5'00'      TEST FOR ACTIVE EXTENT\n         BCR   8,RRET                  EXIT IF ZEROS\n         SPACE\n         LH    R1,F5EXTNTS             COUNT FREE EXTENTS\n         LA    R1,1(R1)\n         STH   R1,F5EXTNTS\n         SPACE\n         MVC   FWORK(4),0(RWK1)        LOAD REGISTERS:\n         LH    RWK2,FWORK                RWK2=RELATIVE ADDR OF 1ST TR\n         LH    RWK3,FWORK+2              RWK3=NUMBER OF FULL CYLS\n         SR    RWK4,RWK4                 RWK4=NUMBER OF ODD TRACKS\n         IC    RWK4,4(RWK1)\n         STH   RWK2,RELTT1             SAVE TT REL OF FIRST TRACK\n         SPACE\n         LH    R0,FREECYLS             COUNT FREE CYLINDERS\n         AR    R0,RWK3\n         STH   R0,FREECYLS\n         SPACE\n         LR    R0,RWK3         COMPUTE EXTENT SIZE (MAY NOT WORK FOR\n         MH    R0,FCYL                   2321 DATA CELL)\n         AR    R0,RWK4\n         STH   R0,FB+FBNTRKS\n         LR    R1,R0                   LOAD SIZE OF THIS EXTENT\n         AH    R1,FREETRKS             COUNT TOTAL FREE TRACKS\n         STH   R1,FREETRKS\n         AR    R0,RWK2                 MAKE TTREL OF LAST TRACK\n         BCTR  R0,0                    DECREMENT BY 1\n         STH   R0,RELTT2\n         SPACE\n         LH    R1,RELTT1               CONVERT TTREL TO CCHH FOR MAP\n         BAL   RRET,TTCNVT\n         MVC   FB+FBCCHH1(4),CCHH\n         LH    R1,RELTT2\n         BAL   RRET,TTCNVT\n         MVC   FB+FBCCHH2(4),CCHH\n         SPACE\n         MVC   FB+FBTTREL1(4),RELTT1   PUT TTREL INTO TRACK MAP\n         MVI   FB+FBEXT,X'FF'          NO EXTENT NUMBER\n         LA    R0,=CL44'   AVAILABLE'  DSNAME FOR AVAILABLE SPACE\n         ST    R0,FB+FBNAME\n         LA    RWK1,FB\n         BAL   RRET,FILEMAP            FILE DATA IN TRACK MAP\n         SPACE\n         LM    RWK1,RWK4,F5EXASAV      RESTORE REGISTERS\n         L     RRET,F5EXAXT\n         BR    RRET\n         SPACE 3\nF5SPAXIT DC    F'0'\nF5EXAXT  DC    F'0'\nF5EXASAV DC    4F'0'\n         EJECT\n*************************\n* CONVERT TTREL TO CCHH *\n*************************\n         SPACE\n* CONVERT RELATIVE TRACK ADDRESS TO ABSOLUTE CCHH FORM.  TTREL IS\n* SUPPLIED IN R1, RESULT IN 'CCHH'.\n         SPACE 2\nTTCNVT   SR    R0,R0                   R0-R1 USED FOR DIVIDE\n         ST    R0,CCHH                 ZERO OUTPUT FIELD\n         LH    RGO,FC1\n         LTR   RGO,RGO                 WATCH FOR DIVIDE BY ZERO\n         BZ    ZFC1\n         DR    R0,RGO\n         STC   R1,CCHH\n         LR    R1,R0\n         SR    R0,R0\nZFC1     LH    RGO,FC2\n         LTR   RGO,RGO\n         BZ    ZFC2\n         DR    R0,RGO\n         STC   R1,CCHH+1\n         LR    R1,R0\n         SR    R0,R0\nZFC2     LH    RGO,FH1\n         LTR   RGO,RGO\n         BZ    ZFH1\n         DR    R0,RGO\n         STC   R1,CCHH+2\n         STC   R0,CCHH+3\n         BR    RRET\nZFH1     STC   R1,CCHH+3\n         BR    RRET\n         SPACE 2\nCCHH     DC    F'0'\n         EJECT\n**************************\n* FILE ITEM IN TRACK MAP *\n**************************\n         SPACE\n* SUBROUTINE USED BY 'F1SPANAL' AND 'F5SPANAL' TO INSERT A SIX-WORD\n* EXTENT DESCRIPTOR BLOCK INTO THE TRACK MAP.  ENTER WITH THE ADDRESS\n* OF THE NEW BLOCK IN 'RWK1'.  THE ROUTINE GETS CORE, MOVES THE BLOCK,\n* AND CHAINS IT IN SEQUENCE WITH OTHER MAP BLOCKS BY ASCENDING ORDER OF\n* LOWER CCHH.\n         SPACE 2\nFILEMAP  ST    RRET,FMEXIT             SAVE EXIT AND WORK REGISTERS\n         STM   RWK2,RWK4,FMSAVE\n         SPACE\n         LA    RWK3,MBSIZE             GET A CORE BLOCK\n         BAL   RRET,GETBLOCK           RETURNS ADDRESS IN RWK2\n         USING MB,RWK2\n         MVC   MB(MBSIZE),0(RWK1)      MOVE NEW BLOCK\n         SPACE\n         L     RWK1,MBBASE             GET CHAIN BEGINNING\n         LA    RWK3,MBBASE             CHAIN HISTORY REG\n         SPACE\nFMSORT   CLC   MBCCHH1(4),FBCCHH1(RWK1)\n         BL    FMTHREAD\n         LR    RWK3,RWK1\n         L     RWK1,FBCHAIN(RWK1)      FOLLOW CHAIN TO NEXT ITEM\n         B     FMSORT\n         SPACE\nFMTHREAD ST    RWK1,MBCHAIN            THREAD FROM NEW TO NEXT\n         ST    RWK2,FBCHAIN(RWK3)      THREAD FROM PRECEDING TO NEW\n         SPACE\n         LM    RWK2,RWK4,FMSAVE        RESTORE REGISTERS\n         L     RRET,FMEXIT\n         BR    RRET\n         DROP  RWK2\n         SPACE 2\nFMSAVE   DC    3F'0'\nFMEXIT   DC    F'0'\nMBBASE   DC    A(*)                    CHAIN BASE ADDRESS\nMBTERM   DC    4X'FF'                  CHAIN END, MUST FOLLOW 'MBBASE'\n         SPACE\nFB       DS    0F                      WORK BLOCK USED BY F1SPANAL\n         DS    24X                       AND F5SPANAL TO ASSEMBLE BLKS\n         EJECT\n***************************\n* BINARY TO ALPHA ROUTINE *\n***************************\n         SPACE\n* ROUTINE TO CONVERT A BINARY NUMBER TO DECIMAL AND EDIT INTO THREE\n* ALPHA FORMATS.  ENTER WITH REGISTER 'RWK1' SET TO THE FIRST BYTE OF\n* THE BINARY FIELD AND THE NUMBER OF BYTES (UP TO FOUR) IN REGISTER\n* 'RWK2'.  THE ALPHA OUTPUT IS IN THREE 12-BYTE FIELDS:\n*        'BTAALF' IS RIGHT-ALIGNED WITH LEADING ZEROS BLANKED;\n*        'BTAALFZ' IS RIGHT-ALIGNED WITH LEADING ZEROS;\n*        'BTAALFJ' IS LEFT-ALIGNED WITH TRAILING BLANKS ADDED.\n* RETURN TO CALLER IS VIA REGISTER 'RRET'.  REGISTER 'R0' IS USED AND\n* IS NOT RESTORED.\n         SPACE\n* THE ALTERNATE ENTRANCE 'BINALFR' MAY BE USED WHEN THE ARGUMENT IS\n* ALREADY IN REGISTER 'R0'.\n         SPACE 2\nBINALF1  LA    RWK2,1                  ENTRANCE FOR 1-BYTE ARG\n         B     BTA\nBINALF2  LA    RWK2,2                  ENTRANCE FOR 2-BYTE ARG\n         B     BTA\nBINALF3  LA    RWK2,3                  ENTRANCE FOR 3-BYTE ARG\n         SPACE\nBTA      SR    R0,R0                   CLEAR ACCUMULATOR\nBTALUP1  SLL   R0,8                    MOVE OVER FOR NEXT BYTE\n         IC    R0,0(RWK1)              GET NEXT BYTE OF ARGUMENT\n         LA    RWK1,1(RWK1)            INCREMENT ADDR OF ARGUMENT\n         BCT   RWK2,BTALUP1            LOOP TO EXTRACT ALL BYTES\n         SPACE\nBINALFR  LPR   R0,R0                   TAKE ABSOLUTE VALUE\n         CVD   R0,BTADWD               CONVERT ARG TO PACKED DECIMAL\n         UNPK  BTAALFZ(12),BTADWD(8)   UNPACK VERSION WITH ZEROS\n         OI    BTAALFZ+11,X'F0'        COVER UP SIGN\n         SPACE\n         MVC   BTAALF(12),BTAPTRN      INSERT EDIT CONTROL CHAR\n         ED    BTAALF(12),BTADWD+2     EDIT ZERO-SUPPRESSED VERSION\n         SPACE\n         MVC   BTAALFJ(11),BTAALF+1    NOTE: BTAALFJ+11 PERMANENT BLANK\nBTALUP2  CLI   BTAALFJ,C' '            CHECK FOR LEADING BLANK\n         BCR   7,RRET                  EXIT IF NOT BLANK, IE, DIGIT\n         MVC   BTAALFJ(11),BTAALFJ+1   SHIFT ONE LEFT\n         B     BTALUP2                 CONTINUE\n         SPACE 3\nBTADWD   DC    D'0'\nBTAPTRN  DC    XL12'402020202020202020202120'     EDIT CONTROL CHARS\nBTAALF   DC    CL12' '\nBTAALFJ  DC    CL12' '\nBTAALFZ  DC    CL12' '\n         EJECT\n*********************\n* VTOC DATE EDITING *\n*********************\n         SPACE\n* SUBROUTINE TO CONVERT FROM THE BINARY FORM 'YDD' IN A DSCB INTO THE\n* CIVILIZED ALPHA FORM 'MM/DD/YY'.  ENTER WITH ADDRESS OF 3-BYTE\n* BINARY ARGUMENT IN RWK1 AND ADDRESS OF 8-BYTE ALPHA RECEIVER IN RWK2.\n         SPACE 2\nVTDATED  ST    RRET,VTDXIT\n         SR    R0,R0\n         IC    R0,0(RWK1)              BINARY YEAR\n         MH    R0,=H'1000'             TIMES 1000\n         MVC   DECDATE(2),1(RWK1)      ALIGN DAY ON HALF-WORD\n         AH    R0,DECDATE              ADD BINARY DAY\n         CVD   R0,DECDATE              CONVERT TO PACKED DECIMAL\n         SPACE\n         LA    R1,DECDATAD             LOAD ADDR OF ARGUMENT ADDRESS\n         L     RGO,VDATEDIT            LOAD SUBROUTINE ADDRESS\n         BALR  RRET,RGO                CALL XDATEDIT ROUTINE\n         SPACE\n         MVC   0(8,RWK2),DECDATE       DELIVER RESULT\n         L     RRET,VTDXIT\n         BR    RRET\n         SPACE 3\nVTDXIT   DC    F'0'\n         EJECT\n*************************\n* DSCB HEX DUMP ROUTINE *\n*************************\n         SPACE\n* THIS SUBROUTINE EDITS A DSCB IN HEX IN THREE LINES.  ENTER WITH THE\n* ADDRESS OF THE DSCB IN RWK1 AND THE ADDRESS OF ITS DISK ADDRESS\n* (MBBCCHHR) IN RWK2.  CHECKS TO BE SURE ALL THREE LINES WILL BE ON\n* THE SAME PAGE.\n         SPACE 2\nDUMPDSCB ST    RRET,DUMPEXIT           SAVE RETURN\n         LR    RWK3,RWK1               TEMP SAVE RWK1\n         LA    RWK1,3                  TO TEST PAGE BALANCE\n         BAL   RRET,PAGECHEK\n         LR    RWK1,RWK3\n         SPACE\n         MVC   PL+8(17),=C'BLK 1234.5678.90:'\n         UNPK  HEXWORK(15),3(8,RWK2)   EDIT DISK ADDRESS OF BLOCK\n         TR    HEXWORK(15),HEXEDTAB\n         MVC   PL+12(4),HEXWORK\n         MVC   PL+17(4),HEXWORK+4\n         MVC   PL+22(2),HEXWORK+8\n         LA    RWK2,0(RWK1)\n         LA    RWK3,PL+35\n         LA    RWK4,44\n         BAL   RRET,DUMPEDIT           EDIT HEX CHARS OF KEY\n         MVI   PL,PRSP1                PRINT AND SPACE 1\n         BAL   RRET,PRINTSUB\n         SPACE\n         MVC   PL+8(13),=C'FORMAT N DSCB'\n         MVC   PL+15(1),44(RWK1)       DSCB TYPE NUMBER\n         OI    PL+15,X'F0'             FOR TYPE 0, IF EVER USED\n         LA    RWK2,44(RWK1)\n         LA    RWK3,PL+26\n         LA    RWK4,48\n         BAL   RRET,DUMPEDIT\n         MVI   PL,PRSP1\n         BAL   RRET,PRINTSUB\n         SPACE\n         LA    RWK2,92(RWK1)\n         LA    RWK3,PL+26\n         LA    RWK4,48\n         BAL   RRET,DUMPEDIT\n         MVI   PL,PRSP2                SPACE 2 ON LAST LINE\n         BAL   RRET,PRINTSUB\n         SPACE\n         L     RRET,DUMPEXIT\n         BR    RRET\n         SPACE\nDUMPEXIT DC    F'0'\n         EJECT\n* HEX DUMP EDIT SUBROUTINE\n         SPACE\n* ROUTINE TO EDIT INTO HEX IN 4-BYTE GROUPS.  'RWK2' IS THE SOURCE\n* ADDRESS, 'RWK3' IS THE RECEIVER ADDRESS, AND 'RWK4' CONTAINS THE\n* NUMBER OF BYTES TO EDIT.\n         SPACE 2\nDUMPEDIT LTR   RWK4,RWK4               TEST FOR ZERO BYTES\n         BCR   13,RRET                 EXIT IF ZERO\n         B     DUMPJOIN\n         SPACE\nDUMPLOOP BCT   R1,DUMPMOVE             TEST FOR 4TH BYTE\n         MVI   0(RWK3),C' '            INSERT BLANK EVERY 4 BYTES\n         LA    RWK3,1(RWK3)            INCREMENT RECEIVER ADDRESS\nDUMPJOIN LA    R1,4                    BEGIN NEW 4-BYTE GROUP\n         SPACE\nDUMPMOVE UNPK  HEXWORK(3),0(2,RWK2)    EDIT ONE BYTE INTO ALPHA\n         TR    HEXWORK(2),HEXEDTAB\n         MVC   0(2,RWK3),HEXWORK\n         LA    RWK2,1(RWK2)            INCREMENT SOURCE ADDR\n         LA    RWK3,2(RWK3)            INCREMENT RECEIVER ADDR\n         BCT   RWK4,DUMPLOOP           COUNT NUMBER OF BYTES EDITED\n         BR    RRET\n         EJECT\n*************************\n* FIELD SCAN SUBROUTINE *\n*************************\n         SPACE\n* SUBROUTINE TO READ A WORD FROM A CHARACTER STRING.  ENTER WITH 'RWK1'\n* SET TO THE BEGINNING OF THE STRING AND 'RWK2' CONTAINING THE LENGTH\n* OF THE STRING.  RETURNS WITH THE WORD IN 8 BYTES AT 'SCANWORD' AND\n* UPDATES 'RWK1' AND 'RWK2' TO GET NEXT WORD IN NEXT CALL.\n         SPACE 2\nSCAN     DS    0H\n         MVC   SCANWORD(8),=8C' '      BLANK OUTPUT FIELD\n         LA    RWK3,SCANWORD\n         SPACE\nSCLOOP   LTR   RWK2,RWK2               TEST FOR END OF INPUT STRING\n         BCR   13,RRET                 EXIT WHEN REACHED\n         CLI   0(RWK1),C' '            BLANKS ARE IGNORED\n         BE    SCANEXT\n         CLI   0(RWK1),C','            TEST FOR COMMA (WORD SEPARATOR)\n         BE    SCANDONE\n         SPACE\n         C     RWK3,=A(SCANWORD+8)     TEST FOR MAX OUTPUT LENGTH\n         BNL   SCANEXT                 SKIP DELIVERY IF OVER 8\n         MVC   0(1,RWK3),0(RWK1)       DELIVER CHAR TO OUTPUT WORD\n         LA    RWK3,1(RWK3)            INCR OUTPUT INDEX\nSCANEXT  LA    RWK1,1(RWK1)            INCR TO NEXT INPUT CHAR, AND\n         BCTR  RWK2,0                    DECREMENT COUNT\n         B     SCLOOP\n         SPACE\nSCANDONE LA    RWK1,1(RWK1)            INCR PAST SEPARATOR AND EXIT\n         BCTR  RWK2,0\n         BR    RRET\n         SPACE 2\nSCANWORD DC    CL8' '\n         EJECT\n************************\n* CORE BLOCK ALLOCATOR *\n************************\n         SPACE\n* THIS ROUTINE IS ENTERED WITH THE SIZE OF A DESIRED BLOCK OF CORE IN\n* 'RWK3'.  IT RETURNS WITH THE ADDRESS OF AN AVAILABLE AREA IN 'RWK2'.\n* THE BLOCK WILL BE ALIGNED ON A FULL-WORD BOUNDARY.\n         SPACE\n* THESE SMALL BLOCKS ARE ALLOCATED FROM LARGE BLOCKS OBTAINED FROM THE\n* SUPERVISOR VIA 'GETMAIN' CALLS.  THE FIRST WORD OF EACH LARGE BLOCK\n* POINTS TO THE NEXT ONE, EXCEPT FOR THE LAST, WHICH CONTAINS A ZERO\n* WORD.  THIS CHAIN IS USED BY THE 'GBRESET' ROUTINE TO RELEASE THE\n* CORE.\n         SPACE 2\nGETBLOCK A     RWK3,=F'3'              ROUND SIZE TO NEXT WORD\n         N     RWK3,ROUND4             'ROUND4 IS X'FFFFFFFC'\nGBJOIN   L     R0,GBBAL                LOAD CURRENT BALANCE\n         SR    R0,RWK3                 SUBTRACT SIZE DESIRED\n         BM    NEWBLOCK                BRANCH IF NOT ENOUGH\n         ST    R0,GBBAL                SAVE NEW BALANCE\n         L     RWK2,GBCLC              LOAD ADDRESS OF BLOCK\n         LR    R0,RWK2\n         AR    R0,RWK3                 UPDATE ADDRESS OF AVAILABLE AREA\n         ST    R0,GBCLC\n         BR    RRET\n         SPACE\n* GET A NEW BLOCK AND CHAIN.\n         SPACE\nNEWBLOCK GETMAIN  EC,LV=GETSIZE,A=GBNEWBL  CONDITIONAL REQUEST FOR CORE\n         LTR   R15,R15                 DID WE GET IT?\n         BNZ   GMFAIL                  NO, BRANCH\n         L     R1,GBNEWBL              LOAD ADDRESS OF GOTTEN CORE\n         L     RWK2,GBBASE             BASE OF CURRENT BLOCK\n         ST    R1,0(RWK2)              CHAIN TO NEW BLOCK\n         ST    R1,GBBASE               UPDATE BASE CELL\n         SR    R0,R0\n         ST    R0,0(R1)                ZERO CHAIN IN NEW BLOCK\n         LA    R1,4(R1)                SET TO FIRST AVAILABLE BYTE\n         ST    R1,GBCLC\n         MVC   GBBAL(4),NEWBAL         RESET BALANCE COUNTER\n         B     GBJOIN\n         EJECT\n* RESET ROUTINE TO RELEASE ALL CORE AND RESET POINTERS.\n         SPACE\nGBRESET  L     RWK1,GBFIRST            ADDR OF FIRST BLOCK OF CORE\nGBR1     LTR   RWK1,RWK1               TEST FOR END OF CHAIN\n         BZ    GBR2                    BRANCH IF RELEASING DONE\n         LR    R1,RWK1                 ADDR OF BLOCK TO RELEASE\n         L     RWK1,0(RWK1)            FOLLOW CHAIN TO NEXT BLOCK\n         LA    R0,GETSIZE              SIZE OF BLOCK\n         SPACE\n         FREEMAIN  R,LV=(0),A=(1)\n         SPACE\n         B     GBR1\n         SPACE\nGBR2     SR    R0,R0\n         ST    R0,GBBAL                SET ZERO BALANCE\n         ST    R0,GBFIRST              SET ZERO INITIAL BLOCK ADDRESS\n         LA    R0,GBFIRST\n         ST    R0,GBBASE               POINT BASE BACK TO INITIAL CELL\n         BR    RRET\n         SPACE 2\n* RAN OUT OF CORE.  PRINT MESSAGE AND GO DIRECTLY TO END VOLUME ROUTINE\n         SPACE\nGMFAIL   XPRNTLIN  PWA,TEXT=GMFMSG,LENGTH=L'GMFMSG,SPB=1,SPA=1\n         WTO '*** NEED MORE CORE TO RUN VTOCLIST PGM ***'      GTEL\n         WTO    '*** RERUN THE JOB AFTER YOU(OPERATOR)'        GTEL\n         WTOR '*** INCREASE THE REGION PARM ON THE STEP OR JOB CARD *',X\n               REPLY,1,ECB,ROUTCDE=(1,11)                      GTEL\n         WAIT ECB=ECB                                          GTEL\n         WTO  'THANK YOU'                                      GTEL\n         B     ENDVOL\n         SPACE 3\nREPLY    DC    CL1' '                                          GTEL\nECB      DC    F'0'                                            GTEL\nGBNEWBL  DC    F'0'\nGBBAL    DC    F'0'\nGBCLC    DC    A(0)\nGBBASE   DC    A(GBFIRST)\nGBFIRST  DC    A(0)\nNEWBAL   DC    A(GETSIZE-4)\n         EJECT\n********************\n* PRINTING ROUTINE *\n********************\n         SPACE\n* ROUTINE TO INTERFACE WITH THE PRINTING ROUTINE.  CALL WITH TEXT IN\n* 133-BYTE LINE 'PL'.  FIRST BYTE CONTAINS DESIRED SPACING AFTER\n* PRINTING.  'PL' IS BLANKED AFTER PRINTING.\n         SPACE\nPRINTSUB ST    RRET,PRSEXIT            SAVE RETURN ADDRESS\n         IC    R0,PL                   PICK UP SPACING AMOUNT\n         SPACE\n         XPRNTLIN  PWA,TEXT=PL+1,LENGTH=132,SPA=((R0))\n         SPACE\n         MVI   PL+1,C' '               BLANK PRINT LINE\n         MVC   PL+2(131),PL+1\n         L     RRET,PRSEXIT            LOAD RETURN ADDRESS\n         BR    RRET                    RETURN TO CALLER\n         SPACE\n* PAGE BALANCE TEST ROUTINE.  SKIP TO HEAD-OF-FORM IF REMAINING LINES\n* ON PAGE ARE LESS THAN THE NUMBER IN 'RWK1'.\n         SPACE\nPAGECHEK ST    RRET,PRSEXIT            SAVE RETURN ADDRESS\n         XPREJECT  PWA,COND=(LT,(RWK1))\n         L     RRET,PRSEXIT            RESTORE EXIT ADDRESS\n         BR    RRET                    RETURN TO CALLER\n         SPACE\nPRSEXIT  DS    F\n         EJECT\n*****************\n* PAGE HEADINGS *\n*****************\n         SPACE\nINITHEAD XPRLDEF  TEXT=IHTXT,LENGTH=L'IHTXT,SPB=(TOPMARGN,ATHOF),SPA=3\n         SPACE\nIHTXT    DC    C'VTOCLIST -- DIRECT-ACCESS VOLUME DIRECTORY LISTER'\n         SPACE 3\nF1HD2    XPRLDEF  TEXT=F1HTXT,LENGTH=LF1HTXT,SPB=(TOPMARGN,ATHOF),SPA=2\n         SPACE\nF1HD3    XPRLDEF  TEXT=F1HTXT,LENGTH=LF1HTXT,SPB=(TOPMARGN,ATHOF),SPA=3\n         SPACE\nF1HTXT   DC    CL20' '\nF1HSER1  EQU   F1HTXT\n         DC    C'TABLE OF CONTENTS FOR VOLUME SERIAL='\nF1HSER2  DC    CL6' '\nLF1HTXT  EQU   *-F1HTXT\n         SPACE 3\nF1SA     XPRLDEF  TEXT=F1SUBA,LENGTH=LF1SUBA,SPA=0,OFFSET=19\n         SPACE\nF1SUBA   DS    0C\n         DC    C'DSNAME'\n         DC    19C' '\n         DC    C' LASTUSE  USE-CT   CREDT    EXPDT    '\n         DC    C'DSO RECFM BLKSZ LRECL KEY OP '\n         DC    C'TRKAL TRKUS EX SECQU T'\nLF1SUBA  EQU   *-F1SUBA\n         SPACE 3\nF1SB     XPRLDEF  TEXT=F1SUBB,LENGTH=LF1SUBB,SPA=2\n         SPACE\nF1SUBB   DS    0C\n         DC    44C'_'\n         DC    C' ________ ______ ________ ________ '\n         DC    C'  ___ _____ _____ _____ ___ __'\n         DC    C' _____ _____ __ _____ _'\nLF1SUBB  EQU   *-F1SUBB\n         SPACE\n* PAGE SUB-HEADING LINES FOR TRACK MAP EDITING\n         SPACE\nTMHEAD   XPRLDEF  TEXT=TMHTXT,LENGTH=LTMHTXT,SPB=(TOPMARGN,ATHOF),SPA=2\n         SPACE\n         SPACE\nTMHTXT   DC    CL20' '\nTMHSER1  EQU   TMHTXT\n         DC    C'TRACK ALLOCATION MAP FOR VOLUME SERIAL='\nTMHSER2  DC    CL6' '\nLTMHTXT  EQU   *-TMHTXT\n         SPACE 3\nTMSA     XPRLDEF  TEXT=TMSUBA,LENGTH=LTMSUBA,OFFSET=27,SPA=0\n         SPACE\nTMSUBA   DS    0C\n         DC    C'CYLS.TRKS  CYLS.TRKS'                         GTEL\n         DC    3C' '                                           GTEL\n         DC    C'FIRST TRK   LAST TRK  #TRKS  EXT  DSNAME OR USAGE'\nLTMSUBA  EQU   *-TMSUBA\n         SPACE 2\nTMSB     XPRLDEF  TEXT=TMSUBB,LENGTH=LTMSUBB,OFFSET=27,SPA=2\n         SPACE\nTMSUBB   DS    0C\n         DC    9X'6D',2C' ',9X'6D'                             GTEL\n         DC    3C' '                                           GTEL\n         DC    C'_________  _________  _____  ___  '\n         DC    44C'_'\nLTMSUBB  EQU   *-TMSUBB\n         SPACE   2\n* PRINT LINE FIELD DEFINITIONS\n         SPACE 2\nPL       DC    CL133' '\n         SPACE 3\n* PRINT LINES FOR VOLUME DESCRIPTION:\n         SPACE\nV1       EQU   PL\nV1TYPE   EQU   V1+22\nV1NOCYL  EQU   V1+45\nV1TRCYL  EQU   V1+57\nV1DEVTK  EQU   V1+73\nV1DEVDT  EQU   V1+88\nV1DEVDB  EQU   V1+102\n         SPACE\nV2       EQU   PL\nV2DSCBCT EQU   V2+20\nV2DSCBAV EQU   V2+37\nV2VTEXT  EQU   V2+55\nV2NUMALT EQU   V2+88\nV2NXTALT EQU   V2+102\n         SPACE\nV3       EQU   PL\nV3FRTRKS EQU   PL+18\nV3FREXTS EQU   PL+34\nV3FRCYLS EQU   PL+58\n         EJECT\n* PRINT LINES FOR FORMAT 1 DSCB DESCRIPTION:\n         SPACE\nF1A      EQU   PL\nF1DSNAM  EQU   F1A+1\nF1DSSN   EQU   F1A+46\nF1VOLSQ  EQU   F1A+2+53\nF1CREDT  EQU   F1A+1+2+59\nF1EXPDT  EQU   F1A+1+2+68\nF1DSORG EQU    F1A+4+78\nF1RECFM  EQU   F1A+3+2+82\nF1BLKL   EQU   F1A+3+1+88\nF1LRECL  EQU   F1A+3+1+94\nF1KEYL   EQU   F1A+3+1+100\nF1OPTCD  EQU   F1A+3+1+104\nF1TRALOC EQU   F1A+3+108\nF1TRUSE  EQU   F1A+3+114\nF1NOEPV  EQU   F1A+3+120\nF1SCALO  EQU   F1A+3+123\nF1ALCTYP  EQU   F1A+3+129\n         SPACE\n* PRINT LINES FOR TRACK MAP EDITING:\n         SPACE\nTM1      EQU   PL\nTMERROR  EQU   TM1+26\nTMDECCH1 EQU   TM1+28                                          GTEL\nTMDECCH2 EQU   TM1+39                                          GTEL\nTMCCHH1  EQU   TM1+48+3                                        GTEL\nTMCCHH2  EQU   TM1+60+2                                        GTEL\nTMEXTSIZ EQU   TM1+71+2                                        GTEL\nTMEXTNO  EQU   TM1+78+3                                        GTEL\nTMDSNAM  EQU   TM1+83+3                                        GTEL\n         SPACE\n* PRINT LINES FOR PDS DIRECTORY LISTING:\n         SPACE\nPDS1     EQU   PL\nPDSMEMB  EQU   PDS1+12\nPDSALIAS EQU   PDS1+21\nPDSTTR   EQU   PDS1+23\nPDSNTT   EQU   PDS1+32\nPDSHEX   EQU   PDS1+35\n         EJECT\n* EXODUS\n         SPACE\n* WHEN ALL VOLUMES ARE COMPLETED, COME HERE TO CLOSE THE PRINTER,\n* TIDY UP LOOSE ENDS, AND RETURN.\n         SPACE 2\nEXODUS   DS    0H\n         SPACE\n         XPRCLOSE  PWA\n         SPACE\n         L     RSAVE,SAVEAREA+4\n         L     RGO,RETCODE             INSERT RETURN CODE IN REG 15\n         RETURN  (14,12),T,RC=(15)\n         SPACE 6\n* DISASTER ROUTINE\n         SPACE\n* COME HERE TO ABEND FOR CONDITIONS WHICH WERE NOT SUPPOSED TO HAPPEN,\n* OR ERRORS FOR WHICH NO SPECIAL ROUTINE ARE WRITTEN.\n         SPACE 2\nDISASTER ABEND 100,DUMP\n         EJECT\n* PDS DIRECTORY DATA CONTROL BLOCK\n         SPACE 2\nPDSDCB   DCB   DSORG=PS,                                               X\n               MACRF=R,                                                X\n               DDNAME=VOLUME01,                                        X\n               DEVD=DA,                                                X\n               RECFM=F,                                                X\n               KEYLEN=8,                                               X\n               BLKSIZE=256,                                            X\n               EODAD=PDSEODAD,                                         X\n               SYNAD=PDSSYNAD,                                         X\n               EXLST=JFCBADR\n         SPACE 6\n* DCB EXIT LIST:\n         SPACE\nJFCBADR  DS    0F\n         DC    X'87'\n         DC    AL3(JFCB)\n         EJECT\n* PRINT SUBROUTINE DATA CONTROL BLOCK AND WORK AREA:\n         SPACE 2\n* UNABLE TO OPEN SYSPRINT - TYPE ERROR MESSAGE AND EXIT.\n         SPACE\nPROPBAD  DS    0H\n         MVC   PROPMSGJ(8),JOBNAME     INSERT JOB NAME IN MESSAGE\n         WTO   MF=(E,PROPMSG)          TYPE COMPLAINT ON CONSOLE\n         MVI   RETCODE+3,20            SET RETURN CODE TO 20\n         B     EXODUS                  EXIT\n         SPACE\nPROPMSG  DS    0F\n         DC    AL2(PROPMSGL,0)         FORMAT V CONTROL FIELD\n         DC    C'JOB '\nPROPMSGJ DC    C'12345678 -- VTOCLIST UNABLE TO OPEN SYSPRINT'\nPROPMSGL EQU   *-PROPMSG\n         SPACE 2\nPWA      XPRDCB  DDNAME=SYSPRINT\n         EJECT\n* MISCELLANEOUS CONSTANTS AND WORK CELLS:\n         SPACE 2\nDECDATE  DC    D'0'\n         SPACE\nDECTIME  DC    F'0'\nDEVCHAR  DC    6F'0'\nUNITTYPE EQU   DEVCHAR+3\nFMT1ADDR DC    F'0'\nFMT4ADDR DC    F'0'\nFMT5ADDR DC    F'0'\nFWORK    DC    F'0'\nRETCODE  DC    F'0'\nROUND4   DC    X'FFFFFFFC'\nSAVEAREA DC    18F'0'\nTIOTLOC  DC    A(0)\nVTOCREAD DC    V(XVTCREAD)\nDECDATAD DC    A(DECDATE)\nVDATEDIT DC    V(XDATEDIT)\n         SPACE\nDSCOUNT  DC    H'0'\nFREECYLS DC    H'0'\nFREETRKS DC    H'0'\nF5EXTNTS DC    H'0'\nHWORK    DC    H'0'\nVTOCSIZE DC    H'0'\n         SPACE\nDDNAME   DC    CL8'VOLUME00'\nJOBNAME  DS    CL8\nVOLUME   DS    CL6\nHEXWORK  DC    CL16' '\nLASTFMT1 DC    44X'FF'\nMODESW   DC    X'00'\nPARMSW   DC    X'00'\nDS3POINT DS    XL5                     SAVE POINTER TO NEXT F3   WFB SL\n         SPACE\n         DC    CL16'0123456789ABCDEF'\nHEXEDTAB EQU   *-256\n         SPACE\n* DUMMY TRACK MAP ENTRY FOR VOLUME LABEL ON TRACK 0:\n         SPACE\nTRK0MAP  DC    2F'0'\n         DC    H'1'\n         DC    XL2'FF00'\n         DC    A(TRK0NAME)\n         DC    F'0'\n         EJECT\n* TABLE OF DEVICE SIZE CONSTANTS, FILLED IN FROM DEVICE NAME TABLE WHEN\n* DEVICE TYPE IS DETERMINED.  THE FOUR CONSTANTS FC1, FC2, FH1, AND FH2\n* ARE SCALING FACTORS TO BE APPLIED TO A FULL DIRECT-ACCESS ADDRESS OF\n* THE FORM 'CCHH'.  EACH CONSTANT IS THE NUMBER OF TRACKS REPRESENTED\n* BY ONE UNIT OF THE CORRESPONDING ADDRESS BYTE.  'FMAXTT' IS THE\n* MAXIMUM RELATIVE TRACK ADDRESS FOR THE DEVICE, AND 'FCYL' IS THE\n* NUMBER OF TRACKS PER CYLINDER, AS APPLIED TO THE CYLINDER COUNT IN A\n* FORMAT 5 EXTENT ENTRY.  'DEVNAMAD' IS THE ADDRESS OF THE DEVICE NAME\n* IN THE DEVICE NAME TABLE.\n         SPACE\nDEVNAMAD DC    A(0)\nFC1      DC    H'0'               T/C BYTE 1 OF CCHH\nFC2      DC    H'0'               T/C BYTE 2 OF CCHH\nFH1      DC    H'0'\nFH2      DC    H'0'\nFCYL     DC    H'0'               NUMBER OF TRACKS PER CYLINDER\nFMAXTT   DC    H'0'               MAXIMUM RELATIVE TRACK ADDRESS\n         SPACE 2\n* DEVICE NAME TABLE, TO PROVIDE SPECIFIC INFORMATION FOR EACH DEVICE.\n* THE ORDER OF THE HALF-WORD CONSTANTS MUST CORRESPOND TO \"FC1...\"\n* ABOVE.\n         SPACE\nDEVNAMES DS    0H\n         DC    AL1(DEV2301)\n         DC    CL15'2301 DRUM'\n         DC    H'0,0,0,1,8,200'   SHOULD BE 0,8,0,1,8,200  ?\nDEVNAMSZ EQU   *-DEVNAMES\n         SPACE\n         DC    AL1(DEV2302)\n         DC    CL15'2302 DISK FILE'\n         DC    H'0,46,0,1,46,10416'    CHANGED FROM 11500\n         SPACE\n         DC    AL1(DEV2303)\n         DC    CL15'2303 DRUM'\n         DC    H'0,10,0,1,10,800'\n         SPACE\n         DC    AL1(DEV23051)\n         DC    CL15'2305-1 DRUM'\n         DC    H'0,8,0,1,8,384'\n         SPACE\n         DC    AL1(DEV23052)\n         DC    CL15'2305-2 DRUM'\n         DC    H'0,8,0,1,8,768'\n         SPACE\n         DC    AL1(DEV2311)\n         DC    CL15'2311 DISK PACK'\n         DC    H'0,10,0,1,10,2000'\n         SPACE\n         DC    AL1(DEV2314)\n         DC    CL15'2314 DISK PACK'\n         DC    H'0,20,0,1,20,4000'\n         SPACE\n         DC    AL1(DEV2321)\n         DC    CL15'2321 DATA CELL'\n         DC    H'1000,100,20,1,20,19600'\n         SPACE\n         DC    AL1(DEV3330)\n         DC    CL15'3330 DISK PACK'\n         DC    H'4864,19,0,1,19,7676'\n*                                        NEXT 3 STATEMENTS MADE BY GTEL\n         DC    AL1(DEV33301)\n         DC    CL15'3330 MOD-11 DSK'\n         DC    H'4864,19,0,1,19,15352'\n         SPACE\n         DC    AL1(DEV3350)\n         DC    CL15'3350  DSK'\n         DC    H'7680,30,0,1,30,16650'\n         SPACE\n         DC    AL1(DEV3375)\n         DC    CL15'3375  DSK'\n         DC    H'3072,12,0,1,12,11508'\n         SPACE\n         DC    AL1(DEV3380)                                      WFB SN\n         DC    CL15'3380  DSK'                                   WFB SN\n         DC    H'3840,15,0,1,15,26550'                           WFB SN\n         SPACE\nDEVNAMOB DC    X'00'                   OBJECT FOR LOOKUP\nUNKNOWN  DC    C'UNKNOWN'\nDEV3380E DC    CL15'3380-E  DSK'                                 WFB SN\nFM3380E  DC    H'13275'                                          WFB SN\n         SPACE 4\n* LITERALS\n         SPACE 2\n         LTORG\n         SPACE 2\n         DROP  RBASE1,RBASE2\n         EJECT\n* WORK AREAS WHICH ARE NOT COVERED BY BASE REGISTERS:\n         SPACE\n*         ORG   VTOCLLIST+8192   KEEP US HONEST ABOUT BASE REG   GTEL\n         SPACE 2\n* BUFFER FOR JOB FILE CONTROL BLOCK:\n         SPACE\n         DS    0D\nJFCB     DS    CL176\n         SPACE 2\n* PDS DIRECTORY BLOCK BUFFER:\n         SPACE\nPDSBUF   DS    1D              KEY\nPDSLRECL DS    1H              LOGICAL RECORD LENGTH\nPDSDATA  DS    CL254           DATA\n         SPACE 2\n* WORK AREA FOR 'OBTAIN' MACRO:\n         SPACE\n         ORG   PDSBUF                  OVERLAPS PDS DIRECTORY BUFFER\nOBWORK   DS    0D                      'OBTAIN' WORK AREA\n         DS    350C\n         SPACE 2\n* MISCELLANEOUS.\n         SPACE\nHOLDJA   DC    D'00'                                           GTEL\nTRK0NAME DC    CL44'VOLUME LABEL'\nVTOCNAME DC    CL44'VOLUME TABLE OF CONTENTS'\n*REVMSG  DC    C'GTEL VERSION 7,  MAY 1981'                    JBSIX\n*REVMSG  DC    C'WFB VERSION 8,  JULY 1984'                      WFB SL\nREVMSG   DC    C'WFB VERSION 9,  JULY 1986'                      WFB SN\nPARMMSG  DC    C' PARM OPTIONS: MAP,PDS,DUMP,(DDNAME)'         GTEL\nDS5WARN  DC    C'*******WARNING--DOS FLAG IS ON; FORMAT 5 DSCB''S MAY NX\n               OT REFLECT TRUE STATUS OF AVAILABLE TRACKS'\nGMFMSG   DC    C'*******INSUFFICIENT CORE TO HOLD ENTIRE VTOC; GOING ONX\n                TO NEXT VOLUME'\nIXVINUSE DC    C'******* NOTE ---INDEXED VTOC IN USE.'          JBSIX\n TITLE 'DIRECT-ACCESS DIRECTORY LISTER                  DUMMY SECTIONS'\n* DUMMY SECTION TO DEFINE TRACK MAP ENTRY\n         SPACE 2\n*              *************************\n*              *                       *\n*            0 * ADDRESS OF NEXT ENTRY *\n*              *                       *\n*              *************************\n*              *                       *\n*            4 *        CC HH 1        *\n*              *                       *\n*              *************************\n*              *                       *\n*            8 *        CC HH 2        *\n*              *                       *\n*              *************************\n*              *           *     *     *\n*           12 * NUMB TRKS * EXT * NU  *\n*              *           *     *     *\n*              *************************\n*              *                       *\n*           16 *   ADDRESS OF DSNAME   *\n*              *                       *\n*              *************************\n*              *           *           *\n*           20 *  TTREL 1  *  TTREL 2  *\n*              *           *           *\n*              *************************\n         SPACE 2\nMB       DSECT\nMBCHAIN  DS    F\nMBCCHH1  DS    F\nMBCCHH2  DS    F\nMBNTRKS  DS    H\nMBEXT    DS    CL1\n         DS    CL1\nMBNAME   DS    F\nMBTTREL1 DS    H\nMBTTREL2 DS    H\n         SPACE\nMBSIZE   EQU   *-MB\n         SPACE\nFBCHAIN  EQU   MBCHAIN-MB\nFBCCHH1  EQU   MBCCHH1-MB\nFBCCHH2  EQU   MBCCHH2-MB\nFBNTRKS  EQU   MBNTRKS-MB\nFBEXT    EQU   MBEXT-MB\nFBNAME   EQU   MBNAME-MB\nFBTTREL1 EQU   MBTTREL1-MB\nFBTTREL2 EQU   MBTTREL2-MB\n         EJECT\n* DUMMY SECTION TO DEFINE PDS DIRECTORY ITEM\n         SPACE 2\n*              *************************\n*              *                       *\n*            0 *                       *\n*              *      MEMBER NAME      *\n*            4 *                       *\n*              *                       *\n*              *************************\n*              *                 *     *\n*            8 *       TT R      *  C  *\n*              *                 *     *\n*              *************************\n*              *                       *\n*           12 *       USER DATA       *\n*            . *                       *\n*            . *      0-62 BYTES       *\n*            . *                       *\n*            . *           *************\n*            . *           *\n*           72 *           *\n*              *           *\n*              *************\n         SPACE 2\nDIRBLOCK DSECT\n         SPACE\nDIRNAME  DS    CL8\nDIRTTR   DS    CL3\nDIRC     DS    CL1\nDIRUDATA DS    CL62\n         EJECT\n* DSCB FORMATTING DUMMY SECTIONS\n         SPACE\n* FORMAT 1 DSCB:\n         SPACE\nDS1      DSECT\n         IECSDSL1  1\nDS1FDAD  DS    CL8\nDS1CHAIN DS    F\nDS1NXTF1 DS    F\nDS1PDSS  EQU   DS1SYSCD           BYTE USED TO INDICATE THIS PDS\n         SPACE\nDS1SIZE  EQU   *-DS1\n         SPACE\nFM1NXTF1 EQU   DS1NXTF1-DS1\nFM1DSNAM EQU   DS1DSNAM-DS1\n         EJECT\n* FORMAT 2 DSCB:\n         SPACE\nDS2      DSECT\n         IECSDSL1  2\nDS2FDAD  DS    CL8\n         SPACE\nDS2SIZE  EQU   *-DS2\n         SPACE 4\n* FORMAT 3 DSCB:\n         SPACE\nDS3      DSECT\n         IECSDSL1  3\nDS3FDAD  DS    CL8\nDS3CHAIN DS    F\n         SPACE\nDS3SIZE  EQU   *-DS3\n         SPACE 4\n* FORMAT 4 DSCB:\n         SPACE\nDS4      DSECT\nDS4DSNAM DS    11F\n         IECSDSL1  4\nDS4FDAD  DS    CL8\n         SPACE\nDS4SIZE  EQU   *-DS4\n         SPACE 4\n* FORMAT 5 DSCB:\n         SPACE\nDS5      DSECT\n         IECSDSL1  5\nDS5FDAD  DS    CL8\nDS5CHAIN DS    F\n         SPACE\nDS5SIZE  EQU   *-DS5\n         EJECT\n* DCB FIELD DEFINING DUMMY SECTION\n         SPACE 2\n         DCBD  DSORG=PS,DEVD=DA\n         EJECT\n* JOB FILE CONTROL BLOCK DUMMY SECTION\n         SPACE 2\nJFDUMMY  DSECT\n         IEFJFCBN\n         SPACE 4\n* TASK I/O TABLE (TIOT) DEFINING DUMMY SECTION:\n         SPACE 2\nTIOT     DSECT\n         IEFTIOT1\n         SPACE\n         END\n         MACRO\n&SYMBOL  XPROPEN  &WA,&MAXLINE=0,&PAGENO=0,&PAGEWID=0,&PAGELEN=0,      X\n               &TIME=0,&DATE=0,&DDNAME=SYSPRINT,&IHBPARM=56\n.* MACRO TO EXECUTE AN 'OPEN' OR 'MODIFY' CALL TO 'XPRNTSUB'.\n         LCLC  &TAG\n&TAG     SETC  'IHB&SYSNDX'\n         AIF   ('&SYMBOL' EQ '').T1\n&SYMBOL  DS    0H\n.T1      AIF   ('&MAXLINE'(1,1) NE '(').T2\n         ST    &MAXLINE(1),&TAG.A      STORE IN PARM LIST\n.T2      AIF   ('&PAGENO'(1,1) NE '(').T3\n         STH   &PAGENO(1),&TAG.A+4     STORE IN PARM LIST\n.T3      AIF   ('&PAGEWID'(1,1) NE '(').T4\n         STC   &PAGEWID(1),&TAG.A+6    STORE IN PARM LIST\n.T4      AIF   ('&PAGELEN'(1,1) NE '(').T5\n         STC   &PAGELEN(1),&TAG.A+7    STORE IN PARM LIST\n.T5      AIF   ('&TIME'(1,1) NE '(').T6\n         ST    &TIME(1),&TAG.A+8       STORE IN PARM LIST\n.T6      AIF   ('&DATE'(1,1) NE '(').T7\n         ST    &DATE(1),&TAG.A+12      STORE IN PARM LIST\n.T7      AIF   ('&DDNAME'(1,1) NE '(').CNOP\n         MVC   &TAG.A+16(8),0(&DDNAME(1))  STORE IN PARM LIST\n.CNOP    CNOP  0,4\n         BAL   1,&TAG.L        LOAD PARM LIST ADDRESS\n.P1      AIF   ('&MAXLINE'(1,1) EQ '(').PR1\n&TAG.A   DC    A(&MAXLINE)             PRINT OUTPUT LIMIT\n         AGO   .P2\n.PR1     ANOP\n&TAG.A   DC    A(0)                    PRINT OUTPUT LIMIT\n.P2      AIF   ('&PAGENO'(1,1) EQ '(').PR2\n         DC    AL2(&PAGENO)            PAGE NUMBER\n         AGO   .P3\n.PR2     DC    AL2(0)                  PAGE NUMBER\n.P3      AIF   ('&PAGEWID'(1,1) EQ '(').PR3\n         DC    AL1(&PAGEWID)           PAGE WIDTH\n         AGO   .P4\n.PR3     DC    AL1(0)                  PAGE WIDTH\n.P4      AIF   ('&PAGELEN'(1,1) EQ '(').PR4\n         DC    AL1(&PAGELEN)           PAGE LENGTH\n         AGO   .P5\n.PR4     DC    AL1(0)                  PAGE LENGTH\n.P5      AIF   ('&TIME'(1,1) EQ '(').PR5\n         DC    A(&TIME)                ADDRESS OF TIME\n         AGO   .P6\n.PR5     DC    A(0)                    ADDRESS OF TIME\n.P6      AIF   ('&DATE'(1,1) EQ '(').PR6\n         DC    A(&DATE)                ADDRESS OF DATE\n         AGO   .P7\n.PR6     DC    A(0)                    ADDRESS OF DATE\n.P7      AIF   ('&IHBPARM' NE '56').VCON\n         AIF   ('&DDNAME'(1,1) EQ '(').PR7\n         DC    CL8'&DDNAME'            DDNAME FOR DATA SET\n         AGO   .VCON\n.PR7     DC    CL8' '                  DDNAME FOR DATA SET\n.VCON    ANOP\n&TAG.L   XPRINNRA  &WA,&IHBPARM\n         MEND\n         MACRO\n&SYMBOL  XPRSPACE  &WA,&LINES=1,&COND=\n.* MACRO TO EXECUTE A SPACE CALL TO 'XPRNTSUB'.\n         LCLA  &N,&B6,&B7\n         LCLC  &TAG,&SYM\n&SYM     SETC  '&SYMBOL'\n&TAG     SETC  'IHB&SYSNDX'\n.LOOP    ANOP\n&N       SETA  &N+1\n         AIF   (&N GT N'&COND).LDONE\n.TST1    AIF   ('&COND(&N)' NE 'NOEJ').TST2\n&B6      SETA  1\n         AGO   .LOOP\n.TST2    AIF   ('&COND(&N)' NE 'ATHOF').TST3\n&B7      SETA  1\n         AGO   .LOOP\n.TST3    MNOTE 4,'OPERAND &COND(&N) AFTER KEYWORD COND IS ILLEGAL'\n         AGO   .LOOP\n.LDONE   CNOP  2,4\n         AIF   ('&LINES'(1,1) NE '(').NOTREG1\n&SYM     STC   &LINES(1),&TAG.A+1      STORE INTO PARM LIST\n&SYM     SETC  ''\n.NOTREG1 ANOP\n&SYM     BAL   1,&TAG.L                LOAD PARM LIST ADDRESS\n&TAG.A   DC    B'000000&B6&B7'         OPTION BITS\n         AIF   ('&LINES'(1,1) NE '(').NOTREG2\n         DC    X'00'                   SPACING AMOUNT\n         AGO   .VCON\n.NOTREG2 DC    AL1(&LINES)             SPACING AMOUNT\n.VCON    ANOP\n&TAG.L   XPRINNRA  &WA,44\n         MEND\n         MACRO\n&SYMBOL  XPRCLOSE  &WA\n.* MACRO TO EXECUTE A CLOSE CALL TO 'XPRNTSUB'.\n         CNOP  0,4\n&SYMBOL  B     *+8                     BRANCH AROUND ADDRESS\n         XPRINNRA  &WA,68\n         MEND\n         MACRO\n&SYMBOL  XPRDCB  &DDNAME=SYSPRINT,&BLKSIZE=0\n         LCLC  &TAG\n.* MACRO TO GENERATE A WORK AREA FOR A PRINTER DATA SET, CONTAINING\n.* A SAVE AREA, THE DCB, OPEN AND CLOSE PARAMETER LISTS, AND VARIOUS\n.* CELLS AND SWITCHES.\n&TAG     SETC  '&SYMBOL'\n         AIF   (T'&SYMBOL NE 'O').TOK  TEST IF NAME SUPPLIED\n&TAG     SETC  'XPRDCB01'              SUPPLY STANDARD PRDCB NAME\n.TOK     ANOP\n&TAG     DS    0D                      ALIGN ON DOUBLE-WORD BOUNDARY\n         DS    18F                     STANDARD SAVE AREA\n         SPACE\n*        DCB   DDNAME=&DDNAME,DSORG=PS,RECFM=VBM,LRECL=137,           X\n*              BLKSIZE=&BLKSIZE,MACRF=PL,BFTEK=S,BUFNO=2\nIHB&SYSNDX DCB DDNAME=&DDNAME,DSORG=PS,RECFM=VBM,LRECL=137,            X\n               BLKSIZE=&BLKSIZE,MACRF=PL,BFTEK=S,BUFNO=2\n         SPACE\n* PARAMETER LISTS FOR OPEN AND CLOSE:\n         SPACE\n         OPEN  (IHB&SYSNDX,(OUTPUT,LEAVE)),MF=L  PARM LIST FOR OPEN\n         SPACE\n         CLOSE (IHB&SYSNDX,LEAVE),MF=L PARM LIST FOR CLOSE\n         SPACE\n* WORK CELLS AND VARIABLE STORAGE:\n         SPACE\n         DS    1D                      WORK CELL\n         DS    3F                      WORK CELLS\n         DS    1A                      PAGE HEADING PARM LIST ADDRESS\n         DS    1F                      MAXIMUM NUMBER OF OUTPUT LINES\n         DS    1H                      PAGE WIDTH\n         DS    1H                      PAGE LENGTH\n         DS    1H                      PAGE NUMBER\n         DS    1H                      PAGE BALANCE\n         DS    1X                      SWITCHES\n         DS    CL24                    DATE & TIME FOR PAGE HEADING\n         SPACE 2\n         MEND\n         MACRO\n&SYMBOL  XPREJECT  &WA,&COND=\n.* MACRO TO EXECUTE AN EJECT CALL TO 'XPRNTSUB'.\n         LCLC  &TAG,&SYM,&OPT,&R\n         LCLA  &K\n&SYM     SETC  '&SYMBOL'\n&TAG     SETC  'IHB&SYSNDX'\n         CNOP  2,4\n.TST1    AIF   ('&COND' NE '').TST2\n&OPT     SETC  'F000'\n         AGO   .SIMPLE\n.TST2    AIF   ('&COND' NE 'ATHOF').TSTC\n&OPT     SETC  'F100'\n.SIMPLE  ANOP\n&SYM     BAL   1,&TAG.L                LOAD PARM ADDRESS\n         DC    XL2'&OPT'               OPTION BITS\n         AGO   .VCON\n.TSTC    AIF   ('&COND(1)' NE 'EQ').NE\n&OPT     SETC  '80'\n.NE      AIF   ('&COND(1)' NE 'NE').LT\n&OPT     SETC  '70'\n.LT      AIF   ('&COND(1)' NE 'LT').GT\n&OPT     SETC  '40'\n.GT      AIF   ('&COND(1)' NE 'GT').LE\n&OPT     SETC  '20'\n.LE      AIF   ('&COND(1)' NE 'LE').GE\n&OPT     SETC  'C0'\n.GE      AIF   ('&COND(1)' NE 'GE').NOT\n&OPT     SETC  'A0'\n.NOT     AIF   ('&OPT' NE '').COK\n         MNOTE 4,'COND OPERAND &COND(1) ILLEGAL'\n.COK     AIF   ('&COND(2)' NE '').C2OK\n         MNOTE 4,'COND TEST QUANTITY MISSING'\n         AGO   .NOTREG\n.C2OK    AIF   ('&COND(2)'(1,1) NE '(').NOTREG\n&K       SETA  K'&COND(2)-2\n&R       SETC  '&COND(2)'(2,&K)\n&SYM     STC   &R,&TAG.A               STORE INTO PARM LIST\n&SYM     SETC  ''\n.NOTREG  ANOP\n&SYM     BAL   1,&TAG.L                LOAD PARM ADDRESS\n         DC    XL1'&OPT'               CONDITION MASK\n         AIF   ('&COND(2)' EQ '').NOTREG2\n         AIF   ('&COND(2)'(1,1) NE '(').NOTREG2\n&TAG.A   DC    AL1(0)                  TEST QUANTITY\n         AGO   .VCON\n.NOTREG2 DC    AL1(&COND(2))           TEST QUANTITY\n.VCON    ANOP\n&TAG.L   XPRINNRA  &WA,92\n         MEND\n         MACRO\n&SYMBOL  XPRHEAD  &WA,&LIST=\n.* MACRO TO PRESENT A LIST OF PRINT LINE DESCRIPTORS FOR PAGE HEADINGS\n.* TO 'XPRNTSUB'.\n&SYMBOL  XPRLIST  &WA,LIST=&LIST,IHBPARM=80\n         MEND\n         MACRO\n&TAG     XPRINNRA  &WA,&IHBPARM\n.* INNER MACRO USED IN CALLS TO 'XPRNTSUB'\n         DC    V(XPRNTSUB)             PRINTING SUBROUTINE ADDRESS\n&TAG     L     15,*-4                  LOAD ENTRY POINT\n         AIF   ('&WA' NE '').WOK\n         LA    0,XPRDCB01              LOAD STANDARD WORK AREA ADDRESS\n         AGO   .BAL\n.WOK     AIF   ('&WA' EQ '(0)').BAL\n         AIF   ('&WA'(1,1) EQ '(').REG\n         LA    0,&WA                   LOAD WORK AREA ADDRESS\n         AGO   .BAL\n.REG     LR    0,&WA(1)                LOAD WORK AREA ADDRESS\n.BAL     BAL   14,&IHBPARM.(15)        CALL PRINT SUBROUTINE\n         MEND\n         MACRO\n&SYMBOL  XPRLDEF  &TEXT=,&LENGTH=132,&OFFSET=0,&SPA=1,&SPB=0\n.* MACRO TO DEFINE PRINT LINE DESCRIPTOR BLOCKS (\"PLD\" BLOCKS) FOR\n.* THE PRINTING SUBROUTINE \"XPRNTSUB\".\n         LCLA  &N\n         LCLC  &B3,&B6,&B7\n         ACTR  25                      JUST IN CASE\n&B3      SETC  '0'\n&B6      SETC  '0'\n&B7      SETC  '0'\n.* PROCESS OPTIONS IN SPA OPERAND:\n.TSTA1   AIF   ('&SPA(2)' EQ '').TSTB1\n         AIF   ('&SPA(2)' NE 'NOEJ').TSTA2\n&B3      SETC  '1'\n         AGO   .TSTB1\n.TSTA2   MNOTE 4,'OPERAND &SPA(2) AFTER KEYWORD SPA IS ILLEGAL'\n.* PROCESS OPTIONS IN SPB OPERAND:\n.TSTB1   ANOP\n&N       SETA  2\n.TSTB5   AIF   ('&SPB(&N)' NE 'NOEJ').TSTB2\n&B7      SETC  '1'\n         AGO   .TSTB4\n.TSTB2   AIF   ('&SPB(&N)' NE 'ATHOF').TSTB3\n&B6      SETC  '1'\n         AGO   .TSTB4\n.TSTB3   AIF   ('&SPB(&N)' EQ '').TSTB4\n         MNOTE 4,'OPERAND &SPB(&N) AFTER KEYWORD SPB IS ILLEGAL'\n.TSTB4   ANOP\n&N       SETA  &N+1\n         AIF   (&N LE 3).TSTB5\n.IFTEXT  AIF   ('&TEXT' NE '').TOK\n         MNOTE 4,'TEXT ADDRESS MISSING'\n.TOK     ANOP\n&SYMBOL  DS    0F                      ALIGN ON FULL-WORD BOUNDARY\n         DC    BL1'000&B3.00&B6&B7'    OPTION BITS\n         DC    AL3(&TEXT)              TEXT ADDRESS\n         DC    AL1(&LENGTH)            TEXT LENGTH\n         DC    AL1(&OFFSET)            MARGIN OFFSET\n.TESTB   AIF   ('&SPB(1)' EQ 'EJECT').BSKIP\n         AIF   ('&SPB(1)' EQ 'SKIP').BSKIP\n         DC    AL1(&SPB(1))            PRE-SPACING\n         AGO   .TESTA\n.BSKIP   ANOP\n         DC    AL1(255)                EJECT BEFORE PRINTING\n.TESTA   AIF   ('&SPA(1)' EQ 'EJECT').ASKIP\n         AIF   ('&SPA(1)' EQ 'SKIP').ASKIP\n         DC    AL1(&SPA(1))            POST-SPACING\n         MEXIT\n.ASKIP   ANOP\n         DC    AL1(255)                EJECT AFTER PRINTING\n         MEND\n         MACRO\n&SYMBOL  XPRLIST  &WA,&LIST=,&IHBPARM=32\n.* MACRO TO DELIVER A LIST OF PRINT LINE DESCRIPTORS TO 'XPRNTSUB'.\n         LCLA  &N,&K,&D\n         LCLC  &TAG,&SYM,&R\n         ACTR  100\n&SYM     SETC  '&SYMBOL'\n&TAG     SETC  'IHB&SYSNDX'\n         AIF   ('&LIST' NE '').LOK\n         MNOTE 8,'LIST OPERAND MUST BE SUPPLIED'\n         MEXIT\n.LOK     CNOP  0,4\n         AIF   ('&LIST' NE '(1)').STLOOP\n&SYMBOL  B     &TAG.L                  BRANCH AROUND ADDRESS\n         AGO   .VCON\n.STLOOP  ANOP\n&N       SETA  &N+1\n         AIF   (&N GT N'&LIST).STDONE\n         AIF   ('&LIST(&N)'(1,1) NE '(').STLOOP\n&K       SETA  K'&LIST(&N)-2\n&R       SETC  '&LIST(&N)'(2,&K)\n&D       SETA  4*(&N-1)\n&SYM     ST    &R,&TAG.A+&D            STORE INTO PARM LIST\n&SYM     SETC  ''\n         AIF   (&N NE N'&LIST).STLOOP\n         OI    &TAG.A+&D,X'80'         SET END-OF-LIST BIT\n.STDONE  ANOP\n&SYM     BAL   1,&TAG.L                LOAD PARM LIST ADDRESS\n&SYM     SETC  '&TAG.A'\n&N       SETA  0\n.LOOP    ANOP\n&N       SETA  &N+1\n         AIF   (&N GT N'&LIST).VCON\n         AIF   ('&LIST(&N)'(1,1) NE '(').NOTREG\n&SYM     DC    A(0)\n&SYM     SETC  ''\n         AGO   .LOOP\n.NOTREG  AIF   (&N EQ N'&LIST).LAST\n&SYM     DC    A(&LIST(&N))\n&SYM     SETC  ''\n         AGO   .LOOP\n.LAST    ANOP\n&SYM     DC    X'80'                   END-OF-LIST BIT\n         DC    AL3(&LIST(&N))\n.VCON    ANOP\n&TAG.L   XPRINNRA  &WA,&IHBPARM\n         MEND\n         MACRO\n&SYMBOL  XPRMOD  &WA,&MAXLINE=0,&PAGENO=0,&PAGEWID=0,&PAGELEN=0,       X\n               &TIME=0,&DATE=0\n.* MACRO TO EXECUTE A MODIFY CALL TO 'XPRINTSUB'.\n&SYMBOL  XPROPEN  &WA,MAXLINE=&MAXLINE,PAGENO=&PAGENO,PAGEWID=&PAGEWID,X\n               PAGELEN=&PAGELEN,TIME=&TIME,DATE=&DATE,IHBPARM=104\n         MEND\n         MACRO\n&SYMBOL  XPRNTLIN  &WA,&TEXT=00,&LENGTH=132,&OFFSET=0,&SPB=0,&SPA=1\n         LCLA  &N\n         LCLC  &B3,&B6,&B7,&T,&R\n         ACTR  25\n&T       SETC  'IHB&SYSNDX'\n&B3      SETC  '0'\n&B6      SETC  '0'\n&B7      SETC  '0'\n.* PROCESS OPTIONS IN SPA OPERAND:\n.TSTA1   AIF   ('&SPA(2)' EQ '').TSTB1\n         AIF   ('&SPA(2)' NE 'NOEJ').TSTA2\n&B3      SETC  '1'\n         AGO   .TSTB1\n.TSTA2   MNOTE 4,'OPERAND &SPA(2) AFTER KEYWORD SPA IS ILLEGAL'\n.* PROCESS OPTIONS IN SPB OPERAND:\n.TSTB1   ANOP\n&N       SETA  2\n.TSTB5   AIF   ('&SPB(&N)' NE 'NOEJ').TSTB2\n&B7      SETC  '1'\n         AGO   .TSTB4\n.TSTB2   AIF   ('&SPB(&N)' NE 'ATHOF').TSTB3\n&B6      SETC  '1'\n         AGO   .TSTB4\n.TSTB3   AIF   ('&SPB(&N)' EQ '').TSTB4\n         MNOTE 4,'OPERAND &SPB(&N) AFTER KEYWORD SPB IS ILLEGAL'\n.TSTB4   ANOP\n&N       SETA  &N+1\n         AIF   (&N LE 3).TSTB5\n.* GENERATE STORE INSTRUCTIONS IF REGISTER NOTATION IS USED:\n         CNOP  0,4\n         AIF   ('&SYMBOL' EQ '').IFR1\n&SYMBOL  DS    0H\n.IFR1    AIF   ('&TEXT' NE '00').TXTOK\n         MNOTE 4,'TEXT ADDRESS MUST BE SUPPLIED'\n.TXTOK   AIF   ('&TEXT'(1,1) NE '(').IFR2\n         ST    &TEXT(1),&T.A           STORE TEXT ADDRESS\n         MVI   &T.A,B'000&B3.00&B6&B7' INSERT OPTION BITS\n.IFR2    AIF   ('&LENGTH'(1,1) NE '(').IFR3\n         STC   &LENGTH(1),&T.A+4       STORE TEXT LENGTH\n.IFR3    AIF   ('&OFFSET'(1,1) NE '(').IFR4\n         STC   &OFFSET(1),&T.A+5       STORE MARGIN OFFSET\n.IFR4    AIF   ('&SPB(1)'(1,1) NE '(').IFR5\n&N       SETA  K'&SPB(1)-2\n&R       SETC  '&SPB(1)'(2,&N)\n         STC   &R,&T.A+6               STORE PRE-SPACING\n.IFR5    AIF   ('&SPA(1)'(1,1) NE '(').LOAD1\n&N       SETA  K'&SPA(1)-2\n&R       SETC  '&SPA(1)'(2,&N)\n         STC   &R,&T.A+7               STORE POST-SPACING\n.* LOAD REG 1 AND GENERATE PLD LIST ADDRESS:\n.LOAD1   BAL   1,&T.L                  LOAD PARM ADDRESS\n         DC    X'80'                   MARK END OF ADDRESS LIST\n         DC    AL3(&T.A)               ADDRESS OF PLD\n.* GENREATE PLD PARAMETERS TO DESCRIBE THE PRINT LINE:\n.IFR11   AIF   ('&TEXT'(1,1) NE '(').NOTR11\n&T.A     DC    A(0)                    TEXT ADDRESS & OPTION BITS\n         AGO   .IFR12\n.NOTR11  ANOP\n&T.A     DC    B'000&B3.00&B6&B7'      OPTION BITS\n         DC    AL3(&TEXT)              TEXT ADDRESS\n.IFR12   AIF   ('&LENGTH'(1,1) NE '(').NOTR12\n         DC    AL1(0)                  TEXT LENGTH\n         AGO   .IFR13\n.NOTR12  DC    AL1(&LENGTH)            TEXT LENGTH\n.IFR13   AIF   ('&OFFSET'(1,1) NE '(').NOTR13\n         DC    AL1(0)                  MARGIN OFFSET\n         AGO   .IFR14\n.NOTR13  DC    AL1(&OFFSET)            MARGIN OFFSET\n.IFR14   AIF   ('&SPB(1)'(1,1) NE '(').NOTR14\n         DC    AL1(0)                  PRE-SPACING\n         AGO   .IFR15\n.NOTR14  AIF   ('&SPB(1)' EQ 'EJECT').BSKIP\n         AIF   ('&SPB(1)' EQ 'SKIP').BSKIP\n         DC    AL1(&SPB(1))            PRE-SPACING\n         AGO   .IFR15\n.BSKIP   DC    AL1(255)                SKIP BEFOR PRINTING\n.IFR15   AIF   ('&SPA(1)'(1,1) NE '(').NOTR15\n         DC    AL1(0)                  POST-SPACING\n         AGO   .VCON\n.NOTR15  AIF   ('&SPA(1)' EQ 'EJECT').ASKIP\n         AIF   ('&SPA(1)' EQ 'SKIP').ASKIP\n         DC    AL1(&SPA(1))            POST-SPACING\n         AGO   .VCON\n.ASKIP   DC    AL1(255)                SKIP AFTER PRINTING\n.VCON    ANOP\n&T.L    XPRINNRA  &WA,32\n         MEND\n         PRINT NOGEN\nXVTC     TITLE 'XVTCREAD - VTOC READING SUBROUTINE'\n* AUTHOR:  R. F. MORSE, MIT INSTRUMENTATION LABORATORY.\n* UPDATED:  H.R.HOWIE/---        REL 20.6, IBM 370\n*           J.AIELLO/GTEL        INCLUDE 3330 MOD-11\n*           W.G.GRIFFIN/GTEL     INCLUDE 3350\n* UPDATED 06/07/79:\n*           D.C.LIVINGSTON/GTEL  USE DSCB'S/TRK FROM F4 DSCB IF VALUE\n*                                  IN TABLE TOO LARGE\n* UPDATED:  4 MAY 1981\n*           J.B.SCHLAM/GTEL      INDEXED VTOC MOD\n*\n* FUNCTION: THIS SUBROUTINE READS THE VOLUME TABLE OF CONTENTS (VTOC)\n*        FROM A DIRECT-ACCESS DEVICE AND PRESENTS IT TO THE CALLER\n*        ONE RECORD (DSCB) AT A TIME.\n         SPACE\n* OPERATION: THIS ROUTINE IS A SPECIALIZED SEQUENTIAL ACCESS METHOD\n*        FOR VTOC'S.  ITS ADVANTAGE OVER ORDINARY BSAM IS THAT IT READS\n*        AN ENTIRE TRACK IN ONE REVOLUTION, THUS SAVING CONSIDERABLE\n*        TIME.  THE ROUTINE HAS THREE CALL MODES:\n*\n*        0 - READ.  RETURNS WITH THE CORE ADDRESS OF A DSCB IN REGISTER\n*              1.  THE CORE CONSISTS OF 148 CONSECUTIVE BYTES, CONTAIN-\n*              ING THE COUNT (8 BYTES), KEY (44 BYTES), AND DATA (96\n*              BYTES) FOR ONE DSCB.  RETURN CODES ARE:\n*                      0 - NORMAL;\n*                      4 - END OF FILE, NO DATA PRESENTED;\n*                      8 - PERMANENT I/O ERROR.  THE KEY AND DATA AREAS\n*                          WILL BE SET TO ZEROS; THE COUNT AREA WILL\n*                          CONTAIN THE CORRECT CCHHR.  SINCE READING\n*                          IS DONE A TRACK AT A TIME, ALL THE DSCB'S\n*                          FOR THAT TRACK WILL BE MARKED IN ERROR.\n*                          READING MAY CONTINUE ON TO THE NEXT TRACK.\n*\n*        1 - OPEN.  REGISTER 1 SHOULD POINT TO AN 8-BYTE FIELD\n*              CONTAINING THE DDNAME TO BE USED IN THE DCB.\n*              RETURN CODES ARE:\n*                      0 - NORMAL;\n*                      4 - UNABLE TO OPEN (PROBABLY MISSING DD CARD);\n*                      8 - DD CARD DID NOT REFER TO A DIRECT-ACCESS\n*                          DEVICE, OR DEVICE TYPE UNKNOWN.\n*\n*        2 - CLOSE.  NO ARGUMENTS ARE REQUIRED OR RETURNED.\n         SPACE\n* ENTRY POINTS:  ENTRY IS ALWAYS TO 'XVTCREAD' VIA A BALR 14,15 WITH\n*        REGISTER 13 SET TO A SAVE AREA.  REGISTER 0 CONTAINS A\n*        BINARY INTEGER TO INDICATE THE CALL MODE AND REGISTER 1\n*        POINTS TO PARAMETERS AS REQUIRED FOR EACH MODE.\n*                ENTRY POINT 'VTOCDCB' IS USED TO ESTABLISH   JBSIX\n*        ADDRESSABILITY TO THE DCB IN MODULE 'VTOCLIST',      JBSIX\n*        WHEN MAPPING AN INDEXED VTOC.                        JBSIX\n         SPACE\n* DATA SETS:  READS VOLUME TABLE OF CONTENTS FROM ANY DIRECT-ACCESS\n*        DEVICE.  USES EXCP TO EXECUTE A CHAINED CHANNEL PROGRAM TO\n*        READ AN ENTIRE TRACK AT A TIME.\n         SPACE\n* EXTERNAL ROUTINES:  USES SUPERVISOR ROUTINE 'IECPCNVT' TO CONVERT\n*        A RELATIVE TRACK NUMBER TO AN ABSOLUTE ADDRESS.\n         SPACE\n* EXIT:  RETURNS VIA REGISTER 14 WITH RETURN CODE IN REGISTER 15.\n         SPACE\n* TABLES AND WORK AREAS:  DOES A GETMAIN TO OBTAIN A BUFFER LARGE\n*        ENOUGH TO HOLD AN ENTIRE TRACK FROM THE DEVICE BEING READ.\n*        THIS AREA MAY BE AS LARGE AS 17000 BYTES (FOR 2305-2 DRUM).\n         SPACE\n* ATTRIBUTES:  SERIALLY REUSABLE.\n         EJECT\n* SECTION DEFINITION AND REGISTER ASSIGNMENTS:\n         SPACE\nXVTCREAD CSECT\n         SPACE 2\n         ENTRY VTOCDCB                                        JBSIX\n         SPACE 2\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nRWA      EQU   2\nRWB      EQU   3\nRWC      EQU   4\nRPARM    EQU   9\nRRCODE   EQU   10              RETURN CODE REGISTER\nRRET     EQU   11              LOCAL SUBROUTINE EXIT REGISTER\nRBASE    EQU   12              LOCAL BASE REGISTER\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 3\n* TAGS FOR CHANNEL COMMANDS AND FLAG BITS:\n         SPACE\nREADR0   EQU   X'16'           READ RECORD 0\nREADCKD  EQU   X'1E'           READ COUNT, KEY, AND DATA\n         SPACE\nCC       EQU   X'40'           COMMAND CHAIN FLAG\nSLI      EQU   X'20'           SUPPRESS LENGTH INDICATION FLAG\nSKIP     EQU   X'10'           SKIP DATA TRANSFER FLAG\n         SPACE 3\n* COMMUNICATION VECTOR TABLE (CVT) DEFINITIONS:\n         SPACE\nCVT      EQU   16              LOCATION OF CVT BASE ADDRESS\nCVTPCNVT EQU   28              OFFSET TO CONVERT ROUTINE ADDRESS\n         EJECT\n************\n* PROLOGUE *\n************\n         SPACE\n* ENTER HERE AND PERFORM STANDARD REGISTER SAVE AREA HOUSEKEEPING.\n         SPACE\n         STM   14,12,12(13)\n         LR    RBASE,R15               SET LOCAL BASE REGISTER\n         USING XVTCREAD,RBASE\n         B     GO\n         DC    C'XVTCREAD 17 MAR 72'\n         SPACE\nGO       LR    R14,R13                 SAVE CALLER'S R13\n         LA    R13,SAVEAREA            ADDRESS LOCAL SAVE AREA\n         ST    R13,8(R14)              CHAIN FORWARD\n         ST    R14,SAVEAREA+4          CHAIN BACKWARD\n         SR    RRCODE,RRCODE           ZERO RETURN CODE REGISTER\n         SPACE\n* SELECT MODE FROM CONTENTS OF REGISTER 0.\n         SPACE\n         LA    RWA,3                   MASK FOR LOW 2 BITS\n         NR    RWA,R0                  GET CALL MODE\n         SLL   RWA,2                   MODE TIMES 4\n         B     *+4(RWA)                BRANCH ON MODE\n         SPACE\n         B     GET                     MODE 0, GET A DSCB\n         B     OPEN                    MODE 1, OPEN A NEW VTOC\n         B     CLOSE                   MODE 2, CLOSE\n         B     RETURN0                 MODE 3 NOT DEFINED, NO OP\n         SPACE 3\n***********\n* RETURNS *\n***********\n         SPACE\nRETURN8  LA    RRCODE,4(RRCODE)        ENTRY FOR RETURN CODE 8\nRETURN4  LA    RRCODE,4(RRCODE)        ENTRY FOR RETURN CODE 4\nRETURN0  LR    R15,RRCODE              ENTRY FOR RETURN CODE 0\n         SPACE\n         L     R13,SAVEAREA+4          RECOVER CALLER'S SAVE AREA\n         L     R14,12(R13)             LOAD RETURN ADDRESS\n         LM    R2,R12,28(R13)          RESTORE OTHER GENERAL REGISTERS\n         MVI   12(R13),X'FF'           SET RETURN FLAG ON\n         BR    R14                     RETURN TO CALLER\n         EJECT\n*********************\n* MODE 0 - GET DSCB *\n*********************\n         SPACE\n* IF END-OF-FILE WAS REACHED, RETURN AT ONCE.\n         SPACE\nGET      DS    0H\n         TM    MODESW,EOFSW            TEST END-OF-FILE BIT\n         BO    RETURN4                 RETURN CODE 4 IF ON\n         SPACE\n* IF CHANNEL PROGRAM HAS BEEN STARTED, GO TO CHECK IT.  OTHERWISE,\n* ASSUME THERE IS AT LEAST ONE FULL BUFFER.\n         SPACE\n         TM    MODESW,XCPRUN           TEST IF EXCP ISSUED\n         BO    XCPTEST                 BRANCH IF SO\n         SPACE\n* SET BUFFER ADDRESS TO NEXT DSCB AND TEST IF LAST ON TRACK.  IF NOT,\n* EXIT WITH ITS ADDRESS IN R1.\n         SPACE\n         L     RWA,DSCBADR             LOAD BUFFER POINTER\n         LA    RWA,148(RWA)            ADVANCE TO NEXT DSCB\nNDXSTORE ST    RWA,DSCBADR             STORE UPDATED POINTER\n         C     RWA,DSCBLIM             TEST IF LAST DSCB IN BUFFER\n         BNL   LASTDSCB                BRANCH IF SO\n         LR    R1,RWA                  PASS ADDRESS TO USER\nGETOUT   TM    MODESW,RDERR            TEST IF ERROR ON THIS TRACK\n         BZ    RETURN0                 RETURN CODE 0 IF NOT\n         B     RETURN8                 RETURN CODE 8 IF ERROR\n         SPACE\n* IF THIS IS THE LAST DSCB, MOVE IT TO THE JFCB BUFFER AND START\n* READING THE NEXT TRACK.\n         SPACE\nLASTDSCB MVC   JFCB(148),0(RWA)        MOVE LAST DSCB\n         L     RWB,TTRN                LOAD RELATIVE TRACK NUMBER\n         AL    RWB,=X'00010000'        INCREMENT TO NEXT TRACK\n         ST    RWB,TTRN\n         BAL   RRET,EXCP               START CHANNEL PROGRAM\n         LA    R1,JFCB                 LOAD DSCB ADDRESS FOR CALLER\n         B     GETOUT                  TO RETURN\n         EJECT\n* WAIT FOR CHANNEL PROGRAM COMPLETION AND TEST THE OUTCOME.\n         SPACE\nXCPTEST  WAIT  ECB=VTOCECB\n         SPACE\n         NI    MODESW,X'FF'-XCPRUN     TURN EXCP STARTED BIT OFF\n         CLI   VTOCECB,X'7F'           TEST COMPLETION CODE\n         BNE   PERMERR                 BRANCH IF ERROR\nSETDSCBA L     RWA,DSCBSTRT            SET BUFFER POINTER TO 1ST DSCB\n         CLC   TTRN(4),=F'0'  FIRST TRACK OF VTOC?                 DCL\n         BNE   NDXSTORE       NO; GO TO NDXSTORE                   DCL\n*                             YES:                                 DCL\n         CLC   NDSCBS+3(1),DS4DEVDT-DS4+52(RWA)                    DCL\n*                             DSCB'S/TRK VALUE IN TABLE CORRECT    DCL\n*                               FOR SELECTED VOLUME?               DCL\n         BE    NDXSTORE       YES; GO TO NDXSTORE                  DCL\n         SR    15,15          NO; USE VALUE FROM F4 DSCB TO        DCL\n*                               RECALCULATE DSCBLIM:               DCL\n         IC    15,DS4DEVDT-DS4+52(RWA) LOAD DSCBS/TRK FROM F4 DSCB DCL\n         STC   15,NDSCBS+3    STORE IN PLACE OF ERRONEOUS VALUE    DCL\n         BCTR  15,0           FORM NEW NDSCBS - 1                  DCL\n         MH    15,=H'148'     MULTIPLY BY LENGTH OF DSCB COUNT,    DCL\n         AR    15,RWA           KEY, DATA FIELDS, ADD DSCBSTRT     DCL\n         ST    15,DSCBLIM     STORE CORRECTED DSCBLIM              DCL\n         B     NDXSTORE\n         SPACE\n* PERMANENT ERROR FOR THIS TRACK.  ZERO THE DSCB'S AND FILL IN THE\n* CCHHR PORTIONS OF THE COUNT AREAS.\n         SPACE\nPERMERR  OI    MODESW,RDERR            SIGNAL READ ERROR\n         NI    IOBFLAG1,X'FB'     TURN OFF BIT 5  (PERM ERR FLG)\n         NI    DCBIFLGS,X'3F'     TURN OFF BITS 0 & 1\n         L     RWA,DSCBSTRT            LOAD ADDRESS OF FIRST DSCB\n         LA    RWB,1                   LOAD RECORD NUMBER\n         SPACE\nDSCBELUP XC    0(148,RWA),0(RWA)       ZERO DSCB BUFFER\n         MVC   0(4,RWA),IOBSEEK+3      INSERT CCHH IN COUNT FIELD\n         STC   RWB,4(RWA)              INSERT R IN COUNT FIELD\n         LA    RWA,148(RWA)            POINT TO NEXT BUFFER\n         LA    RWB,1(RWB)              INCREMENT RECORD NUMBER\n         C     RWA,DSCBLIM             TEST FOR LAST BUFFER\n         BNH   DSCBELUP\n         B     SETDSCBA                BRANCH TO RESET BUFFER POINTER\n         EJECT\n*****************\n* MODE 1 - OPEN *\n*****************\n         SPACE\n* ENTER WITH A DDNAME ADDRESSED BY REGISTER 1.  PERFORM CLOSE\n* SUBROUTINE FIRST TO BE SURE EVERYTHING IS INITIALIZED.\n         SPACE\nOPEN     DS    0H\n         LR    RPARM,R1                SAVE REGISTER 1\n         BAL   RRET,CLOSESUB           CALL CLOSE SUBROUTINE\n         SPACE\n         MVC   DCBDDNAM(8),0(RPARM)    INSERT DDNAME IN DCB\n         SPACE\n* CHECK DEVICE TYPE TO BE SURE IT IS DIRECT ACCESS.\n         SPACE\n         DEVTYPE  DCBDDNAM,DWORK       GET DEVICE TYPE\n         LTR   R15,R15                 TEST IF IT FOUND DD CARD\n         BNZ   RETURN4                 ERROR, DD CARD MISSING\n         CLI   DWORK+2,X'20'           TEST DEVICE TYPE\n         BNE   RETURN8                 ERROR IF NOT DIRECT ACCESS\n         SPACE\n         CLI   DWORK+3,MAXDVT          TEST FOR MAX DEVICE TYPE\n         BNL   RETURN8                 ERROR IF TOO LARGE\n         SR    R1,R1\n         IC    R1,DWORK+3              LOAD DEVICE NUMBER\n         IC    R1,DVICETAB(R1)         LOAD DSCB'S/TRK FROM TABLE\n         LTR   R1,R1                   ZERO IS UNDEFINED DEVICE\n         BZ    RETURN8                 EXIT IF UNKNOWN\n         ST    R1,NDSCBS               STORE NUMBER OF DSCB'S/TRACK\n         EJECT\n* READ JFCB AND INSERT DATA SET NAME OF 44 X'04'.\n         SPACE\n         RDJFCB  VTOCDCB\n         SPACE 2\n* MASSAGE JFCB INTO MODEL AS IF DD CARD HAD ONLY:\n* //       DD    VOL=SER=######,UNIT=####,DISP=OLD\n         SPACE\n         MVI   JFCB,X'04'\n         MVC   JFCB+1(43),JFCB    GENERATE 44X'04' VTOC DSNAME\n         MVI   JFCB+44,C' '\n         MVC   JFCB+45(7),JFCB+44    GENERATE BLANK MEMBER NAME\n         XC    JFCB+52(66),JFCB+52\n         MVI   JFCB+52,X'08'      DON'T WRITE THE JFCB BACK DURING OPEN\n         MVI   JFCB+66,X'02'      STANDARD LABEL\n         MVI   JFCB+87,X'40'      DISP=OLD\n         MVI   JFCB+117,1         ONE VOLUME SERIAL NUMBER FOLLOWS\n         MVI   JFCB+124,C' '\n         MVC   JFCB+125(23),JFCB+124 BLANK LAST FOUR VOLUMES\n         XC    JFCB+148(28),JFCB+148\n         MVI   JFCB+174,1         ONE VOLUME\n         SPACE 2\n* OPEN THE DCB\n         SPACE\n         OPEN  (VTOCDCB,(INPUT)),TYPE=J\n         TM    DCBOFLGS,OPENBIT        TEST IF OPEN WORKED\n         BZ    RETURN4                 ERROR IF OPEN FAILED\n         EJECT\n* OBTAIN CORE FOR CHANNEL PROGRAM AND DSCB BUFFERS.\n         SPACE\n         LA    R0,156                  CORE FOR ONE DSCB AND ITS CCW\n         MH    R0,NDSCBS+2             TIMES NUMBER PER TRACK\n         AH    R0,=H'15'               PLUS 1 CCW AND ROUNDING\n         N     R0,=X'FFFFFFF8'         ROUND TO DOUBLE-WORD MULTIPLE\n         ST    R0,CBSIZE               SAVE SIZE OF GOTTEN CORE\n         GETMAIN  R,LV=(0)             GET TRACK BUFFERS\n         ST    R1,CBADDR               SAVE ADDRESS OF GOTTEN CORE\n         OI    MODESW,CBGOT            INDICATE CORE GOTTEN\n         SPACE\n* GENERATE CHANNEL PROGRAM.  IT CONSISTS OF A 'READ R0' ORDER WITH\n* THE SKIP FLAG ON, FOLLOWED BY A 'READ COUNT-KEY-AND-DATA' ORDER FOR\n* EACH DSCB.\n         SPACE\n         L     RWA,NDSCBS              NUMBER OF DSCB'S\n         SLL   RWA,3                   TIMES   8\n         LA    RWA,8(RWA,R1)           PLUS 8 AND BASE = 1ST BUFFER ADD\n         ST    RWA,DSCBSTRT            SAVE ADDRESS OF FIRST BUFFER\n         SPACE\n         ST    R1,IOBSTART             ADDRESS OF CHANNEL PROGRAM\n         MVC   0(8,R1),INITCCW         INSERT FIRST CCW\n         LA    RWB,8(R1)               PLACE FOR NEXT CCW\n         LA    RWC,1                   BUFFER COUNTER\n         SPACE\nCCWLOOP  MVC   0(8,RWB),READCCW        INSERT READ CCW FOR ONE DSCB\n         ST    RWA,0(RWB)              SET ITS BUFFER ADDRESS\n         MVI   0(RWB),READCKD          RESTORE COMMAND CODE\n         C     RWC,NDSCBS              TEST BUFFER COUNTER\n         BNL   LASTCCW                 BRANCH IF LAST BUFFER\n         LA    RWB,8(RWB)              INCREMENT CCW ADDRESS\n         LA    RWA,148(RWA)            INCREMENT BUFFER ADDRESS\n         LA    RWC,1(RWC)              INCREMENT BUFFER COUNTER\n         B     CCWLOOP                 DO NEXT BUFFER\n         SPACE\nLASTCCW  NI    4(RWB),X'FF'-CC         TURN OFF COMMAND CHAIN BIT\n         ST    RWA,DSCBLIM             SAVE ADDRESS OF LAST DSCB BUFFER\n         SPACE\n* SET OTHER THINGS AND START PROGRAM TO FILL BUFFER.\n         SPACE\n         SR    R0,R0\n         ST    R0,TTRN                 SET RELATIVE TRACK NUMBER TO 0\n         NI    MODESW,X'FF'-XCPRUN-RDERR-EOFSW   SET FLAGS OFF\n         BAL   RRET,EXCP               START CHANNEL PROGRAM\n         B     RETURN0                 INDICATE SUCCESSFUL OPEN\n         EJECT\n******************\n* MODE 2 - CLOSE *\n******************\n         SPACE\nCLOSE    BAL   RRET,CLOSESUB           CALL CLOSED CLOSE SUBROUTINE\n         B     RETURN0\n         SPACE 2\n* IF THE CHANNEL PROGRAM IS RUNNING, WAIT FOR IT BEFORE TAKING FURTHER\n* ACTION.\n         SPACE\nCLOSESUB DS    0H\n         TM    MODESW,XCPRUN           TEST IF CHANNEL PROGRAM RUNNING\n         BZ    NOEXCP                  BRANCH IF NOT\n         WAIT  ECB=VTOCECB             WAIT UNTIL COMPLETE\n         NI    MODESW,X'FF'-XCPRUN     TURN RUNNING SWITCH OFF\nNOEXCP   DS    0H\n         SPACE\n* CLOSE THE DCB.\n         SPACE\n         TM    DCBOFLGS,OPENBIT        TEST IF DCB OPEN\n         BZ    NOCLOSE                 BRANCH IF NOT\n         CLOSE VTOCDCB\nNOCLOSE  DS    0H\n         SPACE\n* RELEASE CORE OBTAINED FOR DSCB BUFFERS.\n         SPACE\n         TM    MODESW,CBGOT            TEST IF CORE GOTTEN\n         BZ    NOFREE                  BRANCH IF NOT\n         LM    R0,R1,CBSIZE            LOAD SIZE AND LOCATION\n         FREEMAIN  R,LV=(0),A=(1)      FREE CORE\n         NI    MODESW,X'FF'-CBGOT      SET CORE GOTTEN BIT OFF\nNOFREE   DS    0H\n         SPACE\n         NI    MODESW,X'FF'-RDERR      CLEAR ERROR SWITCH\n         BR    RRET\n         EJECT\n****************\n* EXCP ROUTINE *\n****************\n         SPACE\n* CONVERT RELATIVE TRACK ADDRESS IN 'TTRN' TO ABSOLUTE SEEK ADDRESS IN\n* 'IOBSEEK', USING SUPERVISOR CONVERSION ROUTINE.\n         SPACE\nEXCP     DS    0H\n         STM   R2,R13,EXCPSAVE         SAVE IMPORTANT REGISTERS\n         L     R0,TTRN                 LOAD RELATIVE TRACK NUMBER\n         L     R1,DCBDEBAD             LOAD DEB ADDRESS\n         LA    R2,IOBSEEK              LOAD ADDR TO RECEIVE MBBCCHHR\n         L     R15,CVT                 LOAD CVT ADDRESS\n         L     R15,CVTPCNVT(R15)       LOAD ADDR OF CONVERT ROUTINE\n         BALR  R14,R15                 CONVERT TTRN TO MBBCCHHR\n         DROP  RBASE                   THAT CLOBBERED BASE REG\n         USING *,R14                   R14 SET BY BALR ABOVE\n         LM    R2,R13,EXCPSAVE         RESTORE REGISTERS\n         DROP  R14\n         USING XVTCREAD,RBASE          BASE REGISTER RECOVERED\n         LTR   R15,R15                 TEST IF EXTENT VIOLATED (RC=4)\n         BNZ   SETEOF                  IF SO, MEANS END-OF-FILE\n         SPACE\n* ZERO ECB AND START CHANNEL PROGRAM.\n         SPACE\n         SR    R0,R0\n         ST    R0,VTOCECB              CLEAR ECB\n         NI    MODESW,X'FF'-RDERR      RESET ERROR SWITCH\n         EXCP  VTOCIOB                 START CHANNEL PROGRAM\n         OI    MODESW,XCPRUN           SET 'RUNNING' FLAG\n         BR    RRET\n         SPACE\n* WHEN EXTENT IS VIOLATED, SET END-FILE AND EXIT VIA CLOSE ROUTINE.\n         SPACE\nSETEOF   OI    MODESW,EOFSW            SET END-OF-FILE BIT\n         B     CLOSESUB                EXIT VIA CLOSE SUBROUTINE\n         EJECT\n********************************\n* CONSTANTS, VARIABLES, ETC... *\n********************************\n         SPACE\nINITCCW  CCW   READR0,0,CC+SLI+SKIP,8\nREADCCW  CCW   READCKD,0,CC,148\n         SPACE\nDVICETAB DC    X'00'     0     TABLE OF NUMBER OF DSCB'S/TRACK\n         DC    AL1(16)   1        2311\n         DC    AL1(63)   2        2301\n         DC    AL1(17)   3        2303\n         DC    AL1(22)   4        2302\n         DC    AL1(8)    5        2321\n         DC    AL1(18)   6        2305-1\n         DC    AL1(34)   7        2305-2\n         DC    AL1(25)   8        2314\n         DC    AL1(39)   9        3330\n         DC    AL1(00)   A        FILLER              GTEL\n         DC    AL1(47)   B        3350                             DCL\n         DC    AL1(51)   C        3375                GTEL\n         DC    AL1(39)   D        3330 MOD-11         GTEL\n         DC    AL1(53)   E        3380                           WFB SL\n         DC    AL1(00)   F        FILER               GTEL\nMAXDVT    EQU   *-DVICETAB\n         SPACE\nDWORK     DS    D           WORK CELL\nSAVEAREA DS   19F           SAVE AREA\nEXCPSAVE EQU   SAVEAREA+12\nCBSIZE   DS    2F              SIZE AND LOCATION OF GOTTEN CORE\nCBADDR   EQU   CBSIZE+4\nNDSCBS   DS    F               NUMBER OF DSCB'S PER TRACK\nDSCBSTRT DS    F               ADDRESS OF 1ST DSCB BUFFER\nDSCBLIM  DS    F               ADDRESS OF LAST DSCB BUFFER\nDSCBADR  DS    F               ADDRESS OF CURRENT DSCB\nTTRN     DS    F               RELATIVE TRACK NUMBER\n         SPACE\n* MODE SWITCH AND BIT DEFINITIONS:\n         SPACE\nMODESW   DC    X'00'\nCBGOT    EQU   X'80'           CORE GOTTEN FOR BUFFER\nXCPRUN   EQU   X'40'           CHANNEL PROGRAM STARTED BUT NOT CHECKED\nRDERR    EQU   X'20'           PERMANENT I/O ERROR\nEOFSW    EQU   X'10'           END-OF-FILE SENSED\n         SPACE\n         LTORG\n         EJECT\n* DATA CONTROL BLOCK\n         SPACE\nVTOCDCB  DCB   DDNAME=VTOCJFCB,MACRF=E,EXLST=JFCBADDR\n         SPACE\nDCBDDNAM EQU   VTOCDCB+40\nDCBIFLGS EQU   VTOCDCB+44\nDCBDEBAD EQU   VTOCDCB+44\nDCBOFLGS EQU   VTOCDCB+48\nOPENBIT  EQU   X'10'\n         EJECT\n* IOB FOR CHANNEL PROGRAM:\n         SPACE\nVTOCIOB  DS    0D\nIOBFLAG1 DC    X'42000000'     COMMAND CHAIN, NOT RELATED\n         DC    A(VTOCECB)\n         DC    2F'0'\nIOBSTART DC    A(0)            CHANNEL PROGRAM BEGINNING\n         DC    A(VTOCDCB)\n         DC    X'03000000'\n         DC    F'0'\nIOBSEEK  DC    D'0'            INITIAL SEEK ADDRESS\n         SPACE\n* EVENT CONTROL BLOCK FOR CHANNEL PROGRAM:\n         SPACE\nVTOCECB  DC    F'0'            EVENT CONTROL BLOCK\n         SPACE 3\n* BUFFER FOR JFCB AND DCB EXIT LIST:\n         SPACE\nJFCBADDR DS    0F\n         DC    X'87'\n         DC    AL3(JFCB)\n         SPACE\nJFCB     DS    0D\n         DS    CL176\n         SPACE\nJFCBDSNM EQU   JFCB            DATA SET NAME\nJFCBTSDM EQU   JFCB+52            INDICATE NO RE-WRITE DURING OPEN\nJFCBVOLS EQU   JFCB+118        VOLUME SERIAL NUMBER\n         SPACE 3\nDS4      DSECT\n         IECSDSL1  4          DSECT FOR FORMAT 4 DSCB              DCL\n         SPACE 6\n         END\n         MACRO\n&SYMBOL  XPROPEN  &WA,&MAXLINE=0,&PAGENO=0,&PAGEWID=0,&PAGELEN=0,      X\n               &TIME=0,&DATE=0,&DDNAME=SYSPRINT,&IHBPARM=56\n.* MACRO TO EXECUTE AN 'OPEN' OR 'MODIFY' CALL TO 'XPRNTSUB'.\n         LCLC  &TAG\n&TAG     SETC  'IHB&SYSNDX'\n         AIF   ('&SYMBOL' EQ '').T1\n&SYMBOL  DS    0H\n.T1      AIF   ('&MAXLINE'(1,1) NE '(').T2\n         ST    &MAXLINE(1),&TAG.A      STORE IN PARM LIST\n.T2      AIF   ('&PAGENO'(1,1) NE '(').T3\n         STH   &PAGENO(1),&TAG.A+4     STORE IN PARM LIST\n.T3      AIF   ('&PAGEWID'(1,1) NE '(').T4\n         STC   &PAGEWID(1),&TAG.A+6    STORE IN PARM LIST\n.T4      AIF   ('&PAGELEN'(1,1) NE '(').T5\n         STC   &PAGELEN(1),&TAG.A+7    STORE IN PARM LIST\n.T5      AIF   ('&TIME'(1,1) NE '(').T6\n         ST    &TIME(1),&TAG.A+8       STORE IN PARM LIST\n.T6      AIF   ('&DATE'(1,1) NE '(').T7\n         ST    &DATE(1),&TAG.A+12      STORE IN PARM LIST\n.T7      AIF   ('&DDNAME'(1,1) NE '(').CNOP\n         MVC   &TAG.A+16(8),0(&DDNAME(1))  STORE IN PARM LIST\n.CNOP    CNOP  0,4\n         BAL   1,&TAG.L        LOAD PARM LIST ADDRESS\n.P1      AIF   ('&MAXLINE'(1,1) EQ '(').PR1\n&TAG.A   DC    A(&MAXLINE)             PRINT OUTPUT LIMIT\n         AGO   .P2\n.PR1     ANOP\n&TAG.A   DC    A(0)                    PRINT OUTPUT LIMIT\n.P2      AIF   ('&PAGENO'(1,1) EQ '(').PR2\n         DC    AL2(&PAGENO)            PAGE NUMBER\n         AGO   .P3\n.PR2     DC    AL2(0)                  PAGE NUMBER\n.P3      AIF   ('&PAGEWID'(1,1) EQ '(').PR3\n         DC    AL1(&PAGEWID)           PAGE WIDTH\n         AGO   .P4\n.PR3     DC    AL1(0)                  PAGE WIDTH\n.P4      AIF   ('&PAGELEN'(1,1) EQ '(').PR4\n         DC    AL1(&PAGELEN)           PAGE LENGTH\n         AGO   .P5\n.PR4     DC    AL1(0)                  PAGE LENGTH\n.P5      AIF   ('&TIME'(1,1) EQ '(').PR5\n         DC    A(&TIME)                ADDRESS OF TIME\n         AGO   .P6\n.PR5     DC    A(0)                    ADDRESS OF TIME\n.P6      AIF   ('&DATE'(1,1) EQ '(').PR6\n         DC    A(&DATE)                ADDRESS OF DATE\n         AGO   .P7\n.PR6     DC    A(0)                    ADDRESS OF DATE\n.P7      AIF   ('&IHBPARM' NE '56').VCON\n         AIF   ('&DDNAME'(1,1) EQ '(').PR7\n         DC    CL8'&DDNAME'            DDNAME FOR DATA SET\n         AGO   .VCON\n.PR7     DC    CL8' '                  DDNAME FOR DATA SET\n.VCON    ANOP\n&TAG.L   XPRINNRA  &WA,&IHBPARM\n         MEND\n         MACRO\n&SYMBOL  XPRSPACE  &WA,&LINES=1,&COND=\n.* MACRO TO EXECUTE A SPACE CALL TO 'XPRNTSUB'.\n         LCLA  &N,&B6,&B7\n         LCLC  &TAG,&SYM\n&SYM     SETC  '&SYMBOL'\n&TAG     SETC  'IHB&SYSNDX'\n.LOOP    ANOP\n&N       SETA  &N+1\n         AIF   (&N GT N'&COND).LDONE\n.TST1    AIF   ('&COND(&N)' NE 'NOEJ').TST2\n&B6      SETA  1\n         AGO   .LOOP\n.TST2    AIF   ('&COND(&N)' NE 'ATHOF').TST3\n&B7      SETA  1\n         AGO   .LOOP\n.TST3    MNOTE 4,'OPERAND &COND(&N) AFTER KEYWORD COND IS ILLEGAL'\n         AGO   .LOOP\n.LDONE   CNOP  2,4\n         AIF   ('&LINES'(1,1) NE '(').NOTREG1\n&SYM     STC   &LINES(1),&TAG.A+1      STORE INTO PARM LIST\n&SYM     SETC  ''\n.NOTREG1 ANOP\n&SYM     BAL   1,&TAG.L                LOAD PARM LIST ADDRESS\n&TAG.A   DC    B'000000&B6&B7'         OPTION BITS\n         AIF   ('&LINES'(1,1) NE '(').NOTREG2\n         DC    X'00'                   SPACING AMOUNT\n         AGO   .VCON\n.NOTREG2 DC    AL1(&LINES)             SPACING AMOUNT\n.VCON    ANOP\n&TAG.L   XPRINNRA  &WA,44\n         MEND\n         MACRO\n&SYMBOL  XPRCLOSE  &WA\n.* MACRO TO EXECUTE A CLOSE CALL TO 'XPRNTSUB'.\n         CNOP  0,4\n&SYMBOL  B     *+8                     BRANCH AROUND ADDRESS\n         XPRINNRA  &WA,68\n         MEND\n         MACRO\n&SYMBOL  XPRDCB  &DDNAME=SYSPRINT,&BLKSIZE=0\n         LCLC  &TAG\n.* MACRO TO GENERATE A WORK AREA FOR A PRINTER DATA SET, CONTAINING\n.* A SAVE AREA, THE DCB, OPEN AND CLOSE PARAMETER LISTS, AND VARIOUS\n.* CELLS AND SWITCHES.\n&TAG     SETC  '&SYMBOL'\n         AIF   (T'&SYMBOL NE 'O').TOK  TEST IF NAME SUPPLIED\n&TAG     SETC  'XPRDCB01'              SUPPLY STANDARD PRDCB NAME\n.TOK     ANOP\n&TAG     DS    0D                      ALIGN ON DOUBLE-WORD BOUNDARY\n         DS    18F                     STANDARD SAVE AREA\n         SPACE\n*        DCB   DDNAME=&DDNAME,DSORG=PS,RECFM=VBM,LRECL=137,           X\n*              BLKSIZE=&BLKSIZE,MACRF=PL,BFTEK=S,BUFNO=2\nIHB&SYSNDX DCB DDNAME=&DDNAME,DSORG=PS,RECFM=VBM,LRECL=137,            X\n               BLKSIZE=&BLKSIZE,MACRF=PL,BFTEK=S,BUFNO=2\n         SPACE\n* PARAMETER LISTS FOR OPEN AND CLOSE:\n         SPACE\n         OPEN  (IHB&SYSNDX,(OUTPUT,LEAVE)),MF=L  PARM LIST FOR OPEN\n         SPACE\n         CLOSE (IHB&SYSNDX,LEAVE),MF=L PARM LIST FOR CLOSE\n         SPACE\n* WORK CELLS AND VARIABLE STORAGE:\n         SPACE\n         DS    1D                      WORK CELL\n         DS    3F                      WORK CELLS\n         DS    1A                      PAGE HEADING PARM LIST ADDRESS\n         DS    1F                      MAXIMUM NUMBER OF OUTPUT LINES\n         DS    1H                      PAGE WIDTH\n         DS    1H                      PAGE LENGTH\n         DS    1H                      PAGE NUMBER\n         DS    1H                      PAGE BALANCE\n         DS    1X                      SWITCHES\n         DS    CL24                    DATE & TIME FOR PAGE HEADING\n         SPACE 2\n         MEND\n         MACRO\n&SYMBOL  XPREJECT  &WA,&COND=\n.* MACRO TO EXECUTE AN EJECT CALL TO 'XPRNTSUB'.\n         LCLC  &TAG,&SYM,&OPT,&R\n         LCLA  &K\n&SYM     SETC  '&SYMBOL'\n&TAG     SETC  'IHB&SYSNDX'\n         CNOP  2,4\n.TST1    AIF   ('&COND' NE '').TST2\n&OPT     SETC  'F000'\n         AGO   .SIMPLE\n.TST2    AIF   ('&COND' NE 'ATHOF').TSTC\n&OPT     SETC  'F100'\n.SIMPLE  ANOP\n&SYM     BAL   1,&TAG.L                LOAD PARM ADDRESS\n         DC    XL2'&OPT'               OPTION BITS\n         AGO   .VCON\n.TSTC    AIF   ('&COND(1)' NE 'EQ').NE\n&OPT     SETC  '80'\n.NE      AIF   ('&COND(1)' NE 'NE').LT\n&OPT     SETC  '70'\n.LT      AIF   ('&COND(1)' NE 'LT').GT\n&OPT     SETC  '40'\n.GT      AIF   ('&COND(1)' NE 'GT').LE\n&OPT     SETC  '20'\n.LE      AIF   ('&COND(1)' NE 'LE').GE\n&OPT     SETC  'C0'\n.GE      AIF   ('&COND(1)' NE 'GE').NOT\n&OPT     SETC  'A0'\n.NOT     AIF   ('&OPT' NE '').COK\n         MNOTE 4,'COND OPERAND &COND(1) ILLEGAL'\n.COK     AIF   ('&COND(2)' NE '').C2OK\n         MNOTE 4,'COND TEST QUANTITY MISSING'\n         AGO   .NOTREG\n.C2OK    AIF   ('&COND(2)'(1,1) NE '(').NOTREG\n&K       SETA  K'&COND(2)-2\n&R       SETC  '&COND(2)'(2,&K)\n&SYM     STC   &R,&TAG.A               STORE INTO PARM LIST\n&SYM     SETC  ''\n.NOTREG  ANOP\n&SYM     BAL   1,&TAG.L                LOAD PARM ADDRESS\n         DC    XL1'&OPT'               CONDITION MASK\n         AIF   ('&COND(2)' EQ '').NOTREG2\n         AIF   ('&COND(2)'(1,1) NE '(').NOTREG2\n&TAG.A   DC    AL1(0)                  TEST QUANTITY\n         AGO   .VCON\n.NOTREG2 DC    AL1(&COND(2))           TEST QUANTITY\n.VCON    ANOP\n&TAG.L   XPRINNRA  &WA,92\n         MEND\n         MACRO\n&SYMBOL  XPRHEAD  &WA,&LIST=\n.* MACRO TO PRESENT A LIST OF PRINT LINE DESCRIPTORS FOR PAGE HEADINGS\n.* TO 'XPRNTSUB'.\n&SYMBOL  XPRLIST  &WA,LIST=&LIST,IHBPARM=80\n         MEND\n         MACRO\n&TAG     XPRINNRA  &WA,&IHBPARM\n.* INNER MACRO USED IN CALLS TO 'XPRNTSUB'\n         DC    V(XPRNTSUB)             PRINTING SUBROUTINE ADDRESS\n&TAG     L     15,*-4                  LOAD ENTRY POINT\n         AIF   ('&WA' NE '').WOK\n         LA    0,XPRDCB01              LOAD STANDARD WORK AREA ADDRESS\n         AGO   .BAL\n.WOK     AIF   ('&WA' EQ '(0)').BAL\n         AIF   ('&WA'(1,1) EQ '(').REG\n         LA    0,&WA                   LOAD WORK AREA ADDRESS\n         AGO   .BAL\n.REG     LR    0,&WA(1)                LOAD WORK AREA ADDRESS\n.BAL     BAL   14,&IHBPARM.(15)        CALL PRINT SUBROUTINE\n         MEND\n         MACRO\n&SYMBOL  XPRLDEF  &TEXT=,&LENGTH=132,&OFFSET=0,&SPA=1,&SPB=0\n.* MACRO TO DEFINE PRINT LINE DESCRIPTOR BLOCKS (\"PLD\" BLOCKS) FOR\n.* THE PRINTING SUBROUTINE \"XPRNTSUB\".\n         LCLA  &N\n         LCLC  &B3,&B6,&B7\n         ACTR  25                      JUST IN CASE\n&B3      SETC  '0'\n&B6      SETC  '0'\n&B7      SETC  '0'\n.* PROCESS OPTIONS IN SPA OPERAND:\n.TSTA1   AIF   ('&SPA(2)' EQ '').TSTB1\n         AIF   ('&SPA(2)' NE 'NOEJ').TSTA2\n&B3      SETC  '1'\n         AGO   .TSTB1\n.TSTA2   MNOTE 4,'OPERAND &SPA(2) AFTER KEYWORD SPA IS ILLEGAL'\n.* PROCESS OPTIONS IN SPB OPERAND:\n.TSTB1   ANOP\n&N       SETA  2\n.TSTB5   AIF   ('&SPB(&N)' NE 'NOEJ').TSTB2\n&B7      SETC  '1'\n         AGO   .TSTB4\n.TSTB2   AIF   ('&SPB(&N)' NE 'ATHOF').TSTB3\n&B6      SETC  '1'\n         AGO   .TSTB4\n.TSTB3   AIF   ('&SPB(&N)' EQ '').TSTB4\n         MNOTE 4,'OPERAND &SPB(&N) AFTER KEYWORD SPB IS ILLEGAL'\n.TSTB4   ANOP\n&N       SETA  &N+1\n         AIF   (&N LE 3).TSTB5\n.IFTEXT  AIF   ('&TEXT' NE '').TOK\n         MNOTE 4,'TEXT ADDRESS MISSING'\n.TOK     ANOP\n&SYMBOL  DS    0F                      ALIGN ON FULL-WORD BOUNDARY\n         DC    BL1'000&B3.00&B6&B7'    OPTION BITS\n         DC    AL3(&TEXT)              TEXT ADDRESS\n         DC    AL1(&LENGTH)            TEXT LENGTH\n         DC    AL1(&OFFSET)            MARGIN OFFSET\n.TESTB   AIF   ('&SPB(1)' EQ 'EJECT').BSKIP\n         AIF   ('&SPB(1)' EQ 'SKIP').BSKIP\n         DC    AL1(&SPB(1))            PRE-SPACING\n         AGO   .TESTA\n.BSKIP   ANOP\n         DC    AL1(255)                EJECT BEFORE PRINTING\n.TESTA   AIF   ('&SPA(1)' EQ 'EJECT').ASKIP\n         AIF   ('&SPA(1)' EQ 'SKIP').ASKIP\n         DC    AL1(&SPA(1))            POST-SPACING\n         MEXIT\n.ASKIP   ANOP\n         DC    AL1(255)                EJECT AFTER PRINTING\n         MEND\n         MACRO\n&SYMBOL  XPRLIST  &WA,&LIST=,&IHBPARM=32\n.* MACRO TO DELIVER A LIST OF PRINT LINE DESCRIPTORS TO 'XPRNTSUB'.\n         LCLA  &N,&K,&D\n         LCLC  &TAG,&SYM,&R\n         ACTR  100\n&SYM     SETC  '&SYMBOL'\n&TAG     SETC  'IHB&SYSNDX'\n         AIF   ('&LIST' NE '').LOK\n         MNOTE 8,'LIST OPERAND MUST BE SUPPLIED'\n         MEXIT\n.LOK     CNOP  0,4\n         AIF   ('&LIST' NE '(1)').STLOOP\n&SYMBOL  B     &TAG.L                  BRANCH AROUND ADDRESS\n         AGO   .VCON\n.STLOOP  ANOP\n&N       SETA  &N+1\n         AIF   (&N GT N'&LIST).STDONE\n         AIF   ('&LIST(&N)'(1,1) NE '(').STLOOP\n&K       SETA  K'&LIST(&N)-2\n&R       SETC  '&LIST(&N)'(2,&K)\n&D       SETA  4*(&N-1)\n&SYM     ST    &R,&TAG.A+&D            STORE INTO PARM LIST\n&SYM     SETC  ''\n         AIF   (&N NE N'&LIST).STLOOP\n         OI    &TAG.A+&D,X'80'         SET END-OF-LIST BIT\n.STDONE  ANOP\n&SYM     BAL   1,&TAG.L                LOAD PARM LIST ADDRESS\n&SYM     SETC  '&TAG.A'\n&N       SETA  0\n.LOOP    ANOP\n&N       SETA  &N+1\n         AIF   (&N GT N'&LIST).VCON\n         AIF   ('&LIST(&N)'(1,1) NE '(').NOTREG\n&SYM     DC    A(0)\n&SYM     SETC  ''\n         AGO   .LOOP\n.NOTREG  AIF   (&N EQ N'&LIST).LAST\n&SYM     DC    A(&LIST(&N))\n&SYM     SETC  ''\n         AGO   .LOOP\n.LAST    ANOP\n&SYM     DC    X'80'                   END-OF-LIST BIT\n         DC    AL3(&LIST(&N))\n.VCON    ANOP\n&TAG.L   XPRINNRA  &WA,&IHBPARM\n         MEND\n         MACRO\n&SYMBOL  XPRMOD  &WA,&MAXLINE=0,&PAGENO=0,&PAGEWID=0,&PAGELEN=0,       X\n               &TIME=0,&DATE=0\n.* MACRO TO EXECUTE A MODIFY CALL TO 'XPRINTSUB'.\n&SYMBOL  XPROPEN  &WA,MAXLINE=&MAXLINE,PAGENO=&PAGENO,PAGEWID=&PAGEWID,X\n               PAGELEN=&PAGELEN,TIME=&TIME,DATE=&DATE,IHBPARM=104\n         MEND\n         MACRO\n&SYMBOL  XPRNTLIN  &WA,&TEXT=00,&LENGTH=132,&OFFSET=0,&SPB=0,&SPA=1\n         LCLA  &N\n         LCLC  &B3,&B6,&B7,&T,&R\n         ACTR  25\n&T       SETC  'IHB&SYSNDX'\n&B3      SETC  '0'\n&B6      SETC  '0'\n&B7      SETC  '0'\n.* PROCESS OPTIONS IN SPA OPERAND:\n.TSTA1   AIF   ('&SPA(2)' EQ '').TSTB1\n         AIF   ('&SPA(2)' NE 'NOEJ').TSTA2\n&B3      SETC  '1'\n         AGO   .TSTB1\n.TSTA2   MNOTE 4,'OPERAND &SPA(2) AFTER KEYWORD SPA IS ILLEGAL'\n.* PROCESS OPTIONS IN SPB OPERAND:\n.TSTB1   ANOP\n&N       SETA  2\n.TSTB5   AIF   ('&SPB(&N)' NE 'NOEJ').TSTB2\n&B7      SETC  '1'\n         AGO   .TSTB4\n.TSTB2   AIF   ('&SPB(&N)' NE 'ATHOF').TSTB3\n&B6      SETC  '1'\n         AGO   .TSTB4\n.TSTB3   AIF   ('&SPB(&N)' EQ '').TSTB4\n         MNOTE 4,'OPERAND &SPB(&N) AFTER KEYWORD SPB IS ILLEGAL'\n.TSTB4   ANOP\n&N       SETA  &N+1\n         AIF   (&N LE 3).TSTB5\n.* GENERATE STORE INSTRUCTIONS IF REGISTER NOTATION IS USED:\n         CNOP  0,4\n         AIF   ('&SYMBOL' EQ '').IFR1\n&SYMBOL  DS    0H\n.IFR1    AIF   ('&TEXT' NE '00').TXTOK\n         MNOTE 4,'TEXT ADDRESS MUST BE SUPPLIED'\n.TXTOK   AIF   ('&TEXT'(1,1) NE '(').IFR2\n         ST    &TEXT(1),&T.A           STORE TEXT ADDRESS\n         MVI   &T.A,B'000&B3.00&B6&B7' INSERT OPTION BITS\n.IFR2    AIF   ('&LENGTH'(1,1) NE '(').IFR3\n         STC   &LENGTH(1),&T.A+4       STORE TEXT LENGTH\n.IFR3    AIF   ('&OFFSET'(1,1) NE '(').IFR4\n         STC   &OFFSET(1),&T.A+5       STORE MARGIN OFFSET\n.IFR4    AIF   ('&SPB(1)'(1,1) NE '(').IFR5\n&N       SETA  K'&SPB(1)-2\n&R       SETC  '&SPB(1)'(2,&N)\n         STC   &R,&T.A+6               STORE PRE-SPACING\n.IFR5    AIF   ('&SPA(1)'(1,1) NE '(').LOAD1\n&N       SETA  K'&SPA(1)-2\n&R       SETC  '&SPA(1)'(2,&N)\n         STC   &R,&T.A+7               STORE POST-SPACING\n.* LOAD REG 1 AND GENERATE PLD LIST ADDRESS:\n.LOAD1   BAL   1,&T.L                  LOAD PARM ADDRESS\n         DC    X'80'                   MARK END OF ADDRESS LIST\n         DC    AL3(&T.A)               ADDRESS OF PLD\n.* GENREATE PLD PARAMETERS TO DESCRIBE THE PRINT LINE:\n.IFR11   AIF   ('&TEXT'(1,1) NE '(').NOTR11\n&T.A     DC    A(0)                    TEXT ADDRESS & OPTION BITS\n         AGO   .IFR12\n.NOTR11  ANOP\n&T.A     DC    B'000&B3.00&B6&B7'      OPTION BITS\n         DC    AL3(&TEXT)              TEXT ADDRESS\n.IFR12   AIF   ('&LENGTH'(1,1) NE '(').NOTR12\n         DC    AL1(0)                  TEXT LENGTH\n         AGO   .IFR13\n.NOTR12  DC    AL1(&LENGTH)            TEXT LENGTH\n.IFR13   AIF   ('&OFFSET'(1,1) NE '(').NOTR13\n         DC    AL1(0)                  MARGIN OFFSET\n         AGO   .IFR14\n.NOTR13  DC    AL1(&OFFSET)            MARGIN OFFSET\n.IFR14   AIF   ('&SPB(1)'(1,1) NE '(').NOTR14\n         DC    AL1(0)                  PRE-SPACING\n         AGO   .IFR15\n.NOTR14  AIF   ('&SPB(1)' EQ 'EJECT').BSKIP\n         AIF   ('&SPB(1)' EQ 'SKIP').BSKIP\n         DC    AL1(&SPB(1))            PRE-SPACING\n         AGO   .IFR15\n.BSKIP   DC    AL1(255)                SKIP BEFOR PRINTING\n.IFR15   AIF   ('&SPA(1)'(1,1) NE '(').NOTR15\n         DC    AL1(0)                  POST-SPACING\n         AGO   .VCON\n.NOTR15  AIF   ('&SPA(1)' EQ 'EJECT').ASKIP\n         AIF   ('&SPA(1)' EQ 'SKIP').ASKIP\n         DC    AL1(&SPA(1))            POST-SPACING\n         AGO   .VCON\n.ASKIP   DC    AL1(255)                SKIP AFTER PRINTING\n.VCON    ANOP\n&T.L    XPRINNRA  &WA,32\n         MEND\nDTED     TITLE 'XDATEDIT--CONVERT JULIAN DATE TO MONTH-DAY-YEAR'\n* STATUS:  VERSION 1, 25 JUNE 1968.\n         PUNCH '  SETSSI  01008177'\n         SPACE\n* AUTHOR:  R. F. MORSE, MIT INSTRUMENTATION LABORATORY\n         SPACE\n* FUNCTION/OPERATION:  EDITS A PACKED DECIMAL DATE IN YEAR-DAY FORM TO\n*        EBCDIC MONTH-DAY-YEAR FORM.  CORRECTS FOR LEAP YEARS AND\n*        FOR THE TURN OF A CENTURY.\n         SPACE\n* ENTRY POINTS:  ENTER AT \"XDATEDIT\" VIA BALR 14,15 WITH REG 13 SET\n*        TO A STANDARD 18-WORD SAVE AREA.  REGISTER 1 POINTS TO A\n*        PARAMETER LIST CONTAINING ONE ADDRESS.\n         SPACE\n* INPUT:  THE ADDRESS IN THE PARAMETER LIST IS THAT OF AN ALIGNED\n*        DOUBLE WORD CONTAINING THE ARGUMENT IN PACKED DECIMAL AS:\n*        X'0000000000YYDDD+'.\n         SPACE\n* OUTPUT:  THE RESULT IS RETURNED IN THE SAME DOUBLE WORD IN EBCDIC AS\n*        C'MM/DD/YY'.\n         SPACE\n* DATA SETS:  NONE.\n         SPACE\n* EXTERNAL ROUTINES:  NONE.\n         SPACE\n* EXITS-NORMAL:  RETURN VIA REG 14 WITH RETURN CODE 0 IN REG 15.\n         SPACE\n* EXITS-ERROR:  IF THE DAY NUMBER IS ZERO OR EXCEEDS THE MAXIMUM VALUE\n*        APPROPRIATE TO THE YEAR, RETURN VIA REG 14 WITH RETURN CODE 4\n*        IN REG 15 AND THE RESULT FIELD SET TO C' YY.DDD '.\n         SPACE\n* TABLES/WORK AREAS:  NONE.\n         SPACE\n* ATTRIBUTES:  REENTRANT, READ ONLY.\n         SPACE\n* NOTES:  NONE.\n         EJECT\n* DUMMY SECTION TO DEFINE THE ARGUMENT AND RETURN FIELD.\n         SPACE\nDUMMY    DSECT\nDWORD    DS    1D\n         SPACE 6\n* BEGIN CONTROL SECTION HERE.  DEFINE REGISTER TAGS.\n         SPACE\nXDATEDIT CSECT\n         SPACE\nRBASE    EQU   12              LOCAL BASE REGISTER\nRDSECT   EQU   11              BASE REG FOR ARGUMENT/RESULT\nRPARM    EQU   1               PARAMETER LIST POINTER\nRARGSAVE EQU   2               TO SAVE ORIGINAL PACKED ARGUMENT\nRMONTH   EQU   3\nRDAY     EQU   4               RDAY AND RYEAR ARE AN EVEN/ODD\nRYEAR    EQU   5                 PAIR FOR DIVISION\nRWORK    EQU   6\nRLIST    EQU   7\n         SPACE 6\n* ENTER HERE.  SAVE GENERAL REGISTERS AND SET UP BASE REGISTERS.\n         SPACE\n         SAVE  (14,12),,XDATEDIT-01008177\n         SPACE\n         BALR  RBASE,0\n         USING *,RBASE\n         L     RDSECT,0(RPARM)         LOAD ARGUMENT ADDRESS\n         USING DWORD,RDSECT\n         EJECT\n* CONVERT YEAR AND DAY TO BINARY, AND SEPARATE BY DIVISION.\n         SPACE\n         MVI   DWORD,X'00'             CLEAR HIGH DECIMAL DIGITS\n         MVC   DWORD+1(4),DWORD          IN ARG TO ZEROS\n         OI    DWORD+7,X'0F'           FORCE PLUS SIGN\n         L     RARGSAVE,DWORD+4        SAVE ARGUMENT FOR 'BADDATE'\n         SPACE\n         CVB   RYEAR,DWORD             CONVERT YYDDD TO BINARY\n         SR    RDAY,RDAY               CLEAR HIGH-ORDER DIVIDEND\n         D     RDAY,F1000              QUOTIENT=YEAR; REMAINDER=DAY\n         SPACE\n* CHECK FOR LEAP YEAR, AND LOAD RLIST WITH BASE ADDRESS OF APPROPRIATE\n* LIST OF MONTH SIZES.\n         SPACE\nDAYOK    DS    0H\n         LA    RLIST,STDLIST           POINT RLIST TO STANDARD MONTHS\n         LTR   RWORK,RYEAR             LOAD BINARY YEAR NUMBER\n         BZ    NOTLEAP                 BR IF TURN OF CENTURY\n         N     RWORK,=F'3'             TEST LOW TWO BITS\n         BC    4,NOTLEAP               BR IF NON-ZERO\n         LA    RLIST,LPYLIST           POINT RLIST TO LEAP-YEAR MONTHS\nNOTLEAP  DS    0H\n         SPACE\n* TEST DAY NUMBER AGAINST ZERO AND THE UPPER LIMIT DETERMINED BY\n* THE YEAR NUMBER.\n         SPACE\n         LTR   RDAY,RDAY               TEST FOR ZERO\n         BZ    BADDATE                 BR IF SO\n         CH    RDAY,0(0,RLIST)         TEST FOR UPPER LIMIT\n         BH    BADDATE                 BR IF TOO LARGE\n         SPACE\n* REDUCE JULIAN DAY TO DAY-OF-MONTH, ACCUMULATING MONTH NUMBER.\n         SPACE\n         LA    RMONTH,1                INITIAL MONTH NUMBER\n         SR    RWORK,RWORK\nDAYLOOP  IC    RWORK,1(RMONTH,RLIST)   LENGTH OF MONTH INTO RWORK\n         CR    RDAY,RWORK              TEST IF DAY IN THIS MONTH\n         BNH   DAYDONE                 BR IF DAY LESS THAN MONTH SIZE\n         SR    RDAY,RWORK              REDUCE DAY BY LENGTH OF MONTH\n         LA    RMONTH,1(RMONTH)        INCREMENT MONTH\n         B     DAYLOOP\nDAYDONE  DS    0H\n         SPACE\n* COMBINE MONTH, DAY, AND YEAR IN BINARY IN ONE REGISTER, MULTIPLYING\n* EACH BY A FACTOR TO PLACE IT PROPERLY IN THE DECIMAL RESULT.\n* THE TRICK IS THAT  1000(1000(MONTH)+DAY)+YEAR  GIVES  MM0DD0YY  WHEN\n* CONVERTED TO DECIMAL.  AFTER UNPACKING, THE ZEROS ARE REPLACED BY\n* SLASHES.\n         SPACE\n         MH    RMONTH,H1000\n         AR    RMONTH,RDAY\n         MH    RMONTH,H1000\n         AR    RMONTH,RYEAR\n         CVD   RMONTH,DWORD\n         MVC   DWORD(5),DWORD+3        MOVE OVER FOR UNPACKING\n         UNPK  DWORD(8),DWORD(5)       CONVERT TO ALPHA\n         OI    DWORD+7,X'F0'           COVER UP SIGN\n         MVI   DWORD+2,C'/'            INSERT SLASHES\n         MVI   DWORD+5,C'/'\n         SR    15,15                   SET NORMAL RETURN CODE OF 0\n         SPACE\nEXIT     RETURN  (14,12),T,RC=(15)     RETURN TO CALLER\n         SPACE 2\n* FOR ARGUMENTS WHOSE DAY NUMBER IS ZERO OR TOO LARGE, RETURN IN\n* 'DWORD' THE EDITED VALUE  C' YY.DDD ' AND SET A RETURN CODE OF 4.\n         SPACE\nBADDATE  ST    RARGSAVE,DWORD          RESTORE ORIGINAL PACKED ARGUMENT\n         UNPK  DWORD+2(5),DWORD+1(3)   UNPACK INTO ALPHA\n         MVC   DWORD+1(2),DWORD+2      SHIFT YEAR 1 LEFT\n         MVI   DWORD,C' '              APPLY COSMETICS\n         MVI   DWORD+3,C'.'\n         MVI   DWORD+7,C' '\n         LA    15,4                    SET RETURN CODE\n         B     EXIT\n         EJECT\n* LISTS OF MONTH SIZES FOR STANDARD AND LEAP YEARS:\n         SPACE\n         SPACE\nSTDLIST  DC    H'365'          DAY LIMIT FOR STANDARD YEARS\n         DC    AL1(31)\n         DC    AL1(28)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         SPACE\nLPYLIST  DC    H'366'          DAY LIMIT FOR LEAP YEARS\n         DC    AL1(31)\n         DC    AL1(29)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         DC    AL1(30)\n         DC    AL1(31)\n         SPACE\nF1000    DC    F'1000'\nH1000    EQU   F1000+2\n         LTORG\n         SPACE\n         END\n         MACRO\n&SYMBOL  XPROPEN  &WA,&MAXLINE=0,&PAGENO=0,&PAGEWID=0,&PAGELEN=0,      X\n               &TIME=0,&DATE=0,&DDNAME=SYSPRINT,&IHBPARM=56\n.* MACRO TO EXECUTE AN 'OPEN' OR 'MODIFY' CALL TO 'XPRNTSUB'.\n         LCLC  &TAG\n&TAG     SETC  'IHB&SYSNDX'\n         AIF   ('&SYMBOL' EQ '').T1\n&SYMBOL  DS    0H\n.T1      AIF   ('&MAXLINE'(1,1) NE '(').T2\n         ST    &MAXLINE(1),&TAG.A      STORE IN PARM LIST\n.T2      AIF   ('&PAGENO'(1,1) NE '(').T3\n         STH   &PAGENO(1),&TAG.A+4     STORE IN PARM LIST\n.T3      AIF   ('&PAGEWID'(1,1) NE '(').T4\n         STC   &PAGEWID(1),&TAG.A+6    STORE IN PARM LIST\n.T4      AIF   ('&PAGELEN'(1,1) NE '(').T5\n         STC   &PAGELEN(1),&TAG.A+7    STORE IN PARM LIST\n.T5      AIF   ('&TIME'(1,1) NE '(').T6\n         ST    &TIME(1),&TAG.A+8       STORE IN PARM LIST\n.T6      AIF   ('&DATE'(1,1) NE '(').T7\n         ST    &DATE(1),&TAG.A+12      STORE IN PARM LIST\n.T7      AIF   ('&DDNAME'(1,1) NE '(').CNOP\n         MVC   &TAG.A+16(8),0(&DDNAME(1))  STORE IN PARM LIST\n.CNOP    CNOP  0,4\n         BAL   1,&TAG.L        LOAD PARM LIST ADDRESS\n.P1      AIF   ('&MAXLINE'(1,1) EQ '(').PR1\n&TAG.A   DC    A(&MAXLINE)             PRINT OUTPUT LIMIT\n         AGO   .P2\n.PR1     ANOP\n&TAG.A   DC    A(0)                    PRINT OUTPUT LIMIT\n.P2      AIF   ('&PAGENO'(1,1) EQ '(').PR2\n         DC    AL2(&PAGENO)            PAGE NUMBER\n         AGO   .P3\n.PR2     DC    AL2(0)                  PAGE NUMBER\n.P3      AIF   ('&PAGEWID'(1,1) EQ '(').PR3\n         DC    AL1(&PAGEWID)           PAGE WIDTH\n         AGO   .P4\n.PR3     DC    AL1(0)                  PAGE WIDTH\n.P4      AIF   ('&PAGELEN'(1,1) EQ '(').PR4\n         DC    AL1(&PAGELEN)           PAGE LENGTH\n         AGO   .P5\n.PR4     DC    AL1(0)                  PAGE LENGTH\n.P5      AIF   ('&TIME'(1,1) EQ '(').PR5\n         DC    A(&TIME)                ADDRESS OF TIME\n         AGO   .P6\n.PR5     DC    A(0)                    ADDRESS OF TIME\n.P6      AIF   ('&DATE'(1,1) EQ '(').PR6\n         DC    A(&DATE)                ADDRESS OF DATE\n         AGO   .P7\n.PR6     DC    A(0)                    ADDRESS OF DATE\n.P7      AIF   ('&IHBPARM' NE '56').VCON\n         AIF   ('&DDNAME'(1,1) EQ '(').PR7\n         DC    CL8'&DDNAME'            DDNAME FOR DATA SET\n         AGO   .VCON\n.PR7     DC    CL8' '                  DDNAME FOR DATA SET\n.VCON    ANOP\n&TAG.L   XPRINNRA  &WA,&IHBPARM\n         MEND\n         MACRO\n&SYMBOL  XPRSPACE  &WA,&LINES=1,&COND=\n.* MACRO TO EXECUTE A SPACE CALL TO 'XPRNTSUB'.\n         LCLA  &N,&B6,&B7\n         LCLC  &TAG,&SYM\n&SYM     SETC  '&SYMBOL'\n&TAG     SETC  'IHB&SYSNDX'\n.LOOP    ANOP\n&N       SETA  &N+1\n         AIF   (&N GT N'&COND).LDONE\n.TST1    AIF   ('&COND(&N)' NE 'NOEJ').TST2\n&B6      SETA  1\n         AGO   .LOOP\n.TST2    AIF   ('&COND(&N)' NE 'ATHOF').TST3\n&B7      SETA  1\n         AGO   .LOOP\n.TST3    MNOTE 4,'OPERAND &COND(&N) AFTER KEYWORD COND IS ILLEGAL'\n         AGO   .LOOP\n.LDONE   CNOP  2,4\n         AIF   ('&LINES'(1,1) NE '(').NOTREG1\n&SYM     STC   &LINES(1),&TAG.A+1      STORE INTO PARM LIST\n&SYM     SETC  ''\n.NOTREG1 ANOP\n&SYM     BAL   1,&TAG.L                LOAD PARM LIST ADDRESS\n&TAG.A   DC    B'000000&B6&B7'         OPTION BITS\n         AIF   ('&LINES'(1,1) NE '(').NOTREG2\n         DC    X'00'                   SPACING AMOUNT\n         AGO   .VCON\n.NOTREG2 DC    AL1(&LINES)             SPACING AMOUNT\n.VCON    ANOP\n&TAG.L   XPRINNRA  &WA,44\n         MEND\n         MACRO\n&SYMBOL  XPRCLOSE  &WA\n.* MACRO TO EXECUTE A CLOSE CALL TO 'XPRNTSUB'.\n         CNOP  0,4\n&SYMBOL  B     *+8                     BRANCH AROUND ADDRESS\n         XPRINNRA  &WA,68\n         MEND\n         MACRO\n&SYMBOL  XPRDCB  &DDNAME=SYSPRINT,&BLKSIZE=0\n         LCLC  &TAG\n.* MACRO TO GENERATE A WORK AREA FOR A PRINTER DATA SET, CONTAINING\n.* A SAVE AREA, THE DCB, OPEN AND CLOSE PARAMETER LISTS, AND VARIOUS\n.* CELLS AND SWITCHES.\n&TAG     SETC  '&SYMBOL'\n         AIF   (T'&SYMBOL NE 'O').TOK  TEST IF NAME SUPPLIED\n&TAG     SETC  'XPRDCB01'              SUPPLY STANDARD PRDCB NAME\n.TOK     ANOP\n&TAG     DS    0D                      ALIGN ON DOUBLE-WORD BOUNDARY\n         DS    18F                     STANDARD SAVE AREA\n         SPACE\n*        DCB   DDNAME=&DDNAME,DSORG=PS,RECFM=VBM,LRECL=137,           X\n*              BLKSIZE=&BLKSIZE,MACRF=PL,BFTEK=S,BUFNO=2\nIHB&SYSNDX DCB DDNAME=&DDNAME,DSORG=PS,RECFM=VBM,LRECL=137,            X\n               BLKSIZE=&BLKSIZE,MACRF=PL,BFTEK=S,BUFNO=2\n         SPACE\n* PARAMETER LISTS FOR OPEN AND CLOSE:\n         SPACE\n         OPEN  (IHB&SYSNDX,(OUTPUT,LEAVE)),MF=L  PARM LIST FOR OPEN\n         SPACE\n         CLOSE (IHB&SYSNDX,LEAVE),MF=L PARM LIST FOR CLOSE\n         SPACE\n* WORK CELLS AND VARIABLE STORAGE:\n         SPACE\n         DS    1D                      WORK CELL\n         DS    3F                      WORK CELLS\n         DS    1A                      PAGE HEADING PARM LIST ADDRESS\n         DS    1F                      MAXIMUM NUMBER OF OUTPUT LINES\n         DS    1H                      PAGE WIDTH\n         DS    1H                      PAGE LENGTH\n         DS    1H                      PAGE NUMBER\n         DS    1H                      PAGE BALANCE\n         DS    1X                      SWITCHES\n         DS    CL24                    DATE & TIME FOR PAGE HEADING\n         SPACE 2\n         MEND\n         MACRO\n&SYMBOL  XPREJECT  &WA,&COND=\n.* MACRO TO EXECUTE AN EJECT CALL TO 'XPRNTSUB'.\n         LCLC  &TAG,&SYM,&OPT,&R\n         LCLA  &K\n&SYM     SETC  '&SYMBOL'\n&TAG     SETC  'IHB&SYSNDX'\n         CNOP  2,4\n.TST1    AIF   ('&COND' NE '').TST2\n&OPT     SETC  'F000'\n         AGO   .SIMPLE\n.TST2    AIF   ('&COND' NE 'ATHOF').TSTC\n&OPT     SETC  'F100'\n.SIMPLE  ANOP\n&SYM     BAL   1,&TAG.L                LOAD PARM ADDRESS\n         DC    XL2'&OPT'               OPTION BITS\n         AGO   .VCON\n.TSTC    AIF   ('&COND(1)' NE 'EQ').NE\n&OPT     SETC  '80'\n.NE      AIF   ('&COND(1)' NE 'NE').LT\n&OPT     SETC  '70'\n.LT      AIF   ('&COND(1)' NE 'LT').GT\n&OPT     SETC  '40'\n.GT      AIF   ('&COND(1)' NE 'GT').LE\n&OPT     SETC  '20'\n.LE      AIF   ('&COND(1)' NE 'LE').GE\n&OPT     SETC  'C0'\n.GE      AIF   ('&COND(1)' NE 'GE').NOT\n&OPT     SETC  'A0'\n.NOT     AIF   ('&OPT' NE '').COK\n         MNOTE 4,'COND OPERAND &COND(1) ILLEGAL'\n.COK     AIF   ('&COND(2)' NE '').C2OK\n         MNOTE 4,'COND TEST QUANTITY MISSING'\n         AGO   .NOTREG\n.C2OK    AIF   ('&COND(2)'(1,1) NE '(').NOTREG\n&K       SETA  K'&COND(2)-2\n&R       SETC  '&COND(2)'(2,&K)\n&SYM     STC   &R,&TAG.A               STORE INTO PARM LIST\n&SYM     SETC  ''\n.NOTREG  ANOP\n&SYM     BAL   1,&TAG.L                LOAD PARM ADDRESS\n         DC    XL1'&OPT'               CONDITION MASK\n         AIF   ('&COND(2)' EQ '').NOTREG2\n         AIF   ('&COND(2)'(1,1) NE '(').NOTREG2\n&TAG.A   DC    AL1(0)                  TEST QUANTITY\n         AGO   .VCON\n.NOTREG2 DC    AL1(&COND(2))           TEST QUANTITY\n.VCON    ANOP\n&TAG.L   XPRINNRA  &WA,92\n         MEND\n         MACRO\n&SYMBOL  XPRHEAD  &WA,&LIST=\n.* MACRO TO PRESENT A LIST OF PRINT LINE DESCRIPTORS FOR PAGE HEADINGS\n.* TO 'XPRNTSUB'.\n&SYMBOL  XPRLIST  &WA,LIST=&LIST,IHBPARM=80\n         MEND\n         MACRO\n&TAG     XPRINNRA  &WA,&IHBPARM\n.* INNER MACRO USED IN CALLS TO 'XPRNTSUB'\n         DC    V(XPRNTSUB)             PRINTING SUBROUTINE ADDRESS\n&TAG     L     15,*-4                  LOAD ENTRY POINT\n         AIF   ('&WA' NE '').WOK\n         LA    0,XPRDCB01              LOAD STANDARD WORK AREA ADDRESS\n         AGO   .BAL\n.WOK     AIF   ('&WA' EQ '(0)').BAL\n         AIF   ('&WA'(1,1) EQ '(').REG\n         LA    0,&WA                   LOAD WORK AREA ADDRESS\n         AGO   .BAL\n.REG     LR    0,&WA(1)                LOAD WORK AREA ADDRESS\n.BAL     BAL   14,&IHBPARM.(15)        CALL PRINT SUBROUTINE\n         MEND\n         MACRO\n&SYMBOL  XPRLDEF  &TEXT=,&LENGTH=132,&OFFSET=0,&SPA=1,&SPB=0\n.* MACRO TO DEFINE PRINT LINE DESCRIPTOR BLOCKS (\"PLD\" BLOCKS) FOR\n.* THE PRINTING SUBROUTINE \"XPRNTSUB\".\n         LCLA  &N\n         LCLC  &B3,&B6,&B7\n         ACTR  25                      JUST IN CASE\n&B3      SETC  '0'\n&B6      SETC  '0'\n&B7      SETC  '0'\n.* PROCESS OPTIONS IN SPA OPERAND:\n.TSTA1   AIF   ('&SPA(2)' EQ '').TSTB1\n         AIF   ('&SPA(2)' NE 'NOEJ').TSTA2\n&B3      SETC  '1'\n         AGO   .TSTB1\n.TSTA2   MNOTE 4,'OPERAND &SPA(2) AFTER KEYWORD SPA IS ILLEGAL'\n.* PROCESS OPTIONS IN SPB OPERAND:\n.TSTB1   ANOP\n&N       SETA  2\n.TSTB5   AIF   ('&SPB(&N)' NE 'NOEJ').TSTB2\n&B7      SETC  '1'\n         AGO   .TSTB4\n.TSTB2   AIF   ('&SPB(&N)' NE 'ATHOF').TSTB3\n&B6      SETC  '1'\n         AGO   .TSTB4\n.TSTB3   AIF   ('&SPB(&N)' EQ '').TSTB4\n         MNOTE 4,'OPERAND &SPB(&N) AFTER KEYWORD SPB IS ILLEGAL'\n.TSTB4   ANOP\n&N       SETA  &N+1\n         AIF   (&N LE 3).TSTB5\n.IFTEXT  AIF   ('&TEXT' NE '').TOK\n         MNOTE 4,'TEXT ADDRESS MISSING'\n.TOK     ANOP\n&SYMBOL  DS    0F                      ALIGN ON FULL-WORD BOUNDARY\n         DC    BL1'000&B3.00&B6&B7'    OPTION BITS\n         DC    AL3(&TEXT)              TEXT ADDRESS\n         DC    AL1(&LENGTH)            TEXT LENGTH\n         DC    AL1(&OFFSET)            MARGIN OFFSET\n.TESTB   AIF   ('&SPB(1)' EQ 'EJECT').BSKIP\n         AIF   ('&SPB(1)' EQ 'SKIP').BSKIP\n         DC    AL1(&SPB(1))            PRE-SPACING\n         AGO   .TESTA\n.BSKIP   ANOP\n         DC    AL1(255)                EJECT BEFORE PRINTING\n.TESTA   AIF   ('&SPA(1)' EQ 'EJECT').ASKIP\n         AIF   ('&SPA(1)' EQ 'SKIP').ASKIP\n         DC    AL1(&SPA(1))            POST-SPACING\n         MEXIT\n.ASKIP   ANOP\n         DC    AL1(255)                EJECT AFTER PRINTING\n         MEND\n         MACRO\n&SYMBOL  XPRLIST  &WA,&LIST=,&IHBPARM=32\n.* MACRO TO DELIVER A LIST OF PRINT LINE DESCRIPTORS TO 'XPRNTSUB'.\n         LCLA  &N,&K,&D\n         LCLC  &TAG,&SYM,&R\n         ACTR  100\n&SYM     SETC  '&SYMBOL'\n&TAG     SETC  'IHB&SYSNDX'\n         AIF   ('&LIST' NE '').LOK\n         MNOTE 8,'LIST OPERAND MUST BE SUPPLIED'\n         MEXIT\n.LOK     CNOP  0,4\n         AIF   ('&LIST' NE '(1)').STLOOP\n&SYMBOL  B     &TAG.L                  BRANCH AROUND ADDRESS\n         AGO   .VCON\n.STLOOP  ANOP\n&N       SETA  &N+1\n         AIF   (&N GT N'&LIST).STDONE\n         AIF   ('&LIST(&N)'(1,1) NE '(').STLOOP\n&K       SETA  K'&LIST(&N)-2\n&R       SETC  '&LIST(&N)'(2,&K)\n&D       SETA  4*(&N-1)\n&SYM     ST    &R,&TAG.A+&D            STORE INTO PARM LIST\n&SYM     SETC  ''\n         AIF   (&N NE N'&LIST).STLOOP\n         OI    &TAG.A+&D,X'80'         SET END-OF-LIST BIT\n.STDONE  ANOP\n&SYM     BAL   1,&TAG.L                LOAD PARM LIST ADDRESS\n&SYM     SETC  '&TAG.A'\n&N       SETA  0\n.LOOP    ANOP\n&N       SETA  &N+1\n         AIF   (&N GT N'&LIST).VCON\n         AIF   ('&LIST(&N)'(1,1) NE '(').NOTREG\n&SYM     DC    A(0)\n&SYM     SETC  ''\n         AGO   .LOOP\n.NOTREG  AIF   (&N EQ N'&LIST).LAST\n&SYM     DC    A(&LIST(&N))\n&SYM     SETC  ''\n         AGO   .LOOP\n.LAST    ANOP\n&SYM     DC    X'80'                   END-OF-LIST BIT\n         DC    AL3(&LIST(&N))\n.VCON    ANOP\n&TAG.L   XPRINNRA  &WA,&IHBPARM\n         MEND\n         MACRO\n&SYMBOL  XPRMOD  &WA,&MAXLINE=0,&PAGENO=0,&PAGEWID=0,&PAGELEN=0,       X\n               &TIME=0,&DATE=0\n.* MACRO TO EXECUTE A MODIFY CALL TO 'XPRINTSUB'.\n&SYMBOL  XPROPEN  &WA,MAXLINE=&MAXLINE,PAGENO=&PAGENO,PAGEWID=&PAGEWID,X\n               PAGELEN=&PAGELEN,TIME=&TIME,DATE=&DATE,IHBPARM=104\n         MEND\n         MACRO\n&SYMBOL  XPRNTLIN  &WA,&TEXT=00,&LENGTH=132,&OFFSET=0,&SPB=0,&SPA=1\n         LCLA  &N\n         LCLC  &B3,&B6,&B7,&T,&R\n         ACTR  25\n&T       SETC  'IHB&SYSNDX'\n&B3      SETC  '0'\n&B6      SETC  '0'\n&B7      SETC  '0'\n.* PROCESS OPTIONS IN SPA OPERAND:\n.TSTA1   AIF   ('&SPA(2)' EQ '').TSTB1\n         AIF   ('&SPA(2)' NE 'NOEJ').TSTA2\n&B3      SETC  '1'\n         AGO   .TSTB1\n.TSTA2   MNOTE 4,'OPERAND &SPA(2) AFTER KEYWORD SPA IS ILLEGAL'\n.* PROCESS OPTIONS IN SPB OPERAND:\n.TSTB1   ANOP\n&N       SETA  2\n.TSTB5   AIF   ('&SPB(&N)' NE 'NOEJ').TSTB2\n&B7      SETC  '1'\n         AGO   .TSTB4\n.TSTB2   AIF   ('&SPB(&N)' NE 'ATHOF').TSTB3\n&B6      SETC  '1'\n         AGO   .TSTB4\n.TSTB3   AIF   ('&SPB(&N)' EQ '').TSTB4\n         MNOTE 4,'OPERAND &SPB(&N) AFTER KEYWORD SPB IS ILLEGAL'\n.TSTB4   ANOP\n&N       SETA  &N+1\n         AIF   (&N LE 3).TSTB5\n.* GENERATE STORE INSTRUCTIONS IF REGISTER NOTATION IS USED:\n         CNOP  0,4\n         AIF   ('&SYMBOL' EQ '').IFR1\n&SYMBOL  DS    0H\n.IFR1    AIF   ('&TEXT' NE '00').TXTOK\n         MNOTE 4,'TEXT ADDRESS MUST BE SUPPLIED'\n.TXTOK   AIF   ('&TEXT'(1,1) NE '(').IFR2\n         ST    &TEXT(1),&T.A           STORE TEXT ADDRESS\n         MVI   &T.A,B'000&B3.00&B6&B7' INSERT OPTION BITS\n.IFR2    AIF   ('&LENGTH'(1,1) NE '(').IFR3\n         STC   &LENGTH(1),&T.A+4       STORE TEXT LENGTH\n.IFR3    AIF   ('&OFFSET'(1,1) NE '(').IFR4\n         STC   &OFFSET(1),&T.A+5       STORE MARGIN OFFSET\n.IFR4    AIF   ('&SPB(1)'(1,1) NE '(').IFR5\n&N       SETA  K'&SPB(1)-2\n&R       SETC  '&SPB(1)'(2,&N)\n         STC   &R,&T.A+6               STORE PRE-SPACING\n.IFR5    AIF   ('&SPA(1)'(1,1) NE '(').LOAD1\n&N       SETA  K'&SPA(1)-2\n&R       SETC  '&SPA(1)'(2,&N)\n         STC   &R,&T.A+7               STORE POST-SPACING\n.* LOAD REG 1 AND GENERATE PLD LIST ADDRESS:\n.LOAD1   BAL   1,&T.L                  LOAD PARM ADDRESS\n         DC    X'80'                   MARK END OF ADDRESS LIST\n         DC    AL3(&T.A)               ADDRESS OF PLD\n.* GENREATE PLD PARAMETERS TO DESCRIBE THE PRINT LINE:\n.IFR11   AIF   ('&TEXT'(1,1) NE '(').NOTR11\n&T.A     DC    A(0)                    TEXT ADDRESS & OPTION BITS\n         AGO   .IFR12\n.NOTR11  ANOP\n&T.A     DC    B'000&B3.00&B6&B7'      OPTION BITS\n         DC    AL3(&TEXT)              TEXT ADDRESS\n.IFR12   AIF   ('&LENGTH'(1,1) NE '(').NOTR12\n         DC    AL1(0)                  TEXT LENGTH\n         AGO   .IFR13\n.NOTR12  DC    AL1(&LENGTH)            TEXT LENGTH\n.IFR13   AIF   ('&OFFSET'(1,1) NE '(').NOTR13\n         DC    AL1(0)                  MARGIN OFFSET\n         AGO   .IFR14\n.NOTR13  DC    AL1(&OFFSET)            MARGIN OFFSET\n.IFR14   AIF   ('&SPB(1)'(1,1) NE '(').NOTR14\n         DC    AL1(0)                  PRE-SPACING\n         AGO   .IFR15\n.NOTR14  AIF   ('&SPB(1)' EQ 'EJECT').BSKIP\n         AIF   ('&SPB(1)' EQ 'SKIP').BSKIP\n         DC    AL1(&SPB(1))            PRE-SPACING\n         AGO   .IFR15\n.BSKIP   DC    AL1(255)                SKIP BEFOR PRINTING\n.IFR15   AIF   ('&SPA(1)'(1,1) NE '(').NOTR15\n         DC    AL1(0)                  POST-SPACING\n         AGO   .VCON\n.NOTR15  AIF   ('&SPA(1)' EQ 'EJECT').ASKIP\n         AIF   ('&SPA(1)' EQ 'SKIP').ASKIP\n         DC    AL1(&SPA(1))            POST-SPACING\n         AGO   .VCON\n.ASKIP   DC    AL1(255)                SKIP AFTER PRINTING\n.VCON    ANOP\n&T.L    XPRINNRA  &WA,32\n         MEND\nXPRT     TITLE 'XPRNTSUB - GENERAL PRINTING SUBROUTINE'\n* STATUS:  VERSION 2, 1 AUGUST 1968.\n         PUNCH '  SETSSI  02008214'\n         SPACE\n* AUTHOR:  R. F. MORSE, MIT INSTRUMENTATION LABORATORY\n         SPACE\n* FUNCTION/OPERATION:  THIS IS A GENERAL PRINTING SUBROUTINE TO MANAGE\n*        THE DETAILS OF PAGINATION, HEADINGS, AND OUTPUT COMPRESSION\n*        FOR PRINTED OUTPUT.  IT IS INVOKED FROM A PROBLEM PROGRAM VIA\n*        THE MACRO 'XPRNT', WHICH HAS THE FOLLOWING CALL MODES:\n*           OPEN - INITIALIZES PAGE SIZE PARAMETERS AND MAXIMUM NUMBER\n*              OF OUTPUT LINES, RESETS PAGE NUMBER, CLEARS HEADING\n*              LINES AND INSERTS CURRENT DATE AND TIME, INSERTS DDNAME\n*              IN DCB, AND OPENS THE DATA SET.\n*           MODIFY - ALTERS ANY OR ALL OF THE PARAMETERS LISTED UNDER\n*              'OPEN' EXCEPT THE DDNAME.\n*           SETHEAD - SUPPLIES TEXT FOR ONE OR MORE LINES TO BE USED\n*              PAGE HEADINGS.\n*           PRINT - DELIVERS ONE OR MORE LINES TO BE PRINTED.\n*           SPACE - MOVES THE PAGE VERTICALLY A GIVEN NUMBER OF LINES.\n*           EJECT - CONDITIONAL OR UNCONDITIONAL SKIP TO HEAD-OF-FORM.\n*           CLOSE - CLOSES THE DATA SET.\n         SPACE\n* ENTRY POINTS:  EACH MODE HAS A SEPARATE ENTRY AT A FIXED OFFSET FROM\n*        THE BASE ADDRESS.  ENTRYS ARE EFFECTED BY A  BAL  14,D(15)\n*        (WHERE D IS A DISPLACEMENT WHICH SELECTS THE DESIRED MODE) AND\n*        ASSUMES THAT REGISTER 13 ADDRESSES A STANDARD 18-WORD SAVE\n*        AREA.\n         SPACE\n* INPUT:  ON ENTRY, REG 0 POINTS TO A WORK AREA FOR THE DATA SET, WHICH\n*        IS DESCRIBED IN THIS CODING BY THE DUMMY SECTION 'WORKAREA'.\n*        REG 1 POINTS TO A PARAMETER LIST OF A FORM APPROPRIATE TO THE\n*        CALL MODE.  THESE LISTS ARE EITHER DESCRIBED BY DUMMY SECTIONS\n*        OR ARE STANDARD VARIABLE-LENGTH ADDRESS LISTS.\n         SPACE\n         SPACE\n* OUTPUT:  PRINT LINES AND SPACE CONTROL RECORDS ARE DELIVERED VIA QSAM\n*        TO A SEQUENTIAL DATA SET.  EACH LINE IS REDUCED TO ITS MIN-\n*        IMUM LENGTH BY TRUNCATING TRAILING BLANKS.\n         SPACE\n* DATA SETS:  THE OUTPUT DATA SET IS SEQUENTIAL, ARRANGED FOR BLOCKED\n*        FORMAT V RECORDS USING MACHINE CONTROL CHARACTERS APPROPRIATE\n*        TO 1403 OR 1404 PRINTERS.  THE DDNAME IS SUPPLIED BY THE\n*        'OPEN' CALL; THE STANDARD VALUE IS 'SYSPRINT'.\n         SPACE\n* EXTERNAL ROUTINES:  CALLS 'XDATEDIT' TO FORMAT THE DATE FOR THE\n*        PAGE HEADING LINE.\n         SPACE\n* EXITS - NORMAL:  RETURNS VIA REG 14 WITH RETURN CODE 0 IN REG 15.\n*        THE CURRENT PAGE NUMBER (IN BINARY) IS IN REG 0 AND THE BINARY\n*        NUMBER OF LINES REMAINING ON THE CURRENT PAGE IS IN REG 1.\n*        IF AN OPEN CALL CANNOT OPEN THE DCB, THE RETURN CODE IS 4.\n         SPACE\n* EXITS - ERROR:  ERRONEOUS CALLS RESULT IN AN 'ABEND' WITH ONE OF THE\n*        FOLLOWING COMPLETION CODES:\n*           4000 - ROUTINE WAS ILLEGALLY ENTERED AT ITS BASE ADDRESS.\n*           4002 - A CALL MODE OTHER THAN 'OPEN' WAS DIRECTED TO A DATA\n*              SET WHICH WAS NOT OPEN.\n*           4003 - 'OPEN' OR 'MODIFY' SPECIFIED TOO LARGE A PAGE WIDTH.\n*           4004 - 'OPEN' OR 'MODIFY' SPECIFIED TOO LONG A PAGE.\n*           4005 - 'PRINT' OR 'SETHEAD' SPECIFIED A LINE WHOSE TEXT\n*              LENGTH PLUS OFFSET EXCEEDED THE PAGE WIDTH.\n*           4006 - THE MAXIMUM NUMBER OF OUTPUT LINES WAS EXCEEDED.\n*           4007 - SYNCHRONOUS I/O ERROR.\n         SPACE\n* TABLES/WORK AREAS:  THE CALL PARAMETER LISTS, WORK AREA, AND PRINT\n*        LINE DESCRIPTOR BLOCK ARE ALL DESCRIBED BY DUMMY SECTIONS\n*        AT THE END OF THE PROGRAM.\n         SPACE\n* ATTRIBUTES:  REENTRANT, READ-ONLY.  WILL HANDLE ANY NUMBER OF DATA\n*        SETS SIMULTANEOUSLY, USING A SEPARATE WORK AREA FOR EACH.\n         SPACE\n* OPERATING ENVIRONMENT:  RUNS UNDER OPERATING SYSTEM/360, USING\n*        QSAM DATA MANAGEMENT WITH LOCATE-MODE PUT MACROS AND SIMPLE\n*        BUFFERING.  ASSUMES OPTION 6A OR 6B FOR TIME OF DAY.\n         SPACE\n* NOTES:  NONE.\n         EJECT\nXPRNTSUB CSECT\n         SPACE 2\n* REGISTER ASSIGNMENTS:\n         SPACE 2\n* N.B.  REGISTER GROUPS 'RWA,RWB,RWC,RWD' AND 'RLPEXIT,RPARM' MUST BE\n* KEPT IN ORDER FOR LM AND STM ORDERS.\n         SPACE\nRWA      EQU   2               GENERAL WORK REG\nRWB      EQU   3               GENERAL WORK REG\nRWC      EQU   4               GENERAL WORK REG\nRWD      EQU   5               GENERAL WORK REG\nRSPACE   EQU   6               NUMBER OF LINES TO SPACE\nRBAL     EQU   7               NUMBER OF LINES LEFT ON PAGE\nRLPEXIT  EQU   8               EXIT FROM LIST PROCESSING ROUTINE\nRPARM    EQU   9               CALL PARAMETER LIST ADDR\nRPLD     EQU   10              PLD BLOCK BASE\nRWKAREA  EQU   11              BASE REGISTER FOR WORK AREA\nRBASE    EQU   12              BASE REGISTER FOR CODING\nRRET     EQU   14              STANDARD RETURN ADDR\n         SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 3\n* MASKS FOR CONTROL BYTE \"SWITCHES\":\n         SPACE\nHOFBIT   EQU   X'80'           PAGE IS AT PHYSICAL HEAD-OF-FORM\nNOSKBIT  EQU   X'40'           DISALLOW EJECT DURING HEAD PRINTING\nTXT1BIT  EQU   X'20'           ON FOR FIRST TEXT LINE ON PAGE\nHD1BIT   EQU   X'10'           ON FOR FIRST HEAD LINE WITH PAGE NO, ETC\nSP0BIT   EQU   X'08'           LAST LINE SPACED 0\n         SPACE 2\nEJFORCE  EQU   255             SPACING QUANTITY TO FORCE PAGE EJECT\nOPENBIT  EQU   X'10'           TO TEST 'DCBOFLGS' FOR SUCCESSFUL OPEN\nMAXLNGTH EQU   254             MAXIMUM PAGE LENGTH\nMAXWIDTH EQU   132             MAXIMUM PAGE WIDTH\nDEFBLKSZ EQU   1692            DEFAULT DCB BLOCK SIZE\n         EJECT\n**********************\n* ENTRY AND PROLOGUE *\n**********************\n         SPACE\n* ENTER FROM THE CALLING SEQUENCE VIA THE INSTRUCTION \"BAL 14,X(0,15)\".\n* REGISTER 15 IS SET TO THE BASE OF THE ROUTINE AND THE DISPLACEMENT\n* \"X\" SELECTS THE ENTRY POINT.  EACH ENTRY SAVES REGISTERS, LOADS THE\n* ADDRESS OF THE APPROPRIATE SUBROUTINE, AND GOES TO A COMMON\n* PROLOGUE.  NOTE THAT AN ATTEMPT TO ENTER AT THE BASE RESULTS IN\n* AN ABEND.\n         SPACE 2\nBASEADDR B     20(0,R15)               BRANCH AROUND MODULE IDENTIFIER\n         DC    AL1(15)                 LENGTH OF IDENTIFIER\n         DC    CL15'XPRNTSUB-028214'\n         STM   R14,R12,12(R13)         SAVE CALLER'S REGISTERS\n         SR    R1,R1                   SET ABEND COMPLETION CODE\n         LR    RBASE,R15               SET BASE REG FOR ABEND ROUTINE\n         USING BASEADDR,RBASE\n         B     ABEND\n         DROP  RBASE\n         SPACE 2\n* ENTRY POINTS FOR VARIOUS FUNCTIONS, AT 12-BYTE INTERVALS BEGINNING\n* AT BASEADDR+32.  EACH LOADS \"RWA\" WITH THE ADDRESS OF THE SUBROUTINE\n* TO GO TO AFTER EXECUTING \"PROLOGUE\".\n         SPACE\n         ORG   XPRNTSUB+32\n         USING BASEADDR,R15\n         SPACE\nPRENTRY  STM   R14,R12,12(R13)         PRINT\n         LA    RWA,PRPROC\n         B     PROLOGUE\nSPENTRY  STM   R14,R12,12(R13)         SPACE\n         LA    RWA,SPPROC\n         B     PROLOGUE\nOPENTRY  STM   R14,R12,12(R13)         OPEN\n         LA    RWA,OPPROC\n         B     PROLOGUE\nCLENTRY  STM   R14,R12,12(R13)         CLOSE\n         LA    RWA,CLPROC\n         B     PROLOGUE\nSHENTRY  STM   R14,R12,12(R13)         SETHEAD\n         LA    RWA,SHPROC\n         B     PROLOGUE\nEJENTRY  STM   R14,R12,12(R13)         EJECT\n         LA    RWA,EJPROC\n         B     PROLOGUE\nMDENTRY  STM   R14,R12,12(R13)         MODIFY\n         LA    RWA,MDPROC\n         B     PROLOGUE\n         SPACE 2\n* PROLOGUE.  SET UP BASE REGISTERS FOR CODING AND WORK AREA.  CHAIN\n* SAVE AREAS IN STANDARD FASHION.  LOAD \"RBAL\" WITH CURRENT PAGE\n* BALANCE AND \"RPARM\" WITH THE CALLING PARAMETER LIST ADDRESS.\n         SPACE\nPROLOGUE LR    RBASE,R15               LOAD CODING BASE REG\n         USING BASEADDR,RBASE\n         DROP  R15\n         SPACE\n         LR    RWKAREA,R0              BASE REG FOR WORK AREA\n         USING WORKAREA,RWKAREA\n         SPACE\n         LR    RWB,R13                 ADDR OF CALLER'S SAVE AREA\n         LA    R13,SAVEAREA            ADDR OF OUR SAVE AREA\n         ST    R13,8(RWB)              CHAIN TO US FROM CALLER\n         ST    RWB,SAVEAREA+4          CHAIN TO CALLER FROM US\n         SPACE\n         LR    RPARM,R1                LOAD PARAMETER LIST ADDR\n         LH    RBAL,PAGEBAL            LOAD PAGE LINE COUNT BALANCE\n         MVC   DCBSYNAD(3),=AL3(SYNAD) PUT ERROR ROUTINE ADDRESS IN DCB\n         SPACE\n         TM    DCBOFLGS,OPENBIT        MAKE SURE DATA SET IS OPEN\n         BCR   1,RWA                   BRANCH IF OPEN\n         CL    RWA,=A(OPPROC)          IF NOT, ONLY OPEN CALL ALLOWED\n         BCR   8,RWA                   BR IF OPEN CALL\n         LA    R1,2                    ERROR CODE 2, GO TO ABEND\n         SPACE 3\n* ABEND ROUTINE FOR SERIOUS ERRORS.  ENTER WITH ERROR NUMBER IN R1.\n* ADD DECIMAL 4000 FOR USER CONPLETION CODE AND ISSUE 'ABEND' WITH DUMP\n         SPACE\n         CNOP  2,4                     ALIGN CONSTANT FOLLOWING SVC\nABEND    AL    R1,*+6                  LOAD ABEND CODES\n         SVC   13                      ISSUE ABEND SVC\n         DC    X'80'                   'DUMP' BIT FOR ABEND\n         DC    AL3(4000)               BASE FOR COMPLETION CODE\n         EJECT\n************\n* EPILOGUE *\n************\n         SPACE\n* ALL MODES RETURN TO THE CALLER VIA THIS ROUTINE.  IT EXITS WITH\n* THE RETURN CODE IN REGISTER 15, THE PAGE NUMBER IN REGISTER 0, AND\n* THE NUMBER OF LINES REMAINING ON THE PAGE IN REGISTER 1.\n         SPACE 2\nEXIT4    LA    R15,4                   SET RETURN CODE 4\n         B     EXIT\n         SPACE\nEXIT0    SR    R15,R15                 SET RETURN CODE 0\n         SPACE\nEXIT     LH    R0,PAGENO               LOAD CURRENT PAGE NUMBER\n         LR    R1,RBAL                 LOAD NUMBER OF LINES LEFT\n         STH   RBAL,PAGEBAL            SAVE PAGE BALANCE\n         XC    DCBSYNAD(3),DCBSYNAD    CLEAR ERROR ROUTINE ADDRESS\n         SPACE\n         L     R13,SAVEAREA+4          ADDRESS OF CALLER'S SAVE AREA\n         L     R14,12(R13)             LOAD RETURN ADDRESS\n         LM    R2,R12,28(R13)          RESTORE CALLER'S REGISTERS\n         MVI   12(R13),X'FF'           SET RETURN INDICATION\n         BR    R14                     RETURN TO CALLER\n         EJECT\n******************\n* PRINT FUNCTION *\n******************\n         SPACE\n* PRINT LINE DELIVERY CALL.  THE PARAMETER LIST IS A VARIABLE-LENGTH\n* LIST OF ADDRESSES, THE LAST OF WHICH IS NEGATIVE (I.E. BIT 0 IS A 1).\n* EACH ADDRESS POINTS TO A PLD DESCRIBING A LINE TO BE PRINTED.  CALL\n* THE GENERAL LIST PROCESSING ROUTINE TO DO THE DIRTY WORK.\n         SPACE 2\nPRPROC   BAL   RLPEXIT,LISTPROC        INVOKE LIST PROCESSOR\n         SPACE\n         B     EXIT0                   EXIT TO CALLER\n         EJECT\n******************\n* SPACE FUNCTION *\n******************\n         SPACE\n* CALL TO MOVE THE PAPER A SPECIFIED NUMBER OF LINES.  IF THE NUMBER\n* OF LINES EXCEEDS THE CURRENT PAGE BALANCE, AN EJECT RESULTS, UNLESS\n* SUPPRESSED BY THE 'SPNOEJ' BIT IN THE PARAMETER LIST.  IF THE PAGE\n* IS AT HEAD-OF-FORM, SPACING IS SUPPRESSED UNLESS THE 'SPATHOF' BIT\n* IS SET IN THE PARAMETER LIST.  IN THE LATTER CASE, THE PAGE HEADINGS\n* WILL BE PRINTED BEFORE THE SPACING IS EXECUTED.\n         SPACE 2\n         USING SPPARM,RPARM            ADDRESSING FOR PARM LIST\n         SPACE\nSPPROC   TM    SWITCHES,HOFBIT         TEST IF AT HEAD-OF-FORM\n         BZ    SPSUBTR                 BR IF NOT\n         TM    SPCOND,SPATHOF          IS SPACE ALLOWED AT HOF?\n         BZ    EXIT0                   EXIT IF NOT\n         BAL   RRET,HEADPRNT           IF SO, PRINT HEADINGS FIRST\n         SPACE\nSPSUBTR  SR    RSPACE,RSPACE\n         IC    RSPACE,SPQUAN           LOAD SPACING AMOUNT\n         SR    RBAL,RSPACE             COMPUTE NEW PAGE BALANCE\n         SPACE\n         BP    SPMOVE                  BRANCH IF BAL STILL > 0\n         TM    SPCOND,SPNOEJ           TEST IF EJECT ALLOWED\n         BO    SPMOVE                  BRANCH IF NOT\n         LA    RSPACE,EJFORCE          IF ALLOWED, FORCE EJECT\n         SPACE\nSPMOVE   BAL   RWA,MOVE                CALL PAPER MOVING SUB\n         B     EXIT0                   EXIT TO CALLER\n         SPACE\n         DROP  RPARM\n         EJECT\n******************\n* EJECT FUNCTION *\n******************\n         SPACE\n* CALL TO MOVE THE PAPER TO HEAD-OF-FORM.  IF THE PAGE IS ALREADY\n* THERE, THE EJECT IS NOT EXECUTED UNLESS THE 'EJATHOF' BIT IN THE\n* PARAMETER LIST IS ON.  IN THE LATTER CASE, A SKIP IS EXECUTED WITHOUT\n* PRINTING ANY HEADINGS, RESULTING IN A BLANK PAGE.  IF THE MASK BITS\n* IN THE 'EJCOND' PARAMETER ARE NOT ALL ONES, A CONDITIONAL EJECT IS\n* REQUESTED.  THE PAGE BALANCE IS COMPARED AGAINST THE TEST QUANTITY\n* 'EJQUAN' IN THE PARAMETER LIST, THEN THE DECISION TO EJECT OR NOT\n* IS MADE WITH A 'BC' ORDER USING THE 'EJCOND' BITS AS A MASK.\n         SPACE 2\n         USING EJPARM,RPARM            FOR PARM LIST ADDRESSING\n         SPACE\nEJPROC   TM    SWITCHES,HOFBIT         TEST IF AT HOF\n         BZ    EJTEST                  BR IF NOT\n         TM    EJCOND,EJATHOF          IF SO, IS EJECT ALLOWED?\n         BZ    EXIT0                   IF NOT, EXIT\n         SPACE\nEJTEST   SR    R0,R0\n         IC    R0,EJQUAN               LOAD TEST QUANTITY\n         IC    R1,EJCOND               GET CONDITIONAL TEST MASK\n         N     R1,=XL4'000000F0'       KEEP BITS 24-27 ONLY\n         CR    RBAL,R0                 COMPARE BALANCE WITH TEST QUAN\n         EX    R1,EJBC                 EXECUTE BC WITH MASK FROM PARM\n         B     EXIT0                   EXIT IF CONDITION NOT MET\n         SPACE\nEJMOVE   LA    RSPACE,EJFORCE          TO FORCE EJECT\n         BAL   RWA,MOVE                CALL PAPER MOVER SUB\n         B     EXIT0                   EXIT TO CALLER\n         SPACE 2\nEJBC     BC    0,EJMOVE                BRANCH IF EJECT REQUIRED\n         SPACE\n         DROP  RPARM\n         EJECT\n*****************\n* OPEN FUNCTION *\n*****************\n         SPACE\n* THIS MUST BE THE FIRST CALL FOR A NEW DATA SET.  IT SETS THE DDNAME\n* IN THE DCB AND OPENS THE DATA SET.   ALL COUNTERS AND SWITCHES ARE\n* SET TO THEIR NOMINAL VALUES BEFORE PROCESSING ANY OPTIONS WHICH\n* MAY HAVE BEEN SUPPLIED WITH THE CALL.  THE PAGE BALANCE IS SET TO\n* ZERO, BUT THE PAGE IS NOT MOVED.  THE PROGRAMMER SHOULD NORMALLY\n* ISSUE AN 'EJECT' CALL BEFORE BEGINNING HIS OUTPUT.\n         SPACE\n* IF THE DATA SET IS ALREADY OPEN, THE DDNAME IS IGNORED, THE NOMINAL\n* OPTIONS ARE SET, THEN THIS CALL IS TREATED EXACTLY AS IF IT WERE A\n* 'MODIFY' CALL.\n         SPACE 2\n         USING OMPARM,RPARM\n         SPACE\nOPPROC   MVC   PAPARMS(DEFSIZE),DEFAULTS  SET STANDARD OPTIONS\n         MVI   HLTEXT,C' '             CLEAR HEADING TEXT\n         MVC   HLTEXT+1(HLTXTLNG-1),HLTEXT\n         SPACE\n         TIME  DEC                     GET CURRENT DATE & TIME\n         STM   R0,R1,HPRSAVE           SAVE TIME AND DATE\n         SPACE\n* NOW IF DATA SET IS ALREADY OPEN, GO TO 'MDPROC'.  OTHERWISE, INSERT\n* DDNAME AND OPEN IT.\n         SPACE\n         TM    DCBOFLGS,OPENBIT        TEST IF OPEN\n         BO    OPJOIN                  BR TO 'MDPROC' IF OPEN\n         MVC   DCBDDNAM(8),OMDDNAME    INSERT DDNAME INTO CLOSED DCB\n         MVC   DCBEXLST(3),=AL3(EXLST) INSERT ADDRESS OF EXIT LIST\n         SPACE\n         MVI   DWORK,X'80'             SET END-OF-LIST BIT\n         OPEN  (PRINTDCB,(OUTPUT,LEAVE)),MF=(E,DWORK)\n         SPACE\n         XC    DCBEXLST(3),DCBEXLST    CLEAR ADDRESS OF EXIT LIST\n         TM    DCBOFLGS,OPENBIT        TEST FOR SUCCESSFUL OPEN\n         BO    OPJOIN                  TO 'MDPROC' IF O.K.\n         B     EXIT4                   EXIT WITH RC=4 IF OPEN FAILS\n         SPACE\n         DROP  RPARM\n         EJECT\n* DCB EXIT ROUTINE FOR OPEN.  SET BLOCK SIZE TO THE DEFAULT VALUE IF\n* NOT SPECIFIED IN DS LABEL OR DD CARD.\n         SPACE\nEXLST    DS    0F                      EXIT LIST, ON BOUNDARY\n         DC    X'85'\n         DC    AL3(DCBMOD)\n         SPACE\nDCBMOD   LH    RWA,DCBBLKSZ            LOAD BLOCK SIZE\n         LTR   RWA,RWA                 TEST IF ZERO\n         BNZ   DCBNZ                   BRANCH IF NOT ZERO\nSETDEF   LA    RWA,DEFBLKSZ            SET DEFAULT BLOCK SIZE\n         STH   RWA,DCBBLKSZ            STORE IN DCB\n         BR    R14                     RETURN TO OPEN ROUTINE\nDCBNZ    CH    RWA,=H'141'             TEST FOR MINIMUM BLOCKSIZE\n         BL    SETDEF                  USE DEFAULT IF TOO LOW\n         BR    R14                     RETURN TO OPEN IF OK\n         EJECT\n*******************\n* MODIFY FUNCTION *\n*******************\n         SPACE\n* THIS CALL MAY ALTER ANY  OR ALL OF THE FOLLOWING: DATE, TIME, PAGE\n* NUMBER, PAGE LENGTH, PAGE WIDTH, MAXIMUM NUMBER OF OUTPUT LINES.\n* THE NEW VALUES ARE PRESENTED IN A PARAMETER LIST.  IF A PARAMETER IS\n* ZERO, THE CORRESPONDING QUANTITY IS NOT ALTERED.\n         SPACE\n* THE DATE AND TIME FIELDS MAY BE SUPPLIED BY THE 'OPEN' ROUTINE,\n* WHICH JOINS THIS CODING AT 'OPJOIN'.  IN THAT CASE, THE VALUES\n* INSERTED BY 'OPEN' ARE USED UNLESS OVERRIDDEN BY THE PARAMETER LIST.\n         SPACE\n         USING OMPARM,RPARM\n         SPACE\nMDPROC   SR    R0,R0                   GENERATE TWO ZERO WORDS\n         SR    R1,R1\n         STM   R0,R1,HPRSAVE           SET DATE & TIME FIELDS TO ZERO\n         SPACE\n* ENTER HERE FROM 'OPEN'.  THE OBJECT OF THE FOLLOWING IS TO GET THE\n* ACTUAL TIME AND DATE (IN PACKED DECIMAL) INTO 'HPRSAVE' AND\n* 'HPRSAVE+4', RESPECTIVELY.  THOSE FIELDS MAY HAVE BEEN FILLED IN BY\n* THE OPEN ROUTINE, OR THEY MAY HAVE BEEN SET TO ZEROS BY 'MDPROC'\n* ABOVE.  NOW WE SEE IF ADDRESSES FOR TIME AND/OR DATE VALUES WERE\n* PROVIDED IN THE PARAMETER LIST, AND TRANSFER THE VALUES IF SO.\n         SPACE\nOPJOIN   LM    RWA,RWB,OMTIMEAD        LOAD TIME & DATE ADDRS FROM PARM\n         LTR   RWA,RWA                 TEST FOR TIME ADDR SUPPLIED\n         BZ    NOTIME                  BRANCH IF ZERO\n         MVC   HPRSAVE(4),0(RWA)       GET TIME AS DECIMAL 'HHMMSSTH'\nNOTIME   LTR   RWB,RWB                 TEST IF DATE ADDR SUPPLIED\n         BZ    DATEEDIT                BR IF NOT\n         MVC   HPRSAVE+4(4),0(RWB)     GET DECIMAL DATE AS '00YYDDD+'\n         SPACE\n* IF THE DATE VALUE IS NOT ZERO, EDIT INTO THE HEADING LINE TEXT.  BOTH\n* THE DAY NUMBER AND THE MONTH-DAY-YEAR FORM ARE USED.\n         SPACE\nDATEEDIT LM    RWA,RWB,HPRSAVE         LOAD TIME & DATE FOR TESTING\n         LTR   RWB,RWB                 TEST IF DATE WAS GIVEN\n         BZ    TIMEEDIT                BRANCH IF ZERO\n         SPACE\n         MVC   HLDAY(4),=C'DAY='       INSERT DAY NUMBER\n         UNPK  HLDAY+4(3),HPRSAVE+6(2) UNPACK DAY NUMBER\n         OI    HLDAY+6,X'F0'           TIDY UP SIGN BITS\n         SPACE\n         ST    RWB,DWORK+4             STORE DATE ARG FOR EDIT RTNE\n         LA    R1,DWORK                CONSTRUCT ONE-WORD PARM LIST\n         ST    R1,HPRSAVE+4              FOR XDATEDIT CALL\n         LA    R1,HPRSAVE+4            LOAD PARM LIST ADDRESS\n         L     R15,=V(XDATEDIT)        LOAD ADDRESS OF DATE EDIT RTNE\n         BALR  R14,R15                   TO EDIT DATE AS 'MM/DD/YY'\n         MVC   HLDATE(8),DWORK         INSERT RESULT IN HL TEXT\n         SPACE\n* EDIT TIME IN HOURS AND MINUTES, IF SUPPLIED.\n         SPACE\nTIMEEDIT LTR   RWA,RWA                 TEST IF TIME GIVEN\n         BZ    TSTPGNO                 BR IF ZERO\n         SRL   RWA,4                   ADD LEADING ZERO TO TIME\n         ST    RWA,HPRSAVE             STORE TIME IN WORK LOC\n         MVC   HLTIME(7),=X'402120207A2020'  EDIT CONTROL CHAR\n         ED    HLTIME(7),HPRSAVE       EDIT INTO ALPHA\n         SPACE\n* MODIFY PAGE NUMBER.  VALUE GIVEN IS DECREMENTED BY ONE, SINCE IT IS\n* INCREMENTED BEFORE USE.\n         SPACE\nTSTPGNO  LH    RWA,OMPAGENO            GET VALUE FROM PARM LIST\n         LTR   RWA,RWA                 TEST IF ZERO\n         BZ    TSTPGWID                BR IF ZERO\n         BCTR  RWA,0                   DECREMENT BY 1\n         STH   RWA,PAGENO              STORE\n         SPACE\n* MODIFY PAGE WIDTH, TESTING FOR MAXIMUM ALLOWED.\n         SPACE\nTSTPGWID SR    RWA,RWA\n         IC    RWA,OMPAGWID            GET WIDTH FROM PARM LIST\n         LTR   RWA,RWA                 TEST IF ZERO\n         BZ    TSTPGLNG                BRANCH IF SO\n         CLI   OMPAGWID,MAXWIDTH       TEST MAXIMUM SIZE\n         BNH   PGWIDOK\n         LA    R1,3                    ERROR, TOO LARGE\n         B     ABEND\nPGWIDOK  STH   RWA,PAGWIDTH\n         SPACE\n* MODIFY PAGE LENGTH, TESTING FOR MAXIMUM VALUE.\n         SPACE\nTSTPGLNG SR    RWA,RWA\n         IC    RWA,OMPAGLNG            GET FROM PARM LIST\n         LTR   RWA,RWA                 TEST IF SUPPLIED\n         BZ    TSTMAXLN                BR IF NOT\n         CLI   OMPAGLNG,MAXLNGTH       TEST FOR LEGAL VALUE\n         BNH   PGLNGOK\n         LA    R1,4                    ERROR, ABORT\n         B     ABEND\nPGLNGOK  STH   RWA,PAGELNG             STORE\n         SPACE\n* MODIFY PRINT LINE LIMIT COUNTER.\n         SPACE\nTSTMAXLN L     RWA,OMMAXLIN            GET FROM PARM LIST\n         LTR   RWA,RWA                 TEST IF SUPPLIED\n         BZ    EXIT0                   EXIT IF NOT\n         ST    RWA,MAXLINES            STORE\n         B     EXIT0                   EXIT TO CALLER\n         SPACE\n         DROP  RPARM\n         EJECT\n********************\n* SETHEAD FUNCTION *\n********************\n         SPACE\n* THIS CALL PRESENTS A LIST OF LINES WHICH WILL BE USED AS PAGE HEADING\n* AND SUB-HEADING LINES.  THE PARAMETER LIST IS A VARIABLE-LENGTH LIST\n* OF PLD ADDRESSES, EXACTLY AS FOR 'PRINT' CALLS.  THE FIRST LINE WILL\n* HAVE ADDED TO ITS RIGHT END THE DATE, TIME, AND PAGE NUMBER.\n* HOWEVER, IF ITS LENGTH EXCEEDS 98 BYTES, IT WILL OVERLAY THOSE\n* FIELDS.  THE SECOND AND SUBSEQUENT LINES WILL BE PRINTED NORMALLY.\n* NOTE THAT THESE LINES ARE NOT PRINTED WHEN THE PAGE IS EJECTED, BUT\n* WHEN THE LINE WHICH WILL BE FIRST ON THE NEW PAGE IS DELIVERED, THUS\n* ALLOWING THE HEADINGS TO BE ALTERED AFTER DELIVERY OF THE LAST LINE\n* ON THE PRECEDING PAGE.  THE ADDRESS OF THE PARAMETER LIST IS SAVED\n* BY THE PRINTING ROUTINE, BUT THE PARAMETER LIST, THE PLD'S TO WHICH\n* IT POINTS, AND THE LINE TEXTS TO WHICH THEY POINT, MUST BE PRESERVED\n* BY THE PROBLEM PROGRAM FOR AS LONG AS THEY ARE IN USE, SINCE THEY\n* ARE REFERRED TO AT THE BEGINNING OF EACH NEW PAGE.  EACH CALL TO\n* TO 'SETHEAD' SUPERSEDES THE EFFECT OF THE PREVIOUS CALL.  A CALL WITH\n* A PARAMETER LIST ADDRESS OF ZERO INDICATES THAT NO HEADINGS ARE\n* PROVIDED BY THE PROBLEM PROGRAM, AND ONLY THE PAGE NUMBER, DATE, AND\n* TIME WILL BE PRINTED, WITH A STANDARD SPACING OF THREE.\n         SPACE 2\nSHPROC   LTR   RPARM,RPARM             TEST FOR NULL LIST ADDR\n         BNZ   SHOK                    BRANCH IF NON-ZERO\n         LA    RPARM,NOHDLIST          ADDRESS OF PLD FOR BLANK LINE\nSHOK     ST    RPARM,HEADLIST          STORE ADDR OF HEADING PARMS\n         B     EXIT0                   EXIT\n         EJECT\n******************\n* CLOSE FUNCTION *\n******************\n         SPACE\n* THIS CALL CLOSES THE PRINTER DATA SET.  IT DOES NOT MOVE THE PAGE\n* OR ALTER ANY SWITCHES OR VARIABLES EXCEPT THE DCB ITSELF.\n* AFTER CLOSING THE DCB, IT RELEASES THE PRINT BUFFERS.\n         SPACE 2\nCLPROC   TM    DCBOFLGS,OPENBIT        IS DCB OPEN NOW?\n         BZ    EXIT0                   EXIT IF ALREADY CLOSED\n         MVI   DWORK,X'80'             SET END-OF-LIST BIT\n         CLOSE (PRINTDCB,LEAVE),MF=(E,DWORK)\n         SPACE\n         FREEPOOL  PRINTDCB            FREE THE BUFFER CORE\n         SPACE\n         B     EXIT0                   EXIT TO CALLER\n         EJECT\n************\n* LISTPROC *\n************\n         SPACE\n* THIS ROUTINE PROCESSES A LIST OF PLD ADDRESSES, FORMATTING EACH PRINT\n* LINE AND PERFORMING THE NECESSARY PRE- AND POST-SPACING OPERATIONS.\n* IT IS ENTERED WITH 'RPARM' POINTING TO THE LIST OF ADDRESSES AND\n* 'RLPEXIT' CONTAINING THE EXIT ADDRESS.  IT MAY DISCOVER THAT ITS\n* SPACING OPERATIONS HAVE BROUGHT THE PAGE TO HEAD OF FORM, REQUIRING\n* THAT THE HEADING AND SUB-HEADING LINES BE PRINTED.  WHEN THIS OCCURS,\n* IT BRANCHES TO 'HEADPRNT', WHICH SAVES 'RPARM' AND 'RLPEXIT' AND\n* REENTERS THIS ROUTINE WITH AN ADDRESS LIST FOR THE HEADING LINES.\n* (WHEN THIS SECOND-LEVEL CALL IS MADE, SWITCH 'NOSKPBIT' IS ON,\n* PREVENTING ANY FURTHER PAGE SKIPS AND ELIMINATING THE POSSIBILITY OF\n* YET ANOTHER CALL TO 'HEADPRNT'.)  AFTER THE HEADINGS ARE PRINTED,\n* THE ORIGINAL VALUES ARE RETURNED TO 'RPARM' AND 'RLPEXIT' AND\n* PROCESSING OF THE LIST OF TEXT LINES PROVIDED BY THE CALLER IS\n* CONTINUED.\n         SPACE 2\n         USING PLDBLOCK,RPLD           TO ADDRESS PLD BLOCKS\n         SPACE\nLISTPROC L     RPLD,0(RPARM)           LOAD A PLD BLOCK ADDRESS\n         SPACE\n* IF PAGE IS NOW AT HEAD OF FORM, EXECUTE 'HEADPRNT'.\n         SPACE\n         LA    RRET,LISTPROC           EXIT FROM HEADPRNT STARTS AGAIN\n         TM    SWITCHES,HOFBIT         SEE IF HEAD-OF-FORM FLAG IS ON\n         BO    HEADPRNT                EXIT IF SO\n         SPACE 2\n* TEST WHETHER WE ARE AT THE FIRST TEXT LINE ON A PAGE, AND, IF SO,\n* WHETHER PRE-SPACING IS ALLOWED IN THAT POSITION.  IF NOT, BYPASS\n* PRE-SPACING ALTOGETHER.\n         SPACE\n         TM    SWITCHES,TXT1BIT        TEST IF FIRST TEXT LINE\n         BZ    PRSUBTR                 BRANCH IF NOT\n         TM    PLDFLAGS,PRHOFBIT       TEST IF ALLOW SKIP AT HOF\n         BZ    POSTSP                  SKIP PRESPACING IF NOT\n         SPACE\n* DECREMENT THE PAGE BALANCE BY THE AMOUNT TO BE SPACED.\n         SPACE\nPRSUBTR  SR    RSPACE,RSPACE\n         IC    RSPACE,PLDSPB           LOAD AMOUNT TO SPACE\n         SR    RBAL,RSPACE             DECREMENT PAGE BALANCE\n         SPACE\n* IF SKIPPING IS ALLOWED BY BOTH THE SYSTEM AND THE USER, TEST THE\n* BALANCE AND FORCE A PAGE SKIP IF <= ZERO.\n         SPACE\n         TM    SWITCHES,NOSKBIT        TEST IF SYSTEM ALLOWS SKIP\n         BO    PREMOVE                 BRANCH IF NOT\n         TM    PLDFLAGS,PRSKPBIT       TEST IF USER ALLOWS SKIP\n         BO    PREMOVE                 BRANCH IF NOT\n         LTR   RBAL,RBAL               TEST PAGE BALANCE\n         BP    PREMOVE                 BRANCH IF SOME LINES LEFT\n         LA    RSPACE,EJFORCE          FORCE A PAGE SKIP\n         SPACE\n* MOVE THE PAGE THE NUMBER OF LINES IN 'RSPACE'.\n         SPACE\nPREMOVE  BAL   RWA,MOVE                TO PAPER MOVING SUBROUTINE\n         SPACE\n* IF THAT MOVING PUT US AT HEAD-OF-FORM, PRINT THE HEADINGS.\n         SPACE\n         LA    RRET,LISTPROC           EXIT FROM HEADPRNT STARTS AGAIN\n         TM    SWITCHES,HOFBIT         TEST HEAD-OF-FORM BIT\n         BO    HEADPRNT                EXIT IF AT HEAD\n         SPACE 2\n* NOW CONSIDER THE SPACING TO BE PERFORMED WHEN THE TEXT OF THE LINE\n* IS PRINTED.  BEGIN BY COMPUTING THE NEW PAGE BALANCE.\n         SPACE\nPOSTSP   SR    RSPACE,RSPACE\n         IC    RSPACE,PLDSPA           LOAD AMOUNT TO SPACE AFTER PRINT\n         SR    RBAL,RSPACE             COMPUTE NEW PAGE BALANCE\n         SPACE\n* IF THE SYSTEM AND USER BOTH ALLOW SKIPPING, TEST THE PAGE BALANCE,\n* AND FORCE A SKIP IF <= ZERO.\n         SPACE\n         TM    SWITCHES,NOSKBIT        TEST IF SYSTEM ALLOWS SKIPPING\n         BO    GETPRCC                 BRANCH IF NOT\n         TM    PLDFLAGS,SPSKPBIT       TEST IF USER ALLOWS SKIPPING\n         BO    GETPRCC                 BRANCH IF NOT\n         LTR   RBAL,RBAL               TEST FOR PAGE END\n         BP    GETPRCC                 BRANCH IF SOME LINES LEFT\n         LA    RSPACE,EJFORCE          FORCE PAGE SKIP\n         SPACE\n* NOW CONSTRUCT THE PRINT LINE IN AN OUTPUT BUFFER.  IN THE INTERESTS\n* OF SAVING BUFFER SPACE, THE CALLER'S TEXT IS SCANNED FROM THE RIGHT\n* TO REDUCE ITS NOMINAL LENGTH BY THE NUMBER OF RIGHT BLANKS.  IN THE\n* EXTREME CASE THAT IT IS ENTIRELY BLANK, BYPASS PRINTING ALTOGETHER\n* AND MERELY SPACE.  IF THIS IS TO BE THE FIRST HEADING LINE OF THE\n* PAGE ('HD1BIT' SET), SCANNING IS OMITTED, THE RECORD LENGTH IS SET TO\n* THE PAGE WIDTH, AND THE DATE, TIME, AND PAGE NUMBER ARE INSERTED.\n         SPACE\nGETPRCC  DS    0H\n         SR    RWA,RWA\n         IC    RWA,PLDLNGTH            LOAD NOMINAL LENGTH OF TEXT\n         SR    RWB,RWB\n         IC    RWB,PLDOFFST            LOAD LEFT MARGIN OFFSET\n         SPACE\n         LA    R0,0(RWA,RWB)           LINE LENGTH = TEXT + OFFSET\n         CH    R0,PAGWIDTH             TEST AGAINST PAGE WIDTH\n         BNH   TSTHD1                  BR IF OK\n         LA    R1,5                    ERROR, LINE TOO LONG\n         B     ABEND\n         SPACE\nTSTHD1   TM    SWITCHES,HD1BIT         TEST IF FIRST HEADING LINE\n         BZ    BLNKSCAN                BR IF NOT\n         LH    RWB,PAGWIDTH            SET RECORD LENGTH AS PAGE WIDTH\n         B     GETBUF                  SKIP BLANK SCANNING\n         SPACE\n* SET UP A 'BXH' FOR SCAN.  R0 IS INCREMENT, R1 IS COMPARAND, RWA\n* VARIABLE.\n         SPACE\nBLNKSCAN LH    R0,=H'-1'               INCREMENT IS MINUS 1\n         L     R1,PLDTXTAD-1           LOAD TEXT ADDRESS\n         LA    R1,0(R1)                ZERO HIGH-ORDER BYTE\n         BCTR  R1,0                    DECREMENT BY ONE\n         AR    RWA,R1                  SET RWA TO RIGHT-MOST TEXT BYTE\n         SPACE\n* SCAN THE LINE, SEARCHING FOR FIRST NON-BLANK.  RESULT IS NEW TEXT\n* LENGTH IN RWA, WHICH WILL BE ZERO FOR BLANK LINES.\n         SPACE\nBLNKLOOP CLI   0(RWA),C' '             TEST FOR NON-BLANK CHAR\n         BNE   BLNKDONE                EXIT WHEN FOUND\n         BXH   RWA,R0,BLNKLOOP\nBLNKDONE SR    RWA,R1                  NOW RWA IS NEW TEXT LENGTH\n         BC    13,POSTMOVE             NO PRINTING IF <= 0\n         SPACE\n* NOW ADD OFFSET TO LENGTH OF SURVIVING TEXT TO GET ACTUAL LINE LENGTH.\n         SPACE\n         AR    RWB,RWA                 ADD TEXT LENGTH\n         SPACE\n* NOW RWA IS THE LENGTH OF THE CALLER'S TEXT, AND RWB IS THE LENGTH OF\n* THE LINE.  THE RECORD LENGTH WILL BE FIVE MORE THAT THE LENGTH OF THE\n* LINE, TO INCLUDE FORMAT 'V'  AND PRINTER CONTROL CHARACTERS.  GET\n* A BUFFER OF THE PROPER LENGTH, KEEPING ITS ADDRESS IN R1.\n         SPACE\nGETBUF   LA    RWC,5(RWB)              LOAD LENGTH OF RECORD IN RWC\n         STH   RWC,DCBLRECL            PUT LRECL IN DCB FOR PUT CALL\n         SPACE\n         PUT   PRINTDCB                GET BUFFER ADDRESS IN R1\n         SPACE\n         ST    R1,CCLAST               SAVE LOCATION OF THIS LINE\n         LR    RWD,R1                  RWD BECOMES BUFFER BASE REG\n         MVI   3(RWD),C' '             CLEAR BUFFER TO BLANKS\n         EX    RWB,BLNKMOVE\n         SLL   RWC,16                  SET UP 4-BYTE 'V' CONTROL FIELD\n         ST    RWC,DWORK               CAN'T ASSUME BUFFER ON ANY\n         MVC   0(4,RWD),DWORK            BOUNDARY\n         SPACE\n* IF THIS IS THE FIRST HEADING LINE, INSERT DATE AND TIME, AND EDIT\n* THE PAGE NUMBER.\n         SPACE\n         TM    SWITCHES,HD1BIT         TEST IF FIRST LINE\n         BZ    MOVETEXT                BRANCH IF NOT\n         SPACE\n         LA    RWC,0(RWB,RWD)          ADDRESS RIGHT END -5\n         SH    RWC,=AL2(HLTXTLNG+10-5) LOCATE PLACE FOR HEADING INFO\n         MVC   0(HLTXTLNG,RWC),HLTEXT  INSERT DATE & TIME\n         SPACE\n         LH    R1,PAGENO               INCREMENT PAGE NUMBER\n         LA    R1,1(R1)\n         STH   R1,PAGENO\n         CVD   R1,DWORK                CONVERT TO DECIMAL\n         MVC   HLTXTLNG(10,RWC),=XL10'40404040402020202120'  EDIT CHARS\n         LA    R1,HLTXTLNG+9(RWC)      IN CASE SIGNIFIGANCE FORCED\n         EDMK  HLTXTLNG+4(6,RWC),DWORK+5  EDIT AND MARK SPOT FOR \"PAGE\"\n         SH    R1,=H'5'\n         MVC   0(4,R1),=C'PAGE'        INSERT WORD \"PAGE\"\n         SPACE\n* PUT PRINTER CONTROL CHARACTER AND CALLER'S TEXT INTO THE BUFFER.\n* REGISTER RWA CONTAINS THE LENGTH OF THE TEXT.\n         SPACE\nMOVETEXT BAL   RWB,CCGEN               GO GET CONTROL CHAR\n         STC   R0,4(RWD)               INSERT IN BUFFER\n         NI    4(RWD),B'11111101'      CHANGE SPACE IMMEDIATE TO WRITE\n         SPACE\n         SR    RWB,RWB\n         IC    RWB,PLDOFFST            LOAD LEFT MARGIN OFFSET\n         LA    RWB,5(RWB,RWD)          ADDRESS FOR FIRST TEXT BYTE\n         BCTR  RWA,0                   DECREMENT LENGTH BY 1 FOR MVC\n         L     RWC,PLDTXTAD-1          LOAD ADDRESS OF CALLER'S TEXT\n         EX    RWA,MOVEINST            MOVE TEXT\n         SPACE\n         NI    SWITCHES,255-HD1BIT-TXT1BIT  RESET ONE-SHOT BITS\n         SPACE\n* DECREMENT PRINT LINE LIMIT COUNTER, ABORTING IF IT GOES NEGATIVE.\n         SPACE\n         L     R1,MAXLINES\n         S     R1,=F'1'                BCTR WOULD NOT SET COND CODE\n         ST    R1,MAXLINES\n         BP    POSTMOVE                BRANCH IF POSITIVE\n         LA    R1,6                    ABORT, TOO MUCH OUTPUT\n         B     ABEND\n         SPACE\n* DO ANY ADDITIONAL SPACING NECESSARY.  AMOUNT STILL IN 'RSPACE'.\n         SPACE\nPOSTMOVE BAL   RWA,MOVE                CALL PAPER MOVING SUBROUTINE\n         SPACE 2\n* NOW WE ARE FINISHED WITH THAT LINE.  IF THE ADDRESS WHICH POINTED TO\n* ITS PLD WAS NEGATIVE, THE LIST IS EXHAUSTED AND THE ROUTINE EXITS.\n* OTHERWISE, INCREMENT THE LIST POINTER BY 4 AND START THE NEXT ONE.\n         SPACE\n         LTR   RPLD,RPLD               TEST CURRENT PLD ADDRESS\n         BCR   4,RLPEXIT               EXIT IF NEGATIVE\n         SPACE\n         LA    RPARM,4(RPARM)          INCREMENT LIST POINTER\n         B     LISTPROC                TO PROCESS NEXT LINE\n         SPACE 2\n* EXECUTED INSTRUCTIONS:\n         SPACE\nBLNKMOVE MVC   4(0,RWD),3(RWD)         SPREAD BLANKS IN OUTPUT BUFFER\nMOVEINST MVC   0(0,RWB),0(RWC)         MOVE CALLER'S TEXT TO OUTPUT BUF\n         SPACE\n         DROP  RPLD\n         EJECT\n************\n* HEADPRNT *\n************\n         SPACE\n* ENTER THIS ROUTINE WHEN IT IS DISCOVERED THAT WE ARE AT\n* HEAD-OF-FORM AND ARE ABOUT TO PRINT A LINE.  SAVE THE REGISTERS\n* DEFINING THE STATE OF 'LISTPROC' AND CALL IT WITH A LIST SPECIFYING\n* THE HEADING AND SUB-HEADING LINES.\n         SPACE 2\nHEADPRNT ST    RRET,HPREXIT            SAVE RETURN ADDRESS\n         STM   RLPEXIT,RPARM,HPRSAVE   STORE LISTPROC REGISTERS\n         SPACE\n* RESET HEAD-OF-FORM BIT AND SET NO-SKIP BIT TO SUPPRESS FORM SKIPS\n* AND HEADING LINE BIT TO INCLUDE THE PAGE NUMBER.  RESET PAGE BALANCE.\n         SPACE\n         NI    SWITCHES,255-HOFBIT     RESET HOF BIT\n         OI    SWITCHES,HD1BIT+NOSKBIT SET HEADING AND NOSKIP BITS\n         LH    RBAL,PAGELNG            RESET PAGE BALANCE\n         SPACE\n* LOAD ADDRESS OF HEADINGS LIST AND CALL LIST PROCESSOR.\n         SPACE\n         L     RPARM,HEADLIST          ADDRESS OF HEADINGS LIST\n         BAL   RLPEXIT,LISTPROC        CALL PROCESSING ROUTINE\n         SPACE\n* AFTER PRINTING THE HEADINGS, TURN SYSTEM SKIP-SUPPRESSION BIT OFF\n* AND SET 'TXT1BIT' TO INDICATE THAT THERE ARE NO TEXT LINES ON THE\n* PAGE YET.  THEN RESTORE THE 'LISTPROC' REGISTERS AND RETURN TO\n* PROCESSING THE CALLER'S LINES.\n         SPACE\n         NI    SWITCHES,255-NOSKBIT    RESET NO-SKIP BIT\n         OI    SWITCHES,TXT1BIT        SET FIRST-TEXT-LINE BIT\n         SPACE\n         LM    RLPEXIT,RPARM,HPRSAVE   RESTORE LISTPROC REGISTERS\n         L     RRET,HPREXIT            RECOVER EXIT ADDRESS AND\n         BR    RRET                      RETURN TO CALLER\n         EJECT\n***********************************\n* MOVE - VERTICAL SPACING ROUTINE *\n***********************************\n         SPACE\n* SUBROUTINE TO MOVE THE PAPER BY THE NUMBER OF LINES IN REGISTER\n* 'RSPACE'.  RETURN ADDRESS IS IN 'RWA'.  IF THE CONTROL CHARACTER FOR\n* THE LAST LINE SPACED 0 LINES, REPLACE IT WITH A NEW ONE BEFORE\n* GENERATING ANY EXTRA LINES.\n         SPACE 2\nMOVE     LTR   RSPACE,RSPACE           TEST NUMBER OF LINES TO BE MOVED\n         BCR   13,RWA                  EXIT IF <= ZERO\n         TM    SWITCHES,SP0BIT         DID PREVIOUS LINE SPACE 0?\n         BZ    PREVNOT0                BRANCH IF NOT\n         L     R1,CCLAST               GET ADDRESS OF PREVIOUS LINE\n         BAL   RWB,CCGEN               GENERATE NEW CONTROL CHAR\n         NI    4(R1),X'02'             TEST WRITE/SPACE BIT IN OLD CC\n         STC   R0,4(R1)                STORE NEW CC IN PREVIOUS LINE\n         BNZ   *+8                     BR IF WRITE/SPACE BIT WAS ON\n         NI    4(R1),255-X'02'         TURN WRITE/SPACE BIT OFF\nPREVNOT0 DS    0H\n         MVC   DCBLRECL(2),MOVELINE    SET LOGICAL RECORD LENGTH IN DCB\n         SPACE\n         PUT   PRINTDCB                GET BUFFER ADDRESS IN R1\n         SPACE\n         ST    R1,CCLAST               SAVE LOCATION OF THIS LINE\n         MVC   0(6,R1),MOVELINE        INSERT FORMAT 'V' CONTROL RECORD\n         BAL   RWB,CCGEN               GET PRINT CONTROL CHAR IN R0\n         STC   R0,4(R1)                INSERT IN RECORD\n         SPACE\n         B     MOVE                    LOOP UNTIL 'RSPACE' IS ZERO\n         SPACE 3\nMOVELINE DC    XL6'000600000340'       FORMAT 'V' CONTROL RECORD\n         EJECT\n*****************************************\n* CCGEN - GENERATE PRINTER CONTROL CHAR *\n*****************************************\n         SPACE\n* THIS ROUTINE GENERATES A PRINTER CONTROL CHARACTER TO SPACE OR EJECT\n* IMMEDIATELY (WITHOUT PRINTING).  ENTER WITH THE TOTAL NUMBER OF\n* LINES TO BE MOVED IN 'RSPACE' AND RETURN ADDRESS IN 'RWB'.  EXITS\n* WITH THE CONTROL CHARACTER IN BITS 24-31 OF REGISTER 0 AND THE COUNT\n* IN 'RSPACE' DECREMENTED BY THE AMOUNT WHICH THE CHARACTER WILL SPACE.\n* A SPACE VALUE OF 255 OR GREATER WILL GENERATE AN EJECT CONTROL\n* CHARACTER, SET 'RSPACE' AND 'RBAL' TO ZERO, AND SET THE HEAD-OF-FORM\n* BIT.  NOTE:  MUST NOT USE R1.\n         SPACE 2\nCCGEN    NI    SWITCHES,255-SP0BIT     RESET 'PREVIOUS SPACED 0' BIT\n         CH    RSPACE,=AL2(EJFORCE)    TEST FOR EJECT REQUEST\n         BL    CCNOEJ                  BRANCH IF NOT\n         LA    R0,X'8B'                LOAD 'SKIP TO CHAN 1' CC\n         OI    SWITCHES,HOFBIT         SET HEAD-OF-PAGE BIT\n         SR    RBAL,RBAL               SET PAGE BALANCE TO ZERO\n         SR    RSPACE,RSPACE           SET REMAINING SPACING TO ZERO\n         BR    RWB                     EXIT\n         SPACE\nCCNOEJ   LR    R15,RSPACE              LOAD WORK REGISTER\n         CH    RSPACE,=H'3'            TEST IF OVER THREE LINES\n         BNH   CCOK                    BR IF <= 3\n         LA    R15,3                   SET 3, MAXIMUM FOR 1 OPERATION\nCCOK     SR    RSPACE,R15              DECR RSPACE BY AMOUNT SPACED\n         SLL   R15,3                   PUT AMOUNT IN BITS 2-4 OF BYTE\n         LA    R0,X'03'(R15)           ADD COMMAND BITS AND PUT IN R0\n         LTR   R15,R15                 TEST FOR ZERO SPACING\n         BCR   7,RWB                   EXIT IF NOT ZERO\n         OI    SWITCHES,SP0BIT         SET 'LINE SPACED 0' BIT\n         BR    RWB                     EXIT\n         EJECT\n***********************\n* SYNAD ERROR ROUTINE *\n***********************\n         SPACE\n* IF A PERMANENT I/O ERROR OCCURS, TYPE A DIAGNOSTIC MESSAGE AND ABORT.\n         SPACE\nSYNAD    SYNADAF  ACSMETH=QSAM         GET ERROR MESSAGE FROM O/S\n         LR    RWA,R1                  SAVE MESSAGE ADDRESS\n         GETMAIN  R,LV=128             GET BUFFER FOR MESSAGE\n         MVC   0(LIOMSG,R1),IOMSG      INSERT MESSAGE BEGINNING\n         MVC   LIOMSG(79,R1),49(RWA)   ADD TEXT FROM O/S\n         LR    RWA,R1                  SAVE MESSAGE ADDRESS\n         SYNADRLS                      FREE O/S MESSAGE\n         WTO   MF=(E,(RWA))            TYPE MESSAGE ON CONSOLE\n         LA    R1,7                    LOAD ERROR CODE\n         B     ABEND                   TO ABORT AND DUMP\n         SPACE\nIOMSG    DC    AL2(LIOMSG+78,0)        FORMAT V CONTROL FIELD\n         DC    C'XPRNTSUB I/O ERROR'\nLIOMSG   EQU   *-IOMSG\n         EJECT\n**************************\n* CONSTANTS AND LITERALS *\n**************************\n         SPACE\n* DUMMY PARAMETER LIST AND PLD FOR USE WHEN NO HEADING IS PROVIDED.\n         SPACE\nNOHDLIST DS    0F\n         DC    XL1'80'                 VL LIST BIT\n         DC    AL3(NOHDPLD)            ADDRESS OF PLD BELOW\n         SPACE\nNOHDPLD  DS    0F                      ALIGN ON FULL-WORD BOUNDARY\n         DC    BL1'00010000'           OPTION BITS\n         DC    AL3(BLANK1)             PRINT TEXT ADDRESS\n         DC    AL1(1)                  PRINT TEXT LENGTH\n         DC    AL1(0)                  LEFT MARGIN INDENTATION\n         DC    AL1(0)                  SPACING BEFORE PRINTING\n         DC    AL1(3)                  SPACING AFTER PRINTING\n         SPACE\n* CONSTANTS TO INITIALIZE PARAMETERS AND SWITCHES WHEN 'OPEN' CALL IS\n* RECEIVED.  THE ORDER MUST MATCH THE 'PAPARMS' LIST IN THE WORK AREA.\n         SPACE\nDEFAULTS DS    0F\n         DC    A(NOHDLIST)     PAGE HEADING PARM LIST ADDRESS\n         DC    F'1000000'      MAXIMUM NUMBER OF OUTPUT LINES\n         DC    H'132'          PAGE WIDTH\n         DC    H'57'           PAGE LENGTH\n         DC    H'0'            PAGE NUMBER (-1)\n         DC    H'0'            PAGE BALANCE\n         DC    X'00'           SWITCHES\nDEFSIZE  EQU   *-DEFAULTS\n         SPACE\n* MISCELLANEOUS CONSTANTS:\n         SPACE\nBLANK1   DC    C' '                    TEXT OF DUMMY HEADING LINE\n         LTORG\n         EJECT\n*******************\n* WORK AREA DSECT *\n*******************\n         SPACE\n* THIS DUMMY SECTION DEFINES THE WORK AREA PROVIDED BY THE PROBLEM\n* PROGRAM FOR EACH DATA SET.  ITS ADDRESS IS PASSED IN PARAMETER\n* REGISTER 0 AT EACH CALL.\n         SPACE 2\nWORKAREA DSECT\n         SPACE 2\n* STANDARD 18-WORD SAVE AREA:\n         SPACE\nSAVEAREA DS    18F\n         SPACE 2\n* DATA CONTROL BLOCK FOR PRINTER DATA SET:\n         SPACE\n         PRINT NOGEN\nPRINTDCB DCB   DDNAME=SYSPRINT,                                        X\n               DSORG=PS,                                               X\n               RECFM=VBM,                                              X\n               LRECL=137,                                              X\n               MACRF=PL,                                               X\n               BFTEK=S,                                                X\n               BUFNO=2,                                                X\n               EROPT=ACC\n         PRINT GEN\n         SPACE\nDCBEXLST EQU   PRINTDCB+37     ADDRESS OF EXIT LIST\nDCBOFLGS EQU   PRINTDCB+48     CONTAINS 'OPENED SUCCESSFULLY' BIT\nDCBDDNAM EQU   PRINTDCB+40     DDNAME (WHEN CLOSED)\nDCBSYNAD EQU   PRINTDCB+57     ADDRESS OF SYNCHRONOUS ERROR ROUTINE\nDCBBLKSZ EQU   PRINTDCB+62     BLOCK SIZE\nDCBLRECL EQU   PRINTDCB+82     LOGICAL RECORD LENGTH\n         SPACE 2\n* ADDRESS OF LAST BUFFER OBTAINED BY \"PUT\" MACRO:\n         SPACE\nCCLAST   DS    1A\n         SPACE\n         DS    1F              SPARE FULL WORD\n         SPACE 2\n* TEMPORARY WORK CELLS:\n         SPACE\nDWORK    DS    1D              DOUBLE-WORD WORK CELL\nHPREXIT  DS    1F              HEADPRNT EXIT SAVE\nHPRSAVE  DS    2F              HEADPRNT REGISTER STORAGE\n         SPACE 2\n* PARAMETERS AND SWITCHES WHICH DEFINE THE PAGE SIZE AND STATUS.\n* SEQUENCE MUST MATCH THAT IN 'DEFAULTS', WHICH INITIALIZES THEM.\n         SPACE\nPAPARMS  DS    0F\nHEADLIST DS    1A              PAGE HEADING PARM LIST ADDRESS\nMAXLINES DS    1F              MAXIMUM NUMBER OF OUTPUT LINES\nPAGWIDTH DS    1H              PAGE WIDTH\nPAGELNG  DS    1H              PAGE LENGTH\nPAGENO   DS    1H              PAGE NUMBER OF CURRENT PAGE\nPAGEBAL  DS    1H              PAGE BALANCE\nSWITCHES DS    1X              SWITCHES\n         SPACE 2\n* STORAGE FOR DATE AND TIME PORTION OF PAGE HEADING:\n         SPACE\nHLTXTLNG EQU   24\nHLTEXT   DS    CL(HLTXTLNG)\nHLDAY    EQU   HLTEXT\nHLTIME   EQU   HLTEXT+7\nHLDATE   EQU   HLTEXT+16\n         EJECT\n*************************\n* PARAMETER LIST DSECTS *\n*************************\n         SPACE 2\n* PARAMETER LIST FOR 'EJECT' CALL:\n         SPACE\nEJPARM   DSECT\n         SPACE\nEJCOND   DS    1X              CONDITIONAL MASK AND SWITCHES\nEJQUAN   DS    1X              CONDITIONAL TEST QUANTITY\n         SPACE\nEJATHOF  EQU   X'01'           MASK FOR 'EJCOND'\n         SPACE 6\n* PARAMETER LIST FOR 'SPACE' CALL:\n         SPACE\nSPPARM   DSECT\n         SPACE\nSPCOND   DS    1X              CONDITIONAL BITS\nSPQUAN   DS    1X              NUMBER OF LINES TO SPACE\n         SPACE\nSPATHOF  EQU   X'01'           MASK FOR 'SPCOND'\nSPNOEJ   EQU   X'02'           MASK FOR 'SPCOND'\n         SPACE 6\n* PARAMETER LIST FOR 'OPEN' AND 'MODIFY' CALLS:\n         SPACE\nOMPARM   DSECT\n         SPACE\nOMMAXLIN DS    1F              MAXIMUM NUMBER OF OUTPUT LINES\nOMPAGENO DS    1H              INITIAL PAGE NUMBER\nOMPAGWID DS    1X              PAGE WIDTH\nOMPAGLNG DS    1X              PAGE LENGTH\nOMTIMEAD DS    1A              ADDRESS OF TIME\nOMDATEAD DS    1A              ADDRESS OF DATE\nOMDDNAME DS    CL8             DDNAME (OPEN CALL ONLY)\n         EJECT\n*************\n* PLD DSECT *\n*************\n         SPACE\n* PRINT LINE DESCRIPTOR DUMMY SECTION:\n         SPACE 2\n*        ******************************************************\n*        *            *                                       *\n*        *   OPTION   *                                       *\n*        *    BITS    *             TEXT ADDRESS              *\n*        *            *                                       *\n*        ******************************************************\n*        *            *            *            *             *\n*        *    TEXT    *    TEXT    *   SPACE    *    SPACE    *\n*        *   LENGTH   *   OFFSET   *   BEFORE   *    AFTER    *\n*        *            *            *            *             *\n*        ******************************************************\n         SPACE 3\nPLDBLOCK DSECT\n         SPACE\nPLDFLAGS DS    1X              OPTION BITS\nPLDTXTAD DS    AL3             TEXT ADDRESS\nPLDLNGTH DS    1X              TEXT LENGTH\nPLDOFFST DS    1X              TEXT OFFSET, OR LEFT MARGIN\nPLDSPB   DS    1X              AMOUNT TO SPACE BEFORE PRINTING\nPLDSPA   DS    1X              AMOUNT TO SPACE AFTER PRINTING\n         SPACE 2\nPRHOFBIT EQU   B'00000010'     MASK FOR 'PLDFLAGS'\nPRSKPBIT EQU   B'00000001'     MASK FOR 'PLDFLAGS'\nSPSKPBIT EQU   B'00010000'     MASK FOR 'PLDFLAGS'\n         SPACE 6\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WFBNOTE": {"ttr": 9732, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87(\\x7f\\x00\\x87(\\x7f\\x12\\x00\\x00#\\x00#\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf2\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-10-14T00:00:00", "modifydate": "1987-10-14T12:00:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "FILE325"}, "text": ")ATTR\n  $ TYPE(TEXT) INTENS(HIGH) SKIP(ON)\n  \u00a2 TYPE(TEXT) INTENS(LOW)  SKIP(ON)\n  < TYPE(INPUT) INTENS(HIGH) CAPS(OFF)\n)BODY\n%----------------------  Wells Fargo Bank NOTE Facility  -----------------------\n%COMMAND ===>_ZCMD                                                             +\n%\n+  Names may be entered as%NICKNAME+or%NODE.USERID\n%\n%  To:_NICK1            $     To:_NICK6            $     To:_NICK11           \u00a2\n$  To:_NICK2            $     To:_NICK7            $     To:_NICK12           \u00a2\n$  To:_NICK3            $     To:_NICK8            $     To:_NICK13           \u00a2\n$  To:_NICK4            $     To:_NICK9            $     To:_NICK14           \u00a2\n$  To:_NICK5            $     To:_NICK10           $     To:_NICK15           \u00a2\n%\n+  &SUBMSG\n%\n+  SUBJECT:<SUBJECT                                                           +\n%\n+  PROLOG:_Z   \u00a2    EPILOG:_Z   \u00a2    COPYLIST:_Z  \u00a2      PROFS Node:_PROFNODE+\n%\n%  OPTION ==>_Z+ Enter:&MAILMSG E to edit, or C to cancel the note.\n%\n%\n)INIT\n  .ZVARS = '(PROLOG EPILOG COPYLIST OPTION)'\n)PROC\n  VER (&OPTION,NONBLANK,LIST,E,M,C)\n  VER (&PROLOG,ALPHA)\n  VER (&EPILOG,ALPHA)\n  VER (&COPYLIST,ALPHA)\n  VER (&PROFNODE,NONBLANK,ALPHA)\n  &SCREEN = &ZSCREEN   /* Set variable for clist use. */\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT325/FILE325.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT325", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}