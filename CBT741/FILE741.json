{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012710000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 176358, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE741.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE741.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x04\\x05'", "DS1TRBAL": "b'\\x85\\x14'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x05\\x0b\\x00\\x00\\x05\\x0b\\x00\\x04\\x00\\x05'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04K\\x00\\x00\\x01\\x07#\\x1f\\x01\\x07#\\x1f\\x08X\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf5@@@'", "ispf": {"version": "04.75", "flags": 0, "createdate": "2007-08-19T00:00:00", "modifydate": "2007-08-19T08:58:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-475"}, "text": "REGULAR CBT TAPE - VERSION 475    FILE:  741\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT475.FILE741\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 6 MEMBERS COUNTED; CUMULATIVE SIZE IS 1,372 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   08/19/07    08:58:42    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE741": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04K\\x00\\x00\\x01\\x07#\\x1f\\x01\\x07#\\x1f\\x08X\\x00\\t\\x00\\t\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf5@@@'", "ispf": {"version": "04.75", "flags": 0, "createdate": "2007-08-19T00:00:00", "modifydate": "2007-08-19T08:58:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "CBT-475"}, "text": "//***FILE 741 is from Bill Godfrey and contains an Assembler        *   FILE 741\n//*           program to create BASE64 encoding for a file, and     *   FILE 741\n//*           also to decode it from BASE64 encoding.               *   FILE 741\n//*                                                                 *   FILE 741\n//*           Two versions are here, the new version is AMODE 31,   *   FILE 741\n//*           while the old one is AMODE 24.                        *   FILE 741\n//*                                                                 *   FILE 741\n//*           email:  bill.godfrey@noaa.gov                         *   FILE 741\n//*                                                                 *   FILE 741\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ERRATA": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x07#\\x1f\\x01\\x07#\\x1f\\x083\\x004\\x004\\x00\\x00\\xc7\\xd6\\xc4\\xc6\\xd9\\xc5\\xe8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-08-19T00:00:00", "modifydate": "2007-08-19T08:33:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "GODFREY"}, "text": "December 16 2006\n\nThere is a bug in the original version of MAKEB64 and MAKEB64O\nfrom April 2006. They will go into an output loop if the number\nof bytes in the input file is a multiple of 57.\n\nHere is how to correct the code to eliminate the bug.\n\nIn this sequence:\n\n   EGET     BAL   R14,GET57           READ 57 INTO IBUF\n            LR    R7,R0               GET LENGTH TO ENCODE\n            BAL   R14,ENCODE\n            LR    R6,R0               GET LENGTH TO PUT\n            BAL   R14,PUT76\n            CH    R6,=H'76'           IF NO EOF YET\n            BE    EGET                   THEN LOOP\n            B     EXITN\n\nchange the \"CH\" line to this:\n\n            CLI   GOTEOD,0\n\nso the sequence looks like this:\n\n   EGET     BAL   R14,GET57           READ 57 INTO IBUF\n            LR    R7,R0               GET LENGTH TO ENCODE\n            BAL   R14,ENCODE\n            LR    R6,R0               GET LENGTH TO PUT\n            BAL   R14,PUT76\n            CLI   GOTEOD,0            IF NO EOF YET\n            BE    EGET                   THEN LOOP\n            B     EXITN\n\nThen in this sequence:\n\n   GET5E    LA    R0,57\n            S     R0,GETREGS+16       COMPUTE HOW MANY BYTES\n            L     R14,GETREGS+8\n            BR    R14\n\ninsert this instruction:\n\n            XC    GETREGS(8),GETREGS\n\nso it looks like this:\n\n   GET5E    LA    R0,57\n            S     R0,GETREGS+16       COMPUTE HOW MANY BYTES\n            XC    GETREGS(8),GETREGS\n            L     R14,GETREGS+8\n            BR    R14\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MAKEB64": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x07#\\x1f\\x01\\x07#\\x1f\\x08V\\x02\\xa0\\x02\\xa0\\x00\\x00\\xc7\\xd6\\xc4\\xc6\\xd9\\xc5\\xe8@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2007-08-19T00:00:00", "modifydate": "2007-08-19T08:56:00", "lines": 672, "newlines": 672, "modlines": 0, "user": "GODFREY"}, "text": "         TITLE '   M A K E B 6 4   '\n* WRITTEN FEBRUARY 7 2002\n* UPDATED DECEMBER 18 2006\n* ENCODE A FILE TO A BASE64 FILE,\n* OR IF PARM=D, REVERSE THE PROCESS AND DECODE IT.\n*\n* DDNAMES: SYSUT1 (INPUT) AND SYSUT2 (OUTPUT)\n*\n* IF PARM CONTAINS 'R' THEN RDW'S WILL BE ENCODED IF INPUT IS V.\n* THERE IS NO ASCII CONVERSION.\n* RECORD BOUNDARIES ARE NOT MARKED.\n*\n* DECODING WRITES A FIXED-LENGTH 80-BYTE RECORD FILE,\n* SO IF THE ORIGINAL FILE WAS THAT TYPE THEN IT SHOULD WORK.\n* A FILE PRODUCED BY THE TSO TRANSMIT COMMAND, FOR EXAMPLE.\n* IF THE ORIGINAL FILE RECORD FORMAT WAS FIXED-LENGTH, AND THE\n* DECODER OUTPUT FILE IS FIXED-LENGTH WITH THE SAME RECORD LENGTH\n* AS THE ORIGINAL, THEN THE DECODED FILE SHOULD MATCH THE ORIGINAL.\n*\n* OTHER FILE TYPES CAN BE ENCODED, BUT DECODING THEM WITH THIS\n* PROGRAM WILL NOT KEEP THE ORIGINAL FILE FORMAT.\n* EVEN IF THE FILE WAS ENCODED WITH RDW'S INCLUDED,\n* THE DECODE LOGIC DOES NOT USE THEM.\n*\n* BASE64 ENCODING, IN A NUTSHELL.\n*  FOR EVERY 3 BYTES READ, THE 24 BITS ARE SPREAD OUT INTO A\n*  32-BIT OUTPUT GROUP 00XXXXXX 00XXXXXX 00XXXXXX 00XXXXXX.\n*  THAT MAKES 4 BYTES, EACH WITH A VALUE IN THE RANGE 0 TO 63.\n*  THEN TRANSLATE VALUES 0 THRU 25 TO CAPITAL 'A' THRU 'Z',\n*  VALUES 26 THRU 51 TO LOWERCASE 'A' THRU 'Z',\n*  VALUES 52 THRU 63 TO '0' THRU '9', '+' AND '/'.\n*  IF AT FILE-END THE LAST GROUP OF 3 HAD ONLY 1 BYTE, THE 4-BYTE\n*  OUTPUT GROUP IS 00XXXXXX 00XX0000 TRANSLATED, PLUS \"==\".\n*  IF AT FILE-END THE LAST GROUP OF 3 HAD ONLY 2 BYTES, THE 4-BYTE\n*  OUTPUT GROUP IS 00XXXXXX 00XXXXXX 00XXXX00 TRANSLATED, PLUS \"=\".\n*  EACH OUTPUT LINE SHOULD BE NO LONGER THAN 76 BYTES (19 GROUPS OF 4)\n*  WHICH IS WHAT YOU WOULD GET FROM 57 INPUT BYTES (19 GROUPS OF 3).\n*\n* DISCLAIMER: NO GUARANTEE; NO WARRANTY; INSTALL/USE AT YOUR OWN RISK.\n*\n* LOG OF CHANGES:\n*  APR 14 2006 - FIX BUGS IN PUT57, WAS USING INPUT DCB RECFM LRECL ETC\n*  APR 14 2006 - CONVERT FROM 24-BIT PROGRAM TO 31-BIT PROGRAM.\n*  APR 15 2006 - REMOVE GETMAIN, ADD MODE=31 TO MF=E OPENS.\n*  DEC 18 2006 - FIX OUTPUT LOOPING WHEN FILE SIZE IS MULTIPLE OF 57\n         SPACE\nMAKEB64  RMODE ANY\nMAKEB64  AMODE 31\nMAKEB64  CSECT\n         USING *,R10\n         B     @PROLOG-*(,R15)\n         DC    AL1(7),CL7'MAKEB64'\n         DC    CL16' &SYSDATE &SYSTIME '\n@SIZE    DC    0F'0',AL1(0),AL3(@DATAL)\n@PROLOG  STM   14,12,12(13)\n         LR    R10,R15\n         LR    R2,R1               POINT R2 TO PARM ADDRESS\n         L     R0,@SIZE\n         STORAGE OBTAIN,LENGTH=(0)\n         LR    R9,R1               POINT R9 TO OBTAINED AREA\n         XC    0(@CLEARL,R9),0(R9)\n         USING @DATA,R9\n         ST    R13,4(,R9)          OLD ADDRESS IN NEW SAVE AREA\n         ST    R9,8(,R13)          NEW ADDRESS IN OLD SAVE AREA\n         LR    R13,R9              POINT R13 TOP NEW SAVE AREA\n         SPACE\n         LA    R0,@DATA24L\n         STORAGE OBTAIN,LENGTH=(0),LOC=24\n         LR    R8,R1               POINT R8 TO OBTAINED AREA\n         USING @DATA24,R8\n         SPACE\n         L     R1,0(,R2)           POINT TO PARM\n         LH    R14,0(,R1)          LENGTH OF PARM\n         LTR   R14,R14\n         BZ    PARMX\n         LA    R15,2(,R1)\nPARMLOOP CLI   0(R15),C'D'         IF PARM CONTAINS D\n         BNE   *+8                   THEN\n         MVI   OPTD,1                TURN ON DECODE OPTION\n         CLI   0(R15),C'R'         IF PARM CONTAINS R\n         BNE   *+8                   THEN\n         MVI   OPTR,1                TURN ON RDW OPTION\n         LA    R15,1(,R15)\n         BCT   R14,PARMLOOP\nPARMX    EQU   *\n         SPACE\n         LA    R15,12\n         ST    R15,RETCODE\n         SPACE\n         LA    R3,UT1DCBW\n         LA    R4,UT2DCBW\n         MVC   0(UT1DCBL,R3),UT1DCB\n         MVC   0(UT2DCBL,R4),UT2DCB\n         SPACE\n         LA    R5,UT1DCBEW\n         LA    R6,UT2DCBEW\n         MVC   0(UT1DCBEL,R5),UT1DCBE\n         MVC   0(UT2DCBEL,R6),UT2DCBE\n         ST    R5,0(,R3)           ST    R5,DCBDCBE-IHADCB(,R3)\n         ST    R6,0(,R4)           ST    R5,DCBDCBE-IHADCB(,R3)\n         SPACE\n         LA    R1,UT2EXLST         POINT TO OPEN EXIT LIST\n         ST    R1,EXLST(,R4)       STORE ADDRESS OF EXIT LIST IN DCB\n         LA    R15,UT2OPENX        POINT TO OPEN EXIT ENTRY POINT\n         ST    R15,0(,R1)          STORE ADDRESS OF EXIT IN EXIT LIST\n         MVI   0(R1),X'85'         SET HIGH BYTE OF EXIT LIST\n         MVC   0(UT2OPENL,R15),UT2GLUE  COPY EXIT TO 24-BIT STORAGE\n         LA    R0,UT2EXIT          POINT TO 31-BIT EXIT\n         O     R0,=A(X'80000000')  SET 31-BIT MODE IN ADDRESS\n         ST    R0,UT2GLUEP-UT2GLUE(,R15) STORE EXIT ADDRESS FOR GLUE\n         SPACE\n         MVC   OPEN31W(OPEN31L),OPEN31\n         OPEN  ((R3),INPUT),MODE=31,MF=(E,OPEN31W)\n*        TM    OFLGS(R3),X'10'     TEST FOR SUCCESSFUL OPEN\n*        TM    16(R5),X'C0'        TM    DCBEFLG1,DCBEOPEN+DCBEMD31\n         TM    DCBEFLG1-DCBE(R5),DCBEOPEN+DCBEMD31 OPEN AND 31-BIT SAM\n         BNO   EXIT\n         SPACE\n         OPEN  ((R4),OUTPUT),MODE=31,MF=(E,OPEN31W)\n         TM    DCBEFLG1-DCBE(R6),DCBEOPEN+DCBEMD31 OPEN AND 31-BIT SAM\n         BNO   EXITC1\n         SPACE\n         XC    GETREGS(8),GETREGS\n         XC    PUTREGS(8),PUTREGS\n         SR    R6,R6\n         CLI   OPTD,0\n         BNE   DEKO\n         XC    ORDW(4),ORDW CLEAR RDW\nEGET     BAL   R14,GET57           READ 57 INTO IBUF\n         LR    R7,R0               GET LENGTH TO ENCODE\n         BAL   R14,ENCODE\n         LR    R6,R0               GET LENGTH TO PUT\n         BAL   R14,PUT76\n         CLI   GOTEOD,0            IF NO EOF YET    .DEC-18-2006.\n         BE    EGET                   THEN LOOP\n         B     EXITN\nDEKO     EQU   *\nDGET     BAL   R14,GET76           READ 76 INTO IBUF\n         LTR   R7,R0               GET LENGTH TO DECODE\n         BZ    DFLUSH              BRANCH IF EOF (OR EMPTY LINE)\n         BAL   R14,DECODE\n         LR    R6,R0               GET LENGTH TO PUT\n         BAL   R14,PUT57\n         CLI   GOTEQL,0            IF WE FOUND '='\n         BNE   DFLUSH                 THEN STOP\n         B     DGET                GO READ NEXT LINE\nDFLUSH   BAL   R14,PUT57Q          WRITE REMAINING OBUF\n         B     EXITN\n         SPACE\n*         ENCODE - ENCODE IBUF TO OBUF, R7 HAS IBUF LENGTH\n*          RETURNS OUTPUT LENGTH IN R0\n         SPACE\nENCODE   LA    R5,IBUF\n         LA    R15,OBUF\n         MVI   0(R15),C' '         FILL\n         MVC   1(79,R15),0(R15)     WITH BLANKS\n         SR    R0,R0               PREPARE FOR DIVIDE\n         LR    R1,R7               PREPARE FOR DIVIDE\n         D     R0,=F'3'            COMPUTE NUMBER OF 3-BYTE GROUPS\n         LTR   R1,R1\n         BZ    EREST\nELOOP    MVC   ALIGN(3),0(R5)      COPY A 3-BYTE GROUP\n         L     R7,ALIGN\n         SR    R6,R6\n         SLDL  R6,6\n         STC   R6,0(R15)\n         SR    R6,R6\n         SLDL  R6,6\n         STC   R6,1(R15)\n         SR    R6,R6\n         SLDL  R6,6\n         STC   R6,2(R15)\n         SR    R6,R6\n         SLDL  R6,6\n         STC   R6,3(R15)\n         TR    0(4,R15),TABE64\n         LA    R15,4(,R15)\n         LA    R5,3(,R5)\n         BCT   R1,ELOOP\nEREST    LTR   R0,R0\n         BZ    EDONE\n         BCT   R0,ERES2            FALL THRU IF R0 = 1\n         IC    R7,0(,R5)\n         SLL   R7,24               ICM R7,8,0(R5)\n         SR    R6,R6\n         SLDL  R6,6\n         STC   R6,0(R15)\n         SR    R6,R6\n         SLDL  R6,6\n         STC   R6,1(R15)\n         TR    0(2,R15),TABE64\n         MVI   2(R15),C'='\n         MVI   3(R15),C'='\n         LA    R15,4(,R15)\n*        LA    R5,1(,R5)\n         B     EDONE\n         SPACE\nERES2    MVC   ALIGN(2),0(R5)\n         LH    R7,ALIGN\n         SLL   R7,16               ICM R7,12,0(R5)\n         SR    R6,R6\n         SLDL  R6,6\n         STC   R6,0(R15)\n         SR    R6,R6\n         SLDL  R6,6\n         STC   R6,1(R15)\n         SR    R6,R6\n         SLDL  R6,6\n         STC   R6,2(R15)\n         TR    0(3,R15),TABE64\n         MVI   3(R15),C'='\n         LA    R15,4(,R15)\n*        LA    R5,2(,R5)\nEDONE    LA    R1,OBUF\n         LR    R0,R15\n         SR    R0,R1               COMPUTE LENGTH\n         BR    R14\n         SPACE\n*         DECODE - DECODE IBUF TO DBUF, R7 HAS IBUF LENGTH\n*          RETURNS OUTPUT LENGTH IN R0\n         SPACE\nDECODE   LA    R5,IBUF\n         LA    R15,DBUF\n         SR    R0,R0               PREPARE FOR DIVIDE\n         LR    R1,R7               PREPARE FOR DIVIDE\n         D     R0,=F'4'            COMPUTE NUMBER OF 4-BYTE GROUPS\n         LTR   R1,R1\n         BZ    DREST\nDLOOP    CLI   0(R5),C'='          SHOULD NOT HAVE '=' AS 1ST CHAR\n         BE    DLASX\n         CLI   1(R5),C'='          SHOULD NOT HAVE '=' AS 2ND CHAR\n         BE    DLASX\n         CLI   2(R5),C'='          CHECK FOR '=' AS 3RD CHAR\n         BE    DLAST\n         CLI   3(R5),C'='          CHECK FOR '=' AS 4TH CHAR\n         BE    DLAST\n         MVC   ALIGN(4),0(R5)\n         TR    ALIGN(4),TABD64\n         L     R7,ALIGN\n         SR    R6,R6\n         SLDL  R6,8\n         SLL   R7,2\n         SLDL  R6,2\n         STC   R6,0(R15)\n         SLDL  R6,4\n         SLL   R7,2\n         SLDL  R6,4\n         STC   R6,1(R15)\n         SLDL  R6,2\n         SLL   R7,2\n         SLDL  R6,6\n         STC   R6,2(R15)\n         LA    R15,3(,R15)\n         LA    R5,4(,R5)\n         BCT   R1,DLOOP\nDREST    LTR   R0,R0\n         BZ    DDONE\n         NOPR  0                   PLACE FOR BREAKPOINT\n         B     DLASE\nDLASX    NOPR  0                   PLACE FOR BREAKPOINT\nDLASE    MVI   RETCODE+3,8         THERE SHOULD BE NO REMAINDER\n         MVI   GOTEQL,1\n         B     DDONE\nDLAST    CLI   2(R5),C'='          IF '=' IS 3RD CHAR\n         BE    DLAS1                 DECODE 2 TO 1\n         MVC   ALIGN(3),0(R5)      COPY XXX TO DECODE 3 TO 2\n         TR    ALIGN(3),TABD64\n         L     R7,ALIGN\n         SR    R6,R6\n         SLDL  R6,8\n         SLL   R7,2\n         SLDL  R6,2\n         STC   R6,0(R15)\n         SLDL  R6,4\n         SLL   R7,2\n         SLDL  R6,4\n         STC   R6,1(R15)\n         LA    R15,2(,R15)\n*        LA    R5,4(,R5)\n         MVI   GOTEQL,1\n         B     DDONE\nDLAS1    MVC   ALIGN(2),0(R5)      COPY XX FROM XX==\n         TR    ALIGN(2),TABD64\n         L     R7,ALIGN\n         SR    R6,R6\n         SLDL  R6,8\n         SLL   R7,2\n         SLDL  R6,2\n         STC   R6,0(R15)\n         LA    R15,1(,R15)\n         MVI   GOTEQL,1\nDDONE    LA    R1,DBUF\n         LR    R0,R15\n         SR    R0,R1               COMPUTE LENGTH\n         BR    R14\n         SPACE\n*         GET57 - READ UP TO 57 BYTES INTO IBUF, SET R0 TO COUNT\n         SPACE\nGET57    LM    R5,R6,GETREGS\n         LA    R15,IBUF\n         LA    R0,57\nGET5A    CR    R5,R6               IF END OF RECORD\n         BNL   GET5R                 THEN READ NEXT RECORD\n         MVC   0(1,R15),0(R5)      COPY ONE BYTE TO OBUF\n         LA    R15,1(,R15)         NEXT OBUF BYTE\n         LA    R5,1(,R5)           NEXT IBUF BYTE\n         BCT   R0,GET5A            DECREMENT R0 AND LOOP\n         LA    R0,57               SET RETURNED LENGTH\n         STM   R5,R6,GETREGS\n         BR    R14\nGET5R    STM   R14,R0,GETREGS+8\n         CLI   GOTEOD,0            IF WE ALREADY HIT EODAD\n         BNE   UT1EOD                GO THERE AGAIN\n         GET   (R3)\n         LR    R5,R1\n         TM    RECFM(R3),X'C0'     RECFM U\n         BO    GET5U\n         TM    RECFM(R3),X'80'     RECFM F\n         BO    GET5F\nGET5V    LA    R0,4\n         LH    R6,0(,R5)           LENGTH+4 FROM RDW\n         CLI   OPTR,0              IF R IN PARM\n         BNE   GET5W                  INCLUDE RDW\n         AR    R5,R0               POINT PAST RDW\n         SR    R6,R0               REDUCE LENGTH\nGET5W    AR    R6,R5               POINT TO END OF RECORD\n         B     GET5X\nGET5U    LH    R6,LRECL(,R3)\n         AR    R6,R5               POINT TO END OF RECORD\n         B     GET5X\nGET5F    LH    R6,LRECL(,R3)       GET LENGTH FROM LRECL\n         TM    RECFM(R3),X'10'     IF NOT BLOCKED\n         BO    *+8                   THEN\n         LH    R6,BLKSI(,R3)         USE BLKSIZE AS LENGTH\n         AR    R6,R5               POINT TO END OF RECORD\nGET5X    LM    R14,R0,GETREGS+8\n         B     GET5A\nGET5E    LA    R0,57\n         S     R0,GETREGS+16       COMPUTE HOW MANY BYTES IN IBUF\n         XC    GETREGS(8),GETREGS                   .DEC-18-2006.\n         L     R14,GETREGS+8\n         BR    R14\n         SPACE\n*         GET76 - READ NEXT RECORD AND COPY UP TO 76 NONBLANKS TO IBUF\n*                 SET R0 TO COUNT\n         SPACE\nGET76    ST    14,GETREGS\n         GET   (R3)\n         LR    R5,R1\n         TM    RECFM(R3),X'C0'     RECFM U\n         BO    GET7U\n         TM    RECFM(R3),X'80'     RECFM F\n         BO    GET7F\nGET7V    LA    R0,4\n         LH    R6,0(,R5)           LENGTH+4 FROM RDW\n         AR    R5,R0               POINT PAST RDW\n         SR    R6,R0               REDUCE LENGTH\n         AR    R6,R5               POINT TO END OF RECORD\n         B     GET7M\nGET7U    LH    R6,LRECL(,R3)\n         AR    R6,R5               POINT TO END OF RECORD\n         B     GET7M\nGET7F    LH    R6,LRECL(,R3)       GET LENGTH FROM LRECL\n         TM    RECFM(R3),X'10'     IF NOT BLOCKED\n         BO    *+8                   THEN\n         LH    R6,BLKSI(,R3)         USE BLKSIZE AS LENGTH\n         AR    R6,R5               POINT TO END OF RECORD\nGET7M    SR    R1,R1               CLEAR COUNTER\n         LA    R15,IBUF\n         LA    R0,76\nGET7N    CR    R1,R0               IF WE HAVE DONE 76\n         BNL   GET7W                  STOP NOW\n         CR    R5,R6               IF END OF RECORD\n         BNL   GET7W                  STOP NOW\n         CLI   0(R5),C' '          IF BLANK\n         BE    GET7S                  IGNORE\n         MVC   0(1,R15),0(R5)      COPY ONE BYTE TO IBUF\n         LA    R15,1(,R15)         NEXT IBUF BYTE\n         LA    R1,1(,R1)           COUNT BYTES\nGET7S    LA    R5,1(,R5)           NEXT INPUT BYTE\n         B     GET7N\nGET7W    LR    R0,R1\nGET7X    L     R14,GETREGS\n         BR    R14\nGET7E    SR    R0,R0\n         B     GET7X\n         SPACE\nUT1EOD   MVI   GOTEOD,1\n         CLI   OPTD,0              IF ENCODING\n         BE    GET5E                  RETURN TO ENCODE LOGIC\n         B     GET7E               ELSE RETURN TO DECODE LOGIC\n         SPACE\n*         PUT76 - WRITE OBUF (LENGTH IN R6)\n         SPACE\nPUT76    LTR   R6,R6\n         BZR   R14\n         ST    R14,PUTREGS\n         TM    RECFM(R4),X'C0'\n         BO    PUT7U\n         TM    RECFM(R4),X'80'\n         BO    PUT7F\nPUT7V    LA    R6,4(,R6)\n         CH    R6,LRECL(,R4)       IF RECORD TOO LONG\n         BNH   PUT7V2                 THEN\n         LH    R6,LRECL(,R4)          TRUNCATE IT\n         MVI   RETCODE+3,4            SET PROGRAM RETURN CODE TO 4\nPUT7V2   STH   R6,ORDW             SET LENGTH IN RDW\n         PUT   (R4),ORDW\n         LA    R0,4\n         SR    R6,R0\n         L     R14,PUTREGS\n         BR    R14\nPUT7U    STH   R6,LRECL(,R4)\nPUT7F    PUT   (R4),OBUF\n         L     R14,PUTREGS\n         BR    R14\n         SPACE\n*         PUT57 - WRITE NEXT COUNT=R6 BYTES FROM DBUF TO OBUF\n*                 WRITE A RECORD WHENEVER OBUF FILLS UP.\n*                 SHOULD CALL PUT57Q BEFORE CLOSING\n         SPACE\nPUT57    LTR   R6,R6\n         BZR   R14\n         ST    R6,PUTREGS+20\n         LR    R0,R6\n         LM    R5,R6,PUTREGS\n         LA    R15,DBUF\n         LTR   R5,R5               IF FIRST TIME\n         BNZ   PUT5A                  FALL THRU\nPUT5I    LA    R5,OBUF\n         XC    OBUF(256),OBUF\n         TM    RECFM(R4),X'C0'\n         BO    PUT5IU\n         TM    RECFM(R4),X'80'\n         BO    PUT5IF\n         LH    R6,LRECL(,R4)       GET LENGTH FROM LRECL\n         TM    RECFM(R4),X'10'     IF NOT BLOCKED\n         BO    *+8                   THEN\n         LH    R6,BLKSI(,R4)         USE BLKSIZE AS LENGTH\n         LA    R0,4\n         SR    R6,R0\n         B     PUT5IL\nPUT5IU   LH    R6,BLKSI(,R4)       GET LENGTH FROM BLKSI\n         B     PUT5IL\nPUT5IF   LH    R6,LRECL(,R4)       GET LENGTH FROM LRECL\n         TM    RECFM(R4),X'10'     IF NOT BLOCKED\n         BO    *+8                   THEN\n         LH    R6,BLKSI(,R4)         USE BLKSIZE AS LENGTH\nPUT5IL   AR    R6,R5\nPUT5A    CR    R5,R6               IF END OF RECORD\n         BNL   PUT5W                 THEN WRITE THE RECORD\n         MVC   0(1,R5),0(R15)      COPY ONE BYTE TO OBUF\n         LA    R5,1(,R5)           NEXT OBUF BYTE\n         LA    R15,1(,R15)         NEXT DBUF BYTE\n         BCT   R0,PUT5A            DECREMENT R0 AND LOOP\n         L     R0,PUTREGS+20       SET RETURNED LENGTH\n         STM   R5,R6,PUTREGS       SAVE FOR NEXT TIME\n         BR    R14                 RETURN\nPUT57Q   L     R5,PUTREGS\n         LTR   R5,R5               IF PUT57 WAS NEVER CALLED\n         BZR   R14                    RETURN\n         LA    R0,OBUF             IF OBUF CURSOR AT COLUMN 1\n         CR    R5,R0                  THEN\n         BER   R14                    RETURN\n         ST    R14,PUTREGS+24\n         BAL   R14,PUT5P\n         STM   R5,R6,PUTREGS\n         L     R14,PUTREGS+24\n         BR    R14\nPUT5W    ST    R14,PUTREGS+28\n         BAL   R14,PUT5P\n         L     R14,PUTREGS+28\n         B     PUT5A\nPUT5P    STM   R14,R0,PUTREGS+8\n         TM    RECFM(R4),X'C0'\n         BO    PUT5U\n         TM    RECFM(R4),X'80'\n         BO    PUT5F\nPUT5V    LR    R1,R5\n         LA    R0,ORDW\n         SR    R1,R0               COMPUTE LENGTH\n         CH    R1,LRECL(,R4)       IF RECORD TOO LONG\n         BNH   PUT5V2                 THEN\n         LH    R1,LRECL(,R4)          TRUNCATE IT\n         MVI   RETCODE+3,4            SET PROGRAM RETURN CODE TO 4\nPUT5V2   STH   R1,ORDW             SET LENGTH IN RDW\n         PUT   (R4),ORDW\n         LA    R5,OBUF\n         LH    R6,LRECL(,R4)       GET LENGTH FROM LRECL\n         TM    RECFM(R4),X'10'     IF NOT BLOCKED\n         BO    *+8                   THEN\n         LH    R6,BLKSI(,R4)         USE BLKSIZE AS LENGTH\n         LA    R0,4\n         SR    R6,R0\n         B     PUT5L\nPUT5U    LR    R1,R5\n         LA    R0,OBUF\n         SR    R1,R0               COMPUTE LENGTH\n         STH   R1,LRECL(,R4)\n         PUT   (R4),OBUF\n         LA    R5,OBUF\n         LH    R6,BLKSI(,R4)\n         B     PUT5L\nPUT5F    PUT   (R4),OBUF\n         LA    R5,OBUF\n         LH    R6,LRECL(,R4)       GET LENGTH FROM LRECL\n         TM    RECFM(R4),X'10'     IF NOT BLOCKED\n         BO    *+8                   THEN\n         LH    R6,BLKSI(,R4)         USE BLKSIZE AS LENGTH\nPUT5L    AR    R6,R5               POINT TO END OF RECORD\n         XC    OBUF(256),OBUF\n         LM    R14,R0,PUTREGS+8\n         BR    R14\n         SPACE\nEXITN    CLI   RETCODE+3,12        IF AN ERROR OCCURRED\n         BNE   EXITC2                DON'T SET RC 0\nEXIT0    MVI   RETCODE+3,0\nEXITC2   MVC   CLOSE31W(CLOSE31L),CLOSE31\n         CLOSE ((R4)),MODE=31,MF=(E,CLOSE31W)\n*        LR    R6,R4\n*        BAL   R2,FREEPOOL\nEXITC1   MVC   CLOSE31W(CLOSE31L),CLOSE31\n         CLOSE ((R3)),MODE=31,MF=(E,CLOSE31W)\n*        LR    R6,R3\n*        BAL   R2,FREEPOOL\n         B     EXIT\n*REEPOOL FREEPOOL (R6)\n*        BR    R2\nEXIT     L     R2,RETCODE\n         LR    R1,R8\n         LA    R0,@DATA24L\n         STORAGE RELEASE,ADDR=(1),LENGTH=(0)\n         LR    R1,R13\n         L     R0,@SIZE\n         L     R13,4(,R13)\n         STORAGE RELEASE,ADDR=(1),LENGTH=(0)\n         DROP  R9\n         LR    R15,R2\n         LM    0,12,20(R13)\n         L     R14,12(,R13)\n         BR    R14\n         SPACE\n*         DCB OPEN EXIT\nUT2EXIT  CLI   RECFM(R1),0         IF NO RECFM\n         BNE   UT2EXI2                THEN\n         MVI   RECFM(R1),X'90'        USE FB\nUT2EXI2  TM    RECFM(R1),X'10'     IF BLOCKED\n         BZ    UT2EXI3                AND\n         CLC   LRECL(2,R1),=H'0'      NO LRECL\n         BNE   UT2EXI3                THEN\n         MVC   LRECL(2,R1),=H'80'     USE 80\nUT2EXI3  CLC   BLKSI(2,R1),=H'0'   IF NO BLKSIZE\n         BNE   UT2EXI4                THEN\n         MVC   BLKSI(2,R1),=H'10720'  USE 5 PER 3390 TRACK\nUT2EXI4  BR    R14\n         SPACE\n*        THIS ROUTINE IS COPIED TO 24-BUT STORAGE\n*        IT IS ENTERED IN 24-BIT MODE, CALLS UT2EXIT IN 31-BIT MODE\n*        LEAVING ORIGINAL R14 RETURN ADDRESS IN R14\n         CNOP  0,4                 ALIGN ON FULLWORD\nUT2GLUE  L     R15,UT2GLUEP-*(,R15)   GET ADDRESS OF UT2EXIT\n         BSM   R14,R15             CALL UT2EXIT WITH OLD MODE IN R14\nUT2GLUEP DC    F'0'                WILL CONTAIN ADDRESS OF UT2EXIT\nUT2OPENL EQU   *-UT2GLUE\n         SPACE\n         LTORG\n         DC    0D'0'\n         PRINT NOGEN\nUT1DCB   DCB   DDNAME=SYSUT1,DSORG=PS,MACRF=(GL),EODAD=0,DCBE=0\nUT1DCBL  EQU   *-UT1DCB\nUT1DCBE  DCBE  RMODE31=BUFF,EODAD=UT1EOD\nUT1DCBEL EQU   *-UT1DCBE\nUT2DCB   DCB   DDNAME=SYSUT2,DSORG=PS,MACRF=(PM),EXLST=0,DCBE=0\nUT2DCBL  EQU   *-UT2DCB\nUT2DCBE  DCBE  RMODE31=BUFF\nUT2DCBEL EQU   *-UT2DCBE\nUT2EXL   DC    0F'0',X'85',AL3(0)\nOPEN31   OPEN  (0,),MODE=31,MF=L\nOPEN31L  EQU   *-OPEN31\nCLOSE31  CLOSE (0,),MODE=31,MF=L\nCLOSE31L EQU   *-CLOSE31\n         DC    0D'0'\nTABE64   DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n         DC    X'818283848586878889'\n         DC    X'919293949596979899'\n         DC    X'A2A3A4A5A6A7A8A9'\n         DC    C'0123456789'\n         DC    C'+/'\n         DC    192X'00'\nTABD64   DC    78X'FF'     00 - 4D\n         DC    AL1(62) '+' 4E\n         DC    18X'FF'     4F - 60\n         DC    AL1(63) '/' 61\n         DC    28X'FF'     62 - 7D\n         DC    X'7E'   '=' 7E\n         DC    2X'FF'      7F - 80\n         DC    X'1A1B1C1D1E1F202122' 81 - 89 (26 - 34)\n         DC    7X'FF'      8A - 90\n         DC    X'232425262728292A2B' 91 - 99 (35 - 43)\n         DC    8X'FF'      9A - A1\n         DC    X'2C2D2E2F30313233'   A2 - A9 (44 - 51)\n         DC    23X'FF'     AA - C0\n         DC    X'000102030405060708' C1 - C9 (00 - 08)\n         DC    7X'FF'      CA - D0\n         DC    X'090A0B0C0D0E0F1011' D1 - D9 (09 - 17)\n         DC    8X'FF'      DA - E1\n         DC    X'1213141516171819'   E2 - E9 (18 - 25)\n         DC    6X'FF'      EA - EF\n         DC    X'3435363738393A3B3C3D'       (52 - 61)\n         DC    6X'FF'      FA - FF\n         DC    0D'0'\n         SPACE\n@DATA    DSECT\n         DS    18F\nRETCODE  DS    F\nOPEN31W  DS    F\nCLOSE31W DS    F\nOPTD     DS    C\nOPTR     DS    C\nGOTEOD   DS    C\nGOTEQL   DS    C\nGETREGS  DS    5F\nPUTREGS  DS    8F\n@CLEARL  EQU   *-@DATA\nUT1DCBEW DS    0F,(UT1DCBEL)X\nUT2DCBEW DS    0F,(UT2DCBEL)X\nDOUBLE   DS    D\nALIGN    DS    F\nIBUF     DS    CL80\nDBUF     DS    CL80\nTBUF     DS    CL80\n         DS    0D,F\nORDW     DS    F\nOBUF     DS    32768C\n         DS    0D\n@DATAL   EQU   *-@DATA\n         SPACE\n@DATA24  DSECT\nUT1DCBW  DS    0F,(UT1DCBL)X\nUT2DCBW  DS    0F,(UT2DCBL)X\nUT2EXLST DS    F\nUT2OPENX DS    0F,(UT2OPENL)X  GLUE ROUTINE COPIED HERE\n         DS    0D\n@DATA24L EQU   *-@DATA24\n         SPACE\n         PRINT NOGEN\n         IHADCBE\n         SPACE\n*         EQUATES FOR DCB FIELD OFFSETS\nEXLST    EQU   36\nRECFM    EQU   36\nOFLGS    EQU   48\nBLKSI    EQU   62\nLRECL    EQU   82\n         SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MAKEB64A": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x06\\x10O\\x01\\x06\\x10O\\x17\\x06\\x00\\x11\\x00\\x11\\x00\\x00\\xc7\\xd6\\xc4\\xc6\\xd9\\xc5\\xe8@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2006-04-14T00:00:00", "modifydate": "2006-04-14T17:06:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "GODFREY"}, "text": "//DISTRIB1 JOB (ACCT),'ASSEMBLE',MSGCLASS=R,MSGLEVEL=(1,1)\n//ASM      EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,ASA,ESD,NOTERM,NOUSING,\n//             NOXREF,NOMXREF,NORXREF,NODXREF),REGION=1M\n//SYSPRINT  DD SYSOUT=*\n//SYSLIB    DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT2    DD UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSLIN    DD DSN=&&OBJ,DISP=(NEW,PASS),\n//             UNIT=SYSDA,SPACE=(TRK,1),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=800)\n//SYSIN     DD DSN=DISTRIB.EXP.CNTL(MAKEB64),DISP=SHR\n//LKED     EXEC PGM=HEWLKED,PARM='LIST,MAP,NCAL,RENT,REUS,REFR',\n//             COND=(0,NE,ASM)\n//SYSPRINT  DD SYSOUT=*\n//SYSLIN    DD DSN=&&OBJ,DISP=(OLD,DELETE)\n//SYSLMOD   DD DSN=DISTRIB.EXP.LOAD(MAKEB64),DISP=SHR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MAKEB64O": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x07#\\x1f\\x01\\x07#\\x1f\\x08V\\x02b\\x02b\\x00\\x00\\xc7\\xd6\\xc4\\xc6\\xd9\\xc5\\xe8@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2007-08-19T00:00:00", "modifydate": "2007-08-19T08:56:00", "lines": 610, "newlines": 610, "modlines": 0, "user": "GODFREY"}, "text": "         TITLE '   M A K E B 6 4   '\n* WRITTEN FEBRUARY 7 2002\n* UPDATED APRIL 14 2006\n* ENCODE A FILE TO A BASE64 FILE,\n* OR IF PARM=D, REVERSE THE PROCESS AND DECODE IT.\n*\n* DDNAMES: SYSUT1 (INPUT) AND SYSUT2 (OUTPUT)\n*\n* IF PARM CONTAINS 'R' THEN RDW'S WILL BE ENCODED IF INPUT IS V.\n* THERE IS NO ASCII CONVERSION.\n* RECORD BOUNDARIES ARE NOT MARKED.\n*\n* DECODING WRITES A FIXED-LENGTH 80-BYTE RECORD FILE,\n* SO IF THE ORIGINAL FILE WAS THAT TYPE THEN IT SHOULD WORK.\n* A FILE PRODUCED BY THE TSO TRANSMIT COMMAND, FOR EXAMPLE.\n* IF THE ORIGINAL FILE RECORD FORMAT WAS FIXED-LENGTH, AND THE\n* DECODER OUTPUT FILE IS FIXED-LENGTH WITH THE SAME RECORD LENGTH\n* AS THE ORIGINAL, THEN THE DECODED FILE SHOULD MATCH THE ORIGINAL.\n*\n* RECFM V AND U FILES CAN BE ENCODED, BUT DECODING THEM WITH THIS\n* PROGRAM WILL NOT KEEP THE ORIGINAL FILE FORMAT.\n* EVEN IF THE FILE WAS ENCODED WITH RDW'S INCLUDED,\n* THE DECODE LOGIC DOES NOT USE THEM.\n*\n* BASE64 ENCODING, IN A NUTSHELL.\n*  FOR EVERY 3 BYTES READ, THE 24 BITS ARE SPREAD OUT INTO A\n*  32-BIT OUTPUT GROUP 00XXXXXX 00XXXXXX 00XXXXXX 00XXXXXX.\n*  THAT MAKES 4 BYTES, EACH WITH A VALUE IN THE RANGE 0 TO 63.\n*  THEN TRANSLATE VALUES 0 THRU 25 TO CAPITAL 'A' THRU 'Z',\n*  VALUES 26 THRU 51 TO LOWERCASE 'A' THRU 'Z',\n*  VALUES 52 THRU 63 TO '0' THRU '9', '+' AND '/'.\n*  IF AT FILE-END THE LAST GROUP OF 3 HAD ONLY 1 BYTE, THE 4-BYTE\n*  OUTPUT GROUP IS 00XXXXXX 00XX0000 TRANSLATED, PLUS \"==\".\n*  IF AT FILE-END THE LAST GROUP OF 3 HAD ONLY 2 BYTES, THE 4-BYTE\n*  OUTPUT GROUP IS 00XXXXXX 00XXXXXX 00XXXX00 TRANSLATED, PLUS \"=\".\n*  EACH OUTPUT LINE SHOULD BE NO LONGER THAN 76 BYTES (19 GROUPS OF 4)\n*  WHICH IS WHAT YOU WOULD GET FROM 57 INPUT BYTES (19 GROUPS OF 3).\n*\n* DISCLAIMER: NO GUARANTEE; NO WARRANTY; INSTALL/USE AT YOUR OWN RISK.\n*\n* LOG OF CHANGES:\n*  APR 14 2006 - FIX BUGS IN PUT57, WAS USING INPUT DCB RECFM LRECL ETC\n*  DEC 18 2006 - FIX OUTPUT LOOPING WHEN FILE SIZE IS MULTIPLE OF 57\n         SPACE\nMAKEB64  CSECT\n         USING *,R10\n         B     @PROLOG-*(,R15)\n         DC    AL1(7),CL7'MAKEB64'\n         DC    CL16' &SYSDATE &SYSTIME '\n@SIZE    DC    0F'0',AL1(0),AL3(@DATAL)\n@PROLOG  STM   14,12,12(13)\n         LR    R10,R15\n         LR    R2,R1               POINT R2 TO PARM ADDRESS\n         L     R0,@SIZE\n         GETMAIN R,LV=(0)\n         LR    R9,R1               POINT R9 TO GETMAINED AREA\n         XC    0(@CLEARL,R9),0(R9)\n         USING @DATA,R9\n         ST    R13,4(,R9)          OLD ADDRESS IN NEW SAVE AREA\n         ST    R9,8(,R13)          NEW ADDRESS IN OLD SAVE AREA\n         LR    R13,R9              POINT R13 TOP NEW SAVE AREA\n         SPACE\n         L     R1,0(,R2)           POINT TO PARM\n         LH    R14,0(,R1)          LENGTH OF PARM\n         LTR   R14,R14\n         BZ    PARMX\n         LA    R15,2(,R1)\nPARMLOOP CLI   0(R15),C'D'         IF PARM CONTAINS D\n         BNE   *+8                   THEN\n         MVI   OPTD,1                TURN ON DECODE OPTION\n         CLI   0(R15),C'R'         IF PARM CONTAINS R\n         BNE   *+8                   THEN\n         MVI   OPTR,1                TURN ON RDW OPTION\n         LA    R15,1(,R15)\n         BCT   R14,PARMLOOP\nPARMX    EQU   *\n         SPACE\n         LA    R15,12\n         ST    R15,RETCODE\n         SPACE\n         LA    R3,UT1DCBW\n         LA    R4,UT2DCBW\n         MVC   0(UT1DCBL,R3),UT1DCB\n         MVC   0(UT2DCBL,R4),UT2DCB\n         MVI   OPEN,X'80'\n         OPEN  ((R3),INPUT),MF=(E,OPEN)\n         TM    OFLGS(R3),X'10'\n         BNO   EXIT\n         OPEN  ((R4),OUTPUT),MF=(E,OPEN)\n         TM    OFLGS(R4),X'10'\n         BNO   EXITC1\n         XC    GETREGS(8),GETREGS\n         XC    PUTREGS(8),PUTREGS\n         SR    R6,R6\n         SR    R8,R8\n         CLI   OPTD,0\n         BNE   DEKO\n         XC    ORDW(4),ORDW CLEAR RDW\nEGET     BAL   R14,GET57           READ 57 INTO IBUF\n         LR    R7,R0               GET LENGTH TO ENCODE\n         BAL   R14,ENCODE\n         LR    R6,R0               GET LENGTH TO PUT\n         BAL   R14,PUT76\n         CLI   GOTEOD,0            IF NO EOF YET    .DEC-18-2006.\n         BE    EGET                   THEN LOOP\n         B     EXITN\nDEKO     EQU   *\nDGET     BAL   R14,GET76           READ 76 INTO IBUF\n         A     R8,=F'1'\n         LTR   R7,R0               GET LENGTH TO DECODE\n         BZ    DFLUSH              BRANCH IF EOF (OR EMPTY LINE)\n         BAL   R14,DECODE\n         LR    R6,R0               GET LENGTH TO PUT\n         BAL   R14,PUT57\n         CLI   GOTEQL,0            IF WE FOUND '='\n         BNE   DFLUSH                 THEN STOP\n         B     DGET                GO READ NEXT LINE\nDFLUSH   BAL   R14,PUT57Q          WRITE REMAINING OBUF\n         B     EXITN\n         SPACE\n*         ENCODE - ENCODE IBUF TO OBUF, R7 HAS IBUF LENGTH\n*          RETURNS OUTPUT LENGTH IN R0\n         SPACE\nENCODE   LA    R5,IBUF\n         LA    R15,OBUF\n         MVI   0(R15),C' '         FILL\n         MVC   1(79,R15),0(R15)     WITH BLANKS\n         SR    R0,R0               PREPARE FOR DIVIDE\n         LR    R1,R7               PREPARE FOR DIVIDE\n         D     R0,=F'3'            COMPUTE NUMBER OF 3-BYTE GROUPS\n         LTR   R1,R1\n         BZ    EREST\nELOOP    MVC   ALIGN(3),0(R5)      COPY A 3-BYTE GROUP\n         L     R7,ALIGN\n         SR    R6,R6\n         SLDL  R6,6\n         STC   R6,0(R15)\n         SR    R6,R6\n         SLDL  R6,6\n         STC   R6,1(R15)\n         SR    R6,R6\n         SLDL  R6,6\n         STC   R6,2(R15)\n         SR    R6,R6\n         SLDL  R6,6\n         STC   R6,3(R15)\n         TR    0(4,R15),TABE64\n         LA    R15,4(,R15)\n         LA    R5,3(,R5)\n         BCT   R1,ELOOP\nEREST    LTR   R0,R0\n         BZ    EDONE\n         BCT   R0,ERES2            FALL THRU IF R0 = 1\n         IC    R7,0(,R5)\n         SLL   R7,24               ICM R7,8,0(R5)\n         SR    R6,R6\n         SLDL  R6,6\n         STC   R6,0(R15)\n         SR    R6,R6\n         SLDL  R6,6\n         STC   R6,1(R15)\n         TR    0(2,R15),TABE64\n         MVI   2(R15),C'='\n         MVI   3(R15),C'='\n         LA    R15,4(,R15)\n*        LA    R5,1(,R5)\n         B     EDONE\n         SPACE\nERES2    MVC   ALIGN(2),0(R5)\n         LH    R7,ALIGN\n         SLL   R7,16               ICM R7,12,0(R5)\n         SR    R6,R6\n         SLDL  R6,6\n         STC   R6,0(R15)\n         SR    R6,R6\n         SLDL  R6,6\n         STC   R6,1(R15)\n         SR    R6,R6\n         SLDL  R6,6\n         STC   R6,2(R15)\n         TR    0(3,R15),TABE64\n         MVI   3(R15),C'='\n         LA    R15,4(,R15)\n*        LA    R5,2(,R5)\nEDONE    LA    R1,OBUF\n         LR    R0,R15\n         SR    R0,R1               COMPUTE LENGTH\n         BR    R14\n         SPACE\n*         DECODE - DECODE IBUF TO DBUF, R7 HAS IBUF LENGTH\n*          RETURNS OUTPUT LENGTH IN R0\n         SPACE\nDECODE   LA    R5,IBUF\n         LA    R15,DBUF\n         SR    R0,R0               PREPARE FOR DIVIDE\n         LR    R1,R7               PREPARE FOR DIVIDE\n         D     R0,=F'4'            COMPUTE NUMBER OF 4-BYTE GROUPS\n         LTR   R1,R1\n         BZ    DREST\nDLOOP    CLI   0(R5),C'='          SHOULD NOT HAVE '=' AS 1ST CHAR\n         BE    DLASX\n         CLI   1(R5),C'='          SHOULD NOT HAVE '=' AS 2ND CHAR\n         BE    DLASX\n         CLI   2(R5),C'='          CHECK FOR '=' AS 3RD CHAR\n         BE    DLAST\n         CLI   3(R5),C'='          CHECK FOR '=' AS 4TH CHAR\n         BE    DLAST\n         MVC   ALIGN(4),0(R5)\n         TR    ALIGN(4),TABD64\n         L     R7,ALIGN\n         SR    R6,R6\n         SLDL  R6,8\n         SLL   R7,2\n         SLDL  R6,2\n         STC   R6,0(R15)\n         SLDL  R6,4\n         SLL   R7,2\n         SLDL  R6,4\n         STC   R6,1(R15)\n         SLDL  R6,2\n         SLL   R7,2\n         SLDL  R6,6\n         STC   R6,2(R15)\n         LA    R15,3(,R15)\n         LA    R5,4(,R5)\n         BCT   R1,DLOOP\nDREST    LTR   R0,R0\n         BZ    DDONE\n         NOPR  0                   PLACE FOR BREAKPOINT\n         B     DLASE\nDLASX    NOPR  0                   PLACE FOR BREAKPOINT\nDLASE    MVI   RETCODE+3,8         THERE SHOULD BE NO REMAINDER\n         MVI   GOTEQL,1\n         B     DDONE\nDLAST    CLI   2(R5),C'='          IF '=' IS 3RD CHAR\n         BE    DLAS1                 DECODE 2 TO 1\n         MVC   ALIGN(3),0(R5)      COPY XXX TO DECODE 3 TO 2\n         TR    ALIGN(3),TABD64\n         L     R7,ALIGN\n         SR    R6,R6\n         SLDL  R6,8\n         SLL   R7,2\n         SLDL  R6,2\n         STC   R6,0(R15)\n         SLDL  R6,4\n         SLL   R7,2\n         SLDL  R6,4\n         STC   R6,1(R15)\n         LA    R15,2(,R15)\n*        LA    R5,4(,R5)\n         MVI   GOTEQL,1\n         B     DDONE\nDLAS1    MVC   ALIGN(2),0(R5)      COPY XX FROM XX==\n         TR    ALIGN(2),TABD64\n         L     R7,ALIGN\n         SR    R6,R6\n         SLDL  R6,8\n         SLL   R7,2\n         SLDL  R6,2\n         STC   R6,0(R15)\n         LA    R15,1(,R15)\n         MVI   GOTEQL,1\nDDONE    LA    R1,DBUF\n         LR    R0,R15\n         SR    R0,R1               COMPUTE LENGTH\n         BR    R14\n         SPACE\n*         GET57 - READ UP TO 57 BYTES INTO IBUF, SET R0 TO COUNT\n         SPACE\nGET57    LM    R5,R6,GETREGS\n         LA    R15,IBUF\n         LA    R0,57\nGET5A    CR    R5,R6               IF END OF RECORD\n         BNL   GET5R                 THEN READ NEXT RECORD\n         MVC   0(1,R15),0(R5)      COPY ONE BYTE TO OBUF\n         LA    R15,1(,R15)         NEXT OBUF BYTE\n         LA    R5,1(,R5)           NEXT IBUF BYTE\n         BCT   R0,GET5A            DECREMENT R0 AND LOOP\n         LA    R0,57               SET RETURNED LENGTH\n         STM   R5,R6,GETREGS\n         BR    R14\nGET5R    STM   R14,R0,GETREGS+8\n         CLI   GOTEOD,0            IF WE ALREADY HIT EODAD\n         BNE   UT1EOD                GO THERE AGAIN\n         GET   (R3)\n         LR    R5,R1\n         TM    RECFM(R3),X'C0'     RECFM U\n         BO    GET5U\n         TM    RECFM(R3),X'80'     RECFM F\n         BO    GET5F\nGET5V    LA    R0,4\n         LH    R6,0(,R5)           LENGTH+4 FROM RDW\n         CLI   OPTR,0              IF R IN PARM\n         BNE   GET5W                  INCLUDE RDW\n         AR    R5,R0               POINT PAST RDW\n         SR    R6,R0               REDUCE LENGTH\nGET5W    AR    R6,R5               POINT TO END OF RECORD\n         B     GET5X\nGET5U    LH    R6,LRECL(,R3)\n         AR    R6,R5               POINT TO END OF RECORD\n         B     GET5X\nGET5F    LH    R6,LRECL(,R3)       GET LENGTH FROM LRECL\n         TM    RECFM(R3),X'10'     IF NOT BLOCKED\n         BO    *+8                   THEN\n         LH    R6,BLKSI(,R3)         USE BLKSIZE AS LENGTH\n         AR    R6,R5               POINT TO END OF RECORD\nGET5X    LM    R14,R0,GETREGS+8\n         B     GET5A\nGET5E    LA    R0,57\n         S     R0,GETREGS+16       COMPUTE HOW MANY BYTES IN IBUF\n         XC    GETREGS(8),GETREGS                   .DEC-18-2006.\n         L     R14,GETREGS+8\n         BR    R14\n         SPACE\n*         GET76 - READ NEXT RECORD AND COPY UP TO 76 NONBLANKS TO IBUF\n*                 SET R0 TO COUNT\n         SPACE\nGET76    ST    14,GETREGS\n         GET   (R3)\n         LR    R5,R1\n         TM    RECFM(R3),X'C0'     RECFM U\n         BO    GET7U\n         TM    RECFM(R3),X'80'     RECFM F\n         BO    GET7F\nGET7V    LA    R0,4\n         LH    R6,0(,R5)           LENGTH+4 FROM RDW\n         AR    R5,R0               POINT PAST RDW\n         SR    R6,R0               REDUCE LENGTH\n         AR    R6,R5               POINT TO END OF RECORD\n         B     GET7M\nGET7U    LH    R6,LRECL(,R3)\n         AR    R6,R5               POINT TO END OF RECORD\n         B     GET7M\nGET7F    LH    R6,LRECL(,R3)       GET LENGTH FROM LRECL\n         TM    RECFM(R3),X'10'     IF NOT BLOCKED\n         BO    *+8                   THEN\n         LH    R6,BLKSI(,R3)         USE BLKSIZE AS LENGTH\n         AR    R6,R5               POINT TO END OF RECORD\nGET7M    SR    R1,R1               CLEAR COUNTER\n         LA    R15,IBUF\n         LA    R0,76\nGET7N    CR    R1,R0               IF WE HAVE DONE 76\n         BNL   GET7W                  STOP NOW\n         CR    R5,R6               IF END OF RECORD\n         BNL   GET7W                  STOP NOW\n         CLI   0(R5),C' '          IF BLANK\n         BE    GET7S                  IGNORE\n         MVC   0(1,R15),0(R5)      COPY ONE BYTE TO IBUF\n         LA    R15,1(,R15)         NEXT IBUF BYTE\n         LA    R1,1(,R1)           COUNT BYTES\nGET7S    LA    R5,1(,R5)           NEXT INPUT BYTE\n         B     GET7N\nGET7W    LR    R0,R1\nGET7X    L     R14,GETREGS\n         BR    R14\nGET7E    SR    R0,R0\n         B     GET7X\n         SPACE\nUT1EOD   MVI   GOTEOD,1\n         CLI   OPTD,0              IF ENCODING\n         BE    GET5E                  RETURN TO ENCODE LOGIC\n         B     GET7E               ELSE RETURN TO DECODE LOGIC\n         SPACE\n*         PUT76 - WRITE OBUF (LENGTH IN R6)\n         SPACE\nPUT76    LTR   R6,R6\n         BZR   R14\n         ST    R14,PUTREGS\n         TM    RECFM(R4),X'C0'\n         BO    PUT7U\n         TM    RECFM(R4),X'80'\n         BO    PUT7F\nPUT7V    LA    R6,4(,R6)\n         CH    R6,LRECL(,R4)       IF RECORD TOO LONG\n         BNH   PUT7V2                 THEN\n         LH    R6,LRECL(,R4)          TRUNCATE IT\n         MVI   RETCODE+3,4            SET PROGRAM RETURN CODE TO 4\nPUT7V2   STH   R6,ORDW             SET LENGTH IN RDW\n         PUT   (R4),ORDW\n         LA    R0,4\n         SR    R6,R0\n         L     R14,PUTREGS\n         BR    R14\nPUT7U    STH   R6,LRECL(,R4)\nPUT7F    PUT   (R4),OBUF\n         L     R14,PUTREGS\n         BR    R14\n         SPACE\n*         PUT57 - WRITE NEXT COUNT=R6 BYTES FROM DBUF TO OBUF\n*                 WRITE A RECORD WHENEVER OBUF FILLS UP.\n*                 SHOULD CALL PUT57Q BEFORE CLOSING\n         SPACE\nPUT57    LTR   R6,R6\n         BZR   R14\n         ST    R6,PUTREGS+20\n         LR    R0,R6\n         LM    R5,R6,PUTREGS\n         LA    R15,DBUF\n         LTR   R5,R5               IF FIRST TIME\n         BNZ   PUT5A                  FALL THRU\nPUT5I    LA    R5,OBUF\n         XC    OBUF(256),OBUF\n         TM    RECFM(R4),X'C0'\n         BO    PUT5IU\n         TM    RECFM(R4),X'80'\n         BO    PUT5IF\n         LH    R6,LRECL(,R4)       GET LENGTH FROM LRECL\n         TM    RECFM(R4),X'10'     IF NOT BLOCKED\n         BO    *+8                   THEN\n         LH    R6,BLKSI(,R4)         USE BLKSIZE AS LENGTH\n         LA    R0,4\n         SR    R6,R0\n         B     PUT5IL\nPUT5IU   LH    R6,BLKSI(,R4)       GET LENGTH FROM BLKSI\n         B     PUT5IL\nPUT5IF   LH    R6,LRECL(,R4)       GET LENGTH FROM LRECL\n         TM    RECFM(R4),X'10'     IF NOT BLOCKED\n         BO    *+8                   THEN\n         LH    R6,BLKSI(,R4)         USE BLKSIZE AS LENGTH\nPUT5IL   AR    R6,R5\nPUT5A    CR    R5,R6               IF END OF RECORD\n         BNL   PUT5W                 THEN WRITE THE RECORD\n         MVC   0(1,R5),0(R15)      COPY ONE BYTE TO OBUF\n         LA    R5,1(,R5)           NEXT OBUF BYTE\n         LA    R15,1(,R15)         NEXT DBUF BYTE\n         BCT   R0,PUT5A            DECREMENT R0 AND LOOP\n         L     R0,PUTREGS+20       SET RETURNED LENGTH\n         STM   R5,R6,PUTREGS       SAVE FOR NEXT TIME\n         BR    R14                 RETURN\nPUT57Q   L     R5,PUTREGS\n         LTR   R5,R5               IF PUT57 WAS NEVER CALLED\n         BZR   R14                    RETURN\n         LA    R0,OBUF             IF OBUF CURSOR AT COLUMN 1\n         CR    R5,R0                  THEN\n         BER   R14                    RETURN\n         ST    R14,PUTREGS+24\n         BAL   R14,PUT5P\n         STM   R5,R6,PUTREGS\n         L     R14,PUTREGS+24\n         BR    R14\nPUT5W    ST    R14,PUTREGS+28\n         BAL   R14,PUT5P\n         L     R14,PUTREGS+28\n         B     PUT5A\nPUT5P    STM   R14,R0,PUTREGS+8\n         TM    RECFM(R4),X'C0'\n         BO    PUT5U\n         TM    RECFM(R4),X'80'\n         BO    PUT5F\nPUT5V    LR    R1,R5\n         LA    R0,ORDW\n         SR    R1,R0               COMPUTE LENGTH\n         CH    R1,LRECL(,R4)       IF RECORD TOO LONG\n         BNH   PUT5V2                 THEN\n         LH    R1,LRECL(,R4)          TRUNCATE IT\n         MVI   RETCODE+3,4            SET PROGRAM RETURN CODE TO 4\nPUT5V2   STH   R1,ORDW             SET LENGTH IN RDW\n         PUT   (R4),ORDW\n         LA    R5,OBUF\n         LH    R6,LRECL(,R4)       GET LENGTH FROM LRECL\n         TM    RECFM(R4),X'10'     IF NOT BLOCKED\n         BO    *+8                   THEN\n         LH    R6,BLKSI(,R4)         USE BLKSIZE AS LENGTH\n         LA    R0,4\n         SR    R6,R0\n         B     PUT5L\nPUT5U    LR    R1,R5\n         LA    R0,OBUF\n         SR    R1,R0               COMPUTE LENGTH\n         STH   R1,LRECL(,R4)\n         PUT   (R4),OBUF\n         LA    R5,OBUF\n         LH    R6,BLKSI(,R4)\n         B     PUT5L\nPUT5F    PUT   (R4),OBUF\n         LA    R5,OBUF\n         LH    R6,LRECL(,R4)       GET LENGTH FROM LRECL\n         TM    RECFM(R4),X'10'     IF NOT BLOCKED\n         BO    *+8                   THEN\n         LH    R6,BLKSI(,R4)         USE BLKSIZE AS LENGTH\nPUT5L    AR    R6,R5               POINT TO END OF RECORD\n         XC    OBUF(256),OBUF\n         LM    R14,R0,PUTREGS+8\n         BR    R14\n         SPACE\nEXITN    CLI   RETCODE+3,12        IF AN ERROR OCCURRED\n         BNE   EXITC2                DON'T SET RC 0\nEXIT0    MVI   RETCODE+3,0\nEXITC2   MVI   CLOSE,X'80'\n         CLOSE ((R4)),MF=(E,CLOSE)\n         LR    R6,R4\n         BAL   R2,FREEPOOL\nEXITC1   MVI   CLOSE,X'80'\n         CLOSE ((R3)),MF=(E,CLOSE)\n         LR    R6,R3\n         BAL   R2,FREEPOOL\n         B     EXIT\nFREEPOOL FREEPOOL (R6)\n         BR    R2\nEXIT     L     R2,RETCODE\n         LR    R1,R13\n         L     R0,@SIZE\n         L     R13,4(,R13)\n         FREEMAIN R,A=(1),LV=(0)\n         DROP  R9\n         LR    R15,R2\n         LM    0,12,20(R13)\n         L     R14,12(,R13)\n         BR    R14\n         SPACE\nUT2EXIT  CLI   RECFM(R1),0         IF NO RECFM\n         BNE   UT2EXI2                THEN\n         MVI   RECFM(R1),X'90'        USE FB\nUT2EXI2  TM    RECFM(R1),X'10'     IF BLOCKED\n         BZ    UT2EXI3                AND\n         CLC   LRECL(2,R1),=H'0'      NO LRECL\n         BNE   UT2EXI3                THEN\n         MVC   LRECL(2,R1),=H'80'     USE 80\nUT2EXI3  CLC   BLKSI(2,R1),=H'0'   IF NO BLKSIZE\n         BNE   UT2EXI4                THEN\n         MVC   BLKSI(2,R1),=H'10720'  USE 5 PER 3390 TRACK\nUT2EXI4  BR    R14\n         SPACE\n         LTORG\n         DC    0D'0'\n         PRINT NOGEN\nUT1DCB   DCB   DDNAME=SYSUT1,DSORG=PS,MACRF=(GL),EODAD=UT1EOD\nUT1DCBL  EQU   *-UT1DCB\nUT2DCB   DCB   DDNAME=SYSUT2,DSORG=PS,MACRF=(PM),EXLST=UT2EXL\nUT2DCBL  EQU   *-UT2DCB\nUT2EXL   DC    0F'0',X'85',AL3(UT2EXIT)\n         DC    0D'0'\nTABE64   DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n         DC    X'818283848586878889'\n         DC    X'919293949596979899'\n         DC    X'A2A3A4A5A6A7A8A9'\n         DC    C'0123456789'\n         DC    C'+/'\n         DC    192X'00'\nTABD64   DC    78X'FF'     00 - 4D\n         DC    AL1(62) '+' 4E\n         DC    18X'FF'     4F - 60\n         DC    AL1(63) '/' 61\n         DC    28X'FF'     62 - 7D\n         DC    X'7E'   '=' 7E\n         DC    2X'FF'      7F - 80\n         DC    X'1A1B1C1D1E1F202122' 81 - 89 (26 - 34)\n         DC    7X'FF'      8A - 90\n         DC    X'232425262728292A2B' 91 - 99 (35 - 43)\n         DC    8X'FF'      9A - A1\n         DC    X'2C2D2E2F30313233'   A2 - A9 (44 - 51)\n         DC    23X'FF'     AA - C0\n         DC    X'000102030405060708' C1 - C9 (00 - 08)\n         DC    7X'FF'      CA - D0\n         DC    X'090A0B0C0D0E0F1011' D1 - D9 (09 - 17)\n         DC    8X'FF'      DA - E1\n         DC    X'1213141516171819'   E2 - E9 (18 - 25)\n         DC    6X'FF'      EA - EF\n         DC    X'3435363738393A3B3C3D'       (52 - 61)\n         DC    6X'FF'      FA - FF\n         DC    0D'0'\n         SPACE\n@DATA    DSECT\n         DS    18F\nRETCODE  DS    F\nOPEN     DS    F\nCLOSE    DS    F\nOPTD     DS    C\nOPTR     DS    C\nGOTEOD   DS    C\nGOTEQL   DS    C\nGETREGS  DS    5F\nPUTREGS  DS    8F\n@CLEARL  EQU   *-@DATA\nDOUBLE   DS    D\nUT1DCBW  DS    0F,(UT1DCBL)X\nUT2DCBW  DS    0F,(UT2DCBL)X\nALIGN    DS    F\nIBUF     DS    CL80\nDBUF     DS    CL80\nTBUF     DS    CL80\n         DS    0D,F\nORDW     DS    F\nOBUF     DS    32768C\n         DS    0D\n@DATAL   EQU   *-@DATA\n         SPACE\n*         EQUATES FOR DCB FIELD OFFSETS\nRECFM    EQU   36\nOFLGS    EQU   48\nBLKSI    EQU   62\nLRECL    EQU   82\n         SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT741/FILE741.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT741", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}