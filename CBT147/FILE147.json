{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011337000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 3703518, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 22, "INMDSNAM": "CBT.V500.FILE147.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 3703518, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 3703518, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE147.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00;\\r'", "DS1TRBAL": "b'\\x04\\x1e'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x01\\x0b\\x00\\x0c\\x01\\x0f\\x00\\x0b\\x00<'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00T\\x01 %\\x7f\\x01 %\\x7f\\x16)\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf5\\xf0\\xf0@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "2020-09-13T00:00:00", "modifydate": "2020-09-13T16:29:54", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-500"}, "text": "REGULAR CBT TAPE - VERSION 500    FILE:  147\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT500.FILE147\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 98 MEMBERS COUNTED; CUMULATIVE SIZE IS 34,355 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   09/13/20    16:29:54    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$README": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06\\r\\x00\\x00\\x01 !_\\x01 !_\\x18\\x06\\x00\\x1a\\x00\\x1a\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@'", "ispf": {"version": "06.13", "flags": 0, "createdate": "2020-08-02T00:00:00", "modifydate": "2020-08-02T18:06:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "ARCHIVR"}, "text": "Sorry to note that Rick Fochtman has passed on.  Please ask Sam Golob\nor Rob Prins to help if you have any questions or problems.\n\n   email:  sbgolob@cbttape.org   or  sbgolob@attglobal.net\n                    -- Or --\n   email:  rn.prins@quicknet.nl  (Rob Prins)\n\n To install the ARCHIVER program, in all its glory (?), edit and\n execute the job in member $INSTALL, in the source dataset.  Then\n print the $ARCHDOC member of the source dataset to learn how to use\n it, or download member ARCHIVE$ for a PDF document or download\n member ARCHIVE@ for the Microsoft Word version of the manual.\n Some functions are demonstrated by samples in the SAMPLIB\n dataset as well.\n\n *-------------------------- IMPORTANT -------------------------------*\n Read member @FILE147 if you want only to install the load modules\n instead of assemble and link the sources.\n *-------------------------- IMPORTANT -------------------------------*\n\n And remember: this is a freebie to anyone who wants it.  I would be\n interested in hearing (or reading) your comments and experiences and\n will be somewhat receptive to suggestions for improvement.  One user\n who has used the 'BETA' code extensively wants a COMPARE function.\n Interesting.  (in the works)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$ARCHDOC": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06\\x0c\\x00\\x00\\x01  \\x9f\\x01  \\x9f \\x19\\x02\\xb2\\x02\\xb2\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@'", "ispf": {"version": "06.12", "flags": 0, "createdate": "2020-07-27T00:00:00", "modifydate": "2020-07-27T20:19:00", "lines": 690, "newlines": 690, "modlines": 0, "user": "ARCHIVR"}, "text": "1\n-\n-\n-\n-\n-\n-\n-                                  ARCHIVER\n+                                  ________\n-\n-                          The Systems Programmer's\n0                              Toolkit Manager\n-\n-\n-\n-\n-\n0 (c) 1999  Richard A. Fochtman Jr., Woodridge, Illinois\n0This document and the program it describes may be distributed freely, to any\n interested party.  No fees or charges are permitted, other than the recovery\n of reasonable distribution costs.  Users are encouraged to submit suggestions\n for improvement to the author, via NASPA.\n1General\n+_______\n0In my many and varied ramblings, I've encountered, and developed, many\n programs, subroutines, macros and clists that I've found useful in my work.\n Because I was changing jobs at a rapid rate at that time, I wanted a\n mechanism that provided a certain amount of portability for this 'tool kit'.\n Net result: the ARCHIVER program.  I wanted to be able to package everything\n in a simple-to-manage form that would be essentially device-independent.  I\n selected VSAM as my 'bridge' because that seems to be the direction of the\n IBM data management trend.  My basic design criteria were these:\n01.  Ability to access partitioned and sequential datasets of nearly any\n     format.  I wasn't worried about spanned records, since they are unusable\n     for most of the functions I needed.  Just about anything else is\n     acceptable to the ARCHIVER.\n02.  Where possible, utilize IBM utilities and mechanisms for the more mundane\n     functions, such as backup and reorganization.\n03.  Provide a mechanism for multiple occurences of a PDS member name, since\n     source, clist and load module might be all the same name.\n04.  Provide a mechanism for multiple versions, since I might encounter\n     compatibility problems in some routines.\n05.  Allow for historical and/or comment data, to help me remember the\n     function of each archived item.\n06.  As far as possible, remain independant of the MVS software level\n     differences.  For that reason, I chose VSAM but didn't use some of the\n     more advanced functions of VSAM.\n0All these criteria were met in the initial version, with a few minor\n limitations.  For example, overlay load modules were improperly processed\n since the note list wasn't updated during reload.  During the ensuing\n evolution, the ARCHIVER has changed radically, accepting new functions and\n polishing some existing functions.  Soon, I hope to be able to ARCHIVE any\n dataset that can be processed using either QSAM or BPAM.\n0This document you are reading corresponds to Version 5.0 of the ARCHIVER.\n Although functions of older versions are still present, they may function\n differently in Version 5.0.  Let the user beware.\n1Changes from Previous Versions\n0Evolution of the ARCHIVER, with prompting from Sam Golob, has resulted in a\n new feature, the ALIAS functions.  The VSAM ARCHIVE may now contain any\n number of aliases for a given item, allowing the same item to be referenced\n by several sets of qualifiers.  In previous versions, if a user wished to\n include a macro, for example, under several sets of qualifications, he was\n forced to include several copies of the macro.  No more.  The ADDALIAS\n command allows the user to assign aliases in virtually any pattern he\n desires.\n0The DELETE function has been EXTENSIVELY reworked, both to handle the new\n aliases and for general cleanup.\n0The EXPORT and IMPORT functions of ARCHIVER now use a DD name or DSNAME\n operand that is unique to EXPORT/IMPORT.  While this may seem trivial to some\n users, it was somewhat confusing to use the LOADT and LISTT functions.\n0Two new functions allow a special list of the number of items in each\n category, where a category is a set of GROUP/SUBGROUP, TYPE and VERSION\n qualifiers that match.\n0The latest and largest enhancement is a COMPARE function.  This command\n allows a user to compare items, of sets of items, from the single archive\n cluster, or optionally, compare like-named items from two different archive\n clusters, all under user control.  Eventually, ARCHIVER will automatically\n delete duplicates and assign aliases, further reducing the space\n requirements for the archive cluster.\n\n1Contents\n0 The ARCHIVE dataset ------------------------------------------------------1\n0 ALIAS Processing ---------------------------------------------------------3\n0 ARCHIVER JCL -------------------------------------------------------------4\n0 General Control Statement Format -----------------------------------------5\n0 SET ------ Define datasets and DD names ----------------------------------6\n0 ADDALIAS - Assign aliases to items or groups of items --------------------7\n0 ADDNOTE  - Add comment data to items or groups of items ------------------8\n0 ALTALIAS - Change the associations of aliases ----------------------------9\n0 ALTER ---- Change the qualifier data for items or groups of items -------10\n0 CLEAN ---- Remove orphan ARCHIVE aliases --------------------------------11\n0 COMPARE -- Compare items in archive(s) ----------------------------------12\n0 CONVERT -- Convert Version 3 archives to Version 4 ----------------------13\n0 COPY ----- Copy items or groups of items from Archive to Archive --------14\n0 DELALIAS - Delete aliases or groups of aliases --------------------------15\n0 DELETE --- Delete items or groups of items ------------------------------16\n0 EXPORT --- Offload the archive to nonvsam media -------------------------17\n0 IMPORT --- Reload the archive from nonvsam media ------------------------18\n0 LFILE ---- List logical files in the Archive ----------------------------19\n0 LFILET --- List logical files from exported archive data ----------------20\n0 LIST ----- List the archive's contents ----------------------------------21\n0 LISTT ---- List the contents of an exported archive ---------------------22\n0 LOAD ----- Transfer from the Archive to nonvsam datasets ----------------23\n0 LOADT ---- Transfer from exported archive data to nonvsam datasets ------24\n0 UNLOAD --- Transfer from nonvsam datasets into the Archive --------------25\n1                                    -1-\n The ARCHIVE dataset\n+___________________\n0The ARCHIVE dataset is a key-sequenced VSAM cluster, containing three\n distinct key ranges.  The actual key of the record contains a record type,\n the qualifier information and a sequence number, in that order.  The record\n type is the mechanism that sets the key range.  The record types are\n header, note-data and item data.  While the note-data record is optional,\n all other types are required.  Here's a short description of each type.\n0 *  HEADER RECORDS are the root of all archived items.  The header record has\n     the required key, plus the RECFM, LRECL, BLKSIZE, DSORG and DEVTYPE of\n     the item's source dataset, as well as the time and date of insertion in\n     the archive and the record count of the original member.  Also, in\n     version 4, all directory data, including PDS alias information, is stored\n     in the header record.  The size and number of directory records is such\n     that, if stored separately, much space and time are wasted, to no good\n     purpose.  (Previous versions of the ARCHIVER used a separate record type\n     for PDS directory data.)\n0 *  NOTE-DATA records, which may not be present, contain comment data\n     supplied by the user for the item described by the record key.\n     Multiple records may be present, with ascending sequence numbers to\n     maintain the uniqueness of the key.  As in the item data records, all\n     the data is in a compressed format, for space-economy reasons.\n0 *  ITEM DATA records contain the actual logical records of the item, in\n     compressed format.  Previous versions of the ARCHIVER used a fairly\n     primitive compression mechanism that only compressed out repetitive\n     strings.  This new improved version uses a variation of the Huffman\n     Tree to do both compression of repetitive strings AND compaction of\n     data at the bit level.\n0VSAM was selected as the access method for the Archive dataset for two very\n important reasons.  First, because the user of VSAM has no great need to know\n the characteristics of the actual device.  Second, standard IBM-type utility\n programs could be used for backup, space recovery, creating transportable\n copies, etc.  While this may seem trivial, the problems involved in\n developing a completely new access mechanism just aren't justified by the\n potential savings.\n0For reference, her's a sample of the IDCAMS control statements required to\n allocate the archive cluster.  Note that there is no provision for 'seed'ing\n the cluster, since the ARCHIVER will automatically deal with this chore.\n0        DEFINE CLUSTER(NAME( your archive name )   -\n                RECORDSIZE(200 32000) -\n                FREESPACE(20 20)      -\n                BUFFERSPACE(262144)   -         (note)\n                KEYS(49 0))\n          DATA(NAME( your archive name .DATA) -\n              CYLINDERS( primary secondary )) -\n          INDEX(NAME( your archive name .INDEX) -\n              CYLINDERS( primary secondary ))\n1                                    -2-\n Note: while this value may seem excessive, it greatly enhances the\n overall performance of the ARCHIVER.\n0Maximum record size should be at least 90 bytes larger than the longest\n load-module record to be unloaded. (control information)\n0REPLICATE/IMBED are performance options that may or may not enhance the\n performance of ARCHIVER, depending on usage patterns.\n0Because of the way VSAM compresses the record keys, a single cylinder of\n index is enough for about 10,000 archived items.\n0RECORD KEYS\n+___________\n0Because of a design requirement to be able to store multiple PDS members\n without the necessity of renaming, and confusing, each item has four levels\n of qualification possible in the archive cluster.  These qualifiers are named\n MEMBER, GROUP, SUBGROUP and TYPE within the ARCHIVER program.  Externally,\n they can be thought of in those terms or in any other 'style' that may be\n convenient.  The original intent was to be able to group together items that\n were related for ease in remembering everything.  As an example, if you\n wished to unload the entire CBT mods tape to the archive, then the GROUP\n could be CBTTAP, the subgroup could be the original CBT tape file number,\n i.e. FILE147 and the type could be indicative of the programming language,\n i.e. BAL.  If you choose to specify a version number to the ARCHIVER, that\n could be the CBT tape version number, e.g. 311.\n0The version number is processed in a different fashion from the other key\n values, since it is maintained in DESCENDING sequence.  This is done by using\n the NEGATIVE of the version number.  Please note however that a negative\n version number is not properly processed by the ARCHIVER's input scan, so\n results may be unpredictable if this is attempted.  Version numbers are\n considered qualifier data, thus may be part of the user's item selection\n criteria for processing.  In all cases, the version number is STRICTLY\n OPTIONAL and in some cases its use should be avoided.\n1                                    -3-\n ALIAS PROCESSING\n+________________\n0Version 5.0 of the ARCHIVER recognizes, and processes, two distinct 'flavors'\n of aliases: BPAM aliases, such as we're all accustomed to using, and\n ARCHIVER aliases, a completely new feature in this version.\n0BPAM aliases (also known as PDS aliases), are saved in the header record for\n each item that is unloaded.  Naturally, sequential datasets have no aliases.\n During reload processing, these aliases, if present, may be restored or\n ignored at the user's discretion.\n0As yet, there is no mechanism within the ARCHIVER to list the PDS directory\n data for each archived item; that's coming but it's going to be some time\n yet.  There are too many other things that the ARCHIVER needs.\n0ARCHIVER aliases, on the other hand, are completely under user control.  The\n user may automatically assign ARCHIVER aliases during unload, add, delete or\n alter aliases and list, or not list, these aliases.  If an item is to be\n deleted, the actual data can be reassigned to a different set of qualifier\n data and retained, or discarded completely with all its aliases, entirely at\n the user's discretion.  In situations where multiple archive datasets are\n being merged, this can result in a massive space saving.\n1                                    -4-\n ARCHIVER JCL\n+____________\n0Job control language for the ARCHIVER is quite simple and straightforward.\n0Required DD statements are SYSPRINT and SYSIN.\n You can use an alternate DDNAME of SYSPRINT with PARM='SYSPRINT=ddname'\n in the EXEC statement of ARCHIVER and\n You can use an alternate DDNAME of SYSIN, with PARM='SYSIN=ddname'\n in the EXEC statement of ARCHIVER. If you want to override both ddnames,\n code PARM='SYSIN=ddname1,SYSPRINT=ddname2' Period.  Additional DD\n statements MAY be required for some functions but the Dynamic Allocation\n facilities within the ARCHIVER program serve to greatly reduce JCL\n requirements over previous versions.  Any CATALOGED dataset may be allocated\n dynamically, without exception.\n0The SYSPRINT dataset is, obviously, the report and listing dataset used by\n all ARCHIVER functions.  Record format is FBA and logical record length is\n set to 133.  If blocksize is not supplied, the default is 133.\n0Again obviously, the SYSIN dataset is the control statement input dataset.\n Record format is set to FB and logical record length is 80.  Again, if a\n blocksize is not supplied, from the DD statement or a dataset label, the\n default value is 80.\n1                                    -5-\n General Control Statement Format\n+________________________________\n0The ARCHIVER control statements all follow a fairly simple and familiar\n format, using all keyword= style operands.  While the major operands are all\n of the keyword=value format, a few of the operands are of a multiple and\n positional format.  I know that's probably hard to understand but when you\n examine the individual control statement formats, you'll see almost\n instantly what it means.  Control statements are continued by ending a\n statement with a comma followed by a blank.  The continuation may begin in\n any position, for any length, provided it does not extend past column 72.\n The number of continuations permitted is unlimited, with the provision that\n a control statement may not contain more than 2048 characters total.\n0The general form of the ARCHIVER control statement is this:\n0  verb  keyword=value,...,keyword=value\n0Item selection is slightly more complicated because of the various types\n of qualifier data that may be used to affect selection.  The ITEM= value\n is actually a list of either four or five positional values, corresponding\n to name, group, subgroup, type and version number, in that order.  The\n first four qualifiers may be any character string, except a blank, and\n may be specific values or generic values.  The version number must always\n be a numeric value in the range of 1-16777216.\n0Generic values are denoted in any of several ways.\n0If a qualifier is completely replaced by an asterisk, the ARCHIVER assumes\n that ANY value, of any length, is a valid match for this qualifier.  Thus\n the parameter 'ITEM=(*,CBT321,FILE241,OBJ)' denotes any item whose group,\n subgroup and type are CBT321,FILE241 and OBJ, respectively.\n0If a qualifier is ended with an asterisk, all characters up to the asterisk\n must match for comparisons within the ARCHIVER.  Any characters in the\n position of the asterisk, or after that position, are ignored.  In the\n example above, if the asterisk is replaced with 'RMF*', only members\n whose names start with RMF are considered to match.\n0If a qualifier contains one or more percent signs ('%'), these are considered\n to match any character in that position.  Again using the example above, if\n we replace the asterist first qualifier value with 'RMF%%%01', only those\n values that have 'RMF' as the first three positions, and have '01' in\n positions 7-8 and are exactly eight characters long are considered to match.\n The characters in positions 4-6 are ignored.\n0As you can see, the ability to use generics is a very powerful feature.\n0Comment statements may be imbedded anywhere in the input stream. A comment is\n denoted by an asterisk ('*') in column one and will be printed as-is and\n ignored.\n1                                    -6-\n The SET Control Statement\n+_________________________\n0The SET control statement allows the user to set default DDNAMES or DSNAMES\n for subsequent processing.\n0Format:\n0 SET (EXPTPDD=ddname | EXPTPDSN=non-vsam dsname)\n  SET (VSAM1DD=ddname | VSAM1DSN=cluster name)\n  SET (VSAM2DD=ddname | VSAM2DSN=cluster name)\n  SET (DDN=ddname | DSN=non-VSAM dsname)\n0The operands for the SET command are DD names or DSNAMEs that will remain in\n effect for subsequent processing, unless one or more operands from the SET\n command appear on subsequent ARCHIVER control statements.  Since some of\n these values are required for further processing, each control statement\n description will contain a note describing the SET operands that are\n required.\n0Because the operands using dsnames force DYNAMIC ALLOCATION (SVC-99) of the\n datasets named, all datasets named in the SET control statement MUST be\n CATALOGED DATASETS.\n0Performance note: because I use the ARCHIVER extensively, I've learned that\n using a DD statement to describe the VSAM cluster and inserting the BUFND and\n BUFNI subparameters of the AMP parameter can vastly improve performance.  I\n generally use about 16 buffers for each component.  Also, if the VSAM cluster\n is defined with GENEROUS bufferspace, it help performance. (I have defined my\n ARCHIVE clusters with 256k of bufferspace.)\n1                                    -7-\n The ADDALIAS Command\n+____________________\n0The ADDALIAS command allows the user to assign ARCHIVER-type aliases to items\n or groups of items in the Archive dataset.\n0General Format:\n0 ADDALIAS  ITEM=(...),ALIAS=(...)\n0The ITEM= values are as described previously in this manual, including the\n usage of generic qualifier data.\n0The ALIAS= operand follows the same format as the ITEM= operand but is\n processed differently.  If a qualifier level in the ALIAS= operand is\n replaced completely by an asterisk, the corresponding qualifier from the\n ITEM= operand is copied.  For example, suppose I wish to give the alias\n CBT324,FILE247,DATA to all items currently qualified as CBT321,FILE247,DATA,\n my control statement would look like this:\n0 ADDALIAS ITEM=(*,CBT321,FILE247,DATA),ALIAS=(*,CBT324,*,*)\n0The SET operand that must be in effect is:  VSAM1DD or VSAM1DSN\n1                                    -8-\n The ADDNOTE Command\n+___________________\n0The ADDNOTE statement causes the ARCHIVER to insert NOTE-DATA into the\n members, or groups of members, named in the control statement and present in\n the VSAM1 archive dataset.  Since this is a relatively complex function to\n understand, a sample job stream is provided to illustrate this function.\n0Format:\n0 ADDNOTE ITEM=(...),KEY=value\n0The ADDNOTE control statement takes some practice to understand fully.  It\n uses the non-VSAM dataset data, which must be card-image data, as the\n comments or NOTES to be added to the selected item.  The KEY= value refers to\n a character string of 1-8 characters in position 73-80 of the NOTES records.\n What happens is this: the non-VSAM dataset is read sequentially and each card\n image that has the key value in position 73-80 is added to the item as note\n data, minus the last 8 columns.  For the next item, the non-VSAM dataset is\n closed and reopened and re-read, etc.  The sample JCL streams distributed\n with the ARCHIVER illustrate this function and are perhaps easier to follow\n than my futile attempts here.\n0One thing to be aware of: all NOTE data is CUMULATIVE.  If you wish to\n replace the note data associated with a particular item, you must first\n delete any pre-existing data, using the delete function.\n0The ADDNOTE function REQUIRES that the non-VSAM dataset support the REREAD\n option of CLOSE.  While JES2 SYSIN seems to allow this, I just don't know\n whether JES3 will permit this function.\n0Required SET operand that must be in effect:\n0 VSAM1DD= or VSAM1DSN=  (denoting the Archive dataset)\n  DDN=     or DSN=       (denoting the file of input NOTE data)\n1                                    -9-\n The ALTALIAS Command\n+____________________\n0The ALTALIAS command allow the user to reassign an Archive alias to a\n different 'real' member.  For example, if the alias XYZ,CBT321,FILE1,DATA\n is an alias for XYZ,CBT249,FILE1,DATA, perhaps you would like it to be\n an alias to XYZ,CBT998,FILE1,DATA instead.  The ALTALIAS function will make\n this change.\n0General format:\n0ALTALIAS ITEM=(...),ALIAS=(...)\n0The ITEM= operand is processed as perviously described, including the\n processing of generics.\n0The ALIAS= operand is processed in its own special way for this function.\n Each qualifier that is replaced by an asterisk remains unchanged.  Any\n qualifier that is NOT replaced by an asterisk is used as a replacement.\n Thus, to make the alias change described above, the control statement would\n be:\n0ALTALIAS ITEM=(XYZ,CBT249,FILE1,DATA),ALIAS=(*,CBT998,*,*)\n0The required SET operands that must be in effect for ALTALIAS are:\n0  VSAM1DD= or VSAM1DSN=     (the Archive dataset)\n1                                   -10-\n The ALTER Command\n+_________________\n0The ALTER control statement allows the user to change the qualifier data on\n any item, or group of items, in the ARCHIVE cluster.  The function is carried\n out by rewriting the item(s) with new keys according to the qualifier data\n provided in the control statement.\n0General Format:\n0ALTER ITEM=(...),NEW=(...)\n0The NEW= operand is of the same format as the ITEM= operand and will be\n examined using the same mechanism.  However, in the NEW= operand, generic\n processing is somewhat different.  The generic characters '*' and '%' are not\n treated as generics but as normal characters.  The only exception is the case\n where a complete qualifier is replaced by '*', which signals the ARCHIVER\n that this qualifier is to remain unchanged.\n0In the ITEM= operand, normal generic processing is in effect and will be\n honored.\n0(Previous version of the ARCHIVER referred to this mechanism as RESPECIFY and\n the RESPECIFY command is considered an alias for ALTER in this version.)\n0Be aware that this function will cause the ARCHIVE to \"grow\", with splits,\n extents, etc.  It's probably a good idea to reorg the ARCHIVE cluster after\n extensive use of ALTER.\n0The required SET operands that must be in effect are:\n0   VSAM1DD= or VSAM1DSN=     (denoting the Archive dataet)\n1                                   -11-\n The CLEAN Command\n+_________________\n0The CLEAN command causes the ARCHIVER to check all the Archive aliases and\n remove those which might have had their 'real' item deleted by previous\n processing errors.  Since this is a 'remedial' command, it should never be\n needed.  Murphy's Law being what it is, the function was added anyway.\n0General format:\n0 CLEAN\n0The CLEAN command has no required operands and will only permit the\n required SET operands to be included.\n0The required SET operands that must be in effect are:\n0   VSAM1DD= or VSAM1DSN=     (denoting the Archive dataset)\n1                                   -12-\n The COMPARE Command\n+___________________\n0The COMPARE statement causes the Archiver to compare two items, or groups of\n items, and message the results of that comparison.  In this initial version,\n messages are very simple and short: either the items match or they don't\n match in some significant way.  Fields compared include the original DCB\n attributes and record counts, item data and NOTE data.  (If the NOTE data\n doesn't match, this is not considered an unsuccessful compare, since the\n NOTE data doesn't participate in LOAD/LOADT functions.)\n0General Format:\n0  COMPARE ITEM=(...),COMPTO=(....),SHRTLST=Y|N\n0All of the qualifier data for the ITEM keyword is optional and may be\n replaced by the generic value '*'.  The format of the COMPTO operand is\n exactly the same as the ITEM operand, with one very important exception.  In\n the COMPTO operand, if a qualifier is replaced by a '*', the compare\n function will search for an item with the SAME qualifier in that position as\n in the ITEM keyword.  For example, consider this scenario:\n0 COMPARE ITEM=(*,CBT325,*,*),COMPTO=(*,CBT324,*,*)\n0During the search of the VSAM1 dataset, an item is found with qualifiers of\n FILE001,CBT325,PDS84,PANEL.  The compare function will attempt to locate, in\n the VSAM2 dataset, an item with the qualifiers of FILE001,CBT324,PDS84,PANEL\n for a comparison.  If no such item is found, a message to that effect is\n produced and the next matching item from VSAM1 is located and compared to its\n matching VSAM2 item.  Partial generics, using the '%' character as a\n place-holder are still honored, as are version numbers.\n0The required SET operands that must be in effect are:\n0   VSAM1DD= or VSAM1DSN=     (input for ITEM= items)\n    VSAM2DD= or VSAM2DSN=     (input for COMPTO items. may be the same\n                               dataset as VSAM1.)\n0The Archiver comparison checks the logical record length, record format,\n logical record count, LMOD indicators, not data in its entirety and item data\n in its entirety.  The first failure to match terminates the comparison with\n appropriate messages.  Also check, but only for information purposes, are\n unload times and dates.\n1                                   -13-\n The CONVERT Command\n+___________________\n0The CONVERT statement will cause the conversion from a previous version\n ARCHIVE cluster of all or selected data to the Version 5 ARCHIVE cluster.\n Data compression/compaction mechanisms are converted as needed.  This\n mechanism is provided for those users who have installed, and are using,\n previous version of the ARCHIVER program.  Item selection is available and\n all generics are honored.  No pre-existing item on the VSAM1 cluster is\n replaced.  If a replacement would occur, the version number of the item to be\n added is incremented by one until insertion is possible.\n0General format:\n0CONVERT ITEM=(...)\n0The required SET operands that must be in effect are:\n0   VSAM1DD= or VSAM1DSN=     (denoting the Version 4 Archive dataset)\n    VSAM2DD= or VSAM2DSN=     (denoting the previous version Archive dataset)\n0Please take careful note: VSAM clusters used and created by Archiver V4.0\n DO NOT REQUIRE CONVERSION.  The ARCHIVE format is unchanged from Version 4.\n1                                   -14-\n The COPY Command\n+___________________\n0The COPY statement causes the ARCHIVER to copy from the VSAM2 ARCHIVE cluster\n to the VSAM1 ARCHIVE cluster.\n0General format:\n0  COPY ITEM=(...),REPLACE=Y|N,ALIASES=Y|N,CHKALIAS=Y|N\n0If the replace operand is supplied, it is honored. Otherwise, a duplicate\n item that is copied has the version number increased by one until the copy\n can succeed.  The user should be aware: this operation can be very slow;\n large numbers of large items are to be avoided.  You should also plan on a\n reorg of the VSAM1 cluster if you use this function much.  If Archiver-type\n aliases are to be copied, the the ALIASES=Y keyword may be provided; and if\n Archiver-type aliases are eligible for selection, the CHKALIAS=Y keyword may\n be supplied as well.\n0The required SET operands that must be in effect are:\n0   VSAM1DD= or VSAM1DSN=     (denoting the OUTPUT Archive dataset)\n    VSAM2DD= or VSAM2DSN=     (denoting the INPUT Archive dataset)\n1                                   -15-\n The DELALIAS Command\n+____________________\n0The DELALIAs command works in either of two modes to delete aliases from the\n Archive dataset.  It will either delete all aliases for a selected set of\n 'real' items, or delete all aliases having the qualifier data specified.  The\n decision is based on the operand keyword supplied.\n0General Format:\n0DELALIAS ITEM=(...)\n0   or\n0DELALIAS ALIAS=(...)\n0If the ITEM= operand is supplied, all aliases for any 'real' item that\n matches the qualifier data supplied will be deleted.  If the ALIAS= operand\n is supplied, all ALIASES that match the qualifier data supplied will be\n deleted.  In either case, the CLEAN processor is invoked after all alias\n deletion is complete.\n0The required SET operands that must be in effect are:\n0   VSAM1DD= or VSAM1DSN=     (denoting the OUTPUT Archive dataset)\n1                                   -16-\n The DELETE Command\n+__________________\n0The DELETE function is just exactly what its name implies.  The user may\n delete NOTE-DATA, back-level copies of items, entire groups of items or the\n entire ARCHIVE contents, depending on the choice of operands.  Since an\n object that is deleted from the Archive cluster may not be recoverable, the\n DELETE function has NO DEFAULTS.  The user must explicitly specify ALL\n options and keywords for the delete function.\n0General Format:\n0DELETE ITEM=(...),DATA=Y|N,NOTE=Y|N,BACK=Y|N,ALIASES=Y|N\n0Operands:\n0DATA=Y or DATA=N  determines whether the actual item is to be deleted.\n0NOTE=Y or NOTE=N determines whether all note data should be deleted from the\n        selected item(s).  Use of the combination NOTE=N,DATA=Y will result in\n        an error message and no action will be taken.  Note data may not be\n        held in the Archive without a 'real' item.\n0BACK=Y or BACK=N will determine whether 'back levels' are to be deleted.\n        Thus, if the Archive contains multiple levels of an item, perhaps\n        placed there as checkpoints in a development cycle, this operand will\n        allow the deletion of these intermediate items.  If you wish to\n        delete ALL occurrances of a particular item, you must use the DELETE\n        twice, once with BACK=Y and again with BACK=N.\n0ALIASES=Y or ALIASES=N has a little more meaning, and function, than the\n        other operands.  If ALIASES=Y is supplied, the item and all its\n        aliases are deleted beyond recovery.  If ALIASES=N is supplied and the\n        item has aliases, the first alias is converted to a 'real' item and\n        the data and note-data are altered to those qualifiers.  Then the\n        selected item is deleted.  It's rather like having multiple copies of\n        the item and notes for the item and just deleting one copy.\n0A cautionary note: the default operands are DATA=N,NOTE=N,ALIASES=N,BACK=N\n for good reason.  Since deletes have the potential to cause permanent data\n loss, the user is required to supply ALL operands.  Invalid combinations will\n result in error messages and no actions, rather than proceeding on possibly\n erroneous assumptions.\n0A further note: you may delete only the 'current' version of an item by\n specifying BACK=N.  Each time you do this, the highest-numbered version will\n be deleted.\n0The required SET operands that must be in effect are:\n0   VSAM1DD= or VSAM1DSN=     (denoting the OUTPUT Archive dataset)\n1                                   -17-\n The EXPORT Command\n+__________________\n0The EXPORT statement will cause the ARCHIVER to copy selected items from the\n ARCHIVE cluster to a sequential dataset in a special format that allows for\n a quick reload to another ARCHIVE cluster, or directly to non-VSAM datasets\n for use.\n0General Format:\n0EXPORT ITEM=(...)\n0Item selection is possible and generics are honored.  The output dataset must\n be a QSAM-supported dataset and the user may specify only the BLKSIZE DCB\n parameter.  The RECFM is VBS and the logical record length is fixed at 32760.\n If the user chooses not to supply a blocksize, the default is 32000.\n0Archive aliases are preserved during export processing and may be restored\n during IMPORT functions or ignored, at the user's discretion.  The capability\n of examining the contents of this EXPORT dataset are provided through the\n LISTT command, described elsewhere.\n0The required SET operands that must be in effect are:\n0   VSAM1DD= or VSAM1DSN=     (denoting the input Archive dataset)\n    EXPTPDD= or EXPTPDSN=     (output sequential dataset)\n1                                   -18-\n The IMPORT Command\n+__________________\n0The IMPORT statement will cause the ARCHIVER to copy selected items from the\n dataset created by EXPORT into the Archive dataset, preserving or discarding\n Archiv aliases at the user's discretion.\n0General Format:\n0IMPORT ITEM=(...),ALIASES=Y|N\n0Operands:\n0ALIASES=Y or ALIASES=N determines whether Archive aliases are to be restored.\n         If the user specifies ALIASES=Y, all applicable aliases are restore\n         as each item is restored.  Please take careful note: the version\n         number in the alias may be altered.\n0REPLACE=Y or REPLACE=N determines whether an item being restored should\n         replace an pre-existing item with all matching qualifiers.  If\n         REPLACE=N is specified, the item being imported will be altered to\n         form a new higher version, rather than replacing a pre-existing item.\n0Item selection is possible and generics are honored.  The input dataset must\n be QSAM-supported and on DASD or TAPE.\n0The required SET operands that must be in effect are:\n0   VSAM1DD= or VSAM1DSN=     (denoting the output Archive dataset)\n    EXPTPDD= or EXPTPDSN=     (input sequential dataset)\n1                                   -19-\n The LFILE Command\n+_________________\n0New in this version of the Archiver is the concept of LOGICAL FILES.  In this\n context, a LOGICAL FILE is any item or group of items that have a common\n GROUP, SUBGROUP, TYPE and VERSION NUMBER.  In keeping with this idea, the\n program can list these logical files, giving item counts and total record\n counts.  This allows the user to list, for example, all the files of a CBT\n tape that has been transferred into any archive, showing the number of\n members from each PDS and the number of logical records, very helpful for\n space estimates.  (The SAMPLIB dataset contains an example of how I\n Archived the CBT325 tape.)\n0Command format:\n0  LFILE ITEM=(.....)\n0While the ITEM= values are not changed for this command, the member name,\nthe first field of the ITEM value, is ignored.\n0SET operands required:  VSAM1DD/VSAM1DSN is required.\n1                                   -20-\n The LFILET Command\n+__________________\n0In keeping with the idea of allowing as much as possible from the Archiver-\n export dataset, the LFILET will perform the same function as the LFILE, the\n only difference being that the input is from the EXPTPDD/EXPTPDSN dataset,\n rather than the VSAM1DD/VSAM1DSN VSAM cluster.\n0Command format:\n0  LFILET ITEM=(.....)\n0While the ITEM= values are not changed for this command, the member name,\nthe first field of the ITEM value, is ignored.\n0SET operands required:  EXPTPDD/EXPTPDSN is required.\n1                                   -21-\n The LIST Command\n+________________\n0The LIST statement allows the user to list, directly from the VSAM1 ARCHIVE\n cluster, the contents  of the ARCHIVE, in a variety of formats.\n0General Format:\n0LIST ITEM=(...),DATA=Y|N,NOTE=Y|N,HEX=Y|N,ALIAS=Y|N\n0DATA=Y or DATA=N determines whether the actual item data should be listed in\n        its entirety.\n0HEX=Y or HEX=N determines whether the item data should be listed in a\n        hexadecimal format, similar to a dump.\n0NOTE=Y or NOTE=N determines whether any NOTE data should be listed. Note data\n        is always listed in character format, regardless of whether or not\n        HEX=Y was specified.\n0ALIASES=Y or ALIASES=N determines whether Archiver aliases should be listed.\n        The aliases are listed in a modified format, showing the qualifiers of\n        the corresponding real item.\n0The required SET operands that must be in effect are:\n0   VSAM1DD= or VSAM1DSN=     (input Archive dataset)\n1                                   -22-\n The LISTT Command\n+_________________\n0The LISTT function will list the contents of a dataset created by the EXPORT\n function of ARCHIVER.  For most operands, refer to the LIST function.  One\n notable exception: since the listing is of a non-VSAM dataset, the SET values\n in effect MUST include EXPTPDD or EXPTPDSN.\n0Since the input is an EXPORT of a VSAM Archive, the items listed will\n probably not be in perfect alphabetical order.  All the Archive aliases for\n an item will be displayed immediately after the 'real' item name, since\n that's how they're exported.\n1                                   -23-\n The LOAD Command\n+________________\n0The LOAD statement causes the ARCHIVER to copy from a VSAM ARCHIVE cluster to\n a non-VSAM dataset.\n0General Format:\n0  LOAD ITEM=(...),REPLACE=Y|N,SEP=IEBUPDTE,ALIASES=Y|N,CHKALIAS=Y|N\n0The selected item(s) are copied from the ARCHIVE cluster to the non-VSAM\n dataset, reblocking and changing formats as requested, if possible.  If a DCB\n format change is impossible, or if the record lengths are incompatable, a\n error message is produced to this effect and processing is terminated for the\n offending item.\n0REPLACE=Y|N determines whether pre-existing members in the output dataset\n will be replaced or not replaced during this LOAD.\n0ALIASES=Y|N determines whether any BPAM aliases for PDS members will be\n restored during the LOAD function.\n0CHKALIAS=Y|N determines whether Archive aliases will be considered during the\n LOAD function.  If the value specified is Y (or YES), each alias will be\n checked against the criteria specified in the ITEM= parameter.  The first\n time an alias matches this criteria, the item will be loaded.  Each alias or\n non-alias that matches the 'real' item name after that point will be ignored.\n Because of the way this is implemented, each 'real' member that is selected\n for loading will cause the ARCHIVER's storage requirements to grow by 48\n bytes.  Executing the LOAD function against a large number of Archive items\n may require significant increases in region size.\n0Please note: if the output dataset from the LOAD function is a NEW dataset,\n the DCB on the DD statement MUST specify the DSORG parameter, either PS or\n PO.\n0The required SET operands that must be in effect are:\n0   VSAM1DD= or VSAM1DSN=     (input Archive dataset)\n    DD=      or DSN=          (output sequential or partitioned dataset)\n1                                   -24-\n The LOADT control statement\n+___________________________\n0The LOADT statement causes the ARCHIVER to copy directly from a sequential\n dataset created by the ARCHIVER EXPORT function to a non-VSAM dataset.\n0All operands are exactly the same as for the LOAD statement, except that the\n input dataset (the EXPORTED archive) is designated by the EXPTPDD/EXPTPDSN\n operand of the SET command.  This is a clarification from previous levels\n of the Archiver.\n1                                   -25-\n The UNLOAD Command\n+__________________\n0The UNLOAD statement causes the ARCHIVER to copy from a non-VSAM dataset into\n the ARCHIVE VSAM cluster described by the VSAM1DDN or VSAM1DSN parameter.\n0General Format:\n0  UNLOAD ITEM=(...),ULMODS=Y|N,ALIASES=Y|N\n0All of the qualifiers must be specified except the mbr value, which may be\n generic if the non-VSAM dataset is a partitioned dataset.  If a version\n number is supplied, any previously unloaded item with all qualifiers matching\n will be replaced.  If no version number is supplied and a previously unloaded\n item exists with mbr, group, subgroup and type matching, a new version will\n be created.  Version numbers should not be supplied, since it's easier to\n delete a bad version that to replace an overlaid item.\n0ULMODS= signals the ARCHIVER whether or not to treat any input data with a\n RECFM of U as LOAD MODULES.  While this has little effect on non-load-module\n data, it will significantly enhance the processing of load modules during\n reload.  Such things as tracking note lists, etc.  The default is Y and the\n user would be well advised to leave this default in effect.\n0ALIASES= signals the ARCHIVER whether or not to create Archive aliases that\n correspond to the aliases that a PDS member might have in the dataset being\n unloaded.  Here again, the default is Y and the user would be well advised to\n leave this default in effect.\n0The required SET operands that must be in effect are:\n0   VSAM1DD= or VSAM1DSN=     (output Archive dataset)\n    DD=      or DSN=          (input sequential or partitioned dataset)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$ARCH370": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00#\\x01\\x02!\\x7f\\x01\\x02!\\x8f\\x13A\\x00\\x1d\\x00\\x08\\x00\\x00\\xd4\\xd4\\xe2\\xd4\\xc1\\xd2@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2002-08-05T00:00:00", "modifydate": "2002-08-06T13:41:23", "lines": 29, "newlines": 8, "modlines": 0, "user": "MMSMAK"}, "text": "ARCHIVER Version 6 for MVS3.8J by Dave Cartwright.\n\nI have long been a fan of The Archiver program from Rick Fochtman - see\nCBT file 172 for some add-ons I did for Version 5 (I have not tried\nthese with Version 6).  When the requirement arose in AGCO UK Ltd. to\narchive a home-grown IMS application that was being replaced with\nshrink-wrap software I looked to the Archiver as a suitable tool.\nOne point about an archive is that you should be able to read it; not\njust the recording medium, but the playback technology as well. At the\ntime I was taking part in the beta test of the MVS Turnkey #3 from\nVolker Bandke (http://www.bsp-gmbh.com/). It seemed to me that this met\nthe requirements of an archiving system; it was freely available,\nportable, not subject to copyright etc.. There was even a copy of The\nArchiver on the Turnkey system (CBT429.FILE147). Unfortunately when I\ntried to install that version I found it was not downwards compatible to\nMVS/370.  Rick kindly allowed me to create a downwards compatible\nversion and this document describes that program.\nThere were some minor problems with the Assembler that I fixed by moving\nsome statements to a different location.  Module RPARSE has RMODE/AMODE\nstatements that cause errors which may be ignored.\nThe biggest problem was the use of a Y2K compliant version of the TIME\nmacro in ARCHINIT. To overcome this I have created a version called\nA370INIT that programs around the functions that IBM now provide in the\nTIME macro. I used code from GETDATE by Jim Marshall as the basis for\nthis work. The code is pretty sloppy and I have a very cavalier attitude\ntowards using data areas for scratch pads, but it works. It is upwards\ncompatible; you may use this version under OS/390 or z/OS if you wish.\nMember $INST370 is the jobstream to install this program using Assembler\nF under MVS/370.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$CVDSORG": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00]\\x00]\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 93, "newlines": 93, "modlines": 0, "user": "ARCHIVR"}, "text": "         MACRO\n&LBL     $CVDSORG &OUT,&IN\n.*--------------------------------------------------------------------*\n.*---    GENERAL-PURPOSE MACRO                                     ---*\n.*---                                                              ---*\n.*---    CONVERT DCBDSORG TO PRINTABLE FORMAT                      ---*\n.*---                                                              ---*\n.*---    IN= IS A TWO-BYTE FIELD CONTAINING THE DSORG FIELD OF     ---*\n.*---    A DCB OR FORMAT-1 DSCB.                                   ---*\n.*---                                                              ---*\n.*---    OUT= IS AN OUTPUT FIELD THAT WILL CONTAIN THE CHARACTER   ---*\n.*---    FORM OF THE DSORG VALUE IN THE INPUT FIELD. NO CHECK IS   ---*\n.*---    MADE REGARDING THE LENGTH OF EITHER THE OUTPUT OR INPUT   ---*\n.*---    FIELDS.  NOTE THAT THIS MACRO CAN GENERATE REENTRANT CODE ---*\n.*---    AND IS NOT ADDRESSING-MODE DEPENDANT.                     ---*\n.*--------------------------------------------------------------------*\n         LCLC  &LL,&LE\n&LL      SETC  '&LBL'\n         AIF   ('&LL' EQ '').NOLBL\n&LL      DS    0H\n.NOLBL   ANOP\n&LL      SETC  '$CDA&SYSNDX'\n&LE      SETC  '$CDU&SYSNDX'\n         LA    15,&OUT             POINT TO OUTPUT AREA\n         MVC   0(3,15),=CL3' '     AND CLEAR IT OUT\n         TM    &IN,X'80'           ISAM ??\n         BZ    &LL                 NOPE ---\n         MVC   0(2,15),=C'IS'      MOVE IN CHARACTER FORM\n         B     &LE                 GO CHECK UNMOVABLE\n&LL      DS    0H\n&LL      SETC  '$CDB&SYSNDX'\n         TM    &IN,X'40'           PHYSICAL SEQUENTIAL ??\n         BZ    &LL                 NOPE ---\n         MVC   0(2,15),=C'PS'      MOVE IN CHARACTER FORM\n         B     &LE                 GO CHECK UNMOVABLE\n&LL      DS    0H\n&LL      SETC  '$CDC&SYSNDX'\n         TM    &IN,X'20'           DIRECT ACCESS (BDAM) ??\n         BZ    &LL                 NOPE ---\n         MVC   0(2,15),=C'DA'      MOVE IN CHARACTER FORM\n         B     &LE                 GO CHECK UNMOVABLE\n&LL      DS    0H\n&LL      SETC  '$CDD&SYSNDX'\n         TM    &IN,X'10'           BTAM/QTAM LINE GROUP ??\n         BZ    &LL                 NOPE ---\n         MVC   0(2,15),=C'CX'      MOVE IN CHARACTER FORM\n         B     &LE                 GO CHECK UNMOVABLE\n&LL      DS    0H\n&LL      SETC  '$CDE&SYSNDX'\n         TM    &IN,X'02'           PARTITIONED ??\n         BZ    &LL                 NOPE ---\n         MVC   0(2,15),=C'PO'      MOVE IN CHARACTER FORM\n         B     &LE                 GO CHECK UNMOVABLE\n&LL      DS    0H\n&LL      SETC  '$CDF&SYSNDX'\n         TM    1(R2),X'80'         GRAPHICS ORGANIZATION ??\n         BZ    &LL                 NOPE ---\n         MVC   0(2,15),=C'GS'      MOVE IN CHARACTER FORM\n         B     &LE                 GO CHECK UNMOVABLE\n&LL      DS    0H\n&LL      SETC  '$CDG&SYSNDX'\n         TM    1(R2),X'40'         TCAM LINE GROUP ??\n         BZ    &LL                 NOPE ---\n         MVC   0(2,15),=C'TX'      MOVE IN CHARACTER FORM\n         B     &LE                 GO CHECK UNMOVABLE\n&LL      DS    0H\n&LL      SETC  '$CDH&SYSNDX'\n         TM    1(R2),X'20'         TCAM MESSAGE QUEUE ??\n         BZ    &LL                 NOPE ---\n         MVC   0(2,15),=C'TQ'      MOVE IN CHARACTER FORM\n         B     &LE                 GO CHECK UNMOVABLE\n&LL      DS    0H\n&LL      SETC  '$CDI&SYSNDX'\n         TM    1(R2),X'08'         VSAM ??\n         BZ    &LL                 NOPE ---\n         MVC   0(2,15),=C'AM'      MOVE IN CHARACTER FORM\n         B     &LE                 GO CHECK UNMOVABLE\n&LL      DS    0H\n&LL      SETC  '$CDJ&SYSNDX'\n         TM    &IN,X'04'           TCAM/3705 ??\n         BZ    &LL                 NOPE ---\n         MVC   0(2,15),=C'TR'      MOVE IN CHARACTER FORM\n         LA    R6,2(,R6)\n         B     &LE                 GO CHECK UNMOVABLE\n&LL      DS    0H\n         MVC   0(2,15),=C'XX'      MOVE IN CHARACTER FORM\n&LE      DS    0H\n&LL      SETC  '$CDK&SYSNDX'\n         TM    &IN,X'01'           UNMOVEABLE DATASET ??\n         BZ    &LL                 NOPE ---\n         MVI   2(15),C'U'\n&LL      DS    0H\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$CVRECFM": {"ttr": 778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00I\\x00I\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 73, "newlines": 73, "modlines": 0, "user": "ARCHIVR"}, "text": "         MACRO\n&LBL     $CVRECFM &OUT,&IN\n.*--------------------------------------------------------------------*\n.*---    GENERAL-PURPOSE MACRO                                     ---*\n.*---                                                              ---*\n.*---    CONVERT DCBRECFM TO PRINTABLE FORMAT                      ---*\n.*---                                                              ---*\n.*---    IN= IS A ONE-BYTE FIELD CONTAINING THE RECFM FIELD OF     ---*\n.*---    A DCB OR FORMAT-1 DSCB.                                   ---*\n.*---                                                              ---*\n.*---    OUT= IS AN OUTPUT FIELD THAT WILL CONTAIN THE CHARACTER   ---*\n.*---    FORM OF THE RECFM VALUE IN THE INPUT FIELD. NO CHECK IS   ---*\n.*---    MADE REGARDING THE LENGTH OF EITHER THE OUTPUT OR INPUT   ---*\n.*---    FIELDS.  NOTE THAT THIS MACRO CAN GENERATE REENTRANT CODE ---*\n.*---    AND IS NOT ADDRESSING-MODE DEPENDANT.                     ---*\n.*--------------------------------------------------------------------*\n         LCLC  &LL,&LLA,&LLB,&LLC,&LLD,&LLE,&LLF,&LLG,&LLH\n&LLA     SETC  '$CRA&SYSNDX'\n&LLB     SETC  '$CRB&SYSNDX'\n&LLC     SETC  '$CRC&SYSNDX'\n&LLD     SETC  '$CRD&SYSNDX'\n&LLE     SETC  '$CRE&SYSNDX'\n&LLF     SETC  '$CRF&SYSNDX'\n&LLG     SETC  '$CRG&SYSNDX'\n&LLH     SETC  '$CRH&SYSNDX'\n&LL      SETC  '&LBL'\n         AIF   ('&LL' EQ '').NOLBL\n&LL      DS    0H\n.NOLBL   ANOP\n         LA    15,&OUT             POINT TO OUTPUT FIELD\n         MVC   0(8,15),=CL8' '     AND CLEAR IT OUT\n         TM    &IN,X'C0'           RECFM=U ??\n         BNO   &LLA                NOPE ---\n         MVI   0(15),C'U'          YES ---\n         LA    15,1(,15)           NEXT POSITION\n         B     &LLC\n&LLA     DS    0H\n         TM    &IN,X'80'           RECFM=F ??\n         BZ    &LLB                NOPE ---\n         MVI   0(15),C'F'\n         LA    15,1(,15)\n         B     &LLC\n&LLB     DS    0H\n         TM    &IN,X'40'           RECFM = V ??\n         BZ    &LLC                NOPE ---\n         MVI   0(15),C'V'\n         LA    15,1(,15)\n&LLC     DS    0H\n         TM    &IN,X'20'           TRACK OVERFLOW ??\n         BZ    &LLD                NOPE ---\n         MVI   0(15),C'T'\n         LA    15,1(,15)\n&LLD     DS    0H\n         TM    &IN,X'10'           BLOCKED RECORDS ??\n         BZ    &LLE\n         MVI   0(15),C'B'\n         LA    15,1(,15)\n&LLE     DS    0H\n         TM    &IN,X'08'           SPANNED/STANDARD RECORDS ??\n         BZ    &LLF                NOPE ---\n         MVI   0(15),C'S'\n         LA    15,1(,15)\n&LLF     DS    0H\n         TM    &IN,X'04'        ANSI CONTROL CHARACTERS ??\n         BZ    &LLG                NOPE ---\n         MVI   0(15),C'A'\n         LA    15,1(,15)\n&LLG     DS    0H\n         TM    &IN,X'02'           MACHINE CONTROL CHARACTERS ??\n         BZ    &LLH                NOPE ---\n         MVI   0(15),C'M'\n&LLH     DS    0H\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$INSTALL": {"ttr": 781, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06\\x0c\\x00\\x00\\x01 \\x18o\\x01 \\x18o\\x10\\x10\\x00Z\\x00Z\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@'", "ispf": {"version": "06.12", "flags": 0, "createdate": "2020-07-04T00:00:00", "modifydate": "2020-07-04T10:10:00", "lines": 90, "newlines": 90, "modlines": 0, "user": "ARCHIVR"}, "text": "//      YOUR JOB STATEMENT GOES HERE\n//*\n//* YOU WILL NEED TO EDIT THE DSNAMES IN THIS JOB.  LOOK FOR ANY\n//* NON-BLANK VALUES IN COLUMNS 73-80\n//*\n//* YOU MAY ALSO WISH TO EDIT THE SYSOUT CLASSES, AS WELL.\n//*\n//ARCHASM  PROC  M=\n//ASM      EXEC  PGM=ASMA90,\n//         PARM='TERM,DECK,NOOBJ,NORLD,XREF(SHORT),USING(WARN(11))'\n//SYSPRINT DD    DUMMY\n//SYSTERM  DD    SYSOUT=Y,HOLD=YES                                      SYSOUT\n//SYSLIB   DD    DSN=ARCHIVER.DISTLIB,DISP=SHR                          DSNAME\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(3,1))\n//SYSIN    DD    DSN=ARCHIVER.DISTLIB(&M),DISP=SHR                      DSNAME\n//SYSPUNCH DD    DSN=ARCHIVER.OBJ(&M),DISP=SHR                          DSNAME\n//         PEND\n//AMATRACE EXEC  ARCHASM,M=AMATRACE\n//ARCHALIS EXEC  ARCHASM,M=ARCHALIS\n//ARCHALT  EXEC  ARCHASM,M=ARCHALT\n//ARCHCOMP EXEC  ARCHASM,M=ARCHCOMP\n//ARCHCONV EXEC  ARCHASM,M=ARCHCONV\n//ARCHCOPY EXEC  ARCHASM,M=ARCHCOPY\n//ARCHDEL  EXEC  ARCHASM,M=ARCHDEL\n//ARCHDELC EXEC  ARCHASM,M=ARCHDELC\n//ARCHDELD EXEC  ARCHASM,M=ARCHDELD\n//ARCHDELE EXEC  ARCHASM,M=ARCHDELE\n//ARCHDELF EXEC  ARCHASM,M=ARCHDELF\n//ARCHDEL1 EXEC  ARCHASM,M=ARCHDEL1\n//ARCHDEL2 EXEC  ARCHASM,M=ARCHDEL2\n//ARCHDEL3 EXEC  ARCHASM,M=ARCHDEL3\n//ARCHDEL4 EXEC  ARCHASM,M=ARCHDEL4\n//ARCHDEL5 EXEC  ARCHASM,M=ARCHDEL5\n//ARCHDEL6 EXEC  ARCHASM,M=ARCHDEL6\n//ARCHDEL7 EXEC  ARCHASM,M=ARCHDEL7\n//ARCHDIR  EXEC  ARCHASM,M=ARCHDIR\n//ARCHERAS EXEC  ARCHASM,M=ARCHERAS\n//ARCHERRM EXEC  ARCHASM,M=ARCHERRM\n//ARCHEXPR EXEC  ARCHASM,M=ARCHEXPR\n//ARCHFORM EXEC  ARCHASM,M=ARCHFORM\n//ARCHIMPR EXEC  ARCHASM,M=ARCHIMPR\n//ARCHINIT EXEC  ARCHASM,M=ARCHINIT\n//ARCHKDCB EXEC  ARCHASM,M=ARCHKDCB\n//ARCHKNAM EXEC  ARCHASM,M=ARCHKNAM\n//ARCHLDT  EXEC  ARCHASM,M=ARCHLDT\n//ARCHLFTP EXEC  ARCHASM,M=ARCHLFTP\n//ARCHLFVS EXEC  ARCHASM,M=ARCHLFVS\n//ARCHLIST EXEC  ARCHASM,M=ARCHLIST\n//ARCHLOAD EXEC  ARCHASM,M=ARCHLOAD\n//ARCHLSTT EXEC  ARCHASM,M=ARCHLSTT\n//ARCHMAIN EXEC  ARCHASM,M=ARCHMAIN\n//ARCHMSGS EXEC  ARCHASM,M=ARCHMSGS\n//ARCHNOTE EXEC  ARCHASM,M=ARCHNOTE\n//ARCHPARS EXEC  ARCHASM,M=ARCHPARS\n//ARCHPRSC EXEC  ARCHASM,M=ARCHPRSC\n//ARCHRSPC EXEC  ARCHASM,M=ARCHRSPC\n//ARCHTABS EXEC  ARCHASM,M=ARCHTABS\n//ARCHUNLD EXEC  ARCHASM,M=ARCHUNLD\n//ARCHVSOP EXEC  ARCHASM,M=ARCHVSOP\n//CELLMAN  EXEC  ARCHASM,M=CELLMAN\n//COMPACT  EXEC  ARCHASM,M=COMPACT\n//DYNAM    EXEC  ARCHASM,M=DYNAM\n//EXPAND   EXEC  ARCHASM,M=EXPAND\n//EXPLODE  EXEC  ARCHASM,M=EXPLODE\n//RPARSE   EXEC  ARCHASM,M=RPARSE\n//LINK1    EXEC  PGM=IEWL,PARM='LIST,LET,XREF,RENT,REUS,REFR'\n//SYSPRINT DD    SYSOUT=E,HOLD=YES                                      SYSOUT\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(3,1))\n//SYSLIB   DD    DSN=ARCHIVER.OBJ,DISP=SHR                              DSNAME\n//SYSLMOD  DD    DSN=ARCHIVER.LOAD,DISP=SHR                             DSNAME\n//SYSLIN   DD    *\n INCLUDE SYSLIB(ARCHMAIN)\n INCLUDE SYSLIB(ARCHTABS)\n ENTRY ARCHMAIN\n NAME ARCHIVER(R)\n//LINK2    EXEC  PGM=IEWL,PARM='LIST,LET,XREF'\n//SYSPRINT DD    SYSOUT=E,HOLD=YES                                      SYSOUT\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(3,1))\n//SYSLIB   DD    DSN=ARCHIVER.OBJ,DISP=SHR                              DSNAME\n//SYSLMOD  DD    DSN=ARCHIVER.LOAD,DISP=SHR                             DSNAME\n//SYSLIN   DD    *\n INCLUDE SYSLIB(ARCHINIT)\n INCLUDE SYSLIB(ARCHPRSC)\n ENTRY ARCHINIT\n NAME ARCHINIT(R)\n INCLUDE SYSLIB(ARCHPARS)\n ENTRY ARCHPARS\n NAME ARCHPARS(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$INST37A": {"ttr": 784, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06\\x0c\\x00\\x00\\x01 \\x18o\\x01 \\x18o\\x10\\x10\\x00g\\x00g\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@'", "ispf": {"version": "06.12", "flags": 0, "createdate": "2020-07-04T00:00:00", "modifydate": "2020-07-04T10:10:00", "lines": 103, "newlines": 103, "modlines": 0, "user": "ARCHIVR"}, "text": "//Z531415A JOB (HERC01),ARCHIVER,CLASS=A,MSGLEVEL=(1,1),\n//         MSGCLASS=X,TIME=30,NOTIFY=&SYSUID,REGION=2M\n//*\n//*     PDSDOC *INSTALL ARCHIVER VERSION 6 ON MVS3.8J................*\n//*\n//ARCHASM  PROC  M=\n//ASM      EXEC  PGM=IFOX00,\n//         PARM='TERM,DECK,NOOBJ,NORLD,XREF(SHORT)'\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*\n//SYSLIB   DD    DSN=Z531415.ARCHIVER.ASM,DISP=SHR,DCB=BLKSIZE=32000\n//         DD    DSN=SYS1.AMODGEN,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(3,1))\n//SYSUT2   DD    UNIT=SYSALLDA,SPACE=(CYL,(3,1))\n//SYSUT3   DD    UNIT=SYSALLDA,SPACE=(CYL,(3,1))\n//SYSIN    DD    DSN=Z531415.ARCHIVER.ASM(&M),DISP=SHR\n//SYSPUNCH DD    DSN=Z531415.ARCHIVER.OBJ(&M),DISP=SHR\n//         PEND\n//*\n//ALLOC    EXEC PGM=IEFBR14\n//OBJ     DD  DISP=(NEW,CATLG),UNIT=SYSALLDA,\n//            SPACE=(TRK,(30,5,10)),VOL=SER=ROB999,\n//            DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200),\n//            DSN=Z531415.ARCHIVER.OBJ\n//LOAD    DD  DISP=(NEW,CATLG),UNIT=SYSALLDA,\n//            SPACE=(TRK,(30,5,10)),VOL=SER=ROB999,\n//            DCB=(RECFM=U,BLKSIZE=6144),\n//            DSN=Z531415.ARCHIVER.LOAD\n//*\n//AMATRACE EXEC  ARCHASM,M=AMATRACE\n//ARCHALIS EXEC  ARCHASM,M=ARCHALIS\n//ARCHALT  EXEC  ARCHASM,M=ARCHALT\n//ARCHCOMP EXEC  ARCHASM,M=ARCHCOMP\n//ARCHCONV EXEC  ARCHASM,M=ARCHCONV\n//ARCHCOPY EXEC  ARCHASM,M=ARCHCOPY\n//ARCHDEL  EXEC  ARCHASM,M=ARCHDEL\n//ARCHDELC EXEC  ARCHASM,M=ARCHDELC\n//ARCHDELD EXEC  ARCHASM,M=ARCHDELD\n//ARCHDELE EXEC  ARCHASM,M=ARCHDELE\n//ARCHDELF EXEC  ARCHASM,M=ARCHDELF\n//ARCHDEL1 EXEC  ARCHASM,M=ARCHDEL1\n//ARCHDEL2 EXEC  ARCHASM,M=ARCHDEL2\n//ARCHDEL3 EXEC  ARCHASM,M=ARCHDEL3\n//ARCHDEL4 EXEC  ARCHASM,M=ARCHDEL4\n//ARCHDEL5 EXEC  ARCHASM,M=ARCHDEL5\n//ARCHDEL6 EXEC  ARCHASM,M=ARCHDEL6\n//ARCHDEL7 EXEC  ARCHASM,M=ARCHDEL7\n//ARCHDIR  EXEC  ARCHASM,M=ARCHDIR\n//ARCHERAS EXEC  ARCHASM,M=ARCHERAS\n//ARCHERRM EXEC  ARCHASM,M=ARCHERRM\n//ARCHEXPR EXEC  ARCHASM,M=ARCHEXPR\n//ARCHFORM EXEC  ARCHASM,M=ARCHFORM\n//ARCHIMPR EXEC  ARCHASM,M=ARCHIMPR\n//ARCHINIT EXEC  ARCHASM,M=A370INIT\n//ARCHKDCB EXEC  ARCHASM,M=ARCHKDCB\n//ARCHKNAM EXEC  ARCHASM,M=ARCHKNAM\n//ARCHLDT  EXEC  ARCHASM,M=ARCHLDT\n//ARCHLFTP EXEC  ARCHASM,M=ARCHLFTP\n//ARCHLFVS EXEC  ARCHASM,M=ARCHLFVS\n//ARCHLIST EXEC  ARCHASM,M=ARCHLIST\n//ARCHLOAD EXEC  ARCHASM,M=ARCHLOAD\n//ARCHLSTT EXEC  ARCHASM,M=ARCHLSTT\n//ARCHMAIN EXEC  ARCHASM,M=ARCHMAIN\n//ARCHMSGS EXEC  ARCHASM,M=ARCHMSGS\n//ARCHNOTE EXEC  ARCHASM,M=ARCHNOTE\n//ARCHPARS EXEC  ARCHASM,M=ARCHPARS\n//ARCHPRSC EXEC  ARCHASM,M=ARCHPRSC\n//ARCHRSPC EXEC  ARCHASM,M=ARCHRSPC\n//ARCHTABS EXEC  ARCHASM,M=ARCHTABS\n//ARCHUNLD EXEC  ARCHASM,M=ARCHUNLD\n//ARCHVSOP EXEC  ARCHASM,M=ARCHVSOP\n//CELLMAN  EXEC  ARCHASM,M=CELLMAN\n//COMPACT  EXEC  ARCHASM,M=COMPACT\n//DYNAM    EXEC  ARCHASM,M=DYNAM\n//EXPAND   EXEC  ARCHASM,M=EXPAND\n//EXPLODE  EXEC  ARCHASM,M=EXPLODE\n//RPARSE   EXEC  ARCHASM,M=RPARSE\n//LINK1    EXEC  PGM=IEWL,PARM='LIST,LET,XREF,RENT,REUS,REFR,MAP'\n//SYSPRINT DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(3,1))\n//SYSLIB   DD    DSN=Z531415.ARCHIVER.OBJ,DISP=SHR\n//SYSLMOD  DD    DSN=Z531415.ARCHIVER.LOAD,DISP=SHR\n//SYSLIN   DD    *\n INCLUDE SYSLIB(ARCHMAIN)\n INCLUDE SYSLIB(ARCHTABS)\n ENTRY ARCHMAIN\n NAME ARCHIVER(R)\n//LINK2    EXEC  PGM=IEWL,PARM='LIST,LET,XREF,MAP'\n//SYSPRINT DD    SYSOUT=*\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(3,1))\n//SYSLIB   DD    DSN=Z531415.ARCHIVER.OBJ,DISP=SHR\n//SYSLMOD  DD    DSN=Z531415.ARCHIVER.LOAD,DISP=SHR\n//SYSLIN   DD    *\n INCLUDE SYSLIB(A370INIT)\n INCLUDE SYSLIB(ARCHPRSC)\n ENTRY ARCHINIT\n NAME ARCHINIT(R)\n INCLUDE SYSLIB(ARCHPARS)\n ENTRY ARCHPARS\n NAME ARCHPARS(R)\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$INST370": {"ttr": 1027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06\\x0c\\x00\\x00\\x01 \\x18o\\x01 \\x18o\\x10\\x10\\x00g\\x00g\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@'", "ispf": {"version": "06.12", "flags": 0, "createdate": "2020-07-04T00:00:00", "modifydate": "2020-07-04T10:10:00", "lines": 103, "newlines": 103, "modlines": 0, "user": "ARCHIVR"}, "text": "//HERC01A1 JOB (HERC01),ARCHIVER,CLASS=A,MSGLEVEL=(1,1),\n//         MSGCLASS=X,TIME=30,NOTIFY=HERC01,REGION=0K\n//*\n//*      PDSDOC *INSTALL ARCHIVER VERSION 6 ON MVS3.8J................*\n//*\n//ARCHASM  PROC  M=\n//ASM      EXEC  PGM=IFOX00,\n//         PARM='TERM,DECK,NOOBJ,NORLD,XREF(SHORT)'\n//SYSPRINT DD    SYSOUT=*\n//SYSTERM  DD    SYSOUT=*,HOLD=YES                                      SYSOUT\n//SYSLIB   DD    DSN=CBT429.FILE147,DISP=SHR,DCB=BLKSIZE=32000          DSNAME\n//         DD    DSN=SYS1.AMODGEN,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(3,1))\n//SYSUT2   DD    UNIT=SYSALLDA,SPACE=(CYL,(3,1))\n//SYSUT3   DD    UNIT=SYSALLDA,SPACE=(CYL,(3,1))\n//SYSIN    DD    DSN=CBT429.FILE147(&M),DISP=SHR                        DSNAME\n//SYSPUNCH DD    DSN=CBT429.A.OBJ(&M),DISP=SHR                          DSNAME\n//         PEND\n//*\n//ALLOC    EXEC PGM=IEFBR14\n//OBJ       DD  DISP=(NEW,CATLG),UNIT=SYSALLDA,\n//              SPACE=(TRK,(30,5,10)),\n//              DCB=(RECFM=FB,LRECL=80,BLKSIZE=800),\n//              DSN=CBT429.A.OBJ\n//LOAD      DD  DISP=(NEW,CATLG),UNIT=SYSALLDA,\n//              SPACE=(TRK,(30,5,10)),\n//              DCB=(RECFM=U,BLKSIZE=6440),\n//              DSN=CBT429.A.LOAD\n//*\n//AMATRACE EXEC  ARCHASM,M=AMATRACE\n//ARCHALIS EXEC  ARCHASM,M=ARCHALIS\n//ARCHALT  EXEC  ARCHASM,M=ARCHALT\n//ARCHCOMP EXEC  ARCHASM,M=ARCHCOMP\n//ARCHCONV EXEC  ARCHASM,M=ARCHCONV\n//ARCHCOPY EXEC  ARCHASM,M=ARCHCOPY\n//ARCHDEL  EXEC  ARCHASM,M=ARCHDEL\n//ARCHDELC EXEC  ARCHASM,M=ARCHDELC\n//ARCHDELD EXEC  ARCHASM,M=ARCHDELD\n//ARCHDELE EXEC  ARCHASM,M=ARCHDELE\n//ARCHDELF EXEC  ARCHASM,M=ARCHDELF\n//ARCHDEL1 EXEC  ARCHASM,M=ARCHDEL1\n//ARCHDEL2 EXEC  ARCHASM,M=ARCHDEL2\n//ARCHDEL3 EXEC  ARCHASM,M=ARCHDEL3\n//ARCHDEL4 EXEC  ARCHASM,M=ARCHDEL4\n//ARCHDEL5 EXEC  ARCHASM,M=ARCHDEL5\n//ARCHDEL6 EXEC  ARCHASM,M=ARCHDEL6\n//ARCHDEL7 EXEC  ARCHASM,M=ARCHDEL7\n//ARCHDIR  EXEC  ARCHASM,M=ARCHDIR\n//ARCHERAS EXEC  ARCHASM,M=ARCHERAS\n//ARCHERRM EXEC  ARCHASM,M=ARCHERRM\n//ARCHEXPR EXEC  ARCHASM,M=ARCHEXPR\n//ARCHFORM EXEC  ARCHASM,M=ARCHFORM\n//ARCHIMPR EXEC  ARCHASM,M=ARCHIMPR\n//ARCHINIT EXEC  ARCHASM,M=A370INIT\n//ARCHKDCB EXEC  ARCHASM,M=ARCHKDCB\n//ARCHKNAM EXEC  ARCHASM,M=ARCHKNAM\n//ARCHLDT  EXEC  ARCHASM,M=ARCHLDT\n//ARCHLFTP EXEC  ARCHASM,M=ARCHLFTP\n//ARCHLFVS EXEC  ARCHASM,M=ARCHLFVS\n//ARCHLIST EXEC  ARCHASM,M=ARCHLIST\n//ARCHLOAD EXEC  ARCHASM,M=ARCHLOAD\n//ARCHLSTT EXEC  ARCHASM,M=ARCHLSTT\n//ARCHMAIN EXEC  ARCHASM,M=ARCHMAIN\n//ARCHMSGS EXEC  ARCHASM,M=ARCHMSGS\n//ARCHNOTE EXEC  ARCHASM,M=ARCHNOTE\n//ARCHPARS EXEC  ARCHASM,M=ARCHPARS\n//ARCHPRSC EXEC  ARCHASM,M=ARCHPRSC\n//ARCHRSPC EXEC  ARCHASM,M=ARCHRSPC\n//ARCHTABS EXEC  ARCHASM,M=ARCHTABS\n//ARCHUNLD EXEC  ARCHASM,M=ARCHUNLD\n//ARCHVSOP EXEC  ARCHASM,M=ARCHVSOP\n//CELLMAN  EXEC  ARCHASM,M=CELLMAN\n//COMPACT  EXEC  ARCHASM,M=COMPACT\n//DYNAM    EXEC  ARCHASM,M=DYNAM\n//EXPAND   EXEC  ARCHASM,M=EXPAND\n//EXPLODE  EXEC  ARCHASM,M=EXPLODE\n//RPARSE   EXEC  ARCHASM,M=RPARSE\n//LINK1    EXEC  PGM=IEWL,PARM='LIST,LET,XREF,RENT,REUS,REFR,MAP'\n//SYSPRINT DD    SYSOUT=*,HOLD=YES                                      SYSOUT\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(3,1))\n//SYSLIB   DD    DSN=CBT429.A.OBJ,DISP=SHR                              DSNAME\n//SYSLMOD  DD    DSN=CBT429.A.LOAD,DISP=SHR                             DSNAME\n//SYSLIN   DD    *\n INCLUDE SYSLIB(ARCHMAIN)\n INCLUDE SYSLIB(ARCHTABS)\n ENTRY ARCHMAIN\n NAME ARCHIVER(R)\n//LINK2    EXEC  PGM=IEWL,PARM='LIST,LET,XREF,MAP'\n//SYSPRINT DD    SYSOUT=*                                               SYSOUT\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(3,1))\n//SYSLIB   DD    DSN=CBT429.A.OBJ,DISP=SHR                              DSNAME\n//SYSLMOD  DD    DSN=CBT429.A.LOAD,DISP=SHR                             DSNAME\n//SYSLIN   DD    *\n INCLUDE SYSLIB(A370INIT)\n INCLUDE SYSLIB(ARCHPRSC)\n ENTRY ARCHINIT\n NAME ARCHINIT(R)\n INCLUDE SYSLIB(ARCHPARS)\n ENTRY ARCHPARS\n NAME ARCHPARS(R)\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$PARSE": {"ttr": 1030, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00_\\x00_\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 95, "newlines": 95, "modlines": 0, "user": "ARCHIVR"}, "text": "         MACRO\n&LBL     $PARSE &TYPE,                                                 -\n               &KEYWD=,                                                -\n               &RSV=0,                                                 -\n               &SUBLIST=0\n         GBLC  &N1,&N2,&N3\n         GBLB  &PB1,&PB2,&PB3\n         GBLA  &POS,&KWD\n         AIF   ('&TYPE' EQ 'DSECT').DSECT\n         AIF   ('&TYPE' EQ 'DEFINE').DEF00\n         AIF   ('&TYPE' EQ 'POS').POS00\n         AIF   ('&TYPE' EQ 'KEYWORD').KEY00\n         AIF   ('&TYPE' EQ 'END').END\n         MNOTE 8,'TYPE=&TYPE IS INVALID -- IGNORED'\n         MEXIT\n.DEF00   ANOP\n&N1      SETC  'PARS&SYSNDX'\n&N2      SETC  'PBRS&SYSNDX'\n&N3      SETC  'PCRS&SYSNDX'\n         AIF   ('&LBL' NE '').DEF01\n         MNOTE 8,'PARSE TABLE MUST HAVE A LABEL'\n         MEXIT\n.DEF01   ANOP\n&LBL     DS    0H\n&N1      DS    AL2                 NUMBER OF POSITIONAL PARMS\n&PB1     SETB  1\n&POS     SETA  0\n&KWD     SETA  0\n         SPACE 1\n         MEXIT\n.POS00   AIF   ('&KEYWD' EQ '').POS01\n         MNOTE 8,'KEYWORD INVALID ON A POSITIONAL PARAMETER'\n         MEXIT\n.POS01   AIF   (&PB1).POS02\n         MNOTE 8,'PARSE TABLE HEADER MISSING'\n         MEXIT\n.POS02   AIF   (NOT &PB2).POS03\n         MNOTE 8,'POSITIONAL PARMS MUST PRECEDE ALL KEYWORD PARMS'\n         MEXIT\n.POS03   ANOP\n&POS     SETA  &POS+1\n&LBL     DC    AL2(0)\n         DC    AL2(&RSV)\n         DC    AL4(0,&SUBLIST)\n         MEXIT\n.KEY00   AIF   (&PB2).KEY01\n&N2      DS    AL2                 COUNT OF KEYWORD PARMS\n&PB2     SETB  1\n.KEY01   ANOP\n&KWD     SETA  &KWD+1\n&LBL     DC    CL8&KEYWD\n         DC    AL2(0,&RSV)\n         DC    AL4(0,&SUBLIST)\n         MEXIT\n.END     ANOP\n&PB1     SETB  0\n&PB2     SETB  0\n         ORG   &N1                 POSITIONAL OPERAND HEADER\n         DC    AL2(&POS)           POSITIONAL OPERAND COUNT\n         AIF   (&KWD EQ 0).NOKW\n         ORG   &N2                 KEYWORD TABLE HEADER\n         DC    AL2(&KWD)           KEYWORD OPERAND COUNT\n         ORG\n         MEXIT\n.NOKW    ANOP\n         ORG\n         DC    AL2(&KWD)           KEYWORD OPERAND COUNT\n         MEXIT\n.DSECT   ANOP\n         SPACE 3\n*---------------------------------------------------------------------*\n*---     RPARSE SUBROUTINE'S PARAMETER LIST AND RETURN AREA        ---*\n*---------------------------------------------------------------------*\nPRSTAB   DSECT\nPRSPSCT  DS    H                   POSITIONAL OPERAND COUNT\n*              THE FOLLOWING 4 FIELDS ARE REPEATED PRSPSCT TIMES\nPRSPSLN  DS    H                   POSITIONAL OPERAND LENGTH\nPRSPSRS  DS    H                   RESERVED\nPRSPSLOC DS    AL4                 OPERAND LOCATION\nPRSPSSL  DS    AL4                 SUBLIST PARSE LIST OR ZEROS\nPRSPSBC  EQU   *-PRSPSLN           LENGTH OF EACH ENTRY\n*---------------------------------------------------------------------*\nPRSKWCT  DS    H                   KEYWORD OPERAND COUNT\n*              THE FOLLOWING FIELDS ARE REPEATED PRSKWCT TIMES\nPRSKWKW  DS    CL8                 KEYWORD IDENTIFIER\nPRSKWLN  DS    H                   VALUE LENGTH\nPRSKWRS  DS    H                   RESERVED\nPRSKWLOC DS    AL4                 START OF KEYWORD VALUE\nPRSKWSL  DS    AL4                 SUBLIST PARSE LIST, OR ZEROS\nPRSKWBC  EQU   *-PRSKWKW           LENGTH OF EACH ENTRY\n*---------------------------------------------------------------------*\n*---     END OF RPARSE PARAMETER LIST DESCRIPTION                  ---*\n*---------------------------------------------------------------------*\n         SPACE 3\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "##ARCHWK": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06\\x0c\\x00\\x00\\x01 !?\\x01 !?\\x14Y\\x00\\x96\\x00\\x96\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@'", "ispf": {"version": "06.12", "flags": 0, "createdate": "2020-07-31T00:00:00", "modifydate": "2020-07-31T14:59:00", "lines": 150, "newlines": 150, "modlines": 0, "user": "ARCHIVR"}, "text": "         TITLE 'MAIN ARCHIVER WORK/COMMUNICATIONS AREA'\n*---------------------------------------------------------------------*\n*---     INFORMATION PERTAINING TO RANGES IN QUALIFIER DATA IS     ---*\n*---     FOR PLANNING PURPOSES ONLY AND DOES NOT REFLECT           ---*\n*---     ARCHIVER'S ACTUAL CAPABILITIES AT THIS POINT.             ---*\n*---------------------------------------------------------------------*\nMAINWK   DSECT\nEYEBALL  DS    CL4                 EYE-CATCHER OF 'ARWK'\nMAINSIZE DS    A                   WORK AREA SIZE\nPRTDCB   DS    A                   ADDRESS OF SYSPRINT DCB\nPARSADDR DS    A                   ADDRESS OF (LOADED) ARCHPARS RTN\nTODVAL   DS    2D                  TOD CLOCK VALUE\nDATE     DS    CL8\nTIME     DS    CL8\nQ1       DS    CL10                ITEM NAME RANGE LOW BDY\nQ2       DS    CL10                ITEM GROUP RANGE LOW BDY\nQ3       DS    CL10                ITEM SUBGROUP RANGE LOW BDY\nQ4       DS    CL10                ITEM TYPE RANGE LOW BDY\nQ5       DS    XL4                 ITEM VERSION NUMBER\nQC1      DS    CL10                ITEM NAME -----------+ FOR COMPARE,\nQC2      DS    CL10                ITEM GROUP           | ALTER AND\nQC3      DS    CL10                ITEM SUBGROUP        | ALIAS\nQC4      DS    CL10                ITEM TYPE            | FUNCTIONS\nQC5      DS    XL4                 ITEM VERSION NUMBER -+\nHIGHMEM  DS    CL10                HIGH BDY OF MEMBER RANGE\nHIGHGRP  DS    CL10                HIGH BDY OF GROUP RANGE\nHIGHSGRP DS    CL10                HIGH BDY OF SUBGROUP RANGE\nHIGHTYP  DS    CL10                HIGH BDY OF TYPE RANGE\nFLAG     DS    0XL16               MISC. FLAGS\n*--------\n*--- FOR DESCRIPTIONS OF THE VARIOUS FLAG BITS HERE, SEE #ARCBITS\n*--------\n@BYTE1   #DSW\n@BYTE2   #DSW\n@BYTE3   #DSW\n@BYTE4   #DSW\n@BYTE5   #DSW\n@BYTE6   #DSW\n@BYTE7   #DSW\n@BYTE8   #DSW\n@BYTE9   #DSW\n@BYTEA   #DSW\n@BYTEB   #DSW\n@BYTEC   #DSW\n@BYTED   #DSW\n@BYTEE   #DSW\n@BYTEF   #DSW\n@BYTEG   #DSW\nVERB     DS    CL10                WHAT ACTION TO BE TAKEN\nEXPTPDD  DS    CL8                 IMPORT/EXPORT DATASET DDNAME\nIMPREC   DS    A                   POINTER TO LAST RECORD READ BY\n*                                  IMPORT GET-LOCATE FROM EXPTPDD\nNVSAMDD  DS    CL8                 NONVSAM DATASET DDNAME\nNVSDSORG DS    XL2\nCURKEY   DS    CL8                 CURRENT COMMDATA KEY VALUE\nSEPVAL   DS    CL8                 SEPARATOR TYPE FOR LOAD TO\n*                                  SEQUENTIAL DATASETS\nMCNT     DS    F                   TOTAL OF MEMBERS PROCESSED\nACNT     DS    F                   TOTAL ALIASES PROCESSED\nFCOUNT   DS    F                   RECORDS FOR THIS FUNCTION\nTCOUNT   DS    F                   RECORDS ARCHIVED THIS RUN\nPRTRTN   DS    A                   ADDRESS OF ARCHPRNT ROUTINE\nCTLIN    DS    A                   ADDRESS OF SYSIN DCB\nARCHWK   DS    A                   ADDRESS OF MAIN ARCHIVER WORK AREA\nLSTLIN#  DS    PL2\nLINECNT  DS    PL2\nPAGENO   DS    PL4\nTITLE1   DS    CL133\nTITLE2   DS    CL133\nTITLE3   DS    CL133\nLINE     DS    CL133\nVOLSER   DS    CL6                 VOLSER OF NONVSAM DATASET\nDEVT     DS    XL4                 DEVICE TYPE OF NONVSAM DATASET\nNVSRECFM DS    XL1                 NON-VSAM RECFM\nNVSBLKL  DS    AL2                 NON-VSAM BLKSIZE\nNVSLRECL DS    AL2                 NON-VSAM LRECL\nDWORK    DS    D                   CVD/CVB WORK AREA\nCHAIN    DS    A\nTOKEN    DS    A                   POOL ID FOR CPOOL SERVICES\nNAMEPOOL DS    A                   POOL ID FOR 'REAL' NAME CHAIN\nNAMECHN  DS    A                   'REAL' NAME CHAIN ROOT\nALIASPL  DS    A                   POOL ID FOR ALIAS NAME CHAIN\nALIASCHN DS    A                   ALIAS NAME CHAIN ROOT\nCOUNT    DS    F\nSYSPUNCH DS    A                   ADDRESS OF SYSPUNCH DCB, WHILE OPEN\nNDCBA    DS    A                   PRIMARY NON-VSAM DCB ADDRESS\nNDCBB    DS    A                   SECONDARY NON-VSAM DCB ADDRESS\n         READ  PDSDECB,SF,0,0,0,MF=L\nBPBUF1   DS    A\nBPBUF2   DS    A\nBLOCKWDS DS    2F                  SAVE VALUES FOR DEBLOCKER/BLOCKER\nBLDLAREA DS    20F                 BLDL AREA, ON FULLWORD BOUNDARY\nCMPWRKL  DS    F                   LENGTH OF COMPRESS/EXPAND WORK AREA\nCMPWRK   DS    A                   ADDR OF COMPRESS/EXPAND WORK AREA\n*---------------------------------------------------------------------\n*        THIS IS THE I/O SELECTION TABLE, CONTAINING THE BRANCH\n*        INSTRUCTIONS THAT SELECT THE I/O ROUTINES FOR NONVSAM\n*        DATASETS\n*\nIOSEP    DS    F                   SEQUENTIAL SEPARATOR ROUTINE\nENDSEP   DS    F                   SEQUENTIAL SEPARATOR ROUTINE\nBLOCK    DS    F                   BRANCH TO THE BLOCKER/DEBLOCKER\n*---------------------------------------------------------------------\nVSAM1DD  DS    CL8                 PRIMARY CLUSTER DDNAME\nACB1     DS    A                   ADDRESS OF VSAM1 ACB\nRPL1     DS    A                   ADDRESS OF VSAM1 RPL1\nRPL2     DS    A                   ADDRESS OF VSAM1 RPL2\nRPL3     DS    A                   ADDRESS OF VSAM1 RPL3\nVS1BUF1  DS    A                   ADDRESS OF VSAM'S BUFFER # 1\nVS1BUF2  DS    A                   ADDRESS OF VSAM'S BUFFER # 2\nVS1BUF3  DS    A                   ADDRESS OF VSAM'S BUFFER # 3\nVS1LIM   DS    A                   MAX. RECORD LENGTH\nVS1LEN1  DS    A                   BYTES USED IN THIS BUFFER\nVS1LEN2  DS    A                   BYTES USED IN THIS BUFFER\nVS1LEN3  DS    A                   BYTES USED IN THIS BUFFER\nVS1MODE  DS    CL8                 'INPUT', 'OUTPUT' OR ZEROS\nVS1DSN   DS    CL44                VSAM1 DATASET NAME\nVSAM2DD  DS    CL8                 SECONDARY CLUSTER DDNAME\nACB2     DS    A                   ADDRESS OF VSAM2 ACB\nRPL4     DS    A                   ADDRESS OF VSAM2 RPL1\nRPL5     DS    A                   ADDRESS OF VSAM2 RPL2\nRPL6     DS    A                   ADDRESS OF VSAM2 RPL3\nVS2BUF1  DS    A                   ADDRESS OF VSAM'S BUFFER # 1\nVS2BUF2  DS    A                   ADDRESS OF VSAM'S BUFFER # 2\nVS2BUF3  DS    A                   ADDRESS OF VSAM'S BUFFER # 3\nVS2LIM   DS    A                   MAX. RECORD LENGTH\nVS2LEN1  DS    A                   BYTES USED IN THIS BUFFER\nVS2LEN2  DS    A                   BYTES USED IN THIS BUFFER\nVS2LEN3  DS    A                   BYTES USED IN THIS BUFFER\nVS2MODE  DS    CL8                 'INPUT' OR ZEROS\nVS2DSN   DS    CL44                VSAM2 DATASET NAME\nTIOTA    DS    A                   ADDRESS OF THE TIOT\nDCBEA    DS    A                   DCB EXIT LIST STARTS  HERE\nDCBCPEXA DS    A                   DCB COMPLETION EXIT PTR, OR ZEROS\nDCBJFC   DS    A                   JFCB ADDRESS, OR ZEROS\nJFC      DS    22D                 JFCB INPUT AREA\nCALLIST  DS    10A                 MISC. CALL SCRATCH AREA\nBLKSAVE  DS    2F                  SAVE AREA FOR #ADDBLK RTN\nIOSAVE   DS    16F                 SAVE AREA FOR I/O RTNS\nSEPSAVE  DS    16F                 SAVE AREA FOR LOAD/SEPARATOR RTNS\nNOTELIST DS    F                   NOTELIST ADDRESS IN STORAGE\nNUMTTR   DS    F                   NUMBER OF TTR'S IN SAVE AREA\nSAVETTR  DS    F                   SAVE AREA FOR TTR STUFF FOR LMODS\nGENWK    DS    32D                 ANOTHER MISC. WORK AREA\nWKSYSIN  DS    CL8                 DEFAULT DDNAME SYSIN       @RP200703\nWKSYSPR  DS    CL8                 DEFAULT DDNAME SYSPRINT    @RP200703\nWKKEYW   DS    CL8                 KEYWORD FOR ARCHPPRSC      @RP200703\nWKWORKA  DS    CL255               WORKAREA FOR ARCHPRSC      @RP200703\nWKRC     DS    C                   RETURN CODE                  @RP2008\nENDMAIN  DS    0D\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#ADDBLK": {"ttr": 1037, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00[\\x00[\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 91, "newlines": 91, "modlines": 0, "user": "ARCHIVR"}, "text": "         MACRO\n&LBL     #ADDBLK &BUFFER=,&RECORD=,&LENGTH=,&ERR=,&RTN=,&LAST=NO\n.*\n.* BUFFER IS A SINGLE DIGIT, EITHER 1 OR 2, DENOTINE VS1BUF1 OR\n.*        VS1BUF2\n.*\n.* RECORD IS THE ADDRESS OF THE PIECE TO BE ADDED, NOT INCLUDING THE\n.*        ARCHIVER'S SPECIAL 3-BYTE LENGTH FIELD\n.*\n.* LENGTH IS THE LENGTH OF THE PIECE TO BE ADDED, AGAIN IGNORING THE\n.*        ARCHIVER'S SPECIAL 3-BYTE LENGTH FIELD\n.*\n.* ERR IS A LOCATION TO BRANCH TO IF THE PIECE CANNOT BE ADDED TO THE\n.*     CURRENT CLUSTER.\n.*\n.* RTN IS THE ROUTINE THAT WILL DO ALL VSAM 'PUT' ACTIVITY\n.*\n.* LAST=YES OR NO, TO DENOTE THE NEED FOR A 'PUT' WITHOUT ADDING A\n.*       PIECE TO THE BUFFER.\n.*\n.* NOTE EXTENSIVE USE OF THE #LR MACRO TO LOAD OPERANDS INTO REGS.\n.*\n         LCLC  &A,&B,&C,&D,&E,&F,&G,&H,&I,&BUF,&LEN\n&A       SETC  '&LBL'\n&B       SETC  '#VSA&SYSNDX'\n&C       SETC  '#VSB&SYSNDX'\n         AIF   ('&A' EQ '').NOLBL\n&LBL     DS    0H\n.NOLBL   ANOP\n         AIF   ('&BUFFER' NE '1').B2\n&BUF     SETC  'VS1BUF1'\n&LEN     SETC  'VS1LEN1'\n         AGO   .C\n.B2      AIF   ('&BUFFER' EQ '2').B3\n         MNOTE 8,'BUFFER=&BUFFER IS INVALID. BUFFER=1 ASSUMED.'\n&BUF     SETC  'VS1BUF1'\n&LEN     SETC  'VS1LEN1'\n         AGO   .C\n.B3      ANOP\n&BUF     SETC  'VS1BUF2'\n&LEN     SETC  'VS1LEN2'\n.C       ANOP\n         AIF   ('&LAST' EQ 'YES' OR '&LAST' EQ 'Y').LAST\n         #LR   R0,&RECORD          LOAD RECORD POINTER\n         #LR   R1,&LENGTH            AND LENGTH\n         ICM   R1,7,0(R1)\n         ICM   R1,8,=X'00'\n         LA    R15,3(,R1)          ACCOUNT FOR LENGTH FIELD\n         LA    R14,RECKLEN(,R15)   ACCOUNT FOR VSAM KEY\n         C     R14,VS1LIM          CAN IT FIT ??\n         BH    &ERR                NOPE; ERROR ---\n         LR    R14,R15             COPY THAT LENGTH\n         A     R14,&LEN            ADD CURRENT LENGTH\n         C     R14,VS1LIM          WILL THIS FIT ??\n         BNH   &B                  YES; JUST ADD IT IN\n         STM   R0,R1,BLKSAVE       SAVE THAT RECORD STUFF\n         L     R1,&BUF             POINT TO THE BUFFER\n         L     R0,&LEN             AND LOAD ITS LENGTH\n         BAL   R14,&RTN            GO OUTPUT THE RECORD\n         L     R1,&BUF             LOAD THE BUFFER ADDRESS\n         ICM   R15,15,RECSEQ#-REC(R1) INSERT THE SEQUENCE NUMBER\n         LA    R15,1(,R15)         ADD ONE\n         STCM  R15,15,RECSEQ#-REC(R1) SAVE UPDATED VALUE\n         LA    R0,RECKLEN          LOAD LENGTH OF NAKED KEY\n         ST    R0,&LEN             AND SAVE IT\n         LM    R0,R1,BLKSAVE       RELOAD THAT INPUT STUFF\n&B       DS    0H\n         L     R14,&LEN            LOAD CURRENT RECORD LENGTH\n         LA    R15,3(R1,R14)       ADD THIS ONE\n         ST    R15,&LEN            SAVE UPDATED VALUE\n         A     R14,&BUF            POINT INTO THE BUFFER\n         STCM  R1,7,0(R14)         STORE LENGTH BYTES\n         LA    R14,3(,R14)         POINT TO DATA AREA\n         LR    R15,R1              COPY THE LENGTH\n         MVCL  R14,R0              COPY RECORD TO BUFFER\n         MEXIT\n.LAST    ANOP\n         LA    R0,RECKLEN          LOAD THE KEY LENGTH\n         C     R0,&LEN             ANYTHING BUT A KEY ??\n         BE    &C                  NOPE; ALL DONE\n         L     R1,&BUF             LOAD BUFFER ADDRESS\n         L     R0,&LEN             AND LENGTH\n         BAL   R14,&RTN            OUTPUT THE LAST RECORD\n         L     R1,&BUF             LOAD THE BUFFER ADDRESS\n         ICM   R15,15,RECSEQ#-REC(R1) INSERT THE SEQUENCE NUMBER\n         LA    R15,1(,R15)         ADD ONE\n         STCM  R15,15,RECSEQ#-REC(R1) SAVE UPDATED VALUE\n         LA    R0,RECKLEN          LOAD LENGTH OF NAKED KEY\n         ST    R0,&LEN             AND SAVE IT\n&C       DS    0H\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#ARCBITS": {"ttr": 1040, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00l\\x00l\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 108, "newlines": 108, "modlines": 0, "user": "ARCHIVR"}, "text": "@BYTE1   #DSW  GENM,                MEMBER NAME IS GENERIC             X\n               GENG,                GROUP IS GENERIC                   X\n               GENSG,               SUBGROUP IS GENERIC                X\n               GENT,                TYPE IS GENERIC                    X\n               VRS,                 VERSION SPECIFIED                  X\n               NVDYN,               NONVSAM IS DYNAMIC                 X\n               V1DYN,               VSAM1DD IS DYNAMIC                 X\n               V2DYN,               VSAM2DD IS DYNAMIC                 X\n               TYPE=NODATA\n@BYTE2   #DSW  SUPM,                MEMBER NAME SUPPLIED               X\n               SUPG,                GROUP NAME SUPPLIED                X\n               SUPSG,               SUBGROUP NAME SUPPLIED             X\n               SUPTYP,              TYPE NAME SUPPLIED                 X\n               SAMECL,              VSAM1 IS ALSO VSAM2                X\n               EOT,                 END OF TAPE REACHED (DIRECT LOAD)  X\n               EXTDYN,              EXPORT/IMPORT IS DYNAMIC           X\n               LOADING,             CURRENT STATUS (DIRECT LOAD)       X\n               TYPE=NODATA\n@BYTE3   #DSW  REPL,                REPLACE DUPS. DURING RELOAD        X\n               GREPL,               REPLACE= SUPPLIED                  X\n               RETA,                RETAIN ALIAS INFORMATION           X\n               GRETA,               ALIAS= SUPPLIED                    X\n               SHHDR,               PROCESS HEADERS                    X\n               GSHHDR,              HEADER= SUPPLIED                   X\n               SHHEX,               LISTING IS IN HEX                  X\n               GSHHEX,              HEX= SUPPLIED                      X\n               TYPE=NODATA\n@BYTE4   #DSW  SHITEM,              PROCESS ITEM DATA                  X\n               GSHITEM,             DATA= SUPPLIED                     X\n               LKED,                PROCESS 'LKEDCTL' RECORDS          X\n               GLKED,               LKEDCTL= SUPPLIED                  X\n               ULMODS,              RECFM=U MEANS LMODS                X\n               GULMODS,             ULMODS= SUPPLIED                   X\n               LMODS,               NONVSAM DATASET IS LMODS           X\n               EODIN,               END OF DATA ON SYSIN               X\n               TYPE=NODATA\n@BYTE5   #DSW  COMK,                COMMDATA KEY IS SPECIFIED          X\n               PRCB,                PROCESS BACK-LEVEL ITEMS           X\n               GPRCB,               BACK= SUPPLIED                     X\n               PRCCM,               PROCESS COMMDATA                   X\n               GPRCCM,              NOTE= SUPPLIED                     X\n               NVPAN,               NONVSAM IS A PANLIB                X\n               GNVPAN,              PANLIB= SUPPLIED                   X\n               EXPL,                EXPLODABLE MEMBER ??               X\n               TYPE=NODATA\n@BYTE6   #DSW  GTCHR,              EXPANDER IS FETCHING COUNT BYTE     X\n               GTCNT,              EXPANDER FETCHING CHAR. TO REPL.    X\n               EXPDYN,             EXPORT/IMPORT DATASET WAS DYNALLOC  X\n               GTDATA,             IMPREC POINTS TO NON-HEADER RCD     X\n               LDARCHA,            CHECK ARCHIVE ALIASES IN LOAD/LOADT X\n               TYPE=NODATA\n@BYTE7   #DSW  NGENM,               MEMBER NAME(2) IS GENERIC          X\n               NGENG,               GROUP(2) IS GENERIC                X\n               NGENSG,              SUBGROUP(2) IS GENERIC             X\n               NGENT,               TYPE(2) IS GENERIC                 X\n               RNGM,                MEMBER IS A RANGE                  X\n               RNGG,                GROUP IS A RANGE                   X\n               RNGSG,               SUBGROUP IS A RANGE                X\n               RNGT,                TYPE IS A RANGE                    X\n               TYPE=NODATA\n@BYTE8   #DSW  IOGOING,            WE HAVE A BPAM READ/WRITE ACTIVE    X\n               BUFUSED,            CURRENT BUFFER HAS SOMETHING IN IT  X\n               TRUNC,              PURGE BUFFERS AT DS/MEMBER END      X\n               NVSPS,              NONVSAM DATASET IS SEQUENTIAL       X\n               NVSPO,              NONVSAM DATASET IS PARTITIONED      X\n               NOEXP,              BYPASS EXPANDER DURING LOAD         X\n               CONV,               FORMAT CONVERSION REQUESTED         X\n               PUNCH,              SYSPUNCH DD STATEMENT IS PRESENT    X\n               TYPE=NODATA\n*---------------------------------------------------------------------*\n*---     @BYTE9 IS USED BY THE COMPARE FUNCTION EXCLUSIVELY.      ----*\n*---------------------------------------------------------------------*\n@BYTE9   #DSW  SAMENAME,           COMPTO MEMBER SAME AS ITEM MEMBER   X\n               SAMEGRP,            COMPTO GROUP SAME AS ITEM GROUP     X\n               SAMESGRP,           COMPTO SUBGRP SAME AS ITEM SUBGRP   X\n               SAMETYPE,           COMPTO TYPE SAME AS ITEM TYPE       X\n               LISTALLC,           LIST ALL COMPARISONS, GOOD OR BAD   X\n               AUTOALIS,           AUTOMATICALLY DELETE/ASSIGN ALIAS   X\n               TYPE=NODATA\n@BYTEA   #DSW  CMPHDRF,            COMPARE OF HEADER RECORDS FAILED    X\n               CMPNTDF,            COMPARE OF NOTE DATA FAILED         X\n               CMPDATF,            COMPARE OF ITEM DATA FAILED         X\n               CMPDETF,            LIST DETAILS OF HEADER FAILURE      X\n               CMPABTF,            ABORT COMPARE AFTER THIS RECORD     X\n               CMPSRCF,            NO MATCHING ITEM FOUND ON VSAM2     X\n               CMPSHRTL,           SHORT-FORM COMPARE LISTING          X\n               TYPE=NODATA         RESERVED FOR FUTURE EXPANSION\n@BYTEB   #DSW  TYPE=NODATA         RESERVED FOR FUTURE EXPANSION\n@BYTEC   #DSW  TYPE=NODATA         RESERVED FOR FUTURE EXPANSION\n@BYTED   #DSW  TYPE=NODATA         RESERVED FOR FUTURE EXPANSION\n@BYTEE   #DSW  TYPE=NODATA         RESERVED FOR FUTURE EXPANSION\n@BYTEF   #DSW  TYPE=NODATA         RESERVED FOR FUTURE EXPANSION\n@BYTEG   #DSW  TYPE=NODATA         RESERVED FOR FUTURE EXPANSION\n*---------------------------------------------------------------------*\n*---     FLAG FIELDS IN HEADER/ALIAS RECORD                        ---*\n*---------------------------------------------------------------------*\n@RSRFLG1 #DSW  TYPE=NODATA         ARCHIVER VERSION NUMBER\n@RSRFLG2 #DSW  TYPE=NODATA         LEVEL WITHIN VERSION\n@RSRFLG3 #DSW  TYPE=NODATA         MISC. RESERVED FLAGS\n@RSRFLG4 #DSW  RSRHALS,            THIS ITEM HAS ALIASES               X\n               RSRALIAS,           THIS IS AN ALIAS ENTRY              X\n               TYPE=NODATA\n*---------------------------------------------------------------------*\n*---     THE FOLLOWING CONSTANT SETS THE MINIMUM VSAM RECORD SIZE  ---*\n*---------------------------------------------------------------------*\nRECSIZE  EQU   12000               MINIMUM ARCHIVE RECORD LENGTH\n* DON'T FORGET TO CHANGE THE VALUE IN THE MESSAGE IN ARCHMSGS IF\n* YOU CHANGE THIS VALUE!!!!!!!!\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#DSW": {"ttr": 1283, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00:\\x00:\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 58, "newlines": 58, "modlines": 0, "user": "ARCHIVR"}, "text": "         MACRO\n&LABEL   #DSW  &B80,&B40,&B20,&B10,&B08,&B04,&B02,&B01,&TYPE=,&INIT=\n.*\n.*       DATA SWITCH GENERATION MACRO\n.*\n         GBLC  &DSWBYTE(80)        DATA SWITCH BYTE NAME ARRAY.\n         GBLC  &DSWBIT(640)        DATA SWITCH BIT NAME ARRAY.\n         GBLA  &DSWBCNT            DATA SWITCH BIT COUNT\n         LCLA  &X\n         LCLC  &C\n.DSW5    AIF   (&X EQ 80).DSWERR\n&X       SETA  &X+1\n         AIF   ('&DSWBYTE(&X)' NE '').DSW5\n&C       SETC  'DSW&SYSNDX.A'\n         AIF   (K'&LABEL EQ 0).NOLABEL\n&C       SETC  '&LABEL'\n.NOLABEL ANOP\n         AIF   ('&TYPE' EQ 'NODATA').NODATA\n         AIF   (K'&INIT EQ 0).NOINIT\n&C       DC    &INIT               .INITIALIZED SWITCH VARIABLE.\n&DSWBCNT SETA  &DSWBCNT+8\n         AGO   .ENDINIT\n.NOINIT  ANOP\n&C       DS    B                   .SWITCH VARIABLE.\n&DSWBCNT SETA  &DSWBCNT+8\n.ENDINIT ANOP\n.NODATA  ANOP\n&DSWBYTE(&X) SETC '&C'             SAVE SWITCH VARIABLE NAME.\n&X       SETA  (&X-1)*8            GET CORRESPONDING BIT SWITCH GROUP.\n         AIF   ('&B80' EQ '').DSW10\n&B80     EQU   B'10000000'\n&DSWBIT(&X+1) SETC '&B80'\n.DSW10   AIF   ('&B40' EQ '').DSW20\n&B40     EQU   B'01000000'\n&DSWBIT(&X+2) SETC '&B40'\n.DSW20   AIF   ('&B20' EQ '').DSW30\n&B20     EQU   B'00100000'\n&DSWBIT(&X+3) SETC '&B20'\n.DSW30   AIF   ('&B10' EQ '').DSW40\n&B10     EQU   B'00010000'\n&DSWBIT(&X+4) SETC '&B10'\n.DSW40   AIF   ('&B08' EQ '').DSW50\n&B08     EQU   B'00001000'\n&DSWBIT(&X+5) SETC '&B08'\n.DSW50   AIF   ('&B04' EQ '').DSW60\n&B04     EQU   B'00000100'\n&DSWBIT(&X+6) SETC '&B04'\n.DSW60   AIF   ('&B02' EQ '').DSW70\n&B02     EQU   B'00000010'\n&DSWBIT(&X+7) SETC '&B02'\n.DSW70   AIF   ('&B01' EQ '').DSW80\n&B01     EQU   B'00000001'\n&DSWBIT(&X+8) SETC '&B01'\n.DSW80   MEXIT\n.*\n.*\n.DSWERR  MNOTE 0,'** ERROR ** MAX NUMBER OF SWITCHES EXCEEDED'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#ERR": {"ttr": 1285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06\\x0c\\x00\\x00\\x01 !?\\x01 !?\\x14Y\\x00\\x10\\x00\\x10\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@'", "ispf": {"version": "06.12", "flags": 0, "createdate": "2020-07-31T00:00:00", "modifydate": "2020-07-31T14:59:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "ARCHIVR"}, "text": "         MACRO --- PUT FOR ARCHIVER ---\n&LABEL   #ERR  &MSG=0\n         LCLC  &L\n&L       SETC  '&LABEL'\n         AIF   ('&L' EQ '').NOLBL\n&LABEL   DS    0H                  DEFINE THE LABEL\n.NOLBL   ANOP\n         LA    R0,&MSG             MESSAGE NUMBER, IF ANY\n         BCTR  R0,R0               DECREMENT BY ONE\n         MH    R0,=H'134'          TIMES MESSAGE LENGTH + RC    @RP2008\n         L     R1,=V(ARCHMSGS)     LOAD MESSAGE CSECT ADDRESS\n         AR    R1,R0               POINT TO SPECIFIC MESSAGE\n         OC    WKRC,133(R1)        SET RETURN CODE OF MESSAGE   @RP2008\n         L     R15,=V(ARCHPRNT)    POINT TO PRINT ROUTINE\n         BALR  R14,R15             AND CALL IT ---\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#ERROR": {"ttr": 1287, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06\\x0c\\x00\\x00\\x01 !?\\x01 !?\\x14Y\\x00\\x16\\x00\\x16\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@'", "ispf": {"version": "06.12", "flags": 0, "createdate": "2020-07-31T00:00:00", "modifydate": "2020-07-31T14:59:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "ARCHIVR"}, "text": "         MACRO --- PUT FOR ARCHIVER ---\n&LABEL   #ERROR  &MSG=0\n         LCLA  &A,&B\n         LCLC  &L\n&L       SETC  '&LABEL'\n         AIF   ('&L' EQ '').NOLBL\n&LABEL   DS    0H                  DEFINE THE LABEL\n.NOLBL   ANOP\n&A       SETA  1\n.L       ANOP\n         AIF   ('&SYSLIST(&A)' EQ '').B\n         LA    R0,&SYSLIST(&A)     MESSAGE NUMBER, IF ANY\n         BCTR  R0,R0               DECREMENT BY ONE\n         MH    R0,=H'134'          TIMES MESSAGE LENGTH + RC    @RP2008\n         L     R1,=V(ARCHMSGS)     LOAD MESSAGE CSECT ADDRESS\n         AR    R1,R0               POINT TO SPECIFIC MESSAGE\n         OC    WKRC,133(R1)        SET RETURN CODE FROM MSG     @RP2008\n         #PUT  0(,R1)\n.B       ANOP\n&A       SETA  &A+1\n         AIF   (&A LE N'&SYSLIST).L\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#FINDSW": {"ttr": 1289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00\\x17\\x00\\x17\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "ARCHIVR"}, "text": "         MACRO\n         #FINDSW &A\n         GBLB  &ERROR              ERROR FLAG.\n         GBLC  &DSWBYTE(80)        DATA SWITCH BYTE NAME ARRAY.\n         GBLC  &DSWBIT(640)        DATA SWITCH BIT NAME ARRAY.\n         GBLC  &SWBYTE             SWITCH BYTE NAME.\n         GBLA  &DSWBCNT            COUNT OF DSW BITS\n         LCLA  &X,&N               COUNTERS.\n         LCLC  &BIT                ISOLATED BIT NAMES.\n&ERROR   SETB  0                   INIT RETURN CODE TO NORMAL RETURN.\n&BIT     SETC  '&A'                FIRST BIT NAME.\n&X       SETA  1\n.SR2     ANOP\n         AIF   ('&DSWBIT(&X)' EQ '&BIT').SETIT\n&X       SETA  &X+1\n         AIF   (&X LE 640).SR2\n         MNOTE 8,'SWITCH BIT &A NOT DEFINED'\n&ERROR   SETB  1\n         MEXIT\n.SETIT   ANOP\n&N       SETA  (&X/8)+1\n&SWBYTE  SETC  '&DSWBYTE(&N)'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#FORMAT": {"ttr": 1291, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00%\\x00%\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 37, "newlines": 37, "modlines": 0, "user": "ARCHIVR"}, "text": "         MACRO\n&LBL     #FORMAT &SRC,&MSG,&TXT,&OUT=LINE+1,&CLEAR=YES,&TIME=NO\n         LCLC  &A,&LL\n&LL      SETC  '&LBL'\n         SPACE 1\n         AIF   ('&LL' EQ '').A\n&LL      DS    0H\n.A       AIF   ('&CLEAR' NE 'YES').B\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n.B       ANOP\n&A       SETC  '&SRC'\n         AIF   ('&A' EQ '').ERR1   &SRC MISSING - REQUIRED\n         LA    R0,&A               LOAD RECORD KEY ADDRESS\n&A       SETC  '&TXT'              CHECK FOR MESSAGE TEXT\n         AIF   ('&A' EQ '').NOTEXT\n         LA    R1,&A               LOAD TEXT ADDRESS\n         AGO   .CALL\n.NOTEXT  ANOP\n         LA    R1,0                NO MESSAGE TEXT FOLLOWS\n.CALL    ANOP\n&A       SETC  '&MSG'              CHECK THE MESSAGE NUMBER\n         AIF   ('&A' NE '').MSG\n&A       SETC  ''' '''\n.MSG     ANOP\n         AIF   ('&TIME' EQ 'NO').NOTIME\n         O     R1,=X'80000000'     SET 'TIME REQUIRED' FLAG\n.NOTIME  ANOP\n         L     R15,=V(ARCHFORM)    LOAD FORMATTER ADDRESS\n         BALR  R14,R15             AND CALL IT\n         DC    CL8&A               MESSAGE NUMBER\n         DC    S(&OUT)             OUTPUT POINTER\n         SPACE 1\n         MEXIT\n.ERR1    ANOP\n         MNOTE 8,'REQUIRED SRC OPERAND IS MISSING.'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#FREE": {"ttr": 1293, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00/\\x00/\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 47, "newlines": 47, "modlines": 0, "user": "ARCHIVR"}, "text": "         MACRO     -- FREE BUFFER POOL, IF IT EXISTS --\n&LABEL   #FREE\n.**********************************************************************\n.*       THIS LITTLE MACRO GENERATES THE CODE TO CHECK EACH OF A LIST *\n.*       LIST OF DCB'S AND FREE THE BUFFER POOLS, IF ANY.             *\n.*       IF THE BUFFER POOL EXISTS, A 'FREEPOOL MACRO IS ISSUED       *\n.*       TO RELEASE THE ALLOCATED BUFFERS.  IF NOT, THE FREEPOOL      *\n.*       MACRO IS SKIPPED.                                            *\n.*                                                                    *\n.*       *******  WARNING  *******  DO NOT ISSUE THIS MACRO ON AN     *\n.*       OPEN DCB. THE RESULTS ARE UNPREDICTABLE.                     *\n.**********************************************************************\n.*       RICK FOCHTMAN, IHC. CCC., 18 NOV 74                          *\n.**********************************************************************\n         GBLA  &FREC\n         LCLC  &DCB,&LBL\n         LCLA  &KNT,&LP1\n         AIF   ('&LABEL' EQ '').ISNA\n         SPACE 1\n&LABEL   DS    0H            DEFINE THE LABEL\n.ISNA    ANOP\n&LP1     SETA  1\n&KNT     SETA  N'&SYSLIST\n         AIF   (&KNT EQ 0).ERRA\n.ISNB    AIF   (&LP1 GT &KNT).MEXIT\n&DCB     SETC  '&SYSLIST(&LP1)'\n         AIF   ('&DCB' NE '').ISNC\n         MNOTE 8,'DUMMY/NULL OPERANDS NOT ALLOWED. IGNORED'\n&LP1     SETA  &LP1+1\n         AGO   .ISNB\n.ISNC    ANOP\n&FREC    SETA  &FREC+1\n&LBL     SETC  '$FRE&FREC'\n         SPACE 1\n         #LR   1,&DCB        POINT OUT THE DCB\n         TM    23(1),1       Q/ BUFCB ADDR INVALID\n         BO    &LBL          NO BUFFER POOL FOR THIS DCB\n         FREEPOOL  (1)       HAS POOL, SO FREE IT\n&LBL     DS    0H\n&LP1     SETA  &LP1+1        BUMP THE LOOP COUNTER\n         AGO   .ISNB         AND LOOP - - -\n.MEXIT   ANOP\n         SPACE 1\n         MEXIT\n.ERRA    ANOP\n         MNOTE 4,'NO OPERANDS. NO CODE GENERATED'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#IF": {"ttr": 1295, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00\\x1f\\x00\\x1f\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "ARCHIVR"}, "text": "         MACRO\n&NAME    #IF   &BIT,&COND,&GOTO\n         GBLB  &ERROR              ERROR FLAG.\n         GBLC  &DSWBYTE(80)        DATA SWITCH BYTE NAME ARRAY.\n         GBLC  &DSWBIT(640)        DATA SWITCH BIT NAME ARRAY.\n         GBLC  &SWBYTE             SWITCH BYTE NAME.\n         GBLA  &DSWBCNT            SWITCH BIT COUNT\n.*\n         LCLA  &X,&N               COUNTERS.\n         LCLC  &OPC,&LBL\n         AIF   ('&COND' EQ 'ON').IFON\n         AIF   ('&COND' EQ 'OFF').IFOFF\n         MNOTE 8,'WHAT CONDITION TO TEST FOR ? '\n         MEXIT\n.IFON    ANOP\n&OPC     SETC  'BO'\n         AGO   .GETBIT\n.IFOFF   ANOP\n&OPC     SETC  'BNO'\n.GETBIT  #FINDSW &BIT\n         AIF   (&ERROR).NOTEST\n&LBL     SETC  '&NAME'\n         AIF   ('&LBL' EQ '').NOLBL\n&NAME    DS    0H\n.NOLBL   ANOP\n         TM    &SWBYTE,&BIT        TEST THE FLAG BIT\n         &OPC  &GOTO               AND BRANCH ---\n         MEXIT\n.NOTEST  ANOP\n         MNOTE 8,'BIT &BIT IS NOT DEFINED.'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#LR": {"ttr": 1297, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00\\xdf\\x00\\xdf\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 223, "newlines": 223, "modlines": 0, "user": "ARCHIVR"}, "text": "         MACRO\n&L       #LR   &A,&B\n.*********************************************************************\n.*       #LR\n.*\n.*       A   --DESTINATION REGISTER.\n.*       B   --INPUT VALUE.\n.*\n.*             THE INPUT VALUE MAY HAVE TWO FORMATS:\n.*\n.*       1)    IT CAN BE SPECIFIED AS A SIGNED NUMBER, CHARACTERS\n.*             ENCLOSED IN QUOTES, A SYMBOL, OR AN EXPRESSION.\n.*\n.*       2)    THE 2ND FORMATS ASSUMES THE USER IS LOADING SOMETHING\n.*             INTO A REGISTER.  THE SUPPORTED OPERATIONS ARE:\n.*             IC, ICM, L, LH, LA, LR.  THEY ARE CODED AS THE DESIRED\n.*             CODE FOLLOWED BY A SEMI-COLON(:) AND THEN THE VALUE.\n.*             IN THE CASE OF THE ICM, THE 2ND FIELD IS THE MASK;\n.*             FOLLOWED BY A SEMI-COLON AND THE VALUE EXPRESSION.\n.*             EG.  LA:3    IC:JUNK(1)     ICM:B'0101':FIELD     LR:8\n.*\n.*********************************************************************\n         LCLA  &I                  INDEX PTR.\n         LCLA  &K                  COUNT 1.\n         LCLA  &K2                 COUNT 2.\n         LCLA  &K3                 COUNT 3.\n         LCLA  &K4                 COUNTER 4.\n         LCLA  &N                  STRING COUNT.\n         LCLB  &ADDR               ADDRESS VALUE FLAG.\n         LCLB  &EXPR               EXPRESSION INDICATOR.\n         LCLB  &QUIT               SCANNING SWITCH.\n         LCLB  &SIGN               NUMERIC SIGN FLAG.\n         LCLC  &D1,&D2             LITERAL DELIMETERS.\n         LCLC  &M(8)               MASK/INDEX STRING.\n         LCLC  &OP                 OPERATION CODE.\n         LCLC  &S(8)               SOURCE OPERAND.\n         LCLC  &R                  REGISTER SYMBOL.\n         LCLC  &TYPE               FULLWORD LITERAL TYPE(A OR F).\n&D1      SETC  ''''                DEFAULT DELIMETERS ARE QUOTES(').\n&D2      SETC  ''''                +\n&OP      SETC  'LA'                DEFAULT OPERATION CODE.\n&TYPE    SETC  'F'                 SET DEFAULT LITERAL TYPE.\n         AIF   (T'&A NE 'O').OKA\n         MNOTE 8,'LRM100E DESTINATION REGISTER NOT SPECIFIED'\n         MEXIT\n.OKA     ANOP\n         AIF   (T'&B NE 'O').OKB\n         MNOTE 8,'LRM110E VALUE/STRING/REGISTER NOT SPECIFIED'\n         MEXIT\n.OKB     ANOP\n&N       SETA  K'&B                GET NO. OF CHARS. IN STRING.\n         AIF   ('&B'(1,1) EQ '''').STR\n         AIF   ('&B'(1,1) EQ '(').REG\n&I       SETA  1                   INITIALIZE INDEX.\n         AIF   ('&B'(1,1) EQ '+').PSGN\n         AIF   ('&B'(1,1) EQ '-').MSGN\n.CKLP    ANOP\n         AIF   (&I GT &N).ENDSCN\n         AIF   ('&B'(&I,1) EQ ':').CODE\n         AIF   ('&B'(&I,1) GE '0').NXT\n         AIF   ('&B'(&I,1) EQ ',' OR '&B'(&I,1) EQ '''').ADR\n         AIF   ('&B'(&I,1) EQ '=').CKEQ\n         AIF   ('&B'(&I,1) EQ '+' OR '&B'(&I,1) EQ '-' OR              X\n               '&B'(&I,1) EQ '*' OR '&B'(&I,1) EQ '/' OR               X\n               '&B'(&I,1) EQ '(' OR '&B'(&I,1) EQ ')').EXPR\n         AIF   ('&B'(&I,1) GE 'A').ADR\n         MNOTE 8,'LRM120E INVALID CHARACTER IN EXPRESSION'\n         MEXIT\n.NXT     ANOP\n&I       SETA  &I+1                INCREMENT TO NEXT CHARACTER.\n         AGO   .CKLP\n.PSGN    ANOP\n&SIGN    SETB  0                   FLAG SIGN AS POSITIVE.\n         AGO   .NXT\n.MSGN    ANOP\n&SIGN    SETB  1                   FLAG SIGN AS NEGATIVE.\n         AGO   .NXT\n.ADR     ANOP\n&ADDR    SETB  1                   FLAG EXPRESSION AS ADDRESS EVAL.\n         AGO   .NXT\n.EXPR    ANOP\n&EXPR    SETB  1                   FLAG AS EXPRESSION.\n         AGO   .NXT\n.CKEQ    ANOP\n         AIF   ('&B'(&I,3) EQ '=A(').CKEQL\n         AIF   ('&B'(&I,3) EQ '=F''').CKEQL\n         AIF   ('&B'(&I,3) EQ '=V''').CKEQL\n         AIF   ('&B'(&I,3) EQ '=H''').CKEQLH\n         AIF   ('&B'(&I,3) EQ '=X''').CKEQIC\n         AGO   .VALA\n.CKEQL   ANOP\n&OP      SETC  'L'                 USE LOAD INSTRUCTION.\n         AGO   .VALA\n.CKEQLH  ANOP\n&OP      SETC  'LH'                USE LOAD HALF INSTRUCTION.\n         AGO   .VALA\n.CKEQIC  ANOP\n         SLR   &A,&A               CLEAR REGISTER FOR LOAD.\n&OP      SETC  'IC'                USE INSERT CHARACTER INSTR.\n         AGO   .VALA\n.ENDSCN  ANOP\n         AIF   ( NOT (&ADDR AND &SIGN)).CKLA\n         MNOTE 8,'LRM130E NEGATIVE NO. AS DISPLACEMENT'\n         MEXIT\n.CKLA    ANOP\n         AIF   (&ADDR).VALA\n         AIF   (&SIGN).CKLH\n         AIF   (&EXPR).VAL\n         AIF   (&B EQ 0).CLREG\n         AIF   (&B GT 0 AND &B LT 4096).VALA\n         AIF   (&B LT 32768).CKLH\n         AGO   .VAL\n.CKLH    ANOP\n         AIF   (NOT &SIGN).VALH\n&R       SETC  '&B'(2,&N-1)        REDUCE SIGNED NUMBER TO UNSIGNED.\n         AIF   ('&R' LT '32768').VALH CK LOWER BOUND FOR HALFWORDS.\n.VAL     ANOP\n         AIF   (NOT &EXPR).VAL10\n&TYPE    SETC  'A'                 ADDRESS LITERAL.\n&D1      SETC  '('                 RESET DELIMETERS FOR A-CON.\n&D2      SETC  ')'                 +\n.VAL10   ANOP\n&L       L     &A,=&TYPE&D1&B&D2   LOAD FULL WORD VALUE.\n         MEXIT\n.VALH    ANOP\n&L       LH    &A,=H'&B'           LOAD HALF WORD VALUE.\n         MEXIT\n.VALA    ANOP\n&L       &OP   &A,&B               LOAD VALUE OF EXPRESSION.\n         MEXIT\n.CLREG   ANOP\n&L       SLR   &A,&A               VALUE = 0.\n         MEXIT\n.REG     ANOP\n&N       SETA  K'&B-2              COMPUTE NO. OF CHARS. IN STR.\n&R       SETC  '&B'(2,&N)          MOVE REGISTER SYMBOL TO VARIABLE.\n         AIF   ('&R' EQ '&A').EXIT\n&L       LR    &A,&R               MOVE REGISTER TO DESTINATION.\n         MEXIT\n.STR     ANOP\n&L       LA    &A,=C&B             LOAD ADDRESS OF  LITERAL.\n         MEXIT\n.CODE    ANOP\n&K       SETA  &I-1                COMPUTE SIZE OF CODE.\n&K2      SETA  &N-&K-1             COMPUTE SIZE OF VALUE.\n         AIF   (&K2 GT 0).CD10\n         MNOTE 8,'LRM140E MISSING SOURCE OPERAND'\n         MEXIT\n.CD10    ANOP\n&I       SETA  &I+1                MOVE INDEX PAST ':'\n&K2      SETA  &I                  SAVE CURRENT POINTER.\n.CD20    ANOP\n         AIF   ('&B'(&K2,1) EQ ':').CD30\n&K2      SETA  &K2+1               NEXT POSITION.\n         AIF   (&K2 LE &N).CD20\n&QUIT    SETB  1                   SET THE QUIT SWITCH.\n.CD30    ANOP\n&K4      SETA  &K2                 SAVE CURRENT POINTER.\n&K2      SETA  &K2-&I              COMPUTE SIZE OF SOURCE OPERAND.\n&K3      SETA  1                   INITIALIZE SOURCE OPERAND INDEX.\n.CD31    AIF   (&K2 LT 8).CD32\n&S(&K3)  SETC  '&B'(&I,8)          MOVE SOURCE OPERAND.\n&I       SETA  &I+8                INCREMENT STRING PTR.\n&K2      SETA  &K2-8               DECREMENT CHARACTER COUNT.\n         AIF   (&K2 EQ 0).CD33\n&K3      SETA  &K3+1               INCREMENT INDEX.\n         AIF   (&K3 LE 8).CD31\n         MNOTE 8,'LRM150E FIRST STRING OPERAND EXCEEDS WORK SPACE'\n         MEXIT\n.CD32    ANOP\n&S(&K3)  SETC  '&B'(&I,&K2)        MOVE LAST SEGMENT.\n.CD33    ANOP\n         AIF   (&QUIT).CD40\n.CD35    ANOP\n&K4      SETA  &K4+1               POINT PAST 2ND COLON.\n         AIF   (&K4 GT &N).CD40\n&K2      SETA  &N+1-&K4            COMPUTE SIZE OF REMAINING CHARS.\n&K3      SETA  1                   INITIALIZE MASK INDEX.\n.CD36    ANOP\n         AIF   (&K2 LT 8).CD37\n&M(&K3)  SETC  '&B'(&K4,8)         MOVE MASK/INDEX TO ARRAY.\n&K4      SETA  &K4+8               INCREMENT POINTER.\n&K2      SETA  &K2-8               DECREMENT COUNT.\n         AIF   (&K2 EQ 0).CD40\n&K3      SETA  &K3+1               INCREMENT INDEX.\n         AIF   (&K3 LE 8).CD36\n         MNOTE 8,'LRM160E SECOND STRING OPERAND EXCEEDS WORK SPACE'\n         MEXIT\n.CD37    ANOP\n&M(&K3)  SETC  '&B'(&K4,&K2)       MOVE LAST SEGMENT.\n.CD40    ANOP\n         AIF   ('&B'(1,&K) EQ 'IC').IC\n         AIF   ('&B'(1,&K) EQ 'ICM').ICM\n         AIF   ('&B'(1,&K) EQ 'LH').LH\n         AIF   ('&B'(1,&K) EQ 'L').L\n         AIF   ('&B'(1,&K) EQ 'LA').LA\n         AIF   ('&B'(1,&K) EQ 'LR').LR\n         MNOTE 8,'LRM170E INVALID CODE SPECIFIED'\n         MEXIT\n.IC      ANOP\n&L       #OP    IC,&A,&S(1)&S(2)&S(3)&S(4)&S(5)&S(6)&S(7)&S(8)\n         MEXIT\n.ICM     ANOP\n         AIF   ('&M(1)' NE '').ICM05\n         MNOTE 8,'LRM180E MISSING MASK/INDEX OPERAND'\n         MEXIT\n.ICM05   ANOP\n&L       #OP   ICM,&A,&M(1)&M(2)&M(3)&M(4)&M(5)&M(6)&M(7)&M(8),        X\n               &S(1)&S(2)&S(3)&S(4)&S(5)&S(6)&S(7)&S(8)\n         MEXIT\n.LH      ANOP\n&L       #OP    LH,&A,&S(1)&S(2)&S(3)&S(4)&S(5)&S(6)&S(7)&S(8)\n         MEXIT\n.L       ANOP\n&L       #OP     L,&A,&S(1)&S(2)&S(3)&S(4)&S(5)&S(6)&S(7)&S(8)\n         MEXIT\n.LA      ANOP\n&L       #OP    LA,&A,&S(1)&S(2)&S(3)&S(4)&S(5)&S(6)&S(7)&S(8)\n         MEXIT\n.LR      ANOP\n&L       #OP    LR,&A,&S(1)&S(2)&S(3)&S(4)&S(5)&S(6)&S(7)&S(8)\n.EXIT    ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#OP": {"ttr": 1302, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00\\x15\\x00\\x15\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 21, "newlines": 21, "modlines": 0, "user": "ARCHIVR"}, "text": "         MACRO\n&L       #OP   &CODE,&A,&B,&M\n.*********************************************************************\n.*       $OP                       INSTRUCTION GENERATION MACRO.\n.*\n.*       CODE -- OPERATION CODE.\n.*       A    -- DESTINATION OPERAND.\n.*       B    -- SOURCE OPERAND.\n.*       M    -- MASK/INDEX OPERAND.\n.*\n.*********************************************************************\n         AIF   ('&CODE' EQ '' OR '&A' EQ '' OR '&B' EQ '').NG\n         AIF   ('&M' EQ '').TYPE2\n&L       &CODE &A,&M,&B\n         MEXIT\n.TYPE2   ANOP\n&L       &CODE &A,&B\n         MEXIT\n.NG      ANOP\n         MNOTE 8,'OPM100E MISSING OP CODE/DESTINATION/SOURCE FIELD'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#PUT": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "ARCHIVR"}, "text": "         MACRO --- PUT FOR ARCHIVER ---\n&LABEL   #PUT  &DATA,&MSG=0\n         LCLC  &L1\n&L1      SETC  '&LABEL'\n         AIF   ('&L1' EQ '').NOLBL\n&LABEL   DS    0H\n.NOLBL   ANOP\n         LA    R1,&DATA            OUTPUT LINE AREA\n         L     R15,=V(ARCHPRNT)    POINT TO PRINT ROUTINE\n         BALR  R14,R15             AND CALL IT ---\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RECS": {"ttr": 1539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00G\\x00G\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 71, "newlines": 71, "modlines": 0, "user": "ARCHIVR"}, "text": "         TITLE 'VSAM ARCHIVE RECORD FORMAT'\n*---------------------------------------------------------------------*\n*---     THIS DSECT, WITH ALL ITS ORGS, REPRESENTS THE FORMATS OF  ---*\n*---     THE VARIOUS RECORDS IN THE VSAM ARCHIVE CLUSTER.          ---*\n*---------------------------------------------------------------------*\nREC      DSECT\nRECSTART EQU   *\nRECTT    DS    CL1   RECORD TYPE -------------+\nRECN     DS    CL10  MEMBER NAME              |\nRECG     DS    CL10  MEMBER GROUP             |\nRECSG    DS    CL10  MEMBER SUBGROUP          +-- VSAM KEY\nRECT     DS    CL10  MEMBER TYPE              |\nRECPKEY  EQU   *-RECSTART                     | FOR PARTIAL KEY --\nRECVER   DS    XL4   MEMBER VERSION           |\nRECSEQ#  DS    XL4   RECORD SEQUENCE NUMBER --+\nRECKLEN  EQU   *-RECTT             RECORD KEY LENGTH\nRECDATA  EQU   *     COMPRESSED RECORD DATA\n         SPACE 3\n*---     RECORD TYPES (ALL TYPES NOT DEFINED HERE ARE RESERVED)    ---*\n#RTHDR   EQU   X'10'\n#RTNOTE  EQU   X'20'\n#RTDATA  EQU   X'80'\n*---------------------------------------------------------------------*\n*---     HEADER RECORD DESCRIPTION                                 ---*\n*---------------------------------------------------------------------*\n         ORG   RECDATA\nRSRNOT#  DS    XL4                 LAST NOTE RECORD SEQUENCE NUMBER\n@RSRFLG1 #DSW  ,                   ARCHIVER VERSION NUMBER\n@RSRFLG2 #DSW  ,                   LEVEL WITHIN VERSION\n@RSRFLG3 #DSW  ,                   MISC.\n@RSRFLG4 #DSW  ,                       FLAGS\nRSRDEV   DS    XL4                 SOURCE DEVICE TYPE\nRSRREC   DS    XL1                 SOURCE DATASET RECORD FORMAT\nRSRLRE   DS    XL2                 SOURCE DATASET LRECL\nRSRBLK   DS    XL2                 SOURCE DATASET BLKSIZE\nRSRDSO   DS    XL2                 SOURCE DATASET DSORG\nRSRLMOD  DS    XL1                 SET TO X'FF' FOR LOAD MODULES\nRSRT1LEN EQU   *-REC\nRSRTIME  DS    CL8                 TIME OF UNLOAD\nRSRDATE  DS    CL8                 DATE OF UNLOAD\nRSRT2LEN EQU   *-REC\nRSRRCNT  DS    XL4                 RECORD COUNT\nRSRT3LEN EQU   *-REC\nRSRPDIR  DS    C                   PDS DIRECTORY ENTRY DATA\nRSRT4LEN EQU   *-REC\n*---------------------------------------------------------------------*\n*---     ALIAS RECORD DESCRIPTION                                  ---*\n*---                                                               ---*\n*---     THESE FIELDS ARE THE KEY FIELDS OF THE HEADER RECORD OF   ---*\n*---     THE ITEM FOR WHICH THIS IS AN ALIAS.                      ---*\n*---------------------------------------------------------------------*\n         ORG   RSRDEV\nRECAN    DS    CL10  MEMBER NAME\nRECAG    DS    CL10  MEMBER GROUP\nRECASG   DS    CL10  MEMBER SUBGROUP\nRECAT    DS    CL10  MEMBER TYPE\nRECAVER  DS    XL4   MEMBER VERSION\n*---------------------------------------------------------------------*\n*---     NOTE RECORD DESCRIPTION                                   ---*\n*---------------------------------------------------------------------*\n         ORG   RECDATA\nRDATNOTE DS    C                   72-BYTE RECORDS OF NOTE DATA,\n*                                  COMPRESSED AS NEEDED.\n*---------------------------------------------------------------------*\n*---     MEMBER DATA RECORD DESCRIPTION                            ---*\n*---------------------------------------------------------------------*\n         ORG   RECDATA\nRDATDATA DS    C                   COMPRESSED MEMBER DATA SEGMENTS\n*        EACH SEGMENT CONTAINS A THREE-BYTE LENGTH, FOLLOWED BY A\n*        TWO-BYTE ORIGINAL LENGTH, FOLLOWED BY THE COMPACTED FORM\n*        OF THE RECORD DATA.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#RESPEC": {"ttr": 1542, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00+\\x00+\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 43, "newlines": 43, "modlines": 0, "user": "ARCHIVR"}, "text": "         MACRO\n&LBL     #RESPEC &COMMENT\n         LCLC  &L1,&L2\n&L1      SETC  '&LBL'\n         AIF   ('&L1' EQ '').NOLBL\n&L1      DS    0H                  DEFINE THE LABEL\n.NOLBL   ANOP\n&L2      SETC  '$RSA&SYSNDX'\n         CLI   QC1,C'*'            ANY CHANGE ??\n         BE    &L2                 NOPE ---\n         CLI   QC1,C' '            ANY CHANGE ??\n         BNH   &L2                 NOPE ---\n         MVC   RECN,QC1            MAKE THE CHANGE ---\n&L2      DS    0H\n&L2      SETC  '$RSB&SYSNDX'\n         CLI   QC2,C'*'            ANY CHANGE ??\n         BE    &L2                 NOPE ---\n         CLI   QC2,C' '            ANY CHANGE ??\n         BNH   &L2                 NOPE ---\n         MVC   RECG,QC2            MAKE THE CHANGE ---\n&L2      DS    0H\n&L2      SETC  '$RSC&SYSNDX'\n         CLI   QC3,C'*'            ANY CHANGE ??\n         BE    &L2                 NOPE ---\n         CLI   QC3,C' '            ANY CHANGE ??\n         BNH   &L2                 NOPE ---\n         MVC   RECSG,QC3           MAKE THE CHANGE ---\n&L2      DS    0H\n&L2      SETC  '$RSD&SYSNDX'\n         CLI   QC4,C'*'            ANY CHANGE ??\n         BE    &L2                 NOPE ---\n         CLI   QC4,C' '            ANY CHANGE ??\n         BNH   &L2                 NOPE ---\n         MVC   RECT,QC4            MAKE THE CHANGE ---\n&L2      DS    0H\n&L2      SETC  '$RSE&SYSNDX'\n         CLI   QC5,C'*'            ANY CHANGE ??\n         BE    &L2                 NOPE ---\n         CLI   QC5,C' '            ANY CHANGE ??\n         BNH   &L2                 NOPE ---\n         MVC   RECVER,QC5          MAKE THE CHANGE ---\n&L2      DS    0H\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SDE": {"ttr": 1544, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00\\x18\\x00\\x18\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "ARCHIVR"}, "text": "         MACRO --- SPF DIRECTORY ENTRY ---\n&LABEL   #SDE   &COMMENT\n*---------------------------------------------------------------------*\n*---     SPF PDS DIRECTORY ENTRY                                   ---*\n*---------------------------------------------------------------------*\n         SPACE 1\nSDE      DSECT\nSDENAME  DS    CL8                 MEMBER NAME\nSDETTR   DS    XL4                 MEMBER TTR/FLAGS\nSDEVERS  DS    AL1                 VERSION NUMBER\nSDEMOD   DS    AL1                 MODIFICATION LEVEL\n         DS    AL2                 RESERVED\nSDECDATE DS    PL4                 MEMBER CREATION DATE\nSDEMDATE DS    PL4                 DATE MEMBER LAST MODIFIED\nSDEMTIME DS    XL2                 TIME OF LAST UPDATE (PACKED DECIMAL\n*                                  WITH SIGN SHIFTED OFF)\nSDECLINE DS    AL2                 CURRENT LINE COUNT\nSDEILINE DS    AL2                 INITIAL LINE COUNT\nSDEMLINE DS    AL2                 NUMBER OF MODIFIED LINES\nSDEID    DS    CL7                 TSO ID OF LAST UPDATER\n         DS    CL3                 RESERVED (BLANKS)\nSDELEN   EQU   (*-SDEVERS)/2       DIRECTORY DATA LENGTH, IN H'WORDS\n         SPACE 1\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SET": {"ttr": 1546, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00\\x17\\x00\\x17\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "ARCHIVR"}, "text": "         MACRO\n&LABEL   #SET  &A,&B\n.*\n.*       DATA SWITCH SET/RESET MACRO\n.*\n         GBLC  &SWBYTE             DATA SWITCH BYTE NAME.\n         GBLB  &ERROR              ERROR FLAG.\n         AIF   ('&LABEL' EQ '').NOLBL\n&LABEL   DS    0H\n.NOLBL   ANOP\n         #FINDSW &A                 SET DATA SWITCH BYTE NAME.\n         AIF   (&ERROR).EXIT\n         AIF   ('&B' EQ 'ON').ON\n         AIF   ('&B' EQ 'OFF').OFF\n         MNOTE 0,'** ERROR SWITCH FUNCTION ''&B'' NOT DEFINED'\n         MEXIT\n.ON      ANOP\n         OI    &SWBYTE,&A          .SET SWITCH ON.\n         MEXIT\n.OFF     ANOP\n         NI    &SWBYTE,X'FF'-&A    .SET SWITCH OFF.\n.EXIT    ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SETDEF": {"ttr": 1548, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00\\r\\x00\\r\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "ARCHIVR"}, "text": "         MACRO\n&LBL     #SETDEF &BIT=,&KWG=,&DFLT=\n         LCLC  &A\n         SPACE 2\n&A       SETC  '&LBL'\n         AIF   ('&A' EQ '').NOLBL\n&LBL     DS    0H\n.NOLBL   ANOP\n&A       SETC  '#DF&SYSNDX.A'\n         #IF   &KWG,ON,&A\n         #SET  &BIT,&DFLT\n&A       DS    0H\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SETFLAG": {"ttr": 1550, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06\\x0c\\x00\\x00\\x01 !?\\x01 !?\\x14Y\\x00*\\x00*\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@'", "ispf": {"version": "06.12", "flags": 0, "createdate": "2020-07-31T00:00:00", "modifydate": "2020-07-31T14:59:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "ARCHIVR"}, "text": "         MACRO\n&LBL     #SETFLAG &BIT=,&MSGVAL=,&KWG=\n         LCLC  &A,&L1,&L2,&L3,&L4\n         SPACE 2\n&A       SETC  '&LBL'\n         AIF   ('&A' EQ '').NOLBL\n&LBL     DS    0H\n.NOLBL   ANOP\n         AIF   ('&KWG' EQ '').NOG0\n         #SET  &KWG,OFF\n.NOG0    ANOP\n&L1      SETC  '#SW&SYSNDX.A'\n&L2      SETC  '#SW&SYSNDX.B'\n&L3      SETC  '#SW&SYSNDX.C'\n&L4      SETC  '#SW&SYSNDX.D'\n         LH    R1,PRSKWLN          LOAD THE LENGTH VALUE\n         LTR   R1,R1               ANYTHING SUPPLIED ??\n         BZ    &L3                 NOPE ---\n         L     R1,PRSKWLOC         POINT TO THE VALUE\n         CLI   0(R1),C'Y'          SHORT FORM ??\n         BE    &L2                 YES; STILL DEFAULT\n         CLI   0(R1),C'N'          NEGATIVE VALUE ??\n         BE    &L1                 YES ---\n         #PUT  &L4\n         #PUT  IGNORED             SHOW KEYWORD WAS IGNORED\n         OI    WKRC,8              SET RETURN CODE              @RP2008\n         B     &L3                 AND SKAT ??\n&L4      DC    CL133'  ARCHPARS:  INVALID VALUE FOR &MSGVAL KEYWORD.'\n&L1      DS    0H\n         #SET  &BIT,OFF\n         AIF   ('&KWG' EQ '').NOG1\n         #SET  &KWG,ON\n.NOG1    ANOP\n         B     &L3\n&L2      DS    0H\n         #SET  &BIT,ON\n         AIF   ('&KWG' EQ '').NOG2\n         #SET  &KWG,ON\n.NOG2    ANOP\n&L3      DS    0H\n         SPACE 2\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#STAMP": {"ttr": 1552, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06\\r\\x00\\x00\\x01 !O\\x01 !O\\x10T\\x00\\x1a\\x00\\x1a\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@'", "ispf": {"version": "06.13", "flags": 0, "createdate": "2020-08-01T00:00:00", "modifydate": "2020-08-01T10:54:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "ARCHIVR"}, "text": "         MACRO\n&LBL     #STAMP &BRANCH=Y,&PTF=NONE,&TRACE=NO\n         GBLB  &DEBUG\n         LCLC  &A\n&A       SETC  '&TRACE'\n&DEBUG   SETB  ('&A' EQ 'YES' OR '&A' EQ 'Y')\n&A       SETC  '&LBL'\n         AIF   ('&A' EQ '').NOLBL\n&LBL     DS    0H\n.NOLBL   ANOP\n         AIF   ('&BRANCH' EQ 'N').A\n         B     PASSIT              BRANCH AROUND\n         DC    AL1(40)             ID LENGTH\n.A       ANOP\n         DC    CL8'&SYSECT'        CSECT NAME\n         DC    CL8'BRC0610'        FMID\n         DC    CL8'&PTF'           RMID (IF ANY)\n         DC    CL8'&SYSDATE'       ASSEMBLY DATE\n         DC    CL8'&SYSTIME'       ASSEMBLY TIME\n         DC    C' ARCHIVER V06.1.3--- COPYRIGHT 1999, '       @RP200703\n         DC    C' RICHARD A. FOCHTMAN, JR., WOODRIDGE, IL '\n         AIF   ('&BRANCH' EQ 'N').B\n         DC    H'4096'             FOR BUMPING BASE REGISTERS\nPASSIT   DS    0H\n.B       ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#STOW": {"ttr": 1554, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00\\x17\\x00\\x17\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "ARCHIVR"}, "text": "         MACRO\n&NAME    #STOW &DCB,&AREA\n.*--------------------------------------------------------------------*\n.*---    THIS IS A MODIFIED VERSION OF THE 'STOW' MACRO, FOR USE   ---*\n.*---    BY THE ARCHIVER PROGRAM.  RATHER THAN DEPENDING ON A      ---*\n.*---    PARAMETER IN THE MACRO INVOCATION, IT CHECKS THE          ---*\n.*---    'REPLACE' FLAG IN THE ARCHIVER WORK AREA TO DETERMINE     ---*\n.*---    WHETHER THE REPLACE OPTION OF STOW IS APPROPRIATE.        ---*\n.*---    SINCE WE ONLY ALLOW OR DISALLOW THE REPLACE OPTION, ALL   ---*\n.*---    REFERENCES TO 'DELETE' OR 'CHANGE' PROCESSING ARE         ---*\n.*---    DELETED.                                                  ---*\n.*--------------------------------------------------------------------*\n         LCLC  &L1,&L2\n&L1      SETC  '#STO&SYSNDX'\n&L2      SETC  '#STR&SYSNDX'\n&NAME    #IF   REPL,OFF,&L1\n         STOW  &DCB,&AREA,R        INDICATE REPLACE\n         LA    15,X'1C'(,15)       MODIFIED RETURN CODE\n         B     &L2                 PROCESS RETURN CODE\n&L1      DS    0H\n         STOW  &DCB,&AREA          ISSUE STOW SVC\n&L2      DS    0H\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SWITCH": {"ttr": 1556, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06\\x0c\\x00\\x00\\x01 !?\\x01 !?\\x14Y\\x00)\\x00)\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@'", "ispf": {"version": "06.12", "flags": 0, "createdate": "2020-07-31T00:00:00", "modifydate": "2020-07-31T14:59:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "ARCHIVR"}, "text": "         MACRO\n&LBL     #SWITCH &PARSE=,&BIT=,&MSGVAL=,&KWG=\n         LCLC  &A,&L1,&L2,&L3\n         SPACE 2\n&A       SETC  '&LBL'\n         AIF   ('&A' EQ '').NOLBL\n&LBL     DS    0H\n.NOLBL   ANOP\n         #SET  &KWG,OFF\n&L1      SETC  '#SW&SYSNDX.A'\n&L2      SETC  '#SW&SYSNDX.B'\n&L3      SETC  '#SW&SYSNDX.C'\n         LA    R2,&PARSE           POINT TO PARSE ITEM\n         USING PRSKWKW,R2\n         LH    R1,PRSKWLN          LOAD THE LENGTH VALUE\n         LTR   R1,R1               ANYTHING SUPPLIED ??\n         BZ    &L3                 NOPE ---\n         L     R1,PRSKWLOC         POINT TO THE VALUE\n         CLC   0(3,R1),=C'YES'     'YES' GIVEN ??\n         BE    &L2                 YES; ASSUME ITS THE DEFAULT\n         CLI   0(R1),C'Y'          SHORT FORM ??\n         BE    &L2                 YES; STILL DEFAULT\n         CLI   0(R1),C'N'          NEGATIVE VALUE ??\n         BE    &L1                 YES ---\n         CLC   0(2,R1),=C'NO'      LONG FORM ??\n         BE    &L1                 YES ---\n         #PUT  =CL133'  ARCHPARS:  INVALID VALUE FOR &MSGVAL KEYWORD.'\n         #PUT  IGNORED             SHOW KEYWORD WAS IGNORED\n         OI    WKRC,8              SET RETURN CODE (8 = SYNTAX ERROR)\n         B     &L3                 AND SKAT ??\n&L1      DS    0H\n         #SET  &BIT,OFF\n         #SET  &KWG,ON\n         B     &L3\n&L2      DS    0H\n         #SET  &BIT,ON\n         #SET  &KWG,ON\n&L3      DS    0H\n         DROP  R2\n         SPACE 2\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#VSPRMS": {"ttr": 1558, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00\\x1a\\x00\\x1a\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "ARCHIVR"}, "text": "         MACRO\n&LBL     #VSPRMS &COMMENT\n         TITLE 'VSAM OPEN/CLOSE PARAMETER LIST. '\n*---------------------------------------------------------------------*\n*---     THIS IS THE BASIC PARAMETER LIST FOR THE VSAM OPEN        ---*\n*---     ROUTINE, ARCHVSOP. IT MUST EXACTLY MATCH THE              ---*\n*---     CORRESPONDING AREAS IN ##ARCHWK, STARTING WITH THE        ---*\n*---     DDNAME.                                                   ---*\n*---------------------------------------------------------------------*\n         SPACE 3\n#VSPRMS  DSECT\nVSAMDD   DS    CL8                 CLUSTER DDNAME\nACBADDR  DS    A                   ADDRESS OF VSAM ACB\nVSRPL1   DS    A                   ADDRESS OF VSAM RPL1\nVSRPL2   DS    A                   ADDRESS OF VSAM RPL2\nVSRPL3   DS    A                   ADDRESS OF VSAM RPL3\nVSBUF1   DS    A                   ADDRESS OF VSAM'S BUFFER # 1\nVSBUF2   DS    A                   ADDRESS OF VSAM'S BUFFER # 2\nVSBUF3   DS    A                   ADDRESS OF VSAM'S BUFFER # 3\nVSLIM    DS    A                   MAX. RECORD LENGTH\nVSLEN1   DS    A                   BYTES USED IN THIS BUFFER\nVSLEN2   DS    A                   BYTES USED IN THIS BUFFER\nVSLEN3   DS    A                   BYTES USED IN THIS BUFFER\nVSMODE   DS    CL8                 'INPUT', 'OUTPUT' OR BLANKS\n         SPACE 3\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE147": {"ttr": 1560, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00I\\x01 %\\x7f\\x01 %\\x7f\\x16)\\x00\\xc3\\x00\\xc3\\x00\\x00\\xc3\\xc2\\xe3`\\xf5\\xf0\\xf0@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "2020-09-13T00:00:00", "modifydate": "2020-09-13T16:29:49", "lines": 195, "newlines": 195, "modlines": 0, "user": "CBT-500"}, "text": "//***FILE 147 is from Rick Fochtman, of Chicago Illinois, and       *   FILE 147\n//*           contains a copy of \"The ARCHIVER\".  \"The ARCHIVER\"    *   FILE 147\n//*           has been upgraded to Version 6.1.3.  This file is     *   FILE 147\n//*           in IEBUPDTE SYSIN format.                             *   FILE 147\n//*                                                                 *   FILE 147\n//*           Rob Prins is the current maintainer of ARCHIVER.      *   FILE 147\n//*                                                                 *   FILE 147\n//*           Unfortunately, Rick Fochtman passed away several      *   FILE 147\n//*           years ago.  Support emails are listed below.          *   FILE 147\n//*                                                                 *   FILE 147\n//*           ARCHIVER documentation has been put into PDF and      *   FILE 147\n//*           MSWORD formats.  Members as follows:                  *   FILE 147\n//*                                                                 *   FILE 147\n//*           ARCHIVE#  - doc in PDF format                         *   FILE 147\n//*           ARCHIVE@  - doc in MSWORD format                      *   FILE 147\n//*                                                                 *   FILE 147\n//*           Loadmodules for OS/390 and z/OS:                      *   FILE 147\n//*           If you do a TSO RECEIVE of member LOADXMI, the        *   FILE 147\n//*           LOADLIB has been created. Actually you don't need     *   FILE 147\n//*           to assemble and link ARCHIVER, the loadmodules will   *   FILE 147\n//*           run on an OS/390 or z/OS system.                      *   FILE 147\n//*                                                                 *   FILE 147\n//*           Loadmodules for MVS:                                  *   FILE 147\n//*           If you do a TSO RECEIVE of member LOADXMIM, the       *   FILE 147\n//*           LOADLIB has been created. Actually you don't need     *   FILE 147\n//*           to assemble and link ARCHIVER, the loadmodules will   *   FILE 147\n//*           run on a MVS system.                                  *   FILE 147\n//*                                                                 *   FILE 147\n//*           To my knowledge, there isn't any other software       *   FILE 147\n//*           product like this, anywhere.  (SG - 10/99)            *   FILE 147\n//*                                                                 *   FILE 147\n//*           Please refer all questions to Sam Golob or Rob Prins  *   FILE 147\n//*                                                                 *   FILE 147\n//*              email:  sbgolob@cbttape.org    (Sam Golob)         *   FILE 147\n//*                                                                 *   FILE 147\n//*              email:  rn.prins@quicknet.nl   (Rob Prins)         *   FILE 147\n//*                                                                 *   FILE 147\n//*           ---------------------------------------------------   *   FILE 147\n//*           Modification note:                                    *   FILE 147\n//*                                                                 *   FILE 147\n//*            Modified slightly by Rob Prins, (Version 6.1.2)      *   FILE 147\n//*            The reason was that ARCHIVER was traditionally       *   FILE 147\n//*            meant to be used in batch.  However, Rob, who is     *   FILE 147\n//*            the author of RPF (Rob's Programming Facility -      *   FILE 147\n//*            CBT File 415) wanted RPF to interactively be able    *   FILE 147\n//*            to access and modify an Archive.  He found that      *   FILE 147\n//*            some LOAD macros were not matched by corresponding   *   FILE 147\n//*            DELETE macros, etc., plus a few other errors,        *   FILE 147\n//*            which didn't show up when the ARCHIVER was run in    *   FILE 147\n//*            batch.  These were fixed here.                       *   FILE 147\n//*            Another modification is intruducing an EXEC PARM     *   FILE 147\n//*            By specifying 'PARM=SYSIN=ddname1,SYSPRINT=ddname2'  *   FILE 147\n//*            you can override the standard ddnames for SYSIN and  *   FILE 147\n//*            SYSPRINT. If you omit the PARM the standard ddnames  *   FILE 147\n//*            SYSIN and SYSPRINT are used.                         *   FILE 147\n//*           ---------------------------------------------------   *   FILE 147\n//*                                                                 *   FILE 147\n//*           \"The ARCHIVER\" is a handy mechanism to store all of   *   FILE 147\n//*           your software and data objects--source code, load     *   FILE 147\n//*           modules, PSF objects, and the like--in one place,     *   FILE 147\n//*           in a single VSAM cluster.  Version 4.0 and higher     *   FILE 147\n//*           of The ARCHIVER provide a large amount of data        *   FILE 147\n//*           compression, especially for source code.  Version     *   FILE 147\n//*           4.0 and higher of \"The ARCHIVER\" allows item-by-item  *   FILE 147\n//*           \"export\" to tape.  From the tape we can go directly   *   FILE 147\n//*           back to pds uncompressed form, without need for the   *   FILE 147\n//*           intermediate VSAM cluster.  Version 5.0 of The        *   FILE 147\n//*           ARCHIVER was extensively reworked from previous       *   FILE 147\n//*           versions.  Files created with previous versions of    *   FILE 147\n//*           \"The ARCHIVER\" are upgradable with the \"CONVERT\"      *   FILE 147\n//*           command.  Rick Fochtman plans to keep \"The ARCHIVER\"  *   FILE 147\n//*           upwardly compatible.                                  *   FILE 147\n//*                                                                 *   FILE 147\n//*           Version 6.1 of The ARCHIVER is basically a            *   FILE 147\n//*           Y2K-ization of Version 5.0.  (Remember here that      *   FILE 147\n//*           the general CBT disclaimer about Y2K compatibility    *   FILE 147\n//*           being \"not guaranteed\" applies - SG 10/12/99.)        *   FILE 147\n//*                                                                 *   FILE 147\n//*           \"The ARCHIVER\" makes it possible to handily store     *   FILE 147\n//*           your personal software tool-kit for transport and     *   FILE 147\n//*           archive purposes.  It may also be useful for the      *   FILE 147\n//*           installation's stuff to help archive all your shop's  *   FILE 147\n//*           software on a tape or two.                            *   FILE 147\n//*                                                                 *   FILE 147\n//*           THIS FILE CONTAINS SOURCE AND MACROS. ALSO A MEMBER   *   FILE 147\n//*           CALLED SAMPLIB CONTAINS AN IEBUPDTE SYSIN STREAM FOR  *   FILE 147\n//*           RICK'S SAMPLIB PDS. SEE MEMBER CALLED ARCHDOC.        *   FILE 147\n//*                                                                 *   FILE 147\n//*     >>>>  An adaptation was made to ARCHIVER, to be able to     *   FILE 147\n//*     >>>>  assemble and run it on MVS 3.8J, under Hercules.      *   FILE 147\n//*     >>>>  This update came from Dave Cartwright.  See his       *   FILE 147\n//*     >>>>  members $ARCH370 and $INST370.  Since MVS 3.8J and    *   FILE 147\n//*     >>>>  Hercules are accessible to all, they can provide a    *   FILE 147\n//*     >>>>  suitable medium for archiving all your later MVS      *   FILE 147\n//*     >>>>  software goodies for posterity.  And you won't have   *   FILE 147\n//*     >>>>  to be dependent on an employer, to be able to         *   FILE 147\n//*     >>>>  access, read, and update your stuff.  There are       *   FILE 147\n//*     >>>>  also a couple of bug fixes to the main ARCHIVER       *   FILE 147\n//*     >>>>  code.                                                 *   FILE 147\n//*                                                                 *   FILE 147\n//*           ARCHIVER FUNCTIONS:  (NOT ALL OF THEM LISTED HERE)    *   FILE 147\n//*                                                                 *   FILE 147\n//*           1. UNLOAD A PDS OR SELECTED PDS MEMBERS TO A VSAM     *   FILE 147\n//*              CLUSTER, STORING HISTORICAL AND COMMENT DATA       *   FILE 147\n//*              RELATED TO EACH ITEM.                              *   FILE 147\n//*                                                                 *   FILE 147\n//*           2. LOAD A PDS FROM A VSAM CLUSTER ARCHIVE.            *   FILE 147\n//*                                                                 *   FILE 147\n//*           3. LIST, COPY OR DELETE ITEMS FROM A VSAM CLUSTER     *   FILE 147\n//*              ARCHIVE DATASET.  OPTIONALLY, ADD COMMENT DATA TO  *   FILE 147\n//*              ITEMS ON THE ARCHIVE CLUSTER.                      *   FILE 147\n//*                                                                 *   FILE 147\n//*           4. ITEM-BY-ITEM \"EXPORT\" OF ALL ENTRIES IN THE VSAM   *   FILE 147\n//*              CLUSTER TO TAPE -- STILL IN HIGHLY COMPRESSED      *   FILE 147\n//*              FORMAT.  LISTT TO LIST CONTENTS AND LOADT TO       *   FILE 147\n//*              LOAD A PDS DIRECTLY FROM TAPE, PARALLEL THE LIST   *   FILE 147\n//*              AND LOAD FUNCTIONS DESCRIBED ABOVE FOR THE VSAM    *   FILE 147\n//*              CLUSTER ARCHIVE DATASET.                           *   FILE 147\n//*                                                                 *   FILE 147\n//*           5. PROVIDE A DATA-COMPRESSION MECHANISM TO REDUCE     *   FILE 147\n//*              THE MEDIA REQUIREMENTS OF THE VSAM CLUSTER         *   FILE 147\n//*              ARCHIVE DATASET AND THE \"ITEM-BY-ITEM EXPORT\"      *   FILE 147\n//*              TAPE.                                              *   FILE 147\n//*                                                                 *   FILE 147\n//*           6. BACKUP AND RECOVER USING STANDARD IBM UTILITY      *   FILE 147\n//*              MECHANISMS.  YOU CAN USE THE \"IDCAMS EXPORT\"       *   FILE 147\n//*              AND \"IDCAMS IMPORT\" TOO, BUT THEY AREN'T ITEM-     *   FILE 147\n//*              BY-ITEM.  THEY MUST DO THE ENTIRE VSAM DATASET.    *   FILE 147\n//*                                                                 *   FILE 147\n//*    email address:   sbgolob@cbttape.org    (Sam Golob)          *   FILE 147\n//*                     rn.prins@quicknet.nl   (Rob Prins)          *   FILE 147\n//*                                                                 *   FILE 147\n//*    ANOTHER NOTE -- I MIGHT AS WELL MENTION THIS CONCEPT HERE.   *   FILE 147\n//*                                                                 *   FILE 147\n//*    \"THE ARCHIVER\" CLASSIFIES \"ITEMS\" BY FOUR 10-BYTE KEYS AND   *   FILE 147\n//*    A VERSION NUMBER THAT CAN GO FROM 1 TO 16MB.  SOME EXAMPLE   *   FILE 147\n//*    CONTROL STATEMENTS TO UNLOAD ALL MEMBERS OF A PDS INTO A     *   FILE 147\n//*    VSAM CLUSTER MIGHT READ AS FOLLOWS:                          *   FILE 147\n//*                                                                 *   FILE 147\n//*    SET VSAM1DSN=TST.SAMPLE.SYSTEM.ARCHIVE                       *   FILE 147\n//*   *   COMMENT (ASTERISK IN COLUMN 1)                            *   FILE 147\n//*   *   SET STATEMENT INSTRUCTS DYNAMIC ALLOCATION.               *   FILE 147\n//*   *   VSAM1DSN OR VSAM1DDN STATEMENTS ALLOCATE VSAM CLUSTERS.   *   FILE 147\n//*    UNLOAD ITEM=(*,SYS1.LKLIB,10/05/90,MVSRES),DSN=SYS1.LINKLIB  *   FILE 147\n//*   *   DSN OR DDN STATEMENTS ALLOCATE NON-VSAM DATASETS.         *   FILE 147\n//*                                                                 *   FILE 147\n//*    THE COMMAS DELIMIT THE KEY FIELDS.  THE \"*\" IN THE FIRST     *   FILE 147\n//*    FIELD DENOTES THAT ALL MEMBERS OF THE PDS SHOULD BE UNLOADED.*   FILE 147\n//*    SYS1.LINKLIB, IF IT IS CATALOGED, IS DYNAMICALLY ALLOCATED   *   FILE 147\n//*    BY THE ARCHIVER PROGRAM, AS INSTRUCTED BY THE \"DSN\" KEYWORD. *   FILE 147\n//*    VERSION NUMBER (THE FIFTH PARAMETER) DEFAULTS TO 1.          *   FILE 147\n//*                                                                 *   FILE 147\n//*    IF AN ITEM EXISTS ON THE VSAM ARCHIVE WITH ALL KEYS AND      *   FILE 147\n//*    VERSION NUMBER MATCHING, A NEW COPY WILL BE ARCHIVED WITH    *   FILE 147\n//*    VERSION NUMBER INCREMENTED BY ONE.  IT IS EASIER TO STORE    *   FILE 147\n//*    AN EXTRA COPY THAN TO RECOVER A DELETED COPY.  IF THE        *   FILE 147\n//*    VERSION NUMBER IS EXPLICITLY STATED AND ALL FIVE KEYS MATCH, *   FILE 147\n//*    THEN AN ITEM REPLACE IS FORCED.  A VERSION NUMBER MAY BE     *   FILE 147\n//*    EXPLICITLY STATED, BUT THIS IS USUALLY NOT PREFERABLE.       *   FILE 147\n//*                                                                 *   FILE 147\n//* >> PLEASE KEEP LOOKING HERE FOR REPORTS OF NEW DEVELOPMENTS. << *   FILE 147\n//*                                                                 *   FILE 147\n//*    A.  ARCHIVER VERSION 6.1 HAS A \"COMPARE\" FUNCTION AND AN     *   FILE 147\n//*        \"ALIAS\" FUNCTION FOR ITEMS, WHICH ARE NEW.  THE FORMAT   *   FILE 147\n//*        OF THE ARCHIVE HASN'T CHANGED--VERSION 6.1 WILL READ     *   FILE 147\n//*        ARCHIVES CREATED BY VERSION 4.0 WITHOUT CONVERSION,      *   FILE 147\n//*        (BUT NOT VICE-VERSA, BECAUSE OF THE NEW ALIAS HEADERS).  *   FILE 147\n//*        THERE IS ALSO A NEW FEATURE TO LIST CATEGORIES OF        *   FILE 147\n//*        ITEMS.  YOU MAY PICTURE THIS FUNCTION AS DESCRIBING      *   FILE 147\n//*        \"LOGICAL FILES\" WITHIN A SINGLE ARCHIVE VSAM DATASET     *   FILE 147\n//*        OR TAPE.  THE FUNCTION IS CALLED \"LFILE\" (FROM AN        *   FILE 147\n//*        ARCHIVE) AND \"LFILET\" (FROM A TAPE).                     *   FILE 147\n//*                                                                 *   FILE 147\n//*    B.  IN VERSION 6.1, IF TWO ARCHIVED ITEMS COMPARE TO BE      *   FILE 147\n//*        IDENTICAL, IT IS POSSIBLE TO STORE ONLY ONE COPY OF      *   FILE 147\n//*        THE ACTUAL DATA, AND STILL GET TO THE ITEM VIA TWO       *   FILE 147\n//*        KEYS--ONE IS THE ACTUAL KEY, AND THE OTHER IS AN         *   FILE 147\n//*        ALIAS KEY.  THIS CAN RESULT IN ENORMOUS MEDIA SAVINGS.   *   FILE 147\n//*        (RICK FOCHTMAN HAS DONE \"WONDERS\" WITH THIS FACILITY.    *   FILE 147\n//*        HE HAS SENT ME A SINGLE CARTRIDGE CONTAINING \"THE        *   FILE 147\n//*        ARCHIVER 5.0\" SOFTWARE, PLUS AN ITEM-BY-ITEM EXPORTED    *   FILE 147\n//*        ARCHIVE CONTAINING SIX VERSIONS OF THE CBT TAPE, THE     *   FILE 147\n//*        JES2 AND JES3 SHARE TAPES, THE CICS SHARE TAPE, AND      *   FILE 147\n//*        MATERIAL FROM OTHER TAPES.  I THINK HE DESERVES AT       *   FILE 147\n//*        LEAST A \"WOW\".)                                          *   FILE 147\n//*                                                                 *   FILE 147\n//* >>>>  NOTICE - NOTICE - NOTICE - NOTICE - NOTICE - NOTICE  <<<< *   FILE 147\n//* >>                                                           << *   FILE 147\n//* >>    FOR ARCHIVER USERS, ARCHIVER VERSIONS 1, 2, AND 3      << *   FILE 147\n//* >>    WILL NOT BE SUPPORTED AFTER JUNE 1, 1994.  VERSION 6.1 << *   FILE 147\n//* >>    WILL CONVERT FILES FROM THE EARLIER FORMATS, TO ITS    << *   FILE 147\n//* >>    CURRENT FORMAT.                                        << *   FILE 147\n//* >>                                                           << *   FILE 147\n//* >>>>  NOTICE - NOTICE - NOTICE - NOTICE - NOTICE - NOTICE  <<<< *   FILE 147\n//*                                                                 *   FILE 147\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AMATRACE": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x01\\x9d\\x01\\x9d\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 413, "newlines": 413, "modlines": 0, "user": "ARCHIVR"}, "text": "         MACRO\n         ENTER\n         LCLA  &A\n.LOOP    AIF   (&A EQ 6).END\nTRACE&A  DS    0H\n         STM   R14,R12,12(R13)     .SAVE ALL REGISTERS.\n         BALR  R10,0               .SET TEMP BASE REGISTER.\n         USING *,R10               .TELL ASSEMBLER.\n         B     AMA&A               .BRANCH AROUND ENTRY ID.\n         DC    CL8'TRACE&A'        .ENTRY IDENTIFIER.\nAMA&A    LA    R12,&A              .SET ENTRY OPTION.\n         L     R11,=V(AMATRACE)    .SET PERMANENT PGM BASE.\n         B     AMA10               .BR TO LINK SAVE AREAS.\n         SPACE 2\n&A       SETA  &A+1\n         AGO   .LOOP\n.END     ANOP\n         DROP  R10                 .TEMP ADDRESSABILITY NOT NEEDED.\n         USING AMATRACE,R11\nAMA10    DS    0H\n         STM   R0,R15,REGAREA      .GET REGISTERS AT ENTRY TO TRACE.\n         MVC   REGAREA+40(12),60(R13) .GET TRUE VALUES FOR 10-12.\n         ST    R13,SA+4            .LINK SAVE AREAS.\n         LA    R10,SA\n         ST    R10,8(R13)\n         LR    R13,R10\n         MEND\n         TITLE 'AMA - BAL STATEMENT LABEL TRACE PROGRAM.'\n***********************************************************************\n*AMATRACE\n*\n*        BAL STATEMENT LABEL TRACE PROGRAM\n*\n*ENTRY FROM:   A BAL APPLICATION PROGRAM USING THE MACRO 'LAB'.\n*\n*INPUT:        GENL REG 14 = PARAMETER LIST ADDRESS.\n*\n*            AMATRACE HAS A SEPARATE ENTRY POINT FOR EACH USER OPTION.\n*\n*        ENTRY POINT         FUNCTION\n*           TRACE0 - USE SAME TRACE LEVEL.\n*           TRACE1 - TRACE STATEMENT LABELS ONLY.\n*           TRACE2 - TRACE STATEMENT LABELS AND GENL REGISTERS.\n*           TRACE3 - TRACE STATEMENT LABELS AND SNAP DUMP.\n*           TRACE4 - ABEND DUMP.\n*\n*PROCESS:      THIS ROUTINE PRINTS TRACE INFORMATION ON THE LEVEL\n*              REQUESTED BY THE CALLER.\n*\n*OUTPUT:       TRACE 0-3 FILE 'TRACEOUT'\n*              TRACE 4   FILE 'SYSUDUMP'\n*\n*EXT REFS:     NONE.\n*\n*OS/VS MACROS: ABEND,CHECK,GETMAIN,OPEN,SNAP,WRITE,WTO.\n*PVT MACROS:   REGISTER.\n*\n*ATTRIBUTES:   NON-REENTRANT,NON-REFRESHABLE.\n*SIZE:         APPR. 1800 BYTES.\n*\n*              S/370-145 OS/VS1 2.6\n***********************************************************************\n         EJECT\n***********************************************************************\n*\n*        TRACE PARAMETER LIST FORMAT\n*\n*ON ENTRY:     GENL REG 14 CONTAINS THE PARAM LIST ADDRESS.\n*\n*        --------------------------------+\n*PREFIX: DS AL1(0) AREA TRACE INDICATOR  |\n*        DS AL1    NUMBER OF AREAS       |\n*                                        |\n*        --------------------+           +--> OPTIONAL\n*ENTRY:  DS CL10   AREA NAME |           |\n*        DS AL4    AREA ADDR +-->REPEATED|\n*        DS AL2    AREA SIZE |           |\n*        --------------------+           |\n*        --------------------------------+\n*\n*SUFFIX: DS CL8    TRACE IDENTIFIER\n*\n*  - OR -\n*\n*        DS AL4    MESSAGE ADDRESS\n*\n***********************************************************************\n         EJECT\n         PRINT NOGEN\nAMATRACE CSECT                     MODULE IDENTIFIER.\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         DC    CL8'AMATRACE'       SAME.\n         ENTRY TRACE0,TRACE1,TRACE2,TRACE3,TRACE4,TRACE5\n         ENTER                     SET UP ENTRY CONVENTIONS FOR ALL ENT\n         SPACE 1\n*        GENL REG 11 = PROGRAM BASE.\n*        GENL REG 12 = OPTION TYPE.\n*        GENL REG 13 = REGISTER SAVE AREA ADDRESS.\n*        GENL REG 14 = PARAMETER LIST ADDRESS.\n*        REGAREA = REGISTERS AT ENTRY TO TRACE.\n         SPACE 1\nAMA20    DS    0H\n         SPACE 1\n*        OPEN OUTPUT FILE IF REQUIRED\n         SPACE 1\n         L     R2,16               SET CVT ADDRESS.\n         L     R2,0(R2)            SET TCB POINTER ADDRESS.\n         L     R2,4(R2)            SET CURRENT TCB ADDRESS.\n         L     R2,112(R2)          SET TCB FSA ADDRESS.\n         LA    R2,4(R2)            USE FSA BACK CHAIN ADDRESS.\n         L     R3,0(R2)            CHECK IF ALREADY IN USE.\n         OC    1(3,R2),1(R2)       TRACE ALREADY IN USE ?\n         BNZ   AMA26               BR IF YES.\n         GETMAIN R,LV=88           GET DCB SPACE.\n         MVC   0(88,R1),TRACEOUT   SET UP DCB.\n         LR    R3,R1               SAVE DCB ADDRESS.\n         OPEN  ((R3),OUTPUT)       OPEN TRACE OUTPUT FILE.\n         TM    48(R3),X'10'        DID FILE OPEN OK ?\n         BO    AMA25               BR IF YES.\n         WTO   'AMA001I TRACEOUT DD CARD REQUIRED FOR TRACE OUTPUT',   X\n               ROUTCDE=11          TELL PGMMER HE BLEW IT.\n         SVC   3                   EXIT TO OS/VS.\n         SPACE 1\nAMA25    DS    0H\n         N     R3,=X'00FFFFFF'     CLEAR HI ORDER BYTE.\n         O     R3,0(R2)            SAVE TRACE PRT ENABLE/DISABLE STATUS\n         ST    R3,0(R2)            SAVE OPEN DCB ADDRESS IN FSA.\n         SPACE 1\nAMA26    DS    0H\n         STC   R12,LEVEL           SET NEW TRACE LEVEL.\n         CLI   LEVEL,5             IS THIS A TRACE MESSAGE CALL ?\n         BNE   AMA30               BR IF NOT.\n         TM    0(R2),X'80'         TRACE PRINTING DISABLED ?\n         BO    AMA29               BR IF YES.\n         L     R1,0(R14)           GET MESSAGE ADDRESS.\n         LH    R4,0(R1)            GET MESSAGE LENGTH.\n         LA    R1,2(R1)            SET TEXT ADDRESS.\n         LTR   R4,R4               MESSAGE TOO LARGE ?\n         BP    AMA27               BR IF OK.\n         MVC   LINE(30),=C'AMA002I INVALID MESSAGE LENGTH'\n         BAL   R9,PRINT            PRINT THE ERROR MESSAGE.\n         B     AMA29\n         SPACE 1\nAMA27    DS    0H\n         C     R4,=F'120'          MESSAGE TOO LARGE ?\n         BNH   AMA28               BR IF NOT.\n         LA    R4,120              TRUNCATE MESSAGE LENGTH.\n         SPACE 1\nAMA28    DS    0H\n         BCTR  R4,0                SET LENGTH FOR EX.\n         EX    R4,MVC              MOVE USER MESSAGE TO PRINT LINE.\n         BAL   R9,PRINT            PRINT USER MESSAGE.\n         SPACE 1\nAMA29    DS    0H\n         L     R13,4(R13)          GET PREVIOUS SAVE AREA ADDRESS.\n         LM    R14,R12,12(R13)     RESTORE ALL REGISTERS.\n         B     4(R14)              RETURN TO APPLICATION PROGRAM.\n         SPACE 1\nAMA30    DS    0H                  MESSAGE BYPASS.\n         SR    R8,R8               SET UP AREAS INDICATOR.\n         CLI   0(R14),0            TRACE MAIN STORAGE OPTION SPECIFIED?\n         BNE   AMA35               BR IF NOT.\n         LR    R8,R14              SAVE AREAS PARAM LIST ADDRESS.\n         LH    R1,0(R14)           PICK NUMBER OF AREAS.\n         SLL   R1,4                SET AREAS PARAM LIST LENGTH.\n         LA    R14,2(R1,R14)       SET TRACE IDENTIFIER ADDRESS.\n         L     R1,4(R13)           GET USER SAVE AREA ADDRESS.\n         ST    R14,12(R1)          SET RETURN ADDRESS.\n         SPACE 1\nAMA35    DS    0H\n         TM    0(R2),X'80'         TRACE PRINTING DISABLED ?\n         BO    AMA900              BR IF YES.\n         MVC   LINE(8),0(R14)      PUT STATEMENT LABEL IN PRINT LINE.\n         SPACE 1\n*        PRINT TRACE INFORMATION\n         SPACE 1\nAMA40    DS    0H\n         CLI   LEVEL,1             LABELS ONLY ?\n         BNE   AMA50               BR IF NOT.\n         BAL   R9,PRINT            PRINT LABEL.\n         B     AMA80               CHECK FOR STORAGE AREA TRACE.\n         SPACE 1\nAMA50    DS    0H\n         BAL   R10,PRINTREG        PRINT CURRENT REGISTERS.\n         CLI   LEVEL,2             LABELS AND REGS ONLY ?\n         BE    AMA80               BR IF YES.\n         CLI   LEVEL,3             LABELS AND SNAP ?\n         BNE   AMA60               BR IF NOT.\n         SNAP  DCB=(R3),ID=7,PDATA=ALL PRINT PARTITION STORAGE.\n         B     AMA80               CHECK FOR STORAGE AREA TRACE.\n         SPACE 1\nAMA60    DS    0H\n         LTR   R8,R8               AREA TRACE REQD ?\n         BZ    AMA70               BR IF NOT.\n         BAL   R10,PRINTA          PRINT STORAGE AREAS.\n         SPACE 1\nAMA70    DS    0H\n         ABEND 7,DUMP              TAKE A DUMP...\n         SPACE 1\n*        PRINT STORAGE AREAS IF REQD\n         SPACE 1\nAMA80    DS    0H\n         LTR   R8,R8               STORAGE AREA TRACE ?\n         BZ    AMA900              BR IF NOT.\n         BAL   R10,PRINTA          PRINT ALL STORAGE AREAS.\n         SPACE 1\n*        RESTORE REGISTERS AND RETURN\n         SPACE 1\nAMA900   DS    0H\n         L     R13,4(R13)          GET PREVIOUS SAVE AREA ADDRESS.\n         LM    R14,R12,12(R13)     RESTORE ALL REGISTERS.\n         B     8(R14)              RETURN TO APPLICATION PROGRAM.\n         EJECT\n***********************************************************************\n*PRINT\n*        PRINT LINE ROUTINE\n*\n*INPUT:  R9 = RETURN ADDRESS.\n*        LINE = LINE TO BE PRINTED.\n*\nPRINT    DS    0H\n         WRITE DECB,SF,(R3),VBRECORD,'S' PRINT A LINE.\n         CHECK DECB                WAIT FOR COMPLETION.\n         MVC   LINE,LINE-1         CLEAR PRINT BUFFER.\n         BR    R9                  RETURN TO CALLER.\n         EJECT\n***********************************************************************\n*PRINTREG\n*\n*        PRINT GENERAL REGISTERS ROUTINE\n*\n*INPUT:  R10 = RETURN ADDRESS.\n*        REGAREA = REGISTERS AT ENTRY TO TRACE.\n*\nPRINTREG DS    0H\n         LA    R2,REGAREA          SET POINTER TO CURRENT REGS.\n         ZAP   REG,=P'0'\n         LA    R4,LINE+16          SET PRINT LINE POS FOR REGS.\n         MVC   0(8,R4),=C'REGS 0-7' PRINT REGISTER HEADER.\n         SPACE 1\nAMA500   DS    0H\n         AP    REG,=P'1'           INCREMENT REGISTER COUNTER.\n         UNPK  13(9,R4),0(5,R2)    PRINT REGISTER CONTENTS.\n         MVI   21(R4),C' '         BLAST GARBAGE BYTE.\n         TR    13(8,R4),TRT1       TRANSLATE TO EBCDIC.\n         LA    R4,10(R4)           BUMP PRINT LINE OFFSET.\n         CP    REG,=P'4'           BUMP AN EXTRA TWO AT FOUR REGISTER\n         BNE   AMA502              INTERVALS.\n         LA    R4,2(R4)\nAMA502   DS    0H\n         CP    REG,=P'12'\n         BNE   AMA505\n         LA    R4,2(R4)\nAMA505   DS    0H\n         LA    R2,4(R2)            BUMP REGISTER POINTER.\n         CP    REG,=P'16'          END OF SECOND LINE ?\n         BE    AMA510              BR IF YES.\n         CP    REG,=P'8'           END OF FIRST LINE ?\n         BNE   AMA500              BR IF NOT.\n         BAL   R9,PRINT            PRINT FIRST LINE.\n         LA    R4,LINE+16          SET PRINT LINE POS FOR REGS.\n         MVC   0(9,R4),=C'REGS 8-15' PRINT REGISTER HEADER.\n         B     AMA500\n         SPACE 1\nAMA510   DS    0H\n         BAL   R9,PRINT            PRINT SECOND LINE.\n         BAL   R9,PRINT            PRINT SPACER.\n         BR    R10                 RETURN TO CALLER.\n         EJECT\n***********************************************************************\n*PRINTA\n*\n*        PRINT STORAGE AREA ROUTINE\n*\n*INPUT:  R8 - AREA PARAMETER LIST ADDRESS.\n*        R10- RETURN ADDRESS.\n*WORK REGS:    R1,R2,R4,R5,R6,R7,R8,R12.\n*\nPRINTA   DS    0H\n         LH    R2,0(R8)            SET NUMBER OF AREAS TO TRACE.\n         LA    R8,2(R8)            SKIP PAST PREFIX.\n         SPACE 1\nAMA600   DS    0H\n         MVC   LINE+16(4),=C'AREA' FORMAT AREA NAME.\n         MVC   LINE+21(10),0(R8)\n         MVC   LINE+34(7),=C'ADDRESS' FORMAT AREA ADDRESS.\n         UNPK  LINE+42(9),10(5,R8)\n         TR    LINE+42(8),TRT1\n         MVI   LINE+50,C' '\n         MVC   LINE+52(11),=C'LENGTH(DEC)' FORMAT AREA LENGTH.\n         LH    R12,14(R8)\n         MVC   LINE+64(5),=C'INVAL'\n         LTR   R12,R12\n         BM    AMA610\n         BZ    AMA610\n         CVD   R12,D\n         MVC   LINE+63(6),=X'402020202120'\n         ED    LINE+63(6),D+5\n         SPACE 1\nAMA610   DS    0H\n         BAL   R9,PRINT            PRINT AREA HEADER.\n         BAL   R9,PRINT            PRINT SPACER LINE.\n         LTR   R12,R12             AREA TRACE POAMABLE ?\n         BNP   AMA690              BR IF NOT.\n         L     R5,10(R8)           SET AREA STARTING ADDRESS.\n         LA    R6,0                SET STARTING OFFSET.\n         SPACE 1\nAMA620   DS    0H\n         LA    R4,LINE+2           FORMAT AREA OFFSET.\n         ST    R6,D\n         UNPK  0(5,R4),D+2(3)\n         TR    0(4,R4),TRT1\n         MVI   4(R4),C' '\n         LA    R6,32(R6)           BUMP OFFSET.\n         LA    R7,8                PRINT 8 WORDS PER LINE.\n         MVI   84(R4),C'*'         FORMAT LITERAL BOUNDS.\n         MVI   117(R4),C'*'\n         LA    R1,LINE+87\n         LA    R4,7(R4)            BUMP PRINT POSITION.\n         SPACE 1\nAMA630   DS    0H\n         MVC   0(4,R1),0(R5)       FORMAT LITERAL INTERPRETATION.\n         TR    0(4,R1),TRT\n         UNPK  0(9,R4),0(5,R5)     FORMAT STORAGE 4 BYTES AT A TIME.\n         TR    0(8,R4),TRT1\n         MVI   8(R4),C' '\n         S     R12,=F'4'           DECREMENT BYTE COUNT.\n         BNP   AMA680              BR TO PRINT LAST LINE.\n         LA    R1,4(R1)\n         LA    R4,9(R4)            ONE SPACE BETWEEN WORDS.\n         C     R7,=F'5'            EXCEPT AT QUAD WORDS.\n         BNE   AMA640\n         LA    R4,3(R4)\n         SPACE 1\nAMA640   DS    0H\n         LA    R5,4(R5)            BUMP STORAGE ADDRESS.\n         BCT   R7,AMA630           FORMAT ANOTHER WORD.\n         BAL   R9,PRINT            PRINT 32 BYTES.\n         B     AMA620\n         SPACE 1\nAMA680   DS    0H\n         BZ    AMA685              BR IF EXACT WORD BOUNDARY.\n         LPR   R6,R12              GET EXCESS BYTES PROCESSED.\n         SLL   R6,1                GET DOUBLE FOR HEX.\n         BCTR  R6,0                SET LENGTH FOR EX.\n         A     R12,=F'4'           GET RID OF EXCESS BYTES.\n         SLL   R12,1               GET HEX OFFSET.\n         LA    R4,0(R12,R4)        GET EXCESS HEX ADDRESS.\n         EX    R6,MVC1             CLEAR EXCESS HEX.\n         SRL   R6,1                SET LENGTH FOR LITERAL CLEAR.\n         SRL   R12,1               GET LITERAL OFFSET.\n         LA    R4,0(R12,R1)        GET EXCESS LITERAL ADDRESS.\n         EX    R6,MVC1             CLEAR EXCESS LITERAL.\n         SPACE 1\nAMA685   DS    0H\n         BAL   R9,PRINT            PRINT LAST LINE.\n         BAL   R9,PRINT            PRINT A SPACER LINE.\n         BAL   R9,PRINT\n         SPACE 1\nAMA690   DS    0H\n         LA    R8,16(R8)           POINT TO NEXT AREA ENTRY.\n         BCT   R2,AMA600           PRINT NEXT AREA.\n         BR    R10                 RETURN TO CALLER.\n         EJECT\n*        AMATRACE DATA AREA\n         SPACE 1\nMVC      MVC   LINE(0),0(R1)       MOVE USER MESSAGE TO PRINT LINE.\nMVC1     MVC   0(0,R4),=CL6' '     CLEAR EXCESS BYTES.\nLEVEL    DC    AL1(1)              CURRENT TRACE LEVEL.\nD        DS    D                   SCRATCH AREA.\nSA       DS    18F                 PGM SAVE AREA.\nREGAREA  DS    16F                 REGISTERS AT ENTRY TO TRACE.\nREG      DC    PL2'0'              REGISTER COUNTER.\n         SPACE 1\nVBRECORD DC    H'129'              BLOCK DESCRIPTOR WORD.\n         DC    H'0'                SYSTEM RESERVED.\nRDW      DC    H'125'              RECORD DESCRIPTOR WORD.\n         DC    H'0'                SYSTEM RESERVED.\nLINEM1   DC    CL121' '            PRINT LINE BUFFER.\nLINE     EQU   LINEM1+1            LINE START ADDRESS.\n         SPACE 1\nTRACEOUT DCB   DDNAME=TRACEOUT,DSORG=PS,MACRF=(W),RECFM=VBA,           X\n               LRECL=125,BLKSIZE=882\nTRT      DS    0D\n         DC    64X'4B'\n         DC    X'404B4B4B4B4B4B4B4B4B4A4B4C4D4E4F'\n         DC    X'504B4B4B4B4B4B4B4B4B5A5B5C5D5E5F'\n         DC    X'60614B4B4B4B4B4B4B4B4B6B6C6D6E6F'\n         DC    X'4B4B4B4B4B4B4B4B4B4B7A7B7C7D7E7F'\n         DC    64X'4B'\n         DC    X'4BC1C2C3C4C5C6C7C8C94B4B4B4B4B4B'\n         DC    X'4BD1D2D3D4D5D6D7D8D94B4B4B4B4B4B'\n         DC    X'4B4BE2E3E4E5E6E7E8E94B4B4B4B4B4B'\n         DC    X'F0F1F2F3F4F5F6F7F8F94B4B4B4B4B4B'\nTRT1     EQU   *-240\n         DC    C'0123456789ABCDEF'\n         LTORG\n         END   AMATRACE            END OF TRACE MODULE.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHALIS": {"ttr": 1802, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x02\\x06\\x02\\x06\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 518, "newlines": 518, "modlines": 0, "user": "ARCHIVR"}, "text": "ALIS     TITLE 'ARCHIVER --- ALIAS ADD/DELETE/ALTER FUNCTIONS '\n*---------------------------------------------------------------------*\n*---     THIS ROUTINE PERFORMS THE ADDALIAS/DELALIAS/ALTALIAS      ---*\n*---          FUNCTIONS OF THE ARCHIVER. WHILE THE ADD ALIAS       ---*\n*---          FUNCTION IS FAIRLY STRAIGHTFORWARD, THE DELALIAS IS  ---*\n*---          SLIGHTLY MORE COMPLICATED, DUE TO THE ABILITY TO     ---*\n*---          DELETE ALL ALIASES FOR A PARTICULAR ARCHIVE ITEM.    ---*\n*---          EVEN MORE COMPLEX IS THE ALTALIAS FUNCTION.  HERE'S  ---*\n*---          A BRIEF DESCRIPTION OF HOW EACH MECHANISM WORKS.     ---*\n*---                                                               ---*\n*---     ADDALIAS: THIS FUNCTION WILL LOCATE THE HEADER(S)         ---*\n*---          DESCRIBED IN THE ITEM= OPERAND.  EACH ITEM SO        ---*\n*---          LOCATED WILL HAVE THE ALIAS VALUES FROM THE          ---*\n*---          'ALIAS=' OPERAND ASSIGNED.  IN THIS CASE, IF THE     ---*\n*---          ALIAS OPERAND CONTAINS A GENERIC, THE CORRESPONDING  ---*\n*---          QUALIFIER FROM THE ORIGINAL ITEM IS DUPLICATED INTO  ---*\n*---          THE ALIAS.  ALSO NOTE: YOU MAY NOT ADD AN ALIAS TO   ---*\n*---          AN ALIAS. IF THE ITEM SELECTED IS AN ALIAS, RATHER   ---*\n*---          THAN A REAL MEMBER, THE ALIAS FOUND IS LISTED,       ---*\n*---          ALONG WITH A WARNING MESSAGE.                        ---*\n*---                                                               ---*\n*---     DELALIAS: THIS FUNCTION HAS TWO FLAVORS: DELETE A SINGLE  ---*\n*---          ALIAS OR DELETE ALL THE ALIASES FOR A PARTICULAR     ---*\n*---          REAL MEMBER.  IF THE USER SUPPLIES THE 'ALIAS='      ---*\n*---          OPERAND, A SINGLE ALIAS IS DELETED.  IF THE USER     ---*\n*---          SUPPLIES THE 'ITEM=' OPERAND, ALL ALIASES THAT       ---*\n*---          RELATE TO THAT ITEM, OR GROUP OF ITEMS, ARE          ---*\n*---          DELETED.                                             ---*\n*---                                                               ---*\n*---     CLEAN: THIS FUNCTION WILL RESET THE ALIAS FLAGS           ---*\n*---           THROUGHOUT THE HEADER RECORD KEYRANGE.  IN SO       ---*\n*---           DOING, ITEMS THAT HAVE HAD ALIASES DELETED WILL BE  ---*\n*---           RESET TO SHOW THAT NO ALIASES EXIST, ITEMS THAT     ---*\n*---           HAVE BEEN DELETED WILL HAVE OLD 'ORPHAN' ALIASES    ---*\n*---           DELETED, ETC.  BASICALLY, IT'S A CLEAN UP OF ALL    ---*\n*---           THE SCRAPS LEFT BEHIND BY OTHER ALIAS PROCESSING,   ---*\n*---           OR NON-PROCESSING.                                  ---*\n*---                                                               ---*\n*---------------------------------------------------------------------*\nARCHALIS CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n@RPL1    EQU   R2                  SOME\n@RPL2    EQU   R3                    SPECIAL\n@RPL3    EQU   R4                      EQUATES\n@BUF1    EQU   R5                        FOR\n@BUF2    EQU   R6                          VSAM\n@BUF3    EQU   R7                            I/O MGMT\n         COPY #ARCBITS\n         USING ARCHALIS,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             ALIS ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHALIS,R11        DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             ALIS NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RECOPY BACK POINTER\n         L     R14,12(,R14)        RECOPY ORIG. REG 14\n         LA    R10,0(,R11)         COPY ORIGINAL BASE REGISTER\n         AH    R10,PASSIT-2        BUMP BY A BASE'S WORTH\n         USING ARCHALIS+4096,R10   AND DECLARE IT\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         XC    FCOUNT,FCOUNT       CLEAR FUNCTION RECORD COUNT\n         XC    MCNT,MCNT           AND MEMBER COUNT\n         XC    ACNT,ACNT           AND MIS-MATCH COUNT\n         MVC   VS1MODE,=CL8'OUTPUT' SET THE I/O MODE\n         LA    R1,VSAM1DD          LOAD THE PARM POINTER\n         LA    R0,0                AND THE 'OPEN' FLAG\n         CALL  ARCHVSOP            CALL THE 'OPEN' FUNCTION\n         LTR   R15,R15             OPEN OK ??\n         BNZ   ENDITALL            NOPE; CAN'T WORK\n         L     @RPL1,RPL1          LOAD RPL\n         L     @RPL2,RPL2\n         L     @RPL3,RPL3\n         L     @BUF1,VS1BUF1       AND BUFFER\n         L     @BUF2,VS1BUF2\n         L     @BUF3,VS1BUF3       REGISTERS\n         EJECT\n*---------------------------------------------------------------------*\n*---     DETERMINE JUST WHICH ALIAS-RELATED FUNCTION WE'RE         ---*\n*---           PERFORMING AND CALL THE APPROPRIATE LOCAL           ---*\n*---           SUBROUTINE.                                         ---*\n*---------------------------------------------------------------------*\n         CLC   VERB,=CL12'ADDALIAS' ADDING ALIAS(ES) ??\n         BE    ADDER               YES ---\n         CLC   VERB,=CL12'DELALIAS' DELETING ALIAS(ES) ??\n         BE    DELLER              YES\n         CLC   VERB,=CL12'CLEAN'   RECHECKING AND CLEANING ??\n         BE    CLEANER             YES\n         TITLE 'ALTER --- POINT AN ALIAS AT A DIFFERENT ''REAL'' ITEM'\n*---------------------------------------------------------------------*\n*---     ALTALIAS IS PERFORMED INLINE.                            ----*\n*---------------------------------------------------------------------*\n         SPACE 3\nALTER    DS    0H\n         USING REC,@BUF1           BASE THE RECORD DSECT\n         XC    0(RECKLEN,@BUF1),0(@BUF1) START AT THE BEGINNING !!\n         MVI   RECTT,#RTHDR        INITIAL RECORD TYPE\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,UPD),                            X\n               ARG=(@BUF1),                                            X\n               AREA=(@BUF1),                                           X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         POINT RPL=(@RPL1)         GET TO IT\nAA1      DS    0H\n         GET   RPL=(@RPL1)         AND READ A HEADER RECORD\n         LTR   R15,R15             ANYTHING LEFT ??\n         BNZ   ENDITALL            NOPE; ALL DONE\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\n         #IF   RSRALIAS,OFF,AA1    NOT AN ALIAS RECORD\n         LA    R1,RECAN            POINT TO THE REAL NAME\n         LA    R0,0                USE DEFAULT QUALIFIER DATA\n         CALL  ARCHKNAM            THIS THE ONE WE CHANGE ??\n         LTR   R15,R15             PASS THE CHECK ??\n         BNZ   AA1                 NOPE ---\n         SPACE 3\n*---------------------------------------------------------------------*\n*---     WE'VE FOUND AN ALIAS TO ALTER.  NOW CHECK THE FIELDS,     ---*\n*---     ALTERING AS WE GO, AND REWRITE THE RECORD.                ---*\n*---------------------------------------------------------------------*\n         SPACE 3\n         CLC   QC1,GENQUAL         SAME MEMBER NAME ??\n         BE    *+10                YES ---\n         MVC   RECAN,QC1           NOPE; REPLACE MEMBER NAME\n         CLC   QC2,GENQUAL         SAME GROUP ??\n         BE    *+10                YES ---\n         MVC   RECAG,QC2           NOPE; USE DIFFERENT GROUP\n         CLC   QC3,GENQUAL         SAME SUBGROUP ??\n         BE    *+10                YES ---\n         MVC   RECASG,QC3          NOPE; USE A DIFFERENT ONE\n         CLC   QC4,GENQUAL         SAME TYPE ??\n         BE    *+10                YES ---\n         MVC   RECAT,QC4           NOPE; USE A DIFFERENT ONE\n         NC    QC5,QC5             WAS A VERSION SUPPLIED ??\n         BZ    *+10                NOPE; HIGHEST VERSION NUMBER\n         MVC   RECAVER,QC5         YES; USE IT\n         PUT   RPL=(@RPL1)         WRITE THE UPDATED RECORD\n         LTR   R15,R15             ANYTHING ??\n         BNZ   1(,R15)             NOPE; DIE HORRIBLY\n         L     R15,MCNT            LOAD THE COUNTER\n         LA    R15,1(,R15)         INCREMENT BY ONE\n         ST    R15,MCNT            AND SAVE UPDATED COUNT\n         #FORMAT RECTT,,AA2        OUTPUT THE 'ALIAS IS ALTERED.' MSG\n         #PUT  LINE\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE+1(L'AA3),AA3\n         #FORMAT RECAN,OUT=LINE+L'AA3,CLEAR=NO\n         #PUT  LINE\n         B     AA1                 LOOP FOR MORE ---\nAA2      DC    AL1(19)\n         DC    CL19'ALIAS IS ALTERED.'\nAA3      DC    CL36'          NOW REFERS TO REAL ITEM: '\n         DROP  @BUF1\n         TITLE 'ADDALIAS --- ADD AN ALIAS FOR REAL ITEM(S)'\n*---------------------------------------------------------------------*\n*---     ADDALIAS IS MUCH SIMPLER THAN THE ALTALIAS FUNCTION,      ---*\n*---     IT MAY SEEM INFINITELY WORSE, AT FIRST GLANCE.  WE MARK   ---*\n*---     THE 'REAL ITEM' HEADER TO SHOW THAT IT HAS AT LEAST ONE   ---*\n*---     ALIAS AND REWRITE IT.  THEN, USING A SEPARATE RPL AND     ---*\n*---     BUFFER, WE BUILD AND WRITE THE ALIAS RECORD. BY USING     ---*\n*---     MULTIPLE VSAM STRINGS, WE MAINTAIN POSITIONING AND        ---*\n*---     NEVER HAVE TO 'SAVE' A KEY FOR LATER REPOSITIONING.       ---*\n*---------------------------------------------------------------------*\n         SPACE 3\n**********************+++++++++++++++++++++++++++++++++++++++++\nADDER    DS    0H\n*        MODCB ACB=(*,ACB1),STRNO=1,MF=(E,GENWK)\n         USING REC,@BUF1           BASE THE RECORD DSECT\n         XC    0(RECKLEN,@BUF1),0(@BUF1) START AT THE BEGINNING !!\n         MVI   RECTT,#RTHDR        INITIAL RECORD TYPE\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               ARG=(@BUF1),                                            X\n               AREA=(@BUF1),                                           X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         POINT RPL=(@RPL1)         GET TO IT\nAD1      DS    0H\n         GET   RPL=(@RPL1)         AND READ A HEADER RECORD\n         LTR   R15,R15             ANYTHING LEFT ??\n         BNZ   ENDITALL            NOPE; ALL DONE\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\n         #IF   RSRALIAS,ON,AD1     NOT AN ALIAS RECORD\n         LA    R1,RECN             POINT TO THE REAL NAME\n         LA    R0,0                USE DEFAULT QUALIFIER DATA\n         CALL  ARCHKNAM            ALIAS FOR THIS ONE ??\n         LTR   R15,R15             PASS THE CHECK ??\n         BNZ   AD1                 NOPE ---\n         SPACE 3\n*---------------------------------------------------------------------*\n*---     WE'VE FOUND AN ITEM TO ADD THE ALIAS FOR. NOW BUILD THE   ---*\n*---     ALIAS RECORD AND ADD TO THE CLUSTER.  ALSO, SET THE       ---*\n*---     'HAS ALIASES' FLAG IN THE REAL ITEM'S HEADER.             ---*\n*---------------------------------------------------------------------*\n         SPACE 3\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(DIR,FKS,KEQ,SYN,UPD),                            X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         GET   RPL=(@RPL1)         AND READ A HEADER RECORD\n         LTR   R15,R15             ANYTHING LEFT ??\n         BNZ   ENDITALL            NOPE; ALL DONE\n         #SET  RSRHALS,ON          TURN ON THE 'HAS ALIAS(ES)' FLAG\n         PUT   RPL=(@RPL1)         WRITE THE UPDATED RECORD\n         LTR   R15,R15             ANYTHING ??\n         BNZ   1(,R15)             NOPE; DIE HORRIBLY\n         ENDREQ RPL=(@RPL1)\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         XC    0(256,@BUF2),0(@BUF2) CLEAR THE AREA\n         MVC   RECAN-RECTT(44,@BUF2),RECN COPY THE 'REAL' ITEM KEYS\n         DROP  @BUF1\n         USING REC,@BUF2\n         #SET  RSRALIAS,ON         TURN ON THE ALIAS FLAG\n         MVI   RECTT,#RTHDR        INITIAL RECORD TYPE\n         MVC   RECN(RECKLEN-5),QC1 COPY NEW QUALIFIERS\n         CLC   QC1,GENQUAL         SAME MEMBER NAME ??\n         BNE   *+10                NO ---\n         MVC   RECN,RECAN          YES; REPLACE MEMBER NAME\n         CLC   QC2,GENQUAL         SAME GROUP ??\n         BNE   *+10                NO ---\n         MVC   RECG,RECAG          YES; USE DIFFERENT GROUP\n         CLC   QC3,GENQUAL         SAME SUBGROUP ??\n         BNE   *+10                NO ---\n         MVC   RECSG,RECASG        YES; USE A DIFFERENT ONE\n         CLC   QC4,GENQUAL         SAME TYPE ??\n         BNE   *+10                NO ---\n         MVC   RECT,RECAT          YES; USE A DIFFERENT ONE\n         NC    QC5,QC5             WAS A VERSION SUPPLIED ??\n         BNZ   *+10                NOPE; HIGHEST VERSION NUMBER\n         MVC   RECVER,RECAVER      YES; USE IT\n         MODCB RPL=(@RPL2),AREA=(@BUF2),                               X\n               RECLEN=RECAVER+4-REC,                                   X\n               OPTCD=(DIR,FKS,KGE,SYN,NUP),                            X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         PUT   RPL=(@RPL2)         WRITE THE UPDATED RECORD\n         LTR   R15,R15             ANYTHING ??\n         BZ    AOK                 ALL IS OKAY\n         TESTCB RPL=(@RPL2),FDBK=8,MF=(E,GENWK)\n         BNE   1(,R15)             NOT DUPLICATE RCD. DIE !!\n         #FORMAT RECAN-1,,ADDUP\n         #PUT  LINE                OUTPUT THE 'DUPLICATE ALIAS' MESSAGE\n         B     ADZZ                GO TRY FOR NEXT ALIAS\nAOK      DS    0H\n         L     R15,MCNT            LOAD THE COUNTER\n         LA    R15,1(,R15)         INCREMENT BY ONE\n         ST    R15,MCNT            AND SAVE UPDATED COUNT\n         #FORMAT RECTT,,AD2        OUTPUT THE 'ALIAS IS ADDED.' MSG\n         #PUT  LINE\n         MVC   LINE+1(L'AD3),AD3\n         #FORMAT RECAN-1,OUT=LINE+L'AD3,CLEAR=NO\n         #PUT  LINE\n         DROP  @BUF2\n         USING REC,@BUF1\nADZZ     DS    0H\n         #IF   VRS,ON,ADX\n         LA    R0,0                CLEAR A WORK REGISTER\n         IC    R0,RECT+9           INSERT LAST OF TYPE FIELD\n         AL    R0,=F'1'            INCREMENT IT BY ONE\n         STC   R0,RECT+9           SAVE THE RESULT\n         POINT RPL=(@RPL1)         RESET THE VSAM POINTER\n         B     AD1                 LOOP FOR MORE ---\nADX      DS    0H\n         LA    R0,0                CLEAR A WORK REGISTER\n         IC    R0,RECVER+3         INSERT LAST OF VERSION FIELD\n         AL    R0,=F'1'            INCREMENT IT BY ONE\n         STC   R0,RECVER+3         SAVE THE RESULT\n         POINT RPL=(@RPL1)         RESET THE VSAM POINTER\n         B     AD1                 LOOP FOR MORE ---\nAD2      DC    AL1(19)\n         DC    CL19'ALIAS IS ADDED.'\nAD3      DC    CL32'          REFERS TO REAL ITEM: '\nADDUP    DC    AL1(35)\n         DC    CL35'ALIAS NOT ADDED. DUPLICATE ALIAS.'\n         DROP  @BUF1\n         TITLE 'DELALIAS --- DELETE ALIAS(ES) FOR REAL ITEM(S)'\n*---------------------------------------------------------------------*\n*---     DELALIAS GETS A LITTLE TRICKY.  WE HAVE TWO OPTIONS FOR   ---*\n*---     THIS FUNCTION. WE CAN EITHER DELETE A STRING OF ALIASES,  ---*\n*---     IF NO 'ITEM=' PARAMETER WAS SUPPLIED, OR DELETE ALL       ---*\n*---     ALIASES THAT REFER TO A PARTICULAR ITEM, IF 'ITEM=' WAS   ---*\n*---     SUPPLIED.  OUR TRIGGER IS WHETHER OR NOT THE FIRST        ---*\n*---     CHARACTER OF Q1 IS A BLANK, THE INITIAL VALUE.  USING     ---*\n*---     THIS COMPARE AS A SWITCH, WE WILL EITHER USE THE DEL1     ---*\n*---     ROUTINE OR THE DEL2 ROUTINE.                              ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nDELLER   DS    0H\n         CLI   Q1,C' '             ALL ALIASES FOR AN ITEM ??\n         BNE   DEL2                YES ---\n         SPACE 3\n*---------------------------------------------------------------------*\n*---     DELETE A STRING OF ALIASES ONLY.                         ----*\n*---------------------------------------------------------------------*\n         SPACE 3\nDEL1     DS    0H\n         MVC   Q1(44),QC1          COPY ALIAS VALUES FOR THE CHECKER\n         USING REC,@BUF1           BASE THE RECORD DSECT\n         XC    0(RECKLEN,@BUF1),0(@BUF1) START AT THE BEGINNING !!\n         MVI   RECTT,#RTHDR        INITIAL RECORD TYPE\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,UPD),                            X\n               ARG=(@BUF1),                                            X\n               AREA=(@BUF1),                                           X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         POINT RPL=(@RPL1)         GET TO IT\nDA1      DS    0H\n         GET   RPL=(@RPL1)         AND READ A HEADER RECORD\n         LTR   R15,R15             ANYTHING LEFT ??\n         BNZ   ENDITALL            NOPE; ALL DONE\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\n         #IF   RSRALIAS,OFF,DA1    NOT AN ALIAS RECORD\n         LA    R1,RECN             POINT TO THE ALIAS NAME\n         LA    R0,0                USE DEFAULT QUALIFIER DATA\n         CALL  ARCHKNAM            ALIAS FOR THIS ONE ??\n         LTR   R15,R15             PASS THE CHECK ??\n         BNZ   DA1                 NOPE ---\n         ERASE RPL=(@RPL1)         ERASE THE RECORD\n         LTR   R15,R15             ERASE OK ??\n         BNZ   1(,R15)             NOPE; DIE HORRIBLY\n         L     R15,MCNT            LOAD THE ITEM COUNTER\n         LA    R15,1(,R15)         INCREMENT BY ONE\n         ST    R15,MCNT            AND SAVE UPDATED COUNT\n         #FORMAT RECTT,,DELD       OUTPUT THE 'ALIAS DELETED' MESSAGE\n         #PUT  LINE\n         B     DA1                 YES; CONTINUE\nDELD     DC    AL1(L'DELD1)\nDELD1    DC    CL30' ALIAS IS DELETED.'\n         DROP  @BUF1\n         SPACE 3\n*---------------------------------------------------------------------*\n*---     DELETE ALL THE ALIASES FOR A SPECIFIC ITEM, OR GROUP OF   ---*\n*---     ITEMS.  WE ARE BOUND TO A MECHANISM WHICH MAKES UP IN     ---*\n*---     BRUTE FORCE WHAT IT LACKS IN ELEGANCE.  SEARCH THROUGH    ---*\n*---     ALL THE HEADER RECORDS FOR ANY ALIAS THAT REFERS TO THE   ---*\n*---     SELECTED ITEM AND DELETE THEM ALL.                        ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nDEL2     DS    0H\n         USING REC,@BUF1           BASE THE RECORD DSECT\n         XC    0(RECKLEN,R6),0(R6)    START AT THE BEGINNING !!\n         MVI   RECTT,#RTHDR        INITIAL RECORD TYPE\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,UPD),                            X\n               ARG=(@BUF1),                                            X\n               AREA=(@BUF1),                                           X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         POINT RPL=(@RPL1)         GET TO IT\nDA2      DS    0H\n         GET   RPL=(@RPL1)         AND READ A HEADER RECORD\n         LTR   R15,R15             ANYTHING LEFT ??\n         BNZ   ENDITALL            NOPE; ALL DONE\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\n         #IF   RSRALIAS,OFF,DA2    NOT AN ALIAS RECORD\n         LA    R1,RECAN            POINT TO THE 'REAL' NAME\n         LA    R0,0                USE DEFAULT QUALIFIER DATA\n         CALL  ARCHKNAM            DELETE IT ??\n         LTR   R15,R15             PASS THE CHECK ??\n         BNZ   DA2                 NOPE ---\n         ERASE RPL=(@RPL1)         ERASE THE RECORD\n         LTR   R15,R15             ERASE OK ??\n         BNZ   1(,R15)             NOPE; DIE HORRIBLY\n         L     R15,MCNT            LOAD THE ITEM COUNTER\n         LA    R15,1(,R15)         INCREMENT BY ONE\n         ST    R15,MCNT            AND SAVE UPDATED COUNT\n         #FORMAT RECTT,,DELD       OUTPUT THE 'ALIAS DELETED' MESSAGE\n         #PUT  LINE\n         B     DA2                 YES; CONTINUE\n         DROP  @BUF1\n         TITLE 'CLEAN UP THE ALIAS FLAGS, ETC.'\n*---------------------------------------------------------------------*\n*---     WE LOOP THROUGH THE HEADER RECORDS TWICE FOR THIS        ----*\n*---     PROCESS.  THE FIRST LOOP CONCENTRATES ON THE 'TRUE NAME' ----*\n*---     RECORDS, TURNING OFF THE FLAG BIT THAT INDICATES THE     ----*\n*---     PRESENCE OF ALIASES.  THE SECOND PASS LOCATES ALL THE    ----*\n*---     ALIAS RECORDS AND SETS THE 'ALIASES PRESENT' BIT ON IN   ----*\n*---     THE 'TRUE NAME' RECORD THEY REFER TO.  IF THE 'TRUE      ----*\n*---     NAME' IS NOT PRESENT, THE ALIAS RECORD IS DELETED.       ----*\n*---------------------------------------------------------------------*\nCLEANER  DS    0H\n         L     @RPL1,RPL1          POINT TO THE\n         L     @RPL2,RPL2            VSAM RPLS\n         L     @RPL3,RPL3            VSAM RPLS\n         L     @BUF1,VS1BUF1       LOAD THE BUFFER ADDRESS\n         L     @BUF2,VS1BUF2       LOAD THE BUFFER ADDRESS\n         L     @BUF3,VS1BUF3       LOAD THE BUFFER ADDRESS\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,UPD),                            X\n               ARG=(@BUF1),                                            X\n               AREA=(@BUF1),                                           X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         MODCB RPL=(@RPL2),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,UPD),                            X\n               ARG=(@BUF2),                                            X\n               AREA=(@BUF2),                                           X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         MODCB RPL=(@RPL3),                                            X\n               OPTCD=(DIR,FKS,KEQ,SYN,UPD),                            X\n               ARG=(@BUF1),                                            X\n               AREA=(@BUF1),                                           X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         USING REC,@BUF1           BASE THE RECORD DSECT\n         XC    0(RECKLEN,@BUF1),0(@BUF1) CLEAR THE KEY\n         POINT RPL=(@RPL1)         GET TO IT\nCL1      DS    0H\n         GET   RPL=(@RPL1)         GO READ A RECORD\nCL1A     DS    0H\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   CL2                 NOPE; ALL DONE ---\n         #IF   RSRALIAS,ON,CL1     DON'T TOUCH ALIASES, YET\n         #SET  RSRHALS,OFF         INDICATE NO ALIASES\n         PUT   RPL=(@RPL1)         AND OUTPUT THE RECORD\nCL1B     DS    0H\n         B     CL1                 AND LOOP FOR MORE\nCL2      DS    0H\n         XC    0(RECKLEN,@BUF1),0(@BUF1) RESET TO STARTING KEY\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(NUP),                                            X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\nCL3      DS    0H\n         MVI   RECSEQ#+3,1         INCREMENT THE KEY VALUE\n         POINT RPL=(@RPL1)         RESET TO DATASET START\n         GET   RPL=(@RPL1)         READ A RECORD\nCL3A     DS    0H\n         ENDREQ RPL=(@RPL1)\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE\n         #IF   RSRALIAS,OFF,CL3    NOT AN ALIAS ---\n         XC    0(RECKLEN,@BUF2),0(@BUF2) CLEAR THE KEY AREA\n         MVI   0(@BUF2),#RTHDR     SHOW A HEADER RECORD\n         MVC   1(44,@BUF2),RECAN   MOVE IN THE 'TRUE NAME'\n         MODCB RPL=(@RPL2),                                            X\n               OPTCD=(DIR,FKS,KEQ,SYN,UPD),                            X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         GET   RPL=(@RPL2)         AND FETCH THE RECORD (MAYBE)\nCL3B     DS    0H\n         LTR   R15,R15             WAS IT FOUND ??\n         BNZ   CL4                 NOPE; DELETE THE ALIAS RECORD\n         PUSH  USING\n         USING REC,@BUF2\n         #SET  RSRHALS,ON          SAY IT HAS ALIASES\n         POP   USING\n         PUT   RPL=(@RPL2)         UPDATE THE RECORD\nCL3C     DS    0H\n         B     CL3                 AND CONTINUE ---\nCL4      DS    0H\n         GET   RPL=(@RPL3)         RE-FETCH THE RECORD\nCL4A     DS    0H\n         ERASE RPL=(@RPL3)         DELETE IT\nCL4B     DS    0H\n         B     CL3                 AND CONTINUE ---\n         TITLE 'TERMINATION LINKAGE, ETC. '\n*---------------------------------------------------------------------*\n*---     WRAP UP, CLOSE THE VSAM FILES, FREE THE STORAGE AND       ---*\n*---           RETURN TO ARCHMAIN FOR ANOTHER FUNCTION.            ---*\n*---------------------------------------------------------------------*\nENDITALL DS    0H\n         LA    R1,VSAM1DD          POINT TO THE DDNAME\n         LA    R0,4                SET 'CLOSE' REQUEST\n         CALL  ARCHVSOP            CALL THE VSAM 'CLOSE' ROUTINE\n         #PUT  ERR12\n         L     R0,MCNT             COPY MEMBER COUNT\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,MCMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\n         L     R13,4(,R13)         COPY BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ALWAYS RC = 0\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\n         LTORG\n* ERROR MESSAGES, ETC.\nERR12    DC    CL133'0         ALIAS MANIPULATIONS COMPLETED.  TOTALS FX\n               OLLOW: '\nMCMSG    DC    CL133' '\n         ORG   MCMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202120'\n         DC    C' ALIAS(ES) PROCESSED.'\n         ORG\nGENQUAL  DC    CL10'%%%%%%%%%%'\n         LTORG\nMINREC   DC    A(RECSIZE)\n         COPY  #RECS\n         COPY  ##ARCHWK\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHALT": {"ttr": 2056, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00\\xb0\\x00\\xb0\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 176, "newlines": 176, "modlines": 0, "user": "ARCHIVR"}, "text": "ALT      TITLE 'ARCHIVER --- ALTER SUBROUTINE'\n*---------------------------------------------------------------------*\n*---     THIS SUBROUTINE IS CALLED BY THE ALTER FUNCTION AND THE   ---*\n*---     DELETE FUNCTION.  ITS PURPOSE IS TO MAKE A SPECIFIC KEY   ---*\n*---     CHANGE FOR ALL THE RECORDS OF A SPECIFIED ITEM.  THE      ---*\n*---     PARAMETER LIST CONSISTS OF THE OLD QUALIFIER DATA AND     ---*\n*---     THE NEW QUALIFIER DATA, FROM ITEM NAME THROUGH VERSION    ---*\n*---     NUMBER. EACH RECORD OF THE OLD-QUALIFIER ITEM IS READ,    ---*\n*---     THE KEY VALUES ARE REPLACED AND THE NEW-QUALIFIED RECORD  ---*\n*---     IS WRITTEN.  NO CHECKS ARE MADE TO ASSESS THE VALIDITY    ---*\n*---     OF ANY QUALIFIER DATA, SINCE THE CALLER SHOULD BE MAKING  ---*\n*---     THESE DETERMINATIONS, BASED ON THE FUNCTION.              ---*\n*---                                                               ---*\n*---     PLEASE NOTE: RPL2 AND RPL3 ARE USED AND REPOSITIONED      ---*\n*---     WITHOUT ANY ATTEMPT TO SAVE A PREVIOUS POSITIONING        ---*\n*---     VALUE.  ALSO, VS1BUF3 IS USED FREELY.  THE ASSUMPTION IS  ---*\n*---     THAT THE CALLER HAS OPENED THE APPROPRIATE VSAM CLUSTER   ---*\n*---     AND MADE ALLOWANCES FOR THIS.                             ---*\n*---------------------------------------------------------------------*\nARCHALT  CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n@RPL1    EQU   R2                  SOME SPECIAL EQUATES, FOR ME\n@RPL2    EQU   R3                  SOME SPECIAL EQUATES, FOR ME\n@RPL3    EQU   R4                  SOME SPECIAL EQUATES, FOR ME\n@BUF3    EQU   R7\n         COPY #ARCBITS\n         USING ARCHALT,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             COPY ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHALT,R11         DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             COPY NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RECOPY BACK POINTER\n         L     R14,12(,R14)        RECOPY ORIG. REG 14\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         LM    R8,R9,0(R1)         LOAD THE QUALIFIER POINTERS\n         EJECT\n*---------------------------------------------------------------------*\n*---     HERE'S THE MEAT OF THE PROCESSING. THE BASIC PROCESS IS   ---*\n*---           THIS:                                               ---*\n*---                                                               ---*\n*---     1. USING THE CONTROL INFORMATION WE WERE GIVEN, LOCATE    ---*\n*---        THE HEADER RECORD FOR THE ITEM. WE'LL USE THE VS1BUF3  ---*\n*---        AREA FOR HEADER/KEY CONSTRUCTION.                      ---*\n*---                                                               ---*\n*---     2. UPDATE THE KEY AND OUTPUT THE 'NEW' HEADER RECORD. IF  ---*\n*---        IT'S A DUPLICATE, SET A '4' RETURN CODE AND RETURN TO  ---*\n*---        THE CALLER, SINCE WE CANNOT CONTINUE.                  ---*\n*---                                                               ---*\n*---     3. LOOP THROUGH THE MEMBER, READING THE RECORDS AND       ---*\n*---        COPYING THEM WITH THE UPDATED KEY. WE DO NOT UPDATE    ---*\n*---        ANY SEQUENCE NUMBERS, SINCE THIS IS ITEM-DEPENDANT.    ---*\n*---------------------------------------------------------------------*\n         L     @RPL2,RPL2          LOAD THE SPECIAL\n         L     @RPL3,RPL3            REGISTERS\n         L     @BUF3,VS1BUF3\n         USING REC,@BUF3           BASE THE RECORD DSECT\n         XC    0(RECKLEN,@BUF3),0(@BUF3) START AT THE BEGINNING !!\n         MVC   RECN(44),0(R8)      MOVE IN THE OLD QUALIFIER\n         MVI   RECTT,#RTHDR        START WITH HEADER RECORDS\n         MODCB RPL=(@RPL2),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               ARG=(@BUF3),                                            X\n               AREA=(@BUF3),                                           X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         POINT RPL=(@RPL2)         GET TO IT\n         GET   RPL=(@RPL2)         AND READ A HEADER RECORD\n         LTR   R15,R15             ANYTHING LEFT ??\n         BNZ   ALT5                NOPE; ALL DONE\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ALT5                NOPE; ALL DONE ---\n         CLC   RECN(44),0(R8)      IS THIS THE HEADER WE WANT ??\n         BNE   ALT5                NOPE ---\n         SHOWCB RPL=(@RPL2),                                           X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,VS1LEN3),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\n         MVC   RECN(44),0(R9)      BUILD THE NEW KEY\n         MODCB RPL=(@RPL3),                                            X\n               OPTCD=(DIR,NUP,MVE),                                    X\n               AREA=(@BUF3),                                           X\n               RECLEN=(*,VS1LEN3),                                     X\n               MF=(G,GENWK)\n         PUT   RPL=(@RPL3)         OUTPUT THE RECORD, MAYBE\n         LTR   R15,R15             PUT OK ??\n         BZ    ALT1                YES ---\n         B     ALT6                CAN'T DO IT ---\nALT1     DS    0H\n         XC    0(RECKLEN,@BUF3),0(@BUF3) START AT THE BEGINNING !!\n         MVC   RECN(44),0(R8)      COPY THAT OLD KEY\n         MVI   RECTT,#RTNOTE       RESET TO NOTE TYPE\n         POINT RPL=(@RPL2)         GET TO IT\nALT2     DS    0H\n         GET   RPL=(@RPL2)         GO READ A MEMBER NOTE RECORD\n         LTR   R15,R15             DID IT COMPLETE OK ??\n         BNZ   ALT3                NOPE; ASSUME WE'RE DONE WITH NOTES\n         SHOWCB RPL=(@RPL2),                                           X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,VS1LEN3),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\n         CLI   RECTT,#RTNOTE       DATA RECORD ??\n         BNE   ALT3\n         CLC   RECN(44),0(R8)      STILL IN THE RIGHT ITEM ??\n         BNE   ALT3                NOPE; GO DO THE DATA RECORDS\n         MODCB RPL=(@RPL3),RECLEN=(*,VS1LEN3),MF=(G,GENWK)\n         MVC   RECN(44),0(R9)      BUILD NEW KEY\n         PUT   RPL=(@RPL3)         OUTPUT THE NEW RECORD\n         LTR   R15,R15             WRITE OK ??\n         BZ    ALT2                YES; CONTINUE\n         ABEND 100,DUMP            AND DIE HORRIBLY\nALT3     DS    0H\n         XC    0(RECKLEN,@BUF3),0(@BUF3) START AT THE BEGINNING !!\n         MVC   RECN(44),0(R8)      COPY THAT OLD KEY\n         MVI   RECTT,#RTDATA       RESET TO DATA TYPE\n         POINT RPL=(@RPL2)         GET TO IT\nALT4     DS    0H\n         GET   RPL=(@RPL2)         GO READ A MEMBER DATA RECORD\n         LTR   R15,R15             DID IT COMPLETE OK ??\n         BNZ   ALT5                NOPE; ASSUME WE'RE DONE WITH DATA\n         SHOWCB RPL=(@RPL2),                                           X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,VS1LEN3),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\n         CLI   RECTT,#RTDATA       DATA RECORD ??\n         BNE   ALT5\n         CLC   RECN(44),0(R8)      STILL IN THE RIGHT ITEM ??\n         BNE   ALT5                NOPE; GO DO THE DATA RECORDS\n         MVC   RECN(44),0(R9)      BUILD NEW KEY\n         MODCB RPL=(@RPL3),RECLEN=(*,VS1LEN3),MF=(G,GENWK)\n         PUT   RPL=(@RPL3)         AND WRITE IT\n         LTR   R15,R15             WRITE OK ??\n         BZ    ALT4                YES ---\n         ABEND 101,DUMP            AND DIE HORRIBLY\n         SPACE 3\nALT5     DS    0H\n         MODCB RPL=(@RPL2),AREA=(*,VS1BUF2),MF=(G,GENWK),              X\n               ARG=(*,VS1BUF2)\n         L     R13,4(,R13)         COPY BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               RC = 0\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\nALT6     DS    0H\n         MODCB RPL=(@RPL2),AREA=(*,VS1BUF2),MF=(G,GENWK),              X\n               ARG=(*,VS1BUF2)\n         L     R13,4(,R13)         COPY BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,4               RC = 4\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\n         LTORG\n         COPY  #RECS\n         COPY  ##ARCHWK\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHCOMP": {"ttr": 2305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x01\\x00(\\x00\\x99'\\x0f\\x01\\x02!?\\t!\\x03Y\\x03W\\x00K\\xd4\\xd4\\xe2\\xd4\\xc1\\xd2@@@@\"", "ispf": {"version": "06.01", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "2002-08-01T09:21:28", "lines": 857, "newlines": 855, "modlines": 75, "user": "MMSMAK"}, "text": "COMP     TITLE 'ARCHIVER --- COMPARE FUNCTION'\n*---------------------------------------------------------------------*\n*---     THIS IS THE ARCHIVER CLUSTER-TO-CLUSTER COMPARE           ---*\n*---     FUNCTION.  EACH ITEM IN THE VSAM1 DATASET IS COMPARED TO  ---*\n*---     THE CORRESPONDING ITEM IN THE VSAM2 DATASET, MODIFYING    ---*\n*---     QUALIFIERS AS PROVIDED BY THE USER IN THE CMP1 AND CMP2   ---*\n*---     ARGUMENTS.  MATCHES AND MIS-MATCHES ARE DENOTED BY        ---*\n*---     APPROPRIATE MESSAGES TO SYSPRINT AND THE COMPARE OF TWO   ---*\n*---     ITEMS TERMINATES AT THE FIRST MIS-MATCH.  PLEASE TAKE     ---*\n*---     CAREFUL NOTE: A MIS-MATCH IN NOTE DATA DOES NOT           ---*\n*---     TERMINATE THE COMPARE OPERATION.  IT GENERATES A MESSAGE  ---*\n*---     AND THE COMPARE CONTINUES WITH THE ACTUAL MEMBER DATA.    ---*\n*---                                                               ---*\n*---     IN THIS FUNCTION, GENERICS IN CMP2 QUALIFIERS ARE         ---*\n*---     TREATED DIFFERENTLY THAN THE USUAL GENERICS.  IF A        ---*\n*---     GENERIC QUALIFIER APPEARS IN CMP2, IT SIGNIFIES THAT THE  ---*\n*---     CORRESPONDING VALUE IN CMP1 MUST BE USED.  FOR EXAMPLE,   ---*\n*---     IF THE USER SPECIFIES CMP1=(*,A,B,C),CMP2=(*,Y,*,*)       ---*\n*---     THEN ITEM (XYZ,A,B,C) WILL BE COMPARED TO ITEM            ---*\n*---     (XYZ,Y,B,C).  BECAUSE OF THE NATURE OF THE COMPARE        ---*\n*---     FUNCTION, IT WAS DECIDED THAT A 'BLANKET' COMPARE OF      ---*\n*---     EACH ITEM IN VSAM1 AGAINST ALL ITEMS IN VSAM2 WAS TOO     ---*\n*---     TIME-CONSUMING.                                           ---*\n*---------------------------------------------------------------------*\nARCHCOMP CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n@RPL1    EQU   R2                  SOME\n@RPL2    EQU   R3                    SPECIAL\n@RPL3    EQU   R4                      EQUATES\n@BUF1    EQU   R5                        FOR\n@BUF2    EQU   R6                          VSAM\n@BUF3    EQU   R7                            I/O MGMT\n         COPY #ARCBITS\n         USING ARCHCOMP,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             COMP ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHCOMP,R11        DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             COMP NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RECOPY BACK POINTER\n         L     R14,12(,R14)        RECOPY ORIG. REG 14\n         LA    R10,0(,R11)         COPY ORIGINAL BASE REGISTER\n         AH    R10,PASSIT-2        BUMP BY A BASE'S WORTH\n         USING ARCHCOMP+4096,R10   AND DECLARE IT\n         LA    R9,0(,R10)          COPY SECOND BASE REGISTER\n         AH    R9,PASSIT-2         BUMP BY A BASE'S WORTH\n         USING ARCHCOMP+8192,R9    AND DECLARE IT\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         XC    FCOUNT,FCOUNT       CLEAR FUNCTION RECORD COUNT\n         XC    MCNT,MCNT           AND MEMBER COUNT\n         XC    ACNT,ACNT           AND MIS-MATCH COUNT\n*---------------------------------------------------------------------*\n*---     FIRST, RESOLVE ANY QUALIFIER MATCHING FUNCTION. WE DO     ---*\n*---     THIS BY REPLACING ANY CL10'*' QUALIFIER IN THE CMP2       ---*\n*---     QUALIFIER LIST WITH THE CORRESPONDING VALUE FROM THE      ---*\n*---     CMP1 QUALIFIER LIST.                                      ---*\n*---------------------------------------------------------------------*\n         LA    R3,Q1               POINT TO FIRST CMP1 QUALIFIER\n         LA    R4,10               LOAD QUALIFIER LENGTH\n         LA    R5,Q4               AND LAST QUALIFIER\n         LA    R6,QC1              POINT TO CMP2 LIST\nQR1      DS    0H\n         CLC   0(10,R6),=CL10'%%%%%%%%%%' 'SAME' GENERIC ??\n         BE    QR2                 NOPE ---\n         MVC   0(10,R6),0(R3)      YES; COPY CMP1 VALUE\nQR2      DS    0H\n         BXLE  R3,R4,QR1           LOOP, MOVINGLY (???)\n*---------------------------------------------------------------------*\n*---     NOW OPEN THE VSAM CLUSTERS FOR INPUT.                     ---*\n*---------------------------------------------------------------------*\n         MVC   VS1MODE,=CL8'INPUT' SET THE I/O MODE\n         LA    R1,VSAM1DD          LOAD THE PARM POINTER\n         LA    R0,0                AND THE 'OPEN' FLAG\n         CALL  ARCHVSOP            CALL THE 'OPEN' FUNCTION\n         LTR   R15,R15             OPEN OK ??\n         BNZ   ENDITALL            NOPE; CAN'T WORK\n         MVC   VS2MODE,=CL8'INPUT' SET THE I/O MODE\n         LA    R1,VSAM2DD          LOAD THE PARM POINTER\n         LA    R0,0                AND THE 'OPEN' FLAG\n         CALL  ARCHVSOP            CALL THE 'OPEN' FUNCTION\n         LTR   R15,R15             OPEN OK ??\n         BNZ   ENDITALL            NOPE; CAN'T WORK\n         EJECT\n*---------------------------------------------------------------------*\n*---     HERE'S THE MEAT OF THE PROCESSING. THE BASIC PROCESS IS   ---*\n*---           THIS:                                               ---*\n*---                                                               ---*\n*---     1. USING THE CONTROL INFORMATION WE WERE GIVEN AND THE    ---*\n*---        INFORMATION WE'VE DEVELOPED, LOCATE THE HEADER RECORD  ---*\n*---        FOR THE FIRST MEMBER. WE'LL USE THE VS1BUF1 AREA FOR   ---*\n*---        HEADER/KEY CONSTRUCTION.                               ---*\n*---                                                               ---*\n*---     2. LOCATE THE RELATED MEMBER IN THE VSAM2 CLUSTER. IF     ---*\n*---        NOT PRESENT, ISSUE A MESSAGE AND RETURN TO STEP1 FOR   ---*\n*---        THE NEXT ITEM.  UNTIL I GET THE BASIC COMPARE TO       ---*\n*---        FUNCTION PROPERLY, ARCHIVER-TYPE ALIASES WILL BE       ---*\n*---        IGNORED.  MAYBE LATER, FOLKS!!                         ---*\n*---                                                               ---*\n*---     3. COMPARE THE LMOD FLAGS IN THE TWO HEADERS. IF NOT      ---*\n*---        EQUAL, THE COMPARISON IS COMPLETE AND THE APPROPRIATE  ---*\n*---        MESSAGE IS ISSUED TO THE USER.  THEN GO BACK TO STEP1  ---*\n*---        FOR THE NEXT ITEM IN VSAM1.                            ---*\n*---                                                               ---*\n*---     4. COMPARE THE HEADER DATA IN DETAIL. THAT MEANS THAT WE  ---*\n*---        COMPARE THE RECFM, LRECL (IF NOT RECFM=U), COMPARE THE ---*\n*---        VARIOUS PDS ALIASES, IF ANY, RECORD COUNTS, TIME/DATE  ---*\n*---        OF UNLOAD, SPF STATISTICS IF PRESENT, LKED ATTRIBUTES  ---*\n*---        IF ANY.  MESSAGE ANY MIS-MATCHES AND CONTINUE.         ---*\n*---                                                               ---*\n*---     PLEASE TAKE NOTE: A MIS-MATCH IN RECFM OR LRECL WILL      ---*\n*---     TERMINATE THE COMPARE IMMEDIATELY.  THE COMPARE WILL      ---*\n*---     ALSO BE TERMINATED IF THE RECORD COUNTS OR LOAD-MODULE    ---*\n*---     LENGTHS (FROM PDS DIRECTORY DATA) ARE UNEQUAL.  MISSING   ---*\n*---     ALIASES, UNEQUAL TIME/DATE STAMPS AND BLKSIZES WILL       ---*\n*---     RESULT IN A MESSAGE.  COMPARISONS OF RECFM=U ITEMS WILL   ---*\n*---     BE TERMINATED IF THE BLKSIZE IS UNEQUAL.                  ---*\n*---                                                               ---*\n*---     5. CHECK FOR NOTE DATA.  MESSAGE THE FIRST DIFFERENCE     ---*\n*---        AND CONTINUE WITH THE DATA COMPARISON.                 ---*\n*---                                                               ---*\n*---     6. READ AND DEBLOCK THE DATA RECORDS IN PARALLEL,         ---*\n*---        COMPARING AS WE GO. THE FIRST TIME WE GET A COMPARE    ---*\n*---        THAT FAILS, MESSAGE THAT THE ITEMS ARE UNEQUAL AND     ---*\n*---        TERMINATE THE COMPARE OF THESE TWO ITEMS.              ---*\n*---                                                               ---*\n*---     IF ANY OF THE QUALIFIER VALUES IN CMP2 WERE GENERIC,      ---*\n*---     LOCATE THE NEXT POSSIBLE MATCH AND CONTINUE TO COMPARE    ---*\n*---     TO THIS SAME CMP1 ITEM. OTHERWISE, GO BACK TO STEP1 AND   ---*\n*---     LOCATE THE NEXT VSAM1-ITEM TO BE COMPARED.                ---*\n*---                                                               ---*\n*---------------------------------------------------------------------*\n         EJECT\n*---------------------------------------------------------------------*\n*---     USING VS1BUF1, LOCATE THE FIRST ITEM IN VSAM1 TO BE       ---*\n*---     COMPARED.                                                 ---*\n*---------------------------------------------------------------------*\n         L     R6,VS1BUF1          POINT TO THE VSAM BUFFER\n         USING REC,R6              BASE THE RECORD DSECT\n         XC    0(RECKLEN,R6),0(R6)    START AT THE BEGINNING !!\n         MVI   RECTT,#RTHDR        INITIAL RECORD TYPE\n         MODCB RPL=(*,RPL1),                                           X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               ACB=(*,ACB1),                                           X\n               ARG=(*,VS1BUF1),                                        X\n               AREA=(*,VS1BUF1),                                       X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         L     R1,RPL1             COPY THE RPL ADDRESS\n         POINT RPL=(1)             GET TO IT\nNEXTHDR  DS    0H\n         L     R6,VS1BUF1          POINT TO THE RECORD\n         L     R1,RPL1             COPY RPL ADDRESS\n         GET   RPL=(1)             AND READ A HEADER RECORD\n         LTR   R15,R15             ANYTHING LEFT ??\n         BNZ   ENDITALL            NOPE; ALL DONE\n         SHOWCB RPL=(*,RPL1),                                          X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,VS1LEN1),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\n         #IF   RSRALIAS,ON,NEXTHDR SKIP ALIAS NAMES\n         LA    R1,RECN             POINT TO THE HEADER\n         LA    R0,0                USE DEFAULT QUALIFIER DATA\n         CALL  ARCHKNAM            GO CHECK: DO WE PROCESS THIS ITEM ??\n         LTR   R15,R15             PASS THE CHECK ??\n         BNZ   NEXTHDR             NOPE ---\n         #IF   CMPSHRTL,ON,NOL1    SKIP MSG IF SHORT-FORM LIST\n         #PUT  SEPREC              OUTPUT A LINE OF HYPHENS\n         #FORMAT 0(,R6),,SELECT1   SHOW WE SELECTED THIS ONE\n         #PUT  LINE\nNOL1     DS    0H\n         EJECT\n*---------------------------------------------------------------------*\n*---     THE VSAM1 ITEM IS SELECTED FOR COMPARISON. NOW USE THE    ---*\n*---     VS2 BUFFERS AND RPLS TO LOCATE, IF POSSIBLE, A            ---*\n*---     CORRESPONDING ITEM ON VSAM2 TO COMPARE WITH THE VSAM1     ---*\n*---     ITEM.  WE NEED TO REMEMBER POSITIONING FOR BOTH THE       ---*\n*---     VS2RPL1 AND VS2RPL2 RPLS, SINCE WE MAY HAVE MULTIPLE      ---*\n*---     ITEMS TO COMPARE WITH.                                    ---*\n*---------------------------------------------------------------------*\n         SPACE 3\n         #SET  CMPSRCF,ON          TO START, SHO NO MATCHING ITEM\n         L     R7,VS2BUF1          LOAD VSAM2 BUFFER POINTER\n         DROP  R6\n         USING REC,R7\n         XC    0(RECKLEN,R7),0(R7) INITIALIZE THAT KEY\n         MODCB RPL=(*,RPL4),                                           X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               ACB=(*,ACB2),                                           X\n               ARG=(*,VS2BUF1),                                        X\n               AREA=(*,VS2BUF1),                                       X\n               AREALEN=(S,VS2LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         L     R1,RPL4             LOAD RPL POINTER\n         POINT RPL=(1)             POSITION VSAM2 TO START\nSRCH2    DS    0H\n         L     R2,RPL4             COPY THE RPL ADDRESS\n         GET   RPL=(R2)            GO READ A RECORD, MAYBE ---\n         LTR   R15,R15             ANYTHING ??\n         BNZ   SRCH2A              NOPE; ITEM DOESN'T EXIST\n         SHOWCB RPL=(*,RPL4),                                          X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,VS2LEN1),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\n         CLI   RECTT,#RTHDR        DID WE GET A HEADER RECORD ??\n         BE    SRCH2B              YES; CHECK NAMES FOR A MATCH\nSRCH2A   DS    0H\n         #IF   CMPSRCF,OFF,NEXTHDR\n         MVC   LINE,NOMATCH        SEND THE 'NO-MATCH' MESSAGE\n         #PUT  LINE\n         B     NEXTHDR             AND TRY FOR ANOTHER VSAM1 ITEM\nSRCH2B   DS    0H\n         #IF   RSRALIAS,ON,SRCH2   SKIP ALIAS RECORDS\n         LA    R0,QC1              POINT TO A QUALIFIER\n         LA    R1,OFFN(,R7)        POINT TO RECORD KEY\n         CALL  ARCHKNAM            GO CHECK FOR A INITIAL MATCH\n         LTR   R15,R15             QUALIFIERS FIT ??\n         BNZ   SRCH2               NOPE; KEEP SEARCHING\n         CLC   QC1,=CL10'%%%%%%%%%%' 'SAME VALUE' QUALIFIER ??\n         BNE   SRCH2C              NOPE ---\n         CLC   OFFN(10,R6),OFFN(R7) DO THEY MATCH ??\n         BNE   SRCH2               NOPE; KEEP SEARCHING\nSRCH2C   DS    0H\n         CLC   QC2,=CL10'%%%%%%%%%%' 'SAME VALUE' QUALIFIER ??\n         BNE   SRCH2D              NOPE ---\n         CLC   OFFG(10,R6),OFFG(R7) DO THEY MATCH ??\n         BNE   SRCH2               NOPE; KEEP SEARCHING\nSRCH2D   DS    0H\n         CLC   QC3,=CL10'%%%%%%%%%%' 'SAME VALUE' QUALIFIER ??\n         BNE   SRCH2E              NOPE ---\n         CLC   OFFSG(10,R6),OFFSG(R7) DO THEY MATCH ??\n         BNE   SRCH2               NOPE; KEEP SEARCHING\nSRCH2E   DS    0H\n         CLC   QC4,=CL10'%%%%%%%%%%' 'SAME VALUE' QUALIFIER ??\n         BNE   SRCH2F              NOPE ---\n         CLC   OFFT(10,R6),OFFT(R7) DO THEY MATCH ??\n         BNE   SRCH2               NOPE; KEEP SEARCHING\nSRCH2F   DS    0H\n         #IF   CMPSHRTL,ON,NOL3    SKIP MSG IF SHORT-FORM LIST\n         #FORMAT 0(,R7),,SELECT2 SHOW WHAT WE SELECTED\n         #PUT  LINE\nNOL3     DS    0H\n         DROP  R7                  DISCARD THAT BASE, FOR NOW\n         EJECT\n*---------------------------------------------------------------------*\n*---     VS1BUF1 AND VS2BUF1 BOTH CONTAIN THE HEADERS OF A PAIR    ---*\n*---     OF ITEMS TO BE COMPARED.  AT THIS POINT, WE MUST COMPARE  ---*\n*---     THE BASIC FIELDS OF THE HEADER RECORD AND MAKE SOME       ---*\n*---     CRITICAL DECISIONS.  LIKE, WHETHER OR NOTE TO CONTINUE.   ---*\n*---------------------------------------------------------------------*\n         SPACE 3\n         #SET  CMPHDRF,OFF         ASSUME IT'S A MATCH, FOR NOW\n         #SET  CMPSRCF,OFF         SHOW WE HAD ONE CORRESPONDING ITEM\n         #SET  CMPABTF,OFF         ASSUME IT'S A MATCH, FOR NOW\n         #SET  CMPDATF,OFF         ASSUME IT'S A MATCH, FOR NOW\n         #SET  CMPNTDF,OFF         ASSUME IT'S A MATCH, FOR NOW\n*---------------------------------------------------------------------*\n*---     COMPARE LMOD FLAGS. ABORT ON MIS-MATCH                    ---*\n*---------------------------------------------------------------------*\n         CLC   OFFLMOD(1,R6),OFFLMOD(R7) BOTH LMODS ?? (OR NOT)\n         BE    HC1                 YES ---\n         MVC   LINE,FM1            MOVE A MESSAGE\n         #PUT  LINE                OUTPUT THE MESSAGE\n         B     SRCH2               AND KEEP SEARCHING ---\nHC1      DS    0H\n*---------------------------------------------------------------------*\n*---     COMPARE RECFM FIELDS. ABORT ON MIS-MATCH                  ---*\n*---------------------------------------------------------------------*\n         CLC   OFFREC(1,R6),OFFREC(R7) COMPARE RECFM'S\n         BE    HC2                 ALL MATCHES ---\n         #SET  CMPABTF,ON          SET THE ABORT FLAG\n         #SET  CMPHDRF,ON          SHOW FAILURE IN HEADER COMPARE\n         #IF   CMPSHRTL,ON,NOL5    SKIP MSG IF SHORT-FORM LIST\n         MVC   LINE,FM2            COPY THE FAILURE MESSAGE\n         #PUT  LINE                AND PRINT IT\nNOL5     DS    0H\nHC2      DS    0H\n*---------------------------------------------------------------------*\n*---     COMPARE LRECL FIELDS. ABORT ON MIS-MATCH                  ---*\n*---------------------------------------------------------------------*\n         TM    OFFREC(R6),X'C0'    RECFM = U ??\n         BO    HC4                 YES ---\n         TM    OFFREC(R7),X'C0'    RECFM = U ??\n         BO    HC4                 YES ---\n         CLC   OFFLRE(2,R6),OFFLRE(R7) COMPARE LRECLS\n         BE    HC3                 ALL MATCHES ---\n         #SET  CMPABTF,ON          SET THE ABORT FLAG\n         #SET  CMPHDRF,ON          SHOW FAILURE IN HEADER COMPARE\n         #IF   CMPSHRTL,ON,NOL6    SKIP MSG IF SHORT-FORM LIST\n         MVC   LINE,FM3            COPY THE FAILURE MESSAGE\n         #PUT  LINE                AND PRINT IT\nNOL6     DS    0H\nHC3      DS    0H\n         B     HC5                 SKIP BLKSIZE COMPARE\nHC4      DS    0H\n*---------------------------------------------------------------------*\n*---     COMPARE BLKSIZE FIELDS FOR RECFM=U ITEMS.                 ---*\n*---------------------------------------------------------------------*\n         CLC   OFFBLK(2,R6),OFFBLK(R7) COMPARE BLKSIZE VALUES\n         BE    HC5                 ALL MATCHES ---\n         #SET  CMPABTF,ON          SET THE ABORT FLAG\n         #SET  CMPHDRF,ON          SHOW FAILURE IN HEADER COMPARE\n         #IF   CMPSHRTL,ON,NOL7    SKIP MSG IF SHORT-FORM LIST\n         MVC   LINE,FM4            COPY THE FAILURE MESSAGE\n         #PUT  LINE                AND PRINT IT\nNOL7     DS    0H\nHC5      DS    0H\n*---------------------------------------------------------------------*\n*---     COMPARE LOGICAL RECORD COUNTS                             ---*\n*---------------------------------------------------------------------*\n         CLC   OFFRCNT(4,R6),OFFRCNT(R7) COMPARE COUNT VALUES\n         BE    HC6                 ALL MATCHES ---\n         #SET  CMPABTF,ON          SET THE ABORT FLAG\n         #SET  CMPHDRF,ON          SHOW FAILURE IN HEADER COMPARE\n         #IF   CMPSHRTL,ON,NOL8    SKIP MSG IF SHORT-FORM LIST\n         MVC   LINE,FM6            COPY THE FAILURE MESSAGE\n         #PUT  LINE                AND PRINT IT\nNOL8     DS    0H\nHC6      DS    0H\n*---------------------------------------------------------------------*\n*---     COMPARE NOTEDATA RECORD COUNTS                            ---*\n*---------------------------------------------------------------------*\n         CLC   OFFNOT#(4,R6),OFFNOT#(R7) COMPARE BLKSIZE VALUES\n         BE    HC7                 ALL MATCHES ---\n         #SET  CMPHDRF,ON          SHOW FAILURE IN HEADER COMPARE\n         MVC   LINE,FM7            COPY THE FAILURE MESSAGE\n         #IF   CMPSHRTL,ON,NOL9    SKIP MSG IF SHORT-FORM LIST\n         #PUT  LINE                AND PRINT IT\nNOL9     DS    0H\nHC7      DS    0H\n*---------------------------------------------------------------------*\n*---     COMPARE UNLOAD DATE VALUES                                ---*\n*---------------------------------------------------------------------*\n         CLC   OFFDATE(4,R6),OFFDATE(R7) COMPARE DATE VALUES\n         BE    HC8                 ALL MATCHES ---\n         #SET  CMPHDRF,ON          SHOW FAILURE IN HEADER COMPARE\n         MVC   LINE,FM8            COPY THE FAILURE MESSAGE\n         #IF   CMPSHRTL,ON,NOL10   SKIP MSG IF SHORT-FORM LIST\n         #PUT  LINE                AND PRINT IT\nNOL10    DS    0H\nHC8      DS    0H\n*---------------------------------------------------------------------*\n*---     COMPARE UNLOAD TIME VALUES                                ---*\n*---------------------------------------------------------------------*\n         CLC   OFFTIME(4,R6),OFFTIME(R7) COMPARE DATE VALUES\n         BE    HC9                 ALL MATCHES ---\n         #SET  CMPHDRF,ON          SHOW FAILURE IN HEADER COMPARE\n         MVC   LINE,FM9            COPY THE FAILURE MESSAGE\n         #IF   CMPSHRTL,ON,NOL11   SKIP MSG IF SHORT-FORM LIST\n         #PUT  LINE                AND PRINT IT\nNOL11    DS    0H\nHC9      DS    0H\n*---------------------------------------------------------------------*\n*---     PRINT 'COMPARE FAILED' MESSAGE IF CMPABTF FLAG SET.       ---*\n*---------------------------------------------------------------------*\n         #IF   CMPABTF,OFF,GDCMP   GOOD COMPARE\n         #IF   CMPSHRTL,OFF,NOF1\n         L     R6,VS1BUF1\n         L     R7,VS2BUF1\n         #FORMAT 0(,R6),,SELECT1\n         #PUT  LINE\n         #FORMAT 0(,R7),,SELECT2\n         #PUT  LINE\nNOF1     DS    0H\n         MVC   LINE,FM5            COPY THE MESSAGE\n         #PUT  LINE                OUTPUT THE MESSAGE\n         B     SRCH2               GO FIND ANOTHER SELECTION\nGDCMP    DS    0H\n         MVC   LINE,SC1            COPY 'SUCCESSFUL COMPARE' MESSAGE\n         #IF   CMPSHRTL,ON,NOL13   SKIP MSG IF SHORT-FORM LIST\n         #PUT  LINE                OUTPUT THAT MESSAGE\nNOL13    DS    0H\n         EJECT\n*---------------------------------------------------------------------*\n*---     ALL COMPARES FOR THE HEADER RECORD ARE COMPLETE. NOT, IF  ---*\n*---     BOTH HAVE NOTEDATA RECORDS, WE NEED TO FETCH AND COMPARE  ---*\n*---     THE NOTE DATA.  IF ONE HAS NOTE DATA RECORDS AND THE      ---*\n*---     OTHER DOESN'T, WE BYPASS THIS COMPARISON, FOR OBVIOUS     ---*\n*---     REASONS.                                                  ---*\n*---------------------------------------------------------------------*\n         CLC   OFFNOT#(4,R6),=F'0' COMPARE NOTEDATA COUNTS\n         BE    CMPDAT              NOTE HERE ---\n         CLC   OFFNOT#(4,R7),=F'0' COMPARE NOTEDATA COUNTS\n         BE    CMPDAT              NOTE HERE ---\n*---------------------------------------------------------------------*\n*---     BOTH ITEMS HAVE NOTE DATA. USING THE NUMBER-2 BUFFERS     ---*\n*---     AND RPLS FOR EACH ARCHIVE CLUSTER, POINT TO THE ACTUAL    ---*\n*---     NOTE DATA RECORDS AND START FETCHING LOGICAL RECORDS FOR  ---*\n*---     COMPARISON.                                               ---*\n*---------------------------------------------------------------------*\n         L     R2,VS1BUF2          VSAM1'S #2 BUFFER\n         L     R3,VS2BUF2          VSAM2'S #2 BUFFER\n         MVC   0(RECKLEN,R2),0(R6) COPY VSAM1 KEY\n         MVC   0(RECKLEN,R3),0(R7) COPY VSAM2 KEY\n         MVI   0(R2),#RTNOTE       RECTYPE = NOTE DATA\n         MVI   0(R3),#RTNOTE       RECTYPE = NOTE DATA\n         LR    R6,R2               COPY BUFFER ADDRESS\n         LR    R7,R3               DITTO ---\n         XC    BLDLAREA,BLDLAREA   SAVE AREA FOR DEBLOCKING STUFF\n         L     R2,RPL2             POINT TO AN RPL\n         L     R3,RPL5             AND A SECOND RPL\n         MODCB RPL=(R2),                                               X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               ACB=(*,ACB1),                                           X\n               ARG=(R6),                                               X\n               AREA=(R6),                                              X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         POINT RPL=(2)             GET TO IT\n         GET   RPL=(2)\n         SHOWCB RPL=(*,RPL2),                                          X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,VS1LEN2),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\n         MODCB RPL=(R3),                                               X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               ACB=(*,ACB2),                                           X\n               ARG=(R7),                                               X\n               AREA=(R7),                                              X\n               AREALEN=(*,VS2LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         POINT RPL=(3)             GET TO IT\n         GET   RPL=(3)\n         SHOWCB RPL=(*,RPL5),                                          X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,VS2LEN2),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\n*---------------------------------------------------------------------*\n*---     AT THIS POINT, THE FIRST ARCHIVE RECORD OF NOTE DATA IS   ---*\n*---     IN STORAGE, IN THE NUMBER-2 BUFFERS.  HERE'S WHERE THE    ---*\n*---     DEBLOCKING AND COMPARING GET REAL HAIRY.  SINCE THE       ---*\n*---     VSAM1 AND VSAM2 CLUSTERS MAY HAVE DIFFERRING RECORD       ---*\n*---     LENGTHS, EACH VSAM RECORD MUST BE DE-BLOCKED INTO         ---*\n*---     INDIVIDUAL ARCHIVER-STYLE LOGICAL RECORDS FOR THE         ---*\n*---     COMPARISON.  A CLCL INSTRUCTION THAT SUCCEEDS WILL        ---*\n*---     UPDATE THE SOURCE AND COUNT REGISTERS, SAVING ME A FEW    ---*\n*---     HEADACHES. FOR THAT REASON, MY REGISTER USAGE MAY SEEM A  ---*\n*---     LITTLE STRANGE.  T2/T3 WILL BE THE SOURCE/COUNT           ---*\n*---     REGISTERS FOR THE VSAM1 RECORDS AND R4/R5 WILL BE THE     ---*\n*---     CORRESPONDING REGISTERS FOR THE VSAM2 RECORDS.  R6 WILL   ---*\n*---     POINT TO THE VERY LAST BYTE OF THE VSAM1 RECORD AND R7    ---*\n*---     THE SAME FOR THE VSAM2 RECORD.  SINCE THE VSAM ACCESS IS  ---*\n*---     SEQUENTIAL, I DON'T NEED ANOTHER 'POINT' BUT I DO NEED    ---*\n*---     TO CHECK THE KEY VALUES AFTER EACH 'GET' TO BE SURE THAT  ---*\n*---     I HAVEN'T RUN OUT OF THE CURRENT ITEM'S NOTE RECORDS      ---*\n*---     PREMATURELY.                                              ---*\n*---------------------------------------------------------------------*\n         LA    R2,RECKLEN(,R6)     POINT TO SOURCE DATA\n         LA    R4,RECKLEN(,R7)     DITTO FOR THE SECOND RECORD\n         A     R6,VS1LEN2          ADD THE BLOCK LENGTH\n         BCTR  R6,R0               BACK UP TO LAST BYTE\n         A     R7,VS2LEN2          ADD THE BLOCK LENGTH\n         BCTR  R7,R0               BACK UP TO LAST BYTE\nNOTEA    DS    0H\n         LTR   R2,R2               INPUT ADDRESS ZERO ??\n         BZ    *+16                YES; DON'T GET A LENGTH\n         LA    R3,0                CLEAR THE LENGTH\n         ICM   R3,7,0(R2)          AND INSERT THE LENGTH TO COMPARE\n         LA    R3,3(,R3)           ACCOUNT FOR SEGMENT HEADER\n         LTR   R4,R4               INPUT ADDRESS ZERO ??\n         BZ    *+16                YES; DON'T GET A LENGTH\n         LA    R5,0\n         ICM   R5,7,0(R4)          AND ITS LENGTH\n         LA    R5,3(,R5)           ACCOUNT FOR SEGMENT HEADER\n         CLCL  R2,R4               COMPARE ---\n         BNE   NOTEH               MIS-MATCH; ALL DONE HERE\n         CR    R2,R6               AT RECORD END ??\n         BL    NOTED               NOPE ---\n         L     R1,RPL2             YES; LOAD RPL POINTER\n         GET   RPL=(1)             READ ANOTHER 'BLOCK'\n         LTR   R15,R15             ANYTHING COME BACK ??\n         BNZ   NOTEB               NOPE; ALL DONE\n         SHOWCB RPL=(*,RPL2),                                          X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,VS1LEN2),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\n         L     R6,VS1BUF1          LOAD THE HEADER'S ADDRESS\n         L     R1,VS1BUF2          AND THIS RECORD'S ADDRESS\n         CLC   1(44,R1),1(R6)      SAME KEY VALUES ??\n         BE    NOTEC               YES; CONTINUE SETUP\nNOTEB    DS    0H\n         LA    R2,0                CLEAR THE SOURCE ADDRESS\n         LR    R3,R3               AND LENGTH\n         B     NOTED               AND CONTINUE\nNOTEC    DS    0H\n         LA    R2,RECKLEN(,R1)     POINT TO FIRST NOTEDATA SEGMENT\n         LR    R6,R1               COPY THE RECORD POINTER\n         A     R6,VS1LEN2          ADD ITS LENGTH\n         BCTR  R6,R0               BACK UP TO LAST BYTE\nNOTED    DS    0H\n         STM   R2,R3,BLDLAREA      SAVE IN CHECKING AREA\n         CR    R4,R7               AT RECORD END ??\n         BL    NOTEG               NOPE ---\n         L     R1,RPL5             YES; LOAD RPL POINTER\n         GET   RPL=(1)             READ ANOTHER 'BLOCK'\n         LTR   R15,R15             ANYTHING COME BACK ??\n         BNZ   NOTEE               NOPE; ALL DONE\n         SHOWCB RPL=(*,RPL5),                                          X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,VS2LEN2),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\n         L     R7,VS2BUF1          LOAD THE HEADER'S ADDRESS\n         L     R1,VS2BUF2          AND THIS RECORD'S ADDRESS\n         CLC   1(44,R1),1(R7)      SAME KEY VALUES ??\n         BE    NOTEF               YES; CONTINUE SETUP\nNOTEE    DS    0H\n         LA    R4,0                CLEAR COMPARAND ADDRESS\n         LR    R5,R4               AND LENGTH\n         B     NOTEG               AND CONTINUE\nNOTEF    DS    0H\n         LA    R4,RECKLEN(,R1)     POINT TO FIRST NOTEDATA SEGMENT\n         LR    R7,R1               COPY THE RECORD POINTER\n         A     R7,VS2LEN2          ADD ITS LENGTH\n         BCTR  R6,R0               BACK UP TO LAST BYTE\nNOTEG    DS    0H\n         STM   R4,R5,BLDLAREA+8    SAVE IN CHECKING AREA\n         CLC   BLDLAREA(16),=4F'0' ALL ZEROS ??\n         BNE   NOTEA               NOTE; MORE TO CHECK ---\n         MVC   LINE,NOTEOK         MOVE 'COMPARE MATCHED' MESSAGE\n         #IF   CMPSHRTL,ON,NOL14   SKIP MSG IF SHORT-FORM LIST\n         #PUT  LINE                AND PRINT IT OUT\nNOL14    DS    0H\n         B     CMPDAT              AND TRY AGAIN\nNOTEH    DS    0H\n         MVC   LINE,NOTEFAIL       NOTEDATA COMPARE FAILED\n         #PUT  LINE                OUTPUT THE MESSAGE\n         B     CMPDAT              AND TRY AGAIN\nCMPDAT   DS    0H\n         EJECT\n*---------------------------------------------------------------------*\n*---     HEADER AND NOTEDATA RECORD COMPARES ARE COMPLETE. NOW     ---*\n*---     START COMPARING THE DATA RECORDS. THE CODE IS THE SAME,   ---*\n*---     EXCEPT FOR THE FIRST BYTE OF THE KEY OF EACH RECORD TO    ---*\n*---     BE EXAMINED.                                              ---*\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n*---     AGAIN, WE USE THE NUMBER-2 BUFFERS AND RPLS.              ---*\n*---------------------------------------------------------------------*\n         L     R6,VS1BUF1          VSAM1'S #2 BUFFER\n         L     R7,VS2BUF1          VSAM2'S #2 BUFFER\n         L     R2,VS1BUF2          VSAM1'S #2 BUFFER\n         L     R3,VS2BUF2          VSAM2'S #2 BUFFER\n         MVC   0(RECKLEN,R2),0(R6) COPY VSAM1 KEY\n         MVC   0(RECKLEN,R3),0(R7) COPY VSAM2 KEY\n         MVI   0(R2),#RTDATA       RECTYPE = NOTE DATA\n         MVI   0(R3),#RTDATA       RECTYPE = NOTE DATA\n         LR    R6,R2               COPY BUFFER ADDRESS\n         LR    R7,R3               DITTO ---\n         XC    BLDLAREA,BLDLAREA   SAVE AREA FOR DEBLOCKING STUFF\n         L     R2,RPL2             POINT TO AN RPL\n         L     R3,RPL5             AND A SECOND RPL\n         MODCB RPL=(R2),                                               X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               ACB=(*,ACB1),                                           X\n               ARG=(R6),                                               X\n               AREA=(R6),                                              X\n               AREALEN=(S,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         POINT RPL=(2)             GET TO IT\n         GET   RPL=(2)\n         SHOWCB RPL=(*,RPL2),                                          X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,VS1LEN2),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\n         MODCB RPL=(R3),                                               X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               ACB=(*,ACB2),                                           X\n               ARG=(R7),                                               X\n               AREA=(R7),                                              X\n               AREALEN=(S,VS2LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         POINT RPL=(3)             GET TO IT\n         GET   RPL=(3)\n         SHOWCB RPL=(*,RPL5),                                          X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,VS2LEN2),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\n*---------------------------------------------------------------------*\n*---     AT THIS POINT, THE FIRST ARCHIVE RECORD OF ITEM DATA IS   ---*\n*---     IN STORAGE, IN THE NUMBER-2 BUFFERS.  HERE'S WHERE THE    ---*\n*---     DEBLOCKING AND COMPARING GET REAL HAIRY.  SINCE THE       ---*\n*---     VSAM1 AND VSAM2 CLUSTERS MAY HAVE DIFFERRING RECORD       ---*\n*---     LENGTHS, EACH VSAM RECORD MUST BE DE-BLOCKED INTO         ---*\n*---     INDIVIDUAL ARCHIVER-STYLE LOGICAL RECORDS FOR THE         ---*\n*---     COMPARISON.  A CLCL INSTRUCTION THAT SUCCEEDS WILL        ---*\n*---     UPDATE THE SOURCE AND COUNT REGISTERS, SAVING ME A FEW    ---*\n*---     HEADACHES. FOR THAT REASON, MY REGISTER USAGE MAY SEEM A  ---*\n*---     LITTLE STRANGE.  R2/R3 WILL BE THE SOURCE/COUNT           ---*\n*---     REGISTERS FOR THE VSAM1 RECORDS AND R4/R5 WILL BE THE     ---*\n*---     CORRESPONDING REGISTERS FOR THE VSAM2 RECORDS.  R6 WILL   ---*\n*---     POINT TO THE VERY LAST BYTE OF THE VSAM1 RECORD AND R7    ---*\n*---     THE SAME FOR THE VSAM2 RECORD.  SINCE THE VSAM ACCESS IS  ---*\n*---     SEQUENTIAL, I DON'T NEED ANOTHER 'POINT' BUT I DO NEED    ---*\n*---     TO CHECK THE KEY VALUES AFTER EACH 'GET' TO BE SURE THAT  ---*\n*---     I HAVEN'T RUN OUT OF THE CURRENT ITEM'S DATA RECORDS      ---*\n*---     PREMATURELY.                                              ---*\n*---------------------------------------------------------------------*\n         LA    R2,RECKLEN(,R6)     POINT TO SOURCE DATA\n         LA    R4,RECKLEN(,R7)     DITTO FOR THE SECOND RECORD\n         A     R6,VS1LEN2          ADD THE BLOCK LENGTH\n         BCTR  R6,R0               BACK UP TO LAST BYTE\n         A     R7,VS2LEN2          ADD THE BLOCK LENGTH\n         BCTR  R7,R0               BACK UP TO LAST BYTE\nDATAA    DS    0H\n         LTR   R2,R2               INPUT ADDRESS ZERO ??\n         BZ    *+16                YES; DON'T GET A LENGTH\n         LA    R3,0                CLEAR THE LENGTH\n         ICM   R3,7,0(R2)          AND INSERT THE LENGTH TO COMPARE\n         LA    R3,3(,R3)           ACCOUNT FOR SEGMENT HEADER\n         LTR   R4,R4               INPUT ADDRESS ZERO ??\n         BZ    *+16                YES; DON'T GET A LENGTH\n         LA    R5,0\n         ICM   R5,7,0(R4)          AND ITS LENGTH\n         LA    R5,3(,R5)           ACCOUNT FOR SEGMENT HEADER\n         CLCL  R2,R4               COMPARE ---\n         BNE   DATAH               MIS-MATCH; ALL DONE HERE\n         CR    R2,R6               AT RECORD END ??\n         BL    DATAD               NOPE ---\n         L     R1,RPL2             YES; LOAD RPL POINTER\n         GET   RPL=(1)             READ ANOTHER 'BLOCK'\n         LTR   R15,R15             ANYTHING COME BACK ??\n         BNZ   DATAB               NOPE; ALL DONE\n         SHOWCB RPL=(*,RPL2),                                          X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,VS1LEN2),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\n         L     R6,VS1BUF1          LOAD THE HEADER'S ADDRESS\n         L     R1,VS1BUF2          AND THIS RECORD'S ADDRESS\n         CLC   1(44,R1),1(R6)      SAME KEY VALUES ??\n         BE    DATAC               YES; CONTINUE SETUP\nDATAB    DS    0H\n         LA    R2,0                CLEAR THE SOURCE ADDRESS\n         LR    R3,R3               AND LENGTH\n         B     DATAD               AND CONTINUE\nDATAC    DS    0H\n         LA    R2,RECKLEN(,R1)     POINT TO FIRST DATADATA SEGMENT\n         LR    R6,R1               COPY THE RECORD POINTER\n         A     R6,VS1LEN2          ADD ITS LENGTH\n         BCTR  R6,R0               BACK UP TO LAST BYTE\nDATAD    DS    0H\n         STM   R2,R3,BLDLAREA      SAVE IN CHECKING AREA\n         CR    R4,R7               AT RECORD END ??\n         BL    DATAG               NOPE ---\n         L     R1,RPL5             YES; LOAD RPL POINTER\n         GET   RPL=(1)             READ ANOTHER 'BLOCK'\n         LTR   R15,R15             ANYTHING COME BACK ??\n         BNZ   DATAE               NOPE; ALL DONE\n         SHOWCB RPL=(*,RPL5),                                          X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,VS2LEN2),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\n         L     R7,VS2BUF1          LOAD THE HEADER'S ADDRESS\n         L     R1,VS2BUF2          AND THIS RECORD'S ADDRESS\n         CLC   1(44,R1),1(R7)      SAME KEY VALUES ??\n         BE    DATAF               YES; CONTINUE SETUP\nDATAE    DS    0H\n         LA    R4,0                CLEAR COMPARAND ADDRESS\n         LR    R5,R4               AND LENGTH\n         B     DATAG               AND CONTINUE\nDATAF    DS    0H\n         LA    R4,RECKLEN(,R1)     POINT TO FIRST DATADATA SEGMENT\n         LR    R7,R1               COPY THE RECORD POINTER\n         A     R7,VS2LEN2          ADD ITS LENGTH\n         BCTR  R6,R0               BACK UP TO LAST BYTE\nDATAG    DS    0H\n         STM   R4,R5,BLDLAREA+8    SAVE IN CHECKING AREA\n         CLC   BLDLAREA(16),=4F'0' ALL ZEROS ??\n         BNE   DATAA               NOTE; MORE TO CHECK ---\n         #IF   CMPSHRTL,ON,NOL16   SKIP MSG IF SHORT-FORM LIST\n         MVC   LINE,DATAOK         MOVE 'COMPARE MATCHED' MESSAGE\n         #PUT  LINE                AND PRINT IT OUT\nNOL16    DS    0H\n         B     SRCH2               AND TRY AGAIN\nDATAH    DS    0H\n         #IF   CMPSHRTL,OFF,NOF2\n         L     R6,VS1BUF1\n         L     R7,VS2BUF1\n         #FORMAT 0(,R6),,SELECT1\n         #PUT  LINE\n         #FORMAT 0(,R7),,SELECT2\n         #PUT  LINE\nNOF2     DS    0H\n         MVC   LINE,DATAFAIL       DATADATA COMPARE FAILED\n         #PUT  LINE                OUTPUT THE MESSAGE\n         B     SRCH2               AND TRY AGAIN\n*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*\n         B     SRCH2               AND TRY AGAIN\nENDITALL DS    0H\n         #PUT  SEPREC\n         #PUT  COMPCOMP\n         LA    R1,VSAM1DD          POINT TO THE DDNAME\n         LA    R0,4                SET 'CLOSE' REQUEST\n         CALL  ARCHVSOP            CALL THE VSAM 'CLOSE' ROUTINE\n         LA    R1,VSAM2DD          POINT TO THE DDNAME\n         LA    R0,4                SET 'CLOSE' REQUEST\n         CALL  ARCHVSOP            CALL THE VSAM 'CLOSE' ROUTINE\n         L     R13,4(,R13)         COPY BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ALWAYS RC = 0\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\nERR12    DC    CL133'0          COMPARE PROCESSING COMPLETED.  TOTALS FX\n               OLLOW: '\nMCMSG    DC    CL133' '\n         ORG   MCMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202120'\n         DC    C' TOTAL ITEM(S) PROCESSED.'\n         ORG\n         LTORG\nSEPREC   DC    CL1' ',132C'-'\nCOMPCOMP DC    CL133'          ARCHIVER COMPARE FUNCTION IS COMPLETE.'\nFM1      DC    CL133'          LMOD FLAGS MISMATCH. FURTHER COMPARES ABX\n               ORTED.'\nFM2      DC    CL133'          RECFM VALUES MISMATCH. HEADER CHECKS WILX\n               L CONTINUE.'\nFM3      DC    CL133'          LRECL VALUES MISMATCH. HEADER CHECKS WILX\n               L CONTINUE.'\nFM4      DC    CL133'          BLKSIZE VALUES MISMATCH. HEADER CHECKS WX\n               ILL CONTINUE.'\nFM5      DC    CL133'          HEADER COMPARE FAILED. REMAINDER OF COMPX\n               ARE IS BYPASSED.'\nFM6      DC    CL133'          RECORD COUNTS MISMATCH. HEADER CHECKS WIX\n               LL CONTINUE.'\nFM7      DC    CL133'          NOTE RECORD COUNTS MISMATCH.  HEADER CHEX\n               CKS WILL CONTINUE.'\nFM8      DC    CL133'          UNLOAD DATES MISMATCH.  HEADER CHECKS WIX\n               LL CONTINUE.'\nFM9      DC    CL133'          UNLOAD TIMES MISMATCH.  HEADER CHECKS WIX\n               LL CONTINUE.'\nSC1      DC    CL133'          HEADER COMPARE SUCCEEDED.  PROCEEDING TOX\n                COMPARE NOTE AND DATA RECORDS.'\nNOTEOK   DC    CL133'          COMPARE OF NOTE DATA INDICATES EQUALITY.X\n                PROCEEDING TO DATA RECORDS.'\nDATAOK   DC    CL133'          COMPARE OF ITEM DATA INDICATES EQUALITY.X\n                ITEMS ARE PROBABLY EQUIVALENT.'\nDATAFAIL DC    CL133'          COMPARE OF ITEM DATA FAILED. ITEMS ARE NX\n               OT EQUAL TO EACH OTHER.'\nNOTEFAIL DC    CL133'          COMPARE OF NOTE DATA FAILED. PROCEEDING X\n               TO DATA RECORDS.'\nSELECT1  DC    AL1(50),CL50' SELECTED FROM VSAM1 CLUSTER FOR COMPARE.'\nSELECT2  DC    AL1(50),CL50' SELECTED FROM VSAM2 CLUSTER FOR COMPARE.'\nNOMATCH  DC    CL133'  *** NO CORRESPONDING ITEM FOUND IN THE VSAM2 ARCX\n               HIVE.'\n         COPY  #RECS\n         COPY  ##ARCHWK\n         IHAPDS DSECT=YES\n         #SDE\n         EJECT ,\n*---------------------------------------------------------------------*\n*---     THESE EQUATES REPRESENT THE BASIC OFFSETS INTO ARCHIVE    ---*\n*---     RECORDS FOR VARIOUS FIELDS.  SINCE I CAN'T BASE THE SAME  ---*\n*---     DSECT ON TWO REGISTERS AT THE SAME TIME, THIS APPROACH    ---*\n*---     ALLOWS ME TO ACCOMPLISH THE SAME END, WITHIN LIMITS.      ---*\n*---------------------------------------------------------------------*\nOFFAG    EQU   RECAG-REC\nOFFAN    EQU   RECAN-REC\nOFFASG   EQU   RECASG-REC\nOFFAT    EQU   RECAT-REC\nOFFAVER  EQU   RECAVER-REC\nOFFBLK   EQU   RSRBLK-REC\nOFFDATA  EQU   RECDATA-REC\nOFFDATE  EQU   RSRDATE-REC\nOFFDEV   EQU   RSRDEV-REC\nOFFDSO   EQU   RSRDSO-REC\nOFFFLAG1 EQU   @RSRFLG1-REC\nOFFFLAG2 EQU   @RSRFLG2-REC\nOFFFLAG3 EQU   @RSRFLG3-REC\nOFFFLAG4 EQU   @RSRFLG4-REC\nOFFG     EQU   RECG-REC\nOFFLMOD  EQU   RSRLMOD-REC\nOFFLRE   EQU   RSRLRE-REC\nOFFN     EQU   RECN-REC\nOFFNOT#  EQU   RSRNOT#-REC\nOFFNOTE  EQU   RDATNOTE-REC\nOFFPDIR  EQU   RSRPDIR-REC\nOFFRCNT  EQU   RSRRCNT-REC\nOFFREC   EQU   RSRREC-REC\nOFFSEQ#  EQU   RECSEQ#-REC\nOFFSG    EQU   RECSG-REC\nOFFT     EQU   RECT-REC\nOFFTIME  EQU   RSRTIME-REC\nOFFTT    EQU   RECTT-REC\nOFFVER   EQU   RECVER-REC\n*---------------------------------------------------------------------*\n*---     SAME THING FOR SPF DIRECTORY ENTRY FIELDS                 ---*\n*---------------------------------------------------------------------*\nOSDCDATE EQU   SDECDATE-SDE\nOSDCLINE EQU   SDECLINE-SDE\nOSDID    EQU   SDEID-SDE\nOSDILINE EQU   SDEILINE-SDE\nOSDMDATE EQU   SDEMDATE-SDE\nOSDMLINE EQU   SDEMLINE-SDE\nOSDMOD   EQU   SDEMOD-SDE\nOSDMTIME EQU   SDEMTIME-SDE\nOSDNAME  EQU   SDENAME-SDE\nOSDTTR   EQU   SDETTR-SDE\nOSDVERS  EQU   SDEVERS-SDE\n*---------------------------------------------------------------------*\n*---     SAME THING FOR LMOD DIRECTORY ENTRIES (ONLY THE           ---*\n*---     BASIC FIELDS)                                             ---*\n*---------------------------------------------------------------------*\nOPDBCEND EQU   PDSBCEND-PDS2\nOPDATR   EQU   PDS2ATR-PDS2\nOPDATR1  EQU   PDS2ATR1-PDS2\nOPDATR2  EQU   PDS2ATR2-PDS2\nOPDEPA   EQU   PDS2EPA-PDS2\nOPDFTBL  EQU   PDS2FTBL-PDS2\nOPDFTBO  EQU   PDS2FTBO-PDS2\nOPDFTB1  EQU   PDS2FTB1-PDS2\nOPDFTB2  EQU   PDS2FTB2-PDS2\nOPDFTB3  EQU   PDS2FTB3-PDS2\nOPDINDC  EQU   PDS2INDC-PDS2\nOPDNAME  EQU   PDS2NAME-PDS2\nOPDNL    EQU   PDS2NL-PDS2\nOPDRLDS  EQU   PDS2RLDS-PDS2\nOPDSTOR  EQU   PDS2STOR-PDS2\nOPDTTRN  EQU   PDS2TTRN-PDS2\nOPDTTRP  EQU   PDS2TTRP-PDS2\nOPDTTRT  EQU   PDS2TTRT-PDS2\nOPDUSRD  EQU   PDS2USRD-PDS2\nOPDZERO  EQU   PDS2ZERO-PDS2\n         SPACE 3\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHCONV": {"ttr": 2566, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x02\\x00\\x16\\x00\\x99'\\x0f\\x01\\x02!\\x8f\\x13&\\x03l\\x03k\\x00\\x07\\xd4\\xd4\\xe2\\xd4\\xc1\\xd2@@@@\"", "ispf": {"version": "06.02", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "2002-08-06T13:26:16", "lines": 876, "newlines": 875, "modlines": 7, "user": "MMSMAK"}, "text": "CONV     TITLE 'ARCHIVER --- CONVERT FUNCTION'\n*---------------------------------------------------------------------*\n*---     THIS ROUTINE CONVERTS A PREVIOUS VERSION ARCHIVE TO THE  ----*\n*---     VERSION-4 FORMAT, MODIFYING THE DATA                     ----*\n*---     COMPRESSION/COMPACTION AS NEEDED.  ALL CONVERSION        ----*\n*---     PROCEEDS FROM THE VSAM2 ARCHIVE TO THE VSAM1 ARCHIVE.    ----*\n*---     AS IN MOST FUNCTIONS OF THE ARCHIVER, ITEM SELECTION IS  ----*\n*---     PROVIDED AND ALL GENERICS ARE HONORED.                   ----*\n*---------------------------------------------------------------------*\nARCHCONV CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n         COPY #ARCBITS\n         USING ARCHCONV,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             COPY ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHCONV,R11        DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             COPY NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RECOPY BACK POINTER\n         L     R14,12(,R14)        RECOPY ORIG. REG 14\n         LA    R10,0(,R11)         COPY ORIGINAL BASE REGISTER\n         AH    R10,PASSIT-2        BUMP BY A BASE'S WORTH\n         USING ARCHCONV+4096,R10   AND DECLARE IT\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         L     R3,=F'32768'\n         LA    R5,0(R3,R3)\n         GETMAIN R,LV=(5),SP=12    GRAB STORAGE FOR WORK AREAS\n         ST    R1,BPBUF1\n         LR    R4,R1               COPY ITS ADDRESS\n         LA    R15,0\n         LA    R14,0\n         MVCL  R4,R14              CLEAR THE AREA\n         LA    R1,0(R3,R1)\n         ST    R1,BPBUF2\n         XC    FCOUNT,FCOUNT       CLEAR FUNCTION RECORD COUNT\n         XC    MCNT,MCNT           AND MEMBER COUNT\n         MVC   VS1MODE,=CL8'OUTPUT' SET THE I/O MODE\n         LA    R1,VSAM1DD          LOAD THE PARM POINTER\n         LA    R0,0                AND THE 'OPEN' FLAG\n         CALL  ARCHVSOP            CALL THE 'OPEN' FUNCTION\n         LTR   R15,R15             OPEN OK ??\n         BNZ   ENDITALL            NOPE; CAN'T WORK\n         BAL   R14,OPEN2           GO OPEN THE VSAM CLUSTER\n         SHOWCB ACB=(*,ACB2),                                          X\n               FIELDS=(LRECL,KEYLEN),                                  X\n               AREA=(S,CALLIST),                                       X\n               LENGTH=8,                                               X\n               MF=(G,GENWK)\n         LM    R7,R8,CALLIST       COPY KEYLEN AND LRECL VALUES\n         C     R8,=A(OLDKLEN)      IS KEY LENGTH RIGHT ??\n         BE    KEYOK2              YES ---\n         #PUT  ERR2                AND PUT IT OUT\n         #PUT  ERR4                AND PUT IT OUT\n         #PUT  ERR6                PRINT ERROR MESSAGE\n         B     ENDITALL            GO DO TERMINATION STUFF\nKEYOK2   DS    0H\n         C     R7,MINREC           IS LRECL LARGE ENOUGH ??\n         BNL   RECOK2              YES ---\n         #PUT  ERR2                AND PUT IT OUT\n         #PUT  ERR5                ERROR MESSAGE\n         #PUT  ERR6                PRINT ERROR MESSAGE\n         B     ENDITALL            GO DO TERMINATION STUFF\nRECOK2   DS    0H\n         XC    MCNT,MCNT             COUNTERS\n         EJECT\n*---------------------------------------------------------------------*\n*---     HERE'S THE MEAT OF THE PROCESSING. THE BASIC PROCESS IS   ---*\n*---           THIS:                                               ---*\n*---                                                               ---*\n*---     1. USING THE CONTROL INFORMATION WE WERE GIVEN AND THE    ---*\n*---        INFORMATION WE'VE DEVELOPED, LOCATE THE HEADER RECORD  ---*\n*---        FOR THE FIRST MEMBER. WE'LL USE THE VS1BUF2 AREA FOR   ---*\n*---        HEADER/KEY CONSTRUCTION.                               ---*\n*---                                                               ---*\n*---     2. LOOP THROUGH THE MEMBER, READING THE RECORDS AND       ---*\n*---        COPYING THEM INTO THE OUTPUT VSAM BUFFER, WRITING AS   ---*\n*---        EACH BUFFER GETS FULL.  IN ORDER TO GET THE COPY DONE, ---*\n*---        WE NEED TO USE THE 'EXPLODE' ROUTINE FROM THE OLD      ---*\n*---        VERSION OF THE ARCHIVER AND THE COMPACT ROUTINE FROM   ---*\n*---        THIS VERSION.  NOTE THAT THE ARCHIVE HEADER RECORD     ---*\n*---        NOW CONTAINS A LEVEL WORD THAT CAN BE INTERROGATED     ---*\n*---        TO DETERMINE THE METHOD OF COMPACTION AND/OR THE       ---*\n*---        APPROPRIATE COMPACTION/DECOMPACTION TABLE.             ---*\n*---                                                               ---*\n*---     3. AT END-OF-FILE FOR THE MEMBER, UPDATE THE VERSION      ---*\n*---        NUMBER, IF NOT SUPPLIED, AND LOOK FOR THE NEXT ITEM    ---*\n*---        TO COPY.                                               ---*\n*---------------------------------------------------------------------*\n         L     R6,VS2BUF2          POINT TO THE VSAM BUFFER\n         USING OLDREC,R6           BASE THE RECORD DSECT\n         XC    0(OLDKLEN,R6),0(R6) START AT THE BEGINNING !!\n         MODCB RPL=(*,RPL5),                                           X\n               OPTCD=(DIR,FKS,KGE,SYN,NUP),                            X\n               ACB=(*,ACB2),                                           X\n               ARG=(*,VS2BUF2),                                        X\n               AREA=(*,VS2BUF2),                                       X\n               AREALEN=(*,VS2LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         L     R1,RPL5             COPY THE RPL ADDRESS\n         POINT RPL=(1)             GET TO IT\nNEXTHDR  DS    0H\n         L     R6,VS2BUF2          POINT TO THE RECORD\n         MVI   OLDTT,OLDHDR        INITIAL RECORD TYPE\n         #IF   VRS,OFF,INCVERS\n         IC    R15,OLDT+7          INSERT A 'TYPE' BYTE\n         LA    R15,1(,R15)         INCREMENT BY ONE\n         STC   R15,OLDT+7          SAVE UPDATED VALUE\n         B     GETHDR              GO READ ANOTHER HEADER RECORD\nINCVERS  DS    0H\n         ICM   R15,3,OLDVER        INSERT THE VERSION NUMBER\n         AL    R15,=F'1'           INCREMENT BY ONE\n         STCM  R15,3,OLDVER        SAVE UPDATED VALUE\nGETHDR   DS    0H\n         L     R1,RPL5             COPY RPL ADDRESS\n         GET   RPL=(1)             AND READ A HEADER RECORD\n         LTR   R15,R15             ANYTHING LEFT ??\n         BNZ   ENDITALL            NOPE; ALL DONE\n         SHOWCB RPL=(*,RPL5),                                          X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,VS2LEN2),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\n         CLI   OLDTT,OLDHDR        HEADER RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\n         LA    R1,OLDTT            POINT TO THE HEADER\n         BAL   R14,OLDCHK          GO CHECK THE OLD ARCHIVE NAME(S)\n         LTR   R15,R15             PASS THE CHECK ??\n         BNZ   NEXTHDR             NOPE ---\n*---------------------------------------------------------------------*\n*---     AT THIS POINT, WE'VE DETERMINED THAT THIS ITEM NEEDS TO   ---*\n*---     BE CONVERTED. USING A LOCAL SUBROUTINE, WE'LL CONVERT     ---*\n*---     THE HEADER RECORD IN ITS ENTIRETY. PLEASE NOTE THAT NO    ---*\n*---     PDS DIRECTORY DATA IS MODIFIED; IT'S JUST COPIED          ---*\n*---     'AS-IS'. AT THIS POINT, WE EXAMINE THE HEADER TO          ---*\n*---     DETERMINE WHETHER WE REALLY HAVE COMPRESSED DATA IN THE   ---*\n*---     OLD ARCHIVE, SINCE LOAD MODULE DATA WAS NOT COMPRESSED.   ---*\n*---     NOW WE CHECK THE VERSION NUMBER.  IF WE'RE NOT REPLACING  ---*\n*---     A SIMILAR VERSION, WE WILL TRY TO WRITE THIS HEADER.      ---*\n*---     EACH TIME WE GET A DUPLICATE RECORD INDICATION FROM       ---*\n*---     VSAM, WE'LL INCREMENT THE VERSION NUMBER BY ONE AND TRY   ---*\n*---     AGAIN.  THIS WILL DETERMINE THE MAJORITY OF THE KEY FOR   ---*\n*---     ALL SUBSEQUENT RECORDS IN THIS ITEM AS WELL.  IF, ON THE  ---*\n*---     OTHER HAND, WE'RE REPLACING ANY DUPLICATE DATA, WE'LL     ---*\n*---     SIMPLY CALL ARCHERAS TO REMOVE ANY PRE-EXISTING ITEM OF   ---*\n*---     A MATCHING KEY.                                           ---*\n*---------------------------------------------------------------------*\n         BAL   R14,HDRCNV          GO CONVERT THE HEADER RECORD\n         L     R1,VS1BUF1          LOAD SPARE-BUFFER ADDRESS\n         L     R7,VS1BUF2          LOAD THE RECORD POINTER\n         USING REC,R7              AND BASE ITS DSECT\n         MVC   0(RECKLEN,R1),RECTT SAVE THAT KEY, FOR LATER\nPUTHDR   DS    0H\n         L     R1,VS1BUF2          LOAD THE RECORD POINTER\n         L     R0,VS1LEN2          AND LENGTH\n         BAL   R14,VSPUT           GO WRITE THE RECORD (MAYBE)\n         LTR   R15,R15             DUPLICATE RECORD ??\n         BZ    DONOTES             NOPE; ALL IS OK ---\n         #IF   REPL,ON,DELEIT      DELETE FOR REPLACEMENT ??\n         ICM   R15,15,RECVER       INSERT THE VERSION NUMBER\n         BCTR  R15,R0              UP BY ONE\n         STCM  R15,15,RECVER\n         B     PUTHDR              GO RETRY THE PUT\nDELEIT   DS    0H\n         LR    R1,R6               LOAD THE BUFFER POINTER\n         CALL  ARCHERAS            DELETE THE DUPLICATE ITEM\n         B     PUTHDR              AND GO RETRY THE 'PUT'\n         DROP  R6,R7\n         TITLE 'NOTE DATA CONVERSION'\n*---------------------------------------------------------------------*\n*---     THE HEADER IS NOW CONVERTED AND WRITTEN. AS A SIDE        ---*\n*---     BENEFIT, I NOW HAVE THE CORRECT VERSION NUMBER SET IN     ---*\n*---     THE RECORD KEY.  NOW DO THE OLD 'COMMDATA' RECORDS,       ---*\n*---     CONVERTING THEM TO THE NEW FORMAT 'NOTE' RECORDS. THESE   ---*\n*---     RECORDS ARE ALWAYS COMPRESSED IN THE OLD ARCHIVE, SO WE   ---*\n*---     NEED TO 'EXPLODE' THEM AND COMPACT THEM USING OUR NEW     ---*\n*---     AND IMPROVED COMPACTION MECHANISM.                        ---*\n*---------------------------------------------------------------------*\nDONOTES  DS    0H\n         L     R7,VS2BUF2          LOAD HEADER-RCD ADDRESS\n         L     R6,VS2BUF1          POINT TO THE OTHER BUFFER\n         USING OLDREC,R6\n         MVC   0(OLDKLEN,R6),0(R7) COPY THAT KEY\n         MVI   OLDTT,OLDCOMM       RESET TO NOTE TYPE\n         MODCB RPL=(*,RPL4),                                           X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               ARG=(*,VS2BUF1),                                        X\n               ACB=(*,ACB2),                                           X\n               AREA=(*,VS2BUF1),                                       X\n               AREALEN=(*,VS2LIM),                                     X\n               MF=(G,GENWK)        POSITION TO ITEM NOTE START\n         L     R1,RPL4             COPY THE RPL ADDRESS\n         POINT RPL=(1)             GET TO IT\n         L     R7,VS1BUF2          LOAD OUTPUT BUFFER POINTER\n         USING REC,R7\n         MVI   RECTT,#RTNOTE       SET TYPE FOR NOTES\n         LA    R0,1                LOAD INITIAL SEQ# VALUE\n         STCM  R0,15,RECSEQ#       SAVE THAT NUMBER\n         LA    R0,RECKLEN          LOAD KEY LENGTH\n         ST    R0,VS1LEN2          SAVE AS INITIAL RECORD LENGTH\nNT1      DS    0H\n         L     R1,RPL4             POINT TO THE RPL\n         GET   RPL=(1)             GO READ A MEMBER NOTE RECORD\n         LTR   R15,R15             DID IT COMPLETE OK ??\n         BNZ   NTDONE              NOPE; ASSUME WE'RE DONE WITH NOTES\n         SHOWCB RPL=(*,RPL4),                                          X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,VS2LEN1),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\n         CLI   OLDTT,OLDCOMM       COMMDATA RECORD ??\n         BNE   NTDONE\n         L     R1,VS2BUF2          POINT TO ORIGINAL KEY\n         CLC   1(OLDKLEN-5,R6),1(R1) STILL IN THE RIGHT ITEM ??\n         BNE   NTDONE              NOPE; GO DO THE DATA RECORDS\n         LA    R5,OLDDATA          POINT TO NOTE DATA\n         L     R4,VS2LEN1          LOAD RECORD LENGTH\n         LA    R4,0(R4,R6)         POINT TO\n         BCTR  R4,R0                 LAST DATA BYTE\nNT2      DS    0H\n         L     R2,BPBUF1           POINT TO EXPLODE OUTPUT AREA\n         LA    R3,3(,R5)           POINT TO INPUT AREA\n         LA    R8,0                CLEAR A REG.\n         ICM   R8,7,0(R5)          LOAD INPUT LENGTH\n         CALL  EXPLODE,((3),(8),(2)),MF=(E,CALLIST)\n         LR    R3,R2               COPY INPUT ADDRESS\n         LR    R8,R0               AND LENGTH\n         L     R2,BPBUF2           LOAD ANOTHER OUTPUT AREA\n         STCM  R0,3,3(R2)          STORE ORIGINAL RECORD LENGTH\n         LA    R2,5(,R2)           POINT TO COMPACT OUTPUT AREA\n         ST    R8,DWORK            SAVE THE LENGTH\n         CALL  COMPACT,((3),DWORK,(2)),MF=(E,CALLIST)\n         L     R3,BPBUF2           RELOAD AREA POINTER\n         LR    R2,R0               COPY THE LENGTH\n         LA    R2,2(,R2)           ACCOUNT FOR EXPAND LENGTH FIELD\n         STCM  R2,7,0(R3)          SAVE THE LENGTH\n         #ADDBLK BUFFER=2,                                             X\n               RECORD=3(,R3),                                          X\n               LENGTH=0(,R3),                                          X\n               ERR=TOOLONG,                                            X\n               RTN=VSPUT\n         ICM   R2,7,0(R5)\n         LA    R5,3(R2,R5)         POINT TO NEXT INPUT SEGMENT\n         CR    R5,R4               PAST THE END LET ??\n         BL    NT2                 NOPE ---\n         B     NT1                 YES; GET ANOTHER RECORD\nNTDONE   DS    0H\n         #ADDBLK BUFFER=2,                                             X\n               LAST=YES,                                               X\n               RTN=VSPUT\nNT5      DS    0H\n*---------------------------------------------------------------------*\n*---     NOTE DATA IS COPIED. NOW UPDATE THE NOTE DATA LAST        ---*\n*---     SEQUENCE NUMBER FIELD IN THE HEADER RECORD. WE'LL USE     ---*\n*---     THE VS1BUF1 BUFFER AREA FOR THIS UPDATE.                  ---*\n*---------------------------------------------------------------------*\n         ICM   R2,15,RECSEQ#       LOAD THE SEQUENCE NUMBER\n         BCTR  R2,R0               BACK UP TO LAST TRUE VALUE\n         XC    RECSEQ#,RECSEQ#     CLEAR THAT VALUE\n         MVI   RECTT,#RTHDR        SET 'HEADER' TYPE\n         MODCB RPL=(*,RPL1),                                           X\n               OPTCD=(DIR,FKS,KEQ,SYN,UPD),                            X\n               ACB=(*,ACB1),                                           X\n               ARG=(*,VS1BUF2),                                        X\n               AREA=(*,VS1BUF2),                                       X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        VSAM SETUP FOR UPDATE\n         L     R1,RPL1             POINT TO THE RPL\n         GET   RPL=(1)             READ THE HEADER RECORD\n         LTR   R15,R15             DID WE GET IT OK ??\n         BZ    NT6                 YES ---\n         L     R4,RPL1             LOAD THE RPL ADDRESS\n         ABEND 100,DUMP            AND DIE HOFFIBLY\nNT6      DS    0H\n         SHOWCB RPL=(*,RPL1),                                          X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,VS1LEN2),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\n         STCM  R2,15,RSRNOT#       UPDATE NOTE-RECORD COUNT\n         MODCB RPL=(*,RPL1),                                           X\n               OPTCD=(DIR,FKS,KEQ,SYN,UPD),                            X\n               ACB=(*,ACB1),                                           X\n               ARG=(*,VS1BUF2),                                        X\n               AREA=(*,VS1BUF2),                                       X\n               AREALEN=(*,VS1LEN2),                                    X\n               MF=(G,GENWK)        VSAM SETUP FOR UPDATE\n         L     R1,RPL1             LOAD THE RPL ADDRESS\n         PUT   RPL=(1)             AND UPDATE THE RECORD\n         LTR   R15,R15             DID WE UPDATE IT OK ??\n         BZ    NTEND               YES ---\n         L     R4,RPL1             LOAD THE RPL ADDRESS\n         ABEND 100,DUMP            AND DIE HORRIBLY\n         DROP  R6,R7\n         TITLE 'ITEM DATA CONVERSION'\nNTEND    DS    0H\n         L     R7,VS2BUF2          LOAD HEADER-RCD ADDRESS\n         L     R6,VS2BUF1          POINT TO THE OTHER BUFFER\n         USING OLDREC,R6\n         MVC   0(OLDKLEN,R6),0(R7) COPY THAT KEY\n         MVI   OLDTT,OLDMEMB       RESET TO DATA TYPE\n         MODCB RPL=(*,RPL4),                                           X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               ARG=(*,VS2BUF1),                                        X\n               ACB=(*,ACB2),                                           X\n               AREA=(*,VS2BUF1),                                       X\n               AREALEN=(*,VS2LIM),                                     X\n               MF=(G,GENWK)        POSITION TO ITEM DATA START\n         L     R1,RPL4             COPY THE RPL ADDRESS\n         POINT RPL=(1)             GET TO IT\n         L     R7,VS1BUF2          LOAD OUTPUT BUFFER POINTER\n         USING REC,R7\n         LA    R0,1                LOAD INITIAL SEQ# VALUE\n         STCM  R0,15,RECSEQ#       SAVE THAT NUMBER\n         MVI   RECTT,#RTDATA       SET TYPE FOR DATA\n         LA    R0,RECKLEN          LOAD KEY LENGTH\n         ST    R0,VS1LEN2          SAVE AS INITIAL RECORD LENGTH\nDT1      DS    0H\n         L     R1,RPL4             POINT TO THE RPL\n         GET   RPL=(1)             GO READ A MEMBER DATA RECORD\n         LTR   R15,R15             DID IT COMPLETE OK ??\n         BNZ   DTDONE              NOPE; ASSUME WE'RE DONE WITH DATA\n         SHOWCB RPL=(*,RPL4),                                          X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,VS2LEN1),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\n         CLI   OLDTT,OLDMEMB       DATA RECORD ??\n         BNE   DTDONE\n         L     R1,VS2BUF2\n         CLC   1(OLDKLEN-5,R6),1(R1) STILL IN THE RIGHT ITEM ??\n         BNE   DTDONE              NOPE; ALL FINISHED ---\n         LA    R5,OLDMEM           POINT TO DATA DATA\n         L     R4,VS2LEN1          LOAD RECORD LENGTH\n         LA    R4,0(R4,R6)         POINT TO\n         BCTR  R4,R0                 LAST DATA BYTE\nDT2      DS    0H\n         #IF   EXPL,OFF,NOEXPL\n         L     R2,BPBUF1           POINT TO EXPLODE OUTPUT AREA\n         LA    R3,3(,R5)           POINT TO INPUT AREA\n         LA    R8,0                CLEAR A REG.\n         ICM   R8,7,0(R5)          LOAD INPUT LENGTH\n         CALL  EXPLODE,((3),(8),(2)),MF=(E,CALLIST)\n         LR    R3,R2               COPY INPUT ADDRESS\n         L     R2,BPBUF2           LOAD ANOTHER OUTPUT AREA\n         STCM  R0,3,3(R2)          STORE ORIGINAL RECORD LENGTH\n         LA    R2,5(,R2)           POINT TO COMPACT OUTPUT AREA\n         ST    R0,DWORK            SAVE THE LENGTH\n         LR    R8,R0\n         CALL  COMPACT,((3),DWORK,(2)),MF=(E,CALLIST)\n         L     R3,BPBUF2           RELOAD AREA POINTER\n         AH    R0,=H'2'            ACCOUNT FOR 'TRUE LENGTH' FIELD\n         STCM  R0,7,0(R3)          STORE LENGTH\n         LR    R2,R0               AND COPY IT\n         B     EXPLD\nNOEXPL   DS    0H\n         L     R2,BPBUF2           POINT TO EXPLODE OUTPUT AREA\n         LA    R3,3(,R5)           POINT TO INPUT AREA\n         LA    R8,0                CLEAR A REG.\n         ICM   R8,7,0(R5)          LOAD INPUT LENGTH\n         STCM  R8,3,3(R2)          STORE ORIGINAL RECORD LENGTH\n         LA    R2,5(,R2)           POINT TO COMPACT OUTPUT AREA\n         ST    R8,DWORK            SAVE THE LENGTH\n         CALL  COMPACT,((3),DWORK,(2)),MF=(E,CALLIST)\n         L     R3,BPBUF2           RELOAD AREA POINTER\n         STCM  R0,7,0(R3)          STORE LENGTH\n         LR    R2,R0               AND COPY IT\nEXPLD    DS    0H\n         STCM  R2,7,0(R3)          SAVE THE LENGTH\n         #ADDBLK BUFFER=2,                                             X\n               RECORD=3(,R3),                                          X\n               LENGTH=0(,R3),                                          X\n               ERR=TOOLONG,                                            X\n               RTN=VSPUT\n         LA    R2,0\n         ICM   R2,7,0(R5)\n         LA    R5,3(R2,R5)         POINT TO NEXT INPUT SEGMENT\n         CR    R5,R4               PAST THE END LET ??\n         BL    DT2                 NOPE ---\n         B     DT1                 YES; GET ANOTHER RECORD\nDTDONE   DS    0H\n         #ADDBLK BUFFER=2,                                             X\n               LAST=YES,                                               X\n               RTN=VSPUT\nDT5      DS    0H\n         L     R1,MCNT             LOAD MEMBER COUNT\n         LA    R1,1(,R1)           INCREMENT BY ONE\n         ST    R1,MCNT             SAVE UPDATED COUNT\n         L     R6,VS1BUF1          POINT TO OLD (CONVERTED) KEY\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         #FORMAT OLDTT,,INMSG\n         #PUT  LINE\n         L     R6,VS1BUF2          POINT TO NEW KEY\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         #FORMAT RECTT,,OUTMSG\n         #PUT  LINE\n         B     NEXTHDR             GO DO ANOTHER ITEM\n         SPACE 3\n*---------------------------------------------------------------------*\n*---     IF WE REACH THIS LABEL, WE'VE GOT AT LEAST ONE RECORD     ---*\n*---     THAT CANNOT BE MADE TO FIT IN THE OUTPUT ARCHIVE          ---*\n*---     CLUSTER. ISSUE AN ERROR MESSAGE AND ERASE THE             ---*\n*---     PARTIALLY-COPIED ITEM.                                    ---*\n*---------------------------------------------------------------------*\nTOOLONG  DS    0H\n         L     R6,VS1BUF1          POINT TO OLD (CONVERTED) KEY\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         #FORMAT OLDTT,,LNGREC\n         #PUT  LINE                PRINT THE ERROR\n         L     R1,RECTT            POINT TO THE RECORD KEY\n         CALL  ARCHERAS            DELETE PARTIAL ITEM\n         B     NEXTHDR             GO FOR ANOTHER ITEM\nLNGREC   DC    AL1(LNGRECE-LNGRECS)\nLNGRECS  DC    C' CANNOT BE CONVERTED. AT LEAST ONE RECORD TOO LONG.'\nLNGRECE  EQU   *\n         DROP  R6,R7\nINMSG    DC    AL1(INEND-INMSG1)\nINMSG1   DC    C' WAS CONVERTED TO ---   '\nINEND    EQU   *\nOUTMSG   DC    AL1(OUTEND-OUTMSG1)\nOUTMSG1  DC    C' ON OUTPUT VSAM CLUSTER. '\nOUTEND   EQU   *\nENDITALL DS    0H\n         #PUT  ERR14\n         L     R0,MCNT             COPY MEMBER COUNT\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,MCMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\n         LA    R1,VSAM1DD          POINT TO THE DDNAME\n         LA    R0,4                SET 'CLOSE' REQUEST\n         CALL  ARCHVSOP            CALL THE VSAM 'CLOSE' ROUTINE\n         BAL   R14,CLOSE2          CLOSE THE VSAM CLUSTER\n         FREEMAIN R,SP=12          RELEASE ALL MY STORAGE\n         XC    BPBUF1,BPBUF1\n         XC    BPBUF2,BPBUF2\n         L     R13,4(,R13)         COPY BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ALWAYS RC = 0\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\n         TITLE 'VSAM CLOSE AND CONTROL-BLOCK FREEMAINS'\n*---------------------------------------------------------------------*\n*---     THIS LITTLE LOCAL SUBROUTINE IS THE COUNTERPART TO THE    ---*\n*---     VSOPEN ROUTINE. HERE, THE VSAM CLUSTER # 2 IS CLOSED      ---*\n*---     AND ALL RELATED STORAGE, WORK AREAS, ETC. ARE FREE'D.     ---*\n*---     ALL RELATED VALUES IN THE ##ARCHWK AREA ARE ALSO RESET.   ---*\n*---------------------------------------------------------------------*\nCLOSE2   DS    0H\n         STM   R14,R12,IOSAVE      SAVE ENTRY REGISTERS\n         NC    ACB2,ACB2           WAS IT OPENED ??\n         BZR   R14                 NOPE ---\n         MVI   ACB2,X'80'          MARK AS LAST FOR CLOSE\n         CLOSE ,MF=(E,ACB2)        CLOSE THE CLUSTER\n         ST    R3,VS2LIM           SAVE RECORD LENGTH LIMIT\n         XC    ACB2(32),ACB2       CLEAR THE VSAM I/O CONTROL WORDS\n         LM    R14,R12,IOSAVE      RESTORE THE REGISTERS\n         BR    R14                 RETURN TO (LOCAL) CALLER\n         TITLE 'VSAM CLUSTER OPEN AND BLOCK-BUILD'\n*---------------------------------------------------------------------*\n*---     THIS LITTLE LOCAL SUBROUTINE OPENS THE VSAM CLUSTER FOR   ---*\n*---     INPUT.  ALL VSAM-RELATED GETMAINS ARE DONE FROM SUBPOOL   ---*\n*---     11, TO ALLOW A SUBPOOL-WIDE FREEMAIN AT THE END OF        ---*\n*---     PROCESSING. NOTE THAT ALL VSAM CONTROL BLOCKS ARE         ---*\n*---     'GENCB'D IN GETMAINED AREAS, FOR THE SAME FLEXIBILITY.    ---*\n*---------------------------------------------------------------------*\nOPEN2    DS    0H\n         STM   R14,R12,IOSAVE      SAVE ENTRY REGISTERS\n         SHOWCB FIELDS=(ACBLEN,RPLLEN),AREA=(S,DWORK),LENGTH=8,        X\n               MF=(G,GENWK)\n         LM    R4,R5,DWORK         LOAD THE TWO LENGTHS\n         LA    R6,0(R5,R5)         PLAN FOR TWO RPL'S\n         LA    R6,0(R6,R4)         PLUS THE ACB\n         GETMAIN R,LV=(6),SP=11    GRAB SOME STORAGE\n         ST    R1,ACB2             SAVE AS ACB ADDRESS\n         LR    R2,R1               COPY ITS ADDRESS\n         GENCB BLK=ACB,                                                X\n               WAREA=(2),                                              X\n               LENGTH=(4),                                             X\n               AM=VSAM,                                                X\n               STRNO=2,                                                X\n               DDNAME=(*,VSAM2DD),                                     X\n               MACRF=(KEY,DIR,SEQ,IN),                                 X\n               MF=(G,GENWK)\n         MVI   ACB2,X'80'          MARK AS LAST FOR OPEN\n         LA    R3,0(R4,R2)         POINT TO RPL PART OF AREA\n         LA    R6,0(R5,R5)         TWO RPL'S LENGTH\n         GENCB BLK=RPL,                                                X\n               WAREA=(3),                                              X\n               LENGTH=(6),                                             X\n               COPIES=2,                                               X\n               ACB=(2),                                                X\n               AM=VSAM,                                                X\n               MF=(G,GENWK)\n         ST    R1,RPL4             SAVE ITS ADDRESS\n         LA    R1,0(R5,R1)         POINT TO SECOND RPL\n         ST    R1,RPL5             SAVE ITS ADDRESS\n         OPEN  ,MF=(E,ACB2)        OPEN THE CLUSTER\n         SHOWCB ACB=(2),FIELDS=LRECL,AREA=(S,VS2LIM),LENGTH=4,         X\n               MF=(G,GENWK)\n         L     R3,VS2LIM           LOAD THE RECORD LENGTH\n         LA    R5,0(R3,R3)         FIGURE TWO BUFFERS\n         GETMAIN R,LV=(5),SP=11    GRAB SPACE FOR A BUFFER AREA\n         ST    R1,VS2BUF1          SAVE BUFFER\n         LA    R2,0(R3,R1)         POINT TO SECOND BUFFER\n         ST    R2,VS2BUF2          AND SAVE ITS ADDRESS\n         LA    R14,0               SOURCE ADDRESS IS ZERO\n         LA    R15,0               LENGTH/PAD IS ZEROS\n         L     R4,VS2BUF1          POINT TO AREA START\n         MVCL  R4,R14              CLEAR ONE BUFFER\n         XC    VS2LEN1,VS2LEN1     INITIAL BYTES USED = ZERO\n         XC    VS2LEN2,VS2LEN2     INITIAL BYTES USED = ZERO\n         LM    R14,R12,IOSAVE      RESTORE THE REGISTERS\n         BR    R14                 RETURN TO (LOCAL) CALLER\n         TITLE 'VSAM I/O OUTPUT '\n*---------------------------------------------------------------------*\n*---     THIS LITTLE LOCAL SUBROUTINE DOES ALL THE VSAM WRITING    ---*\n*---     FOR THE COPY FUNCTION, WITH THE EXCEPTION OF THE ERASURE  ---*\n*---     OF A DUPLICATE ITEM.  THE BASIC ASSUMPTIONS ARE THAT THE  ---*\n*---     VS1BUF1 AREA IS THE RECORD TO BE WRITTEN AND ITS LENGTH   ---*\n*---     IS ACCURATELY REPORTED IN THE VS1LEN1 FIELD.  THE         ---*\n*---     INITIAL-LOAD CONDITION IS PROPERLY HANDLED HERE, IF       ---*\n*---     NECESSARY.                                                ---*\n*---------------------------------------------------------------------*\nVSPUT    DS    0H\n         STM   R14,R12,IOSAVE      SAVE ENTRY REGISTERS\n         L     R4,RPL2             LOAD RPL ADDRESS\n         LR    R5,R1               LOAD BUFFER ADDRESS\n         LR    R6,R0               LOAD RECORD LENGTH\n         MODCB RPL=(4),            RPL ADDRESS                         X\n               OPTCD=(DIR,FKS,NUP,MVE,KEQ), OPTION CODES ---           X\n               ARG=(5),            KEY ADDRESS                         X\n               AREA=(5),           BUFFER ADDRESS                      X\n               RECLEN=(6),         RECORD LENGTH                       X\n               MF=(G,GENWK)\n         PUT   RPL=(4)             OUTPUT THE VSAM RECORD\n         LR    R3,R15              SAVE THAT RETURN CODE\n         SHOWCB RPL=(4),                                               X\n               FIELDS=FDBK,        FETCH THE RPL FEEDBACK FIELD        X\n               AREA=(S,DWORK),                                         X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        GET RECORD LENGTH\n         B     *+4(R3)             CHECK THE 'PUT' RETURN CODE\n         B     VSPUT5              ALL IS OK\n         B     VSPUT1              RPL SHOWS SOMETHING HAPPENING\n         B     VSPUT3              LOGICAL ERROR\n         B     VSPUTDIE            PHYSICAL ERROR\nVSPUT1   DS    0H\n         LA    R8,0                CLEAR A COUNTER REGISTER\nVSPUT2   DS    0H\n         CH    R8,=H'3'            PAST THE LIMIT YET ??\n         BH    VSPUTDIE            YES ---\n         LA    R8,1(,R8)           NOPE; INCREMENT COUNTER\n         PUT   RPL=(4)             OUTPUT THE VSAM RECORD\n         LR    R3,R15              SAVE THAT RETURN CODE\n         SHOWCB RPL=(4),                                               X\n               FIELDS=FDBK,        FETCH THE RPL FEEDBACK FIELD        X\n               AREA=(S,DWORK),                                         X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        GET RECORD LENGTH\n         B     *+4(R3)             CHECK THE 'PUT' RETURN CODE\n         B     VSPUT5              ALL IS OK\n         B     VSPUT2              RPL SHOWS SOMETHING HAPPENING\n         B     VSPUT3              LOGICAL ERROR\n         B     VSPUTDIE            PHYSICAL ERROR\nVSPUT3   DS    0H                  LOGICAL ERROR HAS OCCURED\n         CLI   DWORK+3,8           DUPLICATE KEY ??\n         BNE   VSPUT4              NOPE ---\n         LA    R15,4               LOAD THE RETURN CODE\n         B     VSPUT5              AND TERMINATE\nVSPUT4   DS    0H\n         CLI   DWORK+3,116         INITIAL LOAD IN PROGRESS ??\n         BNE   VSPUTDIE            NOPE; SOME OTHER ERROR\n         MODCB RPL=(4),            RPL ADDRESS                         X\n               OPTCD=(SEQ,NUP,MVE,KEQ), OPTION CODES ---               X\n               MF=(G,GENWK)\n         LR    R7,R15\n         PUT   RPL=(4)             RE-DO THE PUT\n         LTR   R15,R15             OK NOW ??\n         BNZ   VSPUTDIE            NOPE; STILL SHAFTED\n         CLOSE ,MF=(E,ACB1)        CLOSE THE CLUSTER\n         OPEN  ,MF=(E,ACB1)        AND RE-OPEN THE CLUSTER\nVSPUT5   DS    0H\n         L     R14,IOSAVE          RELOAD R14\n         LM    R0,R12,IOSAVE+8     RESTORE OTHER REGS\n         BR    R14                 AND RETURN TO CALLER\nVSPUTDIE DS    0H\n*        WTO   'ARCHIVER --- VSAM I/O ERROR. R4 --> RPL',ROUTCDE=11\n         ABEND 100,DUMP\n         TITLE 'OLD-ARCHIVE NAME CHECK '\n*---------------------------------------------------------------------*\n*---     THIS DIDDLY LITTLE LOCAL SUBROUTINE DUPLICATES THE        ---*\n*---     FUNCTION OF THE ARCHKNAM SUBROUTINE, WITH ONE             ---*\n*---     DIFFERENCE: IT ONLY CHECKS THE FIRST 8 CHARACTERS OF      ---*\n*---     EACH QUALIFIER.  THIS IS BECAUSE THE INPUT IS ASSUMED TO  ---*\n*---     BE FROM THE OLD FORMAT ARCHIVE, WHERE QUALIFIER DATA WAS  ---*\n*---     IN 8-CHARACTER CHUNKS.  THIS IS THE ONLY PIECE OF THE     ---*\n*---     VERSION 4 ARCHIVER THAT ACTUALLY DEFINCES THE FIELDS OF   ---*\n*---     THE VERSION 3 ARCHIVE KEY.                                ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nOLDCHK   DS    0H\n         STM   R14,R12,IOSAVE      STORE ENTRY REGISTERS\n         LA    R15,0               INITIAL RETURN CODE\n         ST    R15,IOSAVE+4        AND SET FOR RETURN\n         LR    R8,R1               COPY RECORD ADDRESS\n         USING OLDREC,R8\n         LA    R1,OLDN             POINT TO ITEM NAME\n         LA    R2,Q1               POINT TO INPUT QUALIFIER\n         LA    R7,Q4               POINT TO LAST QUALIFIER\n         LA    R6,10               AND QUALIFIER LENGTH\nCHK1     DS    0H\n         BAL   R14,CHKQ            GO CHECK THE QUALIFIER\n         B     NOMATCH             TEST FAILED; SET NOMATCH RETURN CODE\n         LA    R1,8(,R1)           POINT TO NEXT VALUE\n         BXLE  R2,R6,CHK1          AND LOOP, CHECKINGLY\n         #IF   VRS,OFF,MATCH       WAS VERSION NUMBER GIVEN ??\n         ICM   R0,15,OLDVER        LOAD THE VERSION NUMBER\n         C     R0,Q5               DOES IT MATCH ??\n         BNE   NOMATCH             NOPE; FAIL THE TEST\nMATCH    DS    0H\n         LM    R14,R12,IOSAVE      RESTORE ENTRY REGISTERS\n         BR    R14                 AND RETURN TO CALLER\nNOMATCH  DS    0H\n         MVC   IOSAVE+4(4),=F'4'   NON-ZERO RETURN CODE FOR FAILURE\n         B     MATCH               AND RETURN TO CALLER\n         DROP  R8\n         TITLE 'GENERIC/NONGENERIC QUALIFIER COMPARISON'\n*---------------------------------------------------------------------*\n*---     WE DO SOME STRANGE THINGS WITH MASKS, 'AND' AND COMPARE   ---*\n*---     INSTRUCTIONS HERE.  THE STEPS ARE RELATIVELY SIMPLE,      ---*\n*---     ONCE THEY'RE UNDERSTOOD, BUT CAN BE A LITTLE STRANGE TO   ---*\n*---     GRASP IF YOU DON'T WORK IT OUT ONCE OR TWICE WITH PAPER   ---*\n*---     AND PENCIL.  THE BASIC STEPS ARE THESE:                   ---*\n*---                                                               ---*\n*---     1. COPY THE QUALIFIER FROM THE CONTROL STATEMENT TO THE   ---*\n*---        GENWK AREA. THEN MAKE A COPY OF IT, IMMEDIATELY        ---*\n*---        FOLLOWING THE FIRST.                                   ---*\n*---                                                               ---*\n*---     2. EVERY PLACE WE HAVE A 'GENERIC' CHARACTER, REPLACE IT  ---*\n*---        WITH A BLANK. ALSO, EVERY NON-GENERIC CHARACTER IS     ---*\n*---        REPLACED WITH A X'FF'.                                 ---*\n*---                                                               ---*\n*---     3. TO MAKE THE COMPARISON, DO THIS:                       ---*\n*---                                                               ---*\n*---        A. 'AND' THE INPUT VALUE WITH THE FIRST MASK. ALL      ---*\n*---           CHARACTERS THAT ARE NOT GENERICS WILL BE UNCHANGED  ---*\n*---           AND ALL GENERICS WILL BE REPLACED BY BLANKS.        ---*\n*---                                                               ---*\n*---        B. COMPARE THE RESULT WITH THE SECOND MASK.  ALL       ---*\n*---           NON-GENERIC CHARACTERS WILL BE CHECKED FOR EXACT    ---*\n*---           MATCHES AND ALL GENERIC CHARACTERS WILL BE BLANKS   ---*\n*---           COMPARED TO BLANKS, MAKING THEM EQUAL.              ---*\n*---                                                               ---*\n*---     SIMPLE, ISN'T IT ??                                       ---*\n*---------------------------------------------------------------------*\nCHKQ     DS    0H\n         MVC   GENWK(8),0(R2)      COPY THE MEMBER NAME\n         MVC   GENWK+8(8),GENWK    AND DUPLICATE IT\n         CLC   =CL10'%%%%%%%%',0(R2) ALL ITEMS ??\n         BE    MATCH               YES; NOTHING TO FILTER\n         LA    R5,GENWK+7          POINT TO STRING END\n         LA    R3,GENWK            AND STRING START\n         LA    R4,1                AND BXLE INCREMENT\nF1       DS    0H\n         CLI   0(R3),C'%'          GENERIC CHARACTER ??\n         BNE   F2                  NOPE ---\n         MVI   0(R3),C' '          YES; REPLACE WITH A BLANK\n         MVI   8(R3),C' '          YES; REPLACE WITH A BLANK\n         B     F3                  DO OTHER MASK\nF2       DS    0H\n         MVI   0(R3),X'FF'         ANYTHING GOES HERE\nF3       DS    0H\n         BXLE  R3,R4,F1            LOOP FOR MASKS\n*---------------------------------------------------------------------*\n*---     SEARCH MASKS ARE BUILT. NOW DO THE COMPARE                ---*\n*---------------------------------------------------------------------*\nTSTX     DS    0H\n         MVC   GENWK+16(8),0(R1)  COPY THE QUALIFIER TO BE CHECKED\n         NC    GENWK+16(8),GENWK  MASK OUT THE GENERIC CHARS\n         CLC   GENWK+16(8),GENWK+8 REMAINDER MATCH ??\n         BE    4(,R14)             YES; RETAIN MAINLINK AND SUBCHAIN\n         BNE   0(,R14)             NOPE; FAIL THE TEST\n         TITLE 'HEADER RECORD FORMAT CONVERSION'\n*---------------------------------------------------------------------*\n*---     THIS LOCAL SUBROUTINE PERFORMS THE CONVERSION OF VERSION  ---*\n*---     3 HEADER RECORDS TO THE VERSION 4 FORMAT, WITH THE        ---*\n*---     EXPANDED FIELDS PADDED AS APPROPRIATE.  HERE, I ALSO SET  ---*\n*---     THE EXPL FLAG, TO DETERMINE WHETHER THE INPUT MEMBER IS   ---*\n*---     IN A COMPRESSED FORMAT OR NOT. ANY ATTEMPT TO USE THE     ---*\n*---     'EXPLODE' ROUTINE ON A LOAD MODULE FROM A VERSION 3       ---*\n*---     ARCHIVE WILL FAIL, SINCE VERSION 3 DIDN'T SUPPORT         ---*\n*---     COMPRESSION FOR LMODS.                                    ---*\n*---------------------------------------------------------------------*\nHDRCNV   DS    0H\n         L     R6,VS1BUF2          LOAD OUTPUT POINTER\n         USING REC,R6\n         L     R7,VS2BUF2          AND INPUT POINTER\n         USING OLDREC,R7\n         MVI   RECTT,#RTHDR        MARK AS A HEADER RECORD\n         MVC   RECN,=CL10' '       START WITH BLANKS\n         MVC   RECN(8),OLDN\n         MVC   RECG,=CL10' '       START WITH BLANKS\n         MVC   RECG(8),OLDG\n         MVC   RECSG,=CL10' '      START WITH BLANKS\n         MVC   RECSG(8),OLDSG\n         MVC   RECT,=CL10' '       START WITH BLANKS\n         MVC   RECT(8),OLDT\n         XC    RECSEQ#,RECSEQ#     RECORD SEQUENCE NUMBER\n         XC    RSRNOT#,RSRNOT#     LAST NOTE RECORD SEQUENCE NUMBER\n         MVI   @RSRFLG1,X'06'      SET THE VERSION NUMBER\n         MVI   @RSRFLG2,X'01'      SET THE VERSION NUMBER\n         MVI   @RSRFLG3,X'00'      SET THE VERSION NUMBER\n         MVI   @RSRFLG4,X'00'      SET THE VERSION NUMBER\n         MVC   RECVER,=F'-1'       INITIAL VERSION\n         MVC   RECVER+2(2),OLDVER  COPY OLD VERSION DATA\n         MVC   RSRDEV,OHDDEV       SOURCE DEVICE TYPE\n         MVC   RSRREC,OHDREC       SOURCE DATASET RECORD FORMAT\n         MVC   RSRLRE,OHDLRE       SOURCE DATASET LRECL\n         MVC   RSRBLK,OHDBLK       SOURCE DATASET BLKSIZE\n         MVC   RSRDSO,OHDDSO       SOURCE DATASET DSORG\n         MVC   RSRLMOD,OHDLMOD     SET TO X'FF' FOR LOAD MODULES\n         MVC   RSRRCNT,OHDRCNT     RECORD COUNT\n         OI    OHDTIME+3,X'0F'\n         UNPK  DWORK,OHDTIME       UNPACK TIME\n         MVC   RSRTIME(2),DWORK+1  MOVE THE HOUR OVER\n         MVI   RSRTIME+2,C':'      SEPARATOR\n         MVC   RSRTIME+3(2),DWORK+3 MOVE THE MINUTES\n         MVI   RSRTIME+5,C':'\n         MVC   RSRTIME+6(2),DWORK+5 AND SECONDS\n         ICM   R4,15,OHDDATE       LOAD THE DATE\n         LR    R5,R4               SAVE THE DATE VALUE\n         N     R5,=A(X'FFFF')      GET JUST JULIAN DAY# IN R5\n         SRL   R4,16               AND DECIMAL YEAR IN R4\n         SLL   R4,4\n         LA    R4,15(,R4)          ADD A ZONE TO THE YEAR\n         XC    DWORK,DWORK         CLEAR THE WORK AREA AGAIN\n         ST    R5,DWORK+4          STORE THE DAY AND\n         CVB   R5,DWORK            CONVERT IT TO BINARY\n         ST    R4,DWORK+4          NOW DO THE\n         CVB   R4,DWORK            FOR THE YEAR\n         LA    R15,SYTAB           LOAD STANDARD YEAR DATE-TABLE\n         LA    R0,3                'ANDING' VALUE IN R0\n         NR    R0,R4               IS THIS A LEAP YEAR ??\n         BNZ   *+8                 NOPE - - -\n         LA    R15,LYTAB           YES, USE LEAP-YEAR TABLE INSTEAD\n         LA    R2,0                LOAD INITIAL MONTH NUMBER\nMA2      DS    0H\n         CH    R5,0(,R15)          TOO MANY DAYS FOR THIS MONTH ??\n         BNH   MA3                 NOPE, IT'S THIS MONTH\n         SH    R5,0(,R15)          YES, ACCOUNT FOR THIS MONTH\n         LA    R15,2(,R15)         BUMP TABLE POINTER\n         LA    R2,1(,R2)           AND MONTH NUMBER\n         B     MA2                 AND LOOP, CONVERTING\nMA3      DS    0H\n         LA    R2,1(,R2)           FINAL ADJUSTMENT TO MONTH NUMBER\n         MH    R2,=H'1000'         MAKE ROOM FOR DAY\n         AR    R2,R5               AND ADD IT IN\n         MH    R2,=H'1000'         MAKE ROOM FOR YEAR\n         AR    R2,R4               AND ADD IT IN\n         CVD   R2,DWORK            CONVERT RESULT TO PACKED\n         UNPK  RSRDATE,DWORK(8)    ADD THE ZONES\n         OC    RSRDATE,=8X'F0'     FORCE ALL NUMERICS\n         MVI   RSRDATE+2,C'/'\n         MVI   RSRDATE+5,C'/'      ADD PUNCTUATION MARKS\n         L     R3,VS2LEN2          LOAD INPUT RECORD LENGTH\n         LA    R2,OHDPDIR-OLDREC   POINT TO DIRDATA START\n         SR    R3,R2               COMPUTE DIRDATA LENGTH\n         LA    R2,OHDPDIR          POINT TO DIRDATA START\n         LR    R5,R3               COPY THAT LENGTH\n         LA    R4,RSRPDIR          POINT TO THE OUTPUT AREA\n         MVCL  R4,R2               COPY THE DIRECTORY DATA\n         S     R4,VS1BUF2          COMPUTE RECORD LENGTH\n         ST    R4,VS1LEN2          AND SAVE IT\n         #SET  EXPL,OFF\n         CLI   RSRLMOD,0           IS THIS A LOAD MODULE ??\n         BNE   ENDCNV              YES ---\n         #SET  EXPL,ON             NO; NEEDS TO BE 'EXPLODED'\nENDCNV   DS    0H\n         BR    R14                 RETURN TO CALLER\n         DROP  R6,R7\nSYTAB    DC    H'31,28,31,30,31,30,31,31,30,31,30,31'\nLYTAB    DC    H'31,29,31,30,31,30,31,31,30,31,30,31'\n         LTORG\nERR1     DC    CL133'0*** ERROR *** ERROR OPENING THE VSAM1 CLUSTER.'\nERR2     DC    CL133'0*** ERROR *** ERROR OPENING THE VSAM2 CLUSTER.'\nERR4     DC    CL133'0*** ERROR *** THE VSAM CLUSTER KEY LENGTH IS INVAX\n               LID.  IS THIS THE CORRECT VSAM CLUSTER?'\nERR5     DC    CL133'0*** ERROR *** THE VSAM CLUSTER RECORD LENGTH IS TX\n               OO SMALL. IT MUST ALLOW 12000-BYTE RECORDS.'\nERR6     DC    CL133'0*** ERROR *** THIS CONTROL STATEMENT WILL BE IGNOX\n               RED.'\nERR14    DC    CL133'0          CONVERT PROCESSING COMPLETED.  TOTALS FX\n               OLLOW: '\nMCMSG    DC    CL133' '\n         ORG   MCMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202120'\n         DC    C' TOTAL ITEM(S) PROCESSED.'\n         ORG\n         LTORG\nMINREC   DC    A(RECSIZE)\n         SPACE 3\n         COPY  #RECS\n         COPY  ##ARCHWK\n         TITLE 'VSAM ARCHIVE RECORD FORMAT - PRE-VERSION 4 '\nOLDREC   DSECT\nOLDTT    DS    CL1   RECORD TYPE -------------+\nOLDN     DS    CL8   MEMBER NAME              |\nOLDG     DS    CL8   MEMBER GROUP             |\nOLDSG    DS    CL8   MEMBER SUBGROUP          +-- VSAM KEY\nOLDT     DS    CL8   MEMBER TYPE              |\nOLDVER   DS    XL2   MEMBER VERSION           |\nOLDSEQ#  DS    XL4   RECORD SEQUENCE NUMBER --+\nOLDKLEN  EQU   *-OLDTT   LENGTH OF KEY\nOLDDATA  EQU   *     COMPRESSED RECORD DATA\n         SPACE 3\n*\n* RECORD TYPES (ALL TYPES NOT DEFINED HERE ARE RESERVED)\n*\nOLDHDR   EQU   X'00'\nOLDCOMM  EQU   X'02'\nOLDMEMB  EQU   X'80'\n*\n* HEADER RECORD DESCRIPTION\n*\n         ORG   OLDDATA\nOHDDEV   DS    XL4                 SOURCE DEVICE TYPE\nOHDREC   DS    XL1                 SOURCE DATASET RECORD FORMAT\nOHDLRE   DS    XL2                 SOURCE DATASET LRECL\nOHDBLK   DS    XL2                 SOURCE DATASET BLKSIZE\nOHDDSO   DS    XL2                 SOURCE DATASET DSORG\nOHDLMOD  DS    XL1                 SET TO X'FF' FOR LOAD MODULES\nOHDT1LEN EQU   *-OLDREC\nOHDTIME  DS    XL4                 TIME OF UNLOAD\nOHDDATE  DS    PL4                 DATE OF UNLOAD\nOHDT2LEN EQU   *-OLDREC\nOHDRCNT  DS    XL4                 RECORD COUNT\nOHDT3LEN EQU   *-OLDREC\nOHDPDIR  DS    CL74                PDS DIRECTORY ENTRY\nOHDT4LEN EQU   *-OLDREC\n*\n* COMMENT RECORD DESCRIPTION\n*\n         ORG   OLDDATA\nOCMDATA  DS    CL68                UP TO 68 BYTES OF USER COMMENT DATA\n*\n* MEMBER DATA RECORD DESCRIPTION\n*\n         ORG   OLDDATA\nOLDMEM   DS    C                   COMPRESSED MEMBER DATA\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHCOPY": {"ttr": 2826, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x02\\x86\\x02\\x86\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 646, "newlines": 646, "modlines": 0, "user": "ARCHIVR"}, "text": "COPY     TITLE 'ARCHIVER --- COPY FUNCTION'\n*---------------------------------------------------------------------*\n*---     THIS IS THE ARCHIVER CLUSTER-TO-CLUSTER COPY FUNCTION.    ---*\n*---     ALL COPIES PROCEED FROM THE VSAM2 ARCHIVE TO THE VSAM1    ---*\n*---     ARCHIVE.  ITEM SELECT IS PROVIDED AND ALL GENERICS ARE    ---*\n*---     HONORED.                                                  ---*\n*---------------------------------------------------------------------*\nARCHCOPY CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n         COPY #ARCBITS\n         USING ARCHCOPY,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             COPY ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHCOPY,R11        DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             COPY NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RECOPY BACK POINTER\n         L     R14,12(,R14)        RECOPY ORIG. REG 14\n         LA    R10,0(,R11)         COPY ORIGINAL BASE REGISTER\n         AH    R10,PASSIT-2        BUMP BY A BASE'S WORTH\n         USING ARCHCOPY+4096,R10   AND DECLARE IT\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         XC    FCOUNT,FCOUNT       CLEAR FUNCTION RECORD COUNT\n         XC    MCNT,MCNT           AND MEMBER COUNT\n         XC    ACNT,ACNT           CLEAR A COUNTER, FOR LATER\n         MVC   VS1MODE,=CL8'OUTPUT' SET THE I/O MODE\n         LA    R1,VSAM1DD          LOAD THE PARM POINTER\n         LA    R0,0                AND THE 'OPEN' FLAG\n         CALL  ARCHVSOP            CALL THE 'OPEN' FUNCTION\n         LTR   R15,R15             OPEN OK ??\n         BNZ   ENDITALL            NOPE; CAN'T WORK\n         MVC   VS2MODE,=CL8'INPUT' SET THE I/O MODE\n         LA    R1,VSAM2DD          LOAD THE PARM POINTER\n         LA    R0,0                AND THE 'OPEN' FLAG\n         CALL  ARCHVSOP            CALL THE 'OPEN' FUNCTION\n         LTR   R15,R15             OPEN OK ??\n         BNZ   ENDITALL            NOPE; CAN'T WORK\n         XC    MCNT,MCNT           CLEAR THE COUNTERS\n         XC    TOKEN,TOKEN\n         XC    CHAIN,CHAIN\n         EJECT\n*---------------------------------------------------------------------*\n*---     HERE'S THE MEAT OF THE PROCESSING. THE BASIC PROCESS IS   ---*\n*---           THIS:                                               ---*\n*---                                                               ---*\n*---     1. USING THE CONTROL INFORMATION WE WERE GIVEN AND THE    ---*\n*---        INFORMATION WE'VE DEVELOPED, LOCATE THE HEADER RECORD  ---*\n*---        FOR THE FIRST MEMBER. WE'LL USE THE VS2BUF1 AREA FOR   ---*\n*---        HEADER/KEY CONSTRUCTION.                               ---*\n*---                                                               ---*\n*---     2. LOOP THROUGH THE MEMBER, READING THE RECORDS AND       ---*\n*---        COPYING THEM INTO THE OUTPUT VSAM BUFFER, WRITING AS   ---*\n*---        EACH BUFFER GETS FULL.                                 ---*\n*---                                                               ---*\n*---     3. AT END-OF-FILE FOR THE MEMBER, UPDATE THE VERSION      ---*\n*---        NUMBER, IF NOT SUPPLIED, AND LOOK FOR THE NEXT ITEM    ---*\n*---        TO COPY.                                               ---*\n*---                                                               ---*\n*---     VSAM BUFFER USAGE:                                        ---*\n*---           VS1BUF1: OUTPUT HEADER RECORD (MULTIPLE UPDATES)    ---*\n*---           VS1BUF2: OUTPUT DATA/NOTE RECORD                    ---*\n*---           VS1BUF3: USED BY ARCHERAS AS NEEDED                 ---*\n*---           VS2BUF1: INPUT HEADER RECORD (OR ALIAS RECORD)      ---*\n*---           VS2BUF2: INPUT 'REAL' HEADER RECORD (ALWAYS)        ---*\n*---           VS2BUF3: INPUT DATA/NOTE RECORD                     ---*\n*---                                                               ---*\n*---     NOTE THAT THESE ASSIGNMENTS ARE SUBJECT TO CHANGE         ---*\n*---     WITHOUT WARNING.                                          ---*\n*---                                                               ---*\n*---     IN ORDER TO AVOID COPYING THE SAME ITEM MULTIPLE TIMES,   ---*\n*---     DUE TO ALIASES, THE CHAIN/CHKCHAIN ROUTINES ARE COPIED    ---*\n*---     FROM ARCHLOAD AND USED FREELY.                            ---*\n*---------------------------------------------------------------------*\n         L     R6,VS2BUF1          POINT TO THE VSAM BUFFER\n         USING REC,R6              BASE THE RECORD DSECT\n         XC    0(RECKLEN,R6),0(R6)    START AT THE BEGINNING !!\n         MODCB RPL=(*,RPL4),                                           X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               ACB=(*,ACB2),                                           X\n               ARG=(6),                                                X\n               AREA=(6),                                               X\n               AREALEN=(*,VS2LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         L     R1,RPL4             COPY THE RPL ADDRESS\n         POINT RPL=(1)             GET TO IT\nNEXTHDR  DS    0H\n         L     R6,VS2BUF1          POINT TO THE RECORD\n*        MVI   RECTT,#RTHDR        INITIAL RECORD TYPE\n*        ICM   R15,15,RECVER       INSERT THE VERSION NUMBER\n*        AL    R15,=F'1'           INCREMENT BY ONE\n*        STCM  R15,15,RECVER       SAVE UPDATED VALUE\nGETHDR   DS    0H\n         L     R1,RPL4             COPY RPL ADDRESS\n         GET   RPL=(1)             AND READ A HEADER RECORD\n         LTR   R15,R15             ANYTHING LEFT ??\n         BNZ   ENDITALL            NOPE; ALL DONE\n         SHOWCB RPL=(*,RPL4),                                          X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,VS2LEN1),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\n         #IF   RSRALIAS,OFF,CHKA   'REAL' HEADER; CHECK IT\n         #IF   LDARCHA,OFF,NEXTHDR SKIPPING ALIASES ??\nCHKA     DS    0H\n         LA    R1,RECN             POINT TO THE HEADER\n         LA    R0,0                USE DEFAULT QUALIFIER DATA\n         CALL  ARCHKNAM            GO CHECK: DO WE PROCESS THIS ITEM ??\n         LTR   R15,R15             PASS THE CHECK ??\n         BNZ   NEXTHDR             NOPE ---\nSELECTED DS    0H\n         LA    R1,RECN             CHECK FOR A PREVIOUS COPY OF IT\n         #IF   RSRALIAS,OFF,SELA   THIS AIN'T AN ALIAS\n         LA    R1,RECAN            CHECK FOR A PREVIOUS COPY OF IT\nSELA     DS    0H\n         BAL   R14,CHKCHN          CALL CHAIN-CHECKER\n         LTR   R15,R15             WAS IT PRESENT ??\n         BNZ   NEXTHDR             YES ---\n*---------------------------------------------------------------------*\n*---     THIS ITEM WAS SELECTED. CONSTRUCT THE 'TRUE' KEY IN       ---*\n*---     VS2BUF2 AND GO GET THE TRUE HEADER RECORD.  ALSO DO THE   ---*\n*---     TRUENAME CHAIN ADD.  IF THE TRUE HEADER CAN'T BE FOUND,   ---*\n*---     JUST IGNORE THIS ITEM COMPLETELY.                         ---*\n*---------------------------------------------------------------------*\n         LA    R1,RECN             POINT TO ITEM NAME\n         #IF   RSRALIAS,OFF,SELB   THIS AIN'T AN ALIAS\n         LA    R1,RECAN            NOW THE TRUE NAME !!\nSELB     DS    0H\n         BAL   R14,CHAINER         CALL CHAIN-BUILDER\n         L     R2,VS2BUF2          LOAD THE BUFFER POINTER\n         MVC   0(RECKLEN,R2),RECTT COPY THE RECORD KEY\n         #IF   RSRALIAS,OFF,SEL1   NOT AN ALIAS RECORD\n         MVC   1(44,R2),RECAN      COPY THE 'TRUE' NAME VALUES\nSEL1     DS    0H\n         LR    R6,R2               BASE DSECT ON VS2BUF2\n         MVC   BLDLAREA(RECKLEN),0(R6) SAVE KEY FOR ALIAS COPIER\n         MODCB RPL=(*,RPL5),                                           X\n               OPTCD=(DIR,FKS,KGE,SYN,NUP),                            X\n               ACB=(*,ACB2),                                           X\n               ARG=(6),                                                X\n               AREA=(6),                                               X\n               AREALEN=(*,VS2LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         L     R1,RPL5             POINT TO THE RPL\n         GET   RPL=(1)             AND READ THE HEADER\n         LTR   R15,R15             DID IT READ OK ??\n         BNZ   NEXTHDR             NOPE; SKIP THIS ITEM\n         SHOWCB RPL=(*,RPL5),                                          X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,VS2LEN2),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\n*---------------------------------------------------------------------*\n*---     AT THIS POINT, WE'VE DETERMINED THAT THIS ITEM NEEDS TO   ---*\n*---     BE COPIED. NOW WE CHECK THE VERSION NUMBER.  IF WE'RE     ---*\n*---     NOT REPLACING A SIMILAR VERSION, WE WILL TRY TO WRITE     ---*\n*---     THIS HEADER.  EACH TIME WE GET A DUPLICATE RECORD         ---*\n*---     INDICATION FROM VSAM, WE'LL INCREMENT THE VERSION NUMBER  ---*\n*---     BY ONE AND TRY AGAIN.  THIS WILL DETERMINE THE MAJORITY   ---*\n*---     OF THE KEY FOR ALL SUBSEQUENT RECORDS IN THIS ITEM AS     ---*\n*---     WELL.  IF, ON THE OTHER HAND, WE'RE REPLACING ANY         ---*\n*---     DUPLICATE DATA, WE'LL SIMPLY CALL ARCHERAS TO REMOVE ANY  ---*\n*---     PRE-EXISTING ITEM OF A MATCHING KEY.                      ---*\n*---------------------------------------------------------------------*\n         L     R6,VS2BUF2          LOAD THE INPUT RECORD POINTER\n         L     R7,VS2LEN2          LOAD THE RECORD LENGTH\n         L     R2,VS1BUF2          LOAD THE OUTPUT BUFFER ADDRESS\n         LR    R3,R7               AND SET A LENGTH\n         ST    R3,VS1LEN2          SAVE FOR THE 'PUT'TER\n         MVCL  R2,R6               COPY THE RECORD\n         L     R6,VS1BUF2          RELOAD THE BUFFER POINTER\n         XC    RSRNOT#,RSRNOT#     NO NOTES, YET ---\nPUTHDR   DS    0H\n         LR    R1,R6               COPY THE RECORD POINTER\n         L     R0,VS2LEN2          AND LENGTH\n         BAL   R14,VSPUT           GO WRITE THE RECORD (MAYBE)\n         LTR   R15,R15             DUPLICATE RECORD ??\n         BZ    DONOTES             NOPE; ALL IS OK ---\n         #IF   REPL,ON,DELEIT      DELETE FOR REPLACEMENT ??\n         ICM   R15,15,RECVER       INSERT THE VERSION NUMBER\n         BCTR  R15,R0              UP BY ONE\n         STCM  R15,15,RECVER\n         B     PUTHDR              GO RETRY THE PUT\nDELEIT   DS    0H\n         LR    R1,R6               LOAD THE BUFFER POINTER\n         CALL  ARCHERAS            DELETE THE DUPLICATE ITEM\n         B     PUTHDR              AND GO RETRY THE 'PUT'\nDONOTES  DS    0H\n         L     R7,VS2BUF2          LOAD HEADER-RCD ADDRESS\n         L     R6,VS2BUF3          POINT TO THE OTHER BUFFER\n         MVC   0(RECKLEN,R6),0(R7) COPY THAT KEY\n         MVI   RECTT,#RTNOTE       RESET TO NOTE TYPE\n         MODCB RPL=(*,RPL6),                                           X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               ARG=(6),                                                X\n               ACB=(*,ACB2),                                           X\n               AREA=(*,VS2BUF3),                                       X\n               AREALEN=(*,VS2LIM),                                     X\n               MF=(G,GENWK)        POSITION TO ITEM NOTE START\n         L     R1,RPL6             COPY THE RPL ADDRESS\n         POINT RPL=(1)             GET TO IT\n         L     R4,VS1BUF2          LOAD OUTPUT BUFFER POINTER\n         MVI   0(R4),#RTNOTE       SET TYPE FOR NOTES\n         LA    R0,1                LOAD INITIAL SEQ# VALUE\n         STCM  R0,15,RECSEQ#-REC(R4) SAVE THAT NUMBER\n         LA    R0,RECKLEN          LOAD KEY LENGTH\n         ST    R0,VS1LEN2          SAVE AS INITIAL RECORD LENGTH\nNT1      DS    0H\n         L     R1,RPL6             POINT TO THE RPL\n         GET   RPL=(1)             GO READ A MEMBER NOTE RECORD\n         LTR   R15,R15             DID IT COMPLETE OK ??\n         BNZ   NTDONE              NOPE; ASSUME WE'RE DONE WITH NOTES\n         SHOWCB RPL=(*,RPL6),                                          X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,VS2LEN3),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\n         CLI   RECTT,#RTNOTE       DATA RECORD ??\n         BNE   NTDONE\n         CLC   1(RECKLEN-5,R6),1(R7) STILL IN THE RIGHT ITEM ??\n         BNE   NTDONE              NOPE; GO DO THE DATA RECORDS\n         L     R6,VS2BUF3          LOAD THE BUFFER POINTER\n         LA    R3,RDATDATA         POINT TO NOTE DATA\n         L     R4,VS2LEN3          LOAD RECORD LENGTH\n         LA    R4,0(R4,R6)         POINT TO\n         BCTR  R4,R0                 LAST DATA BYTE\nNT2      DS    0H\n         #ADDBLK BUFFER=2,                                             X\n               RECORD=3(,R3),                                          X\n               LENGTH=0(,R3),                                          X\n               RTN=VSPUT,                                              X\n               ERR=TOOLONG\n         LA    R15,0               CLEAR A WORK REGISTER\n         ICM   R15,7,0(R3)         INSERT SEGMENT LENGTH\n         LA    R3,3(R15,R3)        POINT TO NEXT INPUT SEGMENT\n         CR    R3,R4               PAST THE END LET ??\n         BL    NT2                 NOPE ---\n         B     NT1                 YES; GET ANOTHER RECORD\nNTDONE   DS    0H\n         #ADDBLK BUFFER=2,                                             X\n               RTN=VSPUT,                                              X\n               LAST=YES\nNT5      DS    0H\n*---------------------------------------------------------------------*\n*---     NOTE DATA IS COPIED. NOW UPDATE THE NOTE DATA LAST        ---*\n*---     SEQUENCE NUMBER FIELD IN THE HEADER RECORD. WE'LL USE     ---*\n*---     THE VS1BUF2 BUFFER AREA FOR THIS UPDATE.                  ---*\n*---------------------------------------------------------------------*\n         L     R2,VS1BUF2          POINT TO THE LAST OUTPUT BUFFER\n         ICM   R4,15,RECSEQ#-REC(R2) LOAD THE SEQUENCE NUMBER\n         BCTR  R4,R0               BACK UP TO LAST TRUE VALUE\n         XC    RECSEQ#-REC(4,R2),RECSEQ#-REC(R2) CLEAR THAT VALUE\n         MVI   0(R2),#RTHDR        SET 'HEADER' TYPE\n         MODCB RPL=(*,RPL1),                                           X\n               OPTCD=(DIR,FKS,KEQ,SYN,UPD),                            X\n               ACB=(*,ACB1),                                           X\n               ARG=(*,VS1BUF2),                                        X\n               AREA=(*,VS1BUF2),                                       X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        VSAM SETUP FOR UPDATE\n         L     R1,RPL1             POINT TO THE RPL\n         GET   RPL=(1)             READ THE HEADER RECORD\n         LTR   R15,R15             DID WE GET IT OK ??\n         BZ    NT6                 YES ---\n         L     R4,RPL1             LOAD THE RPL ADDRESS\n         ABEND 100,DUMP            AND DIE HOFFIBLY\nNT6      DS    0H\n         L     R2,VS1BUF2          LOAD THE BUFFER ADDRESS\n         STCM  R4,15,RSRNOT#-REC(R2) UPDATE NOTE-RECORD COUNT\n         L     R1,RPL1             LOAD THE RPL ADDRESS\n         PUT   RPL=(1)             AND UPDATE THE RECORD\n         LTR   R15,R15             DID WE UPDATE IT OK ??\n         BZ    NTEND               YES ---\n         L     R4,RPL1             LOAD THE RPL ADDRESS\n         ABEND 100,DUMP            AND DIE HORRIBLY\nNTEND    DS    0H\n         L     R7,VS2BUF2          LOAD HEADER-RCD ADDRESS\n         L     R6,VS2BUF3          POINT TO THE OTHER BUFFER\n         MVC   0(RECKLEN,R6),0(R7) COPY THAT KEY\n         MVI   RECTT,#RTDATA       RESET TO DATA TYPE\n         MODCB RPL=(*,RPL6),                                           X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               ARG=(6),                                                X\n               ACB=(*,ACB2),                                           X\n               AREA=(*,VS2BUF3),                                       X\n               AREALEN=(*,VS2LIM),                                     X\n               MF=(G,GENWK)        POSITION TO ITEM DATA START\n         L     R1,RPL6             COPY THE RPL ADDRESS\n         POINT RPL=(1)             GET TO IT\n         L     R4,VS1BUF2          LOAD OUTPUT BUFFER POINTER\n         LA    R0,1                LOAD INITIAL SEQ# VALUE\n         STCM  R0,15,RECSEQ#-REC(R4) SAVE THAT NUMBER\n         MVI   0(R4),#RTDATA       SET TYPE FOR DATA\n         LA    R0,RECKLEN          LOAD KEY LENGTH\n         ST    R0,VS1LEN2          SAVE AS INITIAL RECORD LENGTH\nDT1      DS    0H\n         L     R1,RPL6             POINT TO THE RPL\n         GET   RPL=(1)             GO READ A MEMBER DATA RECORD\n         LTR   R15,R15             DID IT COMPLETE OK ??\n         BNZ   DTDONE              NOPE; ASSUME WE'RE DONE WITH DATA\n         SHOWCB RPL=(*,RPL6),                                          X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,VS2LEN3),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\n         CLI   RECTT,#RTDATA       DATA RECORD ??\n         BNE   DTDONE\n         CLC   1(RECKLEN-5,R6),1(R7) STILL IN THE RIGHT ITEM ??\n         BNE   DTDONE              NOPE; GO DO THE DATA RECORDS\n         L     R6,VS2BUF3          LOAD INPUT BUFFER POINTER\n         LA    R3,RDATDATA         POINT TO DATA DATA\n         L     R4,VS2LEN3          LOAD RECORD LENGTH\n         LA    R4,0(R4,R6)         POINT TO\n         BCTR  R4,R0                 LAST DATA BYTE\nDT2      DS    0H\n         #ADDBLK BUFFER=2,                                             X\n               RECORD=3(,R3),                                          X\n               LENGTH=0(,R3),                                          X\n               RTN=VSPUT,                                              X\n               ERR=TOOLONG\n         LA    R15,0               CLEAR A WORK REGISTER\n         ICM   R15,7,0(R3)         INSERT SEGMENT LENGTH\n         LA    R3,3(R15,R3)        POINT TO NEXT INPUT SEGMENT\n         CR    R3,R4               PAST THE END YET ??\n         BL    DT2                 NOPE ---\n         B     DT1                 YES; GET ANOTHER RECORD\nDTDONE   DS    0H\n         #ADDBLK BUFFER=2,                                             X\n               RTN=VSPUT,                                              X\n               LAST=YES\n         L     R1,MCNT             LOAD MEMBER COUNT\n         LA    R1,1(,R1)           INCREMENT BY ONE\n         ST    R1,MCNT             SAVE UPDATED COUNT\n         L     R6,VS2BUF2          LOAD THE INPUT HEADER ADDRESS\n         MVC   LINE,SEP            MOVE IN A SEPARATOR LINE\n         #PUT  LINE                AND PRINT IT\n         #FORMAT RECTT,,INMSG\n         #PUT  LINE\n         L     R6,VS1BUF2          LOAD OUTPUT HEADER VALUES\n         #FORMAT RECTT,,OUTMSG\n         #PUT  LINE\n         #IF   RETA,OFF,NEXTHDR    DON'T BOTHER WITH ALIASES\n*---------------------------------------------------------------------*\n*---     COPY ALIASES, IF ALIASES=(Y|YES) WAS SPECIFIED.          ----*\n*---------------------------------------------------------------------*\n         L     R2,VS1BUF2          POINT TO OUTPUT BUFFER\n         XC    RECSEQ#-REC(100,R2),RECSEQ#-REC\n         MVC   RECAN-REC(44,R2),1(R2) COPY 'REAL' NAME FIELDS\n         DROP  R6\n         USING REC,R2\n         #SET  RSRALIAS,ON\n         DROP  R2\n         USING REC,R6\n         L     R6,VS2BUF2          POINT TO THE BUFFER\n         XC    0(RECKLEN,R6),0(R6) START AT THE BEGINNING !!\n         MODCB RPL=(*,RPL5),                                           X\n               OPTCD=(SEQ,FKS,KGE,SYN,UPD),                            X\n               ARG=(R6),                                               X\n               AREA=(R6),                                              X\n               AREALEN=(*,VS2LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         L     R1,RPL5\n         POINT RPL=(1)             GET TO IT\nAC       DS    0H\n         L     R1,RPL5\n         GET   RPL=(1)             AND READ A HEADER RECORD\n         LTR   R15,R15             ANYTHING LEFT ??\n         BNZ   NEXTHDR             NOPE; ALL DONE\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   NEXTHDR             NOPE; ALL DONE ---\n         #IF   RSRALIAS,OFF,AC     NOT AN ALIAS RECORD\n         CLC   RECAN(44),BLDLAREA+1 IS THIS ONE WE COPY ??\n         BNE   AC                  NOPE ---\n         SHOWCB RPL=(*,RPL5),                                          X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,VS2LEN2),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\n         MVC   0(RECKLEN,R2),0(R6) COPY THE ALIAS VALUES\n         MODCB RPL=(*,RPL2),       RPL ADDRESS                         X\n               OPTCD=(DIR,FKS,NUP,MVE,KEQ), OPTION CODES ---           X\n               ARG=(2),            KEY ADDRESS                         X\n               AREA=(2),           BUFFER ADDRESS                      X\n               RECLEN=RECAVER+4-REC, RECORD LENGTH                     X\n               MF=(G,GENWK)\nAC2      DS    0H\n         L     R1,RPL2\n         PUT   RPL=(1)             WRITE THE UPDATED RECORD\n         LTR   R15,R15             ANYTHING ??\n         BZ    AC3                 NOPE; ALL OK SO FAR\n         L     R0,RECVER-REC(R2)   LOAD VERSION NUMBER\n         BCTR  R0,R0               INCREMENT BY ONE\n         ST    R0,RECVER-REC(R2)   SAVE UPDATED VALUE\n         B     AC2                 AND TRY AGAIN\nAC3      DS    0H\n         L     R15,ACNT            LOAD THE COUNTER\n         LA    R15,1(,R15)         INCREMENT BY ONE\n         ST    R15,ACNT            AND SAVE UPDATED COUNT\n         #FORMAT 0(,R2),,AC4       OUTPUT THE 'ALIAS IS COPIED.' MSG\n         #PUT  LINE\n         B     AC                  LOOP FOR MORE ---\nAC4      DC    AL1(AC6-AC5)\nAC5      DC    C'ALIAS IS COPIED. (VERSION MAY BE ALTERED.)'\nAC6      EQU   *\nINMSG    DC    AL1(INEND-INMSG1)\nINMSG1   DC    C' WAS COPIED TO ---   '\nINEND    EQU   *\nOUTMSG   DC    AL1(OUTEND-OUTMSG1)\nOUTMSG1  DC    C' ON OUTPUT VSAM CLUSTER. '\nOUTEND   EQU   *\n         SPACE 3\n*---------------------------------------------------------------------*\n*---     IF WE REACH THIS LABEL, WE'VE GOT AT LEAST ONE RECORD     ---*\n*---     THAT CANNOT BE MADE TO FIT IN THE OUTPUT ARCHIVE          ---*\n*---     CLUSTER. ISSUE AN ERROR MESSAGE AND ERASE THE             ---*\n*---     PARTIALLY-COPIED ITEM.                                    ---*\n*---------------------------------------------------------------------*\nTOOLONG  DS    0H\n         L     R1,VS2BUF2          LOAD THE HEADER ADDRESS\n         #FORMAT 0(,R1),,LNGREC\n         #PUT  LINE                PRINT THE ERROR\n         L     R1,VS1BUF1          POINT TO THE RECORD KEY\n         CALL  ARCHERAS            DELETE PARTIAL ITEM\n         B     NEXTHDR             GO FOR ANOTHER ITEM\nLNGREC   DC    AL1(LNGRECE-LNGRECS)\nLNGRECS  DC    C' CANNOT BE COPIED. AT LEAST ONE RECORD TOO LONG.'\nLNGRECE  EQU   *\nENDITALL DS    0H\n         #PUT  ERR12\n         L     R0,MCNT             COPY MEMBER COUNT\n         LTR   R0,R0               ZERO ??\n         BZ    COEND               YES ---\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,MCMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\n         L     R0,ACNT             COPY MEMBER COUNT\n         LTR   R0,R0               ZERO ??\n         BZ    COEND               YES ---\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,ACMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\nCOEND    DS    0H\n         L     R0,TOKEN            LOAD CPPB POINTER\n         LTR   R0,R0               WAS THERE ANY ??\n         BZ    COEND1              NOPE ---\n         CALL  CELLDEL\n         XC    TOKEN,TOKEN         CLEAR THAT POINTER\nCOEND1   DS    0H\n         LA    R1,VSAM1DD          POINT TO THE DDNAME\n         LA    R0,4                SET 'CLOSE' REQUEST\n         CALL  ARCHVSOP            CALL THE VSAM 'CLOSE' ROUTINE\n         LA    R1,VSAM2DD          POINT TO THE DDNAME\n         LA    R0,4                SET 'CLOSE' REQUEST\n         CALL  ARCHVSOP            CALL THE VSAM 'CLOSE' ROUTINE\n         L     R13,4(,R13)         COPY BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ALWAYS RC = 0\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\n         TITLE 'VSAM I/O OUTPUT '\n*---------------------------------------------------------------------*\n*---     THIS LITTLE LOCAL SUBROUTINE DOES ALL THE VSAM WRITING    ---*\n*---     FOR THE COPY FUNCTION, WITH THE EXCEPTION OF THE ERASURE  ---*\n*---     OF A DUPLICATE ITEM.  THE BASIC ASSUMPTIONS ARE THAT THE  ---*\n*---     VS1BUF1 AREA IS THE RECORD TO BE WRITTEN AND ITS LENGTH   ---*\n*---     IS ACCURATELY REPORTED IN THE VS1LEN1 FIELD.  THE         ---*\n*---     INITIAL-LOAD CONDITION IS PROPERLY HANDLED HERE, IF       ---*\n*---     NECESSARY.                                                ---*\n*---------------------------------------------------------------------*\nVSPUT    DS    0H\n         STM   R14,R12,IOSAVE      SAVE ENTRY REGISTERS\n         L     R4,RPL1             LOAD RPL ADDRESS\n         LR    R5,R1               LOAD BUFFER ADDRESS\n         LR    R6,R0               LOAD RECORD LENGTH\n         MODCB RPL=(4),            RPL ADDRESS                         X\n               OPTCD=(DIR,FKS,NUP,MVE,KEQ), OPTION CODES ---           X\n               ARG=(5),            KEY ADDRESS                         X\n               AREA=(5),           BUFFER ADDRESS                      X\n               RECLEN=(6),         RECORD LENGTH                       X\n               MF=(G,GENWK)\n         PUT   RPL=(4)             OUTPUT THE VSAM RECORD\n         LR    R3,R15              SAVE THAT RETURN CODE\n         SHOWCB RPL=(4),                                               X\n               FIELDS=FDBK,        FETCH THE RPL FEEDBACK FIELD        X\n               AREA=(S,DWORK),                                         X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        GET RECORD LENGTH\n         B     *+4(R3)             CHECK THE 'PUT' RETURN CODE\n         B     VSPUT5              ALL IS OK\n         B     VSPUT1              RPL SHOWS SOMETHING HAPPENING\n         B     VSPUT3              LOGICAL ERROR\n         B     VSPUTDIE            PHYSICAL ERROR\nVSPUT1   DS    0H\n         LA    R8,0                CLEAR A COUNTER REGISTER\nVSPUT2   DS    0H\n         CH    R8,=H'3'            PAST THE LIMIT YET ??\n         BH    VSPUTDIE            YES ---\n         LA    R8,1(,R8)           NOPE; INCREMENT COUNTER\n         PUT   RPL=(4)             OUTPUT THE VSAM RECORD\n         LR    R3,R15              SAVE THAT RETURN CODE\n         SHOWCB RPL=(4),                                               X\n               FIELDS=FDBK,        FETCH THE RPL FEEDBACK FIELD        X\n               AREA=(S,DWORK),                                         X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        GET RECORD LENGTH\n         B     *+4(R3)             CHECK THE 'PUT' RETURN CODE\n         B     VSPUT5              ALL IS OK\n         B     VSPUT2              RPL SHOWS SOMETHING HAPPENING\n         B     VSPUT3              LOGICAL ERROR\n         B     VSPUTDIE            PHYSICAL ERROR\nVSPUT3   DS    0H                  LOGICAL ERROR HAS OCCURED\n         CLI   DWORK+3,8           DUPLICATE KEY ??\n         BNE   VSPUT4              NOPE ---\n         LA    R15,4               LOAD THE RETURN CODE\n         B     VSPUT5              AND TERMINATE\nVSPUT4   DS    0H\n         CLI   DWORK+3,116         INITIAL LOAD IN PROGRESS ??\n         BNE   VSPUTDIE            NOPE; SOME OTHER ERROR\n         MODCB RPL=(4),            RPL ADDRESS                         X\n               OPTCD=(SEQ,NUP,MVE,KEQ), OPTION CODES ---               X\n               MF=(G,GENWK)\n         LR    R7,R15\n         PUT   RPL=(4)             RE-DO THE PUT\n         LTR   R15,R15             OK NOW ??\n         BNZ   VSPUTDIE            NOPE; STILL SHAFTED\n         CLOSE ,MF=(E,ACB1)        CLOSE THE CLUSTER\n         OPEN  ,MF=(E,ACB1)        AND RE-OPEN THE CLUSTER\nVSPUT5   DS    0H\n         L     R14,IOSAVE          RELOAD R14\n         LM    R0,R12,IOSAVE+8     RESTORE OTHER REGS\n         BR    R14                 AND RETURN TO CALLER\nVSPUTDIE DS    0H\n         ABEND 100,DUMP\n         LTORG\n*---------------------------------------------------------------------*\n*---     THIS ROUTINE WILL ADD THE 'REAL' NAME WE JUST LOADED TO   ---*\n*---     A CHAIN OF REAL NAMES IN STORAGE.  THE CHAIN IS 'ROOTED'  ---*\n*---     IN THE 'COUNT' FIELD OF THE ARCHIVER'S MAIN WORK AREA.    ---*\n*---     THE PURPOSE OF THIS CHAIN IS TO PREVENT LOADING THE SAME  ---*\n*---     ITEM MULTIPLE TIMES IF IT HAS MULTIPLE ALIASES AND WE'RE  ---*\n*---     LOADING BASED ON ALIAS CHECKS AS WELL AS REAL NAME        ---*\n*---     CHECKS.                                                   ---*\n*---                                                               ---*\n*---     MY USE OF CELL POOL MANAGEMENT HERE PRECLUDES USING THIS  ---*\n*---     ROUTINE IN ANY MVS/370 SYSTEM.                            ---*\n*---                                                               ---*\n*---     REGISTER 1 IS ASSUMED TO POINT TO THE 44-BYTE QUALIFIER   ---*\n*---     DATA TO BE ADDED TO THE CHAIN.                            ---*\n*---------------------------------------------------------------------*\nCHAINER  DS    0H\n         STM   R14,R12,IOSAVE      SAVE THE ENTRY REGISTERS\n         LR    R2,R1               COPY THE DATA POINTER\n         NC    TOKEN,TOKEN         IS CELL POOL INIT'D ??\n         BNZ   CHAIN1              YES ---\n         CNOP  0,4\n         BAL   R1,BLDPOOL          BRANCH AROUND PARM LIST\n         DC    F'100'\n         DC    F'100'\n         DC    F'48'\n         DC    AL1(14)\n         DC    AL1(20)\n         DC    CL20'REAL NAMES COPIED'\nBLDPOOL  DS    0H\n         CALL  CELLBLD\n         ST    R0,TOKEN            SAVE THE 'TOKEN' VALUE\nCHAIN1   DS    0H\n         L     R0,TOKEN            LOAD THE 'TOKEN' VALUE\n         CALL  CELLGET             GO GRAB A Q'CELL\n         XC    0(48,R1),0(R1)      CLEAR IT OUT\n         MVC   0(4,R1),CHAIN       INSERT INTO THE\n         ST    R1,CHAIN              CHAIN\n         MVC   4(44,R1),0(R2)      COPY DATA INTO THE CHAIN\n         LM    R14,R12,IOSAVE      RESTORE THE REGISTERS\n         LA    R15,0               ZERO RETURN CODE\n         BR    R14                 AND RETURN TO MY CALLER\n         EJECT\n*---------------------------------------------------------------------*\n*---     THIS ROUTINE CHECKS THROUGH THE CHAIN BUILT BY 'CHAIN'    ---*\n*---     TO SEE IF WE'VE ALREADY PROCESSED THE ITEM WHOSE          ---*\n*---     QUALIFIERS ARE POINTED TO BY REGISTER 1.  IF A MATCH IS   ---*\n*---     FOUND, A RETURN CODE OF 4 IS SET IN REGISTER 15, ELSE     ---*\n*---     THE RETURN CODE IS ZERO.                                  ---*\n*---------------------------------------------------------------------*\nCHKCHN   DS    0H\n         STM   R14,R2,IOSAVE       SAVE THE ENTRY REGISTERS\n         MVC   IOSAVE+4(4),=F'4'   SET INITIAL RETURN CODE\n         L     R2,CHAIN            LOAD THE FIRST LINK POINTER\n         B     CHKCHN2             AND GO CHECK FOR ANY LINK\nCHKCHN1  DS    0H\n         CLC   4(44,R2),0(R1)      DOES IT MATCH ??\n         BE    CHKCHN3             YES; ERROR RETURN CODE\n         L     R2,0(,R2)           POINT TO NEXT LINK\nCHKCHN2  DS    0H\n         LTR   R2,R2               ANOTHER LINK ??\n         BNZ   CHKCHN1             YES ---\n         XC    IOSAVE+4(4),IOSAVE+4  NOPE; SET ZERO RETURN CODE\nCHKCHN3  DS    0H\n         LM    R14,R2,IOSAVE       RESTORE REGISTERS\n         BR    R14                 AND RETURN TO CALLER\nERR12    DC    CL133'0             COPY PROCESSING COMPLETED.  TOTALS FX\n               OLLOW: '\nMCMSG    DC    CL133' '\n         ORG   MCMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202120'\n         DC    C' TOTAL ITEM(S) PROCESSED.'\n         ORG\nACMSG    DC    CL133' '\n         ORG   ACMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202120'\n         DC    C' TOTAL ALIAS(ES) PROCESSED.'\n         ORG\nSEP      DC    C' '\n         DC    132C'-'\n         COPY  #RECS\n         COPY  ##ARCHWK\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHDEL": {"ttr": 3329, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00v\\x00v\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 118, "newlines": 118, "modlines": 0, "user": "ARCHIVR"}, "text": "DELE     TITLE 'ARCHIVER --- DELETE FUNCTION'\n*---------------------------------------------------------------------*\n*---    THIS ROUTINE IS THE MAIN DRIVER FOR THE DELETE FUNCTION.   ---*\n*---    WE HAVE A SPECIAL CASE IN THE DELETE FUNCTION TO ALLOW     ---*\n*---    FOR THE VARIATIONS THAT MAY BE REQUESTED BY THE USER.      ---*\n*---    THIS IS PRIMARILY DUE TO THE WAYS THAT ALIASES MAY BE      ---*\n*---    PROCESSED.                                                 ---*\n*---                                                               ---*\n*---    TO FURTHER EXAMINE HOW THE DELETE PROCESSING IS ACTUALLY   ---*\n*---    DONE AND WHAT ARCHIVE RECORDS ARE PROCESSED, REFER TO      ---*\n*---    THE MODULE HEADER IN EACH OF THE ARCHDELX MODULES.         ---*\n*---    WHILE SOME OF THE DIFFERENCES MAY SEEM RELATIVELY          ---*\n*---    SUBTLE, THE LOGIC PROBLEMS RELATED TO EACH FUNCTION WERE   ---*\n*---    COMPLEX ENOUGH, TO ME, TO JUSTIFY SEPARATE ROUTINES FOR    ---*\n*---    EACH FORM.                                                 ---*\n*---------------------------------------------------------------------*\n         EJECT\nARCHDEL  CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n         COPY #ARCBITS\n         USING ARCHDEL,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             DELE ROUTINE BASE REGISTER\n         LH    R10,PASSIT-2\n         LA    R10,0(R10,R11)\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHDEL,R11,R10     DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             DELE NEW SAVE AREA POINTER\n         L     R14,4(,R13)         REDELE BACK POINTER\n         L     R14,12(,R14)        REDELE ORIG. REG 14\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n*---------------------------------------------------------------------*\n*---     NOW DECIDE WHICH ARCHDELX ROUTINE TO CALL, AND CALL IT    ---*\n*---                                                               ---*\n*---     THE OPERANDS ARE CHECKED ACCORDING TO A DISTINCT          ---*\n*---     HIERARCHY, PARTLY BECAUSE OF THE CODING INVOLVED IN       ---*\n*---     CHECKING THINGS.  THE SELECTION IS DONE BY SETTING SOME   ---*\n*---     BITS IN R2 AND USING THAT VALUE AS AN INDEX INTO A TABLE  ---*\n*---     OF V-CONS FOR THE VARIOUS DELETE ROUTINES.                ---*\n*---                                                               ---*\n*---------------------------------------------------------------------*\n         LA    R2,0                CLEAR THE INDEX REG, TO START\n         #IF   RETA,OFF,NO1        ALIASES NOT SPECIFIED\n         O     R2,=A(X'01')        INSERT THE VALUE\nNO1      DS    0H\n         #IF   PRCB,OFF,NO2        BACK LEVELS ??\n         O     R2,=A(X'02')        YES ---\nNO2      DS    0H\n         #IF   PRCCM,OFF,NO3       NOTE DATA ??\n         O     R2,=A(X'04')        YES ---\nNO3      DS    0H\n         #IF   SHITEM,OFF,NO4      ITEM DATA ??\n         O     R2,=A(X'08')        YES ---\nNO4      DS    0H\n         SLL   R2,2                RESULT TIMES 4\n         L     R15,VCONS(R2)       POINT TO THE DELETE ROUTINE\n         BALR  R14,R15             CALL THE APPROPRIATE DELETER\nDELEND   DS    0H\n         XC    CHAIN,CHAIN         CLEAR THE CHAIN POINTER\n         L     R13,4(,R13)         LOAD BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ALWAYS RC = 0\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\nDELB1    DS    0H\n         #PUT  DELB1M              INVALID OPERAND COMBINATION\n         #PUT  DELB2M              INVALID OPERAND COMBINATION\n         B     DELEND              AND QUIT ---\nDELB1M   DC    CL133' *** ERROR *** OPERAND MISSING. STATEMENT IS IGNORX\n               ED.'\nDELB2M   DC    CL133'               YOU MUST SPECIFY SOME COMBINATION OX\n               F ALIASES, NOTE, DATA AND/OR BACK ON A DELETE.'\nDELBX    DS    0H\n         #PUT  DELBXA              INVALID OPERAND COMBINATION\n         #PUT  DELBXB              INVALID OPERAND COMBINATION\n         B     DELEND              AND QUIT ---\nDELBXA   DC    CL133' *** ERROR *** YOU CAN''T DELETE THE DATA UNLESS YX\n               ALSO SPECIFY THAT NOTE DATA IS TO BE DELETED.'\nDELBXB   DC    CL133'               THIS REQUEST HAS BEEN IGNORED.'\nVCONS    DC    A(DELB1)            NO OPERANDS; INVALID\n         DC    V(ARCHDEL1)         ALIASES ONLY\n         DC    V(ARCHDEL2)         BACK LEVELS BUT NOT ALIASES\n         DC    V(ARCHDEL3)         ALIASES FOR BACK VERSIONS\n         DC    V(ARCHDEL4)         ALL NOTE DATA (CURRENT ONLY)\n         DC    V(ARCHDEL5)         NOTES & ALIASES (CURRENT ONLY)\n         DC    V(ARCHDEL6)         NOTE DATA FROM BACK LEVELS\n         DC    V(ARCHDEL7)         DEL. NOTES & ALIAS FROM BACKLVLS\n         DC    A(DELBX)            DATA WITHOUT NOTES INVALID\n         DC    A(DELBX)            DATA WITHOUT NOTES INVALID\n         DC    A(DELBX)            DATA WITHOUT NOTES INVALID\n         DC    A(DELBX)            DATA WITHOUT NOTES INVALID\n         DC    V(ARCHDELC)         DELETE SELECTED ITEM(S)\n         DC    V(ARCHDELD)         SELECTED ITEM(S) & ITS ALIASES\n         DC    V(ARCHDELE)         BACK LEVELS IF ALIASES EXIST\n         DC    V(ARCHDELF)         ITEM, BACKUPS & ALIASES\n         LTORG\n         COPY  #RECS\n         COPY  ##ARCHWK\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHDELC": {"ttr": 3332, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x01\\\\\\x01\\\\\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 348, "newlines": 348, "modlines": 0, "user": "ARCHIVR"}, "text": "DELC     TITLE 'ARCHIVER --- DELETE FUNCTION'\n*---------------------------------------------------------------------*\n*---    THIS SUBROUTINE OF ARCHDELE IS A FAIRLY COMPLEX ROUTINE.   ---*\n*---    IT WILL PERFORM THE 'DELETE CURRENT LEVELS WITHOUT         ---*\n*---    ALIASES' FUNCTION.  THE ACTUAL STEPS INVOLVED ARE THESE:   ---*\n*---                                                               ---*\n*---    1.  LOCATE A NON-ALIAS HEADER RECORD OF AN ITEM TO BE      ---*\n*---        DELETED.  THE QUALIFIERS IN THE RECORD KEY MUST MATCH  ---*\n*---        THOSE SUPPLIED BY THE USER.                            ---*\n*---                                                               ---*\n*---    2.  IF ALIASES ARE PRESENT FOR THE ITEM, CONVERT THE       ---*\n*---        FIRST ALIAS TO A 'REAL' ITEM AND COPY THE ITEM TO IT.  ---*\n*---        THIS IS BASICALLY A REWRITE OF THE ITEM DATA WITH A    ---*\n*---        NEW KEY.                                               ---*\n*---                                                               ---*\n*---    3.  LOCATE ANY OTHER ALIASES FOR THE ITEM AND ALTER THEM   ---*\n*---        TO POINT TO THE NEWLY-COPIED ITEM.                     ---*\n*---                                                               ---*\n*---    4.  LOCATE ALL RECORDS FOR THE SELECTED (ORIGINAL-NAMED)   ---*\n*---        ITEM AND ERASE THEM, USING THE ARCHERAS SUBROUTINE.    ---*\n*---                                                               ---*\n*---    5.  POINT PAST ANY 'BACK LEVELS' OF THIS ITEM BY ADDING    ---*\n*---        A BINARY '1' TO THE LAST BYTE OF THE TYPE AND DO A     ---*\n*---        VSAM 'POINT'. (KGE LOGIC IN USE HERE)                  ---*\n*---                                                               ---*\n*---    6.  LOOP BACK TO STATEMENT 1 AND CONTINUE                  ---*\n*---                                                               ---*\n*---    NOTE THAT THIS ONLY DELETES A SINGLE ITEM AT A TIME. IF    ---*\n*---    ALIASES EXIST, PROCESSING IS SUCH THAT THE ITEM NAMED ON   ---*\n*---    THE DELETE CONTROL STATEMENT IS RENAMED AND REPLACES THE   ---*\n*---    FIRST ALIAS FOR THAT ITEM.                                 ---*\n*---------------------------------------------------------------------*\n         EJECT\nARCHDELC CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n@RPL1    EQU   R2                  SOME\n@RPL2    EQU   R3                    SPECIAL\n@RPL3    EQU   R4                      EQUATES\n@BUF1    EQU   R5                        FOR\n@BUF2    EQU   R6                          VSAM\n@BUF3    EQU   R7                            I/O MGMT\n         COPY #ARCBITS\n         USING ARCHDELC,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             DELC ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHDELC,R11        DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             DELC NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RESTORE BACK POINTER\n         L     R14,12(,R14)        RESTORE ORIG. REG 14\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         XC    FCOUNT,FCOUNT       CLEAR FUNCTION RECORD COUNT\n         XC    MCNT,MCNT           AND MEMBER COUNT\n         XC    ACNT,ACNT           AND ALIAS COUNT\n         MVC   VS1MODE,=CL8'OUTPUT' SET THE I/O MODE\n         LA    R1,VSAM1DD          LOAD THE PARM POINTER\n         LA    R0,0                AND THE 'OPEN' FLAG\n         CALL  ARCHVSOP            CALL THE 'OPEN' FUNCTION\n         LTR   R15,R15             OPEN OK ??\n         BNZ   ENDITALL            NOPE; CAN'T WORK\n         L     @RPL1,RPL1\n         L     @RPL2,RPL2\n         L     @RPL3,RPL3\n         L     @BUF1,VS1BUF1\n         L     @BUF2,VS1BUF2\n         L     @BUF3,VS1BUF3\n         BAL   R14,CLEAN           GO CLEAN UP ANY ORPHAN ALIASES\n         EJECT\n*---------------------------------------------------------------------*\n*---     HERE'S THE MEAT OF THE JOB. THESE ARE THE BASIC STEPS     ---*\n*---     INVOLVED.  DETAILS TO FOLLOW.                             ---*\n*---                                                               ---*\n*---     1. USING RPL1/VS1BUF1, LOCATE A HEADER RECORD THAT IS     ---*\n*---        NOT AN ALIAS RECORD.                                   ---*\n*---                                                               ---*\n*---     2. CALL ARCHKNAM TO DETERMINE WHETHER OR NOT THIS KEY     ---*\n*---        FITS THE CRITERIA SPECIFIED BY THE USER.               ---*\n*---                                                               ---*\n*---     4. LOOK FOR AN ALIAS FOR THIS ITEM. IF FOUND, DELETE THE  ---*\n*---        ALIAS AND USE THE ARCHALT ROUTINE TO COPY THE ITEM     ---*\n*---        INTO THE 'ALIAS' MEMBER.                               ---*\n*---                                                               ---*\n*---     5. CALL ARCHERAS TO ERASE THE ITEM WE'VE FOUND. THEN ADD  ---*\n*---        A BINARY '1' TO THE LAST BYTE OF THE 'TYPE'            ---*\n*---        QUALIFIER, TO POINT VSAM PAST ANY 'BACK LEVEL' COPIES  ---*\n*---        OF THIS ITEM AND GO BACK TO NEXTHDR AND CONTINUE       ---*\n*---------------------------------------------------------------------*\nMEMBERS  DS    0H\n         USING REC,@BUF1           BASE THE RECORD DSECT\n         XC    0(RECKLEN,@BUF1),0(@BUF1) START AT THE BEGINNING !!\n         MVI   RECTT,#RTHDR        SET TO HEADER TYPE\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               ARG=(@BUF1),                                            X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         POINT RPL=(@RPL1)         GET TO IT\n*---------------------------------------------------------------------*\n*---     1. USING RPL1/VS1BUF1, LOCATE A HEADER RECORD.            ---*\n*---------------------------------------------------------------------*\nNEXTHDR  DS    0H\n         GET   RPL=(@RPL1)         AND READ A HEADER RECORD\n         LTR   R15,R15             DID WE GET A RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\n         #IF   RSRALIAS,ON,NEXTHDR SKIP ALIAS RECORDS ---\n*---------------------------------------------------------------------*\n*---     2. CALL ARCHKNAM TO DETERMINE WHETHER OR NOT THIS KEY     ---*\n*---        FITS THE CRITERIA SPECIFIED BY THE USER.               ---*\n*---------------------------------------------------------------------*\nNEWHDR   DS    0H\n         LA    R1,RECN             POINT TO THE HEADER\n         LA    R0,0                USE DEFAULT QUALIFIER DATA\n         CALL  ARCHKNAM            GO CHECK: DO WE PROCESS THIS ITEM ??\n         LTR   R15,R15             PASS THE CHECK ??\n         BNZ   NEXTHDR             NOPE ---\n*---------------------------------------------------------------------*\n*---     ITEM TO BE DELETED HAS BEEN FOUND. START BY CHECKING FOR  ---*\n*---     AN ALIAS TO 'ALTER' IT TO.  ALSO SAVE ITS KEY IN BUF3.    ---*\n*---------------------------------------------------------------------*\n         #IF   RSRHALS,OFF,NOALIAS    NO ALIASES FOR THIS ITEM\n         XC    0(49,@BUF2),0(@BUF2)   START AT THE BEGINNING\n         POINT RPL=(@RPL2)\n         DROP  @BUF1\n         USING REC,@BUF2\nASRCH    DS    0H\n         GET   RPL=(@RPL2)         READ A RECORD\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   NOALIAS             NOPE; ALL DONE\n         #IF   RSRALIAS,OFF,ASRCH  SKIP NON-ALIAS HEADERS\n         CLC   RECN-REC(44,@BUF1),RECAN ALIAS FOR THIS ITEM ??\n         BNE   ASRCH               NOPE ---\n*---------------------------------------------------------------------*\n*---     ALIAS IS FOUND. DELETE THE ALIAS RECORD AND USE ARCHALT   ---*\n*---     TO 'REQUALIFY' THE ITEM TO BE DELETED.                    ---*\n*---------------------------------------------------------------------*\n         MODCB RPL=(@RPL2),        RESET RPL2 FOR UPDATE/INSERT        X\n               OPTCD=(DIR,FKS,KGE,SYN,UPD),                            X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         GET   RPL=(@RPL2)         RE-READ THE RECORD, FOR UPDATE\n         ERASE RPL=(@RPL2)\n         CALL  ARCHALT,(1(,@BUF1),1(,@BUF2)),MF=(E,CALLIST)\n         SPACE 3\n*---------------------------------------------------------------------*\n*---     POINT ALL ALIASES FOR THE OLD ITEM AT THE NEW ITEM       ----*\n*---     CREATED BY ARCHALT.                                      ----*\n*---------------------------------------------------------------------*\n         SPACE 3\n         PUSH  USING\n         USING REC,@BUF3           BASE THE RECORD DSECT\n         XC    0(RECKLEN,@BUF3),0(@BUF3) START AT THE BEGINNING !!\n         MVI   RECTT,#RTHDR        INITIAL RECORD TYPE\n         MODCB RPL=(@RPL3),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,UPD),                            X\n               ARG=(@BUF3),                                            X\n               AREA=(@BUF3),                                           X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         POINT RPL=(@RPL3)         GET TO IT\nAA1      DS    0H\n         GET   RPL=(@RPL3)         AND READ A HEADER RECORD\n         LTR   R15,R15             ANYTHING LEFT ??\n         BNZ   AA2                 NOPE; ALL DONE\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   AA2                 NOPE; ALL DONE ---\n         #IF   RSRALIAS,OFF,AA1    NOT AN ALIAS RECORD\n         CLC   RECAN(44),1(@BUF1)  ALTER THIS ONE ??\n         BNE   AA1                 NOPE ---\n         MVC   RECAN(44),1(@BUF2)  REPLACE ALIAS FIELDS\n         PUT   RPL=(@RPL3)         WRITE THE UPDATED RECORD\n         LTR   R15,R15             ANYTHING ??\n         BNZ   1(,R15)             NOPE; DIE HORRIBLY\n         B     AA1                 LOOP FOR MORE ---\nAA2      DS    0H\n         ENDREQ RPL=(@RPL3)\n         POP   USING\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\nNOALIAS  DS    0H\n*---------------------------------------------------------------------*\n*---     NOW WE'RE READY TO DELETE THE ITEM'S ORIGINAL RECORDS.    ---*\n*---     NOTE THAT IN OUR VARIOUS MEANDERINGS TO PRESERVE THE      ---*\n*---     ALIAS NAME AND RELATED DATA, WE'VE PRESERVED THE          ---*\n*---     ORIGINAL HEADER'S KEY IN BUF3. THIS MAKES THE ACTUAL      ---*\n*---     DELETION PROCESS MUCH EASIER.                             ---*\n*---------------------------------------------------------------------*\n         LA    R1,0(,@BUF1)        POINT TO THE DELETABLE ITEM'S KEY\n         CALL  ARCHERAS            GO ERASE THE ITEM\n         DROP  @BUF2\n         USING REC,@BUF1\n         #FORMAT RECTT,,DELMBR\n         #PUT  LINE                AND OUTPUT THE MESSAGE\n         L     R15,MCNT            LOAD THE MEMBER COUNT\n         LA    R15,1(,R15)\n         ST    R15,MCNT            SAVE UPDATED COUNT\n         LA    R1,0                CLEAR A WORK REGISTER\n         IC    R1,RECT+9           INSERT LAST BYTE OF TYPE\n         LA    R1,1(,R1)           ADD ONE\n         STC   R1,RECT+9           SAVE UPDATED VALUE\n         POINT RPL=(@RPL1)         POINT TO IT\n         B     NEXTHDR             AND CONTINUE ---\n         DROP  @BUF1               DISCARD RECORD DSECT\nENDITALL DS    0H\n         L     R0,MCNT             LOAD MEMBER COUNT\n         LTR   R0,R0               ZERO COUNT ??\n         BZ    END2                YES ---\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,MCMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\nEND2     DS    0H\n         CLC   ACB1,=F'0'          WAS ACB EVER OPENED ??\n         BE    NOACB               NOPE ---\n         LA    R1,VSAM1DD          POINT TO THE DDNAME\n         LA    R0,4                SET 'CLOSE' REQUEST\n         CALL  ARCHVSOP            CALL THE VSAM 'CLOSE' ROUTINE\nNOACB    DS    0H\n         XC    CHAIN,CHAIN         CLEAR THE CHAIN POINTER\n         L     R13,4(,R13)         LOAD BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ALWAYS RC = 0\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\nDELMBR   DC    AL1(DELMSGE-DELMSG)\nDELMSG   DC    C' DELETE REQUEST COMPLETE.'\nDELMSGE  EQU   *\nMCMSG    DC    CL133' '\n         ORG   MCMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    C' TOTAL ITEMS(S) PROCESSED.'\n         ORG\n         TITLE 'CLEAN UP THE ALIAS FLAGS, ETC.'\n*---------------------------------------------------------------------*\n*---     WE LOOP THROUGH THE HEADER RECORDS TWICE FOR THIS        ----*\n*---     PROCESS.  THE FIRST LOOP CONCENTRATES ON THE 'TRUE NAME' ----*\n*---     RECORDS, TURNING OFF THE FLAG BIT THAT INDICATES THE     ----*\n*---     PRESENCE OF ALIASES.  THE SECOND PASS LOCATES ALL THE    ----*\n*---     ALIAS RECORDS AND SETS THE 'ALIASES PRESENT' BIT ON IN   ----*\n*---     THE 'TRUE NAME' RECORD THEY REFER TO.  IF THE 'TRUE      ----*\n*---     NAME' IS NOT PRESENT, THE ALIAS RECORD IS DELETED.       ----*\n*---------------------------------------------------------------------*\nCLEAN    DS    0H\n         STM   R14,R12,IOSAVE      SAVE THE ENTRY REGISTERS\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,UPD),                            X\n               ACB=(*,ACB1),                                           X\n               ARG=(@BUF1),                                            X\n               AREA=(@BUF1),                                           X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         MODCB RPL=(@RPL2),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,UPD),                            X\n               ACB=(*,ACB1),                                           X\n               ARG=(@BUF2),                                            X\n               AREA=(@BUF2),                                           X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         MODCB RPL=(@RPL3),                                            X\n               OPTCD=(DIR,FKS,KEQ,SYN,UPD),                            X\n               ACB=(*,ACB1),                                           X\n               ARG=(@BUF1),                                            X\n               AREA=(@BUF1),                                           X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         USING REC,@BUF1           BASE THE RECORD DSECT\n         XC    0(RECKLEN,@BUF1),0(@BUF1) CLEAR THE KEY\n         POINT RPL=(@RPL1)         GET TO IT\nCL1      DS    0H\n         GET   RPL=(@RPL1)         GO READ A RECORD\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   CL2                 NOPE; ALL DONE ---\n         #IF   RSRALIAS,ON,CL1     DON'T TOUCH ALIASES, YET\n         #SET  RSRHALS,OFF         INDICATE NO ALIASES\n         PUT   RPL=(@RPL1)         AND OUTPUT THE RECORD\n         B     CL1                 AND LOOP FOR MORE\nCL2      DS    0H\n         XC    0(RECKLEN,@BUF1),0(@BUF1) RESET TO STARTING KEY\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(NUP),                                            X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\nCL3      DS    0H\n         MVI   RECSEQ#+3,1         INCREMENT THE KEY VALUE\n         POINT RPL=(@RPL1)         RESET TO DATASET START\n         GET   RPL=(@RPL1)         READ A RECORD\n         ENDREQ RPL=(@RPL1)\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   CL5                 NOPE; ALL DONE\n         #IF   RSRALIAS,OFF,CL3    NOT AN ALIAS ---\n         XC    0(RECKLEN,@BUF2),0(@BUF2) CLEAR THE KEY AREA\n         MVI   0(@BUF2),#RTHDR     SHOW A HEADER RECORD\n         MVC   1(44,@BUF2),RECAN   MOVE IN THE 'TRUE NAME'\n         MODCB RPL=(@RPL2),                                            X\n               OPTCD=(DIR,FKS,KEQ,SYN,UPD),                            X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         GET   RPL=(@RPL2)         AND FETCH THE RECORD (MAYBE)\n         LTR   R15,R15             WAS IT FOUND ??\n         BNZ   CL4                 NOPE; DELETE THE ALIAS RECORD\n         PUSH  USING\n         USING REC,@BUF2\n         #SET  RSRHALS,ON          SAY IT HAS ALIASES\n         POP   USING\n         PUT   RPL=(@RPL2)         UPDATE THE RECORD\n         B     CL3                 AND CONTINUE ---\nCL4      DS    0H\n         GET   RPL=(@RPL3)         RE-FETCH THE RECORD\n         ERASE RPL=(@RPL3)         DELETE IT\n         B     CL3                 AND CONTINUE ---\nCL5      DS    0H\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         MODCB RPL=(@RPL2),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         MODCB RPL=(@RPL3),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         LM    R14,R12,IOSAVE      RESTORE REGS\n         BR    R14                 AND RETURN TO LOCAL CALLER\n         DROP  @BUF1\n         LTORG\n         COPY  #RECS\n         COPY  ##ARCHWK\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHDELD": {"ttr": 3338, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00\\xe0\\x00\\xe0\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 224, "newlines": 224, "modlines": 0, "user": "ARCHIVR"}, "text": "DELD     TITLE 'ARCHIVER --- DELETE FUNCTION'\n*---------------------------------------------------------------------*\n*---    THIS SUBROUTINE OF ARCHDEL WILL DELETE THE 'CURRENT'       ---*\n*---    VERSION OF THE SELECTED ITEM(S), AND ALL ITS ALIASES,      ---*\n*---    FROM THE ARCHIVE CLUSTER.  BY 'CURRENT' VERSION, WE        ---*\n*---    MEAN THAT VERSION WITH THE HIGHEST VERSION NUMBER.         ---*\n*---------------------------------------------------------------------*\n         EJECT\nARCHDELD CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n@RPL1    EQU   R2                  SOME\n@RPL2    EQU   R3                    SPECIAL\n@RPL3    EQU   R4                      EQUATES\n@BUF1    EQU   R5                        FOR\n@BUF2    EQU   R6                          VSAM\n@BUF3    EQU   R7                            I/O MGMT\n         COPY #ARCBITS\n         USING ARCHDELD,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             DELD ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHDELD,R11        DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             DELD NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RESTORE BACK POINTER\n         L     R14,12(,R14)        RESTORE ORIG. REG 14\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         XC    FCOUNT,FCOUNT       CLEAR FUNCTION RECORD COUNT\n         XC    MCNT,MCNT           AND MEMBER COUNT\n         XC    ACNT,ACNT           AND ALIAS COUNT\n         MVC   VS1MODE,=CL8'OUTPUT' SET THE I/O MODE\n         LA    R1,VSAM1DD          LOAD THE PARM POINTER\n         LA    R0,0                AND THE 'OPEN' FLAG\n         CALL  ARCHVSOP            CALL THE 'OPEN' FUNCTION\n         LTR   R15,R15             OPEN OK ??\n         BNZ   ENDITALL            NOPE; CAN'T WORK\n         L     @RPL1,RPL1\n         L     @RPL2,RPL2\n         L     @RPL3,RPL3\n         L     @BUF1,VS1BUF1\n         L     @BUF2,VS1BUF2\n         L     @BUF3,VS1BUF3\n         EJECT\n*---------------------------------------------------------------------*\n*---     HERE'S THE MEAT OF THE JOB. THESE ARE THE BASIC STEPS     ---*\n*---     INVOLVED.  DETAILS TO FOLLOW.                             ---*\n*---                                                               ---*\n*---     1. USING RPL1/VS1BUF1, LOCATE A HEADER RECORD THAT IS     ---*\n*---        NOT AN ALIAS RECORD.                                   ---*\n*---                                                               ---*\n*---     2. CALL ARCHKNAM TO DETERMINE WHETHER OR NOT THIS KEY     ---*\n*---        FITS THE CRITERIA SPECIFIED BY THE USER.               ---*\n*---                                                               ---*\n*---     4. LOOK FOR AN ALIAS FOR THIS ITEM. IF FOUND, DELETE THE  ---*\n*---        ALIAS AND LOOK FOR ANOTHER ALIAS.                      ---*\n*---                                                               ---*\n*---     5. CALL ARCHERAS TO ERASE THE ITEM WE'VE FOUND. THEN ADD  ---*\n*---        A BINARY '1' TO THE LAST BYTE OF THE 'TYPE'            ---*\n*---        QUALIFIER, TO POINT VSAM PAST ANY 'BACK LEVEL' COPIES  ---*\n*---        OF THIS ITEM AND GO BACK TO NEXTHDR AND CONTINUE       ---*\n*---------------------------------------------------------------------*\nMEMBERS  DS    0H\n         USING REC,@BUF1           BASE THE RECORD DSECT\n         XC    0(RECKLEN,@BUF1),0(@BUF1) START AT THE BEGINNING !!\n         MVI   RECTT,#RTHDR        SET TO HEADER TYPE\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               ARG=(@BUF1),AREA=(@BUF1),AREALEN=(*,VS1LIM),            X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         POINT RPL=(@RPL1)         GET TO IT\n*---------------------------------------------------------------------*\n*---     1. USING RPL1/VS1BUF1, LOCATE A HEADER RECORD.            ---*\n*---------------------------------------------------------------------*\nNEXTHDR  DS    0H\n         GET   RPL=(@RPL1)         AND READ A HEADER RECORD\n         LTR   R15,R15             DID WE GET A RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\n         #IF   RSRALIAS,ON,NEXTHDR SKIP ALIAS RECORDS ---\n*---------------------------------------------------------------------*\n*---     2. CALL ARCHKNAM TO DETERMINE WHETHER OR NOT THIS KEY     ---*\n*---        FITS THE CRITERIA SPECIFIED BY THE USER.               ---*\n*---------------------------------------------------------------------*\nNEWHDR   DS    0H\n         LA    R1,RECN             POINT TO THE HEADER\n         LA    R0,0                USE DEFAULT QUALIFIER DATA\n         CALL  ARCHKNAM            GO CHECK: DO WE PROCESS THIS ITEM ??\n         LTR   R15,R15             PASS THE CHECK ??\n         BNZ   NEXTHDR             NOPE ---\n*---------------------------------------------------------------------*\n*---     ITEM TO BE DELETED HAS BEEN FOUND. START BY CHECKING FOR  ---*\n*---     AN ALIAS TO 'ALTER' IT TO.  ALSO SAVE ITS KEY IN BUF3.    ---*\n*---------------------------------------------------------------------*\n         #IF   RSRHALS,OFF,NOALIAS    NO ALIASES FOR THIS ITEM\n         SPACE 3\n*---------------------------------------------------------------------*\n*---     DELETE ALL THE ALIASES FOR THIS ITEM                      ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nDELA     DS    0H\n         DROP  @BUF1\n         USING REC,@BUF3\n         XC    0(RECKLEN,@BUF3),0(@BUF3) START AT THE BEGINNING !!\n         MVI   RECTT,#RTHDR        INITIAL RECORD TYPE\n         MODCB RPL=(@RPL3),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,UPD),                            X\n               AREA=(@BUF3),ARG=(@BUF3),                               X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         POINT RPL=(@RPL3)         GET TO IT\nDELB     DS    0H\n         GET   RPL=(@RPL3)         AND READ A HEADER RECORD\n         LTR   R15,R15             ANYTHING LEFT ??\n         BNZ   DELC                NOPE; ALL DONE\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   DELC                NOPE; ALL DONE ---\n         #IF   RSRALIAS,OFF,DELB   NOT AN ALIAS RECORD\n         CLC   RECAN(44),1(@BUF1)  DELETE IT ??\n         BNE   DELB                NOPE ---\n         ERASE RPL=(@RPL3)         ERASE THE RECORD\n         LTR   R15,R15             ERASE OK ??\n         BNZ   1(,R15)             NOPE; DIE HORRIBLY\n         #FORMAT RECTT,,DELALIAS\n         #PUT  LINE\n         L     R15,ACNT            LOAD THE ALIAS COUNT\n         LA    R15,1(,R15)         INCREMENT BY ONE\n         ST    R15,ACNT            STORE UPDATED COUNT\n         B     DELB                AND CONTINUE\nDELALIAS DC    AL1(DELASGE-DELASG)\nDELASG   DC    C' ALIAS IS DELETED.'\nDELASGE  EQU   *\nDELC     DS    0H\n         ENDREQ RPL=(@RPL3)\nNOALIAS  DS    0H\n*---------------------------------------------------------------------*\n*---     NOW WE'RE READY TO DELETE THE ITEM'S ORIGINAL RECORDS.    ---*\n*---------------------------------------------------------------------*\n         DROP  @BUF3\n         USING REC,@BUF1\n         LA    R1,0(,@BUF1)        POINT TO THE DELETABLE ITEM'S KEY\n         CALL  ARCHERAS            GO ERASE THE ITEM\n         #FORMAT RECTT,,DELMBR\n         #PUT  LINE                AND OUTPUT THE MESSAGE\n         L     R15,MCNT            LOAD THE MEMBER COUNT\n         LA    R15,1(,R15)\n         ST    R15,MCNT            SAVE UPDATED COUNT\n         LA    R1,0                CLEAR A WORK REGISTER\n         IC    R1,RECT+9           INSERT LAST BYTE OF TYPE\n         LA    R1,1(,R1)           ADD ONE\n         STC   R1,RECT+9           SAVE UPDATED VALUE\n         POINT RPL=(@RPL1)         POINT TO IT\n         DROP  @BUF1\n         B     NEXTHDR             AND CONTINUE ---\nENDITALL DS    0H\n         L     R0,MCNT             LOAD MEMBER COUNT\n         LTR   R0,R0               ZERO COUNT ??\n         BZ    END2                YES ---\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,MCMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\n         L     R0,ACNT             LOAD MEMBER COUNT\n         LTR   R0,R0               ZERO COUNT ??\n         BZ    END2                YES ---\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,ACMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\nEND2     DS    0H\n         CLC   ACB1,=F'0'          WAS ACB EVER OPENED ??\n         BE    NOACB               NOPE ---\n         LA    R1,VSAM1DD          POINT TO THE DDNAME\n         LA    R0,4                SET 'CLOSE' REQUEST\n         CALL  ARCHVSOP            CALL THE VSAM 'CLOSE' ROUTINE\nNOACB    DS    0H\n         XC    CHAIN,CHAIN         CLEAR THE CHAIN POINTER\n         L     R13,4(,R13)         LOAD BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ALWAYS RC = 0\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\nDELMBR   DC    AL1(DELMSGE-DELMSG)\nDELMSG   DC    C' DELETE REQUEST COMPLETE.'\nDELMSGE  EQU   *\nMCMSG    DC    CL133' '\n         ORG   MCMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    C' TOTAL ITEMS(S) PROCESSED.'\n         ORG\nACMSG    DC    CL133' '\n         ORG   ACMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    C' TOTAL ALIAS(ES) PROCESSED.'\n         ORG\n         LTORG\n         COPY  #RECS\n         COPY  ##ARCHWK\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHDELE": {"ttr": 3588, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x01\\x13\\x01\\x13\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 275, "newlines": 275, "modlines": 0, "user": "ARCHIVR"}, "text": "DELE     TITLE 'ARCHIVER --- DELETE FUNCTION'\n*---------------------------------------------------------------------*\n*---    THIS SUBROUTINE OF ARCHDEL WILL DELETE AN ITEM ONLY IF     ---*\n*---    IT CAN LOCATE AN ALIAS FOR THE ITEM.  THE ACTUAL ITEM      ---*\n*---    DATA IS 'ALTERED' SUCH THAT THE FIRST ALIAS BECOMES A      ---*\n*---    REAL ITEM AND THE SELECTED ITEM 'DISAPPEARS' FROM THE      ---*\n*---    ARCHIVE.  NO DATA IS ACTUALLY LOST; IT'S JUST 'HIDDEN'     ---*\n*---    UNDER A DIFFERENT SET OF KEYS.  IF NO ALIAS EXISTS, A      ---*\n*---    MESSAGE IS PRINTED AND NO ACTION IS TAKEN.                 ---*\n*---------------------------------------------------------------------*\n         EJECT\nARCHDELE CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n@RPL1    EQU   R2                  SOME\n@RPL2    EQU   R3                    SPECIAL\n@RPL3    EQU   R4                      EQUATES\n@BUF1    EQU   R5                        FOR\n@BUF2    EQU   R6                          VSAM\n@BUF3    EQU   R7                            I/O MGMT\n         COPY #ARCBITS\n         USING ARCHDELE,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             DELE ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHDELE,R11        DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             DELE NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RESTORE BACK POINTER\n         L     R14,12(,R14)        RESTORE ORIG. REG 14\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         XC    FCOUNT,FCOUNT       CLEAR FUNCTION RECORD COUNT\n         XC    MCNT,MCNT           AND MEMBER COUNT\n         XC    ACNT,ACNT           AND ALIAS COUNT\n         MVC   VS1MODE,=CL8'OUTPUT' SET THE I/O MODE\n         LA    R1,VSAM1DD          LOAD THE PARM POINTER\n         LA    R0,0                AND THE 'OPEN' FLAG\n         CALL  ARCHVSOP            CALL THE 'OPEN' FUNCTION\n         LTR   R15,R15             OPEN OK ??\n         BNZ   ENDITALL            NOPE; CAN'T WORK\n         L     @RPL1,RPL1\n         L     @RPL2,RPL2\n         L     @RPL3,RPL3\n         L     @BUF1,VS1BUF1\n         L     @BUF2,VS1BUF2\n         L     @BUF3,VS1BUF3\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               ACB=(*,ACB1),                                           X\n               ARG=(@BUF1),                                            X\n               AREA=(@BUF1),                                           X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         MODCB RPL=(@RPL2),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               ACB=(*,ACB1),                                           X\n               ARG=(@BUF2),                                            X\n               AREA=(@BUF2),                                           X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         EJECT\n*---------------------------------------------------------------------*\n*---     HERE'S THE MEAT OF THE JOB. THESE ARE THE BASIC STEPS     ---*\n*---     INVOLVED.  DETAILS TO FOLLOW.                             ---*\n*---                                                               ---*\n*---     1. USING RPL1/VS1BUF1, LOCATE A HEADER RECORD THAT IS     ---*\n*---        NOT AN ALIAS RECORD.                                   ---*\n*---                                                               ---*\n*---     2. CALL ARCHKNAM TO DETERMINE WHETHER OR NOT THIS KEY     ---*\n*---        FITS THE CRITERIA SPECIFIED BY THE USER.               ---*\n*---                                                               ---*\n*---     3. SAVE THE KEY, INCLUDING THE SEQUENCE NUMBER TO THE     ---*\n*---        VALUE IN BLDLAREA. DECREMENT THE VERSION NUMBER BY     ---*\n*---        ONE AND SEARCH FOR A HEADER THAT MATCHES FOR THE       ---*\n*---        LENGTH SPECIFIED BY 'RECPKEY'. THIS IS A BACK LEVEL    ---*\n*---        AND SHOULD BE DELETED.                                 ---*\n*---                                                               ---*\n*---     4. LOOK FOR AN ALIAS FOR THIS 'BACK-LEVEL' ITEM. IF FOUND,---*\n*---        DELETE THE ALIAS AND COPY THE ITEM, RENAMING TO THE    ---*\n*---        KEY VALUES FROM THE ALIAS.  IF NO ALIAS IS FOUND,      ---*\n*---        LOCATE THE NEXT 'BACK LEVEL' COPY OF THIS ITEM AND     ---*\n*---        TRY AGAIN.                                             ---*\n*---                                                               ---*\n*---     5. CALL ARCHERAS TO ERASE THE 'BACK-LEVEL' ITEM WE'VE     ---*\n*---        FOUND, THEN GO BACK AND CHECK FOR ANOTHER              ---*\n*---        'BACK-LEVEL' COPY OF THIS ITEM.  REPEAT STEPS 4 AND 5  ---*\n*---        UNTIL NO FURTHER 'BACK-LEVEL' COPIES OF THIS ITEM ARE  ---*\n*---        FOUND.                                                 ---*\n*---------------------------------------------------------------------*\nMEMBERS  DS    0H\n         USING REC,@BUF1           BASE THE RECORD DSECT\n         XC    0(RECKLEN,@BUF1),0(@BUF1) START AT THE BEGINNING !!\n         MVI   RECTT,#RTHDR        SET TO HEADER TYPE\n         POINT RPL=(@RPL1)         GET TO IT\n*---------------------------------------------------------------------*\n*---     1. USING RPL1/VS1BUF1, LOCATE A HEADER RECORD.            ---*\n*---------------------------------------------------------------------*\nNEXTHDR  DS    0H\n         GET   RPL=(@RPL1)         AND READ A HEADER RECORD\n         LTR   R15,R15             DID WE GET A RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\n         #IF   RSRALIAS,ON,NEXTHDR SKIP ALIAS RECORDS ---\n*---------------------------------------------------------------------*\n*---     2. CALL ARCHKNAM TO DETERMINE WHETHER OR NOT THIS KEY     ---*\n*---        FITS THE CRITERIA SPECIFIED BY THE USER.               ---*\n*---------------------------------------------------------------------*\nNEWHDR   DS    0H\n         LA    R1,RECN             POINT TO THE HEADER\n         LA    R0,0                USE DEFAULT QUALIFIER DATA\n         CALL  ARCHKNAM            GO CHECK: DO WE PROCESS THIS ITEM ??\n         LTR   R15,R15             PASS THE CHECK ??\n         BNZ   NEXTHDR             NOPE ---\n*---------------------------------------------------------------------*\n*---     3. SAVE THE KEY, INCLUDING THE SEQUENCE NUMBER TO THE     ---*\n*---        VALUE IN BLDLAREA. READ THE NEXT HEADER AND CHECK FOR  ---*\n*---        A MATCHING KEY, UP TO BUT NOT INCLUDING THE VERSION    ---*\n*---        NUMBER. IGNORE ALIAS RECORDS.                          ---*\n*---------------------------------------------------------------------*\n         MVC   BLDLAREA(RECKLEN),RECTT SAVE THAT KEY ---\nDELA     DS    0H\n         GET   RPL=(@RPL1)         READ ANOTHER HEADER\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE\n         #IF   RSRALIAS,ON,DELA    SKIP ALIAS RECORDS ---\n         CLC   RECTT(RECPKEY),BLDLAREA SAME ITEM DIF. VERSION ??\n         BNE   NEWHDR              NOPE ---\n*---------------------------------------------------------------------*\n*---     ITEM TO BE DELETED HAS BEEN FOUND. START BY CHECKING FOR  ---*\n*---     AN ALIAS TO 'ALTER' IT TO.  ALSO SAVE ITS KEY IN BUF3.    ---*\n*---------------------------------------------------------------------*\n         MVC   0(49,@BUF3),0(@BUF1)   SAVE ITEM KEY\n         #IF   RSRHALS,OFF,NOALIAS    NO ALIASES FOR THIS ITEM\n         XC    0(49,@BUF2),0(@BUF2)   START AT THE BEGINNING\n         POINT RPL=(@RPL2)\n         DROP  @BUF1\n         USING REC,@BUF2\nASRCH    DS    0H\n         GET   RPL=(@RPL2)         READ A RECORD\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   DELA                NOPE; NO ALIAS FOR THIS ITEM\n         #IF   RSRALIAS,OFF,ASRCH  SKIP NON-ALIAS HEADERS\n         CLC   RECN-REC(44,@BUF1),RECAN ALIAS FOR THIS ITEM ??\n         BNE   ASRCH               NOPE ---\n*---------------------------------------------------------------------*\n*---     WE FOUND AN ALIAS. NOW DELETE THE ALIAS RECORD AND ALTER  ---*\n*---     THE ITEM WE ARE DELETING SUCH THE THE ALIAS IS REPLACED   ---*\n*---     BY THE ITEM.                                              ---*\n*---------------------------------------------------------------------*\n         MODCB RPL=(@RPL2),        RESET RPL2 FOR UPDATE/INSERT        X\n               OPTCD=(DIR,FKS,KGE,SYN,UPD),                            X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         GET   RPL=(@RPL2)         RE-READ THE RECORD, FOR UPDATE\n         ERASE RPL=(@RPL2)\n         ENDREQ RPL=(@RPL2)\n         MODCB RPL=(@RPL2),        RESET RPL2 FOR UPDATE/INSERT        X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         CALL  ARCHALT,(1(,@BUF1),1(,@BUF2)),MF=(E,CALLIST)\n*---------------------------------------------------------------------*\n*---     POINT ALL ALIASES FOR THE OLD ITEM AT THE NEW ITEM       ----*\n*---     CREATED BY ARCHALT.                                      ----*\n*---------------------------------------------------------------------*\n         PUSH  USING\n         USING REC,@BUF3           BASE THE RECORD DSECT\n         XC    0(RECKLEN,@BUF3),0(@BUF3) START AT THE BEGINNING !!\n         MVI   RECTT,#RTHDR        INITIAL RECORD TYPE\n         MODCB RPL=(@RPL3),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,UPD),                            X\n               ARG=(@BUF3),                                            X\n               AREA=(@BUF3),                                           X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         POINT RPL=(@RPL3)         GET TO IT\nAA1      DS    0H\n         GET   RPL=(@RPL3)         AND READ A HEADER RECORD\n         LTR   R15,R15             ANYTHING LEFT ??\n         BNZ   AA2                 NOPE; ALL DONE\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   AA2                 NOPE; ALL DONE ---\n         #IF   RSRALIAS,OFF,AA1    NOT AN ALIAS RECORD\n         CLC   RECAN(44),1(@BUF1)  ALTER THIS ONE ??\n         BNE   AA1                 NOPE ---\n         MVC   RECAN(44),1(@BUF2)  REPLACE ALIAS FIELDS\n         PUT   RPL=(@RPL3)         WRITE THE UPDATED RECORD\n         LTR   R15,R15             ANYTHING ??\n         BNZ   1(,R15)             NOPE; DIE HORRIBLY\n         B     AA1                 LOOP FOR MORE ---\nAA2      DS    0H\n         ENDREQ RPL=(@RPL3)\n         POP   USING\n*---------------------------------------------------------------------*\n*---     NOW WE'RE READY TO DELETE THE ITEM'S ORIGINAL RECORDS.    ---*\n*---     USE THE ARCHERAS ROUTINE TO DO THE ACTUAL DELETE.         ---*\n*---------------------------------------------------------------------*\n         LA    R1,0(,@BUF1)        POINT TO THE DELETABLE ITEM'S KEY\n         CALL  ARCHERAS            GO ERASE THE ITEM\n         #FORMAT 0(@BUF1),,DELMBR\n         #PUT  LINE                AND OUTPUT THE MESSAGE\n         #FORMAT RECTT,,DELMOV,OUT=LINE+10\n         #PUT  LINE                AND OUTPUT THE MESSAGE\n         L     R15,MCNT            LOAD THE MEMBER COUNT\n         LA    R15,1(,R15)\n         ST    R15,MCNT            SAVE UPDATED COUNT\n         B     DELA                AND TRY FOR ANOTHER ITEM\n         DROP  @BUF2               DISCARD RECORD DSECT\nNOALIAS  DS    0H\n         USING REC,@BUF1           RE-BASE THE DSECT\n         #FORMAT RECTT,,NODEL1\n         #PUT  LINE                OUTPUT THAT MESSAGE\n         #PUT  NODEL2              AND THE REASON\n         B     DELA                AND CONTINUE SEARCHING\n         DROP  @BUF1\nENDITALL DS    0H\n         L     R0,MCNT             LOAD MEMBER COUNT\n         LTR   R0,R0               ZERO COUNT ??\n         BZ    END2                YES ---\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,MCMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\nEND2     DS    0H\n         CLC   ACB1,=F'0'          WAS ACB EVER OPENED ??\n         BE    NOACB               NOPE ---\n         LA    R1,VSAM1DD          POINT TO THE DDNAME\n         LA    R0,4                SET 'CLOSE' REQUEST\n         CALL  ARCHVSOP            CALL THE VSAM 'CLOSE' ROUTINE\nNOACB    DS    0H\n         XC    CHAIN,CHAIN         CLEAR THE CHAIN POINTER\n         L     R13,4(,R13)         LOAD BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ALWAYS RC = 0\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\nNODEL1   DC    AL1(NODEL1B-NODEL1A)\nNODEL1A  DC    C' NOT DELETED.'\nNODEL1B  EQU   *\nNODEL2   DC    CL133'     NO ALIAS EXISTS FOR CONVERSION.'\nDELMBR   DC    AL1(DELMSGE-DELMSG)\nDELMSG   DC    C' DELETE REQUEST COMPLETE.'\nDELMSGE  EQU   *\nDELMOV   DC    AL1(DELMOVE-DELMOVM)\nDELMOVM  DC    C' NOW CONTAINS THE COMPLETE ITEM.'\nDELMOVE  EQU   *\nMCMSG    DC    CL133' '\n         ORG   MCMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    C' TOTAL ITEMS(S) PROCESSED.'\n         ORG\n         LTORG\n         COPY  #RECS\n         COPY  ##ARCHWK\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHDELF": {"ttr": 3593, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00\\xf2\\x00\\xf2\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 242, "newlines": 242, "modlines": 0, "user": "ARCHIVR"}, "text": "DELF     TITLE 'ARCHIVER --- DELETE FUNCTION'\n*---------------------------------------------------------------------*\n*---    THIS SUBROUTINE OF ARCHDELE IS A FAIRLY COMPLEX ROUTINE.   ---*\n*---    IT WILL PERFORM THE 'DELETE BACK LEVELS AND ITS ALIASES'   ---*\n*---    FUNCTION.  THE ACTUAL STEPS INVOLVED ARE THESE:            ---*\n*---                                                               ---*\n*---    1.  LOCATE A NON-ALIAS HEADER RECORD OF AN ITEM TO BE      ---*\n*---        DELETED.  THE QUALIFIERS IN THE RECORD KEY MUST MATCH  ---*\n*---        THOSE SUPPLIED BY THE USER AND THE VERSION NUMBER      ---*\n*---        MUST BE LOWER THAT A PREVIOUSLY-ENCOUNTERED ITEM OF    ---*\n*---        THE SAME MEMBER, GROUP, SUBGROUP AND TYPE VALUES.      ---*\n*---        (WHAT A MOUTHFUL!)                                     ---*\n*---                                                               ---*\n*---    2.  LOCATE AND DELETE ALL ALIASES FOR THE ITEM TO BE       ---*\n*---        DELETED.                                               ---*\n*---                                                               ---*\n*---    3.  LOCATE ALL RECORDS FOR THE SELECTED (ORIGINAL-NAMED)   ---*\n*---        ITEM AND ERASE THEM.                                   ---*\n*---                                                               ---*\n*---    4.  LOOP BACK TO STATEMENT 1 AND CONTINUE                  ---*\n*---                                                               ---*\n*---    NOTE THAT THIS DELETE AN ITEM AND ALL REFERENCES TO THAT   ---*\n*---    ITEM. FROM THIS FORM OF DELETE, THERE IS NO RECOVERY.      ---*\n*---------------------------------------------------------------------*\n         EJECT\nARCHDELF CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n@RPL1    EQU   R2                  SOME\n@RPL2    EQU   R3                    SPECIAL\n@RPL3    EQU   R4                      EQUATES\n@BUF1    EQU   R5                        FOR\n@BUF2    EQU   R6                          VSAM\n@BUF3    EQU   R7                            I/O MGMT\n         COPY #ARCBITS\n         USING ARCHDELF,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             DELF ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHDELF,R11        DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             DELF NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RESTORE BACK POINTER\n         L     R14,12(,R14)        RESTORE ORIG. REG 14\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         XC    FCOUNT,FCOUNT       CLEAR FUNCTION RECORD COUNT\n         XC    MCNT,MCNT           AND MEMBER COUNT\n         XC    ACNT,ACNT           AND ALIAS COUNT\n         MVC   VS1MODE,=CL8'OUTPUT' SET THE I/O MODE\n         LA    R1,VSAM1DD          LOAD THE PARM POINTER\n         LA    R0,0                AND THE 'OPEN' FLAG\n         CALL  ARCHVSOP            CALL THE 'OPEN' FUNCTION\n         LTR   R15,R15             OPEN OK ??\n         BNZ   ENDITALL            NOPE; CAN'T WORK\n         L     @RPL1,RPL1\n         L     @RPL2,RPL2\n         L     @RPL3,RPL3\n         L     @BUF1,VS1BUF1\n         L     @BUF2,VS1BUF2\n         L     @BUF3,VS1BUF3\n*        BAL   R14,CLEAN           GO CLEAN UP ANY ORPHAN ALIASES\n         EJECT\n*---------------------------------------------------------------------*\n*---     HERE'S THE MEAT OF THE JOB. THESE ARE THE BASIC STEPS     ---*\n*---     INVOLVED.  DETAILS TO FOLLOW.                             ---*\n*---                                                               ---*\n*---     1. USING RPL1/VS1BUF1, LOCATE A HEADER RECORD THAT IS     ---*\n*---        NOT AN ALIAS RECORD.                                   ---*\n*---                                                               ---*\n*---     2. CALL ARCHKNAM TO DETERMINE WHETHER OR NOT THIS KEY     ---*\n*---        FITS THE CRITERIA SPECIFIED BY THE USER.               ---*\n*---                                                               ---*\n*---     3. SAVE THE KEY, INCLUDING THE SEQUENCE NUMBER TO THE     ---*\n*---        VALUE IN BLDLAREA. DECREMENT THE VERSION NUMBER BY     ---*\n*---        ONE AND SEARCH FOR A HEADER THAT MATCHES FOR THE       ---*\n*---        LENGTH SPECIFIED BY 'RECPKEY'. THIS IS A BACK LEVEL    ---*\n*---        AND SHOULD BE DELETED.                                 ---*\n*---                                                               ---*\n*---     4. LOOK FOR AN ALIAS FOR THIS 'BACK-LEVEL' ITEM. IF FOUND,---*\n*---        DELETE THE ALIAS AND AND LOOK FOR ANOTHER.             ---*\n*---                                                               ---*\n*---     5. DELETE THE BACK-LEVEL ITEM.  REPEAT STEPS 4 AND 5      ---*\n*---        UNTIL NO FURTHER 'BACK-LEVEL' COPIES OF THIS ITEM ARE  ---*\n*---        FOUND.                                                 ---*\n*---------------------------------------------------------------------*\nMEMBERS  DS    0H\n         USING REC,@BUF1           BASE THE RECORD DSECT\n         XC    0(RECKLEN,@BUF1),0(@BUF1) START AT THE BEGINNING !!\n         MVI   RECTT,#RTHDR        SET TO HEADER TYPE\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               ARG=(@BUF1),                                            X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         POINT RPL=(@RPL1)         GET TO IT\n*---------------------------------------------------------------------*\n*---     1. USING RPL1/VS1BUF1, LOCATE A HEADER RECORD.            ---*\n*---------------------------------------------------------------------*\nNEXTHDR  DS    0H\n         GET   RPL=(@RPL1)         AND READ A HEADER RECORD\n         LTR   R15,R15             DID WE GET A RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\n         #IF   RSRALIAS,ON,NEXTHDR SKIP ALIAS RECORDS ---\n*---------------------------------------------------------------------*\n*---     2. CALL ARCHKNAM TO DETERMINE WHETHER OR NOT THIS KEY     ---*\n*---        FITS THE CRITERIA SPECIFIED BY THE USER.               ---*\n*---------------------------------------------------------------------*\nNEWHDR   DS    0H\n         LA    R1,RECN             POINT TO THE HEADER\n         LA    R0,0                USE DEFAULT QUALIFIER DATA\n         CALL  ARCHKNAM            GO CHECK: DO WE PROCESS THIS ITEM ??\n         LTR   R15,R15             PASS THE CHECK ??\n         BNZ   NEXTHDR             NOPE ---\n*---------------------------------------------------------------------*\n*---     3. SAVE THE KEY, INCLUDING THE SEQUENCE NUMBER TO THE     ---*\n*---        VALUE IN BLDLAREA. READ THE NEXT HEADER AND CHECK FOR  ---*\n*---        A MATCHING KEY, UP TO BUT NOT INCLUDING THE VERSION    ---*\n*---        NUMBER. IGNORE ALIAS RECORDS.                          ---*\n*---------------------------------------------------------------------*\n         MVC   BLDLAREA(RECKLEN),RECTT SAVE THAT KEY ---\nDELA     DS    0H\n         GET   RPL=(@RPL1)         READ ANOTHER HEADER\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE\n         #IF   RSRALIAS,ON,DELA    SKIP ALIAS RECORDS ---\n         CLC   RECTT(RECPKEY),BLDLAREA SAME ITEM DIF. VERSION ??\n         BNE   NEWHDR              NOPE ---\n         ENDREQ RPL=(@RPL1)\n*---------------------------------------------------------------------*\n*---     ITEM TO BE DELETED HAS BEEN FOUND. START BY LOCATING AND  ---*\n*---     DELETING ANY ALIASES THAT REFER TO IT.                    ---*\n*---------------------------------------------------------------------*\n         #IF   RSRHALS,OFF,NOALIAS NO ALIASES FOR THIS ITEM\n         XC    0(49,@BUF2),0(@BUF2) START AT THE BEGINNING\n         MODCB RPL=(@RPL2),OPTCD=(UPD,KGE),MF=(G,GENWK),AREA=(@BUF2)\n         POINT RPL=(@RPL2)\n         PUSH  USING\n         USING REC,@BUF2\nASRCH    DS    0H\n         GET   RPL=(@RPL2)         READ A RECORD\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ADELDN              NOPE; ALL DONE\n         #IF   RSRALIAS,OFF,ASRCH  SKIP NON-ALIAS HEADERS\n         CLC   RECAN(44),RECN-REC(@BUF1) ALIAS FOR THIS ITEM ??\n         BNE   ASRCH               NOPE ---\n         ERASE RPL=(@RPL2)         DELETE THE ALIAS RECORD\n         #FORMAT RECTT,,DELALIAS\n         #PUT  LINE\n         L     R15,ACNT            LOAD THE MEMBER COUNT\n         LA    R15,1(,R15)\n         ST    R15,ACNT            SAVE UPDATED COUNT\n         B     ASRCH               AND LOOK FOR ANOTHER\nADELDN   DS    0H\n         ENDREQ RPL=(@RPL2)        FINISH THE WRITES, ETC.\nNOALIAS  DS    0H\n         POP   USING\n*---------------------------------------------------------------------*\n*---     NOW WE'RE READY TO DELETE THE ITEM'S ORIGINAL RECORDS.    ---*\n*---------------------------------------------------------------------*\n         LA    R1,RECTT            POINT TO THE KEY\n         CALL  ARCHERAS            GO DELETE THE ITEM\n         #FORMAT RECTT,,DELMBR\n         #PUT  LINE                AND OUTPUT THE MESSAGE\n         L     R15,MCNT            LOAD THE MEMBER COUNT\n         LA    R15,1(,R15)\n         ST    R15,MCNT            SAVE UPDATED COUNT\n         POINT RPL=(@RPL1)         RESET MY POSITIONING\n         B     DELA                AND TRY FOR ANOTHER ITEM\nENDITALL DS    0H\n         L     R0,MCNT             LOAD MEMBER COUNT\n         LTR   R0,R0               ZERO COUNT ??\n         BZ    END2                YES ---\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,MCMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\n         L     R0,ACNT             LOAD MEMBER COUNT\n         LTR   R0,R0               ZERO COUNT ??\n         BZ    END2                YES ---\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,ACMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\nEND2     DS    0H\n         CLC   ACB1,=F'0'          WAS ACB EVER OPENED ??\n         BE    NOACB               NOPE ---\n         LA    R1,VSAM1DD          POINT TO THE DDNAME\n         LA    R0,4                SET 'CLOSE' REQUEST\n         CALL  ARCHVSOP            CALL THE VSAM 'CLOSE' ROUTINE\nNOACB    DS    0H\n         XC    CHAIN,CHAIN         CLEAR THE CHAIN POINTER\n         L     R13,4(,R13)         LOAD BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ALWAYS RC = 0\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\nDELMBR   DC    AL1(DELMSGE-DELMSG)\nDELMSG   DC    C' DELETE REQUEST COMPLETE.'\nDELMSGE  EQU   *\nDELALIAS DC    AL1(LVL1SGE-LVL1SG)\nLVL1SG   DC    C' ALIAS OF DELETABLE BACK-LEVEL ITEM DELETED.'\nLVL1SGE  EQU   *\nMCMSG    DC    CL133' '\n         ORG   MCMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    C' TOTAL ITEM(S) PROCESSED.'\n         ORG\nACMSG    DC    CL133' '\n         ORG   ACMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    C' TOTAL ALIAS(ES) PROCESSED.'\n         ORG\n         LTORG\n         COPY  #RECS\n         COPY  ##ARCHWK\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHDEL1": {"ttr": 3841, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00\\x8f\\x00\\x8f\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 143, "newlines": 143, "modlines": 0, "user": "ARCHIVR"}, "text": "DEL1     TITLE 'ARCHIVER --- ALIAS DELETE FUNCTION  '\n*---------------------------------------------------------------------*\n*---     THIS SUBROUTINE OF THE DELETE FUNCTION DELETES ALL THE    ---*\n*---          ALIASES FOR A PARTICULAR ITEM IN THE VSAM1 ARCHIVE   ---*\n*---          CLUSTER.  IT IS THEREFORE FUNCTIONALLY EQUIVALENT    ---*\n*---          TO A DELALIAS FUNCTION.                              ---*\n*---------------------------------------------------------------------*\nARCHDEL1 CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n@RPL1    EQU   R2                  SOME\n@RPL2    EQU   R3                    SPECIAL\n@RPL3    EQU   R4                      EQUATES\n@BUF1    EQU   R5                        FOR\n@BUF2    EQU   R6                          VSAM\n@BUF3    EQU   R7                            I/O MGMT\n         COPY #ARCBITS\n         USING ARCHDEL1,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             ALIS ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHDEL1,R11        DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             ALIS NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RECOPY BACK POINTER\n         L     R14,12(,R14)        RECOPY ORIG. REG 14\n         LA    R10,0(,R11)         COPY ORIGINAL BASE REGISTER\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         MVC   VS1MODE,=CL8'OUTPUT' SET THE I/O MODE\n         LA    R1,VSAM1DD          LOAD THE PARM POINTER\n         LA    R0,0                AND THE 'OPEN' FLAG\n         CALL  ARCHVSOP            CALL THE 'OPEN' FUNCTION\n         LTR   R15,R15             OPEN OK ??\n         BNZ   ENDITALL            NOPE; CAN'T WORK\n*---------------------------------------------------------------------*\n*---     DELETE ALL THE ALIASES FOR A SPECIFIC ITEM, OR GROUP OF   ---*\n*---     ITEMS.  WE ARE BOUND TO A MECHANISM WHICH MAKES UP IN     ---*\n*---     BRUTE FORCE WHAT IT LACKS IN ELEGANCE.  SEARCH THROUGH    ---*\n*---     ALL THE HEADER RECORDS FOR ANY ALIASES THAT REFER TO THE  ---*\n*---     SELECTED ITEM(S) AND DELETE THEM ALL.                     ---*\n*---------------------------------------------------------------------*\n         SPACE 3\n         L     @RPL3,RPL3          LOAD RPL POINTER REG.\n         L     @BUF3,VS1BUF3       POINT TO THE VSAM BUFFER\n         USING REC,@BUF3           BASE THE RECORD DSECT\n         XC    0(RECKLEN,@BUF3),0(@BUF3) START AT THE BEGINNING !!\n         MVI   RECTT,#RTHDR        INITIAL RECORD TYPE\n         MODCB RPL=(@RPL3),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,UPD),                            X\n               ACB=(*,ACB1),                                           X\n               ARG=(@BUF3),                                            X\n               AREA=(@BUF3),                                           X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         POINT RPL=(@RPL3)         GET TO IT\nDA2      DS    0H\n         GET   RPL=(@RPL3)         AND READ A HEADER RECORD\n         LTR   R15,R15             ANYTHING LEFT ??\n         BNZ   ENDITALL            NOPE; ALL DONE\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\n         #IF   RSRALIAS,OFF,DA3    NOT AN ALIAS RECORD\n         LA    R1,RECAN            POINT TO THE 'REAL' NAME\n         LA    R0,0                USE DEFAULT QUALIFIER DATA\n         CALL  ARCHKNAM            DELETE IT ??\n         LTR   R15,R15             PASS THE CHECK ??\n         BNZ   DA2                 NOPE ---\n         ERASE RPL=(@RPL3)         ERASE THE RECORD\n         LTR   R15,R15             ERASE OK ??\n         BNZ   1(,R15)             NOPE; DIE HORRIBLY\n         L     R15,MCNT            LOAD THE ITEM COUNTER\n         LA    R15,1(,R15)         INCREMENT BY ONE\n         ST    R15,MCNT            AND SAVE UPDATED COUNT\n         #FORMAT RECTT,,DELD       OUTPUT THE 'ALIAS DELETED' MESSAGE\n         #PUT  LINE\n         B     DA2                 YES; CONTINUE\nDA3      DS    0H\n         #IF   RSRHALS,OFF,DA2     ANY ALIASES KNOWN ??\n         LA    R1,RECN             POINT TO THE KEY\n         LA    R0,0                USE DEFAULT QUALIFIER DATA\n         CALL  ARCHKNAM            IS THIS ONE WE SELECTED ??\n         LTR   R15,R15             CHECK R.C.\n         BNZ   DA2                 NOPE ---\n         #SET  RSRHALS,OFF         NO ALIASES NOW !!\n         PUT   RPL=(@RPL3)         UPDATE THE RECORD\n         B     DA2                 AND CONTINUE ---\n         DROP  @BUF3\n         TITLE 'TERMINATION LINKAGE, ETC. '\n*---------------------------------------------------------------------*\n*---     WRAP UP, CLOSE THE VSAM FILES, FREE THE STORAGE AND       ---*\n*---           RETURN TO ARCHMAIN FOR ANOTHER FUNCTION.            ---*\n*---------------------------------------------------------------------*\nENDITALL DS    0H\n         LA    R1,VSAM1DD          POINT TO THE DDNAME\n         LA    R0,4                SET 'CLOSE' REQUEST\n         CALL  ARCHVSOP            CALL THE VSAM 'CLOSE' ROUTINE\n         #PUT  ERR12\n         L     R0,MCNT             COPY MEMBER COUNT\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,MCMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\n         L     R13,4(,R13)         COPY BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ALWAYS RC = 0\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\n         LTORG\n* ERROR MESSAGES, ETC.\nERR12    DC    CL133'0         ALIAS DELETIONS COMPLETED.  TOTALS FOLLOX\n               W: '\nMCMSG    DC    CL133' '\n         ORG   MCMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202120'\n         DC    C' ALIAS(ES) DELETED. '\n         ORG\nDELD     DC    AL1(L'DELD1)\nDELD1    DC    CL30' ALIAS IS DELETED.'\n         LTORG\n         COPY  #RECS\n         COPY  ##ARCHWK\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHDEL2": {"ttr": 3845, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x01\\t\\x01\\t\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 265, "newlines": 265, "modlines": 0, "user": "ARCHIVR"}, "text": "DEL2     TITLE 'ARCHIVER --- DELETE FUNCTION'\n*---------------------------------------------------------------------*\n*---     THIS SUBROUTINE OF ARCHDEL WILL DELETE 'BACK LEVEL'       ---*\n*---     ITEMS IF ALIASES EXIST.  WHAT IT ACTUALLY DOES IS TO      ---*\n*---     'HIDE' THE ITEM TO BE DELETED BEHIND ITS FIRST ALIAS      ---*\n*---     THEN DELETE THE SELECTED BACK-LEVEL ITEM.  THE NET        ---*\n*---     RESULT IS THAT ONLY THE ITEM KEY DISAPPEARS FROM THE      ---*\n*---     INDEX LISTING.  THE DATA AND NOTES ARE STILL PRESENT BUT  ---*\n*---     ARE UNDER A DIFFERENT SET OF QUALIFIERS. IF NO ALIASES    ---*\n*---     EXIST FOR THE SELECTED ITEM, A MESSAGE IS PRODUCED AND    ---*\n*---     NO ACTION IS TAKEN.                                       ---*\n*---------------------------------------------------------------------*\n         EJECT\nARCHDEL2 CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n@RPL1    EQU   R2                  SOME\n@RPL2    EQU   R3                    SPECIAL\n@RPL3    EQU   R4                      EQUATES\n@BUF1    EQU   R5                        FOR\n@BUF2    EQU   R6                          VSAM\n@BUF3    EQU   R7                            I/O MGMT\n         COPY #ARCBITS\n         USING ARCHDEL2,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             DEL2 ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHDEL2,R11        DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             DEL2 NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RESTORE BACK POINTER\n         L     R14,12(,R14)        RESTORE ORIG. REG 14\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         XC    FCOUNT,FCOUNT       CLEAR FUNCTION RECORD COUNT\n         XC    MCNT,MCNT           AND MEMBER COUNT\n         XC    ACNT,ACNT           AND ALIAS COUNT\n         MVC   VS1MODE,=CL8'OUTPUT' SET THE I/O MODE\n         LA    R1,VSAM1DD          LOAD THE PARM POINTER\n         LA    R0,0                AND THE 'OPEN' FLAG\n         CALL  ARCHVSOP            CALL THE 'OPEN' FUNCTION\n         LTR   R15,R15             OPEN OK ??\n         BNZ   ENDITALL            NOPE; CAN'T WORK\n         L     @RPL1,RPL1\n         L     @RPL2,RPL2\n         L     @RPL3,RPL3\n         L     @BUF1,VS1BUF1\n         L     @BUF2,VS1BUF2\n         L     @BUF3,VS1BUF3\n         EJECT\n*---------------------------------------------------------------------*\n*---     HERE'S THE MEAT OF THE JOB. THESE ARE THE BASIC STEPS     ---*\n*---     INVOLVED.  DETAILS TO FOLLOW.                             ---*\n*---                                                               ---*\n*---     1. USING RPL1/VS1BUF1, LOCATE A HEADER RECORD THAT IS     ---*\n*---        NOT AN ALIAS RECORD.                                   ---*\n*---                                                               ---*\n*---     2. CALL ARCHKNAM TO DETERMINE WHETHER OR NOT THIS KEY     ---*\n*---        FITS THE CRITERIA SPECIFIED BY THE USER.               ---*\n*---                                                               ---*\n*---     3. SAVE THE KEY, INCLUDING THE SEQUENCE NUMBER TO THE     ---*\n*---        VALUE IN BLDLAREA. DECREMENT THE VERSION NUMBER BY     ---*\n*---        ONE AND SEARCH FOR A HEADER THAT MATCHES FOR THE       ---*\n*---        LENGTH SPECIFIED BY 'RECPKEY'. THIS IS A BACK LEVEL    ---*\n*---        AND SHOULD BE DELETED.                                 ---*\n*---                                                               ---*\n*---     4. LOOK FOR AN ALIAS FOR THIS 'BACK-LEVEL' ITEM. IF FOUND,---*\n*---        DELETE THE ALIAS AND COPY THE ITEM, RENAMING TO THE    ---*\n*---        KEY VALUES FROM THE ALIAS.                             ---*\n*---                                                               ---*\n*---     5. CALL ARCHERAS TO ERASE THE 'BACK-LEVEL' ITEM WE'VE     ---*\n*---        FOUND, THEN GO BACK AND CHECK FOR ANOTHER              ---*\n*---        'BACK-LEVEL' COPY OF THIS ITEM.  REPEAT STEPS 4 AND 5  ---*\n*---        UNTIL NO FURTHER 'BACK-LEVEL' COPIES OF THIS ITEM ARE  ---*\n*---        FOUND.                                                 ---*\n*---------------------------------------------------------------------*\nMEMBERS  DS    0H\n         USING REC,@BUF1           BASE THE RECORD DSECT\n         XC    0(RECKLEN,@BUF1),0(@BUF1) START AT THE BEGINNING !!\n         MVI   RECTT,#RTHDR        SET TO HEADER TYPE\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               ARG=(@BUF1),AREA=(@BUF1),AREALEN=(*,VS1LIM),            X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         POINT RPL=(@RPL1)         GET TO IT\n*---------------------------------------------------------------------*\n*---     1. USING RPL1/VS1BUF1, LOCATE A HEADER RECORD.            ---*\n*---------------------------------------------------------------------*\nNEXTHDR  DS    0H\n         GET   RPL=(@RPL1)         AND READ A HEADER RECORD\n         LTR   R15,R15             DID WE GET A RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\n         #IF   RSRALIAS,ON,NEXTHDR SKIP ALIAS RECORDS ---\n*---------------------------------------------------------------------*\n*---     2. CALL ARCHKNAM TO DETERMINE WHETHER OR NOT THIS KEY     ---*\n*---        FITS THE CRITERIA SPECIFIED BY THE USER.               ---*\n*---------------------------------------------------------------------*\nNEWHDR   DS    0H\n         LA    R1,RECN             POINT TO THE HEADER\n         LA    R0,0                USE DEFAULT QUALIFIER DATA\n         CALL  ARCHKNAM            GO CHECK: DO WE PROCESS THIS ITEM ??\n         LTR   R15,R15             PASS THE CHECK ??\n         BNZ   NEXTHDR             NOPE ---\n*---------------------------------------------------------------------*\n*---     3. SAVE THE KEY, INCLUDING THE SEQUENCE NUMBER TO THE     ---*\n*---        VALUE IN BLDLAREA. READ THE NEXT HEADER AND CHECK FOR  ---*\n*---        A MATCHING KEY, UP TO BUT NOT INCLUDING THE VERSION    ---*\n*---        NUMBER. IGNORE ALIAS RECORDS.                          ---*\n*---------------------------------------------------------------------*\n         MVC   BLDLAREA(RECKLEN),RECTT SAVE THAT KEY ---\nDELA     DS    0H\n         GET   RPL=(@RPL1)         READ ANOTHER HEADER\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE\n         #IF   RSRALIAS,ON,DELA    SKIP ALIAS RECORDS ---\n         CLC   RECTT(RECPKEY),BLDLAREA SAME ITEM DIF. VERSION ??\n         BNE   NEWHDR              NOPE ---\n*---------------------------------------------------------------------*\n*---     ITEM TO BE DELETED HAS BEEN FOUND. START BY CHECKING FOR  ---*\n*---     AN ALIAS TO 'ALTER' IT TO.  ALSO SAVE ITS KEY IN BUF3.    ---*\n*---------------------------------------------------------------------*\n         #IF   RSRHALS,OFF,NOALIAS    NO ALIASES FOR THIS ITEM\n         XC    0(49,@BUF2),0(@BUF2)   START AT THE BEGINNING\n         POINT RPL=(@RPL2)\n         DROP  @BUF1\n         USING REC,@BUF2\nASRCH    DS    0H\n         GET   RPL=(@RPL2)         READ A RECORD\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   DELA                NOPE; NO ALIAS FOR THIS ITEM\n         #IF   RSRALIAS,OFF,ASRCH  SKIP NON-ALIAS HEADERS\n         CLC   RECN-REC(44,@BUF1),RECAN ALIAS FOR THIS ITEM ??\n         BNE   ASRCH               NOPE ---\n*---------------------------------------------------------------------*\n*---     WE FOUND AN ALIAS. NOW DELETE THE ALIAS RECORD AND ALTER  ---*\n*---     THE ITEM WE ARE DELETING SUCH THE THE ALIAS IS REPLACED   ---*\n*---     BY THE ITEM.                                              ---*\n*---------------------------------------------------------------------*\n         MODCB RPL=(@RPL2),        RESET RPL2 FOR UPDATE/INSERT        X\n               OPTCD=(DIR,FKS,KGE,SYN,UPD),                            X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         GET   RPL=(@RPL2)         RE-READ THE RECORD, FOR UPDATE\n         ERASE RPL=(@RPL2)\n         ENDREQ RPL=(@RPL2)\n         CALL  ARCHALT,(1(,@BUF1),1(,@BUF2)),MF=(E,CALLIST)\n*---------------------------------------------------------------------*\n*---     POINT ALL ALIASES FOR THE OLD ITEM AT THE NEW ITEM       ----*\n*---     CREATED BY ARCHALT.                                      ----*\n*---------------------------------------------------------------------*\n         DROP  @BUF2\n         USING REC,@BUF3           BASE THE RECORD DSECT\n         XC    0(RECKLEN,@BUF3),0(@BUF3) START AT THE BEGINNING !!\n         MVI   RECTT,#RTHDR        INITIAL RECORD TYPE\n         MODCB RPL=(@RPL3),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,UPD),                            X\n               ARG=(@BUF3),                                            X\n               AREA=(@BUF3),                                           X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         POINT RPL=(@RPL3)         GET TO IT\nAA1      DS    0H\n         GET   RPL=(@RPL3)         AND READ A HEADER RECORD\n         LTR   R15,R15             ANYTHING LEFT ??\n         BNZ   AA2                 NOPE; ALL DONE\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   AA2                 NOPE; ALL DONE ---\n         #IF   RSRALIAS,OFF,AA1    NOT AN ALIAS RECORD\n         CLC   RECAN(44),1(@BUF1)  ALTER THIS ONE ??\n         BNE   AA1                 NOPE ---\n         MVC   RECAN(44),1(@BUF2)  REPLACE ALIAS FIELDS\n         PUT   RPL=(@RPL3)         WRITE THE UPDATED RECORD\n         LTR   R15,R15             ANYTHING ??\n         BNZ   1(,R15)             NOPE; DIE HORRIBLY\n         B     AA1                 LOOP FOR MORE ---\nAA2      DS    0H\n         ENDREQ RPL=(@RPL3)\n         DROP  @BUF3\n         MODCB RPL=(@RPL3),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               MF=(G,GENWK)\n*---------------------------------------------------------------------*\n*---     NOW WE'RE READY TO DELETE THE ITEM'S ORIGINAL RECORDS.    ---*\n*---     USE THE ARCHERAS ROUTINE TO DO THE ACTUAL DELETE.         ---*\n*---------------------------------------------------------------------*\n         USING REC,@BUF1\n         LA    R1,RECTT            POINT TO THE DELETABLE ITEM'S KEY\n         CALL  ARCHERAS            GO ERASE THE ITEM\n         #FORMAT RECTT,,DELMBR\n         #PUT  LINE                AND OUTPUT THE MESSAGE\n         DROP  @BUF1\n         USING REC,@BUF2\n         #FORMAT RECTT,,DELMOV,OUT=LINE+10\n         #PUT  LINE                AND OUTPUT THE MESSAGE\n         DROP  @BUF2\n         L     R15,MCNT            LOAD THE MEMBER COUNT\n         LA    R15,1(,R15)\n         ST    R15,MCNT            SAVE UPDATED COUNT\n         B     DELA                AND TRY FOR ANOTHER ITEM\nNOALIAS  DS    0H\n         USING REC,@BUF1\n         #FORMAT RECTT,,DELNOA\n         #PUT  LINE                AND OUTPUT THE MESSAGE\n         B     DELA                LOOK FOR ANOTHER ---\nDELNOA   DC    AL1(DELNOAE-DELNOAS)\nDELNOAS  DC    C' NO ALIASES EXIST. NO ACTION TAKEN.'\nDELNOAE  EQU   *\n         DROP  @BUF1               DISCARD RECORD DSECT\nENDITALL DS    0H\n         L     R0,MCNT             LOAD MEMBER COUNT\n         LTR   R0,R0               ZERO COUNT ??\n         BZ    END2                YES ---\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,MCMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\nEND2     DS    0H\n         CLC   ACB1,=F'0'          WAS ACB EVER OPENED ??\n         BE    NOACB               NOPE ---\n         LA    R1,VSAM1DD          POINT TO THE DDNAME\n         LA    R0,4                SET 'CLOSE' REQUEST\n         CALL  ARCHVSOP            CALL THE VSAM 'CLOSE' ROUTINE\nNOACB    DS    0H\n         XC    CHAIN,CHAIN         CLEAR THE CHAIN POINTER\n         L     R13,4(,R13)         LOAD BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ALWAYS RC = 0\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\nDELMBR   DC    AL1(DELMSGE-DELMSG)\nDELMSG   DC    C' DELETE REQUEST COMPLETE.'\nDELMSGE  EQU   *\nDELMOV   DC    AL1(DELMOVE-DELMOVM)\nDELMOVM  DC    C' NOW CONTAINS THE COMPLETE ITEM.'\nDELMOVE  EQU   *\nMCMSG    DC    CL133' '\n         ORG   MCMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    C' TOTAL ITEMS(S) PROCESSED.'\n         ORG\n         LTORG\n         COPY  #RECS\n         COPY  ##ARCHWK\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHDEL3": {"ttr": 3850, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00\\xc8\\x00\\xc8\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 200, "newlines": 200, "modlines": 0, "user": "ARCHIVR"}, "text": "DEL3     TITLE 'ARCHIVER --- DELETE FUNCTION'\n*---------------------------------------------------------------------*\n*---    THIS SUBROUTINE OF ARCHDEL WILL DELETE ALL THE ALIASES OF  ---*\n*---    SELECTED BACK VERSIONS OF ARCHIVE ITEMS.                   ---*\n*---------------------------------------------------------------------*\n         EJECT\nARCHDEL3 CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n@RPL1    EQU   R2                  SOME\n@RPL2    EQU   R3                    SPECIAL\n@RPL3    EQU   R4                      EQUATES\n@BUF1    EQU   R5                        FOR\n@BUF2    EQU   R6                          VSAM\n@BUF3    EQU   R7                            I/O MGMT\n         COPY #ARCBITS\n         USING ARCHDEL3,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             DEL3 ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHDEL3,R11        DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             DEL3 NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RESTORE BACK POINTER\n         L     R14,12(,R14)        RESTORE ORIG. REG 14\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         XC    FCOUNT,FCOUNT       CLEAR FUNCTION RECORD COUNT\n         XC    MCNT,MCNT           AND MEMBER COUNT\n         XC    ACNT,ACNT           AND ALIAS COUNT\n         MVC   VS1MODE,=CL8'OUTPUT' SET THE I/O MODE\n         LA    R1,VSAM1DD          LOAD THE PARM POINTER\n         LA    R0,0                AND THE 'OPEN' FLAG\n         CALL  ARCHVSOP            CALL THE 'OPEN' FUNCTION\n         LTR   R15,R15             OPEN OK ??\n         BNZ   ENDITALL            NOPE; CAN'T WORK\n         L     @RPL1,RPL1\n         L     @RPL2,RPL2\n         L     @RPL3,RPL3\n         L     @BUF1,VS1BUF1\n         L     @BUF2,VS1BUF2\n         L     @BUF3,VS1BUF3\n         EJECT\n*---------------------------------------------------------------------*\n*---     HERE'S THE MEAT OF THE JOB. THESE ARE THE BASIC STEPS     ---*\n*---     INVOLVED.  DETAILS TO FOLLOW.                             ---*\n*---                                                               ---*\n*---     1. USING RPL1/VS1BUF1, LOCATE A HEADER RECORD THAT IS     ---*\n*---        NOT AN ALIAS RECORD.                                   ---*\n*---                                                               ---*\n*---     2. CALL ARCHKNAM TO DETERMINE WHETHER OR NOT THIS KEY     ---*\n*---        FITS THE CRITERIA SPECIFIED BY THE USER.               ---*\n*---                                                               ---*\n*---     3. SAVE THE KEY, INCLUDING THE SEQUENCE NUMBER TO THE     ---*\n*---        VALUE IN BLDLAREA. DECREMENT THE VERSION NUMBER BY     ---*\n*---        ONE AND SEARCH FOR A HEADER THAT MATCHES FOR THE       ---*\n*---        LENGTH SPECIFIED BY 'RECPKEY'. THIS IS A BACK LEVEL    ---*\n*---        AND SHOULD BE DELETED.                                 ---*\n*---                                                               ---*\n*---     4. LOOK FOR AN ALIAS FOR THIS 'BACK-LEVEL' ITEM. IF FOUND,---*\n*---        DELETE THE ALIAS AND AND LOOK FOR ANOTHER.             ---*\n*---                                                               ---*\n*---     5. DELETE THE BACK-LEVEL ITEM.  REPEAT STEPS 4 AND 5      ---*\n*---        UNTIL NO FURTHER 'BACK-LEVEL' COPIES OF THIS ITEM ARE  ---*\n*---        FOUND.                                                 ---*\n*---------------------------------------------------------------------*\nMEMBERS  DS    0H\n         USING REC,@BUF1           BASE THE RECORD DSECT\n         XC    0(RECKLEN,@BUF1),0(@BUF1) START AT THE BEGINNING !!\n         MVI   RECTT,#RTHDR        SET TO HEADER TYPE\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               ARG=(@BUF1),                                            X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         MODCB RPL=(@RPL2),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,UPD),                            X\n               ARG=(@BUF2),                                            X\n               AREA=(@BUF2),                                           X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         POINT RPL=(@RPL1)         GET TO IT\n*---------------------------------------------------------------------*\n*---     1. USING RPL1/VS1BUF1, LOCATE A HEADER RECORD.            ---*\n*---------------------------------------------------------------------*\nNEXTHDR  DS    0H\n         GET   RPL=(@RPL1)         AND READ A HEADER RECORD\n         LTR   R15,R15             DID WE GET A RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\n         #IF   RSRALIAS,ON,NEXTHDR SKIP ALIAS RECORDS ---\n*---------------------------------------------------------------------*\n*---     2. CALL ARCHKNAM TO DETERMINE WHETHER OR NOT THIS KEY     ---*\n*---        FITS THE CRITERIA SPECIFIED BY THE USER.               ---*\n*---------------------------------------------------------------------*\nNEWHDR   DS    0H\n         LA    R1,RECN             POINT TO THE HEADER\n         LA    R0,0                USE DEFAULT QUALIFIER DATA\n         CALL  ARCHKNAM            GO CHECK: DO WE PROCESS THIS ITEM ??\n         LTR   R15,R15             PASS THE CHECK ??\n         BNZ   NEXTHDR             NOPE ---\n*---------------------------------------------------------------------*\n*---     3. SAVE THE KEY, INCLUDING THE SEQUENCE NUMBER TO THE     ---*\n*---        VALUE IN BLDLAREA. READ THE NEXT HEADER AND CHECK FOR  ---*\n*---        A MATCHING KEY, UP TO BUT NOT INCLUDING THE VERSION    ---*\n*---        NUMBER. IGNORE ALIAS RECORDS.                          ---*\n*---------------------------------------------------------------------*\n         MVC   BLDLAREA(RECKLEN),RECTT SAVE THAT KEY ---\nDELA     DS    0H\n         GET   RPL=(@RPL1)         READ ANOTHER HEADER\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE\n         #IF   RSRALIAS,ON,DELA    SKIP ALIAS RECORDS ---\n         CLC   RECTT(RECPKEY),BLDLAREA SAME ITEM DIF. VERSION ??\n         BNE   NEWHDR              NOPE ---\n         ENDREQ RPL=(@RPL1)\n*---------------------------------------------------------------------*\n*---     ITEM TO BE DELETED HAS BEEN FOUND. START BY LOCATING AND  ---*\n*---     DELETING ANY ALIASES THAT REFER TO IT.                    ---*\n*---------------------------------------------------------------------*\n         #IF   RSRHALS,OFF,NOALIAS NO ALIASES FOR THIS ITEM\n         XC    0(49,@BUF2),0(@BUF2) START AT THE BEGINNING\n         POINT RPL=(@RPL2)\n         PUSH  USING\n         USING REC,@BUF2\nASRCH    DS    0H\n         GET   RPL=(@RPL2)         READ A RECORD\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ADELDN              NOPE; ALL DONE\n         #IF   RSRALIAS,OFF,ASRCH  SKIP NON-ALIAS HEADERS\n         CLC   RECAN(44),RECN-REC(@BUF1) ALIAS FOR THIS ITEM ??\n         BNE   ASRCH               NOPE ---\n         ERASE RPL=(@RPL2)         DELETE THE ALIAS RECORD\n         #FORMAT RECTT,,DELMBR\n         #PUT  LINE                AND OUTPUT THE RESULTS\n         L     R15,ACNT            LOAD THE MEMBER COUNT\n         LA    R15,1(,R15)\n         ST    R15,ACNT            SAVE UPDATED COUNT\n         B     ASRCH               AND LOOK FOR ANOTHER\nADELDN   DS    0H\n         ENDREQ RPL=(@RPL2)        FINISH THE WRITES, ETC.\nNOALIAS  DS    0H\n         POP   USING\n         ICM   R15,15,RECSEQ#      INSERT THE SEQUENCE NUMBER\n         LA    R15,1(,R15)         INCREMENT BY ONE\n         STCM  R15,15,RECSEQ#      SAVE UPDATED VALUE\n         POINT RPL=(@RPL1)         RESET MY POSITIONING\n         B     DELA                AND TRY FOR ANOTHER ITEM\nENDITALL DS    0H\n         L     R0,ACNT             LOAD MEMBER COUNT\n         LTR   R0,R0               ZERO COUNT ??\n         BZ    END2                YES ---\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,ACMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\nEND2     DS    0H\n         CLC   ACB1,=F'0'          WAS ACB EVER OPENED ??\n         BE    NOACB               NOPE ---\n         LA    R1,VSAM1DD          POINT TO THE DDNAME\n         LA    R0,4                SET 'CLOSE' REQUEST\n         CALL  ARCHVSOP            CALL THE VSAM 'CLOSE' ROUTINE\nNOACB    DS    0H\n         XC    CHAIN,CHAIN         CLEAR THE CHAIN POINTER\n         L     R13,4(,R13)         LOAD BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ALWAYS RC = 0\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\nDELMBR   DC    AL1(DELMSGE-DELMSG)\nDELMSG   DC    C' ALIAS OF BACK VERSION DELETED.'\nDELMSGE  EQU   *\nACMSG    DC    CL133' '\n         ORG   ACMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    C' TOTAL ALIAS(ES) OF BACK VERSIONS DELETED.'\n         ORG\n         LTORG\n         COPY  #RECS\n         COPY  ##ARCHWK\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHDEL4": {"ttr": 4097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00\\xcb\\x00\\xcb\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 203, "newlines": 203, "modlines": 0, "user": "ARCHIVR"}, "text": "DEL4     TITLE 'ARCHIVER --- DELETE FUNCTION'\n*---------------------------------------------------------------------*\n*---    THIS SUBROUTINE OF ARCHDELE DELETES ALL NOTE DATA FROM     ---*\n*---    THE SELECTED ITEM(S).  IT'S A FAIRLY SIMPLE ROUTINE AND    ---*\n*---    CAN BE UNDERSTOOD FROM THE IMBEDDED COMMENTS IN THE CODE.  ---*\n*---------------------------------------------------------------------*\n         EJECT\nARCHDEL4 CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n@RPL1    EQU   R2                  SOME\n@RPL2    EQU   R3                    SPECIAL\n@RPL3    EQU   R4                      EQUATES\n@BUF1    EQU   R5                        FOR\n@BUF2    EQU   R6                          VSAM\n@BUF3    EQU   R7                            I/O MGMT\n         COPY #ARCBITS\n         USING ARCHDEL4,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             DEL4 ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHDEL4,R11        DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             DEL4 NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RESTORE BACK POINTER\n         L     R14,12(,R14)        RESTORE ORIG. REG 14\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         XC    FCOUNT,FCOUNT       CLEAR FUNCTION RECORD COUNT\n         XC    MCNT,MCNT           AND MEMBER COUNT\n         XC    ACNT,ACNT           AND ALIAS COUNT\n         MVC   VS1MODE,=CL8'OUTPUT' SET THE I/O MODE\n         LA    R1,VSAM1DD          LOAD THE PARM POINTER\n         LA    R0,0                AND THE 'OPEN' FLAG\n         CALL  ARCHVSOP            CALL THE 'OPEN' FUNCTION\n         LTR   R15,R15             OPEN OK ??\n         BNZ   ENDITALL            NOPE; CAN'T WORK\n         L     @RPL1,RPL1\n         L     @RPL2,RPL2\n         L     @RPL3,RPL3\n         L     @BUF1,VS1BUF1\n         L     @BUF2,VS1BUF2\n         L     @BUF3,VS1BUF3\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               ACB=(*,ACB1),                                           X\n               ARG=(@BUF1),                                            X\n               AREA=(@BUF1),                                           X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         MODCB RPL=(@RPL2),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,UPD),                            X\n               ACB=(*,ACB1),                                           X\n               ARG=(@BUF2),                                            X\n               AREA=(@BUF2),                                           X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         EJECT\n*---------------------------------------------------------------------*\n*---     HERE'S THE MEAT OF THE JOB. THESE ARE THE BASIC STEPS     ---*\n*---     INVOLVED.  DETAILS TO FOLLOW.                             ---*\n*---                                                               ---*\n*---     1. USING RPL1/VS1BUF1, LOCATE A HEADER RECORD THAT IS     ---*\n*---        NOT AN ALIAS RECORD.                                   ---*\n*---                                                               ---*\n*---     2. CALL ARCHKNAM TO DETERMINE WHETHER OR NOT THIS KEY     ---*\n*---        FITS THE CRITERIA SPECIFIED BY THE USER.               ---*\n*---                                                               ---*\n*---     3. USING RPL2/BUF2, LOCATE AND ERASE ANY NOTE RECORDS     ---*\n*---        THAT MATCH IN NAME, GROUP, SUBGROUP, TYPE AND VERSION  ---*\n*---        NUMBER.                                                ---*\n*---                                                               ---*\n*---     4. RETURN TO STEP1 AND CONTINUE                           ---*\n*---------------------------------------------------------------------*\nMEMBERS  DS    0H\n         USING REC,@BUF1           BASE THE RECORD DSECT\n         XC    0(RECKLEN,@BUF1),0(@BUF1) START AT THE BEGINNING !!\n         MVI   RECTT,#RTHDR        SET TO HEADER TYPE\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               ARG=(@BUF1),                                            X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         POINT RPL=(@RPL1)         GET TO IT\n*---------------------------------------------------------------------*\n*---     1. USING RPL1/VS1BUF1, LOCATE A HEADER RECORD.            ---*\n*---------------------------------------------------------------------*\nNEXTHDR  DS    0H\n         GET   RPL=(@RPL1)         AND READ A HEADER RECORD\n         LTR   R15,R15             DID WE GET A RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\n         #IF   RSRALIAS,ON,NEXTHDR SKIP ALIAS RECORDS ---\n*---------------------------------------------------------------------*\n*---     2. CALL ARCHKNAM TO DETERMINE WHETHER OR NOT THIS KEY     ---*\n*---        FITS THE CRITERIA SPECIFIED BY THE USER.               ---*\n*---------------------------------------------------------------------*\n         LA    R1,RECN             POINT TO THE HEADER\n         LA    R0,0                USE DEFAULT QUALIFIER DATA\n         CALL  ARCHKNAM            GO CHECK: DO WE PROCESS THIS ITEM ??\n         LTR   R15,R15             PASS THE CHECK ??\n         BNZ   NEXTHDR             NOPE ---\n*---------------------------------------------------------------------*\n*---     3. USING RPL2/BUF2, LOCATE AND DELETE ANY NOTE RECORDS    ---*\n*---        OF A MATCHING KEY.                                     ---*\n*---------------------------------------------------------------------*\n         XC    0(49,@BUF2),0(@BUF2) CLEAR THE KEY AREA\n         MVC   0(45,@BUF2),0(@BUF1) COPY THAT KEY ---\n         MVI   0(@BUF2),#RTNOTE    SET FOR NOTE DATA\n         POINT RPL=(@RPL2)\nDELA     DS    0H\n         GET   RPL=(@RPL2)         READ ANOTHER HEADER\n         CLI   0(@BUF2),#RTNOTE       NOTE RECORD ??\n         BNE   NODEL               NOPE; ALL DONE\n         CLC   1(44,@BUF2),1(@BUF1) FOR THIS ITEM ??\n         BNE   NODEL               NOPE; ALL DONE\n         ERASE RPL=(@RPL2)         ERASE THE RECORD\n         L     R15,ACNT            LOAD TOTAL VALUE\n         LA    R15,1(,R15)         INCREMENT\n         ST    R15,ACNT            SAVE UPDATED VALUE\n         B     DELA                AND LOOP, SEARCHINGLY\nNODEL    DS    0H\n         ENDREQ RPL=(@RPL2)\n         MVC   0(49,@BUF2),0(@BUF1) COPY THE KEY AGAIN\n         POINT RPL=(@RPL2)\n         GET   RPL=(@RPL2)         READ THE HEADER AGAIN\n         XC    RSRNOT#-REC(4,@BUF2),RSRNOT#-REC(@BUF2)\n         PUT   RPL=(@RPL2)         SHOW NO NOTE DATA\n         #FORMAT RECTT,,DELNOTE\n         #PUT  LINE                OUTPUT THE 'NOTE DATA DELETED' MSG\n         L     R15,MCNT            LOAD TOTAL VALUE\n         LA    R15,1(,R15)         INCREMENT\n         ST    R15,MCNT            SAVE UPDATED VALUE\n         B     NEXTHDR             AND LOOP FOR ANOTHER HEADER\nENDITALL DS    0H\n         L     R0,MCNT             LOAD MEMBER COUNT\n         LTR   R0,R0               ZERO COUNT ??\n         BZ    END2                YES ---\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,MCMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\n         L     R0,ACNT             LOAD MEMBER COUNT\n         LTR   R0,R0               ZERO COUNT ??\n         BZ    END2                YES ---\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,ACMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\nEND2     DS    0H\n         CLC   ACB1,=F'0'          WAS ACB EVER OPENED ??\n         BE    NOACB               NOPE ---\n         LA    R1,VSAM1DD          POINT TO THE DDNAME\n         LA    R0,4                SET 'CLOSE' REQUEST\n         CALL  ARCHVSOP            CALL THE VSAM 'CLOSE' ROUTINE\nNOACB    DS    0H\n         XC    CHAIN,CHAIN         CLEAR THE CHAIN POINTER\n         L     R13,4(,R13)         LOAD BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ALWAYS RC = 0\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\nDELNOTE  DC    AL1(DELMSGE-DELMSG)\nDELMSG   DC    C' NOTEDATA DELETED.'\nDELMSGE  EQU   *\nMCMSG    DC    CL133' '\n         ORG   MCMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    C' TOTAL ITEMS(S) PROCESSED.'\n         ORG\nACMSG    DC    CL133' '\n         ORG   ACMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    C' NOTE DATA RECORDS ERASED.'\n         ORG\n         LTORG\n         COPY  #RECS\n         COPY  ##ARCHWK\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHDEL5": {"ttr": 4101, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x01\\x1e\\x01\\x1e\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 286, "newlines": 286, "modlines": 0, "user": "ARCHIVR"}, "text": "DEL5     TITLE 'ARCHIVER --- DELETE FUNCTION'\n*---------------------------------------------------------------------*\n*---    THIS SUBROUTINE OF ARCHDELE IS A FAIRLY COMPLEX ROUTINE.   ---*\n*---    IT WILL DELETE A SINGLE ITEM AND ALL ITS ALIASES. ONLY     ---*\n*---    THE HIGHEST-NUMBERED VERSION WILL BE AFFECTED.             ---*\n*---                                                               ---*\n*---    1.  LOCATE A NON-ALIAS HEADER RECORD OF AN ITEM TO BE      ---*\n*---        DELETED.  THE QUALIFIERS IN THE RECORD KEY MUST MATCH  ---*\n*---        THOSE SUPPLIED BY THE USER.                            ---*\n*---                                                               ---*\n*---    2.  LOCATE AND DELETE ALL THE ALIASES FOR THIS ITEM.       ---*\n*---                                                               ---*\n*---    3.  LOCATE ALL RECORDS FOR THE SELECTED ITEM AND ERASE     ---*\n*---        THEM                                                   ---*\n*---                                                               ---*\n*---    4.  LOOP BACK TO STATEMENT 1 AND CONTINUE                  ---*\n*---                                                               ---*\n*---    NOTE THAT THIS ONLY DELETES A SINGLE ITEM AT A TIME.       ---*\n*---------------------------------------------------------------------*\n         EJECT\nARCHDEL5 CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n@RPL1    EQU   R2                  SOME\n@RPL2    EQU   R3                    SPECIAL\n@RPL3    EQU   R4                      EQUATES\n@BUF1    EQU   R5                        FOR\n@BUF2    EQU   R6                          VSAM\n@BUF3    EQU   R7                            I/O MGMT\n         COPY #ARCBITS\n         USING ARCHDEL5,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             DEL5 ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHDEL5,R11        DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             DEL5 NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RESTORE BACK POINTER\n         L     R14,12(,R14)        RESTORE ORIG. REG 14\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         XC    FCOUNT,FCOUNT       CLEAR FUNCTION RECORD COUNT\n         XC    MCNT,MCNT           AND MEMBER COUNT\n         XC    ACNT,ACNT           AND ALIAS COUNT\n         MVC   VS1MODE,=CL8'OUTPUT' SET THE I/O MODE\n         LA    R1,VSAM1DD          LOAD THE PARM POINTER\n         LA    R0,0                AND THE 'OPEN' FLAG\n         CALL  ARCHVSOP            CALL THE 'OPEN' FUNCTION\n         LTR   R15,R15             OPEN OK ??\n         BNZ   ENDITALL            NOPE; CAN'T WORK\n         L     @RPL1,RPL1\n         L     @RPL2,RPL2\n         L     @RPL3,RPL3\n         L     @BUF1,VS1BUF1\n         L     @BUF2,VS1BUF2\n         L     @BUF3,VS1BUF3\n         BAL   R14,CLEAN           GO CLEAN UP ANY ORPHAN ALIASES\n         EJECT\n*---------------------------------------------------------------------*\n*---     HERE'S THE MEAT OF THE JOB. THESE ARE THE BASIC STEPS     ---*\n*---     INVOLVED.  DETAILS TO FOLLOW.                             ---*\n*---                                                               ---*\n*---     1. USING RPL1/VS1BUF1, LOCATE A HEADER RECORD THAT IS     ---*\n*---        NOT AN ALIAS RECORD.                                   ---*\n*---                                                               ---*\n*---     2. CALL ARCHKNAM TO DETERMINE WHETHER OR NOT THIS KEY     ---*\n*---        FITS THE CRITERIA SPECIFIED BY THE USER.               ---*\n*---                                                               ---*\n*---     4. LOOK FOR AN ALIAS FOR THIS 'BACK-LEVEL' ITEM. IF FOUND,---*\n*---        DELETE THE ALIAS AND CONTINUE THE SEARCH FOR MORE      ---*\n*---        ALIASES FOR THIS ITEM.                                 ---*\n*---                                                               ---*\n*---     5. DELETE THE ITEM BY CALLING THE ARCHERAS ROUTINE.       ---*\n*---------------------------------------------------------------------*\nMEMBERS  DS    0H\n         USING REC,@BUF1           BASE THE RECORD DSECT\n         XC    0(RECKLEN,@BUF1),0(@BUF1) START AT THE BEGINNING !!\n         MVI   RECTT,#RTHDR        SET TO HEADER TYPE\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               ARG=(@BUF1),                                            X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         POINT RPL=(@RPL1)         GET TO IT\n*---------------------------------------------------------------------*\n*---     1. USING RPL1/VS1BUF1, LOCATE A HEADER RECORD.            ---*\n*---------------------------------------------------------------------*\nNEXTHDR  DS    0H\n         GET   RPL=(@RPL1)         AND READ A HEADER RECORD\n         LTR   R15,R15             DID WE GET A RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\n         #IF   RSRALIAS,ON,NEXTHDR SKIP ALIAS RECORDS ---\n*---------------------------------------------------------------------*\n*---     2. CALL ARCHKNAM TO DETERMINE WHETHER OR NOT THIS KEY     ---*\n*---        FITS THE CRITERIA SPECIFIED BY THE USER.               ---*\n*---------------------------------------------------------------------*\n         LA    R1,RECN             POINT TO THE HEADER\n         LA    R0,0                USE DEFAULT QUALIFIER DATA\n         CALL  ARCHKNAM            GO CHECK: DO WE PROCESS THIS ITEM ??\n         LTR   R15,R15             PASS THE CHECK ??\n         BNZ   NEXTHDR             NOPE ---\n*---------------------------------------------------------------------*\n*---     ITEM TO BE DELETED HAS BEEN FOUND. START BY CHECKING FOR  ---*\n*---     AN ALIAS TO 'ALTER' IT TO.  ALSO SAVE ITS KEY IN BUF3.    ---*\n*---------------------------------------------------------------------*\n         MVC   0(49,@BUF3),0(@BUF1) SAVE ITEM KEY\n         #IF   RSRHALS,OFF,NOALIAS NO ALIASES FOR THIS ITEM\n         XC    0(49,@BUF2),0(@BUF2) START AT THE BEGINNING\n         POINT RPL=(@RPL2)\n         DROP  @BUF1\n         USING REC,@BUF2\nASRCH    DS    0H\n         GET   RPL=(@RPL2)         READ A RECORD\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   NOALIAS             NOPE; ALL DONE\n         #IF   RSRALIAS,OFF,ASRCH  SKIP NON-ALIAS HEADERS\n         CLC   RECN-REC(44,@BUF1),RECAN ALIAS FOR THIS ITEM ??\n         BNE   ASRCH               NOPE ---\n*---------------------------------------------------------------------*\n*---     ALIAS IS FOUND. START THE PROCESS BY REWRITING THE ALIAS  ---*\n*---     RECORD AS A 'REAL' ITEM HEADER RECORD, USING THE DATA     ---*\n*---     FROM THE HEADER IN BUFFER 1.                              ---*\n*---------------------------------------------------------------------*\n         ERASE RPL=(@RPL2)         DELETE THE ALIAS RECORD\nNOALIAS  DS    0H\n*---------------------------------------------------------------------*\n*---     NOW WE'RE READY TO DELETE THE ITEM'S ORIGINAL RECORDS.    ---*\n*---     NOTE THAT IN OUR VARIOUS MEANDERINGS TO PRESERVE THE      ---*\n*---     ALIAS NAME AND RELATED DATA, WE'VE PRESERVED THE          ---*\n*---     ORIGINAL HEADER'S KEY IN BUF3. THIS MAKES THE ACTUAL      ---*\n*---     DELETION PROCESS MUCH EASIER.                             ---*\n*---------------------------------------------------------------------*\n         LA    R1,RECTT             POINT TO ITEM KEY\n         CALL  ARCHERAS            GO ERASE THE ITEM\n         #FORMAT RECTT,,DELMBR\n         #PUT  LINE                AND OUTPUT THE MESSAGE\n         L     R15,MCNT            LOAD THE MEMBER COUNT\n         LA    R15,1(,R15)\n         ST    R15,MCNT            SAVE UPDATED COUNT\n         MVC   0(49,@BUF1),0(@BUF3) RE-COPY THE RECORD KEY\n         POINT RPL=(@RPL1)         RESET MY POSITIONING\n         B     NEXTHDR             AND TRY FOR ANOTHER ITEM\n         DROP  @BUF2               DISCARD RECORD DSECT\nENDITALL DS    0H\n         L     R0,MCNT             LOAD MEMBER COUNT\n         LTR   R0,R0               ZERO COUNT ??\n         BZ    END2                YES ---\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,MCMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\nEND2     DS    0H\n         CLC   ACB1,=F'0'          WAS ACB EVER OPENED ??\n         BE    NOACB               NOPE ---\n         LA    R1,VSAM1DD          POINT TO THE DDNAME\n         LA    R0,4                SET 'CLOSE' REQUEST\n         CALL  ARCHVSOP            CALL THE VSAM 'CLOSE' ROUTINE\nNOACB    DS    0H\n         XC    CHAIN,CHAIN         CLEAR THE CHAIN POINTER\n         L     R13,4(,R13)         LOAD BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ALWAYS RC = 0\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\nDELMBR   DC    AL1(DELMSGE-DELMSG)\nDELMSG   DC    C' DELETE REQUEST COMPLETE.'\nDELMSGE  EQU   *\nMCMSG    DC    CL133' '\n         ORG   MCMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    C' TOTAL ITEMS(S) PROCESSED.'\n         ORG\n         TITLE 'CLEAN UP THE ALIAS FLAGS, ETC.'\n*---------------------------------------------------------------------*\n*---     WE LOOP THROUGH THE HEADER RECORDS TWICE FOR THIS        ----*\n*---     PROCESS.  THE FIRST LOOP CONCENTRATES ON THE 'TRUE NAME' ----*\n*---     RECORDS, TURNING OFF THE FLAG BIT THAT INDICATES THE     ----*\n*---     PRESENCE OF ALIASES.  THE SECOND PASS LOCATES ALL THE    ----*\n*---     ALIAS RECORDS AND SETS THE 'ALIASES PRESENT' BIT ON IN   ----*\n*---     THE 'TRUE NAME' RECORD THEY REFER TO.  IF THE 'TRUE      ----*\n*---     NAME' IS NOT PRESENT, THE ALIAS RECORD IS DELETED.       ----*\n*---------------------------------------------------------------------*\nCLEAN    DS    0H\n         STM   R14,R12,IOSAVE      SAVE THE ENTRY REGISTERS\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,UPD),                            X\n               ACB=(*,ACB1),                                           X\n               ARG=(@BUF1),                                            X\n               AREA=(@BUF1),                                           X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         MODCB RPL=(@RPL2),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,UPD),                            X\n               ACB=(*,ACB1),                                           X\n               ARG=(@BUF2),                                            X\n               AREA=(@BUF2),                                           X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         MODCB RPL=(@RPL3),                                            X\n               OPTCD=(DIR,FKS,KEQ,SYN,UPD),                            X\n               ACB=(*,ACB1),                                           X\n               ARG=(@BUF1),                                            X\n               AREA=(@BUF1),                                           X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         USING REC,@BUF1           BASE THE RECORD DSECT\n         XC    0(RECKLEN,@BUF1),0(@BUF1) CLEAR THE KEY\n         POINT RPL=(@RPL1)         GET TO IT\nCL1      DS    0H\n         GET   RPL=(@RPL1)         GO READ A RECORD\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   CL2                 NOPE; ALL DONE ---\n         #IF   RSRALIAS,ON,CL1     DON'T TOUCH ALIASES, YET\n         #SET  RSRHALS,OFF         INDICATE NO ALIASES\n         PUT   RPL=(@RPL1)         AND OUTPUT THE RECORD\n         B     CL1                 AND LOOP FOR MORE\nCL2      DS    0H\n         XC    0(RECKLEN,@BUF1),0(@BUF1) RESET TO STARTING KEY\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(NUP),                                            X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\nCL3      DS    0H\n         MVI   RECSEQ#+3,1         INCREMENT THE KEY VALUE\n         POINT RPL=(@RPL1)         RESET TO DATASET START\n         GET   RPL=(@RPL1)         READ A RECORD\n         ENDREQ RPL=(@RPL1)\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   CL5                 NOPE; ALL DONE\n         #IF   RSRALIAS,OFF,CL3    NOT AN ALIAS ---\n         XC    0(RECKLEN,@BUF2),0(@BUF2) CLEAR THE KEY AREA\n         MVI   0(@BUF2),#RTHDR     SHOW A HEADER RECORD\n         MVC   1(44,@BUF2),RECAN   MOVE IN THE 'TRUE NAME'\n         MODCB RPL=(@RPL2),                                            X\n               OPTCD=(DIR,FKS,KEQ,SYN,UPD),                            X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         GET   RPL=(@RPL2)         AND FETCH THE RECORD (MAYBE)\n         LTR   R15,R15             WAS IT FOUND ??\n         BNZ   CL4                 NOPE; DELETE THE ALIAS RECORD\n         PUSH  USING\n         USING REC,@BUF2\n         #SET  RSRHALS,ON          SAY IT HAS ALIASES\n         POP   USING\n         PUT   RPL=(@RPL2)         UPDATE THE RECORD\n         B     CL3                 AND CONTINUE ---\nCL4      DS    0H\n         GET   RPL=(@RPL3)         RE-FETCH THE RECORD\n         ERASE RPL=(@RPL3)         DELETE IT\n         B     CL3                 AND CONTINUE ---\nCL5      DS    0H\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         MODCB RPL=(@RPL2),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         MODCB RPL=(@RPL3),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         LM    R14,R12,IOSAVE      RESTORE REGS\n         BR    R14                 AND RETURN TO LOCAL CALLER\n         DROP  @BUF1\n         LTORG\n         COPY  #RECS\n         COPY  ##ARCHWK\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHDEL6": {"ttr": 4107, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00\\xe6\\x00\\xe6\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 230, "newlines": 230, "modlines": 0, "user": "ARCHIVR"}, "text": "DEL6     TITLE 'ARCHIVER --- DELETE FUNCTION'\n*---------------------------------------------------------------------*\n*---    THIS SUBROUTINE OF ARCHDELE IS A FAIRLY COMPLEX ROUTINE.   ---*\n*---    IT WILL PERFORM THE 'DELETE BACK LEVELS NOTE DATA'         ---*\n*---    FUNCTION.  THE ACTUAL STEPS INVOLVED ARE THESE:            ---*\n*---                                                               ---*\n*---    1.  LOCATE A NON-ALIAS HEADER RECORD OF AN ITEM TO BE      ---*\n*---        DELETED.  THE QUALIFIERS IN THE RECORD KEY MUST MATCH  ---*\n*---        THOSE SUPPLIED BY THE USER AND THE VERSION NUMBER      ---*\n*---        MUST BE LOWER THAT A PREVIOUSLY-ENCOUNTERED ITEM OF    ---*\n*---        THE SAME MEMBER, GROUP, SUBGROUP AND TYPE VALUES.      ---*\n*---        (WHAT A MOUTHFUL!)                                     ---*\n*---                                                               ---*\n*---    2.  LOCATE ALL NOTE DATA RECORDS FOR THE SELECTED ITEM     ---*\n*---        AND ERASE THEM                                         ---*\n*---                                                               ---*\n*---    3.  LOOP BACK TO STATEMENT 1 AND CONTINUE                  ---*\n*---------------------------------------------------------------------*\n         EJECT\nARCHDEL6 CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n@RPL1    EQU   R2                  SOME\n@RPL2    EQU   R3                    SPECIAL\n@RPL3    EQU   R4                      EQUATES\n@BUF1    EQU   R5                        FOR\n@BUF2    EQU   R6                          VSAM\n@BUF3    EQU   R7                            I/O MGMT\n         COPY #ARCBITS\n         USING ARCHDEL6,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             DEL6 ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHDEL6,R11        DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             DEL6 NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RESTORE BACK POINTER\n         L     R14,12(,R14)        RESTORE ORIG. REG 14\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         XC    FCOUNT,FCOUNT       CLEAR FUNCTION RECORD COUNT\n         XC    MCNT,MCNT           AND MEMBER COUNT\n         XC    ACNT,ACNT           AND ALIAS COUNT\n         MVC   VS1MODE,=CL8'OUTPUT' SET THE I/O MODE\n         LA    R1,VSAM1DD          LOAD THE PARM POINTER\n         LA    R0,0                AND THE 'OPEN' FLAG\n         CALL  ARCHVSOP            CALL THE 'OPEN' FUNCTION\n         LTR   R15,R15             OPEN OK ??\n         BNZ   ENDITALL            NOPE; CAN'T WORK\n         L     @RPL1,RPL1\n         L     @RPL2,RPL2\n         L     @RPL3,RPL3\n         L     @BUF1,VS1BUF1\n         L     @BUF2,VS1BUF2\n         L     @BUF3,VS1BUF3\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               ARG=(@BUF1),                                            X\n               AREA=(@BUF1),                                           X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)\n         MODCB RPL=(@RPL2),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,UPD),                            X\n               ARG=(@BUF2),                                            X\n               AREA=(@BUF2),                                           X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)\n         EJECT\n*---------------------------------------------------------------------*\n*---     HERE'S THE MEAT OF THE JOB. THESE ARE THE BASIC STEPS     ---*\n*---     INVOLVED.  DETAILS TO FOLLOW.                             ---*\n*---                                                               ---*\n*---     1. USING RPL1/VS1BUF1, LOCATE A HEADER RECORD THAT IS     ---*\n*---        NOT AN ALIAS RECORD.                                   ---*\n*---                                                               ---*\n*---     2. CALL ARCHKNAM TO DETERMINE WHETHER OR NOT THIS KEY     ---*\n*---        FITS THE CRITERIA SPECIFIED BY THE USER.               ---*\n*---                                                               ---*\n*---     3. SAVE THE KEY, INCLUDING THE SEQUENCE NUMBER TO THE     ---*\n*---        VALUE IN BLDLAREA. DECREMENT THE VERSION NUMBER BY     ---*\n*---        ONE AND SEARCH FOR A HEADER THAT MATCHES FOR THE       ---*\n*---        LENGTH SPECIFIED BY 'RECPKEY'. THIS IS A BACK LEVEL    ---*\n*---        AND SHOULD BE PROCESSED.                               ---*\n*---                                                               ---*\n*---     5. CHECK FOR AND DELETE ANY NOTE RECORDS FOR THE ITEM     ---*\n*---        SELECTED IN STEP 3.                                    ---*\n*---------------------------------------------------------------------*\nMEMBERS  DS    0H\n         USING REC,@BUF1           BASE THE RECORD DSECT\n         XC    0(RECKLEN,@BUF1),0(@BUF1) START AT THE BEGINNING !!\n         MVI   RECTT,#RTHDR        SET TO HEADER TYPE\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               ARG=(@BUF1),                                            X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         POINT RPL=(@RPL1)         GET TO IT\n*---------------------------------------------------------------------*\n*---     1. USING RPL1/VS1BUF1, LOCATE A HEADER RECORD.            ---*\n*---------------------------------------------------------------------*\nNEXTHDR  DS    0H\n         GET   RPL=(@RPL1)         AND READ A HEADER RECORD\n         LTR   R15,R15             DID WE GET A RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\nNEWHDR   DS    0H\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\n         #IF   RSRALIAS,ON,NEXTHDR SKIP ALIAS RECORDS ---\n*---------------------------------------------------------------------*\n*---     2. CALL ARCHKNAM TO DETERMINE WHETHER OR NOT THIS KEY     ---*\n*---        FITS THE CRITERIA SPECIFIED BY THE USER.               ---*\n*---------------------------------------------------------------------*\n         LA    R1,RECN             POINT TO THE HEADER\n         LA    R0,0                USE DEFAULT QUALIFIER DATA\n         CALL  ARCHKNAM            GO CHECK: DO WE PROCESS THIS ITEM ??\n         LTR   R15,R15             PASS THE CHECK ??\n         BNZ   NEXTHDR             NOPE ---\n*---------------------------------------------------------------------*\n*---     3. SAVE THE KEY, INCLUDING THE SEQUENCE NUMBER TO THE     ---*\n*---        VALUE IN BLDLAREA. READ THE NEXT HEADER AND CHECK FOR  ---*\n*---        A MATCHING KEY, UP TO BUT NOT INCLUDING THE VERSION    ---*\n*---        NUMBER. IGNORE ALIAS RECORDS.                          ---*\n*---------------------------------------------------------------------*\n         MVC   BLDLAREA(RECKLEN),RECTT SAVE THAT KEY ---\nDELA     DS    0H\n         GET   RPL=(@RPL1)         READ ANOTHER HEADER\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE\n         #IF   RSRALIAS,ON,DELA    SKIP ALIAS RECORDS ---\n         CLC   RECTT(RECPKEY),BLDLAREA SAME ITEM DIF. VERSION ??\n         BNE   NEWHDR              NOPE ---\n*---------------------------------------------------------------------*\n*---     ITEM TO BE PROCESSED HAS BEEN FOUND. LOCATE ANY NOTE      ---*\n*---     RECORDS AND DELETE THEM.                                  ---*\n*---------------------------------------------------------------------*\n         DROP  @BUF1\n         USING REC,@BUF2\n         MVC   0(49,@BUF2),0(@BUF1) COPY ITEM KEY\n         MVI   RECTT,#RTNOTE        SET FOR NOTE DATA\n         POINT RPL=(@RPL2)\nASRCH    DS    0H\n         GET   RPL=(@RPL2)         READ A RECORD\n         CLI   RECTT,#RTNOTE       NOTE RECORD ??\n         BNE   NOALIAS             NOPE; ALL DONE\n         CLC   1(44,@BUF2),1(@BUF1) SAME ITEM ??\n         BNE   NOALIAS             NOPE ---\n         ERASE RPL=(@RPL2)         ERASE THE RECORD\n         L     R15,ACNT            LOAD RECORD COUNTER\n         LA    R15,1(,R15)         INCREMENT BY ONE\n         ST    R15,ACNT            SAVE UPDATED COUNTER\n         B     ASRCH               AND CONTINUE\nNOALIAS  DS    0H\n         MVC   0(49,@BUF2),0(@BUF1) RE-READ THE HEADER RECORD\n         GET   RPL=(@RPL2)\n         NC    RSRNOT#,RSRNOT#     DOES HEADER SHOW NOTE DATA ??\n         BZ    DROPIT              NOPE; GO FOR ANOTHER ITEM\n         XC    RSRNOT#,RSRNOT#     NO NOTE DATA PRESENT\n         PUT   RPL=(@RPL2)         UPDATE THE RECORD\nDROPIT   DS    0H\n         ENDREQ RPL=(@RPL2)\n         B     DELA                AND GO FOR ANOTHER RECORD\n         DROP  @BUF2\nENDITALL DS    0H\n         L     R0,MCNT             LOAD MEMBER COUNT\n         LTR   R0,R0               ZERO COUNT ??\n         BZ    END2                YES ---\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,MCMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\n         L     R0,ACNT             LOAD MEMBER COUNT\n         LTR   R0,R0               ZERO COUNT ??\n         BZ    END2                YES ---\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,ACMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\nEND2     DS    0H\n         CLC   ACB1,=F'0'          WAS ACB EVER OPENED ??\n         BE    NOACB               NOPE ---\n         LA    R1,VSAM1DD          POINT TO THE DDNAME\n         LA    R0,4                SET 'CLOSE' REQUEST\n         CALL  ARCHVSOP            CALL THE VSAM 'CLOSE' ROUTINE\nNOACB    DS    0H\n         XC    CHAIN,CHAIN         CLEAR THE CHAIN POINTER\n         L     R13,4(,R13)         LOAD BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ALWAYS RC = 0\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\nDELMBR   DC    AL1(DELMSGE-DELMSG)\nDELMSG   DC    C' DELETE REQUEST COMPLETE.'\nDELMSGE  EQU   *\nMCMSG    DC    CL133' '\n         ORG   MCMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    C' TOTAL ITEMS(S) PROCESSED.'\n         ORG\nACMSG    DC    CL133' '\n         ORG   ACMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    C' NOTE RECORDS DELETED.'\n         ORG\n         LTORG\n         COPY  #RECS\n         COPY  ##ARCHWK\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHDEL7": {"ttr": 4357, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x01\\x0f\\x01\\x0f\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 271, "newlines": 271, "modlines": 0, "user": "ARCHIVR"}, "text": "DEL7     TITLE 'ARCHIVER --- DELETE FUNCTION'\n*---------------------------------------------------------------------*\n*---    THIS SUBROUTINE OF ARCHDELE IS A FAIRLY COMPLEX ROUTINE.   ---*\n*---    IT WILL PERFORM THE 'DELETE BACK LEVELS NOTE DATA AND      ---*\n*---    ALIASES' FUNCTION.  THE ACTUAL STEPS INVOLVED ARE THESE:   ---*\n*---                                                               ---*\n*---    1.  LOCATE A NON-ALIAS HEADER RECORD OF AN ITEM TO BE      ---*\n*---        DELETED.  THE QUALIFIERS IN THE RECORD KEY MUST MATCH  ---*\n*---        THOSE SUPPLIED BY THE USER AND THE VERSION NUMBER      ---*\n*---        MUST BE LOWER THAT A PREVIOUSLY-ENCOUNTERED ITEM OF    ---*\n*---        THE SAME MEMBER, GROUP, SUBGROUP AND TYPE VALUES.      ---*\n*---        (WHAT A MOUTHFUL!)                                     ---*\n*---                                                               ---*\n*---    2.  LOCATE ALL NOTE DATA RECORDS FOR THE SELECTED ITEM     ---*\n*---        AND ERASE THEM                                         ---*\n*---                                                               ---*\n*---    3.  LOCATE ALL ALIASES FOR THE SELECTED ITEM AND ERASE     ---*\n*---        THEM.                                                  ---*\n*---                                                               ---*\n*---    4.  LOOP BACK TO STEP 1 AND CONTINUE                       ---*\n*---------------------------------------------------------------------*\n         EJECT\nARCHDEL7 CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n@RPL1    EQU   R2                  SOME\n@RPL2    EQU   R3                    SPECIAL\n@RPL3    EQU   R4                      EQUATES\n@BUF1    EQU   R5                        FOR\n@BUF2    EQU   R6                          VSAM\n@BUF3    EQU   R7                            I/O MGMT\n         COPY #ARCBITS\n         USING ARCHDEL7,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             DEL7 ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHDEL7,R11        DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             DEL7 NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RESTORE BACK POINTER\n         L     R14,12(,R14)        RESTORE ORIG. REG 14\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         XC    FCOUNT,FCOUNT       CLEAR FUNCTION RECORD COUNT\n         XC    MCNT,MCNT           AND MEMBER COUNT\n         XC    ACNT,ACNT           AND ALIAS COUNT\n         MVC   VS1MODE,=CL8'OUTPUT' SET THE I/O MODE\n         LA    R1,VSAM1DD          LOAD THE PARM POINTER\n         LA    R0,0                AND THE 'OPEN' FLAG\n         CALL  ARCHVSOP            CALL THE 'OPEN' FUNCTION\n         LTR   R15,R15             OPEN OK ??\n         BNZ   ENDITALL            NOPE; CAN'T WORK\n         L     @RPL1,RPL1\n         L     @RPL2,RPL2\n         L     @RPL3,RPL3\n         L     @BUF1,VS1BUF1\n         L     @BUF2,VS1BUF2\n         L     @BUF3,VS1BUF3\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               ARG=(@BUF1),                                            X\n               AREA=(@BUF1),                                           X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)\n         MODCB RPL=(@RPL2),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,UPD),                            X\n               ARG=(@BUF2),                                            X\n               AREA=(@BUF2),                                           X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)\n         EJECT\n*---------------------------------------------------------------------*\n*---     HERE'S THE MEAT OF THE JOB. THESE ARE THE BASIC STEPS     ---*\n*---     INVOLVED.  DETAILS TO FOLLOW.                             ---*\n*---                                                               ---*\n*---     1. USING RPL1/VS1BUF1, LOCATE A HEADER RECORD THAT IS     ---*\n*---        NOT AN ALIAS RECORD.                                   ---*\n*---                                                               ---*\n*---     2. CALL ARCHKNAM TO DETERMINE WHETHER OR NOT THIS KEY     ---*\n*---        FITS THE CRITERIA SPECIFIED BY THE USER.               ---*\n*---                                                               ---*\n*---     3. SAVE THE KEY, INCLUDING THE SEQUENCE NUMBER TO THE     ---*\n*---        VALUE IN BLDLAREA. DECREMENT THE VERSION NUMBER BY     ---*\n*---        ONE AND SEARCH FOR A HEADER THAT MATCHES FOR THE       ---*\n*---        LENGTH SPECIFIED BY 'RECPKEY'. THIS IS A BACK LEVEL    ---*\n*---        AND SHOULD BE PROCESSED.                               ---*\n*---                                                               ---*\n*---     5. CHECK FOR AND DELETE ANY NOTE RECORDS FOR THE ITEM     ---*\n*---        SELECTED IN STEP 3.                                    ---*\n*---------------------------------------------------------------------*\nMEMBERS  DS    0H\n         USING REC,@BUF1           BASE THE RECORD DSECT\n         XC    0(RECKLEN,@BUF1),0(@BUF1) START AT THE BEGINNING !!\n         MVI   RECTT,#RTHDR        SET TO HEADER TYPE\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               ARG=(@BUF1),                                            X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         POINT RPL=(@RPL1)         GET TO IT\n*---------------------------------------------------------------------*\n*---     1. USING RPL1/VS1BUF1, LOCATE A HEADER RECORD.            ---*\n*---------------------------------------------------------------------*\nNEXTHDR  DS    0H\n         GET   RPL=(@RPL1)         AND READ A HEADER RECORD\n         LTR   R15,R15             DID WE GET A RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\nNEWHDR   DS    0H\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\n         #IF   RSRALIAS,ON,NEXTHDR SKIP ALIAS RECORDS ---\n*---------------------------------------------------------------------*\n*---     2. CALL ARCHKNAM TO DETERMINE WHETHER OR NOT THIS KEY     ---*\n*---        FITS THE CRITERIA SPECIFIED BY THE USER.               ---*\n*---------------------------------------------------------------------*\n         LA    R1,RECN             POINT TO THE HEADER\n         LA    R0,0                USE DEFAULT QUALIFIER DATA\n         CALL  ARCHKNAM            GO CHECK: DO WE PROCESS THIS ITEM ??\n         LTR   R15,R15             PASS THE CHECK ??\n         BNZ   NEXTHDR             NOPE ---\n*---------------------------------------------------------------------*\n*---     3. SAVE THE KEY, INCLUDING THE SEQUENCE NUMBER TO THE     ---*\n*---        VALUE IN BLDLAREA. READ THE NEXT HEADER AND CHECK FOR  ---*\n*---        A MATCHING KEY, UP TO BUT NOT INCLUDING THE VERSION    ---*\n*---        NUMBER. IGNORE ALIAS RECORDS.                          ---*\n*---------------------------------------------------------------------*\n         MVC   BLDLAREA(RECKLEN),RECTT SAVE THAT KEY ---\nDELA     DS    0H\n         GET   RPL=(@RPL1)         READ ANOTHER HEADER\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE\n         #IF   RSRALIAS,ON,DELA    SKIP ALIAS RECORDS ---\n         CLC   RECTT(RECPKEY),BLDLAREA SAME ITEM DIF. VERSION ??\n         BNE   NEWHDR              NOPE ---\n*---------------------------------------------------------------------*\n*---     ITEM TO BE PROCESSED HAS BEEN FOUND. LOCATE ANY NOTE      ---*\n*---     RECORDS AND DELETE THEM.                                  ---*\n*---------------------------------------------------------------------*\n         MVC   0(49,@BUF2),0(@BUF1) COPY ITEM KEY\n         MVI   0(@BUF2),#RTNOTE     SET FOR NOTE DATA\n         POINT RPL=(@RPL2)\n         DROP  @BUF1\n         USING REC,@BUF2\nNSRCH    DS    0H\n         GET   RPL=(@RPL2)         READ A RECORD\n         CLI   RECTT,#RTNOTE       NOTE RECORD ??\n         BNE   NONOTE              NOPE; ALL DONE\n         CLC   1(44,@BUF2),1(@BUF1) SAME ITEM ??\n         BNE   NONOTE              NOPE ---\n         ERASE RPL=(@RPL2)         ERASE THE RECORD\n         LTR   R15,R15             ERASE OK ??\n         BNZ   1(,R15)             NOPE; DIE HORRIBLY\n         L     R15,FCOUNT          LOAD THE COUNT\n         LA    R15,1(,R15)         INCREMENT BY ONE\n         ST    R15,FCOUNT          SAVE UPDATED COUNT\n         B     NSRCH               AND CONTINUE\nNONOTE   DS    0H\n         MVC   0(49,@BUF2),0(@BUF1) RE-READ THE HEADER RECORD\n         GET   RPL=(@RPL2)\n         XC    RSRNOT#,RSRNOT#\n         #SET  RSRHALS,OFF         SHOW NO ALIASES\n         PUT   RPL=(@RPL2)\n         ENDREQ RPL=(@RPL2)\nDOALIAS  DS    0H\n         XC    RECTT(49),RECTT     CLEAR OUT THE KEY AREA\n         POINT RPL=(@RPL2)         RESET TO CLUSTER START\nASRCH    DS    0H\n         GET   RPL=(@RPL2)         READ A RECORD\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   NOALIAS             NOPE; ALL DONE\n         #IF   RSRALIAS,OFF,ASRCH  NOT AN ALIAS RECORD\n         CLC   RECAN(44),1(@BUF1)  FOR THE SELECTED ITEM ??\n         BNE   ASRCH               NOPE ---\n         ERASE RPL=(@RPL2)         YES; ERASE IT\n         L     R15,ACNT            LOAD ALIAS COUNT\n         LA    R15,1(,R15)         INCREMENT BY ONE\n         ST    R15,ACNT            SAVE UPDATED VALUE\n         B     ASRCH               AND KEEP SEARCHING\n         DROP  @BUF2\n         USING REC,@BUF1\nNOALIAS  DS    0H\n         #FORMAT RECTT,,DELNOT\n         #PUT  LINE\n         B     DELA\n         DROP  @BUF1\nENDITALL DS    0H\n         L     R0,MCNT             LOAD MEMBER COUNT\n         LTR   R0,R0               ZERO COUNT ??\n         BZ    END1                YES ---\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,MCMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\nEND1     DS    0H\n         L     R0,ACNT             LOAD MEMBER COUNT\n         LTR   R0,R0               ZERO COUNT ??\n         BZ    END2                YES ---\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,ACMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\nEND2     DS    0H\n         L     R0,MCNT             LOAD MEMBER COUNT\n         LTR   R0,R0               ZERO COUNT ??\n         BZ    END3                YES ---\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,FCMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\nEND3     DS    0H\n         CLC   ACB1,=F'0'          WAS ACB EVER OPENED ??\n         BE    NOACB               NOPE ---\n         LA    R1,VSAM1DD          POINT TO THE DDNAME\n         LA    R0,4                SET 'CLOSE' REQUEST\n         CALL  ARCHVSOP            CALL THE VSAM 'CLOSE' ROUTINE\nNOACB    DS    0H\n         XC    CHAIN,CHAIN         CLEAR THE CHAIN POINTER\n         L     R13,4(,R13)         LOAD BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ALWAYS RC = 0\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\nDELNOT   DC    AL1(DELMSGE-DELMSG)\nDELMSG   DC    C' NOTE DATA AND ALIASES DELETED.'\nDELMSGE  EQU   *\nMCMSG    DC    CL133' '\n         ORG   MCMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    C' TOTAL ITEMS(S) PROCESSED.'\n         ORG\nACMSG    DC    CL133' '\n         ORG   ACMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    C' TOTAL ALIAS RECORDS DELETED.'\n         ORG\nFCMSG    DC    CL133' '\n         ORG   FCMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    C' TOTAL NOTE RECORDS DELETED.'\n         ORG\n         LTORG\n         COPY  #RECS\n         COPY  ##ARCHWK\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHDIR": {"ttr": 4362, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x01P\\x01P\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 336, "newlines": 336, "modlines": 0, "user": "ARCHIVR"}, "text": "DIR      TITLE 'ARCHDIR --- ARCHIVER FUNCTION SUPPORT ROUTINE'\n*---------------------------------------------------------------------*\n*---     ARCHDIR --- READ A COMPLETE PDS DIRECTORY AND BUILD A     ---*\n*---           LIST OF NAMES AND ALIASES. ALSO DO ANY GENERIC      ---*\n*---           NAME CHECKING DURING CHAIN CONSTRUCTION AND         ---*\n*---           REMOVE THE ELEMENTS THAT DON'T FIT.                 ---*\n*---                                                               ---*\n*---     PARAMETERS: NONE                                          ---*\n*---                                                               ---*\n*---     INPUT DCB IS POINTED TO BY THE NDCBB FIELD                ---*\n*---                                                               ---*\n*---     RESULTING CHAIN IS POINTED TO BY THE FULLWORD ADDRESS     ---*\n*---              'CHAIN'                                          ---*\n*---                                                               ---*\n*---     CHAIN FORMAT:                                             ---*\n*---           DS  A  ADDRESS OF NEXT CHAIN LINK, OR ZERO.         ---*\n*---           DS  A  ADDRESS OF FIRST ALIAS, OR ZERO              ---*\n*---           DS  CL80 COMPLETE DIRECTORY ENTRY, MINUS BLDL       ---*\n*---                    BYTES.                                     ---*\n*---                                                               ---*\n*---     ALL ALIASES ARE CHAINED IN EXACTLY THE SAME FASHION,      ---*\n*---           INCLUDING THE COMPLETE DIRECTORY ENTRY.             ---*\n*---                                                               ---*\n*---     ALIAS CHAIN FORMAT:                                       ---*\n*---           DS  A  ADDRESS OF NON-ALIAS MEMBER NAME ENTRY       ---*\n*---           DS  A  ADDRESS OF NEXT ALIAS, OR ZERO               ---*\n*---           DS  CL80 COMPLETE DIRECTORY ENTRY, MINUS BLDL       ---*\n*---                    BYTES.                                     ---*\n*---                                                               ---*\n*---------------------------------------------------------------------*\n         EJECT\nARCHDIR  CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n         USING ARCHDIR,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             LOAD ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHDIR,R11         DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             LOAD NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RELOAD BACK POINTER\n         L     R14,12(,R14)        RELOAD ORIG. REG 14\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n*---------------------------------------------------------------------*\n*---     INIT THE PARM LIST                                        ---*\n*---------------------------------------------------------------------*\n         XC    CHAIN,CHAIN         START WITH EMPTY CHAIN\n         L     R8,NDCBB            POINT TO INPUT DCB\n         USING IHADCB,R8           AND BASE THE DCB DSECT\n         TM    DCBOFLGS,DCBOFOPN   IS DCB OPEN ??\n         BZ    DR18                NOPE; 8 RETURN CODE AND QUIT\n*---------------------------------------------------------------------*\n*---     LOOP THROUGH THE DIRECTORY, PICKING OUT THE NON-ALIAS     ---*\n*---     MEMBER NAMES AND CHAINING THEM.                           ---*\n*---------------------------------------------------------------------*\nDR1      DS    0H\n         GET   (R8)                READ A DIRECTORY BLOCK\n         LA    R4,2(,R1)           POINT TO DATA START\n         LH    R5,0(,R1)           LOAD BYTES-USED VALUE\n         BCTR  R5,R0               DECREMENT BY ONE\n         LA    R5,0(R5,R1)         POINT TO LAST VALID BYTE\n         USING PDS2,R4             BASE THE DIRECTORY ENTRY DSECT\nDR2      CLC   PDS2NAME,DR19       END-OF-DIRECTORY MARKER ??\n         BE    DR7                 YES; DO THE ALIASES NOW\n         IC    R6,PDS2INDC         INSERT ALIAS/LENGTH BITS\n         N     R6,=A(PDS2LUSR)     ISOLATE LENGTH\n         LA    R6,11(R6,R6)        COMPUTE FULL ENTRY LENGTH\n         TM    PDS2INDC,PDS2ALIS   IS THIS AN ALIAS ??\n         BO    DR5                 YES; SKIP IT THIS TIME\n         GETMAIN R,LV=88,SP=84     GRAB SOME STORAGE\n         XC    0(88,R1),0(R1)      CLEAR IT OUT\n         EX    R6,DR6              COPY IN THE DIRECTORY DATA\n         LA    R7,CHAIN            POINT TO CHAIN START\nDR3      NC    0(4,R7),0(R7)       NULL POINTER ??\n         BZ    DR4                 YES; STORE NEW LINK POINTER\n         L     R7,0(,R7)           BUMP DOWN THE CHAIN\n         B     DR3                 CONTINUE LOOPING AND SEARCHING\nDR4      DS    0H\n         ST    R1,0(,R7)           STORE NEW LINK POINTER\nDR5      DS    0H\n         LA    R4,1(R6,R4)         POINT DOWN THE BLOCK\n         CR    R4,R5               PAST END OF BLOCK\n         BL    DR2                 NOPE; JUST CONTINUE DEBLOCKING\n         B     DR1                 YES; GET A FRESH BLOCK\nDR6      MVC   8(1,R1),PDS2NAME    COPY OF DIRECTORY ENTRY\n*---------------------------------------------------------------------*\n*---     RE-READ THE DIRECTORY, LOOKING FOR ALIASES.               ---*\n*---------------------------------------------------------------------*\nDR7      DS    0H\n         OI    NDCBB,X'80'\n         CLOSE (,REREAD),MF=(E,NDCBB)    CLOSE DIRECTORY FOR RE-READ\n         MVC   DCBEODA,=AL3(DR16)\n         OPEN  MF=(E,NDCBB)        AND RE-OPEN\n         NI    NDCBB,255-X'80'\nDR8      DS    0H\n         GET   (R8)                READ A DIRECTORY BLOCK\n         LA    R4,2(,R1)           POINT TO DATA START\n         LH    R5,0(,R1)           LOAD BYTES-USED VALUE\n         BCTR  R5,R0               DECREMENT BY ONE\n         LA    R5,0(R5,R1)         POINT TO LAST VALID BYTE\nDR9      CLC   DR19,0(R4)          END-OF-DIRECTORY MARKER ??\n         BE    DR16                YES; DO THE ALIASES NOW\n         IC    R6,11(,R4)          INSERT ALIAS/LENGTH BITS\n         N     R6,=A(X'1F')        ISOLATE LENGTH\n         LA    R6,11(R6,R6)        COMPUTE FULL ENTRY LENGTH\n         TM    PDS2INDC,PDS2ALIS   IS THIS AN ALIAS ??\n         BZ    DR15                NO; SKIP IT THIS TIME\n         GETMAIN R,LV=88,SP=84     GRAB SOME STORAGE\n         XC    0(88,R1),0(R1)      CLEAR IT OUT\n         EX    R6,DR6              COPY IN THE DIRECTORY DATA\n         LA    R3,CHAIN            COPY THE CHAIN START POINTER\n         L     R7,0(,R3)           LOAD FIRST LINK POINTER\nDR10     DS    0H\n         LTR   R7,R7               NULL POINTER ??\n         BZ    DR11                YES; STORE NEW LINK POINTER\n         CLC   16(3,R1),16(R7)     DO TTR'S MATCH ??\n         BE    DR12                YES; INSERT KNOWN ALIAS\n         LR    R3,R7               DOUWN THE CHAIN ---\n         L     R7,0(,R7)           BUMP DOWN THE CHAIN\n         B     DR10                CONTINUE LOOPING AND SEARCHING\nDR11     DS    0H\n         BAL   R9,UNALIAS          GO CONVERT TO NON-ALIAS MEMBER TYPE\n         MVC   LINE,DELMSG         COPY MESSAGE SKELETON TO OUTPUT LINE\n         MVC   LINE+18(8),8(R1)    INSERT ORPHAN ALIAS NAME\n         #PUT  LINE                AND OUTPUT THE MESSAGE\n         B     DR15                AND GO DEBLOCK SOME MORE\nDR12     DS    0H\n         ST    R7,0(,R1)           STORE POINTER TO NON-ALIAS NAME\nDR13     DS    0H\n         NC    4(4,R7),4(R7)       ALIAS CHAIN EMPTY ??\n         BZ    DR14                YES; INSERT NEW ALIAS\n         L     R7,4(,R7)           BUMP DOWN THE CHAIN\n         B     DR13                AND KEEP SEARCHING\nDR14     DS    0H\n         ST    R1,4(,R7)\nDR15     DS    0H\n         LA    R4,1(R6,R4)         POINT DOWN THE BLOCK\n         CR    R4,R5               PAST END OF BLOCK\n         BL    DR9                 NOPE; JUST CONTINUE DEBLOCKING\n         B     DR8                 YES; GET A FRESH BLOCK\n         DROP  R4\n*---------------------------------------------------------------------*\n*---     ALL DONE; NOW LOOP THROUGH, CHECKING ANY MASKS.           ---*\n*---                                                               ---*\n*---     A MASK-MATCH ON A MEMBER NAME OR ANY OF ITS ALIASES       ---*\n*---     IS CONSIDERED SUFFICIENT FOR RETENTION.  IF THE MEMBER    ---*\n*---     NAME IN Q1 HAS NO '%' CHARACTERS, DELETE ALL EXCEPT THAT  ---*\n*---     MEMBER/ALIAS AND RELATED INFORMATION.  IF THE MEMBER      ---*\n*---     NAME IN Q1 HAS NO NON-GENERIC CHARACTERS, RETAIN THE      ---*\n*---     ENTIRE CHAIN.  THE GENWK AREA OF THE MAIN ARCHIVER        ---*\n*---     WORK AREA IS USED AS A 'SCRATCH PAD'                      ---*\n*---------------------------------------------------------------------*\nDR16     DS    0H\n         MVC   GENWK(8),Q1         COPY THE MEMBER NAME\n         MVC   GENWK+8(8),GENWK    AND DUPLICATE IT\n         CLC   Q1,=CL10'*'         ALL MEMBERS ??\n         BE    ENDDIR              YES; NOTHING TO FILTER\n         LA    R5,GENWK+7          POINT TO STRING END\n         LA    R3,GENWK            AND STRING START\n         LA    R4,1                AND BXLE INCREMENT\nF1       DS    0H\n         CLI   0(R3),C'%'          GENERIC CHARACTER ??\n         BNE   F2                  NOPE ---\n         MVI   0(R3),C' '          YES; REPLACE WITH A BLANK\n         MVI   8(R3),C' '          YES; REPLACE WITH A BLANK\n         B     F3                  DO OTHER MASK\nF2       DS    0H\n         MVI   0(R3),X'FF'         ANYTHING GOES HERE\nF3       DS    0H\n         BXLE  R3,R4,F1            LOOP FOR MASKS\n*\n*        SEARCH MASKS ARE BUILT. NOW SEARCH THE CHAIN(S)\n*\n         LA    R2,CHAIN            POINT TO CHANGEABLE LINK AREA\nTSTX     DS    0H\n         L     R3,0(,R2)           LOAD STARTING POINTER\n         LTR   R3,R3               ANYTHING HERE ??\n         BZ    ENDDIR              NOPE; ALL DONE\n         L     R4,4(,R3)           POINT TO FIRST 'SUBCHAIN'\nTSTY     DS    0H\n         LTR   R4,R4               ANYTHING HERE ??\n         BZ    NOSUB               NOPE\n         MVC   GENWK+16(8),8(R4)   COPY THE MEMBER NAME\n         NC    GENWK+16(8),GENWK   MASK OUT THE GENERIC CHARS\n         CLC   GENWK+16(8),GENWK+8 REMAINDER MATCH ??\n         BE    MATCH               YES; RETAIN MAINLINK AND SUBCHAIN\n         L     R4,4(,R4)           NEXT SUBCHAIN LINK\n         B     TSTY                AND LOOP, CHECKING\nNOSUB    DS    0H\n         MVC   GENWK+16(8),8(R3)   COPY THE MEMBER NAME\n         NC    GENWK+16(8),GENWK   MASK OUT THE GENERIC CHARS\n         CLC   GENWK+16(8),GENWK+8 REMAINDER MATCH ??\n         BE    MATCH               YES; RETAIN MAINLINK AND SUBCHAIN\nFRE1     DS    0H\n         L     R4,4(,R3)           POINT TO A SUBLINK\n         LTR   R4,R4               ANY LINK PRESENT ??\n         BZ    NOSUB1              NOPE ---\n         MVC   4(4,R3),4(R4)       UNCHAIN THIS LINK\n         FREEMAIN R,LV=88,A=(4),SP=84 RELEASE THIS LINK\n         B     FRE1                AND LOOP, SEARCHINGLY\nNOSUB1   DS    0H\n         MVC   0(4,R2),0(R3)       UNCHAIN MAIN LINK\n         FREEMAIN R,LV=88,A=(3),SP=84 RELEASE ITS STORAGE\n         B     TSTX                AND LOOP, SEARCHINGLY\nMATCH    DS    0H\n         LR    R2,R3               BUMP DOWN THE CHAIN\n         B     TSTX                AND RE-TEST\n*\n*        ALL DONE. PASS BACK THE FILTERED CHAIN AND RETURN\n*\nENDDIR   DS    0H\n         L     R1,4(,R13)          LOAD BACK S.A. POINTER\n         MVC   16(4,R1),=F'0'      SET THE RETURN CODE\nDR17     DS    0H\n         L     R13,4(,R13)         LOAD BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\n*\n*        THIS RETURN CODE SET WHEN THE NDCBB DCB IS NOT OPEN\n*\nDR18     DS    0H\n         L     R1,4(,R13)          LOAD BACK S.A. POINTER\n         MVC   16(4,R1),=F'4'      SET THE RETURN CODE\n         B     DR17                AND RETURN\n         EJECT\n*---------------------------------------------------------------------*\n*---     THIS DIDDLY LITTLE LOCAL SUBROUTINE CONVERTS A 'ORPHAN'   ---*\n*---     ALIAS ENTRY TO A 'REAL' MEMBER AND INSERTS IT IN THE      ---*\n*---     CHAIN OF 'REAL' MEMBERS IN THE PROPER SEQUENCE.           ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nUNALIAS  DS    0H\n         LA    R2,8(,R1)           POINT TO ACTUAL DIRECTORY STUFF\n         USING PDS2,R2             AND BASE THE DSECT\n         NI    PDS2INDC,255-PDS2ALIS DROP THE ALIAS BIT ---\n*\n*        BECAUSE OF THE WAY THAT ALIAS LOAD MODULE ENTRIES ARE\n*        BUILT, WE NEED TO CONCERN OURSELVES WITH THE ACTUAL\n*        DIRECTORY ENTRY CONTENT, AS WELL AS THE ALIAS FLAG.  WE\n*        WILL USE THE LENGTH OF THE DIRECTORY ENTRY AS OUR\n*        'SIGNAL' THAT THIS IS A LOAD MODULE ENTRY.  WE ALSO\n*        KNOW THAT A LOAD MODULE ENTRY CONTAINS AT LEAST ONE TTR\n*        VALUE IN THE USER DATA FIELD AND THIS IS REFLECTED IN\n*        THE PDS2INDC FIELD.\n*\n         TM    PDS2INDC,X'60'      ANY TTR'S IN USER DATA ??\n         BZ    UNAADD              NOPE; ALL DONE ---\n         IC    R15,PDS2INDC        INSERT THE LENGTH/TTR COUNT FIELD\n         N     R15,=A(X'1F')       TRIM TO BARE LENGTH\n         CH    R15,=H'17'          IS IT THIS FORMAT ??\n         BNE   UNA1                NOPE ---\n         MVC   33(2,R2),44(R2)     COPY AUTH BYTES DOWN\n         LA    R15,12              NEW DIR ENTRY LENGTH\n         IC    R14,PDS2INDC        LOAD ORIGINAL VALUE\n         N     R14,=A(X'60')       KEEP ONLY TTR COUNT\n         OR    R15,R14             ADD TO LENGTH\n         STC   R15,PDS2INDC        STORE UPDATED VALUE\n         B     UNAADD              AND RETURN TO CALLER\nUNA1     DS    0H\n         CH    R15,=H'23'          IS IT THIS FORMAT ??\n         BNE   UNA2                NOPE ---\n         MVC   42(6,R2),52(R2)     COPY AUTH BYTES DOWN\n         LA    R15,18              NEW DIR ENTRY LENGTH\n         IC    R14,PDS2INDC        LOAD ORIGINAL VALUE\n         N     R14,=A(X'60')       KEEP ONLY TTR COUNT\n         OR    R15,R14             ADD TO LENGTH\n         STC   R15,PDS2INDC        STORE UPDATED VALUE\n         B     UNAADD              AND RETURN TO CALLER\nUNA2     DS    0H\n         CH    R15,=H'19'          IS IT THIS FORMAT ??\n         BNE   UNA3                NOPE ---\n         MVC   34(6,R2),44(R2)     COPY AUTH BYTES DOWN\n         LA    R15,14              NEW DIR ENTRY LENGTH\n         IC    R14,PDS2INDC        LOAD ORIGINAL VALUE\n         N     R14,=A(X'60')       KEEP ONLY TTR COUNT\n         OR    R15,R14             ADD TO LENGTH\n         STC   R15,PDS2INDC        STORE UPDATED VALUE\n         B     UNAADD              AND RETURN TO CALLER\nUNA3     DS    0H\n         CH    R15,=H'21'          IS IT THIS FORMAT ??\n         BNE   UNAADD              NOPE ---\n         MVC   41(2,R2),52(R2)     COPY AUTH BYTES DOWN\n         LA    R15,16              NEW DIR ENTRY LENGTH\n         IC    R14,PDS2INDC        LOAD ORIGINAL VALUE\n         N     R14,=A(X'60')       KEEP ONLY TTR COUNT\n         OR    R15,R14             ADD TO LENGTH\n         STC   R15,PDS2INDC        STORE UPDATED VALUE\n         B     UNAADD              AND RETURN TO CALLER\nUNAADD   DS    0H\n         LA    R3,CHAIN            LOAD CHAIN ROOT ADDRESS\nUNA4     DS    0H\n         L     R7,0(,R3)           LOAD LINK POINTER\n         LTR   R7,R7               NO MORE ??\n         BZ    UNA5                ADD NEW NAME TO END\n         CLC   8(8,R7),8(R1)       DOES NAME FIT HERE ??\n         BH    UNA5                YES ---\n         LR    R3,R7               COPY LINK ADDRESS\n         B     UNA4                AND CONTINUE\nUNA5     DS    0H\n         MVC   0(4,R1),0(R3)       COPY NEXT-LINK POINTER\n         ST    R1,0(,R3)           INSERT NEW LINK\n         BR    R9                  AND RETURN TO CALLER\n         DROP  R2\n         EJECT\n*---------------------------------------------------------------------*\n*---     MISC CONSTANTS AND DATA AREAS                             ---*\n*---------------------------------------------------------------------*\nDR19     DC    8X'FF'\nDELMSG   DC    CL133' *** ORPHAN ALIAS XXXXXXXX CONVERTED TO REAL MEMBEX\n               R FOR UNLOAD PURPOSES. *** '\n         LTORG\n         DROP  R8\n         COPY  ##ARCHWK            MAIN WORK AREA\n         IHAPDS PDSBLDL=NO\n         PRINT NOGEN\n         DCBD  DSORG=QS\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHERAS": {"ttr": 4613, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00\\x96\\x00\\x96\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 150, "newlines": 150, "modlines": 0, "user": "ARCHIVR"}, "text": "ERAS     TITLE 'ERASE --- ARCHIVER FUNCTION SUPPORT SUBROUTINE'\n*---------------------------------------------------------------------*\n*---     FUNCTION: REMOVE ALL RECORDS OF A GIVEN KEY FROM THE      ---*\n*---           VSAM ARCHIVE CLUSTER.  R1 POINTS TO THE KEY OF      ---*\n*---           THE FIRST RECORD.  ALL RECORDS WITH MATCHING        ---*\n*---           NAME, GROUP, SUBGROUP, TYPE AND VERSION NUMBER      ---*\n*---           ARE ERASED.  THE LARGEST CHANGE IN THIS VERSION     ---*\n*---           IS TO ERASE THE HEADER RECORD LAST INSTEAD OF       ---*\n*---           FIRST.  THUS, THE ITEM WILL APPEAR IN ALL LISTS     ---*\n*---           OF HEADERS UNTIL ITS DELETION IS COMPLETE.          ---*\n*---           ALSO, THE PRESENCE OF ACCURATE SEQ# VALUES IS NO    ---*\n*---           LONGER REQUIRED FOR CORRECT OPERATION. THE KEY      ---*\n*---           VALUE, UP TO BUT NOT INCLUDING SEQ#, IS USED        ---*\n*---           AS A GENERIC KEY FOR ALL SEARCHES AND COMPARES.     ---*\n*---                                                               ---*\n*---     ALL ALIAS ENTRIES THAT REFER TO THE ITEM BEING DELETED    ---*\n*---     ARE ALSO REMOVED. THIS FUNCTION ADDED IN V4.1             ---*\n*---                                                               ---*\n*---     THIS ROUTINE MAY DELETE FROM CLUSTER-2 BY REPLACING THE   ---*\n*---           ACB ADDRESS IN RPL3 VIA MODCB.                      ---*\n*---                                                               ---*\n*---     IT IS ASSUMED HEREIN THAT VS1BUF3 IS AVAILABLE FOR USE.   ---*\n*---     DITTO FOR RPL3.                                           ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nARCHERAS CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n@RPL1    EQU   R2                  SOME\n@RPL2    EQU   R3                    SPECIAL\n@RPL3    EQU   R4                      EQUATES\n@BUF1    EQU   R5                        FOR\n@BUF2    EQU   R6                          VSAM\n@BUF3    EQU   R7                            I/O MGMT\n         COPY  #ARCBITS\n         USING ARCHERAS,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             LOAD ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHERAS,R11        DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             LOAD NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RELOAD BACK POINTER\n         L     R14,12(,R14)        RELOAD ORIG. REG 14\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         L     @RPL3,RPL3          POINT TO THE RPL\n         L     @BUF3,VS1BUF3         AND THE BUFFER\n         LR    R8,R1               COPY THE INPUT RECORD-KEY POINTER\n         USING REC,R8\n         MODCB RPL=(@RPL3),                                            X\n               AREA=(@BUF3),                                           X\n               ARG=(8),                                                X\n               AREALEN=(*,VS1LIM),                                     X\n               OPTCD=(MVE,KEQ,DIR,UPD,GEN),                            X\n               KEYLEN=45,                                              X\n               MF=(G,GENWK)\n         MVC   RECSEQ#,=F'0'       CLOBBER SEQ#\n         MVI   RECTT,#RTDATA       START WITH DATA RECORDS\n         DROP  R8\n         USING REC,@BUF3\nER1      DS    0H\n         GET   RPL=(@RPL3)         READ A RECORD\n         LTR   R15,R15             DID WE GET A RECORD ??\n         BNZ   ER2                 NOPE ---\n         CLC   RECTT(45),0(R8)     KEY MATCH UP TO SEQ# ??\n         BNE   ER2                 NOPE ---\n         ERASE RPL=(@RPL3)         YES; ERASE THE RECORD\n         LTR   R15,R15             ERASE OK ??\n         BNZ   1(,R15)             NOPE; DIE HORRIBLY\n         B     ER1                 AND CONTINUE ---\nER2      DS    0H\n         MVI   0(R8),#RTNOTE       CONTINUE WITH NOTE RECORDS\nER5      DS    0H\n         GET   RPL=(@RPL3)         READ A RECORD\n         LTR   R15,R15             DID WE GET A RECORD ??\n         BNZ   ER6                 NOPE ---\n         CLC   RECTT(45),0(R8)     KEY MATCH UP TO SEQ# ??\n         BNE   ER6                 NOPE ---\n         ERASE RPL=(@RPL3)         YES; ERASE THE RECORD\n         LTR   R15,R15             ERASE OK ??\n         BNZ   1(,R15)             NOPE; DIE HORRIBLY\n         B     ER5                 AND CONTINUE ---\nER6      DS    0H\n         MODCB RPL=(@RPL3),                                            X\n               ARG=(@BUF3),                                            X\n               OPTCD=(MVE,KGE,SEQ,UPD),                                X\n               MF=(G,GENWK)\n         XC    RECTT(49),RECTT     CLEAR OUT THAT KEY\n         MVI   RECTT,#RTHDR        NOW DO THE ALIASES\n         POINT RPL=(@RPL3)\nER7      DS    0H\n         GET   RPL=(@RPL3)         READ A RECORD\n         LTR   R15,R15             DID WE GET A RECORD ??\n         BNZ   ER8                 NOPE ---\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ER8                 NOPE ---\n         #IF   RSRALIAS,OFF,ER7    NOT AN ALIAS\n         CLC   RECAN(44),1(R8)\n         BNE   ER7                 NOPE; KEEP SEARCHING\n         ERASE RPL=(@RPL3)         YES; ERASE THE RECORD\n         LTR   R15,R15             ERASE OK ??\n         BNZ   1(,R15)             NOPE; DIE HORRIBLY\n         B     ER7                 AND CONTINUE ---\nER8      DS    0H\n         MODCB RPL=(@RPL3),                                            X\n               ARG=(8),                                                X\n               OPTCD=(MVE,KEQ,DIR,UPD,GEN),                            X\n               KEYLEN=45,                                              X\n               MF=(G,GENWK)\n         MVI   0(R8),#RTHDR        SET FOR HEADER RECORD\nER9      DS    0H\n         GET   RPL=(@RPL3)         READ A RECORD\n         LTR   R15,R15             DID WE GET A RECORD ??\n         BNZ   ER10                NOPE ---\n         ERASE RPL=(@RPL3)         YES; ERASE THE RECORD\n         LTR   R15,R15             ERASE OK ??\n         BNZ   1(,R15)             NOPE; DIE HORRIBLY\n         B     ER9                 AND CONTINUE ---\nER10     DS    0H\n         ENDREQ RPL=(@RPL3)\n         MODCB RPL=(@RPL3),                                            X\n               OPTCD=(MVE,KEQ,DIR,NUP,FKS),                            X\n               MF=(G,GENWK)\n         L     R13,4(,R13)         LOAD BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ALWAYS RETURN CODE OF ZERO\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\n         LTORG\n         COPY  #RECS\n         COPY  ##ARCHWK\n         DROP  @BUF3,R11,R12\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHERRM": {"ttr": 4617, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x009\\x009\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 57, "newlines": 57, "modlines": 0, "user": "ARCHIVR"}, "text": "ERRM     TITLE 'ARCHIVER --- ERROR MESSAGE SELECTION AND PRINTING '\n*---------------------------------------------------------------------*\n*---     (C) COPYRIGHT 1989, RICHARD A. FOCHTMAN JR., WOODRIDGE,   ---*\n*---           ILLINOIS                                            ---*\n*---                                                               ---*\n*---     THIS SUBROUTINE SELECTS THE CHOSEN ERROR MESSAGE FROM     ---*\n*---     THE DATA CSECT ARCHMSGS AND PRINTS IT.  MESSAGE           ---*\n*---     SELECTION IS VIA A SIMPLE MULTIPLE-AND-INDEX ALGORITHM,   ---*\n*---     USING THE MESSAGE TEXT LENGTH AND THE MESSAGE NUMBER IN   ---*\n*---     R0 AS FACTORS TO INDEX INTO THE DATA CSECT ARCHMSGS.      ---*\n*---                                                               ---*\n*---     PROGRAM ATTRIBUTES: NON-REENTRANT, NON-REUSABLE,          ---*\n*---           NON-REFRESHABLE.                                    ---*\n*---------------------------------------------------------------------*\nARCHERRM CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n         USING ARCHERRM,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             LOAD ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHERRM,R11        DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             LOAD NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RELOAD BACK POINTER\n         L     R14,12(,R14)        RELOAD ORIG. REG 14\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         BCTR  R0,R0               DECREMENT MESSAGE NUMBER BY ONE\n         MH    R0,=H'133'          INDEX VALUE\n         L     R2,=V(ARCHMSGS)     POINT TO THE CSECT\n         AR    R2,R0               POINT TO THE MESSAGE\n         #PUT  (2)                 PRINT THE MESSAGE\n         L     R13,4(,R13)         POINT TO PREVIOUS S.A.\n         LM    R14,R12,12(R13)     RESTORE ENTRY REGISTERS\n         LA    R15,0               SET ZERO RETURN CODE\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO ARCHCTL\n         LTORG ,                   DISPLAY THE LITERALS SO FAR\n         COPY  ##ARCHWK\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHEXPR": {"ttr": 4619, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x01\\x00X\\x00\\x99'\\x0f\\x01\\x02#\\x1f\\tX\\x01\\xf0\\x01\\xf0\\x00\\x00\\xd4\\xd4\\xe2\\xd4\\xc1\\xd2@@@@\"", "ispf": {"version": "06.01", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "2002-08-19T09:58:58", "lines": 496, "newlines": 496, "modlines": 0, "user": "MMSMAK"}, "text": "EXPR     TITLE 'ARCHIVER --- EXPORT FUNCTION'\nARCHEXPR CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n@RPL1    EQU   R2                  SOME\n@RPL2    EQU   R3                    SPECIAL\n@RPL3    EQU   R4                      EQUATES\n@BUF1    EQU   R5                        FOR\n@BUF2    EQU   R6                          VSAM\n@BUF3    EQU   R7                            I/O MGMT\n         COPY #ARCBITS\n         USING ARCHEXPR,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             EXPORT ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHEXPR,R11        DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             LOAD NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RELOAD BACK POINTER\n         L     R14,12(,R14)        RELOAD ORIG. REG 14\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         XC    TOKEN,TOKEN         INITIAL CPPB POINTER\n         XC    FCOUNT,FCOUNT       CLEAR FUNCTION RECORD COUNT\n         XC    MCNT,MCNT           AND MEMBER COUNT\n         XC    ACNT,ACNT           AND ALIAS COUNT\n         MVC   VS1MODE,=CL8'INPUT' SET THE I/O MODE\n         LA    R1,VSAM1DD          LOAD THE PARM POINTER\n         LA    R0,0                AND THE 'OPEN' FLAG\n         CALL  ARCHVSOP            CALL THE 'OPEN' FUNCTION\n         LTR   R15,R15             OPEN OK ??\n         BNZ   ENDITALL            NOPE; CAN'T WORK\n*---------------------------------------------------------------------*\n*---     NOW OPEN THE INPUT NON-VSAM DATASET.                      ---*\n*---------------------------------------------------------------------*\n         BAL   R14,OPNVO           CALL THE OPEN ROUTINE\n*---------------------------------------------------------------------*\n*---     OUR FIRST RECORD IS A SPECIAL RECORD GIVING THE ORIGINAL  ---*\n*---     VSAM CLUSTER'S MAXIMUM RECORD LENGTH.  NEEDED FOR IMPORT. ---*\n*---------------------------------------------------------------------*\n         XC    GENWK(16),GENWK     CLEAR RECORD CONSTRUCTION AREA\n         MVC   GENWK(4),=C'SIZE'   KEYWORD FOR LOCATING THIS RECORD\n         MVC   GENWK+4(4),VS1LIM   COPY THE VSAM MAX RCD LENGTH\n         LA    R1,GENWK            POINT TO THE RECORD\n         LA    R0,8                AND LOAD ITS SIZE\n         BAL   R14,PUT             AND OUTPUT THE RECORD\n         EJECT\n*---------------------------------------------------------------------*\n*---     HERE'S THE MEAT OF THE PROCESSING. THE BASIC PROCESS IS   ---*\n*---           THIS:                                               ---*\n*---                                                               ---*\n*---     1. USING THE CONTROL INFORMATION WE WERE GIVEN AND THE    ---*\n*---        INFORMATION WE'VE DEVELOPED, LOCATE THE HEADER RECORD  ---*\n*---        FOR THE FIRST MEMBER. WE'LL USE THE VS1BUF2 AREA FOR   ---*\n*---        HEADER/KEY CONSTRUCTION.                               ---*\n*---                                                               ---*\n*---     2. LOOP THROUGH THE MEMBER, READING THE RECORDS AND       ---*\n*---        WRITING THEM TO THE NON-VSAM DATASET.  SINCE WE'RE     ---*\n*---        USING QSAM FOR THE I/O, THE MECHANICS OF BLOCKING      ---*\n*---        AND ASYNCHRONOUS PROCESSING ARE UNNEEDED HERE.         ---*\n*---------------------------------------------------------------------*\n         L     @RPL1,RPL1          POINT TO THE\n         L     @RPL2,RPL2            RPL'S\n         L     @RPL3,RPL3              AND\n         L     @BUF1,VS1BUF1       BUFFER\n         L     @BUF2,VS1BUF2         STORAGE\n         L     @BUF3,VS1BUF3           AREAS\n         XC    BLDLAREA,BLDLAREA   CLEAR THE QUALIFIER SAVE AREA\n         LA    @BUF2,4(,@BUF2)     SPACE FOR\n         LA    @BUF3,4(,@BUF3)       VBS RDW'S\n         USING REC,@BUF1           BASE THE RECORD DSECT\n         XC    0(RECKLEN,@BUF1),0(@BUF1)   START AT THE BEGINNING !!\n         MVI   RECTT,#RTHDR        START WITH HEADERS\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN),                                X\n               ACB=(*,ACB1),                                           X\n               ARG=(@BUF1),                                            X\n               AREA=(@BUF1),                                           X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         POINT RPL=(@RPL1)         GET TO IT\nNEXTHDR  DS    0H\n         GET   RPL=(@RPL1)         AND READ A HEADER RECORD\n         SHOWCB RPL=(@RPL1),                                           X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,VS1LEN1),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\n         #IF   RETA,ON,CHKALIAS    CHECK ALIAS NAMES, TOO ---\n         #IF   RSRALIAS,ON,NEXTHDR SKIP ALIAS, FOR NOW\nCHKALIAS DS    0H\n         LA    R1,RECN             POINT TO THE HEADER\n         LA    R0,0                USE DEFAULT QUALIFIER DATA\n         CALL  ARCHKNAM            GO CHECK: DO WE PROCESS THIS ITEM ??\n         LTR   R15,R15             PASS THE CHECK ??\n         BNZ   NEXTHDR             NOPE ---\n         MVC   0(49,@BUF2),0(@BUF1) COPY KEY TO BUFFER 2\n         #IF   RSRALIAS,OFF,NX1    SCOOT ---\n         MVC   1(44,@BUF2),RECAN   COPY 'REAL' QUALIFIERS\nNX1      DS    0H\n         MODCB RPL=(@RPL2),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN),                                X\n               ACB=(*,ACB1),                                           X\n               ARG=(@BUF2),                                            X\n               AREA=(@BUF2),                                           X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         POINT RPL=(@RPL2)         RE-POSITION\n         GET   RPL=(@RPL2)         READ THE 'REAL' HEADER\n         SHOWCB RPL=(@RPL2),                                           X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,VS1LEN2),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\n         DROP  @BUF1\n         USING REC,@BUF2           RE-BASE THE DSECT\nNOTA     DS    0H\n         LA    R1,RECN             POINT TO FIRST QUALIFIER\n         BAL   R14,CHKCHN          IS IT DONE ALREADY ??\n         LTR   R15,R15             MAYBE ---\n         BNZ   NEXTHDR             YES; SKIP THIS ATTEMPT\n         BAL   R14,CHAINER         ADD IT TO THE CHAIN\n         LA    R1,RECTT            POINT TO THE HEADER RECORD AGAIN\n         L     R0,VS1LEN2          LOAD THE RECORD LENGTH\n         BAL   R14,PUT             GO WRITE A LOGICAL RECORD\n*---------------------------------------------------------------------*\n*---     NOW LOCATE AND EXPORT ANY ALIASES                         ---*\n*---------------------------------------------------------------------*\n         XC    0(RECKLEN,@BUF3),0(@BUF3) CLEAR THE KEY AREA\n         MODCB RPL=(@RPL3),AREA=(@BUF3),ARG=(@BUF3),                   X\n               OPTCD=(SEQ,FKS,KGE,SYN),                                X\n               AREALEN=(*,VS1LIM),MF=(G,GENWK)\n         #IF   RETA,OFF,GETB       DON'T EXPORT ALIASES\n         #IF   RSRHALS,OFF,GETB    HAS NO ALIASES -----\n         POINT RPL=(@RPL3)         POSITION TO START\nGETA     DS    0H\n         GET   RPL=(@RPL3)         READ A RECORD\n         DROP  @BUF2\n         USING REC,@BUF3\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   GETB                NOPE; ALL DONE\n         #IF   RSRALIAS,OFF,GETA   NOT AN ALIAS; SKIP IT\n         CLC   RECAN(44),1(@BUF2)  ALIAS FOR CURRENT ITEM ??\n         BNE   GETA                NOPE ---\n         SHOWCB  RPL=(@RPL3),FIELDS=RECLEN,AREA=(S,VS1LEN3),           X\n               LENGTH=4,MF=(G,GENWK)\n         LA    R1,0(,@BUF3)        COPY RECORD ADDRESS\n         L     R0,VS1LEN3          AND ITS LENGTH\n         BAL   R14,PUT             GO OUTPUT THE RECORD\n         L     R15,ACNT            LOAD ALIAS COUNT\n         LA    R15,1(,R15)         INCREMENT BY ONE\n         ST    R15,ACNT            AND SAVE THE RESULT\n         #FORMAT RECTT,,AEXPRTD\n         #PUT  LINE                OUTPUT 'ALIAS EXPORTED' MESSAGE\n         B     GETA                AND CONTINUE ---\nGETB     DS    0H\n*---------------------------------------------------------------------*\n*---     NOW DO ANY NOTE RECORDS                                   ---*\n*---------------------------------------------------------------------*\n         MVC   0(49,@BUF3),0(@BUF2) RESET TO 'REAL' KEY\n         MVI   RECTT,#RTNOTE       RESET TO NOTE TYPE\n         POINT RPL=(@RPL3)         GET TO IT\nLDLOOP   DS    0H\n         GET   RPL=(@RPL3)         GO READ A MEMBER NOTE RECORD\n         LTR   R15,R15             DID IT COMPLETE OK ??\n         BNZ   LDDONE              NOPE; ASSUME WE'RE DONE\n         SHOWCB RPL=(@RPL3),                                           X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,VS1LEN3),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\n         CLI   RECTT,#RTNOTE       DATA RECORD ??\n         BNE   LDDONE\n         CLC   1(RECKLEN-5,@BUF3),1(@BUF2) STILL IN THE RIGHT ITEM ??\n         BNE   LDDONE              NOPE; DO STOWS 'N' STUFF\n         LR    R1,@BUF3            COPY RECORD ADDRESS\n         L     R0,VS1LEN3          LOAD RECORD LENGTH\n         BAL   R14,PUT             OUTPUT THE RECORD\n         B     LDLOOP              NOPE ---\nLDDONE   DS    0H\n         MVC   0(RECKLEN,@BUF3),0(@BUF2) COPY THAT KEY\n         MVI   RECTT,#RTDATA       RESET TO DATA TYPE\n         XC    RECSEQ#,RECSEQ#     RESET THE SEQUENCE NUMBER\n         POINT RPL=(@RPL3)         GET TO IT\nDATALP   DS    0H\n         GET   RPL=(@RPL3)         GO READ A MEMBER DATA RECORD\n         LTR   R15,R15             DID IT COMPLETE OK ??\n         BNZ   DATADN              NOPE; ASSUME WE'RE DONE\n         CLI   RECTT,#RTDATA       DATA RECORD ??\n         BNE   DATADN\n         CLC   1(44,@BUF2),1(@BUF3) STILL IN THE RIGHT ITEM ??\n         BNE   DATADN              NOPE; DO STOWS 'N' STUFF\n         SHOWCB RPL=(*,RPL3),                                          X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,VS1LEN3),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\n         LR    R1,@BUF3            COPY RECORD ADDRESS\n         L     R0,VS1LEN3          LOAD RECORD LENGTH\n         BAL   R14,PUT             OUTPUT THE RECORD\n         B     DATALP              NOPE ---\nDATADN   DS    0H\n         DROP  @BUF3\n         USING REC,@BUF2\n         #FORMAT RECTT,,EXPORTED\n         #PUT  LINE\n         NC    BLDLAREA,BLDLAREA   WAS THERE A SAVED KEY ??\n         BZ    NORESTOR            NOPE ---\n         MVC   RECN(48),BLDLAREA   YES; RESTORE THE KEY\n         XC    BLDLAREA,BLDLAREA   RESET THE SAVE AREA\nNORESTOR DS    0H\n         L     R1,MCNT             LOAD MEMBER COUNT\n         AL    R1,=F'1'            INCREMENT BY ONE\n         ST    R1,MCNT             SAVE RESULTS\n         DROP  @BUF2\n         #IF   GENM,ON,NEXTHDR     LOOP IF GENERIC NAME\n         #IF   GENG,ON,NEXTHDR     LOOP IF GENERIC GROUP\n         #IF   GENSG,ON,NEXTHDR    LOOP IF GENERIC SUBGROUP\n         #IF   GENT,ON,NEXTHDR     LOOP IF GENERIC TYPE\nENDITALL DS    0H\n         L     R0,MCNT             EXPORT MEMBER COUNT\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,MCMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\n         L     R0,ACNT             EXPORT MEMBER COUNT\n         LTR   R0,R0               NO ALIASES ??\n         BZ    END1                NOPE ---\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,ACMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\nEND1     DS    0H\n         CLC   ACB1,=F'0'          WAS ACB EVER OPENED ??\n         BE    NOACB               NOPE ---\n         LA    R1,VSAM1DD          POINT TO THE DDNAME\n         LA    R0,4                SET 'CLOSE' REQUEST\n         CALL  ARCHVSOP            CALL THE VSAM 'CLOSE' ROUTINE\nNOACB    DS    0H\n         BAL   R14,NVSCLOSE        GO CLOSE THE INPUT FILE\n         NC    TOKEN,TOKEN         IS THERE A Q'CELL POOL ??\n         BZ    NOPOOL              NOPE ---\n         L     R0,TOKEN            LOAD CPPB POINTER\n         CALL  CELLDEL             GO DELETE THE ENTIRE POOL\n         XC    TOKEN,TOKEN\nNOPOOL   DS    0H\n         L     R13,4(,R13)         EXPORT BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ALWAYS RC = 0\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\n         TITLE 'OPEN NONVSAM OUTPUT DATASET '\n*---------------------------------------------------------------------*\n*---     THIS LOCAL SUBROUTINE SERVES ONLY ONE PURPOSE: TO OPEN    ---*\n*---     THE EXPORT DATASET.  SINCE QSAM I/O IS USED FOR THE       ---*\n*---     OUTPUT OF THE EXPORT FUNCTION, WE CAN DISREGARD ANY       ---*\n*---     SPECIAL CONSIDERATIONS FOR DEBLOCKING AND REBLOCKING.     ---*\n*---     SIMILARLY, WE CAN IGNORE ANY FANCY BUFFER MANAGEMENT      ---*\n*---     CONSIDERATIONS.  WE ASSUME HERE THAT ANY DEVICE THAT      ---*\n*---     SUPPORTS VARIABLE SPANNED RECORDS IS ACCEPTABLE, EVEN     ---*\n*---     THOUGH IT MAY BE NONSENSICAL.  FOR EXAMPLE, A CARD PUNCH  ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nOPNVO    DS    0H\n         STM   R14,R12,IOSAVE      SAVE THE ENTRY REGISTERS\n*---\n*---     BUILD A DCB, TO START, FOR DSORG CHECKING\n*---\n         GETMAIN R,LV=QSDCBL,SP=11 GRAB STORAGE FOR BPAM DCB\n         ST    R1,NDCBA            AND STORE ADDRESS IN ARCHIVWA\n         MVI   NDCBA,X'80'         BUILD OPEN PARM LIST\n         MVC   0(QSDCBL,R1),QSDCB  COPY DCB TO DYNAMIC AREA\n         USING IHADCB,R1           BASE THE DCB DSECT\n         MVC   DCBDDNAM,EXPTPDD    MOVE IN THE DDNAME\n         DROP  R1\n*---\n*---     SEARCH THE TIOT FOR THE DDNAME\n*---\n         L     R1,TIOTA            EXPORT TIOT ELEMENT POINTER\nOPNVO2   DS    0H\n         CLI   0(R1),0             AT TIOT END ??\n         BE    NODDERR             YES; DD STATEMENT IS MISSING\n         CLC   EXPTPDD,4(R1)       IS THIS THE DD ENTRY ??\n         BE    OPNVO3              YES; GO FETCH UCB ADDR\n         IC    R0,0(,R1)           INSERT TIOE LENGTH\n         N     R0,=F'255'          TRIM TO JUST THE LENGTH\n         AR    R1,R0               BUMP TO NEXT ENTRY\n         B     OPNVO2              AND CONTINUE THE SEARCH\nOPNVO3   DS    0H\n*---\n*---     PROCEED WITH THE NECESSARY OPEN, ETC.\n*---\n         OPEN  (,OUTPUT),MF=(E,NDCBA) OPEN THE DCB\nOPNVO12  DS    0H\n         L     R0,=F'32768'        EXPORT COMPRESS MAX LENGTH\n         ICM   R0,8,=AL1(10)       INSERT SUBPOOL NUMBER\n         GETMAIN R,LV=(0)\n         STM   R0,R1,CMPWRKL       STORE COMPRESS WORK-AREA ADDRESS\n         LM    R14,R12,IOSAVE      REEXPORT ENTRY REGISTERS\n         BR    R14                 AND RETURN TO LOCAL CALLER\n*---\n*---     THIS IS A SHORT AND SNEAKY DCB COMPLETION EXIT. ITS ONLY\n*---     PURPOSE IS TO ESTABLISH THE BLKSIZE FOR THE PRIMARY\n*---     DCB.\n*---\nOPNVO13  DS    0F\n         DC    XL1'85',AL3(OPNVO13+4)\n         USING IHADCB,R1\n         NC    DCBBLKSI,DCBBLKSI   BLKSIZE DEFINED ??\n         BNZR  R14                 YES ---\n         MVC   DCBBLKSI,=H'32760'  DEFAULT BLKSIZE\n         BR    R14                 AND RETURN TO O/C/EOV\n         DROP  R1\n         TITLE 'QSAM CLOSE ROUTINE'\n*---------------------------------------------------------------------*\n*---     THIS LITTLE ROUTINE CLOSES THE NONVSAM DATASET,           ---*\n*---     RELEASES ALL BUFFER POOLS, RESETS POINTER VALUES,         ---*\n*---     ETC.                                                      ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nNVSCLOSE DS    0H\n         STM   R14,R12,IOSAVE      SAVE THE ENTRY REGISTERS\n         L     R2,NDCBA            EXPORT PRIMARY DCB ADDRESS\n         LA    R2,0(,R2)           PURIFY THE ADDRESS\nNVSCX    DS    0H\n         LTR   R2,R2               ZERO ??\n         BZ    NVC1                YES; NO DCB HERE ---\n         TM    48(R2),X'10'        IS IT OPEN ??\n         BZ    NVCA                NOPE ---\n         CLOSE MF=(E,NDCBA)        CLOSE THE DCB\nNVCA     DS    0H\n         #FREE (2)                 RELEASE BUFFER POOL, IF ANY\n         XC    NDCBA,NDCBA         AND RESET THE POINTER FIELD\nNVC1     DS    0H\n         LM    R14,R12,IOSAVE      RESTORE THE REGISTERS\n         BR    R14                 AND RETURN TO CALLER\n         TITLE 'QSAM PUT ROUTINES '\n*---------------------------------------------------------------------*\n*---     REGS AT ENTRY:                                            ---*\n*---              R0 ::= LOGICAL RECORD LENGTH                     ---*\n*---              R1 --> LOGICAL RECORD                            ---*\n*---              R14 -> RETURN ADDRESS                            ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nPUT      DS    0H\n         STM   R14,R12,IOSAVE      SAVE INPUT REGISTERS\n         L     R9,NDCBA            EXPORT DCB ADDRESS\n         USING IHADCB,R9           AND BASE ITS DSECT\n         LR    R2,R1               AND ADDRESS\n         AH    R0,=H'4'            ACCOUNT FOR RDW AREA\n         SLL   R0,16               BUILD A TRUE RDW\n         SH    R2,=H'4'            POINT TO RDW AREA\n         ST    R0,0(,R2)           ADD RDW TO THE RECORD\n         PUT   (9),(2)             AND WRITE THE RECORD\n         LM    R14,R12,IOSAVE      RESTORE CALLER'S REGISTERS\n         BR    R14                 RETURN ---\n         DROP  R9\n*---------------------------------------------------------------------*\n*---     SOME ERROR STUFF                                          ---*\n*---------------------------------------------------------------------*\nNODDERR  DS    0H\n         #PUT  ERR1\n         #PUT  ERR6\n         B     ENDITALL\nERR1     DC    CL133'0** ERROR *** THE DD STATEMENT FOR THE REQUIRED NOX\n               N-VSAM DATASET IS MISSING.'\nERR6     DC    CL133'0*** ERROR *** THIS CONTROL STATEMENT WILL BE IGNOX\n               RED.'\n*---------------------------------------------------------------------*\n*---     THIS ROUTINE WILL ADD THE 'REAL' NAME WE JUST EXPORTED    ---*\n*---     TO A CHAIN OF REAL NAMES IN STORAGE.  THE CHAIN IS        ---*\n*---     'ROOTED' IN THE 'COUNT' FIELD OF THE ARCHIVER'S MAIN      ---*\n*---     WORK AREA.  THE PURPOSE OF THIS CHAIN IS TO PREVENT       ---*\n*---     EXPORTING THE SAME ITEM MULTIPLE TIMES IF IT HAS          ---*\n*---     MULTIPLE ALIASES AND WE'RE EXPORTING BASED ON ALIAS       ---*\n*---     CHECKS AS WELL AS REAL NAME CHECKS.                       ---*\n*---                                                               ---*\n*---     REGISTER 1 IS ASSUMED TO POINT TO THE 44-BYTE QUALIFIER   ---*\n*---     DATA TO BE ADDED TO THE CHAIN.                            ---*\n*---------------------------------------------------------------------*\nCHAINER  DS    0H\n         STM   R14,R12,IOSAVE      SAVE THE ENTRY REGISTERS\n         LR    R2,R1               COPY THE DATA POINTER\n         NC    TOKEN,TOKEN         IS CELL POOL INIT'D ??\n         BNZ   CHAIN1              YES ---\n         CNOP  0,4\n         BAL   R1,BLDPOOL          BRANCH AROUND PARM LIST\n         DC    F'100'\n         DC    F'100'\n         DC    F'48'\n         DC    AL1(14)\n         DC    AL1(20)\n         DC    CL20'EXPORTED REAL ITEMS'\nBLDPOOL  DS    0H\n         CALL  CELLBLD\n         ST    R0,TOKEN            SAVE THE 'TOKEN' VALUE\nCHAIN1   DS    0H\n         L     R0,TOKEN            LOAD THE TOKEN VALUE\n         CALL  CELLGET             GO GET A QUICKCELL\n         XC    0(48,R1),0(R1)      CLEAR IT OUT\n         MVC   0(4,R1),CHAIN       INSERT INTO THE\n         ST    R1,CHAIN              CHAIN\n         MVC   4(44,R1),0(R2)      COPY DATA INTO THE CHAIN\n         LM    R14,R12,IOSAVE      RESTORE THE REGISTERS\n         LA    R15,0               ZERO RETURN CODE\n         BR    R14                 AND RETURN TO MY CALLER\n         EJECT\n*---------------------------------------------------------------------*\n*---     THIS ROUTINE CHECKS THROUGH THE CHAIN BUILT BY 'CHAIN'    ---*\n*---     TO SEE IF WE'VE ALREADY PROCESSED THE ITEM WHOSE          ---*\n*---     QUALIFIERS ARE POINTED TO BY REGISTER 1.  IF A MATCH IS   ---*\n*---     FOUND, A RETURN CODE OF 4 IS SET IN REGISTER 15, ELSE     ---*\n*---     THE RETURN CODE IS ZERO.                                  ---*\n*---------------------------------------------------------------------*\nCHKCHN   DS    0H\n         STM   R14,R2,IOSAVE       SAVE THE ENTRY REGISTERS\n         MVC   IOSAVE+4(4),=F'4'   SET INITIAL RETURN CODE\n         L     R2,CHAIN            LOAD THE FIRST LINK POINTER\n         B     CHKCHN2             AND GO CHECK FOR ANY LINK\nCHKCHN1  DS    0H\n         CLC   4(44,R2),0(R1)      DOES IT MATCH ??\n         BE    CHKCHN3             YES; ERROR RETURN CODE\n         L     R2,0(,R2)           POINT TO NEXT LINK\nCHKCHN2  DS    0H\n         LTR   R2,R2               ANOTHER LINK ??\n         BNZ   CHKCHN1             YES ---\n         XC    IOSAVE+4(4),IOSAVE+4  NOPE; SET ZERO RETURN CODE\nCHKCHN3  DS    0H\n         LM    R14,R2,IOSAVE       RESTORE REGISTERS\n         BR    R14                 AND RETURN TO CALLER\nTCMSG    DC    CL133' '\n         ORG   TCMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202120'\n         DC    C' TOTAL LOGICAL RECORDS PROCESSED.'\n         ORG\nMCMSG    DC    CL133' '\n         ORG   MCMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202120'\n         DC    C' TOTAL MEMBERS PROCESSED.'\n         ORG\nACMSG    DC    CL133' '\n         ORG   ACMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202120'\n         DC    C' TOTAL ALIAS(ES) PROCESSED.'\n         ORG\n         LTORG\nAEXPRTD  DC    AL1(AEXE-AEXS)\nAEXS     DC    C' (ALIAS) SUCCESSFULLY EXPORTED.'\nAEXE     EQU   *\nEXPORTED DC    AL1(LDMSGE-LDMSG)\nLDMSG    DC    C' SUCCESSFULLY EXPORTED.'\nLDMSGE   EQU   *\nMINREC   DC    A(RECSIZE)\nE1       DC    X'85',AL3(E1+4)\n         USING IHADCB,R1\n         CLC   DCBBLKSI,=H'0'      BLKSIZE MISSING ??\n         BNER  R14                 NOPE ---\n         MVC   DCBBLKSI,=H'32000'  YES; INSERT A DEFAULT\n         BR    R14\n         DROP  R1\nQSDCB    DCB   DSORG=PS,MACRF=PM,RECFM=VBS,LRECL=32760,EXLST=OPNVO13\nQSDCBL   EQU   *-QSDCB\n         DCBD  DSORG=(PS)\n         COPY  #RECS\n         COPY  ##ARCHWK\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHFORM": {"ttr": 4872, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00f\\x00f\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 102, "newlines": 102, "modlines": 0, "user": "ARCHIVR"}, "text": "FORM     TITLE 'ARCHFORM --- ARCHIVER FUNCTION SUPPORT SUBROUTINE'\n*---------------------------------------------------------------------*\n*---     FUNCTION: FORMAT ALL MESSAGES INTO 'LINE' FOR THE         ---*\n*---           PRINTING PROCESS.  ANY MESSAGE WHICH CONTAINS       ---*\n*---           ITEM DESCRIPTORS ARE FORMATTED BY THIS ROUTINE.     ---*\n*---                                                               ---*\n*---     THIS ROUTINE IS INVOKED EXCLUSIVELY VIA #FORMAT MACRO.    ---*\n*---                                                               ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nARCHFORM CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n         USING ARCHFORM,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             LOAD ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHFORM,R11        DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             LOAD NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RELOAD BACK POINTER\n         L     R14,12(,R14)        RELOAD ORIG. REG 14\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         LA    R15,0               CLEAR A WORK REGISTER\n         ICM   R15,3,8(R14)        INSERT THE S-CON\n         SRL   R15,12              SHIFT OFF THE OFFSET VALUE\n         O     R15,LR-2            GET THE REST ---\n         EX    R15,LR              COPY THE S-CON'S REGISTER\n         LA    R15,0               RE-CLEAR THE REGISTER\n         ICM   R15,3,8(R14)        RELOAD THE S-CON\n         N     R15,=A(X'FFF')      TRIM TO SIMPLE OFFSET\n         AR    R2,R15              POINT TO ACTUAL OUTPUT AREA\n         CLC   0(8,R14),=CL8' '    IS THERE A MESSAGE NUMBER ??\n         BE    FMT1                NOPE ---\n         MVC   0(8,R2),0(R14)      MOVE MESSAGE NUMBER TO LINE\n         LA    R2,9(,R2)           INCREMENT TRAVELING CURSOR PAST IT\nFMT1     DS    0H\n         LR    R3,R0               COPY DESCRIPTOR ADDRESS\n         USING REC,R3              AND BASE ITS DSECT\n         MVI   0(R2),C'-'\n         LA    R2,1(,R2)\n         MVC   0(10,R2),RECN       MOVE THE NAME OVER\n         MVI   10(R2),C'-'         AND FIELD SEPARATOR\n         LA    R2,11(,R2)          INCREMENT TRAVELING POINTER\n         MVC   0(10,R2),RECG       MOVE THE GROUP OVER\n         MVI   10(R2),C'-'         AND FIELD SEPARATOR\n         LA    R2,11(,R2)          INCREMENT TRAVELING POINTER\n         MVC   0(10,R2),RECSG      MOVE THE SUBGROUP OVER\n         MVI   10(R2),C'-'         AND FIELD SEPARATOR\n         LA    R2,11(,R2)          INCREMENT TRAVELING POINTER\n         MVC   0(10,R2),RECT       MOVE THE TYPE OVER\n         MVI   10(R2),C'-'         AND FIELD SEPARATOR\n         LA    R2,11(,R2)          INCREMENT TRAVELING POINTER\n         ICM   R0,15,RECVER        INSERT THE VERSION\n         X     R0,=F'-1'           INVERT ALL BITS\n         CVD   R0,DWORK            AND DECIMALIZE IT\n         OI    DWORK+7,X'0F'       FORST LAST SIGN NUMERIC\n         MVC   0(12,R2),FMT4       MOVE IN THE EDIT MASK\n         ED    0(12,R2),DWORK+3    EDIT IN THE VERSION NUMBER\n         LA    R2,13(,R2)          POINT PAST IT\n         LTR   R1,R1               IS THERE A MESSAGE ??\n         BZ    FMT2                NOPE ---\n         LA    R7,0                CLEAR THE REGISTER\n         IC    R7,0(,R1)           INSERT ITS LENGTH\n         BCTR  R7,R0               DECREMENT BY ONE\n         EX    R7,FMT3             NOVE TEXT INTO LINE\n         LA    R2,2(R7,R2)         BUMP CURSOR PAST IT\nFMT2     DS    0H\n         LR    R0,R2               SET RETURN VALUE\n         L     R13,4(,R13)\n         L     R14,12(,R13)\n         LM    R2,R12,28(R13)\n         LA    R15,0\n         MVI   12(R13),255\n         B     10(,R14)\nFMT3     MVC   0(0,R2),1(R1)       ACTUAL TEXT MOVE\n         DROP  R3\n         LTORG\nFMT4     DC    C' ',X'202020',C',',X'202020',C',',X'202020'\n         CNOP  2,4\nLR       LR    R2,R0               'EX'ED WHILE CONVERTING THE S-CON\n         LTORG\n         COPY #RECS\n         COPY ##ARCHWK\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHIMPR": {"ttr": 4875, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x02d\\x02d\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 612, "newlines": 612, "modlines": 0, "user": "ARCHIVR"}, "text": "IMPR     TITLE 'ARCHIVER --- IMPORT FUNCTION'\n*---------------------------------------------------------------------*\n*---     THIS IS THE 'IMPORT' FUNCTION OF THE ARCHIVER. TWO        ---*\n*---     'FLAVORS' ARE AVAILABLE.  EITHER THE USER ELECTS TO       ---*\n*---     RESTORE ALIAS INFORMATION OR NOT.  IF ALIASES ARE         ---*\n*---     RETAINED, THEY ARE ALSO CHECKED FOR VALID NAMES FOR       ---*\n*---     IMPORT.  THIS ROUTINE WAS HEAVILY REWORKED FOR VERSION    ---*\n*---     4.1 AND IS STILL NOT COMPLETELY SATISFACTORY TO ME.  I'D  ---*\n*---     STILL LIKE TO REWORK THIS FUNCTION AGAIN BUT I'M MORE     ---*\n*---     INTERESTED IN GETTING THE BASIC FUNCTIONS OUT FOR THE     ---*\n*---     TIME BEING.                                               ---*\n*---------------------------------------------------------------------*\nARCHIMPR CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n@RPL1    EQU   R2                  SOME\n@RPL2    EQU   R3                    SPECIAL\n@RPL3    EQU   R4                      EQUATES\n@BUF1    EQU   R5                        FOR\n@BUF2    EQU   R6                          VSAM\n@BUF3    EQU   R7                            I/O MGMT\n         COPY #ARCBITS\n         USING ARCHIMPR,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             LOAD ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHIMPR,R11        DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             LOAD NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RELOAD BACK POINTER\n         L     R14,12(,R14)        RELOAD ORIG. REG 14\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         XC    FCOUNT,FCOUNT       CLEAR FUNCTION RECORD COUNT\n         XC    MCNT,MCNT           AND MEMBER COUNT\n         XC    ACNT,ACNT           AND ALIAS COUNT\n         XC    CHAIN,CHAIN         CLEAR THE CHAIN POINTER FIELD\n         BAL   R14,OPNVI           GO OPEN THE NONVSAM INPUT DATASET\n         LTR   R15,R15             WAS IT OPENED OK ??\n         BZ    NVSOK               YES ---\n         B     ENDITALL            AND GO TERMINATE\nNVSOK    DS    0H\n         MVC   VS1MODE,=CL8'OUTPUT' SET THE I/O MODE\n         LA    R1,VSAM1DD          LOAD THE PARM POINTER\n         LA    R0,0                AND THE 'OPEN' FLAG\n         CALL  ARCHVSOP            CALL THE 'OPEN' FUNCTION\n         LTR   R15,R15             OPEN OK ??\n         BNZ   ENDITALL            NOPE; CAN'T WORK\n*---------------------------------------------------------------------*\n*---     SINCE WE MAY BE USING THE CONTENTS OF EXPORTED ALIAS      ---*\n*---     RECORDS TO DETERMINE WHETHER THIS ITEM SHOULD BE          ---*\n*---     RESTORED, WE'LL SAVE ALL THE HEADER AND ALIAS RECORDS     ---*\n*---     FOR EACH ITEM UNTIL WE DETERMINE THAT THIS ITEM WILL NOT  ---*\n*---     BE PROCESSED.  TO AVOID REPETITIVE GETMAIN/FREEMAIN       ---*\n*---     CALLS, WE'LL USE A SERIES OF 'QUICKCELLS' TO TRY AND      ---*\n*---     HASTEN, AND EASE, THE STORAGE MANAGEMENT HEADACHES.  THE  ---*\n*---     STUFF WE SAVE WILL BE IN THE FORM OF A SINGLY-LINKED      ---*\n*---     LIST, WITH THE 'REAL' HEADER AS THE FIRST ITEM IN THE     ---*\n*---     LIST, FOLLOWED BY THE ALIAS HEADERS.                      ---*\n*---------------------------------------------------------------------*\n         CNOP  0,4\n         BAL   R1,BLDPOOL          BRANCH AROUND PARM LIST\n         DC    F'100'\n         DC    F'100'\n         DC    F'256'\n         DC    AL1(15)\n         DC    AL1(20)\n         DC    CL20'HEADERS AND ALIASES'\nBLDPOOL  DS    0H\n         CALL  CELLBLD\n         ST    R0,COUNT            SAVE THE 'TOKEN' VALUE\n         EJECT\n*---------------------------------------------------------------------*\n*---     HERE'S THE MEAT OF THE PROCESSING. THE BASIC PROCESS IS   ---*\n*---           THIS:                                               ---*\n*---                                                               ---*\n*---     1. USING THE CONTROL INFORMATION WE WERE GIVEN AND THE    ---*\n*---        INFORMATION WE'VE DEVELOPED, READ THE NONVSAM DATASET  ---*\n*---        UNTIL WE FIND A HEADER WE SHOULD PROCESS.  DURING THE  ---*\n*---        SEARCH, ALSO LOCATE THE 'SIZE' RECORDS AND LOAD THE    ---*\n*---        SIZE VALUE INTO A REGISTER FOR LATER REFERENCE.        ---*\n*---                                                               ---*\n*---        WHEN WE FIND AN ITEM THAT IS TO BE PROCESSED, WE       ---*\n*---        COMPARE THE 'SIZE' VALUE WITH THE MAXIMUM RECORD SIZE  ---*\n*---        OF THE OUTPUT CLUSTER.  IF THE ITEM TO BE IMPORTED     ---*\n*---        WILL FIT, WE GO AHEAD AND DO THE IMPORT.  IF NOT, WE   ---*\n*---        GENERATE AN ERROR MESSAGE, GIVING THE REQUIRED SIZE,   ---*\n*---        AND IGNORE THE ITEM WE JUST FOUND.                     ---*\n*---------------------------------------------------------------------*\nMEMBERS  DS    0H\n*---------------------------------------------------------------------*\n*---     FIRST, LOAD ALL THE HEADER AND ALIAS RECORDS.             ---*\n*---------------------------------------------------------------------*\n         L     R1,NDCBA            LOAD NONVSAM DCB ADDRESS\n         GET   (1)                 READ A RECORD\n         ST    R1,IMPREC           SAVE THE RECORD POINTER\nGETD     DS    0H\n         L     R1,IMPREC           SAVE THE RECORD POINTER\n         LTR   R1,R1               IS THERE A RECORD PRESENT ??\n         BZ    ENDITALL            NOPE; ALL DONE\n         CLC   4(4,R1),=CL4'SIZE'  SIZE RECORD ??\n         BNE   GET1                NOPE ---\n         MVC   VS1LEN3,8(R1)       YES; SAVE FOR LATER REFERENCE\n         B     MEMBERS             AND KEEP SEARCHING ---\nGET1     DS    0H\n         LA    R7,4(,R1)           POINT TO THE DATA AREA\n         LH    R8,0(,R1)           LOAD THE RECORD LENGTH\n         SH    R8,=H'4'            ACCOUNT FOR RDW\n         CLI   0(R7),#RTHDR        IS THIS A HEADER RECORD ??\n         BNE   GET4                GO DO CHECK & STUFF\n         USING REC,R7              BASE THE RECORD DSECT\n         #IF   RSRALIAS,ON,GET1A   DIFFERENT TREATMENT FOR ALIASES\n         L     R2,VS1BUF3          LOAD VSAM BUFFER POINTER\n         LR    R3,R8               COPY RECORD LENGTH\n         ST    R3,VS1LEN3          SAVE LENGTH FOR LATER\n         LR    R14,R7              COPY RECORD POINTER\n         LR    R15,R8              AND LENGTH\n         MVCL  R2,R14              COPY TO VS1BUF3\n         B     MEMBERS             AND GO FOR ANOTHER RECORD\n         DROP  R7                  UN-BASE THE RECORD DSECT\nGET1A    DS    0H\n         L     R0,COUNT            LOAD THE TOKEN VALUE\n         CALL  CELLGET\n         XC    0(8,R1),0(R1)       CLEAR THE CELL HEADER AREA\n         ST    R8,4(,R1)           SAVE THE RECORD LENGTH\n         BCTR  R8,R0               DECREMENT LENGTH BY ONE\n         EX    R8,COPYHDR          COPY HEADER INTO CELL\n         LA    R2,CHAIN            POINT TO CHAIN START\nGET2     DS    0H\n         NC    0(4,R2),0(R2)       POINT TO LAST LINK ??\n         BNZ   GET3                NOPE; GO FOR NEXT LINK\n         ST    R1,0(,R2)           SAVE AS NEXT LINK\n         B     MEMBERS             GO FOR ANOTHER HEADER RECORD\nGET3     DS    0H\n         L     R2,0(,R2)           BUMP DOWN THE LIST\n         B     GET2                AND CONTINUE SEARCHING\nCOPYHDR  MVC   8(*-*,R1),0(R7)     COPY HEADER TO LIST ENTRY\n*---------------------------------------------------------------------*\n*---     NOW THAT WE'VE GOT ALL THE HEADERS AND ALIAS RECORDS FOR  ---*\n*---     THIS ITEM, CHECK AND SEE WHETHER WE'RE GOING TO IMPORT    ---*\n*---     IT.  HERE'S WHERE WE ALSO DECIDE WHETHER OR NOT WE'RE     ---*\n*---     RESTORING ALIASES.                                        ---*\n*---------------------------------------------------------------------*\nGET4     DS    0H\n         #SET  GTDATA,ON           SHOW WE HAVE A DATA RECORD\n         L     R8,CHAIN            POINT TO THE FIRST LINK\n*                                  WE ASSUME THAT THE FIRST RECORD\n*                                  IS THE 'REAL' HEADER, FOLLOWED\n*                                  BY ANY ALIASES PRESENT.\nGET5     DS    0H\n         LA    R1,9(,R8)           POINT TO RECORD KEY\n         LA    R0,0                USE DEFAULT QUALIFIER DATA\n         CALL  ARCHKNAM            GO CHECK THE NAME\n         LTR   R15,R15             KEEP IT ??\n         BZ    GOTONE              YES ---\n         #IF   RETA,OFF,GETBAD     SKIP ALIAS CHECKING ??\n         L     R8,0(,R8)           BUMP DOWN THE CHAIN\n         LTR   R8,R8               ZERO POINTER ??\n         BZ    GETBAD              YES; SKIP THIS ITEM\n         B     GET5                CONTINUE THE LOOP\n*---------------------------------------------------------------------*\n*---     IF WE GET HERE, THE ITEM IS NOT SELECTED FOR PROCESSING.  ---*\n*---     FREE THE QUICKCELLS CONTAINING THE HEADER AND ALIAS       ---*\n*---     RECORDS AND START OVER SEARCHING FOR THE NEXT HEADER      ---*\n*---     RECORD.                                                   ---*\n*---------------------------------------------------------------------*\nGETBAD   DS    0H\n         L     R2,CHAIN            LOAD A CELL ADDRESS\n         LTR   R2,R2               IS A CELL PRESENT ??\n         BZ    GETBAD1             NOPE ---\n         MVC   CHAIN,0(R2)         UNCHAIN IT ---\n         L     R0,COUNT            LOAD TOKEN VALUE\n         LR    R1,R2               COPY CELL ADDRESS\n         CALL  CELLFRE             GO FREE THE CELL\n         B     GETBAD              AND CONTINUE 'TIL CHAIN EMPTY\nGETBAD1  DS    0H\n         L     R1,IMPREC           LOAD INPUT RECORD ADDRESS\n         CLI   4(R1),#RTHDR        WAS IT A HEADER ??\n         BE    GETD                YES, CONTINUE ---\n         L     R1,NDCBA            POINT TO THE DCB\n         GET   (1)                 READ ANOTHER RECORD\n         ST    R1,IMPREC           SAVE ITS ADDRESS\n         B     GETBAD1             AND KEEP CHECKING\nGOTONE   DS    0H\n         EJECT\n*---------------------------------------------------------------------*\n*---     AT THIS POINT, THE WORD AT 'CHAIN' POINTS TO A LIST OF    ---*\n*---     HEADER/ALIAS RECORDS, R7 POINTS TO THE FIRST NON-HEADER   ---*\n*---     RECORD, R8 CONTAINS ITS LENGTH.                           ---*\n*---------------------------------------------------------------------*\n*---     NOW THE TRICKY PART; SETTING THE ITEM VERSION NUMBER      ---*\n*---                                                               ---*\n*---     IF THE USER SPECIFIED A VERSION NUMBER, WE DO A READ TO   ---*\n*---     SEE IF THAT VERSION EXISTS. IF IT DOES, WE MUST DELETE    ---*\n*---     IT BEFORE WE CONTINUE.  SINCE I'M A TRUSTING SOUL, I'LL   ---*\n*---     CALL THE ARCHERAS ROUTINE TO DELETE THE DUPLICATE         ---*\n*---     VERSION.                                                  ---*\n*---                                                               ---*\n*---     IF THE USER DIDN'T PROVIDE A VERSION, WE'LL DO A READ ON  ---*\n*---     A GENERIC KEY, LOOKING FOR A PREVIOUS VERSION. WE'LL      ---*\n*---     INCREMENT THE VERSION NUMBER FROM THERE AND GO.           ---*\n*---------------------------------------------------------------------*\n         L     @BUF3,VS1BUF3       LOAD CHAIN POINTER\n         L     R9,VS1LEN3          LOAD THE RECORD LENGTH\n         L     @RPL2,RPL2          POINT TO THE RPL\n         L     @BUF2,VS1BUF2       LOAD BUFFER POINTER\n         MVC   0(49,@BUF2),0(@BUF3) COPY THE KEY\n         USING REC,@BUF2           AND REDEFINE THE DSECT\n         #IF   REPL,ON,REPLACER\n         #IF   VRS,OFF,NEWVERS\nREPLACER DS    0H\n         LA    R1,RECTT            LOAD PARAMETER POINTER VALUE\n         ICM   R8,15,RECVER\n         CALL  ARCHERAS            GO ERASE ANY DUPLICATE ITEM\n         B     HDRX                GO WRITE THE HEADER RECORD\n*---------------------------------------------------------------------*\n*---     POSSIBLE NEW VERSION OF THE SAME ITEM                     ---*\n*---------------------------------------------------------------------*\nNEWVERS  DS    0H\n         MVC   BLDLAREA(RECKLEN),0(@BUF2) COPY THE KEY\n         XC    RECVER-REC(4,@BUF2),RECVER-REC(@BUF2) LATEST VERSION\n         MODCB RPL=(@RPL2),                                            X\n               AREALEN=(S,VS1LIM),AREA=(@BUF2),                        X\n               ARG=(@BUF2),                                            X\n               OPTCD=(MVE,DIR,FKS,KGE,NUP),                            X\n               MF=(G,GENWK)\n         GET   RPL=(@RPL2)\n         LTR   R15,R15             ANYTHING FOUND ??\n         BNZ   VERS1               NOPE; THIS IS VERSION 1\n         CLC   1(40,@BUF2),1(@BUF3) SAME ITEM ??\n         BNE   VERS1               NOPE; SET VERSION 1\n         ICM   R8,15,RECVER-REC(@BUF2) INSERT THE VERSION NUMBER\n         LTR   R8,R8               ZEROS ??\n         BZ    VERS1               YES; THIS WILL BE VERSION 1\n         BCTR  R8,R0               ONE GREATER\n         STCM  R8,15,RECVER-REC(@BUF3) IN NEW HEADER RECORD\n         B     HDRX                AND GO ---\nVERS1    DS    0H\n         MVC   RECVER,=F'-2'       STARTING VERSION NUMBER (TRUST ME)\n         ICM   R8,15,RECVER        INSERT THE VERSION NUMBER\n         STCM  R8,15,RECVER-REC(@BUF3) IN NEW HEADER RECORD\nHDRX     DS    0H\n         LR    R1,@BUF3            COPY THE RECORD ADDRESS\n         LR    R0,R9               AND RECORD LENGTH\n         BAL   R14,VSPUT           OUTPUT THE HEADER RECORD\n         L     R15,VS1BUF1         POINT TO BUFFER 1\n         MVC   0(RECKLEN,R15),0(@BUF3) COPY THE KEY VALUE\n         LA    R0,RECKLEN          LOAD KEY LENGTH\n         ST    R0,VS1LEN1          SAVE AS CURRENT RCD LENGTH\nREBLK0   DS    0H\n         L     R1,IMPREC           LOAD DATA RECORD POINTER\n         LA    R3,RECKLEN+4(,R1)   POINT TO DATA START\n         LH    R4,0(,R1)           LOAD RECORD LENGTH\n         LA    R4,1(R4,R1)         POINT PAST LAST BYTE\n         BCTR  R4,R0               BACK UP TO LAST BYTE\n         L     R15,VS1BUF1         RELOAD BUFFER POINTER\n         MVC   0(1,R15),4(R1)      COPY RECORD TYPE BYTE\nREBLK1   DS    0H\n         #ADDBLK BUFFER=1,                                             X\n               RECORD=3(,R3),                                          X\n               LENGTH=0(,R3),                                          X\n               LAST=NO,                                                X\n               RTN=VSPUT,                                              X\n               ERR=SIZERR\n         LA    R15,0\n         ICM   R15,7,0(R3)         INSERT SEGMENT LENGTH\n         LA    R3,3(R15,R3)        POINT TO NEXT SEGMENT\n         CR    R3,R4               FAR ENOUGH ??\n         BL    REBLK1              NOPE; CONTINUE\n         L     R1,NDCBA            LOAD NONVSAM DCB ADDRESS\n         GET   (1)                 READ ANOTHER RECORD\n         ST    R1,IMPREC           SAVE THE RECORD POINTER\n         CLI   4(R1),#RTHDR        SAME STUFF ??\n         BE    LOGIT               NOPE; ALL DONE ---\n         CLC   4(4,R1),=CL4'SIZE'    SAME STUFF ??\n         BE    LOGIT               NOPE; ALL DONE ---\n         L     R15,VS1BUF1         POINT TO CURRENT VSAM BUFFER\n         CLC   4(1,R1),0(R15)      SAME ARCHIVER RCD TYPE ??\n         BE    REBLK0              YES; CONTINUE ---\n         #ADDBLK BUFFER=1,RTN=VSPUT,LAST=YES\n         L     R15,VS1BUF1         RELOAD BUFFER POINTER\n         L     R1,IMPREC           POINT TO INPUT RECORD\n         MVC   0(1,R15),4(R1)      COPY NEW RECORD TYPE\n         MVC   RECSEQ#-REC(4,R15),=F'1' RESET SEQUENCE NUMBER\n         B     REBLK0              AND CONTINUE ---\n*---------------------------------------------------------------------*\n*---     COME HERE IF THE CURRENT RECORD IS TOO LARGE TO STORE IN  ---*\n*---     THE ARCHIVE CLUSTER. FORMAT A MESSAGE, WITH ERROR         ---*\n*---     INDICATOR, AND SKIP THE REMAINDER OF THIS ITEM.  THE      ---*\n*---     HEADER RECORD IS PRESENT BUT WHETHER THERE ARE NOTE       ---*\n*---     AND/OR DATA RECORDS IS QUESTIONABLE.  WE'LL ALLOW THE     ---*\n*---     HEADER AND ANY OTHER RECORDS ALREADY STORED TO REMAIN     ---*\n*---     BUT WILL SUPPRESS ANY PROCESSING OF ALIASES. WE'LL ALSO   ---*\n*---     IGNORE THE REMAINDER OF THE ITEM.                         ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nSIZERR   DS    0H\n         #FORMAT 0(,R6),,BADSIZE\n         #PUT  LINE                OUTPUT THE ERROR MESSAGE\n         L     R1,VS1LEN3          LOAD ORIGINAL CLUSTER SIZE\n         CVD   R1,DWORK            CONVERT SIZE TO DECIMAL\n         MVI   LINE,C' '           SEED IN A BLANK\n         MVC   LINE+1(120),LINE    MAKE A FOREST\n         MVC   LINE,SIZMSG         MOVE IN THE ERROR MESSAGE\n         ED    LINE+5(16),DWORK    INSERT THE VALUE\n         #PUT  LINE\n         #SET  GTDATA,OFF          TURN OFF THE 'DATA RECORD' FLAG\nSIZSKIP  DS    0H\n         L     R1,NDCBA            POINT TO THE DCB\n         GET   (1)                 READ A RECORD\n         ST    R1,IMPREC           SAVE ITS ADDRESS\n         CLI   4(R1),#RTHDR        AT A HEADER RECORD ??\n         BE    NOALIAS             YES; SCOOT ---\n         B     SIZSKIP             NOPE; READ THE NEXT RECORD\nSIZMSG   DC    CL133' '\n         ORG   SIZMSG+5\n         DC    X'40202020202020202020202020202020'\n         DC    C' BYTES PER RECORD REQUIRED.'\n         ORG\nBADSIZE  DC    AL1(BADSZE-BADSZ)\nBADSZ    DC    C' VSAM CLUSTER RECORDSIZE TOO SMALL TO IMPORT.'\nBADSZE   EQU   *\n         EJECT\n*---------------------------------------------------------------------*\n*---     DATA RECORDS ARE ALL STORED.  FORMAT THE 'IMPORT          ---*\n*---     COMPLETE' MESSAGE AND PRINT IT. THEN STORE EACH ALIAS     ---*\n*---     RECORD, AS NEEDED OR DIRECTED BY THE USER, AND FORMAT A   ---*\n*---     MESSAGE DENOTING THIS ACTION.  IF AN ALIAS RECORD TURNS   ---*\n*---     OUT TO BE A DUPLICATE OF ANOTHER ALIAS, INCREMENT THE     ---*\n*---     VERSION NUMBER AND KEEP TRYING UNTIL SUCCESSFUL.  THE     ---*\n*---     MESSAGE FORMATTED WILL CONTAIN THE VERSION NUMBER AS      ---*\n*---     STORED.                                                   ---*\n*---------------------------------------------------------------------*\nLOGIT    DS    0H\n         #ADDBLK BUFFER=1,RTN=VSPUT,LAST=YES\n         L     @BUF3,VS1BUF3       LOAD HEADER POINTER\n         LTR   @BUF3,@BUF3         ANYTHING TO LOG ??\n         BZ    ENDITALL            NOPE ---\n         STCM  R8,15,RECVER+8-REC(@BUF3) SAVE THE NEW VERSION NUMBER\n         #FORMAT 0(@BUF3),,IMPORTED\n         #PUT  LINE\n         L     R15,MCNT            LOAD MEMBER COUNT\n         LA    R15,1(,R15)\n         ST    R15,MCNT\n         #IF   RETA,OFF,NOALIAS    NOT RESTORING ALIASES ??\nDOALIAS  DS    0H\n         L     @BUF3,CHAIN         LOAD ALIAS-LINK POINTER\n         LTR   @BUF3,@BUF3         ANY ALIAS RECORD LEFT ??\n         BZ    NOALIAS             NOPE; ALL DONE\n         STCM  R8,15,RECAVER+8-REC(@BUF3) SAVE NEW VERSION NUMBER\nPUTA1    DS    0H\n         LA    R1,8(@BUF3)         POINT TO THE RECORD\n         L     R0,4(,@BUF3)        LOAD RECORD LENGTH\n         BAL   R14,VSPUT           GO 'PUT' THE RECORD\n         LTR   R15,R15             'PUT' OK ??\n         BZ    PUTA2               YES ---\n         ICM   R15,15,RECVER+8-REC(@BUF3) INSERT THE VERSION NUMBER\n         BCTR  R15,R0               MAKE IT ONE HIGHER\n         STCM  R15,15,RECVER+8-REC(@BUF3) SAVE UPDATED VERSION\n         B     PUTA1               AND TRY AGAIN\nPUTA2    DS    0H\n         #FORMAT 8(,@BUF3),,RESTORED\n         #PUT  LINE\n         L     R15,ACNT            LOAD ALIAS COUNT\n         LA    R15,1(,R15)         INCREMENT BY ONE\n         ST    R15,ACNT            AND SAVE THE RESULT\n         MVC   CHAIN,0(@BUF3)      UNCHAIN THIS LINK\n         L     R0,COUNT            LOAD THE TOKEN VALUE\n         LR    R1,@BUF3            COPY THE CELL POINTER\n         CALL  CELLFRE             GO FREE THE CELL\n         B     DOALIAS             AND CONTINUE ---\nNOALIAS  DS    0H\n         L     R2,CHAIN            LOAD A CELL ADDRESS\n         LTR   R2,R2               IS A CELL PRESENT ??\n         BZ    GETD                NOPE ---\n         MVC   CHAIN,0(R2)         UNCHAIN IT ---\n         L     R0,COUNT            LOAD THE TOKEN VALUE\n         LR    R1,R2               COPY THE CELL POINTER\n         CALL  CELLFRE             GO FREE THE CELL\n         B     NOALIAS             AND CONTINUE 'TIL CHAIN EMPTY\nENDITALL DS    0H\n         #SET  EOT,OFF             RESET MY END-OF-FILE FLAG\n         #SET  GTDATA,OFF          RESET MY GOT-DATA-RECORD FLAG\n         L     R0,MCNT             LOAD MEMBER COUNT\n         LTR   R0,R0               ZERO COUNT ??\n         BZ    END2                YES ---\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,MCMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\n         L     R0,ACNT             LOAD MEMBER COUNT\n         LTR   R0,R0               ZERO COUNT ??\n         BZ    END2                YES ---\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,ACMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\nEND2     DS    0H\n         L     R0,COUNT            LOAD THE TOKEN VALUE\n         CALL  CELLDEL             GO DELETE THE CELL POOL\n         CLC   ACB1,=F'0'          WAS ACB EVER OPENED ??\n         BE    NOACB               NOPE ---\n         LA    R1,VSAM1DD          POINT TO THE DDNAME\n         LA    R0,4                SET 'CLOSE' REQUEST\n         CALL  ARCHVSOP            CALL THE VSAM 'CLOSE' ROUTINE\nNOACB    DS    0H\n         BAL   R14,NVSCLOSE        GO CLOSE THE INPUT FILE\n         L     R13,4(,R13)         LOAD BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ALWAYS RC = 0\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\n         SPACE 3\n*---------------------------------------------------------------------*\n*---     SOME OF MY ERROR PROCESSING GOES HERE                     ---*\n*---------------------------------------------------------------------*\nORGERR   DS    0H\n         #PUT  ERR3\n         #PUT  ERR6\n         B     ENDITALL\nERRDEV   DS    0H\n         #PUT  ERR2\n         #PUT  ERR6\n         B     ENDITALL\nERR2     DC    CL133'0*** ERROR *** THE EXPTPDD/EXPTPDSN IS INVALID. ITX\n               MUST BE ON A TAPE OR DASD VOLUME.'\nERR3     DC    CL133'0*** ERROR *** THE EXPDPDD/EXPTPDSN IS INVALID. ITX\n               MUST BE A SEQUENTIAL DATASET.'\nERR6     DC    CL133'0*** ERROR *** THIS CONTROL STATEMENT WILL BE IGNOX\n               RED.'\n         TITLE 'OPEN NONVSAM INPUT DATASET '\nOPNVI    DS    0H\n         STM   R14,R12,IOSAVE      SAVE THE ENTRY REGISTERS\n         XC    IOSAVE+4(4),IOSAVE+4 INITIAL RETURN CODE\n         CLC   EXPTPDD,=CL8' '     DDNAME GIVEN ??\n         BE    OPNVI4              NOPE; RETURN, CODE = 4\n*---------------------------------------------------------------------*\n*---     BUILD A DCB, TO START, FOR DSORG CHECKING                 ---*\n*---------------------------------------------------------------------*\n         GETMAIN R,LV=QSDCBL,SP=11 GRAB STORAGE FOR BPAM DCB\n         ST    R1,NDCBA            AND STORE ADDRESS IN ARCHIVWA\n         MVI   NDCBA,X'80'         BUILD OPEN PARM LIST\n         MVC   0(QSDCBL,R1),QSDCB  COPY DCB TO DYNAMIC AREA\n         USING IHADCB,R1           BASE THE DCB DSECT\n         MVC   DCBDDNAM,EXPTPDD    MOVE IN THE DDNAME\n         DROP  R1\n*---------------------------------------------------------------------*\n*---     GET THE VOLSER FROM THE UCB, STARTING FROM THE TIOT.      ---*\n*---------------------------------------------------------------------*\n         L     R1,TIOTA            LOAD TIOT ELEMENT POINTER\nOPNVI2   DS    0H\n         CLI   0(R1),0             AT TIOT END ??\n         BE    OPNVI4              YES; DD STATEMENT IS MISSING\n         CLC   EXPTPDD,4(R1)       IS THIS THE DD ENTRY ??\n         BE    OPNVI3              YES; GO FETCH UCB ADDR\n         IC    R0,0(,R1)           INSERT TIOE LENGTH\n         N     R0,=F'255'          TRIM TO JUST THE LENGTH\n         AR    R1,R0               BUMP TO NEXT ENTRY\n         B     OPNVI2              AND CONTINUE THE SEARCH\nOPNVI3   DS    0H\n         DEVTYPE EXPTPDD,CALLIST\n         CLI   CALLIST+2,X'20'     DASD DEVICE ??\n         BE    OPNVI3A             YES\n         CLI   CALLIST+2,X'80'     TAPE DEVICE ??\n         BE    OPNVI3A             NOPE; INVALID DEVICE TYPE\n         #PUT  NVDEVBAD            SPIT OUT THE ERROR MESSAGE\n         B     OPNVI4              AND QUIT ---\nOPNVI3A  DS    0H\n         OPEN  (,INPUT),MF=(E,NDCBA) OPEN THE DCB\n         L     R15,NDCBA           LOAD THE DCB ADDRESS\n         TM    DCBOFLGS-IHADCB(R15),DCBOFOPN    DID IT OPEN ??\n         BZ    OPNVI4              NOPE; RETURN, CODE = 4\n         LM    R14,R12,IOSAVE      RELOAD ENTRY REGISTERS\n         BR    R14                 AND RETURN TO LOCAL CALLER\nOPNVI4   DS    0H\n         #PUT  NVSBAD              OUTPUT AN ERROR MESSAGE\n         MVC   IOSAVE+4(4),=F'4'\n         LM    R14,R12,IOSAVE\n         BR    R14\n         SPACE 3\n*---------------------------------------------------------------------*\n*---     THIS IS THE EODAD EXIT CODE FOR THE EXPTP DATASET.        ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nIMPEND   DS    0H\n         #SET  EOT,ON              SET THE 'END OF TAPE' BIT\n         XC    IMPREC,IMPREC       SHOW NO RECORD WAS READ\n         B     LOGIT               FINISH OFF ANYTHING STILL PENDING\n         SPACE 3\n*---------------------------------------------------------------------*\n*---     THIS CHEAP AND DIRTY LITTLE DCB COMPLETION EXIT SETS THE  ---*\n*---     BLKSIZE, IF THE USER HAS FORGOTTEN TO SUPPLY A BLKSIZE,   ---*\n*---     EITHER ON A DD STATEMENT OR A DATASET LABEL.              ---*\n*---------------------------------------------------------------------*\n         SPACE 3\n         DS    0F\nE1       DC    X'85',AL3(E1+4)\n         USING IHADCB,R1\n         CLC   DCBBLKSI,=H'0'      BLKSIZE MISSING ??\n         BNER  R14                 NOPE ---\n         MVC   DCBBLKSI,=H'32000'  YES; INSERT A DEFAULT\n         BR    R14\n         DROP  R1\nQSDCB    DCB   DSORG=PS,MACRF=GL,BFTEK=A,EODAD=IMPEND,RECFM=VBS,       X\n               LRECL=32760,EXLST=E1\nQSDCBL   EQU   *-QSDCB\n         TITLE 'QSAM CLOSE ROUTINE'\n*---------------------------------------------------------------------*\n*---     THIS LITTLE ROUTINE CLOSES THE NONVSAM DATASET, RELEASES  ---*\n*---     ALL BUFFER POOLS, RESETS POINTER VALUES, RELEASE THE      ---*\n*---     COMPRESSION WORK AREA AND CLEANS UP THE NONVSAM I/O IN    ---*\n*---     GENERAL, INCLUDING THE RESETING OF ANY FLAG BITS.         ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nNVSCLOSE DS    0H\n         STM   R14,R12,IOSAVE      SAVE THE ENTRY REGISTERS\n         L     R2,NDCBA            LOAD PRIMARY DCB ADDRESS\n         LA    R2,0(,R2)           PURIFY THE ADDRESS\n         LTR   R2,R2               ZERO ??\n         BZ    NVC1                YES; NO DCB HERE ---\n         CLOSE MF=(E,NDCBA)        CLOSE THE DCB\n         #FREE (2)                 RELEASE BUFFER POOL, IF ANY\n         FREEMAIN R,LV=QSDCBL,SP=11,A=(2)\nNVC1     DS    0H\n         XC    NDCBA,NDCBA         AND RESET THE POINTER FIELD\n         LM    R14,R12,IOSAVE      RESTORE THE REGISTERS\n         BR    R14                 AND RETURN TO CALLER\n         TITLE 'VSAM I/O OUTPUT '\n*---------------------------------------------------------------------*\n*---     THIS LITTLE LOCAL SUBROUTINE DOES ALL THE VSAM WRITING    ---*\n*---     FOR THE IMPORT FUNCTION, WITH THE EXCEPTION OF THE        ---*\n*---     ERASURE OF A DUPLICATE ITEM.  THE BASIC ASSUMPTIONS ARE   ---*\n*---     THAT THE VS1BUF1 AREA IS THE RECORD TO BE WRITTEN AND     ---*\n*---     ITS LENGTH IS ACCURATELY REPORTED IN THE VS1LEN1 FIELD.   ---*\n*---------------------------------------------------------------------*\nVSPUT    DS    0H\n         STM   R14,R12,IOSAVE      SAVE ENTRY REGISTERS\n         L     R4,RPL1             LOAD RPL ADDRESS\n         LR    R5,R1               LOAD BUFFER ADDRESS\n         LR    R6,R0               LOAD RECORD LENGTH\n         MODCB RPL=(4),            RPL ADDRESS                         X\n               OPTCD=(DIR,FKS,NUP,MVE,KEQ), OPTION CODES ---           X\n               ARG=(5),            KEY ADDRESS                         X\n               AREA=(5),           BUFFER ADDRESS                      X\n               RECLEN=(6),         RECORD LENGTH                       X\n               MF=(G,GENWK)\n         PUT   RPL=(4)             OUTPUT THE VSAM RECORD\n         LTR   R15,R15             ALL OK ??\n         BZ    VSPUT5              YES ---\n         SHOWCB RPL=(4),                                               X\n               FIELDS=FDBK,        FETCH THE RPL FEEDBACK FIELD        X\n               AREA=(S,DWORK),                                         X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        GET FEEDBACK FIELD\n         CLI   DWORK+3,8           DUPLICATE KEY ??\n         BNE   VSPUTDIE            NOPE ---\n         LA    R15,4               LOAD THE RETURN CODE\nVSPUT5   DS    0H\n         L     R14,IOSAVE          RELOAD R14\n         LM    R0,R12,IOSAVE+8     RESTORE OTHER REGS\n         BR    R14                 AND RETURN TO CALLER\nVSPUTDIE DS    0H\n         EX    R0,*\nNVSBAD   DC    CL133' *** ERROR *** UNABLE TO OPEN EXPTPDD/EXPTPDSN. CHX\n               ECK THE DD STATEMENT OR PARAMETER.'\nNVDEVBAD DC    CL133' *** ERROR *** INVALID DEVICE FOR EXPTPDD/EXPTPDSNX\n               . MUST BE TAPE OR DASD.'\nMCMSG    DC    CL133' '\n         ORG   MCMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    C' TOTAL MEMBER(S) PROCESSED.'\n         ORG\nACMSG    DC    CL133' '\n         ORG   ACMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    C' ALIASES RESTORED. '\n         ORG\n         LTORG\nIMPORTED DC    AL1(UNLMSGE-UNLMSG)\nUNLMSG   DC    C' SUCCESSFULLY IMPORTED.'\nUNLMSGE  EQU   *\nRESTORED DC    AL1(RSLMSGE-RSLMSG)\nRSLMSG   DC    C' ALIAS RESTORED (MAY BE NEW VERSION).'\nRSLMSGE  EQU   *\n         DCBD  DSORG=(PS,PO)\n         COPY  #RECS\n         COPY  ##ARCHWK\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHINIT": {"ttr": 5129, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06\\x0c\\x00\\x00\\x01 \\x18o\\x01 \\x18o\\x12W\\x00\\xe8\\x00\\xe8\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@'", "ispf": {"version": "06.12", "flags": 0, "createdate": "2020-07-04T00:00:00", "modifydate": "2020-07-04T12:57:00", "lines": 232, "newlines": 232, "modlines": 0, "user": "ARCHIVR"}, "text": "INIT     TITLE 'ARCHIVER --- WORK AREA/TIME/DATE SETUP '\n*---------------------------------------------------------------------*\n*---     (C) COPYRIGHT 1989, RICHARD A. FOCHTMAN JR., WOODRIDGE,   ---*\n*---           ILLINOIS                                            ---*\n*---                                                               ---*\n*---     THIS SUBROUTINE HAS ONLY ONE PURPOSE IN THE ARCHIVER:     ---*\n*---     SETUP THE CONSTANTS, ETC. NECESSARY TO THE BASIC          ---*\n*---     FUNCTIONS IN GENERAL.  THAT IS, THE TIME, DATE, SYSIN     ---*\n*---     AND SYSPRINT DCB'S, BLANK OUT THE VARIOUS PRINT LINE      ---*\n*---     AREAS, ETC.  THIS IS PERFORMED ONCE FOR EACH RUN OF       ---*\n*---     THE ARCHIVER.  FOR THAT REASON, THIS IS A SEPARATE        ---*\n*---     LOAD MODULE OF THE ARCHIVER, USED AND THEN DELETED        ---*\n*---     AT THE BEGINNING OF EACH ARCHIVER EXECUTION.              ---*\n*---                                                               ---*\n*---     PROGRAM ATTRIBUTES: NON-REENTRANT, NON-REUSABLE,          ---*\n*---           NON-REFRESHABLE.                                    ---*\n*--- UPDATE ON JULY 1,2020 ROB PRINS: CHANGE LA    R3,WALEN INTO   ---*\n*---                                         L     R3,WALEN (STMNT 51)*\n*--- UPDATE BY @RP AT 20200703: ADD SUPPORT FOR ALTERNATIVE        ---*\n*--- DDNAMES FOR SYSPRINT AND SYSIN IN THE PARM OF THE EXEC        ---*\n*--- STATEMENT IN THE ARCHIVER JCL.                                ---*\n*---------------------------------------------------------------------*\nARCHINIT CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n         USING ARCHINIT,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             LOAD ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHINIT,R11        DEFINE THE NEW BASE REGISTER\n         GETMAIN R,LV=72           GRAB STORAGE FOR SAVE AREA\n         LA    R14,0(,R1)          KLUDGE FOR STD HDR\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             LOAD NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RELOAD BACK POINTER\n         L     R14,12(,R14)        RELOAD ORIG. REG 14\n         COPY  #ARCBITS            COPY THE BIT-DEFINES\n         L     R3,WALEN            LOAD SIZE OF WORK AREA    @RP2000701\n         GETMAIN R,LV=(3)          GRAB ANOTHER CHUNK OF STORAGE\n         LR    R2,R1               COPY ITS ADDRESS\n         LR    R4,R2\n         SR    R5,R5\n         MVCL  R2,R4               AND CLEAR IT OUT\n         LR    R12,R1              AND LOAD WORK-AREA DSECT BASE\n         USING MAINWK,R12          BASE THE WORK-AREA DSECT\n         MVC   WKSYSPR,=CL8'SYSPRINT' DEFAULT DDNAME SYSRINT  @RP200703\n         MVC   WKSYSIN,=CL8'SYSIN'    DEFAULT DDNAME SYSRINT  @RP200703\n         MVC   WKKEYW,=CL8'SYSIN'  MOVE SYSIN= KEYWORD        @RP200703\n         LA    R3,WKKEYW           1ST PARM ARCHPRSC          @RP200703\n         LA    R4,WKWORKA          2ND PARM ARCHPRSC          @RP200703\n         CALL  ARCHPRSC,((3),(4))  OBTAIN ALT. DDNAME SYSIN   @RP200703\n         LTR   R15,R15             NEW DDNAME OF SYSIN?       @RP200703\n         BNZ   NOALTIN             NO: CARRY                  @RP200703\n         MVC   WKSYSIN,WKWORKA+2   MOVE ALTERNATIVE DDNAME    @RP200703\nNOALTIN  DS    0H                                             @RP200703\n         MVC   WKKEYW,=CL8'SYSPRINT' MOVE SYSPRINT= KEYWORD   @RP200703\n         LA    R3,WKKEYW           1ST PARM ARCHPRSC          @RP200703\n         LA    R4,WKWORKA          2ND PARM ARCHPRSC          @RP200703\n         CALL  ARCHPRSC,((3),(4))  OBTAIN ALT. DDNAME SYSIN   @RP200703\n         LTR   R15,R15             NEW DDNAME OF SYSIN?       @RP200703\n         BNZ   NOALTPR             NO: CARRY                  @RP200703\n         MVC   WKSYSPR,WKWORKA+2   MOVE ALTERNATIVE DDNAME    @RP200703\nNOALTPR  DS    0H                                             @RP200703\n         MVC   IOSEP,=X'47F0E000'  NO SEPARATOR ROUTINES\n         MVC   ENDSEP,=X'47F0E000'   DEFINED YET ---\n         MVC   MAINSIZE,WALEN      COPY SIZE INTO WORD 1\n         ST    R12,ARCHWK          SAVE MAIN WORK-AREA POINTER\n         MVC   EYEBALL,=CL4'ARCW'\n         #SET  REPL,ON              REPLACE DUPS. DURING RELOAD   DFLT\n         #SET  RETA,ON              RETAIN ALIAS INFORMATION      DFLT\n         #SET  SHHDR,ON             PROCESS HEADERS               DFLT\n         #SET  ULMODS,ON            RECFM=U MEANS LMODS           DFLT\n         MVI   TITLE1,C' '         START WITH A BLANK\n         MVC   TITLE1+1(120),TITLE1 CLEAR THE AREA\n         MVC   TITLE2,TITLE1       ALSO SECOND AND\n         MVC   TITLE3,INIT14       COPY IN THE USUAL SUBTITLE\n         MVC   LINE,TITLE1         ALSO OUTPUT LINE AREA\n         MVC   GENWK(LTIMEL),LTIME MOVE IN PARM LIST\n         XC    TODVAL(16),TODVAL   CLEAR THE RETURN AREA\n         TIME  DEC,TODVAL,LINKAGE=SYSTEM,                          Y2K X\n               MF=(E,GENWK),DATETYPE=MMDDYYYY                      Y2K\n         EXTRACT TIOTA,'S',FIELDS=TIOT,MF=(E,CALLIST) LOCATE THE TIOT\n         L     R1,TIOTA            LOAD THE TIOT POINTER\n         LA    R1,24(,R1)          POINT TO THE FIRST TIOE\n         ST    R1,TIOTA            SAVE UPDATED ADDRESS\n*---------------------------------------------------------------------*\n*---     FIND OUT IF SYSPUNCH IS PRESENT                           ---*\n*---------------------------------------------------------------------*\nLOCPNCH  DS    0H\n         CLI   0(R1),0             END OF TIOT ??\n         BE    NOPNCH              YES ---\n         CLC   4(8,R1),=CL8'SYSPUNCH'  IS DDNAME SYSPUNCH ??\n         BE    GOTPNCH             YES ---\n         LA    R15,0               CLEAR A WORK REGISTER\n         IC    R15,0(,R1)          INSERT TIOT LENGTH\n         AR    R1,R15              POINT TO NEXT TIOE\n         B     LOCPNCH\nGOTPNCH  DS    0H\n         #SET  PUNCH,ON\nNOPNCH   DS    0H\n         LA    R0,INIT7            LOAD THE LENGTH OF A QSAM DCB\n         AH    R0,=H'4'            ADD A WORD\n         GETMAIN R,LV=(0)          AND GRAB IT'S CORE\n         ST    R0,0(,R1)           STORE AREA LENGTH\n         LA    R1,4(,R1)\n         MVC   0(INIT7,R1),INIT6   MOVE IN THE DCB\n         ST    R1,PRTDCB           STORE IN THE WORK AREA\n         LR    R3,R1               AND COPY IT'S ADDRESS\n         USING IHADCB,R3           ADDRESS DCBD               @RP200703\n         MVC   DCBDDNAM(8),WKSYSPR MOVE DDNAME OF SYSPRINT    @RP200703\n         DROP  R3                                             @RP200703\n         MVI   PRTDCB,X'80'        LAST-ENTRY FLAG FOR OPEN PARMLIST\n         OPEN  ((3),OUTPUT),MF=(E,PRTDCB)      OPEN THE LISTING DCB\n         TM    48(R3),X'10'        DID SYSPRINT OPEN ??\n         BO    INIT1               YES, NOW CHECK SYSIN FLAG\n         WTO   'SYSPRINT DCB DID NOT OPEN. CHECK DD STATEMENT'\n         LA    R3,0\n         ABEND 1\nINIT1    DS    0H\n         LA    R0,INIT9            LOAD DCB LENGTH\n         AH    R0,=H'4'            ADD A WORD\n         GETMAIN R,LV=(0)          GRAB STORAGE FOR DCB\n         ST    R0,0(,R1)           STORE AREA LENGTH\n         LA    R1,4(,R1)\n         ST    R1,CTLIN            SAVE ITS ADDRESS\n         LR    R2,R1               COPY DCB ADDRESS           @RP200703\n         MVC   0(INIT9,R2),INIT8 MOVE IN THE DCB              @RP200703\n         MVI   CTLIN,X'80'         FLAG END OF OPEN LIST\n         USING IHADCB,R2           ADDRESS DCBD               @RP200703\n         MVC   DCBDDNAM(8),WKSYSIN  MOVE DDNAME SYSIN         @RP200703\n         DROP  R2                                             @RP200703\n         LR    R1,R2                                          @RP200703\n         OPEN  (,INPUT),MF=(E,CTLIN) AND OPEN THE DCB\n         ZAP   PAGENO,=P'0'        INIT THE PAGE COUNTER\n         ZAP   LSTLIN#,=P'99'      FORCE NEW-PAGE CONTROL\n         ZAP   LINECNT,=P'60'      MOVE IN THE DEFAULT\n         LM    R0,R1,TODVAL        LOAD THE TIME VALUE             Y2K\n         SRDL  R0,40               DROP OFF THE FRACTIONS          Y2K\n         SLL   R1,4                MAKE FROM FOR DEC. SIGN VALUE   Y2K\n         O     R1,=A(X'0F')        MAKE A POSITIVE SIGN            Y2K\n         STM   R0,R1,TIME          SAVE IN CLOCK VALUE             Y2K\n         L     R1,TODVAL+8         LOAD THE DATE VALUE             Y2K\n         LA    R0,R0               CLEAR HIGH-ORDER PART           Y2K\n         SLDL  R0,4                MAKE ROOM FOR A SIGN            Y2K\n         O     R1,=A(X'0F')        INSERT POSITIVE SIGN            Y2K\n         STM   R0,R1,DATE          AND SAVE THE VALUE FOR LATER    Y2K\n         LR    R15,R12             COPY THE WORK AREA ADDRESS\n         LR    R1,R13              COPY THE SAVE AREA ADDRESS\n         L     R13,4(,R13)         POINT TO PREVIOUS S.A.\n         ST    R15,16(,R13)        PASS W.A. ADDR AS RETURN CODE\n         FREEMAIN R,LV=72,A=(1)    FREE THE SAVE AREA\n         LM    R14,R12,12(R13)     RESTORE ENTRY REGISTERS\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO ARCHCTL\n         LTORG ,                   DISPLAY THE LITERALS SO FAR\n         SPACE 3\nINIT6    DCB   DSORG=PS,                                               X\n               MACRF=PM,                                               X\n               EXLST=INIT10,                                           X\n               DDNAME=SYSPRINT,                                        X\n               RECFM=FBA,                                              X\n               LRECL=133,                                              X\n               EROPT=ABE\nINIT7    EQU   *-INIT6\nINIT8    DCB   DSORG=PS,                                               X\n               MACRF=GM,                                               X\n               EXLST=INIT10,                                           X\n               DDNAME=SYSIN,                                           X\n               RECFM=FB,                                               X\n               LRECL=80,                                               X\n               EROPT=ABE\nINIT9    EQU   *-INIT8\nINIT10   DC    0F'0'\n         DC    X'85',AL3(INIT11)\n         PUSH  USING\n         USING INIT11,R15\nINIT11   DS    0H\n         LH    R6,62(,R1)          LOAD DCB BLKSIZE ??\n         LTR   R6,R6               IS BLKSIZE STILL ZERO ??\n         BNZ   INIT12              NO; SEE IF MULTIPLE OF LRECL\n         MVC   62(2,R1),82(R1)     COPY LRECL TO BLKSIZE\n         BR    R14                 RETURN TO OPEN/CLOSE/EOV\nINIT12   DS    0H\n         SRDA  R6,32               SHIFT BLKSIZE TO DIVIDEND REGISTER\n         LH    R5,82(,R1)          LOAD LRECL VALUE\n         DR    R6,R5               COMPUTE BLOCKING FACTOR\n         LTR   R7,R7               QUOTIENT ZERO ??\n         BNZ   INIT13              NOPE ---\n         LA    R7,1                ASSUME 1 RECORD/BLOCK\nINIT13   DS    0H\n         MH    R7,82(,R1)          TIMES LRECL\n         STH   R7,62(,R1)          STORE COMPUTED BLOCK SIZE\n         BR    R14                 RETURN TO OPEN/CLOSE/EOV\n         DROP  R15\n         POP   USING\nLTIME    TIME  LINKAGE=SYSTEM,MF=L\nLTIMEL   EQU   *-LTIME\n*\nINIT14   DC    CL2' '\n         DC    CL10'  MEMBER '                                     HEAD\n         DC    CL1'-'\n         DC    CL10'  GROUP  '                                     HEAD\n         DC    CL1'-'\n         DC    CL10'  SUBGRP '                                     HEAD\n         DC    CL1'-'\n         DC    CL10'   TYPE  '                                     HEAD\n         DC    CL1'-'\n         DC    CL12'       VRSN '                                  HEAD\n         DC    CL8' ACTION '\n         DC    CL70' '\nDTIME    DS    F\nDDATE    DS    F\nWALEN    DC    A(ENDMAIN-MAINWK)\n         COPY  ##ARCHWK\n         DCBD  DSORG=(PS,PO)\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHIVE#": {"ttr": 5380, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06\\x0c\\x00@\\x01 !o\\x01 !o\\x13\\x17\\x0e\\x85\\x0e\\x85\\x00\\x00\\xd7\\xc4\\xc6@@@@@@@'", "ispf": {"version": "06.12", "flags": 0, "createdate": "2020-08-03T00:00:00", "modifydate": "2020-08-03T13:17:40", "lines": 3717, "newlines": 3717, "modlines": 0, "user": "PDF"}, "mimetype": "application/pdf", "datatype": "binary", "extension": ".pdf"}, "ARCHIVE@": {"ttr": 6916, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06\\x0c\\x00@\\x01  \\x9f\\x01  \\x9f )\\x06\\x82\\x06\\x82\\x00\\x00\\xd4\\xe2\\xe6\\xd6\\xd9\\xc4@@@@'", "ispf": {"version": "06.12", "flags": 0, "createdate": "2020-07-27T00:00:00", "modifydate": "2020-07-27T20:29:40", "lines": 1666, "newlines": 1666, "modlines": 0, "user": "MSWORD"}, "mimetype": "application/vnd.openxmlformats-officedocument.wordprocessingml.document", "datatype": "binary", "extension": ".docx"}, "ARCHKDCB": {"ttr": 7434, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x01J\\x01J\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 330, "newlines": 330, "modlines": 0, "user": "ARCHIVR"}, "text": "CDCB     TITLE 'ARCHKDCB --- ARCHIVER FUNCTION SUPPORT SUBROUTINE'\n*---------------------------------------------------------------------*\n*---     FUNCTION: USING THE PREVIOUSLY-OPENED OUTPUT DCB AND      ---*\n*---           THE INPUT MEMBER HEADER RECORD, CHECK FOR THE       ---*\n*---           COMPATABILITY OF THE DCB PARAMETERS.  CERTAIN       ---*\n*---           TYPES MAY BE CONVERTED BY THE ARCHIVER, WHILE       ---*\n*---           OTHERS ARE NOT CONVERTIBLE.  FOR THOSE THAT MAY     ---*\n*---           BE VALIDLY CONVERTED, SET A RETURN CODE OF 0,       ---*\n*---           ELSE SET A RETURN CODE OF 4, ISSUE A MESSAGE,       ---*\n*---           AND RETURN TO THE CALLER.  THE FOLLOWING TABLE      ---*\n*---           DEFINES ACCEPTABLE CONVERSIONS.  THOSE THAT ARE     ---*\n*---           ACCEPTABLE ARE MARKED WITH '*'; ALL OTHERS ARE      ---*\n*---           REFUSED.                                            ---*\n*---                                                               ---*\n*---                        INPUT FORMAT FROM ARCHIVE              ---*\n*---                -------------------------------------------    ---*\n*---                |  F   |   FB   |   V   |   VB   |    U   |    ---*\n*---           ------------------------------------------------    ---*\n*---      O     F   |  *   |   *    |       |        |        |    ---*\n*---      U    ------------------------------------------------    ---*\n*---      T     FB  |  *   |   *    |       |        |        |    ---*\n*---      P    ------------------------------------------------    ---*\n*---      U     V   |  *   |    *   |   *   |   *    |   *    |    ---*\n*---      T    ------------------------------------------------    ---*\n*---            VB  |  *   |    *   |   *   |   *    |   *    |    ---*\n*---      D    ------------------------------------------------    ---*\n*---      C     U   |  *   |    *   |   *   |   *    |   *    |    ---*\n*---      B    ------------------------------------------------    ---*\n*---                                                               ---*\n*---     NOTE: CONVERSION FROM F/FB TO V/VB REQUIRES THAT          ---*\n*---           FOUR BYTES BE ADDED TO LRECL FOR RDW AND FOUR BYTES ---*\n*---           ADDED TO BLKSIZE FOR BDW, WHERE APPROPRIATE.        ---*\n*---                                                               ---*\n*---     NOTE: CONVERSION FROM U TO V/VB REQUIRES THAT             ---*\n*---           FOUR BYTES BE ADDED TO LRECL FOR RDW AND FOUR BYTES ---*\n*---           ADDED TO BLKSIZE FOR BDW, WHERE APPROPRIATE.        ---*\n*---                                                               ---*\n*---     V/VB LRECLS MAY BE EXTENDED AS NEEDED.                    ---*\n*---                                                               ---*\n*---     U-FORMAT REQUIRES THAT THE OUTPUT BLKSIZE BE EQUAL OR     ---*\n*---           LARGER THAN INPUT BLKSIZE.                          ---*\n*---                                                               ---*\n*---     PARAMETERS:  REGISTER 1 POINTS TO THE ARCHIVE ITEM        ---*\n*---     HEADER RECORD. THE DCB TO BE CHECKED IS ADDRESS BY        ---*\n*---     THE MAINWK DSECT.                                         ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nARCHKDCB CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n         USING ARCHKDCB,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             LOAD ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHKDCB,R11        DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             LOAD NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RELOAD BACK POINTER\n         L     R14,12(,R14)        RELOAD ORIG. REG 14\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         LR    R3,R1               COPY THE RECORD ADDRESS\n         USING REC,R3              AND HEADER DSECT\n         L     R2,NDCBA            AND LOAD DCB ADDRESS\n         USING IHADCB,R2           BASE DCB DSECT\n         LA    R4,0                CLEAR WORK REGISTER\n         IC    R4,RSRREC           INSERT THE RECORD FORMAT\n         N     R4,=A(DCBRECU+DCBRECBR) CLOBBER EXTRANEOUS BITS\n         IC    R5,DCBRECFM         OUTPUT RECFM\n         N     R5,=A(DCBRECU+DCBRECBR) CLOBBER EXTRANEOUS BITS\n         C     R5,=A(DCBRECF)      F-FORMAT OUTPUT ??\n         BE    DCBC1               YES ---\n         C     R5,=A(DCBRECF+DCBRECBR) FB-FORMAT RECORDS\n         BE    DCBC4               YES ---\n         C     R5,=A(DCBRECV)      V-FORMAT RECORDS ??\n         BE    DCBC7               YES ---\n         C     R5,=A(DCBRECV+DCBRECBR) VB-FORMAT RECORDS ??\n         BE    DCBC13              YES ---\n         B     DCBC19              U-FORMAT RECORDS\n*---------------------------------------------------------------------*\n*---     FIXED, UNBLOCKED RECORDS FOR OUTPUT                       ---*\n*---                                                               ---*\n*---     Q. INPUT RECFM = F                                        ---*\n*---            BLKSIZEIN = BLKSIZE OUT ??                         ---*\n*---                                                               ---*\n*---     Q. INPUT RECFM = FB                                       ---*\n*---            LRECLIN = BLKSIZE OUT ??                           ---*\n*---------------------------------------------------------------------*\nDCBC1    DS    0H\n         C     R4,=A(DCBRECF+DCBRECBR) FIXED BLOCKED RECORDS ??\n         BE    DCBC2               YES ---\n         C     R4,=A(DCBRECF)      FIXED UNBLOCKED RECORDS ??\n         BE    DCBC3               YES ---\n         B     DCBC25              INVALID FORMAT CHANGE\nDCBC2    DS    0H\n         CLC   DCBBLKSI,RSRLRE     INPUT LRECL MATCH OUTPUT BLKSIZE ??\n         BNE   DCBC25              NOPE; INVALID\n         B     DCBC26              YES; ALL IS OK\nDCBC3    DS    0H\n         CLC   DCBBLKSI,RSRBLK     INPUT BLKL MATCH OUTPUT BLKSIZE ??\n         BNE   DCBC25              NOPE; INVALID\n         B     DCBC26              YES; ALL IS OK\n*---------------------------------------------------------------------*\n*---     FIXED, BLOCKED RECORDS FOR OUTPUT                         ---*\n*---                                                               ---*\n*---     Q. INPUT RECFM = F                                        ---*\n*---            BLKSIZEIN = LRECL OUT ??                           ---*\n*---                                                               ---*\n*---     Q. INPUT RECFM = FB                                       ---*\n*---            LRECLIN = LRECL OUT ??                             ---*\n*---------------------------------------------------------------------*\nDCBC4    DS    0H\n         C     R4,=A(DCBRECF+DCBRECBR) FIXED-BLOCKED RECORDS ??\n         BE    DCBC5               YES ---\n         C     R4,=A(DCBRECF)      FIXED UNBLOCKED RECORDS ??\n         BE    DCBC6               YES ---\n         B     DCBC25              INVALID FORMAT CHANGE\nDCBC5    DS    0H\n         CLC   RSRLRE,DCBLRECL     LRECLS MATCH ??\n         BNE   DCBC25              NOPE; INVALID CHANGE\n         B     DCBC26              YES; ALL IS OK\nDCBC6    DS    0H\n         CLC   RSRBLK,DCBLRECL     IN BLKSIZE MATCH OUTPUT LRECL ??\n         BNE   DCBC25              NOPE; INVALID CHANGE\n         B     DCBC26              YES; ALL IS OK\n*---------------------------------------------------------------------*\n*---     VARIABLE, UNBLOCKED RECORDS FOR OUTPUT                    ---*\n*---                                                               ---*\n*---     Q. INPUT RECFM = V                                        ---*\n*---            BLKSIZEIN <= BLKSIZE OUT ??                        ---*\n*---                                                               ---*\n*---     Q. INPUT RECFM = U                                        ---*\n*---            BLKSIZEIN <= BLKSIZE OUT - 4 ??                    ---*\n*---                                                               ---*\n*---     Q. INPUT RECFM = F                                        ---*\n*---            BLKSIZEIN <= BLKSIZE OUT - 4 ??                    ---*\n*---                                                               ---*\n*---     Q. INPUT RECFM = VB                                       ---*\n*---            LRECLIN <= BLKSIZE OUT ??                          ---*\n*---                                                               ---*\n*---     Q. INPUT RECFM = FB                                       ---*\n*---            LRECLIN <= BLKSIZE OUT-4 ??                        ---*\n*---------------------------------------------------------------------*\nDCBC7    DS    0H\n         C     R4,=A(DCBRECV)      V-FORMAT INPUT ??\n         BE    DCBC8               YES ---\n         C     R4,=A(DCBRECU)      U-FORMAT INPUT ??\n         BE    DCBC9               YES ---\n         C     R4,=A(DCBRECF)      F-FORMAT INPUT ??\n         BE    DCBC10\n         C     R4,=A(DCBRECV+DCBRECBR) VB-FORMAT INPUT ??\n         BE    DCBC11              YES ---\n         C     R4,=A(DCBRECF+DCBRECBR) FB-FORMAT INPUT ??\n         BE    DCBC12              YES ---\n         ABEND 998,DUMP            INVALID INPUT RECORD FORMAT\nDCBC8    DS    0H\n         CLC   RSRBLK,DCBBLKSI     INPUT BLKL .LE. OUTPUT BLKL ??\n         BNH   DCBC26              YES; ALL IS OK\n         B     DCBC25              NOPE; FAIL THE VALIDATION\nDCBC9    DS    0H\n         LH    R4,RSRBLK           LOAD INPUT BLKSIZE\n         LA    R4,4(,R4)           ADD 4\n         CH    R4,DCBBLKSI         WILL BLOCKS STILL FIT ??\n         BNH   DCBC26              YES; ALL IS OK\n         B     DCBC25              NOPE; FAIL THE VALIDATION\nDCBC10   DS    0H\n         LH    R4,RSRBLK           LOAD INPUT BLKSIZE\n         LA    R4,4(,R4)           ADD 4\n         CH    R4,DCBBLKSI         WILL BLOCKS STILL FIT ??\n         BNH   DCBC26              YES; ALL IS OK\n         B     DCBC25              NOPE; FAIL THE VALIDATION\nDCBC11   DS    0H\n         CLC   RSRLRE,DCBBLKSI     WILL LRECL FIT INTO BLOCK ??\n         BNH   DCBC26              YES; ALL IS OK\n         B     DCBC25              NOPE; FAIL THE VALIDATION\nDCBC12   DS    0H\n         LH    R4,RSRLRE           LOAD INPUT LRECL\n         LA    R4,4(,R4)           ADD 4\n         CH    R4,DCBBLKSI         WILL IT STILL FIT ??\n         BNH   DCBC26              YES; ALL IS OK\n         B     DCBC25              NOPE; FAIL THE VALIDATION\n*---------------------------------------------------------------------*\n*---     VARIABLE, BLOCKED RECORDS FOR OUTPUT                      ---*\n*---                                                               ---*\n*---     Q. INPUT RECFM = V                                        ---*\n*---            BLKSIZEIN <= LRECL OUT ??                          ---*\n*---                                                               ---*\n*---     Q. INPUT RECFM = U                                        ---*\n*---            BLKSIZEIN <= LRECL OUT - 4 ??                      ---*\n*---                                                               ---*\n*---     Q. INPUT RECFM = F                                        ---*\n*---            BLKSIZEIN <= LRECL OUT - 4 ??                      ---*\n*---                                                               ---*\n*---     Q. INPUT RECFM = VB                                       ---*\n*---            LRECLIN <= LRECL OUT ??                            ---*\n*---                                                               ---*\n*---     Q. INPUT RECFM = FB                                       ---*\n*---            LRECLIN <= LRECL OUT - 4 ??                        ---*\n*---------------------------------------------------------------------*\nDCBC13   DS    0H\n         C     R4,=A(DCBRECV)      V-FORMAT INPUT ??\n         BE    DCBC14              YES ---\n         C     R4,=A(DCBRECU)      U-FORMAT INPUT ??\n         BE    DCBC15              YES ---\n         C     R4,=A(DCBRECF)      F-FORMAT INPUT ??\n         BE    DCBC16\n         C     R4,=A(DCBRECV+DCBRECBR) VB-FORMAT INPUT ??\n         BE    DCBC17              YES ---\n         C     R4,=A(DCBRECF+DCBRECBR) FB-FORMAT INPUT ??\n         BE    DCBC18              YES ---\n         ABEND 998,DUMP            INVALID INPUT RECORD FORMAT\nDCBC14   DS    0H\n         CLC   RSRBLK,DCBLRECL     INPUT BLKL .LE. OUTPUT BLKL ??\n         BNH   DCBC26              YES; ALL IS OK\n         B     DCBC25              NOPE; FAIL THE VALIDATION\nDCBC15   DS    0H\n         LH    R4,RSRBLK           LOAD INPUT BLKSIZE\n         LA    R4,4(,R4)           ADD 4\n         CH    R4,DCBLRECL         WILL BLOCKS STILL FIT ??\n         BNH   DCBC26              YES; ALL IS OK\n         B     DCBC25              NOPE; FAIL THE VALIDATION\nDCBC16   DS    0H\n         LH    R4,RSRBLK           LOAD INPUT BLKSIZE\n         LA    R4,4(,R4)           ADD 4\n         CH    R4,DCBLRECL         WILL BLOCKS STILL FIT ??\n         BNH   DCBC26              YES; ALL IS OK\n         B     DCBC25              NOPE; FAIL THE VALIDATION\nDCBC17   DS    0H\n         CLC   RSRLRE,DCBLRECL     WILL LRECL FIT INTO BLOCK ??\n         BNH   DCBC26              YES; ALL IS OK\n         B     DCBC25              NOPE; FAIL THE VALIDATION\nDCBC18   DS    0H\n         LH    R4,RSRLRE           LOAD INPUT LRECL\n         LA    R4,4(,R4)           ADD 4\n         CH    R4,DCBLRECL         WILL IT STILL FIT ??\n         BNH   DCBC26              YES; ALL IS OK\n         B     DCBC25              NOPE; FAIL THE VALIDATION\n*---------------------------------------------------------------------*\n*---     UNDEFINED-FORMAT RECORDS FOR OUTPUT                       ---*\n*---                                                               ---*\n*---     Q. INPUT RECFM = U ??                                     ---*\n*---            BLKSIZEIN <= BLKSIZE OUT ??                        ---*\n*---                                                               ---*\n*---     Q. INPUT RECFM = V ??                                     ---*\n*---            BLKSIZEIN <= BLKSIZE OUT+4 ??                      ---*\n*---                                                               ---*\n*---     Q. INPUT RECFM = F ??                                     ---*\n*---            BLKSIZEIN <= BLKSIZE OUT ??                        ---*\n*---                                                               ---*\n*---     Q. INPUT RECFM = FB ??                                    ---*\n*---            LRECLIN <= BLKSIZE OUT ??                          ---*\n*---                                                               ---*\n*---     Q. INPUT RECFM = VB ??                                    ---*\n*---            LRECLIN <= BLKSIZE OUT+4 ??                        ---*\n*---                                                               ---*\n*---------------------------------------------------------------------*\nDCBC19   DS    0H\n         C     R4,=A(DCBRECU)      U-FORMAT INPUT ??\n         BE    DCBC20              YES ---\n         C     R4,=A(DCBRECF)      F-FORMAT INPUT ??\n         BE    DCBC21              YES ---\n         C     R4,=A(DCBRECV)      F-FORMAT INPUT ??\n         BE    DCBC22              YES ---\n         C     R4,=A(DCBRECF+DCBRECBR) FB-FORMAT INPUT ??\n         BE    DCBC23              YES ---\n         C     R4,=A(DCBRECV+DCBRECBR) VB-FORMAT INPUT ??\n         BE    DCBC24              YES ---\nDCBC20   DS    0H\n         CLC   RSRBLK,DCBBLKSI     INPUT BKLK .LE. OUTPUT BLKL ??\n         BNH   DCBC26              YES ---\n         B     DCBC25              NOPE; INVALID REBLOCKING\nDCBC21   DS    0H\n         CLC   RSRBLK,DCBBLKSI     INPUT BKLK .LE. OUTPUT BLKL ??\n         BNH   DCBC26              YES ---\n         B     DCBC25              NOPE; INVALID REBLOCKING\nDCBC22   DS    0H\n         LH    R4,RSRBLK           LOAD INPUT BLKSIZE\n         LA    R0,4\n         SR    R4,R0               ACCOUNT FOR BDW\n         CH    R4,DCBBLKSI         WILL IT FIT ??\n         BNH   DCBC26              YES ---\n         B     DCBC25              NOPE; INVALID REBLOCKING\nDCBC23   DS    0H\n         CLC   RSRLRE,DCBBLKSI     INPUT BLKSIZE .LE. OUTPUT BLKSIZE ??\n         BNH   DCBC26              YES ---\n         B     DCBC25              NOPE; INVALID REBLOCKING\nDCBC24   DS    0H\n         LH    R4,RSRLRE           LOAD INPUT LRECL\n         LA    R0,4\n         SR    R4,R0               ACCOUNT FOR BDW\n         CH    R4,DCBBLKSI         WILL IT FIT ??\n         BNH   DCBC26              YES ---\nDCBC25   DS    0H\n         #FORMAT RECTT,,DCBM1\n         #PUT  LINE\n         LA    R15,4\n         L     R13,4(,R13)         LOAD BACK POINTER\n         L     R14,12(,R13)        LOAD RETURN ADDRESS\n         LM    R0,R12,20(R13)      RESTORE REGS\n         BR    R14                 RETURN TO CALLER\nDCBC26   DS    0H\n         LA    R15,0\n         L     R13,4(,R13)         LOAD BACK POINTER\n         L     R14,12(,R13)        LOAD RETURN ADDRESS\n         LM    R0,R12,20(R13)      RESTORE REGS\n         BR    R14                 RETURN TO CALLER\n         LTORG\nDCBM1    DC    AL1(30),CL30' DCB ATTRIBUTES INCOMPATABLE.'\n         LTORG\n         DROP  R2,R3,R11,R12\n         COPY  #RECS\n         COPY  ##ARCHWK\n         DCBD  DSORG=PS,DEVD=DA\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHKNAM": {"ttr": 7686, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00\\x80\\x00\\x80\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 128, "newlines": 128, "modlines": 0, "user": "ARCHIVR"}, "text": "CNAM     TITLE 'ARCHKNAM --- ARCHIVER FUNCTION SUPPORT SUBROUTINE'\n*---------------------------------------------------------------------*\n*---     FUNCTION: CHECK THE NAME IN THE RECORD KEY POINTED TO     ---*\n*---           BY REGISTER 1 AGAINST THE NAME(S) FROM THE          ---*\n*---           CURRENT CONTROL CARD. SET A ZERO RETURN CODE FOR    ---*\n*---           A MATCH OR A 4 FOR A MIS-MATCH.                     ---*\n*---                                                               ---*\n*---     THIS ROUTINE IS INVOKED EXCLUSIVELY VIA #CHKNAM MACRO.    ---*\n*---------------------------------------------------------------------*\n         EJECT\nARCHKNAM CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n         USING ARCHKNAM,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             LOAD ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHKNAM,R11        DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             LOAD NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RELOAD BACK POINTER\n         L     R14,12(,R14)        RELOAD ORIG. REG 14\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         COPY  #ARCBITS\n         L     R15,4(,R13)         LOAD BACK SAVE-AREA POINTER\n         XC    16(4,R15),16(R15)   INITIAL RETURN CODE IS ZERO\n         LA    R2,Q1               INITIALIZE NAME-LIST POINTER\n         LTR   R0,R0               WAS A NAME-LIST PASSED ??\n         BZ    CHK0                NOPE\n         LR    R2,R0               YES; COPY ITS ADDRESS\nCHK0     DS    0H\n         LA    R7,30(,R2)          POINT TO LAST QUALIFIER\n         LA    R6,10               AND QUALIFIER LENGTH\nCHK1     DS    0H\n         BAL   R9,CHKQ             GO CHECK THE QUALIFIER\n         B     NOMATCH             TEST FAILED; SET NOMATCH RETURN CODE\n         LA    R1,10(,R1)          POINT TO NEXT VALUE\n         BXLE  R2,R6,CHK1          AND LOOP, CHECKINGLY\n         #IF   VRS,OFF,MATCH       WAS VERSION NUMBER GIVEN ??\n         ICM   R0,15,0(R1)         LOAD THE VERSION NUMBER\n         C     R0,0(,R2)           DOES IT MATCH ??\n         BNE   NOMATCH             NOPE; FAIL THE TEST\nMATCH    DS    0H\n         L     R13,4(,R13)         LOAD THE BACK POINTER\n         LM    R14,R12,12(R13)     RESTORE ENTRY REGISTERS\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\nNOMATCH  DS    0H\n         L     R15,4(,R13)         LOAD BACK POINTER\n         MVC   16(4,R15),=F'4'     NON-ZERO RETURN CODE FOR FAILURE\n         B     MATCH               AND RETURN TO CALLER\n         TITLE 'GENERIC/NONGENERIC QUALIFIER COMPARISON'\n*---------------------------------------------------------------------*\n*---     WE DO SOME STRANGE THINGS WITH MASKS, 'AND' AND COMPARE   ---*\n*---     INSTRUCTIONS HERE.  THE STEPS ARE RELATIVELY SIMPLE,      ---*\n*---     ONCE THEY'RE UNDERSTOOD, BUT CAN BE A LITTLE STRANGE TO   ---*\n*---     GRASP IF YOU DON'T WORK IT OUT ONCE OR TWICE WITH PAPER   ---*\n*---     AND PENCIL.  THE BASIC STEPS ARE THESE:                   ---*\n*---                                                               ---*\n*---     1. COPY THE QUALIFIER FROM THE CONTROL STATEMENT TO THE   ---*\n*---        GENWK AREA. THEN MAKE A COPY OF IT, IMMEDIATELY        ---*\n*---        FOLLOWING THE FIRST.                                   ---*\n*---                                                               ---*\n*---     2. EVERY PLACE WE HAVE A 'GENERIC' CHARACTER, REPLACE IT  ---*\n*---        WITH A BLANK. ALSO, EVERY NON-GENERIC CHARACTER IS     ---*\n*---        REPLACED WITH A X'FF'.                                 ---*\n*---                                                               ---*\n*---     3. TO MAKE THE COMPARISON, DO THIS:                       ---*\n*---                                                               ---*\n*---        A. 'AND' THE INPUT VALUE WITH THE FIRST MASK. ALL      ---*\n*---           CHARACTERS THAT ARE NOT GENERICS WILL BE UNCHANGED  ---*\n*---           AND ALL GENERICS WILL BE REPLACED BY BLANKS.        ---*\n*---                                                               ---*\n*---        B. COMPARE THE RESULT WITH THE SECOND MASK.  ALL       ---*\n*---           NON-GENERIC CHARACTERS WILL BE CHECKED FOR EXACT    ---*\n*---           MATCHES AND ALL GENERIC CHARACTERS WILL BE BLANKS   ---*\n*---           COMPARED TO BLANKS, MAKING THEM EQUAL.              ---*\n*---                                                               ---*\n*---     SIMPLE, ISN'T IT ??                                       ---*\n*---------------------------------------------------------------------*\nCHKQ     DS    0H\n         MVC   GENWK(10),0(R2)     COPY THE MEMBER NAME\n         MVC   GENWK+10(10),GENWK  AND DUPLICATE IT\n         CLC   =CL10'%%%%%%%%%%',0(R2) ALL ITEMS ??\n         BE    4(,R9)              YES; NOTHING TO FILTER\n         LA    R5,GENWK+9          POINT TO STRING END\n         LA    R3,GENWK            AND STRING START\n         LA    R4,1                AND BXLE INCREMENT\nF1       DS    0H\n         CLI   0(R3),C'%'          GENERIC CHARACTER ??\n         BNE   F2                  NOPE ---\n         MVI   0(R3),C' '          YES; REPLACE WITH A BLANK\n         MVI   10(R3),C' '         YES; REPLACE WITH A BLANK\n         B     F3                  DO OTHER MASK\nF2       DS    0H\n         MVI   0(R3),X'FF'         ANYTHING GOES HERE\nF3       DS    0H\n         BXLE  R3,R4,F1            LOOP FOR MASKS\n*---------------------------------------------------------------------*\n*---     SEARCH MASKS ARE BUILT. NOW DO THE COMPARE                ---*\n*---------------------------------------------------------------------*\nTSTX     DS    0H\n         MVC   GENWK+20(10),0(R1)  COPY THE MEMBER NAME\n         NC    GENWK+20(10),GENWK  MASK OUT THE GENERIC CHARS\n         CLC   GENWK+20(10),GENWK+10 REMAINDER MATCH ??\n         BE    4(,R9)              YES; PASS THE TEST\n         BNE   0(,R9)              NOPE; FAIL THE TEST\n         LTORG\n         COPY  #RECS               INPUT RECORD DSECT\n         COPY  ##ARCHWK            ARCHIVER MAIN WORK AREA\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHLDT": {"ttr": 7689, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x04`\\x04`\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 1120, "newlines": 1120, "modlines": 0, "user": "ARCHIVR"}, "text": "LDT      TITLE 'ARCHIVER --- LOADT FUNCTION'\n*---------------------------------------------------------------------*\n*---     ARCHIVER DIRECT TAPE-LOAD FUNCTION                        ---*\n*---------------------------------------------------------------------*\nARCHLDT  CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n         COPY #ARCBITS\n         USING ARCHLDT,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             LOAD ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHLDT,R11         DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             LOAD NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RELOAD BACK POINTER\n         L     R14,12(,R14)        RELOAD ORIG. REG 14\n         LA    R10,0(,R11)         COPY ORIGINAL BASE REGISTER\n         AH    R10,PASSIT-2        BUMP BY A BASE'S WORTH\n         USING ARCHLDT+4096,R10    AND DECLARE IT\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         #SET  LOADING,OFF         CLEAR STATUS FLAG\n         XC    FCOUNT,FCOUNT       CLEAR FUNCTION RECORD COUNT\n         XC    MCNT,MCNT           AND MEMBER COUNT\n         XC    ACNT,ACNT           AND ALIAS COUNT\n         BAL   R14,QSOPEN          GO OPEN THE EXPORT TAPE\n         BAL   R14,OPNVO           OPEN THE OUTPUT DATASET\n         EJECT\n*---------------------------------------------------------------------*\n*---     HERE'S THE MEAT OF THE PROCESSING. THE BASIC PROCESS IS   ---*\n*---           THIS:                                               ---*\n*---                                                               ---*\n*---     1. USING THE CONTROL INFORMATION WE WERE GIVEN AND THE    ---*\n*---        INFORMATION WE'VE DEVELOPED, READ THROUGH THE INPUT    ---*\n*---        DATASET, LOOKING FOR AN ITEM TO LOAD.  WE'LL USE A     ---*\n*---        GETMAIN'ED AREA, BASED FROM VS1BUF2, TO SAVE EACH      ---*\n*---        'REAL' HEADER RECORD UNTIL THE HEADER AND ALL THE      ---*\n*---        ALIASES ARE CHECKED.                                   ---*\n*---                                                               ---*\n*---     2. LOOP THROUGH THE MEMBER, READING THE RECORDS AND       ---*\n*---        EXPLODING THEM INTO THE BPAM BUFFERS, WRITING AS EACH  ---*\n*---        BUFFER GETS FULL.  THE I/O ROUTINES DESIGNATED BY THE  ---*\n*---        BRANCH INSTRUCTION AT 'BLOCK' WILL DETERMINE THE       ---*\n*---        BLOCKING MECHANISM USED.                               ---*\n*---                                                               ---*\n*---     3. AT END-OF-FILE FOR THE DATASET OR MEMBER, DO ANY STOW  ---*\n*---        THAT MAY BE APPROPRIATE.  FOR PDS MEMBERS WITH         ---*\n*---        ALIASES, WE ALSO STOW THE ALIASES AT THIS POINT.       ---*\n*---------------------------------------------------------------------*\n*---     FIRST, SET UP THE SAVE AREA FOR THE 'REAL' HEADER RECORD. ---*\n*---------------------------------------------------------------------*\n         GETMAIN R,LV=32768,SP=9   GRAB SOME STORAGE\n         ST    R1,VS1BUF2          AND SAVE ITS ADDRESS\nMEMBERS  DS    0H\n         #SET  LOADING,OFF\n         L     R1,ACB1             (ACTUALLY A DCB ADDRESS)\n         GET   (1)                 READ A RECORD\n         LA    R0,0                CLEAR A WORK REGISTER\n         ICM   R0,3,0(R1)          INSERT RECORD LENGTH\n         SH    R0,=H'4'            ACCOUNT FOR RDW\n         ST    R0,VS1LEN1          SAVE RESULT\n         LA    R1,4(,R1)           POINT TO DATA START\n         ST    R1,VS1BUF1          SAVE RECORD ADDRESS\nNEXTHDR  DS    0H\n         #SET  LOADING,OFF\n         L     R6,VS1BUF1          AND COPY FOR LATER USE\n         USING REC,R6              AND BASE THE DSECT\n         L     R1,VS1LEN1          LOAD THE RECORD LENGTH\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   MEMBERS             NOPE; KEEP SEARCHING\nHDRG     DS    0H\n         #IF   RSRALIAS,ON,HDRG1   NOT AN ALIAS RECORD\n         LR    R2,R6               COPY RECORD ADDRESS\n         L     R3,VS1LEN1          AND LOAD ITS LENGTH\n         ST    R3,VS1LEN2          SAVE HEADER LENGTH, FOR LATER\n         L     R14,VS1BUF2         POINT TO HEADER SAVE AREA\n         LR    R15,R3              AND SET LENGTH TO COPY\n         MVCL  R14,R2              SAVE THE HEADER FOR LATER REFERENCE\nHDRG1    DS    0H\n         #IF   RSRALIAS,OFF,HDRG2  NOT AN ALIAS RECORD ??\n         #IF   LDARCHA,OFF,MEMBERS NO ALIASES CHECKED ??\nHDRG2    DS    0H\n         LA    R1,RECN             POINT TO THE HEADER\n         LA    R0,0                USE DEFAULT QUALIFIER DATA\n         CALL  ARCHKNAM            GO CHECK: DO WE PROCESS THIS ITEM ??\n         LTR   R15,R15             PASS THE CHECK ??\n         BNZ   MEMBERS             NOPE ---\nREAL     DS    0H\n         L     R1,VS1BUF2          POINT TO THE HEADER RECORD AGAIN\n         L     R6,VS1BUF2          POINT TO THE HEADER RECORD AGAIN\n         CALL  ARCHKDCB            GO COMPARE DCB'S\n         LTR   R15,R15             STILL OK ??\n         BNZ   MEMBERS             NOPE; SKIP THIS ITEM\n         #IF   NVSPO,OFF,NOTPO     CHECK THE DSORG FLAG\n         #IF   REPL,ON,NOTPO       REPLACE ANYHOW\n         MVC   BLDLAREA(4),=AL2(1,76)\n         MVC   BLDLAREA+4(8),RECN  COPY THE MEMBER NAME IN\n         L     R2,NDCBA            LOAD THE DCB ADDRESS\n         BLDL  (2),BLDLAREA        CHECK: IS THE MEMBER THERE ??\n         LTR   R15,R15             WAS IT FOUND ??\n         BNZ   NOTPO               NOPE; CONTINUE ---\n         #FORMAT RECTT,,STOWM1\n         #PUT  LINE\n         B     MEMBERS             AND GO FOR NEXT ITEM\nNOTPO    DS    0H\n         #SET  LOADING,ON          SET 'SELECTED FOR LOAD' STATUS\n         CLI   RSRDSO,DCBDSGPO     IS IT A PO MEMBER UNLOADED ??\n         BNE   NODIR               NOPE ---\n         LA    R1,0                CLEAR A WORK REGISTER\n         IC    R1,RSRPDIR+11       LOAD DIR ENTRY LENGTH\n         N     R1,=A(X'1F')        TRIM TO BARE LENGTH\n         SLL   R1,1                TIMES TWO\n         LA    R1,11(,R1)          COMPUTE TOTAL ENTRY LENGTH\n         EX    R1,NODIR-6          COPY DIR TO BLDLAREA\n         B     NODIR               AND GO ---\n         MVC   BLDLAREA(1),RSRPDIR 'EX'ED COPY OF DIR ENTRY\nNODIR    DS    0H\n         L     R1,VS1BUF2          COPY THE HEADER ADDRESS\n         BAL   R14,IOSEP           GO DO A SEPARATOR (MAYBE)\n         L     R6,VS1BUF1          RELOAD HEADER RECORD ADDRESS\n         L     R7,VS1BUF2          LOAD SAVE-HEADER AREA POINTER\nLDPRE    DS    0H\n         L     R1,ACB1             LOAD THE DCB ADDRESS\n         GET   (1)                 READ THE NEXT RECORD\n         CLI   4(R1),#RTHDR        HEADER RECORD ??\n         BNE   LDLP1               NOPE; START PROCESSING\n         B     LDPRE               YES; SKIP IT ---\nLDLOOP   DS    0H\n         L     R1,ACB1             POINT TO THE TAPE DCB\n         GET   (1)                 GO READ A TAPE RECORD\nLDLP1    DS    0H\n         LA    R0,0                CLEAR A WORK RECORD\n         ICM   R0,3,0(R1)          LOAD THE LENGTH\n         SH    R0,=H'4'            ACCOUNT FOR RDW\n         ST    R0,VS1LEN1          SAVE THE LENGTH\n         LA    R6,4(,R1)           POINT PAST THE RDW\n         ST    R6,VS1BUF1          AND SAVE RECORD ADDRESS\n         CLI   0(R6),#RTHDR        HEADER RECORD ??\n         BE    LDDONE              YES; LOAD NEARLY COMPLETE\n         CLI   0(R6),#RTDATA       DATA RECORD ??\n         BNE   LDLOOP              NOPE; KEEP LOOKING\n         CLC   1(RECKLEN-5,R6),1(R7) STILL IN THE RIGHT ITEM ??\n         BNE   LDDONE              NOPE; DO STOWS 'N' STUFF\n         LA    R3,RDATDATA         POINT TO ITEM DATA\n         L     R4,VS1LEN1          LOAD RECORD LENGTH\n         LA    R4,0(R4,R6)         POINT TO\n         BCTR  R4,R0                 LAST DATA BYTE\nWRTLOOP  DS    0H\n         L     R0,TCOUNT           LOAD THE RECORD COUNT\n         A     R0,=F'1'            COUNT THIS RECORD\n         ST    R0,TCOUNT           STORE UPDATED COUNT\n         LA    R0,0                CLEAR REGISTER ZERO\n         ICM   R0,7,0(R3)          LOAD SEGMENT LENGTH\n         LA    R1,3(,R3)           POINT TO SEGMENT START\n         BAL   R14,PUT             GO WRITE A LOGICAL RECORD\n         LA    R0,0                CLEAR REGISTER ZERO\n         ICM   R0,7,0(R3)          LOAD SEGMENT LENGTH\n         AR    R3,R0               BUMP TO\n         LA    R3,3(,R3)             NEXT SEGMENT\n         CR    R3,R4               ANOTHER SEGMENT TO PROCESS ??\n         BL    WRTLOOP             YES ---\n         B     LDLOOP              NOPE ---\nENDLOAD  DS    0H\n         #SET  EOT,ON\n         #IF   LOADING,OFF,ENDITALL\nLDDONE   DS    0H\n         #SET  NOEXP,ON            NOTE LIST ALREADY EXPANDED\n         L     R1,NOTELIST         LOAD NOTELIST POINTER\n         LTR   R1,R1               WAS ANY PRESENT ??\n         BZ    LDDN1               NOPE ---\n         L     R0,0(,R1)           LOAD ITS LENGTH\n         SH    R0,=H'4'            ACCOUNT FOR TTR WORD\n         LA    R1,4(,R1)           POINT TO ACTUAL DATA\n         BAL   R14,PUT             GO WRITE THE NOTE LIST\n         L     R1,NOTELIST\n         L     R0,0(,R1)           LOAD ITS LENGTH\n         ICM   R0,8,=AL1(10)       INSERT SUBPOOL NUMBER\n         FREEMAIN R,LV=(0),A=(1)\nLDDN1    DS    0H\n         #SET  NOEXP,OFF\n         XC    NOTELIST,NOTELIST   AND RESET THE POINTER\n         LA    R0,0                ZERO LENGTH RECORD\n         BAL   R14,PUT             AND PURGE THE BUFFERS\n         L     R6,VS1BUF2          POINT BACK TO HEADER RECORD\n         LR    R0,R6               COPY RECORD ADDRESS\n         A     R0,VS1LEN2          POINT TO RECORD END\n         LA    R1,RSRPDIR          POINT TO DIRECTORY DATA\n         SR    R0,R1               COMPUTE DIRDATA LENGTH\n         BAL   R14,ENDSEP          TRAILING SEPARATORS FOR PS OUTPUT\n         BAL   R14,PDSSTOW         GO DO STOWS (MAYBE)\n         #IF   EOT,ON,ENDITALL     STOP AT TAPE END\n         #IF   GENM,ON,NEXTHDR     LOOP IF GENERIC NAME\n         #IF   GENG,ON,NEXTHDR     LOOP IF GENERIC GROUP\n         #IF   GENSG,ON,NEXTHDR    LOOP IF GENERIC SUBGROUP\n         #IF   GENT,ON,NEXTHDR     LOOP IF GENERIC TYPE\nENDITALL DS    0H\n         L     R0,TCOUNT           LOAD TOTAL RECORD COUNT\n         A     R0,FCOUNT           ADD FUNCTION COUNT\n         ST    R0,TCOUNT           SAVE UPDATED COUNT\n         #ERR  MSG=10\n         L     R0,TCOUNT           LOAD TOTAL-RECORD COUNT\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,TCMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\n         L     R0,MCNT             LOAD MEMBER COUNT\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,MCMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\n         L     R0,ACNT             LOAD ALIAS COUNT\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,ACMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\n         CLC   ACB1,=F'0'          WAS ACB EVER OPENED ??\n         BE    NOACB               NOPE ---\n         BAL   R14,QSCLOSE         CLOSE THE VSAM CLUSTER\nNOACB    DS    0H\n         BAL   R14,NVSCLOSE        GO CLOSE THE INPUT FILE\n         L     R13,4(,R13)         LOAD BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ALWAYS RC = 0\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\n         TITLE 'OPEN NONVSAM OUTPUT DATASET '\n*---------------------------------------------------------------------*\n*---     THIS LITTLE LOCAL SUBROUTINE DOES SEVERAL THINGS          ---*\n*---     NECESSARY PRIMARILY FOR LOAD-MODULE RECOGNITION AND       ---*\n*---     PROCESSING. FIRST AND FOREMOST, WE DETERMINE THE DSORG    ---*\n*---     OF THE OUTPUT DATASET. IF OUTPUT IS A SEQUENTIAL          ---*\n*---     DATASET, WE CAN ASSUME THAT ONLY ONE DCB WILL BE NEEDED.  ---*\n*---     IF THE OUTPUT DATASET IS A PDS, WE NEED AT LEAST TWO      ---*\n*---     DCBS; ONE FOR DATA AND ANOTHER FOR THE DIRECTORY          ---*\n*---     INFORMATION PROCESSED BY ARCHDIR.  HERE'S A VERY          ---*\n*---     SIMPLISTIC VIEW OF THE PROCESSING HERE.  (FURTHER MODS    ---*\n*---     FOR PROCESSING PANVALET LIBRARIES ARE PLANNED BUT NOT     ---*\n*---     YET IMPLEMENTED.)                                         ---*\n*---                                                               ---*\n*---     1. DETERMINE THE DSORG OR THE DATASET. IF NOT PS OR PO,   ---*\n*---        WRITE NASTY MESSAGES TO THE USER AND QUIT RIGHT HERE.  ---*\n*---                                                               ---*\n*---     2. BUILD AND OPEN THE PRIMARY DCB.  SINCE WE USE BSAM     ---*\n*---        FOR OUTPUT OF SEQUENTIAL DATASETS, WE CAN (ALMOST)     ---*\n*---        USE THE SAME DCB FOR BOTH SEQUENTIAL AND PARTITIONED   ---*\n*---        DATASETS.  WE ONLY NEED TO CHANGE THE DSORG VALUE IN   ---*\n*---        THE DCB.  DURING THE 'OPEN' PROCESS, AN EXIT WILL      ---*\n*---        BUILD A BUFFER POOL OF TWO BUFFERS.  BUFFERS ARE       ---*\n*---        'GETBUF'ED AND SAVED IN THE ARCHIVER MAIN WORK AREA.   ---*\n*---                                                               ---*\n*---     3. IF THE DSORG IS PO AND RECFM = U, WE NEED ONE          ---*\n*---        ADDITIONAL STEP: BUILD AN ADDITIONAL DCB AND OPEN IT   ---*\n*---        FOR 'UPDAT' I/O.  THIS WILL BE USED BY THE MAINLINE    ---*\n*---        CODE TO UPDATE NOTE LISTS IN LOAD MODULES, IF WE HAVE  ---*\n*---        ANY.                                                   ---*\n*---                                                               ---*\n*---     NOTE: THE ARCHIVER MAKES NO ATTEMPT TO REASSEMBLE OR      ---*\n*---     RECONSTRUCT A SPANNED RECORD.                             ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nOPNVO    DS    0H\n         STM   R14,R12,IOSAVE      SAVE THE ENTRY REGISTERS\n*        #IF   NVPAN,ON,PANOPEN    REALLY A PANLIB ??\n*---\n*---     BUILD A DCB, TO START, FOR DSORG CHECKING\n*---\n         GETMAIN R,LV=BSDCBL,SP=10 GRAB STORAGE FOR BPAM DCB\n         ST    R1,NDCBA            AND STORE ADDRESS IN ARCHIVWA\n         MVI   NDCBA,X'80'         BUILD OPEN PARM LIST\n         MVC   0(BSDCBL,R1),BSDCB  COPY DCB TO DYNAMIC AREA\n         USING IHADCB,R1           BASE THE DCB DSECT\n         MVC   DCBDDNAM,NVSAMDD    MOVE IN THE DDNAME\n         DROP  R1\n*---\n*---     GET THE VOLSER FROM THE UCB, STARTING FROM THE TIOT.\n*---\n         NC    TIOTA,TIOTA         HAVE WE ALREADY DONE THIS ??\n         BNZ   OPNVO1              YES ---\n         MVC   CALLIST(EXTL),EXTRPARM COPY PARMLIST FOR EXTRACT\n         EXTRACT TIOTA,'S',FIELDS=TIOT,MF=(E,CALLIST) LOCATE THE TIOT\n         L     R1,TIOTA            LOAD THE TIOT POINTER\n         LA    R1,24(,R1)          POINT TO THE FIRST TIOE\n         ST    R1,TIOTA            SAVE UPDATED ADDRESS\nOPNVO1   DS    0H\n         L     R1,TIOTA            LOAD TIOT ELEMENT POINTER\nOPNVO2   DS    0H\n         CLI   0(R1),0             AT TIOT END ??\n         BE    NODDERR             YES; DD STATEMENT IS MISSING\n         CLC   NVSAMDD,4(R1)       IS THIS THE DD ENTRY ??\n         BE    OPNVO3              YES; GO FETCH UCB ADDR\n         IC    R0,0(,R1)           INSERT TIOE LENGTH\n         N     R0,=F'255'          TRIM TO JUST THE LENGTH\n         AR    R1,R0               BUMP TO NEXT ENTRY\n         B     OPNVO2              AND CONTINUE THE SEARCH\nOPNVO3   DS    0H\n         L     R1,16(,R1)          LOAD UCB POINTER\n         N     R1,=A(X'FFFFFF')    TRIM GARBAGE BYTES\n         MVC   VOLSER,28(R1)       COPY THE VOLSER\n         MVC   DEVT,16(R1)         AND UCB TYPE\n         TM    DEVT+2,X'A0'        IS THIS A DASD OR TAPE DEVICE ??\n         BZ    ERRDEV              NOPE; INVALID AS HELL\n*---\n*---     GET THE DSNAME. DISREGARD ANY MEMBER NAME\n*---\n         L     R2,NDCBA            LOAD THE DCB ADDRESS\n         USING IHADCB,R2           AND BASE ITS DSECT\n         LA    R0,DCBJFC           LOAD EXIT LIST POINTER\n         STCM  R0,7,DCBEXLSA       SAVE IN THE DCB\n         LA    R0,JFC              POINT TO JFCB AREA\n         ST    R0,DCBJFC           SAVE IN EXIT LIST\n         MVI   DCBJFC,X'87'        EXIT TYPE, LAST FLAG\n         RDJFCB ,MF=(E,NDCBA)      READ THE JFCB\n         DROP  R2\n*---\n*---     BUILD AND EXECUTE THE CAMLIST/OBTAIN SEQUENCE IF DASD\n*---     DATASET. USE THE FORMAT-1 DSCB TO DETERMINE IF THE\n*---     DATASET IS PARTITIONED OR SEQUENTIAL.  IF THE DATASET\n*---     IS SEQUENTIAL OR TAPE, WE BYPASS ANY BPAM STUFF.\n*---\n         TM    DEVT+2,X'80'        IS IT A TAPE DEVICE ??\n         BO    OPNVO4              YES; ALWAYS SEQUENTIAL\n         MVC   CALLIST(LCAMLST),CAMLST COPY CAMLIST TO WORK AREA\n         LA    R0,JFC              LOAD DSNAME POINTER\n         ST    R0,CALLIST+4        SAVE IN CAMLIST AREA\n         LA    R0,VOLSER           POINT TO VOLSER\n         ST    R0,CALLIST+8        SAVE IN CAMLIST AREA\n         LA    R0,GENWK            POINT TO DSCB AREA\n         ST    R0,CALLIST+12       SAVE IN CAMLIST AREA\nGETDSCB  DS    0H\n         OBTAIN CALLIST            FETCH THE DSCB\n         LA    R1,GENWK            POINT TO THE WORK AREA\n         USING DS1FMTID,R1         AND BASE THE DSECT PORTION\n         TM    DS1DSORG,DS1DSGPS   SEQUENTIAL ??\n         BO    OPNVO4              YES ---\n         TM    DS1DSORG,DS1DSGPO   PARTITIONED ??\n         BO    OPNVO5              YES ---\n         B     ORGERR              UNABLE TO PROCESS ANY OTHER DSORG\n         DROP  R1\n*---\n*---     SET THE DSORG IN THE PRIMARY DCB ACCORDING TO THE VALUE\n*---     FOUND IN THE FORMAT-1 DSCB.  ALSO, SET A PAIR OF SPECIAL\n*---     FLAGS IN THE ARCHIVER WORK AREA.  THIS ALLOWS ME TO\n*---     DETERMINE IF I'M REALLY PROCESSING A PDS, REQUIRING\n*---     FIND'S, ETC. OR JUST BE WARY OF AN END-OF-FILE THAT WILL\n*---     ULTIMATELY TERMINATE THE PROCESS.  IT ALSO DETERMINES\n*---     WHETHER I NEED A DIRECTORY DCB, FOR LATER.\n*---\nOPNVO4   DS    0H\n         #SET  NVSPS,ON            SET THE DSORG FLAG\n         #SET  NVSPO,OFF           SET THE DSORG FLAG\n         L     R2,NDCBA            LOAD DCB ADDRESS\n         USING IHADCB,R2\n         MVC   0(BSDCBL,R2),BSDCB  COPY IN THE PROPER DCB\n         MVC   DCBDDNAM,NVSAMDD    MOVE IN THE DDNAME\n         DROP  R2\n         CLC   SEPVAL,=CL8'IEBUPDTE' IEBUPDTE-TYPE SEPARATORS ??\n         BNE   OPNVO4A             NOPE ---\n         MVC   IOSEP(2),=X'47F0'\n         MVC   IOSEP+2(2),=S(SEPUPDTE)\nOPNVO4A  DS    0H\n         B     OPNVO6              GO SET UP THE VSAM I/O BLOCKS,ETC.\nOPNVO5   DS    0H\n         #SET  NVSPO,ON            SET THE DSORG FLAG\n         #SET  NVSPS,OFF           SET THE DSORG FLAG\n         L     R2,NDCBA            LOAD DCB ADDRESS\n         USING IHADCB,R2\n         MVC   0(PODCBL,R2),PODCB  COPY IN THE PROPER DCB\n         MVC   DCBDDNAM,NVSAMDD    MOVE IN THE DDNAME\n         DROP  R2\nOPNVO6   DS    0H\n*---\n*---     SET THE ADDRESS OF MY 'COMPLETION' EXIT INTO THE DCB AND\n*---     PROCEED WITH THE NECESSARY OPEN, ETC.\n*---\n         L     R2,NDCBA            POINT TO PRIMARY DCB\n         USING IHADCB,R2\n         LA    R0,OPNVO13          LOAD EXIT LIST POINTER\n         STCM  R0,7,DCBEXLSA       SAVE IN THE DCB\n         OPEN  (,OUTPUT),MF=(E,NDCBA) OPEN THE DCB\n*---\n*---     GRAB A PAIR OF BUFFERS FROM THE POOL BUILT DURING OPEN\n*---     PROCESSING.\n*---\n         GETBUF (2),(3)            GRAB A BUFFER\n         GETBUF (2),(4)            AND ANOTHER BUFFER\n         LA    R0,4                INITIAL RECORD LENGTH\n         SLL   R0,16               CREATE BDW VALUE\n         ST    R0,0(,R3)\n         ST    R0,0(,R4)\n         STM   R3,R4,BPBUF1        SAVE POINTERS IN WORK AREA\n         ST    R3,BLOCKWDS         START OF BUFFER\n         XC    BLOCKWDS+4(4),BLOCKWDS+4 BLOCK IS EMPTY YET ---\n         #SET  BUFUSED,OFF         ALL BUFFERS EMPTY\n         #SET  IOGOING,OFF         NO I/O IN PROGRESS\n         MVC   BLOCK,=X'47F0E000'  INITIALIZE ---\n         MVC   NVSRECFM,DCBRECFM   COPY THE RECORD FORMAT\n         MVC   NVSBLKL,DCBBLKSI    AND BLKSIZE\n         MVC   NVSLRECL,DCBLRECL   AND LRECL\n*---\n*---     USING THE RECFM AS A GUIDE, SET THE S-TYPE ADDRESS OF\n*---     THE APPROPRIATE DEBLOCKER INTO THE BRANCH INSTRUCTION AT\n*---     'BLOCK'\n*---\n         TM    DCBRECFM,DCBRECU    U-FORMAT ??\n         BNO   OPNVO7              NOPE ---\n         MVC   BLOCK+2(2),=S(PUTU) SET 'U' ROUTINE\n         B     OPNVO12             SCAT ---\nOPNVO7   DS    0H\n         TM    DCBRECFM,DCBRECV+DCBRECBR VB FORMAT ??\n         BNO   OPNVO8              NOPE ---\n         MVC   BLOCK+2(2),=S(PUTVB) SET 'VB' ROUTINE\n         B     OPNVO12             SCAT ---\nOPNVO8   DS    0H\n         TM    DCBRECFM,DCBRECF+DCBRECBR FB FORMAT ??\n         BNO   OPNVO9              NOPE ---\n         MVC   BLOCK+2(2),=S(PUTFB) SET 'FB' ROUTINE\n         B     OPNVO12             SCAT ---\nOPNVO9   DS    0H\n         TM    DCBRECFM,DCBRECV    V FORMAT ??\n         BNO   OPNVO10             NOPE ---\n         MVC   BLOCK+2(2),=S(PUTV) SET 'V' ROUTINE\n         B     OPNVO12             SCAT ---\nOPNVO10  DS    0H\n         TM    DCBRECFM,DCBRECF    V FORMAT ??\n         BNO   OPNVO11             NOPE ---\n         MVC   BLOCK+2(2),=S(PUTF) SET 'F' ROUTINE\n         B     OPNVO12             SCAT ---\nOPNVO11  DS    0H\n         #PUT  =CL133'- UNABLE TO DETERMINE NONVSAM DATASET FORMAT'\n         ABEND 999,DUMP\nOPNVO12  DS    0H\n         L     R0,=F'32768'        LOAD COMPRESS MAX LENGTH\n         ICM   R0,8,=AL1(10)       INSERT SUBPOOL NUMBER\n         GETMAIN R,LV=(0)\n         STM   R0,R1,CMPWRKL       STORE COMPRESS WORK-AREA ADDRESS\n         LM    R14,R12,IOSAVE      RELOAD ENTRY REGISTERS\n         BR    R14                 AND RETURN TO LOCAL CALLER\n         DROP  R2\n*---\n*---     THIS IS A SHORT AND SNEAKY DCB COMPLETION EXIT. ITS ONLY\n*---     PURPOSE IS TO ESTABLISH THE BUFFER POOL FOR THE PRIMARY\n*---     DCB. THIS POOL CONTAINS TWO BUFFERS, EACH BEING 4 BYTES\n*---     LONGER THAN THE BLKSIZE OF THE DCB.\n*---\n*---     NOTE: THE GETPOOL ROUTINE WILL FAIL IF THE HIGH-ORDER\n*---     BIT OF THE DCB ADDRESS IS NOT ZERO. SOME SPECIAL GLITCH\n*---     IN THE IECQBFG1 CODE FOR A SPECIAL APPLICATION\n*---     SOMEWHERE.\n*---\nOPNVO13  DS    0F\n         DC    XL1'85',AL3(OPNVO13+4)\n         USING IHADCB,R1\n         LA    R1,0(,R1)           PURIFY DCB ADDRESS\n         LH    R0,DCBBLKSI         LOAD THE BLKSIZE\n         AH    R0,=H'4'            FOR LATER ---\n         ICM   R0,12,=H'2'         BUFFER COUNT\n         GETPOOL (1),(0)           BUILD A BUFFER POOL\n         DROP  R1\n         BR    R14                 AND RETURN TO O/C/EOV\n         TITLE 'BSAM/BPAM CLOSE ROUTINE'\n*---------------------------------------------------------------------*\n*---     THIS LITTLE ROUTINE CLOSES THE NONVSAM DATASET (ALL       ---*\n*---     DCB'S), RELEASES ALL BUFFER POOLS, RESETS POINTER         ---*\n*---     VALUES, RELEASE THE COMPRESSION WORK AREA AND CLEANS UP   ---*\n*---     THE NONVSAM I/O IN GENERAL, INCLUDING THE RESETING OF     ---*\n*---     ANY FLAG BITS.                                            ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nNVSCLOSE DS    0H\n         STM   R14,R12,IOSAVE      SAVE THE ENTRY REGISTERS\n         L     R2,NDCBA            LOAD PRIMARY DCB ADDRESS\n         LA    R2,0(,R2)           PURIFY THE ADDRESS\nNVSCX    DS    0H\n         LTR   R2,R2               ZERO ??\n         BZ    NVC1                YES; NO DCB HERE ---\n         TM    48(R2),X'10'        IS IT OPEN ??\n         BZ    NVCA                NOPE ---\n         CLOSE MF=(E,NDCBA)        CLOSE THE DCB\nNVCA     DS    0H\n         #FREE (2)                 RELEASE BUFFER POOL, IF ANY\n         XC    NDCBA,NDCBA         AND RESET THE POINTER FIELD\nNVC1     DS    0H\n         XC    DEVT,DEVT           CLEAR SAVED VALUES\n         XC    NVSDSORG,NVSDSORG\n         XC    VOLSER,VOLSER\n         XC    BLOCKWDS(8),BLOCKWDS\n         XC    NVSRECFM,NVSRECFM\n         XC    NVSBLKL,NVSBLKL\n         XC    NVSLRECL,NVSLRECL\n         XC    BPBUF1,BPBUF1\n         XC    BPBUF2,BPBUF2\nNOCMPW   DS    0H\n         XC    CMPWRKL(8),CMPWRKL\n         MVC   BLOCK+2(2),=S(0(R14))\n         #SET  IOGOING,OFF\n         #SET  BUFUSED,OFF\n         #SET  TRUNC,OFF\n         #SET  NVSPS,OFF\n         #SET  NVSPO,OFF\n         LM    R14,R12,IOSAVE      RESTORE THE REGISTERS\n         BR    R14                 AND RETURN TO CALLER\n         TITLE 'DIRECTORY ''STOW'' SUBROUTINE'\n*---------------------------------------------------------------------*\n*---     THIS LOCAL SUBROUTINE TAKES CARE OF ALL STOW PROCESSING.  ---*\n*---     FUNCTIONS INCLUDE UPDATING TTR'S IN THE DIRECTORY ENTRY   ---*\n*---     AND STOWING ALIAS DATA, WHERE APPROPRIATE.                ---*\n*---------------------------------------------------------------------*\nPDSSTOW  DS    0H\n         STM   R14,R12,IOSAVE      SAVE ENTRY REGISTERS\n         LR    R5,R1               COPY DIRDATA POINTER\n         LR    R3,R0               COPY DIRDATA LENGTH\n         LA    R3,0(R3,R5)         POINT TO END\n         BCTR  R3,R0               DECREMENT, FOR LOOPING ---\n         MVC   BLOCKWDS,BPBUF1     START OF BUFFER\n         XC    BLOCKWDS+4(4),BLOCKWDS+4 BLOCK IS EMPTY YET ---\n         #SET  BUFUSED,OFF         ALL BUFFERS EMPTY\n         #SET  IOGOING,OFF         NO I/O IN PROGRESS\n         CR    R5,R3               ANYTHING TO STOW ??\n         BH    STOWDONE            NOPE; ALL DONE\n         #IF   NVSPS,ON,STOWPS     SEQUENTIAL OUTPUT ??\n         L     R2,NDCBA            LOAD PDS DCB ADDRESS\n         LA    R2,0(,R2)           AND PURIFY ADDRESS\n         LM    R7,R8,BPBUF1        LOAD BUFFER ADDRESSES\n         MVC   0(4,R7),=X'00040000' RE-INIT FOR VB\n         MVC   0(4,R8),=X'00040000' RE-INIT FOR VB\n         LM    R7,R9,BLDLAREA+8    LOAD TTR DATA FROM BLDLAREA\nSTOW1    DS    0H\n         CR    R5,R3               ANYTHING TO STOW ??\n         BH    STOWDONE            NOPE; ALL DONE\n         LA    R4,0                CLEAR A WORK REGISTER\n         IC    R4,11(,R5)          LOAD DIR LENGTH BYTE\n         N     R4,=A(X'1F')        TRIM TO BARE LENGTH\n         LA    R4,11(R4,R4)        COMPUTE LENGTH TO MOVE\n         EX    R4,DIRMOVE          COPY TO BLDLAREA\n         LA    R5,1(R4,R5)         BUMP INPUT POINTER\n         STCM  R7,14,BLDLAREA+8    SAVE MEMBER TTR\n         TM    BLDLAREA+11,B'01100000' ANY TTR'S IN USER DATA ??\n         BZ    STOW2               NOPE ---\n         STCM  R8,14,BLDLAREA+12   FIRST TEXT RCD (MAYBE)\n         TM    BLDLAREA+11,B'01000000' SECOND TTR IN USER DATA ??\n         BZ    STOW2               NOPE ---\n         STCM  R9,14,BLDLAREA+16   NOTE LIST (MAYBE)\nSTOW2    DS    0H\n         TM    BLDLAREA+11,X'80'   IS THIS AN ALIAS ??\n         BO    ALCNT               YES ---\n         L     R14,MCNT            LOAD MEMBER COUNT\n         A     R14,=F'1'           INCREMENT BY ONE\n         ST    R14,MCNT            STORE UPDATED COUNT\n         B     STOWD               GO ---\nALCNT    DS    0H\n         L     R14,ACNT            LOAD MEMBER COUNT\n         A     R14,=F'1'           INCREMENT BY ONE\n         ST    R14,ACNT            STORE UPDATED COUNT\nSTOWD    DS    0H\n         STCM  R7,14,BLDLAREA+8    INSERT THE TTR\n         TM    BLDLAREA+11,X'80'   ALIAS ??\n         BO    *+10\n         XC    BLDLAREA+8(3),BLDLAREA+8\n         #STOW (2),BLDLAREA        STOW (MAYBE) MEMBER NAME\n         LR    R1,R15\nSTOWE    DS    0H\n         ICM   R7,14,BLDLAREA+8    INSERT THE TTR\n         LR    R15,R1\n         SRL   R15,2               DIVIDE BY FOUR\n         MH    R15,=H'51'          RC. TIMES MESSAGE LENGTH\n         LA    R15,STOWM(R15)      POINT TO THE MESSAGE\n         #FORMAT RECTT,,0(,R15)\n         TM    BLDLAREA+11,X'80'   ALIAS NAME ??\n         BZ    NOTALIAS            NOPE ---\n         LR    R1,R0               POINT TO NEXT AREA\n         MVC   0(7,R1),=CL7'(ALIAS)'\nNOTALIAS DS    0H\n         MVC   LINE+2(8),BLDLAREA  COPY THE REAL NAME OVER\n         #PUT  LINE\n         B     STOW1               AND CONTINUE ---\nDIRMOVE  MVC   BLDLAREA(1),0(R5)\nSTOWDONE DS    0H\n         LM    R14,R12,IOSAVE      RESTORE REGISTERS\n         BR    R14                 AND RETURN TO LOCAL CALLER\nSTOWPS   DS    0H\n         L     R14,MCNT            LOAD MEMBER COUNT\n         A     R14,=F'1'           INCREMENT BY ONE\n         ST    R14,MCNT            STORE UPDATED COUNT\n         #FORMAT RECTT,,SEQMSG     SEQUENTIAL DATASET MESSAGE\n         #PUT  LINE\n         B     STOWDONE            AND RETURN TO LOCAL CALLER\nSEQMSG   DC    AL1(50),CL50' ADDED TO SEQUENTIAL OUTPUT DATASET.'\nSTOWM    DC    AL1(50),CL50' SUCCESSFULLY STOWED IN PDS.'\nSTOWM1   DC    AL1(50),CL50' NOT REPLACED IN OUTPUT PDS.'\n         DC    AL1(50),CL50' '\n         DC    AL1(50),CL50' NOT STOWED. DIRECTORY OF PDS IS FULL.'\n         DC    AL1(50),CL50' NOT STOWED. PERMANENT I/O ERROR.'\n         DC    AL1(50),CL50' NOT STOWED. DCB INCORRECT OR NOT OPEN.'\n         DC    AL1(50),CL50' NOT STOWED. GETMAIN WITHIN STOW FAILED.'\n         DC    AL1(50),CL50' REPLACED IN OUTPUT PDS'\n         DC    AL1(50),CL50' '\n         DC    AL1(50),CL50' NOT FOUND. ADD ASSUMED.'\n         DC    AL1(50),CL50' NOT STOWED. DIRECTORY OF PDS IS FULL.'\n         DC    AL1(50),CL50' NOT STOWED. PERMANENT I/O ERROR.'\n         DC    AL1(50),CL50' NOT STOWED. DCB INCORRECT OR NOT OPEN.'\n         DC    AL1(50),CL50' NOT STOWED. GETMAIN WITHIN STOW FAILED.'\n         TITLE 'BSAM/BPAM WRITE ROUTINES '\n*---------------------------------------------------------------------*\n*---     REGS AT ENTRY:                                            ---*\n*---              R0 ::= LOGICAL RECORD LENGTH                     ---*\n*---              R1 --> LOGICAL RECORD                            ---*\n*---              R14 -> RETURN ADDRESS                            ---*\n*---                                                               ---*\n*---     IN THE SPECIAL CASE OF RECFM=U, R1 WILL ACTUALLY POINT    ---*\n*---     TO THE TTR WORD THAT PREFIXES THE DATA. R0 WILL BE ALSO   ---*\n*---     BE ADJUSTED TO REFLECT THIS FACT.                         ---*\n*---                                                               ---*\n*---     THE BUFUSED FLAG DENOTES A BUFFER WITH GOOD STUFF IN IT   ---*\n*---     BUT NO WRITE HAS STARTED FOR IT YET.                      ---*\n*---                                                               ---*\n*---     THE SPECIAL CASE OF A RECORD LENGTH OF ZERO SIGNALS A     ---*\n*---     REQUEST TO WRITE ALL REMAINING DATA, SIMILAR TO A QSAM    ---*\n*---     'TRUNC' MACRO.  THIS IS TYPICALLY NECESSARY WHEN THE      ---*\n*---     LAST BLOCK OF THE MEMBER IS NOT FULL.                     ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nPUT      DS    0H\n         STM   R14,R12,IOSAVE      SAVE INPUT REGISTERS\n         #SET  TRUNC,OFF           NOT YET, ANYWAY\n         L     R9,NDCBA            LOAD DCB ADDRESS\n         USING IHADCB,R9           AND BASE ITS DSECT\n         LR    R2,R1               AND ADDRESS\n         LTR   R3,R0               ANYTHING TO ADD ??\n         BNZ   EXPDR               YES ---\n         #SET  TRUNC,ON            NOPE; SET 'TRUNC' FLAG\n         B     BLOCK               GO TO THE BLOCK/WRITE ROUTINE\nEXPDR    DS    0H\n         #IF   NOEXP,ON,BLOCK\n         L     R4,CMPWRK           POINT TO EXPAND OUTPUT AREA\n         ST    R4,IOSAVE+12        SAVE EXPANDED RECORD ADDRESS\n         LH    R3,0(,R2)           LOAD EXPANDED RECORD LENGTH\n         ST    R3,IOSAVE+8         SAVE NEW RECORD LENGTH\n         LA    R2,2(,R2)           POINT TO ACTUAL RECORD DATA\n         CALL  EXPAND,((4),IOSAVE+8,(2)),MF=(E,CALLIST)\n         B     BLOCK               GO TO THE BLOCK/WRITE ROUTINE\n         TITLE 'BSAM/BPAM WRITE FIXED RECORDS '\n*---------------------------------------------------------------------*\n*---     FIXED, UNBLOCKED RECORDS.                                 ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nPUTF     DS    0H\n         #IF   TRUNC,ON,PUTF1      JUST CLEANING UP\n         L     R4,BPBUF1           LOAD BUFFER POINTER\n         LH    R5,DCBBLKSI         LOAD LRECL FOR RETURN\n         L     R2,IOSAVE+12        LOAD RECORD ADDRESS\n         L     R3,IOSAVE+8           AND LENGTH\n         MVCL  R4,R2               COPY RECORD TO BPAM BUFFER\nPUTF1    DS    0H\n         #IF   IOGOING,OFF,PUTF2   IS A WRITE IN PROGRESS ??\n         CHECK PDSDECB             YES; LET IT COMPLETE\n         #SET  IOGOING,OFF         SHOW NO MORE WRITE IN PROGRESS\nPUTF2    DS    0H\n         #IF   TRUNC,ON,PUTRET     ALL DONE ---\n         LM    R2,R3,BPBUF1        LOAD BUFFER POINTER WORDS\n         LR    R4,R2               SWAP BUFFERS\n         STM   R3,R4,BPBUF1        ...\n         WRITE PDSDECB,SF,(9),(4),'S',MF=E\n         #SET  IOGOING,ON          SHOW THAT A WRITE IS IN PROGRESS\n         B     PUTRET              AND GO RETURN TO LOCAL CALLER\n         TITLE 'BSAM/BPAM WRITE FIXED BLOCKED RECORDS '\n*---------------------------------------------------------------------*\n*---     FIXED, BLOCKED RECORDS.                                   ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nPUTFB    DS    0H\n         #IF   TRUNC,ON,PUTFB3     JUST CLEAN UP WHAT'S LEFT\n         #IF   BUFUSED,ON,PUTFBA   INIT. SETUP IS DONE ??\n         L     R4,BPBUF1           POINT TO FIRST BUFFER\n         LA    R5,0                AMOUNT USED ---\n         STM   R4,R5,BLOCKWDS      INIT. THE BLOCKING VALUES\nPUTFBA   DS    0H\n         #SET  BUFUSED,ON          TURN ON 'BUFFER USED' FLAG\n         LM    R4,R5,BLOCKWDS      NEXT-RECORD ADDRESS\n         LR    R6,R5               COPY CURRENT BUFFER-USED VALUE\n         AH    R6,DCBLRECL         ACCOUNT FOR A RECORD\n         ST    R6,BLOCKWDS+4\n         LA    R4,0(R5,R4)         POINT INTO THE BUFFER\n         LH    R5,DCBLRECL         LOAD LOGICAL RECORD LENGTH\n         L     R2,IOSAVE+12        LOAD RECORD ADDRESS\n         L     R3,IOSAVE+8           AND LENGTH\nPUTFB1   DS    0H\n         MVCL  R4,R2               MOVE RECORD INTO BUFFER\n         L     R2,BLOCKWDS+4       LOAD BYTES-USED VALUE\n         CH    R2,DCBBLKSI         AT END OF BUFFER ??\n         BL    PUTRET              NOPE; RETURN TO LOCAL CALLER\n         #IF   IOGOING,OFF,PUTFB2  IS A WRITE IN PROGRESS ??\n         CHECK PDSDECB             YES; LET IT COMPLETE\n         #SET  IOGOING,OFF         NO WRITE IN PROGRESS\n         #SET  BUFUSED,OFF         NEXT BUFFER IS EMPTY\nPUTFB2   DS    0H\n         LM    R2,R3,BPBUF1        LOAD BUFFER POINTER WORDS\n         LR    R4,R2               SWAP BUFFERS\n         STM   R3,R4,BPBUF1        ...\n         ST    R3,BLOCKWDS         STORE AS 'NEXT-RECORD' ADDRESS\n         XC    BLOCKWDS+4(4),BLOCKWDS+4 CLEAR 'BYTES-USED' VALUE\n         WRITE PDSDECB,SF,(9),(4),'S',MF=E\n         #SET  IOGOING,ON          SHOW THAT A WRITE IS IN PROGRESS\n         #SET  BUFUSED,OFF         TURN OFF 'BUFFER USED' FLAG\n         B     PUTRET              AND GO RETURN TO LOCAL CALLER\n*---------------------------------------------------------------------*\n*---     BUFFER PURGE ROUTINE                                      ---*\n*---------------------------------------------------------------------*\nPUTFB3   DS    0H\n         #IF   IOGOING,OFF,PUTFB4  IS A WRITE IN PROGRESS ??\n         CHECK PDSDECB             YES; LET IT COMPLETE\n         #SET  IOGOING,OFF         NO WRITE IN PROGRESS\nPUTFB4   DS    0H\n         #IF   BUFUSED,OFF,PUTFB5  IS CURRENT BUFFER USED ??\n         L     R2,BPBUF1           LOAD BUFFER POINTER WORD\n         L     R3,BLOCKWDS+4       LOAD BYTES-USED VALUE\n         LH    R4,DCBBLKSI         LOAD DCB BLKSIZE\n         STH   R3,DCBBLKSI         STORE UPDATED BLKSIZE\n         WRITE PDSDECB,SF,(9),(2),(3),MF=E\n         #SET  IOGOING,ON          SHOW THAT A WRITE IS IN PROGRESS\n         CHECK PDSDECB             LET IT COMPLETE\n         #SET  IOGOING,OFF         NO WRITE IN PROGRESS\n         #SET  BUFUSED,OFF         NO WRITE IN PROGRESS\n         STH   R4,DCBBLKSI         RESTORE BLKSIZE\n         XC    BLOCKWDS+4(4),BLOCKWDS+4 ZERO BYTES USED\n         ST    R2,BLOCKWDS         RESET NEXT-RECORD POINTER\nPUTFB5   DS    0H\n         B     PUTRET              RETURN TO LOCAL CALLER\n         TITLE 'BSAM/BPAM WRITE VARIABLE RECORDS '\n*---------------------------------------------------------------------*\n*---     VARIABLE, UNBLOCKED RECORDS.                              ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nPUTV     DS    0H\n         #IF   TRUNC,ON,PUTV1      JUST CLEAN UP ---\n         L     R4,BPBUF1           LOAD BUFFER POINTER\n         L     R2,IOSAVE+12        LOAD RECORD ADDRESS\n         L     R3,IOSAVE+8           AND LENGTH\n         AH    R3,=H'4'            ACCOUNT FOR RDW/BDW\n         SLL   R3,16               SHIFT FOR RDW/BDW\n         STCM  R3,15,0(R2)         STORE RDW/BDW PREFIX\n         LA    R4,4(,R4)           POINT PAST IT\n         L     R3,IOSAVE+8           AND LENGTH\n         LR    R5,R3               COPY RECORD LENGTH AGAIN\n         MVCL  R4,R2               MOVE RECORD TO BPAM BUFFER\nPUTV1    DS    0H\n         #IF   IOGOING,OFF,PUTV2   IS A WRITE IN PROGRESS ??\n         CHECK PDSDECB             YES; LET IT COMPLETE\n         #SET  IOGOING,OFF         NO WRITE IN PROGRESS\nPUTV2    DS    0H\n         #IF   TRUNC,ON,PUTRET     JUST CLEAN UP ---\n         LM    R2,R3,BPBUF1        LOAD BUFFER POINTER WORDS\n         LR    R4,R2               SWAP BUFFERS\n         STM   R3,R4,BPBUF1        ...\n         LH    R5,0(,R4)           LOAD RECORD LENGTH\n         WRITE PDSDECB,SF,(9),(4),(5),MF=E\n         #SET  IOGOING,ON          SHOW THAT A WRITE IS IN PROGRESS\n         B     PUTRET              AND GO RETURN TO LOCAL CALLER\n         TITLE 'BSAM/BPAM WRITE VARIABLE BLOCKED RECORDS '\n*---------------------------------------------------------------------*\n*---     VARIABLE, BLOCKED RECORDS.                                ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nPUTVB    DS    0H\n         #IF   TRUNC,ON,PUTVB4     JUST CLEAN UP ---\nPUTVB1   DS    0H\n         #SET  BUFUSED,ON          SHOW THE BUFFER USED\n         L     R2,IOSAVE+12        LOAD RECORD ADDRESS\n         L     R3,IOSAVE+8           AND LENGTH\n         L     R4,BPBUF1           LOAD BUFFER POINTER\n         LH    R5,0(,R4)           LOAD BYTES-USED VALUE\n         LA    R5,4(R3,R5)         ACCOUNT FOR NEW RDW\n         CH    R5,DCBBLKSI         TOO LARGE FOR THIS BLOCK ??\n         BNH   PUTVB3              NOPE ---\n         #IF   IOGOING,OFF,PUTVB2  IS A WRITE IN PROGRESS ??\n         CHECK PDSDECB             YES; LET IT COMPLETE\n         #SET  IOGOING,OFF         NO WRITE IN PROGRESS\n         #SET  BUFUSED,OFF         NO WRITE IN PROGRESS\nPUTVB2   DS    0H\n         LM    R4,R5,BPBUF1        LOAD BUFFER POINTER WORDS\n         LR    R6,R4               SWAP BUFFERS\n         MVC   0(4,R5),=X'00040000' START WITH 4 BYTES (BDW)\n         STM   R5,R6,BPBUF1        ...\n         LH    R5,0(,R4)           LOAD BYTES-USED VALUE\n         WRITE PDSDECB,SF,(9),(4),(5),MF=E\n         #SET  IOGOING,ON          SHOW THAT A WRITE IS IN PROGRESS\n         #SET  BUFUSED,OFF         TURN OFF 'BUFFER USED' FLAG\n         B     PUTVB1              AND RE-CHECK ---\nPUTVB3   DS    0H\n         #SET  BUFUSED,ON          SHOW THE BUFFER NON-EMPTY\n         L     R4,BPBUF1           LOAD POINTER TO AREA\n         LH    R5,0(,R4)           LOAD BYTES-USED VALUE\n         LA    R4,0(R5,R4)         POINT TO NEXT RECORD AREA\n         LA    R0,4(,R3)           BUILD RDW AND\n         STH   R0,0(,R4)           STORE IT\n         XC    2(2,R4),2(R4)       NO SPANNED-RECORD STUFF\n         LR    R5,R3               COPY RECORD LENGTH\n         LA    R4,4(,R4)           POINT TO DATA FIELD\n         MVCL  R4,R2               AND MOVE THE RECORD\n         L     R2,BPBUF1           LOAD POINTER TO AREA\n         AH    R0,0(,R2)           LOAD CURRENT BLK LENGTH\n         STH   R0,0(,R2)           UPDATE BDW\n         ST    R0,BLOCKWDS+4       AND BYTES-USED VALUE\n         B     PUTRET              AND EXIT\nPUTVB4   DS    0H\n*---------------------------------------------------------------------*\n*---     BUFFER PURGE ROUTINE                                      ---*\n*---------------------------------------------------------------------*\n         #IF   IOGOING,OFF,PUTVB6  IS A WRITE IN PROGRESS ??\n         CHECK PDSDECB             YES; LET IT COMPLETE\n         #SET  IOGOING,OFF         NO WRITE IN PROGRESS\nPUTVB6   DS    0H\n         #IF   BUFUSED,OFF,PUTVB7  IS CURRENT BUFFER USED ??\n         L     R2,BPBUF1           LOAD BUFFER POINTER WORD\n         LH    R3,0(,R2)           LOAD BYTES-USED VALUE\n         WRITE PDSDECB,SF,(9),(2),(3),MF=E\n         #SET  IOGOING,ON          SHOW THAT A WRITE IS IN PROGRESS\n         CHECK PDSDECB             LET IT COMPLETE\n         MVC   0(4,R2),=X'00040000' RESET BDW\n         L     R2,BPBUF2           LOAD BUFFER POINTER WORD\n         MVC   0(4,R2),=X'00040000' RESET BDW\n         #SET  BUFUSED,OFF         TURN OFF 'BUFFER USED' FLAG\n         #SET  IOGOING,OFF         TURN OFF 'WRITE-IN-PROGRESS' FLAG\nPUTVB7   DS    0H\n         B     PUTRET              RETURN TO LOCAL CALLER\n         TITLE 'BSAM/BPAM WRITE UNDEFINED RECORDS '\n*---------------------------------------------------------------------*\n*---     UNDEFINED-FORMAT RECORDS.                                 ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nPUTU     DS    0H\n         L     R2,IOSAVE+12        LOAD RECORD ADDRESS\n         L     R3,IOSAVE+8           AND LENGTH\n         #IF   TRUNC,ON,PUTU1      CLEAN UP LAST WRITE\n         NC    NOTELIST,NOTELIST   NOTELIST ALREADY FOUND ??\n         BNZ   PUTUA               YES; CONTINUE ---\n         CLI   BLDLAREA+19,0       IS A NOTE LIST PRESENT ??\n         BE    PUTUA               NOPE ---\n         CLC   0(3,R2),BLDLAREA+16 IS THIS IT ??\n         BNE   PUTUA               NOPE ---\n         LA    R4,4(,R3)           ACCOUNT FOR LENGTH WORD\n         GETMAIN R,LV=(4),SP=10    GRAB SOME STORAGE\n         ST    R1,NOTELIST         SAVE AS NOTELIST POINTER\n         ST    R4,0(,R1)           SAVE LENGTH, FOR RELEASING LATER\n         LA    R4,4(,R1)           POINT TO DATA AREA\n         LR    R5,R3               COPY ACTUAL RECORD LENGTH\n         MVCL  R4,R2               COPY THE NOTE LIST\n         B     PUTRET              END, FOR NOW\nPUTUA    DS    0H\n         LR    R5,R3               COPY RECORD LENGTH\n         L     R4,BPBUF1           LOAD BUFFER ADDRESS\n         MVCL  R4,R2               COPY RECORD TO BUFFER\n         L     R5,IOSAVE+8         RE-COPY RECORD LENGTH\nPUTU1    DS    0H\n         #IF   IOGOING,OFF,PUTU2   IS A WRITE IN PROGRESS ??\n         CHECK PDSDECB             YES; LET IT COMPLETE\n         #SET  IOGOING,OFF         NO WRITE IN PROGRESS\nPUTUF    DS    0H\n         NOTE  (9)                 SAVE ADDRESS OF LAST RECORD\n         LR    R2,R1               COPY RESULT TTR\n         L     R1,BPBUF2           RELOAD BUFFER POINTER\n         ICM   R1,14,0(R1)         INSERT OLD TTR VALUE\nPUTA     DS    0H\n         CLM   R1,14,BLDLAREA+8    MATCHING TTR ??\n         BNE   *+8                 NOPE ---\n         STCM  R2,14,BLDLAREA+8    YES; UPDATE IT ---\n         CLM   R1,14,BLDLAREA+12   MATCHING TTR ??\n         BNE   *+8                 NOPE ---\n         STCM  R2,14,BLDLAREA+12   YES; UPDATE IT ---\n         CLM   R1,14,BLDLAREA+16   MATCHING TTR ??\n         BNE   *+8                 NOPE ---\n         STCM  R2,14,BLDLAREA+16   YES; UPDATE IT ---\nPUTB     DS    0H\n*---------------------------------------------------------------------*\n*---     IF A NOTE LIST WAS PRESENT, WE MUST EXAMINE EACH ENTRY,   ---*\n*---     COMPARING THE OLD TTR OF THE RECORD WE JUST WROTE.  IF    ---*\n*---     WE HAVE A MATCH, WE REPLACE THE OLD TTR WITH THE NEW      ---*\n*---     TTR, BEING CAREFUL NOT TO ALTER THE SEGMENT NUMBER.       ---*\n*---------------------------------------------------------------------*\n         L     R6,NOTELIST         LOAD NOTELIST POINTER\n         LTR   R6,R6               ANY NOTELIST PROCESSING ??\n         BZ    PUTU2               NOPE ---\n         L     R5,0(,R6)           LOAD SAVED-NOTELIST LENGTH\n         LA    R6,8(,R6)           POINT TO FIRST TTR VALUE\n         LA    R7,0(R6,R5)         POINT TO\n         BCTR  R7,R0                 END OF LIST\n         L     R4,BPBUF2           LOAD POINT TO THE BUFFER\nPUTN1    DS    0H\n         CLC   0(3,R4),0(R6)       TTR'S MATCH ??\n         BE    PUTN2               YES ---\n         LA    R6,4(,R6)           POINT TO NEXT ENTRY\n         CR    R6,R7               FAR ENOUTH, YET ??\n         BL    PUTN1               NOPE; KEEP CHECKING\n         B     PUTU2               ALL DONE ---\nPUTN2    DS    0H\n         STCM  R2,14,0(R6)         STORE UPDATED TTR\nPUTU2    DS    0H\n         #IF   TRUNC,ON,PUTRET     ALL DONE ---\n         LM    R2,R3,BPBUF1        LOAD BUFFER POINTER WORDS\n         LR    R4,R2               SWAP BUFFERS\n         STM   R3,R4,BPBUF1        ...\n         ST    R3,BLOCKWDS         STORE AS 'NEXT-RECORD' ADDRESS\n         LA    R4,4(,R4)           POINT PAST THE TTR WORD\n         L     R5,IOSAVE+8         RELOAD ORIGINAL LENGTH\n         SH    R5,=H'4'            AND ACCOUNT FOR IT IN LENGTH\n         WRITE PDSDECB,SF,(9),(4),(5),MF=E\n         #SET  IOGOING,ON          SHOW THAT A WRITE IS IN PROGRESS\n         B     PUTRET              AND RETURN TO LOCAL CALLER\n*---------------------------------------------------------------------*\n*---     COMMON RETURN LINKAGE CODE                                ---*\n*---------------------------------------------------------------------*\nPUTRET   DS    0H\n         LM    R14,R12,IOSAVE      RESTORE CALLER'S REGISTERS\n         BR    R14                 RETURN ---\n         DROP  R9\n*---------------------------------------------------------------------*\n*---     SOME ERROR STUFF                                          ---*\n*---------------------------------------------------------------------*\nNODDERR  DS    0H\n         #ERR  MSG=1\n         #ERR  MSG=6\n         B     ENDITALL\nORGERR   DS    0H\n         #ERR  MSG=3\n         #ERR  MSG=6\n         B     ENDITALL\nERRDEV   DS    0H\n         #ERR  MSG=2\n         #ERR  MSG=6\n         B     ENDITALL\n         TITLE 'VSAM CLOSE AND CONTROL-BLOCK FREEMAINS'\n*---------------------------------------------------------------------*\n*---     THIS LITTLE LOCAL SUBROUTINE IS THE COUNTERPART TO THE    ---*\n*---     QSOPEN ROUTINE. HERE, THE VSAM CLUSTER # 1 IS CLOSED      ---*\n*---     AND ALL RELATED STORAGE, WORK AREAS, ETC. ARE FREE'D.     ---*\n*---     ALL RELATED VALUES IN THE ##ARCHWK AREA ARE ALSO RESET.   ---*\n*---------------------------------------------------------------------*\nQSCLOSE  DS    0H\n         STM   R14,R12,IOSAVE      SAVE ENTRY REGISTERS\n         MVI   ACB1,X'80'          MARK AS LAST FOR CLOSE\n         CLOSE ,MF=(E,ACB1)        CLOSE THE CLUSTER\n         L     R1,ACB1             LOAD THE DCB ADDRESS\n         FREEPOOL (1)              RELEASE THE BUFFER POOL\n         LA    R0,0                LOAD A ZERO\n         ST    R0,ACB1             SAVE\n         ST    R0,VS1LIM                AS\n         ST    R0,VS1BUF1\n         ST    R0,VS1BUF2\n         ST    R0,VS1LEN1\n         ST    R0,VS1LEN2                       VALUES\n         LM    R14,R12,IOSAVE      RESTORE THE REGISTERS\n         BR    R14                 RETURN TO (LOCAL) CALLER\n         TITLE 'VSAM CLUSTER OPEN AND BLOCK-BUILD'\n*---------------------------------------------------------------------*\n*---     THIS LITTLE LOCAL SUBROUTINE OPENS THE VSAM CLUSTER       ---*\n*---     FOR OUTPUT AND/OR UPDATE.  ALL VSAM-RELATED GETMAINS      ---*\n*---     ARE DONE FROM SUBPOOL 10, TO ALLOW A SUBPOOL-WIDE         ---*\n*---     FREEMAIN AT THE END OF PROCESSING. NOTE THAT ALL VSAM     ---*\n*---     CONTROL BLOCKS ARE 'GENCB'D IN GETMAINED AREAS, FOR       ---*\n*---     THE SAME FLEXIBILITY.                                     ---*\n*---------------------------------------------------------------------*\nQSOPEN   DS    0H\n         STM   R14,R12,IOSAVE      SAVE ENTRY REGISTERS\n         #SET  EOT,OFF\n         LA    R6,QSDCBL           LOAD THE DCB LENGTH\n         GETMAIN R,LV=(6),SP=10    GRAB SOME STORAGE\n         ST    R1,ACB1             SAVE AS ACB ADDRESS\n         LR    R2,R1               COPY ITS ADDRESS\n         MVC   0(QSDCBL,R2),QSDCB  COPY DCB INTO THE AREA\n         USING IHADCB,R2           BASE THE DSECT\n         MVC   DCBDDNAM,EXPTPDD    COPY THE DDNAME\n         MVI   ACB1,X'80'          MARK AS LAST FOR OPEN\n         OPEN  ,MF=(E,ACB1)        OPEN THE DATASET\n         LH    R6,DCBLRECL         LOAD THE RECORD LENGTH\n         GETMAIN R,LV=(6),SP=10    GRAB SPACE FOR A BUFFER AREA\n         ST    R1,VS1BUF2          SAVE BUFFER\n         LM    R14,R12,IOSAVE      RESTORE THE REGISTERS\n         BR    R14                 RETURN TO (LOCAL) CALLER\n         DROP  R2\n         SPACE 3\nQSE      DS    0F\n         DC    XL1'85',AL3(QSE+4)\n         USING IHADCB,R1\n         CLC   DCBBLKSI,=H'0'      BLKSIZE STILL ZERO ??\n         BNER  R14                 NOPE ---\n         MVC   DCBBLKSI,=H'32000'  YES; SET A DEFAULT\n         BR    R14                 RETORN TO O/C/EOV\n         DROP  R1\n         TITLE 'SEQUENTIAL OUTPUT SEPARATOR ROUTINES'\n*---------------------------------------------------------------------*\n*---     THIS LITTLE ROUTINE GENERATES A IEBUPDTE-TYPE ./ ADD      ---*\n*---     CARD AS A SEPARATOR BETWEEN ITEMS BEING LOADED TO A       ---*\n*---     SEQUENTIAL DATASET.  NO CHECK OF THE OUTPUT DATASET       ---*\n*---     CHARACTERISTICS IS MADE; THE USER IS ASSUMED TO KNOW      ---*\n*---     WHAT HE'S DOING!                                          ---*\n*---------------------------------------------------------------------*\nSEPUPDTE DS    0H\n         STM   R14,R12,SEPSAVE     SAVE THE INPUT REGISTERS\n         LR    R2,R1               COPY INPUT HEADER ADDRESS\n         MVI   GENWK,C' '          SEED IN A BLANK\n         MVC   GENWK+1(79),GENWK   BUILD A BLANK CARD\n         MVC   GENWK(12),=C'./ ADD NAME='\n         MVC   GENWK+12(8),1(R2)   COPY MEMBER NAME TO CARD\n         #IF   NOEXP,ON,SEP1\n         #SET  NOEXP,ON\n         LA    R1,GENWK\n         LA    R0,80\n         BAL   R14,PUT             OUTPUT THE SEPARATOR\n         #SET  NOEXP,OFF\n         B     SEP2\nSEP1     DS    0H\n         LA    R1,GENWK            LOAD RECORD ADDRESS\n         LA    R0,80               AND ELNGTH\n         BAL   R14,PUT             CALL THE 'PUTTER'\nSEP2     DS    0H\n         LM    R14,R12,SEPSAVE\n         BR    R14                 AND RETURN TO CALLER\n         LTORG\nTCMSG    DC    CL133' '\n         ORG   TCMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202120'\n         DC    C' TOTAL LOGICAL RECORDS PROCESSED.'\n         ORG\nMCMSG    DC    CL133' '\n         ORG   MCMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202120'\n         DC    C' TOTAL MEMBERS PROCESSED.'\n         ORG\nACMSG    DC    CL133' '\n         ORG   ACMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202120'\n         DC    C' TOTAL ALIAS NAMES PROCESSED.'\n         ORG\n         LTORG\nNOGENS   DC    XL16'000102030405060708090A0B0C0D0E0F'\n         DC    XL16'101112131415161718191A1B1C1D1E1F'\n         DC    XL16'202122232425262728292A2B2C2D2E2F'\n         DC    XL16'303132333435363738393A3B3C3D3E3F'\n         DC    XL16'404142434445464748494A4B4C4D4E4F'\n         DC    XL16'505152535455565758595A5B5C5D5E5F'\n         DC    XL16'606162636465666768696A6B6C6D6E6F'\n         DC    XL16'707172737475767778797A7B7C7D7E7F'\n         DC    XL16'808182838485868788898A8B8C8D8E8F'\n         DC    XL16'909192939495969798999A9B9C9D9E9F'\n         DC    XL16'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'\n         DC    XL16'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'\n         DC    XL16'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'\n         DC    XL16'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'\n         DC    XL16'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'\n         ORG   NOGENS+C'%'\n         DC    X'00'\n         ORG   NOGENS+C'*'\n         DC    X'00'\n         ORG\nLOADED   DC    AL1(LDMSGE-LDMSG)\nLDMSG    DC    C' SUCCESSFULLY LOADED.'\nLDMSGE   EQU   *\nALIASM   DC    AL1(ALIASE-ALIASS)\nALIASS   DC    C' IS AN ALIAS. CHECK SYSPUNCH OUTPUT FOR REAL '\n         DC    C'QUALIFIER DATA.'\nALIASE   EQU   *\nMINREC   DC    A(RECSIZE)\nCAMLST   CAMLST SEARCH,0,0,0\nLCAMLST  EQU   *-CAMLST\nPODCB    DCB   DSORG=PO,MACRF=(R,W),DDNAME=X\nPODCBL   EQU   *-PODCB\nBSDCB    DCB   DSORG=PS,MACRF=(RP,WP),DDNAME=X\nBSDCBL   EQU   *-BSDCB\nQSDCB    DCB   DSORG=PS,MACRF=GL,DDNAME=X,BFTEK=A,EXLST=QSE,           X\n               EODAD=ENDLOAD\nQSDCBL   EQU   *-QSDCB\nPCHDCB   DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPUNCH,RECFM=FB,LRECL=80,    X\n               EXLST=PCHEXIT\nDCBL     EQU   *-QSDCB\nPCHEXIT  DS    0F\n         DC    XL1'85',AL3(PCHEXIT+4)\n         USING IHADCB,R1\n         CLC   DCBBLKSI,=H'0'      BLKSIZE STILL ZERO ??\n         BNER  R14                 NOPE ---\n         MVC   DCBBLKSI,DCBLRECL   YES; DEFAULT TO LRECL\n         BR    R14                 RETORN TO O/C/EOV\n         DROP  R1\nEXTRPARM EXTRACT ,'S',FIELDS=TIOT,MF=L\nEXTL     EQU   *-EXTRPARM\n         READ  DECB,SF,0,0,0,MF=L\nDECBL    EQU   *-DECB\n         DCBD  DSORG=(PS,PO)\n         IECSDSL1 (1)\n         COPY  #RECS\n         COPY  ##ARCHWK\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHLFTP": {"ttr": 8198, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x019\\x019\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 313, "newlines": 313, "modlines": 0, "user": "ARCHIVR"}, "text": "LISTF    TITLE 'ARCHIVER --- LISTF FUNCTION'\n*---------------------------------------------------------------------*\n*---     ALL LISTF REQUESTS ARE ROUTED HERE FOR FURTHER            ---*\n*---     PROCESSING.  THIS ROUTINE LISTS THE VARIOUS TYPES OF      ---*\n*---     QUALIFIER AND DCB ATTRIBUTE DATA FOUND IN THE ARCHIVER    ---*\n*---     EXPORT TAPE, UNDER THE CONTROL OF THE ITEM VALUES ON      ---*\n*---     THE INPUT CONTROL STATEMENT.  NOTE THAT THE 'MEMBER'      ---*\n*---     VALUE IS FORCED TO THE GENERIC EQUIVALENT OF              ---*\n*---     'ALL MEMBERS' BEFORE THE PROCESSING STARTS.               ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nARCHLFTP CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n         COPY  #ARCBITS\n         USING ARCHLFTP,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             LOAD ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHLFTP,R11        DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             LOAD NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RELOAD BACK POINTER\n         L     R14,12(,R14)        RELOAD ORIG. REG 14\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         XC    MCNT,MCNT           INIT. THE ITEM COUNT\n         ZAP   LSTLIN#,=P'99'      START ON A NEW PAGE\n         BAL   R14,NVSOPEN         GO OPEN THE ARCHIVER-EXPORT TAPE\n         XC    CALLIST(4),CALLIST  INITIAL CHAIN-POINTER VALUE\n         EJECT\n*---------------------------------------------------------------------*\n*---     HERE'S THE MEAT OF THE PROCESSING. THE BASIC PROCESS IS   ---*\n*---           THIS:                                               ---*\n*---                                                               ---*\n*---     1. USING THE CONTROL INFORMATION WE WERE GIVEN AND THE    ---*\n*---        INFORMATION WE'VE DEVELOPED, LOCATE THE HEADER RECORD  ---*\n*---        FOR THE FIRST MEMBER. WE'LL USE THE VS1BUF2 AREA FOR   ---*\n*---        HEADER/KEY CONSTRUCTION.                               ---*\n*---                                                               ---*\n*---     2. LOOP THROUGH THE MEMBER, READING THE RECORDS AND       ---*\n*---        EXPLODING THEM INTO THE COMPRK AREA, WRITING EACH      ---*\n*---        'LOGICAL' RECORD AS IT BECOMES AVAILABLE.              ---*\n*---------------------------------------------------------------------*\n         MVC   TITLE3,SH10         REPORT SUBTITLE LINE\nMEMBERS  DS    0H\n         L     R1,NDCBA            POINT TO THE DCB\n         GET   (1)                 READ A RECORD\n         LH    R3,0(,R1)           LOAD ITS LENGTH\n         LA    R3,0(R3,R1)         POINT TO RECORD END\n         BCTR  R3,R0               BACK UP TO LAST BYTE\n         LA    R2,4(,R1)           POINT TO RECORD START\n         CLC   0(4,R2),=C'SIZE'    IS THIS A SIZE MARKER ??\n         BNE   NOTSIZE             NOPE ---\n         MVC   LINE,DASHES\n         #PUT  LINE\n         L     R0,4(,R2)           LOAD THE SIZE VALUE\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE,MSGL           COPY MESSAGE DATA TO LINE\n         ED    LINE+38(8),DWORK+4  INSERT SIZE IN LINE\n         #PUT  LINE                OUTPUT THE MESSAGE\n         MVC   LINE,DASHES         ANOTHER LINE OF DASHES\n         #PUT  LINE\n         B     MEMBERS             GO FOR ANOTHER RECORD\nDASHES   DC    C' '\n         DC    120C'-'\nMSGL     DC    CL133' '\n         ORG   MSGL+1\n         DC    C'NEW CLUSTER INPUT. MAXIMUM LRECL WAS '\n         DC    X'4020202020202020'\n         DC    C' BYTES.'\n         ORG\nNOTSIZE  DS    0H\n         CLI   0(R2),#RTHDR        HEADER RECORD ??\n         BNE   MEMBERS             NOPE; LOOK FOR ANOTHER HDR\n         LA    R1,1(,R2)           POINT TO THE HEADER\n         LA    R0,0                USE DEFAULT QUALIFIER DATA\n         CALL  ARCHKNAM            GO CHECK: DO WE PROCESS THIS ITEM ??\n         LTR   R15,R15             PASS THE CHECK ??\n         BNZ   MEMBERS             NOPE ---\n         L     R15,MCNT            LOAD ITEM COUNTER\n         LA    R15,1(,R15)\n         ST    R15,MCNT\n         LA    R1,0(,R2)           POINT TO THE HEADER RECORD\n         BAL   R9,CHAINER          CHECK/LIST HEADER RECORD\n         B     MEMBERS             GO GET THE NEXT RECORD\nENDITALL DS    0H\n*---------------------------------------------------------------------*\n*---     AT THIS POINT, WE'VE CHAINED ALL THAT CAN BE CHAINED.    ----*\n*---     NOW GENERATE THE LISTING, WITH APPROPRIATE TITLES, AND   ----*\n*---     TERMINATE. AFTER EACH LINK IS LISTED, WE UNCHAIN IT,      ---*\n*---     FREEMAIN THE STORAGE AND LOOP BACK TO RESTART THE         ---*\n*---     LISTING PROCESS.                                          ---*\n*---------------------------------------------------------------------*\n         NC    CALLIST(4),CALLIST  ALL LINKS DONE ??\n         BZ    LSTD                YES ---\n         L     R10,CALLIST         LOAD A LINK POINTER\n         MVC   CALLIST(4),0(R10)   UNCHAIN IT\n         MVI   LINE,C' '           SEED IN A BLANK\n         MVC   LINE+1(L'LINE-1),LINE    AND CLEAR THE LINE\n*++++++++++++++++++++++++++++++++++\n         LA    R2,LINE+1           POINT TO OUTPUT AREA\n         MVI   0(R2),C'-'\n         LA    R2,1(,R2)\n         MVC   0(10,R2),12(R10)    MOVE THE GROUP\n         MVI   10(R2),C'-'         AND FIELD SEPARATOR\n         LA    R2,11(,R2)          INCREMENT TRAVELING POINTER\n         MVC   0(10,R2),22(R10)    MOVE THE SUBGROUP OVER\n         MVI   10(R2),C'-'         AND FIELD SEPARATOR\n         LA    R2,11(,R2)          INCREMENT TRAVELING POINTER\n         MVC   0(10,R2),32(R10)    MOVE THE TYPE OVER\n         MVI   10(R2),C'-'         AND FIELD SEPARATOR\n         LA    R2,11(,R2)          INCREMENT TRAVELING POINTER\n         ICM   R0,15,42(R10)       INSERT THE VERSION\n         X     R0,=F'-1'           INVERT ALL BITS\n         CVD   R0,DWORK            AND DECIMALIZE IT\n         OI    DWORK+7,X'0F'       FORST LAST SIGN NUMERIC\n         MVC   0(12,R2),SH11        MOVE IN THE EDIT MASK\n         ED    0(12,R2),DWORK+3     EDIT IN THE VERSION NUMBER\n         LA    R2,14(,R2)          POINT PAST IT\n         $CVRECFM 0(,2),46(R10)\n         CLI   0(R2),C'U'          RECFM = U ??\n         LA    R2,6(,R2)\n         BE    SH4                 YES; SKIP LRECL\n         LA    R15,0               CLEAR A WORK REG\n         ICM   R15,3,47(R10)       INSERT THE LRECL VALUE\n         CVD   R15,DWORK           DECIMALIZE IT\n         OI    DWORK+7,X'0F'       FORST LAST SIGN NUMERIC\n         MVC   0(7,R2),SH8         MOVE IN THE EDIT MASK\n         ED    0(7,R2),DWORK+5     EDIT IN THE LRECL\nSH4      DS    0H\n         LA    R15,0               RE-CLEAR R15\n         LA    R2,9(,R2)\n         ICM   R15,3,49(R10)       INSERT THE BLKSIZE VALUE\n         CVD   R15,DWORK           DECIMALIZE IT\n         OI    DWORK+7,X'0F'       FORST LAST SIGN NUMERIC\n         MVC   0(7,R2),SH8         MOVE IN THE EDIT MASK\n         ED    0(7,R2),DWORK+5     EDIT IN THE BLKSIZE\n         LA    R2,9(,R2)\n         ICM   R0,15,4(R10)        INSERT THE ITEM COUNT\n         CVD   R0,DWORK            AND DECIMALIZE IT\n         OI    DWORK+7,X'0F'       FORCE LAST SIGN NUMERIC\n         MVC   1(12,R2),SH11       MOVE IN THE EDIT MASK\n         ED    1(12,R2),DWORK+3    EDIT IN THE COUNT\n         LA    R2,13(,R2)\n         ICM   R0,15,8(R10)        INSERT THE ITEM COUNT\n         CVD   R0,DWORK            AND DECIMALIZE IT\n         OI    DWORK+7,X'0F'       FORCE LAST SIGN NUMERIC\n         MVC   1(12,R2),SH11       MOVE IN THE EDIT MASK\n         ED    1(12,R2),DWORK+3    EDIT IN THE COUNT\nSH5      DS    0H\n         #PUT  LINE                PRINT IT OUT\n         B     ENDITALL\nLSTD     DS    0H\n         #ERR  MSG=11\n         L     R0,MCNT             LOAD MEMBER COUNT\n         LTR   R0,R0               ZERO COUNT ??\n         BZ    END1                YES ---\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,TCMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\nEND1     DS    0H\n         CLC   NDCBA,=F'0'         WAS DCB EVER OPENED ??\n         BE    NOACB               NOPE ---\n         BAL   R14,NVSCLOSE        CLOSE THE IMPORT TAPE\nNOACB    DS    0H\n         L     R13,4(,R13)         LOAD BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ALWAYS RC = 0\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\n         TITLE 'NONVSAM CLOSE AND CONTROL-BLOCK FREEMAINS'\n*---------------------------------------------------------------------*\n*---     THIS LITTLE LOCAL SUBROUTINE IS THE COUNTERPART TO THE    ---*\n*---     NVSOPEN ROUTINE. HERE, THE NONVSAM DATASET IS CLOSED      ---*\n*---     AND ALL RELATED STORAGE, WORK AREAS, ETC. ARE FREE'D.     ---*\n*---     ALL RELATED VALUES IN THE ##ARCHWK AREA ARE ALSO RESET.   ---*\n*---------------------------------------------------------------------*\nNVSCLOSE DS    0H\n         STM   R14,R12,IOSAVE      SAVE ENTRY REGISTERS\n         OI    NDCBA,X'80'         MARK AS LAST FOR CLOSE\n         CLOSE ,MF=(E,NDCBA)       CLOSE THE DATASET\n         L     R2,NDCBA            LOAD THE DCB ADDRESS\n         FREEPOOL (2)              RELEASE THE BUFFER POOL\n         XC    NDCBA,NDCBA         AND CLOBBER THAT POINTER\n         LM    R14,R12,IOSAVE      RESTORE THE REGISTERS\n         BR    R14                 RETURN TO (LOCAL) CALLER\n         TITLE 'OPEN NONVSAM INPUT DATASET '\n         SPACE 3\nNVSOPEN  DS    0H\n         STM   R14,R12,IOSAVE      SAVE THE ENTRY REGISTERS\n*---\n*---     BUILD A DCB, TO START, FOR DSORG CHECKING\n*---\n         GETMAIN R,LV=QSDCBL,SP=10 GRAB STORAGE FOR BPAM DCB\n         ST    R1,NDCBA            AND STORE ADDRESS IN ARCHIVWA\n         MVI   NDCBA,X'80'         BUILD OPEN PARM LIST\n         MVC   0(QSDCBL,R1),QSDCB  COPY DCB TO DYNAMIC AREA\n         USING IHADCB,R1           BASE THE DCB DSECT\n         MVC   DCBDDNAM,EXPTPDD    MOVE IN THE DDNAME\n         DROP  R1\n         OPEN  (,INPUT),MF=(E,NDCBA) OPEN THE DCB\n         LM    R14,R12,IOSAVE      RELOAD ENTRY REGISTERS\n         BR    R14                 AND RETURN TO LOCAL CALLER\n         SPACE 3\n         DS    0F\nE1       DC    X'85',AL3(E1+4)\n         USING IHADCB,R1\n         CLC   DCBBLKSI,=H'0'      BLKSIZE MISSING ??\n         BNER  R14                 NOPE ---\n         MVC   DCBBLKSI,=H'32000'  YES; INSERT A DEFAULT\n         BR    R14\n         DROP  R1\nQSDCB    DCB   DSORG=PS,MACRF=GL,BFTEK=A,EODAD=ENDITALL,EXLST=E1\nQSDCBL   EQU   *-QSDCB\n         TITLE 'LOCAL SUBROUTINE TO SAVE A HEADER RECORD '\n*---------------------------------------------------------------------*\n*---     THIS LITTLE LOCAL SUBROUTINE CHAINS TOGETHER ALL THE     ----*\n*---     VARIATIONS OF QUALIFIER DATA AND DCB ATTRIBUTES IN A     ----*\n*---     SINGLE-LINKED LIST, IN SORTED ORDER.  THE INFORMATION    ----*\n*---     SAVED CONSISTS OF THE GROUP, SUBGROUP AND TYPE           ----*\n*---     QUALIFIERS, THE VERSION NUMBERS AND THE DCB ATTRIBUTES.  ----*\n*---     EACH TIME ANY OF THESE ITEMS CHANGES, A NEW CHAIN-LINK   ----*\n*---     IS CREATED AND INSERTED AT THE APPROPRIATE PLACE IN THE  ----*\n*---     CHAIN.  SINCE ALL STORAGE FOR THE CHAIN IS GETMAINED     ----*\n*---     FROM A SINGLE SUBPOOL, AT PROCESSING END A SIMPLE        ----*\n*---     'ALL-THE-SUBPOOL' FREEMAIN IS PERFORMED TO RELEASE THE   ----*\n*---     STORAGE.                                                 ----*\n*---------------------------------------------------------------------*\n         SPACE 3\nCHAINER  DS    0H\n         STM   R14,R12,IOSAVE      SAVE ENTRY REGISTERS\n         LR    R6,R1               COPY THE RECORD ADDRESS\n         USING REC,R6              AND BASE ITS DSECT\n         XC    BLDLAREA,BLDLAREA   CLEAR A WORK AREA\n         MVC   BLDLAREA(34),RECG COPY QUALIFIERS OVER\n         MVC   BLDLAREA+34(1),RSRREC COPY RECORD FORMAT\n         MVC   BLDLAREA+35(2),RSRLRE COPY LRECL OVER\n         MVC   BLDLAREA+37(2),RSRBLK AND BLKSIZE\n         LA    R10,CALLIST         POINT TO CHAIN START\nLPA      DS    0H\n         LA    R9,0                RE-CLEAR THAT REGISTER\n         NC    0(4,R10),0(R10)     EMPTY CHAIN ??\n         BZ    LPX                 YES; CREATE THE FIRST LINK\n         L     R9,0(,R10)          LOAD LINK POINTER\n         CLC   12(43,R9),BLDLAREA  ENTRY MATCH ??\n         BH    LPX                 NEW IS LOWER; INSERT\n         BE    LPY                 YES; JUST INCREMENT THE COUNTS\n         LR    R10,R9              BUMP DOWN THE CHAIN\n         B     LPA                 AND LOOP, SEARCHINGLY\nLPX      DS    0H\n         GETMAIN RC,LV=56,SP=10 GRAB SOME STORAGE\n         XC    0(56,R1),0(R1)      CLEAR IT OUT\n         MVC   12(43,R1),BLDLAREA  ADD THE KEY FIELDS\n         ST    R9,0(,R1)           STORE THE LINK POINTER\n         ST    R1,0(,R10)          STORE THE LINK POINTER\n         LR    R9,R1               AND COPY TO MY 'STD' REGISTER\nLPY      DS    0H\n         L     R0,4(,R9)           LOAD THE ITEM COUNT\n         AH    R0,=H'1'            INCREMENT BY ONE\n         ST    R0,4(,R9)           SAVE UPDATED COUNT\n         ICM   R0,15,RSRRCNT       LOAD THE RECORD COUNT\n         A     R0,8(,R9)           ADD TO TOTAL\n         ST    R0,8(,R9)           SAVE UPDATED VALUE\n         LM    R14,R12,IOSAVE      RESTORE ENTRY REGISTERS\n         BR    R9                  AND RETURN TO LOCAL CALLER\n         DROP  R6\nSH10     DC    C'    GROUP   -'\n         DC    C'  SUBGRP  -'\n         DC    C'  TYPE    -'\n         DC    C'   VERSION'\n         DC    C'    RECFM'\n         DC    C'   LRECL'\n         DC    C'     BLKL'\n         DC    C'          ITEMS'\n         DC    C'      RECORDS'\n         DC    CL34' '\nSH11     DC    C' ',X'202020',C',',X'202020',C',',X'202020'\nTCMSG    DC    CL133' '\n         ORG   TCMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    C' TOTAL ITEMS LISTED. '\n         ORG\nSH8      DC    C' ',X'2020',C',',X'202020'\n         LTORG\nMINREC   DC    A(RECSIZE)\n         COPY  #RECS\n         COPY  ##ARCHWK\n         DCBD  DSORG=QS\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHLFVS": {"ttr": 8449, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x01#\\x01#\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 291, "newlines": 291, "modlines": 0, "user": "ARCHIVR"}, "text": "LFVS     TITLE 'ARCHIVER --- LFVS FUNCTION'\nARCHLFVS CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n         COPY #ARCBITS\n         USING ARCHLFVS,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             LOAD ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHLFVS,R11        DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             LOAD NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RELOAD BACK POINTER\n         L     R14,12(,R14)        RELOAD ORIG. REG 14\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         XC    MCNT,MCNT           INIT. THE ITEM COUNT\n         ZAP   LSTLIN#,=P'99'      START ON A NEW PAGE\n         LA    R1,VSAM1DD          POINT TO THE PARAMETER\n         MVC   VS1MODE,=CL8'INPUT'\n         LA    R0,0                SET THE 'OPEN' SIGNAL\n         CALL  ARCHVSOP            CALL THE VSAM-OPEN SUBROUTINE\n         LTR   R15,R15             OPEN OK ??\n         BNZ   ENDITALL            NOPE; GIVE UP THE SHIP\n         XC    CALLIST(4),CALLIST\n         CNOP  0,4\n         BAL   R1,BLDPOOL          BRANCH AROUND PARM LIST\n         DC    F'100'\n         DC    F'100'\n         DC    F'56'\n         DC    AL1(14)\n         DC    AL1(20)\n         DC    CL20'LOGICAL FILE NAMES '\nBLDPOOL  DS    0H\n         CALL  CELLBLD\n         ST    R0,NAMEPOOL         SAVE THE 'TOKEN' VALUE\n         EJECT\n*---------------------------------------------------------------------*\n*---     HERE'S THE MEAT OF THE PROCESSING. THE BASIC PROCESS IS   ---*\n*---           THIS:                                               ---*\n*---                                                               ---*\n*---     1. USING THE CONTROL INFORMATION WE WERE GIVEN AND THE    ---*\n*---        INFORMATION WE'VE DEVELOPED, LOCATE THE HEADER RECORD  ---*\n*---        FOR THE FIRST MEMBER. WE'LL USE THE VS1BUF1 AREA FOR   ---*\n*---        HEADER/KEY CONSTRUCTION.                               ---*\n*---                                                               ---*\n*---     2. LOOP THROUGH THE MEMBER, READING THE RECORDS AND       ---*\n*---        EXPLODING THEM INTO THE COMPRK AREA, WRITING EACH      ---*\n*---        'LOGICAL' RECORD AS IT BECOMES AVAILABLE.              ---*\n*---------------------------------------------------------------------*\n         MVC   TITLE3,SH10         REPORT SUBTITLE LINE\nMEMBERS  DS    0H\n         L     R6,VS1BUF1          POINT TO THE VSAM BUFFER\n         USING REC,R6              BASE THE RECORD DSECT\n         XC    0(RECKLEN,R6),0(R6)    START AT THE BEGINNING !!\n         MVI   RECTT,#RTHDR        START WITH HEADERS\n         MVC   RECN,Q1             COPY INITIAL NAME\n         MVC   RECG,Q2             COPY INITIAL GROUP\n         MVC   RECSG,Q2            COPY INITIAL SUBGROUP\n         MVC   RECT,Q2             COPY INITIAL TYPE\n         TR    RECN(40),NOGENS     CLOBBER GENERIC MARKERS\n         MODCB RPL=(*,RPL1),                                           X\n               OPTCD=(SEQ,FKS,KGE,SYN),                                X\n               ACB=(*,ACB1),                                           X\n               ARG=(*,VS1BUF1),                                        X\n               AREA=(*,VS1BUF1),                                       X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         L     R1,RPL1             LOAD THE RPL ADDRESS\n         POINT RPL=(1)             GET TO IT\nNEXTHDR  DS    0H\n         L     R6,VS1BUF1          POINT TO THE RECORD\n         L     R1,RPL1             LOAD RPL ADDRESS\n         GET   RPL=(1)             AND READ A HEADER RECORD\n         LTR   R15,R15             ARE WE DONE ??\n         BNZ   ENDITALL            YES ---\n         SHOWCB RPL=(*,RPL1),                                          X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,VS1LEN1),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\nF1       DS    0H\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\n         #IF   RSRALIAS,OFF,F2     NOT AN ALIAS\n         B     NEXTHDR             SKIP ALIASES\nF2       DS    0H\n         LA    R1,RECN             POINT TO THE HEADER\n         LA    R0,0                USE DEFAULT QUALIFIER DATA\n         CALL  ARCHKNAM            GO CHECK: DO WE PROCESS THIS ITEM ??\n         LTR   R15,R15             PASS THE CHECK ??\n         BNZ   NEXTHDR             NOPE ---\n         MVC   @BYTEC,@RSRFLG1     SAVE VERSION NUMBER FOR EXPANDER\n         LA    R1,RECTT            POINT TO THE HEADER RECORD\n         BAL   R9,CHAINER          CHECK/LFVS HEADER RECORD\n         L     R15,MCNT            LOAD MEMBER COUNT\n         LA    R15,1(,R15)         INCREMENT BY ONE\n         ST    R15,MCNT            AND SAVE UPDATED VALUE\n         B     NEXTHDR             AND CONTINUE\nENDITALL DS    0H\n*---------------------------------------------------------------------*\n*---     AT THIS POINT, WE'VE CHAINED ALL THAT CAN BE CHAINED.    ----*\n*---     NOW GENERATE THE LISTING, WITH APPROPRIATE TITLES, AND   ----*\n*---     TERMINATE. AFTER EACH LINK IS LISTED, WE UNCHAIN IT,      ---*\n*---     FREEMAIN THE STORAGE AND LOOP BACK TO RESTART THE         ---*\n*---     LISTING PROCESS.                                          ---*\n*---------------------------------------------------------------------*\n         NC    CALLIST(4),CALLIST  ALL LINKS DONE ??\n         BZ    LSTD                YES ---\n         L     R10,CALLIST         LOAD A LINK POINTER\n         MVC   CALLIST(4),0(R10)   UNCHAIN IT\n         MVI   LINE,C' '           SEED IN A BLANK\n         MVC   LINE+1(120),LINE    AND CLEAR THE LINE\n         LA    R2,LINE+1           POINT TO OUTPUT AREA\n         MVI   0(R2),C'-'\n         LA    R2,1(,R2)\n         MVC   0(10,R2),12(R10)    MOVE THE GROUP\n         MVI   10(R2),C'-'         AND FIELD SEPARATOR\n         LA    R2,11(,R2)          INCREMENT TRAVELING POINTER\n         MVC   0(10,R2),22(R10)    MOVE THE SUBGROUP OVER\n         MVI   10(R2),C'-'         AND FIELD SEPARATOR\n         LA    R2,11(,R2)          INCREMENT TRAVELING POINTER\n         MVC   0(10,R2),32(R10)    MOVE THE TYPE OVER\n         MVI   10(R2),C'-'         AND FIELD SEPARATOR\n         LA    R2,11(,R2)          INCREMENT TRAVELING POINTER\n         ICM   R0,15,42(R10)       INSERT THE VERSION\n         X     R0,=F'-1'           INVERT ALL BITS\n         CVD   R0,DWORK            AND DECIMALIZE IT\n         OI    DWORK+7,X'0F'       FORST LAST SIGN NUMERIC\n         MVC   0(12,R2),SH11        MOVE IN THE EDIT MASK\n         ED    0(12,R2),DWORK+3     EDIT IN THE VERSION NUMBER\n         LA    R2,14(,R2)          POINT PAST IT\n         $CVRECFM 0(,2),46(R10)\n         CLI   0(R2),C'U'          RECFM = U ??\n         LA    R2,6(,R2)\n         BE    SH4                 YES; SKIP LRECL\n         LA    R15,0               CLEAR A WORK REG\n         ICM   R15,3,47(R10)       INSERT THE LRECL VALUE\n         CVD   R15,DWORK           DECIMALIZE IT\n         OI    DWORK+7,X'0F'       FORST LAST SIGN NUMERIC\n         MVC   0(7,R2),SH8         MOVE IN THE EDIT MASK\n         ED    0(7,R2),DWORK+5     EDIT IN THE LRECL\nSH4      DS    0H\n         LA    R15,0               RE-CLEAR R15\n         LA    R2,9(,R2)\n         ICM   R15,3,49(R10)       INSERT THE BLKSIZE VALUE\n         CVD   R15,DWORK           DECIMALIZE IT\n         OI    DWORK+7,X'0F'       FORST LAST SIGN NUMERIC\n         MVC   0(7,R2),SH8         MOVE IN THE EDIT MASK\n         ED    0(7,R2),DWORK+5     EDIT IN THE BLKSIZE\n         LA    R2,9(,R2)\n         ICM   R0,15,4(R10)        INSERT THE ITEM COUNT\n         CVD   R0,DWORK            AND DECIMALIZE IT\n         OI    DWORK+7,X'0F'       FORCE LAST SIGN NUMERIC\n         MVC   1(12,R2),SH11       MOVE IN THE EDIT MASK\n         ED    1(12,R2),DWORK+3    EDIT IN THE COUNT\n         LA    R2,13(,R2)\n         ICM   R0,15,8(R10)        INSERT THE ITEM COUNT\n         CVD   R0,DWORK            AND DECIMALIZE IT\n         OI    DWORK+7,X'0F'       FORCE LAST SIGN NUMERIC\n         MVC   1(12,R2),SH11       MOVE IN THE EDIT MASK\n         ED    1(12,R2),DWORK+3    EDIT IN THE COUNT\nSH5      DS    0H\n         #PUT  LINE                PRINT IT OUT\n         B     ENDITALL\nLSTD     DS    0H\n         #ERR  MSG=11\n         L     R0,MCNT             LOAD MEMBER COUNT\n         LTR   R0,R0               ZERO COUNT ??\n         BZ    END1                YES ---\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,TCMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\nEND1     DS    0H\n         LA    R1,VSAM1DD          LOAD THE PARM POINTER\n         LA    R0,4                SET THE 'CLOSE' FLAG\n         CALL  ARCHVSOP            CALL THE OPEN/CLOSE ROUTINE\n         L     R0,NAMEPOOL         LOAD THE 'TOKEN' ADDRESS\n         CALL  CELLDEL             DELETE MY CELL POOL\n         L     R13,4(,R13)         LOAD BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ALWAYS RC = 0\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\n         TITLE 'LOCAL SUBROUTINE TO SAVE A HEADER RECORD '\n*---------------------------------------------------------------------*\n*---     THIS LITTLE LOCAL SUBROUTINE CHAINS TOGETHER ALL THE     ----*\n*---     VARIATIONS OF QUALIFIER DATA AND DCB ATTRIBUTES IN A     ----*\n*---     SINGLE-LINKED LIST, IN SORTED ORDER.  THE INFORMATION    ----*\n*---     SAVED CONSISTS OF THE GROUP, SUBGROUP AND TYPE           ----*\n*---     QUALIFIERS, THE VERSION NUMBERS AND THE DCB ATTRIBUTES.  ----*\n*---     EACH TIME ANY OF THESE ITEMS CHANGES, A NEW CHAIN-LINK   ----*\n*---     IS CREATED AND INSERTED AT THE APPROPRIATE PLACE IN THE  ----*\n*---     CHAIN.  SINCE ALL STORAGE FOR THE CHAIN IS GETMAINED     ----*\n*---     FROM A SINGLE SUBPOOL, AT PROCESSING END A SIMPLE        ----*\n*---     'ALL-THE-SUBPOOL' FREEMAIN IS PERFORMED TO RELEASE THE   ----*\n*---     STORAGE.                                                 ----*\n*---------------------------------------------------------------------*\n         SPACE 3\nCHAINER  DS    0H\n         STM   R14,R12,IOSAVE      SAVE ENTRY REGISTERS\n         LR    R6,R1               COPY THE RECORD ADDRESS\n         USING REC,R6              AND BASE ITS DSECT\n         XC    BLDLAREA,BLDLAREA   CLEAR A WORK AREA\n         MVC   BLDLAREA(34),RECG COPY QUALIFIERS OVER\n         MVC   BLDLAREA+34(1),RSRREC COPY RECORD FORMAT\n         MVC   BLDLAREA+35(2),RSRLRE COPY LRECL OVER\n         MVC   BLDLAREA+37(2),RSRBLK AND BLKSIZE\n         LSRCH CALLIST,BLDLAREA(43),ST=ASC,RAL=R10,RAN=R9,$KEY=12\n         BZ    LPY                 YES; JUST INCREMENT THE COUNTS\n         L     R0,NAMEPOOL         LOAD TOKEN ADDRESS\n         CALL  CELLGET             GET ONE OF MY 'QUIKCELLS'\n         XC    0(56,R1),0(R1)      CLEAR IT OUT\n         MVC   12(43,R1),BLDLAREA  ADD THE KEY FIELDS\n         ST    R9,0(,R1)           STORE THE LINK POINTER\n         ST    R1,0(,R10)          STORE THE LINK POINTER\n         LR    R9,R1               AND COPY TO MY 'STD' REGISTER\nLPY      DS    0H\n         L     R0,4(,R9)           LOAD THE ITEM COUNT\n         AH    R0,=H'1'            INCREMENT BY ONE\n         ST    R0,4(,R9)           SAVE UPDATED COUNT\n         ICM   R0,15,RSRRCNT       LOAD THE RECORD COUNT\n         A     R0,8(,R9)           ADD TO TOTAL\n         ST    R0,8(,R9)           SAVE UPDATED VALUE\n         LM    R14,R12,IOSAVE      RESTORE ENTRY REGISTERS\n         BR    R9                  AND RETURN TO LOCAL CALLER\n         DROP  R6\nSH10     DC    C'    GROUP   -'\n         DC    C'  SUBGRP  -'\n         DC    C'  TYPE    -'\n         DC    C'   VERSION'\n         DC    C'    RECFM'\n         DC    C'   LRECL'\n         DC    C'     BLKL'\n         DC    C'          ITEMS'\n         DC    C'      RECORDS'\n         DC    CL34' '\nSH11     DC    C' ',X'202020',C',',X'202020',C',',X'202020'\nTCMSG    DC    CL133' '\n         ORG   TCMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    C' TOTAL ITEMS LISTED. '\n         ORG\nSH8      DC    C' ',X'2020',C',',X'202020'\n         LTORG\nMINREC   DC    A(RECSIZE)\nNOGENS   DC    XL16'000102030405060708090A0B0C0D0E0F'\n         DC    XL16'101112131415161718191A1B1C1D1E1F'\n         DC    XL16'202122232425262728292A2B2C2D2E2F'\n         DC    XL16'303132333435363738393A3B3C3D3E3F'\n         DC    XL16'404142434445464748494A4B4C4D4E4F'\n         DC    XL16'505152535455565758595A5B5C5D5E5F'\n         DC    XL16'606162636465666768696A6B6C6D6E6F'\n         DC    XL16'707172737475767778797A7B7C7D7E7F'\n         DC    XL16'808182838485868788898A8B8C8D8E8F'\n         DC    XL16'909192939495969798999A9B9C9D9E9F'\n         DC    XL16'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'\n         DC    XL16'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'\n         DC    XL16'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'\n         DC    XL16'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'\n         DC    XL16'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'\n         ORG   NOGENS+C'%'\n         DC    X'00'\n         ORG   NOGENS+C'*'\n         DC    X'00'\n         ORG\n         COPY  #RECS\n         COPY  ##ARCHWK\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHLIST": {"ttr": 8455, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x01\\xf5\\x01\\xf5\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 501, "newlines": 501, "modlines": 0, "user": "ARCHIVR"}, "text": "LIST     TITLE 'ARCHIVER --- LIST FUNCTION'\n*---------------------------------------------------------------------*\n*---     ALL LIST REQUESTS ARE ROUTED HERE FOR FURTHER             ---*\n*---     PROCESSING.  OPTIONS INCLUDE LISTING JUST THE HEADERS,    ---*\n*---     HEADERS AND NOTES, HEADERS AND DATA, OR HEADERS, NOTES    ---*\n*---     AND DATA.  ALTHOUGH A SUBTITLE IS PRESENT GIVING COLUMN   ---*\n*---     HEADINGS, THESE ARE MEANINGFUL ONLY FOR ITEM HEADER       ---*\n*---     DATA.  THE NOTE LISTING IS A BASIC LINE-FOR-LINE LISTING  ---*\n*---     OF THE NOTE DATA ORIGINALLY ADDED TO THE ITEM, WITH A     ---*\n*---     LEADING LINE NUMBER AND FLAG CHARACTER.  THE DATA         ---*\n*---     LISTING MAY TAKE ON EITHER OF TWO FORMATS.  EITHER A HEX  ---*\n*---     LIST, WITH RECORD NUMBER AND OFFSET WITHIN THE RECORD,    ---*\n*---     OR A CHARACTER LISTING, EXTENDED ACROSS MULTIPLE LINES    ---*\n*---     AS NEEDED FOR LONG RECORDS.  A FUTURE ENHANCEMENT WILL    ---*\n*---     ALLOW ANY PDS DIRECTORY INFORMATION STORED IN THE HEADER  ---*\n*---     RECORD TO BE LISTED AS PART OF THE HEADER LISTING.        ---*\n*---     (INCLUDING ALIAS DATA.)                                   ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nARCHLIST CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n         USING ARCHLIST,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             LOAD ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHLIST,R11        DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             LOAD NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RELOAD BACK POINTER\n         L     R14,12(,R14)        RELOAD ORIG. REG 14\n         LA    R10,0(,R11)         COPY ORIGINAL BASE REGISTER\n         AH    R10,PASSIT-2        BUMP BY A BASE'S WORTH\n         USING ARCHLIST+4096,R10   AND DECLARE IT\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         COPY #ARCBITS\n         XC    MCNT,MCNT           INIT. THE ITEM COUNT\n         ZAP   LSTLIN#,=P'99'      START ON A NEW PAGE\n         L     R0,=F'32768'        CMPWRK LENGTH\n         LR    R3,R0               AND COPY IT\n         ICM   R0,8,=AL1(10)       SET THE SUBPOOL NUMBER\n         GETMAIN R,LV=(0)          GRAB A EXPAND WORK AREA\n         STM   R0,R1,CMPWRKL       SAVE ADDRESS AND LENGTH\n         LR    R2,R1               COPY ITS ADDRESS\n         LA    R15,0               PAD/SOURCE LENGTH = ZERO\n         MVCL  R2,R14              CLEAR THE AREA !!\n         MVC   VS1MODE,=CL8'INPUT' SET THE I/O MODE\n         LA    R1,VSAM1DD          LOAD THE PARM POINTER\n         LA    R0,0                AND THE 'OPEN' FLAG\n         CALL  ARCHVSOP            CALL THE 'OPEN' FUNCTION\n         LTR   R15,R15             OPEN OK ??\n         BNZ   ENDITALL            NOPE; CAN'T WORK\n         EJECT\n*---------------------------------------------------------------------*\n*---     HERE'S THE MEAT OF THE PROCESSING. THE BASIC PROCESS IS   ---*\n*---           THIS:                                               ---*\n*---                                                               ---*\n*---     1. USING THE CONTROL INFORMATION WE WERE GIVEN AND THE    ---*\n*---        INFORMATION WE'VE DEVELOPED, LOCATE THE HEADER RECORD  ---*\n*---        FOR THE FIRST MEMBER. WE'LL USE THE VS1BUF2 AREA FOR   ---*\n*---        HEADER/KEY CONSTRUCTION.                               ---*\n*---                                                               ---*\n*---     2. LOOP THROUGH THE MEMBER, READING THE RECORDS AND       ---*\n*---        EXPLODING THEM INTO THE COMPRK AREA, WRITING EACH      ---*\n*---        'LOGICAL' RECORD AS IT BECOMES AVAILABLE.              ---*\n*---------------------------------------------------------------------*\n         MVC   TITLE3,SH10         REPORT SUBTITLE LINE\nMEMBERS  DS    0H\n         L     R6,VS1BUF2          POINT TO THE VSAM BUFFER\n         USING REC,R6              BASE THE RECORD DSECT\n         XC    0(RECKLEN,R6),0(R6)    START AT THE BEGINNING !!\n         MVI   RECTT,#RTHDR        START WITH HEADERS\n         MODCB RPL=(*,RPL2),                                           X\n               OPTCD=(SEQ,FKS,KGE,SYN),                                X\n               ACB=(*,ACB1),                                           X\n               ARG=(*,VS1BUF2),                                        X\n               AREA=(*,VS1BUF2),                                       X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         L     R1,RPL2             LOAD THE RPL ADDRESS\n         POINT RPL=(1)             GET TO IT\nNEXTHDR  DS    0H\n         L     R6,VS1BUF2          POINT TO THE RECORD\n         L     R1,RPL2             LOAD RPL ADDRESS\n         GET   RPL=(1)             AND READ A HEADER RECORD\n         LTR   R15,R15             ARE WE DONE ??\n         BNZ   ENDITALL            YES ---\n         SHOWCB RPL=(*,RPL2),                                          X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,CALLIST),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\nF1       DS    0H\n         L     R1,CALLIST\n         MVC   NUMTTR,CALLIST      COPY TO A SAVE AREA\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\n         LA    R1,RECN             POINT TO THE HEADER\n         LA    R0,0                USE DEFAULT QUALIFIER DATA\n         CALL  ARCHKNAM            GO CHECK: DO WE PROCESS THIS ITEM ??\n         LTR   R15,R15             PASS THE CHECK ??\n         BNZ   NEXTHDR             NOPE ---\n         LA    R1,RECTT            POINT TO THE HEADER RECORD\n         BAL   R9,LISTHDR          CHECK/LIST HEADER RECORD\n         MVC   @BYTEC,@RSRFLG1     SAVE VERSION NUMBER\n         LR    R7,R6               COPY THE BUFFER ADDRESS\n         L     R6,VS1BUF1          POINT TO THE OTHER BUFFER\n         MVC   0(RECKLEN,R6),0(R7) COPY THAT KEY\n         MVI   RECTT,#RTNOTE       RESET TO 'NOTE' TYPE\n         #IF   PRCCM,OFF,NOTE3\n         MODCB RPL=(*,RPL1),                                           X\n               OPTCD=(SEQ,FKS,KGE,SYN),                                X\n               ARG=(6),                                                X\n               ACB=(*,ACB1),                                           X\n               AREA=(*,VS1BUF1),                                       X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO ITEM DATA START\n         L     R1,RPL1             LOAD THE RPL ADDRESS\n         POINT RPL=(1)             GET TO IT\n         ZAP   ACNT,=P'0'          RESET LINE COUNT\nNOTE1    DS    0H\n         L     R6,VS1BUF1          POINT TO THE BUFFER\n         L     R1,RPL1             POINT TO THE RPL\n         GET   RPL=(1)             GO READ A MEMBER DATA RECORD\n         LTR   R15,R15             DID IT COMPLETE OK ??\n         BNZ   NOTE3               NOPE; ASSUME WE'RE DONE\n         SHOWCB RPL=(*,RPL1),                                          X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,CALLIST),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\n         CLI   RECTT,#RTNOTE       DATA RECORD ??\n         BNE   NOTE3\n         CLC   1(RECKLEN-5,R6),1(R7) STILL IN THE RIGHT ITEM ??\n         BNE   NOTE3               NOPE; CHECK FOR DATA LIST\n         L     R8,CALLIST          LOAD RECORD LENGTH\n         LA    R8,0(R8,R6)         POINT TO\n         BCTR  R8,R0                 LAST DATA BYTE\n         LA    R6,RDATDATA         POINT TO ITEM DATA\nNOTE2    DS    0H\n         L     R4,CMPWRK           POINT TO EXPAND OUTPUT AREA\n         LA    R2,0\n         ICM   R2,3,3(R6)          LOAD EXPANDED RECORD LENGTH\n         ST    R2,CALLIST+12       SAVE NEW RECORD LENGTH\n         LA    R3,5(,R6)           POINT TO ACTUAL RECORD DATA\n         CALL  EXPAND,((4),CALLIST+12,(3)),MF=(E,CALLIST)\n         LR    R0,R2               COPY THE RECORD LENGTH\n         LR    R1,R4               AND ITS ADDRESS\n         BAL   R9,LSTCHAR          CHARACTER LIST OF RECORD\n         ICM   R2,7,0(R6)          INSERT SEGMENT LENGTH\n         LA    R6,3(R2,R6)         GO TO NEXT SEGMENT\n         CR    R6,R8               ANOTHER SEGMENT TO PROCESS ??\n         BL    NOTE2               YES ---\n         B     NOTE1               NOPE ---\nNOTE3    DS    0H\n         ZAP   ACNT,=P'0'          CLEAR THE LINE COUNT\n         L     R6,VS1BUF1          LOAD ANOTHER BUFFER POINTER\n         MVC   0(RECKLEN,R6),0(R7) COPY THAT KEY\n         MVI   RECTT,#RTDATA       RESET TO 'DATA' TYPE\n         #IF   SHITEM,OFF,NEXTHDR\n         MODCB RPL=(*,RPL1),                                           X\n               OPTCD=(SEQ,FKS,KGE,SYN),                                X\n               ARG=(6),                                                X\n               ACB=(*,ACB1),                                           X\n               AREA=(*,VS1BUF1),                                       X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO ITEM DATA START\n         L     R1,RPL1             LOAD THE RPL ADDRESS\n         POINT RPL=(1)             GET TO IT\nDATA1    DS    0H\n         L     R6,VS1BUF1          LOAD ANOTHER BUFFER POINTER\n         L     R1,RPL1             POINT TO THE RPL\n         GET   RPL=(1)             GO READ A MEMBER DATA RECORD\n         LTR   R15,R15             DID IT COMPLETE OK ??\n         BNZ   NEXTHDR             NOPE; ASSUME WE'RE DONE\n         SHOWCB RPL=(*,RPL1),                                          X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,CALLIST),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\n         CLI   RECTT,#RTDATA       DATA RECORD ??\n         BNE   NEXTHDR\n         CLC   1(RECKLEN-5,R6),1(R7) STILL IN THE RIGHT ITEM ??\n         BNE   NEXTHDR             NOPE; DO STOWS 'N' STUFF\n         LA    R3,RDATDATA         POINT TO ITEM DATA\n         L     R8,CALLIST          LOAD RECORD LENGTH\n         LA    R8,0(R8,R6)         POINT TO\n         BCTR  R8,R0                 LAST DATA BYTE\n         LA    R6,RDATDATA         POINT TO ITEM DATA\nDATA2    DS    0H\n         L     R4,CMPWRK           POINT TO EXPAND OUTPUT AREA\n         LA    R2,0\n         ICM   R2,3,3(R6)          LOAD EXPANDED RECORD LENGTH\n         ST    R2,CALLIST+12       SAVE NEW RECORD LENGTH\n         LA    R3,5(,R6)           POINT TO ACTUAL RECORD DATA\n         CALL  EXPAND,((4),CALLIST+12,(3)),MF=(E,CALLIST)\n         LR    R0,R2               COPY THE RECORD LENGTH\n         LR    R1,R4               AND ITS ADDRESS\n         #IF   SHHEX,ON,DATAH\n         BAL   R9,LSTCHAR          CHARACTER LIST OF RECORD\n         B     DATAL               AND CONTINUE\nDATAH    DS    0H\n         BAL   R9,LSTHEX           HEX LIST OF RECORD(S)\nDATAL    DS    0H\n         ICM   R2,7,0(R6)          INSERT SEGMENT LENGTH\n         LA    R6,3(R2,R6)         GO TO NEXT SEGMENT\n         CR    R6,R8               ANOTHER SEGMENT TO PROCESS ??\n         BL    DATA2               YES ---\n         B     DATA1               NOPE ---\nENDITALL DS    0H\n         #ERR  MSG=11\n         L     R0,MCNT             LOAD MEMBER COUNT\n         LTR   R0,R0               ZERO COUNT ??\n         BZ    END1                YES ---\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,TCMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\nEND1     DS    0H\n         CLC   ACB1,=F'0'          WAS ACB EVER OPENED ??\n         BE    NOACB               NOPE ---\n         LA    R1,VSAM1DD          POINT TO THE DDNAME\n         LA    R0,4                SET 'CLOSE' REQUEST\n         CALL  ARCHVSOP            CALL THE VSAM 'CLOSE' ROUTINE\nNOACB    DS    0H\n         XC    CMPWRKL(8),CMPWRKL  FORGET THOSE VALUES, TOO\n         L     R13,4(,R13)         LOAD BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ALWAYS RC = 0\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\n         TITLE 'LOCAL SUBROUTINE TO LIST A HEADER RECORD '\n*---------------------------------------------------------------------*\n*---     THIS LITTLE LOCAL SUBROUTINE FORMATS AND LISTS THE        ---*\n*---     CONTENTS OF THE HEADER RECORD, INCLUDING SUCH MUNDATE     ---*\n*---     DATA AS THE ORIGINAL RECORD FORMAT, LOGICAL RECORD        ---*\n*---     LENGTH, DATASET ORGANIZATION AND BLOCKSIZE.  ALSO THE     ---*\n*---     TIME AND DATE THE ITEM WAS ADDED TO THE ARCHIVE AND THE   ---*\n*---     ITEM'S LOGICAL RECORD COUNT.                              ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nLISTHDR  DS    0H\n         STM   R14,R12,IOSAVE      SAVE ENTRY REGISTERS\n         L     R15,MCNT            LOAD THE MEMBER COUNTER\n         LA    R15,1(,R15)         INCREMENT BY ONE\n         ST    R15,MCNT            AND SAVE UPDATED COUNT\n         MVC   TITLE3,SH10         REPORT SUBTITLE LINE\n         #FORMAT RECTT\n         LR    R2,R0               COPY NEXT-AVAILABLE-BYTE POINTER\n         LA    R2,1(,R2)           INCREMENT BY ONE\n         #IF   RSRALIAS,OFF,SH1    ALIAS RECORD ??\n         MVC   0(11,R2),=CL11' ALIAS FOR '\n         #FORMAT RECAN-1,OUT=11(R2),CLEAR=NO\n         B     SH5\nSH1      DS    0H\n         $CVDSORG 0(,2),RSRDSO\n         LA    R2,6(,R2)           INCREMENT BY ONE\n         $CVRECFM 0(,2),RSRREC\n         CLI   0(R2),C'U'          RECFM = U ??\n         LA    R2,6(,R2)\n         BE    SH4                 YES; SKIP LRECL\n         LA    R15,0               CLEAR A WORK REG\n         ICM   R15,3,RSRLRE        INSERT THE LRECL VALUE\n         CVD   R15,DWORK           DECIMALIZE IT\n         OI    DWORK+7,X'0F'       FORST LAST SIGN NUMERIC\n         MVC   0(7,R2),SH8         MOVE IN THE EDIT MASK\n         ED    0(7,R2),DWORK+5     EDIT IN THE LRECL\nSH4      DS    0H\n         LA    R15,0               RE-CLEAR R15\n         LA    R2,9(,R2)\n         ICM   R15,3,RSRBLK        INSERT THE BLKSIZE VALUE\n         CVD   R15,DWORK           DECIMALIZE IT\n         OI    DWORK+7,X'0F'       FORST LAST SIGN NUMERIC\n         MVC   0(7,R2),SH8         MOVE IN THE EDIT MASK\n         ED    0(7,R2),DWORK+5     EDIT IN THE BLKSIZE\n         LA    R2,9(,R2)\n         CLC   NUMTTR,=A(RSRT1LEN) ANY MORE IN HEADER ??\n         BE    SH5                 NO TIME/DATE FIELDS\n         CLI   RSRDATE,0           NEW FORMAT DATE ??              Y2K\n         BE    DATENEW             YES ---                         Y2K\n         MVC   2(8,R2),RSRDATE     COPY THE DATE\n         MVC   0(6,R2),2(R2)       MAKE ROOM FOR CENTURY\n         MVC   6(2,R2),=C'19'      INSERT CENTURY\n         LA    R2,11(,R2)          POINT TO CLOCK FIELD\n         MVC   0(8,R2),RSRTIME     MOVE THE CLOCK FIELD\n         B     DOCOUNT             GO FORMAT THE RECORD COUNT\nDATENEW  DS    0H                                                  Y2K\n         UNPK  2(8,R2),RSRDATE     UNPK DATE INTO LINE             Y2K\n         MVC   0(2,R2),2(R2)       MAKE ROOM                       Y2K\n         MVC   3(2,R2),4(R2)         FOR SLASHES                   Y2K\n         MVI   2(R2),C'/'                                          Y2K\n         MVI   5(R2),C'/'                                          Y2K\n         LA    R2,11(,R2)          POINT TO TIME FIELD             Y2K\n         UNPK  2(6,R2),RSRTIME     UNPACK TIME INTO THE FIELD      Y2K\n         MVC   0(2,R2),2(R2)       MAKE ROOM                       Y2K\n         MVC   3(2,R2),4(R2)          FOR COLONS                   Y2K\n         MVI   2(R2),C':'                                          Y2K\n         MVI   5(R2),C':'                                          Y2K\nDOCOUNT  DS    0H\n         CLC   NUMTTR,=A(RSRT2LEN) ANY MORE IN HEADER ??\n         BE    SH5                 NO TIME/DATE FIELDS\n         LA    R2,9(,R2)           POINT TO COUNT FIELD\n         ICM   R0,15,RSRRCNT       INSERT THE RECORD COUNT\n         CVD   R0,DWORK            AND DECIMALIZE IT\n         OI    DWORK+7,X'0F'       FORCE LAST SIGN NUMERIC\n         MVC   1(12,R2),SH11       MOVE IN THE EDIT MASK\n         ED    1(12,R2),DWORK+3    EDIT IN THE COUNT\nSH5      DS    0H\n         #PUT  LINE                PRINT IT OUT\n         MVI   LINE,C' '           SEED IN A BLANK\n         MVC   LINE+1(120),LINE    AND PROPOGATE ---\n         LM    R14,R12,IOSAVE      RESTORE ENTRY REGISTERS\n         BR    R9                  AND RETURN TO LOCAL CALLER\nSH10     DC    CL2'  '\n         DC    CL10'  MEMBER  '                                    HEAD\n         DC    CL1'-'\n         DC    CL10'  GROUP  '                                     HEAD\n         DC    CL1'-'\n         DC    CL10'  SUBGRP '                                     HEAD\n         DC    CL1'-'\n         DC    CL10'  TYPE  '                                      HEAD\n         DC    CL1'-'\n         DC    CL12'   VERSION '                                   HEAD\n         DC    CL2' '\n         DC    CL3'DS'                                             HEAD\n         DC    CL3'    '\n         DC    CL5'RFM  '                                          HEAD\n         DC    CL3'   '\n         DC    CL5'LRECL'                                          HEAD\n         DC    CL3' '\n         DC    CL5' BLKL'                                          HEAD\n         DC    CL5'   '\n         DC    CL4'DATE'                                           HEAD\n         DC    CL5' '\n         DC    CL6'  TIME'                                         HEAD\n         DC    CL5' '\n         DC    CL12'    RECORDS '                                  HEAD\n         DC    CL10' '\nSH11     DC    C' ',X'202020',C',',X'202020',C',',X'202020'\nTCMSG    DC    CL133' '\n         ORG   TCMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    C' TOTAL ITEMS LISTED. '\n         ORG\nSH8      DC    C' ',X'2020',C',',X'202020'\n         TITLE 'LOCAL SUBROUTINE TO LIST A CHARACTER-FORMAT RECORD'\n*---------------------------------------------------------------------*\n*---     THIS ROUTINE LISTS A RECORD IN CHARACTER FORMAT.  ANY     ---*\n*---     LENGTH RECORD, FROM ANY TYPE OF ITEM, MAY BE LISTED.      ---*\n*---     (USEFULNESS OF THAT LISTING IS PROBLEMATICAL.  PRINTED    ---*\n*---     LOAD MODULES ANYONE ??)  THOSE RECORDS THAT COULD SPAN    ---*\n*---     MULTIPLE LINES ARE BROKEN INTO SEGMENTS AND PRINTED AS    ---*\n*---     MULTIPLE LINES.  THE RECORD START IS ALWAYS ON THE LINE   ---*\n*---     THAT HAS THE LINE NUMBER PREFIXING THE DATA FIELD.  THE   ---*\n*---     USER IS CAUTIONED THAT CONTROL INFORMATION FOR RECORDS    ---*\n*---     THAT WERE ORIGINALLY VARIABLE LENGTH IS NOT PRESENT,      ---*\n*---     SINCE THE ARCHIVER MAINTAINS ALL THAT SORT OF CONTROL IN  ---*\n*---     A SOMEWHAT DIFFERENT FASHION.                             ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nLSTCHAR  DS    0H\n         STM   R14,R12,IOSAVE      SAVE ENTRY REGISTERS\n         LR    R3,R1               COPY RECORD ADDRESS\n         LR    R5,R0               AND LENGTH\n         AP    ACNT,=P'1'          INCREMENT RECORD COUNT\n         MVC   LINE+1(13),R#MSK    COPY THE EDIT MASK TO THE LINE\n         ED    LINE+1(8),ACNT      EDIT IN THE LINE NUMBER\n         AR    R5,R3               POINT PAST RECORD END\nLC1      DS    0H\n         LR    R4,R5               COPY RECORD END ADDRESS\n         SR    R4,R3               MINUS CURRENT POSITION\n         CH    R4,=H'100'          LONGER THAN A LINE SEGMENT ??\n         BNH   *+8                 NOPE ---\n         LA    R4,100              YES; USE ONE SEGMENT\n         BCTR  R4,R0               DECREMENT BY ONE\n         EX    R4,MOVELIN          COPY TO LINE AREA\n         #PUT  LINE                OUTPUT THE DATA LINE\n         MVI   LINE,C' '           SEED IN A BLANK\n         MVC   LINE+1(120),LINE    CLEAR THE LINE AREA\n         LA    R3,1(R4,R3)         POINT TO NEXT PIECE\n         CR    R3,R5               STILL GOING ??\n         BL    LC1                 AND CONTINUE ---\n         LM    R14,R12,IOSAVE      RESTORE REGISTERS\n         BR    R9                  AND RETURN TO CALLER\nR#MSK    DC    X'4020202020202020' LINE NUMBER EDIT MASK\n         DC    C' --> '\nMOVELIN  MVC   LINE+15(*-*),0(R3)  'EX'ED COPY OF DATA\n         TITLE 'LOCAL SUBROUTINE TO LIST A HEXADECIMAL-FORMAT RECORD'\n*---------------------------------------------------------------------*\n*---     THIS ROUTINE LISTS A RECORD IN CHARACTER FORMAT.  ANY     ---*\n*---     LENGTH RECORD, FROM ANY TYPE OF ITEM, MAY BE LISTED.      ---*\n*---     AGAIN, THE USEFULNESS IS LIMITED ONLY TO THE INGENUITY    ---*\n*---     OF THE USER.  THE RECORD NUMBER APPEARS ON THE FIRST      ---*\n*---     LINE OF MULTI-LINE RECORDS.  ONE ADDITIONAL FEATURE: THE  ---*\n*---     FIRST HEXADECIMAL FIELD IS THE OFFSET OF THIS SEGMENT     ---*\n*---     FROM THE BEGINNING OF THE RECORD.                         ---*\n*---                                                               ---*\n*---     THE USER IS CAUTIONED THAT CONTROL INFORMATION FOR        ---*\n*---     RECORDS THAT WERE ORIGINALLY VARIABLE LENGTH IS NOT       ---*\n*---     PRESENT, SINCE THE ARCHIVER MAINTAINS ALL THAT SORT OF    ---*\n*---     CONTROL IN A SOMEWHAT DIFFERENT FASHION.                  ---*\n*---                                                               ---*\n*---     THE METHOD OF USING MULTIPLE TRANSLATE INSTRUCTIONS TO    ---*\n*---     FORMAT THE RECORD WAS CHOSEN OVER THE 'UNPACK AND         ---*\n*---     TRANSLATE' METHOD FOR SPEED, PURE AND SIMPLE.  I          ---*\n*---     STRONGLY SUGGEST YOU LEARN IT WELL BEFORE YOU TRY TO      ---*\n*---     MAKE ANY CHANGES.  IT TAKES A LITTLE ACCLIMATING.         ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nLSTHEX   DS    0H\n         STM   R14,R12,IOSAVE      SAVE ENTRY REGISTERS\n         LR    R3,R1               COPY RECORD ADDRESS\n         LR    R5,R0               AND LENGTH\n         LA    R7,0                RESET OFFSET COUNTER\n         AP    ACNT,=P'1'          INCREMENT RECORD COUNT\n         MVC   LINE+1(8),RNUM      COPY THE EDIT MASK TO THE LINE\n         ED    LINE+1(8),ACNT      EDIT IN THE LINE NUMBER\n         AR    R5,R3               POINT PAST RECORD END\nLH1      DS    0H\n         MVI   GENWK,X'40'         STARTING VALUE\n         MVC   GENWK+1(68),GENWK   AND PROPOGATE IT\n         LR    R4,R5               COPY RECORD END ADDRESS\n         SR    R4,R3               MINUS CURRENT POSITION\n         CH    R4,=H'32'           LONGER THAN A LINE SEGMENT ??\n         BNH   *+8                 NOPE ---\n         LA    R4,32               YES; USE ONE SEGMENT\n         STH   R7,GENWK            SAVE THE OFFSET\n         BCTR  R4,R0               DECREMENT COUNT BY ONE\n         EX    R4,COPY1            CREATE THE FIRST COPY\n         MVC   GENWK+34(34),GENWK  AND THE SECOND COPY\n         LA    R4,2(,R4)           RESET THAT LENGTH\n         EX    R4,TR1              TRANSLATE THE FIRST HALF\n         EX    R4,TR2              AND THE SECOND HALF\n         MVC   LINE+14(78),PRMSK   MOVE TABLE TO OUTPUT LINE\n         TR    LINE+14(78),GENWK   TRANSLATE DATA INTO THE LINE\n         BCTR  R4,R0               DECREMENT COUNT BY ONE\n         #PUT  LINE                OUTPUT THE DATA LINE\n         MVI   LINE,C' '           SEED IN A BLANK\n         MVC   LINE+1(120),LINE    CLEAR THE LINE AREA\n         LA    R7,0(R4,R7)         INCREMENT THE OFFSET COUNTER\n         LA    R3,0(R4,R3)         POINT TO NEXT PIECE\n         CR    R3,R5               STILL GOING ??\n         BL    LH1                 AND CONTINUE ---\n         LM    R14,R12,IOSAVE      RESTORE REGISTERS\n         BR    R9                  AND RETURN TO CALLER\nRNUM     DC    X'4020202020202020' LINE NUMBER EDIT MASK\nMOVEHEX  MVC   LINE+93(*-*),0(R3)  'EX'ED COPY OF DATA\nTRHEX    TR    LINE+93(*-*),VISABLE\nVISABLE  DC    16CL16'................'\n         ORG   VISABLE+C'A'\n         DC    C'ABCDEFGHI'\n         ORG   VISABLE+C'J'\n         DC    C'JKLMNOPQR'\n         ORG   VISABLE+C'S'\n         DC    C'STUVWXYZ'\n         ORG   VISABLE+C'0'\n         DC    C'0123456789'\n         ORG\nCOPY1    MVC   GENWK+2(*-*),0(R3)  COPY TO GENWK AREA\nTR1      TR    GENWK(*-*),ZONES\nTR2      TR    GENWK+34(*-*),DIGITS\nZONES    DC    16C'0',16C'1',16C'2',16C'3'\n         DC    16C'4',16C'5',16C'6',16C'7'\n         DC    16C'8',16C'9',16C'A',16C'B'\n         DC    16C'C',16C'D',16C'E',16C'F'\nDIGITS   DC    16C'0123456789ABCDEF'\nPRMSK    DC    AL1(0,34,1,35,68)\n         DC    AL1(2,36,3,37,4,38,5,39,68)\n         DC    AL1(6,40,7,41,8,42,9,43,68)\n         DC    AL1(10,44,11,45,12,46,13,47,68)\n         DC    AL1(14,48,15,49,16,50,17,51,68,68)\n         DC    AL1(18,52,19,53,20,54,21,55,68)\n         DC    AL1(22,56,23,57,24,58,25,59,68)\n         DC    AL1(26,60,27,61,28,62,29,63,68)\n         DC    AL1(30,64,31,65,32,66,33,67,68)\n         LTORG\nMINREC   DC    A(RECSIZE)\n         COPY  #RECS\n         COPY  ##ARCHWK\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHLOAD": {"ttr": 8710, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x04\\x98\\x04\\x98\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 1176, "newlines": 1176, "modlines": 0, "user": "ARCHIVR"}, "text": "LOAD     TITLE 'ARCHIVER --- LOAD FUNCTION'\n*---------------------------------------------------------------------*\n*---     THIS ROUTINE IS THE SECOND HALF OF THE ARCHIVER'S REASON  ---*\n*---     FOR EXISTANCE: THE INFAMOUS LOAD FUNCTION.  THIS ROUTINE  ---*\n*---     WAS MODIFIED IN LEVEL 4.1 TO ALLOW FOR THE POSSIBILITY    ---*\n*---     OF ARCHIVER-TYPE ALIASES BEING SELECTED AS PART OF THE    ---*\n*---     SELECTION CRITERIA.  IF WE GET AN ARCHIVER-TYPE ALIAS     ---*\n*---     SELECTED, WE HAVE SOME ADDITIONAL 'SPECIAL' PROCESSING    ---*\n*---     TO AVOID DUPLICATE LOADS.                                 ---*\n*---                                                               ---*\n*---     WHAT WE DO FOR A SELECTED 'ALIAS' IS THIS.  FIRST, WE     ---*\n*---     CHECK THE 'REAL' NAME AGAINST THE ENTRIES IN A            ---*\n*---     SINGLY-LINKED CHAIN IN STORAGE.  IF THE REAL NAME IS      ---*\n*---     ALREADY PRESENT, WE IGNORE THIS ALIAS AND CONTINUE. IF    ---*\n*---     NOT, WE'LL ADD THE 'REAL' NAME TO THE CHAIN AND LOAD THE  ---*\n*---     'REAL' ITEM, RESTORING ALIASES AS APPROPRIATE.            ---*\n*---------------------------------------------------------------------*\nARCHLOAD CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n@RPL1    EQU   R2                  SOME\n@RPL2    EQU   R3                    SPECIAL\n@BUF1    EQU   R4                        EQUATES\n@BUF2    EQU   R5                          FOR\n@BUF3    EQU   R6                            VSAM I/O\n         COPY #ARCBITS\n         USING ARCHLOAD,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             LOAD ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHLOAD,R11        DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             LOAD NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RELOAD BACK POINTER\n         L     R14,12(,R14)        RELOAD ORIG. REG 14\n         LA    R10,0(,R11)         COPY ORIGINAL BASE REGISTER\n         AH    R10,PASSIT-2        BUMP BY A BASE'S WORTH\n         USING ARCHLOAD+4096,R10   AND DECLARE IT\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         XC    NAMEPOOL,NAMEPOOL   RESET THE POOL ID FIELD\n         XC    NAMECHN,NAMECHN     AND THE 'REAL' NAME CHAIN ROOT\n         XC    FCOUNT,FCOUNT       CLEAR FUNCTION RECORD COUNT\n         XC    MCNT,MCNT           AND MEMBER COUNT\n         XC    ACNT,ACNT           AND ALIAS COUNT\n         LA    R0,0                LOAD 'OPEN' INDICATOR\n         LA    R1,VSAM1DD          LOAD PARM POINTER\n         CALL  ARCHVSOP            GO OPEN THE INPUT CLUSTER\n         LTR   R15,R15             DID IT OPEN OK ??\n         BNZ   ENDITALL            NOPE; QUIT RIGHT HERE\n*---------------------------------------------------------------------*\n*---     NOW OPEN THE NON-VSAM DATASET. THE OPEN ROUTINE WILL      ---*\n*---     SET THE BLOCKER/DEBLOCKER BRANCH.                         ---*\n*---------------------------------------------------------------------*\n         BAL   R14,OPNVO           CALL THE OPEN ROUTINE\n         EJECT\n*---------------------------------------------------------------------*\n*---     HERE'S THE MEAT OF THE PROCESSING. THE BASIC PROCESS IS   ---*\n*---           THIS:                                               ---*\n*---                                                               ---*\n*---     1. USING THE CONTROL INFORMATION WE WERE GIVEN AND THE    ---*\n*---        INFORMATION WE'VE DEVELOPED, LOCATE THE HEADER RECORD  ---*\n*---        FOR THE FIRST MEMBER. WE'LL USE THE VS1BUF2 AREA FOR   ---*\n*---        HEADER/KEY CONSTRUCTION.                               ---*\n*---                                                               ---*\n*---     2. LOOP THROUGH THE MEMBER, READING THE RECORDS AND       ---*\n*---        EXPLODING THEM INTO THE BPAM BUFFERS, WRITING AS EACH  ---*\n*---        BUFFER GETS FULL.  THE I/O ROUTINES DESIGNATED BY THE  ---*\n*---        BRANCH INSTRUCTION AT 'BLOCK' WILL DETERMINE THE       ---*\n*---        BLOCKING MECHANISM USED.                               ---*\n*---                                                               ---*\n*---     3. AT END-OF-FILE FOR THE DATASET OR MEMBER, DO ANY STOW  ---*\n*---        THAT MAY BE APPROPRIATE.  FOR PDS MEMBERS WITH         ---*\n*---        ALIASES, WE ALSO STOW THE ALIASES AT THIS POINT.       ---*\n*---------------------------------------------------------------------*\n         L     @RPL1,RPL1          LOAD THE VSAM REGS\n         L     @RPL2,RPL2\n         L     @BUF1,VS1BUF1\n         L     @BUF2,VS1BUF2\n         LA    @BUF3,0\n         USING REC,@BUF1           BASE THE RECORD DSECT\n         XC    0(RECKLEN,@BUF1),0(@BUF1) START AT THE BEGINNING !!\n         MVI   RECTT,#RTHDR        WE ONLY WANT HEADERS\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN),                                X\n               ARG=(@BUF1),                                            X\n               AREA=(@BUF1),                                           X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         POINT RPL=(@RPL1)         GET TO IT\nNEXTHDR  DS    0H\n         GET   RPL=(@RPL1)         AND READ A HEADER RECORD\n         SHOWCB RPL=(@RPL1),                                           X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,VS1LEN1),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\n         LA    R1,RECN             POINT TO THE HEADER\n         LA    R0,0                USE DEFAULT QUALIFIER DATA\n         CALL  ARCHKNAM            GO CHECK: DO WE PROCESS THIS ITEM ??\n         LTR   R15,R15             PASS THE CHECK ??\n         BNZ   NEXTHDR             NOPE ---\n         #IF   RSRALIAS,OFF,REAL   NOT AN ALIAS RECORD\n         #IF   LDARCHA,OFF,NEXTHDR SKIP IF NOT CHECK ARCHIVE ALIASES\n         LR    @BUF3,@BUF1         COPY THE RECORD POINTER\n         L     @BUF1,VS1BUF3       START A FRESH BUFFER\n         MVC   RECN(44),RECAN-REC(@BUF3) GET 'REAL' QUALIFIERS\n         MVI   RECTT,#RTHDR        SET FOR A HEADER RECORD\n         MODCB RPL=(@RPL1),ARG=(@BUF1),AREA=(@BUF1),MF=(G,GENWK)\n         POINT RPL=(@RPL1)\n         GET   RPL=(@RPL1)         READ THE 'REAL' HEADER\n         SHOWCB RPL=(@RPL1),                                           X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,VS1LEN1),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\n         CLC   1(44,@BUF1),RECAN-REC(@BUF3) RIGHT RECORD ??\n         BE    REAL                YES; CONTINUE\n         L     @BUF1,VS1BUF1       RELOAD BUFFER POINTER\n         LA    @BUF3,0\n         B     LDDN2               AND SCAT ---\nREAL     DS    0H\n         LA    R1,RECTT            POINT TO THE HEADER RECORD AGAIN\n         CALL  ARCHKDCB            GO COMPARE DCB'S\n         LTR   R15,R15             STILL OK ??\n         BNZ   LDDN1A              NOPE; SKIP THIS ITEM\n         LA    R1,RECN             POINT TO NAME START\n         BAL   R14,CHKCHN          GO CHECK: DONE ALREADY ??\n         LTR   R15,R15             CHECKED OUT OK ??\n         BNZ   LDDN1A              NOPE; SKIP THIS ITEM\n         LA    R1,RECN             POINT TO ITEM NAME\n         BAL   R14,CHAINER         ADD IT TO MY CHAIN\n         LTR   @BUF3,@BUF3         WAS LOAD TRIGGERED BY AN ALIAS ??\n         BZ    NOTRIG              NOPE ---\n         #FORMAT 0(@BUF1),,TRIGGER OUTPUT THE 'TRIGGER' MESSAGE\n         #PUT  LINE\nNOTRIG   DS    0H\n         #IF   NVSPO,OFF,NOTPO     CHECK THE DSORG FLAG\n         #IF   REPL,ON,NOTPO       REPLACE ANYHOW\n         MVC   BLDLAREA(4),=AL2(1,76)\n         MVC   BLDLAREA+4(8),RECN  COPY THE MEMBER NAME IN\n         L     R1,NDCBA            LOAD THE DCB ADDRESS\n         BLDL  (1),BLDLAREA        CHECK: IS THE MEMBER THERE ??\n         LTR   R15,R15             WAS IT FOUND ??\n         BNZ   NOTPO               NOPE; CONTINUE ---\n         #FORMAT RECTT,,STOWM1\n         #PUT  LINE\n         B     LDDN1A              AND GO FORMAT THE MESSAGE\nNOTPO    DS    0H\n         CLI   RSRDSO,DCBDSGPO     IS IT A PO MEMBER UNLOADED ??\n         BNE   NODIR               NOPE ---\n         LA    R1,0                CLEAR A WORK REGISTER\n         IC    R1,RSRPDIR+11       LOAD DIR ENTRY LENGTH\n         N     R1,=A(X'1F')        TRIM TO BARE LENGTH\n         SLL   R1,1                TIMES TWO\n         LA    R1,11(,R1)          COMPUTE TOTAL ENTRY LENGTH\n         EX    R1,NODIR-6          COPY DIR TO BLDLAREA\n         B     NODIR               AND GO ---\n         MVC   BLDLAREA(1),RSRPDIR 'EX'ED COPY OF DIR ENTRY\nNODIR    DS    0H\n         MVC   @BYTEC,@RSRFLG1     SAVE VERSION #                  V6.0\n         LA    R1,RECTT            COPY THE HEADER ADDRESS\n         BAL   R14,IOSEP           GO DO A SEPARATOR (MAYBE)\n         DROP  @BUF1\n         USING REC,@BUF2\n         MVC   0(RECKLEN,@BUF2),0(@BUF1) COPY THAT KEY\n         MVI   RECTT,#RTDATA       RESET TO DATA TYPE\n         MODCB RPL=(@RPL2),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN),                                X\n               ARG=(@BUF2),                                            X\n               AREA=(@BUF2),                                           X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO ITEM DATA START\n         POINT RPL=(@RPL2)         GET TO IT\nLDLOOP   DS    0H\n         GET   RPL=(@RPL2)         GO READ A MEMBER DATA RECORD\n         LTR   R15,R15             DID IT COMPLETE OK ??\n         BNZ   LDDONE              NOPE; ASSUME WE'RE DONE\n         SHOWCB RPL=(@RPL2),                                           X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,VS1LEN2),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\n         CLI   RECTT,#RTDATA       DATA RECORD ??\n         BNE   LDDONE\n         CLC   1(RECKLEN-5,@BUF2),1(@BUF1) STILL IN THE RIGHT ITEM ??\n         BNE   LDDONE              NOPE; DO STOWS 'N' STUFF\n         LA    R9,RDATDATA         POINT TO ITEM DATA\n         L     R8,VS1LEN2          LOAD RECORD LENGTH\n         LA    R8,0(R8,@BUF2)      POINT TO\n         BCTR  R8,R0                 LAST DATA BYTE\nWRTLOOP  DS    0H\n         L     R0,TCOUNT           LOAD THE RECORD COUNT\n         A     R0,=F'1'            COUNT THIS RECORD\n         ST    R0,TCOUNT           STORE UPDATED COUNT\n         LA    R0,0                CLEAR REGISTER ZERO\n         ICM   R0,7,0(R9)          LOAD SEGMENT LENGTH\n         LA    R1,3(,R9)           POINT TO SEGMENT START\n         BAL   R14,PUT             GO WRITE A LOGICAL RECORD\n         LA    R0,0                CLEAR REGISTER ZERO\n         ICM   R0,7,0(R9)          LOAD SEGMENT LENGTH\n         AR    R9,R0               BUMP TO\n         LA    R9,3(,R9)             NEXT SEGMENT\n         CR    R9,R8               ANOTHER SEGMENT TO PROCESS ??\n         BL    WRTLOOP             YES ---\n         B     LDLOOP              NOPE ---\nLDDONE   DS    0H\n         #SET  NOEXP,ON            NOTE LIST ALREADY EXPANDED\n         L     R1,NOTELIST         LOAD NOTELIST POINTER\n         LTR   R1,R1               WAS ANY PRESENT ??\n         BZ    LDDN1               NOPE ---\n         L     R0,0(,R1)           LOAD ITS LENGTH\n         SH    R0,=H'4'            ACCOUNT FOR TTR WORD\n         LA    R1,4(,R1)           POINT TO ACTUAL DATA\n         BAL   R14,PUT             GO WRITE THE NOTE LIST\n         L     R1,NOTELIST\n         L     R0,0(,R1)           LOAD ITS LENGTH\n         ICM   R0,8,=AL1(10)       INSERT SUBPOOL NUMBER\n         FREEMAIN R,LV=(0),A=(1)\nLDDN1    DS    0H\n         #SET  NOEXP,OFF\n         XC    NOTELIST,NOTELIST   AND RESET THE POINTER\n         LA    R0,0                ZERO LENGTH RECORD\n         BAL   R14,PUT             AND PURGE THE BUFFERS\n         DROP  @BUF2\n         USING REC,@BUF1\n         LR    R0,@BUF1            COPY RECORD ADDRESS\n         A     R0,VS1LEN1          POINT TO RECORD END\n         LA    R1,RSRPDIR          POINT TO DIRECTORY DATA\n         SR    R0,R1               COMPUTE DIRDATA LENGTH\n         BAL   R14,ENDSEP          TRAILING SEPARATORS FOR PS OUTPUT\n         BAL   R14,PDSSTOW         GO DO STOWS (MAYBE)\nLDDN1A   DS    0H\n         LTR   @BUF3,@BUF3         WAS LOAD TRIGGERED BY AN ALIAS ??\n         BZ    LDDN2               NOPE ---\n         LR    @BUF1,@BUF3         RESTORE TO ALIAS VALUE\n         LA    @BUF3,0             RESET THE INDICATOR\nLDDN2    DS    0H\n         LA    R15,0               CLEAR A WORK REGISTER\n         IC    R15,RECT+9\n         LA    R15,1(,R15)\n         STC   R15,RECT+9\n         MODCB RPL=(@RPL1),AREA=(@BUF1),ARG=(@BUF1),MF=(G,GENWK)\n         POINT RPL=(@RPL1)\n         #IF   GENM,ON,NEXTHDR     LOOP IF GENERIC NAME\n         #IF   GENG,ON,NEXTHDR     LOOP IF GENERIC GROUP\n         #IF   GENSG,ON,NEXTHDR    LOOP IF GENERIC SUBGROUP\n         #IF   GENT,ON,NEXTHDR     LOOP IF GENERIC TYPE\n         DROP  @BUF1\nENDITALL DS    0H\n         NC    NAMEPOOL,NAMEPOOL   ANY NAME POOL ??\n         BZ    NOPOOL              NOPE ---\n         L     R0,NAMEPOOL         LOAD TOKEN VALUE\n         CALL  CELLDEL             GO DELETE THE CELL POOL\nNOPOOL   DS    0H\n         XC    NAMEPOOL,NAMEPOOL   RESET THE FIELD\n         XC    NAMECHN,NAMECHN     AND THE CHAIN ROOT\n         L     R0,TCOUNT           LOAD TOTAL RECORD COUNT\n         A     R0,FCOUNT           ADD FUNCTION COUNT\n         ST    R0,TCOUNT           SAVE UPDATED COUNT\n         #ERR  MSG=10\n         L     R0,TCOUNT           LOAD TOTAL-RECORD COUNT\n         LTR   R0,R0               ANY VALUES TO CONVERT ??\n         BZ    CLOSES              NOPE ---\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,TCMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\n         L     R0,MCNT             LOAD MEMBER COUNT\n         LTR   R0,R0               ANY VALUES TO CONVERT ??\n         BZ    CLOSES              NOPE ---\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,MCMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\n         L     R0,ACNT             LOAD ALIAS COUNT\n         LTR   R0,R0               ANY VALUES TO CONVERT ??\n         BZ    CLOSES              NOPE ---\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,ACMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\nCLOSES   DS    0H\n         CLC   ACB1,=F'0'          WAS ACB EVER OPENED ??\n         BE    NOACB               NOPE ---\n         LA    R1,VSAM1DD          LOAD PARM POINTER\n         LA    R0,4                LOAD 'CLOSE' INDICATOR\n         CALL  ARCHVSOP            CALL THE 'CLOSE' ROUTINE\nNOACB    DS    0H\n         BAL   R14,NVSCLOSE        GO CLOSE THE INPUT FILE\n         FREEMAIN R,SP=10          RELEASE ALL MY STORAGE\n         L     R13,4(,R13)         LOAD BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ALWAYS RC = 0\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\n         TITLE 'OPEN NONVSAM OUTPUT DATASET '\n*---------------------------------------------------------------------*\n*---     THIS LITTLE LOCAL SUBROUTINE DOES SEVERAL THINGS          ---*\n*---     NECESSARY PRIMARILY FOR LOAD-MODULE RECOGNITION AND       ---*\n*---     PROCESSING. FIRST AND FOREMOST, WE DETERMINE THE DSORG    ---*\n*---     OF THE OUTPUT DATASET. IF OUTPUT IS A SEQUENTIAL          ---*\n*---     DATASET, WE CAN ASSUME THAT ONLY ONE DCB WILL BE NEEDED.  ---*\n*---     IF THE OUTPUT DATASET IS A PDS, WE NEED AT LEAST TWO      ---*\n*---     DCBS; ONE FOR DATA AND ANOTHER FOR THE DIRECTORY          ---*\n*---     INFORMATION PROCESSED BY ARCHDIR.  HERE'S A VERY          ---*\n*---     SIMPLISTIC VIEW OF THE PROCESSING HERE.  (FURTHER MODS    ---*\n*---     FOR PROCESSING PANVALET LIBRARIES ARE PLANNED BUT NOT     ---*\n*---     YET IMPLEMENTED.)                                         ---*\n*---                                                               ---*\n*---     1. DETERMINE THE DSORG OR THE DATASET. IF NOT PS OR PO,   ---*\n*---        WRITE NASTY MESSAGES TO THE USER AND QUIT RIGHT HERE.  ---*\n*---                                                               ---*\n*---     2. BUILD AND OPEN THE PRIMARY DCB.  SINCE WE USE BSAM     ---*\n*---        FOR OUTPUT OF SEQUENTIAL DATASETS, WE CAN (ALMOST)     ---*\n*---        USE THE SAME DCB FOR BOTH SEQUENTIAL AND PARTITIONED   ---*\n*---        DATASETS.  WE ONLY NEED TO CHANGE THE DSORG VALUE IN   ---*\n*---        THE DCB.  DURING THE 'OPEN' PROCESS, AN EXIT WILL      ---*\n*---        BUILD A BUFFER POOL OF TWO BUFFERS.  BUFFERS ARE       ---*\n*---        'GETBUF'ED AND SAVED IN THE ARCHIVER MAIN WORK AREA.   ---*\n*---                                                               ---*\n*---     3. IF THE DSORG IS PO AND RECFM = U, WE NEED ONE          ---*\n*---        ADDITIONAL STEP: BUILD AN ADDITIONAL DCB AND OPEN IT   ---*\n*---        FOR 'UPDAT' I/O.  THIS WILL BE USED BY THE MAINLINE    ---*\n*---        CODE TO UPDATE NOTE LISTS IN LOAD MODULES, IF WE HAVE  ---*\n*---        ANY.                                                   ---*\n*---                                                               ---*\n*---     NOTE: THE ARCHIVER MAKES NO ATTEMPT TO REASSEMBLE OR      ---*\n*---     RECONSTRUCT A SPANNED RECORD.                             ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nOPNVO    DS    0H\n         STM   R14,R12,IOSAVE      SAVE THE ENTRY REGISTERS\n*        #IF   NVPAN,ON,PANOPEN    REALLY A PANLIB ??\n*---\n*---     BUILD A DCB, TO START, FOR DSORG CHECKING\n*---\n         GETMAIN R,LV=BSDCBL,SP=10 GRAB STORAGE FOR BPAM DCB\n         ST    R1,NDCBA            AND STORE ADDRESS IN ARCHIVWA\n         MVI   NDCBA,X'80'         BUILD OPEN PARM LIST\n         MVC   0(BSDCBL,R1),BSDCB  COPY DCB TO DYNAMIC AREA\n         USING IHADCB,R1           BASE THE DCB DSECT\n         MVC   DCBDDNAM,NVSAMDD    MOVE IN THE DDNAME\n         DROP  R1\n*---\n*---     GET THE VOLSER FROM THE UCB, STARTING FROM THE TIOT.\n*---\n         NC    TIOTA,TIOTA         HAVE WE ALREADY DONE THIS ??\n         BNZ   OPNVO1              YES ---\n         MVC   CALLIST(EXTL),EXTRPARM COPY PARMLIST FOR EXTRACT\n         EXTRACT TIOTA,'S',FIELDS=TIOT,MF=(E,CALLIST) LOCATE THE TIOT\n         L     R1,TIOTA            LOAD THE TIOT POINTER\n         LA    R1,24(,R1)          POINT TO THE FIRST TIOE\n         ST    R1,TIOTA            SAVE UPDATED ADDRESS\nOPNVO1   DS    0H\n         L     R1,TIOTA            LOAD TIOT ELEMENT POINTER\nOPNVO2   DS    0H\n         CLI   0(R1),0             AT TIOT END ??\n         BE    NODDERR             YES; DD STATEMENT IS MISSING\n         CLC   NVSAMDD,4(R1)       IS THIS THE DD ENTRY ??\n         BE    OPNVO3              YES; GO FETCH UCB ADDR\n         IC    R0,0(,R1)           INSERT TIOE LENGTH\n         N     R0,=F'255'          TRIM TO JUST THE LENGTH\n         AR    R1,R0               BUMP TO NEXT ENTRY\n         B     OPNVO2              AND CONTINUE THE SEARCH\nOPNVO3   DS    0H\n         L     R1,16(,R1)          LOAD UCB POINTER\n         N     R1,=A(X'FFFFFF')    TRIM GARBAGE BYTES\n         MVC   VOLSER,28(R1)       COPY THE VOLSER\n         MVC   DEVT,16(R1)         AND UCB TYPE\n         TM    DEVT+2,X'A0'        IS THIS A DASD OR TAPE DEVICE ??\n         BZ    ERRDEV              NOPE; INVALID AS HELL\n*---\n*---     GET THE DSNAME. DISREGARD ANY MEMBER NAME\n*---\n         L     R2,NDCBA            LOAD THE DCB ADDRESS\n         USING IHADCB,R2           AND BASE ITS DSECT\n         LA    R0,DCBJFC           LOAD EXIT LIST POINTER\n         STCM  R0,7,DCBEXLSA       SAVE IN THE DCB\n         LA    R0,JFC              POINT TO JFCB AREA\n         ST    R0,DCBJFC           SAVE IN EXIT LIST\n         MVI   DCBJFC,X'87'        EXIT TYPE, LAST FLAG\n         RDJFCB ,MF=(E,NDCBA)      READ THE JFCB\n         DROP  R2\n*---\n*---     BUILD AND EXECUTE THE CAMLIST/OBTAIN SEQUENCE IF DASD\n*---     DATASET. USE THE FORMAT-1 DSCB TO DETERMINE IF THE\n*---     DATASET IS PARTITIONED OR SEQUENTIAL.  IF THE DATASET\n*---     IS SEQUENTIAL OR TAPE, WE BYPASS ANY BPAM STUFF.\n*---\n         TM    DEVT+2,X'80'        IS IT A TAPE DEVICE ??\n         BO    OPNVO4              YES; ALWAYS SEQUENTIAL\n         MVC   CALLIST(LCAMLST),CAMLST COPY CAMLIST TO WORK AREA\n         LA    R0,JFC              LOAD DSNAME POINTER\n         ST    R0,CALLIST+4        SAVE IN CAMLIST AREA\n         LA    R0,VOLSER           POINT TO VOLSER\n         ST    R0,CALLIST+8        SAVE IN CAMLIST AREA\n         LA    R0,GENWK            POINT TO DSCB AREA\n         ST    R0,CALLIST+12       SAVE IN CAMLIST AREA\n         OBTAIN CALLIST            FETCH THE DSCB\n         LA    R1,GENWK            POINT TO THE WORK AREA\n         USING DS1FMTID,R1         AND BASE THE DSECT PORTION\n         TM    DS1DSORG,DS1DSGPS   SEQUENTIAL ??\n         BO    OPNVO4              YES ---\n         TM    DS1DSORG,DS1DSGPO   PARTITIONED ??\n         BO    OPNVO5              YES ---\n         B     ORGERR              UNABLE TO PROCESS ANY OTHER DSORG\n         DROP  R1\n*---\n*---     SET THE DSORG IN THE PRIMARY DCB ACCORDING TO THE VALUE\n*---     FOUND IN THE FORMAT-1 DSCB.  ALSO, SET A PAIR OF SPECIAL\n*---     FLAGS IN THE ARCHIVER WORK AREA.  THIS ALLOWS ME TO\n*---     DETERMINE IF I'M REALLY PROCESSING A PDS, REQUIRING\n*---     FIND'S, ETC. OR JUST BE WARY OF AN END-OF-FILE THAT WILL\n*---     ULTIMATELY TERMINATE THE PROCESS.  IT ALSO DETERMINES\n*---     WHETHER I NEED A DIRECTORY DCB, FOR LATER.\n*---\nOPNVO4   DS    0H\n         #SET  NVSPS,ON            SET THE DSORG FLAG\n         #SET  NVSPO,OFF           SET THE DSORG FLAG\n         L     R2,NDCBA            LOAD DCB ADDRESS\n         USING IHADCB,R2\n         MVC   0(BSDCBL,R2),BSDCB  COPY IN THE PROPER DCB\n         MVC   DCBDDNAM,NVSAMDD    MOVE IN THE DDNAME\n         DROP  R2\n         CLC   SEPVAL,=CL8'IEBUPDTE' IEBUPDTE-TYPE SEPARATORS ??\n         BNE   OPNVO4A             NOPE ---\n         MVC   IOSEP(2),=X'47F0'\n         MVC   IOSEP+2(2),=S(SEPUPDTE)\nOPNVO4A  DS    0H\n         B     OPNVO6              GO SET UP THE VSAM I/O BLOCKS,ETC.\nOPNVO5   DS    0H\n         #SET  NVSPO,ON            SET THE DSORG FLAG\n         #SET  NVSPS,OFF           SET THE DSORG FLAG\n         L     R2,NDCBA            LOAD DCB ADDRESS\n         USING IHADCB,R2\n         MVC   0(PODCBL,R2),PODCB  COPY IN THE PROPER DCB\n         MVC   DCBDDNAM,NVSAMDD    MOVE IN THE DDNAME\n         DROP  R2\nOPNVO6   DS    0H\n*---\n*---     SET THE ADDRESS OF MY 'COMPLETION' EXIT INTO THE DCB AND\n*---     PROCEED WITH THE NECESSARY OPEN, ETC.\n*---\n         L     R2,NDCBA            POINT TO PRIMARY DCB\n         USING IHADCB,R2\n         LA    R0,OPNVO13          LOAD EXIT LIST POINTER\n         STCM  R0,7,DCBEXLSA       SAVE IN THE DCB\n         OPEN  (,OUTPUT),MF=(E,NDCBA) OPEN THE DCB\n*---\n*---     GRAB A PAIR OF BUFFERS FROM THE POOL BUILT DURING OPEN\n*---     PROCESSING.\n*---\n         GETBUF (2),(3)            GRAB A BUFFER\n         GETBUF (2),(4)            AND ANOTHER BUFFER\n         LA    R0,4                LOAD INITIAL VB LENGTH\n         SLL   R0,16               CREATE BDW WORD\n         ST    R0,0(,R3)           FIRST BUFFER\n         ST    R0,0(,R4)           AND SECOND BUFFER\n         STM   R3,R4,BPBUF1        SAVE POINTERS IN WORK AREA\n         ST    R3,BLOCKWDS         START OF BUFFER\n         XC    BLOCKWDS+4(4),BLOCKWDS+4 BLOCK IS EMPTY YET ---\n         #SET  BUFUSED,OFF         ALL BUFFERS EMPTY\n         #SET  IOGOING,OFF         NO I/O IN PROGRESS\n         MVC   BLOCK,=X'47F0E000'  INITIALIZE ---\n         MVC   NVSRECFM,DCBRECFM   COPY THE RECORD FORMAT\n         MVC   NVSBLKL,DCBBLKSI    AND BLKSIZE\n         MVC   NVSLRECL,DCBLRECL   AND LRECL\n*---\n*---     USING THE RECFM AS A GUIDE, SET THE S-TYPE ADDRESS OF\n*---     THE APPROPRIATE DEBLOCKER INTO THE BRANCH INSTRUCTION AT\n*---     'BLOCK'\n*---\n         TM    DCBRECFM,DCBRECU    U-FORMAT ??\n         BNO   OPNVO7              NOPE ---\n         MVC   BLOCK+2(2),=S(PUTU) SET 'U' ROUTINE\n         B     OPNVO12             SCAT ---\nOPNVO7   DS    0H\n         TM    DCBRECFM,DCBRECV+DCBRECBR VB FORMAT ??\n         BNO   OPNVO8              NOPE ---\n         MVC   BLOCK+2(2),=S(PUTVB) SET 'VB' ROUTINE\n         B     OPNVO12             SCAT ---\nOPNVO8   DS    0H\n         TM    DCBRECFM,DCBRECF+DCBRECBR FB FORMAT ??\n         BNO   OPNVO9              NOPE ---\n         MVC   BLOCK+2(2),=S(PUTFB) SET 'FB' ROUTINE\n         B     OPNVO12             SCAT ---\nOPNVO9   DS    0H\n         TM    DCBRECFM,DCBRECV    V FORMAT ??\n         BNO   OPNVO10             NOPE ---\n         MVC   BLOCK+2(2),=S(PUTV) SET 'V' ROUTINE\n         B     OPNVO12             SCAT ---\nOPNVO10  DS    0H\n         TM    DCBRECFM,DCBRECF    V FORMAT ??\n         BNO   OPNVO11             NOPE ---\n         MVC   BLOCK+2(2),=S(PUTF) SET 'F' ROUTINE\n         B     OPNVO12             SCAT ---\nOPNVO11  DS    0H\n         #PUT  =CL133'- UNABLE TO DETERMINE NONVSAM DATASET FORMAT'\n         ABEND 999,DUMP\nOPNVO12  DS    0H\n         L     R0,=F'32768'        LOAD COMPRESS MAX LENGTH\n         ICM   R0,8,=AL1(10)       INSERT SUBPOOL NUMBER\n         GETMAIN R,LV=(0)\n         STM   R0,R1,CMPWRKL       STORE COMPRESS WORK-AREA ADDRESS\n         LM    R14,R12,IOSAVE      RELOAD ENTRY REGISTERS\n         BR    R14                 AND RETURN TO LOCAL CALLER\n         DROP  R2\n*---\n*---     THIS IS A SHORT AND SNEAKY DCB COMPLETION EXIT. ITS ONLY\n*---     PURPOSE IS TO ESTABLISH THE BUFFER POOL FOR THE PRIMARY\n*---     DCB. THIS POOL CONTAINS TWO BUFFERS, EACH BEING 4 BYTES\n*---     LONGER THAN THE BLKSIZE OF THE DCB.\n*---\n*---     NOTE: THE GETPOOL ROUTINE WILL FAIL IF THE HIGH-ORDER\n*---     BIT OF THE DCB ADDRESS IS NOT ZERO. SOME SPECIAL GLITCH\n*---     IN THE IECQBFG1 CODE FOR A SPECIAL APPLICATION\n*---     SOMEWHERE.\n*---\nOPNVO13  DS    0F\n         DC    XL1'85',AL3(OPNVO13+4)\n         USING IHADCB,R1\n         LA    R1,0(,R1)           PURIFY DCB ADDRESS\n         LH    R0,DCBBLKSI         LOAD THE BLKSIZE\n         AH    R0,=H'4'            FOR LATER ---\n         ICM   R0,12,=H'2'         BUFFER COUNT\n         GETPOOL (1),(0)           BUILD A BUFFER POOL\n         DROP  R1\n         BR    R14                 AND RETURN TO O/C/EOV\n         TITLE 'BSAM/BPAM CLOSE ROUTINE'\n*---------------------------------------------------------------------*\n*---     THIS LITTLE ROUTINE CLOSES THE NONVSAM DATASET (ALL       ---*\n*---     DCB'S), RELEASES ALL BUFFER POOLS, RESETS POINTER         ---*\n*---     VALUES, RELEASE THE COMPRESSION WORK AREA AND CLEANS UP   ---*\n*---     THE NONVSAM I/O IN GENERAL, INCLUDING THE RESETING OF     ---*\n*---     ANY FLAG BITS.                                            ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nNVSCLOSE DS    0H\n         STM   R14,R12,IOSAVE      SAVE THE ENTRY REGISTERS\n         L     R2,NDCBA            LOAD PRIMARY DCB ADDRESS\n         LA    R2,0(,R2)           PURIFY THE ADDRESS\nNVSCX    DS    0H\n         LTR   R2,R2               ZERO ??\n         BZ    NVC1                YES; NO DCB HERE ---\n         TM    48(R2),X'10'        IS IT OPEN ??\n         BZ    NVCA                NOPE ---\n         CLOSE MF=(E,NDCBA)        CLOSE THE DCB\nNVCA     DS    0H\n         #FREE (2)                 RELEASE BUFFER POOL, IF ANY\n         XC    NDCBA,NDCBA         AND RESET THE POINTER FIELD\nNVC1     DS    0H\n         XC    DEVT,DEVT           CLEAR SAVED VALUES\n         XC    NVSDSORG,NVSDSORG\n         XC    VOLSER,VOLSER\n         XC    BLOCKWDS(8),BLOCKWDS\n         XC    NVSRECFM,NVSRECFM\n         XC    NVSBLKL,NVSBLKL\n         XC    NVSLRECL,NVSLRECL\n         XC    BPBUF1,BPBUF1\n         XC    BPBUF2,BPBUF2\nNOCMPW   DS    0H\n         XC    CMPWRKL(8),CMPWRKL\n         MVC   BLOCK+2(2),=S(0(R14))\n         #SET  IOGOING,OFF\n         #SET  BUFUSED,OFF\n         #SET  TRUNC,OFF\n         #SET  NVSPS,OFF\n         #SET  NVSPO,OFF\n         LM    R14,R12,IOSAVE      RESTORE THE REGISTERS\n         BR    R14                 AND RETURN TO CALLER\n         TITLE 'DIRECTORY ''STOW'' SUBROUTINE'\n*---------------------------------------------------------------------*\n*---     THIS LOCAL SUBROUTINE TAKES CARE OF ALL STOW PROCESSING.  ---*\n*---     FUNCTIONS INCLUDE UPDATING TTR'S IN THE DIRECTORY ENTRY   ---*\n*---     AND STOWING ALIAS DATA, WHERE APPROPRIATE.                ---*\n*---------------------------------------------------------------------*\nPDSSTOW  DS    0H\n         USING REC,@BUF1\n         STM   R14,R12,IOSAVE      SAVE ENTRY REGISTERS\n         LR    R5,R1               COPY DIRDATA POINTER\n         LR    R3,R0               COPY DIRDATA LENGTH\n         LA    R3,0(R3,R5)         POINT TO END\n         BCTR  R3,R0               DECREMENT, FOR LOOPING ---\n         MVC   BLOCKWDS,BPBUF1     START OF BUFFER\n         XC    BLOCKWDS+4(4),BLOCKWDS+4 BLOCK IS EMPTY YET ---\n         #SET  BUFUSED,OFF         ALL BUFFERS EMPTY\n         #SET  IOGOING,OFF         NO I/O IN PROGRESS\n         CR    R5,R3               ANYTHING TO STOW ??\n         BH    STOWDONE            NOPE; ALL DONE\n         #IF   NVSPS,ON,STOWPS     SEQUENTIAL OUTPUT ??\n         L     R2,NDCBA            LOAD PDS DCB ADDRESS\n         LA    R2,0(,R2)           AND PURIFY ADDRESS\n         LM    R7,R8,BPBUF1        LOAD BUFFER ADDRESSES\n         MVC   0(4,R7),=X'00040000' RE-INIT FOR VB\n         MVC   0(4,R8),=X'00040000' RE-INIT FOR VB\n         LM    R7,R9,BLDLAREA+8    LOAD TTR DATA FROM BLDLAREA\nSTOW1    DS    0H\n         CR    R5,R3               ANYTHING TO STOW ??\n         BH    STOWDONE            NOPE; ALL DONE\n         LA    R15,0               CLEAR A WORK REGISTER\n         IC    R15,11(,R5)         LOAD DIR LENGTH BYTE\n         N     R15,=A(X'1F')       TRIM TO BARE LENGTH\n         LA    R15,11(R15,R15)     COMPUTE LENGTH TO MOVE\n         EX    R15,DIRMOVE         COPY TO BLDLAREA\n         LA    R5,1(R15,R5)        BUMP INPUT POINTER\n         STCM  R7,14,BLDLAREA+8    SAVE MEMBER TTR\n         TM    BLDLAREA+11,B'01100000' ANY TTR'S IN USER DATA ??\n         BZ    STOW2               NOPE ---\n         STCM  R8,14,BLDLAREA+12   FIRST TEXT RCD (MAYBE)\n         TM    BLDLAREA+11,B'01000000' SECOND TTR IN USER DATA ??\n         BZ    STOW2               NOPE ---\n         STCM  R9,14,BLDLAREA+16   NOTE LIST (MAYBE)\nSTOW2    DS    0H\n         TM    BLDLAREA+11,X'80'   IS THIS AN ALIAS ??\n         BO    ALCNT               YES ---\n         L     R14,MCNT            LOAD MEMBER COUNT\n         A     R14,=F'1'           INCREMENT BY ONE\n         ST    R14,MCNT            STORE UPDATED COUNT\n         B     STOWD               GO ---\nALCNT    DS    0H\n         #IF   RETA,OFF,STOW1      SKIP IF NOT RETAINING ALIASES\n         L     R14,ACNT            LOAD MEMBER COUNT\n         A     R14,=F'1'           INCREMENT BY ONE\n         ST    R14,ACNT            STORE UPDATED COUNT\nSTOWD    DS    0H\n         STCM  R7,14,BLDLAREA+8    INSERT THE TTR VALUE            ***\n         TM    BLDLAREA+11,X'80'   ALIAS ??\n         BO    *+10\n         XC    BLDLAREA+8(3),BLDLAREA+8\n         #STOW (2),BLDLAREA        STOW (MAYBE) MEMBER NAME\nSTOWE    DS    0H\n         ICM   R7,14,BLDLAREA+8    INSERT THE TTR VALUE            ***\n         SRL   R15,2               DIVIDE BY FOUR\n         MH    R15,=H'51'          RC. TIMES MESSAGE LENGTH\n         LA    R15,STOWM(R15)      POINT TO THE MESSAGE\n         #FORMAT RECTT,,0(,R15)\n         TM    BLDLAREA+11,X'80'   ALIAS NAME ??\n         BZ    NOTALIAS            NOPE ---\n         LR    R1,R0               POINT TO NEXT AREA\n         MVC   0(7,R1),=CL7'(ALIAS)'\nNOTALIAS DS    0H\n         MVC   LINE+2(8),BLDLAREA  COPY THE REAL NAME OVER\n         #PUT  LINE\n         B     STOW1               AND CONTINUE ---\nDIRMOVE  MVC   BLDLAREA(1),0(R5)\nSTOWDONE DS    0H\n         LM    R14,R12,IOSAVE      RESTORE REGISTERS\n         BR    R14                 AND RETURN TO LOCAL CALLER\nSTOWPS   DS    0H\n         L     R14,MCNT            LOAD MEMBER COUNT\n         A     R14,=F'1'           INCREMENT BY ONE\n         ST    R14,MCNT            STORE UPDATED COUNT\n         #FORMAT RECTT,,SEQMSG     SEQUENTIAL DATASET MESSAGE\n         #PUT  LINE\n         B     STOWDONE            AND RETURN TO LOCAL CALLER\nSEQMSG   DC    AL1(50),CL50' ADDED TO SEQUENTIAL OUTPUT DATASET.'\nSTOWM    DC    AL1(50),CL50' SUCCESSFULLY STOWED IN PDS.'\nSTOWM1   DC    AL1(50),CL50' NOT REPLACED IN OUTPUT PDS.'\n         DC    AL1(50),CL50' '\n         DC    AL1(50),CL50' NOT STOWED. DIRECTORY OF PDS IS FULL.'\n         DC    AL1(50),CL50' NOT STOWED. PERMANENT I/O ERROR.'\n         DC    AL1(50),CL50' NOT STOWED. DCB INCORRECT OR NOT OPEN.'\n         DC    AL1(50),CL50' NOT STOWED. GETMAIN WITHIN STOW FAILED.'\n         DC    AL1(50),CL50' REPLACED IN OUTPUT PDS'\n         DC    AL1(50),CL50' '\n         DC    AL1(50),CL50' NOT FOUND. ADD ASSUMED.'\n         DC    AL1(50),CL50' NOT STOWED. DIRECTORY OF PDS IS FULL.'\n         DC    AL1(50),CL50' NOT STOWED. PERMANENT I/O ERROR.'\n         DC    AL1(50),CL50' NOT STOWED. DCB INCORRECT OR NOT OPEN.'\n         DC    AL1(50),CL50' NOT STOWED. GETMAIN WITHIN STOW FAILED.'\n         DROP  @BUF1\n         TITLE 'BSAM/BPAM WRITE ROUTINES '\n*---------------------------------------------------------------------*\n*---     REGS AT ENTRY:                                            ---*\n*---              R0 ::= LOGICAL RECORD LENGTH                     ---*\n*---              R1 --> LOGICAL RECORD                            ---*\n*---              R14 -> RETURN ADDRESS                            ---*\n*---                                                               ---*\n*---     IN THE SPECIAL CASE OF RECFM=U, R1 WILL ACTUALLY POINT    ---*\n*---     TO THE TTR WORD THAT PREFIXES THE DATA. R0 WILL BE ALSO   ---*\n*---     BE ADJUSTED TO REFLECT THIS FACT.                         ---*\n*---                                                               ---*\n*---     THE BUFUSED FLAG DENOTES A BUFFER WITH GOOD STUFF IN IT   ---*\n*---     BUT NO WRITE HAS STARTED FOR IT YET.                      ---*\n*---                                                               ---*\n*---     THE SPECIAL CASE OF A RECORD LENGTH OF ZERO SIGNALS A     ---*\n*---     REQUEST TO WRITE ALL REMAINING DATA, SIMILAR TO A QSAM    ---*\n*---     'TRUNC' MACRO.  THIS IS TYPICALLY NECESSARY WHEN THE      ---*\n*---     LAST BLOCK OF THE MEMBER IS NOT FULL.                     ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nPUT      DS    0H\n         STM   R14,R12,IOSAVE      SAVE INPUT REGISTERS\n         #SET  TRUNC,OFF           NOT YET, ANYWAY\n         L     R9,NDCBA            LOAD DCB ADDRESS\n         USING IHADCB,R9           AND BASE ITS DSECT\n         LR    R2,R1               AND ADDRESS\n         LTR   R3,R0               ANYTHING TO ADD ??\n         BNZ   EXPDR               YES ---\n         #SET  TRUNC,ON            NOPE; SET 'TRUNC' FLAG\n         B     BLOCK               GO TO THE BLOCK/WRITE ROUTINE\nEXPDR    DS    0H\n         #IF   NOEXP,ON,BLOCK\n         L     R4,CMPWRK           POINT TO EXPAND OUTPUT AREA\n         ST    R4,IOSAVE+12        SAVE EXPANDED RECORD ADDRESS\n         LH    R3,0(,R2)           LOAD EXPANDED RECORD LENGTH\n         ST    R3,IOSAVE+8         SAVE NEW RECORD LENGTH\n         LA    R2,2(,R2)           POINT TO ACTUAL RECORD DATA\n         CALL  EXPAND,((4),IOSAVE+8,(2)),MF=(E,CALLIST)\n         B     BLOCK               GO TO THE BLOCK/WRITE ROUTINE\n         TITLE 'BSAM/BPAM WRITE FIXED RECORDS '\n*---------------------------------------------------------------------*\n*---     FIXED, UNBLOCKED RECORDS.                                 ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nPUTF     DS    0H\n         #IF   TRUNC,ON,PUTF1      JUST CLEANING UP\n         L     R4,BPBUF1           LOAD BUFFER POINTER\n         LH    R5,DCBBLKSI         LOAD LRECL FOR RETURN\n         L     R2,IOSAVE+12        LOAD RECORD ADDRESS\n         L     R3,IOSAVE+8           AND LENGTH\n         MVCL  R4,R2               COPY RECORD TO BPAM BUFFER\nPUTF1    DS    0H\n         #IF   IOGOING,OFF,PUTF2   IS A WRITE IN PROGRESS ??\n         CHECK PDSDECB             YES; LET IT COMPLETE\n         #SET  IOGOING,OFF         SHOW NO MORE WRITE IN PROGRESS\nPUTF2    DS    0H\n         #IF   TRUNC,ON,PUTRET     ALL DONE ---\n         LM    R2,R3,BPBUF1        LOAD BUFFER POINTER WORDS\n         LR    R4,R2               SWAP BUFFERS\n         STM   R3,R4,BPBUF1        ...\n         WRITE PDSDECB,SF,(9),(4),'S',MF=E\n         #SET  IOGOING,ON          SHOW THAT A WRITE IS IN PROGRESS\n         B     PUTRET              AND GO RETURN TO LOCAL CALLER\n         TITLE 'BSAM/BPAM WRITE FIXED BLOCKED RECORDS '\n*---------------------------------------------------------------------*\n*---     FIXED, BLOCKED RECORDS.                                   ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nPUTFB    DS    0H\n         #IF   TRUNC,ON,PUTFB3     JUST CLEAN UP WHAT'S LEFT\n         #IF   BUFUSED,ON,PUTFBA   INIT. SETUP IS DONE ??\n         L     R4,BPBUF1           POINT TO FIRST BUFFER\n         LA    R5,0                AMOUNT USED ---\n         STM   R4,R5,BLOCKWDS      INIT. THE BLOCKING VALUES\nPUTFBA   DS    0H\n         #SET  BUFUSED,ON          TURN ON 'BUFFER USED' FLAG\n         LM    R4,R5,BLOCKWDS      NEXT-RECORD ADDRESS\n         LR    R6,R5               COPY CURRENT BUFFER-USED VALUE\n         AH    R6,DCBLRECL         ACCOUNT FOR A RECORD\n         ST    R6,BLOCKWDS+4\n         LA    R4,0(R5,R4)         POINT INTO THE BUFFER\n         LH    R5,DCBLRECL         LOAD LOGICAL RECORD LENGTH\n         L     R2,IOSAVE+12        LOAD RECORD ADDRESS\n         L     R3,IOSAVE+8           AND LENGTH\nPUTFB1   DS    0H\n         MVCL  R4,R2               MOVE RECORD INTO BUFFER\n         L     R2,BLOCKWDS+4       LOAD BYTES-USED VALUE\n         CH    R2,DCBBLKSI         AT END OF BUFFER ??\n         BL    PUTRET              NOPE; RETURN TO LOCAL CALLER\n         #IF   IOGOING,OFF,PUTFB2  IS A WRITE IN PROGRESS ??\n         CHECK PDSDECB             YES; LET IT COMPLETE\n         #SET  IOGOING,OFF         NO WRITE IN PROGRESS\n         #SET  BUFUSED,OFF         NEXT BUFFER IS EMPTY\nPUTFB2   DS    0H\n         LM    R2,R3,BPBUF1        LOAD BUFFER POINTER WORDS\n         LR    R4,R2               SWAP BUFFERS\n         STM   R3,R4,BPBUF1        ...\n         ST    R3,BLOCKWDS         STORE AS 'NEXT-RECORD' ADDRESS\n         XC    BLOCKWDS+4(4),BLOCKWDS+4 CLEAR 'BYTES-USED' VALUE\n         WRITE PDSDECB,SF,(9),(4),'S',MF=E\n         #SET  IOGOING,ON          SHOW THAT A WRITE IS IN PROGRESS\n         #SET  BUFUSED,OFF         TURN OFF 'BUFFER USED' FLAG\n         B     PUTRET              AND GO RETURN TO LOCAL CALLER\n*---------------------------------------------------------------------*\n*---     BUFFER PURGE ROUTINE                                      ---*\n*---------------------------------------------------------------------*\nPUTFB3   DS    0H\n         #IF   IOGOING,OFF,PUTFB4  IS A WRITE IN PROGRESS ??\n         CHECK PDSDECB             YES; LET IT COMPLETE\n         #SET  IOGOING,OFF         NO WRITE IN PROGRESS\nPUTFB4   DS    0H\n         #IF   BUFUSED,OFF,PUTFB5  IS CURRENT BUFFER USED ??\n         L     R2,BPBUF1           LOAD BUFFER POINTER WORD\n         L     R3,BLOCKWDS+4       LOAD BYTES-USED VALUE\n         LH    R4,DCBBLKSI         LOAD DCB BLKSIZE\n         STH   R3,DCBBLKSI         STORE UPDATED BLKSIZE\n         WRITE PDSDECB,SF,(9),(2),(3),MF=E\n         #SET  IOGOING,ON          SHOW THAT A WRITE IS IN PROGRESS\n         CHECK PDSDECB             LET IT COMPLETE\n         #SET  IOGOING,OFF         NO WRITE IN PROGRESS\n         #SET  BUFUSED,OFF         NO WRITE IN PROGRESS\n         STH   R4,DCBBLKSI         RESTORE BLKSIZE\n         XC    BLOCKWDS+4(4),BLOCKWDS+4 ZERO BYTES USED\n         ST    R2,BLOCKWDS         RESET NEXT-RECORD POINTER\nPUTFB5   DS    0H\n         B     PUTRET              RETURN TO LOCAL CALLER\n         TITLE 'BSAM/BPAM WRITE VARIABLE RECORDS '\n*---------------------------------------------------------------------*\n*---     VARIABLE, UNBLOCKED RECORDS.                              ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nPUTV     DS    0H\n         #IF   TRUNC,ON,PUTV1      JUST CLEAN UP ---\n         L     R4,BPBUF1           LOAD BUFFER POINTER\n         L     R2,IOSAVE+12        LOAD RECORD ADDRESS\n         L     R3,IOSAVE+8           AND LENGTH\n         AH    R3,=H'4'            ACCOUNT FOR RDW/BDW\n         SLL   R3,16               SHIFT FOR RDW/BDW\n         STCM  R3,15,0(R2)         STORE RDW/BDW PREFIX\n         LA    R4,4(,R4)           POINT PAST IT\n         L     R3,IOSAVE+8           AND LENGTH\n         LR    R5,R3               COPY RECORD LENGTH AGAIN\n         MVCL  R4,R2               MOVE RECORD TO BPAM BUFFER\nPUTV1    DS    0H\n         #IF   IOGOING,OFF,PUTV2   IS A WRITE IN PROGRESS ??\n         CHECK PDSDECB             YES; LET IT COMPLETE\n         #SET  IOGOING,OFF         NO WRITE IN PROGRESS\nPUTV2    DS    0H\n         #IF   TRUNC,ON,PUTRET     JUST CLEAN UP ---\n         LM    R2,R3,BPBUF1        LOAD BUFFER POINTER WORDS\n         LR    R4,R2               SWAP BUFFERS\n         STM   R3,R4,BPBUF1        ...\n         LH    R5,0(,R4)           LOAD RECORD LENGTH\n         WRITE PDSDECB,SF,(9),(4),(5),MF=E\n         #SET  IOGOING,ON          SHOW THAT A WRITE IS IN PROGRESS\n         B     PUTRET              AND GO RETURN TO LOCAL CALLER\n         TITLE 'BSAM/BPAM WRITE VARIABLE BLOCKED RECORDS '\n*---------------------------------------------------------------------*\n*---     VARIABLE, BLOCKED RECORDS.                                ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nPUTVB    DS    0H\n         #IF   TRUNC,ON,PUTVB4     JUST CLEAN UP ---\nPUTVB1   DS    0H\n         #SET  BUFUSED,ON          SHOW THE BUFFER USED\n         L     R2,IOSAVE+12        LOAD RECORD ADDRESS\n         L     R3,IOSAVE+8           AND LENGTH\n         L     R4,BPBUF1           LOAD BUFFER POINTER\n         LH    R5,0(,R4)           LOAD BYTES-USED VALUE\n         LA    R5,4(R3,R5)         ACCOUNT FOR NEW RDW\n         CH    R5,DCBBLKSI         TOO LARGE FOR THIS BLOCK ??\n         BNH   PUTVB3              NOPE ---\n         #IF   IOGOING,OFF,PUTVB2  IS A WRITE IN PROGRESS ??\n         CHECK PDSDECB             YES; LET IT COMPLETE\n         #SET  IOGOING,OFF         NO WRITE IN PROGRESS\n         #SET  BUFUSED,OFF         NO WRITE IN PROGRESS\nPUTVB2   DS    0H\n         LM    R4,R5,BPBUF1        LOAD BUFFER POINTER WORDS\n         LR    R6,R4               SWAP BUFFERS\n         MVC   0(4,R5),=X'00040000' START WITH 4 BYTES (BDW)\n         STM   R5,R6,BPBUF1        ...\n         LH    R5,0(,R4)           LOAD BYTES-USED VALUE\n         WRITE PDSDECB,SF,(9),(4),(5),MF=E\n         #SET  IOGOING,ON          SHOW THAT A WRITE IS IN PROGRESS\n         #SET  BUFUSED,OFF         TURN OFF 'BUFFER USED' FLAG\n         B     PUTVB1              AND RE-CHECK ---\nPUTVB3   DS    0H\n         #SET  BUFUSED,ON          SHOW THE BUFFER NON-EMPTY\n         L     R4,BPBUF1           LOAD POINTER TO AREA\n         LH    R5,0(,R4)           LOAD BYTES-USED VALUE\n         LA    R4,0(R5,R4)         POINT TO NEXT RECORD AREA\n         LA    R0,4(,R3)           BUILD RDW AND\n         STH   R0,0(,R4)           STORE IT\n         XC    2(2,R4),2(R4)       NO SPANNED-RECORD STUFF\n         LR    R5,R3               COPY RECORD LENGTH\n         LA    R4,4(,R4)           POINT TO DATA FIELD\n         MVCL  R4,R2               AND MOVE THE RECORD\n         L     R2,BPBUF1           LOAD POINTER TO AREA\n         AH    R0,0(,R2)           LOAD CURRENT BLK LENGTH\n         STH   R0,0(,R2)           UPDATE BDW\n         ST    R0,BLOCKWDS+4       AND BYTES-USED VALUE\n         B     PUTRET              AND EXIT\nPUTVB4   DS    0H\n*---------------------------------------------------------------------*\n*---     BUFFER PURGE ROUTINE                                      ---*\n*---------------------------------------------------------------------*\n         #IF   IOGOING,OFF,PUTVB6  IS A WRITE IN PROGRESS ??\n         CHECK PDSDECB             YES; LET IT COMPLETE\n         #SET  IOGOING,OFF         NO WRITE IN PROGRESS\nPUTVB6   DS    0H\n         #IF   BUFUSED,OFF,PUTVB7  IS CURRENT BUFFER USED ??\n         L     R2,BPBUF1           LOAD BUFFER POINTER WORD\n         LH    R3,0(,R2)           LOAD BYTES-USED VALUE\n         WRITE PDSDECB,SF,(9),(2),(3),MF=E\n         #SET  IOGOING,ON          SHOW THAT A WRITE IS IN PROGRESS\n         CHECK PDSDECB             LET IT COMPLETE\n         MVC   0(4,R2),=X'00040000' RESET BDW\n         L     R2,BPBUF2           LOAD BUFFER POINTER WORD\n         MVC   0(4,R2),=X'00040000' RESET BDW\n         #SET  BUFUSED,OFF         TURN OFF 'BUFFER USED' FLAG\n         #SET  IOGOING,OFF         TURN OFF 'WRITE-IN-PROGRESS' FLAG\nPUTVB7   DS    0H\n         B     PUTRET              RETURN TO LOCAL CALLER\n         TITLE 'BSAM/BPAM WRITE UNDEFINED RECORDS '\n*---------------------------------------------------------------------*\n*---     UNDEFINED-FORMAT RECORDS.                                 ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nPUTU     DS    0H\n         L     R2,IOSAVE+12        LOAD RECORD ADDRESS\n         L     R3,IOSAVE+8           AND LENGTH\n         #IF   TRUNC,ON,PUTU1      CLEAN UP LAST WRITE\n         NC    NOTELIST,NOTELIST   NOTELIST ALREADY FOUND ??\n         BNZ   PUTUA               YES; CONTINUE ---\n         CLI   BLDLAREA+19,0       IS A NOTE LIST PRESENT ??\n         BE    PUTUA               NOPE ---\n         CLC   0(3,R2),BLDLAREA+16 IS THIS IT ??\n         BNE   PUTUA               NOPE ---\n         LA    R4,4(,R3)           ACCOUNT FOR LENGTH WORD\n         GETMAIN R,LV=(4),SP=10    GRAB SOME STORAGE\n         ST    R1,NOTELIST         SAVE AS NOTELIST POINTER\n         ST    R4,0(,R1)           SAVE LENGTH, FOR RELEASING LATER\n         LA    R4,4(,R1)           POINT TO DATA AREA\n         LR    R5,R3               COPY ACTUAL RECORD LENGTH\n         MVCL  R4,R2               COPY THE NOTE LIST\n         B     PUTRET              END, FOR NOW\nPUTUA    DS    0H\n         LR    R5,R3               COPY RECORD LENGTH\n         L     R4,BPBUF1           LOAD BUFFER ADDRESS\n         MVCL  R4,R2               COPY RECORD TO BUFFER\n         L     R5,IOSAVE+8         RE-COPY RECORD LENGTH\nPUTU1    DS    0H\n         #IF   IOGOING,OFF,PUTU2   IS A WRITE IN PROGRESS ??\n         CHECK PDSDECB             YES; LET IT COMPLETE\n         #SET  IOGOING,OFF         NO WRITE IN PROGRESS\nPUTUF    DS    0H\n         NOTE  (9)                 SAVE ADDRESS OF LAST RECORD\n         LR    R2,R1               COPY RESULT TTR\n         L     R1,BPBUF2           RELOAD BUFFER POINTER\n         ICM   R1,14,0(R1)         INSERT OLD TTR VALUE\nPUTA     DS    0H\n         CLM   R1,14,BLDLAREA+8    MATCHING TTR ??\n         BNE   *+8                 NOPE ---\n         STCM  R2,14,BLDLAREA+8    YES; UPDATE IT ---\n         CLM   R1,14,BLDLAREA+12   MATCHING TTR ??\n         BNE   *+8                 NOPE ---\n         STCM  R2,14,BLDLAREA+12   YES; UPDATE IT ---\n         CLM   R1,14,BLDLAREA+16   MATCHING TTR ??\n         BNE   *+8                 NOPE ---\n         STCM  R2,14,BLDLAREA+16   YES; UPDATE IT ---\nPUTB     DS    0H\n*---------------------------------------------------------------------*\n*---     IF A NOTE LIST WAS PRESENT, WE MUST EXAMINE EACH ENTRY,   ---*\n*---     COMPARING THE OLD TTR OF THE RECORD WE JUST WROTE.  IF    ---*\n*---     WE HAVE A MATCH, WE REPLACE THE OLD TTR WITH THE NEW      ---*\n*---     TTR, BEING CAREFUL NOT TO ALTER THE SEGMENT NUMBER.       ---*\n*---------------------------------------------------------------------*\n         L     R6,NOTELIST         LOAD NOTELIST POINTER\n         LTR   R6,R6               ANY NOTELIST PROCESSING ??\n         BZ    PUTU2               NOPE ---\n         L     R5,0(,R6)           LOAD SAVED-NOTELIST LENGTH\n         LA    R6,8(,R6)           POINT TO FIRST TTR VALUE\n         LA    R7,0(R6,R5)         POINT TO\n         BCTR  R7,R0                 END OF LIST\n         L     R4,BPBUF2           LOAD POINT TO THE BUFFER\nPUTN1    DS    0H\n         CLC   0(3,R4),0(R6)       TTR'S MATCH ??\n         BE    PUTN2               YES ---\n         LA    R6,4(,R6)           POINT TO NEXT ENTRY\n         CR    R6,R7               FAR ENOUTH, YET ??\n         BL    PUTN1               NOPE; KEEP CHECKING\n         B     PUTU2               ALL DONE ---\nPUTN2    DS    0H\n         STCM  R2,14,0(R6)         STORE UPDATED TTR\nPUTU2    DS    0H\n         #IF   TRUNC,ON,PUTRET     ALL DONE ---\n         LM    R2,R3,BPBUF1        LOAD BUFFER POINTER WORDS\n         LR    R4,R2               SWAP BUFFERS\n         STM   R3,R4,BPBUF1        ...\n         ST    R3,BLOCKWDS         STORE AS 'NEXT-RECORD' ADDRESS\n         LA    R4,4(,R4)           POINT PAST THE TTR WORD\n         L     R5,IOSAVE+8         RELOAD ORIGINAL LENGTH\n         SH    R5,=H'4'            AND ACCOUNT FOR IT IN LENGTH\n         WRITE PDSDECB,SF,(9),(4),(5),MF=E\n         #SET  IOGOING,ON          SHOW THAT A WRITE IS IN PROGRESS\n         B     PUTRET              AND RETURN TO LOCAL CALLER\n*---------------------------------------------------------------------*\n*---     COMMON RETURN LINKAGE CODE                                ---*\n*---------------------------------------------------------------------*\nPUTRET   DS    0H\n         LM    R14,R12,IOSAVE      RESTORE CALLER'S REGISTERS\n         BR    R14                 RETURN ---\n         DROP  R9\n*---------------------------------------------------------------------*\n*---     SOME ERROR STUFF                                          ---*\n*---------------------------------------------------------------------*\nNODDERR  DS    0H\n         #ERR  MSG=1\n         #ERR  MSG=6\n         B     ENDITALL\nORGERR   DS    0H\n         #ERR  MSG=3\n         #ERR  MSG=6\n         B     ENDITALL\nERRDEV   DS    0H\n         #ERR  MSG=2\n         #ERR  MSG=6\n         B     ENDITALL\n         TITLE 'SEQUENTIAL OUTPUT SEPARATOR ROUTINES'\n*---------------------------------------------------------------------*\n*---     THIS LITTLE ROUTINE GENERATES A IEBUPDTE-TYPE ./ ADD      ---*\n*---     CARD AS A SEPARATOR BETWEEN ITEMS BEING LOADED TO A       ---*\n*---     SEQUENTIAL DATASET.  NO CHECK OF THE OUTPUT DATASET       ---*\n*---     CHARACTERISTICS IS MADE; THE USER IS ASSUMED TO KNOW      ---*\n*---     WHAT HE'S DOING!                                          ---*\n*---------------------------------------------------------------------*\nSEPUPDTE DS    0H\n         STM   R14,R12,SEPSAVE     SAVE THE INPUT REGISTERS\n         LR    R2,R1               COPY INPUT HEADER ADDRESS\n         MVI   GENWK,C' '          SEED IN A BLANK\n         MVC   GENWK+1(79),GENWK   BUILD A BLANK CARD\n         MVC   GENWK(12),=C'./ ADD NAME='\n         MVC   GENWK+12(8),1(R2)   COPY MEMBER NAME TO CARD\n         #IF   NOEXP,ON,SEP1\n         #SET  NOEXP,ON\n         LA    R1,GENWK\n         LA    R0,80\n         BAL   R14,PUT             OUTPUT THE SEPARATOR\n         #SET  NOEXP,OFF\n         B     SEP2\nSEP1     DS    0H\n         LA    R1,GENWK            LOAD RECORD ADDRESS\n         LA    R0,80               AND ELNGTH\n         BAL   R14,PUT             CALL THE 'PUTTER'\nSEP2     DS    0H\n         LM    R14,R12,SEPSAVE\n         BR    R14                 AND RETURN TO CALLER\n         EJECT\n*---------------------------------------------------------------------*\n*---     THIS ROUTINE WILL ADD THE 'REAL' NAME WE JUST LOADED TO   ---*\n*---     A CHAIN OF REAL NAMES IN STORAGE.  THE CHAIN IS 'ROOTED'  ---*\n*---     IN THE 'COUNT' FIELD OF THE ARCHIVER'S MAIN WORK AREA.    ---*\n*---     THE PURPOSE OF THIS CHAIN IS TO PREVENT LOADING THE SAME  ---*\n*---     ITEM MULTIPLE TIMES IF IT HAS MULTIPLE ALIASES AND WE'RE  ---*\n*---     LOADING BASED ON ALIAS CHECKS AS WELL AS REAL NAME        ---*\n*---     CHECKS.                                                   ---*\n*---                                                               ---*\n*---     MY USE OF CELL POOL MANAGEMENT HERE PRECLUDES USING THIS  ---*\n*---     ROUTINE IN ANY MVS/370 SYSTEM.                            ---*\n*---                                                               ---*\n*---     REGISTER 1 IS ASSUMED TO POINT TO THE 44-BYTE QUALIFIER   ---*\n*---     DATA TO BE ADDED TO THE CHAIN.                            ---*\n*---------------------------------------------------------------------*\nCHAINER  DS    0H\n         STM   R14,R12,IOSAVE      SAVE THE ENTRY REGISTERS\n         LR    R2,R1               COPY THE DATA POINTER\n         NC    NAMEPOOL,NAMEPOOL   IS CELL POOL INIT'D ??\n         BNZ   CHAIN1              YES ---\n         CNOP  0,4\n         BAL   R1,BLDPOOL          BRANCH AROUND PARM LIST\n         DC    F'100'\n         DC    F'100'\n         DC    F'48'\n         DC    AL1(16)\n         DC    AL1(20)\n         DC    CL20'REAL NAMES LOADED  '\nBLDPOOL  DS    0H\n         CALL  CELLBLD\n         ST    R0,NAMEPOOL         SAVE THE 'TOKEN' VALUE\nCHAIN1   DS    0H\n         L     R0,NAMEPOOL         LOAD THE TOKEN VALUE\n         CALL  CELLGET             GO GRAB A QUICKCELL\n         XC    0(48,R1),0(R1)      CLEAR IT OUT\n         MVC   0(4,R1),NAMECHN     INSERT INTO THE\n         ST    R1,NAMECHN            CHAIN\n         MVC   4(44,R1),0(R2)      COPY DATA INTO THE CHAIN\n         LM    R14,R12,IOSAVE      RESTORE THE REGISTERS\n         LA    R15,0               ZERO RETURN CODE\n         BR    R14                 AND RETURN TO MY CALLER\n         EJECT\n*---------------------------------------------------------------------*\n*---     THIS ROUTINE CHECKS THROUGH THE CHAIN BUILT BY 'CHAIN'    ---*\n*---     TO SEE IF WE'VE ALREADY PROCESSED THE ITEM WHOSE          ---*\n*---     QUALIFIERS ARE POINTED TO BY REGISTER 1.  IF A MATCH IS   ---*\n*---     FOUND, A RETURN CODE OF 4 IS SET IN REGISTER 15, ELSE     ---*\n*---     THE RETURN CODE IS ZERO.                                  ---*\n*---------------------------------------------------------------------*\nCHKCHN   DS    0H\n         STM   R14,R2,IOSAVE       SAVE THE ENTRY REGISTERS\n         MVC   IOSAVE+4(4),=F'4'   SET INITIAL RETURN CODE\n         L     R2,NAMECHN          LOAD THE FIRST LINK POINTER\n         B     CHKCHN2             AND GO CHECK FOR ANY LINK\nCHKCHN1  DS    0H\n         CLC   4(44,R2),0(R1)      DOES IT MATCH ??\n         BE    CHKCHN3             YES; ERROR RETURN CODE\n         L     R2,0(,R2)           POINT TO NEXT LINK\nCHKCHN2  DS    0H\n         LTR   R2,R2               ANOTHER LINK ??\n         BNZ   CHKCHN1             YES ---\n         XC    IOSAVE+4(4),IOSAVE+4  NOPE; SET ZERO RETURN CODE\nCHKCHN3  DS    0H\n         LM    R14,R2,IOSAVE       RESTORE REGISTERS\n         BR    R14                 AND RETURN TO CALLER\n         EJECT\nTCMSG    DC    CL133' '\n         ORG   TCMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202120'\n         DC    C' TOTAL LOGICAL RECORDS PROCESSED.'\n         ORG\nMCMSG    DC    CL133' '\n         ORG   MCMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202120'\n         DC    C' TOTAL MEMBERS PROCESSED.'\n         ORG\nACMSG    DC    CL133' '\n         ORG   ACMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202120'\n         DC    C' TOTAL ALIAS NAMES PROCESSED.'\n         ORG\n         LTORG\nQSDCB    DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPUNCH,RECFM=FB,             X\n               LRECL=80,EXLST=PCHEXIT\nDCBL     EQU   *-QSDCB\nPCHEXIT  DS    0F\n         DC    X'85',AL3(PCHEXIT+4)\n         USING IHADCB,R1\n         USING PCHEXIT+4,R15\n         NC    DCBBLKSI,DCBBLKSI   BLKSIZE STILL ZERO ??\n         BNZR  R14                 NOPE; RETURN TO CALLER\n         MVC   DCBBLKSI,DCBLRECL   YES; MAKE BLKSIZE = LRECL\n         BR    R14                 RETURN TO OPEN/CLOSE/EOV\n         DROP  R1,R15\nTRIGGER  DC    AL1(TRGE-TRGS)\nTRGS     DC    C' SELECTED BY ARCHIVE ALIAS.'\nTRGE     EQU   *\nALIASM   DC    AL1(ALIASE-ALIASS)\nALIASS   DC    C' IS AN ALIAS. CHECK SYSPUNCH OUTPUT FOR REAL '\n         DC    C'QUALIFIER DATA.'\nALIASE   EQU   *\nCAMLST   CAMLST SEARCH,0,0,0\nLCAMLST  EQU   *-CAMLST\nPODCB    DCB   DSORG=PO,MACRF=(R,W),DDNAME=X\nPODCBL   EQU   *-PODCB\nBSDCB    DCB   DSORG=PS,MACRF=(RP,WP),DDNAME=X\nBSDCBL   EQU   *-BSDCB\nEXTRPARM EXTRACT ,'S',FIELDS=TIOT,MF=L\nEXTL     EQU   *-EXTRPARM\n         READ  DECB,SF,0,0,0,MF=L\nDECBL    EQU   *-DECB\n         DCBD  DSORG=(PS,PO)\n         IECSDSL1 (1)\n         COPY  #RECS\n         COPY  ##ARCHWK\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHLSTT": {"ttr": 9221, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x02\\x00D\\x00\\x99'\\x0f\\x01\\x02 _\\x14\\x16\\x01\\xf2\\x01\\xf0\\x00\\x04\\xd4\\xd4\\xe2\\xd4\\xc1\\xd2@@@@\"", "ispf": {"version": "06.02", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "2002-07-24T14:16:44", "lines": 498, "newlines": 496, "modlines": 4, "user": "MMSMAK"}, "text": "LISTT    TITLE 'ARCHIVER --- LISTT FUNCTION'\n*---------------------------------------------------------------------*\n*---     ALL LISTT REQUESTS ARE ROUTED HERE FOR FURTHER            ---*\n*---     PROCESSING.  OPTIONS INCLUDE LISTING JUST THE HEADERS,    ---*\n*---     HEADERS AND NOTES, HEADERS AND DATA, OR HEADERS, NOTES    ---*\n*---     AND DATA.  ALTHOUGH A SUBTITLE IS PRESENT GIVING COLUMN   ---*\n*---     HEADINGS, THESE ARE MEANINGFUL ONLY FOR ITEM HEADER       ---*\n*---     DATA.  THE NOTE LISTING IS A BASIC LINE-FOR-LINE LISTING  ---*\n*---     OF THE NOTE DATA ORIGINALLY ADDED TO THE ITEM, WITH A     ---*\n*---     LEADING LINE NUMBER AND FLAG CHARACTER.  THE DATA         ---*\n*---     LISTING MAY TAKE ON EITHER OF TWO FORMATS.  EITHER A HEX  ---*\n*---     LIST, WITH RECORD NUMBER AND OFFSET WITHIN THE RECORD,    ---*\n*---     OR A CHARACTER LISTING, EXTENDED ACROSS MULTIPLE LINES    ---*\n*---     AS NEEDED FOR LONG RECORDS.  A FUTURE ENHANCEMENT WILL    ---*\n*---     ALLOW ANY PDS DIRECTORY INFORMATION STORED IN THE HEADER  ---*\n*---     RECORD TO BE LISTED AS PART OF THE HEADER LISTING.        ---*\n*---     (INCLUDING ALIAS DATA.)                                   ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nARCHLSTT CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n         USING ARCHLSTT,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             LOAD ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHLSTT,R11        DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             LOAD NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RELOAD BACK POINTER\n         L     R14,12(,R14)        RELOAD ORIG. REG 14\n         LA    R10,0(,R11)         COPY ORIGINAL BASE REGISTER\n         AH    R10,PASSIT-2        BUMP BY A BASE'S WORTH\n         USING ARCHLSTT+4096,R10   AND DECLARE IT\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         COPY #ARCBITS\n         XC    MCNT,MCNT           INIT. THE ITEM COUNT\n         ZAP   LSTLIN#,=P'99'      START ON A NEW PAGE\n         L     R0,=F'32768'        CMPWRK LENGTH\n         LR    R3,R0               AND COPY IT\n         ICM   R0,8,=AL1(10)       SET THE SUBPOOL NUMBER\n         GETMAIN R,LV=(0)          GRAB A EXPAND WORK AREA\n         STM   R0,R1,CMPWRKL       SAVE ADDRESS AND LENGTH\n         LR    R2,R1               COPY ITS ADDRESS\n         LA    R15,0               PAD/SOURCE LENGTH = ZERO\n         MVCL  R2,R14              CLEAR THE AREA !!\n         BAL   R14,NVSOPEN         GO OPEN THE ARCHIVER-EXPORT TAPE\n         EJECT\n*---------------------------------------------------------------------*\n*---     HERE'S THE MEAT OF THE PROCESSING. THE BASIC PROCESS IS   ---*\n*---           THIS:                                               ---*\n*---                                                               ---*\n*---     1. USING THE CONTROL INFORMATION WE WERE GIVEN AND THE    ---*\n*---        INFORMATION WE'VE DEVELOPED, LOCATE THE HEADER RECORD  ---*\n*---        FOR THE FIRST MEMBER. WE'LL USE THE VS1BUF2 AREA FOR   ---*\n*---        HEADER/KEY CONSTRUCTION.                               ---*\n*---                                                               ---*\n*---     2. LOOP THROUGH THE MEMBER, READING THE RECORDS AND       ---*\n*---        EXPLODING THEM INTO THE COMPRK AREA, WRITING EACH      ---*\n*---        'LOGICAL' RECORD AS IT BECOMES AVAILABLE.              ---*\n*---------------------------------------------------------------------*\n         MVC   TITLE3,SH10         REPORT SUBTITLE LINE\nMEMBERS  DS    0H\nNEXTHDR  DS    0H\n         L     R1,NDCBA            POINT TO THE DCB\n         GET   (1)                 READ A RECORD\n         LH    R3,0(,R1)           LOAD ITS LENGTH\n         LA    R3,0(R3,R1)         POINT TO RECORD END\n         BCTR  R3,R0               BACK UP TO LAST BYTE\n         LA    R2,4(,R1)           POINT TO RECORD START\nRCHKHDR  DS    0H\n         L     R1,CALLIST\n         CLC   0(4,R2),=C'SIZE'    IS THIS A SIZE MARKER ??\n         BNE   NOTSIZE             NOPE ---\n         MVC   LINE,DASHES\n         #PUT  LINE\n         L     R0,4(,R2)           LOAD THE SIZE VALUE\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE,MSGL           COPY MESSAGE DATA TO LINE\n         ED    LINE+38(8),DWORK+4  INSERT SIZE IN LINE\n         #PUT  LINE                OUTPUT THE MESSAGE\n         MVC   LINE,DASHES         ANOTHER LINE OF DASHES\n         #PUT  LINE\n         B     NEXTHDR             GO FOR ANOTHER RECORD\nDASHES   DC    C' '\n         DC    132C'-'\nMSGL     DC    CL133' '\n         ORG   MSGL+1\n         DC    C'NEW CLUSTER INPUT. MAXIMUM LRECL WAS '\n         DC    X'4020202020202020'\n         DC    C' BYTES.'\n         ORG\nNOTSIZE  DS    0H\n         CLI   0(R2),#RTHDR        HEADER RECORD ??\n         BNE   CHKNOTE             NOPE; POSSIBLE NOTE RECORD\n         LA    R1,1(,R2)           POINT TO THE HEADER\n         LA    R0,0                USE DEFAULT QUALIFIER DATA\n         CALL  ARCHKNAM            GO CHECK: DO WE PROCESS THIS ITEM ??\n         LTR   R15,R15             PASS THE CHECK ??\n         BNZ   NEXTHDR             NOPE ---\n         MVC   BLDLAREA(RECKLEN),0(R2) COPY TO BLDL AREA\n         LA    R1,0(,R2)           POINT TO THE HEADER RECORD\n         BAL   R9,LISTHDR          CHECK/LIST HEADER RECORD\n         B     NEXTHDR             GO GET THE NEXT RECORD\nCHKNOTE  DS    0H\n         CLI   0(R2),#RTNOTE       IS THIS A 'NOTE' RECORD ??\n         BNE   CHKDATA             NOPE; MAYBE A DATA TYPE\n         #IF   PRCCM,OFF,NEXTHDR\n         CLC   1(RECKLEN-5,R2),BLDLAREA+1 STILL THE SAME ITEM ??\n         BNE   RCHKHDR             NOPE ---\n         LA    R6,RECKLEN(,R2)     POINT TO ITEM DATA\n         LR    R8,R3               COPY END POINTER\nNOTE2    DS    0H\n         L     R4,CMPWRK           POINT TO EXPAND OUTPUT AREA\n         LA    R2,0\n         ICM   R2,3,3(R6)          LOAD EXPANDED RECORD LENGTH\n         ST    R2,CALLIST+12       SAVE NEW RECORD LENGTH\n         LA    R3,5(,R6)           POINT TO ACTUAL RECORD DATA\n         CALL  EXPAND,((4),CALLIST+12,(3)),MF=(E,CALLIST)\n         LR    R0,R2               COPY THE RECORD LENGTH\n         LR    R1,R4               AND ITS ADDRESS\n         BAL   R9,LSTCHAR          CHARACTER LIST OF RECORD\n         ICM   R2,7,0(R6)          INSERT SEGMENT LENGTH\n         LA    R6,3(R2,R6)         GO TO NEXT SEGMENT\n         CR    R6,R8               ANOTHER SEGMENT TO PROCESS ??\n         BL    NOTE2               YES ---\n         B     NEXTHDR             NOPE ---\nCHKDATA  DS    0H\n         CLI   0(R2),#RTDATA       IS THIS A 'DATA' TYPE ??\n         BNE   BADREC\n         #IF   SHITEM,OFF,NEXTHDR\n         CLC   1(RECKLEN-5,R2),BLDLAREA+1 STILL THE SAME ITEM ??\n*        BNE   RCHKHDR             NOPE ---\n         BNE   NEXTHDR             NOPE ---              *DHC*\n         LR    R8,R3               COPY LAST-BYTE-POINTER\n         LA    R6,RECKLEN(,R2)     POINT TO DATA START\nDATA2    DS    0H\n         L     R4,CMPWRK           POINT TO EXPAND OUTPUT AREA\n         LA    R2,0\n         ICM   R2,3,3(R6)          LOAD EXPANDED RECORD LENGTH\n         ST    R2,CALLIST+12       SAVE NEW RECORD LENGTH\n         LA    R3,5(,R6)           POINT TO ACTUAL RECORD DATA\n         CALL  EXPAND,((4),CALLIST+12,(3)),MF=(E,CALLIST)\n         LR    R0,R2               COPY THE RECORD LENGTH\n         LR    R1,R4               AND ITS ADDRESS\n         #IF   SHHEX,ON,DATAH\n         BAL   R9,LSTCHAR          CHARACTER LIST OF RECORD\n         B     DATAL               AND CONTINUE\nDATAH    DS    0H\n         BAL   R9,LSTHEX           HEX LIST OF RECORD(S)\nDATAL    DS    0H\n         ICM   R2,7,0(R6)          INSERT SEGMENT LENGTH\n         LA    R6,3(R2,R6)         GO TO NEXT SEGMENT\n         CR    R6,R8               ANOTHER SEGMENT TO PROCESS ??\n*        BL    DATA2               YES ---\n         BNH   DATA2               YES ---                   *DHC*\n         B     NEXTHDR             NOPE ---\nBADREC   DS    0H\n         #ERR  MSG=13\n         B     NEXTHDR\nENDITALL DS    0H\n         #ERR  MSG=11\n         L     R0,MCNT             LOAD MEMBER COUNT\n         LTR   R0,R0               ZERO COUNT ??\n         BZ    END1                YES ---\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,TCMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\nEND1     DS    0H\n         CLC   NDCBA,=F'0'         WAS DCB EVER OPENED ??\n         BE    NOACB               NOPE ---\n         BAL   R14,NVSCLOSE        CLOSE THE IMPORT TAPE\nNOACB    DS    0H\n         FREEMAIN R,SP=10          RELEASE ALL MY STORAGE\n         XC    CMPWRKL(8),CMPWRKL  FORGET THOSE VALUES, TOO\n         L     R13,4(,R13)         LOAD BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ALWAYS RC = 0\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\n         TITLE 'VSAM CLOSE AND CONTROL-BLOCK FREEMAINS'\n*---------------------------------------------------------------------*\n*---     THIS LITTLE LOCAL SUBROUTINE IS THE COUNTERPART TO THE    ---*\n*---     NVSOPEN ROUTINE. HERE, THE NONVSAM DATASET IS CLOSED      ---*\n*---     AND ALL RELATED STORAGE, WORK AREAS, ETC. ARE FREE'D.     ---*\n*---     ALL RELATED VALUES IN THE ##ARCHWK AREA ARE ALSO RESET.   ---*\n*---------------------------------------------------------------------*\nNVSCLOSE DS    0H\n         STM   R14,R12,IOSAVE      SAVE ENTRY REGISTERS\n         OI    NDCBA,X'80'         MARK AS LAST FOR CLOSE\n         CLOSE ,MF=(E,NDCBA)       CLOSE THE DATASET\n         L     R2,NDCBA            LOAD THE DCB ADDRESS\n         FREEPOOL (2)              RELEASE THE BUFFER POOL\n         XC    NDCBA,NDCBA         AND CLOBBER THAT POINTER\n         LM    R14,R12,IOSAVE      RESTORE THE REGISTERS\n         BR    R14                 RETURN TO (LOCAL) CALLER\n         TITLE 'OPEN NONVSAM INPUT DATASET '\n         SPACE 3\nNVSOPEN  DS    0H\n         STM   R14,R12,IOSAVE      SAVE THE ENTRY REGISTERS\n*---\n*---     BUILD A DCB, TO START, FOR DSORG CHECKING\n*---\n         GETMAIN R,LV=QSDCBL,SP=10 GRAB STORAGE FOR BPAM DCB\n         ST    R1,NDCBA            AND STORE ADDRESS IN ARCHIVWA\n         MVI   NDCBA,X'80'         BUILD OPEN PARM LIST\n         MVC   0(QSDCBL,R1),QSDCB  COPY DCB TO DYNAMIC AREA\n         USING IHADCB,R1           BASE THE DCB DSECT\n         MVC   DCBDDNAM,EXPTPDD    MOVE IN THE DDNAME\n         DROP  R1\n         OPEN  (,INPUT),MF=(E,NDCBA) OPEN THE DCB\n         LM    R14,R12,IOSAVE      RELOAD ENTRY REGISTERS\n         BR    R14                 AND RETURN TO LOCAL CALLER\n         SPACE 3\n         DS    0F\nE1       DC    X'85',AL3(E1+4)\n         USING IHADCB,R1\n         CLC   DCBBLKSI,=H'0'      BLKSIZE MISSING ??\n         BNER  R14                 NOPE ---\n         MVC   DCBBLKSI,=H'32000'  YES; INSERT A DEFAULT\n         BR    R14\n         DROP  R1\nQSDCB    DCB   DSORG=PS,MACRF=GL,BFTEK=A,EODAD=ENDITALL,EXLST=E1\nQSDCBL   EQU   *-QSDCB\n         TITLE 'LOCAL SUBROUTINE TO LIST A HEADER RECORD '\n*---------------------------------------------------------------------*\n*---     THIS LITTLE LOCAL SUBROUTINE FORMATS AND LISTS THE        ---*\n*---     CONTENTS OF THE HEADER RECORD, INCLUDING SUCH MUNDANE     ---*\n*---     DATA AS THE ORIGINAL RECORD FORMAT, LOGICAL RECORD        ---*\n*---     LENGTH, DATASET ORGANIZATION AND BLOCKSIZE.  ALSO THE     ---*\n*---     TIME AND DATE THE ITEM WAS ADDED TO THE ARCHIVE AND THE   ---*\n*---     ITEM'S LOGICAL RECORD COUNT.                              ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nLISTHDR  DS    0H\n         STM   R14,R12,IOSAVE      SAVE ENTRY REGISTERS\n         L     R15,MCNT            LOAD THE MEMBER COUNTER\n         LA    R15,1(,R15)         INCREMENT BY ONE\n         ST    R15,MCNT            AND SAVE UPDATED COUNT\n         LR    R6,R1               COPY THE INPUT POINTER\n         USING REC,R6              AND BASE HIS DSECT\n         MVC   @BYTEC,@RSRFLG1     SAVE VERSION NUMBER\n         MVC   TITLE3,SH10         REPORT SUBTITLE LINE\n         #FORMAT RECTT\n         LR    R2,R0               COPY NEXT-AVAILABLE-BYTE POINTER\n         LA    R2,1(,R2)           INCREMENT BY ONE\n         #IF   RSRALIAS,OFF,SH1    ALIAS RECORD ??\n         MVC   0(11,R2),=CL11' ALIAS FOR '\n         #FORMAT RECAN-1,OUT=11(R2),CLEAR=NO\n         B     SH5\nSH1      DS    0H\n         $CVDSORG 0(,2),RSRDSO\n         LA    R2,6(,R2)           INCREMENT BY ONE\n         $CVRECFM 0(,2),RSRREC\n         CLI   0(R2),C'U'          RECFM = U ??\n         LA    R2,6(,R2)\n         BE    SH4                 YES; SKIP LRECL\n         LA    R15,0               CLEAR A WORK REG\n         ICM   R15,3,RSRLRE        INSERT THE LRECL VALUE\n         CVD   R15,DWORK           DECIMALIZE IT\n         OI    DWORK+7,X'0F'       FORST LAST SIGN NUMERIC\n         MVC   0(7,R2),SH8         MOVE IN THE EDIT MASK\n         ED    0(7,R2),DWORK+5     EDIT IN THE LRECL\nSH4      DS    0H\n         LA    R15,0               RE-CLEAR R15\n         LA    R2,9(,R2)\n         ICM   R15,3,RSRBLK        INSERT THE BLKSIZE VALUE\n         CVD   R15,DWORK           DECIMALIZE IT\n         OI    DWORK+7,X'0F'       FORST LAST SIGN NUMERIC\n         MVC   0(7,R2),SH8         MOVE IN THE EDIT MASK\n         ED    0(7,R2),DWORK+5     EDIT IN THE BLKSIZE\n         LA    R2,9(,R2)\n         CLC   NUMTTR,=A(RSRT1LEN) ANY MORE IN HEADER ??\n         BE    SH5                 NO TIME/DATE FIELDS\n         CLI   RSRDATE,0           NEW FORMAT DATE ??              Y2K\n         BE    DATENEW             YES ---                         Y2K\n         MVC   2(8,R2),RSRDATE     COPY THE DATE\n         MVC   0(6,R2),2(R2)       MAKE ROOM FOR CENTURY\n         MVC   6(2,R2),=C'19'      INSERT CENTURY\n         LA    R2,11(,R2)          POINT TO CLOCK FIELD\n         MVC   0(8,R2),RSRTIME     MOVE THE CLOCK FIELD\n         B     DOCOUNT             GO FORMAT THE RECORD COUNT\nDATENEW  DS    0H                                                  Y2K\n         UNPK  2(8,R2),RSRDATE     UNPK DATE INTO LINE             Y2K\n         MVC   0(2,R2),2(R2)       MAKE ROOM                       Y2K\n         MVC   3(2,R2),4(R2)         FOR SLASHES                   Y2K\n         MVI   2(R2),C'/'                                          Y2K\n         MVI   5(R2),C'/'                                          Y2K\n         LA    R2,11(,R2)          POINT TO TIME FIELD             Y2K\n         UNPK  2(6,R2),RSRTIME     UNPACK TIME INTO THE FIELD      Y2K\n         MVC   0(2,R2),2(R2)       MAKE ROOM                       Y2K\n         MVC   3(2,R2),4(R2)          FOR COLONS                   Y2K\n         MVI   2(R2),C':'                                          Y2K\n         MVI   5(R2),C':'                                          Y2K\nDOCOUNT  DS    0H\n         CLC   NUMTTR,=A(RSRT2LEN) ANY MORE IN HEADER ??\n         BE    SH5                 NO TIME/DATE FIELDS\n         LA    R2,9(,R2)           POINT TO COUNT FIELD\n         ICM   R0,15,RSRRCNT       INSERT THE RECORD COUNT\n         CVD   R0,DWORK            AND DECIMALIZE IT\n         OI    DWORK+7,X'0F'       FORCE LAST SIGN NUMERIC\n         MVC   1(12,R2),SH11       MOVE IN THE EDIT MASK\n         ED    1(12,R2),DWORK+3    EDIT IN THE COUNT\nSH5      DS    0H\n         #PUT  LINE                PRINT IT OUT\n         MVI   LINE,C' '           SEED IN A BLANK\n         MVC   LINE+1(120),LINE    AND PROPOGATE ---\n         LM    R14,R12,IOSAVE      RESTORE ENTRY REGISTERS\n         BR    R9                  AND RETURN TO LOCAL CALLER\n         DROP  R6\nSH10     DC    CL2'  '\n         DC    CL10'  MEMBER  '                                    HEAD\n         DC    CL1'-'\n         DC    CL10'  GROUP  '                                     HEAD\n         DC    CL1'-'\n         DC    CL10'  SUBGRP '                                     HEAD\n         DC    CL1'-'\n         DC    CL10'  TYPE  '                                      HEAD\n         DC    CL1'-'\n         DC    CL12'   VERSION '                                   HEAD\n         DC    CL2' '\n         DC    CL3'DS'                                             HEAD\n         DC    CL3'    '\n         DC    CL5'RFM  '                                          HEAD\n         DC    CL3'   '\n         DC    CL5'LRECL'                                          HEAD\n         DC    CL3' '\n         DC    CL5' BLKL'                                          HEAD\n         DC    CL5'   '\n         DC    CL4'DATE'                                           HEAD\n         DC    CL5' '\n         DC    CL6'  TIME'                                         HEAD\n         DC    CL5' '\n         DC    CL12'    RECORDS '                                  HEAD\n         DC    CL10' '\nSH11     DC    C' ',X'202020',C',',X'202020',C',',X'202020'\nTCMSG    DC    CL133' '\n         ORG   TCMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    C' TOTAL ITEMS LISTED. '\n         ORG\nSH8      DC    C' ',X'2020',C',',X'202020'\n         TITLE 'LOCAL SUBROUTINE TO LIST A CHARACTER-FORMAT RECORD'\n*---------------------------------------------------------------------*\n*---     THIS ROUTINE LISTS A RECORD IN CHARACTER FORMAT.  ANY     ---*\n*---     LENGTH RECORD, FROM ANY TYPE OF ITEM, MAY BE LISTED.      ---*\n*---     (USEFULNESS OF THAT LISTING IS PROBLEMATICAL.  PRINTED    ---*\n*---     LOAD MODULES ANYONE ??)  THOSE RECORDS THAT COULD SPAN    ---*\n*---     MULTIPLE LINES ARE BROKEN INTO SEGMENTS AND PRINTED AS    ---*\n*---     MULTIPLE LINES.  THE RECORD START IS ALWAYS ON THE LINE   ---*\n*---     THAT HAS THE LINE NUMBER PREFIXING THE DATA FIELD.  THE   ---*\n*---     USER IS CAUTIONED THAT CONTROL INFORMATION FOR RECORDS    ---*\n*---     THAT WERE ORIGINALLY VARIABLE LENGTH IS NOT PRESENT,      ---*\n*---     SINCE THE ARCHIVER MAINTAINS ALL THAT SORT OF CONTROL IN  ---*\n*---     A SOMEWHAT DIFFERENT FASHION.                             ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nLSTCHAR  DS    0H\n         STM   R14,R12,IOSAVE      SAVE ENTRY REGISTERS\n         LR    R3,R1               COPY RECORD ADDRESS\n         LR    R5,R0               AND LENGTH\n         MVC   LINE+1(13),R#MSK    COPY THE EDIT MASK TO THE LINE\n         AR    R5,R3               POINT PAST RECORD END\nLC1      DS    0H\n         LR    R4,R5               COPY RECORD END ADDRESS\n         SR    R4,R3               MINUS CURRENT POSITION\n         CH    R4,=H'100'          LONGER THAN A LINE SEGMENT ??\n         BNH   *+8                 NOPE ---\n         LA    R4,100              YES; USE ONE SEGMENT\n         BCTR  R4,R0               DECREMENT BY ONE\n         EX    R4,MOVELIN          COPY TO LINE AREA\n         #PUT  LINE                OUTPUT THE DATA LINE\n         MVI   LINE,C' '           SEED IN A BLANK\n         MVC   LINE+1(120),LINE    CLEAR THE LINE AREA\n         LA    R3,1(R4,R3)         POINT TO NEXT PIECE\n         CR    R3,R5               STILL GOING ??\n         BL    LC1                 AND CONTINUE ---\n         LM    R14,R12,IOSAVE      RESTORE REGISTERS\n         BR    R9                  AND RETURN TO CALLER\nR#MSK    DC    CL8' '\n         DC    C' --> '\nMOVELIN  MVC   LINE+15(*-*),0(R3)  'EX'ED COPY OF DATA\n         TITLE 'LOCAL SUBROUTINE TO LIST A HEXADECIMAL-FORMAT RECORD'\n*---------------------------------------------------------------------*\n*---     THIS ROUTINE LISTS A RECORD IN CHARACTER FORMAT.  ANY     ---*\n*---     LENGTH RECORD, FROM ANY TYPE OF ITEM, MAY BE LISTED.      ---*\n*---     AGAIN, THE USEFULNESS IS LIMITED ONLY TO THE INGENUITY    ---*\n*---     OF THE USER.  THE RECORD NUMBER APPEARS ON THE FIRST      ---*\n*---     LINE OF MULTI-LINE RECORDS.  ONE ADDITIONAL FEATURE: THE  ---*\n*---     FIRST HEXADECIMAL FIELD IS THE OFFSET OF THIS SEGMENT     ---*\n*---     FROM THE BEGINNING OF THE RECORD.                         ---*\n*---                                                               ---*\n*---     THE USER IS CAUTIONED THAT CONTROL INFORMATION FOR        ---*\n*---     RECORDS THAT WERE ORIGINALLY VARIABLE LENGTH IS NOT       ---*\n*---     PRESENT, SINCE THE ARCHIVER MAINTAINS ALL THAT SORT OF    ---*\n*---     CONTROL IN A SOMEWHAT DIFFERENT FASHION.                  ---*\n*---                                                               ---*\n*---     THE METHOD OF USING MULTIPLE TRANSLATE INSTRUCTIONS TO    ---*\n*---     FORMAT THE RECORD WAS CHOSEN OVER THE 'UNPACK AND         ---*\n*---     TRANSLATE' METHOD FOR SPEED, PURE AND SIMPLE.  I          ---*\n*---     STRONGLY SUGGEST YOU LEARN IT WELL BEFORE YOU TRY TO      ---*\n*---     MAKE ANY CHANGES.  IT TAKES A LITTLE ACCLIMATING.         ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nLSTHEX   DS    0H\n         STM   R14,R12,IOSAVE      SAVE ENTRY REGISTERS\n         LR    R3,R1               COPY RECORD ADDRESS\n         LR    R5,R0               AND LENGTH\n         LA    R7,0                RESET OFFSET COUNTER\n         MVC   LINE+1(8),RNUM      COPY THE EDIT MASK TO THE LINE\n         AR    R5,R3               POINT PAST RECORD END\nLH1      DS    0H\n         MVI   GENWK,X'40'         STARTING VALUE\n         MVC   GENWK+1(68),GENWK   AND PROPOGATE IT\n         LR    R4,R5               COPY RECORD END ADDRESS\n         SR    R4,R3               MINUS CURRENT POSITION\n         CH    R4,=H'32'           LONGER THAN A LINE SEGMENT ??\n         BNH   *+8                 NOPE ---\n         LA    R4,32               YES; USE ONE SEGMENT\n         STH   R7,GENWK            SAVE THE OFFSET\n         BCTR  R4,R0               DECREMENT COUNT BY ONE\n         EX    R4,COPY1            CREATE THE FIRST COPY\n         MVC   GENWK+34(34),GENWK  AND THE SECOND COPY\n         LA    R4,2(,R4)           RESET THAT LENGTH\n         EX    R4,TR1              TRANSLATE THE FIRST HALF\n         EX    R4,TR2              AND THE SECOND HALF\n         MVC   LINE+14(78),PRMSK   MOVE TABLE TO OUTPUT LINE\n         TR    LINE+14(78),GENWK   TRANSLATE DATA INTO THE LINE\n         BCTR  R4,R0               DECREMENT COUNT BY ONE\n         #PUT  LINE                OUTPUT THE DATA LINE\n         MVI   LINE,C' '           SEED IN A BLANK\n         MVC   LINE+1(120),LINE    CLEAR THE LINE AREA\n         LA    R7,0(R4,R7)         INCREMENT THE OFFSET COUNTER\n         LA    R3,0(R4,R3)         POINT TO NEXT PIECE\n         CR    R3,R5               STILL GOING ??\n         BL    LH1                 AND CONTINUE ---\n         LM    R14,R12,IOSAVE      RESTORE REGISTERS\n         BR    R9                  AND RETURN TO CALLER\nRNUM     DC    CL8' '\nMOVEHEX  MVC   LINE+93(*-*),0(R3)  'EX'ED COPY OF DATA\nTRHEX    TR    LINE+93(*-*),VISABLE\nVISABLE  DC    16CL16'................'\n         ORG   VISABLE+C'A'\n         DC    C'ABCDEFGHI'\n         ORG   VISABLE+C'J'\n         DC    C'JKLMNOPQR'\n         ORG   VISABLE+C'S'\n         DC    C'STUVWXYZ'\n         ORG   VISABLE+C'0'\n         DC    C'0123456789'\n         ORG\nCOPY1    MVC   GENWK+2(*-*),0(R3)  COPY TO GENWK AREA\nTR1      TR    GENWK(*-*),ZONES\nTR2      TR    GENWK+34(*-*),DIGITS\nZONES    DC    16C'0',16C'1',16C'2',16C'3'\n         DC    16C'4',16C'5',16C'6',16C'7'\n         DC    16C'8',16C'9',16C'A',16C'B'\n         DC    16C'C',16C'D',16C'E',16C'F'\nDIGITS   DC    16C'0123456789ABCDEF'\nPRMSK    DC    AL1(0,34,1,35,68)\n         DC    AL1(2,36,3,37,4,38,5,39,68)\n         DC    AL1(6,40,7,41,8,42,9,43,68)\n         DC    AL1(10,44,11,45,12,46,13,47,68)\n         DC    AL1(14,48,15,49,16,50,17,51,68,68)\n         DC    AL1(18,52,19,53,20,54,21,55,68)\n         DC    AL1(22,56,23,57,24,58,25,59,68)\n         DC    AL1(26,60,27,61,28,62,29,63,68)\n         DC    AL1(30,64,31,65,32,66,33,67,68)\n         LTORG\nMINREC   DC    A(RECSIZE)\n         COPY  #RECS\n         COPY  ##ARCHWK\n         DCBD  DSORG=QS\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHMAIN": {"ttr": 9476, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06\\r\\x00\\x00\\x01 !O\\x01 !O\\x10T\\x01Y\\x01Y\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@'", "ispf": {"version": "06.13", "flags": 0, "createdate": "2020-08-01T00:00:00", "modifydate": "2020-08-01T10:54:00", "lines": 345, "newlines": 345, "modlines": 0, "user": "ARCHIVR"}, "text": "MAIN     TITLE 'ARCHIVER V6.R1 MAIN CONTROL '\n*---------------------------------------------------------------------*\n*---                                                               ---*\n*---     PROCESS RETURN CODE ON EXIT OF ARCHMAIN                @RP2008\n*---------------------------------------------------------------------*\nARCHMAIN CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n         USING ARCHMAIN,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             LOAD ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHMAIN,R11        DEFINE THE NEW BASE REGISTER\nSAVE#    LA    R3,12               LOAD NUMBER OF SAVE AREAS\n         MH    R3,=H'72'           TIMES SIZE\n         GETMAIN R,LV=(3)          GET SOME SAVE AREAS\n         LR    R2,R1               COPY ITS ADDRESS\n         LA    R14,0               CLEAR SOURCE ADDRESS\n         LA    R15,0               AND LENGTH/PAD\n         MVCL  R2,R14              AND CLEAR THE AREA\n         ST    R1,8(,R13)          STORE FORWARD AND\n         ST    R13,4(,R1)            BACKWARD POINTERS\n         LR    R13,R1              BUMP DOWN THE SAVE AREA CHAIN\n         L     R14,4(,R13)         RELOAD BACK POINTER\n         L     R14,12(,R14)        RELOAD ORIG. REG 14\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         COPY  #ARCBITS\n         LOAD  EP=ARCHINIT         GO INIT. THE WORK AREA\n         LR    R15,R0              COPY ITS ADDRESS\n         BALR  R14,R15             CALL IT\n         LR    R12,R15             COPY ADDRESS TO MY REGISTER\n         DELETE EP=ARCHINIT        ALL DONE WITH THAT ROUTINE\n         USING MAINWK,R12          AND BASE WORK AREA DSECT\n         L     R0,=V(PRTSEP1)      LOAD SPECIAL PRINT EPA\n         ST    R0,PRTRTN           AND SAVE FOR ARCHPARS\n         LOAD  EP=ARCHPARS         LOAD CONTROL STATEMENT PARSER\n         ST    R0,PARSADDR         SAVE ADDRESS IN WORK AREA\nMAIN2    DS    0H\n         L     R15,PARSADDR        POINT TO PARSE ROUTINE\n         BALR  R14,R15             AND CALL IT ---\n         XC    TCOUNT,TCOUNT    CLEAR TOTAL-RECORD COUNT\n         XC    MCNT,MCNT        CLEAR MEMBER COUNT\n         XC    ACNT,ACNT        CLEAR ALIAS COUNT\n         #IF   EODIN,ON,MAIN11\n         C     R15,=F'4'           EODAD ON SYSIN FILE ??\n         LA    R3,FUNTAB           POINT TO FUNCTION TABLE\n         LA    R4,FUNLEN           LOAD TABLE ENTRY LENGTH\n         LA    R5,LASTFUN          POINT TO LAST FUNCTION\nMAIN2A   DS    0H\n         CLC   VERB,0(R3)          IS THIS THE FUNCTION ??\n         BNE   MAIN2B              NOPE ---\n         ICM   R14,15,12(R3)       POINT TO DEFAULT SETTER\n         BZ    MAIN2X              NOT INSTALLED YET ---\n         BALR  R9,R14              GO SET THE DEFAULTS\nMAIN2X   DS    0H\n         ICM   R15,15,16(R3)       INSERT ROUTINE ADDRESS, IF ANY\n         BZ    MAIN2F              NOT INSTALLED YET ---\n         BALR  R14,R15             CALL THE ROUTINE\n         FREEMAIN R,SP=10          RELEASE STORAGE SCRAPS\n         B     MAIN2               GO FOR ANOTHER CONTROL STMT\nMAIN2B   DS    0H\n         BXLE  R3,R4,MAIN2A        LOOP, TESTINGLY\n         #PUT  MAIN14              OUTPUT AN ERROR MESSAGE\n         OI    WKRC,8              AND SET RETURN CODE          @RP2008\n         B     MAIN2               AND GO FOR ANOTHER CTL STATEMENT\nMAIN2F   DS    0H\n         #PUT  MAIN14A            OUTPUT AN ERROR MESSAGE\n         OI    WKRC,8              AND SET RETURN CODE          @RP2008\n         B     MAIN2               AND GO FOR ANOTHER CTL STATEMENT\nMAIN11   DS    0H\n         L     R2,CTLIN            POINT TO SYSIN DCB\n         LTR   R2,R2               IS IT THERE ??\n         BZ    MAIN12              NOPE ---\n         TM    48(R2),X'10'        IS IT OPEN ??\n         BZ    MAIN12              NOPE ---\n         CLOSE MF=(E,CTLIN)        YES; CLOSE IT\n         FREEPOOL (2)              RELEASE ITS BUFFER POOL\n         SH    R2,=H'4'            BACK UP A WORD\n         L     R0,0(,R2)           LOAD AREA LENGTH\n         FREEMAIN R,LV=(0),A=(2)   RELEASE THE STORAGE\n         XC    CTLIN,CTLIN         AND CLEAR THE POINTER\nMAIN12   DS    0H\n         L     R2,PRTDCB           LOAD PRINT DCB ADDRESS\n         LTR   R2,R2               IS IT THERE ??\n         BZ    MAIN12A             NOPE ---\n         TM    48(R2),X'10'        IS IT OPEN ??\n         BZ    MAIN13              NOPE ---\n         CLOSE MF=(E,PRTDCB)       YES; CLOSE IT\n         FREEPOOL (2)              RELEASE ITS BUFFER POOL\n         SH    R2,=H'4'            BACK UP A WORD\n         L     R0,0(,R2)           LOAD AREA LENGTH\n         FREEMAIN R,LV=(0),A=(2)   RELEASE THE STORAGE\n         XC    PRTDCB,PRTDCB       AND CLEAR THE POINTER\nMAIN12A  DS    0H\n         L     R2,SYSPUNCH         LOAD PUNCH DCB ADDRESS\n         LTR   R2,R2               IS IT THERE ??\n         BZ    MAIN13              NOPE ---\n         TM    48(R2),X'10'        IS IT OPEN ??\n         BZ    MAIN13              NOPE ---\n         CLOSE MF=(E,SYSPUNCH)     YES; CLOSE IT\n         FREEPOOL (2)              RELEASE ITS BUFFER POOL\n         SH    R2,=H'4'            BACK UP A WORD\n         L     R0,0(,R2)           LOAD AREA LENGTH\n         FREEMAIN R,LV=(0),A=(2)   RELEASE THE STORAGE\n         XC    SYSPUNCH,SYSPUNCH   AND CLEAR THE POINTER\nMAIN13   DS    0H\n         XR    R2,R2               CLEAR REGISTER               @RP2008\n         IC    R2,WKRC             RETURN CODE                  @RP2008\n         L     R0,MAINSIZE         LOAD WORK AREA SIZE\n         LR    R1,R12              COPY ITS ADDRESS\n         FREEMAIN R,LV=(0),A=(1)   RELEASE THE STORAGE\n         L     R13,4(,R13)         LOAD BACK S.A. POINTER\n         L     R1,8(,R13)          LOAD STAK POINTER\n         L     R0,MAIN15           AND SIZE\n         FREEMAIN R,LV=(0),A=(1)\n         DELETE EP=ARCHPARS        DELETE CSTMNT PARSER       @RP200701\n         LR    R15,R2              RETURN CODE                  @RP2008\n         RETURN (14,12),T,RC=(15)  RETURN                       @RP2008\n*---------------------------------------------------------------------*\n*---     THE FOLLOWING VCON SERVES ONLY ONE PURPOSE: FORCE THE     ---*\n*---     LINKAGE EDITOR TO INCLUDE THE CELLMAN ROUTINE, SO THAT    ---*\n*---     ENTRY POINTS WITHIN CELLMAN CAN BE RESOLVED WITHOUT A     ---*\n*---     LOT OF GAME-PLAYING WITH ALIASES.                         ---*\n*---------------------------------------------------------------------*\n         DC    V(CELLMAN)\nMAIN14   DC    CL133' ARCHMAIN --- UNKNOWN FUNCTION REQUEST. IGNORED.'\nMAIN14A  DC    CL133' ARCHMAIN --- UNINSTALLED FUNCTION. IGNORED.'\nMAIN15   DC    A(72*12)             SAVE AREA STACK SIZE\nDEFCONV  DS    0H\n         #SETDEF   BIT=REPL,KWG=GREPL,DFLT=OFF\n         #SETDEF   BIT=RETA,KWG=GRETA,DFLT=ON\n         BR    R9\nDEFCOPY  DS    0H\n         #SETDEF   BIT=RETA,KWG=GRETA,DFLT=ON\n         #SETDEF   BIT=REPL,KWG=GREPL,DFLT=OFF\n         BR    R9\nDEFDELE  DS    0H\n         #SETDEF   BIT=RETA,KWG=GRETA,DFLT=OFF\n         #SETDEF   BIT=SHITEM,KWG=GSHITEM,DFLT=OFF\n         #SETDEF   BIT=PRCB,KWG=GPRCB,DFLT=OFF\n         #SETDEF   BIT=PRCCM,KWG=GPRCCM,DFLT=OFF\n         BR    R9\nDEFEXPR  DS    0H\n         #SETDEF   BIT=PRCB,KWG=GPRCB,DFLT=ON\n         #SETDEF   BIT=RETA,KWG=GRETA,DFLT=ON\n         BR    R9\nDEFIMPR  DS    0H\n         #SETDEF   BIT=REPL,KWG=GREPL,DFLT=OFF\n         #SETDEF   BIT=RETA,KWG=GRETA,DFLT=ON\n         BR    R9\nDEFLIST  DS    0H\n         #SETDEF   BIT=SHHDR,KWG=GSHHDR,DFLT=ON\n         #SETDEF   BIT=SHHEX,KWG=GSHHEX,DFLT=OFF\n         #SETDEF   BIT=SHITEM,KWG=GSHITEM,DFLT=OFF\n         #SETDEF   BIT=PRCCM,KWG=GPRCCM,DFLT=OFF\n         #SETDEF   BIT=RETA,KWG=GRETA,DFLT=ON\n         BR    R9\nDEFLSTT  DS    0H\n         #SETDEF   BIT=SHHDR,KWG=GSHHDR,DFLT=ON\n         #SETDEF   BIT=SHHEX,KWG=GSHHEX,DFLT=OFF\n         #SETDEF   BIT=SHITEM,KWG=GSHITEM,DFLT=OFF\n         #SETDEF   BIT=PRCCM,KWG=GPRCCM,DFLT=OFF\n         #SETDEF   BIT=RETA,KWG=GRETA,DFLT=ON\n         BR    R9\nDEFLOAD  DS    0H\n         #SETDEF   BIT=REPL,KWG=GREPL,DFLT=OFF\n         #SETDEF   BIT=RETA,KWG=GRETA,DFLT=ON\n         #SETDEF   BIT=ULMODS,KWG=GULMODS,DFLT=ON\n         BR    R9\nDEFRSPC  DS    0H\n         #SETDEF   BIT=REPL,KWG=GREPL,DFLT=OFF\n         #SETDEF   BIT=RETA,KWG=GRETA,DFLT=ON\n         BR    R9\nDEFUNLD  DS    0H\n         #SETDEF   BIT=REPL,KWG=GREPL,DFLT=OFF\n         #SETDEF   BIT=RETA,KWG=GRETA,DFLT=ON\n         #SETDEF   BIT=ULMODS,KWG=GULMODS,DFLT=ON\n         BR    R9\n*---------------------------------------------------------------------*\n*---     THE FOLLOWING TABLES, DOWN TO THE LTORG STATEMENT, ARE    ---*\n*---     ORDER DEPENDANT AND MUST NOT BE CHANGED.  THE FIRST       ---*\n*---     TABLE CONTAINS THE AVAILABLE FUNCTION CODES, AS THEY      ---*\n*---     APPEAR ON THE CONTROL STATEMENTS FOR THE ARCHIVER. THE    ---*\n*---     SECOND TABLE CONSISTS OF THE EXTERNAL ADDRESSES FOR THE   ---*\n*---     CORRESPONDING PROCESSING ROUTINES, IN THE SAME ORDER.     ---*\n*---     THE THIRD TABLE POINTS TO THE LOCAL SUBROUTINE THAT WILL  ---*\n*---     RESET ALL THE FLAG BIT SETTINGS TO THEIR DEFAULTS IF      ---*\n*---     SPECIFIC KEYWORDS WERE NOT SPECIFIED.                     ---*\n*---                                                               ---*\n*---     NOTE THAT WXTRN'S ARE USED TO REFER TO THOSE FUNCTIONS    ---*\n*---     THAT ARE NOT FULLY IMPLEMENTED.                           ---*\n*---------------------------------------------------------------------*\nFUNTAB   DS    0F\n         DC    CL12'ADDALIAS  ',A(0),V(ARCHALIS)\nFUNLEN   EQU   *-FUNTAB\n         DC    CL12'ADDNOTE   ',A(0),V(ARCHNOTE)\n         DC    CL12'ALTALIAS  ',A(0),V(ARCHALIS)\n         DC    CL12'ALTER     ',A(DEFRSPC),V(ARCHRSPC)\n         DC    CL12'CLEAN     ',A(0),V(ARCHALIS)\n         DC    CL12'COMPARE   ',A(0),V(ARCHCOMP)\n         DC    CL12'CONVERT   ',A(DEFCONV),V(ARCHCONV)\n         DC    CL12'COPY      ',A(DEFCOPY),V(ARCHCOPY)\n         DC    CL12'DELALIAS  ',A(0),V(ARCHALIS)\n         DC    CL12'DELETE    ',A(DEFDELE),V(ARCHDEL)\n         DC    CL12'EXPORT    ',A(DEFEXPR),V(ARCHEXPR)\n         DC    CL12'IMPORT    ',A(DEFIMPR),V(ARCHIMPR)\n         DC    CL12'LFILE     ',A(0),V(ARCHLFVS)\n         DC    CL12'LFILET    ',A(0),V(ARCHLFTP)\n         DC    CL12'LIST      ',A(DEFLIST),V(ARCHLIST)\n         DC    CL12'LISTT     ',A(DEFLSTT),V(ARCHLSTT)\n         DC    CL12'LOAD      ',A(DEFLOAD),V(ARCHLOAD)\n         DC    CL12'LOADT     ',A(DEFLOAD),V(ARCHLDT)\n         DC    CL12'RESPECIFY ',A(DEFRSPC),V(ARCHRSPC)\nLASTFUN  EQU   *\n         DC    CL12'UNLOAD    ',A(DEFUNLD),V(ARCHUNLD)\n         LTORG\n         DROP  R11,R12\n         TITLE 'ARCHPRNT --- ARCHIVER FUNCTION SUPPORT SUBROUTINE'\n*---------------------------------------------------------------------*\n*---     FUNCTION: PERFORM ALL PRINTING OPERATIONS FOR THE         ---*\n*---           ARCHIVER. PAGES ARE 60 LINES LONG, WITH TITLES      ---*\n*---           AND TIME & DATE OF ARCHIVER RUN.                    ---*\n*---                                                               ---*\n*---     THIS ROUTINE IS INVOKED EXCLUSIVELY VIA THE #PUT MACRO.   ---*\n*---                                                               ---*\n*---     ONE SPECIAL NOTE: THE SECOND ENTRY POINT, PRTSEP1,        ---*\n*---     REQUIRES THAT R13 POINT TO AN AREA OF 36 WORDS OF         ---*\n*---     STORAGE.  THIS TO MAINTAIN THE SAVE-AREA STACKING         ---*\n*---     MECHANISM SET UP BY ARCHMAIN, EVEN THOUGH PRTSEP1         ---*\n*---     IS ACTUALLY INVOKED BY ARCHPARS.                          ---*\n*---------------------------------------------------------------------*\n         EJECT\nARCHPRNT CSECT\n         USING ARCHPRNT,R15\n         B     12(,R15)            BRANCH AROUND CSECT ID\n         DC    AL1(7),CL7'ARCHPRT'\n         STM   R14,R12,12(R13)     SAVE ENTRY REGISTERS\n         LA    R14,72(,R13)        BUMP DOWN SAVE AREA STACK\n         ST    R14,8(,R13)         FORWARD POINTER\n         ST    R13,4(,R14)         BACK POINTER\n         LR    R13,R14             ADD TO CHAIN\n         B     PRT1\n         DROP  R15\nPRTSEP1  DS    0H\n         ENTRY PRTSEP1\n         B     12(,R15)\n         DC    AL1(7),CL7'PRTSEP1'\n         STM   R14,R12,12(R13)     SAVE ENTRY REGISTERS\n         LA    R14,72(,R13)        BUMP DOWN SAVE AREA STACK\n         ST    R14,8(,R13)         FORWARD POINTER\n         ST    R13,4(,R14)         BACK POINTER\n         LR    R13,R14             ADD TO CHAIN\n         LR    R12,R0               COPY MAINWK POINTER FROM R0\nPRT1     DS    0H\n         BALR  R11,R0              LOAD NEW BASE REGISTER\n         USING *,R11               AND DEFINE MY BASE REGISTER\n         USING MAINWK,R12          AND BASE MY WORK AREA\n         MVC   LINE,0(R1)          COPY THE LINE\n         CLI   LINE,C'1'           NEW-PAGE REQUEST ??\n         BE    PRT6                YES ---\n         CLI   LINE,C'+'           NO-SKIP CNTL ??\n         BE    PRT5                YES ---\n         CLI   LINE,C'-'           TRIPLE SPACE ??\n         BE    PRT2                YES ---\n         CLI   LINE,C'0'           DOUBLE SPACE ??\n         BE    PRT3                YES ---\n         CLI   LINE,C' '           SINGLE SPACE ??\n         BE    PRT4                YES\n         MVI   LINE,C' '           INVALID; BLANK IT OUT\n         B     PRT4                AND ASSUME SINGLE SPACE\nPRT2     DS    0H\n         AP    LSTLIN#,=P'1'\nPRT3     DS    0H\n         AP    LSTLIN#,=P'1'\nPRT4     DS    0H\n         AP    LSTLIN#,=P'1'\nPRT5     DS    0H\n         CP    LSTLIN#,LINECNT     OFF THE END OF THE PAGE ??\n         BL    PRT8                NOPE ---\nPRT6     DS    0H\n         ZAP   LSTLIN#,=P'4'       SET NEW LINECNT\n         AP    PAGENO,=P'1'        INCREMENT THE PAGE COUNT\n         MVC   TITLE1(133),=CL133'1     ARCHIVER V6.1.3-- PDS/VSAM ARCHX\n               IVE MANAGEMENT SYSTEM '\n         UNPK  TITLE1+74(6),TIME\n         MVC   TITLE1+72(2),TITLE1+74\n         MVC   TITLE1+75(2),TITLE1+76\n         MVI   TITLE1+74,C':'\n         MVI   TITLE1+77,C':'\n         UNPK  TITLE1+62(8),DATE\n         MVC   TITLE1+60(2),TITLE1+62\n         MVC   TITLE1+63(2),TITLE1+64\n         MVI   TITLE1+62,C'/'\n         MVI   TITLE1+65,C'/'\n         MVC   TITLE1+84(5),=C'PAGE '\n         MVC   TITLE1+90(7),=X'20202020202020'\n         ED    TITLE1+89(8),PAGENO\n         L     R2,PRTDCB           LOAD OUTPUT DCB ADDRESS\n         PUT   (2),TITLE1          AND PUT OUT THE PAGE-SKIP\n         PUT   (2),PRT11           AND COPYRIGHT NOTICE\n         PUT   (2),PRT10\n         CLC   TITLE3,PRT10        WAS TITLE3 SUPPLIED ??\n         BE    PRT7                NOPE ---\n         PUT   (2),TITLE3          YES; LIST IT OUT\n         PUT   (2),PRT10\n         AP    LSTLIN#,=P'2'       ACCOUNT FOR SUBTITLES\n         MVI   LINE,C' '\nPRT7     DS    0H\n         PUT   (2),LINE\n         B     PRT9                AND RETURN\nPRT8     DS    0H\n         L     R2,PRTDCB           LOAD LISTING DCB ADDRESS\n         PUT   (2),LINE            OUTPUT THE LINE\nPRT9     DS    0H\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         L     R13,4(,R13)\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         MVI   12(R13),X'FF'       SET 'UNUSED' FLAG\n         LA    R15,0               SET THE RETURN CODE\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\n         EJECT\nPRT10    DC    CL133' '\nPRT11    DC    CL133'      (C) 1999, RICHARD A. FOCHTMAN JR., WOODRIDGEX\n               , ILLINOIS'\n         LTORG\n         DROP  R11,R12\n         COPY  ##ARCHWK\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHMSGS": {"ttr": 9482, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06\\x0c\\x00\\x00\\x01 !?\\x01 !?\\x15\\x00\\x006\\x006\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@'", "ispf": {"version": "06.12", "flags": 0, "createdate": "2020-07-31T00:00:00", "modifydate": "2020-07-31T15:00:00", "lines": 54, "newlines": 54, "modlines": 0, "user": "ARCHIVR"}, "text": "MSGS     TITLE 'THIS IS THE ERROR MESSAGE LIST REFERED TO BY #ERR'\n*---------------------------------------------------------------------*\n*--- EACH MESSAGE CONTAINS A 133 BYTES TEXT + 1 BYTE RETURN CODE   ---*\n*--- THE RETURN CODE WILL BE 'OR-ED' OVER WKRC                     ---*\n*---------------------------------------------------------------@RP2008\nARCHMSGS CSECT\nERR1     DC    CL133'0** ERROR *** THE DD STATEMENT FOR THE REQUIRED NOX\n               N-VSAM DATASET IS MISSING.'\n         DC    AL1(0)                                           @RP2008\nERR2     DC    CL133'0** ERROR *** THE NON-VSAM DATASET MUST BE ON A TAX\n               PE OR DASD DEVICE.'\n         DC    AL1(12)                                          @RP2008\nERR3     DC    CL133'0** ERROR *** THE NON-VSAM DATASET SPECIFIED IS NOX\n               T SEQUENTIAL OR PARTITIONED.'\n         DC    AL1(12)                                          @RP2008\nERR4     DC    CL133'0*** ERROR *** THE VSAM CLUSTER KEY LENGTH IS INVAX\n               LID.  IS THIS THE CORRECT VSAM CLUSTER?'\n         DC    AL1(12)                                          @RP2008\nERR5     DC    CL133'0*** ERROR *** THE VSAM CLUSTER RECORD LENGTH IS TX\n               OO SMALL. IT MUST ALLOW 12000-BYTE RECORDS.'\n         DC    AL1(12)                                          @RP2008\nERR6     DC    CL133'0*** ERROR *** THIS CONTROL STATEMENT WILL BE IGNOX\n               RED.'\n         DC    AL1(12)                                          @RP2008\nERR7     DC    CL133'0             UNLOAD PROCESSING COMPLETED.  TOTALSX\n                FOLLOW: '\n         DC    AL1(0)                                           @RP2008\nERR8     DC    CL133'0** ERROR *** INVALID USE OF GENERIC GROUP/SUBGROUX\n               P/TYPE DURING UNLOAD.'\n         DC    AL1(12)                                          @RP2008\nERR9     DC    CL133'0** ERROR *** MEMBER CANNOT BE GENERIC FOR SEQUENTX\n               IAL DATASET UNLOAD.'\n         DC    AL1(12)                                          @RP2008\nERR10    DC    CL133'0             LOAD PROCESSING COMPLETED.  TOTALS FX\n               OLLOW: '\n         DC    AL1(0)                                           @RP2008\nERR11    DC    CL133'0             LIST PROCESSING COMPLETED. '\n         DC    AL1(0)                                           @RP2008\nERR12    DC    CL133'0             COPY PROCESSING COMPLETED.  TOTALS FX\n               OLLOW: '\n         DC    AL1(0)                                           @RP2008\nERR13    DC    CL133'0   *** ERROR *** INVALID RECORD FOUND ON EXPORT FX\n               ILE. IT IS IGNORED.'\n         DC    AL1(12)                                          @RP2008\nERR14    DC    CL133'0          CONVERT PROCESSING COMPLETED.  TOTALS FX\n               OLLOW: '\n         DC    AL1(0)                                           @RP2008\nERR15    DC    CL133'0            ALTER PROCESSING COMPLETED.  TOTALS FX\n               OLLOW: '\n         DC    AL1(0)                                           @RP2008\nERR16    DC    CL133'0***** ERROR ***** VSAM CLUSTER CANNOT BE OPENED. X\n               CHECK MESSAGE LOG.'\n         DC    AL1(12)                                          @RP2008\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHNOTE": {"ttr": 9484, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x01\\xb9\\x01\\xb9\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 441, "newlines": 441, "modlines": 0, "user": "ARCHIVR"}, "text": "NOTE     TITLE 'ARCHIVER --- NOTE FUNCTION'\n*---------------------------------------------------------------------*\n*---     ADD USER-SUPPLIED NOTES TO ARCHIVED ITEMS. NOTE THAT NO   ---*\n*---     ALIAS ENTRY CAN HAVE NOTE DATA ATTACHED TO IT. ALL NOTES  ---*\n*---     REFER TO, AND ARE A PART OF, A REAL ITEM ONLY.            ---*\n*---------------------------------------------------------------------*\nARCHNOTE CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n@RPL1    EQU   R2                  SOME\n@RPL2    EQU   R3                    SPECIAL\n@RPL3    EQU   R4                      EQUATES\n@BUF1    EQU   R5                        FOR\n@BUF2    EQU   R6                          VSAM\n@BUF3    EQU   R7                            I/O MGMT\n         COPY #ARCBITS\n         USING ARCHNOTE,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             NOTE ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHNOTE,R11        DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             NOTE NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RENOTE BACK POINTER\n         L     R14,12(,R14)        RENOTE ORIG. REG 14\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         XC    FCOUNT,FCOUNT       CLEAR FUNCTION RECORD COUNT\n         XC    MCNT,MCNT           AND MEMBER COUNT\n         XC    ACNT,ACNT           AND ALIAS COUNT\n         MVC   VS1MODE,=CL8'OUTPUT' SET THE I/O MODE\n         LA    R1,VSAM1DD          LOAD THE PARM POINTER\n         LA    R0,0                AND THE 'OPEN' FLAG\n         CALL  ARCHVSOP            CALL THE 'OPEN' FUNCTION\n         LTR   R15,R15             OPEN OK ??\n         BNZ   ENDITALL            NOPE; CAN'T WORK\n         EJECT\n*---------------------------------------------------------------------*\n*---     READ IN ALL THE 'NOTE' DATA, MATCHING THE KEY DATA        ---*\n*---     WITH THE USER-SPECIFIED KEY.  BUILD, IN STORAGE, A        ---*\n*---     SERIES OF ONE OR MORE ARCHIVE RECORDS, MINUS KEY FIELDS,  ---*\n*---     CONSISTING OF COMPACTED NOTE DATA.  EACH RECORD WILL      ---*\n*---     BE BUILT IN SUBPOOL 12, WITH A TWO-WORD PREFIX TO BE      ---*\n*---     USED TO CONTROL THE WRITING PROCESS LATER. THIS PREFIX    ---*\n*---     WILL CONTAIN A CHAIN POINTER TO THE NEXT RECORD AND       ---*\n*---     THE LENGTH OF THIS RECORD.                                ---*\n*---------------------------------------------------------------------*\n         BAL   R14,OPNVI           OPEN THE NONVSAM DATASET\n         L     R9,VS1LIM           LOAD MAX. RECORD LENGTH\n         LA    R9,8(,R9)           ACCOUNT FOR PREFIX\n         ICM   R9,8,=AL1(12)\n         GETMAIN R,LV=(9)          GRAB A BUFFER\n         LR    R8,R1               COPY ITS ADDRESS\n         LA    R9,0(,R9)           CLEAR HIGH-ORDER BYTE\n         LA    R15,0               SOURCE LENGTH/PAD = ZEROS\n         MVCL  R8,R14              AND CLEAR THE BUFFER AREA\n         MVC   4(4,R1),=A(RECKLEN) BARE KEY, TO START\n         ST    R1,CHAIN            SAVE THE RECORD POINTER\n         LR    R8,R1               AND COPY ITS ADDRESS\nNIN1     DS    0H\n         BAL   R14,GET             GO GET A RECORD\n         LTR   R0,R0               RECORD LENGTH OF ZERO ??\n         BZ    NIN4                YES; BUFFER CHAIN IS LOADED\n         LR    R4,R1               COPY RECORD ADDRESS\n         LR    R5,R0               AND LENGTH\n         MVI   LINE,C' '           SEED IN A BLANK\n         MVC   LINE+1(120),LINE    CLEAR THE LINE AREA\n         LR    R15,R5              COPY THE DATA LENGTH\n         CH    R15,=H'100'         OVER A HUNDRED ??\n         BNH   *+8                 NOPE\n         LA    R15,100             YES, ASSUME 100\n         BCTR  R15,R0              DECREMENT BY ONE\n         MVC   LINE+1(12),=C'NOTEDATA -->'\n         EX    R15,COPYNOTE        COPY DATA TO OUTPUT LINE\n         #PUT  LINE                AND DISPLAY THE DATA\n         L     R2,CMPWRK           POINT TO COMPACT WORK AREA\n         STH   R5,0(,R2)           SAVE ORIGINAL RECORD LENGTH\n         LA    R2,2(,R2)           POINT TO ACTUAL OUTPUT AREA\n         ST    R5,CALLIST+12\n         CALL  COMPACT,((R4),CALLIST+12,(R2)),MF=(E,CALLIST)\n         L     R4,CMPWRK           LOAD NEW RECORD POINTER\n         LR    R5,R0               COPY LENGTH\n         LA    R5,2(,R5)           ACCOUNT FOR LENGTH FIELD\n         L     R2,4(,R8)           LOAD CURRENT LENGTH\n         LA    R2,3(R2,R5)         COMPUTE NEW LENGTH\n         C     R2,VS1LIM           TOO LONG TO ADD ??\n         BH    NIN3                YES; START A NEW RECORD\nNIN2     DS    0H\n         L     R6,4(,R8)           LOAD CURRENT LENGTH\n         LR    R2,R6               COPY LENGTH\n         LA    R2,3(R5,R2)         ACCOUNT FOR NEW RECORD\n         ST    R2,4(,R8)           STORE UPDATED LENGTH\n         LA    R6,8(R6,R8)         POINT TO DATA FIELD\n         STCM  R5,7,0(R6)          STORE SEGMENT LENGTH\n         LA    R6,3(,R6)           POINT PAST IT\n         LR    R7,R5               COPY LENGTH TO MOVE\n         MVCL  R6,R4               MOVE RECORD INTO BUFFER\n         B     NIN1                AND CONTINUE\nNIN3     DS    0H\n         L     R3,VS1LIM           LOAD MAX. RECORD LENGTH\n         LA    R3,8(,R3)           ACCOUNT FOR PREFIX\n         ICM   R3,8,=AL1(12)\n         GETMAIN R,LV=(3)          GRAB A BUFFER\n         LR    R2,R1               COPY ITS ADDRESS\n         LR    R3,R0               AND LENGTH\n         LA    R15,0               SOURCE LENGTH/PAD = ZEROS\n         MVCL  R2,R14              AND CLEAR THE BUFFER AREA\n         MVC   4(4,R1),=A(RECKLEN) BARE KEY, TO START\n         ST    R1,0(,R8)           SAVE THE RECORD POINTER\n         LR    R8,R1               AND COPY ITS ADDRESS\n         B     NIN2                ADD DATA TO NEW BUFFER\nCOPYNOTE MVC   LINE+13(*-*),0(R4)  COPY OF NOTEDATA TO LINE\nNIN4     DS    0H\n         EJECT\n*---------------------------------------------------------------------*\n*---     HERE'S THE MEAT OF THE PROCESSING. THE BASIC PROCESS IS   ---*\n*---           THIS:                                               ---*\n*---                                                               ---*\n*---     1. USING THE CONTROL INFORMATION WE WERE GIVEN AND THE    ---*\n*---        INFORMATION WE'VE DEVELOPED, LOCATE THE HEADER RECORD  ---*\n*---        FOR THE FIRST MEMBER. WE'LL USE THE VS1BUF2 AREA FOR   ---*\n*---        HEADER/KEY CONSTRUCTION.                               ---*\n*---                                                               ---*\n*---     2. USING THE HEADER RECORD KEY, MODIFIED TO BE A 'NOTE'   ---*\n*---        RECORD, WRITE OUT THE RECORDS OF NOTE DATA BUILT IN    ---*\n*---        THE PREVIOUS STEP. THEN RETURN TO STEP1 FOR ANOTHER    ---*\n*---        HEADER (MAYBE).                                        ---*\n*---------------------------------------------------------------------*\nMEMBERS  DS    0H\n         L     @BUF1,VS1BUF1       LOAD BUFFER ADDRESS\n         L     @RPL1,RPL1          LOAD RPL1 ADDRESS\n         L     @RPL2,RPL2          LOAD RPL2 ADDRESS\n         USING REC,@BUF1           BASE THE RECORD DSECT\n         XC    RECTT(RECKLEN),RECTT  START AT THE BEGINNING !!\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               ARG=(@BUF1),AREA=(@BUF1),AREALEN=(*,VS1LIM),            X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         POINT RPL=(@RPL1)         GET TO IT\nNEXTHDR  DS    0H\n         GET   RPL=(@RPL1)         AND READ A HEADER RECORD\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\n         #IF   RSRALIAS,ON,NEXTHDR NO NOTES FOR ALIASES !!\n         LA    R1,RECN             POINT TO THE HEADER\n         LA    R0,0                USE DEFAULT QUALIFIER DATA\n         CALL  ARCHKNAM            GO CHECK: DO WE PROCESS THIS ITEM ??\n         LTR   R15,R15             PASS THE CHECK ??\n         BNZ   NEXTHDR             NOPE ---\n         ICM   R8,15,RSRNOT#       LOAD CURRENT NOTE RECORD COUNT\n         L     R9,CHAIN            POINT TO THE NOTE DATA\nADDN1    DS    0H\n         DROP  @BUF1\n         USING REC,@BUF2\n         LA    @BUF2,8(,R9)        POINT TO THE ACTUAL BUFFER\n         L     R10,4(,R9)          LOAD BUFFER LENGTH\n         MVC   0(RECKLEN,@BUF2),0(@BUF1) COPY THAT KEY\n         MVI   RECTT,#RTNOTE       RESET TO NOTE TYPE\n         LA    R8,1(,R8)           INCREMENT THE NOTE-DATA COUNT\n         STCM  R8,15,RECSEQ#       SAVE AS SEQUENCE NUMBER\n         MODCB RPL=(@RPL2),                                            X\n               OPTCD=(DIR,FKS,KEQ,SYN),                                X\n               ARG=(@BUF2),                                            X\n               AREA=(@BUF2),                                           X\n               RECLEN=(R10),                                           X\n               MF=(G,GENWK)        POSITION TO ITEM DATA START\n         PUT   RPL=(@RPL2)         WRITE THE NOTE-DATA BUFFER\n         LTR   R15,R15             DID IT WRITE OK ??\n         BNZ   1(,R15)             NOPE ---\n         L     R9,0(,R9)           POINT TO NEXT BUFFER\n         LTR   R9,R9               ANY RECORD HERE ??\n         BZ    UPHDR               NOPE; DO THE NEXT ONE\n         CLC   4(4,R9),=A(RECKLEN) JUST A BARE KEY\n         BH    ADDN1               NOPE; WRITE IT OUT\n         DROP  @BUF2\n         USING REC,@BUF1\nUPHDR    DS    0H\n         ENDREQ RPL=(@RPL2)\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(DIR,FKS,KGE,SYN,UPD),                            X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         GET   RPL=(@RPL1)\n         STCM  R8,15,RSRNOT#       SAVE UPDATED NOTE-DATA COUNT\n         PUT   RPL=(@RPL1)         WRITE THE UPDATED HEADER RECORD\n         MODCB RPL=(@RPL1),                                            X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         L     R15,MCNT            LOAD ITEM COUNT\n         LA    R15,1(,R15)         INCREMENT BY ONE\n         ST    R15,MCNT            AND SAVE UPDATED COUNT\n         #FORMAT RECTT,,ADDED\n         #PUT  LINE                AND OUTPUT THE MESSAGE\n         MVI   RECTT,#RTHDR        INITIAL RECORD TYPE\n         IC    R15,RECT+9          INSERT A 'TYPE' BYTE\n         LA    R15,1(,R15)         INCREMENT BY ONE\n         STC   R15,RECT+9          SAVE UPDATED VALUE\n         POINT RPL=(@RPL1)         GET TO IT\n         B     NEXTHDR             GO DO THE NEXT ONE\nENDITALL DS    0H\n         L     R0,MCNT             LOAD MEMBER COUNT\n         LTR   R0,R0               ZERO COUNT ??\n         BZ    END2                YES ---\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,MCMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\nEND2     DS    0H\n         CLC   ACB1,=F'0'          WAS ACB EVER OPENED ??\n         BE    NOACB               NOPE ---\n         LA    R1,VSAM1DD          POINT TO THE DDNAME\n         LA    R0,4                SET 'CLOSE' REQUEST\n         CALL  ARCHVSOP            CALL THE VSAM 'CLOSE' ROUTINE\nNOACB    DS    0H\n         BAL   R14,NVSCLOSE        GO CLOSE THE INPUT FILE\n         XC    CHAIN,CHAIN         CLEAR THE CHAIN POINTER\n         L     R13,4(,R13)         NOTE BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ALWAYS RC = 0\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\n         TITLE 'OPEN NONVSAM OUTPUT DATASET '\n*---------------------------------------------------------------------*\n*---     THIS LITTLE LOCAL SERVES ONLY ONE PURPOSE: TO OPEN        ---*\n*---     THE NONVSAM SEQUENTIAL DATASET CONTAINING THE 'NOTE'      ---*\n*---     DATA TO BE ADDED TO THE ARCHIVE CLUSTER.                  ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nOPNVI    DS    0H\n         STM   R14,R12,IOSAVE      SAVE THE ENTRY REGISTERS\n*---\n*---     BUILD A DCB, TO START, FOR DSORG CHECKING\n*---\n         GETMAIN R,LV=QSDCBL,SP=10 GRAB STORAGE FOR BPAM DCB\n         ST    R1,NDCBA            AND STORE ADDRESS IN ARCHIVWA\n         LR    R2,R1               COPY ITS ADDRESS\n         MVI   NDCBA,X'80'         BUILD OPEN PARM LIST\n         MVC   0(QSDCBL,R1),QSDCB  COPY DCB TO DYNAMIC AREA\n         USING IHADCB,R2           BASE THE DCB DSECT\n         MVC   DCBDDNAM,NVSAMDD    MOVE IN THE DDNAME\n         OPEN  ,MF=(E,NDCBA) OPEN THE DCB\n*---\n*---     USING THE RECFM AS A GUIDE, SET THE S-TYPE ADDRESS OF\n*---     THE APPROPRIATE DEBLOCKER INTO THE BRANCH INSTRUCTION AT\n*---     'BLOCK'\n*---\n         MVC   BLOCK(2),=X'47F0'   FIRST HALF OF A BRANCH\n         TM    DCBRECFM,DCBRECU    U-FORMAT ??\n         BNO   OPNVI7              NOPE ---\n         B     OPNVI11             SCAT ---\nOPNVI7   DS    0H\n         TM    DCBRECFM,DCBRECV+DCBRECBR VB FORMAT ??\n         BNO   OPNVI8              NOPE ---\n         MVC   BLOCK+2(2),=S(GETV) SET 'U' ROUTINE\n         B     OPNVI12             YES; ERROR MSG AND QUIT\nOPNVI8   DS    0H\n         TM    DCBRECFM,DCBRECF+DCBRECBR FB FORMAT ??\n         BNO   OPNVI9              NOPE ---\n         MVC   BLOCK+2(2),=S(GETFB) SET 'FB' ROUTINE\n         B     OPNVI12             SCAT ---\nOPNVI9   DS    0H\n         TM    DCBRECFM,DCBRECV    V FORMAT ??\n         BNO   OPNVI10             NOPE ---\n         MVC   BLOCK+2(2),=S(GETV) SET 'V' ROUTINE\n         B     OPNVI12             SCAT ---\nOPNVI10  DS    0H\n         TM    DCBRECFM,DCBRECF    V FORMAT ??\n         BNO   OPNVI11             NOPE ---\n         MVC   BLOCK+2(2),=S(GETF) SET 'F' ROUTINE\n         B     OPNVI12             SCAT ---\nOPNVI11  DS    0H\n         #PUT  =CL133'- INVALID OR UNKNOWN NOTEDATA INPUT FORMAT.'\n         #PUT  =CL133'  ADDNOTE REQUEST IS IGNORED. '\n         B     ENDITALL\nOPNVI12  DS    0H\n         L     R0,=F'32768'        NOTE COMPRESS MAX LENGTH\n         ICM   R0,8,=AL1(10)       INSERT SUBPOOL NUMBER\n         GETMAIN R,LV=(0)\n         STM   R0,R1,CMPWRKL       STORE COMPRESS WORK-AREA ADDRESS\n         LM    R14,R12,IOSAVE      RENOTE ENTRY REGISTERS\n         BR    R14                 AND RETURN TO LOCAL CALLER\n         DROP  R2\n         TITLE 'QSAM CLOSE ROUTINE'\n*---------------------------------------------------------------------*\n*---     THIS LITTLE ROUTINE CLOSES THE NONVSAM DATASET, WITH      ---*\n*---     THE REREAD OPTION.  THIS ALLOWS MULTIPLE SETS OF NOTE     ---*\n*---     DATA TO BE RETAINED ON ONE SEQUENTIAL DATASET.  WHILE     ---*\n*---     THE MECHANISM WORKS WITH JES2 SYSIN DATA, I HAVE NO       ---*\n*---     IDEA WHETHER IT WORKS WITH JES3.                          ---*\n*---                                                               ---*\n*---     IT SEEMS THAT JES2 HONORS THE CLOSE OPTIONS, TREATING     ---*\n*---     EACH SYSIN DATASET IN THE SAME FASHION AS OPEN/CLOSE/     ---*\n*---     EOV WOULD TREAT A NON-JES DATASET ON REUSABLE MEDIA.      ---*\n*---     (DASD, TAPE, ETC. BUT NOT DIRECT 3505 INPUT)              ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nNVSCLOSE DS    0H\n         STM   R14,R12,IOSAVE      SAVE THE ENTRY REGISTERS\n         L     R2,NDCBA            NOTE PRIMARY DCB ADDRESS\n         LA    R2,0(,R2)           PURIFY THE ADDRESS\n         LTR   R2,R2               ZERO ??\n         BZ    NVC1                YES; NO DCB HERE ---\n         TM    48(R2),X'10'        IS IT OPEN ??\n         BZ    NVCA                NOPE ---\n         CLOSE (,REREAD),MF=(E,NDCBA) CLOSE THE DCB\nNVCA     DS    0H\n         #FREE (2)                 RELEASE BUFFER POOL, IF ANY\n         XC    NDCBA,NDCBA         AND RESET THE POINTER FIELD\nNVC1     DS    0H\n         XC    CMPWRKL(8),CMPWRKL\n         MVC   BLOCK+2(2),=S(0(R14))\n         #SET  NVSPS,OFF\n         #SET  NVSPO,OFF\n         LM    R14,R12,IOSAVE      RESTORE THE REGISTERS\n         BR    R14                 AND RETURN TO CALLER\n         TITLE 'QSAM READ ROUTINES '\n*---------------------------------------------------------------------*\n*---     REGS AT EXIT:                                             ---*\n*---              R0 ::= LOGICAL RECORD LENGTH                     ---*\n*---              R1 --> LOGICAL RECORD                            ---*\n*---              R14 -> RETURN ADDRESS                            ---*\n*---                                                               ---*\n*---     THE SPECIAL CASE OF A RECORD LENGTH OF ZERO SIGNALS A     ---*\n*---     END OF FILE CONDITION.                                    ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nGET      DS    0H\n         STM   R14,R12,IOSAVE      SAVE INPUT REGISTERS\n         L     R9,NDCBA            NOTE DCB ADDRESS\n         USING IHADCB,R9           AND BASE ITS DSECT\nREGET    DS    0H\n         GET   (9)                 READ A RECORD\n         B     BLOCK               GO SET UP RETURN VALUES\n         TITLE 'QSAM GET REGISTER SETUPS '\n*---------------------------------------------------------------------*\n*---     FIXED, UNBLOCKED RECORDS.                                 ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nGETF     DS    0H\n         LH    R0,DCBBLKSI         LOAD THE BLKSIZE\n         LR    R2,R0               COPY RECORD LENGTH\n         LA    R2,0(R2,R1)         POINT TO RECORD END\n         SH    R2,=H'8'            BACK UP 8 CHARS.\n         CLC   CURKEY,0(R2)        CORRECT NOTEDATA KEY ??\n         BNE   REGET               NOPE; SKIP THIS RECORD\n         SH    R0,=H'8'            LEAVE OFF THE 'KEY'\n         B     GETRET              AND GO RETURN TO LOCAL CALLER\n         SPACE 3\n*---------------------------------------------------------------------*\n*---     FIXED, BLOCKED RECORDS.                                   ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nGETFB    DS    0H\n         LH    R0,DCBLRECL         LOAD LOGICAL RECORD LENGTH\n         LR    R2,R0               COPY RECORD LENGTH\n         LA    R2,0(R2,R1)         POINT TO RECORD END\n         SH    R2,=H'8'            BACK UP 8 CHARS.\n         CLC   CURKEY,0(R2)        CORRECT NOTEDATA KEY ??\n         BNE   REGET               NOPE; SKIP THIS RECORD\n         SH    R0,=H'8'            LEAVE OFF THE 'KEY'\n         B     GETRET              AND GO RETURN TO LOCAL CALLER\n         SPACE 3\n*---------------------------------------------------------------------*\n*---     VARIABLE, UNBLOCKED OR UNBLOCKED, RECORDS                 ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nGETV     DS    0H\n         CLC   CURKEY,4(R1)        CORRECT NOTEDATA KEY ??\n         BNE   REGET               NOPE; SKIP THIS RECORD\n         LH    R0,0(,R1)           LOAD LENGTH FROM RDW/BDW\n         SH    R0,=H'12'           DROP RDW AND KEY FIELD\n         LA    R1,12(,R1)          POINT TO ACTUAL NOTE DATA\n         B     GETRET              AND GO RETURN TO LOCAL CALLER\n         SPACE 3\n*---------------------------------------------------------------------*\n*---     COMMON RETURN LINKAGE CODE                                ---*\n*---------------------------------------------------------------------*\nGETRET   DS    0H\n         STM   R0,R1,IOSAVE+8\n         LM    R14,R12,IOSAVE      RESTORE CALLER'S REGISTERS\n         BR    R14                 RETURN ---\n         SPACE 3\n*---------------------------------------------------------------------*\n*---     END-OF-FILE ON THE NOTEDATA DATASET                       ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nGETEOD   DS    0H\n         LA    R1,0                NO RECORD ADDRESS\n         LA    R0,0                AND NO LENGTH\n         B     GETRET              AND RETURN TO CALLER\n         DROP  R9\n*---------------------------------------------------------------------*\n*---     SOME ERROR STUFF                                          ---*\n*---------------------------------------------------------------------*\nNODDERR  DS    0H\n         #ERR  MSG=1\n         #ERR  MSG=6\n         B     ENDITALL\nORGERR   DS    0H\n         #ERR  MSG=3\n         #ERR  MSG=6\n         B     ENDITALL\nERRDEV   DS    0H\n         #ERR  MSG=2\n         #ERR  MSG=6\n         B     ENDITALL\n         LTORG\nMCMSG    DC    CL133' '\n         ORG   MCMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    C' TOTAL MEMBER(S) PROCESSED.'\n         ORG\nADDED    DC    AL1(ADDMSGE-ADDMSG)\nADDMSG   DC    C' NOTE DATA INSERTED.'\nADDMSGE  EQU   *\nMINREC   DC    A(RECSIZE)\nQSDCB    DCB   DSORG=PS,MACRF=GL,DDNAME=X,EODAD=GETEOD,BFTEK=A\nQSDCBL   EQU   *-QSDCB\n         DCBD  DSORG=(PS,PO)\n         COPY  #RECS\n         COPY  ##ARCHWK\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHPARS": {"ttr": 9736, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06\\x0c\\x00\\x00\\x01 !?\\x01 !?\\x15\\x00\\x05\\xad\\x05\\xad\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@'", "ispf": {"version": "06.12", "flags": 0, "createdate": "2020-07-31T00:00:00", "modifydate": "2020-07-31T15:00:00", "lines": 1453, "newlines": 1453, "modlines": 0, "user": "ARCHIVR"}, "text": "PARS     TITLE 'ARCHIVER V4.0 --- CONTROL STATEMENT PARSE'\n*---------------------------------------------------------------------*\n*---     ARCHPARS --- THE CONTROL STATEMENT PARSE ROUTINE          ---*\n*---                                                               ---*\n*---     THIS SERIALLY-REUSABLE ROUTINE DOES ALL THE CONTROL       ---*\n*---     STATEMENT PROCESSING FOR THE ARCHIVER.  DUE TO THE        ---*\n*---     NATURE OF RPARSE, THIS ROUTINE IS NOT REENTRANT AND       ---*\n*---     PROBABLY NEVER WILL BE.  FOR THAT REASON, THE ARCHIVER    ---*\n*---     USES THE 'LOAD' MACRO TO MAKE THIS ROUTINE AVAILABLE,     ---*\n*---     RATHER THAN A SIMPLE VCON.                                ---*\n*---                                                               ---*\n*---     INPUT: THE AREA MAPPED BY THE RESULTS AREA IS             ---*\n*---     ADDRESSED DIRECTLY BY REGISTER 1.  THIS AREA ALSO         ---*\n*---     INCLUDES THE ADDRESSES OF ALL THE ARCHIVER ROUTINES       ---*\n*---     THAT MIGHT BE USEFUL, LIKE THE PRINTING ROUTINE.          ---*\n*---                                                               ---*\n*---     OUTPUT: THE RESULTS AREA IS FILLED IN, USING THE DYNAM    ---*\n*---     ROUTINE AS INDICATED BY CONTROL STATEMENTS TO ALLOCATE    ---*\n*---     DATASETS.  ONE SPECIAL CASE: THE WORK FILE(S) IS(ARE)     ---*\n*---     DYNAMICALLY ALLOCATED BY THE PROCESSORS OF THE ARCHIVER   ---*\n*---     THAT NEED THEM, AS NEEDED.  DEFAULT SIZES FOR WORK        ---*\n*---     FILES ARE DEFINED IN THE ARCHIVER MAIN PROGRAM.           ---*\n*---                                                               ---*\n*---     PLEASE NOTE: ANY REFERENCES TO FUNCTIONS NOT IMPLEMENTED  ---*\n*---     IMPLIES A 'COMING ATTRACTION', TO BE IMPLEMENTED IN       ---*\n*---     SOME FUTURE VERSION OF THE ARCHIVER PROGRAM.              ---*\n*---                                                               ---*\n*---     ANY CONTROL-STATEMENT-RELATED ERRORS, SUCH AS SYNTAX,     ---*\n*---     ARE GENERATED BY THIS ROUTINE AND PRINTED USING A         ---*\n*---     SPECIAL FORM OF THE #PUT MACRO.                           ---*\n*---                                                               ---*\n*---     ATTRIBUTES: SERIALLY-REUSABLE, NON-REENTRANT, AMODE-24,   ---*\n*---                 RMODE-24, UNAUTHORIZED.                       ---*\n*---                                                               ---*\n*---     SET RETURN CODE IF A SYNTAX ERROR DETECTED             @RP2008\n*---------------------------------------------------------------------*\n         MACRO\n&LBL     #PUT  &VALUE\n         LCLC  &L\n&L       SETC  '&LBL'\n         AIF   ('&L' EQ '').NOLBL\n&LBL     DS    0H\n.NOLBL   ANOP\n         LA    R1,&VALUE           POINT TO PRINT DATA\n         LR    R0,R12              LOAD THE BLOCK START ADDRESS\n         L     R15,PRTRTN          POINT TO THE PRINT ROUTINE\n         BALR  R14,R15             AND CALL IT\n         AIF   ('&VALUE' EQ 'LINE').END     .NO ERROR MESSAGE   @RP2008\n         OI    WKRC,8              SET RETURN CODE              @RP2008\n.END     ANOP\n         MEND\nARCHPARS CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n         COPY  #ARCBITS             COPY MASTER BIT LIST\n         USING ARCHPARS,R15\n         #STAMP\n         STM   R14,R12,12(R13)     SAVE ENTRY REGISTERS\n         LR    R11,R15             COPY ENTRY ADDRESS\n         DROP  R15                 DISCARD OLD BASE\n         USING ARCHPARS,R11,R10,R9 DEFINE THE BASE REGISTERS\n         LA    R10,0(,R11)\n         AH    R10,PASSIT-2\n         LA    R9,0(,R10)\n         AH    R9,PASSIT-2\n         USING MAINWK,R12          AND BASE ITS DSECT\n         L     R3,PRSWKL           LOAD WORK AREA LENGTH\n         GETMAIN R,LV=(3)          A WORK AREA\n         LR    R2,R1               COPY ITS ADDRESS\n         LA    R14,0               CLEAR SOURCE POINTER\n         LA    R15,0               AND LENGTH/PAD\n         MVCL  R2,R14              CLEAR THE WORK AREA\n         ST    R1,8(,R13)          STORE FORWARD POINTER\n         ST    R13,4(,R1)          AND BACK POINTER\n         LR    R13,R1              BUMP POINTER DOWN THE CHAIN\n         USING PRSWK,R13\n         L     R2,CTLIN            READ A CARD\n         USING IHADCB,R2\n         MVC   DCBEODA,=AL3(DONE2) NEW EODAD ADDRESS\n         DROP  R2\n*---------------------------------------------------------------------*\n*---     CLEAR ANY SCANNER RESULTS IN ##ARCHWK.                   ----*\n*---------------------------------------------------------------------*\nIGNORE   DS    0H\n         #SET  GENM,OFF            MEMBER NAME IS GENERIC\n         #SET  GENG,OFF            GROUP IS GENERIC\n         #SET  GENSG,OFF           SUBGROUP IS GENERIC\n         #SET  GENT,OFF            TYPE IS GENERIC\n         #SET  VRS,OFF             VERSION SPECIFIED\n         #SET  SUPM,OFF            MEMBER NAME SUPPLIED\n         #SET  SUPG,OFF            GROUP NAME SUPPLIED\n         #SET  SUPSG,OFF           SUBGROUP NAME SUPPLIED\n         #SET  SUPTYP,OFF          TYPE NAME SUPPLIED\n         #SET  SAMECL,OFF          VSAM1 IS ALSO VSAM2\n         #SET  REPL,OFF            REPLACE DUPS. DURING RELOAD\n         #SET  GREPL,OFF           REPLACE= SUPPLIED\n         #SET  RETA,ON             RETAIN ALIAS INFORMATION\n         #SET  GRETA,OFF           ALIAS= SUPPLIED\n         #SET  SHHDR,ON            PROCESS HEADERS\n         #SET  GSHHDR,OFF          HEADER= SUPPLIED\n         #SET  SHHEX,OFF           LISTING IS IN HEX\n         #SET  GSHHEX,OFF          HEX= SUPPLIED\n         #SET  SHITEM,OFF          PROCESS ITEM DATA\n         #SET  GSHITEM,OFF         DATA= SUPPLIED\n         #SET  ULMODS,ON           RECFM=U MEANS LMODS\n         #SET  GULMODS,OFF         ULMODS= SUPPLIED\n         #SET  COMK,OFF            COMMDATA KEY IS SPECIFIED\n         #SET  PRCB,OFF            DELETE BACK-LEVEL ITEMS ONLY\n         #SET  GPRCB,OFF           BACK= SUPPLIED\n         #SET  PRCCM,OFF           PROCESS COMMDATA\n         #SET  GPRCCM,OFF          NOTE= SUPPLIED\n         #SET  NVPAN,OFF           NONVSAM IS A PANLIB\n         #SET  GNVPAN,OFF          PANLIB= SUPPLIED\n         #SET  NGENM,OFF           MEMBER NAME(2) IS GENERIC\n         #SET  NGENG,OFF           GROUP(2) IS GENERIC\n         #SET  NGENSG,OFF          SUBGROUP(2) IS GENERIC\n         #SET  NGENT,OFF           TYPE(2) IS GENERIC\n         #SET  RNGM,OFF            MEMBER IS A RANGE\n         #SET  RNGG,OFF            GROUP IS A RANGE\n         #SET  RNGSG,OFF           SUBGROUP IS A RANGE\n         #SET  RNGT,OFF            TYPE IS A RANGE\n         #SET  NVSPS,OFF           NONVSAM DATASET IS SEQUENTIAL\n         #SET  NVSPO,OFF           NONVSAM DATASET IS PARTITIONED\n         #SET  NOEXP,OFF           BYPASS EXPANDER DURING LOAD\n         #SET  CONV,OFF            FORMAT CONVERSION REQUESTED\n         #SET  SAMENAME,OFF        COMPTO MEMBER SAME AS ITEM MEMBER\n         #SET  SAMEGRP,OFF         COMPTO GROUP SAME AS ITEM GROUP\n         #SET  SAMESGRP,OFF        COMPTO SUBGRP SAME AS ITEM SUBGRP\n         #SET  SAMETYPE,OFF        COMPTO TYPE SAME AS ITEM TYPE\n         #SET  LISTALLC,OFF        LIST ALL COMPARISONS,OFF GOOD OR BAD\n         #SET  AUTOALIS,OFF        AUTOMATICALLY DELETE/ASSIGN ALIAS\n         #SET  CMPSHRTL,OFF        NOT SHORT-FORM COPY LIST\n         MVI   Q1,C' '\n         MVC   Q1+1(39),Q1\n         XC    Q5,Q5\n         MVC   QC1(40),Q1\n         XC    QC5,QC5\n         MVC   HIGHMEM,Q1\n         MVC   VERB,Q1\n         MVC   CURKEY,Q1\n         MVC   SEPVAL,Q1\nP3       DS    0H\n*---------------------------------------------------------------------*\n*---     NOW THE BREAD-AND-BUTTER PROCESSING. READ A CARD AND      ---*\n*---     SCAN OFF THE PARMS, FILLING IN THE RESULTS AREA AS        ---*\n*---     NEEDED.                                                   ---*\n*---------------------------------------------------------------------*\n*---     READ A CARD AND LIST IT OUT                               ---*\n*---------------------------------------------------------------------*\n         #IF   EODIN,ON,RET4\n         L     R2,CTLIN            READ A CARD\n         GET   (2),INCARD\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE+21(80),INCARD  COPY TO PRINT AREA\n         #PUT  LINE                LIST IT FOR THE USER\n         LA    R7,INCARD           POINT IT OUT FOR THE SCAN\n         CLI   0(R7),C'*'          COMMENT RECORD ??\n         BE    P3                  YES; GO FOR ANOTHER\n*---------------------------------------------------------------------*\n*---     CLOBBER ANY SEQUENCE FIELD AND LOCATE VERB AND OPERAND(S) ---*\n*---------------------------------------------------------------------*\n         MVC   72(8,R7),BLANKS     CLOBBER SEQUENCE FIELD\n         MVC   VERB,BLANKS         CLEAR THE VERB AREA\n         LA    R6,73(,R7)          POINT TO LAST POSSIBLE COLUMN\nNONAME   DS    0H\n         LA    R1,0(,R6)           COPY ENDING ADDRESS\n         SR    R1,R7               MINUS STARTING ADDRESS\n         BCTR  R1,R0               370 GLITCH\n         EX    R1,TRTX             SCAN FOR NON-BLANK\n         BZ    ERR1                NONE; CTL STMT ERROR\n         LR    R7,R1               COPY ITS ADDRESS\n         LR    R1,R6               COPY END ADDRESS\n         SR    R1,R7               COMPUTE LENGTH\n         BCTR  R1,R0               370 GLITCH (AGAIN)\n         EX    R1,TRTY             LOCATE END OF VERB\n         BZ    ERR1                NONE; CTL STMT ERROR\n         SR    R1,R7               COMPUTE VERB LENGTH\n         CH    R1,=H'10'           TOO LONG ??\n         BH    ERR4                YES ---\n         BCTR  R1,R0               370 GLITCH\n         EX    R1,COPYVERB         COPY VERB TO RETURN AREA\n         LA    R7,1(R1,R7)         POINT BACK TO SCAN STOPPER\nOPNDS    DS    0H\n         LR    R1,R6               COPY THE ENDING ADDRESS\n         SR    R1,R7               COMPUTE LENGTH LEFT TO SCAN\n         EX    R1,TRTX             LOCATE THE NEXT NON-BLANK\n         BZ    DONE1               ALL DONE; GO PARSE WORK STRING\n         LR    R7,R1               AND COPY ITS ADDRESS\n         LR    R1,R6               COPY THE ENDING ADDRESS\n         SR    R1,R7               COMPUTE LENGTH LEFT TO SCAN\n         EX    R1,TRTY             LOCATE END OF OPERANDS\n         SR    R1,R7               COMPUTE OPERAND STRING LENGTH\n         LR    R3,R1               COPY THE LENGTH\n         LR    R2,R7               AND ADDRESS\n         L     R5,STRLEN           LOAD CURRENT WKSTR LENGTH\n         LA    R4,WKSTR(R5)        POINT INTO WKSTR\n         AR    R5,R3               ADD NEW STRING LENGTH\n         ST    R5,STRLEN           SAVE UPDATED LENGTH\n         LR    R5,R3               COPY MOVE LENGTH\n         MVCL  R4,R2               COPY OPERANDS TO WORK STRING\n         L     R3,STRLEN           RELOAD WORK STRING LENGTH\n         LA    R3,WKSTR(R3)        POINT TO STRING END\n         BCTR  R3,R0               BACK UP A BYTE\n         CLI   0(R3),C','          END IN A COMMA ??\n         BNE   DONE1               NOPE; PROCESS AS COMPLETE STRING\n         L     R2,CTLIN            LOCATE THE INPUT DCB\nREGET    DS    0H\n         L     R2,CTLIN\n         #IF   EODIN,ON,RET4\n         GET   (2),INCARD\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         MVC   LINE+21(80),0(R1)   COPY TO PRINT AREA\n         #PUT  LINE                LIST IT FOR THE USER\n         LA    R7,INCARD           POINT IT OUT FOR THE SCAN\n         CLI   0(R7),C'*'          COMMENT RECORD ??\n         BE    REGET               YES; GO FOR ANOTHER\n         LA    R6,71(,R7)          POINT TO LAST POSSIBLE COLUMN\n         MVC   INCARD+72(8),BLANKS CLOBBER SEQUENCE FIELD\n         B     OPNDS               AND GO FOR OPERANDS ---\nDONE2    DS    0H\n         #SET  EODIN,ON\n         NC    STRLEN,STRLEN       NULL STRING ??\n         BZ    ENDSCAN             YES; ALL DONE ---\nDONE1    DS    0H\n         L     R2,STRLEN           LOAD WORK STRING LENGTH\n         LTR   R2,R2               NO OPERANDS ??\n         BZ    DOVERB              YES ---\n         LA    R3,WKSTR            POINT TO THE WORK STRING\n         LA    R4,0(R3,R2)         POINT TO WORK STRING END\n         BCTR  R4,R0               BACK UP A BYTE\n         CLI   0(R4),C','          END IN A COMMA ??\n         BE    ERRC                YES; INCOMPLETE\n         LA    R4,1(,R4)           POINT BACK TO END\n         MVC   0(8,R4),BLANKS      PAD WITH BLANKS\n*---------------------------------------------------------------------*\n*---     SELECT A PARSE KEYWORD LIST BASED ON THE VERB.  THIS IS   ---*\n*---     TO SERVE TWO PURPOSES: FIRST, TO ALLOW DIFFERENT PROC-    ---*\n*---     ESSING FOR THE SAME KEYWORD ON TWO CONTROL STATEMENTS     ---*\n*---     AND TO ALLOW DEFAULTS TO BE SET HERE, RATHER THAN IN THE  ---*\n*---     ARCHMAIN ROUTINE.                                         ---*\n*---------------------------------------------------------------------*\nDOVERB   DS    0H\n         LA    R4,KVBTAB           POINT TO TABLE START\n         LA    R14,KVBLEN          LOAD ENTRY LENGTH\n         LA    R15,KVBLAST         AND LAST ENTRY\nKVBS1    DS    0H\n         CLC   VERB,0(R4)          VERBS MATCH ??\n         BE    KVBS2               YES; WE'VE GOT IT ---\n         BXLE  R4,R14,KVBS1        LOOP, SEARCHINGLY\n*        UNKNOWN VERB LANDS HERE\n         MVI   LINE,C' '           SEED IN A BLANK\n         MVC   LINE+1(120),LINE    MAKE A WHOLE FOREST\n         MVC   LINE+1(3),=CL3'***'\n         MVC   LINE+5(10),VERB     COPY VERB TO LINE\n         MVC   LINE+17(L'VBMSG),VERBMSG MESSAGE TEXT\n         #PUT  LINE                OUTPUT THE MESSAGE\n         XC    STRLEN,STRLEN       RESET THE WORK STRING\n         B     IGNORE              IGNORE THIS STATEMENT\nKVBS2    DS    0H\n         L     R7,12(,R4)          LOAD PARSE TABLE ADDRESS\n         LTR   R7,R7               ANYTHING TO PARSE ??\n         BZ    ENDSCAN             NOPE; NO OPERANDS\n         CALL  RPARSE,((R3),STRLEN,(7)),MF=(E,CALLIST)\n         LR    R1,R15              COPY THE RETURN CODE\n         N     R15,=A(X'FF')\n         B     P5(R15)             PROCESS THE RETURN CODE\nP5       DS    0H\n         B     PRC0                ALL IS OK\n         B     PRC4                SYNTAX ERROR\n         B     PRC8                POS. PARM AFTER KW PARM\n         B     PRC12               MIS-MATCHED PARENTHESES\n         B     PRC16               MISSING '=' AFTER KW\n         B     PRC20               ZERO LENGTH PARAMETER\n         B     PRC24               UNKNOWN KEYWORD\n         B     PRC28               SUBLIST IMPROPERLY ENDED\n         B     PRC32               Q'STR IMPROPERLY ENDED\n         B     PRC36               NESTED TOO DEEP\nPRC0     DS    0H\n         EJECT\n*---------------------------------------------------------------------*\n*---     FILL IN THE RESULTS AREA FROM THE OUTPUT OF THE           ---*\n*---     STATEMENT PARSE. THIS IS DONE BY LOOPING THROUGH          ---*\n*---     THE PARSE PARAMETER LIST SELECTED ABOVE AND USING         ---*\n*---     THE RSV FIELD OF THE PARSE ELEMENT TO SELECT THE          ---*\n*---     OPERAND PROCESSING ROUTINE APPROPRIATE. BECAUSE OF        ---*\n*---     THE NATURE OF THIS MECHANISM, ALL SUBLISTS ARE            ---*\n*---     ASSUMED TO BE POSITIONAL-TYPE CONTENT.                    ---*\n*---------------------------------------------------------------------*\n         LH    R6,2(,R7)           LOAD $PARSE TABLE ENTRY COUNT\n         LA    R7,4(,R7)           POINT TO FIRST ACTUAL ENTRY\n         USING PRSKWKW,R7          AND BASE THE DSECT\nPL1      DS    0H\n         LR    R8,R7               COPY $PARSE ENTRY ADDRESS\n         CLC   =F'0',PRSKWSL       ANY SUBLIST ??\n         BE    PL2                 NOPE ---\n         L     R8,PRSKWSL          LOAD SUBLIST POINTER\nPL2      DS    0H\n         CLC   PRSKWLN,=H'0'       ZERO-LENGTH VALUE ??\n         BE    PL3                 THAT'S RIGHT ---\n         LH    R15,PRSKWRS         LOAD RESERVED-FIELD VALUE\n         LA    R15,PLRTAB(R15)     POINT INTO PROCESSOR ADDRESS LIST\n         L     R15,0(,R15)         LOAD PROCESSOR ADDRESS\n         BR    R15                 AND GO TO IT ---\nPL3      DS    0H\n         LA    R7,PRSKWBC(,R7)     POINT TO NEXT ENTRY\n         BCT   R6,PL1              AND LOOP, PROCESSING EACH PARM\n         B     ENDSCAN             AND TERMINATE THE PARSER\n         DROP  R7\n         USING PRSKWKW,R8          AND REDEFINE THE DSECT\n         EJECT\n*---------------------------------------------------------------------*\n*---     OPERAND PROCESSING STARTS HERE                           ----*\n*---------------------------------------------------------------------*\n         SPACE 3\n*---------------------------------------------------------------------*\n*---     PROCESS ALIASES=(YES/Y/NO/N) SPECIFICATION                ---*\n*---     TRIGGERS THE RETENTION OF ALIASES DURING LOAD/UNLOAD      ---*\n*---------------------------------------------------------------------*\nALIASES  DS    0H\n         #SETFLAG BIT=RETA,        SWITCH BIT NAME                     X\n               MSGVAL=ALIAS,       SUBSTITUTION VALUE FOR ERROR MSG    X\n               KWG=GRETA           KEYWORD-SUPPLIED FLAG BIT NAME\n         B     PL3                 RETURN TO OPERAND LOOP\n*---------------------------------------------------------------------*\n*---     PROCESS BACK=(YES/Y/NO/N) SPECIFICATION                   ---*\n*---     PROCESS ALL BACK LEVELS. DELETE/LIST ONLY                 ---*\n*---------------------------------------------------------------------*\nBACK     DS    0H\n         #SETFLAG BIT=PRCB,        SWITCH BIT NAME                     X\n               MSGVAL=BACK,        SUBSTITUTION VALUE FOR ERROR MSG    X\n               KWG=GPRCB           KEYWORD-SUPPLIED FLAG BIT NAME\n         B     PL3                 RETURN TO OPERAND LOOP\n*---------------------------------------------------------------------*\n*---     PROCESS DATA=(YES/Y/NO/N) SPECIFICATION                   ---*\n*---     PROCESS ALL DATA RECDS; LIST/DELETE ONLY                  ---*\n*---     DEFAULT = NO                                              ---*\n*---------------------------------------------------------------------*\nDATA     DS    0H\n         #SETFLAG BIT=SHITEM,      SWITCH BIT NAME                     X\n               MSGVAL=DATA,        SUBSTITUTION VALUE FOR ERROR MSG    X\n               KWG=GSHITEM         KEYWORD-SUPPLIED FLAG BIT NAME\n         B     PL3                 RETURN TO OPERAND LOOP\n*---------------------------------------------------------------------*\n*---     PROCESS HEX=(YES/Y/NO/N) SPECIFICATION                    ---*\n*---     LIST INFORMATION IN HEX. LIST ONLY                        ---*\n*---     DEFAULT = NO                                              ---*\n*---------------------------------------------------------------------*\nHEX      DS    0H\n         #SETFLAG BIT=SHHEX,       SWITCH BIT NAME                     X\n               MSGVAL=HEX,         SUBSTITUTION VALUE FOR ERROR MSG    X\n               KWG=GSHHEX          KEYWORD-SUPPLIED FLAG BIT NAME\n         B     PL3                 RETURN TO OPERAND LOOP\n*---------------------------------------------------------------------*\n*---     PROCESS HDR=(YES/Y/NO/N) SPECIFICATION                    ---*\n*---     LIST HEADER INFORMATION. LIST ONLY                        ---*\n*---     DEFAULT = YES                                             ---*\n*---------------------------------------------------------------------*\nHEADER   DS    0H\n         #SETFLAG BIT=SHHDR,       SWITCH BIT NAME                     X\n               MSGVAL=HEADER,      SUBSTITUTION VALUE FOR ERROR MSG    X\n               KWG=GSHHDR          KEYWORD-SUPPLIED FLAG BIT NAME\n         B     PL3                 RETURN TO OPERAND LOOP\n*---------------------------------------------------------------------*\n*---     PROCESS NOTE=(YES/Y/NO/N) SPECIFICATION                   ---*\n*---     PROCESS NOTE DATA (FORMERLY 'COMMENT' DATA)               ---*\n*---     DEFAULT = NO (LIST/DELETE ONLY)                           ---*\n*---------------------------------------------------------------------*\nNOTE     DS    0H\n         #SETFLAG BIT=PRCCM,       SWITCH BIT NAME                     X\n               MSGVAL=NOTE,        SUBSTITUTION VALUE FOR ERROR MSG    X\n               KWG=GPRCCM          KEYWORD-SUPPLIED FLAG BIT NAME\n         B     PL3                 RETURN TO OPERAND LOOP\n*---------------------------------------------------------------------*\n*---     PROCESS PANLIB=(YES/Y/NO/N) SPECIFICATION                 ---*\n*---     NONVSAM DATASET IS A PANLIB                               ---*\n*---     DEFAULT = NO (LIST/DELETE ONLY)                           ---*\n*---------------------------------------------------------------------*\nPANLIB   DS    0H\n         #SETFLAG BIT=NVPAN,       SWITCH BIT NAME                     X\n               MSGVAL=PANLIB,      SUBSTITUTION VALUE FOR ERROR MSG    X\n               KWG=GNVPAN          KEYWORD-SUPPLIED FLAG BIT NAME\n         B     PL3                 RETURN TO OPERAND LOOP\n*---------------------------------------------------------------------*\n*---     PROCESS REPLACE=(YES/Y/NO/N) SPECIFICATION                ---*\n*---     REPLACE PRE-EXISTING DUPLICATE DURING LOAD                ---*\n*---     DEFAULT = NO                                              ---*\n*---------------------------------------------------------------------*\nREPLACE  DS    0H\n         #SETFLAG BIT=REPL,        SWITCH BIT NAME                     X\n               MSGVAL=REPLACE,     SUBSTITUTION VALUE FOR ERROR MSG    X\n               KWG=GREPL           KEYWORD-SUPPLIED FLAG BIT NAME\n         B     PL3                 RETURN TO OPERAND LOOP\n         SPACE 3\n*---------------------------------------------------------------------*\n*---     PROCESS CHKALIAS=(YES/Y/NO/N) SPECIFICATION               ---*\n*---     CHECK ARCHIVE ALIASES DURING LOAD/LOADT                   ---*\n*---     DEFAULT = NO                                              ---*\n*---------------------------------------------------------------------*\nCHKALIAS DS    0H\n         #SETFLAG BIT=LDARCHA,     SWITCH BIT NAME                     X\n               MSGVAL=CHKALIAS     SUBSTITUTION VALUE FOR ERROR MSG\n         B     PL3                 RETURN TO OPERAND LOOP\n         SPACE 3\n*---------------------------------------------------------------------*\n*---     PROCESS SHRTLST=(YES/Y/NO/N) SPECIFICATION                ---*\n*---     SHORT-FORM OF ARCHCOMP LISTING.                           ---*\n*---     DEFAULT = NO                                              ---*\n*---------------------------------------------------------------------*\nSHRTLST  DS    0H\n         #SETFLAG BIT=CMPSHRTL,    SWITCH BIT NAME                     X\n               MSGVAL=SHRTLST      SUBSTITUTION VALUE FOR ERROR MSG\n         B     PL3                 RETURN TO OPERAND LOOP\n         SPACE 3\n*---------------------------------------------------------------------*\n*---     PROCESS KEY= SPECIFICATION. THE VALUE MUST BE 1-8         ---*\n*---     CHARACTERS OF ANY VALUE THAT WILL PASS THROUGH THE        ---*\n*---     RPARSE ROUTINE.                                           ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nKEY      DS    0H\n         MVC   CURKEY,=CL8' '      BLANK THE FIELD\n         LH    R1,PRSKWLN          LOAD THE LENGTH\n         LTR   R1,R1               IS IT ZERO ??\n         BZ    PL3                 YES; SKIP THIS\n         CH    R1,=H'8'            TOO LONG ??\n         BNH   KEY1                NOPE; PROCESS IT ---\n         #PUT  KERR1               ERROR MESSAGE\n         #PUT  KERRIGN             'IGNORED' MESSAGE\n         XC    STRLEN,STRLEN       CLEAR THE WORK STRING\n         B     IGNORE              GO GET ANOTHER CONTROL STATEMENT\nKEY1     DS    0H\n         MVC   CURKEY,=CL8' '      CLEAR OUT THE OLD VALUE\n         BCTR  R1,R0               DECREMENT LENGTH FOR MVC GLITCH\n         L     R15,PRSKWLOC        POINT TO THE VALUE\n         EX    R1,KEY2             COPY VALUE TO RESULTS AREA\n         B     PL3                 AND RETURN TO OPERAND PARSE\nKEY2     MVC   CURKEY(1),0(R15)    'EX'ED COPY OF KEY VALUE\n         SPACE 3\n*---------------------------------------------------------------------*\n*---     PROCESS SEP= SPECIFICATION. THE VALUE MUST BE 1-8         ---*\n*---     CHARACTERS OF ANY VALUE THAT WILL PASS THROUGH THE        ---*\n*---     RPARSE ROUTINE.                                           ---*\n*---------------------------------------------------------------------*\nSEP      DS    0H\n         MVC   IOSEP(4),=X'47F0E000' INITIALIZE TO A NO-OP\n         LH    R1,PRSKWLN          LOAD THE LENGTH\n         LTR   R1,R1               IS IT ZERO ??\n         BZ    PL3                 YES; SKIP THIS\n         CH    R1,=H'8'            TOO LONG ??\n         BNH   SEP1                NOPE; PROCESS IT ---\n         #PUT  SEPERR1             ERROR MESSAGE\n         #PUT  KERRIGN             'IGNORED' MESSAGE\n         XC    STRLEN,STRLEN       CLEAR THE WORK STRING\n         B     IGNORE              GO GET ANOTHER CONTROL STATEMENT\nSEP1     DS    0H\n         MVC   SEPVAL,=CL8' '      CLEAR OUT THE OLD VALUE\n         BCTR  R1,R0               DECREMENT LENGTH FOR MVC GLITCH\n         L     R15,PRSKWLOC        POINT TO THE VALUE\n         EX    R1,SEP2             COPY VALUE TO RESULTS AREA\n         B     PL3                 AND RETURN TO OPERAND LOOP\nSEP2     MVC   SEPVAL(1),0(R15)    'EX'ED COPY OF SEP VALUE\n         EJECT\n*---------------------------------------------------------------------*\n*---     PROCESS DDN= SPECIFICATION. THE VALUE MUST BE 1-8         ---*\n*---     CHARACTERS OF ANY VALUE THAT WILL PASS THROUGH THE        ---*\n*---     RPARSE ROUTINE.  (ALSO MUST BE A VALID DDNAME, BUT I      ---*\n*---     DON'T CHECK FOR THAT.)                                    ---*\n*---------------------------------------------------------------------*\nDDNAME   DS    0H\n         USING PRSKWKW,R8\n         LH    R0,PRSKWLN          LOAD ITS LENGTH\n         LTR   R0,R0               WAS IT SUPPLIED ??\n         BZ    PL3                 NOPE ---\n         #IF   NVDYN,OFF,DDN1      WAS IT DYNAMIC ??\n         MVC   FREEDDN,NVSAMDD     COPY TO DYNAM PARM AREA\n         CALL  DYNAM,(ZERO,FREE,FREEPRMS),VL\n         #SET  NVDYN,OFF           TURN OFF THE SWITCH\nDDN1     DS    0H\n         LA    R3,NVSAMDD          RESULTS FIELD\n         LH    R1,PRSKWLN          LOAD THE LENGTH\n         LTR   R1,R1               IS IT ZERO ??\n         BZ    PL3                 YES; SKIP THIS\n         CH    R1,=H'8'            TOO LONG ??\n         BNH   DDN2                NOPE; PROCESS IT ---\n         #PUT  DDERR1              ERROR MESSAGE\n         #PUT  KERRIGN             'IGNORED' MESSAGE\n         XC    STRLEN,STRLEN       CLEAR THE WORK STRING\n         B     IGNORE              GO GET ANOTHER CONTROL STATEMENT\nDDN2     DS    0H\n         MVC   0(8,R3),=CL8' '     START WITH BLANKS\n         BCTR  R1,R0               DECREMENT LENGTH FOR MVC GLITCH\n         L     R15,PRSKWLOC        POINT TO THE VALUE\n         EX    R1,COPYDDN          COPY VALUE TO RESULTS AREA\n         OC    0(8,R3),=CL8' '     CAPS AND PADS\n         B     PL3                 RETURN TO OPERAND LOOP\n         EJECT\n*---------------------------------------------------------------------*\n*---     PROCESS VSAM1DD= SPECIFICATION. THE VALUE MUST BE 1-8     ---*\n*---     CHARACTERS OF ANY VALUE THAT WILL PASS THROUGH THE        ---*\n*---     RPARSE ROUTINE.  (ALSO MUST BE A VALID DDNAME, BUT I      ---*\n*---     DON'T CHECK FOR THAT.)                                    ---*\n*---------------------------------------------------------------------*\nDDNV1    DS    0H\n         USING PRSKWKW,R8\n         LH    R0,PRSKWLN          LOAD ITS LENGTH\n         LTR   R0,R0               WAS IT SUPPLIED ??\n         BZ    PL3                 NOPE ---\n         #IF   V1DYN,OFF,DV11      WAS IT DYNAMIC ??\n         MVC   FREEDDN,VSAM1DD     COPY TO DYNAM PARM AREA\n         CALL  DYNAM,(ZERO,FREE,FREEPRMS),VL\n         #SET  V1DYN,OFF           TURN OFF THE SWITCH\nDV11     DS    0H\n         LA    R3,VSAM1DD          RESULTS FIELD\n         LH    R1,PRSKWLN          LOAD THE LENGTH\n         LTR   R1,R1               IS IT ZERO ??\n         BZ    PL3                 YES; SKIP THIS\n         CH    R1,=H'8'            TOO LONG ??\n         BNH   DV12                NOPE; PROCESS IT ---\n         #PUT  DDERR1              ERROR MESSAGE\n         #PUT  KERRIGN             'IGNORED' MESSAGE\n         XC    STRLEN,STRLEN       CLEAR THE WORK STRING\n         B     IGNORE              GO GET ANOTHER CONTROL STATEMENT\nDV12     DS    0H\n         MVC   0(8,R3),=CL8' '     START WITH BLANKS\n         BCTR  R1,R0               DECREMENT LENGTH FOR MVC GLITCH\n         L     R15,PRSKWLOC        POINT TO THE VALUE\n         EX    R1,COPYDDN          COPY VALUE TO RESULTS AREA\n         OC    0(8,R3),=CL8' '     CAPS AND PADS\n         B     PL3                 RETURN TO OPERAND LOOP\n         EJECT\n*---------------------------------------------------------------------*\n*---     PROCESS VSAM2DD SPECIFICATION. THE VALUE MUST BE 1-8      ---*\n*---     CHARACTERS OF ANY VALUE THAT WILL PASS THROUGH THE        ---*\n*---     RPARSE ROUTINE.  (ALSO MUST BE A VALID DDNAME, BUT I      ---*\n*---     DON'T CHECK FOR THAT.)                                    ---*\n*---------------------------------------------------------------------*\nDDNV2    DS    0H\n         USING PRSKWKW,R8\n         LH    R0,PRSKWLN          LOAD ITS LENGTH\n         LTR   R0,R0               WAS IT SUPPLIED ??\n         BZ    PL3                 NOPE ---\n         #IF   V2DYN,OFF,DV21      WAS IT DYNAMIC ??\n         MVC   FREEDDN,VSAM2DD     COPY TO DYNAM PARM AREA\n         CALL  DYNAM,(ZERO,FREE,FREEPRMS),VL\n         #SET  V2DYN,OFF           TURN OFF THE SWITCH\nDV21     DS    0H\n         LA    R3,VSAM2DD          RESULTS FIELD\n         LH    R1,PRSKWLN          LOAD THE LENGTH\n         LTR   R1,R1               IS IT ZERO ??\n         BZ    PL3                 YES; SKIP THIS\n         CH    R1,=H'8'            TOO LONG ??\n         BNH   DV22                NOPE; PROCESS IT ---\n         #PUT  DDERR1              ERROR MESSAGE\n         #PUT  KERRIGN             'IGNORED' MESSAGE\n         XC    STRLEN,STRLEN       CLEAR THE WORK STRING\n         B     IGNORE              GO GET ANOTHER CONTROL STATEMENT\nDV22     DS    0H\n         MVC   0(8,R3),=CL8' '     START WITH BLANKS\n         BCTR  R1,R0               DECREMENT LENGTH FOR MVC GLITCH\n         L     R15,PRSKWLOC        POINT TO THE VALUE\n         EX    R1,COPYDDN          COPY VALUE TO RESULTS AREA\n         OC    0(8,R3),=CL8' '     CAPS AND PADS\n         B     PL3                 RETURN TO OPERAND LOOP\n         EJECT\n*---------------------------------------------------------------------*\n*---     PROCESS VSAM1DD SPECIFICATION. THE VALUE MUST BE 1-8      ---*\n*---     CHARACTERS OF ANY VALUE THAT WILL PASS THROUGH THE        ---*\n*---     RPARSE ROUTINE.  (ALSO MUST BE A VALID DDNAME, BUT I      ---*\n*---     DON'T CHECK FOR THAT.)                                    ---*\n*---------------------------------------------------------------------*\nEXPDD    DS    0H\n         USING PRSKWKW,R8\n         LH    R0,PRSKWLN          LOAD ITS LENGTH\n         LTR   R0,R0               WAS IT SUPPLIED ??\n         BZ    PL3                 NOPE ---\n         #IF   EXTDYN,OFF,EXPT1    WAS IT DYNAMIC ??\n         MVC   FREEDDN,EXPTPDD     COPY TO DYNAM PARM AREA\n         CALL  DYNAM,(ZERO,FREE,FREEPRMS),VL\n         #SET  EXTDYN,OFF          TURN OFF THE SWITCH\nEXPT1    DS    0H\n         LA    R3,EXPTPDD          RESULTS FIELD\n         LH    R1,PRSKWLN          LOAD THE LENGTH\n         LTR   R1,R1               IS IT ZERO ??\n         BZ    PL3                 YES; SKIP THIS\n         CH    R1,=H'8'            TOO LONG ??\n         BNH   EXPT2               NOPE; PROCESS IT ---\n         #PUT  DDERR1              ERROR MESSAGE\n         #PUT  KERRIGN             'IGNORED' MESSAGE\n         XC    STRLEN,STRLEN       CLEAR THE WORK STRING\n         B     IGNORE              GO GET ANOTHER CONTROL STATEMENT\nEXPT2    DS    0H\n         MVC   0(8,R3),=CL8' '     START WITH BLANKS\n         BCTR  R1,R0               DECREMENT LENGTH FOR MVC GLITCH\n         L     R15,PRSKWLOC        POINT TO THE VALUE\n         EX    R1,COPYDDN          COPY VALUE TO RESULTS AREA\n         OC    0(8,R3),=CL8' '     CAPS AND PADS\n         B     PL3                 RETURN TO OPERAND LOOP\nCOPYDDN  MVC   0(*-*,R3),0(R15)    'EX'ED COPY OF KEY VALUE\n         EJECT\n*---------------------------------------------------------------------*\n*---     PROCESS DSN= SPECIFICATION. THE VALUE MUST BE 1-44        ---*\n*---     CHARACTERS OF ANY VALUE THAT WILL PASS THROUGH THE        ---*\n*---     RPARSE ROUTINE.  (ALSO MUST BE A VALID DDNAME, BUT I      ---*\n*---     DON'T CHECK FOR THAT.)                                    ---*\n*---------------------------------------------------------------------*\nDSN      DS    0H\n         LH    R0,PRSKWLN          LOAD VALUE LENGTH\n         LTR   R0,R0               ANY VALUE ??\n         BZ    PL3                 NOPE ---\n         CLI   NVSAMDD,C' '        IS IT ALLOCATED ALREADY ??\n         BNH   DSN1                NOPE ---\n         #IF   NVDYN,OFF,DSN1\n         MVC   FREEDDN,NVSAMDD     COPY TO DYNAM PARM AREA\n         CALL  DYNAM,(ZERO,FREE,FREEPRMS),VL\n         #SET  NVDYN,OFF\nDSN1     DS    0H\n         LA    R3,NVSAMDD          RESULTS FIELD\n         #SET  NVDYN,ON\n         BAL   R5,DODSN            GO PROCESS DSNAME\n         LTR   R15,R15             DID IT ALLOCATE OK ??\n         BZ    PL3                 YES ---\n         #SET  NVDYN,OFF\n         #PUT  BADALLOC\n         #PUT  ALLOCIGN\n         XC    STRLEN,STRLEN       CLEAR THE WORK STRING\n         B     IGNORE              IGNORE THE STATEMENT\n*---------------------------------------------------------------------*\n*---     PROCESS VSAM1DSN= SPECIFICATION. THE VALUE MUST BE 1-44   ---*\n*---     CHARACTERS OF ANY VALUE THAT WILL PASS THROUGH THE        ---*\n*---     RPARSE ROUTINE.  (ALSO MUST BE A VALID DSNAME, BUT I      ---*\n*---     DON'T CHECK FOR THAT.)                                    ---*\n*---------------------------------------------------------------------*\nV1DSN    DS    0H\n         LH    R0,PRSKWLN          LOAD VALUE LENGTH\n         LTR   R0,R0               ANY VALUE ??\n         BZ    PL3                 NOPE ---\n         CLI   VSAM1DD,C' '        IS IT ALLOCATED ALREADY ??\n         BNH   V1DSN1              NOPE ---\n         #IF   V1DYN,OFF,V1DSN1\n         MVC   FREEDDN,VSAM1DD     COPY TO DYNAM PARM AREA\n         CALL  DYNAM,(ZERO,FREE,FREEPRMS),VL\n         #SET  V1DYN,OFF\nV1DSN1   DS    0H\n         #SET  V1DYN,ON\n         LA    R3,VSAM1DD          RESULTS FIELD\n         BAL   R5,DODSN            GO PROCESS DSNAME\n         LTR   R15,R15             DID IT ALLOCATE OK ??\n         BZ    PL3                 YES ---\n         #SET  V1DYN,OFF\n         #PUT  BADALLOC\n         #PUT  ALLOCIGN\n         XC    STRLEN,STRLEN       CLEAR THE WORK STRING\n         B     IGNORE              IGNORE THE STATEMENT\n*---------------------------------------------------------------------*\n*---     PROCESS EXPDSN= SPECIFICATION. THE VALUE MUST BE 1-44     ---*\n*---     CHARACTERS OF ANY VALUE THAT WILL PASS THROUGH THE        ---*\n*---     RPARSE ROUTINE.  (ALSO MUST BE A VALID DSNAME, BUT I      ---*\n*---     DON'T CHECK FOR THAT.)                                    ---*\n*---------------------------------------------------------------------*\nEXPDSN   DS    0H\n         LH    R0,PRSKWLN          LOAD VALUE LENGTH\n         LTR   R0,R0               ANY VALUE ??\n         BZ    PL3                 NOPE ---\n         #IF   EXTDYN,OFF,EXPDSN1  IS IT ALLOCATED ALREADY ??\n         MVC   FREEDDN,EXPTPDD     COPY TO DYNAM PARM AREA\n         CALL  DYNAM,(ZERO,FREE,FREEPRMS),VL\n         #SET  V1DYN,OFF\nEXPDSN1  DS    0H\n         #SET  V1DYN,ON\n         LA    R3,EXPTPDD          RESULTS FIELD\n         BAL   R5,DODSN            GO PROCESS DSNAME\n         LTR   R15,R15             DID IT ALLOCATE OK ??\n         BZ    PL3                 YES ---\n         #SET  V1DYN,OFF\n         #PUT  BADALLOC\n         #PUT  ALLOCIGN\n         XC    STRLEN,STRLEN       CLEAR THE WORK STRING\n         B     IGNORE              IGNORE THE STATEMENT\n*---------------------------------------------------------------------*\n*---     PROCESS VSAM2DSN= SPECIFICATION. THE VALUE MUST BE 1-44   ---*\n*---     CHARACTERS OF ANY VALUE THAT WILL PASS THROUGH THE        ---*\n*---     RPARSE ROUTINE.  (ALSO MUST BE A VALID DSNAME, BUT I      ---*\n*---     DON'T CHECK FOR THAT.)                                    ---*\n*---------------------------------------------------------------------*\nV2DSN    DS    0H\n         LH    R0,PRSKWLN          LOAD VALUE LENGTH\n         LTR   R0,R0               ANY VALUE ??\n         BZ    PL3                 NOPE ---\n         CLI   VSAM2DD,C' '        IS IT ALLOCATED ALREADY ??\n         BNH   V2DSN1              NOPE ---\n         #IF   V2DYN,OFF,V2DSN1\n         MVC   FREEDDN,VSAM2DD     COPY TO DYNAM PARM AREA\n         CALL  DYNAM,(ZERO,FREE,FREEPRMS),VL\n         #SET  V2DYN,OFF\nV2DSN1   DS    0H\n         #SET  V2DYN,ON\n         LA    R3,VSAM2DD          RESULTS FIELD\n         BAL   R5,DODSN            GO PROCESS DSNAME\n         LTR   R15,R15             DID IT ALLOCATE OK ??\n         BZ    PL3                 YES ---\n         #SET  V2DYN,OFF\n         #PUT  BADALLOC\n         #PUT  ALLOCIGN\n         XC    STRLEN,STRLEN       CLEAR THE WORK STRING\n         B     IGNORE              IGNORE THE STATEMENT\n         EJECT\n*---------------------------------------------------------------------*\n*---     LOCAL SUBROUTINE TO DYNAMICALLY ALLOCATE DATASETS         ---*\n*---------------------------------------------------------------------*\nDODSN    DS    0H\n         LH    R1,PRSKWLN          LOAD THE KEYWORD LENGTH\n         LR    R4,R3               COPY THE OUTPUT DDNAME POINTER\n         LA    R3,DYNDSN           FOR REUSE OF COPYDDN INSTR.\n         BCTR  R1,R0               DECREMENT LENGTH BY ONE\n         MVI   DYNDSN,C' '         SEED IN A BLANK\n         MVC   DYNDSN+1(45),DYNDSN CLEAR THE AREA\n         L     R15,PRSKWLOC        POINT TO THE DSNAME\n         EX    R1,COPYDDN          COPY THE DSNAME TO THE PARM AREA\n         LR    R3,R4               RESTORE THE OUTPUT DDNAME POINTER\n         CALL  DYNAM,(ZERO,ALLOC,INFAREA,PRMS),VL\n         LTR   R15,R15             DID IT ALLOCATE OK ??\n         BNZR  R5                  NOPE; ANALYZE AND PRINT ---\n         MVC   0(8,R3),DDNRET      COPY BACK THE DDNAME\n         LA    R0,NVSAMDD          IS THIS THE NON-VSAM FILE ??\n         CR    R3,R0                ???\n         BNER  R5                  NOPE; SKIP DSORG COPY\n         MVC   NVSDSORG,DSORGRET   COPY DSORG TO RETURN AREA\n         BR    R5                  AND RETURN TO MY CALLER\n*---------------------------------------------------------------------*\n*---     RETURN TO ARCHMAIN FOR PROCESSING.                        ---*\n*---------------------------------------------------------------------*\n*++++++++++++++++++++++++++++++++++\nENDSCAN  DS    0H\n         XC    STRLEN,STRLEN       CLEAR THE WORK STRING\n         CLC   VERB,=CL10'SET'     WAS IT THE 'SET' VERB ??\n         BE    P3                  YES; GO DO ANOTHER STATEMENT\n         LA    R15,0\nRETURN   DS    0H\n         LR    R1,R13\n         L     R13,4(,R13)\n         ST    R15,16(,R13)\n         L     R0,PRSWKL           LOAD AREA LENGTH\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         MVI   12(R13),255\n         BR    R14\nRET4     DS    0H\n         LA    R15,4\n         B     RETURN\n         EJECT\n*---------------------------------------------------------------------*\n*---     PROCESS THE CONTENTS OF THE 'ITEM=' KEYWORD. WE NEED TO  ----*\n*---     EXTRACT EACH VALUE AND PLACE IT IN THE APPROPRIATE FIELD ----*\n*---     OF THE ARCHIVER'S MAIN WORK AREA, FOR LATER REFERENCE BY ----*\n*---     THE VARIOUS PROCESSING ROUTINES OF THE ARCHIVER.  THIS   ----*\n*---     CODE IS GENERALLY FAIRLY STRAIGHTFORWARD AND             ----*\n*---     UNDERSTANDABLE.                                          ----*\n*---------------------------------------------------------------------*\nITEM     DS    0H\n         PUSH  USING\n         USING PRSPSLN,R8          AND BASE ITS DSECT\n         LA    R8,2(,R8)           POINT PAST THE HEADER\n         LA    R3,Q1               POINT TO OUTPUT AREA\n         LA    R2,4                LOAD QUALIFIER COUNT\nITEM1    DS    0H\n         ICM   R4,15,PRSPSLOC      LOAD POINTER TO THE VALUE\n         LH    R15,PRSPSLN         LOAD THE VALUE LENGTH\n         LTR   R15,R15             NULL VALUE ??\n         BZ    ITEM2               YES; SKIP THIS\n         BCTR  R15,R0\n         CH    R15,=H'9'           TOO LONG ??\n         BH    BADQUAL             YES ---\n         EX    R15,MOVEQ           AND COPY THE QUALIFIER\nITEM2    DS    0H\n         LA    R8,PRSPSBC(,R8)     BUMP TO NEXT PARSE PARM\n         LA    R3,10(,R3)          POINT TO NEXT OUTPUT AREA\n         BCT   R2,ITEM1            LOOP FOR FOUR QUALIFIERS\n*---------------------------------------------------------------------*\n*---     NUMERIC FIFTH QUALIFIER (VERSION NUMBER)                 ----*\n*---------------------------------------------------------------------*\n         #SET  VRS,OFF             SHOW VERSION, TO START WITH\n         ICM   R4,15,PRSPSLOC      LOAD POINTER TO THE VALUE\n         MVC   Q5,=XL4'00'         BLANK IT OUT\n         LH    R15,PRSPSLN         LOAD THE VALUE LENGTH\n         LTR   R15,R15             NULL VALUE ??\n         BZ    ITEM3               YES; SKIP THIS\n         BCTR  R15,R0              DECREMENT FOR MVC GLITCH\n         CH    R15,=H'9'           TOO LONG ??\n         BH    BADQUAL             YES ---\n         EX    R15,TEST#           ALL NUMERICS ??\n         BNZ   BADQUAL             NOPE ---\n         LA    R15,X'70'(,R15)     INSERT THE REST OF THE PACK LENGTH\n         #SET  VRS,ON              SHOW VERSION, TO START WITH\n         EX    R15,VERPACK         PACK THE VERSION NUMBER\n         CVB   R0,DWORK            INTO BINARY\n         STCM  R0,15,0(R3)         SAVE RESULT\n         XC    0(4,R3),=X'FFFFFFFF'  INVERT ALL BITS\nITEM3    DS    0H\n*---------------------------------------------------------------------*\n*---     ONE LAST LITTLE DETAIL. SEVERAL PROCESSES ARE DEPENDANT   ---*\n*---     ON KNOWING WHETHER THE NAME SUPPLIED IS A GENERIC OR      ---*\n*---     NOT. THEREFORE, WE USE THIS SLOPPY LITTLE PIECE OF CODE   ---*\n*---     TO SET THE VARIOUS 'QUALIFIER IS GENERIC' FLAG BITS.      ---*\n*---                                                               ---*\n*---     A SHORT DESCRIPTION OF GENERICS: A '*' IN ANY QUALIFIER   ---*\n*---     DENOTES THAT THE CHARACTER IN THE MATCHING POSITION OF A  ---*\n*---     QUALIFIER, AND ALL FOLLOWING CHARACTERS, ARE TO BE        ---*\n*---     CONSIDERED A MATCH IN ALL CASES.  ON THE OTHER HAND, A    ---*\n*---     '%' CHARACTER DENOTES A SINGLE CHARACTER, IN THE          ---*\n*---     MATCHING POSITION, THAT MAY BE ANYTHING AND STILL         ---*\n*---     CONSIDERED A MATCH.  IT'S ALL MODELED AFTER THE GENERIC   ---*\n*---     CHARACTERS IN RACF PROFILES.                              ---*\n*---------------------------------------------------------------------*\nGENCHK   DS    0H\n         #SET  GENM,OFF            START\n         #SET  GENG,OFF              WITH\n         #SET  GENSG,OFF               FLAGS\n         #SET  GENT,OFF                  OFF\n         LA    R5,Q1+9             POINT TO QUALIFIER END\n         LA    R4,1                LOAD BXLE INCREMENT\n         LA    R3,Q1               POINT TO QUALIFIER START\nGQ1      DS    0H\n         CLI   0(R3),C'*'          GENERIC TO END ??\n         BE    GQ3                 YES ---\n         CLI   0(R3),C'%'          GENERIC IN THIS CHARACTER ??\n         BNE   GQ2                 NOPE ---\n         #SET  GENM,ON             SET THE FLAG BIT\nGQ2      DS    0H\n         BXLE  R3,R4,GQ1           AND LOOP, SEARCHINGLY\n         B     GQ4                 DO THE NEXT ITEM ---\nGQ3      DS    0H\n         #SET  GENM,ON             SET THE FLAG BIT\nGQ3A     DS    0H\n         MVI   0(R3),C'%'          GENERIC CHARACTER\n         BXLE  R3,R4,GQ3A          FOR REST OF STRING\nGQ4      DS    0H\n         LA    R5,Q2+9             POINT TO QUALIFIER END\n         LA    R4,1                LOAD BXLE INCREMENT\n         LA    R3,Q2               POINT TO QUALIFIER START\nGQ5      DS    0H\n         CLI   0(R3),C'*'          GENERIC TO END ??\n         BE    GQ7                 YES ---\n         CLI   0(R3),C'%'          GENERIC IN THIS CHARACTER ??\n         BNE   GQ6                 NOPE ---\n         #SET  GENG,ON             SET THE FLAG BIT\nGQ6      DS    0H\n         BXLE  R3,R4,GQ5           AND LOOP, SEARCHINGLY\n         B     GQ8                 DO THE NEXT ITEM ---\nGQ7      DS    0H\n         #SET  GENG,ON             SET THE FLAG BIT\nGQ7A     DS    0H\n         MVI   0(R3),C'%'          GENERIC CHARACTER\n         BXLE  R3,R4,GQ7A          FOR REST OF STRING\nGQ8      DS    0H\n         LA    R5,Q3+9             POINT TO QUALIFIER END\n         LA    R4,1                LOAD BXLE INCREMENT\n         LA    R3,Q3               POINT TO QUALIFIER START\nGQ9      DS    0H\n         CLI   0(R3),C'*'          GENERIC TO END ??\n         BE    GQ11                YES ---\n         CLI   0(R3),C'%'          GENERIC IN THIS CHARACTER ??\n         BNE   GQ10                NOPE ---\n         #SET  GENSG,ON            SET THE FLAG BIT\nGQ10     DS    0H\n         BXLE  R3,R4,GQ9           AND LOOP, SEARCHINGLY\n         B     GQ12                DO THE NEXT ITEM ---\nGQ11     DS    0H\n         #SET  GENSG,ON            SET THE FLAG BIT\nGQ11A    DS    0H\n         MVI   0(R3),C'%'          GENERIC CHARACTER\n         BXLE  R3,R4,GQ11A         FOR REST OF STRING\nGQ12     DS    0H\n         LA    R5,Q4+9             POINT TO QUALIFIER END\n         LA    R4,1                LOAD BXLE INCREMENT\n         LA    R3,Q4               POINT TO QUALIFIER START\nGQ13     DS    0H\n         CLI   0(R3),C'*'          GENERIC TO END ??\n         BE    GQ15                YES ---\n         CLI   0(R3),C'%'          GENERIC IN THIS CHARACTER ??\n         BNE   GQ14                NOPE ---\n         #SET  GENT,ON             SET THE FLAG BIT\nGQ14     DS    0H\n         BXLE  R3,R4,GQ13          AND LOOP, SEARCHINGLY\n         B     GQ16                DO THE NEXT ITEM ---\nGQ15     DS    0H\n         #SET  GENT,ON             SET THE FLAG BIT\nGQ15A    DS    0H\n         MVI   0(R3),C'%'          GENERIC CHARACTER\n         BXLE  R3,R4,GQ15A         FOR REST OF STRING\nGQ16     DS    0H\n         B     PL3                 AND RETURN TO CALLER\n         POP   USING\n*---------------------------------------------------------------------*\n*---     THESE INSTRUCTIONS ARE SHARED BY ALL THE QUALIFIER SCAN  ----*\n*---     ROUTINES.  THEY ARE HERE FOR CONVENIENCE IN DEVELOPMENT. ----*\n*---------------------------------------------------------------------*\nVERPACK  PACK  DWORK,0(0,R4)       PACK OF VERSION NUMBER\nMOVEQ    MVC   0(0,R3),0(R4)\nTEST#    TRT   0(0,R4),NUMBERS     TEST FOR NUMERICS\n         EJECT\n*---------------------------------------------------------------------*\n*---     PROCESS THE CONTENTS OF THE 'COMPTO='/'NEWQ='/'ALIAS='   ----*\n*---     KEYWORD.  WE NEED TO EXTRACT EACH VALUE AND PLACE IT IN  ----*\n*---     THE APPROPRIATE FIELD OF THE ARCHIVER'S MAIN WORK AREA,  ----*\n*---     FOR LATER REFERENCE BY THE VARIOUS PROCESSING ROUTINES   ----*\n*---     OF THE ARCHIVER.  THIS CODE IS GENERALLY FAIRLY          ----*\n*---     STRAIGHTFORWARD AND UNDERSTANDABLE.                      ----*\n*---------------------------------------------------------------------*\nNITEM    DS    0H\n         PUSH  USING\n         USING PRSPSLN,R8          AND BASE ITS DSECT\n         LA    R8,2(,R8)           POINT PAST THE HEADER\n         LA    R3,QC1              POINT TO OUTPUT AREA\n         LA    R14,4               LOAD QUALIFIER COUNT\nNITEM1   DS    0H\n         ICM   R4,15,PRSPSLOC      LOAD POINTER TO THE VALUE\n         LH    R15,PRSPSLN         LOAD THE VALUE LENGTH\n         LTR   R15,R15             NULL VALUE ??\n         BZ    NITEM2              YES; SKIP THIS\n         BCTR  R15,R0\n         CH    R15,=H'9'           TOO LONG ??\n         BH    BADQUAL             YES ---\n         EX    R15,MOVEQ           AND COPY THE QUALIFIER\nNITEM2   DS    0H\n         LA    R8,PRSPSBC(,R8)     BUMP TO NEXT PARSE PARM\n         LA    R3,10(,R3)          POINT TO NEXT OUTPUT AREA\n         BCT   R14,NITEM1          LOOP FOR FOUR QUALIFIERS\n*---------------------------------------------------------------------*\n*---     NUMERIC FIFTH QUALIFIER (VERSION NUMBER)                 ----*\n*---------------------------------------------------------------------*\n         #SET  VRS,OFF             SHOW VERSION, TO START WITH\n         ICM   R4,15,PRSPSLOC      LOAD POINTER TO THE VALUE\n         MVC   0(4,R3),=XL4'00'    BLANK IT OUT\n         LH    R15,PRSPSLN         LOAD THE VALUE LENGTH\n         LTR   R15,R15             NULL VALUE ??\n         BZ    NITEM3              YES; SKIP THIS\n         BCTR  R15,R0              DECREMENT FOR MVC GLITCH\n         CH    R15,=H'9'           TOO LONG ??\n         BH    BADQUAL             YES ---\n         EX    R15,TEST#           ALL NUMERICS ??\n         BNZ   BADQUAL             NOPE ---\n         LA    R15,X'70'(,R15)     INSERT THE REST OF THE PACK LENGTH\n         #SET  VRS,ON              SHOW VERSION, TO START WITH\n         EX    R15,VERPACK         PACK THE VERSION NUMBER\n         CVB   R0,DWORK            INTO BINARY\n         STCM  R0,15,0(R3)         SAVE RESULT\n         XC    0(4,R3),=X'FFFFFFFF'  INVERT ALL BITS\nNITEM3   DS    0H\n*---------------------------------------------------------------------*\n*---     ONE LAST LITTLE DETAIL. SEVERAL PROCESSES ARE DEPENDANT   ---*\n*---     ON KNOWING WHETHER THE NAME SUPPLIED IS A GENERIC OR      ---*\n*---     NOT. THEREFORE, WE USE THIS SLOPPY LITTLE PIECE OF CODE   ---*\n*---     TO SET THE VARIOUS 'QUALIFIER IS GENERIC' FLAG BITS.      ---*\n*---                                                               ---*\n*---     A SHORT DESCRIPTION OF GENERICS: A '*' IN ANY QUALIFIER   ---*\n*---     DENOTES THAT THE CHARACTER IN THE MATCHING POSITION OF A  ---*\n*---     QUALIFIER, AND ALL FOLLOWING CHARACTERS, ARE TO BE        ---*\n*---     CONSIDERED A MATCH IN ALL CASES.  ON THE OTHER HAND, A    ---*\n*---     '%' CHARACTER DENOTES A SINGLE CHARACTER, IN THE          ---*\n*---     MATCHING POSITION, THAT MAY BE ANYTHING AND STILL         ---*\n*---     CONSIDERED A MATCH.  IT'S ALL MODELED AFTER THE GENERIC   ---*\n*---     CHARACTERS IN RACF PROFILES.                              ---*\n*---------------------------------------------------------------------*\n         #SET  NGENM,OFF           START\n         #SET  NGENG,OFF             WITH\n         #SET  NGENSG,OFF              FLAGS\n         #SET  NGENT,OFF                 OFF\n         LA    R5,QC1+9            POINT TO QUALIFIER END\n         LA    R4,1                LOAD BXLE INCREMENT\n         LA    R3,QC1              POINT TO QUALIFIER START\nNGQ1     DS    0H\n         CLI   0(R3),C'*'          GENERIC TO END ??\n         BE    NGQ3                YES ---\n         CLI   0(R3),C'%'          GENERIC IN THIS CHARACTER ??\n         BNE   NGQ2                NOPE ---\n         #SET  NGENM,ON            SET THE FLAG BIT\nNGQ2     DS    0H\n         BXLE  R3,R4,NGQ1          AND LOOP, SEARCHINGLY\n         B     NGQ4                DO THE NEXT ITEM ---\nNGQ3     DS    0H\n         #SET  NGENM,ON            SET THE FLAG BIT\nNGQ3A    DS    0H\n         MVI   0(R3),C'%'          GENERIC CHARACTER\n         BXLE  R3,R4,NGQ3A         FOR REST OF STRING\nNGQ4     DS    0H\n         LA    R5,QC2+9            POINT TO QUALIFIER END\n         LA    R4,1                LOAD BXLE INCREMENT\n         LA    R3,QC2              POINT TO QUALIFIER START\nNGQ5     DS    0H\n         CLI   0(R3),C'*'          GENERIC TO END ??\n         BE    NGQ7                YES ---\n         CLI   0(R3),C'%'          GENERIC IN THIS CHARACTER ??\n         BNE   NGQ6                NOPE ---\n         #SET  NGENG,ON            SET THE FLAG BIT\nNGQ6     DS    0H\n         BXLE  R3,R4,NGQ5          AND LOOP, SEARCHINGLY\n         B     NGQ8                DO THE NEXT ITEM ---\nNGQ7     DS    0H\n         #SET  NGENG,ON            SET THE FLAG BIT\nNGQ7A    DS    0H\n         MVI   0(R3),C'%'          GENERIC CHARACTER\n         BXLE  R3,R4,NGQ7A         FOR REST OF STRING\nNGQ8     DS    0H\n         LA    R5,QC3+9            POINT TO QUALIFIER END\n         LA    R4,1                LOAD BXLE INCREMENT\n         LA    R3,QC3              POINT TO QUALIFIER START\nNGQ9     DS    0H\n         CLI   0(R3),C'*'          GENERIC TO END ??\n         BE    NGQ11               YES ---\n         CLI   0(R3),C'%'          GENERIC IN THIS CHARACTER ??\n         BNE   NGQ10               NOPE ---\n         #SET  NGENSG,ON           SET THE FLAG BIT\nNGQ10    DS    0H\n         BXLE  R3,R4,NGQ9          AND LOOP, SEARCHINGLY\n         B     NGQ12               DO THE NEXT ITEM ---\nNGQ11    DS    0H\n         #SET  NGENSG,ON           SET THE FLAG BIT\nNGQ11A   DS    0H\n         MVI   0(R3),C'%'          GENERIC CHARACTER\n         BXLE  R3,R4,NGQ11A        FOR REST OF STRING\nNGQ12    DS    0H\n         LA    R5,QC4+9            POINT TO QUALIFIER END\n         LA    R4,1                LOAD BXLE INCREMENT\n         LA    R3,QC4              POINT TO QUALIFIER START\nNGQ13    DS    0H\n         CLI   0(R3),C'*'          GENERIC TO END ??\n         BE    NGQ15               YES ---\n         CLI   0(R3),C'%'          GENERIC IN THIS CHARACTER ??\n         BNE   NGQ14               NOPE ---\n         #SET  NGENT,ON            SET THE FLAG BIT\nNGQ14    DS    0H\n         BXLE  R3,R4,NGQ13         AND LOOP, SEARCHINGLY\n         B     NGQ16               DO THE NEXT ITEM ---\nNGQ15    DS    0H\n         #SET  NGENT,ON            SET THE FLAG BIT\nNGQ15A   DS    0H\n         MVI   0(R3),C'%'          GENERIC CHARACTER\n         BXLE  R3,R4,NGQ15A        FOR REST OF STRING\nNGQ16    DS    0H\n         B     PL3                 AND RETURN TO CALLER\n         POP   USING\nNUMBERS  DC    15X'11111111111111111111111111111111'\n         DC    X'00000000000000000000111111111111'\n*---------------------------------------------------------------------*\n*---     VARIOUS ERROR MESSAGES GENERATED HERE                     ---*\n*---------------------------------------------------------------------*\nERR1     DS    0H\n         #PUT  TRTER1              OUTPUT AN ERROR MESSAGE\n         XC    STRLEN,STRLEN       CLOBBER THE WORK STRING\n         B     IGNORE              AND LIST THE RESULT\nERR4     DS    0H\n         #PUT  TRTER2              OUTPUT AN ERROR MESSAGE\n         XC    STRLEN,STRLEN       CLOBBER THE WORK STRING\n         B     IGNORE              AND LIST THE RESULT\nERRC     DS    0H\n         #PUT  TRTER3              OUTPUT AN ERROR MESSAGE\n         XC    STRLEN,STRLEN       CLOBBER THE WORK STRING\n         B     IGNORE              AND LIST THE RESULT\nPRERR1   DS    0H\n         #PUT  PRSERR10\n         MVI   LINE,C' '           SEED IN A BLANK\n         MVC   LINE+1(120),LINE    FERTILIZE FOR A FOREST\n         MVC   LINE+2(12),VERB\n         #PUT  LINE\n         MVI   LINE,C' '           SEED IN A BLANK\n         MVC   LINE+1(120),LINE    FERTILIZE FOR A FOREST\n         MVC   LINE+1(15),0(R7)\n         #PUT  LINE\n         B     PRC0                AND LIST THE RESULT\nBADP1    DS    0H\n         #PUT  PRSERR10\n         MVI   LINE,C' '           SEED IN A BLANK\n         MVC   LINE+1(120),LINE    FERTILIZE FOR A FOREST\n         MVC   LINE+2(12),VERB\n         #PUT  LINE\n         MVI   LINE,C' '           SEED IN A BLANK\n         MVC   LINE+1(120),LINE    FERTILIZE FOR A FOREST\n         MVC   LINE+1(15),0(R7)\n         #PUT  LINE\n         B     PRC0                AND LIST THE RESULT\nPRC4     DS    0H\n         #PUT  PRSERR1\n         B     PRC0                AND LIST THE RESULT\nPRC8     DS    0H\n         #PUT  PRSERR2\n         B     PRC0                AND LIST THE RESULT\nPRC12    DS    0H\n         #PUT  PRSERR3\n         B     PRC0                AND LIST THE RESULT\nPRC16    DS    0H\n         #PUT  PRSERR4\n         B     PRC0                AND LIST THE RESULT\nPRC20    DS    0H\n         #PUT  PRSERR5\n         B     PRC0                AND LIST THE RESULT\nPRC24    DS    0H\n         LR    R15,R1              RE-COPY RETURN VALUE\n         MVI   LINE,C' '           SEED IN A BLANK\n         MVC   LINE+1(120),LINE\n         LR    R1,R0               COPY KEYWORD ADDRESS\n         SRL   R15,24\n         BCTR  R15,R0\n         EX    R15,MOVEKEY\n         #PUT  LINE\n         #PUT  PRSERR6\n         B     PRC0                AND LIST THE RESULT\nMOVEKEY  MVC   LINE+1(1),0(R1)\nPRC28    DS    0H\n         #PUT  PRSERR7\n         B     PRC0                AND LIST THE RESULT\nPRC32    DS    0H\n         #PUT  PRSERR8\n         B     PRC0                AND LIST THE RESULT\nPRC36    DS    0H\n         #PUT  PRSERR9\n         B     PRC0                AND LIST THE RESULT\nBADQUAL  DS    0H\n         MVI   LINE,C' '           SEED IN A BLANK\n         MVC   LINE+1(120),LINE    FERTILIZE FOR A FOREST\n         MVC   LINE+1(23),=C' *** INVALID VALUE --> '\n         LA    R3,LINE+24          POINT TO PRINT AREA\n         EX    R15,MOVEQ           COPY TO PRINT LINE\n         #PUT  LINE\n         MVI   LINE,C' '           SEED IN A BLANK\n         MVC   LINE+1(120),LINE    FERTILIZE FOR A FOREST\n         MVC   LINE+1(19),=C'STATEMENT IGNORED. '\n         #PUT  LINE\n         XC    STRLEN,STRLEN\n         B     IGNORE\nVBMSG    DC    CL80'INVALID CONTROL STATEMENT. OPERATION NOT KNOWN.'\nZERO     DC    F'0'\nALLOC    DC    CL8'ALLOCR'\nPRMS     DC    C' SHR    '\n         DC    C' DSN='\nDYNDSN   DC    CL46' '\n         DC    C' ; '\nFREE     DC    CL8'UNALLOC'\nFREEPRMS DC    C' DD='\nFREEDDN  DC    CL8' '\n         DC    C'  ; '\nINFAREA  DS    0F\nDDNRET   DC    CL8' '\nDSNRET   DC    CL44' '\nDSORGRET DC    X'0000'\nVOLRET   DC    CL6' '\nBLANKS   DC    CL12' '\nINCARD   DC    CL80' '\n         DC    X'FF'\nCOPYVERB MVC   VERB(1),0(R7)       COPY VERB TO RESULTS AREA\nVERBMSG  DC    CL48'  IS AN UNKNOWN FUNCTION. STATEMENT IGNORED.'\nBADALLOC DC    CL133'  ARCHPARS:  DYNAMIC ALLOC FAILED. SEE MSG LOG.'\nALLOCIGN DC    CL133'  ARCHPARS:  THE STATEMENT IS IGNORED.'\nIGNORED  DC    CL133'  ARCHPARS:  PARAMETER HAS BEEN IGNORED.'\nTRTER1   DC    CL133'  ARCHPARS:  UNABLE TO ISOLATE VERB.'\nTRTER2   DC    CL133'  ARCHPARS:  UNRECOGNIZABLE FUNCTION.'\nTRTER3   DC    CL133'  ARCHPARS:  INCOMPLETE CONTROL STATEMENT.'\nKERR1    DC    CL133'  ARCHPARS:  KEY= VALUE IS TOO LONG. 8-CHAR MAX.'\nDDERR1   DC    CL133'  ARCHPARS:  DDNAME IS TOO LONG. 8-CHAR MAX.'\nSEPERR1  DC    CL133'  ARCHPARS:  SEP= VALUE IS TOO LONG. 8-CHAR MAX.'\nKERRIGN  DC    CL133'  ARCHPARS:  STATEMENT HAS BEEN IGNORED.'\nPRSERR1  DC    CL133'  RPARSE:  SYNTAX ERROR  '\nPRSERR2  DC    CL133'  RPARSE:  POS. PARM FOUND AFTER FIRST KW PARM '\nPRSERR3  DC    CL133'  RPARSE:  MIS-MATCHED PARENTHESES             '\nPRSERR4  DC    CL133'  RPARSE:  MISSING = AFTER KEYWORD           '\nPRSERR5  DC    CL133'  RPARSE:  ZERO-LENGTH KWD/POS. PARM           '\nPRSERR6  DC    CL133'  RPARSE:  KEYWORD NOT FOUND IN KEYWORD LIST   '\nPRSERR7  DC    CL133'  RPARSE:  SUBLIST IMPROPERLY ENDED            '\nPRSERR8  DC    CL133'  RPARSE:  QUOTED STRING IMPROPERLY ENDED      '\nPRSERR9  DC    CL133'  RPARSE:  OPERANDS ARE NESTED TOO DEEP        '\nPRSERR10 DC    CL133'  ARCHPARS: UNABLE TO DECYPHER ACTION CODE     '\nTRMSCAN  DC    CL1' '\nPLRTAB   DC    A(ALIASES)          0\n         DC    A(BACK)             4\n         DC    A(ITEM)             8\n         DC    A(NITEM)            12\n         DC    A(DATA)             16\n         DC    A(DDNAME)           20\n         DC    A(DSN)              24\n         DC    A(EXPDD)            28\n         DC    A(EXPDSN)           32\n         DC    A(HEADER)           36\n         DC    A(HEX)              40\n         DC    A(ITEM)             44\n         DC    A(KEY)              48\n         DC    A(NITEM)            52\n         DC    A(NOTE)             56\n         DC    A(PANLIB)           60\n         DC    A(REPLACE)          64\n         DC    A(SEP)              68\n         DC    A(DDNV1)            72\n         DC    A(V1DSN)            76\n         DC    A(DDNV2)            80\n         DC    A(V2DSN)            84\n         DC    A(CHKALIAS)         88\n         DC    A(SHRTLST)          92\nKVBTAB   DS    0F\n         DC    CL12'ADDALIAS    ',A(OPLALIAS)\nKVBLEN   EQU   *-KVBTAB\n         DC    CL12'ALTALIAS    ',A(OPLALIAS)\n         DC    CL12'ADDNOTE     ',A(OPLADDN)\n         DC    CL12'ALTER       ',A(OPLRSPC)\n         DC    CL12'CLEAN       ',A(0) TAKES NO OPERANDS\n         DC    CL12'COMPARE     ',A(OPLCOMP)\n         DC    CL12'CONVERT     ',A(OPLCONV)\n         DC    CL12'COPY        ',A(OPLCOPY)\n         DC    CL12'DELALIAS    ',A(OPLALIAS)\n         DC    CL12'DELETE      ',A(OPLDEL)\n         DC    CL12'EXPORT      ',A(OPLEXP)\n         DC    CL12'IMPORT      ',A(OPLIMP)\n         DC    CL12'LFILE       ',A(OPLLLFVS)\n         DC    CL12'LFILET      ',A(OPLLFTP)\n         DC    CL12'LIST        ',A(OPLLIST)\n         DC    CL12'LISTT       ',A(OPLLISTT)\n         DC    CL12'LOAD        ',A(OPLLOAD)\n         DC    CL12'LOADT       ',A(OPLLOADT)\n         DC    CL12'RESPECIFY   ',A(OPLRSPC)\n         DC    CL12'SET         ',A(OPLSET)\nKVBLAST  EQU   *\n         DC    CL12'UNLOAD      ',A(OPLUNLD)\nPRSWKL   DC    A(ENDPRSWK-PRSWK)   WORK AREA LENGTH\nTRTX     TRT   0(0,R7),TTABX\nTRTY     TRT   0(0,R7),TTABY\nTTABX    DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'\n         DC    X'00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'\nTTABY    DC    X'00000000000000000000000000000000'\n         DC    X'00000000000000000000000000000000'\n         DC    X'00000000000000000000000000000000'\n         DC    X'00000000000000000000000000000000'\n         DC    X'FF000000000000000000000000000000'\n         DC    X'00000000000000000000000000000000'\n         DC    X'00000000000000000000000000000000'\n         DC    X'00000000000000000000000000000000'\n         DC    X'00000000000000000000000000000000'\n         DC    X'00000000000000000000000000000000'\n         DC    X'00000000000000000000000000000000'\n         DC    X'00000000000000000000000000000000'\n         DC    X'00000000000000000000000000000000'\n         DC    X'00000000000000000000000000000000'\n         DC    X'00000000000000000000000000000000'\n         DC    X'00000000000000000000000000000000'\n         LTORG\nOPLADDN  $PARSE DEFINE\n         $PARSE KEYWORD,KEYWD='ITEM',SUBLIST=ITEMS,RSV=44\n         $PARSE KEYWORD,KEYWD='VSAM1DD',RSV=72\n         $PARSE KEYWORD,KEYWD='VSAM1DSN',RSV=76\n         $PARSE KEYWORD,KEYWD='KEY',RSV=48\n         $PARSE KEYWORD,KEYWD='DDN',RSV=20\n         $PARSE KEYWORD,KEYWD='DSN',RSV=24\n         $PARSE END\nOPLSET   $PARSE DEFINE\n         $PARSE KEYWORD,KEYWD='DDN',RSV=20\n         $PARSE KEYWORD,KEYWD='DSN',RSV=24\n         $PARSE KEYWORD,KEYWD='EXPDD',RSV=28\n         $PARSE KEYWORD,KEYWD='EXPDSN',RSV=32\n         $PARSE KEYWORD,KEYWD='EXPTPDD',RSV=28\n         $PARSE KEYWORD,KEYWD='EXPTPDSN',RSV=32\n         $PARSE KEYWORD,KEYWD='VSAM1DD',RSV=72\n         $PARSE KEYWORD,KEYWD='VSAM1DSN',RSV=76\n         $PARSE KEYWORD,KEYWD='VSAM2DD',RSV=80\n         $PARSE KEYWORD,KEYWD='VSAM2DSN',RSV=84\n         $PARSE END\nOPLCOMP  $PARSE DEFINE\n         $PARSE KEYWORD,KEYWD='ITEM',SUBLIST=ITEMS,RSV=44\n         $PARSE KEYWORD,KEYWD='VSAM1DD',RSV=72\n         $PARSE KEYWORD,KEYWD='VSAM1DSN',RSV=76\n         $PARSE KEYWORD,KEYWD='VSAM2DD',RSV=80\n         $PARSE KEYWORD,KEYWD='VSAM2DSN',RSV=84\n         $PARSE KEYWORD,KEYWD='COMPTO',SUBLIST=ITEMN,RSV=52\n         $PARSE KEYWORD,KEYWD='ALIASES',RSV=00\n         $PARSE KEYWORD,KEYWD='SHRTLST',RSV=92\n         $PARSE END\nOPLCOPY  $PARSE DEFINE\n         $PARSE KEYWORD,KEYWD='ITEM',SUBLIST=ITEMS,RSV=44\n         $PARSE KEYWORD,KEYWD='VSAM1DD',RSV=72\n         $PARSE KEYWORD,KEYWD='VSAM1DSN',RSV=76\n         $PARSE KEYWORD,KEYWD='VSAM2DD',RSV=80\n         $PARSE KEYWORD,KEYWD='VSAM2DSN',RSV=84\n         $PARSE KEYWORD,KEYWD='ALIASES',RSV=00\n         $PARSE KEYWORD,KEYWD='CHKALIAS',RSV=88\n         $PARSE KEYWORD,KEYWD='REPLACE',RSV=64\n         $PARSE END\nOPLCONV  $PARSE DEFINE\n         $PARSE KEYWORD,KEYWD='ITEM',SUBLIST=ITEMS,RSV=44\n         $PARSE KEYWORD,KEYWD='VSAM1DD',RSV=72\n         $PARSE KEYWORD,KEYWD='VSAM1DSN',RSV=76\n         $PARSE KEYWORD,KEYWD='VSAM2DD',RSV=80\n         $PARSE KEYWORD,KEYWD='VSAM2DSN',RSV=84\n         $PARSE END\nOPLDEL   $PARSE DEFINE\n         $PARSE KEYWORD,KEYWD='ITEM',SUBLIST=ITEMS,RSV=44\n         $PARSE KEYWORD,KEYWD='VSAM1DD',RSV=72\n         $PARSE KEYWORD,KEYWD='VSAM1DSN',RSV=76\n         $PARSE KEYWORD,KEYWD='DATA',RSV=16\n         $PARSE KEYWORD,KEYWD='BACK',RSV=04\n         $PARSE KEYWORD,KEYWD='NOTE',RSV=56\n         $PARSE KEYWORD,KEYWD='ALIASES',RSV=00\n         $PARSE END\nOPLEXP   $PARSE DEFINE\n         $PARSE KEYWORD,KEYWD='ITEM',SUBLIST=ITEMS,RSV=44\n         $PARSE KEYWORD,KEYWD='VSAM1DD',RSV=72\n         $PARSE KEYWORD,KEYWD='VSAM1DSN',RSV=76\n         $PARSE KEYWORD,KEYWD='EXPDD',RSV=28\n         $PARSE KEYWORD,KEYWD='EXPDSN',RSV=32\n         $PARSE KEYWORD,KEYWD='EXPTPDD',RSV=28\n         $PARSE KEYWORD,KEYWD='EXPTPDSN',RSV=32\n         $PARSE KEYWORD,KEYWD='ALIASES',RSV=00\n         $PARSE END\nOPLIMP   $PARSE DEFINE\n         $PARSE KEYWORD,KEYWD='ITEM',SUBLIST=ITEMS,RSV=44\n         $PARSE KEYWORD,KEYWD='VSAM1DD',RSV=72\n         $PARSE KEYWORD,KEYWD='VSAM1DSN',RSV=76\n         $PARSE KEYWORD,KEYWD='EXPDD',RSV=28\n         $PARSE KEYWORD,KEYWD='EXPDSN',RSV=32\n         $PARSE KEYWORD,KEYWD='EXPTPDD',RSV=28\n         $PARSE KEYWORD,KEYWD='EXPTPDSN',RSV=32\n         $PARSE KEYWORD,KEYWD='REPLACE',RSV=64\n         $PARSE KEYWORD,KEYWD='ALIASES',RSV=00\n         $PARSE END\nOPLLIST  $PARSE DEFINE\n         $PARSE KEYWORD,KEYWD='ITEM',SUBLIST=ITEMS,RSV=44\n         $PARSE KEYWORD,KEYWD='VSAM1DD',RSV=72\n         $PARSE KEYWORD,KEYWD='VSAM1DSN',RSV=76\n         $PARSE KEYWORD,KEYWD='BACK',RSV=04\n         $PARSE KEYWORD,KEYWD='DATA',RSV=16\n         $PARSE KEYWORD,KEYWD='HEX',RSV=40\n         $PARSE KEYWORD,KEYWD='NOTE',RSV=56\n         $PARSE KEYWORD,KEYWD='ALIASES',RSV=00\n         $PARSE END\nOPLLISTT $PARSE DEFINE\n         $PARSE KEYWORD,KEYWD='ITEM',SUBLIST=ITEMS,RSV=44\n         $PARSE KEYWORD,KEYWD='EXPDD',RSV=28\n         $PARSE KEYWORD,KEYWD='EXPDSN',RSV=32\n         $PARSE KEYWORD,KEYWD='EXPTPDD',RSV=28\n         $PARSE KEYWORD,KEYWD='EXPTPDSN',RSV=32\n         $PARSE KEYWORD,KEYWD='DATA',RSV=16\n         $PARSE KEYWORD,KEYWD='BACK',RSV=04\n         $PARSE KEYWORD,KEYWD='HEX',RSV=40\n         $PARSE KEYWORD,KEYWD='NOTE',RSV=56\n         $PARSE KEYWORD,KEYWD='ALIASES',RSV=00\n         $PARSE END\nOPLLFTP $PARSE DEFINE\n         $PARSE KEYWORD,KEYWD='ITEM',SUBLIST=ITEMS,RSV=44\n         $PARSE KEYWORD,KEYWD='EXPDD',RSV=28\n         $PARSE KEYWORD,KEYWD='EXPDSN',RSV=32\n         $PARSE KEYWORD,KEYWD='EXPTPDD',RSV=28\n         $PARSE KEYWORD,KEYWD='EXPTPDSN',RSV=32\n         $PARSE END\nOPLLLFVS $PARSE DEFINE\n         $PARSE KEYWORD,KEYWD='ITEM',SUBLIST=ITEMS,RSV=44\n         $PARSE KEYWORD,KEYWD='VSAM1DD',RSV=28\n         $PARSE KEYWORD,KEYWD='VSAM1DSN',RSV=32\n         $PARSE KEYWORD,KEYWD='VSAM1DD',RSV=28\n         $PARSE KEYWORD,KEYWD='VSAM1DSN',RSV=32\n         $PARSE KEYWORD,KEYWD='ALIASES',RSV=00\n         $PARSE END\nOPLLOAD  $PARSE DEFINE\n         $PARSE KEYWORD,KEYWD='ALIASES',RSV=00\n         $PARSE KEYWORD,KEYWD='CHKALIAS',RSV=88\n         $PARSE KEYWORD,KEYWD='DDN',RSV=20\n         $PARSE KEYWORD,KEYWD='DSN',RSV=24\n         $PARSE KEYWORD,KEYWD='ITEM',SUBLIST=ITEMS,RSV=44\n         $PARSE KEYWORD,KEYWD='REPLACE',RSV=64\n         $PARSE KEYWORD,KEYWD='SEP',RSV=68\n         $PARSE KEYWORD,KEYWD='VSAM1DD',RSV=72\n         $PARSE KEYWORD,KEYWD='VSAM1DSN',RSV=76\n         $PARSE END\nOPLLOADT $PARSE DEFINE\n         $PARSE KEYWORD,KEYWD='ALIASES',RSV=00\n         $PARSE KEYWORD,KEYWD='CHKALIAS',RSV=88\n         $PARSE KEYWORD,KEYWD='DDN',RSV=20\n         $PARSE KEYWORD,KEYWD='DSN',RSV=24\n         $PARSE KEYWORD,KEYWD='EXPDD',RSV=28\n         $PARSE KEYWORD,KEYWD='EXPDSN',RSV=32\n         $PARSE KEYWORD,KEYWD='EXPTPDD',RSV=28\n         $PARSE KEYWORD,KEYWD='EXPTPDSN',RSV=32\n         $PARSE KEYWORD,KEYWD='ITEM',SUBLIST=ITEMS,RSV=44\n         $PARSE KEYWORD,KEYWD='REPLACE',RSV=64\n         $PARSE KEYWORD,KEYWD='SEP',RSV=68\n         $PARSE END\nOPLUNLD  $PARSE DEFINE\n         $PARSE KEYWORD,KEYWD='ITEM',SUBLIST=ITEMS,RSV=44\n         $PARSE KEYWORD,KEYWD='ALIASES',RSV=00\n         $PARSE KEYWORD,KEYWD='VSAM1DD',RSV=72\n         $PARSE KEYWORD,KEYWD='VSAM1DSN',RSV=76\n         $PARSE KEYWORD,KEYWD='REPLACE',RSV=64\n         $PARSE KEYWORD,KEYWD='DDN',RSV=20\n         $PARSE KEYWORD,KEYWD='DSN',RSV=24\n         $PARSE END\nOPLRSPC  $PARSE DEFINE\n         $PARSE KEYWORD,KEYWD='ITEM',SUBLIST=ITEMS,RSV=44\n         $PARSE KEYWORD,KEYWD='VSAM1DD',RSV=72\n         $PARSE KEYWORD,KEYWD='VSAM1DSN',RSV=76\n         $PARSE KEYWORD,KEYWD='NEW',SUBLIST=ITEMN,RSV=52\n         $PARSE END\nOPLALIAS $PARSE DEFINE\n         $PARSE KEYWORD,KEYWD='ITEM',SUBLIST=ITEMS,RSV=44\n         $PARSE KEYWORD,KEYWD='VSAM1DD',RSV=72\n         $PARSE KEYWORD,KEYWD='VSAM1DSN',RSV=76\n         $PARSE KEYWORD,KEYWD='ALIAS',SUBLIST=ITEMN,RSV=52\n         $PARSE END\nITEMS    $PARSE DEFINE\n         $PARSE POS\n         $PARSE POS\n         $PARSE POS\n         $PARSE POS\n         $PARSE POS\n         $PARSE END\nITEMN    $PARSE DEFINE\n         $PARSE POS\n         $PARSE POS\n         $PARSE POS\n         $PARSE POS\n         $PARSE POS\n         $PARSE END\n         DCBD  DSORG=QS\n         $PARSE DSECT\n         COPY  ##ARCHWK\nPRSWK    DSECT\nSAVEAREA DS    36F\nSTRLEN   DS    F\nWKSTR    DS    8CL256\nENDPRSWK DS    D\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHPRSC": {"ttr": 10497, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06\\x0c\\x00\\x00\\x01 \\x18o\\x01 \\x18o\\x10\\x11\\x00\\x94\\x00\\x94\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@'", "ispf": {"version": "06.12", "flags": 0, "createdate": "2020-07-04T00:00:00", "modifydate": "2020-07-04T10:11:00", "lines": 148, "newlines": 148, "modlines": 0, "user": "ARCHIVR"}, "text": "ARCHPRSC TITLE 'GENERAL SCAN ROUTINE FOR EXEC PARMS'\n*---------------------------------------------------------------------*\n*                                                                     *\n*         PROGRAM             ARCHPRSC                                *\n*         AUTHOR              ROB PRINS                               *\n*                                                                     *\n*         ATTRIBUTES:         RENT,REUS                               *\n*                                                                     *\n*         FUNCTION            SCAN THE EXEC PARAMETER                 *\n*                             EXAMPLE: PARM='KEYWORD=CONTENTS'        *\n*                             CALL PARMSCAN,(WORD1,WORD2)             *\n*                             WORD1 CONTAINS 'KEYWORD' (8 BYTES WITH  *\n*                             TRAILING BLANKS IF 'KEYWORD' IS SHORTER *\n*                             THAN 8 BYTES)                           *\n*                             AFTER THE CALL YOU RECEIVE IN WORD2     *\n*                             WICH HAVE A LENGTH OF 255 BYTES, THE    *\n*                             FOLLOWING INFORMATION                   *\n*                             2 BYTES LENGTH OF 'CONTENTS'            *\n*                             BYTES 3 TILL 255 'CONTENTS'             *\n*                             EX. PARM='ROB=CHARLIE'                  *\n*                             IN WORD1 YOU MUST SPECIFY 'ROB     '    *\n*                             YOU RECEIVE IN WORD2                    *\n*                             X'0007' IN THE FIRST 2 BYTES            *\n*                             AND 'CHARLIE' WITH 246 BLANKS IN WORD2  *\n*                             RETURNCODES: 00 IF PARM FOUND           *\n*                                          04 IF PARM NOT FOUND       *\n*                                                                     *\n*------------------------------------------ (C)-2020 SKYBIRD SYSTEMS -*\n         SPACE 3\nARCHPRSC CSECT\n         SAVE  (14,12),,*              SAVE REGISTERS\n         LR    R10,R15                 BASE REGISTER\n         USING ARCHPRSC,R10            GET ADDRESSABILITY\n         LR    R2,R1                   SAVE OUR PARM\n         GETMAIN RU,LV=72              OBTAIN SAVEAREA\n         LR    R4,R1                   SAVE IT'S ADDRESS\n         ST    R4,8(,R13)              FORWARD POINTER\n         ST    R13,4(,R4)              BACKWARD POINTER\n         L     R3,4(,R13)              SAVE AREA BEFORE SAVE MACRO\n*                                      (ARCHINIT)\n         L     R3,4(,R3)               POINT TO SA OF ARCHIVER\n         LR    R13,R4\n         L     R1,24(,R3)              PICKUP A(PARM) OF CALLING PROG.\n         LM    R3,R4,0(R2)             PICKUP OUR PARM\n         USING WKAREA,R4\n         L     R2,0(,R1)               PICKUP EXEC-PARM OF CALLER\n         LH    R5,0(,R2)               LENGTH OF EXEC PARM\n         LTR   R5,R5                   NO PARM IN EXEC-STMNT ?\n         BZ    ERROR                   ERROR IF YES\n         LA    R2,2(,R2)               SKIP LENGTH\n         XR    R6,R6                   FOR ACTUAL LENGTH OF 'KEYWORD'\n         LR    R7,R3                   SAVE ADDRESS 'KEYWORD'\nA001     EQU   *\n         CLI   0(R7),X'40'             TRAILING BLANK ?\n         BE    A003                    END OF KEYWORD IF YES\n         LA    R6,1(,R6)               COUNT IS COUNT+1\n         LA    R7,1(,R7)\n         C     R6,=F'8'                MAX LENGTH REACHED ?\n         BL    A001                    BRANCH IF NOT\n*\nA003     EQU   *\n         BCTR  R6,0                    MINUS 1 FOR EX INSTR\n*\nA005     EQU   *\n         EX    R6,COMPARE        COMPARE IF 'KEYWORD' IN EXEC-PARM\n         BE    PRMFOUND                BRANCH IF FOUND\nA005A    LA    R2,1(,R2)               NEXT CHAR IN EXEC-PARM\n         BCT   R5,A005                 TRY AGAIN\n         B     ERROR                   'KEYWORD' NOT FOUND\n*\nCOMPARE  CLC   0(0,R2),0(R3)           << EXECUTED >>\n*\nPRMFOUND EQU   *\n         LA    R2,0(R2,R6)\n         LA    R2,1(,R2)               EQUAL SIGN\n         CLI   0(R2),C'='              MUST BE A = SIGN\n         BE    A006                    YES PROCEED\n         BCTR  R2,R6                   RESET R2\n         SLR   R2,R6                           )RESET R2\n         B     A005A\nA006     SLR   R5,R6                   DECR WITH KEYWORD LENGTH -1\n         BCTR  R5,0                    DECR WITH KEYWORD LENGTH\n         XR    R7,R7                   FOR COUNT 'CONTENTS'\n         LA    R2,1(,R2)               SKIP EQUAL SIGN\n         BCTR  R5,0                    DECREASE LENGTH ('=' SIGN)\n         C     R5,=F'0'\n         BL    ERROR\n         LR    R3,R2                   SAVE BEGINADDRESS 'CONTENTS'\n*\nA007     EQU   *\n         LTR   R5,R5                   REGISTER 5 ALREADY ZERO\n         BZ    A009                    YES: PARM LENGTH IS 0\n         CLI   0(R2),C','              END OF 'CONTENTS'\n         BE    A009                    BRANCH IF SO\n         LA    R2,1(,R2)               NEXT CHAR 'CONTENTS'\n         LA    R7,1(,R7)               COUNT THAT CHARACTER\n         C     R7,=F'253'              MAX LENGTH ?\n         BNL   A009                    FORCE END IF >=253\n         BCT   R5,A007                 NEXT CHAR\n*\nA009     EQU   *\n         STH   R7,PARMLEN              LENGTH OF 'CONTENTS'\n         MVI   PARM,X'40'              CLEAR 'CONTENTS' FIELD\n         MVC   PARM+1(252),PARM\n         BCTR  R7,0                    FOR EX.\n         C     R7,=F'-1'               NEGATIVE ?\n         BE    END                     YES: SKIP MOVE\n         EX    R7,MOVE                 MOVE 'CONTENTS'\n         B     END\n*\nMOVE     MVC   PARM(0),0(R3)           *** EXECUTE ONLY ***\n*\nEND      EQU   *\n         SR    R3,R3                   ZERO RC\n         B     BACK\n*\nERROR    EQU   *\n         LA    R3,4                    'KEYWORD' NOT FOUND\n*\nBACK     EQU   *\n         LR    R2,R13                  PICKUP SAVE AREA TO BE FREED\n         L     R13,4(,R13)             CALLERS SAVE AREA\n         FREEMAIN RU,LV=72,A=(2)       FREE OUR SAVE AREA\n         LR    R15,R3                  RETURN CODE\n         RETURN (14,12),RC=(15)        RETURN\n         EJECT\n         LTORG ,\nWKAREA   DSECT\nPARMLEN  DS    CL2\nPARM     DS    CL253\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHRSPC": {"ttr": 10501, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00\\xc3\\x00\\xc3\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 195, "newlines": 195, "modlines": 0, "user": "ARCHIVR"}, "text": "RSPC     TITLE 'ARCHIVER --- RESPECIFY FUNCTION'\n*---------------------------------------------------------------------*\n*---     THIS IS THE ARCHIVER RESPECIFY FUNCTION.  IT ALLOWS THE   ---*\n*---     USER TO CHANGE THE QUALIFIER DATA ON ANY ITEM OR GROUP    ---*\n*---     OF ITEMS.  ITEM SELECT IS PROVIDED.                       ---*\n*---------------------------------------------------------------------*\nARCHRSPC CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n         USING ARCHRSPC,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             COPY ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHRSPC,R11        DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             COPY NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RECOPY BACK POINTER\n         L     R14,12(,R14)        RECOPY ORIG. REG 14\n         LA    R10,0(,R11)         COPY ORIGINAL BASE REGISTER\n         AH    R10,PASSIT-2        BUMP BY A BASE'S WORTH\n         USING ARCHRSPC+4096,R10   AND DECLARE IT\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         COPY #ARCBITS\n         XC    FCOUNT,FCOUNT       CLEAR FUNCTION RECORD COUNT\n         XC    MCNT,MCNT           AND MEMBER COUNT\n         MVC   VS1MODE,=CL8'OUTPUT' SET THE I/O MODE\n         LA    R1,VSAM1DD          LOAD THE PARM POINTER\n         LA    R0,0                AND THE 'OPEN' FLAG\n         CALL  ARCHVSOP            CALL THE 'OPEN' FUNCTION\n         LTR   R15,R15             OPEN OK ??\n         BNZ   ENDITALL            NOPE; CAN'T WORK\n         XC    MCNT,MCNT             COUNTERS\n         EJECT\n*---------------------------------------------------------------------*\n*---     HERE'S THE MEAT OF THE PROCESSING. THE BASIC PROCESS IS   ---*\n*---           THIS:                                               ---*\n*---                                                               ---*\n*---     1. USING THE CONTROL INFORMATION WE WERE GIVEN AND THE    ---*\n*---        INFORMATION WE'VE DEVELOPED, LOCATE THE HEADER RECORD  ---*\n*---        FOR THE FIRST MEMBER. WE'LL USE THE VS1BUF1 AREA FOR   ---*\n*---        HEADER/KEY CONSTRUCTION.                               ---*\n*---                                                               ---*\n*---     2. LOOP THROUGH THE HEADERS, LOOKING FOR ITEMS TO         ---*\n*---        PROCESS. EACH TIME WE GET A MATCH, SET UP AND CALL     ---*\n*---        THE ARCHALT SUBROUTINE.  IF WE'RE CREATING A DUPLICATE ---*\n*---        ITEM, SEND A MESSAGE AND CREATE THE NEXT HIGHER        ---*\n*---        VERSION NUMBER OF THE SAME ITEM.                       ---*\n*---                                                               ---*\n*---     3. WHEN WE'VE REACHED THE LAST HEADER, OR PROCESSED THE   ---*\n*---        ONLY ITEM GIVEN, EMIT MESSAGES AND COUNTS AND          ---*\n*---        RETURN TO ARCHMAIN.                                    ---*\n*---------------------------------------------------------------------*\n         L     R6,VS1BUF1          POINT TO THE VSAM BUFFER\n         USING REC,R6              BASE THE RECORD DSECT\n         XC    0(RECKLEN,R6),0(R6)    START AT THE BEGINNING !!\n         MVI   RECTT,#RTHDR        START WITH HEADER RECORDS\n         MODCB RPL=(*,RPL1),                                           X\n               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X\n               ACB=(*,ACB1),                                           X\n               ARG=(*,VS1BUF1),                                        X\n               AREA=(*,VS1BUF1),                                       X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)        POSITION TO CLUSTER START\n         L     R1,RPL1             COPY THE RPL ADDRESS\n         POINT RPL=(1)             GET TO IT\nNEXTHDR  DS    0H\n         L     R1,RPL1             COPY RPL ADDRESS\n         GET   RPL=(1)             AND READ THE NEXT HEADER\n         LTR   R15,R15             ANYTHING LEFT ??\n         BNZ   ENDITALL            NOPE; ALL DONE\n         SHOWCB RPL=(*,RPL1),                                          X\n               FIELDS=RECLEN,                                          X\n               AREA=(S,VS2LEN2),                                       X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        FETCH THE RECORD LENGTH\n         CLI   RECTT,#RTHDR        HEADER RECORD ??\n         BNE   ENDITALL            NOPE; ALL DONE ---\n         LA    R1,RECN             POINT TO THE HEADER\n         LA    R0,0                USE DEFAULT QUALIFIER DATA\n         CALL  ARCHKNAM            GO CHECK: DO WE PROCESS THIS ITEM ??\n         LTR   R15,R15             PASS THE CHECK ??\n         BNZ   NEXTHDR             NOPE ---\n         SPACE 3\n*---------------------------------------------------------------------*\n*---     AT THIS POINT, WE'VE DETERMINED THAT THIS ITEM NEEDS TO   ---*\n*---     BE ALTERED. NOW WE CHECK THE VERSION NUMBER.  IF WE'RE    ---*\n*---     NOT REPLACING A SIMILAR VERSION, WE WILL TRY TO WRITE     ---*\n*---     THIS HEADER.  EACH TIME WE GET A DUPLICATE RECORD         ---*\n*---     INDICATION FROM VSAM, WE'LL INCREMENT THE VERSION NUMBER  ---*\n*---     BY ONE AND TRY AGAIN.  THIS WILL DETERMINE THE MAJORITY   ---*\n*---     OF THE KEY FOR ALL SUBSEQUENT RECORDS IN THIS ITEM AS     ---*\n*---     WELL.  IF, ON THE OTHER HAND, WE'RE REPLACING ANY         ---*\n*---     DUPLICATE DATA, WE'LL SIMPLY CALL ARCHERAS TO REMOVE ANY  ---*\n*---     PRE-EXISTING ITEM OF A MATCHING KEY.                      ---*\n*---------------------------------------------------------------------*\n         MVC   BLDLAREA(44),RECN   COPY THE QUALIFIER DATA\n         #RESPEC ,                 MAKE THE CHANGES.\n         MODCB RPL=(*,RPL2),                                           X\n               OPTCD=(DIR,NUP,MVE),                                    X\n               AREA=(*,VS1BUF1),                                       X\n               AREALEN=(*,VS1LIM),                                     X\n               MF=(G,GENWK)\nPUTHDR   DS    0H\n         L     R1,RPL2             LOAD RPL ADDRESS\n         GET   RPL=(1)             SEE IF IT EXISTS ALREADY\n         LTR   R15,R15             FIND IT OK ??\n         BZ    DUPKEY              YES ---\n         TESTCB RPL=(*,RPL2),FDBK=16 RECORD NOT FOUND ??\n         BE    DONOTES             YES ---\n         L     R4,RPL2             LOAD RPL ADDRESS\n         ABEND 100,DUMP            AND DIE HORRIBLY\nDUPKEY   DS    0H\n         #IF   REPL,ON,DELEIT      DELETE FOR REPLACEMENT ??\n         ICM   R8,15,RECVER        LOAD THE VERSION NUMBER\n         BCTR  R8,R0               UP BY ONE\n         STCM  R8,15,RECVER        SET A NEW VALUE\n         B     PUTHDR              GO RETRY THE GET\nDELEIT   DS    0H\n         LR    R1,R6               LOAD THE BUFFER POINTER\n         CALL  ARCHERAS            DELETE THE DUPLICATE ITEM\n         B     PUTHDR              AND GO RETRY THE 'PUT'\nDONOTES  DS    0H\n         LA    R3,RECN             LOAD NEW KEY VALUE PTR\n         LA    R2,BLDLAREA         AND OLD KEY VALUE\n         CALL  ARCHALT,((2),(3)),MF=(E,CALLIST)\nDTDONE   DS    0H\n         L     R1,MCNT             LOAD MEMBER COUNT\n         LA    R1,1(,R1)           INCREMENT BY ONE\n         ST    R1,MCNT             SAVE UPDATED COUNT\n         MVC   RECN(44),BLDLAREA   RESTORE OLD KEY\n         LA    R1,RECTT            LOAD POINT TO OLD HEADER\n         CALL  ARCHERAS            REMOVE OLD COPY OF THE ITEM\n         #FORMAT RECTT,,INMSG\n         #PUT  LINE\n         L     R6,VS1BUF1          LOAD OUTPUT HEADER VALUES\n         #FORMAT RECTT,,OUTMSG\n         #PUT  LINE\n         #IF   GENM,ON,NEXTHDR     LOOP IF GENERIC NAME\n         #IF   GENG,ON,NEXTHDR     LOOP IF GENERIC GROUP\n         #IF   GENSG,ON,NEXTHDR    LOOP IF GENERIC SUBGROUP\n         #IF   GENT,ON,NEXTHDR     LOOP IF GENERIC TYPE\n         SPACE 3\nENDITALL DS    0H\n         #ERR  MSG=15\n         L     R0,MCNT             COPY MEMBER COUNT\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,MCMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\n         LA    R1,VSAM1DD          POINT TO THE DDNAME\n         LA    R0,4                SET 'CLOSE' REQUEST\n         CALL  ARCHVSOP            CALL THE VSAM 'CLOSE' ROUTINE\n         L     R13,4(,R13)         COPY BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ALWAYS RC = 0\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\n         TITLE 'CONSTANTS, DATA AND DSECTS '\n         LTORG\nINMSG    DC    AL1(INEND-INMSG1)\nINMSG1   DC    C' WAS ALTERED TO ---   '\nINEND    EQU   *\nOUTMSG   DC    AL1(OUTEND-OUTMSG1)\nOUTMSG1  DC    C' ON OUTPUT VSAM1 CLUSTER. '\nOUTEND   EQU   *\nMCMSG    DC    CL133' '\n         ORG   MCMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202120'\n         DC    C' TOTAL ITEM(S) PROCESSED.'\n         ORG\nMINREC   DC    A(RECSIZE)\n         COPY  #RECS\n         COPY  ##ARCHWK\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHTABS": {"ttr": 10505, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x08x\\x08x\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 2168, "newlines": 2168, "modlines": 0, "user": "ARCHIVR"}, "text": "TABS     TITLE 'ARCHTABS - COMPRESSION/COMPACTION/EXPANSION TABLES'\n*---------------------------------------------------------------------*\n*---     THIS CSECT CONTAINS ALL THE COMPRESSION, COMPACTION AND   ---*\n*---     EXPANSION TABLES USED BY THE ARCHIVER'S DATA COMPACTION   ---*\n*---     ROUTINES.  FOR DETAILED INFORMATION ON TABLE CONTENTS     ---*\n*---     AND FORMAT, REFER TO THE COMPACT AND EXPAND ROUTINES.     ---*\n*---------------------------------------------------------------------*\nARCHTABS CSECT\n         #STAMP BRANCH=N\n         ENTRY TBL60,EXP60,EXPOLD\n*---------------------------------------------------------------------*\n*---     THIS IS THE CURRENT COMPACTION TABLE.  ENTRY FORMAT IS    ---*\n*---           THIS:                                               ---*\n*---                                                               ---*\n*---           BYTE 1:  THE NUMBER OF BITS IN THE ENTRY THAT ARE   ---*\n*---                    RETAINED                                   ---*\n*---                                                               ---*\n*---           BYTES 2-4: THE ACTUAL BIT STRING THAT WILL BE USED  ---*\n*---                   TO REPRESENT THE CHARACTER IN THE           ---*\n*---                   COMPACTED STRING.                           ---*\n*---------------------------------------------------------------------*\nTBL60    DC    AL1(4),BL.24'010100000000000000000000' MM\n         DC    AL1(4),BL.24'110100000000000000000000' 00\n         DC    AL1(9),BL.24'011001011000000000000000' 01\n         DC    AL1(10),BL.24'110001000000000000000000' 02\n         DC    AL1(10),BL.24'010000111100000000000000' 03\n         DC    AL1(10),BL.24'101000100000000000000000' 04\n         DC    AL1(11),BL.24'111100111100000000000000' 05\n         DC    AL1(11),BL.24'101000100110000000000000' 06\n         DC    AL1(10),BL.24'001001010000000000000000' 07\n         DC    AL1(10),BL.24'010001110100000000000000' 08\n         DC    AL1(12),BL.24'110001101010000000000000' 09\n         DC    AL1(11),BL.24'000100011110000000000000' 0A\n         DC    AL1(13),BL.24'111101110110100000000000' 0B\n         DC    AL1(11),BL.24'110001101100000000000000' 0C\n         DC    AL1(11),BL.24'010001110010000000000000' 0D\n         DC    AL1(12),BL.24'011101000011000000000000' 0E\n         DC    AL1(12),BL.24'001100110000000000000000' 0F\n         DC    AL1(9),BL.24'101000111000000000000000' 10\n         DC    AL1(12),BL.24'011101011110000000000000' 11\n         DC    AL1(11),BL.24'010000110110000000000000' 12\n         DC    AL1(13),BL.24'111001010101100000000000' 13\n         DC    AL1(11),BL.24'000100111000000000000000' 14\n         DC    AL1(13),BL.24'011101001000100000000000' 15\n         DC    AL1(13),BL.24'111001010000000000000000' 16\n         DC    AL1(13),BL.24'101011000010100000000000' 17\n         DC    AL1(10),BL.24'001001011100000000000000' 18\n         DC    AL1(13),BL.24'111100110110100000000000' 19\n         DC    AL1(12),BL.24'001100110011000000000000' 1A\n         DC    AL1(11),BL.24'000100001110000000000000' 1B\n         DC    AL1(11),BL.24'001100010110000000000000' 1C\n         DC    AL1(13),BL.24'011101011111100000000000' 1D\n         DC    AL1(12),BL.24'001001010110000000000000' 1E\n         DC    AL1(12),BL.24'000100111010000000000000' 1F\n         DC    AL1(9),BL.24'000100010000000000000000' 20\n         DC    AL1(13),BL.24'101011001000000000000000' 21\n         DC    AL1(12),BL.24'010000111000000000000000' 22\n         DC    AL1(13),BL.24'001100110010000000000000' 23\n         DC    AL1(12),BL.24'101000110001000000000000' 24\n         DC    AL1(14),BL.24'111001010101010000000000' 25\n         DC    AL1(13),BL.24'010000110011100000000000' 26\n         DC    AL1(14),BL.24'110001101000110000000000' 27\n         DC    AL1(12),BL.24'101000110100000000000000' 28\n         DC    AL1(14),BL.24'011101011111000000000000' 29\n         DC    AL1(13),BL.24'001001010100100000000000' 2A\n         DC    AL1(14),BL.24'101011000010000000000000' 2B\n         DC    AL1(12),BL.24'011001010100000000000000' 2C\n         DC    AL1(14),BL.24'011101001000010000000000' 2D\n         DC    AL1(13),BL.24'000100011100000000000000' 2E\n         DC    AL1(13),BL.24'010000110000100000000000' 2F\n         DC    AL1(10),BL.24'011101000100000000000000' 30\n         DC    AL1(12),BL.24'110001101011000000000000' 31\n         DC    AL1(12),BL.24'011001010101000000000000' 32\n         DC    AL1(13),BL.24'111001010111100000000000' 33\n         DC    AL1(12),BL.24'101011000011000000000000' 34\n         DC    AL1(13),BL.24'001100010101100000000000' 35\n         DC    AL1(13),BL.24'101000110010100000000000' 36\n         DC    AL1(14),BL.24'111001010101000000000000' 37\n         DC    AL1(11),BL.24'101000100100000000000000' 38\n         DC    AL1(14),BL.24'101011001000110000000000' 39\n         DC    AL1(13),BL.24'001100110001000000000000' 3A\n         DC    AL1(14),BL.24'011101001001110000000000' 3B\n         DC    AL1(12),BL.24'010000110010000000000000' 3C\n         DC    AL1(14),BL.24'011101000010100000000000' 3D\n         DC    AL1(13),BL.24'001100110010100000000000' 3E\n         DC    AL1(14),BL.24'111001010001000000000000' 3F\n         DC    AL1(3),BL.24'100000000000000000000000' 40\n         DC    AL1(9),BL.24'001100111000000000000000' 41\n         DC    AL1(12),BL.24'010000111001000000000000' 42\n         DC    AL1(12),BL.24'010001110001000000000000' 43\n         DC    AL1(12),BL.24'111101110000000000000000' 44\n         DC    AL1(11),BL.24'011101000000000000000000' 45\n         DC    AL1(13),BL.24'101000110101000000000000' 46\n         DC    AL1(9),BL.24'110001001000000000000000' 47\n         DC    AL1(11),BL.24'011101011100000000000000' 48\n         DC    AL1(13),BL.24'011001010011000000000000' 49\n         DC    AL1(12),BL.24'000100111011000000000000' 4A\n         DC    AL1(8),BL.24'101011010000000000000000' 4B\n         DC    AL1(12),BL.24'111101110100000000000000' 4C\n         DC    AL1(8),BL.24'111100100000000000000000' 4D\n         DC    AL1(9),BL.24'111101111000000000000000' 4E\n         DC    AL1(12),BL.24'111001010110000000000000' 4F\n         DC    AL1(8),BL.24'010001100000000000000000' 50\n         DC    AL1(14),BL.24'010000110101000000000000' 51\n         DC    AL1(13),BL.24'000100011100100000000000' 52\n         DC    AL1(14),BL.24'010000110011010000000000' 53\n         DC    AL1(6),BL.24'111111000000000000000000' 54\n         DC    AL1(13),BL.24'011101000010000000000000' 55\n         DC    AL1(13),BL.24'001001010111100000000000' 56\n         DC    AL1(14),BL.24'010001110000010000000000' 57\n         DC    AL1(9),BL.24'011101010000000000000000' 58\n         DC    AL1(13),BL.24'101000110011000000000000' 59\n         DC    AL1(13),BL.24'111100110111000000000000' 5A\n         DC    AL1(10),BL.24'001001011000000000000000' 5B\n         DC    AL1(6),BL.24'000001000000000000000000' 5C\n         DC    AL1(8),BL.24'111101100000000000000000' 5D\n         DC    AL1(10),BL.24'101000101000000000000000' 5E\n         DC    AL1(13),BL.24'101000110110100000000000' 5F\n         DC    AL1(8),BL.24'110001010000000000000000' 60\n         DC    AL1(7),BL.24'001001100000000000000000' 61\n         DC    AL1(13),BL.24'011001010001000000000000' 62\n         DC    AL1(14),BL.24'011101000010110000000000' 63\n         DC    AL1(13),BL.24'111101110111100000000000' 64\n         DC    AL1(14),BL.24'001001010100010000000000' 65\n         DC    AL1(13),BL.24'010000110001000000000000' 66\n         DC    AL1(14),BL.24'011101001001000000000000' 67\n         DC    AL1(12),BL.24'001100010100000000000000' 68\n         DC    AL1(14),BL.24'001100110001100000000000' 69\n         DC    AL1(13),BL.24'010001110000100000000000' 6A\n         DC    AL1(6),BL.24'000000000000000000000000' 6B\n         DC    AL1(11),BL.24'011001010110000000000000' 6C\n         DC    AL1(12),BL.24'101011001011000000000000' 6D\n         DC    AL1(12),BL.24'101011001010000000000000' 6E\n         DC    AL1(12),BL.24'111101110011000000000000' 6F\n         DC    AL1(10),BL.24'101011000100000000000000' 70\n         DC    AL1(13),BL.24'001100010101000000000000' 71\n         DC    AL1(13),BL.24'111101110110000000000000' 72\n         DC    AL1(13),BL.24'011001010000000000000000' 73\n         DC    AL1(13),BL.24'111101110001000000000000' 74\n         DC    AL1(14),BL.24'011001010000100000000000' 75\n         DC    AL1(14),BL.24'111100110110000000000000' 76\n         DC    AL1(14),BL.24'111100110111100000000000' 77\n         DC    AL1(12),BL.24'101011001001000000000000' 78\n         DC    AL1(14),BL.24'001100110001110000000000' 79\n         DC    AL1(10),BL.24'101000101100000000000000' 7A\n         DC    AL1(11),BL.24'010000111010000000000000' 7B\n         DC    AL1(8),BL.24'001100000000000000000000' 7C\n         DC    AL1(7),BL.24'011000100000000000000000' 7D\n         DC    AL1(8),BL.24'011001000000000000000000' 7E\n         DC    AL1(11),BL.24'000100001010000000000000' 7F\n         DC    AL1(9),BL.24'010001111000000000000000' 80\n         DC    AL1(8),BL.24'001001000000000000000000' 81\n         DC    AL1(10),BL.24'001100110100000000000000' 82\n         DC    AL1(10),BL.24'111100110000000000000000' 83\n         DC    AL1(9),BL.24'010001000000000000000000' 84\n         DC    AL1(8),BL.24'110001110000000000000000' 85\n         DC    AL1(10),BL.24'011101011000000000000000' 86\n         DC    AL1(10),BL.24'000100111100000000000000' 87\n         DC    AL1(9),BL.24'010001001000000000000000' 88\n         DC    AL1(9),BL.24'111100011000000000000000' 89\n         DC    AL1(14),BL.24'111100110111110000000000' 8A\n         DC    AL1(14),BL.24'101000110110010000000000' 8B\n         DC    AL1(13),BL.24'110001101001000000000000' 8C\n         DC    AL1(14),BL.24'001001010111010000000000' 8D\n         DC    AL1(14),BL.24'111101110111000000000000' 8E\n         DC    AL1(14),BL.24'001001010101010000000000' 8F\n         DC    AL1(10),BL.24'001100010000000000000000' 90\n         DC    AL1(11),BL.24'111001010010000000000000' 91\n         DC    AL1(11),BL.24'111100111110000000000000' 92\n         DC    AL1(9),BL.24'001100011000000000000000' 93\n         DC    AL1(9),BL.24'000100110000000000000000' 94\n         DC    AL1(8),BL.24'000100100000000000000000' 95\n         DC    AL1(8),BL.24'001100100000000000000000' 96\n         DC    AL1(10),BL.24'011101001100000000000000' 97\n         DC    AL1(12),BL.24'111101110101000000000000' 98\n         DC    AL1(9),BL.24'110001100000000000000000' 99\n         DC    AL1(14),BL.24'110001101001110000000000' 9A\n         DC    AL1(14),BL.24'011001010000110000000000' 9B\n         DC    AL1(13),BL.24'101000110101100000000000' 9C\n         DC    AL1(15),BL.24'101011000010010000000000' 9D\n         DC    AL1(14),BL.24'011101001000000000000000' 9E\n         DC    AL1(15),BL.24'101011000010011000000000' 9F\n         DC    AL1(11),BL.24'110001101110000000000000' A0\n         DC    AL1(13),BL.24'010000110101100000000000' A1\n         DC    AL1(9),BL.24'111001011000000000000000' A2\n         DC    AL1(8),BL.24'010000100000000000000000' A3\n         DC    AL1(10),BL.24'110001000100000000000000' A4\n         DC    AL1(12),BL.24'111101110010000000000000' A5\n         DC    AL1(11),BL.24'011101001010000000000000' A6\n         DC    AL1(12),BL.24'011001010010000000000000' A7\n         DC    AL1(10),BL.24'000100011000000000000000' A8\n         DC    AL1(13),BL.24'000100011101000000000000' A9\n         DC    AL1(13),BL.24'011001010001100000000000' AA\n         DC    AL1(14),BL.24'001001010111000000000000' AB\n         DC    AL1(13),BL.24'101000110000000000000000' AC\n         DC    AL1(15),BL.24'111001010001011000000000' AD\n         DC    AL1(14),BL.24'011101011111010000000000' AE\n         DC    AL1(14),BL.24'000100001100000000000000' AF\n         DC    AL1(11),BL.24'101011000000000000000000' B0\n         DC    AL1(13),BL.24'010000110100000000000000' B1\n         DC    AL1(13),BL.24'101000110000100000000000' B2\n         DC    AL1(14),BL.24'110001101000100000000000' B3\n         DC    AL1(13),BL.24'111001010000100000000000' B4\n         DC    AL1(14),BL.24'101000110011100000000000' B5\n         DC    AL1(13),BL.24'000100011101100000000000' B6\n         DC    AL1(14),BL.24'011001010011110000000000' B7\n         DC    AL1(13),BL.24'111101110001100000000000' B8\n         DC    AL1(14),BL.24'010001110000000000000000' B9\n         DC    AL1(13),BL.24'000100001100100000000000' BA\n         DC    AL1(14),BL.24'101000110011110000000000' BB\n         DC    AL1(13),BL.24'110001101000000000000000' BC\n         DC    AL1(14),BL.24'010000110000010000000000' BD\n         DC    AL1(13),BL.24'010000110100100000000000' BE\n         DC    AL1(13),BL.24'101000110010000000000000' BF\n         DC    AL1(11),BL.24'111100110100000000000000' C0\n         DC    AL1(5),BL.24'001110000000000000000000' C1\n         DC    AL1(6),BL.24'000101000000000000000000' C2\n         DC    AL1(5),BL.24'001010000000000000000000' C3\n         DC    AL1(6),BL.24'111000000000000000000000' C4\n         DC    AL1(5),BL.24'110010000000000000000000' C5\n         DC    AL1(7),BL.24'111101000000000000000000' C6\n         DC    AL1(7),BL.24'011000000000000000000000' C7\n         DC    AL1(7),BL.24'011001100000000000000000' C8\n         DC    AL1(6),BL.24'111010000000000000000000' C9\n         DC    AL1(13),BL.24'010000110001100000000000' CA\n         DC    AL1(14),BL.24'101000110110000000000000' CB\n         DC    AL1(13),BL.24'111001010100100000000000' CC\n         DC    AL1(14),BL.24'011101001001100000000000' CD\n         DC    AL1(14),BL.24'111100110110010000000000' CE\n         DC    AL1(14),BL.24'010000110011000000000000' CF\n         DC    AL1(9),BL.24'000100000000000000000000' D0\n         DC    AL1(9),BL.24'111100010000000000000000' D1\n         DC    AL1(8),BL.24'101010000000000000000000' D2\n         DC    AL1(6),BL.24'110000000000000000000000' D3\n         DC    AL1(6),BL.24'001101000000000000000000' D4\n         DC    AL1(6),BL.24'111011000000000000000000' D5\n         DC    AL1(6),BL.24'111110000000000000000000' D6\n         DC    AL1(6),BL.24'011100000000000000000000' D7\n         DC    AL1(8),BL.24'111100000000000000000000' D8\n         DC    AL1(5),BL.24'010010000000000000000000' D9\n         DC    AL1(14),BL.24'101011001000100000000000' DA\n         DC    AL1(14),BL.24'010000110000000000000000' DB\n         DC    AL1(13),BL.24'111001010111000000000000' DC\n         DC    AL1(14),BL.24'011101001001010000000000' DD\n         DC    AL1(13),BL.24'001001010101100000000000' DE\n         DC    AL1(14),BL.24'001001010100000000000000' DF\n         DC    AL1(10),BL.24'101011001100000000000000' E0\n         DC    AL1(14),BL.24'010000110101010000000000' E1\n         DC    AL1(5),BL.24'011010000000000000000000' E2\n         DC    AL1(5),BL.24'011110000000000000000000' E3\n         DC    AL1(6),BL.24'001000000000000000000000' E4\n         DC    AL1(7),BL.24'010000000000000000000000' E5\n         DC    AL1(8),BL.24'010001010000000000000000' E6\n         DC    AL1(8),BL.24'101010010000000000000000' E7\n         DC    AL1(8),BL.24'111001000000000000000000' E8\n         DC    AL1(10),BL.24'111100111000000000000000' E9\n         DC    AL1(14),BL.24'001001010101000000000000' EA\n         DC    AL1(15),BL.24'011001010011101000000000' EB\n         DC    AL1(13),BL.24'111001010100000000000000' EC\n         DC    AL1(15),BL.24'011001010011100000000000' ED\n         DC    AL1(14),BL.24'111101110111010000000000' EE\n         DC    AL1(12),BL.24'101000110111000000000000' EF\n         DC    AL1(4),BL.24'101100000000000000000000' F0\n         DC    AL1(5),BL.24'000010000000000000000000' F1\n         DC    AL1(6),BL.24'101001000000000000000000' F2\n         DC    AL1(6),BL.24'000110000000000000000000' F3\n         DC    AL1(6),BL.24'000111000000000000000000' F4\n         DC    AL1(7),BL.24'111001100000000000000000' F5\n         DC    AL1(7),BL.24'101011100000000000000000' F6\n         DC    AL1(7),BL.24'101000000000000000000000' F7\n         DC    AL1(7),BL.24'101010100000000000000000' F8\n         DC    AL1(7),BL.24'011101100000000000000000' F9\n         DC    AL1(14),BL.24'110001101001100000000000' FA\n         DC    AL1(15),BL.24'111001010001010000000000' FB\n         DC    AL1(13),BL.24'111001010001100000000000' FC\n         DC    AL1(14),BL.24'000100001100010000000000' FD\n         DC    AL1(12),BL.24'000100001101000000000000' FE\n         DC    AL1(11),BL.24'000100001000000000000000' FF\n*---------------------------------------------------------------------*\n*---     THIS IS THE EXPANSION TABLE THAT CORRESPONDS TO THE       ---*\n*---     'CURRENT' COMPACTION TABLE.  BECAUSE OF THE WAY THAT THE  ---*\n*---     EXPANDER WORKS, THE TABLE IS MUCH LARGER AND CONTAINS     ---*\n*---     MANY DUPLICATED ENTRIES. HERE'S THE FORMAT:               ---*\n*---                                                               ---*\n*---     WORDS 1-32 ARE THE TABLE OF SHIFT AMOUNTS AND MASKS OF    ---*\n*---                BITS THAT ARE RETAINED DURING EACH STEP OF     ---*\n*---                THE EXPANSION.                                 ---*\n*---                                                               ---*\n*---     THE FOLLOWING TWO-BYTE ENTRIES ARE COMPOSED OF EITHER OF  ---*\n*---     TWO TYPES OF DATA.                                        ---*\n*---                                                               ---*\n*---     TYPE1:  THOSE ENTRIES THAT HAVE THE X'80' BIT ON ARE      ---*\n*---     DIRECT REPLACEMENT CHARACTERS.  THE LOW-ORDER 6 BITS OF   ---*\n*---     THE FIRST BYTE ARE A COUNT OF BITS TO BE REMOVED FROM     ---*\n*---     THE LEFT END OF THE COMPACTED STRING. THE SECOND BYTE IS  ---*\n*---     THE ACTUAL CHARACTER TO BE PLACED IN THE OUTPUT STRING.   ---*\n*---                                                               ---*\n*---     TYPE2:  THOSE BYTES ARE USED IN CONJUNCTION WITH THE      ---*\n*---     SHIFT VALUES TO INDEX INTO 'SUBTABLES', FOR THOSE         ---*\n*---     CHARACTERS THAT, WHEN COMPACTED, EXCEED 8 BITS.  WHAT     ---*\n*---     HAPPENS IS THIS: THE NUMBER OF BITS DEFINED IN THE        ---*\n*---     CURRENT SHIFT TABLE ARE REMOVED FROM THE LEFT END OF THE  ---*\n*---     STRING.  THE REMAINING BITS ARE USED TO INDEX INTO THE    ---*\n*---     'SUBTABLE'.  IF ANOTHER SUBTABLE REFERENCE IS FOUND, THE  ---*\n*---     APPROPRIATE SHIFT IS MADE AND WE START ALL OVER, ANOTHER  ---*\n*---     LEVEL DOWN IN THE EXPANSION TABLE.  TO REALLY GET A FEEL  ---*\n*---     OF HOW THIS ALL WORKS, YOU SHOULD BE LOOKING AT 'EXPAND'  ---*\n*---     AND WATCH HOW IT ITERATES.                                ---*\n*---------------------------------------------------------------------*\nEXP60    DC    F'8',B'00000000000000000000000011111111'\n         DC    F'3',B'00000000000000000000000000000111'\n         DC    F'4',B'00000000000000000000000000001111'\n         DC    F'4',B'00000000000000000000000000001111'\n         DC    F'3',B'00000000000000000000000000000111'\n         DC    11F'0,0'\n         DC    B'10000110',X'6B'\n         DC    B'10000110',X'6B'\n         DC    B'10000110',X'6B'\n         DC    B'10000110',X'6B'\n         DC    B'10000110',X'5C'\n         DC    B'10000110',X'5C'\n         DC    B'10000110',X'5C'\n         DC    B'10000110',X'5C'\n         DC    B'10000101',X'F1'\n         DC    B'10000101',X'F1'\n         DC    B'10000101',X'F1'\n         DC    B'10000101',X'F1'\n         DC    B'10000101',X'F1'\n         DC    B'10000101',X'F1'\n         DC    B'10000101',X'F1'\n         DC    B'10000101',X'F1'\n         DC    AL2(BB1-*) SUBTABLE REFERENCE\n         DC    AL2(BB2-*) SUBTABLE REFERENCE\n         DC    B'10001000',X'95'\n         DC    AL2(BB3-*) SUBTABLE REFERENCE\n         DC    B'10000110',X'C2'\n         DC    B'10000110',X'C2'\n         DC    B'10000110',X'C2'\n         DC    B'10000110',X'C2'\n         DC    B'10000110',X'F3'\n         DC    B'10000110',X'F3'\n         DC    B'10000110',X'F3'\n         DC    B'10000110',X'F3'\n         DC    B'10000110',X'F4'\n         DC    B'10000110',X'F4'\n         DC    B'10000110',X'F4'\n         DC    B'10000110',X'F4'\n         DC    B'10000110',X'E4'\n         DC    B'10000110',X'E4'\n         DC    B'10000110',X'E4'\n         DC    B'10000110',X'E4'\n         DC    B'10001000',X'81'\n         DC    AL2(BB4-*) SUBTABLE REFERENCE\n         DC    B'10000111',X'61'\n         DC    B'10000111',X'61'\n         DC    B'10000101',X'C3'\n         DC    B'10000101',X'C3'\n         DC    B'10000101',X'C3'\n         DC    B'10000101',X'C3'\n         DC    B'10000101',X'C3'\n         DC    B'10000101',X'C3'\n         DC    B'10000101',X'C3'\n         DC    B'10000101',X'C3'\n         DC    B'10001000',X'7C'\n         DC    AL2(BB5-*) SUBTABLE REFERENCE\n         DC    B'10001000',X'96'\n         DC    AL2(BB6-*) SUBTABLE REFERENCE\n         DC    B'10000110',X'D4'\n         DC    B'10000110',X'D4'\n         DC    B'10000110',X'D4'\n         DC    B'10000110',X'D4'\n         DC    B'10000101',X'C1'\n         DC    B'10000101',X'C1'\n         DC    B'10000101',X'C1'\n         DC    B'10000101',X'C1'\n         DC    B'10000101',X'C1'\n         DC    B'10000101',X'C1'\n         DC    B'10000101',X'C1'\n         DC    B'10000101',X'C1'\n         DC    B'10000111',X'E5'\n         DC    B'10000111',X'E5'\n         DC    B'10001000',X'A3'\n         DC    AL2(BB7-*) SUBTABLE REFERENCE\n         DC    AL2(BB8-*) SUBTABLE REFERENCE\n         DC    B'10001000',X'E6'\n         DC    B'10001000',X'50'\n         DC    AL2(BB9-*) SUBTABLE REFERENCE\n         DC    B'10000101',X'D9'\n         DC    B'10000101',X'D9'\n         DC    B'10000101',X'D9'\n         DC    B'10000101',X'D9'\n         DC    B'10000101',X'D9'\n         DC    B'10000101',X'D9'\n         DC    B'10000101',X'D9'\n         DC    B'10000101',X'D9'\n         DC    B'11000100',X'00' REPEATING STRING\n         DC    B'11000100',X'00' REPEATING STRING\n         DC    B'11000100',X'00' REPEATING STRING\n         DC    B'11000100',X'00' REPEATING STRING\n         DC    B'11000100',X'00' REPEATING STRING\n         DC    B'11000100',X'00' REPEATING STRING\n         DC    B'11000100',X'00' REPEATING STRING\n         DC    B'11000100',X'00' REPEATING STRING\n         DC    B'11000100',X'00' REPEATING STRING\n         DC    B'11000100',X'00' REPEATING STRING\n         DC    B'11000100',X'00' REPEATING STRING\n         DC    B'11000100',X'00' REPEATING STRING\n         DC    B'11000100',X'00' REPEATING STRING\n         DC    B'11000100',X'00' REPEATING STRING\n         DC    B'11000100',X'00' REPEATING STRING\n         DC    B'11000100',X'00' REPEATING STRING\n         DC    B'10000111',X'C7'\n         DC    B'10000111',X'C7'\n         DC    B'10000111',X'7D'\n         DC    B'10000111',X'7D'\n         DC    B'10001000',X'7E'\n         DC    AL2(BB10-*) SUBTABLE REFERENCE\n         DC    B'10000111',X'C8'\n         DC    B'10000111',X'C8'\n         DC    B'10000101',X'E2'\n         DC    B'10000101',X'E2'\n         DC    B'10000101',X'E2'\n         DC    B'10000101',X'E2'\n         DC    B'10000101',X'E2'\n         DC    B'10000101',X'E2'\n         DC    B'10000101',X'E2'\n         DC    B'10000101',X'E2'\n         DC    B'10000110',X'D7'\n         DC    B'10000110',X'D7'\n         DC    B'10000110',X'D7'\n         DC    B'10000110',X'D7'\n         DC    AL2(BB11-*) SUBTABLE REFERENCE\n         DC    AL2(BB12-*) SUBTABLE REFERENCE\n         DC    B'10000111',X'F9'\n         DC    B'10000111',X'F9'\n         DC    B'10000101',X'E3'\n         DC    B'10000101',X'E3'\n         DC    B'10000101',X'E3'\n         DC    B'10000101',X'E3'\n         DC    B'10000101',X'E3'\n         DC    B'10000101',X'E3'\n         DC    B'10000101',X'E3'\n         DC    B'10000101',X'E3'\n         DC    B'10000011',X'40'\n         DC    B'10000011',X'40'\n         DC    B'10000011',X'40'\n         DC    B'10000011',X'40'\n         DC    B'10000011',X'40'\n         DC    B'10000011',X'40'\n         DC    B'10000011',X'40'\n         DC    B'10000011',X'40'\n         DC    B'10000011',X'40'\n         DC    B'10000011',X'40'\n         DC    B'10000011',X'40'\n         DC    B'10000011',X'40'\n         DC    B'10000011',X'40'\n         DC    B'10000011',X'40'\n         DC    B'10000011',X'40'\n         DC    B'10000011',X'40'\n         DC    B'10000011',X'40'\n         DC    B'10000011',X'40'\n         DC    B'10000011',X'40'\n         DC    B'10000011',X'40'\n         DC    B'10000011',X'40'\n         DC    B'10000011',X'40'\n         DC    B'10000011',X'40'\n         DC    B'10000011',X'40'\n         DC    B'10000011',X'40'\n         DC    B'10000011',X'40'\n         DC    B'10000011',X'40'\n         DC    B'10000011',X'40'\n         DC    B'10000011',X'40'\n         DC    B'10000011',X'40'\n         DC    B'10000011',X'40'\n         DC    B'10000011',X'40'\n         DC    B'10000111',X'F7'\n         DC    B'10000111',X'F7'\n         DC    AL2(BB13-*) SUBTABLE REFERENCE\n         DC    AL2(BB14-*) SUBTABLE REFERENCE\n         DC    B'10000110',X'F2'\n         DC    B'10000110',X'F2'\n         DC    B'10000110',X'F2'\n         DC    B'10000110',X'F2'\n         DC    B'10001000',X'D2'\n         DC    B'10001000',X'E7'\n         DC    B'10000111',X'F8'\n         DC    B'10000111',X'F8'\n         DC    AL2(BB15-*) SUBTABLE REFERENCE\n         DC    B'10001000',X'4B'\n         DC    B'10000111',X'F6'\n         DC    B'10000111',X'F6'\n         DC    B'10000100',X'F0'\n         DC    B'10000100',X'F0'\n         DC    B'10000100',X'F0'\n         DC    B'10000100',X'F0'\n         DC    B'10000100',X'F0'\n         DC    B'10000100',X'F0'\n         DC    B'10000100',X'F0'\n         DC    B'10000100',X'F0'\n         DC    B'10000100',X'F0'\n         DC    B'10000100',X'F0'\n         DC    B'10000100',X'F0'\n         DC    B'10000100',X'F0'\n         DC    B'10000100',X'F0'\n         DC    B'10000100',X'F0'\n         DC    B'10000100',X'F0'\n         DC    B'10000100',X'F0'\n         DC    B'10000110',X'D3'\n         DC    B'10000110',X'D3'\n         DC    B'10000110',X'D3'\n         DC    B'10000110',X'D3'\n         DC    AL2(BB16-*) SUBTABLE REFERENCE\n         DC    B'10001000',X'60'\n         DC    AL2(BB17-*) SUBTABLE REFERENCE\n         DC    B'10001000',X'85'\n         DC    B'10000101',X'C5'\n         DC    B'10000101',X'C5'\n         DC    B'10000101',X'C5'\n         DC    B'10000101',X'C5'\n         DC    B'10000101',X'C5'\n         DC    B'10000101',X'C5'\n         DC    B'10000101',X'C5'\n         DC    B'10000101',X'C5'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000110',X'C4'\n         DC    B'10000110',X'C4'\n         DC    B'10000110',X'C4'\n         DC    B'10000110',X'C4'\n         DC    B'10001000',X'E8'\n         DC    AL2(BB18-*) SUBTABLE REFERENCE\n         DC    B'10000111',X'F5'\n         DC    B'10000111',X'F5'\n         DC    B'10000110',X'C9'\n         DC    B'10000110',X'C9'\n         DC    B'10000110',X'C9'\n         DC    B'10000110',X'C9'\n         DC    B'10000110',X'D5'\n         DC    B'10000110',X'D5'\n         DC    B'10000110',X'D5'\n         DC    B'10000110',X'D5'\n         DC    B'10001000',X'D8'\n         DC    AL2(BB19-*) SUBTABLE REFERENCE\n         DC    B'10001000',X'4D'\n         DC    AL2(BB20-*) SUBTABLE REFERENCE\n         DC    B'10000111',X'C6'\n         DC    B'10000111',X'C6'\n         DC    B'10001000',X'5D'\n         DC    AL2(BB21-*) SUBTABLE REFERENCE\n         DC    B'10000110',X'D6'\n         DC    B'10000110',X'D6'\n         DC    B'10000110',X'D6'\n         DC    B'10000110',X'D6'\n         DC    B'10000110',X'54'\n         DC    B'10000110',X'54'\n         DC    B'10000110',X'54'\n         DC    B'10000110',X'54'\nBB1      DC    B'10001001',X'D0'\n         DC    B'10001001',X'D0'\n         DC    B'10001001',X'D0'\n         DC    B'10001001',X'D0'\n         DC    B'10001011',X'FF'\n         DC    B'10001011',X'7F'\n         DC    AL2(BB22-*) SUBTABLE REFERENCE\n         DC    B'10001011',X'1B'\nBB2      DC    B'10001001',X'20'\n         DC    B'10001001',X'20'\n         DC    B'10001001',X'20'\n         DC    B'10001001',X'20'\n         DC    B'10001010',X'A8'\n         DC    B'10001010',X'A8'\n         DC    AL2(BB23-*) SUBTABLE REFERENCE\n         DC    B'10001011',X'0A'\nBB3      DC    B'10001001',X'94'\n         DC    B'10001001',X'94'\n         DC    B'10001001',X'94'\n         DC    B'10001001',X'94'\n         DC    B'10001011',X'14'\n         DC    AL2(BB24-*) SUBTABLE REFERENCE\n         DC    B'10001010',X'87'\n         DC    B'10001010',X'87'\nBB4      DC    B'10001010',X'07'\n         DC    B'10001010',X'07'\n         DC    AL2(BB25-*) SUBTABLE REFERENCE\n         DC    AL2(BB26-*) SUBTABLE REFERENCE\n         DC    B'10001010',X'5B'\n         DC    B'10001010',X'5B'\n         DC    B'10001010',X'18'\n         DC    B'10001010',X'18'\nBB5      DC    B'10001010',X'90'\n         DC    B'10001010',X'90'\n         DC    AL2(BB27-*) SUBTABLE REFERENCE\n         DC    B'10001011',X'1C'\n         DC    B'10001001',X'93'\n         DC    B'10001001',X'93'\n         DC    B'10001001',X'93'\n         DC    B'10001001',X'93'\nBB6      DC    AL2(BB28-*) SUBTABLE REFERENCE\n         DC    AL2(BB29-*) SUBTABLE REFERENCE\n         DC    B'10001010',X'82'\n         DC    B'10001010',X'82'\n         DC    B'10001001',X'41'\n         DC    B'10001001',X'41'\n         DC    B'10001001',X'41'\n         DC    B'10001001',X'41'\nBB7      DC    AL2(BB30-*) SUBTABLE REFERENCE\n         DC    AL2(BB31-*) SUBTABLE REFERENCE\n         DC    AL2(BB32-*) SUBTABLE REFERENCE\n         DC    B'10001011',X'12'\n         DC    AL2(BB33-*) SUBTABLE REFERENCE\n         DC    B'10001011',X'7B'\n         DC    B'10001010',X'03'\n         DC    B'10001010',X'03'\nBB8      DC    B'10001001',X'84'\n         DC    B'10001001',X'84'\n         DC    B'10001001',X'84'\n         DC    B'10001001',X'84'\n         DC    B'10001001',X'88'\n         DC    B'10001001',X'88'\n         DC    B'10001001',X'88'\n         DC    B'10001001',X'88'\nBB9      DC    AL2(BB34-*) SUBTABLE REFERENCE\n         DC    B'10001011',X'0D'\n         DC    B'10001010',X'08'\n         DC    B'10001010',X'08'\n         DC    B'10001001',X'80'\n         DC    B'10001001',X'80'\n         DC    B'10001001',X'80'\n         DC    B'10001001',X'80'\nBB10     DC    AL2(BB35-*) SUBTABLE REFERENCE\n         DC    AL2(BB36-*) SUBTABLE REFERENCE\n         DC    AL2(BB37-*) SUBTABLE REFERENCE\n         DC    B'10001011',X'6C'\n         DC    B'10001001',X'01'\n         DC    B'10001001',X'01'\n         DC    B'10001001',X'01'\n         DC    B'10001001',X'01'\nBB11     DC    B'10001011',X'45'\n         DC    AL2(BB38-*) SUBTABLE REFERENCE\n         DC    B'10001010',X'30'\n         DC    B'10001010',X'30'\n         DC    AL2(BB39-*) SUBTABLE REFERENCE\n         DC    B'10001011',X'A6'\n         DC    B'10001010',X'97'\n         DC    B'10001010',X'97'\nBB12     DC    B'10001001',X'58'\n         DC    B'10001001',X'58'\n         DC    B'10001001',X'58'\n         DC    B'10001001',X'58'\n         DC    B'10001010',X'86'\n         DC    B'10001010',X'86'\n         DC    B'10001011',X'48'\n         DC    AL2(BB40-*) SUBTABLE REFERENCE\nBB13     DC    B'10001010',X'04'\n         DC    B'10001010',X'04'\n         DC    B'10001011',X'38'\n         DC    B'10001011',X'06'\n         DC    B'10001010',X'5E'\n         DC    B'10001010',X'5E'\n         DC    B'10001010',X'7A'\n         DC    B'10001010',X'7A'\nBB14     DC    AL2(BB41-*) SUBTABLE REFERENCE\n         DC    AL2(BB42-*) SUBTABLE REFERENCE\n         DC    AL2(BB43-*) SUBTABLE REFERENCE\n         DC    AL2(BB44-*) SUBTABLE REFERENCE\n         DC    B'10001001',X'10'\n         DC    B'10001001',X'10'\n         DC    B'10001001',X'10'\n         DC    B'10001001',X'10'\nBB15     DC    B'10001011',X'B0'\n         DC    AL2(BB45-*) SUBTABLE REFERENCE\n         DC    B'10001010',X'70'\n         DC    B'10001010',X'70'\n         DC    AL2(BB46-*) SUBTABLE REFERENCE\n         DC    AL2(BB47-*) SUBTABLE REFERENCE\n         DC    B'10001010',X'E0'\n         DC    B'10001010',X'E0'\nBB16     DC    B'10001010',X'02'\n         DC    B'10001010',X'02'\n         DC    B'10001010',X'A4'\n         DC    B'10001010',X'A4'\n         DC    B'10001001',X'47'\n         DC    B'10001001',X'47'\n         DC    B'10001001',X'47'\n         DC    B'10001001',X'47'\nBB17     DC    B'10001001',X'99'\n         DC    B'10001001',X'99'\n         DC    B'10001001',X'99'\n         DC    B'10001001',X'99'\n         DC    AL2(BB48-*) SUBTABLE REFERENCE\n         DC    AL2(BB49-*) SUBTABLE REFERENCE\n         DC    B'10001011',X'0C'\n         DC    B'10001011',X'A0'\nBB18     DC    AL2(BB50-*) SUBTABLE REFERENCE\n         DC    B'10001011',X'91'\n         DC    AL2(BB51-*) SUBTABLE REFERENCE\n         DC    AL2(BB52-*) SUBTABLE REFERENCE\n         DC    B'10001001',X'A2'\n         DC    B'10001001',X'A2'\n         DC    B'10001001',X'A2'\n         DC    B'10001001',X'A2'\nBB19     DC    B'10001001',X'D1'\n         DC    B'10001001',X'D1'\n         DC    B'10001001',X'D1'\n         DC    B'10001001',X'D1'\n         DC    B'10001001',X'89'\n         DC    B'10001001',X'89'\n         DC    B'10001001',X'89'\n         DC    B'10001001',X'89'\nBB20     DC    B'10001010',X'83'\n         DC    B'10001010',X'83'\n         DC    B'10001011',X'C0'\n         DC    AL2(BB53-*) SUBTABLE REFERENCE\n         DC    B'10001010',X'E9'\n         DC    B'10001010',X'E9'\n         DC    B'10001011',X'05'\n         DC    B'10001011',X'92'\nBB21     DC    AL2(BB54-*) SUBTABLE REFERENCE\n         DC    AL2(BB55-*) SUBTABLE REFERENCE\n         DC    AL2(BB56-*) SUBTABLE REFERENCE\n         DC    AL2(BB57-*) SUBTABLE REFERENCE\n         DC    B'10001001',X'4E'\n         DC    B'10001001',X'4E'\n         DC    B'10001001',X'4E'\n         DC    B'10001001',X'4E'\nBB22     DC    B'10001110',X'AF'\n         DC    B'10001110',X'AF'\n         DC    B'10001110',X'FD'\n         DC    B'10001110',X'FD'\n         DC    B'10001101',X'BA'\n         DC    B'10001101',X'BA'\n         DC    B'10001101',X'BA'\n         DC    B'10001101',X'BA'\n         DC    B'10001100',X'FE'\n         DC    B'10001100',X'FE'\n         DC    B'10001100',X'FE'\n         DC    B'10001100',X'FE'\n         DC    B'10001100',X'FE'\n         DC    B'10001100',X'FE'\n         DC    B'10001100',X'FE'\n         DC    B'10001100',X'FE'\nBB23     DC    B'10001101',X'2E'\n         DC    B'10001101',X'2E'\n         DC    B'10001101',X'2E'\n         DC    B'10001101',X'2E'\n         DC    B'10001101',X'52'\n         DC    B'10001101',X'52'\n         DC    B'10001101',X'52'\n         DC    B'10001101',X'52'\n         DC    B'10001101',X'A9'\n         DC    B'10001101',X'A9'\n         DC    B'10001101',X'A9'\n         DC    B'10001101',X'A9'\n         DC    B'10001101',X'B6'\n         DC    B'10001101',X'B6'\n         DC    B'10001101',X'B6'\n         DC    B'10001101',X'B6'\nBB24     DC    B'10001100',X'1F'\n         DC    B'10001100',X'1F'\n         DC    B'10001100',X'1F'\n         DC    B'10001100',X'1F'\n         DC    B'10001100',X'1F'\n         DC    B'10001100',X'1F'\n         DC    B'10001100',X'1F'\n         DC    B'10001100',X'1F'\n         DC    B'10001100',X'4A'\n         DC    B'10001100',X'4A'\n         DC    B'10001100',X'4A'\n         DC    B'10001100',X'4A'\n         DC    B'10001100',X'4A'\n         DC    B'10001100',X'4A'\n         DC    B'10001100',X'4A'\n         DC    B'10001100',X'4A'\nBB25     DC    B'10001110',X'DF'\n         DC    B'10001110',X'DF'\n         DC    B'10001110',X'65'\n         DC    B'10001110',X'65'\n         DC    B'10001101',X'2A'\n         DC    B'10001101',X'2A'\n         DC    B'10001101',X'2A'\n         DC    B'10001101',X'2A'\n         DC    B'10001110',X'EA'\n         DC    B'10001110',X'EA'\n         DC    B'10001110',X'8F'\n         DC    B'10001110',X'8F'\n         DC    B'10001101',X'DE'\n         DC    B'10001101',X'DE'\n         DC    B'10001101',X'DE'\n         DC    B'10001101',X'DE'\nBB26     DC    B'10001100',X'1E'\n         DC    B'10001100',X'1E'\n         DC    B'10001100',X'1E'\n         DC    B'10001100',X'1E'\n         DC    B'10001100',X'1E'\n         DC    B'10001100',X'1E'\n         DC    B'10001100',X'1E'\n         DC    B'10001100',X'1E'\n         DC    B'10001110',X'AB'\n         DC    B'10001110',X'AB'\n         DC    B'10001110',X'8D'\n         DC    B'10001110',X'8D'\n         DC    B'10001101',X'56'\n         DC    B'10001101',X'56'\n         DC    B'10001101',X'56'\n         DC    B'10001101',X'56'\nBB27     DC    B'10001100',X'68'\n         DC    B'10001100',X'68'\n         DC    B'10001100',X'68'\n         DC    B'10001100',X'68'\n         DC    B'10001100',X'68'\n         DC    B'10001100',X'68'\n         DC    B'10001100',X'68'\n         DC    B'10001100',X'68'\n         DC    B'10001101',X'71'\n         DC    B'10001101',X'71'\n         DC    B'10001101',X'71'\n         DC    B'10001101',X'71'\n         DC    B'10001101',X'35'\n         DC    B'10001101',X'35'\n         DC    B'10001101',X'35'\n         DC    B'10001101',X'35'\nBB28     DC    B'10001100',X'0F'\n         DC    B'10001100',X'0F'\n         DC    B'10001100',X'0F'\n         DC    B'10001100',X'0F'\n         DC    B'10001100',X'0F'\n         DC    B'10001100',X'0F'\n         DC    B'10001100',X'0F'\n         DC    B'10001100',X'0F'\n         DC    B'10001101',X'3A'\n         DC    B'10001101',X'3A'\n         DC    B'10001101',X'3A'\n         DC    B'10001101',X'3A'\n         DC    B'10001110',X'69'\n         DC    B'10001110',X'69'\n         DC    B'10001110',X'79'\n         DC    B'10001110',X'79'\nBB29     DC    B'10001101',X'23'\n         DC    B'10001101',X'23'\n         DC    B'10001101',X'23'\n         DC    B'10001101',X'23'\n         DC    B'10001101',X'3E'\n         DC    B'10001101',X'3E'\n         DC    B'10001101',X'3E'\n         DC    B'10001101',X'3E'\n         DC    B'10001100',X'1A'\n         DC    B'10001100',X'1A'\n         DC    B'10001100',X'1A'\n         DC    B'10001100',X'1A'\n         DC    B'10001100',X'1A'\n         DC    B'10001100',X'1A'\n         DC    B'10001100',X'1A'\n         DC    B'10001100',X'1A'\nBB30     DC    B'10001110',X'DB'\n         DC    B'10001110',X'DB'\n         DC    B'10001110',X'BD'\n         DC    B'10001110',X'BD'\n         DC    B'10001101',X'2F'\n         DC    B'10001101',X'2F'\n         DC    B'10001101',X'2F'\n         DC    B'10001101',X'2F'\n         DC    B'10001101',X'66'\n         DC    B'10001101',X'66'\n         DC    B'10001101',X'66'\n         DC    B'10001101',X'66'\n         DC    B'10001101',X'CA'\n         DC    B'10001101',X'CA'\n         DC    B'10001101',X'CA'\n         DC    B'10001101',X'CA'\nBB31     DC    B'10001100',X'3C'\n         DC    B'10001100',X'3C'\n         DC    B'10001100',X'3C'\n         DC    B'10001100',X'3C'\n         DC    B'10001100',X'3C'\n         DC    B'10001100',X'3C'\n         DC    B'10001100',X'3C'\n         DC    B'10001100',X'3C'\n         DC    B'10001110',X'CF'\n         DC    B'10001110',X'CF'\n         DC    B'10001110',X'53'\n         DC    B'10001110',X'53'\n         DC    B'10001101',X'26'\n         DC    B'10001101',X'26'\n         DC    B'10001101',X'26'\n         DC    B'10001101',X'26'\nBB32     DC    B'10001101',X'B1'\n         DC    B'10001101',X'B1'\n         DC    B'10001101',X'B1'\n         DC    B'10001101',X'B1'\n         DC    B'10001101',X'BE'\n         DC    B'10001101',X'BE'\n         DC    B'10001101',X'BE'\n         DC    B'10001101',X'BE'\n         DC    B'10001110',X'51'\n         DC    B'10001110',X'51'\n         DC    B'10001110',X'E1'\n         DC    B'10001110',X'E1'\n         DC    B'10001101',X'A1'\n         DC    B'10001101',X'A1'\n         DC    B'10001101',X'A1'\n         DC    B'10001101',X'A1'\nBB33     DC    B'10001100',X'22'\n         DC    B'10001100',X'22'\n         DC    B'10001100',X'22'\n         DC    B'10001100',X'22'\n         DC    B'10001100',X'22'\n         DC    B'10001100',X'22'\n         DC    B'10001100',X'22'\n         DC    B'10001100',X'22'\n         DC    B'10001100',X'42'\n         DC    B'10001100',X'42'\n         DC    B'10001100',X'42'\n         DC    B'10001100',X'42'\n         DC    B'10001100',X'42'\n         DC    B'10001100',X'42'\n         DC    B'10001100',X'42'\n         DC    B'10001100',X'42'\nBB34     DC    B'10001110',X'B9'\n         DC    B'10001110',X'B9'\n         DC    B'10001110',X'57'\n         DC    B'10001110',X'57'\n         DC    B'10001101',X'6A'\n         DC    B'10001101',X'6A'\n         DC    B'10001101',X'6A'\n         DC    B'10001101',X'6A'\n         DC    B'10001100',X'43'\n         DC    B'10001100',X'43'\n         DC    B'10001100',X'43'\n         DC    B'10001100',X'43'\n         DC    B'10001100',X'43'\n         DC    B'10001100',X'43'\n         DC    B'10001100',X'43'\n         DC    B'10001100',X'43'\nBB35     DC    B'10001101',X'73'\n         DC    B'10001101',X'73'\n         DC    B'10001101',X'73'\n         DC    B'10001101',X'73'\n         DC    B'10001110',X'75'\n         DC    B'10001110',X'75'\n         DC    B'10001110',X'9B'\n         DC    B'10001110',X'9B'\n         DC    B'10001101',X'62'\n         DC    B'10001101',X'62'\n         DC    B'10001101',X'62'\n         DC    B'10001101',X'62'\n         DC    B'10001101',X'AA'\n         DC    B'10001101',X'AA'\n         DC    B'10001101',X'AA'\n         DC    B'10001101',X'AA'\nBB36     DC    B'10001100',X'A7'\n         DC    B'10001100',X'A7'\n         DC    B'10001100',X'A7'\n         DC    B'10001100',X'A7'\n         DC    B'10001100',X'A7'\n         DC    B'10001100',X'A7'\n         DC    B'10001100',X'A7'\n         DC    B'10001100',X'A7'\n         DC    B'10001101',X'49'\n         DC    B'10001101',X'49'\n         DC    B'10001101',X'49'\n         DC    B'10001101',X'49'\n         DC    B'10001111',X'ED'\n         DC    B'10001111',X'EB'\n         DC    B'10001110',X'B7'\n         DC    B'10001110',X'B7'\nBB37     DC    B'10001100',X'2C'\n         DC    B'10001100',X'2C'\n         DC    B'10001100',X'2C'\n         DC    B'10001100',X'2C'\n         DC    B'10001100',X'2C'\n         DC    B'10001100',X'2C'\n         DC    B'10001100',X'2C'\n         DC    B'10001100',X'2C'\n         DC    B'10001100',X'32'\n         DC    B'10001100',X'32'\n         DC    B'10001100',X'32'\n         DC    B'10001100',X'32'\n         DC    B'10001100',X'32'\n         DC    B'10001100',X'32'\n         DC    B'10001100',X'32'\n         DC    B'10001100',X'32'\nBB38     DC    B'10001101',X'55'\n         DC    B'10001101',X'55'\n         DC    B'10001101',X'55'\n         DC    B'10001101',X'55'\n         DC    B'10001110',X'3D'\n         DC    B'10001110',X'3D'\n         DC    B'10001110',X'63'\n         DC    B'10001110',X'63'\n         DC    B'10001100',X'0E'\n         DC    B'10001100',X'0E'\n         DC    B'10001100',X'0E'\n         DC    B'10001100',X'0E'\n         DC    B'10001100',X'0E'\n         DC    B'10001100',X'0E'\n         DC    B'10001100',X'0E'\n         DC    B'10001100',X'0E'\nBB39     DC    B'10001110',X'9E'\n         DC    B'10001110',X'9E'\n         DC    B'10001110',X'2D'\n         DC    B'10001110',X'2D'\n         DC    B'10001101',X'15'\n         DC    B'10001101',X'15'\n         DC    B'10001101',X'15'\n         DC    B'10001101',X'15'\n         DC    B'10001110',X'67'\n         DC    B'10001110',X'67'\n         DC    B'10001110',X'DD'\n         DC    B'10001110',X'DD'\n         DC    B'10001110',X'CD'\n         DC    B'10001110',X'CD'\n         DC    B'10001110',X'3B'\n         DC    B'10001110',X'3B'\nBB40     DC    B'10001100',X'11'\n         DC    B'10001100',X'11'\n         DC    B'10001100',X'11'\n         DC    B'10001100',X'11'\n         DC    B'10001100',X'11'\n         DC    B'10001100',X'11'\n         DC    B'10001100',X'11'\n         DC    B'10001100',X'11'\n         DC    B'10001110',X'29'\n         DC    B'10001110',X'29'\n         DC    B'10001110',X'AE'\n         DC    B'10001110',X'AE'\n         DC    B'10001101',X'1D'\n         DC    B'10001101',X'1D'\n         DC    B'10001101',X'1D'\n         DC    B'10001101',X'1D'\nBB41     DC    B'10001101',X'AC'\n         DC    B'10001101',X'AC'\n         DC    B'10001101',X'AC'\n         DC    B'10001101',X'AC'\n         DC    B'10001101',X'B2'\n         DC    B'10001101',X'B2'\n         DC    B'10001101',X'B2'\n         DC    B'10001101',X'B2'\n         DC    B'10001100',X'24'\n         DC    B'10001100',X'24'\n         DC    B'10001100',X'24'\n         DC    B'10001100',X'24'\n         DC    B'10001100',X'24'\n         DC    B'10001100',X'24'\n         DC    B'10001100',X'24'\n         DC    B'10001100',X'24'\nBB42     DC    B'10001101',X'BF'\n         DC    B'10001101',X'BF'\n         DC    B'10001101',X'BF'\n         DC    B'10001101',X'BF'\n         DC    B'10001101',X'36'\n         DC    B'10001101',X'36'\n         DC    B'10001101',X'36'\n         DC    B'10001101',X'36'\n         DC    B'10001101',X'59'\n         DC    B'10001101',X'59'\n         DC    B'10001101',X'59'\n         DC    B'10001101',X'59'\n         DC    B'10001110',X'B5'\n         DC    B'10001110',X'B5'\n         DC    B'10001110',X'BB'\n         DC    B'10001110',X'BB'\nBB43     DC    B'10001100',X'28'\n         DC    B'10001100',X'28'\n         DC    B'10001100',X'28'\n         DC    B'10001100',X'28'\n         DC    B'10001100',X'28'\n         DC    B'10001100',X'28'\n         DC    B'10001100',X'28'\n         DC    B'10001100',X'28'\n         DC    B'10001101',X'46'\n         DC    B'10001101',X'46'\n         DC    B'10001101',X'46'\n         DC    B'10001101',X'46'\n         DC    B'10001101',X'9C'\n         DC    B'10001101',X'9C'\n         DC    B'10001101',X'9C'\n         DC    B'10001101',X'9C'\nBB44     DC    B'10001110',X'CB'\n         DC    B'10001110',X'CB'\n         DC    B'10001110',X'8B'\n         DC    B'10001110',X'8B'\n         DC    B'10001101',X'5F'\n         DC    B'10001101',X'5F'\n         DC    B'10001101',X'5F'\n         DC    B'10001101',X'5F'\n         DC    B'10001100',X'EF'\n         DC    B'10001100',X'EF'\n         DC    B'10001100',X'EF'\n         DC    B'10001100',X'EF'\n         DC    B'10001100',X'EF'\n         DC    B'10001100',X'EF'\n         DC    B'10001100',X'EF'\n         DC    B'10001100',X'EF'\nBB45     DC    B'10001110',X'2B'\n         DC    B'10001110',X'2B'\n         DC    B'10001111',X'9D'\n         DC    B'10001111',X'9F'\n         DC    B'10001101',X'17'\n         DC    B'10001101',X'17'\n         DC    B'10001101',X'17'\n         DC    B'10001101',X'17'\n         DC    B'10001100',X'34'\n         DC    B'10001100',X'34'\n         DC    B'10001100',X'34'\n         DC    B'10001100',X'34'\n         DC    B'10001100',X'34'\n         DC    B'10001100',X'34'\n         DC    B'10001100',X'34'\n         DC    B'10001100',X'34'\nBB46     DC    B'10001101',X'21'\n         DC    B'10001101',X'21'\n         DC    B'10001101',X'21'\n         DC    B'10001101',X'21'\n         DC    B'10001110',X'DA'\n         DC    B'10001110',X'DA'\n         DC    B'10001110',X'39'\n         DC    B'10001110',X'39'\n         DC    B'10001100',X'78'\n         DC    B'10001100',X'78'\n         DC    B'10001100',X'78'\n         DC    B'10001100',X'78'\n         DC    B'10001100',X'78'\n         DC    B'10001100',X'78'\n         DC    B'10001100',X'78'\n         DC    B'10001100',X'78'\nBB47     DC    B'10001100',X'6E'\n         DC    B'10001100',X'6E'\n         DC    B'10001100',X'6E'\n         DC    B'10001100',X'6E'\n         DC    B'10001100',X'6E'\n         DC    B'10001100',X'6E'\n         DC    B'10001100',X'6E'\n         DC    B'10001100',X'6E'\n         DC    B'10001100',X'6D'\n         DC    B'10001100',X'6D'\n         DC    B'10001100',X'6D'\n         DC    B'10001100',X'6D'\n         DC    B'10001100',X'6D'\n         DC    B'10001100',X'6D'\n         DC    B'10001100',X'6D'\n         DC    B'10001100',X'6D'\nBB48     DC    B'10001101',X'BC'\n         DC    B'10001101',X'BC'\n         DC    B'10001101',X'BC'\n         DC    B'10001101',X'BC'\n         DC    B'10001110',X'B3'\n         DC    B'10001110',X'B3'\n         DC    B'10001110',X'27'\n         DC    B'10001110',X'27'\n         DC    B'10001101',X'8C'\n         DC    B'10001101',X'8C'\n         DC    B'10001101',X'8C'\n         DC    B'10001101',X'8C'\n         DC    B'10001110',X'FA'\n         DC    B'10001110',X'FA'\n         DC    B'10001110',X'9A'\n         DC    B'10001110',X'9A'\nBB49     DC    B'10001100',X'09'\n         DC    B'10001100',X'09'\n         DC    B'10001100',X'09'\n         DC    B'10001100',X'09'\n         DC    B'10001100',X'09'\n         DC    B'10001100',X'09'\n         DC    B'10001100',X'09'\n         DC    B'10001100',X'09'\n         DC    B'10001100',X'31'\n         DC    B'10001100',X'31'\n         DC    B'10001100',X'31'\n         DC    B'10001100',X'31'\n         DC    B'10001100',X'31'\n         DC    B'10001100',X'31'\n         DC    B'10001100',X'31'\n         DC    B'10001100',X'31'\nBB50     DC    B'10001101',X'16'\n         DC    B'10001101',X'16'\n         DC    B'10001101',X'16'\n         DC    B'10001101',X'16'\n         DC    B'10001101',X'B4'\n         DC    B'10001101',X'B4'\n         DC    B'10001101',X'B4'\n         DC    B'10001101',X'B4'\n         DC    B'10001110',X'3F'\n         DC    B'10001110',X'3F'\n         DC    B'10001111',X'FB'\n         DC    B'10001111',X'AD'\n         DC    B'10001101',X'FC'\n         DC    B'10001101',X'FC'\n         DC    B'10001101',X'FC'\n         DC    B'10001101',X'FC'\nBB51     DC    B'10001101',X'EC'\n         DC    B'10001101',X'EC'\n         DC    B'10001101',X'EC'\n         DC    B'10001101',X'EC'\n         DC    B'10001101',X'CC'\n         DC    B'10001101',X'CC'\n         DC    B'10001101',X'CC'\n         DC    B'10001101',X'CC'\n         DC    B'10001110',X'37'\n         DC    B'10001110',X'37'\n         DC    B'10001110',X'25'\n         DC    B'10001110',X'25'\n         DC    B'10001101',X'13'\n         DC    B'10001101',X'13'\n         DC    B'10001101',X'13'\n         DC    B'10001101',X'13'\nBB52     DC    B'10001100',X'4F'\n         DC    B'10001100',X'4F'\n         DC    B'10001100',X'4F'\n         DC    B'10001100',X'4F'\n         DC    B'10001100',X'4F'\n         DC    B'10001100',X'4F'\n         DC    B'10001100',X'4F'\n         DC    B'10001100',X'4F'\n         DC    B'10001101',X'DC'\n         DC    B'10001101',X'DC'\n         DC    B'10001101',X'DC'\n         DC    B'10001101',X'DC'\n         DC    B'10001101',X'33'\n         DC    B'10001101',X'33'\n         DC    B'10001101',X'33'\n         DC    B'10001101',X'33'\nBB53     DC    B'10001110',X'76'\n         DC    B'10001110',X'76'\n         DC    B'10001110',X'CE'\n         DC    B'10001110',X'CE'\n         DC    B'10001101',X'19'\n         DC    B'10001101',X'19'\n         DC    B'10001101',X'19'\n         DC    B'10001101',X'19'\n         DC    B'10001101',X'5A'\n         DC    B'10001101',X'5A'\n         DC    B'10001101',X'5A'\n         DC    B'10001101',X'5A'\n         DC    B'10001110',X'77'\n         DC    B'10001110',X'77'\n         DC    B'10001110',X'8A'\n         DC    B'10001110',X'8A'\nBB54     DC    B'10001100',X'44'\n         DC    B'10001100',X'44'\n         DC    B'10001100',X'44'\n         DC    B'10001100',X'44'\n         DC    B'10001100',X'44'\n         DC    B'10001100',X'44'\n         DC    B'10001100',X'44'\n         DC    B'10001100',X'44'\n         DC    B'10001101',X'74'\n         DC    B'10001101',X'74'\n         DC    B'10001101',X'74'\n         DC    B'10001101',X'74'\n         DC    B'10001101',X'B8'\n         DC    B'10001101',X'B8'\n         DC    B'10001101',X'B8'\n         DC    B'10001101',X'B8'\nBB55     DC    B'10001100',X'A5'\n         DC    B'10001100',X'A5'\n         DC    B'10001100',X'A5'\n         DC    B'10001100',X'A5'\n         DC    B'10001100',X'A5'\n         DC    B'10001100',X'A5'\n         DC    B'10001100',X'A5'\n         DC    B'10001100',X'A5'\n         DC    B'10001100',X'6F'\n         DC    B'10001100',X'6F'\n         DC    B'10001100',X'6F'\n         DC    B'10001100',X'6F'\n         DC    B'10001100',X'6F'\n         DC    B'10001100',X'6F'\n         DC    B'10001100',X'6F'\n         DC    B'10001100',X'6F'\nBB56     DC    B'10001100',X'4C'\n         DC    B'10001100',X'4C'\n         DC    B'10001100',X'4C'\n         DC    B'10001100',X'4C'\n         DC    B'10001100',X'4C'\n         DC    B'10001100',X'4C'\n         DC    B'10001100',X'4C'\n         DC    B'10001100',X'4C'\n         DC    B'10001100',X'98'\n         DC    B'10001100',X'98'\n         DC    B'10001100',X'98'\n         DC    B'10001100',X'98'\n         DC    B'10001100',X'98'\n         DC    B'10001100',X'98'\n         DC    B'10001100',X'98'\n         DC    B'10001100',X'98'\nBB57     DC    B'10001101',X'72'\n         DC    B'10001101',X'72'\n         DC    B'10001101',X'72'\n         DC    B'10001101',X'72'\n         DC    B'10001101',X'0B'\n         DC    B'10001101',X'0B'\n         DC    B'10001101',X'0B'\n         DC    B'10001101',X'0B'\n         DC    B'10001110',X'8E'\n         DC    B'10001110',X'8E'\n         DC    B'10001110',X'EE'\n         DC    B'10001110',X'EE'\n         DC    B'10001101',X'64'\n         DC    B'10001101',X'64'\n         DC    B'10001101',X'64'\n         DC    B'10001101',X'64'\nEXPOLD   DC    F'9',X'000001FF'\n         DC    F'3',X'00000007'\n         DC    F'2',X'00000003'\n         DC    13F'0,0'\n         DC    B'10000110',X'D3'\n         DC    B'10000110',X'D3'\n         DC    B'10000110',X'D3'\n         DC    B'10000110',X'D3'\n         DC    B'10000110',X'D3'\n         DC    B'10000110',X'D3'\n         DC    B'10000110',X'D3'\n         DC    B'10000110',X'D3'\n         DC    B'10000110',X'F4'\n         DC    B'10000110',X'F4'\n         DC    B'10000110',X'F4'\n         DC    B'10000110',X'F4'\n         DC    B'10000110',X'F4'\n         DC    B'10000110',X'F4'\n         DC    B'10000110',X'F4'\n         DC    B'10000110',X'F4'\n         DC    B'10000110',X'C4'\n         DC    B'10000110',X'C4'\n         DC    B'10000110',X'C4'\n         DC    B'10000110',X'C4'\n         DC    B'10000110',X'C4'\n         DC    B'10000110',X'C4'\n         DC    B'10000110',X'C4'\n         DC    B'10000110',X'C4'\n         DC    AL2(BO1-*)\n         DC    B'10001001',X'E9'\n         DC    B'10001001',X'86'\n         DC    AL2(BO2-*)\n         DC    B'10001000',X'E6'\n         DC    B'10001000',X'E6'\n         DC    AL2(BO3-*)\n         DC    B'10001001',X'0E'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10000100',X'00'\n         DC    B'10001000',X'99'\n         DC    B'10001000',X'99'\n         DC    B'10001000',X'D2'\n         DC    B'10001000',X'D2'\n         DC    B'10000111',X'04'\n         DC    B'10000111',X'04'\n         DC    B'10000111',X'04'\n         DC    B'10000111',X'04'\n         DC    B'10000111',X'E4'\n         DC    B'10000111',X'E4'\n         DC    B'10000111',X'E4'\n         DC    B'10000111',X'E4'\n         DC    AL2(BO4-*)\n         DC    AL2(BO5-*)\n         DC    AL2(BO6-*)\n         DC    AL2(BO7-*)\n         DC    B'10000110',X'C3'\n         DC    B'10000110',X'C3'\n         DC    B'10000110',X'C3'\n         DC    B'10000110',X'C3'\n         DC    B'10000110',X'C3'\n         DC    B'10000110',X'C3'\n         DC    B'10000110',X'C3'\n         DC    B'10000110',X'C3'\n         DC    AL2(BO8-*)\n         DC    B'10001001',X'09'\n         DC    B'10001000',X'84'\n         DC    B'10001000',X'84'\n         DC    B'10000111',X'14'\n         DC    B'10000111',X'14'\n         DC    B'10000111',X'14'\n         DC    B'10000111',X'14'\n         DC    B'10000101',X'F1'\n         DC    B'10000101',X'F1'\n         DC    B'10000101',X'F1'\n         DC    B'10000101',X'F1'\n         DC    B'10000101',X'F1'\n         DC    B'10000101',X'F1'\n         DC    B'10000101',X'F1'\n         DC    B'10000101',X'F1'\n         DC    B'10000101',X'F1'\n         DC    B'10000101',X'F1'\n         DC    B'10000101',X'F1'\n         DC    B'10000101',X'F1'\n         DC    B'10000101',X'F1'\n         DC    B'10000101',X'F1'\n         DC    B'10000101',X'F1'\n         DC    B'10000101',X'F1'\n         DC    B'10000110',X'F3'\n         DC    B'10000110',X'F3'\n         DC    B'10000110',X'F3'\n         DC    B'10000110',X'F3'\n         DC    B'10000110',X'F3'\n         DC    B'10000110',X'F3'\n         DC    B'10000110',X'F3'\n         DC    B'10000110',X'F3'\n         DC    B'10000111',X'85'\n         DC    B'10000111',X'85'\n         DC    B'10000111',X'85'\n         DC    B'10000111',X'85'\n         DC    B'10001000',X'E8'\n         DC    B'10001000',X'E8'\n         DC    B'10001001',X'A4'\n         DC    AL2(BO9-*)\n         DC    B'10000100',X'F9'\n         DC    B'10000100',X'F9'\n         DC    B'10000100',X'F9'\n         DC    B'10000100',X'F9'\n         DC    B'10000100',X'F9'\n         DC    B'10000100',X'F9'\n         DC    B'10000100',X'F9'\n         DC    B'10000100',X'F9'\n         DC    B'10000100',X'F9'\n         DC    B'10000100',X'F9'\n         DC    B'10000100',X'F9'\n         DC    B'10000100',X'F9'\n         DC    B'10000100',X'F9'\n         DC    B'10000100',X'F9'\n         DC    B'10000100',X'F9'\n         DC    B'10000100',X'F9'\n         DC    B'10000100',X'F9'\n         DC    B'10000100',X'F9'\n         DC    B'10000100',X'F9'\n         DC    B'10000100',X'F9'\n         DC    B'10000100',X'F9'\n         DC    B'10000100',X'F9'\n         DC    B'10000100',X'F9'\n         DC    B'10000100',X'F9'\n         DC    B'10000100',X'F9'\n         DC    B'10000100',X'F9'\n         DC    B'10000100',X'F9'\n         DC    B'10000100',X'F9'\n         DC    B'10000100',X'F9'\n         DC    B'10000100',X'F9'\n         DC    B'10000100',X'F9'\n         DC    B'10000100',X'F9'\n         DC    B'10001001',X'70'\n         DC    B'10001001',X'D8'\n         DC    B'10001000',X'E7'\n         DC    B'10001000',X'E7'\n         DC    B'10000111',X'58'\n         DC    B'10000111',X'58'\n         DC    B'10000111',X'58'\n         DC    B'10000111',X'58'\n         DC    B'10000111',X'C2'\n         DC    B'10000111',X'C2'\n         DC    B'10000111',X'C2'\n         DC    B'10000111',X'C2'\n         DC    B'10001001',X'7E'\n         DC    AL2(BO10-*)\n         DC    B'10001001',X'94'\n         DC    AL2(BO11-*)\n         DC    B'10001000',X'7D'\n         DC    B'10001000',X'7D'\n         DC    B'10001000',X'30'\n         DC    B'10001000',X'30'\n         DC    B'10000111',X'C6'\n         DC    B'10000111',X'C6'\n         DC    B'10000111',X'C6'\n         DC    B'10000111',X'C6'\n         DC    B'10001001',X'83'\n         DC    B'10001001',X'18'\n         DC    B'10001000',X'95'\n         DC    B'10001000',X'95'\n         DC    AL2(BO12-*)\n         DC    B'10001001',X'D1'\n         DC    B'10001000',X'03'\n         DC    B'10001000',X'03'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000011',X'F0'\n         DC    B'10000110',X'D6'\n         DC    B'10000110',X'D6'\n         DC    B'10000110',X'D6'\n         DC    B'10000110',X'D6'\n         DC    B'10000110',X'D6'\n         DC    B'10000110',X'D6'\n         DC    B'10000110',X'D6'\n         DC    B'10000110',X'D6'\n         DC    B'10000110',X'D5'\n         DC    B'10000110',X'D5'\n         DC    B'10000110',X'D5'\n         DC    B'10000110',X'D5'\n         DC    B'10000110',X'D5'\n         DC    B'10000110',X'D5'\n         DC    B'10000110',X'D5'\n         DC    B'10000110',X'D5'\n         DC    B'10000110',X'C9'\n         DC    B'10000110',X'C9'\n         DC    B'10000110',X'C9'\n         DC    B'10000110',X'C9'\n         DC    B'10000110',X'C9'\n         DC    B'10000110',X'C9'\n         DC    B'10000110',X'C9'\n         DC    B'10000110',X'C9'\n         DC    B'10000110',X'5C'\n         DC    B'10000110',X'5C'\n         DC    B'10000110',X'5C'\n         DC    B'10000110',X'5C'\n         DC    B'10000110',X'5C'\n         DC    B'10000110',X'5C'\n         DC    B'10000110',X'5C'\n         DC    B'10000110',X'5C'\n         DC    B'10000100',X'40'\n         DC    B'10000100',X'40'\n         DC    B'10000100',X'40'\n         DC    B'10000100',X'40'\n         DC    B'10000100',X'40'\n         DC    B'10000100',X'40'\n         DC    B'10000100',X'40'\n         DC    B'10000100',X'40'\n         DC    B'10000100',X'40'\n         DC    B'10000100',X'40'\n         DC    B'10000100',X'40'\n         DC    B'10000100',X'40'\n         DC    B'10000100',X'40'\n         DC    B'10000100',X'40'\n         DC    B'10000100',X'40'\n         DC    B'10000100',X'40'\n         DC    B'10000100',X'40'\n         DC    B'10000100',X'40'\n         DC    B'10000100',X'40'\n         DC    B'10000100',X'40'\n         DC    B'10000100',X'40'\n         DC    B'10000100',X'40'\n         DC    B'10000100',X'40'\n         DC    B'10000100',X'40'\n         DC    B'10000100',X'40'\n         DC    B'10000100',X'40'\n         DC    B'10000100',X'40'\n         DC    B'10000100',X'40'\n         DC    B'10000100',X'40'\n         DC    B'10000100',X'40'\n         DC    B'10000100',X'40'\n         DC    B'10000100',X'40'\n         DC    B'10001000',X'A2'\n         DC    B'10001000',X'A2'\n         DC    AL2(BO13-*)\n         DC    B'10001001',X'0A'\n         DC    AL2(BO14-*)\n         DC    B'10001001',X'E0'\n         DC    B'10001000',X'81'\n         DC    B'10001000',X'81'\n         DC    B'10001000',X'96'\n         DC    B'10001000',X'96'\n         DC    B'10001000',X'89'\n         DC    B'10001000',X'89'\n         DC    AL2(BO15-*)\n         DC    AL2(BO16-*)\n         DC    B'10001001',X'93'\n         DC    B'10001001',X'05'\n         DC    B'10000110',X'C1'\n         DC    B'10000110',X'C1'\n         DC    B'10000110',X'C1'\n         DC    B'10000110',X'C1'\n         DC    B'10000110',X'C1'\n         DC    B'10000110',X'C1'\n         DC    B'10000110',X'C1'\n         DC    B'10000110',X'C1'\n         DC    B'10000111',X'80'\n         DC    B'10000111',X'80'\n         DC    B'10000111',X'80'\n         DC    B'10000111',X'80'\n         DC    B'10000111',X'D4'\n         DC    B'10000111',X'D4'\n         DC    B'10000111',X'D4'\n         DC    B'10000111',X'D4'\n         DC    B'10000111',X'F7'\n         DC    B'10000111',X'F7'\n         DC    B'10000111',X'F7'\n         DC    B'10000111',X'F7'\n         DC    B'10001001',X'0C'\n         DC    AL2(BO17-*)\n         DC    B'10001000',X'50'\n         DC    B'10001000',X'50'\n         DC    B'10000110',X'E2'\n         DC    B'10000110',X'E2'\n         DC    B'10000110',X'E2'\n         DC    B'10000110',X'E2'\n         DC    B'10000110',X'E2'\n         DC    B'10000110',X'E2'\n         DC    B'10000110',X'E2'\n         DC    B'10000110',X'E2'\n         DC    B'10000110',X'D9'\n         DC    B'10000110',X'D9'\n         DC    B'10000110',X'D9'\n         DC    B'10000110',X'D9'\n         DC    B'10000110',X'D9'\n         DC    B'10000110',X'D9'\n         DC    B'10000110',X'D9'\n         DC    B'10000110',X'D9'\n         DC    B'10000110',X'01'\n         DC    B'10000110',X'01'\n         DC    B'10000110',X'01'\n         DC    B'10000110',X'01'\n         DC    B'10000110',X'01'\n         DC    B'10000110',X'01'\n         DC    B'10000110',X'01'\n         DC    B'10000110',X'01'\n         DC    B'10001001',X'47'\n         DC    AL2(BO18-*)\n         DC    B'10001000',X'10'\n         DC    B'10001000',X'10'\n         DC    B'10000111',X'F8'\n         DC    B'10000111',X'F8'\n         DC    B'10000111',X'F8'\n         DC    B'10000111',X'F8'\n         DC    B'10000110',X'F2'\n         DC    B'10000110',X'F2'\n         DC    B'10000110',X'F2'\n         DC    B'10000110',X'F2'\n         DC    B'10000110',X'F2'\n         DC    B'10000110',X'F2'\n         DC    B'10000110',X'F2'\n         DC    B'10000110',X'F2'\n         DC    AL2(BO19-*)\n         DC    AL2(BO20-*)\n         DC    AL2(BO21-*)\n         DC    AL2(BO22-*)\n         DC    B'10000111',X'D7'\n         DC    B'10000111',X'D7'\n         DC    B'10000111',X'D7'\n         DC    B'10000111',X'D7'\n         DC    B'10001000',X'E5'\n         DC    B'10001000',X'E5'\n         DC    AL2(BO23-*)\n         DC    B'10001001',X'0D'\n         DC    AL2(BO24-*)\n         DC    AL2(BO25-*)\n         DC    AL2(BO26-*)\n         DC    B'10001001',X'06'\n         DC    B'10001001',X'06'\n         DC    B'10001001',X'06'\n         DC    B'10001001',X'06'\n         DC    B'10001001',X'06'\n         DC    B'10001001',X'06'\n         DC    B'10001001',X'06'\n         DC    B'10001001',X'06'\n         DC    B'10001001',X'06'\n         DC    B'10001001',X'06'\n         DC    B'10001001',X'06'\n         DC    B'10001001',X'06'\n         DC    B'10001001',X'06'\n         DC    B'10001001',X'06'\n         DC    B'10001001',X'06'\n         DC    B'10001001',X'06'\n         DC    B'10001001',X'06'\n         DC    B'10000110',X'E3'\n         DC    B'10000110',X'E3'\n         DC    B'10000110',X'E3'\n         DC    B'10000110',X'E3'\n         DC    B'10000110',X'E3'\n         DC    B'10000110',X'E3'\n         DC    B'10000110',X'E3'\n         DC    B'10000110',X'E3'\n         DC    B'10001000',X'20'\n         DC    B'10001000',X'20'\n         DC    B'10001000',X'A3'\n         DC    B'10001000',X'A3'\n         DC    B'10001001',X'07'\n         DC    AL2(BO27-*)\n         DC    B'10001000',X'C8'\n         DC    B'10001000',X'C8'\n         DC    B'11000101',X'00'            MULTS\n         DC    B'11000101',X'00'            MULTS\n         DC    B'11000101',X'00'            MULTS\n         DC    B'11000101',X'00'            MULTS\n         DC    B'11000101',X'00'            MULTS\n         DC    B'11000101',X'00'            MULTS\n         DC    B'11000101',X'00'            MULTS\n         DC    B'11000101',X'00'            MULTS\n         DC    B'11000101',X'00'            MULTS\n         DC    B'11000101',X'00'            MULTS\n         DC    B'11000101',X'00'            MULTS\n         DC    B'11000101',X'00'            MULTS\n         DC    B'11000101',X'00'            MULTS\n         DC    B'11000101',X'00'            MULTS\n         DC    B'11000101',X'00'            MULTS\n         DC    B'11000101',X'00'            MULTS\n         DC    B'10000111',X'F6'\n         DC    B'10000111',X'F6'\n         DC    B'10000111',X'F6'\n         DC    B'10000111',X'F6'\n         DC    AL2(BO28-*)\n         DC    B'10001001',X'08'\n         DC    AL2(BO29-*)\n         DC    B'10001001',X'41'\n         DC    B'10000111',X'02'\n         DC    B'10000111',X'02'\n         DC    B'10000111',X'02'\n         DC    B'10000111',X'02'\n         DC    B'10001001',X'88'\n         DC    AL2(BO30-*)\n         DC    B'10001000',X'5D'\n         DC    B'10001000',X'5D'\n         DC    B'10000111',X'6B'\n         DC    B'10000111',X'6B'\n         DC    B'10000111',X'6B'\n         DC    B'10000111',X'6B'\n         DC    B'10001000',X'4B'\n         DC    B'10001000',X'4B'\n         DC    AL2(BO31-*)\n         DC    B'10001001',X'60'\n         DC    B'10000110',X'C5'\n         DC    B'10000110',X'C5'\n         DC    B'10000110',X'C5'\n         DC    B'10000110',X'C5'\n         DC    B'10000110',X'C5'\n         DC    B'10000110',X'C5'\n         DC    B'10000110',X'C5'\n         DC    B'10000110',X'C5'\n         DC    B'10000111',X'FF'\n         DC    B'10000111',X'FF'\n         DC    B'10000111',X'FF'\n         DC    B'10000111',X'FF'\n         DC    B'10001000',X'D0'\n         DC    B'10001000',X'D0'\n         DC    AL2(BO32-*)\n         DC    AL2(BO33-*)\n         DC    B'10001000',X'4D'\n         DC    B'10001000',X'4D'\n         DC    B'10001000',X'C7'\n         DC    B'10001000',X'C7'\n         DC    B'10000111',X'F5'\n         DC    B'10000111',X'F5'\n         DC    B'10000111',X'F5'\n         DC    B'10000111',X'F5'\nBO1      DC    B'10001010',X'92'\n         DC    B'10001010',X'92'\n         DC    B'10001010',X'92'\n         DC    B'10001010',X'92'\n         DC    B'10001011',X'6A'\n         DC    B'10001011',X'6A'\n         DC    B'10001100',X'3F'\n         DC    B'10001100',X'AE'\nBO2      DC    B'10001010',X'1A'\n         DC    B'10001010',X'1A'\n         DC    B'10001010',X'1A'\n         DC    B'10001010',X'1A'\n         DC    B'10001010',X'74'\n         DC    B'10001010',X'74'\n         DC    B'10001010',X'74'\n         DC    B'10001010',X'74'\nBO3      DC    B'10001011',X'B4'\n         DC    B'10001011',X'B4'\n         DC    B'10001100',X'2D'\n         DC    B'10001100',X'BE'\n         DC    B'10001010',X'78'\n         DC    B'10001010',X'78'\n         DC    B'10001010',X'78'\n         DC    B'10001010',X'78'\nBO4      DC    B'10001010',X'6C'\n         DC    B'10001010',X'6C'\n         DC    B'10001010',X'6C'\n         DC    B'10001010',X'6C'\n         DC    B'10001011',X'7B'\n         DC    B'10001011',X'7B'\n         DC    B'10001011',X'32'\n         DC    B'10001011',X'32'\nBO5      DC    B'10001100',X'39'\n         DC    AL2(CC1-*)\n         DC    B'10001011',X'BC'\n         DC    B'10001011',X'BC'\n         DC    B'10001011',X'CC'\n         DC    B'10001011',X'CC'\n         DC    B'10001100',X'79'\n         DC    B'10001100',X'2F'\nBO6      DC    B'10001010',X'22'\n         DC    B'10001010',X'22'\n         DC    B'10001010',X'22'\n         DC    B'10001010',X'22'\n         DC    B'10001100',X'37'\n         DC    B'10001100',X'3D'\n         DC    B'10001011',X'6F'\n         DC    B'10001011',X'6F'\nBO7      DC    B'10001011',X'52'\n         DC    B'10001011',X'52'\n         DC    B'10001011',X'21'\n         DC    B'10001011',X'21'\n         DC    B'10001011',X'56'\n         DC    B'10001011',X'56'\n         DC    B'10001011',X'2A'\n         DC    B'10001011',X'2A'\nBO8      DC    B'10001100',X'EA'\n         DC    AL2(CC2-*)\n         DC    B'10001011',X'6E'\n         DC    B'10001011',X'6E'\n         DC    B'10001011',X'3A'\n         DC    B'10001011',X'3A'\n         DC    B'10001011',X'9C'\n         DC    B'10001011',X'9C'\nBO9      DC    B'10001100',X'29'\n         DC    B'10001100',X'45'\n         DC    B'10001011',X'23'\n         DC    B'10001011',X'23'\n         DC    B'10001100',X'51'\n         DC    AL2(CC3-*)\n         DC    B'10001011',X'31'\n         DC    B'10001011',X'31'\nBO10     DC    B'10001100',X'36'\n         DC    B'10001100',X'8A'\n         DC    B'10001100',X'9A'\n         DC    B'10001100',X'DA'\n         DC    B'10001010',X'A6'\n         DC    B'10001010',X'A6'\n         DC    B'10001010',X'A6'\n         DC    B'10001010',X'A6'\nBO11     DC    B'10001011',X'34'\n         DC    B'10001011',X'34'\n         DC    B'10001011',X'A5'\n         DC    B'10001011',X'A5'\n         DC    B'10001011',X'64'\n         DC    B'10001011',X'64'\n         DC    B'10001011',X'2C'\n         DC    B'10001011',X'2C'\nBO12     DC    AL2(CC4-*)\n         DC    B'10001100',X'CE'\n         DC    B'10001011',X'46'\n         DC    B'10001011',X'46'\n         DC    B'10001010',X'98'\n         DC    B'10001010',X'98'\n         DC    B'10001010',X'98'\n         DC    B'10001010',X'98'\nBO13     DC    B'10001010',X'4E'\n         DC    B'10001010',X'4E'\n         DC    B'10001010',X'4E'\n         DC    B'10001010',X'4E'\n         DC    B'10001010',X'16'\n         DC    B'10001010',X'16'\n         DC    B'10001010',X'16'\n         DC    B'10001010',X'16'\nBO14     DC    AL2(CC5-*)\n         DC    B'10001100',X'AA'\n         DC    AL2(CC6-*)\n         DC    B'10001100',X'A7'\n         DC    B'10001011',X'38'\n         DC    B'10001011',X'38'\n         DC    B'10001011',X'26'\n         DC    B'10001011',X'26'\nBO15     DC    B'10001011',X'91'\n         DC    B'10001011',X'91'\n         DC    B'10001011',X'3C'\n         DC    B'10001011',X'3C'\n         DC    B'10001010',X'11'\n         DC    B'10001010',X'11'\n         DC    B'10001010',X'11'\n         DC    B'10001010',X'11'\nBO16     DC    B'10001010',X'1B'\n         DC    B'10001010',X'1B'\n         DC    B'10001010',X'1B'\n         DC    B'10001010',X'1B'\n         DC    B'10001100',X'2B'\n         DC    B'10001100',X'4F'\n         DC    AL2(CC7-*)\n         DC    B'10001100',X'4A'\nBO17     DC    B'10001011',X'4C'\n         DC    B'10001011',X'4C'\n         DC    B'10001011',X'68'\n         DC    B'10001011',X'68'\n         DC    B'10001011',X'DC'\n         DC    B'10001011',X'DC'\n         DC    B'10001011',X'59'\n         DC    B'10001011',X'59'\nBO18     DC    B'10001100',X'B6'\n         DC    B'10001100',X'FC'\n         DC    AL2(CC8-*)\n         DC    B'10001100',X'8E'\n         DC    B'10001011',X'7A'\n         DC    B'10001011',X'7A'\n         DC    B'10001100',X'FA'\n         DC    B'10001100',X'33'\nBO19     DC    B'10001010',X'6D'\n         DC    B'10001010',X'6D'\n         DC    B'10001010',X'6D'\n         DC    B'10001010',X'6D'\n         DC    AL2(CC9-*)\n         DC    B'10001100',X'9E'\n         DC    B'10001100',X'B2'\n         DC    B'10001100',X'66'\nBO20     DC    B'10001010',X'B0'\n         DC    B'10001010',X'B0'\n         DC    B'10001010',X'B0'\n         DC    B'10001010',X'B0'\n         DC    B'10001010',X'61'\n         DC    B'10001010',X'61'\n         DC    B'10001010',X'61'\n         DC    B'10001010',X'61'\nBO21     DC    B'10001010',X'EF'\n         DC    B'10001010',X'EF'\n         DC    B'10001010',X'EF'\n         DC    B'10001010',X'EF'\n         DC    B'10001100',X'3E'\n         DC    B'10001100',X'1D'\n         DC    AL2(CC10-*)\n         DC    B'10001100',X'1F'\nBO22     DC    B'10001010',X'90'\n         DC    B'10001010',X'90'\n         DC    B'10001010',X'90'\n         DC    B'10001010',X'90'\n         DC    B'10001010',X'A8'\n         DC    B'10001010',X'A8'\n         DC    B'10001010',X'A8'\n         DC    B'10001010',X'A8'\nBO23     DC    B'10001010',X'C0'\n         DC    B'10001010',X'C0'\n         DC    B'10001010',X'C0'\n         DC    B'10001010',X'C0'\n         DC    B'10001010',X'12'\n         DC    B'10001010',X'12'\n         DC    B'10001010',X'12'\n         DC    B'10001010',X'12'\nBO24     DC    AL2(CC11-*)\n         DC    B'10001100',X'CA'\n         DC    AL2(CC12-*)\n         DC    B'10001100',X'2E'\n         DC    B'10001010',X'48'\n         DC    B'10001010',X'48'\n         DC    B'10001010',X'48'\n         DC    B'10001010',X'48'\nBO25     DC    B'10001011',X'1E'\n         DC    B'10001011',X'1E'\n         DC    B'10001100',X'DE'\n         DC    B'10001100',X'53'\n         DC    B'10001100',X'FE'\n         DC    AL2(CC13-*)\n         DC    B'10001011',X'13'\n         DC    B'10001011',X'13'\nBO26     DC    B'10001011',X'42'\n         DC    B'10001011',X'42'\n         DC    B'10001011',X'28'\n         DC    B'10001011',X'28'\n         DC    B'10001010',X'82'\n         DC    B'10001010',X'82'\n         DC    B'10001010',X'82'\n         DC    B'10001010',X'82'\nBO27     DC    B'10001100',X'62'\n         DC    B'10001100',X'25'\n         DC    AL2(CC14-*)\n         DC    B'10001100',X'43'\n         DC    B'10001010',X'54'\n         DC    B'10001010',X'54'\n         DC    B'10001010',X'54'\n         DC    B'10001010',X'54'\nBO28     DC    AL2(CC15-*)\n         DC    B'10001100',X'EC'\n         DC    B'10001011',X'5B'\n         DC    B'10001011',X'5B'\n         DC    B'10001011',X'8C'\n         DC    B'10001011',X'8C'\n         DC    AL2(CC16-*)\n         DC    B'10001100',X'55'\nBO29     DC    B'10001011',X'5A'\n         DC    B'10001011',X'5A'\n         DC    B'10001100',X'5E'\n         DC    B'10001100',X'27'\n         DC    B'10001010',X'0F'\n         DC    B'10001010',X'0F'\n         DC    B'10001010',X'0F'\n         DC    B'10001010',X'0F'\nBO30     DC    B'10001010',X'0B'\n         DC    B'10001010',X'0B'\n         DC    B'10001010',X'0B'\n         DC    B'10001010',X'0B'\n         DC    B'10001010',X'87'\n         DC    B'10001010',X'87'\n         DC    B'10001010',X'87'\n         DC    B'10001010',X'87'\nBO31     DC    B'10001011',X'7C'\n         DC    B'10001011',X'7C'\n         DC    B'10001011',X'A0'\n         DC    B'10001011',X'A0'\n         DC    B'10001010',X'97'\n         DC    B'10001010',X'97'\n         DC    B'10001010',X'97'\n         DC    B'10001010',X'97'\nBO32     DC    AL2(CC17-*)\n         DC    B'10001100',X'17'\n         DC    B'10001011',X'44'\n         DC    B'10001011',X'44'\n         DC    B'10001100',X'AC'\n         DC    B'10001100',X'19'\n         DC    B'10001011',X'24'\n         DC    B'10001011',X'24'\nBO33     DC    AL2(CC18-*)\n         DC    B'10001100',X'7F'\n         DC    B'10001011',X'15'\n         DC    B'10001011',X'15'\n         DC    B'10001011',X'1C'\n         DC    B'10001011',X'1C'\n         DC    B'10001100',X'76'\n         DC    B'10001100',X'B8'\nCC1      DC    B'10001101',X'BA'\n         DC    B'10001101',X'BA'\n         DC    B'10001101',X'8B'\n         DC    B'10001101',X'8B'\nCC2      DC    B'10001110',X'ED'\n         DC    B'10001110',X'BD'\n         DC    B'10001101',X'A9'\n         DC    B'10001101',X'A9'\nCC3      DC    B'10001101',X'73'\n         DC    B'10001101',X'73'\n         DC    B'10001110',X'FD'\n         DC    B'10001110',X'B9'\nCC4      DC    B'10001101',X'71'\n         DC    B'10001101',X'71'\n         DC    B'10001110',X'AD'\n         DC    B'10001110',X'B5'\nCC5      DC    B'10001101',X'75'\n         DC    B'10001101',X'75'\n         DC    B'10001101',X'BB'\n         DC    B'10001101',X'BB'\nCC6      DC    B'10001110',X'EB'\n         DC    B'10001110',X'E1'\n         DC    B'10001101',X'69'\n         DC    B'10001101',X'69'\nCC7      DC    B'10001101',X'67'\n         DC    B'10001101',X'67'\n         DC    B'10001101',X'CB'\n         DC    B'10001101',X'CB'\nCC8      DC    B'10001110',X'AF'\n         DC    B'10001110',X'9F'\n         DC    B'10001101',X'63'\n         DC    B'10001101',X'63'\nCC9      DC    B'10001101',X'5F'\n         DC    B'10001101',X'5F'\n         DC    B'10001110',X'FB'\n         DC    B'10001110',X'BF'\nCC10     DC    B'10001101',X'9D'\n         DC    B'10001101',X'9D'\n         DC    B'10001101',X'DB'\n         DC    B'10001101',X'DB'\nCC11     DC    B'10001101',X'72'\n         DC    B'10001101',X'72'\n         DC    B'10001101',X'35'\n         DC    B'10001101',X'35'\nCC12     DC    B'10001110',X'AB'\n         DC    B'10001110',X'9B'\n         DC    B'10001101',X'EE'\n         DC    B'10001101',X'EE'\nCC13     DC    B'10001101',X'57'\n         DC    B'10001101',X'57'\n         DC    B'10001101',X'65'\n         DC    B'10001101',X'65'\nCC14     DC    B'10001101',X'CD'\n         DC    B'10001101',X'CD'\n         DC    B'10001110',X'DD'\n         DC    B'10001110',X'8D'\nCC15     DC    B'10001101',X'3B'\n         DC    B'10001101',X'3B'\n         DC    B'10001101',X'49'\n         DC    B'10001101',X'49'\nCC16     DC    B'10001101',X'CF'\n         DC    B'10001101',X'CF'\n         DC    B'10001101',X'B3'\n         DC    B'10001101',X'B3'\nCC17     DC    B'10001101',X'77'\n         DC    B'10001101',X'77'\n         DC    B'10001110',X'A1'\n         DC    B'10001110',X'DF'\nCC18     DC    B'10001101',X'B1'\n         DC    B'10001101',X'B1'\n         DC    B'10001110',X'8F'\n         DC    B'10001110',X'B7'\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHUNLD": {"ttr": 11523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x03\\xfd\\x03\\xfd\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 1021, "newlines": 1021, "modlines": 0, "user": "ARCHIVR"}, "text": "UNLD     TITLE 'ARCHIVER --- UNLOAD FUNCTION'\n*---------------------------------------------------------------------*\n*---     THIS ROUTINE IS THE FIRST HALF OF THE ARCHIVER'S REASON   ---*\n*---     FOR EXISTANCE.  THIS SUBROUTINE, WITH ALL ITS CALLS,      ---*\n*---     ETC., PERFORM THE UNLOAD FUNCTIONS OF THE ARCHIVER.       ---*\n*---------------------------------------------------------------------*\n*---     THE ONLY MAJOR CHANGES TO THE UNLOAD FUNCTION ARE TO      ---*\n*---     SUPPORT THE AUTOMATIC ASSIGNING OF ARCHIVE ALIASES, IF    ---*\n*---     REQUESTED BY THE USER.  ANY ALIAS NAMES IN THE INPUT PDS  ---*\n*---     DIRECTORY ARE USED TO ASSIGN ARCHIVE ALIASES OF THE SAME  ---*\n*---     GROUP, SUBGROUP AND TYPE QUALIFIERS AS THE 'MAIN'         ---*\n*---     MEMBER.                                                   ---*\n*---------------------------------------------------------------------*\nARCHUNLD CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n@RPL1    EQU   R2                  SOME\n@RPL2    EQU   R3                    SPECIAL\n@RPL3    EQU   R4                      EQUATES\n@BUF1    EQU   R5                        FOR\n@BUF2    EQU   R6                          VSAM\n@BUF3    EQU   R7                            I/O MGMT\n         COPY #ARCBITS\n         USING ARCHUNLD,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             LOAD ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHUNLD,R11        DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             LOAD NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RELOAD BACK POINTER\n         L     R14,12(,R14)        RELOAD ORIG. REG 14\n         LA    R10,0(,R11)         COPY ORIGINAL BASE REGISTER\n         AH    R10,PASSIT-2        BUMP BY A BASE'S WORTH\n         USING ARCHUNLD+4096,R10   AND DECLARE IT\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         XC    FCOUNT,FCOUNT       CLEAR FUNCTION RECORD COUNT\n         XC    MCNT,MCNT           AND MEMBER COUNT\n         XC    ACNT,ACNT           AND ALIAS COUNT\n         #IF   GENG,ON,GENQ        INVALID GENERICS\n         #IF   GENSG,ON,GENQ\n         #IF   GENT,ON,GENQ\n         BAL   R14,OPNVI           GO OPEN THE NONVSAM INPUT DATASET\n         MVC   VS1MODE,=CL8'OUTPUT' SET THE I/O MODE\n         LA    R1,VSAM1DD          LOAD THE PARM POINTER\n         LA    R0,0                AND THE 'OPEN' FLAG\n         CALL  ARCHVSOP            CALL THE 'OPEN' FUNCTION\n         LTR   R15,R15             OPEN OK ??\n         BNZ   ENDITALL            NOPE; CAN'T WORK\n         EJECT\n*---------------------------------------------------------------------*\n*---     HERE'S THE MEAT OF THE PROCESSING. THE BASIC PROCESS IS   ---*\n*---           THIS:                                               ---*\n*---                                                               ---*\n*---     1. USING THE CONTROL INFORMATION WE WERE GIVEN AND THE    ---*\n*---        INFORMATION WE'VE DEVELOPED, BUILD AND WRITE A HEADER  ---*\n*---        RECORD ON THE VSAM CLUSTER.  WE'LL USE THE VS1BUF2     ---*\n*---        AREA FOR HEADER/KEY CONSTRUCTION.                      ---*\n*---                                                               ---*\n*---     2. LOOP THROUGH THE MEMBER, READING THE RECORDS AND       ---*\n*---        COMPRESSING THEM INTO THE VSAM BUFFER UNTIL WE CAN'T   ---*\n*---        FIT ANOTHER RECORD WITHOUT EXCEEDING THE MAXIMUM       ---*\n*---        LOGICAL RECORD LENGTH.  AT THAT POINT, WE WRITE THE    ---*\n*---        VSAM RECORD, RESET IT AND CONTINUE.  NOTE THAT EACH    ---*\n*---        RECORD WE GET FROM A LMOD DATASET CONTAINS A TTR       ---*\n*---        VALUE AS A PREFIX.  THIS INFORMATION IS USEFUL DURING  ---*\n*---        THE RELOAD PROCESS. WE ALSO SAVE, IN THE MEMBER        ---*\n*---        HEADER, AN INDICATION THAT THIS IS OR IS NOT A LOAD    ---*\n*---        MODULE.                                                ---*\n*---                                                               ---*\n*---     3. AT END-OF-FILE FOR THE DATASET OR MEMBER, UPDATE THE   ---*\n*---        HEADER RECORD WITH THE ACTUAL BLOCK OR LOGICAL RECORD  ---*\n*---        COUNT THAT WAS MAINTAINED BY THE READ ROUTINE.  THIS   ---*\n*---        COMPLETES THE PROCESSING FOR A SINGLE MEMBER OR        ---*\n*---        SEQUENTIAL DATASET.                                    ---*\n*---                                                               ---*\n*---     4. DELETE THE DIRECTORY-CHAIN ENTRY(S) THAT REPRESENT     ---*\n*---        THIS ITEM. IF THAT'S NOT THE LAST ONE, THEN GO BACK    ---*\n*---        TO STEP ONE FOR ANOTHER ITEM.                          ---*\n*---------------------------------------------------------------------*\n         L     @RPL1,RPL1          LOAD RPL AND\n         L     @BUF1,VS1BUF1       BUFFER POINTER\n         L     @BUF2,VS1BUF2       REGISTERS\nMEMBERS  DS    0H\n         #IF   NVSPS,ON,MBR2       PS DATASET ---\n         L     R9,CHAIN            LOAD CHAIN ROOT POINTER\n         LTR   R9,R9               IS IT EMPTY ??\n         BZ    ENDITALL            YES; DO TERMINATION STUFF\nMBR2     DS    0H\n         USING REC,@BUF2           BASE THE RECORD DSECT\n         MVC   RECN,Q1             COPY FIRST QUALIFIER, TO START\n         #IF   NVSPS,ON,MBR3       LEAVE IT ALONE\n         MVC   RECN(8),8(R9)       MOVE IN THE ITEM NAME\n         MVC   RECN+8(2),=CL2' '   CLOBBER TWO EXTRA BYTES\nMBR3     DS    0H\n         MVI   RECTT,#RTHDR        MARK AS A HEADER RECORD\n         MVC   RECG,Q2             SECOND QUALIFIER\n         MVC   RECSG,Q3            THIRD QUALIFIER\n         MVC   RECT,Q4             AND ITEM TYPE\n         XC    RECSEQ#,RECSEQ#     SEQUENCE NUMBER IS ZERO\n         XC    RSRNOT#,RSRNOT#     NO NOTES, YET ---\n         MVI   @RSRFLG1,X'06'      SET THE VERSION NUMBER\n         MVI   @RSRFLG2,X'01'      SET THE LEVEL NUMBER\n         MVI   @RSRFLG3,X'00'      SET THE MISC. FLAGS\n         MVI   @RSRFLG4,X'00'      SET THE ALIAS FLAGS\n         MVC   RSRDEV,DEVT         MOVE IN THE DEVICE TYPE\n         MVC   RSRREC,NVSRECFM     MOVE IN THE RECORD FORMAT\n         MVC   RSRBLK,NVSBLKL      AND BLOCKSIZE\n         MVC   RSRLRE,NVSLRECL     AND LOGICAL RECORD LENGTH\n         MVC   RSRDSO,NVSDSORG     AND DATASET ORGANIZATION\n         MVC   RSRTIME,TIME        TIME OF UNLOAD\n         MVC   RSRDATE,DATE        AND DATE OF UNLOAD\n         XC    RSRRCNT,RSRRCNT     AND CLEAR THE RECORD COUNT\n*---------------------------------------------------------------------*\n*---     NOW THE TRICKY PART; SETTING THE ITEM VERSION NUMBER      ---*\n*---                                                               ---*\n*---     IF THE USER SPECIFIED A VERSION NUMBER, WE DO A READ TO   ---*\n*---     SEE IF THAT VERSION EXISTS. IF IT DOES, WE MUST DELETE    ---*\n*---     IT BEFORE WE CONTINUE.  SINCE I'M A TRUSTING SOUL, I'LL   ---*\n*---     CALL THE ARCHERAS ROUTINE TO DELETE THE DUPLICATE         ---*\n*---     VERSION.                                                  ---*\n*---                                                               ---*\n*---     IF THE USER DIDN'T PROVIDE A VERSION, WE'LL DO A READ ON  ---*\n*---     A GENERIC KEY, LOOKING FOR A PREVIOUS VERSION. WE'LL      ---*\n*---     INCREMENT THE VERSION NUMBER FROM THERE AND GO.           ---*\n*---------------------------------------------------------------------*\n         #IF   VRS,OFF,NEWVERS\n         MVC   RECVER,Q5           COPY IN HIS VERSION NUMBER\n         LA    R1,RECTT            LOAD PARAMETER POINTER VALUE\n         CALL  ARCHERAS            GO ERASE ANY DUPLICATE ITEM\n         B     HDRX                NOPE; GO WRITE THE HEADER RECORD\n*---------------------------------------------------------------------*\n*---     POSSIBLE NEW VERSION OF THE SAME ITEM                     ---*\n*---------------------------------------------------------------------*\nNEWVERS  DS    0H\n         MODCB RPL=(@RPL1),                                            X\n               AREA=(@BUF1),                                           X\n               AREALEN=(*,VS1LIM),                                     X\n               ARG=(@BUF2),                                            X\n               KEYLEN=41,                                              X\n               OPTCD=(DIR,GEN,KEQ,NUP),                                X\n               MF=(G,GENWK)\n         GET   RPL=(@RPL1)\n         LTR   R15,R15             DID WE GET A RECORD ??\n         BNZ   VERS1               NOPE; THIS IS VERSION ONE\nCHKVERS  DS    0H\n         MODCB RPL=(@RPL1),OPTCD=(FKS),MF=(G,GENWK)\n         ICM   R0,15,RECVER-RECTT(@BUF1) INSERT THE VERSION NUMBER\n         BCTR  R0,R0               ONE GREATER\n         STCM  R0,15,RECVER        IN NEW HEADER RECORD\n         B     HDRX                AND GO ---\nVERS1    DS    0H\n         MVC   RECVER,=F'-2'       STARTING VERSION NUMBER (TRUST ME)\nHDRX     DS    0H\n         XC    RECSEQ#,RECSEQ#     CLEAR THE SEQUENCE NUMBER\n         XC    RSRRCNT,RSRRCNT     RECORD COUNT INITS TO ZERO\n         L     R9,CHAIN            LOAD MEMBER CHAIN POINTER\n         LA    R8,RSRPDIR          POINT TO DIRECTORY AREA\n         #IF   NVSPS,ON,UMNAX      BRANCH IF PS INPUT DATASET\n         LA    R14,0               CLEAR A WORK REGISTER\n         IC    R14,19(,R9)         INSERT LENGTH/FLAGS\n         N     R14,=A(X'1F')       TRIM TO BARE LENGTH\n         SLL   R14,1               TIMES 2\n         LA    R14,12(,R14)        PLUS BASIC SECTION LENGTH\n         BCTR  R14,R0              DECREMENT FOR THE MOVE\n         EX    R14,UMNAMVC         COPY TO RECORD AREA\n         EX    R14,SAVEMAIN        COPY TO BLDL AREA, TOO\n         L     R15,MCNT            LOAD MEMBER COUNT\n         LA    R15,1(,R15)         INCREMENT BY ONE\n         ST    R15,MCNT            AND SAVE UPDATED COUNT\n         LA    R8,1(R14,R8)        POINT TO NEXT AREA\nUMNA0    DS    0H\n         NC    4(4,R9),4(R9)       ANY ALIASES ??\n         BZ    UMNA1               NOPE ---\n         L     R9,4(,R9)           POINT TO ALIAS ENTRY\n         LA    R14,0               CLEAR A WORK REGISTER\n         IC    R14,19(,R9)         INSERT LENGTH/FLAGS\n         N     R14,=A(X'1F')       TRIM TO BARE LENGTH\n         SLL   R14,1               TIMES 2\n         LA    R14,12(,R14)        PLUS BASIC SECTION LENGTH\n         BCTR  R14,R0              DECREMENT FOR THE MOVE\n         EX    R14,UMNAMVC         COPY TO RECORD AREA\n         L     R15,ACNT            LOAD ALIAS COUNT\n         LA    R15,1(,R15)         INCREMENT BY ONE\n         ST    R15,ACNT            AND SAVE UPDATED VALUE\n         LA    R8,1(R14,R8)        POINT TO NEXT AREA\n         B     UMNA0               AND LOOP FOR MORE ALIASES\nUMNAMVC  MVC   0(1,R8),8(R9)       COPY OF ALIAS DATA\nSAVEMAIN MVC   BLDLAREA(1),8(R9)   COPY OF MAIN DIR ENTRY\nUMNAX    DS    0H\n         MVC   0(8,R8),Q1          MOVE ITEM NAME AS MEMBER NAME\n         XC    8(4,R8),8(R8)       CLOBBER TTRZ AREA\n         LA    R8,12(,R8)          AND ACCOUNT FOR DUMMY DIR ENTRY\nUMNA1    DS    0H\n         SR    R8,@BUF2            COMPUTE BYTES USED\n         ST    R8,VS1LEN2          SAVE UPDATED COUNT\n         TM    RSRREC,X'C0'        RECFM = U ??\n         BNO   NOTU1               NOPE ---\n         OI    RSRLMOD,128         MARK AS LMOD TYPE ---\nNOTU1    DS    0H\n         MVC   0(RECKLEN,@BUF1),0(@BUF2) COPY KEY TO DATA RECORD\n         L     R0,VS1LEN2          SWITCH THE\n         LR    R1,@BUF2            COPY THE RECORD POINTER\n         BAL   R14,VSPUT           OUTPUT THE DUMMY HEADER RECORD\n         EJECT\n*---------------------------------------------------------------------*\n*---     NOW UNLOAD THE MEMBER DATA, COMPRESSING AS WE GO AND      ---*\n*---     KEEPING TRACK OF THE RECORD COUNT.                        ---*\n*---                                                               ---*\n*---     HERE'S WHERE THAT FANCY LITTLE BRANCH TABLE IS USED.      ---*\n*---------------------------------------------------------------------*\n         BAL   R14,PDSFIND         GO POINT OUT THE MEMBER\n         LA    R0,RECKLEN          LOAD KEY LENGTH\n         ST    R0,VS1LEN1          SAVE AS STARTING RECORD LENGTH\n         DROP  @BUF2               DROP THE HEADER RECORD\n         USING REC,@BUF1           MAP THE DATA RECORD\n         LA    R0,1                LOAD STARTING SEQ#\n         STCM  R0,15,RECSEQ#       INSERT INTO RECORD KEY\n         MVI   RECTT,#RTDATA       MARK AS A DATA RECORD\nUNLDLOOP DS    0H\n         BAL   R14,READ            GO GET A RECORD\n         LTR   R0,R0               ANY RECORD RETRIEVED ??\n         BZ    EOM                 NOPE; MEMBER IS DONE\n         L     R15,COUNT           LOAD RECORD COUNT\n         LA    R15,1(,R15)         INCREMENT BY ONE\n         ST    R15,COUNT           SAVE UPDATED COUNT\n         LR    R14,R1              COPY RECORD ADDRESS\n         L     R8,CMPWRK           POINT TO COMPACT WORK AREA\n         STH   R0,3(,R8)           SAVE ORIGINAL RECORD LENGTH\n         LA    R8,5(,R8)           POINT TO ACTUAL OUTPUT AREA\n         ST    R0,CALLIST+12\n         CALL  COMPACT,((R14),CALLIST+12,(R8)),MF=(E,CALLIST)\n         L     R14,CMPWRK          LOAD NEW RECORD POINTER\n         AH    R0,=H'2'            ACCOUNT FOR LENGTH FIELD\n         STCM  R0,7,0(R14)         STORE IN THE RECORD\n         #ADDBLK BUFFER=1,                                             X\n               RECORD=3(,R14),                                         X\n               LENGTH=0(R14),                                          X\n               RTN=VSPUT,                                              X\n               ERR=TOOLONG\n         B     UNLDLOOP            AND GO FOR ANOTHER RECORD\nEOM      DS    0H\n         #ADDBLK BUFFER=1,                                             X\n               RTN=VSPUT,                                              X\n               LAST=YES\n         MVI   RECTT,#RTHDR        MARK AS A HEADER RECORD\n         XC    RECSEQ#,RECSEQ#     CLOBBER THE SEQUENCE NUMBER\n         MODCB RPL=(@RPL1),AREA=(@BUF1),ARG=(@BUF1),                   X\n               AREALEN=(S,VS1LIM),                                     X\n               OPTCD=(FKS,MVE,UPD),MF=(G,GENWK)\n         GET   RPL=(@RPL1)         READ THE HEADER RECORD\n         MVC   RSRRCNT,COUNT       MOVE RECORD COUNT TO HEADER RECORD\n         L     R0,FCOUNT           LOAD TOTAL RECORD COUNT\n         A     R0,COUNT            AND MEMBER SIZE\n         ST    R0,FCOUNT           STORE UPDATED COUNT\n         XC    COUNT,COUNT         AND RESET THE COUNTER\n         PUT   RPL=(@RPL1)         UPDATE THE RECORD\n         MODCB RPL=(@RPL1),OPTCD=NUP,MF=(G,GENWK)\n         #FORMAT RECTT,,UNLDED\n         #PUT  LINE\nKILLED   DS    0H\n         L     R9,CHAIN            LOAD THE CHAIN POINTER\n         LTR   R9,R9               WAS THERE A CHAIN ??\n         BZ    ENDITALL            NOPE; ALL DONE\n         L     R8,4(,R9)           ALIAS LINK ??\n         LTR   R8,R8               REALLY THERE ??\n         BZ    FREE                NOPE ---\n         #IF   RETA,OFF,FREE       NO AUTOMATIC ALIASES\n         MODCB RPL=(@RPL1),AREA=(@BUF1),ARG=(@BUF1),                   X\n               AREALEN=(S,VS1LIM),                                     X\n               OPTCD=(FKS,MVE,UPD),MF=(G,GENWK)\n         GET   RPL=(@RPL1)         READ THE HEADER RECORD\n         #SET  RSRHALS,ON          SHOW THAT WE HAVE ALIASES\n         PUT   RPL=(@RPL1)         UPDATE THE RECORD\n         MODCB RPL=(@RPL1),OPTCD=NUP,MF=(G,GENWK)\n         DROP  @BUF1\n         USING REC,@BUF2\n         MVC   RECAN(44),1(@BUF1)  COPY ORIGINAL KEY\n         MVC   RECN(44),1(@BUF1)   BASIC ALIAS VALUES\n         MVI   RECTT,#RTHDR        MARK AS A HEADER RECORD\n         #SET  RSRALIAS,ON         SHOW THIS AS AN ALIAS\n         MODCB RPL=(@RPL1),AREA=(@BUF2),ARG=(@BUF2),                   X\n               RECLEN=RECAVER+4-REC,MF=(G,GENWK)\nADDA0    DS    0H\n         MVC   RECVER,RECAVER      START WITH SAME VERSION VALUE\n         MVC   RECN(8),8(R8)       MOVE IN THE ALIAS NAME\n         MVC   RECN+8(2),=CL2' '\nPUTA1    DS    0H\n         PUT   RPL=(@RPL1)         OUTPUT THE ALIAS RECORD\n         LTR   R15,R15             WRITE OK ??\n         BZ    ADDA1               YES ---\n         ICM   R15,15,RECVER       INSERT THE VERSION NUMBER\n         BCTR  R15,R0              INCREMENT BY ONE\n         STCM  R15,15,RECVER       SAVE UPDATED VERSION\n         B     PUTA1               AND TRY AGAIN ---\nADDA1    DS    0H\n         #FORMAT RECTT,,ALIASED\n         #PUT  LINE\n         L     R8,4(,R8)           POINT TO NEXT ALIAS LINK\n         LTR   R8,R8               ALIAS PRESENT ??\n         BNZ   ADDA0               YES; ADD IT\nFREE     DS    0H\n         MVC   CHAIN,0(R9)         UNLINK THE MAIN ENTRY\n         B     MEMBERS             AND CONTINUE UNLOADING\nENDITALL DS    0H\n         L     R0,TCOUNT           LOAD TOTAL RECORD COUNT\n         A     R0,FCOUNT           ADD FUNCTION COUNT\n         ST    R0,TCOUNT           SAVE UPDATED COUNT\n         #ERR  MSG=7\n         L     R0,TCOUNT           LOAD TOTAL-RECORD COUNT\n         LTR   R0,R0               ZERO COUNT ??\n         BZ    END1                YES ---\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,TCMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\nEND1     DS    0H\n         L     R0,MCNT             LOAD MEMBER COUNT\n         LTR   R0,R0               ZERO COUNT ??\n         BZ    END2                YES ---\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,MCMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\nEND2     DS    0H\n         L     R0,ACNT             LOAD ALIAS COUNT\n         LTR   R0,R0               ZERO COUNT ??\n         BZ    END3                YES ---\n         CVD   R0,DWORK            DECIMALIZE IT\n         MVC   LINE,ACMSG          COPY IN THE MESSAGE SKELETON\n         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS\n         #PUT  LINE                AND OUTPUT THE RESULTS\nEND3     DS    0H\n         CLC   ACB1,=F'0'          WAS ACB EVER OPENED ??\n         BE    NOACB               NOPE ---\n         LA    R1,VSAM1DD          POINT TO THE DDNAME\n         LA    R0,4                SET 'CLOSE' REQUEST\n         CALL  ARCHVSOP            CALL THE VSAM 'CLOSE' ROUTINE\nNOACB    DS    0H\n         BAL   R14,NVSCLOSE        GO CLOSE THE INPUT FILE\n         FREEMAIN R,SP=84\n         L     R13,4(,R13)         LOAD BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ALWAYS RC = 0\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\n         SPACE 3\n*---------------------------------------------------------------------*\n*---     IF WE REACH THIS LABEL, WE'VE GOT AT LEAST ONE RECORD     ---*\n*---     THAT CANNOT BE MADE TO FIT IN THE OUTPUT ARCHIVE          ---*\n*---     CLUSTER. ISSUE AN ERROR MESSAGE AND ERASE THE             ---*\n*---     PARTIALLY-COPIED ITEM.                                    ---*\n*---------------------------------------------------------------------*\nTOOLONG  DS    0H\n         #IF   IOGOING,OFF,NOWAIT  LET CURRENT I/O END\n         CHECK PDSDECB\nNOWAIT   DS    0H\n         #SET  IOGOING,OFF\n         #FORMAT 0(,@BUF2),'* ERROR *',LNGREC\n         #PUT  LINE                PRINT THE ERROR\n         LR    R1,@BUF2            POINT TO THE RECORD KEY\n         CALL  ARCHERAS            DELETE PARTIAL ITEM\n         B     KILLED              GO FOR ANOTHER ITEM\nLNGREC   DC    AL1(LNGRECE-LNGRECS)\nLNGRECS  DC    C' CANNOT BE UNLOADED. AT LEAST ONE RECORD IS TOO LONG.'\nLNGRECE  EQU   *\n         TITLE 'BPAM ''FIND'' ROUTINE'\n*---------------------------------------------------------------------*\n*---     THIS SHORT LITTLE ROUTINE DOES A 'FIND' FOR A MEMBER OF   ---*\n*---     THE INPUT PARTITIONED DATASET.                            ---*\n*---------------------------------------------------------------------*\nPDSFIND  DS    0H\n         STM   R14,R12,IOSAVE      SAVE ENTRY REGISTERS\n         XC    NOTELIST,NOTELIST   RESET NOTELIST TTR WORD\n         MVC   BLOCKWDS(8),=A(1,0)\n         #IF   NVSPO,OFF,NOFIND    NO FIND FOR NON-PO D.S.\n         L     R3,NDCBA            LOAD BPAM DCB ADDRESS\n         LA    R3,0(,R3)           FORCE IT POSITIVE ...\n         TM    BLDLAREA+11,X'60'   ANY TTR'S IN USER DATA ??\n         BNM   JSTFIND             NOPE ---\n         MVC   NOTELIST,BLDLAREA+16 COPY NOTELIST TTR\n         NC    NOTELIST,NOTELIST   ANY PRESENT ??\n         BZ    JSTFIND             NOPE ---\n         CLI   NOTELIST+3,0        REALLY A SCTR TABLE PTR ??\n         BE    JSTFIND             YES ---\n         MVI   NOTELIST+3,0        PURIFY THE TTRN VALUE\n         POINT (3),NOTELIST        POINT TO THE NOTE LIST\n         XC    PDSDECB,PDSDECB     CLEAR THE DECB AREA\n         LM    R2,R3,BPBUF1        LOAD BUFFER ADDRESSES\n         LR    R4,R2               AND SWITCH\n         STM   R3,R4,BPBUF1        THE PDS BUFFERS\n         XC    PDSDECB(DECBL),PDSDECB  CLEAR OUT THE ECB\n         L     R2,NDCBA            LOAD THE PDS DCB ADDRESS\n         READ  PDSDECB,SF,(2),(4),'S',MF=E\n         CHECK PDSDECB             YES, LET IT COMPLETE\n         #SET  IOGOING,OFF\n         NOTE  (2)                 READ THE BLOCK'S ADDRESS\n         L     R2,PDSDECB+16       LOAD IOB ADDRESS\n         L     R3,PDSDECB+8        LOAD DCB ADDRESS FROM DECB\n         LH    R3,62(,R3)          LOAD PDS BLOCK SIZE\n         SH    R3,14(,R2)          SUBTRACT CCW RESIDUAL COUNT\n         L     R2,BPBUF2           LOAD BUFFER ADDRESS\n         SH    R2,=H'4'            BACK UP TO 'NOTE' WORD\n         ST    R1,0(,R2)           STORE BLOCK'S 'TTR'\n         LA    R2,4(,R2)           RESTORE ORIGINAL VALUE\n         AR    R3,R2               POINT TO END OF BUFFER\n         BCTR  R3,R0               BACK UP A BYTE AT END\n         STM   R2,R3,BLOCKWDS      STORE NEW BUFFER POINTERS\nJSTFIND  DS    0H\n         L     R3,NDCBA            LOAD BPAM DCB ADDRESS\n         XC    GENWK(4),GENWK      CLEAR A SMALL AREA\n         MVC   GENWK(3),BLDLAREA+8 COPY STARTING TTR\n         POINT (3),GENWK           POINT OUT THE MEMBER\n         XC    PDSDECB(DECBL),PDSDECB  CLEAR OUT THE ECB\nNOFIND   DS    0H\n         LM    R2,R3,BPBUF1        LOAD BUFFER ADDRESSES\n         LR    R4,R2               AND SWITCH\n         STM   R3,R4,BPBUF1        THE PDS BUFFERS\n         XC    PDSDECB(DECBL),PDSDECB  CLEAR OUT THE ECB\n         L     R2,NDCBA            LOAD THE PDS DCB ADDRESS\n         READ  PDSDECB,SF,(2),(4),'S',MF=E\n         #SET  IOGOING,ON          SHOW  READ OUTSTANDING\n         LM    R14,R12,IOSAVE      RESTORE REGISTERS\n         BR    R14                 RETURN TO LOCAL CALLER\n         SPACE 3\n* SOME OF MY ERROR PROCESSING GOES HERE\nNODDERR  DS    0H\n         #ERR  MSG=1\n         #ERR  MSG=6\n         B     ENDITALL\nORGERR   DS    0H\n         #ERR  MSG=3\n         #ERR  MSG=6\n         B     ENDITALL\nERRDEV   DS    0H\n         #ERR  MSG=2\n         #ERR  MSG=6\n         B     ENDITALL\nGENQ     DS    0H\n         #ERR  MSG=8\n         #ERR  MSG=6\n         B     ENDITALL\nGENSEQ   DS    0H\n         #ERR  MSG=9\n         #ERR  MSG=6\n         B     ENDITALL\n         TITLE 'OPEN NONVSAM INPUT DATASET '\n*---------------------------------------------------------------------*\n*---     THIS LITTLE LOCAL SUBROUTINE DOES SEVERAL THINGS          ---*\n*---     NECESSARY PRIMARILY FOR LOAD-MODULE RECOGNITION AND       ---*\n*---     PROCESSING. FIRST AND FOREMOST, WE DETERMINE THE DSORG    ---*\n*---     OF THE INPUT DATASET.  IF INPUT IS A SEQUENTIAL DATASET,  ---*\n*---     WE CAN ASSUME THAT ONLY ONE DCB WILL BE NEEDED.  IF THE   ---*\n*---     INPUT DATASET IS A PDS, WE NEED AT LEAST TWO DCBS; ONE    ---*\n*---     FOR DATA AND ANOTHER FOR THE DIRECTORY INFORMATION        ---*\n*---     PROCESSED BY ARCHDIR.  HERE'S A VERY SIMPLISTIC VIEW OF   ---*\n*---     THE PROCESSING HERE.  (FURTHER MODS FOR PROCESSING        ---*\n*---     PANVALET LIBRARIES ARE PLANNED BUT NOT YET IMPLEMENTED.)  ---*\n*---                                                               ---*\n*---     1. DETERMINE THE DSORG OR THE DATASET. IF NOT PS OR PO,   ---*\n*---        WRITE NASTY MESSAGES TO THE USER AND QUIT RIGHT HERE.  ---*\n*---                                                               ---*\n*---     2. BUILD AND OPEN THE PRIMARY DCB.  SINCE WE USE BSAM     ---*\n*---        FOR INPUT OF SEQUENTIAL DATASETS, WE CAN (ALMOST) USE  ---*\n*---        THE SAME DCB FOR BOTH SEQUENTIAL AND PARTITIONED       ---*\n*---        DATASETS.  WE ONLY NEED TO CHANGE THE DSORG VALUE IN   ---*\n*---        THE DCB.  DURING THE 'OPEN' PROCESS, AN EXIT WILL      ---*\n*---        BUILD A BUFFER POOL OF TWO BUFFERS, EACH BUFFER        ---*\n*---        HAVING 4 EXTRA BYTES. (THESE EXTRA BYTES ARE USED TO   ---*\n*---        SAVE THE TTR OF THE RECORD AFTER EACH 'CHECK' BY THE   ---*\n*---        READ ROUTINE.)  BUFFERS ARE 'GETBUF'ED AND SAVE IN     ---*\n*---        THE ARCHIVER MAIN WORK AREA.                           ---*\n*---                                                               ---*\n*---     3. IF THE DSORG IS PO, WE NEED ONE ADDITIONAL STEP: READ  ---*\n*---        IN THE DIRECTORY OF THE PDS, USING THE ARCHDIR         ---*\n*---        ROUTINE. FOR THIS, WE NEED A SECOND DCB OPEN'ED FOR    ---*\n*---        THE DIRECTORY ONLY. WE THEN CALL THE ARCHIDR ROUTINE,  ---*\n*---        WHICH READS IN THE DIRECTORY AND PERFORMS ANY          ---*\n*---        FILTERING OF NAMES AS SPECIFIED BY USER-SUPPLIED       ---*\n*---        CONTROL STATEMENTS.                                    ---*\n*---                                                               ---*\n*---     NOTE: THE ARCHIVER MAKES NO ATTEMPT TO REASSEMBLE OR      ---*\n*---     RECONSTRUCT A SPANNED RECORD.                             ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nOPNVI    DS    0H\n         STM   R14,R12,IOSAVE      SAVE THE ENTRY REGISTERS\n*        #IF   NVPAN,ON,PANOPEN    REALLY A PANLIB ??\n*---\n*---     BUILD A DCB, TO START, FOR DSORG CHECKING\n*---\n         GETMAIN R,LV=BSDCBL,SP=10 GRAB STORAGE FOR BPAM DCB\n         ST    R1,NDCBA            AND STORE ADDRESS IN ARCHIVWA\n         MVI   NDCBA,X'80'         BUILD OPEN PARM LIST\n         MVC   0(BSDCBL,R1),BSDCB  COPY DCB TO DYNAMIC AREA\n         USING IHADCB,R1           BASE THE DCB DSECT\n         MVC   DCBDDNAM,NVSAMDD    MOVE IN THE DDNAME\n         DROP  R1\n*---\n*---     GET THE VOLSER FROM THE UCB, STARTING FROM THE TIOT.\n*---\n         NC    TIOTA,TIOTA         HAVE WE ALREADY DONE THIS ??\n         BNZ   OPNVI1              YES ---\n         MVC   CALLIST(EXTL),EXTRPARM COPY PARMLIST FOR EXTRACT\n         EXTRACT TIOTA,'S',FIELDS=TIOT,MF=(E,CALLIST) LOCATE THE TIOT\n         L     R1,TIOTA            LOAD THE TIOT POINTER\n         LA    R1,24(,R1)          POINT TO THE FIRST TIOE\n         ST    R1,TIOTA            SAVE UPDATED ADDRESS\nOPNVI1   DS    0H\n         L     R1,TIOTA            LOAD TIOT ELEMENT POINTER\nOPNVI2   DS    0H\n         CLI   0(R1),0             AT TIOT END ??\n         BE    NODDERR             YES; DD STATEMENT IS MISSING\n         CLC   NVSAMDD,4(R1)       IS THIS THE DD ENTRY ??\n         BE    OPNVI3              YES; GO FETCH UCB ADDR\n         IC    R0,0(,R1)           INSERT TIOE LENGTH\n         N     R0,=F'255'          TRIM TO JUST THE LENGTH\n         AR    R1,R0               BUMP TO NEXT ENTRY\n         B     OPNVI2              AND CONTINUE THE SEARCH\nOPNVI3   DS    0H\n         L     R1,16(,R1)          LOAD UCB POINTER\n         N     R1,=A(X'FFFFFF')    TRIM GARBAGE BYTES\n         MVC   VOLSER,28(R1)       COPY THE VOLSER\n         MVC   DEVT,16(R1)         AND UCB TYPE\n         TM    DEVT+2,X'A0'        IS THIS A DASD OR TAPE DEVICE ??\n         BZ    ERRDEV              NOPE; INVALID AS HELL\n*---\n*---     GET THE DSNAME. DISREGARD ANY MEMBER NAME\n*---\n         L     R2,NDCBA            LOAD THE DCB ADDRESS\n         USING IHADCB,R2           AND BASE ITS DSECT\n         LA    R0,DCBJFC           LOAD EXIT LIST POINTER\n         STCM  R0,7,DCBEXLSA       SAVE IN THE DCB\n         LA    R0,JFC              POINT TO JFCB AREA\n         ST    R0,DCBJFC           SAVE IN EXIT LIST\n         MVI   DCBJFC,X'87'        EXIT TYPE, LAST FLAG\n         RDJFCB ,MF=(E,NDCBA)      READ THE JFCB\n         DROP  R2\n*---\n*---     BUILD AND EXECUTE THE CAMLIST/OBTAIN SEQUENCE IF DASD\n*---     DATASET. USE THE FORMAT-1 DSCB TO DETERMINE IF THE\n*---     DATASET IS PARTITIONED OR SEQUENTIAL.  IF THE DATASET\n*---     IS SEQUENTIAL OR TAPE, WE BYPASS ANY BPAM STUFF.\n*---\n         TM    DEVT+2,X'80'        IS IT A TAPE DEVICE ??\n         BO    OPNVI4              YES; ALWAYS SEQUENTIAL\n         MVC   CALLIST(LCAMLST),CAMLST COPY CAMLIST TO WORK AREA\n         LA    R0,JFC              LOAD DSNAME POINTER\n         ST    R0,CALLIST+4        SAVE IN CAMLIST AREA\n         LA    R0,VOLSER           POINT TO VOLSER\n         ST    R0,CALLIST+8        SAVE IN CAMLIST AREA\n         LA    R0,GENWK            POINT TO DSCB AREA\n         ST    R0,CALLIST+12       SAVE IN CAMLIST AREA\n         OBTAIN CALLIST            FETCH THE DSCB\n         LA    R1,GENWK            POINT TO THE WORK AREA\n         USING DS1FMTID,R1         AND BASE THE DSECT PORTION\n         TM    DS1DSORG,DS1DSGPS   SEQUENTIAL ??\n         BO    OPNVI4              YES ---\n         TM    DS1DSORG,DS1DSGPO   PARTITIONED ??\n         BO    OPNVI5              YES ---\n         B     ORGERR              UNABLE TO PROCESS ANY OTHER DSORG\n         DROP  R1\n*---\n*---     SET THE DSORG IN THE PRIMARY DCB ACCORDING TO THE VALUE\n*---     FOUND IN THE FORMAT-1 DSCB.  ALSO, SET A PAIR OF SPECIAL\n*---     FLAGS IN THE ARCHIVER WORK AREA.  THIS ALLOWS ME TO\n*---     DETERMINE IF I'M REALLY PROCESSING A PDS, REQUIRING\n*---     FIND'S, ETC. OR JUST BE WARY OF AN END-OF-FILE THAT WILL\n*---     ULTIMATELY TERMINATE THE PROCESS.  IT ALSO DETERMINES\n*---     WHETHER I NEED A DIRECTORY DCB, FOR LATER.\n*---\nOPNVI4   DS    0H\n         #IF   GENM,ON,GENSEQ      INVALID GENERIC FOR PS DATASET\n         #SET  NVSPS,ON            SET THE DSORG FLAG\n         #SET  NVSPO,OFF           SET THE DSORG FLAG\n         L     R2,NDCBA            LOAD DCB ADDRESS\n         USING IHADCB,R2\n         MVC   DCBDSORG,=XL2'00'   CLEAR DSORG BIT(S)\n         OI    DCBDSRG1,DCBDSGPS   MARK AS 'PS' ORGANIZATION\n         DROP  R2\n         B     OPNVI6              GO SET UP THE VSAM I/O BLOCKS,ETC.\nOPNVI5   DS    0H\n         #SET  NVSPO,ON            SET THE DSORG FLAG\n         #SET  NVSPS,OFF           SET THE DSORG FLAG\n         L     R2,NDCBA            LOAD DCB ADDRESS\n         USING IHADCB,R2\n         MVC   DCBDSORG,=XL2'00'   CLEAR DSORG BIT(S)\n         OI    DCBDSRG1,DCBDSGPO   MARK AS 'PO' ORGANIZATION\n         DROP  R2\n         GETMAIN R,LV=QSDCBL,SP=10 GRAB STORAGE FOR BPAM DCB\n         ST    R1,NDCBB            AND STORE ADDRESS IN ARCHIVWA\n         MVI   NDCBB,X'80'         BUILD OPEN PARM LIST\n         MVC   0(QSDCBL,R1),QSDCB COPY DCB TO DYNAMIC AREA\n         USING IHADCB,R1           BASE THE DSECT\n         MVC   DCBDDNAM,NVSAMDD    MOVE IN THE DDNAME\n         DROP  R1                  DROP THE DSECT\n         OPEN  (,INPUT),MF=(E,NDCBB) OPEN THE DIRECTORY DCB\n         CALL  ARCHDIR             BUILD DIRECTORY CHAIN STUFF\nOPNVI6   DS    0H\n*---\n*---     SET THE ADDRESS OF MY 'COMPLETION' EXIT INTO THE DCB AND\n*---     PROCEED WITH THE NECESSARY OPEN, ETC.\n*---\n         L     R2,NDCBA            POINT TO PRIMARY DCB\n         USING IHADCB,R2\n         LA    R0,OPNVI13          LOAD EXIT LIST POINTER\n         STCM  R0,7,DCBEXLSA       SAVE IN THE DCB\n         OPEN  (,INPUT),MF=(E,NDCBA) OPEN THE DCB\n*---\n*---     GRAB A PAIR OF BUFFERS FROM THE POOL BUILT DURING OPEN\n*---     PROCESSING. WE ALWAYS USE BUFFERS THAT ARE 4 BYTES\n*---     LONGER THAN THE BLKSIZE OF THE DATASET. AFTER EACH\n*---     'CHECK', WE DO A 'NOTE' AND SAVE THE BLOCK'S TTR IN THIS\n*---     'PREFIX' FOR LATER.  IT'S NECESSARY FOR RE-BUILDING THE\n*---     NOTE LIST, IF PRESENT, IN A LOAD MODULE.  MORE ABOUT\n*---     LOAD MODULES LATER.  AT THIS STAGE, WE ASSUME THAT WE\n*---     ALWAYS NEED THE TTR.\n*---\n         GETBUF (2),(3)            GRAB A BUFFER\n         GETBUF (2),(4)            AND ANOTHER BUFFER\n         LA    R3,4(,R3)           POINT PAST 'PREFIX'\n         LA    R4,4(,R4)           -- DITTO --\n         STM   R3,R4,BPBUF1        SAVE POINTERS IN WORK AREA\n         #SET  BUFUSED,OFF         ALL BUFFERS EMPTY\n         #SET  IOGOING,OFF         NO I/O IN PROGRESS\n         MVC   BLOCK,=X'47F0E000'  INIT. THE DEBLOCKING BRANCH\n         MVC   NVSRECFM,DCBRECFM\n         MVC   NVSLRECL,DCBLRECL\n         MVC   NVSBLKL,DCBBLKSI\n         MVC   NVSDSORG,DCBDSORG\n*---\n*---     USING THE RECFM AS A GUIDE, SET THE S-TYPE ADDRESS OF\n*---     THE APPROPRIATE DEBLOCKER INTO THE BRANCH INSTRUCTION AT\n*---     'BLOCK'\n*---\n         TM    DCBRECFM,DCBRECU    U-FORMAT ??\n         BNO   OPNVI7              NOPE ---\n         MVC   BLOCK+2(2),=S(READU) SET 'U' ROUTINE\n         B     OPNVI12             SCAT ---\nOPNVI7   DS    0H\n         TM    DCBRECFM,DCBRECV+DCBRECBR VB FORMAT ??\n         BNO   OPNVI8              NOPE ---\n         MVC   BLOCK+2(2),=S(READVB) SET 'VB' ROUTINE\n         B     OPNVI12             SCAT ---\nOPNVI8   DS    0H\n         TM    DCBRECFM,DCBRECF+DCBRECBR FB FORMAT ??\n         BNO   OPNVI9              NOPE ---\n         MVC   BLOCK+2(2),=S(READFB) SET 'FB' ROUTINE\n         B     OPNVI12             SCAT ---\nOPNVI9   DS    0H\n         TM    DCBRECFM,DCBRECV    V FORMAT ??\n         BNO   OPNVI10             NOPE ---\n         MVC   BLOCK+2(2),=S(READV) SET 'V' ROUTINE\n         B     OPNVI12             SCAT ---\nOPNVI10  DS    0H\n         TM    DCBRECFM,DCBRECF    V FORMAT ??\n         BNO   OPNVI11             NOPE ---\n         MVC   BLOCK+2(2),=S(READF) SET 'F' ROUTINE\n         B     OPNVI12             SCAT ---\nOPNVI11  DS    0H\n         #PUT  =CL133'- UNABLE TO DETERMINE NONVSAM DATASET FORMAT'\n         ABEND 999,DUMP\nOPNVI12  DS    0H\n         L     R0,=F'32768'        LOAD COMPRESS MAX LENGTH\n         ICM   R0,8,=AL1(10)       INSERT THE SUBPOOL NUMBER\n         GETMAIN R,LV=(0)\n         STM   R0,R1,CMPWRKL       STORE COMPRESS WORK-AREA ADDRESS\n         LM    R14,R12,IOSAVE      RELOAD ENTRY REGISTERS\n         BR    R14                 AND RETURN TO LOCAL CALLER\n*---\n*---     THIS IS A SHORT AND SNEAKY DCB COMPLETION EXIT. ITS ONLY\n*---     PURPOSE IS TO ESTABLISH THE BUFFER POOL FOR THE PRIMARY\n*---     DCB. THIS POOL CONTAINS TWO BUFFERS, EACH BEING 4 BYTES\n*---     LONGER THAN THE BLKSIZE OF THE DCB.\n*---\n*---     NOTE: THE GETPOOL ROUTINE WILL FAIL IF THE HIGH-ORDER\n*---     BIT OF THE DCB ADDRESS IS NOT ZERO. SOME SPECIAL GLITCH\n*---     IN THE IECQBFG1 CODE FOR A SPECIAL APPLICATION\n*---     SOMEWHERE.\n*---\nOPNVI13  DS    0F\n         DC    XL1'85',AL3(OPNVI13+4)\n         LA    R1,0(,R1)           PURIFY DCB ADDRESS\n         LH    R0,DCBBLKSI-IHADCB(,R1) LOAD THE BLKSIZE\n         AH    R0,=H'4'            FOR LATER ---\n         ICM   R0,12,=H'2'         BUFFER COUNT\n         GETPOOL (1),(0)           BUILD A BUFFER POOL\n         BR    R14                 AND RETURN TO O/C/EOV\n         SPACE 3\nBSDCB    DCB   DSORG=PS,MACRF=(RP,WP),DDNAME=X,EODAD=EODAD\nBSDCBL   EQU   *-BSDCB\nQSDCB    DCB   DSORG=PS,MACRF=GL,DDNAME=Y,RECFM=U,BLKSIZE=256\nQSDCBL   EQU   *-QSDCB\n         TITLE 'BSAM/BPAM INPUT ROUTINES '\n*---------------------------------------------------------------------*\n*---     REGS AT ENTRY: R14 --> RETURN ADDRESS                     ---*\n*---                                                               ---*\n*---     REGISTERS 14, 15, AND 2-12 ARE SAVED AND RESTORED         ---*\n*---                                                               ---*\n*---          AT EXIT:                                             ---*\n*---              R0 ::= LOGICAL RECORD LENGTH                     ---*\n*---              R1 --> LOGICAL RECORD                            ---*\n*---                                                               ---*\n*---     EOF SIGNALLED BY A ZERO LOGICAL RECORD LENGTH             ---*\n*---                                                               ---*\n*---     IN THE SPECIAL CASE OF RECFM=U, R1 ACTUALLY POINTS TO A   ---*\n*---     FULLWORD RECORD PREFIX CONTAINING THE TTR OF THE RECORD.  ---*\n*---                                                               ---*\n*---     THIS IS FOR LOAD MODULE PROCESSING AND CANNOT BE BYPASSED ---*\n*---------------------------------------------------------------------*\nREAD     DS    0H\n         STM   R14,R12,IOSAVE      SAVE ENTRY REGISTERS\n         LM    R2,R3,BLOCKWDS      LOAD BUFFER POINTER STUFF\n         CR    R2,R3               PAST END OF BLOCK ??\n         BH    READ2               YES, GO FOR THE NEXT BLOCK\nREAD1    DS    0H\n         B     BLOCK               BRANCH TO DEBLOCKING ROUTINE\n*---------------------------------------------------------------------*\n*---     START PROCESSING A NEW BLOCK                              ---*\n*---------------------------------------------------------------------*\nREAD2    DS    0H\n         #IF   IOGOING,OFF,READ4   IS A READ IN PROGRESS ??\n         CHECK PDSDECB             YES, LET IT COMPLETE\n         L     R1,NDCBA            LOAD DCB ADDRESS\n         NOTE  (1)                 READ THE BLOCK'S ADDRESS\n         L     R2,PDSDECB+16       LOAD IOB ADDRESS\n         L     R3,PDSDECB+8        LOAD DCB ADDRESS FROM DECB\n         LH    R3,62(,R3)          LOAD PDS BLOCK SIZE\n         SH    R3,14(,R2)          SUBTRACT CCW RESIDUAL COUNT\n         CLC   NOTELIST,=F'0'      WAS THERE A NOTE LIST ??\n         BE    READ3               NOPE ---\n         CLM   R1,14,NOTELIST      WAS THIS IT ??\n         BE    EODAD               YES; WE'RE ALL DONE\nREAD3    DS    0H\n         L     R2,BPBUF2           LOAD BUFFER ADDRESS\n         SH    R2,=H'4'            BACK UP TO 'NOTE' WORD\n         ST    R1,0(,R2)           STORE BLOCK'S 'TTR'\n         LA    R2,4(,R2)           RESTORE ORIGINAL VALUE\n         AR    R3,R2               POINT TO END OF BUFFER\n         BCTR  R3,R0               BACK UP A BYTE AT END\n         L     R14,NDCBA           LOAD DCB ADDRESS\n         USING IHADCB,R14\n         TM    DCBRECFM,DCBRECV+DCBRECBR VB RECORD FORMAT ??\n         BNO   *+8                 NOPE ---\n         DROP  R14\n         LA    R2,4(,R2)           YES; ACCOUNT FOR BDW\n         STM   R2,R3,BLOCKWDS      STORE NEW BUFFER POINTERS\nREAD4    DS    0H\n         LM    R2,R3,BPBUF1        LOAD BUFFER ADDRESSES\n         LR    R4,R2               AND SWITCH\n         STM   R3,R4,BPBUF1        THE PDS BUFFERS\n         XC    PDSDECB(DECBL),PDSDECB  CLEAR OUT THE ECB\n         L     R2,NDCBA            LOAD THE PDS DCB ADDRESS\n         READ  PDSDECB,SF,(2),(4),'S',MF=E\n         #SET  IOGOING,ON          SHOW  READ OUTSTANDING\n         LM    R2,R3,BLOCKWDS\n         B     READ1               AND GO START DEBLOCKING\n*---------------------------------------------------------------------*\n*---     END OF FILE (OR END OF MEMBER) EXIT RTN                   ---*\n*---------------------------------------------------------------------*\nEODAD    DS    0H\n         #SET  IOGOING,OFF         TURN OFF THE DEBLOCKING FLAG\n         LM    R14,R12,IOSAVE      RESTORE ENTRY REGISTERS\n         LA    R0,0\n         LA    R1,0\n         BR    R14                 AND RETURN TO CALLER\n*---------------------------------------------------------------------*\n*---     FIXED, UNBLOCKED RECORDS.                                 ---*\n*---------------------------------------------------------------------*\nREADF    DS    0H\n         LA    R1,0(,R2)           LOAD LRECL POINTER\n         LA    R0,0                CLEAR A REGISTER\n         L     R15,NDCBA           LOAD DCB ADDRESS\n         LH    R0,62(,R15)         LOAD BLKSIZE\n         AR    R2,R0               BUMP TO NEXT LOGICAL RECORD\n         STM   R2,R3,BLOCKWDS      RESAVE POINTER STUFF\n         STM   R0,R1,IOSAVE+8      SET RETURN VALUES\n         LM    R14,R12,IOSAVE      RESTORE REGISTERS\n         BR    R14                 RETURN TO CALLER\n*---------------------------------------------------------------------*\n*---     FIXED, BLOCKED RECORDS.                                   ---*\n*---------------------------------------------------------------------*\nREADFB   DS    0H\n         LA    R1,0(,R2)           LOAD LRECL POINTER\n         L     R15,NDCBA           LOAD DCB ADDRESS\n         LH    R0,82(,R15)         LOAD LRECL FROM DCB\n         AR    R2,R0               BUMP TO NEXT LOGICAL RECORD\n         STM   R2,R3,BLOCKWDS      RESAVE POINTER STUFF\n         STM   R0,R1,IOSAVE+8      SET RETURN VALUES\n         LM    R14,R12,IOSAVE      RESTORE REGISTERS\n         BR    R14                 RETURN TO CALLER\n*---------------------------------------------------------------------*\n*---     VARIABLE, UNBLOCKED RECORDS.                              ---*\n*---------------------------------------------------------------------*\nREADV    DS    0H\n         LA    R1,4(,R2)           LOAD LRECL POINTER\n         LH    R0,0(,R2)           LOAD LRECL FOR RETURN\n         AR    R2,R0               BUMP TO NEXT LOGICAL RECORD\n         SH    R0,=H'4'            ACCOUNT FOR RDW WORD\n         STM   R2,R3,BLOCKWDS      RESAVE POINTER STUFF\n         STM   R0,R1,IOSAVE+8      SET RETURN VALUES\n         LM    R14,R12,IOSAVE      RESTORE REGISTERS\n         BR    R14                 RETURN TO CALLER\n*---------------------------------------------------------------------*\n*---     VARIABLE, BLOCKED RECORDS.                                ---*\n*---------------------------------------------------------------------*\nREADVB   DS    0H\n         LA    R1,4(,R2)           LOAD LRECL POINTER\n         LH    R0,0(,R2)           LOAD LRECL FOR RETURN\n         AR    R2,R0               BUMP TO NEXT LOGICAL RECORD\n         STM   R2,R3,BLOCKWDS      RESAVE POINTER STUFF\n         SH    R0,=H'4'            ACCOUNT FOR RDW\n         STM   R0,R1,IOSAVE+8      SET RETURN VALUES\n         LM    R14,R12,IOSAVE      RESTORE REGISTERS\n         BR    R14                 RETURN TO CALLER\n*---------------------------------------------------------------------*\n*---     UNDEFINED-FORMAT RECORDS.                                 ---*\n*---------------------------------------------------------------------*\nREADU    DS    0H\n         LA    R0,1(,R3)           COPY RECORD END ADDRESS\n         SR    R0,R2               SUBTRACT STARTING ADDRESS\n         AH    R0,=H'4'            ACCOUNT FOR 'NOTE' WORD\n         LA    R1,0(,R2)           LOAD LRECL POINTER\n         SH    R1,=H'4'            BACK UP TO 'NOTE' WORD\n         LA    R2,1(,R3)           POINT TO NEXT(HA HA) RECORD\n         STM   R2,R3,BLOCKWDS      RESAVE POINTER STUFF\n         STM   R0,R1,IOSAVE+8      SET RETURN VALUES\n         LM    R14,R12,IOSAVE      RESTORE REGISTERS\n         BR    R14                 RETURN TO CALLER\n         TITLE 'BSAM/BPAM CLOSE ROUTINE'\n*---------------------------------------------------------------------*\n*---     THIS LITTLE ROUTINE CLOSES THE NONVSAM DATASET (ALL       ---*\n*---     DCB'S), RELEASES ALL BUFFER POOLS, RESETS POINTER         ---*\n*---     VALUES, RELEASE THE COMPRESSION WORK AREA AND CLEANS UP   ---*\n*---     THE NONVSAM I/O IN GENERAL, INCLUDING THE RESETING OF     ---*\n*---     ANY FLAG BITS.                                            ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nNVSCLOSE DS    0H\n         STM   R14,R12,IOSAVE      SAVE THE ENTRY REGISTERS\n         L     R2,NDCBA            LOAD PRIMARY DCB ADDRESS\n         LA    R2,0(,R2)           PURIFY THE ADDRESS\n         LTR   R2,R2               ZERO ??\n         BZ    NVC1                YES; NO DCB HERE ---\n         CLOSE MF=(E,NDCBA)        CLOSE THE DCB\n         #FREE (2)                 RELEASE BUFFER POOL, IF ANY\n         XC    NDCBA,NDCBA         AND RESET THE POINTER FIELD\nNVC1     DS    0H\n         L     R2,NDCBB            LOAD PRIMARY DCB ADDRESS\n         LA    R2,0(,R2)           PURIFY THE ADDRESS\n         LTR   R2,R2               ZERO ??\n         BZ    NVC2                YES; NO DCB HERE ---\n         MVI   NDCBB,X'80'         BUILD OPEN PARM LIST\n         CLOSE MF=(E,NDCBB)        CLOSE THE DCB\n         #FREE (2)                 RELEASE BUFFER POOL, IF ANY\n         XC    NDCBB,NDCBB         AND RESET THE POINTER FIELD\nNVC2     DS    0H\n         XC    DEVT,DEVT           CLEAR SAVED VALUES\n         XC    NVSDSORG,NVSDSORG\n         XC    VOLSER,VOLSER\n         XC    BLOCKWDS(8),BLOCKWDS\n         XC    NVSRECFM,NVSRECFM\n         XC    NVSBLKL,NVSBLKL\n         XC    NVSLRECL,NVSLRECL\n         XC    BPBUF1,BPBUF1\n         XC    BPBUF2,BPBUF2\n         LM    R0,R1,CMPWRKL       LOAD COMPRESSION AREA LENGTH/PTR\n         LTR   R0,R0               NULL LENGTH ??\n         BZ    NVC2A               YES; NO FREEMAIN\n         XC    CMPWRKL(8),CMPWRKL\nNVC2A    DS    0H\n         NC    SAVETTR,SAVETTR     ANY TTR CHAIN ??\n         BZ    NVC3                NOPE ---\n         XC    SAVETTR,SAVETTR\nNVC3     DS    0H\n         MVC   BLOCK+2(2),=S(0(R14))\n         #SET  IOGOING,OFF\n         #SET  BUFUSED,OFF\n         #SET  TRUNC,OFF\n         #SET  NVSPS,OFF\n         #SET  NVSPO,OFF\n         LM    R14,R12,IOSAVE      RESTORE THE REGISTERS\n         BR    R14                 AND RETURN TO CALLER\n         TITLE 'VSAM I/O OUTPUT '\n*---------------------------------------------------------------------*\n*---     THIS LITTLE LOCAL SUBROUTINE DOES ALL THE VSAM WRITING    ---*\n*---     FOR THE UNLOAD FUNCTION, WITH THE EXCEPTION OF THE        ---*\n*---     ERASURE OF A DUPLICATE ITEM.  THE BASIC ASSUMPTIONS ARE   ---*\n*---     THAT THE RECORD ADDRESS IS IN R1 AND THE LENGTH IS IN     ---*\n*---     R0.  THE INITIAL-LOAD CONDITION NEED NOT BE HANDLED       ---*\n*---     HERE, SINCE THE OPEN ROUTINE TAKES CARE OF ALL THAT.      ---*\n*---------------------------------------------------------------------*\nVSPUT    DS    0H\n         STM   R14,R12,IOSAVE      SAVE ENTRY REGISTERS\n         L     R4,RPL1             LOAD RPL ADDRESS\n         LR    R5,R1               LOAD BUFFER ADDRESS\n         LR    R6,R0               LOAD RECORD LENGTH\n         MODCB RPL=(4),            RPL ADDRESS                         X\n               OPTCD=(DIR,FKS,NUP,MVE,KEQ), OPTION CODES ---           X\n               ARG=(5),            KEY ADDRESS                         X\n               AREA=(5),           BUFFER ADDRESS                      X\n               RECLEN=(6),         RECORD LENGTH                       X\n               MF=(G,GENWK)\n         PUT   RPL=(4)             OUTPUT THE VSAM RECORD\n         LR    R3,R15              SAVE THAT RETURN CODE\n         SHOWCB RPL=(4),                                               X\n               FIELDS=FDBK,        FETCH THE RPL FEEDBACK FIELD        X\n               AREA=(S,DWORK),                                         X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        GET RECORD LENGTH\n         B     *+4(R3)             CHECK THE 'PUT' RETURN CODE\n         B     VSPUT6              ALL IS OK\n         B     VSPUT2              RPL SHOWS SOMETHING HAPPENING\n         B     VSPUT4              LOGICAL ERROR\n         B     VSPUTDIE            PHYSICAL ERROR\nVSPUT2   DS    0H\n         LA    R8,0                CLEAR A COUNTER REGISTER\nVSPUT3   DS    0H\n         CH    R8,=H'3'            PAST THE LIMIT YET ??\n         BH    VSPUTDIE            YES ---\n         LA    R8,1(,R8)           NOPE; INCREMENT COUNTER\n         CHECK RPL=(4)             LET PENDING I/O COMPLETE\n         PUT   RPL=(4)             OUTPUT THE VSAM RECORD\n         LR    R3,R15              SAVE THAT RETURN CODE\n         SHOWCB RPL=(4),                                               X\n               FIELDS=FDBK,        FETCH THE RPL FEEDBACK FIELD        X\n               AREA=(S,DWORK),                                         X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)        GET RECORD LENGTH\n         B     *+4(R3)             CHECK THE 'PUT' RETURN CODE\n         B     VSPUT6              ALL IS OK\n         B     VSPUT3              RPL SHOWS SOMETHING HAPPENING\n         B     VSPUT4              LOGICAL ERROR\n         B     VSPUTDIE            PHYSICAL ERROR\nVSPUT4   DS    0H                  LOGICAL ERROR HAS OCCURED\n         CLI   DWORK+3,8           DUPLICATE KEY ??\n         BNE   VSPUT5              NOPE ---\n         LA    R15,4               LOAD THE RETURN CODE\n         B     VSPUT6              AND TERMINATE\nVSPUT5   DS    0H\n         CLI   DWORK+3,116         INITIAL LOAD IN PROGRESS ??\n         BNE   VSPUTDIE            NOPE; SOME OTHER ERROR\n         MODCB RPL=(4),            RPL ADDRESS                         X\n               OPTCD=(SEQ,NUP,MVE,KEQ), OPTION CODES ---               X\n               MF=(G,GENWK)\n         LR    R7,R15\n         PUT   RPL=(4)             RE-DO THE PUT\n         LTR   R15,R15             OK NOW ??\n         BNZ   VSPUTDIE            NOPE; STILL SHAFTED\n         CLOSE ,MF=(E,ACB1)        CLOSE THE CLUSTER\n         OPEN  ,MF=(E,ACB1)        AND RE-OPEN THE CLUSTER\nVSPUT6   DS    0H\n         L     R14,IOSAVE          RELOAD R14\n         LM    R0,R12,IOSAVE+8     RESTORE OTHER REGS\n         BR    R14                 AND RETURN TO CALLER\nVSPUTDIE DS    0H\n*        WTO   'ARCHIVER --- VSAM I/O ERROR. R4 --> RPL',ROUTCDE=11\n         ABEND 100,DUMP\nTCMSG    DC    CL133' '\n         ORG   TCMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    C' TOTAL LOGICAL RECORDS PROCESSED.'\n         ORG\nMCMSG    DC    CL133' '\n         ORG   MCMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    C' TOTAL MEMBER(S) PROCESSED.'\n         ORG\nACMSG    DC    CL133' '\n         ORG   ACMSG+2\n         DC    X'40202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    X'6B202020'\n         DC    C' TOTAL ALIAS(ES) PROCESSED.'\n         ORG\n         LTORG\nUNLDED   DC    AL1(UNLMSGE-UNLMSG)\nUNLMSG   DC    C' SUCCESSFULLY UNLOADED.'\nUNLMSGE  EQU   *\nALIASED  DC    AL1(ALIASEDE-ALIASEDS)\nALIASEDS DC    C' ALIAS HAS BEEN ASSIGNED.'\nALIASEDE EQU   *\nMINREC   DC    A(RECSIZE)\nCAMLST   CAMLST SEARCH,0,0,0\nLCAMLST  EQU   *-CAMLST\nEXTRPARM EXTRACT ,'S',FIELDS=TIOT,MF=L\nEXTL     EQU   *-EXTRPARM\n         READ  DECB,SF,0,0,0,MF=L\nDECBL    EQU   *-DECB\n         DCBD  DSORG=(PS,PO)\n         IECSDSL1 (1)\n         COPY  #RECS\n         COPY  ##ARCHWK\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARCHVSOP": {"ttr": 11785, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x01\\x16\\x01\\x16\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 278, "newlines": 278, "modlines": 0, "user": "ARCHIVR"}, "text": "VSOP     TITLE 'ARCHIVER --- VSAM OPEN/CLOSE SUBROUTINE'\nARCHVSOP CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n         COPY #ARCBITS\n         USING ARCHVSOP,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             LOAD ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHVSOP,R11        DEFINE THE NEW BASE REGISTER\n         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             LOAD NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RELOAD BACK POINTER\n         L     R14,12(,R14)        RELOAD ORIG. REG 14\n         USING MAINWK,R12          BASE THE MAIN WORK AREA\n         LR    R10,R1              COPY THE PARAMETER REGISTER\n         USING #VSPRMS,R10         AND BASE ITS DSECT\n         LTR   R0,R0               WAS IT A CLOSE REQUEST ??\n         BNZ   CLOSEIT             YES; CLOSE THE FILE\n*---------------------------------------------------------------------*\n*---     DETERMINE NECESSARY STORAGE FOR BLOCKS AND BUFFERS AND   ----*\n*---     DO A SINGLE LARGE GETMAIN FROM SUBPOOL 12.  THE FIRST    ----*\n*---     WORD OF THE AREA WILL CONTAIN THE AREA LENGTH.           ----*\n*---------------------------------------------------------------------*\n         SHOWCB FIELDS=(ACBLEN,RPLLEN),   GET THE CONTROL BLOCK SIZES  X\n               AREA=(S,DWORK),                                         X\n               LENGTH=8,                                               X\n               MF=(G,GENWK)\n         LM    R4,R5,DWORK         LOAD THE TWO LENGTHS\n         LR    R6,R5               COPY THE RPL LENGTH\n         MH    R6,=H'3'            PLAN FOR THREE RPL'S\n         LA    R6,4(R6,R4)         PLUS THE ACB + 4\n         GETMAIN R,LV=(6),SP=10    GRAB SOME STORAGE\n         ST    R6,0(,R1)           STORE LENGTH IN FIRST WORD\n         LA    R1,4(,R1)           AND POINT PAST IT\n*---------------------------------------------------------------------*\n*---     USING GENCB, BUILD THE NECESSARY VSAM CONTROL BLOCKS.    ----*\n*---     WE'LL BUILD AN ACB AND THREE RPL'S IN THIS AREA.  WE     ----*\n*---     NEED TO CHECK THE I/O MODE IN #VSPRMS WHEN WE BUILD THE  ----*\n*---     ACT, TO DETERMINE IF IT'S INPUT OR OUTPUT.  ANY VALUE    ----*\n*---     EXCEPT THE STRING 'OUTPUT  ' WILL DEFAULT TO INPUT MODE. ----*\n*---------------------------------------------------------------------*\n         ST    R1,ACBADDR          SAVE AS ACB ADDRESS\n         LR    R2,R1               COPY ITS ADDRESS\n         GENCB BLK=ACB,                                                X\n               WAREA=(2),                                              X\n               LENGTH=(4),                                             X\n               AM=VSAM,                                                X\n               STRNO=1,                                                X\n               DDNAME=(*,VSAMDD),                                      X\n               MACRF=(KEY,DIR,SEQ,IN,SIS),                             X\n               MF=(G,GENWK)\n         CLC   VSMODE,=CL8'OUTPUT' OUTPUT NEEDED ??\n         BNE   NOTOUT              NOPE ---\n         MODCB ACB=(*,ACBADDR),    MAKE IT OUTPUT                      X\n               MACRF=(KEY,DIR,SEQ,OUT,SIS),                            X\n               MF=(G,GENWK)\nNOTOUT   DS    0H\n         MVI   ACBADDR,X'80'       MARK AS LAST FOR OPEN\n         LA    R3,0(R4,R2)         POINT TO RPL PART OF AREA\n         LA    R6,0(R5,R5)         TWO RPL'S LENGTH\n         LA    R6,0(R5,R6)         THREE RPL'S LENGTH\n         GENCB BLK=RPL,                                                X\n               WAREA=(3),                                              X\n               LENGTH=(6),                                             X\n               COPIES=3,                                               X\n               ACB=(*,ACBADDR),                                        X\n               AM=VSAM,                                                X\n               MF=(G,GENWK)\n         LR    R8,R1               COPY THE ADDRESS\n         ST    R8,VSRPL1           SAVE ITS ADDRESS\n         LA    R8,0(R5,R8)         POINT TO SECOND RPL\n         ST    R8,VSRPL2           SAVE ITS ADDRESS\n         LA    R8,0(R5,R8)         POINT TO THIRD RPL\n         ST    R8,VSRPL3           SAVE ITS ADDRESS\n*---------------------------------------------------------------------*\n*---     CONTROL BLOCKS ARE BUILT. NOW OPEN THE VSAM CLUSTER, GET ----*\n*---     THE LRECL AND ALLOCATE STORAGE FOR THE BUFFERS WE'LL     ----*\n*---     PROBABLY NEED. AGAIN, DO IT ALL IN THREE'S.              ----*\n*---------------------------------------------------------------------*\n         OPEN  ,MF=(E,ACBADDR)     OPEN THE CLUSTER\n         LTR   R15,R15             OPEN OK ??\n         BZ    OPENOK              YES ---\n         #ERROR 16,6\n         B     NOTOPEN             CLEAR UP AND DIE ---\nOPENOK   DS    0H\n         SHOWCB ACB=(*,ACBADDR),   GET RECORD LENGTH                   X\n               FIELDS=LRECL,                                           X\n               AREA=(S,DWORK),                                         X\n               LENGTH=4,                                               X\n               MF=(G,GENWK)\n         L     R3,DWORK            LOAD THE RECORD LENGTH\n         ST    R3,VSLIM            SAVE RECORD LENGTH LIMIT\n         LA    R3,4(,R3)           FUNNY STUFF FOR EXPORT/IMPORT\n         LR    R5,R3               COPY THE LENGTH\n         MH    R5,=H'3'            FIGURE THREE BUFFERS\n         GETMAIN R,LV=(5),SP=10    GRAB SPACE FOR A BUFFER AREA\n         ST    R1,VSBUF1           SAVE BUFFER\n         LA    R2,0(R3,R1)         POINT TO SECOND BUFFER\n         ST    R2,VSBUF2           AND SAVE ITS ADDRESS\n         LA    R2,0(R3,R2)         POINT TO THIRD BUFFER\n         ST    R2,VSBUF3           AND SAVE ITS ADDRESS\n         LA    R14,0               SOURCE ADDRESS IS ZERO\n         LA    R15,0               LENGTH/PAD IS ZEROS\n         L     R4,VSBUF1           POINT TO AREA START\n         MVCL  R4,R14              CLEAR ONE BUFFER\n         XC    VSLEN1,VSLEN1       INITIAL BYTES USED = ZERO\n         XC    VSLEN2,VSLEN2       INITIAL BYTES USED = ZERO\n         XC    VSLEN3,VSLEN3       INITIAL BYTES USED = ZERO\n*---------------------------------------------------------------------*\n*---     NOW TEST. IF THE KEY LENGTH IS NOT EXACTLY RIGHT OR THE  ----*\n*---     RECORD LENGTH IS TOO SMALL, WE'VE DONE ALL THIS FOR      ----*\n*---     NAUGHT. ISSUE AN ERROR MESSAGE, UN-DO ALL THAT WE DID,   ----*\n*---     SET A '8' RETURN CODE AND RETURN TO THE CALLER.          ----*\n*---------------------------------------------------------------------*\n         SHOWCB ACB=(*,ACBADDR),                                       X\n               FIELDS=(LRECL,KEYLEN),                                  X\n               AREA=(S,CALLIST),                                       X\n               LENGTH=8,                                               X\n               MF=(G,GENWK)\n         LM    R7,R8,CALLIST       LOAD KEYLEN AND LRECL VALUES\n         C     R8,=A(RECKLEN)      IS KEY LENGTH RIGHT ??\n         BE    KEYOK               YES ---\n         #ERROR  4,,6\n         B     KILLIT              GO DO TERMINATION STUFF\nKEYOK    DS    0H\n         C     R7,=A(RECSIZE)      IS LRECL LARGE ENOUGH ??\n         BNL   RECOK               YES ---\n         #ERROR  5,,6\n         B     KILLIT              GO DO TERMINATION STUFF\nRECOK    DS    0H\n*---------------------------------------------------------------------*\n*---     INSERT BUFFER ADDRESSES AND LENGTHS IN THE RPL'S          ---*\n*---------------------------------------------------------------------*\n         MODCB RPL=(*,VSRPL1),     INSERT ACB ADDRESS                  X\n               ACB=(*,ACBADDR),AREALEN=(*,VSLIM),                      X\n               AREA=(*,VSBUF1),                                        X\n               MF=(G,GENWK)\n         MODCB RPL=(*,VSRPL2),     INSERT ACB ADDRESS                  X\n               ACB=(*,ACBADDR),AREALEN=(*,VSLIM),                      X\n               AREA=(*,VSBUF2),                                        X\n               MF=(G,GENWK)\n         MODCB RPL=(*,VSRPL3),     INSERT ACB ADDRESS                  X\n               ACB=(*,ACBADDR),AREALEN=(*,VSLIM),                      X\n               AREA=(*,VSBUF3),                                        X\n               MF=(G,GENWK)\n*---------------------------------------------------------------------*\n*---     ONE LAST DETAIL. IF WE'RE OPENING THE CLUSTER FOR        ----*\n*---     OUTPUT, WE SHOULD MAKE SURE THAT IT'S INITIALIZED        ----*\n*---     PROPERLY.  WE CHECK THE 'ENDRBA' OF THE CLUSTER FOR      ----*\n*---     THIS. IF IT'S ZERO, WE'LL CLOSE AND REOPEN THE CLUSTER,  ----*\n*---     WRITE IN A DUMMY RECORD, AGAIN CLOSE AND REOPEN THE      ----*\n*---     CLUSTER, ERASE THAT DUMMY RECORD AND AGAIN CLOSE AND     ----*\n*---     RE-OPEN THE CLUSTER.  IT'S A LOT OF WORK BUT ITS EASIER  ----*\n*---     THAN TRYING TO TEACH SOMEONE ALL ABOUT VSAM INITIAL LOAD ----*\n*---     STATUS AND ITS CONSEQUENCES.                             ----*\n*---------------------------------------------------------------------*\n         TESTCB  ACB=(*,ACBADDR),  CHECK: OUTPUT ACB ??                X\n               MACRF=OUT,                                              X\n               MF=(G,GENWK)\n         BNE   ENDOPEN             NOPE; WE'RE ALL DONE\n         TESTCB ACB=(*,ACBADDR),                                       X\n               ENDRBA=0,                                               X\n               MF=(G,GENWK)        INITIAL LOAD STATUS ??\n         BNE   ENDOPEN             NOPE ---\n         L     R3,VSBUF1           POINT TO A BUFFER\n         XC    0(80,R3),0(R3)      SET INITIAL RECORD VALUE\n         MODCB RPL=(*,VSRPL1),                                         X\n               AREA=(3),           SET RECORD ADDRESS                  X\n               OPTCD=(SEQ,MVE),                                        X\n               RECLEN=80,                                              X\n               MF=(G,GENWK)\n         L     R1,VSRPL1           POINT TO A RPL\n         PUT   RPL=(1)             OUTPUT THE DUMMY RECORD\n         L     R1,VSRPL1           POINT TO A RPL\n         ENDREQ RPL=(1)\n         CLOSE ,MF=(E,ACBADDR)     CLOSE THE CLUSTER\n         OPEN  MF=(E,ACBADDR)      AND REOPEN THE CLUSTER\n         MODCB RPL=(*,VSRPL1),                                         X\n               AREA=(3),                                               X\n               AREALEN=(*,VSLIM),                                      X\n               ARG=(3),                                                X\n               OPTCD=(FKS,KEQ,UPD,DIR),                                X\n               MF=(G,GENWK)        UPDATE THE RPL\n         L     R1,VSRPL1           POINT TO A RPL\n         GET   RPL=(1)             READ THAT RECORD\n         NC    0(80,R3),0(R3)      RIGHT RECORD ??\n         BNE   KILLIT              NOPE ---\n         L     R1,VSRPL1           POINT TO A RPL\n         ERASE RPL=(1)             ERASE THAT RECORD\nENDOPEN  DS    0H\n*---------------------------------------------------------------------*\n*---     ONE LAST DETAIL: CLOSE THE CLUSTER, SET THE NUMBER OF    ----*\n*---     CONCURRENT STRINGS TO THREE INSTEAD OF ONE AND RE-OPEN   ----*\n*---     THE CLUSTER.                                             ----*\n*---------------------------------------------------------------------*\n         CLOSE ,MF=(E,ACBADDR)     CLOSE THE ACB\n         MODCB ACB=(*,ACBADDR),                                        X\n               BUFND=10,BUFNI=30,                                      X\n               STRNO=3,                                                X\n               MF=(G,GENWK)        RESET STRNO VALUE\n         OPEN  ,MF=(E,ACBADDR)     AND RE-OPEN THE ACB\n         L     R13,4(,R13)         LOAD BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ALWAYS RC = 0\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO CALLER\n         TITLE 'CLOSE INVALID CLUSTER AND RELEASE STORAGE'\n*---------------------------------------------------------------------*\n*---     IF WE ARE UNABLE TO USE THE CLUSTER WE'VE OPENED, CLOSE  ----*\n*---     IT AND RELEASE THE STORAGE WE'VE ACQUIRED. WE'LL ALSO    ----*\n*---     PRINT OUT SOME ERROR MESSAGES TO TELL THE USER THAT THIS ----*\n*---     HAS OCCURRED, AND WHY (IF POSSIBLE).  NOTE THAT WE DO A  ----*\n*---     SUBPOOL-TYPE FREEMAIN FOR THE ENTIRE SUBPOOL 12, RATHER  ----*\n*---     THAN INDIVIDUAL AREAS.                                   ----*\n*---------------------------------------------------------------------*\nKILLIT   DS    0H\n         MVI   ACBADDR,X'80'       MARK AS LAST FOR CLOSE\n         CLOSE ,MF=(E,ACBADDR)     CLOSE THE CLUSTER\nNOTOPEN  DS    0H\n         LA    R0,0                LOAD A ZERO\n         ST    R0,ACBADDR          SAVE\n         ST    R0,VSLIM            DITTO THE MAX. LRECL\n         XC    VSRPL1(12),VSRPL1   CLOBBER RPL ADDRESSES\n         XC    VSBUF1(12),VSBUF1   CLOBBER BUFFER ADDRESSES\n         XC    VSLEN1(12),VSLEN1   CLOBBER BUFFER BYTE COUNTERS\n         XC    VSMODE(12),VSMODE   CLOBBER THE MODE INDICATOR\nKILLED   DS    0H\n         L     R13,4(,R13)         LOAD BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,8               SET ERROR RETURN CODE\n         MVI   12(R13),255         AND 'DONE' FLAG\n         BR    R14                 AND RETURN TO CALLER\n         TITLE 'CLOSE CLUSTER AND RELEASE STORAGE, BY REQUEST'\n*---------------------------------------------------------------------*\n*---     IF REGISTER 0 IS NON-ZERO AT ENTRY, WE BRANCH TO THIS    ----*\n*---     CODE TO CLOSE THE VSAM CLUSTER AND RELEASE THE STORAGE   ----*\n*---     OCCUPIED BY VSAM BLOCKS, BUFFERS, ETC.  THE ONLY         ----*\n*---     DIFFERENCE BETWEEN THIS CODE AND THE CODE AT LABEL       ----*\n*---     KILLIT IS THE RETURN CODE SET, WHICH IS ZERO HERE.       ----*\n*---------------------------------------------------------------------*\nCLOSEIT  DS    0H\n         MVI   ACBADDR,X'80'       MARK AS LAST FOR CLOSE\n         CLOSE ,MF=(E,ACBADDR)     CLOSE THE CLUSTER\n         LA    R0,0                LOAD A ZERO\n         ST    R0,ACBADDR          SAVE\n         ST    R0,VSLIM            DITTO THE MAX. LRECL\n         XC    VSRPL1(12),VSRPL1   CLOBBER RPL ADDRESSES\n         XC    VSBUF1(12),VSBUF1   CLOBBER BUFFER ADDRESSES\n         XC    VSLEN1(12),VSLEN1   CLOBBER BUFFER BYTE COUNTERS\n         XC    VSMODE(12),VSMODE   CLOBBER THE MODE INDICATOR\n         L     R13,4(,R13)         LOAD BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               SET ERROR RETURN CODE\n         MVI   12(R13),255         AND 'DONE' FLAG\n         BR    R14                 AND RETURN TO CALLER\n         SPACE 3\n         #VSPRMS\n         COPY  #RECS\n         COPY  ##ARCHWK\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "A370INIT": {"ttr": 12036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06\\x0c\\x00\\x00\\x01 \\x18o\\x01 \\x18o\\x10\\t\\x01\\x1d\\x01\\x1d\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@'", "ispf": {"version": "06.12", "flags": 0, "createdate": "2020-07-04T00:00:00", "modifydate": "2020-07-04T10:09:00", "lines": 285, "newlines": 285, "modlines": 0, "user": "ARCHIVR"}, "text": "INIT     TITLE 'ARCHIVER --- WORK AREA/TIME/DATE SETUP '\n*---------------------------------------------------------------------*\n*---     (C) COPYRIGHT 1989, RICHARD A. FOCHTMAN JR., WOODRIDGE,   ---*\n*---           ILLINOIS                                            ---*\n*---                                                               ---*\n*---     THIS SUBROUTINE HAS ONLY ONE PURPOSE IN THE ARCHIVER:     ---*\n*---     SETUP THE CONSTANTS, ETC. NECESSARY TO THE BASIC          ---*\n*---     FUNCTIONS IN GENERAL.  THAT IS, THE TIME, DATE, SYSIN     ---*\n*---     AND SYSPRINT DCB'S, BLANK OUT THE VARIOUS PRINT LINE      ---*\n*---     AREAS, ETC.  THIS IS PERFORMED ONCE FOR EACH RUN OF       ---*\n*---     THE ARCHIVER.  FOR THAT REASON, THIS IS A SEPARATE        ---*\n*---     LOAD MODULE OF THE ARCHIVER, USED AND THEN DELETED        ---*\n*---     AT THE BEGINNING OF EACH ARCHIVER EXECUTION.              ---*\n*---                                                               ---*\n*---  RETRO-FITTED TO MVS 3.8J BY DAVE CARTWRIGHT AUGUST 2002      ---*\n*---                                                               ---*\n*---     PROGRAM ATTRIBUTES: NON-REENTRANT, NON-REUSABLE,          ---*\n*---           NON-REFRESHABLE.                                    ---*\n*--- UPDATE ON JULY 1,2020 ROB PRINS: CHANGE LA    R3,WALEN INTO   ---*\n*---                                         L     R3,WALEN (STMNT 53)*\n*--- UPDATE BY @RP AT 20200703: ADD SUPPORT FOR ALTERNATIVE        ---*\n*--- DDNAMES FOR SYSPRINT AND SYSIN IN THE PARM OF THE EXEC        ---*\n*--- STATEMENT IN THE ARCHIVER JCL.                                ---*\n*---------------------------------------------------------------------*\nARCHINIT CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n         USING ARCHINIT,R15\n         #STAMP\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R11,R15             LOAD ROUTINE BASE REGISTER\n         DROP  R15                 DROP THE OLD BASE\n         USING ARCHINIT,R11        DEFINE THE NEW BASE REGISTER\n         GETMAIN R,LV=72           GRAB STORAGE FOR SAVE AREA\n         LA    R14,0(,R1)          KLUDGE FOR STD HDR\n         ST    R14,8(,R13)         STORE FORWARD POINTER\n         ST    R13,4(,R14)         AND BACK POINTER\n         LR    R13,R14             LOAD NEW SAVE AREA POINTER\n         L     R14,4(,R13)         RELOAD BACK POINTER\n         L     R14,12(,R14)        RELOAD ORIG. REG 14\n         COPY  #ARCBITS            COPY THE BIT-DEFINES\n         L     R3,WALEN            LOAD SIZE OF WORK AREA     @RP200701\n         GETMAIN R,LV=(3)          GRAB ANOTHER CHUNK OF STORAGE\n         LR    R2,R1               COPY ITS ADDRESS\n         LR    R4,R2\n         SR    R5,R5\n         MVCL  R2,R4               AND CLEAR IT OUT\n         LR    R12,R1              AND LOAD WORK-AREA DSECT BASE\n         USING MAINWK,R12          BASE THE WORK-AREA DSECT\n         MVC   WKSYSPR,=CL8'SYSPRINT' DEFAULT DDNAME SYSRINT  @RP200703\n         MVC   WKSYSIN,=CL8'SYSIN'    DEFAULT DDNAME SYSRINT  @RP200703\n         MVC   WKKEYW,=CL8'SYSIN'  MOVE SYSIN= KEYWORD        @RP200703\n         LA    R3,WKKEYW           1ST PARM ARCHPRSC          @RP200703\n         LA    R4,WKWORKA          2ND PARM ARCHPRSC          @RP200703\n         CALL  ARCHPRSC,((3),(4))  OBTAIN ALT. DDNAME SYSIN   @RP200703\n         LTR   R15,R15             NEW DDNAME OF SYSIN?       @RP200703\n         BNZ   NOALTIN             NO: CARRY                  @RP200703\n         MVC   WKSYSIN,WKWORKA+2   MOVE ALTERNATIVE DDNAME    @RP200703\nNOALTIN  DS    0H                                             @RP200703\n         MVC   WKKEYW,=CL8'SYSPRINT' MOVE SYSPRINT= KEYWORD   @RP200703\n         LA    R3,WKKEYW           1ST PARM ARCHPRSC          @RP200703\n         LA    R4,WKWORKA          2ND PARM ARCHPRSC          @RP200703\n         CALL  ARCHPRSC,((3),(4))  OBTAIN ALT. DDNAME SYSIN   @RP200703\n         LTR   R15,R15             NEW DDNAME OF SYSIN?       @RP200703\n         BNZ   NOALTPR             NO: CARRY                  @RP200703\n         MVC   WKSYSPR,WKWORKA+2   MOVE ALTERNATIVE DDNAME    @RP200703\nNOALTPR  DS    0H                                             @RP200703\n         MVC   IOSEP,=X'47F0E000'  NO SEPARATOR ROUTINES\n         MVC   ENDSEP,=X'47F0E000'   DEFINED YET ---\n         MVC   MAINSIZE,WALEN      COPY SIZE INTO WORD 1\n         ST    R12,ARCHWK          SAVE MAIN WORK-AREA POINTER\n         MVC   EYEBALL,=CL4'ARCW'\n         #SET  REPL,ON              REPLACE DUPS. DURING RELOAD   DFLT\n         #SET  RETA,ON              RETAIN ALIAS INFORMATION      DFLT\n         #SET  SHHDR,ON             PROCESS HEADERS               DFLT\n         #SET  ULMODS,ON            RECFM=U MEANS LMODS           DFLT\n         MVI   TITLE1,C' '         START WITH A BLANK\n         MVC   TITLE1+1(120),TITLE1 CLEAR THE AREA\n         MVC   TITLE2,TITLE1       ALSO SECOND AND\n         MVC   TITLE3,INIT14       COPY IN THE USUAL SUBTITLE\n         MVC   LINE,TITLE1         ALSO OUTPUT LINE AREA\n         XC    TODVAL(16),TODVAL   CLEAR THE RETURN AREA\n         EXTRACT TIOTA,'S',FIELDS=TIOT,MF=(E,CALLIST) LOCATE THE TIOT\n         L     R1,TIOTA            LOAD THE TIOT POINTER\n         LA    R1,24(,R1)          POINT TO THE FIRST TIOE\n         ST    R1,TIOTA            SAVE UPDATED ADDRESS\n*---------------------------------------------------------------------*\n*---     FIND OUT IF SYSPUNCH IS PRESENT                           ---*\n*---------------------------------------------------------------------*\nLOCPNCH  DS    0H\n         CLI   0(R1),0             END OF TIOT ??\n         BE    NOPNCH              YES ---\n         CLC   4(8,R1),=CL8'SYSPUNCH'  IS DDNAME SYSPUNCH ??\n         BE    GOTPNCH             YES ---\n         LA    R15,0               CLEAR A WORK REGISTER\n         IC    R15,0(,R1)          INSERT TIOT LENGTH\n         AR    R1,R15              POINT TO NEXT TIOE\n         B     LOCPNCH\nGOTPNCH  DS    0H\n         #SET  PUNCH,ON\nNOPNCH   DS    0H\n         LA    R0,INIT7            LOAD THE LENGTH OF A QSAM DCB\n         AH    R0,=H'4'            ADD A WORD\n         GETMAIN R,LV=(0)          AND GRAB IT'S CORE\n         ST    R0,0(,R1)           STORE AREA LENGTH\n         LA    R1,4(,R1)\n         MVC   0(INIT7,R1),INIT6   MOVE IN THE DCB\n         ST    R1,PRTDCB           STORE IN THE WORK AREA\n         LR    R3,R1               AND COPY IT'S ADDRESS\n         USING IHADCB,R3           ADDRESS DCBD               @RP200703\n         MVC   DCBDDNAM(8),WKSYSPR MOVE DDNAME OF SYSPRINT    @RP200703\n         DROP  R3                                             @RP200703\n         MVI   PRTDCB,X'80'        LAST-ENTRY FLAG FOR OPEN PARMLIST\n         OPEN  ((3),OUTPUT),MF=(E,PRTDCB)      OPEN THE LISTING DCB\n         TM    48(R3),X'10'        DID SYSPRINT OPEN ??\n         BO    INIT1               YES, NOW CHECK SYSIN FLAG\n         WTO   'SYSPRINT DCB DID NOT OPEN. CHECK DD STATEMENT'\n         LA    R3,0\n         ABEND 1\nINIT1    DS    0H\n         LA    R0,INIT9            LOAD DCB LENGTH\n         AH    R0,=H'4'            ADD A WORD\n         GETMAIN R,LV=(0)          GRAB STORAGE FOR DCB\n         ST    R0,0(,R1)           STORE AREA LENGTH\n         LA    R1,4(,R1)\n         ST    R1,CTLIN            SAVE ITS ADDRESS\n         LR    R2,R1               COPY DCB ADDRESS           @RP200703\n         MVC   0(INIT9,R2),INIT8 MOVE IN THE DCB              @RP200702\n         MVI   CTLIN,X'80'         FLAG END OF OPEN LIST\n         USING IHADCB,R2           ADDRESS DCBD               @RP200703\n         MVC   DCBDDNAM(8),WKSYSIN  MOVE DDNAME SYSIN         @RP200703\n         DROP  R2                                             @RP200703\n         LR    R1,R2                                          @RP200703\n         OPEN  (,INPUT),MF=(E,CTLIN) AND OPEN THE DCB\n         ZAP   PAGENO,=P'0'        INIT THE PAGE COUNTER\n         ZAP   LSTLIN#,=P'99'      FORCE NEW-PAGE CONTROL\n         ZAP   LINECNT,=P'60'      MOVE IN THE DEFAULT\n         EJECT ,\n         TIME  DEC                 OLD STYLE TIME MACRO\n         STM   R0,R1,TODVAL        SAVE THE TIME VALUE\n         SRDL  R0,40               DROP OFF THE FRACTIONS\n         SLL   R1,4                MAKE FROM FOR DEC. SIGN VALUE\n         O     R1,=A(X'0F')        MAKE A POSITIVE SIGN\n         STM   R0,R1,TIME          SAVE IN CLOCK VALUE\n         SPACE 1\n         MVO   PYYYY,TODVAL+4(2)   COPY YEARS\n         OI    PYYYY+1,X'0C'       MAKE POSITIVE\n         ZAP   TODVAL+8(8),P1900   SET BASE YEAR\n         AP    TODVAL+8(8),PYYYY   CALCULATE CALENDAR YEAR\n         CVB   R15,TODVAL+8        CONVERT TO BINARY\n         MVO   DATE(3),TODVAL+13(3) LEFT SHIFT ANSWER\n         ICM   R0,B'0011',DATE     PICK UP YEAR DIGITS\n         ST    R15,TODVAL+8        SAVE BINARY YEARS\n         LA    R1,DAYS-2           POINTER TO MONTHS\n         ZAP   DATE,TODVAL+6(2)    GET DAY NUMBER\n         CVB   R15,DATE            .. AS BINARY\n         TM    TODVAL+11,X'03'     TEST FOR LEAP YEAR\n         BZ    LEAPYEAR            IT IS, ADJUST POINTER\n         LA    R2,DAYS-6           POINT TO DAYS\n         B     MNTHLOOP            GO FIND MONTH\nLEAPYEAR DS    0H                  THIS IS A LEAPYEAR\n         LA    R2,DAYS-4           POINT TO L/Y DAYS\nMNTHLOOP DS    0H                  FIND WHICH MONTH WE ARE\n         LA    R2,6(,R2)           BUMP ADDRESS OF DAY\n         LA    R1,6(,R1)           BUMP ADDRESS OF MONTH\n         CH    R15,0(,R2)          COMPARE DATE WITH DAYS\n         BNH   MNTHLOOP            NOT IN THS MONTH\n         ICM   R0,B'1000',1(R1)    COPY MONTH NUMBER\n         SH    R15,0(,R2)          OTHERWISE SUBTRACT DAYS\n         CVD   R15,DATE            GET DAY NUMBER\n         MVO   TODVAL(2),DATE+6(2) LEFT SHIFT IT\n         ICM   R0,B'0100',TODVAL   PUT INTO DATE\n         SRDL  R0,28               SHIFT DOWN THE BUS\n         O     R1,=A(X'0F')        MAKE A POSITIVE SIGN\n         STM   R0,R1,DATE          SAVE IN DATE VALUE\n         EJECT ,\n         LR    R15,R12             COPY THE WORK AREA ADDRESS\n         LR    R1,R13              COPY THE SAVE AREA ADDRESS\n         L     R13,4(,R13)         POINT TO PREVIOUS S.A.\n         ST    R15,16(,R13)        PASS W.A. ADDR AS RETURN CODE\n         FREEMAIN R,LV=72,A=(1)    FREE THE SAVE AREA\n         LM    R14,R12,12(R13)     RESTORE ENTRY REGISTERS\n         MVI   12(R13),255\n         BR    R14                 AND RETURN TO ARCHCTL\n         LTORG ,                   DISPLAY THE LITERALS SO FAR\n         SPACE 3\nP1900    DC    PL3'1900'           START YEAR\nPYYYY    DC    PL2'0'              YEAR\n         SPACE 3\nINIT6    DCB   DSORG=PS,                                               X\n               MACRF=PM,                                               X\n               EXLST=INIT10,                                           X\n               DDNAME=SYSPRINT,                                        X\n               RECFM=FBA,                                              X\n               LRECL=133,                                              X\n               EROPT=ABE\nINIT7    EQU   *-INIT6\nINIT8    DCB   DSORG=PS,                                               X\n               MACRF=GM,                                               X\n               EXLST=INIT10,                                           X\n               DDNAME=SYSIN,                                           X\n               RECFM=FB,                                               X\n               LRECL=80,                                               X\n               EROPT=ABE\nINIT9    EQU   *-INIT8\nINIT10   DC    0F'0'\n         DC    X'85',AL3(INIT11)\n         PUSH  USING\n         USING INIT11,R15\nINIT11   DS    0H\n         LH    R6,62(,R1)          LOAD DCB BLKSIZE ??\n         LTR   R6,R6               IS BLKSIZE STILL ZERO ??\n         BNZ   INIT12              NO; SEE IF MULTIPLE OF LRECL\n         MVC   62(2,R1),82(R1)     COPY LRECL TO BLKSIZE\n         BR    R14                 RETURN TO OPEN/CLOSE/EOV\nINIT12   DS    0H\n         SRDA  R6,32               SHIFT BLKSIZE TO DIVIDEND REGISTER\n         LH    R5,82(,R1)          LOAD LRECL VALUE\n         DR    R6,R5               COMPUTE BLOCKING FACTOR\n         LTR   R7,R7               QUOTIENT ZERO ??\n         BNZ   INIT13              NOPE ---\n         LA    R7,1                ASSUME 1 RECORD/BLOCK\nINIT13   DS    0H\n         MH    R7,82(,R1)          TIMES LRECL\n         STH   R7,62(,R1)          STORE COMPUTED BLOCK SIZE\n         BR    R14                 RETURN TO OPEN/CLOSE/EOV\n         DROP  R15\n         POP   USING\nINIT14   DC    CL2' '\n         DC    CL10'  MEMBER '                                     HEAD\n         DC    CL1'-'\n         DC    CL10'  GROUP  '                                     HEAD\n         DC    CL1'-'\n         DC    CL10'  SUBGRP '                                     HEAD\n         DC    CL1'-'\n         DC    CL10'   TYPE  '                                     HEAD\n         DC    CL1'-'\n         DC    CL12'       VRSN '                                  HEAD\n         DC    CL8' ACTION '\n         DC    CL70' '\nDTIME    DS    F\nDDATE    DS    F\nWALEN    DC    A(ENDMAIN-MAINWK)\n         SPACE 2\nDAYS     DC    AL2(334),AL2(335)        NOV\n         DC    XL2'0012'\n         DC    AL2(304),AL2(305)        OCT\n         DC    XL2'0011'\n         DC    AL2(273),AL2(274)        SEP\n         DC    XL2'0010'\n         DC    AL2(243),AL2(244)        AUG\n         DC    XL2'0009'\n         DC    AL2(212),AL2(213)        JUL\n         DC    XL2'0008'\n         DC    AL2(181),AL2(182)        JUN\n         DC    XL2'0007'\n         DC    AL2(151),AL2(152)        MAY\n         DC    XL2'0006'\n         DC    AL2(120),AL2(121)        APR\n         DC    XL2'0005'\n         DC    AL2(090),AL2(091)        MAR\n         DC    XL2'0004'\n         DC    AL2(059),AL2(060)        FEB\n         DC    XL2'0003'\n         DC    AL2(031),AL2(031)        JAN\n         DC    XL2'0002'\n         DC    AL2(000),AL2(000)\n         DC    XL2'0001'\n         COPY  ##ARCHWK\n         DCBD  DSORG=(PS,PO)\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CELLMAN": {"ttr": 12042, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x01\\x00D\\x00\\x99'\\x0f\\x01\\x02!?\\t%\\x01\\xd1\\x01\\xd2\\x00\\x00\\xd4\\xd4\\xe2\\xd4\\xc1\\xd2@@@@\"", "ispf": {"version": "06.01", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "2002-08-01T09:25:44", "lines": 465, "newlines": 466, "modlines": 0, "user": "MMSMAK"}, "text": "CELM     TITLE 'CELLMAN --- THE POOR MAN''S CELL POOL MANAGER '\n*---------------------------------------------------------------------*\n*---                                                               ---*\n*---     THIS ROUTINE WAS DEVELOPED TO PROVIDE MINIMAL CELL-POOL   ---*\n*---     MANAGER FUNCTIONS TO THOSE PROGRAMMER LABORING UNDER      ---*\n*---     BACK-LEVEL MVS SYSTEMS THAT LACK THE CPOOL MACRO AND      ---*\n*---     RELATED FUNCTIONS IN ALL THEIR GLORY.  UNFORTUNATELY,     ---*\n*---     THIS IMPLEMENTATION DOES HAVE SOME DRAWBACKS.  FOR        ---*\n*---     EXAMPLE, THERE IS NO MACRO TO BUILD PARM LISTS AND        ---*\n*---     INVOKE THESE FUNCTIONS.  DO THAT THE HARD WAY, FOLKS.     ---*\n*---                                                               ---*\n*---     FIRST, SOME BASIC BACKGROUND.  THE MAIN PURPOSE BEHIND    ---*\n*---     THE USE OF 'CELL POOLS' IS TO REDUCE THE NUMBER OF CALLS  ---*\n*---     TO GETMAIN/FREEMAIN BY PROVIDING A 'QUICKCELL' POOL FOR   ---*\n*---     REPETITIVE GETS AND FREES OF AREAS OF THE SAME SIZE.      ---*\n*---     THOSE USERS WHO ARE FAMILIAR WITH LIST PROCESSING, WITH   ---*\n*---     LINKS AND NODES IN ALL THEIR GLORY(?) HAVE PROBABLY       ---*\n*---     LEARNED BY NOW THAT GETMAIN/FREEMAIN ARE EXPENSIVE IN     ---*\n*---     TERMS OF PERFORMANCE.  MANY HAVE ALREADY DEVELOPED 'RYO'  ---*\n*---     STORAGE MANAGERS BECAUSE OF THIS EXPENSE.  BY USING A     ---*\n*---     'QUICKCELL' TYPE MECHANISM, YOU CAN VASTLY REDUCE THE     ---*\n*---     OVERHEAD IN CALLING GETMAIN/FREEMAIN, EITHER VIA BRANCH   ---*\n*---     ENTRY OR VIA THE SVC MECHANISM.  NOTE THAT I SAID         ---*\n*---     REDUCE, NOT ELIMINATE.  SIMPLE CALLS TO THIS ROUTINE ARE  ---*\n*---     VASTLY FASTER THAN DOING THE SVC'S AND, WITHIN LIMITS,    ---*\n*---     WILL PROVIDE ALL THE NEEDED FUNCTIONS.                    ---*\n*---                                                               ---*\n*---     ANY SPECIAL PARAMETERS RETURNED BY THE CELLMAN ROUTINES   ---*\n*---     ARE EXPLAINED IN THE DETAILED DESCRIPTION OF EACH         ---*\n*---     FUNCTION.                                                 ---*\n*---                                                               ---*\n*---     FUNCTIONS:                                                ---*\n*---        CELLBLD: INITIALIZE A CELL POOL.                       ---*\n*---        CELLGET: ALLOCATE A CELL AND RETURN ITS ADDRESS        ---*\n*---        CELLFRE: RETURN A CELL TO THE POOL                     ---*\n*---        CELLDEL: RELEASE AN ENTIRE CELL POOL                   ---*\n*---                                                               ---*\n*---     ALL ROUTINES USE STANDARD LINKAGE CONVENTIONS AND EXPECT  ---*\n*---     R13 TO POINT TO A 18-WORD SAVE AREA, R14 TO CONTAIN THE   ---*\n*---     RETURN ADDRESS AND R15 TO CONTAIN THE ENTRY POINT         ---*\n*---     ADDRESS.                                                  ---*\n*---                                                               ---*\n*---     ALSO, ALL ROUTINES ARE REENTRANT, REUSABLE AND            ---*\n*---     REFRESHABLE.  FOR THOSE WHO ARE ABLE, I'VE TRIED TO KEEP  ---*\n*---     THE CODE SUCH THAT IT WILL RUN EITHER ABOVE OR BELOW THE  ---*\n*---     16M LINE.  NO QUARANTEES HERE, THOUGH.                    ---*\n*---------------------------------------------------------------------*\n         TITLE 'CELLBLD --- BUILD THE INITIAL CELL POOL '\n*---------------------------------------------------------------------*\n*---     DETAIL DESCRIPTION OF CELLBLD:                            ---*\n*---                                                               ---*\n*---     CELLBLD WILL ALLOCATE THE PRIMARY CELL POOL AND BUILD     ---*\n*---     THE NECESSARY CONTROL BLOCKS IN DYNAMIC STORAGE,          ---*\n*---     RETURNING TO THE CALLER A 'TOKEN', THE ADDRESS OF THE     ---*\n*---     CONTROL BLOCK THAT DESCRIBES THIS CELL POOL. THE CALLER   ---*\n*---     MUST SAVE THIS VALUE AND SUPPLY IT TO THE CELL MANAGER    ---*\n*---     ON ALL SUBSEQUENT CALLS FOR STORAGE FROM THIS CELL POOL.  ---*\n*---     VALUES IN THIS BLOCK INCLUDE CELL SIZE, PRIMARY AND       ---*\n*---     SECONDARY ALLOCATION REQUIREMENTS, SUBPOOL                ---*\n*---     IDENTIFICATION, USAGE STATISTICS AND THE CELL POOL        ---*\n*---     LABEL, IF ONE WAS SUPPLIED.                               ---*\n*---                                                               ---*\n*---     THIS ROUTINE EXPECTS R1 TO POINT TO A PARAMETER LIST OF   ---*\n*---     THE FOLLOWING FORM:                                       ---*\n*---                                                               ---*\n*---     DS    F   THE NUMBER OF CELLS TO START WITH               ---*\n*---     DS    F   THE NUMBER OF CELLS TO ADD EACH TIME WE RUN     ---*\n*---               OUT                                             ---*\n*---     DS    F   THE SIZE OF EACH CELL (AT LEAST 8 BYTES)        ---*\n*---     DS    XL1 THE SUBPOOL NUMBER TO ALLOCATE FROM             ---*\n*---     DS    XL1 THE LENGTH, IN BYTES, OF THE CELL POOL LABEL    ---*\n*---     DC    C   THE CHARACTER STRING USED TO LABEL THE CELL     ---*\n*---               POOL IN STORAGE. USEFUL FOR DUMP CHECKING.      ---*\n*---               (MAX SIZE OF 64 BYTES; PADDED TO D'WORD BY      ---*\n*---               CELLBLD, WITH BLANKS.)                          ---*\n*---                                                               ---*\n*---     THE CELL POOL LABEL IS OPTIONAL BUT HIGHLY RECOMMENDED.   ---*\n*---     IF NOT SUPPLIED, THE LENGTH BYTE IN THE PARAMETER LIST    ---*\n*---     MUST BE ZERO.                                             ---*\n*---                                                               ---*\n*---     UPON RETURN, REGISTER ZERO WILL CONTAIN A 'TOKEN' VALUE   ---*\n*---     THAT MUST BE SAVED BY THE CALLER.  THIS VALUE MUST BE     ---*\n*---     PRESENT IN REGISTER ZERO ON ALL SUBSEQUENT CALLS TO       ---*\n*---     CELLMAN FUNCTIONS.  IT'S THE ADDRESS OF THE CONTROL       ---*\n*---     BLOCK THAT IS BUILT TO MANAGE THE CELL POOL.  A RETURN    ---*\n*---     CODE IS ALSO RETURNED IN REGISTER 15.  THE RETURN CODE    ---*\n*---     IS EITHER A 0, FOR SUCCESSFUL COMPLETION, A 4 IF THE      ---*\n*---     PARAMETER LIST WAS FOUND TO BE INVALID, OR 8, IF NO       ---*\n*---     STORAGE IS AVAILABLE TO FILL THE REQUEST. IN ALL CASES,   ---*\n*---     A NON-ZERO RETURN CODE SIGNIFIES THAT NO STORAGE WAS      ---*\n*---     ALLOCATED AND NO TOKEN VALUE IS RETURNED TO THE CALLER.   ---*\n*---------------------------------------------------------------------*\n         EJECT\nCELLMAN  CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n         ENTRY CELLBLD\nCELLBLD  DS    0D\n         B     12(,R15)            BRANCH AROUND\n         DC    AL1(7),CL7'CELLBLD' ENTRY IDENTIFIER\n         STM   R14,R12,12(R13)     SAVE ENTRY REGISTERS\n         LR    R11,R1              SAVE PARM LIST POINTER\n         USING PARMLST,R11         AND BASE ITS DSECT\n         LR    R12,R15             COPY THE ENTRY ADDRESS\n         USING CELLBLD,R12         AND DEFINE THE BASE REGISTER\n         GETMAIN R,LV=72           GRAB STORAGE FOR WORK/SAVE AREA\n         ST    R1,8(,R13)          SAVE FORWARD POINTER\n         ST    R13,4(,R1)          AND BACK POINTER\n         LR    R13,R1              AND BUMP DOWN THE SAVE-AREA CHAIN\n         LA    R0,CPPBSIZE         LOAD CONTROL BLOCK SIZE\n         LA    R2,0                CLEAR A WORK REGISTER\n         IC    R2,LBLSIZE          LOAD THE LABEL SIZE\n         LA    R2,7(,R2)           BUMP PAST NEXT DBLWD\n         N     R2,BLD4             ROUND TO DBLWD\n         AR    R0,R2               ADD TO BASIC SIZE\n         ICM   R0,8,PSPNUM         INSERT THE SUBPOOL IDENTIFIER\n         GETMAIN R,LV=(0)          GRAB STORAGE FOR CPPB\n         LA    R10,0(R1,R2)        POINT TO BASIC SECTION\n         USING CPPB,R10            AND BASE ITS DSECT\n         STC   R2,CPPBPRFX         STORE CPPB PREFIX LENGTH\n         MVC   CPPBCSIZ,CSIZE      COPY CELL SIZE\n         MVC   CPPBPRI,PSIZE       PRIMARY CELL COUNT\n         MVC   CPPBSEC,SSIZE       SECONDARY CELL COUNT\n         MVC   CPPBSP,PSPNUM       SUBPOOL NUMBER\n         MVC   CPPBID,=CL4'CELL'   CPPB IDENTIFIER\n         LTR   R2,R2               WAS A LABEL AREA SUPPLIED ??\n         BZ    BLD1                NOPE ---\n         MVI   0(R1),C' '          SEED IN A BLANK\n         BCTR  R2,R0               DECREMENT LABEL LENGTH VALUE\n         BCTR  R2,R0               DECREMENT LABEL LENGTH VALUE\n         EX    R2,BLD3             AND CLEAR THE PREFIX\n         IC    R2,LBLSIZE          RELOAD LABEL SIZE\n         BCTR  R2,R0               RELOAD ACTUAL LABEL SIZE\n         EX    R2,BLD1-6           AND COPY THE LABEL VALUE\n         B     BLD1                SKIP AROUND THE 'EX'ED INSTRUCTION\n         MVC   0(*-*,R1),PLBL      DO NOT MOVE THIS INSTRUCTION !!!\n         DROP  R11\nBLD1     DS    0H\n         L     R2,CPPBPRI          LOAD PRIMARY CELL COUNT\n         SRDA  R2,32               SHIFT OVER ---\n         L     R4,CPPBCSIZ         LOAD CELL SIZE\n         MR    R2,R4               TIMES CELL SIZE\n         AL    R3,=F'16'           ADD CONTROL INFO\n         ICM   R3,8,CPPBSP         ADD SUBPOOL NUMBER\n         GETMAIN R,LV=(3)          GRAB THE PRIMARY CELLPOOL AREA\n         USING CELLBLOK,R1\n         XC    0(16,R1),0(R1)      NO LINK POINTER OR CTL STUFF\n         ST    R1,CPPBLINK         SAVE POINTER IN CPPB\n         MVC   CELLCNT,CPPBPRI     SET INITIAL FREE-CELL COUNT\n         LA    R5,0(R1,R3)         POINT TO AREA END\n         ST    R5,CELLLAST         STORE LAST-BYTE ADDRESS\n         SR    R5,R4               BACK UP A CELL\n         LA    R3,16(,R1)          POINT TO FIRST CELL\n         ST    R3,CELLFREE         SET 'FIRST-FREE' POINTER\nBLD2     DS    0H\n         LA    R1,0(R4,R3)         POINT TO 'NEXT FREE' CELL\n         ST    R1,0(,R3)           SET THE CHAIN POINTER\n         MVC   4(4,R3),=CL4'FREE'  MARK THIS CELL FREE\n         BXLE  R3,R4,BLD2          LOOP FOR THE WHOLE AREA\n         SR    R3,R4               BACK UP ONE CELL\n         XC    0(4,R3),0(R3)       NO MORE IN THE CHAIN\n         DROP  R1\n         L     R1,4(,R13)          LOAD BACK S.A. POINTER\n         ST    R10,20(,R1)         SET THE RETURN ADDRESS\n         XC    16(4,R1),16(R1)     ZERO RETURN CODE\n         LR    R1,R13              COPY SAVE/WORK AREA POINTER\n         L     R13,4(,R13)         LOAD BACK POINTER\n         FREEMAIN R,LV=72,A=(1)    RELEASE THAT AREA\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         BR    R14                 AND RETURN TO CALLER\nBLD3     MVC   1(*-*,R1),0(R1)\nBLD4     DC    F'-8'\n         LTORG\n         DROP  R10,R12             DISCARD THOSE BASE REGS.\n         TITLE 'CELLGET --- GRAB A CELL AND RETURN IT''S ADDRESS'\n*---------------------------------------------------------------------*\n*---     THIS ENTRY POINT WILL GRAB A STORAGE CELL AND RETURN ITS  ---*\n*---     ADDRESS TO THE CALLER. IF NECESSARY, A SECONDARY CELL     ---*\n*---     BLOCK WILL BE ALLOCATED AND ADDED TO THE CHAIN OF         ---*\n*---     ALLOCATED STORAGE ROOTED AT CPPBLINK AND A SECONDARY      ---*\n*---     CELL BLOCK WILL BE INITIALIZED.  THE CELL WILL BE         ---*\n*---     RETURNED BY PLACING ITS ADDRESS IN R1 BEFORE RETURNING.   ---*\n*---     UPON ENTRY, R0 MUST CONTAIN THE TOKEN VALUE RETURNED      ---*\n*---     FROM CELLBLD.  IF NOT, THE RESULTS MAY BE VERY            ---*\n*---     SURPRISING, TO SAY THE LEAST.  NO OTHER PARAMETERS ARE    ---*\n*---     REQUIRED.                                                 ---*\n*---------------------------------------------------------------------*\n         ENTRY CELLGET\nCELLGET  DS    0D\n         B     12(,R15)            BRANCH AROUND\n         DC    AL1(7),CL7'CELLGET' ENTRY I.D.\n         STM   R14,R12,12(R13)     SAVE ENTRY REGISTERS\n         LR    R12,R15             COPY THE ENTRY ADDRESS\n         USING CELLGET,R12         AND DEFINE THE BASE REGISTER\n         LR    R2,R0               COPY CPPB ADDRESS\n         ST    R13,4(,R2)          STORE BACK POINTER\n         ST    R2,8(,R13)          AND FORWARD POINTER\n         LR    R13,R2              NEW SAVE/AREA PTR\n         USING CPPB,R13            AND BASE ITS DSECT\n         L     R1,CPPBLINK         LOAD POINTER TO PRIMARY AREA\n         USING CELLBLOK,R1\n         L     R8,CELLLAST\n         SR    R8,R1\n         CLC   CELLFREE,=F'0'      ANY FREE CELLS ??\n         BE    GET2                NOPE; START CHECKING SECONDARIES\nGET1     DS    0H\n         L     R2,CELLFREE         POINT TO THE FIRST FREE CELL\n         MVC   CELLFREE,0(R2)      UNCHAIN IT ---\n         L     R0,CELLCNT          LOAD FREE-CELL COUNT\n         BCTR  R0,R0               DECREMENT BY ONE\n         ST    R0,CELLCNT          SAVE UPDATED COUNT\n         B     GET3                AND RETURN TO CALLER\nGET2     DS    0H\n         CLC   CELLLINK,=F'0'      ANOTHER CELL BLOCK READY ??\n         BE    GET4                NOPE; GO ALLOCATE A SECONDARY\n         L     R1,CELLLINK         POINT TO IT\n         L     R8,CELLLAST\n         SR    R8,R1\n         CLC   CELLFREE,=F'0'      ANY FREE ONES HERE ??\n         BE    GET2                NOPE; KEEP SEARCHING\n         L     R2,CELLFREE         POINT TO A FREE CELL\n         MVC   CELLFREE,0(R2)      UNCHAIN IT\n         L     R0,CELLCNT          LOAD CELL COUNT\n         BCTR  R0,R0               DECREMENT BY ONE\n         ST    R0,CELLCNT          SAVE UPDATED COUNT\n         DROP  R1\nGET3     DS    0H\n         L     R1,4(,R13)          LOAD BACK S.A. POINTER\n         ST    R2,24(,R1)          SAVE IN R1 AREA\n         L     R13,4(,R13)         LOAD BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ALWAYS A ZERO R.C.\n         BR    R14                 RETURN TO CALLER\n         SPACE 3\n*---------------------------------------------------------------------*\n*---     ALL AVAILABLE CELLS ARE CURRENTLY ALLOCATED, SO IT'S      ---*\n*---     TIME TO ALLOCATE A SECONDARY CELL BLOCK, FORMAT IT AND    ---*\n*---     PASS THE FIRST CELL BACK TO THE CALLER.  THE FORMATTING   ---*\n*---     OPERATION IS ESSENTIALLY THE SAME AS IN THE CELLBLD       ---*\n*---     PROCESS.                                                  ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nGET4     DS    0H\n         L     R2,CPPBSEC          LOAD SECONDARY CELL COUNT\n         SRDA  R2,32               SHIFT OVER ---\n         M     R2,CPPBCSIZ         TIMES CELL SIZE\n         AL    R3,=F'16'           ADD CONTROL INFO\n         ICM   R3,8,CPPBSP         ADD SUBPOOL NUMBER\n         GETMAIN R,LV=(3)          GRAB THE PRIMARY CELLPOOL AREA\n         USING CELLBLOK,R1\n         XC    0(16,R1),0(R1)      NO LINK POINTER OR CTL STUFF\n         MVC   CELLCNT,CPPBSEC     SET INITIAL FREE-CELL COUNT\n         L     R4,CPPBCSIZ         LOAD CELL SIZE\n         LA    R5,0(R1,R3)         POINT TO AREA END\n         ST    R5,CELLLAST         STORE LAST-BYTE ADDRESS\n         SR    R5,R4               BACK UP A CELL\n         LA    R3,CELL1            POINT TO FIRST CELL\n         ST    R3,CELLFREE         SET 'FIRST-FREE' POINTER\nGET5     DS    0H\n         LA    R2,0(R4,R3)         POINT TO 'NEXT FREE' CELL\n         ST    R2,0(,R3)           SET THE CHAIN POINTER\n         MVC   4(4,R3),=CL4'FREE'  MARK THIS CELL FREE\n         BXLE  R3,R4,GET5          LOOP FOR THE WHOLE AREA\n         SR    R3,R4               BACK UP ONE CELL\n         XC    0(4,R3),0(R3)       NO MORE IN THE CHAIN\n         DROP  R1\n         LA    R2,CPPBLINK         POINT TO CHAIN ROOT\nGET6     DS    0H\n         L     R2,0(,R2)\n         CLC   0(4,R2),=F'0'       AT CHAIN END ??\n         BNE   GET6                NOPE; KEEP SEARCHING\n         ST    R1,0(,R2)           ADD THIS BLOCK TO CHAIN\n         SR    R5,R1               COMPUTE CELL BLOCK LENGTH\n         B     GET1                GO RESTART THE SEARCH\nGET7     DS    0F\n         DC    X'7FFFFFFF'\n         LTORG\n         DROP  R12,R13\n         TITLE 'CELLFRE --- RETURN A CELL TO THE AVAILABLE POOL'\n*---------------------------------------------------------------------*\n*---     THIS ENTRY POINT WILL FREE A STORAGE CELL WHOSE ADDRESS   ---*\n*---     IS PASSED BY THE CALLER IN REGISTER 1. IF IT'S THE LAST   ---*\n*---     CELL TO BE RETURNED TO A SECONDARY BLOCK, THAT BLOCK      ---*\n*---     WILL BE UNCHAINED AND FREED AS WELL.  (THE PRIMARY BLOCK  ---*\n*---     IS RELEASE ONLY BY THE CELLDEL PROCESSOR) THE CELL WILL   ---*\n*---     BE RETURNED BY PLACING ITS ADDRESS IN CELLFREE AND THE    ---*\n*---     CONTENTS OF CELLFREE WILL BE PLACED IN THE FIRST WORD OF  ---*\n*---     THE CELL, WITH THE VALUE C'FREE' IN THE SECOND WORD.      ---*\n*---     UPON ENTRY, R0 MUST CONTAIN THE TOKEN VALUE RETURNED      ---*\n*---     FROM CELLBLD.  IF NOT, THE RESULTS MAY BE VERY            ---*\n*---     SURPRISING, TO SAY THE LEAST.  NO OTHER PARAMETERS ARE    ---*\n*---     REQUIRED.                                                 ---*\n*---------------------------------------------------------------------*\n         ENTRY CELLFRE\nCELLFRE  DS    0D\n         B     12(,R15)            BRANCH AROUND\n         DC    AL1(7),CL7'CELLFRE' ENTRY I.D.\n         STM   R14,R12,12(R13)     SAVE ENTRY REGISTERS\n         LR    R12,R15             COPY THE ENTRY ADDRESS\n         USING CELLFRE,R12         AND DEFINE THE BASE REGISTER\n         LR    R2,R0               COPY CPPB ADDRESS\n         ST    R13,4(,R2)          STORE BACK POINTER\n         ST    R2,8(,R13)          AND FORWARD POINTER\n         LR    R13,R2              NEW SAVE/AREA PTR\n         USING CPPB,R13            AND BASE ITS DSECT\n         L     R2,CPPBLINK         POINT TO PRIMARY CELL BLOCK\n         USING CELLBLOK,R2         AND BASE ITS DSECT\nFREE1    DS    0H\n         CR    R1,R2               ARE WE BEFORE THIS BLOCK ??\n         BL    FREE2               YES ---\n         C     R1,CELLLAST         AFTER THIS BLOCK ??\n         BL    FREE3               NOPE; IN THIS BLOCK\nFREE2    DS    0H\n         L     R2,CELLLINK         POINT TO NEXT CELL BLOCK\n         B     FREE1               AND LOOP, SEARCHINGLY\nFREE3    DS    0H\n         MVC   0(4,R1),CELLFREE    COPY FREE-CELL POINTER\n         ST    R1,CELLFREE         SAVE ITS ADDRESS\n         L     R4,4(,R13)          LOAD BACK S.A. POINTER\n         XC    24(4,R4),24(R4)     SET POINTER TO ZERO\n         L     R3,CELLCNT          LOAD FREE-CELL COUNT\n         LA    R3,1(,R3)           ADD ONE\n         ST    R3,CELLCNT          SAVE UPDATED VALUE\n         C     R2,CPPBLINK         ARE WE IN THE PRIMARY ??\n         BE    FREE6               YES; ALL DONE HERE\n         CLC   CELLCNT,CPPBSEC     ALL CELLS FREE IN THIS BLOCK ??\n         BNE   FREE6               NOPE ---\n         LR    R1,R2               COPY THE BLOCK'S ADDRESS\n         L     R2,CPPBLINK         LOAD PRIMARY BLOCK POINTER\nFREE4    DS    0H\n         C     R1,CELLLINK         IS THIS THE PREDECESSOR BLOCK ??\n         BE    FREE5               YES ---\n         L     R2,CELLLINK         NOPE; TRY THE NEXT BLOCK\n         LTR   R2,R2               ZERO POINTER ??\n         BZ    FREE6               YES; CELL NOT FROM THIS POOL\n         B     FREE4\nFREE5    DS    0H\n         MVC   CELLLINK,CELLLINK-CELLBLOK(R1) UNCHAIN THIS ONE\n         L     R2,CPPBSEC          LOAD SECONDARY CELL COUNT\n         SRDA  R2,32               SHIFT FOR MULTIPLY\n         M     R2,CPPBCSIZ         TIMES CELL SIZE\n         LA    R0,16(,R3)          ADD CTL AREA SIZE\n         ICM   R0,8,CPPBSP         INSERT SUBPOOL NUMBER\n         FREEMAIN R,LV=(0),A=(1)   RELEASE THE STORAGE\nFREE6    DS    0H\n         L     R13,4(,R13)         LOAD BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ALWAYS A ZERO R.C.\n         BR    R14                 RETURN TO CALLER\n         LTORG\n         DROP  R2,R12,R13\n         TITLE 'CELLDEL --- DELETE THE CELL POOL AND ITS CNTRL BLOCKS'\n*---------------------------------------------------------------------*\n*---     THIS ENTRY POINT WILL DELETE THE ENTIRE CELL POOL AND     ---*\n*---     ALL THE RELATED CONTROL BLOCKS.  THE ONLY PARAMETER IS    ---*\n*---     THE TOKEN VALUE, FROM CELLBLD, IN REGISTER ZERO.          ---*\n*---------------------------------------------------------------------*\n         ENTRY CELLDEL\nCELLDEL  DS    0D\n         B     12(,R15)            BRANCH AROUND\n         DC    AL1(7),CL7'CELLDEL' ENTRY I.D.\n         STM   R14,R12,12(R13)     SAVE ENTRY REGISTERS\n         LR    R12,R15             COPY THE ENTRY ADDRESS\n         USING CELLDEL,R12         AND DEFINE THE BASE REGISTER\n         LR    R2,R0               COPY CPPB ADDRESS\n         ST    R13,4(,R2)          STORE BACK POINTER\n         ST    R2,8(,R13)          AND FORWARD POINTER\n         LR    R13,R2              NEW SAVE/AREA PTR\n         USING CPPB,R13            AND BASE ITS DSECT\n         L     R2,CPPBLINK         POINT TO PRIMARY CELL BLOCK\n         USING CELLBLOK,R2         AND BASE ITS DSECT\nDEL1     DS    0H\n         L     R1,CELLLINK         IS THERE ANOTHER LINK ??\n         LTR   R1,R1\n         BZ    DEL2                NOPE ---\n         L     R0,CELLLAST-CELLBLOK(,R1) LOAD CELLLAST POINTER\n         SR    R0,R1               COMPUTE AREA LENGTH\n         ICM   R0,8,CPPBSP         INSERT SUBPOOL NUMBER\n         MVC   CELLLINK,CELLLINK-CELLBLOK(R1) UNCHAIN IT\n         FREEMAIN R,LV=(0),A=(1)   RELEASE THE STORAGE\n         B     DEL1                GO TRY FOR ANOTHER\nDEL2     DS    0H\n         LA    R1,0(,R2)           LOAD POINTER TO PRIMARY AREA\n         L     R0,CELLLAST         LOAD ITS LAST-BYTE PTR\n         SR    R0,R1               COMPUTE CELLBLOK LENGTH\n         ICM   R0,8,CPPBSP         INSERT SUBPOOL NUMBER\n         FREEMAIN R,LV=(0),A=(1)   RELEASE THE STORAGE\n         LR    R2,R13              COPY CPPB ADDRESS\n         LA    R0,CPPBSIZE         LOAD CPPB LENGTH\n         LA    R1,0                CLEAR A WORK REGISTER\n         IC    R1,CPPBPRFX         LOAD PREFIX LENGTH\n         AR    R0,R1               ADD TO BASIC LENGTH\n         SR    R2,R1               BACK UP THE POINTER\n         LR    R1,R2               COPY THE ADDRESS\n         ICM   R0,8,CPPBSP         INSERT SUBPOOL NUMBER\n         L     R13,4(,R13)         LOAD BACK SAVE-AREA POINTER\n         FREEMAIN R,LV=(0),A=(1)   RELEASE THE CPPB STORAGE\n         LM    R14,R12,12(R13)     RESTORE ENTRY REGISTERS\n         LA    R0,0                TOKEN VALUE IS NOW ZERO\n         LA    R15,0               RETURN CODE IS ZERO\n         BR    R14                 AND RETURN TO CALLER\n         LTORG\n         DROP  R13,R12,R2\n         TITLE 'CPPB --- CELL POOL PARAMETER BLOCK '\n*---------------------------------------------------------------------*\n*---     THE CELL POOL PARAMETER BLOCK IS THE ROOT OF 'ALL EVIL'   ---*\n*---     FOR THIS CELL POOL MANAGER.  NOT SHOWN IN THIS DSECT IS   ---*\n*---     THE PREFIX, WHICH CONTAINS THE LABEL IF SUPPLIED.  SINCE  ---*\n*---     THIS PREFIX IS OF VARIABLE LENGTH, THE ACTUAL PREFIX      ---*\n*---     LENGTH, ROUNDED TO MULTIPLES OF 8, IS SAVED IN THE CPPB.  ---*\n*---     MOST OTHER FIELDS ARE SELF EXPLANITORY.                   ---*\n*---------------------------------------------------------------------*\nCPPB     DSECT\nCPPBID   DS    CL4                 IDENTIFIER ('CELL')\nCPPBSAVE DS    17F                 REGISTER SAVE AREA FOR GET/FRE\nCPPBCSIZ DS    F                   CELL SIZE\nCPPBPRI  DS    F                   PRIMARY CELL COUNT\nCPPBSEC  DS    F                   SECONDARY CELL COUNT\nCPPBPRFX DS    XL1                 CPPB PREFIX LENGTH\nCPPBSP   DS    XL1                 USER'S DESIGNATED SUBPOOL\n         DS    XL2                 RESERVED FOR LATER USE\nCPPBLINK DS    A                   ADDRESS OF PRIMARY CELL BLOCK\nCPPBSIZE EQU   *-CPPB              CPPB SIZE FOR GETMAINS\n         TITLE 'PARMLIST --- PARM LIST FOR CELLBLD '\n*---------------------------------------------------------------------*\n*---     THE CELLBLD PARAMETER LIST IS DESCRIBED IN THE PROSE.     ---*\n*---------------------------------------------------------------------*\nPARMLST  DSECT\nPSIZE    DS    F   THE NUMBER OF CELLS TO START WITH\nSSIZE    DS    F   THE NUMBER OF CELLS TO ADD EACH TIME WE RUN         X\n                   OUT\nCSIZE    DS    F   THE SIZE OF EACH CELL (AT LEAST 8 BYTES)\nPSPNUM   DS    XL1 THE SUBPOOL NUMBER TO ALLOCATE FROM\nLBLSIZE  DS    XL1 THE LENGTH, IN BYTES, OF THE CELL POOL LABEL\nPLBL     DS    C   THE CHARACTER STRING USED TO LABEL THE CELL POOL.   X\n                   (MAX SIZE OF 256 BYTES; PADDED TO D'WORD BY         X\n                   CELLBLD, WITH BLANKS.) (USEFUL FOR DEBUGGING)\n         TITLE 'CELLBLOK --- CELL POOL BLOCK HEADER FORMAT'\n*---------------------------------------------------------------------*\n*---     THIS INFORMATION IS PRESENT AT THE BEGINNING OF EACH      ---*\n*---     CELL POOL BLOCK. IT DESCRIBES THE CURRENT BLOCK,          ---*\n*---     INCLUDING THE FREE CELL CHAIN AND THE NUMBER OF FREE      ---*\n*---     CELLS IN THIS BLOCK.                                      ---*\n*---------------------------------------------------------------------*\nCELLBLOK DSECT\nCELLLINK DS    A   POINTER TO THE NEXT CELL BLOCK, IF ANY\nCELLFREE DS    A   POINT TO THE FIRST FREE CELL IN THIS BLOCK\nCELLLAST DS    A   ADDRESS OF THE LAST CELL IN THIS BLOCK\nCELLCNT  DS    F   NUMBER OF FREE CELLS IN THIS BLOCK\nCELL1    DS    X   THIS IS THE FIRST BYTE OF THE FIRST CELL\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COMPACT": {"ttr": 12295, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00\\xc5\\x00\\xc5\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 197, "newlines": 197, "modlines": 0, "user": "ARCHIVR"}, "text": "CMPK     TITLE 'HUFFMAN TREE COMPACTION ROUTINE'\n*---------------------------------------------------------------------*\n*---     THIS SUBROUTINE USES A HUFFMAN TREE TO COMPACT DATA INTO  ---*\n*---     A VARIABLE-LENGTH BIT STRING. THE RESULTING STRING IS     ---*\n*---     THEN PADDED TO A FULLWORD WITH ZEROS AND RETURNED TO THE  ---*\n*---     CALLER, ALONG WITH THE LENGTH OF THE RESULTING STRING.    ---*\n*---                                                               ---*\n*---     ARGUMENTS:                                                ---*\n*---         A(INPUT STRING)                                       ---*\n*---         A( F'INPUT STRING LENGTH')                            ---*\n*---         A(OUTPUT AREA)                                        ---*\n*---                                                               ---*\n*---     RETURNS:                                                  ---*\n*---         1. COMPACTED STRING IN THE OUTPUT AREA                ---*\n*---         2. RESULT LENGTH, IN BYTES, IN R0                     ---*\n*---                                                               ---*\n*---     NOTES: THE SAVE AREA CONVENTIONS ARE DESIGNED TO WORK     ---*\n*---     WITH THE ARCHIVER PROGRAM'S 'STACKED' SAVE AREAS. IF      ---*\n*---     ADAPTED TO OTHER USES, THE LINKAGE CONVENTIONS WILL       ---*\n*---     REQUIRE MODIFICATION.                                     ---*\n*---------------------------------------------------------------------*\nCOMPACT  CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n         USING COMPACT,R15\n         #STAMP\n         STM   R14,R12,12(R13)     SAVE ENTRY REGISTERS\n         LA    R14,72(,R13)        POINT TO NEXT SAVE AREA\n         ST    R13,4(,R14)         BACK POINTER\n         ST    R14,8(,R13)         FORWARD POINTER\n         LR    R13,R14             BUMP DOWN THE CHAIN\n         LR    R12,R15             COPY EPA\n         DROP  R15\n         USING COMPACT,R12         DECLARE THE BASE REGISTER\n         LM    R2,R4,0(R1)         LOAD PARM VALUES\n         L     R3,0(,R3)           LOAD INPUT STRING LENGTH\n         LA    R5,0(R2,R3)         POINT TO INPUT END\n         BCTR  R5,R0               AND BACK UP FOR BXLE\n         BAL   R9,SELTAB           GO SELECT THE COMPACTION TABLE\n         LR    R1,R4               COPY OUTPUT STRING POINTER\n         LA    R4,1                LOAD BXLE INCREMENT\n         LA    R6,0\n         LA    R7,0\n         LA    R9,0\n         LA    R10,0\n         LA    R11,0\n         LA    R14,0\n         LA    R15,0\n         USING CMPCT,R8            SET THE CONSTANTS DSECT\n*        R14 WILL CONTAIN THE BITS TO BE ADDED TO THE CURRENT STRING\n*        R9 WILL BE THE CURRENT STRING'S LENGTH\n*        R10 WILL BE THE CURRENT STRING\n*        R1 WILL BE THE OUTPUT POINTER\n*        R7 WILL BE THE NUMBER OF BITS BEING ADDED\n*        R0,R11 - WORK REGISTERS\n*        R11 WILL ALSO BE THE RETURN REGISTER FROM THE STORE SUBROUTINE\nML1      DS    0H\n         LR    R6,R5               COPY END POINTER\n         SR    R6,R2               COMPUTE WHAT'S LEFT\n         CH    R6,=H'4'            CLOSE TO END ??\n         BL    MLX                 YES; SKIP THE NEXT CHECK\n         CLC   1(3,R2),0(R2)       NEXT CHAR. REPEATED 4 TIMES ??\n         BE    MULT1               YES; PROCESS SPECIAL WAY\nMLX      DS    0H\n         LA    R6,0\n         IC    R6,0(,R2)           LOAD A CHARACTER\n         SLL   R6,2                TIMES 4\n         LA    R14,0               CLEAR LEFT REGISTER\n         L     R15,TREEV(R6)       LOAD THE STRING/LENGTH\n         SLDL  R14,8               SHIFT OFF THE LENGTH\n         LR    R7,R14              COPY THE LENGTH\n         LA    R3,32               LOAD LIMIT VALUE\n         SR    R3,R9               MINUS CURRENT LENGTH\n         LA    R14,0               CLEAR THAT REG\n         SLDL  R14,0(R3)           SHIFT THOSE BITS OVER\n         OR    R10,R14             ADD TO CURRENT STRING\n         AR    R9,R7               ADD LENGTHS\n         CH    R9,=H'32'           GOT ENOUGH, YET ---\n         BL    ML2                 NOPE ---\n         BAL   R11,STOREIT         NOPE; PARTIAL ADD AND STORE\nML2      DS    0H\n         BXLE  R2,R4,ML1           AND CONTINUE ---\n*        ALL DONE; STORE STRING REMAINDER AND EXIT\nRET1     DS    0H\n         CH    R9,=H'0'            ZERO LEFT ??\n         BNH   RET2                YES ---\n         ST    R10,0(,R1)          STORE THE LAST WORD\n         LA    R1,4(,R1)           BUMP OUTPUT POINTER\nRET2     DS    0H\n         L     R2,4(,R13)          LOAD BACK SAVE AREA POINTER\n         L     R2,24(,R2)          LOAD PARMLIST POINTER\n         L     R2,8(,R2)           LOAD OUTPUT STRING POINTER\n         LR    R0,R1               COPY OUTPUT CURSOR\n         SR    R0,R2               COMPUTE OUTPUT LENGTH\n         L     R13,4(,R13)         LOAD BACK POINTER, AGAIN\n         L     R14,12(,R13)        LOAD RETURN ADDRESS\n         LM    R2,R12,28(R13)      RESTORE REGISTERS\n         MVI   12(R13),255         SET 'DONE' FLAG\n         LA    R15,0               SET ZERO RETURN CODE\n         BR    R14                 AND RETURN TO CALLER\nSTOREIT  DS    0H\n         ST    R10,0(,R1)          STORE COMPLETED STRING\n         LA    R1,4(,R1)           BUMP OUTPUT CURSOR\n         LR    R10,R15             WHAT WAS LEFT FROM BEFORE\n         SH    R9,=H'32'           RESET CURRENT-STRING LENGTH\n         BR    R11                 AND RETURN TO (LOCAL) CALLER\n         LTORG\nMULT1    DS    0H\n         LA    R0,0                CLEAR THE COUNT REGISTER\n         LA    R14,0               CLEAR LEFT REGISTER\n         L     R15,MULTS           LOAD THE STRING/LENGTH\n         SLDL  R14,8               SHIFT OFF THE LENGTH\n         LR    R7,R14              COPY THE LENGTH\n         LA    R3,32               LOAD LIMIT VALUE\n         SR    R3,R9               MINUS CURRENT LENGTH\n         LA    R14,0               CLEAR THAT REG\n         SLDL  R14,0(R3)           SHIFT THOSE BITS OVER\n         OR    R10,R14             ADD TO CURRENT STRING\n         AR    R9,R7               ADD LENGTHS\n         CH    R9,=H'32'           GOT ENOUGH, YET ---\n         BL    MULT2               NOPE ---\n         BAL   R11,STOREIT         NOPE; PARTIAL ADD AND STORE\nMULT2    DS    0H\n         LA    R6,0(,R2)           COPY STARTING ADDRESS\n         LA    R14,0(,R2)             AND RIPPLING ADDRESS\n         LA    R15,1(,R5)          COPY ENDING ADDRESS\n         SR    R15,R14             COMPUTE LENGTH TO COMPARE\n         CH    R15,=H'255'         LONGER THAN MAX ??\n         BNH   MULT3               NOPE ---\n         LA    R15,255             YES; ASSUME MAX FOR NOW\nMULT3    DS    0H\n         LR    R7,R15              AND COPY THAT VALUE\n         LA    R15,0               TWICE ---\n         ICM   R15,8,0(R6)         INSERT 'PAD' CHARACTER\n         CLCL  R6,R14              COMPARE/SEARCH\n         LR    R0,R6               COPY END ADDRESS\n         SR    R0,R2               COMPUTE BYTES COMPARED\n         LR    R2,R6               NEW INPUT ADDRESS\n         BCTR  R2,R0               ACCOUNT FOR BXLE STUFF\n         LR    R6,R0               COPY TO INPUT CHAR. REGISTER\n         LA    R14,0               CLEAR LEFT REGISTER\n         SLL   R6,2                TIMES 4\n         L     R15,TREEV(R6)       LOAD THE STRING/LENGTH\n         SLDL  R14,8               SHIFT OFF THE LENGTH\n         LR    R7,R14              COPY THE LENGTH\n         LA    R3,32               LOAD LIMIT VALUE\n         SR    R3,R9               MINUS CURRENT LENGTH\n         LA    R14,0               CLEAR THAT REG\n         SLDL  R14,0(R3)           SHIFT THOSE BITS OVER\n         OR    R10,R14             ADD TO CURRENT STRING\n         AR    R9,R7               ADD LENGTHS\n         CH    R9,=H'32'           GOT ENOUGH, YET ---\n         BL    MULT4               NOPE ---\n         BAL   R11,STOREIT         NOPE; PARTIAL ADD AND STORE\nMULT4    DS    0H\n         LA    R6,0\n         IC    R6,0(,R2)           INSERT THE REPEATED CHARACTER\n         LA    R14,0               CLEAR LEFT REGISTER\n         SLL   R6,2                TIMES 4\n         L     R15,TREEV(R6)       LOAD THE STRING/LENGTH\n         SLDL  R14,8               SHIFT OFF THE LENGTH\n         LR    R7,R14              COPY THE LENGTH\n         LA    R3,32               LOAD LIMIT VALUE\n         SR    R3,R9               MINUS CURRENT LENGTH\n         LA    R14,0               CLEAR THAT REG\n         SLDL  R14,0(R3)           SHIFT THOSE BITS OVER\n         OR    R10,R14             ADD TO CURRENT STRING\n         AR    R9,R7               ADD LENGTHS\n         CH    R9,=H'32'           GOT ENOUGH, YET ---\n         BL    MULT5               NOPE ---\n         BAL   R11,STOREIT         NOPE; PARTIAL ADD AND STORE\nMULT5    DS    0H\n         B     ML2                 NOPE; CONTINUE\n         DROP  R8\n         EJECT\nSELTAB   DS    0H\n         L     R8,=V(TBL60)\n         BR    R9\n         DC    V(ARCHTABS)         CSECT OF TABLES ---\nCMPCT    DSECT\nMULTS    DS    XL4                 REPEATED-STRING MARKER\nTREEV    DS    256XL4              ACTUAL COMPACTED CHARACTER VALUES\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DOTIME": {"ttr": 12299, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00\\x15\\x00\\x15\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 21, "newlines": 21, "modlines": 0, "user": "ARCHIVR"}, "text": "         CLI   RSRDATE,0           NEW FORMAT DATE ??\n         BE    DATENEW             YES ---\n         MVC   2(8,R2),RSRDATE     COPY THE DATE\n         MVC   0(6,R2),2(R2)       MAKE ROOM FOR CENTURY\n         MVC   6(2,R2),=C'19'      INSERT CENTURY\n         LA    R2,11(,R2)          POINT TO CLOCK FIELD\n         MVC   0(8,R2),RSRTIME     MOVE THE CLOCK FIELD\n         B     DOCOUNT             GO FORMAT THE RECORD COUNT\nDATENEW  DS    0H\n         UNPK  2(8,R2),RSRDATE     UNPK DATE INTO LINE\n         MVC   0(2,R2),2(R2)       MAKE ROOM\n         MVC   3(2,R2),4(R2)         FOR SLASHES\n         MVI   2(R2),C'/'\n         MVI   5(R2),C'/'\n         LA    R2,11(,R2)          POINT TO TIME FIELD\n         UNPK  2(6,R2),RSRTIME     UNPACK TIME INTO THE FIELD\n         MVC   0(2,R2),2(R2)       MAKE ROOM\n         MVC   3(2,R2),4(R2)          FOR COLONS\n         MVI   2(R2),C':'\n         MVI   5(R2),C':'\nDOCOUNT  DS    0H\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DYNAM": {"ttr": 12545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x04\\x91\\x04\\x91\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 1169, "newlines": 1169, "modlines": 0, "user": "ARCHIVR"}, "text": "DYN      TITLE 'DYNAMIC ALLOCATION INTERFACE'\n*\n*   CREATE A VERB TABLE ENTRY\n*\n         MACRO\n         VENT  &VERB,&NUMBER\n         LCLA  &LABEL\n&LABEL   SETA  &SYSNDX\n         DC    AL1(L'#&LABEL)\n         DC    AL1(&NUMBER)\n#&LABEL  DC    C'&VERB'\n         MEND\n         SPACE 3\n*\n*   CREATE A KEYWORD TABLE ENTRY\n*   &KEYWORD  - THE DYNAM KEYWORD\n*   &UAL      - THE DYNAM KEYWORD UNAMBIGOUS LENGTH\n*   &KEY      - THE SVC99 TEXT UNIT KEY\n*   &PARM     - THE SVC99 TEXT UNIT PARM\n*   &PARMLEN  - THE SVC99 TEXT UNIT PARM LENGTH\n*\n         MACRO\n         KENT  &KEYWORD,&UAL,&KEY,&PARM,&PARMLEN\n         GBLA  &OFFSET\n         LCLA  &LABEL\n         LCLC  &LEN\n&LEN     SETC  '0'\n&LABEL   SETA  &SYSNDX\n         DC    AL1(L'#&LABEL)\n         DC    X'&UAL'\n         AIF   (T'&PARM EQ 'O').NOPARM\n         AIF   ('&PARM' NE 'SUBTABLE').KENT003\n         DC    AL1(&OFFSET+240)\n&OFFSET  SETA  &OFFSET+1\n&LEN     SETC  '1'\n         AGO   .KENT001\n.KENT003 ANOP\n         DC    X'&PARM'\n&LEN     SETC  '1'\n         AGO   .KENT001\n.NOPARM  ANOP\n         DC    AL1(0)\n.KENT001 ANOP\n         AIF   (T'&PARMLEN EQ 'O').KENT002\n&LEN     SETC  '&PARMLEN'\n.KENT002 ANOP\n         DC    AL1(&LEN)\n         DC    AL2(&KEY)\n#&LABEL  DC    C'&KEYWORD'\n         MEND\n         EJECT\n*\n*   CREATE A KEYWORD HASH TABLE ENTRY\n*\n         MACRO\n         BEGIN &CHAR\nBEGIN&CHAR DS  0X\n         MEND\n         SPACE 3\n*\n*   CREATE THE KEYWORD TABLE HASH INDEX\n*\n         MACRO\n         INDEX\nKYWDINDX DS    0F                 ALIGN ON FULLWORD BOUNDARY\n         DC    A(BEGINA)\n         DC    A(BEGINB)\n         DC    A(BEGINC)\n         DC    A(BEGIND)\n         DC    A(BEGINE)\n         DC    A(BEGINF)\n         DC    A(BEGING)\n         DC    A(BEGINH)\n         DC    A(BEGINI)\n         DC    7A(0)\n         DC    A(BEGINJ)\n         DC    A(BEGINK)\n         DC    A(BEGINL)\n         DC    A(BEGINM)\n         DC    A(BEGINN)\n         DC    A(BEGINO)\n         DC    A(BEGINP)\n         DC    A(BEGINQ)\n         DC    A(BEGINR)\n         DC    8A(0)\n         DC    A(BEGINS)\n         DC    A(BEGINT)\n         DC    A(BEGINU)\n         DC    A(BEGINV)\n         DC    A(BEGINW)\n         DC    A(BEGINX)\n         DC    A(BEGINY)\n         DC    A(BEGINZ)\n         MEND\n         EJECT\n*\n*   BEGIN A NEW SUBTABLE\n*   SET COUNT OF # OF ENTRIES FOR PREVIOUS SUBTABLE\n*   REMEMBER ENTRY POINT\n*\n         MACRO\n         BEGINSUB                 &SUBNAME\n         GBLC  &SUBLIST(30)       LIST OF SUBTABLE ENTRIES\n         GBLA  &SUBCT(30)         LIST OF SUBTABLE ENTRY COUNTS\n         GBLA  &SUBINDX           CURRENT SUBTABLE\n         GBLA  &SUBSENT           # ENTRIES IN CURRENT SUBTABLE\n         AIF   (&SUBINDX EQ 0).SUB0001 FIRST INVOCATION\n&SUBCT(&SUBINDX) SETA &SUBSENT\n&SUBSENT SETA  0\n.SUB0001 ANOP\n&SUBINDX SETA  &SUBINDX+1\n&SUBLIST(&SUBINDX) SETC '&SUBNAME'\n&SUBNAME DS    0X\n         MEND\n         SPACE 3\n*\n*   ADD LAST SUBTABLE DEFINITION TO SUBTABLE LIST\n*\n         MACRO\n         ENDSUB\n         GBLA  &SUBCT(30)\n         GBLA  &SUBINDX\n         GBLA  &SUBSENT\n&SUBCT(&SUBINDX) SETA &SUBSENT\n         MEND\n         EJECT\n*\n*       GENERATE THE INDEX FOR ALL SUBTABLES\n*\n         MACRO\n&LABEL   SUBINDEX\n         GBLC  &SUBLIST(30)\n         GBLA  &SUBCT(30)\n         GBLA  &SUBINDX\n         LCLA  &X\n         AIF   (&SUBINDX LE 15).NOERR\n         MNOTE 16,'ONLY 16 SUBTABLES PERMITTED'\n.NOERR   ANOP\n&LABEL   DS    0F\n.LOOP    ANOP\n         AIF   (&X EQ &SUBINDX).#1\n&X       SETA  &X+1\n         DC    AL1(&SUBCT(&X)),AL3(&SUBLIST(&X))\n         AGO   .LOOP\n.#1      ANOP\n         MEND\n         SPACE 3\n*\n*   BUILD AN ENTRY IN A SUBTABLE\n*\n         MACRO\n         SENT  &KEY,&VALUE\n         GBLA  &SUBSENT\n         LCLA  &LABEL\n&SUBSENT SETA  &SUBSENT+1\n&LABEL   SETA  &SYSNDX\n         DC    AL1(L'#&LABEL)\n         DC    XL2'&VALUE'\n#&LABEL  DC    C'&KEY'\n         MEND\n         EJECT\n*\n*   BUILD A TABLE USED TO BUILD A DICB\n*\n         MACRO\n&LABEL   DICBTAB1\n&LABEL   DS    0H\n         DC    X'000400010008',XL8'00' DDNAME\n         DC    X'00050001002C',XL44'00' DSNAME\n         DC    X'000600010008',XL8'00' MEMBER NAME\n         DC    X'000700010001',X'00' STATUS\n         DC    X'000800010001',X'00' DISPOSITION\n         DC    X'000900010001',X'00'  CONDITIONAL DISPOSITION\n         DC    X'000A00010002',XL2'00' DSORG\n         DC    X'000B00010002',XL2'00' LIMIT SPECIFICATION\n         DC    X'000C00010001',X'00' ATTRIBUTE SPECIFICATION\n         DC    X'000D00010001',X'00' LAST ENTRY SPECIFICATION\n         DC    X'000E00010001',X'00' DATA SET TYPE\n         MEND\n         MACRO\n&LABEL   DICBTAB2\n&LABEL   DS    0H\n         DC    X'005500010008',XL8'00' DDNAME\n         DC    X'00560001002C',XL44'00' DSNAME\n         DC    X'005700010002',XL2'00' DSORG\n         DC    X'005D00010006',XL6'00' VOLSER\n         MEND\n         EJECT\n***********************************************************************\n*\n*   THIS ROUTINE PROVIDES AN INTERFACE BETWEEN A HIGH LEVEL\n*   LANGUAGE SUCH AS FORTRAN, PL/1 OR COBOL, AND THE OPERATING\n*   SYSTEM DYNAMIC ALLOCATION ROUTINES.\n*\n*   INSTALLATION: UNIVERSITY OF MANITOBA COMPUTER CENTRE\n*   AUTHOR:       GERRY DUECK\n*   DATE WRITTEN: SUMMER 1978\n*   MODS:         ADDITION OF ALLOCR VERB.\n*                 LOTS OF MUCKING ABOUT TO MAKE THIS PROGRAM\n*                 CONSISTENT WITH ITS DOCUMENATION.\n*                   ROD ZAZUBEK FEB 1979\n*   DOCUMENTATION: COMPLETE DOCUMENTATION ON THE USE OF DYNAM IS\n*                  AVAILABLE IN SYS4.DOCUMENT.TEXT(DYNAM)\n*   ATTRIBUTES:   RENT\n*   HINTS:        PUT THIS PROGRAM SOMEWHERE IN THE LINK LIST.\n*\n*   PARAMETERS\n*      1 - WORK AREA. THE FIRST WORD OF THIS WORK AREA MUST CONTAIN\n*          THE LENGTH OF THE AREA. A MINIMUM OF 100 BYTES IS REQUIRED.\n*          IF THE LENGTH IS ZERO, AND 'INIT' IS NOT SPECIFIED (SEE\n*          PARM 2) THEN A WORK AREA IS OBTAINED AND USED FOR THIS\n*          CALL ONLY. THE WORKAREA IS FREED BEFORE RETURNING TO THE\n*          CALLER.\n*      2 - REQUEST VERB. THIS FIELD IS DELIMITED BY A BLANK.\n*          IF THE REQUEST VERB IS 'INIT' THEN ALL THIS CALL\n*          DOES IS TO ALLOCATE A WORK AREA FOR SUBSEQUENT\n*          CALLS. IF THE VERB IS 'END' THEN THIS WORK AREA\n*          IS FREED.\n*      3 AND SUBSEQUENT PARAMETERS.\n*        - CHARACTER STRINGS CONSISTING OF KEYWORD/VALUE PAIRS\n*          SEPARATED BY '=' AND DELIMITED BY ' ', ';'.\n*          END OF STRING IS DETERMINED BY ';'\n*          END OF LIST IS INDICATED BY THE HIGH ORDER BIT OF\n*          THE PARAMETER ADDRESS.\n*      AT LEAST 3 PARAMETERS ARE ASSUMED FOR ALL VERBS OTHER THAN\n*      'INIT' AND 'END'\n*\n*   WORK AREA.\n*      THE WORK AREA CONTAINS 5 SECTIONS:\n*         - WORK AREA CONTROL BLOCK.\n*         - DAIRFAIL PARAMETER LIST.\n*         - DYNAMIC ALLOCATION REQUEST BLOCK.\n*         - TEXT UNITS.\n*         - TEXT POINTERS.\n*      THE TEXT POINTERS ARE STACKED AT THE BOTTOM OF THE WORK AREA.\n*      THE TEXT UNITS ARE HEAPED AFTER THE REQUEST BLOCK.\n*\n*  ENTRY OPTIONS:\n*     IF VERB = 'INIT' THEN\n*        GET WORK AREA\n*        PLACE ADDRESS IN PARM 1\n*        SET FIRST BYTE OF PARM 1 TO X'0F' TO INDICATE\n*           THAT THIS IS A GETMAINED AREA\n*        RETURN\n*     ELSE IF VERB = 'END' THEN\n*        FREE THE AREA POINTED TO BY PARM ONE\n*        RETURN\n*     ELSE IF PARM 1 = 0 THEN\n*        GETMAIN AREA\n*        PERFORM ALLOCATION\n*        FREMAIN AREA\n*        RETURN\n*     ELSE IF HIGH ORDER BYTE OF PARM 1 IS X'0F' THEN\n*        DEREFENCE WORK AREA POINTER\n*        PERFORM COMMAND\n*     ELSE\n*        PERFORM COMMAND USING USER SUPPLIED WORK AREA\n*\n*   THREE TABLES ARE USED TO BUILD TEXT UNITS FOR SVC99.\n*\n*   VERB TABLE:\n*      THERE ARE ONLY 7 VERBS USED BY SVC99, AND SINCE SOME OF\n*      THESE ARE INFORMATION VERBS (IE THEY RETURN INFO) THEY ARE\n*      NOT SUPPORTED BY THIS INTERFACE SINCE THERE IS NO TRIVIAL\n*      MEANS OF RETURNING INFORMATION TO THE CALLER. THE VERB MUST\n*      BE AT LEAST AS LONG AS THE LENGTH SPECIFIED IN ITS CORRESONDING\n*      TABLE ENTRY. ACCESS TO THIS TABLE IS BY LINEAR SEARCH AND THE\n*      RESULT IS A ONE BYTE FIELD CONTAINING THE VERB CODE. TABLE\n*      ENTRIES ARE OF VARIABLE LENGTH WITH THE FIRST BYTE CONTAINING\n*      THE LENGTH OF THE VARIABLE PART. THE LENGTH OVERHEAD IS 2.\n*\n*   KEYWORD TABLE:\n*      THE KEYWORD TABLE IS VERY LONG, AND THE ENTRIES ARE VARIABLE\n*      LENGTH SO A BINARY SEARCH IS OUT OF THE QUESTION (UNLESS YOU\n*      HAD A TAG POINTING TO EACH TABLE ENTRY -- HMMMMM...) AND A\n*      LINEAR SEARCH IS TOO SLOW. A PRIMITIVE HASH TABLE IS USED\n*      IN WHICH THERE IS AN ENTRY FOR EVERY LETTER AND A POINTER\n*      TO THE FIRST KEYWORD TABLE ENTRY WHOSE KEYWORD STARTS WITH\n*      THAT LETTER. THE KEYWORD TABLE IS SORTED ALPHABETICALLY\n*      AND THE HASH TABLE IS BUILT BY INSERTING A BEGIN MACRO\n*      EVERY TIME A CHANGE IN FIRST LETTER OCCURS. WHEN PERFORMING\n*      A SEARCH ON THIS TABLE, COMPARISONS ARE MADE TO THE LENGTH\n*      OF THE KEYWORD SPECIFIED BY THE USER. WHEN A MATCH IS FOUND,\n*      THE LENGTH OF THE KEYWORD IS COMPARED TO THE MINIMUM LENGTH\n*      SPECIFIED IN THE TABLE ENTRY. IT MUST BE AT LEAST THIS LONG\n*      IN ORDER TO BE UNAMBIGOUS.\n*\n*   KEYWORD SUBTABLE:\n*     SOME OF THE ENTRIES IN THE KEYWORD TABLE REQUIRE MORE INFORMATION\n*      AND FOR THESE A POINTER TO A SUBTABLE IS SUPPLIED. THIS POINTER\n*      IS AN INDEX INTO ANOTHER TABLE MUCH LIKE THE HASH TABLE AND IS\n*      ONLY ONE BYTE, SO ONLY 16 SUBTABLES CAN OCCUR.\n*\n*   BUILDING A TEXT UNIT:\n*      AFTER FINDING THE KEYWORD IN THE KEYWORD TABLE, A VARIETY\n*      OF EVENTS CAN OCCUR. THIS IS BECAUSE IBM IN ITS INFINITE\n*      WISDOM CANNOT DECIDE ON A SIMPLE STRUCTURE FOR TEXT UNITS.\n*      SOME HAVE PARAMETERS THAT ARE PLI TYPE CHAR VAR, SOME ARE\n*      VARIABLE LENGTH BINARY VALUES, SOME HAVE NO PARAMETERS, ETC.\n*      THE FOLLOWING ALGORITHM IS USED TO BUILD THE TEXT UNIT:\n*\n*      IF THE USER SUPPLIED A PARM THEN\n*         IF A NON ZERO LENGTH IS SPECIFIED IN THE KEYWORD TABLE THEN\n*            CREATE A TEXT UNIT WITH A VARIABLE LENGTH BINARY VALUE\n*         ELSE\n*            CREATE A TEXT UNIT WITH A VARIABLE LENGTH STRING VALUE\n*      ELIF THE PARM VALUE SUPPLIED IN THE KEYWORD TABLE IS >= X'F0'\n*         CREATE A TEXT UNIT USING THE LENGTH AND VALUE SUPPLIED\n*         IN THE SUBTABLE ENTRY CORRESSPONDING TO THE USER SUPPLIED\n*         VALUE\n*      ELSE\n*         CREATE A TEXT UNIT USING A LENGTH OF 1 AND THE VALUE\n*         SUPPLIED IN THE KEYWORD TABLE\n*\n*      THIS ALGORITHM WORKS WELL ENOUGH EXCEPT FOR TWO KLUGES:\n*      CONCATENATION AND MULTI-VALUED KEYWORDS SUCH AS RECFM.\n*\n*      FOR CONCATENATION, THE TEXT UNIT MUST CONTAIN A VARIABLE\n*      NUMBER OF VARIABLE LENGTH CHARACTER STRINGS SHOVED TOGETHER.\n*      IF A ',' OCCURS AFTER A VALUE,THEN THE NEXT VALUE IS SCANNED AND\n*      CONCATENATED TO THE CURRENT ONE. THIS ASSUMES THAT THE TEXT UNIT\n*      IS ONE FOR WHICH CONCATENATED STRINGS ARE REQUIRED. IT IS UP TO\n*      THE USER TO SUPPLY CORRECT DATA.\n*\n*      FOR THE SPECIAL KEYWORDS RECFM AND OPTCD, EACH LETTER OF THE\n*      VALUE IS INDIVIDUALLY LOOKED UP IN THE SUBTABLE AND THE VALUE\n*      THUS OBTAINED IS OR'ED WITH THE VALUE ALREADY IN THE TEXT UNIT.\n*      IE RECFM=FBA = X'80' | X'10' | X'04' = X'94'\n*\n*   RETURN CODES AND DIAGNOSTICS:\n*      IF THE RETURN CODE FROM SVC99 IS NOT ZERO THEN A PARAMETER\n*      BLOCK FOR DAIRFAIL IS BUILT. DAIRFAIL IS CALLED AND THE\n*      DIAGNOSTIC THAT IT GENERATES IS WRITTEN TO THE JOB LOG (WTP).\n*\n*      THE INTERFACE ALSO HAS ITS OWN RETURNS CODES FOR ERRORS IS\n*      DETECTS IN THE USERS PARAMETER LIST. THESE START AT 4 HIGHER\n*      THAN THE RETURN CODES FROM SVC99.\n*\n*      THE RETURN CODE IS RETURNED BOTH IN REGISTER 15 AND IN THE\n*      SECOND WORD OF THE WORKAREA, IF IT STILL EXISTS AT THE END\n*      OF THE ROUTINE.\n*\n*   SVC99 RETURN CODES (SEE SPL:JOB MANAGEMENT PAGE 34)\n*      00 SUCCESSFULL COMPLETION\n*      04 ENVIRONMENT, RESOURCE FAILURE, SYSTEM ROUTINE\n*      08 REQUEST DENIED BY INSTALLATION VALIDATION ROUTINE\n*      12 INVALID PARAMETER LIST\n*\n*   INTERFACE RETURN CODES\n*      16 INVALID VERB\n*      20 INVALID KEYWORD\n*      24 WORK AREA OVERFLOW\n*      28 VALUE NOT FOUND IN SUBTABLE: INVALID VALUE\n*\n***********************************************************************\n         EJECT\nWORKAREA DSECT\nWALEN    DS    F                  LENGTH OF WORK AREA\nWAS99RC  DS    A                  VALUE OF RETURN CODE FROM SVC 99\nWADWORD  DS    D                  DOUBLE WORD FOR PACKS\nWABOTTOM DS    A                  END OF WORK AREA\nWAKYSTRT DS    A                  START OF KEYWORD\nWAVALAD  DS    A                  START OF VALUE\nWAVBSTRT DS    A                  START OF VERB\nWAS99RB  DS    A                  POINTER TO REQUEST BLOCK\nWADFID   DS    XL2                CALLER IDENTIFIER FOR DAIR FAIL\nWADFDSCT DS    A                  ADDR OF DSECT FOR CALLING DAIR FAIL\nWAZEROES DS    A                  ADDRESS OF IKJEFF02\nWALASTTU DS    A                  ADDRESS OF END OF LAST TEXT UNIT\nWAALLOCR DS    XL1                IS THIS AN ALLOCR VERB\nWATRUE   EQU   X'FF'\nWASAVE   DS    18F                SAVE AREA FOR DAIRFAIL\nWAEND    EQU   *                  END OF DSECT\n         SPACE 1\nVERBTABL DSECT\nVTVLEN   DS    X                  LENGTH OF VERB\nVTVERB   DS    X                  VERB CODE\nVTVSTR   DS    0C                 VERB STRING\nVTVEND   EQU   *\n         SPACE 1\nKYWDTABL DSECT\nKYWDLEN  DS    X                  KEYWORD LENGTH\nKYWDMIN  DS    X                  MINIMUM UNAMBIGOUS LENGTH\nKYWDPARM DS    X                  SPECIAL PARAMETER\nKYNOPARM EQU   X'00'              FLAGS NO PARM\nKYWDPMLN DS    X                  LENGTH OF PARM IF FIXED LENGTH\nKYWDKEY  DS    2X                 KEYWORD KEY\nKYWDSTRG DS    0C                 KEYWORD STRING\n         ORG   KYWDPARM\nKYWDSUBT DS    X                  FLAG A SUBTABLE FOR THIS ENTRY\nKYWDSUBF EQU   X'F0'              FLAGS A SUBTABLE\n         ORG\n         SPACE 1\nVALUTABL DSECT\nVALULEN  DS    X                  LENGTH OF STRING IN THIS ENTRY\nVALUPARM DS    2X                 PARAMETER VALUE FOR TEXT UNIT\nVALUSTRG DS    0C                 ENTRY STRING\n         SPACE 1\nCHAR     DSECT\nCH       DS    C\n         EJECT\nDICB1    DSECT\nDIDDN    DS    XL14               DDNAME\nDIDSN    DS    XL50               DSNAME\nDIMEM    DS    XL14               MEMBER NAME\nDISTAT   DS    XL7                STATUS\nDIDISP   DS    XL7                NORMAL DISPOSITION\nDICDISP  DS    XL7                CONDITIONAL DISPOSITION\nDIDSORG  DS    XL8                DSORG\nDILIMIT  DS    XL8                NUMBER RESOURCES TO BE FREED\nDIATTR   DS    XL7                ATTRIBUTE SPECIFICATION\nDILAST   DS    XL7                LAST ENTRY SPECIFICATION\nDITYPE   DS    XL7                DATA SET TYPE (DUMMY,TERMINAL,OTHER)\nDILEN1   EQU   *-DICB1\nDICB2    DSECT\nDIDDN2   DS    XL14\nDIDSN2   DS    XL50\nDIDSORG2 DS    XL8\nDIVOL2   DS    XL12\nDILEN2   EQU   *-DICB2\n         EJECT\n         IEFZB4D0\n         EJECT\n         IEFZB4D2\n         EJECT\n         IKJEFFDF DFDSECT=YES\n         EJECT\n@WA      EQU   11                 BASE ADDRESS FOR WORK AREA\n@RB      EQU   10                 BASE ADDRESS FOR REQUEST BLOCK\n@TP      EQU   9                  BASE ADDRESS FOR TEXT POINTERS\n@TU      EQU   8                  TEXT UNIT\n@CH      EQU   7                  POINTER INTO PARM STRING\n@VTE     EQU   6                  VERB TABLE ENTRY\n@KTE     EQU   6                  KEYWORD TABLE ENTRY\nLENGTH   EQU   5\n@DF      EQU   5                  BASE ADDRESS FOR DFDSECT\n         SPACE 1\nDYNAM    CSECT\n         USING DYNAM,12           ADDRESSIBILITY FOR CSECT\n         SAVE  (14,12),,DYNAM-MARCH-22-1979\n         LR    R12,R15            GET BASE FOR CSECT\n         SPACE 1\n         USING WORKAREA,@WA       ADDRESSIBILITY FOR WORK AREA\n         USING S99RB,@RB          ADDRESSIBILITY FOR REQUEST BLOCK\n         USING S99TUPL,@TP        ADDRESSIBILITY FOR TEXT POINTERS\n         USING S99TUNIT,@TU       ADDRESSIBILITY FOR TEXT UNITS\n         USING CHAR,@CH\n         USING VERBTABL,@VTE      ADDRESSIBILITY FOR VERB TABLE\n         USING DFDSECTD,@DF       ADDRESSIBILITY FOR DAIRFAIL DSECT\n         SPACE 1\n*\n**   DECODE ENTRY OPTIONS\n*\n         L     R2,4(R1)           ADDRESS OF VERB\n         CLC   0(4,R2),=C'INIT'\n         BE    INITCODE\n         CLC   0(3,R2),=C'END'\n         BE    ENDCODE\n         L     @WA,0(R1)          ADDRESS OF WORK AREA\n         OC    WALEN,WALEN        IS IT 0?\n         BNZ   WORKGOT            NOPE\n         LR    R2,R1              SAVE R1\n         GETMAIN R,LV=2048\n         L     R3,0(R2)           ADDR OF PARM 1\n         ST    R1,0(R3)           SAVE ADDRESS\n         MVI   0(R3),X'0E'        MARK TO BE FREED AFTER ALLOCATE\n         L     @WA,0(R3)          GET ADDRESS\n         LA    R3,2048            LENGTH OF WORKAREA\n         ST    R3,WALEN           SET LENGTH\n         LR    R1,R2              RESTORE R1\n         B     WORKSET\nWORKGOT  CLI   WALEN,X'0F'        IS THIS THE ADDRESS OF A WORK AREA?\n         BNE   WORKSET            NOPE, USER SUPPLIED AREA\n         L     @WA,WALEN          YES, DEREFENCE IT\nWORKSET  DS    0H\n*\n**   SET UP WORK AREA\n*\n         L     @TP,WALEN          GET LENGTH\n         LR    R2,@WA             ADDRESS OF WORK AREA\n         LR    R3,@TP             LENGTH\n         LR    R4,R2              FROM ADDR FOR ZAP\n         XR    R5,R5\n         MVCL  R2,R4              ZAP WORK AREA\n         LR    R15,R13            ADDR OF CALLERS SAVE\n         LA    R13,WASAVE\n         ST    R13,8(R15)         FORE LINK\n         ST    R15,4(R13)         BACK LINK\n         ST    @TP,WALEN\n         AR    @TP,@WA            + ADDRESS = END OF WORK AREA\n         ST    @TP,WABOTTOM\n         LA    @RB,WAEND          BEGINNING OF REQUEST BLOCK\n         ST    @RB,WADFDSCT       ADDRESS OF DFDSECTD\n         LA    @RB,DFLEN(@RB)     POINT PAST DFDSECTD\n         ST    @RB,WAS99RB        ADDRESS OF REQUEST BLOCK\n         LA    @TU,S99RBEND       BEGINNING OF TEXT UNIT HEAP\n         MVI   S99RBLN,X'14'      LENGTH OF RB\n*\n**  EXAMINE THE VERB PARAMETER\n*\n         L     @CH,4(R1)          GET SECOND PARM\n         LA    @VTE,VERBTAB       FIRST ENTRY IN VERB TABLE\n         SR    R2,R2\nVERBLOOP DS    0H\n         C     @VTE,VERBTEND      END OF TABLE?\n         BE    FAILVERB           YES, VERB NOT FOUND\n         IC    R2,VTVLEN          GET LENGTH OF VERB\n         BCTR  R2,0               LESS 1\n         EX    R2,VERBCLC         MATCH?\n         BE    VERBPOOL           YES\n         LA    @VTE,VTVSTR+1(R2)  GET NEXT ENTRY\n         B     VERBLOOP\nVERBCLC  CLC   VTVSTR,CH\nVERBPOOL DS    0H\n         CLC   CH(6),=C'ALLOCR'   VERB = ALLOCR?\n         BNE   VERBEND\n         MVI   WAALLOCR,WATRUE    SET ALLOCR FLAG\nVERBEND  DS    0H\n         MVC   S99VERB,VTVERB     MOVE IN VERB CODE\n*\n*  SCAN OFF KEYWORD PARAMETERS.\n*\n         CLI   4(R1),X'80'        END OF PARM LIST?\n         BE    FAILKEY\n         LA    R1,8(R1)           POINT TO THIRD PARAMETER\n         CLI   S99VERB,S99VRBIN   VERB = INFO?\n         BE    RETINFO            YUP\n         CLI   WAALLOCR,WATRUE    VERB = ALLOCR?\n         BE    RETALLOC\n         B     PARMLOOP           NOPE, START LOOP\n*\n**   SET UP THE TEXT UNITS FOR DYNAMIC INFORMATION RETRIEVAL\n**   THIS IS FOR THE INFO AND ALLOCR VERBS\n*\nRETINFO  DS    0H\n         LA    R2,DILEN1(@TU)     POINT TO END OF DICB\n         MVC   0(DILEN1,@TU),DICBS1 MOVE IN MODEL TEXT UNITS\n         B     RETLOOP\nRETALLOC DS    0H\n         LA    R2,DILEN2(@TU)     POINT TO END OF DICB2\n         MVC   0(DILEN2,@TU),DICBS2 MOVE IN MODEL TEXT UNITS\nRETLOOP  DS    0H\n         S     @TP,=F'4'          POINT TO TUPTR ENTRY\n         ST    @TU,S99TUPTR       SET POINTER\n         LH    R3,S99TULNG        GET LENGTH OF PARM FIELD\n         LA    @TU,S99TUPAR(R3)   POINT TO NEXT TEXT UNIT\n         CR    @TU,R2             END OF DICB?\n         BNE   RETLOOP\n         CLI   0(R1),X'80'        LAST PARM?\n         BE    PARMPOOL           YES\n         LA    R1,4(R1)           POINT TO NEXT PARM\nPARMLOOP DS    0H\n         L     @CH,0(R1)          GET ADDRESS OF STRING\n         LA    @CH,0(@CH)         ZERO TOP BYTE\nSTRINGLP DS    0H                 START OF STRING LOOP\nSTRING01 DS    0H\n         CLI   CH,C';'            END OF STRING\n         BE    STRINGPL           YES, GOTO END OF STRING LOOP\n         CLI   CH,C','            COMMA?\n         BE    STRING02\n         CLI   CH,C' '            BLANK?\n         BNE   STRING03\nSTRING02 LA    @CH,1(@CH)         GET NEXT CHAR\n         B     STRING01\nSTRING03 DS    0H\n         LA    R2,15             LENGTH OF LONGEST KEYWORD\n         ST    @CH,WAKYSTRT       SAVE START ADDRESS\nKEYSLOOP DS    0H\n         CLI   CH,C'='            END OF KEYWORD?\n         BE    KEYSPOOL\n         CLI   CH,C','\n         BE    KEYSPOOL\n         CLI   CH,C';'\n         BE    KEYSPOOL\n         CLI   CH,C' '\n         BE    KEYSPOOL\n         LA    @CH,1(@CH)         GET NEXT CHAR\n         BCT   R2,KEYSLOOP\n         B     FAILKEY            KEY WORD FAILED\n         USING KYWDTABL,@KTE      ADDRESSIBILITY FOR KEY WORD TABLE\nKEYSPOOL DS    0H\n*\n** KEYWORD - SCAN OFF AND LOOK UP A KEYWORD\n*\nKEYWORD  DS    0H\n         L     R3,WAKYSTRT        GET FIRST CHR IN WORD\n         CLI   0(R3),C'A'\n         BL    FAILKEY            INVALID KEYWORD\n         CLI   0(R3),C'Z'\n         BH    FAILKEY            INVALID KEYWORD\n         IC    R2,0(R3)           GET FIRST CHAR\n         S     R2,=F'193'         SUBTRACT OFF VALUE OF 'A'\n         SLL   R2,2               TIMES 4\n         L     @KTE,KYWDINDX(R2)  GET ADDRESS OF FIRST ENTRY WITH\n*                                 SAME FIRST LETTER\n         LR    LENGTH,@CH\n         S     LENGTH,WAKYSTRT    LENGTH OF KEYWORD\n         BCT   LENGTH,KEYLOOP     LESS ONE FOR EXECUTE\n         B     FAILKEY\nKEYLOOP  DS    0H\n         CLC   KYWDSTRG(1),0(R3)  CHECK FIRST CHAR\n         BNE   FAILKEY            NO LONGER IN CORRECT PART OF TABLE\n         EX    LENGTH,KEYCLC      COMPARE KEYWORD TO ENTRY\n         BE    KEYPOOL\n         IC    R2,KYWDLEN         GET LENGTH OF ENTRY\n         LA    @KTE,KYWDSTRG(R2)  GET NEXT ENTRY\n         B     KEYLOOP\nKEYCLC   CLC   KYWDSTRG,0(R3)\nKEYPOOL  DS    0H\n         IC    R2,KYWDMIN         GET MIMINUM UNAMBIGOUS LENGTH\n         LA    LENGTH,1(LENGTH)   LENGTH :=+ 1\n         CR    LENGTH,R2          CHECK LENGTH\n         BL    FAILKEY            KEY WORD TOO SHORT\n         MVC   S99TUKEY,KYWDKEY\n         LA    R4,S99TULNG        ADDRESS OF LENGTH FIELD\n         ST    R4,WALASTTU        SAVE IT\n         CLI   CH,C'='            DID THE USER SUPPLY A PARM\n         BNE   SPECPARM           IF NOT, THEN PARM IS IN TABLE\nVALUNEXT DS    0H\n         LA    @CH,1(@CH)         POINT PAST '='\n         ST    @CH,WAVALAD\nVALULOOP DS    0H\n         CLI   CH,C' '            BLANK?\n         BE    VALUPOOL           YES, END OF VALUE\n         CLI   CH,C','            COMMA?\n         BE    VALUPOOL           YES, END OF VALUE\n         CLI   CH,C';'            SEMI?\n         BE    VALUPOOL           YES, END OF VALUE\n         LA    @CH,1(@CH)         GET NEXT VALUE\n         B     VALULOOP\nVALUPOOL DS    0H\n         LR    LENGTH,@CH\n         S     LENGTH,WAVALAD     LENGTH OF VALUE\n         L     R4,WALASTTU\n         STH   LENGTH,0(R4)       SAVE LENGTH\n         BCTR  LENGTH,0\n         BM    TEXTNUM            DONT MOVE VALUE IF NULL\n         L     R3,WAVALAD         GET START OF VALUE\n         CLI   KYWDSUBT,KYWDSUBF  IS THERE A SUBTABLE?\n         BNL   SUBTLKUP           YES\n         CLI   KYWDPMLN,KYNOPARM  IS THERE A LENGTH SUPPLIED?\n         BNE   CONVALUE\n         L     R4,WALASTTU\n         LA    R4,2(R4)           POINT TO PARAMETER FIELD\n         EX    LENGTH,VALUEMVC\n         B     TEXTNUM\nVALUEMVC MVC   R0(0,R4),0(R3)\nSUBTLKUP DS    0H\n@SUBT    EQU   4\n*\n**   R3 POINTS TO VALUE\n**   R2 # OF ENTRIES IN SUBTABLE\n**   R15 USED FOR IC,STC\n*\n         XR    R15,R15\n         XR    R2,R2\n         IC    R2,KYWDSUBT        GET SUBTABLE INDEX POINTER\n         N     R2,=F'15'          GET RID OF FLAG BITS\n         SLL   R2,2               TIMES 4\n         L     @SUBT,VALUINDX(R2) ADDR OF SUBTABLE\n         USING VALUTABL,@SUBT     ADDRESSIBILITY FOR SUBTABLE ENTRIES\n         IC    R2,VALUINDX(2)     # ENTRIES IN SUBTABLE\n         CLC   KYWDSTRG(5),=C'RECFM' SPECIAL CASE FOR RECFM\n         BE    SPECCASE\n         CLC   KYWDSTRG(5),=C'OPTCD' AND FOR OPTION CODE\n         BE    SPECCASE\nSUBTLOOP DS    0H\n         EX    LENGTH,SUBTCLC     COMPARE ENTRIES\n         BE    SUBTPOOL           ENTRY FOUND\n         IC    R15,VALULEN        GET LENGTH OF THIS ENTRY\n         LA    @SUBT,VALUSTRG(R15) GET NEXT ENTRY\n         BCT   R2,SUBTLOOP        REPEAT IF NOT AT END OF TABLE\n         B     FAILVALU\nSUBTPOOL DS    0H\n         LA    LENGTH,1(LENGTH)   LENGTH +:= 1\n         CR    LENGTH,R15         CORRECT VALUE LENGTH\n         BNE   FAILVALU\n         IC    R2,KYWDPMLN        GET PARM LENGTH\n         STC   R2,S99TULNG+1      SAVE IT IN TEXT UNIT\n         IC    R2,CONVMASK(R2)    GET STCM MASK\n         ICM   R3,3,VALUPARM      GET VALUE\n         EX    R2,CONVSTCM        STCM R3,CONVMASK(R2),S99TUPAR\n         B     TEXTNUM\nSUBTCLC  CLC   VALUSTRG,0(R3)\n*\n**   THIS CODE HANDLES THE SPECIAL CASE FOR KEYWORDS THAT CAN HAVE\n**   MORE THAN ONE VALUE SPECIFIED. EG 'RECFM=FBA'.\n**   THE INDIVIDUAL VALUES ARE OR'ED TOGETHER\n*\nSPECCASE DS    0H\n         LR    R0,@SUBT           SAVE ADDR OF START OF SUBTABLE\n         LR    R15,R2             SAVE # SUBTABLE ENTRIES\n         L     @CH,WAVALAD        POINT TO FIRST VALUE\n         LA    LENGTH,1(LENGTH)   CORRECT LENGTH\nSPECLOOP DS    0H\n         CLC   CH,VALUSTRG        COMPARE CHAR WITH VALUE STRING\n         BE    SPECPOOL           FOUND\n         LA    @SUBT,VALUSTRG+1   NEXT ENTRY\n         BCT   R2,SPECLOOP        REPEAT WITH NEW ENTRY\n         B     FAILVALU           NO MORE ENTRIES LEFT\nSPECPOOL DS    0H\n         OC    S99TUPAR(1),VALUPARM+1\n         LA    @CH,CH+1           NEXT CHAR IN USER SUPPLIED VALUE\n         LR    @SUBT,R0           RESTORE SUBTABLE ADDR\n         LR    R2,R15             RESTORE SUBTABLE ENTRY COUNT\n         BCT   LENGTH,SPECLOOP\n         MVC   S99TULNG+1(1),KYWDPMLN MOVE IN LENGTH\n         B     TEXTNUM            FINISHED\n*\n**   SUPPLY THE PARAMETER VALUE FOR THE TEXT UNIT FROM THE KEYWRD TABLE\n*\nSPECPARM DS    0H\n         CLI   KYWDPARM,KYNOPARM  IS THERE A SPECIAL PARM?\n         BE    TEXTFINI\n         MVC   S99TULNG+1(1),KYWDPMLN MOVE IN LENGTH\n         MVC   S99TUPAR(1),KYWDPARM MOVE IN SPECIAL PARM\n         B     TEXTNUM\n*\n**   THE USER SUPPLIED VALUE IS TO BE CONVERTED TO BINARY AND RIGHT\n**   JUSTIFIED IN A FIELD WHOSE LENGTH IS SUPPLIED IN THE KEYWORD TABLE\n*\nCONVALUE DS    0H\n         LA    R2,WADWORD-1+L'WADWORD POINT 1 BYTE BEFOR END OF WADWORD\n         SR    R2,LENGTH          POINT TO CORRECT ADDR FOR MVC\n         XC    WADWORD,WADWORD\n         EX    LENGTH,CONVMVC     MOVE VALUE\n         PACK  WADWORD,WADWORD    CONVERT TO PACKED DECIMAL\n         CVB   R3,WADWORD         CONVERT TO BINARY\n         MVC   S99TULNG+1(1),KYWDPMLN MOVE IN KYWDPARM\n         XR    R2,R2\n         IC    R2,S99TULNG+1      GET SPECIAL PARM\n         IC    R2,CONVMASK(R2)    SET BYTE 2 FOR STCM INST\n         EX    R2,CONVSTCM        STCM R3,MASK(2),S99TUPAR\n         B     TEXTNUM\nCONVMVC  MVC   0(0,R2),0(R3)\nCONVSTCM STCM  0,0,S99TUPAR\nCONVMASK DC    X'303133373F'\n*\n**   SET THE NUMBER FIELD IN THE TEXTUNIT\n*\nTEXTNUM  DS    0H\n         LH    R2,S99TUNUM        NUMBER OF KEYS IN THIS TEXT UNIT\n         LA    R2,1(R2)           + ONE\n         STH   R2,S99TUNUM        SAVE IT\n         CLI   CH,C','            IS THERE ANOTHER PARAMETER?\n         BNE   TEXTFINI           NO\n         L     R4,WALASTTU        ADDRESF OF LENGTH FIELD FOR LAST TU\n         AH    R4,0(R4)           ADD LENGTH OF PARAMETER\n         LA    R4,2(R4)           + 2 FOR LENGTH FIELD\n         ST    R4,WALASTTU        = ADDRESS OF NEXT LENGTH FIELD\n         B     VALUNEXT           PROCESS NEXT VALUE\n*\n**   COMLETE THE TEXT UNIT.\n**   CHECK FOR WAORK AREA OVERFLOW.\n**   ADD A NEW POINTER THE THE TEXTPOINTERS\n*\nTEXTFINI DS    0H\n         L     R2,WALASTTU        ADDRESS OF LENGTH FIELD\n         AH    R2,0(2)            + LENGTH OF PARM\n         LA    R2,2(2)            + TWO FOR LENGTH FIELD\n         S     @TP,=F'4'          POINT TO NEW TEXT POINTER\n         CR    R2,@TP             CHECK FOR OVERFLOW\n         BH    FAILOVFL           WORKAREA OVERFLOW\n         ST    @TU,S99TUPTR       SAVE ADDR OF TU\n         LR    @TU,R2             POINT TO NEW TEXT UNIT\n         B     STRINGLP\nSTRINGPL DS    0H                 END OF STRING LOOP\n         CLI   0(R1),X'80'        LAST PARM?\n         BE    PARMPOOL           YES\n         LA    R1,4(R1)           POINT TO NEXT PARM\n         B     PARMLOOP\nPARMPOOL DS    0H\n         EJECT\n         ST    @TP,S99TXTPP       SET TEXT POINTER FIELD IN RB\n         L     @TP,WABOTTOM       GET END OF WORKAREA\n         S     @TP,=F'4'          POINT TO LAST PARM\n         MVI   S99TUPTR,S99TUPLN  SET LAST TP FLAG\n         LA    R1,WAS99RB         GET ADDR OF REQUEST BLOCK\n         OI    0(R1),S99RBPND     TURN ON FIRST BIT OF S99RBP\nSVC99    DYNALLOC                 CALL DYNAMIC ALLOCATION RTN\n         LTR   R15,R15\n         BNE   DAIRFAIL\n         CLI   S99VERB,S99VRBIN   VERB = INFO?\n         BE    INFODECO           YES, DECODE IT\n         CLI   WAALLOCR,WATRUE    VERB = ALLOCR?\n         BE    INFODECO\n         B     RETURN\nDAIRFAIL DS    0H\n         L     @DF,WADFDSCT       ADDRESS OF DFDSECT\n         ST    @RB,DFS99RBP       ADDRESS OF SVC99 REQUEST BLOCK\n         ST    R15,WAS99RC        SVC 99 RETURN CODE\n         LA    R2,WAS99RC         GET ADDR OF IT\n         ST    R2,DFRCP\n         LA    R2,WADFID          ADDR OF DIFD\n         ST    R2,DFIDP\n         MVI   WADFID,DFWTP       SPECIFY WRITE TO PROGRAMMER\n         MVI   WADFID+1,DFSVC99   FROM SVC 99\n         LA    R2,WAZEROES\n         ST    R2,DFJEFF02        ADDR OF ADDR OF IKJEFF02 (NOT KNOWN)\n         LR    R1,@DF\n         LINK  EP=IKJEFF18        CALL DAIRFAIL\n         L     R15,WAS99RC        RESTORE RETURN CODE\n         B     RETURN\n         EJECT\n*\n**   INITIALIZATION CODE\n*\nINITCODE DS    0H\n         LR    R2,R1\n         GETMAIN R,LV=2048        GETMAIN AREA\n         L     R3,0(R2)           ADDRESS OF PARM ONE\n         ST    R1,0(R3)           SAVE ADDRESS\n         MVI   0(R3),X'0F'        INDICATE GETMAINED AREA\n         L     R3,0(R3)           POINT TO AREA\n         LA    R4,2048            LENGTH\n         ST    R4,0(R3)           SET LENGTH\n         XR    R15,R15            SET RC\n         XC    4(4,R3),4(R3)      ZERO WAS99RC\n         LM    R14,R12,12(R13)    RESTORE REGS\n         XR    R15,R15            SET RETURN CODE\n         XR    R0,R0\n         BR    R14                RETURN\nENDCODE  DS    0H\n         LR    R2,R1              SAVE REG 1\n         L     R3,0(R1)           ADDRESS OF PARM 1\n         L     R3,0(R3)           ADDRESS TO BE FREED\n         L     R4,0(R3)           LENGTH TO BE FREED\n         FREEMAIN R,A=(3),LV=(4)\n         LM    R14,R12,12(R13)    RESTORE REGS\n         XR    R15,R15            SET RETURN CODE\n         XR    R0,R0\n         BR    R14                RETURN\n         EJECT\n*\n**   DECODE INFO RETURNED BY SVC99\n*\nINFODECO DS    0H\n         L     R1,4(R13)\n         L     R1,24(R1)          RECOVER R1\n         L     R1,8(R1)           POINT TO THIRD PARM\n         L     @TU,S99TUPTR       POINT TO FIRST TEXT UNIT\n         CLI   WAALLOCR,WATRUE    VERB = ALLOCR?\n         BE    INFO1\n         LA    R0,DILEN1(@TU)     POINT TO END OF DICB\n         LA    R4,DICBS1          ADDRESS OF DICB MODEL\n         B     INFO2\nINFO1    DS    0H\n         LA    R0,DILEN2(@TU)     POINT TO END OF DICB\n         LA    R4,DICBS2          ADDRESS OF DICB MODEL\nINFO2    DS    0H\nINFOLOOP DS    0H\n         LH    R3,S99TULNG        GET LENGTH\n         BCTR  R3,0               LESS ONE FOR EXECUTE\n         LTR   R3,R3\n         BL    INFOLEN\n         EX    R3,INFOMVC\nINFOLEN  LH    R3,S99TULNG-S99TUNIT(,R4) GET MAX PARM LENGTH\n         AR    R1,R3              POINT TO NEXT INFO PARM\n         LA    @TU,S99TUPAR(R3)   NEXT TEXT UNIT\n         LA    R4,S99TUPAR-S99TUNIT(R3,4) NEXT TEXT UNIT IN MODEL\n         CR    @TU,R0             END OF INFO TU'S?\n         BNE   INFOLOOP\n         XR    R15,R15            SET RETURN CODE\n         B     RETURN\nINFOMVC  MVC   0(0,R1),S99TUPAR\n         SPACE 3\nFAILVERB DS    0H\n         LA    R15,16\n         B     RETURN\nFAILKEY  DS    0H\n         LA    R15,20\n         B     RETURN\nFAILVALU DS    0H\n         LA    R15,28\n         B     RETURN\nFAILOVFL DS    0H\n         LA    R15,24\n         B     RETURN\n         EJECT\nRETURN   DS    0H\n         ST    R15,WAS99RC        RETURN CODE\n         L     R13,4(R13)         RESTORE SAVEAREA ADDR\n         ST    R15,16(R13)        SET RETURN CODE\n         L     R1,24(R13)         RESTORE R1\n         L     R1,0(R1)           ADDR OF PARM 1\n         CLI   0(R1),X'0E'        IS AREA TO BE FREED?\n         BNE   RETURN01\n         LR    R2,R1              SAVE R1\n         L     R1,0(R1)           ADDR TO BE FREED\n         FREEMAIN R,LV=2048,A=(1)\n         LR    R1,R2              RESTORE R1\n         XC    0(4,R1),0(R1)      SET PARM 1 TO ZEROES\nRETURN01 DS    0H\n         LM    R14,R12,12(R13)    RESTORE REGS\n         LR    R0,R15\n         BR    R14                RETURN\n         EJECT\n         PRINT NOGEN\n         INDEX\nVERBTAB  DS    0H\n         VENT  ALLOC,S99VRBAL\n         VENT  ALLOCR,S99VRBAL\n         VENT  UNALLOC,S99VRBUN\n         VENT  CONCAT,S99VRBCC\n         VENT  UNCONCAT,S99VRBDC\n         VENT  REMOVE,S99VRBRI\n         VENT  DDALLOC,S99VRBDN\n         VENT  INFO,S99VRBIN\nVERBMARK DS    0X\nVERBTEND DC    A(VERBMARK)\n         SPACE 1\nKYWDTAB  DS    0H\n         BEGIN A\n         KENT  ABE,3,DALEROPT,20\n         KENT  ACC,3,DALEROPT,80\n         KENT  AL,2,DALLABEL,40\n         KENT  ALIGNMENT,3,DALFCBAV,08\n         KENT  ALX,3,DALSPFRM,02\n         KENT  AUL,3,DALLABEL,48\n         BEGIN B\n         KENT  BLKSIZE,3,DALBLKSZ,,2\n         KENT  BLOCK,3,DALBLKLN,,3\n         KENT  BLP,3,DALLABEL,10\n         KENT  BUFALN,4,DALBFALN,SUBTABLE\n         KENT  BUFIN,4,DALBUFIN,,2\n         KENT  BUFL,4,DALBUFL,,2\n         KENT  BUFMAX,4,DALBUFMX,,1\n         KENT  BUFNO,4,DALBUFNO,,1\n         KENT  BUFOFF,5,DALBUFOF,,1\n         KENT  BUFOUT,5,DALBUFOU,,1\n         KENT  BUFRQ,4,DALBUFRQ,,1\n         KENT  BUFSZ,4,DALBUFSZ,,2\n         KENT  BUFTEK,4,DALBFTEK,SUBTABLE\n         BEGIN C\n         KENT  CATLG,2,DALNDISP,02\n         KENT  CCATLG,2,DALCDISP,02\n         KENT  CDELETE,2,DALCDISP,04\n         KENT  CHARSET,2,DALUVRFY\n         KENT  CKEEP,2,DALCDISP,08\n         KENT  CLOSE,2,DALCLOSE\n         KENT  CODE,3,DALCODE,SUBTABLE\n         KENT  CONTIG,3,DALSPFRM,08\n         KENT  CONVERT,4,DALCNVRT\n         KENT  COPIES,3,DALCOPYS,,1\n         KENT  CUNCATLG,2,DALCDISP,01\n         KENT  CYL,2,DALCYL\n         BEGIN D\n         KENT  DCBDD,5,DALDCBDD\n         KENT  DCBDS,5,DALDCBDS\n         KENT  DDNAME,2,DALDDNAM\n         KENT  DELETE,2,DALNDISP,04\n         KENT  DIRECTORY,2,DALDIR,,3\n         KENT  DSNAME,3,DALDSNAM\n         KENT  DSORG,3,DALDSORG,SUBTABLE,2\n         KENT  DSSEQ,3,DALDSSEQ,,2\n         KENT  DUMMY,2,DALDUMMY\n         KENT  D1600,5,DALDEN,C3\n         KENT  D6250,5,DALDEN,D3\n         KENT  D800,4,DALDEN,83\n         BEGIN E\n         KENT  EXPIRY,1,DALEXPDT\n         BEGIN F\n         KENT  F,1,DALRECFM,80\n         KENT  FA,2,DALRECFM,84\n         KENT  FAS,3,DALRECFM,8C\n         KENT  FB,2,DALRECFM,C0\n         KENT  FBA,3,DALRECFM,C4\n         KENT  FBAS,4,DALRECFM,9C\n         KENT  FBM,3,DALRECFM,C2\n         KENT  FBMS,4,DALRECFM,8A\n         KENT  FBS,3,DALRECFM,98\n         KENT  FM,2,DALRECFM,82\n         KENT  FMS,3,DALRECFM,8A\n         KENT  FOLDMODE,3,DALUFOLD\n         KENT  FORMS,3,DALFCBIM\n         KENT  FS,2,DALRECFM,88\n         BEGIN G\n         BEGIN H\n         KENT  HOLD,1,DALSHOLD\n         BEGIN I\n         KENT  INPUT,1,DALINOUT,40\n         BEGIN J\n         BEGIN K\n         KENT  KEEP,3,DALNDISP,08\n         KENT  KEYLEN,3,DALKYLEN,,1\n         BEGIN L\n         KENT  LIMCT,2,DALLIMCT,,3\n         KENT  LRECL,2,DALLRECL,,2\n         KENT  LTM,2,DALLABEL,21\n         BEGIN M\n         KENT  MEMBER,2,DALMEMBR\n         KENT  MOD,3,DALSTATS,02\n         KENT  MODE,4,DALMODE,SUBTABLE\n         KENT  MSVGP,2,DALMSVGP\n         KENT  MXIG,2,DALSPFRM,04\n         BEGIN N\n         KENT  NCP,2,DALNCP,,1\n         KENT  NEW,3,DALSTATS,04\n         KENT  NEWCLASS,4,DUNOVCLS\n         KENT  NEWHOLD,4,DUNOVSHQ\n         KENT  NEWNOHOLD,4,DUNOVSNH\n         KENT  NEWREMOTE,4,DUNOVSUS\n         KENT  NL,2,DALLABEL,01\n         KENT  NSL,3,DALLABEL,04\n         BEGIN O\n         KENT  OLD,3,DALSTATS,01\n         KENT  OPTCD,2,DALOPTCD,SUBTABLE\n         KENT  OUTLIM,4,DALOUTLM,,3\n         KENT  OUTPUT,3,DALINOUT,80\n         BEGIN P\n         KENT  PARALLEL,3,DALPARAL\n         KENT  PASSREAD,5,DALPASPR,10\n         KENT  PASSWORD,6,DALPASSW\n         KENT  PASSWRITE,6,DALPASPR,30\n         KENT  PERMANENT,2,DALPERMA\n         KENT  PERMCONCAT,5,DCCPERMC\n         KENT  PRIMARY,4,DALPRIME,,3\n         KENT  PRIVATE,4,DALPRIVT\n         KENT  PRTSP,3,DALPRTSP,SUBTABLE\n         BEGIN Q\n         KENT  QNAME,1,DALQNAME\n         BEGIN R\n         KENT  RECFM,3,DALRECFM,SUBTABLE\n         KENT  RELNO,3,DINRELNO,,2\n         KENT  REMOTE,3,DALSUSER\n         KENT  REMOVE,5,DUNREMOV\n         KENT  RETENTION,3,DALRETPD,,2\n         KENT  RLSE,2,DALRLSE\n         KENT  ROUND,2,DALROUND\n         BEGIN S\n         KENT  SECONDARY,3,DALSECND,,3\n         KENT  SHR,2,DALSTATS,08\n         KENT  SKP,2,DALEROPT,40\n         KENT  SL,2,DALLABEL,02\n         KENT  SUL,3,DALLABEL,08\n         KENT  SYSOFORM,5,DALSFMNO\n         KENT  SYSOPROG,5,DALSPGNM\n         KENT  SYSOUT,5,DALSYSOU\n         BEGIN T\n         KENT  TERMFILE,2,DALTERM\n         KENT  TRK,3,DALTRK\n         KENT  TRTCH,3,DALTRTCH,SUBTABLE\n         BEGIN U\n         KENT  U,1,DALRECFM,C0\n         KENT  UCS,2,DALUCS\n         KENT  UNALLOC,3,DUNUNALC\n         KENT  UNCATLG,3,DALNDISP,01\n         KENT  UNICOUNT,4,DALUNCNT,,1\n         KENT  UNIT,4,DALUNIT\n         BEGIN V\n         KENT  V,1,DALRECFM,40\n         KENT  VA,2,DALRECFM,44\n         KENT  VAS,3,DALRECFM,4C\n         KENT  VB,2,DALRECFM,50\n         KENT  VBA,3,DALRECFM,64\n         KENT  VBAS,4,DALRECFM,5C\n         KENT  VBM,3,DALRECFM,62\n         KENT  VBMS,4,DALRECFM,5A\n         KENT  VBS,3,DALRECFM,58\n         KENT  VERIFY,2,DALFCBAV,04\n         KENT  VM,2,DALRECFM,42\n         KENT  VMS,3,DALRECFM,4A\n         KENT  VOLUME,3,DALVLSER\n         KENT  VOLCOUNT,4,DALVLCNT,,1\n         KENT  VOLREF,4,DALVLRDS\n         KENT  VOLSEQ,4,DALVLSEQ,,2\n         KENT  VS,2,DALRECFM,48\n         BEGIN W\n         BEGIN X\n         BEGIN Y\n         BEGIN Z\nKYWDMARK DS    0X\nKYWDTEND DC    A(KYWDMARK)\n         BEGINSUB BFALN           OFFSET 00\n         SENT  F,01\n         SENT  D,02\n         BEGINSUB BFTEK           OFFSET 04\n         SENT  D,08\n         SENT  E,10\n         SENT  R,20\n         SENT  S,40\n         SENT  A,60\n         BEGINSUB CODE\n         SENT  T,02\n         SENT  A,04\n         SENT  C,08\n         SENT  B,10\n         SENT  F,20\n         SENT  I,40\n         SENT  N,80\n         BEGINSUB DSORG\n         SENT  TQ,0020\n         SENT  TX,0040\n         SENT  GS,0080\n         SENT  PO,0200\n         SENT  MQ,0400\n         SENT  CQ,0800\n         SENT  CX,1000\n         SENT  DA,2000\n         SENT  PS,4000\n         SENT  POU,0300\n         SENT  DAU,2100\n         SENT  PSU,4100\n         SENT  TCAM,0004\n         SENT  VSAM,0008\n         BEGINSUB MODE\n         SENT  E,40\n         SENT  C,80\n         SENT  ER,50\n         SENT  EO,60\n         SENT  CR,90\n         SENT  CO,A0\n         BEGINSUB OPTCD           OFFSET 04\n         SENT  R,01\n         SENT  T,02\n         SENT  Z,04\n         SENT  A,08\n         SENT  Q,08\n         SENT  F,10\n         SENT  H,10\n         SENT  O,10\n         SENT  C,20\n         SENT  E,20\n         SENT  B,40\n         SENT  U,40\n         SENT  W,80\n         BEGINSUB PRTSP\n         SENT  0,01\n         SENT  1,09\n         SENT  2,11\n         SENT  3,19\n         BEGINSUB RECFM\n         SENT  M,02\n         SENT  R,02\n         SENT  A,04\n         SENT  G,04\n         SENT  S,08\n         SENT  B,10\n         SENT  D,20\n         SENT  T,20\n         SENT  V,40\n         SENT  F,80\n         SENT  U,C0\n         BEGINSUB TRTCH\n         SENT  C,13\n         SENT  E,23\n         SENT  T,3B\n         SENT  ET,2B\n         ENDSUB\nVALUINDX SUBINDEX\nDICBS1   DICBTAB1\nDICBS2   DICBTAB2\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EXPAND": {"ttr": 12810, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00\\x98\\x00\\x98\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 152, "newlines": 152, "modlines": 0, "user": "ARCHIVR"}, "text": "EXPD     TITLE 'HUFFMAN TREE EXPANSION ROUTINE'\n*---------------------------------------------------------------------*\n*---     THIS SUBROUTINE IS THE COUNTERPART TO COMPACT AND WILL    ---*\n*---     RE-EXPAND COMPACTED DATA INTO ITS ORIGINAL FORM.          ---*\n*---                                                               ---*\n*---     ARGUMENTS:                                                ---*\n*---         A(OUTPUT STRING)                                      ---*\n*---         F(OUTPUT STRING LENGTH)                               ---*\n*---         A(INPUT AREA)                                         ---*\n*---                                                               ---*\n*---     RETURNS:                                                  ---*\n*---         1. EXPANDED STRING IN THE OUTPUT AREA                 ---*\n*---                                                               ---*\n*---     NOTES: THE SAVE AREA CONVENTIONS ARE DESIGNED TO WORK     ---*\n*---     WITH THE ARCHIVER PROGRAM'S 'STACKED' SAVE AREAS. IF      ---*\n*---     ADAPTED TO OTHER USES, THE LINKAGE CONVENTIONS WILL       ---*\n*---     REQUIRE MODIFICATION.                                     ---*\n*---------------------------------------------------------------------*\nEXPAND   CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n         USING EXPAND,R15\n         #STAMP\n         STM   R14,R12,12(R13)     SAVE ENTRY REGISTERS\n         LA    R14,72(,R13)        POINT TO NEXT SAVE AREA\n         ST    R14,8(,R13)         FORWARD CHAIN\n         ST    R13,4(,R14)         BACKWARD CHAIN\n         LR    R13,R14             POINT DOWN THE CHAIN\n         LR    R11,R15             COPY EPA VALUE\n         DROP  R15                 DROP OLD BASE\n         USING EXPAND,R11          AND DEFINE NEW BASE\n         LM    R2,R4,0(R1)         LOAD PARM POINTERS\n         L     R3,0(,R3)           LOAD ACTUAL OUTPUT LENGTH\n         LR    R1,R12              COPY MAIN WORK AREA ADDRESS\n         LA    R12,0(R2,R3)        POINT TO OUTPUT AREA END\n         BCTR  R12,R0              BACK UP ONE\n         LA    R5,0(,R2)           COPY OUTPUT AREA START\n         LA    R10,0(,R4)          AND INPUT AREA START\n         XC    8(2,R13),8(R13)     CLEAR THE FLAG WORD\n         LA    R14,0               INITIAL VALUES\n         LA    R6,0                INITIAL VALUES\n         LA    R7,0\n         LA    R2,0\n         LA    R0,0                BITS-LEFT COUNTER\n*        SELECT THE EXPANSION TABLE.  THIS IS TRICKY BECAUSE I\n*        NEED TO ACCOUNT FOR A TABLE-SELECTOR IN @BYTEC\n*        IF IT'S REALLY THERE.\n         CLI   @BYTEC-MAINWK(R1),X'06' VERSION 6 OF ARCHIVER ??\n         BNE   SELO                NOPE ---\n         L     R1,=V(EXP60)        YES; POINT TO EXPANSION TABLE\n         B     L1                  AND GO ---\nSELO     DS    0H\n         L     R1,=V(EXPOLD)       LOAD POINTER TO OLD TABLE\nL1       DS    0H\n         USING EXPNDS,R1\n         LA    R4,SHIFTS           POINT TO INITIAL SHIFT VALUES\n         LA    R3,EXPTAB           POINT TO START OF BIT TABLE\nL2       DS    0H\n         BAL   R9,SHIFTER          GO SHIFT SOME BITS (?)\n         AR    R3,R8               POINT INTO THE BIT TABLE\n         ICM   R15,3,0(R3)\n         TM    0(R3),X'40'         REPEATED CHARACTER ??\n         BNO   NOREPEAT            YES ---\n         OI    8(R13),X'40'        SET 'REPEATER' FLAG\n         B     NOINCR              DISCARD THIS CHARACTER\nNOREPEAT DS    0H\n         TM    0(R3),X'80'         ANOTHER LEVEL ??\n         BO    GOTIT               NOPE ---\n         AH    R3,0(,R3)           POINT TO NEXT TABLE LEVEL\n         LA    R4,8(,R4)           LOCATE SECOND SHIFT AMOUNT\n         B     L2                  GO SHIFT SOME MORE\nGOTIT    DS    0H\n         TM    8(R13),X'40'        IS THIS A COUNT CHARACTER ??\n         BO    SETCNT              YES ---\n         MVC   0(1,R5),1(R3)       COPY RESULT CHARACTER\n         TM    8(R13),X'80'        ARE WE REPEATING ??\n         BNO   INCR                NOPE ---\n         LR    R8,R5               COPY OUTPUT ADDRESS\n         LA    R9,0                CLEAR COUNT REGISTER\n         IC    R9,9(,R13)          INSERT BYTES-TO-COPY\n         LA    R15,0               CLEAR INPUT COUNTER\n         ICM   R15,8,1(R3)         INSERT CHARACTER TO INSERT\n         MVCL  R8,R14              PROPOGATE THE CHARACTER\n         LR    R5,R8               REPLACE OUTPUT POINTER\n         XC    8(2,R13),8(R13)     CLEAR THE FLAG WORD\n         B     NOINCR              AND SCOOT ---\nSETCNT   DS    0H\n         MVC   9(1,R13),1(R3)      COPY THE COUNT BYTE\n         XI    8(R13),X'C0'        SET SOME MORE 8(R13)\n         B     NOINCR              AND SKIP SOME MORE\nINCR     DS    0H\n         LA    R5,1(,R5)           BUMP OUTPUT CURSOR\nNOINCR   DS    0H\n         MVC   11(1,R13),0(R3)     COPY BIT COUNT\n         NC    10(2,R13),=H'15'    TRIM TO BARE BIT COUNT\n         SH    R2,10(,R13)         BITS TO RETURN\n         AR    R0,R2               RETURN TO BIT COUNT\n         SRDL  R6,0(R2)            SHIFT BACK OVER\n         LA    R2,0                RE-CLEAR\n         CH    R0,=H'32'           BIGGER THAT IT SHOULD BE ??\n         BNH   NOBACK\n         SH    R0,=H'32'           YES, BACK IT UP\n         SH    R10,=H'4'           BACK UP INPUT POINTER\nNOBACK   DS    0H\n         CR    R5,R12              FAR ENOUGH YET ??\n         BNH   L1                  NOPE; KEEP GOING\nRETURN   DS    0H\n         L     R13,4(,R13)\n         LM    R14,R12,12(R13)     RELOAD REGISTERS\n         LA    R15,0               RETURN CODE IS ZERO\n         BR    R14                 AND RETURN TO CALLER\nSHIFTER  DS    0H\n         STM   R14,R15,12(R13)\n         L     R15,0(,R4)\n         AR    R2,R15              BACKSHIFT ACCUMULATOR\n         LR    R14,R0              COPY BITS-LEFT VALUE\n         SR    R14,R15             ANY LEFT AFTER SHIFT ??\n         BNM   NOLOAD              YES ---\n         LR    R14,R0              COPY BITS-LEFT VALUE\n         SLDL  R6,0(R14)           SHIFT THAT FAR\n         SR    R15,R14             DECREMENT REQUEST SIZE\n         L     R7,0(,R10)          LOAD ANOTHER WORD OF INPUT\n         LA    R10,4(,R10)         POINT TO NEXT WORD\n         LA    R0,32               GOT ANOTHER 32 BITS\nNOLOAD   DS    0H\n         SLDL  R6,0(R15)           SHIFT OVER\n         LR    R8,R6               COPY SHIFTED BITS\n         N     R8,4(,R4)           GET JUST WHAT WE WANT\n         SLL   R8,1                TIMES TWO\n         SR    R0,R15              ACCOUNT FOR IT\n         LM    R14,R15,12(R13)\n         BR    R9                  AND RETURN TO CALLER\n         LTORG\nEXPNDS   DSECT\nSHIFTS   DS    32F                 SHIFT VALUES\nEXPTAB   DS    F                   EXPANSION TABLE\n         COPY  ##ARCHWK\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EXPLODE": {"ttr": 13060, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00Q\\x00Q\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 81, "newlines": 81, "modlines": 0, "user": "ARCHIVR"}, "text": "EXPL     TITLE 'EXPLODE --- ARCHIVER FUNCTION SUPPORT SUBROUTINE'\n*---------------------------------------------------------------------*\n*---     THIS IS THE 'EXPLODE' ROUTINE, TO RE-EXPAND THE DATA      ---*\n*---     COMPRESSED BY THE COMPRESS ROUTINE IN VERSION 3 OF THE    ---*\n*---     ARCHIVER PROGRAM.  THE INPUT PARAMETER LIST IS THREE      ---*\n*---     WORDS, CONTAINING THE ADDRESS AND LENGTH OF THE INPUT     ---*\n*---     STRING AND THE ADDRESS OF THE OUTPUT STRING. THE FINAL    ---*\n*---     LENGTH OF THE OUTPUT STRING IS RETURNED IN REGISTER 0.    ---*\n*---------------------------------------------------------------------*\n         SPACE 3\nEXPLODE  CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n         STM   R14,R12,12(R13)     SAVE ENTRY REGISTERS\n         USING EXPLODE,R15         AND DEFINE THE BASE REGISTER\n         LM    R2,R4,0(R1)         LOAD PARAMETER POINTERS\n         LA    R5,0(R3,R2)         POINT JUST PAST INPUT STRING\n         LA    R7,0                CLEAR TWO\nEXP01    DS    0H\n         IC    R7,0(,R2)           INSERT FIRST COUNT/FLAG BYTE\n         TM    0(R2),X'80'         DUPLICATED STRING ??\n         BO    EXP03               NOPE ---\n         N     R7,=A(X'3F')        TRIM DOWN TO BARE COUNTER\n         TM    0(R2),X'40'         DUPLICATED BLANKS ??\n         BZ    EXP02               NOPE ---\n         LA    R9,0                CLEAR SOURCE COUNTER\n         ICM   R9,8,=C' '          INSERT A BLANK PAD\n         LA    R6,0(,R4)           POINT TO OUTPUT AREA\n         LA    R4,0(R7,R4)         INCREMENT THE OUTPUT CURSOR ADDRESS\n         LA    R8,0                CLEAR SOURCE ADDRESS\n         MVCL  R6,R8               INSERT THE BLANKS\n         LA    R2,1(,R2)           AND INPUT CURSOR\n         CR    R2,R5               FAR ENOUGH YET ??\n         BL    EXP01               NOPE --- CONTINUE\n         B     EXP04               YES; COMPUTE LENGTH AND RETURN\nEXP02    DS    0H\n         LA    R9,0                CLEAR SOURCE COUNTER\n         ICM   R9,8,1(R2)          INSERT THE DUPL'D CHAR\n         LA    R6,0(,R4)           POINT TO OUTPUT AREA\n         LA    R4,0(R7,R4)         INCREMENT THE OUTPUT CURSOR ADDRESS\n         LA    R8,0                CLEAR SOURCE ADDRESS\n         MVCL  R6,R8               INSERT THE BLANKS\n         LA    R2,2(,R2)           BUMP INPUT LENGTH\n         CR    R2,R5               FAR ENOUGH YET ??\n         BL    EXP01               NOPE ---\n         B     EXP04               YES; COMPUTE LENGTH AND RETURN\nEXP03    DS    0H\n         N     R7,=A(X'7F')        TRIM NON-REPEAT FLAG BIT OFF\n         LA    R6,0(,R4)           POINT TO OUTPUT AREA\n         LA    R8,1(,R2)           POINT TO INPUT AREA\n         LA    R2,1(R7,R2)         BUMP INPUT POINTER\n         LA    R4,0(R7,R4)         AND OUTPUT POINTER\n         LR    R9,R7               COPY FOR SOURCE LENGTH\n         MVCL  R6,R8               COPY DATA TO OUTPUT AREA\n         CR    R2,R5               FAR ENOUGH YET ??\n         BL    EXP01               NOPE; CONTINUE\nEXP04    DS    0H\n         L     R2,8(,R1)           LOAD OUTAREA POINTER\n         LA    R2,0(,R2)           CLEAR GARBAGE BITS\n         LA    R0,0(,R4)           COPY END POINTER\n         SR    R0,R2               COMPUTE ACTUAL STRING LENGTH\n         LA    R15,0               RETURN CODE ZERO\n         L     R14,12(,R13)        LOAD RETURN ADDRESS\n         LM    R1,R12,24(R13)      RESTORE REGISTERS\n         BR    R14                 AND RETURN TO CALLER\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FLO": {"ttr": 13063, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00\\xbc\\x00\\xbc\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 188, "newlines": 188, "modlines": 0, "user": "ARCHIVR"}, "text": "         MACRO\n&L       FLO   &AREAS=,&MSG=,&MF=\n.*\n.*       GENERAL STATEMENT LABEL TRACE MACRO\n.*\n.*       EXPANSION OF THIS MACRO IS GOVERNED BY THE ARITHMATIC GLOBAL\n.*       VARIABLE '&TRACE' AND/OR A '&SYSPARM' PARAMETER. '&TRACE'\n.*       VALUES OVERRIDE THE '&SYSPARM' PARAMETER IF BOTH ARE PRESENT\n.*       UNLESS THE '&TRACE' OR THE '&SYSPARM' LEVEL IS ZERO. IF THE\n.*       '&SYSPARM' TRACE LEVEL IS ZERO(OFF), IT UNCONDITIONALLY TURNS\n.*       OFF ALL TRACE CODE GENERATION. IF THE '&TRACE' LEVEL IS ZERO,\n.*       THE '&SYSPARM' LEVEL (IF SPECIFIED) IS USED AS THE DEFAULT\n.*       TRACE LEVEL.\n.*       THE TRACE LEVEL IS USER SELECTED AS FOLLOWS:\n.*\n.*       &TRACE=0  NO TRACE CODE PRODUCED.\n.*       &TRACE=1  STATEMENT LABEL TRACE.\n.*       &TRACE=2  STATEMENT LABEL TRACE AND GENL REGISTERS.\n.*       &TRACE=3  STATEMENT LABEL TRACE,GENL REGS, AND SNAP DUMP.\n.*       &TRACE=4  STATEMENT LABEL TRACE,GENL REGS, AND ABEND DUMP.\n.*\n.*       MAIN STORAGE AREAS MAY BE TRACED AS FOLLOWS:\n.*       AREAS=(A,B<,A,B>...)\n.*             WHERE-\n.*                 A = THE ADDRESS OF A MAIN STORAGE AREA TO BE TRACED.\n.*                     THE ADDRESS MAY BE SPECIFIED AS A RELOCATABLE\n.*                     SYMBOL OR AS A REGISTER (ENCLOSED BY PARENS)\n.*                     WHICH CONTAINS THE ADDRESS.\n.*                 B = THE LENGTH OF THE MAIN STORAGE AREA TO BE\n.*                     TRACED. THE LENGTH MAY BE SPECIFIED AS AN\n.*                     ABSOLUTE EXPRESSION OR AS A REGISTER (ENCLOSED\n.*                     BY PARENS) WHICH CONTAINS THE LENGTH.\n.*\n.*       TRACE MESSAGES MAY BE PRINTED AS FOLLOWS:\n.*       MSG='TEXT STRING'     OR...\n.*       MSG=A\n.*             WHERE-\n.*                 A = THE ADDRESS OF A HALFWORD LENGTH FOLLOWED BY A\n.*                     STRING. THE ADDRESS MAY BE SPECIFIED AS A\n.*                     RELOCATABLE SYMBOL OR AS A REGISTER (ENCLOSED BY\n.*                     PARENS) WHICH CONTAINS THE ADDRESS.\n.*\n         GBLA  &TRACE              IN-LINE CODE SPECIFIED TRACE LEVEL.\n         LCLA  &PARM               SYSPARM SPECIFIED TRACE LEVEL.\n         LCLA  &CTR,&CTR1          COUNTERS.\n         LCLC  &C                  SYSPARM SPECIFIED TRACE VALUE.\n         LCLC  &T                  TYPE OF AREAS LENGTH.\n&L       DS    0H\n.*\n.*       EXTRACT TRACE LEVEL FROM SYSPARM\n.*\n         AIF   (K'&SYSPARM LT 7).NOPARM BR IF NO SYSPARM TRACE.\n&CTR     SETA  K'&SYSPARM-6\n.LOOP    AIF   (&CTR EQ 0).NOPARM  BR IF NO SYSPARM TRACE.\n         AIF   ('&SYSPARM'(&CTR,6) EQ 'TRACE=').CHKPARM BR IF TRACE SPE\n&CTR     SETA  &CTR-1              SCAN AL OF SYSPARM CHARACTERS.\n         AGO   .LOOP\n.*\n.CHKPARM ANOP\n&C       SETC  '&SYSPARM'(&CTR+6,1) GET TRACE VALUE.\n         AIF   ('&C' EQ 'O').END   BR IF UNCONDITIONAL TRACE OFF.\n         AIF   ('&C' EQ '0').END\n&PARM    SETA  1\n         AIF   ('&C' EQ 'L').SETPARM TRACE LABELS.\n         AIF   ('&C' EQ '1').SETPARM\n&PARM    SETA  2\n         AIF   ('&C' EQ 'R').SETPARM TRACE REGISTERS.\n         AIF   ('&C' EQ '2').SETPARM\n&PARM    SETA  3\n         AIF   ('&C' EQ 'S').SETPARM SNAP DUMP.\n         AIF   ('&C' EQ '3').SETPARM\n&PARM    SETA  4\n         AIF   ('&C' EQ 'A').SETPARM ABEND DUMP.\n         AIF   ('&C' EQ '4').SETPARM\n         MNOTE 2,'*** ERROR ** INVALID SYSPARM TRACE VALUE'\n         MEXIT\n.*\n.SETPARM AIF   (&TRACE NE 0).NOPARM BR IF EXPLICIT TRACE SPECIFIED.\n&TRACE   SETA  &PARM               USE SYSPARM SPECIFIED TRACE LEVEL.\n.NOPARM  ANOP                      SYSPARM BYPASS.\n         AIF   (&TRACE EQ 0).END   BYPASS CODE GENERATION.\n.*\n.*       CONSTRUCT MESSAGE CALL TO TRACE MODULE\n.*\n         AIF   (K'&MSG EQ 0).NOMSG BYPASS MESSAGE CODE GENERATION.\n         AIF   ('&MSG'(1,1) EQ '''').MSGTEXT BR IF QUOTED TEXT.\n         CNOP  2,4                 .SET PARAMETER LIST ALIGNMENT.\n         AIF   (('&MSG'(1,1) EQ '(') AND ('&MSG'(K'&MSG,1) EQ ')')).REG\n         L     14,=V(TRACE5)       .SET TRACE MODULE ADDRESS.\n         BALR  14,14               .LINK TO TRACE MODULE.\n         DC    A(&MSG)             .MESSAGE ADDRESS.\n         AGO   .NOMSG\n.REG     ANOP\n&C       SETC  '&MSG'(2,K'&MSG-2)  EXTRACT REGISTER FROM PARENS.\n         ST    &C,*+10             .SET TRACE MESSAGE ADDRESS.\n         AGO   .MSGCOM\n.MSGTEXT ANOP\n&CTR     SETA  K'&MSG-2            SET MESSAGE TEXT LENGTH.\n&C       SETC  '&MSG'(2,&CTR)      EXTRACT MESSAGE FROM QUOTES.\n         BAL   14,AMA&SYSNDX.M     .OBTAIN MESSAGE ADDRESS.\n         DC    AL2(&CTR)           .MESSAGE LENGTH.\n         DC    C'&C'               .MESSAGE TEXT.\n         CNOP  2,4                 .SET PARAMETER LIST ALIGNMENT.\n&C       SETC  'AMA&SYSNDX.M'\n&C       ST    14,*+10             .SET MESSAGE ADDRESS.\n.MSGCOM  L     14,=V(TRACE5)       .SET TRACE MODULE ENTRY ADDRESS.\n         BALR  14,14               .LINK TO TRACE MODULE.\n         DC    A(*-*)              .MESSAGE ADDRESS.\n.*\n.*       SET TRACE PARAMETER LIST VALUES\n.*\n.NOMSG   ANOP                      MESSAGE CODE GENERATION BYPASS.\n         AIF   ('&MF' EQ 'O').END  BR IF MESSAGE ONLY FORM.\n         AIF   (K'&AREAS EQ 0).SETLINK BR IF NOT AREAS.\n&CTR     SETA  N'&AREAS            GET NUMBER OF AREAS TO BE TRACED.\n         AIF   (&CTR/2*2 NE &CTR).BADAREA\n.LOOP1   AIF   (&CTR EQ 0).SETALIN BR IF PARM SETUP COMPLETE.\n&C       SETC  '&AREAS(&CTR-1)'    GET ADDRESS STRING.\n         AIF   ('&C' EQ '').BADAREA\n&CTR1    SETA  10+16*(&CTR/2-1)    SET ADDRESS PARAMETER OFFSET.\n         AIF   (('&C'(1,1) EQ '(') AND ('&C'(K'&C,1) EQ ')')).REGAREA\n         LA    14,&C               .OBTAIN AREA ADDRESS.\n         ST    14,AMA&SYSNDX.A+&CTR1 .SET TRACE PARM ADDRESS.\n         AGO   .SETLEN\n.REGAREA ANOP\n&C       SETC  '&C'(2,K'&C-2)      EXTRACT REGISTER FROM PARENS.\n         ST    &C,AMA&SYSNDX.A+&CTR1 .SET TRACE PARM ADDRESS.\n.SETLEN  ANOP\n&C       SETC  '&AREAS(&CTR)'      GET LENGTH STRING.\n&T       SETC  T'&AREAS(&CTR)      GET TYPE OF LENGTH STRING.\n         AIF   ('&C' EQ '').NXTAREA\n         AIF   (('&C'(1,1) EQ '(') AND ('&C'(K'&C,1) EQ ')')).EXLEN\n         AIF   ('&T' EQ 'N').NXTAREA\n.EXLEN   ANOP\n&CTR1    SETA  &CTR1+4\n         AIF   (('&C'(1,1) EQ '(') AND ('&C'(K'&C,1) EQ ')')).REGLEN\n         LA    14,&C               OBTAIN AREA LENGTH.\n         STH   14,AMA&SYSNDX.A+&CTR1 .SET TRACE PARM LENGTH.\n         AGO   .NXTAREA\n.REGLEN  ANOP\n&C       SETC  '&C'(2,K'&C-2)      EXTRACT REGISTER FROM PARENS.\n         STH   &C,AMA&SYSNDX.A+&CTR1 .SET TRACE PARM LENGTH.\n.NXTAREA ANOP\n&CTR     SETA  &CTR-2              GET NEXT AREA.\n         AGO   .LOOP1\n.SETALIN CNOP  2,4                 .SET PARAMETER LIST ALIGNMENT.\n.*\n.*       ESTABLISH LINKAGE TO TRACE MODULE\n.*\n.SETLINK ANOP\n         L     14,=V(TRACE&TRACE)  .SET TRACE MODULE ENTRY ADDRESS.\n         BALR  14,14               .LINK TO TRACE MODULE.\n.*\n.*       CONSTRUCT TRACE PARAMETER LIST\n.*\n         AIF   (K'&AREAS EQ 0).NOAREAS BR IF NO AREAS TRACE.\n&CTR     SETA  N'&AREAS            GET NUMBER OF AREAS TO BE TRACED.\n         SPACE 1\n         DC    AL1(0)              .INDICATE AREAS TRACE.\n&CTR1    SETA  &CTR/2\n         DC    AL1(&CTR1)          .NUMBER OF AREAS TO TRACE.\n         SPACE 1\n&C       SETC  'AMA&SYSNDX.A'\n&C       DS    0H\n&CTR1    SETA  1\n.LOOP2   AIF   (&CTR LT &CTR1).NOAREAS\n         DC    CL10'&AREAS(&CTR1)' .AREA NAME.\n         DC    AL4(*-*)            .AREA ADDRESS.\n&C       SETC  '&AREAS(&CTR1+1)'   EXTRACT LENGTH STRING.\n&T       SETC  T'&AREAS(&CTR1+1)   EXTRACT TYPE OF LENGTH STRING.\n         AIF   ('&T' EQ 'N').SELFDEF\n         AIF   ('&AREAS(&CTR1+1)' NE '').NOLEN\n&C       SETC  'L'.''''.'&AREAS(&CTR1)'\n.SELFDEF ANOP\n         DC    AL2(&C)             .AREA LENGTH.\n         AGO   .NEXT\n.NOLEN   DC    AL2(*-*)            .AREA LENGTH.\n.NEXT    ANOP\n         SPACE 1\n&CTR1    SETA  &CTR1+2             GET NEXT AREA.\n         AGO   .LOOP2\n.NOAREAS ANOP                      MAIN STORAGE TRACE BYPASS.\n         DC    CL8'&L'             .TRACE IDENTIFIER.\n         AGO   .END\n.*\n.BADAREA MNOTE 2,'*** ERROR ** INVALID AREAS= SPECIFICATION'\n.END     ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IECSDSL1": {"ttr": 13067, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x01\\x8d\\x01\\x8d\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 397, "newlines": 397, "modlines": 0, "user": "ARCHIVR"}, "text": "         MACRO\n         IECSDSL1 &PARA\n.**********************************************************************\n.*\n.*MODULE-TYPE = MACRO\n.*\n.*PROCESSOR = ASSEMBLER OR PLS\n.*\n.*CHANGE ACTIVITY =\n.*$L1=IXVTOC,JDM1134,T790227,STLBS: INDEXED VTOC SUPPORT           @L1A\n.*$L2=ICFCAT,JDM1113,T790225,STLMD: ICF CATALOG SUPPORT            @L2A\n.*$01=OZ52996,JDM1113,81110,STLRRB: DATE LAST REFERENCED           @01A\n.*$L3=MVS/XA,JDP1111,,STLBS:        BIT DESCRIPTIONS               @L3A\n.*$P1=KKC0088,HDP2210,,STLAM:       REMOVE SEMICOLON FROM ASM REM  @P1A\n.*$02=OZ97209,HDP2210,T86113,STLAM: ADD FROMAT 4 INDEX DISABLE BIT @02A\n.*\n.**** END OF SPECIFICATIONS *******************************************\n         LCLA  &CTR\n&CTR     SETA  1\n.LOOP    AIF   (&CTR GT N'&PARA).ENDOFIT\n         AIF   ('&PARA(&CTR)' EQ '1').FIRSTON\n         AIF   ('&PARA(&CTR)' EQ '2').SECNDON\n         AIF   ('&PARA(&CTR)' EQ '3').THIRDON\n         AIF   ('&PARA(&CTR)' EQ '4').FORTHON\n         AIF   ('&PARA(&CTR)' EQ '5').FIFTHON\n         AIF   ('&PARA(&CTR)' EQ '6').SIXTHON\n         AGO   .ERROR\n.FIRSTON ANOP\nIECSDSL1 EQU   *                   FORMAT 1 DSCB\nIECSDSF1 EQU   IECSDSL1            SAME AS IECSDSL1                @P1C\nDS1DSNAM DS    CL44                DATA SET NAME\nDS1FMTID DS    CL1                 FORMAT IDENTIFIER (X'F1')       @L3C\nDS1DSSN  DS    CL6                 DATA SET SERIAL NUMBER\n*                                     (IDENTIFIES THE FIRST OR     @P1A\n*                                      ONLY VOLUME CONTAINING THE  @P1A\n*                                      DATA SET/SPACE)             @P1A\nDS1VOLSQ DS    XL2                 VOLUME SEQUENCE NUMBER (1-9999) @P1C\nDS1CREDT DS    XL3                 CREATION DATE\n*                                    (DISCONTINUOUS BIN, X'YYDDDD')@P1A\nDS1EXPDT DS    XL3                 EXPIRATION DATE\n*                                    (DISCONTINUOUS BIN, X'YYDDDD')@P1A\nDS1NOEPV DS    XL1                 NUMBER OF DATA EXTENTS ON VOLUME@P1C\nDS1NOBDB DS    XL1                 NUMBER OF BYTES USED IN LAST\n*                                     DIRECTORY BLOCK\n         DS    XL1                 RESERVED\nDS1SYSCD DS    CL13                SYSTEM CODE\nDS1REFD  DS    XL3                 DATE LAST REFERENCED            @01C\n*                                    (DISCONTINUOUS BIN, X'YYDDDD')@P1A\n*                                    OR ZERO IF NOT MAINTAINED     @P1A\n         DS    XL4                 RESERVED                    @G60ASBJ\nDS1DSORG DS    XL2                 DATA SET ORGANIZATION\n*\n*                    FIRST BYTE OF DS1DSORG\nDS1DSGIS EQU   X'80'  1... ....    IS - INDEXED SEQUENTIAL         @L1A\n*                                  ORGANIZATION\nDS1DSGPS EQU   X'40'  .1.. ....    PS - PHYSICAL SEQUENTIAL        @L1A\n*                                  ORGANIZATION\nDS1DSGDA EQU   X'20'  ..1. ....    DA - DIRECT ORGANIZATION        @L1A\nDS1DSGCX EQU   X'10'  ...1 ....    CX - BTAM OR QTAM LINE GROUP    @L1A\n*        EQU   X'08'  .... 1...    CQ - QTAM DIRECT ACCESS MSG QUE @P1C\n*        EQU   X'04'  .... .1..    MQ - QTAM PROBLEM PROG MSG QUEUE@P1C\nDS1DSGPO EQU   X'02'  .... ..1.    PO - PARTITIONED ORGANIZATION   @L1A\nDS1DSGU  EQU   X'01'  .... ...1    U - UNMOVABLE, THE DATA SET     @P1C\n*                                      CONTAINS LOCATION DEPENDENT\n*                                      INFORMATION\n*\n*                     SECOND BYTE OF DS1DSORG\nDS1DSGGS EQU   X'80'  1... ....    GS - GRAPHICS ORGANIZATION      @L1A\nDS1DSGTX EQU   X'40'  .1.. ....    TX - TCAM LINE GROUP            @L1A\nDS1DSGTQ EQU   X'20'  ..1. ....    TQ - TCAM MESSAGE QUEUE         @L1A\n*        EQU   X'10'  ...X ....    RESERVED                        @P1C\nDS1ACBM  EQU   X'08'  .... 1...    AM - ACCESS METHOD CONTROL BLOCK@P1C\nDS1ORGAM EQU   X'08'  .... 1...    AM - VSAM DATA SET/SPACE        @P1M\nDS1DSGTR EQU   X'04'  .... .1..    TR - TCAM 3705                  @L1A\n*        EQU   X'02'  .... ..X.    RESERVED                        @P1C\n*        EQU   X'01'  .... ...X    RESERVED                        @P1C\n*                                                                  @P1C\nDS1RECFM DS    XL1                 RECORD FORMAT\nDS1RECFF EQU   X'80'  10.. ....    F - FIXED LENGTH                @L3A\nDS1RECFV EQU   X'40'  01.. ....    V - VARIABLE LENGTH             @L3A\nDS1RECFU EQU   X'C0'  11.. ....    U - UNDEFINED LENGTH            @L3A\nDS1RECFT EQU   X'20'  ..1. ....    T - TRACK OVERFLOW              @L3A\nDS1RECFB EQU   X'10'  ...1 ....    B - BLOCKED: MAY NOT OCCUR WITH @L3A\n*                                      UNDEFINED (U).              @L3A\nDS1RECFS EQU   X'08'  .... 1...    FIXED LENGTH: (X'88')           @L3A\n*                                     STANDARD BLOCKS, NO TRUNCATED@L3A\n*                                     BLOCKS OR UNFILLED TRACKS.   @L3A\n*                                  VARIABLE LENGTH: (X'48')        @L3A\n*                                     SPANNED RECORDS.             @L3A\nDS1RECFA EQU   X'04'  .... .10.    ANSI CONTROL CHARACTER          @L3A\nDS1RECMC EQU   X'02'  .... .01.    MACHINE CONTROL CHARACTER       @L3A\n*                     .... .00.    NO CONTROL CHARACTER            @L3A\n*                     .... ...0    ALWAYS ZERO                     @L3A\nDS1OPTCD DS    XL1                 OPTION CODES -- INDICATES THE   @P1C\n*                                  VARIOUS OPTIONS USED IN         @P1C\n*                                  BUILDING THE DATA SET           @P1C\n*                                                                  @P1A\n* BDAM DS1OPTCD FIELD ASSIGNMENTS (APPLY ONLY WHEN DS1DSGDA IS ON) @P1A\n*              X'80'  1... ....    W - WRITE VALIDITY CHECK        @P1A\n*              X'40'  .1.. ....      - TRACK OVERFLOW              @P1A\n*              X'20'  ..1. ....    E - EXTENDED SEARCH             @P1A\n*              X'10'  ...1 ....    F - FEEDBACK                    @P1A\n*              X'08'  .... 1...    A - ACTUAL ADDRESSING           @P1A\n*              X'04'  .... .1..      - DYNAMIC BUFFERING           @P1A\n*              X'02'  .... ..1.      - READ EXCLUSIVE              @P1A\n*              X'01'  .... ...1    R - RELATIVE BLOCK ADDRESSING   @P1A\n*                                                                  @P1A\n* ISAM DS1OPTCD FIELD ASSIGNMENTS (APPLY ONLY WHEN DS1DSGIS IS ON) @P1A\n*              X'80'  1... ....    W - WRITE VALIDITY CHECK        @P1A\n*              X'40'  .1.. ....    U - ACCUMULATE TRACK INDEX ENT  @P1A\n*              X'20'  ..1. ....    M - MASTER INDECIES             @P1A\n*              X'10'  ...1 ....    I - INDEPENDENT OVERFLOW AREA   @P1A\n*              X'08'  .... 1...    Y - CYLINDER OVERFLOW AREA      @P1A\n*              X'04'  .... .X..    RESERVED                        @P1A\n*              X'02'  .... ..1.    L - DELETE OPTION               @P1A\n*              X'01'  .... ...1    R - REORGANIZATION CRITERIA     @P1A\n*                                                                  @P1A\n* BPAM/BSAM/QSAM DS1OPTCD FIELD ASSIGNMENTS                        @P1A\n*                   (APPLY ONLY WHEN DS1DSGPO OR DS1DSGPS IS ON)   @P1A\n*              X'80'  1... ....    W - WRITE VALIDITY CHECK        @P1A\n*              X'40'  .1.. ....    U - ALLOW DATA CHECK (1403 PRTR)@P1A\n*              X'20'  ..1. ....    C - CHAINED SCHEDULING USING PCI@P1A\n*              X'10'  ...1 ....    H - DOS/OS INTERCHANGE FEATURE  @P1A\n*              X'08'  .... 1...    B - TREAT EOF AS EOV (TAPE)     @P1A\n*              X'04'  .... .1..    Z - SEARCH DIRECT               @P1A\n*              X'02'  .... ..1.    T - USER LABEL TOTALING         @P1A\n*              X'01'  .... ...1    J - FOR 3800 PRINTING SUBSYSTEM @P1A\n*                                                                  @P1A\n* VSAM DS1OPTCD FIELD ASSIGNMENTS (APPLY ONLY WHEN DS1DSGAM IS ON) @P1C\nDS1OPTIC EQU   X'80'  1... ....    DATA SET CATALOGED IN ICF CTLG  @P1C\nDS1OPTBC EQU   X'40'  .1.. ....    DATA SET IS ICF CATALOG         @P1C\n*                     ..XX XXXX    RESERVED                        @P1C\n*\nDS1BLKL  DS    XL2                 BLOCK LENGTH (TYPE F RECORDS),  @L3C\n*                                  OR MAX BLKSIZE (U OR V RECORDS) @L3A\nDS1LRECL DS    XL2                 LOGICAL RECORD LENGTH\n*                                  FIXED LENGTH: RECORD LENGTH     @L3A\n*                                  UNDEFINED LENGTH: ZERO          @L3A\n*                                  VARIABLE UNSPANNED: MAX REC LEN @L3A\n*                                  VARIABLE SPANNED:               @L3A\n*                                   < 32756 BYTES- MAX REC LEN     @L3A\n*                                   > 32756 BYTES- X'8000'         @L3A\nDS1KEYL  DS    XL1                 KEY LENGTH (0 - 255)\nDS1RKP   DS    XL2                 RELATIVE KEY POSITION\nDS1DSIND DS    XL1                 DATA SET INDICATORS\nDS1IND80 EQU   X'80'  1... ....    LAST VOLUME ON WHICH THE DATA   @P1C\n*                                     SET RESIDES              @G60ASBJ\nDS1IND40 EQU   X'40'  .1.. ....    DATA SET IS RACF DEFINED    @G60ASBJ\nDS1IND20 EQU   X'20'  ..1. ....    BLOCK LENGTH IS A MULTIPLE  @G60ASBJ\n*                                     OF 8 BYTES               @G60ASBJ\nDS1IND10 EQU   X'10'  ...1 ....    PASSWORD IS REQUIRED TO     @G60ASBJ\n*                                  READ OR WRITE OR BOTH-SEE   @G60ASBJ\n*                                     DS1IND04                 @G60ASBJ\nDS1IND08 EQU   X'08'  .... X...    RESERVED                        @P1C\nDS1IND04 EQU   X'04'  .... .1..    IF DS1IND10 IS 1 THEN           @P1C\n*                                     IF DS1IND04 IS . . .         @P1C\n*                                        1-PASSWORD REQUIRED TO    @P1C\n*                                          WRITE BUT NOT TO READ   @P1C\n*                                        0-PASSWORD REQUIRED TO    @P1C\n*                                          WRITE AND TO READ       @P1C\nDS1IND02 EQU   X'02'  .... ..1.    DATASET OPENED FOR OTHER    @G60ASBJ\n*                                     THAN INPUT SINCE LAST    @G60ASBJ\n*                                     BACKUP COPY MADE.        @G60ASBJ\nDS1DSCHA EQU   DS1IND02            SAME USE AS BIT DS1IND02    @G60ASBJ\nDS1IND01 EQU   X'01'  .... ...1    SECURE CHECKPOINT DATA SET      @01C\nDS1CHKPT EQU   DS1IND01            SAME AS DS1IND01                @L3C\nDS1SCALO DS    0XL4                SECONDARY ALLOCATION            @L3C\nDS1SCAL1 DS    XL1                 SPACE PARAMETERS                @P1C\nDS1DSPAC EQU   X'C0'  XX.. ....    BIT PATTERN FOR SPACE REQUEST   @L3A\nDS1CYL   EQU   X'C0'  11.. ....    CYLINDER REQUEST                @L3A\nDS1TRK   EQU   X'80'  10.. ....    TRACK REQUEST                   @L3A\nDS1AVR   EQU   X'40'  01.. ....    AVERAGE BLOCK LENGTH REQUEST    @L3A\nDS1AVRND EQU   X'41'  01.. ...1    AVERAGE BLOCK AND ROUND REQUEST @P1C\nDS1MSGP  EQU   X'20'  ..1. ....    MASS STORAGE VOL GROUP (MSVGP)  @L3A\n*                     ...X ....    RESERVED                        @L3A\nDS1CONTG EQU   X'08'  .... 1...    CONTIGUOUS REQUEST              @L3A\nDS1MXIG  EQU   X'04'  .... .1..    MXIG REQUEST                    @L3A\nDS1ALX   EQU   X'02'  .... ..1.    ALX REQUEST                     @L3A\n*              X'01'  .... ...1    ROUND REQUEST                   @P1A\nDS1DSABS EQU   X'00'  0000 0000    ABSOLUTE TRACK REQUEST          @L3A\nDS1SCAL3 DS    XL3                 SECONDARY ALLOCATION QUANTITY   @P1C\nDS1LSTAR DS    XL3                 LAST USED TRACK                 @P1C\n*                                     AND BLOCK ON TRACK (TTR)     @P1A\nDS1TRBAL DS    XL2                 BYTES REMAINING ON LAST TRACK USED\n         DS    XL2                 RESERVED\nDS1EXT1  DS    XL10                FIRST EXTENT DESCRIPTION\n*        FIRST BYTE                EXTENT TYPE INDICATOR\n*              X'81'  1... ...1    EXTENT ON CYLINDER BOUNDARIES   @L3A\n*              X'80'  1... ....    EXTENT DESCRIBED IS SHARING CYL.@L3A\n*              X'40'  01.. ....    FIRST EXTENT DESCRIBES THE      @L3A\n*                                     USER LABEL (AND IS NOT       @P1C\n*                                     COUNTED IN DS1NOEPV)         @P1A\n*              X'04'  .... .1..    INDEX AREA EXTENT (ISAM)        @L3A\n*              X'02'  .... ..1.    OVERFLOW AREA EXTENT (ISAM)     @L3A\n*              X'01'  .... ...1    USER'S DATA BLOCK EXTENT OR     @L3A\n*                                     IS A PRIME AREA EXTENT (ISAM)@P1C\n*              X'00'  0000 0000    FOLLOWING 9 BYTES DO NOT        @L3A\n*                                     INDICATE ANY EXTENT          @P1C\n*        SECOND BYTE               EXTENT SEQUENCE NUMBER\n*        THIRD - SIXTH BYTES       LOWER LIMIT (CCHH)\n*        SEVENTH - TENTH BYTES     UPPER LIMIT (CCHH)\nDS1EXT2  DS    XL10                SECOND EXTENT DESCRIPTION\nDS1EXT3  DS    XL10                THIRD EXTENT DESCRIPTION\nDS1PTRDS DS    XL5                 POINTER (CCHHR) TO A FORMAT 2   @P1C\n*                                     OR 3 DSCB, OR ZERO           @P1A\nDS1END   EQU   *                   EQUATE AT END OF DSCB1 MAP      @P1C\n&CTR     SETA  &CTR+1\n         AGO   .LOOP\n.SECNDON ANOP\nIECSDSL2 EQU   *                   FORMAT 2 DSCB\nIECSDSF2 EQU   IECSDSL2            SAME AS IECSDSL2                @P1C\n         DS    XL1                 KEY IDENTIFIER  (X'02')\nDS22MIND DS    XL7                 ADDRESS OF 2ND LEVEL MASTER INDEX\nDS2L2MEN DS    XL5                 LAST 2ND LEVEL MASTER INDEX ENTRY\nDS23MIND DS    XL7                 ADDRESS OF 3RD LEVEL MASTER INDEX\nDS2L3MIN DS    XL5                 LAST 3RD LEVEL MASTER INDEX ENTRY\n         DS    XL11                RESERVED\nDS2LPDT  DS    XL8                 LAST PRIME TRACK ON LAST PRIME CYL\nDS2FMTID DS    CL1                 FORMAT IDENTIFIER (X'F2')\nDS2NOLEV DS    XL1                 NUMBER OF INDEX LEVELS\nDS2DVIND DS    XL1                 HIGH LEVEL INDEX DEVELOPMENT\n*                                     INDICATOR\nDS21RCYL DS    XL3                 FIRST DATA RECORD IN CYLINDER\nDS2LTCYL DS    XL2                 LAST DATA TRACK IN CYLINDER\nDS2CYLOV DS    XL1                 NUMBER OF TRACKS FOR CYLINDER\n*                                     OVERFLOW\nDS2HIRIN DS    XL1                 HIGHEST 'R' ON HIGH-LEVEL INDEX TRK\nDS2HIRPR DS    XL1                 HIGHEST 'R' ON PRIME DATA TRACK\nDS2HIROV DS    XL1                 HIGHEST 'R' ON OVERFLOW DATA TRACK\nDS2RSHTR DS    XL1                 'R' OF LAST DATA RECORD ON SHARED\n*                                     TRACK\nDS2HIRTI DS    XL1                 HIGHEST 'R' ON UNSHARED TRACK OF\n*                                     TRACK INDEX\nDS2HIIOV DS    XL1                 HIGHEST 'R' FOR INDEPENDENT OVERFLOW\n*                                     DATA TRACKS\nDS2TAGDT DS    XL2                 TAG DELETION COUNT\nDS2RORG3 DS    XL3                 NON-FIRST OVERFLOW REFERENCE COUNT\nDS2NOBYT DS    XL2                 NUMBER OF BYTES FOR HIGHEST-LEVEL\n*                                     INDEX\nDS2NOTRK DS    XL1                 NUMBER OF TRACKS FOR HIGHEST-LEVEL\n*                                     INDEX\nDS2PRCTR DS    XL4                 PRIME RECORD COUNT\nDS2STIND DS    XL1                 STATUS INDICATORS\n*                     .1.. ....    PREFORM KEY SEQUENCE CHECKING   @L3A\n*                     ..1. ....    INITIAL LOAD HAS BEEN COMPLETED @L3A\n*                     .... ..1.    LAST BLOCK FULL                 @L3A\n*                     .... ...1    LAST TRACK FULL                 @L3A\n*                     X..X XX..    RESERVED BITS                   @L3A\nDS2CYLAD DS    XL7                 ADDRESS OF CYLINDER INDEX\nDS2ADLIN DS    XL7                 ADDRESS OF LOWEST LEVEL MASTER INDEX\nDS2ADHIN DS    XL7                 ADDRESS OF HIGHEST LEVEL MASTER\n*                                     INDEX\nDS2LPRAD DS    XL8                 LAST PRIME DATA RECORD ADDRESS\nDS2LTRAD DS    XL5                 LAST TRACK INDEX ENTRY ADDRESS\nDS2LCYAD DS    XL5                 LAST CYLINDER INDEX ENTRY ADDRESS\nDS2LMSAD DS    XL5                 LAST MASTER INDEX ENTRY ADDRESS\nDS2LOVAD DS    XL8                 LAST INDEPENDENT OVERFLOW RECORD\n*                                     ADDRESS\nDS2BYOVL DS    XL2                 BYTES REMAINING ON OVERFLOW TRACK\nDS2RORG2 DS    XL2                 TRACKS REMAINING IN INDEPENDENT\n*                                     OVERFLOW AREA\nDS2OVRCT DS    XL2                 OVERFLOW RECORD COUNT\nDS2RORG1 DS    XL2                 CYLINDER OVERFLOW AREA COUNT\nDS2NIRT  DS    XL3                 DUMMY TRACK INDEX ENTRY ADDRESS\nDS2PTRDS DS    XL5                 POINTER (CCHHR) TO FORMAT 3 DSCB@P1C\n*                                     OR ZERO                      @P1A\nDS2END   EQU   *                   EQUATE AT END OF DSCB2 MAP      @P1C\n&CTR     SETA  &CTR+1\n         AGO   .LOOP\n.THIRDON ANOP\nIECSDSL3 EQU   *                   FORMAT 3 DSCB\nIECSDSF3 EQU   IECSDSL3            SAME AS IECSDSL3                @P1C\n         DS    XL4                 KEY IDENTIFIER (X'03030303')\nDS3EXTNT DS    XL40                FOUR EXTENT DESCRIPTIONS\n*        FIRST BYTE                EXTENT TYPE INDICATOR\n*        SECOND BYTE               EXTENT SEQUENCE NUMBER\n*        THIRD - SIXTH BYTES       LOWER LIMIT (CCHH)              @P1C\n*        SEVENTH - TENTH BYTES     UPPER LIMIT (CCHH)              @P1C\nDS3FMTID DS    CL1                 FORMAT IDENTIFIER (X'F3')\nDS3ADEXT DS    XL90                NINE ADDITIONAL EXTENT DESCRIPTIONS\nDS3PTRDS DS    XL5                 FORWARD CHAIN POINTER (CCHHR)   @P1C\n*                                     TO FORMAT 3 DSCB OR ZERO     @P1A\nDS3END   EQU   *                   EQUATE AT END OF DSCB3 MAP      @P1C\n&CTR     SETA  &CTR+1\n         AGO   .LOOP\n.FORTHON ANOP\nIECSDSL4 EQU   *                   FORMAT 4 DSCB\nIECSDSF4 EQU   IECSDSL4            SAME AS IECSDSL4                @P1C\nDS4IDFMT DS    CL1                 FORMAT IDENTIFIER (X'F4')\nDS4HPCHR DS    XL5                 HIGHEST ADDRESS (CCHHR) OF A    @P1C\n*                                     FORMAT 1 DSCB (SET TO END OF @P1A\n*                                     VTOC IF INDEXED VTOC)        @P1A\nDS4DSREC DS    XL2                 NUMBER OF AVAILABLE DSCB'S (NOT @P1C\n*                                     MAINTAINED IF INDEXED VTOC)  @P1A\nDS4HCCHH DS    XL4                 CCHH OF NEXT AVAILABLE ALTERNATE TRK\nDS4NOATK DS    XL2                 NUMBER OF REMAINING ALTERNATE TRACKS\nDS4VTOCI DS    XL1                 VTOC INDICATORS\nDS4DOSBT EQU   X'80'  1... ....    DOS BIT (IF ON, EITHER NO FORMAT@P1C\n*                                     5 DSCBS OR INDEXED VTOC -    @P1A\n*                                     SEE DS4IVTOC)                @P1A\nDS4DVTOC EQU   X'40'  .1.. ....    IF ON, THE INDEX WAS DISABLED   @02A\nDS4DSTKP EQU   X'10'  ...1 ....    DOS STACKED PACK                @P1C\nDS4DOCVT EQU   X'08'  .... 1...    DOS CONVERTED VTOC              @P1C\nDS4DIRF  EQU   X'04'  .... .1..    DIRF BIT                        @P1C\nDS4DICVT EQU   X'02'  .... ..1.    DIRF RECLAIMED                  @P1C\nDS4IVTOC EQU   X'01'  .... ...1    IF ON, AN INDEX HAS BEEN CREATED@P1C\n*                                     FOR THE VTOC.                @P1A\n*                                  IF DS4DOSBT IS ON, THE INDEX IS @P1A\n*                                     VALID.                       @P1A\n*                                  IF EITHER OF THESE BITS IS OFF, @P1A\n*                                    THE INDEX HAS BEEN INVALIDATED@P1A\n*                     ..X. ....    RESERVED BIT                    @02C\nDS4NOEXT DS    XL1                 NUMBER OF EXTENTS IN THE VTOC\n         DS    XL2                 RESERVED\nDS4DEVCT DS    0XL14               DEVICE CONSTANTS\nDS4DEVSZ DS    XL4                 DEVICE SIZE                     @P1C\n*                     XL2          NUMBER OF LOGICAL CYLINDERS     @P1A\n*                     XL2          NUMBER OF TRACKS IN A           @P1A\n*                                     LOGICAL CYLINDER             @P1A\nDS4DEVTK DS    XL2                 DEVICE TRACK LENGTH\nDS4DEVOV DS    0XL2                KEYED RECORD OVERHEAD\nDS4DEVI  DS    XL1                    NON-LAST KEYED RECORD OVERHEAD\nDS4DEVL  DS    XL1                    LAST KEYED RECORD OVERHEAD\nDS4DEVK  DS    XL1                 NON-KEYED RECORD OVERHEAD\n*                                     DIFFERENTIAL\nDS4DEVFG DS    XL1                 FLAG BYTE\n*                     .... 1...    THE KEYED RECORD OVERHEAD FIELD @L3A\n*                                  (DS4DEVOV) IS USED AS A 2-BYTE  @L3A\n*                                  FIELD TO SPECIFY THE OVERHEAD   @L3A\n*                                  REQUIRED FOR A KEYED RECORD     @L3A\n*                     .... .1..    THE CCHH OF AN ABSOLUTE ADDRESS IS\n*                                  USED AS A CONTINUOUS BINARY VALUE\n*                     .... ..1.    THE CCHH OF AN ABSOLUTE ADDRESS IS\n*                                  USED AS 4 SEPARATE BINARY VALUES\n*                     .... ...1    A TOLERANCE FACTOR MUST BE APPLIED\n*                                  TO ALL BUT THE LAST BLOCK OF THE\n*                                  TRACK.                          @L3A\n*                     XXXX ....    RESERVED BITS                   @L3A\nDS4DEVTL DS    XL2                 DEVICE TOLERANCE\nDS4DEVDT DS    XL1                 NUMBER OF DSCB'S PER TRACK\nDS4DEVDB DS    XL1                 NUMBER OF DIRECTORY BLOCKS PER TRACK\nDS4AMTIM DS    XL8                 VSAM TIME STAMP\nDS4AMCAT DS    0XL3                VSAM CATALOG INDICATOR\nDS4VSIND DS    XL1                 VSAM INDICATORS\n*                     1... ....    A VSAM CATALOG REFERENCES THIS  @L3A\n*                                  VOLUME.                         @L3A\n*                     .1.. ....    THE VSAM DATA SETS ON THIS VOLUME\n*                                  ARE UNUSUABLE BECAUSE AN MSS\n*                                  CONVERTV COMMAND HAS NOT COMPLETED\n*                                  SUCCESSFULLY FOR THIS VOLUME.   @L3A\n*                     ..XX XXXX    RESERVED BITS                   @L3A\nDS4VSCRA DS    XL2                 RELATIVE TRACK LOCATION OF THE CRA\nDS4R2TIM DS    XL8                 VSAM VOLUME/CATALOG MATCH\n*                                  TIME STAMP\n         DS    XL5                 RESERVED\nDS4F6PTR DS    XL5                 POINTER (CCHHR) TO FIRST FORMAT @P1C\n*                                     6 DSCB OR ZERO               @P1A\nDS4VTOCE DS    XL10                VTOC EXTENT DESCRIPTION\n         DS    XL25                RESERVED\nDS4END   EQU   *                   EQUATE AT END OF DSCB4          @P1C\n&CTR     SETA  &CTR+1\n         AGO   .LOOP\n.FIFTHON ANOP\nIECSDSL5 EQU   *                   FORMAT 5 DSCB\nIECSDSF5 EQU   IECSDSL5            SAME AS IECSDSL5                @P1C\nDS5KEYID DS    XL4                 KEY IDENTIFIER (X'05050505')\nDS5AVEXT DS    XL5                 AVAILABLE EXTENT\n*        BYTES 1 - 2     RELATIVE TRACK ADDRESS OF THE FIRST TRACK\n*                        IN THE EXTENT\n*        BYTES 3 - 4     NUMBER OF UNUSED CYLINDERS IN THE EXTENT\n*        BYTE  5         NUMBER OF ADDITIONAL UNUSED TRACKS\nDS5EXTAV DS    XL35                SEVEN AVAILABLE EXTENTS\nDS5FMTID DS    CL1                 FORMAT IDENTIFIER (X'F5')\nDS5MAVET DS    XL90                EIGHTEEN AVAILABLE EXTENTS\nDS5PTRDS DS    XL5                 FORWARD CHAIN POINTER (CCHHR)   @P1C\n*                                     TO FORMAT 5 DSCB OR ZERO     @P1A\nDS5END   EQU   *                   EQUATE AT END OF DSCB5          @P1C\n&CTR     SETA  &CTR+1\n         AGO   .LOOP\n.SIXTHON ANOP\nIECSDSL6 EQU   *                   FORMAT 6 DSCB\nIECSDSF6 EQU   IECSDSL6            SAME AS IECSDSL6                @P1C\nDS6KEYID DS    XL4                 KEY IDENTIFIER (X'06060606')\nDS6AVEXT DS    XL5                 SHARED EXTENT DESCRIPTION\n*        BYTES 1 - 2     RELATIVE TRACK ADDRESS OF THE FIRST CYLINDER\n*        BYTES 3 - 4     NUMBER OF FULL CYLINDERS BEING SHARED\n*        BYTE  5         NUMBER OF DATA SETS SHARING THE EXTENT\nDS6EXTAV DS    XL35                SEVEN SHARED EXTENTS\nDS6FMTID DS    CL1                 FORMAT IDENTIFIER (X'F6')\nDS6MAVET DS    XL90                EIGHTEEN SHARED EXTENTS\nDS6PTRDS DS    XL5                 FORWARD CHAIN POINTER (CCHHR)   @P1C\n*                                     TO FORMAT 6 DSCB OR ZERO     @P1A\nDS6END   EQU   *                   EQUATE AT END OF DSCB6          @P1C\n&CTR     SETA  &CTR+1\n         AGO   .LOOP\n.ERROR   MNOTE 7,'***INCORRECT FORMAT NUMBER'\n.ENDOFIT MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IHAPDS": {"ttr": 13317, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00\\xd0\\x00\\xd0\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 208, "newlines": 208, "modlines": 0, "user": "ARCHIVR"}, "text": "         MACRO\n         IHAPDS &PDSBLDL=NO,&DSECT=YES    */\n*\n*%PDSL1 : ;\n*/* **************************************************************** */\n*/*            PARTITIONED DATA SET (PDS) DIRECTORY ENTRY            */\n*/*                                                                  */\n*/*  MVS/XA DFP RELEASE 1                                            */\n*/*                                                                  */\n*/*      THE PDS DIRECTORY ENTRY MAY HAVE ANY OR ALL OF THE          */\n*/*      FOLLOWING FIVE SECTIONS IN THIS ORDER --                    */\n*/*      1.    BASIC (MAY OR MAY NOT CONTAIN 2 BLDL BYTES)           */\n*/*      2.    SCATTER LOAD   - OPTIONAL                             */\n*/*      3.    ALIAS          - OPTIONAL                             */\n*/*      4.    SSI            - OPTIONAL                             */\n*/*      5.    APF            - OPTIONAL                             */\n*/*                                                                  */\n*/*  METHOD OF ACCESS                                                */\n*/*      BAL  - DSECT IS PRODUCED UNLESS DSECT=NO IS SPECIFIED.      */\n*/*             USING ON PDS2 GIVES ADDRESSABILITY FOR ALL SYMBOLS.  */\n*/*             THE MACRO EXPANSION WILL INCLUDE THE TWO BYTES       */\n*/*             INSERTED BY BLDL UNLESS PDSBLDL=NO IS SPECIFIED.     */\n*/*      PL/S - DCL (PDS2PTR,PDSPTRV) PTR                            */\n*/*             THE MACRO EXPANSION WILL INCLUDE THE TWO BYTES       */\n*/*             INSERTED BY BLDL UNLESS %PDSBLDL='NO' IS SPECIFIED   */\n*/*             BEFORE INCLUDE FOR MACRO.                            */\n*/*                                                                  */\n*/*             THE FOLLOWING 4 PL/S STATEMENTS SHOW HOW THE         */\n*/*             STARTING ADDRESS OF ANY OF THE FOUR OPTIONAL         */\n*/*             SECTIONS OF USER DATA MAY BE OBTAINED.               */\n*/*                                                                  */\n*/*             (1) PDSPTRV=ADDR(PDSBCEND)                           */\n*/*             (2) IF PDS2SCTR='1'B THEN PDSPTRV=PDSPTRV +          */\n*/*                 LENGTH(PDSS01)                                   */\n*/*             (3) IF PDS2ALIS='1'B THEN PDSPTRV=PDSPTRV +          */\n*/*                 LENGTH(PDSS02)                                   */\n*/*             (4) IF PDS2SSI='1'B THEN PDSPTRV=PDSPTRV +           */\n*/*                 LENGTH(PDSS03)                                   */\n*/*                                                                  */\n*/*             STATEMENT (1) GETS THE ADDRESS FOR THE START OF THE  */\n*/*             OPTIONAL SECTIONS.  TO GET THE STARTING ADDRESS OF   */\n*/*             THE SCATTER LOAD SECTION, USE STATEMENT (1).  FOR    */\n*/*             THE ALIAS SECTION, USE STATEMENTS (1) AND (2).  FOR  */\n*/*             THE SSI SECTION, USE STATEMENTS (1), (2) AND (3)     */\n*/*             AND ADD ONE TO ADDRESS IN PDSPTRV IF ADDRESS IS NOT  */\n*/*             ON A HALF-WORD BOUNDARY.  FOR THE APF SECTION, USE   */\n*/*             ALL 4 STATEMENTS.                                    */\n*/* **************************************************************** */\n*%GOTO PDSL2;    /*\n         IEZBITS , -          SYMBOLIC BIT DEFINITIONS\n         SPACE 1\n         AIF   ('&DSECT' EQ 'NO').NODSCT2\nPDS2     DSECT ,              PDS2PTR\n         AGO   .CONT2\n.NODSCT2 ANOP\n         DS    0F -                                              YM2464\nPDS2     EQU   * -            PDS2PTR\n.CONT2   ANOP\nPDS2NAME DS    CL8 -          LOAD MODULE MEMBER NAME OR ALIAS\nPDS2TTRP DS    CL3 -          TTR OF FIRST BLOCK OF NAMED MEMBER\n         AIF   ('&PDSBLDL' EQ 'NO').PDSX2\nPDS2CNCT DS    FL1 -          CONCATENATION NUMBER OF THE DATA SET\nPDS2LIBF DS    C -            LIBRARY FLAG FIELD\nPDS2LNRM EQU   X'00' -        NORMAL CASE\nPDS2LLNK EQU   X'01' -        IF DCB OPERAND IN BLDL MACRO INTRUCTION\n*                             WAS SPECIFIED AS ZERO, NAME WAS FOUND IN\n*                             LINK LIBRARY\nPDS2LJOB EQU   X'02' -        IF DCB OPERAND IN BLDL MACRO INTRUCTION\n*                             WAS SPECIFIED AS ZERO, NAME WAS FOUND IN\n*                             JOB LIBRARY\n.PDSX2   ANOP\nPDS2INDC DS    B -            INDICATOR BYTE\nPDS2ALIS EQU   BIT0 -         NAME IN THE FIRST FIELD IS AN ALIAS\nPDS2NTTR EQU   BIT1+BIT2 -    NUMBER OF TTR'S IN THE USER DATA FIELD\nPDS2LUSR EQU   BIT3+BIT4+BIT5+BIT6+BIT7 - LENGTH OF USER DATA FIELD\n*                             IN HALF WORDS\nPDS2USRD DS    0C -           START OF VARIABLE LENGTH USER DATA FIELD\nPDS2TTRT DS    CL3 -          TTR OF FIRST BLOCK OF TEXT\nPDS2ZERO DS    C -            ZERO\nPDS2TTRN DS    CL3 -          TTR OF NOTE LIST OR SCATTER/TRANSLATION\n*                             TABLE.  USED FOR MODULES IN SCATTER LOAD\n*                             FORMAT OR OVERLAY STRUCTURE ONLY.\nPDS2NL   DS    FL1 -          NUMBER OF ENTRIES IN NOTE LIST FOR\n*                             MODULES IN OVERLAY STRUCTURE         @L6C\nPDS2ATR  DS    0BL2 -         TWO-BYTE MODULE ATTRIBUTE FIELD\nPDS2ATR1 DS    B -            FIRST BYTE OF MODULE ATTRIBUTE FIELD\nPDS2RENT EQU   BIT0 -         REENTERABLE\nPDS2REUS EQU   BIT1 -         REUSABLE\nPDS2OVLY EQU   BIT2 -         IN OVERLAY STRUCTURE\nPDS2TEST EQU   BIT3 -         MODULE TO BE TESTED - TESTRAN\nPDS2LOAD EQU   BIT4 -         ONLY LOADABLE\nPDS2SCTR EQU   BIT5 -         SCATTER FORMAT\nPDS2EXEC EQU   BIT6 -         EXECUTABLE\nPDS21BLK EQU   BIT7 -         IF ZERO, MODULE CONTAINS MULTIPLE RECORDS\n*                             WITH AT LEAST ONE BLOCK OF TEXT.  ---\n*                             IF ONE, MODULE CONTAINS NO RLD ITEMS AND\n*                             ONLY ONE BLOCK OF TEXT.\nPDS2ATR2 DS    B -            SECOND BYTE OF MODULE ATTRIBUTE FIELD\nPDS2FLVL EQU   BIT0 -         IF ZERO, MODULE CAN BE PROCESSED BY ALL\n*                             LEVELS OF LINKAGE EDITOR.  ---\n*                             IF ONE, MODULE CAN BE PROCESSED ONLY BY\n*                             F LEVEL OF LINKAGE EDITOR.\nPDS2ORG0 EQU   BIT1 -         LINKAGE EDITOR ASSIGNED ORIGIN OF FIRST\n*                             BLOCK OF TEXT IS ZERO.\nPDS2EP0  EQU   BIT2 -         ENTRY POINT ASSIGNED BY LINKAGE EDITOR\n*                             IS ZERO\nPDS2NRLD EQU   BIT3 -         MODULE CONTAINS NO RLD ITEMS\nPDS2NREP EQU   BIT4 -         MODULE CANNOT BE REPROCESSED BY LINKAGE\n*                             EDITOR\nPDS2TSTN EQU   BIT5 -         MODULE CONTAINS TESTRAN SYMBOL CARDS\nPDS2LEF  EQU   BIT6 -         MODULE CREATED BY LINKAGE EDITOR F\nPDS2REFR EQU   BIT7 -         REFRESHABLE MODULE\nPDS2STOR DS    FL3 -          TOTAL CONTIGUOUS MAIN STORAGE REQUIREMENT\n*                             OF MODULE\nPDS2FTBL DS    FL2 -          LENGTH OF FIRST BLOCK OF TEXT\nPDS2EPA  DS    AL3 -          ENTRY POINT ADDRESS ASSOCIATED WITH\n*                             MEMBER NAME OR WITH ALIAS NAME IF ALIAS\n*                             INDICATOR IS ONE\n         DS    0AL3 -         LINKAGE EDITOR ASSIGNED ORIGIN OF FIRST\n*                             BLOCK OF TEXT (OS USE OF FIELD)\nPDS2FTBO DS    0BL3 -         FLAG BYTES (AOS USE OF FIELD)      ICB269\nPDS2FTB1 DS    B -            BYTE 1 OF PDS2FTBO                 ICB269\nPDSAOSLE EQU   BIT0 -         MODULE HAS BEEN PROCESSED BY AOS LINKAGE\n*                             EDITOR                             ICB410\n*        BIT1 IS RESERVED TO INDICATE ANOTHER EXPANSION WHEN IT\n*        BECOMES NECESSARY                                       ICB410\nPDS2PAGA EQU   BIT2 -         PAGE ALIGNMENT REQUIRED FOR LOAD\n*                             MODULE                             ICB410\nPDS2SSI  EQU   BIT3 -         SSI INFORMATION PRESENT            ICB410\nPDSAPFLG EQU   BIT4 -         INFORMATION IN PDSAPF IS VALID     ICB360\nPDS2FTB2 DS    B -            BYTE 2 OF PDS2FTBO                 ICB269\nPDSLRMOD EQU   BIT3           LOAD MODULE RESIDENCE MODE           @L6A\nPDSAAMOD EQU   BIT4+BIT5      ALIAS ENTRY POINT ADDRESSING MODE    @L6A\nPDSMAMOD EQU   BIT6+BIT7      MAIN ENTRY POINT ADDRESSING MODE     @L6A\nPDS2RLDS DS    0XL1           NUMBER OF RLD/CONTROL RECORDS WHICH  &L6A\n*                             FOLLOW THE FIRST BLOCK OF TEXT       &L6A\nPDS2FTB3 DS    B -            NOW USED BY LINKAGE EDITOR           &L6C\nPDSBCEND EQU   * -            END OF BASIC SECTION\nPDSBCLN  EQU   PDSBCEND-PDS2 - LENGTH OF BASIC SECTION\n         SPACE 2\n*        THE FOLLOWING SECTION IS FOR LOAD MODULES WITH SCATTER LOAD\n         SPACE 1\nPDSS01   EQU   * -            START OF SCATTER LOAD SECTION\nPDS2SLSZ DS    FL2 -          NUMBER OF BYTES IN SCATTER LIST\nPDS2TTSZ DS    FL2 -          NUMBER OF BYTES IN TRANSLATION TABLE\nPDS2ESDT DS    CL2 -          IDENTIFICATION OF ESD ITEM (ESDID) OF\n*                             CONTROL SECTION TO WHICH FIRST BLOCK OF\n*                             TEXT BELONGS\nPDS2ESDC DS    CL2 -          IDENTIFICATION OF ESD ITEM (ESDID) OF\n*                             CONTROL SECTION CONTAINING ENTRY POINT\nPDSS01ND EQU   * -            END OF SCATTER LOAD SECTION\nPDSS01LN EQU   PDSS01ND-PDSS01 - LENGTH OF SCATTER LOAD SECTION\n         SPACE 2\n*        THE FOLLOWING SECTION IS FOR LOAD MODULES WITH ALIAS NAMES\n         SPACE 1\nPDSS02   EQU   * -            START OF ALIAS SECTION\nPDS2EPM  DS    AL3 -          ENTRY POINT FOR MEMBER NAME\nPDS2MNM  DS    CL8 -          MEMBER NAME OF LOAD MODULE.  WHEN THE\n*                             FIRST FIELD (PDS2NAME) IS AN ALIAS NAME,\n*                             THIS FIELD CONTAINS THE ORIGINAL NAME OF\n*                             THE MEMBER EVEN AFTER THE MEMBER HAS\n*                             BEEN RENAMED.  (MDC302)          @Z30AQ9A\nPDSS02ND EQU   * -            END OF ALIAS SECTION\nPDSS02LN EQU   PDSS02ND-PDSS02 - LENGTH OF ALIAS SECTION\n         SPACE 2\n*        THE FOLLOWING SECTION IS FOR SSI INFORMATION AND IS ON\n*        A HALF-WORD BOUNDARY\n         SPACE 1\nPDSS03   DS    0H -           FORCE HALF-WORD ALIGNMENT FOR SSI\n*                             SECTION\nPDSSSIWD DS    0CL4 -         SSI INFORMATION WORD\nPDSCHLVL DS    FL1 -          CHANGE LEVEL OF MEMBER\nPDSSSIFB DS    B -            SSI FLAG BYTE\nPDSFORCE EQU   BIT1 -         A FORCE CONTROL CARD WAS USED WHEN\n*                             EXECUTING THE IHGUAP PROGRAM\nPDSUSRCH EQU   BIT2 -         A CHANGE WAS MADE TO MEMBER BY THE\n*                             INSTALLATION, AS OPPOSED TO AN\n*                             IBM-DISTRIBUTED CHANGE\nPDSEMFIX EQU   BIT3 -         SET WHEN AN EMERGENCY IBM-AUTHORIZED\n*                             PROGRAM 'FIX' IS MADE, AS OPPOSED TO\n*                             CHANGES THAT ARE INCLUDED IN AN\n*                             IBM-DISTRIBUTED MAINTENANCE PACKAGE\nPDSDEPCH EQU   BIT4 -         A CHANGE MADE TO THE MEMBER IS DEPENDENT\n*                             UPON A CHANGE MADE TO SOME OTHER MEMBER\n*                             IN THE SYSTEM\nPDSSYSGN EQU   BIT5+BIT6 -    FLAGS THAT INDICATE WHETHER OR NOT A\n*                             CHANGE TO THE MEMBER WILL NECESSITATE A\n*                             PARTIAL OR COMPLETE REGENERATION OF THE\n*                             SYSTEM\nPDSNOSGN EQU   X'00' -        NOT CRITICAL FOR SYSTEM GENERATION\nPDSCMSGN EQU   BIT6 -         MAY REQUIRE COMPLETE REGENERATION\nPDSPTSGN EQU   BIT5 -         MAY REQUIRE PARTIAL REGENERATION\nPDSIBMMB EQU   BIT7 -         MEMBER IS SUPPLIED BY IBM\nPDSMBRSN DS    CL2 -          MEMBER SERIAL NUMBER\nPDSS03ND EQU   * -            END OF SSI SECTION\nPDSS03LN EQU   PDSS03ND-PDSS03 - LENGTH OF SSI SECTION\n         SPACE 2\n*        THE FOLLOWING SECTION IS FOR APF INFORMATION          ICB360 *\n         SPACE 1\nPDSS04   EQU   * -            START OF APF SECTION               ICB360\nPDSAPF   DS    0CL2 -         PROGRAM AUTHORIZATION FACILITY (APF)\n*                             FIELD                              ICB360\nPDSAPFCT DS    FL1 -          LENGTH OF PROGRAM AUTHORIZATION CODE\n*                             (PDSAPFAC) IN BYTES                ICB360\nPDSAPFAC DS    C -            PROGRAM AUTHORIZATION CODE         ICB360\nPDSS04ND EQU   * -            END OF APF SECTION                 ICB360\nPDSS04LN EQU   PDSS04ND-PDSS04 - LENGTH OF APF SECTION           ICB360\n         MEND  , */\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LOADXMI": {"ttr": 13321, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06\\r\\x00@\\x01 !_\\x01 !_\\x18\\x14\\x06S\\x06S\\x00\\x00\\xe9a\\xd6\\xe2@@@@@@'", "ispf": {"version": "06.13", "flags": 0, "createdate": "2020-08-02T00:00:00", "modifydate": "2020-08-02T18:14:40", "lines": 1619, "newlines": 1619, "modlines": 0, "user": "Z/OS"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "LOADXMIM": {"ttr": 14085, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06\\r\\x00@\\x01 !_\\x01 !_\\x18\\x01\\x06N\\x06N\\x00\\x00\\xd4\\xe5\\xe2@@@@@@@'", "ispf": {"version": "06.13", "flags": 0, "createdate": "2020-08-02T00:00:00", "modifydate": "2020-08-02T18:01:40", "lines": 1614, "newlines": 1614, "modlines": 0, "user": "MVS"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "LSRCH": {"ttr": 14849, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00f\\x00f\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 102, "newlines": 102, "modlines": 0, "user": "ARCHIVR"}, "text": "         MACRO\n&LABEL   LSRCH &LINK,                                                  X\n               &KEY,                                                   X\n               &ST=NORD,                                               X\n               &RAL=RAL,                                               X\n               &RAN=RAN,                                               X\n               &$LINK=0,                                               X\n               &$KEY=4,                                                X\n               &CIR=NO\n.*********************************************************************.\n.*                                                                   *.\n.*--> MACRO: LSRCH     LINKED LIST SEARCH MACRO...........           *.\n.*     SEARCHES A LINKED LIST FOR A NODE HAVING A GIVEN KEY,RETURNS  *.\n.*  ADDRESS OF IT IF PRESENT, OR ADDRESS OF LINK WHICH WOULD CHANGE  *.\n.*  IF NODE WERE INSERTED. SETS CONDITION CODE = 0 IF NODE EXISTS    *.\n.*                                                                   *.\n.*  &LINK     GIVES THE ADDRESS OF A LINK FIELD (OR LIST HEAD WHICH  *.\n.*     ADDRESSES THE LIST OR PART OF LIST TO BE SEARCHED). CAN BE AN *.\n.*     RX ADDRESS FOR THE LINK, A REGISTER NAME IN PARENS WHICH      *.\n.*     ALREADY CONTAINS THE ADDRESS OF THE LINK. IF OMITTED, IT      *.\n.*     ASSUMES THAT THE REGISTER SPECIFIED BY &RAN ALREADY HAS THE   *.\n.*     ADDRESS IN IT.                                                *.\n.*  &KEY     SPECIFIES THAT A NODE HAVING THE GIVEN KEY IS TO BE     *.\n.*     SEARCHED FOR IN THE LIST, STARTING AT THE NODE POINTED TO BY  *.\n.*     THE WORD AT LOCATION GIVEN BY ADDR IN &LINK. CAN BE SPECIFIED *.\n.*     BY ANY ARGUMENT LEGAL AS THE FIRST OPERAND OF A CLC           *.\n.*     INSTRUCTION SO CAN BE A LITERAL, A COMPLETE D(L,B) OPERAND    *.\n.*     OR A SYMBOLIC EXPRESSION (EITHER HAVING THE CORRECT LENGTH    *.\n.*     ATTRIBUTE FOR IMPLIED LENGTH, OR HAVING IT SPECIFIED)         *.\n.*  &ST=    GIVES THE TYPE OF SEARCH TO BE USED: MAY BE:             *.\n.*     =NORD    (NO ORDER)- THE LIST IS UNORDERED,AND IT SHOULD      *.\n.*     BE SEARCHED UNTIL THE GIVEN KEY IS FOUND.                     *.\n.*     =ASC    (ASCENDING ORDER)--THE LIST IF ORDERED BY LOGICAL     *.\n.*     ASCENDING ORDER BY KEY FIELD.  THE LIST SHOULD BE SEARCHED    *.\n.*     ONLY TO THE POSITION AT WHICH THE REQUIRED NODE SHOULD BE.    *.\n.*     =DES    (DESCENDING ORDER)- SAME AS ASC, EXCEPT THE NODES     *.\n.*     ARE IN DESCENDING ORDER BY KEY.                               *.\n.*  &RAL=    NAME OF A REGISTER WHICH WILL BE USED TO CONTAIN THE    *.\n.*     ADDRESS OF THE LINK FIELD WHICH POINTS TO THE CURRENT NODE. ON*.\n.*     THE COMPLETION OF THE MACRO CODE, WILL POINT TO THE LINK FIELD*.\n.*     WHICH POINTS TO THE REQUIRED NODE, OR TO THE LINK FIELD TO BE *.\n.*     CHANGED TO INSERT A NODE IN THE PROPER SEQUENCE.              *.\n.*  &RAN=    NAME OF A REGISTER WHICH WILL POINT TO THE NODE IF      *.\n.*     IT IS IN THE LIST. IF A NODE WITH REQUIRED KEY IS NOT IN THE  *.\n.*     LIST, IT IS SET TO THE VALUE OF THE LINK FIELD WHICH SHOULD   *.\n.*     BE CHANGED IF THE NEW NODE IS INSERTED (WILL =0 IF A NORD     *.\n.*     SEARCH IS DONE AND IT IS NOT PRESENT, OR IF THE NEW NODE      *.\n.*     WOULD BE ADDED TO THE END OF AN ASC OR DES TYPE LIST).        *.\n.*     ***NOTE*** REGISTERS &RAL AND &RAN ARE DEFINATELY CHANGED.    *.\n.*  &$KEY=     GIVES THE DISPLACEMENT OF THE KEY FROM THE            *.\n.*             BEGINING OF THE NODE.                                 *.\n.*  &$LINK=    GIVES THE DISPLACEMENT OF THE LINK FIELD FROM         *.\n.*             THE BEGINING OF THE NODE.                             *.\n.*  &CIR=      YES IF THE LIST IS CIRCULARLY LINKED,                 *.\n.*             NO IF IT IS NOT.                                      *.\n.*                                                                   *.\n.*  THE CONDITION CODE IS SET BY THIS MACRO AS FOLLOWS:              *.\n.*  CC=0    NODE EXISTS IN THE LIST WITH GIVEN &KEY. &RAN HAS        *.\n.*     ADDRESS OF THIS NODE, &RAL HAS ADDRESS OF THE LINK FIELD      *.\n.*     IN THE PRECEDING NODE (WHICH HAS VALUE IN &RAL).              *.\n.*  CC= ANYTHING ELSE.    THE NODE WITH GIVEN KEY WAS NOT FOUND.     *.\n.*     &RAL HAS ADDRESS OF NODE TO BE CHANGED FOR INSERTION.         *.\n.*     &RAN HAS VALUE OF LINK FIELD POINTED TO BY &RAL.              *.\n.*  MODIFIES ONLY REGISTERS &RAL AND &RAN.                           *.\n.*                                                                   *.\n.*********************************************************************.\n         AIF   ('&CIR' EQ 'NO').CONT\n         B     LL&SYSNDX.C+4       BRANCH AROUND FULLWORD\nLL&SYSNDX.C DS   F                 PLACE TO SAVE FIRST LINK FIELD\n.CONT    ANOP\n&LABEL   DS    0H\n         AIF   (K'&LINK EQ 0).SKIP\n         AIF   ('&LINK'(1,1) NE '(').BUMP\n         LR    &RAN,&LINK(1)\n         AGO   .SKIP\n.BUMP    LA    &RAN,&LINK\n.SKIP    ANOP\n         AIF   ('&CIR' EQ 'NO').CONTA\n         ST    &RAN,LL&SYSNDX.C    SAVE FIRST LINK FIELD\n.CONTA   ANOP\nLL&SYSNDX.A LR &RAL,&RAN           SAVE CURRENT LINK FIELD IN &RAL\n         L     &RAN,&$LINK.(,&RAN) LOAD CONTENTS OF LINK FIELD IN &RAN\n         AIF   ('&CIR' EQ 'NO').CONTB\n         C     &RAN,LL&SYSNDX.C    CHECK FOR CIR. LINKED LIST.\n         BNE   *+10\n         AGO  .CONTC\n.CONTB   LTR   &RAN,&RAN           CHECK IF NODES ARE DEPLETED.\n         BNZ   *+10                IF NOT BRANCH TO CLC.\n.CONTC   LTR   &RAL,&RAL           SETS CC NOT= 0.\n         B     LL&SYSNDX.B         BRANCH TO END OF MACRO CODE.\n         CLC   &KEY,&$KEY.(&RAN)   COMPARE GIVEN KEY WITH NODE.\n         AIF   ('&ST' EQ 'ASC').HIGH\n         AIF   ('&ST' EQ 'DES').LOW\n         BNE   LL&SYSNDX.A         IF NOT = CHECK NXT NODE OF LIST.\nLL&SYSNDX.B EQU *                  IF =,CC=0 AND CONTINUE.\n         MEXIT\n.HIGH    BH    LL&SYSNDX.A         IF HI CHECK NXT NODE OF ASC LIST.\nLL&SYSNDX.B EQU *                  IF =,CC=0 AND CONTINUE.\n         MEXIT\n.LOW     BL    LL&SYSNDX.A         IF LOW CHECH NXT NODE IN DES LIST.\nLL&SYSNDX.B EQU *                  IF =,CC=0 AND CONTINUE.\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RDEF": {"ttr": 14852, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00\\x10\\x00\\x10\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "ARCHIVR"}, "text": "//CHSYRDEF JOB (0227,CHSY),'FOCHTMAN - SYSTEMS',\n//  CLASS=C,NOTIFY=CHSY227\n//IDC      EXEC  PGM=IDCAMS\n//SYSPRINT DD    SYSOUT=C,HOLD=YES\n//SYSIN    DD    *\n         DEFINE CLUSTER(NAME(CHSY227.SAM.ARCHIVE) -\n                RECORDSIZE(200 24000) -\n                VOL(E8FE8F) -\n                BUFFERSPACE(262144) -\n                KEYS(49 0)) -\n          DATA(NAME(CHSY227.SAM.ARCHIVE.DATA) -\n                CONTROLINTERVALSIZE(24576) -\n                CYLINDERS( 100 100 )) -\n          INDEX(NAME(CHSY227.SAM.ARCHIVE.INDEX) -\n                CONTROLINTERVALSIZE(8192) -\n                CYLINDERS( 10 10 ))\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REASM": {"ttr": 14854, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06\\x0c\\x00\\x00\\x01 !?\\x01 !?\\x15\\x00\\x00>\\x00>\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@'", "ispf": {"version": "06.12", "flags": 0, "createdate": "2020-07-31T00:00:00", "modifydate": "2020-07-31T15:00:00", "lines": 62, "newlines": 62, "modlines": 0, "user": "ARCHIVR"}, "text": "//CHSYASMA JOB (0227,CHSY),'FOCHTMAN - SYSTEMS',\n//  CLASS=S,NOTIFY=CHSY227\n//ARCHASM  PROC  M=\n//ASM      EXEC  PGM=AEV90,\n//         PARM='TERM,DECK,NOOBJ,NORLD'\n//SYSPRINT DD    DUMMY\n//SYSTERM  DD    SYSOUT=Y,HOLD=YES                                      SYSOUT\n//SYSLIB   DD    DSN=CHSY227.ARCHIVER.OLDDIST,DISP=SHR                  DSNAME\n//         DD    DSN=SYS1.MODGEN,DISP=SHR\n//         DD    DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(3,1))\n//SYSIN    DD    DSN=CHSY227.ARCHIVER.OLDDIST(&M),DISP=SHR              DSNAME\n//SYSPUNCH DD    DSN=CHSY227.ARCHIVER.OBJ(&M),DISP=SHR                  DSNAME\n//         PEND\n//AMATRACE EXEC  ARCHASM,M=AMATRACE\n//ARCHALIS EXEC  ARCHASM,M=ARCHALIS\n//ARCHALT  EXEC  ARCHASM,M=ARCHALT\n//ARCHCOMP EXEC  ARCHASM,M=ARCHCOMP\n//ARCHCONV EXEC  ARCHASM,M=ARCHCONV\n//ARCHCOPY EXEC  ARCHASM,M=ARCHCOPY\n//ARCHDEL  EXEC  ARCHASM,M=ARCHDEL\n//ARCHDELC EXEC  ARCHASM,M=ARCHDELC\n//ARCHDELD EXEC  ARCHASM,M=ARCHDELD\n//ARCHDELE EXEC  ARCHASM,M=ARCHDELE\n//ARCHDELF EXEC  ARCHASM,M=ARCHDELF\n//ARCHDEL1 EXEC  ARCHASM,M=ARCHDEL1\n//ARCHDEL2 EXEC  ARCHASM,M=ARCHDEL2\n//ARCHDEL3 EXEC  ARCHASM,M=ARCHDEL3\n//ARCHDEL4 EXEC  ARCHASM,M=ARCHDEL4\n//ARCHDEL5 EXEC  ARCHASM,M=ARCHDEL5\n//ARCHDEL6 EXEC  ARCHASM,M=ARCHDEL6\n//ARCHDEL7 EXEC  ARCHASM,M=ARCHDEL7\n//ARCHDIR  EXEC  ARCHASM,M=ARCHDIR\n//ARCHERAS EXEC  ARCHASM,M=ARCHERAS\n//ARCHERRM EXEC  ARCHASM,M=ARCHERRM\n//ARCHEXPR EXEC  ARCHASM,M=ARCHEXPR\n//ARCHFORM EXEC  ARCHASM,M=ARCHFORM\n//ARCHIMPR EXEC  ARCHASM,M=ARCHIMPR\n//ARCHINIT EXEC  ARCHASM,M=ARCHINIT\n//ARCHKDCB EXEC  ARCHASM,M=ARCHKDCB\n//ARCHKNAM EXEC  ARCHASM,M=ARCHKNAM\n//ARCHLDT  EXEC  ARCHASM,M=ARCHLDT\n//ARCHLFTP EXEC  ARCHASM,M=ARCHLFTP\n//ARCHLFVS EXEC  ARCHASM,M=ARCHLFVS\n//ARCHLIST EXEC  ARCHASM,M=ARCHLIST\n//ARCHLOAD EXEC  ARCHASM,M=ARCHLOAD\n//ARCHLSTT EXEC  ARCHASM,M=ARCHLSTT\n//ARCHMAIN EXEC  ARCHASM,M=ARCHMAIN\n//ARCHMSGS EXEC  ARCHASM,M=ARCHMSGS\n//ARCHNOTE EXEC  ARCHASM,M=ARCHNOTE\n//ARCHPARS EXEC  ARCHASM,M=ARCHPARS\n//ARCHPRSC EXEC  ARCHASM,M=ARCHPRSC\n//ARCHRSPC EXEC  ARCHASM,M=ARCHRSPC\n//ARCHTABS EXEC  ARCHASM,M=ARCHTABS\n//ARCHUNLD EXEC  ARCHASM,M=ARCHUNLD\n//ARCHVSOP EXEC  ARCHASM,M=ARCHVSOP\n//CELLMAN  EXEC  ARCHASM,M=CELLMAN\n//COMPACT  EXEC  ARCHASM,M=COMPACT\n//DYNAM    EXEC  ARCHASM,M=DYNAM\n//EXPAND   EXEC  ARCHASM,M=EXPAND\n//EXPLODE  EXEC  ARCHASM,M=EXPLODE\n//RPARSE   EXEC  ARCHASM,M=RPARSE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RELINK": {"ttr": 14856, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06\\x0c\\x00\\x00\\x01 !?\\x01 !?\\x15\\x00\\x00\\x18\\x00\\x18\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@'", "ispf": {"version": "06.12", "flags": 0, "createdate": "2020-07-31T00:00:00", "modifydate": "2020-07-31T15:00:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "ARCHIVR"}, "text": "//CHSYLINK JOB (0227,CHSY),'FOCHTMAN - SYSTEMS',\n//  CLASS=S,NOTIFY=CHSY227\n//LINK1    EXEC  PGM=IEWL,PARM='LIST,LET,XREF,RENT,REUS,REFR'\n//SYSPRINT DD    SYSOUT=C,HOLD=YES\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(3,1))\n//SYSLIB   DD    DSN=CHSY227.ARCHIVER.OBJ,DISP=SHR\n//SYSLMOD  DD    DSN=CHSY227.ARCHIVER.LOAD,DISP=SHR\n//SYSLIN   DD    *\n INCLUDE SYSLIB(ARCHMAIN)\n ENTRY ARCHMAIN\n NAME ARCHIVER(R)\n//LINK2    EXEC  PGM=IEWL,PARM='LIST,LET,XREF'\n//SYSPRINT DD    SYSOUT=C,HOLD=YES\n//SYSUT1   DD    UNIT=SYSALLDA,SPACE=(CYL,(3,1))\n//SYSLIB   DD    DSN=CHSY227.ARCHIVER.OBJ,DISP=SHR\n//SYSLMOD  DD    DSN=CHSY227.ARCHIVER.LOAD,DISP=SHR\n//SYSLIN   DD    *\n INCLUDE SYSLIB(ARCHINIT)\n INCLUDE SYSLIB(ARCHPRSC)\n ENTRY ARCHINIT\n NAME ARCHINIT(R)\n INCLUDE SYSLIB(ARCHPARS)\n ENTRY ARCHPARS\n NAME ARCHPARS(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RELIST": {"ttr": 14858, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "ARCHIVR"}, "text": "//CHSYLOAD JOB (0227,CHSY),'FOCHTMAN - SYSTEMS',\n//  CLASS=S,NOTIFY=CHSY227,MSGCLASS=X\n//EXPORT   EXEC  PGM=ARCHIVER,REGION=4M\n//STEPLIB  DD    DSN=CHSY227.MISC.LOAD,DISP=SHR\n//*YSUDUMP DD    SYSOUT=C,HOLD=YES\n//SYSPRINT DD    DSN=CHSY227.ARCHOUT,DISP=SHR\n//SYSIN    DD    *\n  SET VSAM1DSN=CHSY227.ARCH.VSAM\n  DELETE ITEM=(*,MXG,*,*),DATA=Y,NOTE=Y\n  DELETE ITEM=(*,ISPFVSAM,UTILITY,*),DATA=Y,NOTE=Y\n  LIST ITEM=(*,*,*,*),DATA=N\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RPARSE": {"ttr": 14860, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x01\\xd4\\x01\\xd4\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 468, "newlines": 468, "modlines": 0, "user": "ARCHIVR"}, "text": "PARS     TITLE 'RPARSE--OPERAND STRING PARSING ROUTINE'\n*---------------------------------------------------------------------*\n*---     RPARSE - PARSE A STRING OF POSITIONAL AND KEYWORD         ---*\n*---           OPERANDS, USING A CALLER-DEFINED STRUCTURE          ---*\n*---           DESCRIPTION.                                        ---*\n*---                                                               ---*\n*---     ARGUMENTS:                                                ---*\n*---           WD 1 -- ADDRESS OF THE STRING TO BE EXAMINED. ALL   ---*\n*---                   LEADING BLANKS MUST BE REMOVED.             ---*\n*---           WD 2 -- ADDRESS OF A FULLWORD CONTAINING THE LENGTH ---*\n*---                   OF THE STRING IN ARGUMENT 1.                ---*\n*---           WD 3 -- THE ADDRESS OF THE START OF THE CALLER-     ---*\n*---                   DEFINED STRING STRUCTURE DESCRIPTION.       ---*\n*---                                                               ---*\n*---     STRUCTURE DESCRIPTION:                                    ---*\n*---           DS  H    NUMBER OF POSITIONAL ARGUMENTS, MAX.       ---*\n*---           DS  CL12 THE POSITIONAL OPERAND DESCRIPTIONS        ---*\n*---               DS  H   OPERAND LENGTH                          ---*\n*---               DS  H   RESERVED FOR CALLER'S USE               ---*\n*---               DS  AL4 OPERAND ADDRESS                         ---*\n*---               DS  AL4 SUBLIST DESCRIPTION. SEE BELOW.         ---*\n*---           DS  H    NUMBER OF KEYWORD OPERANDS                 ---*\n*---           DS  CL20  KEYWORD OPERAND DESCRIPTIONS              ---*\n*---               DS  CL8   THE EXPECTED KEYWORD                  ---*\n*---               DS  AL2   OPERAND LENGTH                        ---*\n*---               DS  AL2   RESERVED FOR CALLER'S USE             ---*\n*---               DS  AL4   OPERAND ADDRESS                       ---*\n*---               DS  AL4   SUBLIST DESCRIPTION, IN THE SAME      ---*\n*---                         FORM AS THE OPERAND DESCRIPTION,      ---*\n*---                         INCLUDING POSITIONAL PARMS, COUNTS,   ---*\n*---                         KEYWORDS, ETC.                        ---*\n*---                                                               ---*\n*--- NOTE: THE FIELDS IN THE STRUCTURE DESCRIPTION MUST BE         ---*\n*--- CONTIGUOUS. ALL TRADITIONAL ALIGNMENTS MUST BE BYPASSED.      ---*\n*---                                                               ---*\n*---     RETURNS:  THE OPERAND DESCRIPTION IS FILLED IN WITH       ---*\n*---           APPROPRIATE ADDRESSES AND LENGTHS FOR THE VARIOUS   ---*\n*---           KEYWORDS FOUND IN THE OPERAND STRING.               ---*\n*---                                                               ---*\n*---     RETURN CODES (IN R15):                                    ---*\n*---           RC=0   SUCCESSFUL PARSE OF THE GIVEN STRING         ---*\n*---           RC=4   PARSE SYNTAX ERROR                           ---*\n*---           RC=8   POSITIONAL PARM FOUND AFTER FIRST KW PARM    ---*\n*---           RC=12  MIS-MATCHED PARENTHESES                      ---*\n*---           RC=16  MISSING '=' AFTER KEYWORD                    ---*\n*---           RC=20  ZERO-LENGTH KEYWORD OR POSITIONAL PARAMETER  ---*\n*---           RC=24  KEYWORD NOT FOUND IN SKELETON KEYWORD LIST   ---*\n*---                  KEYWORD ADDRESS IN R0 ON RETURN              ---*\n*---                  LENGTH IN HIGH-ORDER BYTE OF R15             ---*\n*---           RC=28  SUBLIST IMPROPERLY ENDED                     ---*\n*---           RC=32  QUOTED STRING IMPROPERLY ENDED               ---*\n*---           RC=36  OPERANDS ARE NESTED TOO DEEP                 ---*\n*---                                                               ---*\n*---     ATTRIBUTES: SERIALLY REUSABLE                             ---*\n*---                                                               ---*\n*---     AUTHOR:                                                   ---*\n*---           RICK FOCHTMAN, SYSTEMS PROGRAMMER                   ---*\n*---           AMERICAN MEDICAL ASSOCIATION                        ---*\n*---           535 NORTH DEARBORN STREET                           ---*\n*---           CHICAGO, ILLINOIS                                   ---*\n*---                                                               ---*\n*---------------------------------------------------------------------*\n         EJECT\nRPARSE   CSECT\nRPARSE   AMODE 31\nRPARSE   RMODE ANY\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n         USING RPARSE,R15\n         #STAMP\n         STM   R14,R12,12(R13)     SAVE ENTRY REGS\n         LR    R12,R15             COPY E.P. ADDRESS\n         DROP  R15\n         USING RPARSE,R12\n         LR    R10,R1              COPY PARMLIST POINTER\n         LA    R3,PRSWORKL         LOAD WORK AREA SIZE\n         GETMAIN R,LV=(3)\n         LR    R2,R1               COPY AREA ADDRESS\n         LA    R4,0\n         LA    R5,0\n         MVCL  R2,R4\n         ST    R1,8(,R13)          STORE FORWARD POINTER\n         ST    R13,4(,R1)          AND BACK POINTER\n         LR    R13,R1              LOAD NEW S.A. POINTER\n         USING PRSWORK,R13         AND BASE THE DSECT\n         LA    R5,ESLSTTAB         POINT TO STACK AREA END\n         LA    R4,SBLSTTAB         AND START\n         SR    R5,R4               COMPUTE LENGTH\n         STH   R5,STKLIM           AND SAVE AS STACKING LIMIT\n         LR    R1,R10              RESTORE PARM POINTERS\n         L     R5,0(,R1)           GET PARAMETERS--STRING ADDRESS\n         L     R6,4(,R1)           STRING LENGTH\n         L     R7,8(,R1)           SKELETON ADDRESS\n         XR    R2,R2               ZERO STACK DEPTH\nSUBSTR   DS    0H\n         BAL   R10,CONSTRCT        CALL CONSTRCT--BUILD 1 LEVL OF TREE\n         LTR   R15,R15             CHECK RC\n         BNZ   EXITP               IF NON ZERO, ERROR--QUIT, RTN\n         XR    R4,R4               ZERO R4 TO INDICATE POS PART\nNXTPRT   DS    0H\n         LH    R3,0(,R7)           SEARCH TREE FOR SUBLISTS--LIST LEN\n         LA    R7,2(,R7)           BUMP PTR PAST LENGTH FLD\nNXTENT   DS    0H\n         LTR   R3,R3               IS COUNT ZERO?\n         BNZ   CHKPRM              IF NO, BRANCH\n         LTR   R4,R4               IS THIS POS PART ?\n         BM    ENDLST              IF NOT, PROCESS END OF LIST\n         BCTR  R4,0                SET R4 NEG TO INDICATE KEYWD PART\n         B     NXTPRT              GO PROCESS KEYWD PART\nCHKPRM   DS    0H\n         LTR   R4,R4               CHECK R4 FOR MODE\n         BZ    POSMD               IF ZERO, POS MODE\n         LA    R7,8(,R7)           BUMP SKEL PTR PAST KEYWORD\nPOSMD    DS    0H\n         MVC   SAVENT,0(R7)        MOVE OPERAND TO TEMP SAVE AREA\n         LA    R7,12(,R7)          BUMP PTR PAST OPERAND INFO\n         BCTR  R3,0                DECREMENT LIST COUNTER\n         CLC   SAVENT+8(4),=XL4'0' CHECK SUBLIST POINTER\n         BE    NXTENT              IF PTR=0, NO SUBLIST--DO NEXT ENT\n         CLC   SAVENT(2),=XL4'00'  IS LENGTH ZERO ??\n         BE    NXTENT              YES; NO LIST TO PROCESS\n         CH    R2,STKLIM           SAVE CURRENT STATUS IN STACK--CHECK\n         BNL   ER1                 IF OVFLW, ERROR\n         STH   R4,SBLSTTAB(R2)     SAVE MODE\n         STH   R3,SBLSTTAB+2(R2)   SAVE LIST COUNTER\n         ST    R7,SBLSTTAB+4(R2)    SAVE LIST POINTER\n         LA    R2,8(,R2)           PUSH DOWN STACK DEPTH\n         MVI   WORK,X'0'           SET UP PARAMS FOR SBLST ANALYSIS\n         L     R5,SAVENT+4         STRG ADDR TO R5\n         LH    R6,SAVENT           STRG LEN TO R6\n         L     R7,SAVENT+8         SKEL ADDR TO R7\n         LA    R7,0(,R7)           CLEAR R7 BITS 0-7\n         CLI   0(R5),C'('          IS 1ST CHAR L PAREN\n         BNE   SUBSTR              IF NO, PASS AS IS\n         LA    R5,1(,R5)           ELSE REMOVE PARENS--BUMP STRG ADDR\n         SH    R6,=H'2'            DECREMENT LENGTH BY 2\n         B     SUBSTR              PASS PARAM STRIPPED OF PARENS\nENDLST   DS    0H\n         LTR   R2,R2               END OF A SKEL LEVEL--CHECK STACK DEP\n*        BNZ   FINISHED            IF ZERO, ALL TRHOUGH\n         BZ    FINISHED            IF ZERO, ALL TRHOUGH\n         SH    R2,=H'8'            ELSE POP UP STACK\n         LH    R4,SBLSTTAB(R2)     RESTORE STATUS--MODE INDIC TO R4\n         LH    R3,SBLSTTAB+2(R2)   LIST COUNTER TO R3\n         L     R7,SBLSTTAB+4(R2)   LIST POINTER TO R7\n         B     NXTENT              GO FOR NEXT ENTRY\nFINISHED DS    0H\n         XR    R15,R15             SUCESSFUL FINISH--SET RC=0\nEXITP    DS    0H\n         L     R13,4(,R13)         LOAD BACK S.A. POINTER\n         STM   R15,R1,16(R13)      SAVE RETURN VALUES\n         L     R1,8(,R13)          LOAD MY AREA POINTER\n         FREEMAIN R,LV=PRSWORKL,A=(1)\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         BR    R14                 AND RETURN TO CALLER\nER1      DS    0H\n         LA    R15,36              OPRNDS NESTED TOO DEEP RC=36\n         B     EXITP               EXIT\n         EJECT\n*---------------------------------------------------------------------*\n*---                                                               ---*\n*---     THE CONSTRCT ROUTINE FILLS IN ONE LEVEL OF THE            ---*\n*---           SYNTAX SKELETON.                                    ---*\n*---                                                               ---*\n*---     R5 = ADDR OF 1ST BYTE OF STRING                           ---*\n*---     R6 = LENGTH OF STRING                                     ---*\n*---     R7 = ADDR OF SYNTAX SKELETON (DESIRED LEVEL)              ---*\n*---     BAL  R10,CONSTRCT                                         ---*\n*---     REGS 2 THROUGH 12 ARE SAVED                               ---*\n*---                                                               ---*\n*---------------------------------------------------------------------*\nCONSTRCT DS    0H\n         STM   R2,R12,CONSAVE      SAVE REGISTERS\n         LA    R1,0                QUICK FIX ---\n         LH    R2,0(,R7)           CLEAR THE SKEL--GET # POS PARAMS\n         LA    R8,2(,R7)           SET PTR BEYOND COUNT HLFWD\n         LTR   R2,R2               TEST # POS PARAMS\n         BZ    ZERPOS              IF ZERO, SKIP TO KWDS\n         USING PRSPSLN,R8\nCLRPOS   DS    0H\n         XC    PRSPSLN,PRSPSLN     CLEAR A POS PARAM\n         XC    PRSPSLOC,PRSPSLOC   CLEAR A POS PARAM\n         LA    R8,PRSPSBC(,R8)     BUMP PTR\n         BCT   R2,CLRPOS           CHECK POS PARM COUNT\n         DROP  R8\nZERPOS   DS    0H\n         LH    R2,0(,R8)           START KWD PARAMS--GET LENGTH\n         LA    R8,2(,R8)           BUMP PTR RAST CT HLFWD\n         LTR   R2,R2               TEST # KWD PARAMS\n         BZ    ZERKWD              IF ZERO, FINISHED CLEARING\n         USING PRSKWKW,R8\nCLRKWD   DS    0H\n         XC    PRSKWLN,PRSKWLN     CLEAR A KWD PARAM\n         XC    PRSKWLOC,PRSKWLOC   CLEAR A KWD PARAM\n         LA    R8,PRSKWBC(,R8)     BUMP PTR\n         BCT   R2,CLRKWD           CHECK KW PARAM CT\n         DROP  R8\nZERKWD   DS    0H\n         ST    R5,BEGOPR           DONE CLEARING--SAVE STRT OF OPRND\n         LH    R8,0(,R7)           GET # POS TO R8\n         LA    R7,2(,R7)           BUMP PTR PAST LENGTH\n         MVI   MODE,X'00'          CLEAR MODE FLAGS\n         LTR   R8,R8               TEST # POS PARAMS\n         BZ    ZERPSP              IF ZERO SKIP POS PROCESSING\nFIND     DS    0H\n         LR    R3,R5               SET UP TO CALL LOCATE--ADDR\n         LR    R4,R6               LENGTH\n         BAL   R11,LOCATE          CALL LOCATE TO LOCATE SYNTAX GROUP\n         B     BTAB1(R2)           BRANCH THRU BRANCH TABLE\nBTAB1    DS    0H\n         B     ENDSTRG             R2=0\n         B     BLANK               R2=4\n         B     COMMA               R2=8\n         B     LPAREN              R2=12\n         B     RPAREN              R2=16\n         B     APOST               R2=20\n         B     EQUAL               R2=24\nCOMMA    DS    0H\n         TM    MODE,X'C0'          IN STRING OR SUBLIST MODE?\n         BNZ   NEXT                IF YES, IGNORE\nOPRAND   DS    0H\n         TM    MODE,X'20'          IN KW MODE ?\n         BZ    ENDPAR              IF NO, PROCESS END OF PARAM\n         TM    MODE,X'10'          EQUAL ENCOUNTERED?\n         BZ    ERR1                IF NO, ERROR\nENDPAR   DS    0H\n         NI    MODE,X'FF'-X'10'    RESET EQUAL ENCTD FLAG\n         LR    R2,R1               GET CURRENT STRG PTR VALUE\n         S     R2,BEGOPR           COMPUTE LENGTH\n         CLC   4(4,R7),=XL4'0'     IS OPRND ALREADY THERE?\n         BNE   NOSTOR              IF SO, LEAVE AS IS\n         STH   R2,0(,R7)           STORE LEN IN SKEL\n         MVC   4(4,R7),BEGOPR      STORE PTR TO OPRND\nNOSTOR   DS    0H\n         TM    MODE,X'08'          END OF STRG?\n         BO    EXITCON             IF SO, EXIT\n         LA    R2,1(,R1)           COMPUTE START OF NEXT OPRND\n         ST    R2,BEGOPR           SAVE IT\n         TM    MODE,X'20'          KW MODE?\n         BO    NEXT                IF YES, BRANCH\n         LA    R7,12(,R7)          POSITION TO NEXT SKEL ENT\n         BCT   R8,NEXT             CHECK POS PARAM CTR\nZERPSP   DS    0H\n         LR    R8,R7               SET R8 TO KWD PART OF SKEL\n         OI    MODE,X'20'          ENTER KW MODE\n         LTR   R1,R1               ANYTHING FOUND YET ??\n         BZ    FIND                NOPE; START NOW\nNEXT     DS    0H\n         LA    R1,1(,R1)           BUMP STRG PTR\n         SR    R1,R5               COMPUTE LENGTH JUST SCANNED\n         AR    R5,R1               SET NEW START ADDR\n         SR    R6,R1               DECREMENT LEN BY SAME\n         B     FIND                GO DO NEXT SCAN\nLPAREN   DS    0H\n         TM    MODE,X'C0'          IN STRG OR SBLST MODE?\n         BNZ   P3                  IF EITHER, BRANCH\n         TM    MODE,X'20'          KW MODE?\n         BZ    P4                  IF NO, SKIP\n         TM    MODE,X'10'          EQ ENCTD?\n         BZ    ERR2                IF NO, ERROR\nP4       DS    0H\n         OI    MODE,X'80'          ENTER SUBLIST MODE\n         LA    R9,1                SET LEVEL TO 1\n         B     NEXT                GO DO NEXT SCAN\nP3       DS    0H\n         TM    MODE,X'80'          SBLST MODE?\n         BZ    NEXT                IF NO, BRANCH\n         LA    R9,1(,R9)           INCREMENT LEVEL\n         B     NEXT                GO DO NEXT SCAN\nRPAREN   DS    0H\n         TM    MODE,X'80'          SBLST MODE?\n         BZ    P5                  IF NO, BRANCH\n         SH    R9,=H'1'            DECREMENT LEVEL\n         BNZ   NEXT                IF NOT YET ZERO, BRANCH\n         NI    MODE,X'FF'-X'80'    EXIT SUBLST MODE\n         B     NEXT                GO DO NEXT SCAN\nP5       DS    0H\n         TM    MODE,X'40'          STRG MODE?\n         BO    NEXT                IF YES, IGNORE\n         B     ERR3                OTHERWISE ERROR\nAPOST    DS    0H\n         TM    MODE,X'40'          STRG MODE?\n         BZ    P7                  IF NO, BRANCH\n         CLI   1(R1),C''''         NEXT CHAR APOST?\n         BNE   P8                  IF NO, BRANCH\n         LA    R1,1(,R1)           TWO IN A ROW--POSITION TO 2ND\n         B     NEXT                IGNORE BOTH\nP8       DS    0H\n         NI    MODE,X'FF'-X'40'    EXIT STRG MODE\n         B     NEXT                GO FOR NEXT SCAN\nP7       DS    0H\n         TM    MODE,X'20'          KW MODE?\n         BZ    P9                  IF NO, BRANCH\n         TM    MODE,X'10'          EQUAL SIGN ENCTD?\n         BZ    ERR4                IF NO, ERROR\nP9       DS    0H\n         OI    MODE,X'40'          ENTER STRG MODE\n         B     NEXT                GO DO NEXT SCAN\nEQUAL    DS    0H\n         TM    MODE,X'20'          KW MODE?\n         BZ    P10                 IF NO, BRANCH\n         TM    MODE,X'10'          EQ ENCTD?\n         BO    NEXT                IF YES, IGNORE\nKEYMODE  DS    0H\n         OI    MODE,X'10'          SET EQ ENCTD FLAG\n         LR    R2,R1               COMPUTE KW LENGTH\n         S     R2,BEGOPR\n         BZ    ERR5                IF ZERO, ERROR\n         CH    R2,=H'8'            COMPARE LEN WITH 8\n         BH    ERR5                IF GTR, ERROR\n         MVC   WORK(8),=CL8' '     BLANK WORK AREA\n         BCTR  R2,0                COMPUTE LENGTH CODE\n         L     R3,BEGOPR           START OF KEYWORD TO R3\n         L     R15,4(,R13)         LOAD OLD S.A. ADDRESS\n         ST    R3,20(,R15)         STORE KEYWORD ADDRESS\n         LA    R15,1(,R2)          COPY KEYWORD'S LENGTH\n         SLL   R15,24              SHIFT TO HIGH-ORDER BYTE\n         EX    R2,MVC1             MOVE IN KEYWORD\n         LH    R2,0(,R8)           GET KEYWD LIST LENGTH\n         LA    R3,2(,R8)           SET KEYWD LIST PTR\n         LTR   R2,R2               TEST # KWDS\n         BZ    ZERKWP              IF ZERO, SKIP KWD SEARCH\nKEYSCAN  DS    0H\n         CLC   WORK(8),0(R3)       COMPARE KW TO LIST\n         BE    MATCH               BRANCH IF MATCH\n         LA    R3,20(,R3)          OTHERWISE BUMP PTR\n         BCT   R2,KEYSCAN          CHECK KWD LIST CTR\nZERKWP   DS    0H\n         B     ERR6                IF NO MATCH, ERROR\nMATCH    DS    0H\n         LA    R7,8(,R3)           POSITION R7 TO OPRND PART OF SKEL\n         LA    R2,1(,R1)           SET PTR TO START OF OPRND PART\n         ST    R2,BEGOPR           STORE IT\n         B     NEXT                GO DO NEXT SCAN\nP10      DS    0H\n         TM    MODE,X'C0'          STRG OR SUBLST MODE?\n         BNZ   NEXT                IF EITHER, IGNORE\n         MH    R8,=H'12'           COMPUTE LEN OF REST OF POS PARAMS\n         AR    R8,R7               SET PTR TO KWD PART\n         OI    MODE,X'20'          ENTER KEYWD MODE\n         B     KEYMODE             GO PROCESS PARAM\nBLANK    DS    0H\n         TM    MODE,X'40'          STRG MODE?\n         BO    NEXT                IF YES, IGNORE\nENDOPR   DS    0H\n         OI    MODE,X'08'          SET END FLAG\n         TM    MODE,X'80'          SBLST MODE?\n         BO    ERR7                IF YES, ERROR\n         TM    MODE,X'40'          STEG MODE?\n         BO    ERR8                IF YES, ERROR\n         B     OPRAND              GO FINISH PRECEDING OPERAND\nENDSTRG  DS    0H\n         LR    R1,R5               COMPUTE END POINTER--CALL ADDR\n         AR    R1,R6               PLUS LENGTH\n         B     ENDOPR              GO PROCESS END OF OPERAND\nEXITCON  DS    0H\n         XR    R15,R15             SET RC=0\nCEXIT    DS    0H\n         LM    R2,R12,CONSAVE      RESTORE REGISTERS\n         BR    R10                 RETURN\nERR1     DS    0H\n         LA    R15,4               SET RC FOR ALL ERRORS\n         B     CEXIT               RETURN\nERR2     DS    0H\n         LA    R15,8               DITTO\n         B     CEXIT\nERR3     DS    0H\n         LA    R15,12\n         B     CEXIT\nERR4     DS    0H\n         LA    R15,16\n         B     CEXIT\nERR5     DS    0H\n         LA    R15,20\n         B     CEXIT\nERR6     DS    0H\n         ICM   R15,1,=AL1(24)\n         B     CEXIT\nERR7     DS    0H\n         LA    R15,28\n         B     CEXIT\nERR8     DS    0H\n         LA    R15,32\n         B     CEXIT\n         EJECT\n*---------------------------------------------------------------------*\n*---                                                               ---*\n*---     SYNTAX CHARACTER LOCATE ROUTINE                           ---*\n*---                                                               ---*\n*---     R3=POINTER TO STRING                                      ---*\n*---     R4=STRING LENGTH                                          ---*\n*---     BAL R11,LOCATE                                            ---*\n*---     R1=POINTER TO SYNTAX CHR                                  ---*\n*---     R2=BRANCH TABLE VALUE DEPENDING ON CHARACTER              ---*\n*---     USES REGS 0,1,2,3,4--DOESN'T SAVE                         ---*\n*---                                                               ---*\n*---------------------------------------------------------------------*\nLOCATE   DS    0H\n         LH    R0,=H'256'          SET R0 TO 256\n         XR    R1,R1               CLEAR R1\n         XR    R2,R2               CLEAR R2\n         LTR   R4,R4               TEST LENGTH\n         BZ    TESTLEN             GO ANALYZE TEST\nEXTSTR   DS    0H\n         CR    R4,R0               COMPARE R4 WITH 256\n         BNH   P1                  IF NOT HIGHER, BRANCH\n         LR    R4,R0               OTHERWISE SET R4=256\nP1       DS    0H\n         BCTR  R4,0                COMPUTE SCAN LENGTH CODE\n         EX    R4,TRT1             EXECUTE TRT INSTRUCTION\n         BCR   6,R11               IF TERMINATOR FOUND, EXIT\n         AR    R3,R0               OTHERWISE COUNT IS EXHAUSTED\n         SR    R4,R0               ADJUST PARAMETERS\nTESTLEN  DS    0H\n         BNP   ENDSTR              IF FINISHED GO RETURN END OF STRG\n         B     EXTSTR              ELSE CONTINUE\nENDSTR   DS    0H\n         BR    R11                 EXIT\nTRT1     TRT   0(0,R3),TRTTAB1     TRT INSTRUCTION--OBJ OF EX\nMVC1     MVC   WORK(0),0(R3)       MOVE KEYWD TO WORK AREA--OBJ OF EX\nTRTTAB1  DC    XL256'0'            TRT TABLE FOR SYNTAX CHAR LOCATION\n         ORG   TRTTAB1+77\n         DC    AL1(12)             L PAREN\n         ORG   TRTTAB1+93\n         DC    AL1(16)             R PAREN\n         ORG   TRTTAB1+64\n         DC    AL1(4)              BLANK\n         ORG   TRTTAB1+126\n         DC    AL1(24)             EQUAL\n         ORG   TRTTAB1+125\n         DC    AL1(20)             APOSTROPHE\n         ORG   TRTTAB1+107\n         DC    AL1(8)              COMMA\n         ORG\n         SPACE 3\n         LTORG\n         SPACE 3\n*---------------------------------------------------------------------*\n*---     SAVE AREA/WORK AREA DSECT                                 ---*\n*---------------------------------------------------------------------*\nPRSWORK  DSECT\n         DS    18F                 NEW SACE AREA FOR THE CHAIN\nSTKLIM   DC    AL2(ESLSTTAB-SBLSTTAB) LIMITING STACK DEPTH, HALFWD ALIG\nMODE     DS    X                   MODE FLAGS\nCONSAVE  DS    12F\nBEGOPR   DS    A                   BEGINNING OF PARAM POINTER\nWORK     DS    XL8                 WORK AREA, FULLWORD ALIGNED\nSAVENT   DS    XL12                TEMP SKEL ENT SAVE AREA, FULLWD ALIG\nSBLSTTAB DS    40F                 RECURSION STACK--2*(# RECURSIONS)\nESLSTTAB EQU   *                   END OF STACK--FOLLOWS SBLSTTAB\n         DS    0D\nPRSWORKL EQU   *-PRSWORK\n         $PARSE DSECT\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SAMPLIB": {"ttr": 15108, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x00\\x00\\x00\\x00\\x99'\\x0f\\x00\\x99'\\x0f\\x14C\\x01\\xc5\\x01\\xc5\\x00\\x00\\xc1\\xd9\\xc3\\xc8\\xc9\\xe5\\xd9@@@\"", "ispf": {"version": "06.00", "flags": 0, "createdate": "1999-09-27T00:00:00", "modifydate": "1999-09-27T14:43:00", "lines": 453, "newlines": 453, "modlines": 0, "user": "ARCHIVR"}, "text": "./  ADD  NAME=$$SAMPS\n The sample jobs herein demonstrate the basic capabilities of the\n ARCHIVER program better than my humble ability to explain clearly the\n exact nature of those functions.  Unfortunately, since every data\n processing shop has different standards, etc. you will need to make a\n few changes to these jobs.  Here's what you'll probably need to\n change:\n\n  1.  The datasets used in these samples are the ARCHIVER distribution\n      datasets, plus one that you'll construct during installation:\n      a test ARCHIVE.  You may or may not need STEPLIB dd statements,\n      again depending on your installation.\n\n  2.  You'll need to insert a JOB statement on each sample.\n\n The samples should be run in the following order:\n\n     1. DEFINE\n     2. UNLOAD\n     3. ADDALIAS\n     4. LIST\n     5. DELETE\n     6. EXPORT\n     7. ALTER\n     8. IMPORT\n\n For further information, consult the $ARCHDOC member of the ARCHIVER.SRCE\n dataset and the comments in each sample.\n\n More detailed and a wider variety of samples will be provided as the\n development process continues.  ARCHIVER is still evolving and many of\n the suggestions I've had from users are being incorporated.\n./  ADD  NAME=ADDALIAS\n//ADDNOTE  EXEC  PGM=ARCHIVER,REGION=2048K\n//SYSPRINT DD    SYSOUT=C,HOLD=YES\n//SYSIN    DD    *\n*\n*----------------------------------------------------------------------\n* THIS JOB CONTAINS SEVERAL SAMPLES OF THE 'ADDNOTE' FUNCTION OF THE\n* ARCHIVER.  NOTE THE USE OF GENERICS IN THE ITEM 'NAME' QUALIFIER.\n*----------------------------------------------------------------------\n* USING THE 'SET' COMMAND, SET THE DSNAME OF THE ARCHIVE\n* CLUSTER. IT WILL BE DYNAMICALLY ALLOCATED.\n*\n         SET VSAM1DSN=TEST.ARCHIVE\n*\n*----------------------------------------------------------------------\n* USING THE 'ADDALIAS' COMMAND, INSERT THE ALIAS 'ARCH50' ON\n* EACH ARCHIVED ITEM THAT CARRIES 'ARCHIVER' AS THE 'GROUP' QUALIFIER.\n*\n         ADDALIAS ITEM=(*,ARCHIVER,*,*),ALIAS=(*,ARCH50,*,*)\n*\n*----------------------------------------------------------------------\n* LIST THE ALIASES\n*\n         LIST ITEM=(*,*,*,*)\n*\n*----------------------------------------------------------------------\n* DELETE ALL THE ALIASES FOR MEMBER 'ARCHMAIN', REGARDLESS OF THE\n* TRUE ALIAS VALUE\n*\n         DELALIAS ITEM=(ARCHMAIN,*,*,*)\n*\n*----------------------------------------------------------------------\n* RE-LIST THE ALIASES\n*\n         LIST ITEM=(*,*,*,*)\n*\n*----------------------------------------------------------------------\n* DELETE ALL THE ALIASES\n*\n         DELALIAS ALIAS=(*,*,*,*)\n*\n*----------------------------------------------------------------------\n* RE-LIST THE ALIASES\n*\n         LIST ITEM=(*,*,*,*)\n*\n*----------------------------------------------------------------------\n* MURPHY'S LAW BEING WHAT IT IS, WE ALSO HAVE THIS SPECIAL COMMAND\n* TO CLEAN UP ANY FAILED ALIAS PROCESSING. NOTE: NO OPERANDS\n*\n         CLEANUP\n./  ADD  NAME=ADDNOTE\n//ADDNOTE  EXEC  PGM=ARCHIVER,REGION=2048K\n//SYSPRINT DD    SYSOUT=C,HOLD=YES\n//SYSIN    DD    *\n*\n*----------------------------------------------------------------------\n* THIS JOB CONTAINS SEVERAL SAMPLES OF THE 'ADDNOTE' FUNCTION OF THE\n* ARCHIVER.  NOTE THE USE OF GENERICS IN THE ITEM 'NAME' QUALIFIER.\n*----------------------------------------------------------------------\n* USING THE 'SET' COMMAND, SET THE DSNAME OF THE ARCHIVE\n* CLUSTER. IT WILL BE DYNAMICALLY ALLOCATED.\n*\n SET VSAM1DSN=TEST.ARCHIVE\n*\n*----------------------------------------------------------------------\n* USING THE 'SET' COMMAND, SET THE NONVSAM DD NAME FOR THE\n* NOTE DATA. NOTE THAT IT'S THE INPUT STREAM.\n*\n SET DDN=NOTEFILE\n*\n*----------------------------------------------------------------------\n* ADD THE FIRST SET OF NOTE DATA TO THE ENTIRE SET OF ITEMS THAT ARE\n* THE ARCHIVER SOURCE.\n*\n ADDNOTE ITEM=(*,ARCHIVER,UTILITY,SOURCE),KEY=ARCHIVER\n*\n*----------------------------------------------------------------------\n* NOW A SPECIAL NOTE TO ARCHPARS. WE NEED TO NOTE THIS THIS ROUTINE\n* IS NOT REENTRANT.\n*\n ADDNOTE ITEM=(ARCHPARS,ARCHIVER,UTILITY,SOURCE),KEY=ARCHPARS\n*\n*----------------------------------------------------------------------\n* NOW A SPECIAL NOTE TO DYNAM. WE NEED TO NOTE THAT THIS IS PUBLIC\n* DOMAIN SOFTWARE AND WAS NOT INCLUDED IN THE COPYRIGHT.\n*\n ADDNOTE ITEM=(DYNAM,ARCHIVER,UTILITY,SOURCE),KEY=DYNAM\n*\n*----------------------------------------------------------------------\n* NOW, JUST FOR GIGGLES, LIST ALL THE NOTE DATA IN THE ARCHIVE THAT\n* PERTAINS TO THESE ITEMS.\n*\n LIST ITEM=(*,ARCHIVER,UTILITY,SOURCE),NOTE=YES\n//*\n//* THOSE RECORDS IN THE 'NOTE DATA' FILE THAT HAVE BLANKS IN THE\n//* KEY FIELD (COLS 73-80) ARE IGNORED BY THE ARCHIVER, TO ALLOW\n//* THE INSERTION OF SEPARATOR LINES FOR CLARITY.\n//*\n//NOTEFILE DD    *\n----------------------------------------------------------------------  ARCHIVER\nTHIS IS A PART OF THE VSAM ARCHIVER PROGRAM, WRITTEN BY RICHARD         ARCHIVER\nA. FOCHTMAN, JR. AND COPYRIGHTED 1999.  EXCEPT WHERE NOTED, ALL         ARCHIVER\nPARTS OF THE ARCHIVER ARE REENTRANT, REUSABLE AND REFRESHABLE.          ARCHIVER\n----------------------------------------------------------------------  ARCHIVER\n\n*********************************************************               ARCHPARS\n*  THIS ARCHIVER MODULE IS NOT REENTRANT OR REFRESHABLE *               ARCHPARS\n*********************************************************               ARCHPARS\n\n******************************************************************      DYNAM\n* THIS PARTICULAR SUBROUTINE WAS OBTAINED FROM THE CBT MODS TAPE *      DYNAM\n* AND IS PUBLIC DOMAIN SOFTWARE, NOT SUBJECT TO COPYRIGHT.       *      DYNAM\n******************************************************************      DYNAM\n./  ADD  NAME=ALTER\n//TEST     EXEC  PGM=ARCHIVER,REGION=1024K\n//SYSPRINT DD    SYSOUT=C,HOLD=YES\n//SYSIN    DD    *\n*---------------------------------------------------------------------------\n* FIRST, SET MY ARCHIVE CLUSTER DSNAME\n*\n SET VSAM1DSN=TEST.ARCHIVE\n UNLOAD ITEM=(*,ARCHIVER,UTILITY,SOURCE),DSN=ARCHIVER.SRCE\n UNLOAD ITEM=(*,ARCHIVER,UTILITY,MACRO),DSN=ARCHIVER.MACLIB\n*\n*---------------------------------------------------------------------------\n* LIST THE ORIGINAL CONTENTS\n*\n LIST ITEM=(*,*,*,*)\n*\n*---------------------------------------------------------------------------\n* MAKE A QUICKIE CHANGE, JUST FOR DEMONSTRATION PURPOSES\n*\n RESPECIFY ITEM=(*,*,UTILITY,SOURCE),NEW=(*,*,SERVAID,*)\n*\n*---------------------------------------------------------------------------\n* LIST THE RESULTS OF THAT CHANGE\n*\n LIST ITEM=(*,*,*,*)\n./  ADD  NAME=DEFINE\n  SOME JOB STATEMENT\n//IDC      EXEC  PGM=IDCAMS\n//SYSPRINT DD    SYSOUT=A\n//SYSIN    DD    *\n  /*-----------------------------------------------------------*/\n  /* CHANGE THE VALUES FOR THE VARIOUS NAMES AND THE VOLSER    */\n  /* TO FIT YOUR INSTALLATION BEFORE TRYING TO RUN THIS JOB    */\n  /*-----------------------------------------------------------*/\n\n         DEFINE CLUSTER(NAME(TEST.ARCHIVE) -                /* +++++ */\n                RECORDSIZE(200 32000) -\n                VOL( WHEREEVER ) -                          /* +++++ */\n                BUFFERSPACE(524288) -\n                KEYS(49 0)) -\n          DATA(NAME(TEST.ARCHIVE.DATA) -                    /* +++++ */\n                CYLINDERS( 10 10 )) -\n          INDEX(NAME(TEST.ARCHIVE.INDEX) -                  /* +++++ */\n                CYLINDERS( 10 10 ))\n./  ADD  NAME=DELETE\n//DELETE   EXEC  PGM=ARCHIVER,REGION=1024K\n//*\n//* THIS DEMO DOES AN UNLOAD TO THE ARCHIVE CLUSTER BEFORE ANYTHING,\n//* ELSE SO THAT WE CAN HAVE SOME BACK-LEVEL ITEMS TO REFER TO IN\n//* THE DEMONSTRATIONS THAT FOLLOW.  FOR DEMO PURPOSES, YOU SHOULD\n//* IGNORE THE UNLOAD CONTROL STATEMENTS.\n//*\n//SYSPRINT DD    SYSOUT=C,HOLD=YES\n//SYSIN    DD    *\n*\n*----------------------------------------------------------------------\n* THIS JOB CONTAINS SEVERAL SAMPLES OF THE 'DELETE' FUNCTION OF THE\n* ARCHIVER.  NOTE THE USE OF GENERICS IN THE ITEM 'NAME' QUALIFIER.\n* BOTH TYPES OF GENERICS ARE DEMONSTRATED.  ALSO, THE ABILITY TO DELETE\n* 'BACK LEVEL' ITEMS IS DEMONSTRATED.\n*----------------------------------------------------------------------\n* USING THE 'SET' COMMAND, SET THE DSNAME OF THE ARCHIVE\n* CLUSTER. IT WILL BE DYNAMICALLY ALLOCATED.\n*\n SET VSAM1DSN=TEST.ARCHIVE\n UNLOAD ITEM=(*,ARCHIVER,UTILITY,SOURCE),DSN=ARCHIVER.SRCE\n UNLOAD ITEM=(*,ARCHIVER,UTILITY,SOURCE),DSN=ARCHIVER.SRCE\n UNLOAD ITEM=(*,ARCHIVER,UTILITY,SOURCE),DSN=ARCHIVER.SRCE\n UNLOAD ITEM=(*,ARCHIVER,UTILITY,MACRO),DSN=ARCHIVER.MACLIB\n UNLOAD ITEM=(*,ARCHIVER,UTILITY,MACRO),DSN=ARCHIVER.MACLIB\n UNLOAD ITEM=(*,ARCHIVER,UTILITY,MACRO),DSN=ARCHIVER.MACLIB\n UNLOAD ITEM=(*,ARCHIVER,UTILITY,SAMPLE),DSN=ARCHIVER.SAMPLIB\n UNLOAD ITEM=(*,ARCHIVER,UTILITY,SAMPLE),DSN=ARCHIVER.SAMPLIB\n UNLOAD ITEM=(*,ARCHIVER,UTILITY,SAMPLE),DSN=ARCHIVER.SAMPLIB\n UNLOAD ITEM=(MANUAL,ARCHIVER,UTILITY,TEXT),DSN=ARCHIVER.DOC\n UNLOAD ITEM=(MANUAL,ARCHIVER,UTILITY,TEXT),DSN=ARCHIVER.DOC\n UNLOAD ITEM=(MANUAL,ARCHIVER,UTILITY,TEXT),DSN=ARCHIVER.DOC\n UNLOAD ITEM=(*,ARCHIVER,UTILITY,LMOD),DSN=ARCHIVER.LOAD\n UNLOAD ITEM=(*,ARCHIVER,UTILITY,LMOD),DSN=ARCHIVER.LOAD\n UNLOAD ITEM=(*,ARCHIVER,UTILITY,LMOD),DSN=ARCHIVER.LOAD\n*\n* IGNORE THIS STATEMENT AS WELL. IT CONSTRUCTS ALIASES FOR LATER USE\n*\n ADDALIAS ITEM=(*,ARCHIVER,*,*),ALIAS=(*,ARCH50,*,*)\n*\n*----------------------------------------------------------------------\n* LIST THE CONTENTS OF THE ARCHIVE, TO START WITH.\n*\n LIST ITEM=(*,*,*,*)\n*\n*----------------------------------------------------------------------\n* DELETE ALL BACK LEVELS OF ARCHIVER,UTILITY,SOURCE\n*\n DELETE ITEM=(*,ARCHIVER,UTILITY,SOURCE),BACK=YES\n*\n*----------------------------------------------------------------------\n* DELETE ALL BACK LEVELS OF THE 'DOC' FILE\n*\n DELETE ITEM=(MANUAL,*,*,*),BACK=YES\n*\n*----------------------------------------------------------------------\n* DELETE ALL LMODS THAT START WITH C\n*\n DELETE ITEM=(C*,*,*,LMOD),NOTE=Y,DATA=Y,ALIASES=Y\n*\n*----------------------------------------------------------------------\n* DELETE ALL LMODS THAT START WITH D, RETAINING THEM UNDER THE ALIASES\n*\n DELETE ITEM=(*,ARCHIVER,*,LMOD),NOTE=Y,DATA=Y,ALIASES=N\n*\n*----------------------------------------------------------------------\n* RE-LIST THE CONTENTS OF THE ARCHIVE, TO SHOW RESULTS\n*\n LIST ITEM=(*,*,*,*)\n./  ADD  NAME=EXPORT\n//EXPORT   EXEC  PGM=ARCHIVER,REGION=4M\n//SYSPRINT DD    SYSOUT=C,HOLD=YES\n//OUT1     DD    DSN=ARCHIVER.ARCHEXP,DISP=(,CATLG),  <- NOTE DSNAME\n//         UNIT=T3480,LABEL=(,SL,EXPDT=99000)\n//* NOTE: THE OUTPUT DATASET MAY BE ANY QSAM-SUPPORTED DEVICE; EVEN\n//*       A PRINTER, IF YOU'RE SO INCLINED (WHY, I DON'T KNOW, BUT..)\n//SYSIN    DD    *\n*\n*----------------------------------------------------------------------\n* SET THE INPUT AND OUTPUT FILES USING THE SET COMMAND\n*\n SET VSAM1DSN=TEST.ARCHIVE\n SET EXPTPDD=OUT1\n*\n*----------------------------------------------------------------------\n* EXPORT THE ENTIRE ARCHIVE TO A PORTABLE DATASET\n*\n EXPORT ITEM=(*,*,*,*)\n./  ADD  NAME=IMPORT\n//IMPORT   EXEC  PGM=ARCHIVER,REGION=4M\n//SYSPRINT DD    SYSOUT=C,HOLD=YES\n//TAPE1    DD    DSN=ARCHIVER.ARCHEXP,DISP=SHR <== NOTE DSNAME\n//* NOTE: THE INPUT DATASET MAY BE ANY QSAM-SUPPORTED DEVICE; EVEN\n//*       A CARD READER, IF YOU'RE SO INCLINED\n//*       (WHY, I DON'T KNOW, BUT..)\n//SYSIN    DD    *\n*\n*----------------------------------------------------------------------\n* SET THE INPUT AND OUTPUT FILES USING THE SET COMMAND\n*\n SET VSAM1DSN=TEST.ARCHIVE\n SET EXPTPDD=TAPE1\n*\n*----------------------------------------------------------------------\n* IMPORT THE ENTIRE ARCHIVE FROM A PORTABLE DATASET\n*\n IMPORT ITEM=(*,*,*,*)\n./  ADD  NAME=LIST\n//LIST     EXEC  PGM=ARCHIVER,REGION=1024K\n//SYSPRINT DD    SYSOUT=C,HOLD=YES\n//SYSIN    DD    *\n*\n*----------------------------------------------------------------------\n* THIS JOB CONTAINS SEVERAL SAMPLES OF THE 'LIST' FUNCTION OF THE\n* ARCHIVER.  NOTE THE USE OF GENERICS\n*----------------------------------------------------------------------\n* USING THE 'SET' COMMAND, SET THE DSNAME OF THE ARCHIVE\n* CLUSTER. IT WILL BE DYNAMICALLY ALLOCATED.\n*\n SET VSAM1DSN=TEST.ARCHIVE\n*\n*----------------------------------------------------------------------\n* LIST THE CONTENTS OF THE ARCHIVE CLUSTER.  THIS GENERATES A 'TABLE\n* OF CONTENTS' OF THE ARCHIVE.\n*\n LIST ITEM=(*,*,*,*)\n*\n*----------------------------------------------------------------------\n* LIST THE NOTEDATA ON MEMBER ARCHPARS.  THE HEADER RECORD INFORMATION\n* IS ALSO LISTED.\n*\n LIST ITEM=(ARCHPARS,ARCHIVER,UTILITY,SOURCE),NOTE=YES\n*\n*----------------------------------------------------------------------\n* LIST THE COMPLETE RPARSE ITEM, BOTH NOTE DATA AND MEMBER DATA.\n*\n LIST ITEM=(#%%,ARCHIVER,UTILITY,MACRO),NOTE=YES,DATA=YES\n./  ADD  NAME=LOAD\n//LOAD     EXEC  PGM=ARCHIVER,REGION=1024K\n//SYSPRINT DD    SYSOUT=C,HOLD=YES\n//PDS1     DD    UNIT=SYSALLDA,SPACE=(CYL,(10,10,45),RLSE),\n//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=9040,DSORG=PO)\n//PDS2     DD    UNIT=SYSALLDA,SPACE=(CYL,(10,10,45),RLSE),\n//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120,DSORG=PO)\n//PDS3     DD    UNIT=SYSALLDA,SPACE=(CYL,(10,10,45),RLSE),\n//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=400,DSORG=PO)\n//SYSIN    DD    *\n*\n*----------------------------------------------------------------------\n* THIS JOB CONTAINS SEVERAL SAMPLES OF THE 'LOAD' FUNCTION OF THE\n* ARCHIVER.  NOTE THE USE OF GENERICS IN THE ITEM 'NAME' QUALIFIER.\n* NOTE ALSO THAT THE OUTPUT DATASETS ARE NOT DYNAMICALLY ALLOCATED,\n* SINCE THEY ARE NEW.  YOU'LL ALSO SEE AN EXAMPLE OF DCB\n* INCOMPATABILITY DURING THE LOAD\n*----------------------------------------------------------------------\n* USING THE 'SET' COMMAND, SET THE DSNAME OF THE ARCHIVE\n* CLUSTER. IT WILL BE DYNAMICALLY ALLOCATED.\n*\n SET VSAM1DSN=TEST.ARCHIVE\n*\n*----------------------------------------------------------------------\n* LOAD THE SOURCE DATASET.\n*\n LOAD ITEM=(*,ARCHIVER,UTILITY,SOURCE),DDN=PDS1\n*\n*----------------------------------------------------------------------\n* LOAD THE SOURCE DATASET AGAIN, WITH REPLACE\n*\n LOAD ITEM=(*,ARCHIVER,UTILITY,SOURCE),DDN=PDS1,REPLACE=Y\n*\n*----------------------------------------------------------------------\n* LOAD THE SAMPLIB TO PDS3\n*\n LOAD ITEM=(*,ARCHIVER,UTILITY,SAMPLE),DDN=PDS3\n*\n*----------------------------------------------------------------------\n* NOW SCREW UP. TRY TO LOAD THE LMODS TO PDS3\n*\n LOAD ITEM=(*,ARCHIVER,UTILITY,LMOD),DDN=PDS3\n./  ADD  NAME=REGULAR\n//CHSYARCH JOB   (0227,CHSY),'FOCHTMAN - SYSTEMS',\n//         CLASS=S,NOTIFY=CHSY227\n//*\n//* USED FOR THE CONSTRUCTION OF ARCHIVER BATCH JOBS FOR MY OWN USE\n//ARCH     EXEC  PGM=ARCHIVER,REGION=2M\n//STEPLIB  DD    DSN=CHSY227.MISC.LOAD,DISP=SHR\n//SYSPRINT DD    SYSOUT=C,HOLD=YES\n//SYSUDUMP DD    SYSOUT=E,HOLD=YES\n//SYSIN    DD    *\n SET VSAM1DSN=CHSY227.V4.ARCHIVE\n./  ADD  NAME=REORGD\n//* REORG A VSAM CLUSTER, INCLUDING AN ARCHIVE CLUSTER.\n//* CHANGE THE DSNAMES AND CLUSTER NAMES AS NEEDED.\n//REORG1   EXEC  PGM=IDCAMS,REGION=2048K\n//SYSPRINT DD    SYSOUT=C,HOLD=YES\n//SAVETAP1 DD    UNIT=SYSDA,SPACE=(CYL,(100,100),RLSE),\n//         DSN=SAVE.TESTARCH,DISP=(,CATLG),           <--- DSNAME\n//         DCB=BLKSIZE=23476\n//SYSIN    DD    *\n    EXPORT TEST.ARCHIVE -          /* CLUSTER NAME ?? */\n           OUTFILE(SAVETAP1)\n    IMPORT INFILE(SAVETAP1) -\n           OUTDATASET(TEST.ARCHIVE) -          /* CLUSTER NAME ?? */\n             OBJECTS((TEST.ARCHIVE))           /* CLUSTER NAME ?? */\n./  ADD  NAME=UNLOAD\n//UNLOAD   EXEC  PGM=ARCHIVER,REGION=1024K\n//*\n//* PLEASE NOTE: IF YOU ARE UNLOADING A PDS WITH MANY, MANY MEMBERS,\n//* YOUR REGION REQUIREMENTS MAY BE LARGER.  EXPECT TO USE ABOUT 80K\n//* FOR EACH 1000 MEMBER AND/OR ALIAS NAMES IN THE DIRECTORY FOR\n//* INTERNAL TABLES, DATA CHAINS, ETC.  ALSO THE BUFFER REQUIREMENTS\n//* FOR VSAM WILL AFFECT REGION REQUIREMENTS.\n//*\n//SYSPRINT DD    SYSOUT=C,HOLD=YES\n//SYSIN    DD    *\n*\n*----------------------------------------------------------------------\n* THIS JOB CONTAINS SEVERAL SAMPLES OF THE 'UNLOAD' FUNCTION OF THE\n* ARCHIVER.  NOTE THE USE OF GENERICS IN THE ITEM 'NAME' QUALIFIER.\n* BOTH TYPES OF GENERICS ARE DEMONSTRATED.  NOTE ALSO THAT ALL DATASETS\n* EXCEPT SYSIN/SYSPRINT ARE DYNAMICALLY ALLOCATED.\n*----------------------------------------------------------------------\n* USING THE 'SET' COMMAND, SET THE DSNAME OF THE ARCHIVE\n* CLUSTER. IT WILL BE DYNAMICALLY ALLOCATED.\n*\n SET VSAM1DSN=TEST.ARCHIVE\n*\n*----------------------------------------------------------------------\n* USING THE 'SET' COMMAND, SET THE FIRST NONVSAM DSNAME\n* TO BE PROCESSED. AGAIN, IT'S DYNAMICALLY ALLOCATED.\n*\n SET DSN=ARCHIVER.SRCE\n*\n*----------------------------------------------------------------------\n* UNLOAD THE INPUT DATASET, A PARTITIONED DATASET, TO THE\n* ARCHIVE.  THIS EXAMPLE ASSUMES A ASSEMBLER-LANGUAGE\n* SOURCE LIBRARY.\n*\n UNLOAD ITEM=(*,ARCHIVER,UTILITY,SOURCE)\n*\n*----------------------------------------------------------------------\n* UNLOAD A SECOND INPUT PDS TO THE ARCHIVE WITH SLIGHTLY DIFFERENT\n* QUALIFIER DATA.  NOTE THE PRESENCE OF THE DSN= OPERAND, NORMALLY\n* FOUND ON THE 'SET' COMMAND.  IT'S LEGAL HERE, TOO.\n*\n UNLOAD ITEM=(*,ARCHIVER,UTILITY,MACRO),DSN=ARCHIVER.MACLIB\n*\n*----------------------------------------------------------------------\n* AND YET ANOTHER PDS\n*\n UNLOAD ITEM=(*,ARCHIVER,UTILITY,SAMPLE),DSN=ARCHIVER.SAMPLIB\n*\n*----------------------------------------------------------------------\n* NOW UNLOAD A SEQUENTIAL DATASET\n*\n UNLOAD ITEM=(MANUAL,ARCHIVER,UTILITY,TEXT),DSN=ARCHIVER.DOC\n*\n*----------------------------------------------------------------------\n* UNLOAD A LOAD-MODULE PDS. FOR THIS SAMPLE I USED\n* MY ARCHIVER LOADLIB.\n*\n UNLOAD ITEM=(*,ARCHIVER,UTILITY,LMOD),DSN=ARCHIVER.LOAD\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WISHLIST": {"ttr": 15116, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x00\\x89\\x12o\\x00\\x99'\\x0f\\x14E\\x00\\x19\\x00\\x16\\x00\\x00\\xc3\\xc8\\xe2\\xe8\\xf2\\xf2\\xf7@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "1989-05-06T00:00:00", "modifydate": "1999-09-27T14:45:00", "lines": 25, "newlines": 22, "modlines": 0, "user": "CHSY227"}, "text": " THINGS THAT USERS WOULD STILL LIKE TO SEE IN THE ARCHIVER:\n\n *  ERROR MESSAGES ARE NOT REAL OBVIOUS. THEN SHOULD HAVE SOME SORT\n    OF LEAD-IN FLAGS THAT WOULD MAKE THEM STAND OUT.\n\n *  THE LIST/LISTT FUNCTIONS SHOULD BE ABLE TO LIST THE PDS DIRECTORY\n    DATA, INCLUDING ANY ALIAS INFORMATION PRESENT.\n\n    (WHEN I DO THAT, THINK ABOUT ADDING LINK EDIT DATE FOR LMODS.\n     COULD BE EXTRACTED DURING UNLOAD OR RECONSTRUCTED DURING\n     THE LIST, IF I CAN IDENTIFY THE LINKAGE EDITOR IDR RECORDS.)\n\n *   MAKE THE COMPARE FUNCTION OPTIONALLY CALL THE DELETE & ADDALIAS\n     FUNCTIONS AUTOMATICALLY WHEN A DUPLICATE IS FOUND.\n\n *   OPTIONALLY GENERATE ISPF-LIKE DIRECTORY STATISTICS FOR NON-LMOD\n     PDS MEMBER RELOADS, IF THAT DATA ISN'T ALREADY PRESENT.\n\n *   RANGE VALUES FOR QUALIFIER DATA ON CONTROL STATEMENTS.\n\n *   ABEND INTERCEPTION IN ARCHPARS ??\n\n *   ABILITY TO DYNAMICALLY ALLOCATE OUTPUT NON-VSAM DATASETS BASED ON THE\n     ITEMS TO BE LOADED INTO IT. (FOR CBT TAPE PROCESSING!)\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT147/FILE147.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT147", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}