{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012401000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 3762304, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 42, "INMDSNAM": "CBT.V500.FILE571.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 3762304, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 3762304, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE571.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00=\\x0f'", "DS1TRBAL": "b'\\x0f\\x02'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04E\\x00\\x07\\x04I\\x00\\x08\\x00>'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04L\\x00\\x00\\x01\\x08\\x10/\\x01\\x08\\x10/\\x184\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf6@@@'", "ispf": {"version": "04.76", "flags": 0, "createdate": "2008-04-11T00:00:00", "modifydate": "2008-04-11T18:34:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-476"}, "text": "REGULAR CBT TAPE - VERSION 476    FILE:  571\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT476.FILE571\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    3200    PO\n\n   PDS117I 221 MEMBERS COUNTED; CUMULATIVE SIZE IS 34,597 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   04/11/08    18:34:12    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE1": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x17\\x01\\x08\\x10\\x1f\\x01\\x08\\x10\\x1f\\x02\"\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-04-10T00:00:00", "modifydate": "2008-04-10T02:22:17", "lines": 28, "newlines": 28, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:    Re: RECV370 update to Greg Price\nFrom:       Jim Morrison <n9gtm@comcast.net>\nDate:       Wed, 9 Apr 2008 15:58:17 -0500\nTo:         Sam Golob <sbgolob@cbttape.org>\n\nHi Sam,\n\nI am sending you a complete source refresh v00.06, **minus** the\nmembers you guys incorporated into CBT file 571 ($OLDFILE,\n@FILE571, and so forth).  This is the first version which removes\nthe IP Stack source code (well, most of it), since it's in your\n$OLDFILE.  I couldn't see any need to have it in two places, and\nthe current source is drifting away from the old IP Stack source\nanyway.\n\nSorry to say, testing has been extremely light  :-(    Perhaps more\nat some later date.\n\nAnyway, find attached an uncompressed XMIT from SYS2.XMIT370.ASM\non a 3380 with the faked-out z/OS IEBCOPY unload COPYR1 record\n(COPYR1 ddname in XMIT370).  Please let me know if you have\nproblems dealing with it.  Greg said you had some issues with an\nXMIT he sent you but it sounded like his source DASD volume had\nissues.  He planned to spin a new 3390 and retry the XMIT, IIRC.\n\nBest wishes,\nJim\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE2": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x08\\x10/\\x01\\x08\\x10/\\x12\"\\x00#\\x00&\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2008-04-11T00:00:00", "modifydate": "2008-04-11T12:22:00", "lines": 35, "newlines": 38, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:    Re: RECV370 update to Greg Price\nFrom:       Jim Morrison <n9gtm@comcast.net>\nDate:       Thu, 10 Apr 2008 19:43:08 -0500\nTo:         Sam Golob <sbgolob@cbttape.org>\n\nOn Thursday 10 April 2008 01:33, you wrote:\n\n>>     I've updated the Updates page, www.cbttape.org with a new\n>> File 571.  Please check it over for accuracy and documentation.\n>> Thanks very much for your good work, always.\n\n(snip - Other stuff that has since been corrected.  sbg)\n(Please see my additional note, below.  sbg)\n\nI checked the JXMITPDS member that Phil updated, and I believe\nthe version I supplied includes his changes.  Same with U370DATE.\n\nI updated my email address in the @FILE571.txt file, attached.\n\nThat's all I've seen so far, and everything above is pretty minor.\n\nThanks for all your great work at CBT!\n\nBest wishes,\nJim\n\nNote from Sam Golob:  Object decks for all modules are in a PDSLOAD\n    format (i.e. IEBUPDTE SYSIN format with ISPF stats) member called\n    OBJECT.  Load library for all modules is in XMIT-format as member\n    LOADLIB.  You will need RECV370 (or TSO RECEIVE) to extract this\n    to a load library, so it's better to get your load library from\n    running the JINSTALL job.  The member called JINSTAL1 runs on a\n    system that I have access to, and is Jim's job as customized by\n    me.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE3": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00C\\x01\\x08\\x10/\\x01\\x08\\x10/\\x183\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-04-11T00:00:00", "modifydate": "2008-04-11T18:33:43", "lines": 30, "newlines": 30, "modlines": 0, "user": "SBGOLOB"}, "text": "From: \"Jim Morrison\" <jim.n9gtm@gmail.com>\nDate: Fri Apr 11, 2008 6:18 pm\nSubject: RECV370 File571 v00.06\n\nGreetings,\n\nWith Sam G's help there is now an updated version of the\nMVS38j RECV370 program available for download on the CBT\nupdates page http://cbttape.org/updates.htm .\n\nhttp://cbttape.org/ftp/updates/CBT571.zip  (CBT Tape Updates File 571)\n\nThe only real change between v00.05 and v00.06 is to\nRECV370, and that only to repair a bug exposed when\nthe XMIT control record(s) span segments.  Frequently\nthe error caused by this bug was reported by RECV370\nas \"unknown key\" and some seemingly random key.\n\nSince the other code in File571 uses the same version\nsymbol, all the code built from source will reflect\nv00.06: DAST370 (Dual Address Space systems programmer\ntoy), RECV370, and XMIT370.  The STCP IP Stack code has\nnot been updated and possibly may not assemble with the\ncurrent macros.  If you wish to build the STCP370 code\nplease use the macros from $OLDF571.\n\nEnjoy!\n\nJim Morrison\n\n", "mimetype": "message/rfc822", "datatype": "ebcdic", "extension": ".eml"}, "$CHANGES": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00\\xf3\\x00\\xf3\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 243, "newlines": 243, "modlines": 0, "user": "XV0006"}, "text": "Copyright 2001-2008 James M. Morrison\n\nChange log\n\n00.06 - 2008/04/09\n------------------\n\nBug fix for Y2K incorporated (U370DATE CSECT)\n\nBug fix: control records split across multiple segments\n\n    Changes/additions: RECV#BUG, RECVGET -> RECVGSEG,\n    JBUGTINY, JINSTALL, JRECV1, JRECVALL, KBUGRECV,\n    KLNKRECV, RECV370, RECVBLK, RECVCTL, RECVGSEG, $RECV,\n    RECVVTAB, WARECV, WARGS, RECVGCTL (new), JCBTXMIT, U#SET\n\nRemove IP Stack code (copy archived in CBT File 571)\n\n0005 - 2002/??/??\n-----------------\n\nInfrastructure changes\nIn general, an attempt was made to make xxxx370 ready for running\nunder multiple TCBs in support of the MVS38j TCP/IP work\n\nAdded TGD, Task Global Data, to the front of each xxxx370's WAxxxx\nmapping.  Rather than share XMITWA, each xxxx370 application (XMIT,\nRECV, DAST, etc.) has their own WAxxxx DSECT.   Appl names must be\nfour chars; mine end in 370.\n\nAdded CPD, CSECT-related Persistent Data\nEach CSECT has the opportunity to extend the base CPD with their\nuser CGD additions.  CPD data is only initialized at the beginning\nof the xxxx370 application.  The SX is also only initialized at\nappl startup.  Each CSECT's SA is still cleard to x'00' in UPROC.\nPractically speaking, the CPD precedes the DSA in storage due to\nthe way UFINI defines the Pseudo-Registers.\n\nDSA pool redesigned.  Rather than the old Dynamic DSA technique, Q-cons\nare used to provide static DSA locations.  New CSECT U370AP00 inits\neach CPD (see below) and SX, reducing the UPROC code path.\n\nU370AP00 copies U370VTAB (each appl has it's own VTAB, with each one\nusing the U370VTAB CSECT name) to it's CPD and anchors it via TGD@VTAB\nAP00 locates each CSECT's CPD (if it has one), and each CSECT's\nDSA (SX + SA); stores the addresses and lengths in VTAB.  Once\nU370DBUG gets control, (subject to the correct debug level) the VTAB\nis displayed producing a handy debugging reference.\n\nWith the advent of QCON DSAs, the order in which the Linkage Editor\nsee it's input object decks becomes important so that LKED assigns\noffset zero to the TGD.  CSECT xxxx370 must be first obj deck.\nUPROC checks & ABENDs if non-zero.\n\nNew CSECT U370STAE - added ESTAE support\nEach CSECT can specify a Retry routine which will be called via RTM2.\n$RTM member has a few RTM notes, but not much.\nESTAE support has some minimal CPD storage requirements, but most\nof the ESTAE support is optional depending on UPROC specifications.\n\nU370SDWA called by U370STAE.RETRY2 produces summary debugging info\nfrom RTM's SDWA.  For each 'at time of error' GPR, U370SDWA calls\nnew CSECT U370VADR which attempts to describe where the GPR points.\n\nXMITDBUG ddname now xxxxDBUG, where xxxx is appl name\nXMITPRT  ddname now xxxxLOG,  where xxxx is appl name\n\nRenamed all the UTILxxxx CSECTs to U370xxxx, mostly so all the U*\nmacros are distinct from the CSECTs.  Renamed many macros; all\ncode generating macros (and a few others) should begin with U.\n\nEffective with this release, all xxxx370 applications require APF\nauthorization.  U370AP00 will enter supervisor state, U370AP99 will\nreturn to problem state before returning to ID=MAIN's caller.\n\nNew:\nDSACPD   macro    - data area; CPD = CSECT Persistent Data\nDSAEX    macro    - data area; DSA = SA + SX: savearea & header\nDSWIB    macro    - data area; WIB = WUD Information Block\nDSWUD    macro    - data area; WUD = Work Unit Descriptor\n                    STCPTSKM parm & STCP subtask inventory\nDVADRBUF macro    - data area; U370VADR output buffer\nJSTCP    JCL      - run STCP370 in batch\nJSTCPALL JCL      - assemble all STCP370 CSECTs\nJSTCP1   JCL      - assemble single STCP370 CSECT\nKBUGDAST input    - DAST370 debug level spec for U370DBUG\nKBUGRECV input    - RECV370 debug level spec for U370DBUG\nKBUGSTCP input    - STCP370 debug level spec for U370DBUG\nKBUGXMIT input    - XMIT370 debug level spec for U370DBUG\nKLNKDAST input    - DAST370 linkage editor input\nKLNKRECV input    - RECV370 linkage editor input\nKLNKSTCP input    - STCP370 linkage editor input\nKLNKXMIT input    - XMIT370 linkage editor input\nRECV#BUG CSECT    - RECV370 TGD debug bytes\nRECVMSG  CSECT    - RECV370 handle embedded message file\nRECVVTAB CSECT    - RECV370 VCON table\nSTCP#BUG macro    - STCP370 TGD debug bytes\nSTCPOPR  CSECT    - STCP370 operator interface startup & subtask\nSTCPTSKM CSECT    - STCP370 task manager & subtask startup\nSTCPVTAB CSECT    - STCP370 VCON table\nSTCP370  CSECT    - STCP370 main\nTCP      JCL      - STCP370 SYS1.PROCLIB(TCP) PROC - TCP/IP STC\nU#DPR    macro    - Define Pseudo-Register (internal macro)\nU#EQU    macro    - common equates\nU@CPD    macro    - locate CSECT's CPD/TPU\nU@SX     macro    - locate CSECT's SX\nUESTAE   macro    - STCPSTAE interface - ESTAE support\nULOCK    macro    - Compare and Swap helper macro (saves reading POPs)\nUQENV    macro    - U370QENV interface - query environment\nUSTATE   macro    - inline code - MODESET & SPKA support\nUVTAB    macro    - xxxxVTAB entry & DSECT\nUWTO     macro    - U370WTO interface - WTO support\nU370#BUG macro    - U370xxxx TGD debug bytes + xxxx370 debug byte\nU370#VTB macro    - xxxxVTAB VCON table definitions for U370xxxx\nU370AP00 CSECT    - Appl startup, UPROC support\nU370AP99 CSECT    - stub\nU370CHAR CSECT    - Convert R0 to EBCDIC\nU370HERC CSECT    - incomplete fooling around with Hercules DIAGNOSEs\nU370QENV CSECT    - query APF & Hercules emulator presence\nU370QTCB CSECT    - debug aid; TCB summary\nU370SDWA CSECT    - debug aid; displays SDWA for U370STAE\nU370STAE CSECT    - ESTAE support\nU370VADR CSECT    - text description of virtual address\nU370WTO  CSECT    - issues WTO, echoes on xxxxLOG ddname\nWADAST   macro    - DAST370 workarea\nWARECV   macro    - RECV370 workarea\nWASTCP   macro    - STCP370 workarea\nWATGD    macro    - TGD - beginning of WAxxxx areas\nWAXMIT   macro    - XMIT370 workarea\nXMIT#BUG CSECT    - XMIT370 TGD debug bytes\nXMITVTAB CSECT    - XMIT370 VCON table\n\nNotable CSECT changes:\nU370ABND - gutted, no longer issues WTOs with ABEND regs\n           U370STAE/U370SDWA does much nicer job\n           Calls U370VADR to get module.csect+offset for WTO\nU370LOG  - If TGDLOGD = ddname, will be used for OPEN\nU370SNAP - finally eliminated excessive duplicate output\nU370AP99 - will call CSECT XXXXAP99 for application-specific\n           cleanup\n\n\n\n\n0004 - 2002/06/13\n-----------------\n\nFirst version to be contributed to the CBT tape.  Sam G gently prodded\nme, and I finally did it.  See also\n\n    http://ensose.com/mvs38j.html\n\nfor possibly more recent versions (in case I forget to send them to\nSam), and some other stuff for MVS38j - including\n\n    MVS38j 3375/3380/3390 support,\n    RECV390,\n    and some Hercules user tools like rdrprep, dasdseq.\n\nReally curious persons are free to check the mvs38j directory on that\nmachine for who-knows-what bits du-jour).  Most likely, I've said\nsomething about those bits in the H390-MVS or hercules-390 groups\n(currently hosted at Yahoo.com).\n\nAddition of COPYR1 feature, which allows minor customization of the\nIEBCOPY COPYR1 record for unloaded PDSs.  IEBCOPY is rumored to have\nhad variously sized COPYR1 records throughout it's history, this is\nintended to create XMITs targeted for environments which have IEBCOPY\nversions that don't understand differently sized COPYR1s.\n\nAnnoying XMITDBUG open fail message no longer appears; UTILTIOT used\nto scan TIOT before open attempted\n\nRenamed many macros, asm source code, jcl to permit distribution of\none library for CBT distribution ease.\n\nObservant readers may note references to RECV370; it's not officially\nin this version, but the code's there for the brave.  You'll likely\nneed it if you plan on receiving the XMITs created by XMIT370 with\nsomething besides dasdload or RECV390.  That wasn't the plan, but\ntesting has revealed some interesting TSO/E RECEIVE/IEBCOPY behaviors\nI wasn't counting on.  See $NOTES for further details.\n\nUTILABND needs more work; the STSI technique for identifying Hercules\nwas recently (2002/06/19) decided, and this version of XMIT370 does\nnothing in particular with it.  STSI is now a valid instruction\nin S/370 mode under Hercules.  Getting the SYSIB seems beyond the\nreach of S/370 mode however, as the STSI parm regs R0 & R1 need\nto be 'grande' sized (64 bit); S/370 regs are obviously only 32 bit.\nThe HERC macro generates a DIAGNOSE instruction of various flavors.\n\nThis version should assemble OK with ASMF.  There are some \"extra\"\nmacros which I hope to get working later.  In particular, the\nIM#INSTR macro I mentioned on H390-MVS isn't ready.  The sublist\nmacros IM#SUBL, IM#SPLIT aren't tested and are probably only needed\nfor ASMF; such nonsense isn't necessary for higher level assemblers.\nIM#IGEN & IM#IGENF are internal to IM#INSTR (as I recall), and aren't\nneeded for this version.  Sam's been patient enough, so I'm leaving\nthem ASIS for now.\n\n\n\n0003 - 2001/09/05\n-----------------\n\nChanged from custom License to Q Public License version                 1.0.\n\nIncludes new Debug facility.\n\nRepackaged to build from source or XMIT.\n\n\n\n0002 - 2001/06/13\n-----------------\n\nClem Clarke was the only one who got this version.\n\nThe source code was converted from HLASM to ASM-F using the Rexx execs\n(supplied only in previous versions, there's probably a copy of them\nstill lying around at ftp://ensose.com/mvs38j), which did about 75% of\nthe work converting the assembler source code & macros.  Deemed\nnecessary so that Hercules MVS38j users can play along.\n\nRepair bug in XMITPUT which would ABENDS0C4 for some of Clem's JOL\nfiles.\n\n\n\n0001 - 2001/04/07\n-----------------\n\nRedistributed version 00.00 with source\n\nAdded directories for asm, jcl, list, mac and obj\n\n\n\n0000 - 2001/02/26\n-----------------\n\nInitial distribution\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$COPY": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "XV0006"}, "text": "\n Copyright 2001-2008 James M. Morrison\n\n The contents of this PDS/archive are\n\n Copyright 2001-2008 James M. Morrison\n\n with the exception of the following, which are public domain:\n IHADECB, IHADQE, IHADVCT, IHAPQE, IHARTCT, IHASNP, IHASVC.\n\n All the non-public domain materials included in this PDS/archive is\n released under the provisions of the Q Public License version 1.0.\n\n Refer to the LICENSE member for the license details.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$DAST": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00!\\x00!\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "XV0006"}, "text": "\nCopyright 2002, James M. Morrison\n\n                             DAST370\n                             -------\n\nOverview\n--------\n\nDAST370 is a toy application I used to experiment with the S/370\nDual Address Space (DAS) feature under Hercules.\n\nCurrently, all it does is run the ASVT and display the ASCBs and\nASXBs.\n\nNote that MVS38j never supported DAS, but if you're willing to either\ninstall some MVS mods or modify the system's control registers\nyourself, it's \"usable\".  As of this writing, no such MVS mods exist\nbut similar modifications will have to be written to support the\nLIB390 project, so it's likely DAS support will be included in\nthat effort.\n\nMembers specific to DAST370:\nDAST#BUG - Debug bytes for inclusion in WATGD\nDASTMVCP - performs block moves from another address space usng MVCP\nDASTVTAB - VCON table\nDAST370  - ID=MAIN, driver\nJDAST    - JCL to run DAST370\nJDASTALL - Build only DAST370 application\nJDAST1   - Assemble & link only one DAST370 CSECT\nKBUGDAST - DASTDBUG control statements\nKLNKDAST - Linkage editor control statements to build DAST370\nWADAST   - Common workarea, includes WATGD embedded at front\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$HERC": {"ttr": 533, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x13\\x00\\x13\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "XV0006"}, "text": "\nCopyright 2002, James M. Morrison\n\n\nHercules emulator\n-----------------\n\nHercules is a QPL'd project initially written by Roger Bowler,\ncurrently maintained by Jay Maynard, with major contributions by\na long list of fine souls including such luminaries as\nJan Jaeger, Greg Smith, and David Trout (Fish) to name but a few.\n\nFor further information on Hercules, see the following\nweb sites, particularly the Bookmarks section of the Hercules\nYahoo web site:\n\n    http://groups.yahoo.com/group/hercules-390\n    http://www.conmicro.cx/hercules/\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$INSTALL": {"ttr": 535, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00I\\x01\\x08\\x10/\\x01\\x08\\x10/\\x004\\x00T\\x00T\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-04-11T00:00:00", "modifydate": "2008-04-11T00:34:49", "lines": 84, "newlines": 84, "modlines": 0, "user": "XV0006"}, "text": "\nCopyright 2001-2008 James M. Morrison\n\n                xxxx370\n\n                Version 00.06           April 9, 2008\n\nFor Copyright assertions and licensing details, refer to the\n$COPY member.\n\n\n                Introduction\n                ------------\n\nWelcome to xxxx370.  This is the $INSTALL file, which describes the\ninstallation of the xxxx370 programs.\n\nAll xxxx370 programs require APF authorization.\n\nNote for experienced systems programmers: please excuse my long\nexplanations, some portions of my target audience are just getting\nstarted, and are possibly running MVS versions as old as MVS38j.\nQuick install instructions: run JINSTALL, review the individual\nprogram's documentation members ($DAST, $RECV, $STCP, $XMIT).\n\n                Overview\n                --------\n\nThe xxxx370 programs are designed for execution under MVS 3.8J, running\nunder the Hercules emulator.  For a list of the xxxx370 applications\nand their function, see the $INTRO member.\n\n\n                Installation\n                ------------\n\nIf you're reading this, you've already figured out how to extract\nthe source code, JCL, and documentation from the archive, and\nused TSO/E RECEIVE, or some work-alike facility to re-create the\nPDS.  Not much else to do.\n\nJINSTALL\n--------\n\nNote: JINSTALL builds all the included applications:\nDAST370, RECV370, XMIT370.\n\nModify the JINSTALL job as required for your shop.  In particular,\ndon't forget to change the LINK step SYSLMOD dataset.  The xxxx370\nprograms must be run from an APF authorized load module.\nThe SYS2.LOCAL.LINKLIB is what I use on my home MVS38j system.\n\nIf you're new to the systems programming game, you may need to review\nand/or modify your SYS1.PARMLIB(IEAAPFxx) or SYS1.PARMLIB(PROGxx)\nmembers, depending on your release of MVS.  More recent versions of\nMVS allow PARMLIB datasets which aren't named SYS1.PARMLIB.  If you\naren't sure what you're doing, ask someone for help.  Messing up\nPARMLIB members on a production system would be a Very Bad Thing.\n\nThe job steps are:\n\n        DELETE          Delete SYS2.xxxx370.*\n        ALLOC           Allocate SYS2.xxxx370.*\n        DAST....        Assemble DAST.... source\n        RECV....        Assemble RECV.... source\n        U370....        Assemble U370.... source\n        XMIT....        Assemble XMIT.... source\n        LINK            Linkage edit xxxx370 applications\n\nThere's nothing special about using the ASMF assembler (IFOX00),\nit's just what comes with MVS38j.  Replace with your preference of\n(more capable) assembler at will.\n\nOnce you have modified JINSTALL, submit it.  All steps should get\nRC=0, with the possible exception of the DELETE step which might get\nRC=8, and the LINK step which will probably get rc=4.\n\nThe target load library may be in the linklist, and must be an\nAPF authorized dataset.\n\nThis concludes the installation of xxxx370.\nGood luck and enjoy!\n\nJim Morrison     n9gtm@comcast.net\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$INTRO": {"ttr": 770, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00\\x13\\x00\\x13\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "XV0006"}, "text": "\nCopyright 2001-2008 James M. Morrison\n\n                xxxx370 Applications\n\n                Version 00.06           April 9, 2008\n\nBeginning with version 00.04, this PDS contains multiple applications.\nThe applications and the name of their introductory doc member are\nlisted below, in approximately the order they were written:\n\n    XMIT370    $XMIT    Create TRANSMIT (XMIT, XMI) file\n    RECV370    $RECV    Recreate file from XMIT input\n    DAST370    $DAST    Toy application to play with Dual Address Space\n\nCommon utility functions:\n\n    U370xxxx   $UTIL    Service routines\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$MVS38J": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x10\\x00\\x10\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "XV0006"}, "text": "\nCopyright 2002, James M. Morrison\n\n\nMVS 3.8 J\n---------\n\nMVS38j is an early version of IBM's MVS operating system, which is\nbelieved to be in the public domain, and thus unemcumbered by\nlicensing restrictions.\n\nFor further information on MVS38j, see the following Yahoo\ncommunities, particularly the Bookmarks sections of:\n\n    http://groups.yahoo.com/group/H390-MVS\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$OLDF571": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x106$`$`\\x00\\x00\\xd6\\xd3\\xc4\\xc6\\xc9\\xd3\\xc5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:36:00", "lines": 9312, "newlines": 9312, "modlines": 0, "user": "OLDFILE"}, "text": "./ ADD NAME=$$$#DATE 0100-02182-02182-0746-00012-00012-00000-SHIPDAT\nREGULAR CBT TAPE - VERSION 448    FILE:  571\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT448.FILE571\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    3200    PO\n\n   PDS117I 89 MEMBERS COUNTED; CUMULATIVE SIZE IS 9,223 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   07/01/02    07:46:54    GMT-5:00\n\n./ ADD NAME=$$$NOTE1 0100-02182-02182-0745-00033-00033-00000-SBGOLOB\nHi Sam,\n\nThanks for the kind thoughts.  I'm trying to take it easy,\nbut I'm afraid I'm not very good at it <g>.\n\nFind attached v0004 of XMIT370/RECV370.  It's a zipped AWS of an\nIEBCOPY unload of SYS2.XMIT370.ASM (the sole dataset) on a 3380.\nPlease let me know if you have any problems with restoring it.\n\nNow, as to what's in it ... see the $* members in the PDS.  At\nthis stage of the game, I've not got MVS/ESA RECEIVE working with\na modified COPYR1.  However, I supply RECV370 which will take the\nexact same XMIT that MVS/ESA RECEIVE complains about, unwrap the\nIEBCOPY unloaded data, and reload the unloaded PDS by calling\nIEBCOPY.  Too strange.  Confused am I.\n\nThe symptom is exactly the same as before the COPYR1 mod.  I've\nverified that the COPYR1 record looks good, but it's wildly different\nthan what IEBCOPY displays as the COPYR1 record.  Something else is\nafoot than just the COPYR1 record, I fear.  There are some notes\nabout this in $NOTES.  I have no particularly strong opinions as to\nwhat's wrong at this point, so I'm sending you what I have ASIS.\n From what I can tell, the COPYR1 record looks good.  Fortunately,\nwith RECV370 it's now possible to unwrap an XMIT and display detailed\nkey/value pairs pretty easily, so that's my next step.\n\nRECV370 functions fairly well, but has only received light testing.\nIn the doc, I say RECV370 isn't \"officially\" in this version, but\nit's there for those who want to take a crack at it.\n\nBest wishes,\nJim\n\n./ ADD NAME=$CHANGES 0101-02182-02182-0707-00105-00105-00000-XMIT370\nCopyright 2001, 2002 James M. Morrison\n\nChange log\n\n\n\n0004 - 2002/06/13\n-----------------\n\nFirst version to be contributed to the CBT tape.  Sam G gently prodded\nme, and I finally did it.  See also\n\n    http://ensose.com/mvs38j.html\n\nfor possibly more recent versions (in case I forget to send them to\nSam), and some other stuff for MVS38j - including\n\n    MVS38j 3375/3380/3390 support,\n    RECV390,\n    and some Hercules user tools like rdrprep, dasdseq.\n\nReally curious persons are free to check the mvs38j directory on that\nmachine for who-knows-what bits du-jour).  Most likely, I've said\nsomething about those bits in the H390-MVS or hercules-390 groups\n(currently hosted at Yahoogroups.com).\n\nAddition of COPYR1 feature, which allows minor customization of the\nIEBCOPY COPYR1 record for unloaded PDSs.  IEBCOPY is rumored to have\nhad variously sized COPYR1 records throughout it's history, this is\nintended to create XMITs targeted for environments which have IEBCOPY\nversions that don't understand differently sized COPYR1s.\n\nAnnoying XMITDBUG open fail message no longer appears; UTILTIOT used\nto scan TIOT before open attempted\n\nRenamed many macros, asm source code, jcl to permit distribution of\none library for CBT distribution ease.\n\nObservant readers may note references to RECV370; it's not officially\nin this version, but the code's there for the brave.  You'll likely\nneed it if you plan on receiving the XMITs created by XMIT370 with\nsomething besides dasdload or RECV390.  That wasn't the plan, but\ntesting has revealed some interesting TSO/E RECEIVE/IEBCOPY behaviors\nI wasn't counting on.  See $NOTES for further details.\n\nUTILABND needs more work; the STSI technique for identifying Hercules\nwas recently (2002/06/19) decided, and this version of XMIT370 does\nnothing in particular with it.  STSI is now a valid instruction\nin S/370 mode under Hercules.  Getting the SYSIB seems beyond the\nreach of S/370 mode however, as the STSI parm regs R0 & R1 need\nto be 'grande' sized (64 bit); S/370 regs are obviously only 32 bit.\nThe HERC macro generates a DIAGNOSE instruction of various flavors.\n\nThis version should assemble OK with ASMF.  There are some \"extra\"\nmacros which I hope to get working later.  In particular, the\nIM#INSTR macro I mentioned on H390-MVS isn't ready.  The sublist\nmacros IM#SUBL, IM#SPLIT aren't tested and are probably only needed\nfor ASMF; such nonsense isn't necessary for higher level assemblers.\nIM#IGEN & IM#IGENF are internal to IM#INSTR (as I recall), and aren't\nneeded for this version.  Sam's been patient enough, so I'm leaving\nthem ASIS for now.\n\n\n\n0003 - 2001/09/05\n-----------------\n\nChanged from custom License to Q Public License version                 1.0.\n\nIncludes new Debug facility.\n\nRepackaged to build from source or XMIT.\n\n\n\n0002 - 2001/06/13\n-----------------\n\nClem Clarke was the only one who got this version.\n\nThe source code was converted from HLASM to ASM-F using the Rexx execs\n(supplied only in previous versions, there's probably a copy of them\nstill lying around at ftp://ensose.com/mvs38j), which did about 75% of\nthe work converting the assembler source code & macros.  Deemed\nnecessary so that Hercules MVS38j users can play along.\n\nRepair bug in XMITPUT which would ABENDS0C4 for some of Clem's JOL\nfiles.\n\n\n\n0001 - 2001/04/07\n-----------------\n\nRedistributed version 00.00 with source\n\nAdded directories for asm, jcl, list, mac and obj\n\n\n\n0000 - 2001/02/26\n-----------------\n\nInitial distribution\n\n./ ADD NAME=$COPY    0100-02182-02182-0701-00013-00013-00000-XMIT370\n\n Copyright 2001, 2002 James M. Morrison\n\n The contents of this PDS/archive are\n Copyright 2001, 2002 James M. Morrison\n with the exception of the IHADECB and IHADVCT macros,\n which are public domain.\n\n XMIT370/RECV370 is released under the provisions of the\n Q Public License version 1.0.\n\n Refer to the LICENSE member for the license details.\n\n./ ADD NAME=$INTRO   0100-02182-02182-0701-00174-00174-00000-XMIT370\n\nCopyright 2001, 2002 James M. Morrison\n\n                XMIT370\n\n                Version 00.04           June 13, 2002\n\nThe XMIT370/RECV370 source code and executables are\nCopyright 2001, 2002  James M. Morrison.\n\nXMIT370/RECV370 is released under the provisions of the\nQ Public License version 1.0.\nRefer to the LICENSE member for the license details.\n\nSorry, I had to crunch the HTML up to get it to fit in LRECL=80.\nCheck http://www.trolltech.com/developer/licensing/qpl.html which\nis probably the same thing.\n\n\n\n                Introduction\n                ------------\n\nWelcome to XMIT370.  This is the $INTRO file, which describes the       zip,\ninstallation and execution of the XMIT370 program.\n\nXMIT370 requires APF authorization.\n\nNote for experienced systems programmers: please excuse my long\nexplanations, some portions of my target audience are just getting\nstarted, and are possibly running MVS versions as old as MVS38j.\nQuick install instructions: run JINSTALL, jump to DEMO section.\n\n                Overview\n                --------\n\nXMIT370 is a program for execution under MVS 3.8J, which provides\nfacilities similar to the TSO/E TRANSMIT command processor.\nAs opportunities present themselves, I'm testing it under other\nversions of MVS.\n\nXMIT370 will, given a DSORG=PO or DSORG=PS dataset as input, produce\nan XMIT file as output.\n\nThe resulting XMIT dataset can be processed using the TSO/E RECEIVE\ncommand processor, Hercules dasdload (for DSORG=PO datasets), my\nRECV390 program (for DSORG=PO datasets), or any of the other UnXmit\nprograms as detailed at http://planetmvs.com on the UnXmit Information\nExchange page.\n\n\n                Installation\n                ------------\n\nIf you're reading this, you've already figured out how to extract\nthe source code, JCL, and documentation from the archive, and\nused TSO/E RECEIVE, or some work-alike facility to re-create the\nPDS.  Not much else to do.\n\nJINSTALL\n--------\n\nModify the JINSTALL job as required for your shop.  In particular,\ndon't forget to change the LINK step SYSLMOD dataset.  XMIT370 must\neventually end up in an APF authorized dataset before it will run.\nThe SYS2.LOCAL.LINKLIB is what I use on my home MVS38j system.\n\nIf you're new to the systems programming game, you may need to review\nand/or modify your SYS1.PARMLIB(IEAAPFxx) or SYS1.PARMLIB(PROGxx)\nmembers, depending on your release of MVS.  More recent versions of\nMVS allow PARMLIB datasets which aren't named SYS1.PARMLIB.  If you\naren't sure what you're doing, ask someone for help.\n\nThe following libraries are created:\n\n        SYS2.XMIT370.LIST\n        SYS2.XMIT370.OBJ\n\nThe job steps are:\n\n        DELETE          Delete SYS2.XMIT370.*\n        ALLOC           Allocate SYS2.XMIT370.*\n        UTILxxxx        Assemble UTILxxxx source\n        XMITxxxx        Assemble XMITxxxx source\n        LINK            Linkage edit XMIT370\n\nThere's nothing special about using the ASMF assembler (IFOX00),\nit's just what comes with MVS38j.  Replace with your preference of\nassembler at will.\n\nOnce you have modified JINSTALL, submit it.  All steps should get\nRC=0, with the possible exception of the DELETE step which might get\nRC=8.\n\nThe target load library may be in the linklist, and must be an\nAPF authorized dataset.\n\nThat concludes the installation of XMIT370.\n\n\n                Demonstration JCL\n                -----------------\n\nJDEMOPDS        Create XMIT from partitioned dataset (PDS; DSORG=PO)\nJDEMOSEQ        Create XMIT from sequential dataset (DSORG=PS)\n\n\n                XMIT370 JCL\n                -----------\n\nXMIT370 is a batch program, and requires APF authorization.\n\nXMIT370 DDNAMEs:\n----------------\n\n        SYSPRINT        IEBCOPY output messages (required for DSORG=PO\n                        input datasets on SYSUT1)\n\n        XMITPRT         XMIT370 output messages (required)\n\n        SYSUT1          input dataset to be XMIT370'd (required)\n\n        SYSUT2          work dataset for IEBCOPY for DSORG=PO datasets;\n                        should be large enough to contain SYSUT1\n                        plus a little more (required for SYSUT1\n                        DSORG=PO).\n                        Temporary dataset deleted at end of step is OK.\n\n        XMITOUT         XMIT370 output XMIT dataset (required)\n                        Any DCB attributes you specify are currently\n                        ignored.\n                        Should be large enough to contain SYSUT1\n                        plus some more for the XMIT370 \"wrapper\" and\n                        any IEBCOPY overhead data (10 - 20% more\n                        should be sufficient).\n\n        SYSIN           IEBCOPY input dataset (required for SYSUT1\n                        DSORG=PO datasets).\n                        A DUMMY dataset.\n\n        XMITDBUG        Optional, specifies debugging options.\n\nHercules users:\n\n   For input datasets of DSORG=PO, you can use the Hercules dasdload\n   program to restore the PDS to a dasd volume.\n\n   You can also use the dasdpdsu program to extract the members from a\n   PDS on Hercules dasd.\n\nXMIT370 only supports input datasets of DSORG=PO and DSORG=PS.\nI have concentrated most of my testing on RECFM=FB input datasets.\n\nXMIT370 PARM=\n-------------\n\nXMIT370 accepts a one character PARM=x specification, which specifies\nincreasing levels of diagnostic verbosity.  The current definitions of\n\"x\" are:\n\n        0       normal messages (default if no PARM specified)\n        1       status messages, primarily CSECT entry and exit messages\n        2       internal CSECT status messages\n        3+      dump debug areas, can be lots of data for large input datasets\n\nFor more exotic debugging, review the UTILDBUG source code and see the\nJDEBUG job, which points XMITDBUG at SYS2.XMIT370.ASM(KDEBUG).\n\n\nThat's it.  Good luck and enjoy!\n\nJim Morrison     jmorrison@ameritech.net\n                 jmm@ensose.com\n\n./ ADD NAME=$NOTES   0100-02182-02182-0701-00057-00057-00000-XMIT370\n\nDuring testing, I tried to receive the created XMIT files on as\nmany different environments as possible.  Special thanks to those\nkind souls who helped test various MVS environents.\n\n\nHercules 2.16.2 dasdload\n------------------------\n\nworks fine, with and without modification to COPYR1 record\n\n\nRECV390 v1r1m5 (not released, I'm still working on it)\n--------------\n\nworks fine, with and without modification to COPYR1 record\n\n\nMVS38j RECV370\n--------------\n\nJINSTALL - install XMIT370 & RECV370\nJXMIT    - create XMIT without modifying COPYR1 record\nJXMITC   - create XMIT with COPYR1 modification\nJRECV    - receive XMIT files created above\n\nworks fine, with or without modifications to COPYR1 record\n\n\nMVS/ESA TSO/E RECEIVE\n---------------------\n\nInteresting behavior demonstrated by IEBCOPY, which complains that\nthe COPYR1 length is invalid.  The COPYR1 that IEBCOPY displays\nlooks nothing like the COPYR1 in the XMIT, which I verified by\nrunning RECV370 which spins out a SYSUT1 file that I Full-Screen\nZapped.  An intended side-effect of running RECV370 is that it\nsimply unwraps the XMIT and places it on the SYSUT1 ddname.  That\nit actually calls IEBCOPY is merely a happy coincidence.  ;-) What is\ncausing this behavior, I can't exactly say at this point and time.\nI have a mild suspicion that there's a problem with the segments:\neither a key that RECEIVE doesn't understand, or possibly a\nconstruction error.  Unfortunately, I had very limited time on this\nsystem, so it is as yet undetermined.  However, as time becomes\navailable, I'll keep pluggin away at it.  If someone has spare cycles\non an Internet-connected MVS/ESA system I can use to further test,\nI'd be very happy to hear from you (jmorrison@ameritech.net).\n\nI'd like all of XMIT370's XMITs to RECEIVE properly under MVS/ESA,\nbut as of right now that's not the case.  If your version of IEBCOPY\ncan cope with MVS38j IEBCOPY's COPYR1 record, you're golden.\n\nTo the extent that RECV370 works, it acts as a decent substitute\nfor TSO/E RECEIVE on MVS/ESA so all is not lost.  The very same XMIT\nthat TSO/E RECEIVE/IEBCOPY complained about received fine with RECV370.\nI'm sure that's a clue of some kind.\n\n./ ADD NAME=$README  0100-02182-02182-0701-00027-00027-00000-XMIT370\n\nCopyright 2001, 2002 James M. Morrison\n\nWelcome to XMIT370 v0004\n\nFor an introduction to XMIT370, see the $INTRO   member.\nFor the copyright claims,       see the $COPY    member.\nFor the change log,             see the $CHANGES member.\nFor miscellaneous notes,        see the $NOTES   member.\n\nMember Naming Conventions\n-----------------------------------------------------------------------\n\nMEMBER   Contents\n\n$....... Commentary\nD....... DSECT macros\nIM#..... inner macros\nJ....... JCL\nK....... Control cards\nLICENSE  Q Public License version 1.0, modified to fit LRECL=80\nRECV.... RECV370 CSECTs (incomplete, may not be present)\nUTIL.... Utility CSECTs\nU....... Utility macros\nWA...... Work Areas DSECT macros\nXMIT.... XMIT370 CSECTs\n\n./ ADD NAME=@FILE571 0101-01025-02182-0715-00018-00002-00000-SBGOLOB\n//***FILE 571 is from Jim Morrison, and contains XMIT370 and        *   FILE 571\n//*           RECV370.  These are tools to create and handle        *   FILE 571\n//*           XMIT-format pds files (which are FB-80 sequential     *   FILE 571\n//*           files) on MVS systems (such as MVS 3.8) which do      *   FILE 571\n//*           not contain the TSO XMIT and RECEIVE commands.        *   FILE 571\n//*                                                                 *   FILE 571\n//*           XMIT and RECEIVE were first shipped with TSO/E,       *   FILE 571\n//*           so any pre-TSO/E TSO releases, probably do not have   *   FILE 571\n//*           the XMIT and RECEIVE capabilities.                    *   FILE 571\n//*                                                                 *   FILE 571\n//*           These tools are batch programs, and are not TSO       *   FILE 571\n//*           commands, as are the TSO/E XMIT and RECEIVE programs. *   FILE 571\n//*                                                                 *   FILE 571\n//*           These programs were created so that Hercules MVS 3.8  *   FILE 571\n//*           users, can handle XMIT-format sequentialized pds'es.  *   FILE 571\n//*                                                                 *   FILE 571\n//*         email:  Jim Morrison <jmorrison@ameritech.net>          *   FILE 571\n//*                                                                 *   FILE 571\n./ ADD NAME=DCOPYR1  0100-02182-02182-0701-00063-00063-00000-XMIT370\n         MACRO\n         DCOPYR1 &BDW=NO,&RDW=NO\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n.* See MVS38j IEBLDUL source for COPYR1 definition (PL/S).\n.*\n*----------------------------------------------------------------------\n*  IEBCOPY unloaded dataset; COPYR1 record\n*----------------------------------------------------------------------\nCOPYR1   DSECT ,                       WORD aligned\n         AIF   ('&BDW' EQ 'NO').NOBDW\nXC1BDW   DS    XL4                 block descriptor word\n.NOBDW   AIF   ('&RDW' EQ 'NO').NORDW\nXC1RDW   DS    XL4                 record descriptor word\n.NORDW   ANOP\n*\nXC1INDC  DS    XL1                 flags\nXC1IFMT  EQU   X'C0'               unload info mask\nXC1IUERR EQU   X'80'               unload error\nXC1IFOLD EQU   X'00'               unload format=old\nXC1IFPDE EQU   X'40'               unload format=PDS/E\nXC1IFXFR EQU   X'C0'               unload format=transfer\nXC1IFPGM EQU   X'10'               contains program\nXC1IFCPE EQU   X'01'               contains PDS/E\n*\nXC1ID    DS    XL3                 header id x'CA6D0F'\nXC1DSORG DS    XL2                 DSORG\nXC1BLKSZ DS    XL2                 BLKSIZE\nXC1LRECL DS    XL2                 LRECL\nXC1RECFM DS    XL1                 RECFM\nXC1KEYLN DS    XL1                 KEY length\nXC1OPTCD DS    XL1                 OPTCD\nXC1SMSFG DS    XL1                 reserved in MVS38j\nXC1TBLKS DS    XL2                 unloaded blksize\n*\n*  Devicetype info\n*\nXC1DEVT  DS    0XL20\nXC1UCBT  DS    XL4                 UCB.UCBTYP\nXC1UMBLK DS    XL4                 unit max blksize\nXC1UCYLS DS    XL2                 unit # cyls\nXC1UHEAD DS    XL2                 unit # trks/cyl\nXC1UTRKL DS    XL2                 unit track length\nXC1UBOVH DS    XL2                 unit block overhead\nXC1UKOVH DS    XL1                 unit keyed blk ovhd\nXC1UFLGS DS    XL1                 flags\nXC1UTOLF DS    XL2                 unit tolerance factor\n*\n*  Following fields reserved in MVS38j\n*\nXC138RSV DS    0XL16\nL$XC138  EQU   (*+16)-COPYR1\nXC1HDRCT DS    XL2                 header count; when 0, =2.\nXC1RESV1 DS    XL1                 reserved\nXC1LREFD DS    XL3                 last referenced date\nXC1SCEXT DS    XL3                 secondary extent\nXC1SCALO DS    XL4                 secondary allocation\nXC1LSTAR DS    XL3                 last used trk/rec\nXC1TRBAL DS    XL2                 track balance\nXC1RESV2 DS    XL2                 reserved\nL$XC1CUR EQU   *-COPYR1            currently known length\n         MEND\n./ ADD NAME=DRCS2    0100-02182-02182-0701-00036-00036-00000-XMIT370\n         MACRO\n         DRCS2 ,\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n*----------------------------------------------------------------------\n*  Control Segment INMR02 saved data\n*----------------------------------------------------------------------\nCS2      DSECT ,\nCS2#FILE DS    F             # files in XMIT file\n*\n*  This area is based on the assumption that all CLVH values are\n*  four bytes or less.  They don't really have to be, I've just not\n*  seen them larger than that.  Like most assumptions, this will\n*  likely cause problems down the road. <sigh>\n*\n*  The field names correspond to keys named INM rather than CS2.\n*\nCS2BLKSZ DS    F\nCS2CREAT DS    F\nCS2DIR   DS    F\nCS2DSORG DS    F\nCS2EXPDT DS    F\nCS2FFM   DS    F\nCS2LCHG  DS    F\nCS2LRECL DS    F\nCS2LREF  DS    F\nCS2MEMBR DS    CL8\nCS2RECFM DS    F\nCS2SIZE  DS    F\nCS2TERM  DS    C\n         DS    CL7\nCS2UTILN DS    CL8\n         DS    0D\nL$CS2    EQU   *-CS2\n         MEND\n./ ADD NAME=DVTAB    0100-02182-02182-0701-00021-00021-00000-XMIT370\n         MACRO\n         DVTAB ,\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\nVTABLE   DSECT ,\n*----------------------------------------------------------------------\n*  CSECT table header - BXLE index, increment, limit\n*----------------------------------------------------------------------\nVTHDR    DS    0F,XL12\n         ORG   VTABLE\n*----------------------------------------------------------------------\n*  CSECT table\n*----------------------------------------------------------------------\nVTABNAME DS    CL8           CSECT name\nVTABVCON DS    A             address of CSECT\nVTABOFF  DS    H             offset to debug byte from XMTDLEV\nVTABRSV1 DS    H             unused/alignment\nL$VTAB   EQU   *-VTABLE      length of table entry\n         ORG   ,\n         MEND\n./ ADD NAME=DXMITSEG 0100-02182-02182-0701-00095-00095-00000-XMIT370\n         MACRO\n         DXMITSEG &SECT=DSECT\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n*----------------------------------------------------------------------\n*  XMIT segment\n*----------------------------------------------------------------------\nXMITSEG  IM#SECT &SECT                 XMIT SEGment\nSEG      DS    0XL255                  maximum segment length\nSEGL     DS    X                       length of segment (2 -255),\n*                                      including L'XPSEGL & L'XPSEGFLG\nSEGFLG   DS    X                       flag byte\nSEG$1    EQU   128                     first segment of original rec\nSEG$L    EQU   64                      last segment of original rec\nSEG$C    EQU   32                      (part of) control segment\nSEG$R    EQU   16                      rec # of next record\nSEG$XX   EQU   15                      reserved bits = 0\n*\nSEGBUF   DS    XL253                   maximum segment user data\n*\n*  Offsets for control segments\n*\nSEGCTLNM EQU   SEGBUF,6                c'INMR0x'\nSEGCKEYS EQU   SEGBUF+6                INMR0x beginning of keys\nSEGC2NUM EQU   SEGBUF+6,4              INMR02 # files\nSEGC2KEY EQU   SEGBUF+10               INMR02 keys begin here\n*\nSEGBND   EQU   *                       past end of segment data\n*\n*  Keys for network user identification (INMR01)\n*\nINMTNODE EQU   X'1001'       target node name\nINMTUID  EQU   X'1002'       target userid\nINMFNODE EQU   X'1011'       origin node name\nINMFUID  EQU   X'1012'       origin userid\nINMFVERS EQU   X'1023'       origin version number\nINMFTIME EQU   X'1024'       origin time stamp\nINMTTIME EQU   X'1025'       destination time stamp\nINMNUMF  EQU   X'102F'       number of files\n*\n* Keys for general use\n*\nINMFACK  EQU   X'1026'       acknowledgement request\nINMERRCD EQU   X'1027'       receive error code\nINMUTILN EQU   X'1028'       utility name\nINMUSERP EQU   X'1029'       user parm string\nINMRECCT EQU   X'102A'       transmitted record count\n*\n*  Keys for dataset specification\n*\nINMDDNAM EQU   X'0001'       DDNAME\nINMDSNAM EQU   X'0002'       DSN\nINMMEMBR EQU   X'0003'       member name\nINMSECND EQU   X'000B'       secondary space qty\nINMDIR   EQU   X'000C'       directory space qty\nINMEXPDT EQU   X'0022'       expiration date\nINMTERM  EQU   X'0028'       terminal alloc (msg)\nINMBLKSZ EQU   X'0030'       blocksize\nINMDSORG EQU   X'003C'       dsorg\nINMLRECL EQU   X'0042'       lrecl of physical segment records\nINMRECFM EQU   X'0049'       recfm\nINMLREF  EQU   X'1020'       last ref date\nINMLCHG  EQU   X'1021'       last chg date\nINMCREAT EQU   X'1022'       create date\nINMSIZE  EQU   X'102C'       primary space qty\nINMTYPE  EQU   X'8012'       data set type\n*\n*  I'm not sure about the spelling of the next field, so I specify both\n*\nINMFFM   EQU   X'102D'       Filemode number (CMS)\nINMFM    EQU   X'102D'       Filemode number (CMS)\n*\nL$SEG    EQU   *-XMITSEG     L'XMITSEG\n*\nL$CKEY   EQU   2                       length of control seg key\nL$CCOUNT EQU   2                       length of control seg count\nL$CLEN   EQU   2                       length of control seg length\n.*\n.*  Format of key data:\n.*\n.*  KEY     XL2   as above\n.*  LENGTH  XL2   length of following data\n.*  BINDATA XLn\n.*\n.*  KEY     XL2   as above\n.*  LENGTH  XL2   length of following data (flag, as in terminal alloc)\n.*\n.*  KEY     XL2      Dataset type field, dsname\n.*  COUNT   XL2\n.*  LENGTH  XL2\n.*  DATA    XLn\n.*  LENGTH  XL2\n.*  DATA    XL2, etc.\n         MEND\n./ ADD NAME=HERC     0100-02182-02182-0701-00054-00054-00000-XMIT370\n         MACRO\n&LABEL   HERC   &DIAG,&OPT\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n.*---------------------------------------------------------------------\n.* Function: Issue Diagnose code to Hercules emulator\n.*           See Hercules diagnose.c source code\n.* &DIAG   - Hercules diagnose code\n.* &OPT    - Options, for diagnose instructions that support it\n.*---------------------------------------------------------------------\n         GBLB  &G#HERC\n         AIF   (&G#HERC).GEN\n         MNOTE 2,'HERC macro detected lack of Hercules support'\n         MNOTE *,'HERC macro expansion suppressed'\n         MEXIT\n.*\n.GEN     AIF   (N'&OPT EQ 4).FOUR\n         AIF   (N'&OPT EQ 3).THREE\n         AIF   (N'&OPT EQ 2).TWO\n         AIF   (N'&OPT EQ 1).ONE\n         AIF   (N'&OPT EQ 0).NONE\n         MNOTE 2,'HERC macro OPT parse error'\n         MEXIT\n.*\n.*       X'83-ab-cc-dd'\n.*\n.FOUR    ANOP\n&LABEL   DC    AL1(131),A.4(&OPT(1),&OPT(2)),AL1(&OPT(3),&DIAG)    HERC\n         MEXIT\n.*\n.*       X'83-ab-cc-dd'\n.*\n.THREE   ANOP\n&LABEL   DC    AL1(131),A.4(&OPT(1),&OPT(2)),AL1(&OPT(3),&DIAG)    HERC\n         MEXIT\n.*\n.*       X'83-aa-dddd'\n.*\n.ONE     ANOP\n&LABEL   DC    AL1(131,&OPT),AL2(&DIAG)               HERCules diagnose\n         MEXIT\n.*\n.*       X'83-ab-dddd'\n.*\n.TWO     ANOP\n&LABEL   DC    AL1(131),AL1.4(&OPT(1),&OPT(2)),AL2(&DIAG) HERC diagnose\n         MEXIT\n.*\n.*       X'83-00-dddd'\n.*\n.NONE    ANOP\n&LABEL   DC    AL1(131,0),AL2(&DIAG)                  Hercules DIAGNOSE\n         MEND\n./ ADD NAME=IHADECB  0100-02182-02182-0701-00389-00389-00000-XMIT370\n         MACRO\n         IHADECB &DSECT=YES\n         AIF   ('&DSECT' EQ 'NO').NODSCT\nDECB     DSECT , -            DECBPTR\n         AGO   .CONT\n.NODSCT  ANOP\n         DS    0D\nDECB     EQU   * -            DECBPTR\n.CONT    ANOP  ,  */\n*%DECBL1 : ;\n*\n*/* **************************************************************** */\n*/*            DATA EVENT CONTROL BLOCKS FOR -                       */\n*/*            BSAM, BISAM, BDAM, QTAM, BTAM                         */\n*/*                                                                  */\n*/*  OS/VS2 RELEASE 3, OS/VS1 RELEASE 4, 08/30/74, LEVEL=1           */\n*/*                                                                  */\n*/*  METHOD OF ACCESS                                                */\n*/*      BAL  - DSECT IS PRODUCED UNLESS DSECT=NO IS SPECIFIED.      */\n*/*             USING ON DECB GIVES ADDRESSABILITY FOR ALL SYMBOLS.  */\n*/*      PL/S - DCL DECBPT PTR                                       */\n*/* **************************************************************** */\n*%GOTO DECBL2;  /*\n         SPACE 1\n         IEZBITS , -          SYMBOLIC BIT DEFINITIONS\n         SPACE 1\n***********************************************************************\n*              DATA EVENT CONTROL BLOCK FOR BSAM                      *\n***********************************************************************\n         SPACE 1\nDECSDECB DS    CL4 -          EVENT CONTROL BLOCK\nDECBPTR  DS    0A -           FOR IBM 1419 MAGNETIC CHARACTER READER\n*                             AND IBM 1275 OPTICAL READER SORTER, A\n*                             POINTER TO NEXT DECB TO BE TESTED FOR\n*                             COMPLETION BY THE CHECK MACRO\n*                             INSTRUCTION.  (DECB CHAINING APPLIES TO\n*                             THE USE OF MORE THAN ONE DEVICE.)  THIS\n*                             FIELD IN THE LAST DECB MUST BE ZERO.\nDECTYPE  DS    0BL2 -         TYPE OF I/O REQUEST\nDECTYPE1 DS    B -            TYPE OF LENGTH OPERAND\nDECLNS   EQU   BIT0 -         S CODED FOR LENGTH\nDECRSV01 EQU   BIT1,,C'X' -   RESERVED\nDECRSV02 EQU   BIT2,,C'X' -   RESERVED\nDECRSV03 EQU   BIT3,,C'X' -   RESERVED\nDECRSV04 EQU   BIT4,,C'X' -   RESERVED\nDECRSV05 EQU   BIT5,,C'X' -   RESERVED\nDECRSV06 EQU   BIT6,,C'X' -   RESERVED\nDECRSV07 EQU   BIT7,,C'X' -   RESERVED\nDECTYPE2 DS    B -            TYPE OF OPERATION\nDECRDSF  EQU   BIT0 -         READ SF\nDECRDSB  EQU   BIT1 -         READ SB\nDECWRSF  EQU   BIT2 -         WRITE SF\nDECWRSD  EQU   BIT3 -         WRITE SD\nDECRSV08 EQU   BIT4,,C'X' -   RESERVED\nDECWRSZ  EQU   BIT5 -         WRITE SZ\nDECRSV09 EQU   BIT6,,C'X' -   RESERVED\nDECWRSFR EQU   BIT7 -         WRITE SFR (BIT 2 IS ALSO ON) OR\n*                             READ RBL (BIT 0 IS ALSO ON)        MDC004\nDECLNGTH DS    H -            LENGTH OF KEY AND DATA\nDECDCBAD DS    A -            ADDRESS OF THE DCB TO WHICH THIS I/O\n*                             REQUEST IS RELATED\nDECAREA  DS    A -            ADDRESS OF KEY AND DATA, OR FOR 1287 OR\n*                             1288 OPTICAL READERS, THE ADDRESS OF A\n*                             USER-SPECIFIED CHANNEL PROGRAM\nDECIOBPT DS    A -            ADDRESS OF THE IOB\nDECNEXT  DS    0A -           SAME AS DECNEXTA BELOW\nDECRSV10 DS    X -            RESERVED\nDECNEXTA DS    AL3 -          ADDRESS OF THE NEXT ADDRESS FEEDBACK\n*                             FIELD.  PRESENT ONLY IF R IS CODED IN\n*                             THE WRITE MACRO.\n         SPACE 2\n         ORG   DECNEXT -      FOR 3886 ONLY, DEVICE DEPENDENT FIELDS\nDECBHDRA DS    A -            FOR READ RBL, ADDRESS OF 3886 DATA\n*                             HEADER RECORD AFTER READ           MDC001\nDECBLNNM DS    A -            FOR READ RBL, ADDRESS OF LINE NUMBER OR\n*                             NEGATIVE OF LINE NUMBER            MDC002\nDECBLFMT DS    A -            FOR READ RBL, ADDRESS OF LINE FORMAT\n*                             NUMBER OR NEGATIVE OF LINE FORMAT\n*                             NUMBER                             MDC003\n         SPACE 2\n***********************************************************************\n*              DATA EVENT CONTROL BLOCK FOR BISAM                     *\n***********************************************************************\n         SPACE 1\n         ORG   DECB\nDECBECB  DS    0CL4 -         EVENT CONTROL BLOCK\nDECBRB   DS    0A -           SAME AS DECBRBA BELOW\nDECBECBF DS    B -            FLAG FIELD\nDECBWAIT EQU   BIT0 -         AWAITING COMPLETION OF EVENT\nDECBPOST EQU   BIT1 -         EVENT HAS COMPLETED NORMALLY OR\n*                             ABNORMALLY.  IF THE EVENT COMPLETED\n*                             ABNORMALLY, FIELDS DECBEXC1 AND DECBEXC2\n*                             WILL SHOW THE REASON.\nDECRSV11 EQU   BIT2,,C'X' -   RESERVED\nDECRSV12 EQU   BIT3,,C'X' -   RESERVED\nDECRSV13 EQU   BIT4,,C'X' -   RESERVED\nDECRSV14 EQU   BIT5,,C'X' -   RESERVED\nDECRSV15 EQU   BIT6,,C'X' -   RESERVED\nDECRSV16 EQU   BIT7,,C'X' -   RESERVED\nDECBRBA  DS    AL3 -          ADDRESS OF THE RB FOR THE PROGRAM\n*                             AWAITING EVENT (BEFORE EVENT COMPLETION)\n*                             OR RESERVED (AFTER EVENT COMPLETION)\nDECBTYP1 DS    B -            OPTION BYTE\nDECRSV17 EQU   BIT0,,C'X' -   RESERVED\nDECRSV18 EQU   BIT1,,C'X' -   RESERVED\nDECRSV19 EQU   BIT2,,C'X' -   RESERVED\nDECRSV20 EQU   BIT3,,C'X' -   RESERVED\nDECRSV21 EQU   BIT4,,C'X' -   RESERVED\nDECRSV22 EQU   BIT5,,C'X' -   RESERVED\nDECBLNS  EQU   BIT6 -         LENGTH CODED AS 'S'\nDECBARS  EQU   BIT7 -         AREA CODED AS 'S'\nDECBTYP2 DS    B -            TYPE OF I/O REQUEST\nDECBRDK  EQU   BIT0 -         READ K\nDECRSV23 EQU   BIT1,,C'X' -   RESERVED\nDECBRDKU EQU   BIT2 -         READ KU\nDECRSV24 EQU   BIT3,,C'X' -   RESERVED\nDECBWRK  EQU   BIT4 -         WRITE K\nDECBWRKN EQU   BIT5 -         WRITE KN\nDECRSV25 EQU   BIT6,,C'X' -   RESERVED\nDECRSV26 EQU   BIT7,,C'X' -   RESERVED\nDECBLGTH DS    H -            NUMBER OF BYTES READ OR WRITTEN\nDECBDCBA DS    A -            ADDRESS OF THE DATA CONTROL BLOCK\nDECBAREA DS    A -            ADDRESS OF THE AREA IN STORAGE FOR THE\n*                             RECORD\nDECBLOGR DS    A -            ADDRESS OF THE LOGICAL RECORD\nDECBKEY  DS    A -            ADDRESS OF THE KEY PORTION OF THE RECORD\nDECBEXC1 DS    B -            EXCEPTIONAL CONDITION CODE BYTE 1\nDECEXRNF EQU   BIT0 -         RECORD NOT FOUND\nDECEXRLC EQU   BIT1 -         RECORD LENGTH CHECK\nDECEXNSP EQU   BIT2 -         SPACE NOT FOUND IN WHICH TO ADD A RECORD\nDECEXINV EQU   BIT3 -         INVALID REQUEST\nDECEXERR EQU   BIT4 -         UNCORRECTABLE I/O ERROR\nDECEXUBK EQU   BIT5 -         UNREACHABLE BLOCK\nDECEXOFL EQU   BIT6 -         OVERFLOW RECORD\nDECEXDUP EQU   BIT7 -         DUPLICATE RECORD PRESENTED FOR INCLUSION\n*                             IN THE DATA SET\nDECBEXC2 DS    B -            EXCEPTIONAL CONDITION CODE BYTE 2\nDECRSV27 EQU   BIT0,,C'X' -   RESERVED\nDECRSV28 EQU   BIT1,,C'X' -   RESERVED\nDECRSV29 EQU   BIT2,,C'X' -   RESERVED\nDECRSV30 EQU   BIT3,,C'X' -   RESERVED\nDECRSV31 EQU   BIT4,,C'X' -   RESERVED\nDECRSV32 EQU   BIT5,,C'X' -   RESERVED\nDECEXASR EQU   BIT6 -         EXECUTION OF THE LAST CHANNEL PROGRAM WAS\n*                             INSTITUTED BY AN ASYNCHRONOUS ROUTINE\nDECEXRKU EQU   BIT7 -         PREVIOUS MACRO INSTRUCTION WAS READ KU\n         SPACE 2\n***********************************************************************\n*              DATA EVENT CONTROL BLOCK FOR BDAM                      *\n***********************************************************************\n         SPACE 1\n         ORG   DECB\n         DS    0CL4 -         DECSDECB - EVENT CONTROL BLOCK\n         DS    B -            COMPLETION CODE BYTE 1\nDECCC2   DS    B -            COMPLETION CODE BYTE 2\nDECCCRNF EQU   BIT0 -         RECORD NOT FOUND\nDECCCRLC EQU   BIT1 -         RECORD LENGTH CHECK\nDECCCNSP EQU   BIT2 -         SPACE NOT FOUND\nDECCCINV EQU   BIT3 -         INVALID REQUEST.  (THIS CONDITION ALSO\n*                             SETS A BIT IN THE NEXT BYTE.)\nDECCCERR EQU   BIT4 -         UNCORRECTABLE I/O ERROR\nDECCCEOD EQU   BIT5 -         END OF DATA\nDECCCUER EQU   BIT6 -         UNCORRECTABLE ERROR OTHER THAN AN I/O\n*                             ERROR\nDECCCREX EQU   BIT7 -         A WRITE WITH EXCLUSIVE CONTROL WAS NOT\n*                             PRECEDED BY A READ WITH EXCLUSIVE CONTROL\n*                             (MDC300)                         @Z30AQ9A\nDECCC3   DS    B -            COMPLETION CODE BYTE 3\nDECRSV33 EQU   BIT0,,C'X' -   RESERVED\nDECCCWRI EQU   BIT1 -         A WRITE MACRO INSTRUCTION WAS ADDRESSED\n*                             TO AN INPUT DATA SET\nDECCCEXS EQU   BIT2 -         AN EXTENDED SEARCH WAS SPECIFIED WITH THE\n*                             DCBLIMCT FIELD SET TO ZERO\nDECCCNBK EQU   BIT3 -         THE BLOCK REQUESTED IS NOT WITHIN THE\n*                             DATA SET\nDECCCWDI EQU   BIT4 -         A WRITE-BY-IDENTIFICATION (DI) ADDRESSED\n*                             RECORD ZERO\nDECCCSDK EQU   BIT5 -         A SEARCH-ON-KEY (DK) WAS SPECIFIED WITH\n*                             THE DCBKEYLE FIELD SET TO ZERO OR WITHOUT\n*                             AN ADDRESS FOR THE KEY\nDECCCOPT EQU   BIT6 -         A MACRO INSTRUCTION USED AN OPTION NOT\n*                             SET IN THE DCB\nDECCCKFF EQU   BIT7 -         THE KEY FOR THE FIXED-LENGTH RECORD TO BE\n*                             ADDED BEGINS WITH X'FF'\nDECRSV34 DS    X -            RESERVED\n         DS    0BL2 -         DECTYPE - TYPE OF I/O REQUEST\n         DS    B -            DECTYPE1 - FIRST BYTE OF DECTYPE\nDECVERFY EQU   BIT0 -         VERIFY\nDECOFLOW EQU   BIT1 -         OVERFLOW\nDECEXSRC EQU   BIT2 -         EXTENDED SEARCH\nDECFDBCK EQU   BIT3 -         FEEDBACK\nDECACTAD EQU   BIT4 -         ACTUAL ADDRESSING\nDECDYNBF EQU   BIT5 -         DYNAMIC BUFFERING\nDECRDEX  EQU   BIT6 -         READ EXCLUSIVE\nDECRELBA EQU   BIT7 -         RELATIVE BLOCK ADDRESSING\n         DS    B -            DECTYPE2 - SECOND BYTE OF DECTYPE\nDECKEYS  EQU   BIT0 -         S CODED FOR KEY ADDRESS\nDECBKLNS EQU   BIT1 -         S CODED FOR BLOCK LENGTH\nDECTYPRU EQU   BIT2+BIT3 -    RU IS SUFFIXED TO THE TYPE, INDICATING\n*                             THAT THE FEEDBACK ADDRESS POINTED TO BY\n*                             DECNXADR CAN BE THE ADDRESS OF EITHER THE\n*                             NEXT DATA RECORD OR THE NEXT CAPACITY\n*                             RECORD, WHICHEVER OCCURS FIRST\nDECTYPR  EQU   BIT3 -         R IS SUFFIXED TO THE TYPE, INDICATING\n*                             THAT THE FEEDBACK ADDRESS POINTED TO BY\n*                             DECNXADR IS THE ADDRESS OF THE NEXT DATA\n*                             RECORD.  (BIT 2 IS ZERO)\nDECOPRD  EQU   BIT4 -         TYPE OF OPERATION - 0 IS WRITE, 1 IS READ\nDECSRKEY EQU   BIT5 -         TYPE OF SEARCH ARGUMENT - 0 IS ID,\n*                             1 IS KEY\nDECWRADD EQU   BIT6 -         ADD OPTION OF WRITE OPERATION\nDECRSV35 EQU   BIT7,,C'X' -   RESERVED\n         DS    H -            DECLNGTH - LENGTH OF DATA\n         DS    A -            DECDCBAD - ADDRESS OF DCB TO WHICH THIS\n*                             I/O REQUEST IS RELATED\n         DS    A -            DECAREA - ADDRESS OF THE DATA\n         DS    A -            DECIOBPT - ADDRESS OF THE IOB\nDECKYADR DS    A -            ADDRESS OF THE KEY\nDECRECPT DS    A -            ADDRESS OF THE BLOCK REFERENCE FIELD\nDECNA    DS    0A -           SAME AS DECNAA BELOW\nDECRSV36 DS    X -            RESERVED\nDECNAA   DS    AL3 -          ADDRESS OF THE NEXT ADDRESS FEEDBACK\n*                             FIELD.  PRESENT ONLY IF R OR RU IS CODED\n*                             IN THE READ MACRO.\n         SPACE 2\n***********************************************************************\n*              DATA EVENT CONTROL BLOCK FOR QTAM                      *\n***********************************************************************\n         SPACE 1\n         ORG   DECB\nLINEDECB DS    CL4 -          ALWAYS ZERO\nDECRSV37 DS    X -            RESERVED\nDECOPCOD DS    C -            OPERATION CODE FOR CURRENT SEGMENT\n         DS    H -            DECLNGTH - LENGTH OF INPUT AREA FOR\n*                             INITIAL READ\n         DS    A -            DECDCBAD - ADDRESS OF DCB\n         DS    A -            DECAREA - STARTING ADDRESS FOR DATA IN A\n*                             BUFFER\nDECRSV38 DS    XL4 -          RESERVED\nDECCPOL  DS    0A -           SAME AS DECCPOLA BELOW\nDECNMMSG DS    FL1 -          NUMBER OF MESSAGES RECEIVED\nDECCPOLA DS    AL3 -          ADDRESS OF CURRENTLY ACTIVE ENTRY IN\n*                             POLLING LIST\nDECRSV39 DS    X -            RESERVED\nDECUCBDX DS    FL1 -          INDEX TO UCB ADDRESS IN DEB\nDECRSV40 DS    XL2 -          RESERVED\nDECRSV41 DS    XL4 -          RESERVED\nDECADRCH DS    A -            ADDRESS OF ADDRESSING CHARACTERS IN\n*                             TERMINAL ENTRY\n         DS    0A -           DECPOLPT - ADDRESS OF POLLING LIST\nDECRSV42 DS    X -            RESERVED\n         DS    AL3 -          DECPOLPA - ADDRESS OF POLLING LIST\n         SPACE 2\n***********************************************************************\n*              DATA EVENT CONTROL BLOCK FOR BTAM                      *\n***********************************************************************\n         SPACE 1\n         ORG   DECB\n         DS    CL4 -          DECSDECB - EVENT CONTROL BLOCK\n         DS    0BL2 -         DECTYPE - PROGRAMMING INDICATORS\n         DS    B -            DECTYPE1 - FIRST BYTE OF DECTYPE\nDECRDAPL EQU   BIT0 -         READ, USING AUTOPOLL\nDECRSV43 EQU   BIT1,,C'X' -   RESERVED\nDECRSV44 EQU   BIT2,,C'X' -   RESERVED\nDECRSV45 EQU   BIT3,,C'X' -   RESERVED\nDECRSV46 EQU   BIT4,,C'X' -   RESERVED\nDECSTRME EQU   BIT5 -         'S' CODED FOR TERMINAL ENTRY\nDECSAREA EQU   BIT6 -         'S' CODED FOR AREA\nDECSLNTH EQU   BIT7 -         'S' CODED FOR LENGTH\n         DS    C -            DECTYPE2 - COMMAND CODE\n         DS    H -            DECLNGTH - LENGTH OF BUFFER OR MESSAGE\n*                             AREA\n         DS    0A -           DECDCBAD - ADDRESS OF ASSOCIATED DCB\nDECBUFCT DS    0FL1 -         CONTAINS A RUNNING COUNT OF BUFFERS\n*                             OBTAINED BY BTAM FOR THE CURRENT READ\n*                             OPERATION.  (DYNAMIC BUFFERING ONLY.)\n*                             USE DIFFERS DURING BSC AND 2760 ONLINE\n*                             TEST.\nDECONLTT DS    B -            FLAG BYTE FOR BSC AND 2760 ONLINE TEST\nDECONLTS EQU   BIT0 -         IF ZERO, ONLINE TEST REQUESTED BY RFT\n*                             MESSAGE (BSC).  IF ONE, ONLINE TEST\n*                             INITIATED BY ONLTST MACRO INSTRUCTION\n*                             (BSC).\nDECRCVMS EQU   BIT1 -         IF ZERO, SENDING TEST MESSAGES (BSC).\n*                             IF ONE, RECEIVING TEST MESSAGES (BSC) OR\n*                             TYPE 11 ONLINE TEST FOR 2760 OPTICAL\n*                             IMAGE UNIT.\nDECRSV47 EQU   BIT2,,C'X' -   RESERVED\nDECRSV48 EQU   BIT3,,C'X' -   RESERVED\nDECRSV49 EQU   BIT4,,C'X' -   RESERVED\nDECRSV50 EQU   BIT5,,C'X' -   RESERVED\nDECRSV51 EQU   BIT6,,C'X' -   RESERVED\nDECRSV52 EQU   BIT7,,C'X' -   RESERVED\nDECDCBAA DS    AL3 -          ADDRESS OF ASSOCIATED DCB\n         DS    A -            DECAREA - ADDRESS OF BUFFER OR MESSAGE\n*                             AREA\nDECSENS0 DS    B -            SENSE INFORMATION\nDECSENS1 DS    B -            RESERVED\nDECCOUNT DS    H -            RESIDUAL COUNT FROM CSW FOR LAST CCW\n*                             EXECUTED\nDECENTRY DS    0A -           ADDRESS OF THE TERMINAL LIST\nDECCMCOD DS    C -            COMMAND FOR WHICH THE ERROR OCCURRED\nDECENTRA DS    AL3 -          ADDRESS OF THE TERMINAL LIST\nDECFLAGS DS    B -            OPERATION STATUS\nDECWACK  EQU   BIT0+BIT1 -    WACK WAS RECEIVED (BSC)\nDECERRMS EQU   BIT0 -         ERROR STATUS MESSAGE WAS RECEIVED (BSC).\n*                             BIT 1 IS OFF.\nDECDIFAC EQU   BIT1 -         ACKNOWLEDGMENT OTHER THAN ACK-0 OR ACK-1\n*                             RECEIVED (BSC)\nDECALTAC EQU   BIT2 -         ACKNOWLEDGMENT ALTERNATION INCORRECT\nDECBADID EQU   BIT3 -         FOR TWX 33/35 STATION AND BSC STATION,\n*                             INCORRECT ID RECEIVED.  FOR AUTOPOLL,\n*                             INDEX BYTE RECEIVED DOES NOT MATCH AN\n*                             ACTIVE ONE.  FOR BSC NONSWITCHED\n*                             POINT-TO-POINT LINE, CONTENTION OCCURRED.\n*                             FOR WTTA, CONTENTION OCCURRED OR\n*                             INCORRECT ID RECEIVED.\nDECNOBUF EQU   BIT4 -         FOR READ, DYNAMIC BUFFERING, NO BUFFER\n*                             WAS AVAILABLE.  (MESSAGE LOST)\nDECNEGRP EQU   BIT5 -         FOR OPENLST, POLLING, NEGATIVE RESPONSE\n*                             TO POLLING RECEIVED.  FOR WRAPLST, ALL\n*                             ENTRIES ARE INACTIVE.  FOR ADDRESSING,\n*                             NEGATIVE RESPONSE TO ADDRESSING\n*                             RECEIVED.  FOR WTTA, LAST MESSAGE\n*                             RECEIVED ENDED WITH EOT OR TIME-OUT.\n*                             FOR 2741, POWER IS OFF OR OTHER\n*                             INTERVENTION REQUIRED CONDITION EXISTS.\nDECREVRS EQU   BIT6 -         FOR WTTA, MESSAGE ENDED WITH WRU SIGNAL.\n*                             FOR BSC STATIONS, REVERSE INTERRUPT (RVI)\n*                             SEQUENCE WAS RECEIVED (SEE ALSO BIT 1).\n*                             FOR 2741, WRITE OPERATION WAS ENDED BY\n*                             TERMINAL INTERRUPT.\nDECSSMSG EQU   BIT6 -         A 3270 REMOTE SENSE/STATUS MESSAGE WAS\n*                             RECEIVED IF THIS BIT IS ONE AND BIT 1\n*                             IS ZERO                            ICB479\nDECSTXNQ EQU   BIT7 -         FOR WTTA, CONTENTION CONDITION WAS\n*                             ENCOUNTERED.  FOR BSC STATIONS, STX ENQ\n*                             SEQUENCE WAS RECEIVED.\nDECRLN   DS    FL1 -          RELATIVE LINE NUMBER\nDECRESPN DS    CL2 -          FOR BSC OPERATIONS, RESPONSE FROM A\n*                             TERMINAL TO ADDRESSING.  FOR STOP-START\n*                             OPERATIONS, BYTE 1 IS RESPONSE FROM A\n*                             TERMINAL TO ADDRESSING AND BYTE 2 IS\n*                             VERTICAL REDUNDANCY CHARACTER AND\n*                             LONGITUDINAL REDUNDANCY CHARACTER\n*                             (VRC/LRC) RESPONSE.\nDECTPCOD DS    C -            TP OPERATION CODE\nDECERRST DS    B -            I/O ERROR STATUS FLAGS\nDECSIO3  EQU   BIT0 -         SIO RESULTED IN A CONDITION CODE OF 3\nDECUNDEF EQU   BIT1 -         UNDEFINED ERROR CONDITION\nDECERPER EQU   BIT2 -         AN ERROR CONDITION OCCURRED DURING AN I/O\n*                             OPERATION INITIATED BY ERROR RECOVERY\n*                             ROUTINES\nDECDIAGN EQU   BIT3 -         DIAGNOSTIC WRITE/READ OPERATION ENDED\n*                             BECAUSE OF ERROR (2701 ONLY)\nDECDSABL EQU   BIT4 -         DISABLE COMMAND ISSUED TO SWITCHED LINE\n*                             BY ERROR RECOVERY ROUTINE BECAUSE OF\n*                             PERMANENT ERROR ON THAT LINE\nDECRSV53 EQU   BIT5,,C'X' -   RESERVED\nDECRSV54 EQU   BIT6,,C'X' -   RESERVED\nDECRSV55 EQU   BIT7,,C'X' -   RESERVED\nDECCSWST DS    BL2 -          STATUS BITS FROM CSW FOR LAST CCW\n*                             EXECUTED\nDECADRPT DS    A -            ADDRESS OF ADDRESSING LIST ENTRY USED IN\n*                             PREVIOUS OPERATION\nDECPOLPT DS    0A -           SAME AS DECPOLPA BELOW\nDECNDXPL DS    FL1 -          FOR AUTOPOLL, INDEX TO CURRENT ENTRY IN\n*                             POLLING LIST\nDECPOLPA DS    AL3 -          FOR PROGRAMMED POLLING, ADDRESS OF THE\n*                             CURRENT ENTRY IN THE POLLING LIST.  FOR\n*                             AUTOPOLL, ADDRESS OF POLLING LIST.  FOR\n*                             BSC ON-LINE TEST, ADDRESS OF TEXT DATA.\n         SPACE 1\n*              BSC EXTENSION\n*        FIELDS ARE PRESENT ONLY IF A SUBLIST IS CODED FOR THE\n*        AREA AND LENGTH OPERANDS OF THE READ OR WRITE MACRO\n*        INSTRUCTION THAT DEFINES THE DECB.\n         SPACE 1\nDECRSV56 DS    XL2 -          RESERVED\nDECWLNG  DS    H -            LENGTH, IN BYTES, OF THE DATA AREA IN\n*                             LEADING-GRAPHICS AND CONVERSATIONAL TYPE\n*                             OPERATIONS OR OF THE AREA CONTAINING THE\n*                             TONE CHARACTERS IN READ CONNECT WITH TONE\n*                             (TCW) OPERATIONS\nDECWAREA DS    A -            ADDRESS OF THE DATA AREA IN\n*                             LEADING-GRAPHICS AND CONVERSATIONAL\n*                             OPERATIONS, OR OF THE AREA CONTAINING THE\n*                             TONE CHARACTERS IN READ TCW OPERATIONS\n         MEND  , */\n./ ADD NAME=IHADVCT  0100-02182-02182-0701-00138-00138-00000-XMIT370\n         MACRO\n         IHADVCT   &DSECT=YES\n.* /* START OF SPECIFICATIONS ****\n.*\n.*01  MODULE-NAME = IHADVCT\n.*\n.*01  COPYRIGHT = NONE\n.*\n.*01  STATUS = OS/VS2 RELEASE 2, LEVEL 0\n.*\n.*01  CHANGE-ACTIVITY = NONE\n.*\n.*01  DESCRIPTIVE-NAME = DEVICE CHARACTERISTICS TABLE MAPPING\n.*\n.*01  FUNCTION = THIS TABLE DESCRIBES PHYSICAL ATTRIBUTES OF EACH DASD\n.*    DEVICE WHICH HAS BEEN SYSGENED\n.*\n.*01  NOTES = THE TABLE IS POINTED TO BY CVTZDTAB.\n.*\n.*01  MODULE-TYPE = MACRO\n.*02    PROCESSOR = ASSEMBLER-370R\n.*\n.*02    MACRO-SIZE = 200 STATEMENTS\n.*\n.**** END OF SPECIFICATIONS ***/\n* /* MACCOMP Y-2 SC1D0/SJD48                                         */\n* /* MACSTAT Y-2 73226/021160                                        */\n*/********************************************************************/\n*/*                 DEVICE CHARACTERISTICS TABLE                     */\n*/********************************************************************/\n*/*                                                                  */\n*/*         THIS TABLE MAY BE USED TO FIND THE CHARACTERISTICS       */\n*/*         OF DIRECT ACCESS DEVICES.  THE APPLICABLE DEVICES ARE    */\n*/*         THOSE CONTAINING UCBDACC IN UCBTBYT3 (SEE IEFUCBOB).     */\n*/*                                                                  */\n*/*         NOTE: DEVTYPE MAY BE USED TO EXTRACT INFORMATION         */\n*/*         FROM THIS TABLE.  ITS OUTPUT AREA IS IN A SLIGHTLY       */\n*/*         DIFFERENT FORMAT, AND IS MAPPED BY IHADVA.               */\n*/*                                                                  */\n*/*         THE TABLE IS COMPOSED OF AN INDEX FOLLOWED BY ONE        */\n*/*         ENTRY FOR EACH DASD DEVICE WHICH HAS BEEN SYSGENED       */\n*/*                                                                  */\n*/*         FOR ASSEMBLER USE, TWO SEPARATE DSECTS ARE PROVIDED.     */\n*/*         A USING ON DVCTI GIVES ADDRESSIBILITY TO THE INDEX,      */\n*/*         AND A USING ON DVCT GIVES ADDRESSIBILITY TO AN ENTRY.    */\n*/*         SPECIFYING DSECT=NO SUPPRESSES THE INDEX AND PROVIDES    */\n*/*         AN ENTRY DESCRIPTION WITHOUT A DSECT STATEMENT           */\n*/*                                                                  */\n*/*         FOR PLS USE, TWO STRUCTURES ARE PROVIDED. THEIR STORAGE  */\n*/*         ATTRIBUTES ARE CONTROLLED BY SETTING STRING MACRO        */\n*/*         VARIABLES AS FOLLOWS:                                    */\n*/*         STRUCTURE  MACRO-VAR       DEFAULT SETTING               */\n*/*         DVCTI      %DVCIBASE  'BASED(CVTZDTAB)'                  */\n*/*         DVCT       %DVCTBASE  'BASED(CVTZDTAB                    */\n*/*                                +DVCTIOFF(UCBTYP&DVCTYPMK))'      */\n*/*                                                                  */\n*/*         THE DEFAULT SETTINGS WILL PROVIDE ADDRESSIBILITY TO      */\n*/*         ALL FIELDS, BUT DEPEND ON CVT AND UCB ADDRESSIBILITY.    */\n*/*                                                                  */\n*/*               FORMAT OF EACH ENTRY                               */\n*/*         _____________________________________________            */\n*/*   0(00) |                     |                     |            */\n*/*         |       DVCCYL        |       DVCTRK        |            */\n*/*         |_____________________|_____________________|            */\n*/*   4(04) |                     |       DVCOVHD       |            */\n*/*         |       DVCTRKLN      | DVCOVNLB | DVCOVLB  |            */\n*/*         |_____________________|__________|__________|            */\n*/*   8(08) |          |          |                     |            */\n*/*         | DVCOVNK  | DVCFLAGS |       DVCTOL        |            */\n*/*         |__________|__________|_____________________|            */\n*/*  12(0C) |                     |______________________            */\n*/*         |       DVCALT        |                     |            */\n*/*         |_____________________|       DVCOVR0       |  RPS       */\n*/*         ______________________|_____________________|  ONLY      */\n*/*  16(10) |          |          |                        SECTION   */\n*/*         | DVCSECT  | DVCSECTD |                                  */\n*/*         |__________|__________|                                  */\n*/********************************************************************/\n*%/*\n         AIF   ('&DSECT' EQ 'NO').NODSECT\nDVCTI    DSECT ,              INDEX TO DVCT\n*              THIS INDEX IS LOCATED FROM CVTZDTAB.\n*              THE PROPER ENTRY IS FOUND BY ADDING THE LOW ORDER\n*              4 BITS OF UCBTYP TO THE ADDRESS IN CVTZDTAB.\nDVCTYPMK EQU   X'0000000F'              TYPICAL USAGE:\n*              LA    RWRK,DVCTYPMK      MASK FOR UNIT TYPE NUMBER\n*              N     RWRK,UCBTYP        PICK UP UNIT TYPE NUMBER\n*              IC    RWRK,DVCTIOFF(RWRK)  PICK UP OFFSET\nDVCTIOFF DS    AL1                      OFFSET TO DVCT ENTRY\n***********************************************************************\n         SPACE 3\nDVCT     DSECT ,                        FORMAT OF DVCT ENTRY\n*              THE ENTRY IS LOCATED BY ADDING DVCTIOFF TO CVTZDTAB\n         AGO   .ENTRY\n.NODSECT ANOP\nDVCT     DS    0H                       FORMAT OF DVCT ENTRY\n.ENTRY   ANOP\n*\nDVCCYL   DS    H                        PHYS NO. CYL PER VOLUME\nDVCTRK   DS    H                        NO. TRACKS PER CYLINDER\nDVCTRKLN DS    H                        NO. OF BYTES PER TRACK\n*\nDVCOVHD  DS    0H                       BLOCK OVERHEAD IF DVC2BOV=1\n*              USE FOLLOWING TWO CONSTANTS IF DVC2BOV=0\nDVCOVNLB DS    XL1                      OVERHEAD NOT LAST BLOCK\nDVCOVLB  DS    XL1                      OVERHEAD LAST BLOCK\n*\nDVCOVNK  DS    XL1                      OVERHEAD DECREMENT NOT KEYED\n*\nDVCFLAGS DS    BL1\nDVC2BOV  EQU   X'08'                    IF 1, USE DVCOVHD\n*                                       IF 0, USE DVCOVNLB,DVCOVLB\nDVCFTOL  EQU   X'01'                    IF 1, APPLY TOLERANCE FACTOR\n*\nDVCTOL   DS    H                        TOLERANCE FACTOR\n*              APPLY TOLERANCE FACTOR AS FOLLOWS:\n*              1. ADD BLOCKSIZE AND KEYLENGTH\n*              2. MULTIPLY BY DVCTOL\n*              3. SHIFT RIGHT DVCTSHFT BITS\n*              4. ADD APPROPRIATE OVERHEADS\nDVCTSHFT EQU   9                        SHIFT AMT TO DIVIDE BY 512\n*\nDVCALT   DS    H                        NUMBER ALTERNATE TRKS/VOLUME\n*\nDVCENTLG EQU   *-DVCT                   BASIC SIZE OF DEVICE TABLE\n*                                       ENTRY, NOT INCLUDING ADD'L\n*                                       CHARACTERISTICS FOR RPS\n**********************************************************************\n*              THE FOLLOWING SECTION OF THE TABLE IS PRESENT         *\n*              ONLY FOR RPS DEVICES--TEST UCBTBYT2 FOR UCB2OPT3      *\n**********************************************************************\nDVCRPS   DS    0CL4                     RPS SECTION\nDVCOVR0  DS    H                        OVERHEAD BYTES FOR RECORD 0\nDVCSECT  DS    XL1                      NUMBER SECTORS IN FULL TRACK\nDVCSECTD DS    XL1                      NUMBER DATA SECTORS\n*\n*              END OF DVCT\n         MEND\n./ ADD NAME=IM#IGEN  0100-02182-02182-0701-00072-00072-00000-XMIT370\n         MACRO\n&LABEL   IM#IGEN &OP,&A,&B,&REG=R0\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n.*---------------------------------------------------------------------\n.* Function: generate one instruction\n.* &OP  - instruction opcode\n.* &A   - first operand\n.* &B   - second operand\n.* &REG - work register\n.* See IM#INSTR for further details, and notes below.\n.*---------------------------------------------------------------------\n         AIF   (T'&REG EQ 'O').XREG\n         AIF   (T'&OP EQ 'O').XOP\n         AIF   ('&OP' EQ '-CLEAR-').CLEAR\n         AIF   ('&OP' EQ '(-CLEAR-)').CLEAR\n         AIF   ('&OP' EQ '((-CLEAR-))').CLEAR\n         AIF   ('&OP' EQ '-ZERO-').ZERO\n         AIF   ('&OP' EQ '(-ZERO-)').ZERO\n         AIF   ('&OP' EQ '((-ZERO-))').ZERO\n         AIF   ('&OP' EQ '-0-').ZERO\n         AIF   ('&OP' EQ '(-0-)').ZERO\n         AIF   ('&OP' EQ '((-0-))').ZERO\n         AIF   ('&OP' EQ 'MVI').SI\n         AIF   ('&OP' EQ 'OI').SI\n         AIF   ('&OP' EQ 'NI').SI\n         AIF   ('&OP' EQ 'XI').SI\n         AIF   ('&OP' EQ 'MVC').SS\n         AIF   ('&B' NE '').B\n         AIF   ('&A' NE '').A\n         AIF   ('&REG' NE '').R\n&LABEL   &OP   ,\n         MEXIT\n.*\n.R       ANOP\n&LABEL   &OP   &REG\n         MEXIT\n.*\n.A       ANOP\n&LABEL   &OP   &REG,&A\n         MEXIT\n.*\n.B       ANOP\n&LABEL   &OP   &REG,&A,&B\n         MEXIT\n.*\n.CLEAR   ANOP\n&LABEL   SLR   &REG,&REG               clear register\n         MEXIT\n.*\n.ZERO    ANOP\n&LABEL   SR    &REG,&REG               zero register\n         MEXIT\n.*\n.SI      ANOP\n.SS      ANOP\n&LABEL   &OP   &A,&B\n         MEXIT\n.*\n.XOP     MNOTE 8,'IM#IGEN missing OP value'\n         MEXIT\n.XREG    MNOTE 8,'IM#IGEN missing REG value'\n.*---------------------------------------------------------------------\n.* Notes:\n.*\n.*  1) RR, RX, and RS instructions don't need to be checked, the\n.*     code handles them ASIS.  The other opcodes will need to be\n.*     specifically checked, so the right operands can be generated\n.*     for the target instruction.\n.*---------------------------------------------------------------------\n         MEND\n./ ADD NAME=IM#IGENF 0100-02182-02182-0701-00082-00082-00000-XMIT370\n         MACRO\n&LABEL   IM#IGENF &SPEC,&REG=R0\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n.*---------------------------------------------------------------------\n.* Function: generate one instruction - ASMF version\n.* &OP  - instruction opcode\n.* &A   - first operand\n.* &B   - second operand\n.* &REG - work register\n.* See IM#INSTR for further details, and notes below.\n.*---------------------------------------------------------------------\n         LCLC  &OP,&A,&B,&C\n&OP      SETC  '&SPEC(1)'\n&A       SETC  '&SPEC(2)'\n&B       SETC  '&SPEC(3)'\n&C       SETC  '&SPEC(4)'\n         MNOTE *,'IM#IGENF op &OP a &A b &B c &C'\n         MNOTE *,'IM#IGENF SYSLIST(1) &SYSLIST(1)'\n         MNOTE *,'IM#IGENF SYSLIST(2) &SYSLIST(2)'\n         MNOTE *,'IM#IGENF SYSLIST(3) &SYSLIST(3)'\n         MNOTE *,'IM#IGENF SYSLIST(4) &SYSLIST(4)'\n         AIF   (T'&REG EQ 'O').XREG\n         AIF   (T'&OP EQ 'O').XOP\n         AIF   ('&OP' EQ '-CLEAR-').CLEAR\n         AIF   ('&OP' EQ '(-CLEAR-)').CLEAR\n         AIF   ('&OP' EQ '((-CLEAR-))').CLEAR\n         AIF   ('&OP' EQ '-ZERO-').ZERO\n         AIF   ('&OP' EQ '(-ZERO-)').ZERO\n         AIF   ('&OP' EQ '((-ZERO-))').ZERO\n         AIF   ('&OP' EQ '-0-').ZERO\n         AIF   ('&OP' EQ '(-0-)').ZERO\n         AIF   ('&OP' EQ '((-0-))').ZERO\n         AIF   ('&OP' EQ 'MVI').SI\n         AIF   ('&OP' EQ 'OI').SI\n         AIF   ('&OP' EQ 'NI').SI\n         AIF   ('&OP' EQ 'XI').SI\n         AIF   ('&OP' EQ 'MVC').SS\n         AIF   ('&B' NE '').B\n         AIF   ('&A' NE '').A\n         AIF   ('&REG' NE '').R\n&LABEL   &OP   ,\n         MEXIT\n.*\n.R       ANOP\n&LABEL   &OP   &REG\n         MEXIT\n.*\n.A       ANOP\n&LABEL   &OP   &REG,&A\n         MEXIT\n.*\n.B       ANOP\n&LABEL   &OP   &REG,&A,&B\n         MEXIT\n.*\n.CLEAR   ANOP\n&LABEL   SLR   &REG,&REG               clear register\n         MEXIT\n.*\n.ZERO    ANOP\n&LABEL   SR    &REG,&REG               zero register\n         MEXIT\n.*\n.SI      ANOP\n.SS      ANOP\n&LABEL   &OP   &A,&B\n         MEXIT\n.*\n.XOP     MNOTE 8,'IM#IGEN missing OP value'\n         MEXIT\n.XREG    MNOTE 8,'IM#IGEN missing REG value'\n.*---------------------------------------------------------------------\n.* Notes:\n.*\n.*  1) RR, RX, and RS instructions don't need to be checked, the\n.*     code handles them ASIS.  The other opcodes will need to be\n.*     specifically checked, so the right operands can be generated\n.*     for the target instruction.\n.*---------------------------------------------------------------------\n         MEND\n./ ADD NAME=IM#INST  0100-02182-02182-0701-00081-00081-00000-XMIT370\n         MACRO\n&LABEL   IM#INST &REG,&SPEC\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n.*---------------------------------------------------------------------\n.* See notes below for details and syntax examples - ASMH+ version\n.*---------------------------------------------------------------------\n         LCLA  &N,&NN\n         LCLA  &I\n&LABEL   IM#SECT LABEL\n&N       SETA  N'&SPEC\n&NN      SETA  N'&SPEC(1)\n         AIF   ((&N EQ 1) AND (&NN EQ 1)).LALR\n         AIF   (&N GT 0).LOOP\n         MNOTE 8,'IM#INSTR missing SPEC'\n         MEXIT\n.*\n.LOOP    ANOP\n&I       SETA  &I+1\n         IM#IGEN &SPEC(&I,1),&SPEC(&I,2),&SPEC(&I,3),REG=&REG\n         AIF   (&I LT &N).LOOP\n         MEXIT\n.*\n.LALR    IM#LALR &REG,&SPEC\n         MEXIT\n.*---------------------------------------------------------------------\n.* Function: Generate one or more instructions from specified (SPEC)\n.* operands.\n.*\n.* &REG  - work register (may not always be used); generally the\n.*         register into which the calling macro wishes to place\n.*         a value.\n.* &SPEC - instruction specification\n.*\n.* SPEC Syntax samples (REG=Rx):\n.*\n.* SPEC                      calls     generates\n.* ------------------------- -------   --------------------------------\n.* (R3)                      IM#LALR   LR    Rx,R3\n.* FIELD                     IM#LALR   LA    Rx,FIELD\n.* *FIELD                    IM#LALR   L     Rx,FIELD\n.* .FIELD                    IM#LALR   LH    Rx,FIELD\n.*\n.* -CLEAR-                   IM#LALR   SLR   Rx,Rx\n.* -ZERO-                    IM#LALR   SR    Rx,Rx\n.* -0-                       IM#LALR   SR    Rx,Rx\n.*\n.* ((LH,FIELD))              IM#IGEN   LH    Rx,FIELD\n.* ((ICM,8,FIELD))           IM#IGEN   ICM   Rx,8,FIELD\n.* ((-ZERO-),(IC,F1))        IM#IGEN   SR    Rx,Rx\n.*                                     IC    Rx,F1\n.* ((MVI,F,8))               IM#IGEN   MVI   F,8\n.* ((MVC,F1,F2))             IM#IGEN   MVC   F1,F2\n.*\n.* ((-0-),(IC,F),(OI,X,32))  IM#IGEN   SR    Rx,Rx\n.*                           IM#IGEN   IC    Rx,F\n.*                           IM#IGEN   OI    X,32\n.*\n.* The basic function of this macro is to allow our callers to offer\n.* the coder the opportunity to \"reach into\" the macro expansion\n.* to add a few instructions.  Some of the syntax is as old as the\n.* hills: (Rx) and *FIELD have been in common usage since I started\n.* coding, and I have carried those syntax forms forward.\n.*\n.* If you wish to generate more than one instruction, the syntax must\n.* conform to the IM#IGEN format; the IM#LALR format is mostly for\n.* backwards compatability which only requires one instruction.\n.* For IM#IGEN, each sublist specified will generate one instruction.\n.*\n.* Not all instructions are capable of being generated by IM#INSTR.\n.* IM#LALR only supports the LR, LA, L, and LH instructions.\n.* IM#IGEN should support all of the RR, RX, and RS instruction types,\n.* and a handful of others; see IM#IGEN for these details.\n.* Both IM#IGEN and IM#LALR support the -x- forms.\n.*\n.* The coder is strongly encouraged to read the macro expansion to\n.* assure that what gets generated is what was intended, at least\n.* until some general familiarity with IM#INSTR is obtained.\n.*---------------------------------------------------------------------\n         MEND\n./ ADD NAME=IM#INSTF 0100-02182-02182-0702-00128-00128-00000-XMIT370\n         MACRO\n&LABEL   IM#INSTF &SPEC,&REG=R0,&LST=\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n.*---------------------------------------------------------------------\n.* See notes below for details and syntax examples - ASMF version\n.*---------------------------------------------------------------------\n         GBLA  &#SUBLN\n         GBLA  &#SUBLNI(8)\n         GBLC  &#SUBLC(8)\n         LCLA  &NSL           # &SYSLIST(1) operands\n         LCLA  &NI            # &LST(n) operands specified\n         LCLA  &I\n         LCLC  &JUNK\n.*\n&LABEL   XMI#SECT LABEL\n.*\n&NSL     SETA  N'&SYSLIST(1)\n         MNOTE *,'IM#INSTR LST &LST'\n         MNOTE *,'IM#INSTR NSL &NSL'\n.*\n         IM#SUBL &LST(1),&LST(2),&LST(3),&LST(4),&LST(5),&LST(6)\n&NI      SETA  &#SUBLN\n         MNOTE *,'IM#INSTR NI &NI'\n         AIF   (&#SUBLN GT 1).NOLALR\n.*\n         IM#SUBL &SPEC(1)\n         AIF   (&#SUBLN EQ 1).LALR\n.*\n.NOLALR  MNOTE *,'IM#INSTF - not LALR'\n         AIF   (&NSL EQ 0).NOSPEC\n         MNOTE *,'IM#INSTR LST(1) &LST(1)'\n         MNOTE *,'IM#INSTR LST(2) &LST(2)'\n         MNOTE *,'IM#INSTR LST(3) &LST(3)'\n         MNOTE *,'IM#INSTR LST(4) &LST(4)'\n         MNOTE *,'IM#INSTR SPEC(1) &SPEC(1)'\n         MNOTE *,'IM#INSTR SPEC(2) &SPEC(2)'\n         MNOTE *,'IM#INSTR SPEC(3) &SPEC(3)'\n         MNOTE *,'IM#INSTR SPEC(4) &SPEC(4)'\n         MNOTE *,'IM#INSTR SYSLIST(1) &SYSLIST(1)'\n         MNOTE *,'IM#INSTR SYSLIST(2) &SYSLIST(2)'\n         MNOTE *,'IM#INSTR SYSLIST(3) &SYSLIST(3)'\n         MNOTE *,'IM#INSTR SYSLIST(4) &SYSLIST(4)'\n.*\n.LOOP    ANOP\n         MNOTE *,'IM#INSTF *************  LOOP  ********************'\n&I       SETA  &I+1\n&JUNK    SETC  '&SYSLIST(&I,1)'\n         MNOTE *,'IM#INSTF I=&I SYSLIST(I,1) &JUNK'\n&JUNK    SETC  '&SYSLIST(&I,2)'\n         MNOTE *,'IM#INSTF I=&I SYSLIST(I,2) &JUNK'\n&JUNK    SETC  '&SYSLIST(&I,3)'\n         MNOTE *,'IM#INSTF I=&I SYSLIST(I,3) &JUNK'\n&JUNK    SETC  '&SYSLIST(&I,4)'\n         MNOTE *,'IM#INSTF I=&I SYSLIST(I,4) &JUNK'\n.*\n         MNOTE *,'INSTR->SUBL I=&I SYSLIST(I) &SYSLIST(&I)'\n         IM#SUBL &SYSLIST(&I)\n.*\n         MNOTE *,'INSTR->SUBL I=&I LST(I) &LST(&I)'\n         IM#SUBL &LST(&I)\n.*\n         IM#IGENF &SYSLIST(&I)\n         AIF   (&I LT &NI).LOOP\n         MEXIT\n.*\n.LALR    MNOTE *,'INSTR->LALR &REG,&LST'\n         IM#LALR &REG,&LST\n         MEXIT\n.*\n.NOSPEC  MNOTE 8,'IM#INSTR missing specification'\n         MEXIT\n.*---------------------------------------------------------------------\n.* Function: Generate one or more instructions from specified (SPEC)\n.* operands.\n.*\n.* &REG     - work register (may not always be used); generally the\n.*            register into which the calling macro wishes to place\n.*            a value.\n.* &SPEC    - instruction specification\n.*\n.* SPEC Syntax samples (REG=Rx):\n.*\n.* SPEC                      calls     generates\n.* ------------------------- -------   --------------------------------\n.* (R3)                      IM#LALR   LR    Rx,R3\n.* FIELD                     IM#LALR   LA    Rx,FIELD\n.* *FIELD                    IM#LALR   L     Rx,FIELD\n.* .FIELD                    IM#LALR   LH    Rx,FIELD\n.*\n.* -CLEAR-                   IM#LALR   SLR   Rx,Rx\n.* -ZERO-                    IM#LALR   SR    Rx,Rx\n.* -0-                       IM#LALR   SR    Rx,Rx\n.*\n.* ((LH,FIELD))              IM#IGEN   LH    Rx,FIELD\n.* ((ICM,8,FIELD))           IM#IGEN   ICM   Rx,8,FIELD\n.* ((-ZERO-),(IC,F1))        IM#IGEN   SR    Rx,Rx\n.*                                     IC    Rx,F1\n.* ((MVI,F,8))               IM#IGEN   MVI   F,8\n.* ((MVC,F1,F2))             IM#IGEN   MVC   F1,F2\n.*\n.* ((-0-),(IC,F),(OI,X,32))  IM#IGEN   SR    Rx,Rx\n.*                           IM#IGEN   IC    Rx,F\n.*                           IM#IGEN   OI    X,32\n.*\n.* The basic function of this macro is to allow our callers to offer\n.* the coder the opportunity to \"reach into\" the macro expansion\n.* to add a few instructions.  Some of the syntax is as old as the\n.* hills: (Rx) and *FIELD have been in common usage since I started\n.* coding, and I have carried those syntax forms forward.\n.*\n.* If you wish to generate more than one instruction, the syntax must\n.* conform to the IM#IGEN format; the IM#LALR format is mostly for\n.* backwards compatability which only requires one instruction.\n.* For IM#IGEN, each sublist specified will generate one instruction.\n.*\n.* Not all instructions are capable of being generated by IM#INSTR.\n.* IM#LALR only supports the LR, LA, L, and LH instructions.\n.* IM#IGEN should support all of the RR, RX, and RS instruction types,\n.* and a handful of others; see IM#IGEN for these details.\n.* Both IM#IGEN and IM#LALR support the -x- forms.\n.*\n.* The coder is strongly encouraged to read the macro expansion to\n.* assure that what gets generated is what was intended, at least\n.* until some general familiarity with IM#INSTR is obtained.\n.*---------------------------------------------------------------------\n         MEND\n./ ADD NAME=IM#LALR  0100-02182-02182-0702-00065-00065-00000-XMIT370\n         MACRO\n&LABEL   IM#LALR &REG,&WHAT\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n.*---------------------------------------------------------------------\n.* Function: Generate one instruction\n.* &REG  - work register\n.* &WHAT - (register), RX, or self-defining term to put in &REG\n.* See IM#INSTR for further details\n.*---------------------------------------------------------------------\n         LCLA  &LWHAT\n         LCLC  &TREG\n         LCLC  &TWHAT\n         AIF   ('&WHAT' NE '0').MORE\n&LABEL   SLR   &REG,&REG                     zero register\n         MEXIT\n.MORE    ANOP\n&TREG    SETC  '(&REG)'                      (LOWER '(&reg)')\n&TWHAT   SETC  '&WHAT'                       (LOWER '&what')\n.*       MNOTE 0,'IM#LALR REG &TREG'\n.*       MNOTE 0,'IM#LALR WHAT &TWHAT'\n         AIF   ('&TWHAT' EQ '&TREG').SKIP    already have value in reg\n         AIF   ('&WHAT'      EQ '-CLEAR-').CLEAR\n         AIF   ('&WHAT'      EQ '(-CLEAR-)').CLEAR\n         AIF   ('&WHAT'      EQ '((-CLEAR-))').CLEAR\n         AIF   ('&WHAT'      EQ '-ZERO-').ZERO\n         AIF   ('&WHAT'      EQ '(-ZERO-)').ZERO\n         AIF   ('&WHAT'      EQ '((-ZERO-))').ZERO\n         AIF   ('&WHAT'      EQ '-0-').ZERO\n         AIF   ('&WHAT'      EQ '(-0-)').ZERO\n         AIF   ('&WHAT'      EQ '((-0-))').ZERO\n         AIF   ('&WHAT'(1,1) EQ '(').LR\n         AIF   ('&WHAT'(1,1) EQ '*').LOAD    *field means load field\n         AIF   ('&WHAT'(1,1) EQ '.').LH      .field means load halfword\n&LABEL   LA    &REG,&WHAT\n         MEXIT\n.*\n.LR      ANOP\n&LABEL   LR    &REG,&WHAT(1)\n         MEXIT\n.*\n.LH      ANOP\n&LWHAT   SETA  K'&WHAT-1\n&TWHAT   SETC  '&WHAT'(2,&LWHAT)\n&LABEL   LH    &REG,&TWHAT\n         MEXIT\n.*\n.LOAD    ANOP\n&LWHAT   SETA  K'&WHAT-1\n&TWHAT   SETC  '&WHAT'(2,&LWHAT)\n&LABEL   L     &REG,&TWHAT\n         MEXIT\n.*\n.CLEAR   ANOP\n&LABEL   SLR   &REG,&REG\n         MEXIT\n.*\n.ZERO    ANOP\n&LABEL   SR    &REG,&REG\n         MEXIT\n.*\n.SKIP    ANOP\n*              instruction suppressed; register already contains value\n         MEND\n./ ADD NAME=IM#SECT  0100-02182-02182-0702-00022-00022-00000-XMIT370\n         MACRO\n&LABEL   IM#SECT &SECT\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n         AIF   ('&SECT' EQ 'LABEL').DS0H\n         AIF   ('&SECT' NE 'DSECT').NDSECT\n&LABEL   DSECT ,\n         MEXIT\n.*\n.NDSECT  AIF   ('&SECT' NE 'CSECT').NCSECT\n&LABEL   CSECT ,\n         MEXIT\n.*\n.NCSECT  AIF   ('&SECT' EQ '').DS0H\n&LABEL   DS    0&SECT\n         MEXIT\n.*\n.DS0H    ANOP\n         AIF   ('&LABEL' EQ '').DONE\n&LABEL   DS    0H\n.DONE    MEND\n./ ADD NAME=IM#SPLIT 0100-02182-02182-0702-00047-00047-00000-XMIT370\n         MACRO\n         IM#SPLIT\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n         GBLC  &G#SUBL(8)\n         LCLC  &C\n         LCLA  &DEPTH,&I,&IFIRST,&ILAST,&LX\n.*\n&G#SUBL(1) SETC ''\n&G#SUBL(2) SETC ''\n&G#SUBL(3) SETC ''\n&G#SUBL(4) SETC ''\n&G#SUBL(5) SETC ''\n&G#SUBL(6) SETC ''\n&G#SUBL(7) SETC ''\n&G#SUBL(8) SETC ''\n&I       SETA  2\n&IFIRST  SETA  2\n&ILAST   SETA  K'&SYSLIST(1)\n.LOOP    ANOP\n&C       SETC  '&SYSLIST(1)'(&I,1)\n         AIF   ('&C' NE '(').CKRP\n&DEPTH   SETA  &DEPTH+1\n         AGO   .BUMP\n.CKRP    AIF   ('&C' NE ')').CKCOMMA\n&DEPTH   SETA  &DEPTH-1\n         AGO   .BUMP\n.CKCOMMA AIF   ('&C' NE ',').BUMP\n         AIF   (&DEPTH GT 0).BUMP\n.*\n.*  G#SUBL(LX) = sublist string\n.*\n.NEW     ANOP\n&LX      SETA  &LX+1\n         AIF   (&LX GT 8).ERR\n&G#SUBL(&LX) SETC '&SYSLIST(1)'(&IFIRST,&I-&IFIRST)\n&IFIRST  SETA  &I+1\n.*\n.BUMP    ANOP\n&I       SETA  &I+1\n         AIF   (&I LT &ILAST).LOOP\n         AIF   (&IFIRST LT &ILAST).NEW\n         MEXIT\n.*\n.ERR     MNOTE *,'IM#SPLIT LX > 8'\n         MEND\n./ ADD NAME=IM#STA   0100-02182-02182-0702-00018-00018-00000-XMIT370\n         MACRO\n&LABEL   IM#STA &WHAT,&WHERE,&REG=R0\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n.*---------------------------------------------------------------------\n.* &WHAT  - what value to store\n.* &WHERE - field into which to store &WHAT\n.* &REG   - register to use to L, LR, etc. &WHAT field\n.*---------------------------------------------------------------------\n         AIF   ('&WHAT'(1,1) EQ '(').LR\n&LABEL   IM#LALR  &REG(1),&WHAT\n         ST    &REG(1),&WHERE\n         MEXIT\n.*\n.LR      ANOP\n&LABEL   ST    &WHAT(1),&WHERE\n         MEND\n./ ADD NAME=IM#SUBL  0100-02182-02182-0702-00031-00031-00000-XMIT370\n         MACRO\n&LABEL   IM#SUBL &SPEC\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n         GBLA  &#SUBLN\n         GBLA  &#SUBLNI(8)\n         GBLC  &#SUBLC(8)\n         LCLC  &JUNK(8)\n         LCLA  &I,&MAXL\n&MAXL    SETA  8                           max # operands examined\n&#SUBLN  SETA  0\n.*\n.LOOP        ANOP\n&I           SETA  &I+1\n&#SUBLC(&I)  SETC  '&SYSLIST(&I)'\n&JUNK(1)     SETC  '&SPEC(1)'\n&JUNK(2)     SETC  '&SPEC(2)'\n&JUNK(3)     SETC  '&SPEC(3)'\n&JUNK(4)     SETC  '&SPEC(4)'\n             AIF   ('&#SUBLC(&I)' EQ '').DONE\n&#SUBLN      SETA  &#SUBLN+1\n         MNOTE *,'IM#SUBL I &I JUNK(1) &JUNK(1)'\n         MNOTE *,'IM#SUBL I &I JUNK(2) &JUNK(2)'\n         MNOTE *,'IM#SUBL I &I JUNK(3) &JUNK(3)'\n         MNOTE *,'IM#SUBL I &I JUNK(4) &JUNK(4)'\n         MNOTE *,'IM#SUBL I &I #SUBLNI &#SUBLNI(&I) #SUBLC &#SUBLC(&I)'\n         AIF   (&I LT &MAXL).LOOP\n.*\n.DONE    MNOTE *,'IM#SUBL SUBLN &#SUBLN'\n         MEND\n./ ADD NAME=JASM     0100-02182-02182-0702-00012-00012-00000-XMIT370\n//INSTALL  JOB CLASS=A,MSGCLASS=A,MSGLEVEL=(2,0)\n//*\n//RECV370 EXEC ASM370,M=RECV370\n//*\n//LINK     EXEC PGM=IEWL,PARM='LIST,MAP,XREF,LET,NCAL,RENT',COND=(5,LT)\n//SYSPRINT  DD SYSOUT=*\n//SYSLMOD   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//SYSLIB    DD DSN=SYS2.XMIT370.OBJ,DISP=SHR\n//SYSUT1    DD UNIT=SYSDA,SPACE=(TRK,(5,5))\n//* SLIN    DD DSN=SYS2.XMIT370.ASM(KXMIT),DISP=SHR\n//SYSLIN    DD DSN=SYS2.XMIT370.ASM(KRECV),DISP=SHR\n//\n./ ADD NAME=JCBTUNLD 0100-02182-02182-0702-00010-00010-00000-XMIT370\n//UNLOAD   JOB CBT,REGION=1024K,MSGCLASS=A,CLASS=A\n//IEBCOPY  EXEC PGM=IEBCOPY\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD DSN=SYS2.XMIT370.ASM,DISP=SHR\n//SYSUT2    DD DSN=SYS2.XMIT370.V0004.CBT,\n//             UNIT=TAPE,VOL=SER=XV0004,\n//             LABEL=(1,SL),\n//             DISP=(,CATLG)\n//SYSIN     DD DUMMY\n//\n./ ADD NAME=JCOMP    0100-02182-02182-0702-00012-00012-00000-XMIT370\n//COMPRESS JOB CLASS=A,MSGCLASS=A\n//*\n//COMPRESS PROC DS=NULLFILE\n//IEBCOPY  EXEC PGM=IEBCOPY,REGION=2048K\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD DSN=&DS,DISP=SHR\n//SYSUT2    DD DSN=&DS,DISP=SHR\n//SYSIN     DD DUMMY\n//         PEND\n//*\n//ASM      EXEC COMPRESS,DS='SYS2.XMIT370.ASM'\n//\n./ ADD NAME=JDEBUGR  0100-02182-02182-0702-00028-00028-00000-XMIT370\n//RECV370  JOB TESTING,REGION=1024K,MSGCLASS=A,CLASS=A\n//*            //*JOBPARM LINECT=0\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD DUMMY\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n SCRATCH DSNAME=SYS2.RECV370.PDS,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.RECV370.PDS\n SCRATCH DSNAME=SYS2.RECV370.SYSUT1,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.RECV370.SYSUT1\n//*\n//RECV370  EXEC PGM=RECV370\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//XMITPRT   DD SYSOUT=*\n//XMITIN    DD DSN=SYS2.XMIT370.MVS38J.XMIT,DISP=SHR\n//* ITIN    DD DSN=SYS2.XMIT370.MVS38J.XMIT2,DISP=SHR\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DUMMY\n//SYSUT1    DD DSN=SYS2.RECV370.SYSUT1,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(10,10),RLSE),\n//             DISP=(,CATLG)\n//SYSUT2    DD DSN=SYS2.RECV370.PDS,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(10,10),RLSE),\n//             DISP=(,CATLG)\n//XMITDBUG  DD DSN=SYS2.XMIT370.ASM(KDEBUGR),DISP=SHR\n//SYSUDUMP  DD SYSOUT=*\n//\n./ ADD NAME=JDEBUGX  0100-02182-02182-0702-00027-00027-00000-XMIT370\n//XMIT370  JOB TESTING,REGION=1024K,MSGCLASS=A,CLASS=A\n//*JOBPARM LINECT=0\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD SYSOUT=*\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n SCRATCH DSNAME=SYS2.XMIT370.MVS38J.XMI,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.XMIT370.MVS38J.XMI\n SCRATCH DSNAME=SYS2.XMIT370.UNLD.MVS38J,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.XMIT370.UNLD.MVS38J\n//*\n//XMIT370  EXEC PGM=XMIT370,PARM=1\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//XMITPRT   DD SYSOUT=*\n//SYSPRINT  DD SYSOUT=*\n//SYSUDUMP  DD SYSOUT=*\n//SYSIN     DD DUMMY\n//* SUT1    DD DSN=SYS2.XMIT370.ASM,DISP=SHR\n//SYSUT2    DD DSN=SYS2.XMIT370.UNLD.MVS38J,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,1),RLSE),\n//             DISP=(NEW,CATLG)\n//XMITOUT   DD DSN=SYS2.XMIT370.MVS38J.XMI,\n//             VOL=SER=MVS809,UNIT=3380,\n//             SPACE=(CYL,(5,1),RLSE),\n//             DISP=(,CATLG)\n//XMITDBUG  DD DSN=SYS2.XMIT370.ASM(KDEBUGX),DISP=SHR\n//\n./ ADD NAME=JDEMOPDS 0100-02182-02182-0702-00027-00027-00000-XMIT370\n//XMITPDS  JOB 'DEMO DSORG=PO',CLASS=A,MSGCLASS=A\n//*\n//* TRANSMIT XMIT370\n//*\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD SYSOUT=*\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n//SYSIN     DD *\n SCRATCH DSNAME=SYS2.XMIT370.DEMO.XMIT,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.XMIT370.DEMO.XMIT\n//*\n//XMIT     EXEC PGM=XMIT370\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//SYSPRINT  DD SYSOUT=*\n//XMITPRT   DD SYSOUT=*\n//SYSUDUMP  DD SYSOUT=*\n//SYSUT1    DD DSN=SYS2.XMIT370.ASM,DISP=SHR\n//SYSUT2    DD DSN=&&SYSUT2,\n//             UNIT=SYSDA,                            SYSALLDA\n//             SPACE=(CYL,(5,1),\n//             DISP=(,DELETE,DELETE)\n//XMITOUT   DD DSN=SYS2.XMIT370.DEMO.XMIT,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,1)),\n//             DISP=(,CATLG,CATLG)\n//SYSIN     DD DUMMY\n//\n./ ADD NAME=JDEMOSEQ 0100-02182-02182-0702-00023-00023-00000-XMIT370\n//XMITSEQ  JOB 'DEMO DSORG=PS',CLASS=A,MSGCLASS=A\n//*\n//* TEST XMIT OF SEQUENTIAL DATASET\n//*\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD SYSOUT=*\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n//SYSIN     DD *\n SCRATCH DSNAME=SYS2.XMIT370.DEMO.XMIT,VOL=3330=MVS809\n UNCATLG DSNAME=SYS2.XMIT370.DEMO.XMIT\n//*\n//XMIT     EXEC PGM=XMIT370\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//SYSPRINT  DD SYSOUT=*\n//XMITPRT   DD SYSOUT=*\n//SYSUDUMP  DD SYSOUT=*\n//SYSUT1    DD DSN=JMM.SEQ001,DISP=SHR\n//XMITOUT   DD DSN=SYS2.XMIT370.DEMO.XMIT\n//             UNIT=3380,VOL=SER=MVS809,              SYSALLDA\n//             SPACE=(CYL,(1,1)),\n//             DISP=(,CATLG,CATLG)\n//SYSIN     DD DUMMY\n//\n./ ADD NAME=JINITT   0100-02182-02182-0702-00007-00007-00000-XMIT370\n//INITT    JOB CLASS=A,MSGCLASS=A\n//IEHINITT EXEC PGM=IEHINITT\n//SYSPRINT  DD SYSOUT=*\n//TAPE      DD UNIT=(TAPE,,DEFER),DCB=DEN=4  6250 BPI\n//SYSIN     DD *\nTAPE     INITT SER=XV0004,OWNER='N9GTM'\n//\n./ ADD NAME=JINSTALL 0100-02182-02182-0702-00083-00083-00000-XMIT370\n//INSTALL  JOB XMIT370,CLASS=A,MSGCLASS=A,\n//             MSGLEVEL=(2,0),NOTIFY=N9GTM\n//*            RESTART=XMITVTAB.ASMBLR\n//* -------------------------------------------------------------------\n//ASM370   PROC M=MISSING,LIST=,PRT=DISK\n//ASMBLR   EXEC PGM=IFOX00,\n//             COND=(5,LT),\n//             REGION=6144K,\n//             PARM='&LIST.LIST,NOXREF,NORLD,LINECOUNT(999)'\n//SYSPRINT  DD DDNAME=&PRT\n//SYSOUT    DD SYSOUT=*\n//DISK      DD DSN=SYS2.XMIT370.LIST(&M),DISP=SHR\n//SYSLIB    DD DSN=SYS2.XMIT370.ASM,DISP=SHR,\n//             DCB=BLKSIZE=32720\n//          DD DSN=SYS1.AMACLIB,DISP=SHR\n//          DD DSN=SYS1.AMODGEN,DISP=SHR\n//          DD DSN=SYS1.AGENLIB,DISP=SHR\n//SYSPUNCH  DD DSN=SYS2.XMIT370.OBJ(&M),DISP=SHR\n//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(35,10))\n//SYSUT2    DD UNIT=SYSDA,SPACE=(CYL,(35,10))\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(50,10))\n//SYSIN     DD DSN=SYS2.XMIT370.ASM(&M),DISP=SHR\n//         PEND\n//* -------------------------------------------------------------------\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD DUMMY\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n SCRATCH DSNAME=SYS2.XMIT370.LIST,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.XMIT370.LIST\n SCRATCH DSNAME=SYS2.XMIT370.OBJ,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.XMIT370.OBJ\n//*\n//ALLOC    EXEC PGM=IEFBR14\n//LIST      DD DSN=SYS2.XMIT370.LIST,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(20,0,5),RLSE),\n//             DCB=(RECFM=FB,LRECL=121,BLKSIZE=23474),\n//             DISP=(,CATLG)\n//OBJ       DD DSN=SYS2.XMIT370.OBJ,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,0,5),RLSE),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200),\n//             DISP=(,CATLG)\n//*\n//* -------------------------------------------------------------------\n//RECVBLK  EXEC ASM370,M=RECVBLK\n//RECVCTL  EXEC ASM370,M=RECVCTL\n//RECVGET  EXEC ASM370,M=RECVGET\n//RECVRCPY EXEC ASM370,M=RECVRCPY\n//RECVUTIL EXEC ASM370,M=RECVUTIL\n//RECVVTAB EXEC ASM370,M=RECVVTAB\n//RECV370  EXEC ASM370,M=RECV370\n//UTILABND EXEC ASM370,M=UTILABND\n//UTILDBUG EXEC ASM370,M=UTILDBUG\n//UTILHEX  EXEC ASM370,M=UTILHEX\n//UTILLOG  EXEC ASM370,M=UTILLOG\n//UTILPSR  EXEC ASM370,M=UTILPSR\n//UTILSNAP EXEC ASM370,M=UTILSNAP\n//UTILTIOT EXEC ASM370,M=UTILTIOT\n//XMITBUF  EXEC ASM370,M=XMITBUF\n//XMITCPR1 EXEC ASM370,M=XMITCPR1\n//XMITDIR  EXEC ASM370,M=XMITDIR\n//XMITESZ  EXEC ASM370,M=XMITESZ\n//XMITPUT  EXEC ASM370,M=XMITPUT\n//XMITUNLD EXEC ASM370,M=XMITUNLD\n//XMITVTAB EXEC ASM370,M=XMITVTAB\n//XMIT01   EXEC ASM370,M=XMIT01\n//XMIT02A  EXEC ASM370,M=XMIT02A\n//XMIT02B  EXEC ASM370,M=XMIT02B\n//XMIT03   EXEC ASM370,M=XMIT03\n//XMIT06   EXEC ASM370,M=XMIT06\n//XMIT370  EXEC ASM370,M=XMIT370\n//* -------------------------------------------------------------------\n//LINK     EXEC PGM=IEWL,\n//             COND=(5,LT),\n//             PARM='LIST,MAP,XREF,LET,NCAL,RENT'\n//SYSPRINT  DD SYSOUT=*\n//SYSLMOD   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//SYSLIB    DD DSN=SYS2.XMIT370.OBJ,DISP=SHR\n//SYSUT1    DD UNIT=SYSDA,SPACE=(TRK,(5,5))\n//SYSLIN    DD DSN=SYS2.XMIT370.ASM(KXMIT),DISP=SHR\n//          DD DSN=SYS2.XMIT370.ASM(KRECV),DISP=SHR\n//\n./ ADD NAME=JLINK    0100-02182-02182-0702-00013-00013-00000-XMIT370\n//LINK     JOB XMIT370,CLASS=A,MSGCLASS=A,\n//             MSGLEVEL=(2,0),NOTIFY=JMM\n//*\n//LINK     EXEC PGM=IEWL,\n//             COND=(5,LT),\n//             PARM='LIST,MAP,XREF,LET,NCAL,RENT'\n//SYSPRINT  DD SYSOUT=*\n//SYSLMOD   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//SYSLIB    DD DSN=SYS2.XMIT370.OBJ,DISP=SHR\n//SYSUT1    DD UNIT=SYSDA,SPACE=(TRK,(5,5))\n//SYSLIN    DD DSN=SYS2.XMIT370.ASM(KXMIT),DISP=SHR   XMIT370\n//*         DD DSN=SYS2.XMIT370.ASM(KRECV),DISP=SHR   RECV370\n//\n./ ADD NAME=JRECV    0100-02182-02182-0702-00042-00042-00000-XMIT370\n//RECV370  JOB TESTING,REGION=1024K,MSGCLASS=A,CLASS=A\n//*            //*JOBPARM LINECT=0\n//*--------------------------------------------------------------------\n//RECV370  PROC XMIT=\n//RECV370  EXEC PGM=RECV370\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//XMITPRT   DD SYSOUT=*\n//XMITIN    DD DSN=SYS2.XMIT370.MVS38J.XMIT&XMIT,DISP=SHR\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DUMMY\n//SYSUT1    DD DSN=SYS2.RECV370.MVS38J.XMIT&XMIT..SYSUT1,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(10,10),RLSE),\n//             DISP=(,CATLG)\n//SYSUT2    DD DSN=SYS2.RECV370.MVS38J.XMIT&XMIT..PDS,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(10,10,15),RLSE),\n//             DISP=(,CATLG)\n//* ITDBUG  DD DSN=SYS2.XMIT370.ASM(KDEBUGR),DISP=SHR\n//SYSUDUMP  DD SYSOUT=*\n//         PEND\n//*--------------------------------------------------------------------\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD DUMMY\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n SCRATCH DSNAME=SYS2.RECV370.MVS38J.XMIT.PDS,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.RECV370.MVS38J.XMIT.PDS\n SCRATCH DSNAME=SYS2.RECV370.MVS38J.XMIT2.PDS,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.RECV370.MVS38J.XMIT2.PDS\n SCRATCH DSNAME=SYS2.RECV370.MVS38J.XMIT3.PDS,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.RECV370.MVS38J.XMIT3.PDS\n SCRATCH DSNAME=SYS2.RECV370.MVS38J.XMIT.SYSUT1,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.RECV370.MVS38J.XMIT.SYSUT1\n SCRATCH DSNAME=SYS2.RECV370.MVS38J.XMIT2.SYSUT1,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.RECV370.MVS38J.XMIT2.SYSUT1\n SCRATCH DSNAME=SYS2.RECV370.MVS38J.XMIT3.SYSUT1,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.RECV370.MVS38J.XMIT3.SYSUT1\n//*\n//RECV1    EXEC RECV370,XMIT=\n//RECV2    EXEC RECV370,XMIT=2\n//RECV3    EXEC RECV370,XMIT=3\n//\n./ ADD NAME=JUNLD    0100-02182-02182-0702-00017-00017-00000-XMIT370\n//UNLOAD   JOB TESTING,REGION=1024K,MSGCLASS=A,CLASS=A\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD SYSOUT=*\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n SCRATCH DSNAME=SYS2.IEBCOPY.UNLD.MVS38J,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.IEBCOPY.UNLD.MVS38J\n//*\n//IEBCOPY  EXEC PGM=IEBCOPY\n//SYSPRINT  DD SYSOUT=*\n//IN        DD DSN=SYS2.XMIT370.ASM,DISP=SHR\n//OUT       DD UNIT=3380,VOL=SER=MVS809,\n//             DSN=SYS2.IEBCOPY.UNLD.MVS38J,\n//             SPACE=(CYL,(10,10),RLSE),\n//             DISP=(NEW,CATLG)\n//SYSIN     DD *\n COPY OUTDD=OUT,INDD=IN\n//\n./ ADD NAME=JXMIT    0100-02182-02182-0702-00025-00025-00000-XMIT370\n//XMIT370  JOB TESTING,REGION=1024K,MSGCLASS=A,CLASS=A\n//*JOBPARM LINECT=0\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD SYSOUT=*\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n SCRATCH DSNAME=SYS2.XMIT370.MVS38J.XMIT,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.XMIT370.MVS38J.XMIT\n SCRATCH DSNAME=SYS2.XMIT370.MVS38J.UNLD,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.XMIT370.MVS38J.UNLD\n//*\n//XMIT370  EXEC PGM=XMIT370\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//XMITPRT   DD SYSOUT=*\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DUMMY\n//SYSUT1    DD DSN=SYS2.XMIT370.ASM,DISP=SHR\n//SYSUT2    DD DSN=SYS2.XMIT370.MVS38J.UNLD,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,1),RLSE),\n//             DISP=(NEW,CATLG)\n//XMITOUT   DD DSN=SYS2.XMIT370.MVS38J.XMIT,\n//             VOL=SER=MVS809,UNIT=3380,\n//             SPACE=(CYL,(5,1),RLSE),\n//             DISP=(,CATLG)\n//\n./ ADD NAME=JXMIT2   0100-02182-02182-0702-00032-00032-00000-XMIT370\n//XMIT370  JOB TESTING,REGION=1024K,MSGCLASS=A,CLASS=A\n//*JOBPARM LINECT=0\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD SYSOUT=*\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n SCRATCH DSNAME=SYS2.XMIT370.MVS38J.XMIT2,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.XMIT370.MVS38J.XMIT2\n SCRATCH DSNAME=SYS2.XMIT370.MVS38J.UNLD,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.XMIT370.MVS38J.UNLD\n//*\n//XMIT370  EXEC PGM=XMIT370\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//XMITPRT   DD SYSOUT=*\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DUMMY\n//SYSUT2    DD DSN=SYS2.XMIT370.MVS38J.UNLD,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(10,10),RLSE),\n//             DISP=(NEW,CATLG)\n//XMITOUT   DD DSN=SYS2.XMIT370.MVS38J.XMIT2,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,1),RLSE),\n//             DISP=(,CATLG)\n//SYSUT1    DD DSN=SYS2.XMIT370.ASM,DISP=SHR\n//SYSUDUMP  DD SYSOUT=*\n//* ITDBUG  DD DSN=SYS2.XMIT370.ASM(KDEBUGX),DISP=SHR\n//*\n//* MVS38J  LRECL=56\n//* MVS/ESA LRECL=60\n//*\n//COPYR1    DD DUMMY,DCB=LRECL=60\n//\n./ ADD NAME=JXMIT3   0100-02182-02182-0702-00031-00031-00000-XMIT370\n//XMIT370  JOB TESTING,REGION=1024K,MSGCLASS=A,CLASS=A\n//*JOBPARM LINECT=0\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD SYSOUT=*\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n SCRATCH DSNAME=SYS2.XMIT370.MVS38J.XMIT3,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.XMIT370.MVS38J.XMIT3\n SCRATCH DSNAME=SYS2.XMIT370.MVS38J.UNLD,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.XMIT370.MVS38J.UNLD\n//*\n//XMIT370  EXEC PGM=XMIT370\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//XMITPRT   DD SYSOUT=*\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DUMMY\n//SYSUT2    DD DSN=SYS2.XMIT370.MVS38J.UNLD,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(10,1),RLSE),\n//             DISP=(NEW,CATLG)\n//XMITOUT   DD DSN=SYS2.XMIT370.MVS38J.XMIT3,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(10,1),RLSE),\n//             DISP=(,CATLG)\n//SYSUT1    DD DSN=SYS2.XMIT370.ASM,DISP=SHR\n//SYSUDUMP  DD SYSOUT=*\n//* ITDBUG  DD DSN=SYS2.XMIT370.ASM(KDEBUGX),DISP=SHR\n//*\n//* MVS/ESA LRECL=64\n//*\n//COPYR1    DD DUMMY,DCB=LRECL=64\n//\n./ ADD NAME=JZAP     0100-02182-02182-0702-00011-00011-00000-XMIT370\n//ZAP      JOB CLASS=A,MSGCLASS=A\n//ZAP      EXEC PGM=IKJEFT01,REGION=1024K,DYNAMNBR=20,COND=EVEN\n//SYSPRINT  DD SYSOUT=*\n//SYSHELP   DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT  DD SYSOUT=*\n//ZAPLOG    DD SYSOUT=*\n//SYSTSIN   DD *\nZAP 'SYS2.IEBCOPY.UNLD.MVS38J' NOT3270 LOG VERBOSE\nDUMPE\nEND\n//\n./ ADD NAME=JZTEST   0100-02182-02182-0702-00019-00019-00000-XMIT370\n//INSTALL  JOB CLASS=A,MSGCLASS=A\n//*--------------------------------------------------------------------\n//* DOES NOT APPLY TO XMIT370 0004\n//*--------------------------------------------------------------------\n//* IF YOU'RE USING AN OLDER ASSEMBLER (LIKE ASMF/IFOX00 FROM MVS38J),\n//* YOU NEED TO ASSEMBLE THE FOLLOWING TO SEE IF YOU HAVE A BUG IN\n//* MACRO OPERAND SUBLIST HANDLING.  REVIEW THE ASSEMBLY OUTPUT, AND\n//* IF THE MNOTE OUTPUT DOESN'T MATCH WHAT IT SHOULD BE, YOU HAVE THE\n//* BUG.  IF SO, EDIT XMIT#SET TO SPECIFY\n//*\n//*    &G#ASMF  SETB 1\n//*\n//* IF YOU DON'T HAVE THE BUG, EDIT XMIT#SET TO SPECIFY\n//*\n//*    &G#ASMF  SETB 0\n//*\n//* BEFORE YOU ASSEMBLE XMIT370/RECV370.\n//*\n//ZTEST   EXEC ASM370F,M=ZTEST\n./ ADD NAME=KDEBUGR  0100-02182-02182-0702-00014-00014-00000-XMIT370\nDEFAULT  1\nUTILDBUG 1     TURN ON DEBUG MSGS RIGHT AWAY\nRECV370  9\nRECVBLK  0\nRECVCTL  5\nRECVGET  0\nRECVRCPY\nRECVUTIL 9\nUTILABND 9\nUTILHEX  0\nUTILLOG  0\nUTILPSR  0\nUTILSNAP 0\nUTILTIOT 0\n./ ADD NAME=KDEBUGX  0100-02182-02182-0702-00020-00020-00000-XMIT370\nDEFAULT  1\nUTILDBUG 1     TURN ON DEBUG MSGS RIGHT AWAY\nXMIT370\nXMITBUF  0\nXMITCPR1 9\nXMITDIR  0\nXMITESZ  0\nXMITPUT  0\nXMITUNLD 1\nXMIT01\nXMIT02A  3\nXMIT02B\nXMIT03\nXMIT06\nUTILABND 9\nUTILHEX  0\nUTILLOG  0\nUTILPSR  0\nUTILSNAP 0\nUTILTIOT 0\n./ ADD NAME=KRECV    0100-02182-02182-0702-00017-00017-00000-XMIT370\n SETCODE AC(1)\n INCLUDE SYSLIB(RECV370)\n INCLUDE SYSLIB(RECVBLK)\n INCLUDE SYSLIB(RECVCTL)\n INCLUDE SYSLIB(RECVGET)\n INCLUDE SYSLIB(RECVRCPY)\n INCLUDE SYSLIB(RECVUTIL)\n INCLUDE SYSLIB(RECVVTAB)\n INCLUDE SYSLIB(UTILABND)\n INCLUDE SYSLIB(UTILDBUG)\n INCLUDE SYSLIB(UTILHEX)\n INCLUDE SYSLIB(UTILLOG)\n INCLUDE SYSLIB(UTILPSR)\n INCLUDE SYSLIB(UTILSNAP)\n INCLUDE SYSLIB(UTILTIOT)\n ENTRY RECV370\n NAME RECV370(R)\n./ ADD NAME=KXMIT    0100-02182-02182-0702-00023-00023-00000-XMIT370\n SETCODE AC(1)\n INCLUDE SYSLIB(XMIT370)\n INCLUDE SYSLIB(XMITBUF)\n INCLUDE SYSLIB(XMITCPR1)\n INCLUDE SYSLIB(XMITDIR)\n INCLUDE SYSLIB(XMITESZ)\n INCLUDE SYSLIB(XMITPUT)\n INCLUDE SYSLIB(XMITUNLD)\n INCLUDE SYSLIB(XMIT01)\n INCLUDE SYSLIB(XMIT02A)\n INCLUDE SYSLIB(XMIT02B)\n INCLUDE SYSLIB(XMIT03)\n INCLUDE SYSLIB(XMIT06)\n INCLUDE SYSLIB(XMITVTAB)\n INCLUDE SYSLIB(UTILABND)\n INCLUDE SYSLIB(UTILDBUG)\n INCLUDE SYSLIB(UTILHEX)\n INCLUDE SYSLIB(UTILLOG)\n INCLUDE SYSLIB(UTILPSR)\n INCLUDE SYSLIB(UTILSNAP)\n INCLUDE SYSLIB(UTILTIOT)\n ENTRY XMIT370\n NAME XMIT370(R)\n./ ADD NAME=LICENSE  0100-02182-02182-0702-00106-00106-00000-XMIT370\n<HTML>\n<HEAD>\n<TITLE>XMIT370 Q Public License</TITLE>\n</HEAD>\n<BODY TEXT=\"black\" BGCOLOR=\"white\" LINK=\"blue\" VLINK=\"purple\"\nonload=\"if(top.frames.length!=0)top.location=self.location;\">\n\n<H1 ALIGN=\"center\">THE Q PUBLIC LICENSE version 1.0<BR>\n<BR>\n<FONT SIZE=\"2\">Copyright (C) 1999 Trolltech AS, Norway.<BR>\n</FONT><FONT SIZE=\"1\">Everyone is permitted to copy and<BR>\ndistribute this license document. </FONT></H1>\n\n<P>The intent of this license is to establish freedom to share and\nchange the software regulated by this license under the open source\nmodel.</P>\n<P>This license applies to any software containing a notice placed\nby the copyright holder saying that it may be distributed under the\nterms of the Q Public License version 1.0. Such software is herein\nreferred to as the Software. This license covers modification and\ndistribution of the Software, use of third-party application\nprograms based on the Software, and development of free software\nwhich uses the Software.</P>\n\n<H2 ALIGN=\"center\">Granted Rights</H2>\n\n<P>1. You are granted the non-exclusive rights set forth in this\nlicense provided you agree to and comply with any and all conditions\nin this license. Whole or partial distribution of the Software, or\nsoftware items that link with the Software, in any form signifies\nacceptance of this license.</P>\n<P>2. You may copy and distribute the Software in unmodified form\nprovided that the entire package, including - but not restricted to\n- copyright, trademark notices and disclaimers, as released by the\ninitial developer of the Software, is distributed.</P>\n<P>3. You may make modifications to the Software and distribute your\nmodifications, in a form that is separate from the Software,\nsuch as patches. The following restrictions apply to modifications:\n</P>\n<BLOCKQUOTE>\n<P>a. Modifications must not alter or remove any copyright notices\nin the Software.</P>\n<P>b. When modifications to the Software are released under this\nlicense, a non-exclusive royalty-free right is granted to the\ninitial developer of the Software to distribute your modification\nin future versions of the Software provided such versions remain\navailable under these terms in addition to any other license(s)\nof the initial developer.</P>\n</BLOCKQUOTE>\n<P>4. You may distribute machine-executable forms of the Software\nor machine-executable forms of modified versions of the Software,\nprovided that you meet these restrictions:</P>\n<BLOCKQUOTE>\n<P>a. You must include this license document in the distribution.</P>\n<P>b. You must ensure that all recipients of the machine-executable\nforms are also able to receive the complete machine-readable source\ncode to the distributed Software, including all modifications,\nwithout any charge beyond the costs of data transfer, and place\nprominent notices in the distribution explaining this.</P>\n<P>c. You must ensure that all modifications included in the\nmachine-executable forms are available under the terms of this\nlicense.</P>\n</BLOCKQUOTE>\n<P>5. You may use the original or modified versions of the Software\nto compile, link and run application programs legally developed by\nyou or by others.</P>\n<P>6. You may develop application programs, reusable components and\nother software items that link with the original or modified\nversions of the Software. These items, when distributed, are\nsubject to the following requirements:</P>\n<BLOCKQUOTE>\n<P>a. You must ensure that all recipients of machine-executable\nforms of these items are also able to receive and use the\ncomplete machine-readable source code to the items without any\ncharge beyond the costs of data transfer.</P>\n<P>b. You must explicitly license all recipients of your items to\nuse and re-distribute original and modified versions of the items\nin both machine-executable and source code forms. The recipients\nmust be able to do so without any charges whatsoever, and they\nmust be able to re-distribute to anyone they choose.</P>\n<P>c. If the items are not available to the general public, and\nthe initial developer of the Software requests a copy of the items,\nthen you must supply one.</P>\n</BLOCKQUOTE>\n\n<H2 ALIGN=\"center\">Limitations of Liability</H2>\n\n<P>In no event shall the initial developers or copyright holders be\nliable for any damages whatsoever, including - but not restricted\nto - lost revenue or profits or other direct, indirect, special,\nincidental or consequential damages, even if they have been advised\nof the possibility of such damages, except to the extent invariable\nlaw, if any, provides otherwise.</P>\n\n<H2 ALIGN=\"center\">No Warranty</H2>\n\n<P>The Software and this license document are provided AS IS with\nNO WARRANTY OF ANY KIND, INCLUDING THE WARRANTY OF DESIGN,\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</P>\n\n<H2 ALIGN=\"center\">Choice of Law</H2>\n\n<P>This license is governed by the Laws of the United States of\nAmerica and the State of Illinois.</P>\n</BODY>\n</HTML>\n./ ADD NAME=RECVBLK  0100-02182-02182-0702-00202-00202-00000-XMIT370\nRECVBLK  TITLE 'Assemble segments into data block'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n* Things to do:\n*----------------------------------------------------------------------\n         U#SET ,\n*----------------------------------------------------------------------\n* Function: Reads (via RECVGET calls) sufficient data segments to\n*           reconstruct a data block\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         R0  =  buffer length\n*         R1  =  buffer address\n*\n* Exit:   R15 =  Return code\n*\n*                0 = buffer contains data block\n*\n*                    R0 = length of block\n*                    R1 = address of block\n*\n*                4 = encountered control segment\n*\n*                    R0 = 0\n*                    R1 = address of control segment\n*\n* Abends: U0016  internal error - R14 useful\n*         U0017  incomplete data block (XMIT probably damaged)\n*         U0018  EOF encountered\n*         U0019  buffer overflow (XMIT probably damaged)\n*\n* Notes:  Caller is responsible for supplying BDW & RDW.\n*         The XMIT file doesn't contain them, and we don't\n*         return them.\n*\n* Debug:  1  entry/exit; exit shows RC\n*         2  exit shows block length\n*            control segment snapped\n*         3  exit shows data block\n*----------------------------------------------------------------------\n* R2     constant; SEGL - (R2) = # data bytes\n* R3     constant; SEGL - (R3) = # data bytes minus one (for EX)\n* R4     @ buffer slot to receive segment\n* R5     buffer length remaining\n* R6     block length\n* R7     internal linkage\n* R8     SEG\n* R9     SEGL - (R3) = segment data EX length\n* R10    # segment data bytes\n* R11    XMTWA\n* R12    base reg\n* R13    savearea/workarea\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\nRECVBLK  UPROC L=L$SA,ID=RBLK,WA=SAVEAREA\n         EJECT ,\n*----------------------------------------------------------------------\n*  Initialize\n*----------------------------------------------------------------------\nINIT     DS    0H\n         BALR  R14,0\n         LTR   R5,R0                        buffer length\n         BZ    DIE\n*\n         BALR  R14,0\n         LTR   R4,R1                        buffer address\n         BZ    DIE\n*\n         UDIAG 1,'RECVBLK entered'\n*\n         ST    R4,SARADDR                   set R1 return\n         LA    R2,SEGBUF-SEG                # seg overhead bytes\n         LA    R3,1(,R2)                    use to get EX length\n         SLR   R6,R6                        accumulate block length\n         SLR   R9,R9                        only need to clear once\n         BALR  R7,0                         faster looping\n         EJECT ,\n*----------------------------------------------------------------------\n* Call RECVGET until block complete\n*----------------------------------------------------------------------\nGETSEG   DS    0H\n         UCALL RECVGET                      retrieve segment (R1 = @)\n         LTR   R8,R1                        got one?\n         BZ    ENDOFILE                     shouldn't happen\n*\n         USING XMITSEG,R8\n         TM    SEGFLG,SEG$C                 control segment?\n         BO    HVCTL\n*\nHVDATA   DS    0H                           have data segment\n         OI    SAFLG1,SA1DATA               saw data segment\n         IC    R9,SEGL                      segment length\n         LR    R10,R9\n*\n         SR    R10,R2                       R10 = # data bytes\n         SR    R5,R10                       buffer overflow?\n         BM    DIEBUF\n*\n         SR    R9,R3                        l' segment data minus one\n         EX    R9,COPYSEG\n         LA    R4,0(R10,R4)                 @ next buffer slot\n         AR    R6,R10                       accumulate block length\n         TM    SEGFLG,SEG$L                 last segment of block?\n         BO    SEGFINI\n*\n         BR    R7                           continue building block\n*\nCOPYSEG  MVC   0(*-*,R4),SEGBUF             copy segment to buffer\n         EJECT ,\n*----------------------------------------------------------------------\n*  Internal error - invalid parms\n*----------------------------------------------------------------------\nDIE      UABEND SAREASON                    R14 useful\n*----------------------------------------------------------------------\n*  Block incomplete (truncated), no SEG$L before control segment\n*----------------------------------------------------------------------\nBLKTRUNC DS    0H\n         STM   R0,R15,XMTREGS\n         ULOG  'RECVBLK incomplete data block'\n         MVI   SAREASON,17\n         B     DIE\n*----------------------------------------------------------------------\n* End Of File\n*----------------------------------------------------------------------\nENDOFILE DS    0H\n         ULOG  'RECVBLK EOF'\n         MVI   SAREASON,17\n         B     DIE\n*----------------------------------------------------------------------\n*  Buffer overflow\n*----------------------------------------------------------------------\nDIEBUF   DS    0H\n         STM   R0,R15,XMTREGS\n         ULOG  'RECVBLK buffer overflow'\n         USNAP 'RECVBLK buffer contents',*SARADDR,(R6)\n         MVI   SAREASON,19\n         B     DIE\n*----------------------------------------------------------------------\n*  Encountered control segment\n*----------------------------------------------------------------------\nHVCTL    DS    0H\n         TM    SAFLG1,SA1DATA               saw DATA segment(s)?\n         BO    BLKTRUNC\n*\n         ST    R8,SARADDR                   return ctl seg addr\n         SLR   R3,R3\n         IC    R3,SEGL\n         UDIAG 2,'RECVBLK encountered control segment',(R8),(R3)\n         LM    R15,R0,=A(4,0)\n         STM   R15,R0,SARET\n         B     EXIT\n         EJECT ,\n*----------------------------------------------------------------------\n*  Segment complete\n*----------------------------------------------------------------------\n*                                           INIT set R1 return\nSEGFINI  DS    0H                           PROC cleared SARC\n         ST    R6,SARLEN                    return block length\n         UPSR  2,'RECVBLK block length',(R6)\n         UDIAG 3,'RECVBLK block',*SARADDR,(R6)\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\nEXIT     DS    0H                           return values set\n         UPSR  1,'RECVBLK exited rc',*SARC\n         LM    R15,R1,SARET\n         UPEND R0=PASS,R1=PASS              return R0, R1, R15\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\n         LTORG ,\n         EJECT ,\n*----------------------------------------------------------------------\n*  Savearea/workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSA       DS    18F                     savearea for called code\n*\nSAFLG1   DS    X                       status flag\nSA1DATA  EQU   128                     saw DATA segment\n*\nSAREASON DS    X                       UABEND reason code\n*\nSARET    DS    0F,0XL12\nSARC     DS    F                       return code\nSARLEN   DS    F                       block length\nSARADDR  DS    A                       block address\n*\n         DS    0D\nL$SA     EQU   *-SAVEAREA\n         EJECT ,\n         PRINT NOGEN\n         WAXMT FUNC=RECV\n         DXMITSEG ,\n         PRINT GEN\n*\nRECVBLK  UFINI DXDRGET,L$SA\n         END   ,\n./ ADD NAME=RECVCTL  0100-02182-02182-0702-00694-00694-00000-XMIT370\n*\n*  Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*\n*  Things to do:\n*\n*  2) research INMFFM vs. INMFM (CMS?)\n*  4) add special-case code for handling DSN key - CLVE\n*     (assuming we're going to do anything wth the DSN, like\n*     display it)\n*  5) PAIRCHAR - verify target field length before copy\n*\n*----------------------------------------------------------------------\n*\n*  XMIT control segment key table definition macro\n*\n         MACRO\n&LABEL   KEY   &KEY,&TYPE,&TEXT,&SAVE=SAV,&FLAG=0\n         LCLA  &L\n         LCLC  &FIELD,&NDX,&SAV\n&NDX     SETC  '&SYSNDX'\n&L       SETA  K'&TEXT-1\n&L       SETA  (&L/2)*2\n&FIELD   SETC  '0'\n&SAV     SETC  '0'\n         AIF   ('&SAVE' EQ '').GEN\n&FIELD   SETC  '&SAVE.&KEY'\n&SAV     SETC  'L''&FIELD-1'\n.GEN     ANOP\n&LABEL   IM#SECT LABEL\nTE&NDX   DC    AL2(INM&KEY)            XMIT control segment key\n         DC    AL1(TAB$&TYPE)          key flag/count-length-value type\n         DC    AL1(TL&NDX)             length of this TAB entry\n         DC    S(&FIELD)               zero or save field Bddd\n         DC    AL1(&FLAG)              special processing flag\n         DC    AL1(&SAV)               SAVxxxxx field length minus one\n         DC    CL&L.&TEXT\nTL&NDX   EQU   *-TE&NDX\n         MEND\n*\nRECVCTL  TITLE 'Handle XMIT Control segments'\n*----------------------------------------------------------------------\n         U#SET ,\n*----------------------------------------------------------------------\n* Function: Read the XMIT control segments, decide which to call:\n*\n*           a) RECVSEQ to handle sequential input datasets\n*\n*           b) RECVPDS to handle partitioned input datasets\n*\n*           If neither of the above, complain & abandon execution.\n*           Depending on debug level, this code may also display\n*           information about the XMIT control segments, such as\n*           key, count, and length/value pairs.\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         R0  =\n*         R1  =\n*\n* Exit:   R15 = return code\n*         R15 = 00 success\n*\n* Abends: yes\n*\n* Notes:\n*\n* Debug:\n*         2 - show status\n*         3 - show control segment\n*         4 - show control segment details\n*         6 - show savearea at exit\n*         7 - show sasavptr\n*             show TAB entry\n*         8 - show saved-hex value\n*----------------------------------------------------------------------\n* R2     scratch\n* R3     current key\n* R4     ptr to current key/count/length/value\n* R5     scratch, TAB scan index\n* R6     scratch, TAB scan entry length\n* R7     scratch, TAB scan limit\n* R8     segment length\n* R9     segment ptr\n* R10    scratch\n* R11    XMTWA\n* R12    base reg\n* R13    savearea\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\nRECVCTL  UPROC L=L$SA,ID=RCTL,WA=SAVEAREA\n         UDIAG 1,'RECVCTL entered'\n         EJECT ,\n*----------------------------------------------------------------------\n*  Initialize\n*----------------------------------------------------------------------\n*\n*  Activate the dummy CS2, for saved fields in TAB which can occur\n*  before we've seen an INMR02 (but are based in the CS2s).\n*  For instance, INMLRECL typically appears in INMR01s as well as\n*  INMR02s.\n*\n         LA     R0,SACS2X                   dummy CS2\n         ST     R0,SA@CS2\n*----------------------------------------------------------------------\n*  Read control segments\n*----------------------------------------------------------------------\nGETSEG   DS    0H\n         TM    SAFLG1,SA1QCS                queued control seg?\n         BNO   CALLGS\n*\nDQSEG    DS    0H\n         MVI   SAREASON,10\n         L     R9,SA@QCS                    dequeue ctl seg\n         USING XMITSEG,R9\n         SLR   R14,R14\n         ICM   R14,1,SEGL\n         BZ    DIE\n*\n         UDIAG 2,'RECVCTL dequeue cseg',(R9),(R14)\n         NI    SAFLG1,255-SA1QCS\n         B     CKSEG\n*\nCALLGS   DS    0H\n         UCALL RECVGET                      retrieve XMIT segment\n         LTR   R9,R1                        returned segment or zero\n         BZ    EOF\n*\nCKSEG    DS    0H\n         MVI   SAREASON,1\n         TM    SEGFLG,SEG$C                 control segment?\n         BNO   DIE                          we should never see data\n         EJECT ,\n*----------------------------------------------------------------------\n*  We have an XMIT control segment\n*----------------------------------------------------------------------\nHAVESEG  DS    0H\n         SLR   R8,R8\n         IC    R8,SEGL                 segment length\n*\n         UDIAG 3,'RECVCTL control segment',(R9),(R8)\n*\n         CLC   SEGCTLNM,=C'INMR02'\n         BNE   DISPLAY\n*\n*  Decide which INMR02 this is, and set up the correct CS2\n*\n*  XMIT files are built by TRANSMIT (or XMIT370), and the order\n*  of the INMR02s reflects the sequence of operations that TRANSMIT\n*  performed.  For an IEBCOPY unloaded PDS, the IEBCOPY INMR02 is\n*  first, then the INMCOPY INMR02.  When performing the RECEIVE\n*  function we need to reverse the order (INMCOPY first, then\n*  IEBCOPY).  We could queue up the INMR02s, but there's only two\n*  so that's more trouble than necessary.  Rather, we stuff all the\n*  saved fields in the associated CS2 area.  The SA@CS2 field\n*  determines which of those CS2s is to be current.\n*\n*  I might have to re-examine this logic once I get to the\n*  point of supporting embedded messages (TERM flag), but I'm\n*  not there yet and have lots to do before then\n*\n         OI    SAFLG1,SA1CS2           INMR02 seen\n         L     R15,SA@CS2              current CS2 (might be dummy)\n         LA    R15,L$CS2(,R15)         @ next CS2\n         LA    R0,SACS2BAD             limit\n         CR    R15,R0                  too many INMR02s?\n         BL    NEWCS2\n*\n         UDIAG 0,'RECVCTL too many INMR02s'\n         MVI   SAREASON,2\n         B     DIE\n*\nNEWCS2   DS    0H\n         ST    R15,SA@CS2\n         USING CS2,R15\n*\n*  Retain # files in XMIT from INMR02\n*\n         SLR   R0,R0\n         ICM   R0,15,SEGC2NUM          # files present in XMIT\n         ST    R0,CS2#FILE\n         DROP  R15\n         UPSR  2,'RECVCTL INMR02: files present in XMIT',(R0)\n         EJECT ,\n*----------------------------------------------------------------------\n*  Print the details header line\n*----------------------------------------------------------------------\nDISPLAY  DS    0H\n         UDIAG 4,'RECVCTL control segment details'\n*\n         MVI   SAMSG,C' '\n         MVC   SAMSG+1(L$SAMSG-1),SAMSG     clear message area\n         MVC   SAMSG(3),=C'<4>'\n         MVC   SATYPE,=C'TYPE'\n         MVC   SAKEY,=C'KEY '\n         MVC   SACOUNT-1(5),=C'COUNT'\n         MVC   SALEN,=C'LEN '\n         MVC   SAVALUE(5),=C'VALUE'\n         MVC   SATEXT(11),=C'DESCRIPTION'\n         BAL   R14,MSGOUT                   label output to follow\n         EJECT ,\n*----------------------------------------------------------------------\n*  Examine each key in the control segment\n*----------------------------------------------------------------------\nDETAILS  DS    0H\n         LA    R4,SEGCKEYS                  standard 1st key offset\n         CLC   SEGCTLNM,=C'INMR02'          non-standard?\n         BNE   *+8\n         LA    R4,SEGC2KEY                  INMR02 1st key offset\n*\n*  R4 @ key, R8 segment length\n*\nNEXTKEY  DS    0H\n         LA    R0,SEG(R8)                   @ end of segment\n         CR    R4,R0\n         BNL   FINSEG                       exhausted keys, finish seg\n*\n         SLR   R3,R3\n         ICM   R3,3,0(R4)                   grab key\n         LM    R5,R7,=A(TABLE,0,TABEND-1)   set TAB scan regs\n         USING TAB,R5\n*\n*  Scan TAB for matching key\n*\nSCAN     DS    0H\n         IC    R6,TABELEN                   get TAB entry length\n         CLM   R3,3,TABKEY                  found key?\n         BE    FOUND\n*\n         LA    R5,0(R6,R5)                  @ next entry\n         CR    R5,R7                        fell off end?\n         BL    SCAN\n*\n         UPSR  0,'RECVCTL unrecognized key (hex) value',(R3)\n         UPSR  0,'RECVCTL unrecognized key address',(R4)\n         MVI   SAREASON,3\nSNAPDIE  UDIAG 0,'RECVCTL control segment',(R9),(R8)\n         B     DIE\n         EJECT ,\n*----------------------------------------------------------------------\n*  Found key, issue descriptive message(s) based on key type\n*----------------------------------------------------------------------\nCOPYTEXT MVC   SATEXT(*-*),TABTEXT          copy text to display line\n*\nFOUND    DS    0H\n         SLR   R15,R15\n         IC    R15,TABELEN\n         UDIAG 7,'RECVCTL TAB entry',(R5),(R15)\n*\n         ST    R5,SATABENT                  save @ entry for PAIR code\n         LA    R0,L$TABOVH                  TAB entry overhead\n         SR    R6,R0                        R6 = text length\n         MVI   SAMSG,C' '\n         MVC   SAMSG+1(L$SAMSG-1),SAMSG     clear message area\n         MVC   SAMSG(3),=C'<4>'\n*\n         LR    R0,R3\n         LA    R1,SAWORK\n         UCALL UTILHEX\n         MVC   SAKEY,SAWORK+4\n         BCTR  R6,0\n         EX    R6,COPYTEXT\n         LA    R4,L$CKEY(,R4)               bump to next key/count\n*\n*  Set up pointer to save field for ease of handling in the PAIRS code\n*\n*  We build a LA instruction in SAINSTR (X'4110ssss') from the\n*  S-con in the current TAB entry, then execute it to point R1\n*  at the field which will be used to save the current value.\n*  We use an S-con, since we only really care about the INMR02 values;\n*  other values are either ignored or saved somewhere in SAVEAREA.\n*\n         LA    R1,SABOGUS                   field for unsaved fields\n         CLC   TABSCON,=AL2(0)              is this one?\n         BE    NULLSAVE\n*\n*  Avoid wiping out CS2s with INMR03 data by always pointing\n*  saved fields to SABOGUS\n*\n         CLC   SEGCTLNM,=C'INMR03'\n         BE    NULLSAVE\n*\n         MVC   SAINSTR(2),=X'4110'          initialize dynamic instr\n         MVC   SAINSTR+2(2),TABSCON         add S-con\n         MVI   SAREASON,4\n         ICM   R15,15,SA@CS2                select current CS2\n         BZ    DIE\n*\n*  The following instruction requires R15 point at (some) CS2\n*\n         EX    R0,SAINSTR                   R1 @ save field\n*\nNULLSAVE DS    0H\n         ST    R1,SASAVPTR\n         UPSR  7,'RECVCTL sasavptr',(R1)\n         EJECT ,\n*----------------------------------------------------------------------\n*  Examine key type\n*----------------------------------------------------------------------\n         CLI   TABTYPE,TAB$FLAG             flag only?\n         BNE   CKCLV\n*\n*  Flag only\n*\n         L     R1,SASAVPTR                  @ save field\n         MVI   0(R1),C'Y'                   flag set\n*\n         MVC   SATYPE,=C'FLAG'\n         BAL   R14,MSGOUT                   display message\n         B     NEXTKEY\n*\n*  Common setup for either CLVE or CLVH\n*\nCKCLV    DS    0H\n         SLR   R0,R0\n         ICM   R0,3,0(R4)\n         ST    R0,SAXCOUNT                  save count for PAIR code\n         LA    R1,SAWORK\n         UCALL UTILHEX\n         MVC   SACOUNT,SAWORK+4\n         LA    R4,L$CCOUNT(,R4)             bump to length/value pairs\n*\n         CLI   TABTYPE,TAB$CLVE             EBCDIC?\n         BNE   CKCLVH\n*\n*  Key, Count, (Length,Value) pairs - EBCDIC\n*\nCLVE     DS    0H\n         MVC   SATYPE,=C'CLVE'\n         B     PAIRS\n*\nCKCLVH   DS    0H\n         MVI   SAREASON,5\n         CLI   TABTYPE,TAB$CLVH             HEX?\n         BNE   DIE\n*\n*  Key, Count, (Length,Value) pairs - HEX\n*\n         MVC   SATYPE,=C'CLVH'\n         EJECT ,\n*----------------------------------------------------------------------\n*  Handle length/value pairs (R4 @ first length, SAXCOUNT = # pairs)\n*----------------------------------------------------------------------\nPAIRS    DS    0H\n         BAL   R14,MSGOUT\n         ICM   R2,15,SAXCOUNT               # pairs\n         BNZ   PAIRLOOP\n*\n         UPSR  0,'RECVCTL key count = zero; key (hex) value',(R3)\n         MVI   SAREASON,6\n         B     SNAPDIE\n*\nPAIRLOOP DS    0H\n         SLR   R0,R0\n         ICM   R0,3,0(R4)                   grab length\n         LR    R10,R0                       save length in safe reg\n         LA    R1,SAWORK\n         UCALL UTILHEX\n         MVC   SALEN,SAWORK+4\n         LA    R4,L$CLEN(,R4)               point at value\n*\n         CLI   TABTYPE,TAB$CLVE             EBCDIC?\n         BNE   PAIRHEX\n         EJECT ,\n*\n*  EBCDIC - R4 @ value, R10 = value length\n*\nPAIRCHAR DS    0H\n         L     R15,SASAVPTR                 @ save field\n*\n*  set up initial blanks in char fields, so that short values\n*  (like CL7 ddname) are right blank padded after save\n*\n         MVI   0(R15),C' '                  blank 1st save char\n         SLR   R14,R14\n         ICM   R14,1,TABSAVL                L' save field minus one\n         BZ    PCBLNKD                      only one char, already done\n         BCTR  R14,0\n         EX    R14,BLNKSAVE                 propagate blank\nPCBLNKD  DS    0H\n*\n*  set up initial blanks in char fields\n*\n         BCTR  R10,0\n         EX    R10,COPYVALU                 copy value to display line\n         EX    R10,COPYSAVE                 copy value to save field\n         BAL   R14,MSGOUT                   display message\n         LA    R4,1(R10,R4)                 at next key/length\n         BCT   R2,PAIRLOOP\n         B     NEXTKEY\n*\nCOPYVALU MVC   SAVALUE(*-*),0(R4)\nCOPYSAVE MVC   0(*-*,R15),0(R4)\nBLNKSAVE MVC   1(*-*,R15),0(R15)\n         EJECT ,\n*\n*  HEX - R4 @ value, R10 = value length\n*\nPAIRHEX  DS    0H\n         MVI   SAREASON,7\n         C     R10,=F'4'                    max supported HEX length\n         BH    DIE\n*\n*  Copy hex value to save field\n*\n         SLL   R10,2\n         L     R1,SASAVPTR\n         SLR   R0,R0\n         EX    R0,RETRIEVE-4(R10)\n         STCM  R0,15,0(R1)                  store saved field\n         SRL   R10,2\n         UPSR  8,'RECVCTL saved-hex',(R0)\n*\n*  display hex value, one char at a time\n*\n         LA    R5,SAVALUE                   first hex char slot\n         LA    R6,SALIMIT                   past last valid msg char\n         LA    R7,0(R10,R4)                 @ next key/length\n*\nPHLOOP   DS    0H\n         CR    R5,R6                        too much data?\n         BNL   PHFINI                       yes, bail early\n*\n         IC    R0,0(R4)                     grab hex value byte\n         LA    R1,SAWORK\n         UCALL UTILHEX\n         MVC   0(2,R5),SAWORK+6\n         LA    R5,2(,R5)\n         LA    R4,1(,R4)\n         BCT   R10,PHLOOP\n*\nPHFINI   DS    0H\n         BAL   R14,MSGOUT\n         LR    R4,R7                        new key/length ptr\n         BCT   R2,PAIRLOOP\n         B     NEXTKEY\n*\nRETRIEVE ICM   R0,1,0(R4)\n         ICM   R0,3,0(R4)\n         ICM   R0,7,0(R4)\n         ICM   R0,15,0(R4)\n*\n*  Internal error\n*\nDIE      UABEND SAREASON                    internal error\n*----------------------------------------------------------------------\n*  MSGOUT subroutine, returns via R14\n*----------------------------------------------------------------------\n*\n*  This code should only be called to display debug level 4 messages\n*\nMSGOUT   DS    0H\n         ST    R14,SASUB14                  save return reg\n         UDIAG 4,SKIP=MSGCLEAR\n         ULOG  SAMSG,L$SAMSG                display message\nMSGCLEAR DS    0H\n         MVI   SAMSG,C' '\n         MVC   SAMSG+1(L$SAMSG-1),SAMSG     clear message area\n         MVC   SAMSG(3),=C'<4>'\n         L     R14,SASUB14                  restore return ret\n         BR    R14                          return\n         EJECT ,\n*----------------------------------------------------------------------\n*  Control segment parse complete\n*----------------------------------------------------------------------\nFINSEG   DS    0H\n         CLC   SEGCTLNM,=C'INMR06'\n         BNE   FSCK03\n*\n         OI    SAFLG1,SA1MR6                INMR06 (trailer) seen\n         B     GETSEG                       let RECVGET close XMITIN\n*\nFSCK03   DS    0H\n         CLC   SEGCTLNM,=C'INMR03'\n         BNE   GETSEG\n*\n         TM    SAFLG1,SA1CS2                pending CS2(s)?\n         BO    FSCS2\n*\n         ULOG  'RECVCTL ERROR: invalid XMIT'\n         ULOG  'RECVCTL ERROR: INMR03, but no INMR02(s)'\n         MVI   SAREASON,8\n         B     DIE\n*\n*  Pop each CS2 off the stack, call RECVUTIL to handle\n*\nFSCS2    DS    0H\n         L     R1,SA@CS2                    current CS2\n*\nFSUTIL   DS    0H\n         UCALL RECVUTIL                     handle INMR02 utility\n         LTR   R15,R15\n         BZ    FSOK\n*\n         MVI   SAREASON,9\n         C     R15,=F'4'                    returned ctl seg?\n         BNE   DIE\n*\n         MVI   SAREASON,11                  error if SEGL=0\n         ST    R1,SA@QCS                    queue control seg\n         SLR   R14,R14\n         ICM   R14,1,SEGL-SEG(R1)\n         BZ    DIE\n         OI    SAFLG1,SA1QCS\n         UDIAG 2,'RECVCTL RECVUTIL returned ctl seg',(R1),(R14)\n*\nFSOK     DS    0H\n         L     R1,SA@CS2\n         XC    0(L$CS2,R1),0(R1)            clear processed CS2\n         LA    R0,L$CS2\n         SR    R1,R0                        unstack CS2\n         ST    R1,SA@CS2                    possible CS2 re-use\n         LA    R0,SACS2X                    dummy CS2\n         CR    R1,R0                        another CS2?\n         BH    FSUTIL                       yes, go handle it\n*\n         UDIAG 2,'RECVCTL exhausted CS2s'\n         NI    SAFLG1,255-SA1CS2            no pending CS2s\n         B     GETSEG\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\nEOF      DS    0H\n         UDIAG 2,'RECVCTL EOF'\n         TM    SAFLG1,SA1MR6                saw trailer?\n         BO    EXIT\n*\n         ULOG  'RECVCTL WARNING: INMR06 (trailer) missing'\n         ULOG  'RECVCTL WARNING: XMIT file may be damaged'\n*\nEXIT     DS    0H\n         UDIAG 6,'RECVCTL savearea at exit',(R13),SACS2X\n         UDIAG 1,'RECVCTL exited'\n         UPEND RC=0\n         EJECT ,\n*----------------------------------------------------------------------\n*  XMIT control segment key attributes (see TAB DSECT)\n*----------------------------------------------------------------------\n         PUSH  USING\n         USING CS2,R15\nTABLE    DS    0D\n         KEY   DDNAM,CLVE,'DDNAME'\n         KEY   DSNAM,CLVE,'DSN',FLAG=TAB1DSN\n         KEY   ERRCD,CLVH,'receive error code'\n         KEY   FACK,CLVH,'acknowledgement request'\n         KEY   FNODE,CLVE,'origin node name'\n         KEY   FTIME,CLVE,'origin time stamp'\n         KEY   FUID,CLVE,'origin userid'\n         KEY   FVERS,CLVE,'origin version number'\n         KEY   NUMF,CLVH,'number of files'\n         KEY   RECCT,CLVH,'transmitted record count'\n         KEY   SECND,CLVH,'secondary space qty'\n         KEY   TNODE,CLVE,'target node name'\n         KEY   TTIME,CLVE,'destination time stamp'\n         KEY   TUID,CLVE,'target userid'\n         KEY   TYPE,CLVH,'data set type'\n*\n         KEY   USERP,CLVE,'user parm string',SAVE=\n*\n         KEY   BLKSZ,CLVH,'BLKSIZE',SAVE=CS2\n         KEY   DIR,CLVH,'directory blocks',SAVE=CS2\n         KEY   CREAT,CLVH,'creation date',SAVE=CS2\n         KEY   DSORG,CLVH,'DSORG',SAVE=CS2\n         KEY   EXPDT,CLVH,'expiration date',SAVE=CS2\n         KEY   LCHG,CLVH,'last changed date',SAVE=CS2\n         KEY   LRECL,CLVH,'LRECL',SAVE=CS2\n         KEY   LREF,CLVH,'last referenced date',SAVE=CS2\n         KEY   MEMBR,CLVE,'member',SAVE=CS2\n         KEY   RECFM,CLVH,'RECFM',SAVE=CS2\n         KEY   SIZE,CLVH,'approx file size (bytes)',SAVE=CS2\n         KEY   TERM,FLAG,'terminal alloc (msg)',SAVE=CS2\n         KEY   UTILN,CLVE,'utility name',SAVE=CS2\n*\n*  I've not seen an example of the next key, so the following is\n*  a great big guess.\n*\n         KEY   FFM,CLVE,'filemode number (CMS)',SAVE=\nTABEND   DS    0X\n         POP   USING\n*\n         LTORG ,\n         EJECT ,\n*----------------------------------------------------------------------\n*  XMIT control segment key attributes table\n*----------------------------------------------------------------------\nTAB      DSECT ,\nTABKEY   DS    XL2      INMRxxxx key\n*\nTABTYPE  DS    X        key type:\nTAB$CLVH EQU   1             key, count, (length,value) pairs - hex\nTAB$CLVE EQU   2             key, count, (length,value) pairs - EBCDIC\nTAB$FLAG EQU   3             flag only (no count, length, value)\n*\nTABELEN  DS    X        length of complete TAB entry (including text)\n*\nTABSCON  DS    XL2      zero (don't save) or S-con for save field\n*                       valid base regs: R13 (SAVEAREA), R15 (CS2)\n*\nTABFLG1  DS    X        flags for PAIR code\nTAB1DSN  EQU   128           special DSN handling\n*\nTABSAVL  DS    X        length of save field minus one\n*\nTABTEXT  DS    0C       description of related key\n*\nL$TABOVH EQU   *-TAB    TAB entry overhead length\n*\n         EJECT ,\n         DRCS2 ,\n         EJECT ,\n*----------------------------------------------------------------------\n*  Savearea/workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSA       DS    18F\n*\nSAFLG1   DS    X             status flag\nSA1MR6   EQU   128                INMR06 seen (trailer)\nSA1CS2   EQU   64                 INMR02 seen\nSA1QCS   EQU   32                 control seg queued\n*\nSAREASON DS    X             UABEND reason code\n*\nSAWORK   DS    D             hex conversion return\nSAXCOUNT DS    F             hex count\nSASAVPTR DS    A             zero or ptr to key value save field\nSATABENT DS    A             ptr to TAB entry associated with key\nSAINSTR  DS    F             dynamically built instruction\nSA@CS2   DS    A             pointer to current INMR02 save (CS2)\nSASUB14  DS    A             low-level subroutine return reg\nSA@QCS   DS    A             addr of queued control seg\n*\n*  dynamically constructed message giving segment details\n*\nSAMSG    DS    0C\n         DS    CL4\nSATYPE   DS    CL4\n         DS    CL4\nSAKEY    DS    CL4\n         DS    CL2\nSACOUNT  DS    CL4\n         DS    CL2\nSALEN    DS    CL4\n         DS    CL2\nSAVALUE  DS    CL20\n         DS    CL2\nSATEXT   DS    CL30\nSALIMIT  DS    0C                      last valid message char\nL$SAMSG  EQU   *-SAMSG\n         DS    0D\nSABOGUS  DS    CL256                   protection from runaway SAVALUEs\n*                                      and slot for unsaved fields\n*\n*  Save fields\n*\n         DS    0D\nSAVDSNAM DS    CL44\nSAVTNODE DS    CL8\nSAVTUID  DS    CL8\nSAVFNODE DS    CL8\nSAVFUID  DS    CL8\nSAVFVERS DS    CL8\nSAVFTIME DS    CL16\nSAVTTIME DS    CL16\nSAVNUMF  DS    F\nSAVFACK  DS    F\nSAVERRCD DS    F\nSAVRECCT DS    F\nSAVDDNAM DS    CL8\nSAVSECND DS    F\nSAVTYPE  DS    F\n*\n*  CS2 stack (saved INMR02 info)\n*\nSACS2    DS    0D\nSACS2X   DS    CL(L$CS2)     CS2 - dummy\nSACS2A   DS    CL(L$CS2)     CS2 for 1st INMR02 (usually IEBCOPY)\nSACS2B   DS    CL(L$CS2)     CS2 for 2nd INMR02 (usually INMCOPY)\nSACS2C   DS    CL(L$CS2)     CS2 for 3rd INMR02 (future plans)\nSACS2BAD EQU   *             too many CS2s if past here\n*\n         DS    0D\nL$SA     EQU   *-SAVEAREA\n         EJECT ,\n         PRINT NOGEN\n         WAXMT FUNC=RECV\n*        EJECT ,\n         DXMITSEG ,\n*        EJECT ,\n         PRINT ON,GEN\nRECVCTL  UFINI DXDRCTL,L$SA\n         END   ,\n./ ADD NAME=RECVGET  0100-02182-02182-0702-00307-00307-00000-XMIT370\nRECVGET  TITLE 'Get XMIT segment'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n* Things to do:\n*----------------------------------------------------------------------\n         U#SET ,\n*----------------------------------------------------------------------\n* Function: Returns a complete XMIT segment read from XMITIN, or EOF\n*\n*           XMITIN DCB is opened on the first call,\n*           closed on EOF.\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         R0  =\n*         R1  =\n*\n* Exit:   R1  =  Address of segment (XMITSEG)\n*                upon EOF, R1 = 0\n*\n* Abends: U0001 XMITIN open failed\n*         U0002 internal error (R0 = code)\n*\n* Notes: RGSWA contains a buffer holding residual data, which\n*        represents data not yet returned to the caller, to be\n*        saved for a later call to RECVGET.\n*----------------------------------------------------------------------\n* R2     RGSWA (our workarea)\n* R3     DCB\n* R4     XMITSEG (not strictly necessary, only covers one instruction)\n*\n* R5     pointer to residual data within RGSBUF\n* R6     RGSROFF   - offset to residual data within RGSBUF\n*\n* R7     SEGL      - segment length for segment being built in RGSSEG\n* R8     scratch, pointer within RGSSEG where residual data is appended\n* R9     scratch, RGSSL    - # segment bytes currently in RGSSEG\n*\n* R10    scratch (careful)\n* R11    XMTWA\n* R12    base reg\n* R13    savearea/workarea\n*----------------------------------------------------------------------\nL$REC    EQU   80                           XMITIN LRECL\nINTE$1   EQU   1                            internal errors\nINTE$2   EQU   2\nINTE$3   EQU   3\nINTE$4   EQU   4\n         TITLE ' '\nRECVGET  UPROC L=L$SA,ID=RGET,WA=SAVEAREA\n         UDIAG 1,'RECVGET entered'\n*\n         ICM   R2,15,XMT@GS                 find our workarea\n         BNZ   NORMAL                       already init'd, go\n*----------------------------------------------------------------------\n*  Initialize RGSWA\n*----------------------------------------------------------------------\n         UDIAG 2,'RECVGET: initializing RGSWA'\n         LA    R2,XMTRGSWA\n         USING RGSWA,R2\n         UZERO (R2),L$RGSWA                 clear storage\n         ST    R2,XMT@GS                    save ptr to our workarea\n*----------------------------------------------------------------------\n*  Initialize - null segment\n*----------------------------------------------------------------------\nNORMAL   DS    0H\n         LA    R4,RGSSEG                    segment being built\n         USING XMITSEG,R4\n         NI    RGSFLG1,255-RGS1FINI         no segment in RGSSEG\n         SLR   R0,R0\n         STH   R0,RGSSL                     zero bytes in segment\n         XC    RGSSEG,RGSSEG                clear segment\n*----------------------------------------------------------------------\n*  Check for call past EOF\n*----------------------------------------------------------------------\n         TM    RGSFLG2,RGS2EOF              already hit EOF?\n         BNO   CKDCB\n         UDIAG 2,'RECVGET EOF at entry'\n         B     EXIT\n*----------------------------------------------------------------------\n*  Open XMITIN\n*----------------------------------------------------------------------\nCKDCB    DS    0H\n         LA    R3,RGSDCB\n         USING IHADCB,R3\n         TM    DCBOFLG1,DCBOFOPN            dcb open?\n         BO    DCBOPEN\n*\n         UDIAG 2,'RECVGET: opening XMITIN'\n         MVC   RGSDCB(L$DCB),MODLDCB        copy model DCB macro\n         MVC   RGSOPN(L$OPN),MODLOPN        copy model OPEN macro\n         OPEN  ((R3),INPUT),MF=(E,RGSOPN)\n         TM    DCBOFLG1,DCBOFOPN            opened?\n         BO    DCBOPEN\n*\n         ULOG  'RECVGET: XMITIN DCB open error'\n         UDIAG 0,'RECVGET: RGSWA',(R2),L$RGSWA\n         MVI   SAREASON,1                   XMITIN DCB didn't open\n         B     UABEND\n*\nDCBOPEN  DS    0H\n         EJECT ,\n*----------------------------------------------------------------------\n*  Main loop - If no more residual data, read\n*----------------------------------------------------------------------\n*\n*  Note it might be possible for the residual data to contain more\n*  than one segment (or portions thereof), so we may leave RECVGET\n*  with residual data still pending.\n*\nRESUME   DS    0H\n         TM    RGSFLG1,RGS1FINI             seg complete?\n         BO    EXIT                         yes, return to caller\n*\n         TM    RGSFLG1,RGS1RES              residual data?\n         BNO   READ                         no, need to get data\n         EJECT ,\n*----------------------------------------------------------------------\n*  Copy residual data to segment return area (RGSSEG).\n*----------------------------------------------------------------------\nCOPY     DS    0H\n         LH    R6,RGSROFF                   offset to residual data\n         LA    R5,RGSBUF(R6)                @ residual data\n*\n         LA    R0,INTE$1                    internal error #\n         LA    R10,L$REC                    XMITIN LRECL\n         SR    R10,R6                       # residual data bytes\n         BNP   DIE\n*\n         LH    R8,RGSSL                     # bytes in RGSSEG already\n         LR    R9,R8\n         AR    R9,R10\n         LA    R8,RGSSEG(R8)                @ next seg byte to append\n*\n         UDIAG 9,'RECVGET: <COPY> regs',XMTREGS,16*4,REGS=YES\n*\n         BCTR  R10,0\n         EX    R10,COPYRES                  copy residual to segment\n         LA    R10,1(,R10)\n         STH   R9,RGSSL                     new # bytes in RGSSEG\n*\n*  It is now safe to examine SEGL, since the above code copied at\n*  least one byte to RGSSEG, so no matter what else, SEGL is valid.\n*\n         SLR   R7,R7\n         IC    R7,SEGL                 segment length\n*\n         UDIAG 9,'RECVGET: <COPY> seg.segl',RGSSEG,(R7)\n         B     CKSEG\n*\nCOPYRES  MVC   0(*-*,R8),0(R5)\n         EJECT ,\n*----------------------------------------------------------------------\n*  Determine if the segment is now complete\n*----------------------------------------------------------------------\nCKSEG    DS    0H\n         CR    R7,R9                   seglen : bytes in seg\n         BL    SCR                     segment   complete,    residual\n         BE    SCNR                    segment   complete, no residual\n*\n*  The segment is not yet complete, and we've consumed all of\n*  the residual data; get some more\n*\nSINR     DS    0H                           seg incomplete, no residual\n         NI    RGSFLG1,255-RGS1RES\n         SLR   R6,R6\n         STH   R6,RGSROFF\n         XC    RGSBUF,RGSBUF\n         UDIAG 5,'RECVGET SINR',XMTREGS,16*4,REGS=YES\n         B     READ                         finish segment\n*\n*  The segment is now complete, but ... there's some residual\n*  data we need to reclaim from the RGSSEG\n*\nSCR      DS    0H                           segment complete, residual\n         UDIAG 5,'RECVGET SCR1',XMTREGS,16*4,REGS=YES\n         SR    R9,R7                   # bytes residual data remaining\n         OI    RGSFLG1,RGS1FINI+RGS1RES         seg complete\n         LA    R6,L$REC\n         SR    R6,R9                        new residual data offset\n         STH   R6,RGSROFF                   new resoff\n         UDIAG 5,'RECVGET SCR2',XMTREGS,16*4,REGS=YES\n         B     EXIT\n*\n*  The segment is now complete, and exactly consumed the residual\n*  data\n*\nSCNR     DS    0H                           seg complete, no residual\n         OI    RGSFLG1,RGS1FINI                 seg complete\n         NI    RGSFLG1,255-RGS1RES              no residual\n         SLR   R6,R6\n         STH   R6,RGSROFF\n         XC    RGSBUF,RGSBUF\n         UDIAG 5,'RECVGET SCNR',XMTREGS,16*4,REGS=YES\n         B     EXIT\n*\nDIE      STM   R0,R15,XMTREGS\n         UPSR  0,'RECVGET internal error',(R0)\n         UDIAG 0,'RECVGET regs',XMTREGS,16*4\n         MVI   SAREASON,2\nUABEND   UABEND SAREASON\n*\n         EJECT ,\n*----------------------------------------------------------------------\n*  Read input record from XMITIN\n*----------------------------------------------------------------------\n*\n*  We're not allowed to read new data until we've drained RGSBUF\n*  Likewise, reading past EOF seems excessively dense\n*\nREAD     DS    0H\n         LA    R0,INTE$2\n         TM    RGSFLG1,RGS1RES              residual data?\n         BO    DIE\n*\n         LA    R0,INTE$3\n         TM    RGSFLG2,RGS2EOF              already hit EOF?\n         BO    DIE\n*\n         LR    R10,R13                      save workarea ptr\n         LA    R13,SADMSA                   provide data mgt savearea\n         GET   (R3),RGSBUF                  read record\n         LR    R13,R10                      restore workarea ptr\n         TM    RGSFLG2,RGS2EOF              EOF?\n         BO    ENDOFILE\n*\n         UDIAG 3,'RECVGET: GET record',RGSBUF,L'RGSBUF\n*\n*  Indicate residual data exists, restart residual code\n*\n         SLR   R6,R6\n         STH   R6,RGSROFF                   offset = 0\n         OI    RGSFLG1,RGS1RES              residual data valid\n         B     RESUME                       continue building segment\n         EJECT ,\n*----------------------------------------------------------------------\n* End Of File - XMITIN EODAD routine\n*----------------------------------------------------------------------\nEOFRTN   DS    0H\n         OI    RGSFLG2,RGS2EOF              XMITIN EOF\n         BR    R14\n*----------------------------------------------------------------------\n*  End Of File\n*----------------------------------------------------------------------\nENDOFILE DS    0H\n         UDIAG 2,'RECVGET: EOF, closing XMITIN'\n         MVC   RGSCLOS(L$CLOS),MODLCLOS     copy model CLOSE macro\n         CLOSE ((R3),),MF=(E,RGSCLOS)\n         TM    RGSFLG1,RGS1FINI             segment complete?\n         BO    EXIT                         fine, done\n*\n         ICM   R10,3,RGSSL\n         BZ    EXIT\n*\n         UDIAG 2,'RECVGET incomplete seg at EOF',RGSSEG,L'RGSSEG\n         B     EXIT\n         EJECT ,\n*----------------------------------------------------------------------\n*  Return segment or EOF to caller\n*----------------------------------------------------------------------\nEXIT     DS    0H                           return code already set\n         UDIAG 9,'RECVGET: partial RGSWA at exit',(R2),L$RGSNAP\n         UDIAG 1,'RECVGET exited'\n         SLR   R1,R1                        assume EOF, R1 = 0\n         TM    RGSFLG1,RGS1FINI             valid segement to return?\n         BNO   *+8\n         LA    R1,RGSSEG                    R1 @ returned segment\n         UPEND R1=PASS,RC=0                 return R1\n         EJECT ,\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\nMODLOPN  OPEN  (,),MF=L                model OPEN\nL$OPN    EQU   *-MODLOPN               l' model open\n*\nMODLCLOS CLOSE (,),MF=L                model CLOSE\nL$CLOS   EQU   *-MODLCLOS              l' model close\n*\nMODLDCB  DCB   DDNAME=XMITIN,                                          +\n               EODAD=EOFRTN,                                           +\n               MACRF=GM,DSORG=PS,RECFM=FB,                             +\n               LRECL=80\nL$DCB    EQU   *-MODLDCB\n*\n         LTORG ,\n         EJECT ,\n*----------------------------------------------------------------------\n*  Savearea/workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSA       DS    18F\nSADMSA   DS    18F                     Data Management savearea\nSAREASON DS    X                       UABEND reason code\nSAEND    DS    0D\nL$SA     EQU   *-SAVEAREA\n         EJECT ,\n         DXMITSEG ,\n         EJECT ,\n         WAXMT FUNC=RECV\n         EJECT ,\n         PRINT NOGEN\n         DCBD  DSORG=PS,DEVD=DA\n         PRINT GEN\nRECVGET  UFINI DXDRGET,L$SA\n         END   ,\n./ ADD NAME=RECVRCPY 0100-02182-02182-0702-00255-00255-00000-XMIT370\nRECVRCPY TITLE 'RECEIVE INMCOPY'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  Things to do:\n*----------------------------------------------------------------------\n         U#SET ,\n*----------------------------------------------------------------------\n* Function: Copy XMIT data blocks to the specified DDNAME\n*\n* Entry:  S/370 ECMODE KEY=8, STATE=PROB, AUTHORIZED\n*\n*         R0  = CL8'ddname' (output file)\n*         R1  = address of CS2 representing INMCOPY\n*\n* Exit:   R15 = return code\n*\n*               00   success\n*               04   control segment returned (everything else OK)\n*\n*         R1  = zero or address of control segment\n*\n* Abends: yes\n*\n* Notes:\n*\n* Debug:  1  -  entry/exit; show exit rc\n*         2  -  CS2 at entry, DCB (open/close), RECVBLK nonzero rc\n*         3  -  show returned data block\n*----------------------------------------------------------------------\n* R2\n* R3     DCB\n* R4\n* R5\n* R6\n* R7\n* R8     buffer addr\n* R9     buffer length\n* R10    CS2\n* R11    XMTWA\n* R12    base reg\n* R13    savearea\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\nRECVRCPY UPROC L=L$SA,ID=RCPY,WA=SAVEAREA\n         EJECT ,\n*----------------------------------------------------------------------\n*  Initialize\n*----------------------------------------------------------------------\nINIT     DS    0H\n         BALR  R14,0\n         LTR   R10,R1                       save CS2\n         BZ    DIE\n*\n         BALR  R14,0\n         LTR   R15,R0\n         BZ    DIE\n*\n         MVC   SADDNAME,0(R15)              save DDNAME\n*\n         USING CS2,R10\n         UDIAG 1,'RECVRCPY entered'\n         UDIAG 2,'RECVRCPY INMCOPY CS2 at entry',(R10),L$CS2\n         LA    R14,L$CS2\n         SR    R10,R14\n         UDIAG 2,'RECVRCPY IEBCOPY CS2 at entry',(R10),L$CS2\n         LA    R14,L$CS2\n         AR    R10,R14\n         EJECT ,\n*----------------------------------------------------------------------\n*  Open output DDNAME\n*----------------------------------------------------------------------\nCKDCB    DS    0H\n         LA    R3,SADCB\n         USING IHADCB,R3\n         MVC   SADCB(L$DCB),MODLDCB         copy model DCB macro\n         MVC   SAOPN(L$OPN),MODLOPN         copy model OPEN macro\n         MVC   DCBDDNAM,SADDNAME            overlay DDNAME\n*\n         MVC   DCBDSORG,CS2DSORG+2          overlay DSORG=PS\n*\n*  For some reason, RECFM isn't right in either the INMCOPY\n*  or IEBCOPY CS2s.  We know it should be VS.\n*\n         MVC   DCBRECFM,=X'48'              overlay RECFM=VS\n*\n*        LA    R14,L$CS2\n*        SR    R10,R14                      back up to IEBCOPY CS2\n*\n         BALR  R14,0\n         ICM   R0,15,CS2BLKSZ               have BLKSIZE spec'd?\n         BZ    DIE\n         STCM  R0,3,DCBBLKSI                overlay BLKSIZE\n*\n*        BALR  R14,0\n*        ICM   R0,15,CS2LRECL               have LRECL spec'd?\n*        BZ    DIE\n*        STCM  R0,3,DCBLRECL                overlay LRECL\n         MVC   DCBLRECL,=X'7FF4'   <fakeout>\n*\n*        AR    R10,R14                      revert to INMCOPY CS2\n*\n         UDIAG 2,'RECVRCPY open DCB',(R3),L$DCB\n         OPEN  ((R3),OUTPUT),MF=(E,SAOPN)\n         TM    DCBOFLG1,DCBOFOPN            opened?\n         BO    DCBOPEN\n*\n         UDIAG 0,'RECVRCPY DCB open error',(R3),L$DCB\n         MVI   SAREASON,1                   DCB didn't open\nUABEND   UABEND SAREASON                    ABEND w/ diagnostic msgs\n*\nDIE      STM   R0,R15,XMTREGS\n         UPSR  0,'RECVRCPY ABENDing; R14',(R14)\n         UDIAG 0,'RECVRCPY pre-ABEND regs',XMTREGS,16*4\n         MVI   SAREASON,2                   internal error - R14 useful\n         B     UABEND\n*\nDCBOPEN  DS    0H\n*----------------------------------------------------------------------\n*  Allocate buffer\n*----------------------------------------------------------------------\nBUFALLOC DS    0H\n         L     R0,=A(32*1024)          max QSAM blocksize\n         ST    R0,SALBUF\n         GETMAIN R,LV=(0)              allocate buffer\n         ST    R1,SA@BUF\n         EJECT ,\n*----------------------------------------------------------------------\n*  Retrieve data block\n*----------------------------------------------------------------------\nGETBLOCK DS    0H\n         LA    R14,4                   L'RDW\n         LM    R0,R1,SAXBUF            R0=BUFL, R1@BUF\n         LA    R1,0(R14,R1)            reserve RDW space\n         SR    R0,R14\n         UCALL RECVBLK,ERR=READCTL     retrieve data block\n         LTR   R8,R1                   @ buffer\n         BZ    READERR\n*\n         LTR   R9,R0\n         BNZ   WRITE\n*\nREADCTL  DS    0H\n         ST    R1,SACTL                save ctl seg addr\n         ST    R15,SARC                save RECVBLK rc\n         UPSR  2,'RECVRCPY RECVBLK rc',(R15)\n         OI    SAFLG1,SA1CTL           control segment returned\n         B     CLOSE\n*\nREADERR  DS    0H\n         UDIAG 0,'RECVRCPY XMIT read error',XMTREGS,16*4,REGS=YES\n         UDIAG 0,'RECVRCPY DCB',(R3),L$DCB\n         MVI   SAREASON,22                  internal error - R14 useful\n         B     UABEND\n         EJECT ,\n*----------------------------------------------------------------------\n*  Write data block\n*----------------------------------------------------------------------\nWRITE    DS    0H\n         L     R8,SA@BUF               @ RDW space\n         LA    R9,4(,R9)               add RDW overhead\n         STH   R9,0(,R8)               create RDW\n         UPSR  2,'RECVRCPY PUT data block RDW length',(R9)\n         UDIAG 3,'RECVRCPY PUT data block',(R8),(R9)\n         PUT   (R3),(R8)               write IEBCOPY unload rec\n         B     GETBLOCK\n         EJECT ,\n*----------------------------------------------------------------------\n*  Close output\n*----------------------------------------------------------------------\nCLOSE    DS    0H\n         UDIAG 2,'RECVRCPY closing DCB',(R3),L$DCB\n         MVC   SACLOS(L$CLOS),MODLCLOS      copy model CLOSE macro\n         CLOSE ((R3),),MF=(E,SACLOS)\n*----------------------------------------------------------------------\n*  Free buffer\n*----------------------------------------------------------------------\nFREEBUF  DS    0H\n         LM    R0,R1,SAXBUF\n         LTR   R0,R0\n         BZ    NOFREE\n*\n         FREEMAIN R,LV=(0),A=(1)            free output buffer\nNOFREE   DS    0H\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\nEXIT     DS    0H\n         L     R2,SARC\n         UPSR  1,'RECVRCPY exited rc',(R2)\n         L     R1,SACTL\n         UPEND RC=(R2),R1=PASS              return R1, R15\n         EJECT ,\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\nMODLOPN  OPEN  (,),MF=L                model OPEN\nL$OPN    EQU   *-MODLOPN               l' model open\n*\nMODLCLOS CLOSE (,),MF=L                model CLOSE\nL$CLOS   EQU   *-MODLCLOS              l' model close\n*\nMODLDCB  DCB   DDNAME=IEBUT1,                                          +\n               MACRF=PM,                                               +\n               DSORG=PS,                                               +\n               LRECL=0\nL$DCB    EQU   *-MODLDCB\n         LTORG ,\n*        EJECT ,\n*----------------------------------------------------------------------\n*  Savearea/workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSASA     DS    18F                     savearea for anyone we call\n*\nSAFLG1   DS    X\nSA1CTL   EQU   128                     have control segment\n*\nSAREASON DS    X                       UABEND reason code\n*\nSARC     DS    F                       our return code\nSADDNAME DS    CL8                     output DDNAME\n*\nSACTL    DS    F                       @ control segment\n*\nSAXBUF   DS    0F\nSALBUF   DS    F                       output buffer length\nSA@BUF   DS    A                       output buffer address\n*\nSAOPN    OPEN  (,),MF=L\nSACLOS   OPEN  (,),MF=L\nSADCB    DCB   DDNAME=IEBUT1,                                          +\n               MACRF=PM,                                               +\n               DSORG=PS\n*\n         DS    0D\nL$SA     EQU   *-SAVEAREA\n*\n         EJECT ,\n         DRCS2 ,\n*\n         PUSH  PRINT\n         PRINT NOGEN\n*\n         WAXMT FUNC=RECV\n*\n         DCBD  DSORG=PS,DEVD=DA\n*\n         POP   PRINT\n*\n         PRINT GEN\nRECVRCPY UFINI DXDRCPY,L$SA            pseudo-register\n         END   ,\n./ ADD NAME=RECVUTIL 0100-02182-02182-0702-00250-00250-00000-XMIT370\nRECVUTIL TITLE 'Call UTILITY'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  Things to do:\n*----------------------------------------------------------------------\n         U#SET ,\n*----------------------------------------------------------------------\n* Function: Given a CS2 (RECVCS2), call the indicated UTILITY\n*\n* Entry:  S/370 ECMODE KEY=8, STATE=PROB, AUTHORIZED\n*\n*         R0  =\n*         R1  = address of CS2\n*\n* Exit:   R15 = return code\n*\n*               00   success\n*                    R1 = 0\n*\n*               04   control segment returned (everything else OK)\n*                    R1 = address of control segment\n*\n*               16   Utility LOAD failed\n*                    R1 = 0\n*\n* Abends:\n*\n* Notes:\n*----------------------------------------------------------------------\n* R2     return code\n* R3\n* R4\n* R5     BXLE\n* R6     BXLE\n* R7     BXLE\n* R8\n* R9\n* R10    CS2\n* R11    XMTWA\n* R12    base reg\n* R13    savearea\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\nRECVUTIL UPROC L=L$SA,ID=RUTL,WA=SAVEAREA\n         EJECT ,\n*----------------------------------------------------------------------\n*  Initialize\n*----------------------------------------------------------------------\nINIT     DS    0H\n         LR    R10,R1                       save CS2\n         USING CS2,R10\n         UDIAG 1,'RECVUTIL entered'\n         UDIAG 2,'RECVUTIL CS2 at entry',(R10),L$CS2\n*\n         LM    R5,R7,=A(TAB,12,TABEND-1)    BXLE regs\n*\nSCAN     DS    0H\n         CLC   CS2UTILN,0(R5)               supported UTILITY?\n         BE    FOUND\n*\n         BXLE  R5,R6,SCAN\n*\n         UDIAG 0,'RECVUTIL unsupported utility (CS2)',CS2,L$CS2\n         LA    R2,16\n         B     EXITRC\n*\nFOUND    DS    0H\n         ICM   R15,15,8(R5)\n         BNZR  R15                          call support routine\n*\n         STM   R0,R15,XMTREGS\n         ULOG  'RECVCTL support routine unresolved'\n         MVI   SAREASON,1\nDIE      UABEND SAREASON                    installation error\n         EJECT ,\n*----------------------------------------------------------------------\n*  INMCOPY\n*----------------------------------------------------------------------\nINMCOPY  DS    0H\n         LA    R0,IEBUT1                    target DDNAME\n         LR    R1,R10                       CS2\n         UCALL RECVRCPY                     RECEIVE INMCOPY support\n         LTR   R2,R15\n         BZ    EXITRC\n*\n         ST    R1,SACTL                     returned ctl seg addr\n         UPSR  2,'RECVUTIL RECVRCPY rc',(R2)\n         MVI   SAREASON,2\n         L     R15,SACTL\n         SLR   R14,R14\n         ICM   R14,1,SEGL-SEG(R15)\n         BZ    DIE\n*\n         UDIAG 2,'RECVUTIL emit ctl seg',(R15),(R14)\n         B     EXITRC\n         EJECT ,\n*----------------------------------------------------------------------\n*  IEBCOPY setup\n*----------------------------------------------------------------------\nIEBCOPY  DS    0H\n         LA    R0,SAPRM1\n         ST    R0,SAPARM                    IEBCOPY parmlist\n*\n         LA    R0,IEBOPTS     SAPRM4\n         ST    R0,SAPRM1                    IEBCOPY options (OS PARM)\n*\n         LA    R0,IEBDDLST    SAPRM6\n         ST    R0,SAPRM2                    IEBCOPY DDNAME list\n*\n         LA    R0,IEBPAGEL    SAPRM8\n         ST    R0,SAPRM3                    IEBCOPY page header\n*\n         OI    SAPRM2,128                   VL flag (ignore page hdr)\n         B     LOAD\n*\n*  Extraneous setup, for ease of zapping\n*\n         LA    R0,0           SAPRM8\n         ST    R0,SAPRM3                    IEBCOPY page header\n         OI    SAPRM3,128                   VL flag\n*\n         MVC   SAPRM4,IEBOPTS               set OS PARM length\n         MVC   SAPRM5,IEBPARM               copy OS PARM\n*\n         MVC   SAPRM6,IEBDDLST              set DDNAME list length\n         MVC   SAPRM7,IEBDDN                copy DDNAME list\n*\n         MVC   SAPRM8,IEBPAGEL              set page header length\n         MVC   SAPRM9,IEBPAGE               copy page header\n         B     LOAD\n*\n         DS    0H\nIEBOPTS  DC    AL2(0)                       length of OS parm string\nIEBPARM  DC    C'                   '       IEBCOPY options (zappable)\n*        DC    C'SIZE=nnnnK,WORK=nnK'       SIZE = buffer size\n*                                           WORK = I/O buffer size\n*\n         DS    0H\nIEBDDLST DC    AL2(IEBDDX-IEBDDN)           L' DDNAME list\nIEBDDN   DS    0H\n         DC    XL8'00'\n         DC    XL8'00'\n         DC    XL8'00'\n         DC    XL8'00'\nIEBSYSIN DC    CL8'SYSIN'                   SYSIN    DD DUMMY\nIEBSYSPT DC    CL8'SYSPRINT'                SYSPRINT DD SYSOUT\n         DC    XL8'00'\nIEBUT1   DC    CL8'SYSUT1'                  SYSUT1   input unloaded ds\nIEBUT2   DC    CL8'SYSUT2'                  SYSUT2   output PDS\nIEBUT3   DC    CL8'SYSUT3'                  SYSUT3   spill\nIEBUT4   DC    CL8'SYSUT4'                  SYSUT4   spill\nIEBDDX   DS    0H\n*\n         DS    0H\nIEBPAGEL DC    AL2(L'IEBPAGE)               PAGE HEADER length\nIEBPAGE  DC    Z'1'                         PAGE HEADER\n         EJECT ,\n*----------------------------------------------------------------------\n*  LOAD UTILITY\n*----------------------------------------------------------------------\nLOAD     DS    0H\n         LA    R0,CS2UTILN\n         LOAD  EPLOC=(0)                    load UTILITY\n         LTR   R15,R15\n         BZ    CALL\n*\n         MVI   SARC+3,16\n         UPSR  0,'RECVUTIL ERROR: UTILITY LOAD rc',(R15)\n         B     EXIT\n*----------------------------------------------------------------------\n*  Call UTILITY\n*----------------------------------------------------------------------\nCALL     DS    0H\n         LR    R15,R0              get entry address\n         LA    R15,0(,R15)         clear hi byte for DELETE\n         LR    R9,R15              save EP\n         L     R1,SAPARM           UTILITY parmlist ptr\n         BALR  R14,R15             call UTILITY\n         ST    R15,SARC\n         UPSR  2,'RECVUTIL UTILITY rc %',(R15)\n*----------------------------------------------------------------------\n*  DELETE UTILITY\n*----------------------------------------------------------------------\nDELETE   DS    0H\n         LA    R0,CS2UTILN\n         DELETE EPLOC=(0)          delete UTILITY program\n         UPSR  2,'RECVUTIL UTILITY DELETE rc %',(R15)\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\nEXIT     DS    0H\n         L     R2,SARC\n*\nEXITRC   DS    0H\n         UPSR  1,'RECVUTIL exited rc',(R2)\n         L     R1,SACTL\n         UPEND RC=(R2),R1=PASS\n         EJECT ,\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\nTAB      DS    0F\n         DC    CL8'INMCOPY',A(INMCOPY)\n         DC    CL8'IEBCOPY',A(IEBCOPY)\nTABEND   DS    0X\n         LTORG ,\n*        EJECT ,\n*----------------------------------------------------------------------\n*  Savearea/workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSASA     DS    18F                     savearea for anyone we call\nSARC     DS    F                       our return code\nSACTL    DS    A                       addr of ctl seg from RECVRCPY\nSAREASON DS    X                       UABEND reason code\n*\n*  General parm layout for calling IBM utilities\n*\nSAPARM   DS    A                       UTILITY parmlist ptr\n*\nSAPRM1   DS    A                       OS parm\nSAPRM2   DS    A                       DDNAME list\nSAPRM3   DS    A                       page header\n*\nSAPRM4   DS    H                       L' OS PARM\nSAPRM5   DS    CL100                   UTILITY OS PARM\n*\nSAPRM6   DS    H                       L' ddname list\nSAPRM7   DS    XL100                   UTILITY ddname list\n*\nSAPRM8   DS    H                       L' page number\nSAPRM9   DS    CL4                     page number\n*\n         DS    0D\nL$SA     EQU   *-SAVEAREA\n*\n         EJECT ,\n         DRCS2 ,\n*        EJECT ,\n         PUSH  PRINT\n         PRINT NOGEN\n         DXMITSEG ,\n         WAXMT FUNC=RECV\n*        EJECT ,\n         POP   PRINT\nRECVUTIL UFINI DXDRUTL,L$SA            pseudo-register\n         END   ,\n./ ADD NAME=RECVVTAB 0100-02182-02182-0702-00037-00037-00000-XMIT370\nRECVVTAB TITLE 'RECV370 VCON table'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\nUTILVTAB CSECT ,                     XMITDBUG uses V(UTILVTAB)\n         USING *,0\n         USING XMTWA,11\n*----------------------------------------------------------------------\n*  CSECT table header - BXLE index, increment, limit\n*----------------------------------------------------------------------\nHEADER   DC    A(DBUGTAB,L$VTAB,DBUGEND-1)\n*----------------------------------------------------------------------\n*  CSECT table\n*----------------------------------------------------------------------\nDBUGTAB  DS    0F\n         DC    CL8'RECV370',V(RECV370),AL2(XMTD370-XMTDLEV,0)\n         DC    CL8'RECVBLK',V(RECVBLK),AL2(XMTDBLK-XMTDLEV,0)\n         DC    CL8'RECVCTL',V(RECVCTL),AL2(XMTDCTL-XMTDLEV,0)\n         DC    CL8'RECVGET',V(RECVGET),AL2(XMTDGET-XMTDLEV,0)\n         DC    CL8'RECVRCPY',V(RECVRCPY),AL2(XMTDRCPY-XMTDLEV,0)\n         DC    CL8'RECVUTIL',V(RECVUTIL),AL2(XMTDUTIL-XMTDLEV,0)\n*\n         DC    CL8'UTILABND',V(UTILABND),AL2(XMTDABND-XMTDLEV,0)\n         DC    CL8'UTILDBUG',V(UTILDBUG),AL2(XMTDDBUG-XMTDLEV,0)\n         DC    CL8'UTILHEX',V(UTILHEX),AL2(XMTDHEX-XMTDLEV,0)\n         DC    CL8'UTILLOG',V(UTILLOG),AL2(XMTDLOG-XMTDLEV,0)\n         DC    CL8'UTILPSR',V(UTILPSR),AL2(XMTDPSR-XMTDLEV,0)\n         DC    CL8'UTILSNAP',V(UTILSNAP),AL2(XMTDSNAP-XMTDLEV,0)\n         DC    CL8'UTILTIOT',V(UTILTIOT),AL2(XMTDTIOT-XMTDLEV,0)\nDBUGEND  EQU   *\n*----------------------------------------------------------------------\n*  DSECTs\n*----------------------------------------------------------------------\n         DVTAB ,                  VCON table\n         PRINT NOGEN\n         WAXMT FUNC=RECV\n         END   ,\n./ ADD NAME=RECV370  0100-02182-02182-0702-00206-00206-00000-XMIT370\nRECV370  TITLE 'TSO/E RECEIVE clone for MVS 3.8J'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  Copyright 2002, James M. Morrison\n*----------------------------------------------------------------------\n*  Things to do:\n*----------------------------------------------------------------------\n         U#SET ,\n*----------------------------------------------------------------------\n* Function: Given an input XMIT file, recreate original file (PDS\n*           or sequential file).\n*\n* DDNAMEs:\n*\n*        ddname     opened description                opens    closes\n*        --------   ------ -------------------------- -------- --------\n*\n*        XMITPRT    OUTPUT RECV370 messages           XMITLOG  XMITLOG\n*\n*        XMITIN     INPUT  XMIT                       RECVGET  RECVGET\n*\n*        XMITOUT    OUTPUT recreated PDS              IEBCOPY  IEBCOPY\n*                   OUTPUT recreated sequential       RECVSEQ  RECVSEQ\n*\n*        XMITDBUG   INPUT  debug control stmts        UTILDBUG UTILDBUG\n*\n*        SYSPRINT   OUTPUT IEBCOPY messages           IEBCOPY  IEBCOPY\n*\n*        SYSUT1     OUTPUT unwrapped XMIT             RECVPDS  RECVPDS\n*                   INPUT  IEBCOPY unload file        IEBCOPY  IEBCOPY\n*\n*        SYSIN      DUMMY  IEBCOPY control            IEBCOPY  IEBCOPY\n*                          statements (optional)\n*\n* Processing overview:\n*\n*        RECVCTL           handle XMIT control segments\n*          RECVPDS         handle IEBCOPY unloaded PDS\n*            RECVCOPY      invoke IEBCOPY\n*          RECVSEQ         handle sequential file\n*\n*    Utility:\n*\n*        RECVBLK           return IEBCOPY unloaded dataset block\n*        RECVGET           return XMIT segment\n*        RECVTAB           VCON/debug table (like XMIVTAB)\n*        UTILDBUG          setup debug options from XMITDBUG ddname\n*        XMITHEX           convert R0 to display hex\n*        XMITLOG           log messages to XMITPRT ddname\n*        XMITPSR           print string & R0 contents (display hex)\n*        XMITSNAP          mini-SNAP\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         R0  =\n*         R1  =  Address of OS parmlist\n*         R13 =  savearea ptr\n*         R14 =  return addr to caller\n*         R15 =  address of RECV370\n*\n* Exit:   R15 = return code\n*         R15 = 00 success\n*\n* Abends: U0001 DCB didn't open\n*\n* Notes:  This routine is responsible for setting up its registers\n*         as required by the PROC and PEND macros.\n*----------------------------------------------------------------------\n* R2     XPSWA\n* R3     DCB\n* R4     OS parm ptr\n* R5\n* R6\n* R7\n* R8\n* R9\n* R10    our real program base reg\n* R11    XMTWA ... ALWAYS (contains our savearea)\n* R12    BASE REG ... ALL CSECTS (dummy for us)\n* R13    savearea\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\nRECV370  CSECT ,\n         USING *,R15\n         B     MPASTID\n         DC    AL1(MAINIDX-MAINID)\nMAINID   DC    CL8'RECV370'       MODULE IDENTIFIER\n         DC    CL8'&SYSDATE'      ASSEMBLY DATE\n         DC    CL7' &SYSTIME'     ASSEMBLY TIME\nMAINIDX  EQU   *\nMAINSAL  DC    A(L$XMTWA)         XMTWA LENGTH\nMPASTID  DS    0H\n         DROP  R15\n         STM   R14,R12,12(R13)    STANDARD REGISTER SAVE\n         LR    R10,R15\n         USING RECV370,R10        BASE REGISTER (exception to rule)\n         LR    R4,R1              save parm ptr\n*\n         L     R3,L$DSA           LENGTH OF ALL DSAs\n         LA    R3,4095(,R3)       ROUND\n         SRL   R3,12              TO NEXT\n         SLL   R3,12              PAGE\n         GETMAIN R,LV=(R3)        GET STORAGE FOR DSAs\n         LR    R11,R1\n         USING XMTWA,R11\n         UZERO (R11),(R3)         clear storage\n*\n* Init XMTWA\n*\n         MVC   XMTEYE,=C'RECVDSA '          set eyecatcher\n         LA    R1,XMTSA1\n         ST    R1,8(,R13)         FORWARD POINTER\n         ST    R13,4(,R1)         BACKWARD POINTER\n         LR    R13,R1\n         USING SAVEAREA,R13\n         ST    R3,XMTLDSA                   record l' dsa\n         MVC   XMTRGSWE,=C'GETWORK '        set XPSWA eyecatcher\n         MVI   XMTDLEV,C'0'                 default diagnostic level\n         LTR   R4,R4\n         BZ    NOPARM\n         L     R4,0(,R4)                    @ OS parm string\n         LH    R14,0(,R4)                   l' parm string\n         LTR   R14,R14                      anything?\n         BNP   NOPARM                       no, br\n         ST    R4,XMT@PARM                  save parm ptr\n         MVC   XMTDLEV,2(R4)                copy diag char\nNOPARM   DS    0H\n*----------------------------------------------------------------------\n*  setup fake PROC based on R12 so PROC macro works for rest of code\n*----------------------------------------------------------------------\n         LR    R12,R10                       PROC assumes R12 set\n         LA    R15,MAIN                      pretend we just got here\n         PUSH  USING\n         DROP  ,\n         CNOP  0,8\nMAIN     UPROC L=L$MAIN,SECT=LABEL,ID=MAIN,WA=\n         POP   USING                         don't mess up our code\n*----------------------------------------------------------------------\n*  Wake up XMITLOG\n*----------------------------------------------------------------------\n    ULOG 'RECV370 v 00.00 Copyright 2002, James M. Morrison'\n    ULOG 'RECV370 Initial Developer James M. Morrison'\n    ULOG 'RECV370 may be distributed under the terms of the Q Public Li+\n               cense version 1.0'\n*----------------------------------------------------------------------\n*  Handle XMITDBUG ddname\n*----------------------------------------------------------------------\n         UCALL UTILDBUG                     handle XMITDBUG ddname\n*----------------------------------------------------------------------\n*  Verify we're authorized\n*----------------------------------------------------------------------\n         TESTAUTH FCTN=1                    authorized?\n         LTR   R15,R15\n         BZ    AUTHOK\n         ULOG  'RECV370 requires authorization'\n         MVI   SAREASON,X'47'               not authorized\nUABEND   UABEND SAREASON                    ABEND w/ diagnostics\nAUTHOK   DS    0H\n*----------------------------------------------------------------------\n*  Handle the XMIT file, recreate PDS/sequential dataset\n*----------------------------------------------------------------------\n         UCALL RECVCTL,ERR=EXIT\n         ULOG  'RECV370 done'\n*----------------------------------------------------------------------\n*  Close XMITPRT DCB\n*----------------------------------------------------------------------\n         SLR   R1,R1                        r1=0 ... close XMITPRT\n         UCALL UTILLOG                      CLOSE XMITPRT\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\nEXIT     DS    0H\n         L     R3,XMTRC\n         L     R13,XMTSA1+4        LOAD CALLER'S SAVE AREA PTR\n         L     R0,XMTLDSA\n         FREEMAIN R,LV=(0),A=(R11)      free XMITDSA\n         L     R14,12(R13)        STANDARD REGISTER RESTORE\n         LR    R15,R3             SET RETURN CODE\n         LM    R0,R12,20(R13)     STANDARD REGISTER RESTORE\n         XC    8(4,R13),8(R13)    ERASE RECV370'S SAVEAREA PTR\n         BR    R14                RETURN TO CALLER\n*\n         LTORG ,\n*\n         EJECT ,\n         WAXMT FUNC=RECV\n         EJECT ,\n         DXMITSEG ,\n         EJECT ,\nSAVEAREA DSECT ,\n         DS    18F           dummy \"main\" proc savearea\nSAREASON DS    X\nSAEND    DS    0D\nL$MAIN   EQU   *-SAVEAREA\n*\n         PRINT GEN\nRECV370  UFINI DXDR370,L$XMTWA\nRECV370  UFINI DXDRMAIN,L$MAIN\n*\nL$DSA    CXD   ,   LINKAGE EDITOR CALCULATES TOTAL DSA LENGTH FOR US\n*                  NOTE: THIS TECHNIQUE WILL FAIL FOR RECURSIVE CALLS\n*\n         END   ,\n./ ADD NAME=U#SET    0100-02182-02182-0702-00019-00019-00000-XMIT370\n         MACRO\n         U#SET &DIAG=,\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n         GBLB  &XMTDIAG\n         GBLB  &G#ASMF\n         GBLB  &G#HERC\n         GBLC  &XMTREGS\n         GBLC  &XMTABND\n&G#ASMF  SETB  1                  ASMF macro operand sublist bug\n&G#HERC  SETB  1                  Hercules emulator support\n&XMTREGS SETC  'XMTREGS'          XMTWA field for debug regs\n&XMTABND SETC  'XMTABEND'         XMTWA field for abend regs\n.*\n         AIF   ('&DIAG' EQ 'NO').NODIAG\n&XMTDIAG SETB  1                  1 = enable XMITDIAG macro\n.NODIAG  ANOP\n         MEND\n./ ADD NAME=UABEND   0100-02182-02182-0702-00037-00037-00000-XMIT370\n         MACRO\n&LABEL   UABEND &REASON,&DUMP=N,&STEP=N,&CODE=\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n.*---------------------------------------------------------------------\n.* &CODE   - ABEND code\n.* &REASON - ABEND reason code, RX address only\n.*\n.* Normal OS DUMP, STEP options are not provided.  UTILABND makes\n.* a decision on it's own, for ease in consolidating ABEND behavior.\n.*---------------------------------------------------------------------\n         GBLC  &XMTABND\n         LCLC  &NDX\n         LCLB  &A1,&A2,&B1,&B2\n         LCLA  &F1,&F2\n.*\n&NDX     SETC  '&SYSNDX'\n&LABEL   STM   R14,R13,&XMTABND        save regs before ABEND\n         AIF   ('&CODE' EQ '').CKRSN\n         IM#LALR  R1,&CODE             load abend code\n.CKRSN   AIF   ('&REASON' EQ '').NOCOD\n         ICM   R1,8,&REASON            load reason code\n.NOCOD   UCALL UTILABND                call ABEND support\n         SVC   13                      UTILABND returns to ABEND here\n.*\n&A1      SETB  ('&DUMP' NE 'N')\n&A2      SETB  ('&STEP' NE 'N')\n.*\n&B1      SETB  ('&REASON' NE '')\n&B2      SETB  ('&CODE' NE '')\n.*\n&F1      SETA  (&A1*128)+(&A2*64)\n&F2      SETA  (&B1*128)+(&B2*64)\n.*\nOPT&NDX  DC    AL1(&F1,&F2)            option flags\n         MEND\n./ ADD NAME=UCALL    0100-02182-02182-0702-00024-00024-00000-XMIT370\n         MACRO\n&LABEL   UCALL &WHAT,&PLIST=,&ERR=\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n.*---------------------------------------------------------------------\n.* &WHAT  - CSECT name to call\n.* &PLIST - optional parmlist (R1)\n.* &ERR   - optional LTR of R15 after called CSECT returns\n.*\n.* Note UABEND macro depends on the BALR being last instruction gen'd.\n.*--------------------------------------------------------------------\n         AIF   (T'&LABEL EQ 'O').NOLABL\n&LABEL   DS    0H\n.NOLABL  ANOP\n         AIF   (T'&PLIST EQ 'O').NOPLST\n         IM#LALR R1,&PLIST             @ parmlist\n.NOPLST  ANOP\n         L     R15,=V(&WHAT)           load program address\n         BALR  R14,R15                 call program\n         AIF   ('&ERR' EQ '').MEND\n         LTR   R15,R15                 check return code\n         BNZ   &ERR\n.MEND    MEND\n./ ADD NAME=UDIAG    0100-02182-02182-0702-00083-00083-00000-XMIT370\n         MACRO\n&LABEL   UDIAG &LEVEL,&TEXT,&ADDR,&LEN,&SKIP=,&REGS=NO\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n.*---------------------------------------------------------------------\n.* &LEVEL: 0   normal non-diagnostic messages (always shown)\n.*         1   STATUS messages, entry & exit\n.*         2   CSECT-SPECIFIC trace messages\n.*     above   varies by CSECT\n.*\n.* During execution, if the proper debug level is not set in XMTWA,\n.* the XMITLOG or XMITSNAP calls will not be executed\n.*\n.* &TEXT - RX or quoted string message to be issued, using either\n.* calls to XMITLOG or XMITSNAP.  For RX specifications, see XMITLOG\n.* or XMITSNAP for the layout of the message (they're different).\n.* &TEXT will be displayed by XMITLOG, unless &ADDR is coded in which\n.* XMITSNAP will display the text.\n.* Briefly, XMITLOG - RX field consists of text only.\n.* XMITSNAP - RX field has one byte length prefix, or may be delimited\n.* by X'00' at the end (then no length prefix); 60 byte max text.\n.*\n.* &ADDR - XMITSNAP start address\n.* &LEN  - XMITSNAP length (or stop address)\n.*\n.* REGS=NO suppresses STM of R0:R15 into &XMTREGS, code some other\n.* value to generate STM (REGS=YES, REGS=SAVE, etc.).\n.*\n.* SKIP=label causes branch to label if diagnostic level msg would\n.* not be issued; &TEXT, &ADDR, &LEN &REGS ignored when used.\n.* SKIP=label would be used to branch around code only needed for\n.* certain diag levels.\n.*---------------------------------------------------------------------\n         GBLB  &XMTDIAG\n         GBLC  &XMTREGS\n         LCLA  &LDBUG,&LSTR\n         LCLC  &NDX\n         LCLC  &DBUGBYT,&SKIPLAB\n         LCLC  &NEWTEXT,&STRING\n.*\n         AIF   (&XMTDIAG).GO\n&LABEL   IM#SECT LABEL       generate label for suppressed UDIAG\n         MEXIT\n.*\n.GO      ANOP\n&NDX     SETC  '&SYSNDX'\n&LDBUG   SETA  K'&SYSECT\n&DBUGBYT SETC  '&SYSECT'(5,&LDBUG-4)     set XMTD* byte name from CSECT\n.*\n.*  Put label for BL instruction into common format\n.*\n&SKIPLAB SETC  '&SKIP'\n         AIF   ('&SKIP' NE '').NOSTR           SKIP=label ignores &TEXT\n&SKIPLAB SETC  'SKIP&NDX'\n.*\n.*  Insert <n> into front of quoted string\n.*\n&NEWTEXT SETC  '&TEXT'\n         AIF   ('&TEXT'(1,1) NE '''').NOSTR      skip if not quoted str\n&LSTR    SETA  K'&TEXT-2                        length minus two quotes\n&STRING  SETC  '&TEXT'(2,&LSTR)                strip quotes from string\n&NEWTEXT SETC  '''<&LEVEL> &STRING'''              new text with quotes\n.NOSTR   ANOP\n.*\n&LABEL   IM#SECT LABEL\n         AIF   ('&LEVEL' EQ '0').STM        level=0 always runs\n         CLI   XMTD&DBUGBYT,C'&LEVEL'       generate diag msg?\n         BL    &SKIPLAB                     no, br\n         AIF   ('&SKIP' EQ '').STM\n         MEXIT\n.*\n.STM     AIF   ('&REGS' EQ 'NO').CKSNAP\n         STM   R0,R15,&XMTREGS              <debug>\n.*\n.CKSNAP  AIF   ('&ADDR' NE '').SNAP\n         ULOG  &NEWTEXT\nSKIP&NDX DS    0H\n         MEXIT\n.*\n.SNAP    USNAP &NEWTEXT,&ADDR,&LEN\nSKIP&NDX DS    0H\n         MEND\n./ ADD NAME=UFINI    0100-02182-02182-0702-00019-00019-00000-XMIT370\n         MACRO\n&CSECT   UFINI &DXD,&LEN\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n.*---------------------------------------------------------------------\n.* Define pseudo-register for our DSA\n.* &CSECT - CSECT name to which this pseudo-register applies\n.* &DXD   - DXD label\n.* &LEN   - length of the pseudo-register area (savearea length)\n.*---------------------------------------------------------------------\n*----------------------------------------------------------------------\n&CSECT   CSECT ,                            resume CSECT\n*\n&DXD     DXD   XL(&LEN)\n         DC    Q(&DXD)                      our DSA requirement\n         DS    0D\n*----------------------------------------------------------------------\n         MEND\n./ ADD NAME=ULOG     0100-02182-02182-0702-00030-00030-00000-XMIT370\n         MACRO\n&LABEL   ULOG &TEXT,&LENGTH\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n.*---------------------------------------------------------------------\n.* &TEXT   - RX or quoted string.  RX fields consists of text only.\n.* &LENGTH - optional, only needed to specify length if it can't\n.* be determined by the L' length attribute\n.*---------------------------------------------------------------------\n         LCLC  &NDX\n&NDX     SETC  '&SYSNDX'\n.*\n         AIF   ('&TEXT'(1,1) EQ '''').STRING\n.*\n&LABEL   IM#LALR R1,&TEXT                        message text\n         AIF   ('&LENGTH' EQ '').LENATTR\n         IM#LALR R0,&LENGTH                      length of text\n         AGO   .CALL\n.*\n.LENATTR LA    R0,L'&TEXT                        length of text\n         AGO   .CALL\n.*\n.STRING  ANOP\n&LABEL   BAL   R1,CODE&NDX                       skip msg, r1 @ msg txt\nMSG&NDX  DC    C&TEXT\nCODE&NDX LA    R0,L'MSG&NDX                              message length\n.*\n.CALL    UCALL UTILLOG                                      log message\n         MEND\n./ ADD NAME=UPEND    0100-02182-02182-0702-00041-00041-00000-XMIT370\n         MACRO\n&LABEL   UPEND &R0=RESTORE,&R1=RESTORE,&RC=\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n.* R15 is never restored\n.*\n&LABEL   IM#SECT LABEL            conditionally generate label\n         AIF   ('&RC' EQ '').HVRC\n         AIF   ('&RC' EQ '0').RC0\n         IM#LALR R15,&RC\n         AGO   .HVRC\n.RC0     SLR   R15,R15            return code zero\n.HVRC    ANOP\n         L     R13,4(,R13)        R13 @ caller's savearea\n         L     R14,12(,R13)       restore return addr\n.*\n         AIF   ('&R1' NE 'RESTORE').NOR1\n         AIF   ('&R0' NE 'RESTORE').NOR0\n         LM    R0,R12,20(R13)     restore caller's regs (NOT R15)\n         AGO   .XC\n.*\n.NOR0    LM    R1,R12,24(R13)     restore caller's regs (NOT R0,R15)\n         AGO   .XC\n.*\n.*\n.NOR1    AIF   ('&R0' NE 'RESTORE').R2\n         L     R0,20(R13)         restore caller's regs\n         LM    R2,R12,28(R13)     EXCEPT R1, R15\n         AGO   .XC\n.*\n.R2      LM    R2,R12,28(R13)     restore caller's regs (NOT R15,R0,R1)\n.*\n.XC      XC    8(4,R13),8(R13)    erase forward ptr\n         BR    R14                return to caller\n*\n         PUSH  PRINT\n         PRINT DATA\nPATCH    DC    32S(*)             PATCH AREA\n         POP   PRINT\n         MEND\n./ ADD NAME=UPROC    0100-02182-02182-0702-00051-00051-00000-XMIT370\n         MACRO\n&NAME    UPROC  &L=(19*4),&SECT=CSECT,&ID=XMT0,&WA=SAVEAREA\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n&NAME    IM#SECT &SECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11                  XMTWA\nWAREG    EQU   11                  for open code usage\nR12      EQU   12                  program base\nBASEREG  EQU   12                  for open code usage\nR13      EQU   13                  savearea/workarea\nSAREG    EQU   13                  for open code usage\nR14      EQU   14\nR15      EQU   15\n         USING *,R15\n         B     PASTID\n         DC    AL1(IDX-ID)\nID       DC    CL8'&NAME'          CSECT NAME\n         DC    CL8'&SYSDATE'       ASSEMBLY DATE MM/DD/YY\n         DC    CL7' &SYSTIME'      ASSEMBLY TIME HH.MM\nIDX      EQU   *\nDSALEN   DC    A(&L)               LENGTH OF SAVEAREA & WORKAREA\nPASTID   STM   R14,R12,12(R13)     STANDARD REGISTER SAVE\n         DROP  R15\n         LR    R2,R13              CALLER'S R13 + CALLER'S DSALEN\n         A     R2,DSALEN-&NAME.(,R12)    = R2 @ OUR SAVEAREA\n         LR    R3,R2               SAVE OUR SA PTR FOR BELOW\n         LR    R12,R15\n         USING &NAME,R12           BASE REGISTER ... ALL CSECTS\n         UZERO (R2),*DSALEN        CLEAR SAVEAREA\n         ST    R2,8(,R13)          FORWARD POINTER\n         ST    R13,4(,R2)          BACKWARD POINTER\n         LR    R15,R2              save sa ptr for a bit\n         LM    R0,R2,20(R13)       restore input regs\n         LR    R13,R15             R13 @ OUR SAVEAREA & WORKAREA\n         MVC   0(4,R13),=C'&ID'    set eyecatcher\n         USING XMTWA,R11           ALWAYS\n         AIF   ('&WA' EQ '').MEND\n         USING &WA,R13             SAVEAREA AND WORKAREA\n.MEND    MEND\n./ ADD NAME=UPSR     0100-02182-02182-0702-00047-00047-00000-XMIT370\n         MACRO\n&LABEL   UPSR &LEVEL,&TEXT,&VALUE,&SKIP=\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n.* LEVEL - see XMITDIAG macro\n.* TEXT  - message to be displayed (string or RX-expression)\n.*         For string, we insert <n> into string\n.*         RX-expressions are on their own\n.* VALUE - register to load into R0 before call to XMITPSR\n.*\n         LCLA  &LDBUG,&LSTR\n         LCLC  &NDX\n         LCLC  &DBUGBYT\n         LCLC  &NEWTEXT,&STRING\n&NDX     SETC  '&SYSNDX'\n&LDBUG   SETA  K'&SYSECT\n&DBUGBYT SETC  '&SYSECT'(5,&LDBUG-4)   set XMTD* byte name from CSECT\n&LABEL   IM#SECT LABEL\n         AIF   ('&LEVEL' EQ '0').GEN2       level=0 always runs\n         CLI   XMTD&DBUGBYT,C'&LEVEL'       generate diag msg?\n         AIF   ('&SKIP' EQ '').GEN\n         BL    &SKIP                        no, br\n         MEXIT\n.GEN     ANOP\n         BL    SKIP&NDX                     no, br\n.GEN2    AIF   ('&VALUE' EQ '').NOVAL\n         IM#LALR R0,&VALUE\n.NOVAL   ANOP\n.*\n.*  &TEXT     'STRING' will generate correct call to XMITPSR.\n.*    OR      RX-TYPE address or (reg) for buffer address\n.*\n.*  APPEND TRAILING % sign to denote R0 inclusion.\n.*\n         AIF   ('&TEXT'(1,1) EQ '''').STRING  1st char = '?\n         IM#LALR R1,&TEXT              message address\n         UCALL UTILPSR                 log msg w/ R0 in hex appended\n         AGO   .SKIP\n*\n.STRING  ANOP\n         BAL   R1,CALL&NDX             skip inline message text\n         DC    C'<&LEVEL> ',C&TEXT,C' %'\nCALL&NDX UCALL UTILPSR                 log msg w/ R0 in hex appended\n.SKIP    ANOP\nSKIP&NDX DS    0H\n         MEND\n./ ADD NAME=USNAP    0100-02182-02182-0702-00031-00031-00000-XMIT370\n         MACRO\n&LABEL   USNAP &TITLE,&ADDR,&LEN,&PLIST=WKSNAP,&MF=\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n         LCLC  &NDX\n         LCLC  &L2\n&NDX     SETC  '&SYSNDX'\n         AIF   ('&MF' EQ 'L').MFL\n&L2      SETC  'L''&ADDR'              assume &LEN default to L'&ADDR\n         AIF   (T'&LEN EQ 'O').SKIP2\n&L2      SETC  '&LEN'\n.SKIP2   ANOP\n         AIF   ('&TITLE'(1,1) NE '''').NSTR\n&LABEL   BAL   R0,CODE&NDX             skip inline message text\nLMSG&NDX DC    AL1(L'MSG&NDX)          message length\nMSG&NDX  DC    C&TITLE\nCODE&NDX IM#SECT LABEL\n         AGO   .HVADR\n.NSTR    IM#LALR R0,&TITLE\n.HVADR   ST    R0,0+&PLIST\n         IM#STA &ADDR,4+&PLIST         @ storage to snap\n         IM#STA &L2,8+&PLIST           length or end address\n         LA    R1,&PLIST               @ parm list\n         UCALL UTILSNAP                display storage\n         MEXIT\n.*\n.MFL     ANOP\n&PLIST   DS    0F\n&LABEL   DS    3F                      SNAP parmlist\n         MEND\n./ ADD NAME=UTILABND 0100-02182-02182-0702-00472-00472-00000-XMIT370\nUTILABND TITLE 'UABEND macro support'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  Things to do:\n*\n*  1) Finish playing with Hercules diagnose, STSI, etc.  See *<>\n*\n*  2) Route codes on WTO (probably need to adjust offsets)\n*\n*----------------------------------------------------------------------\n         U#SET DIAG=NO\n*----------------------------------------------------------------------\n* Function:    UABEND macro support routine to issue a few messages\n*              before an XMIT370/RECV370 ABEND\n*\n* Entry: R0         SNAP/SDUMP parm\n*\n*                    BITS\n*        R1         (00:07)  REASON code\n*                   (08:19)  reserved\n*                   (20:31)  ABEND code\n*\n*        R14 ->     SVC 13, followed immediately by option bytes:\n*\n*                   +00 (1) ABEND macro options\n*\n*                           1... .... DUMP\n*                           .1.. .... STEP\n*\n*                   +01 (1) Parm validity bits\n*\n*                           1... .... R1(00:07) REASON code\n*                           .1.. .... R1(20:31) ABEND code\n*                           ..1. .... R0 SNAP/SDUMP parm reg\n*                           .... ...1 +02, +03 option bytes present\n*\n*                   +02 (1) not currently generated by UABEND\n*\n*                   +03 (1) not currently generated by UABEND\n*\n* Exit:  Returns to callers' SVC 13 instruction (ABEND SVC)\n*\n* Notes: UABEND macro stored regs R14,R13 in &XMTABND before call.\n*\n*        UTILABND assumes caller follows normal XMIT370/RECV370\n*        register conventions:\n*\n*        R11  -  XMTWA\n*        R12  -  program base\n*        R13  -  savearea/workarea\n*\n*        UTILABND returns to the caller's ABEND SVC, so that any\n*        dumps reflect the actual code that wished to ABEND, rather\n*        than issuing ABEND from here.\n*\n*        UTILABND calls UTILHEX, so UTILHEX isn't allowed to have\n*        any errors or issue ABENDs.\n*\n*        UTILABND doesn't call ULOG/UPSR/UDIAG in case the XMITPRT\n*        ddname either isn't present, didn't open, or those support\n*        routines are issuing the UABEND macro.\n*\n*        UTILABND originally issued the WTL macro, but it didn't\n*        seem to produce output under MVS38j, so the WTO macro is now\n*        what is issued.\n*\n*----------------------------------------------------------------------\n* R2\n* R3\n* R4     options\n* R5     loop ctl\n* R6     loop ctl\n* R7     loop ctl\n* R8     internal linkage\n* R9     @ caller's savearea\n* R10    @ caller's return, options\n* R11    @ XMTWA\n* R12    pgm base\n* R13    @ savearea\n*----------------------------------------------------------------------\n         TITLE ' '\nUTILABND UPROC ID=UABD,L=L$SAV\n         EJECT ,\n*----------------------------------------------------------------------\n*  Zappable options for UTILABND\n*----------------------------------------------------------------------\n         B     INIT\n*\n         DS    0F\nABOPT    DS    0XL4               UTILABND option bytes\n*\n*                01234567\n*\nABOPT1   DC    B'10000000'        IBM ABEND macro options\n*                1.......         DUMP\n*                .1......         STEP\n*\nABOPT2   DC    B'00000000'        spare\n*\nABOPT3   DC    B'00000000'        spare\n*\nABOPT4   DC    B'00000000'        spare\n*\n*  UABEND currently only defines 2 option bytes\n*\nUOPTMASK EQU   B'1100'            ICM mask for UABEND option bytes\n*\n*\nABOPT5   DC    B'00000000'        UTILABND overrides\nAB5IGN1 EQU 128  1.......         ignore UABEND 1st option byte\nAB5IGN2 EQU 64   .1......         ignore UABEND 2nd option byte\nAB5IGN3 EQU 32   ..1.....         ignore UABEND 3rd option byte\nAB5IGN4 EQU 16   ...1....         ignore UABEND 4th option byte\n*\nABOPT6   DC    B'00000000'        spare\n*\n         EJECT ,\n*----------------------------------------------------------------------\n*  Initialize\n*----------------------------------------------------------------------\nINIT     DS    0H\n         L     R9,4(,R13)              @ caller's SA\n         L     R10,12(,R9)             caller's R14 @ SVC 13 + options\n*----------------------------------------------------------------------\n*  Ignore UABEND option bytes as per ABOPT5\n*----------------------------------------------------------------------\n         SLR   R4,R4\n         ICM   R4,UOPTMASK,2(R10)      grab UABEND option bytes\n*\n         TM    ABOPT5,AB5IGN1\n         BNO   *+8\n         ICM   R4,8,ZERO               ignore UABEND 1st option byte\n*\n         TM    ABOPT5,AB5IGN2\n         BNO   *+8\n         ICM   R4,4,ZERO               ignore UABEND 2nd option byte\n*\n         TM    ABOPT5,AB5IGN3\n         BNO   *+8\n         ICM   R4,2,ZERO               ignore UABEND 3rd option byte\n*\n         TM    ABOPT5,AB5IGN4\n         BNO   *+8\n         ICM   R4,1,ZERO               ignore UABEND 4th option byte\n*----------------------------------------------------------------------\n*  If ABOPT specified a value, make sure it gets used\n*----------------------------------------------------------------------\n         O     R4,ABOPT                assert ABOPT choices\n         ST    R4,SAOPTS               save options bytes in SA\n*----------------------------------------------------------------------\n*  If we're recursing give up hope right now\n*----------------------------------------------------------------------\n         MVC   SARABND(16*4),XMTABEND  in case of recursion\n         TM    XMTFLG1,XMT1ABND        UABEND recursing?\n         BO    RECURSE                 abandon all hope\n*\n         OI    XMTFLG1,XMT1ABND        UABEND in progress\n*----------------------------------------------------------------------\n*  Handle ABEND, REASON code(s)\n*----------------------------------------------------------------------\n         L     R0,20(,R9)              UABEND R0 contents\n         ST    R0,SARUR0               UABEND R0 contents\n         TM    SAOPT1,SA1SNAP          valid SNAP/SDUMP parm?\n         BNO   *+8\n         ST    R0,SAPARM0              ABEND R0 value\n*\n         L     R0,24(,R9)              UABEND R1 contents\n         ST    R0,SARUR1               UABEND R1 contents\n         TM    SAOPT1,SA1RSN           valid reason code?\n         BNO   *+8\n         STCM  R0,8,SAREASON+3         yes\n*\n         TM    SAOPT1,SA1COD           valid abend code?\n         BNO   NORSN\n         N     R0,=X'00000FFF'\n         ST    R0,SAABEND              yes\nNORSN    DS    0H\n*----------------------------------------------------------------------\n*  Set up WTO macro expansion & BR R8 in savearea\n*----------------------------------------------------------------------\n         MVC   SAWTO,MODLWTO           copy model WTO\n         MVC   SAWTORET,MODLRET        copy BR instruction\n*----------------------------------------------------------------------\n*  Issue initial ABEND explanation message\n*----------------------------------------------------------------------\n         MVI   SAWTXT,C' '                       blank out\n         MVC   SAWTXT+1(L'SAWTXT-1),SAWTXT       WTO text area\n         MVC   SAWTXT(L'MSGABEND),MSGABEND\n         MVC   SAWTXT+MAFUNC(4),XMTEYE           XMIT/RECV\n         L     R1,SARUR12                        @ caller's CSECT\n         MVC   SAWTXT+MAPGM(8),ID-UTILABND(R1)   caller's pgm name\n         L     R0,SAREASON\n         LA    R1,SAJUNK\n         UCALL UTILHEX\n         MVC   SAWTXT+MARSN(2),SAJUNK+6          caller's reason (hex)\n*<>      BAL   R8,HSNGL                          single-step Hercules\n         BAL   R8,SAWTO                          issue WTO\n*----------------------------------------------------------------------\n*  Display regs prior to abend\n*----------------------------------------------------------------------\n         MVI   SAWTXT,C' '                       blank out\n         MVC   SAWTXT+1(L'SAWTXT-1),SAWTXT       WTO text area\n         MVC   SAWTXT(L'MSG0),MSG0     copy MSG\n         LA    R5,SARABND              @ 1st abend reg value\n         LA    R6,SAWREG               @ 1st text reg slot\n         LA    R7,4                    # regs shown in msg\n*\nLINE1    DS    0H\n         L     R0,0(,R5)               UTILHEX input (R0)\n         LR    R1,R6                   UTILHEX output CL8\n         UCALL UTILHEX                 convert reg to display hex\n         LA    R5,4(,R5)\n         LA    R6,9(,R6)\n         BCT   R7,LINE1\n         BAL   R8,SAWTO                issue WTO from savearea\n*\n         MVI   SAWTXT,C' '                  blank out\n         MVC   SAWTXT+1(L'SAWTXT-1),SAWTXT  WTO text area\n         MVC   SAWTXT(L'MSG1),MSG1     copy MSG\n         LA    R6,SAWREG               @ 1st text reg slot\n         LA    R7,4                    # regs shown in msg\n*\nLINE2    DS    0H\n         L     R0,0(,R5)               UTILHEX input (R0)\n         LR    R1,R6                   UTILHEX output CL8\n         UCALL UTILHEX                 convert reg to display hex\n         LA    R5,4(,R5)\n         LA    R6,9(,R6)\n         BCT   R7,LINE2\n         BAL   R8,SAWTO                issue WTO from savearea\n*\n         MVI   SAWTXT,C' '                  blank out\n         MVC   SAWTXT+1(L'SAWTXT-1),SAWTXT  WTO text area\n         MVC   SAWTXT(L'MSG2),MSG2     copy MSG\n         LA    R6,SAWREG               @ 1st text reg slot\n         LA    R7,4                    # regs shown in msg\n*\nLINE3    DS    0H\n         L     R0,0(,R5)               UTILHEX input (R0)\n         LR    R1,R6                   UTILHEX output CL8\n         UCALL UTILHEX                 convert reg to display hex\n         LA    R5,4(,R5)\n         LA    R6,9(,R6)\n         BCT   R7,LINE3\n         BAL   R8,SAWTO                issue WTO from savearea\n*\n         MVI   SAWTXT,C' '                  blank out\n         MVC   SAWTXT+1(L'SAWTXT-1),SAWTXT  WTO text area\n         MVC   SAWTXT(L'MSG3),MSG3     copy MSG\n         LA    R6,SAWREG               @ 1st text reg slot\n         LA    R7,4                    # regs shown in msg\n*\nLINE4    DS    0H\n         L     R0,0(,R5)               UTILHEX input (R0)\n         LR    R1,R6                   UTILHEX output CL8\n         UCALL UTILHEX                 convert reg to display hex\n         LA    R5,4(,R5)\n         LA    R6,9(,R6)\n         BCT   R7,LINE4\n         BAL   R8,SAWTO                issue WTO from savearea\n         UDIAG 9,'UTILABND savearea',SAVEAREA,L$SAV\n*----------------------------------------------------------------------\n*  Close XMITPRT before ABENDING to flush pending messages\n*----------------------------------------------------------------------\nCLOSE    DS    0H\n         SLR   R1,R1\n         UCALL UTILLOG\n*----------------------------------------------------------------------\n*  Things haven't gone very well for XMIT370/RECV370\n*----------------------------------------------------------------------\nABEND    DS    0H\n*<>      IC    R1,SAMASK1              retrieve system's old mask\n*<>      EX    R1,RESET                return to normal PSW mask\n*<>      BAL   R14,STPROB              return to problem state\n*\n         L     R0,SAPARM0              SNAP/SDUMP parm\n         L     R1,DEFABND              default abend code\n         TM    SAOPT1,SA1COD           valid abend code?\n         BNO   *+8\n         L     R1,SAABEND              abend code\n         ICM   R1,8,SAOPT0             ABEND options\n*\n         LR    R14,R10                 restore caller's return addr\n         L     R15,SARUR15                restore caller's regs\n         LM    R2,R13,SARUR2              except R0, R1, and R14\n         BR    R14                     return to caller's ABEND SVC\n*\nDEFABND  DC    F'200'                  default abend code\nRESET    STOSM SAMASK2,0\n         EJECT ,\n*----------------------------------------------------------------------\n*  Hercules-assisted debugging code\n*----------------------------------------------------------------------\nHSNGL    DS    0H\n         STM   R14,R1,SATEMP\n         BAL   R14,STSUPR              check/enter SUPERVISOR state\n         STNSM SAMASK1,B'10111100'     disable PER, I/O, EXTERNAL\n         TM    XMTFLG2,XMT2QID         CPUid queried for Herc presence?\n         BO    HSNGL1\n*\n         L     R0,STSIR0\n         L     R1,STSIR1\n         L     R15,=F'4096'\n         LA    R14,SAEND\n         LA    R14,X'FFF'(R15,R14)\n         N     R14,=X'FFFFF000'\n*        STSI  SASYSIB                 store system info\n         DC    X'B27D',S(0)  S(0(R14)) store system info\n         BC    1,NOSYSIB               cc=3, no SYSIB stored\n         USNAP 'UTILABND SYSIB',(R14),(R15)\n         OI    XMTFLG2,XMT2QID         queried CPUid, XMT2HERC valid\n*\n* R0(00:07)    Version code = X'FF' when under VM and/or Hercules\n* R0(08:31)    CPU identification number\n* R1(00:15)    Model number\n* R1(16:31)    Maximum MCEL length\n*\nHSNGL1   DS    0H\n         HERC  HDI$SNGL                single step Hercules emulator\n         NOPR  0                       something for ifetch\nNOSYSIB  DS    0H\n         LM    R14,R1,SATEMP\n         BR    R8\n*\nSTSIR0   DC    F'0'\nSTSIR1   DC    F'1'\nHDI$NORM EQU   3840                    normal execution\nHDI$SNGL EQU   3844                    single step execution\n*----------------------------------------------------------------------\n*  State switch subroutines\n*----------------------------------------------------------------------\nSTPROB   DS    0H\n         TM    XMTFLG2,XMT2SUPR        entered SUPERVISOR state?\n         BNOR  R14\n         STM   R14,R1,SATEMP2\n         MODESET MODE=PROB\n         LM    R14,R1,SATEMP2\n         NI    XMTFLG2,255-XMT2SUPR    PROBLEM state\n         BR    R14\n*\nSTSUPR   DS    0H\n         TM    XMTFLG2,XMT2SUPR        entered SUPERVISOR state?\n         BOR   R14\n         STM   R14,R1,SATEMP3\n         MODESET MODE=SUP\n         LM    R14,R1,SATEMP3\n         OI    XMTFLG2,XMT2SUPR        SUPERVISOR state\n         BR    R14\n*----------------------------------------------------------------------\n*  Recursive UABENDs, WTO & bail\n*----------------------------------------------------------------------\nRECURSE  DS    0H\n         STM   R0,R15,SACURSE\n         WTO   'UTILABND recursing; ABEND U(400)'\n         ABEND 400,DUMP\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\nMODLWTO  WTO   '123456789/123456789/123456789/123456789/123456789/'\nL$WTO    EQU   *-MODLWTO\nL$TXT    EQU   50                      maximum text length\nMODLRET  BR    R8\n*\n*                0123456789/123456789/123456789/123456789/123456789\nMSGABEND DC    C'xxxx370 ABENDing in xxxxyyyy reason xx'\nMAFUNC   EQU   00,4\nMAPGM    EQU   20,8\nMARSN    EQU   36,2\n*\nMSG0     DC    C'R14 - R1'\nMSG1     DC    C'R2  - R5'\nMSG2     DC    C'R6  - R9'\nMSG3     DC    C'R10 - R13'\n*\nZERO     DC    F'0'\nPATCH    DC    64S(*)\n*\n         LTORG ,\n*----------------------------------------------------------------------\n*  Dynamic savearea & workarea - based R13\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSAVREGS  DS    18F\nSACURSE  DS    16F\n*\nSAPARM0  DS    F                       UTILABND parm R0\nSAPARM1  DS    F                       UTILABND parm R1\nSAREASON DS    F                       UTILABND reason code\nSAABEND  DS    F                       UTILABND abend code\n*\nSAOPTS   DS    F                       UTILABND options from UABEND\n*\nSAOPT0   EQU   SAOPTS+0,1              IBM ABEND macro options\nSA0DUMP  EQU   128                     ABEND n,DUMP\nSA0STEP  EQU   64                      ABEND n,,STEP\n*\nSAOPT1   EQU   SAOPTS+1,1              UTILABND parm validity options\nSA1RSN   EQU   128                     REASON code valid\nSA1COD   EQU   64                      ABEND code valid\nSA1SNAP  EQU   32                      SNAP/SDUMP parm reg R0\nSA1MORE  EQU   1                       Options +2 & +3 valid\n*\nSAOPT2   EQU   SAOPTS+2,1              spare\nSAOPT3   EQU   SAOPTS+3,1              spare\n*\n*\nSARABND  DS    16F                     XMTABEND copied here @ entry\nSARUR14  EQU   SARABND+0\nSARUR15  EQU   SARABND+4\nSARUR0   EQU   SARABND+(2*4)+(00*4)\nSARUR1   EQU   SARABND+(2*4)+(01*4)\nSARUR2   EQU   SARABND+(2*4)+(02*4)\nSARUR3   EQU   SARABND+(2*4)+(03*4)\nSARUR4   EQU   SARABND+(2*4)+(04*4)\nSARUR5   EQU   SARABND+(2*4)+(05*4)\nSARUR6   EQU   SARABND+(2*4)+(06*4)\nSARUR7   EQU   SARABND+(2*4)+(07*4)\nSARUR8   EQU   SARABND+(2*4)+(08*4)\nSARUR9   EQU   SARABND+(2*4)+(09*4)\nSARUR10  EQU   SARABND+(2*4)+(10*4)\nSARUR11  EQU   SARABND+(2*4)+(11*4)\nSARUR12  EQU   SARABND+(2*4)+(12*4)\nSARUR13  EQU   SARABND+(2*4)+(13*4)\n*\n         DS    0F\nSAWTO    DS    XL(L$WTO)               WTO macro copied here\nSAWTXT   EQU   SAWTO+08,L$TXT          text area\nSAWREG   EQU   SAWTXT+10,8             1st reg display hex area\nSAWTORET BR    R8                      return instruction copied here\n*\nSAJUNK   DS    CL8                     UTILHEX return area\n*\nSAFLAG1  DS    X                       status flags\nSA1SUPVR EQU   128                     entered SUPVR state\n*\nSACPUID  DS    D                       STIDP return\nSATEMP   DS    4F                      temp savearea\nSATEMP2  DS    4F                      temp savearea\nSATEMP3  DS    4F                      temp savearea\nSAMASK1  DS    X                       PSW mask, bits 0:7\nSAMASK2  DS    X                       PSW mask, bits 0:7\n*\n         DS    0D\nSAEND    DS    0D\nL$SAV    EQU   *-SAVEAREA              length of savearea\n*\n         WAXMT FUNC=UTIL,GEN=,DATA=,PRINT=ON\n         EJECT ,\n*----------------------------------------------------------------------\n*  Address of regs saved in XMTABEND by UABEND macro (relative R11)\n*----------------------------------------------------------------------\nABNDR0   EQU   XMTABEND+(2*4)+(00*4)\nABNDR1   EQU   XMTABEND+(2*4)+(01*4)\nABNDR2   EQU   XMTABEND+(2*4)+(02*4)\nABNDR3   EQU   XMTABEND+(2*4)+(03*4)\nABNDR4   EQU   XMTABEND+(2*4)+(04*4)\nABNDR5   EQU   XMTABEND+(2*4)+(05*4)\nABNDR6   EQU   XMTABEND+(2*4)+(06*4)\nABNDR7   EQU   XMTABEND+(2*4)+(07*4)\nABNDR8   EQU   XMTABEND+(2*4)+(08*4)\nABNDR9   EQU   XMTABEND+(2*4)+(09*4)\nABNDR10  EQU   XMTABEND+(2*4)+(10*4)\nABNDR11  EQU   XMTABEND+(2*4)+(12*4)\nABNDR12  EQU   XMTABEND+(2*4)+(12*4)\nABNDR13  EQU   XMTABEND+(2*4)+(13*4)\nABNDR14  EQU   XMTABEND+0\nABNDR15  EQU   XMTABEND+4\n*\nUTILABND UFINI DXDUABND,L$SAV\n         END   ,\n./ ADD NAME=UTILDBUG 0100-02182-02182-0702-00277-00277-00000-XMIT370\nUTILDBUG TITLE 'Parse XMITDBUG ddname, set debug options'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  Things to do:\n* 1) Maybe someday, move XMITDLEV code from XMIT370, move here.\n*    Keep PARM= ptr setting code in XMIT370.\n* 3) Add support for comments (1st char = *, #, or ;) in XMITDBUG\n*    to enable addition of debug level notes for each CSECT\n*----------------------------------------------------------------------\n         U#SET ,\n*----------------------------------------------------------------------\n* Function: Parse XMITDBUG ddname, set debugging option bytes\n*           XMTD* in XMTWA.  The values for each byte vary from\n*           C'0' to C'9', and control XMITDIAG/XMITPSR macro execution.\n*\n* XMITDBUG syntax:\n*\n*           Each XMIT370 CSECT has one statement which is used to\n*           set it's corresponding debug byte.  The syntax is\n*\n*               Column  1: CSECT name (upcase)\n*               Column 10: debug value (C'0' - C'9')\n*\n*           Blank debug values are allowed, and ignored so that\n*           a standard list of CSECTs may be maintained and only\n*           modified when needed.\n*\n*           When CSECT name = 'DEFAULT', all debug bytes are primed\n*           with this value.  When used, it should appear as the\n*           first line of input.\n*\n*           Before XMITDBUG is processed, all debug bytes are\n*           set to whatever XMIT370 set XMITDLEV to\n*           (C'0' or PARM= value).\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         R0  =\n*         R1  =\n*\n* Exit:   R15 = return code\n*         R15 = 00 success\n*\n* Abends:\n*\n* Notes:    This routine manages the XMITDBUG DCB, no one else\n*           need worry about it.  The ddname is optional.\n*----------------------------------------------------------------------\n* Reg  DSECT    usage\n*----------------------------------------------------------------------\n* R2            ptr to debug byte for current CSECT\n* R3   INREC    input record\n* R4\n* R5   TABLE    BXLE index\n* R6            BXLE increment\n* R7            BXLE compare value (table limit)\n* R8   DCBD     XMITDBUG DCB\n* R9\n* R10           saved R13 across GET macro\n* R11  XMTWA    common\n* R12           base reg\n* R13  XDGWA    savearea\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\nUTILDBUG UPROC L=L$XDGWA,ID=UDBG,WA=XDGWA\n         UDIAG 1,'UTILDBUG entered'\n*----------------------------------------------------------------------\n*  Initialize XMTD* values to default (set by XMIT370)\n*----------------------------------------------------------------------\n         MVC   XMTDLEV+1(XMTDEND-XMTDLEV-1),XMTDLEV   propagate value\n*----------------------------------------------------------------------\n*  Initialize XDGWA workarea\n*----------------------------------------------------------------------\n         MVC   XDGDCB(L$DCB),MODLDCB        copy model DCB macro\n         MVC   XDGOPN(L$OPN),MODLOPN        copy model OPEN macro\n         MVI   XDGEOF,0                     not EOF\n*----------------------------------------------------------------------\n*  Open DCB\n*----------------------------------------------------------------------\n         LA    R8,XDGDCB\n         USING IHADCB,R8\n         LA    R1,DCBDDNAM                  DDNAME=XMITDBUG\n         UCALL UTILTIOT                     ddname allocated?\n         LTR   R1,R1\n         BZ    RCZERO                       nope, never mind\n*\n         OPEN  (XDGDCB,INPUT),MF=(E,XDGOPN)\n         TM    DCBOFLG1,DCBOFOPN            opened?\n         BNO   RCZERO                       no, don't cares why, done\n*\n         UDIAG 2,'UTILDBUG processing XMITDBUG ddname'\n*----------------------------------------------------------------------\n*  Read input record\n*----------------------------------------------------------------------\n         LR    R10,R13                      preserve our savearea\nREAD     DS    0H\n         LA    R13,XDGDMSA                  give GET it's own sa\n*\n         GET   (R8)                         locate record\n*\n         LR    R13,R10                      back to R13\n         CLI   XDGEOF,X'00'                 EOF?\n         BNE   ENDOFILE                     yes, br\n*\n         LR    R3,R1                        ptr to input record\n         USING INREC,R3\n*----------------------------------------------------------------------\n*  Process input record\n*----------------------------------------------------------------------\nPROCESS  DS    0H\n         ICM   R5,15,=V(UTILVTAB)           @ VCON table header\n         BZ    OOPS\n*\n         LM    R5,R7,0(R5)                  index, incr, limit\n         USING VTABLE,R5\n         CLC   =CL8'DEFAULT',INAME          setting DEFAULT?\n         BNE   CKCSECT\n*\n         MVC   XMTDLEV,INVAL\n         MVC   XMTDLEV+1(XMTDEND-XMTDLEV-1),XMTDLEV  propagate default\n         B     READ\n*\nCKCSECT  DS    0H\n         CLC   VTABNAME,INAME               found CSECT name?\n         BNE   CKNEXT                       no, advance index\n*\n         CLI   INVAL,C' '                   blank ... ignore\n         BE    READ                         (but shows CSECT entry)\n*\n         LH    R2,VTABOFF                   debug byte offset\n         LA    R15,XMTDLEV(R2)              @ debug byte\n         MVC   0(1,R15),INVAL               set debug byte\n         B     READ\n*\nCKNEXT   DS    0H\n         BXLE  R5,R6,CKCSECT                find CSECT name in table\n*\n         UDIAG 1,'UTILDBUG unknown CSECT ignored',(R3),L$IN\n         B     READ\n*\nOOPS     ULOG  'UTILDBUG - installation error'\n         ULOG  'UTILDBUG - unable to locate UTILVTAB CSECT'\n         UABEND ,\n         EJECT ,\n*----------------------------------------------------------------------\n*  EOF - close DCB\n*----------------------------------------------------------------------\nEOFRTN   DS    0H                           EODAD exit routine\n         MVI   XDGEOF-XDGWA(R10),1          hit EOF, set flag\n         BR    R14                          return to GET macro\n*\nENDOFILE DS    0H\n         MVC   XDGCLOS(L$CLOS),MODLCLOS     copy model CLOSE macro\n         CLOSE (XDGDCB,),MF=(E,XDGCLOS)\n         EJECT ,\n*----------------------------------------------------------------------\n*  Show some info about each CSECT, and give XMTWA's address\n*----------------------------------------------------------------------\n*\n*  Issue the diagnostics AFTER input has been handled, so XMITDBUG's\n*  debug byte has a user-selected value\n*  The SKIP=RCZERO skips the following code (thru BXLE) if the\n*  diagnostic level is less than 1.\n*\n         UDIAG 1,SKIP=RCZERO\n*\n*  Say where XMTWA is located\n*\n         UPSR  1,'UTILDBUG XMTWA @ %',(R11)\n*\n         L     R5,=V(UTILVTAB)              @ VCON table header\n         LM    R5,R7,0(R5)                  index, incr, limit\n*\n*  For each CSECT, issue message containing:\n*  debug level, address, CSECT name, assembly date and time\n*\nVCONLOOP DS    0H\n         MVI   XDGBUF,C' '                  blank out buffer\n         MVC   XDGBUF+1(L$XDGBUF-1),XDGBUF\n*\n         MVC   XDGBEYE,=C'<1> '             fake diag level prefix\n*\n         LH    R2,VTABOFF                   debug byte offset\n         LA    R15,XMTDLEV(R2)              @ debug byte\n         MVC   XDGBLVL,0(R15)               copy debug byte to msg\n*\n         L     R0,VTABVCON                  CSECT addr\n         LA    R1,XDGBADR                   display hex\n         UCALL UTILHEX                      convert R0 to display hex\n         MVC   XDGBCS,VTABNAME              copy CSECT name\n*\n         ICM   R15,15,VTABVCON              @ CSECT or zero\n         BZ    MESSAGE\n*\n         MVC   XDGBCS,5(R15)                copy CSECT\n         MVC   XDGBDATE,13(R15)             copy asm date\n         MVC   XDGBTIME,21(R15)             copy asm time\n*\nMESSAGE  ULOG  XDGBUF,L$XDGBUF              display message\n*\n         BXLE  R5,R6,VCONLOOP               next CSECT\n         EJECT ,\n*----------------------------------------------------------------------\n*  Return to caller with zero return code\n*----------------------------------------------------------------------\nRCZERO   DS    0H\n         L     R5,=V(UTILVTAB)              @ VCON table header\n         LM    R5,R7,0(R5)                  index, incr, limit\n         UDIAG 3,'UTILDBUG DEBUG BYTES',XMTDLEV,XMTDEND\n         UDIAG 3,'UTILDBUG CSECT table',(R5),(R7)\n         UPEND RC=0\n         EJECT ,\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\nMODLOPN  OPEN  (,),MF=L                model OPEN\nL$OPN    EQU   *-MODLOPN               l' model open\n*\nMODLCLOS CLOSE (,),MF=L                model CLOSE\nL$CLOS   EQU   *-MODLCLOS              l' model close\n*\nMODLDCB  DCB   DDNAME=XMITDBUG,MACRF=GL,DSORG=PS,RECFM=FB,LRECL=80,    +\n               EODAD=EOFRTN\nL$DCB    EQU   *-MODLDCB\n*\n         LTORG ,\n         EJECT ,\n*----------------------------------------------------------------------\n*  XDGWA workarea\n*----------------------------------------------------------------------\nXDGWA    DSECT ,\nXDGSA    DS    18F\nXDGOPN   OPEN  0,MF=L\nXDGCLOS  CLOSE 0,MF=L\nXDGEOF   DS    X                       set not = X'00' on EOF\nXDGDCB   DCB   DDNAME=XMITDBUG,MACRF=GL,DSORG=PS,RECFM=FB,LRECL=80,    +\n               EODAD=EOFRTN\nXDGDMSA  DS    18F                     data management (GET) savearea\n*\nXDGBUF   DS    0C                      diagnostic message buffer\nXDGBEYE  DS    C'<1> '\nXDGBLVL  DS    C                       diagnostic level\n         DS    C\nXDGBADR  DS    CL8                     CSECT address\n         DS    C\nXDGBID   DS    0C                      CSECT name, asm date/time\nXDGBCS   DS    CL8                     CSECT name\n         DS    C\nXDGBDATE DS    CL8                     CSECT assembly date\n         DS    C\nXDGBTIME DS    CL7                     CSECT assembly time\nL$XDGBUF EQU   *-XDGBUF                length of buffer\n*\n         DS    0D\nL$XDGWA  EQU   *-XDGWA\n*----------------------------------------------------------------------\n*  Input record\n*----------------------------------------------------------------------\nINREC    DSECT ,\nINAME    DS    CL8           CSECT name\n         DS    C             ignored\nINVAL    DS    C             Debug value - C'0' to C'9' (assumed)\nL$IN     EQU   *             length of significant part of input rec\n         EJECT ,\n         DVTAB ,\n         EJECT ,\n         WAXMT FUNC=UTIL\n*\n         PRINT NOGEN\n         DCBD  DSORG=PS,DEVD=DA\n*\n         PRINT ON,GEN\nUTILDBUG UFINI DXDUDBUG,L$XDGWA\n         END   ,\n./ ADD NAME=UTILHEX  0100-02182-02182-0702-00060-00060-00000-XMIT370\nUTILHEX  TITLE 'Convert R0 into displayable hex'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n         U#SET ,\n*----------------------------------------------------------------------\n* Function:    converts R0 into displayable hex\n*\n* Entry:  R0 = contents of R0 to be converted & displayed\n*         R1 = address of CL8 field to receive output\n*              when zero, this field is not modified\n*\n* Exit:   R15 =  0     everything is OK\n*         R0  =  1st word of output\n*         R1  =  2nd word of output\n*\n* Notes:  UTILHEX is called by UTILABND, and is neither allowed to have\n*         errors in its code, nor to issue ABEND/UABEND.\n*\n*----------------------------------------------------------------------\nUTILHEX  UPROC ID=UHEX,L=L$SAV\n*\n         ST    R0,WKFWORD              value to translate\n         UNPK  WKWORK,WKFWORD(5)       spread out digits\n         LA    R15,HEXCHAR             addressability game\n         LA    R14,C'0'\n         SR    R15,R14\n         TR    WKWORK,0(R15)           hexchar-c'0' translate to char\n         LTR   R1,R1                   caller supplied field addr?\n         BZ    RETREGS                 no, return regs only\n*\n         MVC   0(8,R1),WKWORK          copy input msg to caller's buf\n*\nRETREGS  LM    R0,R1,WKWORK            return values\n*\n         UPEND R0=PASS,R1=PASS,RC=0    return to caller\n*\n         LTORG ,\n*\nHEXCHAR  DC    C'0123456789ABCDEF'     Hex translate table\n*----------------------------------------------------------------------\n*  Dynamic savearea & workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSAVREGS  DS    18F\n*\nWKFWORD  DS    F,C\n*\n         DS    0F\nWKWORK   DS    CL9                     8 bytes plus trailing slop byte\n*\n         DS    0D                      align\nL$SAV    EQU   *-SAVEAREA              length of savearea\n*\n         PRINT NOGEN\n         WAXMT FUNC=UTIL\n         PRINT GEN\nUTILHEX  UFINI DXDUHEX,L$SAV\n         END   ,\n./ ADD NAME=UTILLOG  0100-02182-02182-0702-00118-00118-00000-XMIT370\nUTILLOG  TITLE 'LOG output line to XMITPRT ddname'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  Things to do:\n*----------------------------------------------------------------------\n         U#SET ,\n*----------------------------------------------------------------------\n* Function: Write output line to XMITPRT ddname\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         R0  =  text length\n*         R1  =  Address of text to be written\n*                when 0, XMITPRT DCB will be closed.\n*\n* Exit:   R15 = 0\n*\n* Abends: U0001 DCB didn't open\n*\n* Notes:  UTILLOG maintains the XMITPRT DCB, opening it as required.\n*----------------------------------------------------------------------\n* R2\n* R3     DCB\n* R4     input buffer\n* R5     length of input buffer\n* R6\n* R7\n* R8\n* R9\n* R10\n* R11    XMTWA\n* R12    base reg\n* R13    savearea\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\nUTILLOG  UPROC L=L$LOGWA,ID=ULOG,WA=LOGWA\n         LA    R3,XMTDCBL\n         USING IHADCB,R3\n         LTR   R5,R1                        @ text, or CLOSE request\n         BZ    CLOSE\n*\n         LR    R4,R0                        l'text\n         TM    DCBOFLG1,DCBOFOPN            dcb open?\n         BO    NORMAL\n*----------------------------------------------------------------------\n*  Initialize\n*----------------------------------------------------------------------\n         MVC   XMTDCBL(L$DCB),MODLDCB        copy model DCB macro\n         MVC   LWAOPN(L$OPN),MODLOPN         copy model OPEN\n         OPEN  XMTDCBL,MF=(E,LWAOPN)\n         TM    DCBOFLG1,DCBOFOPN            opened?\n         BO    NORMAL\n         WTO   'UTILLOG: XMITPRT ddname did not open'\n         UABEND ,                           output DCB didn't open\n*----------------------------------------------------------------------\n*  Close XMITPRT\n*----------------------------------------------------------------------\nCLOSE    DS    0H\n         MVC   XMTCLOS(L$CLOS),MODLCLOS     copy model CLOSE macro\n         TM    DCBOFLG1,DCBOFOPN            XMITPRT open?\n         BNO   EXITRC0\n         CLOSE XMTDCBL,MF=(E,XMTCLOS)\n         FREEPOOL XMTDCBL\n         B     EXITRC0\n*----------------------------------------------------------------------\n*  Normal write request\n*----------------------------------------------------------------------\nNORMAL   DS    0H\n         XC    LWARESV,LWARESV              clear reserved\n         A     R4,=A(L'LWAPFX+L'LWARESV+L'LWACC)\n         STH   R4,LWAPFX                    set vb file's rdw\n         S     R4,=A(L'LWAPFX+L'LWARESV+L'LWACC)\n         MVI   LWACC,C' '                   set carriage control\n         BCTR  R4,0\n         EX    R4,COPY                      copy record to buffer\n         LA    R0,LWAPFX                    record address\n         PUT   XMTDCBL                      write record\n*\nEXITRC0  SLR   R15,R15                      set good return code\nEXIT     DS    0H\n         UPEND ,\n*\nCOPY     MVC   LWABUF(*-*),0(R5)            executed\n*\nMODLOPN  OPEN  (,OUTPUT),MF=L          model OPEN\nL$OPN    EQU   *-MODLOPN               l' model open\n*\nMODLCLOS CLOSE (,),MF=L                model CLOSE\nL$CLOS   EQU   *-MODLCLOS              l' model close\n*\nMODLDCB  DCB   DDNAME=XMITPRT,                                         +\n               MACRF=PM,DSORG=PS,RECFM=VBA,                            +\n               LRECL=133+4,BLKSIZE=6144\nL$DCB    EQU   *-MODLDCB\n*\n         LTORG ,\n*----------------------------------------------------------------------\nLOGWA    DSECT ,\n         DS    18F\nLWAOPN   OPEN  (,),MF=L\n         DS    0F\nLWAPFX   DS    H                       rdw length (includes l' rdw)\nLWARESV  DS    H                       rdw reserved\nLWACC    DS    C' '                    asa carriage control\nLWABUF   DS    CL133                   output record\n         DS    0D\nL$LOGWA  EQU   *-LOGWA\n         EJECT ,\n         WAXMT FUNC=UTIL\n         EJECT ,\n         PRINT NOGEN\n         DCBD  DSORG=PS,DEVD=DA\n         PRINT GEN\nUTILLOG  UFINI DXDULOG,L$LOGWA\n         END   ,\n./ ADD NAME=UTILPSR  0100-02182-02182-0702-00116-00116-00000-XMIT370\nUTILPSR  TITLE 'PRINT String and Register 0'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n         U#SET ,\n*----------------------------------------------------------------------\n* Function:    converts R0 into displayable hex, then\n*              appends converted data onto input message text,\n*              finally calls XMITLOG to output completed\n*              text.\n*\n* Entry:  R0 = contents of R0 to be converted & displayed\n*         R1 = address of message text, delimited by trailing % sign.\n*\n* Exit:   R15 =  0     everything is OK\n*                else  error\n*\n*----------------------------------------------------------------------\n* R2     ptr to currently scanning char in input buffer\n* R3     max chars allowed to be scanned\n* R4     length of input message text (not including % sign)\n* R5     ptr to slot for converted R0 in our buffer\n* R6\n* R7\n* R8     input R0\n* R9     input message text ptr\n* R10\n*----------------------------------------------------------------------\n         TITLE ' '\nUTILPSR  UPROC ID=UPSR,L=L$SAV\n         EJECT ,\n*\n         LR    R8,R0              save input R0\n         LA    R9,0(R1)           save msg text ptr\n*----------------------------------------------------------------------\n*  Convert R0 contents to displayable hex\n*----------------------------------------------------------------------\nXLATE    DS    0H\n         ST    R0,WKFWORD              value to translate\n         UNPK  WKWORK,WKFWORD(5)       spread out digits\n         LA    R15,HEXCHAR\n         LA    R14,C'0'\n         SR    R15,R14\n         TR    WKWORK,0(R15)           hexchar-c'0' translate to char\n*----------------------------------------------------------------------\n*  Find end of input message\n*----------------------------------------------------------------------\nL$MAXIN  EQU   120                maximum allowed input text length\n*\n         LR    R2,R9                   @ beginning of input msg txt\n         LA    R3,L$MAXIN\nSCAN     DS    0H\n         CLI   0(R2),C'%'\n         BE    HIT\n*\n         LA    R2,1(,R2)\n         S     R3,=F'1'           too many chars scanned?\n         BP    SCAN               not yet, ok to keep looking\n*\n*----------------------------------------------------------------------\n*  Copy input message (less % sign) to our buffer\n*----------------------------------------------------------------------\nHIT      DS    0H\n         MVI   WKMSG,C' '\n         MVC   WKMSG+1(L'WKMSG-1),WKMSG\n*\n         LR    R4,R2\n         SR    R4,R9              calc msg length\n*        BCTR  R4,0               minus one for execute\n         EX    R4,EXMVC           copy input msg to our buffer\n*----------------------------------------------------------------------\n*  Append displayable hex contents of R0 to our buffer\n*----------------------------------------------------------------------\n         LA    R5,WKMSG(R4)       @ spot to put data\n         MVC   0(8,R5),WKWORK     append converted data\n         LA    R5,8(,R5)          past last char\n         LA    R0,WKMSG\n         SR    R5,R0              length of message\n*----------------------------------------------------------------------\n*  Output our buffer\n*----------------------------------------------------------------------\n         ULOG WKMSG,(R5)          print out the message\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\nEXIT     UPEND                    RETURN to caller\n*\nEXMVC    MVC   WKMSG(*-*),0(R9)   copy input msg to our buffer\n*\n         EJECT ,\n*\n         LTORG ,\n*\n*  Placed last so it's addressable as hexchar-c'0'\n*  Oops, still not enough ... use base reg instead\n*\nHEXCHAR  DC    C'0123456789ABCDEF'     Hex translate table\n*----------------------------------------------------------------------\n*  Dynamic savearea & workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSAVREGS  DS    18F\nWKMSG    DS    CL(L$MAXIN+9)      input msg, blank, 8 bytes of hex\nWKFWORD  DS    F\n         DS    F                  slop ... must be behind WKFWORD\nWKWORK   DS    CL9                8 bytes plus trailing slop byte\n         DS    XL20                    spare\n         DS    0D                      align\nL$SAV    EQU   *-SAVEAREA              length of savearea\n         EJECT ,\n         WAXMT FUNC=UTIL\n*\n         PRINT GEN\nUTILPSR  UFINI DXDUPSR,L$SAV\n         END   ,\n./ ADD NAME=UTILSNAP 0100-02182-02182-0702-00318-00318-00000-XMIT370\nUTILSNAP TITLE 'DIAGNOSTIC tool: display storage'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  Things to do:\n*  1)  Display length of snap in hex & decimal\n*----------------------------------------------------------------------\n         U#SET ,\n*----------------------------------------------------------------------\n*\n* Function: display dump-formatted storage on XMITLOG ddname\n*\n* Input:  R1 points at following parameter list:\n*\n*  +0     Zero or address of TITLE (see below).\n*\n*  +4     Address of virtual storage address at which to begin.\n*\n*  +8     Address of virtual storage address at which to end.\n*         Alternatively, this parameter may contain the length\n*         of storage to be displayed, rather than an address.\n*\n*         TITLE:\n*\n*         The length of the title is determined by the following\n*         technique:  if the first byte of the title < 60,\n*         then the first byte is the length of following title.\n*         Otherwise, the title is delimited by X'00'.\n*         The title's maximum length is 60.\n*\n*         R13 points to caller-provided savearea\n*\n*         R14 return address\n*\n*         R15 entry point address of this routine\n*\n* Output: Input data displayed.\n*\n*         R15 =  00\n*\n* Notes:\n*----------------------------------------------------------------------\n         TITLE ' '\nUTILSNAP UPROC L=L$SAV,ID=USNP,WA=SAVEAREA\n         EJECT ,\n*\n* Initialize\n*\n         LM    R3,R5,0(R1)             save input parms\n         STM   R3,R5,PARMS\n**************************************************************\n* Process title\n**************************************************************\n         LTR   R3,R3                   title supplied?\n         BZ    NOTITLE                 no, br\n*\n         ULOG  ' '                     blank line\n*\n         CLI   0(R3),MAXLEN            1st byte length?\n         BH    SCANTITL                no, br ... need to scan\n*\n         SLR   R6,R6\n         IC    R6,0(R3)                get title's length\n         LA    R7,1(,R3)               1st byte of title\n         B     TITLEOUT\n*\nSCANTITL DS    0H\n         LR    R7,R3                   @ 1st byte of title\n         TRT   0(MAXLEN,R3),ZVALID     scan for non-display\n         BZ    MAXLENT                 found all displayable\n*\n         SR    R1,R3                   calculate length\n         LR    R6,R1\n         C     R6,=A(MAXLEN)           too long?\n         BNH   TITLEOUT\n*\nMAXLENT  DS    0H\n         LA    R6,MAXLEN               set maximum title length\n*\nTITLEOUT DS    0H\n         LR    R0,R6                   length of title\n         LR    R1,R7                   address of title\n         UCALL UTILLOG                 print title\n*\nMAXLEN   EQU   60                      Maximum title length\nNOTITLE  DS    0H\n**************************************************************\n* Display storage specifications\n**************************************************************\n         MVC   CLABEL,=C'DISPLAYING '\n         MVI   CRANGE,C':'             set range char\n*\n         L     R0,@START               starting address\n         LA    R1,CSTART               char format\n         BAL   R14,XLATE               convert to display hex\n*\n         LM    R14,R15,@START\n         CR    R15,R14                 ending addr > starting?\n         BH    USE@END                 yes, ok to use\n*\n         AR    R15,R14                 calculate ending addr\n         ST    R15,@END                fake out parmlist\n*\nUSE@END  DS    0H\n         L     R0,@END                 ending address\n         BCTR  R0,0                    minus one\n         LA    R1,CEND                 char format\n         BAL   R14,XLATE               convert to display hex\n*\n         MVI   CSPACE1,C' '\n         L     R0,@END\n         S     R0,@START\n         LA    R1,CHEXLEN              length (hex)\n         BAL   R14,XLATE\n*\n         LA    R0,L$SPECS\n         LA    R1,CLABEL               label following output\n         UCALL UTILLOG                 type output\n**************************************************************\n* Format output line(s)\n**************************************************************\nFORMAT   DS    0H\n         XC    DISPL,DISPL             zero displacement\n         L     R4,@START               @ beginning of area\n*        N     R4,=X'FFFFFFFC'         align on fullword boundary\n*\nFLINE    DS    0H\n         LR    R8,R4                   storage @ start of line\n         MVI   CFORMAT,C' '\n         MVC   CFORMAT+1(L$FORMAT-1),CFORMAT    clear line,\n         MVI   CSTAR1,C'*'                      delimit\n         MVI   CSTAR2,C'*'                      char area\n*\n         LR    R0,R4\n         LA    R1,CADDR\n         BAL   R14,XLATE               make ADDRESS char\n*\n         L     R0,DISPL\n         LA    R1,CJUNK\n         BAL   R14,XLATE               make DISPLACEMENT char\n         MVC   CDISPL(4),CJUNK+4       copy last 4 digits\n         A     R0,=F'16'               using 4 fullwords\n         ST    R0,DISPL                setup for next time\n*\n         LA    R5,4                    # word slots avail\n         LA    R6,CWORD1               @ first slot\n*\nFLOOP    DS    0H\n         ICM   R0,15,0(R4)             grab 1st 4 bytes\n         LA    R1,CBYTES               workarea\n         BAL   R14,XLATE               make 1st word char\n* copy only right # chars from CYTES to CWORDn\n         LM    R14,R15,CBYTES          get display hex in regs\n         L     R1,@END                 addr last char to display\n         SR    R1,R4                   calc # chars to put in CWORDn\nPUTC     STCM  R14,8,0(R6)             put char in CWORDn\n         STCM  R14,4,1(R6)\n         SLDL  R14,16                  discard char\n         LA    R6,2(,R6)\n         LTR   R14,R14                 got 'em all?\n         BZ    BUMPC                   yep\n         S     R1,=F'1'\n         BP    PUTC\nBUMPC    DS    0H\n         LA    R4,4(,R4)               setup for next time\n         LA    R6,1(,R6)               space between CWORDs\n*\n         C     R4,@END                 displayed enough?\n         BNL   FCHAR                   yes, do chars now\n         S     R5,=F'1'                one less slot\n         BP    FLOOP                   still have some left\n*\n*        Format character display portion of output line\n*\nFCHAR    DS    0H\n         LA    R9,16                   # chars in char display\n         LR    R15,R8                  @ begin of line's data\n         LA    R14,CCHAR\n         MVC   CCHAR,=CL16' '          init to blanks\n*\nCLOOP    DS    0H\n         MVC   0(1,R14),0(R15)         copy for displaying\n         LA    R15,1(,R15)\n         LA    R14,1(,R14)\n         C     R15,@END\n         BNL   CLOOP2\n         S     R9,=F'1'\n         BP    CLOOP\n*\nCLOOP2   DS    0H\n         TR    CCHAR,ZDISP             convert non-display\n         LR    R8,R4                   now done with those\n*\n         LA    R0,L$FORMAT             length of output line\n         LA    R1,CFORMAT              addr of output line\n         UCALL UTILLOG                 type output\n*\n         C     R4,@END                 more lines to format?\n         BL    FLINE                   yes, br\n**************************************************************\n* Return to caller\n**************************************************************\nEXIT     DS    0H\n         SLR   R15,R15\n         UPEND ,                       return to caller\n         TITLE 'XLATE Subroutine'\n**************************************************************\n* XLATE subroutine\n**************************************************************\n*\n* Input:   R0  = value to translate\n*\n*          R1  = address of 8 bytes to receive translated\n*                \"display hexadecimal\" output\n*\n*          R14 = return address\n*\nXLATE    DS    0H\n         ST    R0,FWORD                value to translate\n         UNPK  XWORK,FWORD(5)          spread out digits\n         TR    XWORK,HEXCHAR-C'0'      translate to char\n         MVC   0(8,R1),XWORK           return data to caller\n         BR    R14                     return to caller\n*\nHEXCHAR  DC    C'0123456789ABCDEF'     Hex translate table\n         TITLE 'DATA AREAS'\n**************************************************************\n* Data areas (not modified)\n**************************************************************\nZVALID   DS    0X\n*                000102030405060708090A0B0C0D0E0F    ..\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' X'00'\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' X'10'\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' X'20'\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' X'30'\n         DC    X'00FFFFFFFFFFFFFFFFFF000000000000' X'40'\n         DC    X'00FFFFFFFFFFFFFFFFFF000000000000' X'50'\n         DC    X'00FFFFFFFFFFFFFFFFFF000000000000' X'60'\n         DC    X'FFFFFFFFFFFFFFFFFF00000000000000' X'70'\n         DC    X'FF000000000000000000FFFFFFFFFFFF' X'80' a-i\n         DC    X'FF000000000000000000FFFFFFFFFFFF' X'90' j-r\n         DC    X'FF000000000000000000FFFFFFFFFFFF' X'A0' s-z\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' X'B0'\n         DC    X'00000000000000000000FFFFFFFFFFFF' X'C0' A-I\n         DC    X'00000000000000000000FFFFFFFFFFFF' X'D0' J-R\n         DC    X'00FF0000000000000000FFFFFFFFFFFF' X'E0' S-Z\n         DC    X'00000000000000000000FFFFFFFFFFFF' X'F0' 0-9\n*                000102030405060708090A0B0C0D0E0F    ..\n*\nZDISP    DS    0X\n*                0123456789ABCDEF\n         DC    C'................'                       X'00'\n         DC    C'................'                       X'10'\n         DC    C'................'                       X'20'\n         DC    C'................'                       X'30'\n         DC    X'40',C'.........',X'4A4B4C4D4E4F'        X'40'\n         DC    X'50',C'.........',X'5A5B5C5D5E5F'        X'50'\n         DC    X'60',C'.........',X'6A6B6C6D6E6F'        X'60'\n         DC    C'.........',X'797A7B7C7D7E7F'            X'70'\n         DC    C'.ABCDEFGHI',X'8A8B8C8D8E8F'             X'80'\n         DC    C'.JKLMNOPQR',X'9A9B9C9D9E9F'             X'90'\n         DC    C'.',X'A1',C'STUVWXYZ',X'AAABACADAEAF'    X'A0'\n         DC    C'................'                       X'B0'\n         DC    X'C0',C'ABCDEFGHI',X'CACBCCCDCECF'        X'C0'\n         DC    X'D0',C'JKLMNOPQR.',X'DBDCDDDEDF'         X'D0'\n         DC    X'E0',C'.STUVWXYZ',X'EAEB',C'.',X'EDEEEF' X'E0'\n         DC    C'0123456789......'                       X'F0'\n*                0123456789ABCDEF\n*\n         LTORG ,\n         TITLE 'DSECTS'\n**************************************************************\n* Dynamic savearea & workarea\n**************************************************************\nSAVEAREA DSECT ,\n         DS    19F\nXWORK    DC    CL9' '\nFWORD    DC    F'0'\n*\nPARMS    DS    0XL12                   parmlist:\n@TITLE   DC    A(0)                    A(title)\n@START   DC    A(0)                    A(beginning of storage)\n@END     DC    F'0'                    A(end of storage)\n*\nCLABEL   DC    C'DISPLAYING '\nCSTART   DC    CL8' '\nCRANGE   DC    C':'\nCEND     DC    CL8' '\nCSPACE1  DC    C' '\nCHEXLEN  DC    CL8' '\nL$SPECS  EQU   *-CLABEL                length of stor specs\n*\nCFORMAT  DS    0C\nCADDR    DC    C'XXXXYYYY  '           address\nCDISPL   DC    C'DDDD  '               displacement\nCWORD1   DC    C'AABBCCDD '            1st word\nCWORD2   DC    C'AABBCCDD '            2nd word\nCWORD3   DC    C'AABBCCDD '            3rd word\nCWORD4   DC    C'AABBCCDD '            4th word\nCSTAR1   DC    C'*'\nCCHAR    DC    C'....++++....++++'     char values\nCSTAR2   DC    C'*'\nL$FORMAT EQU   *-CFORMAT               length of output line\n*\n         DS    0F                      align\nCBYTES   DC    C'AABBCCDD '            CWORDn workarea\n*\n         DS    0F\nCJUNK    DC    CL8' '\nDISPL    DC    F'0'\n         DS    0D\nL$SAV    EQU   *-SAVEAREA              length of savearea\n         EJECT ,\n         WAXMT FUNC=UTIL\n         PRINT GEN\nUTILSNAP UFINI DXDUSNAP,L$SAV\n         END   ,\n./ ADD NAME=UTILTIOT 0100-02182-02182-0702-00110-00110-00000-XMIT370\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n         PRINT  NOGEN\n         IHAPSA DSECT=YES              PREFIXED STORAGE AREA\n*\n         IKJTCB DSECT=YES,LIST=NO      TASK CONTROL BLOCK\n*\nTIOT     DSECT\n         IEFTIOT1                      TASK INPUT-OUTPUT TABLE\n*\n         PRINT GEN\nUTILTIOT TITLE 'Scan TIOT for DDNAME'\n*----------------------------------------------------------------------\n*\n*  UTILTIOT is called before UTILDIAG has finished setting up the\n*  debug bytes, so UTILTIOT's message(s) always appear.\n*  Not really very useful, and mildly annoying.  The DIAG=NO\n*  suppresses expansion of XMITDIAG in this CSECT.\n*\n         U#SET DIAG=NO                 suppress XMITDIAG\n*----------------------------------------------------------------------\n* Function:    Given a DDNAME, determine whether it is allocated\n*              by scanning the TIOT.\n*\n* Entry:  R0 =\n*         R1 = address of CL8'ddname' field\n*\n* Exit:   R1  =  address of TIOT entry\n*                0     DDNAME not allocated\n*\n* Notes:\n*\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\n* R2     TIOT entry\n* R3\n* R4\n* R5\n* R6\n* R7\n* R8\n* R9     DDNAME ptr\n* R10\n*----------------------------------------------------------------------\nUTILTIOT UPROC ID=UTIO,L=L$SAV\n         LR    R9,R1                        save caller's R1\n         UDIAG 1,'UTILTIOT entered'\n         UDIAG 3,'UTILTIOT: ddname',(R9),8\n         EJECT ,\n*----------------------------------------------------------------------\n*  Find TIOT, see if ddname allocated\n*----------------------------------------------------------------------\n         USING PSA,0\n         L     R15,PSATOLD             my TCB\n         USING TCB,R15\n*\n         L     R14,TCBTIO              TCB's TIOT\n         DROP  R15\n         USING TIOT1,R14\n*\n         LA    R2,TIOENTRY             @ 1st entry\n         DROP  R14\n         USING TIOENTRY,R2\n*\n         SLR   R6,R6\n*\nNEXTENT  DS    0H\n         ICM   R6,1,TIOELNGH           TIOT entry length\n         BZ    EOT                     no more entries\n*\n         CLC   TIOEDDNM,0(R9)          found DDNAME?\n         BE    FOUND\n*\n         LA    R2,0(R6,R2)             @ next entry\n         B     NEXTENT\n*\nEOT      DS    0H\n         UDIAG 3,'UTILTIOT ddname not allocated'\n         XC    SARETVAL,SARETVAL       TIOT entry ptr = 0\n         B     EXIT\n*\nFOUND    DS    0H\n         UDIAG 3,'UTILTIOT ddname allocated'\n         ST    R2,SARETVAL             TIOT entry ptr\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\nEXIT     UDIAG 1,'UTILTIOT exited'\n         L     R1,SARETVAL             return value = TIOT ptr or 0\n         SLR   R15,R15\n         UPEND R1=PASS                 return to caller w/ R1 intact\n*\n         LTORG ,\n*----------------------------------------------------------------------\n*  Dynamic savearea & workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSAVREGS  DS    18F\nSARETVAL DS    F                       return value (R1)\n         DS    0D\nL$SAV    EQU   *-SAVEAREA              length of savearea\n*\n         PRINT NOGEN\n         WAXMT FUNC=UTIL\n*\n         PRINT GEN\nUTILTIOT UFINI DXDUTIOT,L$SAV\n         END   ,\n./ ADD NAME=UZERO    0100-02182-02182-0702-00022-00022-00000-XMIT370\n         MACRO\n&LABEL   UZERO &ADDR,&LENGTH\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n&LABEL   IM#LALR R0,&ADDR              destination address\n         AIF   ('&LENGTH'(1,1) EQ '(').LALR\n         AIF   ('&LENGTH'(1,1) EQ '*').LALR\n         AIF   ('&LENGTH'(1,1) EQ '.').LALR\n.*\n         L     R1,=A(&LENGTH)          destination length\n         AGO   .JOIN\n.*\n.LALR    IM#LALR R1,&LENGTH            destination length\n.*\n.*       Put off clearing R15 until the last possible moment\n.*       in case the contents of R0 & R1 above depend on R15\n.*       Also, since R15 is zero we don't need to set R14\n.*\n.JOIN    SLR   R15,R15                 source length\n         MVCL  R0,R14                  set storage to x'00'\n         MEND\n./ ADD NAME=WARGS    0100-02182-02182-0702-00037-00037-00000-XMIT370\n         MACRO\n         WARGS &SECT=DSECT\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n*----------------------------------------------------------------------\n*  WARGS: RECVGET workarea (embedded in WAXMT)\n*----------------------------------------------------------------------\nRGSWA    IM#SECT &SECT                 RECVGET workArea\n*\nRGSFLG1  DS    X                       status flag 1\nRGS1FINI EQU   128                     segment complete\nRGS1RES  EQU   1                       residual data valid\n*\nRGSFLG2  DS    X                       status flag 2\nRGS2EOF  EQU   1                       XMITIN EOF\n*\n         DS    0D\nRGSROFF  DS    H                       residual data offset w/i RGSBUF\nRGSBUF   DS    XL80                    residual data\n*\nRGSSL    DS    H                       # bytes in RGSSEG\nRGSSEG   DS    XL255                   segment buffer (XMITSEG)\n*\nL$RGSNAP EQU   *-RGSWA                 length of RECVGET exit SNAP\n         DS    CL80                    slop for RECVGET overexuberance\n*\nRGSOPN   OPEN  (,),MF=L\nRGSCLOS  CLOSE (,),MF=L\n*\nRGSDCB   DCB   DDNAME=XMITIN,                                          +\n               MACRF=GM,DSORG=PS,RECFM=FB,                             +\n               LRECL=80\n*\n         DS    0D\nL$RGSWA  EQU   *-RGSWA                 L'RGSWA\n         MEND\n./ ADD NAME=WAXMT    0100-02182-02182-0702-00192-00192-00000-XMIT370\n         MACRO\n         WAXMT &FUNC=XMIT,&GEN=NO,&DATA=NO,&PRINT=OFF\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n.*---------------------------------------------------------------------\n.* &FUNC  - XMIT, RECV, or UTIL\n.* &GEN   - NO, or null\n.* &DATA  - NO, or null\n.* &PRINT - ON, or OFF\n.*---------------------------------------------------------------------\n         PUSH  PRINT,USING\n         PRINT &PRINT.,&GEN.GEN,&DATA.DATA\n.*\n         AIF   ('&FUNC' NE 'XMIT').NOPS\n         EJECT ,\n         WAXPS ,                       need length of XMITPUT workarea\n.NOPS    AIF   ('&FUNC' NE 'RECV').NOGS\n         EJECT ,\n         WARGS ,                       need length of RECVGET workarea\n.NOGS    ANOP\n         EJECT ,\n*----------------------------------------------------------------------\n* XMTWA: XMIT370 and RECV370 common workarea - based R11\n*----------------------------------------------------------------------\nXMTWA    DSECT ,\nXMTEYE   DC    C'XMITDSA '             eyecatcher\n*\nXMTSA1   DS    18F                     XMIT370/RECV370 savearea\nXMTLDSA  DS    F                       # bytes gotten for DSA\nXMTRC    DS    F                       XMIT370 return code\nXMT@PARM DS    A                       address of OS entry parm\n*----------------------------------------------------------------------\n*  Global status flags\n*----------------------------------------------------------------------\nXMTFLG1  DS    X\nXMT1ABND EQU   128                     UABEND in progress\nXMTF1$U  EQU   64                      XMTDCBI is unloaded DS\n*\nXMTFLG2  DS    X\nXMT2SUPR EQU   128                     Supervisor state\nXMT2HERC EQU   64                      Hercules emulator present\nXMT2QID  EQU   32                      CPUid queried, XMT2HERC valid\n*\nXMTFLG3  DS    X\n*\nXMTFLG4  DS    X\n*----------------------------------------------------------------------\n*  Debug bytes\n*----------------------------------------------------------------------\n*\n*  Debug level bytes, set by XMITDBUG, tested by XMITDIAG & XMITPSR\n*  One byte per CSECT that issues XMITDIAG or XMITPSR\n*  Values range from C'0' (always issue msg) or C'9'\n*  XMITDIAG & XMITPSR manufacture the XMTDxxxx name from CSECT name\n*\n         DS    0F\nXMTDLEV  DS    C             default from PARM=\nXMTDABND DS    C                       UTILABND\nXMTDBLK  DS    C                       RECVBLK\nXMTDBUF  DS    C                       XMITBUF\nXMTDCPR1 DS    C                       XMITCPR1\nXMTDCTL  DS    C                       RECVCTL\nXMTDDBUG DS    C                       UTILDBUG\nXMTDDIR  DS    C                       XMITDIR\nXMTDESZ  DS    C                       XMITESZ\nXMTDGET  DS    C                       RECVGET\nXMTDHEX  DS    C                       UTILHEX\nXMTDLOG  DS    C                       UTILLOG\nXMTDPSR  DS    C                       UTILPSR\nXMTDPUT  DS    C                       XMITPUT\nXMTDRCPY DS    C                       RECVRCPY\nXMTDSNAP DS    C                       UTILSNAP\nXMTDTIOT DS    C                       UTILTIOT\nXMTDUNLD DS    C                       XMITUNLD\nXMTDUTIL DS    C                       RECVUTIL\nXMTD01   DS    C                       XMIT01\nXMTD02A  DS    C                       XMIT02A\nXMTD02B  DS    C                       XMIT02B\nXMTD03   DS    C                       XMIT03\nXMTD06   DS    C                       XMIT06\nXMTD370  DS    C                       XMIT370/RECV370\nXMTDEND  EQU   *                       end of diagnostic area\n         DS    CL4                     spares\n*----------------------------------------------------------------------\n*  Data management areas\n*----------------------------------------------------------------------\nXMT@PS   DS    A                       @ XPSWA XMITPUT workarea\nXMT@GS   EQU   XMT@PS,4                @ XGSWA RECVGET workarea\n*\nXMTOPN   OPEN  (,),MF=L\nXMTCLOS  CLOSE (,),MF=L\n*\nXMT@JFCB DS    A                       @ JFCB for open XMTDCBI\nXMTJFCBL DS    F                       JFCB exlst for XMTDCBI\n*\n         DS    0F\nXMTJFCB1 DS    XL176                   SYSUT1 JFCB area\n*\n         DS    0F\nXMTJFCB2 DS    XL176                   SYSUT2 JFCB area\n*\n*  XMIT02A fills in 44 byte dsn from JFCB, to make IEFJFCBN\n*  offsets usable (based from XMTDSCB), and debug ease.\n*\n         DS    0F\nXMTDSCB  DS    CL44                    SYSUT1 DSCB dsname\n*\n*  Format-1 DSCB of dataset to be XMIT'd.\n*  OBTAIN macro returns first 96 bytes of XMTDSCB1 = data portion\n*  of DSCB, next 5 bytes = CCHHR of DSCB (zero for VSAM/VIO).\n*\n         DS    0F\nXMTDSCB1 DS    XL140                   SYSUT1 OBTAIN area\n*----------------------------------------------------------------------\n* Input DCB\n*----------------------------------------------------------------------\nXMTDCBI  DCB   DDNAME=SYSUT2,                                          +\n               MACRF=PM,DSORG=PS,RECFM=VB,                             +\n               LRECL=0,BLKSIZE=6144\n*----------------------------------------------------------------------\n* Output DCB\n*----------------------------------------------------------------------\nXMTDCBO  DCB   DDNAME=OUTPUT,                                          +\n               MACRF=PM,DSORG=PS,RECFM=FB,                             +\n               LRECL=80,BLKSIZE=3200\n*----------------------------------------------------------------------\n* Log DCB\n*----------------------------------------------------------------------\nXMTDCBL  DCB   DDNAME=XMITPRT,                                         +\n               MACRF=PM,DSORG=PS,RECFM=FB,                             +\n               LRECL=80,BLKSIZE=6080\n*----------------------------------------------------------------------\n*  Debug areas\n*----------------------------------------------------------------------\n         DS    0D\n         USNAP MF=L                    common diagnostic parmlist\n*\n         DS    0D\nXMTREGS  DS    16F                     R0:R15  - diagnostic workarea\n*\n         DS    0D\nXMTABEND DS    16F                     R14:R13 - pre-ABEND\n*\nXMTZAP   DS    8F                      zap workarea\n.*\n.*  FUNC=XMIT or FUNC=RECV workarea\n.*\n.*\n.*  The following areas vary depending on whether or not we're\n.*  running as XMIT370 or RECV370.  Any data common to both\n.*  should occur before here.  FUNC=UTIL code may not place\n.*  data following this point.\n.*\n         AIF   ('&FUNC' NE 'XMIT').NOXMIT\n*----------------------------------------------------------------------\n*  XMITPUT's workarea\n*----------------------------------------------------------------------\n         DS    0D\nXMTXPSWE DC    CL8'PUTWORK '\nXMTXPSWA DS    XL1024                  1K reserved for XMITPUT workarea\nXXPUT    EQU   1024-L$XPSWA            Asm error if workarea exceeds 1K\n         AGO   .FINI\n.*\n.NOXMIT  AIF   ('&FUNC' NE 'RECV').NORECV\n*----------------------------------------------------------------------\n*  RECVGET's workarea\n*----------------------------------------------------------------------\n         DS    0D\nXMTRGSWE DC    CL8'GETWORK '           RECVGET workarea eyecatcher\nXMTRGSWA DS    XL1024                  1K reserved for RECVGET workarea\nXXGET    EQU   1024-L$RGSWA            Asm error if workarea exceeds 1K\n         AGO   .FINI\n.*\n.NORECV  AIF   ('&FUNC' NE 'UTIL').FINI\n*----------------------------------------------------------------------\n*  Space allocated for either XMITPUT or RECVGET workarea\n*  Note FUNC=UTIL routines may not use any of this space\n*----------------------------------------------------------------------\n         DS    0D\nXMTXUTL1 DC    CL8'xxxWORK '           GETWORK or PUTWORK\nXMTXUTL2 DS    XL1024                  1K - XPSWA or RGSWA\n         AGO   .FINI\n.*\n.FINI    ANOP\n*----------------------------------------------------------------------\n*  End of XMTWA\n*----------------------------------------------------------------------\nXMTFINI  DS    0D                      end of XMTWA\nL$XMTWA  EQU   *-XMTWA\n         POP   PRINT,USING\n         MEND  ,\n./ ADD NAME=WAXPS    0100-02182-02182-0702-00029-00029-00000-XMIT370\n         MACRO\n         WAXPS &SECT=DSECT\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n*----------------------------------------------------------------------\n*  WAXPS: XMIT370 PUTSEG support workarea (embedded in WAXMT)\n*  Our eyecatcher is in XMTWA, and is 'PUTWORK '\n*----------------------------------------------------------------------\nXPSWA    IM#SECT &SECT                 Xmit370 PutSeg WorkArea\nXPSSA    DS    18F                     savearea for QSAM\nXPSFLG1  DS    X                       status flag\nXPS1OPN  EQU   128                     DCB opened (once is enough)\n*\n         DS    0D\nXPSRL    DS    F                       residual length in XPSSEG\nXPSSEG   DS    XL(12+80)               segment workarea + slop\n*\n         DS    0D\nXPSOPN   OPEN  (,),MF=L\nXPSCLOS  CLOSE (,),MF=L\nXPSEXL   DS    4F                      DCB exit list\n*\nXPSDCB   DCB   DDNAME=SYSUT1,                                          +\n               MACRF=PM,DSORG=PS,RECFM=FB,                             +\n               LRECL=80,BLKSIZE=3200   might need EXLST to fix blksize\n         DS    0D\nL$XPSWA  EQU   *-XPSWA                 L'XPSWA\n         MEND\n./ ADD NAME=XMITBUF  0100-02182-02182-0702-00110-00110-00000-XMIT370\nXMITBUF  TITLE 'SPLIT buffer into segment(s), write'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  Things to do:\n*----------------------------------------------------------------------\n         U#SET ,\n*----------------------------------------------------------------------\n* Function: Given a BSAM buffer, split the buffer into segment(s),\n*           and write the segments by calling XMITPUT (PUTSEG).\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         R0  = length of buffer\n*         R1  = address of buffer\n*\n* Exit:   R15 = return code\n*         R15 = 00 success\n*\n* Abends:\n*\n* Notes:\n*----------------------------------------------------------------------\n* R2     XBUWA\n* R3     2 (constant)\n* R4     @ segment data\n* R5     length remaining in segment data\n* R6     length of input buffer = blksize\n* R7     address of input buffer\n* R8     length of segment to be written\n* R9     253 (constant)\n* R10\n* R11    XMTWA\n* R12    base reg\n* R13    savearea\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\nXMITBUF  UPROC L=L$XBUWA,ID=XBUF,WA=XBUWA\n         LR    R6,R0\n         LR    R7,R1\n         UDIAG 1,'XMITBUF entered'\n         UDIAG 3,'XMITBUF input block',(R7),(R6)\n*----------------------------------------------------------------------\n* Create segment\n*----------------------------------------------------------------------\n         LA    R3,L'XBUSEGL+L'XBUSEGF  l' overhead\n         LA    R9,L'XBUSEGD            max # seg data bytes permitted\n         MVI   XBUSEGF,SEG$1           turn on 'first' flag\nSPLIT    DS    0H\n         LTR   R6,R6                   anything left in buffer?\n         BNP   EXITRC0\n         LR    R8,R9                   assume max # bytes in segment\n         CR    R6,R9\n         BH    NOTLAST\n         OI    XBUSEGF,SEG$L           last segment\n         LR    R8,R6\nNOTLAST  DS    0H\n         AR    R8,R3                   segment length (except flag)\n         STC   R8,XBUSEGL\n         SR    R8,R3\n         BCTR  R8,0\n         EX    R8,COPY                 copy buffer data to segment\n         LA    R8,1(,R8)\n         LA    R7,0(R8,R7)             bump to next avail char\n         SR    R6,R8\n*----------------------------------------------------------------------\n* Write INMR03 segment\n*----------------------------------------------------------------------\nWRITE    DS    0H\n         LA    R1,XBUSEG\n         UCALL XMITPUT                 write INMR03 segment\n         NI    XBUSEGF,255-SEG$1       not first segment anymore\n         LTR   R15,R15\n         BZ    SPLIT\n         BNZ   EXIT\n*\nEXITRC0  DS    0H\n         SLR   R15,R15\n*\nEXIT     DS    0H\n         ST    R15,XBURC\n         UDIAG 1,'XMITBUF exited'\n         L     R15,XBURC\n         UPEND ,\n*\nCOPY     MVC   XBUSEGD(*-*),0(R7)      copy data\n*\n         LTORG ,\n         EJECT ,\n*----------------------------------------------------------------------\nXBUWA    DSECT ,\nXBUSA    DS    18F\n*\nXBURC    DS    F             return code\nXBUSEG   DS    0D            segment\nXBUSEGL  DS    X             segment length\nXBUSEGF  DS    X             segment flag\nXBUSEGD  DS    XL253         segment data\n         DS    0D\nL$XBUWA  EQU   *-XBUWA\n         EJECT ,\n         PRINT NOGEN\n         DXMITSEG ,\n         EJECT ,\n         WAXMT FUNC=XMIT\n         PRINT GEN\nXMITBUF  UFINI DXDXBUF,L$XBUWA\n         END   ,\n./ ADD NAME=XMITCPR1 0100-02182-02182-0702-00356-00356-00000-XMIT370\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n         PRINT  NOGEN\n*\n         DCBD   DSORG=PS,DEVD=DA\n*\nJFCB     DSECT ,\n         IEFJFCBN ,\nL$JFCB   EQU   *-JFCB\n*\nDSCB1    DSECT ,\n         IECSDSL1 (1)                  FORMAT-1 DSCB\n*\n*  The following 'DX' definition(s) are to allow us to assemble on\n*  either MVS38j or something more modern.  They echo the 'DS'\n*  definitions in later MVS versions.\n*\nDX1SMSFG EQU   DS1DSNAM+X'4E',1          SMS indicators\nDX1SCEXT EQU   DS1DSNAM+X'4F',3          secondary space extension\nL$DSCB1  EQU   *-DSCB1\n*\n         PRINT GEN\n         EJECT ,\n         DCOPYR1 BDW=YES,RDW=YES\nXMITCPR1 TITLE 'Fix IEBCOPY COPYR1 record'\n*----------------------------------------------------------------------\n         U#SET ,\n*----------------------------------------------------------------------\n* Function:    Given an IEBCOPY unload COPYR1 record, change it's\n*              length as specified by the COPYR1 DDNAME's LRECL.\n*              Fields in the extended section are filled in, where\n*              possible, only if they are x'00's.\n*\n* Entry:  R0 =\n*         R1 = address of IEBCOPY COPYR1 record's BDW\n*\n* Exit:   R15 =  0     everything is OK\n*                else  error\n*\n* Notes:  The IEBCOPY program has changed the length and contents of\n*         the COPYR1 record based on the maintenance level of IEBCOPY.\n*\n*         When the user wishes to create a COPYR1 record which doesn't\n*         match the current level of IEBCOPY running on this system,\n*         coding DCB attributes on the COPYR1 DDNAME will instruct this\n*         code to modify the COPYR1 record before it's written to the\n*         XMIT output file.  Following are the values to code on\n*         COPYR1 DDNAME for various levels of IEBCOPY maintenance:\n*\n*         MVS38j      (RDW)  LRECL=56     payload: 52 bytes (x'34')\n*         MVS/ESA     (RDW)  LRECL=60     payload: 56 bytes (x'38')\n*\n*         which is to say the LRECL= value specifies the length to\n*         drop into the RDW, which is 4 greater than the payload's\n*         (data following the RDW) length.\n*\n*         The DCB attributes are what are appropriate to RECEIVE the\n*         XMIT file on the specified levels of MVS.  The COPYR1\n*         allocation doesn't have to specify an actual dataset, it\n*         can be DUMMY, as below:\n*\n*         //COPYR1  DD DUMMY,DCB=LRECL=xx\n*\n*         If no LRECL value is specified, XMITCPR1 will default\n*         to the longest COPYR1 of which it is aware, which should\n*         usually work pretty well.  In such a case, simply code\n*\n*         //COPYR1  DD DUMMY\n*\n*         Allowing the LRECL length to be coded might allow for\n*         some future distinctions between further variations,\n*         or possibly have use to someone modifying this code.\n*\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\n* Register usage (except MODTAB code)\n*----------------------------------------------------------------------\n* R2     TIOT entry\n* R3     DCB\n* R4     JFCB\n* R5\n* R6     scratch\n* R7     old COPYR1 record length\n* R8     new COPYR1 record length\n* R9     address of COPYR1 record (@ BDW)\n* R10\n*----------------------------------------------------------------------\nXMITCPR1 UPROC ID=XCP1,L=L$SAV\n         LR    R9,R1                        save caller's R1\n         USING COPYR1,R9\n         LH    R7,XC1BDW                    old COPYR1 BDW\n         UDIAG 1,'XMITCPR1 entered'\n         UDIAG 3,'XMITCPR1: COPYR1 block @ entry',(R9),(R7)\n*----------------------------------------------------------------------\n*  See if COPYR1 ddname allocated\n*----------------------------------------------------------------------\n         LA    R1,=CL8'COPYR1'         target DDNAME\n         UCALL UTILTIOT                scan TIOT for DDNAME\n         LTR   R1,R1                   found?\n         BNZ   FOUND                   yes\n*\nNOTFOUND DS    0H\n         ULOG  'XMITCPR1 found no COPYR1 ddname, COPYR1 unmodified'\n         B     EXIT\n         EJECT ,\n*----------------------------------------------------------------------\n*  COPYR1 ddname allocated, RDJFCB to retrieve LRECL=\n*----------------------------------------------------------------------\nFOUND    DS    0H\n         LA    R3,SAVDCB\n         USING IHADCB,R3\n         MVC   SAVOPN(L$OPN),MODLOPN        copy model OPEN macro\n         STCM  R3,7,SAVOPN+1                relocate DCB ptr\n*\n         MVC   SAVDCB(L$DCB),MYDCB          copy DCB\n         LA    R0,SAVEXLST                  relocate DCB's EXLST\n         STCM  R0,7,DCBEXLSA\n*\n         MVC   SAVEXLST(L$JFCBL),JFCBLST\n         LA    R4,SAVJFCB                   relocate EXLST's JFCB addr\n         USING JFCB,R4\n         STCM  R4,7,SAVEXLST+1\n*\n         RDJFCB SAVDCB,MF=(E,SAVOPN)\n         LTR   R15,R15\n         BZ    SNAPJFCB\n         UDIAG 0,'XMITCPR1: COPYR1 RDJFCB failed'\n         UABEND ,\nSNAPJFCB DS    0H\n         UDIAG 3,'XMITCPR1: COPYR1 JFCB',SAVJFCB,L$JFCB\n         EJECT ,\n*----------------------------------------------------------------------\n*  Modify the COPYR1 record length as per COPYR1 ddname specification\n*----------------------------------------------------------------------\nL$DEFR1  EQU   L$XC1CUR-L'XC1BDW            default new RDW length\n*\n         LA    R6,4                         L'BDW & L'RDW\n         LH    R7,XC1RDW                    old COPYR1 LRECL (RDW)\n         SR    R7,R6\n         UPSR  3,'XMITCPR1 old COPYR1 payload length (hex)',(R7)\n*\n         SLR   R8,R8\n         ICM   R8,3,JFCLRECL                user spec'd new RDW length\n         BNZ   *+8\n         LH    R8,=AL2(L$DEFR1)             default new RDW length\n*\n         SR    R8,R6\n         UPSR  3,'XMITCPR1 new COPYR1 payload length (hex)',(R8)\n         AR    R8,R6\n         STH   R8,XC1RDW                    update COPYR1 RDW\n         AR    R8,R6\n         STH   R8,XC1BDW                    update COPYR1 BDW\n         EJECT ,\n         PUSH  USING\n*----------------------------------------------------------------------\n*  Modify the COPYR1 record as per MODTAB specification\n*----------------------------------------------------------------------\n* R0  = source value\n* R2  @ modification destination field\n* R3  @ modification source field\n* R4  = modification length\n* R5  = MODTAB BXLE index\n* R6  = MODTAB BXLE increment\n* R7  = MODTAB BXLE limit\n* R8  = max COPYR1 offset we're allowed to change (approximate at best)\n* R9  @ COPYR1 BDW\n* R14 = modification destination offset\n* R15 = modification source offset\n*\n         UDIAG 5,'XMITCPR1 DSCB',XMTDSCB,L$DSCB1\n         UDIAG 5,'XMITCPR1 MODTAB',MODTAB,MODEND\n         LM    R5,R7,=A(MODTAB,L$MODENT,MODEND-1)\n         USING XMODTAB,R5\n         BCTR  R8,0                            adjust max offset\n         B     MODREC\n*\nMODSKIP  DS    0H                              modification skipped\n         OI    SAFLAG1,SA1MDSKP\n         UDIAG 5,'XMITCPR1 SKIP',XMTREGS,16*4,REGS=YES\n*\nMODREC   DS    0H\n         UDIAG 9,'XMITCPR1: COPYR1 MODREC',(R9),80\n         SLR   R14,R14\n         ICM   R14,3,XMDSTOFF\n         LA    R2,COPYR1(R14)                  destination field addr\n*\n         SLR   R15,R15\n         ICM   R15,3,XMSRCOFF\n         LA    R3,XMTDSCB(R15)                 source field addr\n*\n         SLR   R4,R4\n         ICM   R4,3,XMDSTLEN                   field length\n         BCTR  R4,0\n         SLL   R4,2                            index RETRIEVE\n*\n         CR    R14,R8                          exceeded max offset?\n         BH    MODFIN2\n*\n         SLR   R0,R0\n         EX    R0,RETRIEVE(R4)                 source data\n         LTR   R0,R0                           value retrieved?\n         BZ    *+8                             no, place new value\n         BXLE  R5,R6,MODSKIP                   yes, IEBCOPY knows best\n*\n         CLC   =X'0000',XMSRCLEN               hardcoded source?\n         BE    MODHARD\n*\nMODNORML DS    0H                              normal value\n         EX    R0,MODIFY(R4)                   destination data\n         UDIAG 5,'XMITCPR1 NORM',XMTREGS,16*4,REGS=YES\n         BXLE  R5,R6,MODREC\n         B     MODFIN\n*\nMODHARD  DS    0H                              hard-coded value\n         SLR   R0,R0\n         ICM   R0,3,XMSRCOFF                   source data\n         EX    R0,MODIFY(R4)                   modify destination data\n         UDIAG 5,'XMITCPR1 HARD',XMTREGS,16*4,REGS=YES\n         BXLE  R5,R6,MODREC\n         B     MODFIN\n*\nRETRIEVE ICM   R0,1,0(R3)\n         ICM   R0,3,0(R3)\n         ICM   R0,7,0(R3)\n         ICM   R0,15,0(R3)\n*\nMODIFY   STCM  R0,1,0(R2)\n         STCM  R0,3,0(R2)\n         STCM  R0,7,0(R2)\n         STCM  R0,15,0(R2)\n         POP   USING\n*\nXMODTAB  DSECT ,\nXMDSTOFF DS    XL2                     destination field offset\nXMDSTLEN DS    XL2                     destination field length\nXMSRCOFF DS    XL2                     source field offset\nXMSRCLEN DS    XL2                     source field length\nXMITCPR1 CSECT ,\n         EJECT ,\n*----------------------------------------------------------------------\n*  COPYR1 update complete\n*----------------------------------------------------------------------\nMODFIN   DS    0H\n         TM    SAFLAG1,SA1MDSKP        modification(s) skipped?\n         BNO   MODFIN3\nMODFIN2  DS    0H\n         STM   R0,R15,XMTREGS\n         ULOG  'XMITCPR1 ignored some MODTAB updates'\n         UDIAG 3,'XMITCPR1 regs',XMTREGS,16*4\nMODFIN3  DS    0H\n         LH    R6,0(,R9)                    COPYR1 BDW\n         UDIAG 3,'XMITCPR1: COPYR1 block @ exit',(R9),(R6)\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\nEXIT     UDIAG 1,'XMITCPR1 exited'\n         UPEND ,                       return to caller\n         EJECT ,\n*----------------------------------------------------------------------\n*  COPYR1 mods table\n*----------------------------------------------------------------------\n*\n*  Format of table entry:\n*\n*     Destination offset, destination length\n*     Source offset, source length,\n*\n*  when source length = 0, source offset is the value to be applied;\n*  else source length = destination length.\n*\n*  Entries are in ascending destination offset order.\n*\n         PUSH  PRINT,USING\n         PRINT DATA\n         USING DSCB1,R15                       bogus using\n*\nMODTAB   DS    0D\n         DC    AL2(XC1SMSFG-COPYR1,L'XC1SMSFG)\n         DC    AL2(DX1SMSFG-DSCB1,L'DX1SMSFG)      SMS indicators\nL$MODENT EQU   *-MODTAB\n*\n         DC    AL2(XC1HDRCT-COPYR1,L'XC1HDRCT)     hdrcount\n         DC    AL2(2,0)\n*\n         DC    AL2(XC1RESV1-COPYR1,L'XC1RESV1)     resv1 = x'00'\n         DC    AL2(0,0)\n*\n         DC    AL2(XC1LREFD-COPYR1,L'XC1LREFD)\n         DC    AL2(DS1REFD-DSCB1,L'DS1REFD)        last ref date\n*\n         DC    AL2(XC1SCEXT-COPYR1,L'XC1SCEXT)\n         DC    AL2(DX1SCEXT-DSCB1,L'DX1SCEXT)      secondary extent\n*\n         DC    AL2(XC1SCALO-COPYR1,L'XC1SCALO)\n         DC    AL2(DS1SCALO-DSCB1,L'DS1SCALO)      secondary allocation\n*\n         DC    AL2(XC1LSTAR-COPYR1,L'XC1LSTAR)\n         DC    AL2(DS1LSTAR-DSCB1,L'DS1LSTAR)      last used TTR\n*\n         DC    AL2(XC1TRBAL-COPYR1,L'XC1TRBAL)\n         DC    AL2(DS1TRBAL-DSCB1,L'DS1TRBAL)      trk balance\n*\n         DC    AL2(XC1RESV2-COPYR1,L'XC1RESV2)     resv2 = x'0000'\n         DC    AL2(0,0)\nMODEND   EQU   *\n         POP   PRINT,USING\n         EJECT ,\nMODLOPN  OPEN  (,INPUT),MF=L           model OPEN\nL$OPN    EQU   *-MODLOPN               l' model open\n*\n         PUSH  PRINT\n         PRINT NOGEN\nMYDCB    DCB   DDNAME=COPYR1,EXLST=0,DSORG=PS,MACRF=E\nL$DCB    EQU   *-MYDCB\n         POP   PRINT\n*\nJFCBLST  DS    0F\n         DC    XL1'87'\n         DC    AL3(0)\nL$JFCBL  EQU   *-JFCBLST\n*\nCAMLST   CAMLST SEARCH,1,2,3           OBTAIN parmlist\n         LTORG ,\n*----------------------------------------------------------------------\n*  Dynamic savearea & workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSAVREGS  DS    18F\n*\nSAFLAG1  DS    X\nSA1MDSKP EQU   128                     some MODTAB mod(s) skipped\n*\n         DS    0F\nSAVOPN   OPEN  (,INPUT),MF=L           open parmlist\n         PUSH  PRINT\n         PRINT NOGEN\nSAVDCB   DCB   DDNAME=COPYR1,DSORG=PS,MACRF=E\n         POP   PRINT\nSAVEXLST DS    F                       DCB EXLST=\n         DS    0D                      align\nSAVJFCB  DS    CL(L$JFCB)              JFCB\nSAVCAML  CAMLST SEARCH,1,2,3           CAMLST\nL$CAMLST EQU   *-SAVCAML\n         DS    0D\nSAVDSCB  DS    CL140                   Format1 DSCB (minus dsn), cchhr\n         DS    CL5\n         DS    0D\nL$SAV    EQU   *-SAVEAREA              length of savearea\n         EJECT ,\n*\n         WAXMT FUNC=XMIT,PRINT=OFF\n*\nXMITCPR1 UFINI DXDXCPR1,L$SAV\n         END   ,\n./ ADD NAME=XMITDIR  0100-02182-02182-0702-00149-00149-00000-XMIT370\nXMITDIR  TITLE 'Determine Directory blocks allocated'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  Things to do:\n*----------------------------------------------------------------------\n         U#SET ,\n*----------------------------------------------------------------------\n* Function: Determine number of directory blocks allocated\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         R0  =\n*         R1  =  open SYSUT1 DCB, DSORG=PO\n*\n* Exit:   R15 = return code\n*         R15 = 00 success; R0 = # directory blocks\n*\n* Abends: input PDS broken in some way\n*\n* Notes:  It's OK for us to read the directory of the PDS, since no\n*         one else (like XMIT02B) will read a DSORG=PO dataset.\n*         Well, except IEBCOPY when we tell him to.\n*----------------------------------------------------------------------\n* R2     DCB\n* R3\n* R4     IOB\n* R5     # dir blocks\n* R6     DECB\n* R7     DCBBLKSI\n* R8     length of directory block\n* R9     @ directory block\n* R10\n* R11    XMTWA\n* R12    base reg\n* R13    savearea\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\nXMITDIR  UPROC L=L$XDRWA,ID=XMDR,WA=XDRWA\n         LR    R2,R1                   SYSUT1 open DCB\n         USING IHADCB,R2\n         UDIAG 1,'XMITDIR entered'\n*----------------------------------------------------------------------\n*  Initialize\n*----------------------------------------------------------------------\n         TM    DCBRECFM,DCBRECF        PDS directory must be recfm=f\n         BNO   BROKEN\n         TM    DCBRECFM,DCBRECU             recfm=u not acceptable\n         BO    BROKEN\n         LA    R0,EOFRTN\n         STCM  R0,7,DCBEODA                 set EOF exit rtn addr\n         MVC   XDRDECBI(L$DECB),MODLDECB    copy model DECB\n         LH    R7,DCBBLKSI                  get blksize\n         ST    R7,XDRBUFL\n         GETMAIN R,LV=(R7)                  alloc input buffer\n         LR    R9,R1\n*\n*  Read pds directory, counting directory blocks\n*  This is offensively simple-minded, but there doesn't appear to be\n*  an MVS control block which records the number of directory blocks\n*  allocated to a PDS; even the DSCB doesn't have the info.\n*  We return the # dir blocks allocated, not used, so hopefully\n*  the RECEIVE program at the other end will allocate sufficient\n*  directory blocks, rather than the usual number used, which causes\n*  me huge amounts of grief, and probably you, too.\n*\n         SLR   R5,R5                        # dir blocks = 0\n*----------------------------------------------------------------------\n*  Read a directory block\n*----------------------------------------------------------------------\n         LA    R6,XDRDECBI                  @ DECB\n         USING DECB,R6\nREAD     DS    0H\n         READ  (R6),SF,(R2),(R9),'S',MF=E\n         UDIAG 2,'XMITDIR: read issued'\n         CHECK XDRDECBI\n         UDIAG 3,'XMITDIR: dcb after CHECK',(R2),L$DCB\n         UDIAG 3,'XMITDIR: decb after CHECK',(R6),L$DECB\n*----------------------------------------------------------------------\n*  Determine length of data retrieved, bail if not 256\n*----------------------------------------------------------------------\n         LH    R8,DCBBLKSI             l' READ 'S' request\n         L     R4,DECIOBPT             @ IOB\n         USING IOBSTDRD,R4\n         UDIAG 3,'XMITDIR: IOB',(R4),20\n         LH    R0,IOBSTBYT+2           residual count\n         SR    R8,R0                   = l' read\n*\n         UDIAG 3,'XMITDIR directory block',(R9),(R8)\n         C     R8,=F'256'              verify block length valid\n         BNE   BROKEN\n*----------------------------------------------------------------------\n*  Count block just read\n*----------------------------------------------------------------------\n         LA    R5,1(,R5)               accumulate # dir blocks\n         B     READ\n*\nEOFRTN   DS    0H                      END OF FILE branches here\n         SLR   R15,R15\n*\nEXIT     DS    0H\n         ST    R15,XDRRC\n         L     R0,XDRBUFL\n         LTR   R0,R0\n         BZ    NOFREE\n         LR    R1,R9\n         FREEMAIN R,LV=(0),A=(1)\nNOFREE   DS    0H\n         ST    R15,XDRRC\n         UDIAG 1,'XMITDIR exited'\n         L     R15,XDRRC\n         LR    R0,R5                        return dir blocks\n         UPEND R0=RETURN\n*\nBROKEN   DS    0H\n         ULOG  'XMITDIR: input dataset broken'\n         ULOG  'Either RECFM not F or dir block length not 256'\n         UABEND ,                           recfm=v or bad l' dirblk\n*\nMODLDECB READ MODLECB,SF,0,0,'S',MF=L\nL$DECB   EQU  *-MODLDECB\n*\n         LTORG ,\n*----------------------------------------------------------------------\n         EJECT ,\nXDRWA    DSECT ,\nXDRSA    DS    18F\nXDRBUFL  DS    F             l' gotten buffer\nXDRDECBI READ  XDRECBI,SF,0,0,'S',MF=L\n*\nXDRRC    DS    F             return code\n         DS    0D\nL$XDRWA  EQU   *-XDRWA\n*\n         EJECT ,\n         PRINT NOGEN\n         WAXMT FUNC=XMIT\n*        EJECT ,\n         IHADECB ,\n*        EJECT ,\n         IEZIOB ,\n*        EJECT ,\n         DCBD  DSORG=PS,DEVD=DA\nL$DCB    EQU   *-IHADCB\n         PRINT GEN\nXMITDIR  UFINI DXDXDIR,L$XDRWA\n         END   ,\n./ ADD NAME=XMITESZ  0100-02182-02182-0702-00140-00140-00000-XMIT370\nXMITESZ  TITLE 'Estimate dataset SiZe'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  Things to do:\n*----------------------------------------------------------------------\n         U#SET ,\n*----------------------------------------------------------------------\n* Function: Estimate the number of bytes allocated to a dataset\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         R0  =\n*         R1  =  open DCB\n*\n* Exit:   R15 = return code\n*         R15 = 00 success; R0 = # bytes allocated (approximately)\n*\n* Abends: yes\n*\n* Notes:\n*----------------------------------------------------------------------\n* R2     scratch\n* R3     DVCT\n* R4     UCB associated with extent\n* R5     # extents\n* R6     DCB\n* R7     DEB, DEBDASD\n* R8     estimated file size in bytes\n* R9\n* R10\n* R11    XMTWA\n* R12    base reg\n* R13    savearea\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\nXMITESZ  UPROC L=L$XESWA,ID=XESZ,WA=XESWA\n         LR    R6,R1                   SYSUT1/SYSUT2 open DCB\n         USING IHADCB,R6\n         UDIAG 1,'XMITESZ entered'\n*\n*  Calculate estimated file size\n*\n         SLR   R8,R8                   # bytes allocated (estimate)\n         SLR   R7,R7\n         ICM   R7,7,DCBDEBA            @ DEB for DCB\n         USING DEBBASIC,R7\n*\n         LR    R1,R7\n         S     R1,=A(DEBPREFX-DEBBASIC)     back up to prefix\n         SLR   R2,R2\n         IC    R2,DEBLNGTH-DEBPREFX(,R1)    l' DEB in doublewords\n         SLL   R2,3                         l' DEB in bytes\n         MODESET KEY=ZERO                   DEB in key 5\n         UDIAG 3,'XMITESZ DEB',(R7),(R2)\n*\n         SLR   R5,R5\n         IC    R5,DEBNMEXT                  # extents\n         LTR   R5,R5\n         BZ    EXTDONE                      no extents\n         LA    R7,DEBBASND                  @ deb dasd section\n         USING DEBDASD,R7\n*\n* since we don't support ISAM, we don't have to worry about the\n* ISAM device dependent section possibly appearing between the\n* deb basic section and the deb dasd section.\n*\nCALCSPAC DS    0H\n         SLR   R4,R4\n         ICM   R4,7,DEBUCBA                 @ UCB for extent\n         USING UCB,R4\n         TM    UCBTBYT3,UCB3DACC            dasd device?\n         BO    DASD\n         UABEND ,                           input device not dasd\nDASD     DS    0H\n         L     R1,CVTPTR                    @ cvt\n         L     R1,CVTZDTAB-CVT(,R1)         @ ieczdtab\n         USING DVCTI,R1\n         LA    R2,DVCTYPMK                  4 low order bits mask\n         N     R2,UCBTYP                    index into ieczdtab\n         IC    R2,DVCTIOFF(R2)              offset to dvct entry\n         LA    R3,DVCTI(R2)                 @ dvct entry\n         USING DVCT,R3\n         UDIAG 3,'XMITESZ DVCT entry',(R3),DVCENTLG\n         DROP  R1\n*\n         UDIAG 3,'XMITESZ DEBDASD',(R7),L$DEBDA\n*\n         SLR   R2,R2\n         ICM   R2,3,DEBNMTRK                tracks allocated in extent\n         MH    R2,DVCTRKLN                  times bytes/track\n         AR    R8,R2                        accumulate bytes allocated\n         LA    R7,L$DEBDA(,R7)              next debdasd section\n         BCT  R5,CALCSPAC                   look at all extents\n*\nEXTDONE  DS    0H\n         MODESET KEY=NZERO                  back to key 8\n         ST    R15,XESRC\n         UDIAG 1,'XMITESZ exited'\n         L     R15,XESRC\n         LR    R0,R8                        return estimated size\n         UPEND R0=RETURN\n*\n         LTORG ,\n*----------------------------------------------------------------------\n         EJECT ,\nXESWA    DSECT ,\nXESSA    DS    18F\n*\nXESRC    DS    F             return code\n         DS    0D\nL$XESWA  EQU   *-XESWA\n*\n         EJECT ,\n         PRINT NOGEN\n         WAXMT FUNC=XMIT\n*        EJECT ,\n         IEZDEB LIST=YES\nL$DEBDA  EQU   (DEBNMTRK+L'DEBNMTRK)-DEBDASD     l' debdasd section\n*\n*        EJECT ,\nUCB      DSECT ,\n         IEFUCBOB LIST=YES\n*\n*        EJECT ,\n*----------------------------------------------------------------------\n*  See Stage2 assembly of IECZDTAB for values & index\n*----------------------------------------------------------------------\n         IHADVCT ,\n*\n*        EJECT ,\n         PRINT NOGEN\n         CVT   DSECT=YES,LIST=NO\n*\n         DCBD  DSORG=PS,DEVD=DA\n         PRINT GEN\nXMITESZ  UFINI DXDXESZ,L$XESWA\n         END   ,\n./ ADD NAME=XMITPUT  0100-02182-02182-0702-00282-00282-00000-XMIT370\nXMITPUT  TITLE 'WRITE segment'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n* Things to do:\n* 1) Provide EXLST to set BLKSIZE if not coded in JCL/JFCB\n*----------------------------------------------------------------------\n         U#SET ,\n*----------------------------------------------------------------------\n* Function: Write a segment (XMITSEG), respecting LRECL boundaries\n*           and buffer data as necessary.\n*           Similar to fputc support in the C language.\n*           This code maintains the DCB associated with it's\n*           output file.\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         R0  =\n*         R1  =  Address of buffer to be written\n*                when = 0, buffers will be flushed & DCB closed\n*                length of SEGL must be correct\n*\n* Exit:   R15 = 0\n*\n* Abends: DCB didn't open\n*         residual data handling error (buffer hosed)\n*\n* Notes:  The caller is responsible for setting the segment's\n*         length and flags.\n*         We PUT the whole segment, including the length & flag;\n*         RECEIVE needs the length & flag to reconstruct the file.\n*         Some older code's documentation might refer to this code\n*         as PUTSEG.\n*----------------------------------------------------------------------\n* R2     XPSWA\n* R3     DCB\n* R4     input buffer\n* R5     length of input buffer\n* R6     length of residual data in XPSSEG\n* R7     length of input data to copy to residual data\n* R8     scratch\n* R9     constant: 80 = LRECL\n* R10    internal linkage\n* R11    xmtwa\n* R12    base reg\n* R13    savearea\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\nXMITPUT  UPROC L=L$SA,ID=XPUT,WA=SAVEAREA\n         STM   R0,R15,XMTREGS               <debug>\n         LA    R4,0(,R1)                    save input parm, clear hi\n         UDIAG 1,'XMITPUT entered'\n         UDIAG 6,'XMITPUT entry regs',XMTREGS,16*4\n         LTR   R4,R4                        term request?\n         BZ    TERM\n         USING XMITSEG,R4\n*\n         L     R2,XMT@PS                    find our workarea\n         LTR   R2,R2                        does it exist?\n         BNZ   NORMAL\n         EJECT ,\n*----------------------------------------------------------------------\n* Initialize XPSWA\n*----------------------------------------------------------------------\n         UDIAG 2,'XMITPUT: initializing XPSWA'\n         LA    R2,XMTXPSWA\n         USING XPSWA,R2\n         UZERO (R2),L$XPSWA                 clear storage\n         MVC   XPSDCB(L$DCB),MODLDCB        copy model DCB macro\n         MVC   XPSOPN(L$OPN),MODLOPN        copy model OPEN macro\n         MVC   XPSCLOS(L$CLOS),MODLCLOS     copy model CLOSE macro\n         ST    R2,XMT@PS                    save ptr to out workarea\n         B     NORMAL\n         EJECT ,\n*----------------------------------------------------------------------\n* Terminate request\n*----------------------------------------------------------------------\nTERM     DS    0H\n         L     R2,XMT@PS\n*\n* Fill remainder of LRECL with blanks, write if any residual data\n*\n         UDIAG 6,'XMITPUT: term residual',XPSSEG,80\n         L     R6,XPSRL                     residual data length\n         LTR   R6,R6\n         BZ    TERMCLOS\n         LA    R15,80                       lrecl\n         LR    R9,R15                       <bogus> for PUT snap\n         SR    R15,R6                       # bytes to blank\n         LA    R4,XPSSEG\n         LA    R14,0(R6,R4)                 @ 1st byte to set to blank\n         MVI   0(R14),C' '                  blank to be propogated\n         BCTR  R15,0\n         EX    R15,BLANKRES                 blank rest of residual\n         UDIAG 6,'XMITPUT: term residual write',XPSSEG,80\n         BAL   R10,PUT                      write last record\nTERMCLOS DS    0H\n         UDIAG 2,'XMITPUT: closing XMITOUT ddname'\n         CLOSE (XPSDCB,),MF=(E,XPSCLOS)\n         XC    XMT@PS,XMT@PS                workarea gone\n         B     EXITRC0\n*\nBLANKRES MVC   1(*-*,R14),0(R14)            executed\n         EJECT ,\n*----------------------------------------------------------------------\n* Normal write request - open DCB if needed\n*----------------------------------------------------------------------\nNORMAL   DS    0H\n         UDIAG 6,'XMITPUT: XPSWA dump <NORMAL>',XMTXPSWE,L$XPSWA+8\n         LA    R9,80                        LRECL (constant)\n         SLR   R5,R5\n         IC    R5,SEGL                      segment length\n         UDIAG 3,'XMITPUT: input segment',(R4),(R5)\n         LA    R3,XPSDCB\n         USING IHADCB,R3\n         TM    DCBOFLG1,DCBOFOPN            dcb open?\n         BO    DCBOPEN\n         TM    XPSFLG1,XPS1OPN              not open, but did already?\n         BNO   NEWOPEN                      first time, OK\n*\n         UDIAG 0,'XMITPUT: XMITOUT DCB error',XMTXPSWE,L$XPSWA+8\n         UABEND DUMP=Y\n*\nNEWOPEN  DS    0H\n         UDIAG 2,'XMITPUT: opening XMITOUT ddname'\n         OPEN  (XPSDCB,OUTPUT),MF=(E,XPSOPN)\n         OI    XPSFLG1,XPS1OPN              OPEN request issued\n         TM    DCBOFLG1,DCBOFOPN            opened?\n         BO    DCBOPEN\n         UDIAG 0,'XMITPUT: XMITOUT DCB open error',XMTXPSWE,L$XPSWA+8\n         UABEND ,                           output DCB didn't open\n         EJECT ,\n*----------------------------------------------------------------------\n* Try to output residual data in XPSSEG before putting input buffer\n*----------------------------------------------------------------------\nCOPYRES  MVC   0(*-*,R14),0(R4)             executed\n*\nDCBOPEN  DS    0H\n         L     R6,XPSRL                     l' residual data\n         LTR   R6,R6                        any?\n         BZ    PUTINIT                      no, just put input buffer\n*\n         UDIAG 7,'XMITPUT: XPSSEG contains residual data',XPSSEG,(R6)\n         LR    R7,R9                        lrecl\n         SR    R7,R6                        minus l' residual data\n*                            R7 = # bytes needed to complete LRECL\n*\n* Calc how much data to copy from input to behind current residual.\n* A maximum of LRECL bytes will be stored in XPSSEG, the remainder\n* of the input bytes (if any) will remain in the input buffer\n* to be processed by PUTLOOP below.\n*                                           assume just enough bytes\n         LR    R15,R7                       in input seg to fill lrecl\n         CR    R5,R7                        have more than needed?\n         BH    *+6                          yes, leave r15 alone\n         LR    R15,R5                       no use l' input buffer\n*                            R15 = # bytes to copy from input buffer\n*\n         BCTR  R15,0                        minus 1 for EXexute\n         LA    R14,XPSSEG(R6)               copy destination\n*\n*** <Perform sanity test here>\n*\n         EX    R15,COPYRES                  copy residual to XPSSEG\n         LA    R15,1(,R15)                  plus 1 for EXecute\n         AR    R6,R15                       new l' residual data\n         AR    R4,R15                       account for copied data\n         SR    R5,R15                       account for copied data\n*\n* If possible, write a full lrecl from residual data\n*\n         ST    R6,XPSRL                     update l' residual data\n         UDIAG 7,'XMITPUT: input added to residual',XPSSEG,(R6)\n         CR    R6,R9                        have full residual rec?\n         BL    EXITRC0                      no, can't PUT data yet\n         BH    BADCODE                      oops, we spaced out\n*\n* Write a lrecl's worth of data from the \"residual\" buffer\n*\n         UDIAG 4,'XMITPUT: write full residual buffer',XPSSEG,(R9)\n         LA    R0,XPSSEG                    record address\n         PUT   XPSDCB,(0)                   write record\n         XC    XPSRL,XPSRL                  no more residual data\n         XC    XPSSEG,XPSSEG                clear residual data\n*----------------------------------------------------------------------\n* Output as much data as possible from input buffer\n*----------------------------------------------------------------------\nPUTINIT  DS    0H\n         LTR   R5,R5                        any data left?\n         BZ    EXITRC0                      no, all done\n         BM    BADCODE                      oops, went negative\n         LA    R10,PUTLOOP                  (term uses \"put\" rtn)\n         UDIAG 6,'XMITPUT: PUT from input buffer'\nPUTLOOP  DS    0H\n         CR    R5,R9                        more recs to output?\n         BL    RESIDUAL                     no, save residual data\n*\n*----------------------------------------------------------------------\n*  Internal routine to PUT data\n*  R4 @ data byte to output, R5 = length, R9 = lrecl, R10 = return\n*----------------------------------------------------------------------\n*\nPUT      DS    0H\n         UDIAG 4,'XMITPUT: PUT segment',(R4),(R9)\n         LR    R0,R4                        record address\n         PUT   XPSDCB,(0)                   write record\n         AR    R4,R9                        bump record ptr\n         SR    R5,R9                        decr length\n         BR    R10\n*----------------------------------------------------------------------\n* Save unwritten input buffer data as residual in XPSSEG\n*----------------------------------------------------------------------\nCOPY     MVC   XPSSEG(*-*),0(R4)            executed\n*\nRESIDUAL DS    0H            less than 80 bytes to output from segment\n         STM   R0,R15,XMTREGS               <debug>\n         UDIAG 7,'XMITPUT: <RESIDUAL> regs',XMTREGS,16*4\n         ST    R5,XPSRL                     save residual length\n         LTR   R5,R5                        anything left?\n         BZ    EXITRC0                      no, leave XPSSEG alone\n         BM    BADCODE                      arggh, negative\n         BCTR  R5,0                         length minus 1 for EX\n         EX    R5,COPY                      copy residual data\n         EJECT ,\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\nEXITRC0  SLR   R15,R15                      set good return code\nEXIT     DS    0H\n         ST    R15,SARC\n         L     R14,XPSRL\n         LTR   R14,R14                      any residual data?\n         BZ    SKIPDSP\n         UDIAG 7,'XMITPUT: residual at exit',XPSSEG,(R14)\nSKIPDSP  DS    0H\n         UDIAG 7,'XMITPUT: XPSWA at exit',XMTXPSWE,L$XPSWA+8\n         UDIAG 1,'XMITPUT exited'\n         L     R15,SARC\n         UPEND ,\n*\nBADCODE  DS    0H\n         STM   R0,R15,XMTREGS\n         USNAP 'XMITPUT: internal error - regs',XMTREGS,16*4\n         USNAP 'XMITPUT: <badcode> xpswa',XMTXPSWE,L$XPSWA+8\n         UABEND DUMP=Y                      buffer handling error\n         EJECT ,\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\nMODLCLOS CLOSE (,),MF=L                model CLOSE\nL$CLOS   EQU   *-MODLCLOS              l' model close\n*\nMODLOPN  OPEN  (,),MF=L                model OPEN\nL$OPN    EQU   *-MODLOPN               l' model open\n*\nMODLDCB  DCB   DDNAME=XMITOUT,                                         +\n               MACRF=PM,DSORG=PS,RECFM=FB,                             +\n               LRECL=80,BLKSIZE=3200         NEED EXLST to fill blksize\nL$DCB    EQU   *-MODLDCB\n*\n         LTORG ,\n         EJECT ,\n*----------------------------------------------------------------------\n*  Savearea/workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSA       DS    18F\nSARC     DS    F\n         DS    0D\nL$SA     EQU   *-SAVEAREA\n         EJECT ,\n         PRINT NOGEN\n         DXMITSEG ,\n*        EJECT ,\n         WAXMT FUNC=XMIT\n*        EJECT ,\n         DCBD  DSORG=PS,DEVD=DA\n         PRINT GEN\nXMITPUT  UFINI DXDXPUT,L$SA\n         END   ,\n./ ADD NAME=XMITUNLD 0100-02182-02182-0702-00210-00210-00000-XMIT370\nXMITUNLD TITLE 'INVOKE IEBCOPY to unload dataset, write segments'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  Things to do:\n*----------------------------------------------------------------------\n         U#SET ,\n*----------------------------------------------------------------------\n* Function: Invoke IEBCOPY to unload the input dataset, read the\n*           IEBCOPY unload data, and write segments containing the\n*           unloaded data.  Supports partitioned datasets for now.\n*\n*           Data is written as follows:\n* XMIT01    INMR01 (always first)\n* XMIT02A   INMR02 IEBCOPY\n* XMIT02B   INMR02 INMCOPY\n* XMIT03    INMR03 (precedes unloaded data)\n* XMITUNLD  <unloaded data>\n* XMIT06    INMR06 (trailer, always last)\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         R0  =\n*         R1  =\n*\n* Exit:   R15 = return code\n*         R15 = 00 success\n*\n* Abends:\n*\n* Notes:\n*----------------------------------------------------------------------\n* R2\n* R3     JFCB\n* R4     length of block read\n* R5\n* R6     length of allocated input buffer\n* R7     IOB\n* R8     input DCB\n* R9     @ input record\n* R10\n* R11    XMTWA\n* R12    base reg\n* R13    savearea\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\nXMITUNLD UPROC L=L$XUNWA,ID=XUNL,WA=XUNWA\n         UDIAG 1,'XMITUNLD entered'\n         SLR   R6,R6                        no buffer allocated\n*----------------------------------------------------------------------\n* Write INMR01 segment\n*----------------------------------------------------------------------\n         UCALL XMIT01,ERR=EXIT\n*----------------------------------------------------------------------\n* Call INMR02A to unload PDS & write INMR02 for DSORG=PO\n*----------------------------------------------------------------------\n         L     R3,XMT@JFCB\n         USING INFMJFCB,R3\n         TM    JFCDSORG,JFCORGPS            physical sequential?\n         BO    NOPDS\n         TM    JFCDSORG,JFCORGPO            partitioned?\n         BNO   BADORG\nPDS      UCALL XMIT02A,ERR=EXIT\n*----------------------------------------------------------------------\n* Call INMR02B to write INMR02 segment for DSORG=PS on SYSUT1/SYSUT2\n*----------------------------------------------------------------------\nNOPDS    DS    0H\n         UCALL XMIT02B,ERR=EXIT\n*----------------------------------------------------------------------\n* Call XMIT03 to write INMR03 segment prior to outputting data segments\n*----------------------------------------------------------------------\n         UCALL XMIT03,ERR=EXIT\n*----------------------------------------------------------------------\n* Set EOF routine and allocate input buffer\n*----------------------------------------------------------------------\nSETEOF   DS    0H\n         L     R3,XMT@JFCB                  refresh xmtdcbi's JFCB ptr\n         LA    R8,XMTDCBI                   @ input DCB\n         USING IHADCB,R8\n         LA    R0,EOFRTN\n         STCM  R0,7,DCBEODA                 set EOF exit rtn addr\n*\n         MVC   XUNDECBI(L$DECB),MODLDECB   copy model DECB\n*\n         LH    R6,DCBBLKSI                 get blksize\n         GETMAIN R,LV=(R6)                 alloc input buffer\n         LR    R9,R1\n*----------------------------------------------------------------------\n* Read block of data from SYSUT1 or SYSUT2\n*----------------------------------------------------------------------\nREAD     DS    0H\n         READ  XUNDECBI,SF,(R8),(R9),'S',MF=E\n         UDIAG 2,'XMITUNLD: read issued'\n*\n         CHECK XUNDECBI\n         L     R7,(DECIOBPT-DECB)+XUNDECBI   @ IOB\n         USING IOBSTDRD,R7\n*\n         UDIAG 5,'XMITUNLD: decb after CHECK',XUNDECBI,L$DECB\n         UDIAG 5,'XMITUNLD: dcb after CHECK',(R8),L$DCB\n         UDIAG 5,'XMITUNLD: IOB after CHECK',(R7),L$IOB\n*\n*  careful, recfm=u = recfm=v + recfm=f\n*\n         TM    DCBRECFM,DCBRECU        RECFM=U, get residual\n         BO    CALCLEN\n         LH    R4,0(R9)                l' RECFM=VB record = BDW\n         TM    DCBRECFM,DCBRECV        guessed wrong?\n         BO    HVLEN\nCALCLEN  DS    0H\n         LH    R4,DCBBLKSI             max l' RECFM=F or U\n         LH    R0,IOBSTBYT+2           residual count\n         SR    R4,R0                   r4 = l' read\nHVLEN    DS    0H\n         UDIAG 3,'XMITUNLD: input record',(R9),(R4)\n*----------------------------------------------------------------------\n* If this is the IEBCOPY COPYR1 record, see if it needs \"fixing\"\n*----------------------------------------------------------------------\nCKCOPYR1 DS    0H\n         TM    XUNFLG1,XUNF1FX         already fixed?\n         BO    WRITE\n         CLC   =X'CA6D0F',9(R9)        COPYR1 id?\n         BNE   WRITE                   nope, skip\nFXCOPYR1 DS    0H\n         LR    R1,R9                   @ COPYR1 block\n         UCALL XMITCPR1                call COPYR1-fixer-upper\n         OI    XUNFLG1,XUNF1FX         show fixed\n*----------------------------------------------------------------------\n* Write data segments from data read\n*----------------------------------------------------------------------\nWRITE    DS    0H\n         LH    R0,0(,R9)               retrieve new buffer length\n         LR    R1,R9                   @ buffer\n*\n*  XMIT doesn't transmit BDW & RDW for unloaded DSORG=PO datasets\n*\n         TM    JFCRECFM,JFCVAR         have to fudge recfm=v\n         BNO   WBUF\n         TM    XMTFLG1,XMTF1$U         for unloaded datasets,\n         BNO   WBUF\n*                                      skip the BDW & RDW\n         S     R0,=F'8'                fudge length\n         LA    R1,8(,R1)               adjust record ptr\n*\nWBUF     DS    0H\n         UCALL XMITBUF            split buffer into segments, write\n         LTR   R15,R15\n         BZ    READ\n         BNZ   EXIT\n*----------------------------------------------------------------------\n* Write INMR06 segment at End Of File\n*----------------------------------------------------------------------\nEOFRTN   DS    0H\n         UCALL XMIT06,ERR=EXIT\n         SLR   R15,R15\n*----------------------------------------------------------------------\n* Return to caller\n*----------------------------------------------------------------------\nEXIT     DS    0H\n         ST    R15,XUNRC\n         LTR   R6,R6\n         BZ    NOFREE\n         LR    R1,R9\n         FREEMAIN R,LV=(0),A=(1)\nNOFREE   DS    0H\n         UDIAG 1,'XMITUNLD exited'\n         L     R15,XUNRC\n         UPEND ,\n*\nBADORG   DS    0H\n         USNAP 'XMITUNLD: JFCB invalid DSORG',(R3),L$JFCB\n         UABEND ,                      invalid input file DSORG\n*\nMODLDECB READ MODLECB,SF,0,0,'S',MF=L\nL$DECB   EQU  *-MODLDECB\n*\n         LTORG ,\n*----------------------------------------------------------------------\nXUNWA    DSECT ,\nXUNSA    DS    18F\nXUNFLG1  DS    X\nXUNF1FX  EQU   128                     COPYR1 fixed\n*\nXUNRC    DS    F                       return code\nXUNDECBI READ  XUNECBI,SF,0,0,'S',MF=L\n         DS    0D\nL$XUNWA  EQU   *-XUNWA\n         EJECT ,\n         PRINT NOGEN\n         WAXMT FUNC=XMIT\n*        EJECT ,\n         DCBD  DSORG=PS,DEVD=DA\nL$DCB    EQU   *-IHADCB\n*\nJFCB     DSECT ,\n         IEFJFCBN LIST=YES\nL$JFCB   EQU   *-JFCB\n*\n*        PRINT ON,GEN\n*        EJECT ,\n         IHADECB ,\n*\n*        EJECT ,\n         IEZIOB ,\nL$IOB    EQU    *-IOB\n         PRINT ON,GEN\nXMITUNLD UFINI DXDXUNLD,L$XUNWA\n         END   ,\n./ ADD NAME=XMITVTAB 0100-02182-02182-0702-00043-00043-00000-XMIT370\nXMITVTAB TITLE 'XMIT370 VCON table'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\nUTILVTAB CSECT ,\n         USING *,0\n         USING XMTWA,11\n*----------------------------------------------------------------------\n*  CSECT table header - BXLE index, increment, limit\n*----------------------------------------------------------------------\nHEADER   DC    A(DBUGTAB,L$VTAB,DBUGEND-1)\n*----------------------------------------------------------------------\n*  CSECT table\n*----------------------------------------------------------------------\nDBUGTAB  DS    0F\n         DC    CL8'XMIT370',V(XMIT370),AL2(XMTD370-XMTDLEV,0)\n         DC    CL8'XMITBUF',V(XMITBUF),AL2(XMTDBUF-XMTDLEV,0)\n         DC    CL8'XMITCPR1',V(XMITCPR1),AL2(XMTDCPR1-XMTDLEV,0)\n         DC    CL8'XMITDIR',V(XMITDIR),AL2(XMTDDIR-XMTDLEV,0)\n         DC    CL8'XMITESZ',V(XMITESZ),AL2(XMTDESZ-XMTDLEV,0)\n         DC    CL8'XMITPUT',V(XMITPUT),AL2(XMTDPUT-XMTDLEV,0)\n         DC    CL8'XMITUNLD',V(XMITUNLD),AL2(XMTDUNLD-XMTDLEV,0)\n         DC    CL8'XMIT01',V(XMIT01),AL2(XMTD01-XMTDLEV,0)\n         DC    CL8'XMIT02A',V(XMIT02A),AL2(XMTD02A-XMTDLEV,0)\n         DC    CL8'XMIT02B',V(XMIT02B),AL2(XMTD02B-XMTDLEV,0)\n         DC    CL8'XMIT03',V(XMIT03),AL2(XMTD03-XMTDLEV,0)\n         DC    CL8'XMIT06',V(XMIT06),AL2(XMTD06-XMTDLEV,0)\n*\n         DC    CL8'UTILABND',V(UTILABND),AL2(XMTDABND-XMTDLEV,0)\n         DC    CL8'UTILDBUG',V(UTILDBUG),AL2(XMTDDBUG-XMTDLEV,0)\n         DC    CL8'UTILHEX',V(UTILHEX),AL2(XMTDHEX-XMTDLEV,0)\n         DC    CL8'UTILLOG',V(UTILLOG),AL2(XMTDLOG-XMTDLEV,0)\n         DC    CL8'UTILPSR',V(UTILPSR),AL2(XMTDPSR-XMTDLEV,0)\n         DC    CL8'UTILSNAP',V(UTILSNAP),AL2(XMTDSNAP-XMTDLEV,0)\n         DC    CL8'UTILTIOT',V(UTILTIOT),AL2(XMTDTIOT-XMTDLEV,0)\nDBUGEND  EQU   *\n*----------------------------------------------------------------------\n*  DSECTs\n*----------------------------------------------------------------------\n         DVTAB ,                       VCON table\n         PRINT NOGEN\n         WAXMT FUNC=UTIL\n         END   ,\n./ ADD NAME=XMIT01   0100-02182-02182-0702-00137-00137-00000-XMIT370\nXMIT01   TITLE 'WRITE INMR01 segment'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  Things to do:\n*----------------------------------------------------------------------\n         U#SET ,\n*----------------------------------------------------------------------\n* Function: Collect the information for, and write the INMR01 segment.\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         R0  =\n*         R1  =\n*\n* Exit:   R15 = return code\n*         R15 = 00 success\n*\n* Abends:\n*\n* Notes:\n*----------------------------------------------------------------------\n* R2\n* R3\n* R4     @ segment data\n* R5     length remaining in segment data\n* R6\n* R7\n* R8\n* R9\n* R10\n* R11    XMTWA\n* R12    base reg\n* R13    savearea\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\nXMIT01   UPROC L=L$X01WA,ID=XM01,WA=X01WA\n         UDIAG 1,'XMIT01 entered'\n*----------------------------------------------------------------------\n* Create INMR01 segment's key data\n*----------------------------------------------------------------------\n         MVI   X01SEGL,L$X01SGL                  segment length\n         MVI   X01SEGF,SEG$1+SEG$L+SEG$C         segment flag\n         MVC   X01ID,=C'INMR01'\n         MVC   X01KEY(L$MR01),MR01     copy bogus key data\n*\n* Update some of the bogus key data with correct values\n*\n*\n*----------------------------------------------------------------------\n* Write INMR01 segment\n*----------------------------------------------------------------------\nWRITE    DS    0H\n         LA    R1,X01MR01\n         UCALL XMITPUT                      write INMR01 segment\nEXIT     DS    0H\n         UDIAG 1,'XMIT01 exited'\n         SLR   R15,R15                      good return code\n         UPEND  ,\n*\n         LTORG ,\n*\n*\n*     c9d5d4d9 f0f1                               *INMR01   *\n*     0042 0001 0001 50\n*     1011 0001 0008 d5d6c4c5d5c1d4c5             *NODENAME *\n*     1012 0001 0006 e2e2c4d1d4d4                 *SSDJMM   *\n*     1001 0001 0004 d5d6c4c5                     *NODE     *\n*     1002 0001 0006 e4e2c5d9c9c4                 *USERID   *\n*     1024 0001 000e f2f0f0f0f0f3f2f2f0f2f1f5f3f2 *20000322021532*\n*     102f 0001 0001 01\n*\nMR01     DS    0X\nKLRECL   DC    AL2(INMLRECL,1,L'VLRECL)    0042 physical lrecl\nVLRECL   DC    FL1'80'                     of control segments\n*\nKFNODE   DC    AL2(INMFNODE,1,L'VFNODE)    1011 origin node\nVFNODE   DC    C'ORIGNODE'\n*\nKFUID    DC    AL2(INMFUID,1,L'VFUID)      1012 origin userid\nVFUID    DC    C'ORIGUID'\n*\nKTNODE   DC    AL2(INMTNODE,1,L'VTNODE)    1001 dest node\nVTNODE   DC    C'DESTNODE'\n*\nKTUID    DC    AL2(INMTUID,1,L'VTUID)      1002 dest userid\nVTUID    DC    C'DESTUID'\n*\nKFTIME   DC    AL2(INMFTIME,1,L'VFTIME)    1024 origin time stamp\nVFTIME   DC    C'20010203124500'\n*                yyyymmddhhmmss\n*\nKNUMF    DC    AL2(INMNUMF,1,L'VNUMF)      102F # files\nVNUMF    DC    X'01'\nL$MR01   EQU   *-MR01                      actual segment length\n*\n* optional keys not provided: INMFACK, INMFVERS, INMNUMF, INMUSERP\n*\n*----------------------------------------------------------------------\n*\nX01WA    DSECT ,\nX01SA    DS    18F\n*\nX01MR01  DS    0D            INMR01 segment\nX01SEGL  DS    X             segment length\nX01SEGF  DS    X             segment flag\nX01SEGD  DS    XL253         beginning of segment data\n         ORG   X01SEGD\nX01ID    DS    C'INMR01'\nX01KEY   DS    0X            beginning of key data\n         DC    AL2(INMLRECL,1,L'VLRECL)    0042 physical lrecl\nX01LRECL DC    FL1'80'                     of control segments\n         DC    AL2(INMFNODE,1,L'VFNODE)    1011 origin node\nX01FNODE DC    C'ORIGNODE'\n         DC    AL2(INMFUID,1,L'VFUID)      1012 origin userid\nX01FUID  DC    C'ORIGUID'\n         DC    AL2(INMTNODE,1,L'VTNODE)    1001 dest node\nX01TNODE DC    C'DESTNODE'\n         DC    AL2(INMTUID,1,L'VTUID)      1002 dest userid\nX01TUID  DC    C'DESTUID'\n         DC    AL2(INMFTIME,1,L'VFTIME)    1024 origin time stamp\nX01FTIME DC    C'20010203124500'\n         DC    AL2(INMNUMF,1,L'VNUMF)      102F # files\nX01NUMF  DC    X'01'\nL$X01SGL EQU   *-X01MR01                   actual segment length\n         ORG   ,\n         DS    0D\nL$X01WA  EQU   *-X01WA\n         EJECT ,\n         PRINT NOGEN\n         DXMITSEG ,\n*        EJECT ,\n         WAXMT FUNC=XMIT\nXMIT01   UFINI DXDX01,L$X01WA        pseudo-register\n         END   ,\n./ ADD NAME=XMIT02A  0100-02182-02182-0702-00493-00493-00000-XMIT370\nXMIT02A  TITLE 'WRITE INMR02 IEBCOPY segment'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  Things to do:\n*----------------------------------------------------------------------\n         U#SET ,\n*----------------------------------------------------------------------\n* Function: Collect the information for, and write the INMR02 segment.\n*           for DSORG=PO datasets (INMR02 IEBCOPY segment);\n*           call IEBCOPY to unload the input dataset\n*\n* Entry:  S/370 ECMODE KEY=8, STATE=PROB, AUTHORIZED\n*\n*         R0  =\n*         R1  =\n*\n* Exit:   R15 = return code\n*         R15 = 00 success\n*\n* Abends:\n*\n* Notes: XMITUNLD only calls us for DSORG=PO datasets\n*        XMIT370 has already read in the JFCB for the input dataset.\n*        We probably have to close SYSUT1 before calling IEBCOPY to\n*        unload the input dataset.\n*\n*        We also read SYSUT1's Format-1 DSCB, for XMITCPR1.\n*----------------------------------------------------------------------\n* R2     DCB\n* R3     JFCB\n* R4     @ segment data\n* R5     length remaining in segment data\n* R6     makdsnam ptr to count portion of new qualifier\n* R7     makdsnam ptr to free slot in segment\n* R8     makdsnam dsn char ptr\n* R9     makdsnam # chars left in dsn to examine\n* R10    makdsnam # chars in qualifier\n* R11    XMTWA\n* R12    base reg\n* R13    savearea\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\nXMIT02A  UPROC L=L$X02AWA,ID=X02A,WA=X02AWA\n         UDIAG 1,'XMIT02A entered'\n*----------------------------------------------------------------------\n* Create INMR02 segment's key data\n*----------------------------------------------------------------------\n         MVI   X02SEGL,L$X02SGL                        segment length\n         MVI   X02SEGF,SEG$1+SEG$L+SEG$C               segment flags\n         MVC   X02ID,=C'INMR02'\n         MVC   X02NUM,=AL4(1)          applies to file number 1\n         MVC   X02KEY(L$MR02),MR02     copy bogus key data\n*\n* Update bogus data with correct information\n*\n         LA    R3,XMTJFCB1           @ SYSUT1 JFCB\n         USING JFCB,R3\n         MVC   XDSORG,JFCDSORG       dsorg\n         MVC   XLRECL+2(2),JFCLRECL  lrecl\n*\n*  Note LRECL is only a two byte field, but the version of TRANSMIT I\n*  used to create some sample data created LRECL as a four byte field.\n*  Similarly, RECFM and BLKSIZE are transmitted in larger fields, too.\n*\n         MVC   XRECFM(1),JFCRECFM    recfm\n         MVC   XBLKSZ+2(2),JFCBLKSI  block size\n*----------------------------------------------------------------------\n* Estimate the size (in bytes) of the input dataset\n*----------------------------------------------------------------------\n         LA    R1,XMTDCBI            @ open SYSUT1 DCB\n         UCALL XMITESZ,ERR=EXIT\n         STCM  R0,15,XSIZE           approximate # bytes allocated\n*----------------------------------------------------------------------\n* Determine how many directory blocks the PDS has allocated\n*----------------------------------------------------------------------\n         LA    R1,XMTDCBI            @ open SYSUT1 DCB\n         UCALL XMITDIR,ERR=EXIT\n         STCM  R0,7,XDIR             directory blocks allocated\n*----------------------------------------------------------------------\n* Finish off the INMR02 segment\n*----------------------------------------------------------------------\n* by filling in the INMDSNAM key which contains the input (SYSUT1)\n* dataset name split up by qualifiers.\n* For example, the dataset SES.LINK is represented as:\n*        0002                                     INMDSNAM key\n*             0002                                # count/data pairs\n*                  0003 e2c5e2          *SES*     count/data pair #1\n*                  0004 d3c9d5d2        *LINK*    count/data pair #2\n*\n         UDIAG 4,'XMIT02A makdsnam call'\n         BAL   R14,MAKDSNAM                 fill it in\n         UDIAG 4,'XMIT02A makdsnam complete'\n*----------------------------------------------------------------------\n* Write INMR02 segment\n*----------------------------------------------------------------------\nWRITE    DS    0H\n         LA    R1,X02MR02\n         UCALL XMITPUT,ERR=EXIT             write INMR02 segment\n*----------------------------------------------------------------------\n*  OBTAIN SYSUT1 Format 1 DSCB\n*----------------------------------------------------------------------\n         UDIAG 2,'XMIT02A obtain init'\n         MVC   X02CAML(L$CAMLST),CAMLST     copy CAMSLT\n         LA    R0,JFCBDSNM                 SYSUT1 JFCB's dsn\n         ST    R0,X02CAML+04               dsn\n*\n         LA    R0,JFCBVOLS\n         ST    R0,X02CAML+08               volser\n*\n         LA    R0,XMTDSCB1                 SYSUT1 DSCB area\n         ST    R0,X02CAML+12               @ dscb buffer\n*\n         OBTAIN X02CAML\n*\n         ST    R15,X02RC                   save return code\n         MVC   XMTDSCB(44),JFCBDSNM        copy dsn\n         UDIAG 3,'XMIT02A SYSUT1 DSCB',XMTDSCB,44+140\n         L     R15,X02RC\n         LTR   R15,R15                     OBTAIN good?\n         BZ    OBTAINOK\n         UPSR  0,'XMIT02A SYSUT1 OBTAIN rc',(R15)\n         UABEND ,\nOBTAINOK DS    0H\n         UDIAG 2,'XMIT02A obtain fini'\n         EJECT ,\n*----------------------------------------------------------------------\n* Close the SYSUT1 input dataset\n*----------------------------------------------------------------------\nCLOSE    DS    0H\n         MVC   XMTCLOS(L$CLOS),MODLCLOS     copy model CLOSE macro\n         CLOSE XMTDCBI,MF=(E,XMTCLOS)\n         UDIAG 2,'XMIT02A: closed SYSUT1'\n*----------------------------------------------------------------------\n* Call IEBCOPY to unload the PDS\n*----------------------------------------------------------------------\nIEBCOPY  DS    0H\n*\n*  Load IEBCOPY\n*\n         LA    R0,=CL8'IEBCOPY'\n         LOAD  EPLOC=(0)\n         LTR   R15,R15\n         BZ    GOCOPY\n         ST    R15,X02RC\n         UDIAG 0,'XMIT02A: IEBCOPY load failed'\n         L     R0,X02RC\n         UPSR  0,'XMIT02A load rc',(R0)\n         B     EXIT\n*\n*  Call IEBCOPY\n*\nGOCOPY   DS    0H\n         LR    R15,R0              GET ENTRY ADDRESS\n         LA    R15,0(,R15)         CLEAR HI BYTE FOR DELETE ROUTINE\n         LR    R9,R15              SAVE\n         LA    R1,X02PRMOS         IEBCOPY parm: OS parm string\n         ST    R1,X02PRM1\n         OI    X02PRM1,X'80'       end of VL parmlist\n         LA    R1,X02PRM1\n         BALR  R14,R15             call IEBCOPY\n         ST    R15,X02RC\n         UPSR  2,'XMIT02A IEBCOPY rc %',(R15)\n         L     R15,X02RC\n         LTR   R15,R15\n         BNZ   EXIT\n*\n*  Delete IEBCOPY\n*\nDELCOPY  DS    0H\n         UDIAG 2,'XMIT02A: IEBCOPY unload successful'\n         LA    R0,=CL8'IEBCOPY'\n         DELETE EPLOC=(0)          delete IEBCOPY program\n         UPSR  2,'XMIT02A delete rc %',(R15)\n*----------------------------------------------------------------------\n* Open the IEBCOPY output dataset as our input, retrieve JFCB\n* so that XMIT02B (where we're headed next) can fill in it's data\n*----------------------------------------------------------------------\nOPEN     DS    0H\n         MVC   XMTOPN(L$OPN),MODLOPN     copy model OPEN macro\n         MVC   XMTDCBI(L$DCBI),MODLDCBI  copy model DCB\n         OPEN  XMTDCBI,MF=(E,XMTOPN)\n         LA    R2,XMTDCBI\n         USING IHADCB,R2\n         MVC   XMTJFCBL(L$JFCBL),JFCBLST    copy open exit list\n         LA    R0,XMTJFCB2                  relocate JFCB addr\n         STCM  R0,7,XMTJFCBL+1\n         LA    R0,XMTJFCBL                  relocate DCB's EXLST\n         STCM  R0,7,(DCBEXLSA-IHADCB)+XMTDCBI\n         OPEN  XMTDCBI,MF=(E,XMTOPN)\n         TM    DCBOFLG1,DCBOFOPN            opened?\n         BO    DCBIOPEN\n         UDIAG 0,'XMIT02A: SYSUT2 DCB failed to open'\n         UABEND ,                           input DCB didn't open\nDCBIOPEN DS    0H\n         UDIAG 3,'XMIT02A: SYSUT2 DCB open',(R2),L$DCB\n         RDJFCB XMTDCBI,MF=(E,XMTOPN)       SYSUT2 JFCB\n         LTR   R15,R15\n         BZ    SNAPJFCB\n         ST    R15,X02RC\n         UDIAG 0,'XMIT02A: RDJFCB failed'\n         L     R0,X02RC\n         UPSR  2,'XMIT02A RDJFCB rc %',(R0)\n         UABEND ,\nSNAPJFCB DS    0H\n         UDIAG 3,'XMIT02A: SYSUT2 JFCB',XMTJFCB2,L$JFCB\n         LA    R0,XMTJFCB2\n         ST    R0,XMT@JFCB             SYSUT2 JFCB ptr\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\nEXIT     DS    0H\n         OI    XMTFLG1,XMTF1$U         xmtdcbi now unloaded dataset\n         UDIAG 1,'XMIT02A exited'\n         L     R15,X02RC\n         UPEND  ,\n         EJECT ,\n*----------------------------------------------------------------------\n*  MAKDSNAM subroutine - fill in INMDSNAM key\n*----------------------------------------------------------------------\n* R2\n* R3\n* R4     @ segment data\n* R5     length remaining in segment data\n* R6     makdsnam ptr to count portion of new qualifier\n* R7     makdsnam ptr to free slot in segment\n* R8     makdsnam dsn char ptr\n* R9     makdsnam # chars left in dsn to examine\n* R10    makdsnam # chars in qualifier\n* R11    XMTWA\n* R12    base reg\n* R13    savearea\n*----------------------------------------------------------------------\nMAKDSNAM DS    0H\n         STM   R0,R15,X02SAV2          save caller's regs\n*\n* maximum possible space consumed by dataset name:\n* 123456789/123456789/123456789/123456789/1234\n* A.B.C.D.E.F.G.H.I.J.K.L.M.N.O.P.Q.R.S.T.U.VW\n* stored as:\n* 0002         INDSNAM key\n* 0016         22 qualifiers\n* 0001 C1 0001 C2 0001 C3 0001 C4 0001 C5 0001 C6 0001 C7 0001 C8\n* 0001 C9 0001 D1 0001 D2 0001 D3 0001 D4 0001 D5 0001 D6 0001 D7\n* 0001 D8 0001 D9 0001 E2 0001 E3 0001 E4 0002 E5E6\n* consumes 71 bytes.  We have way more than that left in the INMR02\n* segment, so we don't even worry about the space, just getting\n* the new INMDSNAM segment right.\n*\n* We only have to count the count/data pairs, drop them in the\n* segment being created, and update the segment's length.\n*\n         SLR   R15,R15\n         IC    R15,X02SEGL\n         UDIAG 4,'XMIT02A makdsnam entry segment',X02SEGL,(R15)\n*\n         LA    R6,X02DSNAM             1st count slot\n         LA    R7,2(,R6)               data space in segment\n         LA    R8,JFCBDSNM+L'JFCBDSNM-1     @ dsn last char\n         LA    R9,L'JFCBDSNM           max possible dsn length\n         UDIAG 4,'XMIT02A JFCB dsname',JFCBDSNM,44\n*\n*  Determine length of input dataset name\n*\nGETLEN   DS    0H                      calc # chars in dsn\n         CLI   0(R8),C' '              trailing space?\n         BNE   HAVLEN\n         BCTR  R8,0                    r8 back one character\n         BCT   R9,GETLEN               minus trailing space\nHAVLEN   DS    0H                      r9 = # chars in dsn\n         LTR   R9,R9                   better be something left\n         BP    LENOK\n         UDIAG 0,'XMIT02A input dsn parse error'\n         UABEND ,                      can't parse dsn\nLENOK    DS    0H\n         UPSR  4,'XMIT02A dsn length %',(R9)\n*\n*  Handle a qualifier at a time\n*\n         LA    R8,JFCBDSNM             @ dsn's first char\n*\n         STM   R0,R15,XMTREGS          debug aid\n         UDIAG 5,'XMIT02A newqual init regs',XMTREGS,16*4\n*\nNEWQUAL  DS    0H\n         SLR   R10,R10                 # chars in qualifier\n         STM   R0,R15,XMTREGS          debug aid\n         UDIAG 5,'XMIT02A newqual regs',XMTREGS,16*4\n*\n*  Scan qualifier for end\n*\nNXTCHAR  DS    0H                      parse the qualifier\n         CLI   0(R8),C'.'              found period?\n         BE    TERMQUAL                yes, end of qualifier\n         MVC   0(1,R7),0(R8)           copy qualifier char\n         LA    R7,1(,R7)               next segment char slot\n         LA    R8,1(,R8)               next dsn char\n         LA    R10,1(,R10)             account for char moved\n         BCT   R9,NXTCHAR              one less dsn char\n*\n*  Falling through means last qualifer (no '.')\n*\n         STM   R0,R15,XMTREGS          debug aid\n         UDIAG 4,'XMIT02A nxtchar fallthru = last',XMTREGS,16*4\n*\n*  Found end of qualifier\n*\nTERMQUAL DS    0H\n         UDIAG 4,'XMIT02A termqual loop'\n         STCM  R10,3,0(R6)             set # chars in qual\n*\n         SLR   R14,R14                 clean x02quals reg\n         ICM   R14,3,X02QUALS          old # qualifiers\n         LA    R14,1(,R14)             one more\n         STCM  R14,3,X02QUALS          update\n*\n         SLR   R15,R15                 clean x02segl reg\n         IC    R15,X02SEGL             old segment length\n         LA    R15,2(R10,R15)          new segment length\n         STC   R15,X02SEGL             update\n*\n         LR    R6,R7                   next count slot\n         LA    R7,2(,R7)               next data slot\n         LA    R8,1(,R8)               skip period\n*\n         STM   R0,R15,XMTREGS          debug aid\n         UDIAG 5,'XMIT02A next qual regs',XMTREGS,16*4\n         SLR   R15,R15\n         IC    R15,X02SEGL\n         UDIAG 4,'XMIT02A segment updated with count',X02SEGL,(R15)\n*\n         LTR   R9,R9                   all done?\n         BNP   MADEDSNM\n         BCT   R9,NEWQUAL              account for period,\n*                                      do another qualifier\n*\n*  Finished updating segment with dsn, return\n*\nMADEDSNM DS    0H\n         STM   R0,R15,XMTREGS          debug aid\n         UDIAG 4,'XMIT02A makdsnam about to return'\n         UDIAG 5,'XMIT02A makdsnam exit regs',XMTREGS,16*4\n*\n         LM    R0,R15,X02SAV2          restore caller's regs\n         BR    R14                     return to caller\n         EJECT ,\n*\nMODLOPN  OPEN  (,INPUT),MF=L           model OPEN\nL$OPN    EQU   *-MODLOPN               l' model open\n*\nMODLCLOS CLOSE (,),MF=L                model CLOSE\nL$CLOS   EQU   *-MODLCLOS              l' model close\n*\nJFCBLST  DS    0F\n         DC    XL1'87'\n         DC    AL3(0)\nL$JFCBL  EQU   *-JFCBLST\n*\nCAMLST   CAMLST SEARCH,1,2,3\n*\n*\n* IEBCOPY's output is now our input\n* DSORG=PS - maybe yes, maybe no\n* XMITUNLD uses BSAM READ/CHECK\n*\nMODLDCBI DCB   DDNAME=SYSUT2,DSORG=PS,EXLST=JFCBLST,MACRF=R\nL$DCBI   EQU   *-MODLDCBI\n*\n         LTORG ,\n         EJECT ,\n*\n*\n*        c9d5d4d9f0f2                   *INMR02*\n*        00000001\n*        1028 0001 0007 c9c5c2c3d6d7e8  *IEBCOPY*\n*        102c 0001 0004 0000bb60\n*        003c 0001 0002 0200\n*        8012 0001 0001 00\n*        0042 0001 0004 00000050\n*        0030 0001 0004 00005b90\n*        0049 0001 0002 9000\n*        000c 0001 0003 000006\n*        0002 0002 0003 e2c5e2          *SES*\n*                  0004 d3c9d5d2        *LINK*\n*\nMR02     DS    0D\n         DC    AL2(INMUTILN,1,L'VUTILN)     1028 utility name\nVUTILN   DC    C'IEBCOPY'\n*\n         DC    AL2(INMSIZE,1,L'VSIZE)       102c approx file size\nVSIZE    DC    XL4'BB60'\n*\n         DC    AL2(INMDSORG,1,L'VDSORG)     003C dsorg\nVDSORG   DC    XL2'0200'\n*\n         DC    AL2(INMTYPE,1,L'VTYPE)       8012 optional dataset type\nVTYPE    DC    X'00'\n*\n         DC    AL2(INMLRECL,1,L'VLRECL)     0042 lrecl\nVLRECL   DC    AL4(80)\n*\n         DC    AL2(INMBLKSZ,1,L'VBLKSZ)     0030 optional blocksize\nVBLKSZ   DC    AL4(23440)\n*\n         DC    AL2(INMRECFM,1,L'VRECFM)     0049 recfm + pad\nVRECFM   DC    X'9000'\n*\n         DC    AL2(INMDIR,1,L'VDIR)         000C dir blocks\nVDIR     DC    XL3'000006'\n*\nVDSN     DC    AL2(INMDSNAM)                0002 optional dsname\n         DC    AL2(0)                       # dsn qualifiers\nL$MR02   EQU   *-MR02\n*----------------------------------------------------------------------\n*  Immediately following the # of dsn qualifiers field is the\n*  Dataset count/data pairs set in makdsnam subroutine, not prototyped\n*----------------------------------------------------------------------\n*\n* optional keys not provided: <figure out later>\n*\n*----------------------------------------------------------------------\n         EJECT ,\nX02AWA   DSECT ,\nX02SA    DS    18F           savearea for anyone we call\nX02CAML  CAMLST SEARCH,1,2,3\nL$CAMLST EQU   *-X02CAML\nX02SAV2  DS    16F           savearea for makdsnam subroutine\n*\nX02RC    DS    F             most recent return code\n*\nX02PRM1  DS    A             IEBCOPY OS-parm ptr\nX02PRMOS DS    H,CL100       IEBCOPY OS-parm\n*\nX02MR02  DS    0D            INMR02 segment\nX02SEGL  DS    X             segment length\nX02SEGF  DS    X             segment flag\nX02SEGD  DS    XL253         beginning of segment data\n         ORG   X02SEGD\nX02ID    DS    C'INMR02'\nX02NUM   DS    XL4           files # (relative 1)\nX02KEY   DS    0X            beginning of key data\n         DC    AL2(INMUTILN,1,L'VUTILN)     1028 utility name\nXUTILN   DC    C'IEBCOPY'\n         DC    AL2(INMSIZE,1,L'VSIZE)       102c approx file size\nXSIZE    DC    XL4'BB60'\n         DC    AL2(INMDSORG,1,L'VDSORG)     003C dsorg\nXDSORG   DC    XL2'0200'\n         DC    AL2(INMTYPE,1,L'VTYPE)       8012 optional dataset type\nXTYPE    DC    X'00'\n         DC    AL2(INMLRECL,1,L'VLRECL)     0042 lrecl\nXLRECL   DC    AL4(80)\n         DC    AL2(INMBLKSZ,1,L'VBLKSZ)     0030 optional blocksize\nXBLKSZ   DC    AL4(23440)\n         DC    AL2(INMRECFM,1,L'VRECFM)     0049 recfm\nXRECFM   DC    X'9000'\n         DC    AL2(INMDIR,1,L'VDIR)         000C dir blocks\nXDIR     DC    XL3'000006'\n         DC    AL2(INMDSNAM)                0002 optional dsname\nX02QUALS DC    AL2(0)                       # qualifiers\nX02DSNAM EQU   *                            count/data pairs built here\nL$X02SGL EQU   *-X02MR02                    actual segment length\n         DS    CL67                         max count/data pair size\n         ORG   ,\n         DS    0D\nL$X02AWA EQU   *-X02AWA\n*\n         EJECT ,\n         PUSH  PRINT\n         PRINT NOGEN\n         DXMITSEG ,\n*\n*        EJECT ,\n*\n         WAXMT FUNC=XMIT\n*\n*        EJECT ,\n*\n         DCBD   DSORG=PS,DEVD=DA\nL$DCB    EQU   *-IHADCB\n*\nJFCB     DSECT ,\n         IEFJFCBN ,\nL$JFCB   EQU   *-JFCB\n*\nDSCB1    DSECT ,\n         IECSDSL1 (1)                  FORMAT-1 DSCB\nL$DSCB1  EQU   *-DSCB1\n*\n         POP   PRINT\nXMIT02A  UFINI DXDX02A,L$X02AWA           pseudo-register\n         END   ,\n./ ADD NAME=XMIT02B  0100-02182-02182-0702-00209-00209-00000-XMIT370\nXMIT02B  TITLE 'WRITE INMR02 INMCOPY segment'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  Things to do:\n*----------------------------------------------------------------------\n         U#SET ,\n*----------------------------------------------------------------------\n* Function: Collect the information for, and write the INMR02 segment.\n*           for DSORG=PO or DSORG=PS datasets (INMR02 INMCOPY segment).\n*\n* Entry:  S/370 ECMODE KEY=8 STATE=PROB\n*\n*         R0  =\n*         R1  =\n*\n* Exit:   R15 = return code\n*         R15 = 00 success\n*\n* Abends:\n*\n* Notes: XMITUNLD calls us for either DSORG=PO or DSORG=PS datasets.\n*        For DSORG=PO, XMIT02A has already unloaded the PDS using\n*        IEBCOPY, closed the PDS's DCB, and opened the DCB for\n*        IEBCOPY's unloaded dataset (as well as gotten the JFCB).\n*\n*        For DSORG=PS, XMIT370 has opened the input dataset, and\n*        gotten the JFCB.  XMIT370 has the wrong DCB attributes for\n*        a DSORG=PS dataset, since it assumes the SYSUT1 dataset will\n*        be a PDS.  For DSORG=PS, we have to reopen the DCB with the\n*        correct values.\n*----------------------------------------------------------------------\n* R2     DCB\n* R3     JFCB\n* R4\n* R5\n* R6\n* R7\n* R8\n* R9\n* R10\n* R11    XMTWA\n* R12    base reg\n* R13    savearea\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\nXMIT02B  UPROC L=L$X02BWA,ID=X02B,WA=X02BWA\n         UDIAG 1,'XMIT02B entered'\n*----------------------------------------------------------------------\n* Create INMR02 segment's key data\n*----------------------------------------------------------------------\n         MVI   X02SEGL,L$X02SGL                        segment length\n         MVI   X02SEGF,SEG$1+SEG$L+SEG$C               segment flags\n         MVC   X02ID,=C'INMR02'\n         MVC   X02NUM,=AL4(1)          applies to file number 1\n         MVC   X02KEY(L$MR02),MR02     copy bogus key data\n*\n* Update bogus data with (some) correct information\n*\n         L    R3,XMT@JFCB            SYSUT1/SYSUT2 JFCB\n         USING JFCB,R3\n         MVC   XDSORG,JFCDSORG       dsorg\n         MVC   XLRECL+2(2),JFCLRECL  lrecl\n         MVC   XRECFM(1),JFCRECFM    recfm\n         MVC   XBLKSZ+2(2),JFCBLKSI  block size\n*----------------------------------------------------------------------\n* Write INMR02 segment\n*----------------------------------------------------------------------\nWRITE    DS    0H\n         LA    R1,X02MR02\n*        L     R2,XMT@PS\n         UCALL XMITPUT                 write INMR02 segment\n*----------------------------------------------------------------------\n* Determine whether the XMTDCBI DCB correctly reflects the SYSUT1\n* dataset's attributes when DSORG=PS.  XMIT02A took care of the\n* DCB for DSORG=PO.\n*----------------------------------------------------------------------\n         LA    R3,XMTJFCB1             SYSUT1 JFCB\n         TM    JFCDSRG1,JFCORGPS       DSORG=PS?\n         BNO   EXIT                    no, xmit02a already fixed DCB\n*----------------------------------------------------------------------\n* Close the SYSUT1 input dataset\n*----------------------------------------------------------------------\nCLOSE    DS    0H\n         UDIAG 2,'XMIT02B: closing DSORG=PS SYSUT1'\n         MVC   XMTCLOS(L$CLOS),MODLCLOS     copy model CLOSE macro\n         CLOSE XMTDCBI,MF=(E,XMTCLOS)\n*----------------------------------------------------------------------\n* Re-open SYSUT1 with correct DCB attributes\n* We don't need to re-read the JFCB, since it hasn't changed since\n* XMIT370 read it.\n*----------------------------------------------------------------------\n         LA    R2,XMTDCBI\n         USING IHADCB,R2\n         MVC   XMTOPN(L$OPN),MODLOPN     copy model OPEN macro\n         MVC   XMTDCBI(L$DCBI),MODLDCBI  copy model DCB\n         MVC   DCBRECFM,JFCRECFM         copy recfm from JFCB\n         MVC   DCBLRECL,JFCLRECL         copy lrecl from JFCB\n         MVC   DCBBLKSI,JFCBLKSI         copy blksize from JFCB\n         UDIAG 3,'XMIT02B: SYSUT1 DCB',(R2),L$DCB\n         OPEN  ((R2)),MF=(E,XMTOPN)\n         TM    DCBOFLG1,DCBOFOPN            opened?\n         BO    DCBIOPEN\n         UDIAG 0,'XMIT02B: SYSUT1 DCB failed to open'\n         UABEND ,                           input DCB didn't open\nDCBIOPEN DS    0H\n         UDIAG 3,'XMIT02B: SYSUT1 DCB open',(R2),L$DCB\n*----------------------------------------------------------------------\n* Return to caller with return code set\n*----------------------------------------------------------------------\nEXIT     DS    0H\n         UDIAG 1,'XMIT02B exited'\n         L     R15,X02RC\n         UPEND ,\n*\n*\n*       c9d5d4d9f0f2                          *INMR02          *\n*       00000001\n*       1028 0001 0007 c9d5d4c3d6d7e8         *INMCOPY         *\n*       102c 0001 0004 0000bb60\n*       003c 0001 0002 4000\n*       0042 0001 0004 00007ff4\n*       0030 0001 0004 00000c30\n*       0049 0001 0002 4802\n*\nMR02     DS    0X\n         DC    AL2(INMUTILN,1,L'VUTILN)     1028 utility name\nVUTILN   DC    C'INMCOPY'\n*\n         DC    AL2(INMSIZE,1,L'VSIZE)       102C approx file size\nVSIZE    DC    XL4'BB60'\n*\n         DC    AL2(INMDSORG,1,L'VDSORG)     003C dsorg\nVDSORG   DC    XL2'4000'\n*\n         DC    AL2(INMLRECL,1,L'VLRECL)     0042 lrecl\nVLRECL   DC    XL4'C30'\n*\n         DC    AL2(INMBLKSZ,1,L'VBLKSZ)     0030 optional blocksize\nVBLKSZ   DC    AL4(23440)\n*\n         DC    AL2(INMRECFM,1,L'VRECFM)     0049 recfm\nVRECFM   DC    X'4800'\nL$MR02   EQU   *-MR02\n*\n* optional keys not provided: <figure out later>\n*\nMODLDCBI DCB   DDNAME=SYSUT1,                                          +\n               DSORG=PS,               DEFINITELY                      +\n               LRECL=0,BLKSIZE=0,      FILLED in dynamically           +\n               RECFM=F,                MAYBE, maybe not                +\n               MACRF=R\nL$DCBI   EQU   *-MODLDCBI\n*\nMODLOPN  OPEN  (,INPUT),MF=L           model OPEN\nL$OPN    EQU   *-MODLOPN               l' model open\n*\nMODLCLOS CLOSE (,),MF=L                model CLOSE\nL$CLOS   EQU   *-MODLCLOS              l' model close\n*\n         LTORG ,\n*----------------------------------------------------------------------\n         EJECT ,\nX02BWA   DSECT ,\nX02SA    DS    18F\n*\nX02RC    DS    F             return code\nX02MR02  DS    0D            INMR02 segment\nX02SEGL  DS    X             segment length\nX02SEGF  DS    X             segment flag\nX02SEGD  DS    XL253         beginning of segment data\n         ORG   X02SEGD\nX02ID    DS    C'INMR02'\nX02NUM   DS    XL4           files # (relative 1)\nX02KEY   DS    0X            beginning of key data\n         DC    AL2(INMUTILN,1,L'VUTILN)     1028 utility name\nXUTILN   DC    C'INMCOPY'\n         DC    AL2(INMSIZE,1,L'VSIZE)       102C approx file size\nXSIZE    DC    XL4'BB60'\n         DC    AL2(INMDSORG,1,L'VDSORG)     003C dsorg\nXDSORG   DC    XL2'4000'\n         DC    AL2(INMLRECL,1,L'VLRECL)     0042 lrecl\nXLRECL   DC    XL4'C30'\n         DC    AL2(INMBLKSZ,1,L'VBLKSZ)     0030 optional blocksize\nXBLKSZ   DC    AL4(23440)\n         DC    AL2(INMRECFM,1,L'VRECFM)     0049 recfm\nXRECFM   DC    X'4800'\nL$X02SGL EQU   *-X02MR02                    actual segment length\n         ORG   ,\n         DS    0D\nL$X02BWA EQU   *-X02BWA\n         EJECT ,\n         PRINT NOGEN\n         DXMITSEG ,\n*        EJECT ,\n         WAXMT FUNC=XMIT\n*        EJECT ,\n         DCBD  DSORG=PS,DEVD=DA\nL$DCB    EQU   *-IHADCB\n*\nJFCB     DSECT ,\n         IEFJFCBN ,\nL$JFCB   EQU   *-JFCB\n*\n         PRINT GEN\nXMIT02B  UFINI DXDX02B,L$X02BWA\n         END   ,\n./ ADD NAME=XMIT03   0100-02182-02182-0702-00161-00161-00000-XMIT370\nXMIT03   TITLE 'WRITE INMR03 segment'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  Things to do:\n*----------------------------------------------------------------------\n         U#SET ,\n*----------------------------------------------------------------------\n* Function: Collect the information for, and write the INMR03 segment.\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         R0  =\n*         R1  =\n*\n* Exit:   R15 = return code\n*         R15 = 00 success\n*\n* Abends:\n*\n* Notes:  Very little of the INMR03 is \"correct\", but instead\n*         reflects values seen in typical XMI datasets.\n*----------------------------------------------------------------------\n* R2     scratch\n* R3     DVCT\n* R4     UCB associated with extent\n* R5     # extents\n* R6     DCB\n* R7     DEB, DEBDASD\n* R8     estimated file size in bytes\n* R9     JFCB for input file\n* R10\n* R11    XMTWA\n* R12    base reg\n* R13    savearea\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\nXMIT03   UPROC L=L$X03WA,ID=XM03,WA=X03WA\n         UDIAG 1,'XMIT03 entered'\n         LA    R9,XMTJFCB1             @ SYSUT1's JFCB\n         USING JFCB,R9\n*----------------------------------------------------------------------\n* Create INMR03 segment's key data\n*----------------------------------------------------------------------\n         MVI   X03SEGL,L$X03SGL                  segment length\n         MVI   X03SEGF,SEG$1+SEG$L+SEG$C         segment flag\n         MVC   X03ID,=C'INMR03'\n         MVC   X03KEY(L$MR03),MR03     copy bogus key data\n*\n*  Update bogus key data with correct values\n*\n**       mvc   x03dsorg,jfcdsorg       dsorg - leave bogus\n**       mvc   x03recfm,jfcrecfm       recfm - leave bogus\n         MVC   X03LRECL,JFCLRECL       lrecl\n*\n*  Calculate estimated file size\n*\n         LA    R1,XMTDCBI              SYSUT1/SYSUT2 DCB\n         UCALL XMITESZ,ERR=EXIT\n         STCM  R0,15,X03ESTSZ\n*----------------------------------------------------------------------\n* Write INMR03 segment\n*----------------------------------------------------------------------\nWRITE    DS    0H\n         LA    R1,X03MR03\n         UCALL XMITPUT                 write INMR03 segment\nEXIT     DS    0H\n         ST    R15,X03RC\n         UDIAG 1,'XMIT03 exited'\n         L     R15,X03RC\n         UPEND  ,\n*\n         EJECT ,\n*\n*        c9d5d4d9f0f3                       *INMR03*\n*        102c 0001 0004 0000bb60            filesize\n*        003c 0001 0002 4000                DSORG=PS\n*        0042 0001 0002 0050                LRECL=80\n*        0049 0001 0002 0001                RECFM=<bogus>\n*\nMR03     DS    0X\nKSIZE    DC    AL2(INMSIZE,1,L'VSIZE)       102C approx file size bytes\nVSIZE    DC    XL4'BB60'\nLSIZE    EQU   *-KSIZE\n*\nKDSORG   DC    AL2(INMDSORG,1,L'VDSORG)     003C dsorg <bogus>\nVDSORG   DC    XL2'4000'\nLDSORG   EQU   *-KDSORG\n*\nKLRECL   DC    AL2(INMLRECL,1,L'VLRECL)     0042 lrecl\nVLRECL   DC    AL2(80)\nLLRECL   EQU   *-KLRECL\n*\nKRECFM   DC    AL2(INMRECFM,1,L'VRECFM)     004.recfm <bogus>\nVRECFM   DC    XL2'0001'\nLRECFM   EQU   *-KRECFM\nL$MR03   EQU   *-MR03\n*\n* optional keys not provided: none\n*\n*\n         LTORG ,\n*----------------------------------------------------------------------\n         EJECT ,\nX03WA    DSECT ,\nX03SA    DS    18F\n*\nX03RC    DS    F             return code\nX03MR03  DS    0D            INMR03 segment\nX03SEGL  DS    X             segment length\nX03SEGF  DS    X             segment flag\nX03SEGD  DS    XL253         beginning of segment data\n         ORG   X03SEGD\nX03ID    DS    C'INMR03'\nX03KEY   DS    0X            beginning of key data\n         DC    AL2(INMSIZE,1,L'VSIZE)       102C approx file size bytes\nX03ESTSZ DC    XL4'BB60'\n         DC    AL2(INMDSORG,1,L'VDSORG)     003C dsorg\nX03DSORG DC    XL2'4000'\n         DC    AL2(INMLRECL,1,L'VLRECL)     0042 lrecl\nX03LRECL DC    AL2(80)\n         DC    AL2(INMRECFM,1,L'VRECFM)     0049 recfm\nX03RECFM DC    XL2'0001'\nL$X03SGL EQU   *-X03MR03                    actual segment length\n         ORG   ,\n         DS    0D\nL$X03WA  EQU   *-X03WA\n*\n         EJECT ,\n         PRINT NOGEN\n         DXMITSEG ,\n*        EJECT ,\n         WAXMT FUNC=XMIT\n*        EJECT ,\n         IEZDEB LIST=YES\nL$DEBDA  EQU   (DEBNMTRK+L'DEBNMTRK)-DEBDASD     l' debdasd section\n*\n*        EJECT ,\nUCB      DSECT ,\n         IEFUCBOB LIST=YES\n*\n*        EJECT ,\n*----------------------------------------------------------------------\n*  See Stage2 assembly of IECZDTAB for values & index\n*----------------------------------------------------------------------\n         IHADVCT ,\n*\n*        EJECT ,\n         PRINT NOGEN\n         CVT   DSECT=YES,LIST=NO\n*\n         DCBD  DSORG=PS,DEVD=DA\n*\nJFCB     DSECT ,\n         IEFJFCBN ,\n         PRINT GEN\n*\nXMIT03   UFINI DXDX03,L$X03WA\n         END   ,\n./ ADD NAME=XMIT06   0100-02182-02182-0702-00094-00094-00000-XMIT370\nXMIT06   TITLE 'WRITE INMR06 segment'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  Things to do:\n*----------------------------------------------------------------------\n         U#SET ,\n*----------------------------------------------------------------------\n* Function: Write the INMR06 segment.\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         R0  =\n*         R1  =\n*\n* Exit:   R15 = return code\n*         R15 = 00 success\n*\n* Abends:\n*\n* Notes:\n*----------------------------------------------------------------------\n* R2     X06WA\n* R3\n* R4     @ segment data\n* R5     length remaining in segment data\n* R6\n* R7\n* R8\n* R9\n* R10\n* R11    XMTWA\n* R12    base reg\n* R13    savearea\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\nXMIT06   UPROC L=L$X06WA,ID=XM06,WA=X06WA\n         UDIAG 1,'XMIT06 entered'\n*----------------------------------------------------------------------\n* Create INMR06\n*----------------------------------------------------------------------\n         LA    R0,L$SEG6               segment length\n         STC   R0,X06SEGL\n         MVC   X06ID,=C'INMR06'\n         MVI   X06SEGF,SEG$1+SEG$L+SEG$C\n*----------------------------------------------------------------------\n* Write INMR06 segment\n*----------------------------------------------------------------------\nWRITE    DS    0H\n         LA    R1,X06MR06\n         UCALL XMITPUT                 write INMR06 segment\n*----------------------------------------------------------------------\n* Final PUTSEG call issued, terminate PUTSEG service\n*----------------------------------------------------------------------\n         SLR   R1,R1                   PUTSEG terminate call\n         UCALL XMITPUT                 terminate PUTSEG service\n         LTR   R15,R15\n         BZ    EXIT\n*\n         MVI   X06RC+3,8\nEXIT     DS    0H\n         UDIAG 1,'XMIT06 exited'\n         L     R15,X06RC\n         UPEND ,\n*\n         LTORG ,\n*----------------------------------------------------------------------\n*\n*        c9d5d4d9 f0f6                       *INMR06*\n*\nX06WA    DSECT ,\nX06SA    DS    18F\n*\nX06RC    DS    F             return code\nX06MR06  DS    0D            INMR01 segment\nX06SEGL  DS    X             segment length\nX06SEGF  DS    X             segment flag\nX06SEGD  DS    XL253         beginning of segment data\n         ORG   X06SEGD\nX06ID    DS    C'INMR06'\nL$SEG6   EQU   *-X06MR06     length of segment written\n         ORG   ,\n         DS    0D\nL$X06WA  EQU   *-X06WA\n         EJECT ,\n         PRINT NOGEN\n         DXMITSEG ,\n         EJECT ,\n         WAXMT FUNC=XMIT\n         PRINT GEN\nXMIT06   UFINI DXDX06,L$X06WA\n         END   ,\n./ ADD NAME=XMIT370  0100-02182-02182-0702-00247-00247-00000-XMIT370\nXMIT370  TITLE 'TSO/E TRANSMIT clone for MVS 3.8J'\n*\n*  Copyright 2001, James M. Morrison\n*\n*----------------------------------------------------------------------\n*  Things to do:\n*  1)  FREEPOOL SYSUT1/SYSUT2\n*----------------------------------------------------------------------\n         U#SET ,\n*----------------------------------------------------------------------\n* Function: Create a file compatible with TSO/E TRANSMIT,\n*           given an input file that is a PDS.\n*           This initial version runs in batch, not as a CP.\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         R0  =\n*         R1  =  Address of OS parmlist\n*         R13 =  savearea ptr\n*         R14 =  return addr to caller\n*         R15 =  address of XMIT370\n*\n* Exit:   R15 = return code\n*         R15 = 00 success\n*\n* Abends: U0001 DCB didn't open\n*\n* Notes:  This routine is responsible for setting up its registers\n*         as required by the PROC and PEND macros.\n*----------------------------------------------------------------------\n* R2     XPSWA\n* R3     DCB\n* R4     OS parm ptr\n* R5\n* R6\n* R7\n* R8\n* R9\n* R10    our real program base reg\n* R11    XMTWA    ... ALL CSECTS (contains our savearea)\n* R12    BASE REG ... ALL CSECTS (dummy for us)\n* R13    savearea\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\nXMIT370  CSECT ,\n         USING *,R15\n         B     MPASTID\n         DC    AL1(MAINIDX-MAINID)\nMAINID   DC    CL8'XMIT370'       MODULE IDENTIFIER\n         DC    CL8'&SYSDATE'      ASSEMBLY DATE\n         DC    CL7' &SYSTIME'     ASSEMBLY TIME\nMAINIDX  EQU   *\nMAINSAL  DC    A(L$XMTWA)         XMTWA LENGTH\nMPASTID  DS    0H\n         DROP  R15\n         STM   R14,R12,12(R13)    STANDARD REGISTER SAVE\n         LR    R10,R15\n         USING XMIT370,R10        BASE REGISTER\n         LR    R4,R1              save parm ptr\n         L     R3,L$DSA           LENGTH OF ALL DSAs\n         LA    R3,4095(,R3)       ROUND\n         SRL   R3,12              TO NEXT\n         SLL   R3,12              PAGE\n         GETMAIN R,LV=(R3)        GET STORAGE FOR DSAs\n         LR    R11,R1\n         USING XMTWA,R11\n         UZERO (R11),(R3)         clear storage\n*\n* Init XMTWA\n*\n         MVC   XMTEYE,=C'XMITDSA '          set eyecatcher\n         LA    R1,XMTSA1\n         ST    R1,8(,R13)         FORWARD POINTER\n         ST    R13,4(,R1)         BACKWARD POINTER\n         LR    R13,R1\n         ST    R3,XMTLDSA                   record l' dsa\n         MVC   XMTDCBI(L$DCBI),MODLDCBI     copy model DCB macros\n         MVC   XMTOPN(L$OPN),MODLOPN        copy model OPEN macro\n         MVC   XMTCLOS(L$CLOS),MODLCLOS     copy model CLOSE macro\n         MVC   XMTJFCBL(L$JFCBL),JFCBLST    copy open exit list\n         LA    R0,XMTJFCB1                  relocate exlst JFCB addr\n         STCM  R0,7,XMTJFCBL+1\n         LA    R0,XMTJFCBL                  relocate DCB's EXLST\n         STCM  R0,7,(DCBEXLSA-IHADCB)+XMTDCBI\n         MVC   XMTXPSWE,=C'PUTWORK '        set XPSWA eyecatcher\n         MVI   XMTDLEV,C'0'                 default diagnostic level\n         LTR   R4,R4\n         BZ    NOPARM\n         L     R4,0(,R4)                    @ OS parm string\n         LH    R14,0(,R4)                   l' parm string\n         LTR   R14,R14                      anything?\n         BNP   NOPARM                       no, br\n         ST    R4,XMT@PARM                  save parm ptr\n         MVC   XMTDLEV,2(R4)                copy diag char\nNOPARM   DS    0H\n*----------------------------------------------------------------------\n*  setup fake PROC based on R12 so PROC macro works for rest of code\n*----------------------------------------------------------------------\n         LR    R12,R10                       UPROC assumes R12 set\n         LA    R15,MAIN                      pretend we just got here\n         PUSH  USING\n         DROP  ,\n         CNOP  0,8\nMAIN     UPROC L=L$MAIN,SECT=LABEL,ID=MAIN,WA=\n         POP   USING                         don't mess up our code\n*----------------------------------------------------------------------\n*  Wake up UTILLOG\n*----------------------------------------------------------------------\n         ULOG  'XMIT370 00.04 Copyright 2001, 2002, James M. Morrison'\n         ULOG  'XMIT370 Initial Developer James M. Morrison'\n         ULOG  'XMIT370 may be distributed under the terms of the Q Pub+\n               lic License version 1.0'\n         ULOG  ' '\n*----------------------------------------------------------------------\n*  Handle UTILDBUG ddname\n*----------------------------------------------------------------------\n         UCALL UTILDBUG                     handle XMITDBUG ddname\n*----------------------------------------------------------------------\n*  Verify we're authorized\n*----------------------------------------------------------------------\n         TESTAUTH FCTN=1                    authorized?\n         LTR   R15,R15\n         BZ    AUTHOK\n         ULOG  'XMIT370 requires authorization'\n         UABEND ,                           not authorized\nAUTHOK   DS    0H\n*----------------------------------------------------------------------\n*  Open DCBs, complain & abend if they don't open\n*----------------------------------------------------------------------\n         LA    R3,XMTDCBI\n         USING IHADCB,R3\n*        udiag 3,'xmit370: xmtdcbi dcb',(r3),l$dcbi\n         OPEN  (XMTDCBI,INPUT),MF=(E,XMTOPN)\n         TM    DCBOFLG1,DCBOFOPN            opened?\n         BO    DCBIOPEN\n         ULOG  'XMIT370: SYSUT1 open failed'\n         UABEND ,                           input DCB didn't open\nDCBIOPEN DS    0H\n         UDIAG 3,'XMIT370: SYSUT1 DCB opened',XMTDCBI,L$DCB\n*\n* Verify DSORG=PS or DSORG=PO\n*\n         TM    DCBDSRG1,DCBDSGPS            DSORG=PS?\n         BO    ORGOK\n         TM    DCBDSRG1,DCBDSGPO            DSORG=PO?\n         BO    ORGOK\n         ULOG  'XMIT370 only support DSORG=PS or DSORG=PO datasets'\n         UABEND ,\nORGOK    DS    0H\n*\n* We have to read the JFCB after the dataset is open,\n* otherwise the JFCB doesn't have the DSORG field filled in\n* which confuses xmitunld when he finally looks at the JFCB\n*\n         RDJFCB (XMTDCBI,INPUT),MF=(E,XMTOPN)\n         LTR   R15,R15\n         BZ    HAVJFCB\n         ULOG  'XMIT370: RDJFCB failed'\n         UABEND ,\nHAVJFCB  DS    0H\n         UDIAG 3,'XMIT370: xmtdcbi jfcb',XMTJFCB1,L$JFCB\n         LA    R0,XMTJFCB1\n         ST    R0,XMT@JFCB                  SYSUT1's JFCB\n*----------------------------------------------------------------------\n*  Unload and write out segments as needed\n*----------------------------------------------------------------------\n         UCALL XMITUNLD,ERR=EXIT\n*----------------------------------------------------------------------\n*  Close DCBs and exit\n*----------------------------------------------------------------------\n         LA    R3,XMTDCBI\n         TM    DCBOFLG1,DCBOFOPN            SYSUT1/SYSUT2 open?\n         BNO   CLODCBI\n         UDIAG 2,'XMIT370: close dcbi'\n         CLOSE XMTDCBI,MF=(E,XMTCLOS)\n**       FREEPOOL XMTDCBI                   ???????\nCLODCBI  DS    0H\n*\n         LA    R3,XMTDCBL\n         TM    DCBOFLG1,DCBOFOPN            XMITPRT open?\n         BNO   CLODCBL\n         UDIAG 2,'XMIT370: close dcbl; last message possible'\n         CLOSE XMTDCBL,MF=(E,XMTCLOS)\n         FREEPOOL XMTDCBL\nCLODCBL  DS    0H\n*\nEXIT     DS    0H\n         L     R3,XMTRC\n         L     R13,XMTSA1+4        LOAD CALLER'S SAVE AREA PTR\n         L     R0,XMTLDSA\n         FREEMAIN R,LV=(0),A=(R11)      free XMITDSA\n         L     R14,12(R13)        STANDARD REGISTER RESTORE\n         LR    R15,R3             SET RETURN CODE\n         LM    R0,R12,20(R13)     STANDARD REGISTER RESTORE\n         XC    8(4,R13),8(R13)    ERASE XMIT370'S SAVEAREA PTR\n         BR    R14                RETURN TO CALLER\n*\n         LTORG ,\n*\nMODLCLOS CLOSE (,),MF=L                model CLOSE\nL$CLOS   EQU   *-MODLCLOS              l' model close\n*\nMODLOPN  OPEN  (,),MF=L                model OPEN\nL$OPN    EQU   *-MODLOPN               l' model open\n*\nJFCBLST  DS    0F\n         DC    XL1'87'\n         DC    AL3(0)\nL$JFCBL  EQU   *-JFCBLST\n*\n* If the SYSUT1 dataset is DSORG=PS, XMIT02B needs it opened\n* If the SYSUT1 dataset is DSORG=PO, XMIT02A deals with closing\n* and reopening the dataset.  The DCB below reflects DCB attributes\n* that may not be true, but all the rest of our code examines the\n* JFCB rather than the DCB to determine DCB attributes, so we're\n* safe.\n*\nMODLDCBI DCB   DDNAME=SYSUT1,DSORG=PS,LRECL=256,BLKSIZE=256,RECFM=F,   +\n               EXLST=JFCBLST,MACRF=R\nL$DCBI   EQU   *-MODLDCBI\n*\n         EJECT ,\n*----------------------------------------------------------------------\n         WAXMT FUNC=XMIT\n         EJECT ,\n         DXMITSEG ,\n         EJECT ,\nSAVEAREA DSECT ,\n         DS    18F           dummy \"main\" proc savearea\nL$MAIN   EQU   *-SAVEAREA\n*\n         PRINT NOGEN\n         DCBD  DSORG=PS,DEVD=DA\nL$DCB    EQU   *-IHADCB\n*\nJFCB     DSECT ,\n         IEFJFCBN ,\nL$JFCB   EQU   *-JFCB\n         PRINT GEN\nXMIT370  UFINI DXDX370,L$XMTWA\nXMIT370  UFINI DXDMAIN,L$MAIN\n*\nL$DSA    CXD   ,   LINKAGE EDITOR CALCULATES TOTAL DSA LENGTH FOR US\n*                  NOTE: THIS TECHNIQUE WILL FAIL FOR RECURSIVE CODE\n*\n         END   ,\n./ ADD NAME=ZTEST    0100-02182-02182-0702-00038-00038-00000-XMIT370\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n         MACRO\n         XTEST &JUNK,&V=\n         LCLC &A(2),&B\n         MNOTE *,'XTEST V(1)    + &V(1) +'\n         MNOTE *,'XTEST V(2)    + &V(2) +'\n&A(1)    SETC  '&V(1)'(2,1)\n&A(2)    SETC  '&V(1)'(4,1)\n.*\n&B       SETC  '&V(2)'\n&B       SETC  '&B'(2,K'&B-2)\n         MNOTE *,'XTEST A(1)=&A(1) A(2)=&A(2) B=&B'\n         BOGUS (&A(1),&A(2)),(&B)\n         MEND\n*\n         MACRO\n         BOGUS &J,&K\n         MNOTE *,'SYSLIST(1)    + &SYSLIST(1) + SHOULD BE (A,B)'\n         MNOTE *,'SYSLIST(2)    + &SYSLIST(2) + SHOULD BE (X,Y)'\n         MNOTE *,'SYSLIST(1,1)  + &SYSLIST(1,1) + SHOULD BE A'\n         MNOTE *,'SYSLIST(1,2)  + &SYSLIST(1,2) + SHOULD BE B'\n         MNOTE *,'SYSLIST(2,1)  + &SYSLIST(2,1) + SHOULD BE X'\n         MNOTE *,'SYSLIST(2,2)  + &SYSLIST(2,2) + SHOULD BE Y'\n         MNOTE *,'J             + &J    + SHOULD BE (A,B)'\n         MNOTE *,'K             + &K    + SHOULD BE (X,Y)'\n         MNOTE *,'J(1)          + &J(1) +  SHOULD BE A'\n         MNOTE *,'J(2)          + &J(2) +  SHOULD BE B'\n         MNOTE *,'K(1)          + &K(1) +  SHOULD BE X'\n         MNOTE *,'K(2)          + &K(2) +  SHOULD BE Y'\n         MEND\n         EJECT\nBOGUS    CSECT ,\n         USING *,15\n         XTEST X,V=((A,B),(X,Y))\n         BOGUS (A,B),(X,Y)\n         END   ,\n./ ADD NAME=ZTESTOLD 0100-02182-02182-0702-00090-00090-00000-XMIT370\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n* Macro errors - COPY macros\n*----------------------------------------------------------------------\n*        COPY  IM#INSTR\n*\n*        COPY  IM#LALR\n*\n*        COPY  IM#IGEN\n*\n         MACRO\n&LABEL   XTEST &JUNK,&V=\n.* BEL   IM#INSTF &V(1),&V(2),&V(3),&V(4),&V(5),&V(6),REG=R1,LST=&V\n         BOGUS &V(1),&V(2),&V(3),&V(4),&V(5),&V(6)\n.*       BOGUS &V\n         MEND\n*\n         MACRO\n         BOGUS &V\n         LCLC  &J(3)\n&J(1)    SETC  '&SYSLIST(1)'\n&J(2)    SETC  '&SYSLIST(2)'\n&J(3)    SETC  '&SYSLIST(3)'\n         MNOTE *,'< > + &J(1) + &J(2) + &J(3)'\n&J(1)    SETC  '&SYSLIST(1,1)'\n&J(2)    SETC  '&SYSLIST(1,2)'\n&J(3)    SETC  '&SYSLIST(1,3)'\n         MNOTE *,'<1> + &J(1) + &J(2) + &J(3)'\n&J(1)    SETC  '&SYSLIST(2,1)'\n&J(2)    SETC  '&SYSLIST(2,2)'\n&J(3)    SETC  '&SYSLIST(2,3)'\n         MNOTE *,'<2> + &J(1) + &J(2) + &J(3)'\n&J(1)    SETC  '&SYSLIST(3,1)'\n&J(2)    SETC  '&SYSLIST(3,2)'\n&J(3)    SETC  '&SYSLIST(3,3)'\n         MNOTE *,'<3> + &J(1) + &J(2) + &J(3)'\n         MEND\n*\n         PRINT OFF\n         XMIT#SET ,\nRECVRCPY PROC ID=TEST,L=L$SAV\n         PRINT ON\n         XTEST X,V=(R3)\n*\n         XTEST X,V=F4\n*\n         XTEST X,V=*F4\n*\n         XTEST X,V=.F4\n*\n         XTEST X,V=-CLEAR-\n*\n         XTEST X,V=(-CLEAR-)\n*\n         XTEST X,V=((-CLEAR-))\n*\n         XTEST X,V=(-ZERO-)\n*                                      probably not a good idea;\n         XTEST X,V=((SR,R1))           assumes internal macro knowledge\n*\n         XTEST X,V=(-0-)               better\n*\n         XTEST X,V=((ICM,12,F2))\n*\n         XTEST X,V=((-ZERO-),(IC,F1))\n*\n         XTEST X,V=((LH,F2),(STH,F4))\n*\n         XTEST X,V=((LH,F2),(ICM,8,F1),(MVI,F4,1))\n*\n         XTEST X,V=((MVI,F1,8))\n*\n         XTEST X,V=((MVC,F1,F2))\n*\n         XTEST X,V=((-0-),(IC,F1),(OI,F4,32))\n*\nGONZO    XTEST X,V=((MVC,F4(2),=X'4170'),(MVC,F4+2(2),=S(F1)),         +\n               (-0-),(EX,F4),(LR,R7))\n*\n         LTORG ,\nSAVEAREA DSECT ,\nF4       DS    F\nF2       DS    H\nF1       DS    C\nL$SAV    EQU   *-SAVEAREA\n         XMTWA FUNC=UTIL,GEN=NO,DATA=NO,PRINT=OFF\nRECVRCPY XMITFINI DXDTEST,L$SAV\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$README": {"ttr": 4363, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "XV0006"}, "text": "\nCopyright 2001-2008 James M. Morrison\n\nWelcome to xxxx370 v0006\n\nFor the copyright claims,       see the $COPY    member.\nFor an introduction to xxxx370, see the $INTRO   member.\nFor installation instructions,  see the $INSTALL member.\nFor DAST370 documentation,      see the $DAST    member.\nFor RECV370 documentation,      see the $RECV    member.\nFor XMIT370 documentation,      see the $XMIT    member.\nFor the change log,             see the $CHANGES member.\n\nMember Naming Conventions\n-----------------------------------------------------------------------\n\nMEMBER   Contents\n\n$....... Commentary\nD....... DSECT macros\nIM#..... inner macros\nJ....... JCL\nK....... Control cards\nLICENSE  Q Public License version 1.0, modified to fit LRECL=80\nNOTE.... Miscellaneous notes\nRECV.... RECV370 CSECTs\nU370.... Utility CSECTs\nU....... Utility macros\nWA...... Work Areas DSECT macros\nXMIT.... XMIT370 CSECTs\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$RECV": {"ttr": 4609, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00g\\x00g\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 103, "newlines": 103, "modlines": 0, "user": "XV0006"}, "text": "\nCopyright 2002-2008 James M. Morrison\n\n                RECV370\n\n                Version 00.06           April 9, 2008\n\nThe RECV370 source code and executables are\nCopyright 2001-2008  James M. Morrison.\n\nRECV370 is released under the provisions of the\nQ Public License version 1.0.\nRefer to the LICENSE member for the license details.\n\n\n                Overview\n                --------\n\nRECV370 is a program for execution under MVS 3.8J, which provides\nfacilities similar to the TSO/E RECEIVE command processor.\nAs opportunities present themselves, I'm testing it under other\nversions of MVS.\n\nRECV370 will, given an XMIT file as input, produce a sequential or\npartitioned dataset as output.\n\nRECV370 will process XMIT files produced by either the TSO/E TRANSMIT\ncommand processor, the XMIT370 batch program, or a similar facility.\nRECV370 supports DSORG=PO and DSORG=PS datasets in the XMIT file.\n\n\n                Installation\n                ------------\n\nFor installation instructions, refer to the $INSTALL member.\nIf you wish to install RECV370 only, see the JRECVALL member.\n\n\n                Demonstration JCL\n                -----------------\n\nJRECVPDS        Create XMIT from partitioned dataset (PDS; DSORG=PO)\n                and then receive it\n\nJRECVSEQ        Create XMIT from sequential dataset (DSORG=PS)\n                and then receive it\n\n\n                RECV370 JCL\n                -----------\n\nRECV370 is a batch program, and requires APF authorization.\n\nRECV370 DDNAMEs:\n----------------\n\n    RECVLOG        RECV370 output messages (required)\n\n    RECVDBUG       Optional, specifies debugging options.\n\n    XMITIN         input XMIT file to be received (required)\n\n    SYSPRINT       IEBCOPY output messages (required for DSORG=PO\n                   input datasets on SYSUT1)\n\n    SYSUT1         Work dataset for IEBCOPY (not needed for sequential\n                   XMITs; required for partitioned XMITs)\n\n    SYSUT2         Output dataset - sequential or partitioned\n\n    SYSIN          IEBCOPY input dataset (required for DSORG=PO XMITs)\n                   A DUMMY dataset.\n\nRECV370 only supports input datasets of DSORG=PO and DSORG=PS.\nI have concentrated most of my testing on DSORG=PO RECFM=FB datasets.\n\nMembers specific to RECV370:\nDRCS2\nJRECV\nJRECVALL\nJRECVCBT\nJRECVPDS\nJRECVSEQ\nJRECV1\nKBUGRECV\nKLNKRECV\nRECV#BUG\nRECVBLK\nRECVCTL\nRECVGCTL\nRECVGSEG\nRECVMSG\nRECVRCPY\nRECVUTIL\nRECVVTAB\nRECV370\nWARECV\n\nThat's it.  Good luck and enjoy!\n\nJim Morrison     n9gtm@comcast.net\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$STCP": {"ttr": 4612, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "XV0006"}, "text": "\nCopyright 2002, James M. Morrison\n\n                             TCP/IP\n                             ------\n\nOverview\n--------\n\nTCP/IP is designed to run exclusively in MVS38j under the Hercules\nemulator in S/370 mode\n\nHercules is a GPL'd project initially written by Roger Bowler,\ncurrently maintained by Jay Maynard, with major contributions by\na numerous list of fine souls including such luminaries as\nJan Jaeger, Greg Smith, and David Trout (Fish) to name but a few.\n\nMVS38j is available in the public domain, and in various flavors\nfrom Volker Bandke, Jay Moseley, Jay Maynard, and others\n\nFor further information on both Hercules and MVS38j, see the following\nYahoo communities, particularly the Bookmarks sections of the\nweb sites:\n\n    http://groups.yahoo.com/group/hercules-390\n    http://groups.yahoo.com/group/H390-MVS\n\nFor TCP/IP design notes, see the NOTETCP  member\nFor TCP/IP API    notes, see the NOTETCPA member (may not yet exist)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$UTIL": {"ttr": 4614, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x01\\x00\\x01\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 1, "newlines": 1, "modlines": 0, "user": "XV0006"}, "text": "\n", "mimetype": "text/plain", "datatype": "us-ascii", "extension": ".txt"}, "$WORKQ": {"ttr": 4616, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x000\\x000\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 48, "newlines": 48, "modlines": 0, "user": "XV0006"}, "text": "Copyright 2001, 2002 James M. Morrison\n\n\nWork in progress:\n\n\nSTCPxxxx - TCP/IP STC/subsys\n\nSTCPTSKM - support WUD1MOD setting\n\nPending change notes (more or less in the order which I consider\nthe change's importance to be):\n\nXMIT370  - resolve XMITs being unRECEIVEable on OS/390\n           Keys with values different than their \"natural\"\n           lengths seem very suspicious\n         - create PUTKEY routine\n         - review keys' value(S0, fill in with better data\n\nRECV370  - rename ddnames\n         - Split RECVCTL, create GETKEY routine\n\nU370AP00 - call each CSECT at startup as indicated in VTAB\n           Probably set bit in TGD indicating that's happening\n           Create VTAB in storage so TPD, DSA can be found\n\nU370AP99 - Add VTAB bit indicating cleanup, call each CSECT\n           Call AP99 from UPEND\n           Add support to UVTAB:\n           EOT= end of task, EOA= end of appl\n\n           With AP00 & AP99 changes outlined, xxxx370 should have\n           very little (if any) infrastructure init to perform\n\nDAST370  - why in the world has STSI stopped working?\n           Possibly due to Hercules CVS branch structure, where\n           JJ's change isn't rolled into 2.16.5 yet but is in CVS\n           Didn't this work in 2.16.4 or thereabouts?\n           Once that's resolved, add Herc DIAGNOSE CSECT(s)\n\nU370HERC - finish writing\n           Maybe yes, maybe no.  Given the latest plans for MVS38j\n           TCP/IP, it doesn't appear we need Herc-specific code.\n           This might be just as well, as Herc 2.16.5 (current as I\n           type this) produces an operation exception for STSI.\n           STSI was to be the technique used to identify the presence\n           of the Hercules emulator.  Maybe it'll be fixed in the\n           next general release of Hercules.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$XMIT": {"ttr": 4618, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00y\\x00y\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 121, "newlines": 121, "modlines": 0, "user": "XV0006"}, "text": "\nCopyright 2001-2008 James M. Morrison\n\n                XMIT370\n\n                Version 00.06           April 9, 2008\n\nThe XMIT370/RECV370 source code and executables are\nCopyright 2001-2008  James M. Morrison.\n\nXMIT370/RECV370 is released under the provisions of the\nQ Public License version 1.0.\nRefer to the LICENSE member for the license details.\n\n\n                Overview\n                --------\n\nXMIT370 is a program for execution under MVS 3.8J, which provides\nfacilities similar to the TSO/E TRANSMIT command processor.\nAs opportunities present themselves, I'm testing it under other\nversions of MVS.\n\nXMIT370 will, given a DSORG=PO or DSORG=PS dataset as input, produce\nan XMIT file as output.\n\nThe resulting XMIT dataset can be processed using the TSO/E RECEIVE\ncommand processor, Hercules dasdload (for DSORG=PO datasets), my\nRECV390 program (for DSORG=PO datasets), or any of the other UnXmit\nprograms as detailed at http://planetmvs.com on the UnXmit Information\nExchange page.\n\n\n                Installation\n                ------------\n\nFor installation instructions, refer to the $INSTALL member.\nIf you wish to install XMIT370 only, see the JXMITALL member.\n\n\n                Demonstration JCL\n                -----------------\n\nJXMITPDS        Create XMIT from partitioned dataset (PDS; DSORG=PO)\nJXMITSEQ        Create XMIT from sequential dataset (DSORG=PS)\n\n\n                XMIT370 JCL\n                -----------\n\nXMIT370 is a batch program, and requires APF authorization.\n\nXMIT370 DDNAMEs:\n----------------\n\n        SYSPRINT        IEBCOPY output messages (required for DSORG=PO\n                        input datasets on SYSUT1)\n\n        XMITLOG         XMIT370 output messages (required)\n\n        SYSUT1          input dataset to be XMIT370'd (required)\n\n        SYSUT2          work dataset for IEBCOPY for DSORG=PO datasets;\n                        should be large enough to contain SYSUT1\n                        plus a little more (required for SYSUT1\n                        DSORG=PO).\n                        Temporary dataset deleted at end of step is OK.\n\n        XMITOUT         XMIT370 output XMIT dataset (required)\n                        Any DCB attributes you specify are currently\n                        ignored.\n                        Should be large enough to contain SYSUT1\n                        plus some more for the XMIT370 \"wrapper\" and\n                        any IEBCOPY overhead data (10 - 20% more\n                        should be sufficient).\n\n        SYSIN           IEBCOPY input dataset (required for SYSUT1\n                        DSORG=PO datasets).\n                        A DUMMY dataset.\n\n        XMITDBUG        Optional, specifies debugging options.\n\nHercules users:\n\n   For input datasets of DSORG=PO, you can use the Hercules dasdload\n   program to restore the PDS to a dasd volume.\n\n   You can also use the dasdpdsu program to extract the members from a\n   PDS on Hercules dasd.\n\nXMIT370 only supports input datasets of DSORG=PO and DSORG=PS.\nI have concentrated most of my testing on RECFM=FB input datasets.\n\nMembers specific to XMIT370:\nDCOPYR1\nDXSEG\nJXMIT\nJXMITPDS\nJXMITSEQ\nKBUGXMIT\nKLNKXMIT\nXMIT#BUG\nXMITBUF\nXMITCPR1\nXMITDIR\nXMITESZ\nXMITPUT\nXMITUNLD\nXMITVTAB\nXMIT01\nXMIT02A\nXMIT02B\nXMIT03\nXMIT06\nXMIT370\nWAXMIT\n\nThat's it.  Good luck and enjoy!\n\nJim Morrison     n9gtm@comcast.net\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$XMI0004": {"ttr": 4621, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00;\\x00;\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 59, "newlines": 59, "modlines": 0, "user": "XV0006"}, "text": "\nXMIT370 v00.04 notes:\n\nDuring testing, I tried to receive the created XMIT files on as\nmany different environments as possible.  Special thanks to those\nkind souls who helped test various MVS environents.\n\n\nHercules 2.16.2 dasdload\n------------------------\n\nworks fine, with and without modification to COPYR1 record\n\n\nRECV390 v1r1m5 (not released, I'm still working on it)\n--------------\n\nworks fine, with and without modification to COPYR1 record\n\n\nMVS38j RECV370\n--------------\n\nJINSTALL - install XMIT370 & RECV370\nJXMIT    - create XMIT without modifying COPYR1 record\nJXMITC   - create XMIT with COPYR1 modification\nJRECV    - receive XMIT files created above\n\nworks fine, with or without modifications to COPYR1 record\n\n\nMVS/ESA TSO/E RECEIVE\n---------------------\n\nInteresting behavior demonstrated by IEBCOPY, which complains that\nthe COPYR1 length is invalid.  The COPYR1 that IEBCOPY displays\nlooks nothing like the COPYR1 in the XMIT, which I verified by\nrunning RECV370 which spins out a SYSUT1 file that I Full-Screen\nZapped.  An intended side-effect of running RECV370 is that it\nsimply unwraps the XMIT and places it on the SYSUT1 ddname.  That\nit actually calls IEBCOPY is merely a happy coincidence.  ;-) What is\ncausing this behavior, I can't exactly say at this point and time.\nI have a mild suspicion that there's a problem with the segments:\neither a key that RECEIVE doesn't understand, or possibly a\nconstruction error.  Unfortunately, I had very limited time on this\nsystem, so it is as yet undetermined.  However, as time becomes\navailable, I'll keep pluggin away at it.  If someone has spare cycles\non an Internet-connected MVS/ESA system I can use to further test,\nI'd be very happy to hear from you (jmorrison@ameritech.net).\n\nI'd like all of XMIT370's XMITs to RECEIVE properly under MVS/ESA,\nbut as of right now that's not the case.  If your version of IEBCOPY\ncan cope with MVS38j IEBCOPY's COPYR1 record, you're golden.\n\nTo the extent that RECV370 works, it acts as a decent substitute\nfor TSO/E RECEIVE on MVS/ESA so all is not lost.  The very same XMIT\nthat TSO/E RECEIVE/IEBCOPY complained about received fine with RECV370.\nI'm sure that's a clue of some kind.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE571": {"ttr": 4623, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04L\\x00\\x00\\x01\\x08\\x10/\\x01\\x08\\x10/\\x184\\x00\\x1f\\x00\\x1f\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf6@@@'", "ispf": {"version": "04.76", "flags": 0, "createdate": "2008-04-11T00:00:00", "modifydate": "2008-04-11T18:34:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "CBT-476"}, "text": "//***FILE 571 is from Jim Morrison, and contains XMIT370 and        *   FILE 571\n//*           RECV370.  These are tools to create and handle        *   FILE 571\n//*           XMIT-format pds files (which are FB-80 sequential     *   FILE 571\n//*           files) on MVS systems (such as MVS 3.8) which do      *   FILE 571\n//*           not contain the TSO XMIT and RECEIVE commands.        *   FILE 571\n//*                                                                 *   FILE 571\n//*           XMIT and RECEIVE were first shipped with TSO/E,       *   FILE 571\n//*           so any pre-TSO/E TSO releases probably do not have    *   FILE 571\n//*           the XMIT and RECEIVE capabilities.                    *   FILE 571\n//*                                                                 *   FILE 571\n//*           These tools are batch programs, and are not TSO       *   FILE 571\n//*           commands, as are the TSO/E XMIT and RECEIVE programs. *   FILE 571\n//*                                                                 *   FILE 571\n//*           These programs were created so that Hercules MVS 3.8  *   FILE 571\n//*           users can handle XMIT-format sequentialized pds'es.   *   FILE 571\n//*                                                                 *   FILE 571\n//*           A load module library has been included, as member    *   FILE 571\n//*           XMIT370L, in normal TSO XMIT format.                  *   FILE 571\n//*                                                                 *   FILE 571\n//*           An object module library has been included, as        *   FILE 571\n//*           XMIT370O, in IEBUPDTE (PDSLOAD) format.               *   FILE 571\n//*                                                                 *   FILE 571\n//*           The previous version of this file has been included   *   FILE 571\n//*           in IEBUPDTE (PDSLOAD) format, as member $OLDF571.     *   FILE 571\n//*                                                                 *   FILE 571\n//*         email:  Jim Morrison <n9gtm@comcast.net>                *   FILE 571\n//*                                                                 *   FILE 571\n//*    Updates to members JXMITPDS and U370DATE from Phil Roberts.  *   FILE 571\n//*                                                                 *   FILE 571\n//*         email:  Phil Roberts <opplr@hotmail.com>                *   FILE 571\n//*                                                                 *   FILE 571\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASM370": {"ttr": 4625, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x10\\x00\\x10\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "XV0006"}, "text": "//ASM370   PROC M=MISSING,LIST=,PRT=DISK,HLQ=SYS2,APP=XMIT,SRC=XMIT\n//ASMBLR   EXEC PGM=IFOX00,COND=(5,LT),REGION=6144K,\n//         PARM='&LIST.LIST,NOLOAD,DECK,NOXREF,NORLD,LINECOUNT(999)'\n//SYSPRINT  DD DDNAME=&PRT\n//SYSOUT    DD SYSOUT=*\n//DISK      DD DSN=&HLQ..&APP.370.LIST(&M),DISP=SHR\n//SYSLIB    DD DSN=&HLQ..&SRC.370.ASM,DISP=SHR,\n//             DCB=BLKSIZE=32720\n//          DD DSN=SYS1.AMACLIB,DISP=SHR\n//          DD DSN=SYS1.AMODGEN,DISP=SHR\n//          DD DSN=SYS1.AGENLIB,DISP=SHR\n//SYSPUNCH  DD DSN=&HLQ..&APP.370.OBJ(&M),DISP=SHR\n//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(35,10))\n//SYSUT2    DD UNIT=SYSDA,SPACE=(CYL,(35,10))\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(50,10))\n//SYSIN     DD DSN=&HLQ..&SRC.370.ASM(&M),DISP=SHR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DAST#BUG": {"ttr": 4627, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\t\\x00\\t\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n         DAST#BUG &PFX=TGDD\n.*\n.* Copyright 2002 James M. Morrison\n.*\n         LCLC  &P\n&P       SETC  '&PFX'\n&P.MVCP  DS    C        DASTMVCP\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DASTMVCP": {"ttr": 4629, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\xf8\\x00\\xf8\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 248, "newlines": 248, "modlines": 0, "user": "XV0006"}, "text": "         GBLC  &XMTREGS\nDASTMVCP TITLE 'DAS test'\n*----------------------------------------------------------------------\n* To do:\n*----------------------------------------------------------------------\n         U#SET FUNC=DAST\n*----------------------------------------------------------------------\n*\n* Notes:\n*\n* Debug:  1  entry; # times retried at exit\n*         2  show ASCB, ASXB\n*         3  show ASVT\n*         4  show MVCP result\n*         5  show ASID (even for unassigned ASs)\n*         6  show control regs at entry\n*         7  MVCP regs\n*         8  SAVEAREA @ exit\n*----------------------------------------------------------------------\n* R2      MVCP parm, scratch\n* R3      MVCP parm\n* R4      ASVT\n* R5      current ASVT entry\n* R6      ASCB\n* R7\n* R8\n* R9\n* R10\n* R11    DASTWA\n* R12    base reg\n* R13    savearea/workarea\n*----------------------------------------------------------------------\n*\n*  UABEND reason codes\n*\nERR#1    EQU   1             MVCP source won't fit in SAWORK\n         TITLE ' '\n*----------------------------------------------------------------------\nDASTMVCP UPROC L=L$SA,ID=RBLK,CPD=(Y,0,ESTAE),INIT=MVCL\n         EJECT ,\n         UDIAG 1,'DASTMVCP entered'\n         UESTAE RETRY\n*----------------------------------------------------------------------\n*  Save system's control regs (mostly curiosity)\n*----------------------------------------------------------------------\n         MODESET MODE=SUP\n         STCTL R0,15,SACTL\n         UDIAG 6,'DASTMVCP Control regs at entry',SACTL,16*4\n*----------------------------------------------------------------------\n*  Run ASVT, snap each ASCB\n*----------------------------------------------------------------------\n         STCTL R0,R0,SACTL0\n         OI    SACTL0,B'00000100'           enable DAS\n         LCTL  R0,R0,SACTL0\n*\n         L     R2,16                        @ CVT\n         L     R4,CVTASVT-CVT(,R2)          @ ASVT\n         USING ASVT,R4\n*\n         L     R14,ASVTMAXU                 max # ASs\n         SLL   R14,2                        * 4\n         LA    R14,ASVTENTY-ASVT(,R14)      length of ASVT\n         UDIAG 3,'DASTMVCP ASVT',(R4),(R14)\n         LA    R5,ASVTENTY-4\n*\nNXTASVT  DS    0H\n         LA    R5,4(,R5)                    @ next ASVT entry\n         CLC   =X'80000000',0(R5)           last ASVT entry?\n         BE    LASTASVT\n*\n         L     R6,0(R5)                     @ ASCB\n         USING ASCB,R6\n         LH    R14,ASCBASID                 ASID\n         UPSR  5,'DASTMVCP ASID',(R14)\n*\n         TM    0(R5),ASVTAVAL               ASID available?\n         BO    NXTASVT\n*\n         ICM   R14,15,ASCBJBNI              jobname ptr\n         BNZ   *+8\n         ICM   R14,15,ASCBJBNS              stc/mount/log name ptr\n         MVC   SAMSG+00(8),0(R14)\n         MVC   SAMSG+09(4),=C'ASID'\n         LH    R0,ASCBASID\n         SLR   R1,R1\n         UCALL U370HEX\n         STCM  R1,15,SAMSG+14\n         MVC   SAMSG+19(11),=C'           '\n         TM    ASCBRCTF,ASCBOUT\n         BNO   *+10\n         MVC   SAMSG+19(11),=C'SWAPPED-OUT'\n         ULOG  SAMSG\n*\n         UDIAG 2,'DASTMVCP ASCB',(R6),L$ASCB\n         TM    ASCBRCTF,ASCBOUT             swapped out?\n         BO    NXTASVT\n*----------------------------------------------------------------------\n*  Retrieve ASXB (in LSQA) for AS\n*----------------------------------------------------------------------\n         LA    R0,L$ASXB                    length\n         L     R1,ASCBASXB                  2nd AS source\n         LA    R2,SAWORK                    1st AS destination\n         LR    R3,R6                        ASCB\n*\n         MVI   SAREASON,ERR#1\n         LA    R15,L'SAWORK\n         CR    R0,R15                       too long?\n         BH    DIE\n*\n         BAL   R14,MVCP                     copy 2ndry AS data\n         UDIAG 2,'DASTMVCP ASXB',SAWORK,L$ASXB\n         B     NXTASVT\n         EJECT ,\n*----------------------------------------------------------------------\n*  MVCP routine\n*\n*  Entry:\n*        R0    length\n*        R1    Secondary AS source addr\n*        R2    Primary   AS destination addr\n*        R3    ASCB\n*----------------------------------------------------------------------\n         PUSH  USING\nMVCP     DS    0H\n         STM   R0,R15,SA2                   save caller's regs\n         LCTL  R7,R7,ASCBSTOR-ASCB(R3)      2ndry STOR\n         LA    R3,256                       max length per MVCP\n         LR    R7,R0                        MVCP length\n         LR    R9,R1                        MVCP source\n         LR    R8,R2                        MVCP destination\n         SLR   R10,R10                      MVCP 2ndry storage key\n         LR    R2,R0\nMVCPLOOP DS    0H\n         UDIAG 7,'DASTMVCP MVCP regs',&XMTREGS,16*4,REGS=YES\n*\n*\n*  Move to Primary\n*\n*        MVCP  0(R7,R8),0(R9),R10\n*\n*        Length of move:              R7\n*        Primary AS destination:      0(R8)\n*        Secondary AS source:         0(R9)\n*        Secondary AS access key:     R10 - bits 24-27\n*\n         DC    X'DA',AL.4(R7,R10),S(0(R8),0(R9))\n         BZ    MVCPEXIT\n*\n         AR    R8,R3                        bump destination\n         AR    R9,R3                        bump source\n         SR    R7,R3                        decr remaining length\n         BP    MVCPLOOP\n*\nMVCPEXIT DS    0H\n         UDIAG 4,'DASTMVCP MVCP result',SAWORK,(R2)\n         LM    R0,R15,SA2                   restore caller's regs\n         BR    R14\n         POP   USING\n*----------------------------------------------------------------------\n*  Internal error\n*----------------------------------------------------------------------\nDIE      UABEND SAREASON\n*----------------------------------------------------------------------\n*  Restore system's control regs\n*----------------------------------------------------------------------\nLASTASVT DS    0H\nRESET    DS    0H\n         LCTL  R0,R0,SACTL+(R0*4)           restore original CR0\n         LCTL  R7,R7,SACTL+(R7*4)           restore original CR7\n         MODESET MODE=PROB\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\nEXIT     DS    0H                           return values set\n         UDIAG 8,'DASTMVCP savearea',SAVEAREA,L$SA\n         UPSR  1,'DASTMVCP # times retried',*SARC\n         UPEND RC=SARC\n*----------------------------------------------------------------------\n*  ESTAE retry routine\n*----------------------------------------------------------------------\nRETRY    DS    0H\n         UDIAG 0,'DASTMVCP retry SDWA',(R1),512\n*\n         L     R10,SARC\n         LA    R10,1(,R10)\n         ST    R10,SARC\n         UPSR  0,'DASTMVCP retry sarc',(R10)\n*\n         C     R10,=F'3'\n         BL    RESET\n*\n         TM    SAFLAG1,SA1ENT          been here before?\n         BO    EXIT\n         OI    SAFLAG1,SA1ENT          flag entry\n         B     RESET\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\n         LTORG ,\n         EJECT ,\n*----------------------------------------------------------------------\n*  Savearea/workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSA       DS    18F                     savearea for called code\nSA2      DS    16F                     savearea for MVCP\nSARC     DS    F\n*\nSAFLAG1  DS    X                       status flag\nSA1ENT   EQU   128                     RETRY routine entered\n*\nSAREASON DS    X                       UABEND reason code\n*\nSAMSG    DS    CL80\n*\n         DS    0D\nSAWORK   DS    CL1024                  MVCP destination\n*\nSACTL    DS    16F\nSACTL0   DS    F                       modified CR0\nSACTL7   DS    F                       modified CR7\nSAWORD   DS    F\n         DS    0D\nL$SA     EQU   *-SAVEAREA\n*\n         EJECT ,\n*\n         PRINT GEN\n         WADAST ,\n         PRINT NOGEN\n*\n         CVT   DSECT=YES,LIST=NO\n*\n         IHAASVT ,\n*\n         IHAASCB ,\nL$ASCB   EQU   *-ASCB\n*\n         IHAASXB ,\nL$ASXB   EQU   *-ASXB\n*\n         IKJTCB  LIST=NO\nL$TCB    EQU   TCBLEN-TCBPXLEN\n*\n         PRINT GEN\nDASTMVCP UFINI DXDRGET,L$SA\n*\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DASTVTAB": {"ttr": 4869, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "XV0006"}, "text": "DASTVTAB TITLE 'DAST370 VCON table'\n*\n* Copyright 2002 James M. Morrison\n*\n         U#SET FUNC=DAST\n         UVTAB MF=HDR\n*\n         UVTAB DAST370\n         UVTAB DASTMVCP\n*\n         UVTAB MF=TLR\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DAST370": {"ttr": 4871, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00W\\x00W\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 87, "newlines": 87, "modlines": 0, "user": "XV0006"}, "text": "DAST370  TITLE 'Dual Address Space test'\n*----------------------------------------------------------------------\n*  Copyright 2002, James M. Morrison\n*----------------------------------------------------------------------\n*  Things to do:\n*----------------------------------------------------------------------\n         U#SET FUNC=DAST\n*----------------------------------------------------------------------\n* Notes:\n*----------------------------------------------------------------------\n* R2\n* R3\n* R4\n* R5\n* R6\n* R7\n* R8\n* R9\n* R10    our real program base reg\n* R11    DASTWA ... ALWAYS (contains our savearea)\n* R12    BASE REG ... ALL CSECTS (dummy for us)\n* R13    savearea\n*----------------------------------------------------------------------\n         TITLE ' '\nDAST370  UPROC L=L$MAIN,ID=MAIN,CPD=(Y,0,ESTAE)\n*----------------------------------------------------------------------\n*  Set up environment\n*----------------------------------------------------------------------\n         ULOG 'DAST370 v00.00 Copyright 2002, James M. Morrison'\n         UCALL U370DBUG                handle XMITDBUG ddname\n         UQENV QNV$QHEP                query environment\n         TM    TGDFLG2,TGD2VAPF+TGD2APF     APF authd?\n         BO    AUTHOK\n         ULOG  'DAST370 requires authorization'\n         MVI   SAREASON,X'47'          not authorized\nUABEND   UABEND SAREASON               ABEND w/ diagnostics\nAUTHOK   DS    0H\n*\n*  Let U370QENV call U370STAE to establish a supervisor state, key 0\n*  ESTAE environment.  Once U370STAE has established that ESTAE\n*  environment, we just want to specify a RRR.\n*\n         UESTAE RETRY                  establish ESTAE environment\n*----------------------------------------------------------------------\n*  Test out Hercules FEATURE_DUAL_ADDRESS_SPACE\n*----------------------------------------------------------------------\n         UCALL DASTMVCP                test FEATURE_DUAL_ADDRESS_SPACE\n*----------------------------------------------------------------------\n*  Terminate ESTAE environment, close LOG\n*----------------------------------------------------------------------\nRESTART  DS    0H\n         UESTAE TERM=YES\n         ULOG   TERM=YES\n*----------------------------------------------------------------------\n*  Return to caller (FREEMAIN: should be in prob state?)\n*----------------------------------------------------------------------\nEXIT     DS    0H\n         L     R3,DASRC\n         STM   R0,R15,TGDREGS      debug aid\n         UPEND RC=(R3)             <debug> FREE=NO,DIE=YES\n*----------------------------------------------------------------------\n*  ESTAE retry routine\n*----------------------------------------------------------------------\nRETRY    DS    0H\n         STM   R0,R15,SAREGS       diag aid\n         UWTO  2,'DAST370 RETRY routine called'\n         UDIAG 3,'DAST370 retry regs',SAREGS,16*4\n         B     RESTART\n*\n         LTORG ,\n*\n         EJECT ,\n         WADAST ,\n*\n         EJECT ,\nSAVEAREA DSECT ,\n         DS    18F\nSAREGS   DS    16F\nSAREASON DS    X\nSAEND    DS    0D\nL$MAIN   EQU   *-SAVEAREA\n*\n         PRINT GEN\nDAST370  UFINI DXDTGD,L$DAST,ID=TGD         TGD + DASTWA\nDAST370  UFINI DXDD370,L$MAIN               CSECT workarea\n*\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DIAGNOSE": {"ttr": 4874, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x006\\x006\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 54, "newlines": 54, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   DIAGNOSE &DIAG,&OPT\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n.*---------------------------------------------------------------------\n.* Function: Issue Diagnose code to Hercules emulator\n.*           See Hercules diagnose.c source code\n.* &DIAG   - Hercules diagnose code\n.* &OPT    - Options, for diagnose instructions that support it\n.*---------------------------------------------------------------------\n         GBLB  &G#HERC\n         AIF   (&G#HERC).GEN\n         MNOTE 2,'HERC macro detected lack of Hercules support'\n         MNOTE *,'HERC macro expansion suppressed'\n         MEXIT\n.*\n.GEN     AIF   (N'&OPT EQ 4).FOUR\n         AIF   (N'&OPT EQ 3).THREE\n         AIF   (N'&OPT EQ 2).TWO\n         AIF   (N'&OPT EQ 1).ONE\n         AIF   (N'&OPT EQ 0).NONE\n         MNOTE 2,'HERC macro OPT parse error'\n         MEXIT\n.*\n.*       X'83-ab-cc-dd'\n.*\n.FOUR    ANOP\n&LABEL   DC    AL1(131),A.4(&OPT(1),&OPT(2)),AL1(&OPT(3),&DIAG)    HERC\n         MEXIT\n.*\n.*       X'83-ab-cc-dd'\n.*\n.THREE   ANOP\n&LABEL   DC    AL1(131),A.4(&OPT(1),&OPT(2)),AL1(&OPT(3),&DIAG)    HERC\n         MEXIT\n.*\n.*       X'83-aa-dddd'\n.*\n.ONE     ANOP\n&LABEL   DC    AL1(131,&OPT),AL2(&DIAG)               HERCules diagnose\n         MEXIT\n.*\n.*       X'83-ab-dddd'\n.*\n.TWO     ANOP\n&LABEL   DC    AL1(131),AL1.4(&OPT(1),&OPT(2)),AL2(&DIAG) HERC diagnose\n         MEXIT\n.*\n.*       X'83-00-dddd'\n.*\n.NONE    ANOP\n&LABEL   DC    AL1(131,0),AL2(&DIAG)                  Hercules DIAGNOSE\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DRCS2": {"ttr": 4876, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00)\\x00)\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n         DRCS2 ,\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n*----------------------------------------------------------------------\n*  Control Segment INMR02 saved data\n*----------------------------------------------------------------------\nCS2      DSECT ,\nCS2ID    DS    CL4'CS2'      block id\nCS2#FILE DS    F             file number to which data applies\n*                            (relative to 1)\n*\n*  This area is based on the assumption that all CLVH values are\n*  four bytes or less.  They don't really have to be, I've just not\n*  seen them larger than that.  Like most assumptions, this will\n*  likely cause problems down the road. <sigh>\n*\n*  The field names correspond to keys named INM rather than CS2.\n*\nCS2BLKSZ DS    F\nCS2CREAT DS    F\nCS2DIR   DS    F\nCS2DSORG DS    F\nCS2EXPDT DS    F\nCS2FFM   DS    F\nCS2LCHG  DS    F\nCS2LRECL DS    F\nCS2LREF  DS    F\nCS2MEMBR DS    CL8\nCS2RECFM DS    F\nCS2SIZE  DS    F\nCS2TERM  DS    C\nCS2DONE  DS    C             set when CS2 has been handled\nCS2$DONE EQU   C'C'\n         DS    CL2\nCS2UTRC  DS    F             utility return code\nCS2UTILN DS    CL8\n         DS    0D\nL$CS2    EQU   *-CS2\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DSACPD": {"ttr": 4878, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00)\\x00)\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   DSACPD &MF=DSECT,&SECT=DSECT,&PFX=CPD\n.*\n.* Copyright 2002 James M. Morrison\n.*\n         GBLC  &GUPROCP(8)         UPROC CPD=\n         LCLC  &P\n.*\n         AIF   ('&GUPROCP(1)' EQ 'Y').GEN\n         MEXIT ,                   CPD not requested\n.GEN     ANOP\n&P       SETC  '&PFX'\n         AIF   ('&MF' EQ 'L').MFL\n         PUSH  PRINT                                             DSACPD\n         PRINT ON,GEN                                            DSACPD\n*----------------------------------------------------------------------\n*  CPD - Task Persistent Data header - based SX@CPD\n*----------------------------------------------------------------------\n&P       IM#SECT &SECT\n&LABEL   IM#SECT LABEL            conditional label\n&P.ID    DS    CL8                CSECT owning CPD\n&P.L     DS    H                  32K max - CPD length\n&P.ESTAE UESTAE MF=CPD,PFX=&P     U370STAE support fields\n&P.BASE  DS    0D                 user's CPD fields follow\nL$&P.ES  EQU   *-&P.ESTAE         length of CPD ESTAE fields\nL$&P.PFX EQU   *-&P               length of CPD prefix\n&P.USER  DS    0D                 user's CPD fields\n         AIF   ('&GUPROCP(2)' EQ '').NOUSER\n         AIF   ('&GUPROCP(2)' EQ '0').NOUSER\n         DS    XL(&GUPROCP(2))    user's CPD additions\n.NOUSER  ANOP\n&P.USERX DS    0D                 end of user's CPD fields\nL$&P.USR EQU   *-&P.USER          length of user CPD fields (align'd)\n*\nL$&P     EQU   *-&P               length of CPD\n         POP   PRINT                                             DSACPD\n         MEXIT\n.*\n.MFL     ANOP\n&LABEL   DS    XL(L$CPDPFX)       CPD prefix                     DSACPD\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DSAEX": {"ttr": 4880, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00<\\x00<\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 60, "newlines": 60, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n         DSAEX ,\n         GBLB  &GDSAEX\n.*\n.* Copyright 2002 James M. Morrison\n.*\n         AIF   (&GDSAEX).MEX\n&GDSAEX  SETB  1                   only generate once\n         PUSH  PRINT                                              DSAEX\n*----------------------------------------------------------------------\n*  Savearea - prefix (sometimes referred to as SX)\n*----------------------------------------------------------------------\nSX       DSECT ,\nSXID     DS    CL8                 CSECT owning SX\nSXLSA    DS    H                   32K max: length of SA only\nSXLDSA   DS    H                   32K max: length of SX+SA (DSA)\nSX@CPD   DS    A                   0 or @ CSECT's CPD (DSACPD)\nSXAP00   DS    2F                  U370AP00 support for UPROC\nSX@INIT  DS    A                   @ custom DSA init routine\n         DS    F                   spare\n         DS    0D                  align SXBASE on doubleword boundary\n*                                  so user's doublewords align OK\nL$SXPFX  EQU   *-SX                length of SX prefix\n*----------------------------------------------------------------------\n*  Savearea - basic section (sometimes referred to as SA)\n*----------------------------------------------------------------------\nSXBASE   DS    0D                  after UPROC, R13 points here\nSXVER    DS    A     +00 +00       @ verification string = TGDSAVER\nSX@BACK  DS    A     +04 +04       @ previous SXBASE\nSX@FWD   DS    A     +08 +08       0 or @ next SXBASE\nSXR14    DS    F     +0C +12       R14\nSXR15    DS    F     +10 +16       R15\nSXR0     DS    F     +14 +20       R0\nSXR1     DS    F     +18 +24       R1\nSXR2     DS    F                   R2\nSXR3     DS    F                   R3\nSXR4     DS    F                   R4\nSXR5     DS    F                   R5\nSXR6     DS    F                   R6\nSXR7     DS    F                   R7\nSXR8     DS    F                   R8\nSXR9     DS    F                   R9\nSXR10    DS    F                   R10\nSXR11    DS    F                   R11\nSXR12    DS    F                   R12\n*\n*  Remainder of CSECT's SA data follows\n*\nL$SXNP   EQU   *-SXBASE            length of SA header w/o prefix\nL$SX     EQU   *-SX                length of SA header (total)\n*\n         U#EQU ,                   common EQUates\n         POP   PRINT                                              DSAEX\n.MEX     MEXIT ,\n.DOC     ANOP  ,\n.*---------------------------------------------------------------------\n.*  DSAEX describes the extended savearea used by UPROC, UPEND, and\n.*  U370STAE.  Further details in UPROC.\n.*---------------------------------------------------------------------\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DSCELL": {"ttr": 4882, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00>\\x00>\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 62, "newlines": 62, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n         DSCELL ,\n         GBLB  &GDSCELL\n.*\n.* Copyright 2002 James M. Morrison\n.*\n         AIF   (&GDSCELL).MEX\n&GDSCELL SETB  1                   only generate once\n         PUSH  PRINT                                             DSCELL\n*----------------------------------------------------------------------\n*  CLA - Cell Anchor\n*----------------------------------------------------------------------\nCLA      DSECT ,\nCLAID    DS    CL4                 block id (varies)\nCLALOCK  DS    F                   0=free; else @ ASCB holding lock\nCLA@CLH  DS    A                   0 or @ 1st chunk (CLH)\nCLA#BPE  DS    F                   # bytes per entry (cell)\nCLA#EPC  DS    F                   # entries per chunk\nCLALV    DS    0F                  GETMAIN/FREEMAIN LV=\nCLASPID  DS    X                   subpool id of chunk(s)\nCLALCHUN DS    XL3                 length of chunk\n*\nCLAFLG1  DS    X                   flag byte\nCLA1DRN  EQU   128                 1=drained, no new cells allowed\nCLA1NFAB EQU   64                  0=extend when no free slots\n*                                  1=ABEND  when no free slots\n*\nCLA1XMAB EQU   32                  0=rc=12 when max chunks exceeded\n*                                  1=ABEND when max chunks exceeded\n*\nCLAKEY   DS    X                   storage key * 16 of chunk\n*                                  B'xxxx0000' bits 4-7=0\n*\nCLA#MXCH DS    XL2                 max # chunks permitted; 0=no limit\nCLAUSER  DS    XL4                 available to user\n         DS    0D\nL$CLA    EQU   *-CLA               length of cell anchor\n*----------------------------------------------------------------------\n*  CLH - Chunk header\n*----------------------------------------------------------------------\nCLH      DSECT ,\nCLHID    DS    CL4                 block id (varies)\nCLH@NEXT DS    A                   0 or addr of next chunk\nCLHUSER  DS    XL12                available to user\nCLHBX@1  DS    A                   @ 1st cell in chunk\nCLHBXL   DS    F                   length of cell\nCLHBX@N  DS    A                   @ last byte of last cell\nCLHBXLE  EQU   CLHBX@1,12          BXLE regs\n         DS    0D\nL$CLH    EQU   *-CLH               length of chunk header\n         POP   PRINT                                             DSCELL\n.MEX     MEXIT ,\n.DOC     ANOP  ,\n.*---------------------------------------------------------------------\n.*  CLA, CLH - Generic description of the Cell data areas\n.*  Cell content varies depending on type of list\n.*  Areas marked 'available to user' vary depending on application\n.*\n.*  Example cell definitions:\n.*  DSTPE    - TCP/IP Ports Entry\n.*---------------------------------------------------------------------\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DSSSGD": {"ttr": 5121, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00-\\x00-\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   DSSSGD &SECT=DSECT,&PFX=SGD\n.*\n.* Copyright 2002 James M. Morrison\n.*\n         LCLC  &P\n&P       SETC  '&PFX'\n.*\n         AIF   ('&SECT' NE 'DSECT').LAB\n&P       DSECT ,                   Subsystem Global Data\n         AGO   .GEN\n.LAB     ANOP  ,\n&P       DS    0D                  SGD PFX=\n&LABEL   IM#SECT &SECT             conditional label\n.GEN     ANOP  ,\n&P.ID    DS    CL3                 C'SGD'\n&P.FLG1  DS    X                   status flags\n*\n&P.@XGD  DS    A        xgd.h      @ MVS-Xinu XGD\n*\n&P.@SQH  DS    A        DSSSQH     @ SQH - Subsys Queue Headers\n*\n&P.LCSA1 DS    F                   0 or subpool & len - SGD, SQH, SSVT\n&P.@SSFN DS    A                   @ gotten CSA for function code\n&P.LSSFN DS    F                   0 or subpool & len - ss func code\n&P.@SVC  DS    A                   @ gotten CSA for SVC\n&P.LSVC  DS    F                   0 or subpool & len - SVC\n*\n         DS    0D                  align STCP#OPT\n&P.OPTS  STCP#OPT PFX=&P,ID=SGD    TCP/IP options\n         DS    2D                  spare\n*\n*  Currently uninitialized fields - reserved\n*\n&P.@ASCB DS    A        IHAASCB    @ ASCB of TCP/IP subsys; 0 = gone\n&P.@SQXE DS    A        IHAECB     @ xmem ECB for scan queues task\n         DS    0D\nL$&P     EQU   *-&P                SGD length\n.MEX     MEXIT ,\n.DOC     ANOP  ,\n.*---------------------------------------------------------------------\n.*  DSSSGD - TCP/IP Subsystem Global Data\n.*  Describes data area pointed to by TCP/IP subsys SSCTSUSE field\n.*---------------------------------------------------------------------\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DSSSQH": {"ttr": 5123, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00.\\x00.\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   DSSSQH &SECT=DSECT,&PFX=SQH\n.*\n.* Copyright 2002 James M. Morrison\n.*\n         LCLC  &P\n&P       SETC  '&PFX'\n.*\n         AIF   ('&SECT' NE 'DSECT').LAB\n&P       DSECT ,                   Subsystem Global Data\n         AGO   .GEN\n.LAB     ANOP  ,\n&P       DS    0D                  SQH PFX=\n&LABEL   IM#SECT &SECT             conditional label\n.GEN     ANOP  ,\n&P.ID    DS    CL3                 C'SQH'\n&P.FLG1  DS    X                   status flags\n&P.1DRN  EQU   128                 subsystem draining\n         DS    A                   reserved for zap\n*\n*  SEND\n*\n&P.@SCLK DS    D                   STCK - last POST\n&P.@SEND DS    A                   @ queue; 0 = none\n&P.SLIM  DS    F                   max # elements allowed before SLEEP\n&P.SCUR  DS    F                   # elements queued\n&P.@SLOK DS    F                   queue lockword; 0 = free else locked\n*\n*  RECV\n*\n&P.@RCLK DS    D                   RECV routine STCK - last POST\n&P.@RECV DS    A                   @ queue; 0 = none\n&P.RLIM  DS    F                   max # elements allowed before SLEEP\n&P.RCUR  DS    F                   # elements queued\n&P.@RLOK DS    F                   queue lockword; 0 = free else locked\n*\n         DS    2D                  spare\n         DS    0D\nL$&P     EQU   *-&P                SQH length\n.MEX     MEXIT ,\n.DOC     ANOP  ,\n.*---------------------------------------------------------------------\n.*  DSSSQH - TCP/IP Subsystem Queue Headers\n.*  Describes queue headers pointed to by SGD@SQH\n.*---------------------------------------------------------------------\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DSSSVT": {"ttr": 5125, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00H\\x00H\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 72, "newlines": 72, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n         DSSSVT &SECT=DSECT,&PFX=SVT,                                  +\n               &TQRY=0,&TPALC=0,&TPFRE=0,&SNEOT=0,&TSEND=0,&TRECV=0,   +\n               &SNEOM=0,&SNWTO=0,&SNOPR=0,                             +\n               &TFC13=0,&TFC14=0,&TFC15=0,&TFC16=0\n.*\n.* Copyright 2002 James M. Morrison\n.*\n         LCLC  &P\n&P       SETC  '&PFX'\n.*\n&P       IM#SECT &SECT             Subsystem Vector Table\n&P.RESV  DC    AL2(0)              reserved\n&P.FNUM  DC    AL2(16)             # function codes supported\n*\n*  Function codes marked 'BROADCAST' below are subject to\n*  master subsystem broadcasts for the related function\n*\n&P.MT01  DC    AL1(1)              TCP/IP - query\n&P.MT02  DC    AL1(2)              TCP/IP - alloc port/protocol\n&P.MT03  DC    AL1(3)              TCP/IP - free  port/protocol\n&P.MS04  DC    AL1(0)  BROADCAST   MVS    - notify end-of-task\n&P.MT05  DC    AL1(5)              TCP/IP - send packets\n&P.MT06  DC    AL1(6)              TCP/IP - receive packets\n&P.MT07  DC    AL1(7)              TCP/IP - reserved\n&P.MS08  DC    AL1(0)  BROADCAST   MVS    - notify end-of-memory\n&P.MS09  DC    AL1(0)  BROADCAST   MVS    - notify WTO\n&P.MS10  DC    AL1(0)  BROADCAST   MVS    - notify operator command\n&P.MT11  DC    AL1(11)             TCP/IP - reserved\n&P.MT12  DC    AL1(12)             TCP/IP - reserved\n&P.MT13  DC    AL1(13)             TCP/IP - development\n&P.MT14  DC    AL1(0)  BROADCAST   MVS    - notify DOM\n&P.MT15  DC    AL1(15)             TCP/IP - development\n&P.MT16  DC    AL1(16)             TCP/IP - development\n&P.MLAST DC    (256-(*-&P.MT01))AL1(0)\n&P.MXXX  EQU   *\n*\n&P.$TOP  DS    0F                  top of list\n&P.TQRY  DC    A(&TQRY)      01    TCP/IP - query\n&P.TPALC DC    A(&TPALC)     02    TCP/IP - alloc port\n&P.TPFRE DC    A(&TPFRE)     03    TCP/IP - free  port\n&P.SNEOT DC    A(&SNEOT)     04    MVS    - notify EOT\n&P.TSEND DC    A(&TSEND)     05    TCP/IP - send packets\n&P.TRECV DC    A(&TRECV)     06    TCP/IP - receive packets\n&P.TFC07 DC    A(0)          07    TCP/IP - available\n&P.SNEOM DC    A(&SNEOM)     08    MVS    - notify EOM\n&P.SNWTO DC    A(&SNWTO)     09    MVS    - notify WTO\n&P.SNOPR DC    A(&SNOPR)     10    MVS    - notify opr cmd\n&P.TFC11 DC    A(0)          11    TCP/IP - available\n&P.TFC12 DC    A(0)          12    TCP/IP - available\n&P.TFC13 DC    A(&TFC13)     13    TCP/IP - development\n&P.TFC14 DC    A(0)          14    MVS    - notify DOM\n&P.TFC15 DC    A(&TFC15)     15    TCP/IP - development\n&P.TFC16 DC    A(&TFC16)     16    TCP/IP - development\n         ORG   &P.$TOP\n         DS    XL(STCP#SSF*4)      maximum function pointers\n         ORG   ,\n&P.$BOT  EQU   *-1                 bottom of list\n         DS    D                   spare\n&P.STUB  DS    0D                  stub for missing code follows\nL$&P     EQU   *-&P                SVT length\n.MEX     MEXIT ,\n.DOC     ANOP  ,\n.*---------------------------------------------------------------------\n.*  DSSSVT - TCP/IP Subsystem Vector Table\n.*  Describes subsystem's SSVT\n.*  Identifies functions codes subsystem supports & the address\n.*  of the routine that supports the function\n.*  Resides:  CSA\n.*  Created:  STCPSS00\n.*---------------------------------------------------------------------\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DSTPE": {"ttr": 5128, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00$\\x00$\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n         DSTPE ,\n.*\n.* Copyright 2002 James M. Morrison\n.*\n         PUSH  PRINT                                              DSTPE\n*----------------------------------------------------------------------\n*  TPE - TCP/IP Ports Entry (DSCELL cell)\n*----------------------------------------------------------------------\nTPE      DSECT ,\nTPE@ASCB DS    A                   0=free; else @ owner ASCB\n*\n*                                  /usr/include/linux/socket.h\nTPEFAM   DS    X                   supported address family\nTPEFINET EQU   2                   AF_INET\n*\n*                                  /usr/include/netinet/in.h\nTPECOL   DS    X                   supported protocols RFC-1700\nTPECICMP EQU   1                   ICMP RFC-792\nTPECTCP  EQU   6                   TCP  RFC-793\nTPECUDP  EQU   17                  UDP  RFC-768\n*\n*                                  /usr/include/netinet/in.h\n*                                  IANA assigned #s 0-1023\nTPEPORT  DS    XL2                 port number 0-65535 RFC-1700\n         DS    0D\nL$TPE    EQU   *-TPE               length of TPE\n         POP   PRINT                                              DSTPE\n.MEX     MEXIT ,\n.DOC     ANOP  ,\n.*---------------------------------------------------------------------\n.*  TPE - Describes Protocol/Port allocation to user address space\n.*        Path names describe Linux C language headers, provided for\n.*        ease of reference\n.*---------------------------------------------------------------------\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DSWIB": {"ttr": 5130, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00?\\x00?\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 63, "newlines": 63, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   DSWIB  &SECT=DSECT,&PFX=WIB\n.*\n.* Copyright 2002 James M. Morrison\n.*\n         LCLC  &P\n&P       SETC  '&PFX'\n.*\n         AIF   ('&SECT' NE 'DSECT').LAB\n         EJECT ,\n#WUD     EQU   5                   # WUDs in WIB\n#WEE     EQU   #WUD                # WEEs in WIB\n*\nWEE      DSECT ,                   WIB ECB Element (main task ECBLIST)\nWEE@EOT  DS    A                   @ WUD End Of Task ECB\nWEE$LAST EQU   128                 hi bit on = last in list\nL$WEE    EQU   *-WEE               length of WTE\n*\n&P       DSECT ,                   Work Information Block\n         AGO   .GEN\n.LAB     ANOP  ,\n&P       DS    0D                  WIB PFX=\n&LABEL   IM#SECT &SECT             conditional label\n.GEN     ANOP  ,\n&P.ID    DS    CL3                 C'WIB'\n&P.FLG1  DS    X                   status flags\n&P.1RRR  EQU   1                   TSKM ESTAE established\n*\n&P.@TCB  DS    A                   @ TCB that initialized WIB\n         DS    A\n         DS    A                   spare\n&P.WUDID DS    C'WUDL'\n&P.WUDBX DS    3F                  BXLE regs - WUD list\n&P.WEEID DS    C'WEEL'\n&P.WEEBX DS    3F                  BXLE regs - WEE list\n         DS    0D\nL$&P.PFX EQU   *-&P                length of WIB prefix\n*\n&P.WUD1  DS    (#WUD)XL(L$WUD)     WUDs\n&P.WUDX  EQU   *-1\n*\n         DS    4F                  spare\n*\n         DS    0D                  main task ECB list\n&P.WEE1  DS    (#WEE)XL(L$WEE)     WEEs\n&P.WEEX  EQU   *-1\nL$&P     EQU   *-&P                WIB length\n.MEX     MEXIT ,\n.DOC     ANOP  ,\n.*---------------------------------------------------------------------\n.*  DSWIB - WUD Information Block\n.*  Describes header to STCPTSKM's TPU in main task\n.*\n.*  WTE   - WIB Task Element\n.*  Describes one TCB's worth of info\n.*\n.*  WEE   - WIB ECB Element\n.*  Element of WIB ECB list\n.*\n.*  Access rules:\n.*\n.*---------------------------------------------------------------------\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DSWUD": {"ttr": 5132, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x007\\x007\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 55, "newlines": 55, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   DSWUD  &SECT=DSECT,&PFX=WUD\n.*\n.* Copyright 2002 James M. Morrison\n.*\n         LCLC  &P\n&P       SETC  '&PFX'\n.*\n         AIF   ('&SECT' NE 'DSECT').LAB\n         EJECT ,\n&P       DSECT ,             TCP/IP Subsys Work Unit Descriptor\n         AGO   .GEN\n.LAB     DS    0D            align\n&LABEL   IM#SECT &SECT       conditional label\n.GEN     ANOP  ,\n&P.ID    DS    CL3           C'WUD' after TSKM NEW\n*\n&P.FLG1  DS    X             status flags\n&P.1STRT EQU   128           WUD starting - TSKM START\n&P.1ACT  EQU   16            WUD active (running)\n&P.1MOD  EQU   8             user settable: attach module (not CSECT)\n&P.1RSTS EQU   4             user settable: restart subtask as needed\n*\n&P.@TCB  DS    A             @ TCB associated w/ WUD (LOCKWORD)\n&P.@AGD  DS    A             @ TGD for main task = Appl Global Data\n&P.@WIB  DS    A             @ WIB\n*\n&P.RUN   DS    F             ECB - TSKM RUN - work waiting/shutdown\n&P.EOT   DS    F             ECB - TSKM MON - End Of Task\n&P.NEW   DS    F             ECB - TSKM START/NEW\n&P.@ECBL DS    A             TSKM RUN @ ECBLIST (WUD@CODE may reset)\n*\n&P.@1ECB DS    A             TSKM RUN ECBLIST  (see 'TSKM RUN note')\n&P.@2ECB DS    A             TSKM external ECB (see 'TSKM ADD note')\n&P.NAME  DS    CL8           CSECT name of WUD@CODE\n&P.MODNM EQU   &P.NAME       module name to ATTACh\n*\n&P.@CODE DS    A             @ CSECT to handle WUD's work\n&P.WORD  DS    F             word for WUD creator\n&P.LOGD  DS    CL8           U370LOG ddname\n*\n&P.USR1  DS    A             available to WUD@CODE CSECT\n&P.USR2  DS    A             available to WUD@CODE CSECT\n&P.USR3  DS    A             available to WUD@CODE CSECT\n&P.USR4  DS    A             available to WUD@CODE CSECT\n&P.SCR   EQU   &P.USR1,16    available to WUD@CODE CSECT\n         DS    0D\n         AIF   ('&SECT' NE 'DSECT').MEX\nL$&P     EQU   *-&P          length of WUD\n.MEX     MEXIT ,\n.DOC     ANOP  ,\n.*---------------------------------------------------------------------\n.*  DSWUD describes a unit of work to be managed by STCPMGR\n.*---------------------------------------------------------------------\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DVADRBUF": {"ttr": 5134, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n         DVADRBUF &PFX=BUF\n.*\n.*  Copyright 2002, James M. Morrison\n.*\n         LCLC  &P\n&P       SETC  '&PFX'\n.*\n&P.AREA  DS    CL8\n         DS    C' '\n&P.MOD   DS    CL8                     module name\n&P.DOT1  DS    C'.'\n&P.CSECT DS    CL8                     CSECT name\n&P.DOT2  DS    C'.'\n&P.OFF   DS    CL8\n&P.MCO   EQU   &P.MOD,26               MODULE.CSECT.OFFSET\n&P.@BEG  EQU   &P.CSECT,8              @ area start\n&P.DASH  EQU   &P.DOT2,1\n&P.@END  EQU   &P.OFF,8                @ area end\n         ORG   &P.AREA\n         DS    XL(L$VADRBF)            make sure there's enough room\n         ORG   ,\n         MEXIT ,\n.DOC     ANOP\n.*---------------------------------------------------------------------\n.*  DVADRBUF - describes output buffer produced by U370VADR\n.*---------------------------------------------------------------------\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DXCOPYR1": {"ttr": 5136, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00@\\x00@\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 64, "newlines": 64, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n         DXCOPYR1 &BDW=NO,&RDW=NO\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n.* See MVS38j IEBLDUL source for COPYR1 definition (PL/S).\n.*\n*----------------------------------------------------------------------\n*  IEBCOPY unloaded dataset; COPYR1 record\n*----------------------------------------------------------------------\nCOPYR1   DSECT ,                       WORD aligned\n         AIF   ('&BDW' EQ 'NO').NOBDW\nXC1BDW   DS    XL4                 block descriptor word\n.NOBDW   AIF   ('&RDW' EQ 'NO').NORDW\nXC1RDW   DS    XL4                 record descriptor word\n.NORDW   ANOP\n*\nXC1INDC  DS    XL1                 flags\nXC1IFMT  EQU   X'C0'               unload info mask\nXC1IUERR EQU   X'80'               unload error\nXC1IFOLD EQU   X'00'               unload format=old\nXC1IFPDE EQU   X'40'               unload format=PDS/E\nXC1IFXFR EQU   X'C0'               unload format=transfer\nXC1IFPGM EQU   X'10'               contains program\nXC1IFCPE EQU   X'01'               contains PDS/E\n*\nXC1ID    DS    XL3                 header id x'CA6D0F'\nXC1DSORG DS    XL2                 DSORG\nXC1BLKSZ DS    XL2                 BLKSIZE\nXC1LRECL DS    XL2                 LRECL\nXC1RECFM DS    XL1                 RECFM\nXC1KEYLN DS    XL1                 KEY length\nXC1OPTCD DS    XL1                 OPTCD\nXC1SMSFG DS    XL1                 reserved in MVS38j\nXC1TBLKS DS    XL2                 unloaded blksize\n*\n*  Devicetype info\n*\nXC1DEVT  DS    0XL20\nXC1UCBT  DS    XL4                 UCB.UCBTYP\nXC1UMBLK DS    XL4                 unit max blksize\nXC1UCYLS DS    XL2                 unit # cyls\nXC1UHEAD DS    XL2                 unit # trks/cyl\nXC1UTRKL DS    XL2                 unit track length\nXC1UBOVH DS    XL2                 unit block overhead\nXC1UKOVH DS    XL1                 unit keyed blk ovhd\nXC1UFLGS DS    XL1                 flags\nXC1UTOLF DS    XL2                 unit tolerance factor\n*\n*  Following fields reserved in MVS38j\n*\nXC138RSV DS    0XL16\nL$XC138  EQU   (*+16)-COPYR1\nXC1HDRCT DS    XL2                 header count; when 0, =2.\nXC1RESV1 DS    XL1                 reserved\nXC1LREFD DS    XL3                 last referenced date\nXC1SCEXT DS    XL3                 secondary extent\nXC1SCALO DS    XL4                 secondary allocation\nXC1LSTAR DS    XL3                 last used trk/rec\nXC1TRBAL DS    XL2                 track balance\n*\nXC1RESV2 DS    XL2                 reserved post-MVS38j\nL$XC1CUR EQU   *-COPYR1            currently known length\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DXSEG": {"ttr": 5138, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00_\\x00_\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 95, "newlines": 95, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n         DXSEG &SECT=DSECT\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n*----------------------------------------------------------------------\n*  XMIT segment\n*----------------------------------------------------------------------\nXMITSEG  IM#SECT &SECT                 XMIT SEGment\nSEG      DS    0XL255                  maximum segment length\nSEGL     DS    X                       length of segment (2 -255),\n*                                      including L'XPSEGL & L'XPSEGFLG\nSEGFLG   DS    X                       flag byte\nSEG$1    EQU   128                     first segment of original rec\nSEG$L    EQU   64                      last segment of original rec\nSEG$C    EQU   32                      (part of) control segment\nSEG$R    EQU   16                      rec # of next record\nSEG$XX   EQU   15                      reserved bits = 0\n*\nSEGBUF   DS    XL253                   maximum segment user data\n*\n*  Offsets for control segments\n*\nSEGCTLNM EQU   SEGBUF,6                c'INMR0x'\nSEGCKEYS EQU   SEGBUF+6                INMR0x beginning of keys\nSEGC2NUM EQU   SEGBUF+6,4              INMR02 # files\nSEGC2KEY EQU   SEGBUF+10               INMR02 keys begin here\n*\nSEGBND   EQU   *                       past end of segment data\n*\n*  Keys for network user identification (INMR01)\n*\nINMTNODE EQU   X'1001'       target node name\nINMTUID  EQU   X'1002'       target userid\nINMFNODE EQU   X'1011'       origin node name\nINMFUID  EQU   X'1012'       origin userid\nINMFVERS EQU   X'1023'       origin version number\nINMFTIME EQU   X'1024'       origin time stamp\nINMTTIME EQU   X'1025'       destination time stamp\nINMNUMF  EQU   X'102F'       number of files\n*\n* Keys for general use\n*\nINMFACK  EQU   X'1026'       acknowledgement request\nINMERRCD EQU   X'1027'       receive error code\nINMUTILN EQU   X'1028'       utility name\nINMUSERP EQU   X'1029'       user parm string\nINMRECCT EQU   X'102A'       transmitted record count\n*\n*  Keys for dataset specification\n*\nINMDDNAM EQU   X'0001'       DDNAME\nINMDSNAM EQU   X'0002'       DSN\nINMMEMBR EQU   X'0003'       member name\nINMSECND EQU   X'000B'       secondary space qty\nINMDIR   EQU   X'000C'       directory space qty\nINMEXPDT EQU   X'0022'       expiration date\nINMTERM  EQU   X'0028'       terminal alloc (msg)\nINMBLKSZ EQU   X'0030'       blocksize\nINMDSORG EQU   X'003C'       dsorg\nINMLRECL EQU   X'0042'       lrecl of physical segment records\nINMRECFM EQU   X'0049'       recfm\nINMLREF  EQU   X'1020'       last ref date\nINMLCHG  EQU   X'1021'       last chg date\nINMCREAT EQU   X'1022'       create date\nINMSIZE  EQU   X'102C'       primary space qty\nINMTYPE  EQU   X'8012'       data set type\n*\n*  I'm not sure about the spelling of the next field, so I specify both\n*\nINMFFM   EQU   X'102D'       Filemode number (CMS)\nINMFM    EQU   X'102D'       Filemode number (CMS)\n*\nL$SEG    EQU   *-XMITSEG     L'XMITSEG\n*\nL$CKEY   EQU   2                       length of control seg key\nL$CCOUNT EQU   2                       length of control seg count\nL$CLEN   EQU   2                       length of control seg length\n.*\n.*  Format of key data:\n.*\n.*  KEY     XL2   as above\n.*  LENGTH  XL2   length of following data\n.*  BINDATA XLn\n.*\n.*  KEY     XL2   as above\n.*  LENGTH  XL2   length of following data (flag, as in terminal alloc)\n.*\n.*  KEY     XL2      Dataset type field, dsname\n.*  COUNT   XL2\n.*  LENGTH  XL2\n.*  DATA    XLn\n.*  LENGTH  XL2\n.*  DATA    XL2, etc.\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IHADECB": {"ttr": 5377, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x01\\x85\\x01\\x85\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 389, "newlines": 389, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n         IHADECB &DSECT=YES\n         AIF   ('&DSECT' EQ 'NO').NODSCT\nDECB     DSECT , -            DECBPTR\n         AGO   .CONT\n.NODSCT  ANOP\n         DS    0D\nDECB     EQU   * -            DECBPTR\n.CONT    ANOP  ,  */\n*%DECBL1 : ;\n*\n*/* **************************************************************** */\n*/*            DATA EVENT CONTROL BLOCKS FOR -                       */\n*/*            BSAM, BISAM, BDAM, QTAM, BTAM                         */\n*/*                                                                  */\n*/*  OS/VS2 RELEASE 3, OS/VS1 RELEASE 4, 08/30/74, LEVEL=1           */\n*/*                                                                  */\n*/*  METHOD OF ACCESS                                                */\n*/*      BAL  - DSECT IS PRODUCED UNLESS DSECT=NO IS SPECIFIED.      */\n*/*             USING ON DECB GIVES ADDRESSABILITY FOR ALL SYMBOLS.  */\n*/*      PL/S - DCL DECBPT PTR                                       */\n*/* **************************************************************** */\n*%GOTO DECBL2;  /*\n         SPACE 1\n         IEZBITS , -          SYMBOLIC BIT DEFINITIONS\n         SPACE 1\n***********************************************************************\n*              DATA EVENT CONTROL BLOCK FOR BSAM                      *\n***********************************************************************\n         SPACE 1\nDECSDECB DS    CL4 -          EVENT CONTROL BLOCK\nDECBPTR  DS    0A -           FOR IBM 1419 MAGNETIC CHARACTER READER\n*                             AND IBM 1275 OPTICAL READER SORTER, A\n*                             POINTER TO NEXT DECB TO BE TESTED FOR\n*                             COMPLETION BY THE CHECK MACRO\n*                             INSTRUCTION.  (DECB CHAINING APPLIES TO\n*                             THE USE OF MORE THAN ONE DEVICE.)  THIS\n*                             FIELD IN THE LAST DECB MUST BE ZERO.\nDECTYPE  DS    0BL2 -         TYPE OF I/O REQUEST\nDECTYPE1 DS    B -            TYPE OF LENGTH OPERAND\nDECLNS   EQU   BIT0 -         S CODED FOR LENGTH\nDECRSV01 EQU   BIT1,,C'X' -   RESERVED\nDECRSV02 EQU   BIT2,,C'X' -   RESERVED\nDECRSV03 EQU   BIT3,,C'X' -   RESERVED\nDECRSV04 EQU   BIT4,,C'X' -   RESERVED\nDECRSV05 EQU   BIT5,,C'X' -   RESERVED\nDECRSV06 EQU   BIT6,,C'X' -   RESERVED\nDECRSV07 EQU   BIT7,,C'X' -   RESERVED\nDECTYPE2 DS    B -            TYPE OF OPERATION\nDECRDSF  EQU   BIT0 -         READ SF\nDECRDSB  EQU   BIT1 -         READ SB\nDECWRSF  EQU   BIT2 -         WRITE SF\nDECWRSD  EQU   BIT3 -         WRITE SD\nDECRSV08 EQU   BIT4,,C'X' -   RESERVED\nDECWRSZ  EQU   BIT5 -         WRITE SZ\nDECRSV09 EQU   BIT6,,C'X' -   RESERVED\nDECWRSFR EQU   BIT7 -         WRITE SFR (BIT 2 IS ALSO ON) OR\n*                             READ RBL (BIT 0 IS ALSO ON)        MDC004\nDECLNGTH DS    H -            LENGTH OF KEY AND DATA\nDECDCBAD DS    A -            ADDRESS OF THE DCB TO WHICH THIS I/O\n*                             REQUEST IS RELATED\nDECAREA  DS    A -            ADDRESS OF KEY AND DATA, OR FOR 1287 OR\n*                             1288 OPTICAL READERS, THE ADDRESS OF A\n*                             USER-SPECIFIED CHANNEL PROGRAM\nDECIOBPT DS    A -            ADDRESS OF THE IOB\nDECNEXT  DS    0A -           SAME AS DECNEXTA BELOW\nDECRSV10 DS    X -            RESERVED\nDECNEXTA DS    AL3 -          ADDRESS OF THE NEXT ADDRESS FEEDBACK\n*                             FIELD.  PRESENT ONLY IF R IS CODED IN\n*                             THE WRITE MACRO.\n         SPACE 2\n         ORG   DECNEXT -      FOR 3886 ONLY, DEVICE DEPENDENT FIELDS\nDECBHDRA DS    A -            FOR READ RBL, ADDRESS OF 3886 DATA\n*                             HEADER RECORD AFTER READ           MDC001\nDECBLNNM DS    A -            FOR READ RBL, ADDRESS OF LINE NUMBER OR\n*                             NEGATIVE OF LINE NUMBER            MDC002\nDECBLFMT DS    A -            FOR READ RBL, ADDRESS OF LINE FORMAT\n*                             NUMBER OR NEGATIVE OF LINE FORMAT\n*                             NUMBER                             MDC003\n         SPACE 2\n***********************************************************************\n*              DATA EVENT CONTROL BLOCK FOR BISAM                     *\n***********************************************************************\n         SPACE 1\n         ORG   DECB\nDECBECB  DS    0CL4 -         EVENT CONTROL BLOCK\nDECBRB   DS    0A -           SAME AS DECBRBA BELOW\nDECBECBF DS    B -            FLAG FIELD\nDECBWAIT EQU   BIT0 -         AWAITING COMPLETION OF EVENT\nDECBPOST EQU   BIT1 -         EVENT HAS COMPLETED NORMALLY OR\n*                             ABNORMALLY.  IF THE EVENT COMPLETED\n*                             ABNORMALLY, FIELDS DECBEXC1 AND DECBEXC2\n*                             WILL SHOW THE REASON.\nDECRSV11 EQU   BIT2,,C'X' -   RESERVED\nDECRSV12 EQU   BIT3,,C'X' -   RESERVED\nDECRSV13 EQU   BIT4,,C'X' -   RESERVED\nDECRSV14 EQU   BIT5,,C'X' -   RESERVED\nDECRSV15 EQU   BIT6,,C'X' -   RESERVED\nDECRSV16 EQU   BIT7,,C'X' -   RESERVED\nDECBRBA  DS    AL3 -          ADDRESS OF THE RB FOR THE PROGRAM\n*                             AWAITING EVENT (BEFORE EVENT COMPLETION)\n*                             OR RESERVED (AFTER EVENT COMPLETION)\nDECBTYP1 DS    B -            OPTION BYTE\nDECRSV17 EQU   BIT0,,C'X' -   RESERVED\nDECRSV18 EQU   BIT1,,C'X' -   RESERVED\nDECRSV19 EQU   BIT2,,C'X' -   RESERVED\nDECRSV20 EQU   BIT3,,C'X' -   RESERVED\nDECRSV21 EQU   BIT4,,C'X' -   RESERVED\nDECRSV22 EQU   BIT5,,C'X' -   RESERVED\nDECBLNS  EQU   BIT6 -         LENGTH CODED AS 'S'\nDECBARS  EQU   BIT7 -         AREA CODED AS 'S'\nDECBTYP2 DS    B -            TYPE OF I/O REQUEST\nDECBRDK  EQU   BIT0 -         READ K\nDECRSV23 EQU   BIT1,,C'X' -   RESERVED\nDECBRDKU EQU   BIT2 -         READ KU\nDECRSV24 EQU   BIT3,,C'X' -   RESERVED\nDECBWRK  EQU   BIT4 -         WRITE K\nDECBWRKN EQU   BIT5 -         WRITE KN\nDECRSV25 EQU   BIT6,,C'X' -   RESERVED\nDECRSV26 EQU   BIT7,,C'X' -   RESERVED\nDECBLGTH DS    H -            NUMBER OF BYTES READ OR WRITTEN\nDECBDCBA DS    A -            ADDRESS OF THE DATA CONTROL BLOCK\nDECBAREA DS    A -            ADDRESS OF THE AREA IN STORAGE FOR THE\n*                             RECORD\nDECBLOGR DS    A -            ADDRESS OF THE LOGICAL RECORD\nDECBKEY  DS    A -            ADDRESS OF THE KEY PORTION OF THE RECORD\nDECBEXC1 DS    B -            EXCEPTIONAL CONDITION CODE BYTE 1\nDECEXRNF EQU   BIT0 -         RECORD NOT FOUND\nDECEXRLC EQU   BIT1 -         RECORD LENGTH CHECK\nDECEXNSP EQU   BIT2 -         SPACE NOT FOUND IN WHICH TO ADD A RECORD\nDECEXINV EQU   BIT3 -         INVALID REQUEST\nDECEXERR EQU   BIT4 -         UNCORRECTABLE I/O ERROR\nDECEXUBK EQU   BIT5 -         UNREACHABLE BLOCK\nDECEXOFL EQU   BIT6 -         OVERFLOW RECORD\nDECEXDUP EQU   BIT7 -         DUPLICATE RECORD PRESENTED FOR INCLUSION\n*                             IN THE DATA SET\nDECBEXC2 DS    B -            EXCEPTIONAL CONDITION CODE BYTE 2\nDECRSV27 EQU   BIT0,,C'X' -   RESERVED\nDECRSV28 EQU   BIT1,,C'X' -   RESERVED\nDECRSV29 EQU   BIT2,,C'X' -   RESERVED\nDECRSV30 EQU   BIT3,,C'X' -   RESERVED\nDECRSV31 EQU   BIT4,,C'X' -   RESERVED\nDECRSV32 EQU   BIT5,,C'X' -   RESERVED\nDECEXASR EQU   BIT6 -         EXECUTION OF THE LAST CHANNEL PROGRAM WAS\n*                             INSTITUTED BY AN ASYNCHRONOUS ROUTINE\nDECEXRKU EQU   BIT7 -         PREVIOUS MACRO INSTRUCTION WAS READ KU\n         SPACE 2\n***********************************************************************\n*              DATA EVENT CONTROL BLOCK FOR BDAM                      *\n***********************************************************************\n         SPACE 1\n         ORG   DECB\n         DS    0CL4 -         DECSDECB - EVENT CONTROL BLOCK\n         DS    B -            COMPLETION CODE BYTE 1\nDECCC2   DS    B -            COMPLETION CODE BYTE 2\nDECCCRNF EQU   BIT0 -         RECORD NOT FOUND\nDECCCRLC EQU   BIT1 -         RECORD LENGTH CHECK\nDECCCNSP EQU   BIT2 -         SPACE NOT FOUND\nDECCCINV EQU   BIT3 -         INVALID REQUEST.  (THIS CONDITION ALSO\n*                             SETS A BIT IN THE NEXT BYTE.)\nDECCCERR EQU   BIT4 -         UNCORRECTABLE I/O ERROR\nDECCCEOD EQU   BIT5 -         END OF DATA\nDECCCUER EQU   BIT6 -         UNCORRECTABLE ERROR OTHER THAN AN I/O\n*                             ERROR\nDECCCREX EQU   BIT7 -         A WRITE WITH EXCLUSIVE CONTROL WAS NOT\n*                             PRECEDED BY A READ WITH EXCLUSIVE CONTROL\n*                             (MDC300)                         @Z30AQ9A\nDECCC3   DS    B -            COMPLETION CODE BYTE 3\nDECRSV33 EQU   BIT0,,C'X' -   RESERVED\nDECCCWRI EQU   BIT1 -         A WRITE MACRO INSTRUCTION WAS ADDRESSED\n*                             TO AN INPUT DATA SET\nDECCCEXS EQU   BIT2 -         AN EXTENDED SEARCH WAS SPECIFIED WITH THE\n*                             DCBLIMCT FIELD SET TO ZERO\nDECCCNBK EQU   BIT3 -         THE BLOCK REQUESTED IS NOT WITHIN THE\n*                             DATA SET\nDECCCWDI EQU   BIT4 -         A WRITE-BY-IDENTIFICATION (DI) ADDRESSED\n*                             RECORD ZERO\nDECCCSDK EQU   BIT5 -         A SEARCH-ON-KEY (DK) WAS SPECIFIED WITH\n*                             THE DCBKEYLE FIELD SET TO ZERO OR WITHOUT\n*                             AN ADDRESS FOR THE KEY\nDECCCOPT EQU   BIT6 -         A MACRO INSTRUCTION USED AN OPTION NOT\n*                             SET IN THE DCB\nDECCCKFF EQU   BIT7 -         THE KEY FOR THE FIXED-LENGTH RECORD TO BE\n*                             ADDED BEGINS WITH X'FF'\nDECRSV34 DS    X -            RESERVED\n         DS    0BL2 -         DECTYPE - TYPE OF I/O REQUEST\n         DS    B -            DECTYPE1 - FIRST BYTE OF DECTYPE\nDECVERFY EQU   BIT0 -         VERIFY\nDECOFLOW EQU   BIT1 -         OVERFLOW\nDECEXSRC EQU   BIT2 -         EXTENDED SEARCH\nDECFDBCK EQU   BIT3 -         FEEDBACK\nDECACTAD EQU   BIT4 -         ACTUAL ADDRESSING\nDECDYNBF EQU   BIT5 -         DYNAMIC BUFFERING\nDECRDEX  EQU   BIT6 -         READ EXCLUSIVE\nDECRELBA EQU   BIT7 -         RELATIVE BLOCK ADDRESSING\n         DS    B -            DECTYPE2 - SECOND BYTE OF DECTYPE\nDECKEYS  EQU   BIT0 -         S CODED FOR KEY ADDRESS\nDECBKLNS EQU   BIT1 -         S CODED FOR BLOCK LENGTH\nDECTYPRU EQU   BIT2+BIT3 -    RU IS SUFFIXED TO THE TYPE, INDICATING\n*                             THAT THE FEEDBACK ADDRESS POINTED TO BY\n*                             DECNXADR CAN BE THE ADDRESS OF EITHER THE\n*                             NEXT DATA RECORD OR THE NEXT CAPACITY\n*                             RECORD, WHICHEVER OCCURS FIRST\nDECTYPR  EQU   BIT3 -         R IS SUFFIXED TO THE TYPE, INDICATING\n*                             THAT THE FEEDBACK ADDRESS POINTED TO BY\n*                             DECNXADR IS THE ADDRESS OF THE NEXT DATA\n*                             RECORD.  (BIT 2 IS ZERO)\nDECOPRD  EQU   BIT4 -         TYPE OF OPERATION - 0 IS WRITE, 1 IS READ\nDECSRKEY EQU   BIT5 -         TYPE OF SEARCH ARGUMENT - 0 IS ID,\n*                             1 IS KEY\nDECWRADD EQU   BIT6 -         ADD OPTION OF WRITE OPERATION\nDECRSV35 EQU   BIT7,,C'X' -   RESERVED\n         DS    H -            DECLNGTH - LENGTH OF DATA\n         DS    A -            DECDCBAD - ADDRESS OF DCB TO WHICH THIS\n*                             I/O REQUEST IS RELATED\n         DS    A -            DECAREA - ADDRESS OF THE DATA\n         DS    A -            DECIOBPT - ADDRESS OF THE IOB\nDECKYADR DS    A -            ADDRESS OF THE KEY\nDECRECPT DS    A -            ADDRESS OF THE BLOCK REFERENCE FIELD\nDECNA    DS    0A -           SAME AS DECNAA BELOW\nDECRSV36 DS    X -            RESERVED\nDECNAA   DS    AL3 -          ADDRESS OF THE NEXT ADDRESS FEEDBACK\n*                             FIELD.  PRESENT ONLY IF R OR RU IS CODED\n*                             IN THE READ MACRO.\n         SPACE 2\n***********************************************************************\n*              DATA EVENT CONTROL BLOCK FOR QTAM                      *\n***********************************************************************\n         SPACE 1\n         ORG   DECB\nLINEDECB DS    CL4 -          ALWAYS ZERO\nDECRSV37 DS    X -            RESERVED\nDECOPCOD DS    C -            OPERATION CODE FOR CURRENT SEGMENT\n         DS    H -            DECLNGTH - LENGTH OF INPUT AREA FOR\n*                             INITIAL READ\n         DS    A -            DECDCBAD - ADDRESS OF DCB\n         DS    A -            DECAREA - STARTING ADDRESS FOR DATA IN A\n*                             BUFFER\nDECRSV38 DS    XL4 -          RESERVED\nDECCPOL  DS    0A -           SAME AS DECCPOLA BELOW\nDECNMMSG DS    FL1 -          NUMBER OF MESSAGES RECEIVED\nDECCPOLA DS    AL3 -          ADDRESS OF CURRENTLY ACTIVE ENTRY IN\n*                             POLLING LIST\nDECRSV39 DS    X -            RESERVED\nDECUCBDX DS    FL1 -          INDEX TO UCB ADDRESS IN DEB\nDECRSV40 DS    XL2 -          RESERVED\nDECRSV41 DS    XL4 -          RESERVED\nDECADRCH DS    A -            ADDRESS OF ADDRESSING CHARACTERS IN\n*                             TERMINAL ENTRY\n         DS    0A -           DECPOLPT - ADDRESS OF POLLING LIST\nDECRSV42 DS    X -            RESERVED\n         DS    AL3 -          DECPOLPA - ADDRESS OF POLLING LIST\n         SPACE 2\n***********************************************************************\n*              DATA EVENT CONTROL BLOCK FOR BTAM                      *\n***********************************************************************\n         SPACE 1\n         ORG   DECB\n         DS    CL4 -          DECSDECB - EVENT CONTROL BLOCK\n         DS    0BL2 -         DECTYPE - PROGRAMMING INDICATORS\n         DS    B -            DECTYPE1 - FIRST BYTE OF DECTYPE\nDECRDAPL EQU   BIT0 -         READ, USING AUTOPOLL\nDECRSV43 EQU   BIT1,,C'X' -   RESERVED\nDECRSV44 EQU   BIT2,,C'X' -   RESERVED\nDECRSV45 EQU   BIT3,,C'X' -   RESERVED\nDECRSV46 EQU   BIT4,,C'X' -   RESERVED\nDECSTRME EQU   BIT5 -         'S' CODED FOR TERMINAL ENTRY\nDECSAREA EQU   BIT6 -         'S' CODED FOR AREA\nDECSLNTH EQU   BIT7 -         'S' CODED FOR LENGTH\n         DS    C -            DECTYPE2 - COMMAND CODE\n         DS    H -            DECLNGTH - LENGTH OF BUFFER OR MESSAGE\n*                             AREA\n         DS    0A -           DECDCBAD - ADDRESS OF ASSOCIATED DCB\nDECBUFCT DS    0FL1 -         CONTAINS A RUNNING COUNT OF BUFFERS\n*                             OBTAINED BY BTAM FOR THE CURRENT READ\n*                             OPERATION.  (DYNAMIC BUFFERING ONLY.)\n*                             USE DIFFERS DURING BSC AND 2760 ONLINE\n*                             TEST.\nDECONLTT DS    B -            FLAG BYTE FOR BSC AND 2760 ONLINE TEST\nDECONLTS EQU   BIT0 -         IF ZERO, ONLINE TEST REQUESTED BY RFT\n*                             MESSAGE (BSC).  IF ONE, ONLINE TEST\n*                             INITIATED BY ONLTST MACRO INSTRUCTION\n*                             (BSC).\nDECRCVMS EQU   BIT1 -         IF ZERO, SENDING TEST MESSAGES (BSC).\n*                             IF ONE, RECEIVING TEST MESSAGES (BSC) OR\n*                             TYPE 11 ONLINE TEST FOR 2760 OPTICAL\n*                             IMAGE UNIT.\nDECRSV47 EQU   BIT2,,C'X' -   RESERVED\nDECRSV48 EQU   BIT3,,C'X' -   RESERVED\nDECRSV49 EQU   BIT4,,C'X' -   RESERVED\nDECRSV50 EQU   BIT5,,C'X' -   RESERVED\nDECRSV51 EQU   BIT6,,C'X' -   RESERVED\nDECRSV52 EQU   BIT7,,C'X' -   RESERVED\nDECDCBAA DS    AL3 -          ADDRESS OF ASSOCIATED DCB\n         DS    A -            DECAREA - ADDRESS OF BUFFER OR MESSAGE\n*                             AREA\nDECSENS0 DS    B -            SENSE INFORMATION\nDECSENS1 DS    B -            RESERVED\nDECCOUNT DS    H -            RESIDUAL COUNT FROM CSW FOR LAST CCW\n*                             EXECUTED\nDECENTRY DS    0A -           ADDRESS OF THE TERMINAL LIST\nDECCMCOD DS    C -            COMMAND FOR WHICH THE ERROR OCCURRED\nDECENTRA DS    AL3 -          ADDRESS OF THE TERMINAL LIST\nDECFLAGS DS    B -            OPERATION STATUS\nDECWACK  EQU   BIT0+BIT1 -    WACK WAS RECEIVED (BSC)\nDECERRMS EQU   BIT0 -         ERROR STATUS MESSAGE WAS RECEIVED (BSC).\n*                             BIT 1 IS OFF.\nDECDIFAC EQU   BIT1 -         ACKNOWLEDGMENT OTHER THAN ACK-0 OR ACK-1\n*                             RECEIVED (BSC)\nDECALTAC EQU   BIT2 -         ACKNOWLEDGMENT ALTERNATION INCORRECT\nDECBADID EQU   BIT3 -         FOR TWX 33/35 STATION AND BSC STATION,\n*                             INCORRECT ID RECEIVED.  FOR AUTOPOLL,\n*                             INDEX BYTE RECEIVED DOES NOT MATCH AN\n*                             ACTIVE ONE.  FOR BSC NONSWITCHED\n*                             POINT-TO-POINT LINE, CONTENTION OCCURRED.\n*                             FOR WTTA, CONTENTION OCCURRED OR\n*                             INCORRECT ID RECEIVED.\nDECNOBUF EQU   BIT4 -         FOR READ, DYNAMIC BUFFERING, NO BUFFER\n*                             WAS AVAILABLE.  (MESSAGE LOST)\nDECNEGRP EQU   BIT5 -         FOR OPENLST, POLLING, NEGATIVE RESPONSE\n*                             TO POLLING RECEIVED.  FOR WRAPLST, ALL\n*                             ENTRIES ARE INACTIVE.  FOR ADDRESSING,\n*                             NEGATIVE RESPONSE TO ADDRESSING\n*                             RECEIVED.  FOR WTTA, LAST MESSAGE\n*                             RECEIVED ENDED WITH EOT OR TIME-OUT.\n*                             FOR 2741, POWER IS OFF OR OTHER\n*                             INTERVENTION REQUIRED CONDITION EXISTS.\nDECREVRS EQU   BIT6 -         FOR WTTA, MESSAGE ENDED WITH WRU SIGNAL.\n*                             FOR BSC STATIONS, REVERSE INTERRUPT (RVI)\n*                             SEQUENCE WAS RECEIVED (SEE ALSO BIT 1).\n*                             FOR 2741, WRITE OPERATION WAS ENDED BY\n*                             TERMINAL INTERRUPT.\nDECSSMSG EQU   BIT6 -         A 3270 REMOTE SENSE/STATUS MESSAGE WAS\n*                             RECEIVED IF THIS BIT IS ONE AND BIT 1\n*                             IS ZERO                            ICB479\nDECSTXNQ EQU   BIT7 -         FOR WTTA, CONTENTION CONDITION WAS\n*                             ENCOUNTERED.  FOR BSC STATIONS, STX ENQ\n*                             SEQUENCE WAS RECEIVED.\nDECRLN   DS    FL1 -          RELATIVE LINE NUMBER\nDECRESPN DS    CL2 -          FOR BSC OPERATIONS, RESPONSE FROM A\n*                             TERMINAL TO ADDRESSING.  FOR STOP-START\n*                             OPERATIONS, BYTE 1 IS RESPONSE FROM A\n*                             TERMINAL TO ADDRESSING AND BYTE 2 IS\n*                             VERTICAL REDUNDANCY CHARACTER AND\n*                             LONGITUDINAL REDUNDANCY CHARACTER\n*                             (VRC/LRC) RESPONSE.\nDECTPCOD DS    C -            TP OPERATION CODE\nDECERRST DS    B -            I/O ERROR STATUS FLAGS\nDECSIO3  EQU   BIT0 -         SIO RESULTED IN A CONDITION CODE OF 3\nDECUNDEF EQU   BIT1 -         UNDEFINED ERROR CONDITION\nDECERPER EQU   BIT2 -         AN ERROR CONDITION OCCURRED DURING AN I/O\n*                             OPERATION INITIATED BY ERROR RECOVERY\n*                             ROUTINES\nDECDIAGN EQU   BIT3 -         DIAGNOSTIC WRITE/READ OPERATION ENDED\n*                             BECAUSE OF ERROR (2701 ONLY)\nDECDSABL EQU   BIT4 -         DISABLE COMMAND ISSUED TO SWITCHED LINE\n*                             BY ERROR RECOVERY ROUTINE BECAUSE OF\n*                             PERMANENT ERROR ON THAT LINE\nDECRSV53 EQU   BIT5,,C'X' -   RESERVED\nDECRSV54 EQU   BIT6,,C'X' -   RESERVED\nDECRSV55 EQU   BIT7,,C'X' -   RESERVED\nDECCSWST DS    BL2 -          STATUS BITS FROM CSW FOR LAST CCW\n*                             EXECUTED\nDECADRPT DS    A -            ADDRESS OF ADDRESSING LIST ENTRY USED IN\n*                             PREVIOUS OPERATION\nDECPOLPT DS    0A -           SAME AS DECPOLPA BELOW\nDECNDXPL DS    FL1 -          FOR AUTOPOLL, INDEX TO CURRENT ENTRY IN\n*                             POLLING LIST\nDECPOLPA DS    AL3 -          FOR PROGRAMMED POLLING, ADDRESS OF THE\n*                             CURRENT ENTRY IN THE POLLING LIST.  FOR\n*                             AUTOPOLL, ADDRESS OF POLLING LIST.  FOR\n*                             BSC ON-LINE TEST, ADDRESS OF TEXT DATA.\n         SPACE 1\n*              BSC EXTENSION\n*        FIELDS ARE PRESENT ONLY IF A SUBLIST IS CODED FOR THE\n*        AREA AND LENGTH OPERANDS OF THE READ OR WRITE MACRO\n*        INSTRUCTION THAT DEFINES THE DECB.\n         SPACE 1\nDECRSV56 DS    XL2 -          RESERVED\nDECWLNG  DS    H -            LENGTH, IN BYTES, OF THE DATA AREA IN\n*                             LEADING-GRAPHICS AND CONVERSATIONAL TYPE\n*                             OPERATIONS OR OF THE AREA CONTAINING THE\n*                             TONE CHARACTERS IN READ CONNECT WITH TONE\n*                             (TCW) OPERATIONS\nDECWAREA DS    A -            ADDRESS OF THE DATA AREA IN\n*                             LEADING-GRAPHICS AND CONVERSATIONAL\n*                             OPERATIONS, OR OF THE AREA CONTAINING THE\n*                             TONE CHARACTERS IN READ TCW OPERATIONS\n         MEND  , */\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IHADQE": {"ttr": 5384, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00\\x14\\x00\\x14\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n         IHADQE   &TYPE\n*\n*        RELEASE 1 AOS, 11/3/71, LEVEL=1\n*\n         AIF   ('&TYPE' EQ 'INTERNAL').EQU\nDQESECT  DSECT      DESCRIPTOR QUEUE ELEMENT\nDQFQEPTR DS    A    PTR TO FIRST FREE AREA\nDQEPTR   DS    A    PTR TO NEXT DQE OR ZERO\nDQEHRID  DS    0C   HIERARCHY IDENTIFIER\nDQEBLKAD DS    A    ADDR FIRST 2K BLOCK DESCRIBED BY THIS DQE\nDQELNTH  DS    F    LENGTH OF AREA DESCRIBED BY THIS DQE\n         MEXIT\n.EQU     ANOP\nDQFQEPTR EQU      0    PTR TO FIRST FREE AREA\nDQEPTR   EQU      4    PTR TO NEXT DQE OR ZERO\nDQEHRID  EQU      4   HIERARCHY IDENTIFIER\nDQEBLKAD EQU      8    ADDR FIRST 2K BLOCK DESCRIBED BY THIS DQE\nDQELNTH  EQU      12    LENGTH OF AREA DESCRIBED BY THIS DQE\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IHADVCT": {"ttr": 5386, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00\\x8a\\x00\\x8a\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 138, "newlines": 138, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n         IHADVCT   &DSECT=YES\n.* /* START OF SPECIFICATIONS ****\n.*\n.*01  MODULE-NAME = IHADVCT\n.*\n.*01  COPYRIGHT = NONE\n.*\n.*01  STATUS = OS/VS2 RELEASE 2, LEVEL 0\n.*\n.*01  CHANGE-ACTIVITY = NONE\n.*\n.*01  DESCRIPTIVE-NAME = DEVICE CHARACTERISTICS TABLE MAPPING\n.*\n.*01  FUNCTION = THIS TABLE DESCRIBES PHYSICAL ATTRIBUTES OF EACH DASD\n.*    DEVICE WHICH HAS BEEN SYSGENED\n.*\n.*01  NOTES = THE TABLE IS POINTED TO BY CVTZDTAB.\n.*\n.*01  MODULE-TYPE = MACRO\n.*02    PROCESSOR = ASSEMBLER-370R\n.*\n.*02    MACRO-SIZE = 200 STATEMENTS\n.*\n.**** END OF SPECIFICATIONS ***/\n* /* MACCOMP Y-2 SC1D0/SJD48                                         */\n* /* MACSTAT Y-2 73226/021160                                        */\n*/********************************************************************/\n*/*                 DEVICE CHARACTERISTICS TABLE                     */\n*/********************************************************************/\n*/*                                                                  */\n*/*         THIS TABLE MAY BE USED TO FIND THE CHARACTERISTICS       */\n*/*         OF DIRECT ACCESS DEVICES.  THE APPLICABLE DEVICES ARE    */\n*/*         THOSE CONTAINING UCBDACC IN UCBTBYT3 (SEE IEFUCBOB).     */\n*/*                                                                  */\n*/*         NOTE: DEVTYPE MAY BE USED TO EXTRACT INFORMATION         */\n*/*         FROM THIS TABLE.  ITS OUTPUT AREA IS IN A SLIGHTLY       */\n*/*         DIFFERENT FORMAT, AND IS MAPPED BY IHADVA.               */\n*/*                                                                  */\n*/*         THE TABLE IS COMPOSED OF AN INDEX FOLLOWED BY ONE        */\n*/*         ENTRY FOR EACH DASD DEVICE WHICH HAS BEEN SYSGENED       */\n*/*                                                                  */\n*/*         FOR ASSEMBLER USE, TWO SEPARATE DSECTS ARE PROVIDED.     */\n*/*         A USING ON DVCTI GIVES ADDRESSIBILITY TO THE INDEX,      */\n*/*         AND A USING ON DVCT GIVES ADDRESSIBILITY TO AN ENTRY.    */\n*/*         SPECIFYING DSECT=NO SUPPRESSES THE INDEX AND PROVIDES    */\n*/*         AN ENTRY DESCRIPTION WITHOUT A DSECT STATEMENT           */\n*/*                                                                  */\n*/*         FOR PLS USE, TWO STRUCTURES ARE PROVIDED. THEIR STORAGE  */\n*/*         ATTRIBUTES ARE CONTROLLED BY SETTING STRING MACRO        */\n*/*         VARIABLES AS FOLLOWS:                                    */\n*/*         STRUCTURE  MACRO-VAR       DEFAULT SETTING               */\n*/*         DVCTI      %DVCIBASE  'BASED(CVTZDTAB)'                  */\n*/*         DVCT       %DVCTBASE  'BASED(CVTZDTAB                    */\n*/*                                +DVCTIOFF(UCBTYP&DVCTYPMK))'      */\n*/*                                                                  */\n*/*         THE DEFAULT SETTINGS WILL PROVIDE ADDRESSIBILITY TO      */\n*/*         ALL FIELDS, BUT DEPEND ON CVT AND UCB ADDRESSIBILITY.    */\n*/*                                                                  */\n*/*               FORMAT OF EACH ENTRY                               */\n*/*         _____________________________________________            */\n*/*   0(00) |                     |                     |            */\n*/*         |       DVCCYL        |       DVCTRK        |            */\n*/*         |_____________________|_____________________|            */\n*/*   4(04) |                     |       DVCOVHD       |            */\n*/*         |       DVCTRKLN      | DVCOVNLB | DVCOVLB  |            */\n*/*         |_____________________|__________|__________|            */\n*/*   8(08) |          |          |                     |            */\n*/*         | DVCOVNK  | DVCFLAGS |       DVCTOL        |            */\n*/*         |__________|__________|_____________________|            */\n*/*  12(0C) |                     |______________________            */\n*/*         |       DVCALT        |                     |            */\n*/*         |_____________________|       DVCOVR0       |  RPS       */\n*/*         ______________________|_____________________|  ONLY      */\n*/*  16(10) |          |          |                        SECTION   */\n*/*         | DVCSECT  | DVCSECTD |                                  */\n*/*         |__________|__________|                                  */\n*/********************************************************************/\n*%/*\n         AIF   ('&DSECT' EQ 'NO').NODSECT\nDVCTI    DSECT ,              INDEX TO DVCT\n*              THIS INDEX IS LOCATED FROM CVTZDTAB.\n*              THE PROPER ENTRY IS FOUND BY ADDING THE LOW ORDER\n*              4 BITS OF UCBTYP TO THE ADDRESS IN CVTZDTAB.\nDVCTYPMK EQU   X'0000000F'              TYPICAL USAGE:\n*              LA    RWRK,DVCTYPMK      MASK FOR UNIT TYPE NUMBER\n*              N     RWRK,UCBTYP        PICK UP UNIT TYPE NUMBER\n*              IC    RWRK,DVCTIOFF(RWRK)  PICK UP OFFSET\nDVCTIOFF DS    AL1                      OFFSET TO DVCT ENTRY\n***********************************************************************\n         SPACE 3\nDVCT     DSECT ,                        FORMAT OF DVCT ENTRY\n*              THE ENTRY IS LOCATED BY ADDING DVCTIOFF TO CVTZDTAB\n         AGO   .ENTRY\n.NODSECT ANOP\nDVCT     DS    0H                       FORMAT OF DVCT ENTRY\n.ENTRY   ANOP\n*\nDVCCYL   DS    H                        PHYS NO. CYL PER VOLUME\nDVCTRK   DS    H                        NO. TRACKS PER CYLINDER\nDVCTRKLN DS    H                        NO. OF BYTES PER TRACK\n*\nDVCOVHD  DS    0H                       BLOCK OVERHEAD IF DVC2BOV=1\n*              USE FOLLOWING TWO CONSTANTS IF DVC2BOV=0\nDVCOVNLB DS    XL1                      OVERHEAD NOT LAST BLOCK\nDVCOVLB  DS    XL1                      OVERHEAD LAST BLOCK\n*\nDVCOVNK  DS    XL1                      OVERHEAD DECREMENT NOT KEYED\n*\nDVCFLAGS DS    BL1\nDVC2BOV  EQU   X'08'                    IF 1, USE DVCOVHD\n*                                       IF 0, USE DVCOVNLB,DVCOVLB\nDVCFTOL  EQU   X'01'                    IF 1, APPLY TOLERANCE FACTOR\n*\nDVCTOL   DS    H                        TOLERANCE FACTOR\n*              APPLY TOLERANCE FACTOR AS FOLLOWS:\n*              1. ADD BLOCKSIZE AND KEYLENGTH\n*              2. MULTIPLY BY DVCTOL\n*              3. SHIFT RIGHT DVCTSHFT BITS\n*              4. ADD APPROPRIATE OVERHEADS\nDVCTSHFT EQU   9                        SHIFT AMT TO DIVIDE BY 512\n*\nDVCALT   DS    H                        NUMBER ALTERNATE TRKS/VOLUME\n*\nDVCENTLG EQU   *-DVCT                   BASIC SIZE OF DEVICE TABLE\n*                                       ENTRY, NOT INCLUDING ADD'L\n*                                       CHARACTERISTICS FOR RPS\n**********************************************************************\n*              THE FOLLOWING SECTION OF THE TABLE IS PRESENT         *\n*              ONLY FOR RPS DEVICES--TEST UCBTBYT2 FOR UCB2OPT3      *\n**********************************************************************\nDVCRPS   DS    0CL4                     RPS SECTION\nDVCOVR0  DS    H                        OVERHEAD BYTES FOR RECORD 0\nDVCSECT  DS    XL1                      NUMBER SECTORS IN FULL TRACK\nDVCSECTD DS    XL1                      NUMBER DATA SECTORS\n*\n*              END OF DVCT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IHAPQE": {"ttr": 5389, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00\"\\x00\"\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n         IHAPQE   &TYPE\n*\n*        RELEASE 1 AOS, 11/3/71, LEVEL=1\n*\n         AIF   ('&TYPE' EQ 'INTERNAL').EQU\nPQESECT  DSECT      PARTITION QUEUE ELEMENT\nPQEFFBQE DS    A    PTR TO FIRST FBQE OR IF NONE TO PQE\nPQEBFBQE DS    A    PTR TO LAST FBQE OR IF NONE, TO PQE\nPQEFPQE  DS    A    ADDR NEXT PQE OR ZERO\nPQEBPQE  DS    A    ADDR PREVIOUS PQE OR ZERO\nPQETCB   DS    A    ADDR TCB FOR JOB STEP TO WHICH SPACE BELONGS\nPQESIZE  DS    F    SIZE OF REGION DESCRIBED BY THIS PQE\nPQEREGN  DS    A    ADDR FIRST BYTE OF REGION DESCRIBED BY THIS PQE\nPQERFLGS DS    CL1  FLAG BYTE\nPQEHRID  DS    CL1  HIERARCHY IDENTIFIER\nVMMFLGS  DS    BL1  SEVEN HIGH ORDER BITS ZERO\nVVVRFLG  EQU   X'01' REAL OR VIRTUAL REGION FLAG\nPQERSVD  DS    CL1  RESERVED\n         MEXIT\n.EQU     ANOP\nPQEFFBQE EQU      0    PTR TO FIRST FBQE OR IF NONE TO PQE\nPQEBFBQE EQU      4    PTR TO LAST FBQE OR IF NONE, TO PQE\nPQEFPQE  EQU      8    ADDR NEXT PQE OR ZERO\nPQEBPQE  EQU      12    ADDR PREVIOUS PQE OR ZERO\nPQETCB   EQU      16    ADDR TCB FOR JOB STEP TO WHICH SPACE BELONGS\nPQESIZE  EQU      20    SIZE OF REGION DESCRIBED BY THIS PQE\nPQEREGN  EQU      24    ADDR FIRST BYTE OF REGION DESCRIBED BY THIS PQE\nPQERFLGS EQU      28  FLAG BYTE\nPQEHRID  EQU      29  HIERARCHY IDENTIFIER\nVMMFLGS  EQU      30  SEVEN HIGH ORDER BITS ZERO\nVVVRFLG  EQU   X'01' REAL OR VIRTUAL REGION FLAG\nPQERSVD  EQU      31  RESERVED\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IHARTCT": {"ttr": 5633, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x01\\xa1\\x01\\xa1\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 417, "newlines": 417, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n         IHARTCT\n.*A-000000-999999                   ** NEW DUMP KEYWORDS       @G33CPHZ\n.*                                     (INCOMPATIBLE OFFSETS   @G33CPHZ\n.*                                      ON FIELDS ONLY USED    @G33CPHZ\n.*                                      BY RTM DUMP ROUTINES   @G33CPHZ\n.*                                      AND COMMANDS)          @G33CPHZ\n*\n*/********************************************************************/\n*/*                                                                  */\n*/* MACRO NAME = RTCT OR RTMCT                                       */\n*/*                                                                  */\n*/* MICROFICHE NAME = IHARTCT                                        */\n*/*                                                                  */\n*/* DESCRIPTIVE NAME = RECOVERY/TERMINATION CONTROL TABLE            */\n*/*                                                                  */\n*/* STATUS = OS/VS2 RELEASE 3.7 PLUS SU 33       12/08/76    @G33VPHZ*/\n*/*                                                                  */\n*/* METHOD OF ACCESS =                                               */\n*/*   BAL  - DSECT IS ALWAYS PRODUCED.  USING ON RTCT GIVES          */\n*/*          ADDRESSABILITY FOR ALL SYMBOLS.  CVTRTMCT POINTS TO     */\n*/*          THE RTCT.                                               */\n*/*                                                                  */\n*/* SIZE = DECIMAL 344, X'158'                                       */\n*/* CHANGE ACTIVITY = OZ27434 - DEFINE RTCTSDFX USED TO PROHIBIT     */\n*/*                             ASYNCRONOUS INTERRUPTS WHILE SDUMP   */\n*/*                             HAS THE SYSTEM SET NONDISPATCHABLE.  */\n*/*                                                                  */\n*/********************************************************************/\n*\nRTCT     DSECT , -                BAL MAPPING OF TABLE\n.**********************************************************************\n.* KNOWN USERS OF THIS CONTROL BLOCK ARE:\n.*     RTM NIP RIM            - IEAVNPA6  (CREATES RTCT)\n.*     RTM1 MAINLINE          - IEAVTRTM\n.*     RTM RECORDING          - IEAVTRER, IEAVTRET\n.*     RTM MEMORY TERMINATION - IEAVTMRM, IEAVTMTC             @G33SPHW\n.*     RTM2 DUMP ROUTINES     - IEAVAD00, IEAVAD0D, IEAVTABD, IEAVTABI,\n.*                              IEAVTFMT, IEAVTFSD, IEAVTSDI,\n.*                              (MOST MODULES STARTING WITH IEAVTSD...)\n.*                              IEAVTSSD, IEAVTSSE             @G33VPHZ\n.*     CHNGDUMP COMMAND       - IEEMB815\n.*     DISPLAY DUMP COMMAND   - IEECB910                       @G33CPHE\n.*     LOGDATA FORMATTER      - IFCERFMT                       @G33LPHP\n.**********************************************************************\n         IEZBITS , -              SYMBOLIC BIT NAMES\nRTCTNAME DS    CL4 -              CONTAINS C'RTCT' AS IDENTIFIER.\n***********************************************************************\n* SNAP/ABEND PARMLIB VALUES                                           *\n***********************************************************************\nRTCTPLIB DS    0CL12                                           @G33CPHE\n*\nRTCTSAP  DS    0BL4 -             **SYSABEND INITIAL PARMLIB VALUES**\nRTCTSAP1 DS    B -                (BYTE 1 OF SDATA OPTIONS:)\nRTCTSAB0 EQU   BIT0               1=DISPLAY NUCLEUS\nRTCTSAB1 EQU   BIT1               1=DISPLAY SQA\nRTCTSAB2 EQU   BIT2               1=DISPLAY LSQA\nRTCTSAB3 EQU   BIT3               1=DISPLAY SWA\nRTCTSAB4 EQU   BIT4               1=DISPLAY GTF OR SUPERVISOR TRACE\nRTCTSAB5 EQU   BIT5               1=DISPLAY CONTROL BLOCKS FOR TASK\nRTCTSAB6 EQU   BIT6               1=DISPLAY ENQUEUE CONTROL BLOCKS\nRTCTSAB7 EQU   BIT7               1=FORMAT DATA MGMT C.B.S     @G33CPHE\n*\nRTCTSAP2 DS    B                  (BYTE 2 OF SDATA OPTIONS:)\nRTCTSABG EQU   BIT0               1=FORMAT IOS CONTROL BLOCKS  @G33CPHE\nRTCTSABH EQU   BIT1               1=FORMAT ERROR CONTROL BLKS  @G33CPHE\n*        EQU   BIT2               RESERVED\n*        EQU   BIT3               RESERVED\n*        EQU   BIT4               RESERVED\n*        EQU   BIT5               RESERVED\n*        EQU   BIT6               RESERVED\n*        EQU   BIT7               RESERVED\n*\nRTCTSAP3 DS    B -                (BYTE 1 OF PDATA OPTIONS:)\nRTCTSAB8 EQU   BIT0               1=DISPLAY SAVE AREA TRACE(SA KEYWORD)\nRTCTSAB9 EQU   BIT1               0=DISPLAY ENTIRE SAVE AREA\n*                                 1=DISPLAY SAVE AREA HEADINGS(SAH KWD)\nRTCTSABA EQU   BIT2               1=DISPLAY REGISTERS\nRTCTSABB EQU   BIT3               1=DISPLAY LINK PACK AREA\nRTCTSABC EQU   BIT4               1=DISPLAY JOB PACK AREA\nRTCTSABD EQU   BIT5               1=DISPLAY PSW\nRTCTSABE EQU   BIT6               1=DISPLAY USER SUBPOOLS: 0-127\nRTCTSABF EQU   BIT7               RESERVED\nRTCTSAP4 DS    B                  RESERVED\n*\nRTCTSUP  DS    0BL4 -             **SYSUDUMP INITIAL PARMLIB VALUES**\nRTCTSUP1 DS    B -                (BYTE 1 OF SDATA OPTIONS:)\nRTCTSUD0 EQU   BIT0               1=DISPLAY NUCLEUS\nRTCTSUD1 EQU   BIT1               1=DISPLAY SQA\nRTCTSUD2 EQU   BIT2               1=DISPLAY LSQA\nRTCTSUD3 EQU   BIT3               1=DISPLAY SWA\nRTCTSUD4 EQU   BIT4               1=DISPLAY GTF OR SUPERVISOR TRACE\nRTCTSUD5 EQU   BIT5               1=DISPLAY CNTRL BLKS FOR TASK\nRTCTSUD6 EQU   BIT6               1=DISPLAY ENQUEUE CNTRL BLKS\nRTCTSUD7 EQU   BIT7               1=FORMAT DATA MGMT C.B.S     @G33CPHE\n*\nRTCTSUP2 DS    B                  (BYTE 2 OF SDATA OPTIONS:)\nRTCTSUDG EQU   BIT0               1=FORMAT IOS CONTROL BLOCKS  @G33CPHE\nRTCTSUDH EQU   BIT1               1=FORMAT ERROR CONTROL BLKS  @G33CPHE\n*        EQU   BIT2               RESERVED\n*        EQU   BIT3               RESERVED\n*        EQU   BIT4               RESERVED\n*        EQU   BIT5               RESERVED\n*        EQU   BIT6               RESERVED\n*        EQU   BIT7               RESERVED\n*\nRTCTSUP3 DS    B -                (BYTE 1 OF PDATA OPTIONS:)\nRTCTSUD8 EQU   BIT0               1=DISPLAY SAVE AREA TRACE(SA KEYWORD)\nRTCTSUD9 EQU   BIT1               0=DISPLAY ENTIRE SAVE AREA\n*                                 1=DISPLAY SAVE AREA HEADINGS(SAH KWD)\nRTCTSUDA EQU   BIT2               1=DISPLAY REGISTERS\nRTCTSUDB EQU   BIT3               1=DISPLAY LINK PACK AREA\nRTCTSUDC EQU   BIT4               1=DISPLAY JOB PACK AREA\nRTCTSUDD EQU   BIT5               1=DISPLAY PSW\nRTCTSUDE EQU   BIT6               1=DISPLAY USER SUBPOOLS: 0-127\nRTCTSUDF EQU   BIT7               RESERVED\nRTCTSUP4 DS    B                  RESERVED\n*\nRTCTSYD  DS    0BL4               **SYSMDUMP INITIAL PARMLIB VALUES**\nRTCTSY01 DS    B                  (BYTE 1 OF SDATA OPTIONS:)   @G33CPHE\nRTCTSYM0 EQU   BIT0               1=DISPLAY NUCLEUS            @G33CPHE\nRTCTSYM1 EQU   BIT1               1=DISPLAY SQA                @G33CPHE\nRTCTSYM2 EQU   BIT2               1=DISPLAY LSQA               @G33CPHE\nRTCTSYM3 EQU   BIT3               1=DISPLAY SWA                @G33CPHE\nRTCTSYM4 EQU   BIT4               1=DISPLAY GTF OR SUPV TRACE  @G33CPHE\nRTCTSYM5 EQU   BIT5               1=DISPLAY REGION             @G33CPHE\nRTCTSYM6 EQU   BIT6               1=DISPLAY LPA FOR REGION     @G33CPHE\nRTCTSYM7 EQU   BIT7               1=DISPLAY CSA                @G33CPHE\nRTCTSY02 DS    B                  RESERVED\nRTCTSY03 DS    B                  RESERVED\nRTCTSY04 DS    B                  RESERVED\n***********************************************************************\n* RTM AND LOGREC RECORDING INFORMATION                                *\n***********************************************************************\nRTCTYYY1 DS    H                  **RESERVED**                 @G33CPHZ\nRTCTSDID DS    H -                ASID OF MEMORY IN WHICH SVC DUMP IS\n*                                  OR WILL BE RUNNING.\nRTCTMECB DS    XL4 -              ECB WAIT'ED ON BY MEMORY\n*                                  TERMINATION CONTROLLER\nRTCTFASB DS    A -                ADDRESS OF FIRST ASCB ON MEMORY\n*                                  TERMINATION QUEUE.\nRTCTRECB DS    XL4 -              ECB WAIT'ED ON BY RECORDING TASK.\nRTCTRCB  DS    A -                ADDRESS OF RECORDER'S BUFFER CONTROL\n*                                  BLOCKS (CONTAIN LOGREC ENTRIES).\n***********************************************************************\n* THE FOLLOWING TABLE IS COMPOSED OF TEN TWELVE-BYTE ENTRIES, EACH    *\n* ONE CORRESPONDING TO AN SVC DUMP DATA SET.                          *\n***********************************************************************\nRTCTSDDS DS    0CL120 -           TOTAL OF TEN TWELVE-BYTE ENTRIES\nRTCTDSNM DS    CL3 -              NAME IDENTIFIER OF THIS DATA SET...\n*                                  TAPE - EBCDIC UNIT ADDRESS,\n*                                  DISK - EBCDIC 00-09 WITH TRAILING\n*                                         BLANK.\nRTCTFLG  DS    B -                FLAG BYTE..........\nRTCTDSST EQU   BIT0               1-D.S. FULL, 0-D.S. AVAILABLE.\nRTCTDSUS EQU   BIT1               1-D.S. USED, 0-D.S. NOT USED.\nRTCTDETP EQU   BIT2               0-TAPE D.S., 1-DASD D.S.\nRTCTDCB  DS    A -                DEB ADDRESS FOR THIS DATA SET.\nRTCTDEV  DS    XL4 -              DEVICE TYPE CODE FOR THIS DATA SET.\nRTCTBLEN EQU   *-RTCTDSNM         LENGTH OF ONE TABLE ENTRY.\n         DS    CL108              REMAINING NINE ENTRIES.\n*                                 *** END OF TABLE *****************\n*\nRTCTSDPL DS    A -                ADDRESS OF SVC DUMP PARAMETER LIST\n*                                  FOR CROSS-MEMORY REQUEST.\nRTCTSDIP EQU   BIT0               HIGH ORDER BIT IS SVC DUMP IN\n*                                  PROGRESS FLAG.             @G33VPHZ\n*\nRTCTFMT  DS    A                  USED FOR TESTING RTM MODULES\nRTCTMLCK DS    F                  LOCK FOR MEM TERM POST SRB\nRTCTMSRB DS    F                  PTR TO MEM TERM POST SRB\nRTCTTEST DS    F                  USED FOR TESTING RTM MODULES\nRTCTRFLG DS    B                  RECORDING FLAGS\nRTCTRTER EQU   BIT0               RECORDING TEMPORARY ERROR\nRTCTRPER EQU   BIT1               RECORDING PERMANENT ERROR\nRTCTRSTF EQU   BIT2               INITIAL STF ENTRY\nRTCTXXX1 DS    BL1                RESERVED\nRTCTSEQ# DS    H                  ERRORID SEQUENCE NUMBER      @G17EP5W\nRTCTSDSW DS    A                  ADDRESS OF SUMMARY SVC DUMP (SUMDUMP)\n*                                  WORK AREA (IHASMWK)         @G33VPHD\nRTCTTDCB DS    9F                 TAPE DCB FOR SVC DUMP\nRTCTSDWK DS    A                  ADDRESS OF SVC DUMP WORK AREA\nRTCTERID DS    0CL10              ERRORID FOR THIS FAILURE'S SVC DUMP\n*                                  HEADER                     @G17EP5W\nRTCTESEQ DS    CL2                ERRORID SEQUENCE NUMBER     @G17EP5W\nRTCTECPU DS    CL2                ERRORID LOGICAL CPU ID      @G17EP5W\nRTCTEASD DS    CL2                ERRORID ASID                @G17EP5W\nRTCTETIM DS    CL4                ERRORID TIMESTAMP           @G17EP5W\nRTCTXXX2 DS    CL2                RESERVED                    @G17EP5W\n***********************************************************************\n* DEFAULT DUMP OPTIONS, WHICH CAN BE CHANGED BY THE CHNGDUMP          *\n* OPERATOR COMMAND                                                    *\n***********************************************************************\nRTCTOPT  DS    0CL16                                           @G33CPHE\nRTCTSAO  DS    0BL4               **SYSABEND EFFECTIVE OPTIONS**\nRTCTSASD DS    0BL2\nRTCTSAO1 DS    B                  (BYTE 1 OF SDATA OPTIONS:)\nRTCTSAD0 EQU   BIT0               1=DISPLAY NUCLEUS\nRTCTSAD1 EQU   BIT1               1=DISPLAY SQA\nRTCTSAD2 EQU   BIT2               1=DISPLAY LSQA\nRTCTSAD3 EQU   BIT3               1=DISPLAY SWA\nRTCTSAD4 EQU   BIT4               1=DISPLAY GTF OR SUPERVISOR TRACE\nRTCTSAD5 EQU   BIT5               1=DISPLAY CONTROL BLOCKS FOR TASK\nRTCTSAD6 EQU   BIT6               1=DISPLAY ENQUEUE CONTROL BLOCKS\nRTCTSAD7 EQU   BIT7               1=FORMAT DATA MGMT C.B.S     @G33CPHE\n*\nRTCTSAO2 DS    B                  (BYTE 2 OF SDATA OPTIONS:)\nRTCTSADG EQU   BIT0               1=FORMAT IOS CONTROL BLOCKS  @G33CPHE\nRTCTSADH EQU   BIT1               1=FORMAT ERROR CONTROL BLKS  @G33CPHE\n*              BIT3               RESERVED\n*              BIT4               RESERVED\n*              BIT5               RESERVED\n*              BIT6               RESERVED\n*              BIT7               RESERVED\nRTCTSAPD DS    0BL2\nRTCTSAO3 DS    B                  (BYTE 1 OF PDATA OPTIONS:)\nRTCTSAD8 EQU   BIT0               1=DISPLAY SAVE AREA TRACE(SA KEYWORD)\nRTCTSAD9 EQU   BIT1               0=DISPLAY ENTIRE SAVE AREA\n*                                 1=DISPLAY SAVE AREA HEADINGS(SAH KWD)\nRTCTSADA EQU   BIT2               1=DISPLAY REGISTERS\nRTCTSADB EQU   BIT3               1=DISPLAY LINK PACK AREA\nRTCTSADC EQU   BIT4               1=DISPLAY JOB PACK AREA\nRTCTSADD EQU   BIT5               1=DISPLAY PSW\nRTCTSADE EQU   BIT6               1=DISPLAY USER SUBPOOLS: 0-127\nRTCTSADF EQU   BIT7               RESERVED\n*\nRTCTSAO4 DS    B                  (BYTE 1 OF OTHER OPTIONS:)\nRTCTSAMG EQU   BIT6               SEE RTCTSAOV                 @G33CPHZ\nRTCTSAOV EQU   BIT6               1=OVER MODE  0=ADD MODE      @G33CPHZ\nRTCTISAB EQU   BIT7               IGNORE REQUESTS FOR SYSABEND @G33CPHE\n*\nRTCTSUO  DS    0BL4               **SYSUDUMP EFFECTIVE OPTIONS**\nRTCTSUSD DS    0BL2\nRTCTSUO1 DS    B                  (BYTE 1 OF SDATA OPTIONS:)\nRTCTSYD0 EQU   BIT0               1=DISPLAY NUCLEUS\nRTCTSYD1 EQU   BIT1               1=DISPLAY SQA\nRTCTSYD2 EQU   BIT2               1=DISPLAY LSQA\nRTCTSYD3 EQU   BIT3               1=DISPLAY SWA\nRTCTSYD4 EQU   BIT4               1=DISPLAY GTF OR SUPERVISOR TRACE\nRTCTSYD5 EQU   BIT5               1=DISPLAY CNTRL BLKS FOR TASK\nRTCTSYD6 EQU   BIT6               1=DISPLAY ENQUEUE CNTRL BLKS\nRTCTSYD7 EQU   BIT7               1=FORMAT DATA MGMT C.B.S     @G33CPHE\n*\nRTCTSUO2 DS    B                  (BYTE 2 OF SDATA OPTIONS:)\nRTCTSYDG EQU   BIT0               1=FORMAT IOS CONTROL BLOCKS  @G33CPHE\nRTCTSYDH EQU   BIT1               1=FORMAT ERROR CONTROL BLKS  @G33CPHE\n*                                 RESERVED\n*        EQU   BIT4               RESERVED\n*        EQU   BIT5               RESERVED\n*        EQU   BIT6               RESERVED\n*        EQU   BIT7               RESERVED\nRTCTSUPD DS    0BL2\nRTCTSUO3 DS    B                  (BYTE 1 OF PDATA OPTIONS:)\nRTCTSYD8 EQU   BIT0               1=DISPLAY SAVE AREA TRACE(SA KEYWORD)\nRTCTSYD9 EQU   BIT1               0=DISPLAY ENTIRE SAVE AREA\n*                                 1=DISPLAY SAVE AREA HEADINGS(SAH KWD)\nRTCTSYDA EQU   BIT2               1=DISPLAY REGISTERS\nRTCTSYDB EQU   BIT3               1=DISPLAY LINK PACK AREA\nRTCTSYDC EQU   BIT4               1=DISPLAY JOB PACK AREA\nRTCTSYDD EQU   BIT5               1=DISPLAY PSW\nRTCTSYDE EQU   BIT6               1=DISPLAY USER SUBPOOLS: 0-127\nRTCTSYDF EQU   BIT7               RESERVED\n*\nRTCTSUO4 DS    B                  (BYTE 1 OF OTHER OPTIONS:)\nRTCTSUMG EQU   BIT6               SEE RTCTSUOV                 @G33CPHZ\nRTCTSUOV EQU   BIT6               1=OVER MODE  0=ADD MODE      @G33CPHZ\nRTCTISYU EQU   BIT7               IGNORE REQUESTS FOR SYSUDUMP @G33CPHE\n*\nRTCTSYO  DS    0BL4               **SYSMDUMP EFFECTIVE OPTIONS**\nRTCTSD01 DS    B                  (BYTE 1 OF SDATA OPTIONS:)   @G33CPHE\nRTCTSDS0 EQU   BIT0               1=DISPLAY NUCLEUS            @G33CPHE\nRTCTSDS1 EQU   BIT1               1=DISPLAY SQA                @G33CPHE\nRTCTSDS2 EQU   BIT2               1=DISPLAY LSQA               @G33CPHE\nRTCTSDS3 EQU   BIT3               1=DISPLAY SWA                @G33CPHE\nRTCTSDS4 EQU   BIT4               1=DISPLAY GTF OR SPV.TRACE   @G33CPHE\nRTCTSDS5 EQU   BIT5               1=DISPLAY REGION             @G33CPHE\nRTCTSDS6 EQU   BIT6               1=DISPLAY ACTIVE LPA FOR RGN @G33CPHE\nRTCTSDS7 EQU   BIT7               1=DISPLAY CSA                @G33CPHE\nRTCTSD02 DS    B                  RESERVED\nRTCTSD03 DS    B                  RESERVED\n*\nRTCTSD04 DS    B                  (BYTE 1 OF OTHER OPTIONS:)\nRTCTSMMG EQU   BIT6               SEE RTCTSMOV                 @G33CPHZ\nRTCTSMOV EQU   BIT6               1=OVER MODE  0=ADD MODE      @G33CPHZ\nRTCTISYM EQU   BIT7               IGNORE REQUESTS FOR SYSMDUMP @G33CPHE\n*\nRTCTSDO  DS    0BL4               **SVC DUMP EFFECTIVE OPTIONS**\nRTCTSDOD DS    0BL2                                            @G33CPHZ\nRTCTSDO1 DS    B                  (BYTE 1 OF SDATA OPTIONS:)\nRTCTSDP0 EQU   BIT0               1=DISPLAY ALL PSA'S IN SYSTEM\nRTCTSDP1 EQU   BIT1               1=DISPLAY CURRENT PSA\nRTCTSDP2 EQU   BIT2               1=DISPLAY NUCLEUS\nRTCTSDP3 EQU   BIT3               1=DISPLAY SQA\nRTCTSDP4 EQU   BIT4               1=DISPLAY LSQA\nRTCTSDP5 EQU   BIT5               1=DISPLAY REGION (PRIVATE AREA)\nRTCTSDP6 EQU   BIT6               1=DISPLAY ACTIVE LPA MODULES FOR RGN\nRTCTSDP7 EQU   BIT7               1=DISPLAY GTF OR SUPERVISOR TRACE\nRTCTSDO2 DS    B -\nRTCTSDP8 EQU   BIT0               1=DISPLAY CSA\nRTCTSDP9 EQU   BIT1               1=DISPLAY SWA\nRTCTSDPA EQU   BIT2               1=DISPLAY SUMMARY SVC DUMP\n*                                  (SUMDUMP)                   @G33CPHE\nRTCTSDPB EQU   BIT3               1=NO SUMMARY DUMP DISPLAY    @G33CPHE\nRTCTSDPC EQU   BIT4               1=NO ALL PSA DISPLAY         @G33CPHE\nRTCTSDPD EQU   BIT5               1=NO SQA DISPLAY             @G33CPHE\n*        EQU   BIT6               RESERVED\n*        EQU   BIT7               RESERVED\n*\nRTCTSDO3 DS    B                  (BYTE 1 OF OTHER OPTIONS:)\nRTCTSDPG EQU   BIT0               1 MEANS QUIESCE=YES SPECIFIED ON\n*                                  CHNGDUMP COMMAND\nRTCTSDPH EQU   BIT1               1 MEANS QUIESCE=NO SPECIFIED ON\n*                                  CHNGDUMP COMMAND\n*        EQU   BIT3               RESERVED\n*        EQU   BIT4               RESERVED\n*        EQU   BIT5               RESERVED\n*        EQU   BIT6               RESERVED\n*        EQU   BIT7               RESERVED\nRTCTSDO4 DS    B                  (BYTE 2 OF OTHER OPTIONS:)\nRTCTSDMG EQU   BIT6               SEE RTCTSDOV                 @G33CPHZ\nRTCTSDOV EQU   BIT6               1=OVER MODE  0=ADD MODE      @G33CPHZ\nRTCTISVC EQU   BIT7               IGNORE REQUESTS FOR SVCDUMP  @G33CPHE\n*\n***********************************************************************\n* ADDITIONAL SVC DUMP INFORMATION AND FLAGS                           *\n***********************************************************************\nRTCTASO  DS    0BL2               **ACTUAL SVC DUMP OPTIONS FROM MERGER\n*                                 OF DEFAULTS AND SDUMP MACRO OPTIONS**\n*                                                              @G33VPHZ\nRTCTASOD DS    0BL2                                            @G33VPHZ\nRTCTASO1 DS    B                  (BYTE 1 OF SDATA:)           @G33VPHZ\nRTCTASAL EQU   BIT0               1=DISPLAY ALL PSA'S          @G33VPHZ\nRTCTASPS EQU   BIT1               1=DISPLAY CURRENT PSA        @G33VPHZ\nRTCTASNU EQU   BIT2               1=DISPLAY NUCLEUS            @G33VPHZ\nRTCTASSQ EQU   BIT3               1=DISPLAY SQA                @G33VPHZ\nRTCTASLS EQU   BIT4               1=DISPLAY LSQA               @G33VPHZ\nRTCTASRG EQU   BIT5               1=DISPLAY REGION (RGN)       @G33VPHZ\nRTCTASLP EQU   BIT6               1=DISPLAY ACTIVE LPA         @G33VPHZ\nRTCTASTR EQU   BIT7               1=DISPLAY GTF OR SUPV TRACE  @G33VPHZ\nRTCTASO2 DS    B                  (BYTE 2 OF SDATA:)           @G33VPHZ\nRTCTASCS EQU   BIT0               1=DISPLAY CSA                @G33VPHZ\nRTCTASSW EQU   BIT1               1=DISPLAY SWA                @G33VPHZ\nRTCTASSU EQU   BIT2               1=DISPLAY SUMMARY DUMP       @G33VPHZ\nRTCTASNS EQU   BIT3               1=DISPLAY NO SUMDUMP         @G33VPHZ\nRTCTASNA EQU   BIT4               1=DISPLAY NO ALLPSA          @G33VPHZ\nRTCTASNQ EQU   BIT5               1=DISPLAY NO SQA             @G33VPHZ\n*        EQU   BIT6               RESERVED                     @G33VPHZ\n*        EQU   BIT7               RESERVED                     @G33VPHZ\nRTCTSDI  DS    0BL2               **SVC DUMP INFORMATION**\nRTCTSDNA DS    B                  NUMBER ADDR SPACES TO DUMP   @G33VPHD\nRTCTINDX DS    B                  INDEX FOR ASID LIST ENTRY    @G33VPHD\nRTCTSDPR DS    XL1                PERMANENT RETURN CODE        @G33VPHD\nRTCTZZZ2 DS    BL7                RESERVED                     @G33VPHZ\n*\nRTCTSDF  DS    0BL4               **SVC DUMP FLAGS**\nRTCTSDF1 DS    B                  (BYTE 1 OF FLAGS:)\nRTCTSDNO EQU   BIT0               NO SYS1.DUMP DATASETS DEFINED\nRTCTSDND EQU   BIT1               SVC DUMP SET SYSTEM NON-DISP\nRTCTSDSH EQU   BIT2               SCHEDULE DUMP (IEAVTSDX) REQUEST\n*                                                              @G33VPHZ\nRTCTSDMA EQU   BIT3               MULTIPLE ADDR SPACE DUMP IN PROGRESS\n*                                                              @G33VPHD\nRTCTSDEP EQU   BIT4               CALLER'S ECB POSTED\nRTCTSDSD EQU   BIT5               SUMMARY DUMP (IEAVTSSD) RECEIVED\n*                                  CONTROL                     @G33VPHZ\nRTCTSDRS EQU   BIT6               REAL STORAGE BUFFER MGR (IEAVPRSB)\n*                                  RECEIVED CONTROL            @G33VPHZ\nRTCTSDSC EQU   BIT7               SUMMARY DUMP (IEAVTSSD) COMPLETED\n*                                  PROCESSING                  @G33VPHZ\n*\nRTCTSDF2 DS    B                  (BYTE 2 OF FLAGS:)           @G33VPHZ\nRTCTSDMR EQU   BIT0               DUMP MASTER ADDR SPACE REQD  @G33VPHD\nRTCTSDTQ EQU   BIT1               TQE WAS ENQUEUED BY SETDIE   @G33VPHD\nRTCTSDDI EQU   BIT2               TIMER DIE RECEIVED CONTROL (SCHDIE IN\n*                                  IEAVTSDX)                   @G33VPHD\nRTCTSDLA EQU   BIT3               LAST ASID BEING PROCESSED    @G33VPHD\nRTCTSDWF EQU   BIT4               SUMDUMP WRITER (IEAVTSDW) HAS\n*                                  COMPLETED                   @G33VPHD\nRTCTSDSL EQU   BIT5               DUMP DATA SET WAS SELECTED   @G33VPHD\nRTCTSDRW EQU   BIT6               SUMDUMP RECORDS (FROM\n*                                  IEAVTSSD) TO WRITE          @G33VPHD\nRTCTSDFX EQU   BIT7               ASYNC EXIT FLAG              @ZA27434\nRTCTR2D2 DS    B                  (BYTE 3 OF FLAGS:)\nRTCTC3PO DS    B                  (BYTE 4 OF FLAGS:)\nRTCTSDF3 DS    0CL64              **ARRAY OF INFO FOR SVC DUMP OF\n*                                   MULTIPLE ADDRESS SPACES**  @G33VPHD\nRTCTSDAS DS    BL2                ASID OF THIS ADDRESS SPACE (A.S.)\n*                                                              @G33VPHZ\nRTCTSDF4 DS    B                  (BYTE 1 OF FLAGS:)           @G33VPHZ\nRTCTSDSS EQU   BIT0               GSRB IN ADDR SPACE SCHEDULED @G33VPHZ\nRTCTSDNC EQU   BIT1               NON-DISPATCHABLE SRB RECEIVED CONTROL\n*                                                              @G33VPHZ\nRTCTSDAN EQU   BIT2               ADDRESS SPACE SET NON-DISPATCHABLE\n*                                                              @G33VPHZ\nRTCTSDRM EQU   BIT3               DUMP TASK HAS BEEN RESUMED   @G33VPHZ\nRTCTSDTR EQU   BIT4               DUMP TASK RUNNING            @G33VPHZ\nRTCTSDEQ EQU   BIT5               DUMP TASK ENQUEUED ON DUMP RESOURCE\n*                                                              @G33VPHZ\nRTCTSDEN EQU   BIT6               SVC DUMP (IEAVAD00 OR IEAVTSDT) IS\n*                                  PROCESSING THIS A.S.        @G33VPHZ\nRTCTSDDO EQU   BIT7               DUMP ATTEMPTED FOR THIS ASID @G33VPHZ\nRTCTSDF5 DS    B                  RESERVED\nRTCTSDEL EQU   *-RTCTSDF3         LENGTH OF ELEMENT OF ADDR SPACE ARRAY\n*                                                              @G33VPHZ\n         DS    CL60               REMAINING 15 ASID ENTRIES    @G33VPHZ\n*\n***********************************************************************\n* RTM INFORMATION                                                     *\n***********************************************************************\nRTCTMRMQ DS    A                  ADDRESS OF QUEUE OF STORAGE AREAS\n*                                 (USED FOR SYSMDUMPS) TO BE FREED\n*                                 AT MEMTERM                   @G33SPHZ\nRTCTZZZ4 DS    F                  RESERVED                     @G33VPHZ\nRTCTZZZ5 DS    F                  RESERVED                     @G33VPHZ\n*\nRTCTLEN  EQU   *-RTCT             TOTAL LENGTH OF RTM CONTROL TABLE.\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IHASNP": {"ttr": 5640, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00D\\x00D\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 68, "newlines": 68, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n         IHASNP &DSECT=YES                                  @Y307PXE*/\n* /* MACMEAN SNAP MEANS SNAP PARAMETER LIST                          */\n* /* MACCOMP Y-1 SC1C5/PZD81                                         */\n* /* MACSTAT Y-1 72245/Y02705                                        */\n* /* UPDATED FOR SU 33 3.7 BASE      9/23/76                 @G33SPHW*/\n         AIF ('&DSECT' EQ 'YES').SNAP00\nSNPPARMS EQU   *\n         AGO    .SNAP01\n.SNAP00  ANOP\nSNPPARMS DSECT\n.SNAP01  DS    0F\n         IEZBITS\nSNPIDENT DS    B                   DUMP ID SUPPLIED BY USER\nSNPFLAG  DS    B                   FLAG BYTE\nSNPSNAP  EQU   BIT0                0=SNAP REQUEST\n*                                  1=SVC DUMP REQUEST\nSNPVS2   EQU   BIT1                0=OS/VS2 REL.1 PARAMETER LIST\n*                                  1=OS/VS2 REL.2 PARAMETER LIST\nSNPVS2EN EQU   BIT2                1=OS/VS2 ENHANCED SNAP\nSNPABEND EQU   BIT3                0=ABEND IS CALLER\n*                                  1=SNAP REQUEST\nSNPID    EQU   BIT4                1=ID SPECIFIED\nSNPTCB   EQU   BIT5                1=TCB SPECIFIED\nSNPSLIST EQU   BIT6                1=STORAGE LIST SPECIFIED\nSNPHDR   EQU   BIT7                1=HEADER LIST SPECIFIED\n         DS    H                   RESERVED\nSNPSDATA DS    CL2                 SDATA OPTIONS\nSNPSDAT0 DS    0B                  SDATA OPTIONS FLAG ONE    @G33SPHW\nSNPNUC   EQU   BIT0                1=DUMP NUCLEUS,PSA,SQA,LSQA\nSNPSQA   EQU   BIT1                1=DUMP SQA\nSNPLSQA  EQU   BIT2                1=DUMP LSQA\nSNPSWA   EQU   BIT3                1=DUMP SWA\nSNPTRT   EQU   BIT4                1=INCLUDE TRACE TABLE (SUPERVISOR\n*                                  OR GTF)\nSNPCB    EQU   BIT5                1=FORMAT CNTRL BLKS FOR TASK\nSNPQCB   EQU   BIT6                1=FORMAT ENQUEUE CNTRL BLKS\n*                                  FOR TASK\nSNPDM    EQU   BIT7                1=FORMAT DATA MGT. CONTROL BLKS.\n*                                                             @G33SPHW\nSNPSDAT1 DS    0B                  SDATA OPTIONS FLAG TWO     @G33SPHW\nSNPIO    EQU   BIT0                1=FORMAT IOS CONTROL BLKS. @G33SPHW\nSNPERR   EQU   BIT1                1=FORMAT ERROR CONTROL BLKS.@G33SPHW\n*        EQU   BIT2                RESERVED\n*        EQU   BIT3                RESERVED\n*        EQU   BIT4                RESERVED\n*        EQU   BIT5                RESERVED\n*        EQU   BIT6                RESERVED\n*        EQU   BIT7                RESERVED\nSNPPDATA DS    B                   PDATA OPTIONS\nSNPSAVE  EQU   BIT0                1=DISPLAY SAVE AREA TRACE\nSNPSAVE2 EQU   BIT1                0=DISPLAY ENTIRE SAVE AREA\n*                                  1=DISPLAY SAVE AREA HEADS\nSNPREGS  EQU   BIT2                1=DISPLAY REGS- ENTRY TO SNAP/ABEND\nSNPLPA   EQU   BIT3                1=DISPLAY ACTIVE LPA MODULES\nSNPJPA   EQU   BIT4                1=DISPLAY JPA MODULES\nSNPPSW   EQU   BIT5                1=DISPLAY PSW, ILC, INTERRUPT CODE\nSNPSPLS  EQU   BIT6                1=DISPLAY USER SUBPOOLS: 0-127\n*        EQU   BIT7                RESERVED\n         DS    B                   RESERVED\nSNPDCB   DS    A                   ADDRESS OF DCB FOR DUMP DATA\n*                                  SET\nSNPTCBA  DS    A                   ADDRESS OF TCB TO BE DISPLAYED\nSNPSTOR  DS    A                   ADDRESS OF STORAGE LIST\n*                                  LIST CONTAINS BEGIN AND END\n*                                  ADDR OF AREAS TO BE DUMPED\nSNPHDRA  DS    A                   ADDRESS OF HEADER LIST     @G33SPHW\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IHASVC": {"ttr": 5642, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00\\x13\\x00\\x13\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n         IHASVC\nSVCENTRY DSECT\nSVCEP    DS    A                       SVC ENTRY POINT ADDRESS\nSVCATTR1 DS    H                       ATTRIBUTES\nSVCTP1   EQU   X'00'                   TYPE 1 SVC\nSVCTP2   EQU   X'80'                   TYPE 2 SVC\nSVCTP34  EQU   X'C0'                   TYPE 3 OR 4 SVC\nSVCTP6   EQU   X'20'                   TYPE  6 SVC             @Z40FPYK\nSVCAPF   EQU   X'08'                   APF AUTHORIZED 1-AUTHORIZED\nSVCESR   EQU   X'04'                   SVC IS A PART OF THE ESR\nSVCNP    EQU   X'02'                   NON-PREEMPTIVE SVC      @Z40FPYK\nSVCLOCKS DS    H                       LOCK ATTRIBUTES\nSVCLL    EQU   X'80'                   LOCAL LOCK NEEDED\nSVCCMS   EQU   X'40'                   CMS LOCK NEEDED\nSVCOPT   EQU   X'20'                   OPT LOCK NEEDED\nSVCALLOC EQU   X'10'                   SALLOC LOCK NEEDED\nSVCDISP  EQU   X'08'                   DISP LOCK NEEDED\n         MEND ,                                                      */\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IM#IGEN": {"ttr": 5644, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00H\\x00H\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 72, "newlines": 72, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   IM#IGEN &OP,&A,&B,&REG=R0\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n.*---------------------------------------------------------------------\n.* Function: generate one instruction\n.* &OP  - instruction opcode\n.* &A   - first operand\n.* &B   - second operand\n.* &REG - work register\n.* See IM#INSTR for further details, and notes below.\n.*---------------------------------------------------------------------\n         AIF   (T'&REG EQ 'O').XREG\n         AIF   (T'&OP EQ 'O').XOP\n         AIF   ('&OP' EQ '-CLEAR-').CLEAR\n         AIF   ('&OP' EQ '(-CLEAR-)').CLEAR\n         AIF   ('&OP' EQ '((-CLEAR-))').CLEAR\n         AIF   ('&OP' EQ '-ZERO-').ZERO\n         AIF   ('&OP' EQ '(-ZERO-)').ZERO\n         AIF   ('&OP' EQ '((-ZERO-))').ZERO\n         AIF   ('&OP' EQ '-0-').ZERO\n         AIF   ('&OP' EQ '(-0-)').ZERO\n         AIF   ('&OP' EQ '((-0-))').ZERO\n         AIF   ('&OP' EQ 'MVI').SI\n         AIF   ('&OP' EQ 'OI').SI\n         AIF   ('&OP' EQ 'NI').SI\n         AIF   ('&OP' EQ 'XI').SI\n         AIF   ('&OP' EQ 'MVC').SS\n         AIF   ('&B' NE '').B\n         AIF   ('&A' NE '').A\n         AIF   ('&REG' NE '').R\n&LABEL   &OP   ,\n         MEXIT\n.*\n.R       ANOP\n&LABEL   &OP   &REG\n         MEXIT\n.*\n.A       ANOP\n&LABEL   &OP   &REG,&A\n         MEXIT\n.*\n.B       ANOP\n&LABEL   &OP   &REG,&A,&B\n         MEXIT\n.*\n.CLEAR   ANOP\n&LABEL   SLR   &REG,&REG               clear register\n         MEXIT\n.*\n.ZERO    ANOP\n&LABEL   SR    &REG,&REG               zero register\n         MEXIT\n.*\n.SI      ANOP\n.SS      ANOP\n&LABEL   &OP   &A,&B\n         MEXIT\n.*\n.XOP     MNOTE 8,'IM#IGEN missing OP value'\n         MEXIT\n.XREG    MNOTE 8,'IM#IGEN missing REG value'\n.*---------------------------------------------------------------------\n.* Notes:\n.*\n.*  1) RR, RX, and RS instructions don't need to be checked, the\n.*     code handles them ASIS.  The other opcodes will need to be\n.*     specifically checked, so the right operands can be generated\n.*     for the target instruction.\n.*---------------------------------------------------------------------\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IM#IGENF": {"ttr": 5889, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00R\\x00R\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 82, "newlines": 82, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   IM#IGENF &SPEC,&REG=R0\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n.*---------------------------------------------------------------------\n.* Function: generate one instruction - ASMF version\n.* &OP  - instruction opcode\n.* &A   - first operand\n.* &B   - second operand\n.* &REG - work register\n.* See IM#INSTR for further details, and notes below.\n.*---------------------------------------------------------------------\n         LCLC  &OP,&A,&B,&C\n&OP      SETC  '&SPEC(1)'\n&A       SETC  '&SPEC(2)'\n&B       SETC  '&SPEC(3)'\n&C       SETC  '&SPEC(4)'\n         MNOTE *,'IM#IGENF op &OP a &A b &B c &C'\n         MNOTE *,'IM#IGENF SYSLIST(1) &SYSLIST(1)'\n         MNOTE *,'IM#IGENF SYSLIST(2) &SYSLIST(2)'\n         MNOTE *,'IM#IGENF SYSLIST(3) &SYSLIST(3)'\n         MNOTE *,'IM#IGENF SYSLIST(4) &SYSLIST(4)'\n         AIF   (T'&REG EQ 'O').XREG\n         AIF   (T'&OP EQ 'O').XOP\n         AIF   ('&OP' EQ '-CLEAR-').CLEAR\n         AIF   ('&OP' EQ '(-CLEAR-)').CLEAR\n         AIF   ('&OP' EQ '((-CLEAR-))').CLEAR\n         AIF   ('&OP' EQ '-ZERO-').ZERO\n         AIF   ('&OP' EQ '(-ZERO-)').ZERO\n         AIF   ('&OP' EQ '((-ZERO-))').ZERO\n         AIF   ('&OP' EQ '-0-').ZERO\n         AIF   ('&OP' EQ '(-0-)').ZERO\n         AIF   ('&OP' EQ '((-0-))').ZERO\n         AIF   ('&OP' EQ 'MVI').SI\n         AIF   ('&OP' EQ 'OI').SI\n         AIF   ('&OP' EQ 'NI').SI\n         AIF   ('&OP' EQ 'XI').SI\n         AIF   ('&OP' EQ 'MVC').SS\n         AIF   ('&B' NE '').B\n         AIF   ('&A' NE '').A\n         AIF   ('&REG' NE '').R\n&LABEL   &OP   ,\n         MEXIT\n.*\n.R       ANOP\n&LABEL   &OP   &REG\n         MEXIT\n.*\n.A       ANOP\n&LABEL   &OP   &REG,&A\n         MEXIT\n.*\n.B       ANOP\n&LABEL   &OP   &REG,&A,&B\n         MEXIT\n.*\n.CLEAR   ANOP\n&LABEL   SLR   &REG,&REG               clear register\n         MEXIT\n.*\n.ZERO    ANOP\n&LABEL   SR    &REG,&REG               zero register\n         MEXIT\n.*\n.SI      ANOP\n.SS      ANOP\n&LABEL   &OP   &A,&B\n         MEXIT\n.*\n.XOP     MNOTE 8,'IM#IGEN missing OP value'\n         MEXIT\n.XREG    MNOTE 8,'IM#IGEN missing REG value'\n.*---------------------------------------------------------------------\n.* Notes:\n.*\n.*  1) RR, RX, and RS instructions don't need to be checked, the\n.*     code handles them ASIS.  The other opcodes will need to be\n.*     specifically checked, so the right operands can be generated\n.*     for the target instruction.\n.*---------------------------------------------------------------------\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IM#INST": {"ttr": 5892, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00Q\\x00Q\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 81, "newlines": 81, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   IM#INST &REG,&SPEC\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n.*---------------------------------------------------------------------\n.* See notes below for details and syntax examples - ASMH+ version\n.*---------------------------------------------------------------------\n         LCLA  &N,&NN\n         LCLA  &I\n&LABEL   IM#SECT LABEL\n&N       SETA  N'&SPEC\n&NN      SETA  N'&SPEC(1)\n         AIF   ((&N EQ 1) AND (&NN EQ 1)).LALR\n         AIF   (&N GT 0).LOOP\n         MNOTE 8,'IM#INSTR missing SPEC'\n         MEXIT\n.*\n.LOOP    ANOP\n&I       SETA  &I+1\n         IM#IGEN &SPEC(&I,1),&SPEC(&I,2),&SPEC(&I,3),REG=&REG\n         AIF   (&I LT &N).LOOP\n         MEXIT\n.*\n.LALR    IM#LALR &REG,&SPEC\n         MEXIT\n.*---------------------------------------------------------------------\n.* Function: Generate one or more instructions from specified (SPEC)\n.* operands.\n.*\n.* &REG  - work register (may not always be used); generally the\n.*         register into which the calling macro wishes to place\n.*         a value.\n.* &SPEC - instruction specification\n.*\n.* SPEC Syntax samples (REG=Rx):\n.*\n.* SPEC                      calls     generates\n.* ------------------------- -------   --------------------------------\n.* (R3)                      IM#LALR   LR    Rx,R3\n.* FIELD                     IM#LALR   LA    Rx,FIELD\n.* *FIELD                    IM#LALR   L     Rx,FIELD\n.* .FIELD                    IM#LALR   LH    Rx,FIELD\n.*\n.* -CLEAR-                   IM#LALR   SLR   Rx,Rx\n.* -ZERO-                    IM#LALR   SR    Rx,Rx\n.* -0-                       IM#LALR   SR    Rx,Rx\n.*\n.* ((LH,FIELD))              IM#IGEN   LH    Rx,FIELD\n.* ((ICM,8,FIELD))           IM#IGEN   ICM   Rx,8,FIELD\n.* ((-ZERO-),(IC,F1))        IM#IGEN   SR    Rx,Rx\n.*                                     IC    Rx,F1\n.* ((MVI,F,8))               IM#IGEN   MVI   F,8\n.* ((MVC,F1,F2))             IM#IGEN   MVC   F1,F2\n.*\n.* ((-0-),(IC,F),(OI,X,32))  IM#IGEN   SR    Rx,Rx\n.*                           IM#IGEN   IC    Rx,F\n.*                           IM#IGEN   OI    X,32\n.*\n.* The basic function of this macro is to allow our callers to offer\n.* the coder the opportunity to \"reach into\" the macro expansion\n.* to add a few instructions.  Some of the syntax is as old as the\n.* hills: (Rx) and *FIELD have been in common usage since I started\n.* coding, and I have carried those syntax forms forward.\n.*\n.* If you wish to generate more than one instruction, the syntax must\n.* conform to the IM#IGEN format; the IM#LALR format is mostly for\n.* backwards compatability which only requires one instruction.\n.* For IM#IGEN, each sublist specified will generate one instruction.\n.*\n.* Not all instructions are capable of being generated by IM#INSTR.\n.* IM#LALR only supports the LR, LA, L, and LH instructions.\n.* IM#IGEN should support all of the RR, RX, and RS instruction types,\n.* and a handful of others; see IM#IGEN for these details.\n.* Both IM#IGEN and IM#LALR support the -x- forms.\n.*\n.* The coder is strongly encouraged to read the macro expansion to\n.* assure that what gets generated is what was intended, at least\n.* until some general familiarity with IM#INSTR is obtained.\n.*---------------------------------------------------------------------\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IM#INSTF": {"ttr": 5895, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x80\\x00\\x80\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 128, "newlines": 128, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   IM#INSTF &SPEC,&REG=R0,&LST=\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n.*---------------------------------------------------------------------\n.* See notes below for details and syntax examples - ASMF version\n.*---------------------------------------------------------------------\n         GBLA  &#SUBLN\n         GBLA  &#SUBLNI(8)\n         GBLC  &#SUBLC(8)\n         LCLA  &NSL           # &SYSLIST(1) operands\n         LCLA  &NI            # &LST(n) operands specified\n         LCLA  &I\n         LCLC  &JUNK\n.*\n&LABEL   XMI#SECT LABEL\n.*\n&NSL     SETA  N'&SYSLIST(1)\n         MNOTE *,'IM#INSTR LST &LST'\n         MNOTE *,'IM#INSTR NSL &NSL'\n.*\n         IM#SUBL &LST(1),&LST(2),&LST(3),&LST(4),&LST(5),&LST(6)\n&NI      SETA  &#SUBLN\n         MNOTE *,'IM#INSTR NI &NI'\n         AIF   (&#SUBLN GT 1).NOLALR\n.*\n         IM#SUBL &SPEC(1)\n         AIF   (&#SUBLN EQ 1).LALR\n.*\n.NOLALR  MNOTE *,'IM#INSTF - not LALR'\n         AIF   (&NSL EQ 0).NOSPEC\n         MNOTE *,'IM#INSTR LST(1) &LST(1)'\n         MNOTE *,'IM#INSTR LST(2) &LST(2)'\n         MNOTE *,'IM#INSTR LST(3) &LST(3)'\n         MNOTE *,'IM#INSTR LST(4) &LST(4)'\n         MNOTE *,'IM#INSTR SPEC(1) &SPEC(1)'\n         MNOTE *,'IM#INSTR SPEC(2) &SPEC(2)'\n         MNOTE *,'IM#INSTR SPEC(3) &SPEC(3)'\n         MNOTE *,'IM#INSTR SPEC(4) &SPEC(4)'\n         MNOTE *,'IM#INSTR SYSLIST(1) &SYSLIST(1)'\n         MNOTE *,'IM#INSTR SYSLIST(2) &SYSLIST(2)'\n         MNOTE *,'IM#INSTR SYSLIST(3) &SYSLIST(3)'\n         MNOTE *,'IM#INSTR SYSLIST(4) &SYSLIST(4)'\n.*\n.LOOP    ANOP\n         MNOTE *,'IM#INSTF *************  LOOP  ********************'\n&I       SETA  &I+1\n&JUNK    SETC  '&SYSLIST(&I,1)'\n         MNOTE *,'IM#INSTF I=&I SYSLIST(I,1) &JUNK'\n&JUNK    SETC  '&SYSLIST(&I,2)'\n         MNOTE *,'IM#INSTF I=&I SYSLIST(I,2) &JUNK'\n&JUNK    SETC  '&SYSLIST(&I,3)'\n         MNOTE *,'IM#INSTF I=&I SYSLIST(I,3) &JUNK'\n&JUNK    SETC  '&SYSLIST(&I,4)'\n         MNOTE *,'IM#INSTF I=&I SYSLIST(I,4) &JUNK'\n.*\n         MNOTE *,'INSTR->SUBL I=&I SYSLIST(I) &SYSLIST(&I)'\n         IM#SUBL &SYSLIST(&I)\n.*\n         MNOTE *,'INSTR->SUBL I=&I LST(I) &LST(&I)'\n         IM#SUBL &LST(&I)\n.*\n         IM#IGENF &SYSLIST(&I)\n         AIF   (&I LT &NI).LOOP\n         MEXIT\n.*\n.LALR    MNOTE *,'INSTR->LALR &REG,&LST'\n         IM#LALR &REG,&LST\n         MEXIT\n.*\n.NOSPEC  MNOTE 8,'IM#INSTR missing specification'\n         MEXIT\n.*---------------------------------------------------------------------\n.* Function: Generate one or more instructions from specified (SPEC)\n.* operands.\n.*\n.* &REG     - work register (may not always be used); generally the\n.*            register into which the calling macro wishes to place\n.*            a value.\n.* &SPEC    - instruction specification\n.*\n.* SPEC Syntax samples (REG=Rx):\n.*\n.* SPEC                      calls     generates\n.* ------------------------- -------   --------------------------------\n.* (R3)                      IM#LALR   LR    Rx,R3\n.* FIELD                     IM#LALR   LA    Rx,FIELD\n.* *FIELD                    IM#LALR   L     Rx,FIELD\n.* .FIELD                    IM#LALR   LH    Rx,FIELD\n.*\n.* -CLEAR-                   IM#LALR   SLR   Rx,Rx\n.* -ZERO-                    IM#LALR   SR    Rx,Rx\n.* -0-                       IM#LALR   SR    Rx,Rx\n.*\n.* ((LH,FIELD))              IM#IGEN   LH    Rx,FIELD\n.* ((ICM,8,FIELD))           IM#IGEN   ICM   Rx,8,FIELD\n.* ((-ZERO-),(IC,F1))        IM#IGEN   SR    Rx,Rx\n.*                                     IC    Rx,F1\n.* ((MVI,F,8))               IM#IGEN   MVI   F,8\n.* ((MVC,F1,F2))             IM#IGEN   MVC   F1,F2\n.*\n.* ((-0-),(IC,F),(OI,X,32))  IM#IGEN   SR    Rx,Rx\n.*                           IM#IGEN   IC    Rx,F\n.*                           IM#IGEN   OI    X,32\n.*\n.* The basic function of this macro is to allow our callers to offer\n.* the coder the opportunity to \"reach into\" the macro expansion\n.* to add a few instructions.  Some of the syntax is as old as the\n.* hills: (Rx) and *FIELD have been in common usage since I started\n.* coding, and I have carried those syntax forms forward.\n.*\n.* If you wish to generate more than one instruction, the syntax must\n.* conform to the IM#IGEN format; the IM#LALR format is mostly for\n.* backwards compatability which only requires one instruction.\n.* For IM#IGEN, each sublist specified will generate one instruction.\n.*\n.* Not all instructions are capable of being generated by IM#INSTR.\n.* IM#LALR only supports the LR, LA, L, and LH instructions.\n.* IM#IGEN should support all of the RR, RX, and RS instruction types,\n.* and a handful of others; see IM#IGEN for these details.\n.* Both IM#IGEN and IM#LALR support the -x- forms.\n.*\n.* The coder is strongly encouraged to read the macro expansion to\n.* assure that what gets generated is what was intended, at least\n.* until some general familiarity with IM#INSTR is obtained.\n.*---------------------------------------------------------------------\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IM#LALR": {"ttr": 5898, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00A\\x00A\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 65, "newlines": 65, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   IM#LALR &REG,&WHAT\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n.*---------------------------------------------------------------------\n.* Function: Generate one instruction\n.* &REG  - work register\n.* &WHAT - (register), RX, or self-defining term to put in &REG\n.* See IM#INSTR for further details\n.*---------------------------------------------------------------------\n         LCLA  &LWHAT\n         LCLC  &TREG\n         LCLC  &TWHAT\n         AIF   ('&WHAT' NE '0').MORE\n&LABEL   SLR   &REG,&REG                     zero register\n         MEXIT\n.MORE    ANOP\n&TREG    SETC  '(&REG)'                      (LOWER '(&reg)')\n&TWHAT   SETC  '&WHAT'                       (LOWER '&what')\n.*       MNOTE 0,'IM#LALR REG &TREG'\n.*       MNOTE 0,'IM#LALR WHAT &TWHAT'\n         AIF   ('&TWHAT' EQ '&TREG').SKIP    already have value in reg\n         AIF   ('&WHAT'      EQ '-CLEAR-').CLEAR\n         AIF   ('&WHAT'      EQ '(-CLEAR-)').CLEAR\n         AIF   ('&WHAT'      EQ '((-CLEAR-))').CLEAR\n         AIF   ('&WHAT'      EQ '-ZERO-').ZERO\n         AIF   ('&WHAT'      EQ '(-ZERO-)').ZERO\n         AIF   ('&WHAT'      EQ '((-ZERO-))').ZERO\n         AIF   ('&WHAT'      EQ '-0-').ZERO\n         AIF   ('&WHAT'      EQ '(-0-)').ZERO\n         AIF   ('&WHAT'      EQ '((-0-))').ZERO\n         AIF   ('&WHAT'(1,1) EQ '(').LR\n         AIF   ('&WHAT'(1,1) EQ '*').LOAD    *field means load field\n         AIF   ('&WHAT'(1,1) EQ '.').LH      .field means load halfword\n&LABEL   LA    &REG,&WHAT\n         MEXIT\n.*\n.LR      ANOP\n&LABEL   LR    &REG,&WHAT(1)\n         MEXIT\n.*\n.LH      ANOP\n&LWHAT   SETA  K'&WHAT-1\n&TWHAT   SETC  '&WHAT'(2,&LWHAT)\n&LABEL   LH    &REG,&TWHAT\n         MEXIT\n.*\n.LOAD    ANOP\n&LWHAT   SETA  K'&WHAT-1\n&TWHAT   SETC  '&WHAT'(2,&LWHAT)\n&LABEL   L     &REG,&TWHAT\n         MEXIT\n.*\n.CLEAR   ANOP\n&LABEL   SLR   &REG,&REG\n         MEXIT\n.*\n.ZERO    ANOP\n&LABEL   SR    &REG,&REG\n         MEXIT\n.*\n.SKIP    ANOP\n*              instruction suppressed; register already contains value\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IM#SECT": {"ttr": 5900, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x16\\x00\\x16\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   IM#SECT &SECT\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n         AIF   ('&SECT' EQ 'LABEL').DS0H\n         AIF   ('&SECT' NE 'DSECT').NDSECT\n&LABEL   DSECT ,\n         MEXIT\n.*\n.NDSECT  AIF   ('&SECT' NE 'CSECT').NCSECT\n&LABEL   CSECT ,\n         MEXIT\n.*\n.NCSECT  AIF   ('&SECT' EQ '').DS0H\n&LABEL   DS    0&SECT\n         MEXIT\n.*\n.DS0H    ANOP\n         AIF   ('&LABEL' EQ '').DONE\n&LABEL   DS    0H\n.DONE    MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IM#SPLIT": {"ttr": 5902, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00/\\x00/\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 47, "newlines": 47, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n         IM#SPLIT\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n         GBLC  &G#SUBL(8)\n         LCLC  &C\n         LCLA  &DEPTH,&I,&IFIRST,&ILAST,&LX\n.*\n&G#SUBL(1) SETC ''\n&G#SUBL(2) SETC ''\n&G#SUBL(3) SETC ''\n&G#SUBL(4) SETC ''\n&G#SUBL(5) SETC ''\n&G#SUBL(6) SETC ''\n&G#SUBL(7) SETC ''\n&G#SUBL(8) SETC ''\n&I       SETA  2\n&IFIRST  SETA  2\n&ILAST   SETA  K'&SYSLIST(1)\n.LOOP    ANOP\n&C       SETC  '&SYSLIST(1)'(&I,1)\n         AIF   ('&C' NE '(').CKRP\n&DEPTH   SETA  &DEPTH+1\n         AGO   .BUMP\n.CKRP    AIF   ('&C' NE ')').CKCOMMA\n&DEPTH   SETA  &DEPTH-1\n         AGO   .BUMP\n.CKCOMMA AIF   ('&C' NE ',').BUMP\n         AIF   (&DEPTH GT 0).BUMP\n.*\n.*  G#SUBL(LX) = sublist string\n.*\n.NEW     ANOP\n&LX      SETA  &LX+1\n         AIF   (&LX GT 8).ERR\n&G#SUBL(&LX) SETC '&SYSLIST(1)'(&IFIRST,&I-&IFIRST)\n&IFIRST  SETA  &I+1\n.*\n.BUMP    ANOP\n&I       SETA  &I+1\n         AIF   (&I LT &ILAST).LOOP\n         AIF   (&IFIRST LT &ILAST).NEW\n         MEXIT\n.*\n.ERR     MNOTE *,'IM#SPLIT LX > 8'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IM#STA": {"ttr": 5904, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x12\\x00\\x12\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   IM#STA &WHAT,&WHERE,&REG=R0\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n.*---------------------------------------------------------------------\n.* &WHAT  - what value to store\n.* &WHERE - field into which to store &WHAT\n.* &REG   - register to use to L, LR, etc. &WHAT field\n.*---------------------------------------------------------------------\n         AIF   ('&WHAT'(1,1) EQ '(').LR\n&LABEL   IM#LALR  &REG(1),&WHAT\n         ST    &REG(1),&WHERE\n         MEXIT\n.*\n.LR      ANOP\n&LABEL   ST    &WHAT(1),&WHERE\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IM#SUBL": {"ttr": 5906, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   IM#SUBL &SPEC\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n         GBLA  &#SUBLN\n         GBLA  &#SUBLNI(8)\n         GBLC  &#SUBLC(8)\n         LCLC  &JUNK(8)\n         LCLA  &I,&MAXL\n&MAXL    SETA  8                           max # operands examined\n&#SUBLN  SETA  0\n.*\n.LOOP        ANOP\n&I           SETA  &I+1\n&#SUBLC(&I)  SETC  '&SYSLIST(&I)'\n&JUNK(1)     SETC  '&SPEC(1)'\n&JUNK(2)     SETC  '&SPEC(2)'\n&JUNK(3)     SETC  '&SPEC(3)'\n&JUNK(4)     SETC  '&SPEC(4)'\n             AIF   ('&#SUBLC(&I)' EQ '').DONE\n&#SUBLN      SETA  &#SUBLN+1\n         MNOTE *,'IM#SUBL I &I JUNK(1) &JUNK(1)'\n         MNOTE *,'IM#SUBL I &I JUNK(2) &JUNK(2)'\n         MNOTE *,'IM#SUBL I &I JUNK(3) &JUNK(3)'\n         MNOTE *,'IM#SUBL I &I JUNK(4) &JUNK(4)'\n         MNOTE *,'IM#SUBL I &I #SUBLNI &#SUBLNI(&I) #SUBLC &#SUBLC(&I)'\n         AIF   (&I LT &MAXL).LOOP\n.*\n.DONE    MNOTE *,'IM#SUBL SUBLN &#SUBLN'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JASM": {"ttr": 5908, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x03\\x00\\x03\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 3, "newlines": 3, "modlines": 0, "user": "XV0006"}, "text": "//TESTASM  JOB CLASS=A,MSGCLASS=A,MSGLEVEL=(2,0)\n//SINGLE  EXEC ASM370,M=TESTASM\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JBUGPDS": {"ttr": 5910, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00-\\x00-\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "XV0006"}, "text": "//RECVPDS  JOB 'DEMO DSORG=PO',CLASS=A,MSGCLASS=A\n//*\n//* TRANSMIT AND RECEIVE PDS\n//*\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD SYSOUT=*\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n//SYSIN     DD *\n SCRATCH DSNAME=SYS2.RECV370.DEMO.PDS,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.RECV370.DEMO.PDS\n//*\n//XMIT370  EXEC PGM=XMIT370\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//XMITDBUG  DD DSN=SYS2.XMIT370.ASM(KBUGXMIT),DISP=SHR\n//XMITLOG   DD SYSOUT=*\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD DSN=SYS2.XMIT370.ASM,DISP=SHR\n//SYSUT2    DD DSN=&&SYSUT2,\n//             UNIT=SYSDA,                            SYSALLDA\n//             SPACE=(CYL,(5,1)),\n//             DISP=(,DELETE,DELETE)\n//XMITOUT   DD DSN=&&XMIT,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,1)),\n//             DISP=(,PASS,DELETE)\n//SYSIN     DD DUMMY\n//SYSUDUMP  DD SYSOUT=*\n//*\n//RECV370  EXEC PGM=RECV370\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//RECVDBUG  DD DSN=SYS2.XMIT370.ASM(KBUGRECV),DISP=SHR\n//RECVLOG   DD SYSOUT=*\n//XMITIN    DD DSN=&&XMIT,DISP=(OLD,DELETE,DELETE)\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD DSN=&&SYSUT1,\n//             UNIT=SYSDA,                            SYSALLDA\n//             SPACE=(CYL,(5,1)),\n//             DISP=(,DELETE,DELETE)\n//SYSUT2    DD DSN=SYS2.RECV370.DEMO.PDS,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,1,45),RLSE),\n//             DISP=(,CATLG,DELETE)\n//SYSIN     DD DUMMY\n//SYSUDUMP  DD SYSOUT=*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JBUGPDSZ": {"ttr": 6145, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00<\\x00<\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 60, "newlines": 60, "modlines": 0, "user": "XV0006"}, "text": "//RECVPDS  JOB 'DEMO DSORG=PO',CLASS=A,MSGCLASS=A\n//*\n//* TRANSMIT AND RECEIVE PDS, ZAP DUMP\n//*\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD SYSOUT=*\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n//SYSIN     DD *\n SCRATCH DSNAME=SYS2.XMIT370.DEMO.XMIT,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.XMIT370.DEMO.XMIT\n SCRATCH DSNAME=SYS2.XMIT370.IEBCOPY.DATA,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.XMIT370.IEBCOPY.DATA\n SCRATCH DSNAME=SYS2.RECV370.DEMO.PDS,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.RECV370.DEMO.PDS\n//*\n//XMIT370  EXEC PGM=XMIT370\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//XMITDBUG  DD DSN=SYS2.XMIT370.ASM(KBUGXMIT),DISP=SHR\n//XMITLOG   DD SYSOUT=*\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD DSN=SYS2.XMIT370.ASM,DISP=SHR\n//SYSUT2    DD DSN=&&SYSUT2,\n//             UNIT=SYSDA,                            SYSALLDA\n//             SPACE=(CYL,(5,1)),\n//             DISP=(,DELETE,DELETE)\n//XMITOUT   DD DSN=SYS2.XMIT370.DEMO.XMIT,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,1)),\n//             DISP=(,CATLG)\n//SYSIN     DD DUMMY\n//SYSUDUMP  DD SYSOUT=*\n//COPYR1    DD DUMMY\n//*\n//RECV370  EXEC PGM=RECV370\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//RECVDBUG  DD DSN=SYS2.XMIT370.ASM(KBUGRECV),DISP=SHR\n//RECVLOG   DD SYSOUT=*\n//XMITIN    DD DSN=SYS2.XMIT370.DEMO.XMIT,DISP=SHR\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD DSN=SYS2.XMIT370.IEBCOPY.DATA,\n//             UNIT=SYSDA,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,1)),\n//             DISP=(,CATLG,CATLG)\n//SYSUT2    DD DSN=SYS2.RECV370.DEMO.PDS,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,1,45),RLSE),\n//             DISP=(,CATLG,DELETE)\n//SYSIN     DD DUMMY\n//SYSUDUMP  DD SYSOUT=*\n//*\n//ZAP      EXEC PGM=IKJEFT01,REGION=1024K,DYNAMNBR=20,COND=EVEN\n//SYSPRINT  DD SYSOUT=*\n//SYSHELP   DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT  DD SYSOUT=*\n//ZAPLOG    DD SYSOUT=*\n//SYSTSIN   DD *\nZAP 'SYS2.XMIT370.IEBCOPY.DATA' NOT3270 LOG VERBOSE\nDUMP\nEND\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JBUGRECV": {"ttr": 6147, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "XV0006"}, "text": "//RECV370  JOB TESTING,REGION=1024K,MSGCLASS=A,CLASS=A\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD SYSOUT=*\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n SCRATCH DSNAME=SYS2.RECV370.DEMO.PDS,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.RECV370.DEMO.PDS\n SCRATCH DSNAME=SYS2.RECV370.SYSUT1,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.RECV370.SYSUT1\n//*\n//RECV370  EXEC PGM=RECV370\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//RECVLOG   DD SYSOUT=*\n//XMITIN    DD DSN=SYS2.XMIT370.DEMO.XMIT,DISP=SHR\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DUMMY\n//SYSUT1    DD DSN=SYS2.RECV370.SYSUT1,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(10,10),RLSE),\n//             DISP=(,CATLG)\n//SYSUT2    DD DSN=SYS2.RECV370.DEMO.PDS,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(10,10,45),RLSE),\n//             DISP=(,CATLG)\n//RECVDBUG  DD DSN=SYS2.XMIT370.ASM(KBUGRECV),DISP=SHR\n//SYSUDUMP  DD SYSOUT=*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JBUGSEQ": {"ttr": 6149, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x006\\x006\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 54, "newlines": 54, "modlines": 0, "user": "XV0006"}, "text": "//RECVSEQ  JOB 'DEMO DSORG=PS',CLASS=A,MSGCLASS=A\n//*\n//* TRANSMIT AND RECEIVE SEQUENTIAL DATASET\n//*\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD SYSOUT=*\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n//SYSIN     DD *\n SCRATCH DSNAME=SYS2.RECV370.DEMO.SEQ,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.RECV370.DEMO.SEQ\n//*--------------------------------------------------------------------\n//GENER    EXEC PGM=IEBGENER\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD *\nThis is a sample sequential dataset\nLine 2\nLine 3\nLast line\n//SYSUT2    DD DSN=&&SEQ,\n//             UNIT=SYSDA,\n//             SPACE=(CYL,1),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200),\n//             DISP=(,PASS,DELETE)\n//SYSIN     DD DUMMY\n//*--------------------------------------------------------------------\n//XMIT370  EXEC PGM=XMIT370\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//XMITLOG   DD SYSOUT=*\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD DSN=&&SEQ,DISP=(OLD,DELETE,DELETE)\n//SYSUT2    DD DSN=&&SYSUT2,\n//             UNIT=SYSDA,                            SYSALLDA\n//             SPACE=(CYL,(5,1)),\n//             DISP=(,DELETE,DELETE)\n//XMITOUT   DD DSN=&&XMIT,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,1)),\n//             DISP=(,PASS,DELETE)\n//SYSIN     DD DUMMY\n//SYSUDUMP  DD SYSOUT=*\n//*--------------------------------------------------------------------\n//RECV370  EXEC PGM=RECV370\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//RECVLOG   DD SYSOUT=*\n//RECVDBUG  DD DSN=SYS2.XMIT370.ASM(KBUGRECV),DISP=SHR\n//XMITIN    DD DSN=&&XMIT,DISP=(OLD,DELETE,DELETE)\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD DSN=SYS2.RECV370.DEMO.SEQ,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,1),RLSE),\n//             DISP=(,CATLG,DELETE)\n//SYSIN     DD DUMMY\n//SYSUDUMP  DD SYSOUT=*\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JBUGTINY": {"ttr": 6151, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00@\\x00@\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 64, "newlines": 64, "modlines": 0, "user": "XV0006"}, "text": "//RECVPDS  JOB 'DEMO DSORG=PO',CLASS=A,MSGCLASS=A\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD SYSOUT=*\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n//SYSIN     DD *\n SCRATCH DSNAME=SYS2.XMIT370.IEBCOPY.DATA,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.XMIT370.IEBCOPY.DATA\n SCRATCH DSNAME=SYS2.RECV370.DEMO.PDS,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.RECV370.DEMO.PDS\n//*\n//RECV370  EXEC PGM=RECV370\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//RECVDBUG  DD *\nDEFAULT  1\nU370DBUG 1     TURN ON DEBUG MSGS RIGHT AWAY\nRECV370  9\nRECVBLK  0\nRECVCTL  5\nRECVGCTL 2\nRECVGSEG 2\nRECVMSG  9\nRECVRCPY 2\nRECVUTIL 9\nU370ABND 0\nU370AP00 1\nU370AP99 1\nU370CHAR 0\nU370HERC 9\nU370HEX  0\nU370LOG  0\nU370PSR  0\nU370QENV 2\nU370QTCB 2     3=DUMP TCB, 8=ASCB, 9=ASXB\nU370QSS  2     3=DUMP SSCVT 4=DUMP SSVT\nU370SDWA 4\nU370SNAP 0\nU370STAE 9 4 6 8\nU370TIOT 0\nU370VADR 0\nU370WTO  0\n//RECVLOG   DD SYSOUT=*\n//XMITIN    DD DSN=SYS2.XMIT370.TINY.XMIT,DISP=SHR\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD DSN=SYS2.XMIT370.IEBCOPY.DATA,\n//             UNIT=SYSDA,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,1)),\n//             DISP=(,CATLG,CATLG)\n//SYSUT2    DD DSN=SYS2.RECV370.DEMO.PDS,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,1,45),RLSE),\n//             DISP=(,CATLG,DELETE)\n//SYSIN     DD DUMMY\n//SYSUDUMP  DD SYSOUT=*\n//*\n//ZAP      EXEC PGM=IKJEFT01,REGION=1024K,DYNAMNBR=20,COND=EVEN\n//SYSPRINT  DD SYSOUT=*\n//SYSHELP   DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT  DD SYSOUT=*\n//ZAPLOG    DD SYSOUT=*\n//SYSTSIN   DD *\nZAP 'SYS2.XMIT370.IEBCOPY.DATA' NOT3270 LOG VERBOSE\nDUMP\nEND\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JBUGTNYZ": {"ttr": 6153, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00W\\x00W\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 87, "newlines": 87, "modlines": 0, "user": "XV0006"}, "text": "//RECVPDS  JOB 'DEMO DSORG=PO',CLASS=A,MSGCLASS=A\n//*\n//* TRANSMIT AND RECEIVE PDS, ZAP DUMP\n//*\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD SYSOUT=*\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n//SYSIN     DD *\n SCRATCH DSNAME=SYS2.XMIT370.MVS38J.TINY.XMIT,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.XMIT370.MVS38J.TINY.XMIT\n SCRATCH DSNAME=SYS2.RECV370.IEBCOPY.UNLOAD,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.RECV370.IEBCOPY.UNLOAD\n SCRATCH DSNAME=SYS2.RECV370.DEMO.PDS,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.RECV370.DEMO.PDS\n//*\n//XMIT370  EXEC PGM=XMIT370\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//XMITDBUG  DD DSN=SYS2.XMIT370.ASM(KBUGXMIT),DISP=SHR\n//XMITLOG   DD SYSOUT=*\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD DSN=SYS2.XMIT370.TINY.PDS,DISP=SHR\n//SYSUT2    DD DSN=&&SYSUT2,\n//             UNIT=SYSDA,                            SYSALLDA\n//             SPACE=(CYL,(5,1)),\n//             DISP=(,DELETE,DELETE)\n//XMITOUT   DD DSN=SYS2.XMIT370.MVS38J.TINY.XMIT,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,1)),\n//             DISP=(,CATLG)\n//SYSIN     DD DUMMY\n//SYSUDUMP  DD SYSOUT=*\n//COPYR1    DD DUMMY\n//*\n//RECV370  EXEC PGM=RECV370\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//RECVDBUG  DD *\nDEFAULT  1\nU370DBUG 1     TURN ON DEBUG MSGS RIGHT AWAY\nRECV370  9\nRECVBLK  0\nRECVCTL  5\nRECVGCTL 2\nRECVGSEG 2\nRECVMSG  9\nRECVRCPY 2\nRECVUTIL 9\nU370ABND 0\nU370AP00 1\nU370AP99 1\nU370CHAR 0\nU370HERC 9\nU370HEX  0\nU370LOG  0\nU370PSR  0\nU370QENV 2\nU370QTCB 2     3=DUMP TCB, 8=ASCB, 9=ASXB\nU370QSS  2     3=DUMP SSCVT 4=DUMP SSVT\nU370SDWA 4\nU370SNAP 0\nU370STAE 9 4 6 8\nU370TIOT 0\nU370VADR 0\nU370WTO  0\n//RECVLOG   DD SYSOUT=*\n//XMITIN    DD DSN=SYS2.XMIT370.MVS38J.TINY.XMIT,DISP=SHR\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD DSN=SYS2.RECV370.IEBCOPY.UNLOAD,\n//             UNIT=SYSDA,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,1)),\n//             DISP=(,CATLG,CATLG)\n//SYSUT2    DD DSN=SYS2.RECV370.DEMO.PDS,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,1,45),RLSE),\n//             DISP=(,CATLG,DELETE)\n//SYSIN     DD DUMMY\n//SYSUDUMP  DD SYSOUT=*\n//*\n//ZAP      EXEC PGM=IKJEFT01,REGION=1024K,DYNAMNBR=20,COND=EVEN\n//SYSPRINT  DD SYSOUT=*\n//SYSHELP   DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT  DD SYSOUT=*\n//ZAPLOG    DD SYSOUT=*\n//SYSTSIN   DD *\nZAP 'SYS2.RECV370.IEBCOPY.UNLOAD' NOT3270 LOG VERBOSE\nDUMP\nEND\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JBUGXMIT": {"ttr": 6156, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "XV0006"}, "text": "//XMIT370  JOB 'CBT FILE 571',REGION=1024K,MSGCLASS=A,CLASS=A\n//*JOBPARM LINECT=0\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD SYSOUT=*\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n SCRATCH DSNAME=SYS2.XMIT.XXXX370,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.XMIT.XXXX370\n//*\n//XMIT370  EXEC PGM=XMIT370,PARM=1\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//XMITLOG   DD SYSOUT=*\n//SYSPRINT  DD SYSOUT=*\n//SYSUDUMP  DD SYSOUT=*\n//SYSIN     DD DUMMY\n//SYSUT1    DD DSN=SYS2.XMIT370.ASM,DISP=SHR\n//SYSUT2    DD DSN=&&SYSUT2,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(10,1),RLSE),\n//             DISP=(,DELETE,DELETE)\n//XMITOUT   DD DSN=SYS2.XMIT.XXXX370,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(10,2),RLSE),\n//             DISP=(,CATLG)\n//XMITDBUG  DD DSN=SYS2.XMIT370.ASM(KBUGXMIT),DISP=SHR\n//COPYR1    DD DUMMY\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JCBTLOAD": {"ttr": 6158, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00\\r\\x00\\r\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "XV0006"}, "text": "//RELOAD   JOB CBT,REGION=1024K,MSGCLASS=A,CLASS=A\n//IEBCOPY  EXEC PGM=IEBCOPY\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD DSN=JMM.V0005.BETA02.CBT,\n//             UNIT=TAPE,VOL=SER=XV0005,\n//             LABEL=(1,SL),\n//             DISP=OLD\n//SYSUT2    DD DSN=JMM.XMIT370.ASM.TEST,\n//             UNIT=3350,VOL=SER=MVS509,\n//             SPACE=(CYL,(5,5,15),RLSE),\n//             DISP=(,CATLG)\n//SYSIN     DD DUMMY\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JCBTUNLD": {"ttr": 6160, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00\\n\\x00\\n\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "XV0006"}, "text": "//UNLOAD   JOB CBT,REGION=1024K,MSGCLASS=A,CLASS=A\n//IEBCOPY  EXEC PGM=IEBCOPY\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD DSN=SYS2.XMIT370.ASM,DISP=SHR\n//SYSUT2    DD DSN=SYS2.XMIT370.V0005.CBT,\n//             UNIT=TAPE,VOL=SER=XV0005,\n//             LABEL=(1,SL),\n//             DISP=(,CATLG)\n//SYSIN     DD DUMMY\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JCBTXMIT": {"ttr": 6162, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "XV0006"}, "text": "//XMITPDS  JOB CLASS=A,MSGCLASS=A\n//*\n//* TRANSMIT SYS2.XMIT370.ASM (CBT FILE 571 SOURCE PDS)\n//*\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD SYSOUT=*\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n//SYSIN     DD *\n SCRATCH DSNAME=JMM.XMIT.XXXX370,VOL=3380=MVS809\n UNCATLG DSNAME=JMM.XMIT.XXXX370\n//* -------------------------------------------------------------------\n//XMIT370  EXEC PGM=XMIT370\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//COPYR1    DD DUMMY\n//XMITLOG   DD SYSOUT=*\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD DSN=SYS2.XMIT370.ASM,DISP=SHR\n//SYSUT2    DD DSN=&&SYSUT2,\n//             UNIT=SYSDA,                            SYSALLDA\n//             SPACE=(CYL,(10,2)),\n//             DISP=(,DELETE,DELETE)\n//XMITOUT   DD DSN=JMM.XMIT.XXXX370,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(10,10),RLSE),\n//             DISP=(,CATLG)\n//SYSIN     DD DUMMY\n//SYSUDUMP  DD SYSOUT=*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JCOMP": {"ttr": 6164, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\r\\x00\\r\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "XV0006"}, "text": "//COMPRESS JOB CLASS=A,MSGCLASS=A\n//*\n//COMPRESS PROC DS=NULLFILE\n//IEBCOPY  EXEC PGM=IEBCOPY,REGION=2048K\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD DSN=&DS,DISP=SHR\n//SYSUT2    DD DSN=&DS,DISP=SHR\n//SYSIN     DD DUMMY\n//         PEND\n//*\n//ASM      EXEC COMPRESS,DS='SYS2.XMIT370.ASM'\n//LINK     EXEC COMPRESS,DS='SYS2.LOCAL.LINKLIB'\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JCOPY": {"ttr": 6166, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\t\\x00\\t\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "XV0006"}, "text": "//COPY     JOB CLASS=A,MSGCLASS=A\n//*\n//IEBCOPY  EXEC PGM=IEBCOPY,REGION=2048K\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD DSN=SYS1.IMON370.LOAD,DISP=SHR\n//SYSUT2    DD DSN=SYS2.LOCAL.CMDLIB,DISP=SHR\n//SYSIN     DD *\n COPY OUTDD=SYSUT2,INDD=((SYSUT1,R))\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JDAST": {"ttr": 6168, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x07\\x00\\x07\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 7, "newlines": 7, "modlines": 0, "user": "XV0006"}, "text": "//DAS      JOB TESTING,REGION=1024K,MSGCLASS=A,CLASS=A\n//DAST370  EXEC PGM=DAST370\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//DASTDBUG  DD DSN=SYS2.XMIT370.ASM(KBUGDAST),DISP=SHR\n//DASTLOG   DD SYSOUT=*\n//SYSUDUMP  DD SYSOUT=*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JDASTALL": {"ttr": 6170, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00*\\x00*\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "XV0006"}, "text": "//INSTALL  JOB XMIT370,CLASS=A,MSGCLASS=A,\n//             MSGLEVEL=(2,0)\n//*            RESTART=U370AP00.ASMBLR\n//*            RESTART=LINK\n//*\n//* PRECEDESSOR JOB: JU370ALL\n//*\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD DUMMY\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n SCRATCH DSNAME=SYS2.DAST370.LIST,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.DAST370.LIST\n SCRATCH DSNAME=SYS2.DAST370.OBJ,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.DAST370.OBJ\n//*\n//ALLOC    EXEC PGM=IEFBR14\n//LIST      DD DSN=SYS2.DAST370.LIST,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(20,0,5),RLSE),\n//             DCB=(RECFM=FB,LRECL=121,BLKSIZE=23474),\n//             DISP=(,CATLG)\n//OBJ       DD DSN=SYS2.DAST370.OBJ,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,0,5),RLSE),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200),\n//             DISP=(,CATLG)\n//*\n//DAST370  EXEC ASM370,APP=DAST,M=DAST370\n//DASTMVCP EXEC ASM370,APP=DAST,M=DASTMVCP\n//DASTVTAB EXEC ASM370,APP=DAST,M=DASTVTAB\n//* -------------------------------------------------------------------\n//LINK     EXEC PGM=IEWL,\n//             COND=(5,LT),\n//             PARM='LIST,MAP,XREF,LET,RENT'\n//SYSPRINT  DD SYSOUT=*\n//SYSLMOD   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//U370LIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//SYSLIB    DD DSN=SYS2.DAST370.OBJ,DISP=SHR\n//SYSUT1    DD UNIT=SYSDA,SPACE=(TRK,(5,5))\n//SYSLIN    DD DSN=SYS2.XMIT370.ASM(KLNKU370),DISP=SHR\n//          DD DSN=SYS2.XMIT370.ASM(KLNKDAST),DISP=SHR\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JDAST1": {"ttr": 6172, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00\\x10\\x00\\x10\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "XV0006"}, "text": "//INSTALL  JOB XMIT370,CLASS=A,MSGCLASS=A,\n//             MSGLEVEL=(2,0) NOTIFY=N9GTM\n//*            RESTART=XMITVTAB.ASMBLR\n//* -------------------------------------------------------------------\n//SINGLE   EXEC ASM370,APP=DAST,M=DAST370\n//* -------------------------------------------------------------------\n//LINK     EXEC PGM=IEWL,\n//             COND=(5,LT),\n//             PARM='LIST,MAP,XREF,LET,NCAL,RENT'\n//SYSPRINT  DD SYSOUT=*\n//SYSLMOD   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//U370LIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//SYSLIB    DD DSN=SYS2.DAST370.OBJ,DISP=SHR\n//SYSUT1    DD UNIT=SYSDA,SPACE=(TRK,(5,5))\n//SYSLIN    DD DSN=SYS2.XMIT370.ASM(KLNKDAST),DISP=SHR\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JDEMOCP1": {"ttr": 6401, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00.\\x00.\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "XV0006"}, "text": "//RECVPDS  JOB 'DEMO DSORG=PO',CLASS=A,MSGCLASS=A\n//*\n//* TRANSMIT AND RECEIVE PDS - //COPYR1\n//*\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD SYSOUT=*\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n//SYSIN     DD *\n SCRATCH DSNAME=SYS2.XMIT370.DEMO.XMIT,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.XMIT370.DEMO.XMIT\n SCRATCH DSNAME=SYS2.RECV370.DEMO.PDS,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.RECV370.DEMO.PDS\n//*\n//XMIT370  EXEC PGM=XMIT370\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//COPYR1    DD DUMMY\n//XMITLOG   DD SYSOUT=*\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD DSN=SYS2.XMIT370.ASM,DISP=SHR\n//SYSUT2    DD DSN=&&SYSUT2,\n//             UNIT=SYSDA,                            SYSALLDA\n//             SPACE=(CYL,(5,1)),\n//             DISP=(,DELETE,DELETE)\n//XMITOUT   DD DSN=SYS2.XMIT370.DEMO.XMIT,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,1)),\n//             DISP=(,CATLG)\n//SYSIN     DD DUMMY\n//SYSUDUMP  DD SYSOUT=*\n//*\n//RECV370  EXEC PGM=RECV370\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//RECVLOG   DD SYSOUT=*\n//XMITIN    DD DSN=SYS2.XMIT370.DEMO.XMIT,DISP=SHR\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD DSN=&&SYSUT1,\n//             UNIT=SYSDA,                            SYSALLDA\n//             SPACE=(CYL,(5,1)),\n//             DISP=(,DELETE,DELETE)\n//SYSUT2    DD DSN=SYS2.RECV370.DEMO.PDS,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,1,45),RLSE),\n//             DISP=(,CATLG,DELETE)\n//SYSIN     DD DUMMY\n//SYSUDUMP  DD SYSOUT=*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JDUMPSSN": {"ttr": 6403, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x07\\x00\\x07\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 7, "newlines": 7, "modlines": 0, "user": "XV0006"}, "text": "//DUMPSSNT JOB CLASS=A,MSGCLASS=A\n//IMASPZAP EXEC PGM=IMASPZAP\n//SYSPRINT  DD SYSOUT=A\n//SYSLIB    DD DSN=SYS1.LINKLIB,DISP=SHR\n//SYSIN     DD *\n DUMPT IEFJSSNT\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JINITT": {"ttr": 6405, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x07\\x00\\x07\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 7, "newlines": 7, "modlines": 0, "user": "XV0006"}, "text": "//INITT    JOB CLASS=A,MSGCLASS=A\n//IEHINITT EXEC PGM=IEHINITT\n//SYSPRINT  DD SYSOUT=*\n//TAPE      DD UNIT=(TAPE,,DEFER),DCB=DEN=4  6250 BPI\n//SYSIN     DD *\nTAPE     INITT SER=XV0005,OWNER='N9GTM'\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JINSTALL": {"ttr": 6407, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00j\\x00j\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 106, "newlines": 106, "modlines": 0, "user": "XV0006"}, "text": "//INSTALL  JOB XMIT370,CLASS=A,MSGCLASS=A,\n//             MSGLEVEL=(2,0) NOTIFY=N9GTM\n//*            RESTART=LINK\n//*            RESTART=XMIT06.ASMBLR\n//* -------------------------------------------------------------------\n//ASM370   PROC M=MISSING,LIST=,PRT=DISK\n//ASMBLR   EXEC PGM=IFOX00,\n//             COND=(5,LT),\n//             REGION=6144K,\n//             PARM='&LIST.LIST,NOXREF,NORLD,LINECOUNT(999)'\n//SYSPRINT  DD DDNAME=&PRT\n//SYSOUT    DD SYSOUT=*\n//DISK      DD DSN=SYS2.XMIT370.LIST(&M),DISP=SHR\n//SYSLIB    DD DSN=SYS2.XMIT370.ASM,DISP=SHR,\n//             DCB=BLKSIZE=32720\n//          DD DSN=SYS1.AMACLIB,DISP=SHR\n//          DD DSN=SYS1.AMODGEN,DISP=SHR\n//          DD DSN=SYS1.AGENLIB,DISP=SHR\n//SYSPUNCH  DD DSN=SYS2.XMIT370.OBJ(&M),DISP=SHR\n//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(35,10))\n//SYSUT2    DD UNIT=SYSDA,SPACE=(CYL,(35,10))\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(50,10))\n//SYSIN     DD DSN=SYS2.XMIT370.ASM(&M),DISP=SHR\n//         PEND\n//* -------------------------------------------------------------------\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD DUMMY\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n SCRATCH DSNAME=SYS2.XMIT370.LIST,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.XMIT370.LIST\n SCRATCH DSNAME=SYS2.XMIT370.OBJ,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.XMIT370.OBJ\n//*\n//ALLOC    EXEC PGM=IEFBR14\n//LIST      DD DSN=SYS2.XMIT370.LIST,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(20,0,5),RLSE),\n//             DCB=(RECFM=FB,LRECL=121,BLKSIZE=23474),\n//             DISP=(,CATLG)\n//OBJ       DD DSN=SYS2.XMIT370.OBJ,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,0,5),RLSE),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200),\n//             DISP=(,CATLG)\n//*\n//* -------------------------------------------------------------------\n//DASTMVCP EXEC ASM370,M=DASTMVCP\n//DASTVTAB EXEC ASM370,M=DASTVTAB\n//DAST370  EXEC ASM370,M=DAST370\n//RECVBLK  EXEC ASM370,M=RECVBLK\n//RECVCTL  EXEC ASM370,M=RECVCTL\n//RECVGCTL EXEC ASM370,M=RECVGCTL\n//RECVGSEG EXEC ASM370,M=RECVGSEG\n//RECVMSG  EXEC ASM370,M=RECVMSG\n//RECVRCPY EXEC ASM370,M=RECVRCPY\n//RECVUTIL EXEC ASM370,M=RECVUTIL\n//RECVVTAB EXEC ASM370,M=RECVVTAB\n//RECV370  EXEC ASM370,M=RECV370\n//U370ABND EXEC ASM370,M=U370ABND\n//U370AP00 EXEC ASM370,M=U370AP00\n//U370AP99 EXEC ASM370,M=U370AP99\n//U370CHAR EXEC ASM370,M=U370CHAR\n//U370DATE EXEC ASM370,M=U370DATE\n//U370DBUG EXEC ASM370,M=U370DBUG\n//U370HERC EXEC ASM370,M=U370HERC\n//U370HEX  EXEC ASM370,M=U370HEX\n//U370LOG  EXEC ASM370,M=U370LOG\n//U370PSR  EXEC ASM370,M=U370PSR\n//U370QENV EXEC ASM370,M=U370QENV\n//U370QSS  EXEC ASM370,M=U370QSS\n//U370QTCB EXEC ASM370,M=U370QTCB\n//U370SDWA EXEC ASM370,M=U370SDWA\n//U370SNAP EXEC ASM370,M=U370SNAP\n//U370STAE EXEC ASM370,M=U370STAE\n//U370TIOT EXEC ASM370,M=U370TIOT\n//U370VADR EXEC ASM370,M=U370VADR\n//U370WTO  EXEC ASM370,M=U370WTO\n//XMITBUF  EXEC ASM370,M=XMITBUF\n//XMITCPR1 EXEC ASM370,M=XMITCPR1\n//XMITDIR  EXEC ASM370,M=XMITDIR\n//XMITESZ  EXEC ASM370,M=XMITESZ\n//XMITKDSN EXEC ASM370,M=XMITKDSN\n//XMITKEY  EXEC ASM370,M=XMITKEY\n//XMITPUT  EXEC ASM370,M=XMITPUT\n//XMITUNLD EXEC ASM370,M=XMITUNLD\n//XMITVTAB EXEC ASM370,M=XMITVTAB\n//XMIT01   EXEC ASM370,M=XMIT01\n//XMIT02A  EXEC ASM370,M=XMIT02A\n//XMIT02B  EXEC ASM370,M=XMIT02B\n//XMIT03   EXEC ASM370,M=XMIT03\n//XMIT06   EXEC ASM370,M=XMIT06\n//XMIT370  EXEC ASM370,M=XMIT370\n//* -------------------------------------------------------------------\n//LINK     EXEC PGM=IEWL,\n//             COND=(5,LT),\n//             PARM='LIST,MAP,XREF,LET,NCAL,RENT'\n//SYSPRINT  DD SYSOUT=*\n//SYSLMOD   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//U370LIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//SYSLIB    DD DSN=SYS2.XMIT370.OBJ,DISP=SHR\n//SYSUT1    DD UNIT=SYSDA,SPACE=(TRK,(5,5))\n//SYSLIN    DD DSN=SYS2.XMIT370.ASM(KLNKU370),DISP=SHR\n//          DD DSN=SYS2.XMIT370.ASM(KLNKDAST),DISP=SHR\n//          DD DSN=SYS2.XMIT370.ASM(KLNKRECV),DISP=SHR\n//          DD DSN=SYS2.XMIT370.ASM(KLNKXMIT),DISP=SHR\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JINSTAL1": {"ttr": 6410, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x006\\x01\\x021o\\x01\\x08\\x10/\\x11!\\x00h\\x00d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2008-04-11T11:21:36", "lines": 104, "newlines": 100, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBX  JOB (ACCT#),S-GOLOB,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X\n//* -------------------------------------------------------------------\n//ASM370   PROC M=MISSING,LIST=,PRT=DISK\n//ASMBLR   EXEC PGM=IFOX00,\n//             COND=(5,LT),\n//             REGION=6144K,\n//             PARM='&LIST.LIST,NOXREF,NORLD,LINECOUNT(999)'\n//STEPLIB   DD DISP=SHR,DSN=SBGOLOB.W$$.LINKLIB\n//SYSPRINT  DD DDNAME=&PRT\n//SYSOUT    DD SYSOUT=*\n//DISK      DD DSN=SBGOLOB.RECV370A.LIST(&M),DISP=SHR\n//SYSLIB    DD DSN=SBGOLOB.RECV370A.PDS,DISP=SHR,      DUPLICATE OF\n//             DCB=BLKSIZE=32720                       DISTRIBUTION PDS\n//          DD DSN=SBGOLOB.MVS38.AMACLIB,DISP=SHR      MVS 3.8\n//          DD DSN=SBGOLOB.MVS38.AMODGEN,DISP=SHR      MVS 3.8\n//          DD DSN=SBGOLOB.MVS38.AGENLIB,DISP=SHR      MVS 3.8\n//SYSPUNCH  DD DSN=SBGOLOB.RECV370A.OBJ(&M),DISP=SHR\n//SYSUT1    DD UNIT=SYSALLDA,SPACE=(CYL,(5,10))\n//SYSUT2    DD UNIT=SYSALLDA,SPACE=(CYL,(5,10))\n//SYSUT3    DD UNIT=SYSALLDA,SPACE=(CYL,(5,10))\n//SYSIN     DD DSN=SBGOLOB.RECV370A.PDS(&M),DISP=SHR\n//         PEND\n//* -------------------------------------------------------------------\n//*\n//ALLOC    EXEC PGM=IEFBR14\n//LIST      DD DSN=SBGOLOB.RECV370A.LIST,\n//             UNIT=SYSALLDA,VOL=SER=WORK07,\n//             SPACE=(CYL,(20,0,44),RLSE),\n//             DCB=(RECFM=FB,LRECL=121,BLKSIZE=23474),\n//             DISP=(,CATLG)\n//OBJ       DD DSN=SBGOLOB.RECV370A.OBJ,\n//             UNIT=SYSALLDA,VOL=SER=WORK07,\n//             SPACE=(CYL,(5,0,44),RLSE),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200),\n//             DISP=(,CATLG)\n//LOAD      DD DSN=SBGOLOB.RECV370A.LOAD,\n//             UNIT=SYSALLDA,VOL=SER=WORK07,\n//             SPACE=(CYL,(5,1,44),RLSE),\n//             DCB=(RECFM=FB,LRECL=0,BLKSIZE=6144),\n//             DISP=(,CATLG)\n//*\n//* -------------------------------------------------------------------\n//DASTMVCP EXEC ASM370,M=DASTMVCP\n//DASTVTAB EXEC ASM370,M=DASTVTAB\n//DAST370  EXEC ASM370,M=DAST370\n//RECVBLK  EXEC ASM370,M=RECVBLK\n//RECVCTL  EXEC ASM370,M=RECVCTL\n//RECVGCTL EXEC ASM370,M=RECVGCTL\n//RECVGSEG EXEC ASM370,M=RECVGSEG\n//RECVMSG  EXEC ASM370,M=RECVMSG\n//RECVRCPY EXEC ASM370,M=RECVRCPY\n//RECVUTIL EXEC ASM370,M=RECVUTIL\n//RECVVTAB EXEC ASM370,M=RECVVTAB\n//RECV370  EXEC ASM370,M=RECV370\n//U370ABND EXEC ASM370,M=U370ABND\n//U370AP00 EXEC ASM370,M=U370AP00\n//U370AP99 EXEC ASM370,M=U370AP99\n//U370CHAR EXEC ASM370,M=U370CHAR\n//U370DATE EXEC ASM370,M=U370DATE\n//U370DBUG EXEC ASM370,M=U370DBUG\n//U370HERC EXEC ASM370,M=U370HERC\n//U370HEX  EXEC ASM370,M=U370HEX\n//U370LOG  EXEC ASM370,M=U370LOG\n//U370PSR  EXEC ASM370,M=U370PSR\n//U370QENV EXEC ASM370,M=U370QENV\n//U370QSS  EXEC ASM370,M=U370QSS\n//U370QTCB EXEC ASM370,M=U370QTCB\n//U370SDWA EXEC ASM370,M=U370SDWA\n//U370SNAP EXEC ASM370,M=U370SNAP\n//U370STAE EXEC ASM370,M=U370STAE\n//U370TIOT EXEC ASM370,M=U370TIOT\n//U370VADR EXEC ASM370,M=U370VADR\n//U370WTO  EXEC ASM370,M=U370WTO\n//XMITBUF  EXEC ASM370,M=XMITBUF\n//XMITCPR1 EXEC ASM370,M=XMITCPR1\n//XMITDIR  EXEC ASM370,M=XMITDIR\n//XMITESZ  EXEC ASM370,M=XMITESZ\n//XMITKDSN EXEC ASM370,M=XMITKDSN\n//XMITKEY  EXEC ASM370,M=XMITKEY\n//XMITPUT  EXEC ASM370,M=XMITPUT\n//XMITUNLD EXEC ASM370,M=XMITUNLD\n//XMITVTAB EXEC ASM370,M=XMITVTAB\n//XMIT01   EXEC ASM370,M=XMIT01\n//XMIT02A  EXEC ASM370,M=XMIT02A\n//XMIT02B  EXEC ASM370,M=XMIT02B\n//XMIT03   EXEC ASM370,M=XMIT03\n//XMIT06   EXEC ASM370,M=XMIT06\n//XMIT370  EXEC ASM370,M=XMIT370\n//* -------------------------------------------------------------------\n//LINK     EXEC PGM=IEWL,\n//             COND=(5,LT),\n//             PARM='LIST,MAP,XREF,LET,NCAL,RENT'\n//SYSPRINT  DD SYSOUT=*\n//SYSLMOD   DD DSN=SBGOLOB.RECV370A.LOAD,DISP=SHR\n//U370LIB   DD DSN=SBGOLOB.RECV370A.LOAD,DISP=SHR\n//SYSLIB    DD DSN=SBGOLOB.RECV370A.OBJ,DISP=SHR\n//SYSUT1    DD UNIT=SYSALLDA,SPACE=(TRK,(5,5))\n//SYSLIN    DD DSN=SBGOLOB.RECV370A.PDS(KLNKU370),DISP=SHR\n//          DD DSN=SBGOLOB.RECV370A.PDS(KLNKDAST),DISP=SHR\n//          DD DSN=SBGOLOB.RECV370A.PDS(KLNKRECV),DISP=SHR\n//          DD DSN=SBGOLOB.RECV370A.PDS(KLNKXMIT),DISP=SHR\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JLINK": {"ttr": 6413, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\r\\x00\\r\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "XV0006"}, "text": "//LINK     JOB XMIT370,CLASS=A,MSGCLASS=A,\n//             MSGLEVEL=(2,0),NOTIFY=JMM\n//*\n//LINK     EXEC PGM=IEWL,\n//             COND=(5,LT),\n//             PARM='LIST,MAP,XREF,LET,NCAL,RENT'\n//SYSPRINT  DD SYSOUT=*\n//SYSLMOD   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//SYSLIB    DD DSN=SYS2.XMIT370.OBJ,DISP=SHR\n//SYSUT1    DD UNIT=SYSDA,SPACE=(TRK,(5,5))\n//SYSLIN    DD DSN=SYS2.XMIT370.ASM(KXMIT),DISP=SHR   XMIT370\n//          DD DSN=SYS2.XMIT370.ASM(KRECV),DISP=SHR   RECV370\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JLOAD": {"ttr": 6415, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00\\r\\x00\\r\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "XV0006"}, "text": "//RELOAD   JOB ASM,REGION=1024K,MSGCLASS=A,CLASS=A\n//IEBCOPY  EXEC PGM=IEBCOPY\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD DSN=SYS2.XMIT370.ASM,\n//             UNIT=TAPE,VOL=SER=JM4711,\n//             LABEL=(1,SL),\n//             DISP=OLD\n//SYSUT2    DD DSN=MIKE.XMIT370.ASM,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,5,45),RLSE),\n//             DISP=(,KEEP)\n//SYSIN     DD DUMMY\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JRECV": {"ttr": 6417, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00*\\x00*\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "XV0006"}, "text": "//RECV370  JOB TESTING,REGION=1024K,MSGCLASS=A,CLASS=A\n//*            //*JOBPARM LINECT=0\n//*--------------------------------------------------------------------\n//RECV370  PROC XMIT=\n//RECV370  EXEC PGM=RECV370\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//RECVLOG   DD SYSOUT=*\n//XMITIN    DD DSN=SYS2.XMIT370.MVS38J.XMIT&XMIT,DISP=SHR\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DUMMY\n//SYSUT1    DD DSN=SYS2.RECV370.MVS38J.XMIT&XMIT..SYSUT1,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(10,10),RLSE),\n//             DISP=(,CATLG)\n//SYSUT2    DD DSN=SYS2.RECV370.MVS38J.XMIT&XMIT..PDS,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(10,10,15),RLSE),\n//             DISP=(,CATLG)\n//* ITDBUG  DD DSN=SYS2.XMIT370.ASM(KDEBUGR),DISP=SHR\n//SYSUDUMP  DD SYSOUT=*\n//         PEND\n//*--------------------------------------------------------------------\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD DUMMY\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n SCRATCH DSNAME=SYS2.RECV370.MVS38J.XMIT.PDS,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.RECV370.MVS38J.XMIT.PDS\n SCRATCH DSNAME=SYS2.RECV370.MVS38J.XMIT2.PDS,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.RECV370.MVS38J.XMIT2.PDS\n SCRATCH DSNAME=SYS2.RECV370.MVS38J.XMIT3.PDS,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.RECV370.MVS38J.XMIT3.PDS\n SCRATCH DSNAME=SYS2.RECV370.MVS38J.XMIT.SYSUT1,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.RECV370.MVS38J.XMIT.SYSUT1\n SCRATCH DSNAME=SYS2.RECV370.MVS38J.XMIT2.SYSUT1,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.RECV370.MVS38J.XMIT2.SYSUT1\n SCRATCH DSNAME=SYS2.RECV370.MVS38J.XMIT3.SYSUT1,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.RECV370.MVS38J.XMIT3.SYSUT1\n//*\n//RECV1    EXEC RECV370,XMIT=\n//RECV2    EXEC RECV370,XMIT=2\n//RECV3    EXEC RECV370,XMIT=3\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JRECVALL": {"ttr": 6419, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00C\\x00C\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 67, "newlines": 67, "modlines": 0, "user": "XV0006"}, "text": "//INSTALL  JOB RECV370,CLASS=A,MSGCLASS=A,\n//             MSGLEVEL=(2,0)\n//*            RESTART=LINK\n//*            RESTART=U370AP00.ASMBLR\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD DUMMY\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n SCRATCH DSNAME=SYS2.RECV370.LIST,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.RECV370.LIST\n SCRATCH DSNAME=SYS2.RECV370.OBJ,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.RECV370.OBJ\n//*\n//ALLOC    EXEC PGM=IEFBR14\n//LIST      DD DSN=SYS2.RECV370.LIST,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(20,0,5),RLSE),\n//             DCB=(RECFM=FB,LRECL=121,BLKSIZE=23474),\n//             DISP=(,CATLG)\n//OBJ       DD DSN=SYS2.RECV370.OBJ,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,0,5),RLSE),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200),\n//             DISP=(,CATLG)\n//*\n//* STALL  JOB RECV370,CLASS=A,MSGCLASS=A,\n//*            MSGLEVEL=(2,0)\n//* -------------------------------------------------------------------\n//RECVBLK  EXEC ASM370,APP=RECV,M=RECVBLK\n//RECVCTL  EXEC ASM370,APP=RECV,M=RECVCTL\n//RECVGCTL EXEC ASM370,APP=RECV,M=RECVGCTL\n//RECVGSEG EXEC ASM370,APP=RECV,M=RECVGSEG\n//RECVMSG  EXEC ASM370,APP=RECV,M=RECVMSG\n//RECVRCPY EXEC ASM370,APP=RECV,M=RECVRCPY\n//RECVUTIL EXEC ASM370,APP=RECV,M=RECVUTIL\n//RECVVTAB EXEC ASM370,APP=RECV,M=RECVVTAB\n//RECV370  EXEC ASM370,APP=RECV,M=RECV370\n//U370ABND EXEC ASM370,APP=RECV,M=U370ABND\n//U370AP00 EXEC ASM370,APP=RECV,M=U370AP00\n//U370AP99 EXEC ASM370,APP=RECV,M=U370AP99\n//U370CHAR EXEC ASM370,APP=RECV,M=U370CHAR\n//U370DATE EXEC ASM370,APP=RECV,M=U370DATE\n//U370DBUG EXEC ASM370,APP=RECV,M=U370DBUG\n//U370HERC EXEC ASM370,APP=RECV,M=U370HERC\n//U370HEX  EXEC ASM370,APP=RECV,M=U370HEX\n//U370LOG  EXEC ASM370,APP=RECV,M=U370LOG\n//U370PSR  EXEC ASM370,APP=RECV,M=U370PSR\n//U370QENV EXEC ASM370,APP=RECV,M=U370QENV\n//U370QSS  EXEC ASM370,APP=RECV,M=U370QSS\n//U370QTCB EXEC ASM370,APP=RECV,M=U370QTCB\n//U370SDWA EXEC ASM370,APP=RECV,M=U370SDWA\n//U370SNAP EXEC ASM370,APP=RECV,M=U370SNAP\n//U370STAE EXEC ASM370,APP=RECV,M=U370STAE\n//U370TIOT EXEC ASM370,APP=RECV,M=U370TIOT\n//U370VADR EXEC ASM370,APP=RECV,M=U370VADR\n//U370WTO  EXEC ASM370,APP=RECV,M=U370WTO\n//* -------------------------------------------------------------------\n//LINK     EXEC PGM=IEWL,\n//             COND=(5,LT),\n//             PARM='LIST,MAP,XREF,LET,NCAL,RENT'\n//SYSPRINT  DD SYSOUT=*\n//SYSLMOD   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//SYSLIB    DD DSN=SYS2.RECV370.OBJ,DISP=SHR\n//U370LIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//SYSUT1    DD UNIT=SYSDA,SPACE=(TRK,(5,5))\n//SYSLIN    DD DSN=SYS2.XMIT370.ASM(KLNKU370),DISP=SHR\n//          DD DSN=SYS2.XMIT370.ASM(KLNKRECV),DISP=SHR\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JRECVCBT": {"ttr": 6421, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x19\\x00\\x19\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "XV0006"}, "text": "//RECV370  JOB TESTING,REGION=1024K,MSGCLASS=A,CLASS=A\n//*--------------------------------------------------------------------\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD DUMMY\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n SCRATCH DSNAME=JMM.CBT571.PDS,VOL=3380=MVS809\n UNCATLG DSNAME=JMM.CBT571.PDS\n//*--------------------------------------------------------------------\n//RECV370  EXEC PGM=RECV370\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//RECVLOG   DD SYSOUT=*\n//RECVDBUG  DD DSN=SYS2.XMIT370.ASM(KBUGRECV),DISP=SHR\n//XMITIN    DD DSN=JMM.PDS.JCL(CBT571),DISP=SHR\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DUMMY\n//SYSUT1    DD UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(10,10),RLSE),\n//             DISP=(,DELETE,DELETE)\n//SYSUT2    DD DSN=JMM.CBT571.PDS,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(10,10,45),RLSE),\n//             DISP=(,CATLG)\n//*            DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200),\n//SYSUDUMP  DD SYSOUT=*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JRECVPDS": {"ttr": 6423, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00+\\x00+\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 43, "newlines": 43, "modlines": 0, "user": "XV0006"}, "text": "//RECVPDS  JOB 'DEMO DSORG=PO',CLASS=A,MSGCLASS=A\n//*\n//* TRANSMIT AND RECEIVE PDS\n//*\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD SYSOUT=*\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n//SYSIN     DD *\n SCRATCH DSNAME=SYS2.RECV370.DEMO.PDS,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.RECV370.DEMO.PDS\n//*\n//XMIT370  EXEC PGM=XMIT370\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//XMITLOG   DD SYSOUT=*\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD DSN=SYS2.XMIT370.ASM,DISP=SHR\n//SYSUT2    DD DSN=&&SYSUT2,\n//             UNIT=SYSDA,                            SYSALLDA\n//             SPACE=(CYL,(5,1)),\n//             DISP=(,DELETE,DELETE)\n//XMITOUT   DD DSN=&&XMIT,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,1)),\n//             DISP=(,PASS,DELETE)\n//SYSIN     DD DUMMY\n//SYSUDUMP  DD SYSOUT=*\n//*\n//RECV370  EXEC PGM=RECV370\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//RECVLOG   DD SYSOUT=*\n//XMITIN    DD DSN=&&XMIT,DISP=(OLD,DELETE,DELETE)\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD DSN=&&SYSUT1,\n//             UNIT=SYSDA,                            SYSALLDA\n//             SPACE=(CYL,(5,1)),\n//             DISP=(,DELETE,DELETE)\n//SYSUT2    DD DSN=SYS2.RECV370.DEMO.PDS,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,1,45),RLSE),\n//             DISP=(,CATLG,DELETE)\n//SYSIN     DD DUMMY\n//SYSUDUMP  DD SYSOUT=*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JRECVSEQ": {"ttr": 6657, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x005\\x005\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 53, "newlines": 53, "modlines": 0, "user": "XV0006"}, "text": "//RECVSEQ  JOB 'DEMO DSORG=PS',CLASS=A,MSGCLASS=A\n//*\n//* TRANSMIT AND RECEIVE SEQUENTIAL DATASET\n//*\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD SYSOUT=*\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n//SYSIN     DD *\n SCRATCH DSNAME=SYS2.RECV370.DEMO.SEQ,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.RECV370.DEMO.SEQ\n//*--------------------------------------------------------------------\n//GENER    EXEC PGM=IEBGENER\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD *\nThis is a sample sequential dataset\nLine 2\nLine 3\nLast line\n//SYSUT2    DD DSN=&&SEQ,\n//             UNIT=SYSDA,\n//             SPACE=(CYL,1),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200),\n//             DISP=(,PASS,DELETE)\n//SYSIN     DD DUMMY\n//*--------------------------------------------------------------------\n//XMIT370  EXEC PGM=XMIT370\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//XMITLOG   DD SYSOUT=*\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD DSN=&&SEQ,DISP=(OLD,DELETE,DELETE)\n//SYSUT2    DD DSN=&&SYSUT2,\n//             UNIT=SYSDA,                            SYSALLDA\n//             SPACE=(CYL,(5,1)),\n//             DISP=(,DELETE,DELETE)\n//XMITOUT   DD DSN=&&XMIT,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,1)),\n//             DISP=(,PASS,DELETE)\n//SYSIN     DD DUMMY\n//SYSUDUMP  DD SYSOUT=*\n//*--------------------------------------------------------------------\n//RECV370  EXEC PGM=RECV370\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//RECVLOG   DD SYSOUT=*\n//XMITIN    DD DSN=&&XMIT,DISP=(OLD,DELETE,DELETE)\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD DSN=SYS2.RECV370.DEMO.SEQ,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,1),RLSE),\n//             DISP=(,CATLG,DELETE)\n//SYSIN     DD DUMMY\n//SYSUDUMP  DD SYSOUT=*\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JRECV1": {"ttr": 6659, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00\\x12\\x00\\x12\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "XV0006"}, "text": "//INSTALL  JOB RECV370,CLASS=A,MSGCLASS=A,\n//             MSGLEVEL=(2,0) NOTIFY=N9GTM\n//*            RESTART=XMITVTAB.ASMBLR\n//*\n//SINGLE   EXEC ASM370,APP=RECV,M=RECVGCTL\n//\n//* -------------------------------------------------------------------\n//LINK     EXEC PGM=IEWL,\n//             COND=(5,LT),\n//             PARM='LIST,MAP,XREF,LET,NCAL,RENT'\n//SYSPRINT  DD SYSOUT=*\n//SYSLMOD   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//SYSLIB    DD DSN=SYS2.RECV370.OBJ,DISP=SHR\n//U370LIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//SYSUT1    DD UNIT=SYSDA,SPACE=(TRK,(5,5))\n//SYSLIN    DD DSN=SYS2.XMIT370.ASM(KLNKU370),DISP=SHR\n//          DD DSN=SYS2.XMIT370.ASM(KLNKRECV),DISP=SHR\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JSTCP": {"ttr": 6661, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x07\\x00\\x07\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 7, "newlines": 7, "modlines": 0, "user": "XV0006"}, "text": "//STCP     JOB TESTING,REGION=1024K,MSGCLASS=A,CLASS=A\n//STCP370  EXEC PGM=STCP370\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//STCPDBUG  DD DSN=SYS2.XMIT370.ASM(KDEBUGS),DISP=SHR\n//STCPLOG   DD SYSOUT=*\n//SYSUDUMP  DD SYSOUT=*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JSTCPALL": {"ttr": 6663, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00U\\x00U\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 85, "newlines": 85, "modlines": 0, "user": "XV0006"}, "text": "//INSTALL  JOB STCP370,CLASS=A,MSGCLASS=A,\n//             MSGLEVEL=(2,0)\n//*            RESTART=LINK\n//*            RESTART=U370AP00.ASMBLR\n//* -------------------------------------------------------------------\n//ASM370   PROC M=MISSING,LIST=,PRT=DISK\n//ASMBLR   EXEC PGM=IFOX00,\n//             COND=(5,LT),\n//             REGION=6144K,\n//             PARM='&LIST.LIST,NOXREF,NORLD,LINECOUNT(999)'\n//SYSPRINT  DD DDNAME=&PRT\n//SYSOUT    DD SYSOUT=*\n//DISK      DD DSN=SYS2.STCP370.LIST(&M),DISP=SHR\n//SYSLIB    DD DSN=SYS2.XMIT370.ASM,DISP=SHR,\n//             DCB=BLKSIZE=32720\n//          DD DSN=SYS1.AMACLIB,DISP=SHR\n//          DD DSN=SYS1.AMODGEN,DISP=SHR\n//          DD DSN=SYS1.AGENLIB,DISP=SHR\n//SYSPUNCH  DD DSN=SYS2.STCP370.OBJ(&M),DISP=SHR\n//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(35,10))\n//SYSUT2    DD UNIT=SYSDA,SPACE=(CYL,(35,10))\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(50,10))\n//SYSIN     DD DSN=SYS2.XMIT370.ASM(&M),DISP=SHR\n//         PEND\n//* -------------------------------------------------------------------\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD DUMMY\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n SCRATCH DSNAME=SYS2.STCP370.LIST,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.STCP370.LIST\n SCRATCH DSNAME=SYS2.STCP370.OBJ,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.STCP370.OBJ\n//*\n//ALLOC    EXEC PGM=IEFBR14\n//LIST      DD DSN=SYS2.STCP370.LIST,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(20,0,5),RLSE),\n//             DCB=(RECFM=FB,LRECL=121,BLKSIZE=23474),\n//             DISP=(,CATLG)\n//OBJ       DD DSN=SYS2.STCP370.OBJ,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,0,5),RLSE),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200),\n//             DISP=(,CATLG)\n//*\n//STCP370  EXEC ASM370,M=STCP370\n//STCPINIT EXEC ASM370,M=STCPINIT\n//STCPLPA  EXEC ASM370,M=STCPLPA\n//STCPOPR  EXEC ASM370,M=STCPOPR\n//STCPOPT  EXEC ASM370,M=STCPOPT\n//STCPSS00 EXEC ASM370,M=STCPSS00\n//STCPSS99 EXEC ASM370,M=STCPSS99\n//STCPSVC  EXEC ASM370,M=STCPSVC\n//STCPSVC0 EXEC ASM370,M=STCPSVC0\n//STCPSVC9 EXEC ASM370,M=STCPSVC9\n//STCPOPR  EXEC ASM370,M=STCPTSKM\n//STCPVTAB EXEC ASM370,M=STCPVTAB\n//U370ABND EXEC ASM370,M=U370ABND\n//U370AP00 EXEC ASM370,M=U370AP00\n//U370AP99 EXEC ASM370,M=U370AP99\n//U370DBUG EXEC ASM370,M=U370CHAR\n//U370DBUG EXEC ASM370,M=U370DBUG\n//U370HERC EXEC ASM370,M=U370HERC\n//U370HEX  EXEC ASM370,M=U370HEX\n//U370LOG  EXEC ASM370,M=U370LOG\n//U370PSR  EXEC ASM370,M=U370PSR\n//U370QENV EXEC ASM370,M=U370QENV\n//U370QSS  EXEC ASM370,M=U370QSS\n//U370QTCB EXEC ASM370,M=U370QTCB\n//U370SDWA EXEC ASM370,M=U370SDWA\n//U370SNAP EXEC ASM370,M=U370SNAP\n//U370STAE EXEC ASM370,M=U370STAE\n//U370TIOT EXEC ASM370,M=U370TIOT\n//U370VADR EXEC ASM370,M=U370VADR\n//U370WTO  EXEC ASM370,M=U370WTO\n//* -------------------------------------------------------------------\n//LINK     EXEC PGM=IEWL,\n//             COND=(5,LT),\n//             PARM='LIST,MAP,XREF,LET,RENT'\n//SYSPRINT  DD SYSOUT=*\n//SYSLMOD   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//SYSLIB    DD DSN=SYS2.STCP370.OBJ,DISP=SHR\n//SYSUT1    DD UNIT=SYSDA,SPACE=(TRK,(5,5))\n//SYSLIN    DD DSN=SYS2.XMIT370.ASM(KLNKSTCP),DISP=SHR\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JSTCP1": {"ttr": 6666, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00$\\x00$\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "XV0006"}, "text": "//INSTALL  JOB SINGLE,CLASS=A,MSGCLASS=A,\n//             MSGLEVEL=(2,0) NOTIFY=N9GTM\n//*            RESTART=XMITVTAB.ASMBLR\n//* -------------------------------------------------------------------\n//ASM370   PROC M=MISSING,LIST=,PRT=DISK\n//ASMBLR   EXEC PGM=IFOX00,\n//             COND=(5,LT),\n//             REGION=6144K,\n//             PARM='&LIST.LIST,NOXREF,NORLD,LINECOUNT(999)'\n//SYSPRINT  DD DDNAME=&PRT\n//SYSOUT    DD SYSOUT=*\n//DISK      DD DSN=SYS2.STCP370.LIST(&M),DISP=SHR\n//SYSLIB    DD DSN=SYS2.XMIT370.ASM,DISP=SHR,\n//             DCB=BLKSIZE=32720\n//          DD DSN=SYS1.AMACLIB,DISP=SHR\n//          DD DSN=SYS1.AMODGEN,DISP=SHR\n//          DD DSN=SYS1.AGENLIB,DISP=SHR\n//SYSPUNCH  DD DSN=SYS2.STCP370.OBJ(&M),DISP=SHR\n//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(35,10))\n//SYSUT2    DD UNIT=SYSDA,SPACE=(CYL,(35,10))\n//SYSUT3    DD UNIT=SYSDA,SPACE=(CYL,(50,10))\n//SYSIN     DD DSN=SYS2.XMIT370.ASM(&M),DISP=SHR\n//         PEND\n//* -------------------------------------------------------------------\n//SINGLE   EXEC ASM370,M=STCPSS99\n//*\n//* -------------------------------------------------------------------\n//LINK     EXEC PGM=IEWL,\n//             COND=(5,LT),\n//             PARM='LIST,MAP,XREF,LET,NCAL,RENT'\n//SYSPRINT  DD SYSOUT=*\n//SYSLMOD   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//SYSLIB    DD DSN=SYS2.STCP370.OBJ,DISP=SHR\n//SYSUT1    DD UNIT=SYSDA,SPACE=(TRK,(5,5))\n//SYSLIN    DD DSN=SYS2.XMIT370.ASM(KLNKSTCP),DISP=SHR\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JTEST": {"ttr": 6668, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x17\\x00\\x17\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "XV0006"}, "text": "//INSTALL  JOB TEST370,CLASS=A,MSGCLASS=A,\n//             MSGLEVEL=(2,0),NOTIFY=N9GTM\n//* -------------------------------------------------------------------\n//TEST370  EXEC ASM370,M=TEST370\n//TESTVTAB EXEC ASM370,M=TESTVTAB\n//UTILABND EXEC ASM370,M=UTILABND\n//UTILDBUG EXEC ASM370,M=UTILDBUG\n//UTILHEX  EXEC ASM370,M=UTILHEX\n//UTILLOG  EXEC ASM370,M=UTILLOG\n//UTILPSR  EXEC ASM370,M=UTILPSR\n//UTILSNAP EXEC ASM370,M=UTILSNAP\n//UTILSTAE EXEC ASM370,M=UTILSTAE\n//UTILTIOT EXEC ASM370,M=UTILTIOT\n//* -------------------------------------------------------------------\n//LINK     EXEC PGM=IEWL,\n//             COND=(5,LT),\n//             PARM='LIST,MAP,XREF,LET,NCAL,RENT'\n//SYSPRINT  DD SYSOUT=*\n//SYSLMOD   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//SYSLIB    DD DSN=SYS2.XMIT370.OBJ,DISP=SHR\n//SYSUT1    DD UNIT=SYSDA,SPACE=(TRK,(5,5))\n//SYSLIN    DD DSN=SYS2.XMIT370.ASM(KTEST),DISP=SHR\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JUNLD": {"ttr": 6670, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x11\\x00\\x11\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "XV0006"}, "text": "//UNLOAD   JOB TESTING,REGION=1024K,MSGCLASS=A,CLASS=A\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD SYSOUT=*\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n SCRATCH DSNAME=SYS2.IEBCOPY.UNLD.MVS38J,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.IEBCOPY.UNLD.MVS38J\n//*\n//IEBCOPY  EXEC PGM=IEBCOPY\n//SYSPRINT  DD SYSOUT=*\n//IN        DD DSN=SYS2.XMIT370.ASM,DISP=SHR\n//OUT       DD UNIT=3380,VOL=SER=MVS809,\n//             DSN=SYS2.IEBCOPY.UNLD.MVS38J,\n//             SPACE=(CYL,(10,10),RLSE),\n//             DISP=(NEW,CATLG)\n//SYSIN     DD *\n COPY OUTDD=OUT,INDD=IN\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JU370ALL": {"ttr": 6672, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x008\\x008\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 56, "newlines": 56, "modlines": 0, "user": "XV0006"}, "text": "//INSTALL  JOB XMIT370,CLASS=A,MSGCLASS=A,\n//             MSGLEVEL=(2,0),NOTIFY=N9GTM\n//*            RESTART=LINK\n//*            RESTART=XMIT06.ASMBLR\n//* -------------------------------------------------------------------\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD DUMMY\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n SCRATCH DSNAME=SYS2.U370370.LIST,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.U370370.LIST\n SCRATCH DSNAME=SYS2.U370370.OBJ,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.U370370.OBJ\n//*\n//ALLOC    EXEC PGM=IEFBR14\n//LIST      DD DSN=SYS2.U370370.LIST,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(20,0,5),RLSE),\n//             DCB=(RECFM=FB,LRECL=121,BLKSIZE=23474),\n//             DISP=(,CATLG)\n//OBJ       DD DSN=SYS2.U370370.OBJ,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,0,5),RLSE),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200),\n//             DISP=(,CATLG)\n//*\n//* -------------------------------------------------------------------\n//U370ABND EXEC ASM370,APP=U370,M=U370ABND\n//U370AP00 EXEC ASM370,APP=U370,M=U370AP00\n//U370AP99 EXEC ASM370,APP=U370,M=U370AP99\n//U370CHAR EXEC ASM370,APP=U370,M=U370CHAR\n//U370DATE EXEC ASM370,APP=U370,M=U370DATE\n//U370DBUG EXEC ASM370,APP=U370,M=U370DBUG\n//U370HERC EXEC ASM370,APP=U370,M=U370HERC\n//U370HEX  EXEC ASM370,APP=U370,M=U370HEX\n//U370LOG  EXEC ASM370,APP=U370,M=U370LOG\n//U370PSR  EXEC ASM370,APP=U370,M=U370PSR\n//U370QENV EXEC ASM370,APP=U370,M=U370QENV\n//U370QSS  EXEC ASM370,APP=U370,M=U370QSS\n//U370QTCB EXEC ASM370,APP=U370,M=U370QTCB\n//U370SDWA EXEC ASM370,APP=U370,M=U370SDWA\n//U370SNAP EXEC ASM370,APP=U370,M=U370SNAP\n//U370STAE EXEC ASM370,APP=U370,M=U370STAE\n//U370TIOT EXEC ASM370,APP=U370,M=U370TIOT\n//U370VADR EXEC ASM370,APP=U370,M=U370VADR\n//U370WTO  EXEC ASM370,APP=U370,M=U370WTO\n//* -------------------------------------------------------------------\n//LINK     EXEC PGM=IEWL,\n//             COND=(5,LT),\n//             PARM='LIST,MAP,XREF,LET,NCAL,RENT'\n//SYSPRINT  DD SYSOUT=*\n//SYSLMOD   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//U370LIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//SYSLIB    DD DSN=SYS2.U370370.OBJ,DISP=SHR\n//SYSUT1    DD UNIT=SYSDA,SPACE=(TRK,(5,5))\n//SYSLIN    DD DSN=SYS2.XMIT370.ASM(KLNKU370),DISP=SHR\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JU3701": {"ttr": 6674, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00\\x10\\x00\\x10\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "XV0006"}, "text": "//INSTALL  JOB U370,CLASS=A,MSGCLASS=A,\n//             MSGLEVEL=(2,0) NOTIFY=N9GTM\n//*            RESTART=XMITVTAB.ASMBLR\n//* -------------------------------------------------------------------\n//SINGLE   EXEC ASM370,APP=U370,M=U370QENV\n//* -------------------------------------------------------------------\n//LINK     EXEC PGM=IEWL,\n//             COND=(5,LT),\n//             PARM='LIST,MAP,XREF,LET,NCAL,RENT'\n//SYSPRINT  DD SYSOUT=*\n//SYSLMOD   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//U370LIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//SYSLIB    DD DSN=SYS2.U370370.OBJ,DISP=SHR\n//SYSUT1    DD UNIT=SYSDA,SPACE=(TRK,(5,5))\n//SYSLIN    DD DSN=SYS2.XMIT370.ASM(KLNKU370),DISP=SHR\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JXMIT": {"ttr": 6676, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "XV0006"}, "text": "//XMIT370  JOB TESTING,REGION=1024K,MSGCLASS=A,CLASS=A\n//*JOBPARM LINECT=0\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD SYSOUT=*\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n SCRATCH DSNAME=SYS2.XMIT370.MVS38J.XMIT,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.XMIT370.MVS38J.XMIT\n SCRATCH DSNAME=SYS2.XMIT370.MVS38J.UNLD,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.XMIT370.MVS38J.UNLD\n//*\n//XMIT370  EXEC PGM=XMIT370\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//XMITLOG   DD SYSOUT=*\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DUMMY\n//SYSUT1    DD DSN=SYS2.XMIT370.ASM,DISP=SHR\n//SYSUT2    DD DSN=SYS2.XMIT370.MVS38J.UNLD,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,1),RLSE),\n//             DISP=(NEW,CATLG)\n//XMITOUT   DD DSN=SYS2.XMIT370.MVS38J.XMIT,\n//             VOL=SER=MVS809,UNIT=3380,\n//             SPACE=(CYL,(5,1),RLSE),\n//             DISP=(,CATLG)\n//COPYR1    DD DUMMY\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JXMITALL": {"ttr": 6678, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x005\\x005\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 53, "newlines": 53, "modlines": 0, "user": "XV0006"}, "text": "//INSTALL  JOB XMIT370,CLASS=A,MSGCLASS=A,\n//             MSGLEVEL=(2,0),NOTIFY=N9GTM\n//*            RESTART=LINK\n//*            RESTART=XMIT06.ASMBLR\n//* -------------------------------------------------------------------\n//* RUN JXMITNEW TO CREATE LIST & OBJ DATASETS\n//* -------------------------------------------------------------------\n//U370ABND EXEC ASM370,APP=XMIT,M=U370ABND\n//U370AP00 EXEC ASM370,APP=XMIT,M=U370AP00\n//U370AP99 EXEC ASM370,APP=XMIT,M=U370AP99\n//U370CHAR EXEC ASM370,APP=XMIT,M=U370CHAR\n//U370DATE EXEC ASM370,APP=XMIT,M=U370DATE\n//U370DBUG EXEC ASM370,APP=XMIT,M=U370DBUG\n//U370HERC EXEC ASM370,APP=XMIT,M=U370HERC\n//U370HEX  EXEC ASM370,APP=XMIT,M=U370HEX\n//U370LOG  EXEC ASM370,APP=XMIT,M=U370LOG\n//U370PSR  EXEC ASM370,APP=XMIT,M=U370PSR\n//U370QENV EXEC ASM370,APP=XMIT,M=U370QENV\n//U370QSS  EXEC ASM370,APP=XMIT,M=U370QSS\n//U370QTCB EXEC ASM370,APP=XMIT,M=U370QTCB\n//U370SDWA EXEC ASM370,APP=XMIT,M=U370SDWA\n//U370SNAP EXEC ASM370,APP=XMIT,M=U370SNAP\n//U370STAE EXEC ASM370,APP=XMIT,M=U370STAE\n//U370TIOT EXEC ASM370,APP=XMIT,M=U370TIOT\n//U370VADR EXEC ASM370,APP=XMIT,M=U370VADR\n//U370WTO  EXEC ASM370,APP=XMIT,M=U370WTO\n//XMITBUF  EXEC ASM370,APP=XMIT,M=XMITBUF\n//XMITCPR1 EXEC ASM370,APP=XMIT,M=XMITCPR1\n//XMITDIR  EXEC ASM370,APP=XMIT,M=XMITDIR\n//XMITESZ  EXEC ASM370,APP=XMIT,M=XMITESZ\n//XMITKDSN EXEC ASM370,APP=XMIT,M=XMITKDSN\n//XMITKEY  EXEC ASM370,APP=XMIT,M=XMITKEY\n//XMITPUT  EXEC ASM370,APP=XMIT,M=XMITPUT\n//XMITUNLD EXEC ASM370,APP=XMIT,M=XMITUNLD\n//XMITVTAB EXEC ASM370,APP=XMIT,M=XMITVTAB\n//XMIT01   EXEC ASM370,APP=XMIT,M=XMIT01\n//XMIT02A  EXEC ASM370,APP=XMIT,M=XMIT02A\n//XMIT02B  EXEC ASM370,APP=XMIT,M=XMIT02B\n//XMIT03   EXEC ASM370,APP=XMIT,M=XMIT03\n//XMIT06   EXEC ASM370,APP=XMIT,M=XMIT06\n//XMIT370  EXEC ASM370,APP=XMIT,M=XMIT370\n//* -------------------------------------------------------------------\n//LINK     EXEC PGM=IEWL,\n//             COND=(5,LT),\n//             PARM='LIST,MAP,XREF,LET,NCAL,RENT'\n//SYSPRINT  DD SYSOUT=*\n//SYSLMOD   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//U370LIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//SYSLIB    DD DSN=SYS2.XMIT370.OBJ,DISP=SHR\n//SYSUT1    DD UNIT=SYSDA,SPACE=(TRK,(5,5))\n//SYSLIN    DD DSN=SYS2.XMIT370.ASM(KLNKU370),DISP=SHR\n//          DD DSN=SYS2.XMIT370.ASM(KLNKXMIT),DISP=SHR\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JXMITCP1": {"ttr": 6680, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00 \\x00 \\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "XV0006"}, "text": "//XMIT370  JOB TESTING,REGION=1024K,MSGCLASS=A,CLASS=A\n//*JOBPARM LINECT=0\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD SYSOUT=*\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n SCRATCH DSNAME=SYS2.XMIT370.MVS38J.XMIT2,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.XMIT370.MVS38J.XMIT2\n SCRATCH DSNAME=SYS2.XMIT370.MVS38J.UNLD,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.XMIT370.MVS38J.UNLD\n//*\n//XMIT370  EXEC PGM=XMIT370\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//XMITPRT   DD SYSOUT=*\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DUMMY\n//SYSUT2    DD DSN=SYS2.XMIT370.MVS38J.UNLD,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(10,10),RLSE),\n//             DISP=(NEW,CATLG)\n//XMITOUT   DD DSN=SYS2.XMIT370.MVS38J.XMIT2,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,1),RLSE),\n//             DISP=(,CATLG)\n//SYSUT1    DD DSN=SYS2.XMIT370.ASM,DISP=SHR\n//SYSUDUMP  DD SYSOUT=*\n//* ITDBUG  DD DSN=SYS2.XMIT370.ASM(KDEBUGX),DISP=SHR\n//*\n//* MVS38J  LRECL=56\n//* MVS/ESA LRECL=60\n//*\n//COPYR1    DD DUMMY            DCB=LRECL=60\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JXMITNEW": {"ttr": 6682, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x16\\x00\\x16\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "XV0006"}, "text": "//INSTALL  JOB XMIT370,CLASS=A,MSGCLASS=A,\n//             MSGLEVEL=(2,0),NOTIFY=N9GTM\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD DUMMY\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n SCRATCH DSNAME=SYS2.XMIT370.LIST,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.XMIT370.LIST\n SCRATCH DSNAME=SYS2.XMIT370.OBJ,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.XMIT370.OBJ\n//*\n//ALLOC    EXEC PGM=IEFBR14\n//LIST      DD DSN=SYS2.XMIT370.LIST,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(20,0,5),RLSE),\n//             DCB=(RECFM=FB,LRECL=121,BLKSIZE=23474),\n//             DISP=(,CATLG)\n//OBJ       DD DSN=SYS2.XMIT370.OBJ,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,0,5),RLSE),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200),\n//             DISP=(,CATLG)\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JXMITPDS": {"ttr": 6684, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "XV0006"}, "text": "//XMITPDS  JOB 'DEMO DSORG=PO',CLASS=A,MSGCLASS=A\n//*\n//* TRANSMIT XMIT370\n//*\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD SYSOUT=*\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n//SYSIN     DD *\n SCRATCH DSNAME=SYS2.XMIT370.DEMO.XMIT,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.XMIT370.DEMO.XMIT\n//*\n//XMIT     EXEC PGM=XMIT370\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//SYSPRINT  DD SYSOUT=*\n//XMITPRT   DD SYSOUT=*\n//XMITLOG   DD SYSOUT=*\n//SYSUDUMP  DD SYSOUT=*\n//SYSUT1    DD DSN=SYS2.XMIT370.ASM,DISP=SHR\n//SYSUT2    DD DSN=&&SYSUT2,\n//             UNIT=SYSDA,                            SYSALLDA\n//             SPACE=(CYL,(5,1)),\n//             DISP=(,DELETE,DELETE)\n//XMITOUT   DD DSN=SYS2.XMIT370.DEMO.XMIT,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,1)),\n//             DISP=(,CATLG,CATLG)\n//SYSIN     DD DUMMY\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JXMITSEQ": {"ttr": 6913, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00)\\x00)\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "XV0006"}, "text": "//XMITSEQ  JOB 'DEMO DSORG=PS',CLASS=A,MSGCLASS=A\n//*\n//* TRANSMIT SEQUENTIAL DATASET\n//*\n//DELETE   EXEC PGM=IEHPROGM\n//SYSPRINT  DD SYSOUT=*\n//MVS3380   DD UNIT=3380,VOL=SER=MVS809,DISP=SHR\n//SYSIN     DD *\n SCRATCH DSNAME=SYS2.XMIT370.DEMO.SEQ,VOL=3380=MVS809\n UNCATLG DSNAME=SYS2.XMIT370.DEMO.SEQ\n//*\n//GENER    EXEC PGM=IEBGENER\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD *\nThis is a sample sequential dataset\nLine 2\nLine 3\nLast line\n//SYSUT2    DD DSN=&&SEQ,\n//             UNIT=SYSDA,\n//             SPACE=(CYL,1),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200),\n//             DISP=(,PASS,DELETE)\n//SYSIN     DD DUMMY\n//*\n//XMIT370  EXEC PGM=XMIT370\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//XMITLOG   DD SYSOUT=*\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD DSN=&&SEQ,DISP=(OLD,DELETE,DELETE)\n//SYSUT2    DD DSN=&&SYSUT2,\n//             UNIT=SYSDA,                            SYSALLDA\n//             SPACE=(CYL,(5,1)),\n//             DISP=(,DELETE,DELETE)\n//XMITOUT   DD DSN=SYS2.XMIT370.DEMO.SEQ,\n//             UNIT=3380,VOL=SER=MVS809,\n//             SPACE=(CYL,(5,1)),\n//             DISP=(,CATLG)\n//SYSIN     DD DUMMY\n//SYSUDUMP  DD SYSOUT=*\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JXMIT1": {"ttr": 6915, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00\\x12\\x00\\x12\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "XV0006"}, "text": "//INSTALL  JOB XMIT370,CLASS=A,MSGCLASS=A,\n//             MSGLEVEL=(1,1) NOTIFY=N9GTM\n//*            RESTART=XMITVTAB.ASMBLR\n//* -------------------------------------------------------------------\n//SINGLE   EXEC ASM370,APP=XMIT,M=U370DATE\n//*\n//* -------------------------------------------------------------------\n//LINK     EXEC PGM=IEWL,\n//             COND=(5,LT),\n//             PARM='LIST,MAP,XREF,LET,NCAL,RENT'\n//SYSPRINT  DD SYSOUT=*\n//SYSLMOD   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//SYSLIB    DD DSN=SYS2.XMIT370.OBJ,DISP=SHR\n//U370LIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//SYSUT1    DD UNIT=SYSDA,SPACE=(TRK,(5,5))\n//SYSLIN    DD DSN=SYS2.XMIT370.ASM(KLNKU370),DISP=SHR\n//          DD DSN=SYS2.XMIT370.ASM(KLNKXMIT),DISP=SHR\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JZAP": {"ttr": 6917, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x0b\\x00\\x0b\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "XV0006"}, "text": "//ZAP      JOB CLASS=A,MSGCLASS=A\n//ZAP      EXEC PGM=IKJEFT01,REGION=1024K,DYNAMNBR=20,COND=EVEN\n//SYSPRINT  DD SYSOUT=*\n//SYSHELP   DD DISP=SHR,DSN=SYS1.HELP\n//SYSTSPRT  DD SYSOUT=*\n//ZAPLOG    DD SYSOUT=*\n//SYSTSIN   DD *\nZAP 'SYS2.XMIT370.DEMO.XMIT' NOT3270 LOG VERBOSE\nDUMPE\nEND\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JZAPSSN": {"ttr": 6919, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x13\\x00\\x13\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "XV0006"}, "text": "//ZAPSSNT  JOB CLASS=A,MSGCLASS=A\n//IMASPZAP EXEC PGM=IMASPZAP\n//SYSPRINT  DD SYSOUT=A\n//SYSLIB    DD DSN=SYS1.LINKLIB,DISP=SHR\n//SYSIN     DD *\n NAME  IEFJSSNT IEFJSSNT\n VER 0004 E2E3C3D7,C8D5C8E3       CL8'STCPHNHT'\n REP 0004 E2E3C3D7,C9D5C9E3       CL8'STCPINIT'\n DUMPT IEFJSSNT IEFJSSNT\n//\n NAME  IEFJSSNT IEFJSSNT\n VER 0000 40404040                subsystem name\n VER 0004 40404040,40404040       subsystem initialization routine\n VER 000C 40404040                subsystem description - CL68\n VER 0014 40404040                subsystem description - CL68\n REP 0000 E3C3D740                CL4'TCP '\n REP 0004 E2E3C3D7,E2E2F0F0       CL8'STCPSS00'\n REP 000C D4E5E2F3,F89140E3       C'MVS38j T'\n REP 0014 C3D761C9,D7404040       C'CP/IP'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JZAPSSN2": {"ttr": 6921, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00\\x12\\x00\\x12\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "XV0006"}, "text": "//ZAPSSNT  JOB CLASS=A,MSGCLASS=A\n//*\n//*  version of zap for unmodified iefjssnt (Turnkey3)\n//*\n//IMASPZAP EXEC PGM=IMASPZAP\n//SYSPRINT  DD SYSOUT=A\n//SYSLIB    DD DSN=SYS1.LINKLIB,DISP=SHR\n//SYSIN     DD *\n NAME  IEFJSSNT IEFJSSNT\n VER 0000 40404040                subsystem name\n VER 0004 40404040,40404040       subsystem initialization routine\n VER 000C 40404040                subsystem description - CL68\n VER 0014 40404040                subsystem description - CL68\n REP 0000 E3C3D740                CL4'TCP '\n REP 0004 E2E3C3D7,C9D5C9E3       CL8'STCPINIT'\n REP 000C D4E5E2F3,F89140E3       C'MVS38j T'\n REP 0014 C3D761C9,D7404040       C'CP/IP'\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JZTEST": {"ttr": 6923, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x13\\x00\\x13\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "XV0006"}, "text": "//INSTALL  JOB CLASS=A,MSGCLASS=A\n//*--------------------------------------------------------------------\n//* DOES NOT APPLY TO XMIT370 0004\n//*--------------------------------------------------------------------\n//* IF YOU'RE USING AN OLDER ASSEMBLER (LIKE ASMF/IFOX00 FROM MVS38J),\n//* YOU NEED TO ASSEMBLE THE FOLLOWING TO SEE IF YOU HAVE A BUG IN\n//* MACRO OPERAND SUBLIST HANDLING.  REVIEW THE ASSEMBLY OUTPUT, AND\n//* IF THE MNOTE OUTPUT DOESN'T MATCH WHAT IT SHOULD BE, YOU HAVE THE\n//* BUG.  IF SO, EDIT XMIT#SET TO SPECIFY\n//*\n//*    &G#ASMF  SETB 1\n//*\n//* IF YOU DON'T HAVE THE BUG, EDIT XMIT#SET TO SPECIFY\n//*\n//*    &G#ASMF  SETB 0\n//*\n//* BEFORE YOU ASSEMBLE XMIT370/RECV370.\n//*\n//ZTEST   EXEC ASM370F,M=ZTEST\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "KBUGDAST": {"ttr": 6925, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x10\\x00\\x10\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "XV0006"}, "text": "DEFAULT  1\nU370DBUG 1     TURN ON DEBUG MSGS RIGHT AWAY\nDAST370  1\nDASTMVCP 1\nU370ABND 9\nU370HERC 9\nU370HEX  0\nU370LOG  0\nU370PSR  0\nU370QENV 9\nU370SDWA 4\nU370SNAP 0\nU370STAE 4 6 8\nU370TIOT 0\nU370VADR 2\nU370WTO  9\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "KBUGRECV": {"ttr": 6927, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "XV0006"}, "text": "DEFAULT  1\nU370DBUG 1     TURN ON DEBUG MSGS RIGHT AWAY\nRECV370  9\nRECVBLK  0\nRECVCTL  5\nRECVGCTL 3\nRECVGSEG 0\nRECVMSG  9\nRECVRCPY 2\nRECVUTIL 9\nU370ABND 0\nU370AP00 1\nU370AP99 1\nU370CHAR 0\nU370HERC 9\nU370HEX  0\nU370LOG  0\nU370PSR  0\nU370QENV 2\nU370QTCB 2     3=DUMP TCB, 8=ASCB, 9=ASXB\nU370QSS  2     3=DUMP SSCVT 4=DUMP SSVT\nU370SDWA 4\nU370SNAP 0\nU370STAE 9 4 6 8\nU370TIOT 0\nU370VADR 0\nU370WTO  0\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "KBUGSTCP": {"ttr": 6929, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "XV0006"}, "text": "DEFAULT  1\nU370DBUG 1     TURN ON DEBUG MSGS RIGHT AWAY\nSTCP370  9\nSTCPOPR  4\nSTCPSS00 5\nSTCPSS99 9\nSTCPSVC0 9\nSTCPSVC9 9\nSTCPTSKM 5\nU370ABND 0\nU370AP00 1\nU370AP99 1\nU370CHAR 0\nU370HERC 9\nU370HEX  0\nU370LOG  0\nU370PSR  0\nU370QENV 2\nU370QTCB 2     3=DUMP TCB, 8=ASCB, 9=ASXB\nU370QSS  2     3=DUMP SSCVT 4=DUMP SSVT\nU370SDWA 4\nU370SNAP 0\nU370STAE 4 6 8\nU370TIOT 0\nU370VADR 0\nU370WTO  0\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "KBUGXMIT": {"ttr": 6931, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\"\\x00\"\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "XV0006"}, "text": "DEFAULT  1\nU370DBUG 1     TURN ON DEBUG MSGS RIGHT AWAY\nXMIT370  9\nXMITBUF  0 3\nXMITCPR1 9\nXMITDIR  0\nXMITESZ  0\nXMITKDSN 2\nXMITKEY  9\nXMITPUT  0\nXMITUNLD 0\nXMIT01   9\nXMIT02A  4\nXMIT02B\nXMIT03\nXMIT06\nU370ABND 0\nU370AP00 1\nU370AP99 1\nU370CHAR 0\nU370DATE 9\nU370HERC 9\nU370HEX  0\nU370LOG  0\nU370PSR  0\nU370QENV 2\nU370QTCB 2     3=DUMP TCB, 8=ASCB, 9=ASXB\nU370QSS  2     3=DUMP SSCVT 4=DUMP SSVT\nU370SDWA 4\nU370SNAP 0\nU370STAE 4 6 8\nU370TIOT 0\nU370VADR 0\nU370WTO  0\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "KLNKDAST": {"ttr": 6933, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x08\\x00\\x08\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "XV0006"}, "text": " SETCODE AC(1)\n ORDER DAST370(P)\n INCLUDE SYSLIB(DAST370)       MUST BE FIRST OBJECT DECK\n INCLUDE SYSLIB(DASTMVCP)\n INCLUDE SYSLIB(DASTVTAB)\n INCLUDE U370LIB(U370CODE)\n ENTRY DAST370\n NAME DAST370(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "KLNKRECV": {"ttr": 6935, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "XV0006"}, "text": " SETCODE AC(1)\n ORDER RECV370(P)\n INCLUDE SYSLIB(RECV370)\n INCLUDE SYSLIB(RECVBLK)\n INCLUDE SYSLIB(RECVCTL)\n INCLUDE SYSLIB(RECVGCTL)\n INCLUDE SYSLIB(RECVGSEG)\n INCLUDE SYSLIB(RECVMSG)\n INCLUDE SYSLIB(RECVRCPY)\n INCLUDE SYSLIB(RECVUTIL)\n INCLUDE SYSLIB(RECVVTAB)\n INCLUDE U370LIB(U370CODE)\n ENTRY RECV370\n NAME RECV370(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "KLNKSTCP": {"ttr": 6937, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x19\\x00\\x19\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "XV0006"}, "text": " SETCODE AC(1)\n ORDER STCP370(P)\n INCLUDE SYSLIB(STCP370)       MUST BE FIRST OBJECT DECK IN MODULE\n INCLUDE SYSLIB(STCPOPR)\n INCLUDE SYSLIB(STCPSS00)\n INCLUDE SYSLIB(STCPSS99)\n INCLUDE SYSLIB(STCPSVC0)\n INCLUDE SYSLIB(STCPSVC9)\n INCLUDE SYSLIB(STCPTSKM)\n INCLUDE SYSLIB(STCPVTAB)\n INCLUDE U370LIB(U370CODE)\n ENTRY STCP370\n NAME STCP370(R)\n SETCODE AC(1)\n INCLUDE SYSLIB(STCPINIT)\n NAME STCPINIT(R)\n SETCODE AC(1)\n INCLUDE SYSLIB(STCPOPT)\n NAME STCPOPTS(R)\n SETCODE AC(1)\n INCLUDE SYSLIB(STCPLPA)\n NAME STCPLPA(R)\n SETCODE AC(1)\n INCLUDE SYSLIB(STCPSVC)\n NAME STCPSVC(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "KLNKU370": {"ttr": 6939, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x14\\x00\\x14\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "XV0006"}, "text": " INCLUDE SYSLIB(U370ABND)\n INCLUDE SYSLIB(U370AP00)\n INCLUDE SYSLIB(U370AP99)\n INCLUDE SYSLIB(U370CHAR)\n INCLUDE SYSLIB(U370DATE)\n INCLUDE SYSLIB(U370DBUG)\n INCLUDE SYSLIB(U370HEX)\n INCLUDE SYSLIB(U370HERC)\n INCLUDE SYSLIB(U370LOG)\n INCLUDE SYSLIB(U370PSR)\n INCLUDE SYSLIB(U370QENV)\n INCLUDE SYSLIB(U370QSS)\n INCLUDE SYSLIB(U370QTCB)\n INCLUDE SYSLIB(U370SDWA)\n INCLUDE SYSLIB(U370SNAP)\n INCLUDE SYSLIB(U370STAE)\n INCLUDE SYSLIB(U370TIOT)\n INCLUDE SYSLIB(U370VADR)\n INCLUDE SYSLIB(U370WTO)\n NAME U370CODE(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "KLNKXMIT": {"ttr": 6941, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x14\\x00\\x14\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "XV0006"}, "text": " SETCODE AC(1)\n ORDER XMIT370(P)\n INCLUDE SYSLIB(XMIT370)\n INCLUDE SYSLIB(XMITBUF)\n INCLUDE SYSLIB(XMITCPR1)\n INCLUDE SYSLIB(XMITDIR)\n INCLUDE SYSLIB(XMITESZ)\n INCLUDE SYSLIB(XMITKDSN)\n INCLUDE SYSLIB(XMITKEY)\n INCLUDE SYSLIB(XMITPUT)\n INCLUDE SYSLIB(XMITUNLD)\n INCLUDE SYSLIB(XMIT01)\n INCLUDE SYSLIB(XMIT02A)\n INCLUDE SYSLIB(XMIT02B)\n INCLUDE SYSLIB(XMIT03)\n INCLUDE SYSLIB(XMIT06)\n INCLUDE SYSLIB(XMITVTAB)\n INCLUDE U370LIB(U370CODE)\n ENTRY XMIT370\n NAME XMIT370(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "KLNKXXXX": {"ttr": 6943, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x11\\x00\\x11\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "XV0006"}, "text": " INCLUDE SYSLIB(U370ABND)\n INCLUDE SYSLIB(U370AP00)\n INCLUDE SYSLIB(U370AP99)\n INCLUDE SYSLIB(U370CHAR)\n INCLUDE SYSLIB(U370DBUG)\n INCLUDE SYSLIB(U370HEX)\n INCLUDE SYSLIB(U370HERC)\n INCLUDE SYSLIB(U370LOG)\n INCLUDE SYSLIB(U370PSR)\n INCLUDE SYSLIB(U370QENV)\n INCLUDE SYSLIB(U370QTCB)\n INCLUDE SYSLIB(U370SDWA)\n INCLUDE SYSLIB(U370SNAP)\n INCLUDE SYSLIB(U370STAE)\n INCLUDE SYSLIB(U370TIOT)\n INCLUDE SYSLIB(U370VADR)\n INCLUDE SYSLIB(U370WTO)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LICENSE": {"ttr": 6945, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00j\\x00j\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 106, "newlines": 106, "modlines": 0, "user": "XV0006"}, "text": "<HTML>\n<HEAD>\n<TITLE>XMIT370 Q Public License</TITLE>\n</HEAD>\n<BODY TEXT=\"black\" BGCOLOR=\"white\" LINK=\"blue\" VLINK=\"purple\"\nonload=\"if(top.frames.length!=0)top.location=self.location;\">\n\n<H1 ALIGN=\"center\">THE Q PUBLIC LICENSE version 1.0<BR>\n<BR>\n<FONT SIZE=\"2\">Copyright (C) 1999 Trolltech AS, Norway.<BR>\n</FONT><FONT SIZE=\"1\">Everyone is permitted to copy and<BR>\ndistribute this license document. </FONT></H1>\n\n<P>The intent of this license is to establish freedom to share and\nchange the software regulated by this license under the open source\nmodel.</P>\n<P>This license applies to any software containing a notice placed\nby the copyright holder saying that it may be distributed under the\nterms of the Q Public License version 1.0. Such software is herein\nreferred to as the Software. This license covers modification and\ndistribution of the Software, use of third-party application\nprograms based on the Software, and development of free software\nwhich uses the Software.</P>\n\n<H2 ALIGN=\"center\">Granted Rights</H2>\n\n<P>1. You are granted the non-exclusive rights set forth in this\nlicense provided you agree to and comply with any and all conditions\nin this license. Whole or partial distribution of the Software, or\nsoftware items that link with the Software, in any form signifies\nacceptance of this license.</P>\n<P>2. You may copy and distribute the Software in unmodified form\nprovided that the entire package, including - but not restricted to\n- copyright, trademark notices and disclaimers, as released by the\ninitial developer of the Software, is distributed.</P>\n<P>3. You may make modifications to the Software and distribute your\nmodifications, in a form that is separate from the Software,\nsuch as patches. The following restrictions apply to modifications:\n</P>\n<BLOCKQUOTE>\n<P>a. Modifications must not alter or remove any copyright notices\nin the Software.</P>\n<P>b. When modifications to the Software are released under this\nlicense, a non-exclusive royalty-free right is granted to the\ninitial developer of the Software to distribute your modification\nin future versions of the Software provided such versions remain\navailable under these terms in addition to any other license(s)\nof the initial developer.</P>\n</BLOCKQUOTE>\n<P>4. You may distribute machine-executable forms of the Software\nor machine-executable forms of modified versions of the Software,\nprovided that you meet these restrictions:</P>\n<BLOCKQUOTE>\n<P>a. You must include this license document in the distribution.</P>\n<P>b. You must ensure that all recipients of the machine-executable\nforms are also able to receive the complete machine-readable source\ncode to the distributed Software, including all modifications,\nwithout any charge beyond the costs of data transfer, and place\nprominent notices in the distribution explaining this.</P>\n<P>c. You must ensure that all modifications included in the\nmachine-executable forms are available under the terms of this\nlicense.</P>\n</BLOCKQUOTE>\n<P>5. You may use the original or modified versions of the Software\nto compile, link and run application programs legally developed by\nyou or by others.</P>\n<P>6. You may develop application programs, reusable components and\nother software items that link with the original or modified\nversions of the Software. These items, when distributed, are\nsubject to the following requirements:</P>\n<BLOCKQUOTE>\n<P>a. You must ensure that all recipients of machine-executable\nforms of these items are also able to receive and use the\ncomplete machine-readable source code to the items without any\ncharge beyond the costs of data transfer.</P>\n<P>b. You must explicitly license all recipients of your items to\nuse and re-distribute original and modified versions of the items\nin both machine-executable and source code forms. The recipients\nmust be able to do so without any charges whatsoever, and they\nmust be able to re-distribute to anyone they choose.</P>\n<P>c. If the items are not available to the general public, and\nthe initial developer of the Software requests a copy of the items,\nthen you must supply one.</P>\n</BLOCKQUOTE>\n\n<H2 ALIGN=\"center\">Limitations of Liability</H2>\n\n<P>In no event shall the initial developers or copyright holders be\nliable for any damages whatsoever, including - but not restricted\nto - lost revenue or profits or other direct, indirect, special,\nincidental or consequential damages, even if they have been advised\nof the possibility of such damages, except to the extent invariable\nlaw, if any, provides otherwise.</P>\n\n<H2 ALIGN=\"center\">No Warranty</H2>\n\n<P>The Software and this license document are provided AS IS with\nNO WARRANTY OF ANY KIND, INCLUDING THE WARRANTY OF DESIGN,\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</P>\n\n<H2 ALIGN=\"center\">Choice of Law</H2>\n\n<P>This license is governed by the Laws of the United States of\nAmerica and the State of Illinois.</P>\n</BODY>\n</HTML>\n", "mimetype": "text/html", "datatype": "ebcdic", "extension": ".html"}, "LOADLIB": {"ttr": 7171, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x06\\x00\\x00\\x01\\x08\\x10/\\x01\\x08\\x10/\\x111\\x05\\x07\\x05\\x07\\x00\\x00\\xd3\\xd6\\xc1\\xc4\\xd3\\xc9\\xc2@@@'", "ispf": {"version": "00.06", "flags": 0, "createdate": "2008-04-11T00:00:00", "modifydate": "2008-04-11T11:31:00", "lines": 1287, "newlines": 1287, "modlines": 0, "user": "LOADLIB"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "NOTERTM": {"ttr": 7684, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "XV0006"}, "text": "Miscellaneous RTM notes\n\nFrom GC28-0725-1 OS/VS2 SPL: MVS Diagnostic Techniques (Nov, 1977)\n\nRTM: Recovery Termination Manager\n\nRTM1 - attempts recovery for software or hardware errors.\n       Entered via CALLRTM issued by supervisory routines.\n       FRRs are processed in this phase\n\n       Resides in nucleus\n       IEAVTRT1 - RTM entry point processor\n       IEAVTRTM - RTM1 mainline\n       IEAVTRTS - system recovery manager\n       IEAVTRTR - RTM1 recovery routines\n\nRTM2 - performs normal & abnormal task termination for both\n       system & problem program routines\n       Entered via ABEND macro (SVC 13)\n\n       Resides in LPA\n       IEAVTRT2 - initialization\n       IEAVTRTC - controller\n       IEAVTRTE - exit handler\n       IEAVTAS1 - pre-exit\n       IEAVTAS2 - post-exit\n       IEAVTAS3 - control recovery\n       IEAVTSKT - task termination purges\n       IEAVTMRM - RTM2 resource manager\n       IEAVTRML - installation resource manager list\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "NOTETCP": {"ttr": 7686, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\xfe\\x00\\xfe\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 254, "newlines": 254, "modlines": 0, "user": "XV0006"}, "text": "\nCopyright 2002, James M. Morrison\n\n                   TCP/IP design and implementation notes\n                   --------------------------------------\n\nDraft 2002-08-08\n\nThis initial design assumes that all TCP/IP user programs will be\nAPF authorized, eliminating code that has to be written in support\nof non-APF authorized users (probably need SVC for non-APF users).\n\nComponents:\n-----------\n\nAPI\nLPALIB routines\nOptions module\nSubsystem initialization routine\nMVS modifications\nMain task\nSubtask: Operator interface\nSubtask: I/O support\nMiscellaneous notes\n\nComponent notes:\n----------------\n\nAPI\n\n    - Application Programming Interface\n\n    - Supports service requests:\n      - set options (page fixing, MTU, window size, etc)\n      - open port\n      - close port\n      - send packet\n      - receive packet\n\n    - Bindings for S/370 assembler in initial version\n      Subsequent versions will offer C language bindings\n\n    - Assembler language macro interface to generate\n      - Control block(s) (ala DCB, SSIB, SSOB)\n      - Calls LPALIB code (subsystem interface) via IEFSSREQ\n\n    - Status: not begun\n\nLPALIB routines\n\n    - Provides subsystem interface function to relay requests\n      from the API to the subsystem (places requests on queues)\n\n    - Supports API requests\n\n      - Open:\n        - Verifies desired port/protocol is available, if so\n          marks port/protocol as in-use; else exit w/ bad rc\n        - Builds control block in the user's address space\n          - TCP/IP anchor block (TCPSOK)\n          - SSIB - target subsystem\n          - SSOB - request descriptor\n          - Buffer pool descriptor (packet list, free space list)\n          - Options descriptor\n            MTU, window size, etc\n        - Acquires buffers\n        - Find subsystem, identify in control block\n          User may specify subsystem name (alternate TCP/IP stacks)\n        - May load API module(s) in the user's address space (ala SAM)\n\n      - Close:\n        - Releases buffer pool and control block(s)\n        - Deletes API modules, if any were loaded\n        - Verifies closing address space had port/protocol\n          allocated, if so marks port/protocol as free\n\n      - Send packet:\n        - Verifies address space has port/protocol allocated\n        - Constructs complete packet (IP header, UDP datagram or\n          TCP segment) from TCPSOK\n ->       Q: Local Network Header (probably Ethernet) also required?\n        - Optionally fix page(s) containing packet data\n          Caller may do this themselves and indicate such in request\n          as well as whether they wish pages unfixed upon send complete\n          Regardless of who does it, packet pages must be fixed in\n          storage so subsystem I/O subtask can grab the data without\n          taking page fault interrupts\n        - Queues request on subsystem send queue\n          Queue controlled by CS lockword\n\n      - Receive packet:\n        - Verifies address space has port/protocol allocated\n        - Examines receive queue to see if packet has already arrived\n          If so:\n             - marks buffer as transfer-in-progress\n             - disables\n             - sets CR7\n             - uses MVCP to copy data to caller's buffer\n             - enables\n             - indicate subsystem buffer now free for reuse\n               (transfer-in-progress off)\n          If not:\n             - fixes page(s) containing packet data (as required)\n             - Queues request on subsystem queue\n               Queue controlled by CS lockword\n             - Blocks (WAITs) as requested\n               This appears to be OK to do this way, since it looks\n               like IEFJSREQ calls our subsys function code in\n               the caller's address space\n\n      - Enforces limits on user activities, such as maximum number\n        of fixed pages & packet length\n\n    - May be dynamically installed; no CLPA required\n\n    - Monitors MVS operator commands, watching for 'D TCP'\n      Shoulder taps the Operator interface subtask to handle D TCP\n\n    - Status:\n      - Infrastructure to support load-to-global complete\n      - SSVT initialization complete\n      - LPALIB code stubs\n\nOptions module\n\n    - Specifies user site customization options\n\n    - Assembled and linkedited\n\n    - Status: complete\n\nSubsystem initialization routine\n\n    - executed as part of MVS subsystem initialization at MVS IPL\n\n    - Enables JES support so the TCP started task may use JES2\n      SYSIN and SYSOUT services\n\n    - further subsystem initialization is performed by the\n      main task\n\n    - Status: complete\n\nMVS modifications\n\n    - IEFJSSNT\n      - subsystem name table\n        specifies subsystem name and initialization routine\n      - Status: complete\n\n    - various\n      - Additional Floating Point Registers and\n        Binary Floating Point facility\n        in support for the LIB390 project (for MVS38j C)\n        Preserves new FP regs across dispatch/interrupts\n      - Dual Address Space (DAS) support\n        Preserves CR7 across dispatch/interrupts\n      - Status: Not planned for initial release\n        Research appears mainly complete\n\nMain task\n\n    - Runs in the TCP/IP subsystem address space, which is a\n      non-swappable MVS started task\n      (later versions may be swappable)\n\n    - initializes the subsystem, including establishing the\n      subsystem function routines, building the SSVT,\n      and building control areas such as queue headers\n\n    - Initiates the subtasks\n\n    - monitors subtasks\n\n    - Status: complete, except marking STC non-swap (SYSEVENT)\n      \"Monitoring\" currently exits when 1st subtask goes down\n\nSubtask: Operator interface\n\n    - Processes MVS operator START command, which may specify\n      the unit address of the first 3088 device (there are two)\n\n    - Enables operator commands\n\n    - Processes MVS operator MODIFY comands:\n\n      WARN     - warn user address spaces TCP/IP is terminating\n      DRAIN    - begin terminating TCP/IP application\n      SHUT     - alternative to MVS STOP operator command\n      CANCEL   - cancel TCP/IP user(s)\n\n    - Provides support for the MVS D TCP operator command:\n\n      NETSTAT  - TCP/IP status\n      DEBUG    - debugging support\n\n    - Supports the MVS operator STOP command, which terminates\n      the TCP/IP application\n\n    - Status: supports START (including cuu), MODIFY (DRAIN\n      only) and STOP\n\nSubtask: I/O support\n\n    - Supports the 3088 CTCA used under Hercules to pass packets\n      between the TCP/IP application and Hercules, which in turn\n      passes packets to and from the underlying host operating\n      system (Linux, Windows, etc.)\n\n    - Allocate buffer pool (private area)\n      Allocate request pool (CSA)\n\n    - Assemble incoming packets, discard timed out packets\n\n    - Scan queues for I/O requests\n\n    - Performs 3088 I/O (possibly different subtasks\n      for send and receive)\n\n    - Responds to foreign host requests against port/protocols\n      which are not open\n      Later versions will attempt to resist DOS attacks - should\n      be handled by Linux, Windows, etc., but might not be done\n      so well in all environments\n\n    - Returns status and/or packet data to user (if user WAITing)\n      Use MVCP (LPALIB code), cross-memory POST\n\n    - Request descriptor:\n         Request type (send/receive)\n         options (unfix pages, etc)\n         user ASCB address\n         user ECB address\n         user buffer address\n         user buffer length\n\n    - Status: not begun\n\nMiscellaneous notes\n\n    - Not planned for initial release\n      - MVS modifications in support of LIB390, DAS\n      - Application: FTP server\n      - Application: FTP server\n\nIssues:\n\n0001 - Should the subsys function code assemble the packet before\n       giving it to the subsystem I/O subtask, or should func code\n       merely pass the TCPSOK block and let I/O subtask assemble?\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OBJECT": {"ttr": 7691, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x06\\x00\\x00\\x01\\x08\\x10/\\x01\\x08\\x10/\\x113\\x04\\x9f\\x04\\x9f\\x00\\x00\\xd6\\xc2\\xd1\\xc5\\xc3\\xe3@@@@'", "ispf": {"version": "00.06", "flags": 0, "createdate": "2008-04-11T00:00:00", "modifydate": "2008-04-11T11:33:00", "lines": 1183, "newlines": 1183, "modlines": 0, "user": "OBJECT"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "RECV#BUG": {"ttr": 8199, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n         RECV#BUG &PFX=TGDD\n.*\n.* Copyright 2002-2008 James M. Morrison\n.*\n         LCLC  &P\n&P       SETC  '&PFX'\n&P.BLK   DS    C        RECVBLK\n&P.CTL   DS    C        RECVCTL\n&P.GCTL  DS    C        RECVGCTL\n&P.GSEG  DS    C        RECVGSEG    formerly recvget\n&P.MSG   DS    C        RECVMSG\n&P.RCPY  DS    C        RECVRCPY\n&P.UTIL  DS    C        RECVUTIL\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RECVBLK": {"ttr": 8201, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00\\xcb\\x00\\xcb\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 203, "newlines": 203, "modlines": 0, "user": "XV0006"}, "text": "RECVBLK  TITLE 'Assemble segments into data block'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n* Things to do:\n*----------------------------------------------------------------------\n         U#SET FUNC=RECV\n*----------------------------------------------------------------------\n* Function: Reads (via RECVGSEG calls) sufficient data segments to\n*           reconstruct a data block\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         R0  =  buffer length\n*         R1  =  buffer address\n*\n* Exit:   R15 =  Return code\n*\n*                0 = buffer contains data block\n*\n*                    R0 = length of block\n*                    R1 = address of block\n*\n*                4 = encountered control segment\n*\n*                    R0 = 0\n*                    R1 = address of control segment\n*\n* Abends: U0016  internal error - R14 useful\n*         U0017  incomplete data block (XMIT probably damaged)\n*         U0018  EOF encountered\n*         U0019  buffer overflow (XMIT probably damaged)\n*\n* Notes:  Caller is responsible for supplying BDW & RDW.\n*         The XMIT file doesn't contain them, and we don't\n*         return them.\n*\n* Debug:  1  entry/exit; exit shows RC\n*         2  exit shows block length\n*            control segment snapped\n*         3  exit shows data block\n*----------------------------------------------------------------------\n* R2     constant; SEGL - (R2) = # data bytes\n* R3     constant; SEGL - (R3) = # data bytes minus one (for EX)\n* R4     @ buffer slot to receive segment\n* R5     buffer length remaining\n* R6     block length\n* R7     internal linkage\n* R8     SEG\n* R9     SEGL - (R3) = segment data EX length\n* R10    # segment data bytes\n* R11    XMTWA\n* R12    base reg\n* R13    savearea/workarea\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\nRECVBLK  UPROC L=L$SA,ID=RBLK,WA=SAVEAREA\n         EJECT ,\n*----------------------------------------------------------------------\n*  Initialize\n*----------------------------------------------------------------------\nINIT     DS    0H\n         BALR  R14,0\n         LTR   R5,R0                        buffer length\n         BZ    DIE\n*\n         BALR  R14,0\n         LTR   R4,R1                        buffer address\n         BZ    DIE\n*\n         UDIAG 1,'RECVBLK entered'\n*\n         ST    R4,SARADDR                   set R1 return\n         LA    R2,SEGBUF-SEG                # seg overhead bytes\n         LA    R3,1(,R2)                    use to get EX length\n         SLR   R6,R6                        accumulate block length\n         SLR   R9,R9                        only need to clear once\n         BALR  R7,0                         faster looping\n         EJECT ,\n*----------------------------------------------------------------------\n* Call RECVGSEG until block complete\n*----------------------------------------------------------------------\nGETSEG   DS    0H\n         SLR   R0,R0                        no flags\n         UCALL RECVGSEG                     retrieve segment (R1 = @)\n         LTR   R8,R1                        got one?\n         BZ    ENDOFILE                     shouldn't happen\n*\n         USING XMITSEG,R8\n         TM    SEGFLG,SEG$C                 control segment?\n         BO    HVCTL\n*\nHVDATA   DS    0H                           have data segment\n         OI    SAFLG1,SA1DATA               saw data segment\n         IC    R9,SEGL                      segment length\n         LR    R10,R9\n*\n         SR    R10,R2                       R10 = # data bytes\n         SR    R5,R10                       buffer overflow?\n         BM    DIEBUF\n*\n         SR    R9,R3                        l' segment data minus one\n         EX    R9,COPYSEG\n         LA    R4,0(R10,R4)                 @ next buffer slot\n         AR    R6,R10                       accumulate block length\n         TM    SEGFLG,SEG$L                 last segment of block?\n         BO    SEGFINI\n*\n         BR    R7                           continue building block\n*\nCOPYSEG  MVC   0(*-*,R4),SEGBUF             copy segment to buffer\n         EJECT ,\n*----------------------------------------------------------------------\n*  Internal error - invalid parms\n*----------------------------------------------------------------------\nDIE      UABEND SAREASON                    R14 useful\n*----------------------------------------------------------------------\n*  Block incomplete (truncated), no SEG$L before control segment\n*----------------------------------------------------------------------\nBLKTRUNC DS    0H\n         STM   R0,R15,XMTREGS\n         ULOG  'RECVBLK incomplete data block'\n         MVI   SAREASON,17\n         B     DIE\n*----------------------------------------------------------------------\n* End Of File\n*----------------------------------------------------------------------\nENDOFILE DS    0H\n         ULOG  'RECVBLK EOF'\n         MVI   SAREASON,17\n         B     DIE\n*----------------------------------------------------------------------\n*  Buffer overflow\n*----------------------------------------------------------------------\nDIEBUF   DS    0H\n         STM   R0,R15,XMTREGS\n         ULOG  'RECVBLK buffer overflow'\n         USNAP 'RECVBLK buffer contents',*SARADDR,(R6)\n         MVI   SAREASON,19\n         B     DIE\n*----------------------------------------------------------------------\n*  Encountered control segment\n*----------------------------------------------------------------------\nHVCTL    DS    0H\n         TM    SAFLG1,SA1DATA               saw DATA segment(s)?\n         BO    BLKTRUNC\n*\n         ST    R8,SARADDR                   return ctl seg addr\n         SLR   R3,R3\n         IC    R3,SEGL\n         UDIAG 2,'RECVBLK encountered control segment',(R8),(R3)\n         LM    R15,R0,=A(4,0)\n         STM   R15,R0,SARET\n         B     EXIT\n         EJECT ,\n*----------------------------------------------------------------------\n*  Segment complete\n*----------------------------------------------------------------------\n*                                           INIT set R1 return\nSEGFINI  DS    0H                           PROC cleared SARC\n         ST    R6,SARLEN                    return block length\n         UPSR  2,'RECVBLK block length',(R6)\n         UDIAG 3,'RECVBLK block',*SARADDR,(R6)\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\nEXIT     DS    0H                           return values set\n         UPSR  1,'RECVBLK exited rc',*SARC\n         LM    R15,R1,SARET\n         UPEND R0=PASS,R1=PASS              return R0, R1, R15\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\n         LTORG ,\n         EJECT ,\n*----------------------------------------------------------------------\n*  Savearea/workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSA       DS    18F                     savearea for called code\n*\nSAFLG1   DS    X                       status flag\nSA1DATA  EQU   128                     saw DATA segment\n*\nSAREASON DS    X                       UABEND reason code\n*\nSARET    DS    0F,0XL12\nSARC     DS    F                       return code\nSARLEN   DS    F                       block length\nSARADDR  DS    A                       block address\n*\n         DS    0D\nL$SA     EQU   *-SAVEAREA\n         EJECT ,\n         PRINT NOGEN\n         WARECV ,\n         DXSEG ,\n         PRINT GEN\n*\nRECVBLK  UFINI DXDRGET,L$SA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RECVCTL": {"ttr": 8449, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x02\\xbe\\x02\\xbe\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 702, "newlines": 702, "modlines": 0, "user": "XV0006"}, "text": "*\n*  Copyright 2001-2008 James M. Morrison\n*\n*----------------------------------------------------------------------\n*\n*  Things to do:\n*\n*  2) research INMFFM vs. INMFM (CMS?)\n*  5) PAIRCHAR - verify target field length before copy\n*\n*----------------------------------------------------------------------\n*\n*  XMIT control segment key table definition macro\n*\n         MACRO\n&LABEL   KEY   &KEY,&TYPE,&TEXT,&SAVE=SAV,&FLAG=0,&IL=0\n         LCLA  &L\n         LCLC  &FIELD,&NDX,&SAV\n&NDX     SETC  '&SYSNDX'\n&L       SETA  K'&TEXT-1\n&L       SETA  (&L/2)*2\n&FIELD   SETC  '0'\n&SAV     SETC  '0'\n         AIF   ('&SAVE' EQ '').GEN\n&FIELD   SETC  '&SAVE.&KEY'\n&SAV     SETC  'L''&FIELD-1'\n.GEN     ANOP\n&LABEL   IM#SECT LABEL\nTE&NDX   DC    AL2(INM&KEY)            XMIT control segment key\n         DC    AL1(TAB$&TYPE)          key flag/count-length-value type\n         DC    AL1(TL&NDX)             length of this TAB entry\n         DC    S(&FIELD)               zero or save field Bddd\n         DC    AL2(&IL)                intrinsic field length\n         DC    AL1(&FLAG)              special processing flag\n         DC    AL1(&SAV)               SAVxxxxx field length minus one\n         DC    CL&L.&TEXT\nTL&NDX   EQU   *-TE&NDX\n         MEND\n         EJECT ,\n*----------------------------------------------------------------------\n*  XMIT control segment key attributes table\n*----------------------------------------------------------------------\nTAB      DSECT ,\nTABKEY   DS    XL2      INMRxxxx key\n*\nTABTYPE  DS    X        key type:\nTAB$CLVH EQU   1             key, count, (length,value) pairs - hex\nTAB$CLVE EQU   2             key, count, (length,value) pairs - EBCDIC\nTAB$FLAG EQU   3             flag only (no count, length, value)\n*\nTABELEN  DS    X        length of complete TAB entry (including text)\n*\nTABSCON  DS    XL2      zero (don't save) or S-con for save field\n*                       valid base regs: R13 (SAVEAREA), R15 (CS2)\n*\nTABILEN  DS    XL2      intrinsic field length\n*\nTABFLG1  DS    X        flags for PAIR code\nTAB1DSN  EQU   128           special DSN handling\n*\nTABSAVL  DS    X        length of save field minus one\n*\nTABTEXT  DS    0C       description of related key\n*\nL$TABOVH EQU   *-TAB    TAB entry overhead length\n*\n*\nRECVCTL  TITLE 'Handle XMIT Control segments'\n*----------------------------------------------------------------------\n         U#SET FUNC=RECV\n*----------------------------------------------------------------------\n* Function: Read the XMIT control segments, decide which to call:\n*\n*           a) RECVSEQ to handle sequential input datasets\n*\n*           b) RECVPDS to handle partitioned input datasets\n*\n*           If neither of the above, complain & abandon execution.\n*           Depending on debug level, this code may also display\n*           information about the XMIT control segments, such as\n*           key, count, and length/value pairs.\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         R0  =\n*         R1  =\n*\n* Exit:   R15 = return code\n*         R15 = 00 success\n*               04 warning issued\n*               08 error(s) encountered\n*\n* Abends: yes\n*\n* Notes:\n*\n* Diagnostics:\n*         2 - show status\n*         3 - show control segment\n*         4 - show control segment details\n*         5 - show CS2\n*         6 - show savearea at exit\n*         7 - show sasavptr\n*             show TAB entry\n*         8 - show saved-hex value\n*----------------------------------------------------------------------\n* R2     scratch\n* R3     current key\n* R4     ptr to current key/count/length/value\n* R5     scratch, BXLE index\n* R6     scratch, BXLE entry length\n* R7     scratch, BXLE limit\n* R8     segment length\n* R9     segment ptr\n* R10    scratch\n* R11    XMTWA\n* R12    base reg\n* R13    savearea\n*----------------------------------------------------------------------\nERR#1    EQU   1        RECVGSEG returned data segment\nERR#2    EQU   2        too many INMR02s\nERR#8    EQU   8        INMR03, but no INMR02s in XMIT\nERR#9    EQU   9        utility error return code\nERR#10   EQU   10       queued control segment SEGL=0\nERR#11   EQU   11       returned segment's seg length = 0\n         TITLE ' '\n*----------------------------------------------------------------------\nRECVCTL  UPROC L=L$SA,ID=RCTL,WA=SAVEAREA,INIT=MVCL\n*----------------------------------------------------------------------\n*  Initialize\n*----------------------------------------------------------------------\n*\n*  Activate the dummy CS2, for saved fields in TAB which can occur\n*  before we've seen an INMR02 (but are based in the CS2s).\n*  For instance, INMLRECL typically appears in INMR01s as well as\n*  INMR02s.\n*\n         UDIAG 1,'CTL enter'\n         LA     R0,SACS2X                   dummy CS2\n         ST     R0,SA@CS2\n*----------------------------------------------------------------------\n*  Read control record\n*----------------------------------------------------------------------\nGETSEG   DS    0H\n         TM    SAFLG1,SA1MR6                trailer seen?\n         BO    CLOSE                        br, done\n         TM    SAFLG1,SA1QCS                queued control seg?\n         BNO   CALLGC\n         MVI   SAREASON,ERR#10              queued segment SEGL=0\n         L     R9,SA@QCS                    dequeue ctl seg\n         USING XMITSEG,R9\n         SLR   R14,R14\n         ICM   R14,1,SEGL\n         BZ    DIE\n         UDIAG 2,'CTL dequeue cseg',(R9),(R14)\n         NI    SAFLG1,255-SA1QCS            segment dequeued\n         LR    R1,R9                        give q'd seg to GCTL\n         B     *+6\n*\nCALLGC   DS    0H\n         SLR   R1,R1                        no queued ctl seg\n         UCALL RECVGCTL                     retrieve XMIT ctl rec\n         LR    R8,R0                        save ctl rec length\n         LTR   R9,R1                        @ returned segment or zero\n         BZ    EOF\n         C     R15,=F'8'                    error?\n         BL    HAVESEG                      no, br\n         MVI   SAREASON,ERR#1               RECVGCTL error\n         B     DIE\n         EJECT ,\n*----------------------------------------------------------------------\n*  We have an XMIT control segment\n*----------------------------------------------------------------------\nHAVESEG  DS    0H\n         UDIAG 3,'CTL control record',(R9),(R8)\n         USING SEGBUF,R9\n         CLC   SEGCTLNM,=C'INMR02'\n         BNE   DISPLAY\n*\n*  XMIT files are built by TRANSMIT (or XMIT370), and the order\n*  of the INMR02s reflects the sequence of operations that TRANSMIT\n*  performed.  For an IEBCOPY unloaded PDS, the IEBCOPY INMR02 is\n*  first, then the INMCOPY INMR02.\n*\n         OI    SAFLG1,SA1CS2           INMR02 seen\n         L     R15,SA@CS2              current CS2 (might be dummy)\n         LA    R15,L$CS2(,R15)         @ next CS2\n         LA    R0,SACS2BAD             limit\n         CR    R15,R0                  too many INMR02s?\n         BL    NEWCS2\n         UDIAG 0,'CTL too many INMR02s'\n         MVI   SAREASON,ERR#2          too many INMR02s\n         B     DIE\n*\nNEWCS2   DS    0H\n         ST    R15,SA@CS2\n         USING CS2,R15\n         MVC   CS2ID,=C'CS2 '          set CS2 id\n         SLR   R0,R0\n         ICM   R0,15,SEGC2NUM          retain file #\n         ST    R0,CS2#FILE\n         DROP  R15\n         UPSR  2,'CTL INMR02 applies to file',(R0)\n         EJECT ,\n*----------------------------------------------------------------------\n*  Print the details header line\n*----------------------------------------------------------------------\nDISPLAY  DS    0H\n         UDIAG 4,'CTL control segment details'\n         MVI   SAMSG,C' '\n         MVC   SAMSG+1(L$SAMSG-1),SAMSG     clear message area\n         MVC   SAMSG(3),=C'<4>'\n         MVC   SATYPE,=C'TYPE'\n         MVC   SAKEY,=C'KEY '\n         MVC   SACOUNT-1(5),=C'COUNT'\n         MVC   SALEN,=C'LEN '\n         MVC   SAILEN,=C'ILEN '             intrinsic field length\n         MVC   SAVALUE(5),=C'VALUE'\n         MVC   SATEXT(11),=C'DESCRIPTION'\n         BAL   R14,MSGOUT                   label output to follow\n         EJECT ,\n*----------------------------------------------------------------------\n*  Examine each key in the control segment\n*----------------------------------------------------------------------\nDETAILS  DS    0H\n         LA    R4,SEGCKEYS                  standard 1st key offset\n         CLC   SEGCTLNM,=C'INMR02'          non-standard?\n         BNE   *+8\n         LA    R4,SEGC2KEY                  INMR02 1st key offset\n*\nNEXTKEY  DS    0H                           R4 @ key, R8 = seg length\n         LA    R0,SEGBUF(R8)                @ end of segment\n         CR    R4,R0\n         BNL   FINSEG                       exhausted keys, finish seg\n         SLR   R3,R3\n         ICM   R3,3,0(R4)                   grab key\n         LM    R5,R7,=A(TABLE,0,TABEND-1)   set TAB scan regs\n         USING TAB,R5\n*\nSCAN     DS    0H                           scan TAB for matching key\n         IC    R6,TABELEN                   get TAB entry length\n         CLM   R3,3,TABKEY                  found key?\n         BE    FOUND\n         BXLE  R5,R6,SCAN\n*\n         UPSR  0,'CTL unrecognized key',(R3)\n         MVI   SAREASON,3\nSNAPDIE  UDIAG 0,'CTL control seg',(R9),(R8)\n         B     DIE\n         EJECT ,\n*----------------------------------------------------------------------\n*  Found key, issue descriptive message(s) based on key type\n*----------------------------------------------------------------------\nCOPYTEXT MVC   SATEXT(*-*),TABTEXT          copy text to display line\n*\nFOUND    DS    0H\n         MVI   SAMSG,C' '\n         MVC   SAMSG+1(L$SAMSG-1),SAMSG     clear message area\n         MVC   SAMSG(3),=C'<4>'\n         UDIAG 7,'CTL TAB entry',(R5),(R6)\n         ST    R5,SATABENT                  save @ entry for PAIR code\n         LA    R0,L$TABOVH                  TAB entry overhead\n         SR    R6,R0                        R6 = text length\n         LR    R0,R3\n         SLR   R1,R1\n         UCALL U370HEX                      convert key to EBCDIC\n         STCM  R1,15,SAKEY\n         BCTR  R6,0\n         EX    R6,COPYTEXT\n         LA    R4,L$CKEY(,R4)               bump to count\n*\n*  Set up pointer to save field for ease of handling in the PAIRS code\n*\n*  We build a LA instruction in SAINSTR (X'4110ssss') from the\n*  S-con in the current TAB entry, then execute it to point R1\n*  at the field which will be used to save the current value.\n*  We use an S-con, since we only really care about the INMR02 values;\n*  other values are either ignored or saved somewhere in SAVEAREA.\n*\n*  Avoid wiping out CS2s with INMR03 data by always pointing INMR03\n*  save field at SABOGUS\n*\n         LA    R1,SABOGUS                   field for unsaved fields\n         CLC   TABSCON,=AL2(0)              is this field to be saved?\n         BE    NULLSAVE\n         CLC   SEGCTLNM,=C'INMR03'\n         BE    NULLSAVE\n         MVC   SAINSTR(2),=X'4110'          first half of LA R1, instr\n         MVC   SAINSTR+2(2),TABSCON         add S-con (base=R15)\n         MVI   SAREASON,4\n         ICM   R15,15,SA@CS2                select current CS2\n         BZ    DIE\n         EX    R0,SAINSTR                   R1 @ save field\n*\nNULLSAVE DS    0H\n         ST    R1,SASAVPTR\n         UPSR  7,'CTL sasavptr',(R1)\n         EJECT ,\n*----------------------------------------------------------------------\n*  Examine key type\n*----------------------------------------------------------------------\n         CLI   TABTYPE,TAB$FLAG             flag only?\n         BNE   CKCLV\n*\nSETFLAG  DS    0H                           flag: count=0, no value(s)\n         L     R1,SASAVPTR                  @ save field\n         MVI   0(R1),C'Y'                   flag set\n         MVC   SATYPE,=C'FLAG'\n         SLR   R0,R0\n         ICM   R0,3,0(R4)                   document zero count\n         SLR   R1,R1\n         UCALL U370HEX\n         STCM  R1,15,SACOUNT\n         BAL   R14,MSGOUT                   display message\n         LA    R4,L$CCOUNT(,R4)             skip past zero count\n         B     NEXTKEY                      finished with flag\n*\n*  Common setup for either CLVE or CLVH\n*\nCKCLV    DS    0H\n         SLR   R0,R0\n         ICM   R0,3,0(R4)\n         ST    R0,SAXCOUNT                  save count for PAIR code\n         SLR   R1,R1\n         UCALL U370HEX\n         STCM  R1,15,SACOUNT\n         LA    R4,L$CCOUNT(,R4)             bump to length/value pairs\n         CLI   TABTYPE,TAB$CLVE             EBCDIC?\n         BNE   CKCLVH\n*\nCLVE     DS    0H\n         MVC   SATYPE,=C'CLVE'              EBCDIC\n         B     PAIRS\n*\nCKCLVH   DS    0H\n         MVI   SAREASON,5\n         CLI   TABTYPE,TAB$CLVH             HEX?\n         BNE   DIE\n         MVC   SATYPE,=C'CLVH'              HEX\n         EJECT ,\n*----------------------------------------------------------------------\n*  Handle length/value pairs (R4 @ first length, SAXCOUNT = # pairs)\n*----------------------------------------------------------------------\nPAIRS    DS    0H\n         BAL   R14,MSGOUT\n         ICM   R2,15,SAXCOUNT               # pairs\n         BNZ   PAIRLOOP\n         UDIAG 0,'CTL count 0'              should only happen for flag\n         MVI   SAREASON,6\n         B     SNAPDIE\n*\nPAIRLOOP DS    0H\n         SLR   R0,R0\n         ICM   R0,3,0(R4)                   grab length\n         LR    R10,R0                       save length in safe reg\n         SLR   R1,R1\n         UCALL U370HEX\n         STCM  R1,15,SALEN\n         ICM   R0,3,TABILEN                 intrinsic length\n         BZ    PAIRVAL\n         SLR   R1,R1\n         UCALL U370HEX\n         STCM  R1,15,SAILEN\nPAIRVAL  LA    R4,L$CLEN(,R4)               point at value\n*\n         CLI   TABTYPE,TAB$CLVE             EBCDIC value?\n         BNE   PAIRHEX\n         EJECT ,\n*----------------------------------------------------------------------\n*  EBCDIC value - R4 @ value, R10 = value length\n*----------------------------------------------------------------------\n*\n*  set up initial blanks in char fields, so that short values\n*  (like CL7 ddname) are right blank padded after save\n*\nPAIRCHAR DS    0H\n         L     R15,SASAVPTR                 @ save field\n         MVI   0(R15),C' '                  blank 1st save char\n         SLR   R14,R14\n         ICM   R14,1,TABSAVL                L' save field minus one\n         BZ    PCBLNKD                      only one char, already done\n         BCTR  R14,0\n         EX    R14,BLNKSAVE                 propagate blank\nPCBLNKD  DS    0H\n         BCTR  R10,0\n         EX    R10,COPYVALU                 copy value to display line\n         EX    R10,COPYSAVE                 copy value to save field\n         BAL   R14,MSGOUT                   display message\n         LA    R4,1(R10,R4)                 at next key\n         BCT   R2,PAIRLOOP\n         B     NEXTKEY\n*\nCOPYVALU MVC   SAVALUE(*-*),0(R4)\nCOPYSAVE MVC   0(*-*,R15),0(R4)\nBLNKSAVE MVC   1(*-*,R15),0(R15)\n         EJECT ,\n*----------------------------------------------------------------------\n*  HEX value - R4 @ value, R10 = value length\n*----------------------------------------------------------------------\nPAIRHEX  DS    0H\n         MVI   SAREASON,7\n         C     R10,=F'4'                    max supported HEX length\n         BH    DIE\n*\n*  Copy hex value to save field\n*\n         SLL   R10,2                        index RETRIEVE list\n         L     R1,SASAVPTR\n         SLR   R0,R0\n         EX    R0,RETRIEVE-4(R10)           grab 1 to 4 bytes -> R0\n         ST    R0,0(R1)                     store saved field\n         SRL   R10,2\n         UPSR  8,'CTL saved-hex',(R0)\n*\n*  display hex value, two EBCDIC chars at a time\n*\n         LA    R5,SAVALUE                   @ output field\n         LA    R7,0(R10,R4)                 @ next key\n         ICM   R0,15,0(R4)                  grab max hex value\n         LA    R1,SAWORK\n         UCALL U370HEX\n         LA    R14,2                        increment\n         LA    R15,SAWORK\n*\nPHLOOP   DS    0H\n         MVC   0(2,R5),0(R15)               copy 2 EBCDIC chars\n         AR    R15,R14\n         AR    R5,R14\n         BCT   R10,PHLOOP\n         BAL   R14,MSGOUT\n         LR    R4,R7                        @ next key\n         BCT   R2,PAIRLOOP                  process remaining values\n         B     NEXTKEY\n*\nRETRIEVE ICM   R0,1,0(R4)\n         ICM   R0,3,0(R4)\n         ICM   R0,7,0(R4)\n         ICM   R0,15,0(R4)\n*\nDIE      UABEND SAREASON                    internal error\n*----------------------------------------------------------------------\n*  MSGOUT subroutine, returns via R14\n*----------------------------------------------------------------------\n*\n*  This code should only be called to display debug level 4 messages\n*\nMSGOUT   DS    0H\n         ST    R14,SASUB14                  save return reg\n         UDIAG 4,SKIP=MSGCLEAR\n         ULOG  SAMSG,L$SAMSG                display message\nMSGCLEAR DS    0H\n         MVI   SAMSG,C' '\n         MVC   SAMSG+1(L$SAMSG-1),SAMSG     clear message area\n         MVC   SAMSG(3),=C'<4>'\n         L     R14,SASUB14                  restore return ret\n         BR    R14                          return\n         EJECT ,\n*----------------------------------------------------------------------\n*  Control segment parse complete\n*----------------------------------------------------------------------\n*\n*  The INMR02 control segment describes the invocation of a utility\n*  such as INMCOPY, IEBCOPY, IDCAMS, etc.\n*\nFINSEG   DS    0H\n         CLC   SEGCTLNM,=C'INMR02'\n         BNE   FSCK06\n         L     R1,SA@CS2                    current CS2\n         UDIAG 5,'CTL CS2 built',(R1),L$CS2\n         B     GETSEG\n*\n*  The INMR06 control segment is always the last segment of a\n*  properly constructed XMIT file.\n*\nFSCK06   CLC   SEGCTLNM,=C'INMR06'\n         BNE   FSCK03\n         OI    SAFLG1,SA1MR6                INMR06 (trailer) seen\n         B     GETSEG                       read rest of input anyway\n*\n*  The INMR03 control segment indicates data segments follow\n*  immediately after the INMR03\n*  If an embedded message is present, it appears as file number one\n*\nFSCK03   DS    0H\n         CLC   SEGCTLNM,=C'INMR03'\n         BNE   GETSEG\n         L     R14,SAFILE#\n         LA    R14,1(,R14)                  increment file #\n         ST    R14,SAFILE#\n         TM    SAFLG1,SA1CS2                built CS2(s)?\n         BO    FSCS2\n         ULOG  'CTL ERROR: invalid XMIT'\n         ULOG  'CTL ERROR: INMR03, but no INMR02(s)'\n         MVI   SAREASON,ERR#8\n         B     DIE\n*\n*  Scan the CS2 list to find a utility to call\n*\nFSCS2    DS    0H\n         UDIAG 5,'CTL saved CS2s',SACS2,SACS2BAD\n         LA    R5,SACS2A                    BXLE: index\n         LA    R6,L$CS2                     BXLE: increment\n         LA    R7,SACS2BAD-1                BXLE: limit\n         USING CS2,R5\nFSSCAN   DS    0H\n         CLI   CS2DONE,CS2$DONE             CS2 not yet handled?\n         BNE   FSSELECT                     yes, find last related CS2\n         BXLE  R5,R6,FSSCAN                 keep looking\n*\n         UDIAG 2,'CTL exhausted CS2s'\n         NI    SAFLG1,255-SA1CS2            no pending CS2s\n         B     GETSEG                       finish reading input\n*\n*  Find the last CS2 which is related to the current file number\n*  This CS2 will be passed to RECVUTIL, who will handle it then\n*  look backwards in the CS2 list for additional utilities which\n*  address the same file number.  If RECVUTIL finds more such\n*  utilities, it will call them, too.\n*\nFSSELECT DS    0H\n         L     R0,CS2#FILE                  associated file number\nFSSCAN2  DS    0H\n         C     R0,CS2#FILE                  same file #?\n         BNE   FSUTIL                       no, back up to last good\n         LR    R1,R5                        @ acceptable CS2\n         BXLE  R5,R6,FSSCAN2                keep looking\n*\nFSUTIL   DS    0H\n         UCALL RECVUTIL                     handle associated utilities\n         MVI   SAREASON,ERR#9               utility error\n         C     R15,=F'4'                    returned ctl seg?\n         BH    DIE                          no, bad rc; br\n         BNE   GETSEG                       no ctl seg emitted, br\n         MVI   SAREASON,ERR#11              error if emitted seg SEGL=0\n         ST    R1,SA@QCS                    queue control seg\n         SLR   R14,R14\n         ICM   R14,1,SEGL-SEG(R1)\n         BZ    DIE                          null ctl seg returned\n         OI    SAFLG1,SA1QCS\n         UDIAG 2,'CTL RECVUTIL emit ctl seg',(R1),(R14)\n         B     GETSEG                       finish reading input\n         DROP  R5\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\n*\n*  We've seen the INMR06, and since some XMIT files have garbage\n*  at the end, we don't read the rest of the XMIT once we've seen\n*  the INMR06\n*\nCLOSE    DS    0H\n         UDIAG 2,'CTL closing XMIT; INMR06 seen'\n         SLR   R0,R0\n         ICM   R0,8,=AL1(RGET$CLO)          option: close XMIT\n         UCALL RECVGSEG                     close XMITIN\nEOF      DS    0H\n         UDIAG 2,'CTL EOF'\n         TM    SAFLG1,SA1MR6                saw trailer?\n         BO    EXIT\n*\n         ULOG  'CTL Warning: INMR06 (trailer) missing'\n         ULOG  'CTL Warning: XMIT file may be damaged'\n         CLI   SARC+3,4                     more severe error?\n         BH    EXIT                         yes, leave it; br\n         MVI   SARC+3,4                     warning: XMIT damaged\n*\nEXIT     DS    0H\n         UDIAG 6,'CTL savearea at exit',(R13),L$SA\n         UDIAG 1,'CTL exit rc',*SARC\n         UPEND RC=*SARC\n         EJECT ,\n*----------------------------------------------------------------------\n*  XMIT control segment key attributes (see TAB DSECT)\n*----------------------------------------------------------------------\n         PUSH  USING\n         USING CS2,R15                      generate S-con w/ R15\nTABLE    DS    0D\n         KEY   DDNAM,CLVE,'DDNAME'\n         KEY   DSNAM,CLVE,'DSN',FLAG=TAB1DSN\n         KEY   ERRCD,CLVH,'receive error code'\n         KEY   FACK,FLAG,'acknowledgement request'\n         KEY   FNODE,CLVE,'origin node name'\n         KEY   FTIME,CLVE,'origin time stamp'\n         KEY   FUID,CLVE,'origin userid'\n         KEY   FVERS,CLVE,'origin version number'\n         KEY   NUMF,CLVH,'number of files'\n         KEY   RECCT,CLVH,'transmitted record count'\n         KEY   SECND,CLVH,'secondary space qty'\n         KEY   TNODE,CLVE,'target node name'\n         KEY   TTIME,CLVE,'destination time stamp'\n         KEY   TUID,CLVE,'target userid'\n         KEY   TYPE,CLVH,'data set type'\n*\n         KEY   USERP,CLVE,'user parm string',SAVE=\n*\n         KEY   BLKSZ,CLVH,'BLKSIZE',SAVE=CS2,IL=2\n         KEY   DIR,CLVH,'directory blocks',SAVE=CS2\n         KEY   CREAT,CLVH,'creation date',SAVE=CS2\n         KEY   DSORG,CLVH,'DSORG',SAVE=CS2,IL=2\n         KEY   EXPDT,CLVH,'expiration date',SAVE=CS2\n         KEY   LCHG,CLVH,'last changed date',SAVE=CS2\n         KEY   LRECL,CLVH,'LRECL',SAVE=CS2,IL=2\n         KEY   LREF,CLVH,'last referenced date',SAVE=CS2\n         KEY   MEMBR,CLVE,'member',SAVE=CS2\n         KEY   RECFM,CLVH,'RECFM',SAVE=CS2,IL=1\n         KEY   SIZE,CLVH,'approx file size (bytes)',SAVE=CS2\n         KEY   TERM,FLAG,'terminal alloc (msg)',SAVE=CS2\n         KEY   UTILN,CLVE,'utility name',SAVE=CS2\n*\n*  I've not seen an example of the next key, so the following is\n*  a great big guess.\n*\n         KEY   FFM,CLVE,'filemode number (CMS)',SAVE=\nTABEND   DS    0X\n         POP   USING\n*\n         LTORG ,\n         EJECT ,\n         DRCS2 ,\n         EJECT ,\n*----------------------------------------------------------------------\n*  Savearea/workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSA       DS    18F\nSARC     DS    F\n*\nSAFLG1   DS    X             status flag\nSA1MR6   EQU   128                INMR06 seen (trailer)\nSA1CS2   EQU   64                 INMR02 seen\nSA1QCS   EQU   32                 control seg queued\n*\nSAREASON DS    X             UABEND reason code\n*\nSAWORK   DS    D             hex conversion return\nSAXCOUNT DS    F             hex count\nSASAVPTR DS    A             zero or ptr to key value save field\nSATABENT DS    A             ptr to TAB entry associated with key\nSAINSTR  DS    F             LA R1,xxx(R15) instruction\nSA@CS2   DS    A             pointer to current INMR02 save (CS2)\nSASUB14  DS    A             low-level subroutine return reg\nSA@QCS   DS    A             addr of queued control seg\nSAFILE#  DS    F             current file #\n*\n*  message giving segment details\n*\nSAMSG    DS    0C\n         DS    CL4\nSATYPE   DS    CL4\n         DS    CL4\nSAKEY    DS    CL4\n         DS    CL2\nSACOUNT  DS    CL4\n         DS    CL2\nSALEN    DS    CL4\n         DS    CL2\nSAILEN   DS    CL4                     intrinsic field length\n         DS    CL2\nSAVALUE  DS    CL20\n         DS    CL2\nSATEXT   DS    CL30\nSALIMIT  DS    0C                      last valid message char\nL$SAMSG  EQU   *-SAMSG\n         DS    0D\nSABOGUS  DS    CL256                   protection from runaway SAVALUEs\n*                                      and slot for unsaved fields\n*\n*  Save fields\n*\n         DS    0D\nSAVDSNAM DS    CL44\nSAVTNODE DS    CL8\nSAVTUID  DS    CL8\nSAVFNODE DS    CL8\nSAVFUID  DS    CL8\nSAVFVERS DS    CL8\nSAVFTIME DS    CL16\nSAVTTIME DS    CL16\nSAVNUMF  DS    F\nSAVFACK  DS    F\nSAVERRCD DS    F\nSAVRECCT DS    F\nSAVDDNAM DS    CL8\nSAVSECND DS    F\nSAVTYPE  DS    F\n*\n*  CS2 list (saved INMR02 info)\n*\nSACS2    DS    0D\nSACS2X   DS    CL(L$CS2)     CS2 - dummy\nSACS2A   DS    CL(L$CS2)     CS2 for 1st INMR02 (usually IEBCOPY)\nSACS2B   DS    CL(L$CS2)     CS2 for 2nd INMR02 (usually INMCOPY)\nSACS2C   DS    CL(L$CS2)     CS2 for 3rd INMR02 (INMCOPY when MSG)\nSACS2BAD EQU   *             too many CS2s if past here\n*\n         DS    0D\nL$SA     EQU   *-SAVEAREA\n         PRINT NOGEN\n         WARECV ,\n         DXSEG ,\nRECVCTL  UFINI DXDRCTL,L$SA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RECVGCTL": {"ttr": 8708, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00\\xc7\\x00\\xc7\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 199, "newlines": 199, "modlines": 0, "user": "XV0006"}, "text": "*\n*  Copyright 2008 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  Things to do:\n*----------------------------------------------------------------------\nRECVGCTL TITLE 'Read XMIT Control record'\n*----------------------------------------------------------------------\n         U#SET FUNC=RECV\n*----------------------------------------------------------------------\n* Function: Read the XMIT control record, assembling it from\n*           as many segments as necessary\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         R0  =\n*         R1  = when non-zero, R1 points at queued segment\n*                  with prefix fields (SEGL, SEGFLG)\n*               when zero, no input segment provided\n*\n* Exit:   R0  = control record length (data only, no SEGL and\n*               no SEGFLG present in output buffer)\n*               Upon EOF, R0 = 0\n*         R1  = address of control record data\n*               Upon EOF, R1 = 0\n*         R15 = 00 success\n*               04 EOF\n*               08 error(s) encountered\n*\n*\n* Abends: yes\n*\n* Notes:\n*\n* Diagnostics:\n*         1 - entry/exit/status\n*         2 - show returned control record\n*         3 - show read control segment(s)\n*----------------------------------------------------------------------\n* R2     length of MVCL source\n* R3     return value R0\n* R4     return value R1\n* R5     output buffer address\n* R6     segment address\n* R7     segment length\n* R8     address of MVCL destination (output buffer)\n* R9     length of MVCL destination\n* R10    length of free space in output buffer\n* R11    XMTWA\n* R12    base reg\n* R13    savearea\n*----------------------------------------------------------------------\nERR#1    EQU   1        EOF\nERR#2    EQU   2        buffer overflow\nERR#3    EQU   3        malformed control segment; no actual data\nERR#4    EQU   4        control rec length error (zero or negative)\nERR#5    EQU   5        encountered data segment\nERR#6    EQU   6        MVCL destructive overlap\n         TITLE ' '\n*----------------------------------------------------------------------\nRECVGCTL UPROC L=L$SA,ID=RGCT,WA=SAVEAREA,INIT=MVCL\n*----------------------------------------------------------------------\n*  Initialize\n*----------------------------------------------------------------------\n         LR    R6,R1                        save entry parm\n         UPSR  1,'GCTL enter',(R6)\n         MVC   RCVGCEYE,=C'RECVGCTL'        output buffer eyecatcher\n         L     R15,=A(RCVGCBUF-RECVWA)      output buffer offset in WA\n         LA    R8,RECVWA(R15)               output buffer addr\n         LR    R5,R8\n         L     R9,=A(L$GCBUFL)              output buffer length\n         LR    R10,R9\n*        STM   R0,R15,RCVREGS\n*        USNAP 'GCTL initialized',RCVREGS,16*4\n*----------------------------------------------------------------------\n*  Dequeue queued segment when provided\n*----------------------------------------------------------------------\n         LTR   R6,R6                        queued segment present?\n         BNZ   CKSEG                        yes, br\n*----------------------------------------------------------------------\n*  Read control segment\n*----------------------------------------------------------------------\nGETSEG   DS    0H\n         UCALL RECVGSEG                     retrieve XMIT segment\n         LTR   R6,R1                        @ returned segment or zero\n         BNZ   CKSEG\n*----------------------------------------------------------------------\n*  End of file on XMITIN\n*----------------------------------------------------------------------\nEOF      DS    0H\n         UDIAG 1,'GCTL EOF'\n         MVI   SAREASON,ERR#1               EOF\n         SLR   R3,R3                        R0 return value zero\n         SLR   R4,R4                        R1 return value zero\n         MVI   SARC+3,4                     EOF rc\n         B     EXIT\n*----------------------------------------------------------------------\n*  Check read segment\n*----------------------------------------------------------------------\n         USING XMITSEG,R6\nCKSEG    DS    0H\n         SLR   R7,R7\n         IC    R7,SEGL                      segment length\n         TM    SEGFLG,SEG$C                 control segment?\n         BO    HAVESEG                      yes, br\n         MVI   SAREASON,ERR#5               RECVGSEG returned data seg\n         UDIAG 0,'GCTL ERROR data segment',(R6),(R7)\n         B     DIE                          we should never see data\n         EJECT ,\n*----------------------------------------------------------------------\n*  Skip past SEGL & SEGFLG to control record data\n*----------------------------------------------------------------------\nHAVESEG  DS    0H\n         UDIAG 3,'GCTL control segment',(R6),(R7)\n         MVC   SASEGL,SEGL                  save segment length\n         MVC   SAFLG1,SEGFLG                save segment flag\n         LA    R0,L'SEGL+L'SEGFLG           length of prefix fields\n         AR    R6,R0                        skip segment prefix\n         SR    R7,R0                        segment data length\n         MVI   SAREASON,ERR#3               assume malformed segment\n         BNP   DIE\n*----------------------------------------------------------------------\n*  Append control segment's data to output buffer\n*----------------------------------------------------------------------\n*        STM   R0,R15,RCVREGS\n*        USNAP 'GCTL pre MVCL',RCVREGS,16*4\n*\n         MVI   SAREASON,ERR#2               assume truncation\n         CR    R10,R7                       will data fit in buffer?\n         BL    DIE\n         LR    R9,R7\n         LR    R2,R7\n         MVCL  R8,R6                        copy dest,source\n*\n         MVI   SAREASON,ERR#2               assume truncation\n         BC    4,DIE                        1st op (dest) len low\n*\n         MVI   SAREASON,ERR#6               assume destructive overlap\n         BC    1,DIE                        no data movement\n*\n         SR    R10,R2                       recalc free space\n*        STM   R0,R15,RCVREGS\n*        USNAP 'GCTL post MVCL',RCVREGS,16*4\n*----------------------------------------------------------------------\n*  Loop back until all segments of control record read\n*----------------------------------------------------------------------\n         TM    SAFLG1,SEG$L                 last segment in ctl rec?\n         BNO   GETSEG                       nope, read another segment\n*----------------------------------------------------------------------\n*  Calculate control record length\n*----------------------------------------------------------------------\n         LR    R3,R8                        @ end of ctl rec in WA\n         SR    R3,R5                        ctl rec length\n         MVI   SAREASON,ERR#4               ctl rec length error\n         BNP   DIE\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\nEXIT     DS    0H\n*        STM   R0,R15,RCVREGS\n*        USNAP 'GCTL exit regs',RCVREGS,16*4\n         UPSR  1,'GCTL exit R0',(R3)\n         UPSR  1,'GCTL exit R1',(R5)\n         UPSR  1,'GCTL exit rc',*SARC\n         LR    R0,R3                        control record length\n         LR    R1,R5                        control record address\n         UPEND R0=PASS,R1=PASS,RC=*SARC\n         EJECT ,\n*----------------------------------------------------------------------\n*  Abend\n*----------------------------------------------------------------------\nDIE      UABEND SAREASON\n         EJECT ,\n*\n         LTORG ,\n         EJECT ,\n*----------------------------------------------------------------------\n*  Savearea/workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSA       DS    18F\nSARC     DS    F\n*\nSASEGL   DS    X             saved segment SEGL\nSAFLG1   DS    X             saved segment SEGFLG\n*\nSAREASON DS    X             UABEND reason code\n*\n*\n         DS    0D\nL$SA     EQU   *-SAVEAREA\n         EJECT ,\n         PRINT GEN\n         WARECV GEN=,PRINT=ON\n         EJECT ,\n         DXSEG ,\n         EJECT ,\nRECVGCTL UFINI DXDRGCT,L$SA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RECVGET": {"ttr": 8712, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x01@\\x01@\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 320, "newlines": 320, "modlines": 0, "user": "XV0006"}, "text": "RECVGET  TITLE 'Get XMIT segment'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n* Things to do:\n*----------------------------------------------------------------------\n         U#SET FUNC=RECV\n*----------------------------------------------------------------------\n* Function: Returns a complete XMIT segment read from XMITIN, or EOF\n*\n*           XMITIN DCB is opened on the first call,\n*           closed on EOF.\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         R0  =  bits 00:07 flags: RGET$... (defined in WARECV)\n*                bits 08:31 currently unused\n*\n*         R1  =  currently ignored\n*\n* Exit:   R1  =  Address of segment (XMITSEG)\n*                upon EOF, R1 = 0\n*\n* Abends: U0001 XMITIN open failed\n*         U0002 internal error (R0 = code)\n*\n* Notes: RGSWA contains a buffer holding residual data, which\n*        represents data not yet returned to the caller, to be\n*        saved for a later call to RECVGET.\n*----------------------------------------------------------------------\n* R2     RGSWA (our workarea)\n* R3     DCB\n* R4     XMITSEG (not strictly necessary, only covers one instruction)\n*\n* R5     pointer to residual data within RGSBUF\n* R6     RGSROFF   - offset to residual data within RGSBUF\n*\n* R7     SEGL      - segment length for segment being built in RGSSEG\n* R8     scratch, pointer within RGSSEG where residual data is appended\n* R9     scratch, RGSSL    - # segment bytes currently in RGSSEG\n*\n* R10    scratch (careful)\n* R11    RCVWA\n* R12    base reg\n* R13    savearea/workarea\n*----------------------------------------------------------------------\nL$REC    EQU   80                           XMITIN LRECL\nINTE$1   EQU   1                            internal errors\nINTE$2   EQU   2\nINTE$3   EQU   3\nINTE$4   EQU   4\n         TITLE ' '\nRECVGET  UPROC L=L$SA,ID=RGET\n         STM   R0,R1,SAENTRY\n         UDIAG 1,'GET enter'\n         ICM   R2,15,RCV@GS                 find our workarea\n         BNZ   NORMAL                       already init'd, go\n*----------------------------------------------------------------------\n*  Initialize RGSWA\n*----------------------------------------------------------------------\n         UDIAG 2,'GET: init RGSWA'\n         LA    R2,RCVRGSWA\n         USING RGSWA,R2\n         UZERO (R2),L$RGSWA                 clear storage\n         ST    R2,RCV@GS                    save ptr to our workarea\n*----------------------------------------------------------------------\n*  Initialize - null segment\n*----------------------------------------------------------------------\nNORMAL   DS    0H\n         LA    R3,RGSDCB\n         USING IHADCB,R3\n         TM    SAR0B0,RGET$CLO              CLOSE order?\n         BO    CLOSE                        yes, br\n         LA    R4,RGSSEG                    segment being built\n         USING XMITSEG,R4\n         NI    RGSFLG1,255-RGS1FINI         no segment in RGSSEG\n         SLR   R0,R0\n         STH   R0,RGSSL                     zero bytes in segment\n         XC    RGSSEG,RGSSEG                clear segment\n*----------------------------------------------------------------------\n*  Check for call past EOF\n*----------------------------------------------------------------------\n         TM    RGSFLG2,RGS2EOF              already hit EOF?\n         BNO   CKDCB\n         UDIAG 2,'GET EOF at entry'\n         B     EXIT\n*----------------------------------------------------------------------\n*  Open XMITIN\n*----------------------------------------------------------------------\nCKDCB    DS    0H\n         TM    DCBOFLG1,DCBOFOPN            dcb open?\n         BO    DCBOPEN\n*\n         UDIAG 3,'GET opening XMITIN'\n         MVC   RGSDCB(L$DCB),MODLDCB        copy model DCB macro\n         MVC   RGSOPN(L$OPN),MODLOPN        copy model OPEN macro\n         OPEN  ((R3),INPUT),MF=(E,RGSOPN)\n         TM    DCBOFLG1,DCBOFOPN            opened?\n         BO    DCBOPEN\n*\n         ULOG  'RECVGET: XMITIN DCB open error'\n         UDIAG 0,'GET RGSWA',(R2),L$RGSWA\n         MVI   SAREASON,1                   XMITIN DCB didn't open\n         B     UABEND\n*\nDCBOPEN  DS    0H\n         EJECT ,\n*----------------------------------------------------------------------\n*  Main loop - If no more residual data, read\n*----------------------------------------------------------------------\n*\n*  Note it might be possible for the residual data to contain more\n*  than one segment (or portions thereof), so we may leave RECVGET\n*  with residual data still pending.\n*\nRESUME   DS    0H\n         TM    RGSFLG1,RGS1FINI             seg complete?\n         BO    EXIT                         yes, return to caller\n*\n         TM    RGSFLG1,RGS1RES              residual data?\n         BNO   READ                         no, need to get data\n         EJECT ,\n*----------------------------------------------------------------------\n*  Copy residual data to segment return area (RGSSEG).\n*----------------------------------------------------------------------\nCOPY     DS    0H\n         LH    R6,RGSROFF                   offset to residual data\n         LA    R5,RGSBUF(R6)                @ residual data\n*\n         LA    R0,INTE$1                    internal error #\n         LA    R10,L$REC                    XMITIN LRECL\n         SR    R10,R6                       # residual data bytes\n         BNP   DIE\n*\n         LH    R8,RGSSL                     # bytes in RGSSEG already\n         LR    R9,R8\n         AR    R9,R10\n         LA    R8,RGSSEG(R8)                @ next seg byte to append\n*\n         UDIAG 9,'GET: <COPY> regs',RCVREGS,16*4,REGS=YES\n*\n         BCTR  R10,0\n         EX    R10,COPYRES                  copy residual to segment\n         LA    R10,1(,R10)\n         STH   R9,RGSSL                     new # bytes in RGSSEG\n*\n*  It is now safe to examine SEGL, since the above code copied at\n*  least one byte to RGSSEG, so no matter what else, SEGL is valid.\n*\n         SLR   R7,R7\n         IC    R7,SEGL                 segment length\n*\n         UDIAG 9,'GET: <COPY> seg.segl',RGSSEG,(R7)\n         B     CKSEG\n*\nCOPYRES  MVC   0(*-*,R8),0(R5)\n         EJECT ,\n*----------------------------------------------------------------------\n*  Determine if the segment is now complete\n*----------------------------------------------------------------------\nCKSEG    DS    0H\n         CR    R7,R9                   seglen : bytes in seg\n         BL    SCR                     segment   complete,    residual\n         BE    SCNR                    segment   complete, no residual\n*\n*  The segment is not yet complete, and we've consumed all of\n*  the residual data; get some more\n*\nSINR     DS    0H                           seg incomplete, no residual\n         NI    RGSFLG1,255-RGS1RES\n         SLR   R6,R6\n         STH   R6,RGSROFF\n         XC    RGSBUF,RGSBUF\n         UDIAG 5,'GET SINR',RCVREGS,16*4,REGS=YES\n         B     READ                         finish segment\n*\n*  The segment is now complete, but ... there's some residual\n*  data we need to reclaim from the RGSSEG\n*\nSCR      DS    0H                           segment complete, residual\n         UDIAG 5,'GET SCR1',RCVREGS,16*4,REGS=YES\n         SR    R9,R7                   # bytes residual data remaining\n         OI    RGSFLG1,RGS1FINI+RGS1RES         seg complete\n         LA    R6,L$REC\n         SR    R6,R9                        new residual data offset\n         STH   R6,RGSROFF                   new resoff\n         UDIAG 5,'GET SCR2',RCVREGS,16*4,REGS=YES\n         B     EXIT\n*\n*  The segment is now complete, and exactly consumed the residual\n*  data\n*\nSCNR     DS    0H                           seg complete, no residual\n         OI    RGSFLG1,RGS1FINI                 seg complete\n         NI    RGSFLG1,255-RGS1RES              no residual\n         SLR   R6,R6\n         STH   R6,RGSROFF\n         XC    RGSBUF,RGSBUF\n         UDIAG 5,'GET SCNR',RCVREGS,16*4,REGS=YES\n         B     EXIT\n*\nDIE      STM   R0,R15,RCVREGS\n         UPSR  0,'RECVGET internal error',(R0)\n         UDIAG 0,'RECVGET regs',RCVREGS,16*4\n         MVI   SAREASON,2\nUABEND   UABEND SAREASON\n*\n         EJECT ,\n*----------------------------------------------------------------------\n*  Read input record from XMITIN\n*----------------------------------------------------------------------\n*\n*  We're not allowed to read new data until we've drained RGSBUF\n*  Likewise, reading past EOF seems excessively dense\n*\nREAD     DS    0H\n         LA    R0,INTE$2\n         TM    RGSFLG1,RGS1RES              residual data?\n         BO    DIE\n*\n         LA    R0,INTE$3\n         TM    RGSFLG2,RGS2EOF              already hit EOF?\n         BO    DIE\n*\n         LR    R10,R13                      save workarea ptr\n         LA    R13,SADMSA                   provide data mgt savearea\n         GET   (R3),RGSBUF                  read record\n         LR    R13,R10                      restore workarea ptr\n         TM    RGSFLG2,RGS2EOF              EOF?\n         BO    ENDOFILE\n*\n         UDIAG 4,'GET: GET record',RGSBUF,L'RGSBUF\n*\n*  Indicate residual data exists, restart residual code\n*\n         SLR   R6,R6\n         STH   R6,RGSROFF                   offset = 0\n         OI    RGSFLG1,RGS1RES              residual data valid\n         B     RESUME                       continue building segment\n         EJECT ,\n*----------------------------------------------------------------------\n* End Of File - XMITIN EODAD routine\n*----------------------------------------------------------------------\nEOFRTN   DS    0H\n         OI    RGSFLG2,RGS2EOF              XMITIN EOF\n         BR    R14\n*----------------------------------------------------------------------\n*  End Of File\n*----------------------------------------------------------------------\nENDOFILE DS    0H\n         UDIAG 3,'GET: EOF, closing XMITIN'\nCLOSE    DS    0H\n         TM    DCBOFLGS,DCBOFOPN            DCB open?\n         BNO   CLOSEX\n         MVC   RGSCLOS(L$CLOS),MODLCLOS     copy model CLOSE macro\n         CLOSE ((R3),),MF=(E,RGSCLOS)\nCLOSEX   DS    0H\n         TM    SAR0B0,RGET$CLO              CLOSE order?\n         BO    EXIT                         yes, br\n         TM    RGSFLG1,RGS1FINI             segment complete?\n         BO    EXIT                         fine, done\n*\n         ICM   R10,3,RGSSL\n         BZ    EXIT\n*\n         UDIAG 3,'GET incomplete seg at EOF',RGSSEG,L'RGSSEG\n         EJECT ,\n*----------------------------------------------------------------------\n*  Return segment or EOF to caller\n*----------------------------------------------------------------------\nEXIT     DS    0H                           return code already set\n         UDIAG 9,'GET: partial RGSWA at exit',(R2),L$RGSNAP\n         UDIAG 1,'GET exit'\n         SLR   R1,R1                        assume EOF, R1 = 0\n         TM    RGSFLG1,RGS1FINI             valid segement to return?\n         BNO   EXIT99\n         LA    R2,RGSSEG                    R1 @ returned segment\n         SLR   R14,R14\n         IC    R14,0(,R2)\n         UDIAG 2,'GET returned segment',(R2),(R14)\n         LR    R1,R2                        R1 @ returned segment\nEXIT99   UPEND R1=PASS,RC=0                 return R1\n         EJECT ,\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\nMODLOPN  OPEN  (,),MF=L                model OPEN\nL$OPN    EQU   *-MODLOPN               l' model open\n*\nMODLCLOS CLOSE (,),MF=L                model CLOSE\nL$CLOS   EQU   *-MODLCLOS              l' model close\n*\nMODLDCB  DCB   DDNAME=XMITIN,                                          +\n               EODAD=EOFRTN,                                           +\n               MACRF=GM,DSORG=PS,RECFM=FB,                             +\n               LRECL=80\nL$DCB    EQU   *-MODLDCB\n*\n         LTORG ,\n         EJECT ,\n*----------------------------------------------------------------------\n*  Savearea/workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSA       DS    18F\nSADMSA   DS    18F                     Data Management savearea\nSAENTRY  DS    2F                      R0:R1 at entry\nSAR0B0   EQU   SAENTRY+00,1            high byte of R0 - options\n*\nSAREASON DS    X                       UABEND reason code\nSAEND    DS    0D\nL$SA     EQU   *-SAVEAREA\n         EJECT ,\n         DXSEG ,\n         PRINT NOGEN\n         WARECV ,\n         DCBD  DSORG=PS,DEVD=DA\nRECVGET  UFINI DXDRGET,L$SA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RECVGSEG": {"ttr": 8961, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x01@\\x01@\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 320, "newlines": 320, "modlines": 0, "user": "XV0006"}, "text": "RECVGSEG TITLE 'Get XMIT segment'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n* Things to do:\n*----------------------------------------------------------------------\n         U#SET FUNC=RECV\n*----------------------------------------------------------------------\n* Function: Returns a complete XMIT segment read from XMITIN, or EOF\n*\n*           XMITIN DCB is opened on the first call,\n*           closed on EOF.\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         R0  =  bits 00:07 flags: RGET$... (defined in WARECV)\n*                bits 08:31 currently unused\n*\n*         R1  =  currently ignored\n*\n* Exit:   R1  =  Address of segment (XMITSEG)\n*                upon EOF, R1 = 0\n*\n* Abends: U0001 XMITIN open failed\n*         U0002 internal error (R0 = code)\n*\n* Notes: RGSWA contains a buffer holding residual data, which\n*        represents data not yet returned to the caller, to be\n*        saved for a later call to RECVGSEG.\n*----------------------------------------------------------------------\n* R2     RGSWA (our workarea)\n* R3     DCB\n* R4     XMITSEG (not strictly necessary, only covers one instruction)\n*\n* R5     pointer to residual data within RGSBUF\n* R6     RGSROFF   - offset to residual data within RGSBUF\n*\n* R7     SEGL      - segment length for segment being built in RGSSEG\n* R8     scratch, pointer within RGSSEG where residual data is appended\n* R9     scratch, RGSSL    - # segment bytes currently in RGSSEG\n*\n* R10    scratch (careful)\n* R11    RCVWA\n* R12    base reg\n* R13    savearea/workarea\n*----------------------------------------------------------------------\nL$REC    EQU   80                           XMITIN LRECL\nINTE$1   EQU   1                            internal errors\nINTE$2   EQU   2\nINTE$3   EQU   3\nINTE$4   EQU   4\n         TITLE ' '\nRECVGSEG UPROC L=L$SA,ID=RGET\n         STM   R0,R1,SAENTRY\n         UDIAG 1,'GET enter'\n         ICM   R2,15,RCV@GS                 find our workarea\n         BNZ   NORMAL                       already init'd, go\n*----------------------------------------------------------------------\n*  Initialize RGSWA\n*----------------------------------------------------------------------\n         UDIAG 2,'GET: init RGSWA'\n         LA    R2,RCVRGSWA\n         USING RGSWA,R2\n         UZERO (R2),L$RGSWA                 clear storage\n         ST    R2,RCV@GS                    save ptr to our workarea\n*----------------------------------------------------------------------\n*  Initialize - null segment\n*----------------------------------------------------------------------\nNORMAL   DS    0H\n         LA    R3,RGSDCB\n         USING IHADCB,R3\n         TM    SAR0B0,RGET$CLO              CLOSE order?\n         BO    CLOSE                        yes, br\n         LA    R4,RGSSEG                    segment being built\n         USING XMITSEG,R4\n         NI    RGSFLG1,255-RGS1FINI         no segment in RGSSEG\n         SLR   R0,R0\n         STH   R0,RGSSL                     zero bytes in segment\n         XC    RGSSEG,RGSSEG                clear segment\n*----------------------------------------------------------------------\n*  Check for call past EOF\n*----------------------------------------------------------------------\n         TM    RGSFLG2,RGS2EOF              already hit EOF?\n         BNO   CKDCB\n         UDIAG 2,'GET EOF at entry'\n         B     EXIT\n*----------------------------------------------------------------------\n*  Open XMITIN\n*----------------------------------------------------------------------\nCKDCB    DS    0H\n         TM    DCBOFLG1,DCBOFOPN            dcb open?\n         BO    DCBOPEN\n*\n         UDIAG 3,'GET opening XMITIN'\n         MVC   RGSDCB(L$DCB),MODLDCB        copy model DCB macro\n         MVC   RGSOPN(L$OPN),MODLOPN        copy model OPEN macro\n         OPEN  ((R3),INPUT),MF=(E,RGSOPN)\n         TM    DCBOFLG1,DCBOFOPN            opened?\n         BO    DCBOPEN\n*\n         ULOG  'RECVGSEG: XMITIN DCB open error'\n         UDIAG 0,'GET RGSWA',(R2),L$RGSWA\n         MVI   SAREASON,1                   XMITIN DCB didn't open\n         B     UABEND\n*\nDCBOPEN  DS    0H\n         EJECT ,\n*----------------------------------------------------------------------\n*  Main loop - If no more residual data, read\n*----------------------------------------------------------------------\n*\n*  Note it might be possible for the residual data to contain more\n*  than one segment (or portions thereof), so we may leave RECVGSEG\n*  with residual data still pending.\n*\nRESUME   DS    0H\n         TM    RGSFLG1,RGS1FINI             seg complete?\n         BO    EXIT                         yes, return to caller\n*\n         TM    RGSFLG1,RGS1RES              residual data?\n         BNO   READ                         no, need to get data\n         EJECT ,\n*----------------------------------------------------------------------\n*  Copy residual data to segment return area (RGSSEG).\n*----------------------------------------------------------------------\nCOPY     DS    0H\n         LH    R6,RGSROFF                   offset to residual data\n         LA    R5,RGSBUF(R6)                @ residual data\n*\n         LA    R0,INTE$1                    internal error #\n         LA    R10,L$REC                    XMITIN LRECL\n         SR    R10,R6                       # residual data bytes\n         BNP   DIE\n*\n         LH    R8,RGSSL                     # bytes in RGSSEG already\n         LR    R9,R8\n         AR    R9,R10\n         LA    R8,RGSSEG(R8)                @ next seg byte to append\n*\n         UDIAG 9,'GET: <COPY> regs',RCVREGS,16*4,REGS=YES\n*\n         BCTR  R10,0\n         EX    R10,COPYRES                  copy residual to segment\n         LA    R10,1(,R10)\n         STH   R9,RGSSL                     new # bytes in RGSSEG\n*\n*  It is now safe to examine SEGL, since the above code copied at\n*  least one byte to RGSSEG, so no matter what else, SEGL is valid.\n*\n         SLR   R7,R7\n         IC    R7,SEGL                 segment length\n*\n         UDIAG 9,'GET: <COPY> seg.segl',RGSSEG,(R7)\n         B     CKSEG\n*\nCOPYRES  MVC   0(*-*,R8),0(R5)\n         EJECT ,\n*----------------------------------------------------------------------\n*  Determine if the segment is now complete\n*----------------------------------------------------------------------\nCKSEG    DS    0H\n         CR    R7,R9                   seglen : bytes in seg\n         BL    SCR                     segment   complete,    residual\n         BE    SCNR                    segment   complete, no residual\n*\n*  The segment is not yet complete, and we've consumed all of\n*  the residual data; get some more\n*\nSINR     DS    0H                           seg incomplete, no residual\n         NI    RGSFLG1,255-RGS1RES\n         SLR   R6,R6\n         STH   R6,RGSROFF\n         XC    RGSBUF,RGSBUF\n         UDIAG 5,'GET SINR',RCVREGS,16*4,REGS=YES\n         B     READ                         finish segment\n*\n*  The segment is now complete, but ... there's some residual\n*  data we need to reclaim from the RGSSEG\n*\nSCR      DS    0H                           segment complete, residual\n         UDIAG 5,'GET SCR1',RCVREGS,16*4,REGS=YES\n         SR    R9,R7                   # bytes residual data remaining\n         OI    RGSFLG1,RGS1FINI+RGS1RES         seg complete\n         LA    R6,L$REC\n         SR    R6,R9                        new residual data offset\n         STH   R6,RGSROFF                   new resoff\n         UDIAG 5,'GET SCR2',RCVREGS,16*4,REGS=YES\n         B     EXIT\n*\n*  The segment is now complete, and exactly consumed the residual\n*  data\n*\nSCNR     DS    0H                           seg complete, no residual\n         OI    RGSFLG1,RGS1FINI                 seg complete\n         NI    RGSFLG1,255-RGS1RES              no residual\n         SLR   R6,R6\n         STH   R6,RGSROFF\n         XC    RGSBUF,RGSBUF\n         UDIAG 5,'GET SCNR',RCVREGS,16*4,REGS=YES\n         B     EXIT\n*\nDIE      STM   R0,R15,RCVREGS\n         UPSR  0,'RECVGSEGinternal error',(R0)\n         UDIAG 0,'RECVGSEGregs',RCVREGS,16*4\n         MVI   SAREASON,2\nUABEND   UABEND SAREASON\n*\n         EJECT ,\n*----------------------------------------------------------------------\n*  Read input record from XMITIN\n*----------------------------------------------------------------------\n*\n*  We're not allowed to read new data until we've drained RGSBUF\n*  Likewise, reading past EOF seems excessively dense\n*\nREAD     DS    0H\n         LA    R0,INTE$2\n         TM    RGSFLG1,RGS1RES              residual data?\n         BO    DIE\n*\n         LA    R0,INTE$3\n         TM    RGSFLG2,RGS2EOF              already hit EOF?\n         BO    DIE\n*\n         LR    R10,R13                      save workarea ptr\n         LA    R13,SADMSA                   provide data mgt savearea\n         GET   (R3),RGSBUF                  read record\n         LR    R13,R10                      restore workarea ptr\n         TM    RGSFLG2,RGS2EOF              EOF?\n         BO    ENDOFILE\n*\n         UDIAG 4,'GET: GET record',RGSBUF,L'RGSBUF\n*\n*  Indicate residual data exists, restart residual code\n*\n         SLR   R6,R6\n         STH   R6,RGSROFF                   offset = 0\n         OI    RGSFLG1,RGS1RES              residual data valid\n         B     RESUME                       continue building segment\n         EJECT ,\n*----------------------------------------------------------------------\n* End Of File - XMITIN EODAD routine\n*----------------------------------------------------------------------\nEOFRTN   DS    0H\n         OI    RGSFLG2,RGS2EOF              XMITIN EOF\n         BR    R14\n*----------------------------------------------------------------------\n*  End Of File\n*----------------------------------------------------------------------\nENDOFILE DS    0H\n         UDIAG 3,'GET: EOF, closing XMITIN'\nCLOSE    DS    0H\n         TM    DCBOFLGS,DCBOFOPN            DCB open?\n         BNO   CLOSEX\n         MVC   RGSCLOS(L$CLOS),MODLCLOS     copy model CLOSE macro\n         CLOSE ((R3),),MF=(E,RGSCLOS)\nCLOSEX   DS    0H\n         TM    SAR0B0,RGET$CLO              CLOSE order?\n         BO    EXIT                         yes, br\n         TM    RGSFLG1,RGS1FINI             segment complete?\n         BO    EXIT                         fine, done\n*\n         ICM   R10,3,RGSSL\n         BZ    EXIT\n*\n         UDIAG 3,'GET incomplete seg at EOF',RGSSEG,L'RGSSEG\n         EJECT ,\n*----------------------------------------------------------------------\n*  Return segment or EOF to caller\n*----------------------------------------------------------------------\nEXIT     DS    0H                           return code already set\n         UDIAG 9,'GET: partial RGSWA at exit',(R2),L$RGSNAP\n         UDIAG 1,'GET exit'\n         SLR   R1,R1                        assume EOF, R1 = 0\n         TM    RGSFLG1,RGS1FINI             valid segement to return?\n         BNO   EXIT99\n         LA    R2,RGSSEG                    R1 @ returned segment\n         SLR   R14,R14\n         IC    R14,0(,R2)\n         UDIAG 2,'GET returned segment',(R2),(R14)\n         LR    R1,R2                        R1 @ returned segment\nEXIT99   UPEND R1=PASS,RC=0                 return R1\n         EJECT ,\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\nMODLOPN  OPEN  (,),MF=L                model OPEN\nL$OPN    EQU   *-MODLOPN               l' model open\n*\nMODLCLOS CLOSE (,),MF=L                model CLOSE\nL$CLOS   EQU   *-MODLCLOS              l' model close\n*\nMODLDCB  DCB   DDNAME=XMITIN,                                          +\n               EODAD=EOFRTN,                                           +\n               MACRF=GM,DSORG=PS,RECFM=FB,                             +\n               LRECL=80\nL$DCB    EQU   *-MODLDCB\n*\n         LTORG ,\n         EJECT ,\n*----------------------------------------------------------------------\n*  Savearea/workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSA       DS    18F\nSADMSA   DS    18F                     Data Management savearea\nSAENTRY  DS    2F                      R0:R1 at entry\nSAR0B0   EQU   SAENTRY+00,1            high byte of R0 - options\n*\nSAREASON DS    X                       UABEND reason code\nSAEND    DS    0D\nL$SA     EQU   *-SAVEAREA\n         EJECT ,\n         DXSEG ,\n         PRINT NOGEN\n         WARECV ,\n         DCBD  DSORG=PS,DEVD=DA\nRECVGSEG UFINI DXDRGET,L$SA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RECVMSG": {"ttr": 8967, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00i\\x00i\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 105, "newlines": 105, "modlines": 0, "user": "XV0006"}, "text": "RECVMSG  TITLE 'RECEIVE INMCOPY - embedded message'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  Things to do:\n*----------------------------------------------------------------------\n         U#SET FUNC=RECV\n*----------------------------------------------------------------------\n* Function: Display embedded MESSAGE on LOG\n*\n* Entry:  S/370 ECMODE KEY=8, STATE=PROB, AUTHORIZED\n*\n*         R0  = ignored\n*         R1  = address of CS2 representing INMCOPY\n*\n* Exit:   R15 = return code\n*\n*               00   success\n*               04   control segment returned (everything else OK)\n*\n*         R1  = zero or address of control segment\n*\n* Abends: yes\n*\n* Notes:\n*\n* Debug:  1  -  entry/exit; show exit rc\n*         2  -  CS2 at entry\n*         3  -  show returned data block\n*----------------------------------------------------------------------\n* R2\n* R3\n* R4\n* R5\n* R6\n* R7\n* R8\n* R9\n* R10    CS2\n* R11    RECVWA\n*----------------------------------------------------------------------\nERR#1    EQU   1        R1 = 0 at entry\n         TITLE ' '\n*----------------------------------------------------------------------\nRECVMSG  UPROC L=L$SA,ID=RMSG\n*----------------------------------------------------------------------\n*  Verify parm\n*----------------------------------------------------------------------\nINIT     DS    0H\n         MVI   SAREASON,ERR#1               CS2 parm = 0\n         LTR   R10,R1                       save CS2\n         BZ    DIE\n         USING CS2,R10\n         UDIAG 1,'RECVMSG entered'\n         UDIAG 2,'RECVMSG INMCOPY CS2',(R10),L$CS2\n*----------------------------------------------------------------------\n*  Retrieve data block, display it\n*----------------------------------------------------------------------\nGETBLOCK DS    0H\n         LA    R0,L'SABUF              buffer length\n         LA    R1,SABUF                buffer address\n         UCALL RECVBLK,ERR=READCTL     retrieve data block\n         LR    R9,R0                   length of data returned\n         ULOG  SABUF,(R9)              display message record\n         B     GETBLOCK\n*\nREADCTL  DS    0H\n         LR    R2,R15                  save RECVBLK rc\n         LR    R3,R1                   save ctl seg addr\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\nEXIT     DS    0H\n         UPSR  1,'RECVMSG exited rc',(R2)\n         LR    R1,R3\n         UPEND RC=(R2),R1=PASS              return R1, R15\n*\nDIE      UABEND SAREASON\n         EJECT ,\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\n         LTORG ,\n*----------------------------------------------------------------------\n*  Savearea/workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSASA     DS    18F                     savearea for anyone we call\nSAREASON DS    X                       UABEND reason code\nSACTL    DS    F                       @ control segment\nSABUF    DS    CL80                    message record buffer\n         DS    0D\nL$SA     EQU   *-SAVEAREA\n*\n         EJECT ,\n         DRCS2 ,\n*\n         PUSH  PRINT\n         PRINT NOGEN\n         WARECV ,\n         POP   PRINT\n*\nRECVMSG  UFINI DXDRMSG,L$SA              pseudo-register\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RECVRCPY": {"ttr": 8970, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x01\\x18\\x01\\x18\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 280, "newlines": 280, "modlines": 0, "user": "XV0006"}, "text": "RECVRCPY TITLE 'RECEIVE INMCOPY'\n*\n* Copyright 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  To do:\n*----------------------------------------------------------------------\n         U#SET FUNC=RECV\n*----------------------------------------------------------------------\n* Function: Internal implementation of INMCOPY utility\n*\n*           Copy XMIT data blocks to the specified DDNAME\n*\n*           If the TERM flag is set, the data following the\n*           INMR03 represents a message file, in which case\n*           the message file will be echoed to the LOG\n*           rather than being written to DDNAME.\n*\n* Entry:  S/370 ECMODE KEY=8, STATE=PROB, AUTHORIZED\n*\n*         R0  = CL8'ddname' (output file)\n*         R1  = address of CS2 representing INMCOPY\n*\n* Exit:   R15 = return code\n*\n*         00   success\n*              R1 = 0\n*\n*         04   control segment returned (everything else OK)\n*              R1  = address of control segment\n*\n* Abends: yes\n*\n* Diagnostics:\n*         1  -  entry/exit; show exit rc\n*         2  -  CS2 at entry, DCB (open/close), RECVBLK nonzero rc\n*         3  -  show returned data block\n*\n* Notes:  A few words about INMR02s, from which our CS2 was built:\n*         IBM doc, at least at the OS/390 2.8 level I checked, states:\n*\n*             The text units that are in the INMR02 record describe\n*             the output of the utility operation.\n*\n*         This is slightly misleading, at least from what I've\n*         seen in XMIT files.  The INMR02 represents the INPUT\n*         to a utility at TRANSMIT time; at RECEIVE time, it\n*         represents the OUTPUT of a utility.\n*\n*         In addition, the RECFM field (which has an intrinsic DCB\n*         length of one byte) is represented in the INMR02\n*         as two bytes, with the actual RECFM value at the\n*         beginning of the value string.  Everywhere else (that\n*         I've noticed), values which are represented in the INMR02s\n*         with lengths larger than their intrinsic lengths are\n*         right justified; RECFM is the exception.\n*         I've no idea what the 2nd RECFM byte represents.\n*----------------------------------------------------------------------\n* R2\n* R3     DCB\n* R4\n* R5\n* R6\n* R7     scratch\n* R8     buffer addr\n* R9     buffer length\n* R10    CS2\n*----------------------------------------------------------------------\nERR#1    EQU   1        R0 = 0 at entry\nERR#2    EQU   2        R1 = 0 at entry\nERR#3    EQU   3        BLKSIZE not specified in CS2\nERR#4    EQU   4        LRECL   not specified in CS2\nERR#5    EQU   5        DCB failed to OPEN\nERR#6    EQU   6        read error\n         TITLE ' '\n*----------------------------------------------------------------------\nRECVRCPY UPROC L=L$SA,ID=RCPY,WA=SAVEAREA\n*----------------------------------------------------------------------\n*  Initialize\n*----------------------------------------------------------------------\nINIT     DS    0H\n         MVI   SAREASON,ERR#1               DDname parm = 0\n         LTR   R15,R0\n         BZ    DIE\n         MVI   SAREASON,ERR#2               CS2 parm = 0\n         LTR   R10,R1                       save CS2\n         BZ    DIE\n         MVC   SADDNAME,0(R15)              save DDNAME\n*\n         USING CS2,R10\n         UDIAG 1,'RCPY enter'\n         UDIAG 2,'RCPY INMCOPY CS2 at entry',(R10),L$CS2\n         LA    R14,L$CS2\n         SR    R10,R14\n         UDIAG 2,'RCPY IEBCOPY CS2 at entry',(R10),L$CS2\n         LA    R14,L$CS2\n         AR    R10,R14\n         EJECT ,\n*----------------------------------------------------------------------\n*  Open output DDNAME\n*----------------------------------------------------------------------\nCKDCB    DS    0H\n         LA    R3,SADCB\n         USING IHADCB,R3\n         MVC   SADCB(L$DCB),MODLDCB         copy model DCB macro\n         MVC   SAOPN(L$OPN),MODLOPN         copy model OPEN macro\n         MVC   DCBDDNAM,SADDNAME            overlay DDNAME\n*\n         MVC   DCBDSORG,CS2DSORG+2          overlay DSORG\n         MVC   DCBRECFM,CS2RECFM+2          overlay RECFM\n         MVI   SAREASON,ERR#3               BLKSIZE not specified\n         ICM   R0,15,CS2BLKSZ               have BLKSIZE spec'd?\n         BZ    DIE\n         STCM  R0,3,DCBBLKSI                overlay BLKSIZE\n         MVI   SAREASON,ERR#4               LRECL not specified\n         ICM   R0,15,CS2LRECL               have LRECL spec'd?\n         BZ    DIE\n         STCM  R0,3,DCBLRECL                overlay BLKSIZE\n*\n         UDIAG 2,'RCPY pre open DCB',(R3),L$DCB\n         OPEN  ((R3),OUTPUT),MF=(E,SAOPN)\n         TM    DCBOFLG1,DCBOFOPN            opened?\n         BO    DCBOPEN\n*\n         UDIAG 0,'RECVRCPY DCB open error',(R3),L$DCB\n         MVI   SAREASON,ERR#5               DCB didn't open\nUABEND   UABEND SAREASON                    ABEND w/ diagnostic msgs\n*\nDIE      STM   R0,R15,RCVREGS\n         UDIAG 0,'RECVRCPY pre-ABEND regs',RCVREGS,16*4\n         B     UABEND\n*\nDCBOPEN  DS    0H\n*----------------------------------------------------------------------\n*  Allocate buffer\n*----------------------------------------------------------------------\nBUFALLOC DS    0H\n         L     R0,=A(32*1024)          max QSAM blocksize\n         ST    R0,SALBUF\n         GETMAIN R,LV=(0)              allocate buffer\n         ST    R1,SA@BUF\n         EJECT ,\n*----------------------------------------------------------------------\n*  Retrieve data block\n*----------------------------------------------------------------------\nGETBLOCK DS    0H\n         LA    R14,4                   L'RDW\n         LM    R0,R1,SAXBUF            R0=BUFL, R1@BUF\n         LA    R1,0(R14,R1)            reserve RDW space\n         SR    R0,R14\n         UCALL RECVBLK,ERR=READCTL     retrieve data block\n         LTR   R8,R1                   @ buffer\n         BZ    READERR\n         LTR   R9,R0                   length of block or 0 (no data)\n         BNZ   WRITE\n*\nREADCTL  DS    0H\n         ST    R1,SACTL                save ctl seg addr\n         ST    R15,SARC                save RECVBLK rc\n         UPSR  2,'RCPY RECVBLK rc',(R15)\n         OI    SAFLG1,SA1CTL           control segment returned\n         B     CLOSE\n*\nREADERR  DS    0H\n         UDIAG 0,'RECVRCPY XMIT read error',RCVREGS,16*4,REGS=YES\n         UDIAG 0,'RECVRCPY DCB',(R3),L$DCB\n         MVI   SAREASON,ERR#6               read error\n         B     UABEND\n         EJECT ,\n*----------------------------------------------------------------------\n*  Write data block\n*----------------------------------------------------------------------\nWRITE    DS    0H\n         TM    DCBRECFM,DCBRECU        RECFM=U?\n         BO    WRITEU\n         LH    R7,DCBLRECL             LRECL\n         TM    DCBRECFM,DCBRECF        RECFM=F?\n         BO    WRITEF\nWRITEV   L     R8,SA@BUF               RECFM=V; @ RDW space\n         LA    R9,4(,R9)               add RDW overhead\n         STH   R9,0(,R8)               create RDW\n         UPSR  3,'RCPY PUT-V data block RDW length',(R9)\nWRITEU   DS    0H\n         UDIAG 3,'RCPY PUT data block',(R8),(R9)\n         PUT   (R3),(R8)               write IEBCOPY unload rec\n         B     GETBLOCK\n*\nWRITEF   DS    0H\n         UDIAG 3,'RCPY PUT-F data block',(R8),(R9)\n         PUT   (R3),(R8)               write IEBCOPY unload rec\n         AR    R8,R7                   @ next fixed length record\n         SR    R9,R7                   remaining size of buffer\n         BP    WRITEF                  write rest of recs in block\n         B     GETBLOCK\n         EJECT ,\n*----------------------------------------------------------------------\n*  Close output\n*----------------------------------------------------------------------\nCLOSE    DS    0H\n         UDIAG 2,'RCPY closing DCB',(R3),L$DCB\n         MVC   SACLOS(L$CLOS),MODLCLOS      copy model CLOSE macro\n         CLOSE ((R3),),MF=(E,SACLOS)\n*----------------------------------------------------------------------\n*  Free buffer\n*----------------------------------------------------------------------\nFREEBUF  DS    0H\n         LM    R0,R1,SAXBUF\n         LTR   R0,R0\n         BZ    NOFREE\n         FREEMAIN R,LV=(0),A=(1)            free output buffer\nNOFREE   DS    0H\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\nEXIT     DS    0H\n         L     R2,SARC\n         UPSR  1,'RCPY exit rc',(R2)\n         L     R1,SACTL\n         UPEND RC=(R2),R1=PASS              return R1, R15\n         EJECT ,\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\nMODLOPN  OPEN  (,),MF=L                model OPEN\nL$OPN    EQU   *-MODLOPN               l' model open\n*\nMODLCLOS CLOSE (,),MF=L                model CLOSE\nL$CLOS   EQU   *-MODLCLOS              l' model close\n*\nMODLDCB  DCB   DDNAME=IEBUT1,                                          +\n               MACRF=PM,                                               +\n               DSORG=PS,                                               +\n               LRECL=0\nL$DCB    EQU   *-MODLDCB\n         LTORG ,\n*        EJECT ,\n*----------------------------------------------------------------------\n*  Savearea/workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSASA     DS    18F                     savearea for anyone we call\n*\nSAFLG1   DS    X\nSA1CTL   EQU   128                     have control segment\n*\nSAREASON DS    X                       UABEND reason code\n*\nSARC     DS    F                       our return code\nSADDNAME DS    CL8                     output DDNAME\n*\nSACTL    DS    F                       @ control segment\n*\nSAXBUF   DS    0F\nSALBUF   DS    F                       output buffer length\nSA@BUF   DS    A                       output buffer address\n*\nSAOPN    OPEN  (,),MF=L\nSACLOS   OPEN  (,),MF=L\nSADCB    DCB   DDNAME=IEBUT1,                                          +\n               MACRF=PM,                                               +\n               DSORG=PS\n*\n         DS    0D\nL$SA     EQU   *-SAVEAREA\n*\n         EJECT ,\n         DRCS2 ,\n*\n         PUSH  PRINT\n         PRINT NOGEN\n*\n         WARECV ,\n*\n         DCBD  DSORG=PS,DEVD=DA\n*\n         POP   PRINT\n*\n         PRINT GEN\nRECVRCPY UFINI DXDRCPY,L$SA            pseudo-register\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RECVUTIL": {"ttr": 9220, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x01*\\x01*\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 298, "newlines": 298, "modlines": 0, "user": "XV0006"}, "text": "RECVUTIL TITLE 'Call UTILITY'\n*\n* Copyright 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  To do:\n*----------------------------------------------------------------------\n         U#SET FUNC=RECV\n*----------------------------------------------------------------------\n* Function: Given a CS2 (RECVCS2), call the indicated UTILITY\n*           If multiple utilities apply to the same file #, call\n*           them all\n*\n* Entry:  S/370 ECMODE KEY=8, STATE=PROB, AUTHORIZED\n*\n*         R0  =\n*         R1  = address of CS2\n*\n* Exit:   R15 = return code\n*\n*               00   success\n*                    R1 = 0 - no control segment emitted\n*\n*               04   control segment returned (everything else OK)\n*                    R1 = address of control segment\n*\n*               08   Utility return code > 4\n*                    R1 = 0 or @ control segment\n*\n*               12   Utility not recognized\n*                    R1 = 0 or @ control segment\n*\n*               16   Utility LOAD failed\n*                    R1 = 0 or @ control segment\n*\n* Notes: Sets CS2DONE to indicate CS2 has been handled\n*----------------------------------------------------------------------\n* R2     return code\n* R3     scratch\n* R4\n* R5     BXLE\n* R6     BXLE\n* R7     BXLE\n* R8\n* R9\n* R10    CS2\n*----------------------------------------------------------------------\nRC#0     EQU   0        everything ok\nRC#4     EQU   4        control segment emitted; R1 @ segment\nRC#8     EQU   8        utility rc > 4\nRC#12    EQU   12       unsupported utility\nRC#16    EQU   16       LOAD of utility failed\n*\nERR#1    EQU   1        support routine unresolved\nERR#2    EQU   2        returned ctl segment SEGL=0\nERR#3    EQU   3        bad XMIT; two INMCOPYs for same file\nERR#4    EQU   4        LOAD error\n         TITLE ' '\n*----------------------------------------------------------------------\nRECVUTIL UPROC L=L$SA,ID=RUTL,WA=SAVEAREA,INIT=(XC,2)\n*----------------------------------------------------------------------\n*  Initialize\n*----------------------------------------------------------------------\nINIT     DS    0H\n         STM   R0,R1,SAENTRY\n         SLR   R2,R2                        assume good return code\n         LR    R10,R1                       save CS2\n         USING CS2,R10\n         UDIAG 1,'UTIL enter'\n         UDIAG 2,'UTIL CS2 at entry',(R10),L$CS2\nSCANREGS LM    R5,R7,=A(TAB,12,TABEND-1)    BXLE regs\n*\nSCAN     DS    0H\n         CLC   CS2UTILN,0(R5)               supported UTILITY?\n         BE    FOUND\n         BXLE  R5,R6,SCAN\n         UDIAG 0,'RECVUTIL unsupported utility (CS2)',CS2,L$CS2\n         LA    R2,RC#12\n         B     EXITRC\n*\nFOUND    DS    0H\n         MVI   CS2DONE,CS2$DONE             show CS2 handled\n         ICM   R15,15,8(R5)\n         BNZR  R15                          call support routine\n         MVI   SAREASON,ERR#1               support routine unresolved\nDIE      UABEND SAREASON                    ABEND w/ reason code\n*----------------------------------------------------------------------\n*  See if another utility deals with same file #, if so, call it\n*----------------------------------------------------------------------\nUTNEXT   DS    0H                           see if more CS2s qualify\n         L     R0,CS2#FILE                  file # we just handled\n         LA    R14,L$CS2                    length of CS2\n         SR    R10,R14                      back up to previous CS2\n         C     R0,CS2#FILE\n         BNE   EXITRC                       different file #, done\n         UDIAG 2,'UTIL selected CS2',(R10),L$CS2\n         B     SCANREGS\n         EJECT ,\n*----------------------------------------------------------------------\n*  INMCOPY - copy segment data to SYSUT1 or display MESSAGE on LOG\n*  INMCOPY is only utility that reads XMIT, so other utility support\n*  routines don't need to check if SACTL has already been set\n*----------------------------------------------------------------------\nINMCOPY  DS    0H\n         LA    R0,IEBUT1                    target DDNAME\n         LR    R1,R10                       CS2\n         L     R15,=V(RECVMSG)              assume embedded message\n         CLI   CS2TERM,C'Y'                 embedded message?\n         BE    *+8\n         L     R15,=V(RECVRCPY)             no embedded message\n         BALR  R14,R15                      call RECVMSG or RECVRCPY\n         ST    R15,CS2UTRC                  save utility return code\n         MVI   SAREASON,ERR#3               two INMCOPYs for same file\n         SLR   R0,R0\n         C     R0,SACTL                     previously emitted ctl seg?\n         BNE   DIE\n         ST    R1,SACTL                     0 or @ returned ctl seg\n         UPSR  2,'RECVUTIL INMCOPY rc',*CS2UTRC\n         L     R0,CS2UTRC\n         LTR   R0,R0\n         BZ    UTNEXT                       see if another utility\n*\n         MVI   SAREASON,ERR#2               returned ctl seg SEGL=0\n         L     R15,SACTL\n         SLR   R14,R14\n         ICM   R14,1,SEGL-SEG(R15)\n         BZ    DIE\n         UDIAG 2,'UTIL INMCOPY emit ctl seg',(R15),(R14)\n         B     UTNEXT\n         EJECT ,\n*----------------------------------------------------------------------\n*  IEBCOPY - restore unloaded PDS from SYSUT1\n*----------------------------------------------------------------------\nIEBCOPY  DS    0H                           set up IEBCOPY parmlist\n         LA    R0,SAPRM1\n         ST    R0,SAPARM                    IEBCOPY parmlist\n*\n         LA    R0,IEBOPTS     SAPRM4\n         ST    R0,SAPRM1                    IEBCOPY options (OS PARM)\n*\n         LA    R0,IEBDDLST    SAPRM6\n         ST    R0,SAPRM2                    IEBCOPY DDNAME list\n*\n         LA    R0,IEBPAGEL    SAPRM8\n         ST    R0,SAPRM3                    IEBCOPY page header\n*\n         OI    SAPRM2,128                   VL flag (ignore page hdr)\n         B     LOAD\n*\n*  Extraneous setup, for ease of zapping\n*\n         LA    R0,0           SAPRM8\n         ST    R0,SAPRM3                    IEBCOPY page header\n         OI    SAPRM3,128                   VL flag\n*\n         MVC   SAPRM4,IEBOPTS               set OS PARM length\n         MVC   SAPRM5,IEBPARM               copy OS PARM\n*\n         MVC   SAPRM6,IEBDDLST              set DDNAME list length\n         MVC   SAPRM7,IEBDDN                copy DDNAME list\n*\n         MVC   SAPRM8,IEBPAGEL              set page header length\n         MVC   SAPRM9,IEBPAGE               copy page header\n         B     LOAD                         common IBM utilty code\n*\n         DS    0H\nIEBOPTS  DC    AL2(0)                       length of OS parm string\nIEBPARM  DC    C'                   '       IEBCOPY options (zappable)\n*        DC    C'SIZE=nnnnK,WORK=nnK'       SIZE = buffer size\n*                                           WORK = I/O buffer size\n*\n         DS    0H\nIEBDDLST DC    AL2(IEBDDX-IEBDDN)           L' DDNAME list\nIEBDDN   DS    0H\n         DC    XL8'00'\n         DC    XL8'00'\n         DC    XL8'00'\n         DC    XL8'00'\nIEBSYSIN DC    CL8'SYSIN'                   SYSIN    DD DUMMY\nIEBSYSPT DC    CL8'SYSPRINT'                SYSPRINT DD SYSOUT\n         DC    XL8'00'\nIEBUT1   DC    CL8'SYSUT1'                  SYSUT1   input unloaded ds\nIEBUT2   DC    CL8'SYSUT2'                  SYSUT2   output PDS\nIEBUT3   DC    CL8'SYSUT3'                  SYSUT3   spill\nIEBUT4   DC    CL8'SYSUT4'                  SYSUT4   spill\nIEBDDX   DS    0H\n*\n         DS    0H\nIEBPAGEL DC    AL2(L'IEBPAGE)               PAGE HEADER length\nIEBPAGE  DC    Z'1'                         PAGE HEADER\n         EJECT ,\n*----------------------------------------------------------------------\n*  LOAD UTILITY\n*----------------------------------------------------------------------\nLOAD     DS    0H\n         MVI   SAREASON,ERR#4                    assume LOAD error\n         LOAD  EPLOC=CS2UTILN,ERRET=LOADFAIL     load UTILITY\n         LTR   R15,R15\n         BZ    CALL\n         B     DIE                          LOAD parm error?!?\n*\nLOADFAIL DS    0H\n         ST    R1,SALDABCD                  save averted ABEND code\n         ST    R15,SALDRSN                  save averted ABEND reason\n         UDIAG 0,'RECVUTIL utility LOAD failed',SALDBAD,L'SALDBAD\n         UDIAG 0,'RECVUTIL CS2',(R10),L$CS2\n         LA    R2,RC#16                     load failed rc\n         B     EXITRC\n*----------------------------------------------------------------------\n*  Call UTILITY\n*----------------------------------------------------------------------\nCALL     DS    0H\n         LR    R15,R0                       get entry address\n         LR    R9,R15                       save EP\n         L     R1,SAPARM                    UTILITY parmlist ptr\n         BALR  R14,R15                      call UTILITY\n         ST    R15,CS2UTRC                  save return code\n         UPSR  2,'RECVUTIL UTILITY rc %',(R15)\n*----------------------------------------------------------------------\n*  DELETE UTILITY\n*----------------------------------------------------------------------\nDELETE   DS    0H\n         DELETE EPLOC=CS2UTILN     delete UTILITY program\n         UPSR  2,'RECVUTIL UTILITY DELETE rc %',(R15)\n*\n         LA    R0,4                standard IBM utility warning rc\n         C     R0,CS2UTRC          worse rc?\n         BNL   UTNEXT              no, see if more utilities to call\n         LA    R2,RC#8             bad utility return code\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\nEXITRC   DS    0H\n         L     R3,SACTL                     0 or @ control seg to emit\n         SLR   R0,R0\n         CR    R0,R3                        control seg emitted?\n         BE    EXIT2                        no, br\n         CR    R0,R2                        everything OK so far?\n         BNE   EXIT2                        no, br\n         LA    R2,RC#4                      yes, set 'emit ctl seg' rc\nEXIT2    UPSR  1,'RECVUTIL exited rc',(R2)\n         LR    R1,R3\n         UPEND RC=(R2),R1=PASS\n         EJECT ,\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\nTAB      DS    0F\n         DC    CL8'INMCOPY',A(INMCOPY)\n         DC    CL8'IEBCOPY',A(IEBCOPY)\nTABEND   DS    0X\n         LTORG ,\n*        EJECT ,\n*----------------------------------------------------------------------\n*  Savearea/workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSASA     DS    18F                     savearea for anyone we call\nSARC     DS    F                       our return code\nSAENTRY  DS    2F                      R0:R1 at entry\nSACTL    DS    A                       addr of ctl seg from RECVRCPY\nSAREASON DS    X                       UABEND reason code\n*\nSALDABCD DS    F                       LOAD ABEND code\nSALDRSN  DS    F                       LOAD ABEND reason\nSALDBAD  EQU   SALDABCD,8\n*\n*  General parm layout for calling IBM utilities\n*\nSAPARM   DS    A                       UTILITY parmlist ptr\n*\nSAPRM1   DS    A                       OS parm\nSAPRM2   DS    A                       DDNAME list\nSAPRM3   DS    A                       page header\n*\nSAPRM4   DS    H                       L' OS PARM\nSAPRM5   DS    CL100                   UTILITY OS PARM\n*\nSAPRM6   DS    H                       L' ddname list\nSAPRM7   DS    XL100                   UTILITY ddname list\n*\nSAPRM8   DS    H                       L' page number\nSAPRM9   DS    CL4                     page number\n*\n         DS    0D\nL$SA     EQU   *-SAVEAREA\n*\n         EJECT ,\n         DRCS2 ,\n*        EJECT ,\n         PUSH  PRINT\n         PRINT NOGEN\n         DXSEG ,\n         WARECV ,\n*        EJECT ,\n         POP   PRINT\nRECVUTIL UFINI DXDRUTL,L$SA            pseudo-register\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RECVVTAB": {"ttr": 9226, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00\\x11\\x00\\x11\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "XV0006"}, "text": "RECVVTAB TITLE 'RECV370 VCON table'\n*\n* Copyright 2001-2008 James M. Morrison\n*\n         U#SET FUNC=RECV\n*\n         UVTAB MF=HDR\n         UVTAB RECV370\n         UVTAB RECVBLK\n         UVTAB RECVCTL\n         UVTAB RECVGCTL\n         UVTAB RECVGSEG\n         UVTAB RECVMSG\n         UVTAB RECVRCPY\n         UVTAB RECVUTIL\n         UVTAB MF=TLR\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RECV370": {"ttr": 9228, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00\\x83\\x00\\x83\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 131, "newlines": 131, "modlines": 0, "user": "XV0006"}, "text": "         GBLC  &G#VRSN\nRECV370  TITLE 'TSO/E RECEIVE clone for MVS 3.8J'\n*\n* Copyright 2001-2008 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  Copyright 2002-2008 James M. Morrison\n*----------------------------------------------------------------------\n*  Things to do:\n*----------------------------------------------------------------------\n         U#SET FUNC=RECV\n*----------------------------------------------------------------------\n* Function: Given an input XMIT file, recreate original file (PDS\n*           or sequential file).\n*\n* DDNAMEs:\n*\n*        ddname     opened description                opens    closes\n*        --------   ------ -------------------------- -------- --------\n*\n*        RECVLOG    OUTPUT RECV370 messages           U370LOG  U370LOG\n*\n*        RECVDBUG   INPUT  debug control stmts        U370DBUG U370DBUG\n*                          (optional)\n*\n*        XMITIN     INPUT  TRANSMIT file              RECVGSEG RECVGSEG\n*\n*        SYSPRINT   OUTPUT IEBCOPY messages           IEBCOPY  IEBCOPY\n*\n*        SYSUT1     OUTPUT unwrapped XMIT             RECVPDS  RECVPDS\n*                   INPUT  IEBCOPY unloaded file      IEBCOPY  IEBCOPY\n*                   OUTPUT recreated sequential       RECVRCPY RECVRCPY\n*\n*        SYSUT2     OUTPUT recreated PDS              IEBCOPY  IEBCOPY\n*\n*        SYSIN      DUMMY  IEBCOPY control            IEBCOPY  IEBCOPY\n*                          statements (optional)\n*\n* Processing overview:\n*\n*        RECV370           ID=MAIN - calls RECVCTL\n*          RECVCTL         handle XMIT control segments, driver\n*            RECVGCTL      return XMIT control record\n*            RECVUTIL      calls utilities: INMCOPY, IEBCOPY\n*              RECVRCPY    internal implementation of INMCOPY\n*              IEBCOPY     IBM unload/reload utility (DSORG=PS)\n*\n*        RECVBLK           return IEBCOPY unloaded dataset block\n*        RECVGSEG          return XMIT segment\n*        RECVVTAB          VCON table\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*, APF authorized\n*\n*         R0  =\n*         R1  =  Address of OS parmlist\n*         R13 =  savearea ptr\n*         R14 =  return addr to caller\n*         R15 =  address of RECV370\n*\n* Exit:   R15 = return code\n*         R15 = 00 success\n*\n* Abends: U0001 DCB didn't open\n*\n* Notes:\n*----------------------------------------------------------------------\n* R2\n* R3\n* R4\n* R5\n* R6\n* R7\n* R8\n* R9\n* R10\n* R11    RCVWA ... ALWAYS (contains our savearea)\n* R12    BASE REG ... ALL CSECTS (dummy for us)\n* R13    savearea\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\nRECV370  UPROC ID=MAIN,L=L$SA,CPD=(Y,0,ESTAE)\n*\n* Init RECVWA\n*\n         MVC   RCVRGSWE,=C'GETWORK '        set XPSWA eyecatcher\n*----------------------------------------------------------------------\n*  Display Copyright info\n*----------------------------------------------------------------------\n    ULOG 'RECV370 &G#VRSN Copyright 2002-2008 James M. Morrison'\n    ULOG 'RECV370 may be distributed under the terms of the Q Public Li+\n               cense version 1.0'\n    ULOG 'RECV370 Initial Developer James M. Morrison'\n*----------------------------------------------------------------------\n*  Handle RECVDBUG ddname\n*----------------------------------------------------------------------\n         UCALL U370DBUG                     handle RECVDBUG ddname\n*----------------------------------------------------------------------\n*  Handle the XMIT file, recreate PDS/sequential dataset\n*----------------------------------------------------------------------\n         UESTAE RETRY\n         UCALL RECVCTL\n         LR    R3,R15                       save rc\n         ULOG  'RECV370 done'\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\nEXIT     DS    0H\n         UPEND RC=(R3)\n*----------------------------------------------------------------------\nRETRY    DS    0H\n         ULOG  'RECV370 ABENDed'\n         LA    R3,20                        ABEND rc\n         B     EXIT\n         LTORG ,\n*\n         EJECT ,\n         WARECV ,\n         EJECT ,\n         DXSEG ,\n         EJECT ,\nSAVEAREA DSECT ,\n         DS    18F\nSAREASON DS    X\nSAEND    DS    0D\nL$SA     EQU   *-SAVEAREA\n*\n         PRINT GEN\nRECV370  UFINI DXDTGD,L$RCVWA,ID=TGD\nRECV370  UFINI DXDRMAIN,L$SA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STCP#BUG": {"ttr": 9473, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n         STCP#BUG &PFX=TGDD\n.*\n.* Copyright 2002-2008 James M. Morrison\n.*\n         LCLC  &P\n&P       SETC  '&PFX'\n&P.OPR   DS    C        STCPOPR  TCP/IP operator interface\n&P.SS00  DS    C        STCPSS00 TCP/IP subsys initialization\n&P.SS99  DS    C        STCPSS99 TCP/IP subsys termination\n&P.SVC0  DS    C        STCPSVC0 TCP/IP SVCTABLE initialization\n&P.SVC9  DS    C        STCPSVC9 TCP/IP SVCTABLE termination\n&P.TSKM  DS    C        STCPTSKM TCP/IP Task Manager\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STCP#OPT": {"ttr": 9475, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00%\\x00%\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 37, "newlines": 37, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   STCP#OPT &SECT=LABEL,&OPTS=STCPOPTS,&PFX=OPT,&SSN=TCP,        +\n               &SLIM=30,&RLIM=30,&LPA=STCPLPA,&JPA=STCPJPA,&CUU=620,   +\n               &SVC=255,&SVCMOD=STCPSVC,&ID=\n.*\n.* Copyright 2002 James M. Morrison\n.*\n         LCLC  &P\n&P       SETC  '&PFX'\n.*\n         AIF   ('&ID' EQ 'NAME').NAME\n&LABEL   IM#SECT &SECT       CSECT, DSECT, or LABEL\n&P.MOD1  DC    CL8'&LPA'     name of module to be loaded to CSA\n&P.MOD2  DC    CL8'&JPA'     name of module to be loaded to JPA\n&P.MOD3  DC    CL8'&SVCMOD'  name of module to be loaded for SVC\n&P.CUU   DC    XL2'&CUU'     default 3088 cuu (1st addr of pair)\n         DC    XL2'00'       spare\n&P.SSN   DC    CL4'&SSN'     Subsystem name\n&P.SVCOP DC    X'0A'         TCP/IP SVC opcode\n&P.SVC#  DC    AL1(&SVC)     TCP/IP SVC number\n&P.SVC   EQU   &P.SVCOP,2    SVC instruction\n&P.LADB  DC    H'20'         0xxx of LA R15,xxx when OPTSVC overlaid\n&P.OPL1  EQU   *-&P.MOD1     SGD section length\n         AIF   ('&ID' EQ 'SGD').MEX\n*\n&P.SLIM  DC    A(&SLIM)      Max SEND queue length\n&P.RLIM  DC    A(&RLIM)      Max RECV queue length\n*\n.MEX     MEXIT ,\n.NAME    ANOP\n&LABEL   DC    CL8'&OPTS'    options module name               STCP#OPT\n         MEXIT ,\n.DOC     ANOP\n.*---------------------------------------------------------------------\n.*  STC#OPT - generate options module name, options module, or DSECT\n.*---------------------------------------------------------------------\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STCPINIT": {"ttr": 9477, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x005\\x005\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 53, "newlines": 53, "modlines": 0, "user": "XV0006"}, "text": "STCPINIT TITLE 'TCP/IP subsystem initialization - Part One'\n*\n* Copyright 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  To do:\n*----------------------------------------------------------------------\n         U#SET FUNC=STCP\n*----------------------------------------------------------------------\n* Function:    Initializes TCP/IP subsystem\n*\n* Environment: MVS builds our SSCVT due to our being listed\n*              in the IEFJSSNT module\n*\n*        Our IEFJSSNT entry specifies this CSECT for our\n*        subsystem initialization routine, which means that by\n*        time we're called all we have is an SSCVT (no SSVT)\n*\n*        All we do is turn on SSCTUPSS - use primary subsystem's\n*        services for this subsystem (SYSIN/SYSOUT)\n*\n*        Part Two of subsystem initialization is performed by\n*        by the STCPSS00 CSECT; subsystem termination is handled\n*        by the STCPSS99 CSECT\n*\n*        It is not necessary for us to know the subsystem's name,\n*        since MVS passes us the subsystem's SSCVT address as a parm\n*\n* Entry:  R1 @ parmlist containing addr of SSCVT\n*\n* Exit:   R15 =  0 - OK\n*\n* Notes:  See STCPSS00 for further subsystem initialization\n*         The only reason this CSECT exists is so our STC JCL\n*         can have SYSOUT datasets (SYSUDUMP, STCPLOG, OPRLOG, etc.)\n*\n*----------------------------------------------------------------------\nSTCPINIT UPROC ID=SINT,INIT=NONE\n*----------------------------------------------------------------------\n         STM   R14,R12,12(R13)         save MVS regs\n         L     R9,0(,R1)               @ SSCVT\n         USING SSCT,R9\n         OI    SSCTFLG1,SSCTUPSS       JES2 is our bessstt friend\n         WTO   'TCP/IP subsystem enabled'\n         LM    R14,R12,12(R13)         restore MVS regs\n         SLR   R15,R15\n         BR    R14                     return to MVS\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\n         LTORG ,\n         IEFJSCVT ,                    SSCVT\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STCPLPA": {"ttr": 9479, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00O\\x00O\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 79, "newlines": 79, "modlines": 0, "user": "XV0006"}, "text": "STCPLPA  TITLE 'TCP/IP LPALIB-resident support'\n*\n* Copyright 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  To Do:\n*  1) See STCPSVC for TCPSSTC.SSTCFLG1.SSTC1SVC flag notes\n*  2) Verify EVERYTHING in the SSOB before believing in it;\n*     an unprivileged user may be up to no good\n*     Exception: if TCPSOCK (allocated in storage unmodifiable by\n*     unauthorized user) indicates service running APF authorized\n*     bypass some (but probably not all) verification\n*----------------------------------------------------------------------\n         WASTCP ,\n*----------------------------------------------------------------------\n*  Address list used by STCPSS00 to build subsys SSVT\n*\n*  Since the technique used by STCPSS00 is customized for MVS38j,\n*  (as indeed is much of the MVS38j TCP/IP project),\n*  we make use of the fact that MVS38j doesn't support more than 16MB\n*  of addressability, and use the high byte to describe which function\n*  code the A-con supports\n*\n*  It's a somewhat cheesy approach, but it's easy to write the\n*  code that supports it, and it saves us 256+4 bytes of function\n*  code matrix (not that's the only way to do it, but it gets\n*  messy otherwise - at least it does if you want to save bytes)\n*\n*\n*  The highest function code must be last in the address list, so\n*  STCPSS00 can use it to set SSVTFNUM\n*  The maximum function code is obviously 255 (x'FF')\n*----------------------------------------------------------------------\nSTCPLPA  CSECT ,\n         DC    AL1(1),AL3(QUERY)\n         DC    AL1(2),AL3(Q1)\n         DC    AL1(3),AL3(Q2)\n         DC    AL1(5),AL3(Q5)\n         DC    AL1(6),AL3(Q6)\n         DC    AL1(7),AL3(Q7)\n         DC    AL1(11),AL3(Q11)\n         DC    AL1(12),AL3(Q12)\n         DC    AL1(13),AL3(Q13)\n         DC    AL1(14),AL3(Q14)\n         DC    AL1(15),AL3(Q15)\n         DC    AL1(16),AL3(Q16)\n*\n*  Assembly error on FUNCERR if # functions exceeds # defined\n*  by STCP#SSF (defined in WASTCP)\n*\nFUNCWDS  EQU   STCP#SSF*4\nFUNCRTNS EQU   *-STCPLPA\nFUNCERR  EQU   FUNCWDS-FUNCRTNS\n*\n         DC    A(0)                    end of address list\n*----------------------------------------------------------------------\n         DS    0D                      function code doubleword aligned\nQUERY    DS    0H\n         USING SSOB,R1\n         LA    R0,4\n         ST    R0,SSOBRETN\n         SLR   R15,R15\n         BR    R14\nQ1       NOP   0\nQ2       NOP   0\nQ3       NOP   0\nQ5       NOP   0\nQ6       NOP   0\nQ7       NOP   0\nQ11      NOP   0\nQ12      NOP   0\nQ13      NOP   0\nQ14      NOP   0\nQ15      NOP   0\nQ16      NOP   0\n*\n         LTORG ,\n         IEFJSSOB ,                    SSOB\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STCPOPR": {"ttr": 9482, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x01\\x1f\\x01\\x1f\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 287, "newlines": 287, "modlines": 0, "user": "XV0006"}, "text": "STCPOPR  TITLE 'TCP/IP operator interface'\n*\n* Copyright 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n         U#SET FUNC=STCP\n*----------------------------------------------------------------------\n* Function:    TCP/IP operator interface\n*\n*   Main task  - Called by main to initialize ourselves by\n*                passing a WUD to TSKM\n*\n*                Entry:  R0 ignored\n*                        R1 ignored\n*\n*         If STPFLG1.STP1INIT is on, we're coming up\n*         If STPFLG1.STP1SHUT is on, we're shutting down\n*\n* -------------------------------------------------------------------\n*\n*   Sub task   - Enable & disable operator interface\n*              - START command handled here (parse operands)\n*              - Accept MVS operator command(s)\n*              - STOP command causes us to terminate our subtask\n*\n*                Entry:  R0 @ WUD\n*                        R1 = WUDWORD\n*\n*         If neither of these bits is on, we have a CIB to process\n*\n* Exit:   R15 =  0 - OK\n*\n* Diagnostics:\n*               1 - main    - INIT/SHUT\n*               2 -\n*               3 -\n*               4 - subtask - CIB @ entry\n*               5 - subtask - WUD @ exit\n*               6 - subtask - FREECIB - CIB before QEDIT\n*               7 - subtask - SUBWAIT - COMLIST + ECB\n*               8 -\n*               9 -\n*\n* Notes:\n*\n*----------------------------------------------------------------------\n* Reg  DSECT    Usage\n*----------------------------------------------------------------------\n* R2            CIB length\n* R3            CIBDATA length\n* R4            scratch\n* R5\n* R6   WUD      RWUD\n* R7   CIB      IEZCIB - MVS operator command\n* R8   COMLIST  IEZCOM - CIB anchor\n* R9            reserved for TPU\n* R10           internal linkage\n* R11           STCPWA\n* R12           base reg\n* R13  SAVEAREA SA\n*----------------------------------------------------------------------\nRWUD     EQU   6        0 or @ WUD\nRCIB     EQU   7        0 or @ CIB\nRCOM     EQU   8        0 or @ COMLIST\nX8       EQU   3        shift factor to multiply by 8\nENDOLIST EQU   X'80'    hi bit - end of list\nSTCPOPR  UPROC ID=SOPR,L=L$SA\n*----------------------------------------------------------------------\nERR#1    EQU   1        invalid subtask entry parms\nERR#2    EQU   2\nERR#3    EQU   3        COMCIBPT null\nERR#4    EQU   4        COMECBPT null\nERR#5    EQU   5        CIB makes no sense\nERR#6    EQU   6        CIB START operand parse error\nERR#7    EQU   7        STCPTSKM error\n*\n         STM   R0,R1,SAENTRY           save entry parms\n         USING PSA,0\n         SLR   RWUD,RWUD\n*\n         TM    STPFLG1,STP1INIT        initialize?\n         BO    INIT\n         TM    STPFLG1,STP1SHUT        shutdown?\n         BO    SHUT\n         B     SUBTASK\n*\nEXIT     DS    0H\n         LTR   RWUD,RWUD\n         BZ    EX99\n         UDIAG 5,'OPR exit WUD',(RWUD),L$WUD\nEX99     UPEND RC=*SARC\n         EJECT ,\n*----------------------------------------------------------------------\n*  Initialize\n*----------------------------------------------------------------------\nINIT     DS    0H\n         UDIAG 1,'OPR init'\n*\n*  Create WUD - TSKM will ATTACH us to accept CIBs from MVS\n*\n         MVC   SAWID,=C'OPR'                identify creator (briefly)\n         MVC   SAWLOGD,=CL8'OPRLOG'         opr log ddname\n         MVC   SAWNAME,ID                   my CSECT name\n         ST    RBASE,SAW@CODE               @ my CSECT\n         ICM   R0,8,=AL1(TSKM$ADD)          ADD WUD to WIB\n         LA    R1,SAW                       @ WUD to add\n         MVI   SAREASON,ERR#7               STCPTSKM error\n         UCALL STCPTSKM,ERR=DIE             create OPR subtask\n         LR    RWUD,R1                      @ subtask WUD\n         L     R2,=A(POST$WRK)              work-waiting POST code\n         POST  WUDRUN-WUD(RWUD),(R2)        kick subtask for START CIB\n         B     EXIT                         next OPR call: subtask\n*----------------------------------------------------------------------\n*  Shutdown operator interface\n*----------------------------------------------------------------------\nSHUT     DS    0H\n         UDIAG 1,'OPR shut'\n         UWTO  0,'TCP/IP shutdown complete'\n         B     EXIT\n         EJECT ,\n*----------------------------------------------------------------------\n*  Process CIB (MVS operator command)\n*----------------------------------------------------------------------\nSUBTASK  DS    0H\n         MVI   SAREASON,ERR#1          invalid subtask entry parms\n         ICM   RWUD,15,SAR0            @ WUD\n         BZ    DIE\n         USING WUD,RWUD\n         BAL   R10,FINDCOM             RCOM @ COMLIST\n         USING COMLIST,RCOM\n         UPSR  2,'OPR subtask FINDCOM RCOM',(RCOM)\n         MVI   SAREASON,ERR#3          COMCIPT null @ SUBTASK entry\n         ICM   RCIB,15,COMCIBPT        @ CIB or 0\n         BZ    DIE\n         USING CIB,RCIB\n*\nNEWCIB   DS    0H\n         SLR   R2,R2\n         IC    R2,CIBLEN               CIB length in doublewords\n         SLL   R2,X8\n         UDIAG 4,'OPR newcib CIB',(RCIB),(R2)\n         LR    R3,R2\n         LA    R0,CIBDATA-CIB          overhead length\n         SR    R3,R0                   = # bytes of CIBDATA\n*\n*  Route command to appropriate routine\n*\n         TM    CIBVERB,CIBMODFY        test multiple bits\n         BO    OCF\n         BM    OCP\nOCBAD    MVI   SAREASON,ERR#5          MOUNT?!?\n         B     DIE\n         EJECT ,\n*----------------------------------------------------------------------\n*  Subtask - MVS operator MODIFY command\n*----------------------------------------------------------------------\nOCF      CLI   CIBVERB,CIBMODFY        MODIFY?\n         BNE   OCBAD\n         CLC   =C'DRAIN',CIBDATA\n         BNE   OCFBAD\n         UCALL STCPSS99                drain subsys\n         B     SUBWAIT\nOCFBAD   UWTO  0,'TCP/IP modify command invalid'\n         B     SUBWAIT                 wait for another CIB\n*----------------------------------------------------------------------\n*  Subtask - MVS operator STOP command\n*----------------------------------------------------------------------\nOCP      CLI   CIBVERB,CIBSTOP         STOP?\n         BNE   OCS\n         OI    STPFLG1,STP1OPRX        shutdown request\n         UWTO  1,'TCP/IP opr cmds disabled'\n         QEDIT ORIGIN=COMCIBPT,CIBCTR=0\n         LR    R4,R15\n         UPSR  1,'OPR cibctr=0 rc',(R4)\n         UWTO  0,'TCP/IP shutdown initiated'\n         L     R4,=A(POST$SHU)              tell myself to shutdown\n         POST  WUDRUN-WUD(RWUD),(R4)        TSKM will not call again\n         B     SUBWAIT                 opr task completion\n*----------------------------------------------------------------------\n*  Subtask - MVS operator START command\n*----------------------------------------------------------------------\nOCS      CLI   CIBVERB,CIBSTART        START?\n         BNE   OCBAD\n         QEDIT ORIGIN=COMCIBPT,CIBCTR=1\n         UWTO  1,'TCP/IP opr cmds enabled'\n         LTR   R3,R3                   START operands?\n         BZ    OCS3088\n         MVI   SAREASON,ERR#6          START operand error\n         CLM   R3,3,=AL2(3)            one cuu?\n         BNE   DIE\n         LA    R1,CIBDATA\n         LR    R0,R3\n         ICM   R0,8,=AL1(CHAR$HEX)     hex chars allowed\n         UCALL U370CHAR,ERR=DIE\n         L     R15,STP@SGD\n         N     R0,=X'00000FFF'         make valid S/370 cuu\n         STH   R0,SGDCUU-SGD(,R15)     save 3088 base cuu\nOCS3088  DS    0H\n*        UCALL STCP3088                start I/O subtask(s)\n         B     SUBWAIT\n*----------------------------------------------------------------------\n*  SUBWAIT - Subtask - Return to TSKM to WAIT for next CIB\n*----------------------------------------------------------------------\nSUBWAIT  DS    0H     it's fairly safe to use 20, CIB is in a CSCB\n         UDIAG 7,'OPR subwait COMLIST+ECB',(RCOM),20\n         BAL   R10,FREECIB             release CIB (if we have one)\n*\n*  Add COMLIST's ECB to the ECBLIST that TSKM uses to WAIT for work\n*  so we get POSTed when a new CIB arrives\n*\nSUBEXIT  DS    0H\n         MVI   SAREASON,ERR#4\n         ICM   R0,15,COMECBPT          @ COMLIST's ECB\n         BZ    DIE\n         ST    R0,WUD@2ECB             add COMLIST ECB to TSKM ECBLIST\n         NI    WUD@1ECB,255-ENDOLIST   turn off hi bit\n         OI    WUD@2ECB,ENDOLIST       turn on hi bit\n         B     EXIT\n*----------------------------------------------------------------------\n*  FREECIB - Free one CIB control block or ABEND\n*----------------------------------------------------------------------\nFREECIB  DS    0H\n         LTR   RCIB,RCIB\n         BZR   R10\n         UDIAG 6,'OPR freecib CIB',(RCIB),(R2)\n         QEDIT ORIGIN=COMCIBPT,BLOCK=(RCIB)      free CIB control block\n         LTR   R4,R15\n         BZR   R10\n         UPSR  1,'OPR freecib RC',(R4)\n         BR    R10                               return\n*----------------------------------------------------------------------\n*  FINDCOM - Locate COMLIST - Returns RCOM @ COMLIST\n*----------------------------------------------------------------------\nFINDCOM  DS    0H\n         ICM   RCOM,15,WUD@COM\n         BNZR  R10\n         MVC   SAEXTR(L$EXTR),MDLEXTR\n         EXTRACT WUD@COM,'S',FIELDS=(COMM),MF=(E,SAEXTR)\n         L     RCOM,WUD@COM\n         BR    R10\n*\nDIE      UABEND SAREASON\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\nMDLEXTR  EXTRACT *-*,*-*,FIELDS=(COMM),MF=L\nL$EXTR   EQU   *-MDLEXTR\n         LTORG ,\n*\n*----------------------------------------------------------------------\n*  Savearea & workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSASA     DS    18F\nSARC     DS    F\nSAENTRY  DS    2F                      R0:R1 from entry\nSAR0     EQU   SAENTRY+00,4\nSAR1     EQU   SAENTRY+04,4\nSAEXTR   EXTRACT *-*,*-*,FIELDS=(COMM),MF=L\nSAREASON DS    X                       UABEND reason code\nSADEC    DS    PL2                     3088 cuu\nSAW      DSWUD PFX=SAW,SECT=LABEL\n*\n         DS    0D                      align\nL$SA     EQU   *-SAVEAREA              length of savearea\n*\n         DSWUD ,\nWUDFLG2  EQU   WUDSCR,1\nOPR2STRT EQU   128                     START command processed\nOPR2STOP EQU   64                      STOP  command processed\nWUD@COM  EQU   WUDUSR1,4               @ COMLIST\nWUD@CIB  EQU   WUDUSR2,4               @ last-processed CIB\n         DSSSGD ,\n         WASTCP ,\n*\n         PRINT NOGEN\n         IHAPSA ,\nIEZCOM   DSECT ,\n         IEZCOM ,                      COMLIST\nL$COM    EQU   *-IEZCOM\n*\nCIB      DSECT ,\n         IEZCIB ,                      MVS opr Command Input Buffer\n*\n         PRINT GEN\nSTCPOPR  UFINI DXDSOPR,L$SA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STCPOPT": {"ttr": 9488, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x06\\x00\\x06\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 6, "newlines": 6, "modlines": 0, "user": "XV0006"}, "text": "STCPOPT  TITLE 'TCP/IP options'\n*\n* Copyright 2002 James M. Morrison\n*\nSTCPOPT  STCP#OPT SECT=CSECT\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STCPSS00": {"ttr": 9490, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x02D\\x02D\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 580, "newlines": 580, "modlines": 0, "user": "XV0006"}, "text": "STCPSS00 TITLE 'TCP/IP subsystem initialization'\n*\n* Copyright 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  To do:\n*  1) We should check to see if SGD, SQH, SSVT already allocated\n*     before we allocate them (so they can be freed once we've\n*     swapped new for old areas); enables dynamic changes to areas\n*  2) Need to save @, length of allocated storage (I think some of\n*     this has already been done); SGD is not such a bad place to\n*     stuff these values, as they can possibly have longer duration\n*     than the TCP/IP addr space\n*  3) The code that deals with function code in LPA is incomplete\n*     At the moment, there is no code in LPA, so it doesn't matter much\n*  4) Review subpool choices\n*  5) Memory leaks when TCP/IP restarted .... no big deal right now\n*     But, that will change once TCP/IP starts becoming useful\n*----------------------------------------------------------------------\n         U#SET FUNC=STCP\n*----------------------------------------------------------------------\n* Function:    Initializes TCP/IP subsystem\n*\n*              Also contains FINDSSCT entry point that scans\n*              SSCVT chain for TCP/IP subsystem\n*\n* Environment: MVS builds our SSCVT due to our subsystem being listed\n*              in the IEFJSSNT module\n*\n*              The STCPINIT routine is called by MVS when the\n*              TCP/IP subsystem's SSCVT is built\n*\n*              STCPINIT specifies that the primary JES will\n*              provide support, so our STC proc can use SYSIN\n*              and SYSOUT datasets\n*\n*              STCPINIT does not build any control blocks (such\n*              as our SSVT, SGD, and SQH), nor does it load\n*              any modules; that's our job\n*\n*\n* Entry:  no parms, supervisor state, key 8\n*         Options module name is assembled in CSECT at bottom\n*\n* Exit:   R15 =  0 - OK; supervisor state, key 8\n*\n* Notes:\n*\n*\n* IBM Documentation:\n*\n* Order Number Title\n* ------------ -----------------------------------------\n*\n* SR20-4675-01 A Guide to Using Multiple Virtual Storage\n*              Interface Facilities (Student Text)\n*              Second Edition, September 1981\n*\n*      Chapter 6, Subsystem Interface\n*\n* GC28-0627-02 OS/VS2 MVS System Programming Library: Job Management\n*              VS2 Release 3.8\n*              Third  Edition, October   1978\n*\n*      Chapter 9, Updating the Subsystem Names Table - IEFJSSNT\n*\n*\n* Data Areas:\n*\n* Anchor   Area  Creator  Macro\n* -------- ----- ------   --------\n*\n* CVTPTR   CVT   SYSGEN   CVT       Communications Vector Table\n* CVTJESCT JESCT SYSGEN   IEFJESCT  JES Control Table\n* JESSSCT  SSCVT IEFJSINT IEFJSCVT  Subsys Communication Vector Table\n* SSCTSCTA SSCVT    \"     IEFJSCVT  next SSCVT\n* SSCTSSVT SSVT  SUBSYS   IEFJSSVT  Subsystem Vector Table\n*\n* Areas created by SYSGEN are nucleus-resident, Key 0\n* SSCVT - Subpool 241 (CSA), Key 0\n*\n*\n* Source code:\n*\n* SYM11 IEFJSSNT - SYS1.LINKLIB(IEFJSSNT) Subsystem Names Table\n*                  Subsystems not defined at Sysgen time\n*\n* SYM11 IEFJSINT - Subsystem initialization interface\n*                  Builds all SSCVTs, builds Master Scheduler SSVT\n*\n* SYM11 IEEMB860 - Initializes SSVTs named in IEFJSSNT by calling\n*                  the subsystem initialization routine\n*                  See SUBSINIT, LINKINIT routines in IEEMB860\n*\n*----------------------------------------------------------------------\n*\n         WASTCP ,                      TCP/IP common\n*\nERR#1    EQU   1        unable to locate subsystem SSCVT\nERR#2    EQU   2        too many subsys function routines\n*\n*  Subpools allocated by STCPSS00:\n*\n*  Subpool 241: CSA, system-oriented, pageable, user protect key (0),\n*               not fetch protected\n*\nPOOL1    EQU   241      CSA - SGD, SQH, SSVT\nPOOL2    EQU   241      CSA - subsys functions\nPOOL3    EQU   241      CSA - SVC\n*\n*----------------------------------------------------------------------\nSTCPSS00 UPROC ID=SS00,L=L$SA\n         USING PSA,0\n*----------------------------------------------------------------------\n*  Load options module\n*----------------------------------------------------------------------\nOPTIONS  DS    0H\n         L     R1,=A(STCPOPTN)         @ name of options module\n         ST    R1,SAEPLOC1\n         BAL   R10,LOADMOD             load options or ABEND\n         STM   R0,R1,SALOAD1\n         LTR   R8,R0                   @ options module\n         BNZ   *+8                     find TCP/IP subsys SSCVT\n         L     R8,XTLMSBAA-XTLST(,R1)  @ options module in LPA\n         USING OPT,R8\n*----------------------------------------------------------------------\n*  Find our SSCVT\n*----------------------------------------------------------------------\n         MVC   STPSSN,OPTSSN           save subsys name\n         LA    R15,FINDSSCT            SSCVT scan routine\n         BALR  R14,R15                 find our SSCVT\n         MVI   SAREASON,ERR#1          can't find SSCVT\n         LTR   R9,R1                   found SSCVT?\n         BZ    DIE\n         ST    R9,SA@SSCVT             save our SSCVT ptr\n         UPSR  2,'SS00 SSCVT',(R9)\n*----------------------------------------------------------------------\n*  Allocate SGD, SQH, SSVT\n*----------------------------------------------------------------------\nALCSGD   DS    0H\n         LA    R0,STCP#SSF*4           highest function code * L' A-con\n         A     R0,=A(L$SGD+L$SQH+SSVTFSIZ)  1st CSA alloc length\n         ST    R0,SALCSA1\n         SPKA  0\n         GETMAIN RU,LV=(0),SP=POOL1    alloc SGD, SQH, SSVT\n         LR    R7,R1\n         USING SGD,R7\n         LA    R6,L$SGD+SGD            SQH  immediately follows SGD\n         LA    R5,L$SQH+SQH            SSVT immediately follows SQH\n         STM   R5,R7,SA@SGD3           @ SSVT, SQH, SGD\n         UPSR  2,'SS00 SGD',(R7)\n         UPSR  2,'SS00 SQH',(R6)\n         UPSR  2,'SS00 SSVT',(R5)\n*----------------------------------------------------------------------\n*  Initialize SGD, SQH\n*----------------------------------------------------------------------\n         XC    SGD(L$SGD),SGD          clear SGD\n         MVC   SGDID,=C'SGD'           block id\n         MVC   SGDOPTS(SGDOPL1),OPT    copy options to SGD\n         MVC   STPCUU,SGDCUU           set default 3088 cuu for STCPOPR\n         L     R0,SALCSA1\n         ST    R0,SGDLCSA1             tell STCPSS99 about GETMAIN\n         MVI   SGDLCSA1,POOL1               and subpool #\n*\n         XC    SQH(L$SQH),SQH          clear SQH\n         MVC   SQHID,=C'SQH'           block id\n         MVC   SQHSLIM,OPTSLIM         max SEND queued elements\n         MVC   SQHRLIM,OPTRLIM         max RECV queued elements\n         ST    R6,SGD@SQH              @ SQH\n         SPKA  8*16\n*\n         L     R1,SAEPLOC1\n         BAL   R10,DELMOD              release options module\n         DROP  R8                      R7 @ SGD, SQH, SSVT\n         EJECT ,\n*----------------------------------------------------------------------\n*  Load subsys function code to CSA, or locate in LPALIB\n*\n*  MVS38j doesn't have load-to-global support, so we have to fake it\n*\n*  The contents of LPALIB module are split between the SSVT and\n*  the second chunk of CSA\n*  There's an address list at the front of the module, which is\n*  used to build our SSVT; the addr list is terminated by A(0)\n*  The remainder of the module is subsystem function code\n*----------------------------------------------------------------------\n*\n* R4           @ gotten CSA storage to contain subsys function code\n* R5           length of CSA area for subsys function code\n* R7   SGD, SQH, SSVT\n* R8           @ subsys function code module (CSA or LPA)\n* R9           length of module copied for subsys function code\n*\nLOADFCN  DS    0H\n         LA    R1,SGDMOD1              @ ss function code module name\n         ST    R1,SAEPLOC2\n         SLR   R2,R2                   indicate no CDE\n         BAL   R10,LOADMOD             load subsys function code module\n         STM   R0,R1,SALOAD2\n         LTR   R8,R0                   @ module\n         BNZ   LFCOPY                  module not in LPA; copy it\n*\n*  Found module in LPA\n*\n         USING XTLST,R1                @ module's XTLST; R2 @ CDE\n         L     R8,XTLMSBAA             @ module in LPA\n         ST    R8,SA@PROTO\n         L     R0,0(,R8)               @ code\n         ST    R0,SA@SSFN\n         SLR   R5,R5\n         ICM   R5,7,XTLMSBLN           length of module in LPA\n         ST    R5,SALSSFN\n         SLR   R4,R4                   zero value = no GETMAIN\n         UDIAG 4,'SS00 load2 LPA',(R8),(R5)\n         B     LFCALC                  calc length of addr list\n         DROP  R1\n*----------------------------------------------------------------------\n*  Load subsys function code to CSA (fake load-to-global)\n*----------------------------------------------------------------------\nLFCOPY   DS    0H\n         LA    R8,0(,R8)               clear hi even tho it's 0 to\n         ST    R8,SA@PROTO             assure pointer arithmetic ok\n         LR    R5,R1                   module length in doublewords\n         SLL   R5,8+3                  remove APF code\n         SRL   R5,8                    module length in bytes\n         LR    R4,R1                   nonzero value = GETMAIN\n         UDIAG 4,'SS00 load2 private',(R8),(R5)\n*\n*  Delimit the address list from the code in the module\n*  First A-con in the address list * must * point past all A-cons\n*\nLFCALC   DS    0H\n         L     R14,0(,R8)              @ start of code in private/LPA\n         LA    R14,0(,R14)             clear hi\n         ST    R14,SA@CODE2\n         SR    R14,R8                  length of A-con list\n         ST    R14,SALPROTO\n         SR    R5,R14                  minus length of A-con list\n         ST    R5,SALCODE2             length of load2 code\n         LTR   R4,R4\n         BZ    BUILDSVT\n*\n         SPKA  0\n         GETMAIN RU,LV=(R5),SP=POOL2   CSA for \"LPA\" module\n         LR    R4,R1\n         STM   R4,R5,SA@CSA2           @, length of sys func module\n         MVI   SALSSFN,POOL2           save subpool #\n         ST    R4,SGD@SSFN             tell STCPSS99 GETMAIN addr\n         ST    R5,SGDLSSFN             tell STCPSS99 GETMAIN len\n         MVI   SGDLSSFN,POOL2                                subpool #\n*\n         L     R8,SA@CODE2             @ code to copy; ignore addr list\n         LR    R9,R5                   source length\n         MVCL  R4,R8                   copy subsys functions to CSA\n*\n         LM    R2,R3,SA@CSA2\n         LA    R3,0(,R3)               remove subpool #\n         UDIAG 4,'SS00 load2 CSA',(R2),(R3)\n         EJECT ,\n*----------------------------------------------------------------------\n*  Build SSVT from address list at front of the module\n*\n*  The A-cons have a function code number in their high byte\n*  (this is MVS38j, 24 bits of addressability is it, not 31)\n*\n*  The number of functions should be right, as long as the address\n*  lists' function codes end with the highest valid function code\n*  in the last A-con\n*----------------------------------------------------------------------\nBUILDSVT DS    0H\n         LA    R7,SVT                  @ SSVT\n         USING SSVT,R7\n*\n*  When the subsys function code is already in LPA, R9=R10\n*  so the net relocation is zero\n*\n         L     R3,SALPROTO             length of address list\n         L     R8,SA@PROTO             @ address list\n         LR    R9,R8                   save for relocation factor\n         L     R10,SA@SSFN             @ function code CSA/LPA\n         SR    R10,R3                  @ CSA/LPA addr list\n*\n         SRL   R3,2                    = # A-con entries\n         BCTR  R3,0                    less one for A(0)\n         XC    SSVTFCOD(256),SSVTFCOD        clear func code matrix\n         XC    SSVTFRTN(STCP#SSF*4),SSVTFRTN clear function ptrs\n         SLR   R4,R4                   # function codes if none\n         SLR   R6,R6                   SSVTFRTN offset\n         LA    R2,1                    SSVTFRTN subscript (relative 1)\n*\nBSLOOP   DS    0H\n         L     R5,0(,R8)               @ function code\n         UPSR  6,'SS00 bsloop-a @ A-con',(R8)\n         UPSR  6,'SS00 bsloop-b A-con',(R5)\n         LTR   R5,R5                   end of list?\n         BZ    BSFIN\n         SLR   R4,R4                   will contain function code\n         SLDL  R4,8                    R4(24:31) <- R5(00-07)\n         C     R4,=A(STCP#SSF)         function code too high?\n         BH    BSERR\n         SRL   R5,8                    cleaned hi byte\n         SR    R5,R9                   relative to module begin\n         AR    R5,R10                  relative to CSA2\n         UPSR  6,'SS00 bsloop-c relocated',(R5)\n         ST    R5,SSVTFRTN(R6)         @ function support code\n         STC   R2,SSVTFCOD-1(R4)       set ss function rtn subscript\n         LA    R2,1(,R2)               next SSVTFRTN subscript\n         LA    R6,4(,R6)               @ next SSVTFRTN\n         LA    R8,4(,R8)               @ next A-con\n         BCT   R3,BSLOOP\n*\n         SLR   R0,R0\n         C     R0,0(,R8)               end-of-list just in time?\n         BE    BSFIN\nBSDIE    UWTO  0,'TCP/IP subsys/SVC install error'\n         MVI   SAREASON,ERR#2          # functions exceeds STCP#SSF\n         B     DIE\n*\nBSERR    DS    0H\n         UPSR  0,'TCP/IP function code too large',(R4)\n         B     BSDIE\n*\nBSFIN    ST    R4,SSVTFNUM-2           last function code + reserved\n         SPKA  8*16\n         EJECT ,\n*----------------------------------------------------------------------\n*  Load/locate SVC\n*\n*  SVCs must be either part of the resident control program (in the\n*  nucleus), or in fixed or pageable LPA\n*  This code will fail if the SVC is in the nucleus\n*----------------------------------------------------------------------\nLOADSVC  DS    0H\n         L     R7,SA@SGD               @SGD\n         USING SGD,R7\n         LA    R1,SGDMOD3              @ SVC module name\n         ST    R1,SAEPLOC3\n         BAL   R10,LOADMOD             load SVC module\n         STM   R0,R1,SALOAD3\n         LTR   R4,R0                   @ loaded module or 0=fnd in LPA\n         BZ    LSEXISTS                br; module in LPA - SVCTABLE ok\n*\n*  SVC module was loaded (not in LPA); perform load-to-global\n*\n         LR    R5,R1                   module length in doublewords\n         SLL   R5,8                    remove APF code\n         SRL   R5,8-3                  length of module in private\n*\n         SPKA  0\n         GETMAIN RU,LV=(R5),SP=POOL3   for \"LPA\" module\n         LR    R14,R1                  gotten storage addr\n         ST    R14,SGD@SVC             tell STCPSS99 GETMAIN addr\n         ST    R5,SGDLSVC              tell STCPSS99 GETMAIN len\n         MVI   SGDLSVC,POOL3                and subpool #\n         LR    R15,R5                  gotten storage length\n         STM   R14,R15,SA@CSA3         save @, length\n         MVCL  R14,R4                  copy SVC to CSA from private\n         SPKA  8*16\n*\n         SLR   R0,R0\n         IC    R0,SGDSVC#              user's SVC # choice\n         L     R1,SA@SVC               @ SVC entry point\n         ST    R1,STP@SVC\n         UCALL STCPSVC0                steal SVCTABLE entry\n*\n         L     R1,SAEPLOC3\n         BAL   R10,DELMOD              release module storage\nLSEXISTS DS    0H\n         EJECT ,\n*----------------------------------------------------------------------\n*  FINISH - SSCVT, SGD, SQH, SSVT, subsys functions, and SVC\n*----------------------------------------------------------------------\nFINISH   DS    0H\n         L     R9,SA@SSCVT             @ SSCVT\n         USING SSCT,R9\n         ST    R9,STP@SSCT\n         L     R6,SA@SSVT              @ SSVT\n         ST    R6,STP@SSVT\n         L     R7,SA@SGD               @ SGD\n         ST    R7,STP@SGD\n         L     R8,SA@SQH               @ SQH\n         ST    R8,STP@SQH\n*\n         SPKA  0\n         ST    R7,SSCTSUSE             SSCVT user field -> SGD\n         ST    R6,SSCTSSVT             SSCVT -> SSVT\n         UDIAG 3,'SS00 SSCVT',(R9),SSCTSIZE\n         SPKA  8*16\n         UWTO  0,'TCP/IP subsys initialized'\n*\n         SLR   R0,R0\n         SLR   R1,R1\n         UCALL U370QSS                 debug aid - show SS info\n*\n         SPKA  0\n         UDIAG 4,'SS00 exit SGD',(R7),L$SGD\n         UDIAG 4,'SS00 exit SQH',(R8),L$SQH\n         UDIAG 4,'SS00 exit SSVT',(R6),SSVTFSIZ+(STCP#SSF*4)\n         LM    R2,R3,SA@CSA2\n         UDIAG 5,'SS00 exit CSA2',(R2),(R3)\n         LM    R2,R3,SA@CSA3\n         UDIAG 5,'SS00 exit CSA3',(R2),(R3)\n         SPKA  8*16\n*\n         UDIAG 6,'SS00 exit SA',(RSA),L$SA\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\n         UPEND ,                       return to caller\n*----------------------------------------------------------------------\nDIE      UABEND SAREASON               bye bye\n         EJECT ,\n*----------------------------------------------------------------------\n*  LOADMOD  - Scan LPA for requested module, if not found then load\n*             module into private area\n*\n*  Returns:  if module already in LPA\n*                 R0=0\n*                 R1 @ XTLST\n*                 R2 @ major CDE\n*\n*            if module loaded to private - LOAD SVC regs as below\n*            LOAD SVC (SYM11 IEAVLK00.IGC008) returns:\n*                 R0  address of module\n*                 R1  00:07  APF code\n*                     08:31  module length in doublewords\n*----------------------------------------------------------------------\nLOADMOD  DS    0H\n         STM   R6,R11,SALOW\n         L     R6,CVTPTR\n         LR    R7,R11                  IEAQCDSR may modify R11\n         L     R8,CVTQLPAQ-CVT(,R6)    @ LPA CDE list\n         LR    R9,R1                   @ module name\n         L     R15,CVTQCDSR-CVT(,R6)   SYM11 IEAVLK00.IEAQCDSR\n         BALR  R14,R15                 scan CDE chain\n         B     LOADFND                 +0 found; +4 not found\n         LR    R11,R7                  restore in case of ABEND\n         LOAD  EPLOC=(R9)              load module or ABEND\n         LM    R6,R11,SALOW\n         BR    R10                     return R0, R1\n*\nLOADFND  DS    0H                      R11 @ CDE\n         LR    R1,R11                  save CDE ptr\n         LR    R11,R7                  restore\n         USING CDENTRY,R1\n         LR    R2,R1                   assume major CDE\n         TM    CDATTR,CDMIN            minor CDE?\n         BNO   *+8                     no, br\n         L     R2,CDXLMJP              @ major CDE\n         L     R1,CDXLMJP-CDENTRY(,R2) @ XTLST\n         SLR   R0,R0                   indicate module already loaded\n         LM    R6,R11,SALOW\n         BR    R10                     return R0, R1, R2\n         DROP  R1\n*----------------------------------------------------------------------\n*  DELMOD - Delete module from private area\n*----------------------------------------------------------------------\nDELMOD   DS    0H\n         DELETE EPLOC=(1)              release module storage\n         BR    R10\n         EJECT ,\n*----------------------------------------------------------------------\n*  FINDSSCT - attempts to locate TCP/IP subsystem SSCVT and SGD\n*----------------------------------------------------------------------\n*  May use caller's savearea (doesn't currently)\n*\n*  Entry:    Enabled or disabled\n*            Supervisor or Problem state\n*            Key 8 or 0\n*\n*            R11 @ WASTCP\n*            R13 @ standard OS savearea (18 fullwords)\n*            R14 return address\n*            R15 @ FINDSSCT\n*            STPSSN contain subsystem name\n*\n*  Exit:     Same enablement, state, and key as entered\n*\n*            Found: R0 @ SGD\n*                   R1 @ SSCVT\n*                   R15 = 0\n*\n*            Found: R0 @ 0      SSCTSUSE = 0 (no SGD)\n*                   R1 @ SSCVT\n*                   R15 = 4\n*\n*            Not:   R0 = 0\n*                   R1 = 0\n*                   R15 = 8\n*----------------------------------------------------------------------\n         PUSH  USING\n         DROP  ,\n         USING STCPWA,RSTCP\n         USING FINDSSCT,R15\n         ENTRY FINDSSCT\nFINDSSCT DS    0H\n         SLR   R0,R0                   assume SSCVT not found\n         L     R1,CVTPTR               @ CVT\n         L     R1,CVTJESCT-CVT(,R1)    @ JESCT\n         L     R1,JESSSCT-JESCT(,R1)   @ 1st SSCVT (JES2)\n         USING SSCT,R1\nFSLOOP   CLC   SSCTSNAM,STPSSN         same subsys name?\n         BE    FSFOUND                 found, return\n*\n         ICM   R1,15,SSCTSCTA          @ next subsys\n         BNZ   FSLOOP\n         LA    R15,8                   no SSCVT found; rc = 8\n         BR    R14                     return R0 = 0, R1 = 0\n*\nFSFOUND  DS    0H\n         L     R0,SSCTSUSE-SSCT(,R1)   @ SGD\n         LTR   R0,R0\n         BZ    FSNOSGD                 br, no SGD ptr\n         SLR   R15,R15                 found SSCVT & SGD; rc = 0\n         BR    R14                     return R0 @ SGD, R1 @ SSCVT\n*\nFSNOSGD  DS    0H\n         LA    R15,4                   SSCVT but no SGD; rc = 4\n         BR    R14                     return R0 = 0, R1 @ SSCVT\n         POP   USING\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\n         LTORG ,\nSAVEAREA DSECT ,\nSASA     DS    18F\n*\nSALOAD1  DS    2F                      return parms from 1st LOAD\nSAEPLOC1 DS    A                       @ name of 1st module loaded\nSALOAD2  DS    2F                      return parms from 2nd LOAD\nSAEPLOC2 DS    A                       @ name of 2nd module loaded\nSALOAD3  DS    2F                      return parms from 3rd LOAD\nSAEPLOC3 DS    A                       @ name of 3rd module loaded\n*\nSA@SSVT  DS    A                       @ SSVT\nSA@SQH   DS    A                       @ SSVT\nSA@SGD   DS    A                       @ SGD\nSA@SGD3  EQU   SA@SSVT,12              1st CSA alloc - SGD, SQH, SVT\nSALCSA1  DS    F                       length of 1st CSA allocation\nSA@CSA1  EQU   SA@SGD,8                1st CSA alloc - SGD, SQH, SVT\n*\nSA@PROTO DS    A                       @ loaded module = proto-SVT\nSALPROTO DS    F                       length of proto-SVT\nSA@CODE2 DS    A                       load2 code addr (past proto)\nSALCODE2 DS    A                       load2 code length\n*\nSA@SSFN  DS    A                       @ func code addr list\nSALSSFN  DS    F                       length of function code's CSA\nSA@CSA2  EQU   SA@SSFN,8               2nd CSA alloc - subsys functions\n*\nSA@SVC   DS    F                       addr   of SVC's CSA\nSALSVC   DS    F                       length of SVC's CSA\nSA@CSA3  EQU   SA@SVC,8                3nd CSA alloc - SVC\n*\nSA@SSCVT DS    A                       @ SSCVT\nSALOW    DS    6F                      low level subroutine SA\nSAREASON DS    X\n         DS    0D\nL$SA     EQU   *-SAVEAREA\n*\nOPT      STCP#OPT SECT=DSECT           subsys options module layout\n*\n         DSSSGD SECT=DSECT             subsys global data\n         DSSSQH SECT=LABEL             subsys queue headers\n         DSSSVT SECT=LABEL             subsys SSVT\nL$CSA1   EQU   *-SGD\n*\n         PRINT NOGEN\n         IHAPSA ,\n         CVT   DSECT=YES,LIST=NO\n         IEFJESCT ,                    JESCT\n         IEFJSCVT ,                    SSCVT\n         IEFJSSVT ,                    SSVT\n         IHACDE ,                      CDE\n         IHAXTLST ,                    XTLST\nSTCPSS00 UFINI DXDSSS00,L$SA\n*----------------------------------------------------------------------\nSTCPOPTN CSECT ,\n         STCP#OPT ID=NAME              generate CL8 options module name\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STCPSS99": {"ttr": 9738, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00q\\x00q\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 113, "newlines": 113, "modlines": 0, "user": "XV0006"}, "text": "STCPSS99 TITLE 'TCP/IP subsystem terminatino'\n*\n* Copyright 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  To do:\n*----------------------------------------------------------------------\n         U#SET FUNC=STCP\n*----------------------------------------------------------------------\n* Function:    Terminates TCP/IP subsystem\n*\n*\n* Entry:  no parms, supervisor state, key 8\n*\n* Exit:   R15 =  0 - OK; supervisor state, key 8\n*\n* Notes:\n*----------------------------------------------------------------------\nSTCPSS99 UPROC ID=SS99,L=L$SA\n         UDIAG 1,'SS99 enter'\n*----------------------------------------------------------------------\n*  Find our SSCVT\n*----------------------------------------------------------------------\n         L     R15,=V(FINDSSCT)\n         BALR  R14,R15                 find TCP/IP SSCVT\n         LTR   R9,R1                   found?\n         BZ    EXIT                    no, nothing to do\n         USING SSCT,R9\n*\nSSFOUND  DS    0H\n         L     R8,SSCTSUSE             @ SGD\n         USING SGD,R8\n         L     R7,SGD@SQH              @ SQH\n         USING SQH,R7\n         L     R6,SSCTSSVT             @ SSVT\n         USING SSVT,R6\n         TM    STPFLG1,STP1SHUT        main task requesting shutdown?\n         BO    SHUT                    good enough, br\n*----------------------------------------------------------------------\n*  Drain the subsystem\n*----------------------------------------------------------------------\nDRAIN    DS    0H\n         TM    SQHFLG1,SQH1DRN         already started draining?\n         BO    SHUT                    yes, shut it down\n         SPKA  0\n         OI    SQHFLG1,SQH1DRN         stop queueing up work\n         UWTO  0,'TCP/IP draining'\n         B     EXIT\n*----------------------------------------------------------------------\n*  Shut down the subsystem\n*----------------------------------------------------------------------\nSHUT     DS   0H\n*\n*  Call STCPSVC9 to de-install SVC before freeing SGD, since\n*  STCPSVC9 may need FREEMAIN info from the SGD if the SVC was\n*  installed into CSA\n*\n         UCALL STCPSVC9                de-install TCP/IP SVC\n*\n         SPKA  0\n         SLR   R0,R0\n         ST    R0,SSCTSSVT             SSCVT -> SSVT = 0\n         ST    R0,SSCTSUSE             SSCVT -> SGD  = 0\n         ST    R0,STP@SGD              STP -> SGD = 0\n         ST    R0,STP@SQH              STP -> SQH = 0\n         ST    R0,STP@SSVT             STP -> SSVT = 0\n*\n         L     R0,SGDLSSFN\n         LTR   R0,R0\n         BZ    FREESGD\n         L     R1,SGD@SSFN\n         FREEMAIN R,LV=(0),A=(1)       free function code CSA\n         UDIAG 2,'SS99 freed ssfn'\n*\nFREESGD  L     R0,SGDLCSA1\n         LTR   R0,R0\n         BZ    EXIT\n         FREEMAIN R,LV=(0),A=(R8)      free SGD, SQH, SSVT\n         UDIAG 2,'SS99 freed SGD, SQH, SSVT'\n*\nEXIT     DS    0H\n         SPKA  8*16\n         UWTO  2,'SS99 call QSS'\n         SLR   R0,R0\n         SLR   R1,R1\n         UCALL U370QSS                 debug aid - show SS info\n         UWTO  2,'SS99 ret  QSS'\n*\n         UDIAG 1,'SS99 exit'\n         UPEND ,                       return to caller\n         EJECT ,\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\n         LTORG ,\nSAVEAREA DSECT ,\nSASA     DS    18F\n         DS    0D\nL$SA     EQU   *-SAVEAREA\n*\n         DSSSGD ,                      TCP/IP subsys global data\n         DSSSQH ,                      TCP/IP subsys queue headers\n         WASTCP ,                      TCP/IP common\n*\n         PRINT OFF\n         CVT    DSECT=YES,LIST=NO\n         IEFJESCT ,                    JESCT\n         IEFJSCVT ,                    SSCVT\n         IEFJSSVT ,                    SSVT\n         PRINT ON\n*\nSTCPSS99 UFINI DXDSSS99,L$SA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STCPSVC": {"ttr": 9986, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00S\\x00S\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 83, "newlines": 83, "modlines": 0, "user": "XV0006"}, "text": "STCPSVC  TITLE 'TCP/IP SVC'\n*\n* Copyright 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  To do:\n*  1) Filter authorized port requests when SVC caller not APF auth'd\n*  2) Set SSTC1SVC flag after checking SSOB address\n*     Indicates caller isn't necessarily APF authorized, and hence\n*     may not be as trusted as APF authorized code\n*     Should trigger additional checks in subsys function code\n*     rather than trusting that the SVC has validated the request\n*     since sneaky user may set SSTC1SVC is it means additional auth\n*----------------------------------------------------------------------\n         U#SET FUNC=STCP\n*----------------------------------------------------------------------\n* Function:    TCP/IP SVC\n*\n* Entry:  Supervisor state, Key 0, enabled\n*\n*         Registers as set up by SVC FLIH:\n*\n*         R0   SVC issuer's R0\n*              currently unused\n*         R1   SVC issuer's R1\n*              R1 -> A(SSOB) for IEFSSREQ/IEFJSREQ\n*         R3   @ CVT\n*         R4   @ TCB of SVC issuer\n*         R5   Type 2, 3, 4 SVC: @ SVRB\n*              Type 1, 6    SVC: @ last RB\n*         R6   SVC routine entry point addr\n*         R7   @ ASCB of SVC issuer\n*         R13  SVC issuer's R13\n*              standard 18-word savearea\n*         R14  return address\n*         R15  SVC issuer's R15\n*              currently unused\n*\n*         R2, R8 - R12 are unpredictable\n*\n* Exit:   R0, R1, and R15 are only regs which are returned to the\n*         SVC issuer; R2 - R14 restored by system before giving\n*         control back to SVC issuer\n*\n* Notes:  See STCPSVC0 for notes & SVCTABLE steal\n*\n*----------------------------------------------------------------------\nSTCPSVC  UPROC ID=SVC,INIT=NONE,ENTRY=R6\n*----------------------------------------------------------------------\n*  Pass caller's SSOB to TCP/IP subsys function code in LPA\n*----------------------------------------------------------------------\n         USING STCPSVC,R6\n         LR    R8,R14                  save return addr\n*\n*  Verify SSOB address is within acceptable bounds, set\n*  SSTCFLG1.SSTC1SVC flag (SSOB passed through SVC)\n*\n*  Acceptable bounds:\n*     Within user program in private area\n*     Within user subpool in private area\n*     Authorized caller: anywhere\n*\n         IEFSSREQ ,                    call SYM11 IEFJSREQ\n*\n*  Practically speaking, the LPALIB function code doesn't return here\n*  but rather to the SVC FLIH directly (that's how IEFJSREQ sets up\n*  the regs for the LPALIB function code); still, doesn't hurt to\n*  burn two instructions \"just in case\"....\n*\n         LR    R14,R8\n         BR    R14                     return to SVC FLIH\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\n         LTORG ,\n         CVT   DSECT=YES,LIST=NO\n         IEFJESCT ,                    JES Control Table -> IEFJSREQ\n         EJECT ,\n         IEFJSSOB ,                    Subsys Options Block\n         TCPSSTC  ,                    TCP/IP extension\n         EJECT ,\n         IEFJSSIB ,                    Subsys Identification Block\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STCPSVC0": {"ttr": 9989, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x93\\x00\\x93\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 147, "newlines": 147, "modlines": 0, "user": "XV0006"}, "text": "STCPSVC0 TITLE 'TCP/IP SVC initialization'\n*\n* Copyright 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  To do:\n*----------------------------------------------------------------------\n         U#SET FUNC=STCP\n*----------------------------------------------------------------------\n* Function:    Steals an SVC entry from SVCTABLE\n*\n* Entry:  Enabled, Supervisor state, Key 8\n*\n*         R0     bits 00-23  ignored\n*                bits 24-31  SVC number to install\n*\n*         R1     address of SVC load point (= entry point)\n*\n* Exit:   Enabled, Supervisor state, Key 8\n*\n*         R15 =  0 - OK\n*\n* Notes:  IBM recommends user SVC numbers be assigned starting at\n*         255 and working towards 200; SVCs 0-199 are reserved\n*         for IBM\n*\n*         STCPSVC9 de-installs our SVC\n*\n* IBM Documentation:\n*\n* Order Number Title\n* ------------ -----------------------------------------\n*\n* GC28-0628-03 OS/VS2 System Programming Library: Supervisor\n*              Fourth Edition, August    1979\n*\n*      Miscellaneous Services - Writing SVC Routines\n*\n* GC26-3792-08 OS/VS2 System Programming Library:\n*              System Generation Reference\n*              Release 3.8\n*              Ninth  Edition, October   1980\n*\n* Data Areas:\n*\n* Anchor   Area     Create Macro\n* -------- -----    ------ --------\n*\n* CVTPTR   CVT      SYSGEN CVT       Communications Vector Table\n* CVTABEND SCVT     SYSGEN IHASCVT   Secondary Comm Vector Table\n* SCVTSVCT SVCTABLE SYSGEN IHASVC\n*\n* Areas created by SYSGEN are nucleus-resident, Key 0\n*\n* Source code:\n*\n* SYM11 IHASVC   - SVC table entry\n*\n* SYM11 IEAVNPS5 - SVCTABLE initialization (NIP)\n*\n* SYM11 IEAVESVC - SVC FLIH\n*\n*----------------------------------------------------------------------\nERR#1    EQU   1        SVC # not acceptable\n*\nSTCPSVC0 UPROC ID=SS00,L=L$SA\n         STM   R0,R1,SAENTRY\n         LR    R8,R0                   save SVC #\n         LA    R9,0(,R1)               save SVC entry point addr\n*\n         UPSR  1,'SVC0 SVC #',(R8)\n         UPSR  1,'SVC0 SVC @',(R9)\n         SLL   R8,32-8\n         SRL   R8,32-8                 remove extraneous bits\n         MVI   SAREASON,ERR#1          SVC # not acceptable\n         C     R8,=F'200'              SVC # too low?\n         BL    DIE\n*\n         L     R3,CVTPTR               @ CVT\n         USING CVT,R3\n         L     R4,CVTABEND             @ 2ndry CVT\n         USING SCVTSECT,R4\n         L     R5,SCVTSVCT             @ SVCTABLE\n         USING SVCENTRY,R5\n         DROP  R3,R4\n         UDIAG 5,'SVC0 SVCTABLE pre mod',(R5),16+(256*L$SVC)\n*\n         LR    R10,R8\n         SLL   R8,3                    SVC entry length = 8\n         LA    R5,SVCENTRY(R8)         @ target SVC entry\n         UDIAG 4,'SVC0 SVC old entry',(R5),L$SVC\n         C     R9,SVCEP                already installed?\n         BE    EXIT\n*\n         ST    R5,STP@SVCT             save addr of SVC entry\n         MVC   STPSVCTB,SVCENTRY       save old SVC entry for restore\n         SPKA  0\n         ST    R9,SVCEP                overlay with SVC entry addr\n         MVC   SVCATTR1(L$SVC-L'SVCEP),SVCMODEL    update SVCTABLE\n         SPKA  8*16\n*\n         UDIAG 4,'SVC0 TCP/IP SVC new entry',(R5),L$SVC\n         UDIAG 3,'SVC0 WASTCP SVC fields',STPSVCXX,L'STPSVCXX\n         B     EXIT                    not ready to test SVC yet\n*\n*  DEBUG\n*\n         SLR   R0,R0\n         LA    R1,1\n         LA    R15,15\n*\n         MVI   SASVC,X'0A'             SVC opcode\n         IC    R14,SAENTRY+3           grab SVC #\n         STC   R14,SASVC+1\n         EX    R0,SASVC                invoke SVC\n         STM   R15,R1,SATEMP           save SVC return regs\n         UDIAG 4,'SVC0 SVC return',SATEMP,12\n*\nEXIT     UPEND ,                       return to caller\n         EJECT ,\n*----------------------------------------------------------------------\nDIE      UABEND SAREASON               bye bye\n         EJECT ,\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\nSVCMODEL DC    AL1(SVCTP34,0,0,0)\n         LTORG ,\nSAVEAREA DSECT ,\nSASA     DS    18F\nSAENTRY  DS    2F                      R0, R1 from caller\nSATEMP   DS    3F\nSASVC    SVC   0\nSAREASON DS    X\n         DS    0D\nL$SA     EQU   *-SAVEAREA\n*\n         WASTCP ,                      TCP/IP common\n         CVT    DSECT=YES,LIST=NO\n         IEFJESCT ,                    JESCT\n         IEFJSCVT ,                    SSCVT\n         IEFJSSVT ,                    SSVT\n         IHASCVT ,                     secondary CVT\n         IHASVC ,                      SVCTABLE entry\nL$SVC    EQU   *-SVCENTRY              length of SVCTABLE entry\nSTCPSVC0 UFINI DXDSSVC0,L$SA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STCPSVC9": {"ttr": 9993, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00J\\x00J\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 74, "newlines": 74, "modlines": 0, "user": "XV0006"}, "text": "STCPSVC9 TITLE 'TCP/IP SVC termination'\n*\n* Copyright 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  To do:\n*----------------------------------------------------------------------\n         U#SET FUNC=STCP\n*----------------------------------------------------------------------\n* Function:    Restores SVCTABLE for our stolen SVC entry\n*              with the original contents of SVCTABLE entry\n*\n* Entry:  no parms, supervisor state, key 8\n*\n* Exit:   R15 =  0 - OK; supervisor state, key 8\n*\n* Notes:  See STCPSVC0 for notes & SVCTABLE steal\n*\n*----------------------------------------------------------------------\nSTCPSVC9 UPROC ID=SS00,L=L$SA\n         UDIAG 1,'SVC9 enter'\n         L     R3,STP@SVCT             @ stolen SVC entry\n         LTR   R3,R3\n         BNZ   DEINST\n         UDIAG 1,'SVC9 TCP/IP SVC not installed'\n         B     GETSGD\n*\nDEINST   SPKA  0\n         MVC   0(L$SVC,R3),STPSVCTB    restore SVCTABLE entry\n         XC    STPSVCX,STPSVCX         clear stolen entry\n         UDIAG 2,'SVC9 TCP/IP SVC restored'\n*\nGETSGD   L     R4,STP@SGD              @ ss SGD\n         USING SGD,R4\n         LTR   R4,R4\n         BNZ   REPGONE\n         UDIAG 1,'SVC9 SGD not available'\n         B     EXIT\nREPGONE  MVC   SGDSVC(4),GONE          replace SVC with GONE instr\n*\n*  If STCPSS00 allocated CSA storage for the SVC, free it\n*\n         L     R0,SGDLSVC\n         LTR   R0,R0\n         BZ    EXIT\n         L     R1,SGD@SVC\n         LTR   R1,R1\n         BZ    EXIT\n         FREEMAIN R,LV=(0),A=(1)       release SVC GETMAIN space\n         UDIAG 2,'SVC9 freed CSA'\n*\nEXIT     SPKA 8\n         UDIAG 1,'SVC9 exit'\n         UPEND ,                       return to caller\n*----------------------------------------------------------------------\nGONE     LA    R15,20                  replaces STPSVC when SVC removed\n         EJECT ,\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\n         LTORG ,\nSAVEAREA DSECT ,\nSASA     DS    18F\nSAREASON DS    X\n         DS    0D\nL$SA     EQU   *-SAVEAREA\n*\n         WASTCP ,                      TCP/IP common\n         DSSSGD SECT=DSECT\n         PRINT NOGEN\n         IHASVC ,\nL$SVC    EQU   *-SVCENTRY              length of SVCTABLE entry\nSTCPSVC9 UFINI DXDSSVC9,L$SA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STCPTSKM": {"ttr": 9996, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x020\\x020\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 560, "newlines": 560, "modlines": 0, "user": "XV0006"}, "text": "STCPTSKM TITLE 'TCP/IP task manager'\n*\n* Copyright 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  To do:\n*  1) Support WUDFLG1.WUD1MOD (attach module, not CSECT)\n*  1) Support WUDFLG1.WUD1RSTS (restart task as needed)\n*  0) MON support\n*     Should we restart failed subtask???\n*     Currently, we exit at first subtask completion\n*     Appropriate ABENDs from MVS...\n*  0) Check ECBs in START to assure TCB didn't die\n*     Might not be necessary, since whoever in main WAITs on the WEE\n*     Looks like TSKM will be the one who WAITs in main\n*     ECB list will take the POST & find out anyway\n*  4) WUD@CODE - if = 0, WUDNAME is load module name to be LINK/LOADd\n*----------------------------------------------------------------------\n         U#SET FUNC=STCP\n*----------------------------------------------------------------------\n* Function:    Manages subtasks for TCP/IP\n*\n* Main    - Accepts WUD from caller, attaches TCB to handle\n*           unit of work described by WUD\n*\n*         - Handles subtask shutdown\n*\n*         - Called by main task to monitor subtasks after\n*           main task initialization complete\n*\n* Subtask - Initializes TCB, establishes ESTAE environment to\n*           recover crashed CSECT, waits for work\n*\n*         - dispatches CSECT indicated in WUD to handle work\n*\n*         - Upon return from dispatched CSECT, waits for work\n*\n* Entry:  R0(00:07) - function code\n*\n*         TSKM$ADD - Create task to service WUD\n*                    R1 @ caller-supplied WUD\n*                    (not actual WUD used by new TCB)\n*                    addr of real WUD returned to caller in R1\n*\n*         TSKM$NEW - Subtask initialization & dispatch\n*                    R1 @ WUD (from STCP370 entry)\n*\n*         TSKM$MON - main task - monitor subtasks\n*                    R1 = 0\n*\n*         R0(08:31) - ignored\n*\n* Exit:   R15 =  0 - OK\n*               16 - STCPTSKM ABENDed\n*\n*         R1  @ WUD associated with new TCB (ADD only)\n*\n* Diagnostics:\n*\n*              1 - INIT WIB prefix\n*              2 - START attach TCB\n*              3 - ADD accepted WUD\n*                  MON - WIB prior to WAIT\n*              4 - WIB at subtask subdown\n*              5 - entry/exit\n*              6 - WIB at exit\n*              7 - RUN - WUD\n*              8 - ADD WUD scan\n*\n* Notes:\n*\n* Data Areas:\n*\n*        WUD - Work Unit Descriptor; describes work TCB will perform\n*\n*        WIB - WUD Information Block; application-wide anchor for WUDs\n*\n*        WTE - WIB Task Element; pointers in WIB to WUD stuff\n*\n*        WEE - WIB ECB Element; pointers in WIB to ECBs for WUD\n*\n*----------------------------------------------------------------------\nERR#1    EQU   1        CPD missing\nERR#2    EQU   2        invalid function code\nERR#3    EQU   3\nERR#4    EQU   4        ADD; R1=0\nERR#5    EQU   5        ADD; no free WUDs\nERR#6    EQU   6        can't locate WIB\nERR#7    EQU   7\n*\n         DSWUD ,                       WUD\n         DSWIB ,                       WIB, WTE, WEE\n*----------------------------------------------------------------------\nTPU      DSECT ,                       CSECT's CPD user additions\nTPUFLG1  DS    X                       status flag\nTPU1RRR  EQU   1                       ESTAE established\n         DS    0D\nL$TPU    EQU   *-TPU\n*\n*----------------------------------------------------------------------\n* Reg  DSECT    Usage\n*----------------------------------------------------------------------\n* R2            scratch\n* R3   WIB      RWIB\n* R4   WUD      RWUD\n* R5            Reserved for function code\n* R6            Reserved for function code\n* R7            Reserved for function code\n* R8            Reserved for function code\n* R9   TPU      RTPU\n* R10           internal linkage, scratch\n* R11           STCPWA\n* R12           base reg\n* R13  SAVEAREA SA\n*----------------------------------------------------------------------\nRWIB     EQU   3\nRWUD     EQU   4\nRTPU     EQU   9\n*----------------------------------------------------------------------\nSTCPTSKM UPROC ID=STKM,L=L$SA,CPD=(Y,L$TPU,ESTAE)\n*----------------------------------------------------------------------\n         USING PSA,0\n         STM   R0,R2,SAENTRY           save entry parms\n         UDIAG 5,SKIP=GO\n         BAL   R10,DIAG1               display entry parms\nGO       DS    0H\n         EJECT ,\n*----------------------------------------------------------------------\n*  Main task: Initialize WIB\n*  Sub  task: Set RWIB\n*\n*  The WIB (only one) will be GETMAIN'd by main task\n*----------------------------------------------------------------------\n         BAL   R10,FINDWIB             locate WIB\n         LTR   RWIB,RWIB               found WIB?\n         BNZ   INITFIN\n*\n*  Main task will initialize WIB\n*\nINITWIB  DS    0H\n         L     R0,=A(L$WIB)            WIB length\n         ST    R0,STPWIBLV             save for shutdown\n         GETMAIN R,LV=(R0)             allocate WIB storage\n         LR    RWIB,R1\n         USING WIB,RWIB\n         UZERO (RWIB),L$WIB            clear WIB storage\n         ST    RWIB,STP@WIB            set @ WIB in AGD\n         ST    RTGD,STP@AGD            maintask TGD = AGD\n         MVC   WIBID,=C'WIB'           set eyecatcher\n         L     R0,PSATOLD              @ main task TCB\n         ST    R0,WIB@TCB\n*\n*  Init WUD section of WIB\n*\n         LA    R0,WIBWUD1              @ 1st WUD slot\n         LA    R1,L$WUD                WUD length\n         LA    R2,WIBWUDX              last byte of WUD slots\n         STM   R0,R2,WIBWUDBX          save BXLE regs\n         MVC   WIBWUDID,=C'WUDL'       set eyecatcher\n*\n*  Init WEE section of WIB\n*\n         LA    R0,WIBWEE1              @ 1st WEE slot\n         LA    R1,L$WEE                WEE length\n         LA    R2,WIBWEEX              last byte of WEE slots\n         STM   R0,R2,WIBWEEBX          save BXLE regs\n         MVC   WIBWEEID,=C'WEEL'       set eyecatcher\n*\n         UDIAG 3,'TSKM WIB init',(RWIB),L$WIB\n*\n*  Establish TSKM ESTAE in main task\n*\n         BAL   R10,FINDTPU             locate TPU\n         USING TPU,RTPU\n         UESTAE RETRYMOM               establish ESTAE routine\n         OI    TPUFLG1,TPU1RRR         ESTAE established\n         DROP  RTPU\nINITFIN  DS    0H                      RWIB set\n         EJECT ,\n*----------------------------------------------------------------------\n*  Check function code for call type\n*----------------------------------------------------------------------\nCKCODE   DS    0H\n         CLI   SAR0B0,TSKM$NEW         function code = NEW?\n         BE    NEW\n         CLI   SAR0B0,TSKM$ADD         function code = ADD?\n         BE    ADD\n         CLI   SAR0B0,TSKM$MON         function code = MONITOR?\n         BE    MON\n         MVI   SAREASON,ERR#2          invalid function code\n         B     DIE\n         EJECT ,\n*----------------------------------------------------------------------\n*  Main task - Add WUD to WIB\n*----------------------------------------------------------------------\n*  R5, R6, R7  WUD BXLE regs\nADD      DS    0H\n         MVI   SAREASON,ERR#4          ADD; caller's R1=0\n         ICM   RWUD,15,SAR1            @ caller's WUD\n         BZ    DIE\n         LM    R5,R7,WIBWUDBX          WUD BXLE regs\n         USING WUD,R5\n*\nADDSCAN  DS    0H\n         UDIAG 8,'TSKM ADD scan WUD',(R5),L$WUD\n         ULOCK RWUD,WUD@TCB            entry locked?\n         BE    ADDWUD                  br, we own it\n         BXLE  R5,R6,ADDSCAN           @ next WTE\n         MVI   SAREASON,ERR#5          no free WUDs\n         B     DIE\n*\nADDWUD   DS    0H                      WUD now locked, we own it\n         BAL   R10,START               start WUD, reset RWUD\n         UDIAG 2,'TSKM ADD accept WUD',(RWUD),L$WUD\n         B     EXIT                    WUD added OK\n         DROP  R5\n         EJECT ,\n*----------------------------------------------------------------------\n*  Main task - Attach new subtask giving it a WUD to initialize\n*  (Only) Caller: ADDWUD\n*\n*  There are two WUDs being referrenced here:\n*  RWUD - TSKM's caller provided\n*  R5   - The available WUD found by NEW when it scanned the WIB\n*\n*  NEW's WUD will be the real WUD, the caller's may be discarded\n*  upon return of TSKM.\n*\n*  The TCB will be associated with the WUD supplied by NEW for the\n*  life of the task\n*\n*  Upon return to ADD, RWUD contains the address of the \"real\" WUD\n*----------------------------------------------------------------------\n         USING WUD,RWUD                from ADD, @ caller's WUD\nSTART    DS    0H\n         LR    R0,RBASE                virtual address for VADR\n         LA    R1,SAVBUF               U370VADR's buffer\n         UCALL U370VADR                my module name for ATTACH\n*\n*  Copy selected fields from caller's WUD\n*  In particular, don't copy WUD@TBC; it's our lock word\n*\n         MVC   WUD@2ECB-WUD(L'WUD@2ECB,R5),WUD@2ECB\n         MVC   WUDNAME-WUD(L'WUDNAME,R5),WUDNAME\n         MVC   WUD@CODE-WUD(L'WUD@CODE,R5),WUD@CODE\n         MVC   WUDWORD-WUD(L'WUDWORD,R5),WUDWORD\n         MVC   WUDLOGD-WUD(L'WUDLOGD,R5),WUDLOGD\n*\n         LR    RWUD,R5                 RWUD @ real WUD\n         MVC   WUDID,=C'WUD'           flag WUD as accepted\n         MVI   WUDFLG1,WUD1STRT+WUD1ACT\n         ST    RTGD,WUD@AGD            tell subtask @ main's TGD\n         ST    RWIB,WUD@WIB            tell subtask @ WIB\n         SLR   R0,R0\n         ST    R0,WUDRUN               clear work-waiting ECB\n         ST    R0,WUDEOT               clear End Of Task ECB\n         ST    R0,WUDNEW               clear START/NEW ECB\n         UDIAG 3,'TSKM attach WUD',(RWUD),L$WUD\n*\n         MVC   SAATCH(L$ATCH),MDLATCH\n         LR    R1,RWUD                 STCP370 parm\n         ATTACH EPLOC=SAVMOD,ECB=WUDEOT,                               +\n               SF=(E,SAATCH)\n         ST    R1,WUD@TCB              @ TCB (replace placeholder)\n         UPSR  2,'TSKM START TCB',*WUD@TCB\n*\n         LA    R0,WUDNEW               1st ECB=init complete\n         ST    R0,SAWAITL1\n         LA    R0,WUDEOT               2nd ECB=task complete\n         ST    R0,SAWAITL2\n         OI    SAWAITL2,X'80'          end of WAIT list\n         WAIT  1,ECBLIST=SAWAITL1      WAIT for subtask to come up\n*\n         ST    RWUD,SA@WUD             @ WUD to return to caller\n         BR    R10                     return to ADD\n         EJECT ,\n*----------------------------------------------------------------------\n*  Subtask - set up WUD & wait for work\n*\n*  START (in main task) is waiting for us to indicate we're initialized\n*  The WUD in SAR1 is the one TSKM's caller provided; it's location\n*  is not where the WUD will reside once the new task is up\n*  The new WUD will reside in this CSECT's TPU, a unique copy of\n*  which exists for each TCB\n*----------------------------------------------------------------------\n*\n*  TSKM ADD note concerning WUD initialization:\n*  TSKM's caller must initialize the WUD before calling TSKM\n*  The following fields need consideration when creating a WUD:\n*\n*      WUD@CODE - required,  A-con pointing to service CSECT\n*      WUDLOGD  - required,  CL8 DDname for subtask LOG (U370LOG)\n*      WUDNAME  - suggested, CL8 service CSECT name\n*      WUD@2ECB - optional,  TSKM RUN external ECB (STCPOPR only)\n*      WUDID    - optional,  CL3 WUD-creator name\n*\n*  TSKM RUN note concerning WUD@CODE usage of WUD fields:\n*\n*  WUD@CODE may change the ECBLIST address (WUD@ECBL) if it wishes\n*  to WAIT on a different set of ECBs, subject to leaving WUDRUN\n*  the ECB which is WAITed on for work (task shutdown also POSTs\n*  WUDRUN, so don't be so clever you hurt yourself)\n*  If WUD@CODE does change the WUD@ECBL value, it may also reclaim\n*  the WUD@1ECB field for it's own use\n*  WUD@CODE may also make whatever use it wishes for the following\n*  fields:  WUDSCR, WUDWORD.\n*\nNEW      DS    0H\n         L     RWUD,SAR1               @ caller's WUD\n         USING WUD,RWUD\n         LA    R0,WUDRUN               work ECB\n         ST    R0,WUD@1ECB             into ECBLIST\n         LA    R0,WUD@1ECB             default ECBLIST addr\n         ST    R0,WUD@ECBL             WUD@CODE may change\n         SLR   R0,R0\n         C     R0,WUD@2ECB             external ECB present?\n         BNE   *+8                     yes, make that end of ECBLIST\n         OI    WUD@1ECB,X'80'          end of ECBLIST - WUDRUN\n         OI    WUD@2ECB,X'80'          end of ECBLIST - external ECB\n         L     R0,PSATOLD              @ my TCB\n         ST    R0,WUD@TCB\n*\n         BAL   R10,FINDTPU             locate TPU\n         USING TPU,RTPU\n*<temp>  UESTAE RETRYKID               establish ESTAE routine\n         OI    TPUFLG1,TPU1RRR         ESTAE established\n         DROP  RTPU\n*\n         L     R2,=A(POST$NEW)         NEW post code\n         POST  WUDNEW,(R2)             wake up START in main task\n         EJECT ,\n*----------------------------------------------------------------------\n*  Subtask - RUN - WAIT for work, dispatch @CODE when arrives\n*----------------------------------------------------------------------\nRUN      DS    0H\n         UDIAG 7,'TSKM run WUD',(RWUD),L$WUD\n         SLR   R0,R0                   see if can bypass WAIT\n         C     R0,WUDRUN               ECB already POSTed?\n         BNE   RUNWAITX                ECB POSTEd, br\n*\nRUNWAIT  DS    0H\n         UDIAG 7,'TSKM run wait'\n         L     R2,WUD@ECBL             @ ECBLIST\n         WAIT  1,ECBLIST=(R2)          wait for work to appear\n*\nRUNWAITX CLC   SHUTCODE,WUDRUN+1       shutdown?\n         BE    SHUTSUB                 yes, br\n         SLR   R0,R0                   clear ECB for next POST\n         ST    R0,WUDRUN\n*\nRUNDISP  DS    0H\n         UDIAG 7,'TSKM run disp'\n         LR    R0,RWUD                 @ WUD\n         L     R1,WUDWORD              parmlist or whatever\n         L     R15,WUD@CODE            @ CSECT supporting WUD\n         BALR  R14,R15                 call support code\n         B     RUN\n*\nPOSTSHUT DC    A(POST$SHU)             subtask shutdown POST code\nSHUTCODE EQU   POSTSHUT+1,3\n*----------------------------------------------------------------------\n*  Shutdown subtask\n*----------------------------------------------------------------------\nSHUTSUB  DS    0H\n         UPSR  1,'TSKM shutsub WUD',(RWUD)\n         B     EXIT\n         EJECT ,\n*----------------------------------------------------------------------\n*  Main task: monitor subtasks\n*  Build ECBLIST, WAIT on it for subtask completion\n*  At task completion, DETACH TCB\n*----------------------------------------------------------------------\nMON      DS    0H\n         DROP  RWUD\n         LA    R8,WIBWEE1              @ 1st WEE\n         USING WEE,R8\n         LM    R5,R7,WIBWUDBX          WUD BXLE regs\n         USING WUD,R5\n*\nMONSCAN  TM    WUDFLG1,WUD1ACT         WUD running?\n         BNO   MONNEXT\n         LA    R0,WUDEOT               @ WUD's End Of Task ECB\n         ST    R0,WEE@EOT\n         LA    R8,L$WEE(,R8)           @ next WEE\nMONNEXT  BXLE  R5,R6,MONSCAN\n*\n         LA    R0,L$WEE\n         SR    R8,R0                   back up to last WEE\n         OI    WEE@EOT,WEE$LAST        last ECB flag\n         DROP  R5,R8\n*\n         UDIAG 3,'TSKM mon wait WIB',(RWIB),L$WIB\n         WAIT  1,ECBLIST=WIBWEE1       wait for news\n*\n         BAL   R10,DETACH              DETACH completed TCBs\n*\n*  For now, we exit after 1st subtask completes\n*\n         ICM   RWIB,15,STP@WIB\n         BZ    MONFIN\n         UDIAG 4,'TSKM mon post-detach WIB',(RWIB),L$WIB\n         ICM   R0,15,STPWIBLV          WIB allocated?\n         BZ    MONFIN\n         FREEMAIN R,LV=(R0),A=(RWIB)   release WIB storage\n         SLR   RWIB,RWIB               tell EXIT no WIB\n         ST    RWIB,SA@WUD             WUDs were in WIB just freed\nMONFIN   DS    0H\n         EJECT ,\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\nEXIT     DS    0H\n         ICM   RWUD,15,SA@WUD\n         BZ    EX01\n         UDIAG 5,'TSKM exit WUD',(RWUD),L$WUD\nEX01     LTR   RWIB,RWIB\n         BZ    EX02\n         UDIAG 6,'TSKM exit WIB',(RWIB),L$WIB\nEX02     UPSR  1,'TSKM exit rc',*SARC\n         LR    R1,RWUD                 return WUD or 0\n         UPEND RC=*SARC,R1=PASS\n         EJECT ,\n*----------------------------------------------------------------------\n*  DETACH - main task - locate completed TCB(s), DETACH, release WUD\n*  The task that DETACHes a TCB must be the task that created it\n*----------------------------------------------------------------------\nDETACH   DS    0H\n         LM    R5,R7,WIBWUDBX          WUD BXLE regs\n         USING WUD,R5\n*\nDETSCAN  DS    0H\n         ICM   R8,15,WUD@TCB\n         BZ    DETNEXT\n         USING TCB,R8\n         UDIAG 3,'TSKM detach WUD',(R5),L$WUD\n         TM    WUDFLG1,WUD1ACT         TCB created?\n         BNO   DETNEXT\n         UDIAG 7,'TSKM detach TCB',(R8),TCBMNLEN+TCBX2LEN\n         TM    TCBFLGS5,TCBFC          task terminated?\n         BNO   DETNEXT\n*\n         LA    R1,WUD@TCB\n         DETACH (1)                    remove subtask TCB\n         XC    WUD(L$WUD),WUD          clear WUD\n*\nDETNEXT  BXLE  R5,R6,DETSCAN\n         UDIAG 4,'TSKM post-detach TCB summary'\n         UCALL U370QTCB\n         SLR   R15,R15                 <temp> no restart???\n         BR    R10\n         DROP  R5,R8\n*----------------------------------------------------------------------\n*  FINDTPU - Locate TPU or ABEND\n*----------------------------------------------------------------------\nFINDTPU  U@CPD TPU,RTPU,ERR=NOTPU      find our TPU\n         BR    R10                     return w/ TPU\nNOTPU    MVI   SAREASON,ERR#1          couldn't find TPU\nDIE      UABEND SAREASON\n*----------------------------------------------------------------------\n*  FINDWIB - Locate WIB\n*  Will return RWIB @ WIB, RWIB = 0, or no return if bad environment\n*  Subtask side effects: sets STP@AGD, STP@WIB\n*----------------------------------------------------------------------\nFINDWIB  DS    0H\n         ICM   RWIB,15,STP@WIB         main/subtask already know?\n         BNZR  R10                     that was easy\n*\n*  We now know it's first TSKM call in this TCB\n*\n         MVI   SAREASON,ERR#7          assume broken environment\n         ICM   RWUD,15,SAR1            caller provided WUD?\n         BZ    DIE                     MON request, but no WIB\n         USING WUD,RWUD\n*\n*  WUD@AGD and WUD@WIB only set for subtasks\n*\n         ICM   R14,15,WUD@AGD          caller provided @ AGD in WUD?\n         BZR   R10                     no, return to init WIB\n         ST    R14,STP@AGD             subtask now knows @ AGD\n         ICM   RWIB,15,WUD@WIB         (subtask) WUD knows @ WIB?\n         BNZ   FW@WIB                  yes, store @WIB in subtask TGD\n         ICM   RWIB,15,STP@WIB-STCPWA(R14)   main task knows @ WIB?\n         BZR   R10                     return w/ RWIB=0\nFW@WIB   ST    RWIB,STP@WIB            subtask now knows @ WIB\n         BR    R10                     return w/ RWIB @ WIB\n*----------------------------------------------------------------------\n*  DIAG1 - TSKM entry parms diagnostic\n*----------------------------------------------------------------------\nDIAG1    DS    0H\n         MVI   SAMSG,C' '\n         MVC   SAMSG+1(L'SAMSG-1),SAMSG\n         MVC   SAM1LIT1,=C'<5> TSKM enter'\n         L     R0,SAR0\n         LA    R1,SAM1TXT1\n         CALL  U370HEX\n         L     R0,SAR1\n         LA    R1,SAM1TXT2\n         CALL  U370HEX\n         ULOG  SAMSG\n         BR    R10\n*----------------------------------------------------------------------\nRETRYMOM DS    0H                      main task RRR\n         MVI   SARC+3,16               TSKM ABENDed\n         UWTO  0,'TSKM main RETRY'\n         L     RWIB,STP@WIB            @ WIB if initialized\n         B     EXIT\n*----------------------------------------------------------------------\nRETRYKID DS    0H                      sub  task RRR\n         MVI   SARC+3,16               TSKM ABENDed\n         UWTO  0,'TSKM sub RETRY'\n         B     EXIT\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\nMDLATCH  ATTACH EPLOC=0,ECB=0,SF=L\nL$ATCH   EQU   *-MDLATCH\n         LTORG ,\n*\n*----------------------------------------------------------------------\n*  Savearea & workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSASA     DS    18F\nSAENTRY  DS    3F                      R0:R2 at entry\nSAR0B0   EQU   SAENTRY+00,1\nSAR0     EQU   SAENTRY+00,4\nSAR1     EQU   SAENTRY+04,4\n*\nSARC     DS    F                       OPR return code\nSA@WUD   DS    A                       WUD added to WIB or 0\nSAECB1   DS    F                       START waits for init to finish\nSAWAITL1 DS    2F                      START ECBLIST\nSAWAITL2 EQU   SAWAITL1+4,4            2nd ECB in START ECBLIST\nSAATCH   ATTACH EPLOC=SAVMOD,SF=L\nSAATPL   DS    F                       parm for ATTACHed pgm\nSAREASON DS    X                       UABEND reason code\nSAVBUF   DS    0C                      U370VADR return area\n         DVADRBUF PFX=SAV              output buffer for U370VADR\n         ORG   SAVBUF\nSAM1LIT1 DS    C'<5> TSKM enter',C\nSAM1TXT1 DS    CL8,C                   entry R0\nSAM1TXT2 DS    CL8                     entry R1\nL$SAMSG1 EQU   *-SAM1LIT1\nSAMSG    EQU   SAM1LIT1,L$SAMSG1\n         ORG   ,\n*\n         DS    0D                      align\nL$SA     EQU   *-SAVEAREA              length of savearea\n*\n         WASTCP ,\n*\n         PRINT NOGEN\n         IHAPSA ,                      Prefixed Storage Area\n         IKJTCB DSECT=YES,LIST=NO      Task Control Block\nL$TCB    EQU   TCBMNLEN                length of main section\n         IHAECB ,                      Event Control Block\n*\n         PRINT GEN\nSTCPTSKM UFINI DXDSTKM,L$SA\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STCPVTAB": {"ttr": 10246, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x11\\x00\\x11\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "XV0006"}, "text": "STCPVTAB TITLE 'STCP370 VCON table'\n*\n* Copyright 2002 James M. Morrison\n*\n         U#SET FUNC=STCP\n         UVTAB MF=HDR\n*\n         UVTAB STCP370\n         UVTAB STCPOPR\n         UVTAB STCPSS00\n         UVTAB STCPSS99\n         UVTAB STCPSVC0\n         UVTAB STCPSVC9\n         UVTAB STCPTSKM\n*\n         UVTAB MF=TLR\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STCP370": {"ttr": 10248, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x8b\\x00\\x8b\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 139, "newlines": 139, "modlines": 0, "user": "XV0006"}, "text": "STCP370  TITLE 'MVS38j TCP/IP subsystem - main'\n*----------------------------------------------------------------------\n*  Copyright 2002, James M. Morrison\n*----------------------------------------------------------------------\n*  Things to do:\n*----------------------------------------------------------------------\n         U#SET FUNC=STCP\n*----------------------------------------------------------------------\n*  Diagnostics:\n*              1 - RETRY entered\n*              2 - trace msgs\n*              3 - RETRY regs\n*              4 - subtask - WUD @ entry\n*----------------------------------------------------------------------\n* Notes:\n*----------------------------------------------------------------------\n* R2\n* R3\n* R4\n* R5\n* R6\n* R7\n* R8\n* R9  WUD      subtask mode\n* R10          our real program base reg\n* R11          STCPWA ... ALWAYS (contains our savearea)\n* R12          BASE REG ... ALL CSECTS\n* R13          savearea\n*----------------------------------------------------------------------\n         TITLE ' '\nSTCP370  UPROC ID=MAIN,L=L$SA,CPD=(Y,0,ESTAE)\n***\n*----------------------------------------------------------------------\n***\n         OI    TGDFLG4,TGD4NSTA        don't want ANY ESTAEs\n**\n*----------------------------------------------------------------------\n**\n         L     R1,TGD@PARM             save entry parms\n         LTR   R1,R1\n         BZ    SUBSYS\n         CLC   =C'WUD',0(R1)           subtask?\n         BNE   SUBSYS\n*----------------------------------------------------------------------\n*  Subtask support\n*----------------------------------------------------------------------\nSUBTASK  DS    0H\n         LR    R9,R1                   @ WUD\n         USING WUD,R9\n         MVC   TGDLOGD,WUDLOGD         set U370LOG DDname\n         UDIAG 0,'TCP/IP subtask active'\n         UDIAG 4,'370 subtask WUD',(R9),L$WUD\n         UCALL U370DBUG                handle xxxxDBUG\n         UCALL U370QTCB                ASCB, ASXB, TCB diag info\n         ICM   R0,8,=AL1(TSKM$NEW)     new TCB - setup task\n         LR    R1,R9\n         UCALL STCPTSKM                subtask task manager\n         DROP  R9\n         UWTO  2,'370 sub  EXIT'\n         B     TASKFIN                 clean up & exit\n*----------------------------------------------------------------------\n*  Subsystem initialization\n*----------------------------------------------------------------------\nSUBSYS   DS    0H\n         ULOG 'STCP370 v00.00 Copyright 2002, James M. Morrison'\n         UCALL U370DBUG                handle xxxxDBUG\n         UQENV ,                       query APF\n         TM    TGDFLG2,TGD2APF         APF authd?\n         BO    AUTHOK\n         UWTO  0,'TCP/IP APF error'\n         MVI   SAREASON,X'47'          not authorized\nUABEND   UABEND SAREASON               ABEND w/ diagnostics\nAUTHOK   DS    0H\n         UESTAE RETRY                  establish ESTAE environment\n*\n         UDIAG 2,'370 - INIT'\n         UCALL STCPSS00,ERR=SHUT       start up subsystem\n         OI    STPFLG1,STP1INIT\n         UCALL STCPOPR,ERR=SHUT        start up opr interface\n*\n*  STCPOPR will start up the 3088 interface, since the cuu the user\n*  wishes to use may be specified on the TCP/IP start command\n*\n         NI    STPFLG1,255-STP1INIT\n*----------------------------------------------------------------------\n*  Run TCP/IP\n*----------------------------------------------------------------------\nMON      DS    0H\n         TM    STPFLG1,STP1ABRT                  abort startup?\n         BO    SHUT\n         UWTO  2,'370 - MON'\n         ICM   R0,8,=AL1(TSKM$MON)               monitor subtasks\n         SLR   R1,R1                             no WUD - main task\n         UCALL STCPTSKM                          manage subtasks\n*----------------------------------------------------------------------\n*  Termination\n*----------------------------------------------------------------------\nSHUT     DS    0H\n         UWTO  2,'370 - SHUT'\n         OI    STPFLG1,STP1SHUT        shutdown appl\n         UCALL STCPSS99                shut subsystem\n         UCALL STCPOPR                 shut opr interface\n         UWTO  2,'370 main EXIT'\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\nTASKFIN  DS    0H\nRESTART  DS    0H\nEXIT     DS    0H\n         UPEND ,                       terminate application\n*----------------------------------------------------------------------\n*  ESTAE retry routine\n*----------------------------------------------------------------------\nRETRY    DS    0H\n         STM   R0,R15,SAREGS       diag aid\n         UWTO  1,'370 RETRY routine called'\n         UDIAG 3,'370 retry regs',SAREGS,16*4\n         B     RESTART\n*----------------------------------------------------------------------\n         LTORG ,\n*\n         EJECT ,\n         WASTCP ,\n         DSWUD ,                            Work Unit Descriptor\n*\n         EJECT ,\nSAVEAREA DSECT ,\n         DS    18F\nSAREGS   DS    16F\nSAENTRY  DS    F                            entry R1\nSAREASON DS    X\nSAEND    DS    0D\nL$SA     EQU   *-SAVEAREA\n*\n         PRINT GEN\nSTCP370  UFINI DXDTGD,L$STCP,ID=TGD         TGD + STCPWA\nSTCP370  UFINI DXDS370,L$SA                 CSECT workarea\n*\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TCP": {"ttr": 10251, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\t\\x00\\t\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "XV0006"}, "text": "//TCP      PROC DUMP=DUMMY\n//IEFPROC  EXEC PGM=STCP370,REGION=4096K TIME=1440\n//STEPLIB   DD DSN=SYS2.LOCAL.LINKLIB,DISP=SHR\n//STCPDBUG  DD DSN=SYS2.XMIT370.ASM(KBUGSTCP),DISP=SHR\n//STCPLOG   DD SYSOUT=*            TCP MAIN TASK LOG\n//OPRLOG    DD SYSOUT=*            OPERATOR INTERFACE LOG\n//SYSUDUMP  DD DDNAME=&DUMP\n//DUMMY     DD DUMMY\n//SYSOUT    DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TCPHIP": {"ttr": 10253, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00)\\x00)\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   TCPHIP ,\n.*\n.* Copyright 2002 James M. Morrison\n.*\n*----------------------------------------------------------------------\n*  IP Datagram Header - RFC 791\n*----------------------------------------------------------------------\nHIPHDR   DS    0XL20         IP v4 header (minimum length)\n*\nHIPVIHL  DS    X             version: 4 bits = 4 (IPv4)\n*                            IHL: 4 bits = # 32-bit words header length\n*\nHIPTOS   DS    X             type of service - RFC 1349\n*\nHIPTL    DS    XL2           total length (bytes): IP datagram\n*                            (IP header plus higher-level data, ex:UDP)\n*                            All hosts must support at least 576\n*\n*  Fragmentation fields: SOKIID, SOKIFFO\n*\nHIPID    DS    XL2           identifier\nHIPFFO   DS    XL2           flags, fragment offset\n*\nHIPTTL   DS    X             time to live (TTL=0: destroy datagram)\n*                            default TTL=64\n*\n*                            /usr/include/netinet/in.h\nHIPPROT  DS    X             protocol RFC-1700\n*\nHIPCKSM  DS    XL2           checksum\nHIPSADR  DS    XL4           source address\nHIPDADR  DS    XL4           destination address\nHIPOPT   DS    0F            beginning of options & padding\nL$HIPPFX EQU   *-HIP         fixed portion of IP header\n.MEX     MEXIT ,\n.DOC     ANOP\n.*---------------------------------------------------------------------\n.*  TCPHIP - TCP/IP header - IP\n.*---------------------------------------------------------------------\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TCPHTCP": {"ttr": 10255, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   TCPHTCP ,\n.*\n.* Copyright 2002 James M. Morrison\n.*\n*----------------------------------------------------------------------\n*  TCP Segment Header - RFC 793\n*----------------------------------------------------------------------\nHTC      DSECT ,\nHTCPHDR  DS    0XL??         TCP header\nHTCSPORT DS    XL2           source port\nHTCDPORT DS    XL2           destination port\nHTCSEQN  DS    XL4           sequence number\nHTCACKN  DS    XL4           acknowledgement number\nHTCOFF   DS    X             offset + reserved\nHTCFLG1  DS    X             flags\nHTCWIN   DS    XL2           window\nHTCCKSUM DS    XL2           checksum\nHTCURGPT DS    XL2           urgent pointer\nHTCOPT   DS    0F            options & padding\nL$TCPPFX EQU   *-HTCP        length of fixed portion of TCP header\n.MEX     MEXIT ,\n.DOC     ANOP\n.*---------------------------------------------------------------------\n.*  TCPHTCP - TCP/IP header - TCP\n.*---------------------------------------------------------------------\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TCPHUDP": {"ttr": 10257, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x16\\x00\\x16\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   TCPHUDP ,\n.*\n.* Copyright 2002 James M. Morrison\n.*\n*----------------------------------------------------------------------\n*  UDP Datagram Header - RFC 768\n*----------------------------------------------------------------------\nHUDP     DSECT ,\nHUDPHDR  DS    0XL8          UDP header\nHUDSPORT DS    XL2           source port\nHUDDPORT DS    XL2           destination port\nHUDLEN   DS    XL2           length\nHUDCKSUM DS    XL2           checksum (pseudo-header)\nHUDDATA  DS    0F            data follows\nL$UDPPFX EQU   *-HUDP        length of fixed portion of UDP header\n.MEX     MEXIT ,\n.DOC     ANOP\n.*---------------------------------------------------------------------\n.*  TCPHUDP - UDP header\n.*---------------------------------------------------------------------\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TCPSOK": {"ttr": 10497, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00?\\x00?\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 63, "newlines": 63, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   TCPSOK ,\n.*\n.* Copyright 2002 James M. Morrison\n.*\n*----------------------------------------------------------------------\n*  TCPSOK  - TCP/IP socket definition\n*----------------------------------------------------------------------\n*\n*  Status: dropped in mid-creation (incomplete) to check doc\n*\n*  TCPSOK is the TCP/IP anchor control block in the user's address\n*  space, and must be specified in the TCPSSTC SSOB extension of\n*  every TCP/IP subsystem request\n*\n*  TCPSOK must be allocated such that a non-APF authorized user\n*  may not modify it\n*\n*  Useful URLs:\n*  http://www.rfc-editor.org\n*  http://www.networksorcery.com/enp/protocol/ip.htm\n*\nSOK      DSECT ,             TCP/IP Socket definition\nSOKFLG1  DS    X             flag\nSOK1APF  EQU   128           user is APF authorized\n*\nSOKADRFM DS    XL2           address family\nSOKPROT  DS    XL2           protocol number\nSOKWINDW DS    H             window size\nSOKSPORT DS    XL2           port number - source\nSOKDPORT DS    XL2           port number - destination\nSOKSIPV4 DS    F             IP address  - source      (IP v4)\nSOKDIPV4 DS    F             IP address  - destination (IP v4)\nSOKMTU   DS    F             Maxmimum transmission\n*\n*  Buffer headers - everything's scattered all over the place\n*\nSOK@IHBF DS    A             IP header buffer address\nSOKLIHBF DS    F             IP header buffer length  (20 bytes)\nSOK@IHOP DS    A             IP header options address\nSOKLIHOP DS    F             IP header options length (max 40 bytes)\n*\nSOK@THBF DS    A             TCP header buffer address\nSOKLTHBF DS    F             TCP header buffer length\nSOK@THOP DS    A             TCP header options address\nSOKLTHOP DS    F             TCP header options length\nSOK@TDAT DS    A             TCP data address\nSOKLTDAT DS    F             TCP data length\n*\n         ORG   SOK@THBF      UDP overlays TCP header info\nSOK@UHBF DS    A             UDP datagram header buffer address\nSOKLUHBF DS    F             UDP datagram header buffer length\nSOK@UDAT DS    A             UDP datagram data address\nSOKLUDAT DS    F             UDP datagram data length\n         ORG   ,\n         DS    0D\nL$SOK    EQU   *-SOK         TCPSOK length\n.MEX     MEXIT ,\n.DOC     ANOP\n.*---------------------------------------------------------------------\n.*  TCPSOK - TCP/IP socket definition\n.*---------------------------------------------------------------------\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TCPSSTC": {"ttr": 10499, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00a\\x00a\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 97, "newlines": 97, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   TCPSSTC ,\n.*\n.* Copyright 2002 James M. Morrison\n.*\n*----------------------------------------------------------------------\n*  TCPSSTC - TCP/IP SSOB extension (mirrors IEFSSxx macros)\n*----------------------------------------------------------------------\n*\n*  SSOBFUNC codes for TCP/IP subsystem\n*\nSSOBTCQY EQU   1             TCP/IP Query\nSSOBTCAP EQU   2             TCP/IP Allocate Port/Protocol\nSSOBTCFP EQU   3             TCP/IP Free     Port/Protocol\nSSOBTCNT EQU   4             MVS    notify end of task\nSSOBTCSP EQU   5             TCP/IP Send    Packet\nSSOBTCRP EQU   6             TCP/IP Receive Packet\nSSOBTC07 EQU   7             TCP/IP reserved\nSSOBTCNM EQU   7             MVS    notify end of memory\nSSOBTCNW EQU   8             MVS    notify WTO\nSSOBTCNC EQU   9             MVS    notify operator command\n*\n*  SSOBRETN return codes for TCP/IP subsystem\n*\nSSTC$ROK EQU   0             OK, function completed w/o error\nSSTC$R04 EQU   4             function dependent\nSSTC$R08 EQU   8             function dependent\nSSTC$R12 EQU   12            function dependent\nSSTC$R16 EQU   16            function dependent\nSSTC$R20 EQU   20            function dependent\n*\n*  The following bits may be OR'd with the function dependent\n*  return codes to provide additional status\n*\nSSTC$RAS EQU   X'80000000'   Additional status present bits 01:07\n*                            Bit  Indicates\nSSTC$RDN EQU   64            01 - DRAIN, TCP/IP has begun draining\n*                                 service should terminate immediately\nSSTC$RWN EQU   32            02 - WARN, TCP/IP will be stopping \"soon\"\n*                                 service should wrap up ASAP\nSSTC$RUS EQU   16            03 - UnSolicited additional status\n*                                 unrelated to a subsys request\n*                                 not currently implemented\n*                                 requires SSTC@EUS ECB address\n*\nSSTCBGN  EQU   *             TCP/IP SSOB extension begins here\n*\nSSTCFLG1 DS    X             flag byte\nSSTC1SVC EQU   128           SVC issued subsys request\nSSTC1PFX EQU   64            buffer already page fixed\nSSTC1PUX EQU   32            page unfix buffer at completion\nSSTC1UAS EQU   16            0 = buffer in CSA\n*                            1 = buffer in user address space\nSSTC1BLK EQU   8             block (WAIT) for completion\n*\nSSTCFLG2 DS    XL1           reserved for flag; must be zero\nSSTCRSV1 DS    XL2           reserved; must be zero\n*\nSSTC@SOK DS    A             socket control block address (TCPSOK)\nSSTC@BUF DS    A             buffer addr\nSSTCLBUF DS    F             buffer length\nSSTC@ASC DS    A             0 or ASCB address of requester\nSSTC@ERQ DS    A             0 or ECB address for ReQuest completion\nSSTC@EUS DS    A             0 or ECB address for UnSolicited status\n*\n         DS    0F            fullword aligned\nSSTCFS   DS    XL8           function-specific data\n         DS    0D\nSSTCELEN EQU   *-SSTCBGN          TCP/IP extension length\nSSTCSLEN EQU   SSOBHSIZ+SSTCELEN  total SSOB length with TCP/IP xtn\n*\n*  Function specific data - Send and Receive\n*\n         ORG   SSTCFS\nSSTCIOFB DS    XL2           I/O feedback\n         ORG   ,\n*\n.MEX     MEXIT ,\n.DOC     ANOP\n.*---------------------------------------------------------------------\n.*  TCPSSTC - TCP/IP SSOB extension\n.*---------------------------------------------------------------------\n.*\n.*  TCPSSTC should appear immediately behind the coder's IEFJSSOB\n.*  DSECT; TCPSSTC defines fields for the TCP/IP SSOB extension\n.*\n.*  SSTC@ECB - 0 or address of ECB in user's address space\n.*             When 0, subsys function code will not WAIT for\n.*             request completion before returning to user\n.*             When not zero, subsys function code must WAIT for\n.*             request completion before returning to user\n.*  SSTC@ASC - required; address of user's ASCB\n.*             Subsys functions require for\n.*             1) User's STOR register (CR7) for MVCP/MVCS\n.*             2) Cross memory POST when function code WAITs completion\n.*---------------------------------------------------------------------\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TESTASM": {"ttr": 10502, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x13\\x00\\x13\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "XV0006"}, "text": "TESTASM  TITLE 'trial assembly'\n*\n*  Copyright 2002, James M. Morrison\n*\n         U#SET FUNC=STCP\nTESTASM  UPROC ID=TASM,L=L$SA\n         UPEND ,\n         LTORG ,\n         EJECT ,\n         DSCELL ,\n         PRINT NOGEN\n         WASTCP ,\nSAVEAREA DSECT ,\n         DS    18F\nL$SA     EQU   *-SAVEAREA\n*\n         PRINT GEN\nTESTASM  UFINI DXDTASM,L$SA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TESTVTAB": {"ttr": 10504, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00!\\x00!\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "XV0006"}, "text": "TESTVTAB TITLE 'RECV370 VCON table'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\nUTILVTAB CSECT ,                     XMITDBUG uses V(UTILVTAB)\n         USING *,0\n         USING XMTWA,11\n*----------------------------------------------------------------------\n*  CSECT table header - BXLE index, increment, limit\n*----------------------------------------------------------------------\nHEADER   DC    A(DBUGTAB,L$VTAB,DBUGEND-1)\n*----------------------------------------------------------------------\n*  CSECT table\n*----------------------------------------------------------------------\nDBUGTAB  DS    0F\n         DC    CL8'TEST370',V(TEST370),AL2(XMTD370-XMTDLEV,0)\n*\n         DC    CL8'UTILABND',V(UTILABND),AL2(XMTDABND-XMTDLEV,0)\n         DC    CL8'UTILDBUG',V(UTILDBUG),AL2(XMTDDBUG-XMTDLEV,0)\n         DC    CL8'UTILHEX',V(UTILHEX),AL2(XMTDHEX-XMTDLEV,0)\n         DC    CL8'UTILLOG',V(UTILLOG),AL2(XMTDLOG-XMTDLEV,0)\n         DC    CL8'UTILPSR',V(UTILPSR),AL2(XMTDPSR-XMTDLEV,0)\n         DC    CL8'UTILSNAP',V(UTILSNAP),AL2(XMTDSNAP-XMTDLEV,0)\n         DC    CL8'UTILSTAE',V(UTILSTAE),AL2(XMTDSTAE-XMTDLEV,0)\n         DC    CL8'UTILTIOT',V(UTILTIOT),AL2(XMTDTIOT-XMTDLEV,0)\nDBUGEND  EQU   *\n*----------------------------------------------------------------------\n*  DSECTs\n*----------------------------------------------------------------------\n         DVTAB ,                  VCON table\n         PRINT NOGEN\n         WAXMT FUNC=UTIL\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TEST370": {"ttr": 10506, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00U\\x00U\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 85, "newlines": 85, "modlines": 0, "user": "XV0006"}, "text": "TEST370  TITLE 'Prototype xxxx370'\n*\n*  Copyright 2002, James M. Morrison\n*\n*----------------------------------------------------------------------\n*  Things to do:\n*----------------------------------------------------------------------\n         U#SET ,\n*----------------------------------------------------------------------\n* Function: Test UPROC/UPEND\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         R0  =\n*         R1  =  Address of OS parmlist\n*         R13 =  savearea ptr\n*         R14 =  return addr to caller\n*         R15 =  address of TEST370\n*\n* Exit:   R15 = return code\n*         R15 = 00 success\n*\n* Abends:\n*\n* Notes:\n*----------------------------------------------------------------------\n* R2\n* R3\n* R4     OS parm ptr\n* R5\n* R6\n* R7\n* R8\n* R9\n* R10\n* R11    XMTWA    ... ALL CSECTS (contains our savearea)\n* R12    BASE REG ... ALL CSECTS (dummy for us)\n* R13    savearea\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\nTEST370  UPROC ID=MAIN,L=L$MAIN,SECT=LABEL,WA=\n*----------------------------------------------------------------------\n*  Wake up UTILLOG\n*----------------------------------------------------------------------\n         ULOG  'TEST370 00.04 Copyright 2002, James M. Morrison'\n         ULOG  'TEST370 may be distributed under the terms of the Q Pub+\n               lic License version 1.0'\n         ULOG  'TEST370 Initial Developer James M. Morrison'\n         ULOG  ' '\n*----------------------------------------------------------------------\n*  Handle UTILDBUG ddname\n*----------------------------------------------------------------------\n         UCALL UTILDBUG                     handle XMITDBUG ddname\n*----------------------------------------------------------------------\n*  Verify we're authorized\n*----------------------------------------------------------------------\n         TESTAUTH FCTN=1                    authorized?\n         LTR   R15,R15\n         BZ    AUTHOK\n         ULOG  'TEST370 requires authorization'\n         UABEND ,                           not authorized\nAUTHOK   DS    0H\n*----------------------------------------------------------------------\n*  Return to system\n*----------------------------------------------------------------------\nEXIT     DS    0H\n         SLR   R3,R3                   ID=MAIN must use RC=(reg)\n         UPEND RC=(R3)\n*\n         LTORG ,\n*\n         EJECT ,\n*----------------------------------------------------------------------\n         WAXMT FUNC=XMIT\n*\nSAVEAREA DSECT ,\n         DS    18F           dummy \"MAIN\" proc savearea\nL$MAIN   EQU   *-SAVEAREA\n*\n         PRINT GEN\nTEST370  UFINI DXDT370,L$XMTWA         reserve TGD space\nTEST370  UFINI DXDMAIN,L$MAIN          reserve TEST370 DSA space\n*\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "U#DPR": {"ttr": 10509, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   U#DPR &QLAB,&LEN\n.*\n.* Copyright 2002 James M. Morrison\n.*\n         GBLA  &G#ALIGN\n         LCLC  &TXT1,&TXT2\n.*\n         AIF   ('&LEN' EQ '0').MIA\n&TXT1    SETC  'XL(((('\n&TXT2    SETC  ')+&G#ALIGN-1)/&G#ALIGN)*&G#ALIGN)'\n&LABEL   DXD   &TXT1.&LEN.&TXT2             Pseudo-Register     (U#DPR)\n&QLAB    DC    Q(&LABEL)                    PR offset from RDSA (U#DPR)\n         MEXIT ,\n.MIA     ANOP\n&QLAB    DC    A(0)                         PR not defined      (U#DPR)\n         MEXIT ,\n.DOC     ANOP\n.*---------------------------------------------------------------------\n.* Define pseudo-register\n.* If the symbol specified by &LEN does not exist, the area has not\n.* been defined; we don't define the DXD and we define A(0) for Q-con\n.*\n.* &LABEL   - DXD label of Pseudo-Register (PR)\n.* &QLAB    - Q-con label (offset to PR)\n.* &LEN     - length of the pseudo-register\n.*            When =0, we define &LABEL DC A(0); no DXD defined\n.* &G#ALIGN - alignment boundary (U#SET)\n.*---------------------------------------------------------------------\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "U#EQU": {"ttr": 10511, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00D\\x00D\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 68, "newlines": 68, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n         U#EQU ,\n.*\n.* Copyright 2002 James M. Morrison\n.*\n         PUSH  PRINT                                              U#EQU\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\n*\nR11      EQU   11            WAxxxx; TGD; top of DSA pool\nRDAST    EQU   11            for open code usage; WADAST\nRRECV    EQU   11            for open code usage; WARECV\nRSTCP    EQU   11            for open code usage; WASTCP\nRXMIT    EQU   11            for open code usage; WAXMIT\nTGDREG   EQU   11            for open code usage\nWAREG    EQU   11            for open code usage\nRWA      EQU   11            for open code usage\nRTGD     EQU   11            for open code usage; WATGD\nRDSA     EQU   11            for open code usage; DSA pool\n*\nR12      EQU   12            program base\nBASEREG  EQU   12            for open code usage\nRBASE    EQU   12            for open code usage (preferred)\n*\nR13      EQU   13            savearea/workarea\nSAREG    EQU   13            for open code usage\nRSA      EQU   13            for open code usage (preferred)\n*\nR14      EQU   14\nR15      EQU   15\n*\n*  U370QENV parm bits - R0\n*\nQNV$PAGE EQU   64            leave TGD@PAGE allocated\nQNV$QHEP EQU   32            query Hercules emulator presence\n*\n*  U370WTO  parm bits - UWTO macro\n*\nUWTO$DSC EQU   128           descriptor code present\nUWTO$RTC EQU   64            routing    code present\n*\n*  U370VADR\n*\nL$VADRBF EQU   40            length of U370VADR output buffer\n*\n*  U370CHAR - convert char string (decimal or hex) to binary\n*\nCHAR$HEX EQU   128           hex chars allowed\n*\n*  STCPTSKM - TCP/IP Task Manager\n*\nTSKM$ADD EQU   128           add WUD to WIB\nTSKM$NEW EQU   64            subtask initialization\nTSKM$MON EQU   16            monitor subtasks\nPOST$NEW EQU   C'NEW'        TSKM NEW POST code\nPOST$WRK EQU   C'WRK'        TSKM RUN work POST code\nPOST$SHU EQU   C'SHU'        TSKM RUN shutdown subtask\n         POP   PRINT                                              U#EQU\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "U#SET": {"ttr": 10513, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00G\\x00G\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 71, "newlines": 71, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n         U#SET &DIAG=YES,&FUNC=XXXX\n.*\n.* Copyright 2001-2008 James M. Morrison\n.*\n         GBLA  &G#ALIGN\n         GBLB  &G#ASMF\n         GBLB  &G#HERC\n         GBLB  &XMTDIAG\n         GBLC  &GFUNC\n         GBLC  &XMTREGS\n         GBLC  &XMTABND\n         GBLC  &GPFXTGD\n         GBLC  &GUPROCP(8)\n         GBLC  &G#VRSN\n.*\n&G#ASMF  SETB  1                  ASMF macro operand sublist bug\n&G#HERC  SETB  1                  Hercules emulator support\n&G#ALIGN SETA  32                 storage alignment\n&GUPROCP(1) SETC '0'              U370VTAB doesn't use UPROC\n&G#VRSN  SETC  'v00.06'           all xxxx370 codes is same version\n.*\n         AIF   ('&FUNC' NE 'XXXX').WATGD\n.*\n.*  old code support\n.*\n&XMTREGS SETC  'XMTREGS'          XMTWA field for debug regs\n&XMTABND SETC  'XMTABEND'         XMTWA field for abend regs\n&GPFXTGD SETC  'XMT'              TGD fields prefix in WAXMIT\n         AGO   .CKDIAG\n.*\n.WATGD   ANOP\n&XMTREGS SETC  'TGDREGS'          TGDWA field for debug regs\n&XMTABND SETC  'TGDABEND'         TGDWA field for abend regs\n&GPFXTGD SETC  'TGD'              TGD prefix\n&GFUNC   SETC  '&FUNC'            function: DAST, XMIT, RECV, UTIL\n.*\n.CKDIAG  ANOP\n&XMTDIAG SETB  0                  disable UDIAG support\n         AIF   ('&DIAG' NE 'YES').NODIAG\n&XMTDIAG SETB  1                  enable UDIAG support\n.NODIAG  ANOP\n         MEXIT\n.*---------------------------------------------------------------------\n.*  xxxx370 Global Setup\n.*\n.*  &XMTDIAG - Enable/disable UDIAG macro\n.*             0=Disable, 1=Enable\n.*\n.*  &G#ALIGN - Storage alignment, used to make dumps mildly easier\n.*             to scan.  Minimum value 8, or SAVEAREA DSECTs\n.*             doublewords won't align properly.\n.*\n.*  &G#ASMF  - Assembler level F\n.*             1=ASMF, 0=higher level\n.*\n.*  &G#HERC  - Hercules support\n.*             0=Don't, 1=Do\n.*\n.*  &XMTREGS - Label in TGD available for diagnostic reg store\n.*\n.*  &XMTABND - Label in TGD for UABEND macro to store regs before\n.*             calling U370ABND CSECT\n.*\n.*  &GPFXTGD - TGD prefix\n.*\n.*  &GUPROCP - UPROC, UFINI, UESTAE, DSATGD, (?) ...\n.*             Additional user TGD space requested\n.*\n.*---------------------------------------------------------------------\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "U@CPD": {"ttr": 10516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00.\\x00.\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 46, "newlines": 46, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   U@CPD &USER,&REG,&WORK=R0,&SAREG=SAREG,&ERR=\n.*\n.* Copyright 2002 James M. Morrison\n.*\n         AIF   ('&ERR' EQ '').ERR1\n         AIF   ('&REG' EQ '').ERR2\n&LABEL   U@SX  &REG,WORK=&WORK              @ SX                  U@CPD\n         ICM   &REG,15,SX@CPD-SX(&REG)      @CPD                  U@CPD\n         BZ    &ERR                         br, no CPD present    U@CPD\n         USING CPD,&REG                                           U@CPD\n         AIF   ('&USER' NE '').USER\n         MEXIT\n.*\n.USER    LA    &REG,CPDUSER                 @ user portion of CPD U@CPD\n         USING &USER,&REG                                         U@CPD\n         MEXIT\n.*\n.ERR1    ANOP\n         MNOTE 8,'U@CPD - ERR= required'\n.*\n.ERR2    ANOP\n         MNOTE 8,'U@CPD - register required'\n         MNOTE *,'U@CPD - syntax: U@CPD dsect,register,WORK=workreg'\n.DOC     ANOP\n.*---------------------------------------------------------------------\n.*  U@CPD  - Return address of CPD or CPDUSER\n.*           USING provided on either CPD or &USER\n.*\n.*  Note:    not every CSECT has a CPD\n.*\n.*  &USER  - optional, name of DSECT describing area\n.*           if specified, USING will be &USER (@ CPD user area)\n.*           if omitted,   USING will be CPD   (@ CPD base)\n.*\n.*  &REG   - register to contain address\n.*\n.*  &WORK  - work register\n.*\n.*  &SAREG - default=SAREG; register pointing at SA\n.*           passed to U@SX\n.*\n.*  &ERR   - required; default=\n.*           Specifies label to branch to if no CPD\n.*---------------------------------------------------------------------\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "U@SX": {"ttr": 10518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x16\\x00\\x16\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   U@SX  &REG,&WORK=R0,&SAREG=SAREG,&USING=\n.*\n.* Copyright 2002 James M. Morrison\n.*\n&LABEL   LR    &REG,&SAREG             @ SA                        U@SX\n         LA    &WORK,L$SXPFX           SX prefix length            U@SX\n         SR    &REG,&WORK              @ SX                        U@SX\n         AIF   ('&USING' NE '').MEX\n         USING SX,&REG                                             U@SX\n.MEX     MEXIT\n.DOC     ANOP\n.*---------------------------------------------------------------------\n.*  U@SX   - Return address of SX (savearea prefix)\n.*           USING on SX will be provided\n.*\n.*  &REG   - register to contain address of SX\n.*  &WORK  - work register\n.*  &SAREG - reg pointing at savearea (U370STAE uses it)\n.*  &USING - default: generate USING; if value specified, no USING\n.*---------------------------------------------------------------------\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UABEND": {"ttr": 10754, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00+\\x00+\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 43, "newlines": 43, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   UABEND &REASON,&DUMP=N,&STEP=N,&CODE=,&SVC=13\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n.*---------------------------------------------------------------------\n.* &CODE   - ABEND code\n.* &REASON - ABEND reason code, RX address only\n.*\n.* Normal OS DUMP, STEP options are not provided.  U370ABND makes\n.* a decision on it's own, for ease in consolidating ABEND behavior.\n.*---------------------------------------------------------------------\n         GBLC  &XMTABND\n         LCLC  &NDX\n         LCLB  &A1,&A2,&B1,&B2\n         LCLA  &F1,&F2\n.*\n&NDX     SETC  '&SYSNDX'\n&LABEL   STM   R0,R15,&XMTABND         save regs before ABEND\n         AIF   ('&CODE' EQ '').CKRSN\n         IM#LALR  R1,&CODE             load abend code\n.CKRSN   AIF   ('&REASON' EQ '').NOCOD\n         ICM   R1,8,&REASON            load reason code\n.NOCOD   UCALL U370ABND                call ABEND support\n         SVC   &SVC                    U370ABND returns to ABEND here\n.*\n&A1      SETB  ('&DUMP' NE 'N')\n&A2      SETB  ('&STEP' NE 'N')\n.*\n&B1      SETB  ('&REASON' NE '')\n&B2      SETB  ('&CODE' NE '')\n.*\n&F1      SETA  (&A1*128)+(&A2*64)\n&F2      SETA  (&B1*128)+(&B2*64)\n.*\nOPT&NDX  DC    AL1(&F1,&F2)            option flags\n         MEXIT\n.DOC     ANOP\n.*---------------------------------------------------------------------\n.*  UABEND - blah, blah, blah\n.*  &SVC   - U370STAE codes SVC=3\n.*---------------------------------------------------------------------\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UCALL": {"ttr": 10756, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x18\\x00\\x18\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   UCALL &WHAT,&PLIST=,&ERR=\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n.*---------------------------------------------------------------------\n.* &WHAT  - CSECT name to call\n.* &PLIST - optional parmlist (R1)\n.* &ERR   - optional LTR of R15 after called CSECT returns\n.*\n.* Note UABEND macro depends on the BALR being last instruction gen'd.\n.*--------------------------------------------------------------------\n         AIF   (T'&LABEL EQ 'O').NOLABL\n&LABEL   DS    0H\n.NOLABL  ANOP\n         AIF   (T'&PLIST EQ 'O').NOPLST\n         IM#LALR R1,&PLIST             @ parmlist\n.NOPLST  ANOP\n         L     R15,=V(&WHAT)           load program address\n         BALR  R14,R15                 call program\n         AIF   ('&ERR' EQ '').MEND\n         LTR   R15,R15                 check return code\n         BNZ   &ERR\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UDIAG": {"ttr": 10758, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00i\\x00i\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 105, "newlines": 105, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   UDIAG &LEVEL,&TEXT,&ADDR,&LEN,&SKIP=,&REGS=NO,&PLIST=WKSNAP,  +\n               &FIN=\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n         GBLB  &XMTDIAG\n         GBLC  &XMTREGS\n         GBLC  &GPFXTGD\n         LCLA  &LDBUG,&LSTR\n         LCLC  &NDX,&PFX\n         LCLC  &DBUGBYT,&SKIPLAB\n         LCLC  &NEWTEXT,&STRING\n.*\n&PFX     SETC  '&GPFXTGD'    TGD prefix\n         AIF   (&XMTDIAG).GO\n&LABEL   IM#SECT LABEL       generate label for suppressed UDIAG\n         MEXIT\n.*\n.GO      ANOP\n&NDX     SETC  '&SYSNDX'\n&LDBUG   SETA  K'&SYSECT\n&DBUGBYT SETC  '&SYSECT'(5,&LDBUG-4)     set TGDD* byte name from CSECT\n.*\n.*  Put label for BL instruction into common format\n.*\n&SKIPLAB SETC  '&SKIP'\n         AIF   ('&SKIP' NE '').NOSTR           SKIP=label ignores &TEXT\n&SKIPLAB SETC  'SKIP&NDX'\n.*\n.*  Insert <n> into front of quoted string\n.*\n&NEWTEXT SETC  '&TEXT'\n         AIF   ('&TEXT'(1,1) NE '''').NOSTR      skip if not quoted str\n&LSTR    SETA  K'&TEXT-2                        length minus two quotes\n&STRING  SETC  '&TEXT'(2,&LSTR)                strip quotes from string\n&NEWTEXT SETC  '''<&LEVEL> &STRING'''              new text with quotes\n.NOSTR   ANOP\n.*\n.*  Generate code\n.*\n&LABEL   IM#SECT LABEL\n         AIF   ('&LEVEL' EQ '0' AND '&SKIP' NE '').MEXIT\n         AIF   ('&LEVEL' EQ '0').STM        level=0 always runs\n         CLI   &PFX.D&DBUGBYT,C'&LEVEL'     generate diag msg?\n         BL    &SKIPLAB                     no, br\n         AIF   ('&SKIP' EQ '').STM\n.MEXIT   MEXIT\n.*\n.STM     AIF   ('&REGS' EQ 'NO').CKSNAP\n         STM   R0,R15,&XMTREGS              <debug>\n.*\n.CKSNAP  AIF   ('&LEN' NE '').SNAP\n         AIF   ('&TEXT'(1,1) EQ '''').STRLOG\n         ULOG  &TEXT,&ADDR                  ULOG RX/(R),length\n         AGO   .FIN\n.STRLOG  ULOG  &NEWTEXT                     ULOG text string\n         AGO   .FIN\n.*\n.SNAP    USNAP &NEWTEXT,&ADDR,&LEN,PLIST=&PLIST\n.FIN     AIF      ('&FIN' EQ '').DONE\n         B     &FIN                         output produced, br\n.DONE    ANOP\nSKIP&NDX DS    0H\n         MEXIT\n.*---------------------------------------------------------------------\n.* &LEVEL: 0   normal non-diagnostic messages (always shown)\n.*         1   STATUS messages, entry & exit\n.*         2   CSECT-SPECIFIC trace messages\n.*     above   varies by CSECT\n.*\n.* During execution, if the proper debug level is not set in TGDWA,\n.* the U370LOG or U370SNAP calls will not be executed\n.*\n.* &TEXT - RX or quoted string message to be issued, using either\n.* calls to U370LOG or U370SNAP.  For RX specifications, see U370LOG\n.* or U370SNAP for the layout of the message (they're different).\n.* &TEXT will be displayed by U370LOG, unless &LEN is coded in which\n.* case U370SNAP will display the text.\n.* Briefly, U370LOG - RX field consists of text only.\n.* U370SNAP - RX field has one byte length prefix, or may be delimited\n.* by X'00' at the end (then no length prefix); 60 byte max text.\n.*\n.* &ADDR - U370SNAP start address\n.*         An exception - if &LEN isn't coded, assumed to be length\n.*         of non-quoted string &TEXT (ULOG issued, not USNAP)\n.*\n.* &LEN  - U370SNAP length (or stop address)\n.*\n.* REGS=NO suppresses STM of R0:R15 into &XMTREGS, code some other\n.* value to generate STM (REGS=YES, REGS=SAVE, etc.).\n.*\n.* SKIP=label causes branch to label if diagnostic level msg would\n.* not be issued; &TEXT, &ADDR, &LEN &REGS ignored when used.\n.* SKIP=label would be used to branch around code only needed for\n.* certain diag levels.\n.*\n.* FIN=label  causes branch to label after completion of UDIAG.\n.*            Handy for branching around lower-level diagnostics\n.*            immediately following higher-level diagnostics.\n.*            Helpful in filtering out lower-level diags (ex: 4)\n.*            that produce (redundant) reduced output after\n.*            higher-level diags (ex: 9).\n.*---------------------------------------------------------------------\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UESTAE": {"ttr": 10761, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00m\\x00m\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 109, "newlines": 109, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   UESTAE &RRR,&SDWA=NO,&SNAP=NO,&TERM=NO,&MF=CODE,&PFX=CPD\n.*\n.* Copyright 2002 James M. Morrison\n.*\n         GBLC  &GUPROCP(8)             UPROC\n         LCLA  &A\n         LCLC  &P\n.*\n&LABEL   IM#SECT LABEL                 conditionally generate label\n         AIF   ('&MF' EQ 'CPD').CPD    generate CPD fields\n         AIF   ('&TERM' EQ 'NO').INIT\n.*\n.*  UESTAE TERM=YES\n.*\n         LA    R0,CPDETERM             U370STAE termination call\n         AGO   .CALL\n.*\n.*  Setup CPDEFLG1 value R0(24:31)\n.*\n.INIT    AIF   ('&SDWA' EQ 'NO').CKSNAP\n&A       SETA  128                     CPDEFLG1.CPDE1SDW\n.CKSNAP  AIF   ('&SNAP' EQ 'NO').OPTFIN\n&A       SETA  &A+64                   CPDEFLG1.CPDE1SNP\n.OPTFIN  IM#LALR R0,&A                 ESTAE options\n         IM#LALR R1,&RRR               get RRR addr\n.CALL    UCALL U370STAE                call ESTAE support\n         AIF   ('&GUPROCP(3)' NE 'ESTAE').EXPLAIN\n         MEXIT ,\n.EXPLAIN PUSH  PRINT\n         PRINT ON\n*                                                              (UESTAE)\n*  CSECTs which either specify or allow UPROC CPD=N to default\n*  must not request UESTAE services; doing so will overlay\n*  either their own CPD data following here, or some poor\n*  unsuspecting CSECT's SX (almost certainly their own)\n*\n*  If you wish no additional CPD space and no ESTAE support:\n*  UPROC CPD=N\n*  That's the default, so you may omit CPD=N\n*\n*  If you wish ESTAE support but no additional CPD space:\n*  UPROC CPD=(Y,0,ESTAE)\n*\n*  If you wish additional CPD space but no ESTAE support:\n*   UPROC CPD=(Y,xxx)\n*\n*  If you wish additional CPD space and ESTAE support:\n*  UPROC CPD=(Y,xxx,ESTAE)\n*\n*  xxx is your desired CPD addition length\n*\n         POP   PRINT\n         MNOTE 8,'UESTAE - UPROC CPD ESTAE not specified, ESTAE used'\n         MNOTE 8,'UESTAE - see above explanation'\n         MEXIT\n.*\n.CPD     ANOP\n&P       SETC  '&PFX'\n*\n&P.ETERM EQU   256                UESTAE TERM=YES (R0:23)\n*\n&P.EFLG1 DS    X                  UESTAE options\n&P.E1SDW EQU   128                RRR R1 @ SDWA/0; RRR must free\n&P.E1SNP EQU   64                 U370STAE.SUPPORT: SNAP CPDE@SNP\n*\n&P.EFLG2 DS    X                  U370STAE status flags\n&P.E2RRV EQU   128                RRR present + rest of ESTAE fields\n&P.E2RRR EQU   64                 RRR called\n*\n         AIF   ('&GUPROCP(3)' EQ 'ESTAE').CPDE001\n         MEXIT\n.*\n.*  These fields are only present when ESTAE support requested\n.*\n.CPDE001 ANOP\n&P.E@RRR DS    A                  0 or @ CSECT's RRR         (U370STAE)\n&P.E#RUN DS    F                  # times RRR run            (U370STAE)\n&P.E@SNP DS    A                  CSECT's SNAP parmlist or 0 (U370STAE)\n&P.EREGS DS    13F                RRR regs - R0:R12          (U370STAE)\n*                                 R0=0 (reserved for future) (U370STAE)\n*                                 R1=0 or addr of SDWA       (U370STAE)\n         MEXIT ,\n.DOC     ANOP\n.*---------------------------------------------------------------------\n.* UESTAE is the user interface to U370STAE ESTAE support\n.* The user must request that the CPD be generated with ESTAE\n.* support (see .EXPLAIN above)\n.*\n.* &RRR    - label  - Remote Retry Routine addr\n.*\n.* &SDWA   - NO     - default; don't give RRR SDWA in R1\n.*           else   - RRR R1 @ SDWA (RRR must free)\n.*\n.* &SNAP   - NO     - default; U370STAE.SUPPORT won't SNAP CPDE@SNP\n.*         - else   - CPDE@SNP @ SNAP MF=L parmlist (user must set)\n.*\n.* &MF     - CODE   - default; generate code\n.*           CPD    - define CPD fields required for U370STAE support\n.*\n.* &TERM   - NO     - default; create/overlay ESTAE environment\n.*                    as needed, sets up RRR pointer & ESTAE options\n.*         - YES    - terminates TCB's ESTAE environment\n.*                    usually only done in ID=MAIN code\n.*\n.* &PFX    - xxx    - default=CPD; 3 char label prefix for UESTAE\n.*                    fields embedded in DSACPD\n.*---------------------------------------------------------------------\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UFINI": {"ttr": 10764, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00g\\x00g\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 103, "newlines": 103, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&CSECT   UFINI &OBS,&LSA,&ALIGN=32,&ID=,&SECT=,&OPT=0\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n         GBLC  &GUPROCP(8)                  UPROC CPD=\n         GBLC  &GUPROCI                     UPROC ID=\n         LCLC  &TSA,&TSX,&TCPD\n         LCLC  &LCPD\n.*\n         AIF   ('&SECT' EQ 'DSECT').DSECT\n         PUSH  PRINT\n         PRINT ON,GEN\n&CSECT   CSECT ,                            resume CSECT after DSECTs\n         AIF   ('&ID' EQ 'TGD').TGD\n.*\n.*  Normal CSECT's CPD & DSA\n.*  It is important that we define the SX PR immediately before\n.*  the SA PR; the SX is located by: A(SA) - L$SXPFX\n.*\n*----------------------------------------------------------------------\n*  FINIBLOK - CSECT attributes\n*----------------------------------------------------------------------\nFINIBLOK DS    0F\n&LCPD    SETC  '0'                          assume no CPD\n         AIF   ('&GUPROCP(1)' EQ 'N').FINCPD\n&LCPD    SETC  'L$CPD'                      CPD exists, has length\n.FINCPD  ANOP\n&TCPD    SETC  'XCP'.'&CSECT'(1,1).'&CSECT'(5,K'&CSECT-4)\n&TCPD    U#DPR QCPD,&LCPD                   define CPD (UPROC)\n.*\n&TSX     SETC  'XSX'.'&CSECT'(1,1).'&CSECT'(5,K'&CSECT-4)\nQDSA     DS    0F                           SX at top of DSA\n&TSX     U#DPR QSX,L$SXPFX                  define SX\n.*\n&TSA     SETC  'XSA'.'&CSECT'(1,1).'&CSECT'(5,K'&CSECT-4)\n&TSA     U#DPR QSA,&LSA                     define SA\n.*\n         DC    AL2(10+*-&CSECT)         +0C CSECT length (approximate)\n         DC    AL2(&LCPD)               +0E CPD   length\n         DC    AL2(&LSA)                +10 SA    length\nFBLSACL  DC    AL2(&LSA-(SXR0-SXBASE))  +12 SA    length to clear\n         DC    AL1(&OPT,0)              +14 CSECT options, spare\n         POP   PRINT\n         MEXIT\n.*\n.DSECT   ANOP\nFINBLOK  DSECT ,             UFINI FINIBLOK\nFINQCPD  DS    F       +00   CSECT's CPD offset (0=no CPD)\nFINQSX   DS    F       +04   CSECT's SX  offset\nFINQSA   DS    F       +08   CSECT's SA  offset\nFINLCS   DS    H       +0C   CSECT's length (approximate)\nFINLCPD  DS    H       +0E   CSECT's CPD length\nFINLSA   DS    H       +10   CSECT's SA  length\nFINLSACL DS    H       +12   CSECT's SA  length to clear\nFINOPT1  DS    X       +14   CSECT's options\n         DS    X       +15   spare\n         DS    0D\nL$FIN    EQU   *-FINBLOK     FINBLOK length\n         MEXIT ,\n.*\n.*  TGD - Task Global Data - Must be first PR defined in ID=MAIN\n.*        ID=MAIN must be first object deck LKED encounters\n.*\n.TGD     ANOP\n*\n*  Note: it is important that the first DXD which LKED encounters\n*  be the TGD, so that it assigns offset zero to the TGD.\n*  UPROC ID=MAIN verifies the TGD's offset = 0, ABENDs if not\n*\nXTGD     U#DPR QTGD,&LSA\nLDSAPOOL CXD   ,    Length of DSA pool calculated by LKED         UFINI\n*                   (sum of Q-con lengths)                        UFINI\n         POP   PRINT\n         MEXIT\n.DOC     ANOP\n.*---------------------------------------------------------------------\n.* Define pseudo-register & Q-con(s) for our DSA\n.* If the CSECT's UPROC specified non-zero TGD length, define a\n.* QCON which references the TGD\n.*\n.* &CSECT - CSECT name to which this pseudo-register applies\n.*\n.* &OBS   - obsolete, ignored (DXD name manufactured)\n.*          used to be the DXD label\n.*\n.* &ID    - TGD - defines TGD PR (only UPROC ID=MAIN should use)\n.*              - defines normal PR\n.*\n.* &LSA   - length of the SA pseudo-register (excludes SX prefix)\n.*\n.*          - For a DSA, excludes SX prefix length; the actual\n.*            length will contain room for SX prefix\n.*\n.*          - UFINI internally generates a CPD for each CSECT;\n.*            the CPD length (L$CPD) is calculated in DSATGD\n.*            (currently based on UPROC CPD specification)\n.*\n.* &SECT  - null  - generate code\n.*          DSECT - generate DSECT\n.*\n.*---------------------------------------------------------------------\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ULOCK": {"ttr": 10767, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   ULOCK &NEW,&LOCK,&OLD=R0,&BUSY=,&HOLD=\n.*\n.* Copyright 2002 James M. Morrison\n.*\n&LABEL   SLR   &OLD,&OLD          clear reg                       ULOCK\n         CS    &OLD,&NEW,&LOCK    OLD,NEW,LOCK check/set LOCK     ULOCK\n.*\n.* BE   CC=0   before CS: LOCK    zero      after CS: NEW -> LOCK\n.* BNE  CC=1   before CS: LOCK nonzero      after CS: OLD <- LOCK\n.*\n         AIF   ('&BUSY' EQ '').HOLD\n         BNE   &BUSY         br, LOCK was busy; OLD contains LOCK ULOCK\n.HOLD    AIF   ('&HOLD' EQ '').MEX\n         BE    &BUSY         br, LOCK now held; LOCK contains NEW ULOCK\n.MEX     MEXIT\n.DOC     ANOP\n.*---------------------------------------------------------------------\n.*  ULOCK  - If lock free (=0) seize lock, branch on outcome\n.*           See generated comments for operation\n.*\n.*  &NEW   - register that will be stored in lockword if lock free\n.*  &LOCK  - lockword - RX address; when free lock = x'00'\n.*  &OLD   - register that contains lock contents if lock busy\n.*  &BUSY  - optional, branch label if lock was busy (still busy)\n.*  &HOLD  - optional, branch label if lock was free (now held)\n.*---------------------------------------------------------------------\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ULOG": {"ttr": 10769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00$\\x00$\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   ULOG &TEXT,&LENGTH,&TERM=NO\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n.*---------------------------------------------------------------------\n.* &TEXT   - RX or quoted string.  RX fields consists of text only.\n.* &LENGTH - optional, only needed to specify length if it can't\n.*           be determined by the L' length attribute\n.* &TERM   - YES closes xxxxLOG ddname\n.*---------------------------------------------------------------------\n         LCLC  &NDX\n&NDX     SETC  '&SYSNDX'\n.*\n         AIF   ('&TERM' NE 'YES').CKSTR\n         SLR   R1,R1                   TERM=YES, close LOG ddname\n         UCALL U370LOG                 call U370LOG\n         MEXIT ,\n.*\n.CKSTR   AIF   ('&TEXT'(1,1) EQ '''').STRING\n.*\n&LABEL   IM#LALR R1,&TEXT                        message text\n         AIF   ('&LENGTH' EQ '').LENATTR\n         IM#LALR R0,&LENGTH                      length of text\n         AGO   .CALL\n.*\n.LENATTR LA    R0,L'&TEXT                        length of text\n         AGO   .CALL\n.*\n.STRING  ANOP\n&LABEL   BAL   R1,CODE&NDX                       skip msg, r1 @ msg txt\nMSG&NDX  DC    C&TEXT\nCODE&NDX LA    R0,L'MSG&NDX                              message length\n.*\n.CALL    UCALL U370LOG                                      log message\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UMOVE": {"ttr": 10771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\xe2\\x00\\xe2\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 226, "newlines": 226, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   UMOVE ,\n.*---------------------------------------------------------------------\n.* Copyright 2002 James M. Morrison\n.* See .DOC for documentation\n.*---------------------------------------------------------------------\n         LCLC  &NDX\n&NDX     SETC  '&SYSNDX'\n&LABEL   IM#SECT LABEL                 conditionally generate label\n         MEXIT\n.DOC     ANOP\n.*---------------------------------------------------------------------\n.*  UMOVE  - Build parmlist for U370MOVE\n.*\n.*  U370MOVE calling conventions:\n.*\n.*  Entry:   R0 = reserved; must be zero\n.*           R1 = address of parmlist\n.*\n.*  Exit:    R15 = return code\n.*\n.*           00  = success\n.*                 R0 = length of buffer consumed\n.*                 R1 = address of buffer\n.*\n.*           08  = truncation occurred; output buffer incomplete\n.*                 R0 = zero\n.*                 R1 = zero\n.*\n.*  Given a UMOVE parmlist, U370MOVE will construct an output buffer\n.*  according to parmlist specifications.\n.*\n.*  The parameter list is composed of Opcodes, and their associated\n.*  Operands.\n.*\n.*  Conceptually, U370MOVE is the \"machine\" which executes the\n.*  parmlist \"program\".\n.*\n.*\n.*  The parameters to UMOVE are specified via &SYSLST\n.*  Each &SYSLST operand may take the following forms:\n.*\n.*       'string'       Literal string (EBCDIC, assembler DC)\n.*\n.*       (sublist)      Operand sublist; first sublist operand\n.*                      specifies Type\n.*\n.*  Types are divided into the following classes:\n.*\n.*       STG   Storage reference; storage outside parmlist\n.*\n.*       LIT   Literal reference; storage follows opcode or operands\n.*\n.*       REG   Register contents; refers to register contents rather\n.*             than storage\n.*\n.*       OPT   Option specification; no storage referenced\n.*\n.*       JUMP  Continue parmlist at non-consecutive location\n.*\n.*       FINI  Terminate parmlist\n.*\n.*  The following default format conversions apply to each type:\n.*\n.*             STG   Do not convert to EBCDIC\n.*             LIT   Do not convert to EBCDIC\n.*             REG   Do     convert to EBCDIC\n.*\n.*  Below, the full type is specified; throughout UMOVE, only the\n.*  first character is necessary to identify the class.\n.*  The dash (-) is optional.\n.*\n.*  The Opcode and Operands field show the generated fields.\n.*  Opcode is given in bits.\n.*\n.*  S(Bddd)  represents an S-con; B=Base reg; ddd=displacement\n.*  ALn(x)   represents an A-con; n is the A-con's length\n.*  Register specifications below should not usually be R14-R1,\n.*           which U370MOVE uses during its calling sequence\n.*  B=0      in STG class, implies PSA        reference\n.*  B=1      in STG class, implies dictionary reference\n.*  Default  dictionary is pointed to by TGD@DICT\n.*  Default  register contents are contained in savearea pointed\n.*           to by U370MOVE's caller's R13\n.*  Default  output buffer is provided by U370MOVE, and 1024 bytes\n.*  Lengths  specified as register contents are assumed to be the\n.*           full 32-bit register contents (MVCLE lengths), for\n.*           upwards compatibility with later MVS versions; using\n.*           MVCL lengths has no value, since padding ever occurs.\n.*\n.*  -------------------------------------------------------------------\n.*  ONLY THE FUNCTIONS MARKED \".*Y\" ARE CURRENTLY IMPLEMENTED\n.*  -------------------------------------------------------------------\n.*\n.*  Supported/planned sublist types, and their associated operands are:\n.*\n.*  Type       Opcode     Operands            Notes\n.*  --------   ---------- ------------------- -------------------------\n.*\n.*  STG-LS     0000 L-1   S(Bddd)             L  = length\n.*                                        ---\n.*  STG-SAL    0001 0000  S(Bddd)             +00(4) = address\n.*                                            +04(4) = length\n.*\n.*  STG-LLS    0001 LL    ALn(L),S(Bddd)      LL = length of length\n.*                                            L  = length\n.*                                        ---\n.*  STG-RLS    0010 Rlen  S(Bddd)             Rlen  = length  reg\n.*                                        ---\n.*  STG-ALP    0011 Rpair                     Register pair\n.*                                            Rpair in range (R0-R14)\n.*                                            Rpair need not be even\n.*                                            Rpair+0 = address reg\n.*                                            Rpair+1 = length  reg\n.*                                            Register wrapping is not\n.*                                            supported\n.*\n.*  STG-ARLR   0011 1111  Raddr,Rlen          Raddr = address reg\n.*                                            Rlen  = length  reg\n.*\n.*             ------------------------------\n.*\n.*  LIT-L      0100 L     Literal             L = length\n.*                                        ---\n.*  LIT-LL     0101 LL    ALn(L) Literal      LL = length of length\n.*                                            L  = length\n.*                                        ---\n.*  LIT-PRB    0110 0000  (0000,Rdup),Byte    Rdup = length to pad\n.*                                            (0000,Rdup) is one byte\n.*\n.*  LIT-PLLB   0110 0000  (1000,LL),ALn(L),Byte\n.*                                            LL = length of length\n.*                                            L  = length of pad\n.*\n.*  LIT-PLB    0110 L     Byte                L = length to pad\n.*                                        ---\n.*             0111 ....                      extended opcodes\n.*\n.*             ------------------------------\n.*\n.*  REG-R      1000 R                         R = register\n.*                                        ---\n.*  REG-RR     1001 zzzz  Ra:Rb               register range\n.*                                            Ra = first register\n.*                                            Rb = last  register\n.*                                            Register wrapping is not\n.*                                            currently supported\n.*                                        ---\n.*  REG-MR     1010 zzzz  MASK,R              STCM mask, register\n.*                                        ---\n.*             1011 ....                      extended opcodes\n.*\n.*             ------------------------------\n.*\n.*  OPT-DS     1100 0000  S(Bddd)             Dictionary address\n.*                                            B may not be R1\n.*\n.*             1100 0001                      unassigned\n.*\n.*  OPT-DR     1100 Rdict                     Dictionary reg\n.*                                            Rdict may not be R14-R1\n.*\n.*             1100 1110                      unassigned\n.*\n.*             1100 1111                      unassigned\n.*                                        ---\n.*             1101 0000                      unassigned\n.*\n.*  OPT-GBL    1101 nnnn  ALn(gggg)           Global options\n.*                                            nnnn = length\n.*                                        ---\n.*  OPT-S0F    1110 0000  S(Bddd)             Reg sequence R0:R15\n.*\n.*             1110 0001                      unassigned\n.*\n.*  OPT-RSA    1100 Rsa                       Regs from savearea\n.*                                            pointed to by Rsa\n.*                                            Rsa may not be R14-R1\n.*\n.*             1110 1110                      unassigned\n.*\n.*             1110 1111                      unassigned\n.*                                        ---\n.*             1111 0000                      unassigned\n.*\n.*  OPT-BL2S   1111 0001  AL2(L),S(Bddd)      Output buffer\n.*                                            L = buffer length\n.*\n.*  OPT-BP     1111 Rbuf                      Output buffer pair\n.*                                            Rbuf+0 = address\n.*                                            Rbuf+0 may not be R14-R1\n.*                                            Rbuf+1 = length\n.*\n.*  OPT-BL4S   1111 1110  AL4(L),S(Bddd)      Output buffer\n.*                                            L = buffer length\n.*\n.*             1111 1111                      unassigned\n.*\n.*             ------------------------------\n.*\n.*             0111 ....                      extended opcodes\n.*             1011 ....                      extended opcodes\n.*\n.*  JUMP       0111 0000  S(Bddd)             Parmlist jump\n.*\n.*  FINI       0111 1111                      Terminate parmlist\n.*\n.*             ------------------------------\n.*\n.*  zzzz       No options currently defined\n.*\n.*  gggg       No global options currently defined\n.*\n.*\n.*\n.*\n.*\n.*\n.*\n.*\n.*\n.*\n.*\n.*\n.*---------------------------------------------------------------------\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UPEND": {"ttr": 11013, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00=\\x00=\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 61, "newlines": 61, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   UPEND &R0=RESTORE,&R1=RESTORE,&RC=,&DIE=,&FREE=,              +\n               &ABEND=(370,DUMP),&PATCH=8\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n         GBLC  &GUPROCI           ID= (UPROC)\n.*\n&LABEL   IM#SECT LABEL            conditionally generate label\n         AIF   ('&GUPROCI' NE 'MAIN').NORMAL\n*----------------------------------------------------------------------\n*  Terminate xxxx370 application (ID=MAIN)\n*----------------------------------------------------------------------\n         UCALL U370AP99                application termination\n*                                      U370AP99 doesn't return to us\n         MEXIT ,\n.*\n.NORMAL  AIF   ('&RC' EQ '').HVRC\n         AIF   ('&RC' EQ '0').RC0\n         IM#LALR R15,&RC               set return code\n         AGO   .HVRC\n.*\n.RC0     SLR   R15,R15                 return code zero\n.HVRC    L     R13,4(,R13)             R13 @ caller's SA\n.NOR13   L     R14,12(,R13)            restore return addr\n         AIF   ('&R1' NE 'RESTORE').NOR1\n         AIF   ('&R0' NE 'RESTORE').NOR0\n         LM    R0,R12,20(R13)          restore caller's regs (NOT R15)\n         AGO   .XC\n.*\n.NOR0    LM    R1,R12,24(R13)        restore caller's regs (NOT R0,R15)\n         AGO   .XC\n.*\n.*\n.NOR1    AIF   ('&R0' NE 'RESTORE').R2\n         L     R0,20(R13)              restore caller's regs\n         LM    R2,R12,28(R13)          EXCEPT R1, R15\n         AGO   .XC\n.*\n.R2      LM    R2,R12,28(R13)     restore caller's regs (NOT R15,R0,R1)\n.*\n.XC      XC    8(4,R13),8(R13)      erase caller's forward SA ptr to us\n         AIF   ('&DIE' EQ '').BR14\n*\n         ABEND &ABEND(1),&ABEND(2),&ABEND(3)        <debug> DIE\n         AGO   .SKIPRET\n.BR14    BR    R14                     return to caller\n.SKIPRET ANOP\n*\n         PUSH  PRINT\n         PRINT DATA\nPATCH    DC    &PATCH.S(*)             PATCH AREA <zap>\n         POP   PRINT\n.*---------------------------------------------------------------------\n.*  xxxx370 exit linkage\n.*  R15 is never restored\n.*\n.*  Special support for UPROC ID=MAIN\n.*  See UPROC for further details\n.*---------------------------------------------------------------------\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UPRLOC": {"ttr": 11015, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x10\\x00\\x10\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   UPRLOC &QCON,&REG\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n&LABEL   L     &REG,&QCON              PR offset\n         AR    &REG,RDSA               @ PR\n         MEXIT\n.DOC     ANOP\n.*---------------------------------------------------------------------\n.*  UPRLOC - Locate Pseudo-Register\n.*\n.*  &QCON  - UFINI QCON label\n.*  &REG   - register to contain address of PR\n.*---------------------------------------------------------------------\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UPROC": {"ttr": 11017, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x01G\\x01G\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 327, "newlines": 327, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&NAME    UPROC &L=(19*4),&ID=NONE,&WA=SAVEAREA,&INIT=XC,&CPD=(N,0),    +\n               &ENTRY=R15\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n         GBLA  &G#ALIGN\n         GBLC  &GFUNC\n         GBLC  &GUPROCI            ID= passed to UPEND, UFINI\n         GBLC  &GWATGD\n         GBLC  &GUPROCP(8)         CSECT-specific task persistent data\n.*                                 CPD(1) = CPD addition length\n.*                                 CPD(2) = null or ESTAE\n         LCLC  &EYE\n         LCLC  &TDXD,&XCO,&XCL\n         LCLA  &ALIGN,&XCN\n.*\n&ALIGN   SETA  &G#ALIGN            storage alignment\n&EYE     SETC  '&NAME'(1,4).'DSA'  XMITDSA/RECVDSA/DASTDSA\n&GUPROCI SETC  '&ID'               tell UPEND ID=\n&GUPROCP(1) SETC '&CPD(1)'         tell DSACPD\n&GUPROCP(2) SETC '&CPD(2)'         tell DSACPD\n&GUPROCP(3) SETC '&CPD(3)'         tell DSACPD\n.*\n         PUSH  PRINT                                              UPROC\n         AIF   ('&ID' EQ 'MAIN').DSAEX\n         PRINT OFF                 see xxxx370 (ID=MAIN)          UPROC\n.DSAEX   DSAEX ,                   SX, SA, EQUs\n         DSACPD ,                  CSECT Persistent Data\n*----------------------------------------------------------------------\n&NAME    CSECT ,\n*\n         EJECT ,\n         POP   PRINT                                              UPROC\n&NAME    CSECT ,\n         USING *,&ENTRY\n         B     PASTID\nPROCHDR  DS    0F\n         DC    AL1(IDX-ID)\nID       DC    CL8'&NAME'              CSECT name\n         DC    CL8'&SYSDATE'           assembly date MM/DD/YY\n         DC    CL7' &SYSTIME'          assembly time HH.MM\nIDX      EQU   *\n         AIF   ('&INIT' NE 'NONE').PROCFN\nPASTID   DS    0H\n         MEXIT ,\n.PROCFN  ANOP\n*\nPROC@FIN DC    A(FINIBLOK)             @ UFINI - FINIBLOK\nL$PROCHD EQU   *-PROCHDR               length of UPROC header\n*\nPASTID   STM   R14,R12,SXR14-SXBASE(R13)    save caller's regs\n         LR    R12,R15\n         USING &NAME,R12          BASE REGISTER ... ALL CSECTS\n         DROP  R15\n.*\n         AIF   ('&ID' NE 'MAIN').NORMAL\n*----------------------------------------------------------------------\n*  ID=MAIN - Allocate DSA pool storage, initialize TGD\n*----------------------------------------------------------------------\n.*\n.* R8    MAIN - length of entire DSA stack (pool)\n.* R10   MAIN - TGDSA1\n.* R11   base reg - TGD\n.* R12   base reg - CSECT\n.* R13   base reg - SA\n.* R14   scratch\n.*\n         ICM   R0,15,QTGD              verify TGD's offset = 0\n         BZ    TGDOFFOK\n*\n*  Installation error, check Linkage Editor object deck sequencing;\n*  TGD offset must be ZERO\n*\n         WTO   '&NAME UPROC install error'\n         ABEND 99                      installation error, check LKED\n*\nTGDOFFOK DS    0H\n         L     R8,LDSAPOOL             length of DSA pool\n         LA    R8,4095(,R8)               round to\n         SRL   R8,12                        next\n         SLL   R8,12                      page boundary\n*\n*  Allocate DSA pool storage, set to x'00'\n*\n         GETMAIN RU,LV=(R8),BNDRY=PAGE alloc DSA pool storage\n         LR    R11,R1\n         UZERO (R11),(R8)              clear storage to x'00'\n         USING &GFUNC.WA,R11           TGD at begin of DSA pool\n*\n*  Initialize TGD\n*\n         MVC   TGDEYE,=CL8'&EYE'                 TGD eyecatcher\n         ST    R8,TGDLDSA                        DSA pool length\n         MVC   TGDUPFX+(SXID-SX)(L'SXID),ID      TGDSA1 SX ID\n*\n*  Link SA1 into savearea chain\n*\n         LA    R10,TGDSA1              xxxx370's 1st SA\n         ST    R10,8(,R13)             forward ptr to SA1\n         ST    R13,4+TGDSA1            backward ptr to system's SA\n         LM    R0,R1,SXR0-SXBASE(R13) restore caller's parm reg\n         ST    R1,TGD@PARM             save entry R1\n         LR    R13,R10                 ready for normal UPROC now\n*\n*  Initialize DSA pool - AP00 won't modify R0,R1\n*\n         UCALL U370AP00                xxxx370 appl startup\n*----------------------------------------------------------------------\n*  Resume normal entry linkage, setup ID=MAIN DSA\n*----------------------------------------------------------------------\n.NORMAL  USING &GFUNC.WA,R11      ALWAYS\n         AIF   ('&INIT(1)' EQ 'XC').XC\n         AIF   ('&INIT' EQ 'MVCL').MVCL\n         AIF   ('&INIT' EQ 'MIN').MIN\n         AIF   ('&INIT' EQ 'CUST').CUST\n         MNOTE 8,'UPROC - unrecognized INIT value'\n         MEXIT ,\n.*---------------------------------------------------------------------\n.*  CUSTOM     SA initialization - SA cleared, standard SA linkage\n.*  U370AP00 sets up SX to support this; useful another day for\n.*  for such things as tracing, timing, ...\n.*  Probably should be used in conjunction with U#SET; modify UPROC\n.*  to override caller's UPROC specification\n.*---------------------------------------------------------------------\n.CUST    L     R3,QSX                  DSA pool offset to SX\n         AR    R3,RDSA                 R3 @ SX\n         L     R5,SX@INIT-SX(,R3)      U370AP00 set @ DSA init routine\n         BALR  R4,R5                   initialize DSA\n         AGO   .WA\n.*---------------------------------------------------------------------\n.*  XC         SA initialization - SA cleared, standard SA linkage\n.*---------------------------------------------------------------------\n.XC      L     R3,QSA                  DSA pool offset to SA\n         AR    R3,RDSA                 @ our SA\n&XCO     SETC  '(SXR0-SXBASE)'         length string\n&XCL     SETC  '(&L-(SXR0-SXBASE))'    offset string\n         AIF   (N'&INIT EQ 1).XCLAST\n.XCLOOP  ANOP\n&XCO     SETC  '(&XCN*256)+(SXR0-SXBASE)'        offset string\n&XCL     SETC  '(&L-(&XCN*256))-(SXR0-SXBASE)'   length string\n         AIF   (&XCN+1 EQ &INIT(2)).XCLAST\n         XC    &XCO.(256,R3),&XCO.(R3)\n&XCN     SETA  &XCN+1\n         AGO   .XCLOOP\n.XCLAST  XC    &XCO.(&XCL,R3),&XCO.(R3)\n         ST    R3,SX@FWD-SXBASE(,R13)  caller's forward ptr @ our SA\n         ST    R13,SX@BACK-SXBASE(,R3) our backward ptr @ caller's SA\n         LR    R13,R3                  R13 @ our SA\n         AGO   .WA\n.*---------------------------------------------------------------------\n.*  MVCL       SA initialization - SA cleared, standard SA linkage\n.*---------------------------------------------------------------------\n.MVCL    L     R3,QSA                  DSA pool offset to SA\n         AR    R3,RDSA                 @ our SA\n         LA    R14,SXR0-SXBASE(,R3)    1st field to clear\n         LH    R15,FBLSACL             length to clear\n         SLR   R9,R9                   MVCL source length\n         MVCL  R14,R8                  clear selected portion of SA\n         ST    R3,SX@FWD-SXBASE(,R13)  caller's forward ptr @ our SA\n         ST    R13,SX@BACK-SXBASE(,R3) our backward ptr @ caller's SA\n         LR    R13,R3                  R13 @ our SA\n         AGO   .WA\n.*---------------------------------------------------------------------\n.*  MIN        SA initialization - SA not cleared, standard SA linkage\n.*---------------------------------------------------------------------\n.MIN     L     R3,QSA                  DSA pool offset to SA\n         AR    R3,RDSA                 @ our SA\n         ST    R3,SX@FWD-SXBASE(,R13)  caller's forward ptr @ our SA\n         ST    R13,SX@BACK-SXBASE(,R3) our backward ptr @ caller's SA\n         LR    R13,R3                  R13 @ our SA\n.*\n.WA      AIF   ('&WA' EQ '').DONE\n         USING &WA,R13            SAVEAREA AND WORKAREA\n.DONE    EJECT ,\n         MEXIT\n.DOC     ANOP\n.*---------------------------------------------------------------------\n.*  Entry procedure for xxxx370 code\n.*\n.*  Allocates Extended Savearea (DSA - see DSAEX DSECT), sets up\n.*  registers for CSECT (see Standard xxxx370 Register Conventions)\n.*\n.*  Terminology:\n.*\n.*      SA        - Standard MVS 18-word savearea, plus whatever\n.*                  extra stuff the CSECT wants for a workarea\n.*                  Each CSECT has a SA\n.*\n.*      SX        - Savearea extension; precedes SA\n.*                  Has two eye-catchers (CSECT name), which is\n.*                  helpful in identifying SAs in a dump\n.*                  Each CSECT has a SX\n.*\n.*      CPD       - CSECT's Task Persistent Data - DSACPD\n.*                  UESTAE macro support, plus whatever the CSECT\n.*                  wishes to be preserved across calls (if anything)\n.*                  Each CSECT has a CPD; it's length varies\n.*\n.*      DSA       - SX + SA\n.*\n.*      DSA pool  - DSA stack, plus room for TGD and CPDs\n.*                  equivalent to UPROC GETMAIN\n.*\n.*      DSA stack - SA + SX stack only\n.*\n.*  Operands:\n.*\n.*      WA       - Label of CSECT's workarea DSECT (SA)\n.*                 UPROC clears this workarea to x'00'\n.*                 and establishes an SX in front of it\n.*\n.*      L        - length of workarea DSECT\n.*                 (not including the SX prefix length)\n.*\n.*      ID       - 4 character CSECT identifier\n.*                 ID=MAIN (xxxx370) causes special initialization\n.*\n.*      INIT     - Controls SA linkage and if/how SA cleared\n.*                 The default is XC\n.*\n.*                 XC   - normal  entry conventions, SA cleared\n.*                        SA will be cleared using XC instructions\n.*                        (XC,n) will generate n XCs\n.*\n.*                 MVCL - normal  entry conventions, SA cleared\n.*                        SA will be cleared using MVCL instruction\n.*\n.*                 CUST - normal  entry conventions, SA cleared\n.*                        calls customized DSA init routines\n.*                        set up by U370AP00 which select XC or MVCL\n.*                        as dictated by SA length\n.*\n.*                 MIN  - minimal entry conventions, SA not cleared\n.*                        The SA is located & caller's SA linked\n.*\n.*      CPD(1)   - CPD present - Y or N\n.*\n.*      CPD(2)   - Length of user's CPD additions\n.*\n.*      CPD(3)   - null or ESTAE\n.*                 If ESTAE, space for ESTAE support will be\n.*                 provided at the beginning of the user's CPD\n.*\n.*      ENTRY    - register number pointing at beginning of CSECT\n.*                 when it is first called; default R15\n.*                 SVCs specify R6\n.*\n.*  Standard xxxx370 Register Conventions must be observed in order\n.*  for UPROC to process normally:\n.*\n.*      R11  @ TGD - Task Global Data (unique per TCB)\n.*                   See WATGD macro\n.*                   The TGD is embedded at the front of WAxxxx.\n.*\n.*      R12  @ caller's UPROC expansion (R12 is CSECT basereg)\n.*\n.*      R13  @ caller's SA, as set up by UPROC\n.*\n.*      R14  @ caller's return address\n.*\n.*      R15  @ called CSECT's UPROC expansion\n.*\n.*  Upon completion of UPROC, only R0-R2 may be considered valid.\n.*  Other register contents must be retrieved from the caller's SA\n.*\n.*  When ID=MAIN is coded in xxxx370 CSECT, UPROC establishes the\n.*  above register conventions, as well as allocating the DSA pool,\n.*  initializing important parts of the TGD, and establishing the\n.*  initial DSAs for xxxx370.\n.*\n.*  UPROC does not help establish multiple base regs, small is\n.*  (usually) beautiful when it comes to CSECTs\n.*\n.*  Corequisites:\n.*\n.*      UPEND macro  - returns control to caller, generates patch area.\n.*                     For ID=MAIN CSECT, FREEMAINs DSA pool.\n.*\n.*      WAxxxx macro - needed for UPROC expansion (contains TGD)\n.*\n.*      UFINI macro  - place at end of CSECT, generates the CSECT's\n.*                     workarea pseudo-register.  For G#DSAM=QCON,\n.*                     also generates the related Q-con.\n.*\n.*\n.*  Internals notes\n.*  ---------------\n.*\n.*  SX is immediately followed by SA, and is allocated from the\n.*  DSA stack created by xxxx370.  The first SA used within\n.*  xxxx370 is TGDSA1, allocated to the ID=MAIN CSECT\n.*\n.*  UPROC verifies that the offset to the TGD pseudo-register\n.*  is zero; if it's not, R11 would be hosed and the application\n.*  falls down.  Making sure that the TGD pseudo-register offset\n.*  is zero should be accomplished by including the xxxx370 CSECT\n.*  as the first object deck in the linkage editor's input.\n.*\n.*  From a savearea chain perspective, the TGD is merely another SA.\n.*  TGDSA1 is the 2nd savearea when chasing the savearea chain\n.*  from TCBFSAB.  The 1st savearea from TCBFSAB is the savearea the\n.*  system provided to xxxx370.  All this presumes xxxx370 is the\n.*  first program called in our TCB, which is true in batch or if\n.*  xxxx370 has been ATTACHed.\n.*\n.*  Our recovery scheme requires that UPEND clear the caller's forward\n.*  savearea pointer upon return of the current CSECT, so U370STAE\n.*  can identify the current (ABENDing) CSECT by running the SA chain\n.*  starting at TCBFSAB.\n.*\n.*  Currently there is some minimal CPD overhead for ESTAE even\n.*  when ESTAE support is not provided.  Makes life simpler\n.*  in U370STAE\n.*\n.*  Dependencies: The following CSECTs are highly dependent upon\n.*  the implementation of UPROC:\n.*\n.*      U370AP00 - numerous\n.*      U370STAE - numerous, including secondary DSA\n.*      U370ABND - erases callers' forward SA pointer\n.*\n.*  For details on public globals used, see U#SET macro.\n.*  Some macros may also set \"private\" globals....\n.*\n.*---------------------------------------------------------------------\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UPSR": {"ttr": 11265, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x004\\x004\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   UPSR &LEVEL,&TEXT,&VALUE,&SKIP=\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n         GBLC  &GPFXTGD                     TGD prefix\n         LCLA  &LDBUG,&LSTR\n         LCLC  &NDX\n         LCLC  &DBUGBYT\n         LCLC  &NEWTEXT,&STRING\n&NDX     SETC  '&SYSNDX'\n&LDBUG   SETA  K'&SYSECT\n&DBUGBYT SETC  '&SYSECT'(5,&LDBUG-4)   set TGDD* byte name from CSECT\n&LABEL   IM#SECT LABEL\n         AIF   ('&LEVEL' EQ '0').GEN2       level=0 always runs\n         CLI   &GPFXTGD.D&DBUGBYT,C'&LEVEL' generate diag msg?\n         AIF   ('&SKIP' EQ '').GEN\n         BL    &SKIP                        no, br\n         MEXIT\n.GEN     ANOP\n         BL    SKIP&NDX                     no, br\n.GEN2    AIF   ('&VALUE' EQ '').NOVAL\n         IM#LALR R0,&VALUE\n.NOVAL   ANOP\n.*\n.*  &TEXT     'STRING' will generate correct call to XMITPSR.\n.*    OR      RX-TYPE address or (reg) for buffer address\n.*\n.*  APPEND TRAILING % sign to denote R0 inclusion.\n.*\n         AIF   ('&TEXT'(1,1) EQ '''').STRING  1st char = '?\n         IM#LALR R1,&TEXT              message address\n         UCALL U370PSR                 log msg w/ R0 in hex appended\n         AGO   .SKIP\n*\n.STRING  ANOP\n         BAL   R1,CALL&NDX             skip inline message text\n         DC    C'<&LEVEL> ',C&TEXT,C' %'\nCALL&NDX UCALL U370PSR                 log msg w/ R0 in hex appended\n.SKIP    ANOP\nSKIP&NDX DS    0H\n         MEXIT\n.*---------------------------------------------------------------------\n.*\n.* LEVEL - see UDIAG macro\n.* TEXT  - message to be displayed (string or RX-expression)\n.*         For string, we insert <n> into string\n.*         RX-expressions are on their own\n.* VALUE - register to load into R0 before call to U370PSR\n.*\n.*---------------------------------------------------------------------\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UQENV": {"ttr": 11267, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   UQENV &OPT\n.*\n.* Copyright 2002 James M. Morrison\n.*\n.*---------------------------------------------------------------------\n.* &OPT     - QNV$* equates (may be added together)\n.*            See WATGD for definitions\n.*            optional\n.*\n.* QNV$* equates:\n.* QNV$SUPR - return to caller in supervisor state (if APF authorized)\n.* QNV$PAGE - if a 4K page is allocated, leave TGD@PAGE pointing\n.*            at the page (don't FREEMAIN)\n.* QNV$NHEP - disregard whether Hercules is present or not\n.*---------------------------------------------------------------------\n         GBLC  &GUPROCI                UPROC ID=\n&LABEL   IM#SECT LABEL                 conditionally generate label\n         SLR   R0,R0\n         AIF   ('&OPT' EQ '').CALL\n         ICM   R0,8,=AL1(&OPT)         set U370QENV options\n.CALL    UCALL U370QENV                query environment\n         AIF   ('&GUPROCI' NE 'MAIN').DONE\n*\n         MNOTE *,'See U370QENV source for ESTAE considerations'\n*\n.DONE    MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "USNAP": {"ttr": 11269, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   USNAP &TITLE,&ADDR,&LEN,&PLIST=WKSNAP,&MF=\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n         LCLC  &NDX\n         LCLC  &L2\n&NDX     SETC  '&SYSNDX'\n         AIF   ('&MF' EQ 'L').MFL\n&L2      SETC  'L''&ADDR'              assume &LEN default to L'&ADDR\n         AIF   (T'&LEN EQ 'O').SKIP2\n&L2      SETC  '&LEN'\n.SKIP2   ANOP\n         AIF   ('&TITLE'(1,1) NE '''').NSTR\n&LABEL   BAL   R0,CODE&NDX             skip inline message text\nLMSG&NDX DC    AL1(L'MSG&NDX)          message length\nMSG&NDX  DC    C&TITLE\nCODE&NDX IM#SECT LABEL\n         AGO   .HVADR\n.NSTR    IM#LALR R0,&TITLE\n.HVADR   ST    R0,0+&PLIST\n         IM#STA &ADDR,4+&PLIST         @ storage to snap\n         IM#STA &L2,8+&PLIST           length or end address\n         LA    R1,&PLIST               @ parm list\n         UCALL U370SNAP                display storage\n         MEXIT\n.*\n.MFL     ANOP\n&PLIST   DS    0F\n&LABEL   DS    3F                      SNAP parmlist\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "USTATE": {"ttr": 11271, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x006\\x006\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 54, "newlines": 54, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   USTATE &MF=,&SA=SAUSTATE,&STPROB=,&STSUPR=,&KEY=,&SAVE=Y\n.*\n.* Copyright 2002 James M. Morrison\n.*\n.*---------------------------------------------------------------------\n.* &MF     - GEN generates state change routines\n.*         - L   generates state change routines' savearea\n.* &SA     - label of savearea for generated code use\n.* &STPROB - Y generates STPROB routine\n.* &STSUPR - Y generates STSUPR routine\n.* &KEY    - 0-15 - issues SPKA (requires supervisor state)\n.*           &MF will not be examined when KEY= specified\n.* &SAVE   - Y - default; saves work regs in workarea\n.*           N - doesn't\n.* Issuer is assumed to be APF authorized (TGD2APF)\n.*---------------------------------------------------------------------\n         AIF   ('&KEY' EQ '').CKGEN\n&LABEL   SPKA  &KEY*16                 set PSW protect key (priv)\n         MEXIT\n.CKGEN   AIF   ('&MF' EQ 'L').MFL\n         AIF   ('&MF' NE 'GEN').FIN\n         AIF   ('&STPROB' NE 'Y').CKSUPR\n*----------------------------------------------------------------------\n*  Assure problem state\n*----------------------------------------------------------------------\nSTPROB   DS    0H\n         TM    TGDFLG5,TGD5SUPR        SUPERVISOR state?\n         BNOR  R14\n         AIF   ('&SAVE' EQ 'N').MODESET\n         STM   R14,R1,&SA\n.MODESET MODESET MODE=PROB\n         AIF   ('&SAVE' EQ 'N').NI\n         LM    R14,R1,&SA\n.NI      NI    TGDFLG5,255-TGD5SUPR    PROBLEM state\n         BR    R14\n.CKSUPR  AIF   ('&STSUPR' NE 'Y').FIN\n*----------------------------------------------------------------------\n*  Assure supervisor state\n*----------------------------------------------------------------------\nSTSUPR   DS    0H\n         TM    TGDFLG5,TGD5SUPR        SUPERVISOR state?\n         BOR   R14\n         STM   R14,R1,&SA\n         MODESET MODE=SUP\n         LM    R14,R1,&SA\n         OI    TGDFLG5,TGD5SUPR        supervisor state\n         BR    R14\n.FIN     MEXIT\n*\n.MFL     ANOP\n&SA      DS    2D                      USTATE - workarea\n*\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UVTAB": {"ttr": 11273, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00]\\x00]\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 93, "newlines": 93, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   UVTAB &CSECT,&OPT,&MF=\n.*\n.* Copyright 2002 James M. Morrison\n.*\n.*---------------------------------------------------------------------\n.* UVTAB  - Define U370VTAB table entry\n.*\n.* &CSECT - CSECT\n.* &OPT   - options\n.* &MF    - DSECT - generate DSECT\n.*        - HDR   - generate U370VTAB header\n.*        - TLR   - generate U370VTAB trailer\n.*        -       - generate U370VTAB VCON table element\n.*---------------------------------------------------------------------\n         LCLC  &BYT,&OPTVAL\n.*\n.*  Define U370VTAB table entry\n.*\n         AIF   ('&MF' NE '').NEL\n&BYT     SETC  '&CSECT'(5,K'&CSECT-4)\n&OPTVAL  SETC  '0'\n         DC    CL8'&CSECT'\n         DC    V(&CSECT)\n         DC    AL2(TGDD&BYT-TGDDLEV)\n         DC    AL2(&OPTVAL)\n         DC    A(0,0,0,0)\n*\n         MEXIT\n.*\n.NEL     AIF   ('&MF' NE 'HDR').TLR\n*\n*  U370VTAB header\n*\nU370VTAB CSECT ,\n         USING *,0\n         USING TGDWA,11\nHEADER   DC    A(DBUGTAB)\n         DC    A(L$VTABE)\n         DC    A(DBUGEND-1)\n         DC    A(0)                    spare\n*\nDBUGTAB  DS    0D                      beginning of VCON table\n         MEXIT\n.*\n.TLR     AIF   ('&MF' EQ 'DSECT').DSECT\n         COPY  U370#VTB                bring in U370* VCONs\n*\n*  U370VTAB trailer\n*\nDBUGEND  DS    0C                      end of U370VTAB table\n*\n.DSECT   ANOP\nVTB$XXXX EQU   0                       options\nVTABLE   DSECT ,\n*----------------------------------------------------------------------\n*  CSECT table header - BXLE index, increment, limit\n*----------------------------------------------------------------------\nVTHDR    DS    0F            VCON table BXLE: index, increment, limit\nVTINDEX  DS    A             beginning of table entries\nVTINCR   DS    F             entry length\nVTLIMIT  DS    A             last byte in table\n         DS    A             spare\nL$VTHDR  EQU   *-VTHDR       header length\nVTENTRY1 EQU   *             beginning of 1st entry\n         ORG   VTABLE\n*----------------------------------------------------------------------\n*  CSECT table\n*----------------------------------------------------------------------\nVTABNAME DS    CL8           CSECT name\nVTABVCON DS    A             address of CSECT\nVTABOFF  DS    H             offset to debug byte from XMTDLEV\nVTABOPT1 DS    X             options\nVTABOPT2 DS    X             options\nVT@CPD   DS    A             @ CSECT's CPD                     U370AP00\nVT@SX    DS    A             @ CSECT's SX                      U370AP00\nVTCPDL   DS    H             CPD length           for U370VADR U370AP00\nVTDSAL   DS    H             SX length            for U370VADR U370AP00\n         DS    H             spare\nVTCSL    DS    H             approx CSECT length  for U370VADR U370AP00\n         DS    0D\nL$VTABE  EQU   *-VTABLE      length of table entry\n         ORG   ,\n*\n         AIF   ('&MF' EQ 'DSECT').DONE\n         PRINT OFF\n*        DSAEX ,\n         DSAEX ,\n*        WATGD ,\n         WATGD ,\n         PRINT ON\n*\n.DONE    MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UWTO": {"ttr": 11276, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00-\\x00-\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   UWTO &LEVEL,&TEXT,&FIN=,&OPT=0\n.*\n.* Copyright 2002 James M. Morrison\n.*\n.*---------------------------------------------------------------------\n.* &LEVEL - see UDIAG macro\n.* &TEXT  - message to be written to MVS operator's console\n.*          Quoted text string, or any operand supported by IM#LALR\n.*          U370WTO defines the maximum text length, extra truncated\n.* &FIN   - see UDIAG, same feature\n.* &OPT   - U370WTO options, UWTO$* bits defined in WATGD\n.*---------------------------------------------------------------------\n         LCLC  &NDX\n&NDX     SETC  '&SYSNDX'\n&LABEL   UDIAG &LEVEL,SKIP=SKIP&NDX    gen CLI, BL or suppress\n         IM#LALR R0,&OPT               set U370WTO options\n         AIF   ('&TEXT'(1,1) EQ '''').STR\n.*\n         IM#LALR R1,&TEXT              R1 -> AL1 length, text\n         UCALL U370WTO                 issue WTO, echo to xxxxLOG\n         AIF   ('&FIN' EQ '').SKIP1\n         B     &FIN                    output produced, br\n.SKIP1   ANOP\nSKIP&NDX DS    0H\n         MEXIT ,\n.*\n.STR     AIF   ('&OPT' EQ '0').OPTOK\n         MNOTE 8,'UWTO - options not supported with string'\n         MNOTE *,'UWTO - if options desired, do not use string'\n         SLR   R0,R0                   IGNORE OPTIONS\n.OPTOK   IM#LALR R1,STRL&NDX           R1 -> AL1 length, text\n         UCALL U370WTO                 issue WTO, echo to xxxxLOG\n         AIF   ('&FIN' EQ '').SKIP2\n         B     &FIN                    output produced, br\n         AGO   .GENSTR\n.SKIP2   B     SKIP&NDX                skip string\n.GENSTR  ANOP\nSTRL&NDX DC    AL1(L'STR&NDX)          length of text\nSTR&NDX  DC    C&TEXT\n.FIN     AIF   ('&FIN' EQ '').SKIP\n         B     &FIN                    output produced, br\n.SKIP    ANOP\nSKIP&NDX DS    0H\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UZERO": {"ttr": 11278, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x16\\x00\\x16\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   UZERO &ADDR,&LENGTH\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n&LABEL   IM#LALR R0,&ADDR              destination address\n         AIF   ('&LENGTH'(1,1) EQ '(').LALR\n         AIF   ('&LENGTH'(1,1) EQ '*').LALR\n         AIF   ('&LENGTH'(1,1) EQ '.').LALR\n.*\n         L     R1,=A(&LENGTH)          destination length\n         AGO   .JOIN\n.*\n.LALR    IM#LALR R1,&LENGTH            destination length\n.*\n.*       Put off clearing R15 until the last possible moment\n.*       in case the contents of R0 & R1 above depend on R15\n.*       Also, since R15 is zero we don't need to set R14\n.*\n.JOIN    SLR   R15,R15                 source length\n         MVCL  R0,R14                  set storage to x'00'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "U370$MDL": {"ttr": 11280, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00?\\x00?\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 63, "newlines": 63, "modlines": 0, "user": "XV0006"}, "text": "U370$MDL TITLE 'Model FUNC=UTIL code'\n*\n* Copyright 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  To do:\n*----------------------------------------------------------------------\n         U#SET FUNC=UTIL\n*----------------------------------------------------------------------\n* Function:    ..............................\n*\n* Entry: R0    ignored\n*        R1    ignored\n*\n* Exit:  R15 = return code = 00\n*\n* Diagnostics:\n*              1 - entry/exit\n*\n* Notes:\n*\n*----------------------------------------------------------------------\n* Reg  DSECT    usage\n*----------------------------------------------------------------------\n* R2\n* R3\n* R4\n* R5\n* R6\n* R7\n* R8\n* R9\n* R10\n*----------------------------------------------------------------------\n         TITLE ' '\nU370$MDL UPROC ID=U...,L=L$SA\n         STM   R0,R2,SAENTRY\n*----------------------------------------------------------------------\n*\n*----------------------------------------------------------------------\nEXIT     DS    0H\n         UPEND ,\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\n         LTORG ,\n*----------------------------------------------------------------------\n*  Dynamic savearea & workarea - based R13\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSASA     DS    18F                standard MVS savearea\nSAENTRY  DS    3F                 R0:R2 from entry\n*\nSAFLAG1  DS    X                  status flags\n*\nSAX      DS    0D\nL$SA     EQU   *-SAVEAREA         length of savearea\n*\n         WATGD ,\n         EJECT ,\n*\nU370$MDL UFINI DXDUAP00,L$SA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "U370#BUG": {"ttr": 11282, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n         U370#BUG &PFX=TGDD\n.*\n.* Copyright 2002 James M. Morrison\n.*\n         LCLC  &P\n&P       SETC  '&PFX'\n&P.LEV   DS    C        default from PARM=\n*\n&P.ABND  DS    C        U370ABND\n&P.AP00  DS    C        U370AP00\n&P.AP99  DS    C        U370AP99\n&P.DBUG  DS    C        U370DBUG\n&P.CHAR  DS    C        U370CHAR\n&P.DATE  DS    C        U370DATE\n&P.HERC  DS    C        U370HERC\n&P.HEX   DS    C        U370HEX\n&P.LOG   DS    C        U370LOG\n&P.PSR   DS    C        U370PSR\n&P.QENV  DS    C        U370QENV\n&P.QSS   DS    C        U370QSS\n&P.QTCB  DS    C        U370QTCB\n&P.SDWA  DS    C        U370SDWA\n&P.SNAP  DS    C        U370SNAP\n&P.STAE  DS    C        U370STAE\n&P.TIOT  DS    C        U370TIOT\n&P.VADR  DS    C        U370VADR\n&P.WTO   DS    C        U370WTO\n         DS    CL4      spares\n&P.370   DS    C        common definition: DAST, RECV, XMIT, etc.\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "U370#VTB": {"ttr": 11284, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x13\\x00\\x13\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "XV0006"}, "text": "         UVTAB U370ABND\n         UVTAB U370AP00\n         UVTAB U370AP99\n         UVTAB U370CHAR\n         UVTAB U370DATE\n         UVTAB U370DBUG\n         UVTAB U370HERC\n         UVTAB U370HEX\n         UVTAB U370LOG\n         UVTAB U370PSR\n         UVTAB U370QENV\n         UVTAB U370QSS\n         UVTAB U370QTCB\n         UVTAB U370SDWA\n         UVTAB U370SNAP\n         UVTAB U370STAE\n         UVTAB U370TIOT\n         UVTAB U370VADR\n         UVTAB U370WTO\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "U370ABND": {"ttr": 11286, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x01+\\x01+\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 299, "newlines": 299, "modlines": 0, "user": "XV0006"}, "text": "U370ABND TITLE 'UABEND macro support'\n*\n* Copyright 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  To do:\n*----------------------------------------------------------------------\n         U#SET DIAG=NO,FUNC=UTIL\n*----------------------------------------------------------------------\n* Function:    Issues WTO describing ABEND prior to returning to\n*              caller which will issue actual ABEND SVC\n*\n* Entry: R0         SNAP/SDUMP parm\n*\n*                    BITS\n*        R1         (00:07)  REASON code\n*                   (08:19)  reserved\n*                   (20:31)  ABEND code\n*\n*        R14 ->     SVC 13, followed immediately by option bytes:\n*\n*                   +00 (1) ABEND macro options\n*\n*                           1... .... DUMP\n*                           .1.. .... STEP\n*\n*                   +01 (1) Parm validity bits\n*\n*                           1... .... R1(00:07) REASON code\n*                           .1.. .... R1(20:31) ABEND code\n*                           ..1. .... R0 SNAP/SDUMP parm reg\n*                           .... ...1 +02, +03 option bytes present\n*\n*                   +02 (1) not currently generated by UABEND\n*\n*                   +03 (1) not currently generated by UABEND\n*\n* Exit:  Returns to callers' SVC 13 instruction (ABEND SVC)\n*\n* Diagnostics:\n*             9 - savearea after options analysis\n*\n* Notes: UABEND macro stored regs R0-R15 in &XMTABND before call.\n*        I've since written U370SDWA, which captures the regs\n*        via the SDWA which is nicer\n*\n*        U370ABND assumes caller follows normal xxxx370\n*        register conventions:\n*\n*        R11  -  TGD\n*        R12  -  program base\n*        R13  -  savearea/workarea\n*\n*        U370ABND returns to the caller's ABEND SVC, so that any\n*        dumps reflect the actual code that wished to ABEND, rather\n*        than issuing ABEND from here.\n*\n*----------------------------------------------------------------------\n* R2\n* R3\n* R4     options\n* R5\n* R6\n* R7\n* R8\n* R9     @ caller's savearea\n* R10    @ caller's return, options\n* R11    @ TGDWA\n* R12    pgm base\n* R13    @ savearea\n*----------------------------------------------------------------------\n         TITLE ' '\nU370ABND UPROC ID=UABD,L=L$SA\n         EJECT ,\n*----------------------------------------------------------------------\n*  Zappable options for U370ABND\n*----------------------------------------------------------------------\n         B     INIT\n*\n         DS    0F\nABOPT    DS    0XL4               U370ABND option bytes\n*\n*                01234567\n*\nABOPT1   DC    B'10000000'        IBM ABEND macro options\n*                1.......         DUMP\n*                .1......         STEP\n*\nABOPT2   DC    B'00000000'        spare\n*\nABOPT3   DC    B'00000000'        spare\n*\nABOPT4   DC    B'00000000'        spare\n*\n*  UABEND currently only defines 2 option bytes\n*\nUOPTMASK EQU   B'1100'            ICM mask for UABEND option bytes\n*\n*\nABOPT5   DC    B'00000000'        U370ABND overrides\nAB5IGN1 EQU 128  1.......         ignore UABEND 1st option byte\nAB5IGN2 EQU 64   .1......         ignore UABEND 2nd option byte\nAB5IGN3 EQU 32   ..1.....         ignore UABEND 3rd option byte\nAB5IGN4 EQU 16   ...1....         ignore UABEND 4th option byte\n*\nABOPT6   DC    B'00000000'        spare\n*\n         EJECT ,\n*----------------------------------------------------------------------\n*  Initialize\n*----------------------------------------------------------------------\nINIT     DS    0H\n         L     R9,4(,R13)              @ caller's SA\n         USING SXBASE,R9\n         L     R10,SXR14               caller's R14 @ SVC 13 + options\n*----------------------------------------------------------------------\n*  Ignore UABEND option bytes as per ABOPT5\n*----------------------------------------------------------------------\n         SLR   R4,R4\n         ICM   R4,UOPTMASK,2(R10)      grab UABEND option bytes\n*\n         TM    ABOPT5,AB5IGN1\n         BNO   *+8\n         ICM   R4,8,ZERO               ignore UABEND 1st option byte\n*\n         TM    ABOPT5,AB5IGN2\n         BNO   *+8\n         ICM   R4,4,ZERO               ignore UABEND 2nd option byte\n*\n         TM    ABOPT5,AB5IGN3\n         BNO   *+8\n         ICM   R4,2,ZERO               ignore UABEND 3rd option byte\n*\n         TM    ABOPT5,AB5IGN4\n         BNO   *+8\n         ICM   R4,1,ZERO               ignore UABEND 4th option byte\n*----------------------------------------------------------------------\n*  If ABOPT specified a value, make sure it gets used\n*  Store caller's UABEND macro expansion option bytes in SAOPTS\n*----------------------------------------------------------------------\n         O     R4,ABOPT                assert ABOPT choices\n         ST    R4,SAOPTS               save options bytes in SA\n*----------------------------------------------------------------------\n*  If we're recursing give up hope right now\n*----------------------------------------------------------------------\n         MVC   SARABND(16*4),TGDABEND  in case of recursion\n         TM    TGDFLG1,TGD1ABND        UABEND recursing?\n         BO    RECURSE                 abandon all hope\n*\n         OI    TGDFLG1,TGD1ABND        UABEND in progress\n*----------------------------------------------------------------------\n*  Handle ABEND, REASON code(s)\n*----------------------------------------------------------------------\n         L     R0,SXR0                 UABEND R0 contents\n         ST    R0,SARUR0               UABEND R0 contents\n         TM    SAOPT1,SA1SNAP          valid SNAP/SDUMP parm?\n         BNO   *+8\n         ST    R0,SAPARM0              ABEND R0 value\n*\n         L     R0,SXR1                 UABEND R1 contents\n         ST    R0,SARUR1               UABEND R1 contents\n         TM    SAOPT1,SA1RSN           caller provided REASON code?\n         BNO   *+8                     no, leave REASON alone\n         STCM  R0,8,SAREASON+3         yes\n*\n         L     R14,DEFABND             default abend code\n         N     R0,=X'00000FFF'         only user ABENDs supported\n         TM    SAOPT1,SA1COD           caller provided ABEND code?\n         BO    *+6                     yes, br\n         LR    R0,R14                  assign default\n         ST    R0,SAABEND\n         UDIAG 9,'ABND savearea',SAVEAREA,L$SA\n*----------------------------------------------------------------------\n*  Issue a WTO describing the ABEND\n*----------------------------------------------------------------------\n         MVI   SAMSG1,C' '\n         MVC   SAMSG1+1(L'SAMSG1-1),SAMSG1\n         MVC   SAM1LIT1,=C'UABEND'\n*\n         L     R0,SAABEND              load (user) ABEND code\n         SLL   R0,32-12                preserve only rightmost 12 bits\n         SRL   R0,32-12                which contains user ABEND code\n         CVD   R0,SADBL                convert to decimal\n         UNPK  SACHAR,SADEC            convert to EBCDIC\n         OI    SASIGN,X'F0'            repair sign nibble\n         MVI   SAM1LIT2,C'U'\n         MVC   SAM1TXT2,SARESULT\n         MVI   SAM1LIT3,C'-'\n*\n         L     R0,SAREASON             ABEND reason code\n         SLR   R1,R1\n         UCALL U370HEX\n         STCM  R1,3,SAM1TXT3\n*\n         LA    R0,2(,R10)              just past ABEND SVC\n         LA    R1,SAVBUF               @ U370VADR buffer\n         UCALL U370VADR                locate ABENDing code\n         MVC   SAM1MCO,SAVMCO          module.csect.offset\n*\n         MVI   SAM1LEN,L$MSG1          set WTO msg length\n         UWTO  0,SAMPARM\n*----------------------------------------------------------------------\n*  Close xxxxLOG before ABENDing to flush pending messages\n*----------------------------------------------------------------------\nCLOSE    DS    0H\n         ULOG TERM=YES\n*----------------------------------------------------------------------\n*  Return to caller for ABEND issuance\n*----------------------------------------------------------------------\nABEND    DS    0H\n         L     R0,SAPARM0              SNAP/SDUMP parm\n         L     R1,SAABEND              abend code\n         ICM   R1,8,SAOPT0             ABEND options\n*\n         XC    SX@FWD,SX@FWD           erase caller's fwd SA ptr to us\n*                                      so U370STAE doesn't report us\n*                                      as the ABENDing SX\n*\n         LR    R14,R10                 restore caller's return addr\n         L     R15,SAREASON               insert ABEND reason\n         LM    R2,R13,SARUR2              except R0, R1, and R14\n         BR    R14                     return to caller's ABEND SVC\n*\nDEFABND  DC    F'200'                  default abend code\n*----------------------------------------------------------------------\n*  Recursive UABENDs, WTO & bail\n*----------------------------------------------------------------------\nRECURSE  DS    0H\n         WTO   'ABND recursing; ABEND U(400)'\n         ABEND 400,DUMP\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\nZERO     DC    F'0'\n         PRINT DATA\nPATCH    DC    32S(*)                  <zap>\n*\n         LTORG ,\n*----------------------------------------------------------------------\n*  Dynamic savearea & workarea - based R13\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSAVREGS  DS    18F\n*\nSAPARM0  DS    F                       U370ABND parm R0\nSAPARM1  DS    F                       U370ABND parm R1\nSAREASON DS    F                       U370ABND reason code\nSAABEND  DS    F                       U370ABND abend code\n*\nSAOPTS   DS    F                       U370ABND options from UABEND\n*\nSAOPT0   EQU   SAOPTS+0,1              IBM ABEND macro options\nSA0DUMP  EQU   128                     ABEND n,DUMP\nSA0STEP  EQU   64                      ABEND n,,STEP\n*\nSAOPT1   EQU   SAOPTS+1,1              U370ABND parm validity options\nSA1RSN   EQU   128                     REASON code valid\nSA1COD   EQU   64                      ABEND code valid\nSA1SNAP  EQU   32                      SNAP/SDUMP parm reg R0\nSA1MORE  EQU   1                       Options +2 & +3 valid\n*\nSARABND  DS    16F                     TGDABEND copied here @ entry\nSARUR0   EQU   SARABND+(00*4)\nSARUR1   EQU   SARABND+(01*4)\nSARUR2   EQU   SARABND+(02*4)\n*\n*  Binary to EBCDIC workarea\n*\nSADBL    DS    D                       CVD workarea\nSADEC    EQU   SADBL+5,3               decimal ABEND code max 4095\nSACHAR   DS    CL5                     max user ABEND 04095\nSASIGN   EQU   SACHAR+4,1              packed sign repair byte\nSARESULT EQU   SACHAR+1,4\n*\nSAVBUF   DS    0D\n         DVADRBUF PFX=SAV              U370VADR buffer\n*\n*  WTO message text, preceded by AL1 length\n*\nSAMPARM  DS    0D\nSAM1LEN  DS    AL1                     message length for UWTO\nSAM1LIT1 DS    C'UABEND'\n         DS    C\nSAM1LIT2 DS    C'U'                    User ABEND code\nSAM1TXT2 DS    C'dddd'                 User ABEND code\nSAM1LIT3 DS    C'-'\nSAM1TXT3 DS    C'xx'                   reason code\n         DS    C\nSAM1MCO  DS    CL(L'SAVMCO)            module.csect.offset\nL$MSG1   EQU   *-SAM1LIT1\nSAMSG1   EQU   SAM1LIT1,L$MSG1\nSAEND    DS    0D\nL$SA     EQU   *-SAVEAREA              length of savearea\n*\n         WATGD PRINT=ON\n         EJECT ,\n*\nU370ABND UFINI DXDUABND,L$SA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "U370AP00": {"ttr": 11526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x01N\\x01N\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 334, "newlines": 334, "modlines": 0, "user": "XV0006"}, "text": "U370AP00 TITLE 'xxxx370 Application Initialization'\n*\n* Copyright 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  To do:\n*----------------------------------------------------------------------\n         U#SET FUNC=UTIL\n*----------------------------------------------------------------------\n* Function:    Initialize xxxx370 application\n*              Called via UPROC ID=MAIN\n*\n*              - Enters supervisor state, key 8\n*\n*                All xxxx370 applications require APF authorization\n*                (sort of diminishes value of U370QENV, eh?)\n*\n*              - Copies VCON table to our TPU, anchored TGD@VTAB\n*\n*              - Updates VCON table to describe each CSECT's CPD & DSA\n*                address/length so U370DBUG may report them\n*\n*              - Initializes every DSA in the DSA pool for CSECTs\n*                identified in the VCON table (saves UPROC overhead;\n*                only has to be done once)\n*\n*              - Based on the length of a CSECT's SA, selects an\n*                appropriate SA initialization routine;\n*                SX@INIT contains the address of selected routine\n*                The SA initialization routines are in this CSECT\n*                Note that the CSECT can ignore the selected routine\n*                by coding UPROC INIT= values (or taking default)\n*\n* Entry: R0    ignored\n*        R1    ignored\n*\n* Exit:  R15 = return code = 00\n*\n* Diagnostics:\n*              1 - entry/exit\n*\n* Notes: AP00 is highly dependent on UPROC & UPEND implementations\n*        See also U370AP99, which is application termination CSECT\n*\n*        AP00 sets TGD@TCB\n*        AP00 should only be called by UPROC ID=MAIN\n*\n*----------------------------------------------------------------------\n* Reg  DSECT    usage\n*----------------------------------------------------------------------\n* R2\n* R3   SX\n* R4   CPD\n* R5            BXLE\n* R6            BXLE\n* R7            BXLE\n* R8   FINBLOK  RUNVTAB & subroutines only\n* R9\n* R10  TPU      CPD user fields\n*----------------------------------------------------------------------\n         TITLE ' '\n*\n*  Expand some DSECTs so our TPU can reference symbols in them\n*\n         DSAEX ,                  SX + SA\n         WATGD ,                  common\n         UVTAB MF=DSECT           U370VTAB VCON table\n*----------------------------------------------------------------------\n*  TPU - CPD user additions - contains VCON table (with updates)\n*----------------------------------------------------------------------\nTPU      DSECT ,                  task persistent data - user section\nTPUVHDR  DS    XL(L$VTHDR)             VCON table header\nTPUVTAB  DS    (TGD#VTE)XL(L$VTABE)    VCON table entries\nL$TPUVTB EQU   *-TPUVHDR               length of VCON table\nL$TPU    EQU   *-TPU                   length of user additions\n*----------------------------------------------------------------------\nU370AP00 UPROC ID=UAP0,L=L$SA,CPD=(Y,L$TPU),INIT=MIN\n*----------------------------------------------------------------------\n         USING PSA,0\n         MVC   TGD@TCB,PSATOLD         my TCB address\n         MVC   TGDSA1(4),VERFIELD      set SA verification field\n*\n*  Our SX@CPD isn't initialized yet, so rather than using U@CPD,\n*  we must use UPRLOC\n*\n         UPRLOC QCPD,R10               find my CPD\n         LA    R10,CPDUSER-CPD(,R10)   @ CPD user field\n         USING TPU,R10\n*----------------------------------------------------------------------\n*  Copy U370VTAB to our CPD\n*----------------------------------------------------------------------\n         ICM   R9,15,=V(U370VTAB)      find VCON table\n         BZ    VTABERR\n         USING VTABLE,R9\n*\n         L     R7,VTLIMIT              last byte in table\n         LR    R0,R10                  dest addr\n         LR    R8,R0\n         L     R1,=A(L$TPUVTB)         dest length\n         LA    R15,1(,R7)\n         LR    R14,R9                  source addr\n         SR    R15,R14                 source length\n         MVCL  R0,R14                  copy U370VTAB to CPDUSER\n         BC    5,COPYERR\n*\n*  Relocate addresses in VTHDR\n*\n         S     R7,VTINDEX              length of all entries - 1\n         DROP  R9,R10\n         USING VTABLE,R8\n         LA    R2,VTENTRY1             index\n         ST    R2,VTINDEX\n*                                      increment ok asis\n         AR    R2,R7\n         ST    R2,VTLIMIT              limit\n         ST    R8,TGD@VTAB             tell the world where\n         MVC   TGDSAVER,VERFIELD       copy SA verification field\n         EJECT ,\n*----------------------------------------------------------------------\n*  Run U370VTAB, initialize each CSECT's SX & CPD\n*  Also fill in VTAB fields not known until execution time\n*  UFINI defines a halfword containing CSECT length immediately\n*  behind the DSA QCON.\n*----------------------------------------------------------------------\nRUNVTAB  DS    0H\n         LM    R5,R7,VTHDR                  index, incr, limit\n         DROP  R8\n         USING VTABLE,R5\n*\nDSANEXT  DS    0H\n         ICM   R2,15,VTABVCON               @ CSECT\n         BZ    DSALOOP                      nobody home, skip\n*\n         L     R8,PROC@FIN-U370AP00(R2)     @ FINBLOK\n         USING FINBLOK,R8\n         MVC   VTCSL,FINLCS                 CSECT length\n         L     R3,FINQSX\n         AR    R3,RDSA                      @ DSA\n         ST    R3,VT@SX                     so U370DBUG can print addr\n         USING SX,R3\n*\n         ICM   R4,15,FINQCPD                CPD offset or 0\n         BZ    GOPREP\n         AR    R4,RDSA                      @ CPD\n         ST    R4,VT@CPD                    so U370DBG can print addr\n         USING CPD,R4\n*\nGOPREP   BAL   R10,PREPDSA                  prepare DSA\n         BAL   R10,SELINIT                  select DSA init routine\n         MVC   VTDSAL,SXLDSA                copy DSA length\n         MVC   VTCPDL,CPDL                  copy CPD length\nDSALOOP  BXLE  R5,R6,DSANEXT\n*----------------------------------------------------------------------\n*  Enter supervisor state, stay in key 8\n*----------------------------------------------------------------------\n         MODESET MODE=SUP                   supervisor state\n         OI    TGDFLG5,TGD5SUPR             indicate such\n*----------------------------------------------------------------------\n*  Return to caller\n*  Here we have to play a little game to return to ID=MAIN with\n*  it's R13 set at the savearea referenced by the VCON table,\n*  not the TGDSA1 savearea; this assures if ID=MAIN established\n*  an ESTAE, the SX points to the CPD with the ESTAE specification.\n*----------------------------------------------------------------------\nEXIT     DS    0H\n         UPEND ,                            return to ID=MAIN CSECT\n*\nCOPYERR  WTO   'U370AP00 VCON table failure'\nVTABERR  WTO   'U370AP00 install error'\n         ABEND 370\nVERFIELD DC    C'SXSA'\n         EJECT ,\n*----------------------------------------------------------------------\n*  PREPDSA - initialize a single DSA\n*  Entry:  R2 @ CSECT\n*          R3 @ DSA\n*          R4 @ CPD or zero\n*----------------------------------------------------------------------\nPREPDSA  DS    0H\n*\n*  No need to clear DSA, UPROC ID=MAIN cleared whole DSA pool\n*\n         MVC   SXID,ID-U370AP00(R2)         copy CSECT's name\n         LH    R0,FINLSA                    SA length\n         STH   R0,SXLSA                     SA length\n         LA    R14,L$SXPFX                  everybody's got one\n         AR    R0,R14\n         STH   R0,SXLDSA                    SX+SA length\n         MVC   SXVER,VERFIELD               set SA verification field\n         LTR   R4,R4                        CPD present?\n         BZR   R10                          no, done\n*\n*  CPD is also in DSA pool, so it's already cleared\n*\n         ST    R4,SX@CPD                    link SX to CPD\n         MVC   CPDID,ID-U370AP00(R2)        copy CSECT's name\n         LH    R0,FINLCPD                   CPD length\n         STH   R0,CPDL\n         BR    R10\n         DROP  R4,R8\n         EJECT ,\n*----------------------------------------------------------------------\n*  SELINIT - select INITMVCL or INITRS DSA init routine, setup SX\n*\n*  The whole point of having two DSA init routines is to save\n*  the cost of MVCL if we can get by with XC\n*\n*  The DSA init routines are located here because UPROC can't know\n*  at assembly time whether the SA is long enough to require MVCL\n*\n*  We further reduce DSA initialization cost by pre-calculating\n*  the registers needed to perform DSA setup once (here), rather\n*  than every time the CSECT gets called\n*\n*  Fields which are modified by entry conventions are not included\n*  in the length calculation; SXR0 is the first field we clear\n*  in the DSA initialization routines\n*  SXVER     set in the PREPDSA routine\n*  SX@BACK   set by DSA init routine\n*  SX@FWD    cleared by UPEND macro of called routine\n*----------------------------------------------------------------------\nSELINIT  DS    0H\n         LH    R14,SXLSA          SA length\n         LA    R0,SXR0-SXBASE     length of uncleared SA fields\n         SR    R14,R0             length needed to clear\n         LR    R15,R14            save for later\n         LA    R0,256             maximum XC length\n         CR    R14,R0             length exceeds XC capabilities?\n         BH    SELMVCL            yes, br\n         EJECT ,\n*----------------------------------------------------------------------\n*  SELRS - setup SX for INITRS DSA init routine\n*----------------------------------------------------------------------\n*\n*  INITRS setup:\n*  SXAP00+0(4) = length of area to clear minus one\n*  SXAP00+4(4) = length of area to clear\n*  SXINIT+0(4) = A(INITRS)\n*\nSELRS    DS    0H\n         BCTR  R15,0              account for EX needs\n         ST    R15,SXAP00         save EX length\n         LA    R15,SX@BACK        @ 1st field to XC\n         ST    R15,SXAP00+4\n         LA    R15,INITRS         @ DSA init support routine\n         ST    R15,SX@INIT\n         BR    R10\n*----------------------------------------------------------------------\n*  DSA init - RS-length SA\n*\n*  Entry:\n*  R3  @ CSECT's SX\n*  R4  @ return address in UPROC\n*  R5  = SX@INIT\n*  R11 @ DSA pool\n*  R12 @ calling CSECT's UPROC expansion\n*  R13 @ calling CSECT's caller's SA\n*\n*  Preserves contents of SXVER in caller's SA\n*  It's not necessary to restore R0-R2, they're not modified\n*----------------------------------------------------------------------\n         PUSH  USING\n         DROP  ,\n         USING SX,R3\n         USING INITRS,R5\nINITRS   DS    0H\n         LM    R8,R9,SXAP00            restore 'SA clear' regs\n         EX    R8,CLEAR\n         LA    R7,SXBASE               @ our SA (clear hi byte)\n         ST    R7,SX@FWD-SXBASE(,R13)  caller's forward ptr @ our SA\n         ST    R13,SX@BACK             our backward ptr @ caller's SA\n         LR    R13,R7                  R13 @ our SA\n         BR    R4\nCLEAR    XC    0(*-*,R9),0(R9)         clear SA\n         POP   USING\n         EJECT ,\n*----------------------------------------------------------------------\n*  SELMVCL - setup SX for INITMVCL DSA init routine\n*----------------------------------------------------------------------\n*\n*  INITMVCL setup:\n*  SXAP00+0(4) =\n*  SXAP00+4(4) =\n*  SXINIT+0(4) = A(INITMVCL)\n*\nSELMVCL  DS    0H\n         ST    R15,SXAP00         MVCL length\n         LA    R15,SX@BACK        @ 1st field to MVCL\n         ST    R15,SXAP00+4\n         LA    R15,INITMVCL       @ DSA init support routine\n         ST    R15,SX@INIT\n         BR    R10\n*----------------------------------------------------------------------\n*  DSA init - MVCL-length SA\n*\n*  Entry:\n*  R3  @ CSECT's SX\n*  R4  @ return address in UPROC\n*  R5  = SX@INIT\n*  R11 @ DSA pool\n*  R12 @ calling CSECT's UPROC expansion\n*  R13 @ calling CSECT's caller's SA\n*\n*  Preserves contents of SXVER in caller's SA\n*  It's not necessary to restore R0-R2, they're not modified\n*----------------------------------------------------------------------\nINITMVCL DS    0H\n         LM    R8,R9,SXAP00            setup MVCL dest addr/length\n         SLR   R15,R15                 source length (R14 unneeded)\n         MVCL  R8,R14                  clear SA (preserve SXVER)\n         LA    R7,SXBASE               @ our SA\n         ST    R7,SX@FWD-SXBASE(,R13)  caller's forward ptr @ our SA\n         ST    R13,SX@BACK             our backward ptr @ caller's SA\n         LR    R13,R7                  R13 @ our SA\n         BR    R4\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\n         LTORG ,\n*----------------------------------------------------------------------\n*  Dynamic savearea & workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSASA     DS    18F                standard MVS savearea\nSAX      DS    0D\nL$SA     EQU   *-SAVEAREA         length of savearea\n*\n         UFINI SECT=DSECT\n*\n         PRINT NOGEN\n         IHAPSA ,\n*\nU370AP00 UFINI DXDUAP00,L$SA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "U370AP99": {"ttr": 11777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00b\\x00b\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 98, "newlines": 98, "modlines": 0, "user": "XV0006"}, "text": "U370AP99 TITLE 'xxxx370 Application Termination'\n*\n* Copyright 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  To do:\n*----------------------------------------------------------------------\n         U#SET FUNC=UTIL\n*----------------------------------------------------------------------\n* Function:    Terminate xxxx370 application\n*              Called via UPEND ID=MAIN\n*\n*              - Calls XXXXAP99 (WXTRN), if exists\n*                Application-specific cleanup\n*\n*              - Calls selected U370* CSECTs to cleanup\n*\n*              - Re-establishes problem state, key 8\n*\n*              - Releases DSA pool\n*\n*              - Doesn't return to ID=MAIN CSECT; returns to\n*                ID=MAIN CSECT's caller directly\n*\n* Entry: R0      ignored\n*        R1      ignored\n*\n*        TGDFLG1 Two flags are supported:\n*\n*                TGD1XNFR  - don't FREEMAIN DSA pool\n*                TGD1XABD  - ABEND instead of returning\n*\n* Exit:  R15 = return code = TGDRC\n*----------------------------------------------------------------------\n         TITLE ' '\nU370AP99 UPROC ID=UAP9,L=L$SA,CPD=(Y,0,ESTAE)\n*----------------------------------------------------------------------\n*  Call xxxx370 cleanup routine\n*----------------------------------------------------------------------\n         WXTRN XXXXAP99\n         L     R15,=V(XXXXAP99)        appl cleanup\n         LTR   R15,R15                 present?\n         BZ    SHUT                    no, skip it\n*\n         BALR  R14,R15                 call appl cleanup (no parms)\n*----------------------------------------------------------------------\n*  Call U370-guys to cleanup\n*----------------------------------------------------------------------\nSHUT     DS    0H\n         L     R3,TGDRC                application return code\n         UPSR  1,'AP99 terminating rc',(R3)\n         UDIAG 5,'AP99 DSA pool',(RDSA),*TGDLDSA\n         UESTAE  TERM=YES              de-establish ESTAE environment\n         ULOG    TERM=YES              close xxxxLOG\n         SPKA  8*16                    back to key 8\n         MODESET MODE=PROB             back to problem state\n         NI    TGDFLG5,255-TGD5SUPR    no longer in supervisor state\n*----------------------------------------------------------------------\n*  Release DSA pool\n*----------------------------------------------------------------------\n         LA    R9,DIE                  assume ABEND, not EXIT\n         TM    TGDFLG1,TGD1XABD        ABEND instead of return?\n         BO    *+8                     yes, br\n         LA    R9,EXIT                 no ABEND\n*\n         L     R13,TGDSA1+4            ID=MAIN caller's R13\n         DROP  R13\n         TM    TGDFLG1,TGD1XNFR        skip FREEMAIN?\n         BO    EXITBR                  yes, br\n         L     R0,TGDLDSA              length of DSA pool\n         FREEMAIN R,LV=(0),A=(RDSA)    release DSA POOL\n         DROP  RDSA\nEXITBR   BR    R9                      exit or ABEND\n*----------------------------------------------------------------------\n*  Return to ID=MAIN's caller\n*----------------------------------------------------------------------\nEXIT     DS    0H\n         L     R14,12(,R13)            restore return address\n         LR    R15,R3                  application return code\n         LM    R0,R12,20(R13)          restore caller regs\n         BR    R14                     return to ID=MAIN's caller\n*----------------------------------------------------------------------\nDIE      SLR   R15,R15                 reason code = none\n         ABEND 99,DUMP                 ABEND w/ dump\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\n         LTORG ,\n*----------------------------------------------------------------------\n*  Dynamic savearea & workarea - based R13\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSASA     DS    18F                savearea\nSAX      DS    0D\nL$SA     EQU   *-SAVEAREA         length of savearea\n         WATGD ,\nU370AP99 UFINI DXDUAP99,L$SA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "U370CHAR": {"ttr": 11780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x9f\\x00\\x9f\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 159, "newlines": 159, "modlines": 0, "user": "XV0006"}, "text": "U370CHAR TITLE 'Convert R0 into displayable hex'\n*\n* Copyright 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n         U#SET FUNC=UTIL\n*----------------------------------------------------------------------\n* Function:    converts character string to hex\n*\n* Entry:  R0(00:00)    flag bit - hex chars allowed (CHAR$HEX)\n*         R0(24:31)    length of string\n*         R1           @ char string to be converted to hex\n*\n* Exit:   R15 =  0     everything is OK\n*                      R0  =  hex value\n*\n*                4     conversion error\n*\n* Diagnostics:\n*              1 - RETRY\n*              2 - output value\n*\n* Notes:\n*\n*----------------------------------------------------------------------\nMAXDEC   EQU   10                      max decimal: 2,147,483,647\nMAXHEX   EQU   6                       FFFFFF\nERR#1    EQU   1                       unable to locate TPU\nRC4      EQU   4                       return code: error\n*\nTPU      DSECT ,\nTPUESTAE DS    X                       ESTAE established flag\n         DS    0D\nL$TPU    EQU   *-TPU\n*----------------------------------------------------------------------\nU370CHAR UPROC ID=UCHR,L=L$SA,CPD=(Y,L$TPU,ESTAE)\n         STM   R0,R1,SAENTRY           for RETRY routine\n         LR    R5,R0                   flag + length\n         LR    R6,R1                   string addr\n         SLR   R7,R7                   value to return\n         MVI   SARC+3,RC4              assume error rc\n*\n*  Establish ESTAE first time we're called (good rest of task life)\n*\n         BAL   R10,FINDTPU\n         USING TPU,R9\n         CLI   TPUESTAE,0              ESTAE set on prior call?\n         BNE   HVESTAE\n         UESTAE RETRY\n         MVI   TPUESTAE,1              ESTAE established\nHVESTAE  DS    0H\n         DROP  R9\n*\n         SLR   R4,R4                   will contain CHAR$HEX flag\n         SLDL  R4,1                    save flag in R4\n         SRL   R5,1                    discard flag from R5\n         LTR   R4,R4                   hex digits or decimal digits?\n         BNZ   HEX\n*\n*  Convert decimal char string to hex\n*\nCHAR     DS    0H\n         LA    R14,MAXDEC\n         CR    R5,R14                  more than max # chars allowed?\n         BH    EXIT\n         BCTR  R5,0\n         EX    R5,PACK                 char -> packed\n         CVB   R7,SADEC                packed -> hex\n         B     EXIT\n*\nPACK     PACK  SADEC,0(*-*,R6)         char -> packed\n*\n*  Convert hex char string to hex\n*\nHEX      DS    0H\n         LA    R14,MAXHEX\n         CR    R5,R14                  more than max # chars allowed?\n         BH    EXIT\n         SLR   R14,R14                 hex value\n         SLR   R1,R1\nHEXLOOP  DS    0H\n         CLI   0(R6),C'9'\n         BH    EXIT\n         CLI   0(R6),C'0'\n         BL    HEXHEX\n*\nHEXDEC   DS    0H                      handle 0-9\n         ICM   R15,8,0(R6)\n         SLL   R15,4\n         SLDL  R14,4\n         B     HEXNEXT\n*\nHEXHEX   DS    0H                      handle a-f, A-F\n         IC    R1,0(R6)                grab char\n         CLI   0(R6),C'A'\n         BL    HEXHEXLC\n         CLI   0(R6),C'F'\n         BH    EXIT\nHEXHEXUC LA    R15,HEXTAB-C'A'(R1)     upper case; @ char hex value\n         ICM   R15,8,0(R15)\n         SLL   R15,4\n         SLDL  R14,4\n         B     HEXNEXT\nHEXHEXLC DS    0H                      lower case\n         CLI   0(R6),C'a'\n         BL    EXIT\n         CLI   0(R6),C'f'\n         BH    EXIT\n         LA    R15,HEXTAB-C'a'(R1)     @ hex value for char\n         ICM   R15,8,0(R15)\n         SLL   R15,4\n         SLDL  R14,4\n*\nHEXNEXT  LA    R6,1(,R6)               @ next char\n         BCT   R5,HEXLOOP\n         LR    R7,R14                  return value\n*\nEXIT     DS    0H\n         UDIAG 2,'CHAR value',(R7)\n         LR    R0,R7\n         UPEND R0=PASS,RC=SARC         return to caller\n*\nFINDTPU  U@CPD TPU,R9,ERR=NOTPU        find our TPU\n         BR    R10                     return w/ TPU\nNOTPU    MVI   SAREASON,ERR#1          couldn't find TPU\nDIE      UABEND SAREASON\n*\n*  Retry routine - regs are from call when ESTAE was established\n*\nRETRY    DS    0H\n         SLR   R5,R5\n         IC    R5,SAR0B3               length from entry\n         L     R6,SAR1                 addr of string\n         UDIAG 1,'CHAR RETRY',(R6),(R5)\n         SLR   R7,R7                   return value = 0\n         B     EXIT\n         LTORG ,\n*\nHEXTAB   DC    X'0A0B0C0D0E0F'\n*----------------------------------------------------------------------\n*  Dynamic savearea & workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSAVREGS  DS    18F\nSAENTRY  DS    2F                      entry regs\nSAR0B0   EQU   SAENTRY+00,1            hi byte of R0 = flag\nSAR0B3   EQU   SAENTRY+03,1            length of request\nSAR1     EQU   SAENTRY+04,4            addr of request\nSADEC    DS    PL8                     packed number\nSARC     DS    F                       return code\nSAREASON DS    X                       reason for ABENDing\n         DS    0D                      align\nL$SA     EQU   *-SAVEAREA              length of savearea\n*\n         PRINT NOGEN\n         WATGD ,\n         PRINT GEN\nU370CHAR UFINI DXDUCHR,L$SA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "U370DATE": {"ttr": 11784, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00\\x90\\x00\\x90\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 144, "newlines": 144, "modlines": 0, "user": "XV0006"}, "text": "U370DATE TITLE 'Date and time conversion'\n*\n* Copyright 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n         U#SET FUNC=UTIL\n*----------------------------------------------------------------------\n* Function:    Date & time conversion\n*\n* Entry:  R0 = conversion type:\n*              00 - TIME DEC Julian to EBCDIC Gregorian\n*         R1 as below:\n*\n*         Type=00 - TIME DEC Julian to EBCDIC Gregorian\n*              +00  HHMMSSth               TIME DEC R0\n*              +04  00YYDDDF               TIME DEC R1\n*              +08  CL16'YYYYMMDDHHMMSSTH' output buffer\n*\n* Exit:   R15 =  0 - conversion successful\n*                8 - unrecognized type request\n*\n* Notes:\n*----------------------------------------------------------------------\nU370DATE UPROC ID=UDAT,L=L$SA\n         STM   R0,R1,SAENTRY           save entry parms\n         LA    R2,8                    assume unrecognized request\n         LTR   R0,R0                   TIME DEC Julian to EBCDIC Greg?\n         BNZ   EXIT\n         LR    R9,R1                   parm ptr\n*----------------------------------------------------------------------\n*  Convert HHMMSSth, YYYY to EBCDIC\n*----------------------------------------------------------------------\n         LM    R4,R5,0(R9)             HHMMSSth,00YYDDDF\n         STM   R4,R5,SAARG\n         AP    SAARG+4(4),=P'1900000'  Y2K: add S/370 epoch century\n         UNPK  SACHR,SAARG             packed to EBCDIC\n         OI    SACHRX,X'F0'            repair sign\n*----------------------------------------------------------------------\n*  Convert year to binary\n*----------------------------------------------------------------------\n         L     R3,SAARG+4              YYYYDDDF\n         SRL   R3,16-4                 000YYYY.\n         ST    R3,SAPAKY\n         OI    SAPAKY+3,X'0F'          packed year\n         CVB   R3,SADWD\n         ST    R3,SABINY               binary year\n*----------------------------------------------------------------------\n*  Select month table\n*----------------------------------------------------------------------\n         LA    R8,NOTLEAP              not a leap year\n         TM    SABINY+3,X'03'          divisible by 4?\n         BC    5,CALCMON               no, can't be leap year\n         SLR   R6,R6\n         LA    R10,400                 divisible by 400 is leap year\n         LR    R7,R3\n         DR    R6,R10\n         LTR   R6,R6\n         BNZ   CALCMON                 evenly divisible\n         LA    R10,100                 divisible by 100 not leap year\n         LR    R7,R3\n         DR    R6,R10\n         LTR   R6,R6\n         BZ    CALCMON                 evenly divisible\nSETLEAP  LA    R8,LEAP                 leap year\n*----------------------------------------------------------------------\n*  Find month & month day, given Julian days DDD in year\n*----------------------------------------------------------------------\nCALCMON  DS    0H                      R8 @ month table\n         LH    R0,SAPAKDDD             DDDF\n         STH   R0,SAPAKD\n         CVB   R5,SADWD2\n         ST    R5,SABIND               binary ddd\n*\n         LA    R1,1\n         SLR   R14,R14                 month minus one\n         SLR   R15,R15\nSCANMON  IC    R15,0(R14,R8)           # days in month\n         CR    R5,R15                  too many?\n         BNH   SETMON                  no, br; now know month\n         SR    R5,R15                  reduce ddd\n         AR    R14,R1                  bump month\n         B     SCANMON\nSETMON   DS    0H\n         LA    R1,100                  decimal shift factor\n         SLR   R6,R6\n         LA    R7,1(,R14)              month\n         MR    R6,R1\n         AR    R7,R5                   binary month, day of month\n         CVD   R7,SADWD3               decimal: 0000 0000 000M MDDF\n         OI    SAPAKMDX,X'0F'          assure reasonable sign\n         UNPK  SACHRMD,SAPAKMD         MMDD to EBCDIC\n*----------------------------------------------------------------------\n*  Return data to caller\n*----------------------------------------------------------------------\n         MVC   08(8,R9),SARESULT+8     YYYYMMDD\n         MVC   16(8,R9),SARESULT+0     HHMMSSth\n         SLR   R2,R2                   success\nEXIT     DS    0H\n         UDIAG 2,'DATE sa',(RSA),L$SA\n         UPSR  1,'DATE rc',(R2)\n         UPEND RC=(R2)                 return to caller\n         B     EXIT\n         LTORG ,\n*                  J  F  M  A  M  J  J  A  S  O  N  D\nNOTLEAP  DC    AL1(31,28,31,30,31,30,31,31,30,31,30,31)\nLEAP     DC    AL1(31,29,31,30,31,30,31,31,30,31,30,31)\n*----------------------------------------------------------------------\n*  Dynamic savearea & workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSASA     DS    18F\nSAENTRY  DS    2F                      R0:R1 from entry\n*\nSADWD    DS    D                       year\nSABINY   EQU   SADWD+0,4               binary\nSAPAKY   EQU   SADWD+4,4               packed 000Y,YYYF\n*\nSADWD2   DS    D                       julian day of year\nSABIND   EQU   SADWD2+0,4              binary\nSAPAKD   EQU   SADWD2+6,2              packed DDDF\n*\nSADWD3   DS    D                       gregorian month, day of month\nSABINMD  EQU   SADWD3+0,4              binary 0000MMDD\nSAPAKMD  EQU   SADWD3+5,3              packed   0MMDDF\nSAPAKMDX EQU   *-1,1                   sign repair\n*\nSAARG    DS    D                       HHMMSSth,YYYYDDDF\nSAPAKDDD EQU   SAARG+6,2              +0 1 2 3  4 5 6 7\n*\nSARESULT DS    0CL16                   nearly final result\nSACHR    DS    0CL15\nSACHRTM  DS    C'HHMMSSth'\nSACHRY   DS    C'19YY'\nSACHRD   DS    C'DDD'\nSACHRX   EQU   *-1,1                   sign repair\n         DS    C' '\nSACHRMD  EQU   SACHRD,4                C'MMDD'\n         DS    0D                      align\nL$SA     EQU   *-SAVEAREA              length of savearea\n*\n         PRINT NOGEN\n         WATGD ,\nU370DATE UFINI DXDUDAT,L$SA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "U370DBUG": {"ttr": 11788, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x01K\\x01K\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 331, "newlines": 331, "modlines": 0, "user": "XV0006"}, "text": "U370DBUG TITLE 'Parse xxxxDBUG ddname, set debug options'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  To do:\n*  1) Accept parm saying we're subtask, meaning:\n*     a) Find main task's TGD, note in TGD@HOME (or something)\n*     b) Rather than reading xxxxDBUG, copy debug values from\n*        main task's TGD\n*     Either accept the above parm, or just figure it out ourselves\n*  2) Allow CSECT parm similar to DOS/VS UPSI switch\n*     Copy UPSI to somewhere in SX\n*----------------------------------------------------------------------\n         U#SET FUNC=UTIL\n*----------------------------------------------------------------------\n* Function: Parse xxxxDBUG ddname, set debugging option bytes\n*           TGDD* in TGDWA.  The values for each byte vary from\n*           C'0' to C'9', and control UDIAG, UPSR, UWTO, etc.\n*\n* XMITDBUG syntax:\n*\n*           Each xxxx370 CSECT has one statement which is used to\n*           set it's corresponding debug byte.  The syntax is\n*\n*               Column  1: CSECT name (upcase)\n*               Column 10: debug value (C'0' - C'9')\n*\n*           Blank debug values are allowed, and ignored so that\n*           a standard list of CSECTs may be maintained and only\n*           modified when needed.\n*\n*           When CSECT name = 'DEFAULT', all debug bytes are primed\n*           with this value.  When used, it should appear as the\n*           first line of input.\n*\n*           Before xxxxDBUG is processed, all debug bytes are\n*           set to whatever xxxT370 set TGDDLEV to\n*           (C'0' or PARM= value).\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         R0  =\n*         R1  =\n*\n* Exit:   R15 = return code\n*         R15 = 00 success\n*\n* Abends:\n*\n* Notes:    This routine manages the xxxTDBUG DCB, no one else\n*           need worry about it.  The ddname is optional.\n*\n*           xxxx is set from the TGDEYE(1,4) field, and is the\n*           xxxx370 application name: XMIT, RECV, DAST, etc.\n*----------------------------------------------------------------------\n* Reg  DSECT    usage\n*----------------------------------------------------------------------\n* R2            ptr to debug byte for current CSECT\n* R3   INREC    input record\n* R4\n* R5   TABLE    BXLE index\n* R6            BXLE increment\n* R7            BXLE compare value (table limit)\n* R8   DCBD     xxxxDBUG DCB\n* R9\n* R10           saved R13 across GET macro\n* R11  TGDWA    common\n* R12           base reg\n* R13  XDGWA    savearea\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\nU370DBUG UPROC ID=UDBG,WA=XDGWA,L=L$XDGWA\n         UDIAG 1,'U370DBUG entered'\n*----------------------------------------------------------------------\n*  Handle OS parm, set default debug levels\n*----------------------------------------------------------------------\n         MVI   TGDDLEV,C'0'                 default diagnostic level\n*\n         ICM   R4,15,TGD@PARM               OS parm ptr\n         BZ    NOPARM\n         L     R4,0(,R4)                    @ OS parm string\n         LH    R14,0(,R4)                   l' parm string\n         LTR   R14,R14                      anything?\n         BNP   NOPARM                       no, br\n         MVC   TGDDLEV,2(R4)                copy diag char\nNOPARM   DS    0H\n*----------------------------------------------------------------------\n*  Initialize TGDD* values to default\n*----------------------------------------------------------------------\n         MVC   TGDDLEV+1(TGDDEND-TGDDLEV-1),TGDDLEV   propagate value\n*----------------------------------------------------------------------\n*  Initialize XDGWA workarea\n*----------------------------------------------------------------------\n         MVC   XDGDCB(L$DCB),MODLDCB        copy model DCB macro\n         MVC   XDGOPN(L$OPN),MODLOPN        copy model OPEN macro\n         MVI   XDGEOF,0                     not EOF\n         LA    R8,XDGDCB\n         USING IHADCB,R8\n         MVC   DCBDDNAM(4),TGDEYE           set xxxx\n         MVC   DCBDDNAM+4(4),=C'DBUG'       ddname = xxxxDBUG\n*----------------------------------------------------------------------\n*  Open DCB\n*----------------------------------------------------------------------\n         LA    R1,DCBDDNAM                  DDNAME=xxxTDBUG\n         UCALL U370TIOT                     ddname allocated?\n         LTR   R1,R1\n         BZ    RCZERO                       nope, never mind\n*\n         OPEN  (XDGDCB,INPUT),MF=(E,XDGOPN)\n         TM    DCBOFLG1,DCBOFOPN            opened?\n         BNO   RCZERO                       no, don't cares why, done\n*\n         UDIAG 2,'U370DBUG processing xxxxDBUG ddname'\n*----------------------------------------------------------------------\n*  Read input record\n*----------------------------------------------------------------------\n         LR    R10,R13                      preserve our savearea\nREAD     DS    0H\n         GET   (R8)                         locate record\n         CLI   XDGEOF,X'00'                 EOF?\n         BNE   ENDOFILE                     yes, br\n*\n         CLI   0(R1),C'*'                   COMMENT?\n         BE    READ\n*\n         LR    R3,R1                        ptr to input record\n         USING INREC,R3\n*----------------------------------------------------------------------\n*  Process input record\n*----------------------------------------------------------------------\nPROCESS  DS    0H\n         ICM   R5,15,TGD@VTAB               @ VCON table header\n         BZ    OOPS\n*\n         LM    R5,R7,0(R5)                  index, incr, limit\n         USING VTABLE,R5\n         CLC   =CL8'DEFAULT',INAME          setting DEFAULT?\n         BNE   CKCSECT\n*\n         MVC   TGDDLEV,INVAL\n         MVC   TGDDLEV+1(TGDDEND-TGDDLEV-1),TGDDLEV  propagate default\n         B     READ\n*\nCKCSECT  DS    0H\n         CLC   VTABNAME,INAME               found CSECT name?\n         BNE   CKNEXT                       no, advance index\n*\n         CLI   INVAL,C' '                   blank ... ignore\n         BE    READ                         (but shows CSECT entry)\n*\n         LH    R2,VTABOFF                   debug byte offset\n         LA    R15,TGDDLEV(R2)              @ debug byte\n         MVC   0(1,R15),INVAL               set debug byte\n         B     READ\n*\nCKNEXT   DS    0H\n         BXLE  R5,R6,CKCSECT                find CSECT name in table\n*\n         UDIAG 1,'U370DBUG unknown CSECT ignored',(R3),L$IN\n         B     READ\n*\nOOPS     ULOG  'U370DBUG - installation error'\n         ULOG  'U370DBUG - unable to locate U370VTAB CSECT'\n         UABEND ,\n         EJECT ,\n*----------------------------------------------------------------------\n*  EOF - close DCB\n*----------------------------------------------------------------------\nEOFRTN   DS    0H                           EODAD exit routine\n         MVI   XDGEOF-XDGWA(R10),1          hit EOF, set flag\n         BR    R14                          return to GET macro\n*\nENDOFILE DS    0H\n         MVC   XDGCLOS(L$CLOS),MODLCLOS     copy model CLOSE macro\n         CLOSE (XDGDCB,),MF=(E,XDGCLOS)\n         EJECT ,\n*----------------------------------------------------------------------\n*  Show some info about each CSECT, and give TGDWA's address\n*----------------------------------------------------------------------\n*\n*  Issue the diagnostics AFTER input has been handled, so xxxxDBUG's\n*  debug byte has a user-selected value\n*  The SKIP=RCZERO skips the following code (thru BXLE) if the\n*  diagnostic level is less than 1.\n*\n         UDIAG 1,SKIP=RCZERO\n*\n*  Say where TGDWA is located\n*\n         UPSR  1,'U370DBUG TGDWA @ %',(R11)\n*\n*\n*  For each CSECT, issue message containing:\n*  debug level, address, CSECT name, assembly date and time\n*\n         ULOG  '<1>                 CSECT     ASMDATE  TIME      CPD   +\n                       DSA'\n         L     R5,TGD@VTAB                  @ VCON table header\n         LM    R5,R7,0(R5)                  index, incr, limit\nVCONLOOP DS    0H\n         MVI   XDGBUF,C' '                  blank out buffer\n         MVC   XDGBUF+1(L$XDGBUF-1),XDGBUF\n*\n         MVC   XDGBEYE,=C'<1> '             fake diag level prefix\n*\n         LH    R2,VTABOFF                   debug byte offset\n         LA    R15,TGDDLEV(R2)              @ debug byte\n         MVC   XDGBLVL,0(R15)               copy debug byte to msg\n*\n         L     R0,VTABVCON                  CSECT addr\n         LA    R1,XDGBADR                   display hex\n         UCALL U370HEX                      convert R0 to display hex\n*\n         LH    R0,VTCSL                     CSECT length\n         SLR   R1,R1\n         UCALL U370HEX                      convert R0 to display hex\n         STCM  R1,15,XDGBCSLN\n         MVI   XDGBCSLN-1,C'.'\n*\n         MVC   XDGBCS,VTABNAME              copy CSECT name\n*\n         ICM   R15,15,VTABVCON              @ CSECT or zero\n         BZ    MESSAGE\n*\n         MVC   XDGBCS,5(R15)                copy CSECT\n         MVC   XDGBDATE,13(R15)             copy asm date\n         MVC   XDGBTIME,21(R15)             copy asm time\n*\n         L     R0,VT@CPD                    CPD addr\n         LA    R1,XDGB@CPD                  display hex\n         UCALL U370HEX                      convert R0 to display hex\n*\n         MVI   XDGBCPDL-1,C'.'\n         LH    R0,VTCPDL                    CPD length\n         SLR   R1,R1                        display hex\n         UCALL U370HEX                      convert R0 to display hex\n         STCM  R1,15,XDGBCPDL\n*\n         L     R0,VT@SX                     SX  addr\n         LA    R1,XDGB@DSA                  display hex\n         UCALL U370HEX                      convert R0 to display hex\n*\n         MVI   XDGBDSAL-1,C'.'\n         LH    R0,VTDSAL                    SX  length\n         SLR   R1,R1                        display hex\n         UCALL U370HEX                      convert R0 to display hex\n         STCM  R1,15,XDGBDSAL\n*\nMESSAGE  ULOG  XDGBUF,L$XDGBUF              display message\n*\n         BXLE  R5,R6,VCONLOOP               next CSECT\n         EJECT ,\n*----------------------------------------------------------------------\n*  Return to caller with zero return code\n*----------------------------------------------------------------------\nRCZERO   DS    0H\n         L     R5,TGD@VTAB                  @ VCON table header\n         LM    R5,R7,0(R5)                  index, incr, limit\n         UDIAG 3,'U370DBUG DEBUG BYTES',TGDDLEV,TGDDEND\n         UDIAG 3,'U370DBUG CSECT table',(R5),(R7)\n         UPEND RC=0\n         EJECT ,\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\nMODLOPN  OPEN  (,),MF=L                model OPEN\nL$OPN    EQU   *-MODLOPN               l' model open\n*\nMODLCLOS CLOSE (,),MF=L                model CLOSE\nL$CLOS   EQU   *-MODLCLOS              l' model close\n*\nMODLDCB  DCB   DDNAME=X370DBUG,MACRF=GL,DSORG=PS,RECFM=FB,LRECL=80,    +\n               EODAD=EOFRTN\nL$DCB    EQU   *-MODLDCB\n*\n         LTORG ,\n         EJECT ,\n*----------------------------------------------------------------------\n*  XDGWA workarea\n*----------------------------------------------------------------------\nXDGWA    DSECT ,\nXDGSA    DS    18F\nXDGOPN   OPEN  0,MF=L\nXDGCLOS  CLOSE 0,MF=L\nXDGEOF   DS    X                       set not = X'00' on EOF\nXDGDCB   DCB   DDNAME=XXXXDBUG,MACRF=GL,DSORG=PS,RECFM=FB,LRECL=80,    +\n               EODAD=EOFRTN\nXDGBUF   DS    0C                      diagnostic message buffer\nXDGBEYE  DS    C'<1> '\nXDGBLVL  DS    C                       diagnostic level\n         DS    C\nXDGBADR  DS    CL8                     CSECT address\n         DS    C\nXDGBCSLN DS    CL4\n         DS    C\nXDGBID   DS    0C                      CSECT name, asm date/time\nXDGBCS   DS    CL8                     CSECT name\n         DS    C\nXDGBDATE DS    CL8                     CSECT assembly date\nXDGBTIME DS    CL7                     CSECT assembly time\nXDGB@CPD DS    CL8                     CPD address\n         DS    C\nXDGBCPDL DS    CL4\n         DS    C\nXDGB@DSA DS    CL8                     DSA addresss\n         DS    C\nXDGBDSAL DS    CL4\nL$XDGBUF EQU   *-XDGBUF                length of buffer\n*\n         DS    0D\nL$XDGWA  EQU   *-XDGWA\n*----------------------------------------------------------------------\n*  Input record\n*----------------------------------------------------------------------\nINREC    DSECT ,\nINAME    DS    CL8           CSECT name\n         DS    C             ignored\nINVAL    DS    C             Debug value - C'0' to C'9' (assumed)\nL$IN     EQU   *             length of significant part of input rec\n*\n         UVTAB MF=DSECT\n*\n         PRINT NOGEN\n         WATGD ,\n         DCBD  DSORG=PS,DEVD=DA\n*\n         PRINT ON,GEN\nU370DBUG UFINI DXDUDBUG,L$XDGWA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "U370HERC": {"ttr": 12037, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x83\\x00\\x83\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 131, "newlines": 131, "modlines": 0, "user": "XV0006"}, "text": "U370HERC TITLE 'Hercules-specific support'\n*\n* Copyright 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*>  To do:\n*\n*>  1) Finish writing this code\n*>     Currently it is not used\n*\n*----------------------------------------------------------------------\n         U#SET FUNC=UTIL\n*----------------------------------------------------------------------\n* Function:    Query the execution environment for such things as:\n*\n*              - APF authorization\n*              - Hercules emulator presence\n*\n* Entry: R0    ignored\n*        R1    ignored\n*\n* Exit:  R15 = return code = 00\n*\n*              TGDFLG2 valid\n*\n* Diagnostics:\n*              1 - entry/exit\n*              2 - APF authorization\n*\n* Notes:\n*\n*----------------------------------------------------------------------\n* Reg  DSECT    usage\n*----------------------------------------------------------------------\n* R2\n* R3\n* R4\n* R5\n* R6\n* R7\n* R8\n* R9\n* R10\n*----------------------------------------------------------------------\n         TITLE ' '\nU370HERC UPROC ID=UHRC,L=L$SA\n         STM   R0,R2,SAENTRY\n         UPEND ,\n         AGO   .DATA\n*----------------------------------------------------------------------\n*\n*----------------------------------------------------------------------\nINIT     DS    0H\n*<>      BAL   R8,HSNGL                          single-step Hercules\n*<>      IC    R1,SAMASK1              retrieve system's old mask\n*<>      EX    R1,RESET                return to normal PSW mask\n*<>      BAL   R14,STPROB              return to problem state\n*\n         LR    R14,R10                 restore caller's return addr\n         L     R15,SARUR15                restore caller's regs\n         LM    R2,R13,SARUR2              except R0, R1, and R14\n         BR    R14                     return to caller's ABEND SVC\n*\nRESET    STOSM SAMASK2,0\n         EJECT ,\n*----------------------------------------------------------------------\n*  Hercules-assisted debugging code\n*----------------------------------------------------------------------\nHSNGL    DS    0H\n         STM   R14,R1,SATEMP\n         BAL   R14,STSUPR              assure SUPERVISOR state\n         STNSM SAMASK1,B'10111100'     disable PER, I/O, EXTERNAL\n         TM    TGDFLG2,TGD2QRY         CPUid queried for Herc presence?\n         BO    HSNGL1\n*\n         L     R0,STSIR0\n         L     R1,STSIR1\n         L     R15,=F'4096'\n         LA    R14,SAX\n         LA    R14,X'FFF'(R15,R14)\n         N     R14,=X'FFFFF000'\n*\n*        STSI  SASYSIB                 store system info\n         DC    X'B27D',S(0)  S(0(R14)) store system info\n         BC    1,NOSYSIB               cc=3, no SYSIB stored\n*\n         USNAP 'U370HERC SYSIB',(R14),(R15)\n         OI    TGDFLG2,TGD2QRY         queried envir, TGD2HERC valid\n*\n* R0(00:07)    Version code = X'FF' when under VM and/or Hercules\n* R0(08:31)    CPU identification number\n* R1(00:15)    Model number\n* R1(16:31)    Maximum MCEL length\n*\nHSNGL1   DS    0H\n         DIAGNOSE HDI$SNGL             single step Hercules emulator\n         NOPR  0                       something for ifetch\nNOSYSIB  DS    0H\n         LM    R14,R1,SATEMP\n         BR    R8\n*\nSTSIR0   DC    F'0'\nSTSIR1   DC    F'1'\nHDI$NORM EQU   3840                    normal execution\nHDI$SNGL EQU   3844                    single step execution\n*----------------------------------------------------------------------\n*  State switch subroutines\n*----------------------------------------------------------------------\n         USTATE MF=GEN,STPROB=Y,STSUPR=Y\n.DATA    ANOP\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\n         LTORG ,\n*----------------------------------------------------------------------\n*  Dynamic savearea & workarea - based R13\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSAVREGS  DS    18F                standard MVS savearea\nSAENTRY  DS    3F                 R0:R2 from entry\nSATEMP   DS    4F\n         USTATE MF=L              gen STPROB/STSUPR workarea\n*\nSAX      DS    0D\nL$SA     EQU   *-SAVEAREA         length of savearea\n*\n         WATGD ,\n         EJECT ,\n*\nU370HERC UFINI DXDUHERC,L$SA\n.END     END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "U370HEX": {"ttr": 12040, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00;\\x00;\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 59, "newlines": 59, "modlines": 0, "user": "XV0006"}, "text": "U370HEX  TITLE 'Convert hex value in R0 into displayable hex'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n         U#SET FUNC=UTIL\n*----------------------------------------------------------------------\n* Function:    converts hex value in R0 into displayable hex\n*\n* Entry:  R0 = contents of R0 to be converted & displayed\n*         R1 = 0 or address of CL8 field to receive output\n*\n* Exit:   R15 =  0     everything is OK\n*         R0  =  1st word of output\n*         R1  =  2nd word of output\n*\n* Notes:  U370HEX is called by UTILABND, and is neither allowed to have\n*         errors in its code, nor to issue ABEND/UABEND.\n*\n*----------------------------------------------------------------------\nU370HEX  UPROC ID=UHEX,L=L$SAV\n*\n         ST    R0,WKFWORD              value to translate\n         UNPK  WKWORK,WKFWORD(5)       spread out digits\n         LA    R15,HEXCHAR             addressability game\n         LA    R14,C'0'\n         SR    R15,R14\n         TR    WKWORK,0(R15)           hexchar-c'0' translate to char\n         LTR   R1,R1                   caller supplied field addr?\n         BZ    RETREGS                 no, return regs only\n*\n         MVC   0(8,R1),WKWORK          copy input msg to caller's buf\n*\nRETREGS  LM    R0,R1,WKWORK            return values\n*\n         UPEND R0=PASS,R1=PASS,RC=0    return to caller\n*\n         LTORG ,\n*\nHEXCHAR  DC    C'0123456789ABCDEF'     Hex translate table\n*----------------------------------------------------------------------\n*  Dynamic savearea & workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSAVREGS  DS    18F\n*\nWKFWORD  DS    F,C\n*\n         DS    0F\nWKWORK   DS    CL9                     8 bytes plus trailing slop byte\n*\n         DS    0D                      align\nL$SAV    EQU   *-SAVEAREA              length of savearea\n*\n         PRINT NOGEN\n         WATGD ,\n         PRINT GEN\nU370HEX  UFINI DXDUHEX,L$SAV\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "U370LOG": {"ttr": 12042, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x92\\x00\\x92\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 146, "newlines": 146, "modlines": 0, "user": "XV0006"}, "text": "U370LOG  TITLE 'LOG output line to xxxxLOG ddname'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  Things to do:\n*----------------------------------------------------------------------\n         U#SET FUNC=UTIL\n*----------------------------------------------------------------------\n* Function: Write output line to xxxxLOG ddname\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         R0  =  text length\n*         R1  =  Address of text to be written\n*                when 0, xxxxLOG DCB will be closed.\n*\n*         TGDLOGD = xxxxLOG ddname\n*         If x'00', default is to build from appl name + 'LOG '\n*\n* Exit:   R15 = 0\n*\n* Abends: U0001 DCB didn't open\n*\n* Notes:  U370LOG maintains the xxxxLOG DCB, opening it as required.\n*----------------------------------------------------------------------\n* R2\n* R3     DCB\n* R4     input buffer\n* R5     length of input buffer\n* R6\n* R7\n* R8\n* R9     CPD\n* R10\n* R11    TGDWA\n* R12    base reg\n* R13    savearea\n*----------------------------------------------------------------------\nJUNK     DSECT ,\nJUNKDCB  DCB   DDNAME=XXXXLOG,                                         +\n               MACRF=PM,DSORG=PS,RECFM=VBA,                            +\n               LRECL=133+4,BLKSIZE=6144\nL$DCB    EQU   *-JUNKDCB\n*----------------------------------------------------------------------\n*  TPU - CPD user additions\n*----------------------------------------------------------------------\nTPU      DSECT ,                  task persistent data - user section\nTPUDCB   DS    XL(L$DCB)          xxxxLOG DCB\nL$TPU    EQU   *-TPU              length of user additions\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\nU370LOG  UPROC ID=ULOG,L=L$SA,CPD=(Y,L$TPU)\n         LR    R4,R0                        save text length\n         LR    R5,R1                        save text addr\n         U@CPD TPU,R9,ERR=NOCPD             locate CPD w/ DCB in it\n         LA    R3,TPUDCB                    @ DCB in CPD\n         USING IHADCB,R3\n*\n         LTR   R5,R5                        @ text, or CLOSE request\n         BZ    CLOSE\n*\n*  If the DCB hasn't been moved to the CPD yet, the next test is ok,\n*  although instead of testing the DCB it's testing x'00's\n*\n         TM    DCBOFLG1,DCBOFOPN            dcb open?\n         BO    NORMAL\n         EJECT ,\n*----------------------------------------------------------------------\n*  Initialize CPD with our DCB, open it\n*----------------------------------------------------------------------\n         MVC   SAOPN(L$OPN),MODLOPN         copy model OPEN\n         MVC   TPUDCB(L$DCB),MODLDCB        copy model DCB macro\n         MVC   DCBDDNAM(4),TGDEYE           copy appl prefix\n         CLI   TGDLOGD,0                    alternate DDname?\n         BE    *+10\n         MVC   DCBDDNAM,TGDLOGD             copy alternate DDname\n         OPEN  TPUDCB,MF=(E,SAOPN)\n         TM    DCBOFLG1,DCBOFOPN            opened?\n         BO    NORMAL\n         WTO   'U370LOG: xxxxLOG ddname did not open'\n         UABEND ,                           output DCB didn't open\n*----------------------------------------------------------------------\n*  Close xxxxLOG\n*----------------------------------------------------------------------\nCLOSE    DS    0H\n         TM    DCBOFLG1,DCBOFOPN            xxxxLOG open?\n         BNO   EXITRC0\n         MVC   SACLOS(L$CLOS),MODLCLOS      copy model CLOSE macro\n         CLOSE TPUDCB,MF=(E,SACLOS)         close xxxxLOG\n         FREEPOOL TPUDCB\n         B     EXITRC0\n*----------------------------------------------------------------------\n*  Normal write request\n*----------------------------------------------------------------------\nNORMAL   DS    0H\n         LA    R0,L'SAPFX+L'SARESV+L'SACC\n         AR    R4,R0\n         STH   R4,SAPFX                     set VB file's RDW\n         SR    R4,R0\n         MVI   SACC,C' '                    set carriage control\n         BCTR  R4,0\n         EX    R4,COPY                      copy record to buffer\n         LA    R0,SAPFX                     record address\n         PUT   TPUDCB                       write record\n*\nEXITRC0  SLR   R15,R15                      set good return code\nEXIT     UPEND ,\n*\nNOCPD    WTO   'U370LOG no CPD'\n         UABEND =X'FF'\n*\nCOPY     MVC   SABUF(*-*),0(R5)             executed\n*\nMODLOPN  OPEN  (,OUTPUT),MF=L          model OPEN\nL$OPN    EQU   *-MODLOPN               l' model open\n*\nMODLCLOS CLOSE (,),MF=L                model CLOSE\nL$CLOS   EQU   *-MODLCLOS              l' model close\n*\nMODLDCB  DCB   DDNAME=XXXXLOG,                                         +\n               MACRF=PM,DSORG=PS,RECFM=VBA,                            +\n               LRECL=133+4,BLKSIZE=6144\n*\n         LTORG ,\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\n         DS    18F\nSAOPN    OPEN  (,),MF=L\nSACLOS   CLOSE (,),MF=L\n         DS    0F\nSAPFX    DS    H                       rdw length (includes l' rdw)\nSARESV   DS    H                       rdw reserved\nSACC     DS    C' '                    asa carriage control\nSABUF    DS    CL133                   output record\n         DS    0D\nL$SA     EQU *-SAVEAREA\n         EJECT ,\n*\n         WATGD ,\n         PRINT NOGEN\n         DCBD  DSORG=PS,DEVD=DA\n         PRINT GEN\nU370LOG  UFINI DXDULOG,L$SA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "U370PSR": {"ttr": 12046, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00x\\x00x\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 120, "newlines": 120, "modlines": 0, "user": "XV0006"}, "text": "U370PSR  TITLE 'PRINT String and Register 0'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  To do: YES\n*  1) Add AL1(count) after % sign (UPSR), if count > 1 R0 @ list\n*     of fullwords to display, rather than R0 contents displayed\n*----------------------------------------------------------------------\n         U#SET FUNC=UTIL\n*----------------------------------------------------------------------\n* Function:    converts R0 into displayable hex, then\n*              appends converted data onto input message text,\n*              finally calls XMITLOG to output completed\n*              text.\n*\n* Entry:  R0 = contents of R0 to be converted & displayed\n*         R1 = address of message text, delimited by trailing % sign.\n*\n* Exit:   R15 =  0     everything is OK\n*                else  error\n*\n*----------------------------------------------------------------------\n* R2     ptr to currently scanning char in input buffer\n* R3     max chars allowed to be scanned\n* R4     length of input message text (not including % sign)\n* R5     ptr to slot for converted R0 in our buffer\n* R6\n* R7\n* R8     input R0\n* R9     input message text ptr\n* R10\n*----------------------------------------------------------------------\n         TITLE ' '\nU370PSR  UPROC ID=UPSR,L=L$SAV\n         EJECT ,\n*\n         LR    R8,R0              save input R0\n         LA    R9,0(R1)           save msg text ptr\n*----------------------------------------------------------------------\n*  Convert R0 contents to displayable hex\n*----------------------------------------------------------------------\nXLATE    DS    0H\n         ST    R0,WKFWORD              value to translate\n         UNPK  WKWORK,WKFWORD(5)       spread out digits\n         LA    R15,HEXCHAR\n         LA    R14,C'0'\n         SR    R15,R14\n         TR    WKWORK,0(R15)           hexchar-c'0' translate to char\n*----------------------------------------------------------------------\n*  Find end of input message\n*----------------------------------------------------------------------\nL$MAXIN  EQU   120                maximum allowed input text length\n*\n         LR    R2,R9                   @ beginning of input msg txt\n         LA    R3,L$MAXIN\nSCAN     DS    0H\n         CLI   0(R2),C'%'\n         BE    HIT\n*\n         LA    R2,1(,R2)\n         S     R3,=F'1'           too many chars scanned?\n         BP    SCAN               not yet, ok to keep looking\n*\n*----------------------------------------------------------------------\n*  Copy input message (less % sign) to our buffer\n*----------------------------------------------------------------------\nHIT      DS    0H\n         MVI   WKMSG,C' '\n         MVC   WKMSG+1(L'WKMSG-1),WKMSG\n*\n         LR    R4,R2\n         SR    R4,R9              calc msg length\n*        BCTR  R4,0               minus one for execute\n         EX    R4,EXMVC           copy input msg to our buffer\n*----------------------------------------------------------------------\n*  Append displayable hex contents of R0 to our buffer\n*----------------------------------------------------------------------\n         LA    R5,WKMSG(R4)       @ spot to put data\n         MVC   0(8,R5),WKWORK     append converted data\n         LA    R5,8(,R5)          past last char\n         LA    R0,WKMSG\n         SR    R5,R0              length of message\n*----------------------------------------------------------------------\n*  Output our buffer\n*----------------------------------------------------------------------\n         ULOG WKMSG,(R5)          print out the message\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\nEXIT     UPEND ,                  RETURN to caller\n*\nEXMVC    MVC   WKMSG(*-*),0(R9)   copy input msg to our buffer\n*\n         EJECT ,\n*\n         LTORG ,\n*\n*  Placed last so it's addressable as hexchar-c'0'\n*  Oops, still not enough ... use base reg instead\n*\nHEXCHAR  DC    C'0123456789ABCDEF'     Hex translate table\n*----------------------------------------------------------------------\n*  Dynamic savearea & workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSAVREGS  DS    18F\nWKMSG    DS    CL(L$MAXIN+9)      input msg, blank, 8 bytes of hex\nWKFWORD  DS    F\n         DS    F                  slop ... must be behind WKFWORD\nWKWORK   DS    CL9                8 bytes plus trailing slop byte\n         DS    XL20                    spare\n         DS    0D                      align\nL$SAV    EQU   *-SAVEAREA              length of savearea\n         EJECT ,\n         WATGD ,\n*\n         PRINT GEN\nU370PSR  UFINI DXDUPSR,L$SAV\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "U370QENV": {"ttr": 12291, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x010\\x010\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 304, "newlines": 304, "modlines": 0, "user": "XV0006"}, "text": "U370QENV TITLE 'Query execution environment'\n*\n*  Hercules 2.16.5 doesn't seem to understand STSI in S/370 mode,\n*  so this circumvents the issue of detecting Hercules' presence\n*\n         GBLB  &G#HERC       0=issue STSI 1=assume HERC presence\n*\n* Copyright 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  To do:\n*----------------------------------------------------------------------\n         U#SET FUNC=UTIL\n*----------------------------------------------------------------------\n* Function:    UQENV macro support\n*\n*              Query the execution environment for:\n*\n*              - APF authorization\n*\n*              - Hercules emulator presence (optional)\n*                Requires APF authorization\n*\n* Entry: Problem or supervisor state, key 8\n*\n*        R0    bits 00-07 - options\n*\n*              Following equates defined in U#EQU macro:\n*\n*              QNV$PAGE - leave 4K page allocated (TGDPGLV, TGD@PAGE)\n*                         See QNV$SPID for the subpool (and hence the\n*                         page's attributes) in Data Areas section.\n*\n*              QNV$QHEP - query Hercules emulator presence\n*                         The test requires APF authorization, which\n*                         not all xxxx370 applications may possess.\n*\n*              bits 08-31 - presently ignored\n*\n*        R1    presently ignored\n*        R2    presently ignored\n*\n* Exit:  Supervisor state (if we're authorized)\n*        R15 = return code = 00\n*              TGDFLG2 valid\n*\n* Diagnostics:\n*              2 - APF authorization\n*              3 - Hercules presence\n*              8 - entry/exit\n*              9 - show SA at exit\n*\n* Notes:  We don't establish an initial ESTAE environment via UPROC\n*         since we want UTILSTAE to issue ESTAE with supervisor state\n*         and key 0, meaning that all the RRRs get called that way.\n*         xxxx370 must pay attention to when it establishes its ESTAE\n*         so this happens correctly.  If we're not APF authorized,\n*         none of that matters; the RRRs get driven in problem state\n*         with TCB protect key (8).\n*\n*         The UQENV macro reminds CSECTs with UPROC ID=MAIN of this\n*         via a MNOTE.\n*\n*         TGD@PAGE may be used by whatever CSECTs require it, as long\n*         as they're aware the page is not exclusively theirs to use\n*         If the page is not allocated, TGD@PAGE=X'00'\n*\n*         Users of TGDFLG2 are urged to check both the 'valid' bit\n*         and the related bit to assure correctness.\n*----------------------------------------------------------------------\n* Reg  DSECT    usage\n*----------------------------------------------------------------------\n* R2\n* R3            @ 4KB page (TGD@PAGE)\n* R4            4096 (4K) constant\n* R5            TGDPGLV: subpool (bits 00:07); length (bits 16:31)\n* R6\n* R7\n* R8\n* R9  CPD       @ CPD\n* R10\n*----------------------------------------------------------------------\n         TITLE ' '\nU370QENV UPROC ID=UQNV,L=L$SA,CPD=(Y,0,ESTAE)\n*----------------------------------------------------------------------\n         STM   R0,R2,SAENTRY           save entry parms\n         MVI   TGDFLG2,0               invalidate any previous results\n*                                      (might be called more than once)\n*----------------------------------------------------------------------\n*  Check for APF authorization (TGD2APF)\n*----------------------------------------------------------------------\n         TESTAUTH FCTN=1               APF authorized?\n         LTR   R15,R15\n         BZ    AUTH\n*\n         UDIAG 2,'QENV not APF authorized'\n         B     AUTHDONE\n*\nAUTH     DS    0H\n         UDIAG 2,'QENV APF authorized'\n         OI    TGDFLG2,TGD2APF         APF authorized\n         BAL   R14,STSUPR              supervisor state\n*\nAUTHDONE DS    0H\n         OI    TGDFLG2,TGD2VAPF        TGD2APF bit now valid\n         EJECT ,\n*----------------------------------------------------------------------\n*  Determine whether Hercules emulator is present (TGD2HEP)\n*----------------------------------------------------------------------\n         TM    SAR0B0,QNV$QHEP         query Herc presence?\n         BNO   QNVNHEP                 no, br\n         AIF   (NOT &G#HERC).HERCON\n         UDIAG 3,'QENV checking for Hercules'\n*\n*  Don't check APF authorization, we prefer an ABEND if not authorized\n*  If this is the first time U370QENV has been called, and no other\n*  CSECT has established an ESTAE, the application goes down which is\n*  probably the right thing to do.\n*\n         BAL   R14,STSUPR              supervisor state\n         USTATE KEY=0                  subpool we want needs key 0\n         UESTAE STSIBAD                switch ESTAE routines\n*\n*  Allocate 4k page-aligned storage\n*\n         SLR   R4,R4                   in case already allocated\n         ICM   R3,15,TGD@PAGE          already allocated?\n         BNZ   USEPAGE                 yes, use it\n*\n         OI    SAFLG1,SA1GM            indicate GETMAIN\n         L     R4,=F'4096'             4K\n         LR    R5,R4\n         ICM   R5,8,=AL1(QNV$SPID)     TGD@PAGE subpool\n         GETMAIN RU,LV=(R4),BNDRY=PAGE,SP=QNV$SPID\n         LR    R3,R1\n         ST    R5,TGDPGLV              FREEMAIN LV=(0) parm\n         ST    R3,TGD@PAGE             save for others to use\n*\n*  Use the STSI instruction (only valid on S/390 & above on real\n*  hardware) to detect the Hercules emulator's presence\n*  Since STSI requires 'grande' registers, we're not going to\n*  expect much of anything back from STSI\n*  Just the fact that we don't take an operation exception is\n*  enough to detect Hercules' presence\n*\nUSEPAGE  DS    0H\n         LM    R0,R1,STSIPRMS          STSI R0, R1 - parms\n*\n*  STSI instruction\n*\n         DC    X'B27D',S(0)            store system information\n         BC    1,NOSYSIB               cc=3, no SYSIB stored\n*\n         USNAP 'UTILHERC herc SYSIB!',(R3),(R4)\n*\nNOSYSIB  DS    0H\n.HERCON  ANOP\n         UDIAG 3,'QENV Hercules present'\n         OI    TGDFLG2,TGD2VHEP+TGD2HEP     Hercules emulator present\nQNVNHEP  DS    0H\n         STIDP D2     ** temp **\n         USNAP 'QENV D2',D2,L$D2\n         EJECT ,\n*----------------------------------------------------------------------\n*  Check caller's exit options\n*----------------------------------------------------------------------\nRESTART  DS    0H                      RRR resumes here\n         TM    SAR0B3,QNV$PAGE         leave page allocated?\n         BO    EXIT                    yes, br\n         TM    SAFLG1,SA1GM            did we allocate it?\n         BNO   EXIT                    no, leave it alone\n*\n         LM    R0,R1,TGDPGPRM          restore FREEMAIN parms\n         FREEMAIN R,LV=(0),A=(1)       release storage\n         XC    TGDPGLV,TGDPGLV\n         XC    TGD@PAGE,TGD@PAGE       indicate not allocated\n         NI    SAFLG1,255-SA1GM        indicate FREEMAIN'd\n*\nEXIT     DS    0H\n         UDIAG 9,'QENV SA',(SAREG),L$SA\n         UDIAG 8,'QENV exit'\n         UPEND ,                       return to caller\n         EJECT ,\n*----------------------------------------------------------------------\n*  ESTAE retry routine\n*  U370STAE calls this a RRR - Remote Recovery Routine\n*  Admittedly somewhat excessive, serves as demo & test case\n*----------------------------------------------------------------------\n*\n*  Notes:  There was a bug in U370QENV whereby it would ABENDS30A-1\n*  on the FREEMAIN due to A=(R3) being invalid (following an ABENDS0C1\n*  on the STSI instruction).  The bug appears to be repaired, but it\n*  is worth noting that the registers you get in RRR code aren't the\n*  regs you might expect; they're from the last call to U370STAE.\n*  And only R2-R12 at that.  Well worth remembering....\n*\n*  Specifically the bug was repaired by replacing\n*\n*        FREEMAIN R,LV=(R5),A=(R3)\n*\n*  with\n*\n*        LM    R0,R1,TGDPGPRM          restore FREEMAIN parms\n*        FREEMAIN R,LV=(0),A=(1)       release storage\n*\nSTSIBAD  DS    0H                      handle ABEND\n         UDIAG 2,'QENV no Hercules'\n         OI    TGDFLG2,TGD2VHEP        TGD2HEP bit valid\n         UESTAE RETRY2                 trim RESTART path\n         B     RESTART\n*\n*  Request a SNAP next time U370QENV runs through U370STAE.SUPPORT\n*\nRETRY2   DS    0H                      handle ABEND\n         UDIAG 2,'QENV RETRY2'\n         OI    TGDFLG2,TGD2VHEP        TGD2HEP bit valid\n         U@CPD ,R10,ERR=NOCPD          find our CPD\n         LA    R0,SNAPMFL              addr of SNAP parmlist\n         ST    R0,CPDE@SNP             for U370STAE.SUPPORT\n         DROP  R10\n         UESTAE RETRY3,SNAP=Y          enable TGDE@SNP\n         B     RESTART                 try FREEMAIN again\n*\n*  Note: If the SNAP parmlist is placed in our SAVEAREA, it will\n*  be cleared next time UPROC executes.  Normally U370QENV is only\n*  called once per TCB, at startup; however, the UPROC caveat is\n*  certainly applicable to other CSECTS.\n*\n*  You might want to place the SNAP parmlist in SAVEAREA (or the\n*  CPDUSER area) when you want to specify a STORAGE list of\n*  addresses to SNAP.\n*\nSNAPMFL  SNAP  MF=L,SDATA=(CB,ERR,DM),PDATA=ALL\n*\nRETRY3   DS    0H                      handle ABEND\n         UDIAG 2,'QENV RETRY3'\n         OI    TGDFLG2,TGD2VHEP        TGD2HEP bit valid\n         UESTAE BAIL                   trim again (SNAP=NO default)\n         B     EXIT                    OK, really try to exit\n*\n*  Catastrophic CSECT failure\n*\nBAIL     DS    0H\n         UDIAG 2,'QENV BAIL'\n         UESTAE 0                      disable CSECT's ESTAE\n         UABEND =X'FF'\n*\nNOCPD    DS    0H\n         UDIAG 2,'QENV no CPD'\n         UESTAE 0                      disable CSECT's ESTAE\n         UABEND =X'F0'\n*----------------------------------------------------------------------\n*  Generate state switch subroutines\n*----------------------------------------------------------------------\n         USTATE MF=GEN,STSUPR=Y\n         EJECT ,\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\nSTSIR0   DC    F'0'                    STSI parm reg 0\nSTSIR1   DC    F'1'                    STSI parm reg 1\nSTSIPRMS EQU   STSIR0,8                LM target\n*\n*  TGD@PAGE subpool id\n*\nQNV$SPID EQU   253                     Space within LSQA\n*                                      Job oriented\n*                                      Fixed\n*                                      Protection key=0\n*                                      Task-related\n*                                      Not fetch-protected\n*                                      Swappable\n*\n*  Allows a task running in key 0 to acquire fixed, accountable,\n*  protected storage in the LSQA for the user's region that is\n*  job-oriented and freed when the task terminates.\n*\n         LTORG ,\n*----------------------------------------------------------------------\n*  Dynamic savearea & workarea - based R13\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSASA     DS    18F                standard MVS savearea\nSAENTRY  DS    3F                 R0:R2 from entry\nSAR0     EQU   SAENTRY+(R0*4),4\nSAR0B0   EQU   SAR0+0,1\nSAR0B1   EQU   SAR0+1,1\nSAR0B2   EQU   SAR0+2,1\nSAR0B3   EQU   SAR0+3,1\nSAR1     EQU   SAENTRY+(R1*4),4\nSAR2     EQU   SAENTRY+(R2*4),4\n         USTATE MF=L              USTATE workarea\nSAFLG1   DS    X                  U370QENV flags\nSA1GM    EQU   128                GETMAIN issued\nSAFLG2   DS    X                  TGDFLG2 copied, show for diaglvl 3\nD2       DS    8D\nL$D2     EQU   *-D2\nSAX      DS    0D\nL$SA     EQU   *-SAVEAREA         length of savearea\n*\n         WATGD ,\n*\nU370QENV UFINI DXDUQENV,L$SA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "U370QSS": {"ttr": 12297, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\xb4\\x00\\xb4\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 180, "newlines": 180, "modlines": 0, "user": "XV0006"}, "text": "U370QSS  TITLE 'Query Subsystem'\n*\n* Copyright 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  To do:\n*  1) Call DISPSS for each subsys (loop thru subsys again)\n*----------------------------------------------------------------------\n         U#SET FUNC=UTIL\n*----------------------------------------------------------------------\n* Function:    Diagnostic aid - display subsys info\n*              Currently controlled by debug level\n*\n* Entry: Enabled, Supervisor state, Key 8\n*        R0    ignored\n*        R1    ignored\n*\n* Exit:  Enabled, Supervisor state, Key 8\n*        R15 = return code = 00\n*\n* Diagnostics:\n*              1 - ABEND retry entered message\n*              2 - subsys info\n*\n* Notes:\n*----------------------------------------------------------------------\n* Reg  DSECT    usage\n*----------------------------------------------------------------------\n* R2   CVT\n* R3   JESCT\n* R4   SSCT     SSCVT\n* R5   SSVT\n* R6\n* R7\n* R8\n* R9            subroutine scratch\n* R10           internal linkage\n*----------------------------------------------------------------------\n         TITLE ' '\nU370QSS  UPROC ID=UQQQ,L=L$SA\n         UDIAG 1,'QSS entered'\n*----------------------------------------------------------------------\n         STM   R0,R2,SAENTRY           save entry parms\n         UDIAG 2,SKIP=EXIT             leave now if no real output\n         BAL   R10,CLEAR               clear line to blanks\n         BAL   R10,PRINTX              print blank line\n         UDIAG 2,'QSS:'               output follows\n*----------------------------------------------------------------------\n*  Print CVT, JESCT, SS-name, SSCVT, SSVT\n*----------------------------------------------------------------------\n         USING PSA,0\n         MVC   SAM1TXT2(3),=C'CVT'\n         MVC   SAM1TXT3(5),=C'JESCT'\n         MVC   SAM1TXT4(6),=C'SUBSYS'\n         MVC   SAM1TXT5(5),=C'SSCVT'\n         MVC   SAM1TXT6(8),=C'SSCTSSVT'\n         MVC   SAM1TXT7(8),=C'SSCTSUSE'\n         MVC   SAM1TXT8(8),=C'SSCTFLG1'\n         BAL   R10,PRINT               print title line\n*\nQCVT     L     R2,FLCCVT               @ CVT\n         USING CVT,R2\n         LR    R0,R2\n         LA    R1,SAM1TXT2\n         BAL   R10,FMTHEX\n*\nQJESCT   L     R3,CVTJESCT             @ JESCT\n         USING JESCT,R3\n         LR    R0,R3\n         LA    R1,SAM1TXT3\n         BAL   R10,FMTHEX\n*\n         L     R4,JESSSCT              @ 1st SSCVT\n         USING SSCT,R4\nCHASLOOP DS    0H\n         MVC   SAM1TXT4(4),SSCTSNAM    subsys name\n         LR    R0,R4\n         LA    R1,SAM1TXT5\n         BAL   R10,FMTHEX\n*\n         L     R5,SSCTSSVT             @ subsystem's SSVT\n         USING SSVT,R5\n         LR    R0,R5\n         LA    R1,SAM1TXT6\n         BAL   R10,FMTHEX\n*\n         L     R0,SSCTSUSE             @ subsystem's user field\n         LA    R1,SAM1TXT7\n         BAL   R10,FMTHEX\n*\n         L     R0,SSCTFLG1             flag byte + reserved\n         LA    R1,SAM1TXT8\n         BAL   R10,FMTHEX\n*\n         BAL   R10,PRINT               print data line\n*\n         ICM   R4,15,SSCTSCTA          @ next subsystem's SSCVT\n         BNZ   CHASLOOP\n         EJECT ,\n*\nEXIT     DS    0H\n         UDIAG 1,'QSS exit'\n         UPEND ,                       return to caller\n         EJECT ,\n*----------------------------------------------------------------------\n*  Format fullword (display hex) - R0 = value, R1 @ output slot\n*----------------------------------------------------------------------\nFMTHEX   DS    0H\n         UCALL U370HEX\n         BR    R10\n*----------------------------------------------------------------------\n*  DISPSS  - Display SSCVT (R4), SSVT (R5); R9 scratch\n*----------------------------------------------------------------------\nDISPSS   DS    0H\n         UDIAG 3,'QSS SSCVT',(R4),24\n         LTR   R5,R5\n         BZR   R10\n         LH    R9,SSVTFNUM             # function routines\n         SLL   R9,2                    times size of A-con\n         LA    R9,256+4(,R9)           plus matrix & overhead\n         UDIAG 4,'QSS SSVT',(R5),(R9)\n         UDIAG 3,' '\n         BR    R10\n*----------------------------------------------------------------------\n*  Print message\n*----------------------------------------------------------------------\nPRINT    DS    0H\n         MVC   SAM1TXT1,=C'<2>'\nPRINTX   UDIAG 2,SAMSG,L$SAMSG\nCLEAR    MVI   SAMSG,C' '\n         MVC   SAMSG+1(L$SAMSG-1),SAMSG\n         BR    R10\n         LTORG ,\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\n         LTORG ,\n*----------------------------------------------------------------------\n*  Dynamic savearea & workarea - based R13\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSASA     DS    18F                standard MVS savearea\nSAENTRY  DS    3F                 R0:R2 from entry\n*\nSAM1TXT1 DS    C'<3> '\nSAM1TXT2 DS    CL9                CVT\n         DS    CL2\nSAM1FRST DS    0C\nSAM1TXT3 DS    CL8                JESCT\n         DS    CL2\nSAM1TXT4 DS    CL8                SS name\n         DS    CL2\nSAM1TXT5 DS    CL8                @ SSCVT\n         DS    CL2\nSAM1TXT6 DS    CL8                SSCTSSVT\n         DS    CL2\nSAM1TXT7 DS    CL8                SSCTSUSE\n         DS    CL2\nSAM1TXT8 DS    CL8                SSCTFLG1\n         DS    CL2\nSAM1TXTP DS    CL2\n         DS    CL2\nSAM1TXTF DS    CL11\nSAM1LAST DS    0C\nL$SAMSG  EQU   *-SAM1TXT1\nSAMSG    EQU   SAM1TXT1,L$SAMSG\nSAX      DS    0D\nL$SA     EQU   *-SAVEAREA         length of savearea\n*\n         WATGD ,\n*\n         PRINT NOGEN\n         IHAPSA ,\n         CVT   DSECT=YES,LIST=NO\n         IEFJESCT ,\n         IEFJSCVT ,\n         IEFJSSVT ,\n*\nU370QSS  UFINI DXDUQSS,L$SA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "U370QTCB": {"ttr": 12301, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x01\\x12\\x01\\x12\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 274, "newlines": 274, "modlines": 0, "user": "XV0006"}, "text": "U370QTCB TITLE 'Query TCB'\n*\n* Copyright 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  To do:\n*  1) Use STATUS macro (?) to quiesce other TCBs while examining\n*     Lock(s)?\n*----------------------------------------------------------------------\n         U#SET FUNC=UTIL\n*----------------------------------------------------------------------\n* Function:    Diagnostic aid\n*              Currently controlled by debug level\n*\n* Entry: R0    ignored\n*        R1    ignored\n*\n* Exit:  R15 = return code = 00\n*\n* Diagnostics:\n*              1 - ABEND retry entered message\n*              2 - TCB summary\n*              3 - dump each TCB\n*              8 - dump ASCB\n*              9 - dump ASXB\n*\n* Notes:\n*----------------------------------------------------------------------\n* Reg  DSECT    usage\n*----------------------------------------------------------------------\n* R2\n* R3\n* R4   TCB\n* R5\n* R6\n* R7\n* R8            internal linkage\n* R9            subroutine scratch\n* R10           internal linkage\n*----------------------------------------------------------------------\nTPU      DSECT ,\nTPUFLG1  DS    X             status flags\nTPU1RRR  EQU   1             ESTAE established (only needs doing once)\n         DS    0D\nL$TPU    EQU   *-TPU\n         TITLE ' '\nU370QTCB UPROC ID=UQTC,L=L$SA,CPD=(Y,L$TPU,ESTAE)\n*----------------------------------------------------------------------\n         STM   R0,R2,SAENTRY           save entry parms\n         UDIAG 2,SKIP=EXIT             leave now if no real output\n         BAL   R10,CLEAR               clear line to blanks\n         BAL   R10,PRINTX              print blank line\n         UDIAG 2,'QTCB:'               output follows\n         U@CPD TPU,R10,ERR=EXIT\n         TM    TPUFLG1,TPU1RRR         ESTAE established?\n         BO    QGO\n         UESTAE BAIL                   just leave if ABEND\n         OI    TPUFLG1,TPU1RRR         ESTAE established\nQGO      DS    0H\n         DROP  R10\n*----------------------------------------------------------------------\n*  Print ASCB, ASXB; TCBs: current, first & last\n*----------------------------------------------------------------------\n         USING PSA,0\n         MVC   SAM1TXT2(4),=C'ASCB'\n         MVC   SAM1TXT3(4),=C'ASXB'\n         MVC   SAM1TXT4(7),=C'PSATOLD'\n         MVC   SAM1TXT5(8),=C'ASXBFTCB'\n         MVC   SAM1TXT6(8),=C'ASXBLTCB'\n         BAL   R10,PRINT               print title line\n*\nQASCB    L     R2,PSAAOLD              @ current ASCB\n         USING ASCB,R2\n         LR    R0,R2\n         LA    R1,SAM1TXT2\n         BAL   R10,FMTHEX\n*\nQASXB    L     R3,ASCBASXB             @ ASXB\n         USING ASXB,R3\n         LR    R0,R3\n         LA    R1,SAM1TXT3\n         BAL   R10,FMTHEX\n*\nQCURTCB  L     R0,PSATOLD              @ current TCB\n         LA    R1,SAM1TXT4\n         BAL   R10,FMTHEX\n*\nQFTCB    L     R0,ASXBFTCB             @ first TCB\n         LA    R1,SAM1TXT5\n         BAL   R10,FMTHEX\n*\nQLTCB    L     R0,ASXBLTCB             @ last  TCB\n         LA    R1,SAM1TXT6\n         BAL   R10,FMTHEX\n*\n         BAL   R10,PRINT               print data line\n         EJECT ,\n*----------------------------------------------------------------------\n*  SNAP ASCB, ASXB, current TCB\n*----------------------------------------------------------------------\nSNAP     DS    0H\n         UDIAG 8,'QTCB ASCB',(R2),L$ASCB\n         UDIAG 9,'QTCB ASXB',(R3),L$ASXB\n         L     R4,PSATOLD              @ current TCB\n         USING TCB,R4\n         BAL   R10,DISPTCB\n         EJECT ,\n*----------------------------------------------------------------------\n*  Chase TCB chain\n*----------------------------------------------------------------------\nCHASE    BAL   R10,PRINT\n         MVI   SAM1FRST,C'-'\n         MVC   SAM1FRST+1(SAM1LAST-SAM1FRST-1),SAM1FRST\n         MVC   SAM1TXT5(11),=C'TCB SUMMARY'\n         BAL   R10,PRINT\n         MVC   SAM1TXT2(3),=C'TCB'\n         MVC   SAM1TXT3(3),=C'CMP'\n         MVC   SAM1TXT4(3),=C'OTC'\n         MVC   SAM1TXT5(3),=C'LTC'\n         MVC   SAM1TXT6(3),=C'NTC'\n         MVC   SAM1TXT7(5),=C'JSTCB'\n         MVC   SAM1TXT8(4),=C'BACK'\n         MVC   SAM1TXTP(2),=C'PK'\n         MVC   SAM1TXTF(4),=C'FLGS'\n         BAL   R10,PRINT\n*\n         L     R4,ASXBFTCB             @ first TCB\nCHASLOOP BAL   R8,SUMTCB\n         ICM   R4,15,TCBTCB            @ next TCB\n         BNZ   CHASLOOP\n*\nEXIT     DS    0H\n         UPEND ,                       return to caller\n         EJECT ,\n*----------------------------------------------------------------------\n*  TCB summary - setup output - R8 return R4 TCB\n*----------------------------------------------------------------------\nSUMTCB   DS    0H\n         LR    R0,R4\n         LA    R1,SAM1TXT2\n         BAL   R10,FMTHEX\n*\n         L     R0,TCBCMP\n         LA    R1,SAM1TXT3\n         BAL   R10,FMTHEX\n*\n         L     R0,TCBOTC\n         LA    R1,SAM1TXT4\n         BAL   R10,FMTHEX\n*\n         L     R0,TCBNTC\n         LA    R1,SAM1TXT5\n         BAL   R10,FMTHEX\n*\n         L     R0,TCBLTC\n         LA    R1,SAM1TXT6\n         BAL   R10,FMTHEX\n*\n         L     R0,TCBJSTCB\n         LA    R1,SAM1TXT7\n         BAL   R10,FMTHEX\n*\n         L     R0,TCBBACK\n         LA    R1,SAM1TXT8\n         BAL   R10,FMTHEX\n*\n         IC    R0,TCBPKF\n         SLR   R1,R1\n         BAL   R10,FMTHEX\n         STCM  R1,3,SAM1TXTP\n*\n*  Divide TCBFLGS: FLG1-FLG3, FLG4-FLG5\n*  This places the dispatchability flags together nicely\n*\n         ICM   R0,15,TCBFLGS           C'112233-4455' (easier to read)\n         SLR   R1,R1                    +0123456789A\n         BAL   R10,FMTHEX\n         STCM  R0,15,SAM1TXTF+00         0000\n         STCM  R1,12,SAM1TXTF+04             11\n         MVI   SAM1TXTF+06,C'-'\n         STCM  R1,03,SAM1TXTF+07                11\n         ICM   R0,15,TCBFLGS+4\n         SLR   R1,R1\n         BAL   R10,FMTHEX\n         STCM  R0,12,SAM1TXTF+09                  00\n*\n         BAL   R10,PRINT\n         BR    R8\n*----------------------------------------------------------------------\n*  Format fullword (display hex) - R0 = value, R1 @ output slot\n*----------------------------------------------------------------------\nFMT@TCB  DS    0H\n         LR    R0,R4                   @ TCB\n         LA    R1,SAM1TXT3\nFMTHEX   DS    0H\n         UCALL U370HEX\n         BR    R10\n*----------------------------------------------------------------------\n*  DISPTCB - Display TCB (R4); R9 scratch\n*----------------------------------------------------------------------\nDISPTCB  DS    0H\n         LA    R9,TCBPXLEN\n         SR    R4,R9\n         UDIAG 3,'QTCB TCB prefix',(R4),TCBPXLEN\n         AR    R4,R9\n         UDIAG 3,'QTCB TCB proper',(R4),TCBMNLEN\n         L     R9,TCBEXT2\n         UDIAG 3,'QTCB TCB extension',(R9),TCBX2LEN\n         UDIAG 3,' '\n         BR    R10\n*----------------------------------------------------------------------\n*  Print message\n*----------------------------------------------------------------------\nPRINT    DS    0H\n         MVC   SAM1TXT1,=C'<2>'\nPRINTX   UDIAG 2,SAMSG,L$SAMSG\nCLEAR    MVI   SAMSG,C' '\n         MVC   SAMSG+1(L$SAMSG-1),SAMSG\n         BR    R10\n*----------------------------------------------------------------------\n*  ESTAE \"retry\" routine\n*----------------------------------------------------------------------\nBAIL     DS    0H\n         UDIAG 1,'QTCB BAIL; results incomplete'\n         B     EXIT\n         LTORG ,\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\n         LTORG ,\n*----------------------------------------------------------------------\n*  Dynamic savearea & workarea - based R13\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSASA     DS    18F                standard MVS savearea\nSAENTRY  DS    3F                 R0:R2 from entry\n*\nSAM1TXT1 DS    C'<3> '\nSAM1TXT2 DS    CL9                TCB addr\n         DS    CL2\nSAM1FRST DS    0C\nSAM1TXT3 DS    CL8                TCBCMP\n         DS    CL2\nSAM1TXT4 DS    CL8                TCBOTC\n         DS    CL2\nSAM1TXT5 DS    CL8                TCBNTC\n         DS    CL2\nSAM1TXT6 DS    CL8                TCBLTC\n         DS    CL2\nSAM1TXT7 DS    CL8                TCBJSTCB\n         DS    CL2\nSAM1TXT8 DS    CL8                TCBBACK\n         DS    CL2\nSAM1TXTP DS    CL2                TCBPKF\n         DS    CL2\nSAM1TXTF DS    CL11               TCBFLGS: 112233 4455\nSAM1LAST DS    0C\nL$SAMSG  EQU   *-SAM1TXT1\nSAMSG    EQU   SAM1TXT1,L$SAMSG\nSAX      DS    0D\nL$SA     EQU   *-SAVEAREA         length of savearea\n*\n         WATGD ,\n*\n         PRINT NOGEN\n         IHAPSA ,\n         IHAASCB ,\nL$ASCB   EQU   *-ASCB\n         IHAASXB ,\nL$ASXB   EQU   *-ASXB\n         IKJTCB DSECT=YES,LIST=NO\n*\nU370QTCB UFINI DXDUQTCB,L$SA\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "U370SDWA": {"ttr": 12549, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x01\\\\\\x01\\\\\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 348, "newlines": 348, "modlines": 0, "user": "XV0006"}, "text": "U370SDWA TITLE 'ESTAE RTM SDWA analysis'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n         U#SET FUNC=UTIL\n*----------------------------------------------------------------------\n* Function:    Issue various diagnostic messages when U370STAE calls\n*              us after an ABEND has been intercepted\n*\n* Entry:  R0 =\n*         R1 = address of SDWA\n*\n* Exit:   R15 = 00\n*\n* Diagnostics:\n*\n*               1 -\n*               2 - summary info\n*               3 -\n*               4 - show reg details (U370VADR)\n*               5 -\n*               6 -\n*               7 -\n*               8 - dump SDWA\n*               9 - entry/exit\n*\n* Notes:\n*\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\n* R2     subroutines\n* R3     subroutines\n* R4\n* R5\n* R6\n* R7\n* R8     subroutine scratch\n* R9     SDWA\n* R10    subroutine linkage\n*----------------------------------------------------------------------\nU370SDWA UPROC ID=USDW,L=L$SA\n         LTR   R9,R1                        save SDWA addr\n         BZ    EXIT\n         UDIAG 9,'U370SDWA entered'\n*----------------------------------------------------------------------\n*  Display SDWA\n*----------------------------------------------------------------------\n         USING SDWA,R9\n         UDIAG 8,'U370SDWA SDWA',(R9),L$SDWA\n*----------------------------------------------------------------------\n*  Display regs at time of error\n*----------------------------------------------------------------------\n         MVI   SAMSG,C' '\n         MVC   SAMSG+1(L'SAMSG-1),SAMSG\n         BAL   R10,SPACE\n*\n         MVC   SAM1TXT1(L'MSG1),MSG1\n         BAL   R10,PRINT\n*\n         MVC   SAM1TXT1(5),=C'R0-R7'\n         LA    R2,SDWAGRSV                  @ error regs\n         LA    R3,SAM1TXT2\n         BAL   R10,FMTREGS\n         LA    R3,SAM1TXT3\n         BAL   R10,FMTREGS\n         BAL   R10,PRINT\n*\n         MVC   SAM1TXT1(6),=C'R8-R15'\n         LA    R3,SAM1TXT2\n         BAL   R10,FMTREGS\n         LA    R3,SAM1TXT3\n         BAL   R10,FMTREGS\n         BAL   R10,PRINT\n         BAL   R10,SPACE\n*\n         UDIAG 4,SKIP=ABENDGPR              br based on debug level\n         LA    R8,16\n         LA    R2,SDWAGRSV                  @ error regs\n         SLR   R3,R3                        register #\nERRLOOP  BAL   R10,FMT1REG\n         BAL   R10,PRINTX\n         BCT   R8,ERRLOOP\n         BAL   R10,SPACE\n*----------------------------------------------------------------------\n*  Display regs at entry to ABEND\n*----------------------------------------------------------------------\nABENDGPR MVC   SAM1TXT1(L'MSG2),MSG2\n         BAL   R10,PRINT\n*\n         MVC   SAM1TXT1(5),=C'R0-R7'\n         LA    R2,SDWASRSV                  @ ABEND regs\n         LA    R3,SAM1TXT2\n         BAL   R10,FMTREGS\n         LA    R3,SAM1TXT3\n         BAL   R10,FMTREGS\n         BAL   R10,PRINT\n*\n         MVC   SAM1TXT1(5),=C'R8-RF'\n         LA    R3,SAM1TXT2\n         BAL   R10,FMTREGS\n         LA    R3,SAM1TXT3\n         BAL   R10,FMTREGS\n         BAL   R10,PRINT\n         BAL   R10,SPACE\n*----------------------------------------------------------------------\n*  Print TCB addr & ABEND code\n*----------------------------------------------------------------------\n         MVC   SAM2TXT1(8),=C'TCB addr'\n         L     R0,PSATOLD-PSA(,R0)          my TCB addr\n         LA    R1,SAM2TXT2\n         BAL   R10,FMTHEX\n         BAL   R10,PRINT\n*\n         MVC   SAM2TXT1,=C'ABEND code'\n         L     R0,SDWAABCC                  R0 in hex\n         LA    R1,SAM2TXT2\n         BAL   R10,FMTHEX\n*\nABSYS    DS    0H                           Sxxx\n         L     R0,SDWAABCC\n         SRL   R0,12                        reposition abend code\n         N     R0,=X'00000FFF'              isolate sys  abend\n         LTR   R0,R0\n         BZ    ABUSER\n         SLR   R1,R1\n         BAL   R10,FMTHEX\n         MVI   SAM2TXT3,C'S'\n         STCM  R1,7,SAM2TXT3+1\n*\nABUSER   DS    0H                           Udddd\n         L     R0,SDWAABCC\n         N     R0,=X'00000FFF'              isolate user abend\n         LTR   R0,R0\n         BZ    ABREASON\n         MVI   SAM2TXT4,C'U'\n         LA    R1,SAM2TXT4+1\n         BAL   R10,FMTDEC\n*\nABREASON DS    0H                           REASON xx\n         TM    SDWAERRA,SDWASVCD            SVC13 - ABEND?\n         BNO   ABFIN\n         SLR   R0,R0\n         ICM   R0,1,SDWAGR15+3              R15 at time of error\n         BNZ   ABRGO\n         ICM   R0,1,SDWASR15+3              R15 at last interrupt\n         BZ    ABFIN\nABRGO    SLR   R1,R1\n         BAL   R10,FMTHEX\n         MVC   SAM2TXT5,=C'REASON'\n         STCM  R1,3,SAM2TXT6\nABFIN    DS    0H                           handle reason code ....\n         BAL   R10,PRINT\n*----------------------------------------------------------------------\n*  Print PSWs\n*----------------------------------------------------------------------\n         MVC   SAM3TXT1,=C'EC PSW at error'\n         LA    R2,SDWAEC1                   EC mode PSW @ error\n         LA    R3,SAM3TXT9                  common LOCADDR output addr\n         BAL   R10,FMTPSW\n         L     R2,SDWAEC1+4\n         BAL   R10,LOCADDR\n         BAL   R10,PRINT\n*\n         MVC   SAM3TXT1(14),=C'EC PSW last RB'\n         LA    R2,SDWAEC2                   EC mode PSW (last RB)\n         BAL   R10,FMTPSW\n         L     R2,SDWAEC2+4\n         BAL   R10,LOCADDR\n         BAL   R10,PRINT\n*----------------------------------------------------------------------\n*  Print SDWAFLGS (reason for entering recovery)\n*----------------------------------------------------------------------\n         MVC   SAM4TXT1,=C'SDWAFLGS'\n         L     R0,SDWAFLGS                  flags\n         LA    R1,SAM4TXT2\n         BAL   R10,FMTHEX\n         BAL   R10,PRINT\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\n         BAL   R10,SPACE\n         UDIAG 9,'U370SDWA exited'\nEXIT     UPEND ,\n         EJECT ,\n*----------------------------------------------------------------------\n*  Print blank line\n*----------------------------------------------------------------------\nSPACE    DS    0H\n         UDIAG 2,SAMSG,1\n         BR    R10\n*----------------------------------------------------------------------\n*  Print message\n*----------------------------------------------------------------------\nPRINT    DS    0H\n         MVC   SAM1TXT0,=C'<2>'\nPRINTX   UDIAG 2,SAMSG,L$SAMSG\n         MVI   SAMSG,C' '\n         MVC   SAMSG+1(L'SAMSG-1),SAMSG\n         BR    R10\n*----------------------------------------------------------------------\n*  Format 4 registers - R2 @ reg value, R3 @ output slot\n*----------------------------------------------------------------------\nFMTREGS  DS    0H\n         LA    R8,4                         # times to loop\nFMTLOOP  LR    R1,R3\n         L     R0,0(,R2)\n         UCALL U370HEX\n         LA    R2,4(,R2)\n         LA    R3,9(,R3)\n         BCT   R8,FMTLOOP\n         BR    R10\n*----------------------------------------------------------------------\n*  Format 1 register  - R2 @ reg value, R3=register #\n*----------------------------------------------------------------------\nFMT1REG  DS    0H\n         MVC   SAM5TXT0,=C'<4>'\n         LR    R0,R3                        register #\n         SLR   R1,R1\n         UCALL U370HEX\n         MVI   SAM5TXT1,C'R'\n         STCM  R1,1,SAM5TXT1+1\n         L     R0,0(,R2)                    register contents\n         LA    R1,SAM5TXT2\n         UCALL U370HEX\n         L     R0,0(,R2)\n         LA    R1,SAM5TXT3\n         UCALL U370VADR                     describe where reg points\n         LA    R2,4(,R2)\n         LA    R3,1(,R3)\n         BR    R10\n*----------------------------------------------------------------------\n*  Format fullword (display hex) - R0 = value, R1 @ output slot\n*----------------------------------------------------------------------\nFMTHEX   DS    0H\n         UCALL U370HEX\n         BR    R10\n*----------------------------------------------------------------------\n*  Format fullword (display dec) - R0 = value, R1 @ output slot\n*  R0 may range from x'000' - x'FFF' (4095)\n*  Output buffer will contain c'dddd'\n*----------------------------------------------------------------------\nFMTDEC   DS    0H\n         CVD   R0,SADEC\n         UNPK  0(4,R1),SADEC+5(3)\n         OI    3(R1),X'F0'\n         BR    R10\n*----------------------------------------------------------------------\n*  Format a PSW      - R2 @ PSW\n*----------------------------------------------------------------------\nFMTPSW   DS    0H\n         L     R0,0(,R2)\n         LA    R1,SAM3TXT2\n         UCALL U370HEX\n         L     R0,4(,R2)\n         LA    R1,SAM3TXT3\n         UCALL U370HEX\n         BR    R10\n*----------------------------------------------------------------------\n*  LOCADDR           - R2 addr to look up, R3 @ output slot\n*----------------------------------------------------------------------\nLOCADDR  DS    0H\n         LR    R0,R2\n         LR    R1,R3\n         UCALL U370VADR\n         BR    R10\n*\n         LTORG ,\nMSG1     DC    C'Regs at time of error'\nMSG2     DC    C'Regs at entry to ABEND'\n*----------------------------------------------------------------------\n*  Dynamic savearea & workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSASA     DS    18F\nSALOWSA  DS    16F\nSADEC    DS    PL8\nSACHAR   DS    CL4\n*\nSAMSG    DS    CL90\nL$SAMSG  EQU   *-SAMSG\n*\n         ORG   SAMSG\nSAM1TXT0 DS    C'<2>'\n         DS    C\nSAM1TXT1 DS    C'R0-R8  '\nSAM1TXT2 DS    4CL9                    R0-R3, R8-R11\n         DS    C\nSAM1TXT3 DS    4CL9                    R4-R7, R12-R15\n*\n         ORG   SAMSG\nSAM2TXT0 DS    C'<2>'\n         DS    C\nSAM2TXT1 DS    C'ABEND code'\n         ORG   SAMSG+22\nSAM2TXT2 DS    CL8                     fullword in chars\n         DS    C\nSAM2TXT3 DS    C'Sxxxx'                Sys  ABend code (hex)\n         DS    C\nSAM2TXT4 DS    C'Uxxxx'                User ABend code (dec)\n         DS    C\nSAM2TXT5 DS    C'REASON'\n         DS    C\nSAM2TXT6 DS    C'xx'\n*\n         ORG   SAMSG\nSAM3TXT0 DS    C'<2>'\n         DS    C\nSAM3TXT1 DS    C'BC PSW at error'\n         ORG   SAMSG+22\nSAM3TXT2 DS    CL8                     hi word PSW\n         DS    C\nSAM3TXT3 DS    CL8                     lo word PSW\n         DS    C\nSAM3TXT9 DS    CL(L$VADRBF)            U370VADR output buffer\n*\n         ORG   SAMSG\nSAM4TXT0 DS    C'<2>'\n         DS    C\nSAM4TXT1 DS    C'SDWAFLGS'\n         ORG   SAMSG+22\nSAM4TXT2 DS    CL8\n*\n         ORG   SAMSG\nSAM5TXT0 DS    C'<2>'\n         DS    C\nSAM5TXT1 DS    C'Rn'                   Register #\n         DS    C\nSAM5TXT2 DS    CL8                     Register contents\n         DS    C\nSAM5TXT3 DS    CL(L$VADRBF)            U370VADR buffer\n*\n         ORG   ,\n         DS    0D\nL$SA     EQU   *-SAVEAREA              length of savearea\n*\n         UVTAB MF=DSECT                VCON table\n*\n         PRINT NOGEN\n         WATGD ,\n*\n         IHAPSA  DSECT=YES\n         IHASDWA ,\nL$SDWA   EQU   *-SDWA\n*\n         PRINT GEN\nU370SDWA UFINI DXDUSDWA,L$SA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "U370SNAP": {"ttr": 12555, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x01e\\x01e\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 357, "newlines": 357, "modlines": 0, "user": "XV0006"}, "text": "U370SNAP TITLE 'DIAGNOSTIC tool: display storage'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  Things to do:\n*  1)  Display length of snap in hex & decimal\n*----------------------------------------------------------------------\n         U#SET FUNC=UTIL\n*----------------------------------------------------------------------\n*\n* Function: display dump-formatted storage on XMITLOG ddname\n*\n* Input:  R1 points at following parameter list:\n*\n*  +0     Zero or address of TITLE (see below).\n*\n*  +4     Address of virtual storage address at which to begin.\n*\n*  +8     Address of virtual storage address at which to end.\n*         Alternatively, this parameter may contain the length\n*         of storage to be displayed, rather than an address.\n*\n*         TITLE:\n*\n*         The length of the title is determined by the following\n*         technique:  if the first byte of the title < 60,\n*         then the first byte is the length of following title.\n*         Otherwise, the title is delimited by X'00'.\n*         The title's maximum length is 60.\n*\n*         R13 points to caller-provided savearea\n*\n*         R14 return address\n*\n*         R15 entry point address of this routine\n*\n* Output: Input data displayed.\n*\n*         R15 =  00\n*\n* Notes:\n*----------------------------------------------------------------------\n         TITLE ' '\nU370SNAP UPROC ID=USNP,L=L$SA\n         EJECT ,\n*\n* Initialize\n*\n         LM    R3,R5,0(R1)\n         LA    R4,0(,R4)               clear hi bits\n         LA    R5,0(,R5)               clear hi bits\n         STM   R3,R5,PARMS             save input parms\n*----------------------------------------------------------------------\n*  Display title\n*----------------------------------------------------------------------\n         LTR   R3,R3                   title supplied?\n         BZ    NOTITLE                 no, br\n*\n         ULOG  ' '                     blank line\n*\n         CLI   0(R3),MAXLEN            1st byte length?\n         BH    SCANTITL                no, br ... need to scan\n*\n         SLR   R6,R6\n         IC    R6,0(R3)                get title's length\n         LA    R7,1(,R3)               1st byte of title\n         B     TITLEOUT\n*\nSCANTITL DS    0H\n         LR    R7,R3                   @ 1st byte of title\n         TRT   0(MAXLEN,R3),ZVALID     scan for non-display\n         BZ    MAXLENT                 found all displayable\n*\n         SR    R1,R3                   calculate length\n         LR    R6,R1\n         C     R6,=A(MAXLEN)           too long?\n         BNH   TITLEOUT\n*\nMAXLENT  DS    0H\n         LA    R6,MAXLEN               set maximum title length\n*\nTITLEOUT DS    0H\n         LR    R0,R6                   length of title\n         LR    R1,R7                   address of title\n         UCALL U370LOG                 print title\n*\nMAXLEN   EQU   60                      Maximum title length\nNOTITLE  DS    0H\n         EJECT ,\n*----------------------------------------------------------------------\n*  Display storage specifications\n*----------------------------------------------------------------------\n         MVC   CLABEL,=C'DISPLAYING '\n         MVI   CRANGE,C':'             set range char\n*\n         L     R0,@START               starting address\n         LA    R1,CSTART               char format\n         BAL   R14,XLATE               convert to display hex\n*\n         LM    R14,R15,@START\n         LR    R8,R15                  save requested length\n         CR    R15,R14                 ending addr > starting?\n         BH    USE@END                 yes, ok to use\n*\n         AR    R15,R14                 calculate ending addr\n         ST    R15,@END                fake out parmlist\n         LTR   R8,R8\n         BNZ   USE@END\n         L     R0,@END                 ending address\n         B     USEXLATE\n*\nUSE@END  DS    0H\n         L     R0,@END                 ending address\n         BCTR  R0,0                    minus one\nUSEXLATE LA    R1,CEND                 char format\n         BAL   R14,XLATE               convert to display hex\n*\n         MVI   CSPACE1,C' '\n         L     R0,@END\n         S     R0,@START\n         LA    R1,CHEXLEN              length (hex)\n         BAL   R14,XLATE\n*\n         LA    R0,L$SPECS\n         LA    R1,CLABEL               label following output\n         UCALL U370LOG                 type output\n*\n         LTR   R8,R8                   requested length zero?\n         BZ    EXIT                    done, no storage displayed\n         EJECT ,\n*----------------------------------------------------------------------\n*  Format output line(s)\n*----------------------------------------------------------------------\nFORMAT   DS    0H\n         XC    DISPL,DISPL             zero displacement\n         L     R4,@START               @ beginning of area\n*        N     R4,=X'FFFFFFFC'         align on fullword boundary\n*\nFLINE    DS    0H\n         LR    R8,R4                   storage @ start of line\n         MVI   CFORMAT,C' '\n         MVC   CFORMAT+1(L$FORMAT-1),CFORMAT    clear line,\n         MVI   CSTAR1,C'*'                      delimit\n         MVI   CSTAR2,C'*'                      char area\n*\n         LR    R0,R4\n         LA    R1,CADDR\n         BAL   R14,XLATE               make ADDRESS char\n*\n         L     R0,DISPL\n         LA    R1,CJUNK\n         BAL   R14,XLATE               make DISPLACEMENT char\n         MVC   CDISPL(4),CJUNK+4       copy last 4 digits\n         A     R0,=F'16'               using 4 fullwords\n         ST    R0,DISPL                setup for next time\n         EJECT ,\n*----------------------------------------------------------------------\n*  Fill CWORDn - 4 fullwords worth of EBCDIC chars\n*----------------------------------------------------------------------\n         LA    R5,4                    # word slots avail\n         LA    R6,CWORD1               @ first slot\n*\nFLOOP    DS    0H\n         ICM   R0,15,0(R4)             grab 1st 4 bytes\n         LA    R1,CBYTES               workarea\n         BAL   R14,XLATE               make 1st word char\n* copy only right # chars from CBYTES to CWORDn\n         LM    R14,R15,CBYTES          get display hex in regs\n         L     R1,@END                 addr last char to display\n         SR    R1,R4                   calc # chars to put in CWORDn\nPUTC     STCM  R14,12,0(R6)            put char in CWORDn\n         SLDL  R14,16                  discard char\n         LA    R6,2(,R6)\n         LTR   R14,R14                 got 'em all?\n         BZ    BUMPC                   yep\n         S     R1,=F'1'\n         BP    PUTC\nBUMPC    DS    0H\n         LA    R4,4(,R4)               setup for next time\n         LA    R6,1(,R6)               space between CWORDs\n*\n         C     R4,@END                 displayed enough?\n         BNL   CKOLD                   yes, see if duplicate line\n         S     R5,=F'1'                one less slot\n         BP    FLOOP                   still have some left\n*\n*  For duplicate lines, print one line with some '-'s, ignore rest\n*\nCKOLD    DS    0H\n         CLC   OLDBYTES(L'CWORD1*4),CWORD1   same?\n         BNE   FCHAR                         no, br\n         MVI   CADDR,C'-'\n         MVC   CADDR+1(13),CADDR             propagate .\n         MVI   CDISPL-1,C' '\n         B     FCHAR2\n         EJECT ,\n*----------------------------------------------------------------------\n*  Format EBCDIC translation of hex data portion of output line\n*----------------------------------------------------------------------\nFCHAR    DS    0H\n         MVI   FLAG1,0                       reset state\n         MVC   OLDBYTES(L'CWORD1*4),CWORD1   save current CWORD1-4\nFCHAR2   LA    R9,16                   # chars in char display\n         LR    R15,R8                  @ begin of line's data\n         LA    R14,CCHAR\n         MVC   CCHAR,=CL16' '          init to blanks\n*\nCLOOP    DS    0H\n         MVC   0(1,R14),0(R15)         copy for displaying\n         LA    R15,1(,R15)\n         LA    R14,1(,R14)\n         C     R15,@END\n         BNL   CLOOP2\n         S     R9,=F'1'\n         BP    CLOOP\n*\nCLOOP2   DS    0H\n         TR    CCHAR,ZDISP             convert non-display\n         LR    R8,R4                   now done with those\n*\n         CLI   CADDR,C'-'              duplicate?\n         BNE   PRINT\n         TM    FLAG1,FLG1SUP           suppress?\n         BO    NEXTLINE\n         OI    FLAG1,FLG1SUP           suppress following dup lines\nPRINT    LA    R0,L$FORMAT             length of output line\n         LA    R1,CFORMAT              addr of output line\n         UCALL U370LOG                 type output\n*\nNEXTLINE DS    0H\n         C     R4,@END                 more lines to format?\n         BL    FLINE                   yes, br\n         EJECT ,\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\nEXIT     DS    0H\n         SLR   R15,R15\n         UPEND ,                       return to caller\n         TITLE 'XLATE Subroutine'\n*----------------------------------------------------------------------\n*  XLATE subroutine\n*----------------------------------------------------------------------\n*\n* Input:   R0  = value to translate\n*\n*          R1  = address of 8 bytes to receive translated\n*                \"display hexadecimal\" output\n*\n*          R14 = return address\n*\nXLATE    DS    0H\n         ST    R0,FWORD                value to translate\n         UNPK  XWORK,FWORD(5)          spread out digits\n         TR    XWORK,HEXCHAR-C'0'      translate to char\n         MVC   0(8,R1),XWORK           return data to caller\n         BR    R14                     return to caller\n*\nHEXCHAR  DC    C'0123456789ABCDEF'     Hex translate table\n         TITLE 'DATA AREAS'\n*----------------------------------------------------------------------\n* Data areas (not modified)\n*----------------------------------------------------------------------\nZVALID   DS    0X\n*                000102030405060708090A0B0C0D0E0F    ..\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' X'00'\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' X'10'\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' X'20'\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' X'30'\n         DC    X'00FFFFFFFFFFFFFFFFFF000000000000' X'40'\n         DC    X'00FFFFFFFFFFFFFFFFFF000000000000' X'50'\n         DC    X'00FFFFFFFFFFFFFFFFFF000000000000' X'60'\n         DC    X'FFFFFFFFFFFFFFFFFF00000000000000' X'70'\n         DC    X'FF000000000000000000FFFFFFFFFFFF' X'80' a-i\n         DC    X'FF000000000000000000FFFFFFFFFFFF' X'90' j-r\n         DC    X'FF000000000000000000FFFFFFFFFFFF' X'A0' s-z\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' X'B0'\n         DC    X'00000000000000000000FFFFFFFFFFFF' X'C0' A-I\n         DC    X'00000000000000000000FFFFFFFFFFFF' X'D0' J-R\n         DC    X'00FF0000000000000000FFFFFFFFFFFF' X'E0' S-Z\n         DC    X'00000000000000000000FFFFFFFFFFFF' X'F0' 0-9\n*                000102030405060708090A0B0C0D0E0F    ..\n*\nZDISP    DS    0X\n*                0123456789ABCDEF\n         DC    C'................'                       X'00'\n         DC    C'................'                       X'10'\n         DC    C'................'                       X'20'\n         DC    C'................'                       X'30'\n         DC    X'40',C'.........',X'4A4B4C4D4E4F'        X'40'\n         DC    X'50',C'.........',X'5A5B5C5D5E5F'        X'50'\n         DC    X'60',C'.........',X'6A6B6C6D6E6F'        X'60'\n         DC    C'.........',X'797A7B7C7D7E7F'            X'70'\n         DC    C'.ABCDEFGHI',X'8A8B8C8D8E8F'             X'80'\n         DC    C'.JKLMNOPQR',X'9A9B9C9D9E9F'             X'90'\n         DC    C'.',X'A1',C'STUVWXYZ',X'AAABACADAEAF'    X'A0'\n         DC    C'................'                       X'B0'\n         DC    X'C0',C'ABCDEFGHI',X'CACBCCCDCECF'        X'C0'\n         DC    X'D0',C'JKLMNOPQR.',X'DBDCDDDEDF'         X'D0'\n         DC    X'E0',C'.STUVWXYZ',X'EAEB',C'.',X'EDEEEF' X'E0'\n         DC    C'0123456789......'                       X'F0'\n*                0123456789ABCDEF\n*\n         LTORG ,\n         TITLE 'DSECTS'\n*----------------------------------------------------------------------\n* Dynamic savearea & workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\n         DS    19F\nXWORK    DC    CL9' '\nFWORD    DC    F'0'\n*\nPARMS    DS    0XL12                   parmlist:\n@TITLE   DC    A(0)                    A(title)\n@START   DC    A(0)                    A(beginning of storage)\n@END     DC    F'0'                    A(end of storage)\n*\nFLAG1    DS    X\nFLG1SUP  EQU   64                      suppress duplicate lines\n*\nCLABEL   DC    C'DISPLAYING '\nCSTART   DC    CL8' '\nCRANGE   DC    C':'\nCEND     DC    CL8' '\nCSPACE1  DC    C' '\nCHEXLEN  DC    CL8' '\nL$SPECS  EQU   *-CLABEL                length of stor specs\n*\nCFORMAT  DS    0C\nCADDR    DC    C'XXXXYYYY  '           address\nCDISPL   DC    C'DDDD  '               displacement\nCWORD1   DC    C'AABBCCDD '            1st word\nCWORD2   DC    C'AABBCCDD '            2nd word\nCWORD3   DC    C'AABBCCDD '            3rd word\nCWORD4   DC    C'AABBCCDD '            4th word\nCSTAR1   DC    C'*'\nCCHAR    DC    C'....++++....++++'     char values\nCSTAR2   DC    C'*'\nL$FORMAT EQU   *-CFORMAT               length of output line\n*\nOLDBYTES DS    4CL(L'CWORD1)           previous CWORD1-4\n*\n         DS    0F                      align\nCBYTES   DC    C'AABBCCDD '            CWORDn workarea\n*\n         DS    0F\nCJUNK    DC    CL8' '\nDISPL    DC    F'0'\n         DS    0D\nL$SA     EQU   *-SAVEAREA              length of savearea\n         EJECT ,\n         WATGD ,\n         PRINT GEN\nU370SNAP UFINI DXDUSNAP,L$SA\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "U370STAE": {"ttr": 12807, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x04d\\x04d\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 1124, "newlines": 1124, "modlines": 0, "user": "XV0006"}, "text": "U370STAE TITLE 'ESTAE support'\n*\n* Copyright 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  To do:\n*  1) verify SXZERO (rename field) = some value in TGD\n*     change UPROC to support it\n*----------------------------------------------------------------------\n         U#SET FUNC=UTIL\n*\n*----------------------------------------------------------------------\n* Function: ESTAE support\n*\n* Contents:\n*\n*         U370STAE - setup & tear down ESTAE environment\n*\n*         SUPPORT  - ESTAE exit routine, which either decides to\n*                    invoke the RETRY routine, or percolate the ABEND\n*\n*         RETRYx   - local ESTAE retry routine, which will attempt\n*                    to invoke a \"remote\" ESTAE retry routine if it\n*                    can find one.  Remote ESTAE retry routines are\n*                    typically provided on a CSECT-basis.\n*\n*                    RETRY1 - no SDWA\n*                    RETRY2 - SDWA\n*\n*         Miscellaneous additional low-level subroutines\n*\n* Abbreviations used in the code:\n*\n*         RRR - remote retry routine\n*         LRR - local  retry routine\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         TGDFLG4.TGD4NSTA    don't establish any ESTAEs\n*\n*         R0(00:22)           ignored\n*         R0(23:23)           UESTAE TERM=YES flag\n*         R0(24:31) CPDEFLG1  ESTAE processing options\n*                             UESTAE TERM=YES overrides all other opts\n*\n*         R1  = retry addr  - initialize ESTAE environment (as needed),\n*                             set retry routine address\n*                             caller's regs are stored in SX\n*\n*               X'00000000' - terminate ESTAE environment (CSECT only)\n*\n* Exit:   R15 = return code\n*         R15 = 00 success\n*\n*----------------------------------------------------------------------\n*\n* Entry to RRR:\n*\n*         R0     = 0 - reserved for future use\n*         R1     = @ SDWA (RRR responsible for freeing SDWA) or zero\n*         R2-R12 = as provided by RRR in U370STAE setup call\n*         R13    = addr of RRR SA (@ SXBASE)\n*         R14    = addr of supervisor-assisted return linkage\n*                  (returning there will end application, assuming\n*                  a simple RB structure consisting of one PRB;\n*                  other situations requires additional research)\n*         R15    = addr of RRR\n*\n*----------------------------------------------------------------------\n*\n* Diagnostics:\n*\n*         1 - RETRY2   ABENDing SX prefix\n*             RETRY2   SDWA\n*             RETRY2   RRR SX (prefix only)\n*         2 - MAINLINE INIT message w/ RRR addr\n*             RETRY2   ABENDing CSECT DSA\n*         3 - RETRY2   All UWTOs\n*         4 - RETRY2   RRR DSA (whole DSA)\n*         5 - FINDRETY SA chain - SX prefix\n*             FINDRETY SA chain - CPD prefix\n*         6 - RETRY2   TCB\n*         7 - RETRY2   TGD\n*             RETRY2   DSA2 after ALLOCDSA call\n*             RETRY2   ASCB\n*         8 - FINDRETY SA chain - whole DSA\n*             FINDRETY SA chain - whole CPD\n*         9 - RETRY2   whole DSA pool\n*             RETRY2   ALLOCDSA (UWTO)\n*             MAINLINE exit message\n*\n* Abends: U370STAE ABENDs if ESTAE fails, see ERR#nn\n*\n* Notes:  We refer to RETRYx routines as \"local retry routines\",\n*         and the (caller's) CSECT-specific retry routines as\n*         \"remote retry routines\".\n*\n*         Refer to OS/VS2 System Programming Library (SPL):\n*         Supervisor for an overview of ESTAE processing, including\n*         such details as register contents upon entry & return\n*         codes.\n*\n*         Refer to OS/VS2 MVS Supervisor Services and Macro\n*         Instructions for specifics on the ESTAE & SETRP macros.\n*\n*         Retry routines are the code MVS calls when an ABEND is\n*         encountered in code that has established an ESTAE\n*         environment.  An SDWA (and savearea) may or may not\n*         be provided by MVS.  A retry routine may elect to either\n*            a) percolate the ABEND or\n*            b) attempt retry by scheduling a \"retry exit routine\".\n*         A retry routine may also elect to free the SDWA, or\n*         preserve it for the retry exit routine's use (in which\n*         case it's the retry exit routine's responsibility to\n*         free the SDWA).\n*\n*         Retry exit routines are the code MVS calls when a\n*         \"retry routine\" requests that one be scheduled.\n*         Retry exit routines are called only after MVS has\n*         trimmed the RB chain back to where it was when the\n*         ESTAE request was made.  Examples of RBs: PRB, SVRB, IRB.\n*\n*         Trivia:\n*         RTM2 (task recovery/termination) doesn't appear to care\n*         if we wipe out it's registers in SUPPORT.  IEAVTAS1 uses\n*         SYNCH to call SUPPORT, and then chases control blocks to\n*         find it's regs, which it restores from the RTM2WA.\n*         See IEAVTAS1 labels PRESYNCH & POSTSYNC\n*\n*         Whenever this code wants to call another CSECT (such as\n*         U370LOG), it needs to first assure that the standard\n*         xxxx370 register conventions are observed.  The UPROC\n*         macro in the called CSECT depends on them being right.\n*         See UPROC macro for register conventions.\n*\n*         U370STAE has some intimate knowledge of UPROC's workings,\n*         particulary when U370STAE calls other U370* code.\n*\n*         INIT call:\n*         ----------\n*         The caller's regs (stored in caller's SA) are copied into\n*         the CPDEREGS fields, for restoration at ABEND time.\n*         CPDE@RRR will contain the caller's remote retry address.\n*         If an ESTAE is not active, one will be activated.\n*\n*         UESTAE TERM=YES call:\n*         ---------------------\n*         The caller's remote retry address is cleared, and the ESTAE\n*         environment is brought down.\n*         It is not necessary to TERM prior to exit in every CSECT,\n*         the CSECT's retry routine won't be driven unless the CSECT\n*         is active.  You can expect your RRR code to be called if\n*         a lower-level CSECT ABENDs without an active RRR.\n*         However, it's a good idea to TERM prior to exiting xxxx370,\n*         there may be some cleanup done at that time.\n*\n*         See U370QENV for some handy reference stuff coded in\n*         it's RETRY routines (changing retry addrs, SNAP,\n*         catastrophic failure, etc.).\n*\n*----------------------------------------------------------------------\n* Reg  DSECT    usage (mainline only)\n*----------------------------------------------------------------------\n* R2            R1 at entry (0 or \"remote retry exit\" address)\n* R3            address of ESTAE exit routine (SUPPORT)\n* R4\n* R5            zap reg\n* R6            INIT call R0 - ESTAE processing options - CPDEFLG1\n* R7   SX       address of caller's SX\n* R8            address of caller's SA\n* R9            address of caller's CPD\n* R10\n* R11           common\n* R12           base reg\n* R13  SAVEAREA savearea\n*----------------------------------------------------------------------\n* Reg  DSECT    usage (MAINLINE only)\n*----------------------------------------------------------------------\nERR#1    EQU   1        CPD can't be located\nERR#2    EQU   2        ESTAE setup call rc non-zero\nERR#3    EQU   3        ESTAE termination call rc non-zero\n         TITLE ' '\n*----------------------------------------------------------------------\n*  MAINLINE\n*----------------------------------------------------------------------\nU370STAE UPROC ID=USTA,L=L$SA,CPD=(Y,0,ESTAE) generate ESTAE fields\n*----------------------------------------------------------------------\nMAINLINE DS    0H\n         STM   R0,R1,SAENTRY           save entry regs\n         LR    R2,R1                   save RRR addr in safe reg\n         LR    R6,R0                   save flags    in safe reg\n*----------------------------------------------------------------------\n*  Locate caller's SA & SX\n*----------------------------------------------------------------------\n         L     R8,SX@BACK-SXBASE(,R13)      @ caller's SA\n         U@SX  R7,SAREG=R8                  @ caller's SX\n*----------------------------------------------------------------------\n*  Determine call type: INIT or TERM\n*----------------------------------------------------------------------\n         TM    SAR0B2,CPDETERM/256          check entry parm\n         BO    TERM                         terminate request\n         EJECT ,\n*----------------------------------------------------------------------\n*  Set up caller's RRR environment\n*----------------------------------------------------------------------\nINIT     DS    0H\n         ICM   R9,15,SX@CPD            @ CPD\n         BNZ   INITINIT\n*\n         WTO   'STAE ESTAE without CPD; check caller UPROC'\n         ABEND 370                     caller UPROC coding error\n*\n         USING CPD,R9\nINITINIT ICM   R1,15,=C'INIT'\n         BAL   R10,MAINMSG1            issue msg w/ caller's CSECT\n         STC   R6,CPDEFLG1             set ESTAE processing options\n         OI    CPDEFLG2,CPDE2RRV       RRR addr valid\n         ST    R2,CPDE@RRR             set retry address\n         MVC   CPDEREGS(13*4),SXR0     copy caller's R0:R12 (only)\n*\n         TM    TGDFLG3,TGD3RETY\n         BO    RCZERO                  ESTAE already activated\n*----------------------------------------------------------------------\n*  Activate ESTAE environment\n*----------------------------------------------------------------------\n         TM    TGDFLG4,TGD4NSTA        bypass ESTAE CT?\n         BO    RCZERO                  yes, br\n*\n*  Provide WAREG to the ESTAE exit routine via PARAM=\n*\n         MVI   SAREASON,ERR#2\n         MVC   SAESTAE(L$ESTAE),MDLESTAE\n         LA    R3,SUPPORT\n         ESTAE (R3),CT,PARAM=(WAREG),MF=(E,SAESTAE)\n         LTR   R15,R15\n         BNZ   DIE\n*\n         OI    TGDFLG3,TGD3RETY        ESTAE now active\n         B     RCZERO\n*\nDIE      DS    0H\n         WTO   'STAE ESTAE fail; exiting'\n         UABEND SAREASON,SVC=3\n         EJECT ,\n*----------------------------------------------------------------------\n*  Terminate ESTAE environment\n*----------------------------------------------------------------------\nTERM     DS    0H\n         ICM   R1,15,=C'TERM'\n         BAL   R10,MAINMSG1\n         TM    TGDFLG4,TGD4NSTA        ESTAE not desired?\n         BO    TERMOFF                 yes, br\n         TM    TGDFLG3,TGD3RETY        ESTAE established?\n         BNO   TERMOFF                 yes, br\n         MVI   SAREASON,ERR#3\n         MVC   SAESTAE(L$ESTAE),MDLESTAE\n         ESTAE 0,MF=(E,SAESTAE)\n         LTR   R15,R15\n         BNZ   DIE\n*\nTERMOFF  NI    TGDFLG3,255-TGD3RETY    U370STAE ESTAE no longer active\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\nRCZERO   DS    0H\n         UDIAG 9,'STAE main exit'\n         UPEND RC=0\n*----------------------------------------------------------------------\n*  MAINMSG1 - issue INIT/TERM msg with caller's CSECT, RRR addr\n*----------------------------------------------------------------------\nMAINMSG1 DS    0H\n         MVI   SAMSG1,C' '\n         MVC   SAMSG1+1(L$MSG1-1),SAMSG1\n         MVC   SAM1LIT1,=C'<2> STAE main'\n         STCM  R1,15,SAM1TXT1\n         MVC   SAM1TXT2,SXID\n         L     R0,SAR0                           R0 entry parm\n         LA    R1,SAM1TXT3                       display hex dest addr\n         UCALL U370HEX                           convert to display hex\n         L     R0,SAR1                           R1 entry parm\n         LA    R1,SAM1TXT4                       display hex dest addr\n         UCALL U370HEX                           convert to display hex\n         UDIAG 2,SAMSG1,L$MSG1\n         BR    R10\n*----------------------------------------------------------------------\n*  END OF MAINLINE\n*----------------------------------------------------------------------\n         EJECT ,\n*----------------------------------------------------------------------\n*  SUPPORT - U370STAE retry routine\n*----------------------------------------------------------------------\n*  ESTAE retry routine - select RETRYx based on entry environment\n*  It is necessary to return to RTM2 before the retry exit routine\n*  (RETRYx) is scheduled so RTM2 can trim the RB chain.\n*  We may be called either with or without an SDWA (and system-\n*  provided savearea that comes with the SDWA).\n*\n*  It does not appear to be necessary to restore RTM2's registers\n*  before returning (based on examination of MVS38j IEAVTAS1 source).\n*  This greatly simplifies things, especially when no SDWA\n*  has been provided (hence no system-provided savearea).\n*\n*  Upon return to RTM2, RTM2 will trim the RB queue back to the\n*  point of the ESTAE issuer associated with the SCB under which\n*  we were invoked.\n*\n*  OS/VS2 SPL: Supervisor says it does this by pointing the RB\n*  old PSW at an SVC 3 (EXIT) instruction.\n*\n*  Additionally, open DCBs that can be associated with the\n*  purged RBs are closed and queued I/O associated with such\n*  DCBs are deleted from the I/O restore chain.\n*\n*  For our environment, with only one PRB, this should have no\n*  impact on us.  Other situations may be impacted.\n*\n*  SUPPORT always attempts to schedule a retry routine.  The RETRYx\n*  code will attempt to perform some diagnostics, even if no\n*  remote retry code can be found.\n*\n*  In terms of the documentation, NOSDWA, HVSDWA and SUBAIL should\n*  be considered components of SUPPORT.\n*\n*----------------------------------------------------------------------\n* Reg  DSECT    usage (SUPPORT)\n*----------------------------------------------------------------------\n* R0            scratch\n* R1            scratch\n* R2            SUPPORT - NOSDWA, HVSDWA\n* R3            SUPPORT - NOSDWA, HVSDWA\n* R4            SUPPORT - RTM2 return addr\n* R5            zap reg\n* R6            subroutine reserved\n* R7   SX       subroutine SX\n* R8   SA       subroutine SA (SXBASE)\n* R9   CPD      subroutine CPD\n* R10           subroutine internal linkage\n* R11  TGDWA\n* R12           U370STAE basereg\n* R13           SUPPORT - NOSDWA, HVSDWA\n* R14           scratch\n* R15           scratch\n*----------------------------------------------------------------------\n         PUSH  USING              <SUPPORT>\n         DROP  ,\nSUPPORT  DS    0H\n         USING *,R15\n         C     R0,=F'12'               SDWA provided?\n         BNE   HVSDWA\n         POP   USING              <SUPPORT>\n         EJECT ,\n*----------------------------------------------------------------------\n*  NOSDWA - ESTAE retry routine - no SDWA provided\n*----------------------------------------------------------------------\n*\n*  When no SDWA is provided, entry regs are:\n*\n*  R0    = 12 (no SDWA provided)\n*  R1    abend completion code\n*  R2    address of user-supplied parm list (ESTAE PARAM=(WAREG))\n*  R13   unpredictable (no savearea provided)\n*  R14   return address to RTM2 (task termination)\n*  R15   entry point address of ESTAE recovery routine (SUPPORT)\n*\n*  SETRP macro may not be issued (modifies SDWA)\n*\n*----------------------------------------------------------------------\n* Reg  DSECT    usage (NOSDWA)\n*----------------------------------------------------------------------\n* R0            RETRY1 address passed to RTM2\n* R2            reserved for SUBAIL\n* R3            SUBAIL: 0 = no SDWA\n* R4            RTM2 return addr\n* R10           internal linkage\n* R11  TGD\n* R12           U370STAE base\n* R13           spare\n*\n         PUSH  USING              <NOSDWA>\n         DROP  ,\n         USING SUPPORT,R15\nNOSDWA   DS    0H\n         LR    WAREG,R2                SUBAIL requires\n         USING TGDWA,WAREG\n         LR    R4,R14                  save RTM2 return addr\n         L     R12,=A(U370STAE)        set standard base reg\n         USING U370STAE,R12\n         DROP  R15\n         UDIAG 2,SKIP=NOSDWTOX\n         WTO   'STAE no SDWA'\nNOSDWTOX DS    0H\n*\n*  We don't set TGD3SUPT when we have no SDWA; our code path\n*  is almost nothing.  SUBAIL will percolate the ABEND for us.\n*  About all we get out of SUBAIL is it's WTO and probably a dump.\n*\n         TM    TGDFLG3,TGD3SUPT        SUPPORT already active?\n         BNO   NOSDSCHD                no, safe to sched retry\n*\n         SLR   R3,R3                   no SDWA (RTM short on storage)\n         BAL   R10,SUBAIL              attempt graceful shutdown\n*\n*  Schedule RETRY1 (no-SDWA) retry exit routine\n*\nNOSDSCHD DS    0H\n         OI    TGDFLG3,TGD3SCHD        RETRY1 (no-SDWA) scheduled\n         LA    R0,RETRY1               local (no SDWA) retry routine\n         LA    R15,4                   rc = schedule retry routine\n         BR    R4                      return to RTM2\n         POP   USING              <NOSDWA>\n         EJECT ,\n*----------------------------------------------------------------------\n*  HVSDWA - ESTAE retry routine - SDWA provided\n*----------------------------------------------------------------------\n*\n*  When SDWA is provided, entry regs are:\n*\n*  R0    I/O processing code\n*\n*        00 = active I/O quiesced & restorable\n*        04 = active I/O halted, not restorable\n*        08 = no active I/O at time of ABEND\n*        16 = no I/O processing performed\n*\n*  R1    SDWA address\n*  R13   RTM2-provided save area address\n*  R14   RTM2-provided return address\n*  R15   entry point address of ESTAE recovery routine (SUPPORT)\n*\n*  SETRP macro sets up SDWA for retry or percolation\n*\n*----------------------------------------------------------------------\n* Reg  DSECT    usage (HVSDWA)\n*----------------------------------------------------------------------\n* R2            reserved for SUBAIL, scratch in HVSDWA\n* R3   SDWA     SUBAIL: SDWA\n* R4            RTM2 return addr\n* R9   CPD      projected RRR's CPD (FINDCPD)\n* R10           internal linkage, scratch in HVSDWA\n* R11  TGD\n* R12           U370STAE base\n* R13           RTM2 savearea, scratch in HVSDWA\n*\n         PUSH  USING              <HVSDWA>\n         DROP  ,\n         USING SUPPORT,R15\nHVSDWA   DS    0H\n         STM   R14,R12,12(R13)         save RTM2's regs (debug aid)\n         L     R12,=A(U370STAE)\n         USING U370STAE,R12\n         DROP  R15\n         LR    R4,R14                  save RTM2 return addr\n         LR    R3,R1                   save SDWA ptr\n         USING SDWA,R3\n         L     WAREG,SDWAPARM          @ TGD\n         USING TGDWA,WAREG\n*\n         TM    TGDFLG3,TGD3SUPT        SUPPORT already active?\n         BNO   HVSAFE                  no, safe to sched retry\n*\n         BAL   R10,SUBAIL              attempt graceful shutdown\n*\nHVSAFE   DS    0H\n         OI    TGDFLG3,TGD3SUPT        SUPPORT active\n         LA    R2,RETRY2               retry routine\n*\n         BAL   R10,FINDCPD             attempt to find RRR's CPD\n         LTR   R9,R9                   found RRR's CPD?\n         BZ    HVNOSNAP                no, can't check SNAP request\n         USING CPD,R9\n         TM    CPDEFLG1,CPDE1SNP       RRR wants SNAP?\n         BNO   HVNOSNAP                no, select quiet SETRP\n         ICM   R10,15,CPDE@SNP         RRR's SNAP parmlist\n         BZ    HVNOSNAP                Oops, no parmlist\n         DROP  R9\n*\nHVSNAP   DS    0H\n         SETRP WKAREA=(R3),            SDWA                            +\n               DUMP=YES,               SNAP requested                  +\n               DUMPOPT=(R10),          SNAP parmlist                   +\n               RC=4,                   schedule RETRYx routine         +\n               RETADDR=(R2),           RETRY2 address                  +\n               FRESDWA=NO,             preserve SDWA for RETRYx        +\n               RETREGS=NO              RETRY2 figures out regs\n         B     HVSCHED                 schedule RETRY2\n*\nHVNOSNAP DS    0H\n         SETRP WKAREA=(R3),            SDWA                            +\n               DUMP=NO,                no SNAP                         +\n               RC=4,                   schedule RETRYx routine         +\n               RETADDR=(R2),           RETRY2 address                  +\n               FRESDWA=NO,             preserve SDWA for RETRYx        +\n               RETREGS=NO              RETRY2 figures out regs\n*\nHVSCHED  DS    0H\n         NI    TGDFLG3,255-TGD3SUPT    SUPPORT inactive\n         LA    R15,4                   rc = schedule retry routine\n         BR    R4                      return to RTM2\n         POP   USING              <HVSDWA>\n         EJECT ,\n*----------------------------------------------------------------------\n*  SUBAIL - SUPPORT bail (will not return to caller)\n*----------------------------------------------------------------------\n* Entry:\n* R3     zero or SDWA addr\n* R4     RTM2 return addr\n* R10    return to caller (debug aid)\n* R11    TGD\n* R12    U370STAE base\n*----------------------------------------------------------------------\n* Reg  DSECT    usage (SUBAIL)\n*----------------------------------------------------------------------\n* R2            reserved for SUBAIL\n* R10           internal linkage\n* R11  TGD\n* R12           U370STAE base\n*----------------------------------------------------------------------\n*\n*  ABEND detected while SUPPORT active\n*\n         PUSH  USING              <SUBAIL>\n         DROP  ,\nSUBAIL   DS    0H\n         USING TGDWA,WAREG             <required of caller>\n         USING U370STAE,R12            <required of caller>\n*\n         TM    TGDFLG3,TGD3EXIT        stop the madness?\n         BO    SBEXIT                  yes, and I mean NOW\n*\n         OI    TGDFLG3,TGD3EXIT        one dump will be sufficient\n         WTO   'STAE recursive SUPPORT ABEND'\n*\n*  If we have an SDWA, generate diagnostic SNAP\n*\n         LTR   R3,R3                   SDWA?\n         BZ    SBPERC                  no, just percolate ABEND\n*\n*  SUBAIL ignores CPDEFLG1.CPDE1SNP & CPED@SNP for these basic reasons:\n*\n*  1) We want the SNAP parms we want, not someone else's\n*\n*  2) We've already died once in SUPPORT, let's get a dump\n*     and percolate back to a hopefully more graceful state\n*     (even - or perhaps especially - if it means we're done running).\n*     The dump is what we really want, and it could be that we've\n*     died due to some external influence brought on by a RRR.\n*     Don't give the RRRs a chance to kill us & get the dump.\n*\nSBSETRP  DS    0H\n         LA    R2,SBSNAPL              provide SNAP parms\n         SETRP WKAREA=(R3),            SDWA                            +\n               DUMP=YES,               merge dump options              +\n               DUMPOPT=(R2),           SNAP  dump options              +\n               RC=0                    percolate ABEND\n*\n*  Percolate the ABEND\n*\nSBPERC   DS    0H\n         SLR   R15,R15                 rc = percolate ABEND\n         BR    R4                      return to RTM2\n*\n*  I have to admit the SVC3 is a bit of experimentation\n*  For now, it puts a quick end to our misery\n*  MVS38j SVC3 source: SYM12 - IEAVEOR\n*\nSBEXIT   DS    0H\n         SVC   3                       EXIT our PRB\n*\n*  SNAP macro parm list\n*  TCB, DCB, and STRHDR options ignored by RTM2\n*\nSBSNAPL  SNAP  MF=L,                                                   +\n               SDATA=(CB,ERR,DM),                                      +\n               PDATA=ALL\nL$SNAPL  EQU   *-SBSNAPL\n         POP   USING              <SUBAIL>\n         EJECT ,\n*----------------------------------------------------------------------\n*  ESTAE retry exit routine (local) - no SDWA\n*\n*  Entry parms:\n*  R0    = 12 (no SDWA)\n*  R1    address of user parm list (ESTAE PARAM=(WAREG))\n*  R2    0 or address of PIRL (if I/O was quiesced and restorable)\n*  R14   address of supervisor-assisted exit linkage\n*  R15   entry point address of retry routine (RETRY1)\n*\n*----------------------------------------------------------------------\n         PUSH  USING              <RETRY1>\n         DROP  ,\nRETRY1   DS    0H\n         USING *,R15\n         LA    R15,RETRY2              pretend we're RETRY2\n         SLR   R1,R1                   but without an SDWA\n         BR    R15\n*\n         POP   USING              <RETRY1>\n         EJECT ,\n*----------------------------------------------------------------------\n*  ESTAE retry routine (local) - SDWA (not yet freed), RETREGS=NO\n*\n*  Entry:\n*\n*  PSW key = PSW key of ESTAE issuer\n*  RB under which we're running is same as ESTAE issuer\n*\n*  R0    = 0\n*  R1    address of SDWA\n*  R2    unpredictable\n*  R14   address of supervisor-assisted exit linkage\n*  R15   entry point address of retry routine (RETRY2)\n*\n*----------------------------------------------------------------------\n* Reg  DSECT    usage (RETRYx & it's called subroutines)\n*----------------------------------------------------------------------\n* R0            subroutine scratch\n* R1            subroutine scratch\n* R2\n* R3   SDWA     or 0 if called from RETRY1\n* R4            return addr to RTM2 supervisor-assisted linkage\n* R5            zap reg\n* R6            subroutine reserved; scratch\n* R7   SX       subroutine SX\n* R8   SA       subroutine SA (SXBASE)\n* R9   CPD      subroutine CPD\n* R10           subroutine internal linkage\n* R11  TGDWA    subroutine TGDWA (WAREG)\n* R12           RETRYx basereg\n* R13           RETRYx ABENDing CSECT's SA\n* R14           subroutine scratch, return to RMT2\n* R15           subroutine scratch, RETRYx entry point\n*----------------------------------------------------------------------\n         PUSH  USING              <RETRY2>\n         DROP  ,\nRETRY2   DS    0H\n         USING *,R15\n         L     R12,=A(U370STAE)        standard base reg\n         DROP  R15\n         USING U370STAE,R12\n         LR    R4,R14                  supervisor-assisted return addr\n         LR    R3,R1                   SDWA (or zero)\n         USING SDWA,R3\n         BAL   R10,FINDSX              find ABENDing SX, TGD\n         USING TGDWA,WAREG\n         USING SX,R7\n         TM    TGDFLG3,TGD3DIE\n         BOR   R4                      stop the madness\n*\n         NI    TGDFLG3,255-TGD3SCHD    scheduled exit now running\n         UWTO  3,'STAE RETRY'\n         ST    R7,TGDES@AX             note in TGD as debug aid\n         LTR   R8,R8                   found SA?\n         BZ    RE2DIE                  no, badness\n*\n*  We need a DSA so we can call some U370* CSECTs prior to giving\n*  control to the remote retry routine\n*\n         OI    TGDFLG3,TGD3LOCL        local retry exit active (RETRY2)\n         BAL   R10,ALLOCDSA            allocate DSA\n         USING SAVEAREA,R13\n         LH    R14,SXLDSA              ABENDing CSECT's DSA length\n         UDIAG 2,'STAE ABENDing DSA',(R7),(R14)\n         U@SX  R14,USING=NO\n         UDIAG 7,'STAE RETRY DSA2',(R14),L$SXPFX+L$SA\n*\n*  Display diagnostics\n*\n*        UDIAGs labeled with 'Data Areas' documented in\n*        OS/VS2 SPL: Debugging Handbook\n*\n         UDIAG 1,'STAE RETRY ABENDing SX',(R7),L$SXPFX           DSAEX\n*\n         LTR   R1,R3                   set SDWA parm\n         BZ    RE2NOSDW\n         UCALL U370SDWA                analyse RTM's SDWA\n         SLR   R0,R0\n         SLR   R1,R1\n         UCALL U370QTCB                display TCB structure, etc\nRE2NOSDW DS    0H\n*\n         L     R10,TGDLDSA                     length of whole DSA pool\n         UDIAG 9,'STAE RETRY DSA pool',(WAREG),(R10),FIN=RE2DIAGX\n         UDIAG 7,'STAE RETRY TGD',(WAREG),L$TGD                  WATGD\nRE2DIAGX DS    0H\n*\n         L     R10,PSAAOLD-PSA\n         UDIAG 7,'STAE RETRY ASCB',(R10),L$ASCB       Data Areas ASCB\n*\n         L     R10,PSATOLD-PSA\n         UDIAG 6,'STAE RETRY TCB',(R10),L$TCB         Data Areas TCB\n*----------------------------------------------------------------------\n*  Note: this would be the place to handle quiesced I/O, if any\n*----------------------------------------------------------------------\n*\n*  Attempt to locate a RRR in the SA chain\n*\n         BAL   R10,FINDRETY            find lowest RRR (R7 @ RRR SX/0)\n*\n         LTR   R3,R3                   SDWA present?\n         BZ    RE2FREED\n         LTR   R7,R7                   found RRR?\n         BZ    RE2FREE                 no, free SDWA\n         USING CPD,R9\n         TM    CPDEFLG1,CPDE1SDW       RRR wants SDWA?\n         BO    RE2FREED                ok, but RRR must free SDWA\n*\n*  Free SDWA\n*\nRE2FREE  SLR   R0,R0\n         ICM   R0,8,SDWASPID           SDWA subpool\n         ICM   R0,3,SDWALNTH           SDWA length\n         FREEMAIN R,LV=(0),A=(R3)      release SDWA storage\n         SLR   R3,R3                   SDWA gone\nRE2FREED DS    0H\n         DROP  R3\n         LTR   R7,R7                   found RRR?\n         BZ    RE2PUNT2                none provided, skip\n*\n*  Call remote retry routine\n*  The supervisor-assisted return address is provided in case the\n*  retry routine decides to abandon hope\n*\nRE2RMT   DS    0H\n         SLR   R0,R0\n         ST    R0,CPDEREGS+(R0*4)      RRR R0=0 (reserved for future)\n         ST    R3,CPDEREGS+(R1*4)      RRR R1@SDWA or zero\n         ST    R7,TGDES@RX             @ RRR SX\n         SLR   R10,R10\n         ICM   R10,3,CPDL              RRR CPD length\n         UDIAG 6,'STAE RETRY RRR CPD',(R9),(R10),FIN=RE2RRRD\n         UDIAG 1,'STAE RETRY RRR CPD',(R9),L$CPDPFX\nRE2RRRD  SLR   R10,R10\n         ICM   R10,3,SXLDSA            RRR DSA length\n         UDIAG 4,'STAE RETRY RRR DSA',(R7),(R10),FIN=RE2CALL\n         UDIAG 1,'STAE RETRY RRR SX ',(R7),L$SXPFX\n*\nRE2CALL  DS    0H\n         L     R10,CPDE#RUN           # times RRR run\n         LA    R10,1(,R10)\n         ST    R10,CPDE#RUN\n*\n         LA    R13,SXBASE              @ remote retry rtn's SA\n         LR    R14,R4                  supervisor return addr\n         L     R15,CPDE@RRR            RRR entry point\n         NI    TGDFLG3,255-TGD3LOCL    RETRY2 no longer active\n         OI    TGDFLG3,TGD3RMT         RRR active\n         OI    CPDEFLG2,CPDE2RRR       RRR being called\n         LM    R0,R12,CPDEREGS         restore RRR regs\n         BR    R15                     call RRR\n*\n*  no RRR to call, abandon\n*\nRE2PUNT2 DS    0H\n         UWTO  0,'STAE RETRY - no RRR'\n*\nRE2DIE   DS    0H\n         OI    TGDFLG3,TGD3DIE         c'ya\n         MVC   SAESTAE(L$ESTAE),MDLESTAE\n         ESTAE 0,MF=(E,SAESTAE)        cancel ESTAE environment\n         UWTO  0,'STAE RE2DIE'\n         ABEND 370,DUMP                leave DSA pool for DUMP\n*\n         POP   USING              <RETRY2>\n         EJECT ,\n*----------------------------------------------------------------------\n*  Find CPD - called by SUPPORT (HVSDWA)\n*  Duplicates lots of RETRYx subrtns, in a very abbreviated manner\n*  The whole point of this routine is to find the RRR's CPD for\n*  SUPPORT (HVSDWA) so it can check the SNAP options\n*  Calls no one; has no savearea\n*----------------------------------------------------------------------\n* Entry:\n* R10    return addr\n* R11    @ TGDWA (WAREG)\n* R12    @ U370STAE\n*\n* Returns:\n* R9     0 or @ RRR's CPD\n*\n* Uses:\n* R0     SX prefix length\n* R1     @ SX\n* R9     @ selected CPD\n* R14    @ trial CPD\n* R15    @ SA\n*\n         PUSH  USING              <FINDCPD>\n         DROP  ,\n         USING PSA,0\n         USING TGDWA,R11\n         USING U370STAE,R12\nFINDCPD  DS    0H\n*\n*  Run the SA chain forward, reviewing SXs & CPDs as we go\n*  The ABENDing CSECT's SA is at the end of the chain\n*  The CPD we're interested in is associated with the lowest\n*  level SA which has an active RRR; that will be the one that\n*  RETRYx calls to perform recovery\n*\n         LA    R0,L$SXPFX         SX prefix length\n         SLR   R9,R9              clear CPD ptr\n         LA    R15,TGDSA1         @ 1st SA\nFCLOOP   DS    0H\n         LA    R1,0(,R15)         clear hi (might not be ours)\n         SR    R1,R0\n         USING SX,R1\n         CLC   SXVER,TGDSAVER     one of our saveareas?\n         BNER  R10                no, look no further\n         ICM   R14,15,SX@CPD      CPD present?\n         BZ    FCNEXT             no, ignore\n         USING CPD,R14\n         CLC   CPDID,SXID         better match\n         BNE   FCHOSED\n         TM    CPDEFLG2,CPDE2RRV  RRR valid?\n         BNO   FCNEXT\n         LR    R9,R14             found CPD w/ valid ESTAE fields\nFCNEXT   DS    0H\n         ICM   R15,15,8(R15)      @ next lower SA\n         BNZ   FCLOOP             scan to end of SA chain\n         BR    R10                return to caller\n*\nFCHOSED  SLR   R9,R9              CPD/SX damaged, don't sched RRR\n         UWTO  0,'STAE FC CPD/SX corrupt'\n         BR    R10\n         POP   USING              <FINDCPD>\n         EJECT ,\n*----------------------------------------------------------------------\n*  Find SX, verify validity\n*----------------------------------------------------------------------\n* Entry:\n* R10    return addr\n* R12    @ U370STAE\n*\n* Returns:\n* R7     SX (prefix) - invalid when R8=0\n* R8     SA (basic section)  = 0 when FINDSX had problem\n* R11    TGDWA (WAREG)\n*\n* Uses:\n* R0     scratch\n* R1     scratch\n* R6     reserved\n* R7     SX\n* R8     SA\n* R10    return addr\n* R11    TGDWA (WAREG)\n* R14    scratch\n* R15    scratch\n*----------------------------------------------------------------------\n*  Find SX\n*----------------------------------------------------------------------\n         PUSH  USING              <FINDSX>\n         DROP  ,\n         USING U370STAE,R12\nFINDSX   DS    0H\n         SLR   R8,R8                        assume bad news\n         L     R14,PSATOLD-PSA              my TCB addr\n         LA    R14,0(,R14)                  clear hi byte\n*\n         SLR   WAREG,WAREG\n         ICM   WAREG,7,TCBFSAB-TCB(R14)     @ MVS-provided savearea\n         L     WAREG,SX@FWD-SXBASE(,WAREG)  @ xxxx370 1st SA\n         LTR   R0,WAREG\n         BZ    FSNOWA\n*\n         LA    R15,TGDSA1-TGDWA             offset adjustment\n         SR    WAREG,R15\n         USING TGDWA,WAREG\n*\n         CLC   =C'DSA ',TGDEYE+4            verify eyecatcher\n         BE    FSLOOP\n*\nFSBADEYE WTO   'STAE FINDSX bad TGDEYE'\n         BR    R10                          return w/ bad news\n*\nFSNOWA   WTO   'STAE FINDSX no TGDWA'\n         BR    R10                          return w/ bad news\n*\n*  Run savearea chain to end\n*\nFSLOOP   DS    0H\n         LR    R8,R0\n         CLC   SXVER-SXBASE(L'SXVER,R8),TGDSAVER    one of our SAs?\n         BNE   FSFINI                               no, br\n         ICM   R0,15,SX@FWD-SXBASE(R8) @ next lower SA\n         BNZ   FSLOOP                  last SA has fwd ptr = 0\n*\nFSFINI   DS    0H\n         LR    R7,R8\n         LA    R0,L$SXPFX              length of SX prefix\n         SR    R7,R0                   back up to SX (prefix)\n         BR    R10\n*\n         POP   USING              <FINDSX>\n         EJECT ,\n*----------------------------------------------------------------------\n*  FINDRETY - Find RRR - scan SA chain\n*  Side effect: prints SA chain (diag level 4)\n*  Caller's regs restored except R7, R9\n*----------------------------------------------------------------------\n* Entry:\n* R10    return addr\n* R11    TGDWA\n* R12    U370STAE\n* R13    SAVEAREA\n*\n* Returns:\n* R7     zero or lowest level SX  with CPDE@RRR\n* R9     zero or lowest level CPD with CPDE@RRR\n*\n* Uses:\n* R0     scratch\n* R1     scratch\n* R5     SX prefix length\n* R6     SX to be returned\n* R7     SX\n* R8     CPD to be returned\n* R9     CPD\n* R10    DSA length\n* R14    scratch\n* R15    scratch\n*----------------------------------------------------------------------\n         PUSH  USING              <FINDRETY>\n         DROP  ,\n         USING PSA,0\n         USING TGDWA,WAREG\n         USING U370STAE,R12\n         USING SAVEAREA,R13\nFINDRETY DS    0H\n         STM   R0,R15,SALOWSA          save caller's regs\n         LA    R5,L$SXPFX              SX prefix length\n         SLR   R6,R6                   SX returned\n         SLR   R8,R8                   CPD returned\n         LA    R7,TGDSA1-L$SXPFX       @ 1st application SA\n         USING SX,R7\n*\nFRLOOP   DS    0H\n         CLC   SXVER,TGDSAVER          one of our SAs?\n         BNE   FRLAST                  no, br\n         ICM   R7,15,SX@FWD            @ next lower SA\n         BZ    FRLAST                  last active SA, br\n         SR    R7,R5                   @ SX prefix\n*\n*  Display CPD\n*\n         ICM   R9,15,SX@CPD            @ CPD\n         BZ    FRCP2                   no CPD = no retry routine\n         USING CPD,R9\n         SLR   R10,R10\n         ICM   R10,3,CPDL              CPD length\n         BZ    FRCP1\n         UDIAG 8,'STAE FINDRETY SA chain CPD',(R9),(R10),FIN=FRCP2\nFRCP1    UDIAG 5,'STAE FINDRETY SA chain CPD',(R9),L$CPDPFX\nFRCP2    DS    0H\n*\n*  Display DSA/SX\n*\n         SLR   R10,R10\n         ICM   R10,3,SXLDSA            DSA length\n         BZ    FRSX1\n         UDIAG 8,'STAE FINDRETY SA chain DSA',(R7),(R10),FIN=FRSX1\n         UDIAG 5,'STAE FINDRETY SA chain SX',(R7),L$SXPFX\nFRSX1    DS    0H\n         LTR   R9,R9                   no CPD?\n         BZ    FRLOOP                  yes, nothing to check\n         CLC   CPDID,SXID              better match\n         BNE   FRHOSED\n*\n*  Exercise a little caution here, the CPDE@RRR field isn't\n*  present if CSECT didn't request ESTAE support\n*\n         TM    CPDEFLG2,CPDE2RRV       retry routine present?\n         BNO   FRLOOP                  no, leave retry reg alone\n         ICM   R0,15,CPDE@RRR          really present?\n         BZ    FRLOOP                  no, leave retry reg alone\n         LR    R6,R7                   lowest level SX w/ retry\n         LR    R8,R9                   lowest level CPD w/ retry\n         B     FRLOOP\n*\nFRHOSED  DS    0H\n         UWTO  0,'STAE FR CPD/SX corrupt'\n         UDIAG 0,'STAE FR corrupt CPD',(R9),L$CPDPFX\n         UDIAG 0,'STAE FR corrupt SX',(R7),L$SXPFX\n         SLR   R8,R8                   run RRR? no way!\n*\nFRLAST   DS    0H\n         XC    SALOWSA+(R7*4)(4),SALOWSA+(R7*4)   clear caller R7\n         XC    SALOWSA+(R9*4)(4),SALOWSA+(R9*4)   clear caller R9\n         LTR   R8,R8                   found RRR?\n         BZ    FREXIT                  no, return w/o RRR\n*\n*  Trim SA chain at the RRR's SA, return R7 & R9 to caller\n*\n         XC    SX@FWD-SX(L'SX@FWD,R6),SX@FWD-SX(R6)\n         ST    R6,SALOWSA+(R7*4)       modify return R7 @ SX\n         ST    R8,SALOWSA+(R9*4)       modify return R9 @ CPD\n*\nFREXIT   DS    0H\n         LM    R0,R15,SALOWSA          restore caller regs + R7, R9\n         BR    R10\n         POP   USING              <FINDRETY>\n         EJECT ,\n*----------------------------------------------------------------------\n*  ALLOCDSA - allocate DSA, set R13\n*----------------------------------------------------------------------\n* Entry:\n* R10    return addr\n* R11    TGD\n* R12    U370STAE\n*\n* Returns:\n* R13    @ SXBASE (SA)\n*\n* Uses:\n* R0     scratch\n* R1     scratch\n* R13    DSA\n* R14    scratch\n* R15    scratch\n*----------------------------------------------------------------------\n         PUSH  USING              <ALLOCDSA>\n         DROP  ,\n         USING TGDWA,WAREG\n         USING U370STAE,R12\n*\nALLOCDSA DS    0H\n*\n*  Allocate copy of our SAVEAREA via QDSA2\n*\n         UPRLOC QDSA2,R13              address new DSA\n         USING SX,R13\n*\n         LR    R0,R13                  dest addr\n         L     R1,=A(L$SXPFX+L$SA)     dest len\n         SLR   R15,R15                 source len\n         MVCL  R0,R14                  clear borrowed DSA\n*\n*  Finish initializing DSA\n*  Highly dependent on current UPROC & U370AP00 implementations\n*\n         MVC   SXID,=CL8'ESTAEDSA'     identify funky DSA\n         LA    R0,L$SA                 SA  length\n         STH   R0,SXLSA\n         LA    R0,L$SXPFX+L$SA         DSA length\n         STH   R0,SXLDSA\n*\n*  Leave new DSA out of the SA chain, in case of trouble\n*  in whatever CSECTs RETRY2 calls.\n*\n         LA    R13,SXBASE              @ our borrowed SA\n         BR    R10\n*\n         POP   USING              <ALLOCDSA>\n         EJECT ,\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\nMDLESTAE ESTAE MF=L                    model ESTAE\nL$ESTAE  EQU   *-MDLESTAE\n*\n         PRINT DATA\nPATCH2   DC    32S(*)                  additional patch space\n         LTORG ,\n         EJECT ,\n*----------------------------------------------------------------------\n*  Savearea/workarea\n*  Layout common to both U370STAE mainline and RETRY2\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSASA     DS    18F\nSALOWSA  DS    16F                internal subroutine usage\n*\nSAENTRY  DS    2F                 entry regs (mainline)\nSAR0     EQU   SAENTRY+0,4        entry flags\nSAR0B2   EQU   SAENTRY+2,1        entry flags\nSAR0B3   EQU   SAENTRY+3,1        entry flags\nSAR1     EQU   SAENTRY+4,4        RRR addr\n*\nSAESTAE  ESTAE MF=L\nSAREASON DS    C\n*\nSAMSG1   DS    0C\nSAM1LIT1 DS    C'<x> STAE main'\n         DS    C' '\nSAM1TXT1 DS    C'xxxx'                 init, term\n         DS    C' '\nSAM1TXT2 DS    CL8                     CSECT\n         DS    C' '\nSAM1TXT3 DS    CL8                     entry parms\n         DS    C' '\nSAM1TXT4 DS    CL8                     RRR addr\nL$MSG1   EQU   *-SAMSG1\n*\n         DS    0D\nL$SA     EQU   *-SAVEAREA\n*\n         WATGD ,\n*\n         EJECT ,\n         PRINT NOGEN\n*\n         IHAPSA DSECT=YES\n*\n         IHAASCB ,\nL$ASCB   EQU   *-ASCB\n*\n         IKJTCB DSECT=YES,LIST=NO\nL$TCB    EQU    TCBMNLEN\n*\n         IKJRB  DSECT=YES\n*\n         IHASDWA ,\nL$SDWA   EQU    *-SDWA\n*\n**       IHARTM2A ,                    can't find DSECT source\n*\n         IHARTCT ,\nL$RTCT   EQU    *-RTCT\n*\n         PRINT ON,GEN\nU370STAE UFINI DXDUSTAE,L$SA\n*\nDXDUSTA2 U#DPR QDSA2,L$SXPFX+L$SA      DSA for RETRY code\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "U370TIOT": {"ttr": 13318, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00o\\x00o\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 111, "newlines": 111, "modlines": 0, "user": "XV0006"}, "text": "*\n* Copyright 2001, 2002 James M. Morrison\n*\n         PRINT  NOGEN\n         IHAPSA DSECT=YES              PREFIXED STORAGE AREA\n*\n         IKJTCB DSECT=YES,LIST=NO      TASK CONTROL BLOCK\n*\nTIOT     DSECT\n         IEFTIOT1                      TASK INPUT-OUTPUT TABLE\n*\n         PRINT GEN\nU370TIOT TITLE 'Scan TIOT for DDNAME'\nU370TIOT CSECT ,\n*----------------------------------------------------------------------\n*\n*  U370TIOT is called before U370DBUG has finished setting up the\n*  debug bytes, so U370TIOT's message(s) always appear.\n*  Not really very useful, and mildly annoying.  The DIAG=NO\n*  suppresses expansion of XMITDIAG in this CSECT.\n*\n         U#SET DIAG=NO,FUNC=UTIL       suppress UDIAG\n*----------------------------------------------------------------------\n* Function:    Given a DDNAME, determine whether it is allocated\n*              by scanning the TIOT.\n*\n* Entry:  R0 =\n*         R1 = address of CL8'ddname' field\n*\n* Exit:   R1  =  address of TIOT entry\n*                0     DDNAME not allocated\n*\n* Notes:\n*\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\n* R2     TIOT entry\n* R3\n* R4\n* R5\n* R6\n* R7\n* R8\n* R9     DDNAME ptr\n* R10\n*----------------------------------------------------------------------\nU370TIOT UPROC ID=UTIO,L=L$SA\n         LR    R9,R1                        save caller's R1\n         UDIAG 1,'U370TIOT entered'\n         UDIAG 3,'U370TIOT: ddname',(R9),8\n         EJECT ,\n*----------------------------------------------------------------------\n*  Find TIOT, see if ddname allocated\n*----------------------------------------------------------------------\n         USING PSA,0\n         L     R15,PSATOLD             my TCB\n         USING TCB,R15\n*\n         L     R14,TCBTIO              TCB's TIOT\n         DROP  R15\n         USING TIOT1,R14\n*\n         LA    R2,TIOENTRY             @ 1st entry\n         DROP  R14\n         USING TIOENTRY,R2\n*\n         SLR   R6,R6\n*\nNEXTENT  DS    0H\n         ICM   R6,1,TIOELNGH           TIOT entry length\n         BZ    EOT                     no more entries\n*\n         CLC   TIOEDDNM,0(R9)          found DDNAME?\n         BE    FOUND\n*\n         LA    R2,0(R6,R2)             @ next entry\n         B     NEXTENT\n*\nEOT      DS    0H\n         UDIAG 3,'U370TIOT ddname not allocated'\n         XC    SARETVAL,SARETVAL       TIOT entry ptr = 0\n         B     EXIT\n*\nFOUND    DS    0H\n         UDIAG 3,'U370TIOT ddname allocated'\n         ST    R2,SARETVAL             TIOT entry ptr\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\nEXIT     UDIAG 1,'U370TIOT exited'\n         L     R1,SARETVAL             return value = TIOT ptr or 0\n         SLR   R15,R15\n         UPEND R1=PASS                 return to caller w/ R1 intact\n*\n         LTORG ,\n*----------------------------------------------------------------------\n*  Dynamic savearea & workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSAVREGS  DS    18F\nSARETVAL DS    F                       return value (R1)\n         DS    0D\nL$SA     EQU   *-SAVEAREA              length of savearea\n*\n         PRINT NOGEN\n         WATGD ,\n*\n         PRINT GEN\nU370TIOT UFINI DXDUTIOT,L$SA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "U370VADR": {"ttr": 13321, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x01g\\x01g\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 359, "newlines": 359, "modlines": 0, "user": "XV0006"}, "text": "U370VADR TITLE 'Text description of virtual address'\n*\n* Copyright 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  To do:\n*  1) Check MVS38j SHOWMVS, finish writing CKAREA\n*----------------------------------------------------------------------\n         U#SET FUNC=UTIL\n*----------------------------------------------------------------------\n* Function:    Given a virtual address, attempt to describe that\n*              address with a text message\n*\n*              See BUFFER DSECT for output layout\n*\n* Entry:  R0 = virtual address to be described\n*         R1 = addr of CL40 field to receive text\n*              DVADRBUF macro describes this area\n*\n* Exit:   R15 = 00\n*\n* Diagnostics:\n*             3 - CDE/XTLST\n*             9 - entry/exit\n*\n* Notes:\n*\n*----------------------------------------------------------------------\n* Reg  DSECT    usage\n*----------------------------------------------------------------------\n* R2            vaddr caller wants described\n* R3   BUFFER   output buffer\n* R4\n* R5\n* R6\n* R7\n* R8\n* R9            internal linkage\n* R10           internal linkage\n* R11  TGD      common\n* R12           base reg\n* R13  SAVEAREA savearea\n*----------------------------------------------------------------------\n         TITLE ' '\nU370VADR UPROC ID=UVAD,L=L$SA,CPD=(N,0)\n         USING PSA,0\n         LR    R2,R0                   requested virtual addr\n         LA    R2,0(,R2)               clean hi byte\n         LR    R3,R1                   @ output buffer\n         USING BUFFER,R3\n*\n         UDIAG 9,'U370VADR enter'\n*\n         MVI   0(R3),C' '\n         MVC   1(L$VADRBF-1,R3),0(R3)  clear callers' buffer\n         EJECT ,\n*----------------------------------------------------------------------\n*  Check areas first, refine search when found in specific area\n*----------------------------------------------------------------------\nCKAREA   DS    0H\n*\nCKPSA    SLR   R14,R14                 PSA begins at location 0\n         L     R15,=A(L$PSA)           PSA length = 4KB\n         LA    R9,CKNUC                CKBOUND failure addr\n         BAL   R10,CKBOUND             vaddr within area?\n         MVC   BUFAREA(3),=C'PSA'\n         B     AREAHIT\n*\nCKNUC    L     R4,FLCCVT               @ CVT\n         USING CVT,R4\n         L     R14,=A(L$PSA)           PSA/NUC contiguous\n         L     R15,CVTNUCB             lowest addr not in nuc\n         BCTR  R15,0                   lowest nuc addr\n         SR    R15,R14                 convert to length for CKBOUND\n         LA    R9,CKPRIV               CKBOUND failure addr\n         BAL   R10,CKBOUND             vaddr within area?\n         MVC   BUFAREA(3),=C'NUC'\n         B     AREAHIT\n*\nCKPRIV   L     R5,CVTGDA               @ Global Data Area\n         USING GDA,R5\n         L     R14,PASTRT              GDA -> private area start\n         L     R15,PASIZE              GDA -> private area length\n         LA    R9,CKSQA                CKBOUND failure addr\n         BAL   R10,CKBOUND             vaddr within area?\n         MVC   BUFAREA(4),=C'PRIV'\n         B     SCANJPAK                refine search further\n*\nCKSQA    L     R6,SQASPQEP             GDA -> SQA (SP245) SPQE\n         USING SPQESECT,R6\n         L     R7,SPDQEPTR             SPQE -> DQE\n         USING DQESECT,R7\n         L     R14,DQEBLKAD            @ SQA begin\n         L     R15,DQELNTH             SQA length\n         LA    R9,CKPLPA               CKBOUND failure addr\n         BAL   R10,CKBOUND             vaddr within area?\n         MVC   BUFAREA(3),=C'SQA'\n         B     AREAHIT\n*\nCKPLPA   LR    R15,R14                 @ SQA begin\n         BCTR  R15,0                   PLPA/SQA contiguous\n         L     R14,CVTLPDIA            CVT -> LPA directory\n         LA    R14,0(,R14)             clear hi byte\n         SR    R15,R14                 convert to length for CKBOUND\n         LA    R9,CKCSA                CKBOUND failure addr\n         BAL   R10,CKBOUND             vaddr within area?\n         MVC   BUFAREA(4),=C'PLPA'\n         B     SCANLPA                 refine search further\n*\nCKCSA    L     R6,CSAPQEP              GDA -> CSA PQE\n         USING PQESECT,R6\n         L     R14,PQEREGN             @ CSA\n         L     R15,PQESIZE             L' CSA\n         LA    R9,COMMON               CKBOUND failure addr\n         BAL   R10,CKBOUND             vaddr within area?\n         MVC   BUFAREA(3),=C'CSA'\n         B     AREAHIT\n*\n*  OK, it's not PSA, NUC, or PRIV ... hence it's somewhere in COMMON\n*\nCOMMON   L     R15,CVTMZ00             top of machine\n         MVC   BUFAREA(6),=C'COMMON'\n*\nAREAHIT  DS    0H\n         BAL   R10,FMTAREA             stuff R14/R15 into message\n         B     EXIT\n         EJECT ,\n*----------------------------------------------------------------------\n*  Scan Link Pack (common area)\n*----------------------------------------------------------------------\nSCANLPA  DS    0H\n         L     R4,FLCCVT               @ CVT\n         USING CVT,R4\n         L     R5,CVTQLPAQ             @ 1st LPDE\n         ICM   R5,15,0(R5)             anybody home?\n         BZ    EXIT\n         USING LPDE,R5\n         BAL   R9,SCLPLOOP             R9 @ CKBOUND failure addr\n*\nSCLPNEXT ICM   R5,15,LPDECHN           next LPDE\n         BZ    EXIT                    no more LPDEs\n*\nSCLPLOOP DS    0H\n         TM    LPDEATTR,LPDEMIN        minor LPDE?\n         BOR   R9                      yes, ignore it\n         L     R14,LPDEXTAD            addr of module load pt\n         L     R15,LPDEXTLN            length of module in vstor\n         BAL   R10,CKBOUND             check R2 within bounds\n*\n*  Found LPDE containing vaddr\n*\n         MVC   BUFAREA(3),=C'LPA'\n         MVC   BUFMOD,LPDENAME         module name\n         BAL   R10,FMTAREA             stuff R14/R15 into message\n         B     SCANVTAB                see if one of our CSECTs\n         EJECT ,\n*----------------------------------------------------------------------\n*  Scan CDEs in TCB's Job Pack (private area)\n*----------------------------------------------------------------------\nSCANJPAK DS    0H\n         L     R4,PSATOLD              current TCB\n         USING TCB,R4\n         L     R4,TCBJSTCB             job step TCB\n         L     R5,TCBJPQ               @ 1st jobpack CDE\n         USING CDENTRY,R5\n         BAL   R9,JPCDLOOP             @ CKBOUND failure addr\n*\nJPCDNEXT ICM   R5,15,CDCHAIN           next CDE\n         BZ    PRIVMORE                check more private area stuff\n*\nJPCDLOOP DS    0H\n*        UDIAG 3,'U370VADR CDE',(R5),L$CDE\n         TM    CDATTR,CDMIN            minor CDE?\n         BOR   R9                      yes, skip it\n*\n         L     R6,CDXLMJP              extent list\n         USING XTLST,R6\n*        UDIAG 3,'U370VADR XTLST',(R6),L$XTLST\n*\n         L     R14,XTLMSBAA            addr of module load pt\n         SLR   R15,R15\n         ICM   R15,7,XTLMSBLN          length of module in vstor\n         BAL   R10,CKBOUND             R2 within bounds?\n*\n*  Found CDE containing vaddr\n*\n         MVC   BUFAREA(4),=C'JPAQ'\n         MVC   BUFMOD,CDNAME           just right, have module name\n         BAL   R10,FMTAREA             stuff R14/R15 into message\n         DROP  R4,R5,R6\n         EJECT ,\n*----------------------------------------------------------------------\n*  Scan VCON table (vaddr found in either LPA or JobPack)\n*----------------------------------------------------------------------\nSCANVTAB DS    0H\n         ICM   R15,15,TGD@VTAB         @ VCON table\n         BZ    EXIT                    no VCON table\n         LM    R5,R7,0(R15)\n         USING VTABLE,R5\n*\n         LA    R10,SVCSECT             @ CKBOUND success addr\nSVLOOP   DS    0H\n         L     R14,VTABVCON            @ CSECT begin\n         LH    R15,VTCSL               approx CSECT length\n         BAL   R9,CKBOUND              see if within bounds\n         BXLE  R5,R6,SVLOOP\n         B     EXIT\n*\nSVCSECT  DS    0H\n         MVI   BUFDOT1,C'.'\n         MVC   BUFCSECT,VTABNAME       CSECT found in VCON table\n         MVI   BUFDOT2,C'+'\n         LR    R0,R2\n         SR    R0,R14                  offset within CSECT\n         LA    R1,BUFOFF\n         UCALL U370HEX\n         B     EXIT\n         EJECT ,\n*----------------------------------------------------------------------\n*  Private area - not in CDE\n*----------------------------------------------------------------------\nPRIVMORE DS    0H\n         CR    R2,WAREG                TGD?\n         BNE   PRIV002\n         MVC   BUFMOD(3),=C'TGD'\n         LR    R14,WAREG\n         LA    R15,L$TGD\n         AR    R15,R14\n         BAL   R10,FMTAREA\n         B     EXIT\n*\n*  Scan VCON table for CPD & DSA\n*\nPRIV002  DS    0H\n         ICM   R15,15,TGD@VTAB         @ VCON table\n         BZ    PRIV003                 no VCON table\n         LM    R5,R7,0(R15)\n         USING VTABLE,R5\n*\nCPLOOP   DS    0H\n         L     R14,VT@CPD              @ CSECT's CPD\n         LH    R15,VTCPDL              CPD length\n         LA    R10,CPHIT               @ CKBOUND success addr\n         BAL   R9,CKBOUND              see if within bounds\n*\n         L     R14,VT@SX               @ CSECT's SX\n         LH    R15,VTDSAL              DSA length\n         LA    R10,SXHIT               @ CKBOUND success addr\n         BAL   R9,CKBOUND              see if within bounds\n*\n         BXLE  R5,R6,CPLOOP\n         B     PRIV003\n*\nCPHIT    DS    0H\n         MVC   BUFMOD(3),=C'CPD'\n         B     SVWHO\n*\nSXHIT    DS    0H\n         MVC   BUFMOD(3),=C'DSA'\n*\nSVWHO    DS    0H\n         MVI   BUFDOT1,C' '\n         MVC   BUFCSECT,VTABNAME       CSECT found in VCON table\n         MVI   BUFDOT2,C' '\n         B     EXIT\n*\nPRIV003  DS    0H\n         LR    R14,WAREG               DSA pool?\n         L     R15,TGDLDSA\n         LA    R9,PRIV004\n         BAL   R10,CKBOUND\n         MVC   BUFMOD,=C'DSA POOL'\n         BAL   R10,FMTAREA             stuff R14/R15 into message\n         B     EXIT\n*\nPRIV004  DS    0H\nPRIV999  DS    0H\n         L     R4,FLCCVT               @ CVT\n         USING CVT,R4\n         L     R5,CVTGDA               @ Global Data Area\n         USING GDA,R5\n         L     R14,PASTRT              GDA -> private area start\n         L     R15,PASIZE              GDA -> private area length\n         AR    R15,R14\n         BAL   R10,FMTAREA\n         EJECT ,\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\nEXIT     DS    0H\n         UDIAG 9,'U370VADR exit'\n         UPEND ,                       return to caller\n         LTORG ,\n         EJECT ,\n*----------------------------------------------------------------------\n*  CKBOUND - check boundaries - R2 vaddr, R14 begin addr, R15 length\n*  Returns via R9 for failure, R10 for success\n*----------------------------------------------------------------------\nCKBOUND  DS    0H\n         LA    R14,0(,R14)             clean hi byte\n         CR    R2,R14                  vaddr too low?\n         BLR   R9                      yes, fail return\n         AR    R15,R14                 @ past end of module\n         CR    R2,R15                  vaddr too high?\n         BNLR  R9                      yes, fail return\n         ST    R14,SA@MOD              save module load point addr\n         BR    R10                     no, success return\n*----------------------------------------------------------------------\n*  FMTAREA - Given R14 & R15 (after CKBOUND success), fill in\n*  description of area containing vaddr\n*----------------------------------------------------------------------\nFMTAREA  DS    0H\n         STM   R14,R15,SAAREA          save @start, @end\n         LR    R0,R14\n         LA    R1,BUF@BEG\n         UCALL U370HEX\n         MVI   BUFDASH,C'-'\n         L     R0,SAAREA+4             @ area end\n         LA    R1,BUF@END\n         UCALL U370HEX\n         BR    R10                     no, success return\n*----------------------------------------------------------------------\n*  BUFFER description\n*----------------------------------------------------------------------\nBUFFER   DSECT ,\n         DVADRBUF PFX=BUF\n*----------------------------------------------------------------------\n*  Dynamic savearea & workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSASA     DS    18F\nSA@MOD   DS    A                       addr of module containg vaddr\nSAAREA   DS    2A                      FMTAREA @start, @end\n         DS    0D\nL$SA     EQU   *-SAVEAREA              length of savearea\n*\n         UVTAB MF=DSECT                VCON table\n         WATGD ,\n*\n         PRINT OFF,NOGEN\n         IHAPSA DSECT=YES\nL$PSA    EQU   *-PSA\n         CVT   DSECT=YES,LIST=NO\n         IKJTCB DSECT=YES,LIST=NO\n         IHALPDE ,\n         IHACDE ,\nL$CDE    EQU   *-CDENTRY\n         IHALLE ,\n         IHAXTLST ,\nL$XTLST  EQU   *-XTLST\n*\n         EJECT ,\n         IHAGDA ,\n         IHAPQE ,\n         IHASPQE ,\n         IHADQE ,\n         PRINT GEN\nU370VADR UFINI DXDUVADR,L$SA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "U370WTO": {"ttr": 13572, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\xa1\\x00\\xa1\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 161, "newlines": 161, "modlines": 0, "user": "XV0006"}, "text": "U370WTO  TITLE 'Issue WTO'\n*\n* Copyright 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n         U#SET FUNC=UTIL\n*----------------------------------------------------------------------\n* Function:    Issue Write To Operator (WTO, SVC 35)\n*              Echoes WTO text in xxxxLOG via ULOG\n*\n*              Supports Helper macro: UWTO\n*\n* Entry:  R0   bits\n*\n*              00:23   currently ignored\n*\n*              24:31   option bits as described in WATGD:\n*\n*                      UWTO$DSC - descriptor codes valid\n*                      UWTO$RTC - routing    codes valid\n*\n*         R1 = address of following:\n*\n*         -08  (02)    WPLLGH\n*         -06  (02)    MCS flags\n*         -05  (01)    ignored - msg 'x'\n*         -04  (02)    descriptor code or x'0000' (default  8)\n*         -02  (02     routing    code or x'0000' (default 11)\n*         +00  (01)    text length (truncated after 124 bytes)\n*         +01  (nn)    message text\n*\n* Exit:   R15 = 0\n*\n* Notes:  Does not support multi-line WTOs or WTOR\n*         Mostly used when WTO text is variable\n*\n*         The parmlist to this routine is intended to make things\n*         as easy as possible for the caller.  If all that is\n*         desired is to issue a WTO with given text and take the\n*         defaults for everything else, only the +00 and +01\n*         elements are needed, with R1 pointing at the one byte\n*         length & R0 = x'00'.\n*\n*         If the caller wishes to specify any of the elements in\n*         the prefix portion (negative offsets), a WTO MF=L\n*         macro can be expanded in the caller's CSECT to set\n*         up our parmlist, with the text length and desired text\n*         immediately behind the expansion, R1 pointing at the\n*         one byte length code at +00 & R0 set to select the\n*         desired prefix elements.\n*\n*         Currently, the caller's MCS flags are ignored.\n*\n*----------------------------------------------------------------------\n* Reg  DSECT    usage\n*----------------------------------------------------------------------\n* R2            spare\n* R3            @ text length, text\n* R4            @ caller's desc & routing codes, if any\n* R5            00:15 - desc, 16:31 - rout\n* R6            text length, WPLLGH\n* R7            effective text length\n* R8            @ WTO parmlist desc & rout codes\n* R9            l' desc & routing codes (4)\n* R10           zap reg\n*----------------------------------------------------------------------\nU370WTO  UPROC ID=UWTO,L=L$SA\n*----------------------------------------------------------------------\n         STM   R0,R2,SAENTRY           save entry parms\n         LR    R3,R1                   @ length, text\n         LR    R4,R1\n         UDIAG 1,'U370WTO enter'\n         LA    R9,L'WPLDESC+L'WPLROUT  4\n         SR    R4,R9                   @ desc & routing codes\n*\n         ICM   R5,12,DFLTDESC          load default desc code\n         ICM   R5,03,DFLTROUT          load default rout code\n         TM    SAR0B3,UWTO$DSC         descriptor codes present?\n         BNO   *+8\n         ICM   R5,12,0(R4)             load caller's desc codes\n*\n         TM    SAR0B3,UWTO$RTC         routing codes present?\n         BNO   *+8\n         ICM   R5,03,2(R4)             load caller's rout codes\n*\n         SLR   R6,R6\n         ICM   R6,1,0(R3)              text length\n         BZ    EXIT\n         LA    R15,L'SATEXT\n         CR    R6,R15                  caller's text too long?\n         BL    *+6\n         LR    R6,R15                  truncate at max\n*\n         LR    R7,R6                   effective text length\n         MVC   SAMCS,MCSFLGS           set MCS flags\n         BCTR  R6,0\n         EX    R6,COPYTEXT             copy WPLTXT\n         LA    R6,1(R9,R6)\n         STH   R6,SAWTOLGH             set WPLLGH\n*\n         LA    R8,SATEXT(R7)           @ desc & rout code slot\n         STCM  R5,15,0(R8)             save desc & rout codes\n*\n         WTO   MF=(E,SAWTO)            issue WTO\n*\n         MVC   SATEXT-06(06),=C'<WTO> '\n         LA    R7,6(,R7)\n         UDIAG 0,SATEXT-06,(R7)        echo WTO to xxxxLOG\n*\nEXIT     DS    0H                      return to caller\n         UDIAG 1,'U370WTO exit'\n         UPEND ,                       return to caller\n*----------------------------------------------------------------------\n*  Data Areas\n*----------------------------------------------------------------------\nCOPYTEXT MVC   SATEXT(*-*),1(R3)       EX'd: copy caller's WTO text\nMDLWTO   WTO   'x',ROUTCDE=11,DESC=8,MF=L\nLWTOTXT  EQU   MDLWTO+0,2              text length + 4\nMCSFLGS  EQU   MDLWTO+2,2              MCS flags\nWTOTXT   EQU   MDLWTO+4,1              text\nDFLTDESC EQU   MDLWTO+5,2              default descriptor code\nDFLTROUT EQU   MDLWTO+7,2              default routing    code\n         LTORG ,\n*----------------------------------------------------------------------\n*  Savearea & workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSASA     DS    18F\nSAENTRY  DS    3F                      R0:R1 at entry\nSAR0     EQU   SAENTRY+(R0*4),4\nSAR0B0   EQU   SAR0+0,1\nSAR0B1   EQU   SAR0+1,1\nSAR0B2   EQU   SAR0+2,1\nSAR0B3   EQU   SAR0+3,1\n*\nSAWTO    WTO   'x',ROUTCDE=11,DESC=8,MF=L\n         ORG   SAWTO\nSAWTOLGH DS    H                       combined length: text, length,\n*                                      and MCS flags (L' text + 4)\nSAMCS    DS    H                       MCS flags\nSATEXT   DS    CL124                   text follows (max 124 or 126,\n*                                      depending on whether you believe\n*                                      GC28-0683-2 OS/VS2 Supervisor\n*                                      Services and Macro Instructions\n*                                      or the IEZWPL macro)\n*                                      we pick the more restrictive 124\n*                                      from Supvr Services & Macros\n*\nSADESC   DS    XL2                     descriptor codes immediately\n*                                      follow last byte of msg text\nSAROUT   DS    XL2                     routing codes behind desc codes\n         ORG   ,\n         DS    0D                      align\nL$SA     EQU   *-SAVEAREA              length of savearea\n*\n         PRINT NOGEN\n         WATGD ,\n         PRINT GEN\n         IEZWPL ,                      WTO parmlist - SYS1.AMODGEN\nU370WTO  UFINI DXDUWTO,L$SA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WADAST": {"ttr": 13576, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n         WADAST &GEN=,&DATA=NO,&PRINT=ON\n.*\n.* Copyright 2002 James M. Morrison\n.*\n.*---------------------------------------------------------------------\n.* &GEN  - NO or null\n.* DATA  - NO or null\n.* PRINT - ON or OFF\n.*---------------------------------------------------------------------\n         PUSH  PRINT,USING\n         PRINT &PRINT,&GEN.GEN,&DATA.DATA\n*----------------------------------------------------------------------\n*  DASTWA: DAST370 common workarea - based R11\n*----------------------------------------------------------------------\nDASTWA   DSECT ,\n*\n*  Embed TGD (Task Global Data) in beginning of DASTWA\n*\n         WATGD PRINT=&PRINT,GEN=&GEN,DATA=&DATA,SECT=LABEL\n***********************************************************************\n*  Application-specific data areas\n***********************************************************************\nDASRC    EQU   TGDRC,L'TGDRC           return code\nL$DAST   EQU   *-DASTWA                length of DASTWA\n*\n         POP   PRINT,USING\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WARECV": {"ttr": 13578, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00Y\\x00Y\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 89, "newlines": 89, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n         WARECV &FUNC=RECV,&GEN=NO,&DATA=NO,&PRINT=OFF,&PFX=RCV\n.*\n.* Copyright 2001-2008 James M. Morrison\n.*\n.*---------------------------------------------------------------------\n.* &GEN  - NO or null\n.* DATA  - NO or null\n.* PRINT - ON or OFF\n.*---------------------------------------------------------------------\n         PUSH  PRINT,USING\n         PRINT &PRINT,&GEN.GEN,&DATA.DATA\n*----------------------------------------------------------------------\n*  RECVWA: RECV370 common workarea - based R11\n*----------------------------------------------------------------------\nRECVWA   DSECT ,\n*\n*  Embed TGD (Task Global Data) in beginning of WARCV\n*\n         WATGD PRINT=&PRINT,GEN=&GEN,DATA=&DATA,SECT=LABEL\n***********************************************************************\n*  Application-specific data areas\n***********************************************************************\nXMTREGS  EQU   TGDREGS,16*4            prevalent usage\nRCVREGS  EQU   TGDREGS,16*4            prevalent usage\nRCVRC    EQU   TGDRC,4                 return code\n*----------------------------------------------------------------------\n*  Data management areas\n*----------------------------------------------------------------------\nRCV@PS   DS    A                       @ XPSWA XMITPUT workarea\nRCV@GS   EQU   RCV@PS,4                @ XGSWA RECVGSEG workarea\n*\nRCVOPN   OPEN  (,),MF=L\nRCVCLOS  CLOSE (,),MF=L\n*\nRCV@JFCB DS    A                       @ JFCB for open RCVDCBI\nRCVJFCBL DS    F                       JFCB exlst for RCVDCBI\n*\n         DS    0F\nRCVJFCB1 DS    XL176                   SYSUT1 JFCB area\n*\n         DS    0F\nRCVJFCB2 DS    XL176                   SYSUT2 JFCB area\n*\n*  XMIT02A fills in 44 byte dsn from JFCB, to make IEFJFCBN\n*  offsets usable (based from RCVDSCB), and debug ease.\n*\n         DS    0F\nRCVDSCB  DS    CL44                    SYSUT1 DSCB dsname\n*\n*  Format-1 DSCB of dataset to be XMIT'd.\n*  OBTAIN macro returns first 96 bytes of RCVDSCB1 = data portion\n*  of DSCB, next 5 bytes = CCHHR of DSCB (zero for VSAM/VIO).\n*\n         DS    0F\nRCVDSCB1 DS    XL140                   SYSUT1 OBTAIN area\n*\nRCVL$DCB EQU   96                      DCB length\n         DS    0D\nRCVDCBI  DS    XL(RCVL$DCB)            input DCB\n*\n         DS    0D\nRCVDCBO  DS    XL(RCVL$DCB)            output DCB\n.*\n*----------------------------------------------------------------------\n*  RECVGSEG's workarea\n*----------------------------------------------------------------------\n         DS    0D\nRCVRGSWE DC    CL8'GETWORK '           RECVGSEG workarea eyecatcher\nRCVRGSWA DS    XL1024                  1K reserved for RECVGSEG w/a\n*----------------------------------------------------------------------\n*  RECVGCTL's output buffer\n*----------------------------------------------------------------------\n         DS    0D\nRCVGCEYE DC    CL8'RECVGCTL'           RECVGCTL workarea eyecatcher\nRCVGCBUF DS    XL1024                  RECVGCTL output buffer\nL$GCBUFL EQU   *-RCVGCBUF              RECVGCTL output buffer length\n*----------------------------------------------------------------------\n*  RECV370 - miscellaneous equates\n*----------------------------------------------------------------------\nRGET$CLO EQU   128                     RECVGSEG: close XMITIN\n*----------------------------------------------------------------------\n*  End of RECVWA\n*----------------------------------------------------------------------\nL$RCVWA  EQU   *-RECVWA\n         EJECT ,\n         WARGS ,\n         POP   PRINT,USING\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WARGS": {"ttr": 13581, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00%\\x00%\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 37, "newlines": 37, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n         WARGS &SECT=DSECT\n.*\n.* Copyright 2002-2008 James M. Morrison\n.*\n*----------------------------------------------------------------------\n*  WARGS: RECVGSEG workarea (embedded in WARCV)\n*----------------------------------------------------------------------\nRGSWA    IM#SECT &SECT                 RECVGSEG workArea\n*\nRGSFLG1  DS    X                       status flag 1\nRGS1FINI EQU   128                     segment complete\nRGS1RES  EQU   1                       residual data valid\n*\nRGSFLG2  DS    X                       status flag 2\nRGS2EOF  EQU   1                       XMITIN EOF\n*\n         DS    0D\nRGSROFF  DS    H                       residual data offset w/i RGSBUF\nRGSBUF   DS    XL80                    residual data\n*\nRGSSL    DS    H                       # bytes in RGSSEG\nRGSSEG   DS    XL255                   segment buffer (XMITSEG)\n*\nL$RGSNAP EQU   *-RGSWA                 length of RECVGSEG exit SNAP\n         DS    CL80                    slop for RECVGSEG overexuberance\n*\nRGSOPN   OPEN  (,),MF=L\nRGSCLOS  CLOSE (,),MF=L\n*\nRGSDCB   DCB   DDNAME=XMITIN,                                          +\n               MACRF=GM,DSORG=PS,RECFM=FB,                             +\n               LRECL=80\n*\n         DS    0D\nL$RGSWA  EQU   *-RGSWA                 L'RGSWA\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WASTCP": {"ttr": 13583, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00D\\x00D\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 68, "newlines": 68, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n         WASTCP &GEN=,&DATA=NO,&PRINT=OFF\n.*\n.* Copyright 2002 James M. Morrison\n.*\n.*---------------------------------------------------------------------\n.* &GEN  - NO or null\n.* DATA  - NO or null\n.* PRINT - ON or OFF\n.*---------------------------------------------------------------------\n         PUSH  PRINT,USING\n         PRINT &PRINT,&GEN.GEN,&DATA.DATA                        WASTCP\n*----------------------------------------------------------------------\n*  STCPWA: STCP370 common workarea - based R11\n*----------------------------------------------------------------------\nSTCPWA   WATGD PRINT=&PRINT,GEN=&GEN,DATA=&DATA,SECT=DSECT\n*----------------------------------------------------------------------\nSTPRC    EQU   TGDRC,L'TGDRC           return code\nSTCP#SSF EQU   20                      max # subsys function routines\n*----------------------------------------------------------------------\n*  Fields common to both main task and subtasks\n*----------------------------------------------------------------------\nSTPCOM   DS    0D\nSTP@AGD  DS    A                       Appl Global Data        STCPTSKM\nSTP@SSCT DS    A                       @ subsys SSCVT\nSTP@SGD  DS    A                       @ subsys SGD\nSTP@SQH  DS    A                       @ subsys SQH\nSTP@SSVT DS    A                       @ subsys SSVT\nSTPSSN   DS    CL4                     subsystem name\n         DS    H\n         DS    3F\nSTPCOMX  EQU   *\n*----------------------------------------------------------------------\n*  Main task fields - subtasks access this area via STP@AGD\n*----------------------------------------------------------------------\nSTPMAIN  DS    0D\nSTPFLG1  DS    X                       status flag\nSTP1INIT EQU   128                     initialize application\nSTP1ABRT EQU   64                      abort initialization\nSTP1SHUT EQU   32                      shutdown application\nSTP1OPRX EQU   16                      operator requested shutdown\n*\nSTPCUU   DS    H                       base 3088 cuu           STCPOPR\n*\nSTPWIBLV DS    F                       WIB FREEMAIN parm       STCPTSKM\nSTP@WIB  DS    A                       @ DSWIB (WUD Info Blk)  STCPTSKM\n*\nSTP@SVC  DS    A                       @ SVC in CSA\nSTP@SVCT DS    A                       @ SVCTABLE entry we stole\nSTPSVCTB DS    XL8                     SVCTABLE entry we stole\nSTPSVCX  EQU   STP@SVCT,12             cleared when SVC entry restored\nSTPSVCXX EQU   STP@SVC,16              SVC fields for USNAP\n*\n         DS    3F                      spare\nSTPMAINX EQU   *\n*----------------------------------------------------------------------\n*  Subtask fields\n*----------------------------------------------------------------------\n         ORG   STPMAIN\nSTPSUB   DS    0D\n         DS    D\nSTPSUBX  EQU   *\n         ORG   ,\n         DS    0D\nL$STCP   EQU   *-STCPWA                length of STCPWA\n*\n         POP   PRINT,USING                                       WASTCP\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WATGD": {"ttr": 13585, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x9e\\x00\\x9e\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 158, "newlines": 158, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n&LABEL   WATGD &PFX=TGD,&PRINT=OFF,&GEN=,&DATA=,&SECT=DSECT,&TGDL=544\n.*\n.* Copyright 2002 James M. Morrison\n.*\n         GBLB  &G#TGD                  WATGD generated\n         LCLC  &P                      TGD prefix selected;\n.*\n         AIF   (NOT &G#TGD).CONT\n         MEXIT ,\n.*\n.CONT    ANOP\n&G#TGD   SETB  1                       TGD generated\n.*\n&P       SETC  '&PFX'                  TGD prefix\n         PUSH  PRINT                                              WATGD\n         PRINT &PRINT,&GEN.GEN,&DATA.DATA                         WATGD\n         DSAEX ,                       need L$SXPFX (generated once)\n***********************************************************************\n*  TGD: xxxx370 Task Global Data - based R11\n*  Provides support for U* macros & U370xxx CSECTs\n***********************************************************************\n&LABEL   IM#SECT &SECT\n&P.WA    DS    0D                      U#SET FUNC=UTIL support\nUTILWA   DS    0D                      U#SET FUNC=UTIL support\n&P.EYE   DC    CL8'xxxxDSA'            eyecatcher                 UPROC\n&P.LDSA  DS    F                       bytes gotten for DSA pool  UPROC\n&P.RC    DS    F                       xxxx370 return code\n&P.@PARM DS    A                       address of OS entry parm   UPROC\n&P.@VTAB DS    A                       VCON table              U370AP00\n&P.@TCB  DS    A                       @ owning TCB            U370AP00\n&P.LOGD  DS    CL8                     U370LOG ddname or 0\n         DS    2F                      spare\n*\n         DS    0D\n&P.UPFX  DS    XL(L$SXPFX)             xxxx370 SX                 UPROC\n&P.SA1   DS    18F                     xxxx370 SA                 UPROC\n*----------------------------------------------------------------------\n*  Global status flags\n*----------------------------------------------------------------------\n&P.FLG1  DS    X                       notable events\n&P.1ABND EQU   128                     UABEND requested\n&P.1XNFR EQU   64                      U370AP99 - don't FREEMAIN pool\n&P.1XABD EQU   32                      U370AP99 - ABEND, not return\n*\n&P.FLG2  DS    X                       U370QENV status flags\n&P.2QENV EQU   128                     U370QENV called, TGD2V* set\n&P.2VAPF EQU   32                      TGD2APF valid\n&P.2APF  EQU   16                      APF authorized\n&P.2VHEP EQU   8                       TGD2HEP valid (APF required)\n&P.2HEP  EQU   4                       Hercules emulator present\n*\n&P.FLG3  DS    X                       U370STAE (only) status\n&P.3RETY EQU   128                     U370STAE ESTAE active\n&P.3SUPT EQU   64                      SUPPORT active\n&P.3SCHD EQU   32                      ESTAE retry exit scheduled\n&P.3EXIT EQU   16                      SUBAIL should exit appl\n&P.3LOCL EQU   8                       RETRY2 active (local)\n&P.3RMT  EQU   4                       remote retry active\n&P.3DIE  EQU   2                       RE2DIE ABENDing\n*\n&P.FLG4  DS    X                       U370* behavior modification\n&P.4NSTA EQU   128                     don't establish any ESTAEs\n*\n&P.FLG5  DS    X                       USTATE state recording\n&P.5SUPR EQU   128                     supervisor state (U370AP00/99)\n*\n&P.FLG6  DS    X                       spare\n&P.FLG7  DS    X                       spare\n&P.FLG8  DS    X                       spare\n*----------------------------------------------------------------------\n*  Debug areas\n*----------------------------------------------------------------------\n         DS    0D\n&P.SNAP  USNAP MF=L,PLIST=WKSNAP       common U370SNAP parmlist\n*\n         DS    0D\n&P.REGS  DS    16F                     R0:R15 - UDIAG REGS=\n*\n         DS    0D\n&P.ABEND DS    16F                     R0:R15 - pre-ABEND (UABEND)\n*----------------------------------------------------------------------\n*  U370STAE work areas\n*----------------------------------------------------------------------\n         DS    0D\n&P.ESRGS DS    16F                     SUPPORT regs R0:R15\n&P.ES@AX DS    A                       @ ABENDing SX\n&P.ES@RX DS    A                       @ remote retry SX\n&P.ES@SP DS    A                       zero or @ SNAP parmlist\n&P.ES@SL SNAP  MF=L                    SNAP parmlist\n&P.ES@SS DS    4D                      SNAP storage LIST=\n*----------------------------------------------------------------------\n*  Miscellaneous\n*----------------------------------------------------------------------\n* U370QENV:\n&P.PGLV  DS    F                       subpool/length for FREEMAIN\n&P.@PAGE DS    A                       0 or addr of page-aligned 4K\n*                                      not currently freed by UPROC;\n*                                      allocated by U370QENV\n&P.PGPRM EQU   &P.PGLV,8               LM target for FREEMAIN\nTGDSAVER DS    CL4                     U370AP00 SA verification field\n*----------------------------------------------------------------------\n*  Reserved for zap usage\n*----------------------------------------------------------------------\n         DS    0D\n&P.ZAP   DS    XL32                    zap workarea\n*----------------------------------------------------------------------\n*  Debug bytes\n*----------------------------------------------------------------------\n.*\n.*  Debug level bytes, set by U370DBUG, tested by UDIAG & UPSR\n.*  One byte per CSECT that issues UDIAG or UPSR\n.*  Values range from C'0' (no messages) or C'9' (most verbose)\n.*  UDIAG & UPSR manufacture the debug byte name from CSECT name\n.*\n.*  ASMF seems to be too silly to let us generate an opcode containing\n.*  '#' (American pound sign) ... hardcoding the macro name works fine\n*\n&P.DEBUG DS    0F\n         U370#BUG ,\n&P.APPLD DS    0C\n         XMIT#BUG ,\n         ORG   &P.APPLD\n         RECV#BUG ,\n         ORG   &P.APPLD\n         DAST#BUG ,\n         ORG   &P.APPLD\n         STCP#BUG ,\n         ORG   ,\n&P.DEND  DS    0C                      end of debug bytes\n&P.#VTE  EQU   *-&P.DEBUG              # CSECTs - for U370AP00\n         DS    0D                      in case TGD larger than &TGDL\n*----------------------------------------------------------------------\n*  End of TGDWA\n*----------------------------------------------------------------------\n         ORG   &P.WA\n         DS    XL&TGDL                 desired TGD size (unless larger)\n         ORG   ,\n&P.X     DS    0D                      end of TGDWA\nL$&P     EQU   *-&P.WA\n*\n         POP   PRINT                                              WATGD\n.DONE    MEXIT ,\n.*---------------------------------------------------------------------\n.*  WATGD - TGD Data Area - Task Global Data\n.*\n.*  The TGD is intended to provide common work areas for the U370*\n.*  CSECTs, and other handy things.  It should remain relatively small\n.*  so it doesn't impinge on the application specific TGD additions\n.*  (WAXMIT, etc).  Since we can only cover 4KB with a single base\n.*  register, the total size of the TGD and the application specific\n.*  additions must remain under 4KB to be addressable.\n.*\n.*  Beginning in v0005, U370* CSECTs should place whatever data\n.*  they can into their CSECT-specific persistent data area,\n.*  rather than clutter up the TGD.\n.*---------------------------------------------------------------------\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WAXMIT": {"ttr": 13828, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00M\\x00M\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 77, "newlines": 77, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n         WAXMIT &FUNC=XMIT,&GEN=NO,&DATA=NO,&PRINT=OFF,&PFX=XMT\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n.*---------------------------------------------------------------------\n.* &FUNC - XMIT, RECV, or UTIL\n.* &GEN  - NO or null\n.* DATA  - NO or null\n.* PRINT - ON or OFF\n.*---------------------------------------------------------------------\n         PUSH  PRINT,USING\n         PRINT &PRINT,&GEN.GEN,&DATA.DATA\n         EJECT ,\n*----------------------------------------------------------------------\n*  XMITWA: XMIT370 common workarea - based R11\n*----------------------------------------------------------------------\nXMITWA   DSECT ,\n*\n*  Embed TGD (Task Global Data) in beginning of WAXMT\n*\n         WATGD PRINT=&PRINT,GEN=&GEN,DATA=&DATA,SECT=LABEL\n***********************************************************************\n*  Application-specific data areas\n***********************************************************************\nXMTRC    EQU   TGDRC,4\nXMTREGS  EQU   TGDREGS,16*4\nXMTABEND EQU   TGDABEND,16*4\nXMTL$DCB EQU   96\n*----------------------------------------------------------------------\n*  Status flags\n*----------------------------------------------------------------------\nXMTFLG1  DS    X                       XMIT370 status flags\nXMTF1$U  EQU   128                     XMTDCBI is unloaded DS\n*----------------------------------------------------------------------\n*  Data management areas\n*----------------------------------------------------------------------\nXMT#FILE DS    F                       current file number\nXMTESZ   DS    F                       estimate file size, bytes\nXMT@PS   DS    A                       @ XPSWA XMITPUT workarea\n*\nXMTOPN   OPEN  (,),MF=L\nXMTCLOS  CLOSE (,),MF=L\n*\nXMT@JFCB DS    A                       @ JFCB for open XMTDCBI\nXMTJFCBL DS    F                       JFCB exlst for XMTDCBI\n*\n         DS    0D\nXMTJFCB1 DS    XL176                   SYSUT1 JFCB area\nXMTDSN1  DS    CL44                    SYSUT1 DSCB dsname\nXMTDSCB1 DS    XL140                   SYSUT1 OBTAIN area (DS1FMTID)\n*\n         DS    0D                      SYSUT2 dsn & DSCB\nXMTJFCB2 DS    XL176                   SYSUT2 JFCB area\nXMTDSN2  DS    CL44\nXMTDSCB2 DS    XL140\n*\n         DS    0D\n         DS    4D                      spare\n*\n         DS    0D\nXMTDCBI  DS    XL(XMTL$DCB)            input DCB (SYSUT1/SYSUT2)\n*----------------------------------------------------------------------\n*  XMITPUT's workarea\n*----------------------------------------------------------------------\n         DS    0D\nXMTXPSWE DC    CL8'PUTWORK '\nXMTXPSWA DS    XL1024                  1K reserved for XMITPUT workarea\n*----------------------------------------------------------------------\n*  End of XMITWA\n*----------------------------------------------------------------------\nL$XMTWA  EQU   *-XMITWA\n         EJECT ,\n         WAXPS ,\nXXPUT    EQU   1024-L$XPSWA            Asm error if workarea exceeds 1K\n         POP   PRINT,USING\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WAXPS": {"ttr": 13831, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n         WAXPS &SECT=DSECT\n.*\n.* Copyright 2001, 2002 James M. Morrison\n.*\n*----------------------------------------------------------------------\n*  WAXPS: XMIT370 PUTSEG support workarea (embedded in WAXMT)\n*  Our eyecatcher is in XMTWA, and is 'PUTWORK '\n*----------------------------------------------------------------------\nXPSWA    IM#SECT &SECT                 Xmit370 PutSeg WorkArea\nXPSSA    DS    18F                     savearea for QSAM\nXPSFLG1  DS    X                       status flag\nXPS1OPN  EQU   128                     DCB opened (once is enough)\n*\n         DS    0D\nXPSRL    DS    F                       residual length in XPSSEG\nXPSSEG   DS    XL(12+80)               segment workarea + slop\n*\n         DS    0D\nXPSOPN   OPEN  (,),MF=L\nXPSCLOS  CLOSE (,),MF=L\nXPSEXL   DS    4F                      DCB exit list\n*\nXPSDCB   DCB   DDNAME=SYSUT1,                                          +\n               MACRF=PM,DSORG=PS,RECFM=FB,                             +\n               LRECL=80,BLKSIZE=3200   might need EXLST to fix blksize\n         DS    0D\nL$XPSWA  EQU   *-XPSWA                 L'XPSWA\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XFASM": {"ttr": 13833, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x13\\x13\\x060\\x060\\x00\\x00\\xc9\\xc6\\xd6\\xe7\\xf0\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T13:13:00", "lines": 1584, "newlines": 1584, "modlines": 0, "user": "IFOX00"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMIT#BUG": {"ttr": 14347, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x15\\x00\\x15\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 21, "newlines": 21, "modlines": 0, "user": "XV0006"}, "text": "         MACRO\n         XMIT#BUG &PFX=TGDD\n.*\n.* Copyright 2002 James M. Morrison\n.*\n         LCLC  &P\n&P       SETC  '&PFX'\n&P.BUF   DS    C        XMITBUF\n&P.CPR1  DS    C        XMITCPR1\n&P.DIR   DS    C        XMITDIR\n&P.ESZ   DS    C        XMITESZ\n&P.KDSN  DS    C        XMITKDSN\n&P.KEY   DS    C        XMITKEY\n&P.PUT   DS    C        XMITPUT\n&P.UNLD  DS    C        XMITUNLD\n&P.01    DS    C        XMIT01\n&P.02A   DS    C        XMIT02A\n&P.02B   DS    C        XMIT02B\n&P.03    DS    C        XMIT03\n&P.06    DS    C        XMIT06\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XMITBUF": {"ttr": 14594, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00n\\x00n\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 110, "newlines": 110, "modlines": 0, "user": "XV0006"}, "text": "XMITBUF  TITLE 'SPLIT buffer into segment(s), write'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  Things to do:\n*----------------------------------------------------------------------\n         U#SET FUNC=XMIT\n*----------------------------------------------------------------------\n* Function: Given a BSAM buffer, split the buffer into segment(s),\n*           and write the segments by calling XMITPUT (PUTSEG).\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         R0  = length of buffer\n*         R1  = address of buffer\n*\n* Exit:   R15 = return code\n*         R15 = 00 success\n*\n* Abends:\n*\n* Notes:\n*----------------------------------------------------------------------\n* R2     XBUWA\n* R3     2 (constant)\n* R4     @ segment data\n* R5     length remaining in segment data\n* R6     length of input buffer = blksize\n* R7     address of input buffer\n* R8     length of segment to be written\n* R9     253 (constant)\n* R10\n* R11    XMTWA\n* R12    base reg\n* R13    savearea\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\nXMITBUF  UPROC L=L$XBUWA,ID=XBUF,WA=XBUWA,INIT=MVCL\n         LR    R6,R0\n         LR    R7,R1\n         UDIAG 1,'XMITBUF entered'\n         UDIAG 3,'XMITBUF input block',(R7),(R6)\n*----------------------------------------------------------------------\n* Create segment\n*----------------------------------------------------------------------\n         LA    R3,L'XBUSEGL+L'XBUSEGF  l' overhead\n         LA    R9,L'XBUSEGD            max # seg data bytes permitted\n         MVI   XBUSEGF,SEG$1           turn on 'first' flag\nSPLIT    DS    0H\n         LTR   R6,R6                   anything left in buffer?\n         BNP   EXITRC0\n         LR    R8,R9                   assume max # bytes in segment\n         CR    R6,R9\n         BH    NOTLAST\n         OI    XBUSEGF,SEG$L           last segment\n         LR    R8,R6\nNOTLAST  DS    0H\n         AR    R8,R3                   segment length (except flag)\n         STC   R8,XBUSEGL\n         SR    R8,R3\n         BCTR  R8,0\n         EX    R8,COPY                 copy buffer data to segment\n         LA    R8,1(,R8)\n         LA    R7,0(R8,R7)             bump to next avail char\n         SR    R6,R8\n*----------------------------------------------------------------------\n* Write INMR03 segment\n*----------------------------------------------------------------------\nWRITE    DS    0H\n         LA    R1,XBUSEG\n         UCALL XMITPUT                 write INMR03 segment\n         NI    XBUSEGF,255-SEG$1       not first segment anymore\n         LTR   R15,R15\n         BZ    SPLIT\n         BNZ   EXIT\n*\nEXITRC0  DS    0H\n         SLR   R15,R15\n*\nEXIT     DS    0H\n         ST    R15,XBURC\n         UDIAG 1,'XMITBUF exited'\n         L     R15,XBURC\n         UPEND ,\n*\nCOPY     MVC   XBUSEGD(*-*),0(R7)      copy data\n*\n         LTORG ,\n         EJECT ,\n*----------------------------------------------------------------------\nXBUWA    DSECT ,\nXBUSA    DS    18F\n*\nXBURC    DS    F             return code\nXBUSEG   DS    0D            segment\nXBUSEGL  DS    X             segment length\nXBUSEGF  DS    X             segment flag\nXBUSEGD  DS    XL253         segment data\n         DS    0D\nL$XBUWA  EQU   *-XBUWA\n         EJECT ,\n         PRINT NOGEN\n         DXSEG ,\n         EJECT ,\n         WAXMIT ,\n         PRINT GEN\nXMITBUF  UFINI DXDXBUF,L$XBUWA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XMITCPR1": {"ttr": 14597, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x01\\x89\\x01\\x89\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 393, "newlines": 393, "modlines": 0, "user": "XV0006"}, "text": "XMITCPR1 TITLE 'Fix IEBCOPY COPYR1 record'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n         PRINT  NOGEN\n*\n         DCBD   DSORG=PS,DEVD=DA\n*\nJFCB     DSECT ,\n         IEFJFCBN ,\nL$JFCB   EQU   *-JFCB\n*\nDSCB1    DSECT ,\n         IECSDSL1 (1)                  FORMAT-1 DSCB\n*\n*  The following 'DX' definition(s) are to allow us to assemble on\n*  either MVS38j or something more modern.  They echo the 'DS'\n*  definitions in later MVS versions.\n*\nDX1SMSFG EQU   DS1DSNAM+X'4E',1          SMS indicators\nDX1SCEXT EQU   DS1DSNAM+X'4F',3          secondary space extension\nL$DSCB1  EQU   *-DSCB1\n*\n         PRINT GEN\n         EJECT ,\n         DXCOPYR1 BDW=YES,RDW=YES\nXMITCPR1 CSECT ,\n*----------------------------------------------------------------------\n         U#SET FUNC=XMIT\n*----------------------------------------------------------------------\n* Function:    Given an MVS38j IEBCOPY unload COPYR1 record,\n*              transform it to mimic higher levels of IEBCOPY.\n*\n*              Fields in the post-MVS38j section are filled in,\n*              where possible, only if they are x'00's.\n*\n*              Modification of the COPYR1 record is controlled by\n*              presence/absence of COPYR1 ddname.\n*\n* Caller: XMITUNLD (after INMR03 written)\n*\n* Entry:  R0 =\n*         R1 = address of IEBCOPY COPYR1 record's BDW\n*\n*         XMTJFCB1 contains the SYSUT1 JFCB\n*         XMTJFCB2 contains the SYSUT2 JFCB\n*\n* Exit:   R15 =  0     everything is OK\n*                else  error\n*\n* Notes:\n*\n* COPYR1 notes:\n*         The IEBCOPY program has changed the length and contents of\n*         the COPYR1 record based on the maintenance level of IEBCOPY.\n*\n*         When the user wishes to create a COPYR1 record which doesn't\n*         match the current level of IEBCOPY running on this system,\n*         coding the COPYR1 DDNAME will cause this code to modify\n*         the COPYR1 record before it's written to the XMIT.\n*\n*         Following are the values to code on the COPYR1 DDNAME\n*         for various levels of IEBCOPY maintenance:\n*\n*         MVS38j      (RDW)  LRECL=56     payload: 52 bytes (x'34')\n*         MVS/ESA     (RDW)  LRECL=60     payload: 56 bytes (x'38')\n*\n*         which is to say the LRECL= value specifies the length to\n*         drop into the RDW, which is 4 greater than the payload's\n*         (data following the RDW) length.\n*\n*         The DCB attributes are what are appropriate to RECEIVE the\n*         XMIT file on the specified levels of MVS.  The COPYR1\n*         allocation doesn't have to specify an actual dataset, it\n*         can be DUMMY, as below:\n*\n*         //COPYR1  DD DUMMY,DCB=LRECL=xx\n*\n*         If no LRECL value is specified, XMITCPR1 will default\n*         to the longest COPYR1 of which it is aware, which should\n*         usually work pretty well.  In such a case, simply code\n*\n*         //COPYR1  DD DUMMY\n*\n*         Allowing the LRECL length to be coded might allow for\n*         some future distinctions between further variations,\n*         or possibly have use to someone modifying this code.\n*         Plus it let me play with the length while I slog through\n*         creating XMIT370's XMITs that TSO/E RECEIVE understands.\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\n* Register usage (except MODTAB code)\n*----------------------------------------------------------------------\n* R2     TIOT entry\n* R3     DCB\n* R4     JFCB\n* R5\n* R6     scratch\n* R7     old COPYR1 record length\n* R8     new COPYR1 record length\n* R9     address of COPYR1 record (@ BDW)\n* R10\n*----------------------------------------------------------------------\nXMITCPR1 UPROC ID=XCP1,L=L$SA,INIT=MVCL\n         LR    R9,R1                        save caller's R1\n         USING COPYR1,R9\n         LH    R7,XC1BDW                    old COPYR1 BDW\n         UDIAG 1,'CPR1 entry'\n         UDIAG 3,'CPR1 entry COPYR1',(R9),(R7)\n         UDIAG 4,'CPR1 entry XMTJFCB1',XMTJFCB1,L$JFCB\n         UDIAG 4,'CPR1 entry XMTJFCB2',XMTJFCB2,L$JFCB\n*----------------------------------------------------------------------\n*  See if COPYR1 ddname allocated\n*----------------------------------------------------------------------\n         LA    R1,=CL8'COPYR1'         target DDNAME\n         UCALL U370TIOT                scan TIOT for DDNAME\n         LTR   R1,R1                   found?\n         BNZ   FOUND                   yes\n*\nNOTFOUND DS    0H\n         ULOG  'No COPYR1 ddname found, COPYR1 record unmodified'\n         B     EXIT\n         EJECT ,\n*----------------------------------------------------------------------\n*  COPYR1 ddname allocated, RDJFCB to retrieve LRECL=\n*----------------------------------------------------------------------\nFOUND    DS    0H\n         LA    R3,SAVDCB\n         USING IHADCB,R3\n         MVC   SAVOPN(L$OPN),MODLOPN        copy model OPEN macro\n         STCM  R3,7,SAVOPN+1                relocate DCB ptr\n*\n         MVC   SAVDCB(L$DCB),MYDCB          copy DCB\n         LA    R0,SAVEXLST                  relocate DCB's EXLST\n         STCM  R0,7,DCBEXLSA\n*\n         MVC   SAVEXLST(L$JFCBL),JFCBLST\n         LA    R4,SAVJFCB                   relocate EXLST's JFCB addr\n         USING JFCB,R4\n         STCM  R4,7,SAVEXLST+1\n*\n         RDJFCB SAVDCB,MF=(E,SAVOPN)\n         LTR   R15,R15\n         BZ    SNAPJFCB\n         UDIAG 0,'XMITCPR1 COPYR1 RDJFCB failed'\n         UABEND ,\nSNAPJFCB DS    0H\n         UDIAG 3,'CPR1 COPYR1 JFCB',SAVJFCB,L$JFCB\n         EJECT ,\n*----------------------------------------------------------------------\n*  Modify the COPYR1 record length as per COPYR1 ddname specification\n*----------------------------------------------------------------------\nL$DEFR1  EQU   L$XC1CUR-L'XC1BDW            default new RDW length\n*\n         LA    R6,4                         L'BDW & L'RDW\n         LH    R7,XC1RDW                    old COPYR1 LRECL (RDW)\n         SR    R7,R6\n         UPSR  3,'CPR1 old COPYR1 payload length (hex)',(R7)\n*\n         SLR   R8,R8\n         ICM   R8,3,JFCLRECL                user spec'd new RDW length\n         BNZ   *+8\n         LH    R8,=AL2(L$DEFR1)             default new RDW length\n*\n         SR    R8,R6\n         UPSR  3,'CPR1 new COPYR1 payload length (hex)',(R8)\n         AR    R8,R6\n         STH   R8,XC1RDW                    update COPYR1 RDW\n         AR    R8,R6\n         STH   R8,XC1BDW                    update COPYR1 BDW\n         EJECT ,\n         PUSH  USING\n*----------------------------------------------------------------------\n*  Modify the COPYR1 record as per MODTAB specification\n*----------------------------------------------------------------------\n* R0  = source value\n* R2  @ modification destination field\n* R3  @ modification source field\n* R4  = modification length\n* R5  = MODTAB BXLE index\n* R6  = MODTAB BXLE increment\n* R7  = MODTAB BXLE limit\n* R8\n* R9  @ COPYR1 BDW\n* R14 = modification destination offset\n* R15 = modification source offset\n*\n         UDIAG 5,'CPR1 SYSUT1 DSCB',XMTDSN1,L$DSCB1\n         UDIAG 5,'CPR1 SYSUT2 DSCB',XMTDSN2,L$DSCB1\n         UDIAG 5,'CPR1 MODTAB',MODTAB,MODEND\n         LM    R5,R7,=A(MODTAB,L$MODENT,MODEND-1)\n         USING XMODTAB,R5\n         B     MODREC\n*\nMODSKIP  DS    0H                              modification skipped\n         OI    SAFLAG1,SA1MDSKP\n         UDIAG 4,'CPR1 modskip - previous dest unchanged'\n*\nMODREC   DS    0H\n         LH    R14,0(,R9)\n         UDIAG 9,'CPR1: COPYR1 modrec',(R9),(R14)\n         SLR   R14,R14\n         ICM   R14,3,XMDSTOFF\n         LA    R2,COPYR1(R14)                  destination field addr\n         SLR   R15,R15\n         ICM   R15,3,XMSRCOFF\n         LA    R3,XMTDSN1(R15)                 source field addr\n         STM   R14,R15,SATEMP\n         UPSR  4,'CPR1 dest offset',(R14)\n         L     R15,SATEMP+4\n         UPSR  4,'CPR1 source offset',(R15)\n         LM    R14,R15,SATEMP\n*\n         SLR   R4,R4\n         ICM   R4,3,XMDSTLEN                   field length\n         UPSR  4,'CPR1 dest length',(R4)\n         BCTR  R4,0\n         SLL   R4,2                            index retrieval list\n         SLR   R0,R0\n         EX    R0,RETDEST(R4)                  IEBCOPY-provided value\n         ST    R0,SATEMP\n         UPSR  4,'CPR1 DSCB value',(R0)\n         L     R0,SATEMP\n         LTR   R0,R0                           IEBCOPY value null?\n         BZ    *+8                             yes, place new value\n         BXLE  R5,R6,MODSKIP                   no, IEBCOPY knows best\n*\n*  IEBCOPY didn't provide a value for the field of interest\n*\n         CLC   =X'0000',XMSRCLEN               hardcoded source value?\n         BE    MODHARD\n*\n*  Retrieve value from DSCB, store in COPYR1 destination field\n*\nMODNORML DS    0H                              normal value\n         EX    R0,RETSRC(R4)                   retrieve DSCB value\n         ST    R0,SATEMP\n         UPSR  5,'CPR1 modnorml DSCB value',(R0)\n         L     R0,SATEMP\n         EX    R0,MODDEST(R4)                  update destination\n         BXLE  R5,R6,MODREC\n         B     MODFIN\n*\n*  Retrieve value from MODTAB, store in COPYR1 destination field\n*\nMODHARD  DS    0H                              hard-coded value\n         SLR   R0,R0\n         ICM   R0,3,XMSRCOFF                   source data\n         ST    R0,SATEMP\n         UPSR  5,'CPR1 modhard value',(R0)\n         L     R0,SATEMP\n         EX    R0,MODDEST(R4)                  update destination\n         BXLE  R5,R6,MODREC\n         B     MODFIN\n*\nRETDEST  ICM   R0,1,0(R2)                      retrieve COPYR1 data\n         ICM   R0,3,0(R2)\n         ICM   R0,7,0(R2)\n         ICM   R0,15,0(R2)\n*\nRETSRC   ICM   R0,1,0(R3)                      retrieve DSCB data\n         ICM   R0,3,0(R3)\n         ICM   R0,7,0(R3)\n         ICM   R0,15,0(R3)\n*\nMODDEST  STCM  R0,1,0(R2)                      store COPYR1 data\n         STCM  R0,3,0(R2)\n         STCM  R0,7,0(R2)\n         STCM  R0,15,0(R2)\n         POP   USING\n*\nXMODTAB  DSECT ,\nXMDSTOFF DS    XL2                     destination field offset\nXMDSTLEN DS    XL2                     destination field length\nXMSRCOFF DS    XL2                     source field offset\nXMSRCLEN DS    XL2                     source field length\nXMITCPR1 CSECT ,\n         EJECT ,\n*----------------------------------------------------------------------\n*  COPYR1 update complete\n*----------------------------------------------------------------------\nMODFIN   DS    0H\n         TM    SAFLAG1,SA1MDSKP        modification(s) skipped?\n         BNO   MODFIN3\n         UDIAG 1,'CPR1 ignored some MODTAB updates'\nMODFIN3  DS    0H\n         LH    R14,0(,R9)              COPYR1 BDW\n         UDIAG 3,'CPR1: COPYR1 @ exit',(R9),(R14)\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\nEXIT     UDIAG 1,'CPR1 exited'\n         UPEND ,                       return to caller\n         EJECT ,\n*----------------------------------------------------------------------\n*  COPYR1 mods table\n*----------------------------------------------------------------------\n*\n*  Format of table entry:\n*\n*     Destination offset, destination length\n*     Source offset, source length,\n*\n*  when source length = 0, source offset is the value to be applied;\n*  else source length = destination length.\n*\n*  Entries are in ascending destination offset order.\n*\n         PUSH  PRINT,USING\n         PRINT DATA\n         USING IECSDSL1,R15                        bogus base\n*\nMODTAB   DS    0D\n         DC    AL2(XC1SMSFG-COPYR1,L'XC1SMSFG)\n         DC    AL2(DX1SMSFG-DSCB1,L'DX1SMSFG)      SMS indicators\nL$MODENT EQU   *-MODTAB\n*\n         DC    AL2(XC1HDRCT-COPYR1,L'XC1HDRCT)     hdrcount = x'0002'\n         DC    AL2(2,0)\n*\n         DC    AL2(XC1RESV1-COPYR1,L'XC1RESV1)     resv1 = x'00'\n         DC    AL2(0,0)\n*\n         DC    AL2(XC1LREFD-COPYR1,L'XC1LREFD)\n         DC    AL2(DS1REFD-DSCB1,L'DS1REFD)        last ref date\n*\n         DC    AL2(XC1SCEXT-COPYR1,L'XC1SCEXT)\n         DC    AL2(DX1SCEXT-DSCB1,L'DX1SCEXT)      secondary extent\n*\n         DC    AL2(XC1SCALO-COPYR1,L'XC1SCALO)\n         DC    AL2(DS1SCALO-DSCB1,L'DS1SCALO)      secondary allocation\n*\n         DC    AL2(XC1LSTAR-COPYR1,L'XC1LSTAR)\n         DC    AL2(DS1LSTAR-DSCB1,L'DS1LSTAR)      last used TTR\n*\n         DC    AL2(XC1TRBAL-COPYR1,L'XC1TRBAL)\n         DC    AL2(DS1TRBAL-DSCB1,L'DS1TRBAL)      track balance\n*\n         DC    AL2(XC1RESV2-COPYR1,L'XC1RESV2)     resv2 = x'0000'\n         DC    AL2(0,0)\nMODEND   EQU   *\n         POP   PRINT,USING\n         EJECT ,\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\nMODLOPN  OPEN  (,INPUT),MF=L           model OPEN\nL$OPN    EQU   *-MODLOPN               l' model open\n*\n         PUSH  PRINT\n         PRINT NOGEN\nMYDCB    DCB   DDNAME=COPYR1,EXLST=0,DSORG=PS,MACRF=E\nL$DCB    EQU   *-MYDCB\n         POP   PRINT\n*\nJFCBLST  DS    0F\n         DC    XL1'87'\n         DC    AL3(0)\nL$JFCBL  EQU   *-JFCBLST\n*\nCAMLST   CAMLST SEARCH,1,2,3           OBTAIN parmlist\n         LTORG ,\n*----------------------------------------------------------------------\n*  Dynamic savearea & workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSAVREGS  DS    18F\n*\nSAFLAG1  DS    X\nSA1MDSKP EQU   128                     some MODTAB mod(s) skipped\n*\nSATEMP   DS    4F                      short-term save\n         DS    0F\nSAVOPN   OPEN  (,INPUT),MF=L           open parmlist\n         PUSH  PRINT\n         PRINT NOGEN\nSAVDCB   DCB   DDNAME=COPYR1,DSORG=PS,MACRF=E\n         POP   PRINT\nSAVEXLST DS    F                       DCB EXLST=\n         DS    0D                      align\nSAVJFCB  DS    CL(L$JFCB)              JFCB\nSAVCAML  CAMLST SEARCH,1,2,3           CAMLST\nL$CAMLST EQU   *-SAVCAML\n         DS    0D\nSAVDSCB  DS    CL140                   Format1 DSCB (minus dsn), cchhr\n         DS    CL5\n         DS    0D\nL$SA     EQU   *-SAVEAREA              length of savearea\n*\n         WAXMIT ,\nXMITCPR1 UFINI DXDXCPR1,L$SA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XMITDIR": {"ttr": 14604, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x96\\x00\\x96\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 150, "newlines": 150, "modlines": 0, "user": "XV0006"}, "text": "XMITDIR  TITLE 'Determine Directory blocks allocated'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  To do: NO\n*----------------------------------------------------------------------\n         U#SET FUNC=XMIT\n*----------------------------------------------------------------------\n* Function: Determine number of directory blocks allocated\n*\n* Caller: XMIT02A\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         R0  =\n*         R1  =  open SYSUT1 DCB, DSORG=PO\n*\n* Exit:   R15 = return code\n*         R15 = 00 success; R0 = # directory blocks\n*\n* Abends: input PDS broken in some way\n*\n* Notes:  It's OK for us to read the directory of the PDS, since no\n*         one else (like XMIT02B) will read a DSORG=PO dataset.\n*         Well, except IEBCOPY when we tell him to.\n*----------------------------------------------------------------------\n* R2     DCB\n* R3\n* R4     IOB\n* R5     # dir blocks\n* R6     DECB\n* R7     DCBBLKSI\n* R8     length of directory block\n* R9     @ directory block\n* R10\n* R11    XMTWA\n* R12    base reg\n* R13    savearea\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\nXMITDIR  UPROC L=L$XDRWA,ID=XMDR,WA=XDRWA\n         LR    R2,R1                   SYSUT1 open DCB\n         USING IHADCB,R2\n         UDIAG 1,'XMITDIR entered'\n*----------------------------------------------------------------------\n*  Initialize\n*----------------------------------------------------------------------\n         TM    DCBRECFM,DCBRECF        PDS directory must be recfm=f\n         BNO   BROKEN\n         TM    DCBRECFM,DCBRECU             recfm=u not acceptable\n         BO    BROKEN\n         LA    R0,EOFRTN\n         STCM  R0,7,DCBEODA                 set EOF exit rtn addr\n         MVC   XDRDECBI(L$DECB),MODLDECB    copy model DECB\n         LH    R7,DCBBLKSI                  get blksize\n         ST    R7,XDRBUFL\n         GETMAIN R,LV=(R7)                  alloc input buffer\n         LR    R9,R1\n*\n*  Read pds directory, counting directory blocks\n*  This is offensively simple-minded, but there doesn't appear to be\n*  an MVS control block which records the number of directory blocks\n*  allocated to a PDS; even the DSCB doesn't have the info.\n*  We return the # dir blocks allocated, not used, so hopefully\n*  the RECEIVE program at the other end will allocate sufficient\n*  directory blocks, rather than the usual number used, which causes\n*  me huge amounts of grief, and probably you, too.\n*\n         SLR   R5,R5                        # dir blocks = 0\n*----------------------------------------------------------------------\n*  Read a directory block\n*----------------------------------------------------------------------\n         LA    R6,XDRDECBI                  @ DECB\n         USING DECB,R6\nREAD     DS    0H\n         READ  (R6),SF,(R2),(R9),'S',MF=E\n         UDIAG 2,'XMITDIR: read issued'\n         CHECK XDRDECBI\n         UDIAG 3,'XMITDIR: dcb after CHECK',(R2),L$DCB\n         UDIAG 3,'XMITDIR: decb after CHECK',(R6),L$DECB\n*----------------------------------------------------------------------\n*  Determine length of data retrieved, bail if not 256\n*----------------------------------------------------------------------\n         LH    R8,DCBBLKSI             l' READ 'S' request\n         L     R4,DECIOBPT             @ IOB\n         USING IOBSTDRD,R4\n         UDIAG 3,'XMITDIR: IOB',(R4),20\n         LH    R0,IOBSTBYT+2           residual count\n         SR    R8,R0                   = l' read\n*\n         UDIAG 3,'XMITDIR directory block',(R9),(R8)\n         C     R8,=F'256'              verify block length valid\n         BNE   BROKEN\n*----------------------------------------------------------------------\n*  Count block just read\n*----------------------------------------------------------------------\n         LA    R5,1(,R5)               accumulate # dir blocks\n         B     READ\n*\nEOFRTN   DS    0H                      END OF FILE branches here\n         SLR   R15,R15\n*\nEXIT     DS    0H\n         ST    R15,XDRRC\n         L     R0,XDRBUFL\n         LTR   R0,R0\n         BZ    NOFREE\n         LR    R1,R9\n         FREEMAIN R,LV=(0),A=(1)\nNOFREE   DS    0H\n         ST    R15,XDRRC\n         UDIAG 1,'XMITDIR exited'\n         L     R15,XDRRC\n         LR    R0,R5                        return dir blocks\n         UPEND R0=RETURN\n*\nBROKEN   DS    0H\n         ULOG  'XMITDIR: input dataset broken'\n         ULOG  'Either RECFM not F or dir block length not 256'\n         UABEND ,                           recfm=v or bad l' dirblk\n*\nMODLDECB READ MODLECB,SF,0,0,'S',MF=L\nL$DECB   EQU  *-MODLDECB\n*\n         LTORG ,\n*----------------------------------------------------------------------\n         EJECT ,\nXDRWA    DSECT ,\nXDRSA    DS    18F\nXDRBUFL  DS    F             l' gotten buffer\nXDRDECBI READ  XDRECBI,SF,0,0,'S',MF=L\n*\nXDRRC    DS    F             return code\n         DS    0D\nL$XDRWA  EQU   *-XDRWA\n*\n         EJECT ,\n         WAXMIT ,\n*        EJECT ,\n         IHADECB ,\n*        EJECT ,\n         IEZIOB ,\n*        EJECT ,\n         DCBD  DSORG=PS,DEVD=DA\nL$DCB    EQU   *-IHADCB\n         PRINT GEN\nXMITDIR  UFINI DXDXDIR,L$XDRWA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XMITESZ": {"ttr": 14852, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x95\\x00\\x95\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 149, "newlines": 149, "modlines": 0, "user": "XV0006"}, "text": "XMITESZ  TITLE 'Estimate dataset SiZe'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  To do: YES\n*  1) Rather than running through the DEB for _allocated_ tracks,\n*     use the DS1LSTAR field of the Format1 DSCB\n*----------------------------------------------------------------------\n         U#SET FUNC=XMIT\n*----------------------------------------------------------------------\n* Function: Estimate the number of bytes allocated to a dataset\n*\n* Caller: XMIT02A\n*\n* Entry:  AMODE=24, KEY=8, STATE=supervisor\n*\n*         R0  =  Format 1 DSCB\n*         R1  =  open DCB\n*\n* Exit:   R15 = return code\n*         R15 = 00 success; R0 = # bytes allocated (approximately)\n*\n* Abends: yes\n*\n* Notes:\n*----------------------------------------------------------------------\n* R2     scratch\n* R3     DVCT\n* R4     UCB associated with extent\n* R5     # extents\n* R6     DCB\n* R7     DEB, DEBDASD\n* R8     estimated file size in bytes\n* R9     Format1 DSCB\n* R10\n* R11    XMTWA\n* R12    base reg\n* R13    savearea\n*----------------------------------------------------------------------\nERR#1    EQU   1        dataset not on dasd device\n         TITLE ' '\n*----------------------------------------------------------------------\nXMITESZ  UPROC L=L$SA,ID=XESZ\n         LR    R9,R0                   Format1 DSCB\n         LR    R6,R1                   SYSUT1/SYSUT2 open DCB\n         USING IHADCB,R6\n         UPSR  1,'ESZ enter',(R6)\n*\n*  Calculate estimated file size\n*\n         SLR   R8,R8                   # bytes allocated (estimate)\n         SLR   R7,R7\n         ICM   R7,7,DCBDEBA            @ DEB for DCB\n         USING DEBBASIC,R7\n*\n         LR    R1,R7\n         S     R1,=A(DEBPREFX-DEBBASIC)     back up to prefix\n         SLR   R2,R2\n         IC    R2,DEBLNGTH-DEBPREFX(,R1)    L' DEB in doublewords\n         SLL   R2,3                         L' DEB in bytes\n         SPKA  0                            DEB in key 5\n         UDIAG 3,'ESZ DEB',(R7),(R2)\n*\n         SLR   R5,R5\n         IC    R5,DEBNMEXT                  # extents\n         LTR   R15,R5\n         BZ    EXTDONE                      no extents\n         UPSR  4,'ESZ extents',(R5)\n         LA    R7,DEBBASND                  @ deb dasd section\n         USING DEBDASD,R7\n         UPSR  4,'ESZ DEB dasd section',(R7)\n*\n* since we don't support ISAM, we don't have to worry about the\n* ISAM device dependent section possibly appearing between the\n* deb basic section and the deb dasd section.\n*\nCALCSPAC DS    0H\n         SLR   R4,R4\n         ICM   R4,7,DEBUCBA                 @ UCB for extent\n         USING UCB,R4\n         TM    UCBTBYT3,UCB3DACC            dasd device?\n         BO    DASD\n         MVI   SAREASON,ERR#1               not dasd device\nDIE      UABEND ,                           input device not dasd\nDASD     DS    0H\n         L     R1,CVTPTR                    @ cvt\n         L     R1,CVTZDTAB-CVT(,R1)         @ ieczdtab\n         USING DVCTI,R1\n         LA    R2,DVCTYPMK                  4 low order bits mask\n         N     R2,UCBTYP                    index into IECZDTAB\n         IC    R2,DVCTIOFF(R2)              offset to DVCT entry\n         LA    R3,DVCTI(R2)                 @ DVCT entry\n         USING DVCT,R3\n         UDIAG 4,'XMITESZ DVCT entry',(R3),DVCENTLG\n         DROP  R1\n*\n         UDIAG 3,'XMITESZ DEBDASD',(R7),L$DEBDA\n*\n         SLR   R2,R2\n         ICM   R2,3,DEBNMTRK                tracks allocated in extent\n         UPSR  2,'ESZ tracks',(R2)\n         SLR   R0,R0\n         LR    R1,R2\n         SLR   R14,R14\n         ICM   R14,3,DVCTRKLN               # bytes/track\n         MR    R0,R14                       = bytes in extent\n         AR    R8,R1                        accumulate bytes allocated\n         UPSR  2,'ESZ bytes',(R8)\n         LA    R7,L$DEBDA(,R7)              next debdasd section\n         BCT   R5,CALCSPAC                  look at all extents\n         SLR   R15,R15                      good return code\n*\nEXTDONE  DS    0H\n         SPKA  8*16                         back to key 8\n         ST    R15,SARC\n         UPSR  1,'ESZ exit; size',(R8)\n         LR    R0,R8                        return estimated size\n         UPEND R0=PASS,RC=*SARC\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\n         LTORG ,\nSAVEAREA DSECT ,\nSASA     DS    18F\nSAENTRY  DS    2F\nSARC     DS    F             return code\nSAREASON DS    X\n         DS    0D\nL$SA     EQU   *-SAVEAREA\n*\n         EJECT ,\n         PRINT NOGEN\n         WAXMIT ,\n         IEZDEB LIST=NO\nL$DEBDA  EQU   (DEBNMTRK+L'DEBNMTRK)-DEBDASD     l' debdasd section\nUCB      DSECT ,\n         IEFUCBOB LIST=NO\nDSCB1    DSECT ,\n         IECSDSL1 (1)                            Format 1 DSCB\n*----------------------------------------------------------------------\n*  See Stage2 assembly of IECZDTAB for values & index\n*----------------------------------------------------------------------\n         IHADVCT ,\n         PRINT NOGEN\n         CVT   DSECT=YES,LIST=NO\n         DCBD  DSORG=PS,DEVD=DA\nXMITESZ  UFINI DXDXESZ,L$SA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XMITKDSN": {"ttr": 14856, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\xb2\\x00\\xb2\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 178, "newlines": 178, "modlines": 0, "user": "XV0006"}, "text": "XMITKDSN TITLE 'Split DSN into key fields'\n*\n* Copyright 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  To do: NO\n*----------------------------------------------------------------------\n         U#SET FUNC=XMIT\n*----------------------------------------------------------------------\n* Function: Create DSN key fields for XMIT02A:\n*           Key, count, and length/value pair(s)\n*\n* Caller: XMIT02A\n*\n* Entry:  S/370 ECMODE KEY=8, STATE=PROB, AUTHORIZED\n*\n*         R0  = address of segment space to contain\n*               DSN key, count, and length/value pair(s)\n*               CL80 is more than enough room\n*\n*         R1  = address of CL44 DSN\n*\n* Exit:   R15 = return code\n*               00 success\n*\n* Abends:\n*\n* Notes: Split out from XMIT02A\n*----------------------------------------------------------------------\n* R2\n* R3\n* R4     @ segment data\n* R5     length remaining in segment data\n* R6     makdsnam ptr to count portion of new qualifier\n* R7     makdsnam ptr to free slot in segment\n* R8     makdsnam dsn char ptr\n* R9     makdsnam # chars left in dsn to examine\n* R10    makdsnam # chars in qualifier\n* R11    XMTWA\n* R12    base reg\n* R13    savearea\n*----------------------------------------------------------------------\nERR#1    EQU   1        dsn parse error\n         TITLE ' '\n*----------------------------------------------------------------------\nXMITKDSN UPROC L=L$SA,ID=XKDS,INIT=MVCL\n         STM   R0,R1,SAENTRY\n         UDIAG 1,'KDSN enter'\n*----------------------------------------------------------------------\n*\n* Maximum possible space consumed by dataset name:\n*\n* 123456789/123456789/123456789/123456789/1234\n* A.B.C.D.E.F.G.H.I.J.K.L.M.N.O.P.Q.R.S.T.U.VW\n* stored as:\n*\n* 0002         INDSNAM key\n* 0016         22 qualifiers\n* 0001 C1 0001 C2 0001 C3 0001 C4 0001 C5 0001 C6 0001 C7 0001 C8\n* 0001 C9 0001 D1 0001 D2 0001 D3 0001 D4 0001 D5 0001 D6 0001 D7\n* 0001 D8 0001 D9 0001 E2 0001 E3 0001 E4 0002 E5E6\n*\n* consumes 71 bytes.  We have way more than that left in the INMR02\n* segment, so we don't worry about overflowing the segment buffer\n*\n* We only have to count the length/value pairs, and drop them in the\n* segment being created\n*\n         LA    R6,SADSNAM              1st count slot\n         LA    R7,2(,R6)               data space in segment\n         L     R8,SAENTRY+4            @ dsn\n         UDIAG 4,'KDSN dsname',(R8),44\n         LA    R8,44-1(,R8)            @ dsn last char\n         LA    R9,44                   max possible dsn length\n*----------------------------------------------------------------------\n*  Determine length of input dataset name\n*----------------------------------------------------------------------\nGETLEN   DS    0H                      calc # chars in dsn\n         CLI   0(R8),C' '              trailing space?\n         BNE   HAVLEN\n         BCTR  R8,0                    r8 back one character\n         BCT   R9,GETLEN               minus trailing space\nHAVLEN   DS    0H                      r9 = # chars in dsn\n         LTR   R9,R9                   better be something left\n         BP    LENOK\n         UDIAG 0,'KDSN input dsn parse error'\n         MVI   SAREASON,ERR#1          dsn parse error\nDIE      UABEND ,                      can't parse dsn\nLENOK    DS    0H\n         UPSR  4,'KDSN dsn length %',(R9)\n*----------------------------------------------------------------------\n*  Handle one qualifier at a time\n*----------------------------------------------------------------------\n         L     R8,SAENTRY+4            @ dsn's first char\n         STM   R0,R15,XMTREGS          debug aid\n         UDIAG 5,'KDSN newqual init regs',XMTREGS,16*4\n*\nNEWQUAL  DS    0H\n         SLR   R10,R10                 # chars in qualifier\n         STM   R0,R15,XMTREGS          debug aid\n         UDIAG 5,'KDSN newqual regs',XMTREGS,16*4\n*----------------------------------------------------------------------\n*  Scan qualifier for end\n*----------------------------------------------------------------------\nNXTCHAR  DS    0H                      parse the qualifier\n         CLI   0(R8),C'.'              found period?\n         BE    TERMQUAL                yes, end of qualifier\n         MVC   0(1,R7),0(R8)           copy qualifier char\n         LA    R7,1(,R7)               next segment char slot\n         LA    R8,1(,R8)               next dsn char\n         LA    R10,1(,R10)             account for char moved\n         BCT   R9,NXTCHAR              one less dsn char\n*\n*  Falling through means last qualifer (no '.')\n*\n         STM   R0,R15,XMTREGS          debug aid\n         UDIAG 4,'KDSN nxtchar fallthru = last',XMTREGS,16*4\n*----------------------------------------------------------------------\n*  Found end of qualifier\n*----------------------------------------------------------------------\nTERMQUAL DS    0H\n         UDIAG 4,'KDSN termqual loop'\n         STCM  R10,3,0(R6)             set # chars in qual\n         SLR   R14,R14                 clean x02quals reg\n         ICM   R14,3,SAQUALS           old # qualifiers\n         LA    R14,1(,R14)             one more\n         STCM  R14,3,SAQUALS           update\n*\n         LR    R6,R7                   next count slot\n         LA    R7,2(,R7)               next data slot\n         LA    R8,1(,R8)               skip period\n         STM   R0,R15,XMTREGS          debug aid\n         UDIAG 5,'KDSN next qual regs',XMTREGS,16*4\n*\n         LTR   R9,R9                   all done?\n         BNP   MADEDSNM\n         BCT   R9,NEWQUAL              account for period,\n*                                      do another qualifier\n*----------------------------------------------------------------------\n*  Finished updating segment with dsn, return\n*----------------------------------------------------------------------\nMADEDSNM DS    0H\n         L     R15,SAENTRY             @ output buffer\n         MVC   SAKDSN,=AL2(INMDSNAM)   set DSN key\n         MVC   0(L$OUT,R15),SAKDSN     return data to caller\n         STM   R0,R15,XMTREGS          debug aid\n         UDIAG 5,'KDSN exit regs',XMTREGS,16*4\n         UDIAG 2,'KDSN exit savearea',(RSA),L$SA\n         UPEND  ,\n         EJECT ,\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\n         LTORG ,\n*----------------------------------------------------------------------\n*  Workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSASA     DS    18F           savearea for anyone we call\nSAENTRY  DS    2F            R0:R1 from entry\n*\nSAKDSN   DS    AL2           DSN key\nSAQUALS  DS    AL2           DSN # qualifiers\nSADSNAM  DS    CL67          DSN count/data pairs built here\nL$OUT    EQU   *-SAKDSN\n*\nSAREASON DS    X\n         DS    0D\nL$SA     EQU   *-SAVEAREA\n*\n         EJECT ,\n         PUSH  PRINT\n         PRINT NOGEN\n         DXSEG ,\n         WAXMIT ,\n         POP   PRINT\nXMITKDSN UFINI DXDXKDS,L$SA            pseudo-register\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XMITKEY": {"ttr": 14860, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x82\\x00\\x82\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 130, "newlines": 130, "modlines": 0, "user": "XV0006"}, "text": "XMITKEY  TITLE 'Place key/count/length/value in segment'\n*\n* Copyright 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  To do: NO\n*----------------------------------------------------------------------\n         U#SET FUNC=XMIT\n*----------------------------------------------------------------------\n* Function: Given one or more key/count/length/value specifications,\n*           place them in the provided (control) segment buffer\n*\n* Caller: various\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         R0  = ignored\n*         R1  = address of VL parmlist as follows:\n*\n*               +00  addr of CL255 segment buffer (see XMITSEG DSECT)\n*               +04  addr of first key/count/length/value\n*               ...  ....    next\n*               ...  ...     last\n*\n*               Upon entry, the segment buffer must have the\n*               following fields initialized:\n*\n*               SEGL\n*               SEGFLG\n*               SEGCTLNM\n*               and for INMR02s: SEGC2NUM\n*\n* Exit:   R15 = 00\n*\n* Notes:\n*----------------------------------------------------------------------\n* R2           address of last usable segment buffer byte\n* R3           address of current parmlist entry\n* R4           address of segment buffer\n* R5           length of segment data (SEGL)\n* R6           count field\n* R7\n* R8           output pointer\n* R9           input  pointer\n* R10          scratch\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\nXMITKEY  UPROC L=L$SA,ID=XKEY,INIT=XC\n         STM   R0,R1,SAENTRY\n         L     R4,0(,R1)               @ segment buffer\n         USING XMITSEG,R4\n         SLR   R5,R5\n         IC    R5,SEGL                 caller already init'd buffer\n         LA    R3,4(,R1)               @ 1st key addr\n         UDIAG 1,'KEY enter'\n         UDIAG 2,'KEY entry seg',(R4),(R5)\n*----------------------------------------------------------------------\n*  For each key address passed, place key & count in segment buffer\n*----------------------------------------------------------------------\n         LA    R2,XMITSEG+254          output limit\n         LA    R8,XMITSEG(R5)          @ output area\nKEYLOOP  DS    0H\n         LA    R0,4(,R8)\n         CR    R0,R2                   enough room for key & count?\n         BH    DIE                     nope, br\n         L     R9,0(,R3)               @ input key\n         ICM   R6,15,0(R9)             grab key & count\n         STCM  R6,15,0(R8)             store key & count\n         LA    R8,4(,R8)               bump past key & count\n*----------------------------------------------------------------------\n*  Place key's length & value pairs in segment buffer\n*----------------------------------------------------------------------\n         SLL   R6,16\n         SRL   R6,16                   remove key\n         LTR   R6,R6                   count = 0 (flag)?\n         BZ    KEYNEXT                 yes, br\n         LA    R9,4(,R9)               bump past key & count\nVLOOP    DS    0H\n         SLR   R10,R10\n         ICM   R10,3,0(R9)             grab length\n         BZ    DIE\n         LA    R0,2(R10,R8)\n         CR    R0,R2                   too much data?\n         BH    DIE\n         STCM  R10,3,0(R8)             store length\n         BCTR  R10,0\n         EX    R10,COPY                copy value to output buffer\n         LA    R8,3(R10,R8)            bump past length & value\n         LA    R9,3(R10,R9)            bump past length & value\n         BCT   R6,VLOOP\n*----------------------------------------------------------------------\n*  Select next key from the parmlist, unless we just finished last one\n*----------------------------------------------------------------------\nKEYNEXT  DS    0H\n         TM    0(R3),X'80'             end of parmlist?\n         BO    EXIT                    yes, finished\n         LA    R3,4(,R3)               @ next key address\n         B     KEYLOOP\n*\nCOPY     MVC   2(*-*,R8),2(R9)         EX target\nDIE      DS    0H\n         UABEND SAREASON               reason code = 00\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\nEXIT     DS    0H\n         LR    R5,R8\n         SR    R5,R4                   calculate segment length\n         STC   R5,SEGL\n         UDIAG 2,'KEY exit seg',(R4),(R5)\n         UDIAG 1,'KEY exit'\n         UPEND ,\n*\n         LTORG ,\n*----------------------------------------------------------------------\n*  Savearea, workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSASA     DS    18F\nSAENTRY  DS    2F            entry parms R0:R1\nSARC     DS    F             return code\nSAREASON DS    X\n         DS    0D\nL$SA     EQU   *-SAVEAREA\n         PRINT NOGEN\n         DXSEG ,\n         WAXMIT ,\nXMITKEY  UFINI DXDXKEY,L$SA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XMITPUT": {"ttr": 15105, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x01\\x1c\\x01\\x1c\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 284, "newlines": 284, "modlines": 0, "user": "XV0006"}, "text": "XMITPUT  TITLE 'WRITE segment'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n* Things to do:\n* 1) Provide EXLST to set BLKSIZE if not coded in JCL/JFCB\n*----------------------------------------------------------------------\n         U#SET FUNC=XMIT\n*----------------------------------------------------------------------\n* Function: Write a segment (XMITSEG), respecting LRECL boundaries\n*           and buffer data as necessary.\n*           Similar to fputc support in the C language.\n*           This code maintains the DCB associated with it's\n*           output file.\n*\n* Caller: various\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         R0  =\n*         R1  =  Address of buffer to be written\n*                when = 0, buffers will be flushed & DCB closed\n*                length of SEGL must be correct\n*\n* Exit:   R15 = 0\n*\n* Abends: DCB didn't open\n*         residual data handling error (buffer hosed)\n*\n* Notes:  The caller is responsible for setting the segment's\n*         length and flags.\n*         We PUT the whole segment, including the length & flag;\n*         RECEIVE needs the length & flag to reconstruct the file.\n*         Some older code's documentation might refer to this code\n*         as PUTSEG.\n*----------------------------------------------------------------------\n* R2     XPSWA\n* R3     DCB\n* R4     input buffer\n* R5     length of input buffer\n* R6     length of residual data in XPSSEG\n* R7     length of input data to copy to residual data\n* R8     scratch\n* R9     constant: 80 = LRECL\n* R10    internal linkage\n* R11    xmtwa\n* R12    base reg\n* R13    savearea\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\nXMITPUT  UPROC L=L$SA,ID=XPUT,WA=SAVEAREA\n         STM   R0,R15,XMTREGS               <debug>\n         LA    R4,0(,R1)                    save input parm, clear hi\n         UDIAG 1,'XMITPUT entered'\n         UDIAG 6,'XMITPUT entry regs',XMTREGS,16*4\n         LTR   R4,R4                        term request?\n         BZ    TERM\n         USING XMITSEG,R4\n*\n         L     R2,XMT@PS                    find our workarea\n         LTR   R2,R2                        does it exist?\n         BNZ   NORMAL\n         EJECT ,\n*----------------------------------------------------------------------\n* Initialize XPSWA\n*----------------------------------------------------------------------\n         UDIAG 2,'XMITPUT: initializing XPSWA'\n         LA    R2,XMTXPSWA\n         USING XPSWA,R2\n         UZERO (R2),L$XPSWA                 clear storage\n         MVC   XPSDCB(L$DCB),MODLDCB        copy model DCB macro\n         MVC   XPSOPN(L$OPN),MODLOPN        copy model OPEN macro\n         MVC   XPSCLOS(L$CLOS),MODLCLOS     copy model CLOSE macro\n         ST    R2,XMT@PS                    save ptr to out workarea\n         B     NORMAL\n         EJECT ,\n*----------------------------------------------------------------------\n* Terminate request\n*----------------------------------------------------------------------\nTERM     DS    0H\n         L     R2,XMT@PS\n*\n* Fill remainder of LRECL with blanks, write if any residual data\n*\n         UDIAG 6,'XMITPUT: term residual',XPSSEG,80\n         L     R6,XPSRL                     residual data length\n         LTR   R6,R6\n         BZ    TERMCLOS\n         LA    R15,80                       lrecl\n         LR    R9,R15                       <bogus> for PUT snap\n         SR    R15,R6                       # bytes to blank\n         LA    R4,XPSSEG\n         LA    R14,0(R6,R4)                 @ 1st byte to set to blank\n         MVI   0(R14),C' '                  blank to be propogated\n         BCTR  R15,0\n         EX    R15,BLANKRES                 blank rest of residual\n         UDIAG 6,'XMITPUT: term residual write',XPSSEG,80\n         BAL   R10,PUT                      write last record\nTERMCLOS DS    0H\n         UDIAG 2,'XMITPUT: closing XMITOUT ddname'\n         CLOSE (XPSDCB,),MF=(E,XPSCLOS)\n         XC    XMT@PS,XMT@PS                workarea gone\n         B     EXITRC0\n*\nBLANKRES MVC   1(*-*,R14),0(R14)            executed\n         EJECT ,\n*----------------------------------------------------------------------\n* Normal write request - open DCB if needed\n*----------------------------------------------------------------------\nNORMAL   DS    0H\n         UDIAG 6,'XMITPUT: XPSWA dump <NORMAL>',XMTXPSWE,L$XPSWA+8\n         LA    R9,80                        LRECL (constant)\n         SLR   R5,R5\n         IC    R5,SEGL                      segment length\n         UDIAG 3,'XMITPUT: input segment',(R4),(R5)\n         LA    R3,XPSDCB\n         USING IHADCB,R3\n         TM    DCBOFLG1,DCBOFOPN            dcb open?\n         BO    DCBOPEN\n         TM    XPSFLG1,XPS1OPN              not open, but did already?\n         BNO   NEWOPEN                      first time, OK\n*\n         UDIAG 0,'XMITPUT: XMITOUT DCB error',XMTXPSWE,L$XPSWA+8\n         UABEND DUMP=Y\n*\nNEWOPEN  DS    0H\n         UDIAG 2,'XMITPUT: opening XMITOUT ddname'\n         OPEN  (XPSDCB,OUTPUT),MF=(E,XPSOPN)\n         OI    XPSFLG1,XPS1OPN              OPEN request issued\n         TM    DCBOFLG1,DCBOFOPN            opened?\n         BO    DCBOPEN\n         UDIAG 0,'XMITPUT: XMITOUT DCB open error',XMTXPSWE,L$XPSWA+8\n         UABEND ,                           output DCB didn't open\n         EJECT ,\n*----------------------------------------------------------------------\n* Try to output residual data in XPSSEG before putting input buffer\n*----------------------------------------------------------------------\nCOPYRES  MVC   0(*-*,R14),0(R4)             executed\n*\nDCBOPEN  DS    0H\n         L     R6,XPSRL                     l' residual data\n         LTR   R6,R6                        any?\n         BZ    PUTINIT                      no, just put input buffer\n*\n         UDIAG 7,'XMITPUT: XPSSEG contains residual data',XPSSEG,(R6)\n         LR    R7,R9                        lrecl\n         SR    R7,R6                        minus l' residual data\n*                            R7 = # bytes needed to complete LRECL\n*\n* Calc how much data to copy from input to behind current residual.\n* A maximum of LRECL bytes will be stored in XPSSEG, the remainder\n* of the input bytes (if any) will remain in the input buffer\n* to be processed by PUTLOOP below.\n*                                           assume just enough bytes\n         LR    R15,R7                       in input seg to fill lrecl\n         CR    R5,R7                        have more than needed?\n         BH    *+6                          yes, leave r15 alone\n         LR    R15,R5                       no use l' input buffer\n*                            R15 = # bytes to copy from input buffer\n*\n         BCTR  R15,0                        minus 1 for EXexute\n         LA    R14,XPSSEG(R6)               copy destination\n*\n*** <Perform sanity test here>\n*\n         EX    R15,COPYRES                  copy residual to XPSSEG\n         LA    R15,1(,R15)                  plus 1 for EXecute\n         AR    R6,R15                       new l' residual data\n         AR    R4,R15                       account for copied data\n         SR    R5,R15                       account for copied data\n*\n* If possible, write a full lrecl from residual data\n*\n         ST    R6,XPSRL                     update l' residual data\n         UDIAG 7,'XMITPUT: input added to residual',XPSSEG,(R6)\n         CR    R6,R9                        have full residual rec?\n         BL    EXITRC0                      no, can't PUT data yet\n         BH    BADCODE                      oops, we spaced out\n*\n* Write a lrecl's worth of data from the \"residual\" buffer\n*\n         UDIAG 4,'XMITPUT: write full residual buffer',XPSSEG,(R9)\n         LA    R0,XPSSEG                    record address\n         PUT   XPSDCB,(0)                   write record\n         XC    XPSRL,XPSRL                  no more residual data\n         XC    XPSSEG,XPSSEG                clear residual data\n*----------------------------------------------------------------------\n* Output as much data as possible from input buffer\n*----------------------------------------------------------------------\nPUTINIT  DS    0H\n         LTR   R5,R5                        any data left?\n         BZ    EXITRC0                      no, all done\n         BM    BADCODE                      oops, went negative\n         LA    R10,PUTLOOP                  (term uses \"put\" rtn)\n         UDIAG 6,'XMITPUT: PUT from input buffer'\nPUTLOOP  DS    0H\n         CR    R5,R9                        more recs to output?\n         BL    RESIDUAL                     no, save residual data\n*\n*----------------------------------------------------------------------\n*  Internal routine to PUT data\n*  R4 @ data byte to output, R5 = length, R9 = lrecl, R10 = return\n*----------------------------------------------------------------------\n*\nPUT      DS    0H\n         UDIAG 4,'XMITPUT: PUT segment',(R4),(R9)\n         LR    R0,R4                        record address\n         PUT   XPSDCB,(0)                   write record\n         AR    R4,R9                        bump record ptr\n         SR    R5,R9                        decr length\n         BR    R10\n*----------------------------------------------------------------------\n* Save unwritten input buffer data as residual in XPSSEG\n*----------------------------------------------------------------------\nCOPY     MVC   XPSSEG(*-*),0(R4)            executed\n*\nRESIDUAL DS    0H            less than 80 bytes to output from segment\n         STM   R0,R15,XMTREGS               <debug>\n         UDIAG 7,'XMITPUT: <RESIDUAL> regs',XMTREGS,16*4\n         ST    R5,XPSRL                     save residual length\n         LTR   R5,R5                        anything left?\n         BZ    EXITRC0                      no, leave XPSSEG alone\n         BM    BADCODE                      arggh, negative\n         BCTR  R5,0                         length minus 1 for EX\n         EX    R5,COPY                      copy residual data\n         EJECT ,\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\nEXITRC0  SLR   R15,R15                      set good return code\nEXIT     DS    0H\n         ST    R15,SARC\n         L     R14,XPSRL\n         LTR   R14,R14                      any residual data?\n         BZ    SKIPDSP\n         UDIAG 7,'XMITPUT: residual at exit',XPSSEG,(R14)\nSKIPDSP  DS    0H\n         UDIAG 7,'XMITPUT: XPSWA at exit',XMTXPSWE,L$XPSWA+8\n         UDIAG 1,'XMITPUT exited'\n         L     R15,SARC\n         UPEND ,\n*\nBADCODE  DS    0H\n         STM   R0,R15,XMTREGS\n         USNAP 'XMITPUT: internal error - regs',XMTREGS,16*4\n         USNAP 'XMITPUT: <badcode> xpswa',XMTXPSWE,L$XPSWA+8\n         UABEND DUMP=Y                      buffer handling error\n         EJECT ,\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\nMODLCLOS CLOSE (,),MF=L                model CLOSE\nL$CLOS   EQU   *-MODLCLOS              l' model close\n*\nMODLOPN  OPEN  (,),MF=L                model OPEN\nL$OPN    EQU   *-MODLOPN               l' model open\n*\nMODLDCB  DCB   DDNAME=XMITOUT,                                         +\n               MACRF=PM,DSORG=PS,RECFM=FB,                             +\n               LRECL=80,BLKSIZE=3200         NEED EXLST to fill blksize\nL$DCB    EQU   *-MODLDCB\n*\n         LTORG ,\n         EJECT ,\n*----------------------------------------------------------------------\n*  Savearea/workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSA       DS    18F\nSARC     DS    F\n         DS    0D\nL$SA     EQU   *-SAVEAREA\n         EJECT ,\n         PRINT NOGEN\n         DXSEG ,\n*        EJECT ,\n         WAXMIT ,\n*        EJECT ,\n         DCBD  DSORG=PS,DEVD=DA\n         PRINT GEN\nXMITPUT  UFINI DXDXPUT,L$SA\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XMITUNLD": {"ttr": 15111, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\xdd\\x00\\xdd\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 221, "newlines": 221, "modlines": 0, "user": "XV0006"}, "text": "XMITUNLD TITLE 'INVOKE IEBCOPY to unload dataset, write segments'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  To do: NO\n*----------------------------------------------------------------------\n         U#SET FUNC=XMIT\n*----------------------------------------------------------------------\n* Function: Invoke IEBCOPY to unload the input dataset, read the\n*           IEBCOPY unload data, and write segments containing the\n*           unloaded data.  Supports partitioned datasets and\n*           sequential datasets.\n*\n*           Data is written as follows:\n*           XMIT01    INMR01 (always first)\n*           XMIT02A   INMR02 IEBCOPY\n*           XMIT02B   INMR02 INMCOPY\n*           XMIT03    INMR03 (precedes unloaded data)\n*           XMITUNLD  <unloaded data>\n*           XMIT06    INMR06 (trailer, always last)\n*\n* Caller: XMIT370\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         R0  =\n*         R1  =\n*\n* Exit:   R15 = return code\n*         R15 = 00 success\n*\n* Abends:\n*\n* Notes:  XMIT370 has opened SYSUT1 (XMTDCBI), and read the SYSUT1\n*         JFCB into XMTJFCB1; XMT@JFCB points at XMTJFCB1\n*----------------------------------------------------------------------\n* R2\n* R3     JFCB\n* R4     length of block read\n* R5\n* R6     length of allocated input buffer\n* R7     IOB\n* R8     input DCB\n* R9     @ input record\n* R10\n* R11    XMTWA\n* R12    base reg\n* R13    savearea\n*----------------------------------------------------------------------\nERR#1    EQU   1        SYSUT1 invalid DSORG\n         TITLE ' '\n*----------------------------------------------------------------------\nXMITUNLD UPROC L=L$SA,ID=XULD\n         UDIAG 1,'UNLD entered'\n         SLR   R6,R6                        no buffer allocated\n*----------------------------------------------------------------------\n*  Write INMR01 segment\n*----------------------------------------------------------------------\n         UCALL XMIT01,ERR=EXIT\n*----------------------------------------------------------------------\n*  Unload PDS & write INMR02 IEBCOPY segment (DSORG=PO only)\n*----------------------------------------------------------------------\n         L     R3,XMT@JFCB\n         USING INFMJFCB,R3\n         TM    JFCDSORG,JFCORGPS            physical sequential?\n         BO    NOPDS\n         TM    JFCDSORG,JFCORGPO            partitioned?\n         BNO   BADORG\nPDS      UCALL XMIT02A,ERR=EXIT   unload PDS, write IEBCOPY INMR02\n*----------------------------------------------------------------------\n*  Write INMR02 INMCOPY segment for DSORG=PS or DSORG=PO\n*----------------------------------------------------------------------\nNOPDS    UCALL XMIT02B,ERR=EXIT             DCBI ddname = SYSUT1/SYSUT2\n*----------------------------------------------------------------------\n*  Write INMR03 segment prior to outputting data segments\n*----------------------------------------------------------------------\n         UCALL XMIT03,ERR=EXIT\n*----------------------------------------------------------------------\n*  Set EOF routine and allocate input buffer\n*----------------------------------------------------------------------\nSETEOF   DS    0H\n         L     R3,XMT@JFCB                  refresh xmtdcbi's JFCB ptr\n         LA    R8,XMTDCBI                   @ input DCB\n         USING IHADCB,R8\n         LA    R0,EOFRTN\n         STCM  R0,7,DCBEODA                 set EOF exit rtn addr\n         MVC   SADECBI(L$DECB),MODLDECB     copy model DECB\n         LH    R6,DCBBLKSI                  get blksize\n         GETMAIN R,LV=(R6)                  alloc input buffer\n         LR    R9,R1\n*----------------------------------------------------------------------\n* Read block of data from SYSUT1 or SYSUT2\n*----------------------------------------------------------------------\nREAD     DS    0H\n         READ  SADECBI,SF,(R8),(R9),'S',MF=E\n*        UDIAG 2,'UNLD: READ issued'\n*\n         CHECK SADECBI\n         L     R7,(DECIOBPT-DECB)+SADECBI    @ IOB\n         USING IOBSTDRD,R7\n*\n*        UDIAG 5,'UNLD: DECB after CHECK',SADECBI,L$DECB\n*        UDIAG 5,'UNLD: DCB after CHECK',(R8),L$DCB\n*        UDIAG 5,'UNLD: IOB after CHECK',(R7),L$IOB\n*\n*  careful, recfm=u = recfm=v + recfm=f\n*\n         TM    DCBRECFM,DCBRECU        RECFM=U, get residual\n         BO    CALCLEN\n         LH    R4,0(R9)                l' RECFM=VB record = BDW\n         TM    DCBRECFM,DCBRECV        guessed wrong?\n         BO    HVLEN\nCALCLEN  DS    0H\n         LH    R4,DCBBLKSI             max l' RECFM=F or U\n         LH    R0,IOBSTBYT+2           residual count\n         SR    R4,R0                   r4 = l' read\nHVLEN    DS    0H\n         UDIAG 3,'UNLD: input record',(R9),(R4)\n*----------------------------------------------------------------------\n* If this is the IEBCOPY COPYR1 record, see if it needs \"fixing\"\n*----------------------------------------------------------------------\nCKCOPYR1 DS    0H\n         TM    SAFLG1,SAF1FX           already fixed?\n         BO    WRITE\n         CLC   =X'CA6D0F',9(R9)        COPYR1 id?\n         BNE   WRITE                   nope, skip\nFXCOPYR1 DS    0H\n         LR    R1,R9                   @ COPYR1 block\n         UCALL XMITCPR1                call COPYR1-fixer-upper\n         OI    SAFLG1,SAF1FX           show fixed\n         LH    R4,0(,R9)               retrieve new buffer length\n*----------------------------------------------------------------------\n* Write data segments from data read\n*----------------------------------------------------------------------\nWRITE    DS    0H\n         LR    R0,R4                   buffer length\n         LR    R1,R9                   buffer addr\n*\n*  XMIT doesn't transmit BDW & RDW for unloaded DSORG=PO datasets\n*\n         TM    JFCRECFM,JFCVAR         have to fudge recfm=v\n         BNO   WBUF\n         TM    XMTFLG1,XMTF1$U         for unloaded datasets,\n         BNO   WBUF\n         S     R0,=F'8'                fudge length\n         LA    R1,8(,R1)               adjust record ptr\n*\nWBUF     DS    0H\n         UCALL XMITBUF            split buffer into segments, write\n         LTR   R15,R15\n         BZ    READ\n         B     EXIT\n*----------------------------------------------------------------------\n* Write INMR06 segment at End Of File\n*----------------------------------------------------------------------\nEOFRTN   DS    0H\n         UCALL XMIT06,ERR=EXIT\n         SLR   R15,R15\n*----------------------------------------------------------------------\n*  Release gotten storage, close DCB\n*----------------------------------------------------------------------\nEXIT     DS    0H\n         ST    R15,SARC\n         LTR   R0,R6\n         BZ    NOFREE\n         FREEMAIN R,LV=(0),A=(R9)\nNOFREE   DS    0H\n         TM    DCBOFLGS,DCBOFOPN       DCB open?\n         BNO   EXIT99\n         MVC   XMTCLOS(L$CLOS),MODLCLOS\n         UDIAG 1,'UNLD CLOSE XMITDCBI',XMTDCBI,L$DCB\n         CLOSE XMTDCBI,MF=(E,XMTCLOS)  close SYSUT2\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\nEXIT99   UDIAG 1,'UNLD exited'\n         UPEND RC=*SARC\n*----------------------------------------------------------------------\nBADORG   DS    0H\n         USNAP 'XMITUNLD: JFCB invalid DSORG',(R3),L$JFCB\n         MVI   SAREASON,ERR#1\nDIE      UABEND SAREASON               invalid input file DSORG\n*\nMODLCLOS CLOSE (,),MF=L\nL$CLOS   EQU  *-MODLCLOS\n*\nMODLDECB READ MODLECB,SF,0,0,'S',MF=L\nL$DECB   EQU  *-MODLDECB\n*\n         LTORG ,\n         EJECT ,\n*----------------------------------------------------------------------\n*  Workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSASA     DS    18F\nSAFLG1   DS    X\nSAF1FX   EQU   128                     COPYR1 fixed\nSAREASON DS    X\nSARC     DS    F                       return code\nSADECBI  READ  SAECBI,SF,0,0,'S',MF=L\n         DS    0D\nL$SA     EQU   *-SAVEAREA\n         PRINT NOGEN\n         WAXMIT ,\n*\n         DCBD  DSORG=PS,DEVD=DA\nL$DCB    EQU   *-IHADCB\n*\nJFCB     DSECT ,\n         IEFJFCBN LIST=YES\nL$JFCB   EQU   *-JFCB\n*\n         IHADECB ,\n*\n         IEZIOB ,\nL$IOB    EQU    *-IOB\n*\nXMITUNLD UFINI DXDXUNLD,L$SA\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XMITVTAB": {"ttr": 15116, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x16\\x00\\x16\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "XV0006"}, "text": "XMITVTAB TITLE 'XMIT370 VCON table'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n         U#SET FUNC=XMIT\n         UVTAB MF=HDR\n         UVTAB XMIT370\n         UVTAB XMITBUF\n         UVTAB XMITCPR1\n         UVTAB XMITDIR\n         UVTAB XMITESZ\n         UVTAB XMITKDSN\n         UVTAB XMITKEY\n         UVTAB XMITPUT\n         UVTAB XMITUNLD\n         UVTAB XMIT01\n         UVTAB XMIT02A\n         UVTAB XMIT02B\n         UVTAB XMIT03\n         UVTAB XMIT06\n         UVTAB MF=TLR\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XMIT01": {"ttr": 15118, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x96\\x00\\x96\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 150, "newlines": 150, "modlines": 0, "user": "XV0006"}, "text": "XMIT01   TITLE 'WRITE INMR01 segment'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  To do:\n*----------------------------------------------------------------------\n         U#SET FUNC=XMIT\n*----------------------------------------------------------------------\n* Function: Collect the information for, and write the INMR01 segment.\n*\n* Caller: XMITUNLD\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         R0  =\n*         R1  =\n*\n* Exit:   R15 = 00 = return code\n*\n* Notes:\n*----------------------------------------------------------------------\n* R2\n* R3\n* R4     @ segment data\n* R5     length remaining in segment data\n* R6\n* R7\n* R8\n* R9\n* R10\n* R11    XMTWA\n* R12    base reg\n* R13    savearea\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\nXMIT01   UPROC L=L$SA,ID=XM01,INIT=MVCL\n         UDIAG 1,'XMIT01 enter'\n*----------------------------------------------------------------------\n* Create INMR01 segment's key data\n*----------------------------------------------------------------------\n         MVI   X01SEGL,8                    segment length\n         MVI   X01SEGF,SEG$1+SEG$L+SEG$C    segment flag\n         MVC   X01ID,=C'INMR01'\n*----------------------------------------------------------------------\n* Update key data\n*----------------------------------------------------------------------\n         MVC   SAKEY1(L$PROT),PROTLIST      copy prototype list\n         TIME  DEC                          R0=HHMMSSth, R1=00YYDDDF\n         STM   R0,R1,SATIMED\n         SLR   R0,R0                        Julian to Gregorian\n         LA    R1,SATIMED\n         UCALL U370DATE                     convert date, time\n         MVC   SAKFTIME,KFTIME              set date, time key info\n         LA    R0,SAKFTIME\n         ST    R0,SA@FTIME                  provide U370DATE key ptr\n*----------------------------------------------------------------------\n*  Build INMR01 segment\n*----------------------------------------------------------------------\nBUILD    DS    0H\n         LA    R0,X01MR01                   @ segment buffer\n         ST    R0,SA@BUF\n         OI    SAKEYX,X'80'                 set VL flag\n         LA    R1,SAKEYPL                   @ parmlist\n         UCALL XMITKEY                      build segment from key list\n*----------------------------------------------------------------------\n*  Write INMR01 segment\n*----------------------------------------------------------------------\nWRITE    DS    0H\n         LA    R1,X01MR01\n         UCALL XMITPUT                      write INMR01 segment\nEXIT     DS    0H\n         UDIAG 1,'XMIT01 exited'\n         SLR   R15,R15                      good return code\n         UPEND  ,\n         EJECT ,\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\n         LTORG ,\n*\nMR01     DS    0X\nKLRECL   DC    AL2(INMLRECL,1,L'VLRECL)    0042 physical lrecl\nVLRECL   DC    FL1'80'                     of control segments\n*\nKFNODE   DC    AL2(INMFNODE,1,L'VFNODE)    1011 origin node\nVFNODE   DC    C'ORIGNODE'\n*\nKFUID    DC    AL2(INMFUID,1,L'VFUID)      1012 origin userid\nVFUID    DC    C'ORIGUID'\n*\nKTNODE   DC    AL2(INMTNODE,1,L'VTNODE)    1001 dest node\nVTNODE   DC    C'DESTNODE'\n*\nKTUID    DC    AL2(INMTUID,1,L'VTUID)      1002 dest userid\nVTUID    DC    C'DESTUID'\n*\nKFTIME   DC    AL2(INMFTIME,1,14)          1024 origin time stamp\nL$KFTIME EQU   *-KFTIME\n*\nKNUMF    DC    AL2(INMNUMF,1,L'VNUMF)      102F # files\nVNUMF    DC    X'01'\n*\n* optional keys not provided: INMFACK, INMFVERS, INMNUMF, INMUSERP\n*\n*----------------------------------------------------------------------\nPROTLIST DS    0D            prototype key list passed to U370KEY\nX1@LRECL DC    A(KLRECL)     addr of LRECL key info\nX1@FNODE DC    A(KFNODE)             ORIGIN NODE\nX1@FUID  DC    A(KFUID)              ORIGIN USERID\nX1@TNODE DC    A(KTNODE)             DEST NODE\nX1@TUID  DC    A(KTUID)              DEST USERID\nX1@FTIME DC    A(KFTIME)             ORIGIN TIME STAMP\nX1@NUMF  DC    A(KNUMF)              NUMBER OF FILES\nL$PROT   EQU   *-PROTLIST\n*----------------------------------------------------------------------\n*  Workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSASA     DS    18F\n*\nSATIMED  DS    D                       TIME DEC R0:R1\nSAKFTIME EQU   SATIMED+2,6\nSATIMEE  DS    CL16'YYYYMMDDHHMMSSTH'  U370DATE return buffer\n*\nSAKEYPL  DS    0D            XMITKEY parmlist\nSA@BUF   DS    A             addr of seg buffer\nSAKEY1   EQU   *             beginning of key addresses\nSA@LRECL DS    A             addr of LRECL key info\nSA@FNODE DS    A                     ORIGIN NODE\nSA@FUID  DS    A                     ORIGIN USERID\nSA@TNODE DS    A                     DEST NODE\nSA@TUID  DS    A                     DEST USERID\nSA@FTIME DS    A                     ORIGIN TIME STAMP\nSA@NUMF  DS    A                     NUMBER OF FILES\nSAKEYX   EQU   *-4,1         VL byte\n*\nX01MR01  DS    0D            INMR01 segment\nX01SEGL  DS    X             segment length\nX01SEGF  DS    X             segment flag\nX01SEGD  DS    XL253         segment data\nX01ID    EQU   X01SEGD,6     C'INMR01'\n         DS    0D\nL$SA     EQU   *-SAVEAREA\n         PRINT NOGEN\n         DXSEG ,\n         WAXMIT ,\nXMIT01   UFINI DXDX01,L$SA           pseudo-register\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XMIT02A": {"ttr": 15364, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x01\\x87\\x01\\x87\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 391, "newlines": 391, "modlines": 0, "user": "XV0006"}, "text": "XMIT02A  TITLE 'Unload PDS, write INMR02 IEBCOPY segment'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  To do:\n*  1) Move XMITESZ call to after the SYSUT2 DSCB has been read\n*     (is it?), then use the SYSUT2 DSCB to estimate space required.\n*     SYSUT2 might need RELEASE SPACE call to make it as accurate\n*     as possible; however, is that a good idea?\n*     User might have overallocated SYSUT2 to cause TSO/E RECEIVE\n*     to overallocate its output file instead of the no-extra-room\n*     allocation TSO/E RECEIVE usually delivers.\n*----------------------------------------------------------------------\n         U#SET FUNC=XMIT\n*----------------------------------------------------------------------\n* Function: Call IEBCOPY to unload the input dataset\n*           Write the IEBCOPY INMR02 segment\n*\n* Caller: XMITUNLD when SYSUT1 DSORG=PO\n*\n* Entry:  S/370 ECMODE KEY=8, STATE=PROB, AUTHORIZED\n*\n*         R0  =\n*         R1  =\n*\n* Exit:   R15 = return code\n*               00 success\n*\n* Diagnostics:\n*              1 - entry/exit\n*              2 - internal trace\n*              3 - DSCB, JFCB, DCB\n*              4 - savearea at exit\n*\n* Notes: XMITUNLD only calls us for DSORG=PO datasets\n*        XMIT370 has already read in the JFCB for the input dataset.\n*        We also read SYSUT1's Format-1 DSCB, for XMITCPR1.\n*----------------------------------------------------------------------\n* R2     DCB\n* R3     JFCB\n* R4     @ segment data\n* R5     length remaining in segment data\n* R6     Format1 DSCB\n* R7\n* R8\n* R9\n* R10\n* R11    XMTWA\n* R12    base reg\n* R13    savearea\n*----------------------------------------------------------------------\nERR#1    EQU   1        SYSUT1 OBTAIN error\nERR#2    EQU   2        SYSUT2 OPEN   error\nERR#3    EQU   3        SYSUT2 RDJFCB error\n         TITLE ' '\n*----------------------------------------------------------------------\nXMIT02A  UPROC L=L$SA,ID=X02A,INIT=MVCL\n         UDIAG 1,'XMIT02A enter'\n         LA    R2,XMTDCBI\n         LA    R3,XMTJFCB1                  @ SYSUT1 JFCB\n         USING IHADCB,R2\n         USING JFCB,R3\n         UDIAG 4,'XMIT02A XMTDCBI',(R2),L$DCB\n         UDIAG 4,'XMIT02A XMTJFCB1',(R3),L$JFCB\n*----------------------------------------------------------------------\n* Initialize IEBCOPY INMR02 segment\n*----------------------------------------------------------------------\n         MVI   X02SEGL,12                   segment length\n         MVI   X02SEGF,SEG$1+SEG$L+SEG$C    segment flags\n         MVC   X02ID,=C'INMR02'\n         L     R0,XMT#FILE\n         ST    R0,X02NUM                    file number\n         MVC   SAKEY1(L$PROT),PROTLIST      copy prototype keys list\n*----------------------------------------------------------------------\n*  Obtain SYSUT1 Format 1 DSCB\n*----------------------------------------------------------------------\n*\n*  Format-1 DSCB of dataset to be XMIT'd.\n*  OBTAIN macro returns first 96 bytes of XMTDSCB1 = data portion\n*  of DSCB, next 5 bytes = CCHHR of DSCB (zero for VSAM/VIO).\n*\n         MVC   XMTDSN1,JFCBDSNM             copy dsn\n         MVC   SACAML(L$CAMLST),CAMLST      copy CAMSLT; +0(4) flags\n         LA    R0,JFCBDSNM\n         ST    R0,SACAML+04                 dsn\n         LA    R0,JFCBVOLS\n         ST    R0,SACAML+08                 volser\n         LA    R6,XMTDSCB1                  SYSUT1 DSCB area\n         ST    R6,SACAML+12                 @ dscb buffer\n         OBTAIN SACAML                      obtain SYSUT1 DSCB1\n         ST    R15,SARC                     save return code\n         L     R15,SARC\n         LTR   R15,R15                      OBTAIN good?\n         BZ    OBTAINOK\n         UPSR  0,'XMIT02A SYSUT1 OBTAIN error; rc',(R15)\n         UDIAG 0,'XMIT02A OBTAIN parmlist',SACAML,L$CAMLST\n         MVI   SAREASON,ERR#1               OBTAIN error\nDIE      UABEND SAREASON\nOBTAINOK DS    0H\n         UDIAG 3,'XMIT02A SYSUT1 DSCB',XMTDSN1,44+140\n         USING DSCB1,R6\n*----------------------------------------------------------------------\n*  Estimate the size (in bytes) of the input dataset\n*----------------------------------------------------------------------\n         LR    R0,R6                   @ SYSUT1 Format1 DSCB\n         LR    R1,R2                   @ SYSUT1 open DCB\n         UCALL XMITESZ,ERR=EXIT\n         STCM  R0,15,XSIZE             approximate # bytes allocated\n         ST    R0,XMTESZ               for XMIT02B, XMIT03\n*----------------------------------------------------------------------\n*  Determine how many directory blocks the PDS has allocated\n*----------------------------------------------------------------------\n         LR    R1,R2                   @ open SYSUT1 DCB\n         UCALL XMITDIR,ERR=EXIT\n         STCM  R0,7,XDIR               directory blocks allocated\n*----------------------------------------------------------------------\n*  Format dataset name\n*----------------------------------------------------------------------\nMAKEDSN  DS    0H\n         LA    R0,SAKDSN                    @ DSN key segment space\n         LA    R1,JFCBDSNM                  @ dataset name\n         UCALL XMITKDSN                     build dsn fields\n*----------------------------------------------------------------------\n*  Build INMR02 segment\n*----------------------------------------------------------------------\n         LA    R0,SAKSIZE\n         ST    R0,SA@SIZE\n         MVC   SAKSIZE(6),KSIZE\n         LA    R0,SAKDSORG\n         ST    R0,SA@DSORG\n         MVC   SAKDSORG(6),KDSORG\n         LA    R0,SAKLRECL\n         ST    R0,SA@LRECL\n         MVC   SAKLRECL(6),KLRECL\n         LA    R0,SAKBLKSZ\n         ST    R0,SA@BLKSZ\n         MVC   SAKBLKSZ(6),KBLKSZ\n         LA    R0,SAKRECFM\n         ST    R0,SA@RECFM\n         MVC   SAKRECFM(6),KRECFM\n         LA    R0,SAKDIR\n         ST    R0,SA@DIR\n         MVC   SAKDIR(6),KDIR\n         LA    R0,SAKDSN\n         ST    R0,SA@DSN\n*\n*  Note LRECL is only a two byte field, but TSO/E TRANSMIT seems to\n*  always store the LRECL value as a four byte field.\n*  Similarly, RECFM and BLKSIZE are transmitted in larger fields, too.\n*\n         MVC   XDSORG,JFCDSORG              dsorg\n         MVC   XLRECL+2(2),JFCLRECL         lrecl\n         MVC   XRECFM(1),JFCRECFM           recfm\n         MVC   XBLKSZ+2(2),JFCBLKSI         block size\n         LA    R0,X02MR02                   @ segment buffer\n         ST    R0,SA@BUF\n         OI    SAKEYX,X'80'                 set VL flag\n         LA    R1,SAKEYPL                   @ parmlist\n         UCALL XMITKEY                      build segment from key list\n*----------------------------------------------------------------------\n*  Write INMR02 segment for DSORG=PO dataset\n*----------------------------------------------------------------------\nWRITE02  DS    0H\n         LA    R1,X02MR02\n         UCALL XMITPUT                      write INMR02 segment\n         EJECT ,\n*----------------------------------------------------------------------\n* Close the SYSUT1 input dataset\n*----------------------------------------------------------------------\nCLOSE    DS    0H\n         UDIAG 2,'XMIT02A: close DSORG=PO SYSUT1'\n         MVC   XMTCLOS(L$CLOS),MODLCLOS     copy model CLOSE macro\n         CLOSE XMTDCBI,MF=(E,XMTCLOS)       close DSORG=PO SYSUT1\n         EJECT ,\n*----------------------------------------------------------------------\n* Call IEBCOPY to unload the PDS\n*----------------------------------------------------------------------\nIEBCOPY  DS    0H\n         LA    R0,=CL8'IEBCOPY'\n         LOAD  EPLOC=(0)               load IEBCOPY\n         LTR   R15,R15\n         BZ    GOCOPY\n         ST    R15,SARC\n         UPSR  0,'XMIT02A: IEBCOPY LOAD failed; rc',(R15)\n         B     EXIT\n*\nGOCOPY   DS    0H\n         LR    R15,R0                  get entry address\n         LA    R15,0(,R15)             clear hi byte for DELETE\n         LR    R9,R15\n         LA    R1,SAPRMOS              IEBCOPY parm: OS parm string\n         ST    R1,SAPRM1\n         OI    SAPRM1,X'80'            end of VL parmlist\n         LA    R1,SAPRM1\n         BALR  R14,R15                 call IEBCOPY\n         ST    R15,SARC\n         UPSR  2,'XMIT02A IEBCOPY rc %',(R15)\n         L     R15,SARC\n         LTR   R15,R15\n         BNZ   EXIT\n*\nDELCOPY  DS    0H\n         UDIAG 2,'XMIT02A: IEBCOPY unload successful'\n         LA    R0,=CL8'IEBCOPY'\n         DELETE EPLOC=(0)              delete IEBCOPY\n*----------------------------------------------------------------------\n* Open the IEBCOPY output dataset as our input, retrieve JFCB\n*----------------------------------------------------------------------\nOPEN     DS    0H\n         MVC   XMTOPN(L$OPN),MODLOPN     copy model OPEN macro\n         MVC   XMTDCBI(L$DCBI),MODLDCBI  copy model DCB\n         OPEN  XMTDCBI,MF=(E,XMTOPN)        open IEBCOPY's SYSUT2\n         MVC   XMTJFCBL(L$JFCBL),JFCBLST    copy open exit list\n         LA    R0,XMTJFCB2                  relocate JFCB addr\n         STCM  R0,7,XMTJFCBL+1\n         LA    R0,XMTJFCBL                  relocate DCB's EXLST\n         STCM  R0,7,(DCBEXLSA-IHADCB)+XMTDCBI\n         OPEN  XMTDCBI,MF=(E,XMTOPN)\n         TM    DCBOFLG1,DCBOFOPN            opened?\n         BO    DCBIOPEN\n         UDIAG 0,'XMIT02A SYSUT2 OPEN error'\n         MVI   SAREASON,ERR#2               SYSUT2 didn't open\n         B     DIE                          input DCB didn't open\nDCBIOPEN DS    0H\n         UDIAG 3,'XMIT02A SYSUT2 DCB open',(R2),L$DCB\n         RDJFCB XMTDCBI,MF=(E,XMTOPN)       SYSUT2 JFCB\n         LTR   R15,R15\n         BZ    SNAPJFCB\n         ST    R15,SARC\n         UPSR  0,'XMIT02A SYSUT2 RDJFCB error; rc %',(R15)\n         MVI   SAREASON,ERR#3               SYSUT2 RDJFCB error\n         B     DIE\nSNAPJFCB DS    0H\n         LA    R3,XMTJFCB2                  switch JFCBs\n         ST    R3,XMT@JFCB                  SYSUT2 JFCB ptr\n         UDIAG 3,'XMIT02A: SYSUT2 JFCB',XMTJFCB2,L$JFCB\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\nEXIT     DS    0H\n         UDIAG 4,'XMIT02A savearea',(RSA),L$SA\n         OI    XMTFLG1,XMTF1$U              xmtdcbi now unloaded ds\n         UPSR  1,'XMIT02A exit rc',*SARC\n         UPEND RC=*SARC\n         EJECT ,\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\nPROTLIST DS    0D            prototype key list for U370KEY\nX2@UTILN DC    A(KUTILN)     addr of UTILITY NAME key info\nX2@SIZE  DC    A(KSIZE)              DATASET SIZE\nX2@DSORG DC    A(KDSORG)             DSORG\nX2@TYPE  DC    A(KTYPE)              TYPE\nX2@LRECL DC    A(KLRECL)             LRECL\nX2@BLKSZ DC    A(KBLKSZ)             BLKSIZE\nX2@RECFM DC    A(KRECFM)             RECFM\nX2@DSN   DC    A(KDSN)               DSN\nL$PROT   EQU   *-PROTLIST\n*\nMODLOPN  OPEN  (,INPUT),MF=L           model OPEN\nL$OPN    EQU   *-MODLOPN               L' model open\n*\nMODLCLOS CLOSE (,),MF=L                model CLOSE\nL$CLOS   EQU   *-MODLCLOS              L' model close\n*\nJFCBLST  DS    0F\n         DC    XL1'87'\n         DC    AL3(0)\nL$JFCBL  EQU   *-JFCBLST\n*\nCAMLST   CAMLST SEARCH,0,0,0\n*\nMODLDCBI DCB   DDNAME=SYSUT2,DSORG=PS,EXLST=JFCBLST,MACRF=R\nL$DCBI   EQU   *-MODLDCBI\n*\nMR02     DS    0D\nKUTILN   DC    AL2(INMUTILN,1,L'VUTILN)     1028 utility name\nVUTILN   DC    C'IEBCOPY'\n*\nKSIZE    DC    AL2(INMSIZE,1,L'VSIZE)       102c approx file size\nVSIZE    DC    XL4'BB60'\n*\nKDSORG   DC    AL2(INMDSORG,1,L'VDSORG)     003C dsorg\nVDSORG   DC    XL2'0200'\n*\nKTYPE    DC    AL2(INMTYPE,1,L'VTYPE)       8012 optional dataset type\nVTYPE    DC    X'00'\n*\nKLRECL   DC    AL2(INMLRECL,1,L'VLRECL)     0042 lrecl\nVLRECL   DC    AL4(80)\n*\nKBLKSZ   DC    AL2(INMBLKSZ,1,L'VBLKSZ)     0030 optional blocksize\nVBLKSZ   DC    AL4(23440)\n*\nKRECFM   DC    AL2(INMRECFM,1,L'VRECFM)     0049 recfm + pad\nVRECFM   DC    X'9000'\n*\nKDIR     DC    AL2(INMDIR,1,L'VDIR)         000C dir blocks\nVDIR     DC    XL3'000006'\n*\nVDSN     DC    AL2(INMDSNAM)                0002 optional dsname\n         DC    AL2(0)                       # dsn qualifiers\nKDSN     EQU   VDSN,4\nL$MR02   EQU   *-MR02\n*\n         LTORG ,\n         EJECT ,\n*----------------------------------------------------------------------\n*  Workarea\n*----------------------------------------------------------------------\nSAVEAREA DSECT ,\nSASA     DS    18F           savearea for anyone we call\nSARC     DS    F             most recent return code\nSAREASON DS    X\n*\nSAKEYPL  DS    0D            XMITKEY parmlist\nSA@BUF   DS    A\nSAKEY1   EQU   *\nSA@UTILN DS    A             addr of UTILITY NAME key info\nSA@SIZE  DS    A                     DATASET SIZE\nSA@DSORG DS    A                     DSORG\nSA@TYPE  DS    A                     TYPE\nSA@LRECL DS    A                     LRECL\nSA@BLKSZ DS    A                     BLKSIZE\nSA@RECFM DS    A                     RECFM\nSA@DIR   DS    A                     DIRECTORY BLOCKS\nSA@DSN   DS    A                     DSN\nSAKEYX   EQU   *-4,1         VL byte\n*\nSAKUTILN DC    AL2(INMUTILN,1,L'XUTILN)     1028 utility name\nXUTILN   DC    C'IEBCOPY'\n*\nSAKSIZE  DC    AL2(INMSIZE,1,L'XSIZE)       102c approx file size\nXSIZE    DC    XL4'BB60'\n*\nSAKDSORG DC    AL2(INMDSORG,1,L'XDSORG)     003C dsorg\nXDSORG   DC    XL2'0200'\n*\nSAKTYPE  DC    AL2(INMTYPE,1,L'XTYPE)       8012 optional dataset type\nXTYPE    DC    X'00'\n*\nSAKLRECL DC    AL2(INMLRECL,1,L'XLRECL)     0042 lrecl\nXLRECL   DC    AL4(80)\n*\nSAKBLKSZ DC    AL2(INMBLKSZ,1,L'XBLKSZ)     0030 optional blocksize\nXBLKSZ   DC    AL4(23440)\n*\nSAKRECFM DC    AL2(INMRECFM,1,L'XRECFM)     0049 recfm + pad\nXRECFM   DC    X'9000'\n*\nSAKDIR   DC    AL2(INMDIR,1,L'XDIR)         000C dir blocks\nXDIR     DC    XL3'000006'\n*\nSAKDSN   DS    AL2           DSN key\nSAQUALS  DS    AL2           DSN # qualifiers\nSADSNAM  DS    CL80          DSN count/data pairs built here\n*\nSACAML   CAMLST SEARCH,0,0,0\nL$CAMLST EQU   *-SACAML\n*\nSAPRM1   DS    A             IEBCOPY OS-parm ptr\nSAPRMOS  DS    H,CL100       IEBCOPY OS-parm\n*----------------------------------------------------------------------\nX02MR02  DS    0D            INMR02 segment\nX02SEGL  DS    X             segment length\nX02SEGF  DS    X             segment flag\nX02SEGD  DS    XL253         beginning of segment data\n         ORG   X02SEGD\nX02ID    DS    C'INMR02'\nX02NUM   DS    XL4           files # (relative 1)\n         ORG   ,\n         DS    0D\nL$SA     EQU   *-SAVEAREA\n*\n         EJECT ,\n         PRINT NOGEN\n         DXSEG ,\n         WAXMIT ,\n         DCBD  DSORG=PS,DEVD=DA\nL$DCB    EQU   *-IHADCB\n*\nJFCB     DSECT ,\n         IEFJFCBN ,\nL$JFCB   EQU   *-JFCB\n*\nDSCB1    DSECT ,\n         IECSDSL1 (1)                  FORMAT-1 DSCB\nL$DSCB1  EQU   *-DSCB1\nXMIT02A  UFINI DXDX02A,L$SA            pseudo-register\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XMIT02B": {"ttr": 15371, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\xd1\\x00\\xd1\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 209, "newlines": 209, "modlines": 0, "user": "XV0006"}, "text": "XMIT02B  TITLE 'WRITE INMR02 INMCOPY segment'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  To do: NO\n*----------------------------------------------------------------------\n         U#SET FUNC=XMIT\n*----------------------------------------------------------------------\n* Function: Collect the information for, and write the\n*           INMR02 INMCOPY segment for DSORG=PS or DSORG=PO datasets.\n*\n*           For DSORG=PO datasets, XMIT02A has already written the\n*           INMR02 IEBCOPY segment.\n*\n*           For DSORG=PS datasets, XMIT02A wasn't called;\n*           no INMR02 IEBCOPY segment is needed.\n*\n* Caller: XMITUNLD\n*\n* Entry:\n*         R0  =\n*         R1  =\n*\n* Exit:   R15 = return code\n*         R15 = 00 success\n*\n* Abends:\n*\n* Notes: XMITUNLD calls us for either DSORG=PO or DSORG=PS datasets.\n*        For DSORG=PO, XMIT02A has already unloaded the PDS using\n*        IEBCOPY, closed the PDS's DCB, and opened the DCB for\n*        IEBCOPY's unloaded dataset (as well as gotten the JFCB).\n*\n*        For DSORG=PS, XMIT370 has opened the input dataset, and\n*        gotten the JFCB.  XMIT370 has the wrong DCB attributes for\n*        a DSORG=PS dataset, since it assumes the SYSUT1 dataset will\n*        be a PDS.  For DSORG=PS, we have to reopen the DCB with the\n*        correct values.\n*----------------------------------------------------------------------\n* R2     DCB\n* R3     JFCB\n* R4\n* R5\n* R6\n* R7\n* R8\n* R9\n* R10\n* R11    XMTWA\n* R12    base reg\n* R13    savearea\n*----------------------------------------------------------------------\nERR#1    EQU   1        SYSUT1 re-OPEN error\n         TITLE ' '\n*----------------------------------------------------------------------\nXMIT02B  UPROC L=L$X02BWA,ID=X02B,WA=X02BWA,INIT=MVCL\n         UDIAG 1,'XMIT02B enter'\n*----------------------------------------------------------------------\n* Create INMR02 segment's key data\n*----------------------------------------------------------------------\n         MVI   X02SEGL,L$X02SGL                        segment length\n         MVI   X02SEGF,SEG$1+SEG$L+SEG$C               segment flags\n         MVC   X02ID,=C'INMR02'\n         MVC   X02NUM,=AL4(1)          applies to file number 1\n         MVC   X02KEY(L$MR02),MR02     copy bogus key data\n*\n* Update bogus data with (some) correct information\n*\n         L    R3,XMT@JFCB            SYSUT1/SYSUT2 JFCB\n         USING JFCB,R3\n         MVC   XSIZE,XMTESZ          estimated file size\n         MVC   XDSORG,JFCDSORG       dsorg\n         MVC   XLRECL+2(2),JFCLRECL  lrecl\n         MVC   XRECFM(1),JFCRECFM    recfm\n         MVI   XRECFM+1,2            INMCOPY INMR02's seem to have it\n         MVC   XBLKSZ+2(2),JFCBLKSI  block size\n*----------------------------------------------------------------------\n* Write INMR02 segment\n*----------------------------------------------------------------------\nWRITE02  DS    0H\n         LA    R1,X02MR02\n         UCALL XMITPUT                 write INMR02 segment\n*----------------------------------------------------------------------\n* Determine whether the XMTDCBI DCB correctly reflects the SYSUT1\n* dataset's attributes when DSORG=PS.  XMIT02A took care of the\n* DCB for DSORG=PO.\n*----------------------------------------------------------------------\n         LA    R3,XMTJFCB1             SYSUT1 JFCB\n         TM    JFCDSRG1,JFCORGPS       DSORG=PS?\n         BNO   EXIT                    no, xmit02a already fixed DCB\n*----------------------------------------------------------------------\n* Close the SYSUT1 input dataset\n*----------------------------------------------------------------------\nCLOSE    DS    0H\n         UDIAG 2,'XMIT02B close DSORG=PS SYSUT1'\n         MVC   XMTCLOS(L$CLOS),MODLCLOS     copy model CLOSE macro\n         CLOSE XMTDCBI,MF=(E,XMTCLOS)       close DSORG=PS SYSUT1\n*----------------------------------------------------------------------\n* Re-open SYSUT1 with correct DCB attributes\n* We don't need to re-read the JFCB, since it hasn't changed since\n* XMIT370 read it.\n*----------------------------------------------------------------------\nREOPEN   DS    0H\n         LA    R2,XMTDCBI\n         USING IHADCB,R2\n         MVC   XMTOPN(L$OPN),MODLOPN     copy model OPEN macro\n         MVC   XMTDCBI(L$DCBI),MODLDCBI  copy model DCB\n         MVC   DCBRECFM,JFCRECFM         copy recfm from JFCB\n         MVC   DCBLRECL,JFCLRECL         copy lrecl from JFCB\n         MVC   DCBBLKSI,JFCBLKSI         copy blksize from JFCB\n         UDIAG 3,'XMIT02B SYSUT1 reopen DCB',(R2),L$DCB\n         OPEN  ((R2)),MF=(E,XMTOPN)\n         TM    DCBOFLG1,DCBOFOPN            opened?\n         BO    DCBIOPEN\n         UDIAG 0,'XMIT02B: SYSUT1 OPEN error'\n         MVI   SAREASON,ERR#1               SYSUT1 re-open error\n         UABEND SAREASON                    input DCB didn't open\nDCBIOPEN DS    0H\n         UDIAG 3,'XMIT02B: SYSUT1 DCB open',(R2),L$DCB\n*----------------------------------------------------------------------\n* Return to caller with return code set\n*----------------------------------------------------------------------\nEXIT     DS    0H\n         UPSR  1,'XMIT02B exit rc',*X02RC\n         UPEND RC=*X02RC\n         EJECT ,\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\nMR02     DS    0X\n         DC    AL2(INMUTILN,1,L'VUTILN)     1028 utility name\nVUTILN   DC    C'INMCOPY'\n*\n         DC    AL2(INMSIZE,1,L'VSIZE)       102C approx file size\nVSIZE    DC    XL4'BB60'\n*\n         DC    AL2(INMDSORG,1,L'VDSORG)     003C dsorg\nVDSORG   DC    XL2'4000'\n*\n         DC    AL2(INMLRECL,1,L'VLRECL)     0042 lrecl\nVLRECL   DC    XL4'C30'\n*\n         DC    AL2(INMBLKSZ,1,L'VBLKSZ)     0030 optional blocksize\nVBLKSZ   DC    AL4(23440)\n*\n         DC    AL2(INMRECFM,1,L'VRECFM)     0049 recfm\nVRECFM   DC    X'4800'\nL$MR02   EQU   *-MR02\n*\nMODLDCBI DCB   DDNAME=SYSUT1,                                          +\n               DSORG=PS,               DEFINITELY                      +\n               LRECL=0,BLKSIZE=0,      FILLED in dynamically           +\n               RECFM=F,                MAYBE, maybe not                +\n               MACRF=R\nL$DCBI   EQU   *-MODLDCBI\n*\nMODLOPN  OPEN  (,INPUT),MF=L           model OPEN\nL$OPN    EQU   *-MODLOPN               l' model open\n*\nMODLCLOS CLOSE (,),MF=L                model CLOSE\nL$CLOS   EQU   *-MODLCLOS              l' model close\n         LTORG ,\n         EJECT ,\n*----------------------------------------------------------------------\n*  Workarea\n*----------------------------------------------------------------------\nX02BWA   DSECT ,\nX02SA    DS    18F\nSAREASON DS    X\n*\nX02RC    DS    F             return code\nX02MR02  DS    0D            INMR02 segment\nX02SEGL  DS    X             segment length\nX02SEGF  DS    X             segment flag\nX02SEGD  DS    XL253         beginning of segment data\n         ORG   X02SEGD\nX02ID    DS    C'INMR02'\nX02NUM   DS    XL4           files # (relative 1)\nX02KEY   DS    0X            beginning of key data\n         DC    AL2(INMUTILN,1,L'VUTILN)     1028 utility name\nXUTILN   DC    C'INMCOPY'\n         DC    AL2(INMSIZE,1,L'VSIZE)       102C approx file size\nXSIZE    DC    XL4'BB60'\n         DC    AL2(INMDSORG,1,L'VDSORG)     003C dsorg\nXDSORG   DC    XL2'4000'\n         DC    AL2(INMLRECL,1,L'VLRECL)     0042 lrecl\nXLRECL   DC    XL4'C30'\n         DC    AL2(INMBLKSZ,1,L'VBLKSZ)     0030 optional blocksize\nXBLKSZ   DC    AL4(23440)\n         DC    AL2(INMRECFM,1,L'VRECFM)     0049 recfm\nXRECFM   DC    X'4800'\nL$X02SGL EQU   *-X02MR02                    actual segment length\n         ORG   ,\n         DS    0D\nL$X02BWA EQU   *-X02BWA\n         EJECT ,\n         PRINT NOGEN\n         DXSEG ,\n         WAXMIT ,\n         DCBD  DSORG=PS,DEVD=DA\nL$DCB    EQU   *-IHADCB\n*\nJFCB     DSECT ,\n         IEFJFCBN ,\nL$JFCB   EQU   *-JFCB\n*\nXMIT02B  UFINI DXDX02B,L$X02BWA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XMIT03": {"ttr": 15619, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00\\x9e\\x00\\x9e\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 158, "newlines": 158, "modlines": 0, "user": "XV0006"}, "text": "XMIT03   TITLE 'WRITE INMR03 segment'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  To do: NO\n*----------------------------------------------------------------------\n         U#SET FUNC=XMIT\n*----------------------------------------------------------------------\n* Function: Collect the information for, and write the INMR03 segment.\n*\n* Caller: XMITUNLD\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         R0  =\n*         R1  =\n*\n* Exit:   R15 = return code\n*         R15 = 00 success\n*\n* Abends:\n*\n* Notes:  Very little of the INMR03 is \"correct\", but instead\n*         reflects values seen in typical XMI datasets.\n*----------------------------------------------------------------------\n* R2     scratch\n* R3     DVCT\n* R4     UCB associated with extent\n* R5     # extents\n* R6     DCB\n* R7     DEB, DEBDASD\n* R8     estimated file size in bytes\n* R9     JFCB for input file\n* R10\n* R11    XMTWA\n* R12    base reg\n* R13    savearea\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\nXMIT03   UPROC L=L$X03WA,ID=XM03,WA=X03WA,INIT=MVCL\n         UDIAG 1,'XMIT03 entered'\n         LA    R9,XMTJFCB1             @ SYSUT1's JFCB\n         USING JFCB,R9\n*----------------------------------------------------------------------\n* Create INMR03 segment's key data\n*----------------------------------------------------------------------\n         MVI   X03SEGL,L$X03SGL                  segment length\n         MVI   X03SEGF,SEG$1+SEG$L+SEG$C         segment flag\n         MVC   X03ID,=C'INMR03'\n         MVC   X03KEY(L$MR03),MR03     copy prototype key data\n*\n*  Update bogus key data with correct values\n*\n**       mvc   x03dsorg,jfcdsorg       dsorg - leave bogus\n**       mvc   x03recfm,jfcrecfm       recfm - leave bogus\n         MVC   X03LRECL,JFCLRECL       lrecl\n         MVC   X03ESTSZ,XMTESZ         estimated file size\n*----------------------------------------------------------------------\n* Write INMR03 segment\n*----------------------------------------------------------------------\nWRITE03  DS    0H\n         LA    R1,X03MR03\n         UCALL XMITPUT                 write INMR03 segment\nEXIT     DS    0H\n         ST    R15,X03RC\n         UDIAG 1,'XMIT03 exited'\n         L     R15,X03RC\n         UPEND  ,\n*\n         EJECT ,\n*\n*        c9d5d4d9f0f3                       *INMR03*\n*        102c 0001 0004 0000bb60            filesize\n*        003c 0001 0002 4000                DSORG=PS\n*        0042 0001 0002 0050                LRECL=80\n*        0049 0001 0002 0001                RECFM=<bogus>\n*\nMR03     DS    0X\nKSIZE    DC    AL2(INMSIZE,1,L'VSIZE)       102C approx file size bytes\nVSIZE    DC    XL4'BB60'\nLSIZE    EQU   *-KSIZE\n*\nKDSORG   DC    AL2(INMDSORG,1,L'VDSORG)     003C dsorg <bogus>\nVDSORG   DC    XL2'4000'\nLDSORG   EQU   *-KDSORG\n*\nKLRECL   DC    AL2(INMLRECL,1,L'VLRECL)     0042 lrecl\nVLRECL   DC    AL2(80)\nLLRECL   EQU   *-KLRECL\n*\nKRECFM   DC    AL2(INMRECFM,1,L'VRECFM)     004.recfm <bogus>\nVRECFM   DC    XL2'0001'\nLRECFM   EQU   *-KRECFM\nL$MR03   EQU   *-MR03\n*\n* optional keys not provided: none\n*\n*\n         LTORG ,\n*----------------------------------------------------------------------\n         EJECT ,\nX03WA    DSECT ,\nX03SA    DS    18F\n*\nX03RC    DS    F             return code\nX03MR03  DS    0D            INMR03 segment\nX03SEGL  DS    X             segment length\nX03SEGF  DS    X             segment flag\nX03SEGD  DS    XL253         beginning of segment data\n         ORG   X03SEGD\nX03ID    DS    C'INMR03'\nX03KEY   DS    0X            beginning of key data\n         DC    AL2(INMSIZE,1,L'VSIZE)       102C approx file size bytes\nX03ESTSZ DC    XL4'BB60'\n         DC    AL2(INMDSORG,1,L'VDSORG)     003C dsorg\nX03DSORG DC    XL2'4000'\n         DC    AL2(INMLRECL,1,L'VLRECL)     0042 lrecl\nX03LRECL DC    AL2(80)\n         DC    AL2(INMRECFM,1,L'VRECFM)     0049 recfm\nX03RECFM DC    XL2'0001'\nL$X03SGL EQU   *-X03MR03                    actual segment length\n         ORG   ,\n         DS    0D\nL$X03WA  EQU   *-X03WA\n*\n         EJECT ,\n         PRINT NOGEN\n         DXSEG ,\n*        EJECT ,\n         WAXMIT ,\n*        EJECT ,\n         IEZDEB LIST=YES\nL$DEBDA  EQU   (DEBNMTRK+L'DEBNMTRK)-DEBDASD     l' debdasd section\n*\n*        EJECT ,\nUCB      DSECT ,\n         IEFUCBOB LIST=YES\n*\n*        EJECT ,\n*----------------------------------------------------------------------\n*  See Stage2 assembly of IECZDTAB for values & index\n*----------------------------------------------------------------------\n         IHADVCT ,\n*\n*        EJECT ,\n         PRINT NOGEN\n         CVT   DSECT=YES,LIST=NO\n*\n         DCBD  DSORG=PS,DEVD=DA\n*\nJFCB     DSECT ,\n         IEFJFCBN ,\n         PRINT GEN\n*\nXMIT03   UFINI DXDX03,L$X03WA\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XMIT06": {"ttr": 15623, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00`\\x00`\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 96, "newlines": 96, "modlines": 0, "user": "XV0006"}, "text": "XMIT06   TITLE 'WRITE INMR06 segment'\n*\n* Copyright 2001, 2002 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  To do: NO\n*----------------------------------------------------------------------\n         U#SET FUNC=XMIT\n*----------------------------------------------------------------------\n* Function: Write the INMR06 segment.\n*\n* Caller: XMITUNLD\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         R0  =\n*         R1  =\n*\n* Exit:   R15 = return code\n*         R15 = 00 success\n*\n* Abends:\n*\n* Notes:\n*----------------------------------------------------------------------\n* R2     X06WA\n* R3\n* R4     @ segment data\n* R5     length remaining in segment data\n* R6\n* R7\n* R8\n* R9\n* R10\n* R11    XMTWA\n* R12    base reg\n* R13    savearea\n*----------------------------------------------------------------------\n         TITLE ' '\n*----------------------------------------------------------------------\nXMIT06   UPROC L=L$X06WA,ID=XM06,WA=X06WA,INIT=MVCL\n         UDIAG 1,'XMIT06 entered'\n*----------------------------------------------------------------------\n* Create INMR06\n*----------------------------------------------------------------------\n         LA    R0,L$SEG6               segment length\n         STC   R0,X06SEGL\n         MVC   X06ID,=C'INMR06'\n         MVI   X06SEGF,SEG$1+SEG$L+SEG$C\n*----------------------------------------------------------------------\n* Write INMR06 segment\n*----------------------------------------------------------------------\nWRITE    DS    0H\n         LA    R1,X06MR06\n         UCALL XMITPUT                 write INMR06 segment\n*----------------------------------------------------------------------\n* Final PUTSEG call issued, terminate PUTSEG service\n*----------------------------------------------------------------------\n         SLR   R1,R1                   PUTSEG terminate call\n         UCALL XMITPUT                 terminate PUTSEG service\n         LTR   R15,R15\n         BZ    EXIT\n*\n         MVI   X06RC+3,8\nEXIT     DS    0H\n         UDIAG 1,'XMIT06 exited'\n         L     R15,X06RC\n         UPEND ,\n*\n         LTORG ,\n*----------------------------------------------------------------------\n*\n*        c9d5d4d9 f0f6                       *INMR06*\n*\nX06WA    DSECT ,\nX06SA    DS    18F\n*\nX06RC    DS    F             return code\nX06MR06  DS    0D            INMR01 segment\nX06SEGL  DS    X             segment length\nX06SEGF  DS    X             segment flag\nX06SEGD  DS    XL253         beginning of segment data\n         ORG   X06SEGD\nX06ID    DS    C'INMR06'\nL$SEG6   EQU   *-X06MR06     length of segment written\n         ORG   ,\n         DS    0D\nL$X06WA  EQU   *-X06WA\n         EJECT ,\n         PRINT NOGEN\n         DXSEG ,\n         EJECT ,\n         WAXMIT ,\n         PRINT GEN\nXMIT06   UFINI DXDX06,L$X06WA\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XMIT370": {"ttr": 15626, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x00\\x00\\x00\\x00\\x80\\x10\\x0f\\x00\\x80\\x10\\x0f!(\\x00\\xb9\\x00\\xb9\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "00.00", "flags": 0, "createdate": "1980-04-09T00:00:00", "modifydate": "1980-04-09T21:28:00", "lines": 185, "newlines": 185, "modlines": 0, "user": "XV0006"}, "text": "         GBLC  &G#VRSN\nXMIT370  TITLE 'TSO/E TRANSMIT clone for MVS 3.8J'\n*\n*  Copyright 2001-2008 James M. Morrison\n*\n*----------------------------------------------------------------------\n*  Things to do:\n*  1)  FREEPOOL SYSUT1/SYSUT2\n*----------------------------------------------------------------------\n         U#SET FUNC=XMIT\n*----------------------------------------------------------------------\n* Function: Create a file compatible with TSO/E TRANSMIT,\n*           given an input file that is a PDS or sequential file.\n*           This version runs in batch, not as a CP.\n*\n* Entry:  AMODE=24, ASC=PRIMARY, KEY=*, STATE=*\n*\n*         R0  =\n*         R1  =  Address of OS parmlist\n*         R13 =  savearea ptr\n*         R14 =  return addr to caller\n*         R15 =  address of XMIT370\n*\n* Exit:   R15 = return code\n*         R15 = 00 success\n*\n* Abends: U0001 DCB didn't open\n*\n* Notes:\n*\n*----------------------------------------------------------------------\n* R2     XPSWA\n* R3     DCB\n* R4     OS parm ptr\n* R5\n* R6\n* R7\n* R8\n* R9\n* R10\n* R11    XMTWA    ... ALL CSECTS (contains our savearea)\n* R12    BASE REG ... ALL CSECTS (dummy for us)\n* R13    savearea\n*----------------------------------------------------------------------\nERR#1    EQU   1        not APF authorized\nERR#2    EQU   2        SYSUT1 open failed\nERR#3    EQU   3        invalid DSORG; PO or PS supported\nERR#4    EQU   4        RDJFCB failed\n         TITLE ' '\n*----------------------------------------------------------------------\nXMIT370  UPROC L=L$MAIN,ID=MAIN,CPD=(Y,0,ESTAE)\n*----------------------------------------------------------------------\n* Init XMTWA\n*----------------------------------------------------------------------\n         MVC   XMTXPSWE,=C'PUTWORK '        set XPSWA eyecatcher\n*----------------------------------------------------------------------\n*  Wake up LOG\n*----------------------------------------------------------------------\n         ULOG  'XMIT370 &G#VRSN Copyright 2001-2008, James M. Morrison'\n         ULOG  'XMIT370 may be distributed under the terms of the Q Pub+\n               lic License version 1.0'\n         ULOG  'XMIT370 Initial Developer James M. Morrison'\n         ULOG  ' '\n*----------------------------------------------------------------------\n*  Handle XMITDBUG ddname\n*----------------------------------------------------------------------\n         UCALL U370DBUG                     handle XMITDBUG ddname\n*----------------------------------------------------------------------\n*  Verify we're authorized\n*----------------------------------------------------------------------\n         TESTAUTH FCTN=1                    authorized?\n         LTR   R15,R15\n         BZ    AUTHOK\n         ULOG  'XMIT370 requires authorization'\n         MVI   SAREASON,ERR#1\nDIE      UABEND SAREASON                    surrender\nAUTHOK   DS    0H\n         UESTAE RETRY                       establish ESTAE\n*----------------------------------------------------------------------\n*  Open DCBs, complain & abend if they don't open\n*----------------------------------------------------------------------\n         MVC   XMTDCBI(L$DCBI),MODLDCBI     copy model DCB macro\n         MVC   XMTOPN(L$OPN),MODLOPN        copy model OPEN macro\n         LA    R0,XMTJFCB1                  relocate EXLST JFCB addr\n         ST    R0,XMTJFCBL\n         MVI   XMTJFCBL,X'87'               VL flag + X'07' RDJFCB\n         LA    R0,XMTJFCBL                  relocate DCB's EXLST\n         STCM  R0,7,(DCBEXLSA-IHADCB)+XMTDCBI\n         LA    R3,XMTDCBI\n         USING IHADCB,R3\n         OPEN  (XMTDCBI,INPUT),MF=(E,XMTOPN)\n         TM    DCBOFLG1,DCBOFOPN            opened?\n         BO    DCBIOPEN\n         ULOG  'XMIT370: SYSUT1 open failed'\n         MVI   SAREASON,ERR#2               input DCB didn't open\n         B     DIE\nDCBIOPEN DS    0H\n         UDIAG 3,'370: SYSUT1 DCB opened',XMTDCBI,L$DCB\n*\n* Verify DSORG=PS or DSORG=PO\n*\n         TM    DCBDSRG1,DCBDSGPS            DSORG=PS?\n         BO    ORGOK\n         TM    DCBDSRG1,DCBDSGPO            DSORG=PO?\n         BO    ORGOK\n         ULOG  'XMIT370 only support DSORG=PS or DSORG=PO datasets'\n         MVI   SAREASON,ERR#3               invalid DSORG\n         B     DIE\nORGOK    DS    0H\n*\n* We have to read the JFCB after the dataset is open,\n* otherwise the JFCB doesn't have the DSORG field filled in\n* which confuses XMITUNLD when it eventually looks at the JFCB\n*\n         RDJFCB (XMTDCBI,INPUT),MF=(E,XMTOPN)\n         LTR   R15,R15\n         BZ    HAVJFCB\n         ULOG  'XMIT370: RDJFCB failed'\n         MVI   SAREASON,ERR#4               RDJFCB failed\n         B     DIE\nHAVJFCB  DS    0H\n         UDIAG 3,'370: SYSUT1 JFCB',XMTJFCB1,L$JFCB\n         LA    R0,XMTJFCB1\n         ST    R0,XMT@JFCB                  @ SYSUT1's JFCB\n*----------------------------------------------------------------------\n*  Unload SYSUT1 and write segments\n*----------------------------------------------------------------------\n         L     R14,XMT#FILE\n         LA    R14,1(,R14)                  bump file number\n         ST    R14,XMT#FILE\n         UCALL XMITUNLD,ERR=EXIT\n*----------------------------------------------------------------------\n*  Return to caller\n*----------------------------------------------------------------------\nEXIT     UPEND RC=*XMTRC                    provide return code\n*----------------------------------------------------------------------\n*  ESTAE retry routine\n*----------------------------------------------------------------------\nRETRY    DS    0H\n         ULOG  'XMIT370 ABENDed'\n         LA    R3,20\n         ST    R3,XMTRC\n         B     EXIT\n*----------------------------------------------------------------------\n*  Data areas\n*----------------------------------------------------------------------\n         LTORG ,\n*\nMODLOPN  OPEN  (,),MF=L                model OPEN\nL$OPN    EQU   *-MODLOPN               l' model open\n*\n* If the SYSUT1 dataset is DSORG=PS, XMIT02B needs it opened\n* If the SYSUT1 dataset is DSORG=PO, XMIT02A deals with closing\n* and reopening the dataset.  The DCB below reflects DCB attributes\n* that may not be true, but all the rest of our code examines the\n* JFCB rather than the DCB to determine DCB attributes, so we should\n* be ok.\n*\nMODLDCBI DCB   DDNAME=SYSUT1,DSORG=PS,LRECL=256,BLKSIZE=256,RECFM=F,   +\n               EXLST=0,MACRF=R\nL$DCBI   EQU   *-MODLDCBI\n*\n         EJECT ,\n*----------------------------------------------------------------------\n         WAXMIT PRINT=ON,GEN=\n         EJECT ,\n         DXSEG ,\n         EJECT ,\nSAVEAREA DSECT ,\n         DS    18F           dummy \"main\" proc savearea\nSAREASON DS    X\n         DS    0D\nL$MAIN   EQU   *-SAVEAREA\n*\n         PRINT NOGEN\n         DCBD  DSORG=PS,DEVD=DA\nL$DCB    EQU   *-IHADCB\n*\nJFCB     DSECT ,\n         IEFJFCBN ,\nL$JFCB   EQU   *-JFCB\n         PRINT GEN\nXMIT370  UFINI DXDX370,L$XMTWA,ID=TGD\nXMIT370  UFINI DXDMAIN,L$MAIN\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZTEST": {"ttr": 15630, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x021o\\x01\\x021o\\x10\"\\x00&\\x00&\\x00\\x00\\xe7\\xe5\\xf0\\xf0\\xf0\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T10:22:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "XV0006"}, "text": "*\n* Copyright 2001, 2002 James M. Morrison\n*\n         MACRO\n         XTEST &JUNK,&V=\n         LCLC &A(2),&B\n         MNOTE *,'XTEST V(1)    + &V(1) +'\n         MNOTE *,'XTEST V(2)    + &V(2) +'\n&A(1)    SETC  '&V(1)'(2,1)\n&A(2)    SETC  '&V(1)'(4,1)\n.*\n&B       SETC  '&V(2)'\n&B       SETC  '&B'(2,K'&B-2)\n         MNOTE *,'XTEST A(1)=&A(1) A(2)=&A(2) B=&B'\n         BOGUS (&A(1),&A(2)),(&B)\n         MEND\n*\n         MACRO\n         BOGUS &J,&K\n         MNOTE *,'SYSLIST(1)    + &SYSLIST(1) + SHOULD BE (A,B)'\n         MNOTE *,'SYSLIST(2)    + &SYSLIST(2) + SHOULD BE (X,Y)'\n         MNOTE *,'SYSLIST(1,1)  + &SYSLIST(1,1) + SHOULD BE A'\n         MNOTE *,'SYSLIST(1,2)  + &SYSLIST(1,2) + SHOULD BE B'\n         MNOTE *,'SYSLIST(2,1)  + &SYSLIST(2,1) + SHOULD BE X'\n         MNOTE *,'SYSLIST(2,2)  + &SYSLIST(2,2) + SHOULD BE Y'\n         MNOTE *,'J             + &J    + SHOULD BE (A,B)'\n         MNOTE *,'K             + &K    + SHOULD BE (X,Y)'\n         MNOTE *,'J(1)          + &J(1) +  SHOULD BE A'\n         MNOTE *,'J(2)          + &J(2) +  SHOULD BE B'\n         MNOTE *,'K(1)          + &K(1) +  SHOULD BE X'\n         MNOTE *,'K(2)          + &K(2) +  SHOULD BE Y'\n         MEND\n         EJECT\nBOGUS    CSECT ,\n         USING *,15\n         XTEST X,V=((A,B),(X,Y))\n         BOGUS (A,B),(X,Y)\n         END   ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT571/FILE571.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT571", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}